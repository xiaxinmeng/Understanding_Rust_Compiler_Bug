{"sha": "e24329cdf00e258cfb48e84f55bbd4903cc48939", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI0MzI5Y2RmMDBlMjU4Y2ZiNDhlODRmNTViYmQ0OTAzY2M0ODkzOQ==", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2011-08-02T10:21:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T10:21:47Z"}, "message": "par-ch6.adb: Correct obsolete name in comments\n\n2011-08-02  Yannick Moy  <moy@adacore.com>\n\n\t* par-ch6.adb: Correct obsolete name in comments\n\t* restrict.adb, restrict.ads (Check_Formal_Restriction): new function\n\twhich takes two message arguments (existing function takes one), with\n\tsecond message used for continuation.\n\t* sem_ch5.adb (Analyze_Block_Statement): in formal mode, only reject\n\tblock statements that originate from a source block statement, not\n\tgenerated block statements\n\t* sem_ch6.adb (Analyze_Function_Call): rename L into Actuals, for\n\tsymmetry with procedure case\n\t* sem_ch7.adb (Check_One_Tagged_Type_Or_Extension_At_Most): new\n\tfunction to issue an error in formal mode if a package specification\n\tcontains more than one tagged type or type extension.\n\t* sem_res.adb (Resolve_Actuals): in formal mode, check that actual\n\tparameters matching formals of tagged types are objects (or ancestor\n\ttype conversions of objects), not general expressions. Issue an error\n\ton view conversions that are not involving ancestor conversion of an\n\textended type.\n\t(Resolve_Type_Conversion): in formal mode, issue an error on the\n\toperand of an ancestor type conversion which is not an object\n\t* sem_util.adb, sem_util.ads (Find_Actual): extend the behavior of the\n\tprocedure so that it works also for actuals of function calls\n\t(Is_Actual_Tagged_Parameter): new function which determines if its\n\targument is an actual parameter of a formal of tagged type in a\n\tsubprogram call\n\t(Is_SPARK_Object_Reference): new function which determines if the tree\n\treferenced by its argument represents an object in SPARK\n\nFrom-SVN: r177125", "tree": {"sha": "6e6be6347d2e4a0f8831778d9a190954fe41d3cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e6be6347d2e4a0f8831778d9a190954fe41d3cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e24329cdf00e258cfb48e84f55bbd4903cc48939", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e24329cdf00e258cfb48e84f55bbd4903cc48939", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e24329cdf00e258cfb48e84f55bbd4903cc48939", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e24329cdf00e258cfb48e84f55bbd4903cc48939/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "176dadf6396a67fb74572ceb74c1e66520adbd51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/176dadf6396a67fb74572ceb74c1e66520adbd51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/176dadf6396a67fb74572ceb74c1e66520adbd51"}], "stats": {"total": 270, "additions": 237, "deletions": 33}, "files": [{"sha": "6507dea5a22bbd767874165aed7f5be7cd30a3aa", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e24329cdf00e258cfb48e84f55bbd4903cc48939", "patch": "@@ -1,3 +1,32 @@\n+2011-08-02  Yannick Moy  <moy@adacore.com>\n+\n+\t* par-ch6.adb: Correct obsolete name in comments\n+\t* restrict.adb, restrict.ads (Check_Formal_Restriction): new function\n+\twhich takes two message arguments (existing function takes one), with\n+\tsecond message used for continuation.\n+\t* sem_ch5.adb (Analyze_Block_Statement): in formal mode, only reject\n+\tblock statements that originate from a source block statement, not\n+\tgenerated block statements\n+\t* sem_ch6.adb (Analyze_Function_Call): rename L into Actuals, for\n+\tsymmetry with procedure case\n+\t* sem_ch7.adb (Check_One_Tagged_Type_Or_Extension_At_Most): new\n+\tfunction to issue an error in formal mode if a package specification\n+\tcontains more than one tagged type or type extension.\n+\t* sem_res.adb (Resolve_Actuals): in formal mode, check that actual\n+\tparameters matching formals of tagged types are objects (or ancestor\n+\ttype conversions of objects), not general expressions. Issue an error\n+\ton view conversions that are not involving ancestor conversion of an\n+\textended type.\n+\t(Resolve_Type_Conversion): in formal mode, issue an error on the\n+\toperand of an ancestor type conversion which is not an object\n+\t* sem_util.adb, sem_util.ads (Find_Actual): extend the behavior of the\n+\tprocedure so that it works also for actuals of function calls\n+\t(Is_Actual_Tagged_Parameter): new function which determines if its\n+\targument is an actual parameter of a formal of tagged type in a\n+\tsubprogram call\n+\t(Is_SPARK_Object_Reference): new function which determines if the tree\n+\treferenced by its argument represents an object in SPARK\n+\n 2011-08-02  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch3.adb: Minor reformatting"}, {"sha": "bcb6161fdd44ac46b61f93930587f866597bb771", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=e24329cdf00e258cfb48e84f55bbd4903cc48939", "patch": "@@ -1492,25 +1492,25 @@ package body Ch6 is\n    -- 6.4  Function Call --\n    ------------------------\n \n-   --  Parsed by P_Call_Or_Name (4.1)\n+   --  Parsed by P_Name (4.1)\n \n    --------------------------------\n    -- 6.4  Actual Parameter Part --\n    --------------------------------\n \n-   --  Parsed by P_Call_Or_Name (4.1)\n+   --  Parsed by P_Name (4.1)\n \n    --------------------------------\n    -- 6.4  Parameter Association --\n    --------------------------------\n \n-   --  Parsed by P_Call_Or_Name (4.1)\n+   --  Parsed by P_Name (4.1)\n \n    ------------------------------------\n    -- 6.4  Explicit Actual Parameter --\n    ------------------------------------\n \n-   --  Parsed by P_Call_Or_Name (4.1)\n+   --  Parsed by P_Name (4.1)\n \n    ---------------------------\n    -- 6.5  Return Statement --"}, {"sha": "5a9f0b24cc36427655cac15d43670892506dd954", "filename": "gcc/ada/restrict.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=e24329cdf00e258cfb48e84f55bbd4903cc48939", "patch": "@@ -118,6 +118,18 @@ package body Restrict is\n       end if;\n    end Check_Formal_Restriction;\n \n+   procedure Check_Formal_Restriction (Msg1, Msg2 : String; N : Node_Id) is\n+   begin\n+      pragma Assert (Msg2'Length /= 0 and then Msg2 (Msg2'First) = '\\');\n+\n+      if Formal_Verification_Mode\n+        and then Comes_From_Source (Original_Node (N))\n+      then\n+         Error_Msg_F (\"|~~\" & Msg1, N);\n+         Error_Msg_F (Msg2, N);\n+      end if;\n+   end Check_Formal_Restriction;\n+\n    -----------------------------------------\n    -- Check_Implicit_Dynamic_Code_Allowed --\n    -----------------------------------------"}, {"sha": "c006fd6feb145b6469ed108be5b09fe75679cb97", "filename": "gcc/ada/restrict.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2Frestrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2Frestrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.ads?ref=e24329cdf00e258cfb48e84f55bbd4903cc48939", "patch": "@@ -225,6 +225,10 @@ package Restrict is\n    --  \"|~~\" (error not serious, language prepended). Call has no effect if\n    --  not in formal mode, or if N does not come originally from source.\n \n+   procedure Check_Formal_Restriction (Msg1, Msg2 : String; N : Node_Id);\n+   --  Same as Check_Formal_Restriction except there is a continuation message\n+   --  Msg2 following the initial message Msg1.\n+\n    procedure Check_Implicit_Dynamic_Code_Allowed (N : Node_Id);\n    --  Tests to see if dynamic code generation (dynamically generated\n    --  trampolines, in particular) is allowed by the current restrictions"}, {"sha": "2bf338325156dc323824dd6410e64c66b087bd65", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=e24329cdf00e258cfb48e84f55bbd4903cc48939", "patch": "@@ -807,7 +807,12 @@ package body Sem_Ch5 is\n       HSS   : constant Node_Id := Handled_Statement_Sequence (N);\n \n    begin\n-      Check_Formal_Restriction (\"block statement is not allowed\", N);\n+      --  Only reject block statements that originate from a source block\n+      --  statement, in formal mode.\n+\n+      if Nkind (Original_Node (N)) = N_Block_Statement then\n+         Check_Formal_Restriction (\"block statement is not allowed\", N);\n+      end if;\n \n       --  If no handled statement sequence is present, things are really messed\n       --  up, and we just return immediately (defence against previous errors)."}, {"sha": "c0b17fe325f7115ea90070e2bd941ab99f7d43f3", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=e24329cdf00e258cfb48e84f55bbd4903cc48939", "patch": "@@ -325,9 +325,9 @@ package body Sem_Ch6 is\n    ----------------------------\n \n    procedure Analyze_Function_Call (N : Node_Id) is\n-      P      : constant Node_Id := Name (N);\n-      L      : constant List_Id := Parameter_Associations (N);\n-      Actual : Node_Id;\n+      P       : constant Node_Id := Name (N);\n+      Actuals : constant List_Id := Parameter_Associations (N);\n+      Actual  : Node_Id;\n \n    begin\n       Analyze (P);\n@@ -353,8 +353,8 @@ package body Sem_Ch6 is\n \n       --  Otherwise analyze the parameters\n \n-      if Present (L) then\n-         Actual := First (L);\n+      if Present (Actuals) then\n+         Actual := First (Actuals);\n          while Present (Actual) loop\n             Analyze (Actual);\n             Check_Parameterless_Call (Actual);"}, {"sha": "1fbaacd0b8df8e7b7b6395ead482908f44f79f5e", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=e24329cdf00e258cfb48e84f55bbd4903cc48939", "patch": "@@ -43,6 +43,7 @@ with Nmake;    use Nmake;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n with Output;   use Output;\n+with Restrict; use Restrict;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Cat;  use Sem_Cat;\n@@ -873,6 +874,11 @@ package body Sem_Ch7 is\n       --  private_with_clauses, and remove them at the end of the nested\n       --  package.\n \n+      procedure Check_One_Tagged_Type_Or_Extension_At_Most;\n+      --  Issue an error in formal mode if a package specification contains\n+      --  more than one tagged type or type extension. This is a restriction of\n+      --  SPARK.\n+\n       procedure Clear_Constants (Id : Entity_Id; FE : Entity_Id);\n       --  Clears constant indications (Never_Set_In_Source, Constant_Value, and\n       --  Is_True_Constant) on all variables that are entities of Id, and on\n@@ -901,6 +907,56 @@ package body Sem_Ch7 is\n       --  private part rather than being done in Sem_Ch12.Install_Parent\n       --  (which is where the parents' visible declarations are installed).\n \n+      ------------------------------------------------\n+      -- Check_One_Tagged_Type_Or_Extension_At_Most --\n+      ------------------------------------------------\n+\n+      procedure Check_One_Tagged_Type_Or_Extension_At_Most is\n+         Previous : Node_Id;\n+\n+         procedure Check_Decls (Decls : List_Id);\n+         --  Check that either Previous is Empty and Decls does not contain\n+         --  more than one tagged type or type extension, or Previous is\n+         --  already set and Decls contains no tagged type or type extension.\n+\n+         -----------------\n+         -- Check_Decls --\n+         -----------------\n+\n+         procedure Check_Decls (Decls : List_Id) is\n+            Decl : Node_Id;\n+         begin\n+            Decl := First (Decls);\n+            while Present (Decl) loop\n+               if Nkind (Decl) = N_Full_Type_Declaration\n+                 and then Is_Tagged_Type (Defining_Identifier (Decl))\n+               then\n+                  if No (Previous) then\n+                     Previous := Decl;\n+                  else\n+                     Error_Msg_Sloc := Sloc (Previous);\n+                     Check_Formal_Restriction\n+                       (\"at most one tagged type or type extension allowed\",\n+                        \"\\\\ previous declaration#\",\n+                        Decl);\n+                  end if;\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+         end Check_Decls;\n+\n+      --  Start of processing for Check_One_Tagged_Type_Or_Extension_At_Most\n+\n+      begin\n+         Previous := Empty;\n+         Check_Decls (Vis_Decls);\n+\n+         if Present (Priv_Decls) then\n+            Check_Decls (Priv_Decls);\n+         end if;\n+      end Check_One_Tagged_Type_Or_Extension_At_Most;\n+\n       ---------------------\n       -- Clear_Constants --\n       ---------------------\n@@ -1383,6 +1439,8 @@ package body Sem_Ch7 is\n          Clear_Constants (Id, First_Entity (Id));\n          Clear_Constants (Id, First_Private_Entity (Id));\n       end if;\n+\n+      Check_One_Tagged_Type_Or_Extension_At_Most;\n    end Analyze_Package_Specification;\n \n    --------------------------------------"}, {"sha": "fa938c188d1b69a8a4652fb40f50f453b4de5bfb", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 70, "deletions": 16, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=e24329cdf00e258cfb48e84f55bbd4903cc48939", "patch": "@@ -3585,29 +3585,70 @@ package body Sem_Res is\n             A_Typ := Etype (A);\n             F_Typ := Etype (F);\n \n-            --  In SPARK or ALFA, the only view conversions are those involving\n-            --  ancestor conversion of an extended type.\n-\n-            if Nkind (A) = N_Type_Conversion\n-              and then Ekind_In (F, E_Out_Parameter, E_In_Out_Parameter)\n+            if Comes_From_Source (Original_Node (N))\n+              and then Nkind_In (Original_Node (N),\n+                                 N_Function_Call,\n+                                 N_Procedure_Call_Statement)\n             then\n-               declare\n-                  Operand     : constant Node_Id   := Expression (A);\n-                  Operand_Typ : constant Entity_Id := Etype (Operand);\n-                  Target_Typ  : constant Entity_Id := A_Typ;\n+               --  In formal mode, check that actual parameters matching\n+               --  formals of tagged types are objects (or ancestor type\n+               --  conversions of objects), not general expressions.\n \n-               begin\n-                  if not (Is_Tagged_Type (Target_Typ)\n+               if Is_Actual_Tagged_Parameter (A) then\n+                  if Is_SPARK_Object_Reference (A) then\n+                     null;\n+\n+                  elsif Nkind (A) = N_Type_Conversion then\n+                     declare\n+                        Operand     : constant Node_Id   := Expression (A);\n+                        Operand_Typ : constant Entity_Id := Etype (Operand);\n+                        Target_Typ  : constant Entity_Id := A_Typ;\n+\n+                     begin\n+                        if not Is_SPARK_Object_Reference (Operand) then\n+                           Check_Formal_Restriction\n+                             (\"object required\", Operand);\n+\n+                        --  In formal mode, the only view conversions are those\n+                        --  involving ancestor conversion of an extended type.\n+\n+                        elsif not\n+                          (Is_Tagged_Type (Target_Typ)\n                            and then not Is_Class_Wide_Type (Target_Typ)\n                            and then Is_Tagged_Type (Operand_Typ)\n                            and then not Is_Class_Wide_Type (Operand_Typ)\n                            and then Is_Ancestor (Target_Typ, Operand_Typ))\n-                  then\n-                     Check_Formal_Restriction\n-                       (\"ancestor conversion is the only permitted view \"\n-                        & \"conversion\", A);\n+                        then\n+                           if Ekind_In\n+                             (F, E_Out_Parameter, E_In_Out_Parameter)\n+                           then\n+                              Check_Formal_Restriction\n+                                (\"ancestor conversion is the only permitted \"\n+                                 & \"view conversion\", A);\n+                           else\n+                              Check_Formal_Restriction\n+                                (\"ancestor conversion required\", A);\n+                           end if;\n+\n+                        else\n+                           null;\n+                        end if;\n+                     end;\n+\n+                  else\n+                     Check_Formal_Restriction (\"object required\", A);\n                   end if;\n-               end;\n+\n+               --  In formal mode, the only view conversions are those\n+               --  involving ancestor conversion of an extended type.\n+\n+               elsif Nkind (A) = N_Type_Conversion\n+                 and then Ekind_In (F, E_Out_Parameter, E_In_Out_Parameter)\n+               then\n+                  Check_Formal_Restriction\n+                    (\"ancestor conversion is the only permitted view \"\n+                     & \"conversion\", A);\n+               end if;\n             end if;\n \n             --  Save actual for subsequent check on order dependence, and\n@@ -9056,6 +9097,19 @@ package body Sem_Res is\n            (\"array types should have matching static bounds\", N);\n       end if;\n \n+      --  In formal mode, the operand of an ancestor type conversion must be an\n+      --  object (not an expression).\n+\n+      if Is_Tagged_Type (Target_Typ)\n+        and then not Is_Class_Wide_Type (Target_Typ)\n+        and then Is_Tagged_Type (Operand_Typ)\n+        and then not Is_Class_Wide_Type (Operand_Typ)\n+        and then Is_Ancestor (Target_Typ, Operand_Typ)\n+        and then not Is_SPARK_Object_Reference (Operand)\n+      then\n+         Check_Formal_Restriction (\"object required\", Operand);\n+      end if;\n+\n       --  Note: we do the Eval_Type_Conversion call before applying the\n       --  required checks for a subtype conversion. This is important, since\n       --  both are prepared under certain circumstances to change the type"}, {"sha": "15e978f4892e22dc047062ecc7b351fc6a52096b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=e24329cdf00e258cfb48e84f55bbd4903cc48939", "patch": "@@ -3359,7 +3359,7 @@ package body Sem_Util is\n       then\n          Call := Parent (Parnt);\n \n-      elsif Nkind (Parnt) = N_Procedure_Call_Statement then\n+      elsif Nkind_In (Parnt, N_Procedure_Call_Statement, N_Function_Call) then\n          Call := Parnt;\n \n       else\n@@ -5883,6 +5883,18 @@ package body Sem_Util is\n       end case;\n    end Is_Actual_Parameter;\n \n+   --------------------------------\n+   -- Is_Actual_Tagged_Parameter --\n+   --------------------------------\n+\n+   function Is_Actual_Tagged_Parameter (N : Node_Id) return Boolean is\n+      Formal : Entity_Id;\n+      Call   : Node_Id;\n+   begin\n+      Find_Actual (N, Formal, Call);\n+      return Present (Formal) and then Is_Tagged_Type (Etype (Formal));\n+   end Is_Actual_Tagged_Parameter;\n+\n    ---------------------\n    -- Is_Aliased_View --\n    ---------------------\n@@ -6833,6 +6845,29 @@ package body Sem_Util is\n       end if;\n    end Is_Object_Reference;\n \n+   -------------------------------\n+   -- Is_SPARK_Object_Reference --\n+   -------------------------------\n+\n+   function Is_SPARK_Object_Reference (N : Node_Id) return Boolean is\n+   begin\n+      if Is_Entity_Name (N) then\n+         return Present (Entity (N))\n+           and then\n+             (Ekind_In (Entity (N), E_Constant, E_Variable)\n+              or else Ekind (Entity (N)) in Formal_Kind);\n+\n+      else\n+         case Nkind (N) is\n+            when N_Selected_Component =>\n+               return Is_SPARK_Object_Reference (Prefix (N));\n+\n+            when others =>\n+               return False;\n+         end case;\n+      end if;\n+   end Is_SPARK_Object_Reference;\n+\n    -----------------------------------\n    -- Is_OK_Variable_For_Out_Formal --\n    -----------------------------------"}, {"sha": "c908d8853610a32cfdfa2ed7deed49465e1a795b", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24329cdf00e258cfb48e84f55bbd4903cc48939/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=e24329cdf00e258cfb48e84f55bbd4903cc48939", "patch": "@@ -353,12 +353,12 @@ package Sem_Util is\n      (N      : Node_Id;\n       Formal : out Entity_Id;\n       Call   : out Node_Id);\n-   --  Determines if the node N is an actual parameter of a procedure call. If\n-   --  so, then Formal points to the entity for the formal (whose Ekind is one\n-   --  of E_In_Parameter, E_Out_Parameter, E_In_Out_Parameter) and Call is set\n-   --  to the node for the corresponding call. If the node N is not an actual\n-   --  parameter, or is an actual parameter of a function call, then Formal and\n-   --  Call are set to Empty.\n+   --  Determines if the node N is an actual parameter of a function of a\n+   --  procedure call. If so, then Formal points to the entity for the formal\n+   --  (whose Ekind is one of E_In_Parameter, E_Out_Parameter,\n+   --  E_In_Out_Parameter) and Call is set to the node for the corresponding\n+   --  call. If the node N is not an actual parameter then Formal and Call are\n+   --  set to Empty.\n \n    function Find_Corresponding_Discriminant\n      (Id   : Node_Id;\n@@ -677,6 +677,10 @@ package Sem_Util is\n    function Is_Actual_Parameter (N : Node_Id) return Boolean;\n    --  Determines if N is an actual parameter in a subprogram call\n \n+   function Is_Actual_Tagged_Parameter (N : Node_Id) return Boolean;\n+   --  Determines if N is an actual parameter of a formal of tagged type in a\n+   --  subprogram call.\n+\n    function Is_Aliased_View (Obj : Node_Id) return Boolean;\n    --  Determine if Obj is an aliased view, i.e. the name of an object to which\n    --  'Access or 'Unchecked_Access can apply.\n@@ -763,6 +767,9 @@ package Sem_Util is\n    --  Determines if the tree referenced by N represents an object. Both\n    --  variable and constant objects return True (compare Is_Variable).\n \n+   function Is_SPARK_Object_Reference (N : Node_Id) return Boolean;\n+   --  Determines if the tree referenced by N represents an object in SPARK.\n+\n    function Is_OK_Variable_For_Out_Formal (AV : Node_Id) return Boolean;\n    --  Used to test if AV is an acceptable formal for an OUT or IN OUT formal.\n    --  Note that the Is_Variable function is not quite the right test because"}]}