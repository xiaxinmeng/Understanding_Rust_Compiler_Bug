{"sha": "5ea0f26bab31e63aaab85eee25250eddb753486f", "node_id": "C_kwDOANBUbNoAKDVlYTBmMjZiYWIzMWU2M2FhYWI4NWVlZTI1MjUwZWRkYjc1MzQ4NmY", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-01-16T19:27:36Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-02-05T00:10:47Z"}, "message": "gccrs: Refactor all code out of the rust-tyty.h header\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>\n\ngcc/rust/ChangeLog:\n\n\t* typecheck/rust-hir-type-check.h: refactor\n\t* typecheck/rust-tyctx.cc (TypeCheckContext::iterate): refactor\n\t(TypeCheckContext::have_loop_context): likewise\n\t(TypeCheckContext::push_new_loop_context): likewise\n\t(TypeCheckContext::push_new_while_loop_context): likewise\n\t(TypeCheckContext::peek_loop_context): likewise\n\t(TypeCheckContext::pop_loop_context): likewise\n\t(TypeCheckContext::swap_head_loop_context): likewise\n\t(TypeCheckContext::insert_trait_reference): likewise\n\t(TypeCheckContext::lookup_trait_reference): likewise\n\t(TypeCheckContext::insert_receiver): likewise\n\t(TypeCheckContext::lookup_receiver): likewise\n\t(TypeCheckContext::insert_associated_type_mapping): likewise\n\t(TypeCheckContext::clear_associated_type_mapping): likewise\n\t(TypeCheckContext::lookup_associated_type_mapping): likewise\n\t(TypeCheckContext::insert_variant_definition): likewise\n\t(TypeCheckContext::lookup_variant_definition): likewise\n\t(TypeCheckContext::insert_operator_overload): likewise\n\t(TypeCheckContext::lookup_operator_overload): likewise\n\t(TypeCheckContext::insert_unconstrained_check_marker): likewise\n\t(TypeCheckContext::have_checked_for_unconstrained): likewise\n\t(TypeCheckContext::insert_resolved_predicate): likewise\n\t(TypeCheckContext::lookup_predicate): likewise\n\t(TypeCheckContext::insert_query): likewise\n\t(TypeCheckContext::query_completed): likewise\n\t(TypeCheckContext::query_in_progress): likewise\n\t(TypeCheckContext::insert_trait_query): likewise\n\t(TypeCheckContext::trait_query_completed): likewise\n\t(TypeCheckContext::trait_query_in_progress): likewise\n\t(TypeCheckContextItem::Item::Item): likewise\n\t(TypeCheckContextItem::TypeCheckContextItem): likewise\n\t(TypeCheckContextItem::get_item): likewise\n\t(TypeCheckContextItem::get_impl_item): likewise\n\t(TypeCheckContextItem::get_trait_item): likewise\n\t(TypeCheckContextItem::get_type): likewise\n\t* typecheck/rust-tyty.cc (StructFieldType::StructFieldType): likewise\n\t(StructFieldType::get_ref): likewise\n\t(StructFieldType::get_name): likewise\n\t(StructFieldType::get_field_type): likewise\n\t(StructFieldType::set_field_type): likewise\n\t(StructFieldType::is_concrete): likewise\n\t(StructFieldType::debug): likewise\n\t(StructFieldType::get_locus): likewise\n\t(VariantDef::variant_type_string): likewise\n\t(VariantDef::VariantDef): likewise\n\t(VariantDef::operator=): likewise\n\t(VariantDef::get_error_node): likewise\n\t(VariantDef::is_error): likewise\n\t(VariantDef::get_id): likewise\n\t(VariantDef::get_defid): likewise\n\t(VariantDef::get_variant_type): likewise\n\t(VariantDef::is_data_variant): likewise\n\t(VariantDef::is_dataless_variant): likewise\n\t(VariantDef::get_identifier): likewise\n\t(VariantDef::num_fields): likewise\n\t(VariantDef::get_field_at_index): likewise\n\t(VariantDef::get_fields): likewise\n\t(VariantDef::lookup_field): likewise\n\t(VariantDef::get_discriminant): likewise\n\t(VariantDef::as_string): likewise\n\t(VariantDef::is_equal): likewise\n\t(VariantDef::clone): likewise\n\t(VariantDef::monomorphized_clone): likewise\n\t(VariantDef::get_ident): likewise\n\t(TupleType::TupleType): likewise\n\t(TupleType::get_unit_type): likewise\n\t(TupleType::is_unit): likewise\n\t(TupleType::num_fields): likewise\n\t(TupleType::is_concrete): likewise\n\t(TupleType::get_fields): likewise\n\t(BoolType::BoolType): likewise\n\t(BoolType::get_name): likewise\n\t(BoolType::is_concrete): likewise\n\t(IntType::IntType): likewise\n\t(IntType::get_name): likewise\n\t(IntType::get_int_kind): likewise\n\t(IntType::is_concrete): likewise\n\t(UintType::UintType): likewise\n\t(UintType::get_name): likewise\n\t(UintType::get_uint_kind): likewise\n\t(UintType::is_concrete): likewise\n\t(FloatType::FloatType): likewise\n\t(FloatType::get_name): likewise\n\t(FloatType::get_float_kind): likewise\n\t(FloatType::is_concrete): likewise\n\t(USizeType::USizeType): likewise\n\t(USizeType::get_name): likewise\n\t(USizeType::is_concrete): likewise\n\t(ISizeType::ISizeType): likewise\n\t(ISizeType::get_name): likewise\n\t(ISizeType::is_concrete): likewise\n\t(CharType::CharType): likewise\n\t(CharType::is_concrete): likewise\n\t(CharType::get_name): likewise\n\t(ReferenceType::ReferenceType): likewise\n\t(ReferenceType::is_concrete): likewise\n\t(ReferenceType::mutability): likewise\n\t(ReferenceType::is_mutable): likewise\n\t(ReferenceType::is_dyn_object): likewise\n\t(ReferenceType::is_dyn_slice_type): likewise\n\t(ReferenceType::is_dyn_str_type): likewise\n\t(PointerType::PointerType): likewise\n\t(PointerType::is_concrete): likewise\n\t(PointerType::mutability): likewise\n\t(PointerType::is_mutable): likewise\n\t(PointerType::is_const): likewise\n\t(PointerType::is_dyn_object): likewise\n\t(PointerType::is_dyn_slice_type): likewise\n\t(PointerType::is_dyn_str_type): likewise\n\t(ParamType::ParamType): likewise\n\t(ParamType::get_generic_param): likewise\n\t(ParamType::can_resolve): likewise\n\t(ParamType::is_concrete): likewise\n\t(StrType::StrType): likewise\n\t(StrType::get_name): likewise\n\t(StrType::is_concrete): likewise\n\t(NeverType::NeverType): likewise\n\t(NeverType::get_name): likewise\n\t(NeverType::is_unit): likewise\n\t(NeverType::is_concrete): likewise\n\t(PlaceholderType::PlaceholderType): likewise\n\t(PlaceholderType::get_name): likewise\n\t(PlaceholderType::is_unit): likewise\n\t(PlaceholderType::get_symbol): likewise\n\t(PlaceholderType::is_concrete): likewise\n\t(ProjectionType::is_unit): likewise\n\t(ProjectionType::get_name): likewise\n\t(ProjectionType::needs_generic_substitutions): likewise\n\t(ProjectionType::supports_substitutions): likewise\n\t(ProjectionType::has_subsititions_defined): likewise\n\t(ProjectionType::get): likewise\n\t(ProjectionType::is_concrete): likewise\n\t(DynamicObjectType::is_concrete): likewise\n\t* typecheck/rust-tyty.h: likewise", "tree": {"sha": "10e68ab0b756ce5472cec70344307831a583dae3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10e68ab0b756ce5472cec70344307831a583dae3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ea0f26bab31e63aaab85eee25250eddb753486f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ea0f26bab31e63aaab85eee25250eddb753486f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ea0f26bab31e63aaab85eee25250eddb753486f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ea0f26bab31e63aaab85eee25250eddb753486f/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5d70e3fa6e66798b1f2eca4b9aa3821ae4dc0c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5d70e3fa6e66798b1f2eca4b9aa3821ae4dc0c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5d70e3fa6e66798b1f2eca4b9aa3821ae4dc0c5"}], "stats": {"total": 2338, "additions": 1508, "deletions": 830}, "files": [{"sha": "8e5c8f681d1ba9913e48e6a37567a1e14492967d", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 48, "deletions": 284, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ea0f26bab31e63aaab85eee25250eddb753486f/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ea0f26bab31e63aaab85eee25250eddb753486f/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=5ea0f26bab31e63aaab85eee25250eddb753486f", "patch": "@@ -38,37 +38,17 @@ class TypeCheckContextItem\n     TRAIT_ITEM,\n   };\n \n-  TypeCheckContextItem (HIR::Function *item)\n-    : type (ItemType::ITEM), item (item)\n-  {}\n+  TypeCheckContextItem (HIR::Function *item);\n+  TypeCheckContextItem (HIR::ImplBlock *impl_block, HIR::Function *item);\n+  TypeCheckContextItem (HIR::TraitItemFunc *trait_item);\n \n-  TypeCheckContextItem (HIR::ImplBlock *impl_block, HIR::Function *item)\n-    : type (ItemType::IMPL_ITEM), item (impl_block, item)\n-  {}\n+  ItemType get_type () const;\n \n-  TypeCheckContextItem (HIR::TraitItemFunc *trait_item)\n-    : type (ItemType::TRAIT_ITEM), item (trait_item)\n-  {}\n+  HIR::Function *get_item ();\n \n-  ItemType get_type () const { return type; }\n+  std::pair<HIR::ImplBlock *, HIR::Function *> &get_impl_item ();\n \n-  HIR::Function *get_item ()\n-  {\n-    rust_assert (get_type () == ItemType::ITEM);\n-    return item.item;\n-  }\n-\n-  std::pair<HIR::ImplBlock *, HIR::Function *> &get_impl_item ()\n-  {\n-    rust_assert (get_type () == ItemType::IMPL_ITEM);\n-    return item.impl_item;\n-  };\n-\n-  HIR::TraitItemFunc *get_trait_item ()\n-  {\n-    rust_assert (get_type () == ItemType::TRAIT_ITEM);\n-    return item.trait_item;\n-  }\n+  HIR::TraitItemFunc *get_trait_item ();\n \n   TyTy::FnType *get_context_type ();\n \n@@ -79,13 +59,9 @@ class TypeCheckContextItem\n     std::pair<HIR::ImplBlock *, HIR::Function *> impl_item;\n     HIR::TraitItemFunc *trait_item;\n \n-    Item (HIR::Function *item) : item (item) {}\n-\n-    Item (HIR::ImplBlock *impl_block, HIR::Function *item)\n-      : impl_item ({impl_block, item})\n-    {}\n-\n-    Item (HIR::TraitItemFunc *trait_item) : trait_item (trait_item) {}\n+    Item (HIR::Function *item);\n+    Item (HIR::ImplBlock *impl_block, HIR::Function *item);\n+    Item (HIR::TraitItemFunc *trait_item);\n   };\n \n   ItemType type;\n@@ -118,283 +94,71 @@ class TypeCheckContext\n   void push_return_type (TypeCheckContextItem item,\n \t\t\t TyTy::BaseType *return_type);\n   void pop_return_type ();\n+  void iterate (std::function<bool (HirId, TyTy::BaseType *)> cb);\n \n-  void iterate (std::function<bool (HirId, TyTy::BaseType *)> cb)\n-  {\n-    for (auto it = resolved.begin (); it != resolved.end (); it++)\n-      {\n-\tif (!cb (it->first, it->second))\n-\t  return;\n-      }\n-  }\n-\n-  bool have_loop_context () const { return !loop_type_stack.empty (); }\n-\n-  void push_new_loop_context (HirId id, Location locus)\n-  {\n-    TyTy::BaseType *infer_var\n-      = new TyTy::InferType (id, TyTy::InferType::InferTypeKind::GENERAL,\n-\t\t\t     locus);\n-    loop_type_stack.push_back (infer_var);\n-  }\n-\n-  void push_new_while_loop_context (HirId id)\n-  {\n-    TyTy::BaseType *infer_var = new TyTy::ErrorType (id);\n-    loop_type_stack.push_back (infer_var);\n-  }\n-\n-  TyTy::BaseType *peek_loop_context () { return loop_type_stack.back (); }\n-\n-  TyTy::BaseType *pop_loop_context ()\n-  {\n-    auto back = peek_loop_context ();\n-    loop_type_stack.pop_back ();\n-    return back;\n-  }\n-\n-  void swap_head_loop_context (TyTy::BaseType *val)\n-  {\n-    loop_type_stack.pop_back ();\n-    loop_type_stack.push_back (val);\n-  }\n-\n-  void insert_trait_reference (DefId id, TraitReference &&ref)\n-  {\n-    rust_assert (trait_context.find (id) == trait_context.end ());\n-    trait_context.emplace (id, std::move (ref));\n-  }\n-\n-  bool lookup_trait_reference (DefId id, TraitReference **ref)\n-  {\n-    auto it = trait_context.find (id);\n-    if (it == trait_context.end ())\n-      return false;\n+  bool have_loop_context () const;\n+  void push_new_loop_context (HirId id, Location locus);\n+  void push_new_while_loop_context (HirId id);\n+  TyTy::BaseType *peek_loop_context ();\n+  TyTy::BaseType *pop_loop_context ();\n \n-    *ref = &it->second;\n-    return true;\n-  }\n-\n-  void insert_receiver (HirId id, TyTy::BaseType *t)\n-  {\n-    receiver_context[id] = t;\n-  }\n+  void swap_head_loop_context (TyTy::BaseType *val);\n \n-  bool lookup_receiver (HirId id, TyTy::BaseType **ref)\n-  {\n-    auto it = receiver_context.find (id);\n-    if (it == receiver_context.end ())\n-      return false;\n+  void insert_trait_reference (DefId id, TraitReference &&ref);\n+  bool lookup_trait_reference (DefId id, TraitReference **ref);\n \n-    *ref = it->second;\n-    return true;\n-  }\n+  void insert_receiver (HirId id, TyTy::BaseType *t);\n+  bool lookup_receiver (HirId id, TyTy::BaseType **ref);\n \n-  void insert_associated_trait_impl (HirId id, AssociatedImplTrait &&associated)\n-  {\n-    rust_assert (associated_impl_traits.find (id)\n-\t\t == associated_impl_traits.end ());\n-    associated_impl_traits.emplace (id, std::move (associated));\n-  }\n+  void insert_associated_trait_impl (HirId id,\n+\t\t\t\t     AssociatedImplTrait &&associated);\n+  bool lookup_associated_trait_impl (HirId id,\n+\t\t\t\t     AssociatedImplTrait **associated);\n \n-  bool lookup_associated_trait_impl (HirId id, AssociatedImplTrait **associated)\n-  {\n-    auto it = associated_impl_traits.find (id);\n-    if (it == associated_impl_traits.end ())\n-      return false;\n-\n-    *associated = &it->second;\n-    return true;\n-  }\n-\n-  void insert_associated_type_mapping (HirId id, HirId mapping)\n-  {\n-    associated_type_mappings[id] = mapping;\n-  }\n-\n-  void clear_associated_type_mapping (HirId id)\n-  {\n-    auto it = associated_type_mappings.find (id);\n-    if (it != associated_type_mappings.end ())\n-      associated_type_mappings.erase (it);\n-  }\n+  void insert_associated_type_mapping (HirId id, HirId mapping);\n+  void clear_associated_type_mapping (HirId id);\n \n   // lookup any associated type mappings, the out parameter of mapping is\n   // allowed to be nullptr which allows this interface to do a simple does exist\n   // check\n-  bool lookup_associated_type_mapping (HirId id, HirId *mapping)\n-  {\n-    auto it = associated_type_mappings.find (id);\n-    if (it == associated_type_mappings.end ())\n-      return false;\n-\n-    if (mapping != nullptr)\n-      *mapping = it->second;\n-\n-    return true;\n-  }\n+  bool lookup_associated_type_mapping (HirId id, HirId *mapping);\n \n   void insert_associated_impl_mapping (HirId trait_id,\n \t\t\t\t       const TyTy::BaseType *impl_type,\n-\t\t\t\t       HirId impl_id)\n-  {\n-    auto it = associated_traits_to_impls.find (trait_id);\n-    if (it == associated_traits_to_impls.end ())\n-      {\n-\tassociated_traits_to_impls[trait_id] = {};\n-      }\n-\n-    associated_traits_to_impls[trait_id].push_back ({impl_type, impl_id});\n-  }\n-\n+\t\t\t\t       HirId impl_id);\n   bool lookup_associated_impl_mapping_for_self (HirId trait_id,\n \t\t\t\t\t\tconst TyTy::BaseType *self,\n-\t\t\t\t\t\tHirId *mapping)\n-  {\n-    auto it = associated_traits_to_impls.find (trait_id);\n-    if (it == associated_traits_to_impls.end ())\n-      return false;\n-\n-    for (auto &item : it->second)\n-      {\n-\tif (item.first->can_eq (self, false))\n-\t  {\n-\t    *mapping = item.second;\n-\t    return true;\n-\t  }\n-      }\n-    return false;\n-  }\n+\t\t\t\t\t\tHirId *mapping);\n \n   void insert_autoderef_mappings (HirId id,\n-\t\t\t\t  std::vector<Adjustment> &&adjustments)\n-  {\n-    rust_assert (autoderef_mappings.find (id) == autoderef_mappings.end ());\n-    autoderef_mappings.emplace (id, std::move (adjustments));\n-  }\n-\n+\t\t\t\t  std::vector<Adjustment> &&adjustments);\n   bool lookup_autoderef_mappings (HirId id,\n-\t\t\t\t  std::vector<Adjustment> **adjustments)\n-  {\n-    auto it = autoderef_mappings.find (id);\n-    if (it == autoderef_mappings.end ())\n-      return false;\n-\n-    *adjustments = &it->second;\n-    return true;\n-  }\n+\t\t\t\t  std::vector<Adjustment> **adjustments);\n \n   void insert_cast_autoderef_mappings (HirId id,\n-\t\t\t\t       std::vector<Adjustment> &&adjustments)\n-  {\n-    rust_assert (cast_autoderef_mappings.find (id)\n-\t\t == cast_autoderef_mappings.end ());\n-    cast_autoderef_mappings.emplace (id, std::move (adjustments));\n-  }\n-\n+\t\t\t\t       std::vector<Adjustment> &&adjustments);\n   bool lookup_cast_autoderef_mappings (HirId id,\n-\t\t\t\t       std::vector<Adjustment> **adjustments)\n-  {\n-    auto it = cast_autoderef_mappings.find (id);\n-    if (it == cast_autoderef_mappings.end ())\n-      return false;\n+\t\t\t\t       std::vector<Adjustment> **adjustments);\n \n-    *adjustments = &it->second;\n-    return true;\n-  }\n+  void insert_variant_definition (HirId id, HirId variant);\n+  bool lookup_variant_definition (HirId id, HirId *variant);\n \n-  void insert_variant_definition (HirId id, HirId variant)\n-  {\n-    auto it = variants.find (id);\n-    rust_assert (it == variants.end ());\n+  void insert_operator_overload (HirId id, TyTy::FnType *call_site);\n+  bool lookup_operator_overload (HirId id, TyTy::FnType **call);\n \n-    variants[id] = variant;\n-  }\n+  void insert_unconstrained_check_marker (HirId id, bool status);\n+  bool have_checked_for_unconstrained (HirId id, bool *result);\n \n-  bool lookup_variant_definition (HirId id, HirId *variant)\n-  {\n-    auto it = variants.find (id);\n-    if (it == variants.end ())\n-      return false;\n+  void insert_resolved_predicate (HirId id, TyTy::TypeBoundPredicate predicate);\n+  bool lookup_predicate (HirId id, TyTy::TypeBoundPredicate *result);\n \n-    *variant = it->second;\n-    return true;\n-  }\n-\n-  void insert_operator_overload (HirId id, TyTy::FnType *call_site)\n-  {\n-    auto it = operator_overloads.find (id);\n-    rust_assert (it == operator_overloads.end ());\n-\n-    operator_overloads[id] = call_site;\n-  }\n-\n-  bool lookup_operator_overload (HirId id, TyTy::FnType **call)\n-  {\n-    auto it = operator_overloads.find (id);\n-    if (it == operator_overloads.end ())\n-      return false;\n-\n-    *call = it->second;\n-    return true;\n-  }\n+  void insert_query (HirId id);\n+  void query_completed (HirId id);\n+  bool query_in_progress (HirId id) const;\n \n-  void insert_unconstrained_check_marker (HirId id, bool status)\n-  {\n-    unconstrained[id] = status;\n-  }\n-\n-  bool have_checked_for_unconstrained (HirId id, bool *result)\n-  {\n-    auto it = unconstrained.find (id);\n-    bool found = it != unconstrained.end ();\n-    if (!found)\n-      return false;\n-\n-    *result = it->second;\n-    return true;\n-  }\n-\n-  void insert_resolved_predicate (HirId id, TyTy::TypeBoundPredicate predicate)\n-  {\n-    auto it = predicates.find (id);\n-    rust_assert (it == predicates.end ());\n-\n-    predicates.insert ({id, predicate});\n-  }\n-\n-  bool lookup_predicate (HirId id, TyTy::TypeBoundPredicate *result)\n-  {\n-    auto it = predicates.find (id);\n-    bool found = it != predicates.end ();\n-    if (!found)\n-      return false;\n-\n-    *result = it->second;\n-    return true;\n-  }\n-\n-  void insert_query (HirId id) { querys_in_progress.insert (id); }\n-\n-  void query_completed (HirId id) { querys_in_progress.erase (id); }\n-\n-  bool query_in_progress (HirId id) const\n-  {\n-    return querys_in_progress.find (id) != querys_in_progress.end ();\n-  }\n-\n-  void insert_trait_query (DefId id) { trait_queries_in_progress.insert (id); }\n-\n-  void trait_query_completed (DefId id)\n-  {\n-    trait_queries_in_progress.erase (id);\n-  }\n-\n-  bool trait_query_in_progress (DefId id) const\n-  {\n-    return trait_queries_in_progress.find (id)\n-\t   != trait_queries_in_progress.end ();\n-  }\n+  void insert_trait_query (DefId id);\n+  void trait_query_completed (DefId id);\n+  bool trait_query_in_progress (DefId id) const;\n \n private:\n   TypeCheckContext ();"}, {"sha": "ba4d3228c22663ab89406f50ac932119e56dfdf0", "filename": "gcc/rust/typecheck/rust-tyctx.cc", "status": "modified", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ea0f26bab31e63aaab85eee25250eddb753486f/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ea0f26bab31e63aaab85eee25250eddb753486f/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc?ref=5ea0f26bab31e63aaab85eee25250eddb753486f", "patch": "@@ -154,8 +154,387 @@ TypeCheckContext::peek_context ()\n   return return_type_stack.back ().first;\n }\n \n+void\n+TypeCheckContext::iterate (std::function<bool (HirId, TyTy::BaseType *)> cb)\n+{\n+  for (auto it = resolved.begin (); it != resolved.end (); it++)\n+    {\n+      if (!cb (it->first, it->second))\n+\treturn;\n+    }\n+}\n+\n+bool\n+TypeCheckContext::have_loop_context () const\n+{\n+  return !loop_type_stack.empty ();\n+}\n+\n+void\n+TypeCheckContext::push_new_loop_context (HirId id, Location locus)\n+{\n+  TyTy::BaseType *infer_var\n+    = new TyTy::InferType (id, TyTy::InferType::InferTypeKind::GENERAL, locus);\n+  loop_type_stack.push_back (infer_var);\n+}\n+\n+void\n+TypeCheckContext::push_new_while_loop_context (HirId id)\n+{\n+  TyTy::BaseType *infer_var = new TyTy::ErrorType (id);\n+  loop_type_stack.push_back (infer_var);\n+}\n+\n+TyTy::BaseType *\n+TypeCheckContext::peek_loop_context ()\n+{\n+  return loop_type_stack.back ();\n+}\n+\n+TyTy::BaseType *\n+TypeCheckContext::pop_loop_context ()\n+{\n+  auto back = peek_loop_context ();\n+  loop_type_stack.pop_back ();\n+  return back;\n+}\n+\n+void\n+TypeCheckContext::swap_head_loop_context (TyTy::BaseType *val)\n+{\n+  loop_type_stack.pop_back ();\n+  loop_type_stack.push_back (val);\n+}\n+\n+void\n+TypeCheckContext::insert_trait_reference (DefId id, TraitReference &&ref)\n+{\n+  rust_assert (trait_context.find (id) == trait_context.end ());\n+  trait_context.emplace (id, std::move (ref));\n+}\n+\n+bool\n+TypeCheckContext::lookup_trait_reference (DefId id, TraitReference **ref)\n+{\n+  auto it = trait_context.find (id);\n+  if (it == trait_context.end ())\n+    return false;\n+\n+  *ref = &it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_receiver (HirId id, TyTy::BaseType *t)\n+{\n+  receiver_context[id] = t;\n+}\n+\n+bool\n+TypeCheckContext::lookup_receiver (HirId id, TyTy::BaseType **ref)\n+{\n+  auto it = receiver_context.find (id);\n+  if (it == receiver_context.end ())\n+    return false;\n+\n+  *ref = it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_associated_trait_impl (\n+  HirId id, AssociatedImplTrait &&associated)\n+{\n+  rust_assert (associated_impl_traits.find (id)\n+\t       == associated_impl_traits.end ());\n+  associated_impl_traits.emplace (id, std::move (associated));\n+}\n+\n+bool\n+TypeCheckContext::lookup_associated_trait_impl (\n+  HirId id, AssociatedImplTrait **associated)\n+{\n+  auto it = associated_impl_traits.find (id);\n+  if (it == associated_impl_traits.end ())\n+    return false;\n+\n+  *associated = &it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_associated_type_mapping (HirId id, HirId mapping)\n+{\n+  associated_type_mappings[id] = mapping;\n+}\n+\n+void\n+TypeCheckContext::clear_associated_type_mapping (HirId id)\n+{\n+  auto it = associated_type_mappings.find (id);\n+  if (it != associated_type_mappings.end ())\n+    associated_type_mappings.erase (it);\n+}\n+\n+// lookup any associated type mappings, the out parameter of mapping is\n+// allowed to be nullptr which allows this interface to do a simple does exist\n+// check\n+bool\n+TypeCheckContext::lookup_associated_type_mapping (HirId id, HirId *mapping)\n+{\n+  auto it = associated_type_mappings.find (id);\n+  if (it == associated_type_mappings.end ())\n+    return false;\n+\n+  if (mapping != nullptr)\n+    *mapping = it->second;\n+\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_associated_impl_mapping (\n+  HirId trait_id, const TyTy::BaseType *impl_type, HirId impl_id)\n+{\n+  auto it = associated_traits_to_impls.find (trait_id);\n+  if (it == associated_traits_to_impls.end ())\n+    {\n+      associated_traits_to_impls[trait_id] = {};\n+    }\n+\n+  associated_traits_to_impls[trait_id].push_back ({impl_type, impl_id});\n+}\n+\n+bool\n+TypeCheckContext::lookup_associated_impl_mapping_for_self (\n+  HirId trait_id, const TyTy::BaseType *self, HirId *mapping)\n+{\n+  auto it = associated_traits_to_impls.find (trait_id);\n+  if (it == associated_traits_to_impls.end ())\n+    return false;\n+\n+  for (auto &item : it->second)\n+    {\n+      if (item.first->can_eq (self, false))\n+\t{\n+\t  *mapping = item.second;\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+void\n+TypeCheckContext::insert_autoderef_mappings (\n+  HirId id, std::vector<Adjustment> &&adjustments)\n+{\n+  rust_assert (autoderef_mappings.find (id) == autoderef_mappings.end ());\n+  autoderef_mappings.emplace (id, std::move (adjustments));\n+}\n+\n+bool\n+TypeCheckContext::lookup_autoderef_mappings (\n+  HirId id, std::vector<Adjustment> **adjustments)\n+{\n+  auto it = autoderef_mappings.find (id);\n+  if (it == autoderef_mappings.end ())\n+    return false;\n+\n+  *adjustments = &it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_cast_autoderef_mappings (\n+  HirId id, std::vector<Adjustment> &&adjustments)\n+{\n+  rust_assert (cast_autoderef_mappings.find (id)\n+\t       == cast_autoderef_mappings.end ());\n+  cast_autoderef_mappings.emplace (id, std::move (adjustments));\n+}\n+\n+bool\n+TypeCheckContext::lookup_cast_autoderef_mappings (\n+  HirId id, std::vector<Adjustment> **adjustments)\n+{\n+  auto it = cast_autoderef_mappings.find (id);\n+  if (it == cast_autoderef_mappings.end ())\n+    return false;\n+\n+  *adjustments = &it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_variant_definition (HirId id, HirId variant)\n+{\n+  auto it = variants.find (id);\n+  rust_assert (it == variants.end ());\n+\n+  variants[id] = variant;\n+}\n+\n+bool\n+TypeCheckContext::lookup_variant_definition (HirId id, HirId *variant)\n+{\n+  auto it = variants.find (id);\n+  if (it == variants.end ())\n+    return false;\n+\n+  *variant = it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_operator_overload (HirId id, TyTy::FnType *call_site)\n+{\n+  auto it = operator_overloads.find (id);\n+  rust_assert (it == operator_overloads.end ());\n+\n+  operator_overloads[id] = call_site;\n+}\n+\n+bool\n+TypeCheckContext::lookup_operator_overload (HirId id, TyTy::FnType **call)\n+{\n+  auto it = operator_overloads.find (id);\n+  if (it == operator_overloads.end ())\n+    return false;\n+\n+  *call = it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_unconstrained_check_marker (HirId id, bool status)\n+{\n+  unconstrained[id] = status;\n+}\n+\n+bool\n+TypeCheckContext::have_checked_for_unconstrained (HirId id, bool *result)\n+{\n+  auto it = unconstrained.find (id);\n+  bool found = it != unconstrained.end ();\n+  if (!found)\n+    return false;\n+\n+  *result = it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_resolved_predicate (HirId id,\n+\t\t\t\t\t     TyTy::TypeBoundPredicate predicate)\n+{\n+  auto it = predicates.find (id);\n+  rust_assert (it == predicates.end ());\n+\n+  predicates.insert ({id, predicate});\n+}\n+\n+bool\n+TypeCheckContext::lookup_predicate (HirId id, TyTy::TypeBoundPredicate *result)\n+{\n+  auto it = predicates.find (id);\n+  bool found = it != predicates.end ();\n+  if (!found)\n+    return false;\n+\n+  *result = it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_query (HirId id)\n+{\n+  querys_in_progress.insert (id);\n+}\n+\n+void\n+TypeCheckContext::query_completed (HirId id)\n+{\n+  querys_in_progress.erase (id);\n+}\n+\n+bool\n+TypeCheckContext::query_in_progress (HirId id) const\n+{\n+  return querys_in_progress.find (id) != querys_in_progress.end ();\n+}\n+\n+void\n+TypeCheckContext::insert_trait_query (DefId id)\n+{\n+  trait_queries_in_progress.insert (id);\n+}\n+\n+void\n+TypeCheckContext::trait_query_completed (DefId id)\n+{\n+  trait_queries_in_progress.erase (id);\n+}\n+\n+bool\n+TypeCheckContext::trait_query_in_progress (DefId id) const\n+{\n+  return trait_queries_in_progress.find (id)\n+\t != trait_queries_in_progress.end ();\n+}\n+\n // TypeCheckContextItem\n \n+TypeCheckContextItem::Item::Item (HIR::Function *item) : item (item) {}\n+\n+TypeCheckContextItem::Item::Item (HIR::ImplBlock *impl_block,\n+\t\t\t\t  HIR::Function *item)\n+  : impl_item ({impl_block, item})\n+{}\n+\n+TypeCheckContextItem::Item::Item (HIR::TraitItemFunc *trait_item)\n+  : trait_item (trait_item)\n+{}\n+\n+TypeCheckContextItem::TypeCheckContextItem (HIR::Function *item)\n+  : type (ItemType::ITEM), item (item)\n+{}\n+\n+TypeCheckContextItem::TypeCheckContextItem (HIR::ImplBlock *impl_block,\n+\t\t\t\t\t    HIR::Function *item)\n+  : type (ItemType::IMPL_ITEM), item (impl_block, item)\n+{}\n+\n+TypeCheckContextItem::TypeCheckContextItem (HIR::TraitItemFunc *trait_item)\n+  : type (ItemType::TRAIT_ITEM), item (trait_item)\n+{}\n+\n+HIR::Function *\n+TypeCheckContextItem::get_item ()\n+{\n+  rust_assert (get_type () == ItemType::ITEM);\n+  return item.item;\n+}\n+\n+std::pair<HIR::ImplBlock *, HIR::Function *> &\n+TypeCheckContextItem::get_impl_item ()\n+{\n+  rust_assert (get_type () == ItemType::IMPL_ITEM);\n+  return item.impl_item;\n+}\n+\n+HIR::TraitItemFunc *\n+TypeCheckContextItem::get_trait_item ()\n+{\n+  rust_assert (get_type () == ItemType::TRAIT_ITEM);\n+  return item.trait_item;\n+}\n+\n+TypeCheckContextItem::ItemType\n+TypeCheckContextItem::get_type () const\n+{\n+  return type;\n+}\n+\n TyTy::FnType *\n TypeCheckContextItem::get_context_type ()\n {"}, {"sha": "c16c2163907f38c2e317560449cc43d9be430507", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 956, "deletions": 4, "changes": 960, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ea0f26bab31e63aaab85eee25250eddb753486f/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ea0f26bab31e63aaab85eee25250eddb753486f/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=5ea0f26bab31e63aaab85eee25250eddb753486f", "patch": "@@ -17,17 +17,22 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-tyty.h\"\n-#include \"rust-tyty-visitor.h\"\n-#include \"rust-tyty-call.h\"\n+\n #include \"rust-hir-type-check-expr.h\"\n #include \"rust-hir-type-check-type.h\"\n-#include \"rust-tyty-rules.h\"\n-#include \"rust-tyty-cmp.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-tyty-call.h\"\n #include \"rust-hir-map.h\"\n+#include \"rust-location.h\"\n+#include \"rust-linemap.h\"\n+\n #include \"rust-substitution-mapper.h\"\n #include \"rust-hir-trait-ref.h\"\n #include \"rust-hir-type-bounds.h\"\n #include \"rust-hir-trait-resolve.h\"\n+#include \"rust-tyty-rules.h\"\n+#include \"rust-tyty-cmp.h\"\n+\n #include \"options.h\"\n \n namespace Rust {\n@@ -658,6 +663,53 @@ ErrorType::monomorphized_clone () const\n \n // Struct Field type\n \n+StructFieldType::StructFieldType (HirId ref, std::string name, BaseType *ty,\n+\t\t\t\t  Location locus)\n+  : ref (ref), name (name), ty (ty), locus (locus)\n+{}\n+\n+HirId\n+StructFieldType::get_ref () const\n+{\n+  return ref;\n+}\n+\n+std::string\n+StructFieldType::get_name () const\n+{\n+  return name;\n+}\n+\n+BaseType *\n+StructFieldType::get_field_type () const\n+{\n+  return ty;\n+}\n+\n+void\n+StructFieldType::set_field_type (BaseType *fty)\n+{\n+  ty = fty;\n+}\n+\n+bool\n+StructFieldType::is_concrete () const\n+{\n+  return ty->is_concrete ();\n+}\n+\n+void\n+StructFieldType::debug () const\n+{\n+  rust_debug (\"%s\", as_string ().c_str ());\n+}\n+\n+Location\n+StructFieldType::get_locus () const\n+{\n+  return locus;\n+}\n+\n std::string\n StructFieldType::as_string () const\n {\n@@ -695,6 +747,241 @@ StructFieldType::monomorphized_clone () const\n \t\t\t      get_field_type ()->monomorphized_clone (), locus);\n }\n \n+// VariantDef\n+\n+std::string\n+VariantDef::variant_type_string (VariantType type)\n+{\n+  switch (type)\n+    {\n+    case NUM:\n+      return \"enumeral\";\n+    case TUPLE:\n+      return \"tuple\";\n+    case STRUCT:\n+      return \"struct\";\n+    }\n+  gcc_unreachable ();\n+  return \"\";\n+}\n+\n+VariantDef::VariantDef (HirId id, DefId defid, std::string identifier,\n+\t\t\tRustIdent ident, HIR::Expr *discriminant)\n+  : id (id), defid (defid), identifier (identifier), ident (ident),\n+    discriminant (discriminant)\n+\n+{\n+  type = VariantType::NUM;\n+  fields = {};\n+}\n+\n+VariantDef::VariantDef (HirId id, DefId defid, std::string identifier,\n+\t\t\tRustIdent ident, VariantType type,\n+\t\t\tHIR::Expr *discriminant,\n+\t\t\tstd::vector<StructFieldType *> fields)\n+  : id (id), defid (defid), identifier (identifier), ident (ident), type (type),\n+    discriminant (discriminant), fields (fields)\n+{\n+  rust_assert ((type == VariantType::NUM && fields.empty ())\n+\t       || (type == VariantType::TUPLE || type == VariantType::STRUCT));\n+}\n+\n+VariantDef::VariantDef (const VariantDef &other)\n+  : id (other.id), defid (other.defid), identifier (other.identifier),\n+    ident (other.ident), type (other.type), discriminant (other.discriminant),\n+    fields (other.fields)\n+{}\n+\n+VariantDef &\n+VariantDef::operator= (const VariantDef &other)\n+{\n+  id = other.id;\n+  identifier = other.identifier;\n+  type = other.type;\n+  discriminant = other.discriminant;\n+  fields = other.fields;\n+  ident = other.ident;\n+\n+  return *this;\n+}\n+\n+VariantDef &\n+VariantDef::get_error_node ()\n+{\n+  static VariantDef node\n+    = VariantDef (UNKNOWN_HIRID, UNKNOWN_DEFID, \"\",\n+\t\t  {Resolver::CanonicalPath::create_empty (),\n+\t\t   Linemap::unknown_location ()},\n+\t\t  nullptr);\n+\n+  return node;\n+}\n+\n+bool\n+VariantDef::is_error () const\n+{\n+  return get_id () == UNKNOWN_HIRID;\n+}\n+\n+HirId\n+VariantDef::get_id () const\n+{\n+  return id;\n+}\n+\n+DefId\n+VariantDef::get_defid () const\n+{\n+  return defid;\n+}\n+\n+VariantDef::VariantType\n+VariantDef::get_variant_type () const\n+{\n+  return type;\n+}\n+\n+bool\n+VariantDef::is_data_variant () const\n+{\n+  return type != VariantType::NUM;\n+}\n+\n+bool\n+VariantDef::is_dataless_variant () const\n+{\n+  return type == VariantType::NUM;\n+}\n+\n+std::string\n+VariantDef::get_identifier () const\n+{\n+  return identifier;\n+}\n+\n+size_t\n+VariantDef::num_fields () const\n+{\n+  return fields.size ();\n+}\n+\n+StructFieldType *\n+VariantDef::get_field_at_index (size_t index)\n+{\n+  rust_assert (index < fields.size ());\n+  return fields.at (index);\n+}\n+\n+std::vector<StructFieldType *> &\n+VariantDef::get_fields ()\n+{\n+  rust_assert (type != NUM);\n+  return fields;\n+}\n+\n+bool\n+VariantDef::lookup_field (const std::string &lookup,\n+\t\t\t  StructFieldType **field_lookup, size_t *index) const\n+{\n+  size_t i = 0;\n+  for (auto &field : fields)\n+    {\n+      if (field->get_name ().compare (lookup) == 0)\n+\t{\n+\t  if (index != nullptr)\n+\t    *index = i;\n+\n+\t  if (field_lookup != nullptr)\n+\t    *field_lookup = field;\n+\n+\t  return true;\n+\t}\n+      i++;\n+    }\n+  return false;\n+}\n+\n+HIR::Expr *\n+VariantDef::get_discriminant () const\n+{\n+  rust_assert (discriminant != nullptr);\n+  return discriminant;\n+}\n+\n+std::string\n+VariantDef::as_string () const\n+{\n+  if (type == VariantType::NUM)\n+    return identifier + \" = \" + discriminant->as_string ();\n+\n+  std::string buffer;\n+  for (size_t i = 0; i < fields.size (); ++i)\n+    {\n+      buffer += fields.at (i)->as_string ();\n+      if ((i + 1) < fields.size ())\n+\tbuffer += \", \";\n+    }\n+\n+  if (type == VariantType::TUPLE)\n+    return identifier + \" (\" + buffer + \")\";\n+  else\n+    return identifier + \" {\" + buffer + \"}\";\n+}\n+\n+bool\n+VariantDef::is_equal (const VariantDef &other) const\n+{\n+  if (type != other.type)\n+    return false;\n+\n+  if (identifier.compare (other.identifier) != 0)\n+    return false;\n+\n+  if (discriminant != other.discriminant)\n+    return false;\n+\n+  if (fields.size () != other.fields.size ())\n+    return false;\n+\n+  for (size_t i = 0; i < fields.size (); i++)\n+    {\n+      if (!fields.at (i)->is_equal (*other.fields.at (i)))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+VariantDef *\n+VariantDef::clone () const\n+{\n+  std::vector<StructFieldType *> cloned_fields;\n+  for (auto &f : fields)\n+    cloned_fields.push_back ((StructFieldType *) f->clone ());\n+\n+  return new VariantDef (id, defid, identifier, ident, type, discriminant,\n+\t\t\t cloned_fields);\n+}\n+\n+VariantDef *\n+VariantDef::monomorphized_clone () const\n+{\n+  std::vector<StructFieldType *> cloned_fields;\n+  for (auto &f : fields)\n+    cloned_fields.push_back ((StructFieldType *) f->monomorphized_clone ());\n+\n+  return new VariantDef (id, defid, identifier, ident, type, discriminant,\n+\t\t\t cloned_fields);\n+}\n+\n+const RustIdent &\n+VariantDef::get_ident () const\n+{\n+  return ident;\n+}\n+\n+// ADTType\n+\n void\n ADTType::accept_vis (TyVisitor &vis)\n {\n@@ -892,6 +1179,57 @@ ADTType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n   return adt;\n }\n \n+// TupleType\n+\n+TupleType::TupleType (HirId ref, Location locus, std::vector<TyVar> fields,\n+\t\t      std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::TUPLE,\n+\t      {Resolver::CanonicalPath::create_empty (), locus}, refs),\n+    fields (fields)\n+{}\n+\n+TupleType::TupleType (HirId ref, HirId ty_ref, Location locus,\n+\t\t      std::vector<TyVar> fields, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::TUPLE,\n+\t      {Resolver::CanonicalPath::create_empty (), locus}, refs),\n+    fields (fields)\n+{}\n+\n+TupleType *\n+TupleType::get_unit_type (HirId ref)\n+{\n+  return new TupleType (ref, Linemap::predeclared_location ());\n+}\n+\n+bool\n+TupleType::is_unit () const\n+{\n+  return this->fields.empty ();\n+}\n+\n+size_t\n+TupleType::num_fields () const\n+{\n+  return fields.size ();\n+}\n+\n+bool\n+TupleType::is_concrete () const\n+{\n+  for (size_t i = 0; i < num_fields (); i++)\n+    {\n+      if (!get_field (i)->is_concrete ())\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+const std::vector<TyVar> &\n+TupleType::get_fields () const\n+{\n+  return fields;\n+}\n+\n void\n TupleType::accept_vis (TyVisitor &vis)\n {\n@@ -1622,6 +1960,34 @@ SliceType::handle_substitions (SubstitutionArgumentMappings mappings)\n   return ref;\n }\n \n+// BoolType\n+\n+BoolType::BoolType (HirId ref, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::BOOL,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+BoolType::BoolType (HirId ref, HirId ty_ref, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::BOOL,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+std::string\n+BoolType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+bool\n+BoolType::is_concrete () const\n+{\n+  return true;\n+}\n+\n void\n BoolType::accept_vis (TyVisitor &vis)\n {\n@@ -1666,6 +2032,36 @@ BoolType::monomorphized_clone () const\n   return clone ();\n }\n \n+// IntType\n+\n+IntType::IntType (HirId ref, IntKind kind, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::INT,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    int_kind (kind)\n+{}\n+\n+IntType::IntType (HirId ref, HirId ty_ref, IntKind kind, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::INT,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    int_kind (kind)\n+{}\n+\n+std::string\n+IntType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+IntType::IntKind\n+IntType::get_int_kind () const\n+{\n+  return int_kind;\n+}\n+\n void\n IntType::accept_vis (TyVisitor &vis)\n {\n@@ -1735,6 +2131,43 @@ IntType::is_equal (const BaseType &other) const\n   return get_int_kind () == o.get_int_kind ();\n }\n \n+bool\n+IntType::is_concrete () const\n+{\n+  return true;\n+}\n+\n+// UintType\n+\n+UintType::UintType (HirId ref, UintKind kind, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::UINT,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    uint_kind (kind)\n+{}\n+\n+UintType::UintType (HirId ref, HirId ty_ref, UintKind kind,\n+\t\t    std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::UINT,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    uint_kind (kind)\n+{}\n+\n+std::string\n+UintType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+UintType::UintKind\n+UintType::get_uint_kind () const\n+{\n+  return uint_kind;\n+}\n+\n void\n UintType::accept_vis (TyVisitor &vis)\n {\n@@ -1804,6 +2237,49 @@ UintType::is_equal (const BaseType &other) const\n   return get_uint_kind () == o.get_uint_kind ();\n }\n \n+bool\n+UintType::is_concrete () const\n+{\n+  return true;\n+}\n+\n+// FloatType\n+\n+FloatType::FloatType (HirId ref, FloatKind kind, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::FLOAT,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    float_kind (kind)\n+{}\n+\n+FloatType::FloatType (HirId ref, HirId ty_ref, FloatKind kind,\n+\t\t      std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::FLOAT,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    float_kind (kind)\n+{}\n+\n+std::string\n+FloatType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+FloatType::FloatKind\n+FloatType::get_float_kind () const\n+{\n+  return float_kind;\n+}\n+\n+bool\n+FloatType::is_concrete () const\n+{\n+  return true;\n+}\n+\n void\n FloatType::accept_vis (TyVisitor &vis)\n {\n@@ -1867,6 +2343,34 @@ FloatType::is_equal (const BaseType &other) const\n   return get_float_kind () == o.get_float_kind ();\n }\n \n+// UsizeType\n+\n+USizeType::USizeType (HirId ref, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::USIZE,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+USizeType::USizeType (HirId ref, HirId ty_ref, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::USIZE,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+std::string\n+USizeType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+bool\n+USizeType::is_concrete () const\n+{\n+  return true;\n+}\n+\n void\n USizeType::accept_vis (TyVisitor &vis)\n {\n@@ -1911,6 +2415,34 @@ USizeType::monomorphized_clone () const\n   return clone ();\n }\n \n+// ISizeType\n+\n+ISizeType::ISizeType (HirId ref, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::ISIZE,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+ISizeType::ISizeType (HirId ref, HirId ty_ref, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::ISIZE,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+std::string\n+ISizeType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+bool\n+ISizeType::is_concrete () const\n+{\n+  return true;\n+}\n+\n void\n ISizeType::accept_vis (TyVisitor &vis)\n {\n@@ -1955,6 +2487,34 @@ ISizeType::monomorphized_clone () const\n   return clone ();\n }\n \n+// Char Type\n+\n+CharType::CharType (HirId ref, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::CHAR,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+CharType::CharType (HirId ref, HirId ty_ref, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::CHAR,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+bool\n+CharType::is_concrete () const\n+{\n+  return true;\n+}\n+\n+std::string\n+CharType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n void\n CharType::accept_vis (TyVisitor &vis)\n {\n@@ -1999,6 +2559,76 @@ CharType::monomorphized_clone () const\n   return clone ();\n }\n \n+// Reference Type\n+\n+ReferenceType::ReferenceType (HirId ref, TyVar base, Mutability mut,\n+\t\t\t      std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::REF,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    base (base), mut (mut)\n+{}\n+\n+ReferenceType::ReferenceType (HirId ref, HirId ty_ref, TyVar base,\n+\t\t\t      Mutability mut, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::REF,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    base (base), mut (mut)\n+{}\n+\n+bool\n+ReferenceType::is_concrete () const\n+{\n+  return get_base ()->is_concrete ();\n+}\n+\n+Mutability\n+ReferenceType::mutability () const\n+{\n+  return mut;\n+}\n+\n+bool\n+ReferenceType::is_mutable () const\n+{\n+  return mut == Mutability::Mut;\n+}\n+\n+bool\n+ReferenceType::is_dyn_object () const\n+{\n+  return is_dyn_slice_type () || is_dyn_str_type ();\n+}\n+\n+bool\n+ReferenceType::is_dyn_slice_type (const TyTy::SliceType **slice) const\n+{\n+  const TyTy::BaseType *element = get_base ()->destructure ();\n+  if (element->get_kind () != TyTy::TypeKind::SLICE)\n+    return false;\n+  if (slice == nullptr)\n+    return true;\n+\n+  *slice = static_cast<const TyTy::SliceType *> (element);\n+  return true;\n+}\n+\n+bool\n+ReferenceType::is_dyn_str_type (const TyTy::StrType **str) const\n+{\n+  const TyTy::BaseType *element = get_base ()->destructure ();\n+  if (element->get_kind () != TyTy::TypeKind::STR)\n+    return false;\n+  if (str == nullptr)\n+    return true;\n+\n+  *str = static_cast<const TyTy::StrType *> (element);\n+  return true;\n+}\n+\n void\n ReferenceType::accept_vis (TyVisitor &vis)\n {\n@@ -2089,6 +2719,82 @@ ReferenceType::handle_substitions (SubstitutionArgumentMappings mappings)\n   return ref;\n }\n \n+// PointerType\n+\n+PointerType::PointerType (HirId ref, TyVar base, Mutability mut,\n+\t\t\t  std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::POINTER,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    base (base), mut (mut)\n+{}\n+\n+PointerType::PointerType (HirId ref, HirId ty_ref, TyVar base, Mutability mut,\n+\t\t\t  std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::POINTER,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    base (base), mut (mut)\n+{}\n+\n+bool\n+PointerType::is_concrete () const\n+{\n+  return get_base ()->is_concrete ();\n+}\n+\n+Mutability\n+PointerType::mutability () const\n+{\n+  return mut;\n+}\n+\n+bool\n+PointerType::is_mutable () const\n+{\n+  return mut == Mutability::Mut;\n+}\n+\n+bool\n+PointerType::is_const () const\n+{\n+  return mut == Mutability::Imm;\n+}\n+\n+bool\n+PointerType::is_dyn_object () const\n+{\n+  return is_dyn_slice_type () || is_dyn_str_type ();\n+}\n+\n+bool\n+PointerType::is_dyn_slice_type (const TyTy::SliceType **slice) const\n+{\n+  const TyTy::BaseType *element = get_base ()->destructure ();\n+  if (element->get_kind () != TyTy::TypeKind::SLICE)\n+    return false;\n+  if (slice == nullptr)\n+    return true;\n+\n+  *slice = static_cast<const TyTy::SliceType *> (element);\n+  return true;\n+}\n+\n+bool\n+PointerType::is_dyn_str_type (const TyTy::StrType **str) const\n+{\n+  const TyTy::BaseType *element = get_base ()->destructure ();\n+  if (element->get_kind () != TyTy::TypeKind::STR)\n+    return false;\n+  if (str == nullptr)\n+    return true;\n+\n+  *str = static_cast<const TyTy::StrType *> (element);\n+  return true;\n+}\n+\n void\n PointerType::accept_vis (TyVisitor &vis)\n {\n@@ -2179,6 +2885,52 @@ PointerType::handle_substitions (SubstitutionArgumentMappings mappings)\n   return ref;\n }\n \n+// PARAM Type\n+\n+ParamType::ParamType (std::string symbol, Location locus, HirId ref,\n+\t\t      HIR::GenericParam &param,\n+\t\t      std::vector<TypeBoundPredicate> specified_bounds,\n+\t\t      std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::PARAM,\n+\t      {Resolver::CanonicalPath::new_seg (UNKNOWN_NODEID, symbol),\n+\t       locus},\n+\t      specified_bounds, refs),\n+    symbol (symbol), param (param)\n+{}\n+\n+ParamType::ParamType (std::string symbol, Location locus, HirId ref,\n+\t\t      HirId ty_ref, HIR::GenericParam &param,\n+\t\t      std::vector<TypeBoundPredicate> specified_bounds,\n+\t\t      std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::PARAM,\n+\t      {Resolver::CanonicalPath::new_seg (UNKNOWN_NODEID, symbol),\n+\t       locus},\n+\t      specified_bounds, refs),\n+    symbol (symbol), param (param)\n+{}\n+\n+HIR::GenericParam &\n+ParamType::get_generic_param ()\n+{\n+  return param;\n+}\n+\n+bool\n+ParamType::can_resolve () const\n+{\n+  return get_ref () != get_ty_ref ();\n+}\n+\n+bool\n+ParamType::is_concrete () const\n+{\n+  auto r = resolve ();\n+  if (r == this)\n+    return false;\n+\n+  return r->is_concrete ();\n+}\n+\n void\n ParamType::accept_vis (TyVisitor &vis)\n {\n@@ -2320,6 +3072,34 @@ ParamType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n   return p;\n }\n \n+// StrType\n+\n+StrType::StrType (HirId ref, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::STR,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+StrType::StrType (HirId ref, HirId ty_ref, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::STR,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+std::string\n+StrType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+bool\n+StrType::is_concrete () const\n+{\n+  return true;\n+}\n+\n BaseType *\n StrType::clone () const\n {\n@@ -2370,6 +3150,40 @@ StrType::is_equal (const BaseType &other) const\n   return get_kind () == other.get_kind ();\n }\n \n+// Never Type\n+\n+NeverType::NeverType (HirId ref, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::NEVER,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+NeverType::NeverType (HirId ref, HirId ty_ref, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::NEVER,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+std::string\n+NeverType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+bool\n+NeverType::is_unit () const\n+{\n+  return true;\n+}\n+\n+bool\n+NeverType::is_concrete () const\n+{\n+  return true;\n+}\n+\n void\n NeverType::accept_vis (TyVisitor &vis)\n {\n@@ -2416,6 +3230,52 @@ NeverType::monomorphized_clone () const\n \n // placeholder type\n \n+PlaceholderType::PlaceholderType (std::string symbol, HirId ref,\n+\t\t\t\t  std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::PLACEHOLDER,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    symbol (symbol)\n+{}\n+\n+PlaceholderType::PlaceholderType (std::string symbol, HirId ref, HirId ty_ref,\n+\t\t\t\t  std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::PLACEHOLDER,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    symbol (symbol)\n+{}\n+\n+std::string\n+PlaceholderType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+bool\n+PlaceholderType::is_unit () const\n+{\n+  rust_assert (can_resolve ());\n+  return resolve ()->is_unit ();\n+}\n+\n+std::string\n+PlaceholderType::get_symbol () const\n+{\n+  return symbol;\n+}\n+\n+bool\n+PlaceholderType::is_concrete () const\n+{\n+  if (!can_resolve ())\n+    return true;\n+\n+  return resolve ()->is_concrete ();\n+}\n+\n void\n PlaceholderType::accept_vis (TyVisitor &vis)\n {\n@@ -2515,6 +3375,78 @@ PlaceholderType::is_equal (const BaseType &other) const\n \n // Projection type\n \n+ProjectionType::ProjectionType (\n+  HirId ref, BaseType *base, const Resolver::TraitReference *trait, DefId item,\n+  std::vector<SubstitutionParamMapping> subst_refs,\n+  SubstitutionArgumentMappings generic_arguments, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::PROJECTION,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n+    base (base), trait (trait), item (item)\n+{}\n+\n+ProjectionType::ProjectionType (\n+  HirId ref, HirId ty_ref, BaseType *base,\n+  const Resolver::TraitReference *trait, DefId item,\n+  std::vector<SubstitutionParamMapping> subst_refs,\n+  SubstitutionArgumentMappings generic_arguments, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::PROJECTION,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n+    base (base), trait (trait), item (item)\n+{}\n+\n+bool\n+ProjectionType::is_unit () const\n+{\n+  return false;\n+}\n+\n+std::string\n+ProjectionType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+bool\n+ProjectionType::needs_generic_substitutions () const\n+{\n+  return needs_substitution ();\n+}\n+\n+bool\n+ProjectionType::supports_substitutions () const\n+{\n+  return true;\n+}\n+\n+bool\n+ProjectionType::has_subsititions_defined () const\n+{\n+  return has_substitutions ();\n+}\n+\n+const BaseType *\n+ProjectionType::get () const\n+{\n+  return base;\n+}\n+BaseType *\n+ProjectionType::get ()\n+{\n+  return base;\n+}\n+\n+bool\n+ProjectionType::is_concrete () const\n+{\n+  return base->is_concrete ();\n+}\n+\n void\n ProjectionType::accept_vis (TyVisitor &vis)\n {\n@@ -2631,6 +3563,26 @@ ProjectionType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n   return projection;\n }\n \n+// DynObjectType\n+\n+DynamicObjectType::DynamicObjectType (\n+  HirId ref, RustIdent ident, std::vector<TypeBoundPredicate> specified_bounds,\n+  std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::DYNAMIC, ident, specified_bounds, refs)\n+{}\n+\n+DynamicObjectType::DynamicObjectType (\n+  HirId ref, HirId ty_ref, RustIdent ident,\n+  std::vector<TypeBoundPredicate> specified_bounds, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::DYNAMIC, ident, specified_bounds, refs)\n+{}\n+\n+bool\n+DynamicObjectType::is_concrete () const\n+{\n+  return true;\n+}\n+\n void\n DynamicObjectType::accept_vis (TyVisitor &vis)\n {"}, {"sha": "3dd97cef35b691fd55e2f4bdc0e3953c6c84369b", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 125, "deletions": 542, "changes": 667, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ea0f26bab31e63aaab85eee25250eddb753486f/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ea0f26bab31e63aaab85eee25250eddb753486f/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=5ea0f26bab31e63aaab85eee25250eddb753486f", "patch": "@@ -20,11 +20,9 @@\n #define RUST_TYTY\n \n #include \"rust-hir-map.h\"\n-#include \"rust-hir-full.h\"\n-#include \"rust-diagnostics.h\"\n-#include \"rust-abi.h\"\n #include \"rust-common.h\"\n #include \"rust-identifier.h\"\n+#include \"rust-abi.h\"\n #include \"rust-tyty-bounds.h\"\n #include \"rust-tyty-util.h\"\n #include \"rust-tyty-subst.h\"\n@@ -274,24 +272,12 @@ class ParamType : public BaseType\n   ParamType (std::string symbol, Location locus, HirId ref,\n \t     HIR::GenericParam &param,\n \t     std::vector<TypeBoundPredicate> specified_bounds,\n-\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::PARAM,\n-\t\t{Resolver::CanonicalPath::new_seg (UNKNOWN_NODEID, symbol),\n-\t\t locus},\n-\t\tspecified_bounds, refs),\n-      symbol (symbol), param (param)\n-  {}\n+\t     std::set<HirId> refs = std::set<HirId> ());\n \n   ParamType (std::string symbol, Location locus, HirId ref, HirId ty_ref,\n \t     HIR::GenericParam &param,\n \t     std::vector<TypeBoundPredicate> specified_bounds,\n-\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::PARAM,\n-\t\t{Resolver::CanonicalPath::new_seg (UNKNOWN_NODEID, symbol),\n-\t\t locus},\n-\t\tspecified_bounds, refs),\n-      symbol (symbol), param (param)\n-  {}\n+\t     std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n@@ -306,24 +292,17 @@ class ParamType : public BaseType\n \n   std::string get_symbol () const;\n \n-  HIR::GenericParam &get_generic_param () { return param; }\n+  HIR::GenericParam &get_generic_param ();\n \n-  bool can_resolve () const { return get_ref () != get_ty_ref (); }\n+  bool can_resolve () const;\n \n   BaseType *resolve () const;\n \n   std::string get_name () const override final;\n \n   bool is_equal (const BaseType &other) const override;\n \n-  bool is_concrete () const override final\n-  {\n-    auto r = resolve ();\n-    if (r == this)\n-      return false;\n-\n-    return r->is_concrete ();\n-  }\n+  bool is_concrete () const override final;\n \n   ParamType *handle_substitions (SubstitutionArgumentMappings mappings);\n \n@@ -335,31 +314,25 @@ class ParamType : public BaseType\n class StructFieldType\n {\n public:\n-  StructFieldType (HirId ref, std::string name, BaseType *ty, Location locus)\n-    : ref (ref), name (name), ty (ty), locus (locus)\n-  {}\n-\n-  HirId get_ref () const { return ref; }\n+  StructFieldType (HirId ref, std::string name, BaseType *ty, Location locus);\n \n-  std::string as_string () const;\n+  HirId get_ref () const;\n \n   bool is_equal (const StructFieldType &other) const;\n \n-  std::string get_name () const { return name; }\n-\n-  BaseType *get_field_type () const { return ty; }\n+  std::string get_name () const;\n \n-  void set_field_type (BaseType *fty) { ty = fty; }\n+  BaseType *get_field_type () const;\n+  void set_field_type (BaseType *fty);\n \n   StructFieldType *clone () const;\n-\n   StructFieldType *monomorphized_clone () const;\n \n-  bool is_concrete () const { return ty->is_concrete (); }\n-\n-  void debug () const { rust_debug (\"%s\", as_string ().c_str ()); }\n+  bool is_concrete () const;\n \n-  Location get_locus () const { return locus; }\n+  void debug () const;\n+  Location get_locus () const;\n+  std::string as_string () const;\n \n private:\n   HirId ref;\n@@ -373,29 +346,18 @@ class TupleType : public BaseType\n public:\n   TupleType (HirId ref, Location locus,\n \t     std::vector<TyVar> fields = std::vector<TyVar> (),\n-\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::TUPLE,\n-\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n-      fields (fields)\n-  {}\n+\t     std::set<HirId> refs = std::set<HirId> ());\n \n   TupleType (HirId ref, HirId ty_ref, Location locus,\n \t     std::vector<TyVar> fields = std::vector<TyVar> (),\n-\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::TUPLE,\n-\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n-      fields (fields)\n-  {}\n+\t     std::set<HirId> refs = std::set<HirId> ());\n \n-  static TupleType *get_unit_type (HirId ref)\n-  {\n-    return new TupleType (ref, Linemap::predeclared_location ());\n-  }\n+  static TupleType *get_unit_type (HirId ref);\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n-  bool is_unit () const override { return this->fields.empty (); }\n+  bool is_unit () const override;\n \n   std::string as_string () const override;\n \n@@ -404,24 +366,16 @@ class TupleType : public BaseType\n \n   bool is_equal (const BaseType &other) const override;\n \n-  size_t num_fields () const { return fields.size (); }\n+  size_t num_fields () const;\n \n   BaseType *get_field (size_t index) const;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n-  bool is_concrete () const override final\n-  {\n-    for (size_t i = 0; i < num_fields (); i++)\n-      {\n-\tif (!get_field (i)->is_concrete ())\n-\t  return false;\n-      }\n-    return true;\n-  }\n+  bool is_concrete () const override final;\n \n-  const std::vector<TyVar> &get_fields () const { return fields; }\n+  const std::vector<TyVar> &get_fields () const;\n \n   std::string get_name () const override final;\n \n@@ -507,185 +461,48 @@ class VariantDef\n     STRUCT\n   };\n \n-  static std::string variant_type_string (VariantType type)\n-  {\n-    switch (type)\n-      {\n-      case NUM:\n-\treturn \"enumeral\";\n-      case TUPLE:\n-\treturn \"tuple\";\n-      case STRUCT:\n-\treturn \"struct\";\n-      }\n-    gcc_unreachable ();\n-    return \"\";\n-  }\n+  static std::string variant_type_string (VariantType type);\n \n   VariantDef (HirId id, DefId defid, std::string identifier, RustIdent ident,\n-\t      HIR::Expr *discriminant)\n-    : id (id), defid (defid), identifier (identifier), ident (ident),\n-      discriminant (discriminant)\n-\n-  {\n-    type = VariantType::NUM;\n-    fields = {};\n-  }\n+\t      HIR::Expr *discriminant);\n \n   VariantDef (HirId id, DefId defid, std::string identifier, RustIdent ident,\n \t      VariantType type, HIR::Expr *discriminant,\n-\t      std::vector<StructFieldType *> fields)\n-    : id (id), defid (defid), identifier (identifier), ident (ident),\n-      type (type), discriminant (discriminant), fields (fields)\n-  {\n-    rust_assert (\n-      (type == VariantType::NUM && fields.empty ())\n-      || (type == VariantType::TUPLE || type == VariantType::STRUCT));\n-  }\n+\t      std::vector<StructFieldType *> fields);\n \n-  VariantDef (const VariantDef &other)\n-    : id (other.id), defid (other.defid), identifier (other.identifier),\n-      ident (other.ident), type (other.type), discriminant (other.discriminant),\n-      fields (other.fields)\n-  {}\n+  VariantDef (const VariantDef &other);\n \n-  VariantDef &operator= (const VariantDef &other)\n-  {\n-    id = other.id;\n-    identifier = other.identifier;\n-    type = other.type;\n-    discriminant = other.discriminant;\n-    fields = other.fields;\n-    ident = other.ident;\n-\n-    return *this;\n-  }\n+  VariantDef &operator= (const VariantDef &other);\n \n-  static VariantDef &get_error_node ()\n-  {\n-    static VariantDef node\n-      = VariantDef (UNKNOWN_HIRID, UNKNOWN_DEFID, \"\",\n-\t\t    {Resolver::CanonicalPath::create_empty (),\n-\t\t     Linemap::unknown_location ()},\n-\t\t    nullptr);\n+  static VariantDef &get_error_node ();\n+  bool is_error () const;\n \n-    return node;\n-  }\n+  HirId get_id () const;\n+  DefId get_defid () const;\n \n-  bool is_error () const { return get_id () == UNKNOWN_HIRID; }\n+  VariantType get_variant_type () const;\n+  bool is_data_variant () const;\n+  bool is_dataless_variant () const;\n \n-  HirId get_id () const { return id; }\n-  DefId get_defid () const { return defid; }\n+  std::string get_identifier () const;\n \n-  VariantType get_variant_type () const { return type; }\n-  bool is_data_variant () const { return type != VariantType::NUM; }\n-  bool is_dataless_variant () const { return type == VariantType::NUM; }\n+  size_t num_fields () const;\n+  StructFieldType *get_field_at_index (size_t index);\n \n-  std::string get_identifier () const { return identifier; }\n-\n-  size_t num_fields () const { return fields.size (); }\n-  StructFieldType *get_field_at_index (size_t index)\n-  {\n-    rust_assert (index < fields.size ());\n-    return fields.at (index);\n-  }\n-\n-  std::vector<StructFieldType *> &get_fields ()\n-  {\n-    rust_assert (type != NUM);\n-    return fields;\n-  }\n+  std::vector<StructFieldType *> &get_fields ();\n \n   bool lookup_field (const std::string &lookup, StructFieldType **field_lookup,\n-\t\t     size_t *index) const\n-  {\n-    size_t i = 0;\n-    for (auto &field : fields)\n-      {\n-\tif (field->get_name ().compare (lookup) == 0)\n-\t  {\n-\t    if (index != nullptr)\n-\t      *index = i;\n-\n-\t    if (field_lookup != nullptr)\n-\t      *field_lookup = field;\n-\n-\t    return true;\n-\t  }\n-\ti++;\n-      }\n-    return false;\n-  }\n-\n-  HIR::Expr *get_discriminant () const\n-  {\n-    rust_assert (discriminant != nullptr);\n-    return discriminant;\n-  }\n-\n-  std::string as_string () const\n-  {\n-    if (type == VariantType::NUM)\n-      return identifier + \" = \" + discriminant->as_string ();\n-\n-    std::string buffer;\n-    for (size_t i = 0; i < fields.size (); ++i)\n-      {\n-\tbuffer += fields.at (i)->as_string ();\n-\tif ((i + 1) < fields.size ())\n-\t  buffer += \", \";\n-      }\n-\n-    if (type == VariantType::TUPLE)\n-      return identifier + \" (\" + buffer + \")\";\n-    else\n-      return identifier + \" {\" + buffer + \"}\";\n-  }\n-\n-  bool is_equal (const VariantDef &other) const\n-  {\n-    if (type != other.type)\n-      return false;\n-\n-    if (identifier.compare (other.identifier) != 0)\n-      return false;\n+\t\t     size_t *index) const;\n \n-    if (discriminant != other.discriminant)\n-      return false;\n-\n-    if (fields.size () != other.fields.size ())\n-      return false;\n-\n-    for (size_t i = 0; i < fields.size (); i++)\n-      {\n-\tif (!fields.at (i)->is_equal (*other.fields.at (i)))\n-\t  return false;\n-      }\n-\n-    return true;\n-  }\n-\n-  VariantDef *clone () const\n-  {\n-    std::vector<StructFieldType *> cloned_fields;\n-    for (auto &f : fields)\n-      cloned_fields.push_back ((StructFieldType *) f->clone ());\n+  HIR::Expr *get_discriminant () const;\n \n-    return new VariantDef (id, defid, identifier, ident, type, discriminant,\n-\t\t\t   cloned_fields);\n-  }\n+  std::string as_string () const;\n \n-  VariantDef *monomorphized_clone () const\n-  {\n-    std::vector<StructFieldType *> cloned_fields;\n-    for (auto &f : fields)\n-      cloned_fields.push_back ((StructFieldType *) f->monomorphized_clone ());\n+  bool is_equal (const VariantDef &other) const;\n+  VariantDef *clone () const;\n+  VariantDef *monomorphized_clone () const;\n \n-    return new VariantDef (id, defid, identifier, ident, type, discriminant,\n-\t\t\t   cloned_fields);\n-  }\n-\n-  const RustIdent &get_ident () const { return ident; }\n+  const RustIdent &get_ident () const;\n \n private:\n   HirId id;\n@@ -1262,33 +1079,22 @@ class SliceType : public BaseType\n class BoolType : public BaseType\n {\n public:\n-  BoolType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::BOOL,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n-\n-  BoolType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::BOOL,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n+  BoolType (HirId ref, std::set<HirId> refs = std::set<HirId> ());\n+  BoolType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n \n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n-  bool is_concrete () const override final { return true; }\n+  bool is_concrete () const override final;\n };\n \n class IntType : public BaseType\n@@ -1303,40 +1109,27 @@ class IntType : public BaseType\n     I128\n   };\n \n-  IntType (HirId ref, IntKind kind, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::INT,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      int_kind (kind)\n-  {}\n-\n+  IntType (HirId ref, IntKind kind, std::set<HirId> refs = std::set<HirId> ());\n   IntType (HirId ref, HirId ty_ref, IntKind kind,\n-\t   std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::INT,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      int_kind (kind)\n-  {}\n+\t   std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n \n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  IntKind get_int_kind () const { return int_kind; }\n+  IntKind get_int_kind () const;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n   bool is_equal (const BaseType &other) const override;\n-  bool is_concrete () const override final { return true; }\n+  bool is_concrete () const override final;\n \n private:\n   IntKind int_kind;\n@@ -1354,40 +1147,28 @@ class UintType : public BaseType\n     U128\n   };\n \n-  UintType (HirId ref, UintKind kind, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::UINT,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      uint_kind (kind)\n-  {}\n-\n+  UintType (HirId ref, UintKind kind,\n+\t    std::set<HirId> refs = std::set<HirId> ());\n   UintType (HirId ref, HirId ty_ref, UintKind kind,\n-\t    std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::UINT,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      uint_kind (kind)\n-  {}\n+\t    std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n \n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  UintKind get_uint_kind () const { return uint_kind; }\n+  UintKind get_uint_kind () const;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n   bool is_equal (const BaseType &other) const override;\n-  bool is_concrete () const override final { return true; }\n+  bool is_concrete () const override final;\n \n private:\n   UintKind uint_kind;\n@@ -1403,40 +1184,26 @@ class FloatType : public BaseType\n   };\n \n   FloatType (HirId ref, FloatKind kind,\n-\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::FLOAT,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      float_kind (kind)\n-  {}\n-\n+\t     std::set<HirId> refs = std::set<HirId> ());\n   FloatType (HirId ref, HirId ty_ref, FloatKind kind,\n-\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::FLOAT,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      float_kind (kind)\n-  {}\n+\t     std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n-\n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  FloatKind get_float_kind () const { return float_kind; }\n+  FloatKind get_float_kind () const;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n   bool is_equal (const BaseType &other) const override;\n-  bool is_concrete () const override final { return true; }\n+  bool is_concrete () const override final;\n \n private:\n   FloatKind float_kind;\n@@ -1445,117 +1212,72 @@ class FloatType : public BaseType\n class USizeType : public BaseType\n {\n public:\n-  USizeType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::USIZE,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n-\n-  USizeType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::USIZE,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n+  USizeType (HirId ref, std::set<HirId> refs = std::set<HirId> ());\n+  USizeType (HirId ref, HirId ty_ref,\n+\t     std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n-\n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n-  bool is_concrete () const override final { return true; }\n+  bool is_concrete () const override final;\n };\n \n class ISizeType : public BaseType\n {\n public:\n-  ISizeType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::ISIZE,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n-\n-  ISizeType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::ISIZE,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n+  ISizeType (HirId ref, std::set<HirId> refs = std::set<HirId> ());\n+  ISizeType (HirId ref, HirId ty_ref,\n+\t     std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n-\n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n-  bool is_concrete () const override final { return true; }\n+  bool is_concrete () const override final;\n };\n \n class CharType : public BaseType\n {\n public:\n-  CharType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::CHAR,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n-\n-  CharType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::CHAR,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n+  CharType (HirId ref, std::set<HirId> refs = std::set<HirId> ());\n+  CharType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n-\n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n-  bool is_concrete () const override final { return true; }\n+  bool is_concrete () const override final;\n };\n \n class StrType : public BaseType\n {\n public:\n-  StrType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::STR,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n-\n-  StrType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::STR,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n+  StrType (HirId ref, std::set<HirId> refs = std::set<HirId> ());\n+  StrType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ());\n \n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n@@ -1569,29 +1291,16 @@ class StrType : public BaseType\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n-  bool is_concrete () const override final { return true; }\n+  bool is_concrete () const override final;\n };\n \n class ReferenceType : public BaseType\n {\n public:\n   ReferenceType (HirId ref, TyVar base, Mutability mut,\n-\t\t std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::REF,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      base (base), mut (mut)\n-  {}\n-\n+\t\t std::set<HirId> refs = std::set<HirId> ());\n   ReferenceType (HirId ref, HirId ty_ref, TyVar base, Mutability mut,\n-\t\t std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::REF,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      base (base), mut (mut)\n-  {}\n+\t\t std::set<HirId> refs = std::set<HirId> ());\n \n   BaseType *get_base () const;\n \n@@ -1610,45 +1319,19 @@ class ReferenceType : public BaseType\n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n-  bool is_concrete () const override final\n-  {\n-    return get_base ()->is_concrete ();\n-  }\n+  bool is_concrete () const override final;\n \n   ReferenceType *handle_substitions (SubstitutionArgumentMappings mappings);\n \n-  Mutability mutability () const { return mut; }\n+  Mutability mutability () const;\n \n-  bool is_mutable () const { return mut == Mutability::Mut; }\n+  bool is_mutable () const;\n \n-  bool is_dyn_object () const\n-  {\n-    return is_dyn_slice_type () || is_dyn_str_type ();\n-  }\n+  bool is_dyn_object () const;\n \n-  bool is_dyn_slice_type (const TyTy::SliceType **slice = nullptr) const\n-  {\n-    const TyTy::BaseType *element = get_base ()->destructure ();\n-    if (element->get_kind () != TyTy::TypeKind::SLICE)\n-      return false;\n-    if (slice == nullptr)\n-      return true;\n+  bool is_dyn_slice_type (const TyTy::SliceType **slice = nullptr) const;\n \n-    *slice = static_cast<const TyTy::SliceType *> (element);\n-    return true;\n-  }\n-\n-  bool is_dyn_str_type (const TyTy::StrType **str = nullptr) const\n-  {\n-    const TyTy::BaseType *element = get_base ()->destructure ();\n-    if (element->get_kind () != TyTy::TypeKind::STR)\n-      return false;\n-    if (str == nullptr)\n-      return true;\n-\n-    *str = static_cast<const TyTy::StrType *> (element);\n-    return true;\n-  }\n+  bool is_dyn_str_type (const TyTy::StrType **str = nullptr) const;\n \n private:\n   TyVar base;\n@@ -1659,22 +1342,9 @@ class PointerType : public BaseType\n {\n public:\n   PointerType (HirId ref, TyVar base, Mutability mut,\n-\t       std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::POINTER,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      base (base), mut (mut)\n-  {}\n-\n+\t       std::set<HirId> refs = std::set<HirId> ());\n   PointerType (HirId ref, HirId ty_ref, TyVar base, Mutability mut,\n-\t       std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::POINTER,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      base (base), mut (mut)\n-  {}\n+\t       std::set<HirId> refs = std::set<HirId> ());\n \n   BaseType *get_base () const;\n \n@@ -1692,47 +1362,17 @@ class PointerType : public BaseType\n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n-  bool is_concrete () const override final\n-  {\n-    return get_base ()->is_concrete ();\n-  }\n+  bool is_concrete () const override final;\n \n   PointerType *handle_substitions (SubstitutionArgumentMappings mappings);\n \n-  Mutability mutability () const { return mut; }\n-\n-  bool is_mutable () const { return mut == Mutability::Mut; }\n-\n-  bool is_const () const { return mut == Mutability::Imm; }\n-\n-  bool is_dyn_object () const\n-  {\n-    return is_dyn_slice_type () || is_dyn_str_type ();\n-  }\n-\n-  bool is_dyn_slice_type (const TyTy::SliceType **slice = nullptr) const\n-  {\n-    const TyTy::BaseType *element = get_base ()->destructure ();\n-    if (element->get_kind () != TyTy::TypeKind::SLICE)\n-      return false;\n-    if (slice == nullptr)\n-      return true;\n+  Mutability mutability () const;\n+  bool is_mutable () const;\n+  bool is_const () const;\n+  bool is_dyn_object () const;\n \n-    *slice = static_cast<const TyTy::SliceType *> (element);\n-    return true;\n-  }\n-\n-  bool is_dyn_str_type (const TyTy::StrType **str = nullptr) const\n-  {\n-    const TyTy::BaseType *element = get_base ()->destructure ();\n-    if (element->get_kind () != TyTy::TypeKind::STR)\n-      return false;\n-    if (str == nullptr)\n-      return true;\n-\n-    *str = static_cast<const TyTy::StrType *> (element);\n-    return true;\n-  }\n+  bool is_dyn_slice_type (const TyTy::SliceType **slice = nullptr) const;\n+  bool is_dyn_str_type (const TyTy::StrType **str = nullptr) const;\n \n private:\n   TyVar base;\n@@ -1752,19 +1392,9 @@ class PointerType : public BaseType\n class NeverType : public BaseType\n {\n public:\n-  NeverType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::NEVER,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n-\n-  NeverType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::NEVER,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n+  NeverType (HirId ref, std::set<HirId> refs = std::set<HirId> ());\n+  NeverType (HirId ref, HirId ty_ref,\n+\t     std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n@@ -1777,10 +1407,10 @@ class NeverType : public BaseType\n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n-  bool is_unit () const override { return true; }\n-  bool is_concrete () const override final { return true; }\n+  bool is_unit () const override;\n+  bool is_concrete () const override final;\n };\n \n // used at the type in associated types in traits\n@@ -1789,22 +1419,9 @@ class PlaceholderType : public BaseType\n {\n public:\n   PlaceholderType (std::string symbol, HirId ref,\n-\t\t   std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::PLACEHOLDER,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      symbol (symbol)\n-  {}\n-\n+\t\t   std::set<HirId> refs = std::set<HirId> ());\n   PlaceholderType (std::string symbol, HirId ref, HirId ty_ref,\n-\t\t   std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::PLACEHOLDER,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      symbol (symbol)\n-  {}\n+\t\t   std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n@@ -1817,15 +1434,11 @@ class PlaceholderType : public BaseType\n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n-  bool is_unit () const override\n-  {\n-    rust_assert (can_resolve ());\n-    return resolve ()->is_unit ();\n-  }\n+  bool is_unit () const override;\n \n-  std::string get_symbol () const { return symbol; }\n+  std::string get_symbol () const;\n \n   void set_associated_type (HirId ref);\n \n@@ -1837,13 +1450,7 @@ class PlaceholderType : public BaseType\n \n   bool is_equal (const BaseType &other) const override;\n \n-  bool is_concrete () const override final\n-  {\n-    if (!can_resolve ())\n-      return true;\n-\n-    return resolve ()->is_concrete ();\n-  }\n+  bool is_concrete () const override final;\n \n private:\n   std::string symbol;\n@@ -1857,28 +1464,14 @@ class ProjectionType : public BaseType, public SubstitutionRef\n \t\t  std::vector<SubstitutionParamMapping> subst_refs,\n \t\t  SubstitutionArgumentMappings generic_arguments\n \t\t  = SubstitutionArgumentMappings::error (),\n-\t\t  std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::PROJECTION,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n-      base (base), trait (trait), item (item)\n-  {}\n+\t\t  std::set<HirId> refs = std::set<HirId> ());\n \n   ProjectionType (HirId ref, HirId ty_ref, BaseType *base,\n \t\t  const Resolver::TraitReference *trait, DefId item,\n \t\t  std::vector<SubstitutionParamMapping> subst_refs,\n \t\t  SubstitutionArgumentMappings generic_arguments\n \t\t  = SubstitutionArgumentMappings::error (),\n-\t\t  std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::PROJECTION,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n-      base (base), trait (trait), item (item)\n-  {}\n+\t\t  std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n@@ -1891,26 +1484,20 @@ class ProjectionType : public BaseType, public SubstitutionRef\n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n-  bool is_unit () const override { return false; }\n+  bool is_unit () const override;\n \n-  bool needs_generic_substitutions () const override final\n-  {\n-    return needs_substitution ();\n-  }\n+  bool needs_generic_substitutions () const override final;\n \n-  bool supports_substitutions () const override final { return true; }\n+  bool supports_substitutions () const override final;\n \n-  bool has_subsititions_defined () const override final\n-  {\n-    return has_substitutions ();\n-  }\n+  bool has_subsititions_defined () const override final;\n \n-  const BaseType *get () const { return base; }\n-  BaseType *get () { return base; }\n+  const BaseType *get () const;\n+  BaseType *get ();\n \n-  bool is_concrete () const override final { return base->is_concrete (); }\n+  bool is_concrete () const override final;\n \n   ProjectionType *\n   handle_substitions (SubstitutionArgumentMappings mappings) override final;\n@@ -1926,15 +1513,11 @@ class DynamicObjectType : public BaseType\n public:\n   DynamicObjectType (HirId ref, RustIdent ident,\n \t\t     std::vector<TypeBoundPredicate> specified_bounds,\n-\t\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::DYNAMIC, ident, specified_bounds, refs)\n-  {}\n+\t\t     std::set<HirId> refs = std::set<HirId> ());\n \n   DynamicObjectType (HirId ref, HirId ty_ref, RustIdent ident,\n \t\t     std::vector<TypeBoundPredicate> specified_bounds,\n-\t\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::DYNAMIC, ident, specified_bounds, refs)\n-  {}\n+\t\t     std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n@@ -1951,7 +1534,7 @@ class DynamicObjectType : public BaseType\n \n   std::string get_name () const override final;\n \n-  bool is_concrete () const override final { return true; }\n+  bool is_concrete () const override final;\n \n   // this returns a flat list of items including super trait bounds\n   const std::vector<"}]}