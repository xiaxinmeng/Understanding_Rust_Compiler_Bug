{"sha": "5d86f5f999de9315fc3b2220d7a04577662fbf20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ4NmY1Zjk5OWRlOTMxNWZjM2IyMjIwZDdhMDQ1Nzc2NjJmYmYyMA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-22T20:49:31Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-22T20:49:31Z"}, "message": "reload: Use rtx_insn (also touches caller-save.c and config/arc/arc)\n\ngcc/\n\t* reload.h (struct insn_chain): Strengthen field \"insn\" from rtx\n\tto rtx_insn *.\n\t(find_reloads): Likewise for param 1.\n\t(subst_reloads): Likewise for sole param.\n\t(find_equiv_reg): Likwise for param 2.\n\t(regno_clobbered_p): Likwise for param 2.\n\t(reload): Likewise for param 1.\n\n\t* caller-save.c (save_call_clobbered_regs): Strengthen local\n\t\"insn\" from rtx to rtx_insn *.\n\t(insert_one_insn): Likewise for local \"insn\".\n\n\t* reload.c (this_insn): Likewise for this global.\n\t(find_reloads): Likewise for param \"insn\".\n\t(find_reloads_toplev): Likewise.\n\t(find_reloads_address): Likewise.\n\t(subst_reg_equivs): Likewise.\n\t(update_auto_inc_notes): Likewise.\n\t(find_reloads_address_1): Likewise.\n\t(find_reloads_subreg_address): Likewise.\n\t(subst_reloads): Likewise.\n\t(find_equiv_reg): Likewise, also for local \"p\".\n\t(regno_clobbered_p): Likewise for param \"insn\".\n\n\t* reload1.c (reg_reloaded_insn): Likewise for the elements of this\n\tarray.\n\t(spill_reg_store): Likewise for the elements of this array.\n\t(remove_init_insns): Likewise for local \"equiv_insn\".\n\t(will_delete_init_insn_p): Likewise for param \"insn\".\n\t(reload): Likewise for param \"\"first\" and local \"insn\".\n\t(calculate_needs_all_insns): Strengthen local \"insn\" from rtx to\n\trtx_insn *.\n\t(calculate_elim_costs_all_insns): Likewise.\n\t(delete_caller_save_insns): Likewise.\n\t(spill_failure): Likewise for param \"insn\".\n\t(delete_dead_insn): Likewise.\n\t(set_label_offsets): Likewise.\n\t(eliminate_regs_in_insn): Likewise, also for locals \"base_insn\" and\n\t\"prev_insn\".\n\t(elimination_costs_in_insn): Likewise for param \"insn\".\n\t(set_initial_eh_label_offset): Replace use of NULL_RTX with NULL\n\twhen referring to an insn.\n\t(set_initial_label_offsets): Likewise.\n\t(set_offsets_for_label): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(init_eliminable_invariants): Likewise for param \"first\" and local\n\t\"insn\".\n\t(fixup_eh_region_note): Likewise for param \"insn\".\n\t(reload_as_needed): Likewise for locals \"prev\", \"insn\",\n\t\"old_next\", \"old_prev\", \"next\".\n\t(gen_reload_chain_without_interm_reg_p): Likewise for locals \"insn\",\n\t\"last\".\n\t(reload_inheritance_insn): Strengthen elements of this array from\n\trtx to rtx_insn *.\n\t(failed_reload): Likewise for param \"insn\".\n\t(choose_reload_regs): Likewise for local \"insn\".  Replace use of\n\tNULL_RTX with NULL when referring to an insn.\n\t(input_reload_insns): Strengthen elements of this array from rtx\n\tto rtx_insn *.\n\t(other_input_address_reload_insns): Likewise for this global.\n\t(other_input_reload_insns): Likewise for this global.\n\t(input_address_reload_insns): Likwise for the elements of this\n\tarray.\n\t(inpaddr_address_reload_insns): Likwise for the elements of this\n\tarray.\n\t(output_reload_insns): Likewise for the elements of this array.\n\t(output_address_reload_insns): Likewise for the elements of this\n\tarray.\n\t(outaddr_address_reload_insns): Likewise for the elements of this\n\tarray.\n\t(operand_reload_insns): Likewise for this global.\n\t(other_operand_reload_insns): Likewise for this global.\n\t(other_output_reload_insns): Likewise for the elements of this\n\tarray.\n\t(new_spill_reg_store): Likewise for the elements of this\n\tarray.\n\t(emit_input_reload_insns): Likewise for locals \"insn\", \"temp\".\n\tStrengthen local \"where\" from rtx * to rtx_insn **.\n\t(emit_output_reload_insns): Strengthen locals \"insn\", \"p\", \"next\"\n\tfrom rtx to rtx_insn *.\n\t(do_input_reload): Likewise for local \"insn\".\n\t(do_output_reload): Likewise for local \"insn\".\n\t(emit_reload_insns): Likewise for locals \"insn\" and \"store_insn\".\n\t(emit_insn_if_valid_for_reload): Likewise for return type and local\n\t\"last\".  Add checked cast to rtx_insn when returning \"insn\" since\n\tthis has been through emit_insn.\n\t(gen_reload): Strengthen return type and locals \"last\", \"insn\", \"set\"\n\tfrom rtx to rtx_insn *.  Add checked cast to rtx_insn when\n\treturning \"insn\" since it's been through\n\temit_insn_if_valid_for_reload at this point.\n\t(delete_output_reload): Strengthen param \"insn\" and locals\n\t\"output_reload_insn\", \"i2\" from rtx to rtx_insn *.\n\t(delete_address_reloads): Likewise for params \"dead_insn\",\n\t\"current_insn\" and locals \"prev\", \"next\".\n\t(delete_address_reloads_1): Likewise for params \"dead_insn\",\n\t\"current_insn\" and locals \"prev\", \"i2\".\n\t(inc_for_reload): Likewise for locals \"last\", \"add_insn\".\n\t(add_auto_inc_notes): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\n\t* config/arc/arc-protos.h (regno_clobbered_p): Likewise for 2nd\n\tparam of this duplicate of the prototype from reload.h\n\nFrom-SVN: r214370", "tree": {"sha": "532a948321aba61df69e0c9c2333f8510d4068ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/532a948321aba61df69e0c9c2333f8510d4068ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d86f5f999de9315fc3b2220d7a04577662fbf20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d86f5f999de9315fc3b2220d7a04577662fbf20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d86f5f999de9315fc3b2220d7a04577662fbf20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d86f5f999de9315fc3b2220d7a04577662fbf20/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7839a073c18dbc7b9e3f7539c87ed064914ddfd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7839a073c18dbc7b9e3f7539c87ed064914ddfd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7839a073c18dbc7b9e3f7539c87ed064914ddfd3"}], "stats": {"total": 347, "additions": 230, "deletions": 117}, "files": [{"sha": "7872e5801a86b2619ed286cdcc7470a65ed778d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d86f5f999de9315fc3b2220d7a04577662fbf20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d86f5f999de9315fc3b2220d7a04577662fbf20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d86f5f999de9315fc3b2220d7a04577662fbf20", "patch": "@@ -1,3 +1,108 @@\n+2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* reload.h (struct insn_chain): Strengthen field \"insn\" from rtx\n+\tto rtx_insn *.\n+\t(find_reloads): Likewise for param 1.\n+\t(subst_reloads): Likewise for sole param.\n+\t(find_equiv_reg): Likwise for param 2.\n+\t(regno_clobbered_p): Likwise for param 2.\n+\t(reload): Likewise for param 1.\n+\n+\t* caller-save.c (save_call_clobbered_regs): Strengthen local\n+\t\"insn\" from rtx to rtx_insn *.\n+\t(insert_one_insn): Likewise for local \"insn\".\n+\n+\t* reload.c (this_insn): Likewise for this global.\n+\t(find_reloads): Likewise for param \"insn\".\n+\t(find_reloads_toplev): Likewise.\n+\t(find_reloads_address): Likewise.\n+\t(subst_reg_equivs): Likewise.\n+\t(update_auto_inc_notes): Likewise.\n+\t(find_reloads_address_1): Likewise.\n+\t(find_reloads_subreg_address): Likewise.\n+\t(subst_reloads): Likewise.\n+\t(find_equiv_reg): Likewise, also for local \"p\".\n+\t(regno_clobbered_p): Likewise for param \"insn\".\n+\n+\t* reload1.c (reg_reloaded_insn): Likewise for the elements of this\n+\tarray.\n+\t(spill_reg_store): Likewise for the elements of this array.\n+\t(remove_init_insns): Likewise for local \"equiv_insn\".\n+\t(will_delete_init_insn_p): Likewise for param \"insn\".\n+\t(reload): Likewise for param \"\"first\" and local \"insn\".\n+\t(calculate_needs_all_insns): Strengthen local \"insn\" from rtx to\n+\trtx_insn *.\n+\t(calculate_elim_costs_all_insns): Likewise.\n+\t(delete_caller_save_insns): Likewise.\n+\t(spill_failure): Likewise for param \"insn\".\n+\t(delete_dead_insn): Likewise.\n+\t(set_label_offsets): Likewise.\n+\t(eliminate_regs_in_insn): Likewise, also for locals \"base_insn\" and\n+\t\"prev_insn\".\n+\t(elimination_costs_in_insn): Likewise for param \"insn\".\n+\t(set_initial_eh_label_offset): Replace use of NULL_RTX with NULL\n+\twhen referring to an insn.\n+\t(set_initial_label_offsets): Likewise.\n+\t(set_offsets_for_label): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(init_eliminable_invariants): Likewise for param \"first\" and local\n+\t\"insn\".\n+\t(fixup_eh_region_note): Likewise for param \"insn\".\n+\t(reload_as_needed): Likewise for locals \"prev\", \"insn\",\n+\t\"old_next\", \"old_prev\", \"next\".\n+\t(gen_reload_chain_without_interm_reg_p): Likewise for locals \"insn\",\n+\t\"last\".\n+\t(reload_inheritance_insn): Strengthen elements of this array from\n+\trtx to rtx_insn *.\n+\t(failed_reload): Likewise for param \"insn\".\n+\t(choose_reload_regs): Likewise for local \"insn\".  Replace use of\n+\tNULL_RTX with NULL when referring to an insn.\n+\t(input_reload_insns): Strengthen elements of this array from rtx\n+\tto rtx_insn *.\n+\t(other_input_address_reload_insns): Likewise for this global.\n+\t(other_input_reload_insns): Likewise for this global.\n+\t(input_address_reload_insns): Likwise for the elements of this\n+\tarray.\n+\t(inpaddr_address_reload_insns): Likwise for the elements of this\n+\tarray.\n+\t(output_reload_insns): Likewise for the elements of this array.\n+\t(output_address_reload_insns): Likewise for the elements of this\n+\tarray.\n+\t(outaddr_address_reload_insns): Likewise for the elements of this\n+\tarray.\n+\t(operand_reload_insns): Likewise for this global.\n+\t(other_operand_reload_insns): Likewise for this global.\n+\t(other_output_reload_insns): Likewise for the elements of this\n+\tarray.\n+\t(new_spill_reg_store): Likewise for the elements of this\n+\tarray.\n+\t(emit_input_reload_insns): Likewise for locals \"insn\", \"temp\".\n+\tStrengthen local \"where\" from rtx * to rtx_insn **.\n+\t(emit_output_reload_insns): Strengthen locals \"insn\", \"p\", \"next\"\n+\tfrom rtx to rtx_insn *.\n+\t(do_input_reload): Likewise for local \"insn\".\n+\t(do_output_reload): Likewise for local \"insn\".\n+\t(emit_reload_insns): Likewise for locals \"insn\" and \"store_insn\".\n+\t(emit_insn_if_valid_for_reload): Likewise for return type and local\n+\t\"last\".  Add checked cast to rtx_insn when returning \"insn\" since\n+\tthis has been through emit_insn.\n+\t(gen_reload): Strengthen return type and locals \"last\", \"insn\", \"set\"\n+\tfrom rtx to rtx_insn *.  Add checked cast to rtx_insn when\n+\treturning \"insn\" since it's been through\n+\temit_insn_if_valid_for_reload at this point.\n+\t(delete_output_reload): Strengthen param \"insn\" and locals\n+\t\"output_reload_insn\", \"i2\" from rtx to rtx_insn *.\n+\t(delete_address_reloads): Likewise for params \"dead_insn\",\n+\t\"current_insn\" and locals \"prev\", \"next\".\n+\t(delete_address_reloads_1): Likewise for params \"dead_insn\",\n+\t\"current_insn\" and locals \"prev\", \"i2\".\n+\t(inc_for_reload): Likewise for locals \"last\", \"add_insn\".\n+\t(add_auto_inc_notes): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\n+\t* config/arc/arc-protos.h (regno_clobbered_p): Likewise for 2nd\n+\tparam of this duplicate of the prototype from reload.h\n+\n 2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n \n \t* regstat.c (regstat_bb_compute_ri): Strengthen local \"insn\" from"}, {"sha": "03d22a0c6cbd6f53a4b3a4f8b19dc0dc42b1c2df", "filename": "gcc/caller-save.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d86f5f999de9315fc3b2220d7a04577662fbf20/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d86f5f999de9315fc3b2220d7a04577662fbf20/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=5d86f5f999de9315fc3b2220d7a04577662fbf20", "patch": "@@ -755,7 +755,7 @@ save_call_clobbered_regs (void)\n \n   for (chain = reload_insn_chain; chain != 0; chain = next)\n     {\n-      rtx insn = chain->insn;\n+      rtx_insn *insn = chain->insn;\n       enum rtx_code code = GET_CODE (insn);\n \n       next = chain->next;\n@@ -1372,7 +1372,7 @@ add_used_regs (rtx *loc, void *data)\n static struct insn_chain *\n insert_one_insn (struct insn_chain *chain, int before_p, int code, rtx pat)\n {\n-  rtx insn = chain->insn;\n+  rtx_insn *insn = chain->insn;\n   struct insn_chain *new_chain;\n \n #ifdef HAVE_cc0"}, {"sha": "f6759729afcd13fabe430fbacd3f7d831cb1fc67", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d86f5f999de9315fc3b2220d7a04577662fbf20/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d86f5f999de9315fc3b2220d7a04577662fbf20/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=5d86f5f999de9315fc3b2220d7a04577662fbf20", "patch": "@@ -113,6 +113,6 @@ extern int arc_decl_pretend_args (tree decl);\n extern bool arc_short_comparison_p (rtx, int);\n extern bool arc_epilogue_uses (int regno);\n /* insn-attrtab.c doesn't include reload.h, which declares regno_clobbered_p. */\n-extern int regno_clobbered_p (unsigned int, rtx, enum machine_mode, int);\n+extern int regno_clobbered_p (unsigned int, rtx_insn *, enum machine_mode, int);\n extern int arc_return_slot_offset (void);\n extern bool arc_legitimize_reload_address (rtx *, enum machine_mode, int, int);"}, {"sha": "e27635b2e2c786bce7b0411dc73ee337abc9cd51", "filename": "gcc/reload.c", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d86f5f999de9315fc3b2220d7a04577662fbf20/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d86f5f999de9315fc3b2220d7a04577662fbf20/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=5d86f5f999de9315fc3b2220d7a04577662fbf20", "patch": "@@ -191,7 +191,7 @@ static int secondary_memlocs_elim_used = 0;\n \n /* The instruction we are doing reloads for;\n    so we can test whether a register dies in it.  */\n-static rtx this_insn;\n+static rtx_insn *this_insn;\n \n /* Nonzero if this instruction is a user-specified asm with operands.  */\n static int this_insn_is_asm;\n@@ -264,24 +264,24 @@ static int hard_reg_set_here_p (unsigned int, unsigned int, rtx);\n static struct decomposition decompose (rtx);\n static int immune_p (rtx, rtx, struct decomposition);\n static bool alternative_allows_const_pool_ref (rtx, const char *, int);\n-static rtx find_reloads_toplev (rtx, int, enum reload_type, int, int, rtx,\n-\t\t\t\tint *);\n+static rtx find_reloads_toplev (rtx, int, enum reload_type, int, int,\n+\t\t\t\trtx_insn *, int *);\n static rtx make_memloc (rtx, int);\n static int maybe_memory_address_addr_space_p (enum machine_mode, rtx,\n \t\t\t\t\t      addr_space_t, rtx *);\n static int find_reloads_address (enum machine_mode, rtx *, rtx, rtx *,\n-\t\t\t\t int, enum reload_type, int, rtx);\n-static rtx subst_reg_equivs (rtx, rtx);\n+\t\t\t\t int, enum reload_type, int, rtx_insn *);\n+static rtx subst_reg_equivs (rtx, rtx_insn *);\n static rtx subst_indexed_address (rtx);\n-static void update_auto_inc_notes (rtx, int, int);\n+static void update_auto_inc_notes (rtx_insn *, int, int);\n static int find_reloads_address_1 (enum machine_mode, addr_space_t, rtx, int,\n \t\t\t\t   enum rtx_code, enum rtx_code, rtx *,\n-\t\t\t\t   int, enum reload_type,int, rtx);\n+\t\t\t\t   int, enum reload_type,int, rtx_insn *);\n static void find_reloads_address_part (rtx, rtx *, enum reg_class,\n \t\t\t\t       enum machine_mode, int,\n \t\t\t\t       enum reload_type, int);\n static rtx find_reloads_subreg_address (rtx, int, enum reload_type,\n-\t\t\t\t\tint, rtx, int *);\n+\t\t\t\t\tint, rtx_insn *, int *);\n static void copy_replacements_1 (rtx *, rtx *, int);\n static int find_inc_amount (rtx, rtx);\n static int refers_to_mem_for_reload_p (rtx);\n@@ -2609,7 +2609,7 @@ safe_from_earlyclobber (rtx op, rtx clobber)\n    commutative operands, reg_equiv_address substitution, or whatever.  */\n \n int\n-find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n+find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \t      short *reload_reg_p)\n {\n   int insn_code_number;\n@@ -4667,7 +4667,7 @@ alternative_allows_const_pool_ref (rtx mem ATTRIBUTE_UNUSED,\n \n static rtx\n find_reloads_toplev (rtx x, int opnum, enum reload_type type,\n-\t\t     int ind_levels, int is_set_dest, rtx insn,\n+\t\t     int ind_levels, int is_set_dest, rtx_insn *insn,\n \t\t     int *address_reloaded)\n {\n   RTX_CODE code = GET_CODE (x);\n@@ -4875,7 +4875,7 @@ maybe_memory_address_addr_space_p (enum machine_mode mode, rtx ad,\n static int\n find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t\t      rtx *loc, int opnum, enum reload_type type,\n-\t\t      int ind_levels, rtx insn)\n+\t\t      int ind_levels, rtx_insn *insn)\n {\n   addr_space_t as = memrefloc? MEM_ADDR_SPACE (*memrefloc)\n \t\t\t     : ADDR_SPACE_GENERIC;\n@@ -5277,7 +5277,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n    front of it for pseudos that we have to replace with stack slots.  */\n \n static rtx\n-subst_reg_equivs (rtx ad, rtx insn)\n+subst_reg_equivs (rtx ad, rtx_insn *insn)\n {\n   RTX_CODE code = GET_CODE (ad);\n   int i;\n@@ -5453,7 +5453,7 @@ subst_indexed_address (rtx addr)\n    RELOADNUM is the reload number.  */\n \n static void\n-update_auto_inc_notes (rtx insn ATTRIBUTE_UNUSED, int regno ATTRIBUTE_UNUSED,\n+update_auto_inc_notes (rtx_insn *insn ATTRIBUTE_UNUSED, int regno ATTRIBUTE_UNUSED,\n \t\t       int reloadnum ATTRIBUTE_UNUSED)\n {\n #ifdef AUTO_INC_DEC\n@@ -5501,7 +5501,7 @@ find_reloads_address_1 (enum machine_mode mode, addr_space_t as,\n \t\t\trtx x, int context,\n \t\t\tenum rtx_code outer_code, enum rtx_code index_code,\n \t\t\trtx *loc, int opnum, enum reload_type type,\n-\t\t\tint ind_levels, rtx insn)\n+\t\t\tint ind_levels, rtx_insn *insn)\n {\n #define REG_OK_FOR_CONTEXT(CONTEXT, REGNO, MODE, AS, OUTER, INDEX)\t\\\n   ((CONTEXT) == 0\t\t\t\t\t\t\t\\\n@@ -6135,7 +6135,8 @@ find_reloads_address_part (rtx x, rtx *loc, enum reg_class rclass,\n \n static rtx\n find_reloads_subreg_address (rtx x, int opnum, enum reload_type type,\n-\t\t\t     int ind_levels, rtx insn, int *address_reloaded)\n+\t\t\t     int ind_levels, rtx_insn *insn,\n+\t\t\t     int *address_reloaded)\n {\n   enum machine_mode outer_mode = GET_MODE (x);\n   enum machine_mode inner_mode = GET_MODE (SUBREG_REG (x));\n@@ -6244,7 +6245,7 @@ find_reloads_subreg_address (rtx x, int opnum, enum reload_type type,\n    Return the rtx that X translates into; usually X, but modified.  */\n \n void\n-subst_reloads (rtx insn)\n+subst_reloads (rtx_insn *insn)\n {\n   int i;\n \n@@ -6671,10 +6672,10 @@ refers_to_mem_for_reload_p (rtx x)\n    as if it were a constant except that sp is required to be unchanging.  */\n \n rtx\n-find_equiv_reg (rtx goal, rtx insn, enum reg_class rclass, int other,\n+find_equiv_reg (rtx goal, rtx_insn *insn, enum reg_class rclass, int other,\n \t\tshort *reload_reg_p, int goalreg, enum machine_mode mode)\n {\n-  rtx p = insn;\n+  rtx_insn *p = insn;\n   rtx goaltry, valtry, value, where;\n   rtx pat;\n   int regno = -1;\n@@ -7207,7 +7208,7 @@ reg_inc_found_and_valid_p (unsigned int regno, unsigned int endregno,\n    REG_INC.  REGNO must refer to a hard register.  */\n \n int\n-regno_clobbered_p (unsigned int regno, rtx insn, enum machine_mode mode,\n+regno_clobbered_p (unsigned int regno, rtx_insn *insn, enum machine_mode mode,\n \t\t   int sets)\n {\n   unsigned int nregs, endregno;"}, {"sha": "ea9081f6471edea96921ea15a226f66ac0d2d05d", "filename": "gcc/reload.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d86f5f999de9315fc3b2220d7a04577662fbf20/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d86f5f999de9315fc3b2220d7a04577662fbf20/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=5d86f5f999de9315fc3b2220d7a04577662fbf20", "patch": "@@ -285,7 +285,7 @@ struct insn_chain\n   struct insn_chain *next_need_reload;\n \n   /* The rtx of the insn.  */\n-  rtx insn;\n+  rtx_insn *insn;\n \n   /* The basic block this insn is in.  */\n   int block;\n@@ -364,7 +364,7 @@ extern int safe_from_earlyclobber (rtx, rtx);\n /* Search the body of INSN for values that need reloading and record them\n    with push_reload.  REPLACE nonzero means record also where the values occur\n    so that subst_reloads can be used.  */\n-extern int find_reloads (rtx, int, int, int, short *);\n+extern int find_reloads (rtx_insn *, int, int, int, short *);\n \n /* Compute the sum of X and Y, making canonicalizations assumed in an\n    address, namely: sum constant integers, surround the sum of two\n@@ -374,7 +374,7 @@ extern rtx form_sum (enum machine_mode, rtx, rtx);\n \n /* Substitute into the current INSN the registers into which we have reloaded\n    the things that need reloading.  */\n-extern void subst_reloads (rtx);\n+extern void subst_reloads (rtx_insn *);\n \n /* Make a copy of any replacements being done into X and move those copies\n    to locations in Y, a copy of X.  We only look at the highest level of\n@@ -393,11 +393,11 @@ extern int reg_overlap_mentioned_for_reload_p (rtx, rtx);\n \n /* Check the insns before INSN to see if there is a suitable register\n    containing the same value as GOAL.  */\n-extern rtx find_equiv_reg (rtx, rtx, enum reg_class, int, short *,\n+extern rtx find_equiv_reg (rtx, rtx_insn *, enum reg_class, int, short *,\n \t\t\t   int, enum machine_mode);\n \n /* Return 1 if register REGNO is the subject of a clobber in insn INSN.  */\n-extern int regno_clobbered_p (unsigned int, rtx, enum machine_mode, int);\n+extern int regno_clobbered_p (unsigned int, rtx_insn *, enum machine_mode, int);\n \n /* Return 1 if X is an operand of an insn that is being earlyclobbered.  */\n extern int earlyclobber_operand_p (rtx);\n@@ -413,7 +413,7 @@ extern int push_reload (rtx, rtx, rtx *, rtx *, enum reg_class,\n extern void init_reload (void);\n \n /* The reload pass itself.  */\n-extern bool reload (rtx, int);\n+extern bool reload (rtx_insn *, int);\n \n /* Mark the slots in regs_ever_live for the hard regs\n    used by pseudo-reg number REGNO.  */"}, {"sha": "2bb8005329ba5a5a7f56f4c06fba6f67f2302972", "filename": "gcc/reload1.c", "status": "modified", "additions": 96, "deletions": 89, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d86f5f999de9315fc3b2220d7a04577662fbf20/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d86f5f999de9315fc3b2220d7a04577662fbf20/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=5d86f5f999de9315fc3b2220d7a04577662fbf20", "patch": "@@ -115,7 +115,7 @@ static int reg_reloaded_contents[FIRST_PSEUDO_REGISTER];\n /* During reload_as_needed, element N contains the insn for which\n    hard register N was last used.   Its contents are significant only\n    when reg_reloaded_valid is set for this register.  */\n-static rtx reg_reloaded_insn[FIRST_PSEUDO_REGISTER];\n+static rtx_insn *reg_reloaded_insn[FIRST_PSEUDO_REGISTER];\n \n /* Indicate if reg_reloaded_insn / reg_reloaded_contents is valid.  */\n static HARD_REG_SET reg_reloaded_valid;\n@@ -140,7 +140,7 @@ static rtx spill_reg_rtx[FIRST_PSEUDO_REGISTER];\n /* In parallel with spill_regs, contains nonzero for a spill reg\n    that was stored after the last time it was used.\n    The precise value is the insn generated to do the store.  */\n-static rtx spill_reg_store[FIRST_PSEUDO_REGISTER];\n+static rtx_insn *spill_reg_store[FIRST_PSEUDO_REGISTER];\n \n /* This is the register that was stored with spill_reg_store.  This is a\n    copy of reload_out / reload_out_reg when the value was stored; if\n@@ -354,27 +354,27 @@ static void find_reload_regs (struct insn_chain *);\n static void select_reload_regs (void);\n static void delete_caller_save_insns (void);\n \n-static void spill_failure (rtx, enum reg_class);\n+static void spill_failure (rtx_insn *, enum reg_class);\n static void count_spilled_pseudo (int, int, int);\n-static void delete_dead_insn (rtx);\n+static void delete_dead_insn (rtx_insn *);\n static void alter_reg (int, int, bool);\n-static void set_label_offsets (rtx, rtx, int);\n+static void set_label_offsets (rtx, rtx_insn *, int);\n static void check_eliminable_occurrences (rtx);\n static void elimination_effects (rtx, enum machine_mode);\n static rtx eliminate_regs_1 (rtx, enum machine_mode, rtx, bool, bool);\n-static int eliminate_regs_in_insn (rtx, int);\n+static int eliminate_regs_in_insn (rtx_insn *, int);\n static void update_eliminable_offsets (void);\n static void mark_not_eliminable (rtx, const_rtx, void *);\n static void set_initial_elim_offsets (void);\n static bool verify_initial_elim_offsets (void);\n static void set_initial_label_offsets (void);\n-static void set_offsets_for_label (rtx);\n-static void init_eliminable_invariants (rtx, bool);\n+static void set_offsets_for_label (rtx_insn *);\n+static void init_eliminable_invariants (rtx_insn *, bool);\n static void init_elim_table (void);\n static void free_reg_equiv (void);\n static void update_eliminables (HARD_REG_SET *);\n static bool update_eliminables_and_spill (void);\n-static void elimination_costs_in_insn (rtx);\n+static void elimination_costs_in_insn (rtx_insn *);\n static void spill_hard_reg (unsigned int, int);\n static int finish_spills (int);\n static void scan_paradoxical_subregs (rtx);\n@@ -395,7 +395,7 @@ static int free_for_value_p (int, enum machine_mode, int, enum reload_type,\n \t\t\t     rtx, rtx, int, int);\n static int allocate_reload_reg (struct insn_chain *, int, int);\n static int conflicts_with_override (rtx);\n-static void failed_reload (rtx, int);\n+static void failed_reload (rtx_insn *, int);\n static int set_reload_reg (int, int);\n static void choose_reload_regs_init (struct insn_chain *, rtx *);\n static void choose_reload_regs (struct insn_chain *);\n@@ -406,18 +406,18 @@ static void emit_output_reload_insns (struct insn_chain *, struct reload *,\n static void do_input_reload (struct insn_chain *, struct reload *, int);\n static void do_output_reload (struct insn_chain *, struct reload *, int);\n static void emit_reload_insns (struct insn_chain *);\n-static void delete_output_reload (rtx, int, int, rtx);\n-static void delete_address_reloads (rtx, rtx);\n-static void delete_address_reloads_1 (rtx, rtx, rtx);\n+static void delete_output_reload (rtx_insn *, int, int, rtx);\n+static void delete_address_reloads (rtx_insn *, rtx_insn *);\n+static void delete_address_reloads_1 (rtx_insn *, rtx, rtx_insn *);\n static void inc_for_reload (rtx, rtx, rtx, int);\n #ifdef AUTO_INC_DEC\n-static void add_auto_inc_notes (rtx, rtx);\n+static void add_auto_inc_notes (rtx_insn *, rtx);\n #endif\n static void substitute (rtx *, const_rtx, rtx);\n static bool gen_reload_chain_without_interm_reg_p (int, int);\n static int reloads_conflict (int, int);\n-static rtx gen_reload (rtx, rtx, int, enum reload_type);\n-static rtx emit_insn_if_valid_for_reload (rtx);\n+static rtx_insn *gen_reload (rtx, rtx, int, enum reload_type);\n+static rtx_insn *emit_insn_if_valid_for_reload (rtx);\n \f\n /* Initialize the reload pass.  This is called at the beginning of compilation\n    and may be called again if the target is reinitialized.  */\n@@ -702,7 +702,7 @@ remove_init_insns ()\n \t  rtx list;\n \t  for (list = reg_equiv_init (i); list; list = XEXP (list, 1))\n \t    {\n-\t      rtx equiv_insn = XEXP (list, 0);\n+\t      rtx_insn *equiv_insn = as_a <rtx_insn *> (XEXP (list, 0));\n \n \t      /* If we already deleted the insn or if it may trap, we can't\n \t\t delete it.  The latter case shouldn't happen, but can\n@@ -723,7 +723,7 @@ remove_init_insns ()\n \n /* Return true if remove_init_insns will delete INSN.  */\n static bool\n-will_delete_init_insn_p (rtx insn)\n+will_delete_init_insn_p (rtx_insn *insn)\n {\n   rtx set = single_set (insn);\n   if (!set || !REG_P (SET_DEST (set)))\n@@ -760,10 +760,10 @@ will_delete_init_insn_p (rtx insn)\n    return value is FALSE.  */\n \n bool\n-reload (rtx first, int global)\n+reload (rtx_insn *first, int global)\n {\n   int i, n;\n-  rtx insn;\n+  rtx_insn *insn;\n   struct elim_table *ep;\n   basic_block bb;\n   bool inserted;\n@@ -1475,7 +1475,7 @@ calculate_needs_all_insns (int global)\n   reload_insn_firstobj = XOBNEWVAR (&reload_obstack, char, 0);\n   for (chain = reload_insn_chain; chain != 0; chain = next)\n     {\n-      rtx insn = chain->insn;\n+      rtx_insn *insn = chain->insn;\n \n       next = chain->next;\n \n@@ -1605,7 +1605,7 @@ calculate_elim_costs_all_insns (void)\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n       elim_bb = bb;\n \n       FOR_BB_INSNS (bb, insn)\n@@ -2075,7 +2075,7 @@ delete_caller_save_insns (void)\n       while (c != 0 && c->is_caller_save_insn)\n \t{\n \t  struct insn_chain *next = c->next;\n-\t  rtx insn = c->insn;\n+\t  rtx_insn *insn = c->insn;\n \n \t  if (c == reload_insn_chain)\n \t    reload_insn_chain = next;\n@@ -2098,7 +2098,7 @@ delete_caller_save_insns (void)\n    INSN should be one of the insns which needed this particular spill reg.  */\n \n static void\n-spill_failure (rtx insn, enum reg_class rclass)\n+spill_failure (rtx_insn *insn, enum reg_class rclass)\n {\n   if (asm_noperands (PATTERN (insn)) >= 0)\n     error_for_asm (insn, \"can%'t find a register in class %qs while \"\n@@ -2122,9 +2122,9 @@ spill_failure (rtx insn, enum reg_class rclass)\n    data that is dead in INSN.  */\n \n static void\n-delete_dead_insn (rtx insn)\n+delete_dead_insn (rtx_insn *insn)\n {\n-  rtx prev = prev_active_insn (insn);\n+  rtx_insn *prev = prev_active_insn (insn);\n   rtx prev_dest;\n \n   /* If the previous insn sets a register that dies in our insn make\n@@ -2344,7 +2344,7 @@ mark_home_live (int regno)\n    current offset.  */\n \n static void\n-set_label_offsets (rtx x, rtx insn, int initial_p)\n+set_label_offsets (rtx x, rtx_insn *insn, int initial_p)\n {\n   enum rtx_code code = GET_CODE (x);\n   rtx tem;\n@@ -3218,7 +3218,7 @@ check_eliminable_occurrences (rtx x)\n    is returned.  Otherwise, 1 is returned.  */\n \n static int\n-eliminate_regs_in_insn (rtx insn, int replace)\n+eliminate_regs_in_insn (rtx_insn *insn, int replace)\n {\n   int icode = recog_memoized (insn);\n   rtx old_body = PATTERN (insn);\n@@ -3261,12 +3261,13 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t\t&& ep->to == HARD_FRAME_POINTER_REGNUM)\n \t      {\n \t\trtx base = SET_SRC (old_set);\n-\t\trtx base_insn = insn;\n+\t\trtx_insn *base_insn = insn;\n \t\tHOST_WIDE_INT offset = 0;\n \n \t\twhile (base != ep->to_rtx)\n \t\t  {\n-\t\t    rtx prev_insn, prev_set;\n+\t\t    rtx_insn *prev_insn;\n+\t\t    rtx prev_set;\n \n \t\t    if (GET_CODE (base) == PLUS\n \t\t        && CONST_INT_P (XEXP (base, 1)))\n@@ -3628,7 +3629,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n    an invariant equivalence would add extra cost.  */\n \n static void\n-elimination_costs_in_insn (rtx insn)\n+elimination_costs_in_insn (rtx_insn *insn)\n {\n   int icode = recog_memoized (insn);\n   rtx old_body = PATTERN (insn);\n@@ -3895,7 +3896,7 @@ set_initial_elim_offsets (void)\n static void\n set_initial_eh_label_offset (rtx label)\n {\n-  set_label_offsets (label, NULL_RTX, 1);\n+  set_label_offsets (label, NULL, 1);\n }\n \n /* Initialize the known label offsets.\n@@ -3913,11 +3914,11 @@ set_initial_label_offsets (void)\n \n   for (x = forced_labels; x; x = XEXP (x, 1))\n     if (XEXP (x, 0))\n-      set_label_offsets (XEXP (x, 0), NULL_RTX, 1);\n+      set_label_offsets (XEXP (x, 0), NULL, 1);\n \n   for (x = nonlocal_goto_handler_labels; x; x = XEXP (x, 1))\n     if (XEXP (x, 0))\n-      set_label_offsets (XEXP (x, 0), NULL_RTX, 1);\n+      set_label_offsets (XEXP (x, 0), NULL, 1);\n \n   for_each_eh_label (set_initial_eh_label_offset);\n }\n@@ -3926,7 +3927,7 @@ set_initial_label_offsets (void)\n    by INSN.  */\n \n static void\n-set_offsets_for_label (rtx insn)\n+set_offsets_for_label (rtx_insn *insn)\n {\n   unsigned int i;\n   int label_nr = CODE_LABEL_NUMBER (insn);\n@@ -4132,10 +4133,10 @@ init_elim_table (void)\n    be substituted eventually by altering the REG-rtx's.  */\n \n static void\n-init_eliminable_invariants (rtx first, bool do_subregs)\n+init_eliminable_invariants (rtx_insn *first, bool do_subregs)\n {\n   int i;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   grow_reg_equivs ();\n   if (do_subregs)\n@@ -4547,7 +4548,7 @@ strip_paradoxical_subreg (rtx *op_ptr, rtx *other_ptr)\n    annotate all that may trap.  */\n \n static void\n-fixup_eh_region_note (rtx insn, rtx prev, rtx next)\n+fixup_eh_region_note (rtx_insn *insn, rtx_insn *prev, rtx_insn *next)\n {\n   rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n   if (note == NULL)\n@@ -4591,11 +4592,11 @@ reload_as_needed (int live_known)\n \n   for (chain = reload_insn_chain; chain; chain = chain->next)\n     {\n-      rtx prev = 0;\n-      rtx insn = chain->insn;\n-      rtx old_next = NEXT_INSN (insn);\n+      rtx_insn *prev = 0;\n+      rtx_insn *insn = chain->insn;\n+      rtx_insn *old_next = NEXT_INSN (insn);\n #ifdef AUTO_INC_DEC\n-      rtx old_prev = PREV_INSN (insn);\n+      rtx_insn *old_prev = PREV_INSN (insn);\n #endif\n \n       if (will_delete_init_insn_p (insn))\n@@ -4661,7 +4662,7 @@ reload_as_needed (int live_known)\n \n \t  if (n_reloads > 0)\n \t    {\n-\t      rtx next = NEXT_INSN (insn);\n+\t      rtx_insn *next = NEXT_INSN (insn);\n \t      rtx p;\n \n \t      /* ??? PREV can get deleted by reload inheritance.\n@@ -5677,8 +5678,9 @@ gen_reload_chain_without_interm_reg_p (int r1, int r2)\n      chain reloads or do need an intermediate hard registers.  */\n   bool result = true;\n   int regno, n, code;\n-  rtx out, in, insn;\n-  rtx last = get_last_insn ();\n+  rtx out, in;\n+  rtx_insn *insn;\n+  rtx_insn *last = get_last_insn ();\n \n   /* Make r2 a component of r1.  */\n   if (reg_mentioned_p (rld[r1].in, rld[r2].in))\n@@ -5817,7 +5819,7 @@ static char reload_inherited[MAX_RELOADS];\n \n /* For an inherited reload, this is the insn the reload was inherited from,\n    if we know it.  Otherwise, this is 0.  */\n-static rtx reload_inheritance_insn[MAX_RELOADS];\n+static rtx_insn *reload_inheritance_insn[MAX_RELOADS];\n \n /* If nonzero, this is a place to get the value of the reload,\n    rather than using reload_in.  */\n@@ -6128,7 +6130,7 @@ conflicts_with_override (rtx x)\n /* Give an error message saying we failed to find a reload for INSN,\n    and clear out reload R.  */\n static void\n-failed_reload (rtx insn, int r)\n+failed_reload (rtx_insn *insn, int r)\n {\n   if (asm_noperands (PATTERN (insn)) < 0)\n     /* It's the compiler's fault.  */\n@@ -6443,7 +6445,7 @@ compute_reload_subreg_offset (enum machine_mode outermode,\n static void\n choose_reload_regs (struct insn_chain *chain)\n {\n-  rtx insn = chain->insn;\n+  rtx_insn *insn = chain->insn;\n   int i, j;\n   unsigned int max_group_size = 1;\n   enum reg_class group_class = NO_REGS;\n@@ -6907,7 +6909,7 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t     We must clear it, since otherwise emit_reload_insns\n \t\t     might delete the store.  */\n \t\t  if (! TEST_HARD_REG_BIT (reg_reloaded_valid, regno))\n-\t\t    spill_reg_store[regno] = NULL_RTX;\n+\t\t    spill_reg_store[regno] = NULL;\n \t\t  /* If any of the hard registers in EQUIV are spill\n \t\t     registers, mark them as in use for this insn.  */\n \t\t  for (k = 0; k < nr; k++)\n@@ -7168,22 +7170,22 @@ deallocate_reload_reg (int r)\n }\n \f\n /* These arrays are filled by emit_reload_insns and its subroutines.  */\n-static rtx input_reload_insns[MAX_RECOG_OPERANDS];\n-static rtx other_input_address_reload_insns = 0;\n-static rtx other_input_reload_insns = 0;\n-static rtx input_address_reload_insns[MAX_RECOG_OPERANDS];\n-static rtx inpaddr_address_reload_insns[MAX_RECOG_OPERANDS];\n-static rtx output_reload_insns[MAX_RECOG_OPERANDS];\n-static rtx output_address_reload_insns[MAX_RECOG_OPERANDS];\n-static rtx outaddr_address_reload_insns[MAX_RECOG_OPERANDS];\n-static rtx operand_reload_insns = 0;\n-static rtx other_operand_reload_insns = 0;\n-static rtx other_output_reload_insns[MAX_RECOG_OPERANDS];\n+static rtx_insn *input_reload_insns[MAX_RECOG_OPERANDS];\n+static rtx_insn *other_input_address_reload_insns = 0;\n+static rtx_insn *other_input_reload_insns = 0;\n+static rtx_insn *input_address_reload_insns[MAX_RECOG_OPERANDS];\n+static rtx_insn *inpaddr_address_reload_insns[MAX_RECOG_OPERANDS];\n+static rtx_insn *output_reload_insns[MAX_RECOG_OPERANDS];\n+static rtx_insn *output_address_reload_insns[MAX_RECOG_OPERANDS];\n+static rtx_insn *outaddr_address_reload_insns[MAX_RECOG_OPERANDS];\n+static rtx_insn *operand_reload_insns = 0;\n+static rtx_insn *other_operand_reload_insns = 0;\n+static rtx_insn *other_output_reload_insns[MAX_RECOG_OPERANDS];\n \n /* Values to be put in spill_reg_store are put here first.  Instructions\n    must only be placed here if the associated reload register reaches\n    the end of the instruction's reload sequence.  */\n-static rtx new_spill_reg_store[FIRST_PSEUDO_REGISTER];\n+static rtx_insn *new_spill_reg_store[FIRST_PSEUDO_REGISTER];\n static HARD_REG_SET reg_reloaded_died;\n \n /* Check if *RELOAD_REG is suitable as an intermediate or scratch register\n@@ -7242,13 +7244,13 @@ static void\n emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\t\t rtx old, int j)\n {\n-  rtx insn = chain->insn;\n+  rtx_insn *insn = chain->insn;\n   rtx reloadreg;\n   rtx oldequiv_reg = 0;\n   rtx oldequiv = 0;\n   int special = 0;\n   enum machine_mode mode;\n-  rtx *where;\n+  rtx_insn **where;\n \n   /* delete_output_reload is only invoked properly if old contains\n      the original pseudo register.  Since this is replaced with a\n@@ -7363,7 +7365,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t   && free_for_value_p (REGNO (reloadreg), rl->mode, rl->opnum,\n \t\t\t\trl->when_needed, old, rl->out, j, 0))\n     {\n-      rtx temp = PREV_INSN (insn);\n+      rtx_insn *temp = PREV_INSN (insn);\n       while (temp && (NOTE_P (temp) || DEBUG_INSN_P (temp)))\n \ttemp = PREV_INSN (temp);\n       if (temp\n@@ -7704,11 +7706,11 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\t\t  int j)\n {\n   rtx reloadreg;\n-  rtx insn = chain->insn;\n+  rtx_insn *insn = chain->insn;\n   int special = 0;\n   rtx old = rl->out;\n   enum machine_mode mode;\n-  rtx p;\n+  rtx_insn *p;\n   rtx rl_reg_rtx;\n \n   if (rl->when_needed == RELOAD_OTHER)\n@@ -7871,7 +7873,7 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\t       that it is, setting new_spill_reg_store to\n \t\t       that insn will allow an extra optimization.  */\n \t\t    rtx s_reg = rld[s].reg_rtx;\n-\t\t    rtx next = NEXT_INSN (p);\n+\t\t    rtx_insn *next = NEXT_INSN (p);\n \t\t    rld[s].out = rl->out;\n \t\t    rld[s].out_reg = rl->out_reg;\n \t\t    set = single_set (next);\n@@ -7908,7 +7910,7 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n static void\n do_input_reload (struct insn_chain *chain, struct reload *rl, int j)\n {\n-  rtx insn = chain->insn;\n+  rtx_insn *insn = chain->insn;\n   rtx old = (rl->in && MEM_P (rl->in)\n \t     ? rl->in_reg : rl->in);\n   rtx reg_rtx = rl->reg_rtx;\n@@ -8010,7 +8012,7 @@ static void\n do_output_reload (struct insn_chain *chain, struct reload *rl, int j)\n {\n   rtx note, old;\n-  rtx insn = chain->insn;\n+  rtx_insn *insn = chain->insn;\n   /* If this is an output reload that stores something that is\n      not loaded in this same reload, see if we can eliminate a previous\n      store.  */\n@@ -8119,7 +8121,7 @@ inherit_piecemeal_p (int dest ATTRIBUTE_UNUSED,\n static void\n emit_reload_insns (struct insn_chain *chain)\n {\n-  rtx insn = chain->insn;\n+  rtx_insn *insn = chain->insn;\n \n   int j;\n \n@@ -8461,7 +8463,8 @@ emit_reload_insns (struct insn_chain *chain)\n \n \t  if (!HARD_REGISTER_NUM_P (out_regno))\n \t    {\n-\t      rtx src_reg, store_insn = NULL_RTX;\n+\t      rtx src_reg;\n+\t      rtx_insn *store_insn = NULL;\n \n \t      reg_last_reload_reg[out_regno] = 0;\n \n@@ -8558,10 +8561,10 @@ emit_reload_insns (struct insn_chain *chain)\n /* Go through the motions to emit INSN and test if it is strictly valid.\n    Return the emitted insn if valid, else return NULL.  */\n \n-static rtx\n+static rtx_insn *\n emit_insn_if_valid_for_reload (rtx insn)\n {\n-  rtx last = get_last_insn ();\n+  rtx_insn *last = get_last_insn ();\n   int code;\n \n   insn = emit_insn (insn);\n@@ -8574,7 +8577,7 @@ emit_insn_if_valid_for_reload (rtx insn)\n \t validity determination, i.e., the way it would after reload has\n \t completed.  */\n       if (constrain_operands (1))\n-\treturn insn;\n+\treturn as_a <rtx_insn *> (insn);\n     }\n \n   delete_insns_since (last);\n@@ -8587,10 +8590,10 @@ emit_insn_if_valid_for_reload (rtx insn)\n \n    Returns first insn emitted.  */\n \n-static rtx\n+static rtx_insn *\n gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n {\n-  rtx last = get_last_insn ();\n+  rtx_insn *last = get_last_insn ();\n   rtx tem;\n #ifdef SECONDARY_MEMORY_NEEDED\n   rtx tem1, tem2;\n@@ -8655,7 +8658,8 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n \t `extract_insn' and it is simpler to emit and then delete the insn if\n \t not valid than to dummy things up.  */\n \n-      rtx op0, op1, tem, insn;\n+      rtx op0, op1, tem;\n+      rtx_insn *insn;\n       enum insn_code code;\n \n       op0 = find_replacement (&XEXP (in, 0));\n@@ -8757,7 +8761,7 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n       rtx insn;\n       rtx op1;\n       rtx out_moded;\n-      rtx set;\n+      rtx_insn *set;\n \n       op1 = find_replacement (&XEXP (in, 0));\n       if (op1 != XEXP (in, 0))\n@@ -8787,7 +8791,7 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n       if (insn)\n \t{\n \t  set_unique_reg_note (insn, REG_EQUIV, in);\n-\t  return insn;\n+\t  return as_a <rtx_insn *> (insn);\n \t}\n \n       fatal_insn (\"failure trying to reload:\", set);\n@@ -8829,9 +8833,10 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n    NEW_RELOAD_REG is reload register that reload J is using for REG.  */\n \n static void\n-delete_output_reload (rtx insn, int j, int last_reload_reg, rtx new_reload_reg)\n+delete_output_reload (rtx_insn *insn, int j, int last_reload_reg,\n+\t\t      rtx new_reload_reg)\n {\n-  rtx output_reload_insn = spill_reg_store[last_reload_reg];\n+  rtx_insn *output_reload_insn = spill_reg_store[last_reload_reg];\n   rtx reg = spill_reg_stored_to[last_reload_reg];\n   int k;\n   int n_occurrences;\n@@ -8944,7 +8949,7 @@ delete_output_reload (rtx insn, int j, int last_reload_reg, rtx new_reload_reg)\n       && REG_BASIC_BLOCK (REGNO (reg)) >= NUM_FIXED_BLOCKS\n       && find_regno_note (insn, REG_DEAD, REGNO (reg)))\n     {\n-      rtx i2;\n+      rtx_insn *i2;\n \n       /* We know that it was used only between here and the beginning of\n \t the current basic block.  (We also know that the last use before\n@@ -9004,10 +9009,11 @@ delete_output_reload (rtx insn, int j, int last_reload_reg, rtx new_reload_reg)\n    reload registers used in DEAD_INSN that are not used till CURRENT_INSN.\n    CURRENT_INSN is being reloaded, so we have to check its reloads too.  */\n static void\n-delete_address_reloads (rtx dead_insn, rtx current_insn)\n+delete_address_reloads (rtx_insn *dead_insn, rtx_insn *current_insn)\n {\n   rtx set = single_set (dead_insn);\n-  rtx set2, dst, prev, next;\n+  rtx set2, dst;\n+  rtx_insn *prev, *next;\n   if (set)\n     {\n       rtx dst = SET_DEST (set);\n@@ -9040,9 +9046,10 @@ delete_address_reloads (rtx dead_insn, rtx current_insn)\n \n /* Subfunction of delete_address_reloads: process registers found in X.  */\n static void\n-delete_address_reloads_1 (rtx dead_insn, rtx x, rtx current_insn)\n+delete_address_reloads_1 (rtx_insn *dead_insn, rtx x, rtx_insn *current_insn)\n {\n-  rtx prev, set, dst, i2;\n+  rtx_insn *prev, *i2;\n+  rtx set, dst;\n   int i, j;\n   enum rtx_code code = GET_CODE (x);\n \n@@ -9163,9 +9170,9 @@ inc_for_reload (rtx reloadreg, rtx in, rtx value, int inc_amount)\n   /* Nonzero if increment after copying.  */\n   int post = (GET_CODE (value) == POST_DEC || GET_CODE (value) == POST_INC\n \t      || GET_CODE (value) == POST_MODIFY);\n-  rtx last;\n+  rtx_insn *last;\n   rtx inc;\n-  rtx add_insn;\n+  rtx_insn *add_insn;\n   int code;\n   rtx real_in = in == value ? incloc : in;\n \n@@ -9257,7 +9264,7 @@ inc_for_reload (rtx reloadreg, rtx in, rtx value, int inc_amount)\n \f\n #ifdef AUTO_INC_DEC\n static void\n-add_auto_inc_notes (rtx insn, rtx x)\n+add_auto_inc_notes (rtx_insn *insn, rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n   const char *fmt;"}]}