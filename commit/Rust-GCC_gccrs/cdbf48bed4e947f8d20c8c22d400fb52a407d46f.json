{"sha": "cdbf48bed4e947f8d20c8c22d400fb52a407d46f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RiZjQ4YmVkNGU5NDdmOGQyMGM4YzIyZDQwMGZiNTJhNDA3ZDQ2Zg==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-16T13:57:58Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-16T21:37:55Z"}, "message": "d: Consistently format quotations in comments.\n\ngcc/d/ChangeLog:\n\n\t* d-builtins.cc: Update quotation formatting of comments.\n\t* d-codegen.cc: Likewise.\n\t* d-lang.cc: Likewise.\n\t* decl.cc: Likewise.\n\t* expr.cc: Likewise.\n\t* imports.cc: Likewise.\n\t* runtime.cc: Likewise.\n\t* toir.cc: Likewise.\n\t* typeinfo.cc: Likewise.\n\t* types.cc: Likewise.", "tree": {"sha": "76431a84538bbe0a2df74dbbf18793343a3cf0c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76431a84538bbe0a2df74dbbf18793343a3cf0c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdbf48bed4e947f8d20c8c22d400fb52a407d46f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdbf48bed4e947f8d20c8c22d400fb52a407d46f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdbf48bed4e947f8d20c8c22d400fb52a407d46f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a23b6d61bca7ee91e326264f2923a609908d1d04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a23b6d61bca7ee91e326264f2923a609908d1d04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a23b6d61bca7ee91e326264f2923a609908d1d04"}], "stats": {"total": 96, "additions": 48, "deletions": 48}, "files": [{"sha": "75eaa6b8a730bbe39d59ec23c7e38b8b5f816a76", "filename": "gcc/d/d-builtins.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Fd-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Fd-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-builtins.cc?ref=cdbf48bed4e947f8d20c8c22d400fb52a407d46f", "patch": "@@ -222,7 +222,7 @@ build_frontend_type (tree type)\n \tIdentifier::idPool (IDENTIFIER_POINTER (TYPE_IDENTIFIER (type))) : NULL;\n \n       /* Neither the `object' and `gcc.builtins' modules will not exist when\n-\t this is called.  Use a stub 'object' module parent in the meantime.\n+\t this is called.  Use a stub `object' module parent in the meantime.\n \t If `gcc.builtins' is later imported, the parent will be overridden\n \t with the correct module symbol.  */\n       static Identifier *object = Identifier::idPool (\"object\");"}, {"sha": "b82e16fe79efcdd558e2eb3e816b1c7a53e2f5ed", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=cdbf48bed4e947f8d20c8c22d400fb52a407d46f", "patch": "@@ -82,7 +82,7 @@ d_decl_context (Dsymbol *dsym)\n \t  return build_import_decl (parent);\n \t}\n \n-      /* Declarations marked as 'static' or '__gshared' are never\n+      /* Declarations marked as `static' or `__gshared' are never\n \t part of any context except at module level.  */\n       if (decl != NULL && decl->isDataseg ())\n \tcontinue;\n@@ -164,7 +164,7 @@ declaration_type (Declaration *decl)\n   if (declaration_reference_p (decl))\n     return build_reference_type (type);\n \n-  /* The 'this' parameter is always const.  */\n+  /* The `this' parameter is always const.  */\n   if (decl->isThisDeclaration ())\n     return insert_type_modifiers (type, MODconst);\n \n@@ -1830,7 +1830,7 @@ call_by_alias_p (FuncDeclaration *caller, FuncDeclaration *callee)\n }\n \n /* Entry point for call routines.  Builds a function call to FD.\n-   OBJECT is the 'this' reference passed and ARGS are the arguments to FD.  */\n+   OBJECT is the `this' reference passed and ARGS are the arguments to FD.  */\n \n tree\n d_build_call_expr (FuncDeclaration *fd, tree object, Expressions *arguments)\n@@ -1839,7 +1839,7 @@ d_build_call_expr (FuncDeclaration *fd, tree object, Expressions *arguments)\n \t\t       build_address (get_symbol_decl (fd)), object, arguments);\n }\n \n-/* Builds a CALL_EXPR of type TF to CALLABLE.  OBJECT holds the 'this' pointer,\n+/* Builds a CALL_EXPR of type TF to CALLABLE.  OBJECT holds the `this' pointer,\n    ARGUMENTS are evaluated in left to right order, saved and promoted\n    before passing.  */\n \n@@ -2044,7 +2044,7 @@ build_float_modulus (tree type, tree arg0, tree arg1)\n }\n \n /* Build a function type whose first argument is a pointer to BASETYPE,\n-   which is to be used for the 'vthis' context parameter for TYPE.\n+   which is to be used for the `vthis' context parameter for TYPE.\n    The base type may be a record for member functions, or a void for\n    nested functions and delegates.  */\n \n@@ -2085,7 +2085,7 @@ get_frame_for_symbol (Dsymbol *sym)\n       /* Check that the nested function is properly defined.  */\n       if (!fd->fbody)\n \t{\n-\t  /* Should instead error on line that references 'fd'.  */\n+\t  /* Should instead error on line that references `fd'.  */\n \t  error_at (make_location_t (fd->loc), \"nested function missing body\");\n \t  return null_pointer_node;\n \t}\n@@ -2181,7 +2181,7 @@ get_frame_for_symbol (Dsymbol *sym)\n     {\n       tree frame_ref = get_framedecl (thisfd, fdparent);\n \n-      /* If 'thisfd' is a derived member function, then 'fdparent' is the\n+      /* If `thisfd' is a derived member function, then `fdparent' is the\n \t overridden member function in the base class.  Even if there's a\n \t closure environment, we should give the original stack data as the\n \t nested function frame.  */\n@@ -2195,12 +2195,12 @@ get_frame_for_symbol (Dsymbol *sym)\n \t  if (cdo->isBaseOf (cd, &offset) && offset != 0)\n \t    {\n \t      /* Generate a new frame to pass to the overriden function that\n-\t\t has the 'this' pointer adjusted.  */\n+\t\t has the `this' pointer adjusted.  */\n \t      gcc_assert (offset != OFFSET_RUNTIME);\n \n \t      tree type = FRAMEINFO_TYPE (get_frameinfo (fdoverride));\n \t      tree fields = TYPE_FIELDS (type);\n-\t      /* The 'this' field comes immediately after the '__chain'.  */\n+\t      /* The `this' field comes immediately after the `__chain'.  */\n \t      tree thisfield = chain_index (1, fields);\n \t      vec<constructor_elt, va_gc> *ve = NULL;\n \n@@ -2263,7 +2263,7 @@ d_nested_struct (StructDeclaration *sd)\n \n \n /* Starting from the current function FD, try to find a suitable value of\n-   'this' in nested function instances.  A suitable 'this' value is an\n+   `this' in nested function instances.  A suitable `this' value is an\n    instance of OCD or a class that has OCD as a base.  */\n \n static tree\n@@ -2301,7 +2301,7 @@ find_this_tree (ClassDeclaration *ocd)\n   return NULL_TREE;\n }\n \n-/* Retrieve the outer class/struct 'this' value of DECL from\n+/* Retrieve the outer class/struct `this' value of DECL from\n    the current function.  */\n \n tree\n@@ -2327,7 +2327,7 @@ build_vthis (AggregateDeclaration *decl)\n \t  outer = ((TemplateInstance *) outer->parent)->enclosing;\n \t}\n \n-      /* For outer classes, get a suitable 'this' value.\n+      /* For outer classes, get a suitable `this' value.\n \t For outer functions, get a suitable frame/closure pointer.  */\n       ClassDeclaration *cdo = outer->isClassDeclaration ();\n       FuncDeclaration *fdo = outer->isFuncDeclaration ();\n@@ -2412,7 +2412,7 @@ build_frame_type (tree ffi, FuncDeclaration *fd)\n \t    }\n \t}\n \n-      /* Also add hidden 'this' to outer context.  */\n+      /* Also add hidden `this' to outer context.  */\n       if (fd->vthis)\n \t{\n \t  for (size_t i = 0; i < fd->closureVars.length; i++)\n@@ -2542,7 +2542,7 @@ build_closure (FuncDeclaration *fd)\n }\n \n /* Return the frame of FD.  This could be a static chain or a closure\n-   passed via the hidden 'this' pointer.  */\n+   passed via the hidden `this' pointer.  */\n \n tree\n get_frameinfo (FuncDeclaration *fd)"}, {"sha": "dd5a83cb4fe473a40f2b185d9fa94843c92d16e2", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=cdbf48bed4e947f8d20c8c22d400fb52a407d46f", "patch": "@@ -337,7 +337,7 @@ d_init_options_struct (gcc_options *opts)\n   /* Avoid range issues for complex multiply and divide.  */\n   opts->x_flag_complex_method = 2;\n \n-  /* Unlike C, there is no global 'errno' variable.  */\n+  /* Unlike C, there is no global `errno' variable.  */\n   opts->x_flag_errno_math = 0;\n   opts->frontend_set_flag_errno_math = true;\n "}, {"sha": "f43b334aac79af2245bdca3d5d41d7c97db95b8b", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=cdbf48bed4e947f8d20c8c22d400fb52a407d46f", "patch": "@@ -859,7 +859,7 @@ class DeclVisitor : public Visitor\n \n     /* Special arguments...  */\n \n-    /* 'this' parameter:\n+    /* `this' parameter:\n        For nested functions, D still generates a vthis, but it\n        should not be referenced in any expression.  */\n     if (d->vthis)\n@@ -1205,7 +1205,7 @@ get_symbol_decl (Declaration *decl)\n \t}\n       else if (fd->isThis ())\n \t{\n-\t  /* Add an extra argument for the 'this' parameter.  The handle type is\n+\t  /* Add an extra argument for the `this' parameter.  The handle type is\n \t     used even if there is no debug info.  It is needed to make sure\n \t     virtual member functions are not called statically.  */\n \t  AggregateDeclaration *ad = fd->isMember2 ();\n@@ -1226,11 +1226,11 @@ get_symbol_decl (Declaration *decl)\n \t}\n       else if (fd->isMain () || fd->isCMain ())\n \t{\n-\t  /* The main function is named 'D main' to distinguish from C main.  */\n+\t  /* The main function is named `D main' to distinguish from C main.  */\n \t  if (fd->isMain ())\n \t    DECL_NAME (decl->csym) = get_identifier (fd->toPrettyChars (true));\n \n-\t  /* 'void main' is implicitly converted to returning an int.  */\n+\t  /* `void main' is implicitly converted to returning an int.  */\n \t  newfntype = build_function_type (d_int_type, TYPE_ARG_TYPES (fntype));\n \t}\n \n@@ -1253,14 +1253,14 @@ get_symbol_decl (Declaration *decl)\n \t  DECL_NO_INLINE_WARNING_P (decl->csym) = 1;\n \t}\n \n-      /* In [pragma/inline], functions decorated with 'pragma(inline)' affects\n+      /* In [pragma/inline], functions decorated with `pragma(inline)' affects\n \t whether they are inlined or not.  */\n       if (fd->inlining == PINLINEalways)\n \tDECL_DECLARED_INLINE_P (decl->csym) = 1;\n       else if (fd->inlining == PINLINEnever)\n \tDECL_UNINLINABLE (decl->csym) = 1;\n \n-      /* Function was declared 'naked'.  */\n+      /* Function was declared `naked'.  */\n       if (fd->naked)\n \t{\n \t  insert_decl_attribute (decl->csym, \"naked\");\n@@ -1466,7 +1466,7 @@ get_decl_tree (Declaration *decl)\n \t\t\t    DECL_LANG_FRAME_FIELD (t));\n     }\n \n-  /* Get the non-local 'this' value by going through parent link\n+  /* Get the non-local `this' value by going through parent link\n      of nested classes, this routine pretty much undoes what\n      getRightThis in the frontend removes from codegen.  */\n   if (vd->parent != fd && vd->isThisDeclaration ())\n@@ -1501,9 +1501,9 @@ get_decl_tree (Declaration *decl)\n \t  fd = outer->isFuncDeclaration ();\n \t  while (fd != NULL)\n \t    {\n-\t      /* If outer function creates a closure, then the 'this'\n+\t      /* If outer function creates a closure, then the `this'\n \t\t value would be the closure pointer, and the real\n-\t\t 'this' the first field of that closure.  */\n+\t\t `this' the first field of that closure.  */\n \t      tree ff = get_frameinfo (fd);\n \t      if (FRAMEINFO_CREATES_FRAME (ff))\n \t\t{\n@@ -1900,7 +1900,7 @@ start_function (FuncDeclaration *fd)\n   cfun->language = ggc_cleared_alloc<language_function> ();\n   cfun->language->function = fd;\n \n-  /* Default chain value is 'null' unless parent found.  */\n+  /* Default chain value is `null' unless parent found.  */\n   cfun->language->static_chain = null_pointer_node;\n \n   /* Find module for this function.  */\n@@ -2194,7 +2194,7 @@ build_new_class_expr (ClassReferenceExp *expr)\n \n /* Get the VAR_DECL of the static initializer symbol for the struct/class DECL.\n    If this does not yet exist, create it.  The static initializer data is\n-   accessible via TypeInfo, and is also used in 'new class' and default\n+   accessible via TypeInfo, and is also used in `new class' and default\n    initializing struct literals.  */\n \n tree"}, {"sha": "e1842cc6feec39c3bffb1d56fa38f7c076bfbd84", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=cdbf48bed4e947f8d20c8c22d400fb52a407d46f", "patch": "@@ -1739,7 +1739,7 @@ class ExprVisitor : public Visitor\n \t\t    thisexp = TREE_OPERAND (thisexp, 1);\n \t\t  }\n \n-\t\t/* Want reference to 'this' object.  */\n+\t\t/* Want reference to `this' object.  */\n \t\tif (!POINTER_TYPE_P (TREE_TYPE (thisexp)))\n \t\t  thisexp = build_address (thisexp);\n \n@@ -1770,7 +1770,7 @@ class ExprVisitor : public Visitor\n \t  {\n \t    /* This gets the true function type, getting the function type\n \t       from e1->type can sometimes be incorrect, such as when calling\n-\t       a 'ref' return function.  */\n+\t       a `ref' return function.  */\n \t    tf = get_function_type (e1b->isDotVarExp ()->var->type);\n \t  }\n \telse\n@@ -1794,7 +1794,7 @@ class ExprVisitor : public Visitor\n \n \tif (fd->isNested ())\n \t  {\n-\t    /* Maybe re-evaluate symbol storage treating 'fd' as public.  */\n+\t    /* Maybe re-evaluate symbol storage treating `fd' as public.  */\n \t    if (call_by_alias_p (d_function_chain->function, fd))\n \t      TREE_PUBLIC (callee) = 1;\n \n@@ -2099,7 +2099,7 @@ class ExprVisitor : public Visitor\n   {\n     Type *ftype = e->type->toBasetype ();\n \n-    /* This check is for lambda's, remove 'vthis' as function isn't nested.  */\n+    /* This check is for lambda's, remove `vthis' as function isn't nested.  */\n     if (e->fd->tok == TOKreserved && ftype->ty == Tpointer)\n       {\n \te->fd->tok = TOKfunction;"}, {"sha": "34cd5e1fdd293d438707f5033e4da22dc53b97a2", "filename": "gcc/d/imports.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Fimports.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Fimports.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fimports.cc?ref=cdbf48bed4e947f8d20c8c22d400fb52a407d46f", "patch": "@@ -202,7 +202,7 @@ build_import_decl (Dsymbol *d)\n       input_location = saved_location;\n     }\n \n-  /* Not all visitors set 'isym'.  */\n+  /* Not all visitors set `isym'.  */\n   return d->isym ? d->isym : NULL_TREE;\n }\n "}, {"sha": "b4426e150ba5a041f04a4a84591031c8a82fe2ce", "filename": "gcc/d/runtime.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Fruntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Fruntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fruntime.cc?ref=cdbf48bed4e947f8d20c8c22d400fb52a407d46f", "patch": "@@ -219,7 +219,7 @@ build_libcall_decl (const char *name, d_libcall_type return_type,\n   bool varargs = false;\n   tree fntype;\n \n-  /* Add parameter types, using 'void' as the last parameter type\n+  /* Add parameter types, using `void' as the last parameter type\n      to mean this function accepts a variable list of arguments.  */\n   va_list ap;\n   va_start (ap, nparams);"}, {"sha": "b6f72092e5f50e4d3c542ad19d682e4a60752666", "filename": "gcc/d/toir.cc", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Ftoir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Ftoir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftoir.cc?ref=cdbf48bed4e947f8d20c8c22d400fb52a407d46f", "patch": "@@ -564,22 +564,22 @@ class IRVisitor : public Visitor\n   {\n     this->start_scope (level_cond);\n \n-    /* Build the outer 'if' condition, which may produce temporaries\n+    /* Build the outer `if' condition, which may produce temporaries\n        requiring scope destruction.  */\n     tree ifcond = convert_for_condition (build_expr_dtor (s->condition),\n \t\t\t\t\t s->condition->type);\n     tree ifbody = void_node;\n     tree elsebody = void_node;\n \n-    /* Build the 'then' branch.  */\n+    /* Build the `then' branch.  */\n     if (s->ifbody)\n       {\n \tpush_stmt_list ();\n \tthis->build_stmt (s->ifbody);\n \tifbody = pop_stmt_list ();\n       }\n \n-    /* Now build the 'else' branch, which may have nested 'else if' parts.  */\n+    /* Now build the `else' branch, which may have nested `else if' parts.  */\n     if (s->elsebody)\n       {\n \tpush_stmt_list ();\n@@ -627,7 +627,7 @@ class IRVisitor : public Visitor\n \tthis->pop_continue_label (lcontinue);\n       }\n \n-    /* Build the outer 'while' condition, which may produce temporaries\n+    /* Build the outer `while' condition, which may produce temporaries\n        requiring scope destruction.  */\n     tree exitcond = convert_for_condition (build_expr_dtor (s->condition),\n \t\t\t\t\t   s->condition->type);\n@@ -885,7 +885,7 @@ class IRVisitor : public Visitor\n \t  {\n \t    tree defaultlabel = this->lookup_label (s->sdefault);\n \n-\t    /* The default label is the last 'else' block.  */\n+\t    /* The default label is the last `else' block.  */\n \t    if (s->hasVars)\n \t      {\n \t\tthis->do_jump (defaultlabel);\n@@ -917,7 +917,7 @@ class IRVisitor : public Visitor\n \n     SWITCH_BREAK_LABEL_P (lbreak) = 1;\n \n-    /* If the switch had any 'break' statements, emit the label now.  */\n+    /* If the switch had any `break' statements, emit the label now.  */\n     this->pop_break_label (lbreak);\n     this->finish_scope ();\n   }\n@@ -968,7 +968,7 @@ class IRVisitor : public Visitor\n       this->build_stmt (s->statement);\n   }\n \n-  /* Implements 'goto default' by jumping to the label associated with\n+  /* Implements `goto default' by jumping to the label associated with\n      the DefaultStatement in a switch block.  */\n \n   void visit (GotoDefaultStatement *s)\n@@ -977,7 +977,7 @@ class IRVisitor : public Visitor\n     this->do_jump (label);\n   }\n \n-  /* Implements 'goto case' by jumping to the label associated with the\n+  /* Implements `goto case' by jumping to the label associated with the\n      CaseStatement in a switch block.  */\n \n   void visit (GotoCaseStatement *s)\n@@ -1112,7 +1112,7 @@ class IRVisitor : public Visitor\n \n     if (s->wthis)\n       {\n-\t/* Perform initialisation of the 'with' handle.  */\n+\t/* Perform initialisation of the `with' handle.  */\n \tExpInitializer *ie = s->wthis->_init->isExpInitializer ();\n \tgcc_assert (ie != NULL);\n \n@@ -1127,7 +1127,7 @@ class IRVisitor : public Visitor\n     this->finish_scope ();\n   }\n \n-  /* Implements 'throw Object'.  Frontend already checks that the object\n+  /* Implements `throw Object'.  Frontend already checks that the object\n      thrown is a class type, but does not check if it is derived from\n      Object.  Foreign objects are not currently supported at run-time.  */\n \n@@ -1432,7 +1432,7 @@ class IRVisitor : public Visitor\n        optimization, this could be unset when building in release mode.  */\n     ASM_VOLATILE_P (exp) = 1;\n \n-    /* If the function has been annotated with 'pragma(inline)', then mark\n+    /* If the function has been annotated with `pragma(inline)', then mark\n        the asm expression as being inline as well.  */\n     if (this->func_->inlining == PINLINEalways)\n       ASM_INLINE_P (exp) = 1;"}, {"sha": "b03019bdff567e9931d56afea1e3cea6c1c499e6", "filename": "gcc/d/typeinfo.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Ftypeinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Ftypeinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypeinfo.cc?ref=cdbf48bed4e947f8d20c8c22d400fb52a407d46f", "patch": "@@ -456,7 +456,7 @@ class TypeInfoVisitor : public Visitor\n \t    CONSTRUCTOR_APPEND_ELT (v, size_int (2), value);\n \t  }\n \n-\t/* The 'this' offset.  */\n+\t/* The `this' offset.  */\n \tCONSTRUCTOR_APPEND_ELT (v, size_int (3), size_int (b->offset));\n \n \t/* Add to the array of interfaces.  */\n@@ -1483,7 +1483,7 @@ create_typeinfo (Type *type, Module *mod)\n \t  /* Kinds of TypeInfo that add one extra pointer field.  */\n \t  if (tk == TK_SHARED_TYPE)\n \t    {\n-\t      /* Does both 'shared' and 'shared const'.  */\n+\t      /* Does both `shared' and `shared const'.  */\n \t      t->vtinfo = TypeInfoSharedDeclaration::create (t);\n \t      ident = Identifier::idPool (\"TypeInfo_Shared\");\n \t    }"}, {"sha": "b8984a50ff05bad9c512b8760483831264c65fe1", "filename": "gcc/d/types.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbf48bed4e947f8d20c8c22d400fb52a407d46f/gcc%2Fd%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypes.cc?ref=cdbf48bed4e947f8d20c8c22d400fb52a407d46f", "patch": "@@ -106,7 +106,7 @@ same_type_p (Type *t1, Type *t2)\n   return false;\n }\n \n-/* Returns 'Object' type which all D classes are derived from.  */\n+/* Returns `Object' type which all D classes are derived from.  */\n \n Type *\n get_object_type (void)\n@@ -204,7 +204,7 @@ insert_type_modifiers (tree type, unsigned mod)\n \n   tree qualtype = build_qualified_type (type, quals);\n \n-  /* Mark whether the type is qualified 'shared'.  */\n+  /* Mark whether the type is qualified `shared'.  */\n   if (mod & MODshared)\n     TYPE_SHARED (qualtype) = 1;\n "}]}