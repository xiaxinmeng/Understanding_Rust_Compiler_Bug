{"sha": "e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdhYzZhN2NlYmM3YWY0NTMxOWFjMWI4OGQzZjYwNzFmMGZlZDQ5ZQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2013-04-16T20:54:21Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2013-04-16T20:54:21Z"}, "message": "re PR fortran/39505 (Consider a 'no arg check' directive)\n\n2013-04-12  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/39505\n        * decl.c (ext_attr_list): Add EXT_ATTR_NO_ARG_CHECK.\n        * gfortran.h (ext_attr_id_t): Ditto.\n        * gfortran.texi (GNU Fortran Compiler Directives):\n        Document it.\n        * interface.c (compare_type_rank): Ignore rank for NO_ARG_CHECK.\n        (compare_parameter): Ditto - and regard as unlimited polymorphic.\n        * resolve.c (resolve_symbol, resolve_variable): Add same\n        * constraint\n        checks as for TYPE(*); turn dummy to TYPE(*),dimension(*).\n        (gfc_explicit_interface_required): Require explicit interface\n        for NO_ARG_CHECK.\n\n2013-04-12  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/39505\n        * gfortran.dg/no_arg_check_1.f90: New.\n        * gfortran.dg/no_arg_check_2.f90: New.\n        * gfortran.dg/no_arg_check_3.f90: New.\n\nFrom-SVN: r198011", "tree": {"sha": "ae48f47ebf76afba5e32eeb6ff8fdc0fcb516a97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae48f47ebf76afba5e32eeb6ff8fdc0fcb516a97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bafa0782ad3ba8e5c92196b00d76b38d69e3e1e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bafa0782ad3ba8e5c92196b00d76b38d69e3e1e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bafa0782ad3ba8e5c92196b00d76b38d69e3e1e1"}], "stats": {"total": 497, "additions": 481, "deletions": 16}, "files": [{"sha": "2f99025ea3361e1cb555aef357c536ffe4b411bd", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e", "patch": "@@ -1,3 +1,17 @@\n+2013-04-16  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/39505\n+\t* decl.c (ext_attr_list): Add EXT_ATTR_NO_ARG_CHECK.\n+\t* gfortran.h (ext_attr_id_t): Ditto.\n+\t* gfortran.texi (GNU Fortran Compiler Directives):\n+\tDocument it.\n+\t* interface.c (compare_type_rank): Ignore rank for NO_ARG_CHECK.\n+\t(compare_parameter): Ditto - and regard as unlimited polymorphic.\n+\t* resolve.c (resolve_symbol, resolve_variable): Add same constraint\n+\tchecks as for TYPE(*); turn dummy to TYPE(*),dimension(*).\n+\t(gfc_explicit_interface_required): Require explicit interface\n+\tfor NO_ARG_CHECK.\n+\n 2013-04-16  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/56968"}, {"sha": "f9891c98d0fd62fb73ebf56fcf2831bae9e52174", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e", "patch": "@@ -8572,12 +8572,13 @@ gfc_match_final_decl (void)\n \n \n const ext_attr_t ext_attr_list[] = {\n-  { \"dllimport\", EXT_ATTR_DLLIMPORT, \"dllimport\" },\n-  { \"dllexport\", EXT_ATTR_DLLEXPORT, \"dllexport\" },\n-  { \"cdecl\",     EXT_ATTR_CDECL,     \"cdecl\"     },\n-  { \"stdcall\",   EXT_ATTR_STDCALL,   \"stdcall\"   },\n-  { \"fastcall\",  EXT_ATTR_FASTCALL,  \"fastcall\"  },\n-  { NULL,        EXT_ATTR_LAST,      NULL        }\n+  { \"dllimport\",    EXT_ATTR_DLLIMPORT,    \"dllimport\" },\n+  { \"dllexport\",    EXT_ATTR_DLLEXPORT,    \"dllexport\" },\n+  { \"cdecl\",        EXT_ATTR_CDECL,        \"cdecl\"     },\n+  { \"stdcall\",      EXT_ATTR_STDCALL,      \"stdcall\"   },\n+  { \"fastcall\",     EXT_ATTR_FASTCALL,     \"fastcall\"  },\n+  { \"no_arg_check\", EXT_ATTR_NO_ARG_CHECK, NULL        },\n+  { NULL,           EXT_ATTR_LAST,         NULL        }\n };\n \n /* Match a !GCC$ ATTRIBUTES statement of the form:"}, {"sha": "27662f7ca404c03a2f12e141c4edfac035005d45", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e", "patch": "@@ -679,6 +679,7 @@ typedef enum\n   EXT_ATTR_STDCALL,\n   EXT_ATTR_CDECL,\n   EXT_ATTR_FASTCALL,\n+  EXT_ATTR_NO_ARG_CHECK,\n   EXT_ATTR_LAST, EXT_ATTR_NUM = EXT_ATTR_LAST\n }\n ext_attr_id_t;"}, {"sha": "f4bcdef69c472d3e0a22ec2dbb81afc2bd0820c4", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e", "patch": "@@ -2688,6 +2688,29 @@ are in a shared library.  The following attributes are available:\n @item @code{DLLIMPORT} -- reference the function or variable using a global pointer \n @end itemize\n \n+For dummy arguments, the @code{NO_ARG_CHECK} attribute can be used; in\n+other compilers, it is also known as @code{IGNORE_TKR}.  For dummy arguments\n+with this attribute actual arguments of any type and kind (similar to\n+@code{TYPE(*)}), scalars and arrays of any rank (no equivalent\n+in Fortran standard) are accepted.  As with @code{TYPE(*)}, the argument\n+is unlimited polymorphic and no type information is available.\n+Additionally, the same restrictions apply, i.e. the argument may only be\n+passed to dummy arguments with the @code{NO_ARG_CHECK} attribute and as\n+argument to the @code{C_LOC} intrinsic function of the @code{ISO_C_BINDING}\n+module.\n+\n+Variables with @code{NO_ARG_CHECK} attribute shall be of assumed-type\n+(@code{TYPE(*)}; recommended) or of an intrinsic numeric type; they\n+shall not have the @code{ALLOCATE}, @code{CODIMENSION}, @code{INTENT(OUT)},\n+@code{POINTER} or @code{VALUE} attribute; furthermore, they shall be\n+either scalar or of assumed-size (@code{dimension(*)}). As @code{TYPE(*)},\n+the @code{NO_ARG_CHECK} attribute requires an explicit interface.\n+\n+@itemize\n+@item @code{NO_ARG_CHECK} -- disable the type, kind and rank checking\n+@end itemize\n+\n+\n The attributes are specified using the syntax\n \n @code{!GCC$ ATTRIBUTES} @var{attribute-list} @code{::} @var{variable-list}"}, {"sha": "8f7cad72992efe88bde8f22aa78a7fda5f595446", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e", "patch": "@@ -518,6 +518,10 @@ compare_type_rank (gfc_symbol *s1, gfc_symbol *s2)\n   gfc_array_spec *as1, *as2;\n   int r1, r2;\n \n+  if (s1->attr.ext_attr & (1 << EXT_ATTR_NO_ARG_CHECK)\n+      || s2->attr.ext_attr & (1 << EXT_ATTR_NO_ARG_CHECK))\n+    return 1;\n+\n   as1 = (s1->ts.type == BT_CLASS) ? CLASS_DATA (s1)->as : s1->as;\n   as2 = (s2->ts.type == BT_CLASS) ? CLASS_DATA (s2)->as : s2->as;\n \n@@ -1900,6 +1904,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n   if ((actual->expr_type != EXPR_NULL || actual->ts.type != BT_UNKNOWN)\n       && actual->ts.type != BT_HOLLERITH\n       && formal->ts.type != BT_ASSUMED\n+      && !(formal->attr.ext_attr & (1 << EXT_ATTR_NO_ARG_CHECK))\n       && !gfc_compare_types (&formal->ts, &actual->ts)\n       && !(formal->ts.type == BT_DERIVED && actual->ts.type == BT_CLASS\n \t   && gfc_compare_derived_types (formal->ts.u.derived,\n@@ -2060,6 +2065,10 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t\t   || formal->as->type == AS_DEFERRED)\n \t       && actual->expr_type != EXPR_NULL;\n \n+  /* Skip rank checks for NO_ARG_CHECK.  */\n+  if (formal->attr.ext_attr & (1 << EXT_ATTR_NO_ARG_CHECK))\n+    return 1;\n+\n   /* Scalar & coindexed, see: F2008, Section 12.5.2.4.  */\n   if (rank_check || ranks_must_agree\n       || (formal->attr.pointer && actual->expr_type != EXPR_NULL)"}, {"sha": "90bce536c2db21b10bcca50813f7b66f22c2eabf", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 87, "deletions": 10, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e", "patch": "@@ -2191,6 +2191,11 @@ gfc_explicit_interface_required (gfc_symbol *sym, char *errmsg, int err_len)\n \t  strncpy (errmsg, _(\"polymorphic argument\"), err_len);\n \t  return true;\n \t}\n+      else if (arg->sym->attr.ext_attr & (1 << EXT_ATTR_NO_ARG_CHECK))\n+\t{\n+\t  strncpy (errmsg, _(\"NO_ARG_CHECK attribute\"), err_len);\n+\t  return true;\n+\t}\n       else if (arg->sym->ts.type == BT_ASSUMED)\n \t{\n \t  /* As assumed-type is unlimited polymorphic (cf. above).\n@@ -4644,8 +4649,19 @@ resolve_variable (gfc_expr *e)\n     return false;\n   sym = e->symtree->n.sym;\n \n+  /* Use same check as for TYPE(*) below; this check has to be before TYPE(*)\n+     as ts.type is set to BT_ASSUMED in resolve_symbol.  */\n+  if (sym->attr.ext_attr & (1 << EXT_ATTR_NO_ARG_CHECK))\n+    {\n+      if (!actual_arg || inquiry_argument)\n+\t{\n+\t  gfc_error (\"Variable %s at %L with NO_ARG_CHECK attribute may only \"\n+\t\t     \"be used as actual argument\", sym->name, &e->where);\n+\t  return false;\n+\t}\n+    }\n   /* TS 29113, 407b.  */\n-  if (e->ts.type == BT_ASSUMED)\n+  else if (e->ts.type == BT_ASSUMED)\n     {\n       if (!actual_arg)\n \t{\n@@ -4665,13 +4681,12 @@ resolve_variable (gfc_expr *e)\n \t  return false;\n \t}\n     }\n-\n   /* TS 29113, C535b.  */\n-  if ((sym->ts.type == BT_CLASS && sym->attr.class_ok\n-\t&& CLASS_DATA (sym)->as\n-\t&& CLASS_DATA (sym)->as->type == AS_ASSUMED_RANK)\n-       || (sym->ts.type != BT_CLASS && sym->as\n-\t   && sym->as->type == AS_ASSUMED_RANK))\n+  else if ((sym->ts.type == BT_CLASS && sym->attr.class_ok\n+\t    && CLASS_DATA (sym)->as\n+\t    && CLASS_DATA (sym)->as->type == AS_ASSUMED_RANK)\n+\t   || (sym->ts.type != BT_CLASS && sym->as\n+\t       && sym->as->type == AS_ASSUMED_RANK))\n     {\n       if (!actual_arg)\n \t{\n@@ -4692,10 +4707,18 @@ resolve_variable (gfc_expr *e)\n \t}\n     }\n \n-  /* TS 29113, 407b.  */\n-  if (e->ts.type == BT_ASSUMED && e->ref\n+  if ((sym->attr.ext_attr & (1 << EXT_ATTR_NO_ARG_CHECK)) && e->ref\n       && !(e->ref->type == REF_ARRAY && e->ref->u.ar.type == AR_FULL\n \t   && e->ref->next == NULL))\n+    {\n+      gfc_error (\"Variable %s at %L with NO_ARG_CHECK attribute shall not have \"\n+\t\t \"a subobject reference\", sym->name, &e->ref->u.ar.where);\n+      return false;\n+    }\n+  /* TS 29113, 407b.  */\n+  else if (e->ts.type == BT_ASSUMED && e->ref\n+\t   && !(e->ref->type == REF_ARRAY && e->ref->u.ar.type == AR_FULL\n+\t\t&& e->ref->next == NULL))\n     {\n       gfc_error (\"Assumed-type variable %s at %L shall not have a subobject \"\n \t\t \"reference\", sym->name, &e->ref->u.ar.where);\n@@ -12837,7 +12860,61 @@ resolve_symbol (gfc_symbol *sym)\n \t}\n     }\n \n-  if (sym->ts.type == BT_ASSUMED)\n+    /* Use the same constraints as TYPE(*), except for the type check\n+       and that only scalars and assumed-size arrays are permitted.  */\n+    if (sym->attr.ext_attr & (1 << EXT_ATTR_NO_ARG_CHECK))\n+      {\n+\tif (!sym->attr.dummy)\n+\t  {\n+\t    gfc_error (\"Variable %s at %L with NO_ARG_CHECK attribute shall be \"\n+\t\t       \"a dummy argument\", sym->name, &sym->declared_at);\n+\t    return;\n+\t  }\n+\n+\tif (sym->ts.type != BT_ASSUMED && sym->ts.type != BT_INTEGER\n+\t    && sym->ts.type != BT_REAL && sym->ts.type != BT_LOGICAL\n+\t    && sym->ts.type != BT_COMPLEX)\n+\t  {\n+\t    gfc_error (\"Variable %s at %L with NO_ARG_CHECK attribute shall be \"\n+\t\t       \"of type TYPE(*) or of an numeric intrinsic type\",\n+\t\t       sym->name, &sym->declared_at);\n+\t    return;\n+\t  }\n+\n+      if (sym->attr.allocatable || sym->attr.codimension\n+\t  || sym->attr.pointer || sym->attr.value)\n+\t{\n+\t  gfc_error (\"Variable %s at %L with NO_ARG_CHECK attribute may not \"\n+\t\t     \"have the ALLOCATABLE, CODIMENSION, POINTER or VALUE \"\n+\t\t     \"attribute\", sym->name, &sym->declared_at);\n+\t  return;\n+\t}\n+\n+      if (sym->attr.intent == INTENT_OUT)\n+\t{\n+\t  gfc_error (\"Variable %s at %L with NO_ARG_CHECK attribute may not \"\n+\t\t     \"have the INTENT(OUT) attribute\",\n+\t\t     sym->name, &sym->declared_at);\n+\t  return;\n+\t}\n+      if (sym->attr.dimension && sym->as->type != AS_ASSUMED_SIZE)\n+\t{\n+\t  gfc_error (\"Variable %s at %L with NO_ARG_CHECK attribute shall \"\n+\t\t     \"either be a scalar or an assumed-size array\",\n+\t\t     sym->name, &sym->declared_at);\n+\t  return;\n+\t}\n+\n+      /* Set the type to TYPE(*) and add a dimension(*) to ensure\n+\t NO_ARG_CHECK is correctly handled in trans*.c, e.g. with\n+\t packing.  */\n+      sym->ts.type = BT_ASSUMED;\n+      sym->as = gfc_get_array_spec ();\n+      sym->as->type = AS_ASSUMED_SIZE;\n+      sym->as->rank = 1;\n+      sym->as->lower[0] = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);\n+    }\n+  else if (sym->ts.type == BT_ASSUMED)\n     {\n       /* TS 29113, C407a.  */\n       if (!sym->attr.dummy)"}, {"sha": "02cb9473ef6dc44ba5f8a63a70993a20ceec199e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e", "patch": "@@ -1,3 +1,10 @@\n+2013-04-16  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/39505\n+\t* gfortran.dg/no_arg_check_1.f90: New.\n+\t* gfortran.dg/no_arg_check_2.f90: New.\n+\t* gfortran.dg/no_arg_check_3.f90: New.\n+\n 2013-04-16  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/56968"}, {"sha": "1e1855d3174f23691684abf6dd983199c2685190", "filename": "gcc/testsuite/gfortran.dg/no_arg_check_1.f90", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ftestsuite%2Fgfortran.dg%2Fno_arg_check_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ftestsuite%2Fgfortran.dg%2Fno_arg_check_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fno_arg_check_1.f90?ref=e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e", "patch": "@@ -0,0 +1,56 @@\n+! { dg-do compile }\n+!\n+! PR fortran/39505\n+! \n+! Test NO_ARG_CHECK\n+! Copied from assumed_type_1.f90\n+!\n+module mpi_interface\n+  implicit none\n+\n+  interface !mpi_send\n+    subroutine MPI_Send (buf, count, datatype, dest, tag, comm, ierr)\n+!GCC$ attributes NO_ARG_CHECK :: buf\n+      integer, intent(in) :: buf\n+      integer, intent(in) :: count\n+      integer, intent(in) :: datatype\n+      integer, intent(in) :: dest\n+      integer, intent(in) :: tag\n+      integer, intent(in) :: comm\n+      integer, intent(out):: ierr\n+    end subroutine\n+  end interface\n+\n+  interface !mpi_send2\n+    subroutine MPI_Send2 (buf, count, datatype, dest, tag, comm, ierr)\n+!GCC$ attributes NO_ARG_CHECK :: buf\n+      type(*), intent(in) :: buf(*)\n+      integer, intent(in) :: count\n+      integer, intent(in) :: datatype\n+      integer, intent(in) :: dest\n+      integer, intent(in) :: tag\n+      integer, intent(in) :: comm\n+      integer, intent(out):: ierr\n+    end subroutine\n+  end interface\n+\n+end module\n+\n+use mpi_interface\n+  real :: a(3)\n+  integer :: b(3)\n+  call foo(a)\n+  call foo(b)\n+  call foo(a(1:2))\n+  call foo(b(1:2))\n+  call MPI_Send(a, 1, 1,1,1,j,i)\n+  call MPI_Send(b, 1, 1,1,1,j,i)\n+  call MPI_Send2(a, 1, 1,1,1,j,i)\n+  call MPI_Send2(b, 1, 1,1,1,j,i)\n+contains\n+    subroutine foo(x)\n+!GCC$ attributes NO_ARG_CHECK :: x\n+    real :: x(*)\n+    call MPI_Send2(x, 1, 1,1,1,j,i)\n+  end\n+end"}, {"sha": "5ff98940d6f519652cf06d8def858cf5e30ba29c", "filename": "gcc/testsuite/gfortran.dg/no_arg_check_2.f90", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ftestsuite%2Fgfortran.dg%2Fno_arg_check_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ftestsuite%2Fgfortran.dg%2Fno_arg_check_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fno_arg_check_2.f90?ref=e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e", "patch": "@@ -0,0 +1,153 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! PR fortran/39505\n+! \n+! Test NO_ARG_CHECK\n+! Copied from assumed_type_2.f90\n+!\n+\n+module mod\n+  use iso_c_binding, only: c_loc, c_ptr, c_bool\n+  implicit none\n+  interface my_c_loc\n+    function my_c_loc1(x) bind(C)\n+      import c_ptr\n+!GCC$ attributes NO_ARG_CHECK :: x\n+      type(*) :: x\n+      type(c_ptr) :: my_c_loc1\n+    end function\n+  end interface my_c_loc\n+contains\n+  subroutine sub_scalar (arg1, presnt)\n+     integer(8), target, optional :: arg1\n+     logical :: presnt\n+     type(c_ptr) :: cpt\n+!GCC$ attributes NO_ARG_CHECK :: arg1\n+     if (presnt .neqv. present (arg1)) call abort ()\n+     cpt = c_loc (arg1)\n+  end subroutine sub_scalar\n+\n+  subroutine sub_array_assumed (arg3)\n+!GCC$ attributes NO_ARG_CHECK :: arg3\n+     logical(1), target :: arg3(*)\n+     type(c_ptr) :: cpt\n+     cpt = c_loc (arg3)\n+  end subroutine sub_array_assumed\n+end module\n+\n+use mod\n+use iso_c_binding, only: c_int, c_null_ptr\n+implicit none\n+type t1\n+  integer :: a\n+end type t1\n+type :: t2\n+  sequence\n+  integer :: b\n+end type t2\n+type, bind(C) :: t3\n+  integer(c_int) :: c\n+end type t3\n+\n+integer            :: scalar_int\n+real, allocatable  :: scalar_real_alloc\n+character, pointer :: scalar_char_ptr\n+\n+integer            :: array_int(3)\n+real, allocatable  :: array_real_alloc(:,:)\n+character, pointer :: array_char_ptr(:,:)\n+\n+type(t1)              :: scalar_t1\n+type(t2), allocatable :: scalar_t2_alloc\n+type(t3), pointer     :: scalar_t3_ptr\n+\n+type(t1)              :: array_t1(4)\n+type(t2), allocatable :: array_t2_alloc(:,:)\n+type(t3), pointer     :: array_t3_ptr(:,:)\n+\n+class(t1), allocatable :: scalar_class_t1_alloc\n+class(t1), pointer     :: scalar_class_t1_ptr\n+\n+class(t1), allocatable :: array_class_t1_alloc(:,:)\n+class(t1), pointer     :: array_class_t1_ptr(:,:)\n+\n+scalar_char_ptr => null()\n+scalar_t3_ptr => null()\n+\n+call sub_scalar (presnt=.false.)\n+call sub_scalar (scalar_real_alloc, .false.)\n+call sub_scalar (scalar_char_ptr, .false.)\n+call sub_scalar (null (), .false.)\n+call sub_scalar (scalar_t2_alloc, .false.)\n+call sub_scalar (scalar_t3_ptr, .false.)\n+\n+allocate (scalar_real_alloc, scalar_char_ptr, scalar_t3_ptr)\n+allocate (scalar_class_t1_alloc, scalar_class_t1_ptr, scalar_t2_alloc)\n+allocate (array_real_alloc(3:5,2:4), array_char_ptr(-2:2,2))\n+allocate (array_t2_alloc(3:5,2:4), array_t3_ptr(-2:2,2))\n+allocate (array_class_t1_alloc(3,3), array_class_t1_ptr(4,4))\n+\n+call sub_scalar (scalar_int, .true.)\n+call sub_scalar (scalar_real_alloc, .true.)\n+call sub_scalar (scalar_char_ptr, .true.)\n+call sub_scalar (array_int(2), .true.)\n+call sub_scalar (array_real_alloc(3,2), .true.)\n+call sub_scalar (array_char_ptr(0,1), .true.)\n+call sub_scalar (scalar_t1, .true.)\n+call sub_scalar (scalar_t2_alloc, .true.)\n+call sub_scalar (scalar_t3_ptr, .true.)\n+call sub_scalar (array_t1(2), .true.)\n+call sub_scalar (array_t2_alloc(3,2), .true.)\n+call sub_scalar (array_t3_ptr(0,1), .true.)\n+call sub_scalar (array_class_t1_alloc(2,1), .true.)\n+call sub_scalar (array_class_t1_ptr(3,3), .true.)\n+\n+call sub_array_assumed (array_int)\n+call sub_array_assumed (array_real_alloc)\n+call sub_array_assumed (array_char_ptr)\n+call sub_array_assumed (array_t1)\n+call sub_array_assumed (array_t2_alloc)\n+call sub_array_assumed (array_t3_ptr)\n+call sub_array_assumed (array_class_t1_alloc)\n+call sub_array_assumed (array_class_t1_ptr)\n+\n+deallocate (scalar_char_ptr, scalar_class_t1_ptr, array_char_ptr)\n+deallocate (array_class_t1_ptr, array_t3_ptr)\n+contains\n+  subroutine sub(x)\n+    integer :: x(:)\n+    call sub_array_assumed (x)\n+  end subroutine sub\n+end\n+\n+! { dg-final { scan-tree-dump-times \"sub_scalar .0B,\"  2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .scalar_real_alloc,\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .scalar_char_ptr,\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .scalar_t2_alloc,\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .scalar_t3_ptr\" 2 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"sub_scalar .&scalar_int,\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .&scalar_t1,\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .&array_int.1.,\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .&scalar_t1,\" 1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"sub_scalar .&\\\\(.\\\\(real.kind=4..0:. . restrict\\\\) array_real_alloc.data\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .&\\\\(.\\\\(character.kind=1..0:..1:1. .\\\\) array_char_ptr.data\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .&\\\\(.\\\\(struct t2.0:. . restrict\\\\) array_t2_alloc.data\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .&\\\\(.\\\\(struct t3.0:. .\\\\) array_t3_ptr.data\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .\\\\(struct t1 .\\\\) array_class_t1_alloc._data.data\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .\\\\(struct t1 .\\\\) array_class_t1_ptr._data.dat\" 1 \"original\" } }a\n+\n+! { dg-final { scan-tree-dump-times \"sub_array_assumed \\\\(D\" 3 \"original\" } }\n+! { dg-final { scan-tree-dump-times \" = _gfortran_internal_pack \\\\(&parm\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_array_assumed \\\\(&array_int\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_array_assumed \\\\(\\\\(real\\\\(kind=4\\\\).0:. . restrict\\\\) array_real_alloc.data\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \" = _gfortran_internal_pack \\\\(&array_char_ptr\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\.data = \\\\(void .\\\\) &array_t1.0.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_array_assumed \\\\(\\\\(struct t1.0:. .\\\\) parm\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_array_assumed \\\\(\\\\(struct t2.0:. . restrict\\\\) array_t2_alloc.data\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_array_assumed \\\\(\\\\(struct t1.0:. . restrict\\\\) array_class_t1_alloc._data.data\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_array_assumed \\\\(\\\\(struct t1.0:. .\\\\) array_class_t1_ptr._data.data\\\\);\" 1 \"original\" } }\n+\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "c3a80899ade54c9e7c0cc0dafeb6208ca030f2c8", "filename": "gcc/testsuite/gfortran.dg/no_arg_check_3.f90", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ftestsuite%2Fgfortran.dg%2Fno_arg_check_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e/gcc%2Ftestsuite%2Fgfortran.dg%2Fno_arg_check_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fno_arg_check_3.f90?ref=e7ac6a7cebc7af45319ac1b88d3f6071f0fed49e", "patch": "@@ -0,0 +1,124 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! PR fortran/39505\n+! \n+! Test NO_ARG_CHECK\n+! Copied from assumed_type_2.f90\n+!\n+subroutine one(a) ! { dg-error \"may not have the ALLOCATABLE, CODIMENSION, POINTER or VALUE attribute\" }\n+!GCC$ attributes NO_ARG_CHECK :: a\n+  integer, value :: a\n+end subroutine one\n+\n+subroutine two(a) ! { dg-error \"may not have the ALLOCATABLE, CODIMENSION, POINTER or VALUE attribute\" }\n+!GCC$ attributes NO_ARG_CHECK :: a\n+  integer, pointer :: a\n+end subroutine two\n+\n+subroutine three(a) ! { dg-error \"may not have the ALLOCATABLE, CODIMENSION, POINTER or VALUE attribute\" }\n+!GCC$ attributes NO_ARG_CHECK :: a\n+  integer, allocatable :: a\n+end subroutine three\n+\n+subroutine four(a) ! { dg-error \"may not have the ALLOCATABLE, CODIMENSION, POINTER or VALUE attribute\" }\n+!GCC$ attributes NO_ARG_CHECK :: a\n+  integer  :: a[*]\n+end subroutine four\n+\n+subroutine five(a) ! { dg-error \"with NO_ARG_CHECK attribute shall either be a scalar or an assumed-size array\" }\n+!GCC$ attributes NO_ARG_CHECK :: a\n+  integer :: a(3)\n+end subroutine five\n+\n+subroutine six()\n+!GCC$ attributes NO_ARG_CHECK :: nodum ! { dg-error \"with NO_ARG_CHECK attribute shall be a dummy argument\" }\n+  integer :: nodum\n+end subroutine six\n+\n+subroutine seven(y)\n+!GCC$ attributes NO_ARG_CHECK :: y\n+ integer :: y(*)\n+ call a7(y(3:5)) ! { dg-error \"with NO_ARG_CHECK attribute shall not have a subobject reference\" }\n+contains\n+ subroutine a7(x)\n+!GCC$ attributes NO_ARG_CHECK :: x\n+   integer :: x(*)\n+ end subroutine a7\n+end subroutine seven\n+\n+subroutine nine()\n+  interface one\n+    subroutine okay(x)\n+!GCC$ attributes NO_ARG_CHECK :: x\n+      integer :: x\n+    end subroutine okay\n+  end interface\n+  interface two\n+    subroutine ambig1(x)\n+!GCC$ attributes NO_ARG_CHECK :: x\n+      integer :: x\n+    end subroutine ambig1\n+    subroutine ambig2(x)\n+!GCC$ attributes NO_ARG_CHECK :: x\n+      integer :: x(*)\n+    end subroutine ambig2 ! { dg-error \"Ambiguous interfaces 'ambig2' and 'ambig1' in generic interface 'two'\" }\n+  end interface\n+  interface three\n+    subroutine ambig3(x)\n+!GCC$ attributes NO_ARG_CHECK :: x\n+      integer :: x\n+    end subroutine ambig3\n+    subroutine ambig4(x)\n+      integer :: x\n+    end subroutine ambig4 ! { dg-error \"Ambiguous interfaces 'ambig4' and 'ambig3' in generic interface 'three'\" }\n+  end interface\n+end subroutine nine\n+\n+subroutine ten()\n+ interface\n+   subroutine bar()\n+   end subroutine\n+ end interface\n+ type t\n+ contains\n+   procedure, nopass :: proc => bar\n+ end type\n+ type(t) :: xx\n+ call sub(xx) ! { dg-error \"is of derived type with type-bound or FINAL procedures\" }\n+contains\n+  subroutine sub(a)\n+!GCC$ attributes NO_ARG_CHECK :: a\n+    integer :: a\n+  end subroutine sub\n+end subroutine ten\n+\n+subroutine eleven(x)\n+  external bar\n+!GCC$ attributes NO_ARG_CHECK :: x\n+  integer :: x\n+  call bar(x) ! { dg-error \"Assumed-type argument x at .1. requires an explicit interface\" }\n+end subroutine eleven\n+\n+subroutine twelf(x)\n+!GCC$ attributes NO_ARG_CHECK :: x\n+  integer :: x\n+  call bar(x) ! { dg-error \"Type mismatch in argument\" }\n+contains\n+  subroutine bar(x)\n+    integer :: x\n+  end subroutine bar\n+end subroutine twelf\n+\n+subroutine thirteen(x, y)\n+!GCC$ attributes NO_ARG_CHECK :: x\n+  integer :: x\n+  integer :: y(:)\n+  print *, ubound(y, dim=x) ! { dg-error \"must be INTEGER\" }\n+end subroutine thirteen\n+\n+subroutine fourteen(x)\n+!GCC$ attributes NO_ARG_CHECK :: x\n+  integer :: x\n+  x = x ! { dg-error \"with NO_ARG_CHECK attribute may only be used as actual argument\" }\n+end subroutine fourteen"}]}