{"sha": "2268453b5c0f425924156a445d1f1c178f821cb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI2ODQ1M2I1YzBmNDI1OTI0MTU2YTQ0NWQxZjFjMTc4ZjgyMWNiMA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2010-09-28T15:25:03Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2010-09-28T15:25:03Z"}, "message": "re PR target/45807 (Lying eh_frame r2 save info causes crashes with static libgcc_eh and libstdc++)\n\n\tPR target/45807\n\t* config/rs6000/aix.h (SETUP_FRAME_ADDRESSES): Delete.\n\t* config/rs6000/linux64.h (SETUP_FRAME_ADDRESSES): Delete.\n\t* config/rs6000/rs6000-protos.h (rs6000_aix_emit_builtin_unwind_init):\n\tDelete.\n\t* config/rs6000/rs6000.c (rs6000_aix_emit_builtin_unwind_init): Delete.\n\t(rs6000_emit_prologue): Don't just create frame save info for r2,\n\tactually save r2.\n\nFrom-SVN: r164685", "tree": {"sha": "08b4a63df76a2d77b9e83f02da266c0e8d284a26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08b4a63df76a2d77b9e83f02da266c0e8d284a26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2268453b5c0f425924156a445d1f1c178f821cb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2268453b5c0f425924156a445d1f1c178f821cb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2268453b5c0f425924156a445d1f1c178f821cb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2268453b5c0f425924156a445d1f1c178f821cb0/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4d508d590e0f6c6c0d7a2890d519a029f4282c6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d508d590e0f6c6c0d7a2890d519a029f4282c6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d508d590e0f6c6c0d7a2890d519a029f4282c6b"}], "stats": {"total": 126, "additions": 58, "deletions": 68}, "files": [{"sha": "a176a7a33b551c69e401cb30e8d4bd059b0ce4f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2268453b5c0f425924156a445d1f1c178f821cb0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2268453b5c0f425924156a445d1f1c178f821cb0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2268453b5c0f425924156a445d1f1c178f821cb0", "patch": "@@ -1,3 +1,14 @@\n+2010-09-29  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/45807\n+\t* config/rs6000/aix.h (SETUP_FRAME_ADDRESSES): Delete.\n+\t* config/rs6000/linux64.h (SETUP_FRAME_ADDRESSES): Delete.\n+\t* config/rs6000/rs6000-protos.h (rs6000_aix_emit_builtin_unwind_init):\n+\tDelete.\n+\t* config/rs6000/rs6000.c (rs6000_aix_emit_builtin_unwind_init): Delete.\n+\t(rs6000_emit_prologue): Don't just create frame save info for r2,\n+\tactually save r2.\n+\n 2010-09-28  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/cygming.h (ASM_OUTPUT_DWARF_OFFSET): Output 8 bytes"}, {"sha": "f9004b4e6f05d2f2d7e7b7cc3c169752eb4402f3", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2268453b5c0f425924156a445d1f1c178f821cb0/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2268453b5c0f425924156a445d1f1c178f821cb0/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=2268453b5c0f425924156a445d1f1c178f821cb0", "patch": "@@ -207,13 +207,6 @@\n /* And similarly for general purpose registers.  */\n #define GP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) < 32)\n \n-/* __throw will restore its own return address to be the same as the\n-   return address of the function that the throw is being made to.\n-   This is unfortunate, because we want to check the original\n-   return address to see if we need to restore the TOC.\n-   So we have to squirrel it away with this.  */\n-#define SETUP_FRAME_ADDRESSES() rs6000_aix_emit_builtin_unwind_init ()\n-\n /* If the current unwind info (FS) does not contain explicit info\n    saving R2, then we have to do a minor amount of code reading to\n    figure out if it was saved.  The big problem here is that the"}, {"sha": "b233261286ce03fdac1743c4ad2b958b1e458abd", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2268453b5c0f425924156a445d1f1c178f821cb0/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2268453b5c0f425924156a445d1f1c178f821cb0/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=2268453b5c0f425924156a445d1f1c178f821cb0", "patch": "@@ -305,14 +305,6 @@ extern enum rs6000_cmodel cmodel;\n #define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n   (!(FIRST) ? upward : FUNCTION_ARG_PADDING (MODE, TYPE))\n \n-/* __throw will restore its own return address to be the same as the\n-   return address of the function that the throw is being made to.\n-   This is unfortunate, because we want to check the original\n-   return address to see if we need to restore the TOC.\n-   So we have to squirrel it away with this.  */\n-#define SETUP_FRAME_ADDRESSES() \\\n-  do { if (TARGET_64BIT) rs6000_aix_emit_builtin_unwind_init (); } while (0)\n-\n /* Override svr4.h  */\n #undef MD_EXEC_PREFIX\n #undef MD_STARTFILE_PREFIX"}, {"sha": "0678fc0d1899a70c714fa9e9ec670d865e82b9e2", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2268453b5c0f425924156a445d1f1c178f821cb0/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2268453b5c0f425924156a445d1f1c178f821cb0/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=2268453b5c0f425924156a445d1f1c178f821cb0", "patch": "@@ -163,7 +163,6 @@ extern int rs6000_trampoline_size (void);\n extern alias_set_type get_TOC_alias_set (void);\n extern void rs6000_emit_prologue (void);\n extern void rs6000_emit_load_toc_table (int);\n-extern void rs6000_aix_emit_builtin_unwind_init (void);\n extern unsigned int rs6000_dbx_register_number (unsigned int);\n extern void rs6000_emit_epilogue (int);\n extern void rs6000_emit_eh_reg_restore (rtx, rtx);"}, {"sha": "6399cab0d3159fd31c7fc6250c46836ef9f3dc3b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 47, "deletions": 52, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2268453b5c0f425924156a445d1f1c178f821cb0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2268453b5c0f425924156a445d1f1c178f821cb0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2268453b5c0f425924156a445d1f1c178f821cb0", "patch": "@@ -18916,42 +18916,6 @@ rs6000_aix_asm_output_dwarf_table_ref (char * frame_table_label)\n   fprintf (asm_out_file, \"\\t.ref %s\\n\",\n \t   TARGET_STRIP_NAME_ENCODING (frame_table_label));\n }\n-\n-/* If _Unwind_* has been called from within the same module,\n-   toc register is not guaranteed to be saved to 40(1) on function\n-   entry.  Save it there in that case.  */\n-\n-void\n-rs6000_aix_emit_builtin_unwind_init (void)\n-{\n-  rtx mem;\n-  rtx stack_top = gen_reg_rtx (Pmode);\n-  rtx opcode_addr = gen_reg_rtx (Pmode);\n-  rtx opcode = gen_reg_rtx (SImode);\n-  rtx tocompare = gen_reg_rtx (SImode);\n-  rtx no_toc_save_needed = gen_label_rtx ();\n-\n-  mem = gen_frame_mem (Pmode, hard_frame_pointer_rtx);\n-  emit_move_insn (stack_top, mem);\n-\n-  mem = gen_frame_mem (Pmode,\n-\t\t       gen_rtx_PLUS (Pmode, stack_top,\n-\t\t\t\t     GEN_INT (2 * GET_MODE_SIZE (Pmode))));\n-  emit_move_insn (opcode_addr, mem);\n-  emit_move_insn (opcode, gen_rtx_MEM (SImode, opcode_addr));\n-  emit_move_insn (tocompare, gen_int_mode (TARGET_32BIT ? 0x80410014\n-\t\t\t\t\t   : 0xE8410028, SImode));\n-\n-  do_compare_rtx_and_jump (opcode, tocompare, EQ, 1,\n-\t\t\t   SImode, NULL_RTX, NULL_RTX,\n-\t\t\t   no_toc_save_needed, -1);\n-\n-  mem = gen_frame_mem (Pmode,\n-\t\t       gen_rtx_PLUS (Pmode, stack_top,\n-\t\t\t\t     GEN_INT (5 * GET_MODE_SIZE (Pmode))));\n-  emit_move_insn (mem, gen_rtx_REG (Pmode, 2));\n-  emit_label (no_toc_save_needed);\n-}\n \f\n /* This ties together stack memory (MEM with an alias set of frame_alias_set)\n    and the change to the stack pointer.  */\n@@ -20237,22 +20201,6 @@ rs6000_emit_prologue (void)\n     {\n       unsigned int i, regno;\n \n-      /* In AIX ABI we need to pretend we save r2 here.  */\n-      if (TARGET_AIX)\n-\t{\n-\t  rtx addr, reg, mem;\n-\n-\t  reg = gen_rtx_REG (reg_mode, 2);\n-\t  addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t       GEN_INT (sp_offset + 5 * reg_size));\n-\t  mem = gen_frame_mem (reg_mode, addr);\n-\n-\t  insn = emit_move_insn (mem, reg);\n-\t  rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n-\t\t\t\tNULL_RTX, NULL_RTX);\n-\t  PATTERN (insn) = gen_blockage ();\n-\t}\n-\n       for (i = 0; ; ++i)\n \t{\n \t  regno = EH_RETURN_DATA_REGNO (i);\n@@ -20266,6 +20214,53 @@ rs6000_emit_prologue (void)\n \t}\n     }\n \n+  /* In AIX ABI we need to make sure r2 is really saved.  */\n+  if (TARGET_AIX && crtl->calls_eh_return)\n+    {\n+      rtx tmp_reg, tmp_reg_si, compare_result, toc_save_done, jump;\n+      long toc_restore_insn;\n+\n+      gcc_assert (frame_reg_rtx == frame_ptr_rtx\n+\t\t  || frame_reg_rtx == sp_reg_rtx);\n+      tmp_reg = gen_rtx_REG (Pmode, 11);\n+      tmp_reg_si = gen_rtx_REG (SImode, 11);\n+      if (using_static_chain_p)\n+\temit_move_insn (gen_rtx_REG (Pmode, 0), tmp_reg);\n+      gcc_assert (saving_GPRs_inline && saving_FPRs_inline);\n+      emit_move_insn (tmp_reg, gen_rtx_REG (Pmode, LR_REGNO));\n+      /* Peek at instruction to which this function returns.  If it's\n+\t restoring r2, then we know we've already saved r2.  We can't\n+\t unconditionally save r2 because the value we have will already\n+\t be updated if we arrived at this function via a plt call or\n+\t toc adjusting stub.  */\n+      emit_move_insn (tmp_reg_si, gen_rtx_MEM (SImode, tmp_reg));\n+      toc_restore_insn = ((TARGET_32BIT ? 0x80410014 : 0xE8410028)\n+\t\t\t  ^ 0x80000000) - 0x80000000;\n+      emit_insn (gen_xorsi3 (tmp_reg_si, tmp_reg_si,\n+\t\t\t     GEN_INT (toc_restore_insn & ~0xffff)));\n+      compare_result = gen_rtx_REG (CCUNSmode, CR0_REGNO);\n+      validate_condition_mode (EQ, CCUNSmode);\n+      emit_insn (gen_rtx_SET (VOIDmode, compare_result,\n+\t\t\t      gen_rtx_COMPARE (CCUNSmode, tmp_reg_si,\n+\t\t\t\t\t       GEN_INT (toc_restore_insn\n+\t\t\t\t\t\t\t& 0xffff))));\n+      toc_save_done = gen_label_rtx ();\n+      jump = gen_rtx_IF_THEN_ELSE (VOIDmode,\n+\t\t\t\t   gen_rtx_EQ (VOIDmode, compare_result,\n+\t\t\t\t\t       const0_rtx),\n+\t\t\t\t   gen_rtx_LABEL_REF (VOIDmode, toc_save_done),\n+\t\t\t\t   pc_rtx);\n+      jump = emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, jump));\n+      JUMP_LABEL (jump) = toc_save_done;\n+      LABEL_NUSES (toc_save_done) += 1;\n+\n+      emit_frame_save (frame_reg_rtx, frame_ptr_rtx, reg_mode, 2,\n+\t\t       sp_offset + 5 * reg_size, info->total_size);\n+      emit_label (toc_save_done);\n+      if (using_static_chain_p)\n+\temit_move_insn (tmp_reg, gen_rtx_REG (Pmode, 0));\n+    }\n+\n   /* Save CR if we use any that must be preserved.  */\n   if (!WORLD_SAVE_P (info) && info->cr_save_p)\n     {"}]}