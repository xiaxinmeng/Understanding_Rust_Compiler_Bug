{"sha": "62e882937cf07a66f220adbb9ea1ae171db55ad5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJlODgyOTM3Y2YwN2E2NmYyMjBhZGJiOWVhMWFlMTcxZGI1NWFkNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-01-19T19:49:33Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-01-19T19:49:33Z"}, "message": "alpha.c (aligned_memory_operand): Check MEM_ALIGN, don't check memory mode.\n\n        * config/alpha/alpha.c (aligned_memory_operand): Check MEM_ALIGN,\n        don't check memory mode.\n        (unaligned_memory_operand): Likewise.\n        (reload_inqi, reload_inhi, reload_outqi, reload_outhi): Don't\n        abort for op0 not MEM.\n\n        * config/alpha/alpha.c (alpha_expand_mov_nobwx): If the destination\n        is not a reg, copy to a scratch first.\n        (aligned_loadqi, aligned_loadhi, unaligned_loadqi, unaligned_loadhi,\n        unaligned_loadqi_le, unaligned_loadqi_be, unaligned_loadhi_le,\n        unaligned_loadhi_be): Expect op0 in DImode; don't SUBREG.\n        (reload_inqi, reload_inhi): Fix mode of op0.\n        (reload_inqi_help, reload_inhi_help, reload_outqi_help,\n        reload_outhi_help): Likewise.  Use define_insn_and_split.\n\n        * config/alpha/alpha.md (call peepholes): Check for REG_NORETURN\n        as well as $29 dead.\n\nFrom-SVN: r76172", "tree": {"sha": "b4349017c9bfe6ec1c0882bc0397d55a345cac9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4349017c9bfe6ec1c0882bc0397d55a345cac9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62e882937cf07a66f220adbb9ea1ae171db55ad5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e882937cf07a66f220adbb9ea1ae171db55ad5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62e882937cf07a66f220adbb9ea1ae171db55ad5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e882937cf07a66f220adbb9ea1ae171db55ad5/comments", "author": null, "committer": null, "parents": [{"sha": "c9a5b6246037d733736f5faad02dd698175a885e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9a5b6246037d733736f5faad02dd698175a885e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9a5b6246037d733736f5faad02dd698175a885e"}], "stats": {"total": 187, "additions": 101, "deletions": 86}, "files": [{"sha": "4de9dac9f1619aa863accc9ed4c9f417abe0f987", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e882937cf07a66f220adbb9ea1ae171db55ad5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e882937cf07a66f220adbb9ea1ae171db55ad5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62e882937cf07a66f220adbb9ea1ae171db55ad5", "patch": "@@ -1,3 +1,23 @@\n+2004-01-19  Richard Henderson  <rth@redhat.com>\n+\n+        * config/alpha/alpha.c (aligned_memory_operand): Check MEM_ALIGN,\n+        don't check memory mode.\n+        (unaligned_memory_operand): Likewise.\n+        (reload_inqi, reload_inhi, reload_outqi, reload_outhi): Don't\n+        abort for op0 not MEM.\n+\n+        * config/alpha/alpha.c (alpha_expand_mov_nobwx): If the destination\n+        is not a reg, copy to a scratch first.\n+        (aligned_loadqi, aligned_loadhi, unaligned_loadqi, unaligned_loadhi,\n+        unaligned_loadqi_le, unaligned_loadqi_be, unaligned_loadhi_le,\n+        unaligned_loadhi_be): Expect op0 in DImode; don't SUBREG.\n+        (reload_inqi, reload_inhi): Fix mode of op0.\n+        (reload_inqi_help, reload_inhi_help, reload_outqi_help,\n+        reload_outhi_help): Likewise.  Use define_insn_and_split.\n+\n+        * config/alpha/alpha.md (call peepholes): Check for REG_NORETURN\n+        as well as $29 dead.\n+\n 2004-01-19  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* config/sparc/sol2.h (ASM_DECLARE_OBJECT_NAME): New.  Emit"}, {"sha": "f6485a0bdfbcc22bf776ca6250562d42576d4979", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 37, "deletions": 12, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e882937cf07a66f220adbb9ea1ae171db55ad5/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e882937cf07a66f220adbb9ea1ae171db55ad5/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=62e882937cf07a66f220adbb9ea1ae171db55ad5", "patch": "@@ -1219,9 +1219,10 @@ aligned_memory_operand (rtx op, enum machine_mode mode)\n \t}\n     }\n \n-  if (GET_CODE (op) != MEM\n-      || GET_MODE (op) != mode)\n+  if (GET_CODE (op) != MEM)\n     return 0;\n+  if (MEM_ALIGN (op) >= 32)\n+    return 1;\n   op = XEXP (op, 0);\n \n   /* LEGITIMIZE_RELOAD_ADDRESS creates (plus (plus reg const_hi) const_lo)\n@@ -1261,8 +1262,9 @@ unaligned_memory_operand (rtx op, enum machine_mode mode)\n \t}\n     }\n \n-  if (GET_CODE (op) != MEM\n-      || GET_MODE (op) != mode)\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+  if (MEM_ALIGN (op) >= 32)\n     return 0;\n   op = XEXP (op, 0);\n \n@@ -2876,13 +2878,24 @@ alpha_expand_mov_nobwx (enum machine_mode mode, rtx *operands)\n \t    {\n \t      rtx aligned_mem, bitnum;\n \t      rtx scratch = gen_reg_rtx (SImode);\n+\t      rtx subtarget;\n+\t      bool copyout;\n \n \t      get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n \n+\t      subtarget = operands[0];\n+\t      if (GET_CODE (subtarget) == REG)\n+\t\tsubtarget = gen_lowpart (DImode, subtarget), copyout = false;\n+\t      else\n+\t\tsubtarget = gen_reg_rtx (DImode), copyout = true;\n+\n \t      emit_insn ((mode == QImode\n \t\t\t  ? gen_aligned_loadqi\n \t\t\t  : gen_aligned_loadhi)\n-\t\t\t (operands[0], aligned_mem, bitnum, scratch));\n+\t\t\t (subtarget, aligned_mem, bitnum, scratch));\n+\n+\t      if (copyout)\n+\t\temit_move_insn (operands[0], gen_lowpart (mode, subtarget));\n \t    }\n \t}\n       else\n@@ -2891,16 +2904,28 @@ alpha_expand_mov_nobwx (enum machine_mode mode, rtx *operands)\n \t     code depend on parameter evaluation order which will cause\n \t     bootstrap failures.  */\n \n-\t  rtx temp1 = gen_reg_rtx (DImode);\n-\t  rtx temp2 = gen_reg_rtx (DImode);\n-\t  rtx seq = ((mode == QImode\n-\t\t      ? gen_unaligned_loadqi\n-\t\t      : gen_unaligned_loadhi)\n-\t\t     (operands[0], get_unaligned_address (operands[1], 0),\n-\t\t      temp1, temp2));\n+\t  rtx temp1, temp2, seq, subtarget;\n+\t  bool copyout;\n+\n+\t  temp1 = gen_reg_rtx (DImode);\n+\t  temp2 = gen_reg_rtx (DImode);\n \n+\t  subtarget = operands[0];\n+\t  if (GET_CODE (subtarget) == REG)\n+\t    subtarget = gen_lowpart (DImode, subtarget), copyout = false;\n+\t  else\n+\t    subtarget = gen_reg_rtx (DImode), copyout = true;\n+\n+\t  seq = ((mode == QImode\n+\t\t  ? gen_unaligned_loadqi\n+\t\t  : gen_unaligned_loadhi)\n+\t\t (subtarget, get_unaligned_address (operands[1], 0),\n+\t\t  temp1, temp2));\n \t  alpha_set_memflags (seq, operands[1]);\n \t  emit_insn (seq);\n+\n+\t  if (copyout)\n+\t    emit_move_insn (operands[0], gen_lowpart (mode, subtarget));\n \t}\n       return true;\n     }"}, {"sha": "27eca2495c53b55f7dac9d52ba45851fbb71714f", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 44, "deletions": 74, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e882937cf07a66f220adbb9ea1ae171db55ad5/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e882937cf07a66f220adbb9ea1ae171db55ad5/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=62e882937cf07a66f220adbb9ea1ae171db55ad5", "patch": "@@ -4718,7 +4718,8 @@\n \t      (clobber (reg:DI 26))])]\n   \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF && reload_completed\n    && ! samegp_function_operand (operands[0], Pmode)\n-   && peep2_regno_dead_p (1, 29)\"\n+   && (peep2_regno_dead_p (1, 29)\n+       || find_reg_note (insn, REG_NORETURN, NULL_RTX))\"\n   [(parallel [(call (mem:DI (match_dup 2))\n \t\t    (match_dup 1))\n \t      (set (reg:DI 26) (plus:DI (pc) (const_int 4)))\n@@ -4748,7 +4749,8 @@\n \t      (clobber (reg:DI 26))])]\n   \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF && reload_completed\n    && ! samegp_function_operand (operands[0], Pmode)\n-   && ! peep2_regno_dead_p (1, 29)\"\n+   && ! (peep2_regno_dead_p (1, 29)\n+         || find_reg_note (insn, REG_NORETURN, NULL_RTX))\"\n   [(parallel [(call (mem:DI (match_dup 2))\n \t\t    (match_dup 1))\n \t      (set (reg:DI 26) (plus:DI (pc) (const_int 4)))\n@@ -5708,7 +5710,7 @@\n (define_expand \"aligned_loadqi\"\n   [(set (match_operand:SI 3 \"register_operand\" \"\")\n \t(match_operand:SI 1 \"memory_operand\" \"\"))\n-   (set (subreg:DI (match_operand:QI 0 \"register_operand\" \"\") 0)\n+   (set (match_operand:DI 0 \"register_operand\" \"\")\n \t(zero_extract:DI (subreg:DI (match_dup 3) 0)\n \t\t\t (const_int 8)\n \t\t\t (match_operand:DI 2 \"const_int_operand\" \"\")))]\n@@ -5719,7 +5721,7 @@\n (define_expand \"aligned_loadhi\"\n   [(set (match_operand:SI 3 \"register_operand\" \"\")\n \t(match_operand:SI 1 \"memory_operand\" \"\"))\n-   (set (subreg:DI (match_operand:HI 0 \"register_operand\" \"\") 0)\n+   (set (match_operand:DI 0 \"register_operand\" \"\")\n \t(zero_extract:DI (subreg:DI (match_dup 3) 0)\n \t\t\t (const_int 16)\n \t\t\t (match_operand:DI 2 \"const_int_operand\" \"\")))]\n@@ -5735,7 +5737,7 @@\n ;; operand 3 can overlap the input and output registers.\n \n (define_expand \"unaligned_loadqi\"\n-  [(use (match_operand:QI 0 \"register_operand\" \"\"))\n+  [(use (match_operand:DI 0 \"register_operand\" \"\"))\n    (use (match_operand:DI 1 \"address_operand\" \"\"))\n    (use (match_operand:DI 2 \"register_operand\" \"\"))\n    (use (match_operand:DI 3 \"register_operand\" \"\"))]\n@@ -5756,7 +5758,7 @@\n \t\t\t(const_int -8))))\n    (set (match_operand:DI 3 \"register_operand\" \"\")\n \t(match_dup 1))\n-   (set (subreg:DI (match_operand:QI 0 \"register_operand\" \"\") 0)\n+   (set (match_operand:DI 0 \"register_operand\" \"\")\n \t(zero_extract:DI (match_dup 2)\n \t\t\t (const_int 8)\n \t\t\t (ashift:DI (match_dup 3) (const_int 3))))]\n@@ -5769,7 +5771,7 @@\n \t\t\t(const_int -8))))\n    (set (match_operand:DI 3 \"register_operand\" \"\")\n \t(match_dup 1))\n-   (set (subreg:DI (match_operand:QI 0 \"register_operand\" \"\") 0)\n+   (set (match_operand:DI 0 \"register_operand\" \"\")\n \t(zero_extract:DI (match_dup 2)\n \t\t\t (const_int 8)\n \t\t\t (minus:DI\n@@ -5779,7 +5781,7 @@\n   \"\")\n \n (define_expand \"unaligned_loadhi\"\n-  [(use (match_operand:QI 0 \"register_operand\" \"\"))\n+  [(use (match_operand:DI 0 \"register_operand\" \"\"))\n    (use (match_operand:DI 1 \"address_operand\" \"\"))\n    (use (match_operand:DI 2 \"register_operand\" \"\"))\n    (use (match_operand:DI 3 \"register_operand\" \"\"))]\n@@ -5800,7 +5802,7 @@\n \t\t\t(const_int -8))))\n    (set (match_operand:DI 3 \"register_operand\" \"\")\n \t(match_dup 1))\n-   (set (subreg:DI (match_operand:QI 0 \"register_operand\" \"\") 0)\n+   (set (match_operand:DI 0 \"register_operand\" \"\")\n \t(zero_extract:DI (match_dup 2)\n \t\t\t (const_int 16)\n \t\t\t (ashift:DI (match_dup 3) (const_int 3))))]\n@@ -5813,7 +5815,7 @@\n \t\t\t(const_int -8))))\n    (set (match_operand:DI 3 \"register_operand\" \"\")\n \t(plus:DI (match_dup 1) (const_int 1)))\n-   (set (subreg:DI (match_operand:QI 0 \"register_operand\" \"\") 0)\n+   (set (match_operand:DI 0 \"register_operand\" \"\")\n \t(zero_extract:DI (match_dup 2)\n \t\t\t (const_int 16)\n \t\t\t (minus:DI\n@@ -6008,9 +6010,6 @@\n {\n   rtx scratch, seq;\n \n-  if (GET_CODE (operands[1]) != MEM)\n-    abort ();\n-\n   if (aligned_memory_operand (operands[1], QImode))\n     {\n       seq = gen_reload_inqi_help (operands[0], operands[1],\n@@ -6029,8 +6028,8 @@\n \tscratch = gen_rtx_REG (DImode, REGNO (operands[2]));\n \n       addr = get_unaligned_address (operands[1], 0);\n-      seq = gen_unaligned_loadqi (operands[0], addr, scratch,\n-\t\t\t  gen_rtx_REG (DImode, REGNO (operands[0])));\n+      operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n+      seq = gen_unaligned_loadqi (operands[0], addr, scratch, operands[0]);\n       alpha_set_memflags (seq, operands[1]);\n     }\n   emit_insn (seq);\n@@ -6045,9 +6044,6 @@\n {\n   rtx scratch, seq;\n \n-  if (GET_CODE (operands[1]) != MEM)\n-    abort ();\n-\n   if (aligned_memory_operand (operands[1], HImode))\n     {\n       seq = gen_reload_inhi_help (operands[0], operands[1],\n@@ -6066,8 +6062,8 @@\n \tscratch = gen_rtx_REG (DImode, REGNO (operands[2]));\n \n       addr = get_unaligned_address (operands[1], 0);\n-      seq = gen_unaligned_loadhi (operands[0], addr, scratch,\n-\t\t\t  gen_rtx_REG (DImode, REGNO (operands[0])));\n+      operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n+      seq = gen_unaligned_loadhi (operands[0], addr, scratch, operands[0]);\n       alpha_set_memflags (seq, operands[1]);\n     }\n   emit_insn (seq);\n@@ -6080,9 +6076,6 @@\n \t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n   \"! TARGET_BWX\"\n {\n-  if (GET_CODE (operands[0]) != MEM)\n-    abort ();\n-\n   if (aligned_memory_operand (operands[0], QImode))\n     {\n       emit_insn (gen_reload_outqi_help\n@@ -6115,9 +6108,6 @@\n \t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n   \"! TARGET_BWX\"\n {\n-  if (GET_CODE (operands[0]) != MEM)\n-    abort ();\n-\n   if (aligned_memory_operand (operands[0], HImode))\n     {\n       emit_insn (gen_reload_outhi_help\n@@ -6148,71 +6138,47 @@\n ;; always get a proper address for a stack slot during reload_foo\n ;; expansion, so we must delay our address manipulations until after.\n \n-(define_insn \"reload_inqi_help\"\n+(define_insn_and_split \"reload_inqi_help\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n         (match_operand:QI 1 \"memory_operand\" \"m\"))\n    (clobber (match_operand:SI 2 \"register_operand\" \"=r\"))]\n   \"! TARGET_BWX && (reload_in_progress || reload_completed)\"\n-  \"#\")\n-\n-(define_insn \"reload_inhi_help\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (match_operand:HI 1 \"memory_operand\" \"m\"))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"=r\"))]\n-  \"! TARGET_BWX && (reload_in_progress || reload_completed)\"\n-  \"#\")\n-\n-(define_insn \"reload_outqi_help\"\n-  [(set (match_operand:QI 0 \"memory_operand\" \"=m\")\n-        (match_operand:QI 1 \"register_operand\" \"r\"))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"=r\"))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=r\"))]\n-  \"! TARGET_BWX && (reload_in_progress || reload_completed)\"\n-  \"#\")\n-\n-(define_insn \"reload_outhi_help\"\n-  [(set (match_operand:HI 0 \"memory_operand\" \"=m\")\n-        (match_operand:HI 1 \"register_operand\" \"r\"))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"=r\"))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=r\"))]\n-  \"! TARGET_BWX && (reload_in_progress || reload_completed)\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-        (match_operand:QI 1 \"memory_operand\" \"\"))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"\"))]\n+  \"#\"\n   \"! TARGET_BWX && reload_completed\"\n   [(const_int 0)]\n {\n   rtx aligned_mem, bitnum;\n   get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n-\n+  operands[0] = gen_lowpart (DImode, operands[0]);\n   emit_insn (gen_aligned_loadqi (operands[0], aligned_mem, bitnum,\n \t\t\t\t operands[2]));\n   DONE;\n })\n \n-(define_split\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-        (match_operand:HI 1 \"memory_operand\" \"\"))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"\"))]\n+(define_insn_and_split \"reload_inhi_help\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (match_operand:HI 1 \"memory_operand\" \"m\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=r\"))]\n+  \"! TARGET_BWX && (reload_in_progress || reload_completed)\"\n+  \"#\"\n   \"! TARGET_BWX && reload_completed\"\n   [(const_int 0)]\n {\n   rtx aligned_mem, bitnum;\n   get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n-\n+  operands[0] = gen_lowpart (DImode, operands[0]);\n   emit_insn (gen_aligned_loadhi (operands[0], aligned_mem, bitnum,\n \t\t\t\t operands[2]));\n   DONE;\n })\n \n-(define_split\n-  [(set (match_operand:QI 0 \"memory_operand\" \"\")\n-        (match_operand:QI 1 \"register_operand\" \"\"))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"\"))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n+(define_insn_and_split \"reload_outqi_help\"\n+  [(set (match_operand:QI 0 \"memory_operand\" \"=m\")\n+        (match_operand:QI 1 \"register_operand\" \"r\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=r\"))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"=r\"))]\n+  \"! TARGET_BWX && (reload_in_progress || reload_completed)\"\n+  \"#\"\n   \"! TARGET_BWX && reload_completed\"\n   [(const_int 0)]\n {\n@@ -6223,11 +6189,13 @@\n   DONE;\n })\n \n-(define_split\n-  [(set (match_operand:HI 0 \"memory_operand\" \"\")\n-        (match_operand:HI 1 \"register_operand\" \"\"))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"\"))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n+(define_insn_and_split \"reload_outhi_help\"\n+  [(set (match_operand:HI 0 \"memory_operand\" \"=m\")\n+        (match_operand:HI 1 \"register_operand\" \"r\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=r\"))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"=r\"))]\n+  \"! TARGET_BWX && (reload_in_progress || reload_completed)\"\n+  \"#\"\n   \"! TARGET_BWX && reload_completed\"\n   [(const_int 0)]\n {\n@@ -7895,7 +7863,8 @@\n \t      (clobber (reg:DI 26))])]\n   \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF && reload_completed\n    && ! samegp_function_operand (operands[1], Pmode)\n-   && peep2_regno_dead_p (1, 29)\"\n+   && (peep2_regno_dead_p (1, 29)\n+       || find_reg_note (insn, REG_NORETURN, NULL_RTX))\"\n   [(parallel [(set (match_dup 0)\n \t\t   (call (mem:DI (match_dup 3))\n \t\t\t (match_dup 2)))\n@@ -7927,7 +7896,8 @@\n \t      (clobber (reg:DI 26))])]\n   \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF && reload_completed\n    && ! samegp_function_operand (operands[1], Pmode)\n-   && ! peep2_regno_dead_p (1, 29)\"\n+   && ! (peep2_regno_dead_p (1, 29)\n+         || find_reg_note (insn, REG_NORETURN, NULL_RTX))\"\n   [(parallel [(set (match_dup 0)\n \t\t   (call (mem:DI (match_dup 3))\n \t\t\t (match_dup 2)))"}]}