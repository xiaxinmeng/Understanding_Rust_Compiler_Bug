{"sha": "54ff41b717adbdea60052aaf1ae686b518acbffb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRmZjQxYjcxN2FkYmRlYTYwMDUyYWFmMWFlNjg2YjUxOGFjYmZmYg==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "1999-04-18T13:09:37Z"}, "committer": {"name": "John Wehle", "email": "wehle@gcc.gnu.org", "date": "1999-04-18T13:09:37Z"}, "message": "output.h (current_function_is_leaf, [...]): Declare.\n\n\t* output.h (current_function_is_leaf,\n\tcurrent_function_uses_only_leaf_regs): Declare.\n\t* function.c (current_function_is_leaf,\n\tcurrent_function_uses_only_leaf_regs): Define.\n\t(init_function_start): Initialize current_function_is_leaf\n\tand current_function_uses_only_leaf_regs.\n\t* final.c (leaf_function): Don't define.\n\t(final_start_function): Replace uses of leaf_function with\n\tcurrent_function_uses_only_leaf_regs.\n\t* toplev.c (rest_of_compilation): Set current_function_is_leaf\n\tprior to invoking local register allocation.\n\t(rest_of_compilation): Replace uses of leaf_function with\n\tcurrent_function_uses_only_leaf_regs.\n\t* dbxout.c (dbxout_symbol, dbxout_parms): Likewise.\n\t* dwarf2out.c (add_location_or_const_vaule_attribute): Likewise.\n\t* dwarfout.c (add_location_or_const_value_attribute): Likewise.\n\t* sdbout.c (sdbout_symbol): Likewise.\n\t* sparc.h (FUNCTION_PROLOGUE, FUNCTION_EPILOGUE): Likewise.\n\t* sparc.c (eligible_for_epilogue_delay, output_return,\n\tsparc_return_peephole_ok): Likewise.\n\t* sparc.md (leaf_function attribute, untyped_return): Likewise.\n\t* i386.c (ix86_compute_frame_size): Don't align the stack\n\tfor leaf functions which don't allocate any stack slots.\n\t* tm.texi: Update documentation.\n\nFrom-SVN: r26538", "tree": {"sha": "266e9b6a151a15a5ac1a49e1ec8038fde7907520", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/266e9b6a151a15a5ac1a49e1ec8038fde7907520"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54ff41b717adbdea60052aaf1ae686b518acbffb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54ff41b717adbdea60052aaf1ae686b518acbffb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54ff41b717adbdea60052aaf1ae686b518acbffb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54ff41b717adbdea60052aaf1ae686b518acbffb/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fbdd0024110fbdc960e21862e5df7bd2e508afc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbdd0024110fbdc960e21862e5df7bd2e508afc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbdd0024110fbdc960e21862e5df7bd2e508afc9"}], "stats": {"total": 126, "additions": 96, "deletions": 30}, "files": [{"sha": "37cb3f08a9e55c7ad53e4067d57ee8bcf55ca611", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=54ff41b717adbdea60052aaf1ae686b518acbffb", "patch": "@@ -1,3 +1,30 @@\n+Sun Apr 18 15:50:33 EDT 1999  John Wehle  (john@feith.com)\n+\n+\t* output.h (current_function_is_leaf,\n+\tcurrent_function_uses_only_leaf_regs): Declare.\n+\t* function.c (current_function_is_leaf,\n+\tcurrent_function_uses_only_leaf_regs): Define.\n+\t(init_function_start): Initialize current_function_is_leaf\n+\tand current_function_uses_only_leaf_regs.\n+\t* final.c (leaf_function): Don't define.\n+\t(final_start_function): Replace uses of leaf_function with\n+\tcurrent_function_uses_only_leaf_regs.\n+\t* toplev.c (rest_of_compilation): Set current_function_is_leaf\n+\tprior to invoking local register allocation.\n+\t(rest_of_compilation): Replace uses of leaf_function with\n+\tcurrent_function_uses_only_leaf_regs.\n+\t* dbxout.c (dbxout_symbol, dbxout_parms): Likewise.\n+\t* dwarf2out.c (add_location_or_const_vaule_attribute): Likewise.\n+\t* dwarfout.c (add_location_or_const_value_attribute): Likewise.\n+\t* sdbout.c (sdbout_symbol): Likewise.\n+\t* sparc.h (FUNCTION_PROLOGUE, FUNCTION_EPILOGUE): Likewise.\n+\t* sparc.c (eligible_for_epilogue_delay, output_return,\n+\tsparc_return_peephole_ok): Likewise.\n+\t* sparc.md (leaf_function attribute, untyped_return): Likewise.\n+\t* i386.c (ix86_compute_frame_size): Don't align the stack\n+\tfor leaf functions which don't allocate any stack slots.\n+\t* tm.texi: Update documentation.\n+\n Sun Apr 18 02:15:09 PDT 1999 Jeff Law  (law@cygnus.com)\n \n \t* version.c: Bump for snapshot.\n@@ -1150,7 +1177,7 @@ Fri Apr  2 14:12:06 1999  John Wehle  (john@feith.com)\n \t* i386.md: Delete floating point compare, add, subtract,\n \tmultiply, and divide patterns which allowed integer\n \toperands.\n-\t* i386.c (output_386_binary_op): Delete unused code.\n+\t* i386.c (output_387_binary_op): Delete unused code.\n \t(output_float_compare): Likewise.\n \n Fri Apr  2 11:53:37 1999  John Wehle  (john@feith.com)"}, {"sha": "4faff7b9d14f114d41299990790caed03e1fe7ec", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=54ff41b717adbdea60052aaf1ae686b518acbffb", "patch": "@@ -1990,6 +1990,11 @@ ix86_compute_frame_size (size, nregs_on_stack)\n     if (padding < (((offset + preferred_alignment - 1)\n \t\t    & -preferred_alignment) - offset))\n       padding += preferred_alignment;\n+\n+    /* Don't bother aligning the stack of a leaf function\n+       which doesn't allocate any stack slots.  */\n+    if (size == 0 && current_function_is_leaf)\n+      padding = 0;\n   }\n #endif\n "}, {"sha": "49502422031d07a9ed3476144135f48792e7e112", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=54ff41b717adbdea60052aaf1ae686b518acbffb", "patch": "@@ -2230,7 +2230,7 @@ eligible_for_epilogue_delay (trial, slot)\n   /* In the case of a true leaf function, anything can go into the delay slot.\n      A delay slot only exists however if the frame size is zero, otherwise\n      we will put an insn to adjust the stack after the return.  */\n-  if (leaf_function)\n+  if (current_function_uses_only_leaf_regs)\n     {\n       if (leaf_return_peephole_ok ())\n \treturn ((get_attr_in_uncond_branch_delay (trial)\n@@ -4686,7 +4686,7 @@ output_return (operands)\n       operands[0] = leaf_label;\n       return \"b%* %l0%(\";\n     }\n-  else if (leaf_function)\n+  else if (current_function_uses_only_leaf_regs)\n     {\n       /* No delay slot in a leaf function.  */\n       if (delay)\n@@ -7524,7 +7524,7 @@ sparc_return_peephole_ok (dest, src)\n {\n   if (! TARGET_V9)\n     return 0;\n-  if (leaf_function)\n+  if (current_function_uses_only_leaf_regs)\n     return 0;\n   if (GET_CODE (src) != CONST_INT\n       && (GET_CODE (src) != REG || ! IN_OR_GLOBAL_P (src)))"}, {"sha": "a220ce741f8de97e2a10e7e3c70d12bee93b6c18", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=54ff41b717adbdea60052aaf1ae686b518acbffb", "patch": "@@ -1838,10 +1838,10 @@ do {\t\t\t\t\t\t\t\t\t\\\n    to do a \"save\" insn.  The decision about whether or not\n    to do this is made in regclass.c.  */\n \n-extern int leaf_function;\n #define FUNCTION_PROLOGUE(FILE, SIZE) \\\n   (TARGET_FLAT ? sparc_flat_output_function_prologue (FILE, (int)SIZE) \\\n-   : output_function_prologue (FILE, (int)SIZE, leaf_function))\n+   : output_function_prologue (FILE, (int)SIZE, \\\n+\t\t\t       current_function_uses_only_leaf_regs))\n \f\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.\n@@ -2216,7 +2216,8 @@ extern union tree_node *current_function_decl;\n \n #define FUNCTION_EPILOGUE(FILE, SIZE) \\\n   (TARGET_FLAT ? sparc_flat_output_function_epilogue (FILE, (int)SIZE) \\\n-   : output_function_epilogue (FILE, (int)SIZE, leaf_function))\n+   : output_function_epilogue (FILE, (int)SIZE, \\\n+\t\t\t       current_function_uses_only_leaf_regs))\n \n #define DELAY_SLOTS_FOR_EPILOGUE \\\n   (TARGET_FLAT ? sparc_flat_epilogue_delay_slots () : 1)"}, {"sha": "025992a354ca4bee3d55570859b418d077bac991", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=54ff41b717adbdea60052aaf1ae686b518acbffb", "patch": "@@ -159,7 +159,7 @@\n   [(eq_attr \"in_call_delay\" \"true\") (nil) (nil)])\n \n (define_attr \"leaf_function\" \"false,true\"\n-  (const (symbol_ref \"leaf_function\")))\n+  (const (symbol_ref \"current_function_uses_only_leaf_regs\")))\n \n (define_attr \"in_return_delay\" \"false,true\"\n   (if_then_else (and (and (and (eq_attr \"type\" \"move,load,sload,store,binary,ialu\")\n@@ -7618,7 +7618,8 @@\n \n   if (! TARGET_ARCH64)\n     {\n-      rtx rtnreg = gen_rtx_REG (SImode, (leaf_function ? 15 : 31));\n+      rtx rtnreg = gen_rtx_REG (SImode, (current_function_uses_only_leaf_regs\n+\t\t\t\t\t ? 15 : 31));\n       rtx value = gen_reg_rtx (SImode);\n \n       /* Fetch the instruction where we will return to and see if it's an unimp"}, {"sha": "bc15a4d5411c1ec0bf2b1a5b61d34b39f092567d", "filename": "gcc/dbxout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=54ff41b717adbdea60052aaf1ae686b518acbffb", "patch": "@@ -1937,7 +1937,7 @@ dbxout_symbol (decl, local)\n \n       DECL_RTL (decl) = eliminate_regs (DECL_RTL (decl), 0, NULL_RTX);\n #ifdef LEAF_REG_REMAP\n-      if (leaf_function)\n+      if (current_function_uses_only_leaf_regs)\n \tleaf_renumber_regs_insn (DECL_RTL (decl));\n #endif\n \n@@ -2259,7 +2259,7 @@ dbxout_parms (parms)\n \t  = eliminate_regs (DECL_INCOMING_RTL (parms), 0, NULL_RTX);\n \tDECL_RTL (parms) = eliminate_regs (DECL_RTL (parms), 0, NULL_RTX);\n #ifdef LEAF_REG_REMAP\n-\tif (leaf_function)\n+\tif (current_function_uses_only_leaf_regs)\n \t  {\n \t    leaf_renumber_regs_insn (DECL_INCOMING_RTL (parms));\n \t    leaf_renumber_regs_insn (DECL_RTL (parms));"}, {"sha": "659b119f4bdffb68e4539f1dfc30698758cdce5e", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=54ff41b717adbdea60052aaf1ae686b518acbffb", "patch": "@@ -7207,7 +7207,7 @@ add_location_or_const_value_attribute (die, decl)\n \n   rtl = eliminate_regs (rtl, 0, NULL_RTX);\n #ifdef LEAF_REG_REMAP\n-  if (leaf_function)\n+  if (current_function_uses_only_leaf_regs)\n     leaf_renumber_regs_insn (rtl);\n #endif\n "}, {"sha": "ac17f7fb196954dcb18157fab9c7407815ffc92f", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=54ff41b717adbdea60052aaf1ae686b518acbffb", "patch": "@@ -2421,7 +2421,7 @@ location_or_const_value_attribute (decl)\n \n   rtl = eliminate_regs (rtl, 0, NULL_RTX);\n #ifdef LEAF_REG_REMAP\n-  if (leaf_function)\n+  if (current_function_uses_only_leaf_regs)\n     leaf_renumber_regs_insn (rtl);\n #endif\n "}, {"sha": "bacc093224900d9535d73b2796dd12b4439d6fa4", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=54ff41b717adbdea60052aaf1ae686b518acbffb", "patch": "@@ -131,11 +131,6 @@ Boston, MA 02111-1307, USA.  */\n #define JUMP_TABLES_IN_TEXT_SECTION 0\n #endif\n \n-/* Nonzero means this function is a leaf function, with no function calls. \n-   This variable exists to be examined in FUNCTION_PROLOGUE\n-   and FUNCTION_EPILOGUE.  Always zero, unless set by some action.  */\n-int leaf_function;\n-\n /* Last insn processed by final_scan_insn.  */\n static rtx debug_insn = 0;\n \n@@ -1634,7 +1629,7 @@ final_start_function (first, file, optimize)\n \toutput_source_line (file, first);\n \n #ifdef LEAF_REG_REMAP\n-  if (leaf_function)\n+  if (current_function_uses_only_leaf_regs)\n     leaf_renumber_regs (first);\n #endif\n "}, {"sha": "30357865d73a2e0b95bcad7bca2c3299c967049e", "filename": "gcc/function.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=54ff41b717adbdea60052aaf1ae686b518acbffb", "patch": "@@ -140,12 +140,25 @@ int current_function_has_nonlocal_goto;\n \n int current_function_contains_functions;\n \n+/* Nonzero if function being compiled doesn't contain any calls\n+   (ignoring the prologue and epilogue).  This is set prior to\n+   local register allocation and is valid for the remaining\n+   compiler passes. */\n+\n+int current_function_is_leaf;\n+\n /* Nonzero if function being compiled doesn't modify the stack pointer\n    (ignoring the prologue and epilogue).  This is only valid after\n    life_analysis has run. */\n \n int current_function_sp_is_unchanging;\n \n+/* Nonzero if the function being compiled is a leaf function which only\n+   uses leaf registers.  This is valid after reload (specifically after\n+   sched2) and is useful only if the port defines LEAF_REGISTERS.  */\n+\n+int current_function_uses_only_leaf_regs;\n+\n /* Nonzero if the function being compiled issues a computed jump.  */\n \n int current_function_has_computed_jump;\n@@ -5897,7 +5910,9 @@ init_function_start (subr, filename, line)\n   current_function_has_nonlocal_label = 0;\n   current_function_has_nonlocal_goto = 0;\n   current_function_contains_functions = 0;\n+  current_function_is_leaf = 0;\n   current_function_sp_is_unchanging = 0;\n+  current_function_uses_only_leaf_regs = 0;\n   current_function_has_computed_jump = 0;\n   current_function_is_thunk = 0;\n "}, {"sha": "e1cf6d82950305060c7f43f737210f15f1272e5a", "filename": "gcc/output.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=54ff41b717adbdea60052aaf1ae686b518acbffb", "patch": "@@ -383,12 +383,25 @@ extern int current_function_has_nonlocal_label;\n \n extern int current_function_contains_functions;\n \n+/* Nonzero if function being compiled doesn't contain any calls\n+   (ignoring the prologue and epilogue).  This is set prior to\n+   local register allocation and is valid for the remaining\n+   compiler passes. */\n+\n+extern int current_function_is_leaf;\n+\n /* Nonzero if function being compiled doesn't modify the stack pointer\n    (ignoring the prologue and epilogue).  This is only valid after\n    life_analysis has run. */\n \n extern int current_function_sp_is_unchanging;\n \n+/* Nonzero if the function being compiled is a leaf function which only\n+   uses leaf registers.  This is valid after reload (specifically after\n+   sched2) and is useful only if the port defines LEAF_REGISTERS.  */\n+\n+extern int current_function_uses_only_leaf_regs;\n+\n /* Nonzero if the function being compiled issues a computed jump.  */\n \n extern int current_function_has_computed_jump;"}, {"sha": "0aebd834d23be955d9d7eb6dfd9c0def024bdd5f", "filename": "gcc/sdbout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=54ff41b717adbdea60052aaf1ae686b518acbffb", "patch": "@@ -811,7 +811,7 @@ sdbout_symbol (decl, local)\n \n       DECL_RTL (decl) = eliminate_regs (DECL_RTL (decl), 0, NULL_RTX);\n #ifdef LEAF_REG_REMAP\n-      if (leaf_function)\n+      if (current_function_uses_only_leaf_regs)\n \tleaf_renumber_regs_insn (DECL_RTL (decl));\n #endif\n       value = DECL_RTL (decl);"}, {"sha": "ac6e6beae53ed0d4eb34682e76abc8d6dd862edf", "filename": "gcc/tm.texi", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=54ff41b717adbdea60052aaf1ae686b518acbffb", "patch": "@@ -1642,12 +1642,17 @@ treatment of leaf functions, and registers need to be renumbered to do\n this.\n @end table\n \n-@findex leaf_function\n+@findex current_function_is_leaf\n+@findex current_function_uses_only_leaf_regs\n Normally, @code{FUNCTION_PROLOGUE} and @code{FUNCTION_EPILOGUE} must\n-treat leaf functions specially.  It can test the C variable\n-@code{leaf_function} which is nonzero for leaf functions.  (The variable\n-@code{leaf_function} is defined only if @code{LEAF_REGISTERS} is\n-defined.)\n+treat leaf functions specially.  They can test the C variable\n+@code{current_function_is_leaf} which is nonzero for leaf functions.\n+@code{current_function_is_leaf} is set prior to local register allocation\n+and is valid for the remaining compiler passes.  They can also test the C\n+variable @code{current_function_uses_only_leaf_regs} which is nonzero for\n+leaf functions which only use leaf registers.\n+@code{current_function_uses_only_leaf_regs} is valid after reload and is\n+only useful if @code{LEAF_REGISTERS} is defined.\n @c changed this to fix overfull.  ALSO:  why the \"it\" at the beginning\n @c of the next paragraph?!  --mew 2feb93\n \n@@ -3296,7 +3301,7 @@ argument lists of the function.  @xref{Stack Arguments}.\n \n Normally, it is necessary for the macros @code{FUNCTION_PROLOGUE} and\n @code{FUNCTION_EPILOGUE} to treat leaf functions specially.  The C\n-variable @code{leaf_function} is nonzero for such a function.\n+variable @code{current_function_is_leaf} is nonzero for such a function.\n \n @findex EXIT_IGNORE_STACK\n @item EXIT_IGNORE_STACK\n@@ -3346,8 +3351,8 @@ is wanted, the macro can refer to the variable\n a function that needs a frame pointer.\n \n Normally, @code{FUNCTION_PROLOGUE} and @code{FUNCTION_EPILOGUE} must\n-treat leaf functions specially.  The C variable @code{leaf_function} is\n-nonzero for such a function.  @xref{Leaf Functions}.\n+treat leaf functions specially.  The C variable @code{current_function_is_leaf}\n+is nonzero for such a function.  @xref{Leaf Functions}.\n \n On some machines, some functions pop their arguments on exit while\n others leave that for the caller to do.  For example, the 68020 when"}, {"sha": "7b3c31c92bdf9957a1deeb87a42f8f01b6019725", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54ff41b717adbdea60052aaf1ae686b518acbffb/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=54ff41b717adbdea60052aaf1ae686b518acbffb", "patch": "@@ -4089,6 +4089,11 @@ rest_of_compilation (decl)\n \t}\n     }\n \n+  /* Determine if the current function is a leaf before running reload\n+     since this can impact optimizations done by the prologue and\n+     epilogue thus changing register elimination offsets.  */\n+  current_function_is_leaf = leaf_function_p ();\n+\n   /* Unless we did stupid register allocation,\n      allocate pseudo-regs that are used only within 1 basic block. \n \n@@ -4235,9 +4240,8 @@ rest_of_compilation (decl)\n     }\n \n #ifdef LEAF_REGISTERS\n-  leaf_function = 0;\n   if (optimize > 0 && only_leaf_regs_used () && leaf_function_p ())\n-    leaf_function = 1;\n+    current_function_uses_only_leaf_regs = 1;\n #endif\n \n   /* One more attempt to remove jumps to .+1"}]}