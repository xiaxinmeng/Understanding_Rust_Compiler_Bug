{"sha": "7615df781226137b9cd76b47df4aea6ad9f2140e", "node_id": "C_kwDOANBUbNoAKDc2MTVkZjc4MTIyNjEzN2I5Y2Q3NmI0N2RmNGFlYTZhZDlmMjE0MGU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-16T11:38:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-16T11:38:58Z"}, "message": "Merge #836\n\n836: BugFix NodeId skew on AST::Patterns r=philberty a=philberty\n\nThe AST constructors implicitly generate new NodeId's, their associated\r\ncopy/move constructors ensure that they preserve the NodeId correctly.\r\nThe AST::Pattern's here incorrectly had a constructor in the abstract\r\nbase class which was generating the NodeId's but when this is used\r\nwithin AST::MatchArms the fields contain these patterns which can get\r\ncopied/moved to cause new NodeId's to be generated which then throws off\r\ntype checking as the NodeId changes during HIR lowering and thus each of the\r\nID's are all off by one during type checking.\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "9612ddcdf4381a28762ad694b4e233e4c3dda4e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9612ddcdf4381a28762ad694b4e233e4c3dda4e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7615df781226137b9cd76b47df4aea6ad9f2140e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhuyVTCRBK7hj4Ov3rIwAAmZQIABQZn4jXMlgqbWmIZnWtNpoc\ndUh09q5M/3J4jAzC06px1xezdFtMwTYNdNHQDWufRjOupA12Xmyip0TO4hJlWTTC\n38zGYxwqOmd1RmqyjlLSqaXuSax5iGKgObdC9RYvBzekIEYsKPR6nb4kvsXiA7Kh\nu0hvTjdtGj+BAN0wRDcUejUk4vwNObjaUDYMN7sFStpXF0VlDwYrJwub989ejpxl\nfESeax0mfGLVDx3+5Q8o6qJQVayr1ZOs2mdPtvnbLZDsArpy+04X08LPEXxPk5DG\nOASXeFIw6a+PTMkaQTNa4sSy7aKoGNw6Ux/QX7kkw9LO8doFM1Z73RZ0kTeOyP0=\n=yWCm\n-----END PGP SIGNATURE-----\n", "payload": "tree 9612ddcdf4381a28762ad694b4e233e4c3dda4e3\nparent 83a984b1a12694d8e06eb139089429b61e236fdd\nparent c81eb149048938e2e795e015b69bf601a930f799\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1639654738 +0000\ncommitter GitHub <noreply@github.com> 1639654738 +0000\n\nMerge #836\n\n836: BugFix NodeId skew on AST::Patterns r=philberty a=philberty\n\nThe AST constructors implicitly generate new NodeId's, their associated\r\ncopy/move constructors ensure that they preserve the NodeId correctly.\r\nThe AST::Pattern's here incorrectly had a constructor in the abstract\r\nbase class which was generating the NodeId's but when this is used\r\nwithin AST::MatchArms the fields contain these patterns which can get\r\ncopied/moved to cause new NodeId's to be generated which then throws off\r\ntype checking as the NodeId changes during HIR lowering and thus each of the\r\nID's are all off by one during type checking.\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7615df781226137b9cd76b47df4aea6ad9f2140e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7615df781226137b9cd76b47df4aea6ad9f2140e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7615df781226137b9cd76b47df4aea6ad9f2140e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83a984b1a12694d8e06eb139089429b61e236fdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83a984b1a12694d8e06eb139089429b61e236fdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83a984b1a12694d8e06eb139089429b61e236fdd"}, {"sha": "c81eb149048938e2e795e015b69bf601a930f799", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c81eb149048938e2e795e015b69bf601a930f799", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c81eb149048938e2e795e015b69bf601a930f799"}], "stats": {"total": 154, "additions": 113, "deletions": 41}, "files": [{"sha": "cfded356944d05e969ac7bc155b92f09498f8cba", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7615df781226137b9cd76b47df4aea6ad9f2140e/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7615df781226137b9cd76b47df4aea6ad9f2140e/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=7615df781226137b9cd76b47df4aea6ad9f2140e", "patch": "@@ -1037,24 +1037,18 @@ class Pattern\n   virtual ~Pattern () {}\n \n   virtual std::string as_string () const = 0;\n-\n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n   // as only one kind of pattern can be stripped, have default of nothing\n   virtual void mark_for_strip () {}\n   virtual bool is_marked_for_strip () const { return false; }\n \n   virtual Location get_locus () const = 0;\n-\n-  virtual NodeId get_node_id () const { return node_id; }\n+  virtual NodeId get_pattern_node_id () const = 0;\n \n protected:\n   // Clone pattern implementation as pure virtual method\n   virtual Pattern *clone_pattern_impl () const = 0;\n-\n-  Pattern () : node_id (Analysis::Mappings::get ()->get_next_node_id ()) {}\n-\n-  NodeId node_id;\n };\n \n // forward decl for Type"}, {"sha": "1fe7a46312cdfd9cecb1666de7f5b700288b0307", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7615df781226137b9cd76b47df4aea6ad9f2140e/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7615df781226137b9cd76b47df4aea6ad9f2140e/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=7615df781226137b9cd76b47df4aea6ad9f2140e", "patch": "@@ -394,6 +394,11 @@ class MacroInvocation : public TypeNoBounds,\n     outer_attrs = std::move (new_attrs);\n   }\n \n+  NodeId get_pattern_node_id () const override final\n+  {\n+    return ExprWithoutBlock::get_node_id ();\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "f4f1624c4c31e10d57201a597f412f9f457547e7", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7615df781226137b9cd76b47df4aea6ad9f2140e/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7615df781226137b9cd76b47df4aea6ad9f2140e/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=7615df781226137b9cd76b47df4aea6ad9f2140e", "patch": "@@ -380,6 +380,8 @@ class PathInExpression : public PathPattern, public PathExpr\n     outer_attrs = std::move (new_attrs);\n   }\n \n+  NodeId get_pattern_node_id () const override final { return get_node_id (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -902,6 +904,8 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n \n   NodeId get_node_id () const override { return _node_id; }\n \n+  NodeId get_pattern_node_id () const override final { return get_node_id (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "afc781bac12a0947a41f489647f010ef586136d0", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 91, "deletions": 22, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7615df781226137b9cd76b47df4aea6ad9f2140e/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7615df781226137b9cd76b47df4aea6ad9f2140e/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=7615df781226137b9cd76b47df4aea6ad9f2140e", "patch": "@@ -36,25 +36,32 @@ class LiteralPattern : public Pattern\n   // Actually, this might be a good place to use a template.\n \n   Location locus;\n+  NodeId node_id;\n \n public:\n   std::string as_string () const override;\n \n   // Constructor for a literal pattern\n   LiteralPattern (Literal lit, Location locus, bool has_minus = false)\n-    : lit (std::move (lit)), has_minus (has_minus), locus (locus)\n+    : lit (std::move (lit)), has_minus (has_minus), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   LiteralPattern (std::string val, Literal::LitType type, Location locus,\n \t\t  bool has_minus = false)\n     : lit (Literal (std::move (val), type, PrimitiveCoreType::CORETYPE_STR)),\n-      has_minus (has_minus), locus (locus)\n+      has_minus (has_minus), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   Location get_locus () const override final { return locus; }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -73,8 +80,8 @@ class IdentifierPattern : public Pattern\n \n   // bool has_pattern;\n   std::unique_ptr<Pattern> to_bind;\n-\n   Location locus;\n+  NodeId node_id;\n \n public:\n   std::string as_string () const override;\n@@ -87,26 +94,24 @@ class IdentifierPattern : public Pattern\n \t\t     bool is_mut = false,\n \t\t     std::unique_ptr<Pattern> to_bind = nullptr)\n     : Pattern (), variable_ident (std::move (ident)), is_ref (is_ref),\n-      is_mut (is_mut), to_bind (std::move (to_bind)), locus (locus)\n+      is_mut (is_mut), to_bind (std::move (to_bind)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   IdentifierPattern (NodeId node_id, Identifier ident, Location locus,\n \t\t     bool is_ref = false, bool is_mut = false,\n \t\t     std::unique_ptr<Pattern> to_bind = nullptr)\n     : Pattern (), variable_ident (std::move (ident)), is_ref (is_ref),\n-      is_mut (is_mut), to_bind (std::move (to_bind)), locus (locus)\n-  {\n-    this->node_id = node_id;\n-  }\n+      is_mut (is_mut), to_bind (std::move (to_bind)), locus (locus),\n+      node_id (node_id)\n+  {}\n \n   // Copy constructor with clone\n   IdentifierPattern (IdentifierPattern const &other)\n     : variable_ident (other.variable_ident), is_ref (other.is_ref),\n-      is_mut (other.is_mut), locus (other.locus)\n+      is_mut (other.is_mut), locus (other.locus), node_id (other.node_id)\n   {\n-    node_id = other.node_id;\n     // fix to get prevent null pointer dereference\n-\n     if (other.to_bind != nullptr)\n       to_bind = other.to_bind->clone_pattern ();\n   }\n@@ -149,6 +154,10 @@ class IdentifierPattern : public Pattern\n   bool get_is_mut () const { return is_mut; }\n   bool get_is_ref () const { return is_ref; }\n \n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -162,16 +171,23 @@ class IdentifierPattern : public Pattern\n class WildcardPattern : public Pattern\n {\n   Location locus;\n+  NodeId node_id;\n \n public:\n   std::string as_string () const override { return std::string (1, '_'); }\n \n-  WildcardPattern (Location locus) : locus (locus) {}\n+  WildcardPattern (Location locus)\n+    : locus (locus), node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n \n   Location get_locus () const override final { return locus; }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -310,6 +326,7 @@ class RangePattern : public Pattern\n   /* location only stored to avoid a dereference - lower pattern should give\n    * correct location so maybe change in future */\n   Location locus;\n+  NodeId node_id;\n \n public:\n   std::string as_string () const override;\n@@ -319,14 +336,16 @@ class RangePattern : public Pattern\n \t\tstd::unique_ptr<RangePatternBound> upper, Location locus,\n \t\tbool has_ellipsis_syntax = false)\n     : lower (std::move (lower)), upper (std::move (upper)),\n-      has_ellipsis_syntax (has_ellipsis_syntax), locus (locus)\n+      has_ellipsis_syntax (has_ellipsis_syntax), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Copy constructor with clone\n   RangePattern (RangePattern const &other)\n     : lower (other.lower->clone_range_pattern_bound ()),\n       upper (other.upper->clone_range_pattern_bound ()),\n-      has_ellipsis_syntax (other.has_ellipsis_syntax), locus (other.locus)\n+      has_ellipsis_syntax (other.has_ellipsis_syntax), locus (other.locus),\n+      node_id (other.node_id)\n   {}\n \n   // Overloaded assignment operator to clone\n@@ -336,6 +355,7 @@ class RangePattern : public Pattern\n     upper = other.upper->clone_range_pattern_bound ();\n     has_ellipsis_syntax = other.has_ellipsis_syntax;\n     locus = other.locus;\n+    node_id = other.node_id;\n \n     return *this;\n   }\n@@ -361,6 +381,10 @@ class RangePattern : public Pattern\n     return upper;\n   }\n \n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -377,20 +401,23 @@ class ReferencePattern : public Pattern\n   bool is_mut;\n   std::unique_ptr<Pattern> pattern;\n   Location locus;\n+  NodeId node_id;\n \n public:\n   std::string as_string () const override;\n \n   ReferencePattern (std::unique_ptr<Pattern> pattern, bool is_mut_reference,\n \t\t    bool ref_has_two_amps, Location locus)\n     : has_two_amps (ref_has_two_amps), is_mut (is_mut_reference),\n-      pattern (std::move (pattern)), locus (locus)\n+      pattern (std::move (pattern)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Copy constructor requires clone\n   ReferencePattern (ReferencePattern const &other)\n     : has_two_amps (other.has_two_amps), is_mut (other.is_mut),\n-      pattern (other.pattern->clone_pattern ()), locus (other.locus)\n+      pattern (other.pattern->clone_pattern ()), locus (other.locus),\n+      node_id (other.node_id)\n   {}\n \n   // Overload assignment operator to clone\n@@ -400,6 +427,7 @@ class ReferencePattern : public Pattern\n     is_mut = other.is_mut;\n     has_two_amps = other.has_two_amps;\n     locus = other.locus;\n+    node_id = other.node_id;\n \n     return *this;\n   }\n@@ -419,6 +447,10 @@ class ReferencePattern : public Pattern\n     return pattern;\n   }\n \n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -817,6 +849,7 @@ class StructPattern : public Pattern\n   StructPatternElements elems;\n \n   // TODO: should this store location data? Accessor uses path location data.\n+  NodeId node_id;\n \n public:\n   std::string as_string () const override;\n@@ -825,7 +858,8 @@ class StructPattern : public Pattern\n   StructPattern (PathInExpression struct_path,\n \t\t StructPatternElements elems\n \t\t = StructPatternElements::create_empty ())\n-    : path (std::move (struct_path)), elems (std::move (elems))\n+    : path (std::move (struct_path)), elems (std::move (elems)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   /* TODO: constructor to construct via elements included in\n@@ -849,6 +883,10 @@ class StructPattern : public Pattern\n   PathInExpression &get_path () { return path; }\n   const PathInExpression &get_path () const { return path; }\n \n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1027,6 +1065,7 @@ class TupleStructPattern : public Pattern\n {\n   PathInExpression path;\n   std::unique_ptr<TupleStructItems> items;\n+  NodeId node_id;\n \n   /* TOOD: should this store location data? current accessor uses path location\n    * data */\n@@ -1039,13 +1078,15 @@ class TupleStructPattern : public Pattern\n \n   TupleStructPattern (PathInExpression tuple_struct_path,\n \t\t      std::unique_ptr<TupleStructItems> items)\n-    : path (std::move (tuple_struct_path)), items (std::move (items))\n+    : path (std::move (tuple_struct_path)), items (std::move (items)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Copy constructor required to clone\n   TupleStructPattern (TupleStructPattern const &other) : path (other.path)\n   {\n     // guard to protect from null dereference\n+    node_id = other.node_id;\n     if (other.items != nullptr)\n       items = other.items->clone_tuple_struct_items ();\n   }\n@@ -1054,6 +1095,7 @@ class TupleStructPattern : public Pattern\n   TupleStructPattern &operator= (TupleStructPattern const &other)\n   {\n     path = other.path;\n+    node_id = other.node_id;\n \n     // guard to protect from null dereference\n     if (other.items != nullptr)\n@@ -1082,6 +1124,10 @@ class TupleStructPattern : public Pattern\n   PathInExpression &get_path () { return path; }\n   const PathInExpression &get_path () const { return path; }\n \n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1287,6 +1333,7 @@ class TuplePattern : public Pattern\n   // bool has_tuple_pattern_items;\n   std::unique_ptr<TuplePatternItems> items;\n   Location locus;\n+  NodeId node_id;\n \n public:\n   std::string as_string () const override;\n@@ -1295,13 +1342,15 @@ class TuplePattern : public Pattern\n   bool has_tuple_pattern_items () const { return items != nullptr; }\n \n   TuplePattern (std::unique_ptr<TuplePatternItems> items, Location locus)\n-    : items (std::move (items)), locus (locus)\n+    : items (std::move (items)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Copy constructor requires clone\n   TuplePattern (TuplePattern const &other) : locus (other.locus)\n   {\n     // guard to prevent null dereference\n+    node_id = other.node_id;\n     if (other.items != nullptr)\n       items = other.items->clone_tuple_pattern_items ();\n   }\n@@ -1310,6 +1359,7 @@ class TuplePattern : public Pattern\n   TuplePattern &operator= (TuplePattern const &other)\n   {\n     locus = other.locus;\n+    node_id = other.node_id;\n \n     // guard to prevent null dereference\n     if (other.items != nullptr)\n@@ -1331,6 +1381,10 @@ class TuplePattern : public Pattern\n     return items;\n   }\n \n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1345,6 +1399,7 @@ class GroupedPattern : public Pattern\n {\n   std::unique_ptr<Pattern> pattern_in_parens;\n   Location locus;\n+  NodeId node_id;\n \n public:\n   std::string as_string () const override\n@@ -1353,20 +1408,22 @@ class GroupedPattern : public Pattern\n   }\n \n   GroupedPattern (std::unique_ptr<Pattern> pattern_in_parens, Location locus)\n-    : pattern_in_parens (std::move (pattern_in_parens)), locus (locus)\n+    : pattern_in_parens (std::move (pattern_in_parens)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Copy constructor uses clone\n   GroupedPattern (GroupedPattern const &other)\n     : pattern_in_parens (other.pattern_in_parens->clone_pattern ()),\n-      locus (other.locus)\n+      locus (other.locus), node_id (other.node_id)\n   {}\n \n   // Overload assignment operator to clone\n   GroupedPattern &operator= (GroupedPattern const &other)\n   {\n     pattern_in_parens = other.pattern_in_parens->clone_pattern ();\n     locus = other.locus;\n+    node_id = other.node_id;\n \n     return *this;\n   }\n@@ -1386,6 +1443,10 @@ class GroupedPattern : public Pattern\n     return pattern_in_parens;\n   }\n \n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1400,17 +1461,20 @@ class SlicePattern : public Pattern\n {\n   std::vector<std::unique_ptr<Pattern> > items;\n   Location locus;\n+  NodeId node_id;\n \n public:\n   std::string as_string () const override;\n \n   SlicePattern (std::vector<std::unique_ptr<Pattern> > items, Location locus)\n-    : items (std::move (items)), locus (locus)\n+    : items (std::move (items)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Copy constructor with vector clone\n   SlicePattern (SlicePattern const &other) : locus (other.locus)\n   {\n+    node_id = other.node_id;\n     items.reserve (other.items.size ());\n     for (const auto &e : other.items)\n       items.push_back (e->clone_pattern ());\n@@ -1420,6 +1484,7 @@ class SlicePattern : public Pattern\n   SlicePattern &operator= (SlicePattern const &other)\n   {\n     locus = other.locus;\n+    node_id = other.node_id;\n \n     items.reserve (other.items.size ());\n     for (const auto &e : other.items)\n@@ -1443,6 +1508,10 @@ class SlicePattern : public Pattern\n     return items;\n   }\n \n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "a5c1ff596763283c1870bc19ce5f405a355da247", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7615df781226137b9cd76b47df4aea6ad9f2140e/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7615df781226137b9cd76b47df4aea6ad9f2140e/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=7615df781226137b9cd76b47df4aea6ad9f2140e", "patch": "@@ -77,8 +77,8 @@ class ResolveTraitItems : public ResolverBase\n \n \t// the mutability checker needs to verify for immutable decls the number\n \t// of assignments are <1. This marks an implicit assignment\n-\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n-\t\t\t\t\t   param.get_node_id ());\n+\tresolver->mark_assignment_to_decl (\n+\t  param.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n       }\n \n     if (function.has_where_clause ())\n@@ -143,8 +143,8 @@ class ResolveTraitItems : public ResolverBase\n \n \t// the mutability checker needs to verify for immutable decls the number\n \t// of assignments are <1. This marks an implicit assignment\n-\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n-\t\t\t\t\t   param.get_node_id ());\n+\tresolver->mark_assignment_to_decl (\n+\t  param.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n       }\n \n     if (function.has_where_clause ())\n@@ -394,8 +394,8 @@ class ResolveItem : public ResolverBase\n \n \t// the mutability checker needs to verify for immutable decls the number\n \t// of assignments are <1. This marks an implicit assignment\n-\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n-\t\t\t\t\t   param.get_node_id ());\n+\tresolver->mark_assignment_to_decl (\n+\t  param.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n       }\n \n     // resolve the function body\n@@ -510,8 +510,8 @@ class ResolveItem : public ResolverBase\n \n \t// the mutability checker needs to verify for immutable decls the number\n \t// of assignments are <1. This marks an implicit assignment\n-\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n-\t\t\t\t\t   param.get_node_id ());\n+\tresolver->mark_assignment_to_decl (\n+\t  param.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n       }\n \n     // resolve any where clause items"}, {"sha": "9b32901a6551663ab133333d82bb9c85b9e67ea2", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7615df781226137b9cd76b47df4aea6ad9f2140e/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7615df781226137b9cd76b47df4aea6ad9f2140e/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=7615df781226137b9cd76b47df4aea6ad9f2140e", "patch": "@@ -82,8 +82,8 @@ class ResolveStmt : public ResolverBase\n \tResolveExpr::go (stmt.get_init_expr ().get (), stmt.get_node_id ());\n \n \t// mark the assignment\n-\tresolver->mark_assignment_to_decl (stmt.get_pattern ()->get_node_id (),\n-\t\t\t\t\t   stmt.get_node_id ());\n+\tresolver->mark_assignment_to_decl (\n+\t  stmt.get_pattern ()->get_pattern_node_id (), stmt.get_node_id ());\n       }\n \n     PatternDeclaration::go (stmt.get_pattern ().get (), stmt.get_node_id ());\n@@ -316,8 +316,8 @@ class ResolveStmt : public ResolverBase\n \n \t// the mutability checker needs to verify for immutable decls the number\n \t// of assignments are <1. This marks an implicit assignment\n-\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n-\t\t\t\t\t   param.get_node_id ());\n+\tresolver->mark_assignment_to_decl (\n+\t  param.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n       }\n \n     // resolve the function body"}]}