{"sha": "4cc833b7a82f38982f5e709fd7ae368c9ead5016", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNjODMzYjdhODJmMzg5ODJmNWU3MDlmZDdhZTM2OGM5ZWFkNTAxNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-07-21T00:26:00Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-07-21T00:26:00Z"}, "message": "rs6000.h (struct rs6000_args): Add sysv_gregno.\n\n        * rs6000.h (struct rs6000_args): Add sysv_gregno.\n        * rs6000.c (init_cumulative_args): Init sysv_gregno.\n        (function_arg_boundary): Align DFmode.\n        (function_arg_advance): Restructure for ABI_V4; use sysv_gregno\n        to get fp reg and stack overflow correct.\n        (function_arg): Likewise.\n        (function_arg_pass_by_reference): True for TFmode for ABI_V4.\n        (setup_incoming_varargs): Restructure for ABI_V4; use\n        function_arg_advance to skip final named argument.\n        (expand_builtin_saveregs): Properly unskip the last integer arg\n        when doing varargs.  Adjust overflow location calculation.\n\n        * ginclude/va-ppc.h (struct __va_list_tag): Make gpr and fpr\n        explicitly unsigned.\n        (__VA_FP_REGSAVE): Use new OFS argument instead of AP->fpr directly.\n        (__VA_GP_REGSAVE): Similarly.\n        (__va_longlong_p): Delete.\n        (__va_arg_type_violation): New declaration.\n        (va_arg): Restructure.  Flag promotion errors.  Align double.\n        TFmode passed by reference.\n\n        * rs6000.md (movdi_32+1): Use GEN_INT after arithmetic\n        in the HOST_BITS_PER_WIDE_INT > 32 case.\n\nFrom-SVN: r28199", "tree": {"sha": "0ebaa8fa73357ac49f1fcc4fdc21804f89cd70f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ebaa8fa73357ac49f1fcc4fdc21804f89cd70f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cc833b7a82f38982f5e709fd7ae368c9ead5016", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cc833b7a82f38982f5e709fd7ae368c9ead5016", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cc833b7a82f38982f5e709fd7ae368c9ead5016", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cc833b7a82f38982f5e709fd7ae368c9ead5016/comments", "author": null, "committer": null, "parents": [{"sha": "7705e9db01267c127d2b9f9a33b5218546898ef6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7705e9db01267c127d2b9f9a33b5218546898ef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7705e9db01267c127d2b9f9a33b5218546898ef6"}], "stats": {"total": 510, "additions": 317, "deletions": 193}, "files": [{"sha": "1215c13a05485cabe2b35625c7aec3c43f777c14", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 208, "deletions": 132, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc833b7a82f38982f5e709fd7ae368c9ead5016/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc833b7a82f38982f5e709fd7ae368c9ead5016/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=4cc833b7a82f38982f5e709fd7ae368c9ead5016", "patch": "@@ -1253,6 +1253,7 @@ init_cumulative_args (cum, fntype, libname, incoming)\n   cum->fregno = FP_ARG_MIN_REG;\n   cum->prototype = (fntype && TYPE_ARG_TYPES (fntype));\n   cum->call_cookie = CALL_NORMAL;\n+  cum->sysv_gregno = GP_ARG_MIN_REG;\n \n   if (incoming)\n     cum->nargs_prototype = 1000;\t\t/* don't return a PARALLEL */\n@@ -1338,7 +1339,8 @@ function_arg_boundary (mode, type)\n      enum machine_mode mode;\n      tree type;\n {\n-  if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS) && mode == DImode)\n+  if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n+      && (mode == DImode || mode == DFmode))\n     return 64;\n \n   if (DEFAULT_ABI != ABI_NT || TARGET_64BIT)\n@@ -1361,48 +1363,85 @@ function_arg_advance (cum, mode, type, named)\n      tree type;\n      int named;\n {\n-  int align = (TARGET_32BIT && (cum->words & 1) != 0\n-\t       && function_arg_boundary (mode, type) == 64) ? 1 : 0;\n-  cum->words += align;\n   cum->nargs_prototype--;\n \n   if (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n     {\n-      /* Long longs must not be split between registers and stack */\n-      if ((GET_MODE_CLASS (mode) != MODE_FLOAT || TARGET_SOFT_FLOAT)\n-\t  && type && !AGGREGATE_TYPE_P (type)\n-\t  && cum->words < GP_ARG_NUM_REG\n-\t  && cum->words + RS6000_ARG_SIZE (mode, type, named) > GP_ARG_NUM_REG)\n+      if (TARGET_HARD_FLOAT\n+\t  && (mode == SFmode || mode == DFmode))\n \t{\n-\t  cum->words = GP_ARG_NUM_REG;\n+\t  if (cum->fregno <= FP_ARG_V4_MAX_REG)\n+\t    cum->fregno++;\n+\t  else\n+\t    {\n+\t      if (mode == DFmode)\n+\t        cum->words += cum->words & 1;\n+\t      cum->words += RS6000_ARG_SIZE (mode, type, 1);\n+\t    }\n \t}\n+      else\n+\t{\n+\t  int n_words;\n+\t  int gregno = cum->sysv_gregno;\n+\n+\t  /* Aggregates and IEEE quad get passed by reference.  */\n+\t  if ((type && AGGREGATE_TYPE_P (type))\n+\t      || mode == TFmode)\n+\t    n_words = 1;\n+\t  else \n+\t    n_words = RS6000_ARG_SIZE (mode, type, 1);\n+\n+\t  /* Long long is put in odd registers.  */\n+\t  if (n_words == 2 && (gregno & 1) == 0)\n+\t    gregno += 1;\n+\n+\t  /* Long long is not split between registers and stack.  */\n+\t  if (gregno + n_words - 1 > GP_ARG_MAX_REG)\n+\t    {\n+\t      /* Long long is aligned on the stack.  */\n+\t      if (n_words == 2)\n+\t\tcum->words += cum->words & 1;\n+\t      cum->words += n_words;\n+\t    }\n \n-      /* Aggregates get passed as pointers */\n-      if (type && AGGREGATE_TYPE_P (type))\n-\tcum->words++;\n-\n-      /* Floats go in registers, & don't occupy space in the GP registers\n-\t like they do for AIX unless software floating point.  */\n-      else if (GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t       && TARGET_HARD_FLOAT\n-\t       && cum->fregno <= FP_ARG_V4_MAX_REG)\n-\tcum->fregno++;\n+\t  /* Note: continuing to accumulate gregno past when we've started\n+\t     spilling to the stack indicates the fact that we've started\n+\t     spilling to the stack to expand_builtin_saveregs.  */\n+\t  cum->sysv_gregno = gregno + n_words;\n+\t}\n \n-      else\n-\tcum->words += RS6000_ARG_SIZE (mode, type, 1);\n+      if (TARGET_DEBUG_ARG)\n+\t{\n+\t  fprintf (stderr, \"function_adv: words = %2d, fregno = %2d, \",\n+\t\t   cum->words, cum->fregno);\n+\t  fprintf (stderr, \"gregno = %2d, nargs = %4d, proto = %d, \",\n+\t\t   cum->sysv_gregno, cum->nargs_prototype, cum->prototype);\n+\t  fprintf (stderr, \"mode = %4s, named = %d\\n\",\n+\t\t   GET_MODE_NAME (mode), named);\n+\t}\n     }\n   else\n-    if (named)\n-      {\n-\tcum->words += RS6000_ARG_SIZE (mode, type, named);\n-\tif (GET_MODE_CLASS (mode) == MODE_FLOAT && TARGET_HARD_FLOAT)\n-\t  cum->fregno++;\n-      }\n+    {\n+      int align = (TARGET_32BIT && (cum->words & 1) != 0\n+\t\t   && function_arg_boundary (mode, type) == 64) ? 1 : 0;\n+      cum->words += align;\n \n-  if (TARGET_DEBUG_ARG)\n-    fprintf (stderr,\n-\t     \"function_adv: words = %2d, fregno = %2d, nargs = %4d, proto = %d, mode = %4s, named = %d, align = %d\\n\",\n-\t     cum->words, cum->fregno, cum->nargs_prototype, cum->prototype, GET_MODE_NAME (mode), named, align);\n+      if (named)\n+\t{\n+\t  cum->words += RS6000_ARG_SIZE (mode, type, named);\n+\t  if (GET_MODE_CLASS (mode) == MODE_FLOAT && TARGET_HARD_FLOAT)\n+\t    cum->fregno++;\n+\t}\n+\n+      if (TARGET_DEBUG_ARG)\n+\t{\n+\t  fprintf (stderr, \"function_adv: words = %2d, fregno = %2d, \",\n+\t\t   cum->words, cum->fregno);\n+\t  fprintf (stderr, \"nargs = %4d, proto = %d, mode = %4s, \",\n+\t\t   cum->nargs_prototype, cum->prototype, GET_MODE_NAME (mode));\n+\t  fprintf (stderr, \"named = %d, align = %d\\n\", named, align);\n+\t}\n+    }\n }\n \f\n /* Determine where to put an argument to a function.\n@@ -1435,22 +1474,14 @@ function_arg (cum, mode, type, named)\n      tree type;\n      int named;\n {\n-  int align = (TARGET_32BIT && (cum->words & 1) != 0\n-\t       && function_arg_boundary (mode, type) == 64) ? 1 : 0;\n-  int align_words = cum->words + align;\n-\n-  if (TARGET_DEBUG_ARG)\n-    fprintf (stderr,\n-\t     \"function_arg: words = %2d, fregno = %2d, nargs = %4d, proto = %d, mode = %4s, named = %d, align = %d\\n\",\n-\t     cum->words, cum->fregno, cum->nargs_prototype, cum->prototype, GET_MODE_NAME (mode), named, align);\n+  enum rs6000_abi abi = DEFAULT_ABI;\n \n-  /* Return a marker to indicate whether CR1 needs to set or clear the bit that V.4\n-     uses to say fp args were passed in registers.  Assume that we don't need the\n-     marker for software floating point, or compiler generated library calls.  */\n+  /* Return a marker to indicate whether CR1 needs to set or clear the bit\n+     that V.4 uses to say fp args were passed in registers.  Assume that we\n+     don't need the marker for software floating point, or compiler generated\n+     library calls.  */\n   if (mode == VOIDmode)\n     {\n-      enum rs6000_abi abi = DEFAULT_ABI;\n-\n       if ((abi == ABI_V4 || abi == ABI_SOLARIS)\n \t  && TARGET_HARD_FLOAT\n \t  && cum->nargs_prototype < 0\n@@ -1465,31 +1496,65 @@ function_arg (cum, mode, type, named)\n       return GEN_INT (cum->call_cookie);\n     }\n \n-  if (!named)\n+  if (abi == ABI_V4 || abi == ABI_SOLARIS)\n     {\n-      if (DEFAULT_ABI != ABI_V4 && DEFAULT_ABI != ABI_SOLARIS)\n-\treturn NULL_RTX;\n+      if (TARGET_HARD_FLOAT\n+\t  && (mode == SFmode || mode == DFmode))\n+\t{\n+\t  if (cum->fregno <= FP_ARG_V4_MAX_REG)\n+\t    return gen_rtx_REG (mode, cum->fregno);\n+\t  else\n+\t    return NULL;\n+\t}\n+      else\n+\t{\n+\t  int n_words;\n+\t  int gregno = cum->sysv_gregno;\n+\n+\t  /* Aggregates and IEEE quad get passed by reference.  */\n+\t  if ((type && AGGREGATE_TYPE_P (type))\n+\t      || mode == TFmode)\n+\t    n_words = 1;\n+\t  else \n+\t    n_words = RS6000_ARG_SIZE (mode, type, 1);\n+\n+\t  /* Long long is put in odd registers.  */\n+\t  if (n_words == 2 && (gregno & 1) == 0)\n+\t    gregno += 1;\n+\n+\t  /* Long long is not split between registers and stack.  */\n+\t  if (gregno + n_words - 1 <= GP_ARG_MAX_REG)\n+\t    return gen_rtx_REG (mode, gregno);\n+\t  else\n+\t    return NULL;\n+\t}\n     }\n+  else\n+    {\n+      int align = (TARGET_32BIT && (cum->words & 1) != 0\n+\t           && function_arg_boundary (mode, type) == 64) ? 1 : 0;\n+      int align_words = cum->words + align;\n \n-  if (type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n-    return NULL_RTX;\n+      if (!named)\n+\treturn NULL_RTX;\n \n-  if (USE_FP_FOR_ARG_P (*cum, mode, type))\n-    {\n-      if (DEFAULT_ABI == ABI_V4 /* V.4 never passes FP values in GP registers */\n-\t  || DEFAULT_ABI == ABI_SOLARIS\n-\t  || ! type\n-\t  || ((cum->nargs_prototype > 0)\n-\t      /* IBM AIX extended its linkage convention definition always to\n-\t\t require FP args after register save area hole on the stack.  */\n-\t      && (DEFAULT_ABI != ABI_AIX\n-\t\t  || ! TARGET_XL_CALL\n-\t\t  || (align_words < GP_ARG_NUM_REG))))\n-\treturn gen_rtx_REG (mode, cum->fregno);\n-\n-      return gen_rtx_PARALLEL (mode,\n-\t\t      gen_rtvec\n-\t\t      (2,\n+      if (type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+        return NULL_RTX;\n+\n+      if (USE_FP_FOR_ARG_P (*cum, mode, type))\n+\t{\n+\t  if (! type\n+\t      || ((cum->nargs_prototype > 0)\n+\t          /* IBM AIX extended its linkage convention definition always\n+\t\t     to require FP args after register save area hole on the\n+\t\t     stack.  */\n+\t          && (DEFAULT_ABI != ABI_AIX\n+\t\t      || ! TARGET_XL_CALL\n+\t\t      || (align_words < GP_ARG_NUM_REG))))\n+\t    return gen_rtx_REG (mode, cum->fregno);\n+\n+          return gen_rtx_PARALLEL (mode,\n+\t    gen_rtvec (2,\n \t\t       gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t((align_words >= GP_ARG_NUM_REG)\n \t\t\t\t ? NULL_RTX\n@@ -1507,21 +1572,12 @@ function_arg (cum, mode, type, named)\n \t\t       gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\tgen_rtx_REG (mode, cum->fregno),\n \t\t\t\tconst0_rtx)));\n+\t}\n+      else if (align_words < GP_ARG_NUM_REG)\n+\treturn gen_rtx_REG (mode, GP_ARG_MIN_REG + align_words);\n+      else\n+\treturn NULL_RTX;\n     }\n-\n-  /* Long longs won't be split between register and stack;\n-     FP arguments get passed on the stack if they didn't get a register.  */\n-  else if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS) &&\n-\t   (align_words + RS6000_ARG_SIZE (mode, type, named) > GP_ARG_NUM_REG\n-\t    || (GET_MODE_CLASS (mode) == MODE_FLOAT && TARGET_HARD_FLOAT)))\n-    {\n-      return NULL_RTX;\n-    }\n-\n-  else if (align_words < GP_ARG_NUM_REG)\n-    return gen_rtx_REG (mode, GP_ARG_MIN_REG + align_words);\n-\n-  return NULL_RTX;\n }\n \f\n /* For an arg passed partly in registers and partly in memory,\n@@ -1576,7 +1632,8 @@ function_arg_pass_by_reference (cum, mode, type, named)\n      int named ATTRIBUTE_UNUSED;\n {\n   if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n-      && type && AGGREGATE_TYPE_P (type))\n+      && ((type && AGGREGATE_TYPE_P (type))\n+\t  || mode == TFmode))\n     {\n       if (TARGET_DEBUG_ARG)\n \tfprintf (stderr, \"function_arg_pass_by_reference: aggregate\\n\");\n@@ -1611,73 +1668,87 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n      int no_rtl;\n \n {\n-  rtx save_area = virtual_incoming_args_rtx;\n-  int reg_size\t= TARGET_32BIT ? 4 : 8;\n-\n-  if (TARGET_DEBUG_ARG)\n-    fprintf (stderr,\n-\t     \"setup_vararg: words = %2d, fregno = %2d, nargs = %4d, proto = %d, mode = %4s, no_rtl= %d\\n\",\n-\t     cum->words, cum->fregno, cum->nargs_prototype, cum->prototype, GET_MODE_NAME (mode), no_rtl);\n+  CUMULATIVE_ARGS next_cum;\n+  int reg_size = TARGET_32BIT ? 4 : 8;\n+  rtx save_area;\n+  int first_reg_offset;\n \n   if (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n     {\n+      tree fntype;\n+      int stdarg_p;\n+\n+      fntype = TREE_TYPE (current_function_decl);\n+      stdarg_p = (TYPE_ARG_TYPES (fntype) != 0\n+\t\t  && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n+\t\t      != void_type_node));\n+\n+      /* For varargs, we do not want to skip the dummy va_dcl argument.\n+         For stdargs, we do want to skip the last named argument.  */\n+      next_cum = *cum;\n+      if (stdarg_p)\n+\tfunction_arg_advance (&next_cum, mode, type, 1);\n+\n+      /* Indicate to allocate space on the stack for varargs save area.  */\n+      /* ??? Does this really have to be located at a magic spot on the\n+\t stack, or can we allocate this with assign_stack_local instead.  */\n       rs6000_sysv_varargs_p = 1;\n       if (! no_rtl)\n \tsave_area = plus_constant (virtual_stack_vars_rtx,\n \t\t\t\t   - RS6000_VARARGS_SIZE);\n+\n+      first_reg_offset = next_cum.sysv_gregno - GP_ARG_MIN_REG;\n     }\n   else\n-    rs6000_sysv_varargs_p = 0;\n-\n-  if (cum->words < 8)\n     {\n-      int first_reg_offset = cum->words;\n+      save_area = virtual_incoming_args_rtx;\n+      rs6000_sysv_varargs_p = 0;\n \n+      first_reg_offset = cum->words;\n       if (MUST_PASS_IN_STACK (mode, type))\n \tfirst_reg_offset += RS6000_ARG_SIZE (TYPE_MODE (type), type, 1);\n+    }\n \n-      if (first_reg_offset > GP_ARG_NUM_REG)\n-\tfirst_reg_offset = GP_ARG_NUM_REG;\n-\n-      if (!no_rtl && first_reg_offset != GP_ARG_NUM_REG)\n-\tmove_block_from_reg\n-\t  (GP_ARG_MIN_REG + first_reg_offset,\n-\t   gen_rtx_MEM (BLKmode,\n-\t\t    plus_constant (save_area, first_reg_offset * reg_size)),\n-\t   GP_ARG_NUM_REG - first_reg_offset,\n-\t   (GP_ARG_NUM_REG - first_reg_offset) * UNITS_PER_WORD);\n-\n+  if (!no_rtl && first_reg_offset < GP_ARG_NUM_REG)\n+    {\n+      move_block_from_reg\n+\t(GP_ARG_MIN_REG + first_reg_offset,\n+\t gen_rtx_MEM (BLKmode,\n+\t\t      plus_constant (save_area, first_reg_offset * reg_size)),\n+\t GP_ARG_NUM_REG - first_reg_offset,\n+\t (GP_ARG_NUM_REG - first_reg_offset) * UNITS_PER_WORD);\n+\n+      /* ??? Does ABI_V4 need this at all?  */\n       *pretend_size = (GP_ARG_NUM_REG - first_reg_offset) * UNITS_PER_WORD;\n     }\n \n   /* Save FP registers if needed.  */\n-  if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS) && TARGET_HARD_FLOAT && !no_rtl)\n+  if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n+      && TARGET_HARD_FLOAT && !no_rtl\n+      && next_cum.fregno <= FP_ARG_V4_MAX_REG)\n     {\n-      int fregno     = cum->fregno;\n-      int num_fp_reg = FP_ARG_V4_MAX_REG + 1 - fregno;\n+      int fregno = next_cum.fregno;\n+      rtx cr1 = gen_rtx_REG (CCmode, 69);\n+      rtx lab = gen_label_rtx ();\n+      int off = (GP_ARG_NUM_REG * reg_size) + ((fregno - FP_ARG_MIN_REG) * 8);\n \n-      if (num_fp_reg >= 0)\n-\t{\n-\t  rtx cr1 = gen_rtx_REG (CCmode, 69);\n-\t  rtx lab = gen_label_rtx ();\n-\t  int off = (GP_ARG_NUM_REG * reg_size) + ((fregno - FP_ARG_MIN_REG) * 8);\n-\n-\t  emit_jump_insn (gen_rtx_SET (VOIDmode,\n+      emit_jump_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\t   pc_rtx,\n \t\t\t\t   gen_rtx_IF_THEN_ELSE (VOIDmode,\n-\t\t\t\t\t    gen_rtx_NE (VOIDmode, cr1, const0_rtx),\n+\t\t\t\t\t    gen_rtx_NE (VOIDmode, cr1,\n+\t\t\t\t\t\t        const0_rtx),\n \t\t\t\t\t    gen_rtx_LABEL_REF (VOIDmode, lab),\n \t\t\t\t\t    pc_rtx)));\n \n-\t  while ( num_fp_reg-- >= 0)\n-\t    {\n-\t      emit_move_insn (gen_rtx_MEM (DFmode, plus_constant (save_area, off)),\n-\t\t\t      gen_rtx_REG (DFmode, fregno++));\n-\t      off += 8;\n-\t    }\n-\n-\t  emit_label (lab);\n+      while (fregno <= FP_ARG_V4_MAX_REG)\n+\t{\n+\t  emit_move_insn (gen_rtx_MEM (DFmode, plus_constant (save_area, off)),\n+\t\t\t  gen_rtx_REG (DFmode, fregno));\n+\t  fregno++;\n+\t  off += 8;\n \t}\n+\n+      emit_label (lab);\n     }\n }\n \f\n@@ -1733,9 +1804,18 @@ expand_builtin_saveregs (args)\n \t\t\t\t\t\t     2 * UNITS_PER_WORD));\n \n   /* Construct the two characters of `gpr' and `fpr' as a unit.  */\n-  words = current_function_args_info.words - !stdarg_p;\n-  gpr = (words > 8 ? 8 : words);\n-  fpr = current_function_args_info.fregno - 33;\n+  words = current_function_args_info.words;\n+  gpr = current_function_args_info.sysv_gregno - GP_ARG_MIN_REG;\n+  fpr = current_function_args_info.fregno - FP_ARG_MIN_REG;\n+\n+  /* Varargs has the va_dcl argument, but we don't count it.  */\n+  if (!stdarg_p)\n+    {\n+      if (gpr > GP_ARG_NUM_REG)\n+        words -= 1;\n+      else\n+        gpr -= 1;\n+    }\n \n   if (BYTES_BIG_ENDIAN)\n     {\n@@ -1754,12 +1834,9 @@ expand_builtin_saveregs (args)\n   emit_move_insn (mem_gpr_fpr, tmp);\n \n   /* Find the overflow area.  */\n-  if (words <= 8)\n-    tmp = virtual_incoming_args_rtx;\n-  else\n-    tmp = expand_binop (Pmode, add_optab, virtual_incoming_args_rtx,\n-\t\t        GEN_INT ((words - 8) * UNITS_PER_WORD),\n-\t\t        mem_overflow, 0, OPTAB_WIDEN);\n+  tmp = expand_binop (Pmode, add_optab, virtual_incoming_args_rtx,\n+\t\t      GEN_INT (words * UNITS_PER_WORD),\n+\t\t      mem_overflow, 0, OPTAB_WIDEN);\n   if (tmp != mem_overflow)\n     emit_move_insn (mem_overflow, tmp);\n \n@@ -1773,7 +1850,6 @@ expand_builtin_saveregs (args)\n   /* Return the address of the va_list constructor.  */\n   return XEXP (block, 0);\n }\n-\n \f\n /* Generate a memory reference for expand_block_move, copying volatile,\n    and other bits from an original memory reference.  */"}, {"sha": "4e5c9ac8af8e166b0c5275137166be69ba5bda25", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc833b7a82f38982f5e709fd7ae368c9ead5016/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc833b7a82f38982f5e709fd7ae368c9ead5016/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=4cc833b7a82f38982f5e709fd7ae368c9ead5016", "patch": "@@ -1435,17 +1435,22 @@ extern int rs6000_sysv_varargs_p;\n    floating-point register number, and the third says how many more args we\n    have prototype types for.\n \n+   For ABI_V4, we treat these slightly differently -- `sysv_gregno' is\n+   the next availible GP register, `fregno' is the next available FP\n+   register, and `words' is the number of words used on the stack.\n+\n    The varargs/stdarg support requires that this structure's size\n-   be a multiple of sizeof(int). */\n+   be a multiple of sizeof(int).  */\n \n typedef struct rs6000_args\n {\n-  int words;\t\t\t/* # words uses for passing GP registers */\n+  int words;\t\t\t/* # words used for passing GP registers */\n   int fregno;\t\t\t/* next available FP register */\n   int nargs_prototype;\t\t/* # args left in the current prototype */\n   int orig_nargs;\t\t/* Original value of nargs_prototype */\n   int prototype;\t\t/* Whether a prototype was defined */\n   int call_cookie;\t\t/* Do special things for this call */\n+  int sysv_gregno;\t\t/* next available GP register */\n } CUMULATIVE_ARGS;\n \n /* Define intermediate macro to compute the size (in registers) of an argument"}, {"sha": "bb23a1a32a246731bc714eeffa01996228f546ec", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc833b7a82f38982f5e709fd7ae368c9ead5016/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc833b7a82f38982f5e709fd7ae368c9ead5016/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=4cc833b7a82f38982f5e709fd7ae368c9ead5016", "patch": "@@ -6624,8 +6624,8 @@\n #if HOST_BITS_PER_WIDE_INT == 32\n   operands[4] = (INTVAL (operands[1]) & 0x80000000) ? constm1_rtx : const0_rtx;\n #else\n-  operands[4] = (HOST_WIDE_INT) INTVAL (operands[1]) >> 32;\n-  operands[1] = INTVAL (operands[1]) & 0xffffffff;\n+  operands[4] = GEN_INT ((HOST_WIDE_INT) INTVAL (operands[1]) >> 32);\n+  operands[1] = GEN_INT (INTVAL (operands[1]) & 0xffffffff);\n #endif\n }\")\n "}, {"sha": "0c79d5fe20626a1b3802986cb527c07e17b922fa", "filename": "gcc/ginclude/va-ppc.h", "status": "modified", "additions": 100, "deletions": 57, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc833b7a82f38982f5e709fd7ae368c9ead5016/gcc%2Fginclude%2Fva-ppc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc833b7a82f38982f5e709fd7ae368c9ead5016/gcc%2Fginclude%2Fva-ppc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-ppc.h?ref=4cc833b7a82f38982f5e709fd7ae368c9ead5016", "patch": "@@ -17,10 +17,10 @@\n /* Note that the names in this structure are in the user's namespace, but\n    that the V.4 abi explicitly states that these names should be used.  */\n typedef struct __va_list_tag {\n-  char gpr;\t\t\t/* index into the array of 8 GPRs stored in the\n+  unsigned char gpr;\t\t/* index into the array of 8 GPRs stored in the\n \t\t\t\t   register save area gpr=0 corresponds to r3,\n \t\t\t\t   gpr=1 to r4, etc. */\n-  char fpr;\t\t\t/* index into the array of 8 FPRs stored in the\n+  unsigned char fpr;\t\t/* index into the array of 8 FPRs stored in the\n \t\t\t\t   register save area fpr=0 corresponds to f1,\n \t\t\t\t   fpr=1 to f2, etc. */\n   char *overflow_arg_area;\t/* location on stack that holds the next\n@@ -51,13 +51,13 @@ typedef struct {\n /* Macros to access the register save area */\n /* We cast to void * and then to TYPE * because this avoids\n    a warning about increasing the alignment requirement.  */\n-#define __VA_FP_REGSAVE(AP,TYPE)\t\t\t\t\t\\\n+#define __VA_FP_REGSAVE(AP,OFS,TYPE)\t\t\t\t\t\\\n   ((TYPE *) (void *) (&(((__va_regsave_t *)\t\t\t\t\\\n-\t\t\t (AP)->reg_save_area)->__fp_save[(int)(AP)->fpr])))\n+\t\t\t (AP)->reg_save_area)->__fp_save[OFS])))\n \n-#define __VA_GP_REGSAVE(AP,TYPE)\t\t\t\t\t\\\n+#define __VA_GP_REGSAVE(AP,OFS,TYPE)\t\t\t\t\t\\\n   ((TYPE *) (void *) (&(((__va_regsave_t *)\t\t\t\t\\\n-\t\t\t (AP)->reg_save_area)->__gp_save[(int)(AP)->gpr])))\n+\t\t\t (AP)->reg_save_area)->__gp_save[OFS])))\n \n /* Common code for va_start for both varargs and stdarg.  We allow all\n    the work to be done by __builtin_saveregs.  It returns a pointer to\n@@ -88,60 +88,103 @@ typedef struct {\n #define __va_float_p(TYPE)\t(__builtin_classify_type(*(TYPE *)0) == 8)\n #endif\n \n-#define __va_longlong_p(TYPE) \\\n-  ((__builtin_classify_type(*(TYPE *)0) == 1) && (sizeof(TYPE) == 8))\n-\n #define __va_aggregate_p(TYPE)\t(__builtin_classify_type(*(TYPE *)0) >= 12)\n #define __va_size(TYPE)\t\t((sizeof(TYPE) + sizeof (long) - 1) / sizeof (long))\n \n-#define va_arg(AP,TYPE)\t\t\t\t\t\t\t\\\n-__extension__ (*({\t\t\t\t\t\t\t\\\n-  register TYPE *__ptr;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (__va_float_p (TYPE) && (AP)->fpr < 8)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      __ptr = __VA_FP_REGSAVE (AP, TYPE);\t\t\t\t\\\n-      (AP)->fpr++;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  else if (__va_aggregate_p (TYPE) && (AP)->gpr < 8)\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      __ptr = * __VA_GP_REGSAVE (AP, TYPE *);\t\t\t\t\\\n-      (AP)->gpr++;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  else if (!__va_float_p (TYPE) && !__va_aggregate_p (TYPE)\t\t\\\n-\t   && (AP)->gpr + __va_size(TYPE) <= 8\t\t\t\t\\\n-\t   && (!__va_longlong_p(TYPE)\t\t\t\t\t\\\n-\t       || (AP)->gpr + __va_size(TYPE) <= 8))\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (__va_longlong_p(TYPE) && ((AP)->gpr & 1) != 0)\t\t\\\n-\t(AP)->gpr++;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      __ptr = __VA_GP_REGSAVE (AP, TYPE);\t\t\t\t\\\n-      (AP)->gpr += __va_size (TYPE);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  else if (!__va_float_p (TYPE) && !__va_aggregate_p (TYPE)\t\t\\\n-\t   && (AP)->gpr < 8)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      (AP)->gpr = 8;\t\t\t\t\t\t\t\\\n-      __ptr = (TYPE *) (void *) (__va_overflow(AP));\t\t\t\\\n-      __va_overflow(AP) += __va_size (TYPE) * sizeof (long);\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  else if (__va_aggregate_p (TYPE))\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      __ptr = * (TYPE **) (void *) (__va_overflow(AP));\t\t\t\\\n-      __va_overflow(AP) += sizeof (TYPE *);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      __ptr = (TYPE *) (void *) (__va_overflow(AP));\t\t\t\\\n-      __va_overflow(AP) += __va_size (TYPE) * sizeof (long);\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  __ptr;\t\t\t\t\t\t\t\t\\\n+/* This symbol isn't defined.  It is used to flag type promotion violations\n+   at link time.  We can only do this when optimizing.  Use __builtin_trap\n+   instead of abort so that we don't require a prototype for abort.  */\n+\n+#ifdef __OPTIMIZE__\n+extern void __va_arg_type_violation(void) __attribute__((__noreturn__));\n+#else\n+#define __va_arg_type_violation() __builtin_trap()\n+#endif\n+\n+#define va_arg(AP,TYPE)\t\t\t\t\t\t\t   \\\n+__extension__ (*({\t\t\t\t\t\t\t   \\\n+  register TYPE *__ptr;\t\t\t\t\t\t\t   \\\n+\t\t\t\t\t\t\t\t\t   \\\n+  if (__va_float_p (TYPE) && sizeof (TYPE) < 16)\t\t\t   \\\n+    {\t\t\t\t\t\t\t\t\t   \\\n+      unsigned char __fpr = (AP)->fpr;\t\t\t\t\t   \\\n+      if (__fpr < 8)\t\t\t\t\t\t\t   \\\n+\t{\t\t\t\t\t\t\t\t   \\\n+\t  __ptr = __VA_FP_REGSAVE (AP, __fpr, TYPE);\t\t\t   \\\n+\t  (AP)->fpr = __fpr + 1;\t\t\t\t\t   \\\n+\t}\t\t\t\t\t\t\t\t   \\\n+      else if (sizeof (TYPE) == 8)\t\t\t\t\t   \\\n+\t{\t\t\t\t\t\t\t\t   \\\n+\t  unsigned long __addr = (unsigned long) (__va_overflow (AP));\t   \\\n+\t  __ptr = (TYPE *)((__addr + 7) & -8);\t\t\t\t   \\\n+\t  __va_overflow (AP) = (char *)(__ptr + 1);\t\t\t   \\\n+\t}\t\t\t\t\t\t\t\t   \\\n+      else\t\t\t\t\t\t\t\t   \\\n+\t{\t\t\t\t\t\t\t\t   \\\n+\t  /* float is promoted to double.  */\t\t\t\t   \\\n+\t  __va_arg_type_violation ();\t\t\t\t\t   \\\n+\t}\t\t\t\t\t\t\t\t   \\\n+    }\t\t\t\t\t\t\t\t\t   \\\n+\t\t\t\t\t\t\t\t\t   \\\n+  /* Aggregates and long doubles are passed by reference.  */\t\t   \\\n+  else if (__va_aggregate_p (TYPE) || __va_float_p (TYPE))\t\t   \\\n+    {\t\t\t\t\t\t\t\t\t   \\\n+      unsigned char __gpr = (AP)->gpr;\t\t\t\t\t   \\\n+      if (__gpr < 8)\t\t\t\t\t\t\t   \\\n+\t{\t\t\t\t\t\t\t\t   \\\n+\t  __ptr = * __VA_GP_REGSAVE (AP, __gpr, TYPE *);\t\t   \\\n+\t  (AP)->gpr = __gpr + 1;\t\t\t\t\t   \\\n+\t}\t\t\t\t\t\t\t\t   \\\n+      else\t\t\t\t\t\t\t\t   \\\n+\t{\t\t\t\t\t\t\t\t   \\\n+\t  TYPE **__pptr = (TYPE **) (__va_overflow (AP));\t\t   \\\n+\t  __ptr = * __pptr;\t\t\t\t\t\t   \\\n+\t  __va_overflow (AP) = (char *) (__pptr + 1);\t\t\t   \\\n+\t}\t\t\t\t\t\t\t\t   \\\n+    }\t\t\t\t\t\t\t\t\t   \\\n+\t\t\t\t\t\t\t\t\t   \\\n+  /* Only integrals remaining.  */\t\t\t\t\t   \\\n+  else\t\t\t\t\t\t\t\t\t   \\\n+    {\t\t\t\t\t\t\t\t\t   \\\n+      /* longlong is aligned.  */\t\t\t\t\t   \\\n+      if (sizeof (TYPE) == 8)\t\t\t\t\t\t   \\\n+\t{\t\t\t\t\t\t\t\t   \\\n+\t  unsigned char __gpr = (AP)->gpr;\t\t\t\t   \\\n+\t  if (__gpr < 7)\t\t\t\t\t\t   \\\n+\t    {\t\t\t\t\t\t\t\t   \\\n+\t      __gpr += __gpr & 1;\t\t\t\t\t   \\\n+\t      __ptr = __VA_GP_REGSAVE (AP, __gpr, TYPE);\t\t   \\\n+\t      (AP)->gpr = __gpr + 2;\t\t\t\t\t   \\\n+\t    }\t\t\t\t\t\t\t\t   \\\n+\t  else\t\t\t\t\t\t\t\t   \\\n+\t    {\t\t\t\t\t\t\t\t   \\\n+\t      unsigned long __addr = (unsigned long) (__va_overflow (AP)); \\\n+\t      __ptr = (TYPE *)((__addr + 7) & -8);\t\t\t   \\\n+\t      (AP)->gpr = 8;\t\t\t\t\t\t   \\\n+\t      __va_overflow (AP) = (char *)(__ptr + 1);\t\t\t   \\\n+\t    }\t\t\t\t\t\t\t\t   \\\n+\t}\t\t\t\t\t\t\t\t   \\\n+      else if (sizeof (TYPE) == 4)\t\t\t\t\t   \\\n+\t{\t\t\t\t\t\t\t\t   \\\n+\t  unsigned char __gpr = (AP)->gpr;\t\t\t\t   \\\n+\t  if (__gpr < 8)\t\t\t\t\t\t   \\\n+\t    {\t\t\t\t\t\t\t\t   \\\n+\t      __ptr = __VA_GP_REGSAVE (AP, __gpr, TYPE);\t\t   \\\n+\t      (AP)->gpr = __gpr + 1;\t\t\t\t\t   \\\n+\t    }\t\t\t\t\t\t\t\t   \\\n+\t  else\t\t\t\t\t\t\t\t   \\\n+\t    {\t\t\t\t\t\t\t\t   \\\n+\t      __ptr = (TYPE *) __va_overflow (AP);\t\t\t   \\\n+\t      __va_overflow (AP) = (char *)(__ptr + 1);\t\t\t   \\\n+\t    }\t\t\t\t\t\t\t\t   \\\n+\t}\t\t\t\t\t\t\t\t   \\\n+      else\t\t\t\t\t\t\t\t   \\\n+\t{\t\t\t\t\t\t\t\t   \\\n+\t  /* Everything else was promoted to int.  */\t\t\t   \\\n+\t  __va_arg_type_violation ();\t\t\t\t\t   \\\n+\t}\t\t\t\t\t\t\t\t   \\\n+    }\t\t\t\t\t\t\t\t\t   \\\n+  __ptr;\t\t\t\t\t\t\t\t   \\\n }))\n \n #define va_end(AP)\t((void)0)"}]}