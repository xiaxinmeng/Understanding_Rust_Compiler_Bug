{"sha": "526303ecaaf13762aaad638ec8fa75fed778e332", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI2MzAzZWNhYWYxMzc2MmFhYWQ2MzhlYzhmYTc1ZmVkNzc4ZTMzMg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2015-08-26T21:22:23Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2015-08-26T21:22:23Z"}, "message": "rs6000-protos.h (rs6000_expand_float128_convert): Add declaration.\n\n2015-08-26  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000-protos.h (rs6000_expand_float128_convert):\n\tAdd declaration.\n\n\t* config/rs6000/rs6000.c (rs6000_emit_le_vsx_store): Fix a\n\tcomment.\n\t(rs6000_cannot_change_mode_class): Add support for IEEE 128-bit\n\tfloating point in VSX registers.\n\t(rs6000_output_move_128bit): Always print out the set insn if we\n\tcan't generate an appropriate 128-bit move.\n\t(rs6000_generate_compare): Add support for IEEE 128-bit floating\n\tpoint in VSX registers comparisons.\n\t(rs6000_expand_float128_convert): Likewise.\n\n\t* config/rs6000/predicates.md (int_reg_operand_not_pseudo): New\n\tpredicate for only GPR hard registers.\n\n\t* config/rs6000/rs6000.md (FP): Add IEEE 128-bit floating point\n\tmodes to iterators. Add new iterators for moving 128-bit values in\n\tscalar FPR registers and VSX registers.\n\t(FMOVE128): Likewise.\n\t(FMOVE128_FPR): Likewise.\n\t(FMOVE128_GPR): Likewise.\n\t(FMOVE128_VSX): Likewise.\n\t(FLOAT128_SFDFTF): New iterators for IEEE 128-bit floating point\n\tin VSX registers.\n\t(IFKF): Likewise.\n\t(IBM128): Likewise.\n\t(TFIFKF): Likewise.\n\t(RELOAD): Add IEEE 128-bit floating point modes.\n\t(signbittf2): Convert TF insns to add support for new IEEE 128-bit\n\tfloating point in VSX registers modes.\n\t(signbit<mode>2, IBM128 iterator): Likewise.\n\t(mov<mode>_64bit_dm, FMOVE128_FPR iterator): Likewise.\n\t(mov<mode>_32bit, FMOVE128_FPR iterator): Likewise.\n\t(negtf2): Likewise.\n\t(neg<mode>2, TFIFKF iterator): Likewise.\n\t(negtf2_internal): Likewise.\n\t(abstf2): Likewise.\n\t(abs<mode>2, TFIFKF iterator): Likewise.\n\t(ieee_128bit_negative_zero): New IEEE 128-bit floating point in\n\tVSX insn support for negate, absolute value, and negative absolute\n\tvalue.\n\t(ieee_128bit_vsx_neg<mode>2): Likewise.\n\t(ieee_128bit_vsx_neg<mode>2_internal): Likewise.\n\t(ieee_128bit_vsx_abs<mode>2): Likewise.\n\t(ieee_128bit_vsx_abs<mode>2_internal): Likewise.\n\t(ieee_128bit_vsx_nabs<mode>2): Likewise.\n\t(ieee_128bit_vsx_nabs<mode>2_internal): Likewise.\n\t(FP128_64): Update pack/unpack 128-bit insns for IEEE 128-bit\n\tfloating point in VSX registers.\n\t(unpack<mode>_dm): Likewise.\n\t(unpack<mode>_nodm): Likewise.\n\t(pack<mode>): Likewise.\n\t(unpackv1ti): Likewise.\n\t(unpack<mode>, FMOVE128_VSX iterator): Likewise.\n\t(packv1ti): Likewise.\n\t(pack<mode>, FMOVE128_VSX iterator): Likewise.\n\t(extenddftf2): Add support for IEEE 128-bit floating point in VSX\n\tregisters.\n\t(extenddftf2_internal): Likewise.\n\t(trunctfdf2): Likewise.\n\t(trunctfdf2_internal2): Likewise.\n\t(fix_trunc_helper): Likewise.\n\t(fix_trunctfdi2\"): Likewise.\n\t(floatditf2): Likewise.\n\t(floatuns<mode>tf2): Likewise.\n\t(extend<FLOAT128_SFDFTF:mode><IFKF:mode>2): Likewise.\n\t(trunc<IFKF:mode><FLOAT128_SFDFTF:mode>2): Likewise.\n\t(fix_trunc<IFKF:mode><SDI:mode>2): Likewise.\n\t(fixuns_trunc<IFKF:mode><SDI:mode>2): Likewise.\n\t(float<SDI:mode><IFKF:mode>2): Likewise.\n\t(floatuns<SDI:mode><IFKF:mode>2): Likewise.\n\nFrom-SVN: r227230", "tree": {"sha": "72f288b1a9bf99ef476279a20d7b79f312f490e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72f288b1a9bf99ef476279a20d7b79f312f490e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/526303ecaaf13762aaad638ec8fa75fed778e332", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/526303ecaaf13762aaad638ec8fa75fed778e332", "html_url": "https://github.com/Rust-GCC/gccrs/commit/526303ecaaf13762aaad638ec8fa75fed778e332", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/526303ecaaf13762aaad638ec8fa75fed778e332/comments", "author": null, "committer": null, "parents": [{"sha": "66c182be120bb3777329475c67338b7c0d9ad2f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66c182be120bb3777329475c67338b7c0d9ad2f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66c182be120bb3777329475c67338b7c0d9ad2f4"}], "stats": {"total": 711, "additions": 637, "deletions": 74}, "files": [{"sha": "f38da546d0aa188395019f3202947b62fd1ebb74", "filename": "gcc/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/526303ecaaf13762aaad638ec8fa75fed778e332/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/526303ecaaf13762aaad638ec8fa75fed778e332/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=526303ecaaf13762aaad638ec8fa75fed778e332", "patch": "@@ -1,3 +1,79 @@\n+2015-08-26  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_expand_float128_convert):\n+\tAdd declaration.\n+\n+\t* config/rs6000/rs6000.c (rs6000_emit_le_vsx_store): Fix a\n+\tcomment.\n+\t(rs6000_cannot_change_mode_class): Add support for IEEE 128-bit\n+\tfloating point in VSX registers.\n+\t(rs6000_output_move_128bit): Always print out the set insn if we\n+\tcan't generate an appropriate 128-bit move.\n+\t(rs6000_generate_compare): Add support for IEEE 128-bit floating\n+\tpoint in VSX registers comparisons.\n+\t(rs6000_expand_float128_convert): Likewise.\n+\n+\t* config/rs6000/predicates.md (int_reg_operand_not_pseudo): New\n+\tpredicate for only GPR hard registers.\n+\n+\t* config/rs6000/rs6000.md (FP): Add IEEE 128-bit floating point\n+\tmodes to iterators. Add new iterators for moving 128-bit values in\n+\tscalar FPR registers and VSX registers.\n+\t(FMOVE128): Likewise.\n+\t(FMOVE128_FPR): Likewise.\n+\t(FMOVE128_GPR): Likewise.\n+\t(FMOVE128_VSX): Likewise.\n+\t(FLOAT128_SFDFTF): New iterators for IEEE 128-bit floating point\n+\tin VSX registers.\n+\t(IFKF): Likewise.\n+\t(IBM128): Likewise.\n+\t(TFIFKF): Likewise.\n+\t(RELOAD): Add IEEE 128-bit floating point modes.\n+\t(signbittf2): Convert TF insns to add support for new IEEE 128-bit\n+\tfloating point in VSX registers modes.\n+\t(signbit<mode>2, IBM128 iterator): Likewise.\n+\t(mov<mode>_64bit_dm, FMOVE128_FPR iterator): Likewise.\n+\t(mov<mode>_32bit, FMOVE128_FPR iterator): Likewise.\n+\t(negtf2): Likewise.\n+\t(neg<mode>2, TFIFKF iterator): Likewise.\n+\t(negtf2_internal): Likewise.\n+\t(abstf2): Likewise.\n+\t(abs<mode>2, TFIFKF iterator): Likewise.\n+\t(ieee_128bit_negative_zero): New IEEE 128-bit floating point in\n+\tVSX insn support for negate, absolute value, and negative absolute\n+\tvalue.\n+\t(ieee_128bit_vsx_neg<mode>2): Likewise.\n+\t(ieee_128bit_vsx_neg<mode>2_internal): Likewise.\n+\t(ieee_128bit_vsx_abs<mode>2): Likewise.\n+\t(ieee_128bit_vsx_abs<mode>2_internal): Likewise.\n+\t(ieee_128bit_vsx_nabs<mode>2): Likewise.\n+\t(ieee_128bit_vsx_nabs<mode>2_internal): Likewise.\n+\t(FP128_64): Update pack/unpack 128-bit insns for IEEE 128-bit\n+\tfloating point in VSX registers.\n+\t(unpack<mode>_dm): Likewise.\n+\t(unpack<mode>_nodm): Likewise.\n+\t(pack<mode>): Likewise.\n+\t(unpackv1ti): Likewise.\n+\t(unpack<mode>, FMOVE128_VSX iterator): Likewise.\n+\t(packv1ti): Likewise.\n+\t(pack<mode>, FMOVE128_VSX iterator): Likewise.\n+\t(extenddftf2): Add support for IEEE 128-bit floating point in VSX\n+\tregisters.\n+\t(extenddftf2_internal): Likewise.\n+\t(trunctfdf2): Likewise.\n+\t(trunctfdf2_internal2): Likewise.\n+\t(fix_trunc_helper): Likewise.\n+\t(fix_trunctfdi2\"): Likewise.\n+\t(floatditf2): Likewise.\n+\t(floatuns<mode>tf2): Likewise.\n+\t(extend<FLOAT128_SFDFTF:mode><IFKF:mode>2): Likewise.\n+\t(trunc<IFKF:mode><FLOAT128_SFDFTF:mode>2): Likewise.\n+\t(fix_trunc<IFKF:mode><SDI:mode>2): Likewise.\n+\t(fixuns_trunc<IFKF:mode><SDI:mode>2): Likewise.\n+\t(float<SDI:mode><IFKF:mode>2): Likewise.\n+\t(floatuns<SDI:mode><IFKF:mode>2): Likewise.\n+\n+\n 2015-08-26  Renlin Li  <renlin.li@arm.com>\n \n \t* config/aarch64/aarch64.md (*aarch64_bfi<GPI:mode><ALLX:mode>4): New."}, {"sha": "b111df62df887490e1b49bbc2c45d3512660ab55", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/526303ecaaf13762aaad638ec8fa75fed778e332/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/526303ecaaf13762aaad638ec8fa75fed778e332/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=526303ecaaf13762aaad638ec8fa75fed778e332", "patch": "@@ -239,6 +239,25 @@\n   return INT_REGNO_P (REGNO (op));\n })\n \n+;; Like int_reg_operand, but don't return true for pseudo registers\n+(define_predicate \"int_reg_operand_not_pseudo\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  if ((TARGET_E500_DOUBLE || TARGET_SPE) && invalid_e500_subreg (op, mode))\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (!REG_P (op))\n+    return 0;\n+\n+  if (REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+    return 0;\n+\n+  return INT_REGNO_P (REGNO (op));\n+})\n+\n ;; Like int_reg_operand, but only return true for base registers\n (define_predicate \"base_reg_operand\"\n   (match_operand 0 \"int_reg_operand\")"}, {"sha": "7be529fab4972004b09276ea3bbe95fedad7a183", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/526303ecaaf13762aaad638ec8fa75fed778e332/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/526303ecaaf13762aaad638ec8fa75fed778e332/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=526303ecaaf13762aaad638ec8fa75fed778e332", "patch": "@@ -54,6 +54,7 @@ extern const char *output_vec_const_move (rtx *);\n extern const char *rs6000_output_move_128bit (rtx *);\n extern bool rs6000_move_128bit_ok_p (rtx []);\n extern bool rs6000_split_128bit_ok_p (rtx []);\n+extern void rs6000_expand_float128_convert (rtx, rtx, bool);\n extern void rs6000_expand_vector_init (rtx, rtx);\n extern void paired_expand_vector_init (rtx, rtx);\n extern void rs6000_expand_vector_set (rtx, rtx, int);"}, {"sha": "93fdece9a321caa27103d6a2613e39f51df0165a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 187, "deletions": 12, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/526303ecaaf13762aaad638ec8fa75fed778e332/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/526303ecaaf13762aaad638ec8fa75fed778e332/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=526303ecaaf13762aaad638ec8fa75fed778e332", "patch": "@@ -8485,7 +8485,7 @@ rs6000_emit_le_vsx_store (rtx dest, rtx source, machine_mode mode)\n      during expand.  */\n   gcc_assert (!reload_in_progress && !lra_in_progress && !reload_completed);\n \n-  /* Use V2DImode to do swaps of types with 128-bit scalare parts (TImode,\n+  /* Use V2DImode to do swaps of types with 128-bit scalar parts (TImode,\n      V1TImode).  */\n   if (mode == TImode || mode == V1TImode)\n     {\n@@ -18542,6 +18542,8 @@ rs6000_cannot_change_mode_class (machine_mode from,\n \t{\n \t  unsigned to_nregs = hard_regno_nregs[FIRST_FPR_REGNO][to];\n \t  unsigned from_nregs = hard_regno_nregs[FIRST_FPR_REGNO][from];\n+\t  bool to_float128_vector_p = FLOAT128_VECTOR_P (to);\n+\t  bool from_float128_vector_p = FLOAT128_VECTOR_P (from);\n \n \t  /* Don't allow 64-bit types to overlap with 128-bit types that take a\n \t     single register under VSX because the scalar part of the register\n@@ -18550,7 +18552,10 @@ rs6000_cannot_change_mode_class (machine_mode from,\n \t     IEEE floating point can't overlap, and neither can small\n \t     values.  */\n \n-\t  if (TARGET_IEEEQUAD && (to == TFmode || from == TFmode))\n+\t  if (to_float128_vector_p && from_float128_vector_p)\n+\t    return false;\n+\n+\t  else if (to_float128_vector_p || from_float128_vector_p)\n \t    return true;\n \n \t  /* TDmode in floating-mode registers must always go into a register\n@@ -18578,6 +18583,8 @@ rs6000_cannot_change_mode_class (machine_mode from,\n   if (TARGET_E500_DOUBLE\n       && ((((to) == DFmode) + ((from) == DFmode)) == 1\n \t  || (((to) == TFmode) + ((from) == TFmode)) == 1\n+\t  || (((to) == IFmode) + ((from) == IFmode)) == 1\n+\t  || (((to) == KFmode) + ((from) == KFmode)) == 1\n \t  || (((to) == DDmode) + ((from) == DDmode)) == 1\n \t  || (((to) == TDmode) + ((from) == TDmode)) == 1\n \t  || (((to) == DImode) + ((from) == DImode)) == 1))\n@@ -18774,13 +18781,7 @@ rs6000_output_move_128bit (rtx operands[])\n \treturn output_vec_const_move (operands);\n     }\n \n-  if (TARGET_DEBUG_ADDR)\n-    {\n-      fprintf (stderr, \"\\n===== Bad 128 bit move:\\n\");\n-      debug_rtx (gen_rtx_SET (dest, src));\n-    }\n-\n-  gcc_unreachable ();\n+  fatal_insn (\"Bad 128-bit move\", gen_rtx_SET (dest, src));\n }\n \n /* Validate a 128-bit move.  */\n@@ -19824,6 +19825,8 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n \t      break;\n \n \t    case TFmode:\n+\t    case IFmode:\n+\t    case KFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n \t\t? gen_tsttfeq_gpr (compare_result, op0, op1)\n \t\t: gen_cmptfeq_gpr (compare_result, op0, op1);\n@@ -19851,6 +19854,8 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n \t      break;\n \n \t    case TFmode:\n+\t    case IFmode:\n+\t    case KFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n \t\t? gen_tsttfgt_gpr (compare_result, op0, op1)\n \t\t: gen_cmptfgt_gpr (compare_result, op0, op1);\n@@ -19878,6 +19883,8 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n \t      break;\n \n \t    case TFmode:\n+\t    case IFmode:\n+\t    case KFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n \t\t? gen_tsttflt_gpr (compare_result, op0, op1)\n \t\t: gen_cmptflt_gpr (compare_result, op0, op1);\n@@ -19915,6 +19922,8 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n \t      break;\n \n \t    case TFmode:\n+\t    case IFmode:\n+\t    case KFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n \t\t? gen_tsttfeq_gpr (compare_result2, op0, op1)\n \t\t: gen_cmptfeq_gpr (compare_result2, op0, op1);\n@@ -19937,14 +19946,117 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n \n       emit_insn (cmp);\n     }\n+\n+  /* IEEE 128-bit support in VSX registers.  The comparison function (__cmpkf2)\n+     returns 0..15 that is laid out the same way as the PowerPC CR register\n+     would for a normal floating point comparison.  */\n+  else if (FLOAT128_IEEE_P (mode))\n+    {\n+      rtx and_reg = gen_reg_rtx (SImode);\n+      rtx dest = gen_reg_rtx (SImode);\n+      rtx libfunc = optab_libfunc (cmp_optab, mode);\n+      HOST_WIDE_INT mask_value = 0;\n+\n+      /* Values that __cmpkf2 returns.  */\n+#define PPC_CMP_UNORDERED\t0x1\t\t/* isnan (a) || isnan (b).  */\n+#define PPC_CMP_EQUAL\t\t0x2\t\t/* a == b.  */\n+#define PPC_CMP_GREATER_THEN\t0x4\t\t/* a > b.  */\n+#define PPC_CMP_LESS_THEN\t0x8\t\t/* a < b.  */\n+\n+      switch (code)\n+\t{\n+\tcase EQ:\n+\t  mask_value = PPC_CMP_EQUAL;\n+\t  code = NE;\n+\t  break;\n+\n+\tcase NE:\n+\t  mask_value = PPC_CMP_EQUAL;\n+\t  code = EQ;\n+\t  break;\n+\n+\tcase GT:\n+\t  mask_value = PPC_CMP_GREATER_THEN;\n+\t  code = NE;\n+\t  break;\n+\n+\tcase GE:\n+\t  mask_value = PPC_CMP_GREATER_THEN | PPC_CMP_EQUAL;\n+\t  code = NE;\n+\t  break;\n+\n+\tcase LT:\n+\t  mask_value = PPC_CMP_LESS_THEN;\n+\t  code = NE;\n+\t  break;\n+\n+\tcase LE:\n+\t  mask_value = PPC_CMP_LESS_THEN | PPC_CMP_EQUAL;\n+\t  code = NE;\n+\t  break;\n+\n+\tcase UNLE:\n+\t  mask_value = PPC_CMP_GREATER_THEN;\n+\t  code = EQ;\n+\t  break;\n+\n+\tcase UNLT:\n+\t  mask_value = PPC_CMP_GREATER_THEN | PPC_CMP_EQUAL;\n+\t  code = EQ;\n+\t  break;\n+\n+\tcase UNGE:\n+\t  mask_value = PPC_CMP_LESS_THEN;\n+\t  code = EQ;\n+\t  break;\n+\n+\tcase UNGT:\n+\t  mask_value = PPC_CMP_LESS_THEN | PPC_CMP_EQUAL;\n+\t  code = EQ;\n+\t  break;\n+\n+\tcase UNEQ:\n+\t  mask_value = PPC_CMP_EQUAL | PPC_CMP_UNORDERED;\n+\t  code = NE;\n+\n+\tcase LTGT:\n+\t  mask_value = PPC_CMP_EQUAL | PPC_CMP_UNORDERED;\n+\t  code = EQ;\n+\t  break;\n+\n+\tcase UNORDERED:\n+\t  mask_value = PPC_CMP_UNORDERED;\n+\t  code = NE;\n+\t  break;\n+\n+\tcase ORDERED:\n+\t  mask_value = PPC_CMP_UNORDERED;\n+\t  code = EQ;\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      gcc_assert (mask_value != 0);\n+      and_reg = emit_library_call_value (libfunc, and_reg, LCT_CONST, SImode, 2,\n+\t\t\t\t\t op0, mode, op1, mode);\n+\n+      emit_insn (gen_andsi3 (dest, and_reg, GEN_INT (mask_value)));\n+      compare_result = gen_reg_rtx (CCmode);\n+      comp_mode = CCmode;\n+\n+      emit_insn (gen_rtx_SET (compare_result,\n+\t\t\t      gen_rtx_COMPARE (comp_mode, dest, const0_rtx)));\n+    }\n+\n   else\n     {\n       /* Generate XLC-compatible TFmode compare as PARALLEL with extra\n \t CLOBBERs to match cmptf_internal2 pattern.  */\n       if (comp_mode == CCFPmode && TARGET_XL_COMPAT\n-\t  && GET_MODE (op0) == TFmode\n-\t  && !TARGET_IEEEQUAD\n-\t  && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128)\n+\t  && FLOAT128_IBM_P (GET_MODE (op0))\n+\t  && TARGET_HARD_FLOAT && TARGET_FPRS)\n \temit_insn (gen_rtx_PARALLEL (VOIDmode,\n \t  gen_rtvec (10,\n \t\t     gen_rtx_SET (compare_result,\n@@ -19977,6 +20089,7 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n   /* Some kinds of FP comparisons need an OR operation;\n      under flag_finite_math_only we don't bother.  */\n   if (FLOAT_MODE_P (mode)\n+      && !FLOAT128_IEEE_P (mode)\n       && !flag_finite_math_only\n       && !(TARGET_HARD_FLOAT && !TARGET_FPRS)\n       && (code == LE || code == GE\n@@ -20016,6 +20129,68 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n }\n \n \n+/* Expand floating point conversion to/from __float128 and __ibm128.  */\n+\n+void\n+rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n+{\n+  machine_mode dest_mode = GET_MODE (dest);\n+  machine_mode src_mode = GET_MODE (src);\n+  convert_optab cvt = unknown_optab;\n+  rtx libfunc = NULL_RTX;\n+  rtx dest2;\n+\n+  if (dest_mode == src_mode)\n+    gcc_unreachable ();\n+\n+  if (FLOAT128_IEEE_P (dest_mode))\n+    {\n+      if (src_mode == SFmode\n+\t  || src_mode == DFmode\n+\t  || FLOAT128_IBM_P (src_mode))\n+\tcvt = sext_optab;\n+\n+      else if (GET_MODE_CLASS (src_mode) == MODE_INT)\n+\tcvt = (unsigned_p) ? ufloat_optab : sfloat_optab;\n+\n+      else if (FLOAT128_IEEE_P (src_mode))\n+\temit_move_insn (dest, gen_lowpart (dest_mode, src));\n+\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n+  else if (FLOAT128_IEEE_P (src_mode))\n+    {\n+      if (dest_mode == SFmode\n+\t  || dest_mode == DFmode\n+\t  || FLOAT128_IBM_P (dest_mode))\n+\tcvt = trunc_optab;\n+\n+      else if (GET_MODE_CLASS (dest_mode) == MODE_INT)\n+\tcvt = (unsigned_p) ? ufix_optab : sfix_optab;\n+\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n+  else\n+    gcc_unreachable ();\n+\n+  gcc_assert (cvt != unknown_optab);\n+  libfunc = convert_optab_libfunc (cvt, dest_mode, src_mode);\n+  gcc_assert (libfunc != NULL_RTX);\n+\n+  dest2 = emit_library_call_value (libfunc, dest, LCT_CONST, dest_mode, 1, src,\n+\t\t\t\t   src_mode);\n+\n+  gcc_assert (dest != NULL_RTX);\n+  if (!rtx_equal_p (dest, dest2))\n+    emit_move_insn (dest, dest2);\n+\n+  return;\n+}\n+\n /* Emit the RTL for an sISEL pattern.  */\n \n void"}, {"sha": "48abc26634956655e9eacbf7c0152a99d6ae9550", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 354, "deletions": 62, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/526303ecaaf13762aaad638ec8fa75fed778e332/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/526303ecaaf13762aaad638ec8fa75fed778e332/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=526303ecaaf13762aaad638ec8fa75fed778e332", "patch": "@@ -348,6 +348,8 @@\n    && TARGET_HARD_FLOAT\n    && (TARGET_FPRS || TARGET_E500_DOUBLE)\n    && TARGET_LONG_DOUBLE_128\")\n+  (IF \"TARGET_FLOAT128\")\n+  (KF \"TARGET_FLOAT128\")\n   (DD \"TARGET_DFP\")\n   (TD \"TARGET_DFP\")])\n \n@@ -365,9 +367,14 @@\n (define_mode_iterator FMOVE32 [SF SD])\n (define_mode_iterator FMOVE64 [DF DD])\n (define_mode_iterator FMOVE64X [DI DF DD])\n-(define_mode_iterator FMOVE128 [(TF \"!TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\")\n+(define_mode_iterator FMOVE128 [(TF \"TARGET_LONG_DOUBLE_128\")\n+\t\t\t\t(IF \"TARGET_LONG_DOUBLE_128\")\n \t\t\t\t(TD \"TARGET_HARD_FLOAT && TARGET_FPRS\")])\n \n+(define_mode_iterator FMOVE128_FPR [(TF \"FLOAT128_2REG_P (TFmode)\")\n+\t\t\t\t    (IF \"FLOAT128_2REG_P (IFmode)\")\n+\t\t\t\t    (TD \"TARGET_HARD_FLOAT && TARGET_FPRS\")])\n+\n ; Iterators for 128 bit types for direct move\n (define_mode_iterator FMOVE128_GPR [(TI    \"TARGET_VSX_TIMODE\")\n \t\t\t\t    (V16QI \"\")\n@@ -376,7 +383,13 @@\n \t\t\t\t    (V4SF  \"\")\n \t\t\t\t    (V2DI  \"\")\n \t\t\t\t    (V2DF  \"\")\n-\t\t\t\t    (V1TI  \"\")])\n+\t\t\t\t    (V1TI  \"\")\n+\t\t\t\t    (KF    \"\")\n+\t\t\t\t    (TF    \"\")\n+\t\t\t\t    (IF    \"\")])\n+\n+; Iterator for 128-bit VSX types for pack/unpack\n+(define_mode_iterator FMOVE128_VSX [V1TI KF])\n \n ; Whether a floating point move is ok, don't allow SD without hardware FP\n (define_mode_attr fmove_ok [(SF \"\")\n@@ -432,6 +445,25 @@\n ; Iterator for just SF/DF\n (define_mode_iterator SFDF [SF DF])\n \n+; Iterator for float128 floating conversions\n+(define_mode_iterator FLOAT128_SFDFTF [\n+    (SF \"TARGET_FLOAT128\")\n+    (DF \"TARGET_FLOAT128\")\n+    (TF \"FLOAT128_IBM_P (TFmode)\")\n+    (IF \"TARGET_FLOAT128\")])\n+\n+; Iterator for special 128-bit floating point.  This is for non-default\n+; conversions, so TFmode is not used here.\n+(define_mode_iterator IFKF [IF KF])\n+\n+; Iterator for 128-bit floating point that uses the IBM double-double format\n+(define_mode_iterator IBM128 [IF TF])\n+\n+; Iterator for 128-bit floating point\n+(define_mode_iterator TFIFKF [(KF \"TARGET_FLOAT128\")\n+\t\t\t      (IF \"TARGET_FLOAT128\")\n+\t\t\t      (TF \"TARGET_LONG_DOUBLE_128\")])\n+\n ; SF/DF suffix for traditional floating instructions\n (define_mode_attr Ftrad\t\t[(SF \"s\") (DF \"\")])\n \n@@ -596,7 +628,7 @@\n ;; Reload iterator for creating the function to allocate a base register to\n ;; supplement addressing modes.\n (define_mode_iterator RELOAD [V16QI V8HI V4SI V2DI V4SF V2DF V1TI\n-\t\t\t      SF SD SI DF DD DI TI PTI])\n+\t\t\t      SF SD SI DF DD DI TI PTI KF IF TF])\n \n \f\n ;; Start with fixed-point load and store insns.  Here we put only the more\n@@ -4204,19 +4236,18 @@\n ;; This expander is here to avoid FLOAT_WORDS_BIGENDIAN tests in\n ;; builtins.c and optabs.c that are not correct for IBM long double\n ;; when little-endian.\n-(define_expand \"signbittf2\"\n+(define_expand \"signbit<mode>2\"\n   [(set (match_dup 2)\n-\t(float_truncate:DF (match_operand:TF 1 \"gpc_reg_operand\" \"\")))\n+\t(float_truncate:DF (match_operand:IBM128 1 \"gpc_reg_operand\" \"\")))\n    (set (match_dup 3)\n    \t(subreg:DI (match_dup 2) 0))\n    (set (match_dup 4)\n    \t(match_dup 5))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n   \t(match_dup 6))]\n-  \"!TARGET_IEEEQUAD\n+  \"FLOAT128_IBM_P (<MODE>mode)\n    && TARGET_HARD_FLOAT\n-   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n-   && TARGET_LONG_DOUBLE_128\"\n+   && (TARGET_FPRS || TARGET_E500_DOUBLE)\"\n {\n   operands[2] = gen_reg_rtx (DFmode);\n   operands[3] = gen_reg_rtx (DImode);\n@@ -6390,9 +6421,10 @@\n ;; problematical.  Don't allow direct move for this case.\n \n (define_insn_and_split \"*mov<mode>_64bit_dm\"\n-  [(set (match_operand:FMOVE128 0 \"nonimmediate_operand\" \"=m,d,d,ws,Y,r,r,r,wm\")\n-\t(match_operand:FMOVE128 1 \"input_operand\" \"d,m,d,j,r,jY,r,wm,r\"))]\n+  [(set (match_operand:FMOVE128_FPR 0 \"nonimmediate_operand\" \"=m,d,d,ws,Y,r,r,r,wm\")\n+\t(match_operand:FMOVE128_FPR 1 \"input_operand\" \"d,m,d,j,r,jY,r,wm,r\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_POWERPC64\n+   && FLOAT128_2REG_P (<MODE>mode)\n    && (<MODE>mode != TDmode || WORDS_BIG_ENDIAN)\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n@@ -6415,9 +6447,12 @@\n   [(set_attr \"length\" \"8,8,8,8,12,12,8\")])\n \n (define_insn_and_split \"*mov<mode>_32bit\"\n-  [(set (match_operand:FMOVE128 0 \"nonimmediate_operand\" \"=m,d,d,ws,Y,r,r\")\n-\t(match_operand:FMOVE128 1 \"input_operand\" \"d,m,d,j,r,jY,r\"))]\n+  [(set (match_operand:FMOVE128_FPR 0 \"nonimmediate_operand\" \"=m,d,d,ws,Y,r,r\")\n+\t(match_operand:FMOVE128_FPR 1 \"input_operand\" \"d,m,d,j,r,jY,r\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && !TARGET_POWERPC64\n+   && (FLOAT128_2REG_P (<MODE>mode)\n+       || int_reg_operand_not_pseudo (operands[0], <MODE>mode)\n+       || int_reg_operand_not_pseudo (operands[1], <MODE>mode))\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n   \"#\"\n@@ -6441,12 +6476,12 @@\n (define_expand \"extenddftf2\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n \t(float_extend:TF (match_operand:DF 1 \"input_operand\" \"\")))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT\n-   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n+  \"TARGET_HARD_FLOAT && (TARGET_FPRS || TARGET_E500_DOUBLE)\n    && TARGET_LONG_DOUBLE_128\"\n {\n-  if (TARGET_E500_DOUBLE)\n+  if (TARGET_IEEEQUAD)\n+    rs6000_expand_float128_convert (operands[0], operands[1], false);\n+  else if (TARGET_E500_DOUBLE)\n     emit_insn (gen_spe_extenddftf2 (operands[0], operands[1]));\n   else\n     emit_insn (gen_extenddftf2_fprs (operands[0], operands[1]));\n@@ -6495,25 +6530,34 @@\n (define_expand \"extendsftf2\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n \t(float_extend:TF (match_operand:SF 1 \"gpc_reg_operand\" \"\")))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT\n+  \"TARGET_HARD_FLOAT\n    && (TARGET_FPRS || TARGET_E500_DOUBLE)\n    && TARGET_LONG_DOUBLE_128\"\n {\n-  rtx tmp = gen_reg_rtx (DFmode);\n-  emit_insn (gen_extendsfdf2 (tmp, operands[1]));\n-  emit_insn (gen_extenddftf2 (operands[0], tmp));\n+  if (TARGET_IEEEQUAD)\n+    rs6000_expand_float128_convert (operands[0], operands[1], false);\n+  else\n+    {\n+      rtx tmp = gen_reg_rtx (DFmode);\n+      emit_insn (gen_extendsfdf2 (tmp, operands[1]));\n+      emit_insn (gen_extenddftf2 (operands[0], tmp));\n+    }\n   DONE;\n })\n \n (define_expand \"trunctfdf2\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(float_truncate:DF (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT\n+  \"TARGET_HARD_FLOAT\n    && (TARGET_FPRS || TARGET_E500_DOUBLE)\n    && TARGET_LONG_DOUBLE_128\"\n-  \"\")\n+{\n+  if (TARGET_IEEEQUAD)\n+    {\n+      rs6000_expand_float128_convert (operands[0], operands[1], false);\n+      DONE;\n+    }\n+})\n \n (define_insn_and_split \"trunctfdf2_internal1\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,?d\")\n@@ -6544,12 +6588,13 @@\n (define_expand \"trunctfsf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n \t(float_truncate:SF (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT\n+  \"TARGET_HARD_FLOAT\n    && (TARGET_FPRS || TARGET_E500_DOUBLE)\n    && TARGET_LONG_DOUBLE_128\"\n {\n-  if (TARGET_E500_DOUBLE)\n+  if (TARGET_IEEEQUAD)\n+    rs6000_expand_float128_convert (operands[0], operands[1], false);\n+  else if (TARGET_E500_DOUBLE)\n     emit_insn (gen_spe_trunctfsf2 (operands[0], operands[1]));\n   else\n     emit_insn (gen_trunctfsf2_fprs (operands[0], operands[1]));\n@@ -6600,10 +6645,12 @@\n (define_expand \"fix_trunctfsi2\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(fix:SI (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n-  \"!TARGET_IEEEQUAD && TARGET_HARD_FLOAT\n+  \"TARGET_HARD_FLOAT\n    && (TARGET_FPRS || TARGET_E500_DOUBLE) && TARGET_LONG_DOUBLE_128\"\n {\n-  if (TARGET_E500_DOUBLE)\n+  if (TARGET_IEEEQUAD)\n+    rs6000_expand_float128_convert (operands[0], operands[1], false);\n+  else if (TARGET_E500_DOUBLE)\n     emit_insn (gen_spe_fix_trunctfsi2 (operands[0], operands[1]));\n   else\n     emit_insn (gen_fix_trunctfsi2_fprs (operands[0], operands[1]));\n@@ -6651,20 +6698,73 @@\n   DONE;\n })\n \n-(define_expand \"negtf2\"\n-  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n-\t(neg:TF (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT\n-   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n-   && TARGET_LONG_DOUBLE_128\"\n-  \"\")\n+(define_expand \"fix_trunctfdi2\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(fix:DI (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\"\n+{\n+  rs6000_expand_float128_convert (operands[0], operands[1], false);\n+  DONE;\n+})\n+\n+(define_expand \"fixuns_trunctf<mode>2\"\n+  [(set (match_operand:SDI 0 \"nonimmediate_operand\" \"\")\n+\t(unsigned_fix:SDI (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\"\n+{\n+  rs6000_expand_float128_convert (operands[0], operands[1], true);\n+  DONE;\n+})\n+\n+(define_expand \"floatditf2\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+\t(float:TF (match_operand:DI 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\"\n+{\n+  rs6000_expand_float128_convert (operands[0], operands[1], false);\n+  DONE;\n+})\n+\n+(define_expand \"floatuns<mode>tf2\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+\t(unsigned_float:TF (match_operand:SDI 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\"\n+{\n+  rs6000_expand_float128_convert (operands[0], operands[1], true);\n+  DONE;\n+})\n+\n+(define_expand \"neg<mode>2\"\n+  [(set (match_operand:TFIFKF 0 \"gpc_reg_operand\" \"\")\n+\t(neg:TFIFKF (match_operand:TFIFKF 1 \"gpc_reg_operand\" \"\")))]\n+  \"FLOAT128_IEEE_P (<MODE>mode)\n+   || (FLOAT128_IBM_P (<MODE>mode)\n+       && TARGET_HARD_FLOAT\n+       && (TARGET_FPRS || TARGET_E500_DOUBLE))\"\n+  \"\n+{\n+  if (FLOAT128_IEEE_P (<MODE>mode))\n+    {\n+      if (TARGET_FLOAT128)\n+\temit_insn (gen_ieee_128bit_vsx_neg<mode>2 (operands[0], operands[1]));\n+      else\n+\t{\n+\t  rtx libfunc = optab_libfunc (neg_optab, <MODE>mode);\n+\t  rtx target = emit_library_call_value (libfunc, operands[0], LCT_CONST,\n+\t\t\t\t\t\t<MODE>mode, 1,\n+\t\t\t\t\t\toperands[1], <MODE>mode);\n+\n+\t  if (target && !rtx_equal_p (target, operands[0]))\n+\t    emit_move_insn (operands[0], target);\n+\t}\n+      DONE;\n+    }\n+}\")\n \n (define_insn \"negtf2_internal\"\n   [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=d\")\n \t(neg:TF (match_operand:TF 1 \"gpc_reg_operand\" \"d\")))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && FLOAT128_IBM_P (TFmode)\"\n   \"*\n {\n   if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n@@ -6675,16 +6775,29 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"8\")])\n \n-(define_expand \"abstf2\"\n-  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n-\t(abs:TF (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT\n-   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n-   && TARGET_LONG_DOUBLE_128\"\n+(define_expand \"abs<mode>2\"\n+  [(set (match_operand:TFIFKF 0 \"gpc_reg_operand\" \"\")\n+\t(abs:TFIFKF (match_operand:TFIFKF 1 \"gpc_reg_operand\" \"\")))]\n+  \"FLOAT128_IEEE_P (<MODE>mode)\n+   || (FLOAT128_IBM_P (<MODE>mode)\n+       && TARGET_HARD_FLOAT\n+       && (TARGET_FPRS || TARGET_E500_DOUBLE))\"\n   \"\n {\n-  rtx label = gen_label_rtx ();\n+  rtx label;\n+\n+  if (FLOAT128_IEEE_P (<MODE>mode))\n+    {\n+      if (TARGET_FLOAT128)\n+\t{\n+\t  emit_insn (gen_ieee_128bit_vsx_abs<mode>2 (operands[0], operands[1]));\n+\t  DONE;\n+\t}\n+      else\n+\tFAIL;\n+    }\n+\n+  label = gen_label_rtx ();\n   if (TARGET_E500_DOUBLE)\n     {\n       if (flag_finite_math_only && !flag_trapping_math)\n@@ -6720,6 +6833,184 @@\n   operands[5] = simplify_gen_subreg (DFmode, operands[0], TFmode, hi_word);\n   operands[6] = simplify_gen_subreg (DFmode, operands[0], TFmode, lo_word);\n }\")\n+\n+\f\n+;; Generate IEEE 128-bit -0.0 (0x80000000000000000000000000000000) in a vector\n+;; register\n+\n+(define_expand \"ieee_128bit_negative_zero\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"\") (match_dup 1))]\n+  \"TARGET_FLOAT128\"\n+{\n+  rtvec v = rtvec_alloc (16);\n+  int i, high;\n+\n+  for (i = 0; i < 16; i++)\n+    RTVEC_ELT (v, i) = const0_rtx;\n+\n+  high = (BYTES_BIG_ENDIAN) ? 0 : 15;\n+  RTVEC_ELT (v, high) = GEN_INT (0x80);\n+\n+  rs6000_expand_vector_init (operands[0], gen_rtx_PARALLEL (V16QImode, v));\n+  DONE;\n+})\n+\n+;; IEEE 128-bit negate\n+\n+;; We have 2 insns here for negate and absolute value.  The first uses\n+;; match_scratch so that phases like combine can recognize neg/abs as generic\n+;; insns, and second insn after the first split pass loads up the bit to\n+;; twiddle the sign bit.  Later GCSE passes can then combine multiple uses of\n+;; neg/abs to create the constant just once.\n+\n+(define_insn_and_split \"ieee_128bit_vsx_neg<mode>2\"\n+  [(set (match_operand:TFIFKF 0 \"register_operand\" \"=wa\")\n+\t(neg:TFIFKF (match_operand:TFIFKF 1 \"register_operand\" \"wa\")))\n+   (clobber (match_scratch:V16QI 2 \"=v\"))]\n+  \"TARGET_FLOAT128 && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"#\"\n+  \"&& 1\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (neg:TFIFKF (match_dup 1)))\n+\t      (use (match_dup 2))])]\n+{\n+  if (GET_CODE (operands[2]) == SCRATCH)\n+    operands[2] = gen_reg_rtx (V16QImode);\n+\n+  operands[3] = gen_reg_rtx (V16QImode);\n+  emit_insn (gen_ieee_128bit_negative_zero (operands[2]));\n+}\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"*ieee_128bit_vsx_neg<mode>2_internal\"\n+  [(set (match_operand:TFIFKF 0 \"register_operand\" \"=wa\")\n+\t(neg:TFIFKF (match_operand:TFIFKF 1 \"register_operand\" \"wa\")))\n+   (use (match_operand:V16QI 2 \"register_operand\" \"=v\"))]\n+  \"TARGET_FLOAT128\"\n+  \"xxlxor %x0,%x1,%x2\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n+;; IEEE 128-bit absolute value\n+(define_insn_and_split \"ieee_128bit_vsx_abs<mode>2\"\n+  [(set (match_operand:TFIFKF 0 \"register_operand\" \"=wa\")\n+\t(abs:TFIFKF (match_operand:TFIFKF 1 \"register_operand\" \"wa\")))\n+   (clobber (match_scratch:V16QI 2 \"=v\"))]\n+  \"TARGET_FLOAT128 && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"#\"\n+  \"&& 1\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (abs:TFIFKF (match_dup 1)))\n+\t      (use (match_dup 2))])]\n+{\n+  if (GET_CODE (operands[2]) == SCRATCH)\n+    operands[2] = gen_reg_rtx (V16QImode);\n+\n+  operands[3] = gen_reg_rtx (V16QImode);\n+  emit_insn (gen_ieee_128bit_negative_zero (operands[2]));\n+}\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"*ieee_128bit_vsx_abs<mode>2_internal\"\n+  [(set (match_operand:TFIFKF 0 \"register_operand\" \"=wa\")\n+\t(abs:TFIFKF (match_operand:TFIFKF 1 \"register_operand\" \"wa\")))\n+   (use (match_operand:V16QI 2 \"register_operand\" \"=v\"))]\n+  \"TARGET_FLOAT128\"\n+  \"xxlandc %x0,%x1,%x2\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n+;; IEEE 128-bit negative absolute value\n+(define_insn_and_split \"*ieee_128bit_vsx_nabs<mode>2\"\n+  [(set (match_operand:TFIFKF 0 \"register_operand\" \"=wa\")\n+\t(neg:TFIFKF\n+\t (abs:TFIFKF\n+\t  (match_operand:TFIFKF 1 \"register_operand\" \"wa\"))))\n+   (clobber (match_scratch:V16QI 2 \"=v\"))]\n+  \"TARGET_FLOAT128 && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"#\"\n+  \"&& 1\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (abs:TFIFKF (match_dup 1)))\n+\t      (use (match_dup 2))])]\n+{\n+  if (GET_CODE (operands[2]) == SCRATCH)\n+    operands[2] = gen_reg_rtx (V16QImode);\n+\n+  operands[3] = gen_reg_rtx (V16QImode);\n+  emit_insn (gen_ieee_128bit_negative_zero (operands[2]));\n+}\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"*ieee_128bit_vsx_nabs<mode>2_internal\"\n+  [(set (match_operand:TFIFKF 0 \"register_operand\" \"=wa\")\n+\t(neg:TFIFKF\n+\t (abs:TFIFKF\n+\t  (match_operand:TFIFKF 1 \"register_operand\" \"wa\"))))\n+   (use (match_operand:V16QI 2 \"register_operand\" \"=v\"))]\n+  \"TARGET_FLOAT128\"\n+  \"xxlor %x0,%x1,%x2\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n+;; Float128 conversion functions.  These expand to library function calls.\n+\n+(define_expand \"extend<FLOAT128_SFDFTF:mode><IFKF:mode>2\"\n+  [(set (match_operand:IFKF 0 \"nonimmediate_operand\" \"\")\n+\t(float_extend:IFKF\n+\t (match_operand:FLOAT128_SFDFTF 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_FLOAT128\"\n+{\n+  rs6000_expand_float128_convert (operands[0], operands[1], false);\n+  DONE;\n+})\n+\n+(define_expand \"trunc<IFKF:mode><FLOAT128_SFDFTF:mode>2\"\n+  [(set (match_operand:FLOAT128_SFDFTF 0 \"nonimmediate_operand\" \"\")\n+\t(float_truncate:FLOAT128_SFDFTF\n+\t (match_operand:IFKF 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_FLOAT128\"\n+{\n+  rs6000_expand_float128_convert (operands[0], operands[1], false);\n+  DONE;\n+})\n+\n+(define_expand \"fix_trunc<IFKF:mode><SDI:mode>2\"\n+  [(set (match_operand:SDI 0 \"nonimmediate_operand\" \"\")\n+\t(fix:SDI (match_operand:IFKF 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_FLOAT128\"\n+{\n+  rs6000_expand_float128_convert (operands[0], operands[1], false);\n+  DONE;\n+})\n+\n+(define_expand \"fixuns_trunc<IFKF:mode><SDI:mode>2\"\n+  [(set (match_operand:SDI 0 \"nonimmediate_operand\" \"\")\n+\t(unsigned_fix:SDI (match_operand:IFKF 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_FLOAT128\"\n+{\n+  rs6000_expand_float128_convert (operands[0], operands[1], true);\n+  DONE;\n+})\n+\n+(define_expand \"float<SDI:mode><IFKF:mode>2\"\n+  [(set (match_operand:IFKF 0 \"nonimmediate_operand\" \"\")\n+\t(float:KF (match_operand:SDI 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_FLOAT128\"\n+{\n+  rs6000_expand_float128_convert (operands[0], operands[1], false);\n+  DONE;\n+})\n+\n+(define_expand \"floatuns<SDI:mode><IFKF:mode>2\"\n+  [(set (match_operand:IFKF 0 \"nonimmediate_operand\" \"\")\n+\t(unsigned_float:IFKF (match_operand:SDI 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_FLOAT128\"\n+{\n+  rs6000_expand_float128_convert (operands[0], operands[1], true);\n+  DONE;\n+})\n+\n \f\n ;; Reload helper functions used by rs6000_secondary_reload.  The patterns all\n ;; must have 3 arguments, and scratch register constraint must be a single\n@@ -12122,15 +12413,18 @@\n ;; Pack/unpack 128-bit floating point types that take 2 scalar registers\n \n ; Type of the 64-bit part when packing/unpacking 128-bit floating point types\n-(define_mode_attr FP128_64 [(TF \"DF\") (TD \"DI\")])\n+(define_mode_attr FP128_64 [(TF \"DF\")\n+\t\t\t    (IF \"DF\")\n+\t\t\t    (TD \"DI\")\n+\t\t\t    (KF \"DI\")])\n \n (define_expand \"unpack<mode>\"\n   [(set (match_operand:<FP128_64> 0 \"nonimmediate_operand\" \"\")\n \t(unspec:<FP128_64>\n \t [(match_operand:FMOVE128 1 \"register_operand\" \"\")\n \t  (match_operand:QI 2 \"const_0_to_1_operand\" \"\")]\n \t UNSPEC_UNPACK_128BIT))]\n-  \"\"\n+  \"FLOAT128_2REG_P (<MODE>mode)\"\n   \"\")\n \n (define_insn_and_split \"unpack<mode>_dm\"\n@@ -12139,7 +12433,7 @@\n \t [(match_operand:FMOVE128 1 \"register_operand\" \"d,d,r,d,r\")\n \t  (match_operand:QI 2 \"const_0_to_1_operand\" \"i,i,i,i,i\")]\n \t UNSPEC_UNPACK_128BIT))]\n-  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE && FLOAT128_2REG_P (<MODE>mode)\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0) (match_dup 3))]\n@@ -12163,7 +12457,7 @@\n \t [(match_operand:FMOVE128 1 \"register_operand\" \"d,d\")\n \t  (match_operand:QI 2 \"const_0_to_1_operand\" \"i,i\")]\n \t UNSPEC_UNPACK_128BIT))]\n-  \"!TARGET_POWERPC64 || !TARGET_DIRECT_MOVE\"\n+  \"(!TARGET_POWERPC64 || !TARGET_DIRECT_MOVE) && FLOAT128_2REG_P (<MODE>mode)\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0) (match_dup 3))]\n@@ -12187,7 +12481,7 @@\n \t [(match_operand:<FP128_64> 1 \"register_operand\" \"0,d\")\n \t  (match_operand:<FP128_64> 2 \"register_operand\" \"d,d\")]\n \t UNSPEC_PACK_128BIT))]\n-  \"\"\n+  \"FLOAT128_2REG_P (<MODE>mode)\"\n   \"@\n    fmr %L0,%2\n    #\"\n@@ -12207,32 +12501,30 @@\n   [(set_attr \"type\" \"fp,fp\")\n    (set_attr \"length\" \"4,8\")])\n \n-(define_insn \"unpackv1ti\"\n+(define_insn \"unpack<mode>\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n-\t(unspec:DI [(match_operand:V1TI 1 \"register_operand\" \"0,wa\")\n+\t(unspec:DI [(match_operand:FMOVE128_VSX 1 \"register_operand\" \"0,wa\")\n \t\t    (match_operand:QI 2 \"const_0_to_1_operand\" \"O,i\")]\n \t UNSPEC_UNPACK_128BIT))]\n-  \"TARGET_VSX\"\n+  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n {\n   if (REGNO (operands[0]) == REGNO (operands[1]) && INTVAL (operands[2]) == 0)\n     return ASM_COMMENT_START \" xxpermdi to same register\";\n \n   operands[3] = GEN_INT (INTVAL (operands[2]) == 0 ? 0 : 3);\n   return \"xxpermdi %x0,%x1,%x1,%3\";\n }\n-  [(set_attr \"type\" \"vecperm\")\n-   (set_attr \"length\" \"4\")])\n+  [(set_attr \"type\" \"vecperm\")])\n \n-(define_insn \"packv1ti\"\n-  [(set (match_operand:V1TI 0 \"register_operand\" \"=wa\")\n-\t(unspec:V1TI\n+(define_insn \"pack<mode>\"\n+  [(set (match_operand:FMOVE128_VSX 0 \"register_operand\" \"=wa\")\n+\t(unspec:FMOVE128_VSX\n \t [(match_operand:DI 1 \"register_operand\" \"d\")\n \t  (match_operand:DI 2 \"register_operand\" \"d\")]\n \t UNSPEC_PACK_128BIT))]\n   \"TARGET_VSX\"\n   \"xxpermdi %x0,%x1,%x2,0\"\n-  [(set_attr \"type\" \"vecperm\")\n-   (set_attr \"length\" \"4\")])\n+  [(set_attr \"type\" \"vecperm\")])\n \n \f\n "}]}