{"sha": "a9711f360bc99dee33c249e47caf9d5144ab0000", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk3MTFmMzYwYmM5OWRlZTMzYzI0OWU0N2NhZjlkNTE0NGFiMDAwMA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2014-01-21T19:15:40Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2014-01-21T19:15:40Z"}, "message": "re PR rtl-optimization/59858 (ICE: assign_by_spills, at lra-assigns.c:1283)\n\n2014-01-21  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/59858\n\t* lra-constraints.c (SMALL_REGISTER_CLASS_P): Use\n\tira_class_hard_regs_num.\n\t(process_alt_operands): Increase reject for dying matched operand.\n\n2014-01-21  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/59858\n\t* gcc.target/arm/pr59858.c: New.\n\nFrom-SVN: r206897", "tree": {"sha": "459e1dcb7d902e824bd5c5d271e9cb7cf7978955", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/459e1dcb7d902e824bd5c5d271e9cb7cf7978955"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9711f360bc99dee33c249e47caf9d5144ab0000", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9711f360bc99dee33c249e47caf9d5144ab0000", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9711f360bc99dee33c249e47caf9d5144ab0000", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9711f360bc99dee33c249e47caf9d5144ab0000/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f8ea7cb08dc13e3cb78bb3b4017c556c9838263b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8ea7cb08dc13e3cb78bb3b4017c556c9838263b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8ea7cb08dc13e3cb78bb3b4017c556c9838263b"}], "stats": {"total": 211, "additions": 197, "deletions": 14}, "files": [{"sha": "aea384ee69d936ffc4da0c6238115a83414c553c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9711f360bc99dee33c249e47caf9d5144ab0000/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9711f360bc99dee33c249e47caf9d5144ab0000/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9711f360bc99dee33c249e47caf9d5144ab0000", "patch": "@@ -1,3 +1,10 @@\n+2014-01-21  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/59858\n+\t* lra-constraints.c (SMALL_REGISTER_CLASS_P): Use\n+\tira_class_hard_regs_num.\n+\t(process_alt_operands): Increase reject for dying matched operand.\n+\n 2014-01-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/59003"}, {"sha": "7a2d065b55bb8f9cbe97ee499a3076f09ece9e47", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9711f360bc99dee33c249e47caf9d5144ab0000/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9711f360bc99dee33c249e47caf9d5144ab0000/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=a9711f360bc99dee33c249e47caf9d5144ab0000", "patch": "@@ -688,9 +688,10 @@ operands_match_p (rtx x, rtx y, int y_hard_regno)\n \n /* True if C is a non-empty register class that has too few registers\n    to be safely used as a reload target class.\t*/\n-#define SMALL_REGISTER_CLASS_P(C)\t\t\t\t\t\\\n-  (reg_class_size [(C)] == 1\t\t\t\t\t\t\\\n-   || (reg_class_size [(C)] >= 1 && targetm.class_likely_spilled_p (C)))\n+#define SMALL_REGISTER_CLASS_P(C)\t\t\\\n+  (ira_class_hard_regs_num [(C)] == 1\t\t\\\n+   || (ira_class_hard_regs_num [(C)] >= 1\t\\\n+       && targetm.class_likely_spilled_p (C)))\n \n /* If REG is a reload pseudo, try to make its class satisfying CL.  */\n static void\n@@ -2113,17 +2114,25 @@ process_alt_operands (int only_alternative)\n \t\t}\n \t      /* If the operand is dying, has a matching constraint,\n \t\t and satisfies constraints of the matched operand\n-\t\t which failed to satisfy the own constraints, we do\n-\t\t not need to generate a reload insn for this\n-\t\t operand.  */\n-\t      if (!(this_alternative_matches >= 0\n-\t\t    && !curr_alt_win[this_alternative_matches]\n-\t\t    && REG_P (op)\n-\t\t    && find_regno_note (curr_insn, REG_DEAD, REGNO (op))\n-\t\t    && (hard_regno[nop] >= 0\n-\t\t\t? in_hard_reg_set_p (this_alternative_set,\n-\t\t\t\t\t     mode, hard_regno[nop])\n-\t\t\t: in_class_p (op, this_alternative, NULL))))\n+\t\t which failed to satisfy the own constraints, probably\n+\t\t the reload for this operand will be gone.  */\n+\t      if (this_alternative_matches >= 0\n+\t\t  && !curr_alt_win[this_alternative_matches]\n+\t\t  && REG_P (op)\n+\t\t  && find_regno_note (curr_insn, REG_DEAD, REGNO (op))\n+\t\t  && (hard_regno[nop] >= 0\n+\t\t      ? in_hard_reg_set_p (this_alternative_set,\n+\t\t\t\t\t   mode, hard_regno[nop])\n+\t\t      : in_class_p (op, this_alternative, NULL)))\n+\t\t{\n+\t\t  if (lra_dump_file != NULL)\n+\t\t    fprintf\n+\t\t      (lra_dump_file,\n+\t\t       \"            %d Dying matched operand reload: reject++\\n\",\n+\t\t       nop);\n+\t\t  reject++;\n+\t\t}\n+\t      else\n \t\t{\n \t\t  /* Strict_low_part requires to reload the register\n \t\t     not the sub-register.  In this case we should"}, {"sha": "deae651145126689e53bc5807e98e61dbfcb5cf0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9711f360bc99dee33c249e47caf9d5144ab0000/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9711f360bc99dee33c249e47caf9d5144ab0000/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a9711f360bc99dee33c249e47caf9d5144ab0000", "patch": "@@ -1,3 +1,8 @@\n+2014-01-21  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/59858\n+\t* gcc.target/arm/pr59858.c: New.\n+\n 2014-01-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/59003"}, {"sha": "463bd38f715d71896d2bbc38aa1546a61e5470c1", "filename": "gcc/testsuite/gcc.target/arm/pr59858.c", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9711f360bc99dee33c249e47caf9d5144ab0000/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr59858.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9711f360bc99dee33c249e47caf9d5144ab0000/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr59858.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr59858.c?ref=a9711f360bc99dee33c249e47caf9d5144ab0000", "patch": "@@ -0,0 +1,162 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=armv5te -marm -mthumb-interwork -Wall -Wstrict-prototypes -Wstrict-aliasing -funsigned-char -fno-builtin -fno-asm -msoft-float -std=gnu99 -mlittle-endian -mthumb -fno-stack-protector  -Os -g -feliminate-unused-debug-types -funit-at-a-time -fmerge-all-constants -fstrict-aliasing -fno-tree-loop-optimize -fno-tree-dominator-opts -fno-strength-reduce -fPIC -w\" } */\n+\n+typedef enum {\n+ REG_ENOSYS = -1,\n+} reg_errcode_t;\n+typedef unsigned long int bitset_word_t;\n+typedef bitset_word_t bitset_t[(256 / (sizeof (bitset_word_t) * 8))];\n+typedef bitset_word_t *re_bitset_ptr_t;\n+typedef const bitset_word_t *re_const_bitset_ptr_t;\n+typedef struct {\n+ int nelem;\n+ int *elems;\n+} re_node_set;\n+typedef enum {\n+ CHARACTER = 1,\n+} re_token_type_t;\n+typedef struct {\n+ re_token_type_t type:8;\n+ unsigned int word_char:1;\n+} re_token_t;\n+struct re_string_t {\n+ const unsigned char *raw_mbs;\n+ int raw_mbs_idx;\n+ int cur_idx;\n+ unsigned int tip_context;\n+ re_const_bitset_ptr_t word_char;\n+};\n+typedef struct re_string_t re_string_t;\n+typedef struct re_dfa_t re_dfa_t;\n+struct re_dfastate_t {\n+ re_node_set nodes;\n+};\n+typedef struct re_dfastate_t re_dfastate_t;\n+typedef struct {\n+ re_dfastate_t **array;\n+} state_array_t;\n+typedef struct {\n+ state_array_t path;\n+} re_sub_match_last_t;\n+typedef struct {\n+ int nlasts;\n+ re_sub_match_last_t **lasts;\n+} re_sub_match_top_t;\n+typedef struct {\n+ re_string_t input;\n+ const re_dfa_t *dfa;\n+ int nsub_tops;\n+ re_sub_match_top_t **sub_tops;\n+} re_match_context_t;\n+struct re_dfa_t {\n+ re_token_t *nodes;\n+ re_bitset_ptr_t sb_char;\n+ int mb_cur_max;\n+ bitset_t word_char;\n+} bracket_elem_t;\n+static reg_errcode_t\n+re_string_reconstruct (\n+ re_string_t * pstr,\n+ int idx,\n+ int eflags\n+)\n+{\n+ int offset = idx - pstr->raw_mbs_idx;\n+ int c = pstr->raw_mbs[pstr->raw_mbs_idx + offset - 1];\n+ pstr->tip_context = ((pstr->word_char[c] & ((bitset_word_t) 1)) ? : (c));\n+}\n+\n+static void match_ctx_clean (\n+ re_match_context_t *\n+);\n+static int check_matching (\n+);\n+static re_dfastate_t *transit_state (\n+);\n+static int build_trtable (\n+);\n+re_search_internal (int eflags\n+)\n+{\n+ reg_errcode_t err;\n+ int incr;\n+ int\n+  match_first,\n+  match_last = -1;\n+ re_match_context_t mctx;\n+ err = re_string_allocate (&mctx.input);\n+ for (;; match_first += incr)\n+  {\n+   err = re_string_reconstruct (&mctx.input, match_first, eflags);\n+   err = re_string_reconstruct (&mctx.input, match_first, eflags);\n+   match_last = check_matching (&mctx, &match_first);\n+   match_ctx_clean (&mctx);\n+  }\n+}\n+\n+check_matching (re_match_context_t * mctx, int *p_match_first\n+)\n+{\n+ int cur_str_idx = ((&mctx->input)->cur_idx);\n+ re_dfastate_t *cur_state;\n+ int next_start_idx = cur_str_idx;\n+ cur_state = transit_state (mctx, cur_state);\n+ *p_match_first += next_start_idx;\n+}\n+\n+static re_dfastate_t *\n+transit_state (\n+ re_match_context_t * mctx,\n+ re_dfastate_t * state\n+)\n+{\n+ if (!build_trtable (mctx->dfa, state))\n+  {\n+  }\n+}\n+\n+build_trtable (const re_dfa_t * dfa,\n+\t             re_dfastate_t * state\n+)\n+{\n+ int i,\n+  j;\n+ bitset_t accepts;\n+ const re_node_set *cur_nodes = &state->nodes;\n+ for (i = 0; i < cur_nodes->nelem; ++i)\n+  {\n+   re_token_t *node = &dfa->nodes[cur_nodes->elems[i]];\n+   re_token_type_t type = node->type;\n+   {\n+    if (dfa->mb_cur_max > 1)\n+     bitset_merge (accepts, dfa->sb_char);\n+    {\n+     bitset_word_t any_set = 0;\n+     if (type == CHARACTER && !node->word_char)\n+      any_set |= (accepts[j] &= (dfa->word_char[j] | ~dfa->sb_char[j]));\n+     else\n+      for (j = 0; j < (256 / (sizeof (bitset_word_t) * 8)); ++j)\n+       any_set |= (accepts[j] &= dfa->word_char[j]);\n+    }\n+   }\n+  }\n+}\n+\n+static void\n+match_ctx_clean (\n+ re_match_context_t * mctx\n+)\n+{\n+ int st_idx;\n+ for (st_idx = 0; st_idx < mctx->nsub_tops; ++st_idx)\n+  {\n+   int sl_idx;\n+   re_sub_match_top_t *top = mctx->sub_tops[st_idx];\n+   for (sl_idx = 0; sl_idx < top->nlasts; ++sl_idx)\n+    {\n+     re_sub_match_last_t *last = top->lasts[sl_idx];\n+     free (last->path.array);\n+    }\n+  }\n+}\n+"}]}