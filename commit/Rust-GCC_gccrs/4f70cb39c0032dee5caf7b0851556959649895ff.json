{"sha": "4f70cb39c0032dee5caf7b0851556959649895ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY3MGNiMzljMDAzMmRlZTVjYWY3YjA4NTE1NTY5NTk2NDk4OTVmZg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-11-09T03:19:09Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-11-09T03:19:09Z"}, "message": "[PATCH] Remove backedge handling support in tree-ssa-threadupdate.c\n\n\t* tree-ssa-threadupdate.c (register_jump_thraed): Assert that a\n\tnon-FSM path has no edges marked with EDGE_DFS_BACK.\n\t(ssa_redirect_edges): No longer call mark_loop_for_removal.\n\t(thread_single_edge, def_split_header_continue_p): Remove.\n\t(bb_ends_with_multiway_branch): Likewise.\n\t(thread_through_loop_header): Remove cases of threading from\n\tlatch through the header.  Simplify knowing we won't thread\n\tthe latch.\n\t(thread_through_all_blocks): Simplify knowing that only the FSM\n\tthreader needs to handle backedges.\n\nFrom-SVN: r229982", "tree": {"sha": "6acb9b6d64e5f982bef27de238285e95f827c2d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6acb9b6d64e5f982bef27de238285e95f827c2d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f70cb39c0032dee5caf7b0851556959649895ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f70cb39c0032dee5caf7b0851556959649895ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f70cb39c0032dee5caf7b0851556959649895ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f70cb39c0032dee5caf7b0851556959649895ff/comments", "author": null, "committer": null, "parents": [{"sha": "a2478e36e045c2e19f6cb59b5b0350298306d9bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2478e36e045c2e19f6cb59b5b0350298306d9bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2478e36e045c2e19f6cb59b5b0350298306d9bb"}], "stats": {"total": 301, "additions": 57, "deletions": 244}, "files": [{"sha": "6401c437ed20000c72c41ccd46b11e1ada13bca0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f70cb39c0032dee5caf7b0851556959649895ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f70cb39c0032dee5caf7b0851556959649895ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4f70cb39c0032dee5caf7b0851556959649895ff", "patch": "@@ -1,3 +1,16 @@\n+2015-11-08  Jeff Law <jeff@redhat.com>\n+\n+\t* tree-ssa-threadupdate.c (register_jump_thraed): Assert that a\n+\tnon-FSM path has no edges marked with EDGE_DFS_BACK.\n+\t(ssa_redirect_edges): No longer call mark_loop_for_removal.\n+\t(thread_single_edge, def_split_header_continue_p): Remove.\n+\t(bb_ends_with_multiway_branch): Likewise.\n+\t(thread_through_loop_header): Remove cases of threading from\n+\tlatch through the header.  Simplify knowing we won't thread\n+\tthe latch.\n+\t(thread_through_all_blocks): Simplify knowing that only the FSM\n+\tthreader needs to handle backedges.\n+\n 2015-11-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* doc/extend.texi (type attributes): Document scalar_storage_order."}, {"sha": "184cf3402a9c1b334bdf2b31fcf2df8d2847736c", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 44, "deletions": 244, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f70cb39c0032dee5caf7b0851556959649895ff/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f70cb39c0032dee5caf7b0851556959649895ff/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=4f70cb39c0032dee5caf7b0851556959649895ff", "patch": "@@ -1406,10 +1406,6 @@ ssa_redirect_edges (struct redirection_data **slot,\n \t    fprintf (dump_file, \"  Threaded jump %d --> %d to %d\\n\",\n \t\t     e->src->index, e->dest->index, rd->dup_blocks[0]->index);\n \n-\t  /* If we redirect a loop latch edge cancel its loop.  */\n-\t  if (e->src == e->src->loop_father->latch)\n-\t    mark_loop_for_removal (e->src->loop_father);\n-\n \t  /* Redirect the incoming edge (possibly to the joiner block) to the\n \t     appropriate duplicate block.  */\n \t  e2 = redirect_edge_and_branch (e, rd->dup_blocks[0]);\n@@ -1630,67 +1626,6 @@ thread_block (basic_block bb, bool noloop_only)\n   return retval;\n }\n \n-\n-/* Threads edge E through E->dest to the edge THREAD_TARGET (E).  Returns the\n-   copy of E->dest created during threading, or E->dest if it was not necessary\n-   to copy it (E is its single predecessor).  */\n-\n-static basic_block\n-thread_single_edge (edge e)\n-{\n-  basic_block bb = e->dest;\n-  struct redirection_data rd;\n-  vec<jump_thread_edge *> *path = THREAD_PATH (e);\n-  edge eto = (*path)[1]->e;\n-\n-  delete_jump_thread_path (path);\n-  e->aux = NULL;\n-\n-  thread_stats.num_threaded_edges++;\n-\n-  if (single_pred_p (bb))\n-    {\n-      /* If BB has just a single predecessor, we should only remove the\n-\t control statements at its end, and successors except for ETO.  */\n-      remove_ctrl_stmt_and_useless_edges (bb, eto->dest);\n-\n-      /* And fixup the flags on the single remaining edge.  */\n-      eto->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE | EDGE_ABNORMAL);\n-      eto->flags |= EDGE_FALLTHRU;\n-\n-      return bb;\n-    }\n-\n-  /* Otherwise, we need to create a copy.  */\n-  if (e->dest == eto->src)\n-    update_bb_profile_for_threading (bb, EDGE_FREQUENCY (e), e->count, eto);\n-\n-  vec<jump_thread_edge *> *npath = new vec<jump_thread_edge *> ();\n-  jump_thread_edge *x = new jump_thread_edge (e, EDGE_START_JUMP_THREAD);\n-  npath->safe_push (x);\n-\n-  x = new jump_thread_edge (eto, EDGE_COPY_SRC_BLOCK);\n-  npath->safe_push (x);\n-  rd.path = npath;\n-\n-  create_block_for_threading (bb, &rd, 0, NULL);\n-  remove_ctrl_stmt_and_useless_edges (rd.dup_blocks[0], NULL);\n-  create_edge_and_update_destination_phis (&rd, rd.dup_blocks[0], 0);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"  Threaded jump %d --> %d to %d\\n\",\n-\t     e->src->index, e->dest->index, rd.dup_blocks[0]->index);\n-\n-  rd.dup_blocks[0]->count = e->count;\n-  rd.dup_blocks[0]->frequency = EDGE_FREQUENCY (e);\n-  single_succ_edge (rd.dup_blocks[0])->count = e->count;\n-  redirect_edge_and_branch (e, rd.dup_blocks[0]);\n-  flush_pending_stmts (e);\n-\n-  delete_jump_thread_path (npath);\n-  return rd.dup_blocks[0];\n-}\n-\n /* Callback for dfs_enumerate_from.  Returns true if BB is different\n    from STOP and DBDS_CE_STOP.  */\n \n@@ -1769,24 +1704,6 @@ determine_bb_domination_status (struct loop *loop, basic_block bb)\n   return (bb_reachable ? DOMST_DOMINATING : DOMST_LOOP_BROKEN);\n }\n \n-/* Return true if BB is part of the new pre-header that is created\n-   when threading the latch to DATA.  */\n-\n-static bool\n-def_split_header_continue_p (const_basic_block bb, const void *data)\n-{\n-  const_basic_block new_header = (const_basic_block) data;\n-  const struct loop *l;\n-\n-  if (bb == new_header\n-      || loop_depth (bb->loop_father) < loop_depth (new_header->loop_father))\n-    return false;\n-  for (l = bb->loop_father; l; l = loop_outer (l))\n-    if (l == new_header->loop_father)\n-      return true;\n-  return false;\n-}\n-\n /* Thread jumps through the header of LOOP.  Returns true if cfg changes.\n    If MAY_PEEL_LOOP_HEADERS is false, we avoid threading from entry edges\n    to the inside of the loop.  */\n@@ -1869,27 +1786,7 @@ thread_through_loop_header (struct loop *loop, bool may_peel_loop_headers)\n   if (single_succ_p (header))\n     goto fail;\n \n-  /* If we threaded the latch using a joiner block, we cancel the\n-     threading opportunity out of an abundance of caution.  However,\n-     still allow threading from outside to inside the loop.  */\n-  if (latch->aux)\n-    {\n-      vec<jump_thread_edge *> *path = THREAD_PATH (latch);\n-      if ((*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n-\t{\n-\t  delete_jump_thread_path (path);\n-\t  latch->aux = NULL;\n-\t}\n-    }\n-\n-  if (latch->aux)\n-    {\n-      vec<jump_thread_edge *> *path = THREAD_PATH (latch);\n-      tgt_edge = (*path)[1]->e;\n-      tgt_bb = tgt_edge->dest;\n-    }\n-  else if (!may_peel_loop_headers\n-\t   && !redirection_block_p (loop->header))\n+  if (!may_peel_loop_headers && !redirection_block_p (loop->header))\n     goto fail;\n   else\n     {\n@@ -1961,96 +1858,34 @@ thread_through_loop_header (struct loop *loop, bool may_peel_loop_headers)\n \ttgt_bb = split_edge (tgt_edge);\n     }\n \n-  if (latch->aux)\n-    {\n-      basic_block *bblocks;\n-      unsigned nblocks, i;\n-\n-      /* First handle the case latch edge is redirected.  We are copying\n-\t the loop header but not creating a multiple entry loop.  Make the\n-\t cfg manipulation code aware of that fact.  */\n-      set_loop_copy (loop, loop);\n-      loop->latch = thread_single_edge (latch);\n-      set_loop_copy (loop, NULL);\n-      gcc_assert (single_succ (loop->latch) == tgt_bb);\n-      loop->header = tgt_bb;\n-\n-      /* Remove the new pre-header blocks from our loop.  */\n-      bblocks = XCNEWVEC (basic_block, loop->num_nodes);\n-      nblocks = dfs_enumerate_from (header, 0, def_split_header_continue_p,\n-\t\t\t\t    bblocks, loop->num_nodes, tgt_bb);\n-      for (i = 0; i < nblocks; i++)\n-\tif (bblocks[i]->loop_father == loop)\n-\t  {\n-\t    remove_bb_from_loops (bblocks[i]);\n-\t    add_bb_to_loop (bblocks[i], loop_outer (loop));\n-\t  }\n-      free (bblocks);\n-\n-      /* If the new header has multiple latches mark it so.  */\n-      FOR_EACH_EDGE (e, ei, loop->header->preds)\n-\tif (e->src->loop_father == loop\n-\t    && e->src != loop->latch)\n-\t  {\n-\t    loop->latch = NULL;\n-\t    loops_state_set (LOOPS_MAY_HAVE_MULTIPLE_LATCHES);\n-\t  }\n-\n-      /* Cancel remaining threading requests that would make the\n-\t loop a multiple entry loop.  */\n-      FOR_EACH_EDGE (e, ei, header->preds)\n-\t{\n-\t  edge e2;\n-\n-\t  if (e->aux == NULL)\n-\t    continue;\n+  basic_block new_preheader;\n \n-\t  vec<jump_thread_edge *> *path = THREAD_PATH (e);\n-\t  e2 = path->last ()->e;\n-\n-\t  if (e->src->loop_father != e2->dest->loop_father\n-\t      && e2->dest != loop->header)\n-\t    {\n-\t      delete_jump_thread_path (path);\n-\t      e->aux = NULL;\n-\t    }\n-\t}\n-\n-      /* Thread the remaining edges through the former header.  */\n-      thread_block (header, false);\n-    }\n-  else\n+  /* Now consider the case entry edges are redirected to the new entry\n+     block.  Remember one entry edge, so that we can find the new\n+     preheader (its destination after threading).  */\n+  FOR_EACH_EDGE (e, ei, header->preds)\n     {\n-      basic_block new_preheader;\n+      if (e->aux)\n+\tbreak;\n+    }\n \n-      /* Now consider the case entry edges are redirected to the new entry\n-\t block.  Remember one entry edge, so that we can find the new\n-\t preheader (its destination after threading).  */\n-      FOR_EACH_EDGE (e, ei, header->preds)\n-\t{\n-\t  if (e->aux)\n-\t    break;\n-\t}\n+  /* The duplicate of the header is the new preheader of the loop.  Ensure\n+     that it is placed correctly in the loop hierarchy.  */\n+  set_loop_copy (loop, loop_outer (loop));\n \n-      /* The duplicate of the header is the new preheader of the loop.  Ensure\n-\t that it is placed correctly in the loop hierarchy.  */\n-      set_loop_copy (loop, loop_outer (loop));\n-\n-      thread_block (header, false);\n-      set_loop_copy (loop, NULL);\n-      new_preheader = e->dest;\n-\n-      /* Create the new latch block.  This is always necessary, as the latch\n-\t must have only a single successor, but the original header had at\n-\t least two successors.  */\n-      loop->latch = NULL;\n-      mfb_kj_edge = single_succ_edge (new_preheader);\n-      loop->header = mfb_kj_edge->dest;\n-      latch = make_forwarder_block (tgt_bb, mfb_keep_just, NULL);\n-      loop->header = latch->dest;\n-      loop->latch = latch->src;\n-    }\n+  thread_block (header, false);\n+  set_loop_copy (loop, NULL);\n+  new_preheader = e->dest;\n \n+  /* Create the new latch block.  This is always necessary, as the latch\n+     must have only a single successor, but the original header had at\n+     least two successors.  */\n+  loop->latch = NULL;\n+  mfb_kj_edge = single_succ_edge (new_preheader);\n+  loop->header = mfb_kj_edge->dest;\n+  latch = make_forwarder_block (tgt_bb, mfb_keep_just, NULL);\n+  loop->header = latch->dest;\n+  loop->latch = latch->src;\n   return true;\n \n fail:\n@@ -2332,20 +2167,6 @@ mark_threaded_blocks (bitmap threaded_blocks)\n }\n \n \n-/* Return TRUE if BB ends with a switch statement or a computed goto.\n-   Otherwise return false.  */\n-static bool\n-bb_ends_with_multiway_branch (basic_block bb ATTRIBUTE_UNUSED)\n-{\n-  gimple *stmt = last_stmt (bb);\n-  if (stmt && gimple_code (stmt) == GIMPLE_SWITCH)\n-    return true;\n-  if (stmt && gimple_code (stmt) == GIMPLE_GOTO\n-      && TREE_CODE (gimple_goto_dest (stmt)) == SSA_NAME)\n-    return true;\n-  return false;\n-}\n-\n /* Verify that the REGION is a valid jump thread.  A jump thread is a special\n    case of SEME Single Entry Multiple Exits region in which all nodes in the\n    REGION have exactly one incoming edge.  The only exception is the first block\n@@ -2788,36 +2609,7 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n \t\te->aux = NULL;\n \t\tei_next (&ei);\n \t      }\n-\t   else if (bb_ends_with_multiway_branch (path->last ()->e->src))\n-\t      {\n-\t\t/* The code to thread through loop headers may have\n-\t\t   split a block with jump threads attached to it.\n-\n-\t\t   We can identify this with a disjoint jump threading\n-\t\t   path.  If found, just remove it.  */\n-\t\tfor (unsigned int i = 0; i < path->length () - 1; i++)\n-\t\t  if ((*path)[i]->e->dest != (*path)[i + 1]->e->src)\n-\t\t    {\n-\t\t      delete_jump_thread_path (path);\n-\t\t      e->aux = NULL;\n-\t\t      ei_next (&ei);\n-\t\t      break;\n-\t\t    }\n-\n-\t\t/* Our path is still valid, thread it.  */\n-\t\tif (e->aux)\n-\t\t  {\n-\t\t    if (thread_block ((*path)[0]->e->dest, false))\n-\t\t      e->aux = NULL;\n-\t\t    else\n-\t\t      {\n-\t\t\tdelete_jump_thread_path (path);\n-\t\t\te->aux = NULL;\n-\t\t\tei_next (&ei);\n-\t\t      }\n-\t\t  }\n-\t      }\n-\t   else\n+\t    else\n \t      {\n \t\tdelete_jump_thread_path (path);\n \t\te->aux = NULL;\n@@ -2878,18 +2670,26 @@ register_jump_thread (vec<jump_thread_edge *> *path)\n   /* First make sure there are no NULL outgoing edges on the jump threading\n      path.  That can happen for jumping to a constant address.  */\n   for (unsigned int i = 0; i < path->length (); i++)\n-    if ((*path)[i]->e == NULL)\n-      {\n-\tif (dump_file && (dump_flags & TDF_DETAILS))\n-\t  {\n-\t    fprintf (dump_file,\n-\t\t     \"Found NULL edge in jump threading path.  Cancelling jump thread:\\n\");\n-\t    dump_jump_thread_path (dump_file, *path, false);\n-\t  }\n+    {\n+      if ((*path)[i]->e == NULL)\n+        {\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file,\n+\t\t       \"Found NULL edge in jump threading path.  Cancelling jump thread:\\n\");\n+\t      dump_jump_thread_path (dump_file, *path, false);\n+\t    }\n \n-\tdelete_jump_thread_path (path);\n-\treturn;\n-      }\n+\t  delete_jump_thread_path (path);\n+\t  return;\n+        }\n+\n+      /* Only the FSM threader is allowed to thread across\n+\t backedges in the CFG.  */\n+      if (flag_checking\n+\t  && (*path)[0]->type != EDGE_FSM_THREAD)\n+\tgcc_assert (((*path)[i]->e->flags & EDGE_DFS_BACK) == 0);\n+    }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_jump_thread_path (dump_file, *path, true);"}]}