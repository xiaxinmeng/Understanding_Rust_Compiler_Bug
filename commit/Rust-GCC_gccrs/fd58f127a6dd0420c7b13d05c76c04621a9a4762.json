{"sha": "fd58f127a6dd0420c7b13d05c76c04621a9a4762", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ1OGYxMjdhNmRkMDQyMGM3YjEzZDA1Yzc2YzA0NjIxYTlhNDc2Mg==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-02-05T00:14:37Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-02-05T00:14:37Z"}, "message": "[multiple changes]\n\n2002-02-04  Phil Edwards  <pme@gcc.gnu.org>\n\n\t* docs/doxygen/TODO:  Impl-defined behavior now documented...\n\t* docs/html/17_intro/howto.html:  ...here.\n\t* docs/doxygen/mainpage.doxy:  Remove, rename...\n\t* docs/doxygen/mainpage.html:  ...to this.  Tweak HTML, add license.\n\t* docs/doxygen/style.css:  Add small text.\n\t* docs/doxygen/run_doxygen:  Adjust for new mainpage.\n\t* docs/doxygen/user.cfg.in:  Likewise.\n\n2002-02-04  Stephan Buys  <s.buys@icon.co.za>\n\n\t* include/bits/stl_map.h:  Initial doxygen markup.\n\t* include/std/std_fstream.h:  Initial doxygen markup.\n\nFrom-SVN: r49502", "tree": {"sha": "59af872e275659095bb92bbd4026564bbcfaa4b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59af872e275659095bb92bbd4026564bbcfaa4b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd58f127a6dd0420c7b13d05c76c04621a9a4762", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd58f127a6dd0420c7b13d05c76c04621a9a4762", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd58f127a6dd0420c7b13d05c76c04621a9a4762", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd58f127a6dd0420c7b13d05c76c04621a9a4762/comments", "author": null, "committer": null, "parents": [{"sha": "ebbb0a63f48a678ebc3b6064a60304aeb7662268", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebbb0a63f48a678ebc3b6064a60304aeb7662268", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebbb0a63f48a678ebc3b6064a60304aeb7662268"}], "stats": {"total": 690, "additions": 553, "deletions": 137}, "files": [{"sha": "4d7f104c1ca00d9b47ac019914c220f6eb7d73a7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd58f127a6dd0420c7b13d05c76c04621a9a4762/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd58f127a6dd0420c7b13d05c76c04621a9a4762/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=fd58f127a6dd0420c7b13d05c76c04621a9a4762", "patch": "@@ -1,3 +1,18 @@\n+2002-02-04  Phil Edwards  <pme@gcc.gnu.org>\n+\n+\t* docs/doxygen/TODO:  Impl-defined behavior now documented...\n+\t* docs/html/17_intro/howto.html:  ...here.\n+\t* docs/doxygen/mainpage.doxy:  Remove, rename...\n+\t* docs/doxygen/mainpage.html:  ...to this.  Tweak HTML, add license.\n+\t* docs/doxygen/style.css:  Add small text.\n+\t* docs/doxygen/run_doxygen:  Adjust for new mainpage.\n+\t* docs/doxygen/user.cfg.in:  Likewise.\n+\n+2002-02-04  Stephan Buys  <s.buys@icon.co.za>\n+\n+\t* include/bits/stl_map.h:  Initial doxygen markup.\n+\t* include/std/std_fstream.h:  Initial doxygen markup.\n+\n 2002-02-04  Paolo Carlini  <pcarlini@unitus.it>\n \n \tlibstdc++/5579"}, {"sha": "da2f25ab5e7978dd718860387dd3bfb199daf30c", "filename": "libstdc++-v3/docs/doxygen/TODO", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd58f127a6dd0420c7b13d05c76c04621a9a4762/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2FTODO", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd58f127a6dd0420c7b13d05c76c04621a9a4762/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2FTODO", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2FTODO?ref=fd58f127a6dd0420c7b13d05c76c04621a9a4762", "patch": "@@ -30,13 +30,6 @@ ext/*           Some of the SGI algorithm/functional extensions.\n \n __gnu_cxx       Tricky.  Right now ext/* are in this namespace.\n \n-[1.3.5]         \"implementation-defined behavior:  behavior ... that depends\n-                on the implementation *and that each implementation shall\n-                document*.\"  [my emphasis]  Not all implementation choices\n-                have been thus described; doxygen is not necessarily the\n-                appropriate place for such descriptions, either.  I suggest\n-                adding this list to the Chapter 17 HOWTO.\n-\n -----------------------------------------------------------\n \n NOTES:"}, {"sha": "d7b1c436d29b5a3a55bb022770a00f576a3e9890", "filename": "libstdc++-v3/docs/doxygen/mainpage.html", "status": "renamed", "additions": 58, "deletions": 4, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd58f127a6dd0420c7b13d05c76c04621a9a4762/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fmainpage.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd58f127a6dd0420c7b13d05c76c04621a9a4762/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fmainpage.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fmainpage.html?ref=fd58f127a6dd0420c7b13d05c76c04621a9a4762", "patch": "@@ -1,7 +1,32 @@\n-/*! \\mainpage\n+<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n+<html>\n+<head><meta http-equiv=\"Content-Type\" content=\"text/html;charset=iso-8859-1\">\n+<title>Main Page</title>\n+<link href=\"style.css\" rel=\"stylesheet\" type=\"text/css\">\n+</head>\n+\n+<body bgcolor=\"#ffffff\">\n+<!--\n+     Originally generated by Doxygen 1.2.12.\n+\n+     This used to be surrounded by /* */ marks and tagged with @mainpage, so\n+     that Doxygen would create the index page from it.  HOWEVER, Doxygen\n+     ignores all but the most basic HTML tags, and even with those it strips\n+     all the attributes.  (See, the HTML you write for @mainpage isn't used\n+     directly; it all gets run through Doxygen and re-output.)  So lots of\n+     tags were all being mangled.\n+\n+     Funk 'dat.  Now we let Doxygen do whateer it feels like doing for the\n+     index page, and then we just flat copy this over top of it.  Voila!\n+     Tags actually work like they're supposed to.\n+-->\n+\n+<h1>libstdc++-v3 Source Documentation</h1>\n \n <h2> Documentation Overview </h2>\n \n+<p class=\"smallertext\">Generated 2002-02-04.</p>\n+\n <p>There are two types of documentation for libstdc++-v3.  One is the\n    distribution documentation, which can be read online at\n    <a href=\"http://gcc.gnu.org/onlinedocs/libstdc++/documentation.html\">http://gcc.gnu.org/onlinedocs/libstdc++/documentation.html</a>\n@@ -26,8 +51,12 @@ <h2> Generating this file </h2>\n    The Makefile rule <code> 'make\n    doxygen' </code> in the libstdc++-v3 build directory generates these pages\n    using a tool called, appropriately enough, Doxygen.  To learn more about\n-   Doxygen, take a look at <a href=\"http://www.doxygen.org\">the Doxygen\n-   webpage</a>.\n+   Doxygen, take a look at\n+   <a href=\"http://www.doxygen.org/\">\n+   <!-- snagged from the generated page -->\n+   <img src=\"doxygen.gif\" alt=\"the Doxygen homepage\"\n+        align=center border=0 width=110 height=53>\n+   </a>\n </p>\n \n <p>The libstdc++-v3 configuration files needed to generate doxygen output\n@@ -71,6 +100,31 @@ <h2> Full page index </h2>\n    </ul>\n </p>\n \n-*/\n \n+<h2> License, Copyright, and Other Lawyerly Verbosity </h2>\n+<p>The libstdc++-v3 documentation is released under\n+   <a href=\"http://gcc.gnu.org/onlinedocs/libstdc++/17_intro/license.html\">\n+   these terms</a>.\n+</p>\n+<p>Part of the generated documentation involved comments\n+   and notes from SGI, who says we gotta say this:\n+   <blockquote>\n+   Permission to use, copy, modify, distribute and sell this software and its\n+   documentation for any purpose is hereby granted without fee, provided\n+   that the below copyright notice appears in all copies and that both\n+   the copyright notice and this permission notice appear in supporting\n+   documentation. Silicon Graphics makes no representations about the\n+   suitability of this software for any purpose. It is provided \"as is\"\n+   without express or implied warranty.\n+   <br><br>\n+   Copyright &copy; 1994\n+   Hewlett-Packard Company\n+   </blockquote>\n+</p>\n+<p>Part of the generated documentation is quoted from the C++ standard, which\n+   is copyright 1998 by Information Technology Industry Council.\n+</p>\n+\n+</body>\n+</html>\n ", "previous_filename": "libstdc++-v3/docs/doxygen/mainpage.doxy"}, {"sha": "e93c947276e8c8309b51079d5d057a040508533f", "filename": "libstdc++-v3/docs/doxygen/run_doxygen", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd58f127a6dd0420c7b13d05c76c04621a9a4762/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Frun_doxygen", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd58f127a6dd0420c7b13d05c76c04621a9a4762/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Frun_doxygen", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Frun_doxygen?ref=fd58f127a6dd0420c7b13d05c76c04621a9a4762", "patch": "@@ -146,6 +146,7 @@ set -e\n set +e\n \n test $do_html = yes && {\n+    cp ${srcdir}/docs/doxygen/mainpage.html ${outdir}/html_${mode}/index.html\n     echo ::\n     echo :: HTML pages begin with\n     echo :: ${outdir}/html_${mode}/index.html"}, {"sha": "5e430053dff1f9f47ce7769a2a5e2927c7790e67", "filename": "libstdc++-v3/docs/doxygen/style.css", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd58f127a6dd0420c7b13d05c76c04621a9a4762/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fstyle.css", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd58f127a6dd0420c7b13d05c76c04621a9a4762/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fstyle.css", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fstyle.css?ref=fd58f127a6dd0420c7b13d05c76c04621a9a4762", "patch": "@@ -21,3 +21,4 @@ FONT.comment       { color: #800000 }\n FONT.preprocessor  { color: #806020 }\n FONT.stringliteral { color: #002080 }\n FONT.charliteral   { color: #008080 }\n+.smallertext { font-size: smaller }"}, {"sha": "430194b5579cfc4390969db2bed3c6dc2cf1756d", "filename": "libstdc++-v3/docs/doxygen/user.cfg.in", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd58f127a6dd0420c7b13d05c76c04621a9a4762/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fuser.cfg.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd58f127a6dd0420c7b13d05c76c04621a9a4762/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fuser.cfg.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fuser.cfg.in?ref=fd58f127a6dd0420c7b13d05c76c04621a9a4762", "patch": "@@ -296,8 +296,7 @@ WARN_LOGFILE           =\n # directories like \"/usr/src/myproject\". Separate the files or directories \n # with spaces.\n \n-INPUT                  = @srcdir@/docs/doxygen/mainpage.doxy \\\n-                         @srcdir@/docs/doxygen/doxygroups.cc \\\n+INPUT                  = @srcdir@/docs/doxygen/doxygroups.cc \\\n                          @srcdir@/src \\\n                          @srcdir@/libsupc++/exception \\\n                          @srcdir@/libsupc++/new \\"}, {"sha": "7aa7430abe753b1872e50bd5671f8587a7af887e", "filename": "libstdc++-v3/docs/html/17_intro/howto.html", "status": "modified", "additions": 57, "deletions": 16, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd58f127a6dd0420c7b13d05c76c04621a9a4762/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd58f127a6dd0420c7b13d05c76c04621a9a4762/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fhowto.html?ref=fd58f127a6dd0420c7b13d05c76c04621a9a4762", "patch": "@@ -165,26 +165,28 @@ <h2><a name=\"4\"><code>&lt;foo&gt;</code> vs <code>&lt;foo.h&gt;</code></a></h2>\n \n <hr>\n <h2><a name=\"5\">Behavior specific to libstdc++-v3</a></h2>\n-   <p>The ISO standard defines the following:\n+   <p>The ISO standard defines the following phrase:\n      <blockquote><dl>\n      <dt><code>[1.3.5] implementation-defined behavior</code>\n      <dd>behavior, for a well-formed program construct and correct data, that\n          depends on the implementation <strong>and that each implementation\n-\t shall document</strong>.\n+         shall document</strong>.\n      </dl></blockquote>\n       We do so here, for the C++ library only.  Behavior of the compiler,\n       linker, runtime loader, and other elements of &quot;the\n-      implementation&quot; are documented elsewhere.\n+      implementation&quot; are documented elsewhere.  Everything listed in\n+      Annex B, Implemenation Qualities, are also part of the compiler, not\n+      the library.\n    </p>\n    <p>For each entry, we give the section number of the standard, when\n-      applicable.  This list is known to be incomplet and inkorrekt.\n+      applicable.  This list is probably incomplet and inkorrekt.\n    </p>\n    <p><strong>[17.4.4.5]</strong> Non-reentrant functions are probably best\n       discussed in the various sections on multithreading (see above).\n    </p>\n    <!-- [17.4.4.8]/3 says any function that doesn't have an exception-spec\n         can throw whatever we want; see also its footnote.  Let's list those\n-\tin the sections where the function itself occurs.\n+        in the sections where the function itself occurs.\n    -->\n    <p><strong>[18.1]/4</strong> The type of <code>NULL</code> is described\n       <a href=\"../18_support/howto.html#1\">here</a>.\n@@ -200,27 +202,66 @@ <h2><a name=\"5\">Behavior specific to libstdc++-v3</a></h2>\n       <strong>[18.6.2.1]/5</strong> (bad_exception):  The <code>what()</code>\n       member function of class <code>std::exception</code>, and these other\n       classes publicly derived from it, simply returns the name of the\n-      class.  But they are the <em>mangled</em> names.\n-<!-- demangler bug fixed yet? -->\n+      class.  But they are the <em>mangled</em> names; you will need to call\n+      <code>c++filt</code> and pass the names as command-line parameters to\n+      demangle them.\n       (The classes in <code>&lt;stdexcept&gt;</code> have constructors which\n-      require a string argument to use in <code>what()</code> calls, so the\n+      require an argument to use later for <code>what()</code> calls, so the\n       question does not arise in most user-defined exceptions.)\n    </p>\n-   <p><strong></strong>\n+   <p><strong>[18.5.1]/7</strong> The return value of\n+      <code>std::type_info::name()</code> is the mangled type name (see the\n+      previous entry for more).\n    </p>\n-   <p><strong></strong>\n+   <p><strong>[20.1.5]/5</strong> <em>&quot;Implementors are encouraged to\n+      supply libraries that can accept allocators that encapsulate more\n+      general memory models and that support non-equal instances.  In such\n+      implementations, any requirements imposed on allocators by containers\n+      beyond those requirements that appear in Table 32, and the semantics\n+      of containers and algorithms when allocator instances compare\n+      non-equal, are implementation-defined.&quot;</em>  As yet we don't\n+      have any allocators which compare non-equal, so we can't describe how\n+      they behave.\n    </p>\n-   <p><strong></strong>\n+   <p><strong>[21.1.3.1]/3,4</strong>,<br>\n+      <strong>[21.1.3.2]/2</strong>,<br>\n+      <strong>[23.*]'s foo::iterator</strong>,<br>\n+      <strong>[27.*]'s foo::*_type</strong>,<br>\n+      <strong>others...</strong>\n+      Nope, these types are called implementation-defined because you\n+      shouldn't be taking advantage of their underlying types.  Listing them\n+      here would defeat the purpose.  :-)\n    </p>\n-   <p><strong></strong>\n+   <p><strong>[21.1.3.1]/5</strong> I don't really know about the mbstate_t\n+      stuff... see the chapter 22 notes for what does exist.\n    </p>\n-   <p><strong></strong>\n+   <p><strong>[22.*]</strong> Anything and everything we have on locale\n+      implemenation will be described\n+      <a href=\"../22_locale/howto.html\">over here</a>.\n    </p>\n-   <p><strong></strong>\n+   <p><strong>[26.2.8]/9</strong> I have no idea what\n+      <code>complex&lt;T&gt;</code>'s pow(0,0) returns.\n    </p>\n-   <p><strong></strong>\n+   <p><strong>[27.4.2.4]/2</strong> Calling\n+      <code>std::ios_base::sync_with_stdio</code> after I/O has already been\n+      performed on the standard stream objects will\n+      flush the buffers, and <!-- this line might go away -->\n+      destroy and recreate the underlying buffer instances.  Whether or not\n+      the previously-written I/O is destroyed in this process depends mostly\n+      on the --enable-libio choice:  for stdio, if the written data is\n+      already in the stdio buffer, the data may be completely safe!\n    </p>\n-   <p><strong></strong>\n+   <p><strong>I/O sentry ctor/dtor</strong> They can perform additional work\n+      than the minimum required.  I don't think we're currently taking\n+      advantage of this yet.\n+   </p>\n+   <p><strong>[27.7.1.3]/16</strong>,<br>\n+      <strong>[27.8.1.4]/10</strong>\n+      The effects of <code>pubsetbuf/setbuf</code> are described\n+      <a href=\"../27_io/howto.html#2\">in this chapter</a>.\n+   </p>\n+   <p><strong>[27.8.1.4]/16</strong> Calling <code>fstream::sync</code> when\n+      a get area exists will... whatever <code>fflush()</code> does, I think.\n    </p>\n    <p>Return <a href=\"#top\">to top of page</a> or\n       <a href=\"../faq/index.html\">to the FAQ</a>."}, {"sha": "8ca6bed0d93cdc65356df356c46de9aac41461d7", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 253, "deletions": 17, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd58f127a6dd0420c7b13d05c76c04621a9a4762/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd58f127a6dd0420c7b13d05c76c04621a9a4762/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=fd58f127a6dd0420c7b13d05c76c04621a9a4762", "patch": "@@ -1,6 +1,6 @@\n // Map implementation -*- C++ -*-\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -66,6 +66,14 @@\n namespace std\n {\n \n+/**\n+ *  @brief A standard container made up of pairs (see std::pair in <utility>)\n+ *         which can be retrieved based on a key.\n+ *\n+ *  This is an associative container.  Values contained within it can be\n+ *  quickly retrieved through a key element.  Example:  MyMap[\"First\"] would\n+ *  return the data associated with the key \"First\".\n+*/\n template <class _Key, class _Tp, class _Compare = less<_Key>,\n           class _Alloc = allocator<pair<const _Key, _Tp> > >\n class map\n@@ -81,7 +89,7 @@ class map\n   typedef _Tp                   mapped_type;\n   typedef pair<const _Key, _Tp> value_type;\n   typedef _Compare             key_compare;\n-    \n+\n   class value_compare\n     : public binary_function<value_type, value_type, bool> {\n   friend class map<_Key,_Tp,_Compare,_Alloc>;\n@@ -95,7 +103,7 @@ class map\n   };\n \n private:\n-  typedef _Rb_tree<key_type, value_type, \n+  typedef _Rb_tree<key_type, value_type,\n                    _Select1st<value_type>, key_compare, _Alloc> _Rep_type;\n   _Rep_type _M_t;  // red-black tree representing map\n public:\n@@ -133,7 +141,7 @@ class map\n   operator=(const map<_Key, _Tp, _Compare, _Alloc>& __x)\n   {\n     _M_t = __x._M_t;\n-    return *this; \n+    return *this;\n   }\n \n   // accessors:\n@@ -142,62 +150,290 @@ class map\n   value_compare value_comp() const { return value_compare(_M_t.key_comp()); }\n   allocator_type get_allocator() const { return _M_t.get_allocator(); }\n \n+  /**\n+   *  Returns a read/write iterator that points to the first pair in the map.\n+   *  Iteration is done in ascending order according to the keys.\n+  */\n   iterator begin() { return _M_t.begin(); }\n+\n+  /**\n+   *  Returns a read-only (constant) iterator that points to the first pair\n+   *  in the map.  Iteration is done in ascending order according to the keys.\n+  */\n   const_iterator begin() const { return _M_t.begin(); }\n+\n+  /**\n+   *  Returns a read/write iterator that points one past the last pair in the\n+   *  map.  Iteration is done in ascending order according to the keys.\n+  */\n   iterator end() { return _M_t.end(); }\n+\n+  /**\n+   *  Returns a read-only (constant) iterator that points one past the last\n+   *  pair in the map.  Iteration is done in ascending order according to the\n+   *  keys.\n+  */\n   const_iterator end() const { return _M_t.end(); }\n+\n+  /**\n+   *  Returns a read/write reverse iterator that points to the last pair in\n+   *  the map.  Iteration is done in descending order according to the keys.\n+  */\n   reverse_iterator rbegin() { return _M_t.rbegin(); }\n+\n+  /**\n+   *  Returns a read-only (constant) reverse iterator that points to the last\n+   *  pair in the map.  Iteration is done in descending order according to\n+   *  the keys.\n+  */\n   const_reverse_iterator rbegin() const { return _M_t.rbegin(); }\n+\n+  /**\n+   *  Returns a read/write reverse iterator that points to one before the\n+   *  first pair in the map.  Iteration is done in descending order according\n+   *  to the keys.\n+  */\n   reverse_iterator rend() { return _M_t.rend(); }\n+\n+  /**\n+   *  Returns a read-only (constant) reverse iterator that points to one\n+   *  before the first pair in the map.  Iteration is done in descending order\n+   *  according to the keys.\n+  */\n   const_reverse_iterator rend() const { return _M_t.rend(); }\n+\n+  /** Returns true if the map is empty.  (Thus begin() would equal end().)  */\n   bool empty() const { return _M_t.empty(); }\n+  /** Returns the size of the map.  */\n   size_type size() const { return _M_t.size(); }\n+  /** Returns the maximum size of the map.  */\n   size_type max_size() const { return _M_t.max_size(); }\n+\n+  /**\n+   *  @brief Subscript ( [] ) access to map data.\n+   *  @param  k  The key for which data should be retrieved.\n+   *  Allows for easy lookup with the subscript ( [] ) operator.  Returns the\n+   *  data associated with the key specified in subscript.  If the key does\n+   *  not exist a pair with that key is created with a default value, which\n+   *  is then returned.\n+  */\n   _Tp& operator[](const key_type& __k) {\n     iterator __i = lower_bound(__k);\n     // __i->first is greater than or equivalent to __k.\n     if (__i == end() || key_comp()(__k, (*__i).first))\n       __i = insert(__i, value_type(__k, _Tp()));\n     return (*__i).second;\n   }\n+\n   void swap(map<_Key,_Tp,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }\n \n   // insert/erase\n-\n-  pair<iterator,bool> insert(const value_type& __x) \n+  /**\n+   *  @brief Attempts to insert a std::pair into the map.\n+   *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n+   *             pairs).\n+   *  @return  A pair of which the first element is an iterator that points\n+   *           to the possibly inserted pair, a second element of type bool\n+   *           to show if the pair was actually inserted.\n+   *\n+   *  This function attempts to insert a (key, value) pair into the map.  A\n+   *  map relies on unique keys and thus a pair is only inserted if its first\n+   *  element (the key) is not already present in the map.\n+  */\n+  pair<iterator,bool> insert(const value_type& __x)\n     { return _M_t.insert_unique(__x); }\n+\n+  /**\n+   *  @brief Attempts to insert a std::pair into the map.\n+   *  @param  position  An iterator that serves as a hint as to where the\n+   *                    pair should be inserted.\n+   *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n+   *             pairs).\n+   *  @return  An iterator that points to the inserted (key,value) pair.\n+   *\n+   *  This function is not concerned about whether the insertion took place\n+   *  or not and thus does not return a boolean like the single-argument\n+   *  insert() does.  Note that the first parameter is only a hint and can\n+   *  potentially improve the performance of the insertion process.  A bad\n+   *  hint would cause no gains in efficiency.\n+  */\n   iterator insert(iterator position, const value_type& __x)\n     { return _M_t.insert_unique(position, __x); }\n+\n+  /**\n+   *  @brief A template function that attemps to insert elements from\n+   *         another range (possibly another map).\n+   *  @param  first  Iterator pointing to the start of the range to be inserted.\n+   *  @param  last  Iterator pointing to the end of the range.\n+  */\n   template <class _InputIterator>\n   void insert(_InputIterator __first, _InputIterator __last) {\n     _M_t.insert_unique(__first, __last);\n   }\n \n+  /**\n+   *  @brief Erases an element from a map.\n+   *  @param  position  An iterator pointing to the element to be erased.\n+   *\n+   *  This function erases an element, pointed to by the given iterator, from\n+   *  a map.  Note that this function only erases the element, and that if\n+   *  the element is itself a pointer, the pointed-to memory is not touched\n+   *  in any way.  That is the user's responsibilty.\n+  */\n   void erase(iterator __position) { _M_t.erase(__position); }\n+\n+  /**\n+   *  @brief Erases an element according to the provided key.\n+   *  @param  x  Key of element to be erased.\n+   *  @return  Doc me!\n+   *\n+   *  This function erases an element, located by the given key, from a map.\n+   *  Note that this function only erases the element, and that if\n+   *  the element is itself a pointer, the pointed-to memory is not touched\n+   *  in any way.  That is the user's responsibilty.\n+  */\n   size_type erase(const key_type& __x) { return _M_t.erase(__x); }\n+\n+  /**\n+   *  @brief Erases a [first,last) range of elements from a map.\n+   *  @param  first  Iterator pointing to the start of the range to be erased.\n+   *  @param  last  Iterator pointing to the end of the range to be erased.\n+   *\n+   *  This function erases a sequence of elements from a map.\n+   *  Note that this function only erases the element, and that if\n+   *  the element is itself a pointer, the pointed-to memory is not touched\n+   *  in any way.  That is the user's responsibilty.\n+  */\n   void erase(iterator __first, iterator __last)\n     { _M_t.erase(__first, __last); }\n+\n+  /** Erases all elements in a map.  */\n   void clear() { _M_t.clear(); }\n \n   // map operations:\n \n+  /**\n+   *  @brief Tries to locate an element in a map.\n+   *  @param  x  Key of (key, value) pair to be located.\n+   *  @return  Iterator pointing to sought-after element, or end() if not\n+   *           found.\n+   *\n+   *  This function takes a key and tries to locate the element with which\n+   *  the key matches.  If successful the function returns an iterator\n+   *  pointing to the sought after pair. If unsuccessful it returns the\n+   *  one past the end ( end() ) iterator.\n+  */\n   iterator find(const key_type& __x) { return _M_t.find(__x); }\n+\n+  /**\n+   *  @brief Tries to locate an element in a map.\n+   *  @param  x  Key of (key, value) pair to be located.\n+   *  @return  Read-only (constant) iterator pointing to sought-after\n+   *           element, or end() if not found.\n+   *\n+   *  This function takes a key and tries to locate the element with which\n+   *  the key matches.  If successful the function returns a constant iterator\n+   *  pointing to the sought after pair. If unsuccessful it returns the\n+   *  one past the end ( end() ) iterator.\n+  */\n   const_iterator find(const key_type& __x) const { return _M_t.find(__x); }\n+\n+  /**\n+   *  @brief Finds the number of elements with given key.\n+   *  @param  x  Key of (key, value) pairs to be located.\n+   *  @return Number of elements with specified key.\n+   *\n+   *  This function only makes sense for multimaps.\n+  */\n   size_type count(const key_type& __x) const {\n-    return _M_t.find(__x) == _M_t.end() ? 0 : 1; \n+    return _M_t.find(__x) == _M_t.end() ? 0 : 1;\n   }\n+\n+  /**\n+   *  @brief Finds the beginning of a subsequence matching given key.\n+   *  @param  x  Key of (key, value) pair to be located.\n+   *  @return  Iterator pointing to first element matching given key, or\n+   *           end() if not found.\n+   *\n+   *  This function is useful only with std::multimap.  It returns the first\n+   *  element of a subsequence of elements that matches the given key.  If\n+   *  unsuccessful it returns an iterator pointing to the first element that\n+   *  has a greater value than given key or end() if no such element exists.\n+  */\n   iterator lower_bound(const key_type& __x) {return _M_t.lower_bound(__x); }\n+\n+  /**\n+   *  @brief Finds the beginning of a subsequence matching given key.\n+   *  @param  x  Key of (key, value) pair to be located.\n+   *  @return  Read-only (constant) iterator pointing to first element\n+   *           matching given key, or end() if not found.\n+   *\n+   *  This function is useful only with std::multimap.  It returns the first\n+   *  element of a subsequence of elements that matches the given key.  If\n+   *  unsuccessful the iterator will point to the next greatest element or,\n+   *  if no such greater element exists, to end().\n+  */\n   const_iterator lower_bound(const key_type& __x) const {\n-    return _M_t.lower_bound(__x); \n+    return _M_t.lower_bound(__x);\n   }\n+\n+  /**\n+   *  @brief Finds the end of a subsequence matching given key.\n+   *  @param  x  Key of (key, value) pair to be located.\n+   *  @return Iterator pointing to last element matching given key.\n+   *\n+   *  This function only makes sense with multimaps.\n+  */\n   iterator upper_bound(const key_type& __x) {return _M_t.upper_bound(__x); }\n+\n+  /**\n+   *  @brief Finds the end of a subsequence matching given key.\n+   *  @param  x  Key of (key, value) pair to be located.\n+   *  @return  Read-only (constant) iterator pointing to last element matching\n+   *           given key.\n+   *\n+   *  This function only makes sense with multimaps.\n+  */\n   const_iterator upper_bound(const key_type& __x) const {\n-    return _M_t.upper_bound(__x); \n+    return _M_t.upper_bound(__x);\n   }\n-  \n+\n+  /**\n+   *  @brief Finds a subsequence matching given key.\n+   *  @param  x  Key of (key, value) pairs to be located.\n+   *  @return  Pair of iterators that possibly points to the subsequence\n+   *           matching given key.\n+   *\n+   *  This function improves on lower_bound() and upper_bound() by giving a more\n+   *  elegant and efficient solution.  It returns a pair of which the first\n+   *  element possibly points to the first element matching the given key\n+   *  and the second element possibly points to the last element matching the\n+   *  given key.  If unsuccessful the first element of the returned pair will\n+   *  contain an iterator pointing to the next greatest element or, if no such\n+   *  greater element exists, to end().\n+   *\n+   *  This function only makes sense for multimaps.\n+  */\n   pair<iterator,iterator> equal_range(const key_type& __x) {\n     return _M_t.equal_range(__x);\n   }\n+\n+  /**\n+   *  @brief Finds a subsequence matching given key.\n+   *  @param  x  Key of (key, value) pairs to be located.\n+   *  @return  Pair of read-only (constant) iterators that possibly points to\n+   *           the subsequence matching given key.\n+   *\n+   *  This function improves on lower_bound() and upper_bound() by giving a more\n+   *  elegant and efficient solution.  It returns a pair of which the first\n+   *  element possibly points to the first element matching the given key\n+   *  and the second element possibly points to the last element matching the\n+   *  given key.  If unsuccessful the first element of the returned pair will\n+   *  contain an iterator pointing to the next greatest element or, if no such\n+   *  a greater element exists, to end().\n+   *\n+   *  This function only makes sense for multimaps.\n+  */\n   pair<const_iterator,const_iterator> equal_range(const key_type& __x) const {\n     return _M_t.equal_range(__x);\n   }\n@@ -211,43 +447,43 @@ class map\n };\n \n template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator==(const map<_Key,_Tp,_Compare,_Alloc>& __x, \n+inline bool operator==(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n                        const map<_Key,_Tp,_Compare,_Alloc>& __y) {\n   return __x._M_t == __y._M_t;\n }\n \n template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator<(const map<_Key,_Tp,_Compare,_Alloc>& __x, \n+inline bool operator<(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n                       const map<_Key,_Tp,_Compare,_Alloc>& __y) {\n   return __x._M_t < __y._M_t;\n }\n \n template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator!=(const map<_Key,_Tp,_Compare,_Alloc>& __x, \n+inline bool operator!=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n                        const map<_Key,_Tp,_Compare,_Alloc>& __y) {\n   return !(__x == __y);\n }\n \n template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator>(const map<_Key,_Tp,_Compare,_Alloc>& __x, \n+inline bool operator>(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n                       const map<_Key,_Tp,_Compare,_Alloc>& __y) {\n   return __y < __x;\n }\n \n template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator<=(const map<_Key,_Tp,_Compare,_Alloc>& __x, \n+inline bool operator<=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n                        const map<_Key,_Tp,_Compare,_Alloc>& __y) {\n   return !(__y < __x);\n }\n \n template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator>=(const map<_Key,_Tp,_Compare,_Alloc>& __x, \n+inline bool operator>=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n                        const map<_Key,_Tp,_Compare,_Alloc>& __y) {\n   return !(__x < __y);\n }\n \n template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline void swap(map<_Key,_Tp,_Compare,_Alloc>& __x, \n+inline void swap(map<_Key,_Tp,_Compare,_Alloc>& __x,\n                  map<_Key,_Tp,_Compare,_Alloc>& __y) {\n   __x.swap(__y);\n }"}, {"sha": "4483e3f489933b0a0a90d0ed485327caee81c743", "filename": "libstdc++-v3/include/std/std_fstream.h", "status": "modified", "additions": 167, "deletions": 91, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd58f127a6dd0420c7b13d05c76c04621a9a4762/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd58f127a6dd0420c7b13d05c76c04621a9a4762/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h?ref=fd58f127a6dd0420c7b13d05c76c04621a9a4762", "patch": "@@ -48,7 +48,7 @@\n #include <bits/basic_file.h>\n #include <bits/gthr.h>\n \n-namespace std \n+namespace std\n {\n   template<typename _CharT, typename _Traits>\n     class basic_filebuf : public basic_streambuf<_CharT, _Traits>\n@@ -60,7 +60,7 @@ namespace std\n       typedef typename traits_type::int_type \t\tint_type;\n       typedef typename traits_type::pos_type \t\tpos_type;\n       typedef typename traits_type::off_type \t\toff_type;\n-      \n+\n       // Non-standard Types:\n       typedef basic_streambuf<char_type, traits_type>  \t__streambuf_type;\n       typedef basic_filebuf<char_type, traits_type>     __filebuf_type;\n@@ -79,72 +79,72 @@ namespace std\n \n       // Current and beginning state type for codecvt.\n       __state_type\t\t_M_state_cur;\n-      __state_type \t\t_M_state_beg; \t\n+      __state_type \t\t_M_state_beg;\n \n       // MT lock inherited from libio or other low-level io library.\n       __c_lock          \t_M_lock;\n \n       // Set iff _M_buf is allocated memory from _M_allocate_internal_buffer..\n       bool\t\t\t_M_buf_allocated;\n \n-      // XXX Needed? \n-      bool\t\t\t_M_last_overflowed;  \n-  \n+      // XXX Needed?\n+      bool\t\t\t_M_last_overflowed;\n+\n     public:\n       // Constructors/destructor:\n       basic_filebuf();\n \n       // Non-standard ctor:\n-      basic_filebuf(__c_file_type* __f, ios_base::openmode __mode, \n+      basic_filebuf(__c_file_type* __f, ios_base::openmode __mode,\n \t\t    int_type __s = static_cast<int_type>(BUFSIZ));\n- \n+\n       // Non-standard member:\n       int\n       fd();\n \n-      virtual \n-      ~basic_filebuf() \n-      { \n+      virtual\n+      ~basic_filebuf()\n+      {\n \tthis->close();\n \t_M_last_overflowed = false;\n       }\n \n       // Members:\n-      bool \n+      bool\n       is_open(void) const { return _M_file ? _M_file->is_open() : false; }\n-    \n-      __filebuf_type* \n+\n+      __filebuf_type*\n       open(const char* __s, ios_base::openmode __mode);\n-    \n-      __filebuf_type* \n+\n+      __filebuf_type*\n       close(void);\n \n     protected:\n-      void \n+      void\n       _M_allocate_internal_buffer();\n \n-      void \n+      void\n       _M_destroy_internal_buffer();\n \n-      void \n+      void\n       _M_allocate_pback_buffer();\n \n       // Create __file_type object and initialize it properly.\n       void\n       _M_allocate_file();\n \n       // Overridden virtual functions:\n-      virtual streamsize \n+      virtual streamsize\n       showmanyc(void);\n-   \n-      // Stroustrup, 1998, p. 628 \n+\n+      // Stroustrup, 1998, p. 628\n       // underflow() and uflow() functions are called to get the next\n       // charater from the real input source when the buffer is empty.\n       // Buffered input uses underflow()\n-      virtual int_type \n+      virtual int_type\n       underflow(void);\n \n-      virtual int_type \n+      virtual int_type\n       pbackfail(int_type __c = _Traits::eof());\n \n       // NB: For what the standard expects of the overflow function,\n@@ -155,31 +155,31 @@ namespace std\n       // this in actuality be a helper function that checks for the\n       // eccentricities of this implementation, and then call\n       // overflow() if indeed the buffer is full.\n-      virtual int_type \n+      virtual int_type\n       overflow(int_type __c = _Traits::eof());\n \n       // Stroustrup, 1998, p 648\n       // The overflow() function is called to transfer characters to the\n       // real output destination when the buffer is full. A call to\n       // overflow(c) outputs the contents of the buffer plus the\n       // character c.\n-      // 27.5.2.4.5 \n+      // 27.5.2.4.5\n       // Consume some sequence of the characters in the pending sequence.\n-      int_type \n+      int_type\n       _M_really_overflow(int_type __c = _Traits::eof());\n-    \n-      virtual __streambuf_type* \n+\n+      virtual __streambuf_type*\n       setbuf(char_type* __s, streamsize __n);\n-    \n-      virtual pos_type \n+\n+      virtual pos_type\n       seekoff(off_type __off, ios_base::seekdir __way,\n \t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n \n-      virtual pos_type \n+      virtual pos_type\n       seekpos(pos_type __pos,\n \t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n \n-      virtual int \n+      virtual int\n       sync(void)\n       {\n \tbool __testput = _M_out_cur && _M_out_beg < _M_out_end;\n@@ -197,14 +197,14 @@ namespace std\n \t    _M_really_overflow();\n \t    _M_file->seekpos(__cur + __off);\n \t  }\n-\t_M_last_overflowed = false;\t\n+\t_M_last_overflowed = false;\n \treturn 0;\n       }\n-      \n-      virtual void \n+\n+      virtual void\n       imbue(const locale& __loc);\n \n-      virtual streamsize \n+      virtual streamsize\n       xsgetn(char_type* __s, streamsize __n)\n       {\n \tstreamsize __ret = 0;\n@@ -224,20 +224,24 @@ namespace std\n \t  __ret += __streambuf_type::xsgetn(__s, __n - __ret);\n \treturn __ret;\n       }\n- \n-      virtual streamsize \n+\n+      virtual streamsize\n       xsputn(const char_type* __s, streamsize __n)\n       {\n \t_M_pback_destroy();\n \treturn __streambuf_type::xsputn(__s, __n);\n       }\n-       \n+\n       void\n       _M_output_unshift();\n     };\n \n \n+\n   // 27.8.1.5  Template class basic_ifstream\n+  /**\n+   *  Derivation of general input streams, specific to files.\n+  */\n   template<typename _CharT, typename _Traits>\n     class basic_ifstream : public basic_istream<_CharT, _Traits>\n     {\n@@ -252,52 +256,69 @@ namespace std\n       // Non-standard types:\n       typedef basic_filebuf<char_type, traits_type> \t__filebuf_type;\n       typedef basic_istream<char_type, traits_type>\t__istream_type;\n-    \n+\n     private:\n       __filebuf_type\t_M_filebuf;\n \n     public:\n      // Constructors/Destructors:\n+     /** Default constructor.  Create an input file stream.  */\n       basic_ifstream()\n       : __istream_type(NULL), _M_filebuf()\n       { this->init(&_M_filebuf); }\n \n-      explicit \n+      /**\n+       *  @brief Create an input file stream.\n+       *  @param  s  Null terminated string specifying filename.\n+       *  @param  mode  Open file in specified mode (see std::ios_base).\n+       *\n+       *  Tip:  When using std::string to hold the filename, you must use\n+       *  .c_str() before passing it to this constructor.\n+      */\n+      explicit\n       basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)\n       : __istream_type(NULL), _M_filebuf()\n-      { \n-\tthis->init(&_M_filebuf); \n-\tthis->open(__s, __mode); \n+      {\n+\tthis->init(&_M_filebuf);\n+\tthis->open(__s, __mode);\n       }\n-    \n+\n       ~basic_ifstream()\n       { }\n \n       // Members:\n-      __filebuf_type* \n-      rdbuf() const \n+      /**\n+       *  @brief  Get a pointer to the file stream's buffer.\n+       *  @return Pointer to basic_filebuf.\n+      */\n+      __filebuf_type*\n+      rdbuf() const\n       { return const_cast<__filebuf_type*>(&_M_filebuf); }\n \n-      bool \n+      bool\n       is_open(void) { return _M_filebuf.is_open(); }\n \n-      void \n+      void\n       open(const char* __s, ios_base::openmode __mode = ios_base::in)\n-      { \n+      {\n \tif (_M_filebuf.open(__s, __mode | ios_base::in) == NULL)\n-\t  this->setstate(ios_base::failbit); \n+\t  this->setstate(ios_base::failbit);\n       }\n \n-      void \n+      /** Close the file.  */\n+      void\n       close(void)\n-      { \n+      {\n \tif (!_M_filebuf.close())\n-\t  this->setstate(ios_base::failbit);\t\n+\t  this->setstate(ios_base::failbit);\n       }\n     };\n \n-  \n+\n   // 27.8.1.8  Template class basic_ofstream\n+  /**\n+   *  Derivation of general output streams, specific to files.\n+  */\n   template<typename _CharT, typename _Traits>\n     class basic_ofstream : public basic_ostream<_CharT,_Traits>\n     {\n@@ -312,54 +333,83 @@ namespace std\n       // Non-standard types:\n       typedef basic_filebuf<char_type, traits_type> \t__filebuf_type;\n       typedef basic_ostream<char_type, traits_type>\t__ostream_type;\n-      \n+\n     private:\n       __filebuf_type\t_M_filebuf;\n \n     public:\n       // Constructors:\n+      /** Default constructor for output file_stream.  */\n       basic_ofstream()\n       : __ostream_type(NULL), _M_filebuf()\n       { this->init(&_M_filebuf); }\n-      \n-      explicit \n-      basic_ofstream(const char* __s, \n+\n+      /**\n+       *  @brief  Create an output stream.\n+       *  @param  s  Null terminated string specifying filename.\n+       *  @param  mode  Open file in specified mode (see std::ios_base).\n+       *\n+       *  Tip:  When using std::string to hold the filename, you must use\n+       *  .c_str() before passing it to this constructor.\n+      */\n+      explicit\n+      basic_ofstream(const char* __s,\n \t\t     ios_base::openmode __mode = ios_base::out|ios_base::trunc)\n       : __ostream_type(NULL), _M_filebuf()\n-      { \n-\tthis->init(&_M_filebuf); \n-\tthis->open(__s, __mode); \n+      {\n+\tthis->init(&_M_filebuf);\n+\tthis->open(__s, __mode);\n       }\n \n       ~basic_ofstream()\n       { }\n \n       // Members:\n-      __filebuf_type* \n+      /**\n+       *  @brief  Get a pointer to the file stream's buffer.\n+       *  @return Pointer to basic_filebuf.\n+      */\n+      __filebuf_type*\n       rdbuf(void) const\n       { return const_cast<__filebuf_type*>(&_M_filebuf); }\n- \n-      bool \n+\n+      /**\n+       *  @brief Query to see if file stream is open.\n+       *  @return True if stream is open.\n+      */\n+      bool\n       is_open(void) { return _M_filebuf.is_open(); }\n \n-      void \n-      open(const char* __s, \n+      /**\n+       *  @brief Specify a file to open for output.\n+       *  @param  s  Null terminated string specifying filename.\n+       *  @param  mode  Mode in which to open file (see std::ios_base).\n+       *\n+       *  Tip:  When using std::string to hold the filename, you must use\n+       *  .c_str() before passing it to this constructor.\n+      */\n+      void\n+      open(const char* __s,\n \t   ios_base::openmode __mode = ios_base::out | ios_base::trunc)\n-      { \n+      {\n \tif (!_M_filebuf.open(__s, __mode | ios_base::out))\n-\t  this->setstate(ios_base::failbit); \n+\t  this->setstate(ios_base::failbit);\n       }\n \n-      void \n+      /** Close the file stream.  */\n+      void\n       close(void)\n-      { \n+      {\n \tif (!_M_filebuf.close())\n-\t  this->setstate(ios_base::failbit); \n+\t  this->setstate(ios_base::failbit);\n       }\n     };\n \n \n   // 27.8.1.11  Template class basic_fstream\n+  /**\n+   *  Derivation of general input/output streams, specific to files.\n+  */\n   template<typename _CharT, typename _Traits>\n     class basic_fstream : public basic_iostream<_CharT, _Traits>\n     {\n@@ -378,46 +428,72 @@ namespace std\n \n     private:\n       __filebuf_type\t_M_filebuf;\n-      \n+\n     public:\n       // Constructors/destructor:\n+      /** Default constructor.  Create a file stream.  */\n       basic_fstream()\n       : __iostream_type(NULL), _M_filebuf()\n       { this->init(&_M_filebuf); }\n \n-      explicit \n+      /**\n+       *  @brief Create an input/output stream.\n+       *  @param  s  Null terminated string specifying filename.\n+       *  @param  mode  Open file in specified mode (see std::ios_base).\n+       *\n+       *  Tip:  When using std::string to hold the filename, you must use\n+       *  .c_str() before passing it to this constructor.\n+      */\n+      explicit\n       basic_fstream(const char* __s,\n \t\t    ios_base::openmode __mode = ios_base::in | ios_base::out)\n       : __iostream_type(NULL), _M_filebuf()\n-      { \n-\tthis->init(&_M_filebuf); \n-\tthis->open(__s, __mode); \n+      {\n+\tthis->init(&_M_filebuf);\n+\tthis->open(__s, __mode);\n       }\n- \n+\n       ~basic_fstream()\n       { }\n-    \n+\n       // Members:\n-      __filebuf_type* \n-      rdbuf(void) const \n+      /**\n+       *  @brief  Get a pointer to the file stream's buffer.\n+       *  @return Pointer to basic_filebuf.\n+      */\n+      __filebuf_type*\n+      rdbuf(void) const\n       { return const_cast<__filebuf_type*>(&_M_filebuf); }\n \n-      bool \n+      /**\n+       *  @brief Query to see if file stream is open.\n+       *  @return True if stream is open.\n+      */\n+      bool\n       is_open(void) { return _M_filebuf.is_open(); }\n \n-      void \n-      open(const char* __s, \n+      /**\n+       *  @brief Specify a file to open for input and/or output.\n+       *  @param  s  Null terminated string specifying filename.\n+       *  @param  mode  Mode in which to open file (see std::ios_base).\n+       *\n+       *  Tip:  When using std::string to hold the filename, you must use\n+       *  .c_str() before passing it to this constructor.\n+      */\n+      void\n+      open(const char* __s,\n \t   ios_base::openmode __mode = ios_base::in | ios_base::out)\n-      { \n+      {\n \tif (!_M_filebuf.open(__s, __mode))\n-\t  setstate(ios_base::failbit); \n+\t  setstate(ios_base::failbit);\n       }\n \n-      void \n+      /** Close the file stream.  */\n+      void\n       close(void)\n-      { \n+      {\n \tif (!_M_filebuf.close())\n-\t  setstate(ios_base::failbit); \n+\t  setstate(ios_base::failbit);\n       }\n     };\n } // namespace std\n@@ -429,4 +505,4 @@ namespace std\n #endif\n #endif\n \n-#endif\t\n+#endif"}]}