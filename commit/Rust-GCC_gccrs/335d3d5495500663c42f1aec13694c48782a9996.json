{"sha": "335d3d5495500663c42f1aec13694c48782a9996", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM1ZDNkNTQ5NTUwMDY2M2M0MmYxYWVjMTM2OTRjNDg3ODJhOTk5Ng==", "commit": {"author": {"name": "Dorit Naishlos", "email": "dorit@il.ibm.com", "date": "2004-11-19T19:08:03Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2004-11-19T19:08:03Z"}, "message": "tree-vectorizer.c (slpeel_make_loop_iterate_ntimes): Last two arguments removed.\n\n        * tree-vectorizer.c (slpeel_make_loop_iterate_ntimes): Last two\n        arguments removed.\n        (slpeel_tree_peel_loop_to_edge): Call slpeel_make_loop_iterate_ntimes\n        without last two arguments. Update single_exit of loops.\n        (vect_update_niters_after_peeling): Removed. Its functionality was\n        moved to vect_do_peeling_for_alignment.\n        (vect_do_peeling_for_loop_bound): New name for function previously\n        called vect_transform_for_unknown_loop_bound.\n        (vect_transform_loop_bound): Call slpeel_make_loop_iterate_ntimes\n        instead of code that duplicates the same functionality.\n        (vect_do_peeling_for_alignment): Functionality of\n        vect_update_niters_after_peeling moved here.\n        (vect_transform_loop): Unify call to vect_do_peeling_for_loop_bound -\n        previously named vect_transform_for_unknown_loop_bound - for both known\n        and unknown loop bound cases.\n\nFrom-SVN: r90931", "tree": {"sha": "4881a7709f8620fe03653bdfdebb9627303044a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4881a7709f8620fe03653bdfdebb9627303044a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/335d3d5495500663c42f1aec13694c48782a9996", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/335d3d5495500663c42f1aec13694c48782a9996", "html_url": "https://github.com/Rust-GCC/gccrs/commit/335d3d5495500663c42f1aec13694c48782a9996", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/335d3d5495500663c42f1aec13694c48782a9996/comments", "author": null, "committer": null, "parents": [{"sha": "d6901754328ca02294c088a792630ed81dc63165", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6901754328ca02294c088a792630ed81dc63165", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6901754328ca02294c088a792630ed81dc63165"}], "stats": {"total": 139, "additions": 49, "deletions": 90}, "files": [{"sha": "cf8c73bb24baa310c12fe5da708a31ae6dc9c49d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/335d3d5495500663c42f1aec13694c48782a9996/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/335d3d5495500663c42f1aec13694c48782a9996/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=335d3d5495500663c42f1aec13694c48782a9996", "patch": "@@ -1,3 +1,21 @@\n+2004-11-19  Dorit Naishlos  <dorit@il.ibm.com>\n+\n+\t* tree-vectorizer.c (slpeel_make_loop_iterate_ntimes): Last two\n+\targuments removed.\n+\t(slpeel_tree_peel_loop_to_edge): Call slpeel_make_loop_iterate_ntimes\n+\twithout last two arguments. Update single_exit of loops.\n+\t(vect_update_niters_after_peeling): Removed. Its functionality was\n+\tmoved to vect_do_peeling_for_alignment. \n+\t(vect_do_peeling_for_loop_bound): New name for function previously\n+\tcalled vect_transform_for_unknown_loop_bound.\n+\t(vect_transform_loop_bound): Call slpeel_make_loop_iterate_ntimes\n+\tinstead of code that duplicates the same functionality.\n+\t(vect_do_peeling_for_alignment): Functionality of   \n+\tvect_update_niters_after_peeling moved here.\n+\t(vect_transform_loop): Unify call to vect_do_peeling_for_loop_bound -\n+\tpreviously named vect_transform_for_unknown_loop_bound - for both known\n+\tand unknown loop bound cases.\n+\n 2004-11-19  Dorit Naishlos  <dorit@il.ibm.com>\n \n \t* tree-vectorizer.c (slpeel_can_duplicate_loop_p): New name for function"}, {"sha": "a7cc59bd5797efdea76d17fa27b3b5d8f4317081", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 31, "deletions": 90, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/335d3d5495500663c42f1aec13694c48782a9996/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/335d3d5495500663c42f1aec13694c48782a9996/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=335d3d5495500663c42f1aec13694c48782a9996", "patch": "@@ -165,7 +165,7 @@ static struct loop *slpeel_tree_duplicate_loop_to_edge_cfg\n static void slpeel_update_phis_for_duplicate_loop \n   (struct loop *, struct loop *, bool after);\n static void slpeel_update_phi_nodes_for_guard (edge, struct loop *);\n-static void slpeel_make_loop_iterate_ntimes (struct loop *, tree, tree, tree);\n+static void slpeel_make_loop_iterate_ntimes (struct loop *, tree);\n static edge slpeel_add_loop_guard (basic_block, tree, basic_block);\n static bool slpeel_can_duplicate_loop_p (struct loop *, edge);\n static void allocate_new_names (bitmap);\n@@ -251,12 +251,11 @@ static void vect_generate_tmps_on_preheader\n static tree vect_build_loop_niters (loop_vec_info);\n static void vect_update_ivs_after_vectorizer (struct loop *, tree); \n static tree vect_gen_niters_for_prolog_loop (loop_vec_info, tree);\n-static void vect_update_niters_after_peeling (loop_vec_info, tree);\n static void vect_update_inits_of_dr \n   (struct data_reference *, struct loop *, tree niters);\n static void vect_update_inits_of_drs (loop_vec_info, tree);\n static void vect_do_peeling_for_alignment (loop_vec_info, struct loops *);\n-static void vect_transform_for_unknown_loop_bound \n+static void vect_do_peeling_for_loop_bound \n   (loop_vec_info, tree *, struct loops *);\n \n /* Utilities for creation and deletion of vec_info structs.  */\n@@ -605,16 +604,19 @@ slpeel_update_phi_nodes_for_guard (edge guard_true_edge, struct loop * loop)\n \n \n /* Make the LOOP iterate NITERS times. This is done by adding a new IV\n-   that starts at zero, increases by one and its limit is NITERS.  */\n+   that starts at zero, increases by one and its limit is NITERS.\n+\n+   Assumption: the exit-condition of LOOP is the last stmt in the loop.  */\n \n static void\n-slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters,\n-\t\t\t\t tree begin_label, tree exit_label)\n+slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n {\n   tree indx_before_incr, indx_after_incr, cond_stmt, cond;\n   tree orig_cond;\n   edge exit_edge = loop->exit_edges[0];\n   block_stmt_iterator loop_exit_bsi = bsi_last (exit_edge->src);\n+  tree begin_label = tree_block_label (loop->latch);\n+  tree exit_label = tree_block_label (loop->single_exit->dest);\n \n   /* Flow loop scan does not update loop->single_exit field.  */\n   loop->single_exit = loop->exit_edges[0];\n@@ -948,17 +950,13 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n      and second loop preheader edge.  */\n   flow_loop_scan (first_loop, LOOP_ALL);\n   flow_loop_scan (second_loop, LOOP_ALL);  \n+  /* Flow loop scan does not update loop->single_exit field.  */\n+  first_loop->single_exit = first_loop->exit_edges[0];\n+  second_loop->single_exit = second_loop->exit_edges[0];\n \n   /* 3. Make first loop iterate FIRST_NITERS times, if needed.  */\n   if (!update_first_loop_count)\n-    {\n-      tree first_loop_latch_lbl = tree_block_label (first_loop->latch);\n-      tree first_loop_exit_lbl = tree_block_label (first_exit_bb);\n-\n-      slpeel_make_loop_iterate_ntimes (first_loop, first_niters,\n-\t\t\t\tfirst_loop_latch_lbl,\n-\t\t\t\tfirst_loop_exit_lbl);\n-    }\n+    slpeel_make_loop_iterate_ntimes (first_loop, first_niters);\n   \n   /* 4. Add the guard before first loop:\n \n@@ -2791,16 +2789,11 @@ static void\n vect_transform_loop_bound (loop_vec_info loop_vinfo, tree niters)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  edge exit_edge = loop->single_exit;\n-  block_stmt_iterator loop_exit_bsi = bsi_last (exit_edge->src);\n-  tree indx_before_incr, indx_after_incr;\n   tree orig_cond_expr;\n   HOST_WIDE_INT old_N = 0;\n   int vf;\n-  tree cond_stmt;\n   tree new_loop_bound;\n   bool symbol_niters;\n-  tree cond;\n   tree lb_type;\n \n   symbol_niters = !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo);\n@@ -2814,45 +2807,16 @@ vect_transform_loop_bound (loop_vec_info loop_vinfo, tree niters)\n #ifdef ENABLE_CHECKING\n   gcc_assert (orig_cond_expr);\n #endif\n-  gcc_assert (orig_cond_expr == bsi_stmt (loop_exit_bsi));\n-\n-  create_iv (integer_zero_node, integer_one_node, NULL_TREE, loop, \n-\t     &loop_exit_bsi, false, &indx_before_incr, &indx_after_incr);\n-\n-  /* bsi_insert is using BSI_NEW_STMT. We need to bump it back \n-     to point to the exit condition.  */\n-  bsi_next (&loop_exit_bsi);\n-  gcc_assert (bsi_stmt (loop_exit_bsi) == orig_cond_expr);\n \n   /* new loop exit test:  */\n   lb_type = TREE_TYPE (TREE_OPERAND (COND_EXPR_COND (orig_cond_expr), 1));\n   if (!symbol_niters)\n-    new_loop_bound = fold_convert (lb_type, \n-\t\t\t\t   build_int_cst (unsigned_type_node, \n-\t\t\t\t\t\t  old_N/vf));\n+    new_loop_bound = \n+\tfold_convert (lb_type, build_int_cst (unsigned_type_node, old_N/vf));\n   else\n     new_loop_bound = niters;\n \n-  if (exit_edge->flags & EDGE_TRUE_VALUE) /* 'then' edge exits the loop.  */\n-    cond = build2 (GE_EXPR, boolean_type_node, \n-\t\t   indx_after_incr, new_loop_bound);\n-  else /* 'then' edge loops back.  */\n-    cond = build2 (LT_EXPR, boolean_type_node, \n-\t\t   indx_after_incr, new_loop_bound);\n-\n-  cond_stmt = build3 (COND_EXPR, TREE_TYPE (orig_cond_expr), cond,\n-\t\t      COND_EXPR_THEN (orig_cond_expr),\n-\t\t      COND_EXPR_ELSE (orig_cond_expr));\n-\n-  bsi_insert_before (&loop_exit_bsi, cond_stmt, BSI_SAME_STMT);   \n-\n-  /* remove old loop exit test:  */\n-  bsi_remove (&loop_exit_bsi);\n-\n-  if (vect_debug_details (NULL))\n-    print_generic_expr (dump_file, cond_stmt, TDF_SLIM);\n-\n-  loop->nb_iterations = new_loop_bound;\n+  slpeel_make_loop_iterate_ntimes (loop, new_loop_bound);\n }\n \n \n@@ -2978,8 +2942,8 @@ vect_update_ivs_after_vectorizer (struct loop *loop, tree niters)\n    unknown loop bound.  */\n \n static void \n-vect_transform_for_unknown_loop_bound (loop_vec_info loop_vinfo, tree * ratio,\n-\t\t\t\t       struct loops *loops)\n+vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree * ratio,\n+\t\t\t\tstruct loops *loops)\n {\n \n   tree ni_name, ratio_mult_vf_name;\n@@ -3095,21 +3059,6 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree niters)\n }\n \n \n-/* Function vect_update_niters_after_peeling\n-\n-   NITERS iterations were peeled from the loop represented by LOOP_VINFO. \n-   The new number of iterations is therefore original_niters - NITERS.\n-   Record the new number of iterations in LOOP_VINFO.  */\n-\n-static void\n-vect_update_niters_after_peeling (loop_vec_info loop_vinfo, tree niters)\n-{\n-  tree n_iters = LOOP_VINFO_NITERS (loop_vinfo);\n-  LOOP_VINFO_NITERS (loop_vinfo) = \n-    build (MINUS_EXPR, integer_type_node, n_iters, niters);      \n-}\n-\n-\n /* Function vect_update_inits_of_dr\n \n    NITERS iterations were peeled from LOOP.  DR represents a data reference\n@@ -3183,6 +3132,7 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, struct loops *loops)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree niters_of_prolog_loop, ni_name;\n+  tree n_iters;\n \n   if (vect_debug_details (NULL))\n     fprintf (dump_file, \"\\n<<vect_do_peeling_for_alignment>>\\n\");\n@@ -3196,7 +3146,9 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, struct loops *loops)\n \t\t\t\t niters_of_prolog_loop, ni_name, false); \n \n   /* Update number of times loop executes.  */\n-  vect_update_niters_after_peeling (loop_vinfo, niters_of_prolog_loop);\n+  n_iters = LOOP_VINFO_NITERS (loop_vinfo);\n+  LOOP_VINFO_NITERS (loop_vinfo) =\n+    build (MINUS_EXPR, integer_type_node, n_iters, niters_of_prolog_loop);\n \n   /* Update all inits of access functions of all data refs.  */\n   vect_update_inits_of_drs (loop_vinfo, niters_of_prolog_loop);\n@@ -3233,32 +3185,21 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n   /* Peel the loop if there are data refs with unknown alignment.\n      Only one data ref with unknown store is allowed.  */\n \n-  \n   if (LOOP_DO_PEELING_FOR_ALIGNMENT (loop_vinfo))\n     vect_do_peeling_for_alignment (loop_vinfo, loops);\n   \n-  /* If the loop has a symbolic number of iterations 'n' \n-     (i.e. it's not a compile time constant), \n-     then an epilog loop needs to be created. We therefore duplicate \n-     the initial loop. The original loop will be vectorized, and will compute\n-     the first (n/VF) iterations. The second copy of the loop will remain \n-     serial and will compute the remaining (n%VF) iterations.\n+  /* If the loop has a symbolic number of iterations 'n' (i.e. it's not a\n+     compile time constant), or it is a constant that doesn't divide by the\n+     vectorization factor, then an epilog loop needs to be created.\n+     We therefore duplicate the loop: the original loop will be vectorized,\n+     and will compute the first (n/VF) iterations. The second copy of the loop\n+     will remain scalar and will compute the remaining (n%VF) iterations.\n      (VF is the vectorization factor).  */\n \n-  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n-    vect_transform_for_unknown_loop_bound (loop_vinfo, &ratio, loops);\n-\n-  /* FORNOW: we'll treat the case where niters is constant and \n-     \n-                        niters % vf != 0\n-\n-     in the way similar to one with symbolic niters. \n-     For this we'll generate variable which value is equal to niters.  */\n-\n-  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo) \n-      && (LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0))\n-    vect_transform_for_unknown_loop_bound (loop_vinfo, &ratio, loops);\n-\n+  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      || (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+          && LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0))\n+    vect_do_peeling_for_loop_bound (loop_vinfo, &ratio, loops);\n \n   /* 1) Make sure the loop header has exactly two entries\n      2) Make sure we have a preheader basic block.  */"}]}