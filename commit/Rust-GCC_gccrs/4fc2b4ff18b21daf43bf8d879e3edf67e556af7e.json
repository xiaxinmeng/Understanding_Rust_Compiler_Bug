{"sha": "4fc2b4ff18b21daf43bf8d879e3edf67e556af7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZjMmI0ZmYxOGIyMWRhZjQzYmY4ZDg3OWUzZWRmNjdlNTU2YWY3ZQ==", "commit": {"author": {"name": "Andy Hutchinson", "email": "HutchinsonAndy@netscape.net", "date": "2007-05-19T10:59:17Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2007-05-19T10:59:17Z"}, "message": "avr-protos.h (expand_prologue, [...]): Add declaration.\n\n\t* config/avr/avr-protos.h (expand_prologue, expand_epilogue, \n\tavr_epilogue_uses) : Add declaration.\n\t* config/avr/predicates.md (avr_sp_immediate_operand): New predicate.\n\t* config/avr/constraints.md (R): New constraint.\n\tconfig/avr/avr.md (SREG_ADDR,  UNSPEC_SEI, UNSPEC_CLI, \n\tUNSPECV_PROLOGUE_SAVES, UNSPECV_EPILOGUE_RESTORES): New constants.\n\t(*pop1, *pop2, *pop3, *pop4, *pop5): Combine into ...\n\t(*addhi3_sp_R_pc2, *addhi3_sp_R_pc3): ... these patterns.\n\t(*movhi_sp, popqi, pophi, enable_interrupt, disable_interrupt, \n\tcall_prologue_saves, epilogue_restores, return_from_epilogue,\n\treturn_from_main_epilogue, return_from_interrupt_epilogue, \n\treturn_from_naked_epilogue, prologue, epilogue): New patterns.\n\t(jump): Handle symbol reference.\n\t* config/avr/avr.c (out_adj_frame_ptr, out_set_stack_ptr, \n\tavr_output_function_prologue, avr_output_function_epilogue): Remove \n\tfunctions.\n\t(avr_init_machine_status, expand_prologue, expand_epilogue, \n\tavr_asm_function_end_prologue, avr_epilogue_uses, \n\tavr_asm_function_begin_epilogue): New functions.\n\t(prologue_size, epilogue_size, jump_tables_size): Remove global \n\tvariables.\n\t(TARGET_ASM_FUNCTION_PROLOGUE, TARGET_ASM_FUNCTION_EPILOGUE): Remove.\n\t(TARGET_ASM_FUNCTION_END_PROLOGUE): Define.\n\t(TARGET_ASM_FUNCTION_BEGIN_EPILOGUE): Define.\n\t(avr_override_options): Initialise init_machine_status.\n\t(output_movhi): Handle all stack pointer loads.\n\t(out_movqi_r_mr, out_movqi_mr_r): Handle SREG_ADDR address.\n\t(avr_output_addr_vec_elt): Do not use variable jump_tables_size.\n\t* config/avr/avr.h (AVR_2_BYTE_PC, AVR_3_BYTE_PC): New.\n\t(EPILOGUE_USES) Redefine.\n\t(machine_function) Declare.\n\nCo-Authored-By: Anatoly Sokolov <aesok@dol.ru>\n\nFrom-SVN: r124854", "tree": {"sha": "e1afdb336d4a391ac60933901f808c63399b7edb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1afdb336d4a391ac60933901f808c63399b7edb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fc2b4ff18b21daf43bf8d879e3edf67e556af7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fc2b4ff18b21daf43bf8d879e3edf67e556af7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fc2b4ff18b21daf43bf8d879e3edf67e556af7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fc2b4ff18b21daf43bf8d879e3edf67e556af7e/comments", "author": null, "committer": null, "parents": [{"sha": "6de3644168854618eafd229d72356ead4f92a0cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6de3644168854618eafd229d72356ead4f92a0cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6de3644168854618eafd229d72356ead4f92a0cf"}], "stats": {"total": 1143, "additions": 749, "deletions": 394}, "files": [{"sha": "c012554030c6a827dd4a7d3667e9466ec3f8d249", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc2b4ff18b21daf43bf8d879e3edf67e556af7e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc2b4ff18b21daf43bf8d879e3edf67e556af7e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4fc2b4ff18b21daf43bf8d879e3edf67e556af7e", "patch": "@@ -1,3 +1,38 @@\n+2007-05-19 Andy Hutchinson <HutchinsonAndy@netscape.net>\n+           Anatoly Sokolov <aesok@dol.ru>\n+\n+\t* config/avr/avr-protos.h (expand_prologue, expand_epilogue, \n+\tavr_epilogue_uses) : Add declaration.\n+\t* config/avr/predicates.md (avr_sp_immediate_operand): New predicate.\n+\t* config/avr/constraints.md (R): New constraint.\n+\tconfig/avr/avr.md (SREG_ADDR,  UNSPEC_SEI, UNSPEC_CLI, \n+\tUNSPECV_PROLOGUE_SAVES, UNSPECV_EPILOGUE_RESTORES): New constants.\n+\t(*pop1, *pop2, *pop3, *pop4, *pop5): Combine into ...\n+\t(*addhi3_sp_R_pc2, *addhi3_sp_R_pc3): ... these patterns.\n+\t(*movhi_sp, popqi, pophi, enable_interrupt, disable_interrupt, \n+\tcall_prologue_saves, epilogue_restores, return_from_epilogue,\n+\treturn_from_main_epilogue, return_from_interrupt_epilogue, \n+\treturn_from_naked_epilogue, prologue, epilogue): New patterns.\n+\t(jump): Handle symbol reference.\n+\t* config/avr/avr.c (out_adj_frame_ptr, out_set_stack_ptr, \n+\tavr_output_function_prologue, avr_output_function_epilogue): Remove \n+\tfunctions.\n+\t(avr_init_machine_status, expand_prologue, expand_epilogue, \n+\tavr_asm_function_end_prologue, avr_epilogue_uses, \n+\tavr_asm_function_begin_epilogue): New functions.\n+\t(prologue_size, epilogue_size, jump_tables_size): Remove global \n+\tvariables.\n+\t(TARGET_ASM_FUNCTION_PROLOGUE, TARGET_ASM_FUNCTION_EPILOGUE): Remove.\n+\t(TARGET_ASM_FUNCTION_END_PROLOGUE): Define.\n+\t(TARGET_ASM_FUNCTION_BEGIN_EPILOGUE): Define.\n+\t(avr_override_options): Initialise init_machine_status.\n+\t(output_movhi): Handle all stack pointer loads.\n+\t(out_movqi_r_mr, out_movqi_mr_r): Handle SREG_ADDR address.\n+\t(avr_output_addr_vec_elt): Do not use variable jump_tables_size.\n+\t* config/avr/avr.h (AVR_2_BYTE_PC, AVR_3_BYTE_PC): New.\n+\t(EPILOGUE_USES) Redefine.\n+\t(machine_function) Declare.\n+\n 2007-05-19  Richard Sandiford  <richard@codesourcery.com>\n \n \t* config/mips/mips.c (mips_offset_within_alignment_p): Tweak comment."}, {"sha": "50dbd12cc263505c4ff298ee6bd71948445c1e5e", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc2b4ff18b21daf43bf8d879e3edf67e556af7e/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc2b4ff18b21daf43bf8d879e3edf67e556af7e/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=4fc2b4ff18b21daf43bf8d879e3edf67e556af7e", "patch": "@@ -87,6 +87,10 @@ extern const char *lshrqi3_out (rtx insn, rtx operands[], int *len);\n extern const char *lshrhi3_out (rtx insn, rtx operands[], int *len);\n extern const char *lshrsi3_out (rtx insn, rtx operands[], int *len);\n \n+extern void expand_prologue (void);\n+extern void expand_epilogue (void);\n+extern int avr_epilogue_uses (int regno);\n+\n extern void avr_output_bld (rtx operands[], int bit_nr);\n extern void avr_output_addr_vec_elt (FILE *stream, int value);\n extern const char *avr_out_sbxx_branch (rtx insn, rtx operands[]);"}, {"sha": "950777c7c1582d0973dcb5ba187dcd63c0c127e4", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 363, "deletions": 340, "changes": 703, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc2b4ff18b21daf43bf8d879e3edf67e556af7e/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc2b4ff18b21daf43bf8d879e3edf67e556af7e/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=4fc2b4ff18b21daf43bf8d879e3edf67e556af7e", "patch": "@@ -56,8 +56,7 @@ static int sequent_regs_live (void);\n static const char *ptrreg_to_str (int);\n static const char *cond_string (enum rtx_code);\n static int avr_num_arg_regs (enum machine_mode, tree);\n-static int out_adj_frame_ptr (FILE *, int);\n-static int out_set_stack_ptr (FILE *, int, int);\n+\n static RTX_CODE compare_condition (rtx insn);\n static int compare_sign_p (rtx insn);\n static tree avr_handle_progmem_attribute (tree *, tree, tree, int, bool *);\n@@ -66,8 +65,8 @@ const struct attribute_spec avr_attribute_table[];\n static bool avr_assemble_integer (rtx, unsigned int, int);\n static void avr_file_start (void);\n static void avr_file_end (void);\n-static void avr_output_function_prologue (FILE *, HOST_WIDE_INT);\n-static void avr_output_function_epilogue (FILE *, HOST_WIDE_INT);\n+static void avr_asm_function_end_prologue (FILE *);\n+static void avr_asm_function_begin_epilogue (FILE *);\n static void avr_insert_attributes (tree, tree *);\n static void avr_asm_init_sections (void);\n static unsigned int avr_section_type_flags (tree, const char *, int);\n@@ -79,7 +78,7 @@ static int avr_operand_rtx_cost (rtx, enum machine_mode, enum rtx_code);\n static bool avr_rtx_costs (rtx, int, int, int *);\n static int avr_address_cost (rtx);\n static bool avr_return_in_memory (tree, tree);\n-\n+static struct machine_function * avr_init_machine_status (void);\n /* Allocate registers from r25 to r8 for parameters for function calls.  */\n #define FIRST_CUM_REG 26\n \n@@ -104,13 +103,6 @@ static int commands_in_prologues;\n /* Commands in the functions epilogues in the compiled file */\n static int commands_in_epilogues;\n \n-/* Prologue/Epilogue size in words */\n-static int prologue_size;\n-static int epilogue_size;\n-\n-/* Size of all jump tables in the current function, in words.  */\n-static int jump_tables_size;\n-\n /* Preprocessor macros to define depending on MCU type.  */\n const char *avr_base_arch_macro;\n const char *avr_extra_arch_macro;\n@@ -299,10 +291,10 @@ int avr_case_values_threshold = 30000;\n #undef TARGET_ASM_FILE_END\n #define TARGET_ASM_FILE_END avr_file_end\n \n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE avr_output_function_prologue\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE avr_output_function_epilogue\n+#undef TARGET_ASM_FUNCTION_END_PROLOGUE\n+#define TARGET_ASM_FUNCTION_END_PROLOGUE avr_asm_function_end_prologue\n+#undef TARGET_ASM_FUNCTION_BEGIN_EPILOGUE\n+#define TARGET_ASM_FUNCTION_BEGIN_EPILOGUE avr_asm_function_begin_epilogue\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE avr_attribute_table\n #undef TARGET_ASM_FUNCTION_RODATA_SECTION\n@@ -359,6 +351,8 @@ avr_override_options (void)\n \n   tmp_reg_rtx  = gen_rtx_REG (QImode, TMP_REGNO);\n   zero_reg_rtx = gen_rtx_REG (QImode, ZERO_REGNO);\n+\n+  init_machine_status = avr_init_machine_status;\n }\n \n /*  return register class from register number.  */\n@@ -377,6 +371,15 @@ static const int reg_class_tab[]={\n   STACK_REG,STACK_REG           /* SPL,SPH */\n };\n \n+/* Function to set up the backend function structure.  */\n+\n+static struct machine_function *\n+avr_init_machine_status (void)\n+{\n+  return ((struct machine_function *) \n+          ggc_alloc_cleared (sizeof (struct machine_function)));\n+}\n+\n /* Return register class for register R.  */\n \n enum reg_class\n@@ -550,388 +553,382 @@ sequent_regs_live (void)\n   return (cur_seq == live_seq) ? live_seq : 0;\n }\n \n+/*  Output function prologue.  */\n \n-/* Output to FILE the asm instructions to adjust the frame pointer by\n-   ADJ (r29:r28 -= ADJ;) which can be positive (prologue) or negative\n-   (epilogue).  Returns the number of instructions generated.  */\n-\n-static int\n-out_adj_frame_ptr (FILE *file, int adj)\n+void\n+expand_prologue (void)\n {\n-  int size = 0;\n+  int live_seq;\n+  int minimize;\n+  HOST_WIDE_INT size = get_frame_size();\n+  /* Define templates for push instructions.  */\n+  rtx pushbyte = gen_rtx_MEM (QImode,\n+                  gen_rtx_POST_DEC (HImode, stack_pointer_rtx));\n+  rtx pushword = gen_rtx_MEM (HImode,\n+                  gen_rtx_POST_DEC (HImode, stack_pointer_rtx));\n+  rtx insn;\n \n-  if (adj)\n+  last_insn_address = 0;\n+  \n+  /* Init cfun->machine.  */\n+  cfun->machine->is_main = MAIN_NAME_P (DECL_NAME (current_function_decl));\n+  cfun->machine->is_naked = avr_naked_function_p (current_function_decl);\n+  cfun->machine->is_interrupt = interrupt_function_p (current_function_decl);\n+  cfun->machine->is_signal = signal_function_p (current_function_decl);\n+  \n+  /* Prologue: naked.  */\n+  if (cfun->machine->is_naked)\n     {\n-      if (TARGET_TINY_STACK)\n-\t{\n-\t  if (adj < -63 || adj > 63)\n-\t    warning (0, \"large frame pointer change (%d) with -mtiny-stack\", adj);\n-\n-\t  /* The high byte (r29) doesn't change - prefer \"subi\" (1 cycle)\n-\t     over \"sbiw\" (2 cycles, same size).  */\n-\n-\t  fprintf (file, (AS2 (subi, r28, %d) CR_TAB), adj);\n-\t  size++;\n-\t}\n-      else if (adj < -63 || adj > 63)\n-\t{\n-\t  fprintf (file, (AS2 (subi, r28, lo8(%d)) CR_TAB\n-\t\t\t  AS2 (sbci, r29, hi8(%d)) CR_TAB),\n-\t\t   adj, adj);\n-\t  size += 2;\n-\t}\n-      else if (adj < 0)\n-\t{\n-\t  fprintf (file, (AS2 (adiw, r28, %d) CR_TAB), -adj);\n-\t  size++;\n-\t}\n-      else\n-\t{\n-\t  fprintf (file, (AS2 (sbiw, r28, %d) CR_TAB), adj);\n-\t  size++;\n-\t}\n+      return;\n     }\n-  return size;\n-}\n-\n \n-/* Output to FILE the asm instructions to copy r29:r28 to SPH:SPL,\n-   handling various cases of interrupt enable flag state BEFORE and AFTER\n-   (0=disabled, 1=enabled, -1=unknown/unchanged) and target_flags.\n-   Returns the number of instructions generated.  */\n-\n-static int\n-out_set_stack_ptr (FILE *file, int before, int after)\n-{\n-  int do_sph, do_cli, do_save, do_sei, lock_sph, size;\n-\n-  /* The logic here is so that -mno-interrupts actually means\n-     \"it is safe to write SPH in one instruction, then SPL in the\n-     next instruction, without disabling interrupts first\".\n-     The after != -1 case (interrupt/signal) is not affected.  */\n-\n-  do_sph = !TARGET_TINY_STACK;\n-  lock_sph = do_sph && !TARGET_NO_INTERRUPTS;\n-  do_cli = (before != 0 && (after == 0 || lock_sph));\n-  do_save = (do_cli && before == -1 && after == -1);\n-  do_sei = ((do_cli || before != 1) && after == 1);\n-  size = 1;\n+  live_seq = sequent_regs_live ();\n+  minimize = (TARGET_CALL_PROLOGUES\n+\t      && !(cfun->machine->is_interrupt || cfun->machine->is_signal) \n+\t      && live_seq);\n \n-  if (do_save)\n+  if (cfun->machine->is_interrupt || cfun->machine->is_signal)\n     {\n-      fprintf (file, AS2 (in, __tmp_reg__, __SREG__) CR_TAB);\n-      size++;\n-    }\n+      if (cfun->machine->is_interrupt)\n+        {\n+          /* Enable interrupts.  */\n+          insn = emit_insn (gen_enable_interrupt ());\n+          RTX_FRAME_RELATED_P (insn) = 1;\n+        }\n+\t\n+      /* Push zero reg.  */\n+      insn = emit_move_insn (pushbyte, zero_reg_rtx);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      /* Push tmp reg.  */\n+      insn = emit_move_insn (pushbyte, tmp_reg_rtx);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      /* Push SREG.  */\n+      insn = emit_move_insn (tmp_reg_rtx, \n+                             gen_rtx_MEM (QImode, GEN_INT (SREG_ADDR)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      insn = emit_move_insn (pushbyte, tmp_reg_rtx);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      \n+      /* Clear zero reg.  */\n+      insn = emit_move_insn (zero_reg_rtx, const0_rtx);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n \n-  if (do_cli)\n-    {\n-      fprintf (file, \"cli\" CR_TAB);\n-      size++;\n+      /* Prevent any attempt to delete the setting of ZERO_REG!  */\n+      emit_insn (gen_rtx_USE (VOIDmode, zero_reg_rtx));\n     }\n-\n-  /* Do SPH first - maybe this will disable interrupts for one instruction\n-     someday (a suggestion has been sent to avr@atmel.com for consideration\n-     in future devices - that would make -mno-interrupts always safe).  */\n-  if (do_sph)\n+  if (cfun->machine->is_main)\n     {\n-      fprintf (file, AS2 (out, __SP_H__, r29) CR_TAB);\n-      size++;\n+      char buffer[40];\n+      sprintf (buffer, \"%s - %d\", avr_init_stack, (int) size);\n+      rtx sym = gen_rtx_SYMBOL_REF (HImode, ggc_strdup (buffer));\n+      /*  Initialise stack pointer using frame pointer.  */\n+      insn = emit_move_insn (frame_pointer_rtx, sym);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      insn = emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n-\n-  /* Set/restore the I flag now - interrupts will be really enabled only\n-     after the next instruction.  This is not clearly documented, but\n-     believed to be true for all AVR devices.  */\n-  if (do_save)\n+  else if (minimize && (frame_pointer_needed || live_seq > 6)) \n     {\n-      fprintf (file, AS2 (out, __SREG__, __tmp_reg__) CR_TAB);\n-      size++;\n+      insn = \n+        emit_insn (gen_call_prologue_saves (gen_int_mode (size, HImode),\n+                                            gen_int_mode (live_seq, HImode)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n-  else if (do_sei)\n+  else\n     {\n-      fprintf (file, \"sei\" CR_TAB);\n-      size++;\n+      HARD_REG_SET set;\n+      avr_regs_to_save (&set);\n+      int reg;\n+      for (reg = 0; reg < 32; ++reg)\n+        {\n+          if (TEST_HARD_REG_BIT (set, reg))\n+            {\n+              /* Emit push of register to save.  */\n+              insn=emit_move_insn (pushbyte, gen_rtx_REG (QImode, reg));\n+              RTX_FRAME_RELATED_P (insn) = 1;\n+            }\n+        }\n+      if (frame_pointer_needed)\n+        {\n+          /* Push frame pointer.  */\n+\t  insn = emit_move_insn (pushword, frame_pointer_rtx);\n+          RTX_FRAME_RELATED_P (insn) = 1;\n+          if (!size)\n+            {\n+              insn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+              RTX_FRAME_RELATED_P (insn) = 1;\n+            }\n+          else\n+            {\n+              /*  Creating a frame can be done by direct manipulation of the\n+                  stack or via the frame pointer. These two methods are:\n+                    fp=sp\n+                    fp-=size\n+                    sp=fp\n+                OR\n+                    sp-=size\n+                    fp=sp\n+              the optimum method depends on function type, stack and frame size.\n+              To avoid a complex logic, both methods are tested and shortest\n+              is selected.  */\n+              rtx myfp;\n+              /*  First method.  */\n+              if (TARGET_TINY_STACK)\n+                {\n+                  if (size < -63 || size > 63)\n+                    warning (0, \"large frame pointer change (%d) with -mtiny-stack\", size);\n+                    \n+                  /* The high byte (r29) doesn't change - prefer 'subi' (1 cycle)\n+                     over 'sbiw' (2 cycles, same size).  */\n+                  myfp = gen_rtx_REG (QImode, REGNO (frame_pointer_rtx));\n+                }\n+              else \n+                {\n+                  /*  Normal sized addition.  */\n+                  myfp = frame_pointer_rtx;\n+                }\n+              /* Calculate length.  */ \n+              int method1_length;\n+              method1_length =\n+\t        get_attr_length (gen_move_insn (frame_pointer_rtx, stack_pointer_rtx));\n+              method1_length +=\n+\t        get_attr_length (gen_move_insn (myfp, \n+                                                gen_rtx_PLUS (GET_MODE(myfp), myfp,\n+                                                              gen_int_mode (-size, \n+\t\t\t\t\t\t\t                    GET_MODE(myfp)))));\n+              method1_length += \n+\t        get_attr_length (gen_move_insn (stack_pointer_rtx, frame_pointer_rtx));\n+              \n+\t      /* Method 2-Adjust Stack pointer.  */\n+              int sp_plus_length = 0;\n+              if (size <= 6)\n+                {\n+                  sp_plus_length = \n+\t\t    get_attr_length (gen_move_insn (stack_pointer_rtx,\n+                                                    gen_rtx_PLUS (HImode, stack_pointer_rtx,\n+                                                                  gen_int_mode (-size, \n+\t\t\t\t\t\t\t\t                HImode))));\n+\t\t  sp_plus_length += \n+\t\t    get_attr_length (gen_move_insn (frame_pointer_rtx, stack_pointer_rtx));\n+                }\n+              /* Use shortest method.  */\n+              if (size <= 6 && (sp_plus_length < method1_length))\n+                {\n+                  insn = emit_move_insn (stack_pointer_rtx,\n+                                         gen_rtx_PLUS (HImode, stack_pointer_rtx, \n+                                                       gen_int_mode (-size, HImode)));\n+                  RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t  insn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+                  RTX_FRAME_RELATED_P (insn) = 1;\n+                }\n+              else\n+                {\t\t\n+                  insn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+                  RTX_FRAME_RELATED_P (insn) = 1;\n+                  insn = emit_move_insn (myfp,\n+                                         gen_rtx_PLUS (GET_MODE(myfp), frame_pointer_rtx, \n+                                                       gen_int_mode (-size, GET_MODE(myfp))));\n+                  RTX_FRAME_RELATED_P (insn) = 1;\n+                  insn = emit_move_insn ( stack_pointer_rtx, frame_pointer_rtx);\n+                  RTX_FRAME_RELATED_P (insn) = 1;\n+                }\n+            }\n+        }\n     }\n-\n-  fprintf (file, AS2 (out, __SP_L__, r28) \"\\n\");\n-\n-  return size;\n }\n \n-\n-/* Output function prologue.  */\n+/* Output summary at end of function prologue.  */\n \n static void\n-avr_output_function_prologue (FILE *file, HOST_WIDE_INT size)\n+avr_asm_function_end_prologue (FILE *file)\n {\n-  int reg;\n-  int interrupt_func_p;\n-  int signal_func_p;\n-  int main_p;\n-  int live_seq;\n-  int minimize;\n-\n-  last_insn_address = 0;\n-  jump_tables_size = 0;\n-  prologue_size = 0;\n-  fprintf (file, \"/* prologue: frame size=\" HOST_WIDE_INT_PRINT_DEC \" */\\n\",\n-\t   size);\n-\n-  if (avr_naked_function_p (current_function_decl))\n+  if (cfun->machine->is_naked)\n     {\n       fputs (\"/* prologue: naked */\\n\", file);\n-      goto out;\n-    }\n-\n-  interrupt_func_p = interrupt_function_p (current_function_decl);\n-  signal_func_p = signal_function_p (current_function_decl);\n-  main_p = MAIN_NAME_P (DECL_NAME (current_function_decl));\n-  live_seq = sequent_regs_live ();\n-  minimize = (TARGET_CALL_PROLOGUES\n-\t      && !interrupt_func_p && !signal_func_p && live_seq);\n-\n-  if (interrupt_func_p)\n-    {\n-      fprintf (file,\"\\tsei\\n\");\n-      ++prologue_size;\n-    }\n-  if (interrupt_func_p || signal_func_p)\n-    {\n-      fprintf (file, \"\\t\"\n-               AS1 (push,__zero_reg__)   CR_TAB\n-               AS1 (push,__tmp_reg__)    CR_TAB\n-\t       AS2 (in,__tmp_reg__,__SREG__) CR_TAB\n-\t       AS1 (push,__tmp_reg__)    CR_TAB\n-\t       AS1 (clr,__zero_reg__)    \"\\n\");\n-      prologue_size += 5;\n-    }\n-  if (main_p)\n-    {\n-      fprintf (file, (\"\\t\" \n-\t\t      AS1 (ldi,r28) \",lo8(%s - \" HOST_WIDE_INT_PRINT_DEC \")\" CR_TAB\n-\t\t      AS1 (ldi,r29) \",hi8(%s - \" HOST_WIDE_INT_PRINT_DEC \")\" CR_TAB\n-\t\t      AS2 (out,__SP_H__,r29)     CR_TAB\n-\t\t      AS2 (out,__SP_L__,r28) \"\\n\"),\n-\t       avr_init_stack, size, avr_init_stack, size);\n-      \n-      prologue_size += 4;\n     }\n-  else if (minimize && (frame_pointer_needed || live_seq > 6)) \n+  else\n     {\n-      fprintf (file, (\"\\t\"\n-\t\t      AS1 (ldi, r26) \",lo8(\" HOST_WIDE_INT_PRINT_DEC \")\" CR_TAB\n-\t\t      AS1 (ldi, r27) \",hi8(\" HOST_WIDE_INT_PRINT_DEC \")\" CR_TAB), size, size);\n-\n-      fputs ((AS2 (ldi,r30,pm_lo8(1f)) CR_TAB\n-\t      AS2 (ldi,r31,pm_hi8(1f)) CR_TAB), file);\n-      \n-      prologue_size += 4;\n-      \n-      if (AVR_MEGA)\n-\t{\n-\t  fprintf (file, AS1 (jmp,__prologue_saves__+%d) \"\\n\",\n-\t\t   (18 - live_seq) * 2);\n-\t  prologue_size += 2;\n-\t}\n+      if (cfun->machine->is_interrupt)\n+        {\n+          fputs (\"/* prologue: Interrupt */\\n\", file);\n+        }\n+      else if (cfun->machine->is_signal)\n+        {\n+          fputs (\"/* prologue: Signal */\\n\", file);\n+        }\n+      else if (cfun->machine->is_main)\n+        {\n+          fputs (\"/* prologue: main */\\n\", file);\n+        }\n       else\n-\t{\n-\t  fprintf (file, AS1 (rjmp,__prologue_saves__+%d) \"\\n\",\n-\t\t   (18 - live_seq) * 2);\n-\t  ++prologue_size;\n-\t}\n-      fputs (\"1:\\n\", file);\n+        fputs (\"/* prologue: function */\\n\", file);\n     }\n-  else\n-    {\n-      HARD_REG_SET set;\n+  fprintf (file, \"/* frame size = \" HOST_WIDE_INT_PRINT_DEC \" */\\n\",\n+                 get_frame_size());\n+}\n \n-      prologue_size += avr_regs_to_save (&set);\n-      for (reg = 0; reg < 32; ++reg)\n-\t{\n-\t  if (TEST_HARD_REG_BIT (set, reg))\n-\t    {\n-\t      fprintf (file, \"\\t\" AS1 (push,%s) \"\\n\", avr_regnames[reg]);\n-\t    }\n-\t}\n-      if (frame_pointer_needed)\n-\t{\n-\t  fprintf (file, \"\\t\"\n-\t\t   AS1 (push,r28) CR_TAB\n-\t\t   AS1 (push,r29) CR_TAB\n-\t\t   AS2 (in,r28,__SP_L__) CR_TAB\n-\t\t   AS2 (in,r29,__SP_H__) \"\\n\");\n-\t  prologue_size += 4;\n-\t  if (size)\n-\t    {\n-\t      fputs (\"\\t\", file);\n-\t      prologue_size += out_adj_frame_ptr (file, size);\n \n-\t      if (interrupt_func_p)\n-\t\t{\n-\t\t  prologue_size += out_set_stack_ptr (file, 1, 1);\n-\t\t}\n-\t      else if (signal_func_p)\n-\t\t{\n-\t\t  prologue_size += out_set_stack_ptr (file, 0, 0);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  prologue_size += out_set_stack_ptr (file, -1, -1);\n-\t\t}\n-\t    }\n-\t}\n-    }\n+/* Implement EPILOGUE_USES.  */\n \n- out:\n-  fprintf (file, \"/* prologue end (size=%d) */\\n\", prologue_size);\n+int\n+avr_epilogue_uses (int regno ATTRIBUTE_UNUSED)\n+{\n+  if (reload_completed \n+      && cfun->machine\n+      && (cfun->machine->is_interrupt || cfun->machine->is_signal))\n+    return 1;\n+  return 0;\n }\n \n-/* Output function epilogue.  */\n+/*  Output RTL epilogue.  */\n \n-static void\n-avr_output_function_epilogue (FILE *file, HOST_WIDE_INT size)\n+void\n+expand_epilogue (void)\n {\n   int reg;\n-  int interrupt_func_p;\n-  int signal_func_p;\n-  int main_p;\n-  int function_size;\n   int live_seq;\n   int minimize;\n-  rtx last = get_last_nonnote_insn ();\n-\n-  function_size = jump_tables_size;\n-  if (last)\n-    {\n-      rtx first = get_first_nonnote_insn ();\n-      function_size += (INSN_ADDRESSES (INSN_UID (last)) -\n-\t\t\tINSN_ADDRESSES (INSN_UID (first)));\n-      function_size += get_attr_length (last);\n-    }\n-\n-  fprintf (file, \"/* epilogue: frame size=\" HOST_WIDE_INT_PRINT_DEC \" */\\n\", size);\n-  epilogue_size = 0;\n-\n-  if (avr_naked_function_p (current_function_decl))\n-    {\n-      fputs (\"/* epilogue: naked */\\n\", file);\n-      goto out;\n-    }\n-\n-  if (last && GET_CODE (last) == BARRIER)\n+  HOST_WIDE_INT size = get_frame_size();\n+  rtx insn;\n+  \n+  /* epilogue: naked  */\n+  if (cfun->machine->is_naked)\n     {\n-      fputs (\"/* epilogue: noreturn */\\n\", file);\n-      goto out;\n+      insn = emit_jump_insn (gen_return ());\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      return;\n     }\n \n-  interrupt_func_p = interrupt_function_p (current_function_decl);\n-  signal_func_p = signal_function_p (current_function_decl);\n-  main_p = MAIN_NAME_P (DECL_NAME (current_function_decl));\n   live_seq = sequent_regs_live ();\n   minimize = (TARGET_CALL_PROLOGUES\n-\t      && !interrupt_func_p && !signal_func_p && live_seq);\n+\t      && !(cfun->machine->is_interrupt || cfun->machine->is_signal)\n+\t      && live_seq);\n   \n-  if (main_p)\n+  if (cfun->machine->is_main)\n     {\n       /* Return value from main() is already in the correct registers\n-\t (r25:r24) as the exit() argument.  */\n-      if (AVR_MEGA)\n-\t{\n-\t  fputs (\"\\t\" AS1 (jmp,exit) \"\\n\", file);\n-\t  epilogue_size += 2;\n-\t}\n-      else\n-\t{\n-\t  fputs (\"\\t\" AS1 (rjmp,exit) \"\\n\", file);\n-\t  ++epilogue_size;\n-\t}\n+         (r25:r24) as the exit() argument.  */\n+      insn = emit_jump_insn (gen_return ());\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n   else if (minimize && (frame_pointer_needed || live_seq > 4))\n     {\n-      fprintf (file, (\"\\t\" AS2 (ldi, r30, %d) CR_TAB), live_seq);\n-      ++epilogue_size;\n       if (frame_pointer_needed)\n \t{\n-\t  epilogue_size += out_adj_frame_ptr (file, -size);\n-\t}\n-      else\n-\t{\n-\t  fprintf (file, (AS2 (in , r28, __SP_L__) CR_TAB\n-\t\t\t  AS2 (in , r29, __SP_H__) CR_TAB));\n-\t  epilogue_size += 2;\n-\t}\n-      \n-      if (AVR_MEGA)\n-\t{\n-\t  fprintf (file, AS1 (jmp,__epilogue_restores__+%d) \"\\n\",\n-\t\t   (18 - live_seq) * 2);\n-\t  epilogue_size += 2;\n+          /*  Get rid of frame.  */\n+          insn = \n+\t    emit_move_insn(frame_pointer_rtx,\n+                           gen_rtx_PLUS (HImode, frame_pointer_rtx, \n+                                         gen_int_mode (size, HImode)));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n       else\n \t{\n-\t  fprintf (file, AS1 (rjmp,__epilogue_restores__+%d) \"\\n\",\n-\t\t   (18 - live_seq) * 2);\n-\t  ++epilogue_size;\n+          insn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+          RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n+\t\n+      insn = \n+        emit_insn (gen_epilogue_restores (gen_int_mode (live_seq, HImode)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n   else\n     {\n-      HARD_REG_SET set;\n-\n       if (frame_pointer_needed)\n \t{\n \t  if (size)\n \t    {\n-\t      fputs (\"\\t\", file);\n-\t      epilogue_size += out_adj_frame_ptr (file, -size);\n-\n-\t      if (interrupt_func_p || signal_func_p)\n-\t\t{\n-\t\t  epilogue_size += out_set_stack_ptr (file, -1, 0);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  epilogue_size += out_set_stack_ptr (file, -1, -1);\n-\t\t}\n-\t    }\n-\t  fprintf (file, \"\\t\"\n-\t\t   AS1 (pop,r29) CR_TAB\n-\t\t   AS1 (pop,r28) \"\\n\");\n-\t  epilogue_size += 2;\n+              /* Try two methods to adjust stack and select shortest.  */\n+              int fp_plus_length;\n+              /* Method 1-Adjust frame pointer.  */\n+              fp_plus_length = \n+\t        get_attr_length (gen_move_insn (frame_pointer_rtx,\n+                                                gen_rtx_PLUS (HImode, frame_pointer_rtx,\n+                                                              gen_int_mode (size, \n+\t\t\t\t\t\t\t\t\t    HImode))));\n+              /* Copy to stack pointer.  */\n+              fp_plus_length += \n+\t        get_attr_length (gen_move_insn (stack_pointer_rtx, frame_pointer_rtx));    \n+          \n+              /* Method 2-Adjust Stack pointer.  */\n+              int sp_plus_length = 0;\n+              if (size <= 5)\n+                {\n+                  sp_plus_length = \n+\t\t    get_attr_length (gen_move_insn (stack_pointer_rtx,\n+                                                    gen_rtx_PLUS (HImode, stack_pointer_rtx,\n+                                                                  gen_int_mode (size, \n+\t\t\t\t\t\t\t\t\t\tHImode))));\n+                }\n+              /* Use shortest method.  */\n+              if (size <= 5 && (sp_plus_length < fp_plus_length))\n+                {\n+                  insn = emit_move_insn (stack_pointer_rtx,\n+                                         gen_rtx_PLUS (HImode, stack_pointer_rtx,\n+                                                       gen_int_mode (size, HImode)));\n+                  RTX_FRAME_RELATED_P (insn) = 1;\n+                }\n+              else\n+                {\n+                  insn = emit_move_insn (frame_pointer_rtx,\n+                                         gen_rtx_PLUS (HImode, frame_pointer_rtx,\n+                                                       gen_int_mode (size, HImode)));\n+\t          RTX_FRAME_RELATED_P (insn) = 1;\t   \n+                  /* Copy to stack pointer.  */\n+                  insn = emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n+\t          RTX_FRAME_RELATED_P (insn) = 1;\n+                }\n+            }\n+        \n+          /* Restore previous frame_pointer.  */\n+\t  insn = emit_insn (gen_pophi (frame_pointer_rtx));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n-\n-      epilogue_size += avr_regs_to_save (&set);\n+      /* Restore used registers.  */\n+      HARD_REG_SET set;      \n+      avr_regs_to_save (&set);\n       for (reg = 31; reg >= 0; --reg)\n-\t{\n-\t  if (TEST_HARD_REG_BIT (set, reg))\n-\t    {\n-\t      fprintf (file, \"\\t\" AS1 (pop,%s) \"\\n\", avr_regnames[reg]);\n-\t    }\n-\t}\n+        {\n+          if (TEST_HARD_REG_BIT (set, reg))\n+            {\n+              insn = emit_insn (gen_popqi (gen_rtx_REG (QImode, reg)));\n+              RTX_FRAME_RELATED_P (insn) = 1;\n+            }\n+        }\n+      if (cfun->machine->is_interrupt || cfun->machine->is_signal)\n+        {\n \n-      if (interrupt_func_p || signal_func_p)\n-\t{\n-\t  fprintf (file, \"\\t\"\n-\t\t   AS1 (pop,__tmp_reg__)      CR_TAB\n-\t\t   AS2 (out,__SREG__,__tmp_reg__) CR_TAB\n-\t\t   AS1 (pop,__tmp_reg__)      CR_TAB\n-\t\t   AS1 (pop,__zero_reg__)     \"\\n\");\n-\t  epilogue_size += 4;\n-\t  fprintf (file, \"\\treti\\n\");\n-\t}\n-      else\n-\tfprintf (file, \"\\tret\\n\");\n-      ++epilogue_size;\n-    }\n+          /* Restore SREG using tmp reg as scratch.  */\n+          insn = emit_insn (gen_popqi (tmp_reg_rtx));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n+      \n+          insn = emit_move_insn (gen_rtx_MEM(QImode, GEN_INT(SREG_ADDR)), \n+\t\t\t\t tmp_reg_rtx);\n+          RTX_FRAME_RELATED_P (insn) = 1;\n+\n+          /* Restore tmp REG.  */\n+          insn = emit_insn (gen_popqi (tmp_reg_rtx));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n \n- out:\n-  fprintf (file, \"/* epilogue end (size=%d) */\\n\", epilogue_size);\n-  fprintf (file, \"/* function %s size %d (%d) */\\n\", current_function_name (),\n-\t   prologue_size + function_size + epilogue_size, function_size);\n-  commands_in_file += prologue_size + function_size + epilogue_size;\n-  commands_in_prologues += prologue_size;\n-  commands_in_epilogues += epilogue_size;\n+          /* Restore zero REG.  */\n+          insn = emit_insn (gen_popqi (zero_reg_rtx));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+        }\n+\n+      insn = emit_jump_insn (gen_return ());\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n }\n \n+/* Output summary messages at beginning of function epilogue.  */\n+\n+static void\n+avr_asm_function_begin_epilogue (FILE *file)\n+{\n+  fprintf (file, \"/* epilogue start */\\n\");\n+}\n \n /* Return nonzero if X (an RTX) is a legitimate memory address on the target\n    machine for a memory operand of mode MODE.  */\n@@ -1651,13 +1648,31 @@ output_movhi (rtx insn, rtx operands[], int *l)\n \t\t  *l = 1;\n \t\t  return AS2 (out,__SP_L__,%A1);\n \t\t}\n-\t      else if (TARGET_NO_INTERRUPTS)\n-\t\t{\n-\t\t  *l = 2;\n-\t\t  return (AS2 (out,__SP_H__,%B1) CR_TAB\n-\t\t\t  AS2 (out,__SP_L__,%A1));\n-\t\t}\n-\n+              /*  Use simple load of stack pointer if no interrupts are used\n+              or inside main or signal function prologue where they disabled.  */\n+\t      else if (TARGET_NO_INTERRUPTS \n+                        || (reload_completed \n+                            && cfun->machine->is_main \n+                            && prologue_epilogue_contains (insn))\n+                        || (reload_completed \n+                            && cfun->machine->is_signal \n+                            && prologue_epilogue_contains (insn)))\n+                {\n+                  *l = 2;\n+                  return (AS2 (out,__SP_H__,%B1) CR_TAB\n+                          AS2 (out,__SP_L__,%A1));\n+                }\n+              /*  In interrupt prolog we know interrupts are enabled.  */\n+              else if (reload_completed \n+                        && cfun->machine->is_interrupt\n+                        && prologue_epilogue_contains (insn))\n+                {\n+                  *l = 4;\n+\t           return (\"cli\"                   CR_TAB\n+                           AS2 (out,__SP_H__,%B1) CR_TAB\n+                           \"sei\"                   CR_TAB\n+                           AS2 (out,__SP_L__,%A1));\n+                }\n \t      *l = 5;\n \t      return (AS2 (in,__tmp_reg__,__SREG__)  CR_TAB\n \t\t      \"cli\"                          CR_TAB\n@@ -1798,6 +1813,11 @@ out_movqi_r_mr (rtx insn, rtx op[], int *l)\n   \n   if (CONSTANT_ADDRESS_P (x))\n     {\n+      if (CONST_INT_P (x) && INTVAL (x) == SREG_ADDR)\n+\t{\n+\t  *l = 1;\n+\t  return AS2 (in,%0,__SREG__);\n+\t}\n       if (avr_io_address_p (x, 1))\n \t{\n \t  *l = 1;\n@@ -2481,6 +2501,11 @@ out_movqi_mr_r (rtx insn, rtx op[], int *l)\n   \n   if (CONSTANT_ADDRESS_P (x))\n     {\n+      if (CONST_INT_P (x) && INTVAL (x) == SREG_ADDR)\n+\t{\n+\t  *l = 1;\n+\t  return AS2 (out,__SREG__,%1);\n+\t}\n       if (avr_io_address_p (x, 1))\n \t{\n \t  *l = 1;\n@@ -5772,8 +5797,6 @@ avr_output_addr_vec_elt (FILE *stream, int value)\n     fprintf (stream, \"\\t.word pm(.L%d)\\n\", value);\n   else\n     fprintf (stream, \"\\trjmp .L%d\\n\", value);\n-\n-  jump_tables_size++;\n }\n \n /* Returns 1 if SCRATCH are safe to be allocated as a scratch"}, {"sha": "9c80f536d27071176920948f6e3af05d93e4b65c", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc2b4ff18b21daf43bf8d879e3edf67e556af7e/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc2b4ff18b21daf43bf8d879e3edf67e556af7e/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=4fc2b4ff18b21daf43bf8d879e3edf67e556af7e", "patch": "@@ -63,6 +63,9 @@ extern GTY(()) section *progmem_section;\n #define AVR_HAVE_MOVW (avr_have_movw_lpmx_p)\n #define AVR_HAVE_LPMX (avr_have_movw_lpmx_p)\n \n+#define AVR_2_BYTE_PC 1\n+#define AVR_3_BYTE_PC 0\n+\n #define TARGET_VERSION fprintf (stderr, \" (GNU assembler syntax)\");\n \n #define OVERRIDE_OPTIONS avr_override_options ()\n@@ -338,7 +341,7 @@ extern int avr_reg_order[];\n \n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n-#define EPILOGUE_USES(REGNO) 0\n+#define EPILOGUE_USES(REGNO) avr_epilogue_uses(REGNO)\n \n #define HAVE_POST_INCREMENT 1\n #define HAVE_PRE_DECREMENT 1\n@@ -933,3 +936,22 @@ mmcu=*:-mmcu=%*}\"\n #define DWARF2_ADDR_SIZE 4\n \n #define OBJECT_FORMAT_ELF\n+\n+/* A C structure for machine-specific, per-function data.\n+   This is added to the cfun structure.  */\n+struct machine_function GTY(())\n+{\n+  /* 'true' - if current function is a 'main' function.  */\n+  int is_main;\n+\n+  /* 'true' - if current function is a naked function.  */\n+  int is_naked;\n+\n+  /* 'true' - if current function is an interrupt function \n+     as specified by the \"interrupt\" attribute.  */\n+  int is_interrupt;\n+\n+  /* 'true' - if current function is a signal function \n+     as specified by the \"signal\" attribute.  */\n+  int is_signal;\n+};"}, {"sha": "34dc7034ee028d65495d8359dfa5c36de519019a", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 313, "deletions": 52, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc2b4ff18b21daf43bf8d879e3edf67e556af7e/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc2b4ff18b21daf43bf8d879e3edf67e556af7e/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=4fc2b4ff18b21daf43bf8d879e3edf67e556af7e", "patch": "@@ -46,8 +46,16 @@\n    (REG_SP\t32)\n    (TMP_REGNO\t0)\t; temporary register r0\n    (ZERO_REGNO\t1)\t; zero register r1\n+   \n+   (SREG_ADDR   0x5F)\n+   \n    (UNSPEC_STRLEN\t0)\n-   (UNSPEC_INDEX_JMP\t1)])\n+   (UNSPEC_INDEX_JMP\t1)\n+   (UNSPEC_SEI\t\t2)\n+   (UNSPEC_CLI\t\t3)\n+\n+   (UNSPECV_PROLOGUE_SAVES\t0)\n+   (UNSPECV_EPILOGUE_RESTORES\t1)])\n \n (include \"predicates.md\")\n (include \"constraints.md\")\n@@ -104,46 +112,6 @@\n \t\t       (const_int 2))]\n         (const_int 2)))\n \n-(define_insn \"*pop1\"\n-  [(set (reg:HI 32) (plus:HI (reg:HI 32) (const_int 1)))]\n-  \"\"\n-  \"pop __tmp_reg__\"\n-  [(set_attr \"length\" \"1\")])\n-\n-(define_insn \"*pop2\"\n-  [(set (reg:HI 32) (plus:HI (reg:HI 32) (const_int 2)))]\n-  \"\"\n-  \"pop __tmp_reg__\n-\tpop __tmp_reg__\"\n-  [(set_attr \"length\" \"2\")])\n-\n-(define_insn \"*pop3\"\n-  [(set (reg:HI 32) (plus:HI (reg:HI 32) (const_int 3)))]\n-  \"\"\n-  \"pop __tmp_reg__\n-\tpop __tmp_reg__\n- \tpop __tmp_reg__\"\n-  [(set_attr \"length\" \"3\")])\n-\n-(define_insn \"*pop4\"\n-  [(set (reg:HI 32) (plus:HI (reg:HI 32) (const_int 4)))]\n-  \"\"\n-  \"pop __tmp_reg__\n-\tpop __tmp_reg__\n-\tpop __tmp_reg__\n-\tpop __tmp_reg__\"\n-  [(set_attr \"length\" \"4\")])\n-\n-(define_insn \"*pop5\"\n-  [(set (reg:HI 32) (plus:HI (reg:HI 32) (const_int 5)))]\n-  \"\"\n-  \"pop __tmp_reg__\n-\tpop __tmp_reg__\n-\tpop __tmp_reg__\n-\tpop __tmp_reg__\n-\tpop __tmp_reg__\"\n-  [(set_attr \"length\" \"5\")])\n-\n (define_insn \"*pushqi\"\n   [(set (mem:QI (post_dec (reg:HI REG_SP)))\n         (match_operand:QI 0 \"reg_or_0_operand\" \"r,L\"))]\n@@ -252,6 +220,14 @@\n     }\n }\")\n \n+(define_insn \"*movhi_sp\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=q,r\")\n+        (match_operand:HI 1 \"register_operand\"  \"r,q\"))]\n+  \"((stack_register_operand(operands[0], HImode) && register_operand (operands[1], HImode))\n+    || (register_operand (operands[0], HImode) && stack_register_operand(operands[1], HImode)))\"\n+  \"* return output_movhi (insn, operands, NULL);\"\n+  [(set_attr \"length\" \"5,2\")\n+   (set_attr \"cc\" \"none,none\")])\n \n (define_peephole2\n   [(match_scratch:QI 2 \"d\")\n@@ -622,6 +598,143 @@\n   [(set_attr \"length\" \"3\")\n    (set_attr \"cc\" \"set_n\")])\n \n+(define_insn \"*addhi3_sp_R_pc2\"\n+  [(set (match_operand:HI 1 \"stack_register_operand\" \"=q\")\n+        (plus:HI (match_operand:HI 2 \"stack_register_operand\" \"q\")\n+                 (match_operand:HI 0 \"avr_sp_immediate_operand\" \"R\")))]\n+  \"AVR_2_BYTE_PC\"\n+  \"*{\n+      if (CONST_INT_P (operands[0]))\n+        {\n+\t  switch(INTVAL (operands[0]))\n+\t    {\n+\t    case -6: \n+\t      return \\\"rcall .\\\" CR_TAB \n+\t             \\\"rcall .\\\" CR_TAB \n+\t\t     \\\"rcall .\\\";\n+\t    case -5: \n+\t      return \\\"rcall .\\\" CR_TAB \n+\t             \\\"rcall .\\\" CR_TAB \n+\t\t     \\\"push __tmp_reg__\\\";\n+\t    case -4: \n+\t      return \\\"rcall .\\\" CR_TAB \n+\t             \\\"rcall .\\\";\n+\t    case -3: \n+\t      return \\\"rcall .\\\" CR_TAB \n+\t             \\\"push __tmp_reg__\\\";\n+\t    case -2: \n+\t      return \\\"rcall .\\\";\n+\t    case -1: \n+\t      return \\\"push __tmp_reg__\\\";\n+\t    case 0: \n+\t      return \\\"\\\";\n+\t    case 1: \n+\t      return \\\"pop __tmp_reg__\\\";\n+\t    case 2: \n+\t      return \\\"pop __tmp_reg__\\\" CR_TAB \n+\t             \\\"pop __tmp_reg__\\\";\n+\t    case 3: \n+\t      return \\\"pop __tmp_reg__\\\" CR_TAB \n+\t             \\\"pop __tmp_reg__\\\" CR_TAB \n+\t\t     \\\"pop __tmp_reg__\\\";\n+\t    case 4: \n+\t      return \\\"pop __tmp_reg__\\\" CR_TAB \n+\t             \\\"pop __tmp_reg__\\\" CR_TAB \n+\t\t     \\\"pop __tmp_reg__\\\" CR_TAB \n+\t\t     \\\"pop __tmp_reg__\\\";\n+\t    case 5: \n+\t      return \\\"pop __tmp_reg__\\\" CR_TAB \n+\t             \\\"pop __tmp_reg__\\\" CR_TAB \n+\t\t     \\\"pop __tmp_reg__\\\" CR_TAB \n+\t\t     \\\"pop __tmp_reg__\\\" CR_TAB \n+\t\t     \\\"pop __tmp_reg__\\\";\n+\t    }\n+        }\n+      return \\\"bug\\\";\n+    }\"\n+  [(set (attr \"length\") \n+        (cond [(eq (const_int -6) (symbol_ref \"INTVAL (operands[0])\")) (const_int 3)\n+               (eq (const_int -5) (symbol_ref \"INTVAL (operands[0])\")) (const_int 3)\n+               (eq (const_int -4) (symbol_ref \"INTVAL (operands[0])\")) (const_int 2)\n+               (eq (const_int -3) (symbol_ref \"INTVAL (operands[0])\")) (const_int 2)\n+               (eq (const_int -2) (symbol_ref \"INTVAL (operands[0])\")) (const_int 1)\n+               (eq (const_int -1) (symbol_ref \"INTVAL (operands[0])\")) (const_int 1)\n+               (eq (const_int  0) (symbol_ref \"INTVAL (operands[0])\")) (const_int 0)\n+               (eq (const_int  1) (symbol_ref \"INTVAL (operands[0])\")) (const_int 1)\n+               (eq (const_int  2) (symbol_ref \"INTVAL (operands[0])\")) (const_int 2)\n+               (eq (const_int  3) (symbol_ref \"INTVAL (operands[0])\")) (const_int 3)\n+               (eq (const_int  4) (symbol_ref \"INTVAL (operands[0])\")) (const_int 4)\n+               (eq (const_int  5) (symbol_ref \"INTVAL (operands[0])\")) (const_int 5)]\n+               (const_int 0)))])\n+\n+(define_insn \"*addhi3_sp_R_pc3\"\n+  [(set (match_operand:HI 1 \"stack_register_operand\" \"=q\")\n+        (plus:HI (match_operand:HI 2 \"stack_register_operand\" \"q\")\n+                 (match_operand:QI 0 \"avr_sp_immediate_operand\" \"R\")))]\n+  \"AVR_3_BYTE_PC\"\n+  \"*{\n+      if (CONST_INT_P (operands[0]))\n+        {\n+\t  switch(INTVAL (operands[0]))\n+\t    {\n+\t    case -6: \n+\t      return \\\"rcall .\\\" CR_TAB \n+\t\t     \\\"rcall .\\\";\n+\t    case -5: \n+\t      return \\\"rcall .\\\" CR_TAB \n+\t             \\\"push __tmp_reg__\\\" CR_TAB \n+\t\t     \\\"push __tmp_reg__\\\";\n+\t    case -4: \n+\t      return \\\"rcall .\\\" CR_TAB \n+\t             \\\"push __tmp_reg__\\\";\n+\t    case -3: \n+\t      return \\\"rcall .\\\";\n+\t    case -2: \n+\t      return \\\"push __tmp_reg__\\\" CR_TAB \n+\t\t     \\\"push __tmp_reg__\\\";\n+\t    case -1: \n+\t      return \\\"push __tmp_reg__\\\";\n+\t    case 0: \n+\t      return \\\"\\\";\n+\t    case 1: \n+\t      return \\\"pop __tmp_reg__\\\";\n+\t    case 2: \n+\t      return \\\"pop __tmp_reg__\\\" CR_TAB \n+\t             \\\"pop __tmp_reg__\\\";\n+\t    case 3: \n+\t      return \\\"pop __tmp_reg__\\\" CR_TAB \n+\t             \\\"pop __tmp_reg__\\\" CR_TAB \n+\t\t     \\\"pop __tmp_reg__\\\";\n+\t    case 4: \n+\t      return \\\"pop __tmp_reg__\\\" CR_TAB \n+\t             \\\"pop __tmp_reg__\\\" CR_TAB \n+\t\t     \\\"pop __tmp_reg__\\\" CR_TAB \n+\t\t     \\\"pop __tmp_reg__\\\";\n+\t    case 5: \n+\t      return \\\"pop __tmp_reg__\\\" CR_TAB \n+\t             \\\"pop __tmp_reg__\\\" CR_TAB \n+\t\t     \\\"pop __tmp_reg__\\\" CR_TAB \n+\t\t     \\\"pop __tmp_reg__\\\" CR_TAB \n+\t\t     \\\"pop __tmp_reg__\\\";\n+\t    }\n+        }\n+      return \\\"bug\\\";\n+    }\"\n+  [(set (attr \"length\") \n+        (cond [(eq (const_int -6) (symbol_ref \"INTVAL (operands[0])\")) (const_int 2)\n+               (eq (const_int -5) (symbol_ref \"INTVAL (operands[0])\")) (const_int 3)\n+               (eq (const_int -4) (symbol_ref \"INTVAL (operands[0])\")) (const_int 2)\n+               (eq (const_int -3) (symbol_ref \"INTVAL (operands[0])\")) (const_int 1)\n+               (eq (const_int -2) (symbol_ref \"INTVAL (operands[0])\")) (const_int 2)\n+               (eq (const_int -1) (symbol_ref \"INTVAL (operands[0])\")) (const_int 1)\n+               (eq (const_int  0) (symbol_ref \"INTVAL (operands[0])\")) (const_int 0)\n+               (eq (const_int  1) (symbol_ref \"INTVAL (operands[0])\")) (const_int 1)\n+               (eq (const_int  2) (symbol_ref \"INTVAL (operands[0])\")) (const_int 2)\n+               (eq (const_int  3) (symbol_ref \"INTVAL (operands[0])\")) (const_int 3)\n+               (eq (const_int  4) (symbol_ref \"INTVAL (operands[0])\")) (const_int 4)\n+               (eq (const_int  5) (symbol_ref \"INTVAL (operands[0])\")) (const_int 5)]\n+               (const_int 0)))])\n+\n (define_insn \"*addhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,!w,!w,d,r,r\")\n  \t(plus:HI\n@@ -2095,10 +2208,14 @@\n   return AS1 (rjmp,%0);\n }\"\n   [(set (attr \"length\")\n-\t(if_then_else (and (ge (minus (pc) (match_dup 0)) (const_int -2047))\n-\t\t\t   (le (minus (pc) (match_dup 0)) (const_int 2047)))\n-\t\t      (const_int 1)\n-\t\t      (const_int 2)))\n+\t(if_then_else (match_operand 0 \"symbol_ref_operand\" \"\")\t\n+\t\t(if_then_else (eq_attr \"mcu_mega\" \"no\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (const_int 2))\n+\t\t(if_then_else (and (ge (minus (pc) (match_dup 0)) (const_int -2047))\n+\t\t\t\t   (le (minus (pc) (match_dup 0)) (const_int 2047)))\n+\t\t\t      (const_int 1)\n+\t\t\t      (const_int 2))))\n    (set_attr \"cc\" \"none\")])\n \n ;; call\n@@ -2193,13 +2310,6 @@\n \t\t\t\t\t(const_int 1))\n \t\t\t  (const_int 3)])])\n \n-(define_insn \"return\"\n-  [(return)]\n-  \"reload_completed && avr_simple_epilogue ()\"\n-  \"ret\"\n-  [(set_attr \"cc\" \"none\")\n-   (set_attr \"length\" \"1\")])\n-\n (define_insn \"nop\"\n   [(const_int 0)]\n   \"\"\n@@ -2555,3 +2665,154 @@\n \t\t      (pc)))]\n   \"jump_over_one_insn_p (insn, operands[2])\"\n   \"cpse %0,%1\")\n+\n+;;pppppppppppppppppppppppppppppppppppppppppppppppppppp\n+;;prologue/epilogue support instructions\n+\n+(define_insn \"popqi\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+        (mem:QI (post_inc (reg:HI REG_SP))))]\n+  \"\"\n+  \"pop %0\"\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"pophi\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (mem:HI (post_inc (reg:HI REG_SP))))]\n+  \"\"\n+  \"pop %A0\\;pop %B0\"\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"2\")])\n+\n+;; Enable Interrupts\n+(define_insn \"enable_interrupt\"\n+  [(unspec [(const_int 0)] UNSPEC_SEI)]\n+  \"\"\n+  \"sei\"\n+  [(set_attr \"length\" \"1\")\n+  (set_attr \"cc\" \"none\")\n+  ])\n+\n+;; Disable Interrupts\n+(define_insn \"disable_interrupt\"\n+  [(unspec [(const_int 0)] UNSPEC_CLI)]\n+  \"\"\n+  \"cli\"\n+  [(set_attr \"length\" \"1\")\n+  (set_attr \"cc\" \"none\")\n+  ])\n+\n+;;  Library prologue saves\n+(define_insn \"call_prologue_saves\"\n+  [(unspec_volatile:HI [(const_int 0)] UNSPECV_PROLOGUE_SAVES)\n+   (set (reg:HI REG_SP) (minus:HI \n+                           (reg:HI REG_SP)\n+                           (match_operand:HI 0 \"immediate_operand\" \"\")))\n+   (set (reg:HI REG_SP) (minus:HI \n+                           (reg:HI REG_SP)\n+                           (match_operand:HI 1 \"immediate_operand\" \"\")))\n+   (set (reg:HI REG_X) (match_dup 0))\n+   (clobber (reg:HI REG_Z))]\n+  \"\"\n+  \"ldi r26,lo8(%0)\n+\tldi r27,hi8(%0)\n+\tldi r30,pm_lo8(1f)\n+\tldi r31,pm_hi8(1f)\n+\t%~jmp __prologue_saves__+((18 - %1) * 2)\n+1:\"\n+  [(set_attr_alternative \"length\"\n+\t\t\t [(if_then_else (eq_attr \"mcu_mega\" \"yes\")\n+\t\t\t\t\t(const_int 6)\n+\t\t\t\t\t(const_int 5))])\n+  (set_attr \"cc\" \"clobber\")\n+  ])\n+  \n+;  epilogue  restores using library\n+(define_insn \"epilogue_restores\"\n+  [(unspec_volatile:QI [(const_int 0)] UNSPECV_EPILOGUE_RESTORES)\n+   (set (reg:HI REG_Y ) (plus:HI \n+                           (reg:HI REG_Y)\n+                           (match_operand:HI 0 \"immediate_operand\" \"\"))) \n+   (set (reg:HI REG_SP) (reg:HI REG_Y))\n+   (clobber  (reg:QI REG_Z))]\n+  \"\"\n+  \"ldi r30, lo8(%0)\n+\t%~jmp __epilogue_restores__ + ((18 - %0) * 2)\"\n+  [(set_attr_alternative \"length\"\n+\t\t\t [(if_then_else (eq_attr \"mcu_mega\" \"yes\")\n+\t\t\t\t\t(const_int 3)\n+\t\t\t\t\t(const_int 2))])\n+  (set_attr \"cc\" \"clobber\")\n+  ])\n+  \n+; return\n+(define_insn \"return\"\n+  [(return)]\n+  \"reload_completed && avr_simple_epilogue ()\"\n+  \"ret\"\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"return_from_epilogue\"\n+  [(return)]\n+  \"(reload_completed \n+    && cfun->machine \n+    && !cfun->machine->is_main\n+    && !(cfun->machine->is_interrupt || cfun->machine->is_signal)\n+    && !cfun->machine->is_naked)\"\n+  \"ret\"\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"return_from_main_epilogue\"\n+  [(return)]\n+  \"(reload_completed \n+    && cfun->machine \n+    && cfun->machine->is_main\n+    && !cfun->machine->is_naked)\"\n+  \"%~jmp exit\"\n+  [(set_attr_alternative \"length\"\n+\t\t\t [(if_then_else (eq_attr \"mcu_mega\" \"yes\")\n+\t\t\t\t\t(const_int 2)\n+\t\t\t\t\t(const_int 1))])\n+  (set_attr \"cc\" \"none\")\n+  ])\n+  \n+(define_insn \"return_from_interrupt_epilogue\"\n+  [(return)]\n+  \"(reload_completed \n+    && cfun->machine \n+    && !cfun->machine->is_main\n+    && (cfun->machine->is_interrupt || cfun->machine->is_signal)\n+    && !cfun->machine->is_naked)\"\n+  \"reti\"\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"return_from_naked_epilogue\"\n+  [(return)]\n+  \"(reload_completed \n+    && cfun->machine \n+    && cfun->machine->is_naked)\"\n+  \"\"\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"0\")])\n+\n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"\n+  {\n+    expand_prologue (); \n+    DONE;\n+  }\")\n+\n+(define_expand \"epilogue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"\n+  {\n+    expand_epilogue (); \n+    DONE;\n+  }\")"}, {"sha": "f3ff9e962cc615b06709ec9c9ed16a7538715916", "filename": "gcc/config/avr/constraints.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc2b4ff18b21daf43bf8d879e3edf67e556af7e/gcc%2Fconfig%2Favr%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc2b4ff18b21daf43bf8d879e3edf67e556af7e/gcc%2Fconfig%2Favr%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fconstraints.md?ref=4fc2b4ff18b21daf43bf8d879e3edf67e556af7e", "patch": "@@ -99,6 +99,11 @@\n   (and (match_code \"const_double\")\n        (match_test \"op == CONST0_RTX (SFmode)\")))\n \n+(define_constraint \"R\"\n+  \"Integer constant in the range -6 @dots{} 5.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -6 && ival <= 5\")))\n+       \n (define_memory_constraint \"Q\"\n   \"A memory address based on X or Y pointer with displacement.\"\n   (and (match_code \"mem\")"}, {"sha": "acc82f6d20e8ddb20bf1a511d9848b5f5a99cbdc", "filename": "gcc/config/avr/predicates.md", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc2b4ff18b21daf43bf8d879e3edf67e556af7e/gcc%2Fconfig%2Favr%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc2b4ff18b21daf43bf8d879e3edf67e556af7e/gcc%2Fconfig%2Favr%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fpredicates.md?ref=4fc2b4ff18b21daf43bf8d879e3edf67e556af7e", "patch": "@@ -78,7 +78,12 @@\n (define_predicate \"single_zero_operand\"\n   (and (match_code \"const_int\")\n        (match_test \"exact_log2(~INTVAL (op) & GET_MODE_MASK (mode)) >= 0\")))\n-      \n+\n+;;\n+(define_predicate \"avr_sp_immediate_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) >= -6 && INTVAL (op) <= 5\")))\n+\n ;; True for EQ & NE\n (define_predicate \"eqne_operator\"\n   (match_code \"eq,ne\"))"}]}