{"sha": "08afab6f8642f58f702010ec196dce3b00955627", "node_id": "C_kwDOANBUbNoAKDA4YWZhYjZmODY0MmY1OGY3MDIwMTBlYzE5NmRjZTNiMDA5NTU2Mjc", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-05-31T07:37:05Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-06-02T06:35:23Z"}, "message": "tree-optimization/101668 - relax SLP of existing vectors\n\nThis relaxes the conditions on SLPing extracts from existing vectors\nleveraging the relaxed VEC_PERM conditions on the input vs output\nvector type compatibility.  It also handles lowpart extracts\nand concats without VEC_PERMs now.\n\n2022-05-25  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/101668\n\t* tree-vect-slp.cc (vect_build_slp_tree_1): Allow BIT_FIELD_REFs\n\tfor vector types with compatible lane types.\n\t(vect_build_slp_tree_2): Deal with this.\n\t(vect_add_slp_permutation): Adjust.  Emit lowpart/concat\n\tspecial cases without VEC_PERM.\n\t(vectorizable_slp_permutation): Select the operand vector\n\ttype and relax requirements.  Handle identity permutes\n\twith mismatching operand types.\n\t* optabs-query.cc (can_vec_perm_const_p): Only allow variable\n\tpermutes for op_mode == mode.\n\n\t* gcc.target/i386/pr101668.c: New testcase.\n\t* gcc.dg/vect/bb-slp-pr101668.c: Likewise.", "tree": {"sha": "fecb020d184300f9a86b413a3b1ed959b3dcbcf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fecb020d184300f9a86b413a3b1ed959b3dcbcf3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08afab6f8642f58f702010ec196dce3b00955627", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08afab6f8642f58f702010ec196dce3b00955627", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08afab6f8642f58f702010ec196dce3b00955627", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08afab6f8642f58f702010ec196dce3b00955627/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a6b8d9aad9f68eec223cc126d9effbf45e37271", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a6b8d9aad9f68eec223cc126d9effbf45e37271", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a6b8d9aad9f68eec223cc126d9effbf45e37271"}], "stats": {"total": 187, "additions": 168, "deletions": 19}, "files": [{"sha": "44ce41e95e3695fed5c132927387d66088e6f90b", "filename": "gcc/optabs-query.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08afab6f8642f58f702010ec196dce3b00955627/gcc%2Foptabs-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08afab6f8642f58f702010ec196dce3b00955627/gcc%2Foptabs-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.cc?ref=08afab6f8642f58f702010ec196dce3b00955627", "patch": "@@ -426,7 +426,7 @@ can_vec_perm_const_p (machine_mode mode, machine_mode op_mode,\n     return false;\n \n   /* It's probably cheaper to test for the variable case first.  */\n-  if (allow_variable_p && selector_fits_mode_p (mode, sel))\n+  if (op_mode == mode && allow_variable_p && selector_fits_mode_p (mode, sel))\n     {\n       if (direct_optab_handler (vec_perm_optab, mode) != CODE_FOR_nothing)\n \treturn true;"}, {"sha": "eb44ad736574030cb124a5a76c5eb83c4a46524a", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr101668.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08afab6f8642f58f702010ec196dce3b00955627/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr101668.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08afab6f8642f58f702010ec196dce3b00955627/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr101668.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr101668.c?ref=08afab6f8642f58f702010ec196dce3b00955627", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-w -Wno-psabi\" } */\n+\n+#include \"tree-vect.h\"\n+\n+typedef int v4si __attribute__((vector_size(16)));\n+typedef int v8si __attribute__((vector_size(32)));\n+\n+void __attribute__((noipa)) test_lo (v4si *dst, v8si src)\n+{\n+  (*dst)[0] = src[0];\n+  (*dst)[1] = src[1];\n+  (*dst)[2] = src[2];\n+  (*dst)[3] = src[3];\n+}\n+\n+void __attribute__((noipa)) test_hi (v4si *dst, v8si src)\n+{\n+  (*dst)[0] = src[4];\n+  (*dst)[1] = src[5];\n+  (*dst)[2] = src[6];\n+  (*dst)[3] = src[7];\n+}\n+\n+void __attribute__((noipa)) test_even (v4si *dst, v8si src)\n+{\n+  (*dst)[0] = src[0];\n+  (*dst)[1] = src[2];\n+  (*dst)[2] = src[4];\n+  (*dst)[3] = src[6];\n+}\n+\n+void __attribute__((noipa)) test_odd (v4si *dst, v8si src)\n+{\n+  (*dst)[0] = src[1];\n+  (*dst)[1] = src[3];\n+  (*dst)[2] = src[5];\n+  (*dst)[3] = src[7];\n+}\n+\n+int main()\n+{\n+  check_vect ();\n+  v8si v = (v8si) { 0, 1, 2, 3, 4, 5, 6, 7 };\n+  v4si dst;\n+  test_lo (&dst, v);\n+  if (dst[0] != 0 || dst[1] != 1 || dst[2] != 2 || dst[3] != 3)\n+    abort ();\n+  test_hi (&dst, v);\n+  if (dst[0] != 4 || dst[1] != 5 || dst[2] != 6 || dst[3] != 7)\n+    abort ();\n+  test_even (&dst, v);\n+  if (dst[0] != 0 || dst[1] != 2 || dst[2] != 4 || dst[3] != 6)\n+    abort ();\n+  test_odd (&dst, v);\n+  if (dst[0] != 1 || dst[1] != 3 || dst[2] != 5 || dst[3] != 7)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "07719ec03d9c1c0aab1ff56f58ebec1671c1801e", "filename": "gcc/testsuite/gcc.target/i386/pr101668.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08afab6f8642f58f702010ec196dce3b00955627/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101668.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08afab6f8642f58f702010ec196dce3b00955627/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101668.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101668.c?ref=08afab6f8642f58f702010ec196dce3b00955627", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=skylake-avx512 -mprefer-vector-width=512\" } */\n+\n+typedef int v16si __attribute__((vector_size (64)));\n+typedef long long v8di __attribute__((vector_size (64)));\n+\n+void\n+bar_s32_s64 (v8di * dst, v16si src)\n+{\n+  long long tem[8];\n+  tem[0] = src[0];\n+  tem[1] = src[1];\n+  tem[2] = src[2];\n+  tem[3] = src[3];\n+  tem[4] = src[4];\n+  tem[5] = src[5];\n+  tem[6] = src[6];\n+  tem[7] = src[7];\n+  dst[0] = *(v8di *) tem;\n+}\n+\n+/* We want to generate\n+        vpmovsxdq       %ymm0, %zmm0\n+        vmovdqa64       %zmm0, (%rdi)\n+        ret\n+ */\n+/* { dg-final { scan-assembler \"vpmovsxdq\" } } */"}, {"sha": "dab5daddcc5a6d8e2003144cf5b4660350cc4844", "filename": "gcc/tree-vect-slp.cc", "status": "modified", "additions": 81, "deletions": 18, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08afab6f8642f58f702010ec196dce3b00955627/gcc%2Ftree-vect-slp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08afab6f8642f58f702010ec196dce3b00955627/gcc%2Ftree-vect-slp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.cc?ref=08afab6f8642f58f702010ec196dce3b00955627", "patch": "@@ -1086,8 +1086,13 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t      tree vec = TREE_OPERAND (gimple_assign_rhs1 (stmt), 0);\n \t      if (!is_a <bb_vec_info> (vinfo)\n \t\t  || TREE_CODE (vec) != SSA_NAME\n-\t\t  || !operand_equal_p (TYPE_SIZE (vectype),\n-\t\t\t\t       TYPE_SIZE (TREE_TYPE (vec))))\n+\t\t  /* When the element types are not compatible we pun the\n+\t\t     source to the target vectype which requires equal size.  */\n+\t\t  || ((!VECTOR_TYPE_P (TREE_TYPE (vec))\n+\t\t       || !types_compatible_p (TREE_TYPE (vectype),\n+\t\t\t\t\t       TREE_TYPE (TREE_TYPE (vec))))\n+\t\t      && !operand_equal_p (TYPE_SIZE (vectype),\n+\t\t\t\t\t   TYPE_SIZE (TREE_TYPE (vec)))))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1796,11 +1801,21 @@ vect_build_slp_tree_2 (vec_info *vinfo, slp_tree node,\n \t  lperm.safe_push (std::make_pair (0, (unsigned)lane));\n \t}\n       slp_tree vnode = vect_create_new_slp_node (vNULL);\n-      /* ???  We record vectype here but we hide eventually necessary\n-\t punning and instead rely on code generation to materialize\n-\t VIEW_CONVERT_EXPRs as necessary.  We instead should make\n-\t this explicit somehow.  */\n-      SLP_TREE_VECTYPE (vnode) = vectype;\n+      if (operand_equal_p (TYPE_SIZE (vectype), TYPE_SIZE (TREE_TYPE (vec))))\n+\t/* ???  We record vectype here but we hide eventually necessary\n+\t   punning and instead rely on code generation to materialize\n+\t   VIEW_CONVERT_EXPRs as necessary.  We instead should make\n+\t   this explicit somehow.  */\n+\tSLP_TREE_VECTYPE (vnode) = vectype;\n+      else\n+\t{\n+\t  /* For different size but compatible elements we can still\n+\t     use VEC_PERM_EXPR without punning.  */\n+\t  gcc_assert (VECTOR_TYPE_P (TREE_TYPE (vec))\n+\t\t      && types_compatible_p (TREE_TYPE (vectype),\n+\t\t\t\t\t     TREE_TYPE (TREE_TYPE (vec))));\n+\t  SLP_TREE_VECTYPE (vnode) = TREE_TYPE (vec);\n+\t}\n       SLP_TREE_VEC_DEFS (vnode).safe_push (vec);\n       /* We are always building a permutation node even if it is an identity\n \t permute to shield the rest of the vectorizer from the odd node\n@@ -6900,7 +6915,8 @@ vect_add_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n   /* ???  We SLP match existing vector element extracts but\n      allow punning which we need to re-instantiate at uses\n      but have no good way of explicitly representing.  */\n-  if (!types_compatible_p (TREE_TYPE (first_def), vectype))\n+  if (operand_equal_p (TYPE_SIZE (TREE_TYPE (first_def)), TYPE_SIZE (vectype))\n+      && !types_compatible_p (TREE_TYPE (first_def), vectype))\n     {\n       gassign *conv_stmt\n \t= gimple_build_assign (make_ssa_name (vectype),\n@@ -6912,7 +6928,9 @@ vect_add_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n   tree perm_dest = make_ssa_name (vectype);\n   if (mask_vec)\n     {\n-      if (!types_compatible_p (TREE_TYPE (second_def), vectype))\n+      if (operand_equal_p (TYPE_SIZE (TREE_TYPE (first_def)),\n+\t\t\t   TYPE_SIZE (vectype))\n+\t  && !types_compatible_p (TREE_TYPE (second_def), vectype))\n \t{\n \t  gassign *conv_stmt\n \t    = gimple_build_assign (make_ssa_name (vectype),\n@@ -6925,9 +6943,34 @@ vect_add_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n \t\t\t\t       first_def, second_def,\n \t\t\t\t       mask_vec);\n     }\n+  else if (!types_compatible_p (TREE_TYPE (first_def), vectype))\n+    {\n+      /* For identity permutes we still need to handle the case\n+\t of lowpart extracts or concats.  */\n+      unsigned HOST_WIDE_INT c;\n+      auto first_def_nunits\n+\t= TYPE_VECTOR_SUBPARTS (TREE_TYPE (first_def));\n+      if (known_le (TYPE_VECTOR_SUBPARTS (vectype), first_def_nunits))\n+\t{\n+\t  tree lowpart = build3 (BIT_FIELD_REF, vectype, first_def,\n+\t\t\t\t TYPE_SIZE (vectype), bitsize_zero_node);\n+\t  perm_stmt = gimple_build_assign (perm_dest, lowpart);\n+\t}\n+      else if (constant_multiple_p (TYPE_VECTOR_SUBPARTS (vectype),\n+\t\t\t\t    first_def_nunits, &c) && c == 2)\n+\t{\n+\t  tree ctor = build_constructor_va (vectype, 2, NULL_TREE, first_def,\n+\t\t\t\t\t    NULL_TREE, second_def);\n+\t  perm_stmt = gimple_build_assign (perm_dest, ctor);\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n   else\n-    /* We need a copy here in case the def was external.  */\n-    perm_stmt = gimple_build_assign (perm_dest, first_def);\n+    {\n+      /* We need a copy here in case the def was external.  */\n+      perm_stmt = gimple_build_assign (perm_dest, first_def);\n+    }\n   vect_finish_stmt_generation (vinfo, NULL, perm_stmt, gsi);\n   /* Store the vector statement in NODE.  */\n   SLP_TREE_VEC_STMTS (node).quick_push (perm_stmt);\n@@ -6950,21 +6993,32 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n {\n   tree vectype = SLP_TREE_VECTYPE (node);\n \n-  /* ???  We currently only support all same vector input and output types\n+  /* ???  We currently only support all same vector input types\n      while the SLP IL should really do a concat + select and thus accept\n      arbitrary mismatches.  */\n   slp_tree child;\n   unsigned i;\n   poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   bool repeating_p = multiple_p (nunits, SLP_TREE_LANES (node));\n+  tree op_vectype = NULL_TREE;\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+    if (SLP_TREE_VECTYPE (child))\n+      {\n+\top_vectype = SLP_TREE_VECTYPE (child);\n+\tbreak;\n+      }\n+  if (!op_vectype)\n+    op_vectype = vectype;\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     {\n-      if (!vect_maybe_update_slp_op_vectype (child, vectype)\n-\t  || !types_compatible_p (SLP_TREE_VECTYPE (child), vectype))\n+      if ((SLP_TREE_DEF_TYPE (child) != vect_internal_def\n+\t   && !vect_maybe_update_slp_op_vectype (child, op_vectype))\n+\t  || !types_compatible_p (SLP_TREE_VECTYPE (child), op_vectype)\n+\t  || !types_compatible_p (TREE_TYPE (vectype), TREE_TYPE (op_vectype)))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"Unsupported lane permutation\\n\");\n+\t\t\t     \"Unsupported vector types in lane permutation\\n\");\n \t  return false;\n \t}\n       if (SLP_TREE_LANES (child) != SLP_TREE_LANES (node))\n@@ -7121,11 +7175,20 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n \n       if (index == count)\n \t{\n-\t  indices.new_vector (mask, second_vec.first == -1U ? 1 : 2, nunits);\n+\t  indices.new_vector (mask, second_vec.first == -1U ? 1 : 2,\n+\t\t\t      TYPE_VECTOR_SUBPARTS (op_vectype));\n \t  bool identity_p = indices.series_p (0, 1, 0, 1);\n \t  machine_mode vmode = TYPE_MODE (vectype);\n-\t  if (!identity_p\n-\t      && !can_vec_perm_const_p (vmode, vmode, indices))\n+\t  machine_mode op_vmode = TYPE_MODE (op_vectype);\n+\t  unsigned HOST_WIDE_INT c;\n+\t  if ((!identity_p\n+\t       && !can_vec_perm_const_p (vmode, op_vmode, indices))\n+\t      || (identity_p\n+\t\t  && !known_le (nunits,\n+\t\t\t\tTYPE_VECTOR_SUBPARTS (op_vectype))\n+\t\t  && (!constant_multiple_p (nunits,\n+\t\t\t\t\t    TYPE_VECTOR_SUBPARTS (op_vectype),\n+\t\t\t\t\t    &c) || c != 2)))\n \t    {\n \t      if (dump_enabled_p ())\n \t\t{"}]}