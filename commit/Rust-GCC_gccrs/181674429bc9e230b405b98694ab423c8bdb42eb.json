{"sha": "181674429bc9e230b405b98694ab423c8bdb42eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgxNjc0NDI5YmM5ZTIzMGI0MDViOTg2OTRhYjQyM2M4YmRiNDJlYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2004-11-22T22:26:11Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2004-11-22T22:26:11Z"}, "message": "re PR target/18444 (Multithreading broken on Unix95-class platforms)\n\n\tPR target/18444\n\t* configure.ac (threading): Accept 'posix95'.\n\t* configure: Regenerate.\n\t* config.gcc (i[34567]86-*-solaris2*): On Solaris up to 2.6,\n\tinclude sol26.h and default to posix95 threads if have_pthread_h.\n\t(sparc-*-solaris2*): Likewise.\n\t* gthr.h: Include gthr-posix95.h if _PTHREADS95 is defined.\n\t* gthr-posix95.h: New file.\n\t* config/sol26.h: New file.\n\t* doc/install.texi (--enable-threads): Document 'posix95'.\n\nFrom-SVN: r91041", "tree": {"sha": "429455b0553bb86246e8d7679840ae2346140ce4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/429455b0553bb86246e8d7679840ae2346140ce4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/181674429bc9e230b405b98694ab423c8bdb42eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/181674429bc9e230b405b98694ab423c8bdb42eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/181674429bc9e230b405b98694ab423c8bdb42eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/181674429bc9e230b405b98694ab423c8bdb42eb/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "515a17919798a2c9597b2cf02660b9b07afd3fc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/515a17919798a2c9597b2cf02660b9b07afd3fc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/515a17919798a2c9597b2cf02660b9b07afd3fc4"}], "stats": {"total": 690, "additions": 680, "deletions": 10}, "files": [{"sha": "e656514382ea00d2e81d5b87b1f6fbcdfdcbcfd0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181674429bc9e230b405b98694ab423c8bdb42eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181674429bc9e230b405b98694ab423c8bdb42eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=181674429bc9e230b405b98694ab423c8bdb42eb", "patch": "@@ -1,3 +1,16 @@\n+2004-11-22  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR target/18444\n+\t* configure.ac (threading): Accept 'posix95'.\n+\t* configure: Regenerate.\n+\t* config.gcc (i[34567]86-*-solaris2*): On Solaris up to 2.6,\n+\tinclude sol26.h and default to posix95 threads if have_pthread_h.\n+\t(sparc-*-solaris2*): Likewise.\n+\t* gthr.h: Include gthr-posix95.h if _PTHREADS95 is defined.\n+\t* gthr-posix95.h: New file.\n+\t* config/sol26.h: New file.\n+\t* doc/install.texi (--enable-threads): Document 'posix95'.\n+\n 2004-11-23  Ben Elliston  <bje@au.ibm.com>\n \n \t* pointer-set.h (pointer_set_contains): Remove."}, {"sha": "0b4cef12d15d00624fdbb9d16e0d418f7e81a87b", "filename": "gcc/config.gcc", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181674429bc9e230b405b98694ab423c8bdb42eb/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181674429bc9e230b405b98694ab423c8bdb42eb/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=181674429bc9e230b405b98694ab423c8bdb42eb", "patch": "@@ -1012,7 +1012,12 @@ i[34567]86-*-sco3.2v5*)\t# 80386 running SCO Open Server 5\n \t;;\n i[34567]86-*-solaris2*)\n \txm_defines=\"SMALL_ARG_MAX\"\n-\ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h sol2.h i386/sol2.h\"\n+\ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h sol2.h\"\n+\tcase ${target} in\n+\t*-*-solaris2.[0-6] | *-*-solaris2.[0-6].*)\n+\t\ttm_file=\"${tm_file} sol26.h\"\n+\tesac\n+\ttm_file=\"${tm_file} i386/sol2.h\"\n \ttmake_file=\"t-sol2 i386/t-sol2 t-svr4\"\n \tc_target_objs=\"sol2-c.o\"\n \tcxx_target_objs=\"sol2-c.o\"\n@@ -1044,8 +1049,19 @@ i[34567]86-*-solaris2*)\n \t\t;;\n \tesac\n \tcase ${enable_threads}:${have_pthread_h}:${have_thread_h} in\n-\t  \"\":yes:* | yes:yes:* ) thread_file=posix ;;\n-\t  \"\":*:yes | yes:*:yes ) thread_file=solaris ;;\n+\t  \"\":yes:* | yes:yes:* )\n+\t\tcase ${target} in\n+\t\t  *-*-solaris2.[0-6] | *-*-solaris2.[0-6].*)\n+\t\t\tthread_file=posix95\n+\t\t\t;;\n+\t\t  *)\n+\t\t\tthread_file=posix\n+\t\t\t;;\n+\t\tesac\n+\t\t;;\n+\t  \"\":*:yes | yes:*:yes )\n+\t\tthread_file=solaris\n+\t\t;;\n \tesac\n \t;;\n i[34567]86-*-sysv5*)           # Intel x86 on System V Release 5\n@@ -1902,7 +1918,12 @@ sparc64-*-solaris2* | sparcv9-*-solaris2*)\n \tneed_64bit_hwint=yes\n \t;;\n sparc-*-solaris2*)\n-\ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sol2.h sparc/sol2.h\"\n+\ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sol2.h\"\n+\tcase ${target} in\n+\t*-*-solaris2.[0-6] | *-*-solaris2.[0-6].*)\n+\t\ttm_file=\"${tm_file} sol26.h\"\n+\tesac\n+\ttm_file=\"${tm_file} sparc/sol2.h\"\n \tif test x$gnu_ld = xyes; then\n \t\ttm_file=\"${tm_file} sparc/sol2-gld.h\"\n \tfi\n@@ -1939,8 +1960,19 @@ sparc-*-solaris2*)\n \ttm_p_file=\"${tm_p_file} sol2-protos.h\"\n \textra_parts=\"crt1.o crti.o crtn.o gcrt1.o gmon.o crtbegin.o crtend.o\"\n \tcase ${enable_threads}:${have_pthread_h}:${have_thread_h} in\n-\t  \"\":yes:* | yes:yes:* ) thread_file=posix ;;\n-\t  \"\":*:yes | yes:*:yes ) thread_file=solaris ;;\n+\t  \"\":yes:* | yes:yes:* )\n+\t\tcase ${target} in\n+\t\t  *-*-solaris2.[0-6] | *-*-solaris2.[0-6].*)\n+\t\t\tthread_file=posix95\n+\t\t\t;;\n+\t\t  *)\n+\t\t\tthread_file=posix\n+\t\t\t;;\n+\t\tesac\n+\t\t;;\n+\t  \"\":*:yes | yes:*:yes )\n+\t\tthread_file=solaris\n+\t\t;;\n \tesac\n \t;;\n sparc-*-sysv4*)"}, {"sha": "2c34cb2c352e41c6da8ea7cce181523c87501acd", "filename": "gcc/config/sol26.h", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181674429bc9e230b405b98694ab423c8bdb42eb/gcc%2Fconfig%2Fsol26.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181674429bc9e230b405b98694ab423c8bdb42eb/gcc%2Fconfig%2Fsol26.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsol26.h?ref=181674429bc9e230b405b98694ab423c8bdb42eb", "patch": "@@ -0,0 +1,27 @@\n+/* Operating system specific defines to be used when targeting GCC for any\n+   Solaris 2 system up to Solaris 2.6.\n+   Copyright 2004 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#undef CPP_SUBTARGET_SPEC\n+#define CPP_SUBTARGET_SPEC \"\\\n+%{pthreads:-D_REENTRANT -D_PTHREADS95} \\\n+%{!pthreads:%{threads:-D_REENTRANT -D_SOLARIS_THREADS}} \\\n+%{compat-bsd:-iwithprefixbefore ucbinclude -I/usr/ucbinclude} \\\n+\""}, {"sha": "5ccbd34834cc5a0af089bdfbdef1450fea9a441c", "filename": "gcc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181674429bc9e230b405b98694ab423c8bdb42eb/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181674429bc9e230b405b98694ab423c8bdb42eb/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=181674429bc9e230b405b98694ab423c8bdb42eb", "patch": "@@ -11976,7 +11976,7 @@ case ${enable_threads} in\n     # default\n     target_thread_file='single'\n     ;;\n-  aix | dce | gnat | irix | posix | rtems | \\\n+  aix | dce | gnat | irix | posix | posix95 | rtems | \\\n   single | solaris | vxworks | win32 )\n     target_thread_file=${enable_threads}\n     ;;"}, {"sha": "80eb7161ca84e4cc40233752ff4a36983e7cac92", "filename": "gcc/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181674429bc9e230b405b98694ab423c8bdb42eb/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181674429bc9e230b405b98694ab423c8bdb42eb/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=181674429bc9e230b405b98694ab423c8bdb42eb", "patch": "@@ -1266,7 +1266,7 @@ case ${enable_threads} in\n     # default\n     target_thread_file='single'\n     ;;\n-  aix | dce | gnat | irix | posix | rtems | \\\n+  aix | dce | gnat | irix | posix | posix95 | rtems | \\\n   single | solaris | vxworks | win32 )\n     target_thread_file=${enable_threads}\n     ;;"}, {"sha": "44fb961b00453bc3b439927ffab9c428b511bed4", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181674429bc9e230b405b98694ab423c8bdb42eb/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181674429bc9e230b405b98694ab423c8bdb42eb/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=181674429bc9e230b405b98694ab423c8bdb42eb", "patch": "@@ -926,7 +926,9 @@ missing and thus this setting will cause a known bootstrap failure.)\n @item no\n This is an alias for @samp{single}.\n @item posix\n-Generic POSIX thread support.\n+Generic POSIX/Unix98 thread support.\n+@item posix95\n+Generic POSIX/Unix95 thread support.\n @item rtems\n RTEMS thread support.\n @item single"}, {"sha": "78e1d89485bdeae0a25157342704521d29cee2a7", "filename": "gcc/gthr-posix95.h", "status": "added", "additions": 592, "deletions": 0, "changes": 592, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181674429bc9e230b405b98694ab423c8bdb42eb/gcc%2Fgthr-posix95.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181674429bc9e230b405b98694ab423c8bdb42eb/gcc%2Fgthr-posix95.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix95.h?ref=181674429bc9e230b405b98694ab423c8bdb42eb", "patch": "@@ -0,0 +1,592 @@\n+/* Threads compatibility routines for libgcc2 and libobjc.  */\n+/* Compile this one with gcc.  */\n+/* Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with other files,\n+   some of which are compiled with GCC, to produce an executable,\n+   this library does not by itself cause the resulting executable\n+   to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#ifndef GCC_GTHR_POSIX_H\n+#define GCC_GTHR_POSIX_H\n+\n+/* POSIX threads specific definitions.\n+   Easy, since the interface is just one-to-one mapping.  */\n+\n+#define __GTHREADS 1\n+\n+/* Some implementations of <pthread.h> require this to be defined.  */\n+#ifndef _REENTRANT\n+#define _REENTRANT 1\n+#endif\n+\n+#include <pthread.h>\n+#include <unistd.h>\n+\n+typedef pthread_key_t __gthread_key_t;\n+typedef pthread_once_t __gthread_once_t;\n+typedef pthread_mutex_t __gthread_mutex_t;\n+\n+typedef struct {\n+  long depth;\n+  pthread_t owner;\n+  pthread_mutex_t actual;\n+} __gthread_recursive_mutex_t;\n+\n+#define __GTHREAD_MUTEX_INIT PTHREAD_MUTEX_INITIALIZER\n+#define __GTHREAD_ONCE_INIT PTHREAD_ONCE_INIT\n+#define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function\n+\n+#if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n+\n+#pragma weak pthread_once\n+#pragma weak pthread_key_create\n+#pragma weak pthread_key_delete\n+#pragma weak pthread_getspecific\n+#pragma weak pthread_setspecific\n+#pragma weak pthread_create\n+#pragma weak pthread_self\n+\n+#pragma weak pthread_mutex_lock\n+#pragma weak pthread_mutex_trylock\n+#pragma weak pthread_mutex_unlock\n+#pragma weak pthread_mutexattr_init\n+#pragma weak pthread_mutexattr_settype\n+#pragma weak pthread_mutexattr_destroy\n+\n+#pragma weak pthread_mutex_init\n+\n+#if defined(_LIBOBJC) || defined(_LIBOBJC_WEAK)\n+/* Objective-C.  */\n+#pragma weak pthread_cond_broadcast\n+#pragma weak pthread_cond_destroy\n+#pragma weak pthread_cond_init\n+#pragma weak pthread_cond_signal\n+#pragma weak pthread_cond_wait\n+#pragma weak pthread_exit\n+#pragma weak pthread_mutex_destroy\n+#pragma weak pthread_self\n+#ifdef _POSIX_PRIORITY_SCHEDULING\n+#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n+#pragma weak sched_get_priority_max\n+#pragma weak sched_get_priority_min\n+#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n+#endif /* _POSIX_PRIORITY_SCHEDULING */\n+#pragma weak sched_yield\n+#pragma weak pthread_attr_destroy\n+#pragma weak pthread_attr_init\n+#pragma weak pthread_attr_setdetachstate\n+#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n+#pragma weak pthread_getschedparam\n+#pragma weak pthread_setschedparam\n+#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n+#endif /* _LIBOBJC || _LIBOBJC_WEAK */\n+\n+static inline int\n+__gthread_active_p (void)\n+{\n+  static void *const __gthread_active_ptr \n+    = __extension__ (void *) &pthread_create;\n+  return __gthread_active_ptr != 0;\n+}\n+\n+#else /* not SUPPORTS_WEAK */\n+\n+static inline int\n+__gthread_active_p (void)\n+{\n+  return 1;\n+}\n+\n+#endif /* SUPPORTS_WEAK */\n+\n+#ifdef _LIBOBJC\n+\n+/* This is the config.h file in libobjc/ */\n+#include <config.h>\n+\n+#ifdef HAVE_SCHED_H\n+# include <sched.h>\n+#endif\n+\n+/* Key structure for maintaining thread specific storage */\n+static pthread_key_t _objc_thread_storage;\n+static pthread_attr_t _objc_thread_attribs;\n+\n+/* Thread local storage for a single thread */\n+static void *thread_local_storage = NULL;\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem.  */\n+static inline int\n+__gthread_objc_init_thread_system (void)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      /* Initialize the thread storage key.  */\n+      if (pthread_key_create (&_objc_thread_storage, NULL) == 0)\n+\t{\n+\t  /* The normal default detach state for threads is\n+\t   * PTHREAD_CREATE_JOINABLE which causes threads to not die\n+\t   * when you think they should.  */\n+\t  if (pthread_attr_init (&_objc_thread_attribs) == 0\n+\t      && pthread_attr_setdetachstate (&_objc_thread_attribs,\n+\t\t\t\t\t      PTHREAD_CREATE_DETACHED) == 0)\n+\t    return 0;\n+\t}\n+    }\n+\n+  return -1;\n+}\n+\n+/* Close the threads subsystem.  */\n+static inline int\n+__gthread_objc_close_thread_system (void)\n+{\n+  if (__gthread_active_p ()\n+      && pthread_key_delete (_objc_thread_storage) == 0\n+      && pthread_attr_destroy (&_objc_thread_attribs) == 0)\n+    return 0;\n+\n+  return -1;\n+}\n+\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution.  */\n+static inline objc_thread_t\n+__gthread_objc_thread_detach (void (*func)(void *), void *arg)\n+{\n+  objc_thread_t thread_id;\n+  pthread_t new_thread_handle;\n+\n+  if (!__gthread_active_p ())\n+    return NULL;\n+\n+  if (!(pthread_create (&new_thread_handle, NULL, (void *) func, arg)))\n+    thread_id = (objc_thread_t) new_thread_handle;\n+  else\n+    thread_id = NULL;\n+\n+  return thread_id;\n+}\n+\n+/* Set the current thread's priority.  */\n+static inline int\n+__gthread_objc_thread_set_priority (int priority)\n+{\n+  if (!__gthread_active_p ())\n+    return -1;\n+  else\n+    {\n+#ifdef _POSIX_PRIORITY_SCHEDULING\n+#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n+      pthread_t thread_id = pthread_self ();\n+      int policy;\n+      struct sched_param params;\n+      int priority_min, priority_max;\n+\n+      if (pthread_getschedparam (thread_id, &policy, &params) == 0)\n+\t{\n+\t  if ((priority_max = sched_get_priority_max (policy)) == -1)\n+\t    return -1;\n+\n+\t  if ((priority_min = sched_get_priority_min (policy)) == -1)\n+\t    return -1;\n+\n+\t  if (priority > priority_max)\n+\t    priority = priority_max;\n+\t  else if (priority < priority_min)\n+\t    priority = priority_min;\n+\t  params.sched_priority = priority;\n+\n+\t  /*\n+\t   * The solaris 7 and several other man pages incorrectly state that\n+\t   * this should be a pointer to policy but pthread.h is universally\n+\t   * at odds with this.\n+\t   */\n+\t  if (pthread_setschedparam (thread_id, policy, &params) == 0)\n+\t    return 0;\n+\t}\n+#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n+#endif /* _POSIX_PRIORITY_SCHEDULING */\n+      return -1;\n+    }\n+}\n+\n+/* Return the current thread's priority.  */\n+static inline int\n+__gthread_objc_thread_get_priority (void)\n+{\n+#ifdef _POSIX_PRIORITY_SCHEDULING\n+#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n+  if (__gthread_active_p ())\n+    {\n+      int policy;\n+      struct sched_param params;\n+\n+      if (pthread_getschedparam (pthread_self (), &policy, &params) == 0)\n+\treturn params.sched_priority;\n+      else\n+\treturn -1;\n+    }\n+  else\n+#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n+#endif /* _POSIX_PRIORITY_SCHEDULING */\n+    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+}\n+\n+/* Yield our process time to another thread.  */\n+static inline void\n+__gthread_objc_thread_yield (void)\n+{\n+  if (__gthread_active_p ())\n+    sched_yield ();\n+}\n+\n+/* Terminate the current thread.  */\n+static inline int\n+__gthread_objc_thread_exit (void)\n+{\n+  if (__gthread_active_p ())\n+    /* exit the thread */\n+    pthread_exit (&__objc_thread_exit_status);\n+\n+  /* Failed if we reached here */\n+  return -1;\n+}\n+\n+/* Returns an integer value which uniquely describes a thread.  */\n+static inline objc_thread_t\n+__gthread_objc_thread_id (void)\n+{\n+  if (__gthread_active_p ())\n+    return (objc_thread_t) pthread_self ();\n+  else\n+    return (objc_thread_t) 1;\n+}\n+\n+/* Sets the thread's local storage pointer.  */\n+static inline int\n+__gthread_objc_thread_set_data (void *value)\n+{\n+  if (__gthread_active_p ())\n+    return pthread_setspecific (_objc_thread_storage, value);\n+  else\n+    {\n+      thread_local_storage = value;\n+      return 0;\n+    }\n+}\n+\n+/* Returns the thread's local storage pointer.  */\n+static inline void *\n+__gthread_objc_thread_get_data (void)\n+{\n+  if (__gthread_active_p ())\n+    return pthread_getspecific (_objc_thread_storage);\n+  else\n+    return thread_local_storage;\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex.  */\n+static inline int\n+__gthread_objc_mutex_allocate (objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      mutex->backend = objc_malloc (sizeof (pthread_mutex_t));\n+\n+      if (pthread_mutex_init ((pthread_mutex_t *) mutex->backend, NULL))\n+\t{\n+\t  objc_free (mutex->backend);\n+\t  mutex->backend = NULL;\n+\t  return -1;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Deallocate a mutex.  */\n+static inline int\n+__gthread_objc_mutex_deallocate (objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      int count;\n+\n+      /*\n+       * Posix Threads specifically require that the thread be unlocked\n+       * for pthread_mutex_destroy to work.\n+       */\n+\n+      do\n+\t{\n+\t  count = pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend);\n+\t  if (count < 0)\n+\t    return -1;\n+\t}\n+      while (count);\n+\n+      if (pthread_mutex_destroy ((pthread_mutex_t *) mutex->backend))\n+\treturn -1;\n+\n+      objc_free (mutex->backend);\n+      mutex->backend = NULL;\n+    }\n+  return 0;\n+}\n+\n+/* Grab a lock on a mutex.  */\n+static inline int\n+__gthread_objc_mutex_lock (objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ()\n+      && pthread_mutex_lock ((pthread_mutex_t *) mutex->backend) != 0)\n+    {\n+      return -1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Try to grab a lock on a mutex.  */\n+static inline int\n+__gthread_objc_mutex_trylock (objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ()\n+      && pthread_mutex_trylock ((pthread_mutex_t *) mutex->backend) != 0)\n+    {\n+      return -1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Unlock the mutex */\n+static inline int\n+__gthread_objc_mutex_unlock (objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ()\n+      && pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend) != 0)\n+    {\n+      return -1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition.  */\n+static inline int\n+__gthread_objc_condition_allocate (objc_condition_t condition)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      condition->backend = objc_malloc (sizeof (pthread_cond_t));\n+\n+      if (pthread_cond_init ((pthread_cond_t *) condition->backend, NULL))\n+\t{\n+\t  objc_free (condition->backend);\n+\t  condition->backend = NULL;\n+\t  return -1;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Deallocate a condition.  */\n+static inline int\n+__gthread_objc_condition_deallocate (objc_condition_t condition)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      if (pthread_cond_destroy ((pthread_cond_t *) condition->backend))\n+\treturn -1;\n+\n+      objc_free (condition->backend);\n+      condition->backend = NULL;\n+    }\n+  return 0;\n+}\n+\n+/* Wait on the condition */\n+static inline int\n+__gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ())\n+    return pthread_cond_wait ((pthread_cond_t *) condition->backend,\n+\t\t\t      (pthread_mutex_t *) mutex->backend);\n+  else\n+    return 0;\n+}\n+\n+/* Wake up all threads waiting on this condition.  */\n+static inline int\n+__gthread_objc_condition_broadcast (objc_condition_t condition)\n+{\n+  if (__gthread_active_p ())\n+    return pthread_cond_broadcast ((pthread_cond_t *) condition->backend);\n+  else\n+    return 0;\n+}\n+\n+/* Wake up one thread waiting on this condition.  */\n+static inline int\n+__gthread_objc_condition_signal (objc_condition_t condition)\n+{\n+  if (__gthread_active_p ())\n+    return pthread_cond_signal ((pthread_cond_t *) condition->backend);\n+  else\n+    return 0;\n+}\n+\n+#else /* _LIBOBJC */\n+\n+static inline int\n+__gthread_once (__gthread_once_t *once, void (*func) (void))\n+{\n+  if (__gthread_active_p ())\n+    return pthread_once (once, func);\n+  else\n+    return -1;\n+}\n+\n+static inline int\n+__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n+{\n+  return pthread_key_create (key, dtor);\n+}\n+\n+static inline int\n+__gthread_key_delete (__gthread_key_t key)\n+{\n+  return pthread_key_delete (key);\n+}\n+\n+static inline void *\n+__gthread_getspecific (__gthread_key_t key)\n+{\n+  return pthread_getspecific (key);\n+}\n+\n+static inline int\n+__gthread_setspecific (__gthread_key_t key, const void *ptr)\n+{\n+  return pthread_setspecific (key, ptr);\n+}\n+\n+static inline int\n+__gthread_mutex_lock (__gthread_mutex_t *mutex)\n+{\n+  if (__gthread_active_p ())\n+    return pthread_mutex_lock (mutex);\n+  else\n+    return 0;\n+}\n+\n+static inline int\n+__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n+{\n+  if (__gthread_active_p ())\n+    return pthread_mutex_trylock (mutex);\n+  else\n+    return 0;\n+}\n+\n+static inline int\n+__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n+{\n+  if (__gthread_active_p ())\n+    return pthread_mutex_unlock (mutex);\n+  else\n+    return 0;\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n+{\n+  mutex->depth = 0;\n+  mutex->owner = (pthread_t) 0;\n+  return pthread_mutex_init (&mutex->actual, NULL);\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      pthread_t me = pthread_self ();\n+\n+      if (mutex->owner != me)\n+\t{\n+\t  pthread_mutex_lock (&mutex->actual);\n+\t  mutex->owner = me;\n+\t}\n+\n+      mutex->depth++;\n+    }\n+  return 0;\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      pthread_t me = pthread_self ();\n+\n+      if (mutex->owner != me)\n+\t{\n+\t  if (pthread_mutex_trylock (&mutex->actual))\n+\t    return 1;\n+\t  mutex->owner = me;\n+\t}\n+\n+      mutex->depth++;\n+    }\n+  return 0;\n+}\n+\n+static inline int\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      if (--mutex->depth == 0)\n+        {\n+\t   mutex->owner = (pthread_t) 0;\n+\t   pthread_mutex_unlock (&mutex->actual);\n+\t}\n+    }\n+  return 0;\n+}\n+\n+#endif /* _LIBOBJC */\n+\n+#endif /* ! GCC_GTHR_POSIX_H */"}, {"sha": "70345a57c6a086a1d26bf116ab9ffe4b1702b514", "filename": "gcc/gthr.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181674429bc9e230b405b98694ab423c8bdb42eb/gcc%2Fgthr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181674429bc9e230b405b98694ab423c8bdb42eb/gcc%2Fgthr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr.h?ref=181674429bc9e230b405b98694ab423c8bdb42eb", "patch": "@@ -83,7 +83,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    number.  If the operation is not supported, -1 is returned.\n \n    Currently supported threads packages are\n-     POSIX threads with -D_PTHREADS\n+     TPF threads with -D__tpf__\n+     POSIX/Unix98 threads with -D_PTHREADS\n+     POSIX/Unix95 threads with -D_PTHREADS95\n      DCE threads with -D_DCE_THREADS\n      Solaris/UI threads with -D_SOLARIS_THREADS\n */\n@@ -93,6 +95,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"gthr-tpf.h\"\n #elif _PTHREADS\n #include \"gthr-posix.h\"\n+#elif _PTHREADS95\n+#include \"gthr-posix95.h\"\n #elif _DCE_THREADS\n #include \"gthr-dce.h\"\n #elif _SOLARIS_THREADS"}]}