{"sha": "64e6863ed571bbd89eb7a65e3727a2a4ecc1ea27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRlNjg2M2VkNTcxYmJkODllYjdhNjVlMzcyN2EyYTRlY2MxZWEyNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-05-17T08:15:41Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-05-17T08:15:41Z"}, "message": "* config/i386/sse.md (mulv16qi3, mulv2di3): New.\n\nFrom-SVN: r99824", "tree": {"sha": "f0184ce23c030c7fb89609b4a44adfbe78828469", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0184ce23c030c7fb89609b4a44adfbe78828469"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64e6863ed571bbd89eb7a65e3727a2a4ecc1ea27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64e6863ed571bbd89eb7a65e3727a2a4ecc1ea27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64e6863ed571bbd89eb7a65e3727a2a4ecc1ea27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64e6863ed571bbd89eb7a65e3727a2a4ecc1ea27/comments", "author": null, "committer": null, "parents": [{"sha": "34bab46d1a5dbd12110adad9245454c5699bcfa5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34bab46d1a5dbd12110adad9245454c5699bcfa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34bab46d1a5dbd12110adad9245454c5699bcfa5"}], "stats": {"total": 120, "additions": 120, "deletions": 0}, "files": [{"sha": "82233e9ee9bba1a77c0b6dd2b67fd850e0050af5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64e6863ed571bbd89eb7a65e3727a2a4ecc1ea27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64e6863ed571bbd89eb7a65e3727a2a4ecc1ea27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=64e6863ed571bbd89eb7a65e3727a2a4ecc1ea27", "patch": "@@ -1,3 +1,7 @@\n+2005-05-17  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/sse.md (mulv16qi3, mulv2di3): New.\n+\n 2005-05-17  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/21492"}, {"sha": "5ff94ba98148b5598215ee49eb4d6111a0b1170a", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64e6863ed571bbd89eb7a65e3727a2a4ecc1ea27/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64e6863ed571bbd89eb7a65e3727a2a4ecc1ea27/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=64e6863ed571bbd89eb7a65e3727a2a4ecc1ea27", "patch": "@@ -2392,6 +2392,50 @@\n   [(set_attr \"type\" \"sseiadd\")\n    (set_attr \"mode\" \"TI\")])\n \n+(define_expand \"mulv16qi3\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"\")\n+\t(mult:V16QI (match_operand:V16QI 1 \"register_operand\" \"\")\n+\t\t    (match_operand:V16QI 2 \"register_operand\" \"\")))]\n+  \"TARGET_SSE2\"\n+{\n+  rtx t[12], op0;\n+  int i;\n+\n+  for (i = 0; i < 12; ++i)\n+    t[i] = gen_reg_rtx (V16QImode);\n+\n+  /* Unpack data such that we've got a source byte in each low byte of\n+     each word.  We don't care what goes into the high byte of each word.\n+     Rather than trying to get zero in there, most convenient is to let\n+     it be a copy of the low byte.  */\n+  emit_insn (gen_sse2_punpckhbw (t[0], operands[1], operands[1]));\n+  emit_insn (gen_sse2_punpckhbw (t[1], operands[2], operands[2]));\n+  emit_insn (gen_sse2_punpcklbw (t[2], operands[1], operands[1]));\n+  emit_insn (gen_sse2_punpcklbw (t[3], operands[2], operands[2]));\n+\n+  /* Multiply words.  The end-of-line annotations here give a picture of what\n+     the output of that instruction looks like.  Dot means don't care; the \n+     letters are the bytes of the result with A being the most significant.  */\n+  emit_insn (gen_mulv8hi3 (gen_lowpart (V8HImode, t[4]), /* .A.B.C.D.E.F.G.H */\n+\t\t\t   gen_lowpart (V8HImode, t[0]),\n+\t\t\t   gen_lowpart (V8HImode, t[1])));\n+  emit_insn (gen_mulv8hi3 (gen_lowpart (V8HImode, t[5]), /* .I.J.K.L.M.N.O.P */\n+\t\t\t   gen_lowpart (V8HImode, t[2]),\n+\t\t\t   gen_lowpart (V8HImode, t[3])));\n+\n+  /* Extract the relevant bytes and merge them back together.  */\n+  emit_insn (gen_sse2_punpckhbw (t[6], t[5], t[4]));\t/* ..AI..BJ..CK..DL */\n+  emit_insn (gen_sse2_punpcklbw (t[7], t[5], t[4]));\t/* ..EM..FN..GO..HP */\n+  emit_insn (gen_sse2_punpckhbw (t[8], t[7], t[6]));\t/* ....AEIM....BFJN */\n+  emit_insn (gen_sse2_punpcklbw (t[9], t[7], t[6]));\t/* ....CGKO....DHLP */\n+  emit_insn (gen_sse2_punpckhbw (t[10], t[9], t[8]));\t/* ........ACEGIKMO */\n+  emit_insn (gen_sse2_punpcklbw (t[11], t[9], t[8]));\t/* ........BDFHJLNP */\n+\n+  op0 = operands[0];\n+  emit_insn (gen_sse2_punpcklbw (op0, t[11], t[10]));\t/* ABCDEFGHIJKLMNOP */\n+  DONE;\n+})\n+\n (define_expand \"mulv8hi3\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"\")\n \t(mult:V8HI (match_operand:V8HI 1 \"nonimmediate_operand\" \"\")\n@@ -2536,6 +2580,50 @@\n   DONE;\n })\n \n+(define_expand \"mulv2di3\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"\")\n+\t(mult:V2DI (match_operand:V2DI 1 \"nonimmediate_operand\" \"\")\n+\t\t   (match_operand:V2DI 2 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_SSE2\"\n+{\n+  rtx t1, t2, t3, t4, t5, t6, thirtytwo;\n+  rtx op0, op1, op2;\n+\n+  op0 = operands[0];\n+  op1 = operands[1];\n+  op2 = operands[2];\n+  t1 = gen_reg_rtx (V2DImode);\n+  t2 = gen_reg_rtx (V2DImode);\n+  t3 = gen_reg_rtx (V2DImode);\n+  t4 = gen_reg_rtx (V2DImode);\n+  t5 = gen_reg_rtx (V2DImode);\n+  t6 = gen_reg_rtx (V2DImode);\n+  thirtytwo = GEN_INT (32);\n+\n+  /* Multiply low parts.  */\n+  emit_insn (gen_sse2_umulv2siv2di3 (t1, gen_lowpart (V4SImode, op1),\n+\t\t\t\t     gen_lowpart (V4SImode, op2)));\n+\n+  /* Shift input vectors left 32 bits so we can multiply high parts.  */\n+  emit_insn (gen_lshrv2di3 (t2, op1, thirtytwo));\n+  emit_insn (gen_lshrv2di3 (t3, op2, thirtytwo));\n+\n+  /* Multiply high parts by low parts.  */\n+  emit_insn (gen_sse2_umulv2siv2di3 (t4, gen_lowpart (V4SImode, op1),\n+\t\t\t\t     gen_lowpart (V4SImode, t3)));\n+  emit_insn (gen_sse2_umulv2siv2di3 (t5, gen_lowpart (V4SImode, op2),\n+\t\t\t\t     gen_lowpart (V4SImode, t2)));\n+\n+  /* Shift them back.  */\n+  emit_insn (gen_ashlv2di3 (t4, t4, thirtytwo));\n+  emit_insn (gen_ashlv2di3 (t5, t5, thirtytwo));\n+\n+  /* Add the three parts together.  */\n+  emit_insn (gen_addv2di3 (t6, t1, t4));\n+  emit_insn (gen_addv2di3 (op0, t6, t5));\n+  DONE;\n+})\n+\n (define_insn \"ashr<mode>3\"\n   [(set (match_operand:SSEMODE24 0 \"register_operand\" \"=x\")\n \t(ashiftrt:SSEMODE24"}, {"sha": "3b803fc71b6a0fb708c0343f9d83abb68779f503", "filename": "gcc/testsuite/gcc.dg/vect/vect-100.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64e6863ed571bbd89eb7a65e3727a2a4ecc1ea27/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-100.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64e6863ed571bbd89eb7a65e3727a2a4ecc1ea27/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-100.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-100.c?ref=64e6863ed571bbd89eb7a65e3727a2a4ecc1ea27", "patch": "@@ -0,0 +1,28 @@\n+/* Assuming we can vectorize char multiplication, here's an execute test.  */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+extern void abort (void);\n+void foo()\n+{\n+  static unsigned char A[256], B[256], C[256];\n+  int i;\n+\n+  for (i = 0; i < 256; ++i)\n+    A[i] = B[i] = i;\n+\n+  for (i = 0; i < 256; ++i)\n+    C[i] = A[i] * B[i];\n+\n+  for (i = 0; i < 256; ++i)\n+    if (C[i] != (unsigned char)(i * i))\n+      abort ();\n+}\n+\n+int main()\n+{\n+  check_vect ();\n+  foo();\n+  return 0;\n+}"}]}