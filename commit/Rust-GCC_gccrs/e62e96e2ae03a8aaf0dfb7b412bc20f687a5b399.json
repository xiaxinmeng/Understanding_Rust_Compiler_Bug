{"sha": "e62e96e2ae03a8aaf0dfb7b412bc20f687a5b399", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYyZTk2ZTJhZTAzYThhYWYwZGZiN2I0MTJiYzIwZjY4N2E1YjM5OQ==", "commit": {"author": {"name": "Sascha Brawer", "email": "brawer@dandelis.ch", "date": "2003-10-21T13:18:22Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-10-21T13:18:22Z"}, "message": "Fix for Classpath bug #6076.\n\n2003-10-21  Sascha Brawer  <brawer@dandelis.ch>\n\n\tFix for Classpath bug #6076.\n\t* java/awt/geom/GeneralPath.java (append): Re-written.\n\n2003-10-21  Sascha Brawer  <brawer@dandelis.ch>\n\n\tFix for Classpath bug #6089.\n\t* java/awt/geom/GeneralPath.java (curveTo): Set correct segment type.\n\t(getPathIterator, GeneralPathIterator): Re-written from scratch.\n\n2003-10-21  Sascha Brawer  <brawer@dandelis.ch>\n\n\t* java/awt/geom/GeneralPath.java (getCurrentPoint): Return last\n\tpoint, not start of subpath.  Fixes Classpath bug #6075.\n\nFrom-SVN: r72748", "tree": {"sha": "2e2e326a8d4b5912e61de5d168d5f3db716293bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e2e326a8d4b5912e61de5d168d5f3db716293bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e62e96e2ae03a8aaf0dfb7b412bc20f687a5b399", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e62e96e2ae03a8aaf0dfb7b412bc20f687a5b399", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e62e96e2ae03a8aaf0dfb7b412bc20f687a5b399", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e62e96e2ae03a8aaf0dfb7b412bc20f687a5b399/comments", "author": null, "committer": null, "parents": [{"sha": "c4ff410a6ba8420e1f8083a779b0ed57014e7d1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ff410a6ba8420e1f8083a779b0ed57014e7d1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4ff410a6ba8420e1f8083a779b0ed57014e7d1c"}], "stats": {"total": 314, "additions": 221, "deletions": 93}, "files": [{"sha": "4946230c0930e4550ee4518c28504ba6236ef674", "filename": "libjava/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e62e96e2ae03a8aaf0dfb7b412bc20f687a5b399/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e62e96e2ae03a8aaf0dfb7b412bc20f687a5b399/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=e62e96e2ae03a8aaf0dfb7b412bc20f687a5b399", "patch": "@@ -1,3 +1,19 @@\n+2003-10-21  Sascha Brawer  <brawer@dandelis.ch>\n+\n+\tFix for Classpath bug #6076.\n+\t* java/awt/geom/GeneralPath.java (append): Re-written.\n+\n+2003-10-21  Sascha Brawer  <brawer@dandelis.ch>\n+\n+\tFix for Classpath bug #6089.\n+\t* java/awt/geom/GeneralPath.java (curveTo): Set correct segment type.\n+\t(getPathIterator, GeneralPathIterator): Re-written from scratch.\n+\n+2003-10-21  Sascha Brawer  <brawer@dandelis.ch>\n+\n+\t* java/awt/geom/GeneralPath.java (getCurrentPoint): Return last\n+\tpoint, not start of subpath.  Fixes Classpath bug #6075.\n+\n 2003-10-21  Michael Koch  <konqueror@gmx.de>\n \n \t* java/nio/ByteOrder.java,"}, {"sha": "05d98c762388df605fac7e074325331a7f63b1fa", "filename": "libjava/java/awt/geom/GeneralPath.java", "status": "modified", "additions": 205, "deletions": 93, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e62e96e2ae03a8aaf0dfb7b412bc20f687a5b399/libjava%2Fjava%2Fawt%2Fgeom%2FGeneralPath.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e62e96e2ae03a8aaf0dfb7b412bc20f687a5b399/libjava%2Fjava%2Fawt%2Fgeom%2FGeneralPath.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fgeom%2FGeneralPath.java?ref=e62e96e2ae03a8aaf0dfb7b412bc20f687a5b399", "patch": "@@ -1,5 +1,5 @@\n /* GeneralPath.java -- represents a shape built from subpaths\n-   Copyright (C) 2002 Free Software Foundation\n+   Copyright (C) 2002, 2003 Free Software Foundation\n \n This file is part of GNU Classpath.\n \n@@ -128,7 +128,7 @@ public void curveTo(float x1, float y1, float x2, float y2,\n                       float x3, float y3)\n   {\n     ensureSize(index + 6);\n-    types[index >> 1] = PathIterator.SEG_QUADTO;\n+    types[index >> 1] = PathIterator.SEG_CUBICTO;\n     points[index++] = x1;\n     points[index++] = y1;\n     points[index++] = x2;\n@@ -148,40 +148,69 @@ public void append(Shape s, boolean connect)\n   {\n     append(s.getPathIterator(null), connect);\n   }\n-  public void append(PathIterator i, boolean connect)\n+\n+\n+  /**\n+   * Appends the segments of a PathIterator to this GeneralPath.\n+   * Optionally, the initial {@link PathIterator#SEG_MOVETO} segment\n+   * of the appended path is changed into a {@link\n+   * PathIterator#SEG_LINETO} segment.\n+   *\n+   * @param iter the PathIterator specifying which segments shall be\n+   * appended.\n+   * \n+   * @param connect <code>true</code> for substituting the initial\n+   * {@link PathIterator#SEG_MOVETO} segment by a {@link\n+   * PathIterator#SEG_LINETO}, or <code>false</code> for not\n+   * performing any substitution. If this GeneralPath is currently\n+   * empty, <code>connect</code> is assumed to be <code>false</code>,\n+   * thus leaving the initial {@link PathIterator#SEG_MOVETO}\n+   * unchanged.\n+   */\n+  public void append(PathIterator iter, boolean connect)\n   {\n+    // A bad implementation of this method had caused Classpath bug #6076.\n     float[] f = new float[6];\n-    while (! i.isDone())\n+    while (!iter.isDone())\n+    {\n+      switch (iter.currentSegment(f))\n       {\n-        int result = i.currentSegment(f);\n-        switch (result)\n-          {\n-          case PathIterator.SEG_MOVETO:\n-            if (! connect)\n-              {\n-                moveTo(f[0], f[1]);\n-                break;\n-              }\n-            if (subpath >= 0 && f[0] == points[subpath]\n-                && f[1] == points[subpath + 1])\n-              break;\n-            // Fallthrough.\n-          case PathIterator.SEG_LINETO:\n-            lineTo(f[0], f[1]);\n-            break;\n-          case PathIterator.SEG_QUADTO:\n-            quadTo(f[0], f[1], f[2], f[3]);\n-            break;\n-          case PathIterator.SEG_CUBICTO:\n-            curveTo(f[0], f[1], f[2], f[3], f[4], f[5]);\n-            break;\n-          default:\n-            closePath();\n-          }\n-        connect = false;\n+      case PathIterator.SEG_MOVETO:\n+        if (!connect || (index == 0))\n+        {\n+          moveTo(f[0], f[1]);\n+          break;\n+        }\n+\n+        if ((index >= 2) && (types[(index - 2) >> 2] == PathIterator.SEG_CLOSE)\n+            && (f[0] == points[index - 2]) && (f[1] == points[index - 1]))\n+          break;\n+        \n+        // Fall through.\n+\n+      case PathIterator.SEG_LINETO:\n+        lineTo(f[0], f[1]);\n+        break;\n+\n+      case PathIterator.SEG_QUADTO:\n+        quadTo(f[0], f[1], f[2], f[3]);\n+        break;\n+\n+      case PathIterator.SEG_CUBICTO:\n+        curveTo(f[0], f[1], f[2], f[3], f[4], f[5]);\n+        break;\n+\n+      case PathIterator.SEG_CLOSE:\n+        closePath();\n+        break;\n       }\n+\n+      connect = false;\n+      iter.next();\n+    }\n   }\n \n+\n   public int getWindingRule()\n   {\n     return rule;\n@@ -197,7 +226,7 @@ public Point2D getCurrentPoint()\n   {\n     if (subpath < 0)\n       return null;\n-    return new Point2D.Float(points[subpath], points[subpath + 1]);\n+    return new Point2D.Float(points[index - 2], points[index - 1]);\n   }\n   public void reset()\n   {\n@@ -254,80 +283,163 @@ public boolean intersects(Rectangle2D r)\n   {\n     return intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());\n   }\n-  public PathIterator getPathIterator(final AffineTransform at)\n+\n+\n+  /**\n+   * A PathIterator that iterates over the segments of a GeneralPath.\n+   *\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n+  private static class GeneralPathIterator\n+    implements PathIterator\n   {\n-    return new PathIterator()\n+    /**\n+     * The number of coordinate values for each segment type.\n+     */\n+    private static final int[] NUM_COORDS =\n     {\n-      int current = 0;\n+      /* 0: SEG_MOVETO */ 2,\n+      /* 1: SEG_LINETO */ 2,\n+      /* 2: SEG_QUADTO */ 4,\n+      /* 3: SEG_CUBICTO */ 6,\n+      /* 4: SEG_CLOSE */ 0\n+    };\n \n-      public int getWindingRule()\n-      {\n-        return rule;\n-      }\n \n-      public boolean isDone()\n-      {\n-        return current >= index;\n-      }\n+    /**\n+     * The GeneralPath whose segments are being iterated.\n+     */\n+    private final GeneralPath path;\n \n-      public void next()\n-      {\n-        current++;\n-      }\n \n-      public int currentSegment(float[] coords)\n+    /**\n+     * The affine transformation used to transform coordinates.\n+     */\n+    private final AffineTransform transform;\n+\n+\n+    /**\n+     * The current position of the iterator.\n+     */\n+    private int pos;\n+\n+\n+    /**\n+     * Constructs a new iterator for enumerating the segments of a\n+     * GeneralPath.\n+     *\n+     * @param at an affine transformation for projecting the returned\n+     * points, or <code>null</code> to return the original points\n+     * without any mapping.\n+     */\n+    GeneralPathIterator(GeneralPath path, AffineTransform transform)\n+    {\n+      this.path = path;\n+      this.transform = transform;\n+    }\n+\n+\n+    /**\n+     * Returns the current winding rule of the GeneralPath.\n+     */\n+    public int getWindingRule()\n+    {\n+      return path.rule;\n+    }\n+\n+\n+    /**\n+     * Determines whether the iterator has reached the last segment in\n+     * the path.\n+     */\n+    public boolean isDone()\n+    {\n+      return pos >= path.index;\n+    }\n+\n+\n+    /**\n+     * Advances the iterator position by one segment.\n+     */\n+    public void next()\n+    {\n+      int seg;\n+\n+      /* Increment pos by the number of coordinate values. Note that\n+       * we store two values even for a SEG_CLOSE segment, which is\n+       * why we increment pos at least by 2. \n+       */\n+      seg = path.types[pos >> 1];\n+      if (seg == SEG_CLOSE)\n+        pos += 2;\n+      else\n+        pos += NUM_COORDS[seg];\n+    }\n+\n+\n+    /**\n+     * Returns the current segment in float coordinates.\n+     */\n+    public int currentSegment(float[] coords)\n+    {\n+      int seg, numCoords;\n+\n+      seg = path.types[pos >> 1];\n+      numCoords = NUM_COORDS[seg];\n+      if (numCoords > 0)\n       {\n-        if (current >= index)\n-          return SEG_CLOSE;\n-        int result = types[current >> 1];\n-        int i = 0;\n-        if (result == 3)\n-          {\n-            coords[i++] = points[current++];\n-            coords[i++] = points[current++];\n-          }\n-        if (result == 2)\n-          {\n-            coords[i++] = points[current++];\n-            coords[i++] = points[current++];\n-          }\n-        if (result < 2)\n-          {\n-            coords[i++] = points[current++];\n-            coords[i++] = points[current++];\n-            if (at != null)\n-              at.transform(coords, 0, coords, 0, result == 0 ? 1 : result);\n-          }\n-        return result;\n+        if (transform == null)\n+          System.arraycopy(path.points, pos, coords, 0, numCoords);\n+        else\n+          transform.transform(/* src */ path.points, /* srcOffset */ pos,\n+                              /* dest */ coords, /* destOffset */ 0,\n+                              /* numPoints */ numCoords >> 1);\n       }\n+      return seg;\n+    }\n+\n+\n+    /**\n+     * Returns the current segment in double coordinates.\n+     */\n+    public int currentSegment(double[] coords)\n+    {\n+      int seg, numCoords;\n \n-      public int currentSegment(double[] coords)\n+      seg = path.types[pos >> 1];\n+      numCoords = NUM_COORDS[seg];\n+      if (numCoords > 0)\n       {\n-        if (current >= index)\n-          return SEG_CLOSE;\n-        int result = types[current >> 1];\n-        int i = 0;\n-        if (result == 3)\n-          {\n-            coords[i++] = points[current++];\n-            coords[i++] = points[current++];\n-          }\n-        if (result == 2)\n-          {\n-            coords[i++] = points[current++];\n-            coords[i++] = points[current++];\n-          }\n-        if (result < 2)\n-          {\n-            coords[i++] = points[current++];\n-            coords[i++] = points[current++];\n-            if (at != null)\n-              at.transform(coords, 0, coords, 0, result == 0 ? 1 : result);\n-          }\n-        return result;\n+        if (transform == null)\n+        {\n+          // System.arraycopy throws an exception if the source and destination\n+          // array are not of the same primitive type.\n+          for (int i = 0; i < numCoords; i++)\n+            coords[i] = (double) path.points[pos + i];\n+        }\n+        else\n+          transform.transform(/* src */ path.points, /* srcOffset */ pos,\n+                              /* dest */ coords, /* destOffset */ 0,\n+                              /* numPoints */ numCoords >> 1);\n       }\n-    };\n+      return seg;\n+    }\n+  }\n+\n+\n+  /**\n+   * Creates a PathIterator for iterating along the segments of this path.\n+   *\n+   * @param at an affine transformation for projecting the returned\n+   * points, or <code>null</code> to let the created iterator return\n+   * the original points without any mapping.\n+   */\n+  public PathIterator getPathIterator(AffineTransform at)\n+  {\n+    return new GeneralPathIterator(this, at);\n   }\n+\n+\n   public PathIterator getPathIterator(AffineTransform at, double flatness)\n   {\n     return new FlatteningPathIterator(getPathIterator(at), flatness);"}]}