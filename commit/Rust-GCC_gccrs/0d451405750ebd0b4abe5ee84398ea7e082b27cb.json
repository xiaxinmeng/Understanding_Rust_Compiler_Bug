{"sha": "0d451405750ebd0b4abe5ee84398ea7e082b27cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ0NTE0MDU3NTBlYmQwYjRhYmU1ZWU4NDM5OGVhN2UwODJiMjdjYg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2005-12-02T14:40:40Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2005-12-02T14:40:40Z"}, "message": "tree-vrp.c (build_assert_expr_for, [...]): Use buildN instead of build.\n\n2005-12-02  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vrp.c (build_assert_expr_for, process_assert_insertions_for,\n\tsimplify_cond_using_ranges): Use buildN instead of build.\n\t* tree-tailcall.c (adjust_accumulator_values,\n\tadjust_return_value): Likewise.\n\t* tree-sra.c (generate_one_element_ref, generate_copy_inout,\n\tgenerate_element_copy, generate_element_zero,\n\tgenerate_one_element_init): Likewise.\n\t* tree-ssa-forwprop.c (forward_propagate_into_cond_1): Likewise.\n\t* lambda-code.c (gcc_loop_to_lambda_loop, lbv_to_gcc_expression,\n\tlle_to_gcc_expression, lambda_loopnest_to_gcc_loopnest,\n\tperfect_nestify): Likewise.\n\nFrom-SVN: r107894", "tree": {"sha": "91c46da23139dff93fd79a1086c7f732c02caccb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91c46da23139dff93fd79a1086c7f732c02caccb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d451405750ebd0b4abe5ee84398ea7e082b27cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d451405750ebd0b4abe5ee84398ea7e082b27cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d451405750ebd0b4abe5ee84398ea7e082b27cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d451405750ebd0b4abe5ee84398ea7e082b27cb/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "69f8a2d68a851452b56452d866e4d383a83da7bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69f8a2d68a851452b56452d866e4d383a83da7bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69f8a2d68a851452b56452d866e4d383a83da7bd"}], "stats": {"total": 168, "additions": 91, "deletions": 77}, "files": [{"sha": "0f20adc6b4a6ba0d237e803e5e97fb5150e3efba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d451405750ebd0b4abe5ee84398ea7e082b27cb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d451405750ebd0b4abe5ee84398ea7e082b27cb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d451405750ebd0b4abe5ee84398ea7e082b27cb", "patch": "@@ -1,3 +1,17 @@\n+2005-12-02  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vrp.c (build_assert_expr_for, process_assert_insertions_for,\n+\tsimplify_cond_using_ranges): Use buildN instead of build.\n+\t* tree-tailcall.c (adjust_accumulator_values,\n+\tadjust_return_value): Likewise.\n+\t* tree-sra.c (generate_one_element_ref, generate_copy_inout,\n+\tgenerate_element_copy, generate_element_zero,\n+\tgenerate_one_element_init): Likewise.\n+\t* tree-ssa-forwprop.c (forward_propagate_into_cond_1): Likewise.\n+\t* lambda-code.c (gcc_loop_to_lambda_loop, lbv_to_gcc_expression,\n+\tlle_to_gcc_expression, lambda_loopnest_to_gcc_loopnest,\n+\tperfect_nestify): Likewise.\n+\n 2005-12-02  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* pa.c (pa_secondary_reload): Revise initialization of variable regno."}, {"sha": "43889f78595cb3e81a2929d0894326783d185fd5", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d451405750ebd0b4abe5ee84398ea7e082b27cb/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d451405750ebd0b4abe5ee84398ea7e082b27cb/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=0d451405750ebd0b4abe5ee84398ea7e082b27cb", "patch": "@@ -1434,8 +1434,8 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n   ubound = gcc_tree_to_linear_expression (depth, uboundvar,\n \t\t\t\t\t  outerinductionvars,\n \t\t\t\t\t  *invariants, extra);\n-  uboundresult = build (PLUS_EXPR, TREE_TYPE (uboundvar), uboundvar,\n-\t\t\tbuild_int_cst (TREE_TYPE (uboundvar), extra));\n+  uboundresult = build2 (PLUS_EXPR, TREE_TYPE (uboundvar), uboundvar,\n+\t\t\t build_int_cst (TREE_TYPE (uboundvar), extra));\n   VEC_safe_push (tree, heap, *uboundvars, uboundresult);\n   VEC_safe_push (tree, heap, *lboundvars, lboundvar);\n   VEC_safe_push (int, heap, *steps, stepint);\n@@ -1576,7 +1576,7 @@ lbv_to_gcc_expression (lambda_body_vector lbv,\n   add_referenced_tmp_var (resvar);\n \n   /* Start at 0.  */\n-  stmt = build (MODIFY_EXPR, void_type_node, resvar, integer_zero_node);\n+  stmt = build2 (MODIFY_EXPR, void_type_node, resvar, integer_zero_node);\n   name = make_ssa_name (resvar, stmt);\n   TREE_OPERAND (stmt, 0) = name;\n   tsi = tsi_last (stmts);\n@@ -1591,8 +1591,8 @@ lbv_to_gcc_expression (lambda_body_vector lbv,\n \t  \n \t  /* newname = coefficient * induction_variable */\n \t  coeffmult = build_int_cst (type, LBV_COEFFICIENTS (lbv)[i]);\n-\t  stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t\tfold_build2 (MULT_EXPR, type, iv, coeffmult));\n+\t  stmt = build2 (MODIFY_EXPR, void_type_node, resvar,\n+\t\t\t fold_build2 (MULT_EXPR, type, iv, coeffmult));\n \n \t  newname = make_ssa_name (resvar, stmt);\n \t  TREE_OPERAND (stmt, 0) = newname;\n@@ -1601,8 +1601,8 @@ lbv_to_gcc_expression (lambda_body_vector lbv,\n \t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \n \t  /* name = name + newname */\n-\t  stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t\tbuild (PLUS_EXPR, type, name, newname));\n+\t  stmt = build2 (MODIFY_EXPR, void_type_node, resvar,\n+\t\t\t build2 (PLUS_EXPR, type, name, newname));\n \t  name = make_ssa_name (resvar, stmt);\n \t  TREE_OPERAND (stmt, 0) = name;\n \t  fold_stmt (&stmt);\n@@ -1616,8 +1616,8 @@ lbv_to_gcc_expression (lambda_body_vector lbv,\n   if (LBV_DENOMINATOR (lbv) != 1)\n     {\n       tree denominator = build_int_cst (type, LBV_DENOMINATOR (lbv));\n-      stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t    build (CEIL_DIV_EXPR, type, name, denominator));\n+      stmt = build2 (MODIFY_EXPR, void_type_node, resvar,\n+\t\t     build2 (CEIL_DIV_EXPR, type, name, denominator));\n       name = make_ssa_name (resvar, stmt);\n       TREE_OPERAND (stmt, 0) = name;\n       fold_stmt (&stmt);\n@@ -1667,7 +1667,7 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n   for (; lle != NULL; lle = LLE_NEXT (lle))\n     {\n       /* Start at name = 0.  */\n-      stmt = build (MODIFY_EXPR, void_type_node, resvar, integer_zero_node);\n+      stmt = build2 (MODIFY_EXPR, void_type_node, resvar, integer_zero_node);\n       name = make_ssa_name (resvar, stmt);\n       TREE_OPERAND (stmt, 0) = name;\n       fold_stmt (&stmt);\n@@ -1698,16 +1698,16 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n \t\t}\n \n \t      /* newname = mult */\n-\t      stmt = build (MODIFY_EXPR, void_type_node, resvar, mult);\n+\t      stmt = build2 (MODIFY_EXPR, void_type_node, resvar, mult);\n \t      newname = make_ssa_name (resvar, stmt);\n \t      TREE_OPERAND (stmt, 0) = newname;\n \t      fold_stmt (&stmt);\n \t      tsi = tsi_last (stmts);\n \t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \n \t      /* name = name + newname */\n-\t      stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t\t    build (PLUS_EXPR, type, name, newname));\n+\t      stmt = build2 (MODIFY_EXPR, void_type_node, resvar,\n+\t\t\t     build2 (PLUS_EXPR, type, name, newname));\n \t      name = make_ssa_name (resvar, stmt);\n \t      TREE_OPERAND (stmt, 0) = name;\n \t      fold_stmt (&stmt);\n@@ -1739,16 +1739,16 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n \t\t}\n \n \t      /* newname = mult */\n-\t      stmt = build (MODIFY_EXPR, void_type_node, resvar, mult);\n+\t      stmt = build2 (MODIFY_EXPR, void_type_node, resvar, mult);\n \t      newname = make_ssa_name (resvar, stmt);\n \t      TREE_OPERAND (stmt, 0) = newname;\n \t      fold_stmt (&stmt);\n \t      tsi = tsi_last (stmts);\n \t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \n \t      /* name = name + newname */\n-\t      stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t\t    build (PLUS_EXPR, type, name, newname));\n+\t      stmt = build2 (MODIFY_EXPR, void_type_node, resvar,\n+\t\t\t     build2 (PLUS_EXPR, type, name, newname));\n \t      name = make_ssa_name (resvar, stmt);\n \t      TREE_OPERAND (stmt, 0) = name;\n \t      fold_stmt (&stmt);\n@@ -1761,9 +1761,9 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n          name = name + constant.  */\n       if (LLE_CONSTANT (lle) != 0)\n \t{\n-\t  stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t\tbuild (PLUS_EXPR, type, name, \n-\t\t\t       build_int_cst (type, LLE_CONSTANT (lle))));\n+\t  stmt = build2 (MODIFY_EXPR, void_type_node, resvar,\n+\t\t\t build2 (PLUS_EXPR, type, name, \n+\t\t\t         build_int_cst (type, LLE_CONSTANT (lle))));\n \t  name = make_ssa_name (resvar, stmt);\n \t  TREE_OPERAND (stmt, 0) = name;\n \t  fold_stmt (&stmt);\n@@ -1775,9 +1775,9 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n          name = name + linear offset.  */\n       if (LLE_CONSTANT (offset) != 0)\n \t{\n-\t  stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t\tbuild (PLUS_EXPR, type, name, \n-\t\t\t       build_int_cst (type, LLE_CONSTANT (offset))));\n+\t  stmt = build2 (MODIFY_EXPR, void_type_node, resvar,\n+\t\t\t build2 (PLUS_EXPR, type, name, \n+\t\t\t         build_int_cst (type, LLE_CONSTANT (offset))));\n \t  name = make_ssa_name (resvar, stmt);\n \t  TREE_OPERAND (stmt, 0) = name;\n \t  fold_stmt (&stmt);\n@@ -1789,9 +1789,9 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n       if (LLE_DENOMINATOR (lle) != 1)\n \t{\n \t  stmt = build_int_cst (type, LLE_DENOMINATOR (lle));\n-\t  stmt = build (wrap == MAX_EXPR ? CEIL_DIV_EXPR : FLOOR_DIV_EXPR,\n-\t\t\ttype, name, stmt);\n-\t  stmt = build (MODIFY_EXPR, void_type_node, resvar, stmt);\n+\t  stmt = build2 (wrap == MAX_EXPR ? CEIL_DIV_EXPR : FLOOR_DIV_EXPR,\n+\t\t\t type, name, stmt);\n+\t  stmt = build2 (MODIFY_EXPR, void_type_node, resvar, stmt);\n \n \t  /* name = {ceil, floor}(name/denominator) */\n \t  name = make_ssa_name (resvar, stmt);\n@@ -1811,8 +1811,8 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n     {\n       tree op1 = VEC_index (tree, results, 0);\n       tree op2 = VEC_index (tree, results, 1);\n-      stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t    build (wrap, type, op1, op2));\n+      stmt = build2 (MODIFY_EXPR, void_type_node, resvar,\n+\t\t     build2 (wrap, type, op1, op2));\n       name = make_ssa_name (resvar, stmt);\n       TREE_OPERAND (stmt, 0) = name;\n       tsi = tsi_last (stmts);\n@@ -1927,10 +1927,10 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n \t dominate the block containing the exit condition.\n \t So we simply create our own incremented iv to use in the new exit\n \t test,  and let redundancy elimination sort it out.  */\n-      inc_stmt = build (PLUS_EXPR, type, \n-\t\t\tivvar, build_int_cst (type, LL_STEP (newloop)));\n-      inc_stmt = build (MODIFY_EXPR, void_type_node, SSA_NAME_VAR (ivvar),\n-\t\t\tinc_stmt);\n+      inc_stmt = build2 (PLUS_EXPR, type, \n+\t\t\t ivvar, build_int_cst (type, LL_STEP (newloop)));\n+      inc_stmt = build2 (MODIFY_EXPR, void_type_node, SSA_NAME_VAR (ivvar),\n+\t\t\t inc_stmt);\n       ivvarinced = make_ssa_name (SSA_NAME_VAR (ivvar), inc_stmt);\n       TREE_OPERAND (inc_stmt, 0) = ivvarinced;\n       bsi = bsi_for_stmt (exitcond);\n@@ -1948,9 +1948,9 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n       if (exit->flags & EDGE_FALSE_VALUE)\n \ttesttype = swap_tree_comparison (testtype);\n \n-      COND_EXPR_COND (exitcond) = build (testtype,\n-\t\t\t\t\t boolean_type_node,\n-\t\t\t\t\t newupperbound, ivvarinced);\n+      COND_EXPR_COND (exitcond) = build2 (testtype,\n+\t\t\t\t\t  boolean_type_node,\n+\t\t\t\t\t  newupperbound, ivvarinced);\n       update_stmt (exitcond);\n       VEC_replace (tree, new_ivs, i, ivvar);\n \n@@ -2424,11 +2424,11 @@ perfect_nestify (struct loops *loops,\n   make_edge (headerbb, bodybb, EDGE_FALLTHRU); \n   then_label = build1 (GOTO_EXPR, void_type_node, tree_block_label (latchbb));\n   else_label = build1 (GOTO_EXPR, void_type_node, tree_block_label (olddest));\n-  cond_stmt = build (COND_EXPR, void_type_node,\n-\t\t     build (NE_EXPR, boolean_type_node, \n-\t\t\t    integer_one_node, \n-\t\t\t    integer_zero_node), \n-\t\t     then_label, else_label);\n+  cond_stmt = build3 (COND_EXPR, void_type_node,\n+\t\t      build2 (NE_EXPR, boolean_type_node, \n+\t\t\t      integer_one_node, \n+\t\t\t      integer_zero_node), \n+\t\t      then_label, else_label);\n   bsi = bsi_start (bodybb);\n   bsi_insert_after (&bsi, cond_stmt, BSI_NEW_STMT);\n   e = make_edge (bodybb, olddest, EDGE_FALSE_VALUE);\n@@ -2464,8 +2464,8 @@ perfect_nestify (struct loops *loops,\n   exit_condition = get_loop_exit_condition (newloop);\n   uboundvar = create_tmp_var (integer_type_node, \"uboundvar\");\n   add_referenced_tmp_var (uboundvar);\n-  stmt = build (MODIFY_EXPR, void_type_node, uboundvar, \n-\t\tVEC_index (tree, ubounds, 0));\n+  stmt = build2 (MODIFY_EXPR, void_type_node, uboundvar, \n+\t\t VEC_index (tree, ubounds, 0));\n   uboundvar = make_ssa_name (uboundvar, stmt);\n   TREE_OPERAND (stmt, 0) = uboundvar;\n \n@@ -2474,10 +2474,10 @@ perfect_nestify (struct loops *loops,\n   else\n     bsi_insert_before (&bsi, stmt, BSI_SAME_STMT);\n   update_stmt (stmt);\n-  COND_EXPR_COND (exit_condition) = build (GE_EXPR, \n-\t\t\t\t\t   boolean_type_node,\n-\t\t\t\t\t   uboundvar,\n-\t\t\t\t\t   ivvarinced);\n+  COND_EXPR_COND (exit_condition) = build2 (GE_EXPR, \n+\t\t\t\t\t    boolean_type_node,\n+\t\t\t\t\t    uboundvar,\n+\t\t\t\t\t    ivvarinced);\n   update_stmt (exit_condition);\n   bbs = get_loop_body_in_dom_order (loop); \n   /* Now move the statements, and replace the induction variable in the moved"}, {"sha": "bae96f0c2209bf66951082c33752c225d8e0e575", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d451405750ebd0b4abe5ee84398ea7e082b27cb/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d451405750ebd0b4abe5ee84398ea7e082b27cb/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=0d451405750ebd0b4abe5ee84398ea7e082b27cb", "patch": "@@ -1511,17 +1511,17 @@ generate_one_element_ref (struct sra_elt *elt, tree base)\n \tif (DECL_FIELD_CONTEXT (field) != TYPE_MAIN_VARIANT (TREE_TYPE (base)))\n \t  field = find_compatible_field (TREE_TYPE (base), field);\n \n-        return build (COMPONENT_REF, elt->type, base, field, NULL);\n+        return build3 (COMPONENT_REF, elt->type, base, field, NULL);\n       }\n \n     case ARRAY_TYPE:\n-      return build (ARRAY_REF, elt->type, base, elt->element, NULL, NULL);\n+      return build4 (ARRAY_REF, elt->type, base, elt->element, NULL, NULL);\n \n     case COMPLEX_TYPE:\n       if (elt->element == integer_zero_node)\n-\treturn build (REALPART_EXPR, elt->type, base);\n+\treturn build1 (REALPART_EXPR, elt->type, base);\n       else\n-\treturn build (IMAGPART_EXPR, elt->type, base);\n+\treturn build1 (IMAGPART_EXPR, elt->type, base);\n \n     default:\n       gcc_unreachable ();\n@@ -1561,17 +1561,17 @@ generate_copy_inout (struct sra_elt *elt, bool copy_out, tree expr,\n       c = lookup_element (elt, integer_one_node, NULL, NO_INSERT);\n       i = c->replacement;\n \n-      t = build (COMPLEX_EXPR, elt->type, r, i);\n-      t = build (MODIFY_EXPR, void_type_node, expr, t);\n+      t = build2 (COMPLEX_EXPR, elt->type, r, i);\n+      t = build2 (MODIFY_EXPR, void_type_node, expr, t);\n       SSA_NAME_DEF_STMT (expr) = t;\n       append_to_statement_list (t, list_p);\n     }\n   else if (elt->replacement)\n     {\n       if (copy_out)\n-\tt = build (MODIFY_EXPR, void_type_node, elt->replacement, expr);\n+\tt = build2 (MODIFY_EXPR, void_type_node, elt->replacement, expr);\n       else\n-\tt = build (MODIFY_EXPR, void_type_node, expr, elt->replacement);\n+\tt = build2 (MODIFY_EXPR, void_type_node, expr, elt->replacement);\n       append_to_statement_list (t, list_p);\n     }\n   else\n@@ -1606,8 +1606,8 @@ generate_element_copy (struct sra_elt *dst, struct sra_elt *src, tree *list_p)\n \n       gcc_assert (src->replacement);\n \n-      t = build (MODIFY_EXPR, void_type_node, dst->replacement,\n-\t\t src->replacement);\n+      t = build2 (MODIFY_EXPR, void_type_node, dst->replacement,\n+\t\t  src->replacement);\n       append_to_statement_list (t, list_p);\n     }\n }\n@@ -1638,7 +1638,7 @@ generate_element_zero (struct sra_elt *elt, tree *list_p)\n       gcc_assert (elt->is_scalar);\n       t = fold_convert (elt->type, integer_zero_node);\n \n-      t = build (MODIFY_EXPR, void_type_node, elt->replacement, t);\n+      t = build2 (MODIFY_EXPR, void_type_node, elt->replacement, t);\n       append_to_statement_list (t, list_p);\n     }\n }\n@@ -1650,7 +1650,7 @@ static void\n generate_one_element_init (tree var, tree init, tree *list_p)\n {\n   /* The replacement can be almost arbitrarily complex.  Gimplify.  */\n-  tree stmt = build (MODIFY_EXPR, void_type_node, var, init);\n+  tree stmt = build2 (MODIFY_EXPR, void_type_node, var, init);\n   gimplify_and_add (stmt, list_p);\n }\n "}, {"sha": "a5023ed810c9dd01e50ecb84adc07898027d85e4", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d451405750ebd0b4abe5ee84398ea7e082b27cb/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d451405750ebd0b4abe5ee84398ea7e082b27cb/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=0d451405750ebd0b4abe5ee84398ea7e082b27cb", "patch": "@@ -244,7 +244,7 @@ forward_propagate_into_cond_1 (tree cond, tree *test_var_p)\n \t  if (!is_gimple_val (t))\n \t    return NULL_TREE;\n \n-\t  new_cond = build (cond_code, boolean_type_node, op0, t);\n+\t  new_cond = build2 (cond_code, boolean_type_node, op0, t);\n \t}\n     }\n \n@@ -285,8 +285,8 @@ forward_propagate_into_cond_1 (tree cond, tree *test_var_p)\n \t  if (has_single_use (test_var))\n \t    {\n \t      /* TEST_VAR was set from a relational operator.  */\n-\t      new_cond = build (TREE_CODE (def_rhs),\n-\t\t\t\tboolean_type_node, op0, op1);\n+\t      new_cond = build2 (TREE_CODE (def_rhs),\n+\t\t\t\t boolean_type_node, op0, op1);\n \n \t      /* Invert the conditional if necessary.  */\n \t      if ((cond_code == EQ_EXPR"}, {"sha": "ce5af15ef1c7c0838750856654bf8b11f4f261b1", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d451405750ebd0b4abe5ee84398ea7e082b27cb/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d451405750ebd0b4abe5ee84398ea7e082b27cb/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=0d451405750ebd0b4abe5ee84398ea7e082b27cb", "patch": "@@ -559,8 +559,8 @@ adjust_accumulator_values (block_stmt_iterator bsi, tree m, tree a, edge back)\n \t    var = m_acc;\n \t  else\n \t    {\n-\t      stmt = build (MODIFY_EXPR, ret_type, NULL_TREE,\n-\t\t\t    build (MULT_EXPR, ret_type, m_acc, a));\n+\t      stmt = build2 (MODIFY_EXPR, ret_type, NULL_TREE,\n+\t\t\t     build2 (MULT_EXPR, ret_type, m_acc, a));\n \n \t      tmp = create_tmp_var (ret_type, \"acc_tmp\");\n \t      add_referenced_tmp_var (tmp);\n@@ -573,8 +573,8 @@ adjust_accumulator_values (block_stmt_iterator bsi, tree m, tree a, edge back)\n       else\n \tvar = a;\n \n-      stmt = build (MODIFY_EXPR, ret_type, NULL_TREE,\n-\t\t    build (PLUS_EXPR, ret_type, a_acc, var));\n+      stmt = build2 (MODIFY_EXPR, ret_type, NULL_TREE,\n+\t\t     build2 (PLUS_EXPR, ret_type, a_acc, var));\n       var = make_ssa_name (SSA_NAME_VAR (a_acc), stmt);\n       TREE_OPERAND (stmt, 0) = var;\n       bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n@@ -583,8 +583,8 @@ adjust_accumulator_values (block_stmt_iterator bsi, tree m, tree a, edge back)\n \n   if (m)\n     {\n-      stmt = build (MODIFY_EXPR, ret_type, NULL_TREE,\n-\t\t    build (MULT_EXPR, ret_type, m_acc, m));\n+      stmt = build2 (MODIFY_EXPR, ret_type, NULL_TREE,\n+\t\t     build2 (MULT_EXPR, ret_type, m_acc, m));\n       var = make_ssa_name (SSA_NAME_VAR (m_acc), stmt);\n       TREE_OPERAND (stmt, 0) = var;\n       bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n@@ -638,8 +638,8 @@ adjust_return_value (basic_block bb, tree m, tree a)\n \n   if (m)\n     {\n-      stmt = build (MODIFY_EXPR, ret_type, NULL_TREE,\n-\t\t    build (MULT_EXPR, ret_type, m_acc, ret_var));\n+      stmt = build2 (MODIFY_EXPR, ret_type, NULL_TREE,\n+\t\t     build2 (MULT_EXPR, ret_type, m_acc, ret_var));\n \n       tmp = create_tmp_var (ret_type, \"acc_tmp\");\n       add_referenced_tmp_var (tmp);\n@@ -653,8 +653,8 @@ adjust_return_value (basic_block bb, tree m, tree a)\n \n   if (a)\n     {\n-      stmt = build (MODIFY_EXPR, ret_type, NULL_TREE,\n-\t\t    build (PLUS_EXPR, ret_type, a_acc, var));\n+      stmt = build2 (MODIFY_EXPR, ret_type, NULL_TREE,\n+\t\t     build2 (PLUS_EXPR, ret_type, a_acc, var));\n \n       tmp = create_tmp_var (ret_type, \"acc_tmp\");\n       add_referenced_tmp_var (tmp);"}, {"sha": "04353f5ad8b279c2889b4c93acf1f58e2fe6452b", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d451405750ebd0b4abe5ee84398ea7e082b27cb/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d451405750ebd0b4abe5ee84398ea7e082b27cb/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=0d451405750ebd0b4abe5ee84398ea7e082b27cb", "patch": "@@ -2164,21 +2164,21 @@ build_assert_expr_for (tree cond, tree v)\n \n   if (COMPARISON_CLASS_P (cond))\n     {\n-      tree a = build (ASSERT_EXPR, TREE_TYPE (v), v, cond); \n-      assertion = build (MODIFY_EXPR, TREE_TYPE (v), n, a);\n+      tree a = build2 (ASSERT_EXPR, TREE_TYPE (v), v, cond); \n+      assertion = build2 (MODIFY_EXPR, TREE_TYPE (v), n, a);\n     }\n   else if (TREE_CODE (cond) == TRUTH_NOT_EXPR)\n     {\n       /* Given !V, build the assignment N = false.  */\n       tree op0 = TREE_OPERAND (cond, 0);\n       gcc_assert (op0 == v);\n-      assertion = build (MODIFY_EXPR, TREE_TYPE (v), n, boolean_false_node);\n+      assertion = build2 (MODIFY_EXPR, TREE_TYPE (v), n, boolean_false_node);\n     }\n   else if (TREE_CODE (cond) == SSA_NAME)\n     {\n       /* Given V, build the assignment N = true.  */\n       gcc_assert (v == cond);\n-      assertion = build (MODIFY_EXPR, TREE_TYPE (v), n, boolean_true_node);\n+      assertion = build2 (MODIFY_EXPR, TREE_TYPE (v), n, boolean_true_node);\n     }\n   else\n     gcc_unreachable ();\n@@ -2781,7 +2781,7 @@ process_assert_insertions_for (tree name, assert_locus_t loc)\n   edge_iterator ei;\n   edge e;\n \n-  cond = build (loc->comp_code, boolean_type_node, name, loc->val);\n+  cond = build2 (loc->comp_code, boolean_type_node, name, loc->val);\n   assert_expr = build_assert_expr_for (cond, name);\n \n   if (loc->e)\n@@ -3957,7 +3957,7 @@ simplify_cond_using_ranges (tree stmt)\n \t\t}\n \n \t      COND_EXPR_COND (stmt)\n-\t\t= build (EQ_EXPR, boolean_type_node, op0, new);\n+\t\t= build2 (EQ_EXPR, boolean_type_node, op0, new);\n \t      update_stmt (stmt);\n \n \t      if (dump_file)\n@@ -3985,7 +3985,7 @@ simplify_cond_using_ranges (tree stmt)\n \t\t}\n \n \t      COND_EXPR_COND (stmt)\n-\t\t= build (NE_EXPR, boolean_type_node, op0, new);\n+\t\t= build2 (NE_EXPR, boolean_type_node, op0, new);\n \t      update_stmt (stmt);\n \n \t      if (dump_file)"}]}