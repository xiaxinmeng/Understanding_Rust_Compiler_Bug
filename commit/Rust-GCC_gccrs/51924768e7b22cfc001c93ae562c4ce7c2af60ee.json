{"sha": "51924768e7b22cfc001c93ae562c4ce7c2af60ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE5MjQ3NjhlN2IyMmNmYzAwMWM5M2FlNTYyYzRjZTdjMmFmNjBlZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-10-19T20:08:23Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-10-19T20:08:23Z"}, "message": "Revamp references to member functions.\n\n\t* method.c (hack_identifier): Call build_component_ref for a\n\treference to a member function.\n\t* typeck.c (build_component_ref): Only return a single function\n\tif it's static.  Otherwise, return a COMPONENT_REF.\n\t(build_x_function_call): Handle a COMPONENT_REF.\n\t(build_unary_op): Handle all unknown-type things.\n\t* decl2.c (arg_assoc): Handle COMPONENT_REF.\n\t* class.c (instantiate_type): Complain if the function we get is a\n\tnonstatic member function.  Remove code for finding \"compatible\"\n\tfunctions.\n\t* pt.c (tsubst_copy): Handle NOP_EXPR.\n\t* tree.c (build_dummy_object): New fn.\n\t(maybe_dummy_object): New fn.\n\t(is_dummy_object): New fn.\n\t* cp-tree.h: Declare them.\n\t* cvt.c (cp_convert_to_pointer): Use maybe_dummy_object.\n\t* error.c (dump_expr, case OFFSET_REF): Use is_dummy_object.\n\t* init.c (build_member_call): Use maybe_dummy_object and\n\tis_dummy_object.\n\t(build_offset_ref): Use maybe_dummy_object.\n\t(resolve_offset_ref): Use is_dummy_object.\n\t* typeck.c (build_x_function_call): Call build_dummy_object.\n\t(unary_complex_lvalue): Call is_dummy_object.\n\t* typeck.c (build_component_addr): Make sure field is a field.\n\t* call.c (build_new_op): Delete obsolete code.\n\t* pt.c (tsubst, TEMPLATE*PARM*): Abort if we don't have any args.\n\nFrom-SVN: r23186", "tree": {"sha": "a80a7239efe1c828f5d785068f86b4c524aee0ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a80a7239efe1c828f5d785068f86b4c524aee0ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51924768e7b22cfc001c93ae562c4ce7c2af60ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51924768e7b22cfc001c93ae562c4ce7c2af60ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51924768e7b22cfc001c93ae562c4ce7c2af60ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51924768e7b22cfc001c93ae562c4ce7c2af60ee/comments", "author": null, "committer": null, "parents": [{"sha": "4f2905fb4b3857320f2a3218f8419d8b3616ce63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f2905fb4b3857320f2a3218f8419d8b3616ce63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f2905fb4b3857320f2a3218f8419d8b3616ce63"}], "stats": {"total": 425, "additions": 163, "deletions": 262}, "files": [{"sha": "fb5a81e66e42805f2bdb1c9a685ed68074fa75e5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=51924768e7b22cfc001c93ae562c4ce7c2af60ee", "patch": "@@ -1,3 +1,36 @@\n+1998-10-19  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\tRevamp references to member functions.\n+\t* method.c (hack_identifier): Call build_component_ref for a\n+\treference to a member function.\n+\t* typeck.c (build_component_ref): Only return a single function \n+\tif it's static.  Otherwise, return a COMPONENT_REF.\n+\t(build_x_function_call): Handle a COMPONENT_REF.\n+\t(build_unary_op): Handle all unknown-type things.\n+\t* decl2.c (arg_assoc): Handle COMPONENT_REF.\n+\t* class.c (instantiate_type): Complain if the function we get is a\n+\tnonstatic member function.  Remove code for finding \"compatible\"\n+\tfunctions.\n+\t* pt.c (tsubst_copy): Handle NOP_EXPR.\n+\t* tree.c (build_dummy_object): New fn.\n+\t(maybe_dummy_object): New fn.\n+\t(is_dummy_object): New fn.\n+\t* cp-tree.h: Declare them.\n+\t* cvt.c (cp_convert_to_pointer): Use maybe_dummy_object.\n+\t* error.c (dump_expr, case OFFSET_REF): Use is_dummy_object.\n+\t* init.c (build_member_call): Use maybe_dummy_object and\n+\tis_dummy_object.\n+\t(build_offset_ref): Use maybe_dummy_object.\n+\t(resolve_offset_ref): Use is_dummy_object.\n+\t* typeck.c (build_x_function_call): Call build_dummy_object.\n+\t(unary_complex_lvalue): Call is_dummy_object.\n+\n+\t* typeck.c (build_component_addr): Make sure field is a field.\n+\n+\t* call.c (build_new_op): Delete obsolete code.\n+\n+\t* pt.c (tsubst, TEMPLATE*PARM*): Abort if we don't have any args.\n+\n 1998-10-18  Martin von L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* decl2.c (validate_nonmember_using_decl): Fix using-directives of"}, {"sha": "dc05d19b81ba8df5d80c7ab3fcbd24d447d2b9c8", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 71, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=51924768e7b22cfc001c93ae562c4ce7c2af60ee", "patch": "@@ -2513,73 +2513,10 @@ build_new_op (code, flags, arg1, arg2, arg3)\n     {\n     case NEW_EXPR:\n     case VEC_NEW_EXPR:\n-      {\n-\ttree rval;\n-\n-\targlist = scratch_tree_cons (NULL_TREE, arg2, arg3);\n-\tif (flags & LOOKUP_GLOBAL)\n-\t  return build_new_function_call\n-\t    (lookup_function_nonclass (fnname, arglist), arglist);\n-\n-\t/* FIXME */\n-\trval = build_method_call\n-\t  (build_indirect_ref (build1 (NOP_EXPR, arg1, error_mark_node),\n-\t\t\t       \"new\"),\n-\t   fnname, arglist, NULL_TREE, flags);\n-\tif (rval == error_mark_node)\n-\t  /* User might declare fancy operator new, but invoke it\n-\t     like standard one.  */\n-\t  return rval;\n-\n-\tTREE_TYPE (rval) = arg1;\n-\treturn rval;\n-      }\n-\n     case VEC_DELETE_EXPR:\n     case DELETE_EXPR:\n-      {\n-\ttree rval;\n-\n-\tif (flags & LOOKUP_GLOBAL)\n-\t  {\n-\t    arglist = build_scratch_list (NULL_TREE, arg1);\n-\t    return build_new_function_call\n-\t      (lookup_function_nonclass (fnname, arglist), arglist);\n-\t  }    \n-\n-\targlist = scratch_tree_cons (NULL_TREE, arg1, build_scratch_list (NULL_TREE, arg2));\n-\n-\targ1 = TREE_TYPE (arg1);\n-\n-\t/* This handles the case where we're trying to delete\n-\t   X (*a)[10];\n-\t   a=new X[5][10];\n-\t   delete[] a; */\n-\t   \n-\tif (TREE_CODE (TREE_TYPE (arg1)) == ARRAY_TYPE)\n-\t  {\n-\t    /* Strip off the pointer and the array.  */\n-\t    arg1 = TREE_TYPE (TREE_TYPE (arg1));\n-\n-\t    while (TREE_CODE (arg1) == ARRAY_TYPE)\n-\t\targ1 = (TREE_TYPE (arg1));\n-\n-\t    arg1 = build_pointer_type (arg1);\n-\t  }\n-\n-\t/* FIXME */\n-\trval = build_method_call\n-\t  (build_indirect_ref (build1 (NOP_EXPR, arg1,\n-\t\t\t\t       error_mark_node),\n-\t\t\t       NULL_PTR),\n-\t   fnname, arglist, NULL_TREE, flags);\n-#if 0\n-\t/* This can happen when operator delete is protected.  */\n-\tmy_friendly_assert (rval != error_mark_node, 250);\n-\tTREE_TYPE (rval) = void_type_node;\n-#endif\n-\treturn rval;\n-      }\n+      /* Use build_op_new_call and build_op_delete_call instead. */\n+      my_friendly_abort (981018);\n \n     case CALL_EXPR:\n       return build_object_call (arg1, arg2);\n@@ -2898,10 +2835,8 @@ build_op_new_call (code, type, args, flags)\n   if (IS_AGGR_TYPE (type) && ! (flags & LOOKUP_GLOBAL)\n       && (TYPE_GETS_NEW (type) & (1 << (code == VEC_NEW_EXPR))))\n     {\n-      tree dummy = build1 (NOP_EXPR, build_pointer_type (type),\n-\t\t\t   error_mark_node);\n-      dummy = build_indirect_ref (dummy, \"new\");\n-      return build_method_call (dummy, fnname, args, NULL_TREE, flags);\n+      return build_method_call (build_dummy_object (type),\n+\t\t\t\tfnname, args, NULL_TREE, flags);\n     }\n   else\n     return build_new_function_call \n@@ -3716,8 +3651,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n       && value_member (cand->fn, get_abstract_virtuals (basetype)))\n     cp_error (\"abstract virtual `%#D' called from constructor\", cand->fn);\n   if (TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE\n-      && TREE_CODE (instance_ptr) == NOP_EXPR\n-      && TREE_OPERAND (instance_ptr, 0) == error_mark_node)\n+      && is_dummy_object (instance_ptr))\n     cp_error (\"cannot call member function `%D' without object\", cand->fn);\n \n   if (DECL_VINDEX (cand->fn) && ! (flags & LOOKUP_NONVIRTUAL)"}, {"sha": "70a905f40865fa6601a6aed0dffe6857bf84a986", "filename": "gcc/cp/class.c", "status": "modified", "additions": 10, "deletions": 54, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=51924768e7b22cfc001c93ae562c4ce7c2af60ee", "patch": "@@ -5045,17 +5045,11 @@ instantiate_type (lhstype, rhs, complain)\n \t    if (function == error_mark_node)\n \t      return error_mark_node;\n \t    my_friendly_assert (TREE_CODE (function) == FUNCTION_DECL, 185);\n-\t    if (DECL_VINDEX (function))\n-\t      {\n-\t\ttree base = TREE_OPERAND (rhs, 0);\n-\t\ttree base_ptr = build_unary_op (ADDR_EXPR, base, 0);\n-\t\tif (base_ptr == error_mark_node)\n-\t\t  return error_mark_node;\n-\t\tbase_ptr = convert_pointer_to (DECL_CONTEXT (function), base_ptr);\n-\t\tif (base_ptr == error_mark_node)\n-\t\t  return error_mark_node;\n-\t\treturn build_vfn_ref (&base_ptr, base, DECL_VINDEX (function));\n-\t      }\n+\n+\t    if (! DECL_STATIC_FUNCTION_P (function))\n+\t      cp_error (\"reference to `%D' can only be used in a call\",\n+\t\t\tfunction);\n+\n \t    mark_used (function);\n \t    return function;\n \t  }\n@@ -5293,49 +5287,11 @@ instantiate_type (lhstype, rhs, complain)\n \t\telem = OVL_NEXT (elem);\n \t  }\n \n-\t/* No exact match found, look for a compatible method.  */\n-\tfor (baselink = rhs; baselink;\n-\t     baselink = next_baselink (baselink))\n-\t  {\n-\t    elem = TREE_VALUE (baselink);\n-\t    for (; elem; elem = OVL_NEXT (elem))\n-\t      if (comp_target_types (lhstype, \n-\t\t\t\t     TREE_TYPE (OVL_CURRENT (elem)), 1) > 0)\n-\t\tbreak;\n-\t    if (elem)\n-\t      {\n-\t\ttree save_elem = OVL_CURRENT (elem);\n-\t\tfor (elem = OVL_NEXT (elem); elem; elem = OVL_NEXT (elem))\n-\t\t  if (comp_target_types (lhstype, \n-\t\t\t\t\t TREE_TYPE (OVL_CURRENT (elem)), 0) > 0)\n-\t\t    break;\n-\t\tif (elem)\n-\t\t  {\n-\t\t    if (complain)\n-\t\t      error (\"ambiguous overload for overloaded method requested\");\n-\t\t    return error_mark_node;\n-\t\t  }\n-\t\tmark_used (save_elem);\n-\t\treturn save_elem;\n-\t      }\n-\t    name = rhs;\n-\t    while (TREE_CODE (name) == TREE_LIST)\n-\t      name = TREE_VALUE (name);\n-\t    name = DECL_NAME (OVL_CURRENT (name));\n-#if 0\n-\t    if (TREE_CODE (lhstype) == FUNCTION_TYPE && globals < 0)\n-\t      {\n-\t\t/* Try to instantiate from non-member functions.  */\n-\t\trhs = lookup_name_nonclass (name);\n-\t\tif (rhs && TREE_CODE (rhs) == TREE_LIST)\n-\t\t  {\n-\t\t    /* This code seems to be missing a `return'.  */\n-\t\t    my_friendly_abort (4);\n-\t\t    instantiate_type (lhstype, rhs, complain);\n-\t\t  }\n-\t      }\n-#endif\n-\t  }\n+\tname = rhs;\n+\twhile (TREE_CODE (name) == TREE_LIST)\n+\t  name = TREE_VALUE (name);\n+\tname = DECL_NAME (OVL_CURRENT (name));\n+\n \tif (complain)\n \t  cp_error (\"no compatible member functions named `%D'\", name);\n \treturn error_mark_node;"}, {"sha": "d49932750916fd618daa25d597f88642d06a8baf", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=51924768e7b22cfc001c93ae562c4ce7c2af60ee", "patch": "@@ -3084,6 +3084,9 @@ extern tree mapcar\t\t\t\tPROTO((tree, tree (*) (tree)));\n extern tree no_linkage_check\t\t\tPROTO((tree));\n extern void debug_binfo\t\t\t\tPROTO((tree));\n extern void push_expression_obstack\t\tPROTO((void));\n+extern tree build_dummy_object\t\t\tPROTO((tree));\n+extern tree maybe_dummy_object\t\t\tPROTO((tree, tree *));\n+extern int is_dummy_object\t\t\tPROTO((tree));\n #define scratchalloc expralloc\n #define scratch_tree_cons expr_tree_cons\n #define build_scratch_list build_expr_list"}, {"sha": "3058641fc106cb4dfe788701f5526ed4efd9ece1", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=51924768e7b22cfc001c93ae562c4ce7c2af60ee", "patch": "@@ -107,21 +107,8 @@ cp_convert_to_pointer (type, expr)\n \t functions.  */\n       if (TYPE_PTRMEMFUNC_P (intype))\n \t{\n-\t  tree decl, basebinfo;\n \t  tree fntype = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (intype));\n-\t  tree t = TYPE_METHOD_BASETYPE (fntype);\n-\n-\t  if (current_class_type == 0\n-\t      || get_base_distance (t, current_class_type, 0, &basebinfo)\n-\t      == -1)\n-\t    {\n-\t      decl = build1 (NOP_EXPR, t, error_mark_node);\n-\t    }\n-\t  else if (current_class_ptr == 0)\n-\t    decl = build1 (NOP_EXPR, t, error_mark_node);\n-\t  else\n-\t    decl = current_class_ref;\n-\n+\t  tree decl = maybe_dummy_object (TYPE_METHOD_BASETYPE (fntype), 0);\n \t  expr = build (OFFSET_REF, fntype, decl, expr);\n \t}\n "}, {"sha": "f0b3167ab27ab280e1484210365129f3a17c37ac", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=51924768e7b22cfc001c93ae562c4ce7c2af60ee", "patch": "@@ -4539,9 +4539,13 @@ arg_assoc (k, n)\n \n   if (TREE_CODE (n) == ADDR_EXPR)\n     n = TREE_OPERAND (n, 0);\n+  if (TREE_CODE (n) == COMPONENT_REF)\n+    n = TREE_OPERAND (n, 1);\n   while (TREE_CODE (n) == TREE_LIST)\n     n = TREE_VALUE (n);\n \n+  if (TREE_CODE (n) == FUNCTION_DECL)\n+    return arg_assoc_type (k, TREE_TYPE (n));\n   if (TREE_CODE (n) == TEMPLATE_ID_EXPR)\n     {\n       /* [basic.lookup.koenig]\n@@ -4604,7 +4608,7 @@ arg_assoc (k, n)\n       my_friendly_assert (TREE_CODE (n) == OVERLOAD, 980715);\n       \n       for (; n; n = OVL_CHAIN (n))\n-\tif (arg_assoc (k, OVL_FUNCTION (n)))\n+\tif (arg_assoc_type (k, TREE_TYPE (OVL_FUNCTION (n))))\n \t  return 1;\n     }\n "}, {"sha": "ba5243aefc2db204f08e4fe050bd44c86883aebe", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=51924768e7b22cfc001c93ae562c4ce7c2af60ee", "patch": "@@ -1577,8 +1577,7 @@ dump_expr (t, nop)\n     case OFFSET_REF:\n       {\n \ttree ob = TREE_OPERAND (t, 0);\n-\tif (TREE_CODE (ob) == NOP_EXPR\n-\t    && TREE_OPERAND (ob, 0) == error_mark_node)\n+\tif (is_dummy_object (ob))\n \t  {\n \t    if (TREE_CODE (TREE_OPERAND (t, 1)) == FUNCTION_DECL)\n \t      /* A::f */"}, {"sha": "47c83558d53a2cf07f06f391ad3c59323b855430", "filename": "gcc/cp/init.c", "status": "modified", "additions": 9, "deletions": 37, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=51924768e7b22cfc001c93ae562c4ce7c2af60ee", "patch": "@@ -1359,7 +1359,6 @@ build_member_call (type, name, parmlist)\n   tree t;\n   tree method_name;\n   int dtor = 0;\n-  int dont_use_this = 0;\n   tree basetype_path, decl;\n \n   if (TREE_CODE (name) == TEMPLATE_ID_EXPR\n@@ -1415,23 +1414,11 @@ build_member_call (type, name, parmlist)\n       return error_mark_node;\n     }\n \n-  /* No object?  Then just fake one up, and let build_method_call\n-     figure out what to do.  */\n-  if (current_class_type == 0\n-      || get_base_distance (type, current_class_type, 0, &basetype_path) == -1)\n-    dont_use_this = 1;\n+  decl = maybe_dummy_object (type, &basetype_path);\n \n-  if (dont_use_this)\n-    {\n-      basetype_path = TYPE_BINFO (type);\n-      decl = build1 (NOP_EXPR, build_pointer_type (type), error_mark_node);\n-    }\n-  else if (current_class_ptr == 0)\n-    {\n-      dont_use_this = 1;\n-      decl = build1 (NOP_EXPR, build_pointer_type (type), error_mark_node);\n-    }\n-  else\n+  /* Convert 'this' to the specified type to disambiguate conversion\n+     to the function's context.  */\n+  if (decl == current_class_ref)\n     {\n       tree olddecl = current_class_ptr;\n       tree oldtype = TREE_TYPE (TREE_TYPE (olddecl));\n@@ -1440,13 +1427,10 @@ build_member_call (type, name, parmlist)\n \t  tree newtype = build_type_variant (type, TYPE_READONLY (oldtype),\n \t\t\t\t\t     TYPE_VOLATILE (oldtype));\n \t  decl = convert_force (build_pointer_type (newtype), olddecl, 0);\n+\t  decl = build_indirect_ref (decl, NULL_PTR);\n \t}\n-      else\n-\tdecl = olddecl;\n     }\n \n-  decl = build_indirect_ref (decl, NULL_PTR);\n-\n   if (method_name == constructor_name (type)\n       || method_name == constructor_name_full (type))\n     return build_functional_cast (type, parmlist);\n@@ -1463,7 +1447,7 @@ build_member_call (type, name, parmlist)\n \treturn error_mark_node;\n       if (TREE_CODE (t) == FIELD_DECL)\n \t{\n-\t  if (dont_use_this)\n+\t  if (is_dummy_object (decl))\n \t    {\n \t      cp_error (\"invalid use of non-static field `%D'\", t);\n \t      return error_mark_node;\n@@ -1569,16 +1553,7 @@ build_offset_ref (type, name)\n       return error_mark_node;\n     }\n \n-  if (current_class_type == 0\n-      || get_base_distance (type, current_class_type, 0, &basebinfo) == -1)\n-    {\n-      basebinfo = TYPE_BINFO (type);\n-      decl = build1 (NOP_EXPR, type, error_mark_node);\n-    }\n-  else if (current_class_ptr == 0)\n-    decl = build1 (NOP_EXPR, type, error_mark_node);\n-  else\n-    decl = current_class_ref;\n+  decl = maybe_dummy_object (type, &basebinfo);\n \n   fnfields = lookup_fnfields (basebinfo, name, 1);\n   fields = lookup_field (basebinfo, name, 0, 0);\n@@ -1771,9 +1746,7 @@ resolve_offset_ref (exp)\n \n   /* The first case is really just a reference to a member of `this'.  */\n   if (TREE_CODE (member) == FIELD_DECL\n-      && (base == current_class_ref\n-\t  || (TREE_CODE (base) == NOP_EXPR\n-\t      && TREE_OPERAND (base, 0) == error_mark_node)))\n+      && (base == current_class_ref || is_dummy_object (base)))\n     {\n       tree basetype_path;\n       tree access;\n@@ -1815,8 +1788,7 @@ resolve_offset_ref (exp)\n     }\n \n   /* Ensure that we have an object.  */\n-  if (TREE_CODE (base) == NOP_EXPR\n-      && TREE_OPERAND (base, 0) == error_mark_node)\n+  if (is_dummy_object (base))\n     addr = error_mark_node;\n   else\n     /* If this is a reference to a member function, then return the"}, {"sha": "6d31ce4f268b26d4d3f55f3cc87f23cf927adcce", "filename": "gcc/cp/method.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=51924768e7b22cfc001c93ae562c4ce7c2af60ee", "patch": "@@ -1866,6 +1866,17 @@ hack_identifier (value, name)\n       TREE_USED (value) = 1;\n       value = build_component_ref (current_class_ref, name, NULL_TREE, 1);\n     }\n+  else if (TREE_CODE (value) == FUNCTION_DECL\n+\t   && DECL_FUNCTION_MEMBER_P (value))\n+    {\n+      tree decl;\n+\n+      if (IS_SIGNATURE (DECL_CLASS_CONTEXT (value)))\n+\treturn value;\n+\n+      decl = maybe_dummy_object (DECL_CLASS_CONTEXT (value), 0);\n+      value = build_component_ref (decl, name, NULL_TREE, 1);\n+    }\n   else if (really_overloaded_fn (value))\n     {\n #if 0"}, {"sha": "11c89df5c165e66452ebbc3711d619d8a7474360", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=51924768e7b22cfc001c93ae562c4ce7c2af60ee", "patch": "@@ -5596,6 +5596,8 @@ tsubst (t, args, in_decl)\n \t\t  return arg;\n \t      }\n \t  }\n+\telse\n+\t  my_friendly_abort (981018);\n \n \tif (level == 1)\n \t  /* This can happen during the attempted tsubst'ing in\n@@ -5990,6 +5992,7 @@ tsubst_copy (t, args, in_decl)\n     case CONST_CAST_EXPR:\n     case STATIC_CAST_EXPR:\n     case DYNAMIC_CAST_EXPR:\n+    case NOP_EXPR:\n       return build1\n \t(code, tsubst (TREE_TYPE (t), args, in_decl),\n \t tsubst_copy (TREE_OPERAND (t, 0), args, in_decl));"}, {"sha": "b943b834f4a89653849f9ff4ee08ab73d23ea62e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=51924768e7b22cfc001c93ae562c4ce7c2af60ee", "patch": "@@ -2629,3 +2629,56 @@ member_p (decl)\n   tree ctx = DECL_CONTEXT (decl);\n   return (ctx && TREE_CODE_CLASS (TREE_CODE (ctx)) == 't');\n }\n+\n+/* Create a placeholder for member access where we don't actually have an\n+   object that the access is against.  */\n+\n+tree\n+build_dummy_object (type)\n+     tree type;\n+{\n+  tree decl = build1 (NOP_EXPR, build_pointer_type (type), error_mark_node);\n+  return build_indirect_ref (decl, NULL_PTR);\n+}\n+\n+/* We've gotten a reference to a member of TYPE.  Return *this if appropriate,\n+   or a dummy object otherwise.  If BINFOP is non-0, it is filled with the\n+   binfo path from current_class_type to TYPE, or 0.  */\n+\n+tree\n+maybe_dummy_object (type, binfop)\n+     tree type;\n+     tree *binfop;\n+{\n+  tree decl, context;\n+\n+  if (current_class_type\n+      && get_base_distance (type, current_class_type, 0, binfop) != -1)\n+    context = current_class_type;\n+  else\n+    {\n+      /* Reference from a nested class member function.  */\n+      context = type;\n+      if (binfop)\n+\t*binfop = TYPE_BINFO (type);\n+    }\n+\n+  if (current_class_ref && context == current_class_type)\n+    decl = current_class_ref;\n+  else\n+    decl = build_dummy_object (context);\n+\n+  return decl;\n+}\n+\n+/* Returns 1 if OB is a placeholder object, or a pointer to one.  */\n+\n+int\n+is_dummy_object (ob)\n+     tree ob;\n+{\n+  if (TREE_CODE (ob) == INDIRECT_REF)\n+    ob = TREE_OPERAND (ob, 0);\n+  return (TREE_CODE (ob) == NOP_EXPR\n+\t  && TREE_OPERAND (ob, 0) == error_mark_node);\n+}"}, {"sha": "5cd21f1509028b33628d66d352ce232d34ae1dc5", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 25, "deletions": 74, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=51924768e7b22cfc001c93ae562c4ce7c2af60ee", "patch": "@@ -2078,57 +2078,27 @@ build_component_ref (datum, component, basetype_path, protect)\n \t    return error_mark_node;\n \t  if (fndecls)\n \t    {\n+\t      /* If the function is unique and static, we can resolve it\n+\t\t now.  Otherwise, we have to wait and see what context it is\n+\t\t used in; a component_ref involving a non-static member\n+\t\t function can only be used in a call (expr.ref).  */\n \t      if (TREE_CHAIN (fndecls) == NULL_TREE\n-\t\t  && TREE_CODE (TREE_VALUE (fndecls)) != OVERLOAD)\n+\t\t  && TREE_CODE (TREE_VALUE (fndecls)) == FUNCTION_DECL\n+\t\t  && DECL_STATIC_FUNCTION_P (TREE_VALUE (fndecls)))\n \t\t{\n-\t\t  tree access, fndecl;\n+\t\t  tree fndecl;\n \n-\t\t  /* Unique, so use this one now.  */\n \t\t  basetype = TYPE_MAIN_VARIANT (TREE_PURPOSE (fndecls));\n \t\t  fndecl = TREE_VALUE (fndecls);\n-\t\t  access = compute_access (TREE_PURPOSE (fndecls), fndecl);\n-\t\t  if (access == access_public_node)\n-\t\t    {\n-\t\t      if (DECL_VINDEX (fndecl)\n-\t\t\t  && ! resolves_to_fixed_type_p (datum, 0))\n-\t\t\t{\n-\t\t\t  tree addr = build_unary_op (ADDR_EXPR, datum, 0);\n-\t\t\t  tree fntype = TREE_TYPE (fndecl);\n-\n-\t\t\t  addr = convert_pointer_to (DECL_CONTEXT (fndecl),\n-\t\t\t\t\t\t     addr);\n-\t\t\t  datum = build_indirect_ref (addr, NULL_PTR);\n-\t\t\t  my_friendly_assert (datum != error_mark_node, 310);\n-\t\t\t  fndecl = build_vfn_ref (&addr, datum,\n-\t\t\t\t\t\t  DECL_VINDEX (fndecl));\n-\t\t\t  /* The type of fndecl is a function type,\n-\t\t\t     not a pointer-to-function type, since\n-\t\t\t     build_vfn_ref returns not the correct\n-\t\t\t     vtable slot, but the indirection of the\n-\t\t\t     correct vtable slot.  */\n-\t\t\t  TREE_TYPE (fndecl) = fntype;\n-\t\t\t}\n-\t\t      else\n-\t\t\tmark_used (fndecl);\n-\t\t      return build (OFFSET_REF, TREE_TYPE (fndecl),\n-\t\t\t\t    datum, fndecl);\n-\t\t    }\n-\t\t  if (access == access_protected_node)\n-\t\t    cp_error (\"member function `%D' is protected\", fndecl);\n-\t\t  else\n-\t\t    cp_error (\"member function `%D' is private\", fndecl);\n-\t\t  return error_mark_node;\n+\t\t  enforce_access (TREE_PURPOSE (fndecls), fndecl);\n+\t\t  mark_used (fndecl);\n+\t\t  return fndecl;\n \t\t}\n \t      else\n \t\t{\n-\t\t  /* Just act like build_offset_ref, since the object does\n-                     not matter unless we're actually calling the function.  */\n-\t\t  tree t;\n-\n-\t\t  t = build_tree_list (error_mark_node, fndecls);\n-\t\t  TREE_TYPE (t) = build_offset_type (basetype,\n-\t\t\t\t\t\t     unknown_type_node);\n-\t\t  return t;\n+\t\t  ref = build (COMPONENT_REF, unknown_type_node,\n+\t\t\t       datum, fndecls);\n+\t\t  return ref;\n \t\t}\n \t    }\n \n@@ -2622,9 +2592,7 @@ build_x_function_call (function, params, decl)\n \t      return error_mark_node;\n \t    }\n \t  /* Yow: call from a static member function.  */\n-\t  decl = build1 (NOP_EXPR, build_pointer_type (current_class_type),\n-\t\t\t error_mark_node);\n-\t  decl = build_indirect_ref (decl, NULL_PTR);\n+\t  decl = build_dummy_object (current_class_type);\n \t}\n \n       /* Put back explicit template arguments, if any.  */\n@@ -2636,12 +2604,10 @@ build_x_function_call (function, params, decl)\n   else if (TREE_CODE (function) == COMPONENT_REF\n \t   && type == unknown_type_node)\n     {\n-      /* Should we undo what was done in build_component_ref? */\n-      if (TREE_CODE (TREE_PURPOSE (TREE_OPERAND (function, 1))) == TREE_VEC)\n-\t/* Get the name that build_component_ref hid.  */\n-\tfunction = DECL_NAME (TREE_VALUE (TREE_OPERAND (function, 1)));\n-      else\n-\tfunction = TREE_PURPOSE (TREE_OPERAND (function, 1));\n+      /* Undo what we did in build_component_ref.  */\n+      decl = TREE_OPERAND (function, 0);\n+      function = TREE_OPERAND (function, 1);\n+      function = DECL_NAME (OVL_CURRENT (TREE_VALUE (function)));\n       return build_method_call (decl, function, params,\n \t\t\t\tNULL_TREE, LOOKUP_NORMAL);\n     }\n@@ -4248,6 +4214,8 @@ build_component_addr (arg, argtype, msg)\n   tree basetype = decl_type_context (field);\n   tree rval = build_unary_op (ADDR_EXPR, TREE_OPERAND (arg, 0), 0);\n \n+  my_friendly_assert (TREE_CODE (field) == FIELD_DECL, 981018);\n+\n   if (DECL_C_BIT_FIELD (field))\n     {\n       error (msg, IDENTIFIER_POINTER (DECL_NAME (field)));\n@@ -4665,24 +4633,7 @@ build_unary_op (code, xarg, noconvert)\n \t  return build1 (ADDR_EXPR, unknown_type_node, arg);\n \t}\n \n-      if (TREE_CODE (arg) == OVERLOAD \n-\t  || (TREE_CODE (arg) == OFFSET_REF\n-\t      && TREE_CODE (TREE_OPERAND (arg, 1)) == TEMPLATE_ID_EXPR))\n-\treturn build1 (ADDR_EXPR, unknown_type_node, arg);\n-      else if (TREE_CODE (arg) == TREE_LIST)\n-\t{\n-\t  if (TREE_CODE (TREE_VALUE (arg)) == FUNCTION_DECL)\n-\t    /* Unique overloaded non-member function.  */\n-\t    return build_unary_op (ADDR_EXPR, TREE_VALUE (arg), 0);\n-\t  if (TREE_CHAIN (arg) == NULL_TREE\n-\t      && TREE_CODE (TREE_VALUE (arg)) == TREE_LIST\n-\t      && TREE_CODE (TREE_VALUE (TREE_VALUE (arg))) != OVERLOAD)\n-\t    /* Unique overloaded member function.  */\n-\t    return build_unary_op (ADDR_EXPR, TREE_VALUE (TREE_VALUE (arg)),\n-\t\t\t\t   0);\n-\t  return build1 (ADDR_EXPR, unknown_type_node, arg);\n-\t}\n-      else if (TREE_CODE (arg) == TEMPLATE_ID_EXPR)\n+      if (TREE_CODE (arg) == TEMPLATE_ID_EXPR)\n \t{\n \t  tree targs;\n \t  tree fn;\n@@ -4705,6 +4656,8 @@ build_unary_op (code, xarg, noconvert)\n \n \t  return build1 (ADDR_EXPR, unknown_type_node, arg);\n \t}\n+      else if (type_unknown_p (arg))\n+\treturn build1 (ADDR_EXPR, unknown_type_node, arg);\n \n       /* Handle complex lvalues (when permitted)\n \t by reduction to simpler cases.  */\n@@ -4890,9 +4843,7 @@ unary_complex_lvalue (code, arg)\n \t  tree type;\n \n \t  if (TREE_OPERAND (arg, 0)\n-\t      && (TREE_CODE (TREE_OPERAND (arg, 0)) != NOP_EXPR\n-\t\t  || (TREE_OPERAND (TREE_OPERAND (arg, 0), 0)\n-\t\t      != error_mark_node))\n+\t      && ! is_dummy_object (TREE_OPERAND (arg, 0))\n \t      && TREE_CODE (t) != FIELD_DECL)\n \t    {\n \t      cp_error (\"taking address of bound pointer-to-member expression\");\n@@ -5770,7 +5721,7 @@ build_c_cast (type, expr)\n   if (TREE_CODE (type) == VOID_TYPE)\n     value = build1 (CONVERT_EXPR, type, value);\n   else if (TREE_TYPE (value) == NULL_TREE\n-      || type_unknown_p (value))\n+\t   || type_unknown_p (value))\n     {\n       value = instantiate_type (type, value, 1);\n       /* Did we lose?  */"}, {"sha": "809b89d589ee8d020d46640040f7e655482d8c9a", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51924768e7b22cfc001c93ae562c4ce7c2af60ee/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=51924768e7b22cfc001c93ae562c4ce7c2af60ee", "patch": "@@ -352,19 +352,14 @@ ack (s, v, v2)\n    59 is, so they can understand how to work around it, should they\n    ever run into it.\n \n-   Note, there will be no more calls in the C++ front end to abort,\n-   because the C++ front end is so unreliable still.  The C front end\n-   can get away with calling abort, because for most of the calls to\n-   abort on most machines, it, I suspect, can be proven that it is\n-   impossible to ever call abort.  The same is not yet true for C++,\n-   one day, maybe it will be.\n-\n    We used to tell people to \"fix the above error[s] and try recompiling\n    the program\" via a call to fatal, but that message tended to look\n    silly.  So instead, we just do the equivalent of a call to fatal in the\n-   same situation (call exit).  */\n+   same situation (call exit).\n \n-/* First used: 0 (reserved), Last used: 369.  Free: */\n+   We used to assign sequential numbers for the aborts; now we use an\n+   encoding of the date the abort was added, since that has more meaning\n+   when we only see the error message.  */\n \n static int abortcount = 0;\n "}]}