{"sha": "f7e52577137bb5d0e7501475eab47331a41fac67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdlNTI1NzcxMzdiYjVkMGU3NTAxNDc1ZWFiNDczMzFhNDFmYWM2Nw==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2007-04-03T08:32:31Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2007-04-03T08:32:31Z"}, "message": "re PR libstdc++/31440 (libstdc++-g++-v3 discarded qualifiers)\n\n2007-04-03  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/31440\n\t* include/bits/stl_tree.h (_M_lower_bound(_Link_type, _Link_type,\n\tconst _Key&), _M_upper_bound(_Link_type, _Link_type, const _Key&)):\n\tAdd.\n\t(_M_equal_range(const _Key&) const): Remove.\n\t(lower_bound(const key_type&), lower_bound(const key_type&) const,\n\tupper_bound(const key_type&), upper_bound(const key_type&) const,\n\tequal_range(const key_type&), equal_range(const key_type&) const):\n\tAdjust.\n\t(find(const _Key&), find(const _Key&) const): Tweak.\n\t* testsuite/23_containers/map/operations/31440.cc: New.\n\nFrom-SVN: r123452", "tree": {"sha": "289abca05a130c779f1723ddf73de9859252d39f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/289abca05a130c779f1723ddf73de9859252d39f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7e52577137bb5d0e7501475eab47331a41fac67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7e52577137bb5d0e7501475eab47331a41fac67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7e52577137bb5d0e7501475eab47331a41fac67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7e52577137bb5d0e7501475eab47331a41fac67/comments", "author": null, "committer": null, "parents": [{"sha": "5be527d081efb7c875ac3d1ae4df66c6e9388a81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5be527d081efb7c875ac3d1ae4df66c6e9388a81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5be527d081efb7c875ac3d1ae4df66c6e9388a81"}], "stats": {"total": 198, "additions": 172, "deletions": 26}, "files": [{"sha": "9a25a519eb1a7d0971ed133ea1661f6b04650415", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e52577137bb5d0e7501475eab47331a41fac67/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e52577137bb5d0e7501475eab47331a41fac67/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f7e52577137bb5d0e7501475eab47331a41fac67", "patch": "@@ -1,3 +1,17 @@\n+2007-04-03  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/31440\n+\t* include/bits/stl_tree.h (_M_lower_bound(_Link_type, _Link_type,\n+\tconst _Key&), _M_upper_bound(_Link_type, _Link_type, const _Key&)):\n+\tAdd.\n+\t(_M_equal_range(const _Key&) const): Remove.\n+\t(lower_bound(const key_type&), lower_bound(const key_type&) const,\n+\tupper_bound(const key_type&), upper_bound(const key_type&) const,\n+\tequal_range(const key_type&), equal_range(const key_type&) const):\n+\tAdjust.\n+\t(find(const _Key&), find(const _Key&) const): Tweak.\n+\t* testsuite/23_containers/map/operations/31440.cc: New.\n+\n 2007-04-02  Matthew Levine  <gcc@severeweblint.org>\n \t    Paolo Carlini  <pcarlini@suse.de>\n "}, {"sha": "c0ecddc8f52911ba6d86e7519e16d638f2e30675", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 97, "deletions": 26, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e52577137bb5d0e7501475eab47331a41fac67/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e52577137bb5d0e7501475eab47331a41fac67/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=f7e52577137bb5d0e7501475eab47331a41fac67", "patch": "@@ -554,16 +554,21 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       _M_erase(_Link_type __x);\n \n       iterator\n+      _M_lower_bound(_Link_type __x, _Link_type __y,\n+\t\t     const _Key& __k);\n+\n+      const_iterator\n       _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,\n \t\t     const _Key& __k) const;\n \n       iterator\n+      _M_upper_bound(_Link_type __x, _Link_type __y,\n+\t\t     const _Key& __k);\n+\n+      const_iterator\n       _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,\n \t\t     const _Key& __k) const;\n \n-      pair<iterator, iterator>\n-      _M_equal_range(const _Key& __k) const;\n-\n     public:\n       // allocation/deallocation\n       _Rb_tree()\n@@ -717,27 +722,25 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n       iterator\n       lower_bound(const key_type& __k)\n-      { return iterator(_M_lower_bound(_M_begin(), _M_end(), __k)); }\n+      { return _M_lower_bound(_M_begin(), _M_end(), __k); }\n \n       const_iterator\n       lower_bound(const key_type& __k) const\n-      { return const_iterator(_M_lower_bound(_M_begin(), _M_end(), __k)); }\n+      { return _M_lower_bound(_M_begin(), _M_end(), __k); }\n \n       iterator\n       upper_bound(const key_type& __k)\n-      { return iterator(_M_upper_bound(_M_begin(), _M_end(), __k)); }\n+      { return _M_upper_bound(_M_begin(), _M_end(), __k); }\n \n       const_iterator\n       upper_bound(const key_type& __k) const\n-      { return const_iterator(_M_upper_bound(_M_begin(), _M_end(), __k)); }\n+      { return _M_upper_bound(_M_begin(), _M_end(), __k); }\n \n       pair<iterator, iterator>\n-      equal_range(const key_type& __k)\n-      { return pair<iterator, iterator>(_M_equal_range(__k)); }\n+      equal_range(const key_type& __k);\n \n       pair<const_iterator, const_iterator>\n-      equal_range(const key_type& __k) const\n-      { return pair<const_iterator, const_iterator>(_M_equal_range(__k)); }\n+      equal_range(const key_type& __k) const;\n \n       // Debugging.\n       bool\n@@ -929,7 +932,24 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t      _Compare, _Alloc>::iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    _M_lower_bound(_Link_type __x, _Link_type __y,\n+\t\t   const _Key& __k)\n+    {\n+      while (__x != 0)\n+\tif (!_M_impl._M_key_compare(_S_key(__x), __k))\n+\t  __y = __x, __x = _S_left(__x);\n+\telse\n+\t  __x = _S_right(__x);\n+      return iterator(__y);\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t      _Compare, _Alloc>::const_iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,\n \t\t   const _Key& __k) const\n@@ -939,12 +959,29 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t  __y = __x, __x = _S_left(__x);\n \telse\n \t  __x = _S_right(__x);\n-      return iterator(const_cast<_Link_type>(__y));\n+      return const_iterator(__y);\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t      _Compare, _Alloc>::iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    _M_upper_bound(_Link_type __x, _Link_type __y,\n+\t\t   const _Key& __k)\n+    {\n+      while (__x != 0)\n+\tif (_M_impl._M_key_compare(__k, _S_key(__x)))\n+\t  __y = __x, __x = _S_left(__x);\n+\telse\n+\t  __x = _S_right(__x);\n+      return iterator(__y);\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t      _Compare, _Alloc>::const_iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,\n \t\t   const _Key& __k) const\n@@ -954,16 +991,48 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t  __y = __x, __x = _S_left(__x);\n \telse\n \t  __x = _S_right(__x);\n-      return iterator(const_cast<_Link_type>(__y));\n+      return const_iterator(__y);\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n \t\t\t   _Compare, _Alloc>::iterator,\n-\t typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator>\n+\t typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t\t   _Compare, _Alloc>::iterator>\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    equal_range(const _Key& __k)\n+    {\n+      _Link_type __x = _M_begin();\n+      _Link_type __y = _M_end();\n+      while (__x != 0)\n+\t{\n+\t  if (_M_impl._M_key_compare(_S_key(__x), __k))\n+\t    __x = _S_right(__x);\n+\t  else if (_M_impl._M_key_compare(__k, _S_key(__x)))\n+\t    __y = __x, __x = _S_left(__x);\n+\t  else\n+\t    {\n+\t      _Link_type __xu(__x), __yu(__y);\n+\t      __y = __x, __x = _S_left(__x);\n+\t      __xu = _S_right(__xu);\n+\t      return pair<iterator,\n+\t\t          iterator>(_M_lower_bound(__x, __y, __k),\n+\t\t\t\t    _M_upper_bound(__xu, __yu, __k));\n+\t    }\n+\t}\n+      return pair<iterator, iterator>(iterator(__y),\n+\t\t\t\t      iterator(__y));\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t\t   _Compare, _Alloc>::const_iterator,\n+\t typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t\t   _Compare, _Alloc>::const_iterator>\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-    _M_equal_range(const _Key& __k) const\n+    equal_range(const _Key& __k) const\n     {\n       _Const_Link_type __x = _M_begin();\n       _Const_Link_type __y = _M_end();\n@@ -978,12 +1047,13 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t      _Const_Link_type __xu(__x), __yu(__y);\n \t      __y = __x, __x = _S_left(__x);\n \t      __xu = _S_right(__xu);\n-\t      return pair<iterator, iterator>(_M_lower_bound(__x, __y, __k),\n-\t\t\t\t\t      _M_upper_bound(__xu, __yu, __k));\t  \n+\t      return pair<const_iterator,\n+\t\t          const_iterator>(_M_lower_bound(__x, __y, __k),\n+\t\t\t\t\t  _M_upper_bound(__xu, __yu, __k));\n \t    }\n \t}\n-      return pair<iterator, iterator>(iterator(const_cast<_Link_type>(__y)),\n-\t\t\t\t      iterator(const_cast<_Link_type>(__y)));\n+      return pair<const_iterator, const_iterator>(const_iterator(__y),\n+\t\t\t\t\t\t  const_iterator(__y));\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -1295,24 +1365,25 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t      _Compare, _Alloc>::iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     find(const _Key& __k)\n     {\n-      iterator __j = iterator(_M_lower_bound(_M_begin(), _M_end(), __k));\n+      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);\n       return (__j == end()\n \t      || _M_impl._M_key_compare(__k,\n \t\t\t\t\t_S_key(__j._M_node))) ? end() : __j;\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t      _Compare, _Alloc>::const_iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     find(const _Key& __k) const\n     {\n-      const_iterator __j = const_iterator(_M_lower_bound(_M_begin(),\n-\t\t\t\t\t\t\t _M_end(), __k));\n+      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);\n       return (__j == end()\n \t      || _M_impl._M_key_compare(__k, \n \t\t\t\t\t_S_key(__j._M_node))) ? end() : __j;"}, {"sha": "54ca6146e2dfe35b692aa42dd7d68f8d69eefa97", "filename": "libstdc++-v3/testsuite/23_containers/map/operations/31440.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e52577137bb5d0e7501475eab47331a41fac67/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperations%2F31440.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e52577137bb5d0e7501475eab47331a41fac67/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperations%2F31440.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperations%2F31440.cc?ref=f7e52577137bb5d0e7501475eab47331a41fac67", "patch": "@@ -0,0 +1,61 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <map>\n+\n+// libstdc++/31440\n+struct DagNode\n+{ };\n+\n+class MemoTable\n+{\n+public:\n+  void memoRewrite();\n+\n+private:\n+  struct dagNodeLt;\n+  class MemoMap;\n+\n+  MemoMap* memoMap;\n+};\n+\n+struct MemoTable::dagNodeLt\n+{\n+  bool operator()(const DagNode*, const DagNode*);\n+};\n+\n+class MemoTable::MemoMap\n+: public std::map<DagNode*, DagNode*, MemoTable::dagNodeLt>\n+{ };\n+\n+void\n+MemoTable::memoRewrite()\n+{\n+  memoMap->find(0);\n+}"}]}