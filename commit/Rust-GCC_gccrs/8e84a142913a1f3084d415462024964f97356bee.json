{"sha": "8e84a142913a1f3084d415462024964f97356bee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU4NGExNDI5MTNhMWYzMDg0ZDQxNTQ2MjAyNDk2NGY5NzM1NmJlZQ==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-04-14T07:29:10Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-04-08T13:30:47Z"}, "message": "d: Update language attribute support, and implement gcc.attributes\n\nD attribute support has been updated to have a baseline parity with the\nLLVM D compiler's own `ldc.attributes'.\n\nThe handler that extracts GCC attributes from a list of UDAs has been\nimproved to take care of some mistakes that could have been warnings.\nUDAs attached to field variables are also now processed for any GCC\nattributes attached to them.\n\nThe following new attributes have been added to the D front-end:\n\n - @attribute(\"alloc_size\")\n - @attribute(\"used\")\n - @attribute(\"optimize\")\n - @attribute(\"restrict\")\n - @attribute(\"cold\")\n - @attribute(\"noplt\")\n - @attribute(\"target_clones\")\n - @attribute(\"no_icf\")\n - @attribute(\"noipa\")\n - @attribute(\"symver\")\n\nWith convenience aliases in a new `gcc.attributes' module to match\nthe same naming convention as `ldc.attributes':\n\n - @allocSize()\n - @assumeUsed\n - @fastmath\n - @naked\n - @restrict\n - @cold\n - @noplt\n - @optStrategy()\n - @polly\n - @section()\n - @target()\n - @weak\n\nThe old gcc.attribute module has been deprecated, along with the removal\nof the following attribute handlers:\n\n - @attribute(\"alias\"): Has been superseded by `pragma(mangle)'.\n - @attribute(\"forceinline\"): Renamed to always_inline.\n\ngcc/d/ChangeLog:\n\n\t* d-attribs.cc: Include fold-const.h and opts.h.\n\t(attr_noreturn_exclusions): Add alloc_size.\n\t(attr_const_pure_exclusions): Likewise.\n\t(attr_inline_exclusions): Add target_clones.\n\t(attr_noinline_exclusions): Rename forceinline to always_inline.\n\t(attr_target_exclusions): New array.\n\t(attr_target_clones_exclusions): New array.\n\t(attr_alloc_exclusions): New array.\n\t(attr_cold_hot_exclusions): New array.\n\t(d_langhook_common_attribute_table): Add new D attribute handlers.\n\t(build_attributes): Update to look for gcc.attributes.  Issue warning\n\tif not given a struct literal.  Handle void initialized arguments.\n\t(handle_always_inline_attribute): Remove function.\n\t(d_handle_noinline_attribute): Don't extract TYPE_LANG_FRONTEND.\n\t(d_handle_forceinline_attribute): Rename to...\n\t(d_handle_always_inline_attribute): ...this.  Remove special handling.\n\t(d_handle_flatten_attribute): Don't extract TYPE_LANG_FRONTEND.\n\t(d_handle_target_attribute): Likewise.  Warn about empty arguments.\n\t(d_handle_target_clones_attribute): New function.\n\t(optimize_args): New static variable.\n\t(parse_optimize_options): New function.\n\t(d_handle_optimize_attribute): New function.\n\t(d_handle_noclone_attribute): Don't extract TYPE_LANG_FRONTEND.\n\t(d_handle_alias_attribute): Remove function.\n\t(d_handle_noicf_attribute): New function.\n\t(d_handle_noipa_attribute): New function.\n\t(d_handle_section_attribute): Call the handle_generic_attribute target\n\thook after performing target independent processing.\n\t(d_handle_symver_attribute): New function.\n\t(d_handle_noplt_attribute): New function.\n\t(positional_argument): New function.\n\t(d_handle_alloc_size_attribute): New function.\n\t(d_handle_cold_attribute): New function.\n\t(d_handle_restrict_attribute): New function.\n\t(d_handle_used_attribute): New function.\n\t* decl.cc (gcc_attribute_p): Update to look for gcc.attributes.\n\t(get_symbol_decl): Update decl source location of old prototypes to\n\tthe new declaration being merged.\n\t* types.cc (layout_aggregate_members): Apply user defined attributes\n\ton fields.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/Makefile.am (DRUNTIME_DSOURCES): Add\n\t  gcc/attributes.d.\n\t* libdruntime/Makefile.in: Regenerate.\n\t* libdruntime/gcc/attribute.d: Deprecate module, publicly import\n\tgcc.attributes.\n\t* libdruntime/gcc/deh.d: Update imports.\n\t* libdruntime/gcc/attributes.d: New file.\n\ngcc/testsuite/ChangeLog:\n\n\t* gdc.dg/gdc108.d: Update test.\n\t* gdc.dg/gdc142.d: Likewise.\n\t* gdc.dg/pr90136a.d: Likewise.\n\t* gdc.dg/pr90136b.d: Likewise.\n\t* gdc.dg/pr90136c.d: Likewise.\n\t* gdc.dg/pr95173.d: Likewise.\n\t* gdc.dg/attr_allocsize1.d: New test.\n\t* gdc.dg/attr_allocsize2.d: New test.\n\t* gdc.dg/attr_alwaysinline1.d: New test.\n\t* gdc.dg/attr_cold1.d: New test.\n\t* gdc.dg/attr_exclusions1.d: New test.\n\t* gdc.dg/attr_exclusions2.d: New test.\n\t* gdc.dg/attr_flatten1.d: New test.\n\t* gdc.dg/attr_module.d: New test.\n\t* gdc.dg/attr_noclone1.d: New test.\n\t* gdc.dg/attr_noicf1.d: New test.\n\t* gdc.dg/attr_noinline1.d: New test.\n\t* gdc.dg/attr_noipa1.d: New test.\n\t* gdc.dg/attr_noplt1.d: New test.\n\t* gdc.dg/attr_optimize1.d: New test.\n\t* gdc.dg/attr_optimize2.d: New test.\n\t* gdc.dg/attr_optimize3.d: New test.\n\t* gdc.dg/attr_optimize4.d: New test.\n\t* gdc.dg/attr_restrict1.d: New test.\n\t* gdc.dg/attr_section1.d: New test.\n\t* gdc.dg/attr_symver1.d: New test.\n\t* gdc.dg/attr_target1.d: New test.\n\t* gdc.dg/attr_targetclones1.d: New test.\n\t* gdc.dg/attr_used1.d: New test.\n\t* gdc.dg/attr_used2.d: New test.\n\t* gdc.dg/attr_weak1.d: New test.\n\t* gdc.dg/imports/attributes.d: New test.", "tree": {"sha": "67a8e38717a38cc3572382c90fc9a1773bc1c84a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67a8e38717a38cc3572382c90fc9a1773bc1c84a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e84a142913a1f3084d415462024964f97356bee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e84a142913a1f3084d415462024964f97356bee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e84a142913a1f3084d415462024964f97356bee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e84a142913a1f3084d415462024964f97356bee/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "855ce475883c7a52112b9c110f998a49dd69caab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/855ce475883c7a52112b9c110f998a49dd69caab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/855ce475883c7a52112b9c110f998a49dd69caab"}], "stats": {"total": 2070, "additions": 1900, "deletions": 170}, "files": [{"sha": "070866020a2c979220930323f6cb13b6cce6351b", "filename": "gcc/d/d-attribs.cc", "status": "modified", "additions": 695, "deletions": 140, "changes": 835, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Fd%2Fd-attribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Fd%2Fd-attribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-attribs.cc?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -24,7 +24,9 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"dmd/attrib.h\"\n #include \"dmd/declaration.h\"\n+#include \"dmd/module.h\"\n #include \"dmd/mtype.h\"\n+#include \"dmd/template.h\"\n \n #include \"tree.h\"\n #include \"diagnostic.h\"\n@@ -36,6 +38,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"varasm.h\"\n+#include \"fold-const.h\"\n+#include \"opts.h\"\n \n #include \"d-tree.h\"\n \n@@ -53,17 +57,25 @@ static tree handle_type_generic_attribute (tree *, tree, tree, int, bool *);\n static tree handle_transaction_pure_attribute (tree *, tree, tree, int, bool *);\n static tree handle_returns_twice_attribute (tree *, tree, tree, int, bool *);\n static tree handle_fnspec_attribute (tree *, tree, tree, int, bool *);\n-static tree handle_always_inline_attribute (tree *, tree, tree, int, bool *);\n \n /* D attribute handlers for user defined attributes.  */\n static tree d_handle_noinline_attribute (tree *, tree, tree, int, bool *);\n-static tree d_handle_forceinline_attribute (tree *, tree, tree, int, bool *);\n+static tree d_handle_always_inline_attribute (tree *, tree, tree, int, bool *);\n static tree d_handle_flatten_attribute (tree *, tree, tree, int, bool *);\n static tree d_handle_target_attribute (tree *, tree, tree, int, bool *);\n+static tree d_handle_target_clones_attribute (tree *, tree, tree, int, bool *);\n+static tree d_handle_optimize_attribute (tree *, tree, tree, int, bool *);\n static tree d_handle_noclone_attribute (tree *, tree, tree, int, bool *);\n+static tree d_handle_noicf_attribute (tree *, tree, tree, int, bool *);\n+static tree d_handle_noipa_attribute (tree *, tree, tree, int, bool *);\n static tree d_handle_section_attribute (tree *, tree, tree, int, bool *);\n-static tree d_handle_alias_attribute (tree *, tree, tree, int, bool *);\n+static tree d_handle_symver_attribute (tree *, tree, tree, int, bool *);\n static tree d_handle_weak_attribute (tree *, tree, tree, int, bool *) ;\n+static tree d_handle_noplt_attribute (tree *, tree, tree, int, bool *) ;\n+static tree d_handle_alloc_size_attribute (tree *, tree, tree, int, bool *);\n+static tree d_handle_cold_attribute (tree *, tree, tree, int, bool *);\n+static tree d_handle_restrict_attribute (tree *, tree, tree, int, bool *);\n+static tree d_handle_used_attribute (tree *, tree, tree, int, bool *);\n \n /* Helper to define attribute exclusions.  */\n #define ATTR_EXCL(name, function, type, variable)\t\\\n@@ -72,6 +84,7 @@ static tree d_handle_weak_attribute (tree *, tree, tree, int, bool *) ;\n /* Define attributes that are mutually exclusive with one another.  */\n static const struct attribute_spec::exclusions attr_noreturn_exclusions[] =\n {\n+  ATTR_EXCL (\"alloc_size\", true, true, true),\n   ATTR_EXCL (\"const\", true, true, true),\n   ATTR_EXCL (\"malloc\", true, true, true),\n   ATTR_EXCL (\"pure\", true, true, true),\n@@ -87,6 +100,7 @@ static const struct attribute_spec::exclusions attr_returns_twice_exclusions[] =\n \n static const struct attribute_spec::exclusions attr_const_pure_exclusions[] =\n {\n+  ATTR_EXCL (\"alloc_size\", true, true, true),\n   ATTR_EXCL (\"const\", true, true, true),\n   ATTR_EXCL (\"noreturn\", true, true, true),\n   ATTR_EXCL (\"pure\", true, true, true),\n@@ -96,15 +110,44 @@ static const struct attribute_spec::exclusions attr_const_pure_exclusions[] =\n static const struct attribute_spec::exclusions attr_inline_exclusions[] =\n {\n   ATTR_EXCL (\"noinline\", true, true, true),\n+  ATTR_EXCL (\"target_clones\", true, true, true),\n   ATTR_EXCL (NULL, false, false, false),\n };\n \n static const struct attribute_spec::exclusions attr_noinline_exclusions[] =\n {\n-  ATTR_EXCL (\"forceinline\", true, true, true),\n+  ATTR_EXCL (\"always_inline\", true, true, true),\n   ATTR_EXCL (NULL, false, false, false),\n };\n \n+static const struct attribute_spec::exclusions attr_target_exclusions[] =\n+{\n+  ATTR_EXCL (\"target_clones\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false),\n+};\n+\n+static const struct attribute_spec::exclusions attr_target_clones_exclusions[] =\n+{\n+  ATTR_EXCL (\"always_inline\", true, true, true),\n+  ATTR_EXCL (\"target\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false),\n+};\n+\n+static const struct attribute_spec::exclusions attr_alloc_exclusions[] =\n+{\n+  ATTR_EXCL (\"const\", true, true, true),\n+  ATTR_EXCL (\"noreturn\", true, true, true),\n+  ATTR_EXCL (\"pure\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false),\n+};\n+\n+extern const struct attribute_spec::exclusions attr_cold_hot_exclusions[] =\n+{\n+  ATTR_EXCL (\"cold\", true, true, true),\n+  ATTR_EXCL (\"hot\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false)\n+};\n+\n /* Helper to define an attribute.  */\n #define ATTR_SPEC(name, min_len, max_len, decl_req, type_req, fn_type_req, \\\n \t\t  affects_type_identity, handler, exclude)\t\t   \\\n@@ -139,8 +182,6 @@ const attribute_spec d_langhook_common_attribute_table[] =\n \t     handle_type_generic_attribute, NULL),\n   ATTR_SPEC (\"fn spec\", 1, 1, false, true, true, false,\n \t     handle_fnspec_attribute, NULL),\n-  ATTR_SPEC (\"always_inline\", 0, 0, true,  false, false, false,\n-\t     handle_always_inline_attribute, NULL),\n   ATTR_SPEC (NULL, 0, 0, false, false, false, false, NULL, NULL),\n };\n \n@@ -149,20 +190,38 @@ const attribute_spec d_langhook_attribute_table[] =\n {\n   ATTR_SPEC (\"noinline\", 0, 0, true, false, false, false,\n \t     d_handle_noinline_attribute, attr_noinline_exclusions),\n-  ATTR_SPEC (\"forceinline\", 0, 0, true, false, false, false,\n-\t     d_handle_forceinline_attribute, attr_inline_exclusions),\n+  ATTR_SPEC (\"always_inline\", 0, 0, true,  false, false, false,\n+\t     d_handle_always_inline_attribute, attr_inline_exclusions),\n   ATTR_SPEC (\"flatten\", 0, 0, true, false, false, false,\n \t     d_handle_flatten_attribute, NULL),\n   ATTR_SPEC (\"target\", 1, -1, true, false, false, false,\n-\t     d_handle_target_attribute, NULL),\n+\t     d_handle_target_attribute, attr_target_exclusions),\n+  ATTR_SPEC (\"target_clones\", 1, -1, true, false, false, false,\n+\t     d_handle_target_clones_attribute, attr_target_clones_exclusions),\n+  ATTR_SPEC (\"optimize\", 1, -1, true, false, false, false,\n+\t     d_handle_optimize_attribute, NULL),\n   ATTR_SPEC (\"noclone\", 0, 0, true, false, false, false,\n \t     d_handle_noclone_attribute, NULL),\n+  ATTR_SPEC (\"no_icf\", 0, 0, true, false, false, false,\n+\t     d_handle_noicf_attribute, NULL),\n+  ATTR_SPEC (\"noipa\", 0, 0, true, false, false, false,\n+\t     d_handle_noipa_attribute, NULL),\n   ATTR_SPEC (\"section\", 1, 1, true, false, false, false,\n \t     d_handle_section_attribute, NULL),\n-  ATTR_SPEC (\"alias\", 1, 1, true, false, false, false,\n-\t     d_handle_alias_attribute, NULL),\n+  ATTR_SPEC (\"symver\", 1, -1, true, false, false, false,\n+\t     d_handle_symver_attribute, NULL),\n   ATTR_SPEC (\"weak\", 0, 0, true, false, false, false,\n \t     d_handle_weak_attribute, NULL),\n+  ATTR_SPEC (\"noplt\", 0, 0, true, false, false, false,\n+\t     d_handle_noplt_attribute, NULL),\n+  ATTR_SPEC (\"alloc_size\", 1, 3, false, true, true, false,\n+\t     d_handle_alloc_size_attribute, attr_alloc_exclusions),\n+  ATTR_SPEC (\"cold\", 0, 0, true, false, false, false,\n+\t     d_handle_cold_attribute, attr_cold_hot_exclusions),\n+  ATTR_SPEC (\"restrict\", 0, 0, true, false, false, false,\n+\t     d_handle_restrict_attribute, NULL),\n+  ATTR_SPEC (\"used\", 0, 0, true, false, false, false,\n+\t     d_handle_used_attribute, NULL),\n   ATTR_SPEC (NULL, 0, 0, false, false, false, false, NULL, NULL),\n };\n \n@@ -254,11 +313,23 @@ build_attributes (Expressions *eattrs)\n       Dsymbol *sym = attr->type->toDsymbol (0);\n \n       if (!sym)\n-\tcontinue;\n+\t{\n+\t  /* If attribute is a template symbol, perhaps arguments were not\n+\t     supplied, so warn about attribute having no effect.  */\n+\t  if (TemplateExp *te = attr->isTemplateExp ())\n+\t    {\n+\t      if (!te->td || !te->td->onemember)\n+\t\tcontinue;\n+\n+\t      sym = te->td->onemember;\n+\t    }\n+\t  else\n+\t    continue;\n+\t}\n \n       /* Attribute symbol must come from the `gcc.attribute' module.  */\n-      Dsymbol *mod = (Dsymbol *) sym->getModule ();\n-      if (!(strcmp (mod->toChars (), \"attribute\") == 0\n+      Dsymbol *mod = sym->getModule ();\n+      if (!(strcmp (mod->toChars (), \"attributes\") == 0\n \t    && mod->parent != NULL\n \t    && strcmp (mod->parent->toChars (), \"gcc\") == 0\n \t    && !mod->parent->parent))\n@@ -268,16 +339,24 @@ build_attributes (Expressions *eattrs)\n       if (attr->op == TOKcall)\n \tattr = attr->ctfeInterpret ();\n \n+      if (attr->op != TOKstructliteral)\n+\t{\n+\t  warning_at (make_location_t (attr->loc), OPT_Wattributes,\n+\t\t      \"%qE attribute has no effect\",\n+\t\t      get_identifier (sym->toChars ()));\n+\t  continue;\n+\t}\n+\n       /* Should now have a struct `Attribute(\"attrib\", \"value\", ...)'\n \t initializer list.  */\n-      gcc_assert (attr->op == TOKstructliteral);\n       Expressions *elems = attr->isStructLiteralExp ()->elements;\n       Expression *e0 = (*elems)[0];\n \n       if (e0->op != TOKstring)\n \t{\n-\t  error (\"expected string attribute, not %qs\", e0->toChars ());\n-\t  return error_mark_node;\n+\t  warning_at (make_location_t (attr->loc), OPT_Wattributes,\n+\t\t      \"unknown attribute %qs\", e0->toChars());\n+\t  continue;\n \t}\n \n       StringExp *se = e0->toStringExp ();\n@@ -292,9 +371,9 @@ build_attributes (Expressions *eattrs)\n       const char *name = (const char *)(se->len ? se->string : \"\");\n       if (!uda_attribute_p (name))\n \t{\n-\t  warning_at (make_location_t (e0->loc), OPT_Wattributes,\n+\t  warning_at (make_location_t (attr->loc), OPT_Wattributes,\n \t\t      \"unknown attribute %qs\", name);\n-\t  return error_mark_node;\n+\t  continue;\n \t}\n \n       /* Chain all attribute arguments together.  */\n@@ -303,6 +382,10 @@ build_attributes (Expressions *eattrs)\n       for (size_t j = 1; j < elems->length; j++)\n \t{\n \t  Expression *e = (*elems)[j];\n+\t  /* Stop after the first `void' argument.  */\n+\t  if (e == NULL)\n+\t    break;\n+\n \t  StringExp *s = e->isStringExp ();\n \t  tree t;\n \t  if (s != NULL && s->sz == 1)\n@@ -523,7 +606,8 @@ handle_nothrow_attribute (tree *node, tree, tree, int, bool *)\n   return NULL_TREE;\n }\n \n-/* Handle a \"type_generic\" attribute.  */\n+/* Handle a \"type generic\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n \n static tree\n handle_type_generic_attribute (tree *node, tree, tree, int, bool *)\n@@ -537,7 +621,8 @@ handle_type_generic_attribute (tree *node, tree, tree, int, bool *)\n   return NULL_TREE;\n }\n \n-/* Handle a \"transaction_pure\" attribute.  */\n+/* Handle a \"transaction_pure\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n \n static tree\n handle_transaction_pure_attribute (tree *node, tree, tree, int, bool *)\n@@ -548,7 +633,8 @@ handle_transaction_pure_attribute (tree *node, tree, tree, int, bool *)\n   return NULL_TREE;\n }\n \n-/* Handle a \"returns_twice\" attribute.  */\n+/* Handle a \"returns_twice\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n \n static tree\n handle_returns_twice_attribute (tree *node, tree, tree, int, bool *)\n@@ -572,30 +658,18 @@ handle_fnspec_attribute (tree *, tree, tree args, int, bool *)\n   return NULL_TREE;\n }\n \n-/* Handle a \"always_inline\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_always_inline_attribute (tree *node, tree, tree, int, bool *)\n-{\n-  gcc_assert (TREE_CODE (*node) == FUNCTION_DECL);\n-\n-  return NULL_TREE;\n-}\n-\n /* Language specific attribute handlers.\n    These functions take the arguments:\n    (tree *node, tree name, tree args, int flags, bool *no_add_attrs)  */\n \n-/* Handle a \"noinline\" attribute.  */\n+/* Handle a \"noinline\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n \n static tree\n d_handle_noinline_attribute (tree *node, tree name, tree, int,\n \t\t\t     bool *no_add_attrs)\n {\n-  Type *t = TYPE_LANG_FRONTEND (TREE_TYPE (*node));\n-\n-  if (t->ty == Tfunction)\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n     DECL_UNINLINABLE (*node) = 1;\n   else\n     {\n@@ -606,25 +680,16 @@ d_handle_noinline_attribute (tree *node, tree name, tree, int,\n   return NULL_TREE;\n }\n \n-/* Handle a \"forceinline\" attribute.  */\n+/* Handle a \"always_inline\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n \n static tree\n-d_handle_forceinline_attribute (tree *node, tree name, tree, int,\n-\t\t\t\tbool *no_add_attrs)\n+d_handle_always_inline_attribute (tree *node, tree name, tree, int,\n+\t\t\t\t  bool *no_add_attrs)\n {\n-  Type *t = TYPE_LANG_FRONTEND (TREE_TYPE (*node));\n-\n-  if (t->ty == Tfunction)\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n     {\n-      tree attributes = DECL_ATTRIBUTES (*node);\n-\n-      /* Push attribute always_inline.  */\n-      if (!lookup_attribute (\"always_inline\", attributes))\n-\tDECL_ATTRIBUTES (*node) = tree_cons (get_identifier (\"always_inline\"),\n-\t\t\t\t\t     NULL_TREE, attributes);\n-\n       DECL_DECLARED_INLINE_P (*node) = 1;\n-      DECL_NO_INLINE_WARNING_P (*node) = 1;\n       DECL_DISREGARD_INLINE_LIMITS (*node) = 1;\n     }\n   else\n@@ -636,15 +701,14 @@ d_handle_forceinline_attribute (tree *node, tree name, tree, int,\n   return NULL_TREE;\n }\n \n-/* Handle a \"flatten\" attribute.  */\n+/* Handle a \"flatten\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n \n static tree\n d_handle_flatten_attribute (tree *node, tree name, tree, int,\n \t\t\t    bool *no_add_attrs)\n {\n-  Type *t = TYPE_LANG_FRONTEND (TREE_TYPE (*node));\n-\n-  if (t->ty != Tfunction)\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n     {\n       warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n       *no_add_attrs = true;\n@@ -653,169 +717,384 @@ d_handle_flatten_attribute (tree *node, tree name, tree, int,\n   return NULL_TREE;\n }\n \n-/* Handle a \"target\" attribute.  */\n+/* Handle a \"target\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n \n static tree\n d_handle_target_attribute (tree *node, tree name, tree args, int flags,\n \t\t\t   bool *no_add_attrs)\n {\n-  Type *t = TYPE_LANG_FRONTEND (TREE_TYPE (*node));\n-\n   /* Ensure we have a function type.  */\n-  if (t->ty != Tfunction)\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n     {\n       warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n       *no_add_attrs = true;\n     }\n   else if (!targetm.target_option.valid_attribute_p (*node, name, args, flags))\n     *no_add_attrs = true;\n \n+  /* Check that there's no empty string in values of the attribute.  */\n+  for (tree t = args; t != NULL_TREE; t = TREE_CHAIN (t))\n+    {\n+      tree value = TREE_VALUE (t);\n+      if (TREE_CODE (value) != STRING_CST\n+\t  || (TREE_STRING_LENGTH (value) != 0\n+\t      && TREE_STRING_POINTER (value)[0] != '\\0'))\n+\tcontinue;\n+\n+      warning (OPT_Wattributes, \"empty string in attribute %<target%>\");\n+      *no_add_attrs = true;\n+    }\n+\n   return NULL_TREE;\n }\n \n-/* Handle a \"noclone\" attribute.  */\n+/* Handle a \"target_clones\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n \n static tree\n-d_handle_noclone_attribute (tree *node, tree name, tree, int,\n-\t\t\t    bool *no_add_attrs)\n+d_handle_target_clones_attribute (tree *node, tree name, tree, int,\n+\t\t\t\t  bool *no_add_attrs)\n {\n-  Type *t = TYPE_LANG_FRONTEND (TREE_TYPE (*node));\n-\n-  if (t->ty == Tfunction)\n+  /* Ensure we have a function type.  */\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n     {\n-      tree attributes = DECL_ATTRIBUTES (*node);\n-\n-      /* Push attribute noclone.  */\n-      if (!lookup_attribute (\"noclone\", attributes))\n-\tDECL_ATTRIBUTES (*node) = tree_cons (get_identifier (\"noclone\"),\n-\t\t\t\t\t     NULL_TREE, attributes);\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n     }\n   else\n     {\n-      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n-      *no_add_attrs = true;\n+      /* Do not inline functions with multiple clone targets.  */\n+      DECL_UNINLINABLE (*node) = 1;\n     }\n \n   return NULL_TREE;\n }\n \n-/* Handle a \"section\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n+/* Arguments being collected for optimization.  */\n+static GTY(()) vec <const char *, va_gc> *optimize_args;\n \n-static tree\n-d_handle_section_attribute (tree *node, tree, tree args, int,\n-\t\t\t    bool *no_add_attrs)\n+/* Inner function to convert a TREE_LIST to argv string to parse the optimize\n+   options in ARGS.  */\n+\n+static bool\n+parse_optimize_options (tree args)\n {\n-  tree decl = *node;\n+  bool ret = true;\n+\n+  /* Build up argv vector.  Just in case the string is stored away, use garbage\n+     collected strings.  */\n+  vec_safe_truncate (optimize_args, 0);\n+  vec_safe_push (optimize_args, (const char *) NULL);\n \n-  if (targetm_common.have_named_sections)\n+  for (tree ap = args; ap != NULL_TREE; ap = TREE_CHAIN (ap))\n     {\n-      if (VAR_OR_FUNCTION_DECL_P (decl)\n-\t  && TREE_CODE (TREE_VALUE (args)) == STRING_CST)\n+      tree value = TREE_VALUE (ap);\n+\n+      if (TREE_CODE (value) == INTEGER_CST)\n \t{\n-\t  if (VAR_P (decl)\n-\t      && current_function_decl != NULL_TREE\n-\t      && !TREE_STATIC (decl))\n-\t    {\n-\t      error_at (DECL_SOURCE_LOCATION (decl),\n-\t\t\t\"section attribute cannot be specified for \"\n-\t\t\t\"local variables\");\n-\t      *no_add_attrs = true;\n-\t    }\n+\t  char buffer[20];\n+\t  sprintf (buffer, \"-O%ld\", (long) TREE_INT_CST_LOW (value));\n+\t  vec_safe_push (optimize_args, ggc_strdup (buffer));\n+\t}\n+      else if (TREE_CODE (value) == STRING_CST)\n+\t{\n+\t  size_t len = TREE_STRING_LENGTH (value);\n+\t  const char *p = TREE_STRING_POINTER (value);\n \n-\t  /* The decl may have already been given a section attribute\n-\t     from a previous declaration.  Ensure they match.  */\n-\t  else if (DECL_SECTION_NAME (decl) != NULL\n-\t\t   && strcmp (DECL_SECTION_NAME (decl),\n-\t\t\t      TREE_STRING_POINTER (TREE_VALUE (args))) != 0)\n+\t  /* If the user supplied -Oxxx or -fxxx, only allow -Oxxx or -fxxx\n+\t     options.  */\n+\t  if (*p == '-' && p[1] != 'O' && p[1] != 'f')\n \t    {\n-\t      error (\"section of %q+D conflicts with previous declaration\",\n-\t\t     *node);\n-\t      *no_add_attrs = true;\n+\t      ret = false;\n+\t      warning (OPT_Wattributes,\n+\t\t       \"bad option %qs to attribute %<optimize%>\", p);\n+\t      continue;\n \t    }\n-\t  else if (VAR_P (decl)\n-\t\t   && !targetm.have_tls && targetm.emutls.tmpl_section\n-\t\t   && DECL_THREAD_LOCAL_P (decl))\n+\n+\t  /* Can't use GC memory here.  */\n+\t  char *q = XOBNEWVEC (&opts_obstack, char, len + 3);\n+\t  char *r = q;\n+\n+\t  if (*p != '-')\n \t    {\n-\t      error (\"section of %q+D cannot be overridden\", *node);\n-\t      *no_add_attrs = true;\n+\t      *r++ = '-';\n+\n+\t      /* Assume that Ox is -Ox, a numeric value is -Ox, a s by\n+\t\t itself is -Os, and any other switch begins with a -f.  */\n+\t      if ((*p >= '0' && *p <= '9') || (p[0] == 's' && p[1] == '\\0'))\n+\t\t*r++ = 'O';\n+\t      else if (*p != 'O')\n+\t\t*r++ = 'f';\n \t    }\n-\t  else\n-\t    set_decl_section_name (decl,\n-\t\t\t\t   TREE_STRING_POINTER (TREE_VALUE (args)));\n+\n+\t  memcpy (r, p, len);\n+\t  r[len] = '\\0';\n+\t  vec_safe_push (optimize_args, (const char *) q);\n \t}\n-      else\n+    }\n+\n+  unsigned opt_argc = optimize_args->length ();\n+  const char **opt_argv\n+    = (const char **) alloca (sizeof (char *) * (opt_argc + 1));\n+\n+  for (unsigned i = 1; i < opt_argc; i++)\n+    opt_argv[i] = (*optimize_args)[i];\n+\n+  /* Now parse the options.  */\n+  struct cl_decoded_option *decoded_options;\n+  unsigned int decoded_options_count;\n+\n+  decode_cmdline_options_to_array_default_mask (opt_argc, opt_argv,\n+\t\t\t\t\t\t&decoded_options,\n+\t\t\t\t\t\t&decoded_options_count);\n+  /* Drop non-Optimization options.  */\n+  unsigned j = 1;\n+  for (unsigned i = 1; i < decoded_options_count; ++i)\n+    {\n+      if (! (cl_options[decoded_options[i].opt_index].flags & CL_OPTIMIZATION))\n \t{\n-\t  error (\"section attribute not allowed for %q+D\", *node);\n-\t  *no_add_attrs = true;\n+\t  ret = false;\n+\t  warning (OPT_Wattributes,\n+\t\t   \"bad option %qs to attribute %<optimize%>\",\n+\t\t   decoded_options[i].orig_option_with_args_text);\n+\t  continue;\n \t}\n+      if (i != j)\n+\tdecoded_options[j] = decoded_options[i];\n+      j++;\n+    }\n+  decoded_options_count = j;\n+  /* And apply them.  */\n+  decode_options (&global_options, &global_options_set,\n+\t\t  decoded_options, decoded_options_count,\n+\t\t  input_location, global_dc, NULL);\n+\n+  targetm.override_options_after_change();\n+\n+  optimize_args->truncate (0);\n+  return ret;\n+}\n+\n+/* Handle a \"optimize\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+d_handle_optimize_attribute (tree *node, tree name, tree args, int,\n+\t\t\t     bool *no_add_attrs)\n+{\n+  /* Ensure we have a function type.  */\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n     }\n   else\n     {\n-      error_at (DECL_SOURCE_LOCATION (*node),\n-\t\t\"section attributes are not supported for this target\");\n+      struct cl_optimization cur_opts;\n+      tree old_opts = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (*node);\n+\n+      /* Save current options.  */\n+      cl_optimization_save (&cur_opts, &global_options, &global_options_set);\n+\n+      /* If we previously had some optimization options, use them as the\n+\t default.  */\n+      gcc_options *saved_global_options = NULL;\n+      if (flag_checking)\n+\t{\n+\t  saved_global_options = XNEW (gcc_options);\n+\t  *saved_global_options = global_options;\n+\t}\n+\n+      if (old_opts)\n+\tcl_optimization_restore (&global_options, &global_options_set,\n+\t\t\t\t TREE_OPTIMIZATION (old_opts));\n+\n+      /* Parse options, and update the vector.  */\n+      parse_optimize_options (args);\n+      DECL_FUNCTION_SPECIFIC_OPTIMIZATION (*node)\n+\t= build_optimization_node (&global_options, &global_options_set);\n+\n+      /* Restore current options.  */\n+      cl_optimization_restore (&global_options, &global_options_set,\n+\t\t\t       &cur_opts);\n+      if (saved_global_options != NULL)\n+\t{\n+\t  cl_optimization_compare (saved_global_options, &global_options);\n+\t  free (saved_global_options);\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"noclone\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+d_handle_noclone_attribute (tree *node, tree name, tree, int,\n+\t\t\t    bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n       *no_add_attrs = true;\n     }\n \n   return NULL_TREE;\n }\n \n-/* Handle an \"alias\" attribute; arguments as in\n+/* Handle a \"no_icf\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n \n static tree\n-d_handle_alias_attribute (tree *node, tree name, tree args, int,\n+d_handle_noicf_attribute (tree *node, tree name, tree, int,\n \t\t\t  bool *no_add_attrs)\n {\n-  tree decl = *node;\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n \n-  if (TREE_CODE (decl) != FUNCTION_DECL\n-      && TREE_CODE (decl) != VAR_DECL)\n+/* Handle a \"noipa\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+d_handle_noipa_attribute (tree *node, tree name, tree, int,\n+\t\t\t  bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n     {\n       warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n       *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"section\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+d_handle_section_attribute (tree *node, tree name, tree args, int flags,\n+\t\t\t    bool *no_add_attrs)\n+{\n+  if (!targetm_common.have_named_sections)\n+    {\n+      error (\"section attributes are not supported for this target\");\n+      *no_add_attrs = true;\n       return NULL_TREE;\n     }\n-  else if ((TREE_CODE (decl) == FUNCTION_DECL && DECL_INITIAL (decl))\n-      || (TREE_CODE (decl) != FUNCTION_DECL\n-\t  && TREE_PUBLIC (decl) && !DECL_EXTERNAL (decl))\n-      /* A static variable declaration is always a tentative definition,\n-\t but the alias is a non-tentative definition which overrides.  */\n-      || (TREE_CODE (decl) != FUNCTION_DECL\n-\t  && !TREE_PUBLIC (decl) && DECL_INITIAL (decl)))\n+\n+  if (!VAR_OR_FUNCTION_DECL_P (*node))\n     {\n-      error (\"%q+D defined both normally and as %qE attribute\", decl, name);\n+      error (\"section attribute not allowed for %q+D\", *node);\n       *no_add_attrs = true;\n       return NULL_TREE;\n     }\n-  else if (decl_function_context (decl))\n+\n+  if (TREE_CODE (TREE_VALUE (args)) != STRING_CST)\n     {\n-      error (\"%q+D alias functions must be global\", name);\n+      error (\"section attribute argument not a string constant\");\n       *no_add_attrs = true;\n       return NULL_TREE;\n     }\n-  else\n+\n+  if (VAR_P (*node)\n+      && current_function_decl != NULL_TREE\n+      && !TREE_STATIC (*node))\n     {\n-      tree id;\n+      error (\"section attribute cannot be specified for local variables\");\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n \n-      id = TREE_VALUE (args);\n-      if (TREE_CODE (id) != STRING_CST)\n+  /* The decl may have already been given a section attribute\n+     from a previous declaration.  Ensure they match.  */\n+  if (DECL_SECTION_NAME (*node) != NULL\n+      && strcmp (DECL_SECTION_NAME (*node),\n+\t\t TREE_STRING_POINTER (TREE_VALUE (args))) != 0)\n+    {\n+      error (\"section of %q+D conflicts with previous declaration\", *node);\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  if (VAR_P (*node)\n+      && !targetm.have_tls && targetm.emutls.tmpl_section\n+      && DECL_THREAD_LOCAL_P (*node))\n+    {\n+      error (\"section of %q+D cannot be overridden\", *node);\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  tree res = targetm.handle_generic_attribute (node, name, args, flags,\n+\t\t\t\t\t       no_add_attrs);\n+\n+  /* If the back end confirms the attribute can be added then continue onto\n+     final processing.  */\n+  if (*no_add_attrs)\n+    return NULL_TREE;\n+\n+  set_decl_section_name (*node, TREE_STRING_POINTER (TREE_VALUE (args)));\n+  return res;\n+}\n+\n+/* Handle a \"symver\" and attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+d_handle_symver_attribute (tree *node, tree, tree args, int, bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL && TREE_CODE (*node) != VAR_DECL)\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"%<symver%> attribute only applies to functions and variables\");\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  if (!decl_in_symtab_p (*node))\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"%<symver%> attribute is only applicable to symbols\");\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  for (; args; args = TREE_CHAIN (args))\n+    {\n+      tree symver = TREE_VALUE (args);\n+      if (TREE_CODE (symver) != STRING_CST)\n \t{\n-\t  error (\"attribute %qE argument not a string\", name);\n+\t  error (\"%<symver%> attribute argument not a string constant\");\n \t  *no_add_attrs = true;\n \t  return NULL_TREE;\n \t}\n-      id = get_identifier (TREE_STRING_POINTER (id));\n-      /* This counts as a use of the object pointed to.  */\n-      TREE_USED (id) = 1;\n \n-      if (TREE_CODE (decl) == FUNCTION_DECL)\n-\tDECL_INITIAL (decl) = error_mark_node;\n-      else\n-\tTREE_STATIC (decl) = 1;\n+      const char *symver_str = TREE_STRING_POINTER (symver);\n \n-      return NULL_TREE;\n+      int ats = 0;\n+      for (int n = 0; (int)n < TREE_STRING_LENGTH (symver); n++)\n+\tif (symver_str[n] == '@')\n+\t  ats++;\n+\n+      if (ats != 1 && ats != 2)\n+\t{\n+\t  error (\"symver attribute argument must have format %<name@nodename%>\");\n+\t  error (\"%<symver%> attribute argument %qs must contain one or two \"\n+\t\t \"%<@%>\", symver_str);\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n+\t}\n     }\n+\n+  return NULL_TREE;\n }\n \n /* Handle a \"weak\" attribute; arguments as in\n@@ -843,3 +1122,279 @@ d_handle_weak_attribute (tree *node, tree name, tree, int, bool *no_add_attrs)\n   return NULL_TREE;\n }\n \n+/* Handle a \"noplt\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+d_handle_noplt_attribute (tree *node, tree name, tree, int, bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Verify that argument value POS at position ARGNO to attribute ATNAME applied\n+   to function FNTYPE refers to a function parameter at position POS and is a\n+   valid integer type.  When ZERO_BASED is true, POS is adjusted to be 1-based.\n+   If successful, POS is returned.  Otherwise, issue appropriate warnings and\n+   return null.  A non-zero 1-based ARGNO should be passed in by callers only\n+   for attributes with more than one argument.  */\n+\n+static tree\n+positional_argument (const_tree fntype, const_tree atname, tree pos,\n+\t\t     int argno, bool zero_based)\n+{\n+  tree postype = TREE_TYPE (pos);\n+\n+  if (pos == error_mark_node || !postype)\n+    {\n+      /* Only mention the positional argument number when it's non-zero.  */\n+      if (argno < 1)\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument is invalid\", atname);\n+      else\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument %i is invalid\", atname, argno);\n+\n+      return NULL_TREE;\n+    }\n+\n+  if (!INTEGRAL_TYPE_P (postype))\n+    {\n+      /* Handle this case specially to avoid mentioning the value\n+\t of pointer constants in diagnostics.  Only mention\n+\t the positional argument number when it's non-zero.  */\n+      if (argno < 1)\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument has type %qT\",\n+\t\t atname, postype);\n+      else\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument %i has type %qT\",\n+\t\t atname, argno, postype);\n+\n+      return NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (pos) != INTEGER_CST)\n+    {\n+      /* Only mention the argument number when it's non-zero.  */\n+      if (argno < 1)\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument value %qE is not an integer \"\n+\t\t \"constant\",\n+\t\t atname, pos);\n+      else\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument %i value %qE is not an integer \"\n+\t\t \"constant\",\n+\t\t atname, argno, pos);\n+\n+      return NULL_TREE;\n+    }\n+\n+  /* Validate the value of the position argument.  If 0-based, then it should\n+     not be negative.  If 1-based, it should be greater than zero.  */\n+  if ((zero_based && tree_int_cst_sgn (pos) < 0)\n+      || (!zero_based && tree_int_cst_sgn (pos) < 1))\n+    {\n+      if (argno < 1)\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument value %qE does not refer to \"\n+\t\t \"a function parameter\",\n+\t\t atname, pos);\n+      else\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument %i value %qE does not refer to \"\n+\t\t \"a function parameter\",\n+\t\t atname, argno, pos);\n+\n+      return NULL_TREE;\n+    }\n+\n+  /* Adjust the value of pos to be 1-based.  */\n+  tree adjusted_pos = (zero_based)\n+    ? int_const_binop (PLUS_EXPR, pos, integer_one_node) : pos;\n+\n+  if (!prototype_p (fntype))\n+    return adjusted_pos;\n+\n+  /* Verify that the argument position does not exceed the number\n+     of formal arguments to the function.  */\n+  unsigned nargs = type_num_arguments (fntype);\n+  if (!nargs\n+      || !tree_fits_uhwi_p (adjusted_pos)\n+      || !IN_RANGE (tree_to_uhwi (adjusted_pos), 1, nargs))\n+    {\n+      if (argno < 1)\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument value %qE exceeds the number \"\n+\t\t \"of function parameters %u\",\n+\t\t atname, pos, nargs);\n+      else\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument %i value %qE exceeds the number \"\n+\t\t \"of function parameters %u\",\n+\t\t atname, argno, pos, nargs);\n+\n+      return NULL_TREE;\n+    }\n+\n+  /* Verify that the type of the referenced formal argument matches\n+     the expected type.  */\n+  unsigned HOST_WIDE_INT ipos = tree_to_uhwi (adjusted_pos);\n+\n+  /* Zero was handled above.  */\n+  gcc_assert (ipos != 0);\n+\n+  if (tree argtype = type_argument_type (fntype, ipos))\n+    {\n+      /* Accept types that match INTEGRAL_TYPE_P except for bool.  */\n+      if (!INTEGRAL_TYPE_P (argtype) || TREE_CODE (argtype) == BOOLEAN_TYPE)\n+\t{\n+\t  if (argno < 1)\n+\t    warning (OPT_Wattributes,\n+\t\t     \"%qE attribute argument value %qE refers to \"\n+\t\t     \"parameter type %qT\",\n+\t\t     atname, pos, argtype);\n+\t  else\n+\t    warning (OPT_Wattributes,\n+\t\t     \"%qE attribute argument %i value %qE refers to \"\n+\t\t     \"parameter type %qT\",\n+\t\t     atname, argno, pos, argtype);\n+\n+\t  return NULL_TREE;\n+\t}\n+\n+      return adjusted_pos;\n+    }\n+\n+  /* Argument position exceeding number of parameters was handled above.  */\n+  gcc_unreachable ();\n+}\n+\n+/* Handle a \"alloc_size\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+d_handle_alloc_size_attribute (tree *node, tree name, tree args, int,\n+\t\t\t       bool *no_add_attrs)\n+{\n+  tree fntype = *node;\n+  tree rettype = TREE_TYPE (fntype);\n+  if (!POINTER_TYPE_P (rettype))\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"%qE attribute ignored on a function returning %qT\",\n+\t       name, rettype);\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  /* The first argument SIZE_ARG is never null.  */\n+  tree size_arg = TREE_VALUE (args);\n+  tree next = TREE_CHAIN (args);\n+\n+  /* NUM_ARG is null when the attribute includes just one argument, or is\n+     explictly set to null if it has been left uninitialized by the caller.  */\n+  tree num_arg = NULL_TREE;\n+  if (next != NULL_TREE)\n+    {\n+      if (TREE_VALUE (next) != TYPE_MIN_VALUE (d_int_type))\n+\tnum_arg = TREE_VALUE (next);\n+\n+      next = TREE_CHAIN (next);\n+    }\n+\n+  /* If ZERO_ARG is set and true, arguments positions are treated as 0-based.\n+     Otherwise the default is 1-based.  */\n+  bool zero_based = false;\n+  if (next != NULL_TREE)\n+    zero_based = integer_truep (TREE_VALUE (next));\n+\n+  /* Update the argument values with the real argument position.  */\n+  if (tree val = positional_argument (fntype, name, size_arg, num_arg ? 1 : 0,\n+\t\t\t\t      zero_based))\n+    TREE_VALUE (args) = val;\n+  else\n+    *no_add_attrs = true;\n+\n+  if (num_arg != NULL_TREE)\n+    {\n+      args = TREE_CHAIN (args);\n+      if (tree val = positional_argument (fntype, name, num_arg, 2, zero_based))\n+\tTREE_VALUE (args) = val;\n+      else\n+\t*no_add_attrs = true;\n+    }\n+\n+  /* Terminate the original TREE_CHAIN in `args' to remove any remaining\n+     D-specific `alloc_size` arguments.  */\n+  TREE_CHAIN (args) = NULL_TREE;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"cold\" and attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+d_handle_cold_attribute (tree *node, tree name, tree, int, bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"restrict\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+d_handle_restrict_attribute (tree *node, tree name, tree, int,\n+\t\t\t     bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) == PARM_DECL && POINTER_TYPE_P (TREE_TYPE (*node)))\n+    {\n+      TREE_TYPE (*node) = build_qualified_type (TREE_TYPE (*node),\n+\t\t\t\t\t\tTYPE_QUAL_RESTRICT);\n+    }\n+  else\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"used\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+d_handle_used_attribute (tree *node, tree name, tree, int, bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL\n+      || (VAR_P (*node) && TREE_STATIC (*node))\n+      || (TREE_CODE (*node) == TYPE_DECL))\n+    {\n+      TREE_USED (*node) = 1;\n+      DECL_PRESERVE_P (*node) = 1;\n+      if (VAR_P (*node))\n+\tDECL_READ_P (*node) = 1;\n+    }\n+  else\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}"}, {"sha": "b07068ed6ca33613f11977a5ad25d4d1be17ecff", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -108,7 +108,7 @@ gcc_attribute_p (Dsymbol *decl)\n   if (md && md->packages && md->packages->length == 1)\n     {\n       if (!strcmp ((*md->packages)[0]->toChars (), \"gcc\")\n-\t  && !strcmp (md->id->toChars (), \"attribute\"))\n+\t  && !strcmp (md->id->toChars (), \"attributes\"))\n \treturn true;\n     }\n \n@@ -1124,6 +1124,10 @@ get_symbol_decl (Declaration *decl)\n \t  tree olddecl = decl->csym;\n \t  decl->csym = get_symbol_decl (other);\n \n+\t  /* Update the symbol location to the current definition.  */\n+\t  if (DECL_EXTERNAL (decl->csym) && !DECL_INITIAL (decl->csym))\n+\t    DECL_SOURCE_LOCATION (decl->csym) = DECL_SOURCE_LOCATION (olddecl);\n+\n \t  /* The current declaration is a prototype or marked extern, merge\n \t     applied user attributes and return.  */\n \t  if (DECL_EXTERNAL (olddecl) && !DECL_INITIAL (olddecl))"}, {"sha": "ec617407b3dcee7106f169abb81b10f5742fce11", "filename": "gcc/d/types.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Fd%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Fd%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypes.cc?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -354,6 +354,7 @@ layout_aggregate_members (Dsymbols *members, tree context, bool inherited_p)\n \t      const char *ident = var->ident ? var->ident->toChars () : NULL;\n \t      tree field = create_field_decl (declaration_type (var), ident,\n \t\t\t\t\t      inherited_p, inherited_p);\n+\t      apply_user_attributes (var, field);\n \t      insert_aggregate_field (context, field, var->offset);\n \n \t      /* Because the front-end shares field decls across classes, don't\n@@ -403,6 +404,7 @@ layout_aggregate_members (Dsymbols *members, tree context, bool inherited_p)\n \n \t  /* And make the corresponding data member.  */\n \t  tree field = create_field_decl (type, NULL, 0, 0);\n+\t  apply_user_attributes (ad, field);\n \t  insert_aggregate_field (context, field, ad->anonoffset);\n \t  continue;\n \t}"}, {"sha": "9efba19728961a079a887859f2e2a7c1b94c3d4d", "filename": "gcc/testsuite/gdc.dg/attr_allocsize1.d", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_allocsize1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_allocsize1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_allocsize1.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do compile }\n+\n+import gcc.attributes;\n+\n+@alloc_size(1)\n+int ignoredfunc(int size); // { dg-warning \".alloc_size. attribute ignored on a function returning .int.\" }\n+\n+@alloc_size(0) int var; // { dg-warning \".alloc_size. attribute only applies to function types\" }\n+\n+@attribute(\"alloc_size\", \"1\")\n+void* invalid1(int size); // { dg-warning \".alloc_size. attribute argument is invalid\" }\n+\n+@attribute(\"alloc_size\", 1, \"2\")\n+void* invalid2(int count, int size); // { dg-warning \".alloc_size. attribute argument 2 is invalid\" }\n+\n+@attribute(\"alloc_size\", 0.1)\n+void* wrongtype1(int size); // { dg-warning \".alloc_size. attribute argument has type .double.\" }\n+\n+@attribute(\"alloc_size\", 1, 0.2)\n+void* wrongtype2(int count, int size); // { dg-warning \".alloc_size. attribute argument 2 has type .double.\" }\n+\n+@alloc_size(0)\n+void* malloc0(int size); // { dg-warning \".alloc_size. attribute argument value .0. does not refer to a function parameter\" }\n+\n+@alloc_size(1, 0)\n+void* malloc0(int count, int size); // { dg-warning \".alloc_size. attribute argument 2 value .0. does not refer to a function parameter\" }\n+\n+@alloc_size(1, 0, true)\n+void* malloc0pos(int count, int size);\n+\n+@alloc_size(1, -1, true)\n+void* mallocminus1(int count, int size); // { dg-warning \".alloc_size. attribute argument 2 value .-1. does not refer to a function parameter\" }\n+\n+@alloc_size(99)\n+void* malloc99(int size); // { dg-warning \".alloc_size. attribute argument value .99. exceeds the number of function parameters 1\" }\n+\n+@alloc_size(1, 99)\n+void* malloc99(int count, int size); // { dg-warning \".alloc_size. attribute argument 2 value .99. exceeds the number of function parameters 2\" }\n+\n+@alloc_size(1)\n+void* mallocdouble(double size); // { dg-warning \".alloc_size. attribute argument value .1. refers to parameter type .double.\" }\n+\n+@alloc_size(2, 1)\n+void* mallocdouble(int count, double size); // { dg-warning \".alloc_size. attribute argument 1 value .2. refers to parameter type .double.\" }"}, {"sha": "a10dbbee498d3cd9b1cc72708a04085bb3bd8218", "filename": "gcc/testsuite/gdc.dg/attr_allocsize2.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_allocsize2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_allocsize2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_allocsize2.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile }\n+\n+import gcc.attributes;\n+\n+void* my_calloc(size_t num, size_t size) @allocSize(1, 0)\n+{\n+    return null;\n+}\n+\n+void* my_malloc(int a, int b, size_t size, int c) @allocSize(2)\n+{\n+    return null;\n+}"}, {"sha": "8fbe25cdfc1fe4cdaba982ebe5a6fe3534aee168", "filename": "gcc/testsuite/gdc.dg/attr_alwaysinline1.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_alwaysinline1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_alwaysinline1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_alwaysinline1.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+// { dg-options \"-O0\" }\n+\n+import gcc.attributes;\n+\n+int func()\n+{\n+    int nested_function() @always_inline\n+    {\n+        return 13;\n+    }\n+    return nested_function();\n+}\n+\n+@always_inline int var = 0; // { dg-warning \".always_inline. attribute ignored\" }\n+\n+// { dg-final { scan-assembler-not \"nested_function\" } }"}, {"sha": "bf44d7b28d58774d014a522f5e5d1a4107ee2b0f", "filename": "gcc/testsuite/gdc.dg/attr_cold1.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_cold1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_cold1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_cold1.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fdump-tree-optimized\" }\n+\n+import gcc.attributes;\n+\n+int func() @cold\n+{\n+    return 0;\n+}\n+\n+@cold int var = 0; // { dg-warning \".cold. attribute ignored\" }\n+\n+// { dg-final { scan-tree-dump \"func\\[^\\r\\n\\]*(unlikely executed)\" \"optimized\" } }"}, {"sha": "90d4e5d77e66951c203cfcd3ab39e6ccfc204b6c", "filename": "gcc/testsuite/gdc.dg/attr_exclusions1.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_exclusions1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_exclusions1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_exclusions1.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile }\n+\n+import gcc.attributes;\n+\n+// always_inline\n+\n+@noinline\n+@always_inline\n+void i0(); // { dg-warning \"ignoring attribute .always_inline. because it conflicts with attribute .noinline.\" }\n+\n+@target_clones(\"\")\n+@always_inline\n+void i1(); // { dg-warning \"ignoring attribute .always_inline. because it conflicts with attribute .target_clones.\" }\n+\n+// noinline\n+\n+@always_inline\n+@noinline\n+void n0(); // { dg-warning \"ignoring attribute .noinline. because it conflicts with attribute .always_inline.\" }"}, {"sha": "791e9afeb48926983bc0c155e58315cf06fa27e1", "filename": "gcc/testsuite/gdc.dg/attr_exclusions2.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_exclusions2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_exclusions2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_exclusions2.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile { target x86_64-*-* } }\n+\n+import gcc.attributes;\n+\n+// target\n+\n+@target_clones(\"default\")\n+@target(\"default\")\n+void tc0(); // { dg-warning \"ignoring attribute .target. because it conflicts with attribute .target_clones.\" }\n+\n+// target_clones\n+\n+@target(\"default\")\n+@target_clones(\"default\")\n+void t0(); // { dg-warning \"ignoring attribute .target_clones. because it conflicts with attribute .target.\" }\n+\n+@always_inline\n+@target_clones(\"default\")\n+void tc1(); // { dg-warning \"ignoring attribute .target_clones. because it conflicts with attribute .always_inline.\" }"}, {"sha": "47bcc3883fbac4a693b438d0251fb2af2683728d", "filename": "gcc/testsuite/gdc.dg/attr_flatten1.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_flatten1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_flatten1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_flatten1.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile }\n+// { dg-options \"-O1\" }\n+\n+import gcc.attributes;\n+\n+int func() @flatten\n+{\n+    __gshared int count = 0;\n+    int nested_function()\n+    {\n+        return count++;\n+    }\n+    static foreach (_; 0 .. 1000)\n+        nested_function();\n+\n+    return nested_function();\n+}\n+\n+@flatten int var = 0; // { dg-warning \".flatten. attribute ignored\" }\n+\n+// { dg-final { scan-assembler-not \"nested_function\" } }"}, {"sha": "e7a93414fd0df462f8e1e653428f8e94d48790b1", "filename": "gcc/testsuite/gdc.dg/attr_module.d", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_module.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_module.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_module.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,40 @@\n+// { dg-do compile }\n+// { dg-additional-sources \"imports/attributes.d\" }\n+\n+import gcc.attributes;\n+\n+@value_ignored\n+int f0()\n+{\n+    return 0;\n+}\n+\n+@type_symbol // { dg-warning \".type_symbol. attribute has no effect\" }\n+int f1()\n+{\n+    return 1;\n+}\n+\n+@template_symbol // { dg-warning \".template_symbol. attribute has no effect\" }\n+int f2()\n+{\n+    return 2;\n+}\n+\n+@struct_wrong_field(123) // { dg-warning  \"unknown attribute .123.\" }\n+int f3()\n+{\n+    return 3;\n+}\n+\n+@struct_void_init()\n+int f4()\n+{\n+    return 4;\n+}\n+\n+@unknown_attribute() // { dg-warning \"unknown attribute .made up name.\" }\n+int f5()\n+{\n+    return 5;\n+}"}, {"sha": "0289135318a9de29cf9ba0244e8591123876347a", "filename": "gcc/testsuite/gdc.dg/attr_noclone1.d", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_noclone1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_noclone1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_noclone1.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+import gcc.attributes;\n+\n+@target_clones(\"avx\", \"default\")\n+@noclone\n+void func() // { dg-error \"clones for .target_clones. attribute cannot be created\" }\n+{           // { dg-message \"function .func. can never be copied because it has .noclone. attribute\" \"\" { target *-*-* } .-1 }\n+}\n+\n+@noclone int var = 0; // { dg-warning \".noclone. attribute ignored\" }"}, {"sha": "71a9aa10283b19832aedfd2a5341ac764593e74c", "filename": "gcc/testsuite/gdc.dg/attr_noicf1.d", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_noicf1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_noicf1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_noicf1.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,30 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fno-inline\" }\n+\n+import gcc.attributes;\n+\n+extern int t();\n+\n+int func()\n+{\n+    __gshared int var = 42;\n+    int nested_1() @no_icf\n+    {\n+        return var++;\n+    }\n+    int nested_2()\n+    {\n+        return var++;\n+    }\n+    int nested_3()\n+    {\n+        return var++;\n+    }\n+    return nested_1() + nested_2() + nested_3();\n+}\n+\n+@no_icf int var = 0; // { dg-warning \".no_icf. attribute ignored\" }\n+\n+// { dg-final { scan-assembler \"nested_1\" } }\n+// { dg-final { scan-assembler \"nested_2\" } }\n+// { dg-final { scan-assembler-not \"nested_3\" } }"}, {"sha": "51fffe52e7872abeea0a2358bdc30fb101c6efff", "filename": "gcc/testsuite/gdc.dg/attr_noinline1.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_noinline1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_noinline1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_noinline1.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -finline-functions -fno-ipa-icf\" }\n+\n+import gcc.attributes;\n+\n+extern int t();\n+\n+void func()\n+{\n+    void nested_function() @noinline\n+    {\n+        t();\n+    }\n+    nested_function();\n+}\n+\n+@noinline int var = 0; // { dg-warning \".noinline. attribute ignored\" }\n+\n+// { dg-final { scan-assembler \"nested_function\" } }"}, {"sha": "a1f58dc42c1651435533acc714584a6a7c23af2e", "filename": "gcc/testsuite/gdc.dg/attr_noipa1.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_noipa1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_noipa1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_noipa1.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -finline-functions\" }\n+\n+import gcc.attributes;\n+\n+int func(int x)\n+{\n+    int nested_function(int y, int z) @noipa\n+    {\n+        return y + z;\n+    }\n+    return nested_function(x, 0);\n+}\n+\n+@noipa int var = 0; // { dg-warning \".noipa. attribute ignored\" }\n+\n+// { dg-final { scan-assembler \"nested_function\" } }"}, {"sha": "73a2fb53704e024ac8c9644d33e4edb7eb2ecb18", "filename": "gcc/testsuite/gdc.dg/attr_noplt1.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_noplt1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_noplt1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_noplt1.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile { target x86_64-*-linux* } }\n+// { dg-options \"-O2 -fno-pic\" }\n+\n+import gcc.attributes;\n+\n+@noplt int func();\n+\n+@noplt int var = 0; // { dg-warning \".noplt. attribute ignored\" }\n+\n+int main()\n+{\n+    return func();\n+}"}, {"sha": "043202a8f5f0192630832acb2f4e4a0400d5aae9", "filename": "gcc/testsuite/gdc.dg/attr_optimize1.d", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_optimize1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_optimize1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_optimize1.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,48 @@\n+// { dg-do compile }\n+\n+import gcc.attributes;\n+\n+int func()\n+{\n+    int return_zero() @optimize(0)\n+    {\n+        return 0;\n+    }\n+\n+    int return_one() @optimize(\"0\")\n+    {\n+        return 1;\n+    }\n+\n+    int return_two() @optimize(\"s\")\n+    {\n+        return 2;\n+    }\n+\n+    int return_three() @optimize(\"O3\")\n+    {\n+        return 3;\n+    }\n+\n+    int return_four() @optimize(\"fast-math\")\n+    {\n+        return 4;\n+    }\n+\n+    return return_one + return_two + return_three + return_four;\n+}\n+\n+@optimize(3)\n+int var = 0; // { dg-warning \".optimize. attribute ignored\" }\n+\n+@optimize(\"-f_\")\n+int bad_option() // { dg-warning \"bad option .-f_. to attribute .optimize.\" }\n+{\n+    return 0;\n+}\n+\n+@optimize(\"-z\")\n+int bad_option2() // { dg-warning \"bad option .-z. to attribute .optimize.\" }\n+{\n+    return 0;\n+}"}, {"sha": "13bc1d7cb6ed6c1e1e310776801d4cca8953b69b", "filename": "gcc/testsuite/gdc.dg/attr_optimize2.d", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_optimize2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_optimize2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_optimize2.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,9 @@\n+// { dg-do compile }\n+\n+import gcc.attributes;\n+\n+@optimize(-1)\n+int non_negative() // { dg-error \"argument to .-O. should be a non-negative integer\" }\n+{\n+    return 0;\n+}"}, {"sha": "2a9ad1230366c2ec705d68fd10dba415a38d3cbe", "filename": "gcc/testsuite/gdc.dg/attr_optimize3.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_optimize3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_optimize3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_optimize3.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile }\n+// { dg-options \"-O0 -fdump-tree-optimized-raw\" }\n+\n+import gcc.attributes;\n+\n+double notfast(double x)\n+{\n+    return x * x * x * x * x * x * x * x;\n+}\n+\n+// { dg-final { scan-tree-dump-times \"mult_expr, _\" 7 \"optimized\" } }\n+\n+@fastmath\n+static double fast(double x)\n+{\n+    return x * x * x * x * x * x * x * x;\n+}\n+\n+// { dg-final { scan-tree-dump-times \"mult_expr, powmult_\" 3 \"optimized\" } }"}, {"sha": "54d793ed94f07feb3be4c4d4344da0801eb28407", "filename": "gcc/testsuite/gdc.dg/attr_optimize4.d", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_optimize4.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_optimize4.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_optimize4.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,45 @@\n+// { dg-do compile }\n+// { dg-options \"-O3 -fdump-tree-optimized-raw\" }\n+\n+import gcc.attributes;\n+\n+int glob1;\n+int easily_inlinable(int i) { glob1 = i; return 2; }\n+\n+@optStrategy(\"none\")\n+int call_easily_inlinable(int i)\n+{\n+    return easily_inlinable(i);\n+}\n+\n+// { dg-final { scan-tree-dump \"gimple_call <easily_inlinable\" \"optimized\" } }\n+\n+pragma(inline, true) int always_inline() { return 321; }\n+\n+@optStrategy(\"none\")\n+int call_always_inline()\n+{\n+    return always_inline();\n+}\n+\n+// { dg-final { scan-tree-dump \"gimple_call <always_inline\" \"optimized\" } }\n+\n+int glob2;\n+@optStrategy(\"none\") void optnone_function(int i) { glob2 = i; }\n+\n+void call_optnone()\n+{\n+    optnone_function(1);\n+}\n+\n+// { dg-final { scan-tree-dump \"gimple_call <optnone_function\" \"optimized\" } }\n+\n+@optStrategy(\"optsize\")\n+void optsize_fn()\n+{\n+}\n+\n+@optStrategy(\"minsize\")\n+void minsize_fn()\n+{\n+}"}, {"sha": "26839c3c00037c7113328bf999ec50701fee6e70", "filename": "gcc/testsuite/gdc.dg/attr_restrict1.d", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_restrict1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_restrict1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_restrict1.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile }\n+// { dg-options \"-fdump-tree-optimized\" }\n+\n+import gcc.attributes;\n+\n+int func(@restrict int ignored) // { dg-warning \".restrict. attribute ignored\" }\n+{\n+    return 0;\n+}\n+\n+int func(@restrict int *parm)\n+{\n+    return 0;\n+}\n+\n+@restrict int var = 0; // { dg-warning \".restrict. attribute ignored\" }\n+\n+// { dg-final { scan-tree-dump \"restrict parm\" \"optimized\" } }"}, {"sha": "c24634f7fd52bbf06ea993171a04731dcc759349", "filename": "gcc/testsuite/gdc.dg/attr_section1.d", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_section1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_section1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_section1.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do compile }\n+// { dg-require-named-sections \"\" }\n+\n+import gcc.attributes;\n+\n+@section(\"types\")\n+struct S {} // { dg-warning \".section. attribute does not apply to types\" }\n+\n+@attribute(\"section\", 123)\n+int f1(); // { dg-error \"section attribute argument not a string constant\" }\n+\n+int f2(@section(\"param\") int a) // { dg-error \"section attribute not allowed for .a.\" }\n+{\n+    @section(\"local\") int v; // { dg-error \"section attribute cannot be specified for local variables\" }\n+    return a;\n+}\n+\n+@section(\"c1\") void conflict(); \n+@section(\"c2\") void conflict(); // { dg-error \"section of .conflict. conflicts with previous declaration\" }\n+\n+@section(\"c3\")\n+@section(\"c4\")\n+void conflict2(); // { dg-error \"section of .conflict2. conflicts with previous declaration\" }"}, {"sha": "8a680cbab7b45757472ba4f5d3abee2c6e41579a", "filename": "gcc/testsuite/gdc.dg/attr_symver1.d", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_symver1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_symver1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_symver1.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,24 @@\n+// { dg-do compile }\n+// { dg-skip-if \"only works for ELF targets\" { *-*-darwin* *-*-aix* } }\n+\n+import gcc.attributes;\n+\n+@symver(\"type\")\n+struct S {} // { dg-warning \".symver. attribute does not apply to types\" }\n+\n+@attribute(\"symver\", 123)\n+int f1(); // { dg-error \".symver. attribute argument not a string constant\" }\n+\n+@symver(\"format\")\n+int f2() // { dg-error \"symver attribute argument must have format .name@nodename'\" }\n+{ // { dg-error \".symver. attribute argument .format. must contain one or two .@.\" \"\" { target *-*-* } .-1 }\n+    return 0;\n+}\n+\n+int f3(@symver(\"param@VER_1\") int param) // { dg-warning \".symver. attribute only applies to functions and variables\" }\n+{\n+    return param;\n+}\n+\n+@symver(\"extern@VER_2\")\n+extern int f4(); // { dg-error \"symbol needs to be defined to have a version\" }"}, {"sha": "4cf89f34dda8c4c6a890ae878da8898161e810f5", "filename": "gcc/testsuite/gdc.dg/attr_target1.d", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_target1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_target1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_target1.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do compile { target i?86*-*-* x86_64-*-* } }\n+\n+import gcc.attributes;\n+\n+@target(\"default\")\n+int foo() { return 1; }\n+\n+@target(\"arch=core2\", \"\")\n+int foo2() { return 2; } // { dg-warning \"empty string in attribute .target.\" }\n+\n+@target(\"sse4.2\", \"\", \"\")\n+int foo3() { return 3; } // { dg-warning \"empty string in attribute .target.\" }\n+\n+@target(\"default\")\n+int var = 0; // { dg-warning \".target. attribute ignored\" }\n+\n+int main()\n+{\n+    return foo() + foo2() + foo3();\n+}"}, {"sha": "287782c370904a049cb47ca456025d103bd48f76", "filename": "gcc/testsuite/gdc.dg/attr_targetclones1.d", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_targetclones1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_targetclones1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_targetclones1.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile { target i?86*-*-* x86_64-*-* } }\n+\n+import gcc.attributes;\n+\n+@target_clones(\"default\")\n+int func() // { dg-warning \"single .target_clones. attribute is ignored\" }\n+{\n+    return 0;\n+}\n+\n+@target_clones(\"default\")\n+int var = 0; // { dg-warning \".target_clones. attribute ignored\" }"}, {"sha": "66f33fbab004006795e5317d0a4acafeb916194f", "filename": "gcc/testsuite/gdc.dg/attr_used1.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_used1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_used1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_used1.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile }\n+// { dg-options \"-O2\" }\n+\n+import gcc.attributes;\n+\n+int func()\n+{\n+    int nested_function() @used\n+    {\n+        return 1;\n+    }\n+    @used int var = 0; // { dg-warning \".used. attribute ignored\" }\n+    return var;\n+}\n+\n+// { dg-final { scan-assembler \"nested_function\" } }"}, {"sha": "bac004d3f9c2aff14e0471a1a3acf3374e1f328d", "filename": "gcc/testsuite/gdc.dg/attr_used2.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_used2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_used2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_used2.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile }\n+// { dg-options \"-O2\" }\n+\n+import gcc.attributes;\n+\n+int func()\n+{\n+    int nested_function() @assumeUsed\n+    {\n+        return 1;\n+    }\n+    @assumeUsed int var = 0; // { dg-warning \".used. attribute ignored\" }\n+    return var;\n+}\n+\n+// { dg-final { scan-assembler \"nested_function\" } }"}, {"sha": "0b84454b3ff8ba2c3a1f4f535628a0dfe64ce784", "filename": "gcc/testsuite/gdc.dg/attr_weak1.d", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_weak1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_weak1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fattr_weak1.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile }\n+\n+import gcc.attributes;\n+\n+pragma(inline, true)\n+@weak int func() // { dg-warning \"inline function .func. declared weak\" }\n+{\n+    return 0;\n+}\n+\n+int parm(@weak int a) // { dg-warning \".weak. attribute ignored\" }\n+{\n+    return a;\n+}"}, {"sha": "8f9116bba250cb1af08bd3b9a56a9993436ce79d", "filename": "gcc/testsuite/gdc.dg/gdc108.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fgdc108.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fgdc108.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fgdc108.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -1,9 +1,9 @@\n // https://bugzilla.gdcproject.org/show_bug.cgi?id=108\n // { dg-do compile }\n \n-import gcc.attribute;\n+import gcc.attributes;\n \n-@attribute(\"forceinline\")\n+@attribute(\"always_inline\")\n void forceinline108()\n {\n }"}, {"sha": "7713d5e9dab575906ce272839b27bf8ce3b4cfa6", "filename": "gcc/testsuite/gdc.dg/gdc142.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fgdc142.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fgdc142.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fgdc142.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -1,7 +1,7 @@\n // https://bugzilla.gdcproject.org/show_bug.cgi?id=142\n // { dg-do compile }\n \n-import gcc.attribute;\n+import gcc.attributes;\n \n @attribute(\"noinline\")\n int test142a()()"}, {"sha": "1ed209497dc3660d85ea2957486a839267d039f5", "filename": "gcc/testsuite/gdc.dg/imports/attributes.d", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fimports%2Fattributes.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fimports%2Fattributes.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fimports%2Fattributes.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,28 @@\n+// Pretend to be the GDC attributes module.\n+module gcc.attributes;\n+\n+immutable value_ignored = 42;\n+\n+enum type_symbol { _ }\n+\n+auto template_symbol(A...)(A arguments)\n+{\n+    return arguments;\n+}\n+\n+struct struct_wrong_field\n+{\n+    int bad_field;\n+}\n+\n+struct struct_void_init\n+{\n+    string name_field = \"noinline\";\n+    int void_field = void;\n+    string ignored;\n+}\n+\n+struct unknown_attribute\n+{\n+    string name_field = \"made up name\";\n+}"}, {"sha": "e576fffec3d332342280dbf5113c432b6a13ba7e", "filename": "gcc/testsuite/gdc.dg/pr90136a.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fpr90136a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fpr90136a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr90136a.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -3,9 +3,9 @@\n // { dg-options \"-fdump-tree-optimized\" }\n // { dg-final { scan-tree-dump-times \"sum_array \\\\(array\\\\)\" 0 \"optimized\"} }\n \n-import gcc.attribute;\n+import gcc.attributes;\n \n-@attribute(\"forceinline\") int sum_array(int[] input);\n+@attribute(\"always_inline\") int sum_array(int[] input);\n \n int sum_array(int[] input)\n {"}, {"sha": "8e8d9d5e3c1b0dc14a1605e38e5cae186c84ad4a", "filename": "gcc/testsuite/gdc.dg/pr90136b.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fpr90136b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fpr90136b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr90136b.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -3,7 +3,7 @@\n // { dg-options \"-fdump-tree-optimized\" }\n // { dg-final { scan-tree-dump-times \"sum_array \\\\(array\\\\)\" 1 \"optimized\"} }\n \n-import gcc.attribute;\n+import gcc.attributes;\n \n @attribute(\"noinline\") int sum_array(int[] input);\n "}, {"sha": "534a7343ec4dae79569bd5a55eda4433970c9dba", "filename": "gcc/testsuite/gdc.dg/pr90136c.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fpr90136c.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fpr90136c.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr90136c.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -2,8 +2,8 @@\n // { dg-do compile }\n // { dg-options \"-Wattributes\" }\n \n-import gcc.attribute;\n+import gcc.attributes;\n \n-@attribute(\"forceinline\") int sum_array(int[] input);\n+@attribute(\"always_inline\") int sum_array(int[] input);\n @attribute(\"noinline\") int sum_array(int[] input);\n-// { dg-warning \"ignoring attribute .noinline. because it conflicts with attribute .forceinline.\" \"\" { target *-*-* } .-1 }\n+// { dg-warning \"ignoring attribute .noinline. because it conflicts with attribute .always_inline.\" \"\" { target *-*-* } .-1 }"}, {"sha": "100378357de5501f2823c904ce47ba7eff764db9", "filename": "gcc/testsuite/gdc.dg/pr95173.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fpr95173.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/gcc%2Ftestsuite%2Fgdc.dg%2Fpr95173.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr95173.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -2,7 +2,7 @@\n // { dg-do compile }\n // { dg-options \"-Wattributes\" }\n \n-import gcc.attribute;\n+import gcc.attributes;\n \n @attribute(\"foo\") // { dg-warning \"unknown attribute .foo.\" }\n void f95173() "}, {"sha": "5137f85b57143c32657dabd061bb3236824b1ce4", "filename": "libphobos/libdruntime/Makefile.am", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/libphobos%2Flibdruntime%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/libphobos%2Flibdruntime%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.am?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -184,8 +184,8 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/thread/threadbase.d core/thread/threadgroup.d core/thread/types.d \\\n \tcore/time.d core/vararg.d core/volatile.d gc/bits.d gc/config.d \\\n \tgc/gcinterface.d gc/impl/conservative/gc.d gc/impl/manual/gc.d gc/os.d \\\n-\tgc/pooltable.d gc/proxy.d gcc/attribute.d gcc/backtrace.d \\\n-\tgcc/builtins.d gcc/deh.d gcc/emutls.d gcc/gthread.d \\\n+\tgc/pooltable.d gc/proxy.d gcc/attribute.d gcc/attributes.d \\\n+\tgcc/backtrace.d gcc/builtins.d gcc/deh.d gcc/emutls.d gcc/gthread.d \\\n \tgcc/sections/android.d gcc/sections/elf_shared.d gcc/sections/osx.d \\\n \tgcc/sections/package.d gcc/sections/win32.d gcc/sections/win64.d \\\n \tgcc/unwind/arm.d gcc/unwind/arm_common.d gcc/unwind/c6x.d \\"}, {"sha": "4a93b4921a487acffd3883c9ed4e4e2eecae5ca8", "filename": "libphobos/libdruntime/Makefile.in", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/libphobos%2Flibdruntime%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/libphobos%2Flibdruntime%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.in?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -209,11 +209,12 @@ am__objects_1 = core/atomic.lo core/attribute.lo core/bitop.lo \\\n \tcore/thread/types.lo core/time.lo core/vararg.lo \\\n \tcore/volatile.lo gc/bits.lo gc/config.lo gc/gcinterface.lo \\\n \tgc/impl/conservative/gc.lo gc/impl/manual/gc.lo gc/os.lo \\\n-\tgc/pooltable.lo gc/proxy.lo gcc/attribute.lo gcc/backtrace.lo \\\n-\tgcc/builtins.lo gcc/deh.lo gcc/emutls.lo gcc/gthread.lo \\\n-\tgcc/sections/android.lo gcc/sections/elf_shared.lo \\\n-\tgcc/sections/osx.lo gcc/sections/package.lo \\\n-\tgcc/sections/win32.lo gcc/sections/win64.lo gcc/unwind/arm.lo \\\n+\tgc/pooltable.lo gc/proxy.lo gcc/attribute.lo gcc/attributes.lo \\\n+\tgcc/backtrace.lo gcc/builtins.lo gcc/deh.lo gcc/emutls.lo \\\n+\tgcc/gthread.lo gcc/sections/android.lo \\\n+\tgcc/sections/elf_shared.lo gcc/sections/osx.lo \\\n+\tgcc/sections/package.lo gcc/sections/win32.lo \\\n+\tgcc/sections/win64.lo gcc/unwind/arm.lo \\\n \tgcc/unwind/arm_common.lo gcc/unwind/c6x.lo \\\n \tgcc/unwind/generic.lo gcc/unwind/package.lo gcc/unwind/pe.lo \\\n \tobject.lo rt/aApply.lo rt/aApplyR.lo rt/aaA.lo rt/adi.lo \\\n@@ -816,8 +817,8 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/thread/threadbase.d core/thread/threadgroup.d core/thread/types.d \\\n \tcore/time.d core/vararg.d core/volatile.d gc/bits.d gc/config.d \\\n \tgc/gcinterface.d gc/impl/conservative/gc.d gc/impl/manual/gc.d gc/os.d \\\n-\tgc/pooltable.d gc/proxy.d gcc/attribute.d gcc/backtrace.d \\\n-\tgcc/builtins.d gcc/deh.d gcc/emutls.d gcc/gthread.d \\\n+\tgc/pooltable.d gc/proxy.d gcc/attribute.d gcc/attributes.d \\\n+\tgcc/backtrace.d gcc/builtins.d gcc/deh.d gcc/emutls.d gcc/gthread.d \\\n \tgcc/sections/android.d gcc/sections/elf_shared.d gcc/sections/osx.d \\\n \tgcc/sections/package.d gcc/sections/win32.d gcc/sections/win64.d \\\n \tgcc/unwind/arm.d gcc/unwind/arm_common.d gcc/unwind/c6x.d \\\n@@ -1209,6 +1210,7 @@ gcc/$(am__dirstamp):\n \t@$(MKDIR_P) gcc\n \t@: > gcc/$(am__dirstamp)\n gcc/attribute.lo: gcc/$(am__dirstamp)\n+gcc/attributes.lo: gcc/$(am__dirstamp)\n gcc/backtrace.lo: gcc/$(am__dirstamp)\n gcc/builtins.lo: gcc/$(am__dirstamp)\n gcc/deh.lo: gcc/$(am__dirstamp)"}, {"sha": "d1ff5c712716af51eda8f42a4cc54dc1bed3e1ac", "filename": "libphobos/libdruntime/gcc/attribute.d", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/libphobos%2Flibdruntime%2Fgcc%2Fattribute.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/libphobos%2Flibdruntime%2Fgcc%2Fattribute.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fattribute.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -20,14 +20,7 @@\n // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n // <http://www.gnu.org/licenses/>.\n \n+deprecated(\"Import gcc.attributes instead\")\n module gcc.attribute;\n \n-private struct Attribute(A...)\n-{\n-    A args;\n-}\n-\n-auto attribute(A...)(A args) if (A.length > 0 && is(A[0] == string))\n-{\n-    return Attribute!A(args);\n-}\n+public import gcc.attributes;"}, {"sha": "58a4023edcacbda1d8c5ee5b9f0b903ab50afe39", "filename": "libphobos/libdruntime/gcc/attributes.d", "status": "added", "additions": 605, "deletions": 0, "changes": 605, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/libphobos%2Flibdruntime%2Fgcc%2Fattributes.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/libphobos%2Flibdruntime%2Fgcc%2Fattributes.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fattributes.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -0,0 +1,605 @@\n+// GNU D Compiler attribute support declarations.\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+module gcc.attributes;\n+\n+// Private helper templates.\n+private struct Attribute(A...)\n+{\n+    A arguments;\n+}\n+\n+private enum bool isStringValue(alias T) = is(typeof(T) == string);\n+\n+private enum bool isStringOrIntValue(alias T)\n+    = is(typeof(T) == string) || is(typeof(T) == int);\n+\n+private template allSatisfy(alias F, T...)\n+{\n+    static if (T.length == 0)\n+        enum allSatisfy = true;\n+    else static if (T.length == 1)\n+        enum allSatisfy = F!(T[0]);\n+    else\n+    {\n+        enum allSatisfy = allSatisfy!(F, T[ 0  .. $/2])\n+            && allSatisfy!(F, T[$/2 ..  $ ]);\n+    }\n+}\n+\n+/**\n+ * Generic entrypoint for applying GCC attributes to a function or type.\n+ * There is no type checking done, as well as no deprecation path for\n+ * attributes removed from the compiler.  So the recommendation is to use any\n+ , of the other UDAs available unless it is a target-specific attribute.\n+ *\n+ * Function attributes introduced by the @attribute UDA are used in the\n+ * declaration of a function, followed by an attribute name string and\n+ * any arguments separated by commas enclosed in parentheses.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @attribute(\"regparm\", 1) int func(int size);\n+ * ---\n+ */\n+@system\n+auto attribute(A...)(A arguments)\n+    if (A.length > 0 && is(A[0] == string))\n+{\n+    return Attribute!A(arguments);\n+}\n+\n+\n+///////////////////////////////////////////////////////////////////////////////\n+//\n+// Supported common attributes exposed by GDC.\n+//\n+///////////////////////////////////////////////////////////////////////////////\n+\n+/**\n+ * The `@alloc_size` attribute may be applied to a function that returns a\n+ * pointer and takes at least one argument of an integer or enumerated type.\n+ * It indicates that the returned pointer points to memory whose size is given\n+ * by the function argument at `sizeArgIdx`, or by the product of the arguments\n+ * at `sizeArgIdx` and `numArgIdx`.  Meaningful sizes are positive values less\n+ * than `ptrdiff_t.max`.  Unless `zeroBasedNumbering` is true, argument\n+ * numbering starts at one for ordinary functions, and at two for non-static\n+ * member functions.\n+ *\n+ * If `numArgIdx` is less than `0`, it is taken to mean there is no argument\n+ * specifying the element count.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @alloc_size(1) extern(C) void* malloc(size_t size);\n+ * @alloc_size(3,2) extern(C) void* reallocarray(void *ptr, size_t nmemb,\n+ *                                               size_t size);\n+ * @alloc_size(1,2) void* my_calloc(size_t element_size, size_t count,\n+ *                                  bool irrelevant);\n+ * ---\n+ */\n+auto alloc_size(int sizeArgIdx)\n+{\n+    return attribute(\"alloc_size\", sizeArgIdx);\n+}\n+\n+/// ditto\n+auto alloc_size(int sizeArgIdx, int numArgIdx)\n+{\n+    return attribute(\"alloc_size\", sizeArgIdx, numArgIdx);\n+}\n+\n+/// ditto\n+auto alloc_size(int sizeArgIdx, int numArgIdx, bool zeroBasedNumbering)\n+{\n+    return attribute(\"alloc_size\", sizeArgIdx, numArgIdx, zeroBasedNumbering);\n+}\n+\n+auto alloc_size(A...)(A arguments)\n+{\n+    assert(false, \"alloc_size attribute argument value is not an integer constant\");\n+}\n+\n+/**\n+ * The `@always_inline` attribute inlines the function independent of any\n+ * restrictions that otherwise apply to inlining.  Failure to inline such a\n+ * function is diagnosed as an error.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @always_inline int func();\n+ * ---\n+ */\n+enum always_inline = attribute(\"always_inline\");\n+\n+/**\n+ * The `@cold` attribute on functions is used to inform the compiler that the\n+ * function is unlikely to be executed.  The function is optimized for size\n+ * rather than speed and on many targets it is placed into a special subsection\n+ * of the text section so all cold functions appear close together, improving\n+ * code locality of non-cold parts of program.  The paths leading to calls of\n+ * cold functions within code are considered to be cold too.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @cold int func();\n+ * ---\n+ */\n+enum cold = attribute(\"cold\");\n+\n+/**\n+ * The `@flatten` attribute is used to inform the compiler that every call\n+ * inside this function should be inlined, if possible.  Functions declared with\n+ * attribute `@noinline` and similar are not inlined.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @flatten int func();\n+ * ---\n+ */\n+enum flatten = attribute(\"flatten\");\n+\n+/**\n+ * The `@no_icf` attribute prevents a functions from being merged with another\n+ * semantically equivalent function.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @no_icf int func();\n+ * ---\n+ */\n+enum no_icf = attribute(\"no_icf\");\n+\n+/**\n+ * The `@noclone` attribute prevents a function from being considered for\n+ * cloning - a mechanism that produces specialized copies of functions and\n+ * which is (currently) performed by interprocedural constant propagation.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @noclone int func();\n+ * ---\n+ */\n+enum noclone = attribute(\"noclone\");\n+\n+/**\n+ * The `@noinline` attribute prevents a function from being considered for\n+ * inlining.  If the function does not have side effects, there are\n+ * optimizations other than inlining that cause function calls to be optimized\n+ * away, although the function call is live.  To keep such calls from being\n+ * optimized away, put `asm { \"\"; }` in the called function, to serve as a\n+ * special side effect.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @noinline int func();\n+ * ---\n+ */\n+enum noinline = attribute(\"noinline\");\n+\n+/**\n+ * The `@noipa` attribute disables interprocedural optimizations between the\n+ * function with this attribute and its callers, as if the body of the function\n+ * is not available when optimizing callers and the callers are unavailable when\n+ * optimizing the body.  This attribute implies `@noinline`, `@noclone`, and\n+ * `@no_icf` attributes.  However, this attribute is not equivalent to a\n+ * combination of other attributes, because its purpose is to suppress existing\n+ * and future optimizations employing interprocedural analysis, including those\n+ * that do not have an attribute suitable for disabling them individually.\n+ *\n+ * This attribute is supported mainly for the purpose of testing the compiler.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @noipa int func();\n+ * ---\n+ */\n+enum noipa = attribute(\"noipa\");\n+\n+/**\n+ * The `@optimize` attribute is used to specify that a function is to be\n+ * compiled with different optimization options than specified on the command\n+ * line.  Valid `arguments` are constant non-negative integers and strings.\n+ * Multiple arguments can be provided, separated by commas to specify multiple\n+ * options.  Each numeric argument specifies an optimization level.  Each string\n+ * argument that begins with the letter O refers to an optimization option such\n+ * as `-O0` or `-Os`.  Other options are taken as suffixes to the `-f` prefix\n+ * jointly forming the name of an optimization option.\n+ *\n+ * Not every optimization option that starts with the `-f` prefix specified by\n+ * the attribute necessarily has an effect on the function.  The `@optimize`\n+ * attribute should be used for debugging purposes only.  It is not suitable in\n+ * production code.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @optimize(2) double fn0(double x);\n+ * @optimize(\"2\") double fn1(double x);\n+ * @optimize(\"s\") double fn2(double x);\n+ * @optimize(\"Ofast\") double fn3(double x);\n+ * @optimize(\"-O2\") double fn4(double x);\n+ * @optimize(\"tree-vectorize\") double fn5(double x);\n+ * @optimize(\"-ftree-vectorize\") double fn6(double x);\n+ * @optimize(\"no-finite-math-only\", 3) double fn7(double x);\n+ * ---\n+ */\n+auto optimize(A...)(A arguments)\n+    if (allSatisfy!(isStringOrIntValue, arguments))\n+{\n+    return attribute(\"optimize\", arguments);\n+}\n+\n+auto optimize(A...)(A arguments)\n+    if (!allSatisfy!(isStringOrIntValue, arguments))\n+{\n+    assert(false, \"optimize attribute argument not a string or integer constant\");\n+}\n+\n+/**\n+ * The `@restrict` attribute specifies that a function parameter is to be\n+ * restrict-qualified in the C99 sense of the term.  The parameter needs to\n+ * boil down to either a pointer or reference type, such as a D pointer,\n+ * class reference, or a `ref` parameter.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * void func(@restrict ref const float[16] array);\n+ * ---\n+ */\n+enum restrict = attribute(\"restrict\");\n+\n+/**\n+ * The `@section` attribute specifies that a function lives in a particular\n+ * section.  For when you need certain particular functions to appear in\n+ * special sections.\n+ *\n+ * Some file formats do not support arbitrary sections so the section attribute\n+ * is not available on all platforms.  If you need to map the entire contents\n+ * of a module to a particular section, consider using the facilities of the\n+ * linker instead.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @section(\"bar\") extern void func();\n+ * ---\n+ */\n+auto section(string sectionName)\n+{\n+    return attribute(\"section\", sectionName);\n+}\n+\n+auto section(A...)(A arguments)\n+{\n+    assert(false, \"section attribute argument not a string constant\");\n+}\n+\n+/**\n+ * The `@symver` attribute creates a symbol version on ELF targets.  The syntax\n+ * of the string parameter is `name@nodename`.  The `name` part of the parameter\n+ * is the actual name of the symbol by which it will be externally referenced.\n+ * The `nodename` portion should be the name of a node specified in the version\n+ * script supplied to the linker when building a shared library.  Versioned\n+ * symbol must be defined and must be exported with default visibility.\n+ *\n+ * Finally if the parameter is `name@@nodename` then in addition to creating a\n+ * symbol version (as if `name@nodename` was used) the version will be also used\n+ * to resolve `name` by the linker.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @symver(\"foo@VERS_1\") int foo_v1();\n+ * ---\n+ */\n+auto symver(A...)(A arguments)\n+    if (allSatisfy!(isStringValue, arguments))\n+{\n+    return attribute(\"symver\", arguments);\n+}\n+\n+auto symver(A...)(A arguments)\n+    if (!allSatisfy!(isStringValue, arguments))\n+{\n+    assert(false, \"symver attribute argument not a string constant\");\n+}\n+\n+/**\n+ * The `@target` attribute is used to specify that a function is to be\n+ * compiled with different target options than specified on the command line.\n+ * One or more strings can be provided as arguments, separated by commas to\n+ * specify multiple options.  Each string consists of one or more\n+ * comma-separated suffixes to the `-m` prefix jointly forming the name of a\n+ * machine-dependent option.\n+ *\n+ * The target attribute can be used for instance to have a function compiled\n+ * with a different ISA (instruction set architecture) than the default.\n+ *\n+ * The options supported are specific to each target.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @target(\"arch=core2\") void core2_func();\n+ * @target(\"sse3\") void sse3_func();\n+ * ---\n+ */\n+auto target(A...)(A arguments)\n+    if (allSatisfy!(isStringValue, arguments))\n+{\n+    return attribute(\"target\", arguments);\n+}\n+\n+auto target(A...)(A arguments)\n+    if (!allSatisfy!(isStringValue, arguments))\n+{\n+    assert(false, \"target attribute argument not a string constant\");\n+}\n+\n+/**\n+ * The `@target_clones` attribute is used to specify that a function be cloned\n+ * into multiple versions compiled with different target `options` than\n+ * specified on the command line.  The supported options and restrictions are\n+ * the same as for `@target` attribute.\n+ *\n+ * It also creates a resolver function that dynamically selects a clone suitable\n+ * for current architecture.  The resolver is created only if there is a usage\n+ * of a function with `@target_clones` attribute.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @target_clones(\"sse4.1,avx,default\") double func(double x);\n+ * ---\n+ */\n+auto target_clones(A...)(A arguments)\n+    if (allSatisfy!(isStringValue, arguments))\n+{\n+    return attribute(\"target_clones\", arguments);\n+}\n+\n+auto target_clones(A...)(A arguments)\n+    if (!allSatisfy!(isStringValue, arguments))\n+{\n+    assert(false, \"target attribute argument not a string constant\");\n+}\n+\n+/**\n+ * The `@used` attribute, annotated to a function, means that code must be\n+ * emitted for the function even if it appears that the function is not\n+ * referenced.  This is useful, for example, when the function is referenced\n+ * only in inline assembly.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @used __gshared int var = 0x1000;\n+ * ---\n+ */\n+enum used = attribute(\"used\");\n+\n+/**\n+ * The `@weak` attribute causes a declaration of an external symbol to be\n+ * emitted as a weak symbol rather than a global.  This is primarily useful in\n+ * defining library functions that can be overridden in user code, though it can\n+ * also be used with non-function declarations.  The overriding symbol must have\n+ * the same type as the weak symbol.  In addition, if it designates a variable\n+ * it must also have the same size and alignment as the weak symbol.\n+ *\n+ * Weak symbols are supported for ELF targets, and also for a.out targets when\n+ * using the GNU assembler and linker.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @weak int func() { return 1; }\n+ * ---\n+ */\n+enum weak = attribute(\"weak\");\n+\n+/**\n+ * The `@noplt` attribute is the counterpart to option `-fno-plt`. Calls to\n+ * functions marked with this attribute in position-independent code do not use\n+ * the PLT in position-independent code.\n+ *\n+ * In position-dependant code, a few targets also convert call to functions\n+ * that are marked to not use the PLT to use the GOT instead.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @noplt int func();\n+ *\n+ * ---\n+ */\n+enum noplt = attribute(\"noplt\");\n+\n+///////////////////////////////////////////////////////////////////////////////\n+//\n+// Attributes defined for compatibility with LDC.\n+//\n+///////////////////////////////////////////////////////////////////////////////\n+\n+/**\n+ * Specifies that the function returns `null` or a pointer to at least a\n+ * certain number of allocated bytes. `sizeArgIdx` and `numArgIdx` specify\n+ * the 0-based index of the function arguments that should be used to calculate\n+ * the number of bytes returned.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @allocSize(0) extern(C) void* malloc(size_t size);\n+ * @allocSize(2,1) extern(C) void* reallocarray(void *ptr, size_t nmemb,\n+ *                                              size_t size);\n+ * @allocSize(0,1) void* my_calloc(size_t element_size, size_t count,\n+ *                                 bool irrelevant);\n+ * ---\n+ */\n+auto allocSize(int sizeArgIdx, int numArgIdx = int.min)\n+{\n+    return alloc_size(sizeArgIdx, numArgIdx, true);\n+}\n+\n+auto allocSize(A...)(A arguments)\n+{\n+    assert(false, \"allocSize attribute argument value is not an integer constant\");\n+}\n+\n+/**\n+ * When applied to a global symbol, the compiler, assembler, and linker are\n+ * required to treat the symbol as if there is a reference to the symbol that\n+ * it cannot see (which is why they have to be named).  For example, it\n+ * prevents the deletion by the linker of an unreferenced symbol.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @assumeUsed __gshared int var = 0x1000;\n+ * ---\n+ */\n+alias assumeUsed = used;\n+\n+/// This attribute has no effect.\n+enum dynamicCompile = false;\n+\n+/// ditto\n+enum dynamicCompileConst = false;\n+\n+/// ditto\n+enum dynamicCompileEmit = false;\n+\n+/**\n+ * Explicitly sets \"fast-math\" for a function, enabling aggressive math\n+ * optimizations.  These optimizations may dramatically change the outcome of\n+ * floating point calculations (e.g. because of reassociation).\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @fastmath\n+ * double dot(double[] a, double[] b) {\n+ *     double s = 0;\n+ *     foreach(size_t i; 0..a.length)\n+ *     {\n+ *         // will result in vectorized fused-multiply-add instructions\n+ *         s += a * b;\n+ *     }\n+ *     return s;\n+ * }\n+ * ---\n+ */\n+enum fastmath = optimize(\"Ofast\");\n+\n+/**\n+ * Adds GCC's \"naked\" attribute to a function, disabling function prologue /\n+ * epilogue emission.\n+ * Intended to be used in combination with basic `asm` statement.  While using\n+ * extended `asm` or a mixture of basic `asm` and D code may appear to work,\n+ * they cannot be depended upon to work reliably and are not supported.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @naked void abort() {\n+ *     asm { \"ud2\"; }\n+ * }\n+ * ---\n+ */\n+enum naked = attribute(\"naked\");\n+\n+/**\n+ * Sets the optimization strategy for a function.\n+ * Valid strategies are \"none\", \"optsize\", \"minsize\". The strategies are\n+ * mutually exclusive.\n+ *\n+ * Example:\n+ * ---\n+ * import gcc.attributes;\n+ *\n+ * @optStrategy(\"none\")\n+ * int func() {\n+ *     return call();\n+ * }\n+ * ---\n+ */\n+auto optStrategy(string strategy)\n+{\n+    if (strategy == \"none\")\n+        return optimize(\"O0\");\n+    else if (strategy == \"optsize\" || strategy == \"minsize\")\n+        return optimize(\"Os\");\n+    else\n+    {\n+        assert(false, \"unrecognized parameter `\" ~ strategy\n+               ~ \"` for `gcc.attribute.optStrategy`\");\n+    }\n+}\n+\n+auto optStrategy(A...)(A arguments)\n+{\n+    assert(false, \"optStrategy attribute argument value is not a string constant\");\n+}\n+\n+/**\n+ * When applied to a function, specifies that the function should be optimzed\n+ * by Graphite, GCC's polyhedral optimizer. Useful for optimizing loops for\n+ * data locality, vectorization and parallelism.\n+ *\n+ * Experimental!\n+ *\n+ * Only effective when GDC was built with ISL included.\n+ */\n+enum polly = optimize(\"loop-parallelize-all\", \"loop-nest-optimize\");"}, {"sha": "2e679320c380b5c7a6246c621c18f90aef815b65", "filename": "libphobos/libdruntime/gcc/deh.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e84a142913a1f3084d415462024964f97356bee/libphobos%2Flibdruntime%2Fgcc%2Fdeh.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e84a142913a1f3084d415462024964f97356bee/libphobos%2Flibdruntime%2Fgcc%2Fdeh.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fdeh.d?ref=8e84a142913a1f3084d415462024964f97356bee", "patch": "@@ -28,7 +28,7 @@ import gcc.unwind;\n import gcc.unwind.pe;\n import gcc.builtins;\n import gcc.config;\n-import gcc.attribute;\n+import gcc.attributes;\n \n extern(C)\n {"}]}