{"sha": "290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjkwZWJjYjc3ZjZmYjYwMzNkM2FhMWVkM2M4ODA3Y2I4NmEzMGM2Zg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2011-11-03T13:53:29Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2011-11-03T13:53:29Z"}, "message": "ipa-prop.c (type_change_info): New fields offset, object, known_current_type and multiple_types_encountered.\n\n2011-11-03  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.c (type_change_info): New fields offset, object,\n\tknown_current_type and multiple_types_encountered.\n\t(extr_type_from_vtbl_ptr_store): New function.\n\t(check_stmt_for_type_change): Use it, set multiple_types_encountered if\n        the result is different from the previous one.\n\t(detect_type_change): Renamed to detect_type_change_1. New parameter\n\tcomp_type.  Set up new fields in tci, build known type jump\n\tfunctions if the new type can be identified.\n\t(detect_type_change): New function.\n\t* tree.h (DECL_CONTEXT): Comment new use.\n\n\t* testsuite/g++.dg/ipa/devirt-c-1.C: Add dump scans.\n\t* testsuite/g++.dg/ipa/devirt-c-2.C: Likewise.\n\t* testsuite/g++.dg/ipa/devirt-c-7.C: New test.\n\t* testsuite/g++.dg/ipa/devirt-c-8.C: Likewise.\n\nFrom-SVN: r180825", "tree": {"sha": "e661722751a83456ce47c31c36a8cf188d06b2aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e661722751a83456ce47c31c36a8cf188d06b2aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "969d578c2df1fd86ad6a29347ddbaa8ff248df75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/969d578c2df1fd86ad6a29347ddbaa8ff248df75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/969d578c2df1fd86ad6a29347ddbaa8ff248df75"}], "stats": {"total": 325, "additions": 309, "deletions": 16}, "files": [{"sha": "0b95499f36f50e654a1c06f40395223bddbdf686", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f", "patch": "@@ -1,3 +1,16 @@\n+2011-11-03  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.c (type_change_info): New fields offset, object,\n+\tknown_current_type and multiple_types_encountered.\n+\t(extr_type_from_vtbl_ptr_store): New function.\n+\t(check_stmt_for_type_change): Use it, set multiple_types_encountered if\n+        the result is different from the previous one.\n+\t(detect_type_change): Renamed to detect_type_change_1. New parameter\n+\tcomp_type.  Set up new fields in tci, build known type jump\n+\tfunctions if the new type can be identified.\n+\t(detect_type_change): New function.\n+\t* tree.h (DECL_CONTEXT): Comment new use.\n+\n 2011-11-03  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/48217"}, {"sha": "0ca3f3a5f837f12737be324a9d43a5d2fa18a7cd", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 105, "deletions": 13, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f", "patch": "@@ -271,8 +271,20 @@ ipa_print_all_jump_functions (FILE *f)\n \n struct type_change_info\n {\n+  /* Offset into the object where there is the virtual method pointer we are\n+     looking for.  */\n+  HOST_WIDE_INT offset;\n+  /* The declaration or SSA_NAME pointer of the base that we are checking for\n+     type change.  */\n+  tree object;\n+  /* If we actually can tell the type that the object has changed to, it is\n+     stored in this field.  Otherwise it remains NULL_TREE.  */\n+  tree known_current_type;\n   /* Set to true if dynamic type change has been detected.  */\n   bool type_maybe_changed;\n+  /* Set to true if multiple types have been encountered.  known_current_type\n+     must be disregarded in that case.  */\n+  bool multiple_types_encountered;\n };\n \n /* Return true if STMT can modify a virtual method table pointer.\n@@ -338,6 +350,50 @@ stmt_may_be_vtbl_ptr_store (gimple stmt)\n   return true;\n }\n \n+/* If STMT can be proved to be an assignment to the virtual method table\n+   pointer of ANALYZED_OBJ and the type associated with the new table\n+   identified, return the type.  Otherwise return NULL_TREE.  */\n+\n+static tree\n+extr_type_from_vtbl_ptr_store (gimple stmt, struct type_change_info *tci)\n+{\n+  HOST_WIDE_INT offset, size, max_size;\n+  tree lhs, rhs, base;\n+\n+  if (!gimple_assign_single_p (stmt))\n+    return NULL_TREE;\n+\n+  lhs = gimple_assign_lhs (stmt);\n+  rhs = gimple_assign_rhs1 (stmt);\n+  if (TREE_CODE (lhs) != COMPONENT_REF\n+      || !DECL_VIRTUAL_P (TREE_OPERAND (lhs, 1))\n+      || TREE_CODE (rhs) != ADDR_EXPR)\n+    return NULL_TREE;\n+  rhs = get_base_address (TREE_OPERAND (rhs, 0));\n+  if (!rhs\n+      || TREE_CODE (rhs) != VAR_DECL\n+      || !DECL_VIRTUAL_P (rhs))\n+    return NULL_TREE;\n+\n+  base = get_ref_base_and_extent (lhs, &offset, &size, &max_size);\n+  if (offset != tci->offset\n+      || size != POINTER_SIZE\n+      || max_size != POINTER_SIZE)\n+    return NULL_TREE;\n+  if (TREE_CODE (base) == MEM_REF)\n+    {\n+      if (TREE_CODE (tci->object) != MEM_REF\n+\t  || TREE_OPERAND (tci->object, 0) != TREE_OPERAND (base, 0)\n+\t  || !tree_int_cst_equal (TREE_OPERAND (tci->object, 1),\n+\t\t\t\t  TREE_OPERAND (base, 1)))\n+\treturn NULL_TREE;\n+    }\n+  else if (tci->object != base)\n+    return NULL_TREE;\n+\n+  return DECL_CONTEXT (rhs);\n+}\n+\n /* Callback of walk_aliased_vdefs and a helper function for\n    detect_type_change to check whether a particular statement may modify\n    the virtual table pointer, and if possible also determine the new type of\n@@ -352,23 +408,28 @@ check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n \n   if (stmt_may_be_vtbl_ptr_store (stmt))\n     {\n+      tree type;\n+      type = extr_type_from_vtbl_ptr_store (stmt, tci);\n+      if (tci->type_maybe_changed\n+\t  && type != tci->known_current_type)\n+\ttci->multiple_types_encountered = true;\n+      tci->known_current_type = type;\n       tci->type_maybe_changed = true;\n       return true;\n     }\n   else\n     return false;\n }\n \n-/* Detect whether the dynamic type of ARG has changed (before callsite CALL) by\n-   looking for assignments to its virtual table pointer.  If it is, return true\n-   and fill in the jump function JFUNC with relevant type information or set it\n-   to unknown.  ARG is the object itself (not a pointer to it, unless\n-   dereferenced).  BASE is the base of the memory access as returned by\n-   get_ref_base_and_extent, as is the offset.  */\n+\n+\n+/* Like detect_type_change but with extra argument COMP_TYPE which will become\n+   the component type part of new JFUNC of dynamic type change is detected and\n+   the new base type is identified.  */\n \n static bool\n-detect_type_change (tree arg, tree base, gimple call,\n-\t\t    struct ipa_jump_func *jfunc, HOST_WIDE_INT offset)\n+detect_type_change_1 (tree arg, tree base, tree comp_type, gimple call,\n+\t\t      struct ipa_jump_func *jfunc, HOST_WIDE_INT offset)\n {\n   struct type_change_info tci;\n   ao_ref ao;\n@@ -381,8 +442,6 @@ detect_type_change (tree arg, tree base, gimple call,\n   if (!flag_devirtualize || !gimple_vuse (call))\n     return false;\n \n-  tci.type_maybe_changed = false;\n-\n   ao.ref = arg;\n   ao.base = base;\n   ao.offset = offset;\n@@ -391,32 +450,65 @@ detect_type_change (tree arg, tree base, gimple call,\n   ao.ref_alias_set = -1;\n   ao.base_alias_set = -1;\n \n+  tci.offset = offset;\n+  tci.object = get_base_address (arg);\n+  tci.known_current_type = NULL_TREE;\n+  tci.type_maybe_changed = false;\n+  tci.multiple_types_encountered = false;\n+\n   walk_aliased_vdefs (&ao, gimple_vuse (call), check_stmt_for_type_change,\n \t\t      &tci, NULL);\n   if (!tci.type_maybe_changed)\n     return false;\n \n-  jfunc->type = IPA_JF_UNKNOWN;\n+  if (!tci.known_current_type\n+      || tci.multiple_types_encountered\n+      || offset != 0)\n+    jfunc->type = IPA_JF_UNKNOWN;\n+  else\n+    {\n+      jfunc->type = IPA_JF_KNOWN_TYPE;\n+      jfunc->value.known_type.base_type = tci.known_current_type;\n+      jfunc->value.known_type.component_type = comp_type;\n+    }\n+\n   return true;\n }\n \n+/* Detect whether the dynamic type of ARG has changed (before callsite CALL) by\n+   looking for assignments to its virtual table pointer.  If it is, return true\n+   and fill in the jump function JFUNC with relevant type information or set it\n+   to unknown.  ARG is the object itself (not a pointer to it, unless\n+   dereferenced).  BASE is the base of the memory access as returned by\n+   get_ref_base_and_extent, as is the offset.  */\n+\n+static bool\n+detect_type_change (tree arg, tree base, gimple call,\n+\t\t    struct ipa_jump_func *jfunc, HOST_WIDE_INT offset)\n+{\n+  return detect_type_change_1 (arg, base, TREE_TYPE (arg), call, jfunc, offset);\n+}\n+\n /* Like detect_type_change but ARG is supposed to be a non-dereferenced pointer\n    SSA name (its dereference will become the base and the offset is assumed to\n    be zero).  */\n \n static bool\n detect_type_change_ssa (tree arg, gimple call, struct ipa_jump_func *jfunc)\n {\n+  tree comp_type;\n+\n   gcc_checking_assert (TREE_CODE (arg) == SSA_NAME);\n   if (!flag_devirtualize\n       || !POINTER_TYPE_P (TREE_TYPE (arg))\n       || TREE_CODE (TREE_TYPE (TREE_TYPE (arg))) != RECORD_TYPE)\n     return false;\n \n+  comp_type = TREE_TYPE (TREE_TYPE (arg));\n   arg = build2 (MEM_REF, ptr_type_node, arg,\n-                build_int_cst (ptr_type_node, 0));\n+\t\tbuild_int_cst (ptr_type_node, 0));\n \n-  return detect_type_change (arg, arg, call, jfunc, 0);\n+  return detect_type_change_1 (arg, arg, comp_type, call, jfunc, 0);\n }\n \n /* Callback of walk_aliased_vdefs.  Flags that it has been invoked to the"}, {"sha": "841d7b034538348e078439fdfeebdbcd9bb97945", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f", "patch": "@@ -1,3 +1,10 @@\n+2011-11-03  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* g++.dg/ipa/devirt-c-1.C: Add dump scans.\n+\t* g++.dg/ipa/devirt-c-2.C: Likewise.\n+\t* g++.dg/ipa/devirt-c-7.C: New test.\n+\t* g++.dg/ipa/devirt-c-8.C: Likewise.\n+\n 2011-11-03  Ira Rosen  <ira.rosen@linaro.org>\n \n \tPR tree-optimization/50912"}, {"sha": "dcd8046597c3466ad5840f4e7c09c899ae16c372", "filename": "gcc/testsuite/g++.dg/ipa/devirt-c-1.C", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-1.C?ref=290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f", "patch": "@@ -1,7 +1,7 @@\n /* Verify that ipa-cp correctly detects the dynamic type of an object\n    under construction when doing devirtualization.  */\n /* { dg-do run } */\n-/* { dg-options \"-O3 -fno-early-inlining -fno-inline\"  } */\n+/* { dg-options \"-O3 -fno-early-inlining -fno-inline -fdump-ipa-cp -fdump-tree-optimized\"  } */\n \n extern \"C\" void abort (void);\n \n@@ -69,3 +69,8 @@ int main (int argc, char *argv[])\n     bah ();\n   return 0;\n }\n+\n+/* { dg-final { scan-ipa-dump \"Discovered a virtual call to a known target.*A::foo\"  \"cp\"  } } */\n+/* { dg-final { scan-tree-dump-times \"OBJ_TYPE_REF\" 0 \"optimized\"} } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "b9a36e29f87c04fd823ff4738762ea1208b525a6", "filename": "gcc/testsuite/g++.dg/ipa/devirt-c-2.C", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-2.C?ref=290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f", "patch": "@@ -1,7 +1,7 @@\n /* Verify that ipa-cp correctly detects the dynamic type of an object\n    under construction when doing devirtualization.  */\n /* { dg-do run } */\n-/* { dg-options \"-O3 -fno-early-inlining -fno-inline\"  } */\n+/* { dg-options \"-O3 -fno-early-inlining -fno-inline -fdump-ipa-cp -fdump-tree-optimized\"  } */\n \n extern \"C\" void abort (void);\n \n@@ -77,3 +77,8 @@ int main (int argc, char *argv[])\n     bah ();\n   return 0;\n }\n+\n+/* { dg-final { scan-ipa-dump \"Discovered a virtual call to a known target.*A::foo\"  \"cp\"  } } */\n+/* { dg-final { scan-tree-dump-times \"OBJ_TYPE_REF\" 0 \"optimized\"} } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "89d04328c182bd0af5de5086a36fd408057a01f0", "filename": "gcc/testsuite/g++.dg/ipa/devirt-c-7.C", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-7.C?ref=290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f", "patch": "@@ -0,0 +1,87 @@\n+/* Verify that ipa-cp will not get confused by placement new constructing an\n+   object within another one when looking for dynamic type change .  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -Wno-attributes\"  } */\n+\n+extern \"C\" void abort (void);\n+namespace std {\n+  typedef __SIZE_TYPE__ size_t;\n+}\n+inline void* __attribute__ ((always_inline))\n+operator new(std::size_t, void* __p) throw()\n+{\n+  return __p;\n+}\n+\n+class A\n+{\n+public:\n+  char data[256];\n+  A();\n+  virtual int foo (int i);\n+};\n+\n+class B : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+class C\n+{\n+public:\n+  C();\n+  virtual double foo (double i);\n+};\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+double C::foo (double i)\n+{\n+  return i + 3.5;\n+}\n+\n+static int __attribute__ ((noinline)) middleman (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+__attribute__ ((always_inline)) C::C ()\n+{\n+}\n+\n+A::A ()\n+{\n+}\n+\n+static  __attribute__ ((noinline)) void bah ()\n+{\n+  class B b;\n+\n+  C *c = new ((void *) &b.data) C;\n+\n+  if (middleman (&b, get_input ()) != 3)\n+    abort ();\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  int i;\n+\n+  for (i = 0; i < 10; i++)\n+    bah ();\n+  return 0;\n+}"}, {"sha": "309644d92acdbd7881842d3ba65906e133559d21", "filename": "gcc/testsuite/g++.dg/ipa/devirt-c-8.C", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-8.C?ref=290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f", "patch": "@@ -0,0 +1,82 @@\n+/* Verify that ipa-cp correctly detects the dynamic type of an object\n+   under construction when doing devirtualization.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fno-early-inlining -fno-inline -fdump-ipa-cp -fdump-tree-optimized\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class A\n+{\n+public:\n+  int data;\n+  A();\n+  virtual int foo (int i);\n+};\n+\n+class B : public A\n+{\n+public:\n+  B();\n+  virtual int foo (int i);\n+};\n+\n+class C : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int C::foo (int i)\n+{\n+  return i + 3;\n+}\n+\n+static int __attribute__ ((noinline))\n+middleman (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+inline __attribute__ ((always_inline)) A::A ()\n+{\n+  if (middleman (this, get_input ()) != 2)\n+    abort ();\n+}\n+\n+inline __attribute__ ((always_inline)) B::B ()\n+{\n+}\n+\n+static void bah ()\n+{\n+  class B b;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  int i;\n+\n+  for (i = 0; i < 10; i++)\n+    bah ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Discovered a virtual call to a known target.*A::foo\"  \"cp\"  } } */\n+/* { dg-final { scan-tree-dump-times \"OBJ_TYPE_REF\" 0 \"optimized\"} } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "00b663726b8f336cc7411eb4f2dae8d1389efb72", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=290ebcb77f6fb6033d3aa1ed3c8807cb86a30c6f", "patch": "@@ -2686,7 +2686,9 @@ struct function;\n     nodes, this points to either the FUNCTION_DECL for the containing\n     function, the RECORD_TYPE or UNION_TYPE for the containing type, or\n     NULL_TREE or a TRANSLATION_UNIT_DECL if the given decl has \"file\n-    scope\".  */\n+    scope\".  In particular, for VAR_DECLs which are virtual table pointers\n+    (they have DECL_VIRTUAL set), we use DECL_CONTEXT to determine the type\n+    they belong to.  */\n #define DECL_CONTEXT(NODE) (DECL_MINIMAL_CHECK (NODE)->decl_minimal.context)\n #define DECL_FIELD_CONTEXT(NODE) \\\n   (FIELD_DECL_CHECK (NODE)->decl_minimal.context)"}]}