{"sha": "ac45df5dba58049cf731c7ce9a20f31b6637604e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM0NWRmNWRiYTU4MDQ5Y2Y3MzFjN2NlOWEyMGYzMWI2NjM3NjA0ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-08T07:46:07Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-08T07:46:07Z"}, "message": "except.c (expand_eh_region_start, [...]): Remove.\n\n\t* except.c (expand_eh_region_start, expand_eh_region_end,\n\texpand_eh_handler, expand_eh_region_end_cleanup,\n\texpand_start_all_catch, expand_start_catch, expand_end_catch,\n\texpand_end_all_catch, expand_eh_region_end_allowed,\n\texpand_eh_region_end_must_not_throw, expand_eh_region_end_throw,\n\texpand_eh_region_end_fixup): Remove.\n\t* stmt.c (struct nesting): Remove stack_level, innermost_stack_block,\n\tcleanups, outer_cleanups, label_chain, exception_region.\n\t(struct goto_fixup): Remove stack_level, cleanup_list_list.\n\t(struct label_chain): Remove.\n\t(struct stmt_status): Remove x_stack_block_stack.\n\t(stack_block_stack, expand_goto_internal, expand_fixup, expand_fixups,\n\tfixup_gotos, save_stack_pointer, expand_decl_cleanup,\n\texpand_decl_cleanup_eh, expand_cleanups, start_cleanup_deferral,\n\tend_cleanup_deferral, last_cleanup_this_contour,\n\tcontaining_blocks_have_cleanups_or_stack_level,\n\tany_pending_cleanups): Remove.\n\t(expand_null_return_1): Take no arguments.\n\t(expand_label, expand_naked_return, expand_return,\n\texpand_start_bindings_and_block, expand_end_bindings, expand_decl,\n\texpand_anon_union_decl, expand_start_case, pushcase, pushcase_range,\n\texpand_end_case_type): Don't use any of them.\n\t* calls.c (expand_call): Likewise.\n\t* dojump.c (do_jump): Likewise.\n\t* function.c (expand_function_end): Likewise.\n\t* expr.c (store_expr, expand_expr_real_1): Likewise.\n\t(safe_from_p): Don't handle WITH_CLEANUP_EXPR, CLEANUP_POINT_EXPR.\n\t(expand_expr_real_1): Don't handle WITH_CLEANUP_EXPR,\n\tCLEANUP_POINT_EXPR, TARGET_EXPR, TRY_CATCH_EXPR, CATCH_EXPR,\n\tEH_FILTER_EXPR, TRY_FINALLY_EXPR, GOTO_SUBROUTINE_EXPR.\n\t* fold-const.c (fold_checksum_tree): Use first_rtl_op.\n\t* gengtype.c (adjust_field_tree_exp): Remove rtl op handling.\n\t* gimplify.c (gimplify_cleanup_point_expr): Renumber operands\n\tfor WITH_CLEANUP_EXPR.\n\t(gimple_push_cleanup): Likewise.\n\t* integrate.c (copy_decl_for_inlining): Don't DECL_TOO_LATE.\n\t* print-tree.c (print_node): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Remove GOTO_SUBROUTINE_EXPR.\n\t* tree.c (first_rtl_op): Always just TREE_CODE_LENGTH.\n\t(has_cleanups): Remove GOTO_SUBROUTINE_EXPR.\n\t* tree.def (WITH_CLEANUP_EXPR): Remove op1 and op2.\n\t(GOTO_SUBROUTINE_EXPR): Remove.\n\t* tree.h (WITH_CLEANUP_EXPR_RTL): Remove.\n\t(DECL_TOO_LATE): Remove.\n\t* except.h, tree.h: Update decls.\nada/\n\t* trans.c (gnat_to_gnu <N_Handled_Sequence_Of_Statements>): Update\n\tcommentary.\ncp/\n\t* cp-tree.h (expand_eh_spec_block): Remove.\njava/\n\t* expr.c (case_identity, get_primitive_array_vtable,\n\tjava_expand_expr, emit_init_test_initialization): Remove.\n\t* java-tree.h (java_expand_expr): Remove.\n\t* lang.c (LANG_HOOKS_EXPAND_EXPR): Remove.\n\nFrom-SVN: r84275", "tree": {"sha": "61dfd284f56a5b01c34603db08a963ed6004572d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61dfd284f56a5b01c34603db08a963ed6004572d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac45df5dba58049cf731c7ce9a20f31b6637604e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac45df5dba58049cf731c7ce9a20f31b6637604e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac45df5dba58049cf731c7ce9a20f31b6637604e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac45df5dba58049cf731c7ce9a20f31b6637604e/comments", "author": null, "committer": null, "parents": [{"sha": "97b0ade303bbfe07ef8b0a9071f718f4d8cd002d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d"}], "stats": {"total": 2005, "additions": 114, "deletions": 1891}, "files": [{"sha": "6ab72383141efb76890ebe0bd4d3252969a385a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -1,3 +1,51 @@\n+2004-07-08  Richard Henderson  <rth@redhat.com>\n+\n+\t* except.c (expand_eh_region_start, expand_eh_region_end, \n+\texpand_eh_handler, expand_eh_region_end_cleanup,\n+\texpand_start_all_catch, expand_start_catch, expand_end_catch,\n+\texpand_end_all_catch, expand_eh_region_end_allowed,\n+\texpand_eh_region_end_must_not_throw, expand_eh_region_end_throw,\n+\texpand_eh_region_end_fixup): Remove.\n+\t* stmt.c (struct nesting): Remove stack_level, innermost_stack_block,\n+\tcleanups, outer_cleanups, label_chain, exception_region.\n+\t(struct goto_fixup): Remove stack_level, cleanup_list_list.\n+\t(struct label_chain): Remove.\n+\t(struct stmt_status): Remove x_stack_block_stack.\n+\t(stack_block_stack, expand_goto_internal, expand_fixup, expand_fixups,\n+\tfixup_gotos, save_stack_pointer, expand_decl_cleanup,\n+\texpand_decl_cleanup_eh, expand_cleanups, start_cleanup_deferral,\n+\tend_cleanup_deferral, last_cleanup_this_contour, \n+\tcontaining_blocks_have_cleanups_or_stack_level,\n+\tany_pending_cleanups): Remove.\n+\t(expand_null_return_1): Take no arguments.\n+\t(expand_label, expand_naked_return, expand_return,\n+\texpand_start_bindings_and_block, expand_end_bindings, expand_decl,\n+\texpand_anon_union_decl, expand_start_case, pushcase, pushcase_range,\n+\texpand_end_case_type): Don't use any of them.\n+\t* calls.c (expand_call): Likewise.\n+\t* dojump.c (do_jump): Likewise.\n+\t* function.c (expand_function_end): Likewise.\n+\t* expr.c (store_expr, expand_expr_real_1): Likewise.\n+\t(safe_from_p): Don't handle WITH_CLEANUP_EXPR, CLEANUP_POINT_EXPR.\n+\t(expand_expr_real_1): Don't handle WITH_CLEANUP_EXPR, \n+\tCLEANUP_POINT_EXPR, TARGET_EXPR, TRY_CATCH_EXPR, CATCH_EXPR, \n+\tEH_FILTER_EXPR, TRY_FINALLY_EXPR, GOTO_SUBROUTINE_EXPR.\n+\t* fold-const.c (fold_checksum_tree): Use first_rtl_op.\n+\t* gengtype.c (adjust_field_tree_exp): Remove rtl op handling.\n+\t* gimplify.c (gimplify_cleanup_point_expr): Renumber operands\n+\tfor WITH_CLEANUP_EXPR.\n+\t(gimple_push_cleanup): Likewise.\n+\t* integrate.c (copy_decl_for_inlining): Don't DECL_TOO_LATE.\n+\t* print-tree.c (print_node): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Remove GOTO_SUBROUTINE_EXPR.\n+\t* tree.c (first_rtl_op): Always just TREE_CODE_LENGTH.\n+\t(has_cleanups): Remove GOTO_SUBROUTINE_EXPR.\n+\t* tree.def (WITH_CLEANUP_EXPR): Remove op1 and op2.\n+\t(GOTO_SUBROUTINE_EXPR): Remove.\n+\t* tree.h (WITH_CLEANUP_EXPR_RTL): Remove.\n+\t(DECL_TOO_LATE): Remove.\n+\t* except.h, tree.h: Update decls.\n+\n 2004-07-08  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* explow.c (optimize_save_area_alloca): Do not accept parameters."}, {"sha": "c4c7c5fd2a13ba371f3859e627cc82618ac199f7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -1,3 +1,8 @@\n+2004-07-08  Richard Henderson  <rth@redhat.com>\n+\n+\t* trans.c (gnat_to_gnu <N_Handled_Sequence_Of_Statements>): Update\n+\tcommentary.\n+\n 2004-07-06  Vincent Celier  <celier@gnat.com>\n \n \t* vms_conv.ads: Minor reformatting."}, {"sha": "da75a353a8e9ecc271778b99aafda099949506b9", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -3236,20 +3236,9 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Handled_Sequence_Of_Statements:\n \n       /* The GCC exception handling mechanism can handle both ZCX and SJLJ\n-\t schemes and we have our own SJLJ mechanism. To call the GCC\n-\t mechanism, we first call expand_eh_region_start if there is at least\n-\t one handler associated with the region.  We then generate code for\n-\t the region and call expand_start_all_catch to announce that the\n-\t associated handlers are going to be generated.\n-\n-\t For each handler we call expand_start_catch, generate code for the\n-\t handler, and then call expand_end_catch.\n-\n-\t After all the handlers, we call expand_end_all_catch.\n-\n-\t Here we deal with the region level calls and the\n-\t N_Exception_Handler branch deals with the handler level calls\n-\t (start_catch/end_catch).\n+\t schemes and we have our own SJLJ mechanism.  To call the GCC\n+\t mechanism, we call add_cleanup, and when we leave the binding,\n+\t end_stmt_group will create the TRY_FINALLY_EXPR.\n \n \t ??? The region level calls down there have been specifically put in\n \t place for a ZCX context and currently the order in which things are"}, {"sha": "b1c226de0e2359c9323a32bbf6262ae187a76294", "filename": "gcc/calls.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -2263,7 +2263,6 @@ expand_call (tree exp, rtx target, int ignore)\n       || !flag_optimize_sibling_calls\n       || !rtx_equal_function_value_matters\n       || current_nesting_level () == 0\n-      || any_pending_cleanups ()\n       || args_size.var\n       || lookup_stmt_eh_region (exp) >= 0)\n     try_tail_call = 0;\n@@ -2343,10 +2342,6 @@ expand_call (tree exp, rtx target, int ignore)\n       /* Do the same for the function address if it is an expression.  */\n       if (!fndecl)\n         addr = fix_unsafe_tree (addr);\n-      /* Expanding one of those dangerous arguments could have added\n-\t cleanups, but otherwise give it a whirl.  */\n-      if (any_pending_cleanups ())\n-\ttry_tail_call = 0;\n     }\n \n \n@@ -2959,16 +2954,6 @@ expand_call (tree exp, rtx target, int ignore)\n \n       /* If value type not void, return an rtx for the value.  */\n \n-      /* If there are cleanups to be called, don't use a hard reg as target.\n-\t We need to double check this and see if it matters anymore.  */\n-      if (any_pending_cleanups ())\n-\t{\n-\t  if (target && REG_P (target)\n-\t      && REGNO (target) < FIRST_PSEUDO_REGISTER)\n-\t    target = 0;\n-\t  sibcall_failure = 1;\n-\t}\n-\n       if (TYPE_MODE (TREE_TYPE (exp)) == VOIDmode\n \t  || ignore)\n \ttarget = const0_rtx;\n@@ -3222,7 +3207,6 @@ expand_call (tree exp, rtx target, int ignore)\n       clear_pending_stack_adjust ();\n       emit_insn (gen_rtx_CLOBBER (VOIDmode, stack_pointer_rtx));\n       emit_move_insn (virtual_stack_dynamic_rtx, stack_pointer_rtx);\n-      save_stack_pointer ();\n     }\n \n   return target;"}, {"sha": "d04b5af2d06e5db7f6a9fcd1384fc9a0e8d1189a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -1,3 +1,7 @@\n+2004-07-08  Richard Henderson  <rth@redhat.com>\n+\n+\t* cp-tree.h (expand_eh_spec_block): Remove.\n+\n 2004-07-07  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (saved_scope): Remove x_previous_class_type and"}, {"sha": "59133c1d74f8e880a956ef1f3ed078f1101f8fbd", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -3833,7 +3833,6 @@ extern void init_exception_processing\t\t(void);\n extern tree expand_start_catch_block\t\t(tree);\n extern void expand_end_catch_block\t\t(void);\n extern void expand_builtin_throw\t\t(void);\n-extern void expand_eh_spec_block\t        (tree);\n extern void expand_exception_blocks\t\t(void);\n extern tree build_exc_ptr\t\t\t(void);\n extern tree build_throw\t\t\t\t(tree);"}, {"sha": "0ce27195b9cf19e3ea255ba8f0e32e5bcd32be17", "filename": "gcc/dojump.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -290,18 +290,14 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n       if (if_false_label == 0)\n         if_false_label = drop_through_label = gen_label_rtx ();\n       do_jump (TREE_OPERAND (exp, 0), if_false_label, NULL_RTX);\n-      start_cleanup_deferral ();\n       do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);\n-      end_cleanup_deferral ();\n       break;\n \n     case TRUTH_ORIF_EXPR:\n       if (if_true_label == 0)\n         if_true_label = drop_through_label = gen_label_rtx ();\n       do_jump (TREE_OPERAND (exp, 0), NULL_RTX, if_true_label);\n-      start_cleanup_deferral ();\n       do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);\n-      end_cleanup_deferral ();\n       break;\n \n     case COMPOUND_EXPR:\n@@ -362,7 +358,6 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \n         do_jump (TREE_OPERAND (exp, 0), label1, NULL_RTX);\n \n-        start_cleanup_deferral ();\n         /* Now the THEN-expression.  */\n         do_jump (TREE_OPERAND (exp, 1),\n                  if_false_label ? if_false_label : drop_through_label,\n@@ -375,7 +370,6 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n         do_jump (TREE_OPERAND (exp, 2),\n            if_false_label ? if_false_label : drop_through_label,\n            if_true_label ? if_true_label : drop_through_label);\n-        end_cleanup_deferral ();\n       }\n       break;\n "}, {"sha": "c66ad32d562d1aa68fa62ba1e188a02850607dfa", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 331, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -260,8 +260,6 @@ static hashval_t t2r_hash (const void *);\n static void add_type_for_runtime (tree);\n static tree lookup_type_for_runtime (tree);\n \n-static struct eh_region *expand_eh_region_end (void);\n-\n static void resolve_fixup_regions (void);\n static void remove_fixup_regions (void);\n static void remove_unreachable_regions (rtx);\n@@ -574,141 +572,6 @@ set_eh_region_tree_label (struct eh_region *region, tree lab)\n   region->tree_label = lab;\n }\n \f\n-/* Start an exception handling region.  All instructions emitted\n-   after this point are considered to be part of the region until\n-   expand_eh_region_end is invoked.  */\n-\n-void\n-expand_eh_region_start (void)\n-{\n-  struct eh_region *new;\n-  rtx note;\n-\n-  if (! doing_eh (0))\n-    return;\n-\n-  new = gen_eh_region (ERT_UNKNOWN, cfun->eh->cur_region);\n-  cfun->eh->cur_region = new;\n-\n-  /* Create a note marking the start of this region.  */\n-  note = emit_note (NOTE_INSN_EH_REGION_BEG);\n-  NOTE_EH_HANDLER (note) = new->region_number;\n-}\n-\n-/* Common code to end a region.  Returns the region just ended.  */\n-\n-static struct eh_region *\n-expand_eh_region_end (void)\n-{\n-  struct eh_region *cur_region = cfun->eh->cur_region;\n-  rtx note;\n-\n-  /* Create a note marking the end of this region.  */\n-  note = emit_note (NOTE_INSN_EH_REGION_END);\n-  NOTE_EH_HANDLER (note) = cur_region->region_number;\n-\n-  /* Pop.  */\n-  cfun->eh->cur_region = cur_region->outer;\n-\n-  return cur_region;\n-}\n-\n-/* Expand HANDLER, which is the operand 1 of a TRY_CATCH_EXPR.  Catch\n-   blocks and C++ exception-specifications are handled specially.  */\n-\n-void\n-expand_eh_handler (tree handler)\n-{\n-  tree inner = expr_first (handler);\n-\n-  switch (TREE_CODE (inner))\n-    {\n-    case CATCH_EXPR:\n-      expand_start_all_catch ();\n-      expand_expr (handler, const0_rtx, VOIDmode, 0);\n-      expand_end_all_catch ();\n-      break;\n-\n-    case EH_FILTER_EXPR:\n-      if (EH_FILTER_MUST_NOT_THROW (handler))\n-\texpand_eh_region_end_must_not_throw (EH_FILTER_FAILURE (handler));\n-      else\n-\texpand_eh_region_end_allowed (EH_FILTER_TYPES (handler),\n-\t\t\t\t      EH_FILTER_FAILURE (handler));\n-      break;\n-\n-    default:\n-      expand_eh_region_end_cleanup (handler);\n-      break;\n-    }\n-}\n-\n-/* End an exception handling region for a cleanup.  HANDLER is an\n-   expression to expand for the cleanup.  */\n-\n-void\n-expand_eh_region_end_cleanup (tree handler)\n-{\n-  struct eh_region *region;\n-  tree protect_cleanup_actions;\n-  rtx around_label;\n-  rtx data_save[2];\n-\n-  if (! doing_eh (0))\n-    return;\n-\n-  region = expand_eh_region_end ();\n-  region->type = ERT_CLEANUP;\n-  region->label = gen_label_rtx ();\n-  region->u.cleanup.exp = handler;\n-  region->u.cleanup.prev_try = cfun->eh->try_region;\n-\n-  around_label = gen_label_rtx ();\n-  emit_jump (around_label);\n-\n-  emit_label (region->label);\n-\n-  if (flag_non_call_exceptions || region->may_contain_throw)\n-    {\n-      /* Give the language a chance to specify an action to be taken if an\n-\t exception is thrown that would propagate out of the HANDLER.  */\n-      protect_cleanup_actions\n-\t= (lang_protect_cleanup_actions\n-\t   ? (*lang_protect_cleanup_actions) ()\n-\t   : NULL_TREE);\n-\n-      if (protect_cleanup_actions)\n-\texpand_eh_region_start ();\n-\n-      /* In case this cleanup involves an inline destructor with a try block in\n-\t it, we need to save the EH return data registers around it.  */\n-      data_save[0] = gen_reg_rtx (ptr_mode);\n-      emit_move_insn (data_save[0], get_exception_pointer (cfun));\n-      data_save[1] = gen_reg_rtx (word_mode);\n-      emit_move_insn (data_save[1], get_exception_filter (cfun));\n-\n-      expand_expr (handler, const0_rtx, VOIDmode, 0);\n-\n-      emit_move_insn (cfun->eh->exc_ptr, data_save[0]);\n-      emit_move_insn (cfun->eh->filter, data_save[1]);\n-\n-      if (protect_cleanup_actions)\n-\texpand_eh_region_end_must_not_throw (protect_cleanup_actions);\n-\n-      /* We need any stack adjustment complete before the around_label.  */\n-      do_pending_stack_adjust ();\n-    }\n-\n-  /* We delay the generation of the _Unwind_Resume until we generate\n-     landing pads.  We emit a marker here so as to get good control\n-     flow data in the meantime.  */\n-  region->resume\n-    = emit_jump_insn (gen_rtx_RESX (VOIDmode, region->region_number));\n-  emit_barrier ();\n-\n-  emit_label (around_label);\n-}\n-\n void\n expand_resx_expr (tree exp)\n {\n@@ -719,197 +582,6 @@ expand_resx_expr (tree exp)\n   emit_barrier ();\n }\n \n-/* End an exception handling region for a try block, and prepares\n-   for subsequent calls to expand_start_catch.  */\n-\n-void\n-expand_start_all_catch (void)\n-{\n-  struct eh_region *region;\n-\n-  if (! doing_eh (1))\n-    return;\n-\n-  region = expand_eh_region_end ();\n-  region->type = ERT_TRY;\n-  region->u.try.prev_try = cfun->eh->try_region;\n-  region->u.try.continue_label = gen_label_rtx ();\n-\n-  cfun->eh->try_region = region;\n-\n-  emit_jump (region->u.try.continue_label);\n-}\n-\n-/* Begin a catch clause.  TYPE is the type caught, a list of such\n-   types, (in the case of Java) an ADDR_EXPR which points to the\n-   runtime type to match, or null if this is a catch-all\n-   clause. Providing a type list enables to associate the catch region\n-   with potentially several exception types, which is useful e.g. for\n-   Ada.  */\n-\n-void\n-expand_start_catch (tree type_or_list)\n-{\n-  struct eh_region *c;\n-  rtx note;\n-\n-  if (! doing_eh (0))\n-    return;\n-\n-  c = gen_eh_region_catch (cfun->eh->try_region, type_or_list);\n-  cfun->eh->cur_region = c;\n-\n-  c->label = gen_label_rtx ();\n-  emit_label (c->label);\n-\n-  note = emit_note (NOTE_INSN_EH_REGION_BEG);\n-  NOTE_EH_HANDLER (note) = c->region_number;\n-}\n-\n-/* End a catch clause.  Control will resume after the try/catch block.  */\n-\n-void\n-expand_end_catch (void)\n-{\n-  if (! doing_eh (0))\n-    return;\n-\n-  expand_eh_region_end ();\n-  emit_jump (cfun->eh->try_region->u.try.continue_label);\n-}\n-\n-/* End a sequence of catch handlers for a try block.  */\n-\n-void\n-expand_end_all_catch (void)\n-{\n-  struct eh_region *try_region;\n-\n-  if (! doing_eh (0))\n-    return;\n-\n-  try_region = cfun->eh->try_region;\n-  cfun->eh->try_region = try_region->u.try.prev_try;\n-\n-  emit_label (try_region->u.try.continue_label);\n-}\n-\n-/* End an exception region for an exception type filter.  ALLOWED is a\n-   TREE_LIST of types to be matched by the runtime.  FAILURE is an\n-   expression to invoke if a mismatch occurs.\n-\n-   ??? We could use these semantics for calls to rethrow, too; if we can\n-   see the surrounding catch clause, we know that the exception we're\n-   rethrowing satisfies the \"filter\" of the catch type.  */\n-\n-void\n-expand_eh_region_end_allowed (tree allowed, tree failure)\n-{\n-  struct eh_region *region;\n-  rtx around_label;\n-\n-  if (! doing_eh (0))\n-    return;\n-\n-  region = expand_eh_region_end ();\n-  region->type = ERT_ALLOWED_EXCEPTIONS;\n-  region->u.allowed.type_list = allowed;\n-  region->label = gen_label_rtx ();\n-\n-  for (; allowed ; allowed = TREE_CHAIN (allowed))\n-    add_type_for_runtime (TREE_VALUE (allowed));\n-\n-  /* We must emit the call to FAILURE here, so that if this function\n-     throws a different exception, that it will be processed by the\n-     correct region.  */\n-\n-  around_label = gen_label_rtx ();\n-  emit_jump (around_label);\n-\n-  emit_label (region->label);\n-  expand_expr (failure, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-  /* We must adjust the stack before we reach the AROUND_LABEL because\n-     the call to FAILURE does not occur on all paths to the\n-     AROUND_LABEL.  */\n-  do_pending_stack_adjust ();\n-\n-  emit_label (around_label);\n-}\n-\n-/* End an exception region for a must-not-throw filter.  FAILURE is an\n-   expression invoke if an uncaught exception propagates this far.\n-\n-   This is conceptually identical to expand_eh_region_end_allowed with\n-   an empty allowed list (if you passed \"std::terminate\" instead of\n-   \"__cxa_call_unexpected\"), but they are represented differently in\n-   the C++ LSDA.  */\n-\n-void\n-expand_eh_region_end_must_not_throw (tree failure)\n-{\n-  struct eh_region *region;\n-  rtx around_label;\n-\n-  if (! doing_eh (0))\n-    return;\n-\n-  region = expand_eh_region_end ();\n-  region->type = ERT_MUST_NOT_THROW;\n-  region->label = gen_label_rtx ();\n-\n-  /* We must emit the call to FAILURE here, so that if this function\n-     throws a different exception, that it will be processed by the\n-     correct region.  */\n-\n-  around_label = gen_label_rtx ();\n-  emit_jump (around_label);\n-\n-  emit_label (region->label);\n-  expand_expr (failure, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  emit_label (around_label);\n-}\n-\n-/* End an exception region for a throw.  No handling goes on here,\n-   but it's the easiest way for the front-end to indicate what type\n-   is being thrown.  */\n-\n-void\n-expand_eh_region_end_throw (tree type)\n-{\n-  struct eh_region *region;\n-\n-  if (! doing_eh (0))\n-    return;\n-\n-  region = expand_eh_region_end ();\n-  region->type = ERT_THROW;\n-  region->u.throw.type = type;\n-}\n-\n-/* End a fixup region.  Within this region the cleanups for the immediately\n-   enclosing region are _not_ run.  This is used for goto cleanup to avoid\n-   destroying an object twice.\n-\n-   This would be an extraordinarily simple prospect, were it not for the\n-   fact that we don't actually know what the immediately enclosing region\n-   is.  This surprising fact is because expand_cleanups is currently\n-   generating a sequence that it will insert somewhere else.  We collect\n-   the proper notion of \"enclosing\" in convert_from_eh_region_ranges.  */\n-\n-void\n-expand_eh_region_end_fixup (tree handler)\n-{\n-  struct eh_region *fixup;\n-\n-  if (! doing_eh (0))\n-    return;\n-\n-  fixup = expand_eh_region_end ();\n-  fixup->type = ERT_FIXUP;\n-  fixup->u.fixup.cleanup_exp = handler;\n-}\n-\n /* Note that the current EH region (if any) may contain a throw, or a\n    call to a function which itself may contain a throw.  */\n \n@@ -962,9 +634,7 @@ get_exception_filter (struct function *fun)\n \f\n /* This section is for the exception handling specific optimization pass.  */\n \n-/* Random access the exception region tree.  It's just as simple to\n-   collect the regions this way as in expand_eh_region_start, but\n-   without having to realloc memory.  */\n+/* Random access the exception region tree.  */\n \n void\n collect_eh_region_array (void)"}, {"sha": "7a5899009ff46516abc134bee62ac98fa86bc4e0", "filename": "gcc/except.h", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -35,52 +35,6 @@ struct eh_region;\n /* Test: is exception handling turned on?  */\n extern int doing_eh (int);\n \n-/* Start an exception handling region.  All instructions emitted after\n-   this point are considered to be part of the region until an\n-   expand_eh_region_end variant is invoked.  */\n-extern void expand_eh_region_start (void);\n-\n-/* End an exception handling region for a cleanup.  HANDLER is an\n-   expression to expand for the cleanup.  */\n-extern void expand_eh_region_end_cleanup (tree);\n-\n-/* End an exception handling region for a try block, and prepares\n-   for subsequent calls to expand_start_catch.  */\n-extern void expand_start_all_catch (void);\n-\n-/* Begin a catch clause.  TYPE is an object to be matched by the\n-   runtime, or a list of such objects, or null if this is a catch-all\n-   clause.  */\n-extern void expand_start_catch (tree);\n-\n-/* End a catch clause.  Control will resume after the try/catch block.  */\n-extern void expand_end_catch (void);\n-\n-/* End a sequence of catch handlers for a try block.  */\n-extern void expand_end_all_catch (void);\n-\n-/* End an exception region for an exception type filter.  ALLOWED is a\n-   TREE_LIST of TREE_VALUE objects to be matched by the runtime.\n-   FAILURE is a function to invoke if a mismatch occurs.  */\n-extern void expand_eh_region_end_allowed (tree, tree);\n-\n-/* End an exception region for a must-not-throw filter.  FAILURE is a\n-   function to invoke if an uncaught exception propagates this far.  */\n-extern void expand_eh_region_end_must_not_throw (tree);\n-\n-/* End an exception region for a throw.  No handling goes on here,\n-   but it's the easiest way for the front-end to indicate what type\n-   is being thrown.  */\n-extern void expand_eh_region_end_throw (tree);\n-\n-/* End a fixup region.  Within this region the cleanups for the immediately\n-   enclosing region are _not_ run.  This is used for goto cleanup to avoid\n-   destroying an object twice.  */\n-extern void expand_eh_region_end_fixup (tree);\n-\n-/* End some sort of EH region, depending on the argument.  */\n-extern void expand_eh_handler (tree);\n-\n /* Note that the current EH region (if any) may contain a throw, or a\n    call to a function which itself may contain a throw.  */\n extern void note_eh_region_may_contain_throw (struct eh_region *);"}, {"sha": "b2e25c751148df132867d23112490bb47e0b4fba", "filename": "gcc/expr.c", "status": "modified", "additions": 12, "deletions": 233, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -4071,16 +4071,12 @@ store_expr (tree exp, rtx target, int want_value)\n       do_pending_stack_adjust ();\n       NO_DEFER_POP;\n       jumpifnot (TREE_OPERAND (exp, 0), lab1);\n-      start_cleanup_deferral ();\n       store_expr (TREE_OPERAND (exp, 1), target, want_value & 2);\n-      end_cleanup_deferral ();\n       emit_queue ();\n       emit_jump_insn (gen_jump (lab2));\n       emit_barrier ();\n       emit_label (lab1);\n-      start_cleanup_deferral ();\n       store_expr (TREE_OPERAND (exp, 2), target, want_value & 2);\n-      end_cleanup_deferral ();\n       emit_queue ();\n       emit_label (lab2);\n       OK_DEFER_POP;\n@@ -6042,10 +6038,10 @@ safe_from_p (rtx x, tree exp, int top_p)\n \t  break;\n \n \tcase WITH_CLEANUP_EXPR:\n-\t  exp_rtl = WITH_CLEANUP_EXPR_RTL (exp);\n-\t  break;\n-\n \tcase CLEANUP_POINT_EXPR:\n+\t  /* Lowered by gimplify.c.  */\n+\t  abort ();\n+\n \tcase SAVE_EXPR:\n \t  return safe_from_p (x, TREE_OPERAND (exp, 0), 0);\n \n@@ -7345,36 +7341,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case OBJ_TYPE_REF:\n       return expand_expr (OBJ_TYPE_REF_EXPR (exp), target, tmode, modifier);\n \n-    case WITH_CLEANUP_EXPR:\n-      if (WITH_CLEANUP_EXPR_RTL (exp) == 0)\n-\t{\n-\t  WITH_CLEANUP_EXPR_RTL (exp)\n-\t    = expand_expr (TREE_OPERAND (exp, 0), target, tmode, modifier);\n-\t  expand_decl_cleanup_eh (NULL_TREE, TREE_OPERAND (exp, 1),\n-\t\t\t\t  CLEANUP_EH_ONLY (exp));\n-\n-\t  /* That's it for this cleanup.  */\n-\t  TREE_OPERAND (exp, 1) = 0;\n-\t}\n-      return WITH_CLEANUP_EXPR_RTL (exp);\n-\n-    case CLEANUP_POINT_EXPR:\n-      {\n-\t/* Start a new binding layer that will keep track of all cleanup\n-\t   actions to be performed.  */\n-\texpand_start_bindings (2);\n-\n-\ttarget_temp_slot_level = temp_slot_level;\n-\n-\top0 = expand_expr (TREE_OPERAND (exp, 0), target, tmode, modifier);\n-\t/* If we're going to use this value, load it up now.  */\n-\tif (! ignore)\n-\t  op0 = force_not_mem (op0);\n-\tpreserve_temp_slots (op0);\n-\texpand_end_bindings (NULL_TREE, 0, 0);\n-      }\n-      return op0;\n-\n     case CALL_EXPR:\n       /* Check for a built-in function.  */\n       if (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n@@ -8180,15 +8146,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  tree then_ = TREE_OPERAND (exp, 1);\n \t  tree else_ = TREE_OPERAND (exp, 2);\n \n-\t  /* If we do not have any pending cleanups or stack_levels\n-\t     to restore, and at least one arm of the COND_EXPR is a\n-\t     GOTO_EXPR to a local label, then we can emit more efficient\n-\t     code by using jumpif/jumpifnot instead of the 'if' machinery.  */\n-\t  if (! optimize\n-\t      || containing_blocks_have_cleanups_or_stack_level ())\n-\t    ;\n-\t  else if (TREE_CODE (then_) == GOTO_EXPR\n-\t\t   && TREE_CODE (GOTO_DESTINATION (then_)) == LABEL_DECL)\n+\t  if (TREE_CODE (then_) == GOTO_EXPR\n+\t      && TREE_CODE (GOTO_DESTINATION (then_)) == LABEL_DECL)\n \t    {\n \t      jumpif (pred, label_rtx (GOTO_DESTINATION (then_)));\n \t      return expand_expr (else_, const0_rtx, VOIDmode, 0);\n@@ -8202,7 +8161,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \t  /* Just use the 'if' machinery.  */\n \t  expand_start_cond (pred, 0);\n-\t  start_cleanup_deferral ();\n \t  expand_expr (then_, const0_rtx, VOIDmode, 0);\n \n \t  exp = else_;\n@@ -8225,7 +8183,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      expand_start_else ();\n \t      expand_expr (exp, const0_rtx, VOIDmode, 0);\n \t    }\n-\t  end_cleanup_deferral ();\n \t  expand_end_cond ();\n \t  return const0_rtx;\n \t}\n@@ -8422,7 +8379,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    else\n \t      jumpifnot (TREE_OPERAND (exp, 0), op0);\n \n-\t    start_cleanup_deferral ();\n \t    if (binary_op && temp == 0)\n \t      /* Just touch the other operand.  */\n \t      expand_expr (TREE_OPERAND (binary_op, 1),\n@@ -8458,7 +8414,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\tmodifier == EXPAND_STACK_PARM ? 2 : 0);\n \t    jumpif (TREE_OPERAND (exp, 0), op0);\n \n-\t    start_cleanup_deferral ();\n \t    if (TREE_TYPE (TREE_OPERAND (exp, 2)) != void_type_node)\n \t      store_expr (TREE_OPERAND (exp, 2), temp,\n \t\t\t  modifier == EXPAND_STACK_PARM ? 2 : 0);\n@@ -8483,7 +8438,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\tmodifier == EXPAND_STACK_PARM ? 2 : 0);\n \t    jumpifnot (TREE_OPERAND (exp, 0), op0);\n \n-\t    start_cleanup_deferral ();\n \t    if (TREE_TYPE (TREE_OPERAND (exp, 1)) != void_type_node)\n \t      store_expr (TREE_OPERAND (exp, 1), temp,\n \t\t\t  modifier == EXPAND_STACK_PARM ? 2 : 0);\n@@ -8497,8 +8451,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    op1 = gen_label_rtx ();\n \t    jumpifnot (TREE_OPERAND (exp, 0), op0);\n \n-\t    start_cleanup_deferral ();\n-\n \t    /* One branch of the cond can be void, if it never returns. For\n \t       example A ? throw : E  */\n \t    if (temp != 0\n@@ -8508,12 +8460,10 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    else\n \t      expand_expr (TREE_OPERAND (exp, 1),\n \t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n-\t    end_cleanup_deferral ();\n \t    emit_queue ();\n \t    emit_jump_insn (gen_jump (op1));\n \t    emit_barrier ();\n \t    emit_label (op0);\n-\t    start_cleanup_deferral ();\n \t    if (temp != 0\n \t\t&& TREE_TYPE (TREE_OPERAND (exp, 2)) != void_type_node)\n \t      store_expr (TREE_OPERAND (exp, 2), temp,\n@@ -8523,107 +8473,13 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n \t  }\n \n-\tend_cleanup_deferral ();\n-\n \temit_queue ();\n \temit_label (op1);\n \tOK_DEFER_POP;\n \n \treturn temp;\n       }\n \n-    case TARGET_EXPR:\n-      {\n-\t/* Something needs to be initialized, but we didn't know\n-\t   where that thing was when building the tree.  For example,\n-\t   it could be the return value of a function, or a parameter\n-\t   to a function which lays down in the stack, or a temporary\n-\t   variable which must be passed by reference.\n-\n-\t   We guarantee that the expression will either be constructed\n-\t   or copied into our original target.  */\n-\n-\ttree slot = TREE_OPERAND (exp, 0);\n-\ttree cleanups = NULL_TREE;\n-\ttree exp1;\n-\n-\tif (TREE_CODE (slot) != VAR_DECL)\n-\t  abort ();\n-\n-\tif (! ignore)\n-\t  target = original_target;\n-\n-\t/* Set this here so that if we get a target that refers to a\n-\t   register variable that's already been used, put_reg_into_stack\n-\t   knows that it should fix up those uses.  */\n-\tTREE_USED (slot) = 1;\n-\n-\tif (target == 0)\n-\t  {\n-\t    if (DECL_RTL_SET_P (slot))\n-\t      {\n-\t\ttarget = DECL_RTL (slot);\n-\t\t/* If we have already expanded the slot, so don't do\n-\t\t   it again.  (mrs)  */\n-\t\tif (TREE_OPERAND (exp, 1) == NULL_TREE)\n-\t\t  return target;\n-\t      }\n-\t    else\n-\t      {\n-\t\ttarget = assign_temp (type, 2, 0, 1);\n-\t\tSET_DECL_RTL (slot, target);\n-\n-\t\t/* Since SLOT is not known to the called function\n-\t\t   to belong to its stack frame, we must build an explicit\n-\t\t   cleanup.  This case occurs when we must build up a reference\n-\t\t   to pass the reference as an argument.  In this case,\n-\t\t   it is very likely that such a reference need not be\n-\t\t   built here.  */\n-\n-\t\tif (TREE_OPERAND (exp, 2) == 0)\n-\t\t  TREE_OPERAND (exp, 2)\n-\t\t    = lang_hooks.maybe_build_cleanup (slot);\n-\t\tcleanups = TREE_OPERAND (exp, 2);\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    /* This case does occur, when expanding a parameter which\n-\t       needs to be constructed on the stack.  The target\n-\t       is the actual stack address that we want to initialize.\n-\t       The function we call will perform the cleanup in this case.  */\n-\n-\t    /* If we have already assigned it space, use that space,\n-\t       not target that we were passed in, as our target\n-\t       parameter is only a hint.  */\n-\t    if (DECL_RTL_SET_P (slot))\n-\t      {\n-\t\ttarget = DECL_RTL (slot);\n-\t\t/* If we have already expanded the slot, so don't do\n-                   it again.  (mrs)  */\n-\t\tif (TREE_OPERAND (exp, 1) == NULL_TREE)\n-\t\t  return target;\n-\t      }\n-\t    else\n-\t      SET_DECL_RTL (slot, target);\n-\t  }\n-\n-\texp1 = TREE_OPERAND (exp, 3) = TREE_OPERAND (exp, 1);\n-\t/* Mark it as expanded.  */\n-\tTREE_OPERAND (exp, 1) = NULL_TREE;\n-\n-\tif (VOID_TYPE_P (TREE_TYPE (exp1)))\n-\t  /* If the initializer is void, just expand it; it will initialize\n-\t     the object directly.  */\n-\t  expand_expr (exp1, const0_rtx, VOIDmode, 0);\n-\telse\n-\t  store_expr (exp1, target, modifier == EXPAND_STACK_PARM ? 2 : 0);\n-\n-\texpand_decl_cleanup_eh (NULL_TREE, cleanups, CLEANUP_EH_ONLY (exp));\n-\n-\treturn target;\n-      }\n-\n     case INIT_EXPR:\n       {\n \ttree lhs = TREE_OPERAND (exp, 0);\n@@ -8927,94 +8783,17 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       return const0_rtx;\n \n     case TRY_CATCH_EXPR:\n-      {\n-\ttree handler = TREE_OPERAND (exp, 1);\n-\n-\texpand_eh_region_start ();\n-\top0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n-\texpand_eh_handler (handler);\n-\n-\treturn op0;\n-      }\n-\n     case CATCH_EXPR:\n-      expand_start_catch (CATCH_TYPES (exp));\n-      expand_expr (CATCH_BODY (exp), const0_rtx, VOIDmode, 0);\n-      expand_end_catch ();\n-      return const0_rtx;\n-\n     case EH_FILTER_EXPR:\n-      /* Should have been handled in expand_eh_handler.  */\n-      abort ();\n-\n     case TRY_FINALLY_EXPR:\n-      {\n-\ttree try_block = TREE_OPERAND (exp, 0);\n-\ttree finally_block = TREE_OPERAND (exp, 1);\n-\n-        if ((!optimize && lang_protect_cleanup_actions == NULL)\n-\t    || unsafe_for_reeval (finally_block) > 1)\n-\t  {\n-\t    /* In this case, wrapping FINALLY_BLOCK in an UNSAVE_EXPR\n-\t       is not sufficient, so we cannot expand the block twice.\n-\t       So we play games with GOTO_SUBROUTINE_EXPR to let us\n-\t       expand the thing only once.  */\n-\t    /* When not optimizing, we go ahead with this form since\n-\t       (1) user breakpoints operate more predictably without\n-\t\t   code duplication, and\n-\t       (2) we're not running any of the global optimizers\n-\t           that would explode in time/space with the highly\n-\t\t   connected CFG created by the indirect branching.  */\n-\n-\t    rtx finally_label = gen_label_rtx ();\n-\t    rtx done_label = gen_label_rtx ();\n-\t    rtx return_link = gen_reg_rtx (Pmode);\n-\t    tree cleanup = build (GOTO_SUBROUTINE_EXPR, void_type_node,\n-\t\t\t          (tree) finally_label, (tree) return_link);\n-\t    TREE_SIDE_EFFECTS (cleanup) = 1;\n-\n-\t    /* Start a new binding layer that will keep track of all cleanup\n-\t       actions to be performed.  */\n-\t    expand_start_bindings (2);\n-\t    target_temp_slot_level = temp_slot_level;\n-\n-\t    expand_decl_cleanup (NULL_TREE, cleanup);\n-\t    op0 = expand_expr (try_block, target, tmode, modifier);\n-\n-\t    preserve_temp_slots (op0);\n-\t    expand_end_bindings (NULL_TREE, 0, 0);\n-\t    emit_jump (done_label);\n-\t    emit_label (finally_label);\n-\t    expand_expr (finally_block, const0_rtx, VOIDmode, 0);\n-\t    emit_indirect_jump (return_link);\n-\t    emit_label (done_label);\n-\t  }\n-\telse\n-\t  {\n-\t    expand_start_bindings (2);\n-\t    target_temp_slot_level = temp_slot_level;\n-\n-\t    expand_decl_cleanup (NULL_TREE, finally_block);\n-\t    op0 = expand_expr (try_block, target, tmode, modifier);\n-\n-\t    preserve_temp_slots (op0);\n-\t    expand_end_bindings (NULL_TREE, 0, 0);\n-\t  }\n-\n-\treturn op0;\n-      }\n+      /* Lowered by tree-eh.c.  */\n+      abort ();\n \n-    case GOTO_SUBROUTINE_EXPR:\n-      {\n-\trtx subr = (rtx) TREE_OPERAND (exp, 0);\n-\trtx return_link = *(rtx *) &TREE_OPERAND (exp, 1);\n-\trtx return_address = gen_label_rtx ();\n-\temit_move_insn (return_link,\n-\t\t\tgen_rtx_LABEL_REF (Pmode, return_address));\n-\temit_jump (subr);\n-\temit_label (return_address);\n-\treturn const0_rtx;\n-      }\n+    case WITH_CLEANUP_EXPR:\n+    case CLEANUP_POINT_EXPR:\n+    case TARGET_EXPR:\n+      /* Lowered by gimplify.c.  */\n+      abort ();\n \n     case VA_ARG_EXPR:\n       return expand_builtin_va_arg (TREE_OPERAND (exp, 0), type);"}, {"sha": "05f4a21d6af8b03db989c0da9dd7af8d5688d9df", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -9048,7 +9048,6 @@ fold_checksum_tree (tree expr, struct md5_ctx *ctx, htab_t ht)\n   fold_checksum_tree (TREE_TYPE (expr), ctx, ht);\n   if (TREE_CODE_CLASS (code) != 't' && TREE_CODE_CLASS (code) != 'd')\n     fold_checksum_tree (TREE_CHAIN (expr), ctx, ht);\n-  len = TREE_CODE_LENGTH (code);\n   switch (TREE_CODE_CLASS (code))\n     {\n     case 'c':\n@@ -9085,18 +9084,12 @@ fold_checksum_tree (tree expr, struct md5_ctx *ctx, htab_t ht)\n \t}\n       break;\n     case 'e':\n-      switch (code)\n-\t{\n-\tcase GOTO_SUBROUTINE_EXPR: len = 0; break;\n-\tcase WITH_CLEANUP_EXPR: len = 2; break;\n-\tdefault: break;\n-\t}\n-      /* Fall through.  */\n     case 'r':\n     case '<':\n     case '1':\n     case '2':\n     case 's':\n+      len = first_rtl_op (code);\n       for (i = 0; i < len; ++i)\n \tfold_checksum_tree (TREE_OPERAND (expr, i), ctx, ht);\n       break;"}, {"sha": "57d52eee2659a3fe149017c17324c0731e61e262", "filename": "gcc/function.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -4549,15 +4549,6 @@ expand_function_end (void)\n      sh mach_dep_reorg) that still try and compute their own lifetime info\n      instead of using the general framework.  */\n   use_return_register ();\n-\n-  /* Fix up any gotos that jumped out to the outermost\n-     binding level of the function.\n-     Must follow emitting RETURN_LABEL.  */\n-\n-  /* If you have any cleanups to do at this point,\n-     and they need to create temporary variables,\n-     then you will lose.  */\n-  expand_fixups (get_insns ());\n }\n \n rtx"}, {"sha": "3912c99fef6b159dcc4a5405b5b22f54a51313d3", "filename": "gcc/gengtype.c", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -644,15 +644,6 @@ adjust_field_tree_exp (type_p t, options_p opt ATTRIBUTE_UNUSED)\n {\n   pair_p flds;\n   options_p nodot;\n-  size_t i;\n-  static const struct {\n-    const char *name;\n-    int first_rtl;\n-    int num_rtl;\n-  } data[] = {\n-    { \"GOTO_SUBROUTINE_EXPR\", 0, 2 },\n-    { \"WITH_CLEANUP_EXPR\", 2, 1 },\n-  };\n \n   if (t->kind != TYPE_ARRAY)\n     {\n@@ -684,44 +675,6 @@ adjust_field_tree_exp (type_p t, options_p opt ATTRIBUTE_UNUSED)\n     flds->opt->info = \"\";\n   }\n \n-  for (i = 0; i < ARRAY_SIZE (data); i++)\n-    {\n-      pair_p old_flds = flds;\n-      pair_p subfields = NULL;\n-      int r_index;\n-      const char *sname;\n-\n-      for (r_index = 0;\n-\t   r_index < data[i].first_rtl + data[i].num_rtl;\n-\t   r_index++)\n-\t{\n-\t  pair_p old_subf = subfields;\n-\t  subfields = xmalloc (sizeof (*subfields));\n-\t  subfields->next = old_subf;\n-\t  subfields->name = xasprintf (\"[%d]\", r_index);\n-\t  if (r_index < data[i].first_rtl)\n-\t    subfields->type = t->u.a.p;\n-\t  else\n-\t    subfields->type = create_pointer (find_structure (\"rtx_def\", 0));\n-\t  subfields->line.file = __FILE__;\n-\t  subfields->line.line = __LINE__;\n-\t  subfields->opt = nodot;\n-\t}\n-\n-      flds = xmalloc (sizeof (*flds));\n-      flds->next = old_flds;\n-      flds->name = \"\";\n-      sname = xasprintf (\"tree_exp_%s\", data[i].name);\n-      new_structure (sname, 0, &lexer_line, subfields, NULL);\n-      flds->type = find_structure (sname, 0);\n-      flds->line.file = __FILE__;\n-      flds->line.line = __LINE__;\n-      flds->opt = xmalloc (sizeof (*flds->opt));\n-      flds->opt->next = nodot;\n-      flds->opt->name = \"tag\";\n-      flds->opt->info = data[i].name;\n-    }\n-\n   new_structure (\"tree_exp_subunion\", 1, &lexer_line, flds, nodot);\n   return find_structure (\"tree_exp_subunion\", 1);\n }"}, {"sha": "f60ef89bc48f9b3e2b9d46d4e14d1a107b1ff539", "filename": "gcc/gimplify.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -3210,7 +3210,7 @@ gimplify_cleanup_point_expr (tree *expr_p, tree *pre_p)\n \t{\n \t  if (tsi_one_before_end_p (iter))\n \t    {\n-\t      tsi_link_before (&iter, TREE_OPERAND (wce, 1), TSI_SAME_STMT);\n+\t      tsi_link_before (&iter, TREE_OPERAND (wce, 0), TSI_SAME_STMT);\n \t      tsi_delink (&iter);\n \t      break;\n \t    }\n@@ -3220,8 +3220,8 @@ gimplify_cleanup_point_expr (tree *expr_p, tree *pre_p)\n \n \t      sl = tsi_split_statement_list_after (&iter);\n \t      tfe = build (TRY_FINALLY_EXPR, void_type_node, sl, NULL_TREE);\n-\t      append_to_statement_list (TREE_OPERAND (wce, 1),\n-\t\t\t\t     &TREE_OPERAND (tfe, 1));\n+\t      append_to_statement_list (TREE_OPERAND (wce, 0),\n+\t\t\t\t        &TREE_OPERAND (tfe, 1));\n \t      *wce_p = tfe;\n \t      iter = tsi_start (sl);\n \t    }\n@@ -3285,8 +3285,7 @@ gimple_push_cleanup (tree var, tree cleanup, tree *pre_p)\n       tree ftrue = build (MODIFY_EXPR, void_type_node, flag,\n \t\t\t  boolean_true_node);\n       cleanup = build (COND_EXPR, void_type_node, flag, cleanup, NULL);\n-      wce = build (WITH_CLEANUP_EXPR, void_type_node, NULL_TREE,\n-\t\t   cleanup, NULL_TREE);\n+      wce = build (WITH_CLEANUP_EXPR, void_type_node, cleanup);\n       append_to_statement_list (ffalse, &gimplify_ctxp->conditional_cleanups);\n       append_to_statement_list (wce, &gimplify_ctxp->conditional_cleanups);\n       append_to_statement_list (ftrue, pre_p);\n@@ -3298,12 +3297,11 @@ gimple_push_cleanup (tree var, tree cleanup, tree *pre_p)\n     }\n   else\n     {\n-      wce = build (WITH_CLEANUP_EXPR, void_type_node, NULL_TREE,\n-\t\t   cleanup, NULL_TREE);\n+      wce = build (WITH_CLEANUP_EXPR, void_type_node, cleanup);\n       append_to_statement_list (wce, pre_p);\n     }\n \n-  gimplify_stmt (&TREE_OPERAND (wce, 1));\n+  gimplify_stmt (&TREE_OPERAND (wce, 0));\n }\n \n /* Gimplify a TARGET_EXPR which doesn't appear on the rhs of an INIT_EXPR.  */"}, {"sha": "9a944b4e0cca785fce7077e1751e55f48ffbaa44", "filename": "gcc/integrate.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -160,7 +160,6 @@ copy_decl_for_inlining (tree decl, tree from_fn, tree to_fn)\n       if (TREE_CODE (copy) == LABEL_DECL)\n \t{\n \t  TREE_ADDRESSABLE (copy) = 0;\n-\t  DECL_TOO_LATE (copy) = 0;\n \t}\n     }\n "}, {"sha": "b0bdd58aade5e9895e62496ca952c90b8757552a", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -1,3 +1,10 @@\n+2004-07-08  Richard Henderson  <rth@redhat.com>\n+\n+\t* expr.c (case_identity, get_primitive_array_vtable,\n+\tjava_expand_expr, emit_init_test_initialization): Remove.\n+\t* java-tree.h (java_expand_expr): Remove.\n+\t* lang.c (LANG_HOOKS_EXPAND_EXPR): Remove.\n+\n 2004-07-07  Per Bothner  <per@bothner.com>\n \n \t* class.c (build_static_field_ref):  Add a NOP_EXPR; otherwise we"}, {"sha": "81dfde679879a37d5c1b2a7cb54f0bbdcad2cce0", "filename": "gcc/java/expr.c", "status": "modified", "additions": 0, "deletions": 270, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -85,9 +85,7 @@ static void java_push_constant_from_pool (struct JCF *, int);\n static void java_stack_pop (int); \n static tree build_java_throw_out_of_bounds_exception (tree); \n static tree build_java_check_indexed_type (tree, tree); \n-static tree case_identity (tree, tree); \n static unsigned char peek_opcode_at_pc (struct JCF *, int, int);\n-static int emit_init_test_initialization (void **entry, void * ptr);\n \n static GTY(()) tree operand_type[59];\n \n@@ -2455,241 +2453,6 @@ load_type_state (tree label)\n     type_map [i] = TREE_VEC_ELT (vec, i);\n }\n \n-/* Do the expansion of a Java switch. With Gcc, switches are front-end\n-   dependent things, but they rely on gcc routines. This function is\n-   placed here because it uses things defined locally in parse.y. */\n-\n-static tree\n-case_identity (tree t __attribute__ ((__unused__)), tree v)\n-{\n-  return v;\n-}\n-\n-/* Return the name of the vtable for an array of a given primitive\n-   type.  */\n-static tree\n-get_primitive_array_vtable (tree elt)\n-{\n-  tree r;\n-  if (elt == boolean_type_node)\n-    r = boolean_array_vtable;\n-  else if (elt == byte_type_node)\n-    r = byte_array_vtable;\n-  else if (elt == char_type_node)\n-    r = char_array_vtable;\n-  else if (elt == short_type_node)\n-    r = short_array_vtable;\n-  else if (elt == int_type_node)\n-    r = int_array_vtable;\n-  else if (elt == long_type_node)\n-    r = long_array_vtable;\n-  else if (elt == float_type_node)\n-    r = float_array_vtable;\n-  else if (elt == double_type_node)\n-    r = double_array_vtable;\n-  else\n-    abort ();\n-  return build_address_of (r);\n-}\n-\n-struct rtx_def *\n-java_expand_expr (tree exp, rtx target, enum machine_mode tmode,\n-\t\t  int modifier /* Actually an enum expand_modifier. */,\n-\t\t  rtx *alt_rtl ATTRIBUTE_UNUSED)\n-{\n-  tree current;\n-\n-  abort ();\n-\n-  switch (TREE_CODE (exp))\n-    {\n-\n-    case EXPR_WITH_FILE_LOCATION:\n-      {\n-\trtx to_return;\n-\tconst char *saved_input_filename = input_filename;\n-\tint saved_lineno = input_line;\n-\tinput_filename = EXPR_WFL_FILENAME (exp);\n-\tinput_line = EXPR_WFL_LINENO (exp);\n-        if (EXPR_WFL_EMIT_LINE_NOTE (exp))\n-          emit_line_note (input_location);\n-\t/* Possibly avoid switching back and forth here.  */\n-\tto_return = expand_expr (EXPR_WFL_NODE (exp), target, tmode, modifier);\n-\tinput_filename = saved_input_filename;\n-\tinput_line = saved_lineno;\n-\treturn to_return;\n-      }\n-\n-    case NEW_ARRAY_INIT:\n-      {\n-\trtx tmp;\n-\ttree array_type = TREE_TYPE (TREE_TYPE (exp));\n-\ttree element_type = TYPE_ARRAY_ELEMENT (array_type);\n-\ttree data_fld = TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (array_type)));\n-\tHOST_WIDE_INT ilength = java_array_type_length (array_type);\n-\ttree length = build_int_2 (ilength, 0);\n-\ttree init = TREE_OPERAND (exp, 0);\n-\ttree array_decl;\n-\n-\t/* See if we can generate the array statically.  */\n-\tif (TREE_CONSTANT (init) && TREE_STATIC (exp)\n-\t    && JPRIMITIVE_TYPE_P (element_type))\n-\t  {\n-\t    tree temp, value, init_decl;\n-\t    struct rtx_def *r;\n-\t    START_RECORD_CONSTRUCTOR (temp, object_type_node);\n-\t    PUSH_FIELD_VALUE (temp, \"vtable\",\n-\t\t\t      get_primitive_array_vtable (element_type));\n-\t    if (! flag_hash_synchronization)\n-\t      PUSH_FIELD_VALUE (temp, \"sync_info\", null_pointer_node);\n-\t    FINISH_RECORD_CONSTRUCTOR (temp);\n-\t    START_RECORD_CONSTRUCTOR (value, array_type);\n-\t    PUSH_SUPER_VALUE (value, temp);\n-\t    PUSH_FIELD_VALUE (value, \"length\", length);\n-\t    PUSH_FIELD_VALUE (value, \"data\", init);\n-\t    FINISH_RECORD_CONSTRUCTOR (value);\n-\n-\t    init_decl = build_decl (VAR_DECL, generate_name (), array_type);\n-\t    pushdecl_top_level (init_decl);\n-\t    TREE_STATIC (init_decl) = 1;\n-\t    DECL_INITIAL (init_decl) = value;\n-\t    DECL_IGNORED_P (init_decl) = 1;\n-\t    TREE_READONLY (init_decl) = 1;\n-\t    /* Hash synchronization requires at least 64-bit alignment. */\n-\t    if (flag_hash_synchronization && POINTER_SIZE < 64)\n-\t      DECL_ALIGN (init_decl) = 64;\n-\t    rest_of_decl_compilation (init_decl, NULL, 1, 0);\n-\t    TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (init_decl)) = 1;\n-\t    init = build1 (ADDR_EXPR, TREE_TYPE (exp), init_decl);\n-\t    r = expand_expr (init, target, tmode, modifier);\n-\t    return r;\n-\t  }\n-\n-\tarray_decl = build_decl (VAR_DECL, NULL_TREE, TREE_TYPE (exp));\n-\texpand_decl (array_decl);\n-\ttmp = expand_assignment (array_decl,\n-\t\t\t\t build_new_array (element_type, length),\n-\t\t\t\t 1);\n-\tif (TREE_CONSTANT (init)\n-\t    && ilength >= 10 && JPRIMITIVE_TYPE_P (element_type))\n-\t  {\n-\t    tree init_decl;\n-\t    init_decl = build_decl (VAR_DECL, generate_name (),\n-\t\t\t\t    TREE_TYPE (init));\n-\t    pushdecl_top_level (init_decl);\n-\t    TREE_STATIC (init_decl) = 1;\n-\t    DECL_INITIAL (init_decl) = init;\n-\t    DECL_IGNORED_P (init_decl) = 1;\n-\t    TREE_READONLY (init_decl) = 1;\n-\t    rest_of_decl_compilation (init_decl, NULL, 1, 0);\n-\t    TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (init_decl)) = 1;\n-\t    init = init_decl;\n-\t  }\n-\texpand_assignment (build (COMPONENT_REF, TREE_TYPE (data_fld),\n-\t\t\t\t  build_java_indirect_ref (array_type, \n-\t\t\t\t\t  array_decl, flag_check_references), \n-\t\t\t\t  data_fld, NULL_TREE),\n-\t\t\t   init, 0);\n-\treturn tmp;\n-      }\n-    case BLOCK:\n-      if (BLOCK_EXPR_BODY (exp))\n-\t{\n-\t  tree local;\n-\t  rtx last;\n-\t  tree body = BLOCK_EXPR_BODY (exp);\n-\t  /* Set to 1 or more when we found a static class\n-             initialization flag. */\n-\t  int found_class_initialization_flag = 0;\n-\n-\t  pushlevel (2);\t/* 2 and above */\n-\t  expand_start_bindings (0);\n-\t  local = BLOCK_EXPR_DECLS (exp);\n-\t  while (local)\n-\t    {\n-\t      tree next = TREE_CHAIN (local);\n-\t      found_class_initialization_flag +=\n-\t\tLOCAL_CLASS_INITIALIZATION_FLAG_P (local);\n-\t      layout_decl (local, 0);\n-\t      expand_decl (pushdecl (local));\n-\t      local = next;\n-\t    }\n-\n-\t  /* Emit initialization code for test flags if we saw one. */\n-\t  if (! always_initialize_class_p \n-\t      && current_function_decl\n-\t      && found_class_initialization_flag)\n-\t    htab_traverse \n-\t      (DECL_FUNCTION_INIT_TEST_TABLE (current_function_decl),\n-\t       emit_init_test_initialization, NULL);\n-\n-\t  /* Avoid deep recursion for long block.  */\n-\t  while (TREE_CODE (body) == COMPOUND_EXPR)\n-\t    {\n-\t      expand_expr (TREE_OPERAND (body, 0), const0_rtx, VOIDmode, 0);\n-\t      emit_queue ();\n-\t      body = TREE_OPERAND (body, 1);\n-\t    }\n-  \t  last = expand_expr (body, NULL_RTX, VOIDmode, 0);\n-\t  emit_queue ();\n-\t  expand_end_bindings (getdecls (), 1, 0);\n-\t  poplevel (1, 1, 0);\n-\t  return last;\n-\t}\n-      return const0_rtx;\n-\n-    case CASE_EXPR:\n-      {\n-\ttree duplicate;\n-\tif (pushcase (TREE_OPERAND (exp, 0), case_identity,\n-\t\t      build_decl (LABEL_DECL, NULL_TREE, NULL_TREE), \n-\t\t      &duplicate) == 2)\n-\t  {\n-\t    EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (exp);\n-\t    parse_error_context\n-\t      (wfl_operator, \"Duplicate case label: `%s'\",\n-\t       print_int_node (TREE_OPERAND (exp, 0)));\n-\t  }\n-\treturn const0_rtx;\n-      }\n-\n-    case DEFAULT_EXPR:\n-      pushcase (NULL_TREE, 0, \n-\t\tbuild_decl (LABEL_DECL, NULL_TREE, NULL_TREE), NULL);\n-      return const0_rtx;\n-\n-    case TRY_EXPR:\n-      /* We expand a try[-catch] block */\n-\n-      /* Expand the try block */\n-      expand_eh_region_start ();\n-      expand_expr_stmt (TREE_OPERAND (exp, 0));\n-      expand_start_all_catch ();\n-\n-      /* Expand all catch clauses (EH handlers) */\n-      for (current = TREE_OPERAND (exp, 1); current; \n-\t   current = TREE_CHAIN (current))\n-\t{\n-\t  tree catch = TREE_OPERAND (current, 0);\n-\t  tree decl = BLOCK_EXPR_DECLS (catch);\n-\t  tree type = (decl ? TREE_TYPE (TREE_TYPE (decl)) : NULL_TREE);\n-\n-\t  expand_start_catch (prepare_eh_table_type (type));\n-\t  expand_expr_stmt (TREE_OPERAND (current, 0));\n-\t  expand_end_catch ();\n-\t}\n-      expand_end_all_catch ();\n-      return const0_rtx;\n-\n-    case JAVA_EXC_OBJ_EXPR:\n-      return expand_expr (build_exception_object_ref (TREE_TYPE (exp)),\n-\t\t\t  target, tmode, modifier);\n-\n-    default:\n-      internal_error (\"can't expand %s\", tree_code_name [TREE_CODE (exp)]);\n-    }\n-}\n-\n /* Go over METHOD's bytecode and note instruction starts in\n    instruction_bits[].  */\n \n@@ -3448,39 +3211,6 @@ force_evaluation_order (tree node)\n   return node;\n }\n \n-/* Called for every element in DECL_FUNCTION_INIT_TEST_TABLE of a\n-   method in order to emit initialization code for each test flag.  */\n-\n-static int\n-emit_init_test_initialization (void **entry, void *x ATTRIBUTE_UNUSED)\n-{\n-  struct treetreehash_entry *ite = (struct treetreehash_entry *) *entry;\n-  tree klass = build_class_ref (ite->key);\n-  tree rhs;\n-\n-  /* If the DECL_INITIAL of the test flag is set to true, it\n-     means that the class is already initialized the time it\n-     is in use. */\n-  if (DECL_INITIAL (ite->value) == boolean_true_node)\n-    rhs = boolean_true_node;\n-  /* Otherwise, we initialize the class init check variable by looking\n-     at the `state' field of the class to see if it is already\n-     initialized.  This makes things a bit faster if the class is\n-     already initialized, which should be the common case.  */\n-  else\n-    rhs = build (GE_EXPR, boolean_type_node,\n-\t\t build (COMPONENT_REF, byte_type_node,\n-\t\t\tbuild1 (INDIRECT_REF, class_type_node, klass),\n-\t\t\tlookup_field (&class_type_node,\n-\t\t\t\t      get_identifier (\"state\")),\n-\t\t\tNULL_TREE),\n-\t\t build_int_2 (JV_STATE_DONE, 0));\n-\n-  expand_expr_stmt (build (MODIFY_EXPR, boolean_type_node, \n-\t\t\t   ite->value, rhs));\n-  return true;\n-}\n-\n /* EXPR_WITH_FILE_LOCATION are used to keep track of the exact\n    location where an expression or an identifier were encountered. It\n    is necessary for languages where the frontend parser will handle"}, {"sha": "1920232c38cb7ffdfcb8048857d4ca1a23195d5e", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -1333,9 +1333,6 @@ extern tree decl_constant_value (tree);\n \n extern void java_mark_class_local (tree);\n \n-#if defined(RTX_CODE) && defined (HAVE_MACHINE_MODES)\n-struct rtx_def * java_expand_expr (tree, rtx, enum machine_mode, int, rtx *); \n-#endif\n extern void java_inlining_merge_static_initializers (tree, void *);\n extern void java_inlining_map_static_initializers (tree, void *);\n "}, {"sha": "b50977e1a3e916288109cc3180d5c661f2af6f79", "filename": "gcc/java/lang.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -224,8 +224,6 @@ struct language_function GTY(())\n #define LANG_HOOKS_UNSAFE_FOR_REEVAL java_unsafe_for_reeval\n #undef LANG_HOOKS_MARK_ADDRESSABLE\n #define LANG_HOOKS_MARK_ADDRESSABLE java_mark_addressable\n-#undef LANG_HOOKS_EXPAND_EXPR\n-#define LANG_HOOKS_EXPAND_EXPR java_expand_expr\n #undef LANG_HOOKS_TRUTHVALUE_CONVERSION\n #define LANG_HOOKS_TRUTHVALUE_CONVERSION java_truthvalue_conversion\n #undef LANG_HOOKS_DUP_LANG_SPECIFIC_DECL"}, {"sha": "01e57026153b0f0cd657b261a8223333c5ef0329", "filename": "gcc/print-tree.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -337,8 +337,6 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       if (TREE_CODE (node) == FIELD_DECL && DECL_NONADDRESSABLE_P (node))\n \tfputs (\" nonaddressable\", file);\n \n-      if (TREE_CODE (node) == LABEL_DECL && DECL_TOO_LATE (node))\n-\tfputs (\" too-late\", file);\n       if (TREE_CODE (node) == LABEL_DECL && DECL_ERROR_ISSUED (node))\n \tfputs (\" error-issued\", file);\n "}, {"sha": "8970734f375fd37f8ba36b059c400ae795d7da16", "filename": "gcc/stmt.c", "status": "modified", "additions": 22, "deletions": 851, "changes": 873, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -164,33 +164,10 @@ struct nesting GTY(())\n \t  /* Sequence number of this binding contour within the function,\n \t     in order of entry.  */\n \t  int block_start_count;\n-\t  /* Nonzero => value to restore stack to on exit.  */\n-\t  rtx stack_level;\n \t  /* The NOTE that starts this contour.\n \t     Used by expand_goto to check whether the destination\n \t     is within each contour or not.  */\n \t  rtx first_insn;\n-\t  /* Innermost containing binding contour that has a stack level.  */\n-\t  struct nesting *innermost_stack_block;\n-\t  /* List of cleanups to be run on exit from this contour.\n-\t     This is a list of expressions to be evaluated.\n-\t     The TREE_PURPOSE of each link is the ..._DECL node\n-\t     which the cleanup pertains to.  */\n-\t  tree cleanups;\n-\t  /* List of cleanup-lists of blocks containing this block,\n-\t     as they were at the locus where this block appears.\n-\t     There is an element for each containing block,\n-\t     ordered innermost containing block first.\n-\t     The tail of this list can be 0,\n-\t     if all remaining elements would be empty lists.\n-\t     The element's TREE_VALUE is the cleanup-list of that block,\n-\t     which may be null.  */\n-\t  tree outer_cleanups;\n-\t  /* Chain of labels defined inside this binding contour.\n-\t     For contours that have stack levels or cleanups.  */\n-\t  struct label_chain *label_chain;\n-\t  /* Nonzero if this is associated with an EH region.  */\n-\t  int exception_region;\n \t  /* The saved target_temp_slot_level from our outer block.\n \t     We may reset target_temp_slot_level to be the level of\n \t     this block, if that is done, target_temp_slot_level\n@@ -251,8 +228,6 @@ do { struct nesting *target = STACK;\t\t\t\\\n \t    cond_stack = cond_stack->next;\t\t\\\n \t  if (block_stack == this)\t\t\t\\\n \t    block_stack = block_stack->next;\t\t\\\n-\t  if (stack_block_stack == this)\t\t\\\n-\t    stack_block_stack = stack_block_stack->next; \\\n \t  if (case_stack == this)\t\t\t\\\n \t    case_stack = case_stack->next;\t\t\\\n \t  nesting_depth = nesting_stack->depth - 1;\t\\\n@@ -284,28 +259,6 @@ struct goto_fixup GTY(())\n   /* Number of binding contours started in current function\n      before the label reference.  */\n   int block_start_count;\n-  /* The outermost stack level that should be restored for this jump.\n-     Each time a binding contour that resets the stack is exited,\n-     if the target label is *not* yet defined, this slot is updated.  */\n-  rtx stack_level;\n-  /* List of lists of cleanup expressions to be run by this goto.\n-     There is one element for each block that this goto is within.\n-     The tail of this list can be 0,\n-     if all remaining elements would be empty.\n-     The TREE_VALUE contains the cleanup list of that block as of the\n-     time this goto was seen.\n-     The TREE_ADDRESSABLE flag is 1 for a block that has been exited.  */\n-  tree cleanup_list_list;\n-};\n-\n-/* Within any binding contour that must restore a stack level,\n-   all labels are recorded with a chain of these structures.  */\n-\n-struct label_chain GTY(())\n-{\n-  /* Points to following fixup.  */\n-  struct label_chain *next;\n-  tree label;\n };\n \n struct stmt_status GTY(())\n@@ -315,10 +268,6 @@ struct stmt_status GTY(())\n \n   /* If any new stacks are added here, add them to POPSTACKS too.  */\n \n-  /* Chain of all pending binding contours that restore stack levels\n-     or have cleanups.  */\n-  struct nesting * x_stack_block_stack;\n-\n   /* Chain of all pending conditional statements.  */\n   struct nesting * x_cond_stack;\n \n@@ -343,7 +292,6 @@ struct stmt_status GTY(())\n };\n \n #define block_stack (cfun->stmt->x_block_stack)\n-#define stack_block_stack (cfun->stmt->x_stack_block_stack)\n #define cond_stack (cfun->stmt->x_cond_stack)\n #define case_stack (cfun->stmt->x_case_stack)\n #define nesting_stack (cfun->stmt->x_nesting_stack)\n@@ -357,18 +305,14 @@ int using_eh_for_cleanups_p = 0;\n \n static int n_occurrences (int, const char *);\n static bool decl_conflicts_with_clobbers_p (tree, const HARD_REG_SET);\n-static void expand_goto_internal (tree, rtx, rtx);\n-static int expand_fixup (tree, rtx, rtx);\n static void expand_nl_goto_receiver (void);\n-static void fixup_gotos (struct nesting *, rtx, tree, rtx, int);\n static bool check_operand_nalternatives (tree, tree);\n static bool check_unique_operand_names (tree, tree);\n static char *resolve_operand_name_1 (char *, tree, tree);\n-static void expand_null_return_1 (rtx);\n+static void expand_null_return_1 (void);\n static enum br_predictor return_prediction (rtx);\n static rtx shift_return_value (rtx);\n static void expand_value_return (rtx);\n-static void expand_cleanups (tree, int, int);\n static void do_jump_if_equal (rtx, rtx, rtx, int);\n static int estimate_case_costs (case_node_ptr);\n static bool same_case_target_p (rtx, rtx);\n@@ -507,7 +451,6 @@ expand_computed_goto (tree exp)\n void\n expand_label (tree label)\n {\n-  struct label_chain *p;\n   rtx label_r = label_rtx (label);\n \n   do_pending_stack_adjust ();\n@@ -528,14 +471,6 @@ expand_label (tree label)\n       \n   if (DECL_NONLOCAL (label) || FORCED_LABEL (label))\n     maybe_set_first_label_num (label_r);\n-\n-  if (stack_block_stack != 0)\n-    {\n-      p = ggc_alloc (sizeof (struct label_chain));\n-      p->next = stack_block_stack->data.block.label_chain;\n-      stack_block_stack->data.block.label_chain = p;\n-      p->label = label;\n-    }\n }\n \n /* Generate RTL code for a `goto' statement with target label LABEL.\n@@ -553,385 +488,7 @@ expand_goto (tree label)\n     abort ();\n #endif\n \n-  expand_goto_internal (label, label_rtx (label), NULL_RTX);\n-}\n-\n-/* Generate RTL code for a `goto' statement with target label BODY.\n-   LABEL should be a LABEL_REF.\n-   LAST_INSN, if non-0, is the rtx we should consider as the last\n-   insn emitted (for the purposes of cleaning up a return).  */\n-\n-static void\n-expand_goto_internal (tree body, rtx label, rtx last_insn)\n-{\n-  struct nesting *block;\n-  rtx stack_level = 0;\n-\n-  if (GET_CODE (label) != CODE_LABEL)\n-    abort ();\n-\n-  /* If label has already been defined, we can tell now\n-     whether and how we must alter the stack level.  */\n-\n-  if (PREV_INSN (label) != 0)\n-    {\n-      /* Find the innermost pending block that contains the label.\n-\t (Check containment by comparing insn-uids.)\n-\t Then restore the outermost stack level within that block,\n-\t and do cleanups of all blocks contained in it.  */\n-      for (block = block_stack; block; block = block->next)\n-\t{\n-\t  if (INSN_UID (block->data.block.first_insn) < INSN_UID (label))\n-\t    break;\n-\t  if (block->data.block.stack_level != 0)\n-\t    stack_level = block->data.block.stack_level;\n-\t  /* Execute the cleanups for blocks we are exiting.  */\n-\t  if (block->data.block.cleanups != 0)\n-\t    {\n-\t      expand_cleanups (block->data.block.cleanups, 1, 1);\n-\t      do_pending_stack_adjust ();\n-\t    }\n-\t}\n-\n-      if (stack_level)\n-\t{\n-\t  /* Ensure stack adjust isn't done by emit_jump, as this\n-\t     would clobber the stack pointer.  This one should be\n-\t     deleted as dead by flow.  */\n-\t  clear_pending_stack_adjust ();\n-\t  do_pending_stack_adjust ();\n-\n-\t  /* Don't do this adjust if it's to the end label and this function\n-\t     is to return with a depressed stack pointer.  */\n-\t  if (label == return_label\n-\t      && (((TREE_CODE (TREE_TYPE (current_function_decl))\n-\t\t   == FUNCTION_TYPE)\n-\t\t   && (TYPE_RETURNS_STACK_DEPRESSED\n-\t\t       (TREE_TYPE (current_function_decl))))))\n-\t    ;\n-\t  else\n-\t    emit_stack_restore (SAVE_BLOCK, stack_level, NULL_RTX);\n-\t}\n-\n-      if (body != 0 && DECL_TOO_LATE (body))\n-\terror (\"jump to `%s' invalidly jumps into binding contour\",\n-\t       IDENTIFIER_POINTER (DECL_NAME (body)));\n-    }\n-  /* Label not yet defined: may need to put this goto\n-     on the fixup list.  */\n-  else if (! expand_fixup (body, label, last_insn))\n-    {\n-      /* No fixup needed.  Record that the label is the target\n-\t of at least one goto that has no fixup.  */\n-      if (body != 0)\n-\tTREE_ADDRESSABLE (body) = 1;\n-    }\n-\n-  emit_jump (label);\n-}\n-\f\n-/* Generate if necessary a fixup for a goto\n-   whose target label in tree structure (if any) is TREE_LABEL\n-   and whose target in rtl is RTL_LABEL.\n-\n-   If LAST_INSN is nonzero, we pretend that the jump appears\n-   after insn LAST_INSN instead of at the current point in the insn stream.\n-\n-   The fixup will be used later to insert insns just before the goto.\n-   Those insns will restore the stack level as appropriate for the\n-   target label, and will (in the case of C++) also invoke any object\n-   destructors which have to be invoked when we exit the scopes which\n-   are exited by the goto.\n-\n-   Value is nonzero if a fixup is made.  */\n-\n-static int\n-expand_fixup (tree tree_label, rtx rtl_label, rtx last_insn)\n-{\n-  struct nesting *block, *end_block;\n-\n-  /* See if we can recognize which block the label will be output in.\n-     This is possible in some very common cases.\n-     If we succeed, set END_BLOCK to that block.\n-     Otherwise, set it to 0.  */\n-\n-  if (cond_stack\n-      && (rtl_label == cond_stack->data.cond.endif_label\n-\t  || rtl_label == cond_stack->data.cond.next_label))\n-    end_block = cond_stack;\n-  else\n-    end_block = 0;\n-\n-  /* Now set END_BLOCK to the binding level to which we will return.  */\n-\n-  if (end_block)\n-    {\n-      struct nesting *next_block = end_block->all;\n-      block = block_stack;\n-\n-      /* First see if the END_BLOCK is inside the innermost binding level.\n-\t If so, then no cleanups or stack levels are relevant.  */\n-      while (next_block && next_block != block)\n-\tnext_block = next_block->all;\n-\n-      if (next_block)\n-\treturn 0;\n-\n-      /* Otherwise, set END_BLOCK to the innermost binding level\n-\t which is outside the relevant control-structure nesting.  */\n-      next_block = block_stack->next;\n-      for (block = block_stack; block != end_block; block = block->all)\n-\tif (block == next_block)\n-\t  next_block = next_block->next;\n-      end_block = next_block;\n-    }\n-\n-  /* Does any containing block have a stack level or cleanups?\n-     If not, no fixup is needed, and that is the normal case\n-     (the only case, for standard C).  */\n-  for (block = block_stack; block != end_block; block = block->next)\n-    if (block->data.block.stack_level != 0\n-\t|| block->data.block.cleanups != 0)\n-      break;\n-\n-  if (block != end_block)\n-    {\n-      /* Ok, a fixup is needed.  Add a fixup to the list of such.  */\n-      struct goto_fixup *fixup = ggc_alloc (sizeof (struct goto_fixup));\n-      /* In case an old stack level is restored, make sure that comes\n-\t after any pending stack adjust.  */\n-      /* ?? If the fixup isn't to come at the present position,\n-\t doing the stack adjust here isn't useful.  Doing it with our\n-\t settings at that location isn't useful either.  Let's hope\n-\t someone does it!  */\n-      if (last_insn == 0)\n-\tdo_pending_stack_adjust ();\n-      fixup->target = tree_label;\n-      fixup->target_rtl = rtl_label;\n-\n-      /* Create a BLOCK node and a corresponding matched set of\n-\t NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes at\n-\t this point.  The notes will encapsulate any and all fixup\n-\t code which we might later insert at this point in the insn\n-\t stream.  Also, the BLOCK node will be the parent (i.e. the\n-\t `SUPERBLOCK') of any other BLOCK nodes which we might create\n-\t later on when we are expanding the fixup code.\n-\n-\t Note that optimization passes might move the *_BLOCK notes away,\n-\t so we use a NOTE_INSN_DELETED as a placeholder.  */\n-\n-      {\n-\trtx original_before_jump\n-\t  = last_insn ? last_insn : get_last_insn ();\n-\trtx start;\n-\trtx end;\n-\ttree block;\n-\n-\tblock = make_node (BLOCK);\n-\tTREE_USED (block) = 1;\n-\n-\tBLOCK_CHAIN (block)\n-\t  = BLOCK_CHAIN (DECL_INITIAL (current_function_decl));\n-\tBLOCK_CHAIN (DECL_INITIAL (current_function_decl))\n-\t  = block;\n-\n-\tstart_sequence ();\n-\tstart = emit_note (NOTE_INSN_BLOCK_BEG);\n-\tNOTE_BLOCK (start) = block;\n-\tfixup->before_jump = emit_note (NOTE_INSN_DELETED);\n-\tend = emit_note (NOTE_INSN_BLOCK_END);\n-\tNOTE_BLOCK (end) = block;\n-\tfixup->context = block;\n-\tend_sequence ();\n-\temit_insn_after (start, original_before_jump);\n-      }\n-\n-      fixup->block_start_count = current_block_start_count;\n-      fixup->stack_level = 0;\n-      fixup->cleanup_list_list\n-\t= ((block->data.block.outer_cleanups\n-\t    || block->data.block.cleanups)\n-\t   ? tree_cons (NULL_TREE, block->data.block.cleanups,\n-\t\t\tblock->data.block.outer_cleanups)\n-\t   : 0);\n-      fixup->next = goto_fixup_chain;\n-      goto_fixup_chain = fixup;\n-    }\n-\n-  return block != 0;\n-}\n-\f\n-/* Expand any needed fixups in the outputmost binding level of the\n-   function.  FIRST_INSN is the first insn in the function.  */\n-\n-void\n-expand_fixups (rtx first_insn)\n-{\n-  fixup_gotos (NULL, NULL_RTX, NULL_TREE, first_insn, 0);\n-}\n-\n-/* When exiting a binding contour, process all pending gotos requiring fixups.\n-   THISBLOCK is the structure that describes the block being exited.\n-   STACK_LEVEL is the rtx for the stack level to restore exiting this contour.\n-   CLEANUP_LIST is a list of expressions to evaluate on exiting this contour.\n-   FIRST_INSN is the insn that began this contour.\n-\n-   Gotos that jump out of this contour must restore the\n-   stack level and do the cleanups before actually jumping.\n-\n-   DONT_JUMP_IN positive means report error if there is a jump into this\n-   contour from before the beginning of the contour.  This is also done if\n-   STACK_LEVEL is nonzero unless DONT_JUMP_IN is negative.  */\n-\n-static void\n-fixup_gotos (struct nesting *thisblock, rtx stack_level,\n-\t     tree cleanup_list, rtx first_insn, int dont_jump_in)\n-{\n-  struct goto_fixup *f, *prev;\n-\n-  /* F is the fixup we are considering; PREV is the previous one.  */\n-  /* We run this loop in two passes so that cleanups of exited blocks\n-     are run first, and blocks that are exited are marked so\n-     afterwards.  */\n-\n-  for (prev = 0, f = goto_fixup_chain; f; prev = f, f = f->next)\n-    {\n-      /* Test for a fixup that is inactive because it is already handled.  */\n-      if (f->before_jump == 0)\n-\t{\n-\t  /* Delete inactive fixup from the chain, if that is easy to do.  */\n-\t  if (prev != 0)\n-\t    prev->next = f->next;\n-\t}\n-      /* Has this fixup's target label been defined?\n-\t If so, we can finalize it.  */\n-      else if (PREV_INSN (f->target_rtl) != 0)\n-\t{\n-\t  rtx cleanup_insns;\n-\n-\t  /* If this fixup jumped into this contour from before the beginning\n-\t     of this contour, report an error.   This code used to use\n-\t     the first non-label insn after f->target_rtl, but that's\n-\t     wrong since such can be added, by things like put_var_into_stack\n-\t     and have INSN_UIDs that are out of the range of the block.  */\n-\t  /* ??? Bug: this does not detect jumping in through intermediate\n-\t     blocks that have stack levels or cleanups.\n-\t     It detects only a problem with the innermost block\n-\t     around the label.  */\n-\t  if (f->target != 0\n-\t      && (dont_jump_in > 0 || (dont_jump_in == 0 && stack_level)\n-\t\t  || cleanup_list)\n-\t      && INSN_UID (first_insn) < INSN_UID (f->target_rtl)\n-\t      && INSN_UID (first_insn) > INSN_UID (f->before_jump)\n-\t      && ! DECL_ERROR_ISSUED (f->target))\n-\t    {\n-\t      error (\"%Jlabel '%D' used before containing binding contour\",\n-\t\t     f->target, f->target);\n-\t      /* Prevent multiple errors for one label.  */\n-\t      DECL_ERROR_ISSUED (f->target) = 1;\n-\t    }\n-\n-\t  /* We will expand the cleanups into a sequence of their own and\n-\t     then later on we will attach this new sequence to the insn\n-\t     stream just ahead of the actual jump insn.  */\n-\n-\t  start_sequence ();\n-\n-\t  /* Temporarily restore the lexical context where we will\n-\t     logically be inserting the fixup code.  We do this for the\n-\t     sake of getting the debugging information right.  */\n-\n-\t  lang_hooks.decls.pushlevel (0);\n-\t  lang_hooks.decls.set_block (f->context);\n-\n-\t  /* Expand the cleanups for blocks this jump exits.  */\n-\t  if (f->cleanup_list_list)\n-\t    {\n-\t      tree lists;\n-\t      for (lists = f->cleanup_list_list; lists; lists = TREE_CHAIN (lists))\n-\t\t/* Marked elements correspond to blocks that have been closed.\n-\t\t   Do their cleanups.  */\n-\t\tif (TREE_ADDRESSABLE (lists)\n-\t\t    && TREE_VALUE (lists) != 0)\n-\t\t  {\n-\t\t    expand_cleanups (TREE_VALUE (lists), 1, 1);\n-\t\t    /* Pop any pushes done in the cleanups,\n-\t\t       in case function is about to return.  */\n-\t\t    do_pending_stack_adjust ();\n-\t\t  }\n-\t    }\n-\n-\t  /* Restore stack level for the biggest contour that this\n-\t     jump jumps out of.  */\n-\t  if (f->stack_level\n-\t      && ! (f->target_rtl == return_label\n-\t\t    && ((TREE_CODE (TREE_TYPE (current_function_decl))\n-\t\t\t == FUNCTION_TYPE)\n-\t\t\t&& (TYPE_RETURNS_STACK_DEPRESSED\n-\t\t\t    (TREE_TYPE (current_function_decl))))))\n-\t    emit_stack_restore (SAVE_BLOCK, f->stack_level, f->before_jump);\n-\n-\t  /* Finish up the sequence containing the insns which implement the\n-\t     necessary cleanups, and then attach that whole sequence to the\n-\t     insn stream just ahead of the actual jump insn.  Attaching it\n-\t     at that point insures that any cleanups which are in fact\n-\t     implicit C++ object destructions (which must be executed upon\n-\t     leaving the block) appear (to the debugger) to be taking place\n-\t     in an area of the generated code where the object(s) being\n-\t     destructed are still \"in scope\".  */\n-\n-\t  cleanup_insns = get_insns ();\n-\t  lang_hooks.decls.poplevel (1, 0, 0);\n-\n-\t  end_sequence ();\n-\t  emit_insn_after (cleanup_insns, f->before_jump);\n-\n-\t  f->before_jump = 0;\n-\t}\n-    }\n-\n-  /* For any still-undefined labels, do the cleanups for this block now.\n-     We must do this now since items in the cleanup list may go out\n-     of scope when the block ends.  */\n-  for (prev = 0, f = goto_fixup_chain; f; prev = f, f = f->next)\n-    if (f->before_jump != 0\n-\t&& PREV_INSN (f->target_rtl) == 0\n-\t/* Label has still not appeared.  If we are exiting a block with\n-\t   a stack level to restore, that started before the fixup,\n-\t   mark this stack level as needing restoration\n-\t   when the fixup is later finalized.  */\n-\t&& thisblock != 0\n-\t/* Note: if THISBLOCK == 0 and we have a label that hasn't appeared, it\n-\t   means the label is undefined.  That's erroneous, but possible.  */\n-\t&& (thisblock->data.block.block_start_count\n-\t    <= f->block_start_count))\n-      {\n-\ttree lists = f->cleanup_list_list;\n-\trtx cleanup_insns;\n-\n-\tfor (; lists; lists = TREE_CHAIN (lists))\n-\t  /* If the following elt. corresponds to our containing block\n-\t     then the elt. must be for this block.  */\n-\t  if (TREE_CHAIN (lists) == thisblock->data.block.outer_cleanups)\n-\t    {\n-\t      start_sequence ();\n-\t      lang_hooks.decls.pushlevel (0);\n-\t      lang_hooks.decls.set_block (f->context);\n-\t      expand_cleanups (TREE_VALUE (lists), 1, 1);\n-\t      do_pending_stack_adjust ();\n-\t      cleanup_insns = get_insns ();\n-\t      lang_hooks.decls.poplevel (1, 0, 0);\n-\t      end_sequence ();\n-\t      if (cleanup_insns != 0)\n-\t\tf->before_jump\n-\t\t  = emit_insn_after (cleanup_insns, f->before_jump);\n-\n-\t      f->cleanup_list_list = TREE_CHAIN (lists);\n-\t    }\n-\n-\tif (stack_level)\n-\t  f->stack_level = stack_level;\n-      }\n+  emit_jump (label_rtx (label));\n }\n \f\n /* Return the number of times character C occurs in string S.  */\n@@ -2297,16 +1854,12 @@ preserve_subexpressions_p (void)\n void\n expand_null_return (void)\n {\n-  rtx last_insn;\n-\n-  last_insn = get_last_insn ();\n-\n   /* If this function was declared to return a value, but we\n      didn't, clobber the return registers so that they are not\n      propagated live to the rest of the function.  */\n   clobber_return_register ();\n \n-  expand_null_return_1 (last_insn);\n+  expand_null_return_1 ();\n }\n \n /* Generate RTL to return directly from the current function.\n@@ -2315,17 +1868,16 @@ expand_null_return (void)\n void\n expand_naked_return (void)\n {\n-  rtx last_insn, end_label;\n-\n-  last_insn = get_last_insn ();\n-  end_label = naked_return_label;\n+  rtx end_label;\n \n   clear_pending_stack_adjust ();\n   do_pending_stack_adjust ();\n \n+  end_label = naked_return_label;\n   if (end_label == 0)\n     end_label = naked_return_label = gen_label_rtx ();\n-  expand_goto_internal (NULL_TREE, end_label, last_insn);\n+\n+  emit_jump (end_label);\n }\n \n /* Try to guess whether the value of return means error code.  */\n@@ -2389,7 +1941,6 @@ shift_return_value (rtx val)\n static void\n expand_value_return (rtx val)\n {\n-  rtx last_insn;\n   rtx return_reg;\n   enum br_predictor pred;\n \n@@ -2405,7 +1956,6 @@ expand_value_return (rtx val)\n \n     }\n \n-  last_insn = get_last_insn ();\n   return_reg = DECL_RTL (DECL_RESULT (current_function_decl));\n \n   /* Copy the value to the return location\n@@ -2431,23 +1981,23 @@ expand_value_return (rtx val)\n \temit_move_insn (return_reg, val);\n     }\n \n-  expand_null_return_1 (last_insn);\n+  expand_null_return_1 ();\n }\n \n-/* Output a return with no value.  If LAST_INSN is nonzero,\n-   pretend that the return takes place after LAST_INSN.  */\n+/* Output a return with no value.  */\n \n static void\n-expand_null_return_1 (rtx last_insn)\n+expand_null_return_1 (void)\n {\n-  rtx end_label = return_label;\n+  rtx end_label;\n \n   clear_pending_stack_adjust ();\n   do_pending_stack_adjust ();\n \n+  end_label = return_label;\n   if (end_label == 0)\n      end_label = return_label = gen_label_rtx ();\n-  expand_goto_internal (NULL_TREE, end_label, last_insn);\n+  emit_jump (end_label);\n }\n \f\n /* Generate RTL to evaluate the expression RETVAL and return it\n@@ -2456,15 +2006,6 @@ expand_null_return_1 (rtx last_insn)\n void\n expand_return (tree retval)\n {\n-  /* If there are any cleanups to be performed, then they will\n-     be inserted following LAST_INSN.  It is desirable\n-     that the last_insn, for such purposes, should be the\n-     last insn before computing the return value.  Otherwise, cleanups\n-     which call functions can clobber the return value.  */\n-  /* ??? rms: I think that is erroneous, because in C++ it would\n-     run destructors on variables that might be used in the subsequent\n-     computation of the return value.  */\n-  rtx last_insn = 0;\n   rtx result_rtl;\n   rtx val = 0;\n   tree retval_rhs;\n@@ -2487,23 +2028,21 @@ expand_return (tree retval)\n     }\n   else if (TREE_CODE (retval) == RESULT_DECL)\n     retval_rhs = retval;\n-  else if ((TREE_CODE (retval) == MODIFY_EXPR || TREE_CODE (retval) == INIT_EXPR)\n+  else if ((TREE_CODE (retval) == MODIFY_EXPR\n+\t    || TREE_CODE (retval) == INIT_EXPR)\n \t   && TREE_CODE (TREE_OPERAND (retval, 0)) == RESULT_DECL)\n     retval_rhs = TREE_OPERAND (retval, 1);\n   else\n     retval_rhs = retval;\n \n-  last_insn = get_last_insn ();\n-\n   result_rtl = DECL_RTL (DECL_RESULT (current_function_decl));\n \n   /* If the result is an aggregate that is being returned in one (or more)\n      registers, load the registers here.  The compiler currently can't handle\n      copying a BLKmode value into registers.  We could put this code in a\n      more general area (for use by everyone instead of just function\n      call/return), but until this feature is generally usable it is kept here\n-     (and in expand_call).  The value must go into a pseudo in case there\n-     are cleanups that will clobber the real return register.  */\n+     (and in expand_call).  */\n \n   if (retval_rhs != 0\n       && TYPE_MODE (TREE_TYPE (retval_rhs)) == BLKmode\n@@ -2631,13 +2170,12 @@ expand_return (tree retval)\n       val = expand_expr (retval_rhs, val, GET_MODE (val), 0);\n       val = force_not_mem (val);\n       emit_queue ();\n-      /* Return the calculated value, doing cleanups first.  */\n+      /* Return the calculated value.  */\n       expand_value_return (shift_return_value (val));\n     }\n   else\n     {\n-      /* No cleanups or no hard reg used;\n-\t calculate value into hard return reg.  */\n+      /* No hard reg used; calculate value into hard return reg.  */\n       expand_expr (retval, const0_rtx, VOIDmode, 0);\n       emit_queue ();\n       expand_value_return (result_rtl);\n@@ -2686,9 +2224,6 @@ expand_start_bindings_and_block (int flags, tree block)\n   thisblock->next = block_stack;\n   thisblock->all = nesting_stack;\n   thisblock->depth = ++nesting_depth;\n-  thisblock->data.block.stack_level = 0;\n-  thisblock->data.block.cleanups = 0;\n-  thisblock->data.block.exception_region = 0;\n   thisblock->data.block.block_target_temp_slot_level = target_temp_slot_level;\n \n   thisblock->data.block.conditional_code = 0;\n@@ -2701,16 +2236,6 @@ expand_start_bindings_and_block (int flags, tree block)\n      never the last instruction.  */\n   emit_note (NOTE_INSN_DELETED);\n \n-  if (block_stack\n-      && !(block_stack->data.block.cleanups == NULL_TREE\n-\t   && block_stack->data.block.outer_cleanups == NULL_TREE))\n-    thisblock->data.block.outer_cleanups\n-      = tree_cons (NULL_TREE, block_stack->data.block.cleanups,\n-\t\t   block_stack->data.block.outer_cleanups);\n-  else\n-    thisblock->data.block.outer_cleanups = 0;\n-  thisblock->data.block.label_chain = 0;\n-  thisblock->data.block.innermost_stack_block = stack_block_stack;\n   thisblock->data.block.first_insn = note;\n   thisblock->data.block.block_start_count = ++current_block_start_count;\n   thisblock->exit_label = exit_flag ? gen_label_rtx () : 0;\n@@ -2906,7 +2431,7 @@ warn_about_unused_variables (tree vars)\n \n void\n expand_end_bindings (tree vars, int mark_ends ATTRIBUTE_UNUSED,\n-\t\t     int dont_jump_in)\n+\t\t     int dont_jump_in ATTRIBUTE_UNUSED)\n {\n   struct nesting *thisblock = block_stack;\n \n@@ -2920,71 +2445,7 @@ expand_end_bindings (tree vars, int mark_ends ATTRIBUTE_UNUSED,\n       emit_label (thisblock->exit_label);\n     }\n \n-  /* Don't allow jumping into a block that has a stack level.\n-     Cleanups are allowed, though.  */\n-  if (dont_jump_in > 0\n-      || (dont_jump_in == 0 && thisblock->data.block.stack_level != 0))\n-    {\n-      struct label_chain *chain;\n-\n-      /* Any labels in this block are no longer valid to go to.\n-\t Mark them to cause an error message.  */\n-      for (chain = thisblock->data.block.label_chain; chain; chain = chain->next)\n-\t{\n-\t  DECL_TOO_LATE (chain->label) = 1;\n-\t  /* If any goto without a fixup came to this label,\n-\t     that must be an error, because gotos without fixups\n-\t     come from outside all saved stack-levels.  */\n-\t  if (TREE_ADDRESSABLE (chain->label))\n-\t    error (\"%Jlabel '%D' used before containing binding contour\",\n-\t\t   chain->label, chain->label);\n-\t}\n-    }\n-\n-  /* Restore stack level in effect before the block\n-     (only if variable-size objects allocated).  */\n-  /* Perform any cleanups associated with the block.  */\n-\n-  if (thisblock->data.block.stack_level != 0\n-      || thisblock->data.block.cleanups != 0)\n-    {\n-      int reachable;\n-      rtx insn;\n-\n-      /* Only clean up here if this point can actually be reached.  */\n-      insn = get_last_insn ();\n-      if (GET_CODE (insn) == NOTE)\n-\tinsn = prev_nonnote_insn (insn);\n-      reachable = (! insn || GET_CODE (insn) != BARRIER);\n-\n-      /* Do the cleanups.  */\n-      expand_cleanups (thisblock->data.block.cleanups, 0, reachable);\n-      if (reachable)\n-\tdo_pending_stack_adjust ();\n-\n-      /* Restore the stack level.  */\n-\n-      if (reachable && thisblock->data.block.stack_level != 0)\n-\t{\n-\t  emit_stack_restore (thisblock->next ? SAVE_BLOCK : SAVE_FUNCTION,\n-\t\t\t      thisblock->data.block.stack_level, NULL_RTX);\n-\t  if (cfun->nonlocal_goto_save_area)\n-\t    update_nonlocal_goto_save_area ();\n-\t}\n-\n-      /* Any gotos out of this block must also do these things.\n-\t Also report any gotos with fixups that came to labels in this\n-\t level.  */\n-      fixup_gotos (thisblock,\n-\t\t   thisblock->data.block.stack_level,\n-\t\t   thisblock->data.block.cleanups,\n-\t\t   thisblock->data.block.first_insn,\n-\t\t   dont_jump_in);\n-    }\n-\n-  /* Mark the beginning and end of the scope if requested.\n-     We do this now, after running cleanups on the variables\n-     just going out of scope, so they are in scope for their cleanups.  */\n+  /* Mark the beginning and end of the scope if requested.  */\n \n   /* Get rid of the beginning-mark if we don't make an end-mark.  */\n   NOTE_LINE_NUMBER (thisblock->data.block.first_insn) = NOTE_INSN_DELETED;\n@@ -2994,30 +2455,12 @@ expand_end_bindings (tree vars, int mark_ends ATTRIBUTE_UNUSED,\n \n   /* Restore block_stack level for containing block.  */\n \n-  stack_block_stack = thisblock->data.block.innermost_stack_block;\n   POPSTACK (block_stack);\n \n   /* Pop the stack slot nesting and free any slots at this level.  */\n   pop_temp_slots ();\n }\n \f\n-/* Generate code to save the stack pointer at the start of the current block\n-   and set up to restore it on exit.  */\n-\n-void\n-save_stack_pointer (void)\n-{\n-  struct nesting *thisblock = block_stack;\n-\n-  if (thisblock->data.block.stack_level == 0)\n-    {\n-      emit_stack_save (thisblock->next ? SAVE_BLOCK : SAVE_FUNCTION,\n-\t\t       &thisblock->data.block.stack_level,\n-\t\t       thisblock->data.block.first_insn);\n-      stack_block_stack = thisblock;\n-    }\n-}\n-\f\n /* Generate RTL for the automatic variable declaration DECL.\n    (Other kinds of declarations are simply ignored if seen here.)  */\n \n@@ -3143,7 +2586,6 @@ expand_decl (tree decl)\n       /* Record the stack pointer on entry to block, if have\n \t not already done so.  */\n       do_pending_stack_adjust ();\n-      save_stack_pointer ();\n \n       /* Compute the variable's size, in bytes.  This will expand any\n \t needed SAVE_EXPRs for the first time.  */\n@@ -3270,133 +2712,15 @@ expand_decl_init (tree decl)\n   pop_temp_slots ();\n }\n \n-/* CLEANUP is an expression to be executed at exit from this binding contour;\n-   for example, in C++, it might call the destructor for this variable.\n-\n-   We wrap CLEANUP in an UNSAVE_EXPR node, so that we can expand the\n-   CLEANUP multiple times, and have the correct semantics.  This\n-   happens in exception handling, for gotos, returns, breaks that\n-   leave the current scope.\n-\n-   If CLEANUP is nonzero and DECL is zero, we record a cleanup\n-   that is not associated with any particular variable.  */\n-\n-int\n-expand_decl_cleanup (tree decl, tree cleanup)\n-{\n-  struct nesting *thisblock;\n-\n-  /* Error if we are not in any block.  */\n-  if (cfun == 0 || block_stack == 0)\n-    return 0;\n-\n-  thisblock = block_stack;\n-\n-  /* Record the cleanup if there is one.  */\n-\n-  if (cleanup != 0)\n-    {\n-      tree t;\n-      rtx seq;\n-      tree *cleanups = &thisblock->data.block.cleanups;\n-      int cond_context = conditional_context ();\n-\n-      if (cond_context)\n-\t{\n-\t  rtx flag = gen_reg_rtx (word_mode);\n-\t  rtx set_flag_0;\n-\t  tree cond;\n-\n-\t  start_sequence ();\n-\t  emit_move_insn (flag, const0_rtx);\n-\t  set_flag_0 = get_insns ();\n-\t  end_sequence ();\n-\n-\t  thisblock->data.block.last_unconditional_cleanup\n-\t    = emit_insn_after (set_flag_0,\n-\t\t\t\tthisblock->data.block.last_unconditional_cleanup);\n-\n-\t  emit_move_insn (flag, const1_rtx);\n-\n-\t  cond = build_decl (VAR_DECL, NULL_TREE,\n-\t\t\t     lang_hooks.types.type_for_mode (word_mode, 1));\n-\t  SET_DECL_RTL (cond, flag);\n-\n-\t  /* Conditionalize the cleanup.  */\n-\t  cleanup = build (COND_EXPR, void_type_node,\n-\t\t\t   lang_hooks.truthvalue_conversion (cond),\n-\t\t\t   cleanup, integer_zero_node);\n-\t  cleanup = fold (cleanup);\n-\n-\t  cleanups = &thisblock->data.block.cleanups;\n-\t}\n-\n-      cleanup = unsave_expr (cleanup);\n-\n-      t = *cleanups = tree_cons (decl, cleanup, *cleanups);\n-\n-      if (! cond_context)\n-\t/* If this block has a cleanup, it belongs in stack_block_stack.  */\n-\tstack_block_stack = thisblock;\n-\n-      if (cond_context)\n-\t{\n-\t  start_sequence ();\n-\t}\n-\n-      if (! using_eh_for_cleanups_p)\n-\tTREE_ADDRESSABLE (t) = 1;\n-      else\n-\texpand_eh_region_start ();\n-\n-      if (cond_context)\n-\t{\n-\t  seq = get_insns ();\n-\t  end_sequence ();\n-\t  if (seq)\n-\t    thisblock->data.block.last_unconditional_cleanup\n-\t      = emit_insn_after (seq,\n-\t\t\t\t thisblock->data.block.last_unconditional_cleanup);\n-\t}\n-      else\n-\t{\n-\t  thisblock->data.block.last_unconditional_cleanup\n-\t    = get_last_insn ();\n-\t  /* When we insert instructions after the last unconditional cleanup,\n-\t     we don't adjust last_insn.  That means that a later add_insn will\n-\t     clobber the instructions we've just added.  The easiest way to\n-\t     fix this is to just insert another instruction here, so that the\n-\t     instructions inserted after the last unconditional cleanup are\n-\t     never the last instruction.  */\n-\t  emit_note (NOTE_INSN_DELETED);\n-\t}\n-    }\n-  return 1;\n-}\n-\n-/* Like expand_decl_cleanup, but maybe only run the cleanup if an exception\n-   is thrown.  */\n-\n-int\n-expand_decl_cleanup_eh (tree decl, tree cleanup, int eh_only)\n-{\n-  int ret = expand_decl_cleanup (decl, cleanup);\n-  if (cleanup && ret)\n-    {\n-      tree node = block_stack->data.block.cleanups;\n-      CLEANUP_EH_ONLY (node) = eh_only;\n-    }\n-  return ret;\n-}\n \f\n /* DECL is an anonymous union.  CLEANUP is a cleanup for DECL.\n    DECL_ELTS is the list of elements that belong to DECL's type.\n    In each, the TREE_VALUE is a VAR_DECL, and the TREE_PURPOSE a cleanup.  */\n \n void\n-expand_anon_union_decl (tree decl, tree cleanup, tree decl_elts)\n+expand_anon_union_decl (tree decl, tree cleanup ATTRIBUTE_UNUSED,\n+\t\t\ttree decl_elts)\n {\n-  struct nesting *thisblock = cfun == 0 ? 0 : block_stack;\n   rtx x;\n   tree t;\n \n@@ -3409,14 +2733,12 @@ expand_anon_union_decl (tree decl, tree cleanup, tree decl_elts)\n       }\n \n   expand_decl (decl);\n-  expand_decl_cleanup (decl, cleanup);\n   x = DECL_RTL (decl);\n \n   /* Go through the elements, assigning RTL to each.  */\n   for (t = decl_elts; t; t = TREE_CHAIN (t))\n     {\n       tree decl_elt = TREE_VALUE (t);\n-      tree cleanup_elt = TREE_PURPOSE (t);\n       enum machine_mode mode = TYPE_MODE (TREE_TYPE (decl_elt));\n \n       /* If any of the elements are addressable, so is the entire\n@@ -3453,145 +2775,9 @@ expand_anon_union_decl (tree decl, tree cleanup, tree decl_elts)\n \t}\n       else\n \tabort ();\n-\n-      /* Record the cleanup if there is one.  */\n-\n-      if (cleanup != 0)\n-\tthisblock->data.block.cleanups\n-\t  = tree_cons (decl_elt, cleanup_elt,\n-\t\t       thisblock->data.block.cleanups);\n     }\n }\n \f\n-/* Expand a list of cleanups LIST.\n-   Elements may be expressions or may be nested lists.\n-\n-   If IN_FIXUP is nonzero, we are generating this cleanup for a fixup\n-   goto and handle protection regions specially in that case.\n-\n-   If REACHABLE, we emit code, otherwise just inform the exception handling\n-   code about this finalization.  */\n-\n-static void\n-expand_cleanups (tree list, int in_fixup, int reachable)\n-{\n-  tree tail;\n-  for (tail = list; tail; tail = TREE_CHAIN (tail))\n-    if (TREE_CODE (TREE_VALUE (tail)) == TREE_LIST)\n-      expand_cleanups (TREE_VALUE (tail), in_fixup, reachable);\n-    else\n-      {\n-\tif (! in_fixup && using_eh_for_cleanups_p)\n-\t  expand_eh_region_end_cleanup (TREE_VALUE (tail));\n-\n-\tif (reachable && !CLEANUP_EH_ONLY (tail))\n-\t  {\n-\t    /* Cleanups may be run multiple times.  For example,\n-\t       when exiting a binding contour, we expand the\n-\t       cleanups associated with that contour.  When a goto\n-\t       within that binding contour has a target outside that\n-\t       contour, it will expand all cleanups from its scope to\n-\t       the target.  Though the cleanups are expanded multiple\n-\t       times, the control paths are non-overlapping so the\n-\t       cleanups will not be executed twice.  */\n-\n-\t    /* We may need to protect from outer cleanups.  */\n-\t    if (in_fixup && using_eh_for_cleanups_p)\n-\t      {\n-\t\texpand_eh_region_start ();\n-\n-\t\texpand_expr (TREE_VALUE (tail), const0_rtx, VOIDmode, 0);\n-\n-\t\texpand_eh_region_end_fixup (TREE_VALUE (tail));\n-\t      }\n-\t    else\n-\t      expand_expr (TREE_VALUE (tail), const0_rtx, VOIDmode, 0);\n-\n-\t    free_temp_slots ();\n-\t  }\n-      }\n-}\n-\n-/* Mark when the context we are emitting RTL for as a conditional\n-   context, so that any cleanup actions we register with\n-   expand_decl_init will be properly conditionalized when those\n-   cleanup actions are later performed.  Must be called before any\n-   expression (tree) is expanded that is within a conditional context.  */\n-\n-void\n-start_cleanup_deferral (void)\n-{\n-  /* block_stack can be NULL if we are inside the parameter list.  It is\n-     OK to do nothing, because cleanups aren't possible here.  */\n-  if (block_stack)\n-    ++block_stack->data.block.conditional_code;\n-}\n-\n-/* Mark the end of a conditional region of code.  Because cleanup\n-   deferrals may be nested, we may still be in a conditional region\n-   after we end the currently deferred cleanups, only after we end all\n-   deferred cleanups, are we back in unconditional code.  */\n-\n-void\n-end_cleanup_deferral (void)\n-{\n-  /* block_stack can be NULL if we are inside the parameter list.  It is\n-     OK to do nothing, because cleanups aren't possible here.  */\n-  if (block_stack)\n-    --block_stack->data.block.conditional_code;\n-}\n-\n-tree\n-last_cleanup_this_contour (void)\n-{\n-  if (block_stack == 0)\n-    return 0;\n-\n-  return block_stack->data.block.cleanups;\n-}\n-\n-\n-/* Return nonzero if any containing block has a stack level or\n-   cleanups.  */\n-\n-int\n-containing_blocks_have_cleanups_or_stack_level (void)\n-{\n-  struct nesting *block;\n-\n-  for (block = block_stack; block; block = block->next)\n-    if (block->data.block.stack_level != 0\n-        || block->data.block.cleanups != 0)\n-      return 1;\n-\n-  return 0;\n-}\n-\n-/* Return 1 if there are any pending cleanups at this point.\n-   Check the current contour as well as contours that enclose\n-   the current contour.  */\n-\n-int\n-any_pending_cleanups (void)\n-{\n-  struct nesting *block;\n-\n-  if (cfun == NULL || cfun->stmt == NULL || block_stack == 0)\n-    return 0;\n-\n-  if (block_stack->data.block.cleanups != NULL)\n-    return 1;\n-\n-  if (block_stack->data.block.outer_cleanups == 0)\n-    return 0;\n-\n-  for (block = block_stack->next; block; block = block->next)\n-    if (block->data.block.cleanups != 0)\n-      return 1;\n-\n-  return 0;\n-}\n-\f\n /* Enter a case (Pascal) or switch (C) statement.\n    Push a block onto case_stack and nesting_stack\n    to accumulate the case-labels that are seen\n@@ -3635,8 +2821,6 @@ expand_start_case (int exit_flag, tree expr, tree type,\n     emit_note (NOTE_INSN_DELETED);\n \n   thiscase->data.case_stmt.start = get_last_insn ();\n-\n-  start_cleanup_deferral ();\n }\n \n /* Accumulate one case or default label inside a case or switch statement.\n@@ -3649,7 +2833,6 @@ expand_start_case (int exit_flag, tree expr, tree type,\n    If VALUE is a duplicate or overlaps, return 2 and do nothing\n    except store the (first) duplicate node in *DUPLICATE.\n    If VALUE is out of range, return 3 and do nothing.\n-   If we are jumping into the scope of a cleanup or var-sized array, return 5.\n    Return 0 on success.\n \n    Extended to handle range statements.  */\n@@ -3665,10 +2848,6 @@ pushcase (tree value, tree (*converter) (tree, tree), tree label,\n   if (! (case_stack && case_stack->data.case_stmt.start))\n     return 1;\n \n-  if (stack_block_stack\n-      && stack_block_stack->depth > case_stack->depth)\n-    return 5;\n-\n   index_type = TREE_TYPE (case_stack->data.case_stmt.index_expr);\n   nominal_type = case_stack->data.case_stmt.nominal_type;\n \n@@ -3710,10 +2889,6 @@ pushcase_range (tree value1, tree value2, tree (*converter) (tree, tree),\n   if (! (case_stack && case_stack->data.case_stmt.start))\n     return 1;\n \n-  if (stack_block_stack\n-      && stack_block_stack->depth > case_stack->depth)\n-    return 5;\n-\n   index_type = TREE_TYPE (case_stack->data.case_stmt.index_expr);\n   nominal_type = case_stack->data.case_stmt.nominal_type;\n \n@@ -4268,8 +3443,6 @@ expand_end_case_type (tree orig_index, tree orig_type)\n       if (count != 0)\n \trange = fold (build (MINUS_EXPR, index_type, maxval, minval));\n \n-      end_cleanup_deferral ();\n-\n       if (count == 0)\n \t{\n \t  expand_expr (index_expr, const0_rtx, VOIDmode, 0);\n@@ -4482,8 +3655,6 @@ expand_end_case_type (tree orig_index, tree orig_type)\n       reorder_insns (before_case, end,\n \t\t     thiscase->data.case_stmt.start);\n     }\n-  else\n-    end_cleanup_deferral ();\n \n   if (thiscase->exit_label && !exit_done)\n     emit_label (thiscase->exit_label);"}, {"sha": "e660b4488190dbadcf01d3feffea1465ec46d5c0", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -1185,10 +1185,6 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       is_expr = false;\n       break;\n \n-    case GOTO_SUBROUTINE_EXPR:\n-      NIY;\n-      break;\n-\n     case LABEL_EXPR:\n       op0 = TREE_OPERAND (node, 0);\n       /* If this is for break or continue, don't bother printing it.  */"}, {"sha": "009888a5b21099ec2749d22625bd4545e06e62c6", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -1493,10 +1493,6 @@ first_rtl_op (enum tree_code code)\n {\n   switch (code)\n     {\n-    case GOTO_SUBROUTINE_EXPR:\n-      return 0;\n-    case WITH_CLEANUP_EXPR:\n-      return 2;\n     default:\n       return TREE_CODE_LENGTH (code);\n     }\n@@ -1850,7 +1846,6 @@ has_cleanups (tree exp)\n   switch (TREE_CODE (exp))\n     {\n     case TARGET_EXPR:\n-    case GOTO_SUBROUTINE_EXPR:\n     case WITH_CLEANUP_EXPR:\n       return 1;\n "}, {"sha": "8068f266758f6c53e1b4a74a0ec847d9946c54db", "filename": "gcc/tree.def", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -494,16 +494,11 @@ DEFTREECODE (LABELED_BLOCK_EXPR, \"labeled_block_expr\", 'e', 2)\n DEFTREECODE (CALL_EXPR, \"call_expr\", 'e', 3)\n \n /* Specify a value to compute along with its corresponding cleanup.\n-   Operand 0 argument is an expression whose value needs a cleanup.\n-   Operand 1 is the cleanup expression for the object.\n-   Operand 2 is unused.\n-   The cleanup is executed by the first enclosing CLEANUP_POINT_EXPR, if\n-   it exists, otherwise it is the responsibility of the caller to manually\n-   call expand_start_target_temps/expand_end_target_temps, as needed.\n-\n-   This differs from TRY_CATCH_EXPR in that operand 2 is always\n-   evaluated when an exception isn't thrown when cleanups are run.  */\n-DEFTREECODE (WITH_CLEANUP_EXPR, \"with_cleanup_expr\", 'e', 3)\n+   Operand 0 is the cleanup expression.\n+   The cleanup is executed by the first enclosing CLEANUP_POINT_EXPR,\n+   which must exist.  This differs from TRY_CATCH_EXPR in that operand 1\n+   is always evaluated when cleanups are run.  */\n+DEFTREECODE (WITH_CLEANUP_EXPR, \"with_cleanup_expr\", 'e', 1)\n \n /* Specify a cleanup point.\n    Operand 0 is an expression that may have cleanups.  If it does, those\n@@ -790,13 +785,6 @@ DEFTREECODE (LABEL_EXPR, \"label_expr\", 's', 1)\n    The type should be void and the value should be ignored.  */\n DEFTREECODE (GOTO_EXPR, \"goto_expr\", 's', 1)\n \n-/* Used internally for cleanups in the implementation of TRY_FINALLY_EXPR.\n-   (Specifically, it is created by expand_expr, not front-ends.)\n-   Operand 0 is the rtx for the start of the subroutine we need to call.\n-   Operand 1 is the rtx for a variable in which to store the address\n-   of where the subroutine should return to.  */\n-DEFTREECODE (GOTO_SUBROUTINE_EXPR, \"goto_subroutine\", 's', 2)\n-\n /* RETURN.  Evaluates operand 0, then returns from the current function.\n    Presumably that operand is an assignment that stores into the\n    RESULT_DECL that hold the value to be returned."}, {"sha": "28582dd7ec4bfc58441bc65da98fd95bb96b43f3", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac45df5dba58049cf731c7ce9a20f31b6637604e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ac45df5dba58049cf731c7ce9a20f31b6637604e", "patch": "@@ -1025,10 +1025,6 @@ struct tree_vec GTY(())\n \t\t\t\t && VOID_TYPE_P (TREE_TYPE (NODE)) \\\n \t\t\t\t && integer_zerop (TREE_OPERAND (NODE, 0)))\n \n-/* In a WITH_CLEANUP_EXPR node.  */\n-#define WITH_CLEANUP_EXPR_RTL(NODE) \\\n-  TREE_RTL_OPERAND_CHECK (NODE, WITH_CLEANUP_EXPR, 2)\n-\n /* In a CONSTRUCTOR node.  */\n #define CONSTRUCTOR_ELTS(NODE) TREE_OPERAND_CHECK_CODE (NODE, CONSTRUCTOR, 0)\n \n@@ -2013,10 +2009,6 @@ extern GTY (()) unsigned binfo_lang_slots;\n    specially.  */\n #define DECL_BIT_FIELD(NODE) (FIELD_DECL_CHECK (NODE)->decl.bit_field_flag)\n \n-/* In a LABEL_DECL, nonzero means label was defined inside a binding\n-   contour that restored a stack level and which is now exited.  */\n-#define DECL_TOO_LATE(NODE) (LABEL_DECL_CHECK (NODE)->decl.bit_field_flag)\n-\n /* Unused in FUNCTION_DECL.  */\n \n /* In a VAR_DECL that's static,\n@@ -3333,7 +3325,6 @@ extern bool commutative_tree_code (enum tree_code);\n \f\n /* In stmt.c */\n \n-extern void expand_fixups (rtx);\n extern void expand_expr_stmt (tree);\n extern void expand_expr_stmt_value (tree, int, int);\n extern int warn_if_unused_value (tree, location_t);\n@@ -3355,13 +3346,10 @@ extern void expand_start_bindings_and_block (int, tree);\n   expand_start_bindings_and_block(flags, NULL_TREE)\n extern void expand_end_bindings (tree, int, int);\n extern void warn_about_unused_variables (tree);\n-extern void start_cleanup_deferral (void);\n-extern void end_cleanup_deferral (void);\n extern int is_body_block (tree);\n \n extern int conditional_context (void);\n extern struct nesting * current_nesting_level (void);\n-extern tree last_cleanup_this_contour (void);\n extern void expand_start_case (int, tree, tree, const char *);\n extern void expand_end_case_type (tree, tree);\n #define expand_end_case(cond) expand_end_case_type (cond, NULL)\n@@ -3613,17 +3601,12 @@ extern void expand_asm_operands (tree, tree, tree, tree, int, location_t);\n extern void expand_asm_expr (tree);\n extern bool asm_op_is_mem_input (tree, tree);\n extern tree resolve_asm_operand_names (tree, tree, tree);\n-extern int any_pending_cleanups (void);\n extern void init_stmt_for_function (void);\n extern void expand_start_target_temps (void);\n extern void expand_end_target_temps (void);\n extern void expand_elseif (tree);\n-extern void save_stack_pointer (void);\n extern void expand_decl (tree);\n-extern int expand_decl_cleanup (tree, tree);\n-extern int expand_decl_cleanup_eh (tree, tree, int);\n extern void expand_anon_union_decl (tree, tree, tree);\n-extern int containing_blocks_have_cleanups_or_stack_level (void);\n \n /* In gimplify.c.  */\n extern tree create_artificial_label (void);"}]}