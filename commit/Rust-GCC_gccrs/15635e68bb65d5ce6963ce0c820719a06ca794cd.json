{"sha": "15635e68bb65d5ce6963ce0c820719a06ca794cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU2MzVlNjhiYjY1ZDVjZTY5NjNjZTBjODIwNzE5YTA2Y2E3OTRjZA==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-04T14:26:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-04T14:26:10Z"}, "message": "Merge #605\n\n605: Merge both module classes in one r=philberty a=CohenArthur\n\nThis PR merges both kinds of Modules (formerly `ModuleBodied` and `ModuleNoBody`) as one class with an enum. This is the [behavior used by rustc](https://github.com/rust-lang/rust/blob/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/compiler/rustc_ast/src/ast.rs#L2274), where both variants are kept in an enum with one holding a vector of items.\r\n\r\nThis change is important for multiple file parsing: An external mod (`mod foo; // defined in foo.rs or foo/mod.rs`) will see its items expanded during expansion, which occurs after parsing. This means that the previous directive will be \"replaced\" by `mod foo { <items> }` at the AST level. In order to achieve this, we need to be able to modify a previously parsed instance of an AST element.\r\n\r\nIn rustc, this is done [here](https://github.com/rust-lang/rust/blob/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/compiler/rustc_expand/src/expand.rs#L1427), where `mod_kind` was previously `ModKind::Unloaded` and becomes `ModKind::Loaded(parsed_items, ...)`. \n\nCo-authored-by: CohenArthur <arthur.cohen@epita.fr>", "tree": {"sha": "a1b2dfdc3aa8c82367b4a71ae5cb3c633bd35292", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1b2dfdc3aa8c82367b4a71ae5cb3c633bd35292"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15635e68bb65d5ce6963ce0c820719a06ca794cd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhCqOCCRBK7hj4Ov3rIwAAykkIAHQAxbzSfgSt5TI6gTENSJI9\nBoJohnBT3PtI4QbNjqhq7eqG8dQnFRAAsxk4lZqQbvIdD70hoP0C3Qbe0ApIkqAc\nxfS4kOgrD89pVm66d3ZLThN9LqwTjJn8rbhRfBSuh5HjwKZ93bg9iTe/pi7ppBFZ\nfV9EAZYzF7LPngcbQnilZuoFvJWa9K8Djfk3+4yiKTMOXQk60IKkTKibwFi6qsRd\nKiIuA2GMbQwIl/DsTpXtINUNIalKGdVP2rxnQgl5iNR2ZwbM5/RKZRvX7EY1Ok7H\nq3lkF7+MajaXDX7Awa5IE2ZITD7k13QmUjcaHreeRrjDIfEgIwvV4UnIMZA/08U=\n=Q0WZ\n-----END PGP SIGNATURE-----\n", "payload": "tree a1b2dfdc3aa8c82367b4a71ae5cb3c633bd35292\nparent 7bdd8599b99a80b5930945bb87d1abffba8ee157\nparent c4077cc2a8c9ade9bd9b61804d756fcfc2cc9931\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1628087170 +0000\ncommitter GitHub <noreply@github.com> 1628087170 +0000\n\nMerge #605\n\n605: Merge both module classes in one r=philberty a=CohenArthur\n\nThis PR merges both kinds of Modules (formerly `ModuleBodied` and `ModuleNoBody`) as one class with an enum. This is the [behavior used by rustc](https://github.com/rust-lang/rust/blob/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/compiler/rustc_ast/src/ast.rs#L2274), where both variants are kept in an enum with one holding a vector of items.\r\n\r\nThis change is important for multiple file parsing: An external mod (`mod foo; // defined in foo.rs or foo/mod.rs`) will see its items expanded during expansion, which occurs after parsing. This means that the previous directive will be \"replaced\" by `mod foo { <items> }` at the AST level. In order to achieve this, we need to be able to modify a previously parsed instance of an AST element.\r\n\r\nIn rustc, this is done [here](https://github.com/rust-lang/rust/blob/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/compiler/rustc_expand/src/expand.rs#L1427), where `mod_kind` was previously `ModKind::Unloaded` and becomes `ModKind::Loaded(parsed_items, ...)`. \n\nCo-authored-by: CohenArthur <arthur.cohen@epita.fr>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15635e68bb65d5ce6963ce0c820719a06ca794cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15635e68bb65d5ce6963ce0c820719a06ca794cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15635e68bb65d5ce6963ce0c820719a06ca794cd/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bdd8599b99a80b5930945bb87d1abffba8ee157", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bdd8599b99a80b5930945bb87d1abffba8ee157", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bdd8599b99a80b5930945bb87d1abffba8ee157"}, {"sha": "c4077cc2a8c9ade9bd9b61804d756fcfc2cc9931", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4077cc2a8c9ade9bd9b61804d756fcfc2cc9931", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4077cc2a8c9ade9bd9b61804d756fcfc2cc9931"}], "stats": {"total": 438, "additions": 200, "deletions": 238}, "files": [{"sha": "7644dfe240cd910f9720d8b012f13fb1bd27135f", "filename": "gcc/rust/ast/rust-ast-full-decls.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15635e68bb65d5ce6963ce0c820719a06ca794cd/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15635e68bb65d5ce6963ce0c820719a06ca794cd/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-decls.h?ref=15635e68bb65d5ce6963ce0c820719a06ca794cd", "patch": "@@ -182,8 +182,6 @@ struct Visibility;\n class Method;\n class VisItem;\n class Module;\n-class ModuleBodied;\n-class ModuleNoBody;\n class ExternCrate;\n class UseTree;\n class UseTreeGlob;"}, {"sha": "dfd9cdbbd832753a49ae2b4d19b4915c558137a1", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 9, "deletions": 27, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15635e68bb65d5ce6963ce0c820719a06ca794cd/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15635e68bb65d5ce6963ce0c820719a06ca794cd/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=15635e68bb65d5ce6963ce0c820719a06ca794cd", "patch": "@@ -379,22 +379,20 @@ VisItem::as_string () const\n std::string\n Module::as_string () const\n {\n-  std::string vis_item = VisItem::as_string ();\n+  std::string str = VisItem::as_string () + \"mod \" + module_name;\n \n-  return vis_item + \"mod \" + module_name;\n-}\n-\n-std::string\n-ModuleBodied::as_string () const\n-{\n-  // get module string for \"[vis] mod [name]\"\n-  std::string str = Module::as_string ();\n+  // Return early if we're dealing with an unloaded module as their body resides\n+  // in a different file\n+  if (kind == ModuleKind::UNLOADED)\n+    return str + \"\\n no body (reference to external file)\\n\";\n \n   // inner attributes\n   str += append_attributes (inner_attrs, INNER);\n \n   // items\n   str += \"\\n items: \";\n+\n+  // This can still happen if the module is loaded but empty, i.e. `mod foo {}`\n   if (items.empty ())\n     {\n       str += \"none\";\n@@ -418,16 +416,6 @@ ModuleBodied::as_string () const\n   return str + \"\\n\";\n }\n \n-std::string\n-ModuleNoBody::as_string () const\n-{\n-  std::string str = Module::as_string ();\n-\n-  str += \"\\n no body (reference to external file)\";\n-\n-  return str + \"\\n\";\n-}\n-\n std::string\n StaticItem::as_string () const\n {\n@@ -4053,7 +4041,7 @@ AttrInputMetaItemContainer::as_string () const\n /* Override that calls the function recursively on all items contained within\n  * the module. */\n void\n-ModuleBodied::add_crate_name (std::vector<std::string> &names) const\n+Module::add_crate_name (std::vector<std::string> &names) const\n {\n   /* TODO: test whether module has been 'cfg'-ed out to determine whether to\n    * exclude it from search */\n@@ -5381,13 +5369,7 @@ Method::accept_vis (ASTVisitor &vis)\n }\n \n void\n-ModuleBodied::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-ModuleNoBody::accept_vis (ASTVisitor &vis)\n+Module::accept_vis (ASTVisitor &vis)\n {\n   vis.visit (*this);\n }"}, {"sha": "e0de54d7a98b687fe83ebf1af2900e01b59e512f", "filename": "gcc/rust/ast/rust-ast-visitor.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15635e68bb65d5ce6963ce0c820719a06ca794cd/gcc%2Frust%2Fast%2Frust-ast-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15635e68bb65d5ce6963ce0c820719a06ca794cd/gcc%2Frust%2Fast%2Frust-ast-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-visitor.h?ref=15635e68bb65d5ce6963ce0c820719a06ca794cd", "patch": "@@ -143,8 +143,7 @@ class ASTVisitor\n   virtual void visit (LifetimeWhereClauseItem &item) = 0;\n   virtual void visit (TypeBoundWhereClauseItem &item) = 0;\n   virtual void visit (Method &method) = 0;\n-  virtual void visit (ModuleBodied &module) = 0;\n-  virtual void visit (ModuleNoBody &module) = 0;\n+  virtual void visit (Module &module) = 0;\n   virtual void visit (ExternCrate &crate) = 0;\n   // virtual void visit(UseTree& use_tree) = 0;\n   virtual void visit (UseTreeGlob &use_tree) = 0;"}, {"sha": "32fb56f41fe9bbb1c564a46aa1c8ea1698d1fe89", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 170, "deletions": 179, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15635e68bb65d5ce6963ce0c820719a06ca794cd/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15635e68bb65d5ce6963ce0c820719a06ca794cd/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=15635e68bb65d5ce6963ce0c820719a06ca794cd", "patch": "@@ -57,7 +57,7 @@ class TypeParam : public GenericParam\n \n   // bool has_type_param_bounds;\n   // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound> >\n+  std::vector<std::unique_ptr<TypeParamBound>>\n     type_param_bounds; // inlined form\n \n   // bool has_type;\n@@ -78,8 +78,8 @@ class TypeParam : public GenericParam\n   bool has_outer_attribute () const { return !outer_attr.is_empty (); }\n \n   TypeParam (Identifier type_representation, Location locus = Location (),\n-\t     std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds\n-\t     = std::vector<std::unique_ptr<TypeParamBound> > (),\n+\t     std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds\n+\t     = std::vector<std::unique_ptr<TypeParamBound>> (),\n \t     std::unique_ptr<Type> type = nullptr,\n \t     Attribute outer_attr = Attribute::create_empty ())\n     : GenericParam (Analysis::Mappings::get ()->get_next_node_id ()),\n@@ -144,11 +144,11 @@ class TypeParam : public GenericParam\n   }\n \n   // TODO: mutable getter seems kinda dodgy\n-  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  std::vector<std::unique_ptr<TypeParamBound>> &get_type_param_bounds ()\n   {\n     return type_param_bounds;\n   }\n-  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  const std::vector<std::unique_ptr<TypeParamBound>> &\n   get_type_param_bounds () const\n   {\n     return type_param_bounds;\n@@ -224,7 +224,7 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n \n   // bool has_type_param_bounds;\n   // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound> >\n+  std::vector<std::unique_ptr<TypeParamBound>>\n     type_param_bounds; // inlined form\n \n   // should this store location info?\n@@ -238,7 +238,7 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n \n   TypeBoundWhereClauseItem (\n     std::vector<LifetimeParam> for_lifetimes, std::unique_ptr<Type> bound_type,\n-    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds)\n+    std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds)\n     : for_lifetimes (std::move (for_lifetimes)),\n       bound_type (std::move (bound_type)),\n       type_param_bounds (std::move (type_param_bounds))\n@@ -284,11 +284,11 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n   }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n-  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  std::vector<std::unique_ptr<TypeParamBound>> &get_type_param_bounds ()\n   {\n     return type_param_bounds;\n   }\n-  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  const std::vector<std::unique_ptr<TypeParamBound>> &\n   get_type_param_bounds () const\n   {\n     return type_param_bounds;\n@@ -306,13 +306,12 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n struct WhereClause\n {\n private:\n-  std::vector<std::unique_ptr<WhereClauseItem> > where_clause_items;\n+  std::vector<std::unique_ptr<WhereClauseItem>> where_clause_items;\n \n   // should this store location info?\n \n public:\n-  WhereClause (\n-    std::vector<std::unique_ptr<WhereClauseItem> > where_clause_items)\n+  WhereClause (std::vector<std::unique_ptr<WhereClauseItem>> where_clause_items)\n     : where_clause_items (std::move (where_clause_items))\n   {}\n \n@@ -341,7 +340,7 @@ struct WhereClause\n   // Creates a WhereClause with no items.\n   static WhereClause create_empty ()\n   {\n-    return WhereClause (std::vector<std::unique_ptr<WhereClauseItem> > ());\n+    return WhereClause (std::vector<std::unique_ptr<WhereClauseItem>> ());\n   }\n \n   // Returns whether the WhereClause has no items.\n@@ -350,11 +349,11 @@ struct WhereClause\n   std::string as_string () const;\n \n   // TODO: this mutable getter seems kinda dodgy\n-  std::vector<std::unique_ptr<WhereClauseItem> > &get_items ()\n+  std::vector<std::unique_ptr<WhereClauseItem>> &get_items ()\n   {\n     return where_clause_items;\n   }\n-  const std::vector<std::unique_ptr<WhereClauseItem> > &get_items () const\n+  const std::vector<std::unique_ptr<WhereClauseItem>> &get_items () const\n   {\n     return where_clause_items;\n   }\n@@ -698,7 +697,7 @@ class Method : public InherentImplItem, public TraitImplItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   SelfParam self_param;\n \n@@ -731,7 +730,7 @@ class Method : public InherentImplItem, public TraitImplItem\n   static Method create_error ()\n   {\n     return Method (\"\", FunctionQualifiers (FunctionQualifiers::NONE, true),\n-\t\t   std::vector<std::unique_ptr<GenericParam> > (),\n+\t\t   std::vector<std::unique_ptr<GenericParam>> (),\n \t\t   SelfParam::create_error (), std::vector<FunctionParam> (),\n \t\t   nullptr, WhereClause::create_empty (), nullptr,\n \t\t   Visibility::create_error (), std::vector<Attribute> (), {});\n@@ -754,7 +753,7 @@ class Method : public InherentImplItem, public TraitImplItem\n \n   // Mega-constructor with all possible fields\n   Method (Identifier method_name, FunctionQualifiers qualifiers,\n-\t  std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t  std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t  SelfParam self_param, std::vector<FunctionParam> function_params,\n \t  std::unique_ptr<Type> return_type, WhereClause where_clause,\n \t  std::unique_ptr<BlockExpr> function_body, Visibility vis,\n@@ -853,11 +852,11 @@ class Method : public InherentImplItem, public TraitImplItem\n     return function_params;\n   }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -961,134 +960,127 @@ class VisItem : public Item\n // Rust module item - abstract base class\n class Module : public VisItem\n {\n-  Identifier module_name;\n-  Location locus;\n-\n-protected:\n-  // Protected constructor\n-  Module (Identifier module_name, Visibility visibility, Location locus,\n-\t  std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n-    : VisItem (std::move (visibility), std::move (outer_attrs)),\n-      module_name (module_name), locus (locus)\n-  {}\n-\n public:\n-  std::string as_string () const override;\n-\n-  Location get_locus () const { return locus; }\n+  // Type of the current module. A module can be either loaded or unloaded,\n+  // meaning that the items of the module can already be present or not. For\n+  // example, the following module would be loaded: `mod foo { fn bar() {} }`.\n+  // However, the module would be unloaded if it refers to an external file (i.e\n+  // `mod foo;`) and then become loaded upon expansion.\n+  enum ModuleKind\n+  {\n+    LOADED,\n+    UNLOADED,\n+  };\n \n-  // Invalid if name is empty, so base stripping on that.\n-  void mark_for_strip () override { module_name = \"\"; }\n-  bool is_marked_for_strip () const override { return module_name.empty (); }\n-};\n+private:\n+  Identifier module_name;\n+  Location locus;\n+  ModuleKind kind;\n \n-// Module with a body, defined in file\n-class ModuleBodied : public Module\n-{\n   // bool has_inner_attrs;\n   std::vector<Attribute> inner_attrs;\n   // bool has_items;\n-  std::vector<std::unique_ptr<Item> > items;\n+  std::vector<std::unique_ptr<Item>> items;\n \n-public:\n-  std::string as_string () const override;\n+  void clone_items (const std::vector<std::unique_ptr<Item>> &other_items)\n+  {\n+    items.reserve (other_items.size ());\n+    for (const auto &e : other_items)\n+      items.push_back (e->clone_item ());\n+  }\n \n+public:\n   // Returns whether the module has items in its body.\n   bool has_items () const { return !items.empty (); }\n \n   // Returns whether the module has any inner attributes.\n   bool has_inner_attrs () const { return !inner_attrs.empty (); }\n \n-  // Full constructor\n-  ModuleBodied (Identifier name, Location locus,\n-\t\tstd::vector<std::unique_ptr<Item> > items\n-\t\t= std::vector<std::unique_ptr<Item> > (),\n-\t\tVisibility visibility = Visibility::create_error (),\n-\t\tstd::vector<Attribute> inner_attrs = std::vector<Attribute> (),\n-\t\tstd::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n-    : Module (std::move (name), std::move (visibility), locus,\n-\t      std::move (outer_attrs)),\n+  // Unloaded module constructor\n+  Module (Identifier module_name, Visibility visibility,\n+\t  std::vector<Attribute> outer_attrs, Location locus)\n+    : VisItem (std::move (visibility), std::move (outer_attrs)),\n+      module_name (module_name), locus (locus), kind (ModuleKind::UNLOADED),\n+      inner_attrs (std::vector<Attribute> ()),\n+      items (std::vector<std::unique_ptr<Item>> ())\n+  {}\n+\n+  // Loaded module constructor, with items\n+  Module (Identifier name, Location locus,\n+\t  std::vector<std::unique_ptr<Item>> items,\n+\t  Visibility visibility = Visibility::create_error (),\n+\t  std::vector<Attribute> inner_attrs = std::vector<Attribute> (),\n+\t  std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n+    : VisItem (std::move (visibility), std::move (outer_attrs)),\n+      module_name (name), locus (locus), kind (ModuleKind::LOADED),\n       inner_attrs (std::move (inner_attrs)), items (std::move (items))\n   {}\n \n   // Copy constructor with vector clone\n-  ModuleBodied (ModuleBodied const &other)\n-    : Module (other), inner_attrs (other.inner_attrs)\n-  {\n-    items.reserve (other.items.size ());\n-    for (const auto &e : other.items)\n-      items.push_back (e->clone_item ());\n+  Module (Module const &other)\n+    : VisItem (other), module_name (other.module_name), locus (other.locus),\n+      kind (other.kind), inner_attrs (other.inner_attrs)\n+  {\n+    // We need to check whether we are copying a loaded module or an unloaded\n+    // one. In the second case, clear the `items` vector.\n+    if (other.kind == LOADED)\n+      clone_items (other.items);\n+    else\n+      items.clear ();\n   }\n \n   // Overloaded assignment operator with vector clone\n-  ModuleBodied &operator= (ModuleBodied const &other)\n+  Module &operator= (Module const &other)\n   {\n-    Module::operator= (other);\n+    VisItem::operator= (other);\n+\n+    module_name = other.module_name;\n+    locus = other.locus;\n+    kind = other.kind;\n     inner_attrs = other.inner_attrs;\n \n-    items.reserve (other.items.size ());\n-    for (const auto &e : other.items)\n-      items.push_back (e->clone_item ());\n+    // Likewise, we need to clear the `items` vector in case the other module is\n+    // unloaded\n+    if (kind == LOADED)\n+      clone_items (other.items);\n+    else\n+      items.clear ();\n \n     return *this;\n   }\n \n-  // move constructors\n-  ModuleBodied (ModuleBodied &&other) = default;\n-  ModuleBodied &operator= (ModuleBodied &&other) = default;\n-\n   void accept_vis (ASTVisitor &vis) override;\n \n   /* Override that runs the function recursively on all items contained within\n    * the module. */\n   void add_crate_name (std::vector<std::string> &names) const override;\n \n+  // Returns the kind of the module\n+  enum ModuleKind get_kind () const { return kind; }\n+\n   // TODO: think of better way to do this - mutable getter seems dodgy\n   const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n   std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n-  const std::vector<std::unique_ptr<Item> > &get_items () const\n-  {\n-    return items;\n-  }\n-  std::vector<std::unique_ptr<Item> > &get_items () { return items; }\n+  const std::vector<std::unique_ptr<Item>> &get_items () const { return items; }\n+  std::vector<std::unique_ptr<Item>> &get_items () { return items; }\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  ModuleBodied *clone_item_impl () const override\n-  {\n-    return new ModuleBodied (*this);\n-  }\n-};\n+  // move constructors\n+  Module (Module &&other) = default;\n+  Module &operator= (Module &&other) = default;\n \n-// Module without a body, loaded from external file\n-class ModuleNoBody : public Module\n-{\n-  /* TODO: are modules loaded from file unique? As in, can you load the same\n-   * file into two different other files? Because this may make the difference\n-   * between simply replacing this with the module\n-   * \"definition\" (as loaded from another file) vs this having to \"reference\" a\n-   * module with body. */\n-public:\n   std::string as_string () const override;\n \n-  // Full constructor\n-  ModuleNoBody (Identifier name, Visibility visibility,\n-\t\tstd::vector<Attribute> outer_attrs, Location locus)\n-    : Module (std::move (name), std::move (visibility), locus,\n-\t      std::move (outer_attrs))\n-  {}\n+  Location get_locus () const { return locus; }\n \n-  void accept_vis (ASTVisitor &vis) override;\n+  // Invalid if name is empty, so base stripping on that.\n+  void mark_for_strip () override { module_name = \"\"; }\n+  bool is_marked_for_strip () const override { return module_name.empty (); }\n \n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n-  ModuleNoBody *clone_item_impl () const override\n-  {\n-    return new ModuleNoBody (*this);\n-  }\n+  Module *clone_item_impl () const override { return new Module (*this); }\n };\n \n // Rust extern crate declaration AST node\n@@ -1242,11 +1234,11 @@ class UseTreeList : public UseTree\n   PathType path_type;\n   SimplePath path;\n \n-  std::vector<std::unique_ptr<UseTree> > trees;\n+  std::vector<std::unique_ptr<UseTree>> trees;\n \n public:\n   UseTreeList (PathType path_type, SimplePath path,\n-\t       std::vector<std::unique_ptr<UseTree> > trees, Location locus)\n+\t       std::vector<std::unique_ptr<UseTree>> trees, Location locus)\n     : UseTree (locus), path_type (path_type), path (std::move (path)),\n       trees (std::move (trees))\n   {\n@@ -1430,7 +1422,7 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   // bool has_function_params;\n   // FunctionParams function_params;\n@@ -1463,7 +1455,7 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \n   // Mega-constructor with all possible fields\n   Function (Identifier function_name, FunctionQualifiers qualifiers,\n-\t    std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t    std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t    std::vector<FunctionParam> function_params,\n \t    std::unique_ptr<Type> return_type, WhereClause where_clause,\n \t    std::unique_ptr<BlockExpr> function_body, Visibility vis,\n@@ -1554,11 +1546,11 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n     return function_params;\n   }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -1615,7 +1607,7 @@ class TypeAlias : public VisItem, public TraitImplItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n@@ -1635,7 +1627,7 @@ class TypeAlias : public VisItem, public TraitImplItem\n \n   // Mega-constructor with all possible fields\n   TypeAlias (Identifier new_type_name,\n-\t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t     std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t     WhereClause where_clause, std::unique_ptr<Type> existing_type,\n \t     Visibility vis, std::vector<Attribute> outer_attrs, Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n@@ -1697,11 +1689,11 @@ class TypeAlias : public VisItem, public TraitImplItem\n     return existing_type == nullptr;\n   }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -1744,7 +1736,7 @@ class Struct : public VisItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n@@ -1769,11 +1761,11 @@ class Struct : public VisItem\n \n   Identifier get_struct_name () const { return struct_name; }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -1789,7 +1781,7 @@ class Struct : public VisItem\n \n protected:\n   Struct (Identifier struct_name,\n-\t  std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t  std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t  WhereClause where_clause, Visibility vis, Location locus,\n \t  std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n@@ -1941,7 +1933,7 @@ class StructStruct : public Struct\n \n   // Mega-constructor with all possible fields\n   StructStruct (std::vector<StructField> fields, Identifier struct_name,\n-\t\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t\tstd::vector<std::unique_ptr<GenericParam>> generic_params,\n \t\tWhereClause where_clause, bool is_unit, Visibility vis,\n \t\tstd::vector<Attribute> outer_attrs, Location locus)\n     : Struct (std::move (struct_name), std::move (generic_params),\n@@ -1952,7 +1944,7 @@ class StructStruct : public Struct\n \n   // Unit struct constructor\n   StructStruct (Identifier struct_name,\n-\t\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t\tstd::vector<std::unique_ptr<GenericParam>> generic_params,\n \t\tWhereClause where_clause, Visibility vis,\n \t\tstd::vector<Attribute> outer_attrs, Location locus)\n     : Struct (std::move (struct_name), std::move (generic_params),\n@@ -2092,7 +2084,7 @@ class TupleStruct : public Struct\n \n   // Mega-constructor with all possible fields\n   TupleStruct (std::vector<TupleField> fields, Identifier struct_name,\n-\t       std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t       std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t       WhereClause where_clause, Visibility vis,\n \t       std::vector<Attribute> outer_attrs, Location locus)\n     : Struct (std::move (struct_name), std::move (generic_params),\n@@ -2304,12 +2296,12 @@ class Enum : public VisItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n \n-  std::vector<std::unique_ptr<EnumItem> > items;\n+  std::vector<std::unique_ptr<EnumItem>> items;\n \n   Location locus;\n \n@@ -2328,8 +2320,8 @@ class Enum : public VisItem\n \n   // Mega-constructor\n   Enum (Identifier enum_name, Visibility vis,\n-\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n-\tWhereClause where_clause, std::vector<std::unique_ptr<EnumItem> > items,\n+\tstd::vector<std::unique_ptr<GenericParam>> generic_params,\n+\tWhereClause where_clause, std::vector<std::unique_ptr<EnumItem>> items,\n \tstd::vector<Attribute> outer_attrs, Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n       enum_name (std::move (enum_name)),\n@@ -2386,17 +2378,17 @@ class Enum : public VisItem\n   bool is_marked_for_strip () const override { return enum_name.empty (); }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n-  std::vector<std::unique_ptr<EnumItem> > &get_variants () { return items; }\n-  const std::vector<std::unique_ptr<EnumItem> > &get_variants () const\n+  std::vector<std::unique_ptr<EnumItem>> &get_variants () { return items; }\n+  const std::vector<std::unique_ptr<EnumItem>> &get_variants () const\n   {\n     return items;\n   }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -2421,7 +2413,7 @@ class Union : public VisItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n@@ -2440,7 +2432,7 @@ class Union : public VisItem\n   bool has_where_clause () const { return !where_clause.is_empty (); }\n \n   Union (Identifier union_name, Visibility vis,\n-\t std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t WhereClause where_clause, std::vector<StructField> variants,\n \t std::vector<Attribute> outer_attrs, Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n@@ -2502,11 +2494,11 @@ class Union : public VisItem\n       }\n   }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -2757,7 +2749,7 @@ struct TraitFunctionDecl\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   // bool has_params;\n   // FunctionParams function_params;\n@@ -2788,7 +2780,7 @@ struct TraitFunctionDecl\n \n   // Mega-constructor\n   TraitFunctionDecl (Identifier function_name, FunctionQualifiers qualifiers,\n-\t\t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t\t     std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t\t     std::vector<FunctionParam> function_params,\n \t\t     std::unique_ptr<Type> return_type,\n \t\t     WhereClause where_clause)\n@@ -2854,11 +2846,11 @@ struct TraitFunctionDecl\n     return function_params;\n   }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -2979,7 +2971,7 @@ struct TraitMethodDecl\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   SelfParam self_param;\n \n@@ -3012,7 +3004,7 @@ struct TraitMethodDecl\n \n   // Mega-constructor\n   TraitMethodDecl (Identifier function_name, FunctionQualifiers qualifiers,\n-\t\t   std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t\t   std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t\t   SelfParam self_param,\n \t\t   std::vector<FunctionParam> function_params,\n \t\t   std::unique_ptr<Type> return_type, WhereClause where_clause)\n@@ -3081,11 +3073,11 @@ struct TraitMethodDecl\n     return function_params;\n   }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -3315,7 +3307,7 @@ class TraitItemType : public TraitItem\n \n   // bool has_type_param_bounds;\n   // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound> >\n+  std::vector<std::unique_ptr<TypeParamBound>>\n     type_param_bounds; // inlined form\n \n   Location locus;\n@@ -3324,10 +3316,9 @@ class TraitItemType : public TraitItem\n   // Returns whether trait item type has type param bounds.\n   bool has_type_param_bounds () const { return !type_param_bounds.empty (); }\n \n-  TraitItemType (\n-    Identifier name,\n-    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n-    std::vector<Attribute> outer_attrs, Location locus)\n+  TraitItemType (Identifier name,\n+\t\t std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n+\t\t std::vector<Attribute> outer_attrs, Location locus)\n     : TraitItem (), outer_attrs (std::move (outer_attrs)),\n       name (std::move (name)),\n       type_param_bounds (std::move (type_param_bounds)), locus (locus)\n@@ -3378,11 +3369,11 @@ class TraitItemType : public TraitItem\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n   // TODO: mutable getter seems kinda dodgy\n-  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  std::vector<std::unique_ptr<TypeParamBound>> &get_type_param_bounds ()\n   {\n     return type_param_bounds;\n   }\n-  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  const std::vector<std::unique_ptr<TypeParamBound>> &\n   get_type_param_bounds () const\n   {\n     return type_param_bounds;\n@@ -3403,11 +3394,11 @@ class Trait : public VisItem\n {\n   bool has_unsafe;\n   Identifier name;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params;\n-  std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds;\n+  std::vector<std::unique_ptr<GenericParam>> generic_params;\n+  std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds;\n   WhereClause where_clause;\n   std::vector<Attribute> inner_attrs;\n-  std::vector<std::unique_ptr<TraitItem> > trait_items;\n+  std::vector<std::unique_ptr<TraitItem>> trait_items;\n   Location locus;\n \n public:\n@@ -3434,10 +3425,10 @@ class Trait : public VisItem\n \n   // Mega-constructor\n   Trait (Identifier name, bool is_unsafe,\n-\t std::vector<std::unique_ptr<GenericParam> > generic_params,\n-\t std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n+\t std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n \t WhereClause where_clause,\n-\t std::vector<std::unique_ptr<TraitItem> > trait_items, Visibility vis,\n+\t std::vector<std::unique_ptr<TraitItem>> trait_items, Visibility vis,\n \t std::vector<Attribute> outer_attrs, std::vector<Attribute> inner_attrs,\n \t Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n@@ -3509,29 +3500,29 @@ class Trait : public VisItem\n   const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n   std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n-  const std::vector<std::unique_ptr<TraitItem> > &get_trait_items () const\n+  const std::vector<std::unique_ptr<TraitItem>> &get_trait_items () const\n   {\n     return trait_items;\n   }\n-  std::vector<std::unique_ptr<TraitItem> > &get_trait_items ()\n+  std::vector<std::unique_ptr<TraitItem>> &get_trait_items ()\n   {\n     return trait_items;\n   }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n \n-  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  std::vector<std::unique_ptr<TypeParamBound>> &get_type_param_bounds ()\n   {\n     return type_param_bounds;\n   }\n-  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  const std::vector<std::unique_ptr<TypeParamBound>> &\n   get_type_param_bounds () const\n   {\n     return type_param_bounds;\n@@ -3561,7 +3552,7 @@ class Impl : public VisItem\n protected:\n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   std::unique_ptr<Type> trait_type;\n \n@@ -3595,11 +3586,11 @@ class Impl : public VisItem\n   const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n   std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -3620,7 +3611,7 @@ class Impl : public VisItem\n \n protected:\n   // Mega-constructor\n-  Impl (std::vector<std::unique_ptr<GenericParam> > generic_params,\n+  Impl (std::vector<std::unique_ptr<GenericParam>> generic_params,\n \tstd::unique_ptr<Type> trait_type, WhereClause where_clause,\n \tVisibility vis, std::vector<Attribute> inner_attrs,\n \tstd::vector<Attribute> outer_attrs, Location locus)\n@@ -3675,7 +3666,7 @@ class Impl : public VisItem\n class InherentImpl : public Impl\n {\n   // bool has_impl_items;\n-  std::vector<std::unique_ptr<InherentImplItem> > impl_items;\n+  std::vector<std::unique_ptr<InherentImplItem>> impl_items;\n \n public:\n   std::string as_string () const override;\n@@ -3684,8 +3675,8 @@ class InherentImpl : public Impl\n   bool has_impl_items () const { return !impl_items.empty (); }\n \n   // Mega-constructor\n-  InherentImpl (std::vector<std::unique_ptr<InherentImplItem> > impl_items,\n-\t\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n+  InherentImpl (std::vector<std::unique_ptr<InherentImplItem>> impl_items,\n+\t\tstd::vector<std::unique_ptr<GenericParam>> generic_params,\n \t\tstd::unique_ptr<Type> trait_type, WhereClause where_clause,\n \t\tVisibility vis, std::vector<Attribute> inner_attrs,\n \t\tstd::vector<Attribute> outer_attrs, Location locus)\n@@ -3722,11 +3713,11 @@ class InherentImpl : public Impl\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: think of better way to do this\n-  const std::vector<std::unique_ptr<InherentImplItem> > &get_impl_items () const\n+  const std::vector<std::unique_ptr<InherentImplItem>> &get_impl_items () const\n   {\n     return impl_items;\n   }\n-  std::vector<std::unique_ptr<InherentImplItem> > &get_impl_items ()\n+  std::vector<std::unique_ptr<InherentImplItem>> &get_impl_items ()\n   {\n     return impl_items;\n   }\n@@ -3748,7 +3739,7 @@ class TraitImpl : public Impl\n   TypePath trait_path;\n \n   // bool has_impl_items;\n-  std::vector<std::unique_ptr<TraitImplItem> > impl_items;\n+  std::vector<std::unique_ptr<TraitImplItem>> impl_items;\n \n public:\n   std::string as_string () const override;\n@@ -3758,8 +3749,8 @@ class TraitImpl : public Impl\n \n   // Mega-constructor\n   TraitImpl (TypePath trait_path, bool is_unsafe, bool has_exclam,\n-\t     std::vector<std::unique_ptr<TraitImplItem> > impl_items,\n-\t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t     std::vector<std::unique_ptr<TraitImplItem>> impl_items,\n+\t     std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t     std::unique_ptr<Type> trait_type, WhereClause where_clause,\n \t     Visibility vis, std::vector<Attribute> inner_attrs,\n \t     std::vector<Attribute> outer_attrs, Location locus)\n@@ -3805,11 +3796,11 @@ class TraitImpl : public Impl\n   bool is_exclam () const { return has_exclam; }\n \n   // TODO: think of better way to do this\n-  const std::vector<std::unique_ptr<TraitImplItem> > &get_impl_items () const\n+  const std::vector<std::unique_ptr<TraitImplItem>> &get_impl_items () const\n   {\n     return impl_items;\n   }\n-  std::vector<std::unique_ptr<TraitImplItem> > &get_impl_items ()\n+  std::vector<std::unique_ptr<TraitImplItem>> &get_impl_items ()\n   {\n     return impl_items;\n   }\n@@ -4116,7 +4107,7 @@ class ExternalFunctionItem : public ExternalItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   // bool has_return_type;\n   // FunctionReturnType return_type;\n@@ -4158,7 +4149,7 @@ class ExternalFunctionItem : public ExternalItem\n \n   ExternalFunctionItem (\n     Identifier item_name,\n-    std::vector<std::unique_ptr<GenericParam> > generic_params,\n+    std::vector<std::unique_ptr<GenericParam>> generic_params,\n     std::unique_ptr<Type> return_type, WhereClause where_clause,\n     std::vector<NamedFunctionParam> function_params, bool has_variadics,\n     std::vector<Attribute> variadic_outer_attrs, Visibility vis,\n@@ -4246,11 +4237,11 @@ class ExternalFunctionItem : public ExternalItem\n     return function_params;\n   }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -4290,7 +4281,7 @@ class ExternBlock : public VisItem\n   std::vector<Attribute> inner_attrs;\n \n   // bool has_extern_items;\n-  std::vector<std::unique_ptr<ExternalItem> > extern_items;\n+  std::vector<std::unique_ptr<ExternalItem>> extern_items;\n \n   Location locus;\n \n@@ -4312,7 +4303,7 @@ class ExternBlock : public VisItem\n   std::string get_abi () const { return abi; }\n \n   ExternBlock (std::string abi,\n-\t       std::vector<std::unique_ptr<ExternalItem> > extern_items,\n+\t       std::vector<std::unique_ptr<ExternalItem>> extern_items,\n \t       Visibility vis, std::vector<Attribute> inner_attrs,\n \t       std::vector<Attribute> outer_attrs, Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)), abi (std::move (abi)),\n@@ -4359,11 +4350,11 @@ class ExternBlock : public VisItem\n   bool is_marked_for_strip () const override { return marked_for_strip; }\n \n   // TODO: think of better way to do this\n-  const std::vector<std::unique_ptr<ExternalItem> > &get_extern_items () const\n+  const std::vector<std::unique_ptr<ExternalItem>> &get_extern_items () const\n   {\n     return extern_items;\n   }\n-  std::vector<std::unique_ptr<ExternalItem> > &get_extern_items ()\n+  std::vector<std::unique_ptr<ExternalItem>> &get_extern_items ()\n   {\n     return extern_items;\n   }"}, {"sha": "0a2547179793ed60240761d04f3f8167f77f9770", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15635e68bb65d5ce6963ce0c820719a06ca794cd/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15635e68bb65d5ce6963ce0c820719a06ca794cd/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=15635e68bb65d5ce6963ce0c820719a06ca794cd", "patch": "@@ -2015,7 +2015,7 @@ class AttrVisitor : public AST::ASTVisitor\n \t\t     \"cannot strip block expression in this position - outer \"\n \t\t     \"attributes not allowed\");\n   }\n-  void visit (AST::ModuleBodied &module) override\n+  void visit (AST::Module &module) override\n   {\n     // strip test based on outer attrs\n     expander.expand_cfg_attrs (module.get_outer_attrs ());\n@@ -2025,27 +2025,21 @@ class AttrVisitor : public AST::ASTVisitor\n \treturn;\n       }\n \n-    // strip test based on inner attrs\n-    expander.expand_cfg_attrs (module.get_inner_attrs ());\n-    if (expander.fails_cfg_with_expand (module.get_inner_attrs ()))\n+    // A loaded module might have inner attributes\n+    if (module.get_kind () == AST::Module::ModuleKind::LOADED)\n       {\n-\tmodule.mark_for_strip ();\n-\treturn;\n+\t// strip test based on inner attrs\n+\texpander.expand_cfg_attrs (module.get_inner_attrs ());\n+\tif (expander.fails_cfg_with_expand (module.get_inner_attrs ()))\n+\t  {\n+\t    module.mark_for_strip ();\n+\t    return;\n+\t  }\n       }\n \n     // strip items if required\n     expand_pointer_allow_strip (module.get_items ());\n   }\n-  void visit (AST::ModuleNoBody &module) override\n-  {\n-    // strip test based on outer attrs\n-    expander.expand_cfg_attrs (module.get_outer_attrs ());\n-    if (expander.fails_cfg_with_expand (module.get_outer_attrs ()))\n-      {\n-\tmodule.mark_for_strip ();\n-\treturn;\n-      }\n-  }\n   void visit (AST::ExternCrate &crate) override\n   {\n     // strip test based on outer attrs"}, {"sha": "7ef5938697e9cafb4497633194c04c80ddb6438e", "filename": "gcc/rust/hir/rust-ast-lower-base.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15635e68bb65d5ce6963ce0c820719a06ca794cd/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15635e68bb65d5ce6963ce0c820719a06ca794cd/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h?ref=15635e68bb65d5ce6963ce0c820719a06ca794cd", "patch": "@@ -146,8 +146,7 @@ class ASTLoweringBase : public AST::ASTVisitor\n   virtual void visit (AST::LifetimeWhereClauseItem &item) {}\n   virtual void visit (AST::TypeBoundWhereClauseItem &item) {}\n   virtual void visit (AST::Method &method) {}\n-  virtual void visit (AST::ModuleBodied &module) {}\n-  virtual void visit (AST::ModuleNoBody &module) {}\n+  virtual void visit (AST::Module &module) {}\n   virtual void visit (AST::ExternCrate &crate) {}\n   //  virtual void visit(UseTree& use_tree) {}\n   virtual void visit (AST::UseTreeGlob &use_tree) {}"}, {"sha": "596a682c59de55264888a39fdbef188402cb04d7", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15635e68bb65d5ce6963ce0c820719a06ca794cd/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15635e68bb65d5ce6963ce0c820719a06ca794cd/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=15635e68bb65d5ce6963ce0c820719a06ca794cd", "patch": "@@ -2121,10 +2121,10 @@ Parser<ManagedTokenSource>::parse_module (AST::Visibility vis,\n     case SEMICOLON:\n       lexer.skip_token ();\n \n-      return std::unique_ptr<AST::ModuleNoBody> (\n-\tnew AST::ModuleNoBody (std::move (name), std::move (vis),\n-\t\t\t       std::move (outer_attrs),\n-\t\t\t       locus)); // module name?\n+      return std::unique_ptr<AST::Module> (\n+\tnew AST::Module (std::move (name), std::move (vis),\n+\t\t\t std::move (outer_attrs),\n+\t\t\t locus)); // module name?\n       case LEFT_CURLY: {\n \tlexer.skip_token ();\n \n@@ -2157,10 +2157,10 @@ Parser<ManagedTokenSource>::parse_module (AST::Visibility vis,\n \t    return nullptr;\n \t  }\n \n-\treturn std::unique_ptr<AST::ModuleBodied> (\n-\t  new AST::ModuleBodied (std::move (name), locus, std::move (items),\n-\t\t\t\t std::move (vis), std::move (inner_attrs),\n-\t\t\t\t std::move (outer_attrs))); // module name?\n+\treturn std::unique_ptr<AST::Module> (\n+\t  new AST::Module (std::move (name), locus, std::move (items),\n+\t\t\t   std::move (vis), std::move (inner_attrs),\n+\t\t\t   std::move (outer_attrs))); // module name?\n       }\n     default:\n       add_error ("}, {"sha": "10e2b1bf6d551f4d69d9f851a75aa3969b159f5f", "filename": "gcc/rust/resolve/rust-ast-resolve-base.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15635e68bb65d5ce6963ce0c820719a06ca794cd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15635e68bb65d5ce6963ce0c820719a06ca794cd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h?ref=15635e68bb65d5ce6963ce0c820719a06ca794cd", "patch": "@@ -119,8 +119,7 @@ class ResolverBase : public AST::ASTVisitor\n   void visit (AST::LifetimeWhereClauseItem &) {}\n   void visit (AST::TypeBoundWhereClauseItem &) {}\n   void visit (AST::Method &) {}\n-  void visit (AST::ModuleBodied &) {}\n-  void visit (AST::ModuleNoBody &) {}\n+  void visit (AST::Module &) {}\n   void visit (AST::ExternCrate &) {}\n \n   void visit (AST::UseTreeGlob &) {}"}]}