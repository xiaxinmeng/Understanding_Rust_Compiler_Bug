{"sha": "28151221b583422b67e223d255545dae326fce5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgxNTEyMjFiNTgzNDIyYjY3ZTIyM2QyNTU1NDVkYWUzMjZmY2U1YQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2014-04-28T16:55:40Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2014-04-28T16:55:40Z"}, "message": "tree-sra.c (sra_modify_expr): Generate new memory accesses with same alias type as the original statement.\n\n2014-04-28  Martin Jambor  <mjambor@suse.cz>\n\n\t* tree-sra.c (sra_modify_expr): Generate new memory accesses with\n\tsame alias type as the original statement.\n\t(subreplacement_assignment_data): New type.\n\t(handle_unscalarized_data_in_subtree): New type of parameter,\n\tgenerate new memory accesses with same alias type as the original\n\tstatement.\n\t(load_assign_lhs_subreplacements): Likewise.\n\t(sra_modify_constructor_assign): Generate new memory accesses with\n\tsame alias type as the original statement.\n\ntestsuite/\n        * gcc.dg/tree-ssa/sra-14.c: New test.\n\nFrom-SVN: r209868", "tree": {"sha": "ab11ee9ce415853d1400973e6d4370089821aa91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab11ee9ce415853d1400973e6d4370089821aa91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28151221b583422b67e223d255545dae326fce5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28151221b583422b67e223d255545dae326fce5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28151221b583422b67e223d255545dae326fce5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28151221b583422b67e223d255545dae326fce5a/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9358288555fadf2280d4388de45a1a1a5d6a68f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9358288555fadf2280d4388de45a1a1a5d6a68f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9358288555fadf2280d4388de45a1a1a5d6a68f7"}], "stats": {"total": 263, "additions": 187, "deletions": 76}, "files": [{"sha": "61c8eccd90b86866c54c47282676b32a5b1ae92d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28151221b583422b67e223d255545dae326fce5a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28151221b583422b67e223d255545dae326fce5a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28151221b583422b67e223d255545dae326fce5a", "patch": "@@ -1,3 +1,15 @@\n+2014-04-28  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* tree-sra.c (sra_modify_expr): Generate new memory accesses with\n+\tsame alias type as the original statement.\n+\t(subreplacement_assignment_data): New type.\n+\t(handle_unscalarized_data_in_subtree): New type of parameter,\n+\tgenerate new memory accesses with same alias type as the original\n+\tstatement.\n+\t(load_assign_lhs_subreplacements): Likewise.\n+\t(sra_modify_constructor_assign): Generate new memory accesses with\n+\tsame alias type as the original statement.\n+\n 2014-04-28  Richard Biener  <rguenther@suse.de>\n \n \t* tree-pass.h (TODO_verify_il): Define."}, {"sha": "b2f07c669c437abb7770132c65deaa16567d0452", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28151221b583422b67e223d255545dae326fce5a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28151221b583422b67e223d255545dae326fce5a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=28151221b583422b67e223d255545dae326fce5a", "patch": "@@ -1,3 +1,7 @@\n+2014-04-28  Martin Jambor  <mjambor@suse.cz>\n+\n+        * gcc.dg/tree-ssa/sra-14.c: New test.\n+\n 2014-04-28  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/60092"}, {"sha": "6cbc0b43d583629d759baa66e6acc17f1fc9d7e4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/sra-14.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28151221b583422b67e223d255545dae326fce5a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28151221b583422b67e223d255545dae326fce5a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-14.c?ref=28151221b583422b67e223d255545dae326fce5a", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O1\" } */\n+\n+struct S\n+{\n+  int i, j;\n+};\n+\n+struct Z\n+{\n+  struct S d, s;\n+};\n+\n+struct S __attribute__ ((noinline, noclone))\n+get_s (void)\n+{\n+  struct S s;\n+  s.i = 5;\n+  s.j = 6;\n+\n+  return s;\n+}\n+\n+struct S __attribute__ ((noinline, noclone))\n+get_d (void)\n+{\n+  struct S d;\n+  d.i = 0;\n+  d.j = 0;\n+\n+  return d;\n+}\n+\n+int __attribute__ ((noinline, noclone))\n+get_c (void)\n+{\n+  return 1;\n+}\n+\n+int __attribute__ ((noinline, noclone))\n+my_nop (int i)\n+{\n+  return i;\n+}\n+\n+int __attribute__ ((noinline, noclone))\n+foo (void)\n+{\n+  struct Z z;\n+  int i, c = get_c ();\n+\n+  z.d = get_d ();\n+  z.s = get_s ();\n+\n+  for (i = 0; i < c; i++)\n+    {\n+      z.s.i = my_nop (z.s.i);\n+      z.s.j = my_nop (z.s.j);\n+    }\n+\n+  return z.s.i + z.s.j;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  if (foo () != 11)\n+    __builtin_abort ();\n+  return 0;\n+}\n+"}, {"sha": "4a24e6a1b70a5f869b0a222741d7bba990ce2ca3", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 101, "deletions": 76, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28151221b583422b67e223d255545dae326fce5a/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28151221b583422b67e223d255545dae326fce5a/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=28151221b583422b67e223d255545dae326fce5a", "patch": "@@ -2769,7 +2769,7 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n {\n   location_t loc;\n   struct access *access;\n-  tree type, bfr;\n+  tree type, bfr, orig_expr;\n \n   if (TREE_CODE (*expr) == BIT_FIELD_REF)\n     {\n@@ -2785,6 +2785,7 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n   if (!access)\n     return false;\n   type = TREE_TYPE (*expr);\n+  orig_expr = *expr;\n \n   loc = gimple_location (gsi_stmt (*gsi));\n   gimple_stmt_iterator alt_gsi = gsi_none ();\n@@ -2811,8 +2812,7 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n \t{\n \t  tree ref;\n \n-\t  ref = build_ref_for_model (loc, access->base, access->offset, access,\n-\t\t\t\t     NULL, false);\n+\t  ref = build_ref_for_model (loc, orig_expr, 0, access, NULL, false);\n \n \t  if (write)\n \t    {\n@@ -2863,7 +2863,7 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n       else\n \tstart_offset = chunk_size = 0;\n \n-      generate_subtree_copies (access->first_child, access->base, 0,\n+      generate_subtree_copies (access->first_child, orig_expr, access->offset,\n \t\t\t       start_offset, chunk_size, gsi, write, write,\n \t\t\t       loc);\n     }\n@@ -2877,107 +2877,128 @@ enum unscalarized_data_handling { SRA_UDH_NONE,  /* Nothing done so far. */\n \t\t\t\t  SRA_UDH_RIGHT, /* Data flushed to the RHS. */\n \t\t\t\t  SRA_UDH_LEFT }; /* Data flushed to the LHS. */\n \n+struct subreplacement_assignment_data\n+{\n+  /* Offset of the access representing the lhs of the assignment.  */\n+  HOST_WIDE_INT left_offset;\n+\n+  /* LHS and RHS of the original assignment.  */\n+  tree assignment_lhs, assignment_rhs;\n+\n+  /* Access representing the rhs of the whole assignment.  */\n+  struct access *top_racc;\n+\n+  /* Stmt iterator used for statement insertions after the original assignment.\n+   It points to the main GSI used to traverse a BB during function body\n+   modification.  */\n+  gimple_stmt_iterator *new_gsi;\n+\n+  /* Stmt iterator used for statement insertions before the original\n+   assignment.  Keeps on pointing to the original statement.  */\n+  gimple_stmt_iterator old_gsi;\n+\n+  /* Location of the assignment.   */\n+  location_t loc;\n+\n+  /* Keeps the information whether we have needed to refresh replacements of\n+   the LHS and from which side of the assignments this takes place.  */\n+  enum unscalarized_data_handling refreshed;\n+};\n+\n /* Store all replacements in the access tree rooted in TOP_RACC either to their\n    base aggregate if there are unscalarized data or directly to LHS of the\n    statement that is pointed to by GSI otherwise.  */\n \n-static enum unscalarized_data_handling\n-handle_unscalarized_data_in_subtree (struct access *top_racc,\n-\t\t\t\t     gimple_stmt_iterator *gsi)\n+static void\n+handle_unscalarized_data_in_subtree (struct subreplacement_assignment_data *sad)\n {\n-  if (top_racc->grp_unscalarized_data)\n+  tree src;\n+  if (sad->top_racc->grp_unscalarized_data)\n     {\n-      generate_subtree_copies (top_racc->first_child, top_racc->base, 0, 0, 0,\n-\t\t\t       gsi, false, false,\n-\t\t\t       gimple_location (gsi_stmt (*gsi)));\n-      return SRA_UDH_RIGHT;\n+      src = sad->assignment_rhs;\n+      sad->refreshed = SRA_UDH_RIGHT;\n     }\n   else\n     {\n-      tree lhs = gimple_assign_lhs (gsi_stmt (*gsi));\n-      generate_subtree_copies (top_racc->first_child, lhs, top_racc->offset,\n-\t\t\t       0, 0, gsi, false, false,\n-\t\t\t       gimple_location (gsi_stmt (*gsi)));\n-      return SRA_UDH_LEFT;\n+      src = sad->assignment_lhs;\n+      sad->refreshed = SRA_UDH_LEFT;\n     }\n+  generate_subtree_copies (sad->top_racc->first_child, src,\n+\t\t\t   sad->top_racc->offset, 0, 0,\n+\t\t\t   &sad->old_gsi, false, false, sad->loc);\n }\n \n-\n /* Try to generate statements to load all sub-replacements in an access subtree\n-   formed by children of LACC from scalar replacements in the TOP_RACC subtree.\n-   If that is not possible, refresh the TOP_RACC base aggregate and load the\n-   accesses from it.  LEFT_OFFSET is the offset of the left whole subtree being\n-   copied. NEW_GSI is stmt iterator used for statement insertions after the\n-   original assignment, OLD_GSI is used to insert statements before the\n-   assignment.  *REFRESHED keeps the information whether we have needed to\n-   refresh replacements of the LHS and from which side of the assignments this\n-   takes place.  */\n+   formed by children of LACC from scalar replacements in the SAD->top_racc\n+   subtree.  If that is not possible, refresh the SAD->top_racc base aggregate\n+   and load the accesses from it.  */\n \n static void\n-load_assign_lhs_subreplacements (struct access *lacc, struct access *top_racc,\n-\t\t\t\t HOST_WIDE_INT left_offset,\n-\t\t\t\t gimple_stmt_iterator *old_gsi,\n-\t\t\t\t gimple_stmt_iterator *new_gsi,\n-\t\t\t\t enum unscalarized_data_handling *refreshed)\n+load_assign_lhs_subreplacements (struct access *lacc,\n+\t\t\t\t struct subreplacement_assignment_data *sad)\n {\n-  location_t loc = gimple_location (gsi_stmt (*old_gsi));\n   for (lacc = lacc->first_child; lacc; lacc = lacc->next_sibling)\n     {\n-      HOST_WIDE_INT offset = lacc->offset - left_offset + top_racc->offset;\n+      HOST_WIDE_INT offset;\n+      offset = lacc->offset - sad->left_offset + sad->top_racc->offset;\n \n       if (lacc->grp_to_be_replaced)\n \t{\n \t  struct access *racc;\n \t  gimple stmt;\n \t  tree rhs;\n \n-\t  racc = find_access_in_subtree (top_racc, offset, lacc->size);\n+\t  racc = find_access_in_subtree (sad->top_racc, offset, lacc->size);\n \t  if (racc && racc->grp_to_be_replaced)\n \t    {\n \t      rhs = get_access_replacement (racc);\n \t      if (!useless_type_conversion_p (lacc->type, racc->type))\n-\t\trhs = fold_build1_loc (loc, VIEW_CONVERT_EXPR, lacc->type, rhs);\n+\t\trhs = fold_build1_loc (sad->loc, VIEW_CONVERT_EXPR,\n+\t\t\t\t       lacc->type, rhs);\n \n \t      if (racc->grp_partial_lhs && lacc->grp_partial_lhs)\n-\t\trhs = force_gimple_operand_gsi (old_gsi, rhs, true, NULL_TREE,\n-\t\t\t\t\t\ttrue, GSI_SAME_STMT);\n+\t\trhs = force_gimple_operand_gsi (&sad->old_gsi, rhs, true,\n+\t\t\t\t\t\tNULL_TREE, true, GSI_SAME_STMT);\n \t    }\n \t  else\n \t    {\n \t      /* No suitable access on the right hand side, need to load from\n \t\t the aggregate.  See if we have to update it first... */\n-\t      if (*refreshed == SRA_UDH_NONE)\n-\t\t*refreshed = handle_unscalarized_data_in_subtree (top_racc,\n-\t\t\t\t\t\t\t\t  old_gsi);\n+\t      if (sad->refreshed == SRA_UDH_NONE)\n+\t\thandle_unscalarized_data_in_subtree (sad);\n \n-\t      if (*refreshed == SRA_UDH_LEFT)\n-\t\trhs = build_ref_for_model (loc, lacc->base, lacc->offset, lacc,\n-\t\t\t\t\t    new_gsi, true);\n+\t      if (sad->refreshed == SRA_UDH_LEFT)\n+\t\trhs = build_ref_for_model (sad->loc, sad->assignment_lhs,\n+\t\t\t\t\t   lacc->offset - sad->left_offset,\n+\t\t\t\t\t   lacc, sad->new_gsi, true);\n \t      else\n-\t\trhs = build_ref_for_model (loc, top_racc->base, offset, lacc,\n-\t\t\t\t\t    new_gsi, true);\n+\t\trhs = build_ref_for_model (sad->loc, sad->assignment_rhs,\n+\t\t\t\t\t   lacc->offset - sad->left_offset,\n+\t\t\t\t\t   lacc, sad->new_gsi, true);\n \t      if (lacc->grp_partial_lhs)\n-\t\trhs = force_gimple_operand_gsi (new_gsi, rhs, true, NULL_TREE,\n+\t\trhs = force_gimple_operand_gsi (sad->new_gsi,\n+\t\t\t\t\t\trhs, true, NULL_TREE,\n \t\t\t\t\t\tfalse, GSI_NEW_STMT);\n \t    }\n \n \t  stmt = gimple_build_assign (get_access_replacement (lacc), rhs);\n-\t  gsi_insert_after (new_gsi, stmt, GSI_NEW_STMT);\n-\t  gimple_set_location (stmt, loc);\n+\t  gsi_insert_after (sad->new_gsi, stmt, GSI_NEW_STMT);\n+\t  gimple_set_location (stmt, sad->loc);\n \t  update_stmt (stmt);\n \t  sra_stats.subreplacements++;\n \t}\n       else\n \t{\n-\t  if (*refreshed == SRA_UDH_NONE\n+\t  if (sad->refreshed == SRA_UDH_NONE\n \t      && lacc->grp_read && !lacc->grp_covered)\n-\t    *refreshed = handle_unscalarized_data_in_subtree (top_racc,\n-\t\t\t\t\t\t\t      old_gsi);\n+\t    handle_unscalarized_data_in_subtree (sad);\n+\n \t  if (lacc && lacc->grp_to_be_debug_replaced)\n \t    {\n \t      gimple ds;\n \t      tree drhs;\n-\t      struct access *racc = find_access_in_subtree (top_racc, offset,\n+\t      struct access *racc = find_access_in_subtree (sad->top_racc,\n+\t\t\t\t\t\t\t    offset,\n \t\t\t\t\t\t\t    lacc->size);\n \n \t      if (racc && racc->grp_to_be_replaced)\n@@ -2987,27 +3008,26 @@ load_assign_lhs_subreplacements (struct access *lacc, struct access *top_racc,\n \t\t  else\n \t\t    drhs = NULL;\n \t\t}\n-\t      else if (*refreshed == SRA_UDH_LEFT)\n-\t\tdrhs = build_debug_ref_for_model (loc, lacc->base, lacc->offset,\n-\t\t\t\t\t\t  lacc);\n-\t      else if (*refreshed == SRA_UDH_RIGHT)\n-\t\tdrhs = build_debug_ref_for_model (loc, top_racc->base, offset,\n-\t\t\t\t\t\t  lacc);\n+\t      else if (sad->refreshed == SRA_UDH_LEFT)\n+\t\tdrhs = build_debug_ref_for_model (sad->loc, lacc->base,\n+\t\t\t\t\t\t  lacc->offset, lacc);\n+\t      else if (sad->refreshed == SRA_UDH_RIGHT)\n+\t\tdrhs = build_debug_ref_for_model (sad->loc, sad->top_racc->base,\n+\t\t\t\t\t\t  offset, lacc);\n \t      else\n \t\tdrhs = NULL_TREE;\n \t      if (drhs\n \t\t  && !useless_type_conversion_p (lacc->type, TREE_TYPE (drhs)))\n-\t\tdrhs = fold_build1_loc (loc, VIEW_CONVERT_EXPR,\n+\t\tdrhs = fold_build1_loc (sad->loc, VIEW_CONVERT_EXPR,\n \t\t\t\t\tlacc->type, drhs);\n \t      ds = gimple_build_debug_bind (get_access_replacement (lacc),\n-\t\t\t\t\t    drhs, gsi_stmt (*old_gsi));\n-\t      gsi_insert_after (new_gsi, ds, GSI_NEW_STMT);\n+\t\t\t\t\t    drhs, gsi_stmt (sad->old_gsi));\n+\t      gsi_insert_after (sad->new_gsi, ds, GSI_NEW_STMT);\n \t    }\n \t}\n \n       if (lacc->first_child)\n-\tload_assign_lhs_subreplacements (lacc, top_racc, left_offset,\n-\t\t\t\t\t old_gsi, new_gsi, refreshed);\n+\tload_assign_lhs_subreplacements (lacc, sad);\n     }\n }\n \n@@ -3053,7 +3073,7 @@ sra_modify_constructor_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n       /* I have never seen this code path trigger but if it can happen the\n \t following should handle it gracefully.  */\n       if (access_has_children_p (acc))\n-\tgenerate_subtree_copies (acc->first_child, acc->base, 0, 0, 0, gsi,\n+\tgenerate_subtree_copies (acc->first_child, lhs, acc->offset, 0, 0, gsi,\n \t\t\t\t true, true, loc);\n       return SRA_AM_MODIFIED;\n     }\n@@ -3261,7 +3281,7 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n       || stmt_ends_bb_p (*stmt))\n     {\n       if (access_has_children_p (racc))\n-\tgenerate_subtree_copies (racc->first_child, racc->base, 0, 0, 0,\n+\tgenerate_subtree_copies (racc->first_child, rhs, racc->offset, 0, 0,\n \t\t\t\t gsi, false, false, loc);\n       if (access_has_children_p (lacc))\n \t{\n@@ -3271,7 +3291,7 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n \t      alt_gsi = gsi_start_edge (single_non_eh_succ (gsi_bb (*gsi)));\n \t      gsi = &alt_gsi;\n \t    }\n-\t  generate_subtree_copies (lacc->first_child, lacc->base, 0, 0, 0,\n+\t  generate_subtree_copies (lacc->first_child, lhs, lacc->offset, 0, 0,\n \t\t\t\t   gsi, true, true, loc);\n \t}\n       sra_stats.separate_lhs_rhs_handling++;\n@@ -3301,21 +3321,26 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n \t  && !lacc->grp_unscalarizable_region\n \t  && !racc->grp_unscalarizable_region)\n \t{\n-\t  gimple_stmt_iterator orig_gsi = *gsi;\n-\t  enum unscalarized_data_handling refreshed;\n+\t  struct subreplacement_assignment_data sad;\n+\n+\t  sad.left_offset = lacc->offset;\n+\t  sad.assignment_lhs = lhs;\n+\t  sad.assignment_rhs = rhs;\n+\t  sad.top_racc = racc;\n+\t  sad.old_gsi = *gsi;\n+\t  sad.new_gsi = gsi;\n+\t  sad.loc = gimple_location (*stmt);\n+\t  sad.refreshed = SRA_UDH_NONE;\n \n \t  if (lacc->grp_read && !lacc->grp_covered)\n-\t    refreshed = handle_unscalarized_data_in_subtree (racc, gsi);\n-\t  else\n-\t    refreshed = SRA_UDH_NONE;\n+\t    handle_unscalarized_data_in_subtree (&sad);\n \n-\t  load_assign_lhs_subreplacements (lacc, racc, lacc->offset,\n-\t\t\t\t\t   &orig_gsi, gsi, &refreshed);\n-\t  if (refreshed != SRA_UDH_RIGHT)\n+\t  load_assign_lhs_subreplacements (lacc, &sad);\n+\t  if (sad.refreshed != SRA_UDH_RIGHT)\n \t    {\n \t      gsi_next (gsi);\n \t      unlink_stmt_vdef (*stmt);\n-\t      gsi_remove (&orig_gsi, true);\n+\t      gsi_remove (&sad.old_gsi, true);\n \t      release_defs (*stmt);\n \t      sra_stats.deleted++;\n \t      return SRA_AM_REMOVED;\n@@ -3344,7 +3369,7 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n \t  /* Restore the aggregate RHS from its components so the\n \t     prevailing aggregate copy does the right thing.  */\n \t  if (access_has_children_p (racc))\n-\t    generate_subtree_copies (racc->first_child, racc->base, 0, 0, 0,\n+\t    generate_subtree_copies (racc->first_child, rhs, racc->offset, 0, 0,\n \t\t\t\t     gsi, false, false, loc);\n \t  /* Re-load the components of the aggregate copy destination.\n \t     But use the RHS aggregate to load from to expose more"}]}