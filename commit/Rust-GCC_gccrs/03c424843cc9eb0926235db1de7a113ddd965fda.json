{"sha": "03c424843cc9eb0926235db1de7a113ddd965fda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNjNDI0ODQzY2M5ZWIwOTI2MjM1ZGIxZGU3YTExM2RkZDk2NWZkYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-26T11:58:10Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-26T11:58:10Z"}, "message": "(MULTILIB_DIRS): Provide default if not defined.\n\n(multilib_defaults): New static variable.\n(default_arg): New static function.\n(set_multilib_dir): Ignore default arguments.\n(print_multilib_info): Ignore entries which use default arguments.\n\nFrom-SVN: r10155", "tree": {"sha": "9fe4ea2a07229a2acff4d128c78a78d3a62b81d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fe4ea2a07229a2acff4d128c78a78d3a62b81d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03c424843cc9eb0926235db1de7a113ddd965fda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03c424843cc9eb0926235db1de7a113ddd965fda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03c424843cc9eb0926235db1de7a113ddd965fda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03c424843cc9eb0926235db1de7a113ddd965fda/comments", "author": null, "committer": null, "parents": [{"sha": "5eb387b858bbec655fa5faa258af1e0451ca796e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5eb387b858bbec655fa5faa258af1e0451ca796e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5eb387b858bbec655fa5faa258af1e0451ca796e"}], "stats": {"total": 99, "additions": 91, "deletions": 8}, "files": [{"sha": "23a588c8c90b156c3afb772ca844427c49afe9af", "filename": "gcc/gcc.c", "status": "modified", "additions": 91, "deletions": 8, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c424843cc9eb0926235db1de7a113ddd965fda/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c424843cc9eb0926235db1de7a113ddd965fda/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=03c424843cc9eb0926235db1de7a113ddd965fda", "patch": "@@ -295,6 +295,7 @@ static void validate_switches\tPROTO((char *));\n static void validate_all_switches PROTO((void));\n static void give_switch\t\tPROTO((int, int));\n static int used_arg\t\tPROTO((char *, int));\n+static int default_arg\t\tPROTO((char *, int));\n static void set_multilib_dir\tPROTO((void));\n static void print_multilib_info\tPROTO((void));\n static void pfatal_with_name\tPROTO((char *));\n@@ -5028,6 +5029,31 @@ used_arg (p, len)\n   return 0;\n }\n \n+/* Check whether a particular argument is a default argument.  */\n+\n+#ifndef MULTILIB_DEFAULTS\n+#define MULTILIB_DEFAULTS { NULL }\n+#endif\n+\n+static char *multilib_defaults[] = MULTILIB_DEFAULTS;\n+\n+static int\n+default_arg (p, len)\n+     char *p;\n+     int len;\n+{\n+  int count = sizeof multilib_defaults / sizeof multilib_defaults[0];\n+  int i;\n+\n+  for (i = 0; i < count; i++)\n+    if (multilib_defaults[i] != NULL\n+\t&& strncmp (multilib_defaults[i], p, len) == 0\n+\t&& multilib_defaults[i][len] == '\\0')\n+      return 1;\n+\n+  return 0;\n+}\n+\n /* Work out the subdirectory to use based on the\n    options.  The format of multilib_select is a list of elements.\n    Each element is a subdirectory name followed by a list of options\n@@ -5042,7 +5068,8 @@ set_multilib_dir ()\n   char *p = multilib_select;\n   int this_path_len;\n   char *this_path, *this_arg;\n-  int failed;\n+  int not_arg;\n+  int ok;\n \n   while (*p != '\\0')\n     {\n@@ -5064,14 +5091,14 @@ set_multilib_dir ()\n       this_path_len = p - this_path;\n \n       /* Check the arguments.  */\n-      failed = 0;\n+      ok = 1;\n       ++p;\n       while (*p != ';')\n \t{\n \t  if (*p == '\\0')\n \t    abort ();\n \n-\t  if (failed)\n+\t  if (! ok)\n \t    {\n \t      ++p;\n \t      continue;\n@@ -5085,16 +5112,33 @@ set_multilib_dir ()\n \t      ++p;\n \t    }\n \n-\t  if (*this_arg == '!')\n-\t    failed = used_arg (this_arg + 1, p - (this_arg + 1));\n+\t  if (*this_arg != '!')\n+\t    not_arg = 0;\n \t  else\n-\t    failed = ! used_arg (this_arg, p - this_arg);\n+\t    {\n+\t      not_arg = 1;\n+\t      ++this_arg;\n+\t    }\n+\n+\t  /* If this is a default argument, we can just ignore it.\n+\t     This is true even if this_arg begins with '!'.  Beginning\n+\t     with '!' does not mean that this argument is necessarily\n+\t     inappropriate for this library: it merely means that\n+\t     there is a more specific library which uses this\n+\t     argument.  If this argument is a default, we need not\n+\t     consider that more specific library.  */\n+\t  if (! default_arg (this_arg, p - this_arg))\n+\t    {\n+\t      ok = used_arg (this_arg, p - this_arg);\n+\t      if (not_arg)\n+\t\tok = ! ok;\n+\t    }\n \n \t  if (*p == ' ')\n \t    ++p;\n \t}\n \n-      if (! failed)\n+      if (ok)\n \t{\n \t  if (this_path_len != 1\n \t      || this_path[0] != '.')\n@@ -5124,7 +5168,7 @@ print_multilib_info ()\n {\n   char *p = multilib_select;\n   char *last_path = 0, *this_path;\n-  int skip, use_arg;\n+  int skip;\n   int last_path_len = 0;\n \n   while (*p != '\\0')\n@@ -5152,6 +5196,45 @@ print_multilib_info ()\n       last_path = this_path;\n       last_path_len = p - this_path;\n \n+      /* If this directory requires any default arguments, we can skip\n+\t it.  We will already have printed a directory identical to\n+\t this one which does not require that default argument.  */\n+      if (! skip)\n+\t{\n+\t  char *q;\n+\n+\t  q = p + 1;\n+\t  while (*q != ';')\n+\t    {\n+\t      char *arg;\n+\n+\t      if (*q == '\\0')\n+\t\tabort ();\n+\n+\t      if (*q == '!')\n+\t\targ = NULL;\n+\t      else\n+\t\targ = q;\n+\n+\t      while (*q != ' ' && *q != ';')\n+\t\t{\n+\t\t  if (*q == '\\0')\n+\t\t    abort ();\n+\t\t  ++q;\n+\t\t}\n+\n+\t      if (arg != NULL\n+\t\t  && default_arg (arg, q - arg))\n+\t\t{\n+\t\t  skip = 1;\n+\t\t  break;\n+\t\t}\n+\n+\t      if (*q == ' ')\n+\t\t++q;\n+\t    }\n+\t}\n+\n       if (! skip)\n \t{\n \t  char *p1;"}]}