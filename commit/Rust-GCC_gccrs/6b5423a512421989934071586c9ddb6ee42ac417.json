{"sha": "6b5423a512421989934071586c9ddb6ee42ac417", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI1NDIzYTUxMjQyMTk4OTkzNDA3MTU4NmM5ZGRiNmVlNDJhYzQxNw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-05-17T19:28:47Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-05-17T19:28:47Z"}, "message": "jit: gcc diagnostics are jit errors\n\nlibgccjit performs numerous checks at the API boundary, but\nif these succeed, it ignores errors and other diagnostics emitted\nwithin the core of gcc, and treats the compile of a gcc_jit_context\nas having succeeded.\n\nThis patch ensures that if any diagnostics are emitted, they\nare visible from the libgccjit API, and that the the context is\nflagged as having failed.\n\nFor now any kind of diagnostic is treated as a jit error,\nso warnings and notes also count as errors.\n\ngcc/jit/ChangeLog:\n\t* dummy-frontend.c: Include diagnostic.h.\n\t(jit_begin_diagnostic): New function.\n\t(jit_end_diagnostic): New function.\n\t(jit_langhook_init): Register jit_begin_diagnostic\n\tand jit_end_diagnostic with the global_dc.\n\t* jit-playback.c: Include diagnostic.h.\n\t(gcc::jit::playback::context::add_diagnostic): New method.\n\t* jit-playback.h (struct diagnostic_context): Add forward\n\tdeclaration.\n\t(gcc::jit::playback::context::add_diagnostic): New method.\n\ngcc/testsuite/ChangeLog:\n\t* jit.dg/test-error-array-bounds.c: New test case.\n\nFrom-SVN: r236342", "tree": {"sha": "ff6f37c704f22faac7eab9e79f10232646b62933", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff6f37c704f22faac7eab9e79f10232646b62933"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b5423a512421989934071586c9ddb6ee42ac417", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b5423a512421989934071586c9ddb6ee42ac417", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b5423a512421989934071586c9ddb6ee42ac417", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b5423a512421989934071586c9ddb6ee42ac417/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f51703a8f80c9935f27148bb53ec7591716fd519", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f51703a8f80c9935f27148bb53ec7591716fd519", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f51703a8f80c9935f27148bb53ec7591716fd519"}], "stats": {"total": 168, "additions": 168, "deletions": 0}, "files": [{"sha": "f9320eccee0a195e23961eb2e62bd930e57ac3b3", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5423a512421989934071586c9ddb6ee42ac417/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5423a512421989934071586c9ddb6ee42ac417/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=6b5423a512421989934071586c9ddb6ee42ac417", "patch": "@@ -1,3 +1,16 @@\n+2016-05-17  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* dummy-frontend.c: Include diagnostic.h.\n+\t(jit_begin_diagnostic): New function.\n+\t(jit_end_diagnostic): New function.\n+\t(jit_langhook_init): Register jit_begin_diagnostic\n+\tand jit_end_diagnostic with the global_dc.\n+\t* jit-playback.c: Include diagnostic.h.\n+\t(gcc::jit::playback::context::add_diagnostic): New method.\n+\t* jit-playback.h (struct diagnostic_context): Add forward\n+\tdeclaration.\n+\t(gcc::jit::playback::context::add_diagnostic): New method.\n+\n 2016-05-17  David Malcolm  <dmalcolm@redhat.com>\n \n \t* docs/topics/expressions.rst (Function calls): Document"}, {"sha": "26311536186fda5276157628341ac5c2cf75d0e8", "filename": "gcc/jit/dummy-frontend.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5423a512421989934071586c9ddb6ee42ac417/gcc%2Fjit%2Fdummy-frontend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5423a512421989934071586c9ddb6ee42ac417/gcc%2Fjit%2Fdummy-frontend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdummy-frontend.c?ref=6b5423a512421989934071586c9ddb6ee42ac417", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"debug.h\"\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n+#include \"diagnostic.h\"\n \n \n #include <mpfr.h>\n@@ -90,6 +91,35 @@ struct ggc_root_tab jit_root_tab[] =\n     LAST_GGC_ROOT_TAB\n   };\n \n+/* JIT-specific implementation of diagnostic callbacks.  */\n+\n+/* Implementation of \"begin_diagnostic\".  */\n+\n+static void\n+jit_begin_diagnostic (diagnostic_context */*context*/,\n+\t\t      diagnostic_info */*diagnostic*/)\n+{\n+  gcc_assert (gcc::jit::active_playback_ctxt);\n+  JIT_LOG_SCOPE (gcc::jit::active_playback_ctxt->get_logger ());\n+\n+  /* No-op (apart from logging); the real error-handling is done in the\n+     \"end_diagnostic\" hook.  */\n+}\n+\n+/* Implementation of \"end_diagnostic\".  */\n+\n+static void\n+jit_end_diagnostic (diagnostic_context *context,\n+\t\t    diagnostic_info *diagnostic)\n+{\n+  gcc_assert (gcc::jit::active_playback_ctxt);\n+  JIT_LOG_SCOPE (gcc::jit::active_playback_ctxt->get_logger ());\n+\n+  /* Delegate to the playback context (and thence to the\n+     recording context).  */\n+  gcc::jit::active_playback_ctxt->add_diagnostic (context, diagnostic);\n+}\n+\n /* Language hooks.  */\n \n static bool\n@@ -105,6 +135,10 @@ jit_langhook_init (void)\n       registered_root_tab = true;\n     }\n \n+  gcc_assert (global_dc);\n+  global_dc->begin_diagnostic = jit_begin_diagnostic;\n+  global_dc->end_diagnostic = jit_end_diagnostic;\n+\n   build_common_tree_nodes (false);\n \n   /* I don't know why this has to be done explicitly.  */"}, {"sha": "156448d13d546028c6357973c503da660486ac7b", "filename": "gcc/jit/jit-playback.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5423a512421989934071586c9ddb6ee42ac417/gcc%2Fjit%2Fjit-playback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5423a512421989934071586c9ddb6ee42ac417/gcc%2Fjit%2Fjit-playback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.c?ref=6b5423a512421989934071586c9ddb6ee42ac417", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"context.h\"\n #include \"fold-const.h\"\n #include \"gcc.h\"\n+#include \"diagnostic.h\"\n \n #include <pthread.h>\n \n@@ -2833,6 +2834,43 @@ add_error_va (location *loc, const char *fmt, va_list ap)\n \t\t\t\t  fmt, ap);\n }\n \n+/* Report a diagnostic up to the jit context as an error,\n+   so that the compilation is treated as a failure.\n+   For now, any kind of diagnostic is treated as an error by the jit\n+   API.  */\n+\n+void\n+playback::context::\n+add_diagnostic (struct diagnostic_context *diag_context,\n+\t\tstruct diagnostic_info *diagnostic)\n+{\n+  /* At this point the text has been formatted into the pretty-printer's\n+     output buffer.  */\n+  pretty_printer *pp = diag_context->printer;\n+  const char *text = pp_formatted_text (pp);\n+\n+  /* Get location information (if any) from the diagnostic.\n+     The recording::context::add_error[_va] methods require a\n+     recording::location.  We can't lookup the playback::location\n+     from the file/line/column since any playback location instances\n+     may have been garbage-collected away by now, so instead we create\n+     another recording::location directly.  */\n+  location_t gcc_loc = diagnostic_location (diagnostic);\n+  recording::location *rec_loc = NULL;\n+  if (gcc_loc)\n+    {\n+      expanded_location exploc = expand_location (gcc_loc);\n+      if (exploc.file)\n+\trec_loc = m_recording_ctxt->new_location (exploc.file,\n+\t\t\t\t\t\t  exploc.line,\n+\t\t\t\t\t\t  exploc.column,\n+\t\t\t\t\t\t  false);\n+    }\n+\n+  m_recording_ctxt->add_error (rec_loc, \"%s\", text);\n+  pp_clear_output_area (pp);\n+}\n+\n /* Dealing with the linemap API.  */\n \n /* Construct a playback::location for a recording::location, if it"}, {"sha": "8f7a43db1b02516ae4b0cd22185797bfa2a4c94a", "filename": "gcc/jit/jit-playback.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5423a512421989934071586c9ddb6ee42ac417/gcc%2Fjit%2Fjit-playback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5423a512421989934071586c9ddb6ee42ac417/gcc%2Fjit%2Fjit-playback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.h?ref=6b5423a512421989934071586c9ddb6ee42ac417", "patch": "@@ -27,6 +27,9 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"jit-recording.h\"\n \n+struct diagnostic_context;\n+struct diagnostic_info;\n+\n namespace gcc {\n \n namespace jit {\n@@ -202,6 +205,10 @@ class context : public log_user\n   const char *\n   get_first_error () const;\n \n+  void\n+  add_diagnostic (struct diagnostic_context *context,\n+\t\t  struct diagnostic_info *diagnostic);\n+\n   void\n   set_tree_location (tree t, location *loc);\n "}, {"sha": "cb5940e2c904dad545be30e0c2b311e998490c6c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5423a512421989934071586c9ddb6ee42ac417/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5423a512421989934071586c9ddb6ee42ac417/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6b5423a512421989934071586c9ddb6ee42ac417", "patch": "@@ -1,3 +1,7 @@\n+2016-05-17  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-error-array-bounds.c: New test case.\n+\n 2016-05-17  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* gcc.dg/tree-ssa/and-1.c: New testcase."}, {"sha": "732ec87bfd9f95b37e82838a514f6bfb2a61ecaf", "filename": "gcc/testsuite/jit.dg/test-error-array-bounds.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5423a512421989934071586c9ddb6ee42ac417/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-array-bounds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5423a512421989934071586c9ddb6ee42ac417/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-array-bounds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-array-bounds.c?ref=6b5423a512421989934071586c9ddb6ee42ac417", "patch": "@@ -0,0 +1,72 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+       char\n+       test_array_bounds (void)\n+       {\n+\t  char buffer[10];\n+\t  return buffer[10];\n+       }\n+     with -Warray-bounds and -ftree-vrp and verify that the\n+     out-of-bounds access is detected and reported as a jit error.  */\n+  gcc_jit_context_add_command_line_option (ctxt, \"-Warray-bounds\");\n+  gcc_jit_context_add_command_line_option (ctxt, \"-ftree-vrp\");\n+\n+  /* Ensure that the error message doesn't contain colorization codes,\n+     even if run at a TTY.  */\n+  gcc_jit_context_add_command_line_option (ctxt, \"-fdiagnostics-color=never\");\n+\n+  gcc_jit_type *char_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_CHAR);\n+  gcc_jit_type *array_type =\n+    gcc_jit_context_new_array_type (ctxt, NULL,\n+\t\t\t\t    char_type, 10);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+  /* Build the test_fn.  */\n+  gcc_jit_function *test_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  char_type,\n+\t\t\t\t  \"test_array_bounds\",\n+\t\t\t\t  0, NULL,\n+\t\t\t\t  0);\n+  gcc_jit_lvalue *buffer =\n+    gcc_jit_function_new_local (test_fn, NULL, array_type, \"buffer\");\n+\n+  /* tree-vrp.c:check_all_array_refs only checks array lookups that\n+     have source locations.  */\n+  gcc_jit_location *dummy_loc =\n+    gcc_jit_context_new_location (ctxt, \"dummy.c\", 10, 4);\n+\n+  gcc_jit_block *block = gcc_jit_function_new_block (test_fn, NULL);\n+  gcc_jit_rvalue *index =\n+    gcc_jit_context_new_rvalue_from_int (ctxt, int_type, 10);\n+  gcc_jit_lvalue *read_of_the_buffer =\n+    gcc_jit_context_new_array_access (ctxt, dummy_loc,\n+\t\t\t\t      gcc_jit_lvalue_as_rvalue (buffer),\n+\t\t\t\t      index);\n+  gcc_jit_block_end_with_return (\n+    block, dummy_loc,\n+    gcc_jit_lvalue_as_rvalue (read_of_the_buffer));\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  /* Verify that the diagnostic led to the context failing... */\n+  CHECK_VALUE (result, NULL);\n+\n+  /* ...and that the message was captured by the API.  */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"array subscript is above array bounds [-Warray-bounds]\");\n+}"}]}