{"sha": "b70f0f48c716c8571723ee667f9712fd7e097490", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjcwZjBmNDhjNzE2Yzg1NzE3MjNlZTY2N2Y5NzEyZmQ3ZTA5NzQ5MA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2006-07-20T16:02:57Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2006-07-20T16:02:57Z"}, "message": "re PR c++/28407 (Issue with anonymous namespace)\n\n        PR c++/28407\n        * cp/decl.c (grokvardecl): Set DECL_THIS_STATIC on file-scope\n        const variables with implicit internal linkage.\n        * cp/tree.c (decl_linkage): Only return lk_external if it's set.\n\n        PR c++/28409\n        * cp/decl2.c (constrain_visibility): Ignore the anonymous namespace \n        for extern C decls.\n        (VISIBILITY_STATIC): Rename to VISIBILITY_ANON.\n\n        Don't override explicit visibility.\n        * cp/decl2.c (constrain_visibility): Remove specified and reason\n        parameters.  Don't touch decls that already have explicit visibility.\n        (determine_visibility): Do copy DECL_VISIBILITY_SPECIFIED from\n        template.\n        (determine_visibility_from_class): Reverse sense of\n        DECL_VISIBILITY_SPECIFIED test for target-specific visibility rules.\n        (constrain_class_visibility): Only complain about member visibility\n        if the member type is another class.  Don't change visibility of the\n        current class.\n        * tree.c (remove_attribute): New fn.\n        * tree.h: Declare it.\n\nFrom-SVN: r115622", "tree": {"sha": "2668380ba111a9cfdf1beb690c74127fc5593651", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2668380ba111a9cfdf1beb690c74127fc5593651"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b70f0f48c716c8571723ee667f9712fd7e097490", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b70f0f48c716c8571723ee667f9712fd7e097490", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b70f0f48c716c8571723ee667f9712fd7e097490", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b70f0f48c716c8571723ee667f9712fd7e097490/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e67b81d14078e85aff856cd25679a4f349e9c3b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e67b81d14078e85aff856cd25679a4f349e9c3b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e67b81d14078e85aff856cd25679a4f349e9c3b4"}], "stats": {"total": 307, "additions": 246, "deletions": 61}, "files": [{"sha": "7163d753157c7dce8aa889332ec5dd5e4b20652f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b70f0f48c716c8571723ee667f9712fd7e097490", "patch": "@@ -1,3 +1,7 @@\n+2006-07-20  Jason Merrill  <jason@redhat.com>\n+\n+\t* tree.c (remove_attribute): New fn.\n+\n 2006-07-20  Paul Brook  <paul@codesourcery.com>\n \n \tPR 27363"}, {"sha": "309a060c3a2d0522c7cfaaa291805513297dc4ba", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b70f0f48c716c8571723ee667f9712fd7e097490", "patch": "@@ -1,3 +1,25 @@\n+2006-07-20  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/28407\n+\t* decl.c (grokvardecl): Set DECL_THIS_STATIC on file-scope\n+\tconst variables with implicit internal linkage.\n+\t* tree.c (decl_linkage): Only return lk_external if it's set.\n+\n+\tPR c++/28409\n+\t* decl2.c (constrain_visibility): Ignore the anonymous namespace \n+\tfor extern \"C\" decls.\n+\t(VISIBILITY_STATIC): Rename to VISIBILITY_ANON.\n+\n+\t* decl2.c (constrain_visibility): Remove specified and reason \n+\tparameters.  Don't touch decls that already have explicit visibility.\n+\t(determine_visibility): Do copy DECL_VISIBILITY_SPECIFIED from \n+\ttemplate.\n+\t(determine_visibility_from_class): Reverse sense of \n+\tDECL_VISIBILITY_SPECIFIED test for target-specific visibility rules.\n+\t(constrain_class_visibility): Only complain about member visibility\n+\tif the member type is another class.  Don't change visibility of the\n+\tcurrent class.\n+\n 2006-07-19  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/28338"}, {"sha": "78838b06b2be767375e41a0b19eab0efae73a639", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b70f0f48c716c8571723ee667f9712fd7e097490", "patch": "@@ -5246,6 +5246,14 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t{\n \t  layout_var_decl (decl);\n \t  maybe_commonize_var (decl);\n+\t  if (DECL_NAMESPACE_SCOPE_P (decl) && !TREE_PUBLIC (decl)\n+\t      && !DECL_THIS_STATIC (decl) && !DECL_ARTIFICIAL (decl))\n+\t    {\n+\t      /* This is a const variable with implicit 'static'.  Set\n+\t\t DECL_THIS_STATIC so we can tell it from variables that are\n+\t\t !TREE_PUBLIC because of the anonymous namespace.  */\n+\t      DECL_THIS_STATIC (decl) = 1;\n+\t    }\n \t}\n \n       make_rtl_for_nonlocal_decl (decl, init, asmspec);"}, {"sha": "351de049f4c1075a5a5f4bb3f4909ad6ec65584c", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 75, "deletions": 51, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=b70f0f48c716c8571723ee667f9712fd7e097490", "patch": "@@ -1536,7 +1536,7 @@ maybe_emit_vtables (tree ctype)\n /* A special return value from type_visibility meaning internal\n    linkage.  */\n \n-enum { VISIBILITY_STATIC = VISIBILITY_INTERNAL+1 };\n+enum { VISIBILITY_ANON = VISIBILITY_INTERNAL+1 };\n \n /* walk_tree helper function for type_visibility.  */\n \n@@ -1552,7 +1552,7 @@ min_vis_r (tree *tp, int *walk_subtrees, void *data)\n     {\n       if (!TREE_PUBLIC (TYPE_MAIN_DECL (*tp)))\n \t{\n-\t  *vis_p = VISIBILITY_STATIC;\n+\t  *vis_p = VISIBILITY_ANON;\n \t  return *tp;\n \t}\n       else if (CLASSTYPE_VISIBILITY (*tp) > *vis_p)\n@@ -1572,29 +1572,28 @@ type_visibility (tree type)\n   return vis;\n }\n \n-/* Limit the visibility of DECL to VISIBILITY.  SPECIFIED is true if the\n-   constraint comes from an attribute or pragma; REASON is the source of\n-   the constraint.  */\n+/* Limit the visibility of DECL to VISIBILITY, if not explicitly\n+   specified (or if VISIBILITY is static).  */\n \n static bool\n-constrain_visibility (tree decl, int visibility, bool specified,\n-\t\t      const char *reason)\n+constrain_visibility (tree decl, int visibility)\n {\n-  if (visibility == VISIBILITY_STATIC)\n+  if (visibility == VISIBILITY_ANON)\n     {\n-      TREE_PUBLIC (decl) = 0;\n-      DECL_INTERFACE_KNOWN (decl) = 1;\n-      if (DECL_LANG_SPECIFIC (decl))\n-\tDECL_NOT_REALLY_EXTERN (decl) = 1;\n+      /* extern \"C\" declarations aren't affected by the anonymous\n+\t namespace.  */\n+      if (!DECL_EXTERN_C_P (decl))\n+\t{\n+\t  TREE_PUBLIC (decl) = 0;\n+\t  DECL_INTERFACE_KNOWN (decl) = 1;\n+\t  if (DECL_LANG_SPECIFIC (decl))\n+\t    DECL_NOT_REALLY_EXTERN (decl) = 1;\n+\t}\n     }\n-  else if (visibility > DECL_VISIBILITY (decl))\n+  else if (visibility > DECL_VISIBILITY (decl)\n+\t   && !DECL_VISIBILITY_SPECIFIED (decl))\n     {\n-      if (lookup_attribute (\"visibility\", DECL_ATTRIBUTES (decl)))\n-\twarning (OPT_Wattributes, \"%q+D: visibility attribute requests \"\n-\t\t \"greater visibility than its %s allows\", decl, reason);\n       DECL_VISIBILITY (decl) = visibility;\n-      if (!DECL_VISIBILITY_SPECIFIED (decl))\n-\tDECL_VISIBILITY_SPECIFIED (decl) = specified;\n       return true;\n     }\n   return false;\n@@ -1627,13 +1626,13 @@ constrain_visibility_for_template (tree decl, tree targs)\n \t      || TREE_CODE (arg) == FUNCTION_DECL)\n \t    {\n \t      if (! TREE_PUBLIC (arg))\n-\t\tvis = VISIBILITY_STATIC;\n+\t\tvis = VISIBILITY_ANON;\n \t      else\n \t\tvis = DECL_VISIBILITY (arg);\n \t    }\n \t}\n       if (vis)\n-\tconstrain_visibility (decl, vis, false, \"template parameter\");\n+\tconstrain_visibility (decl, vis);\n     }\n }\n \n@@ -1735,8 +1734,7 @@ determine_visibility (tree decl)\n \t{\n \t  /* tinfo visibility is based on the type it's for.  */\n \t  constrain_visibility\n-\t    (decl, type_visibility (TREE_TYPE (DECL_NAME (decl))),\n-\t     false, \"type\");\n+\t    (decl, type_visibility (TREE_TYPE (DECL_NAME (decl))));\n \t}\n       else if (use_template)\n \t/* Template instantiations and specializations get visibility based\n@@ -1752,43 +1750,42 @@ determine_visibility (tree decl)\n \n   if (use_template)\n     {\n+      /* If the specialization doesn't specify visibility, use the\n+\t visibility from the template.  */\n       tree tinfo = (TREE_CODE (decl) == TYPE_DECL\n \t\t    ? TYPE_TEMPLATE_INFO (TREE_TYPE (decl))\n \t\t    : DECL_TEMPLATE_INFO (decl));\n       tree args = TI_ARGS (tinfo);\n       int depth = TMPL_ARGS_DEPTH (args);\n+      tree pattern = DECL_TEMPLATE_RESULT (TI_TEMPLATE (tinfo));\n \n-      /* If the template has explicit visibility and the specialization\n-\t doesn't, use the visibility from the template.  */\n       if (!DECL_VISIBILITY_SPECIFIED (decl))\n \t{\n-\t  tree pattern = DECL_TEMPLATE_RESULT (TI_TEMPLATE (tinfo));\n \t  DECL_VISIBILITY (decl) = DECL_VISIBILITY (pattern);\n+\t  DECL_VISIBILITY_SPECIFIED (decl)\n+\t    = DECL_VISIBILITY_SPECIFIED (pattern);\n \t}\n \n       /* FIXME should TMPL_ARGS_DEPTH really return 1 for null input? */\n       if (args && depth > template_class_depth (class_type))\n-\t/* Don't let it have more visibility than its template type\n-\t   arguments.  */\n+\t/* Limit visibility based on its template arguments.  */\n \tconstrain_visibility_for_template (decl, args);\n     }\n-  \n+\n   if (class_type)\n     determine_visibility_from_class (decl, class_type);\n \n   /* Don't let it have more visibility than its type.  */\n   if (TREE_CODE (decl) != TYPE_DECL)\n-    if (constrain_visibility (decl, type_visibility (TREE_TYPE (decl)),\n-\t\t\t      false, \"type\"))\n+    if (constrain_visibility (decl, type_visibility (TREE_TYPE (decl))))\n       warning (OPT_Wattributes, \"\\\n-%q+D declared with greater visibility than its type\",\n+lowering visibility of %q+D to match its type\",\n \t       decl);\n \n   if (decl_anon_ns_mem_p (decl))\n     /* Names in an anonymous namespace get internal linkage.\n        This might change once we implement export.  */\n-    constrain_visibility (decl, VISIBILITY_STATIC,\n-\t\t\t  false, \"namespace\");\n+    constrain_visibility (decl, VISIBILITY_ANON);\n }\n \n /* By default, static data members and function members receive\n@@ -1806,11 +1803,13 @@ determine_visibility_from_class (tree decl, tree class_type)\n       && TREE_CODE (decl) == FUNCTION_DECL\n       && DECL_DECLARED_INLINE_P (decl))\n     DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;\n-\n-  /* The decl can't have more visibility than its class.  */\n-  constrain_visibility (decl, CLASSTYPE_VISIBILITY (class_type),\n-\t\t\tCLASSTYPE_VISIBILITY_SPECIFIED (class_type),\n-\t\t\t\"class\");\n+  else if (!DECL_VISIBILITY_SPECIFIED (decl))\n+    {\n+      /* Default to the class visibility.  */\n+      DECL_VISIBILITY (decl) = CLASSTYPE_VISIBILITY (class_type);\n+      DECL_VISIBILITY_SPECIFIED (decl)\n+\t= CLASSTYPE_VISIBILITY_SPECIFIED (class_type);\n+    }\n \n   /* Give the target a chance to override the visibility associated\n      with DECL.  */\n@@ -1823,8 +1822,8 @@ determine_visibility_from_class (tree decl, tree class_type)\n \t      && !DECL_CONSTRUCTION_VTABLE_P (decl)))\n       && TREE_PUBLIC (decl)\n       && !DECL_REALLY_EXTERN (decl)\n-      && DECL_VISIBILITY_SPECIFIED (decl)\n-      && (!class_type || !CLASSTYPE_VISIBILITY_SPECIFIED (class_type)))\n+      && !DECL_VISIBILITY_SPECIFIED (decl)\n+      && !CLASSTYPE_VISIBILITY_SPECIFIED (class_type))\n     targetm.cxx.determine_class_data_visibility (decl);\n }\n \n@@ -1834,25 +1833,50 @@ determine_visibility_from_class (tree decl, tree class_type)\n void\n constrain_class_visibility (tree type)\n {\n-  tree decl = TYPE_MAIN_DECL (type);\n-  tree binfo = TYPE_BINFO (type);\n+  tree binfo;\n   tree t;\n   int i;\n \n+  int vis = type_visibility (type);\n+\n+  if (vis == VISIBILITY_ANON)\n+    return;\n+\n+  /* Don't warn about visibility if the class has explicit visibility.  */\n+  if (CLASSTYPE_VISIBILITY_SPECIFIED (type))\n+    vis = VISIBILITY_INTERNAL;\n+\n   for (t = TYPE_FIELDS (type); t; t = TREE_CHAIN (t))\n-    if (TREE_CODE (t) == FIELD_DECL)\n-      if (constrain_visibility (decl, type_visibility (TREE_TYPE (t)),\n-\t\t\t\tfalse, \"field type\"))\n-\twarning (OPT_Wattributes, \"\\\n+    if (TREE_CODE (t) == FIELD_DECL && TREE_TYPE (t) != error_mark_node)\n+      {\n+\tint subvis = type_visibility (TREE_TYPE (t));\n+\n+\tif (subvis == VISIBILITY_ANON)\n+\t  warning (0, \"\\\n+%qT has a field %qD whose type uses the anonymous namespace\",\n+\t\t   type, t);\n+\telse if (vis < VISIBILITY_HIDDEN\n+\t\t && subvis >= VISIBILITY_HIDDEN)\n+\t  warning (OPT_Wattributes, \"\\\n %qT declared with greater visibility than the type of its field %qD\",\n-\t\t type, t);\n+\t\t   type, t);\n+      }\n \n+  binfo = TYPE_BINFO (type);\n   for (i = 0; BINFO_BASE_ITERATE (binfo, i, t); ++i)\n-    if (constrain_visibility (decl, type_visibility (TREE_TYPE (t)),\n-\t\t\t      false, \"base type\"))\n-      warning (OPT_Wattributes, \"\\\n+    {\n+      int subvis = type_visibility (TREE_TYPE (t));\n+\n+      if (subvis == VISIBILITY_ANON)\n+\twarning (0, \"\\\n+%qT has a base %qT whose type uses the anonymous namespace\",\n+\t\t type, TREE_TYPE (t));\n+      else if (vis < VISIBILITY_HIDDEN\n+\t       && subvis >= VISIBILITY_HIDDEN)\n+\twarning (OPT_Wattributes, \"\\\n %qT declared with greater visibility than its base %qT\",\n-\t       type, TREE_TYPE (t));\n+\t\t type, TREE_TYPE (t));\n+    }\n }\n \n /* DECL is a FUNCTION_DECL or VAR_DECL.  If the object file linkage"}, {"sha": "f65d0ce25a6755923f6fd188fc4ace8c87d97818", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b70f0f48c716c8571723ee667f9712fd7e097490", "patch": "@@ -6589,7 +6589,12 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \n \t/* Possibly limit visibility based on template args.  */\n \tDECL_VISIBILITY (r) = VISIBILITY_DEFAULT;\n-\tDECL_VISIBILITY_SPECIFIED (r) = 0;\n+\tif (DECL_VISIBILITY_SPECIFIED (t))\n+\t  {\n+\t    DECL_VISIBILITY_SPECIFIED (r) = 0;\n+\t    DECL_ATTRIBUTES (r)\n+\t      = remove_attribute (\"visibility\", DECL_ATTRIBUTES (r));\n+\t  }\n \tdetermine_visibility (r);\n       }\n       break;\n@@ -6791,7 +6796,12 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t  {\n \t    /* Possibly limit visibility based on template args.  */\n \t    DECL_VISIBILITY (r) = VISIBILITY_DEFAULT;\n-\t    DECL_VISIBILITY_SPECIFIED (r) = 0;\n+\t    if (DECL_VISIBILITY_SPECIFIED (t))\n+\t      {\n+\t\tDECL_VISIBILITY_SPECIFIED (r) = 0;\n+\t\tDECL_ATTRIBUTES (r)\n+\t\t  = remove_attribute (\"visibility\", DECL_ATTRIBUTES (r));\n+\t      }\n \t    determine_visibility (r);\n \t  }\n "}, {"sha": "0d42502da76410bea6309f8a63f358c4328e57a0", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=b70f0f48c716c8571723ee667f9712fd7e097490", "patch": "@@ -2195,6 +2195,9 @@ decl_linkage (tree decl)\n   if (TREE_PUBLIC (decl))\n     return lk_external;\n \n+  if (TREE_CODE (decl) == NAMESPACE_DECL)\n+    return lk_external;\n+\n   /* Linkage of a CONST_DECL depends on the linkage of the enumeration\n      type.  */\n   if (TREE_CODE (decl) == CONST_DECL)\n@@ -2214,6 +2217,14 @@ decl_linkage (tree decl)\n   if (decl_function_context (decl))\n     return lk_none;\n \n+  /* Members of the anonymous namespace also have TREE_PUBLIC unset, but\n+     are considered to have external linkage for language purposes.  DECLs\n+     really meant to have internal linkage have DECL_THIS_STATIC set.  */\n+  if (TREE_CODE (decl) == TYPE_DECL\n+      || ((TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == FUNCTION_DECL)\n+\t  && !DECL_THIS_STATIC (decl)))\n+    return lk_external;\n+\n   /* Everything else has internal linkage.  */\n   return lk_internal;\n }"}, {"sha": "e6e5e1718c6e12f5f099449c10b78bbeb2de3466", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=b70f0f48c716c8571723ee667f9712fd7e097490", "patch": "@@ -2413,16 +2413,16 @@ In C++, the visibility attribute applies to types as well as functions\n and objects, because in C++ types have linkage.  A class must not have\n greater visibility than its non-static data member types and bases,\n and class members default to the visibility of their class.  Also, a\n-declaration must not have greater visibility than its type.\n+declaration without explicit visibility is limited to the visibility\n+of its type.\n \n In C++, you can mark member functions and static member variables of a\n class with the visibility attribute.  This is useful if if you know a\n particular method or static member variable should only be used from\n one shared object; then you can mark it hidden while the rest of the\n class has default visibility.  Care must be taken to avoid breaking\n-the One Definition Rule; for example, it is not useful to mark a\n-method which is defined inside a class definition as hidden without\n-marking the whole class as hidden.\n+the One Definition Rule; for example, it is usually not useful to mark\n+an inline method as hidden without marking the whole class as hidden.\n \n A C++ namespace declaration can also have the visibility attribute.\n This attribute applies only to the particular namespace body, not to\n@@ -2435,6 +2435,9 @@ restriction is implicitly propagated to the template instantiation.\n Otherwise, template instantiations and specializations default to the\n visibility of their template.\n \n+If both the template and enclosing class have explicit visibility, the\n+visibility from the template is used.\n+\n @item warn_unused_result\n @cindex @code{warn_unused_result} attribute\n The @code{warn_unused_result} attribute causes a warning to be emitted\n@@ -3668,6 +3671,13 @@ applied to class, struct, union and enum types.  Unlike other type\n attributes, the attribute must appear between the initial keyword and\n the name of the type; it cannot appear after the body of the type.\n \n+Note that the type visibility is applied to vague linkage entities\n+associated with the class (vtable, typeinfo node, etc.).  In\n+particular, if a class is thrown as an exception in one shared object\n+and caught in another, the class must have default visibility.\n+Otherwise the two shared objects will be unable to use the same\n+typeinfo node and exception handling will break.\n+\n @subsection ARM Type Attributes\n \n On those ARM targets that support @code{dllimport} (such as Symbian"}, {"sha": "7892a46e2aa5818ae0ab6e86bc419c240277c74c", "filename": "gcc/testsuite/g++.dg/ext/visibility/template6.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ftemplate6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ftemplate6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ftemplate6.C?ref=b70f0f48c716c8571723ee667f9712fd7e097490", "patch": "@@ -0,0 +1,17 @@\n+// Test for explicit visibility taking precedence\n+\n+// { dg-require-visibility \"\" }\n+// { dg-final { scan-not-hidden \"_ZN1AIiE1fEv\" } }\n+\n+template <class T> struct A\n+{\n+  // This attribute takes precedence over...\n+  __attribute ((visibility (\"default\"))) void f ();\n+};\n+\n+template <class T>\n+void A<T>::f ()\n+{ }\n+\n+// ...this attribute.\n+template struct __attribute ((visibility (\"hidden\"))) A<int>;"}, {"sha": "54354b52311cea5123887fd47c4423437c10e791", "filename": "gcc/testsuite/g++.dg/ext/visibility/warn2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fwarn2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fwarn2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fwarn2.C?ref=b70f0f48c716c8571723ee667f9712fd7e097490", "patch": "@@ -14,6 +14,6 @@ struct B\n   N::A a;\n };\n \n-B f () { }\t\t\t// { dg-warning \"visibility\" }\n+N::A f () { }\t\t\t// { dg-warning \"visibility\" }\n \n struct C: public N::A { };\t// { dg-warning \"visibility\" }"}, {"sha": "de64217fd3b173b39bac15b18910028058494649", "filename": "gcc/testsuite/g++.dg/ext/visibility/warn3.C", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fwarn3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fwarn3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fwarn3.C?ref=b70f0f48c716c8571723ee667f9712fd7e097490", "patch": "@@ -1,11 +1,32 @@\n-// Warn when a class member is specified to have greater visibility than\n-// its class.\n+// Tests for various visibility mismatch situations.\n \n // { dg-require-visibility \"\" }\n \n+// { dg-final { scan-not-hidden \"_ZN1A1fEv\" } }\n+\n struct __attribute ((visibility (\"hidden\"))) A\n {\n-  __attribute ((visibility (\"default\"))) void f (); // { dg-warning \"visibility\" }\n+  // This is OK, A::f gets default visibility.\n+  __attribute ((visibility (\"default\"))) void f ();\n };\n \n void A::f() { }\n+\n+// This gets a warning; it should have explicit visibility of some sort.\n+A* afactory1() { return new A; }\t// { dg-warning \"visibility\" }\n+\n+// This is OK.\n+__attribute ((visibility (\"default\"))) A*\n+afactory2 () { return new A; }\n+\n+// This gets a warning.\n+struct B\n+{\t\t\t\t// { dg-warning \"visibility\" }\n+  A a;\n+};\n+\n+// This one has explicit visibility, so it doesn't get a warning.\n+struct __attribute ((visibility (\"default\"))) C\n+{\n+  A a;\n+};"}, {"sha": "c3d36c20f533b77b6f3119ae2d1bcc862e82b914", "filename": "gcc/testsuite/g++.dg/lookup/anon5.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fanon5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fanon5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fanon5.C?ref=b70f0f48c716c8571723ee667f9712fd7e097490", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/28409\n+// shouldIbevisible should be emitted because it's an extern \"C\" decl with\n+// external linkage, even though it's in the anonymous namespace.\n+\n+namespace\n+{\n+  extern \"C\" int shouldIbevisible()\n+  {\n+    return 0;\n+  }\n+}\n+\n+namespace t\n+{\n+  extern \"C\" int shouldIbevisible(void);\n+}\n+\n+int main(void)\n+{\n+  return t::shouldIbevisible();\n+}"}, {"sha": "59bfee1e814a82f3ad4294e23237eef20774ba8a", "filename": "gcc/testsuite/g++.dg/template/anon4.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fanon4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fanon4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fanon4.C?ref=b70f0f48c716c8571723ee667f9712fd7e097490", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/28407\n+// A declaration in the anonymous namespace still has external linkage.\n+\n+template <int *P> class A { };\n+namespace\n+{\n+  int i;\n+}\n+\n+A<&i> a;"}, {"sha": "dc78ad775af92523ec7a43795a8c4057cd2bc167", "filename": "gcc/tree.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b70f0f48c716c8571723ee667f9712fd7e097490", "patch": "@@ -3499,6 +3499,28 @@ lookup_attribute (const char *attr_name, tree list)\n   return NULL_TREE;\n }\n \n+/* Remove any instances of attribute ATTR_NAME in LIST and return the\n+   modified list.  */\n+\n+tree\n+remove_attribute (const char *attr_name, tree list)\n+{\n+  tree *p;\n+  size_t attr_len = strlen (attr_name);\n+\n+  for (p = &list; *p; )\n+    {\n+      tree l = *p;\n+      gcc_assert (TREE_CODE (TREE_PURPOSE (l)) == IDENTIFIER_NODE);\n+      if (is_attribute_with_length_p (attr_name, attr_len, TREE_PURPOSE (l)))\n+\t*p = TREE_CHAIN (l);\n+      else\n+\tp = &TREE_CHAIN (l);\n+    }\n+\n+  return list;\n+}\n+\n /* Return an attribute list that is the union of a1 and a2.  */\n \n tree"}, {"sha": "5e47dacc56dfddd71f51f1746acf8aeeadd309c3", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70f0f48c716c8571723ee667f9712fd7e097490/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b70f0f48c716c8571723ee667f9712fd7e097490", "patch": "@@ -3696,6 +3696,11 @@ extern int is_attribute_p (const char *, tree);\n \n extern tree lookup_attribute (const char *, tree);\n \n+/* Remove any instances of attribute ATTR_NAME in LIST and return the\n+   modified list.  */\n+\n+extern tree remove_attribute (const char *, tree);\n+\n /* Given two attributes lists, return a list of their union.  */\n \n extern tree merge_attributes (tree, tree);"}]}