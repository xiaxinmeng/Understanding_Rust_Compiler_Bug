{"sha": "e165f3f04d3f5bfca6c47010a745f0404109db38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE2NWYzZjA0ZDNmNWJmY2E2YzQ3MDEwYTc0NWYwNDA0MTA5ZGIzOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-28T11:52:03Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-28T11:52:03Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r610", "tree": {"sha": "b4f8a9c0adecc560b2a3327d0009e1ceb3cd4519", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4f8a9c0adecc560b2a3327d0009e1ceb3cd4519"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e165f3f04d3f5bfca6c47010a745f0404109db38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e165f3f04d3f5bfca6c47010a745f0404109db38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e165f3f04d3f5bfca6c47010a745f0404109db38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e165f3f04d3f5bfca6c47010a745f0404109db38/comments", "author": null, "committer": null, "parents": [{"sha": "aae7526179ceb830c39b8259eccf3182d8055dc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aae7526179ceb830c39b8259eccf3182d8055dc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aae7526179ceb830c39b8259eccf3182d8055dc0"}], "stats": {"total": 58, "additions": 55, "deletions": 3}, "files": [{"sha": "cac077382a70c9c88ca0aa2ac4998fc8d07f36fa", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 55, "deletions": 3, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e165f3f04d3f5bfca6c47010a745f0404109db38/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e165f3f04d3f5bfca6c47010a745f0404109db38/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e165f3f04d3f5bfca6c47010a745f0404109db38", "patch": "@@ -1016,7 +1016,7 @@ print_operand (file, x, code)\n \t write 'l'.  Otherwise, write 'r'.  This is a kludge to fix a bug\n \t in the RS/6000 assembler where \"sri\" with a zero shift count\n \t write a trash instruction.  */\n-      if (GET_CODE (x) != CONST_INT && (INTVAL (x) & 31) == 0)\n+      if (GET_CODE (x) == CONST_INT && (INTVAL (x) & 31) == 0)\n \tfprintf (file, \"l\");\n       else\n \tfprintf (file, \"r\");\n@@ -1090,6 +1090,15 @@ first_reg_to_save ()\n     if (regs_ever_live[first_reg])\n       break;\n \n+  /* If profiling, then we must save/restore every register that contains\n+     a parameter before/after the .mcount call.  Use registers from 30 down\n+     to 23 to do this.  Don't use the frame pointer in reg 31.\n+\n+     For now, save enough room for all of the parameter registers.  */\n+  if (profile_flag)\n+    if (first_reg > 23)\n+      first_reg = 23;\n+\n   return first_reg;\n }\n \n@@ -1194,8 +1203,9 @@ output_prolog (file, size)\n       trunc_defined = 1;\n     }\n \n-  /* If we have to call a function to save fpr's, we will be using LR.  */\n-  if (first_fp_reg < 62)\n+  /* If we have to call a function to save fpr's, or if we are doing profiling,\n+     then we will be using LR.  */\n+  if (first_fp_reg < 62 || profile_flag)\n     regs_ever_live[65] = 1;\n \n   /* If we use the link register, get it into r0.  */\n@@ -1511,3 +1521,45 @@ rs6000_gen_section_name (buf, filename, section_desc)\n   else\n     *p = '\\0';\n }\n+\f\n+/* Write function profiler code. */\n+\n+void\n+output_function_profiler (file, labelno)\n+  FILE *file;\n+  int labelno;\n+{\n+  /* The last used parameter register.  */\n+  int last_parm_reg;\n+  int i, j;\n+\n+  /* Set up a TOC entry for the profiler label.  */\n+  toc_section ();\n+  fprintf (file, \"LPTOC..%d:\\n\\t.tc\\tLP..%d[TC], LP..%d\\n\",\n+\t   labelno, labelno, labelno);\n+  text_section ();\n+\n+  /* Figure out last used parameter register.  The proper thing to do is\n+     to walk incoming args of the function.  A function might have live\n+     parameter registers even if it has no incoming args.  */\n+\n+  for (last_parm_reg = 10;\n+       last_parm_reg > 2 && ! regs_ever_live [last_parm_reg];\n+       last_parm_reg--)\n+    ;\n+\n+  /* Save parameter registers in regs 23-30.  Don't overwrite reg 31, since\n+     it might be set up as the frame pointer.  */\n+\n+  for (i = 3, j = 30; i <= last_parm_reg; i++, j--)\n+    fprintf (file, \"\\tai %d,%d,0\\n\", j, i);\n+\n+  /* Load location address into r3, and call mcount.  */\n+\n+  fprintf (file, \"\\tl 3,LPTOC..%d(2)\\n\\tbl .mcount\\n\", labelno);\n+\n+  /* Restore parameter registers.  */\n+\n+  for (i = 3, j = 30; i <= last_parm_reg; i++, j--)\n+    fprintf (file, \"\\tai %d,%d,0\\n\", i, j);\n+}"}]}