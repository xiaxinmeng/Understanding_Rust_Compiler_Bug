{"sha": "b68eb70bd6df8c4b846bddb4f0aeae9054b932bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY4ZWI3MGJkNmRmOGM0Yjg0NmJkZGI0ZjBhZWFlOTA1NGI5MzJiYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-07-13T09:17:36Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-07-13T09:17:36Z"}, "message": "vect: Create array_slice of live-out stmts\n\nThis patch constructs an array_slice of the scalar statements that\nproduce live-out reduction results in the original unvectorised loop.\nThere are three cases:\n\n- SLP reduction chains: the final SLP stmt is live-out\n- full SLP reductions: all SLP stmts are live-out\n- non-SLP reductions: the single scalar stmt is live-out\n\nThis is a slight simplification on its own, mostly because it maans\n\u201cgroup_size\u201d has a consistent meaning throughout the function.\nThe main justification though is that it helps with later patches.\n\ngcc/\n\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Truncate\n\tscalar_results to group_size elements after reducing down from\n\tN*group_size elements.  Construct an array_slice of the live-out\n\tstmts and assert that there is one stmt per scalar result.", "tree": {"sha": "66acfed4fee420d074d73214421797af5da9b608", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66acfed4fee420d074d73214421797af5da9b608"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b68eb70bd6df8c4b846bddb4f0aeae9054b932bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b68eb70bd6df8c4b846bddb4f0aeae9054b932bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b68eb70bd6df8c4b846bddb4f0aeae9054b932bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b68eb70bd6df8c4b846bddb4f0aeae9054b932bc/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3658ee4c73955ebf281842d2e637ca556fa8bbfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3658ee4c73955ebf281842d2e637ca556fa8bbfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3658ee4c73955ebf281842d2e637ca556fa8bbfd"}], "stats": {"total": 61, "additions": 21, "deletions": 40}, "files": [{"sha": "8390ac80ca00b487b3e1b87c10fb95269bda03e4", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 21, "deletions": 40, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68eb70bd6df8c4b846bddb4f0aeae9054b932bc/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68eb70bd6df8c4b846bddb4f0aeae9054b932bc/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=b68eb70bd6df8c4b846bddb4f0aeae9054b932bc", "patch": "@@ -5010,7 +5010,12 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n   auto_vec<tree> scalar_results;\n   unsigned int group_size = 1, k;\n   auto_vec<gimple *> phis;\n-  bool slp_reduc = false;\n+  /* SLP reduction without reduction chain, e.g.,\n+     # a1 = phi <a2, a0>\n+     # b1 = phi <b2, b0>\n+     a2 = operation (a1)\n+     b2 = operation (b1)  */\n+  bool slp_reduc = (slp_node && !REDUC_GROUP_FIRST_ELEMENT (stmt_info));\n   bool direct_slp_reduc;\n   tree new_phi_result;\n   tree induction_index = NULL_TREE;\n@@ -5050,6 +5055,16 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \tadjustment_def = STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT (reduc_info);\n     }\n \n+  stmt_vec_info single_live_out_stmt[] = { stmt_info };\n+  array_slice<const stmt_vec_info> live_out_stmts = single_live_out_stmt;\n+  if (slp_reduc)\n+    /* All statements produce live-out values.  */\n+    live_out_stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n+  else if (slp_node)\n+    /* The last statement in the reduction chain produces the live-out\n+       value.  */\n+    single_live_out_stmt[0] = SLP_TREE_SCALAR_STMTS (slp_node)[group_size - 1];\n+\n   unsigned vec_num;\n   int ncopies;\n   if (slp_node)\n@@ -5248,13 +5263,6 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n   new_scalar_dest = vect_create_destination_var (scalar_dest, NULL);\n   bitsize = TYPE_SIZE (scalar_type);\n \n-  /* SLP reduction without reduction chain, e.g.,\n-     # a1 = phi <a2, a0>\n-     # b1 = phi <b2, b0>\n-     a2 = operation (a1)\n-     b2 = operation (b1)  */\n-  slp_reduc = (slp_node && !REDUC_GROUP_FIRST_ELEMENT (stmt_info));\n-\n   /* True if we should implement SLP_REDUC using native reduction operations\n      instead of scalar operations.  */\n   direct_slp_reduc = (reduc_fn != IFN_LAST\n@@ -5877,6 +5885,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \t\t\t\t\t  first_res, res);\n                   scalar_results[j % group_size] = new_res;\n                 }\n+\t      scalar_results.truncate (group_size);\n \t      for (k = 0; k < group_size; k++)\n \t\tscalar_results[k] = gimple_convert (&stmts, scalar_type,\n \t\t\t\t\t\t    scalar_results[k]);\n@@ -5969,39 +5978,11 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n           use <s_out4>  \n           use <s_out4> */\n \n-\n-  /* In SLP reduction chain we reduce vector results into one vector if\n-     necessary, hence we set here REDUC_GROUP_SIZE to 1.  SCALAR_DEST is the\n-     LHS of the last stmt in the reduction chain, since we are looking for\n-     the loop exit phi node.  */\n-  if (REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n-    {\n-      stmt_vec_info dest_stmt_info\n-\t= vect_orig_stmt (SLP_TREE_SCALAR_STMTS (slp_node)[group_size - 1]);\n-      scalar_dest = gimple_assign_lhs (dest_stmt_info->stmt);\n-      group_size = 1;\n-    }\n-\n-  /* In SLP we may have several statements in NEW_PHIS and REDUCTION_PHIS (in\n-     case that REDUC_GROUP_SIZE is greater than vectorization factor).\n-     Therefore, we need to match SCALAR_RESULTS with corresponding statements.\n-     The first (REDUC_GROUP_SIZE / number of new vector stmts) scalar results\n-     correspond to the first vector stmt, etc.\n-     (RATIO is equal to (REDUC_GROUP_SIZE / number of new vector stmts)).  */\n-  if (group_size > new_phis.length ())\n-    gcc_assert (!(group_size % new_phis.length ()));\n-\n-  for (k = 0; k < group_size; k++)\n+  gcc_assert (live_out_stmts.size () == scalar_results.length ());\n+  for (k = 0; k < live_out_stmts.size (); k++)\n     {\n-      if (slp_reduc)\n-        {\n-\t  stmt_vec_info scalar_stmt_info = SLP_TREE_SCALAR_STMTS (slp_node)[k];\n-\n-\t  orig_stmt_info = STMT_VINFO_RELATED_STMT (scalar_stmt_info);\n-\t  /* SLP statements can't participate in patterns.  */\n-\t  gcc_assert (!orig_stmt_info);\n-\t  scalar_dest = gimple_assign_lhs (scalar_stmt_info->stmt);\n-        }\n+      stmt_vec_info scalar_stmt_info = vect_orig_stmt (live_out_stmts[k]);\n+      scalar_dest = gimple_assign_lhs (scalar_stmt_info->stmt);\n \n       phis.create (3);\n       /* Find the loop-closed-use at the loop exit of the original scalar"}]}