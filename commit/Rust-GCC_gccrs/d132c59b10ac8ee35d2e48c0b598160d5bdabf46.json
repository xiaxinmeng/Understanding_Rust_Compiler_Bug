{"sha": "d132c59b10ac8ee35d2e48c0b598160d5bdabf46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDEzMmM1OWIxMGFjOGVlMzVkMmU0OGMwYjU5ODE2MGQ1YmRhYmY0Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-07-12T16:56:57Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-07-12T16:56:57Z"}, "message": "tree-ssa-alias.c (same_tmr_indexing_p): Break out from ...\n\n\n\t* tree-ssa-alias.c (same_tmr_indexing_p): Break out from ...\n\t(indirect_refs_may_alias_p): ... here.\n\t(nonoverlapping_component_refs_since_match_p): Support also non-trivial\n\tmem refs in the access paths.\n\n\t* gcc.dg/tree-ssa/alias-access-path-9.c: New testcase.\n\nFrom-SVN: r273451", "tree": {"sha": "080c5b7b15159e9ae8e4cb14f36c0885da7f5b46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/080c5b7b15159e9ae8e4cb14f36c0885da7f5b46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d132c59b10ac8ee35d2e48c0b598160d5bdabf46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d132c59b10ac8ee35d2e48c0b598160d5bdabf46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d132c59b10ac8ee35d2e48c0b598160d5bdabf46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d132c59b10ac8ee35d2e48c0b598160d5bdabf46/comments", "author": null, "committer": null, "parents": [{"sha": "b9ef6a2e04bfd01329902781818ef80c52cd8b97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9ef6a2e04bfd01329902781818ef80c52cd8b97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9ef6a2e04bfd01329902781818ef80c52cd8b97"}], "stats": {"total": 99, "additions": 76, "deletions": 23}, "files": [{"sha": "37b5eafa598064aa18ae3d4a46e47590a08781a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d132c59b10ac8ee35d2e48c0b598160d5bdabf46/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d132c59b10ac8ee35d2e48c0b598160d5bdabf46/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d132c59b10ac8ee35d2e48c0b598160d5bdabf46", "patch": "@@ -1,3 +1,10 @@\n+2019-07-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-ssa-alias.c (same_tmr_indexing_p): Break out from ...\n+\t(indirect_refs_may_alias_p): ... here.\n+\t(nonoverlapping_component_refs_since_match_p): Support also non-trivial\n+\tmem refs in the access paths.\n+\n 2019-07-12  Jiangning Liu  <jiangning.liu@amperecomputing.com>\n \n \tPR tree-optimization/89430\n@@ -21,6 +28,7 @@\n \trather than this_state as the lowering context for the ELSE\n \tseq in a GIMPLE_EH_ELSE.\n \n+>>>>>>> .r273450\n 2019-07-12  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* vector-builder.h (vector_builder::elt): Allow already-supplied"}, {"sha": "4d6eb0ff648574ed46576e9f76159012ee48d733", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d132c59b10ac8ee35d2e48c0b598160d5bdabf46/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d132c59b10ac8ee35d2e48c0b598160d5bdabf46/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d132c59b10ac8ee35d2e48c0b598160d5bdabf46", "patch": "@@ -1,3 +1,7 @@\n+2019-07-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/alias-access-path-9.c: New testcase.\n+\n 2019-07-08  Jiangning Liu  <jiangning.liu@amperecomputing.com>\n \n \tPR tree-optimization/89430"}, {"sha": "fdc478922d5ce6decb931f6e51214ac22c81f197", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-9.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d132c59b10ac8ee35d2e48c0b598160d5bdabf46/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d132c59b10ac8ee35d2e48c0b598160d5bdabf46/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-9.c?ref=d132c59b10ac8ee35d2e48c0b598160d5bdabf46", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-fre1\" } */\n+\n+/* This testcase tests nonoverlapping_component_refs_since_match_p in presence\n+   of non-trivial mem-refs.  */\n+struct a {int a,b;};\n+struct b {struct a a[10];};\n+struct c {int c; struct b b;} c, *cptr;\n+\n+void\n+set_a(struct a *a, int p)\n+{\n+  a->a=p;\n+}\n+void\n+set_b(struct a *a, int p)\n+{\n+  a->b=p;\n+}\n+int\n+get_a(struct a *a)\n+{\n+  return a->a;\n+}\n+\n+int\n+test(int i, int j)\n+{\n+  struct b *bptr = &c.b;\n+  set_a (&bptr->a[i], 123);\n+  set_b (&bptr->a[j], 124);\n+  return get_a (&bptr->a[i]);\n+}\n+\n+int\n+test2(int i, int j)\n+{\n+  struct b *bptr = &cptr->b;\n+  set_a (&bptr->a[i], 125);\n+  set_b (&bptr->a[j], 126);\n+  return get_a (&bptr->a[i]);\n+}\n+/* { dg-final { scan-tree-dump-times \"return 123\" 1 \"fre1\"} } */\n+/* { dg-final { scan-tree-dump-times \"return 125\" 1 \"fre1\"} } */"}, {"sha": "e1ea30744de55746b7f99b6a45491184fe22584b", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d132c59b10ac8ee35d2e48c0b598160d5bdabf46/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d132c59b10ac8ee35d2e48c0b598160d5bdabf46/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=d132c59b10ac8ee35d2e48c0b598160d5bdabf46", "patch": "@@ -1265,20 +1265,6 @@ nonoverlapping_component_refs_since_match_p (tree match1, tree ref1,\n         component_refs1.safe_push (ref1);\n       ref1 = TREE_OPERAND (ref1, 0);\n     }\n-  if (TREE_CODE (ref1) == MEM_REF && ref1 != match1)\n-    {\n-      if (!integer_zerop (TREE_OPERAND (ref1, 1)))\n-\t{\n-\t  ++alias_stats.nonoverlapping_component_refs_since_match_p_may_alias;\n-\t  return -1;\n-\t}\n-    }\n-  /* TODO: Handle TARGET_MEM_REF later.  */\n-  if (TREE_CODE (ref1) == TARGET_MEM_REF && ref1 != match1)\n-    {\n-      ++alias_stats.nonoverlapping_component_refs_since_match_p_may_alias;\n-      return -1;\n-    }\n \n   /* Create the stack of handled components for REF2.  */\n   while (handled_component_p (ref2) && ref2 != match2)\n@@ -1290,20 +1276,31 @@ nonoverlapping_component_refs_since_match_p (tree match1, tree ref1,\n         component_refs2.safe_push (ref2);\n       ref2 = TREE_OPERAND (ref2, 0);\n     }\n-  if (TREE_CODE (ref2) == MEM_REF && ref2 != match2)\n-    {\n-      if (!integer_zerop (TREE_OPERAND (ref2, 1)))\n-\t{\n-\t  ++alias_stats.nonoverlapping_component_refs_since_match_p_may_alias;\n-\t  return -1;\n-\t}\n-    }\n-  if (TREE_CODE (ref2) == TARGET_MEM_REF && ref2 != match2)\n+\n+  bool mem_ref1 = TREE_CODE (ref1) == MEM_REF && ref1 != match1;\n+  bool mem_ref2 = TREE_CODE (ref2) == MEM_REF && ref2 != match2;\n+\n+  /* If only one of access path starts with MEM_REF check that offset is 0\n+     so the addresses stays the same after stripping it.\n+     TODO: In this case we may walk the other access path until we get same\n+     offset.\n+\n+     If both starts with MEM_REF, offset has to be same.  */\n+  if ((mem_ref1 && !mem_ref2 && !integer_zerop (TREE_OPERAND (ref1, 1)))\n+      || (mem_ref2 && !mem_ref1 && !integer_zerop (TREE_OPERAND (ref2, 1)))\n+      || (mem_ref1 && mem_ref2\n+\t  && !tree_int_cst_equal (TREE_OPERAND (ref1, 1),\n+\t\t\t\t  TREE_OPERAND (ref2, 1))))\n     {\n       ++alias_stats.nonoverlapping_component_refs_since_match_p_may_alias;\n       return -1;\n     }\n \n+  /* TARGET_MEM_REF are never wrapped in handled components, so we do not need\n+     to handle them here at all.  */\n+  gcc_checking_assert (TREE_CODE (ref1) != TARGET_MEM_REF\n+\t\t       && TREE_CODE (ref2) != TARGET_MEM_REF);\n+\n   /* Pop the stacks in parallel and examine the COMPONENT_REFs of the same\n      rank.  This is sufficient because we start from the same DECL and you\n      cannot reference several fields at a time with COMPONENT_REFs (unlike"}]}