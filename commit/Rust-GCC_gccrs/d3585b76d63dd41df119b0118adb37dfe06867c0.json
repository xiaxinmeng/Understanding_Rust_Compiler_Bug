{"sha": "d3585b76d63dd41df119b0118adb37dfe06867c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM1ODViNzZkNjNkZDQxZGYxMTliMDExOGFkYjM3ZGZlMDY4NjdjMA==", "commit": {"author": {"name": "Daniel Jacobowitz", "email": "dan@codesourcery.com", "date": "2005-11-04T15:02:51Z"}, "committer": {"name": "Daniel Jacobowitz", "email": "drow@gcc.gnu.org", "date": "2005-11-04T15:02:51Z"}, "message": "configure.ac: Add test for ARM TLS support.\n\n\t* configure.ac: Add test for ARM TLS support.\n\t* configure: Regenerated.\n\t* config/arm/arm-protos.h (legitimize_tls_address)\n\t(arm_tls_referenced_p, tls_mentioned_p)\n\t(arm_output_addr_const_extra): New prototypes.\n\t(thumb_legitimize_pic_address): Delete.\n\t* config/arm/arm.c: Include \"gt-arm.h\".\n\t(enum tls_reloc): New.\n\t(arm_cannot_copy_insn_p, arm_tls_symbol_p, load_tls_operand)\n\t(pcrel_constant_p, get_tls_get_addr, arm_load_tp)\n\t(arm_call_tls_get_addr, legitimize_tls_address)\n\t(arm_tls_referenced_p, arm_tls_operand_p_1, tls_mentioned_p)\n\t(arm_init_tls_builtins, arm_emit_tls_decoration)\n\t(arm_output_addr_const_extra): New functions.\n\t(TARGET_CANNOT_COPY_INSN_P, TARGET_CANNOT_FORCE_CONST_MEM)\n\t(TARGET_HAVE_TLS): Define.\n\t(target_thread_pointer): New.\n\t(arm_override_options): Handle -mtp=.\n\t(legitimize_pic_address): Ignore UNSPECs.\n\t(arm_legitimate_address_p, thumb_legitimate_address_p): Handle PC\n\trelative symbols.\n\t(arm_legitimize_address, thumb_legitimize_address): Handle TLS.\n\t(tls_get_addr_libfunc): New variable.\n\t(symbol_mentioned_p, label_mentioned_p): Ignore UNSPEC_TLS.\n\t(arm_init_builtins): Call arm_init_tls_builtins.\n\t(arm_expand_builtin): Handle ARM_BUILTIN_THREAD_POINTER.\n\t(arm_encode_section_info): Call default_encode_section_info.\n\t* config/arm/arm.h (TARGET_HARD_TP, TARGET_SOFT_TP): Define.\n\t(enum arm_tp_type): New.\n\t(target_thread_pointer): Add declaration.\n\t(LEGITIMATE_CONSTANT_P): Handle TLS.\n\t(LEGITIMATE_PIC_OPERAND_P): Handle TLS.\n\t(OUTPUT_ADDR_CONST_EXTRA): Call arm_output_addr_const_extra.\n\t(enum arm_builtins): Add ARM_BUILTIN_THREAD_POINTER.\n\t* config/arm/arm.md: Add UNSPEC_TLS.\n\t(movsi): Handle TLS.\n\t(pic_add_dot_plus_four, pic_add_dot_plus_eight): Allow for\n\tnon-PIC.\n\t(tls_load_dot_plus_eight): New insn and a peephole to create it.\n\t(load_tp_hard, load_tp_soft): New insns.\n\t* arm.opt: Add -mtp=.\n\t* doc/invoke.texi (ARM Options): Document -mtp.\n\nCo-Authored-By: Paul Brook <paul@codesourcery.com>\nCo-Authored-By: Phil Blundell <pb@reciva.com>\n\nFrom-SVN: r106489", "tree": {"sha": "0b5c365ba47bb21bef0fb99092b7dea429e37aca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b5c365ba47bb21bef0fb99092b7dea429e37aca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3585b76d63dd41df119b0118adb37dfe06867c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3585b76d63dd41df119b0118adb37dfe06867c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3585b76d63dd41df119b0118adb37dfe06867c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3585b76d63dd41df119b0118adb37dfe06867c0/comments", "author": null, "committer": null, "parents": [{"sha": "802b34612cc1c7176de9de21c4183ce4db22e4cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/802b34612cc1c7176de9de21c4183ce4db22e4cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/802b34612cc1c7176de9de21c4183ce4db22e4cb"}], "stats": {"total": 650, "additions": 624, "deletions": 26}, "files": [{"sha": "cfee75f54c4baa720363e2fbdd67058185bb5514", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3585b76d63dd41df119b0118adb37dfe06867c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3585b76d63dd41df119b0118adb37dfe06867c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d3585b76d63dd41df119b0118adb37dfe06867c0", "patch": "@@ -1,3 +1,50 @@\n+2005-11-04  Daniel Jacobowitz  <dan@codesourcery.com>\n+\t    Paul Brook  <paul@codesourcery.com>\n+\t    Phil Blundell  <pb@reciva.com>\n+\n+\t* configure.ac: Add test for ARM TLS support.\n+\t* configure: Regenerated.\n+\t* config/arm/arm-protos.h (legitimize_tls_address)\n+\t(arm_tls_referenced_p, tls_mentioned_p)\n+\t(arm_output_addr_const_extra): New prototypes.\n+\t(thumb_legitimize_pic_address): Delete.\n+\t* config/arm/arm.c: Include \"gt-arm.h\".\n+\t(enum tls_reloc): New.\n+\t(arm_cannot_copy_insn_p, arm_tls_symbol_p, load_tls_operand)\n+\t(pcrel_constant_p, get_tls_get_addr, arm_load_tp)\n+\t(arm_call_tls_get_addr, legitimize_tls_address)\n+\t(arm_tls_referenced_p, arm_tls_operand_p_1, tls_mentioned_p)\n+\t(arm_init_tls_builtins, arm_emit_tls_decoration)\n+\t(arm_output_addr_const_extra): New functions.\n+\t(TARGET_CANNOT_COPY_INSN_P, TARGET_CANNOT_FORCE_CONST_MEM)\n+\t(TARGET_HAVE_TLS): Define.\n+\t(target_thread_pointer): New.\n+\t(arm_override_options): Handle -mtp=.\n+\t(legitimize_pic_address): Ignore UNSPECs.\n+\t(arm_legitimate_address_p, thumb_legitimate_address_p): Handle PC\n+\trelative symbols.\n+\t(arm_legitimize_address, thumb_legitimize_address): Handle TLS.\n+\t(tls_get_addr_libfunc): New variable.\n+\t(symbol_mentioned_p, label_mentioned_p): Ignore UNSPEC_TLS.\n+\t(arm_init_builtins): Call arm_init_tls_builtins.\n+\t(arm_expand_builtin): Handle ARM_BUILTIN_THREAD_POINTER.\n+\t(arm_encode_section_info): Call default_encode_section_info.\n+\t* config/arm/arm.h (TARGET_HARD_TP, TARGET_SOFT_TP): Define.\n+\t(enum arm_tp_type): New.\n+\t(target_thread_pointer): Add declaration.\n+\t(LEGITIMATE_CONSTANT_P): Handle TLS.\n+\t(LEGITIMATE_PIC_OPERAND_P): Handle TLS.\n+\t(OUTPUT_ADDR_CONST_EXTRA): Call arm_output_addr_const_extra.\n+\t(enum arm_builtins): Add ARM_BUILTIN_THREAD_POINTER.\n+\t* config/arm/arm.md: Add UNSPEC_TLS.\n+\t(movsi): Handle TLS.\n+\t(pic_add_dot_plus_four, pic_add_dot_plus_eight): Allow for\n+\tnon-PIC.\n+\t(tls_load_dot_plus_eight): New insn and a peephole to create it.\n+\t(load_tp_hard, load_tp_soft): New insns.\n+\t* arm.opt: Add -mtp=.\n+\t* doc/invoke.texi (ARM Options): Document -mtp.\n+\n 2005-11-04  Daniel Jacobowitz  <dan@codesourcery.com>\n \n \t* config/arm/lib1funcs.asm: Don't include \"libunwind.S\"."}, {"sha": "2bd84ca6024c7c88fc805c5e9b6e15ac15489541", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3585b76d63dd41df119b0118adb37dfe06867c0/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3585b76d63dd41df119b0118adb37dfe06867c0/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=d3585b76d63dd41df119b0118adb37dfe06867c0", "patch": "@@ -56,6 +56,7 @@ extern RTX_CODE arm_canonicalize_comparison (RTX_CODE, enum machine_mode,\n \t\t\t\t\t     rtx *);\n extern int legitimate_pic_operand_p (rtx);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n+extern rtx legitimize_tls_address (rtx, rtx);\n extern int arm_legitimate_address_p  (enum machine_mode, rtx, RTX_CODE, int);\n extern int thumb_legitimate_address_p (enum machine_mode, rtx, int);\n extern int thumb_legitimate_offset_p (enum machine_mode, HOST_WIDE_INT);\n@@ -66,6 +67,7 @@ extern rtx thumb_legitimize_reload_address (rtx *, enum machine_mode, int, int,\n extern int arm_const_double_rtx (rtx);\n extern int neg_const_double_rtx_ok_for_fpa (rtx);\n extern enum reg_class vfp_secondary_reload_class (enum machine_mode, rtx);\n+extern bool arm_tls_referenced_p (rtx);\n \n extern int cirrus_memory_offset (rtx);\n extern int arm_coproc_mem_operand (rtx, bool);\n@@ -74,6 +76,7 @@ extern int arm_no_early_alu_shift_dep (rtx, rtx);\n extern int arm_no_early_alu_shift_value_dep (rtx, rtx);\n extern int arm_no_early_mul_dep (rtx, rtx);\n \n+extern int tls_mentioned_p (rtx);\n extern int symbol_mentioned_p (rtx);\n extern int label_mentioned_p (rtx);\n extern RTX_CODE minmax_code (rtx);\n@@ -122,6 +125,8 @@ extern const char *vfp_output_fstmx (rtx *);\n extern void arm_set_return_address (rtx, rtx);\n extern int arm_eliminable_register (rtx);\n \n+extern bool arm_output_addr_const_extra (FILE *, rtx);\n+\n #if defined TREE_CODE\n extern rtx arm_function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n extern void arm_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n@@ -161,7 +166,6 @@ extern const char *thumb_load_double_from_address (rtx *);\n extern const char *thumb_output_move_mem_multiple (int, rtx *);\n extern const char *thumb_call_via_reg (rtx);\n extern void thumb_expand_movmemqi (rtx *);\n-extern rtx *thumb_legitimize_pic_address (rtx, enum machine_mode, rtx);\n extern int thumb_go_if_legitimate_address (enum machine_mode, rtx);\n extern rtx arm_return_addr (int, rtx);\n extern void thumb_reload_out_hi (rtx *);"}, {"sha": "061c33abfcc0191dc116171d371250c295c47371", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 414, "deletions": 6, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3585b76d63dd41df119b0118adb37dfe06867c0/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3585b76d63dd41df119b0118adb37dfe06867c0/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=d3585b76d63dd41df119b0118adb37dfe06867c0", "patch": "@@ -188,6 +188,9 @@ static bool arm_cxx_use_aeabi_atexit (void);\n static void arm_init_libfuncs (void);\n static bool arm_handle_option (size_t, const char *, int);\n static unsigned HOST_WIDE_INT arm_shift_truncation_mask (enum machine_mode);\n+static bool arm_cannot_copy_insn_p (rtx);\n+static bool arm_tls_symbol_p (rtx x);\n+\n \f\n /* Initialize the GCC target structure.  */\n #if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n@@ -353,6 +356,17 @@ static unsigned HOST_WIDE_INT arm_shift_truncation_mask (enum machine_mode);\n #define TARGET_ARM_EABI_UNWINDER true\n #endif /* TARGET_UNWIND_INFO */\n \n+#undef  TARGET_CANNOT_COPY_INSN_P\n+#define TARGET_CANNOT_COPY_INSN_P arm_cannot_copy_insn_p\n+\n+#ifdef HAVE_AS_TLS\n+#undef TARGET_HAVE_TLS\n+#define TARGET_HAVE_TLS true\n+#endif\n+\n+#undef TARGET_CANNOT_FORCE_CONST_MEM\n+#define TARGET_CANNOT_FORCE_CONST_MEM arm_tls_referenced_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Obstack for minipool constant handling.  */\n@@ -390,6 +404,9 @@ enum float_abi_type arm_float_abi;\n /* Which ABI to use.  */\n enum arm_abi_type arm_abi;\n \n+/* Which thread pointer model to use.  */\n+enum arm_tp_type target_thread_pointer = TP_AUTO;\n+\n /* Used to parse -mstructure_size_boundary command line option.  */\n int    arm_structure_size_boundary = DEFAULT_STRUCTURE_SIZE_BOUNDARY;\n \n@@ -415,6 +432,7 @@ static int thumb_call_reg_needed;\n #define FL_VFPV2      (1 << 13)       /* Vector Floating Point V2.  */\n #define FL_WBUF\t      (1 << 14)\t      /* Schedule for write buffer ops.\n \t\t\t\t\t Note: ARM6 & 7 derivatives only.  */\n+#define FL_ARCH6K     (1 << 15)       /* Architecture rel 6 K extensions.  */\n \n #define FL_IWMMXT     (1 << 29)\t      /* XScale v2 or \"Intel Wireless MMX technology\".  */\n \n@@ -430,9 +448,9 @@ static int thumb_call_reg_needed;\n #define FL_FOR_ARCH5TEJ\tFL_FOR_ARCH5TE\n #define FL_FOR_ARCH6\t(FL_FOR_ARCH5TE | FL_ARCH6)\n #define FL_FOR_ARCH6J\tFL_FOR_ARCH6\n-#define FL_FOR_ARCH6K\tFL_FOR_ARCH6\n+#define FL_FOR_ARCH6K\t(FL_FOR_ARCH6 | FL_ARCH6K)\n #define FL_FOR_ARCH6Z\tFL_FOR_ARCH6\n-#define FL_FOR_ARCH6ZK\tFL_FOR_ARCH6\n+#define FL_FOR_ARCH6ZK\tFL_FOR_ARCH6K\n \n /* The bits in this mask specify which\n    instructions we are allowed to generate.  */\n@@ -463,6 +481,9 @@ int arm_arch5e = 0;\n /* Nonzero if this chip supports the ARM Architecture 6 extensions.  */\n int arm_arch6 = 0;\n \n+/* Nonzero if this chip supports the ARM 6K extensions.  */\n+int arm_arch6k = 0;\n+\n /* Nonzero if this chip can benefit from load scheduling.  */\n int arm_ld_sched = 0;\n \n@@ -677,6 +698,16 @@ static const struct abi_name arm_all_abis[] =\n   {\"aapcs-linux\",   ARM_ABI_AAPCS_LINUX}\n };\n \n+/* Supported TLS relocations.  */\n+\n+enum tls_reloc {\n+  TLS_GD32,\n+  TLS_LDM32,\n+  TLS_LDO32,\n+  TLS_IE32,\n+  TLS_LE32\n+};\n+\n /* Return the number of bits set in VALUE.  */\n static unsigned\n bit_count (unsigned long value)\n@@ -1065,6 +1096,7 @@ arm_override_options (void)\n   arm_arch5 = (insn_flags & FL_ARCH5) != 0;\n   arm_arch5e = (insn_flags & FL_ARCH5E) != 0;\n   arm_arch6 = (insn_flags & FL_ARCH6) != 0;\n+  arm_arch6k = (insn_flags & FL_ARCH6K) != 0;\n   arm_arch_xscale = (insn_flags & FL_XSCALE) != 0;\n   arm_arch_cirrus = (insn_flags & FL_CIRRUS) != 0;\n \n@@ -1194,6 +1226,30 @@ arm_override_options (void)\n       && (tune_flags & FL_MODE32) == 0)\n     flag_schedule_insns = flag_schedule_insns_after_reload = 0;\n \n+  if (target_thread_switch)\n+    {\n+      if (strcmp (target_thread_switch, \"soft\") == 0)\n+\ttarget_thread_pointer = TP_SOFT;\n+      else if (strcmp (target_thread_switch, \"auto\") == 0)\n+\ttarget_thread_pointer = TP_AUTO;\n+      else if (strcmp (target_thread_switch, \"cp15\") == 0)\n+\ttarget_thread_pointer = TP_CP15;\n+      else\n+\terror (\"invalid thread pointer option: -mtp=%s\", target_thread_switch);\n+    }\n+\n+  /* Use the cp15 method if it is available.  */\n+  if (target_thread_pointer == TP_AUTO)\n+    {\n+      if (arm_arch6k && !TARGET_THUMB)\n+\ttarget_thread_pointer = TP_CP15;\n+      else\n+\ttarget_thread_pointer = TP_SOFT;\n+    }\n+\n+  if (TARGET_HARD_TP && TARGET_THUMB)\n+    error (\"can not use -mtp=cp15 with -mthumb\");\n+\n   /* Override the default structure alignment for AAPCS ABI.  */\n   if (TARGET_AAPCS_BASED)\n     arm_structure_size_boundary = 8;\n@@ -3182,6 +3238,10 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)\n \treturn orig;\n \n+      if (GET_CODE (XEXP (orig, 0)) == UNSPEC\n+\t  && XINT (XEXP (orig, 0), 1) == UNSPEC_TLS)\n+\treturn orig;\n+\n       if (reg == 0)\n \t{\n \t  gcc_assert (!no_new_pseudos);\n@@ -3355,6 +3415,19 @@ arm_address_register_rtx_p (rtx x, int strict_p)\n \t  || regno == ARG_POINTER_REGNUM);\n }\n \n+/* Return TRUE if this rtx is the difference of a symbol and a label,\n+   and will reduce to a PC-relative relocation in the object file.\n+   Expressions like this can be left alone when generating PIC, rather\n+   than forced through the GOT.  */\n+static int\n+pcrel_constant_p (rtx x)\n+{\n+  if (GET_CODE (x) == MINUS)\n+    return symbol_mentioned_p (XEXP (x, 0)) && label_mentioned_p (XEXP (x, 1));\n+\n+  return FALSE;\n+}\n+\n /* Return nonzero if X is a valid ARM state address operand.  */\n int\n arm_legitimate_address_p (enum machine_mode mode, rtx x, RTX_CODE outer,\n@@ -3433,7 +3506,8 @@ arm_legitimate_address_p (enum machine_mode mode, rtx x, RTX_CODE outer,\n \t   && code == SYMBOL_REF\n \t   && CONSTANT_POOL_ADDRESS_P (x)\n \t   && ! (flag_pic\n-\t\t && symbol_mentioned_p (get_pool_constant (x))))\n+\t\t && symbol_mentioned_p (get_pool_constant (x))\n+\t\t && ! pcrel_constant_p (get_pool_constant (x))))\n     return 1;\n \n   return 0;\n@@ -3658,8 +3732,9 @@ thumb_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n \t   && GET_MODE_SIZE (mode) == 4\n \t   && GET_CODE (x) == SYMBOL_REF\n \t   && CONSTANT_POOL_ADDRESS_P (x)\n-\t   && !(flag_pic\n-\t\t&& symbol_mentioned_p (get_pool_constant (x))))\n+\t   && ! (flag_pic\n+\t\t && symbol_mentioned_p (get_pool_constant (x))\n+\t\t && ! pcrel_constant_p (get_pool_constant (x))))\n     return 1;\n \n   return 0;\n@@ -3685,11 +3760,163 @@ thumb_legitimate_offset_p (enum machine_mode mode, HOST_WIDE_INT val)\n     }\n }\n \n+/* Build the SYMBOL_REF for __tls_get_addr.  */\n+\n+static GTY(()) rtx tls_get_addr_libfunc;\n+\n+static rtx\n+get_tls_get_addr (void)\n+{\n+  if (!tls_get_addr_libfunc)\n+    tls_get_addr_libfunc = init_one_libfunc (\"__tls_get_addr\");\n+  return tls_get_addr_libfunc;\n+}\n+\n+static rtx\n+arm_load_tp (rtx target)\n+{\n+  if (!target)\n+    target = gen_reg_rtx (SImode);\n+\n+  if (TARGET_HARD_TP)\n+    {\n+      /* Can return in any reg.  */\n+      emit_insn (gen_load_tp_hard (target));\n+    }\n+  else\n+    {\n+      /* Always returned in r0.  Immediately copy the result into a pseudo,\n+\t otherwise other uses of r0 (e.g. setting up function arguments) may\n+\t clobber the value.  */\n+\n+      rtx tmp;\n+\n+      emit_insn (gen_load_tp_soft ());\n+\n+      tmp = gen_rtx_REG (SImode, 0);\n+      emit_move_insn (target, tmp);\n+    }\n+  return target;\n+}\n+\n+static rtx\n+load_tls_operand (rtx x, rtx reg)\n+{\n+  rtx tmp;\n+\n+  if (reg == NULL_RTX)\n+    reg = gen_reg_rtx (SImode);\n+\n+  tmp = gen_rtx_CONST (SImode, x);\n+\n+  emit_move_insn (reg, tmp);\n+\n+  return reg;\n+}\n+\n+static rtx\n+arm_call_tls_get_addr (rtx x, rtx reg, rtx *valuep, int reloc)\n+{\n+  rtx insns, label, sum;\n+\n+  start_sequence ();\n+\n+  label = gen_label_rtx ();\n+  sum = gen_rtx_UNSPEC (Pmode,\n+\t\t\tgen_rtvec (4, x, GEN_INT (reloc),\n+\t\t\t\t   gen_rtx_LABEL_REF (Pmode, label),\n+\t\t\t\t   GEN_INT (TARGET_ARM ? 8 : 4)),\n+\t\t\tUNSPEC_TLS);\n+  reg = load_tls_operand (sum, reg);\n+\n+  if (TARGET_ARM)\n+    emit_insn (gen_pic_add_dot_plus_eight (reg, label));\n+  else\n+    emit_insn (gen_pic_add_dot_plus_four (reg, label));\n+\n+  *valuep = emit_library_call_value (get_tls_get_addr (), NULL_RTX, LCT_PURE, /* LCT_CONST?  */\n+\t\t\t\t     Pmode, 1, reg, Pmode);\n+\n+  insns = get_insns ();\n+  end_sequence ();\n+\n+  return insns;\n+}\n+\n+rtx\n+legitimize_tls_address (rtx x, rtx reg)\n+{\n+  rtx dest, tp, label, sum, insns, ret, eqv, addend;\n+  unsigned int model = SYMBOL_REF_TLS_MODEL (x);\n+\n+  switch (model)\n+    {\n+    case TLS_MODEL_GLOBAL_DYNAMIC:\n+      insns = arm_call_tls_get_addr (x, reg, &ret, TLS_GD32);\n+      dest = gen_reg_rtx (Pmode);\n+      emit_libcall_block (insns, dest, ret, x);\n+      return dest;\n+\n+    case TLS_MODEL_LOCAL_DYNAMIC:\n+      insns = arm_call_tls_get_addr (x, reg, &ret, TLS_LDM32);\n+\n+      /* Attach a unique REG_EQUIV, to allow the RTL optimizers to\n+\t share the LDM result with other LD model accesses.  */\n+      eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const1_rtx),\n+\t\t\t    UNSPEC_TLS);\n+      dest = gen_reg_rtx (Pmode);\n+      emit_libcall_block (insns, dest, ret, x);\n+\n+      /* Load the addend.  */\n+      addend = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, x, GEN_INT (TLS_LDO32)),\n+\t\t\t       UNSPEC_TLS);\n+      addend = force_reg (SImode, gen_rtx_CONST (SImode, addend));\n+      return gen_rtx_PLUS (Pmode, dest, addend);\n+\n+    case TLS_MODEL_INITIAL_EXEC:\n+      label = gen_label_rtx ();\n+      sum = gen_rtx_UNSPEC (Pmode,\n+\t\t\t    gen_rtvec (4, x, GEN_INT (TLS_IE32),\n+\t\t\t\t       gen_rtx_LABEL_REF (Pmode, label),\n+\t\t\t\t       GEN_INT (TARGET_ARM ? 8 : 4)),\n+\t\t\t    UNSPEC_TLS);\n+      reg = load_tls_operand (sum, reg);\n+\n+      if (TARGET_ARM)\n+\temit_insn (gen_tls_load_dot_plus_eight (reg, reg, label));\n+      else\n+\t{\n+\t  emit_insn (gen_pic_add_dot_plus_four (reg, label));\n+\t  emit_move_insn (reg, gen_const_mem (SImode, reg));\n+\t}\n+\n+      tp = arm_load_tp (NULL_RTX);\n+\n+      return gen_rtx_PLUS (Pmode, tp, reg);\n+\n+    case TLS_MODEL_LOCAL_EXEC:\n+      tp = arm_load_tp (NULL_RTX);\n+\n+      reg = gen_rtx_UNSPEC (Pmode,\n+\t\t\t    gen_rtvec (2, x, GEN_INT (TLS_LE32)),\n+\t\t\t    UNSPEC_TLS);\n+      reg = force_reg (SImode, gen_rtx_CONST (SImode, reg));\n+\n+      return gen_rtx_PLUS (Pmode, tp, reg);\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.  */\n rtx\n arm_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n {\n+  if (arm_tls_symbol_p (x))\n+    return legitimize_tls_address (x, NULL_RTX);\n+\n   if (GET_CODE (x) == PLUS)\n     {\n       rtx xop0 = XEXP (x, 0);\n@@ -3803,6 +4030,9 @@ arm_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n rtx\n thumb_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n {\n+  if (arm_tls_symbol_p (x))\n+    return legitimize_tls_address (x, NULL_RTX);\n+\n   if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n       && (INTVAL (XEXP (x, 1)) >= 32 * GET_MODE_SIZE (mode)\n@@ -3907,6 +4137,50 @@ thumb_legitimize_reload_address (rtx *x_p,\n \n   return NULL;\n }\n+\n+/* Test for various thread-local symbols.  */\n+\n+/* Return TRUE if X is a thread-local symbol.  */\n+\n+static bool\n+arm_tls_symbol_p (rtx x)\n+{\n+  if (! TARGET_HAVE_TLS)\n+    return false;\n+\n+  if (GET_CODE (x) != SYMBOL_REF)\n+    return false;\n+\n+  return SYMBOL_REF_TLS_MODEL (x) != 0;\n+}\n+\n+/* Helper for arm_tls_referenced_p.  */\n+\n+static int\n+arm_tls_operand_p_1 (rtx *x, void *data ATTRIBUTE_UNUSED)\n+{\n+  if (GET_CODE (*x) == SYMBOL_REF)\n+    return SYMBOL_REF_TLS_MODEL (*x) != 0;\n+\n+  /* Don't recurse into UNSPEC_TLS looking for TLS symbols; these are\n+     TLS offsets, not real symbol references.  */\n+  if (GET_CODE (*x) == UNSPEC\n+      && XINT (*x, 1) == UNSPEC_TLS)\n+    return -1;\n+\n+  return 0;\n+}\n+\n+/* Return TRUE if X contains any TLS symbol references.  */\n+\n+bool\n+arm_tls_referenced_p (rtx x)\n+{\n+  if (! TARGET_HAVE_TLS)\n+    return false;\n+\n+  return for_each_rtx (&x, arm_tls_operand_p_1, NULL);\n+}\n \f\n #define REG_OR_SUBREG_REG(X)\t\t\t\t\t\t\\\n   (GET_CODE (X) == REG\t\t\t\t\t\t\t\\\n@@ -5278,6 +5552,11 @@ symbol_mentioned_p (rtx x)\n   if (GET_CODE (x) == SYMBOL_REF)\n     return 1;\n \n+  /* UNSPEC_TLS entries for a symbol include the SYMBOL_REF, but they\n+     are constant offsets, not symbols.  */\n+  if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_TLS)\n+    return 0;\n+\n   fmt = GET_RTX_FORMAT (GET_CODE (x));\n \n   for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n@@ -5307,6 +5586,11 @@ label_mentioned_p (rtx x)\n   if (GET_CODE (x) == LABEL_REF)\n     return 1;\n \n+  /* UNSPEC_TLS entries for a symbol include a LABEL_REF for the referencing\n+     instruction, but they are constant offsets, not symbols.  */\n+  if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_TLS)\n+    return 0;\n+\n   fmt = GET_RTX_FORMAT (GET_CODE (x));\n   for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n     {\n@@ -5325,6 +5609,48 @@ label_mentioned_p (rtx x)\n   return 0;\n }\n \n+int\n+tls_mentioned_p (rtx x)\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case CONST:\n+      return tls_mentioned_p (XEXP (x, 0));\n+\n+    case UNSPEC:\n+      if (XINT (x, 1) == UNSPEC_TLS)\n+\treturn 1;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Must not copy a SET whose source operand is PC-relative.  */\n+\n+static bool\n+arm_cannot_copy_insn_p (rtx insn)\n+{\n+  rtx pat = PATTERN (insn);\n+\n+  if (GET_CODE (pat) == PARALLEL\n+      && GET_CODE (XVECEXP (pat, 0, 0)) == SET)\n+    {\n+      rtx rhs = SET_SRC (XVECEXP (pat, 0, 0));\n+\n+      if (GET_CODE (rhs) == UNSPEC\n+\t  && XINT (rhs, 1) == UNSPEC_PIC_BASE)\n+\treturn TRUE;\n+\n+      if (GET_CODE (rhs) == MEM\n+\t  && GET_CODE (XEXP (rhs, 0)) == UNSPEC\n+\t  && XINT (XEXP (rhs, 0), 1) == UNSPEC_PIC_BASE)\n+\treturn TRUE;\n+    }\n+\n+  return FALSE;\n+}\n+\n enum rtx_code\n minmax_code (rtx x)\n {\n@@ -5811,7 +6137,6 @@ emit_stm_seq (rtx *operands, int nops)\n   output_asm_insn (buf, operands);\n   return \"\";\n }\n-\n \f\n /* Routines for use in generating RTL.  */\n \n@@ -12118,9 +12443,24 @@ arm_init_iwmmxt_builtins (void)\n   def_mbuiltin (FL_IWMMXT, \"__builtin_arm_tmiatt\", di_ftype_di_int_int, ARM_BUILTIN_TMIATT);\n }\n \n+static void\n+arm_init_tls_builtins (void)\n+{\n+  tree ftype;\n+  tree nothrow = tree_cons (get_identifier (\"nothrow\"), NULL, NULL);\n+  tree const_nothrow = tree_cons (get_identifier (\"const\"), NULL, nothrow);\n+\n+  ftype = build_function_type (ptr_type_node, void_list_node);\n+  lang_hooks.builtin_function (\"__builtin_thread_pointer\", ftype,\n+\t\t\t       ARM_BUILTIN_THREAD_POINTER, BUILT_IN_MD,\n+\t\t\t       NULL, const_nothrow);\n+}\n+\n static void\n arm_init_builtins (void)\n {\n+  arm_init_tls_builtins ();\n+\n   if (TARGET_REALLY_IWMMXT)\n     arm_init_iwmmxt_builtins ();\n }\n@@ -12425,6 +12765,9 @@ arm_expand_builtin (tree exp,\n       emit_insn (gen_iwmmxt_clrdi (target));\n       return target;\n \n+    case ARM_BUILTIN_THREAD_POINTER:\n+      return arm_load_tp (target);\n+\n     default:\n       break;\n     }\n@@ -14224,6 +14567,8 @@ arm_encode_section_info (tree decl, rtx rtl, int first)\n       else if (! TREE_PUBLIC (decl))\n         arm_encode_call_attribute (decl, SHORT_CALL_FLAG_CHAR);\n     }\n+\n+  default_encode_section_info (decl, rtl, first);\n }\n #endif /* !ARM_PE */\n \n@@ -15025,3 +15370,66 @@ arm_output_fn_unwind (FILE * f, bool prologue)\n   else\n     fputs (\"\\t.fnend\\n\", f);\n }\n+\n+static bool\n+arm_emit_tls_decoration (FILE *fp, rtx x)\n+{\n+  enum tls_reloc reloc;\n+  rtx val;\n+\n+  val = XVECEXP (x, 0, 0);\n+  reloc = INTVAL (XVECEXP (x, 0, 1));\n+\n+  output_addr_const (fp, val);\n+\n+  switch (reloc)\n+    {\n+    case TLS_GD32:\n+      fputs (\"(tlsgd)\", fp);\n+      break;\n+    case TLS_LDM32:\n+      fputs (\"(tlsldm)\", fp);\n+      break;\n+    case TLS_LDO32:\n+      fputs (\"(tlsldo)\", fp);\n+      break;\n+    case TLS_IE32:\n+      fputs (\"(gottpoff)\", fp);\n+      break;\n+    case TLS_LE32:\n+      fputs (\"(tpoff)\", fp);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  switch (reloc)\n+    {\n+    case TLS_GD32:\n+    case TLS_LDM32:\n+    case TLS_IE32:\n+      fputs (\" + (. - \", fp);\n+      output_addr_const (fp, XVECEXP (x, 0, 2));\n+      fputs (\" - \", fp);\n+      output_addr_const (fp, XVECEXP (x, 0, 3));\n+      fputc (')', fp);\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  return TRUE;\n+}\n+\n+bool\n+arm_output_addr_const_extra (FILE *fp, rtx x)\n+{\n+  if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_TLS)\n+    return arm_emit_tls_decoration (fp, x);\n+  else if (GET_CODE (x) == CONST_VECTOR)\n+    return arm_emit_vector_const (fp, x);\n+\n+  return FALSE;\n+}\n+\n+#include \"gt-arm.h\""}, {"sha": "2bca1538dc1a5dd48e2ef9f1ed310d52a999edc2", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3585b76d63dd41df119b0118adb37dfe06867c0/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3585b76d63dd41df119b0118adb37dfe06867c0/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=d3585b76d63dd41df119b0118adb37dfe06867c0", "patch": "@@ -192,6 +192,9 @@ extern GTY(()) rtx aof_pic_label;\n #define TARGET_AAPCS_BASED \\\n     (arm_abi != ARM_ABI_APCS && arm_abi != ARM_ABI_ATPCS)\n \n+#define TARGET_HARD_TP\t\t\t(target_thread_pointer == TP_CP15)\n+#define TARGET_SOFT_TP\t\t\t(target_thread_pointer == TP_SOFT)\n+\n /* True iff the full BPABI is being used.  If TARGET_BPABI is true,\n    then TARGET_AAPCS_BASED must be true -- but the converse does not\n    hold.  TARGET_BPABI implies the use of the BPABI runtime library,\n@@ -289,6 +292,15 @@ extern enum arm_abi_type arm_abi;\n #define ARM_DEFAULT_ABI ARM_ABI_APCS\n #endif\n \n+/* Which thread pointer access sequence to use.  */\n+enum arm_tp_type {\n+  TP_AUTO,\n+  TP_SOFT,\n+  TP_CP15\n+};\n+\n+extern enum arm_tp_type target_thread_pointer;\n+\n /* Nonzero if this chip supports the ARM Architecture 3M extensions.  */\n extern int arm_arch3m;\n \n@@ -1882,8 +1894,10 @@ typedef struct\n   || CONSTANT_ADDRESS_P (X)\t\t\\\n   || flag_pic)\n \n-#define LEGITIMATE_CONSTANT_P(X)\t\\\n-  (TARGET_ARM ? ARM_LEGITIMATE_CONSTANT_P (X) : THUMB_LEGITIMATE_CONSTANT_P (X))\n+#define LEGITIMATE_CONSTANT_P(X)\t\t\t\\\n+  (!arm_tls_referenced_p (X)\t\t\t\t\\\n+   && (TARGET_ARM ? ARM_LEGITIMATE_CONSTANT_P (X)\t\\\n+\t\t  : THUMB_LEGITIMATE_CONSTANT_P (X)))\n \n /* Special characters prefixed to function names\n    in order to encode attribute like information.\n@@ -2199,14 +2213,16 @@ extern int arm_pic_register;\n #define PIC_OFFSET_TABLE_REGNUM arm_pic_register\n \n /* We can't directly access anything that contains a symbol,\n-   nor can we indirect via the constant pool.  */\n+   nor can we indirect via the constant pool.  One exception is\n+   UNSPEC_TLS, which is always PIC.  */\n #define LEGITIMATE_PIC_OPERAND_P(X)\t\t\t\t\t\\\n \t(!(symbol_mentioned_p (X)\t\t\t\t\t\\\n \t   || label_mentioned_p (X)\t\t\t\t\t\\\n \t   || (GET_CODE (X) == SYMBOL_REF\t\t\t\t\\\n \t       && CONSTANT_POOL_ADDRESS_P (X)\t\t\t\t\\\n \t       && (symbol_mentioned_p (get_pool_constant (X))\t\t\\\n-\t\t   || label_mentioned_p (get_pool_constant (X))))))\n+\t\t   || label_mentioned_p (get_pool_constant (X)))))\t\\\n+\t || tls_mentioned_p (X))\n \n /* We need to know when we are making a constant pool; this determines\n    whether data needs to be in the GOT or can be referenced via a GOT\n@@ -2487,10 +2503,9 @@ extern int making_const_table;\n   else\t\t\t\t\t\t\\\n     THUMB_PRINT_OPERAND_ADDRESS (STREAM, X)\n \n-#define OUTPUT_ADDR_CONST_EXTRA(FILE, X, FAIL)\t\\\n-  if (GET_CODE (X) != CONST_VECTOR\t\t\\\n-      || ! arm_emit_vector_const (FILE, X))\t\\\n-    goto FAIL;\n+#define OUTPUT_ADDR_CONST_EXTRA(file, x, fail)\t\t\\\n+  if (arm_output_addr_const_extra (file, x) == FALSE)\t\\\n+    goto fail\n \n /* A C expression whose value is RTL representing the value of the return\n    address for the frame COUNT steps up from the current frame.  */\n@@ -2682,6 +2697,8 @@ enum arm_builtins\n   ARM_BUILTIN_WUNPCKELUH,\n   ARM_BUILTIN_WUNPCKELUW,\n \n+  ARM_BUILTIN_THREAD_POINTER,\n+\n   ARM_BUILTIN_MAX\n };\n #endif /* ! GCC_ARM_H */"}, {"sha": "478ce866092d734f10eb96cff0a5d00815056d16", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 91, "deletions": 9, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3585b76d63dd41df119b0118adb37dfe06867c0/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3585b76d63dd41df119b0118adb37dfe06867c0/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=d3585b76d63dd41df119b0118adb37dfe06867c0", "patch": "@@ -90,6 +90,7 @@\n    (UNSPEC_CLRDI    17) ; Used by the intrinsic form of the iWMMXt CLRDI instruction.\n    (UNSPEC_WMADDS   18) ; Used by the intrinsic form of the iWMMXt WMADDS instruction.\n    (UNSPEC_WMADDU   19) ; Used by the intrinsic form of the iWMMXt WMADDU instruction.\n+   (UNSPEC_TLS      20) ; A symbol that has been treated properly for TLS usage.\n   ]\n )\n \n@@ -4280,13 +4281,37 @@\n \t    operands[1] = force_reg (SImode, operands[1]);\n         }\n     }\n-    \n-  if (flag_pic\n-      && (CONSTANT_P (operands[1])\n-\t || symbol_mentioned_p (operands[1])\n-\t || label_mentioned_p (operands[1])))\n-    operands[1] = legitimize_pic_address (operands[1], SImode,\n-\t\t\t\t\t  (no_new_pseudos ? operands[0] : 0));\n+\n+  /* Recognize the case where operand[1] is a reference to thread-local\n+     data and load its address to a register.  */\n+  if (arm_tls_referenced_p (operands[1]))\n+    {\n+      rtx tmp = operands[1];\n+      rtx addend = NULL;\n+\n+      if (GET_CODE (tmp) == CONST && GET_CODE (XEXP (tmp, 0)) == PLUS)\n+        {\n+          addend = XEXP (XEXP (tmp, 0), 1);\n+          tmp = XEXP (XEXP (tmp, 0), 0);\n+        }\n+\n+      gcc_assert (GET_CODE (tmp) == SYMBOL_REF);\n+      gcc_assert (SYMBOL_REF_TLS_MODEL (tmp) != 0);\n+\n+      tmp = legitimize_tls_address (tmp, no_new_pseudos ? operands[0] : 0);\n+      if (addend)\n+        {\n+          tmp = gen_rtx_PLUS (SImode, tmp, addend);\n+          tmp = force_operand (tmp, operands[0]);\n+        }\n+      operands[1] = tmp;\n+    }\n+  else if (flag_pic\n+\t   && (CONSTANT_P (operands[1])\n+\t       || symbol_mentioned_p (operands[1])\n+\t       || label_mentioned_p (operands[1])))\n+      operands[1] = legitimize_pic_address (operands[1], SImode,\n+\t\t\t\t\t    (no_new_pseudos ? operands[0] : 0));\n   \"\n )\n \n@@ -4444,7 +4469,7 @@\n \t\t\t     (const (plus:SI (pc) (const_int 4))))]\n \t\t   UNSPEC_PIC_BASE))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"TARGET_THUMB && flag_pic\"\n+  \"TARGET_THUMB\"\n   \"*\n   (*targetm.asm_out.internal_label) (asm_out_file, \\\"L\\\",\n \t\t\t     CODE_LABEL_NUMBER (operands[1]));\n@@ -4459,7 +4484,7 @@\n \t\t\t     (const (plus:SI (pc) (const_int 8))))]\n \t\t   UNSPEC_PIC_BASE))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"TARGET_ARM && flag_pic\"\n+  \"TARGET_ARM\"\n   \"*\n     (*targetm.asm_out.internal_label) (asm_out_file, \\\"L\\\",\n \t\t\t       CODE_LABEL_NUMBER (operands[1]));\n@@ -4468,6 +4493,41 @@\n   [(set_attr \"predicable\" \"yes\")]\n )\n \n+(define_insn \"tls_load_dot_plus_eight\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t(mem:SI (unspec:SI [(plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t     (const (plus:SI (pc) (const_int 8))))]\n+\t\t\t   UNSPEC_PIC_BASE)))\n+   (use (label_ref (match_operand 2 \"\" \"\")))]\n+  \"TARGET_ARM\"\n+  \"*\n+    (*targetm.asm_out.internal_label) (asm_out_file, \\\"L\\\",\n+\t\t\t       CODE_LABEL_NUMBER (operands[2]));\n+    return \\\"ldr%?\\\\t%0, [%|pc, %1]\\t\\t@ tls_load_dot_plus_eight\\\";\n+  \"\n+  [(set_attr \"predicable\" \"yes\")]\n+)\n+\n+;; PIC references to local variables can generate pic_add_dot_plus_eight\n+;; followed by a load.  These sequences can be crunched down to\n+;; tls_load_dot_plus_eight by a peephole.\n+\n+(define_peephole2\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (unspec:SI [(plus:SI (match_dup 0)\n+\t\t\t     \t \t(const (plus:SI (pc) (const_int 8))))]\n+\t\t\t      UNSPEC_PIC_BASE))\n+   \t      (use (label_ref (match_operand 1 \"\" \"\")))])\n+   (set (match_operand:SI 2 \"register_operand\" \"\") (mem:SI (match_dup 0)))]\n+  \"TARGET_ARM && peep2_reg_dead_p (2, operands[0])\"\n+  [(parallel [(set (match_operand:SI 2 \"register_operand\" \"+r\")\n+\t\t   (mem:SI (unspec:SI [(plus:SI (match_dup 0)\n+\t\t\t\t\t\t(const (plus:SI (pc) (const_int 8))))]\n+\t\t\t\t      UNSPEC_PIC_BASE)))\n+   \t      (use (label_ref (match_operand 1 \"\" \"\")))])]\n+  \"\"\n+)\n+\n (define_expand \"builtin_setjmp_receiver\"\n   [(label_ref (match_operand 0 \"\" \"\"))]\n   \"flag_pic\"\n@@ -10080,6 +10140,28 @@\n   }\"\n )\n \n+\f\n+;; TLS support\n+\n+(define_insn \"load_tp_hard\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(const_int 0)] UNSPEC_TLS))]\n+  \"TARGET_HARD_TP\"\n+  \"mrc%?\\\\tp15, 0, %0, c13, c0, 3\\\\t@ load_tp_hard\"\n+  [(set_attr \"predicable\" \"yes\")]\n+)\n+\n+;; Doesn't clobber R1-R3.  Must use r0 for the first operand.\n+(define_insn \"load_tp_soft\"\n+  [(set (reg:SI 0) (unspec:SI [(const_int 0)] UNSPEC_TLS))\n+   (clobber (reg:SI LR_REGNUM))\n+   (clobber (reg:SI IP_REGNUM))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_SOFT_TP\"\n+  \"bl\\\\t__aeabi_read_tp\\\\t@ load_tp_soft\"\n+  [(set_attr \"conds\" \"clob\")]\n+)\n+\n ;; Load the FPA co-processor patterns\n (include \"fpa.md\")\n ;; Load the Maverick co-processor patterns"}, {"sha": "ac497d96186ebacf3eca96b30adb9602f0c6074c", "filename": "gcc/config/arm/arm.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3585b76d63dd41df119b0118adb37dfe06867c0/gcc%2Fconfig%2Farm%2Farm.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3585b76d63dd41df119b0118adb37dfe06867c0/gcc%2Fconfig%2Farm%2Farm.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.opt?ref=d3585b76d63dd41df119b0118adb37dfe06867c0", "patch": "@@ -134,6 +134,10 @@ mthumb-interwork\n Target Report Mask(INTERWORK)\n Support calls between Thumb and ARM instruction sets\n \n+mtp=\n+Target RejectNegative Joined Var(target_thread_switch)\n+Specify how to access the thread pointer\n+\n mtpcs-frame\n Target Report Mask(TPCS_FRAME)\n Thumb: Generate (non-leaf) stack frames even if not needed"}, {"sha": "f9a438bedfe16efe9fabb26c275695c5eff79458", "filename": "gcc/configure", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3585b76d63dd41df119b0118adb37dfe06867c0/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3585b76d63dd41df119b0118adb37dfe06867c0/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=d3585b76d63dd41df119b0118adb37dfe06867c0", "patch": "@@ -14523,6 +14523,19 @@ foo:\t.long\t25\n \ttls_first_minor=15\n \ttls_as_opt=--fatal-warnings\n \t;;\n+  arm*-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",%progbits\n+foo:\t.long\t25\n+\t.text\n+.word foo(gottpoff)\n+.word foo(tpoff)\n+.word foo(tlsgd)\n+.word foo(tlsldm)\n+.word foo(tlsldo)'\n+\ttls_first_major=2\n+\ttls_first_minor=17\n+\t;;\n   i[34567]86-*-*)\n     conftest_s='\n \t.section \".tdata\",\"awT\",@progbits"}, {"sha": "d46fc45fd73a234c234b1caf5b241c4db8bf0fe9", "filename": "gcc/configure.ac", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3585b76d63dd41df119b0118adb37dfe06867c0/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3585b76d63dd41df119b0118adb37dfe06867c0/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=d3585b76d63dd41df119b0118adb37dfe06867c0", "patch": "@@ -1,7 +1,7 @@\n # configure.ac for GCC\n # Process this file with autoconf to generate a configuration script.\n \n-# Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+# Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n # Free Software Foundation, Inc.\n \n #This file is part of GCC.\n@@ -2236,6 +2236,19 @@ foo:\t.long\t25\n \ttls_first_minor=15\n \ttls_as_opt=--fatal-warnings\n \t;;\n+  arm*-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",%progbits\n+foo:\t.long\t25\n+\t.text\n+.word foo(gottpoff)\n+.word foo(tpoff)\n+.word foo(tlsgd)\n+.word foo(tlsldm)\n+.word foo(tlsldo)'\n+\ttls_first_major=2\n+\ttls_first_minor=17\n+\t;;\n   i[34567]86-*-*)\n     conftest_s='\n \t.section \".tdata\",\"awT\",@progbits"}, {"sha": "eda329a76842ca0a81e72881d419ea52c4819664", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3585b76d63dd41df119b0118adb37dfe06867c0/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3585b76d63dd41df119b0118adb37dfe06867c0/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d3585b76d63dd41df119b0118adb37dfe06867c0", "patch": "@@ -412,7 +412,8 @@ Objective-C and Objective-C++ Dialects}.\n -mpoke-function-name @gol\n -mthumb  -marm @gol\n -mtpcs-frame  -mtpcs-leaf-frame @gol\n--mcaller-super-interworking  -mcallee-super-interworking}\n+-mcaller-super-interworking  -mcallee-super-interworking @gol\n+-mtp=@var{name}}\n \n @emph{AVR Options}\n @gccoptlist{-mmcu=@var{mcu}  -msize  -minit-stack=@var{n}  -mno-interrupts @gol\n@@ -7456,6 +7457,15 @@ execute correctly regardless of whether the target code has been\n compiled for interworking or not.  There is a small overhead in the cost\n of executing a function pointer if this option is enabled.\n \n+@item -mtp=@var{name}\n+@opindex mtp\n+Specify the access model for the thread local storage pointer.  The valid\n+models are @option{soft}, which generates calls to @code{__aeabi_read_tp},\n+@option{cp15}, which fetches the thread pointer from @code{cp15} directly\n+(supported in the arm6k architecture), and @option{auto}, which uses the\n+best available method for the selected processor.  The default setting is\n+@option{auto}.\n+\n @end table\n \n @node AVR Options"}]}