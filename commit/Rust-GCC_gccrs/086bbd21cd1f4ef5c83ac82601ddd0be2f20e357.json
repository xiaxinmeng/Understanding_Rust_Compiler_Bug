{"sha": "086bbd21cd1f4ef5c83ac82601ddd0be2f20e357", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg2YmJkMjFjZDFmNGVmNWM4M2FjODI2MDFkZGQwYmUyZjIwZTM1Nw==", "commit": {"author": {"name": "Toon Moene", "email": "toon@moene.indiv.nluug.nl", "date": "2002-07-10T21:13:26Z"}, "committer": {"name": "Toon Moene", "email": "toon@gcc.gnu.org", "date": "2002-07-10T21:13:26Z"}, "message": "Revert all patches for optimization of Complex .op.\n\n2002-07-10  Toon Moene  <toon@moene.indiv.nluug.nl>\n\n\tRevert all patches for optimization of Complex .op. Real.\n\t* complex_part_zero_p: Remove\n\t* expand_cmplxdiv_straight: Replace complex_part_zero_p(x)\n\twith x.\n\t* expand_cmplxdiv_wide: Ditto.\n\t* expand_binop: Ditto.\n\nFrom-SVN: r55379", "tree": {"sha": "20b08d545cc7d533bc9d754a9b90302cb34abc5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20b08d545cc7d533bc9d754a9b90302cb34abc5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/086bbd21cd1f4ef5c83ac82601ddd0be2f20e357", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/086bbd21cd1f4ef5c83ac82601ddd0be2f20e357", "html_url": "https://github.com/Rust-GCC/gccrs/commit/086bbd21cd1f4ef5c83ac82601ddd0be2f20e357", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/086bbd21cd1f4ef5c83ac82601ddd0be2f20e357/comments", "author": null, "committer": null, "parents": [{"sha": "126dbce033efc65645fd30054f0c33c56df91529", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/126dbce033efc65645fd30054f0c33c56df91529", "html_url": "https://github.com/Rust-GCC/gccrs/commit/126dbce033efc65645fd30054f0c33c56df91529"}], "stats": {"total": 45, "additions": 17, "deletions": 28}, "files": [{"sha": "a654380521ee7491ac52d9fb39c6c7e79c3798fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/086bbd21cd1f4ef5c83ac82601ddd0be2f20e357/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/086bbd21cd1f4ef5c83ac82601ddd0be2f20e357/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=086bbd21cd1f4ef5c83ac82601ddd0be2f20e357", "patch": "@@ -1,3 +1,12 @@\n+2002-07-10  Toon Moene  <toon@moene.indiv.nluug.nl>\n+\n+\tRevert all patches for optimization of Complex .op. Real.\n+\t* complex_part_zero_p: Remove\n+\t* expand_cmplxdiv_straight: Replace complex_part_zero_p(x)\n+\twith x.\n+\t* expand_cmplxdiv_wide: Ditto.\n+\t* expand_binop: Ditto.\n+\n 2002-07-10  Marek Michalkiewicz  <marekm@amelek.gda.pl>\n \n \t* config/avr/avr.md: Fix two 0x80000000 constants to make them"}, {"sha": "dcb4df5f04bf2c58a1e71300a498bb0eaf374f10", "filename": "gcc/optabs.c", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/086bbd21cd1f4ef5c83ac82601ddd0be2f20e357/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/086bbd21cd1f4ef5c83ac82601ddd0be2f20e357/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=086bbd21cd1f4ef5c83ac82601ddd0be2f20e357", "patch": "@@ -108,8 +108,6 @@ static rtx ftruncify\tPARAMS ((rtx));\n static optab new_optab\tPARAMS ((void));\n static inline optab init_optab\tPARAMS ((enum rtx_code));\n static inline optab init_optabv\tPARAMS ((enum rtx_code));\n-static inline int complex_part_zero_p PARAMS ((rtx, enum mode_class,\n-\t\t\t\t\t\tenum machine_mode));\n static void init_libfuncs PARAMS ((optab, int, int, const char *, int));\n static void init_integral_libfuncs PARAMS ((optab, const char *, int));\n static void init_floating_libfuncs PARAMS ((optab, const char *, int));\n@@ -241,22 +239,6 @@ widen_operand (op, mode, oldmode, unsignedp, no_extend)\n   return result;\n }\n \f\n-/* Test whether either the real or imaginary part of a complex floating\n-   point number is 0.0, so that it can be ignored (when compiling\n-   with -funsafe-math-optimizations). */\n-\n-static inline int\n-complex_part_zero_p (part, class, submode)\n-  rtx part;\n-  enum mode_class class;\n-  enum machine_mode submode;\n-{\n-  return part == 0 ||\n-\t  (flag_unsafe_math_optimizations\n-\t   && class == MODE_COMPLEX_FLOAT\n-\t   && part == CONST0_RTX (submode));\n-}\n-\n /* Generate code to perform a straightforward complex divide.  */\n \n static int\n@@ -310,7 +292,7 @@ expand_cmplxdiv_straight (real0, real1, imag0, imag1, realr, imagr, submode,\n   if (divisor == 0)\n     return 0;\n \n-  if (complex_part_zero_p (imag0, class, submode))\n+  if (imag0 == 0)\n     {\n       /* Mathematically, ((a)(c-id))/divisor.  */\n       /* Computationally, (a+i0) / (c+id) = (ac/(cc+dd)) + i(-ad/(cc+dd)).  */\n@@ -476,7 +458,7 @@ expand_cmplxdiv_wide (real0, real1, imag0, imag1, realr, imagr, submode,\n \n   /* Calculate dividend.  */\n \n-  if (complex_part_zero_p (imag0, class, submode))\n+  if (imag0 == 0)\n     {\n       real_t = real0;\n \n@@ -581,7 +563,7 @@ expand_cmplxdiv_wide (real0, real1, imag0, imag1, realr, imagr, submode,\n \n   /* Calculate dividend.  */\n \n-  if (complex_part_zero_p (imag0, class, submode))\n+  if (imag0 == 0)\n     {\n       /* Compute a / (c+id) as a(c/d) / (c(c/d)+d) + i (-a) / (c(c/d)+d).  */\n \n@@ -1609,11 +1591,10 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  else if (res != realr)\n \t    emit_move_insn (realr, res);\n \n-\t  if (!complex_part_zero_p (imag0, class, submode)\n-\t      && !complex_part_zero_p (imag1, class, submode))\n+\t  if (imag0 != 0 && imag1 != 0)\n \t    res = expand_binop (submode, binoptab, imag0, imag1,\n \t\t\t\timagr, unsignedp, methods);\n-\t  else if (!complex_part_zero_p (imag0, class, submode))\n+\t  else if (imag0 != 0)\n \t    res = imag0;\n \t  else if (binoptab->code == MINUS)\n             res = expand_unop (submode,\n@@ -1633,8 +1614,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \tcase MULT:\n \t  /* (a+ib) * (c+id) = (ac-bd) + i(ad+cb) */\n \n-\t  if (!complex_part_zero_p (imag0, class, submode)\n-\t       && !complex_part_zero_p (imag1, class, submode))\n+\t  if (imag0 != 0 && imag1 != 0)\n \t    {\n \t      rtx temp1, temp2;\n \n@@ -1697,7 +1677,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t      else if (res != realr)\n \t\temit_move_insn (realr, res);\n \n-\t      if (!complex_part_zero_p (imag0, class, submode))\n+\t      if (imag0 != 0)\n \t\tres = expand_binop (submode, binoptab,\n \t\t\t\t    real1, imag0, imagr, unsignedp, methods);\n \t      else\n@@ -1716,7 +1696,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \tcase DIV:\n \t  /* (a+ib) / (c+id) = ((ac+bd)/(cc+dd)) + i((bc-ad)/(cc+dd)) */\n \t  \n-\t  if (complex_part_zero_p (imag1, class, submode))\n+\t  if (imag1 == 0)\n \t    {\n \t      /* (a+ib) / (c+i0) = (a/c) + i(b/c) */\n "}]}