{"sha": "0cf856b72826d6c8888a5570716596242bf2085c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNmODU2YjcyODI2ZDZjODg4OGE1NTcwNzE2NTk2MjQyYmYyMDg1Yw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-07-24T23:30:39Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-07-24T23:30:39Z"}, "message": "re PR rtl-optimization/34999 (Incorrect FDE entries with hot/cold code section splitting (partition_hot_cold_basic_blocks))\n\n\tPR rtl-optimization/34999\n\t* dwarf2out.c (struct dw_fde_struct): Add dw_fde_switch_cfi\n\tand dw_fde_switched_cold_to_hot fields.\n\t(output_cfi_p): New function.\n\t(output_call_frame_info): If fde->dw_fde_switched_sections,\n\toutput 2 FDEs instead of one with corrupted header.\n\t(dwarf2out_do_cfi_startproc): New function.\n\t(dwarf2out_begin_prologue): Use it.  Initialize fde->dw_fde_switch_cfi\n\tand fde->dw_fde_switched_cold_to_hot.\n\t(dwarf2out_switch_text_section): Compute\n\tfde->dw_fde_switched_cold_to_hot.  Switch to new text section here.\n\tIf dwarf2out_do_cfi_asm, emit .cfi_endproc before it and call\n\tdwarf2out_do_cfi_startproc plus emit again currently active CFI insns.\n\tOtherwise, compute fde->dw_fde_switch_cfi.\n\nFrom-SVN: r150069", "tree": {"sha": "4d7bffae2e9b3f41417d6614c1efbdadba7f1d91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d7bffae2e9b3f41417d6614c1efbdadba7f1d91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0cf856b72826d6c8888a5570716596242bf2085c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cf856b72826d6c8888a5570716596242bf2085c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cf856b72826d6c8888a5570716596242bf2085c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cf856b72826d6c8888a5570716596242bf2085c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2a2869d6c57d1186e209d58d2f875e2f3180049e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a2869d6c57d1186e209d58d2f875e2f3180049e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a2869d6c57d1186e209d58d2f875e2f3180049e"}], "stats": {"total": 430, "additions": 279, "deletions": 151}, "files": [{"sha": "948f2fa6fda9196c8d5aeadd7f1c56ea65e90e40", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cf856b72826d6c8888a5570716596242bf2085c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cf856b72826d6c8888a5570716596242bf2085c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0cf856b72826d6c8888a5570716596242bf2085c", "patch": "@@ -1,3 +1,20 @@\n+2009-07-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/34999\n+\t* dwarf2out.c (struct dw_fde_struct): Add dw_fde_switch_cfi\n+\tand dw_fde_switched_cold_to_hot fields.\n+\t(output_cfi_p): New function.\n+\t(output_call_frame_info): If fde->dw_fde_switched_sections,\n+\toutput 2 FDEs instead of one with corrupted header.\n+\t(dwarf2out_do_cfi_startproc): New function.\n+\t(dwarf2out_begin_prologue): Use it.  Initialize fde->dw_fde_switch_cfi\n+\tand fde->dw_fde_switched_cold_to_hot.\n+\t(dwarf2out_switch_text_section): Compute\n+\tfde->dw_fde_switched_cold_to_hot.  Switch to new text section here.\n+\tIf dwarf2out_do_cfi_asm, emit .cfi_endproc before it and call\n+\tdwarf2out_do_cfi_startproc plus emit again currently active CFI insns.\n+\tOtherwise, compute fde->dw_fde_switch_cfi.\n+\n 2009-07-24  Cary Coutant  <ccoutant@google.com>\n \n \t* tree-cfg.c (assign_discriminator): Add explicit parentheses."}, {"sha": "c62116204465fe3ad11633ccbce2e696bff81623", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 262, "deletions": 151, "changes": 413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cf856b72826d6c8888a5570716596242bf2085c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cf856b72826d6c8888a5570716596242bf2085c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=0cf856b72826d6c8888a5570716596242bf2085c", "patch": "@@ -268,8 +268,8 @@ typedef struct GTY(()) dw_fde_struct {\n   const char *dw_fde_hot_section_end_label;\n   const char *dw_fde_unlikely_section_label;\n   const char *dw_fde_unlikely_section_end_label;\n-  bool dw_fde_switched_sections;\n   dw_cfi_ref dw_fde_cfi;\n+  dw_cfi_ref dw_fde_switch_cfi; /* Last CFI before switching sections.  */\n   unsigned funcdef_number;\n   HOST_WIDE_INT stack_realignment;\n   /* Dynamic realign argument pointer register.  */\n@@ -288,6 +288,10 @@ typedef struct GTY(()) dw_fde_struct {\n   /* True iff dw_fde_unlikely_section_label is in text_section or\n      cold_text_section.  */\n   unsigned cold_in_std_section : 1;\n+  /* True iff switched sections.  */\n+  unsigned dw_fde_switched_sections : 1;\n+  /* True iff switching from cold to hot section.  */\n+  unsigned dw_fde_switched_cold_to_hot : 1;\n }\n dw_fde_node;\n \n@@ -3210,14 +3214,65 @@ output_cfi_directive (dw_cfi_ref cfi)\n     }\n }\n \n+/* Return true if *CFIP should be output after switching sections.  */\n+\n+static bool\n+output_cfi_p (dw_cfi_ref *cfip, dw_cfi_ref *cfi_args_sizep)\n+{\n+  dw_cfi_ref cfi = *cfip, cfi2;\n+\n+  switch (cfi->dw_cfi_opc)\n+    {\n+    case DW_CFA_advance_loc:\n+    case DW_CFA_advance_loc1:\n+    case DW_CFA_advance_loc2:\n+    case DW_CFA_advance_loc4:\n+    case DW_CFA_MIPS_advance_loc8:\n+    case DW_CFA_set_loc:\n+      /* All advances should be ignored.  */\n+      return false;\n+    case DW_CFA_remember_state:\n+      /* Skip everything between .cfi_remember_state and\n+\t .cfi_restore_state.  */\n+      for (cfi2 = cfi->dw_cfi_next; cfi2; cfi2 = cfi2->dw_cfi_next)\n+\tif (cfi2->dw_cfi_opc == DW_CFA_restore_state)\n+\t  break;\n+\telse if (cfi2->dw_cfi_opc == DW_CFA_GNU_args_size)\n+\t  *cfi_args_sizep = cfi2;\n+\telse\n+\t  gcc_assert (cfi2->dw_cfi_opc != DW_CFA_remember_state);\n+      if (cfi2 == NULL)\n+\treturn true;\n+      *cfip = cfi2;\n+      return false;\n+    case DW_CFA_def_cfa_offset:\n+    case DW_CFA_def_cfa_offset_sf:\n+      /* Only keep the last of these if they are consecutive.  */\n+      for (cfi2 = cfi->dw_cfi_next; cfi2; cfi2 = cfi2->dw_cfi_next)\n+\tif (cfi2->dw_cfi_opc == cfi->dw_cfi_opc)\n+\t  *cfip = cfi2;\n+\telse if (cfi2->dw_cfi_opc == DW_CFA_GNU_args_size)\n+\t  *cfi_args_sizep = cfi2;\n+\telse\n+\t  break;\n+      return true;\n+    case DW_CFA_GNU_args_size:\n+      /* One DW_CFA_GNU_args_size, the last one, is enough.  */\n+      *cfi_args_sizep = cfi;\n+      return false;\n+    default:\n+      return true;\n+    }\n+}\n+\n /* Output the call frame information used to record information\n    that relates to calculating the frame pointer, and records the\n    location of saved registers.  */\n \n static void\n output_call_frame_info (int for_eh)\n {\n-  unsigned int i;\n+  unsigned int i, j;\n   dw_fde_ref fde;\n   dw_cfi_ref cfi;\n   char l1[20], l2[20], section_start_label[20];\n@@ -3423,8 +3478,9 @@ output_call_frame_info (int for_eh)\n   ASM_OUTPUT_LABEL (asm_out_file, l2);\n \n   /* Loop through all of the FDE's.  */\n-  for (i = 0; i < fde_table_in_use; i++)\n+  for (i = 0, j = 0; i < fde_table_in_use; i++)\n     {\n+      unsigned int k;\n       fde = &fde_table[i];\n \n       /* Don't emit EH unwind info for leaf functions that don't need it.  */\n@@ -3434,139 +3490,154 @@ output_call_frame_info (int for_eh)\n \t  && !fde->uses_eh_lsda)\n \tcontinue;\n \n-      targetm.asm_out.unwind_label (asm_out_file, fde->decl, for_eh, /* empty */ 0);\n-      targetm.asm_out.internal_label (asm_out_file, FDE_LABEL, for_eh + i * 2);\n-      ASM_GENERATE_INTERNAL_LABEL (l1, FDE_AFTER_SIZE_LABEL, for_eh + i * 2);\n-      ASM_GENERATE_INTERNAL_LABEL (l2, FDE_END_LABEL, for_eh + i * 2);\n-      if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4 && !for_eh)\n-\tdw2_asm_output_data (4, 0xffffffff,\n-\t\t\t     \"Initial length escape value indicating 64-bit DWARF extension\");\n-      dw2_asm_output_delta (for_eh ? 4 : DWARF_OFFSET_SIZE, l2, l1,\n-\t\t\t    \"FDE Length\");\n-      ASM_OUTPUT_LABEL (asm_out_file, l1);\n-\n-      if (for_eh)\n-\tdw2_asm_output_delta (4, l1, section_start_label, \"FDE CIE offset\");\n-      else\n-\tdw2_asm_output_offset (DWARF_OFFSET_SIZE, section_start_label,\n-\t\t\t       debug_frame_section, \"FDE CIE offset\");\n-\n-      if (for_eh)\n+      for (k = 0; k < (fde->dw_fde_switched_sections ? 2 : 1); k++)\n \t{\n-\t  if (fde->dw_fde_switched_sections)\n+\t  const char *begin, *end;\n+\n+\t  targetm.asm_out.unwind_label (asm_out_file, fde->decl, for_eh,\n+\t\t\t\t\t/* empty */ 0);\n+\t  targetm.asm_out.internal_label (asm_out_file, FDE_LABEL,\n+\t\t\t\t\t  for_eh + j);\n+\t  ASM_GENERATE_INTERNAL_LABEL (l1, FDE_AFTER_SIZE_LABEL, for_eh + j);\n+\t  ASM_GENERATE_INTERNAL_LABEL (l2, FDE_END_LABEL, for_eh + j);\n+\t  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4 && !for_eh)\n+\t    dw2_asm_output_data (4, 0xffffffff, \"Initial length escape value\"\n+\t\t\t\t \" indicating 64-bit DWARF extension\");\n+\t  dw2_asm_output_delta (for_eh ? 4 : DWARF_OFFSET_SIZE, l2, l1,\n+\t\t\t\t\"FDE Length\");\n+\t  ASM_OUTPUT_LABEL (asm_out_file, l1);\n+\n+\t  if (for_eh)\n+\t    dw2_asm_output_delta (4, l1, section_start_label,\n+\t\t\t\t  \"FDE CIE offset\");\n+\t  else\n+\t    dw2_asm_output_offset (DWARF_OFFSET_SIZE, section_start_label,\n+\t\t\t\t   debug_frame_section, \"FDE CIE offset\");\n+\n+\t  if (!fde->dw_fde_switched_sections)\n \t    {\n-\t      rtx sym_ref2 = gen_rtx_SYMBOL_REF (Pmode,\n-\t\t\t\t      fde->dw_fde_unlikely_section_label);\n-\t      rtx sym_ref3= gen_rtx_SYMBOL_REF (Pmode,\n-\t\t\t\t      fde->dw_fde_hot_section_label);\n-\t      SYMBOL_REF_FLAGS (sym_ref2) |= SYMBOL_FLAG_LOCAL;\n-\t      SYMBOL_REF_FLAGS (sym_ref3) |= SYMBOL_FLAG_LOCAL;\n-\t      dw2_asm_output_encoded_addr_rtx (fde_encoding, sym_ref3, false,\n-\t\t\t\t\t       \"FDE initial location\");\n-\t      dw2_asm_output_delta (size_of_encoded_value (fde_encoding),\n-\t\t\t\t    fde->dw_fde_hot_section_end_label,\n-\t\t\t\t    fde->dw_fde_hot_section_label,\n-\t\t\t\t    \"FDE address range\");\n-\t      dw2_asm_output_encoded_addr_rtx (fde_encoding, sym_ref2, false,\n-\t\t\t\t\t       \"FDE initial location\");\n-\t      dw2_asm_output_delta (size_of_encoded_value (fde_encoding),\n-\t\t\t\t    fde->dw_fde_unlikely_section_end_label,\n-\t\t\t\t    fde->dw_fde_unlikely_section_label,\n-\t\t\t\t    \"FDE address range\");\n+\t      begin = fde->dw_fde_begin;\n+\t      end = fde->dw_fde_end;\n+\t    }\n+\t  else if (k ^ fde->dw_fde_switched_cold_to_hot)\n+\t    {\n+\t      begin = fde->dw_fde_unlikely_section_label;\n+\t      end = fde->dw_fde_unlikely_section_end_label;\n \t    }\n \t  else\n \t    {\n-\t      rtx sym_ref = gen_rtx_SYMBOL_REF (Pmode, fde->dw_fde_begin);\n+\t      begin = fde->dw_fde_hot_section_label;\n+\t      end = fde->dw_fde_hot_section_end_label;\n+\t    }\n+\n+\t  if (for_eh)\n+\t    {\n+\t      rtx sym_ref = gen_rtx_SYMBOL_REF (Pmode, begin);\n \t      SYMBOL_REF_FLAGS (sym_ref) |= SYMBOL_FLAG_LOCAL;\n \t      dw2_asm_output_encoded_addr_rtx (fde_encoding,\n \t\t\t\t\t       sym_ref,\n \t\t\t\t\t       false,\n \t\t\t\t\t       \"FDE initial location\");\n \t      dw2_asm_output_delta (size_of_encoded_value (fde_encoding),\n-\t\t\t\t    fde->dw_fde_end, fde->dw_fde_begin,\n-\t\t\t\t    \"FDE address range\");\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  if (fde->dw_fde_switched_sections)\n-\t    {\n-\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE,\n-\t\t\t\t   fde->dw_fde_hot_section_label,\n-\t\t\t\t   \"FDE initial location\");\n-\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE,\n-\t\t\t\t    fde->dw_fde_hot_section_end_label,\n-\t\t\t\t    fde->dw_fde_hot_section_label,\n-\t\t\t\t    \"FDE address range\");\n-\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE,\n-\t\t\t\t   fde->dw_fde_unlikely_section_label,\n-\t\t\t\t   \"FDE initial location\");\n-\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE,\n-\t\t\t\t    fde->dw_fde_unlikely_section_end_label,\n-\t\t\t\t    fde->dw_fde_unlikely_section_label,\n-\t\t\t\t    \"FDE address range\");\n+\t\t\t\t    end, begin, \"FDE address range\");\n \t    }\n \t  else\n \t    {\n-\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE, fde->dw_fde_begin,\n+\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE, begin,\n \t\t\t\t   \"FDE initial location\");\n-\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE,\n-\t\t\t\t    fde->dw_fde_end, fde->dw_fde_begin,\n+\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE, end, begin,\n \t\t\t\t    \"FDE address range\");\n \t    }\n-\t}\n \n-      if (augmentation[0])\n-\t{\n-\t  if (any_lsda_needed)\n+\t  if (augmentation[0])\n \t    {\n-\t      int size = size_of_encoded_value (lsda_encoding);\n-\n-\t      if (lsda_encoding == DW_EH_PE_aligned)\n+\t      if (any_lsda_needed)\n \t\t{\n-\t\t  int offset = (  4\t\t/* Length */\n-\t\t\t\t+ 4\t\t/* CIE offset */\n-\t\t\t\t+ 2 * size_of_encoded_value (fde_encoding)\n-\t\t\t\t+ 1\t\t/* Augmentation size */ );\n-\t\t  int pad = -offset & (PTR_SIZE - 1);\n-\n-\t\t  size += pad;\n-\t\t  gcc_assert (size_of_uleb128 (size) == 1);\n-\t\t}\n+\t\t  int size = size_of_encoded_value (lsda_encoding);\n \n-\t      dw2_asm_output_data_uleb128 (size, \"Augmentation size\");\n+\t\t  if (lsda_encoding == DW_EH_PE_aligned)\n+\t\t    {\n+\t\t      int offset = (  4\t\t/* Length */\n+\t\t\t\t    + 4\t\t/* CIE offset */\n+\t\t\t\t    + 2 * size_of_encoded_value (fde_encoding)\n+\t\t\t\t    + 1\t\t/* Augmentation size */ );\n+\t\t      int pad = -offset & (PTR_SIZE - 1);\n+\n+\t\t      size += pad;\n+\t\t      gcc_assert (size_of_uleb128 (size) == 1);\n+\t\t    }\n \n-\t      if (fde->uses_eh_lsda)\n-\t\t{\n-\t\t  ASM_GENERATE_INTERNAL_LABEL (l1, \"LLSDA\",\n-\t\t\t\t\t       fde->funcdef_number);\n-\t\t  dw2_asm_output_encoded_addr_rtx (\n-\t\t\tlsda_encoding, gen_rtx_SYMBOL_REF (Pmode, l1),\n-\t\t\tfalse, \"Language Specific Data Area\");\n+\t\t  dw2_asm_output_data_uleb128 (size, \"Augmentation size\");\n+\n+\t\t  if (fde->uses_eh_lsda)\n+\t\t    {\n+\t\t       ASM_GENERATE_INTERNAL_LABEL (l1, \"LLSDA\",\n+\t\t\t\t\t\t    fde->funcdef_number);\n+\t\t      dw2_asm_output_encoded_addr_rtx (lsda_encoding,\n+\t\t\t\t\t\tgen_rtx_SYMBOL_REF (Pmode, l1),\n+\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\"Language Specific Data Area\");\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (lsda_encoding == DW_EH_PE_aligned)\n+\t\t\tASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (PTR_SIZE));\n+\t\t      dw2_asm_output_data (\n+\t\t\t\tsize_of_encoded_value (lsda_encoding), 0,\n+\t\t\t\t\"Language Specific Data Area (none)\");\n+\t\t    }\n \t\t}\n \t      else\n+\t\tdw2_asm_output_data_uleb128 (0, \"Augmentation size\");\n+\t    }\n+\n+\t  /* Loop through the Call Frame Instructions associated with\n+\t     this FDE.  */\n+\t  fde->dw_fde_current_label = begin;\n+\t  if (!fde->dw_fde_switched_sections)\n+\t    for (cfi = fde->dw_fde_cfi; cfi != NULL; cfi = cfi->dw_cfi_next)\n+\t      output_cfi (cfi, fde, for_eh);\n+\t  else if (k == 0)\n+\t    {\n+\t      if (fde->dw_fde_switch_cfi)\n+\t\tfor (cfi = fde->dw_fde_cfi; cfi != NULL;\n+\t\t     cfi = cfi->dw_cfi_next)\n+\t\t  {\n+\t\t    output_cfi (cfi, fde, for_eh);\n+\t\t    if (cfi == fde->dw_fde_switch_cfi)\n+\t\t      break;\n+\t\t  }\n+\t    }\n+\t  else\n+\t    {\n+\t      dw_cfi_ref cfi_next = fde->dw_fde_cfi;\n+\n+\t      if (fde->dw_fde_switch_cfi)\n \t\t{\n-\t\t  if (lsda_encoding == DW_EH_PE_aligned)\n-\t\t    ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (PTR_SIZE));\n-\t\t  dw2_asm_output_data\n-\t\t    (size_of_encoded_value (lsda_encoding), 0,\n-\t\t     \"Language Specific Data Area (none)\");\n+\t\t  dw_cfi_ref cfi_args_size = NULL;\n+\t\t  cfi_next = fde->dw_fde_switch_cfi->dw_cfi_next;\n+\t\t  fde->dw_fde_switch_cfi->dw_cfi_next = NULL;\n+\t\t  for (cfi = fde->dw_fde_cfi; cfi != NULL;\n+\t\t       cfi = cfi->dw_cfi_next)\n+\t\t    if (output_cfi_p (&cfi, &cfi_args_size))\n+\t\t      output_cfi (cfi, fde, for_eh);\n+\t\t  if (cfi_args_size\n+\t\t      && cfi_args_size->dw_cfi_oprnd1.dw_cfi_offset)\n+\t\t    output_cfi (cfi_args_size, fde, for_eh);\n+\t\t  fde->dw_fde_switch_cfi->dw_cfi_next = cfi_next;\n \t\t}\n+\t      for (cfi = cfi_next; cfi != NULL; cfi = cfi->dw_cfi_next)\n+\t\toutput_cfi (cfi, fde, for_eh);\n \t    }\n-\t  else\n-\t    dw2_asm_output_data_uleb128 (0, \"Augmentation size\");\n-\t}\n \n-      /* Loop through the Call Frame Instructions associated with\n-\t this FDE.  */\n-      fde->dw_fde_current_label = fde->dw_fde_begin;\n-      for (cfi = fde->dw_fde_cfi; cfi != NULL; cfi = cfi->dw_cfi_next)\n-\toutput_cfi (cfi, fde, for_eh);\n+\t  /* Pad the FDE out to an address sized boundary.  */\n+\t  ASM_OUTPUT_ALIGN (asm_out_file,\n+\t\t\t    floor_log2 ((for_eh\n+\t\t\t\t\t ? PTR_SIZE : DWARF2_ADDR_SIZE)));\n+\t  ASM_OUTPUT_LABEL (asm_out_file, l2);\n \n-      /* Pad the FDE out to an address sized boundary.  */\n-      ASM_OUTPUT_ALIGN (asm_out_file,\n-\t\t\tfloor_log2 ((for_eh ? PTR_SIZE : DWARF2_ADDR_SIZE)));\n-      ASM_OUTPUT_LABEL (asm_out_file, l2);\n+\t  j += 2;\n+\t}\n     }\n \n   if (for_eh && targetm.terminate_dw2_eh_frame_info)\n@@ -3582,6 +3653,52 @@ output_call_frame_info (int for_eh)\n     app_disable ();\n }\n \n+/* Emit .cfi_startproc and .cfi_personality/.cfi_lsda if needed.  */\n+\n+static void\n+dwarf2out_do_cfi_startproc (void)\n+{\n+  int enc;\n+  rtx ref;\n+\n+  fprintf (asm_out_file, \"\\t.cfi_startproc\\n\");\n+\n+  if (eh_personality_libfunc)\n+    {\n+      enc = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/2, /*global=*/1);\n+      ref = eh_personality_libfunc;\n+\n+      /* ??? The GAS support isn't entirely consistent.  We have to\n+\t handle indirect support ourselves, but PC-relative is done\n+\t in the assembler.  Further, the assembler can't handle any\n+\t of the weirder relocation types.  */\n+      if (enc & DW_EH_PE_indirect)\n+\tref = dw2_force_const_mem (ref, true);\n+\n+      fprintf (asm_out_file, \"\\t.cfi_personality 0x%x,\", enc);\n+      output_addr_const (asm_out_file, ref);\n+      fputc ('\\n', asm_out_file);\n+    }\n+\n+  if (crtl->uses_eh_lsda)\n+    {\n+      char lab[20];\n+\n+      enc = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/0, /*global=*/0);\n+      ASM_GENERATE_INTERNAL_LABEL (lab, \"LLSDA\",\n+\t\t\t\t   current_function_funcdef_no);\n+      ref = gen_rtx_SYMBOL_REF (Pmode, lab);\n+      SYMBOL_REF_FLAGS (ref) = SYMBOL_FLAG_LOCAL;\n+\n+      if (enc & DW_EH_PE_indirect)\n+\tref = dw2_force_const_mem (ref, true);\n+\n+      fprintf (asm_out_file, \"\\t.cfi_lsda 0x%x,\", enc);\n+      output_addr_const (asm_out_file, ref);\n+      fputc ('\\n', asm_out_file);\n+    }\n+}\n+\n /* Output a marker (i.e. a label) for the beginning of a function, before\n    the prologue.  */\n \n@@ -3644,9 +3761,11 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,\n   fde->dw_fde_hot_section_end_label = NULL;\n   fde->dw_fde_unlikely_section_label = NULL;\n   fde->dw_fde_unlikely_section_end_label = NULL;\n-  fde->dw_fde_switched_sections = false;\n+  fde->dw_fde_switched_sections = 0;\n+  fde->dw_fde_switched_cold_to_hot = 0;\n   fde->dw_fde_end = NULL;\n   fde->dw_fde_cfi = NULL;\n+  fde->dw_fde_switch_cfi = NULL;\n   fde->funcdef_number = current_function_funcdef_no;\n   fde->nothrow = crtl->nothrow;\n   fde->uses_eh_lsda = crtl->uses_eh_lsda;\n@@ -3685,47 +3804,7 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,\n #endif\n \n   if (dwarf2out_do_cfi_asm ())\n-    {\n-      int enc;\n-      rtx ref;\n-\n-      fprintf (asm_out_file, \"\\t.cfi_startproc\\n\");\n-\n-      if (eh_personality_libfunc)\n-\t{\n-\t  enc = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/2, /*global=*/1); \n-\t  ref = eh_personality_libfunc;\n-\n-\t  /* ??? The GAS support isn't entirely consistent.  We have to\n-\t     handle indirect support ourselves, but PC-relative is done\n-\t     in the assembler.  Further, the assembler can't handle any\n-\t     of the weirder relocation types.  */\n-\t  if (enc & DW_EH_PE_indirect)\n-\t    ref = dw2_force_const_mem (ref, true);\n-\n-\t  fprintf (asm_out_file, \"\\t.cfi_personality 0x%x,\", enc);\n-\t  output_addr_const (asm_out_file, ref);\n-\t  fputc ('\\n', asm_out_file);\n-\t}\n-\n-      if (crtl->uses_eh_lsda)\n-\t{\n-\t  char lab[20];\n-\n-\t  enc = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/0, /*global=*/0);\n-\t  ASM_GENERATE_INTERNAL_LABEL (lab, \"LLSDA\",\n-\t\t\t\t       current_function_funcdef_no);\n-\t  ref = gen_rtx_SYMBOL_REF (Pmode, lab);\n-\t  SYMBOL_REF_FLAGS (ref) = SYMBOL_FLAG_LOCAL;\n-\n-\t  if (enc & DW_EH_PE_indirect)\n-\t    ref = dw2_force_const_mem (ref, true);\n-\n-\t  fprintf (asm_out_file, \"\\t.cfi_lsda 0x%x,\", enc);\n-\t  output_addr_const (asm_out_file, ref);\n-\t  fputc ('\\n', asm_out_file);\n-\t}\n-    }\n+    dwarf2out_do_cfi_startproc ();\n }\n \n /* Output a marker (i.e. a label) for the absolute end of the generated code\n@@ -3807,9 +3886,11 @@ dwarf2out_switch_text_section (void)\n {\n   dw_fde_ref fde = current_fde ();\n \n-  gcc_assert (cfun && fde);\n+  gcc_assert (cfun && fde && !fde->dw_fde_switched_sections);\n+\n+  fde->dw_fde_switched_sections = 1;\n+  fde->dw_fde_switched_cold_to_hot = !in_cold_section_p;\n \n-  fde->dw_fde_switched_sections = true;\n   fde->dw_fde_hot_section_label = crtl->subsections.hot_section_label;\n   fde->dw_fde_hot_section_end_label = crtl->subsections.hot_section_end_label;\n   fde->dw_fde_unlikely_section_label = crtl->subsections.cold_section_label;\n@@ -3823,6 +3904,36 @@ dwarf2out_switch_text_section (void)\n   /* There is no need to mark used sections when not debugging.  */\n   if (cold_text_section != NULL)\n     dwarf2out_note_section_used ();\n+\n+  if (dwarf2out_do_cfi_asm ())\n+    fprintf (asm_out_file, \"\\t.cfi_endproc\\n\");\n+\n+  /* Now do the real section switch.  */\n+  switch_to_section (current_function_section ());\n+\n+  if (dwarf2out_do_cfi_asm ())\n+    {\n+      dw_cfi_ref cfi, cfi_args_size = NULL;\n+\n+      dwarf2out_do_cfi_startproc ();\n+      /* As this is a different FDE, insert all current CFI instructions\n+\t again.  */\n+      for (cfi = fde->dw_fde_cfi; cfi; cfi = cfi->dw_cfi_next)\n+\tif (output_cfi_p (&cfi, &cfi_args_size))\n+\t  output_cfi_directive (cfi);\n+      if (cfi_args_size && cfi_args_size->dw_cfi_oprnd1.dw_cfi_offset)\n+\toutput_cfi_directive (cfi_args_size);\n+    }\n+  else\n+    {\n+      dw_cfi_ref cfi = fde->dw_fde_cfi;\n+\n+      cfi = fde->dw_fde_cfi;\n+      if (cfi)\n+\twhile (cfi->dw_cfi_next != NULL)\n+\t  cfi = cfi->dw_cfi_next;\n+      fde->dw_fde_switch_cfi = cfi;\n+    }\n }\n #endif\n \f"}]}