{"sha": "69851283e8a56a7cfdf40f566dcaae2331840a51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk4NTEyODNlOGE1NmE3Y2ZkZjQwZjU2NmRjYWFlMjMzMTg0MGE1MQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-09-24T23:53:37Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-09-24T23:53:37Z"}, "message": "cp-tree.h (language_lvalue_valid): Remove.\n\n\t* cp-tree.h (language_lvalue_valid): Remove.\n\t* decl.c (grokdeclarator): Don't disallow references to functions.\n\t* tree.c (lvalue_p_1): New function, combining duplicated\n\tcode from ...\n\t(lvalue_p): Use it.\n\t(real_lvalue_p): Likewise.\n\t* typeck.c (language_lvalue_valid): Remove.\n\t(build_modify_expr): Treat FUNCTION_TYPEs as readonly, even though\n\tthey don't have TREE_READONLY set.\n\t* typeck2.c (readonly_error): Add case for FUNCTION_DECLs.\n\nFrom-SVN: r22583", "tree": {"sha": "736e0a7d64b731293e53ed1d5b1cfe97e9274412", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/736e0a7d64b731293e53ed1d5b1cfe97e9274412"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69851283e8a56a7cfdf40f566dcaae2331840a51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69851283e8a56a7cfdf40f566dcaae2331840a51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69851283e8a56a7cfdf40f566dcaae2331840a51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69851283e8a56a7cfdf40f566dcaae2331840a51/comments", "author": null, "committer": null, "parents": [{"sha": "85ccbba3d72e6025398f487c4a948b192a2fdf8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85ccbba3d72e6025398f487c4a948b192a2fdf8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85ccbba3d72e6025398f487c4a948b192a2fdf8c"}], "stats": {"total": 200, "additions": 77, "deletions": 123}, "files": [{"sha": "548bed8dd71f43bbbfe7cafc405dd896356eb981", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69851283e8a56a7cfdf40f566dcaae2331840a51/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69851283e8a56a7cfdf40f566dcaae2331840a51/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=69851283e8a56a7cfdf40f566dcaae2331840a51", "patch": "@@ -1,3 +1,16 @@\n+1998-09-24  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h (language_lvalue_valid): Remove.\n+\t* decl.c (grokdeclarator): Don't disallow references to functions.\n+\t* tree.c (lvalue_p_1): New function, combining duplicated\n+\tcode from ...\n+\t(lvalue_p): Use it.\n+\t(real_lvalue_p): Likewise.\n+\t* typeck.c (language_lvalue_valid): Remove.\n+\t(build_modify_expr): Treat FUNCTION_TYPEs as readonly, even though\n+\tthey don't have TREE_READONLY set.\n+\t* typeck2.c (readonly_error): Add case for FUNCTION_DECLs.\n+\t\n 1998-09-24  Benjamin Kosnik  <bkoz@loony.cygnus.com>\n \n \t* spew.c (yylex): Give diagnostic."}, {"sha": "d77bb82c381114638a19abb06fe2ae575ef5dd7c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69851283e8a56a7cfdf40f566dcaae2331840a51/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69851283e8a56a7cfdf40f566dcaae2331840a51/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=69851283e8a56a7cfdf40f566dcaae2331840a51", "patch": "@@ -3101,7 +3101,6 @@ extern tree build_const_cast\t\t\tPROTO((tree, tree));\n extern tree build_c_cast\t\t\tPROTO((tree, tree));\n extern tree build_x_modify_expr\t\t\tPROTO((tree, enum tree_code, tree));\n extern tree build_modify_expr\t\t\tPROTO((tree, enum tree_code, tree));\n-extern int language_lvalue_valid\t\tPROTO((tree));\n extern void warn_for_assignment\t\t\tPROTO((char *, char *, char *, tree, int, int));\n extern tree convert_for_initialization\t\tPROTO((tree, tree, tree, int, char *, tree, int));\n extern void c_expand_asm_operands\t\tPROTO((tree, tree, tree, tree, int, char *, int));"}, {"sha": "87a391f03503bc3bba3a01f6c41085887e09d267", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69851283e8a56a7cfdf40f566dcaae2331840a51/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69851283e8a56a7cfdf40f566dcaae2331840a51/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=69851283e8a56a7cfdf40f566dcaae2331840a51", "patch": "@@ -9744,18 +9744,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    }\n \t  else if (TREE_CODE (declarator) == ADDR_EXPR)\n \t    {\n-\t      if (TREE_CODE (type) == FUNCTION_TYPE)\n-\t\t{\n-\t\t  error (\"cannot declare references to functions; use pointer to function instead\");\n-\t\t  type = build_pointer_type (type);\n-\t\t}\n+\t      if (TREE_CODE (type) == VOID_TYPE)\n+\t\terror (\"invalid type: `void &'\");\n \t      else\n-\t\t{\n-\t\t  if (TREE_CODE (type) == VOID_TYPE)\n-\t\t    error (\"invalid type: `void &'\");\n-\t\t  else\n-\t\t    type = build_reference_type (type);\n-\t\t}\n+\t\ttype = build_reference_type (type);\n \t    }\n \t  else if (TREE_CODE (type) == METHOD_TYPE)\n \t    {"}, {"sha": "1a87a5128e1b6cee0b3a9246964c553099327145", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 51, "deletions": 97, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69851283e8a56a7cfdf40f566dcaae2331840a51/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69851283e8a56a7cfdf40f566dcaae2331840a51/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=69851283e8a56a7cfdf40f566dcaae2331840a51", "patch": "@@ -40,20 +40,19 @@ static tree list_hash_lookup PROTO((int, int, int, int, tree, tree,\n \t\t\t\t    tree));\n static void propagate_binfo_offsets PROTO((tree, tree));\n static int avoid_overlap PROTO((tree, tree));\n+static int lvalue_p_1 PROTO((tree, int));\n \n #define CEIL(x,y) (((x) + (y) - 1) / (y))\n \n-/* Return nonzero if REF is an lvalue valid for this language.\n-   Lvalues can be assigned, unless they have TREE_READONLY.\n-   Lvalues can have their address taken, unless they have DECL_REGISTER.  */\n+/* Returns non-zero if REF is an lvalue.  If\n+   TREAT_CLASS_RVALUES_AS_LVALUES is non-zero, rvalues of class type\n+   are considered lvalues.  */\n \n-int\n-real_lvalue_p (ref)\n+static int\n+lvalue_p_1 (ref, treat_class_rvalues_as_lvalues)\n      tree ref;\n+     int treat_class_rvalues_as_lvalues;\n {\n-  if (! language_lvalue_valid (ref))\n-    return 0;\n-  \n   if (TREE_CODE (TREE_TYPE (ref)) == REFERENCE_TYPE)\n     return 1;\n \n@@ -71,7 +70,10 @@ real_lvalue_p (ref)\n     case UNSAVE_EXPR:\n     case TRY_CATCH_EXPR:\n     case WITH_CLEANUP_EXPR:\n-      return real_lvalue_p (TREE_OPERAND (ref, 0));\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+      return lvalue_p_1 (TREE_OPERAND (ref, 0),\n+\t\t\t treat_class_rvalues_as_lvalues);\n \n     case STRING_CST:\n       return 1;\n@@ -85,7 +87,6 @@ real_lvalue_p (ref)\n     case ARRAY_REF:\n     case PARM_DECL:\n     case RESULT_DECL:\n-    case ERROR_MARK:\n       if (TREE_CODE (TREE_TYPE (ref)) != FUNCTION_TYPE\n \t  && TREE_CODE (TREE_TYPE (ref)) != METHOD_TYPE)\n \treturn 1;\n@@ -97,24 +98,43 @@ real_lvalue_p (ref)\n     case OFFSET_REF:\n       if (TREE_CODE (TREE_OPERAND (ref, 1)) == FUNCTION_DECL)\n \treturn 1;\n-      return real_lvalue_p (TREE_OPERAND (ref, 0))\n-\t&& real_lvalue_p (TREE_OPERAND (ref, 1));\n+      return (lvalue_p_1 (TREE_OPERAND (ref, 0),\n+\t\t\t  treat_class_rvalues_as_lvalues)\n+\t      && lvalue_p_1 (TREE_OPERAND (ref, 1),\n+\t\t\t     treat_class_rvalues_as_lvalues));\n       break;\n \n     case COND_EXPR:\n-      return (real_lvalue_p (TREE_OPERAND (ref, 1))\n-\t      && real_lvalue_p (TREE_OPERAND (ref, 2)));\n+      return (lvalue_p_1 (TREE_OPERAND (ref, 1),\n+\t\t\t  treat_class_rvalues_as_lvalues)\n+\t      && lvalue_p_1 (TREE_OPERAND (ref, 2),\n+\t\t\t     treat_class_rvalues_as_lvalues));\n \n     case MODIFY_EXPR:\n       return 1;\n \n     case COMPOUND_EXPR:\n-      return real_lvalue_p (TREE_OPERAND (ref, 1));\n+      return lvalue_p_1 (TREE_OPERAND (ref, 1),\n+\t\t\t    treat_class_rvalues_as_lvalues);\n \n     case MAX_EXPR:\n     case MIN_EXPR:\n-      return (real_lvalue_p (TREE_OPERAND (ref, 0))\n-\t      && real_lvalue_p (TREE_OPERAND (ref, 1)));\n+      return (lvalue_p_1 (TREE_OPERAND (ref, 0),\n+\t\t\t  treat_class_rvalues_as_lvalues)\n+\t      && lvalue_p_1 (TREE_OPERAND (ref, 1),\n+\t\t\t     treat_class_rvalues_as_lvalues));\n+\n+    case TARGET_EXPR:\n+      return treat_class_rvalues_as_lvalues;\n+\n+    case CALL_EXPR:\n+      return (treat_class_rvalues_as_lvalues\n+\t      && IS_AGGR_TYPE (TREE_TYPE (ref)));\n+\n+    case FUNCTION_DECL:\n+      /* All functions (except non-static-member functions) are\n+\t lvalues.  */\n+      return !DECL_NONSTATIC_MEMBER_FUNCTION_P (ref);\n \n     default:\n       break;\n@@ -123,92 +143,26 @@ real_lvalue_p (ref)\n   return 0;\n }\n \n+/* Return nonzero if REF is an lvalue valid for this language.\n+   Lvalues can be assigned, unless they have TREE_READONLY, or unless\n+   they are FUNCTION_DECLs.  Lvalues can have their address taken,\n+   unless they have DECL_REGISTER.  */\n+\n+int\n+real_lvalue_p (ref)\n+     tree ref;\n+{\n+  return lvalue_p_1 (ref, /*treat_class_rvalues_as_lvalues=*/0);\n+}\n+\n /* This differs from real_lvalue_p in that class rvalues are considered\n    lvalues.  */\n+\n int\n lvalue_p (ref)\n      tree ref;\n {\n-  if (! language_lvalue_valid (ref))\n-    return 0;\n-  \n-  if (TREE_CODE (TREE_TYPE (ref)) == REFERENCE_TYPE)\n-    return 1;\n-\n-  if (ref == current_class_ptr && flag_this_is_variable <= 0)\n-    return 0;\n-\n-  switch (TREE_CODE (ref))\n-    {\n-      /* preincrements and predecrements are valid lvals, provided\n-\t what they refer to are valid lvals.  */\n-    case PREINCREMENT_EXPR:\n-    case PREDECREMENT_EXPR:\n-    case REALPART_EXPR:\n-    case IMAGPART_EXPR:\n-    case COMPONENT_REF:\n-    case SAVE_EXPR:\n-    case UNSAVE_EXPR:\n-    case TRY_CATCH_EXPR:\n-    case WITH_CLEANUP_EXPR:\n-      return lvalue_p (TREE_OPERAND (ref, 0));\n-\n-    case STRING_CST:\n-      return 1;\n-\n-    case VAR_DECL:\n-      if (TREE_READONLY (ref) && ! TREE_STATIC (ref)\n-\t  && DECL_LANG_SPECIFIC (ref)\n-\t  && DECL_IN_AGGR_P (ref))\n-\treturn 0;\n-    case INDIRECT_REF:\n-    case ARRAY_REF:\n-    case PARM_DECL:\n-    case RESULT_DECL:\n-    case ERROR_MARK:\n-      if (TREE_CODE (TREE_TYPE (ref)) != FUNCTION_TYPE\n-\t  && TREE_CODE (TREE_TYPE (ref)) != METHOD_TYPE)\n-\treturn 1;\n-      break;\n-\n-    case TARGET_EXPR:\n-      return 1;\n-\n-    case CALL_EXPR:\n-      if (IS_AGGR_TYPE (TREE_TYPE (ref)))\n-\treturn 1;\n-      break;\n-\n-      /* A currently unresolved scope ref.  */\n-    case SCOPE_REF:\n-      my_friendly_abort (103);\n-    case OFFSET_REF:\n-      if (TREE_CODE (TREE_OPERAND (ref, 1)) == FUNCTION_DECL)\n-\treturn 1;\n-      return lvalue_p (TREE_OPERAND (ref, 0))\n-\t&& lvalue_p (TREE_OPERAND (ref, 1));\n-      break;\n-\n-    case COND_EXPR:\n-      return (lvalue_p (TREE_OPERAND (ref, 1))\n-\t      && lvalue_p (TREE_OPERAND (ref, 2)));\n-\n-    case MODIFY_EXPR:\n-      return 1;\n-\n-    case COMPOUND_EXPR:\n-      return lvalue_p (TREE_OPERAND (ref, 1));\n-\n-    case MAX_EXPR:\n-    case MIN_EXPR:\n-      return (lvalue_p (TREE_OPERAND (ref, 0))\n-\t      && lvalue_p (TREE_OPERAND (ref, 1)));\n-\n-    default:\n-      break;\n-    }\n-\n-  return 0;\n+  return lvalue_p_1 (ref, /*treat_class_rvalues_as_lvalues=*/1);\n }\n \n /* Return nonzero if REF is an lvalue valid for this language;"}, {"sha": "72481750d7672628272abbae7b1b029e11d9efec", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69851283e8a56a7cfdf40f566dcaae2331840a51/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69851283e8a56a7cfdf40f566dcaae2331840a51/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=69851283e8a56a7cfdf40f566dcaae2331840a51", "patch": "@@ -6106,6 +6106,9 @@ build_modify_expr (lhs, modifycode, rhs)\n \t    && (IS_SIGNATURE_POINTER (TREE_TYPE (TREE_OPERAND (lhs, 0)))\n \t\t|| IS_SIGNATURE_REFERENCE (TREE_TYPE (TREE_OPERAND (lhs, 0)))))\n       && (TREE_READONLY (lhs) || TYPE_READONLY (lhstype)\n+\t  /* Functions are not modifiable, even though they are\n+\t     lvalues.  */\n+\t  || TREE_CODE (TREE_TYPE (lhs)) == FUNCTION_TYPE\n \t  || ((TREE_CODE (lhstype) == RECORD_TYPE\n \t       || TREE_CODE (lhstype) == UNION_TYPE)\n \t      && C_TYPE_FIELDS_READONLY (lhstype))\n@@ -6354,15 +6357,6 @@ build_x_modify_expr (lhs, modifycode, rhs)\n   return build_modify_expr (lhs, modifycode, rhs);\n }\n \n-/* Return 0 if EXP is not a valid lvalue in this language\n-   even though `lvalue_or_else' would accept it.  */\n-\n-int\n-language_lvalue_valid (exp)\n-     tree exp ATTRIBUTE_UNUSED;\n-{\n-  return 1;\n-}\n \f\n /* Get difference in deltas for different pointer to member function\n    types.  Return integer_zero_node, if FROM cannot be converted to a"}, {"sha": "a00a4f13ffc1904e8e50585eb0db618785edcfcf", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69851283e8a56a7cfdf40f566dcaae2331840a51/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69851283e8a56a7cfdf40f566dcaae2331840a51/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=69851283e8a56a7cfdf40f566dcaae2331840a51", "patch": "@@ -118,7 +118,9 @@ readonly_error (arg, string, soft)\n     (*fn) (\"%s of read-only reference `%D'\", string, TREE_OPERAND (arg, 0));\n   else if (TREE_CODE (arg) == RESULT_DECL)\n     (*fn) (\"%s of read-only named return value `%D'\", string, arg);\n-  else\t       \n+  else if (TREE_CODE (arg) == FUNCTION_DECL)\n+    (*fn) (\"%s of function `%D'\", string, arg);\n+  else\n     (*fn) (\"%s of read-only location\", string);\n }\n "}, {"sha": "9a2a4cffaa27f21ac36b6f17374319d77e914d8d", "filename": "gcc/testsuite/g++.old-deja/g++.bugs/900519_05.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69851283e8a56a7cfdf40f566dcaae2331840a51/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900519_05.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69851283e8a56a7cfdf40f566dcaae2331840a51/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900519_05.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900519_05.C?ref=69851283e8a56a7cfdf40f566dcaae2331840a51", "patch": "@@ -7,12 +7,12 @@\n // keywords: function types, reference types\n \n typedef void (func_type) (int, int);\n-typedef func_type& func_ref_type;\t\t// gets bogus error, XFAIL *-*-*\n+typedef func_type& func_ref_type;\t\t\n \n void function (int arg1, int arg2)\n {\n }\n \n-func_type& global_func_ref1 = function;\t\t// gets bogus error, XFAIL *-*-*\n+func_type& global_func_ref1 = function;\t\t\n \n int main () { return 0; }"}, {"sha": "5c62d6a10d2b405ac7cedddf301fad24e253f963", "filename": "gcc/testsuite/g++.old-deja/g++.jason/ref4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69851283e8a56a7cfdf40f566dcaae2331840a51/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fref4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69851283e8a56a7cfdf40f566dcaae2331840a51/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fref4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fref4.C?ref=69851283e8a56a7cfdf40f566dcaae2331840a51", "patch": "@@ -1,4 +1,4 @@\n // Build don't link:\n \n void f ();\n-void (&fr)() = f;\t\t// gets bogus error - references to functions XFAIL *-*-*\n+void (&fr)() = f;"}, {"sha": "d2f43d76e8b4855ff10b5b68f3067ec2da0e5c59", "filename": "gcc/testsuite/g++.old-deja/g++.law/arm2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69851283e8a56a7cfdf40f566dcaae2331840a51/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Farm2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69851283e8a56a7cfdf40f566dcaae2331840a51/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Farm2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Farm2.C?ref=69851283e8a56a7cfdf40f566dcaae2331840a51", "patch": "@@ -11,7 +11,7 @@ int f() {  return 1; }\n \n int main()\n {\n-  int (&fr)() = f;  // g++ cannot compile it\n+  int (&fr)() = f;\n \n   return 0;\n }"}]}