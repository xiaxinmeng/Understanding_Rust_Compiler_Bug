{"sha": "09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDljYWU3NTA3ZDllODhmMmIwNWNmM2E5NDA0YmYxODFlNjVjY2JhYw==", "commit": {"author": {"name": "Palmer Dabbelt", "email": "palmer@dabbelt.com", "date": "2017-02-06T21:38:37Z"}, "committer": {"name": "Palmer Dabbelt", "email": "palmer@gcc.gnu.org", "date": "2017-02-06T21:38:37Z"}, "message": "RISC-V Port: gcc\n\ngcc/ChangeLog:\n\n2017-02-06  Palmer Dabbelt  <palmer@dabbelt.com>\n\n        * config/riscv/riscv.c: New file.\n        * gcc/common/config/riscv/riscv-common.c: Likewise.\n        * config.gcc: Likewise.\n        * config/riscv/constraints.md: Likewise.\n        * config/riscv/elf.h: Likewise.\n        * config/riscv/generic.md: Likewise.\n        * config/riscv/linux.h: Likewise.\n        * config/riscv/multilib-generator: Likewise.\n        * config/riscv/peephole.md: Likewise.\n        * config/riscv/pic.md: Likewise.\n        * config/riscv/predicates.md: Likewise.\n        * config/riscv/riscv-builtins.c: Likewise.\n        * config/riscv/riscv-c.c: Likewise.\n        * config/riscv/riscv-ftypes.def: Likewise.\n        * config/riscv/riscv-modes.def: Likewise.\n        * config/riscv/riscv-opts.h: Likewise.\n        * config/riscv/riscv-protos.h: Likewise.\n        * config/riscv/riscv.h: Likewise.\n        * config/riscv/riscv.md: Likewise.\n        * config/riscv/riscv.opt: Likewise.\n        * config/riscv/sync.md: Likewise.\n        * config/riscv/t-elf-multilib: Likewise.\n        * config/riscv/t-linux: Likewise.\n        * config/riscv/t-linux-multilib: Likewise.\n        * config/riscv/t-riscv: Likewise.\n        * configure.ac: Likewise.\n        * doc/contrib.texi: Add Kito Cheng, Palmer Dabbelt, and Andrew\n        Waterman as RISC-V maintainers.\n        * doc/install.texi: Add RISC-V entries.\n        * doc/invoke.texi: Add RISC-V options section.\n        * doc/md.texi: Add RISC-V constraints section.\n\nFrom-SVN: r245224", "tree": {"sha": "4068c1ab645786d53f4bb817e680cf0963f2f03d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4068c1ab645786d53f4bb817e680cf0963f2f03d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/comments", "author": {"login": "palmer-dabbelt", "id": 1383006, "node_id": "MDQ6VXNlcjEzODMwMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1383006?v=4", "gravatar_id": "", "url": "https://api.github.com/users/palmer-dabbelt", "html_url": "https://github.com/palmer-dabbelt", "followers_url": "https://api.github.com/users/palmer-dabbelt/followers", "following_url": "https://api.github.com/users/palmer-dabbelt/following{/other_user}", "gists_url": "https://api.github.com/users/palmer-dabbelt/gists{/gist_id}", "starred_url": "https://api.github.com/users/palmer-dabbelt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/palmer-dabbelt/subscriptions", "organizations_url": "https://api.github.com/users/palmer-dabbelt/orgs", "repos_url": "https://api.github.com/users/palmer-dabbelt/repos", "events_url": "https://api.github.com/users/palmer-dabbelt/events{/privacy}", "received_events_url": "https://api.github.com/users/palmer-dabbelt/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "44a6da7bac79f288af814cd401a666c81fb8735c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44a6da7bac79f288af814cd401a666c81fb8735c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44a6da7bac79f288af814cd401a666c81fb8735c"}], "stats": {"total": 9093, "additions": 9091, "deletions": 2}, "files": [{"sha": "2ea85e5a608aa86da22302f1ff949843357ef0d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -1,3 +1,37 @@\n+2017-02-06  Palmer Dabbelt  <palmer@dabbelt.com>\n+\n+\t* config/riscv/riscv.c: New file.\n+\t* gcc/common/config/riscv/riscv-common.c: Likewise.\n+\t* config.gcc: Likewise.\n+\t* config/riscv/constraints.md: Likewise.\n+\t* config/riscv/elf.h: Likewise.\n+\t* config/riscv/generic.md: Likewise.\n+\t* config/riscv/linux.h: Likewise.\n+\t* config/riscv/multilib-generator: Likewise.\n+\t* config/riscv/peephole.md: Likewise.\n+\t* config/riscv/pic.md: Likewise.\n+\t* config/riscv/predicates.md: Likewise.\n+\t* config/riscv/riscv-builtins.c: Likewise.\n+\t* config/riscv/riscv-c.c: Likewise.\n+\t* config/riscv/riscv-ftypes.def: Likewise.\n+\t* config/riscv/riscv-modes.def: Likewise.\n+\t* config/riscv/riscv-opts.h: Likewise.\n+\t* config/riscv/riscv-protos.h: Likewise.\n+\t* config/riscv/riscv.h: Likewise.\n+\t* config/riscv/riscv.md: Likewise.\n+\t* config/riscv/riscv.opt: Likewise.\n+\t* config/riscv/sync.md: Likewise.\n+\t* config/riscv/t-elf-multilib: Likewise.\n+\t* config/riscv/t-linux: Likewise.\n+\t* config/riscv/t-linux-multilib: Likewise.\n+\t* config/riscv/t-riscv: Likewise.\n+\t* configure.ac: Likewise.\n+\t* doc/contrib.texi: Add Kito Cheng, Palmer Dabbelt, and Andrew\n+\tWaterman as RISC-V maintainers.\n+\t* doc/install.texi: Add RISC-V entries.\n+\t* doc/invoke.texi: Add RISC-V options section.\n+\t* doc/md.texi: Add RISC-V constraints section.\n+\n 2017-02-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/66144"}, {"sha": "50f1485f87a406dcf4ecf5571145980e965ce309", "filename": "gcc/common/config/riscv/riscv-common.c", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.c?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,131 @@\n+/* Common hooks for RISC-V.\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"common/common-target.h\"\n+#include \"common/common-target-def.h\"\n+#include \"opts.h\"\n+#include \"flags.h\"\n+#include \"diagnostic-core.h\"\n+\n+/* Parse a RISC-V ISA string into an option mask.  */\n+\n+static void\n+riscv_parse_arch_string (const char *isa, int *flags, location_t loc)\n+{\n+  const char *p = isa;\n+\n+  if (strncmp (p, \"rv32\", 4) == 0)\n+    *flags &= ~MASK_64BIT, p += 4;\n+  else if (strncmp (p, \"rv64\", 4) == 0)\n+    *flags |= MASK_64BIT, p += 4;\n+  else\n+    {\n+      error_at (loc, \"-march=%s: ISA string must begin with rv32 or rv64\", isa);\n+      return;\n+    }\n+\n+  if (*p == 'g')\n+    {\n+      p++;\n+\n+      *flags |= MASK_MUL;\n+      *flags |= MASK_ATOMIC;\n+      *flags |= MASK_HARD_FLOAT;\n+      *flags |= MASK_DOUBLE_FLOAT;\n+    }\n+  else if (*p == 'i')\n+    {\n+      p++;\n+\n+      *flags &= ~MASK_MUL;\n+      if (*p == 'm')\n+\t*flags |= MASK_MUL, p++;\n+\n+      *flags &= ~MASK_ATOMIC;\n+      if (*p == 'a')\n+\t*flags |= MASK_ATOMIC, p++;\n+\n+      *flags &= ~(MASK_HARD_FLOAT | MASK_DOUBLE_FLOAT);\n+      if (*p == 'f')\n+\t{\n+\t  *flags |= MASK_HARD_FLOAT, p++;\n+\n+\t  if (*p == 'd')\n+\t    {\n+\t      *flags |= MASK_DOUBLE_FLOAT;\n+\t      p++;\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      error_at (loc, \"-march=%s: invalid ISA string\", isa);\n+      return;\n+    }\n+\n+  *flags &= ~MASK_RVC;\n+  if (*p == 'c')\n+    *flags |= MASK_RVC, p++;\n+\n+  if (*p)\n+    {\n+      error_at (loc, \"-march=%s: unsupported ISA substring %qs\", isa, p);\n+      return;\n+    }\n+}\n+\n+/* Implement TARGET_HANDLE_OPTION.  */\n+\n+static bool\n+riscv_handle_option (struct gcc_options *opts,\n+\t\t     struct gcc_options *opts_set ATTRIBUTE_UNUSED,\n+\t\t     const struct cl_decoded_option *decoded,\n+\t\t     location_t loc)\n+{\n+  switch (decoded->opt_index)\n+    {\n+    case OPT_march_:\n+      riscv_parse_arch_string (decoded->arg, &opts->x_target_flags, loc);\n+      return true;\n+\n+    default:\n+      return true;\n+    }\n+}\n+\n+/* Implement TARGET_OPTION_OPTIMIZATION_TABLE.  */\n+static const struct default_options riscv_option_optimization_table[] =\n+  {\n+    { OPT_LEVELS_1_PLUS, OPT_fsection_anchors, NULL, 1 },\n+    { OPT_LEVELS_1_PLUS, OPT_fomit_frame_pointer, NULL, 1 },\n+    { OPT_LEVELS_2_PLUS, OPT_free, NULL, 1 },\n+    { OPT_LEVELS_NONE, 0, NULL, 0 }\n+  };\n+\n+#undef TARGET_OPTION_OPTIMIZATION_TABLE\n+#define TARGET_OPTION_OPTIMIZATION_TABLE riscv_option_optimization_table\n+\n+#undef TARGET_HANDLE_OPTION\n+#define TARGET_HANDLE_OPTION riscv_handle_option\n+\n+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;"}, {"sha": "ddfa4dccb520b8cc1706e1cb581298d670169ccf", "filename": "gcc/config.gcc", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -451,6 +451,10 @@ powerpc*-*-*)\n \tesac\n \textra_options=\"${extra_options} g.opt fused-madd.opt rs6000/rs6000-tables.opt\"\n \t;;\n+riscv*)\n+\tcpu_type=riscv\n+\textra_objs=\"riscv-builtins.o riscv-c.o\"\n+\t;;\n rs6000*-*-*)\n \textra_options=\"${extra_options} g.opt fused-madd.opt rs6000/rs6000-tables.opt\"\n \t;;\n@@ -2016,6 +2020,34 @@ microblaze*-*-elf)\n \tcxx_target_objs=\"${cxx_target_objs} microblaze-c.o\"\n \ttmake_file=\"${tmake_file} microblaze/t-microblaze\"\n         ;;\n+riscv*-*-linux*)\n+\ttm_file=\"elfos.h gnu-user.h linux.h glibc-stdint.h ${tm_file} riscv/linux.h\"\n+\tcase \"x${enable_multilib}\" in\n+\txno) ;;\n+\txyes) tmake_file=\"${tmake_file} riscv/t-linux-multilib\" ;;\n+\t*) echo \"Unknown value for enable_multilib\"; exit 1\n+\tesac\n+\ttmake_file=\"${tmake_file} riscv/t-riscv riscv/t-linux\"\n+\tgnu_ld=yes\n+\tgas=yes\n+\t# Force .init_array support.  The configure script cannot always\n+\t# automatically detect that GAS supports it, yet we require it.\n+\tgcc_cv_initfini_array=yes\n+\t;;\n+riscv*-*-elf*)\n+\ttm_file=\"elfos.h newlib-stdint.h ${tm_file} riscv/elf.h\"\n+\tcase \"x${enable_multilib}\" in\n+\txno) ;;\n+\txyes) tmake_file=\"${tmake_file} riscv/t-elf-multilib\" ;;\n+\t*) echo \"Unknown value for enable_multilib\"; exit 1\n+\tesac\n+\ttmake_file=\"${tmake_file} riscv/t-riscv\"\n+\tgnu_ld=yes\n+\tgas=yes\n+\t# Force .init_array support.  The configure script cannot always\n+\t# automatically detect that GAS supports it, yet we require it.\n+\tgcc_cv_initfini_array=yes\n+\t;;\n mips*-*-netbsd*)\t\t\t# NetBSD/mips, either endian.\n \ttarget_cpu_default=\"MASK_ABICALLS\"\n \ttm_file=\"elfos.h ${tm_file} mips/elf.h netbsd.h netbsd-elf.h mips/netbsd.h\"\n@@ -3939,6 +3971,70 @@ case \"${target}\" in\n \t\tdone\n \t\t;;\n \n+\triscv*-*-*)\n+\t\tsupported_defaults=\"abi arch tune\"\n+\n+\t\tcase \"${target}\" in\n+\t\triscv32*) xlen=32 ;;\n+\t\triscv64*) xlen=64 ;;\n+\t\t*) echo \"Unsupported RISC-V target ${target}\" 1>&2; exit 1 ;;\n+\t\tesac\n+\n+\t\t# Infer arch from --with-arch, --target, and --with-abi.\n+\t\tcase \"${with_arch}\" in\n+\t\trv32i* | rv32g* | rv64i* | rv64g*)\n+\t\t\t# OK.\n+\t\t\t;;\n+\t\t\"\")\n+\t\t\t# Infer XLEN, but otherwise assume GC.\n+\t\t\tcase \"${with_abi}\" in\n+\t\t\tilp32 | ilp32f | ilp32d) with_arch=\"rv32gc\" ;;\n+\t\t\tlp64 | lp64f | lp64d) with_arch=\"rv64gc\" ;;\n+\t\t\t*) with_arch=\"rv${xlen}gc\" ;;\n+\t\t\tesac\n+\t\t\t;;\n+\t\t*)\n+\t\t\techo \"--with-arch=${with_arch} is not supported.  The argument must begin with rv32i, rv32g, rv64i, or rv64g.\" 1>&2\n+\t\t\texit 1\n+\t\t\t;;\n+\t\tesac\n+\n+\t\t# Make sure --with-abi is valid.  If it was not specified,\n+\t\t# pick a default based on the ISA, preferring soft-float\n+\t\t# unless the D extension is present.\n+\t\tcase \"${with_abi}\" in\n+\t\tilp32 | ilp32f | ilp32d | lp64 | lp64f | lp64d)\n+\t\t\t;;\n+\t\t\"\")\n+\t\t\tcase \"${with_arch}\" in\n+\t\t\trv32*d* | rv32g*) with_abi=ilp32d ;;\n+\t\t\trv32*) with_abi=ilp32 ;;\n+\t\t\trv64*d* | rv64g*) with_abi=lp64d ;;\n+\t\t\trv64*) with_abi=lp64 ;;\n+\t\t\tesac\n+\t\t\t;;\n+\t\t*)\n+\t\t\techo \"--with-abi=${with_abi} is not supported\" 1>&2\n+\t\t\texit 1\n+\t\t\t;;\n+\t\tesac\n+\n+\t\t# Make sure ABI and ISA are compatible.\n+\t\tcase \"${with_abi},${with_arch}\" in\n+\t\tilp32,rv32* \\\n+\t\t| ilp32f,rv32*f* | ilp32f,rv32g* \\\n+\t\t| ilp32d,rv32*d* | ilp32d,rv32g* \\\n+\t\t| lp64,rv64* \\\n+\t\t| lp64f,rv64*f* | lp64f,rv64g* \\\n+\t\t| lp64d,rv64*d* | lp64d,rv64g*)\n+\t\t\t;;\n+\t\t*)\n+\t\t\techo \"--with-abi=${with_abi} is not supported for ISA ${with_arch}\" 1>&2\n+\t\t\texit 1\n+\t\t\t;;\n+\t\tesac\n+\t\t;;\n+\n \tmips*-*-*)\n \t\tsupported_defaults=\"abi arch arch_32 arch_64 float fpu nan fp_32 odd_spreg_32 tune tune_32 tune_64 divide llsc mips-plt synci lxc1-sxc1 madd4\"\n "}, {"sha": "ae93788e44a4a2b94beba8b5a989a18548e1dfa9", "filename": "gcc/config/riscv/constraints.md", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fconstraints.md?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,78 @@\n+;; Constraint definitions for RISC-V target.\n+;; Copyright (C) 2011-2017 Free Software Foundation, Inc.\n+;; Contributed by Andrew Waterman (andrew@sifive.com).\n+;; Based on MIPS target for GNU compiler.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; Register constraints\n+\n+(define_register_constraint \"f\" \"TARGET_HARD_FLOAT ? FP_REGS : NO_REGS\"\n+  \"A floating-point register (if available).\")\n+\n+(define_register_constraint \"j\" \"SIBCALL_REGS\"\n+  \"@internal\")\n+\n+;; Avoid using register t0 for JALR's argument, because for some\n+;; microarchitectures that is a return-address stack hint.\n+(define_register_constraint \"l\" \"JALR_REGS\"\n+  \"@internal\")\n+\n+;; General constraints\n+\n+(define_constraint \"I\"\n+  \"An I-type 12-bit signed immediate.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SMALL_OPERAND (ival)\")))\n+\n+(define_constraint \"J\"\n+  \"Integer zero.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0\")))\n+\n+(define_constraint \"K\"\n+  \"A 5-bit unsigned immediate for CSR access instructions.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 0, 31)\")))\n+\n+;; Floating-point constant +0.0, used for FCVT-based moves when FMV is\n+;; not available in RV32.\n+(define_constraint \"G\"\n+  \"@internal\"\n+  (and (match_code \"const_double\")\n+       (match_test \"op == CONST0_RTX (mode)\")))\n+\n+(define_memory_constraint \"A\"\n+  \"An address that is held in a general-purpose register.\"\n+  (and (match_code \"mem\")\n+       (match_test \"GET_CODE(XEXP(op,0)) == REG\")))\n+\n+(define_constraint \"S\"\n+  \"@internal\n+   A constant call address.\"\n+  (match_operand 0 \"absolute_symbolic_operand\"))\n+\n+(define_constraint \"U\"\n+  \"@internal\n+   A PLT-indirect call address.\"\n+  (match_operand 0 \"plt_symbolic_operand\"))\n+\n+(define_constraint \"T\"\n+  \"@internal\n+   A constant @code{move_operand}.\"\n+  (and (match_operand 0 \"move_operand\")\n+       (match_test \"CONSTANT_P (op)\")))"}, {"sha": "391e59f49b994c59dc9a2df35ad23299d0854081", "filename": "gcc/config/riscv/elf.h", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Felf.h?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,35 @@\n+/* Target macros for riscv*-elf targets.\n+   Copyright (C) 1994-2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#define LINK_SPEC \"\\\n+-melf\" XLEN_SPEC \"lriscv \\\n+%{shared}\"\n+\n+/* Link against Newlib libraries, because the ELF backend assumes Newlib.\n+   Handle the circular dependence between libc and libgloss. */\n+#undef  LIB_SPEC\n+#define LIB_SPEC \"--start-group -lc -lgloss --end-group\"\n+\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC \"crt0%O%s crtbegin%O%s\"\n+\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtend%O%s\"\n+\n+#define NO_IMPLICIT_EXTERN_C 1"}, {"sha": "294c7ef729dadbab5f8c5f416211e8b7a2173034", "filename": "gcc/config/riscv/generic.md", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Fgeneric.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Fgeneric.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fgeneric.md?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,78 @@\n+;; Generic DFA-based pipeline description for RISC-V targets.\n+;; Copyright (C) 2011-2017 Free Software Foundation, Inc.\n+;; Contributed by Andrew Waterman (andrew@sifive.com).\n+;; Based on MIPS target for GNU compiler.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+\n+(define_automaton \"pipe0\")\n+(define_cpu_unit \"alu\" \"pipe0\")\n+(define_cpu_unit \"imuldiv\" \"pipe0\")\n+(define_cpu_unit \"fdivsqrt\" \"pipe0\")\n+\n+(define_insn_reservation \"generic_alu\" 1\n+  (eq_attr \"type\" \"unknown,const,arith,shift,slt,multi,nop,logical,move\")\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_load\" 3\n+  (eq_attr \"type\" \"load,fpload\")\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_store\" 1\n+  (eq_attr \"type\" \"store,fpstore\")\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_xfer\" 3\n+  (eq_attr \"type\" \"mfc,mtc,fcvt,fmove,fcmp\")\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_branch\" 1\n+  (eq_attr \"type\" \"branch,jump,call\")\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_imul\" 10\n+  (eq_attr \"type\" \"imul\")\n+  \"imuldiv*10\")\n+\n+(define_insn_reservation \"generic_idivsi\" 34\n+  (and (eq_attr \"type\" \"idiv\")\n+       (eq_attr \"mode\" \"SI\"))\n+  \"imuldiv*34\")\n+\n+(define_insn_reservation \"generic_idivdi\" 66\n+  (and (eq_attr \"type\" \"idiv\")\n+       (eq_attr \"mode\" \"DI\"))\n+  \"imuldiv*66\")\n+\n+(define_insn_reservation \"generic_fmul_single\" 5\n+  (and (eq_attr \"type\" \"fadd,fmul,fmadd\")\n+       (eq_attr \"mode\" \"SF\"))\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_fmul_double\" 7\n+  (and (eq_attr \"type\" \"fadd,fmul,fmadd\")\n+       (eq_attr \"mode\" \"DF\"))\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_fdiv\" 20\n+  (eq_attr \"type\" \"fdiv\")\n+  \"fdivsqrt*20\")\n+\n+(define_insn_reservation \"generic_fsqrt\" 25\n+  (eq_attr \"type\" \"fsqrt\")\n+  \"fdivsqrt*25\")"}, {"sha": "ecf424d1a2bba7ac1cfb328bbccc8caa35f41956", "filename": "gcc/config/riscv/linux.h", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Flinux.h?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,44 @@\n+/* Definitions for RISC-V GNU/Linux systems with ELF format.\n+   Copyright (C) 1998-2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#define TARGET_OS_CPP_BUILTINS()\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    GNU_USER_TARGET_OS_CPP_BUILTINS();\t\t\t\t\\\n+  } while (0)\n+\n+#define GLIBC_DYNAMIC_LINKER \"/lib/ld-linux-riscv\" XLEN_SPEC \"-\" ABI_SPEC \".so.1\"\n+\n+/* Because RISC-V only has word-sized atomics, it requries libatomic where\n+   others do not.  So link libatomic by default, as needed.  */\n+#undef LIB_SPEC\n+#ifdef LD_AS_NEEDED_OPTION\n+#define LIB_SPEC GNU_USER_TARGET_LIB_SPEC \\\n+  \" %{pthread:\" LD_AS_NEEDED_OPTION \" -latomic \" LD_NO_AS_NEEDED_OPTION \"}\"\n+#else\n+#define LIB_SPEC GNU_USER_TARGET_LIB_SPEC \" -latomic \"\n+#endif\n+\n+#define LINK_SPEC \"\\\n+-melf\" XLEN_SPEC \"lriscv \\\n+%{shared} \\\n+  %{!shared: \\\n+    %{!static: \\\n+      %{rdynamic:-export-dynamic} \\\n+      -dynamic-linker \" GNU_USER_DYNAMIC_LINKER \"} \\\n+    %{static:-static}}\""}, {"sha": "50687b418946195b13ab22a90c8679692d932ac2", "filename": "gcc/config/riscv/multilib-generator", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Fmultilib-generator", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Fmultilib-generator", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fmultilib-generator?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,65 @@\n+#!/usr/bin/env python\n+\n+# RISC-V multilib list generator.\n+# Copyright (C) 2011-2017 Free Software Foundation, Inc.\n+# Contributed by Andrew Waterman (andrew@sifive.com).\n+# \n+# This file is part of GCC.\n+# \n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+# \n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Each argument to this script is of the form\n+#  <primary arch>-<abi>-<additional arches>-<extensions>\n+# For example,\n+#  rv32imafd-ilp32d-rv32g-c,v\n+# means that, in addition to rv32imafd, these configurations can also use the\n+# rv32imafd-ilp32d libraries: rv32imafdc, rv32imafdv, rv32g, rv32gc, rv32gv\n+\n+from __future__ import print_function\n+import sys\n+import collections\n+\n+arches = collections.OrderedDict()\n+abis = collections.OrderedDict()\n+required = []\n+reuse = []\n+\n+for cfg in sys.argv[1:]:\n+  (arch, abi, extra, ext) = cfg.split('-')\n+  arches[arch] = 1\n+  abis[abi] = 1\n+  extra = list(filter(None, extra.split(',')))\n+  ext = list(filter(None, ext.split(',')))\n+  alts = sum([[x] + [x + y for y in ext] for x in [arch] + extra], [])\n+  alts = alts + [x.replace('imafd', 'g') for x in alts if 'imafd' in x]\n+  for alt in alts[1:]:\n+    arches[alt] = 1\n+    reuse.append('march.%s/mabi.%s=march.%s/mabi.%s' % (arch, abi, alt, abi))\n+  required.append('march=%s/mabi=%s' % (arch, abi))\n+\n+arch_options = '/'.join(['march=%s' % x for x in arches.keys()])\n+arch_dirnames = ' \\\\\\n'.join(arches.keys())\n+\n+abi_options = '/'.join(['mabi=%s' % x for x in abis.keys()])\n+abi_dirnames = ' \\\\\\n'.join(abis.keys())\n+\n+prog = sys.argv[0].split('/')[-1]\n+print('# This file was generated by %s with the command:' % prog)\n+print('#  %s' % ' '.join(sys.argv))\n+\n+print('MULTILIB_OPTIONS = %s %s' % (arch_options, abi_options))\n+print('MULTILIB_DIRNAMES = %s %s' % (arch_dirnames, abi_dirnames))\n+print('MULTILIB_REQUIRED = %s' % ' \\\\\\n'.join(required))\n+print('MULTILIB_REUSE = %s' % ' \\\\\\n'.join(reuse))"}, {"sha": "7e644e01759b73ac2421f7affe3ad8b7b1efb920", "filename": "gcc/config/riscv/peephole.md", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Fpeephole.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Fpeephole.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fpeephole.md?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,40 @@\n+;; Peephole optimizations for RISC-V for GNU compiler.\n+;; Copyright (C) 2011-2017 Free Software Foundation, Inc.\n+;; Contributed by Andrew Waterman (andrew@sifive.com).\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; Simplify (unsigned long)(unsigned int)a << const\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\")\n+\t\t   (match_operand 2 \"const_int_operand\")))\n+   (set (match_operand:DI 3 \"register_operand\")\n+\t(lshiftrt:DI (match_dup 0) (match_dup 2)))\n+   (set (match_operand:DI 4 \"register_operand\")\n+\t(ashift:DI (match_dup 3) (match_operand 5 \"const_int_operand\")))]\n+  \"TARGET_64BIT\n+   && INTVAL (operands[5]) < INTVAL (operands[2])\n+   && (REGNO (operands[3]) == REGNO (operands[4])\n+       || peep2_reg_dead_p (3, operands[3]))\"\n+  [(set (match_dup 0)\n+\t(ashift:DI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 4)\n+\t(lshiftrt:DI (match_dup 0) (match_operand 5)))]\n+{\n+  operands[5] = GEN_INT (INTVAL (operands[2]) - INTVAL (operands[5]));\n+})"}, {"sha": "6a29ead32d363ec540e2cda206971e97ddd2eb31", "filename": "gcc/config/riscv/pic.md", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Fpic.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Fpic.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fpic.md?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,85 @@\n+;; PIC codegen for RISC-V for GNU compiler.\n+;; Copyright (C) 2011-2017 Free Software Foundation, Inc.\n+;; Contributed by Andrew Waterman (andrew@sifive.com).\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+\n+;; Simplify PIC loads to static variables.\n+;; These should go away once we figure out how to emit auipc discretely.\n+\n+(define_insn \"*local_pic_load<mode>\"\n+  [(set (match_operand:ANYI 0 \"register_operand\" \"=r\")\n+\t(mem:ANYI (match_operand 1 \"absolute_symbolic_operand\" \"\")))]\n+  \"USE_LOAD_ADDRESS_MACRO (operands[1])\"\n+  \"<load>\\t%0,%1\"\n+  [(set (attr \"length\") (const_int 8))])\n+\n+(define_insn \"*local_pic_load<mode>\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(mem:ANYF (match_operand 1 \"absolute_symbolic_operand\" \"\")))\n+   (clobber (match_scratch:DI 2 \"=r\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_64BIT && USE_LOAD_ADDRESS_MACRO (operands[1])\"\n+  \"<load>\\t%0,%1,%2\"\n+  [(set (attr \"length\") (const_int 8))])\n+\n+(define_insn \"*local_pic_load<mode>\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(mem:ANYF (match_operand 1 \"absolute_symbolic_operand\" \"\")))\n+   (clobber (match_scratch:SI 2 \"=r\"))]\n+  \"TARGET_HARD_FLOAT && !TARGET_64BIT && USE_LOAD_ADDRESS_MACRO (operands[1])\"\n+  \"<load>\\t%0,%1,%2\"\n+  [(set (attr \"length\") (const_int 8))])\n+\n+(define_insn \"*local_pic_loadu<mode>\"\n+  [(set (match_operand:SUPERQI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SUPERQI (mem:SUBX (match_operand 1 \"absolute_symbolic_operand\" \"\"))))]\n+  \"USE_LOAD_ADDRESS_MACRO (operands[1])\"\n+  \"<load>u\\t%0,%1\"\n+  [(set (attr \"length\") (const_int 8))])\n+\n+(define_insn \"*local_pic_storedi<mode>\"\n+  [(set (mem:ANYI (match_operand 0 \"absolute_symbolic_operand\" \"\"))\n+\t(match_operand:ANYI 1 \"reg_or_0_operand\" \"rJ\"))\n+   (clobber (match_scratch:DI 2 \"=&r\"))]\n+  \"TARGET_64BIT && USE_LOAD_ADDRESS_MACRO (operands[0])\"\n+  \"<store>\\t%z1,%0,%2\"\n+  [(set (attr \"length\") (const_int 8))])\n+\n+(define_insn \"*local_pic_storesi<mode>\"\n+  [(set (mem:ANYI (match_operand 0 \"absolute_symbolic_operand\" \"\"))\n+\t(match_operand:ANYI 1 \"reg_or_0_operand\" \"rJ\"))\n+   (clobber (match_scratch:SI 2 \"=&r\"))]\n+  \"!TARGET_64BIT && USE_LOAD_ADDRESS_MACRO (operands[0])\"\n+  \"<store>\\t%z1,%0,%2\"\n+  [(set (attr \"length\") (const_int 8))])\n+\n+(define_insn \"*local_pic_storedi<mode>\"\n+  [(set (mem:ANYF (match_operand 0 \"absolute_symbolic_operand\" \"\"))\n+\t(match_operand:ANYF 1 \"register_operand\" \"f\"))\n+   (clobber (match_scratch:DI 2 \"=r\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_64BIT && USE_LOAD_ADDRESS_MACRO (operands[0])\"\n+  \"<store>\\t%1,%0,%2\"\n+  [(set (attr \"length\") (const_int 8))])\n+\n+(define_insn \"*local_pic_storesi<mode>\"\n+  [(set (mem:ANYF (match_operand 0 \"absolute_symbolic_operand\" \"\"))\n+\t(match_operand:ANYF 1 \"register_operand\" \"f\"))\n+   (clobber (match_scratch:SI 2 \"=r\"))]\n+  \"TARGET_HARD_FLOAT && !TARGET_64BIT && USE_LOAD_ADDRESS_MACRO (operands[0])\"\n+  \"<store>\\t%1,%0,%2\"\n+  [(set (attr \"length\") (const_int 8))])"}, {"sha": "854af1481f79b1c97fa8474f660ca2f9e62d1ed0", "filename": "gcc/config/riscv/predicates.md", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fpredicates.md?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,180 @@\n+;; Predicate description for RISC-V target.\n+;; Copyright (C) 2011-2017 Free Software Foundation, Inc.\n+;; Contributed by Andrew Waterman (andrew@sifive.com).\n+;; Based on MIPS target for GNU compiler.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_predicate \"const_arith_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SMALL_OPERAND (INTVAL (op))\")))\n+\n+(define_predicate \"arith_operand\"\n+  (ior (match_operand 0 \"const_arith_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"const_csr_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 31)\")))\n+\n+(define_predicate \"csr_operand\"\n+  (ior (match_operand 0 \"const_csr_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"sle_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SMALL_OPERAND (INTVAL (op) + 1)\")))\n+\n+(define_predicate \"sleu_operand\"\n+  (and (match_operand 0 \"sle_operand\")\n+       (match_test \"INTVAL (op) + 1 != 0\")))\n+\n+(define_predicate \"const_0_operand\"\n+  (and (match_code \"const_int,const_wide_int,const_double,const_vector\")\n+       (match_test \"op == CONST0_RTX (GET_MODE (op))\")))\n+\n+(define_predicate \"reg_or_0_operand\"\n+  (ior (match_operand 0 \"const_0_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+;; Only use branch-on-bit sequences when the mask is not an ANDI immediate.\n+(define_predicate \"branch_on_bit_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) >= IMM_BITS - 1\")))\n+\n+;; A legitimate CONST_INT operand that takes more than one instruction\n+;; to load.\n+(define_predicate \"splittable_const_int_operand\"\n+  (match_code \"const_int\")\n+{\n+  /* Don't handle multi-word moves this way; we don't want to introduce\n+     the individual word-mode moves until after reload.  */\n+  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+    return false;\n+\n+  /* Otherwise check whether the constant can be loaded in a single\n+     instruction.  */\n+  return !LUI_OPERAND (INTVAL (op)) && !SMALL_OPERAND (INTVAL (op));\n+})\n+\n+(define_predicate \"move_operand\"\n+  (match_operand 0 \"general_operand\")\n+{\n+  enum riscv_symbol_type symbol_type;\n+\n+  /* The thinking here is as follows:\n+\n+     (1) The move expanders should split complex load sequences into\n+\t individual instructions.  Those individual instructions can\n+\t then be optimized by all rtl passes.\n+\n+     (2) The target of pre-reload load sequences should not be used\n+\t to store temporary results.  If the target register is only\n+\t assigned one value, reload can rematerialize that value\n+\t on demand, rather than spill it to the stack.\n+\n+     (3) If we allowed pre-reload passes like combine and cse to recreate\n+\t complex load sequences, we would want to be able to split the\n+\t sequences before reload as well, so that the pre-reload scheduler\n+\t can see the individual instructions.  This falls foul of (2);\n+\t the splitter would be forced to reuse the target register for\n+\t intermediate results.\n+\n+     (4) We want to define complex load splitters for combine.  These\n+\t splitters can request a temporary scratch register, which avoids\n+\t the problem in (2).  They allow things like:\n+\n+\t      (set (reg T1) (high SYM))\n+\t      (set (reg T2) (low (reg T1) SYM))\n+\t      (set (reg X) (plus (reg T2) (const_int OFFSET)))\n+\n+\t to be combined into:\n+\n+\t      (set (reg T3) (high SYM+OFFSET))\n+\t      (set (reg X) (lo_sum (reg T3) SYM+OFFSET))\n+\n+\t if T2 is only used this once.  */\n+  switch (GET_CODE (op))\n+    {\n+    case CONST_INT:\n+      return !splittable_const_int_operand (op, mode);\n+\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return riscv_symbolic_constant_p (op, &symbol_type)\n+\t      && !riscv_split_symbol_type (symbol_type);\n+\n+    case HIGH:\n+      op = XEXP (op, 0);\n+      return riscv_symbolic_constant_p (op, &symbol_type)\n+\t      && riscv_split_symbol_type (symbol_type)\n+\t      && symbol_type != SYMBOL_PCREL;\n+\n+    default:\n+      return true;\n+    }\n+})\n+\n+(define_predicate \"symbolic_operand\"\n+  (match_code \"const,symbol_ref,label_ref\")\n+{\n+  enum riscv_symbol_type type;\n+  return riscv_symbolic_constant_p (op, &type);\n+})\n+\n+(define_predicate \"absolute_symbolic_operand\"\n+  (match_code \"const,symbol_ref,label_ref\")\n+{\n+  enum riscv_symbol_type type;\n+  return (riscv_symbolic_constant_p (op, &type)\n+\t  && (type == SYMBOL_ABSOLUTE || type == SYMBOL_PCREL));\n+})\n+\n+(define_predicate \"plt_symbolic_operand\"\n+  (match_code \"const,symbol_ref,label_ref\")\n+{\n+  enum riscv_symbol_type type;\n+  return (riscv_symbolic_constant_p (op, &type)\n+\t  && type == SYMBOL_GOT_DISP && !SYMBOL_REF_WEAK (op) && TARGET_PLT);\n+})\n+\n+(define_predicate \"call_insn_operand\"\n+  (ior (match_operand 0 \"absolute_symbolic_operand\")\n+       (match_operand 0 \"plt_symbolic_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"modular_operator\"\n+  (match_code \"plus,minus,mult,ashift\"))\n+\n+(define_predicate \"equality_operator\"\n+  (match_code \"eq,ne\"))\n+\n+(define_predicate \"order_operator\"\n+  (match_code \"eq,ne,lt,ltu,le,leu,ge,geu,gt,gtu\"))\n+\n+(define_predicate \"signed_order_operator\"\n+  (match_code \"eq,ne,lt,le,ge,gt\"))\n+\n+(define_predicate \"fp_native_comparison\"\n+  (match_code \"eq,lt,le,gt,ge\"))\n+\n+(define_predicate \"fp_scc_comparison\"\n+  (match_code \"unordered,ordered,unlt,unge,unle,ungt,ltgt,ne,eq,lt,le,gt,ge\"))\n+\n+(define_predicate \"fp_branch_comparison\"\n+  (match_code \"unordered,ordered,unlt,unge,unle,ungt,uneq,ltgt,ne,eq,lt,le,gt,ge\"))"}, {"sha": "626a6a33f9914c24135911ebaa5048e7190e0d2f", "filename": "gcc/config/riscv/riscv-builtins.c", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-builtins.c?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,287 @@\n+/* Subroutines used for expanding RISC-V builtins.\n+   Copyright (C) 2011-2017 Free Software Foundation, Inc.\n+   Contributed by Andrew Waterman (andrew@sifive.com).\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"gimple-expr.h\"\n+#include \"memmodel.h\"\n+#include \"expmed.h\"\n+#include \"optabs.h\"\n+#include \"recog.h\"\n+#include \"diagnostic-core.h\"\n+#include \"stor-layout.h\"\n+#include \"expr.h\"\n+#include \"langhooks.h\"\n+\n+/* Macros to create an enumeration identifier for a function prototype.  */\n+#define RISCV_FTYPE_NAME1(A, B) RISCV_##A##_FTYPE_##B\n+\n+/* Classifies the prototype of a built-in function.  */\n+enum riscv_function_type {\n+#define DEF_RISCV_FTYPE(NARGS, LIST) RISCV_FTYPE_NAME##NARGS LIST,\n+#include \"config/riscv/riscv-ftypes.def\"\n+#undef DEF_RISCV_FTYPE\n+  RISCV_MAX_FTYPE_MAX\n+};\n+\n+/* Specifies how a built-in function should be converted into rtl.  */\n+enum riscv_builtin_type {\n+  /* The function corresponds directly to an .md pattern.  */\n+  RISCV_BUILTIN_DIRECT,\n+\n+  /* Likewise, but with return type VOID.  */\n+  RISCV_BUILTIN_DIRECT_NO_TARGET\n+};\n+\n+/* Declare an availability predicate for built-in functions.  */\n+#define AVAIL(NAME, COND)\t\t\\\n+ static unsigned int\t\t\t\\\n+ riscv_builtin_avail_##NAME (void)\t\\\n+ {\t\t\t\t\t\\\n+   return (COND);\t\t\t\\\n+ }\n+\n+/* This structure describes a single built-in function.  */\n+struct riscv_builtin_description {\n+  /* The code of the main .md file instruction.  See riscv_builtin_type\n+     for more information.  */\n+  enum insn_code icode;\n+\n+  /* The name of the built-in function.  */\n+  const char *name;\n+\n+  /* Specifies how the function should be expanded.  */\n+  enum riscv_builtin_type builtin_type;\n+\n+  /* The function's prototype.  */\n+  enum riscv_function_type prototype;\n+\n+  /* Whether the function is available.  */\n+  unsigned int (*avail) (void);\n+};\n+\n+AVAIL (hard_float, TARGET_HARD_FLOAT)\n+\n+/* Construct a riscv_builtin_description from the given arguments.\n+\n+   INSN is the name of the associated instruction pattern, without the\n+   leading CODE_FOR_riscv_.\n+\n+   NAME is the name of the function itself, without the leading\n+   \"__builtin_riscv_\".\n+\n+   BUILTIN_TYPE and FUNCTION_TYPE are riscv_builtin_description fields.\n+\n+   AVAIL is the name of the availability predicate, without the leading\n+   riscv_builtin_avail_.  */\n+#define RISCV_BUILTIN(INSN, NAME, BUILTIN_TYPE,\tFUNCTION_TYPE, AVAIL)\t\\\n+  { CODE_FOR_riscv_ ## INSN, \"__builtin_riscv_\" NAME,\t\t\t\\\n+    BUILTIN_TYPE, FUNCTION_TYPE, riscv_builtin_avail_ ## AVAIL }\n+\n+/* Define __builtin_riscv_<INSN>, which is a RISCV_BUILTIN_DIRECT function\n+   mapped to instruction CODE_FOR_riscv_<INSN>,  FUNCTION_TYPE and AVAIL\n+   are as for RISCV_BUILTIN.  */\n+#define DIRECT_BUILTIN(INSN, FUNCTION_TYPE, AVAIL)\t\t\t\\\n+  RISCV_BUILTIN (INSN, #INSN, RISCV_BUILTIN_DIRECT, FUNCTION_TYPE, AVAIL)\n+\n+/* Define __builtin_riscv_<INSN>, which is a RISCV_BUILTIN_DIRECT_NO_TARGET\n+   function mapped to instruction CODE_FOR_riscv_<INSN>,  FUNCTION_TYPE\n+   and AVAIL are as for RISCV_BUILTIN.  */\n+#define DIRECT_NO_TARGET_BUILTIN(INSN, FUNCTION_TYPE, AVAIL)\t\t\\\n+  RISCV_BUILTIN (INSN, #INSN, RISCV_BUILTIN_DIRECT_NO_TARGET,\t\t\\\n+\t\tFUNCTION_TYPE, AVAIL)\n+\n+/* Argument types.  */\n+#define RISCV_ATYPE_VOID void_type_node\n+#define RISCV_ATYPE_USI unsigned_intSI_type_node\n+\n+/* RISCV_FTYPE_ATYPESN takes N RISCV_FTYPES-like type codes and lists\n+   their associated RISCV_ATYPEs.  */\n+#define RISCV_FTYPE_ATYPES1(A, B) \\\n+  RISCV_ATYPE_##A, RISCV_ATYPE_##B\n+\n+static const struct riscv_builtin_description riscv_builtins[] = {\n+  DIRECT_BUILTIN (frflags, RISCV_USI_FTYPE_VOID, hard_float),\n+  DIRECT_NO_TARGET_BUILTIN (fsflags, RISCV_VOID_FTYPE_USI, hard_float)\n+};\n+\n+/* Index I is the function declaration for riscv_builtins[I], or null if the\n+   function isn't defined on this target.  */\n+static GTY(()) tree riscv_builtin_decls[ARRAY_SIZE (riscv_builtins)];\n+\n+/* Get the index I of the function declaration for riscv_builtin_decls[I]\n+   using the instruction code or return null if not defined for the target.  */\n+static GTY(()) int riscv_builtin_decl_index[NUM_INSN_CODES];\n+\n+#define GET_BUILTIN_DECL(CODE) \\\n+  riscv_builtin_decls[riscv_builtin_decl_index[(CODE)]]\n+\n+/* Return the function type associated with function prototype TYPE.  */\n+\n+static tree\n+riscv_build_function_type (enum riscv_function_type type)\n+{\n+  static tree types[(int) RISCV_MAX_FTYPE_MAX];\n+\n+  if (types[(int) type] == NULL_TREE)\n+    switch (type)\n+      {\n+#define DEF_RISCV_FTYPE(NUM, ARGS)\t\t\t\t\t\\\n+  case RISCV_FTYPE_NAME##NUM ARGS:\t\t\t\t\t\\\n+    types[(int) type]\t\t\t\t\t\t\t\\\n+      = build_function_type_list (RISCV_FTYPE_ATYPES##NUM ARGS,\t\t\\\n+\t\t\t\t  NULL_TREE);\t\t\t\t\\\n+    break;\n+#include \"config/riscv/riscv-ftypes.def\"\n+#undef DEF_RISCV_FTYPE\n+      default:\n+\tgcc_unreachable ();\n+      }\n+\n+  return types[(int) type];\n+}\n+\n+/* Implement TARGET_INIT_BUILTINS.  */\n+\n+void\n+riscv_init_builtins (void)\n+{\n+  for (size_t i = 0; i < ARRAY_SIZE (riscv_builtins); i++)\n+    {\n+      const struct riscv_builtin_description *d = &riscv_builtins[i];\n+      if (d->avail ())\n+\t{\n+\t  tree type = riscv_build_function_type (d->prototype);\n+\t  riscv_builtin_decls[i]\n+\t    = add_builtin_function (d->name, type, i, BUILT_IN_MD, NULL, NULL);\n+\t  riscv_builtin_decl_index[d->icode] = i;\n+\t}\n+    }\n+}\n+\n+/* Implement TARGET_BUILTIN_DECL.  */\n+\n+tree\n+riscv_builtin_decl (unsigned int code, bool initialize_p ATTRIBUTE_UNUSED)\n+{\n+  if (code >= ARRAY_SIZE (riscv_builtins))\n+    return error_mark_node;\n+  return riscv_builtin_decls[code];\n+}\n+\n+/* Take argument ARGNO from EXP's argument list and convert it into\n+   an expand operand.  Store the operand in *OP.  */\n+\n+static void\n+riscv_prepare_builtin_arg (struct expand_operand *op, tree exp, unsigned argno)\n+{\n+  tree arg = CALL_EXPR_ARG (exp, argno);\n+  create_input_operand (op, expand_normal (arg), TYPE_MODE (TREE_TYPE (arg)));\n+}\n+\n+/* Expand instruction ICODE as part of a built-in function sequence.\n+   Use the first NOPS elements of OPS as the instruction's operands.\n+   HAS_TARGET_P is true if operand 0 is a target; it is false if the\n+   instruction has no target.\n+\n+   Return the target rtx if HAS_TARGET_P, otherwise return const0_rtx.  */\n+\n+static rtx\n+riscv_expand_builtin_insn (enum insn_code icode, unsigned int n_ops,\n+\t\t\t   struct expand_operand *ops, bool has_target_p)\n+{\n+  if (!maybe_expand_insn (icode, n_ops, ops))\n+    {\n+      error (\"invalid argument to built-in function\");\n+      return has_target_p ? gen_reg_rtx (ops[0].mode) : const0_rtx;\n+    }\n+\n+  return has_target_p ? ops[0].value : const0_rtx;\n+}\n+\n+/* Expand a RISCV_BUILTIN_DIRECT or RISCV_BUILTIN_DIRECT_NO_TARGET function;\n+   HAS_TARGET_P says which.  EXP is the CALL_EXPR that calls the function\n+   and ICODE is the code of the associated .md pattern.  TARGET, if nonnull,\n+   suggests a good place to put the result.  */\n+\n+static rtx\n+riscv_expand_builtin_direct (enum insn_code icode, rtx target, tree exp,\n+\t\t\t     bool has_target_p)\n+{\n+  struct expand_operand ops[MAX_RECOG_OPERANDS];\n+\n+  /* Map any target to operand 0.  */\n+  int opno = 0;\n+  if (has_target_p)\n+    create_output_operand (&ops[opno++], target, TYPE_MODE (TREE_TYPE (exp)));\n+\n+  /* Map the arguments to the other operands.  */\n+  gcc_assert (opno + call_expr_nargs (exp)\n+\t      == insn_data[icode].n_generator_args);\n+  for (int argno = 0; argno < call_expr_nargs (exp); argno++)\n+    riscv_prepare_builtin_arg (&ops[opno++], exp, argno);\n+\n+  return riscv_expand_builtin_insn (icode, opno, ops, has_target_p);\n+}\n+\n+/* Implement TARGET_EXPAND_BUILTIN.  */\n+\n+rtx\n+riscv_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n+\t\t      machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t      int ignore ATTRIBUTE_UNUSED)\n+{\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n+  unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n+  const struct riscv_builtin_description *d = &riscv_builtins[fcode];\n+\n+  switch (d->builtin_type)\n+    {\n+    case RISCV_BUILTIN_DIRECT:\n+      return riscv_expand_builtin_direct (d->icode, target, exp, true);\n+\n+    case RISCV_BUILTIN_DIRECT_NO_TARGET:\n+      return riscv_expand_builtin_direct (d->icode, target, exp, false);\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Implement TARGET_ATOMIC_ASSIGN_EXPAND_FENV.  */\n+\n+void\n+riscv_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n+{\n+  if (!TARGET_HARD_FLOAT)\n+    return;\n+\n+  tree frflags = GET_BUILTIN_DECL (CODE_FOR_riscv_frflags);\n+  tree fsflags = GET_BUILTIN_DECL (CODE_FOR_riscv_fsflags);\n+  tree old_flags = create_tmp_var_raw (RISCV_ATYPE_USI);\n+\n+  *hold = build2 (MODIFY_EXPR, RISCV_ATYPE_USI, old_flags,\n+\t\t  build_call_expr (frflags, 0));\n+  *clear = build_call_expr (fsflags, 1, old_flags);\n+  *update = NULL_TREE;\n+}"}, {"sha": "64e7cf877afe78d10600f4a94a26d8e715d17082", "filename": "gcc/config/riscv/riscv-c.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-c.c?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,92 @@\n+/* RISC-V-specific code for C family languages.\n+   Copyright (C) 2011-2017 Free Software Foundation, Inc.\n+   Contributed by Andrew Waterman (andrew@sifive.com).\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"c-family/c-common.h\"\n+#include \"cpplib.h\"\n+\n+#define builtin_define(TXT) cpp_define (pfile, TXT)\n+\n+/* Implement TARGET_CPU_CPP_BUILTINS.  */\n+\n+void\n+riscv_cpu_cpp_builtins (cpp_reader *pfile)\n+{\n+  builtin_define (\"__riscv\");\n+  \n+  if (TARGET_RVC)\n+    builtin_define (\"__riscv_compressed\");\n+  \n+  if (TARGET_ATOMIC)\n+    builtin_define (\"__riscv_atomic\");\n+  \n+  if (TARGET_MUL)\n+    builtin_define (\"__riscv_mul\");\n+  if (TARGET_DIV)\n+    builtin_define (\"__riscv_div\");\n+  if (TARGET_DIV && TARGET_MUL)\n+    builtin_define (\"__riscv_muldiv\");\n+  \n+  builtin_define_with_int_value (\"__riscv_xlen\", UNITS_PER_WORD * 8);\n+  if (TARGET_HARD_FLOAT)\n+    builtin_define_with_int_value (\"__riscv_flen\", UNITS_PER_FP_REG * 8);\n+  \n+  if (TARGET_HARD_FLOAT && TARGET_FDIV)\n+    {\n+      builtin_define (\"__riscv_fdiv\");\n+      builtin_define (\"__riscv_fsqrt\");\n+    }\n+  \n+  switch (riscv_abi)\n+    {\n+    case ABI_ILP32:\n+    case ABI_LP64:\n+      builtin_define (\"__riscv_float_abi_soft\");\n+      break;\n+  \n+    case ABI_ILP32F:\n+    case ABI_LP64F:\n+      builtin_define (\"__riscv_float_abi_single\");\n+      break;\n+  \n+    case ABI_ILP32D:\n+    case ABI_LP64D:\n+      builtin_define (\"__riscv_float_abi_double\");\n+      break;\n+    }\n+  \n+  switch (riscv_cmodel)\n+    {\n+    case CM_MEDLOW:\n+      builtin_define (\"__riscv_cmodel_medlow\");\n+      break;\n+  \n+    case CM_MEDANY:\n+      builtin_define (\"__riscv_cmodel_medany\");\n+      break;\n+  \n+    case CM_PIC:\n+      builtin_define (\"__riscv_cmodel_pic\");\n+      break;\n+    }\n+}"}, {"sha": "eb69148368fa2a0e7b8a987e1b113b9a39b5bf94", "filename": "gcc/config/riscv/riscv-ftypes.def", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv-ftypes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv-ftypes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-ftypes.def?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,30 @@\n+/* Definitions of prototypes for RISC-V built-in functions.  -*- C -*-\n+   Copyright (C) 2011-2017 Free Software Foundation, Inc.\n+   Contributed by Andrew Waterman (andrew@sifive.com).\n+   Based on MIPS target for GNU compiler.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Invoke DEF_RISCV_FTYPE (NARGS, LIST) for each prototype used by\n+   RISCV built-in functions, where:\n+\n+      NARGS is the number of arguments.\n+      LIST contains the return-type code followed by the codes for each\n+        argument type.  */\n+\n+DEF_RISCV_FTYPE (1, (USI, VOID))\n+DEF_RISCV_FTYPE (1, (VOID, USI))"}, {"sha": "5c65667da68e6d8853191eae1b1ec72f1a88a33b", "filename": "gcc/config/riscv/riscv-modes.def", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-modes.def?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,22 @@\n+/* Extra machine modes for RISC-V target.\n+   Copyright (C) 2011-2017 Free Software Foundation, Inc.\n+   Contributed by Andrew Waterman (andrew@sifive.com).\n+   Based on MIPS target for GNU compiler.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+FLOAT_MODE (TF, 16, ieee_quad_format);"}, {"sha": "2b19233379c05c2a71b0e4d98c9e98ce3bf1d502", "filename": "gcc/config/riscv/riscv-opts.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-opts.h?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,41 @@\n+/* Definition of RISC-V target for GNU compiler.\n+   Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+   Contributed by Andrew Waterman (andrew@sifive.com).\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_RISCV_OPTS_H\n+#define GCC_RISCV_OPTS_H\n+\n+enum riscv_abi_type {\n+  ABI_ILP32,\n+  ABI_ILP32F,\n+  ABI_ILP32D,\n+  ABI_LP64,\n+  ABI_LP64F,\n+  ABI_LP64D\n+};\n+extern enum riscv_abi_type riscv_abi;\n+\n+enum riscv_code_model {\n+  CM_MEDLOW,\n+  CM_MEDANY,\n+  CM_PIC\n+};\n+extern enum riscv_code_model riscv_cmodel;\n+\n+#endif /* ! GCC_RISCV_OPTS_H */"}, {"sha": "de7023f88c5d08baafc1628906f7b84114e6f9be", "filename": "gcc/config/riscv/riscv-protos.h", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,83 @@\n+/* Definition of RISC-V target for GNU compiler.\n+   Copyright (C) 2011-2017 Free Software Foundation, Inc.\n+   Contributed by Andrew Waterman (andrew@sifive.com).\n+   Based on MIPS target for GNU compiler.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_RISCV_PROTOS_H\n+#define GCC_RISCV_PROTOS_H\n+\n+/* Symbol types we understand.  The order of this list must match that of\n+   the unspec enum in riscv.md, subsequent to UNSPEC_ADDRESS_FIRST.  */\n+enum riscv_symbol_type {\n+  SYMBOL_ABSOLUTE,\n+  SYMBOL_PCREL,\n+  SYMBOL_GOT_DISP,\n+  SYMBOL_TLS,\n+  SYMBOL_TLS_LE,\n+  SYMBOL_TLS_IE,\n+  SYMBOL_TLS_GD\n+};\n+#define NUM_SYMBOL_TYPES (SYMBOL_TLS_GD + 1)\n+\n+/* Routines implemented in riscv.c.  */\n+extern enum riscv_symbol_type riscv_classify_symbolic_expression (rtx);\n+extern bool riscv_symbolic_constant_p (rtx, enum riscv_symbol_type *);\n+extern int riscv_regno_mode_ok_for_base_p (int, enum machine_mode, bool);\n+extern bool riscv_hard_regno_mode_ok_p (unsigned int, enum machine_mode);\n+extern int riscv_address_insns (rtx, enum machine_mode, bool);\n+extern int riscv_const_insns (rtx);\n+extern int riscv_split_const_insns (rtx);\n+extern int riscv_load_store_insns (rtx, rtx_insn *);\n+extern rtx riscv_emit_move (rtx, rtx);\n+extern bool riscv_split_symbol (rtx, rtx, enum machine_mode, rtx *);\n+extern bool riscv_split_symbol_type (enum riscv_symbol_type);\n+extern rtx riscv_unspec_address (rtx, enum riscv_symbol_type);\n+extern void riscv_move_integer (rtx, rtx, HOST_WIDE_INT);\n+extern bool riscv_legitimize_move (enum machine_mode, rtx, rtx);\n+extern rtx riscv_subword (rtx, bool);\n+extern bool riscv_split_64bit_move_p (rtx, rtx);\n+extern void riscv_split_doubleword_move (rtx, rtx);\n+extern const char *riscv_output_move (rtx, rtx);\n+extern const char *riscv_output_gpr_save (unsigned);\n+#ifdef RTX_CODE\n+extern void riscv_expand_int_scc (rtx, enum rtx_code, rtx, rtx);\n+extern void riscv_expand_float_scc (rtx, enum rtx_code, rtx, rtx);\n+extern void riscv_expand_conditional_branch (rtx, enum rtx_code, rtx, rtx);\n+#endif\n+extern rtx riscv_legitimize_call_address (rtx);\n+extern void riscv_set_return_address (rtx, rtx);\n+extern bool riscv_expand_block_move (rtx, rtx, rtx);\n+extern rtx riscv_return_addr (int, rtx);\n+extern HOST_WIDE_INT riscv_initial_elimination_offset (int, int);\n+extern void riscv_expand_prologue (void);\n+extern void riscv_expand_epilogue (bool);\n+extern bool riscv_can_use_return_insn (void);\n+extern rtx riscv_function_value (const_tree, const_tree, enum machine_mode);\n+extern unsigned int riscv_hard_regno_nregs (int, enum machine_mode);\n+\n+/* Routines implemented in riscv-c.c.  */\n+void riscv_cpu_cpp_builtins (cpp_reader *);\n+\n+/* Routines implemented in riscv-builtins.c.  */\n+extern void riscv_atomic_assign_expand_fenv (tree *, tree *, tree *);\n+extern rtx riscv_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n+extern tree riscv_builtin_decl (unsigned int, bool);\n+extern void riscv_init_builtins (void);\n+\n+#endif /* ! GCC_RISCV_PROTOS_H */"}, {"sha": "834651f4214a2b6e2cda5d7f0ab61028cfefbc6f", "filename": "gcc/config/riscv/riscv.c", "status": "added", "additions": 4138, "deletions": 0, "changes": 4138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac"}, {"sha": "8d4c75e677073542637567b01b8c90bdf963e1bf", "filename": "gcc/config/riscv/riscv.h", "status": "added", "additions": 906, "deletions": 0, "changes": 906, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,906 @@\n+/* Definition of RISC-V target for GNU compiler.\n+   Copyright (C) 2011-2017 Free Software Foundation, Inc.\n+   Contributed by Andrew Waterman (andrew@sifive.com).\n+   Based on MIPS target for GNU compiler.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_RISCV_H\n+#define GCC_RISCV_H\n+\n+#include \"config/riscv/riscv-opts.h\"\n+\n+/* Target CPU builtins.  */\n+#define TARGET_CPU_CPP_BUILTINS() riscv_cpu_cpp_builtins (pfile)\n+\n+/* Default target_flags if no switches are specified  */\n+\n+#ifndef TARGET_DEFAULT\n+#define TARGET_DEFAULT 0\n+#endif\n+\n+#ifndef RISCV_TUNE_STRING_DEFAULT\n+#define RISCV_TUNE_STRING_DEFAULT \"rocket\"\n+#endif\n+\n+/* Support for a compile-time default CPU, et cetera.  The rules are:\n+   --with-arch is ignored if -march is specified.\n+   --with-abi is ignored if -mabi is specified.\n+   --with-tune is ignored if -mtune is specified.  */\n+#define OPTION_DEFAULT_SPECS \\\n+  {\"tune\", \"%{!mtune=*:-mtune=%(VALUE)}\" }, \\\n+  {\"arch\", \"%{!march=*:-march=%(VALUE)}\" }, \\\n+  {\"abi\", \"%{!mabi=*:-mabi=%(VALUE)}\" }, \\\n+\n+#ifdef IN_LIBGCC2\n+#undef TARGET_64BIT\n+/* Make this compile time constant for libgcc2 */\n+#define TARGET_64BIT           (__riscv_xlen == 64)\n+#endif /* IN_LIBGCC2 */\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \"\\\n+%(subtarget_asm_debugging_spec) \\\n+%{\" FPIE_OR_FPIC_SPEC \":-fpic} \\\n+%{march=*} \\\n+%{mabi=*} \\\n+%(subtarget_asm_spec)\"\n+\n+#define TARGET_DEFAULT_CMODEL CM_MEDLOW\n+\n+#define LOCAL_LABEL_PREFIX\t\".\"\n+#define USER_LABEL_PREFIX\t\"\"\n+\n+/* Offsets recorded in opcodes are a multiple of this alignment factor.\n+   The default for this in 64-bit mode is 8, which causes problems with\n+   SFmode register saves.  */\n+#define DWARF_CIE_DATA_ALIGNMENT -4\n+\n+/* The mapping from gcc register number to DWARF 2 CFA column number.  */\n+#define DWARF_FRAME_REGNUM(REGNO) \\\n+  (GP_REG_P (REGNO) || FP_REG_P (REGNO) ? REGNO : INVALID_REGNUM)\n+\n+/* The DWARF 2 CFA column which tracks the return address.  */\n+#define DWARF_FRAME_RETURN_COLUMN RETURN_ADDR_REGNUM\n+#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (VOIDmode, RETURN_ADDR_REGNUM)\n+\n+/* Describe how we implement __builtin_eh_return.  */\n+#define EH_RETURN_DATA_REGNO(N) \\\n+  ((N) < 4 ? (N) + GP_ARG_FIRST : INVALID_REGNUM)\n+\n+#define EH_RETURN_STACKADJ_RTX  gen_rtx_REG (Pmode, GP_ARG_FIRST + 4)\n+\n+/* Target machine storage layout */\n+\n+#define BITS_BIG_ENDIAN 0\n+#define BYTES_BIG_ENDIAN 0\n+#define WORDS_BIG_ENDIAN 0\n+\n+#define MAX_BITS_PER_WORD 64\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD (TARGET_64BIT ? 8 : 4)\n+#ifndef IN_LIBGCC2\n+#define MIN_UNITS_PER_WORD 4\n+#endif\n+\n+/* The `Q' extension is not yet supported.  */\n+#define UNITS_PER_FP_REG (TARGET_DOUBLE_FLOAT ? 8 : 4)\n+\n+/* The largest type that can be passed in floating-point registers.  */\n+#define UNITS_PER_FP_ARG\t\t\t\t\t\\\n+  (riscv_abi == ABI_ILP32 || riscv_abi == ABI_LP64 ? 0 :\t\\\n+   riscv_abi == ABI_ILP32F || riscv_abi == ABI_LP64F ? 4 : 8)\t\\\n+\n+/* Set the sizes of the core types.  */\n+#define SHORT_TYPE_SIZE 16\n+#define INT_TYPE_SIZE 32\n+#define LONG_LONG_TYPE_SIZE 64\n+#define POINTER_SIZE (riscv_abi >= ABI_LP64 ? 64 : 32)\n+#define LONG_TYPE_SIZE POINTER_SIZE\n+\n+#define FLOAT_TYPE_SIZE 32\n+#define DOUBLE_TYPE_SIZE 64\n+#define LONG_DOUBLE_TYPE_SIZE 128\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY BITS_PER_WORD\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY (TARGET_RVC ? 16 : 32)\n+\n+/* There is no point aligning anything to a rounder boundary than this.  */\n+#define BIGGEST_ALIGNMENT 128\n+\n+/* The user-level ISA permits misaligned accesses, but they may execute\n+   extremely slowly and non-atomically.  Some privileged architectures\n+   do not permit them at all.  It is best to enforce strict alignment.  */\n+#define STRICT_ALIGNMENT 1\n+\n+/* Define this if you wish to imitate the way many other C compilers\n+   handle alignment of bitfields and the structures that contain\n+   them.\n+\n+   The behavior is that the type written for a bit-field (`int',\n+   `short', or other integer type) imposes an alignment for the\n+   entire structure, as if the structure really did contain an\n+   ordinary field of that type.  In addition, the bit-field is placed\n+   within the structure so that it would fit within such a field,\n+   not crossing a boundary for it.\n+\n+   Thus, on most machines, a bit-field whose type is written as `int'\n+   would not cross a four-byte boundary, and would force four-byte\n+   alignment for the whole structure.  (The alignment used may not\n+   be four bytes; it is controlled by the other alignment\n+   parameters.)\n+\n+   If the macro is defined, its definition should be a C expression;\n+   a nonzero value for the expression enables this behavior.  */\n+\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* If defined, a C expression to compute the alignment given to a\n+   constant that is being placed in memory.  CONSTANT is the constant\n+   and ALIGN is the alignment that the object would ordinarily have.\n+   The value of this macro is used instead of that alignment to align\n+   the object.\n+\n+   If this macro is not defined, then ALIGN is used.\n+\n+   The typical use of this macro is to increase alignment for string\n+   constants to be word aligned so that `strcpy' calls that copy\n+   constants can be done inline.  */\n+\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)\t\t\t\t\t\\\n+  ((TREE_CODE (EXP) == STRING_CST  || TREE_CODE (EXP) == CONSTRUCTOR)\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* If defined, a C expression to compute the alignment for a static\n+   variable.  TYPE is the data type, and ALIGN is the alignment that\n+   the object would ordinarily have.  The value of this macro is used\n+   instead of that alignment to align the object.\n+\n+   If this macro is not defined, then ALIGN is used.\n+\n+   One use of this macro is to increase alignment of medium-size\n+   data to make it all fit in fewer cache lines.  Another is to\n+   cause character arrays to be word-aligned so that `strcpy' calls\n+   that copy constants to character arrays can be done inline.  */\n+\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\t\t\t\\\n+  ((((ALIGN) < BITS_PER_WORD)\t\t\t\t\t\t\\\n+    && (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\t\t\t\\\n+\t|| TREE_CODE (TYPE) == UNION_TYPE\t\t\t\t\\\n+\t|| TREE_CODE (TYPE) == RECORD_TYPE)) ? BITS_PER_WORD : (ALIGN))\n+\n+/* We need this for the same reason as DATA_ALIGNMENT, namely to cause\n+   character arrays to be word-aligned so that `strcpy' calls that copy\n+   constants to character arrays can be done inline, and 'strcmp' can be\n+   optimised to use word loads. */\n+#define LOCAL_ALIGNMENT(TYPE, ALIGN) \\\n+  DATA_ALIGNMENT (TYPE, ALIGN)\n+\n+/* Define if operations between registers always perform the operation\n+   on the full register even if a narrower mode is specified.  */\n+#define WORD_REGISTER_OPERATIONS 1\n+\n+/* When in 64-bit mode, move insns will sign extend SImode and CCmode\n+   moves.  All other references are zero extended.  */\n+#define LOAD_EXTEND_OP(MODE) \\\n+  (TARGET_64BIT && (MODE) == SImode ? SIGN_EXTEND : ZERO_EXTEND)\n+\n+/* Define this macro if it is advisable to hold scalars in registers\n+   in a wider mode than that declared by the program.  In such cases,\n+   the value is constrained to be within the bounds of the declared\n+   type, but kept valid in the wider mode.  The signedness of the\n+   extension may differ from that of the type.  */\n+\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\t\\\n+    {\t\t\t\t\t\t\\\n+      if ((MODE) == SImode)\t\t\t\\\n+\t(UNSIGNEDP) = 0;\t\t\t\\\n+      (MODE) = word_mode;\t\t\t\\\n+    }\n+\n+/* Pmode is always the same as ptr_mode, but not always the same as word_mode.\n+   Extensions of pointers to word_mode must be signed.  */\n+#define POINTERS_EXTEND_UNSIGNED false\n+\n+/* When floating-point registers are wider than integer ones, moves between\n+   them must go through memory.  */\n+#define SECONDARY_MEMORY_NEEDED(CLASS1,CLASS2,MODE)\t\\\n+  (GET_MODE_SIZE (MODE) > UNITS_PER_WORD\t\t\\\n+   && ((CLASS1) == FP_REGS) != ((CLASS2) == FP_REGS))\n+\n+/* Define if loading short immediate values into registers sign extends.  */\n+#define SHORT_IMMEDIATES_SIGN_EXTEND 1\n+\n+/* Standard register usage.  */\n+\n+/* Number of hardware registers.  We have:\n+\n+   - 32 integer registers\n+   - 32 floating point registers\n+   - 2 fake registers:\n+\t- ARG_POINTER_REGNUM\n+\t- FRAME_POINTER_REGNUM */\n+\n+#define FIRST_PSEUDO_REGISTER 66\n+\n+/* x0, sp, gp, and tp are fixed.  */\n+\n+#define FIXED_REGISTERS\t\t\t\t\t\t\t\\\n+{ /* General registers.  */\t\t\t\t\t\t\\\n+  1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  /* Floating-point registers.  */\t\t\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  /* Others.  */\t\t\t\t\t\t\t\\\n+  1, 1\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* a0-a7, t0-a6, fa0-fa7, and ft0-ft11 are volatile across calls.\n+   The call RTLs themselves clobber ra.  */\n+\n+#define CALL_USED_REGISTERS\t\t\t\t\t\t\\\n+{ /* General registers.  */\t\t\t\t\t\t\\\n+  1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,\t\t\t\\\n+  /* Floating-point registers.  */\t\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,\t\t\t\\\n+  /* Others.  */\t\t\t\t\t\t\t\\\n+  1, 1\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Internal macros to classify an ISA register's type.  */\n+\n+#define GP_REG_FIRST 0\n+#define GP_REG_LAST  31\n+#define GP_REG_NUM   (GP_REG_LAST - GP_REG_FIRST + 1)\n+\n+#define FP_REG_FIRST 32\n+#define FP_REG_LAST  63\n+#define FP_REG_NUM   (FP_REG_LAST - FP_REG_FIRST + 1)\n+\n+/* The DWARF 2 CFA column which tracks the return address from a\n+   signal handler context.  This means that to maintain backwards\n+   compatibility, no hard register can be assigned this column if it\n+   would need to be handled by the DWARF unwinder.  */\n+#define DWARF_ALT_FRAME_RETURN_COLUMN 64\n+\n+#define GP_REG_P(REGNO)\t\\\n+  ((unsigned int) ((int) (REGNO) - GP_REG_FIRST) < GP_REG_NUM)\n+#define FP_REG_P(REGNO)  \\\n+  ((unsigned int) ((int) (REGNO) - FP_REG_FIRST) < FP_REG_NUM)\n+\n+#define FP_REG_RTX_P(X) (REG_P (X) && FP_REG_P (REGNO (X)))\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE) riscv_hard_regno_nregs (REGNO, MODE)\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n+  riscv_hard_regno_mode_ok_p (REGNO, MODE)\n+\n+/* Don't allow floating-point modes to be tied, since type punning of\n+   single-precision and double-precision is implementation defined.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\\\n+  ((MODE1) == (MODE2)\t\t\t\t\t\\\n+   || !(GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\t\\\n+\t&& GET_MODE_CLASS (MODE2) == MODE_FLOAT))\n+\n+/* Use s0 as the frame pointer if it is so requested.  */\n+#define HARD_FRAME_POINTER_REGNUM 8\n+#define STACK_POINTER_REGNUM 2\n+#define THREAD_POINTER_REGNUM 4\n+\n+/* These two registers don't really exist: they get eliminated to either\n+   the stack or hard frame pointer.  */\n+#define ARG_POINTER_REGNUM 64\n+#define FRAME_POINTER_REGNUM 65\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM (GP_TEMP_FIRST + 2)\n+\n+/* Registers used as temporaries in prologue/epilogue code.\n+\n+   The prologue registers mustn't conflict with any\n+   incoming arguments, the static chain pointer, or the frame pointer.\n+   The epilogue temporary mustn't conflict with the return registers,\n+   the frame pointer, the EH stack adjustment, or the EH data registers. */\n+\n+#define RISCV_PROLOGUE_TEMP_REGNUM (GP_TEMP_FIRST + 1)\n+#define RISCV_PROLOGUE_TEMP(MODE) gen_rtx_REG (MODE, RISCV_PROLOGUE_TEMP_REGNUM)\n+\n+#define MCOUNT_NAME \"_mcount\"\n+\n+#define NO_PROFILE_COUNTERS 1\n+\n+/* Emit rtl for profiling.  Output assembler code to FILE\n+   to call \"_mcount\" for profiling a function entry.  */\n+#define PROFILE_HOOK(LABEL)\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    rtx fun, ra;\t\t\t\t\t\t\t\\\n+    ra = get_hard_reg_initial_val (Pmode, RETURN_ADDR_REGNUM);\t\t\\\n+    fun = gen_rtx_SYMBOL_REF (Pmode, MCOUNT_NAME);\t\t\t\\\n+    emit_library_call (fun, LCT_NORMAL, VOIDmode, 1, ra, Pmode);\t\\\n+  }\n+\n+/* All the work done in PROFILE_HOOK, but still required.  */\n+#define FUNCTION_PROFILER(STREAM, LABELNO) do { } while (0)\n+\n+/* Define this macro if it is as good or better to call a constant\n+   function address than to call an address kept in a register.  */\n+#define NO_FUNCTION_CSE 1\n+\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+\n+enum reg_class\n+{\n+  NO_REGS,\t\t\t/* no registers in set */\n+  SIBCALL_REGS,\t\t\t/* registers used by indirect sibcalls */\n+  JALR_REGS,\t\t\t/* registers used by indirect calls */\n+  GR_REGS,\t\t\t/* integer registers */\n+  FP_REGS,\t\t\t/* floating-point registers */\n+  FRAME_REGS,\t\t\t/* arg pointer and frame pointer */\n+  ALL_REGS,\t\t\t/* all registers */\n+  LIM_REG_CLASSES\t\t/* max value + 1 */\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+#define GENERAL_REGS GR_REGS\n+\n+/* An initializer containing the names of the register classes as C\n+   string constants.  These names are used in writing some of the\n+   debugging dumps.  */\n+\n+#define REG_CLASS_NAMES\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  \"NO_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"SIBCALL_REGS\",\t\t\t\t\t\t\t\\\n+  \"JALR_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"GR_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"FP_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"FRAME_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"ALL_REGS\"\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* An initializer containing the contents of the register classes,\n+   as integers which are bit masks.  The Nth integer specifies the\n+   contents of class N.  The way the integer MASK is interpreted is\n+   that register R is in the class if `MASK & (1 << R)' is 1.\n+\n+   When the machine has more than 32 registers, an integer does not\n+   suffice.  Then the integers are replaced by sub-initializers,\n+   braced groupings containing several integers.  Each\n+   sub-initializer must be suitable as an initializer for the type\n+   `HARD_REG_SET' which is defined in `hard-reg-set.h'.  */\n+\n+#define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000000 },\t/* NO_REGS */\t\t\\\n+  { 0xf00000c0, 0x00000000, 0x00000000 },\t/* SIBCALL_REGS */\t\\\n+  { 0xffffffc0, 0x00000000, 0x00000000 },\t/* JALR_REGS */\t\t\\\n+  { 0xffffffff, 0x00000000, 0x00000000 },\t/* GR_REGS */\t\t\\\n+  { 0x00000000, 0xffffffff, 0x00000000 },\t/* FP_REGS */\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000003 },\t/* FRAME_REGS */\t\\\n+  { 0xffffffff, 0xffffffff, 0x00000003 }\t/* ALL_REGS */\t\t\\\n+}\n+\n+/* A C expression whose value is a register class containing hard\n+   register REGNO.  In general there is more that one such class;\n+   choose a class which is \"minimal\", meaning that no smaller class\n+   also contains the register.  */\n+\n+#define REGNO_REG_CLASS(REGNO) riscv_regno_to_class[ (REGNO) ]\n+\n+/* A macro whose definition is the name of the class to which a\n+   valid base register must belong.  A base register is one used in\n+   an address which is the register value plus a displacement.  */\n+\n+#define BASE_REG_CLASS GR_REGS\n+\n+/* A macro whose definition is the name of the class to which a\n+   valid index register must belong.  An index register is one used\n+   in an address where its value is either multiplied by a scale\n+   factor or added to another register (as well as added to a\n+   displacement).  */\n+\n+#define INDEX_REG_CLASS NO_REGS\n+\n+/* We generally want to put call-clobbered registers ahead of\n+   call-saved ones.  (IRA expects this.)  */\n+\n+#define REG_ALLOC_ORDER\t\t\t\t\t\t\t\\\n+{ \\\n+  /* Call-clobbered GPRs.  */\t\t\t\t\t\t\\\n+  15, 14, 13, 12, 11, 10, 16, 17, 6, 28, 29, 30, 31, 5, 7, 1,\t\t\\\n+  /* Call-saved GPRs.  */\t\t\t\t\t\t\\\n+  8, 9, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\t       \t\t\t\\\n+  /* GPRs that can never be exposed to the register allocator.  */\t\\\n+  0, 2, 3, 4,\t\t\t\t\t\t\t\t\\\n+  /* Call-clobbered FPRs.  */\t\t\t\t\t\t\\\n+  47, 46, 45, 44, 43, 42, 32, 33, 34, 35, 36, 37, 38, 39, 48, 49,\t\\\n+  60, 61, 62, 63,\t\t\t\t\t\t\t\\\n+  /* Call-saved FPRs.  */\t\t\t\t\t\t\\\n+  40, 41, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\t\t\t\\\n+  /* None of the remaining classes have defined call-saved\t\t\\\n+     registers.  */\t\t\t\t\t\t\t\\\n+  64, 65\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* True if VALUE is a signed 12-bit number.  */\n+\n+#define SMALL_OPERAND(VALUE) \\\n+  ((unsigned HOST_WIDE_INT) (VALUE) + IMM_REACH/2 < IMM_REACH)\n+\n+/* True if VALUE can be loaded into a register using LUI.  */\n+\n+#define LUI_OPERAND(VALUE)\t\t\t\t\t\t\\\n+  (((VALUE) | ((1UL<<31) - IMM_REACH)) == ((1UL<<31) - IMM_REACH)\t\\\n+   || ((VALUE) | ((1UL<<31) - IMM_REACH)) + IMM_REACH == 0)\n+\n+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\\n+  reg_classes_intersect_p (FP_REGS, CLASS)\n+\n+/* Stack layout; function entry, exit and calling.  */\n+\n+#define STACK_GROWS_DOWNWARD 1\n+\n+#define FRAME_GROWS_DOWNWARD 1\n+\n+#define STARTING_FRAME_OFFSET 0\n+\n+#define RETURN_ADDR_RTX riscv_return_addr\n+\n+#define ELIMINABLE_REGS\t\t\t\t\t\t\t\\\n+{{ ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},\t\t\t\t\\\n+ { ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM},\t\t\t\\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\t\t\\\n+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\t\t\t\t\\\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  (OFFSET) = riscv_initial_elimination_offset (FROM, TO)\n+\n+/* Allocate stack space for arguments at the beginning of each function.  */\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+/* The argument pointer always points to the first argument.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+#define REG_PARM_STACK_SPACE(FNDECL) 0\n+\n+/* Define this if it is the responsibility of the caller to\n+   allocate the area reserved for arguments passed in registers.\n+   If `ACCUMULATE_OUTGOING_ARGS' is also defined, the only effect\n+   of this macro is to determine whether the space is included in\n+   `crtl->outgoing_args_size'.  */\n+#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1\n+\n+#define STACK_BOUNDARY 128\n+\f\n+/* Symbolic macros for the registers used to return integer and floating\n+   point values.  */\n+\n+#define GP_RETURN GP_ARG_FIRST\n+#define FP_RETURN (UNITS_PER_FP_ARG == 0 ? GP_RETURN : FP_ARG_FIRST)\n+\n+#define MAX_ARGS_IN_REGISTERS 8\n+\n+/* Symbolic macros for the first/last argument registers.  */\n+\n+#define GP_ARG_FIRST (GP_REG_FIRST + 10)\n+#define GP_ARG_LAST  (GP_ARG_FIRST + MAX_ARGS_IN_REGISTERS - 1)\n+#define GP_TEMP_FIRST (GP_REG_FIRST + 5)\n+#define FP_ARG_FIRST (FP_REG_FIRST + 10)\n+#define FP_ARG_LAST  (FP_ARG_FIRST + MAX_ARGS_IN_REGISTERS - 1)\n+\n+#define CALLEE_SAVED_REG_NUMBER(REGNO)\t\t\t\\\n+  ((REGNO) >= 8 && (REGNO) <= 9 ? (REGNO) - 8 :\t\t\\\n+   (REGNO) >= 18 && (REGNO) <= 27 ? (REGNO) - 16 : -1)\n+\n+#define LIBCALL_VALUE(MODE) \\\n+  riscv_function_value (NULL_TREE, NULL_TREE, MODE)\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n+  riscv_function_value (VALTYPE, FUNC, VOIDmode)\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == GP_RETURN || (N) == FP_RETURN)\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   We have no FP argument registers when soft-float.  When FP registers\n+   are 32 bits, we can't directly reference the odd numbered ones.  */\n+\n+/* Accept arguments in a0-a7, and in fa0-fa7 if permitted by the ABI.  */\n+#define FUNCTION_ARG_REGNO_P(N)\t\t\t\t\t\t\\\n+  (IN_RANGE ((N), GP_ARG_FIRST, GP_ARG_LAST)\t\t\t\t\\\n+   || (UNITS_PER_FP_ARG && IN_RANGE ((N), FP_ARG_FIRST, FP_ARG_LAST)))\n+\n+typedef struct {\n+  /* Number of integer registers used so far, up to MAX_ARGS_IN_REGISTERS. */\n+  unsigned int num_gprs;\n+\n+  /* Number of floating-point registers used so far, likewise.  */\n+  unsigned int num_fprs;\n+} CUMULATIVE_ARGS;\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n+  memset (&(CUM), 0, sizeof (CUM))\n+\n+#define EPILOGUE_USES(REGNO)\t((REGNO) == RETURN_ADDR_REGNUM)\n+\n+/* ABI requires 16-byte alignment, even on RV32. */\n+#define RISCV_STACK_ALIGN(LOC) (((LOC) + 15) & -16)\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+\n+/* Trampolines are a block of code followed by two pointers.  */\n+\n+#define TRAMPOLINE_CODE_SIZE 16\n+#define TRAMPOLINE_SIZE\t\t\\\n+  ((Pmode == SImode)\t\t\\\n+   ? TRAMPOLINE_CODE_SIZE\t\\\n+   : (TRAMPOLINE_CODE_SIZE + POINTER_SIZE * 2))\n+#define TRAMPOLINE_ALIGNMENT POINTER_SIZE\n+\n+/* Addressing modes, and classification of registers for them.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) 0\n+#define REGNO_MODE_OK_FOR_BASE_P(REGNO, MODE) \\\n+  riscv_regno_mode_ok_for_base_p (REGNO, MODE, 1)\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects them all.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Some source files that are used after register allocation\n+   need to be strict.  */\n+\n+#ifndef REG_OK_STRICT\n+#define REG_MODE_OK_FOR_BASE_P(X, MODE) \\\n+  riscv_regno_mode_ok_for_base_p (REGNO (X), MODE, 0)\n+#else\n+#define REG_MODE_OK_FOR_BASE_P(X, MODE) \\\n+  riscv_regno_mode_ok_for_base_p (REGNO (X), MODE, 1)\n+#endif\n+\n+#define REG_OK_FOR_INDEX_P(X) 0\n+\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+#define CONSTANT_ADDRESS_P(X) \\\n+  (CONSTANT_P (X) && memory_address_p (SImode, X))\n+\n+/* This handles the magic '..CURRENT_FUNCTION' symbol, which means\n+   'the start of the function that this code is output in'.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)  \\\n+  if (strcmp (NAME, \"..CURRENT_FUNCTION\") == 0)\t\t\t\t\\\n+    asm_fprintf ((FILE), \"%U%s\",\t\t\t\t\t\\\n+\t\t XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    asm_fprintf ((FILE), \"%U%s\", (NAME))\n+\n+#define JUMP_TABLES_IN_TEXT_SECTION 0\n+#define CASE_VECTOR_MODE SImode\n+#define CASE_VECTOR_PC_RELATIVE (riscv_cmodel != CM_MEDLOW)\n+\n+/* The load-address macro is used for PC-relative addressing of symbols\n+   that bind locally.  Don't use it for symbols that should be addressed\n+   via the GOT.  Also, avoid it for CM_MEDLOW, where LUI addressing\n+   currently results in more opportunities for linker relaxation.  */\n+#define USE_LOAD_ADDRESS_MACRO(sym)\t\t\t\t\t\\\n+  (!TARGET_EXPLICIT_RELOCS &&\t\t\t\t\t\t\\\n+   ((flag_pic\t\t\t\t\t\t\t\t\\\n+     && ((SYMBOL_REF_P (sym) && SYMBOL_REF_LOCAL_P (sym))\t\t\\\n+\t || ((GET_CODE (sym) == CONST)\t\t\t\t\t\\\n+\t     && SYMBOL_REF_P (XEXP (XEXP (sym, 0),0))\t\t\t\\\n+\t     && SYMBOL_REF_LOCAL_P (XEXP (XEXP (sym, 0),0)))))\t\t\\\n+     || riscv_cmodel == CM_MEDANY))\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 0\n+\n+#define MOVE_MAX UNITS_PER_WORD\n+#define MAX_MOVE_MAX 8\n+\n+#define SLOW_BYTE_ACCESS 0\n+\n+#define SHIFT_COUNT_TRUNCATED 1\n+\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+\n+#define Pmode word_mode\n+\n+/* Give call MEMs SImode since it is the \"most permissive\" mode\n+   for both 32-bit and 64-bit targets.  */\n+\n+#define FUNCTION_MODE SImode\n+\n+/* A C expression for the cost of a branch instruction.  A value of 2\n+   seems to minimize code size.  */\n+\n+#define BRANCH_COST(speed_p, predictable_p) \\\n+  ((!(speed_p) || (predictable_p)) ? 2 : riscv_branch_cost)\n+\n+#define LOGICAL_OP_NON_SHORT_CIRCUIT 0\n+\n+/* Control the assembler format that we output.  */\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#ifndef ASM_APP_ON\n+#define ASM_APP_ON \" #APP\\n\"\n+#endif\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#ifndef ASM_APP_OFF\n+#define ASM_APP_OFF \" #NO_APP\\n\"\n+#endif\n+\n+#define REGISTER_NAMES\t\t\t\t\t\t\\\n+{ \"zero\",\"ra\",  \"sp\",  \"gp\",  \"tp\",  \"t0\",  \"t1\",  \"t2\",\t\\\n+  \"s0\",  \"s1\",  \"a0\",  \"a1\",  \"a2\",  \"a3\",  \"a4\",  \"a5\",\t\\\n+  \"a6\",  \"a7\",  \"s2\",  \"s3\",  \"s4\",  \"s5\",  \"s6\",  \"s7\",\t\\\n+  \"s8\",  \"s9\",  \"s10\", \"s11\", \"t3\",  \"t4\",  \"t5\",  \"t6\",\t\\\n+  \"ft0\", \"ft1\", \"ft2\", \"ft3\", \"ft4\", \"ft5\", \"ft6\", \"ft7\",\t\\\n+  \"fs0\", \"fs1\", \"fa0\", \"fa1\", \"fa2\", \"fa3\", \"fa4\", \"fa5\",\t\\\n+  \"fa6\", \"fa7\", \"fs2\", \"fs3\", \"fs4\", \"fs5\", \"fs6\", \"fs7\",\t\\\n+  \"fs8\", \"fs9\", \"fs10\",\"fs11\",\"ft8\", \"ft9\", \"ft10\",\"ft11\",\t\\\n+  \"arg\", \"frame\", }\n+\n+#define ADDITIONAL_REGISTER_NAMES\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  { \"x0\",\t 0 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x1\",\t 1 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x2\",\t 2 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x3\",\t 3 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x4\",\t 4 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x5\",\t 5 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x6\",\t 6 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x7\",\t 7 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x8\",\t 8 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x9\",\t 9 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x10\",\t10 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x11\",\t11 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x12\",\t12 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x13\",\t13 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x14\",\t14 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x15\",\t15 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x16\",\t16 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x17\",\t17 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x18\",\t18 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x19\",\t19 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x20\",\t20 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x21\",\t21 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x22\",\t22 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x23\",\t23 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x24\",\t24 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x25\",\t25 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x26\",\t26 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x27\",\t27 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x28\",\t28 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x29\",\t29 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x30\",\t30 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x31\",\t31 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f0\",\t 0 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f1\",\t 1 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f2\",\t 2 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f3\",\t 3 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f4\",\t 4 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f5\",\t 5 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f6\",\t 6 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f7\",\t 7 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f8\",\t 8 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f9\",\t 9 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f10\",\t10 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f11\",\t11 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f12\",\t12 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f13\",\t13 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f14\",\t14 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f15\",\t15 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f16\",\t16 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f17\",\t17 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f18\",\t18 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f19\",\t19 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f20\",\t20 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f21\",\t21 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f22\",\t22 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f23\",\t23 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f24\",\t24 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f25\",\t25 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f26\",\t26 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f27\",\t27 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f28\",\t28 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f29\",\t29 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f30\",\t30 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"f31\",\t31 + FP_REG_FIRST },\t\t\t\t\t\\\n+}\n+\n+/* Globalizing directive for a label.  */\n+#define GLOBAL_ASM_OP \"\\t.globl\\t\"\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#undef ASM_GENERATE_INTERNAL_LABEL\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\t\t\\\n+  sprintf ((LABEL), \"*%s%s%ld\", (LOCAL_LABEL_PREFIX), (PREFIX), (long)(NUM))\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)\t\t\t\t\\\n+  fprintf (STREAM, \"\\t.word\\t%sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE)\n+\n+/* This is how to output an element of a PIC case-vector. */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)\t\t\\\n+  fprintf (STREAM, \"\\t.word\\t%sL%d-%sL%d\\n\",\t\t\t\t\\\n+\t   LOCAL_LABEL_PREFIX, VALUE, LOCAL_LABEL_PREFIX, REL)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(STREAM,LOG)\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\t.align\\t%d\\n\", (LOG))\n+\n+/* Define the strings to put out for each section in the object file.  */\n+#define TEXT_SECTION_ASM_OP\t\"\\t.text\"\t/* instructions */\n+#define DATA_SECTION_ASM_OP\t\"\\t.data\"\t/* large data */\n+#define READONLY_DATA_SECTION_ASM_OP\t\"\\t.section\\t.rodata\"\n+#define BSS_SECTION_ASM_OP\t\"\\t.bss\"\n+#define SBSS_SECTION_ASM_OP\t\"\\t.section\\t.sbss,\\\"aw\\\",@nobits\"\n+#define SDATA_SECTION_ASM_OP\t\"\\t.section\\t.sdata,\\\"aw\\\",@progbits\"\n+\n+#define ASM_OUTPUT_REG_PUSH(STREAM,REGNO)\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\taddi\\t%s,%s,-8\\n\\t%s\\t%s,0(%s)\\n\",\t\t\\\n+\t     reg_names[STACK_POINTER_REGNUM],\t\t\t\t\\\n+\t     reg_names[STACK_POINTER_REGNUM],\t\t\t\t\\\n+\t     TARGET_64BIT ? \"sd\" : \"sw\",\t\t\t\t\\\n+\t     reg_names[REGNO],\t\t\t\t\t\t\\\n+\t     reg_names[STACK_POINTER_REGNUM]);\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+#define ASM_OUTPUT_REG_POP(STREAM,REGNO)\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t%s\\t%s,0(%s)\\n\\taddi\\t%s,%s,8\\n\",\t\t\\\n+\t     TARGET_64BIT ? \"ld\" : \"lw\",\t\t\t\t\\\n+\t     reg_names[REGNO],\t\t\t\t\t\t\\\n+\t     reg_names[STACK_POINTER_REGNUM],\t\t\t\t\\\n+\t     reg_names[STACK_POINTER_REGNUM],\t\t\t\t\\\n+\t     reg_names[STACK_POINTER_REGNUM]);\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+#define ASM_COMMENT_START \"#\"\n+\n+#undef SIZE_TYPE\n+#define SIZE_TYPE (POINTER_SIZE == 64 ? \"long unsigned int\" : \"unsigned int\")\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE (POINTER_SIZE == 64 ? \"long int\" : \"int\")\n+\n+/* If a memory-to-memory move would take MOVE_RATIO or more simple\n+   move-instruction pairs, we will do a movmem or libcall instead.  */\n+\n+#define MOVE_RATIO(speed) (CLEAR_RATIO (speed) / 2)\n+\n+/* For CLEAR_RATIO, when optimizing for size, give a better estimate\n+   of the length of a memset call, but use the default otherwise.  */\n+\n+#define CLEAR_RATIO(speed) ((speed) ? 16 : 6)\n+\n+/* This is similar to CLEAR_RATIO, but for a non-zero constant, so when\n+   optimizing for size adjust the ratio to account for the overhead of\n+   loading the constant and replicating it across the word.  */\n+\n+#define SET_RATIO(speed) (CLEAR_RATIO (speed) - ((speed) ? 0 : 2))\n+\n+#ifndef USED_FOR_TARGET\n+extern const enum reg_class riscv_regno_to_class[];\n+extern bool riscv_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n+#endif\n+\n+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL) \\\n+  (((GLOBAL) ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | DW_EH_PE_sdata4)\n+\n+#define XLEN_SPEC \\\n+  \"%{march=rv32*:32}\" \\\n+  \"%{march=rv64*:64}\" \\\n+\n+#define ABI_SPEC \\\n+  \"%{mabi=ilp32:ilp32}\" \\\n+  \"%{mabi=ilp32f:ilp32f}\" \\\n+  \"%{mabi=ilp32d:ilp32d}\" \\\n+  \"%{mabi=lp64:lp64}\" \\\n+  \"%{mabi=lp64f:lp64f}\" \\\n+  \"%{mabi=lp64d:lp64d}\" \\\n+\n+#define STARTFILE_PREFIX_SPEC \t\t\t\\\n+   \"/lib\" XLEN_SPEC \"/\" ABI_SPEC \"/ \"\t\t\\\n+   \"/usr/lib\" XLEN_SPEC \"/\" ABI_SPEC \"/ \"\t\\\n+   \"/lib/ \"\t\t\t\t\t\\\n+   \"/usr/lib/ \"\n+\n+/* ISA constants needed for code generation.  */\n+#define OPCODE_LW    0x2003\n+#define OPCODE_LD    0x3003\n+#define OPCODE_AUIPC 0x17\n+#define OPCODE_JALR  0x67\n+#define OPCODE_LUI   0x37\n+#define OPCODE_ADDI  0x13\n+#define SHIFT_RD  7\n+#define SHIFT_RS1 15\n+#define SHIFT_IMM 20\n+#define IMM_BITS 12\n+\n+#define IMM_REACH (1LL << IMM_BITS)\n+#define CONST_HIGH_PART(VALUE) (((VALUE) + (IMM_REACH/2)) & ~(IMM_REACH-1))\n+#define CONST_LOW_PART(VALUE) ((VALUE) - CONST_HIGH_PART (VALUE))\n+\n+#endif /* ! GCC_RISCV_H */"}, {"sha": "4cbb2431335415762c3b472a309c2358ef4dd769", "filename": "gcc/config/riscv/riscv.md", "status": "added", "additions": 2079, "deletions": 0, "changes": 2079, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.md?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,2079 @@\n+;; Machine description for RISC-V for GNU compiler.\n+;; Copyright (C) 2011-2017 Free Software Foundation, Inc.\n+;; Contributed by Andrew Waterman (andrew@sifive.com).\n+;; Based on MIPS target for GNU compiler.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_c_enum \"unspec\" [\n+  ;; Override return address for exception handling.\n+  UNSPEC_EH_RETURN\n+\n+  ;; Symbolic accesses.  The order of this list must match that of\n+  ;; enum riscv_symbol_type in riscv-protos.h.\n+  UNSPEC_ADDRESS_FIRST\n+  UNSPEC_PCREL\n+  UNSPEC_LOAD_GOT\n+  UNSPEC_TLS\n+  UNSPEC_TLS_LE\n+  UNSPEC_TLS_IE\n+  UNSPEC_TLS_GD\n+\n+  ;; High part of PC-relative address.\n+  UNSPEC_AUIPC\n+\n+  ;; Floating-point unspecs.\n+  UNSPEC_FLT_QUIET\n+  UNSPEC_FLE_QUIET\n+  UNSPEC_COPYSIGN\n+  UNSPEC_LRINT\n+  UNSPEC_LROUND\n+\n+  ;; Stack tie\n+  UNSPEC_TIE\n+])\n+\n+(define_c_enum \"unspecv\" [\n+  ;; Register save and restore.\n+  UNSPECV_GPR_SAVE\n+  UNSPECV_GPR_RESTORE\n+\n+  ;; Floating-point unspecs.\n+  UNSPECV_FRFLAGS\n+  UNSPECV_FSFLAGS\n+\n+  ;; Blockage and synchronization.\n+  UNSPECV_BLOCKAGE\n+  UNSPECV_FENCE\n+  UNSPECV_FENCE_I\n+])\n+\n+(define_constants\n+  [(RETURN_ADDR_REGNUM\t\t1)\n+   (T0_REGNUM\t\t\t5)\n+   (T1_REGNUM\t\t\t6)\n+   (S0_REGNUM\t\t\t8)\n+   (S1_REGNUM\t\t\t9)\n+   (S2_REGNUM\t\t\t18)\n+])\n+\n+(include \"predicates.md\")\n+(include \"constraints.md\")\n+\n+;; ....................\n+;;\n+;;\tAttributes\n+;;\n+;; ....................\n+\n+(define_attr \"got\" \"unset,xgot_high,load\"\n+  (const_string \"unset\"))\n+\n+;; Classification of moves, extensions and truncations.  Most values\n+;; are as for \"type\" (see below) but there are also the following\n+;; move-specific values:\n+;;\n+;; andi\t\ta single ANDI instruction\n+;; shift_shift\ta shift left followed by a shift right\n+;;\n+;; This attribute is used to determine the instruction's length and\n+;; scheduling type.  For doubleword moves, the attribute always describes\n+;; the split instructions; in some cases, it is more appropriate for the\n+;; scheduling type to be \"multi\" instead.\n+(define_attr \"move_type\"\n+  \"unknown,load,fpload,store,fpstore,mtc,mfc,move,fmove,\n+   const,logical,arith,andi,shift_shift\"\n+  (const_string \"unknown\"))\n+\n+;; Main data type used by the insn\n+(define_attr \"mode\" \"unknown,none,QI,HI,SI,DI,TI,SF,DF,TF\"\n+  (const_string \"unknown\"))\n+\n+;; True if the main data type is twice the size of a word.\n+(define_attr \"dword_mode\" \"no,yes\"\n+  (cond [(and (eq_attr \"mode\" \"DI,DF\")\n+\t      (eq (symbol_ref \"TARGET_64BIT\") (const_int 0)))\n+\t (const_string \"yes\")\n+\n+\t (and (eq_attr \"mode\" \"TI,TF\")\n+\t      (ne (symbol_ref \"TARGET_64BIT\") (const_int 0)))\n+\t (const_string \"yes\")]\n+\t(const_string \"no\")))\n+\n+;; Classification of each insn.\n+;; branch\tconditional branch\n+;; jump\t\tunconditional jump\n+;; call\t\tunconditional call\n+;; load\t\tload instruction(s)\n+;; fpload\tfloating point load\n+;; store\tstore instruction(s)\n+;; fpstore\tfloating point store\n+;; mtc\t\ttransfer to coprocessor\n+;; mfc\t\ttransfer from coprocessor\n+;; const\tload constant\n+;; arith\tinteger arithmetic instructions\n+;; logical      integer logical instructions\n+;; shift\tinteger shift instructions\n+;; slt\t\tset less than instructions\n+;; imul\t\tinteger multiply \n+;; idiv\t\tinteger divide\n+;; move\t\tinteger register move (addi rd, rs1, 0)\n+;; fmove\tfloating point register move\n+;; fadd\t\tfloating point add/subtract\n+;; fmul\t\tfloating point multiply\n+;; fmadd\tfloating point multiply-add\n+;; fdiv\t\tfloating point divide\n+;; fcmp\t\tfloating point compare\n+;; fcvt\t\tfloating point convert\n+;; fsqrt\tfloating point square root\n+;; multi\tmultiword sequence (or user asm statements)\n+;; nop\t\tno operation\n+;; ghost\tan instruction that produces no real code\n+(define_attr \"type\"\n+  \"unknown,branch,jump,call,load,fpload,store,fpstore,\n+   mtc,mfc,const,arith,logical,shift,slt,imul,idiv,move,fmove,fadd,fmul,\n+   fmadd,fdiv,fcmp,fcvt,fsqrt,multi,nop,ghost\"\n+  (cond [(eq_attr \"got\" \"load\") (const_string \"load\")\n+\n+\t ;; If a doubleword move uses these expensive instructions,\n+\t ;; it is usually better to schedule them in the same way\n+\t ;; as the singleword form, rather than as \"multi\".\n+\t (eq_attr \"move_type\" \"load\") (const_string \"load\")\n+\t (eq_attr \"move_type\" \"fpload\") (const_string \"fpload\")\n+\t (eq_attr \"move_type\" \"store\") (const_string \"store\")\n+\t (eq_attr \"move_type\" \"fpstore\") (const_string \"fpstore\")\n+\t (eq_attr \"move_type\" \"mtc\") (const_string \"mtc\")\n+\t (eq_attr \"move_type\" \"mfc\") (const_string \"mfc\")\n+\n+\t ;; These types of move are always single insns.\n+\t (eq_attr \"move_type\" \"fmove\") (const_string \"fmove\")\n+\t (eq_attr \"move_type\" \"arith\") (const_string \"arith\")\n+\t (eq_attr \"move_type\" \"logical\") (const_string \"logical\")\n+\t (eq_attr \"move_type\" \"andi\") (const_string \"logical\")\n+\n+\t ;; These types of move are always split.\n+\t (eq_attr \"move_type\" \"shift_shift\")\n+\t   (const_string \"multi\")\n+\n+\t ;; These types of move are split for doubleword modes only.\n+\t (and (eq_attr \"move_type\" \"move,const\")\n+\t      (eq_attr \"dword_mode\" \"yes\"))\n+\t   (const_string \"multi\")\n+\t (eq_attr \"move_type\" \"move\") (const_string \"move\")\n+\t (eq_attr \"move_type\" \"const\") (const_string \"const\")]\n+\t(const_string \"unknown\")))\n+\n+;; Length of instruction in bytes.\n+(define_attr \"length\" \"\"\n+   (cond [\n+\t  ;; Branches further than +/- 4 KiB require two instructions.\n+\t  (eq_attr \"type\" \"branch\")\n+\t  (if_then_else (and (le (minus (match_dup 0) (pc)) (const_int 4088))\n+\t\t\t\t  (le (minus (pc) (match_dup 0)) (const_int 4092)))\n+\t  (const_int 4)\n+\t  (const_int 8))\n+\n+\t  ;; Conservatively assume calls take two instructions (AUIPC + JALR).\n+\t  ;; The linker will opportunistically relax the sequence to JAL.\n+\t  (eq_attr \"type\" \"call\") (const_int 8)\n+\n+\t  ;; \"Ghost\" instructions occupy no space.\n+\t  (eq_attr \"type\" \"ghost\") (const_int 0)\n+\n+\t  (eq_attr \"got\" \"load\") (const_int 8)\n+\n+\t  (eq_attr \"type\" \"fcmp\") (const_int 8)\n+\n+\t  ;; SHIFT_SHIFTs are decomposed into two separate instructions.\n+\t  (eq_attr \"move_type\" \"shift_shift\")\n+\t\t(const_int 8)\n+\n+\t  ;; Check for doubleword moves that are decomposed into two\n+\t  ;; instructions.\n+\t  (and (eq_attr \"move_type\" \"mtc,mfc,move\")\n+\t       (eq_attr \"dword_mode\" \"yes\"))\n+\t  (const_int 8)\n+\n+\t  ;; Doubleword CONST{,N} moves are split into two word\n+\t  ;; CONST{,N} moves.\n+\t  (and (eq_attr \"move_type\" \"const\")\n+\t       (eq_attr \"dword_mode\" \"yes\"))\n+\t  (symbol_ref \"riscv_split_const_insns (operands[1]) * 4\")\n+\n+\t  ;; Otherwise, constants, loads and stores are handled by external\n+\t  ;; routines.\n+\t  (eq_attr \"move_type\" \"load,fpload\")\n+\t  (symbol_ref \"riscv_load_store_insns (operands[1], insn) * 4\")\n+\t  (eq_attr \"move_type\" \"store,fpstore\")\n+\t  (symbol_ref \"riscv_load_store_insns (operands[0], insn) * 4\")\n+\t  ] (const_int 4)))\n+\n+;; Is copying of this instruction disallowed?\n+(define_attr \"cannot_copy\" \"no,yes\" (const_string \"no\"))\n+\n+;; Describe a user's asm statement.\n+(define_asm_attributes\n+  [(set_attr \"type\" \"multi\")])\n+\n+;; This mode iterator allows 32-bit and 64-bit GPR patterns to be generated\n+;; from the same template.\n+(define_mode_iterator GPR [SI (DI \"TARGET_64BIT\")])\n+\n+;; This mode iterator allows :P to be used for patterns that operate on\n+;; pointer-sized quantities.  Exactly one of the two alternatives will match.\n+(define_mode_iterator P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n+\n+;; Likewise, but for XLEN-sized quantities.\n+(define_mode_iterator X [(SI \"!TARGET_64BIT\") (DI \"TARGET_64BIT\")])\n+\n+;; Branches operate on XLEN-sized quantities, but for RV64 we accept\n+;; QImode values so we can force zero-extension.\n+(define_mode_iterator BR [(QI \"TARGET_64BIT\") SI (DI \"TARGET_64BIT\")])\n+\n+;; 32-bit moves for which we provide move patterns.\n+(define_mode_iterator MOVE32 [SI])\n+\n+;; 64-bit modes for which we provide move patterns.\n+(define_mode_iterator MOVE64 [DI DF])\n+\n+;; Iterator for sub-32-bit integer modes.\n+(define_mode_iterator SHORT [QI HI])\n+\n+;; Iterator for HImode constant generation.\n+(define_mode_iterator HISI [HI SI])\n+\n+;; Iterator for QImode extension patterns.\n+(define_mode_iterator SUPERQI [HI SI (DI \"TARGET_64BIT\")])\n+\n+;; Iterator for hardware integer modes narrower than XLEN.\n+(define_mode_iterator SUBX [QI HI (SI \"TARGET_64BIT\")])\n+\n+;; Iterator for hardware-supported integer modes.\n+(define_mode_iterator ANYI [QI HI SI (DI \"TARGET_64BIT\")])\n+\n+;; Iterator for hardware-supported floating-point modes.\n+(define_mode_iterator ANYF [(SF \"TARGET_HARD_FLOAT\")\n+\t\t\t    (DF \"TARGET_DOUBLE_FLOAT\")])\n+\n+;; This attribute gives the length suffix for a sign- or zero-extension\n+;; instruction.\n+(define_mode_attr size [(QI \"b\") (HI \"h\")])\n+\n+;; Mode attributes for loads.\n+(define_mode_attr load [(QI \"lb\") (HI \"lh\") (SI \"lw\") (DI \"ld\") (SF \"flw\") (DF \"fld\")])\n+\n+;; Instruction names for stores.\n+(define_mode_attr store [(QI \"sb\") (HI \"sh\") (SI \"sw\") (DI \"sd\") (SF \"fsw\") (DF \"fsd\")])\n+\n+;; This attribute gives the best constraint to use for registers of\n+;; a given mode.\n+(define_mode_attr reg [(SI \"d\") (DI \"d\") (CC \"d\")])\n+\n+;; This attribute gives the format suffix for floating-point operations.\n+(define_mode_attr fmt [(SF \"s\") (DF \"d\")])\n+\n+;; This attribute gives the integer suffix for floating-point conversions.\n+(define_mode_attr ifmt [(SI \"w\") (DI \"l\")])\n+\n+;; This attribute gives the format suffix for atomic memory operations.\n+(define_mode_attr amo [(SI \"w\") (DI \"d\")])\n+\n+;; This attribute gives the upper-case mode name for one unit of a\n+;; floating-point mode.\n+(define_mode_attr UNITMODE [(SF \"SF\") (DF \"DF\")])\n+\n+;; This attribute gives the integer mode that has half the size of\n+;; the controlling mode.\n+(define_mode_attr HALFMODE [(DF \"SI\") (DI \"SI\") (TF \"DI\")])\n+\n+;; Iterator and attributes for floating-point rounding instructions.\n+(define_int_iterator RINT [UNSPEC_LRINT UNSPEC_LROUND])\n+(define_int_attr rint_pattern [(UNSPEC_LRINT \"rint\") (UNSPEC_LROUND \"round\")])\n+(define_int_attr rint_rm [(UNSPEC_LRINT \"dyn\") (UNSPEC_LROUND \"rmm\")])\n+\n+;; Iterator and attributes for quiet comparisons.\n+(define_int_iterator QUIET_COMPARISON [UNSPEC_FLT_QUIET UNSPEC_FLE_QUIET])\n+(define_int_attr quiet_pattern [(UNSPEC_FLT_QUIET \"lt\") (UNSPEC_FLE_QUIET \"le\")])\n+\n+;; This code iterator allows signed and unsigned widening multiplications\n+;; to use the same template.\n+(define_code_iterator any_extend [sign_extend zero_extend])\n+\n+;; This code iterator allows the two right shift instructions to be\n+;; generated from the same template.\n+(define_code_iterator any_shiftrt [ashiftrt lshiftrt])\n+\n+;; This code iterator allows the three shift instructions to be generated\n+;; from the same template.\n+(define_code_iterator any_shift [ashift ashiftrt lshiftrt])\n+\n+;; This code iterator allows the three bitwise instructions to be generated\n+;; from the same template.\n+(define_code_iterator any_bitwise [and ior xor])\n+\n+;; This code iterator allows unsigned and signed division to be generated\n+;; from the same template.\n+(define_code_iterator any_div [div udiv mod umod])\n+\n+;; This code iterator allows unsigned and signed modulus to be generated\n+;; from the same template.\n+(define_code_iterator any_mod [mod umod])\n+\n+;; These code iterators allow the signed and unsigned scc operations to use\n+;; the same template.\n+(define_code_iterator any_gt [gt gtu])\n+(define_code_iterator any_ge [ge geu])\n+(define_code_iterator any_lt [lt ltu])\n+(define_code_iterator any_le [le leu])\n+\n+;; <u> expands to an empty string when doing a signed operation and\n+;; \"u\" when doing an unsigned operation.\n+(define_code_attr u [(sign_extend \"\") (zero_extend \"u\")\n+\t\t     (gt \"\") (gtu \"u\")\n+\t\t     (ge \"\") (geu \"u\")\n+\t\t     (lt \"\") (ltu \"u\")\n+\t\t     (le \"\") (leu \"u\")])\n+\n+;; <su> is like <u>, but the signed form expands to \"s\" rather than \"\".\n+(define_code_attr su [(sign_extend \"s\") (zero_extend \"u\")])\n+\n+;; <optab> expands to the name of the optab for a particular code.\n+(define_code_attr optab [(ashift \"ashl\")\n+\t\t\t (ashiftrt \"ashr\")\n+\t\t\t (lshiftrt \"lshr\")\n+\t\t\t (div \"div\")\n+\t\t\t (mod \"mod\")\n+\t\t\t (udiv \"udiv\")\n+\t\t\t (umod \"umod\")\n+\t\t\t (ge \"ge\")\n+\t\t\t (le \"le\")\n+\t\t\t (gt \"gt\")\n+\t\t\t (lt \"lt\")\n+\t\t\t (ior \"ior\")\n+\t\t\t (xor \"xor\")\n+\t\t\t (and \"and\")\n+\t\t\t (plus \"add\")\n+\t\t\t (minus \"sub\")])\n+\n+;; <insn> expands to the name of the insn that implements a particular code.\n+(define_code_attr insn [(ashift \"sll\")\n+\t\t\t(ashiftrt \"sra\")\n+\t\t\t(lshiftrt \"srl\")\n+\t\t\t(div \"div\")\n+\t\t\t(mod \"rem\")\n+\t\t\t(udiv \"divu\")\n+\t\t\t(umod \"remu\")\n+\t\t\t(ior \"or\")\n+\t\t\t(xor \"xor\")\n+\t\t\t(and \"and\")\n+\t\t\t(plus \"add\")\n+\t\t\t(minus \"sub\")])\n+\n+;; Ghost instructions produce no real code and introduce no hazards.\n+;; They exist purely to express an effect on dataflow.\n+(define_insn_reservation \"ghost\" 0\n+  (eq_attr \"type\" \"ghost\")\n+  \"nothing\")\n+\n+;;\n+;;  ....................\n+;;\n+;;\tADDITION\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"add<mode>3\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(plus:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t\t   (match_operand:ANYF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fadd.<fmt>\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fadd\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t  (match_operand:SI 2 \"arith_operand\" \"r,I\")))]\n+  \"\"\n+  { return TARGET_64BIT ? \"addw\\t%0,%1,%2\" : \"add\\t%0,%1,%2\"; }\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"r,r\")\n+\t\t  (match_operand:DI 2 \"arith_operand\" \"r,I\")))]\n+  \"TARGET_64BIT\"\n+  \"add\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*addsi3_extended\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(sign_extend:DI\n+\t     (plus:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t      (match_operand:SI 2 \"arith_operand\" \"r,I\"))))]\n+  \"TARGET_64BIT\"\n+  \"addw\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*addsi3_extended2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(sign_extend:DI\n+\t  (subreg:SI (plus:DI (match_operand:DI 1 \"register_operand\" \"r,r\")\n+\t\t\t      (match_operand:DI 2 \"arith_operand\" \"r,I\"))\n+\t\t     0)))]\n+  \"TARGET_64BIT\"\n+  \"addw\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+;;\n+;;  ....................\n+;;\n+;;\tSUBTRACTION\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"sub<mode>3\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(minus:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t\t    (match_operand:ANYF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fsub.<fmt>\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fadd\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(minus:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n+\t\t   (match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"sub\\t%0,%z1,%2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\")\n+\t\t   (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  { return TARGET_64BIT ? \"subw\\t%0,%z1,%2\" : \"sub\\t%0,%z1,%2\"; }\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*subsi3_extended\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:DI\n+\t    (minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\")\n+\t\t      (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"TARGET_64BIT\"\n+  \"subw\\t%0,%z1,%2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*subsi3_extended2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:DI\n+\t  (subreg:SI (minus:DI (match_operand:DI 1 \"reg_or_0_operand\" \"r\")\n+\t\t\t       (match_operand:DI 2 \"register_operand\" \"r\"))\n+\t\t     0)))]\n+  \"TARGET_64BIT\"\n+  \"subw\\t%0,%z1,%2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+;;\n+;;  ....................\n+;;\n+;;\tMULTIPLICATION\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"mul<mode>3\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(mult:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:ANYF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fmul.<fmt>\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fmul\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_MUL\"\n+  { return TARGET_64BIT ? \"mulw\\t%0,%1,%2\" : \"mul\\t%0,%1,%2\"; }\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"muldi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(mult:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_MUL && TARGET_64BIT\"\n+  \"mul\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*mulsi3_extended\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:DI\n+\t    (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t     (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"TARGET_MUL && TARGET_64BIT\"\n+  \"mulw\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*mulsi3_extended2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:DI\n+\t  (subreg:SI (mult:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t      (match_operand:DI 2 \"register_operand\" \"r\"))\n+\t\t     0)))]\n+  \"TARGET_MUL && TARGET_64BIT\"\n+  \"mulw\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+;;\n+;;  ........................\n+;;\n+;;\tMULTIPLICATION HIGH-PART\n+;;\n+;;  ........................\n+;;\n+\n+\n+(define_expand \"<u>mulditi3\"\n+  [(set (match_operand:TI 0 \"register_operand\")\n+\t(mult:TI (any_extend:TI (match_operand:DI 1 \"register_operand\"))\n+\t\t (any_extend:TI (match_operand:DI 2 \"register_operand\"))))]\n+  \"TARGET_MUL && TARGET_64BIT\"\n+{\n+  rtx low = gen_reg_rtx (DImode);\n+  emit_insn (gen_muldi3 (low, operands[1], operands[2]));\n+\n+  rtx high = gen_reg_rtx (DImode);\n+  emit_insn (gen_<u>muldi3_highpart (high, operands[1], operands[2]));\n+\n+  emit_move_insn (gen_lowpart (DImode, operands[0]), low);\n+  emit_move_insn (gen_highpart (DImode, operands[0]), high);\n+  DONE;\n+})\n+\n+(define_insn \"<u>muldi3_highpart\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(truncate:DI\n+\t  (lshiftrt:TI\n+\t    (mult:TI (any_extend:TI\n+\t\t       (match_operand:DI 1 \"register_operand\" \"r\"))\n+\t\t     (any_extend:TI\n+\t\t       (match_operand:DI 2 \"register_operand\" \"r\")))\n+\t    (const_int 64))))]\n+  \"TARGET_MUL && TARGET_64BIT\"\n+  \"mulh<u>\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_expand \"usmulditi3\"\n+  [(set (match_operand:TI 0 \"register_operand\")\n+\t(mult:TI (zero_extend:TI (match_operand:DI 1 \"register_operand\"))\n+\t\t (sign_extend:TI (match_operand:DI 2 \"register_operand\"))))]\n+  \"TARGET_MUL && TARGET_64BIT\"\n+{\n+  rtx low = gen_reg_rtx (DImode);\n+  emit_insn (gen_muldi3 (low, operands[1], operands[2]));\n+\n+  rtx high = gen_reg_rtx (DImode);\n+  emit_insn (gen_usmuldi3_highpart (high, operands[1], operands[2]));\n+\n+  emit_move_insn (gen_lowpart (DImode, operands[0]), low);\n+  emit_move_insn (gen_highpart (DImode, operands[0]), high);\n+  DONE;\n+})\n+\n+(define_insn \"usmuldi3_highpart\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(truncate:DI\n+\t  (lshiftrt:TI\n+\t    (mult:TI (zero_extend:TI\n+\t\t       (match_operand:DI 1 \"register_operand\" \"r\"))\n+\t\t     (sign_extend:TI\n+\t\t       (match_operand:DI 2 \"register_operand\" \"r\")))\n+\t    (const_int 64))))]\n+  \"TARGET_MUL && TARGET_64BIT\"\n+  \"mulhsu\\t%0,%2,%1\"\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_expand \"<u>mulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(mult:DI (any_extend:DI\n+\t\t   (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t (any_extend:DI\n+\t\t   (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"TARGET_MUL && !TARGET_64BIT\"\n+{\n+  rtx temp = gen_reg_rtx (SImode);\n+  emit_insn (gen_mulsi3 (temp, operands[1], operands[2]));\n+  emit_insn (gen_<u>mulsi3_highpart (riscv_subword (operands[0], true),\n+\t\t\t\t     operands[1], operands[2]));\n+  emit_insn (gen_movsi (riscv_subword (operands[0], false), temp));\n+  DONE;\n+})\n+\n+(define_insn \"<u>mulsi3_highpart\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(truncate:SI\n+\t  (lshiftrt:DI\n+\t    (mult:DI (any_extend:DI\n+\t\t       (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t     (any_extend:DI\n+\t\t       (match_operand:SI 2 \"register_operand\" \"r\")))\n+\t    (const_int 32))))]\n+  \"TARGET_MUL && !TARGET_64BIT\"\n+  \"mulh<u>\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+\n+(define_expand \"usmulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(mult:DI (zero_extend:DI\n+\t\t   (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t (sign_extend:DI\n+\t\t   (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"TARGET_MUL && !TARGET_64BIT\"\n+{\n+  rtx temp = gen_reg_rtx (SImode);\n+  emit_insn (gen_mulsi3 (temp, operands[1], operands[2]));\n+  emit_insn (gen_usmulsi3_highpart (riscv_subword (operands[0], true),\n+\t\t\t\t     operands[1], operands[2]));\n+  emit_insn (gen_movsi (riscv_subword (operands[0], false), temp));\n+  DONE;\n+})\n+\n+(define_insn \"usmulsi3_highpart\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(truncate:SI\n+\t  (lshiftrt:DI\n+\t    (mult:DI (zero_extend:DI\n+\t\t       (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t     (sign_extend:DI\n+\t\t       (match_operand:SI 2 \"register_operand\" \"r\")))\n+\t    (const_int 32))))]\n+  \"TARGET_MUL && !TARGET_64BIT\"\n+  \"mulhsu\\t%0,%2,%1\"\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+;;\n+;;  ....................\n+;;\n+;;\tDIVISION and REMAINDER\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"<optab>si3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(any_div:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t    (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_DIV\"\n+  { return TARGET_64BIT ? \"<insn>w\\t%0,%1,%2\" : \"<insn>\\t%0,%1,%2\"; }\n+  [(set_attr \"type\" \"idiv\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"<optab>di3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(any_div:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t    (match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_DIV && TARGET_64BIT\"\n+  \"<insn>\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"idiv\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*<optab>si3_extended\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:DI\n+\t    (any_div:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t(match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"TARGET_DIV && TARGET_64BIT\"\n+  \"<insn>w\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"idiv\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"div<mode>3\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(div:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:ANYF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_FDIV\"\n+  \"fdiv.<fmt>\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fdiv\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+;;\n+;;  ....................\n+;;\n+;;\tSQUARE ROOT\n+;;\n+;;  ....................\n+\n+(define_insn \"sqrt<mode>2\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(sqrt:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_FDIV\"\n+{\n+    return \"fsqrt.<fmt>\\t%0,%1\";\n+}\n+  [(set_attr \"type\" \"fsqrt\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+;; Floating point multiply accumulate instructions.\n+\n+;; a * b + c\n+(define_insn \"fma<mode>4\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+    (fma:ANYF\n+      (match_operand:ANYF 1 \"register_operand\" \"f\")\n+      (match_operand:ANYF 2 \"register_operand\" \"f\")\n+      (match_operand:ANYF 3 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fmadd.<fmt>\\t%0,%1,%2,%3\"\n+  [(set_attr \"type\" \"fmadd\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+;; a * b - c\n+(define_insn \"fms<mode>4\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+    (fma:ANYF\n+      (match_operand:ANYF 1 \"register_operand\" \"f\")\n+      (match_operand:ANYF 2 \"register_operand\" \"f\")\n+      (neg:ANYF (match_operand:ANYF 3 \"register_operand\" \"f\"))))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fmsub.<fmt>\\t%0,%1,%2,%3\"\n+  [(set_attr \"type\" \"fmadd\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+;; -a * b - c\n+(define_insn \"fnms<mode>4\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+    (fma:ANYF\n+      (neg:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\"))\n+      (match_operand:ANYF 2 \"register_operand\" \"f\")\n+      (neg:ANYF (match_operand:ANYF 3 \"register_operand\" \"f\"))))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fnmadd.<fmt>\\t%0,%1,%2,%3\"\n+  [(set_attr \"type\" \"fmadd\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+;; -a * b + c\n+(define_insn \"fnma<mode>4\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+    (fma:ANYF\n+      (neg:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\"))\n+      (match_operand:ANYF 2 \"register_operand\" \"f\")\n+      (match_operand:ANYF 3 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fnmsub.<fmt>\\t%0,%1,%2,%3\"\n+  [(set_attr \"type\" \"fmadd\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+;; -(-a * b - c), modulo signed zeros\n+(define_insn \"*fma<mode>4\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+    (neg:ANYF\n+      (fma:ANYF\n+\t(neg:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\"))\n+\t(match_operand:ANYF 2 \"register_operand\" \"f\")\n+\t(neg:ANYF (match_operand:ANYF 3 \"register_operand\" \"f\")))))]\n+  \"TARGET_HARD_FLOAT && !HONOR_SIGNED_ZEROS (<MODE>mode)\"\n+  \"fmadd.<fmt>\\t%0,%1,%2,%3\"\n+  [(set_attr \"type\" \"fmadd\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+;; -(-a * b + c), modulo signed zeros\n+(define_insn \"*fms<mode>4\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+    (neg:ANYF\n+      (fma:ANYF\n+\t(neg:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\"))\n+\t(match_operand:ANYF 2 \"register_operand\" \"f\")\n+\t(match_operand:ANYF 3 \"register_operand\" \"f\"))))]\n+  \"TARGET_HARD_FLOAT && !HONOR_SIGNED_ZEROS (<MODE>mode)\"\n+  \"fmsub.<fmt>\\t%0,%1,%2,%3\"\n+  [(set_attr \"type\" \"fmadd\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+;; -(a * b + c), modulo signed zeros\n+(define_insn \"*fnms<mode>4\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+    (neg:ANYF\n+      (fma:ANYF\n+\t(match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t(match_operand:ANYF 2 \"register_operand\" \"f\")\n+\t(match_operand:ANYF 3 \"register_operand\" \"f\"))))]\n+  \"TARGET_HARD_FLOAT && !HONOR_SIGNED_ZEROS (<MODE>mode)\"\n+  \"fnmadd.<fmt>\\t%0,%1,%2,%3\"\n+  [(set_attr \"type\" \"fmadd\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+;; -(a * b - c), modulo signed zeros\n+(define_insn \"*fnma<mode>4\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+    (neg:ANYF\n+      (fma:ANYF\n+\t(match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t(match_operand:ANYF 2 \"register_operand\" \"f\")\n+\t(neg:ANYF (match_operand:ANYF 3 \"register_operand\" \"f\")))))]\n+  \"TARGET_HARD_FLOAT && !HONOR_SIGNED_ZEROS (<MODE>mode)\"\n+  \"fnmsub.<fmt>\\t%0,%1,%2,%3\"\n+  [(set_attr \"type\" \"fmadd\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+;;\n+;;  ....................\n+;;\n+;;\tSIGN INJECTION\n+;;\n+;;  ....................\n+\n+(define_insn \"abs<mode>2\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(abs:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fabs.<fmt>\\t%0,%1\"\n+  [(set_attr \"type\" \"fmove\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+(define_insn \"copysign<mode>3\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(unspec:ANYF [(match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:ANYF 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_COPYSIGN))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fsgnj.<fmt>\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fmove\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+(define_insn \"neg<mode>2\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(neg:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fneg.<fmt>\\t%0,%1\"\n+  [(set_attr \"type\" \"fmove\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+;;\n+;;  ....................\n+;;\n+;;\tMIN/MAX\n+;;\n+;;  ....................\n+\n+(define_insn \"smin<mode>3\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t\t   (smin:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t\t\t    (match_operand:ANYF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fmin.<fmt>\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fmove\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+(define_insn \"smax<mode>3\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t\t   (smax:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t\t\t    (match_operand:ANYF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fmax.<fmt>\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fmove\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+;;\n+;;  ....................\n+;;\n+;;\tLOGICAL\n+;;\n+;;  ....................\n+;;\n+\n+;; For RV64, we don't expose the SImode operations to the rtl expanders,\n+;; but SImode versions exist for combine.\n+\n+(define_insn \"<optab><mode>3\"\n+  [(set (match_operand:X 0 \"register_operand\" \"=r,r\")\n+\t(any_bitwise:X (match_operand:X 1 \"register_operand\" \"%r,r\")\n+\t\t       (match_operand:X 2 \"arith_operand\" \"r,I\")))]\n+  \"\"\n+  \"<insn>\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"logical\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*<optab>si3_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(any_bitwise:SI (match_operand:SI 1 \"register_operand\" \"%r,r\")\n+\t\t\t(match_operand:SI 2 \"arith_operand\" \"r,I\")))]\n+  \"TARGET_64BIT\"\n+  \"<insn>\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"logical\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"one_cmpl<mode>2\"\n+  [(set (match_operand:X 0 \"register_operand\" \"=r\")\n+\t(not:X (match_operand:X 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"not\\t%0,%1\"\n+  [(set_attr \"type\" \"logical\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*one_cmplsi2_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"not\\t%0,%1\"\n+  [(set_attr \"type\" \"logical\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+;;\n+;;  ....................\n+;;\n+;;\tTRUNCATION\n+;;\n+;;  ....................\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_DOUBLE_FLOAT\"\n+  \"fcvt.s.d\\t%0,%1\"\n+  [(set_attr \"type\" \"fcvt\")\n+   (set_attr \"mode\" \"SF\")])\n+\n+;;\n+;;  ....................\n+;;\n+;;\tZERO EXTENSION\n+;;\n+;;  ....................\n+\n+;; Extension insns.\n+\n+(define_insn_and_split \"zero_extendsidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   #\n+   lwu\\t%0,%1\"\n+  \"&& reload_completed && REG_P (operands[1])\"\n+  [(set (match_dup 0)\n+\t(ashift:DI (match_dup 1) (const_int 32)))\n+   (set (match_dup 0)\n+\t(lshiftrt:DI (match_dup 0) (const_int 32)))]\n+  { operands[1] = gen_lowpart (DImode, operands[1]); }\n+  [(set_attr \"move_type\" \"shift_shift,load\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn_and_split \"zero_extendhi<GPR:mode>2\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:GPR (match_operand:HI 1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+   #\n+   lhu\\t%0,%1\"\n+  \"&& reload_completed && REG_P (operands[1])\"\n+  [(set (match_dup 0)\n+\t(ashift:GPR (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0)\n+\t(lshiftrt:GPR (match_dup 0) (match_dup 2)))]\n+  {\n+    operands[1] = gen_lowpart (<GPR:MODE>mode, operands[1]);\n+    operands[2] = GEN_INT(GET_MODE_BITSIZE(<GPR:MODE>mode) - 16);\n+  }\n+  [(set_attr \"move_type\" \"shift_shift,load\")\n+   (set_attr \"mode\" \"<GPR:MODE>\")])\n+\n+(define_insn \"zero_extendqi<SUPERQI:mode>2\"\n+  [(set (match_operand:SUPERQI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:SUPERQI\n+\t     (match_operand:QI 1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+   and\\t%0,%1,0xff\n+   lbu\\t%0,%1\"\n+  [(set_attr \"move_type\" \"andi,load\")\n+   (set_attr \"mode\" \"<SUPERQI:MODE>\")])\n+\n+;;\n+;;  ....................\n+;;\n+;;\tSIGN EXTENSION\n+;;\n+;;  ....................\n+\n+(define_insn \"extendsidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(sign_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   sext.w\\t%0,%1\n+   lw\\t%0,%1\"\n+  [(set_attr \"move_type\" \"move,load\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn_and_split \"extend<SHORT:mode><SUPERQI:mode>2\"\n+  [(set (match_operand:SUPERQI 0 \"register_operand\" \"=r,r\")\n+\t(sign_extend:SUPERQI\n+\t     (match_operand:SHORT 1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+   #\n+   l<SHORT:size>\\t%0,%1\"\n+  \"&& reload_completed && REG_P (operands[1])\"\n+  [(set (match_dup 0) (ashift:SI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0) (ashiftrt:SI (match_dup 0) (match_dup 2)))]\n+{\n+  operands[0] = gen_lowpart (SImode, operands[0]);\n+  operands[1] = gen_lowpart (SImode, operands[1]);\n+  operands[2] = GEN_INT (GET_MODE_BITSIZE (SImode)\n+\t\t\t - GET_MODE_BITSIZE (<SHORT:MODE>mode));\n+}\n+  [(set_attr \"move_type\" \"shift_shift,load\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(float_extend:DF (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_DOUBLE_FLOAT\"\n+  \"fcvt.d.s\\t%0,%1\"\n+  [(set_attr \"type\" \"fcvt\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+;;\n+;;  ....................\n+;;\n+;;\tCONVERSIONS\n+;;\n+;;  ....................\n+\n+(define_insn \"fix_trunc<ANYF:mode><GPR:mode>2\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=r\")\n+\t(fix:GPR (match_operand:ANYF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fcvt.<GPR:ifmt>.<ANYF:fmt> %0,%1,rtz\"\n+  [(set_attr \"type\" \"fcvt\")\n+   (set_attr \"mode\" \"<ANYF:MODE>\")])\n+\n+(define_insn \"fixuns_trunc<ANYF:mode><GPR:mode>2\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=r\")\n+\t(unsigned_fix:GPR (match_operand:ANYF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fcvt.<GPR:ifmt>u.<ANYF:fmt> %0,%1,rtz\"\n+  [(set_attr \"type\" \"fcvt\")\n+   (set_attr \"mode\" \"<ANYF:MODE>\")])\n+\n+(define_insn \"float<GPR:mode><ANYF:mode>2\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(float:ANYF (match_operand:GPR 1 \"reg_or_0_operand\" \"rJ\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fcvt.<ANYF:fmt>.<GPR:ifmt>\\t%0,%z1\"\n+  [(set_attr \"type\" \"fcvt\")\n+   (set_attr \"mode\" \"<ANYF:MODE>\")])\n+\n+(define_insn \"floatuns<GPR:mode><ANYF:mode>2\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(unsigned_float:ANYF (match_operand:GPR 1 \"reg_or_0_operand\" \"rJ\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fcvt.<ANYF:fmt>.<GPR:ifmt>u\\t%0,%z1\"\n+  [(set_attr \"type\" \"fcvt\")\n+   (set_attr \"mode\" \"<ANYF:MODE>\")])\n+\n+(define_insn \"l<rint_pattern><ANYF:mode><GPR:mode>2\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=r\")\n+\t(unspec:GPR [(match_operand:ANYF 1 \"register_operand\" \"f\")]\n+\t\t    RINT))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fcvt.<GPR:ifmt>.<ANYF:fmt> %0,%1,<rint_rm>\"\n+  [(set_attr \"type\" \"fcvt\")\n+   (set_attr \"mode\" \"<ANYF:MODE>\")])\n+\n+;;\n+;;  ....................\n+;;\n+;;\tDATA MOVEMENT\n+;;\n+;;  ....................\n+\n+;; Lower-level instructions for loading an address from the GOT.\n+;; We could use MEMs, but an unspec gives more optimization\n+;; opportunities.\n+\n+(define_insn \"got_load<mode>\"\n+   [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+       (unspec:P [(match_operand:P 1 \"symbolic_operand\" \"\")]\n+\t\t UNSPEC_LOAD_GOT))]\n+  \"\"\n+  \"la\\t%0,%1\"\n+   [(set_attr \"got\" \"load\")\n+    (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"tls_add_tp_le<mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(unspec:P [(match_operand:P 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:P 2 \"register_operand\" \"r\")\n+\t\t   (match_operand:P 3 \"symbolic_operand\" \"\")]\n+\t\t  UNSPEC_TLS_LE))]\n+  \"\"\n+  \"add\\t%0,%1,%2,%%tprel_add(%3)\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"got_load_tls_gd<mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+       (unspec:P [(match_operand:P 1 \"symbolic_operand\" \"\")]\n+\t\t UNSPEC_TLS_GD))]\n+  \"\"\n+  \"la.tls.gd\\t%0,%1\"\n+  [(set_attr \"got\" \"load\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"got_load_tls_ie<mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+       (unspec:P [(match_operand:P 1 \"symbolic_operand\" \"\")]\n+\t\t UNSPEC_TLS_IE))]\n+  \"\"\n+  \"la.tls.ie\\t%0,%1\"\n+  [(set_attr \"got\" \"load\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"auipc<mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+       (unspec:P [(match_operand:P 1 \"symbolic_operand\" \"\")\n+\t\t  (match_operand:P 2 \"const_int_operand\")\n+\t\t  (pc)]\n+\t\t UNSPEC_AUIPC))]\n+  \"\"\n+  \".LA%2: auipc\\t%0,%h1\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"cannot_copy\" \"yes\")])\n+\n+;; Instructions for adding the low 12 bits of an address to a register.\n+;; Operand 2 is the address: riscv_print_operand works out which relocation\n+;; should be applied.\n+\n+(define_insn \"*low<mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(lo_sum:P (match_operand:P 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:P 2 \"symbolic_operand\" \"\")))]\n+  \"\"\n+  \"addi\\t%0,%1,%R2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; Allow combine to split complex const_int load sequences, using operand 2\n+;; to store the intermediate results.  See move_operand for details.\n+(define_split\n+  [(set (match_operand:GPR 0 \"register_operand\")\n+\t(match_operand:GPR 1 \"splittable_const_int_operand\"))\n+   (clobber (match_operand:GPR 2 \"register_operand\"))]\n+  \"\"\n+  [(const_int 0)]\n+{\n+  riscv_move_integer (operands[2], operands[0], INTVAL (operands[1]));\n+  DONE;\n+})\n+\n+;; Likewise, for symbolic operands.\n+(define_split\n+  [(set (match_operand:P 0 \"register_operand\")\n+\t(match_operand:P 1))\n+   (clobber (match_operand:P 2 \"register_operand\"))]\n+  \"riscv_split_symbol (operands[2], operands[1], MAX_MACHINE_MODE, NULL)\"\n+  [(set (match_dup 0) (match_dup 3))]\n+{\n+  riscv_split_symbol (operands[2], operands[1],\n+\t\t     MAX_MACHINE_MODE, &operands[3]);\n+})\n+\n+;; 64-bit integer moves\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"\")\n+\t(match_operand:DI 1 \"\"))]\n+  \"\"\n+{\n+  if (riscv_legitimize_move (DImode, operands[0], operands[1]))\n+    DONE;\n+})\n+\n+(define_insn \"*movdi_32bit\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,m,  *f,*f,*r,*f,*m\")\n+\t(match_operand:DI 1 \"move_operand\" \" r,i,m,r,*J*r,*m,*f,*f,*f\"))]\n+  \"!TARGET_64BIT\n+   && (register_operand (operands[0], DImode)\n+       || reg_or_0_operand (operands[1], DImode))\"\n+  { return riscv_output_move (operands[0], operands[1]); }\n+  [(set_attr \"move_type\" \"move,const,load,store,mtc,fpload,mfc,fmove,fpstore\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*movdi_64bit\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r, m,*f,*f,*r,*f,*m\")\n+\t(match_operand:DI 1 \"move_operand\" \" r,T,m,rJ,*r*J,*m,*f,*f,*f\"))]\n+  \"TARGET_64BIT\n+   && (register_operand (operands[0], DImode)\n+       || reg_or_0_operand (operands[1], DImode))\"\n+  { return riscv_output_move (operands[0], operands[1]); }\n+  [(set_attr \"move_type\" \"move,const,load,store,mtc,fpload,mfc,fmove,fpstore\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+;; 32-bit Integer moves\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:MOVE32 0 \"\")\n+\t(match_operand:MOVE32 1 \"\"))]\n+  \"\"\n+{\n+  if (riscv_legitimize_move (<MODE>mode, operands[0], operands[1]))\n+    DONE;\n+})\n+\n+(define_insn \"*movsi_internal\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,m,*f,*f,*r,*m\")\n+\t(match_operand:SI 1 \"move_operand\" \"r,T,m,rJ,*r*J,*m,*f,*f\"))]\n+  \"(register_operand (operands[0], SImode)\n+    || reg_or_0_operand (operands[1], SImode))\"\n+  { return riscv_output_move (operands[0], operands[1]); }\n+  [(set_attr \"move_type\" \"move,const,load,store,mtc,fpload,mfc,fpstore\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+;; 16-bit Integer moves\n+\n+;; Unlike most other insns, the move insns can't be split with\n+;; different predicates, because register spilling and other parts of\n+;; the compiler, have memoized the insn number already.\n+;; Unsigned loads are used because LOAD_EXTEND_OP returns ZERO_EXTEND.\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"\")\n+\t(match_operand:HI 1 \"\"))]\n+  \"\"\n+{\n+  if (riscv_legitimize_move (HImode, operands[0], operands[1]))\n+    DONE;\n+})\n+\n+(define_insn \"*movhi_internal\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r,m,*f,*r\")\n+\t(match_operand:HI 1 \"move_operand\"\t \"r,T,m,rJ,*r*J,*f\"))]\n+  \"(register_operand (operands[0], HImode)\n+    || reg_or_0_operand (operands[1], HImode))\"\n+  { return riscv_output_move (operands[0], operands[1]); }\n+  [(set_attr \"move_type\" \"move,const,load,store,mtc,mfc\")\n+   (set_attr \"mode\" \"HI\")])\n+\n+;; HImode constant generation; see riscv_move_integer for details.\n+;; si+si->hi without truncation is legal because of TRULY_NOOP_TRUNCATION.\n+\n+(define_insn \"*add<mode>hi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(plus:HI (match_operand:HISI 1 \"register_operand\" \"r,r\")\n+\t\t  (match_operand:HISI 2 \"arith_operand\" \"r,I\")))]\n+  \"\"\n+  { return TARGET_64BIT ? \"addw\\t%0,%1,%2\" : \"add\\t%0,%1,%2\"; }\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"HI\")])\n+\n+(define_insn \"*xor<mode>hi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(xor:HI (match_operand:HISI 1 \"register_operand\" \"r,r\")\n+\t\t  (match_operand:HISI 2 \"arith_operand\" \"r,I\")))]\n+  \"\"\n+  \"xor\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"logical\")\n+   (set_attr \"mode\" \"HI\")])\n+\n+;; 8-bit Integer moves\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"\")\n+\t(match_operand:QI 1 \"\"))]\n+  \"\"\n+{\n+  if (riscv_legitimize_move (QImode, operands[0], operands[1]))\n+    DONE;\n+})\n+\n+(define_insn \"*movqi_internal\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,r,m,*f,*r\")\n+\t(match_operand:QI 1 \"move_operand\"\t \"r,I,m,rJ,*r*J,*f\"))]\n+  \"(register_operand (operands[0], QImode)\n+    || reg_or_0_operand (operands[1], QImode))\"\n+  { return riscv_output_move (operands[0], operands[1]); }\n+  [(set_attr \"move_type\" \"move,const,load,store,mtc,mfc\")\n+   (set_attr \"mode\" \"QI\")])\n+\n+;; 32-bit floating point moves\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"\")\n+\t(match_operand:SF 1 \"\"))]\n+  \"\"\n+{\n+  if (riscv_legitimize_move (SFmode, operands[0], operands[1]))\n+    DONE;\n+})\n+\n+(define_insn \"*movsf_hardfloat\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f,f,m,m,*f,*r,*r,*r,*m\")\n+\t(match_operand:SF 1 \"move_operand\" \"f,G,m,f,G,*r,*f,*G*r,*m,*r\"))]\n+  \"TARGET_HARD_FLOAT\n+   && (register_operand (operands[0], SFmode)\n+       || reg_or_0_operand (operands[1], SFmode))\"\n+  { return riscv_output_move (operands[0], operands[1]); }\n+  [(set_attr \"move_type\" \"fmove,mtc,fpload,fpstore,store,mtc,mfc,move,load,store\")\n+   (set_attr \"mode\" \"SF\")])\n+\n+(define_insn \"*movsf_softfloat\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,m\")\n+\t(match_operand:SF 1 \"move_operand\" \"Gr,m,r\"))]\n+  \"!TARGET_HARD_FLOAT\n+   && (register_operand (operands[0], SFmode)\n+       || reg_or_0_operand (operands[1], SFmode))\"\n+  { return riscv_output_move (operands[0], operands[1]); }\n+  [(set_attr \"move_type\" \"move,load,store\")\n+   (set_attr \"mode\" \"SF\")])\n+\n+;; 64-bit floating point moves\n+\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"\")\n+\t(match_operand:DF 1 \"\"))]\n+  \"\"\n+{\n+  if (riscv_legitimize_move (DFmode, operands[0], operands[1]))\n+    DONE;\n+})\n+\n+;; In RV32, we lack fmv.x.d and fmv.d.x.  Go through memory instead.\n+;; (However, we can still use fcvt.d.w to zero a floating-point register.)\n+(define_insn \"*movdf_hardfloat_rv32\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,f,m,m,*r,*r,*m\")\n+\t(match_operand:DF 1 \"move_operand\" \"f,G,m,f,G,*r*G,*m,*r\"))]\n+  \"!TARGET_64BIT && TARGET_DOUBLE_FLOAT\n+   && (register_operand (operands[0], DFmode)\n+       || reg_or_0_operand (operands[1], DFmode))\"\n+  { return riscv_output_move (operands[0], operands[1]); }\n+  [(set_attr \"move_type\" \"fmove,mtc,fpload,fpstore,store,move,load,store\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+(define_insn \"*movdf_hardfloat_rv64\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,f,m,m,*f,*r,*r,*r,*m\")\n+\t(match_operand:DF 1 \"move_operand\" \"f,G,m,f,G,*r,*f,*r*G,*m,*r\"))]\n+  \"TARGET_64BIT && TARGET_DOUBLE_FLOAT\n+   && (register_operand (operands[0], DFmode)\n+       || reg_or_0_operand (operands[1], DFmode))\"\n+  { return riscv_output_move (operands[0], operands[1]); }\n+  [(set_attr \"move_type\" \"fmove,mtc,fpload,fpstore,store,mtc,mfc,move,load,store\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+(define_insn \"*movdf_softfloat\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,m\")\n+\t(match_operand:DF 1 \"move_operand\" \"rG,m,rG\"))]\n+  \"!TARGET_DOUBLE_FLOAT\n+   && (register_operand (operands[0], DFmode)\n+       || reg_or_0_operand (operands[1], DFmode))\"\n+  { return riscv_output_move (operands[0], operands[1]); }\n+  [(set_attr \"move_type\" \"move,load,store\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+(define_split\n+  [(set (match_operand:MOVE64 0 \"nonimmediate_operand\")\n+\t(match_operand:MOVE64 1 \"move_operand\"))]\n+  \"reload_completed\n+   && riscv_split_64bit_move_p (operands[0], operands[1])\"\n+  [(const_int 0)]\n+{\n+  riscv_split_doubleword_move (operands[0], operands[1]);\n+  DONE;\n+})\n+\n+;; Expand in-line code to clear the instruction cache between operand[0] and\n+;; operand[1].\n+(define_expand \"clear_cache\"\n+  [(match_operand 0 \"pmode_register_operand\")\n+   (match_operand 1 \"pmode_register_operand\")]\n+  \"\"\n+{\n+  emit_insn (gen_fence_i ());\n+  DONE;\n+})\n+\n+(define_insn \"fence\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_FENCE)]\n+  \"\"\n+  \"%|fence%-\")\n+\n+(define_insn \"fence_i\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_FENCE_I)]\n+  \"\"\n+  \"fence.i\")\n+\n+;;\n+;;  ....................\n+;;\n+;;\tSHIFTS\n+;;\n+;;  ....................\n+\n+(define_insn \"<optab>si3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(any_shift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t       (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  \"\"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    operands[2] = GEN_INT (INTVAL (operands[2])\n+\t\t\t   & (GET_MODE_BITSIZE (SImode) - 1));\n+\n+  return TARGET_64BIT ? \"<insn>w\\t%0,%1,%2\" : \"<insn>\\t%0,%1,%2\";\n+}\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"<optab>di3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(any_shift:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t       (match_operand:DI 2 \"arith_operand\" \"rI\")))]\n+  \"TARGET_64BIT\"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    operands[2] = GEN_INT (INTVAL (operands[2])\n+\t\t\t   & (GET_MODE_BITSIZE (DImode) - 1));\n+\n+  return \"<insn>\\t%0,%1,%2\";\n+}\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*<optab>si3_extend\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:DI\n+\t   (any_shift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"arith_operand\" \"rI\"))))]\n+  \"TARGET_64BIT\"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n+\n+  return \"<insn>w\\t%0,%1,%2\";\n+}\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+;;\n+;;  ....................\n+;;\n+;;\tCONDITIONAL BRANCHES\n+;;\n+;;  ....................\n+\n+;; Conditional branches\n+\n+(define_insn \"*branch_order<mode>\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 1 \"order_operator\"\n+\t\t\t [(match_operand:X 2 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:X 3 \"register_operand\" \"r\")])\n+\t (label_ref (match_operand 0 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"b%C1\\t%2,%3,%0\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"mode\" \"none\")])\n+\n+(define_insn \"*branch_zero<mode>\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 1 \"signed_order_operator\"\n+\t\t\t [(match_operand:X 2 \"register_operand\" \"r\")\n+\t\t\t  (const_int 0)])\n+\t (label_ref (match_operand 0 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"b%C1z\\t%2,%0\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"mode\" \"none\")])\n+\n+;; Used to implement built-in functions.\n+(define_expand \"condjump\"\n+  [(set (pc)\n+\t(if_then_else (match_operand 0)\n+\t\t      (label_ref (match_operand 1))\n+\t\t      (pc)))])\n+\n+(define_expand \"cbranch<mode>4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t       [(match_operand:BR 1 \"register_operand\")\n+\t\t\t(match_operand:BR 2 \"nonmemory_operand\")])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+{\n+  riscv_expand_conditional_branch (operands[3], GET_CODE (operands[0]),\n+\t\t\t\t   operands[1], operands[2]);\n+  DONE;\n+})\n+\n+(define_expand \"cbranch<mode>4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"fp_branch_comparison\"\n+\t\t       [(match_operand:ANYF 1 \"register_operand\")\n+\t\t\t(match_operand:ANYF 2 \"register_operand\")])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_HARD_FLOAT\"\n+{\n+  riscv_expand_conditional_branch (operands[3], GET_CODE (operands[0]),\n+\t\t\t\t   operands[1], operands[2]);\n+  DONE;\n+})\n+\n+(define_insn_and_split \"*branch_on_bit<X:mode>\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"equality_operator\"\n+\t  [(zero_extract:X (match_operand:X 2 \"register_operand\" \"r\")\n+\t\t (const_int 1)\n+\t\t (match_operand 3 \"branch_on_bit_operand\"))\n+\t\t (const_int 0)])\n+\t (label_ref (match_operand 1))\n+\t (pc)))\n+   (clobber (match_scratch:X 4 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 4)\n+\t(ashift:X (match_dup 2) (match_dup 3)))\n+   (set (pc)\n+\t(if_then_else\n+\t (match_op_dup 0 [(match_dup 4) (const_int 0)])\n+\t (label_ref (match_operand 1))\n+\t (pc)))]\n+{\n+  int shift = GET_MODE_BITSIZE (<MODE>mode) - 1 - INTVAL (operands[3]);\n+  operands[3] = GEN_INT (shift);\n+\n+  if (GET_CODE (operands[0]) == EQ)\n+    operands[0] = gen_rtx_GE (<MODE>mode, operands[4], const0_rtx);\n+  else\n+    operands[0] = gen_rtx_LT (<MODE>mode, operands[4], const0_rtx);\n+})\n+\n+(define_insn_and_split \"*branch_on_bit_range<X:mode>\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"equality_operator\"\n+\t  [(zero_extract:X (match_operand:X 2 \"register_operand\" \"r\")\n+\t\t (match_operand 3 \"branch_on_bit_operand\")\n+\t\t (const_int 0))\n+\t\t (const_int 0)])\n+\t (label_ref (match_operand 1))\n+\t (pc)))\n+   (clobber (match_scratch:X 4 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 4)\n+\t(ashift:X (match_dup 2) (match_dup 3)))\n+   (set (pc)\n+\t(if_then_else\n+\t (match_op_dup 0 [(match_dup 4) (const_int 0)])\n+\t (label_ref (match_operand 1))\n+\t (pc)))]\n+{\n+  operands[3] = GEN_INT (GET_MODE_BITSIZE (<MODE>mode) - INTVAL (operands[3]));\n+})\n+\n+;;\n+;;  ....................\n+;;\n+;;\tSETTING A REGISTER FROM A COMPARISON\n+;;\n+;;  ....................\n+\n+;; Destination is always set in SI mode.\n+\n+(define_expand \"cstore<mode>4\"\n+  [(set (match_operand:SI 0 \"register_operand\")\n+\t(match_operator:SI 1 \"order_operator\"\n+\t [(match_operand:GPR 2 \"register_operand\")\n+\t  (match_operand:GPR 3 \"nonmemory_operand\")]))]\n+  \"\"\n+{\n+  riscv_expand_int_scc (operands[0], GET_CODE (operands[1]), operands[2],\n+\t\t\toperands[3]);\n+  DONE;\n+})\n+\n+(define_expand \"cstore<mode>4\"\n+  [(set (match_operand:SI 0 \"register_operand\")\n+\t(match_operator:SI 1 \"fp_scc_comparison\"\n+\t [(match_operand:ANYF 2 \"register_operand\")\n+\t  (match_operand:ANYF 3 \"register_operand\")]))]\n+  \"TARGET_HARD_FLOAT\"\n+{\n+  riscv_expand_float_scc (operands[0], GET_CODE (operands[1]), operands[2],\n+\t\t\t  operands[3]);\n+  DONE;\n+})\n+\n+(define_insn \"*cstore<ANYF:mode><X:mode>4\"\n+   [(set (match_operand:X 0 \"register_operand\" \"=r\")\n+\t(match_operator:X 1 \"fp_native_comparison\"\n+\t      [(match_operand:ANYF 2 \"register_operand\" \"f\")\n+\t       (match_operand:ANYF 3 \"register_operand\" \"f\")]))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"f%C1.<fmt>\\t%0,%2,%3\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+(define_insn \"f<quiet_pattern>_quiet<ANYF:mode><X:mode>4\"\n+   [(set (match_operand:X 0 \"register_operand\" \"=r\")\n+\t (unspec:X\n+\t    [(match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t     (match_operand:ANYF 2 \"register_operand\" \"f\")]\n+\t    QUIET_COMPARISON))\n+    (clobber (match_scratch:X 3 \"=&r\"))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"frflags\\t%3\\n\\tf<quiet_pattern>.<fmt>\\t%0,%1,%2\\n\\tfsflags %3\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"<UNITMODE>\")\n+   (set (attr \"length\") (const_int 12))])\n+\n+(define_insn \"*seq_zero_<X:mode><GPR:mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=r\")\n+\t(eq:GPR (match_operand:X 1 \"register_operand\" \"r\")\n+\t       (const_int 0)))]\n+  \"\"\n+  \"seqz\\t%0,%1\"\n+  [(set_attr \"type\" \"slt\")\n+   (set_attr \"mode\" \"<X:MODE>\")])\n+\n+(define_insn \"*sne_zero_<X:mode><GPR:mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=r\")\n+\t(ne:GPR (match_operand:X 1 \"register_operand\" \"r\")\n+\t       (const_int 0)))]\n+  \"\"\n+  \"snez\\t%0,%1\"\n+  [(set_attr \"type\" \"slt\")\n+   (set_attr \"mode\" \"<X:MODE>\")])\n+\n+(define_insn \"*sgt<u>_<X:mode><GPR:mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=r\")\n+\t(any_gt:GPR (match_operand:X 1 \"register_operand\" \"r\")\n+\t\t    (match_operand:X 2 \"reg_or_0_operand\" \"rJ\")))]\n+  \"\"\n+  \"sgt<u>\\t%0,%1,%z2\"\n+  [(set_attr \"type\" \"slt\")\n+   (set_attr \"mode\" \"<X:MODE>\")])\n+\n+(define_insn \"*sge<u>_<X:mode><GPR:mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=r\")\n+\t(any_ge:GPR (match_operand:X 1 \"register_operand\" \"r\")\n+\t\t    (const_int 1)))]\n+  \"\"\n+  \"slt<u>\\t%0,zero,%1\"\n+  [(set_attr \"type\" \"slt\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*slt<u>_<X:mode><GPR:mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=r\")\n+\t(any_lt:GPR (match_operand:X 1 \"register_operand\" \"r\")\n+\t\t    (match_operand:X 2 \"arith_operand\" \"rI\")))]\n+  \"\"\n+  \"slt<u>\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"slt\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*sle<u>_<X:mode><GPR:mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=r\")\n+\t(any_le:GPR (match_operand:X 1 \"register_operand\" \"r\")\n+\t\t    (match_operand:X 2 \"sle_operand\" \"\")))]\n+  \"\"\n+{\n+  operands[2] = GEN_INT (INTVAL (operands[2]) + 1);\n+  return \"slt<u>\\t%0,%1,%2\";\n+}\n+  [(set_attr \"type\" \"slt\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;;\n+;;  ....................\n+;;\n+;;\tUNCONDITIONAL BRANCHES\n+;;\n+;;  ....................\n+\n+;; Unconditional branches.\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"j\\t%l0\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+(define_expand \"indirect_jump\"\n+  [(set (pc) (match_operand 0 \"register_operand\"))]\n+  \"\"\n+{\n+  operands[0] = force_reg (Pmode, operands[0]);\n+  if (Pmode == SImode)\n+    emit_jump_insn (gen_indirect_jumpsi (operands[0]));\n+  else\n+    emit_jump_insn (gen_indirect_jumpdi (operands[0]));\n+  DONE;\n+})\n+\n+(define_insn \"indirect_jump<mode>\"\n+  [(set (pc) (match_operand:P 0 \"register_operand\" \"l\"))]\n+  \"\"\n+  \"jr\\t%0\"\n+  [(set_attr \"type\" \"jump\")\n+   (set_attr \"mode\" \"none\")])\n+\n+(define_expand \"tablejump\"\n+  [(set (pc) (match_operand 0 \"register_operand\" \"\"))\n+\t      (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+{\n+  if (CASE_VECTOR_PC_RELATIVE)\n+      operands[0] = expand_simple_binop (Pmode, PLUS, operands[0],\n+\t\t\t\t\t gen_rtx_LABEL_REF (Pmode, operands[1]),\n+\t\t\t\t\t NULL_RTX, 0, OPTAB_DIRECT);\n+\n+  if (CASE_VECTOR_PC_RELATIVE && Pmode == DImode)\n+    emit_jump_insn (gen_tablejumpdi (operands[0], operands[1]));\n+  else\n+    emit_jump_insn (gen_tablejumpsi (operands[0], operands[1]));\n+  DONE;\n+})\n+\n+(define_insn \"tablejump<mode>\"\n+  [(set (pc) (match_operand:GPR 0 \"register_operand\" \"l\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"jr\\t%0\"\n+  [(set_attr \"type\" \"jump\")\n+   (set_attr \"mode\" \"none\")])\n+\n+;;\n+;;  ....................\n+;;\n+;;\tFunction prologue/epilogue\n+;;\n+;;  ....................\n+;;\n+\n+(define_expand \"prologue\"\n+  [(const_int 1)]\n+  \"\"\n+{\n+  riscv_expand_prologue ();\n+  DONE;\n+})\n+\n+;; Block any insns from being moved before this point, since the\n+;; profiling call to mcount can use various registers that aren't\n+;; saved or used to pass arguments.\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_BLOCKAGE)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"type\" \"ghost\")\n+   (set_attr \"mode\" \"none\")])\n+\n+(define_expand \"epilogue\"\n+  [(const_int 2)]\n+  \"\"\n+{\n+  riscv_expand_epilogue (false);\n+  DONE;\n+})\n+\n+(define_expand \"sibcall_epilogue\"\n+  [(const_int 2)]\n+  \"\"\n+{\n+  riscv_expand_epilogue (true);\n+  DONE;\n+})\n+\n+;; Trivial return.  Make it look like a normal return insn as that\n+;; allows jump optimizations to work better.\n+\n+(define_expand \"return\"\n+  [(simple_return)]\n+  \"riscv_can_use_return_insn ()\"\n+  \"\")\n+\n+(define_insn \"simple_return\"\n+  [(simple_return)]\n+  \"\"\n+  \"ret\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+;; Normal return.\n+\n+(define_insn \"simple_return_internal\"\n+  [(simple_return)\n+   (use (match_operand 0 \"pmode_register_operand\" \"\"))]\n+  \"\"\n+  \"jr\\t%0\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+;; This is used in compiling the unwind routines.\n+(define_expand \"eh_return\"\n+  [(use (match_operand 0 \"general_operand\"))]\n+  \"\"\n+{\n+  if (GET_MODE (operands[0]) != word_mode)\n+    operands[0] = convert_to_mode (word_mode, operands[0], 0);\n+  if (TARGET_64BIT)\n+    emit_insn (gen_eh_set_lr_di (operands[0]));\n+  else\n+    emit_insn (gen_eh_set_lr_si (operands[0]));\n+  DONE;\n+})\n+\n+;; Clobber the return address on the stack.  We can't expand this\n+;; until we know where it will be put in the stack frame.\n+\n+(define_insn \"eh_set_lr_si\"\n+  [(unspec [(match_operand:SI 0 \"register_operand\" \"r\")] UNSPEC_EH_RETURN)\n+   (clobber (match_scratch:SI 1 \"=&r\"))]\n+  \"! TARGET_64BIT\"\n+  \"#\")\n+\n+(define_insn \"eh_set_lr_di\"\n+  [(unspec [(match_operand:DI 0 \"register_operand\" \"r\")] UNSPEC_EH_RETURN)\n+   (clobber (match_scratch:DI 1 \"=&r\"))]\n+  \"TARGET_64BIT\"\n+  \"#\")\n+\n+(define_split\n+  [(unspec [(match_operand 0 \"register_operand\")] UNSPEC_EH_RETURN)\n+   (clobber (match_scratch 1))]\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  riscv_set_return_address (operands[0], operands[1]);\n+  DONE;\n+})\n+\n+;;\n+;;  ....................\n+;;\n+;;\tFUNCTION CALLS\n+;;\n+;;  ....................\n+\n+(define_expand \"sibcall\"\n+  [(parallel [(call (match_operand 0 \"\")\n+\t\t    (match_operand 1 \"\"))\n+\t      (use (match_operand 2 \"\"))\t;; next_arg_reg\n+\t      (use (match_operand 3 \"\"))])]\t;; struct_value_size_rtx\n+  \"\"\n+{\n+  rtx target = riscv_legitimize_call_address (XEXP (operands[0], 0));\n+  emit_call_insn (gen_sibcall_internal (target, operands[1]));\n+  DONE;\n+})\n+\n+(define_insn \"sibcall_internal\"\n+  [(call (mem:SI (match_operand 0 \"call_insn_operand\" \"j,S,U\"))\n+\t (match_operand 1 \"\" \"\"))]\n+  \"SIBLING_CALL_P (insn)\"\n+  \"@\n+   jr\\t%0\n+   tail\\t%0\n+   tail\\t%0@plt\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"sibcall_value\"\n+  [(parallel [(set (match_operand 0 \"\")\n+\t\t   (call (match_operand 1 \"\")\n+\t\t\t (match_operand 2 \"\")))\n+\t      (use (match_operand 3 \"\"))])]\t\t;; next_arg_reg\n+  \"\"\n+{\n+  rtx target = riscv_legitimize_call_address (XEXP (operands[1], 0));\n+  emit_call_insn (gen_sibcall_value_internal (operands[0], target, operands[2]));\n+  DONE;\n+})\n+\n+(define_insn \"sibcall_value_internal\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand 1 \"call_insn_operand\" \"j,S,U\"))\n+\t      (match_operand 2 \"\" \"\")))]\n+  \"SIBLING_CALL_P (insn)\"\n+  \"@\n+   jr\\t%1\n+   tail\\t%1\n+   tail\\t%1@plt\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"call\"\n+  [(parallel [(call (match_operand 0 \"\")\n+\t\t    (match_operand 1 \"\"))\n+\t      (use (match_operand 2 \"\"))\t;; next_arg_reg\n+\t      (use (match_operand 3 \"\"))])]\t;; struct_value_size_rtx\n+  \"\"\n+{\n+  rtx target = riscv_legitimize_call_address (XEXP (operands[0], 0));\n+  emit_call_insn (gen_call_internal (target, operands[1]));\n+  DONE;\n+})\n+\n+(define_insn \"call_internal\"\n+  [(call (mem:SI (match_operand 0 \"call_insn_operand\" \"l,S,U\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (reg:SI RETURN_ADDR_REGNUM))]\n+  \"\"\n+  \"@\n+   jalr\\t%0\n+   call\\t%0\n+   call\\t%0@plt\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"call_value\"\n+  [(parallel [(set (match_operand 0 \"\")\n+\t\t   (call (match_operand 1 \"\")\n+\t\t\t (match_operand 2 \"\")))\n+\t      (use (match_operand 3 \"\"))])]\t\t;; next_arg_reg\n+  \"\"\n+{\n+  rtx target = riscv_legitimize_call_address (XEXP (operands[1], 0));\n+  emit_call_insn (gen_call_value_internal (operands[0], target, operands[2]));\n+  DONE;\n+})\n+\n+(define_insn \"call_value_internal\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand 1 \"call_insn_operand\" \"l,S,U\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (reg:SI RETURN_ADDR_REGNUM))]\n+  \"\"\n+  \"@\n+   jalr\\t%1\n+   call\\t%1\n+   call\\t%1@plt\"\n+  [(set_attr \"type\" \"call\")])\n+\n+;; Call subroutine returning any type.\n+\n+(define_expand \"untyped_call\"\n+  [(parallel [(call (match_operand 0 \"\")\n+\t\t    (const_int 0))\n+\t      (match_operand 1 \"\")\n+\t      (match_operand 2 \"\")])]\n+  \"\"\n+{\n+  int i;\n+\n+  emit_call_insn (gen_call (operands[0], const0_rtx, NULL, const0_rtx));\n+\n+  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n+    {\n+      rtx set = XVECEXP (operands[2], 0, i);\n+      riscv_emit_move (SET_DEST (set), SET_SRC (set));\n+    }\n+\n+  emit_insn (gen_blockage ());\n+  DONE;\n+})\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  [(set_attr \"type\"\t\"nop\")\n+   (set_attr \"mode\"\t\"none\")])\n+\n+(define_insn \"trap\"\n+  [(trap_if (const_int 1) (const_int 0))]\n+  \"\"\n+  \"ebreak\")\n+\n+(define_insn \"gpr_save\"\n+  [(unspec_volatile [(match_operand 0 \"const_int_operand\")] UNSPECV_GPR_SAVE)\n+   (clobber (reg:SI T0_REGNUM))\n+   (clobber (reg:SI T1_REGNUM))]\n+  \"\"\n+  { return riscv_output_gpr_save (INTVAL (operands[0])); })\n+\n+(define_insn \"gpr_restore\"\n+  [(unspec_volatile [(match_operand 0 \"const_int_operand\")] UNSPECV_GPR_RESTORE)]\n+  \"\"\n+  \"tail\\t__riscv_restore_%0\")\n+\n+(define_insn \"gpr_restore_return\"\n+  [(return)\n+   (use (match_operand 0 \"pmode_register_operand\" \"\"))\n+   (const_int 0)]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"riscv_frflags\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile [(const_int 0)] UNSPECV_FRFLAGS))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"frflags %0\")\n+\n+(define_insn \"riscv_fsflags\"\n+  [(unspec_volatile [(match_operand:SI 0 \"csr_operand\" \"rK\")] UNSPECV_FSFLAGS)]\n+  \"TARGET_HARD_FLOAT\"\n+  \"fsflags %0\")\n+\n+(define_insn \"stack_tie<mode>\"\n+  [(set (mem:BLK (scratch))\n+\t(unspec:BLK [(match_operand:X 0 \"register_operand\" \"r\")\n+\t\t     (match_operand:X 1 \"register_operand\" \"r\")]\n+\t\t    UNSPEC_TIE))]\n+  \"\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")]\n+)\n+\n+(include \"sync.md\")\n+(include \"peephole.md\")\n+(include \"pic.md\")\n+(include \"generic.md\")"}, {"sha": "0466bb29d14ca631322a63077fe1c5c79a3b2fe9", "filename": "gcc/config/riscv/riscv.opt", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Friscv.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.opt?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,111 @@\n+; Options for the RISC-V port of the compiler\n+;\n+; Copyright (C) 2011-2017 Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT\n+; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+; License for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+\n+HeaderInclude\n+config/riscv/riscv-opts.h\n+\n+mbranch-cost=\n+Target RejectNegative Joined UInteger Var(riscv_branch_cost)\n+-mbranch-cost=N\tSet the cost of branches to roughly N instructions.\n+\n+mplt\n+Target Report Var(TARGET_PLT) Init(1)\n+When generating -fpic code, allow the use of PLTs. Ignored for fno-pic.\n+\n+mabi=\n+Target Report RejectNegative Joined Enum(abi_type) Var(riscv_abi) Init(ABI_ILP32)\n+Specify integer and floating-point calling convention.\n+\n+Enum\n+Name(abi_type) Type(enum riscv_abi_type)\n+Supported ABIs (for use with the -mabi= option):\n+\n+EnumValue\n+Enum(abi_type) String(ilp32) Value(ABI_ILP32)\n+\n+EnumValue\n+Enum(abi_type) String(ilp32f) Value(ABI_ILP32F)\n+\n+EnumValue\n+Enum(abi_type) String(ilp32d) Value(ABI_ILP32D)\n+\n+EnumValue\n+Enum(abi_type) String(lp64) Value(ABI_LP64)\n+\n+EnumValue\n+Enum(abi_type) String(lp64f) Value(ABI_LP64F)\n+\n+EnumValue\n+Enum(abi_type) String(lp64d) Value(ABI_LP64D)\n+\n+mfdiv\n+Target Report Mask(FDIV)\n+Use hardware floating-point divide and square root instructions.\n+\n+mdiv\n+Target Report Mask(DIV)\n+Use hardware instructions for integer division.\n+\n+march=\n+Target Report RejectNegative Joined\n+-march=\tGenerate code for given RISC-V ISA (e.g. RV64IM).  ISA strings must be\n+lower-case.\n+\n+mtune=\n+Target RejectNegative Joined Var(riscv_tune_string)\n+-mtune=PROCESSOR\tOptimize the output for PROCESSOR.\n+\n+msmall-data-limit=\n+Target Joined Separate UInteger Var(g_switch_value) Init(8)\n+-msmall-data-limit=N\tPut global and static data smaller than <number> bytes into a special section (on some targets).\n+\n+msave-restore\n+Target Report Mask(SAVE_RESTORE)\n+Use smaller but slower prologue and epilogue code.\n+\n+mcmodel=\n+Target Report RejectNegative Joined Enum(code_model) Var(riscv_cmodel) Init(TARGET_DEFAULT_CMODEL)\n+Specify the code model.\n+\n+Enum\n+Name(code_model) Type(enum riscv_code_model)\n+Known code models (for use with the -mcmodel= option):\n+\n+EnumValue\n+Enum(code_model) String(medlow) Value(CM_MEDLOW)\n+\n+EnumValue\n+Enum(code_model) String(medany) Value(CM_MEDANY)\n+\n+mexplicit-relocs\n+Target Report Mask(EXPLICIT_RELOCS)\n+Use %reloc() operators, rather than assembly macros, to load addresses.\n+\n+Mask(64BIT)\n+\n+Mask(MUL)\n+\n+Mask(ATOMIC)\n+\n+Mask(HARD_FLOAT)\n+\n+Mask(DOUBLE_FLOAT)\n+\n+Mask(RVC)"}, {"sha": "09970b9f36bc451aae92fede99fa59ede15899b0", "filename": "gcc/config/riscv/sync.md", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fsync.md?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,194 @@\n+;; Machine description for RISC-V atomic operations.\n+;; Copyright (C) 2011-2017 Free Software Foundation, Inc.\n+;; Contributed by Andrew Waterman (andrew@sifive.com).\n+;; Based on MIPS target for GNU compiler.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_c_enum \"unspec\" [\n+  UNSPEC_COMPARE_AND_SWAP\n+  UNSPEC_SYNC_OLD_OP\n+  UNSPEC_SYNC_EXCHANGE\n+  UNSPEC_ATOMIC_STORE\n+  UNSPEC_MEMORY_BARRIER\n+])\n+\n+(define_code_iterator any_atomic [plus ior xor and])\n+(define_code_attr atomic_optab\n+  [(plus \"add\") (ior \"or\") (xor \"xor\") (and \"and\")])\n+\n+;; Memory barriers.\n+\n+(define_expand \"mem_thread_fence\"\n+  [(match_operand:SI 0 \"const_int_operand\" \"\")] ;; model\n+  \"\"\n+{\n+  if (INTVAL (operands[0]) != MEMMODEL_RELAXED)\n+    {\n+      rtx mem = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));\n+      MEM_VOLATILE_P (mem) = 1;\n+      emit_insn (gen_mem_thread_fence_1 (mem, operands[0]));\n+    }\n+  DONE;\n+})\n+\n+;; Until the RISC-V memory model (hence its mapping from C++) is finalized,\n+;; conservatively emit a full FENCE.\n+(define_insn \"mem_thread_fence_1\"\n+  [(set (match_operand:BLK 0 \"\" \"\")\n+\t(unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))\n+   (match_operand:SI 1 \"const_int_operand\" \"\")] ;; model\n+  \"\"\n+  \"fence\\trw,rw\")\n+\n+;; Atomic memory operations.\n+\n+;; Implement atomic stores with amoswap.  Fall back to fences for atomic loads.\n+(define_insn \"atomic_store<mode>\"\n+  [(set (match_operand:GPR 0 \"memory_operand\" \"=A\")\n+    (unspec_volatile:GPR\n+      [(match_operand:GPR 1 \"reg_or_0_operand\" \"rJ\")\n+       (match_operand:SI 2 \"const_int_operand\")]      ;; model\n+      UNSPEC_ATOMIC_STORE))]\n+  \"TARGET_ATOMIC\"\n+  \"%F2amoswap.<amo>%A2 zero,%z1,%0\"\n+  [(set (attr \"length\") (const_int 8))])\n+\n+(define_insn \"atomic_<atomic_optab><mode>\"\n+  [(set (match_operand:GPR 0 \"memory_operand\" \"+A\")\n+\t(unspec_volatile:GPR\n+\t  [(any_atomic:GPR (match_dup 0)\n+\t\t     (match_operand:GPR 1 \"reg_or_0_operand\" \"rJ\"))\n+\t   (match_operand:SI 2 \"const_int_operand\")] ;; model\n+\t UNSPEC_SYNC_OLD_OP))]\n+  \"TARGET_ATOMIC\"\n+  \"%F2amo<insn>.<amo>%A2 zero,%z1,%0\"\n+  [(set (attr \"length\") (const_int 8))])\n+\n+(define_insn \"atomic_fetch_<atomic_optab><mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=&r\")\n+\t(match_operand:GPR 1 \"memory_operand\" \"+A\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:GPR\n+\t  [(any_atomic:GPR (match_dup 1)\n+\t\t     (match_operand:GPR 2 \"reg_or_0_operand\" \"rJ\"))\n+\t   (match_operand:SI 3 \"const_int_operand\")] ;; model\n+\t UNSPEC_SYNC_OLD_OP))]\n+  \"TARGET_ATOMIC\"\n+  \"%F3amo<insn>.<amo>%A3 %0,%z2,%1\"\n+  [(set (attr \"length\") (const_int 8))])\n+\n+(define_insn \"atomic_exchange<mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=&r\")\n+\t(unspec_volatile:GPR\n+\t  [(match_operand:GPR 1 \"memory_operand\" \"+A\")\n+\t   (match_operand:SI 3 \"const_int_operand\")] ;; model\n+\t  UNSPEC_SYNC_EXCHANGE))\n+   (set (match_dup 1)\n+\t(match_operand:GPR 2 \"register_operand\" \"0\"))]\n+  \"TARGET_ATOMIC\"\n+  \"%F3amoswap.<amo>%A3 %0,%z2,%1\"\n+  [(set (attr \"length\") (const_int 8))])\n+\n+(define_insn \"atomic_cas_value_strong<mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=&r\")\n+\t(match_operand:GPR 1 \"memory_operand\" \"+A\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:GPR [(match_operand:GPR 2 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t      (match_operand:GPR 3 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t      (match_operand:SI 4 \"const_int_operand\")  ;; mod_s\n+\t\t\t      (match_operand:SI 5 \"const_int_operand\")] ;; mod_f\n+\t UNSPEC_COMPARE_AND_SWAP))\n+   (clobber (match_scratch:GPR 6 \"=&r\"))]\n+  \"TARGET_ATOMIC\"\n+  \"%F5 1: lr.<amo>%A5 %0,%1; bne %0,%z2,1f; sc.<amo>%A4 %6,%z3,%1; bnez %6,1b; 1:\"\n+  [(set (attr \"length\") (const_int 20))])\n+\n+(define_expand \"atomic_compare_and_swap<mode>\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")   ;; bool output\n+   (match_operand:GPR 1 \"register_operand\" \"\")  ;; val output\n+   (match_operand:GPR 2 \"memory_operand\" \"\")    ;; memory\n+   (match_operand:GPR 3 \"reg_or_0_operand\" \"\")  ;; expected value\n+   (match_operand:GPR 4 \"reg_or_0_operand\" \"\")  ;; desired value\n+   (match_operand:SI 5 \"const_int_operand\" \"\")  ;; is_weak\n+   (match_operand:SI 6 \"const_int_operand\" \"\")  ;; mod_s\n+   (match_operand:SI 7 \"const_int_operand\" \"\")] ;; mod_f\n+  \"TARGET_ATOMIC\"\n+{\n+  emit_insn (gen_atomic_cas_value_strong<mode> (operands[1], operands[2],\n+\t\t\t\t\t\toperands[3], operands[4],\n+\t\t\t\t\t\toperands[6], operands[7]));\n+\n+  rtx compare = operands[1];\n+  if (operands[3] != const0_rtx)\n+    {\n+      rtx difference = gen_rtx_MINUS (<MODE>mode, operands[1], operands[3]);\n+      compare = gen_reg_rtx (<MODE>mode);\n+      emit_insn (gen_rtx_SET (compare, difference));\n+    }\n+\n+  if (word_mode != <MODE>mode)\n+    {\n+      rtx reg = gen_reg_rtx (word_mode);\n+      emit_insn (gen_rtx_SET (reg, gen_rtx_SIGN_EXTEND (word_mode, compare)));\n+      compare = reg;\n+    }\n+\n+  emit_insn (gen_rtx_SET (operands[0], gen_rtx_EQ (SImode, compare, const0_rtx)));\n+  DONE;\n+})\n+\n+(define_expand \"atomic_test_and_set\"\n+  [(match_operand:QI 0 \"register_operand\" \"\")     ;; bool output\n+   (match_operand:QI 1 \"memory_operand\" \"+A\")    ;; memory\n+   (match_operand:SI 2 \"const_int_operand\" \"\")]   ;; model\n+  \"TARGET_ATOMIC\"\n+{\n+  /* We have no QImode atomics, so use the address LSBs to form a mask,\n+     then use an aligned SImode atomic. */\n+  rtx result = operands[0];\n+  rtx mem = operands[1];\n+  rtx model = operands[2];\n+  rtx addr = force_reg (Pmode, XEXP (mem, 0));\n+\n+  rtx aligned_addr = gen_reg_rtx (Pmode);\n+  emit_move_insn (aligned_addr, gen_rtx_AND (Pmode, addr, GEN_INT (-4)));\n+\n+  rtx aligned_mem = change_address (mem, SImode, aligned_addr);\n+  set_mem_alias_set (aligned_mem, 0);\n+\n+  rtx offset = gen_reg_rtx (SImode);\n+  emit_move_insn (offset, gen_rtx_AND (SImode, gen_lowpart (SImode, addr),\n+\t\t\t\t       GEN_INT (3)));\n+\n+  rtx tmp = gen_reg_rtx (SImode);\n+  emit_move_insn (tmp, GEN_INT (1));\n+\n+  rtx shmt = gen_reg_rtx (SImode);\n+  emit_move_insn (shmt, gen_rtx_ASHIFT (SImode, offset, GEN_INT (3)));\n+\n+  rtx word = gen_reg_rtx (SImode);\n+  emit_move_insn (word, gen_rtx_ASHIFT (SImode, tmp, shmt));\n+\n+  tmp = gen_reg_rtx (SImode);\n+  emit_insn (gen_atomic_fetch_orsi (tmp, aligned_mem, word, model));\n+\n+  emit_move_insn (gen_lowpart (SImode, result),\n+\t\t  gen_rtx_LSHIFTRT (SImode, tmp,\n+\t\t\t\t    gen_lowpart (SImode, shmt)));\n+  DONE;\n+})"}, {"sha": "19f9434616c2d424d96e5d4d66b0a6fe714b3f08", "filename": "gcc/config/riscv/t-elf-multilib", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Ft-elf-multilib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Ft-elf-multilib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Ft-elf-multilib?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,30 @@\n+# This file was generated by multilib-generator with the command:\n+#  ./multilib-generator rv32i-ilp32--c rv32im-ilp32--c rv32iac-ilp32-- rv32imac-ilp32-- rv32imafc-ilp32f-rv32imafdc- rv64imac-lp64-- rv64imafdc-lp64d--\n+MULTILIB_OPTIONS = march=rv32i/march=rv32ic/march=rv32im/march=rv32imc/march=rv32iac/march=rv32imac/march=rv32imafc/march=rv32imafdc/march=rv32gc/march=rv64imac/march=rv64imafdc/march=rv64gc mabi=ilp32/mabi=ilp32f/mabi=lp64/mabi=lp64d\n+MULTILIB_DIRNAMES = rv32i \\\n+rv32ic \\\n+rv32im \\\n+rv32imc \\\n+rv32iac \\\n+rv32imac \\\n+rv32imafc \\\n+rv32imafdc \\\n+rv32gc \\\n+rv64imac \\\n+rv64imafdc \\\n+rv64gc ilp32 \\\n+ilp32f \\\n+lp64 \\\n+lp64d\n+MULTILIB_REQUIRED = march=rv32i/mabi=ilp32 \\\n+march=rv32im/mabi=ilp32 \\\n+march=rv32iac/mabi=ilp32 \\\n+march=rv32imac/mabi=ilp32 \\\n+march=rv32imafc/mabi=ilp32f \\\n+march=rv64imac/mabi=lp64 \\\n+march=rv64imafdc/mabi=lp64d\n+MULTILIB_REUSE = march.rv32i/mabi.ilp32=march.rv32ic/mabi.ilp32 \\\n+march.rv32im/mabi.ilp32=march.rv32imc/mabi.ilp32 \\\n+march.rv32imafc/mabi.ilp32f=march.rv32imafdc/mabi.ilp32f \\\n+march.rv32imafc/mabi.ilp32f=march.rv32gc/mabi.ilp32f \\\n+march.rv64imafdc/mabi.lp64d=march.rv64gc/mabi.lp64d"}, {"sha": "216d2776a183d13ade76642b73b9bf04b0c4694e", "filename": "gcc/config/riscv/t-linux", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Ft-linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Ft-linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Ft-linux?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,3 @@\n+# Only XLEN and ABI affect Linux multilib dir names, e.g. /lib32/ilp32d/\n+MULTILIB_DIRNAMES := $(patsubst rv32%,lib32,$(patsubst rv64%,lib64,$(MULTILIB_DIRNAMES)))\n+MULTILIB_OSDIRNAMES := $(patsubst lib%,../lib%,$(MULTILIB_DIRNAMES))"}, {"sha": "298547fee38b2b4062e7854c539aabd292927857", "filename": "gcc/config/riscv/t-linux-multilib", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Ft-linux-multilib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Ft-linux-multilib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Ft-linux-multilib?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,46 @@\n+# This file was generated by multilib-generator with the command:\n+#  ./multilib-generator rv32imac-ilp32-rv32ima,rv32imaf,rv32imafd,rv32imafc,rv32imafdc- rv32imafdc-ilp32d-rv32imafd- rv64imac-lp64-rv64ima,rv64imaf,rv64imafd,rv64imafc,rv64imafdc- rv64imafdc-lp64d-rv64imafd-\n+MULTILIB_OPTIONS = march=rv32imac/march=rv32ima/march=rv32imaf/march=rv32imafd/march=rv32imafc/march=rv32imafdc/march=rv32g/march=rv32gc/march=rv64imac/march=rv64ima/march=rv64imaf/march=rv64imafd/march=rv64imafc/march=rv64imafdc/march=rv64g/march=rv64gc mabi=ilp32/mabi=ilp32d/mabi=lp64/mabi=lp64d\n+MULTILIB_DIRNAMES = rv32imac \\\n+rv32ima \\\n+rv32imaf \\\n+rv32imafd \\\n+rv32imafc \\\n+rv32imafdc \\\n+rv32g \\\n+rv32gc \\\n+rv64imac \\\n+rv64ima \\\n+rv64imaf \\\n+rv64imafd \\\n+rv64imafc \\\n+rv64imafdc \\\n+rv64g \\\n+rv64gc ilp32 \\\n+ilp32d \\\n+lp64 \\\n+lp64d\n+MULTILIB_REQUIRED = march=rv32imac/mabi=ilp32 \\\n+march=rv32imafdc/mabi=ilp32d \\\n+march=rv64imac/mabi=lp64 \\\n+march=rv64imafdc/mabi=lp64d\n+MULTILIB_REUSE = march.rv32imac/mabi.ilp32=march.rv32ima/mabi.ilp32 \\\n+march.rv32imac/mabi.ilp32=march.rv32imaf/mabi.ilp32 \\\n+march.rv32imac/mabi.ilp32=march.rv32imafd/mabi.ilp32 \\\n+march.rv32imac/mabi.ilp32=march.rv32imafc/mabi.ilp32 \\\n+march.rv32imac/mabi.ilp32=march.rv32imafdc/mabi.ilp32 \\\n+march.rv32imac/mabi.ilp32=march.rv32g/mabi.ilp32 \\\n+march.rv32imac/mabi.ilp32=march.rv32gc/mabi.ilp32 \\\n+march.rv32imafdc/mabi.ilp32d=march.rv32imafd/mabi.ilp32d \\\n+march.rv32imafdc/mabi.ilp32d=march.rv32gc/mabi.ilp32d \\\n+march.rv32imafdc/mabi.ilp32d=march.rv32g/mabi.ilp32d \\\n+march.rv64imac/mabi.lp64=march.rv64ima/mabi.lp64 \\\n+march.rv64imac/mabi.lp64=march.rv64imaf/mabi.lp64 \\\n+march.rv64imac/mabi.lp64=march.rv64imafd/mabi.lp64 \\\n+march.rv64imac/mabi.lp64=march.rv64imafc/mabi.lp64 \\\n+march.rv64imac/mabi.lp64=march.rv64imafdc/mabi.lp64 \\\n+march.rv64imac/mabi.lp64=march.rv64g/mabi.lp64 \\\n+march.rv64imac/mabi.lp64=march.rv64gc/mabi.lp64 \\\n+march.rv64imafdc/mabi.lp64d=march.rv64imafd/mabi.lp64d \\\n+march.rv64imafdc/mabi.lp64d=march.rv64gc/mabi.lp64d \\\n+march.rv64imafdc/mabi.lp64d=march.rv64g/mabi.lp64d"}, {"sha": "0765b49f90f45a934ef7d487bcf8278140833d2c", "filename": "gcc/config/riscv/t-riscv", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Ft-riscv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfig%2Friscv%2Ft-riscv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Ft-riscv?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -0,0 +1,11 @@\n+riscv-builtins.o: $(srcdir)/config/riscv/riscv-builtins.c $(CONFIG_H) \\\n+  $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) $(RECOG_H) langhooks.h \\\n+  $(DIAGNOSTIC_CORE_H) $(OPTABS_H) $(srcdir)/config/riscv/riscv-ftypes.def \\\n+  $(srcdir)/config/riscv/riscv-modes.def\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\t$(srcdir)/config/riscv/riscv-builtins.c\n+\n+riscv-c.o: $(srcdir)/config/riscv/riscv-c.c $(CONFIG_H) $(SYSTEM_H) \\\n+    coretypes.h $(TM_H) $(TREE_H) output.h $(C_COMMON_H) $(TARGET_H)\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\t$(srcdir)/config/riscv/riscv-c.c"}, {"sha": "673fb1bb891dc6634b13db35741aa60bcdacf783", "filename": "gcc/configure.ac", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -3393,6 +3393,17 @@ x3:\t.space 4\n \ttls_first_minor=14\n \ttls_as_opt=\"-a32 --fatal-warnings\"\n \t;;\n+  riscv*-*-*)\n+    conftest_s='\n+\t.section .tdata,\"awT\",@progbits\n+x:\t.word 2\n+\t.text\n+\tla.tls.gd a0,x\n+        call __tls_get_addr'\n+\ttls_first_major=2\n+\ttls_first_minor=21\n+\ttls_as_opt='--fatal-warnings'\n+\t;;\n   s390-*-*)\n     conftest_s='\n \t.section \".tdata\",\"awT\",@progbits\n@@ -4744,8 +4755,8 @@ esac\n # version to the per-target configury.\n case \"$cpu_type\" in\n   aarch64 | alpha | arm | avr | bfin | cris | i386 | m32c | m68k | microblaze \\\n-  | mips | nios2 | pa | rs6000 | score | sparc | spu | tilegx | tilepro \\\n-  | visium | xstormy16 | xtensa)\n+  | mips | nios2 | pa | riscv | rs6000 | score | sparc | spu | tilegx \\\n+  | tilepro | visium | xstormy16 | xtensa)\n     insn=\"nop\"\n     ;;\n   ia64 | s390)"}, {"sha": "85cd1d37b7d1639049d2bd1cc2136e1850d3e72b", "filename": "gcc/doc/contrib.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fdoc%2Fcontrib.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fdoc%2Fcontrib.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcontrib.texi?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -172,6 +172,10 @@ John-Marc Chandonia for various libgcj patches.\n Denis Chertykov for contributing and maintaining the AVR port, the first GCC port\n for an 8-bit architecture.\n \n+@item\n+Kito Cheng for his work on the RISC-V port, including bringing up the test\n+suite and maintenance.\n+\n @item\n Scott Christley for his Objective-C contributions.\n \n@@ -216,6 +220,9 @@ Ian Dall for major improvements to the NS32k port.\n Paul Dale for his work to add uClinux platform support to the\n m68k backend.\n \n+@item\n+Palmer Dabbelt for his work maintaining the RISC-V port.\n+\n @item\n Dario Dariol contributed the four varieties of sample programs\n that print a copy of their source.\n@@ -1034,6 +1041,9 @@ associated configure steps.\n @item\n Todd Vierling for contributions for NetBSD ports.\n \n+@item\n+Andrew Waterman for contributing the RISC-V port, as well as maintaining it.\n+\n @item\n Jonathan Wakely for contributing libstdc++ Doxygen notes and XHTML\n guidance."}, {"sha": "0c82fe9eb94d2208c2ea38a6083054320882fddb", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -4294,6 +4294,36 @@ Embedded PowerPC system in little endian mode.\n The Renesas RL78 processor.\n This configuration is intended for embedded systems.\n \n+@html\n+<hr />\n+@end html\n+@anchor{riscv32-x-elf}\n+@heading riscv32-*-elf\n+The RISC-V RV32 instruction set.\n+This configuration is intended for embedded systems.\n+\n+@html\n+<hr />\n+@end html\n+@anchor{riscv64-x-elf}\n+@heading riscv64-*-elf\n+The RISC-V RV64 instruction set.\n+This configuration is intended for embedded systems.\n+\n+@html\n+<hr />\n+@end html\n+@anchor{riscv32-x-linux}\n+@heading riscv32-*-linux\n+The RISC-V RV32 instruction set running GNU/Linux.\n+\n+@html\n+<hr />\n+@end html\n+@anchor{riscv64-x-linux}\n+@heading riscv64-*-linux\n+The RISC-V RV64 instruction set running GNU/Linux.\n+\n @html\n <hr />\n @end html"}, {"sha": "ce3c704e70b91f277767c5466b68e05ec8975805", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -1026,6 +1026,20 @@ See RS/6000 and PowerPC Options.\n -mstack-protector-guard-offset=@var{offset} @gol\n -mlra  -mno-lra}\n \n+@emph{RISC-V Options}\n+@gccoptlist{-mbranch-cost=@var{N-instruction} @gol\n+-mmemcpy -mno-memcpy @gol\n+-mplt -mno-plt @gol\n+-mabi=@var{ABI-string} @gol\n+-mfdiv -mno-fdiv @gol\n+-mdiv -mno-div @gol\n+-march=@var{ISA-string} @gol\n+-mtune=@var{processor-string} @gol\n+-msmall-data-limit=@var{N-bytes} @gol\n+-msave-restore -mno-save-restore @gol\n+-mcmodel=@var{code-model} @gol\n+-mexplicit-relocs -mno-explicit-relocs @gol}\n+\n @emph{RX Options}\n @gccoptlist{-m64bit-doubles  -m32bit-doubles  -fpu  -nofpu@gol\n -mcpu=@gol\n@@ -13744,6 +13758,7 @@ platform.\n * PowerPC Options::\n * RL78 Options::\n * RS/6000 and PowerPC Options::\n+* RISC-V Options::\n * RX Options::\n * S/390 and zSeries Options::\n * Score Options::\n@@ -22137,6 +22152,70 @@ offset from that base register. The default for those is as specified in the\n relevant ABI.\n @end table\n \n+@node RISC-V Options\n+@subsection RISC-V Options\n+@cindex RISC-V Options\n+\n+These command-line options are defined for RISC-V targets:\n+\n+@table @gcctabopt\n+@item -mbranch-cost=@var{n}\n+@opindex mbranch-cost\n+Set the cost of branches to roughly @var{n} instructions.\n+\n+@item -mmemcpy\n+@itemx -mno-memcpy\n+@opindex mmemcpy\n+Don't optimize block moves.\n+\n+@item -mplt\n+@itemx -mno-plt\n+@opindex plt\n+When generating PIC code, allow the use of PLTs. Ignored for non-PIC.\n+\n+@item -mabi=@var{ABI-string}\n+@opindex mabi\n+Specify integer and floating-point calling convention.  This defaults to the\n+natural calling convention: e.g.@ LP64 for RV64I, ILP32 for RV32I, LP64D for\n+RV64G.\n+\n+@item -mfdiv\n+@itemx -mno-fdiv\n+@opindex mfdiv\n+Use hardware floating-point divide and square root instructions.  This requires\n+the F or D extensions for floating-point registers.\n+\n+@item -mdiv\n+@itemx -mno-div\n+@opindex mdiv\n+Use hardware instructions for integer division.  This requires the M extension.\n+\n+@item -march=@var{ISA-string}\n+@opindex march\n+Generate code for given RISC-V ISA (e.g.@ @samp{rv64im}).  ISA strings must be\n+lower-case.  Examples include @samp{rv64i}, @samp{rv32g}, and @samp{rv32imaf}.\n+\n+@item -mtune=@var{processor-string}\n+@opindex mtune\n+Optimize the output for the given processor, specified by microarchitecture\n+name.\n+\n+@item -msmall-data-limit=@var{n}\n+@opindex msmall-data-limit\n+Put global and static data smaller than @var{n} bytes into a special section\n+(on some targets).\n+\n+@item -msave-restore\n+@itemx -mno-save-restore\n+@opindex msave-restore\n+Use smaller but slower prologue and epilogue code.\n+\n+@item -mcmodel=@var{code-model}\n+@opindex mcmodel\n+Specify the code model.\n+\n+@end table\n+\n @node RX Options\n @subsection RX Options\n @cindex RX Options"}, {"sha": "3f710740b220f01e13dc031d4b02eb800805150c", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09cae7507d9e88f2b05cf3a9404bf181e65ccbac/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=09cae7507d9e88f2b05cf3a9404bf181e65ccbac", "patch": "@@ -3362,6 +3362,26 @@ The @code{X} register.\n \n @end table\n \n+@item RISC-V---@file{config/riscv/constraints.md}\n+@table @code\n+\n+@item f\n+A floating-point register (if availiable).\n+\n+@item I\n+An I-type 12-bit signed immediate.\n+\n+@item J\n+Integer zero.\n+\n+@item K\n+A 5-bit unsigned immediate for CSR access instructions.\n+\n+@item A\n+An address that is held in a general-purpose register.\n+\n+@end table\n+\n @item RX---@file{config/rx/constraints.md}\n @table @code\n @item Q"}]}