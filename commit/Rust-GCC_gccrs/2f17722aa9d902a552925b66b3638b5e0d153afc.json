{"sha": "2f17722aa9d902a552925b66b3638b5e0d153afc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYxNzcyMmFhOWQ5MDJhNTUyOTI1YjY2YjM2MzhiNWUwZDE1M2FmYw==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1993-10-05T05:52:39Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1993-10-05T05:52:39Z"}, "message": "(pushxf,movxf,extenddfxf2,extendsfxf2): Handle XFmode write to MEM by eading...\n\n(pushxf,movxf,extenddfxf2,extendsfxf2): Handle XFmode write to MEM by\neading back value after write if source doesn't die.\n(movxf,extenddfxf2,extendsfxf2): Don't emit fld before calling\noutput_to_reg: output_to_reg does that now.\n\nFrom-SVN: r5601", "tree": {"sha": "5832234291169d20959c2b8e180b00c30be922f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5832234291169d20959c2b8e180b00c30be922f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f17722aa9d902a552925b66b3638b5e0d153afc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f17722aa9d902a552925b66b3638b5e0d153afc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f17722aa9d902a552925b66b3638b5e0d153afc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f17722aa9d902a552925b66b3638b5e0d153afc/comments", "author": null, "committer": null, "parents": [{"sha": "303872755c1358d1a120c05959a046505d1176c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/303872755c1358d1a120c05959a046505d1176c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/303872755c1358d1a120c05959a046505d1176c4"}], "stats": {"total": 60, "additions": 17, "deletions": 43}, "files": [{"sha": "5a87914ecf33c501cebcbfc4f0dd49cad7ffe3cb", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 17, "deletions": 43, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f17722aa9d902a552925b66b3638b5e0d153afc/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f17722aa9d902a552925b66b3638b5e0d153afc/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=2f17722aa9d902a552925b66b3638b5e0d153afc", "patch": "@@ -1154,13 +1154,10 @@\n       xops[2] = stack_pointer_rtx;\n \n       output_asm_insn (AS2 (sub%L2,%1,%2), xops);\n-      if (find_regno_note (insn, REG_DEAD, FIRST_STACK_REG))\n-        output_asm_insn (AS1 (fstp%T0,%0), xops);\n-      else\n-        {\n-          output_asm_insn (AS1 (fld,%y1), operands);\n-          output_asm_insn (AS1 (fstp%T0,%y0), xops);\n-         }\n+      output_asm_insn (AS1 (fstp%T0,%0), xops);\n+      if (! find_regno_note (insn, REG_DEAD, FIRST_STACK_REG))\n+\toutput_asm_insn (AS1 (fld%T0,%0), xops);\n+\n       RET;\n     }\n   else\n@@ -1211,11 +1208,6 @@\n \n   if (STACK_TOP_P (operands[1]) && NON_STACK_REG_P (operands[0]))\n     {\n-      if (stack_top_dies == 0)\n-\t{\n-\t  output_asm_insn (AS1 (fld,%y1), operands);\n-\t  stack_top_dies = 1;\n-\t}\n       output_to_reg (operands[0], stack_top_dies);\n       RET;\n     }\n@@ -1224,13 +1216,11 @@\n \n   if (STACK_TOP_P (operands[1]))\n     {\n-      if (stack_top_dies)\n-\treturn AS1 (fstp%z0,%y0);\n-      else\n-\t{\n-        output_asm_insn (AS1 (fld,%y1), operands);\n-\treturn AS1 (fstp%z0,%y0);\n-\t}\n+      output_asm_insn (AS1 (fstp%z0,%y0), operands);\n+      if (! stack_top_dies)\n+\treturn AS1 (fld%z0,%y0);\n+\n+      RET;\n     }\n \n   /* Handle other kinds of reads to the 387 */\n@@ -1491,11 +1481,6 @@\n \n   if (NON_STACK_REG_P (operands[0]))\n     {\n-      if (stack_top_dies == 0)\n-\t{\n-\t  output_asm_insn (AS1 (fld,%y1), operands);\n-\t  stack_top_dies = 1;\n-\t}\n       output_to_reg (operands[0], stack_top_dies);\n       RET;\n     }\n@@ -1505,13 +1490,10 @@\n \n   if (GET_CODE (operands[0]) == MEM)\n     {\n-      if (stack_top_dies)\n-\treturn AS1 (fstp%z0,%y0);\n-      else\n-\t{\n-\t  output_asm_insn (AS1 (fld,%y1), operands);\n-\t  return AS1 (fstp%z0,%0);\n-\t}\n+      output_asm_insn (AS1 (fstp%z0,%y0), operands);\n+      if (! stack_top_dies)\n+\treturn AS1 (fld%z0,%y0);\n+      RET;\n     }\n \n   abort ();\n@@ -1534,11 +1516,6 @@\n \n   if (NON_STACK_REG_P (operands[0]))\n     {\n-      if (stack_top_dies == 0)\n-\t{\n-\t  output_asm_insn (AS1 (fld,%y1), operands);\n-\t  stack_top_dies = 1;\n-\t}\n       output_to_reg (operands[0], stack_top_dies);\n       RET;\n     }\n@@ -1548,13 +1525,10 @@\n \n   if (GET_CODE (operands[0]) == MEM)\n     {\n-      if (stack_top_dies)\n-\treturn AS1 (fstp%z0,%y0);\n-      else\n-\t{\n-\t  output_asm_insn (AS1 (fld,%y1), operands);\n-\t  return AS1 (fstp%z0,%0);\n-\t}\n+      output_asm_insn (AS1 (fstp%z0,%y0), operands);\n+      if (! stack_top_dies)\n+\treturn AS1 (fld%z0,%y0);\n+      RET;\n     }\n \n   abort ();"}]}