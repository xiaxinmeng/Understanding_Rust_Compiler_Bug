{"sha": "c4bda9f0cf757474d9970e3e9174a76eb31b0444", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRiZGE5ZjBjZjc1NzQ3NGQ5OTcwZTNlOTE3NGE3NmViMzFiMDQ0NA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2004-11-03T17:32:34Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-11-03T17:32:34Z"}, "message": "lambda-code.c (lambda_compute_auxillary_space): Update comments.\n\n2004-11-02  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* lambda-code.c (lambda_compute_auxillary_space): Update comments.\n\t(lambda_compute_target_space). Ditto.\n\t* lambda.h (lambda_trans_matrix): Ditto.\n\t(lambda_linear_expression): Ditto.\n\t(lambda_body_vector): Ditto.\n\t(lambda_loopnest): Ditto.\n\t* tree-loop-linear.c (gather_interchange_stats): Combine tests,\n\tupdate comments, and remove pointless addition of 0.\n\t(linear_transform_loops): Update comments.\n\nFrom-SVN: r90029", "tree": {"sha": "8465e9dd44bb38c923701c2c41d78e75fb2c644d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8465e9dd44bb38c923701c2c41d78e75fb2c644d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4bda9f0cf757474d9970e3e9174a76eb31b0444", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4bda9f0cf757474d9970e3e9174a76eb31b0444", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4bda9f0cf757474d9970e3e9174a76eb31b0444", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4bda9f0cf757474d9970e3e9174a76eb31b0444/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "308d51892fb3d625bbaa1b458a52d72527fd92cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/308d51892fb3d625bbaa1b458a52d72527fd92cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/308d51892fb3d625bbaa1b458a52d72527fd92cc"}], "stats": {"total": 105, "additions": 80, "deletions": 25}, "files": [{"sha": "012836072e3223c6a6901efbe2458cb0b6084ef7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4bda9f0cf757474d9970e3e9174a76eb31b0444/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4bda9f0cf757474d9970e3e9174a76eb31b0444/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c4bda9f0cf757474d9970e3e9174a76eb31b0444", "patch": "@@ -1,3 +1,15 @@\n+2004-11-02  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* lambda-code.c (lambda_compute_auxillary_space): Update comments.\n+\t(lambda_compute_target_space). Ditto.\n+\t* lambda.h (lambda_trans_matrix): Ditto.\n+\t(lambda_linear_expression): Ditto.\n+\t(lambda_body_vector): Ditto.\n+\t(lambda_loopnest): Ditto.\n+\t* tree-loop-linear.c (gather_interchange_stats): Combine tests,\n+\tupdate comments, and remove pointless addition of 0.\n+\t(linear_transform_loops): Update comments.\n+\n 2004-11-03  Sebastian Pop  <pop@cri.ensmp.fr>\n \n \t* tree.c (tree_fold_gcd): Use FLOOR_MOD_EXPR instead of"}, {"sha": "0d066b936dfdaf1c752b9274e279587537c38707", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4bda9f0cf757474d9970e3e9174a76eb31b0444/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4bda9f0cf757474d9970e3e9174a76eb31b0444/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=c4bda9f0cf757474d9970e3e9174a76eb31b0444", "patch": "@@ -651,7 +651,19 @@ compute_nest_using_fourier_motzkin (int size,\n }\n \n /* Compute the loop bounds for the auxiliary space NEST.\n-   Input system used is Ax <= b.  TRANS is the unimodular transformation.  */\n+   Input system used is Ax <= b.  TRANS is the unimodular transformation.  \n+   Given the original nest, this function will \n+   1. Convert the nest into matrix form, which consists of a matrix for the\n+   coefficients, a matrix for the \n+   invariant coefficients, and a vector for the constants.  \n+   2. Use the matrix form to calculate the lattice base for the nest (which is\n+   a dense space) \n+   3. Compose the dense space transform with the user specified transform, to \n+   get a transform we can easily calculate transformed bounds for.\n+   4. Multiply the composed transformation matrix times the matrix form of the\n+   loop.\n+   5. Transform the newly created matrix (from step 4) back into a loop nest\n+   using fourier motzkin elimination to figure out the bounds.  */\n \n static lambda_loopnest\n lambda_compute_auxillary_space (lambda_loopnest nest,\n@@ -786,9 +798,11 @@ lambda_compute_auxillary_space (lambda_loopnest nest,\n }\n \n /* Compute the loop bounds for the target space, using the bounds of\n-   the auxiliary nest AUXILLARY_NEST, and the triangular matrix H.  This is\n-   done by matrix multiplication and then transformation of the new matrix\n-   back into linear expression form.\n+   the auxiliary nest AUXILLARY_NEST, and the triangular matrix H.  \n+   The target space loop bounds are computed by multiplying the triangular\n+   matrix H by the auxillary nest, to get the new loop bounds.  The sign of\n+   the loop steps (positive or negative) is then used to swap the bounds if\n+   the loop counts downwards.\n    Return the target loopnest.  */\n \n static lambda_loopnest"}, {"sha": "98fe6bd1ca67698edce84101f1eb71ca1a04f36b", "filename": "gcc/lambda.h", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4bda9f0cf757474d9970e3e9174a76eb31b0444/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4bda9f0cf757474d9970e3e9174a76eb31b0444/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=c4bda9f0cf757474d9970e3e9174a76eb31b0444", "patch": "@@ -29,11 +29,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    and scalar multiplication.  In this vector space, an element is a list of\n    integers.  */\n typedef int *lambda_vector;\n+\n /* An integer matrix.  A matrix consists of m vectors of length n (IE\n    all vectors are the same length).  */\n typedef lambda_vector *lambda_matrix;\n \n-/* A transformation matrix.  */\n+/* A transformation matrix, which is a self-contained ROWSIZE x COLSIZE\n+   matrix.  Rather than use floats, we simply keep a single DENOMINATOR that\n+   represents the denominator for every element in the matrix.  */\n typedef struct\n {\n   lambda_matrix matrix;\n@@ -46,7 +49,15 @@ typedef struct\n #define LTM_COLSIZE(T) ((T)->colsize)\n #define LTM_DENOMINATOR(T) ((T)->denominator)\n \n-/* A vector representing a statement in the body of a loop.  */\n+/* A vector representing a statement in the body of a loop.\n+   The COEFFICIENTS vector contains a coefficient for each induction variable\n+   in the loop nest containing the statement.\n+   The DENOMINATOR represents the denominator for each coefficient in the\n+   COEFFICIENT vector.\n+\n+   This structure is used during code generation in order to rewrite the old\n+   induction variable uses in a statement in terms of the newly created\n+   induction variables.  */\n typedef struct\n {\n   lambda_vector coefficients;\n@@ -57,7 +68,18 @@ typedef struct\n #define LBV_SIZE(T) ((T)->size)\n #define LBV_DENOMINATOR(T) ((T)->denominator)\n \n-/* Piecewise linear expression.  */\n+/* Piecewise linear expression.  \n+   This structure represents a linear expression with terms for the invariants\n+   and induction variables of a loop. \n+   COEFFICIENTS is a vector of coefficients for the induction variables, one\n+   per loop in the loop nest.\n+   CONSTANT is the constant portion of the linear expression\n+   INVARIANT_COEFFICIENTS is a vector of coefficients for the loop invariants,\n+   one per invariant.\n+   DENOMINATOR is the denominator for all of the coefficients and constants in\n+   the expression.  \n+   The linear expressions can be linked together using the NEXT field, in\n+   order to represent MAX or MIN of a group of linear expressions.  */\n typedef struct lambda_linear_expression_s\n {\n   lambda_vector coefficients;\n@@ -77,7 +99,12 @@ lambda_linear_expression lambda_linear_expression_new (int, int);\n void print_lambda_linear_expression (FILE *, lambda_linear_expression, int,\n \t\t\t\t     int, char);\n \n-/* Loop structure.  */\n+/* Loop structure.  Our loop structure consists of a constant representing the\n+   STEP of the loop, a set of linear expressions representing the LOWER_BOUND\n+   of the loop, a set of linear expressions representing the UPPER_BOUND of\n+   the loop, and a set of linear expressions representing the LINEAR_OFFSET of\n+   the loop.  The linear offset is a set of linear expressions that are\n+   applied to *both* the lower bound, and the upper bound.  */\n typedef struct lambda_loop_s\n {\n   lambda_linear_expression lower_bound;\n@@ -91,7 +118,12 @@ typedef struct lambda_loop_s\n #define LL_LINEAR_OFFSET(T) ((T)->linear_offset)\n #define LL_STEP(T)   ((T)->step)\n \n-/* Loop nest structure.  */\n+/* Loop nest structure.  \n+   The loop nest structure consists of a set of loop structures (defined\n+   above) in LOOPS, along with an integer representing the DEPTH of the loop,\n+   and an integer representing the number of INVARIANTS in the loop.  Both of\n+   these integers are used to size the associated coefficient vectors in the\n+   linear expression structures.  */\n typedef struct\n {\n   lambda_loop *loops;"}, {"sha": "fcb93eaf460d8ab73da8c0e25d456508d5838398", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4bda9f0cf757474d9970e3e9174a76eb31b0444/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4bda9f0cf757474d9970e3e9174a76eb31b0444/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=c4bda9f0cf757474d9970e3e9174a76eb31b0444", "patch": "@@ -88,7 +88,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    DEPENDENCE_STEPS = 3000\n    NB_DEPS_NOT_CARRIED_BY_LOOP = 7\n    ACCESS_STRIDES = 8010\n-  */\n+*/\n \n static void\n gather_interchange_stats (varray_type dependence_relations, \n@@ -112,21 +112,17 @@ gather_interchange_stats (varray_type dependence_relations,\n \t(struct data_dependence_relation *) \n \tVARRAY_GENERIC_PTR (dependence_relations, i);\n \n-      /* Compute the dependence strides.  */\n+      /* If we don't know anything about this dependence, or the distance\n+\t vector is NULL, or there is no dependence, then there is no reuse of\n+\t data.  */\n \n-      if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n-\t{\n-\t  (*dependence_steps) += 0;\n-\t  continue;\n-\t}\n+      if (DDR_DIST_VECT (ddr) == NULL\n+\t  || DDR_ARE_DEPENDENT (ddr) == chrec_dont_know\n+\t  || DDR_ARE_DEPENDENT (ddr) == chrec_known)\n+\tcontinue;\n+      \n \n-      /* When we know that there is no dependence, we know that there\n-\t is no reuse of the data.  */\n-      if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n-\t{\n-\t  (*dependence_steps) += 0;\n-\t  continue;\n-\t}\n+      \n       dist = DDR_DIST_VECT (ddr)[loop_number];\n       if (dist == 0)\n \t(*nb_deps_not_carried_by_loop) += 1;\n@@ -164,7 +160,8 @@ gather_interchange_stats (varray_type dependence_relations,\n     }\n }\n \n-/* Apply to TRANS any loop interchange that minimize inner loop steps.\n+/* Attempt to apply interchange transformations to TRANS to maximize the\n+   spatial and temporal locality of the loop.  \n    Returns the new transform matrix.  The smaller the reuse vector\n    distances in the inner loops, the fewer the cache misses.\n    FIRST_LOOP is the loop->num of the first loop in the analyzed loop\n@@ -238,7 +235,7 @@ void\n linear_transform_loops (struct loops *loops)\n {\n   unsigned int i;\n-\n+  \n   compute_immediate_uses (TDFA_USE_OPS | TDFA_USE_VOPS, NULL);\n   for (i = 1; i < loops->num; i++)\n     {"}]}