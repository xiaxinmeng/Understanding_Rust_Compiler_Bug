{"sha": "f25a62a5f34a0f33b00238c6c681edac038e1078", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI1YTYyYTVmMzRhMGYzM2IwMDIzOGM2YzY4MWVkYWMwMzhlMTA3OA==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-09-18T12:02:50Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2008-09-18T12:02:50Z"}, "message": "re PR fortran/37507 (Print location in (DE)ALLOCATION errors)\n\n2008-09-18  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/37507\n\t* trans.h (gfc_trans_runtime_error): New method.\n\t(gfc_trans_runtime_error_vararg): New method.\n\t(gfc_allocate_array_with_status): New argument `expr' for locus/varname.\n\t(gfc_deallocate_array_with_status): Ditto.\n\t* trans-array.h (gfc_array_deallocate): Ditto.\n\t* trans.c (gfc_trans_runtime_error): New method.\n\t(gfc_trans_runtime_error_vararg): New method, moved parts of the code\n\tfrom gfc_trans_runtime_check here.\n\t(gfc_trans_runtime_error_check): Moved code partly to new method.\n\t(gfc_call_malloc): Fix tab-indentation.\n\t(gfc_allocate_array_with_status): New argument `expr' and call\n\tgfc_trans_runtime_error for error reporting to include locus.\n\t(gfc_deallocate_with_status): Ditto.\n\t* trans-stmt.c (gfc_trans_deallocate): Pass expr as new argument.\n\t* trans-array.c (gfc_array_allocate): Ditto.\n\t(gfc_array_deallocate): New argument `expr', passed on.\n\t(gfc_trans_dealloc_allocated): Pass NULL for expr.\n\t* trans-openmp.c (gfc_omp_clause_default): Ditto.\n\n2008-09-18  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/37507\n\t* gfortran.dg/allocate_error_1.f90: New test.\n\t* gfortran.dg/deallocate_error_1.f90: New test.\n\t* gfortran.dg/deallocate_error_2.f90: New test.\n\nFrom-SVN: r140451", "tree": {"sha": "e5471c68dc29810955e55c653efe13687946b17a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5471c68dc29810955e55c653efe13687946b17a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f25a62a5f34a0f33b00238c6c681edac038e1078", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f25a62a5f34a0f33b00238c6c681edac038e1078", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f25a62a5f34a0f33b00238c6c681edac038e1078", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f25a62a5f34a0f33b00238c6c681edac038e1078/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e7089ecf1c8a67d5572ada8ecd3b3d99f420089c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7089ecf1c8a67d5572ada8ecd3b3d99f420089c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7089ecf1c8a67d5572ada8ecd3b3d99f420089c"}], "stats": {"total": 259, "additions": 197, "deletions": 62}, "files": [{"sha": "d3d36903beca61adf61f178d7d7d5bc758ce12a5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f25a62a5f34a0f33b00238c6c681edac038e1078", "patch": "@@ -1,3 +1,25 @@\n+2008-09-18  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/37507\n+\t* trans.h (gfc_trans_runtime_error): New method.\n+\t(gfc_trans_runtime_error_vararg): New method.\n+\t(gfc_allocate_array_with_status): New argument `expr' for locus/varname.\n+\t(gfc_deallocate_array_with_status): Ditto.\n+\t* trans-array.h (gfc_array_deallocate): Ditto.\n+\t* trans.c (gfc_trans_runtime_error): New method.\n+\t(gfc_trans_runtime_error_vararg): New method, moved parts of the code\n+\tfrom gfc_trans_runtime_check here.\n+\t(gfc_trans_runtime_error_check): Moved code partly to new method.\n+\t(gfc_call_malloc): Fix tab-indentation.\n+\t(gfc_allocate_array_with_status): New argument `expr' and call\n+\tgfc_trans_runtime_error for error reporting to include locus.\n+\t(gfc_deallocate_with_status): Ditto.\n+\t* trans-stmt.c (gfc_trans_deallocate): Pass expr as new argument.\n+\t* trans-array.c (gfc_array_allocate): Ditto.\n+\t(gfc_array_deallocate): New argument `expr', passed on.\n+\t(gfc_trans_dealloc_allocated): Pass NULL for expr.\n+\t* trans-openmp.c (gfc_omp_clause_default): Ditto.\n+\n 2008-09-18  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/37274"}, {"sha": "f4af4f25da1864503d36728dc2b34515194ded93", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=f25a62a5f34a0f33b00238c6c681edac038e1078", "patch": "@@ -3796,7 +3796,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n \n   /* The allocate_array variants take the old pointer as first argument.  */\n   if (allocatable_array)\n-    tmp = gfc_allocate_array_with_status (&se->pre, pointer, size, pstat);\n+    tmp = gfc_allocate_array_with_status (&se->pre, pointer, size, pstat, expr);\n   else\n     tmp = gfc_allocate_with_status (&se->pre, size, pstat);\n   tmp = fold_build2 (MODIFY_EXPR, void_type_node, pointer, tmp);\n@@ -3822,7 +3822,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n /*GCC ARRAYS*/\n \n tree\n-gfc_array_deallocate (tree descriptor, tree pstat)\n+gfc_array_deallocate (tree descriptor, tree pstat, gfc_expr* expr)\n {\n   tree var;\n   tree tmp;\n@@ -3834,7 +3834,7 @@ gfc_array_deallocate (tree descriptor, tree pstat)\n   STRIP_NOPS (var);\n \n   /* Parameter is the address of the data component.  */\n-  tmp = gfc_deallocate_with_status (var, pstat, false);\n+  tmp = gfc_deallocate_with_status (var, pstat, false, expr);\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* Zero the data pointer.  */\n@@ -5341,7 +5341,7 @@ gfc_trans_dealloc_allocated (tree descriptor)\n   /* Call array_deallocate with an int * present in the second argument.\n      Although it is ignored here, it's presence ensures that arrays that\n      are already deallocated are ignored.  */\n-  tmp = gfc_deallocate_with_status (var, NULL_TREE, true);\n+  tmp = gfc_deallocate_with_status (var, NULL_TREE, true, NULL);\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* Zero the data pointer.  */"}, {"sha": "2cc9d5caf28c9bdbe6551970e31bdec49262ed04", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=f25a62a5f34a0f33b00238c6c681edac038e1078", "patch": "@@ -20,7 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n /* Generate code to free an array.  */\n-tree gfc_array_deallocate (tree, tree);\n+tree gfc_array_deallocate (tree, tree, gfc_expr*);\n \n /* Generate code to initialize an allocate an array.  Statements are added to\n    se, which should contain an expression for the array descriptor.  */"}, {"sha": "04ec4d4c12c36c785f90dae62301eb8a45a6d474", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=f25a62a5f34a0f33b00238c6c681edac038e1078", "patch": "@@ -163,7 +163,7 @@ gfc_omp_clause_default_ctor (tree clause, tree decl, tree outer)\n   size = gfc_evaluate_now (fold_convert (size_type_node, size), &cond_block);\n   ptr = gfc_allocate_array_with_status (&cond_block,\n \t\t\t\t\tbuild_int_cst (pvoid_type_node, 0),\n-\t\t\t\t\tsize, NULL);\n+\t\t\t\t\tsize, NULL, NULL);\n   gfc_conv_descriptor_data_set (&cond_block, decl, ptr);\n   then_b = gfc_finish_block (&cond_block);\n \n@@ -215,7 +215,7 @@ gfc_omp_clause_copy_ctor (tree clause, tree dest, tree src)\n   size = gfc_evaluate_now (fold_convert (size_type_node, size), &block);\n   ptr = gfc_allocate_array_with_status (&block,\n \t\t\t\t\tbuild_int_cst (pvoid_type_node, 0),\n-\t\t\t\t\tsize, NULL);\n+\t\t\t\t\tsize, NULL, NULL);\n   gfc_conv_descriptor_data_set (&block, dest, ptr);\n   call = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3, ptr,\n \t\t\t  fold_convert (pvoid_type_node,\n@@ -619,7 +619,7 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n       size = gfc_evaluate_now (fold_convert (size_type_node, size), &block);\n       ptr = gfc_allocate_array_with_status (&block,\n \t\t\t\t\t    build_int_cst (pvoid_type_node, 0),\n-\t\t\t\t\t    size, NULL);\n+\t\t\t\t\t    size, NULL, NULL);\n       gfc_conv_descriptor_data_set (&block, decl, ptr);\n       gfc_add_expr_to_block (&block, gfc_trans_assignment (e1, e2, false));\n       stmt = gfc_finish_block (&block);"}, {"sha": "da227523e72de99aaa69dcc2a8ba5a649d96c8af", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=f25a62a5f34a0f33b00238c6c681edac038e1078", "patch": "@@ -4005,16 +4005,16 @@ gfc_trans_deallocate (gfc_code * code)\n \t\t   && !(!last && expr->symtree->n.sym->attr.pointer))\n \t    {\n \t      tmp = gfc_deallocate_alloc_comp (expr->ts.derived, se.expr,\n-\t\t\t\t\t\texpr->rank);\n+\t\t\t\t\t       expr->rank);\n \t      gfc_add_expr_to_block (&se.pre, tmp);\n \t    }\n \t}\n \n       if (expr->rank)\n-\ttmp = gfc_array_deallocate (se.expr, pstat);\n+\ttmp = gfc_array_deallocate (se.expr, pstat, expr);\n       else\n \t{\n-\t  tmp = gfc_deallocate_with_status (se.expr, pstat, false);\n+\t  tmp = gfc_deallocate_with_status (se.expr, pstat, false, expr);\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n \n \t  tmp = fold_build2 (MODIFY_EXPR, void_type_node,"}, {"sha": "b8f0d2dd35bdde9782d6f7c950a7e433a600abdb", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 106, "deletions": 49, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=f25a62a5f34a0f33b00238c6c681edac038e1078", "patch": "@@ -347,27 +347,31 @@ gfc_build_array_ref (tree base, tree offset, tree decl)\n }\n \n \n-/* Generate a runtime error if COND is true.  */\n+/* Generate a call to print a runtime error possibly including multiple\n+   arguments and a locus.  */\n \n-void\n-gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n-\t\t     locus * where, const char * msgid, ...)\n+tree\n+gfc_trans_runtime_error (bool error, locus* where, const char* msgid, ...)\n {\n   va_list ap;\n+\n+  va_start (ap, msgid);\n+  return gfc_trans_runtime_error_vararg (error, where, msgid, ap);\n+}\n+\n+tree\n+gfc_trans_runtime_error_vararg (bool error, locus* where, const char* msgid,\n+\t\t\t\tva_list ap)\n+{\n   stmtblock_t block;\n-  tree body;\n   tree tmp;\n-  tree tmpvar = NULL;\n   tree arg, arg2;\n   tree *argarray;\n   tree fntype;\n   char *message;\n   const char *p;\n   int line, nargs, i;\n \n-  if (integer_zerop (cond))\n-    return;\n-\n   /* Compute the number of extra arguments from the format string.  */\n   for (p = msgid, nargs = 0; *p; p++)\n     if (*p == '%')\n@@ -377,14 +381,6 @@ gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n \t  nargs++;\n       }\n \n-  if (once)\n-    {\n-       tmpvar = gfc_create_var (boolean_type_node, \"print_warning\");\n-       TREE_STATIC (tmpvar) = 1;\n-       DECL_INITIAL (tmpvar) = boolean_true_node;\n-       gfc_add_expr_to_block (pblock, tmpvar);\n-    }\n-\n   /* The code to generate the error.  */\n   gfc_start_block (&block);\n \n@@ -411,9 +407,8 @@ gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n   argarray = (tree *) alloca (sizeof (tree) * (nargs + 2));\n   argarray[0] = arg;\n   argarray[1] = arg2;\n-  va_start (ap, msgid);\n   for (i = 0; i < nargs; i++)\n-    argarray[2+i] = va_arg (ap, tree);\n+    argarray[2 + i] = va_arg (ap, tree);\n   va_end (ap);\n   \n   /* Build the function call to runtime_(warning,error)_at; because of the\n@@ -432,6 +427,41 @@ gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n \t\t\t\t nargs + 2, argarray);\n   gfc_add_expr_to_block (&block, tmp);\n \n+  return gfc_finish_block (&block);\n+}\n+\n+\n+/* Generate a runtime error if COND is true.  */\n+\n+void\n+gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n+\t\t\t locus * where, const char * msgid, ...)\n+{\n+  va_list ap;\n+  stmtblock_t block;\n+  tree body;\n+  tree tmp;\n+  tree tmpvar = NULL;\n+\n+  if (integer_zerop (cond))\n+    return;\n+\n+  if (once)\n+    {\n+       tmpvar = gfc_create_var (boolean_type_node, \"print_warning\");\n+       TREE_STATIC (tmpvar) = 1;\n+       DECL_INITIAL (tmpvar) = boolean_true_node;\n+       gfc_add_expr_to_block (pblock, tmpvar);\n+    }\n+\n+  gfc_start_block (&block);\n+\n+  /* The code to generate the error.  */\n+  va_start (ap, msgid);\n+  gfc_add_expr_to_block (&block,\n+\t\t\t gfc_trans_runtime_error_vararg (error, where,\n+\t\t\t\t\t\t\t msgid, ap));\n+\n   if (once)\n     gfc_add_modify (&block, tmpvar, boolean_false_node);\n \n@@ -524,30 +554,30 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n       void *newmem;\n     \n       if (stat)\n-        *stat = 0;\n+\t*stat = 0;\n \n       // The only time this can happen is the size wraps around.\n       if (size < 0)\n       {\n-        if (stat)\n-        {\n-          *stat = LIBERROR_ALLOCATION;\n-          newmem = NULL;\n-        }\n-        else\n-          runtime_error (\"Attempt to allocate negative amount of memory. \"\n-                         \"Possible integer overflow\");\n+\tif (stat)\n+\t{\n+\t  *stat = LIBERROR_ALLOCATION;\n+\t  newmem = NULL;\n+\t}\n+\telse\n+\t  runtime_error (\"Attempt to allocate negative amount of memory. \"\n+\t\t\t \"Possible integer overflow\");\n       }\n       else\n       {\n-        newmem = malloc (MAX (size, 1));\n-        if (newmem == NULL)\n-        {\n-          if (stat)\n-            *stat = LIBERROR_ALLOCATION;\n-          else\n-            runtime_error (\"Out of memory\");\n-        }\n+\tnewmem = malloc (MAX (size, 1));\n+\tif (newmem == NULL)\n+\t{\n+\t  if (stat)\n+\t    *stat = LIBERROR_ALLOCATION;\n+\t  else\n+\t    runtime_error (\"Out of memory\");\n+\t}\n       }\n \n       return newmem;\n@@ -668,13 +698,16 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n \t}\n \telse\n \t  runtime_error (\"Attempting to allocate already allocated array\");\n-    }  */\n+    }\n+    \n+    expr must be set to the original expression being allocated for its locus\n+    and variable name in case a runtime error has to be printed.  */\n tree\n gfc_allocate_array_with_status (stmtblock_t * block, tree mem, tree size,\n-\t\t\t\ttree status)\n+\t\t\t\ttree status, gfc_expr* expr)\n {\n   stmtblock_t alloc_block;\n-  tree res, tmp, null_mem, alloc, error, msg;\n+  tree res, tmp, null_mem, alloc, error;\n   tree type = TREE_TYPE (mem);\n \n   if (TREE_TYPE (size) != TREE_TYPE (size_type_node))\n@@ -692,9 +725,23 @@ gfc_allocate_array_with_status (stmtblock_t * block, tree mem, tree size,\n   alloc = gfc_finish_block (&alloc_block);\n \n   /* Otherwise, we issue a runtime error or set the status variable.  */\n-  msg = gfc_build_addr_expr (pchar_type_node, gfc_build_localized_cstring_const\n-\t\t\t(\"Attempting to allocate already allocated array\"));\n-  error = build_call_expr (gfor_fndecl_runtime_error, 1, msg);\n+  if (expr)\n+    {\n+      tree varname;\n+\n+      gcc_assert (expr->expr_type == EXPR_VARIABLE && expr->symtree);\n+      varname = gfc_build_cstring_const (expr->symtree->name);\n+      varname = gfc_build_addr_expr (pchar_type_node, varname);\n+\n+      error = gfc_trans_runtime_error (true, &expr->where,\n+\t\t\t\t       \"Attempting to allocate already\"\n+\t\t\t\t       \" allocated array '%s'\",\n+\t\t\t\t       varname);\n+    }\n+  else\n+    error = gfc_trans_runtime_error (true, NULL,\n+\t\t\t\t     \"Attempting to allocate already allocated\"\n+\t\t\t\t     \"array\");\n \n   if (status != NULL_TREE && !integer_zerop (status))\n     {\n@@ -775,12 +822,16 @@ gfc_call_free (tree var)\n    Moreover, if CAN_FAIL is true, then we will not emit a runtime error,\n    even when no status variable is passed to us (this is used for\n    unconditional deallocation generated by the front-end at end of\n-   each procedure).  */\n+   each procedure).\n+   \n+   If a runtime-message is possible, `expr' must point to the original\n+   expression being deallocated for its locus and variable name.  */\n tree\n-gfc_deallocate_with_status (tree pointer, tree status, bool can_fail)\n+gfc_deallocate_with_status (tree pointer, tree status, bool can_fail,\n+\t\t\t    gfc_expr* expr)\n {\n   stmtblock_t null, non_null;\n-  tree cond, tmp, error, msg;\n+  tree cond, tmp, error;\n \n   cond = fold_build2 (EQ_EXPR, boolean_type_node, pointer,\n \t\t      build_int_cst (TREE_TYPE (pointer), 0));\n@@ -790,10 +841,16 @@ gfc_deallocate_with_status (tree pointer, tree status, bool can_fail)\n   gfc_start_block (&null);\n   if (!can_fail)\n     {\n-      msg = gfc_build_addr_expr (pchar_type_node,\n-\t\t\t\t gfc_build_localized_cstring_const\n-\t\t\t\t (\"Attempt to DEALLOCATE unallocated memory.\"));\n-      error = build_call_expr (gfor_fndecl_runtime_error, 1, msg);\n+      tree varname;\n+\n+      gcc_assert (expr && expr->expr_type == EXPR_VARIABLE && expr->symtree);\n+\n+      varname = gfc_build_cstring_const (expr->symtree->name);\n+      varname = gfc_build_addr_expr (pchar_type_node, varname);\n+\n+      error = gfc_trans_runtime_error (true, &expr->where,\n+\t\t\t\t       \"Attempt to DEALLOCATE unallocated '%s'\",\n+\t\t\t\t       varname);\n     }\n   else\n     error = build_empty_stmt ();"}, {"sha": "36553ea255bfe3a2fb5f8dab5f8381f1fbb7fc5f", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=f25a62a5f34a0f33b00238c6c681edac038e1078", "patch": "@@ -450,6 +450,10 @@ void gfc_generate_constructors (void);\n /* Get the string length of an array constructor.  */\n bool get_array_ctor_strlen (stmtblock_t *, gfc_constructor *, tree *);\n \n+/* Generate a runtime error call.  */\n+tree gfc_trans_runtime_error (bool, locus*, const char*, ...);\n+tree gfc_trans_runtime_error_vararg (bool, locus*, const char*, va_list);\n+\n /* Generate a runtime warning/error check.  */\n void gfc_trans_runtime_check (bool, bool, tree, stmtblock_t *, locus *,\n \t\t\t      const char *, ...);\n@@ -461,13 +465,13 @@ tree gfc_call_free (tree);\n tree gfc_call_malloc (stmtblock_t *, tree, tree);\n \n /* Allocate memory for arrays, with optional status variable.  */\n-tree gfc_allocate_array_with_status (stmtblock_t *, tree, tree, tree);\n+tree gfc_allocate_array_with_status (stmtblock_t*, tree, tree, tree, gfc_expr*);\n \n /* Allocate memory, with optional status variable.  */\n tree gfc_allocate_with_status (stmtblock_t *, tree, tree);\n \n /* Generate code to deallocate an array.  */\n-tree gfc_deallocate_with_status (tree, tree, bool);\n+tree gfc_deallocate_with_status (tree, tree, bool, gfc_expr*);\n \n /* Generate code to call realloc().  */\n tree gfc_call_realloc (stmtblock_t *, tree, tree);"}, {"sha": "e905405bbd9e20a3256dfbb8ef02f46f3ac6873d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f25a62a5f34a0f33b00238c6c681edac038e1078", "patch": "@@ -1,3 +1,10 @@\n+2008-09-18  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/37507\n+\t* gfortran.dg/allocate_error_1.f90: New test.\n+\t* gfortran.dg/deallocate_error_1.f90: New test.\n+\t* gfortran.dg/deallocate_error_2.f90: New test.\n+\n 2008-09-18  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/37456"}, {"sha": "42a12159e2821256ab28e10fdc47edd60890f355", "filename": "gcc/testsuite/gfortran.dg/allocate_error_1.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_error_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_error_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_error_1.f90?ref=f25a62a5f34a0f33b00238c6c681edac038e1078", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do run }\n+! { dg-shouldfail \"runtime error\" }\n+! { dg-output \"At line 13.*Attempting to allocate .* 'arr'\" }\n+\n+! PR fortran/37507\n+! Check that locus is printed for ALLOCATE errors.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  INTEGER, ALLOCATABLE :: arr(:)\n+\n+  ALLOCATE (arr(5))\n+  ALLOCATE (arr(6))\n+END PROGRAM main"}, {"sha": "98ffdb3b91ad156606687593ec7cb3d6def3f180", "filename": "gcc/testsuite/gfortran.dg/deallocate_error_1.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_error_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_error_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_error_1.f90?ref=f25a62a5f34a0f33b00238c6c681edac038e1078", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do run }\n+! { dg-shouldfail \"runtime error\" }\n+! { dg-output \"At line 14.*Attempt to DEALLOCATE unallocated 'arr'\" }\n+\n+! PR fortran/37507\n+! Check that locus is printed for DEALLOCATE errors.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  INTEGER, ALLOCATABLE :: arr(:)\n+\n+  ALLOCATE (arr(5))\n+  DEALLOCATE (arr)\n+  DEALLOCATE (arr)\n+END PROGRAM main"}, {"sha": "bda1adff514c8c21a65376c9b60b51e21d0084e6", "filename": "gcc/testsuite/gfortran.dg/deallocate_error_2.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_error_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25a62a5f34a0f33b00238c6c681edac038e1078/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_error_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_error_2.f90?ref=f25a62a5f34a0f33b00238c6c681edac038e1078", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! { dg-shouldfail \"runtime error\" }\n+! { dg-output \"At line 15.*Attempt to DEALLOCATE unallocated 'ptr'\" }\n+\n+! PR fortran/37507\n+! Check that locus is printed for DEALLOCATE errors.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  INTEGER, POINTER :: ptr\n+  INTEGER, ALLOCATABLE :: arr(:)\n+\n+  ALLOCATE (ptr, arr(5))\n+  DEALLOCATE (ptr)\n+  DEALLOCATE (arr, ptr)\n+END PROGRAM main"}]}