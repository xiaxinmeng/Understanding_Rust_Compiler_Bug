{"sha": "eb6ea9e54f1f275fd6ec3c61662243ca0165bd64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI2ZWE5ZTU0ZjFmMjc1ZmQ2ZWMzYzYxNjYyMjQzY2EwMTY1YmQ2NA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-09-03T07:38:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-09-03T08:15:03Z"}, "message": "Look at fullest view when checking for static types in unnesting\n\nWhen seeing if any bound involved in a type is an uplevel reference,\nwe must look at the fullest view of a type, since that's what the\nbackends will do.  Similarly for private types. We introduce\nGet_Fullest_View for that purpose.\n\n\t* sem_util.ads, sem_util.adb (Get_Fullest_View): New procedure.\n\t* exp_unst.adb (Check Static_Type): Do all processing on fullest\n\tview of specified type.", "tree": {"sha": "26ac38333bb327c5b10e857c997a58d2a583c191", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26ac38333bb327c5b10e857c997a58d2a583c191"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb6ea9e54f1f275fd6ec3c61662243ca0165bd64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb6ea9e54f1f275fd6ec3c61662243ca0165bd64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb6ea9e54f1f275fd6ec3c61662243ca0165bd64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb6ea9e54f1f275fd6ec3c61662243ca0165bd64/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "433734126996b6fc4fc99b594421510f928a7bb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/433734126996b6fc4fc99b594421510f928a7bb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/433734126996b6fc4fc99b594421510f928a7bb9"}], "stats": {"total": 109, "additions": 96, "deletions": 13}, "files": [{"sha": "ffc30c304d1f44f4b446446062c776f9c3321275", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6ea9e54f1f275fd6ec3c61662243ca0165bd64/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6ea9e54f1f275fd6ec3c61662243ca0165bd64/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=eb6ea9e54f1f275fd6ec3c61662243ca0165bd64", "patch": "@@ -471,21 +471,23 @@ package body Exp_Unst is\n             Callee : Entity_Id;\n \n             procedure Check_Static_Type\n-              (T                : Entity_Id;\n+              (In_T             : Entity_Id;\n                N                : Node_Id;\n                DT               : in out Boolean;\n                Check_Designated : Boolean := False);\n-            --  Given a type T, checks if it is a static type defined as a type\n-            --  with no dynamic bounds in sight. If so, the only action is to\n-            --  set Is_Static_Type True for T. If T is not a static type, then\n-            --  all types with dynamic bounds associated with T are detected,\n-            --  and their bounds are marked as uplevel referenced if not at the\n-            --  library level, and DT is set True. If N is specified, it's the\n-            --  node that will need to be replaced. If not specified, it means\n-            --  we can't do a replacement because the bound is implicit.\n-\n-            --  If Check_Designated is True and T or its full view is an access\n-            --  type, check whether the designated type has dynamic bounds.\n+            --  Given a type In_T, checks if it is a static type defined as\n+            --  a type with no dynamic bounds in sight. If so, the only\n+            --  action is to set Is_Static_Type True for In_T. If In_T is\n+            --  not a static type, then all types with dynamic bounds\n+            --  associated with In_T are detected, and their bounds are\n+            --  marked as uplevel referenced if not at the library level,\n+            --  and DT is set True. If N is specified, it's the node that\n+            --  will need to be replaced. If not specified, it means we\n+            --  can't do a replacement because the bound is implicit.\n+\n+            --  If Check_Designated is True and In_T or its full view\n+            --  is an access type, check whether the designated type\n+            --  has dynamic bounds.\n \n             procedure Note_Uplevel_Ref\n               (E      : Entity_Id;\n@@ -505,11 +507,13 @@ package body Exp_Unst is\n             -----------------------\n \n             procedure Check_Static_Type\n-              (T                : Entity_Id;\n+              (In_T             : Entity_Id;\n                N                : Node_Id;\n                DT               : in out Boolean;\n                Check_Designated : Boolean := False)\n             is\n+               T : constant Entity_Id := Get_Fullest_View (In_T);\n+\n                procedure Note_Uplevel_Bound (N : Node_Id; Ref : Node_Id);\n                --  N is the bound of a dynamic type. This procedure notes that\n                --  this bound is uplevel referenced, it can handle references"}, {"sha": "a80cc5c5e156f5cd45b7bbb8f940c3b440d73471", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6ea9e54f1f275fd6ec3c61662243ca0165bd64/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6ea9e54f1f275fd6ec3c61662243ca0165bd64/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=eb6ea9e54f1f275fd6ec3c61662243ca0165bd64", "patch": "@@ -9958,6 +9958,79 @@ package body Sem_Util is\n       end if;\n    end Get_Enum_Lit_From_Pos;\n \n+   ----------------------\n+   -- Get_Fullest_View --\n+   ----------------------\n+\n+   function Get_Fullest_View\n+     (E : Entity_Id; Include_PAT : Boolean := True) return Entity_Id is\n+   begin\n+      --  Strictly speaking, the recursion below isn't necessary, but\n+      --  it's both simplest and safest.\n+\n+      case Ekind (E) is\n+         when Incomplete_Kind =>\n+            if From_Limited_With (E) then\n+               return Get_Fullest_View (Non_Limited_View (E), Include_PAT);\n+            elsif Present (Full_View (E)) then\n+               return Get_Fullest_View (Full_View (E), Include_PAT);\n+            elsif Ekind (E) = E_Incomplete_Subtype then\n+               return Get_Fullest_View (Etype (E));\n+            end if;\n+\n+         when Private_Kind =>\n+            if Present (Underlying_Full_View (E)) then\n+               return\n+                 Get_Fullest_View (Underlying_Full_View (E), Include_PAT);\n+            elsif Present (Full_View (E)) then\n+               return Get_Fullest_View (Full_View (E), Include_PAT);\n+            elsif Etype (E) /= E then\n+               return Get_Fullest_View (Etype (E), Include_PAT);\n+            end if;\n+\n+         when Array_Kind =>\n+            if Include_PAT and then Present (Packed_Array_Impl_Type (E)) then\n+               return Get_Fullest_View (Packed_Array_Impl_Type (E));\n+            end if;\n+\n+         when E_Record_Subtype =>\n+            if Present (Cloned_Subtype (E)) then\n+               return Get_Fullest_View (Cloned_Subtype (E), Include_PAT);\n+            end if;\n+\n+         when E_Class_Wide_Type =>\n+            return Get_Fullest_View (Root_Type (E), Include_PAT);\n+\n+         when  E_Class_Wide_Subtype =>\n+            if Present (Equivalent_Type (E)) then\n+               return Get_Fullest_View (Equivalent_Type (E), Include_PAT);\n+            elsif Present (Cloned_Subtype (E)) then\n+               return Get_Fullest_View (Cloned_Subtype (E), Include_PAT);\n+            end if;\n+\n+         when E_Protected_Type | E_Protected_Subtype\n+            | E_Task_Type |  E_Task_Subtype =>\n+            if Present (Corresponding_Record_Type (E)) then\n+               return Get_Fullest_View (Corresponding_Record_Type (E),\n+                                        Include_PAT);\n+            end if;\n+\n+         when E_Access_Protected_Subprogram_Type\n+            | E_Anonymous_Access_Protected_Subprogram_Type =>\n+            if Present (Equivalent_Type (E)) then\n+               return Get_Fullest_View (Equivalent_Type (E), Include_PAT);\n+            end if;\n+\n+         when E_Access_Subtype =>\n+            return Get_Fullest_View (Base_Type (E), Include_PAT);\n+\n+         when others =>\n+            null;\n+      end case;\n+\n+      return E;\n+   end Get_Fullest_View;\n+\n    ------------------------\n    -- Get_Generic_Entity --\n    ------------------------"}, {"sha": "e2147e04beee0010d8f60482f0698da5eb8e4e15", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6ea9e54f1f275fd6ec3c61662243ca0165bd64/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6ea9e54f1f275fd6ec3c61662243ca0165bd64/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=eb6ea9e54f1f275fd6ec3c61662243ca0165bd64", "patch": "@@ -1228,6 +1228,12 @@ package Sem_Util is\n    --    UFull_Typ - the underlying full view, if the full view is private\n    --    CRec_Typ  - the corresponding record type of the full views\n \n+   function Get_Fullest_View\n+     (E : Entity_Id; Include_PAT : Boolean := True) return Entity_Id;\n+   --  Get the fullest possible view of E, looking through private,\n+   --  limited, packed array and other implementation types.  If Include_PAT\n+   --  is False, don't look inside packed array types.\n+\n    function Has_Access_Values (T : Entity_Id) return Boolean;\n    --  Returns true if type or subtype T is an access type, or has a component\n    --  (at any recursive level) that is an access type. This is a conservative"}]}