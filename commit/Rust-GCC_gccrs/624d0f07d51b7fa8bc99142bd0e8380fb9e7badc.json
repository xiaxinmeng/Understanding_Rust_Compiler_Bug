{"sha": "624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI0ZDBmMDdkNTFiN2ZhOGJjOTkxNDJiZDBlODM4MGZiOWU3YmFkYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-10-29T08:58:41Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-10-29T08:58:41Z"}, "message": "[AArch64] Add support for arm_sve.h\n\nThis patch adds support for arm_sve.h.  I've tried to split all the\ngroundwork out into separate patches, so this is mostly adding new code\nrather than changing existing code.\n\nThe C++ frontend seems to handle correct ACLE code without modification,\neven in length-agnostic mode.  The C frontend is close; the only correct\nconstruct I know it doesn't handle is initialisation.  E.g.:\n\n  svbool_t pg = svptrue_b8 ();\n\nproduces:\n\n  variable-sized object may not be initialized\n\nalthough:\n\n  svbool_t pg; pg = svptrue_b8 ();\n\nworks fine.  This can be fixed by changing:\n\n \t  {\n \t    /* A complete type is ok if size is fixed.  */\n\n-\t    if (TREE_CODE (TYPE_SIZE (TREE_TYPE (decl))) != INTEGER_CST\n+\t    if (!poly_int_tree_p (TYPE_SIZE (TREE_TYPE (decl)))\n \t\t|| C_DECL_VARIABLE_SIZE (decl))\n \t      {\n \t\terror (\"variable-sized object may not be initialized\");\n\nin c/c-decl.c:start_decl.\n\nInvalid code is likely to trigger ICEs, so this isn't ready for general\nuse yet.  However, it seemed better to apply the patch now and deal with\ndiagnosing invalid code as a follow-up.  For one thing, it means that\nwe'll be able to provide testcases for middle-end changes related\nto SVE vectors, which has been a problem until now.  (I already have\na series of such patches lined up.)\n\nThe patch includes some tests, but the main ones need to wait until the\nPCS support has been applied.\n\n2019-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n\t    Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n\t    Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n\ngcc/\n\t* config.gcc (aarch64*-*-*): Add arm_sve.h to extra_headers.\n\tAdd aarch64-sve-builtins.o, aarch64-sve-builtins-shapes.o and\n\taarch64-sve-builtins-base.o to extra_objs.  Add\n\taarch64-sve-builtins.h and aarch64-sve-builtins.cc to target_gtfiles.\n\t* config/aarch64/t-aarch64 (aarch64-sve-builtins.o): New rule.\n\t(aarch64-sve-builtins-shapes.o): Likewise.\n\t(aarch64-sve-builtins-base.o): New rules.\n\t* config/aarch64/aarch64-c.c (aarch64_pragma_aarch64): New function.\n\t(aarch64_resolve_overloaded_builtin): Likewise.\n\t(aarch64_check_builtin_call): Likewise.\n\t(aarch64_register_pragmas): Install aarch64_resolve_overloaded_builtin\n\tand aarch64_check_builtin_call in targetm.  Register the GCC aarch64\n\tpragma.\n\t* config/aarch64/aarch64-protos.h (AARCH64_FOR_SVPRFOP): New macro.\n\t(aarch64_svprfop): New enum.\n\t(AARCH64_BUILTIN_SVE): New aarch64_builtin_class enum value.\n\t(aarch64_sve_int_mode, aarch64_sve_data_mode): Declare.\n\t(aarch64_fold_sve_cnt_pat, aarch64_output_sve_prefetch): Likewise.\n\t(aarch64_output_sve_cnt_pat_immediate): Likewise.\n\t(aarch64_output_sve_ptrues, aarch64_sve_ptrue_svpattern_p): Likewise.\n\t(aarch64_sve_sqadd_sqsub_immediate_p, aarch64_sve_ldff1_operand_p)\n\t(aarch64_sve_ldnf1_operand_p, aarch64_sve_prefetch_operand_p)\n\t(aarch64_ptrue_all_mode, aarch64_convert_sve_data_to_pred): Likewise.\n\t(aarch64_expand_sve_dupq, aarch64_replace_reg_mode): Likewise.\n\t(aarch64_sve::init_builtins, aarch64_sve::handle_arm_sve_h): Likewise.\n\t(aarch64_sve::builtin_decl, aarch64_sve::builtin_type_p): Likewise.\n\t(aarch64_sve::mangle_builtin_type): Likewise.\n\t(aarch64_sve::resolve_overloaded_builtin): Likewise.\n\t(aarch64_sve::check_builtin_call, aarch64_sve::gimple_fold_builtin)\n\t(aarch64_sve::expand_builtin): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_sve_data_mode): Make public.\n\t(aarch64_sve_int_mode): Likewise.\n\t(aarch64_ptrue_all_mode): New function.\n\t(aarch64_convert_sve_data_to_pred): Make public.\n\t(svprfop_token): New function.\n\t(aarch64_output_sve_prefetch): Likewise.\n\t(aarch64_fold_sve_cnt_pat): Likewise.\n\t(aarch64_output_sve_cnt_pat_immediate): Likewise.\n\t(aarch64_sve_move_pred_via_while): Use gen_while with UNSPEC_WHILE_LO\n\tinstead of gen_while_ult.\n\t(aarch64_replace_reg_mode): Make public.\n\t(aarch64_init_builtins): Call aarch64_sve::init_builtins.\n\t(aarch64_fold_builtin): Handle AARCH64_BUILTIN_SVE.\n\t(aarch64_gimple_fold_builtin, aarch64_expand_builtin): Likewise.\n\t(aarch64_builtin_decl, aarch64_builtin_reciprocal): Likewise.\n\t(aarch64_mangle_type): Call aarch64_sve::mangle_type.\n\t(aarch64_sve_sqadd_sqsub_immediate_p): New function.\n\t(aarch64_sve_ptrue_svpattern_p): Likewise.\n\t(aarch64_sve_pred_valid_immediate): Check\n\taarch64_sve_ptrue_svpattern_p.\n\t(aarch64_sve_ldff1_operand_p, aarch64_sve_ldnf1_operand_p)\n\t(aarch64_sve_prefetch_operand_p, aarch64_output_sve_ptrues): New\n\tfunctions.\n\t* config/aarch64/aarch64.md (UNSPEC_LDNT1_SVE, UNSPEC_STNT1_SVE)\n\t(UNSPEC_LDFF1_GATHER, UNSPEC_PTRUE, UNSPEC_WHILE_LE, UNSPEC_WHILE_LS)\n\t(UNSPEC_WHILE_LT, UNSPEC_CLASTA, UNSPEC_UPDATE_FFR)\n\t(UNSPEC_UPDATE_FFRT, UNSPEC_RDFFR, UNSPEC_WRFFR)\n\t(UNSPEC_SVE_LANE_SELECT, UNSPEC_SVE_CNT_PAT, UNSPEC_SVE_PREFETCH)\n\t(UNSPEC_SVE_PREFETCH_GATHER, UNSPEC_SVE_COMPACT, UNSPEC_SVE_SPLICE):\n\tNew unspecs.\n\t* config/aarch64/iterators.md (SI_ONLY, DI_ONLY, VNx8HI_ONLY)\n\t(VNx2DI_ONLY, SVE_PARTIAL, VNx8_NARROW, VNx8_WIDE, VNx4_NARROW)\n\t(VNx4_WIDE, VNx2_NARROW, VNx2_WIDE, PRED_HSD): New mode iterators.\n\t(UNSPEC_ADR, UNSPEC_BRKA, UNSPEC_BRKB, UNSPEC_BRKN, UNSPEC_BRKPA)\n\t(UNSPEC_BRKPB, UNSPEC_PFIRST, UNSPEC_PNEXT, UNSPEC_CNTP, UNSPEC_SADDV)\n\t(UNSPEC_UADDV, UNSPEC_FMLA, UNSPEC_FMLS, UNSPEC_FEXPA, UNSPEC_FTMAD)\n\t(UNSPEC_FTSMUL, UNSPEC_FTSSEL, UNSPEC_COND_CMPEQ_WIDE): New unspecs.\n\t(UNSPEC_COND_CMPGE_WIDE, UNSPEC_COND_CMPGT_WIDE): Likewise.\n\t(UNSPEC_COND_CMPHI_WIDE, UNSPEC_COND_CMPHS_WIDE): Likewise.\n\t(UNSPEC_COND_CMPLE_WIDE, UNSPEC_COND_CMPLO_WIDE): Likewise.\n\t(UNSPEC_COND_CMPLS_WIDE, UNSPEC_COND_CMPLT_WIDE): Likewise.\n\t(UNSPEC_COND_CMPNE_WIDE, UNSPEC_COND_FCADD90, UNSPEC_COND_FCADD270)\n\t(UNSPEC_COND_FCMLA, UNSPEC_COND_FCMLA90, UNSPEC_COND_FCMLA180)\n\t(UNSPEC_COND_FCMLA270, UNSPEC_COND_FMAX, UNSPEC_COND_FMIN): Likewise.\n\t(UNSPEC_COND_FMULX, UNSPEC_COND_FRECPX, UNSPEC_COND_FSCALE): Likewise.\n\t(UNSPEC_LASTA, UNSPEC_ASHIFT_WIDE, UNSPEC_ASHIFTRT_WIDE): Likewise.\n\t(UNSPEC_LSHIFTRT_WIDE, UNSPEC_LDFF1, UNSPEC_LDNF1): Likewise.\n\t(Vesize): Handle partial vector modes.\n\t(self_mask, narrower_mask, sve_lane_con, sve_lane_pair_con): New\n\tmode attributes.\n\t(UBINQOPS, ANY_PLUS, SAT_PLUS, ANY_MINUS, SAT_MINUS): New code\n\titerators.\n\t(s, paired_extend, inc_dec): New code attributes.\n\t(SVE_INT_ADDV, CLAST, LAST): New int iterators.\n\t(SVE_INT_UNARY): Add UNSPEC_RBIT.\n\t(SVE_FP_UNARY, SVE_FP_UNARY_INT): New int iterators.\n\t(SVE_FP_BINARY, SVE_FP_BINARY_INT): Likewise.\n\t(SVE_COND_FP_UNARY): Add UNSPEC_COND_FRECPX.\n\t(SVE_COND_FP_BINARY): Add UNSPEC_COND_FMAX, UNSPEC_COND_FMIN and\n\tUNSPEC_COND_FMULX.\n\t(SVE_COND_FP_BINARY_INT, SVE_COND_FP_ADD): New int iterators.\n\t(SVE_COND_FP_SUB, SVE_COND_FP_MUL): Likewise.\n\t(SVE_COND_FP_BINARY_I1): Add UNSPEC_COND_FMAX and UNSPEC_COND_FMIN.\n\t(SVE_COND_FP_BINARY_REG): Add UNSPEC_COND_FMULX.\n\t(SVE_COND_FCADD, SVE_COND_FP_MAXMIN, SVE_COND_FCMLA)\n\t(SVE_COND_INT_CMP_WIDE, SVE_FP_TERNARY_LANE, SVE_CFP_TERNARY_LANE)\n\t(SVE_WHILE, SVE_SHIFT_WIDE, SVE_LDFF1_LDNF1, SVE_BRK_UNARY)\n\t(SVE_BRK_BINARY, SVE_PITER): New int iterators.\n\t(optab): Handle UNSPEC_SADDV, UNSPEC_UADDV, UNSPEC_FRECPE,\n\tUNSPEC_FRECPS, UNSPEC_RSQRTE, UNSPEC_RSQRTS, UNSPEC_RBIT,\n\tUNSPEC_SMUL_HIGHPART, UNSPEC_UMUL_HIGHPART, UNSPEC_FMLA, UNSPEC_FMLS,\n\tUNSPEC_FCMLA, UNSPEC_FCMLA90, UNSPEC_FCMLA180, UNSPEC_FCMLA270,\n\tUNSPEC_FEXPA, UNSPEC_FTSMUL, UNSPEC_FTSSEL, UNSPEC_COND_FCADD90,\n\tUNSPEC_COND_FCADD270, UNSPEC_COND_FCMLA, UNSPEC_COND_FCMLA90,\n\tUNSPEC_COND_FCMLA180, UNSPEC_COND_FCMLA270, UNSPEC_COND_FMAX,\n\tUNSPEC_COND_FMIN, UNSPEC_COND_FMULX, UNSPEC_COND_FRECPX and\n\tUNSPEC_COND_FSCALE.\n\t(maxmin_uns): Handle UNSPEC_COND_FMAX and UNSPEC_COND_FMIN.\n\t(binqops_op, binqops_op_rev, last_op): New int attributes.\n\t(su): Handle UNSPEC_SADDV and UNSPEC_UADDV.\n\t(fn, ab): New int attributes.\n\t(cmp_op): Handle UNSPEC_COND_CMP*_WIDE and UNSPEC_WHILE_*.\n\t(while_optab_cmp, brk_op, sve_pred_op): New int attributes.\n\t(sve_int_op): Handle UNSPEC_SMUL_HIGHPART, UNSPEC_UMUL_HIGHPART,\n\tUNSPEC_ASHIFT_WIDE, UNSPEC_ASHIFTRT_WIDE, UNSPEC_LSHIFTRT_WIDE and\n\tUNSPEC_RBIT.\n\t(sve_fp_op): Handle UNSPEC_FRECPE, UNSPEC_FRECPS, UNSPEC_RSQRTE,\n\tUNSPEC_RSQRTS, UNSPEC_FMLA, UNSPEC_FMLS, UNSPEC_FEXPA, UNSPEC_FTSMUL,\n\tUNSPEC_FTSSEL, UNSPEC_COND_FMAX, UNSPEC_COND_FMIN, UNSPEC_COND_FMULX,\n\tUNSPEC_COND_FRECPX and UNSPEC_COND_FSCALE.\n\t(sve_fp_op_rev): Handle UNSPEC_COND_FMAX, UNSPEC_COND_FMIN and\n\tUNSPEC_COND_FMULX.\n\t(rot): Handle UNSPEC_COND_FCADD* and UNSPEC_COND_FCMLA*.\n\t(brk_reg_con, brk_reg_opno): New int attributes.\n\t(sve_pred_fp_rhs1_operand, sve_pred_fp_rhs2_operand): Handle\n\tUNSPEC_COND_FMAX, UNSPEC_COND_FMIN and UNSPEC_COND_FMULX.\n\t(sve_pred_fp_rhs2_immediate): Handle UNSPEC_COND_FMAX and\n\tUNSPEC_COND_FMIN.\n\t(max_elem_bits): New int attribute.\n\t(min_elem_bits): Handle UNSPEC_RBIT.\n\t* config/aarch64/predicates.md (subreg_lowpart_operator): Handle\n\tTRUNCATE as well as SUBREG.\n\t(ascending_int_parallel, aarch64_simd_reg_or_minus_one)\n\t(aarch64_sve_ldff1_operand, aarch64_sve_ldnf1_operand)\n\t(aarch64_sve_prefetch_operand, aarch64_sve_ptrue_svpattern_immediate)\n\t(aarch64_sve_qadd_immediate, aarch64_sve_qsub_immediate)\n\t(aarch64_sve_gather_immediate_b, aarch64_sve_gather_immediate_h)\n\t(aarch64_sve_gather_immediate_w, aarch64_sve_gather_immediate_d)\n\t(aarch64_sve_sqadd_operand, aarch64_sve_gather_offset_b)\n\t(aarch64_sve_gather_offset_h, aarch64_sve_gather_offset_w)\n\t(aarch64_sve_gather_offset_d, aarch64_gather_scale_operand_b)\n\t(aarch64_gather_scale_operand_h): New predicates.\n\t* config/aarch64/constraints.md (UPb, UPd, UPh, UPw, Utf, Utn, vgb)\n\t(vgd, vgh, vgw, vsQ, vsS): New constraints.\n\t* config/aarch64/aarch64-sve.md: Add a note on the FFR handling.\n\t(*aarch64_sve_reinterpret<mode>): Allow any source register\n\tinstead of requiring an exact match.\n\t(*aarch64_sve_ptruevnx16bi_cc, *aarch64_sve_ptrue<mode>_cc)\n\t(*aarch64_sve_ptruevnx16bi_ptest, *aarch64_sve_ptrue<mode>_ptest)\n\t(aarch64_wrffr, aarch64_update_ffr_for_load, aarch64_copy_ffr_to_ffrt)\n\t(aarch64_rdffr, aarch64_rdffr_z, *aarch64_rdffr_z_ptest)\n\t(*aarch64_rdffr_ptest, *aarch64_rdffr_z_cc, *aarch64_rdffr_cc)\n\t(aarch64_update_ffrt): New patterns.\n\t(@aarch64_load_<ANY_EXTEND:optab><VNx8_WIDE:mode><VNx8_NARROW:mode>)\n\t(@aarch64_load_<ANY_EXTEND:optab><VNx4_WIDE:mode><VNx4_NARROW:mode>)\n\t(@aarch64_load_<ANY_EXTEND:optab><VNx2_WIDE:mode><VNx2_NARROW:mode>)\n\t(@aarch64_ld<fn>f1<mode>): New patterns.\n\t(@aarch64_ld<fn>f1_<ANY_EXTEND:optab><VNx8_WIDE:mode><VNx8_NARROW:mode>)\n\t(@aarch64_ld<fn>f1_<ANY_EXTEND:optab><VNx4_WIDE:mode><VNx4_NARROW:mode>)\n\t(@aarch64_ld<fn>f1_<ANY_EXTEND:optab><VNx2_WIDE:mode><VNx2_NARROW:mode>)\n\t(@aarch64_ldnt1<mode>): New patterns.\n\t(gather_load<mode>): Use aarch64_sve_gather_offset_<Vesize> for\n\tthe scalar part of the address.\n\t(mask_gather_load<SVE_S:mode>): Use aarch64_sve_gather_offset_w for the\n\tscalar part of the addresse and add an alternative for handling\n\tnonzero offsets.\n\t(mask_gather_load<SVE_D:mode>): Likewise aarch64_sve_gather_offset_d.\n\t(*mask_gather_load<mode>_sxtw, *mask_gather_load<mode>_uxtw)\n\t(@aarch64_gather_load_<ANY_EXTEND:optab><VNx4_WIDE:mode><VNx4_NARROW:mode>)\n\t(@aarch64_gather_load_<ANY_EXTEND:optab><VNx2_WIDE:mode><VNx2_NARROW:mode>)\n\t(*aarch64_gather_load_<ANY_EXTEND:optab><VNx2_WIDE:mode><VNx2_NARROW:mode>_sxtw)\n\t(*aarch64_gather_load_<ANY_EXTEND:optab><VNx2_WIDE:mode><VNx2_NARROW:mode>_uxtw)\n\t(@aarch64_ldff1_gather<SVE_S:mode>, @aarch64_ldff1_gather<SVE_D:mode>)\n\t(*aarch64_ldff1_gather<mode>_sxtw, *aarch64_ldff1_gather<mode>_uxtw)\n\t(@aarch64_ldff1_gather_<ANY_EXTEND:optab><VNx4_WIDE:mode><VNx4_NARROW:mode>)\n\t(@aarch64_ldff1_gather_<ANY_EXTEND:optab><VNx2_WIDE:mode><VNx2_NARROW:mode>)\n\t(*aarch64_ldff1_gather_<ANY_EXTEND:optab><VNx2_WIDE:mode><VNx2_NARROW:mode>_sxtw)\n\t(*aarch64_ldff1_gather_<ANY_EXTEND:optab><VNx2_WIDE:mode><VNx2_NARROW:mode>_uxtw)\n\t(@aarch64_sve_prefetch<mode>): New patterns.\n\t(@aarch64_sve_gather_prefetch<SVE_I:mode><VNx4SI_ONLY:mode>)\n\t(@aarch64_sve_gather_prefetch<SVE_I:mode><VNx2DI_ONLY:mode>)\n\t(*aarch64_sve_gather_prefetch<SVE_I:mode><VNx2DI_ONLY:mode>_sxtw)\n\t(*aarch64_sve_gather_prefetch<SVE_I:mode><VNx2DI_ONLY:mode>_uxtw)\n\t(@aarch64_store_trunc<VNx8_NARROW:mode><VNx8_WIDE:mode>)\n\t(@aarch64_store_trunc<VNx4_NARROW:mode><VNx4_WIDE:mode>)\n\t(@aarch64_store_trunc<VNx2_NARROW:mode><VNx2_WIDE:mode>)\n\t(@aarch64_stnt1<mode>): New patterns.\n\t(scatter_store<mode>): Use aarch64_sve_gather_offset_<Vesize> for\n\tthe scalar part of the address.\n\t(mask_scatter_store<SVE_S:mode>): Use aarch64_sve_gather_offset_w for\n\tthe scalar part of the addresse and add an alternative for handling\n\tnonzero offsets.\n\t(mask_scatter_store<SVE_D:mode>): Likewise aarch64_sve_gather_offset_d.\n\t(*mask_scatter_store<mode>_sxtw, *mask_scatter_store<mode>_uxtw)\n\t(@aarch64_scatter_store_trunc<VNx4_NARROW:mode><VNx4_WIDE:mode>)\n\t(@aarch64_scatter_store_trunc<VNx2_NARROW:mode><VNx2_WIDE:mode>)\n\t(*aarch64_scatter_store_trunc<VNx2_NARROW:mode><VNx2_WIDE:mode>_sxtw)\n\t(*aarch64_scatter_store_trunc<VNx2_NARROW:mode><VNx2_WIDE:mode>_uxtw):\n\tNew patterns.\n\t(vec_duplicate<mode>): Use QI as the mode of the input operand.\n\t(extract_last_<mode>): Generalize to...\n\t(@extract_<LAST:last_op>_<mode>): ...this.\n\t(*<SVE_INT_UNARY:optab><mode>2): Rename to...\n\t(@aarch64_pred_<SVE_INT_UNARY:optab><mode>): ...this.\n\t(@cond_<SVE_INT_UNARY:optab><mode>): New expander.\n\t(@aarch64_pred_sxt<SVE_HSDI:mode><SVE_PARTIAL:mode>): New pattern.\n\t(@aarch64_cond_sxt<SVE_HSDI:mode><SVE_PARTIAL:mode>): Likewise.\n\t(@aarch64_pred_cnot<mode>, @cond_cnot<mode>): New expanders.\n\t(@aarch64_sve_<SVE_FP_UNARY_INT:optab><mode>): New pattern.\n\t(@aarch64_sve_<SVE_FP_UNARY:optab><mode>): Likewise.\n\t(*<SVE_COND_FP_UNARY:optab><mode>2): Rename to...\n\t(@aarch64_pred_<SVE_COND_FP_UNARY:optab><mode>): ...this.\n\t(@cond_<SVE_COND_FP_UNARY:optab><mode>): New expander.\n\t(*<SVE_INT_BINARY_IMM:optab><mode>3): Rename to...\n\t(@aarch64_pred_<SVE_INT_BINARY_IMM:optab><mode>): ...this.\n\t(@aarch64_adr<mode>, *aarch64_adr_sxtw): New patterns.\n\t(*aarch64_adr_uxtw_unspec): Likewise.\n\t(*aarch64_adr_uxtw): Rename to...\n\t(*aarch64_adr_uxtw_and): ...this.\n\t(@aarch64_adr<mode>_shift): New expander.\n\t(*aarch64_adr_shift_sxtw): New pattern.\n\t(aarch64_<su>abd<mode>_3): Rename to...\n\t(@aarch64_pred_<su>abd<mode>): ...this.\n\t(<su>abd<mode>_3): Update accordingly.\n\t(@aarch64_cond_<su>abd<mode>): New expander.\n\t(@aarch64_<SBINQOPS:su_optab><optab><mode>): New pattern.\n\t(@aarch64_<UBINQOPS:su_optab><optab><mode>): Likewise.\n\t(*<su>mul<mode>3_highpart): Rename to...\n\t(@aarch64_pred_<optab><mode>): ...this.\n\t(@cond_<MUL_HIGHPART:optab><mode>): New expander.\n\t(*cond_<MUL_HIGHPART:optab><mode>_2): New pattern.\n\t(*cond_<MUL_HIGHPART:optab><mode>_z): Likewise.\n\t(*<SVE_INT_BINARY_SD:optab><mode>3): Rename to...\n\t(@aarch64_pred_<SVE_INT_BINARY_SD:optab><mode>): ...this.\n\t(cond_<SVE_INT_BINARY_SD:optab><mode>): Add a \"@\" marker.\n\t(@aarch64_bic<mode>, @cond_bic<mode>): New expanders.\n\t(*v<ASHIFT:optab><mode>3): Rename to...\n\t(@aarch64_pred_<ASHIFT:optab><mode>): ...this.\n\t(@aarch64_sve_<SVE_SHIFT_WIDE:sve_int_op><mode>): New pattern.\n\t(@cond_<SVE_SHIFT_WIDE:sve_int_op><mode>): New expander.\n\t(*cond_<SVE_SHIFT_WIDE:sve_int_op><mode>_m): New pattern.\n\t(*cond_<SVE_SHIFT_WIDE:sve_int_op><mode>_z): Likewise.\n\t(@cond_asrd<mode>): New expander.\n\t(*cond_asrd<mode>_2, *cond_asrd<mode>_z): New patterns.\n\t(sdiv_pow2<mode>3): Expand to *cond_asrd<mode>_2.\n\t(*sdiv_pow2<mode>3): Delete.\n\t(@cond_<SVE_COND_FP_BINARY_INT:optab><mode>): New expander.\n\t(*cond_<SVE_COND_FP_BINARY_INT:optab><mode>_2): New pattern.\n\t(*cond_<SVE_COND_FP_BINARY_INT:optab><mode>_any): Likewise.\n\t(@aarch64_sve_<SVE_FP_BINARY:optab><mode>): New pattern.\n\t(@aarch64_sve_<SVE_FP_BINARY_INT:optab><mode>): Likewise.\n\t(*<SVE_COND_FP_BINARY_REG:optab><mode>3): Rename to...\n\t(@aarch64_pred_<SVE_COND_FP_BINARY_REG:optab><mode>): ...this.\n\t(@aarch64_pred_<SVE_COND_FP_BINARY_INT:optab><mode>): New pattern.\n\t(cond_<SVE_COND_FP_BINARY:optab><mode>): Add a \"@\" marker.\n\t(*add<SVE_F:mode>3): Rename to...\n\t(@aarch64_pred_add<SVE_F:mode>): ...this and add alternatives\n\tfor SVE_STRICT_GP.\n\t(@aarch64_pred_<SVE_COND_FCADD:optab><mode>): New pattern.\n\t(@cond_<SVE_COND_FCADD:optab><mode>): New expander.\n\t(*cond_<SVE_COND_FCADD:optab><mode>_2): New pattern.\n\t(*cond_<SVE_COND_FCADD:optab><mode>_any): Likewise.\n\t(*sub<SVE_F:mode>3): Rename to...\n\t(@aarch64_pred_sub<SVE_F:mode>): ...this and add alternatives\n\tfor SVE_STRICT_GP.\n\t(@aarch64_pred_abd<SVE_F:mode>): New expander.\n\t(*fabd<SVE_F:mode>3): Rename to...\n\t(*aarch64_pred_abd<SVE_F:mode>): ...this.\n\t(@aarch64_cond_abd<SVE_F:mode>): New expander.\n\t(*mul<SVE_F:mode>3): Rename to...\n\t(@aarch64_pred_<SVE_F:optab><mode>): ...this and add alternatives\n\tfor SVE_STRICT_GP.\n\t(@aarch64_mul_lane_<SVE_F:mode>): New pattern.\n\t(*<SVE_COND_FP_MAXMIN_PUBLIC:optab><mode>3): Rename and generalize\n\tto...\n\t(@aarch64_pred_<SVE_COND_FP_MAXMIN:optab><mode>): ...this.\n\t(*<LOGICAL:optab><PRED_ALL:mode>3_ptest): New pattern.\n\t(*<nlogical><PRED_ALL:mode>3): Rename to...\n\t(aarch64_pred_<nlogical><PRED_ALL:mode>_z): ...this.\n\t(*<nlogical><PRED_ALL:mode>3_cc): New pattern.\n\t(*<nlogical><PRED_ALL:mode>3_ptest): Likewise.\n\t(*<logical_nn><PRED_ALL:mode>3): Rename to...\n\t(aarch64_pred_<logical_nn><mode>_z): ...this.\n\t(*<logical_nn><PRED_ALL:mode>3_cc): New pattern.\n\t(*<logical_nn><PRED_ALL:mode>3_ptest): Likewise.\n\t(*fma<SVE_I:mode>4): Rename to...\n\t(@aarch64_pred_fma<SVE_I:mode>): ...this.\n\t(*fnma<SVE_I:mode>4): Rename to...\n\t(@aarch64_pred_fnma<SVE_I:mode>): ...this.\n\t(@aarch64_<sur>dot_prod_lane<vsi2qi>): New pattern.\n\t(*<SVE_FP_TERNARY:optab><mode>4): Rename to...\n\t(@aarch64_pred_<SVE_FP_TERNARY:optab><mode>): ...this.\n\t(cond_<SVE_FP_TERNARY:optab><mode>): Add a \"@\" marker.\n\t(@aarch64_<SVE_FP_TERNARY_LANE:optab>_lane_<mode>): New pattern.\n\t(@aarch64_pred_<SVE_COND_FCMLA:optab><mode>): Likewise.\n\t(@cond_<SVE_COND_FCMLA:optab><mode>): New expander.\n\t(*cond_<SVE_COND_FCMLA:optab><mode>_4): New pattern.\n\t(*cond_<SVE_COND_FCMLA:optab><mode>_any): Likewise.\n\t(@aarch64_<FCMLA:optab>_lane_<mode>): Likewise.\n\t(@aarch64_sve_tmad<mode>): Likewise.\n\t(vcond_mask_<SVE_ALL:mode><vpred>): Add a \"@\" marker.\n\t(*aarch64_sel_dup<mode>): Rename to...\n\t(@aarch64_sel_dup<mode>): ...this.\n\t(@aarch64_pred_cmp<cmp_op><SVE_I:mode>_wide): New pattern.\n\t(*aarch64_pred_cmp<cmp_op><SVE_I:mode>_wide_cc): Likewise.\n\t(*aarch64_pred_cmp<cmp_op><SVE_I:mode>_wide_ptest): Likewise.\n\t(@while_ult<GPI:mode><PRED_ALL:mode>): Generalize to...\n\t(@while_<while_optab_cmp><GPI:mode><PRED_ALL:mode>): ...this.\n\t(*while_ult<GPI:mode><PRED_ALL:mode>_cc): Generalize to.\n\t(*while_<while_optab_cmp><GPI:mode><PRED_ALL:mode>_cc): ...this.\n\t(*while_<while_optab_cmp><GPI:mode><PRED_ALL:mode>_ptest): New pattern.\n\t(*fcm<cmp_op><mode>): Rename to...\n\t(@aarch64_pred_fcm<cmp_op><mode>): ...this.  Make operand order\n\tmatch @aarch64_pred_cmp<cmp_op><SVE_I:mode>.\n\t(*fcmuo<mode>): Rename to...\n\t(@aarch64_pred_fcmuo<mode>): ...this.  Make operand order\n\tmatch @aarch64_pred_cmp<cmp_op><SVE_I:mode>.\n\t(@aarch64_pred_fac<cmp_op><mode>): New expander.\n\t(@vcond_mask_<PRED_ALL:mode><mode>): New pattern.\n\t(fold_extract_last_<mode>): Generalize to...\n\t(@fold_extract_<last_op>_<mode>): ...this.\n\t(@aarch64_fold_extract_vector_<last_op>_<mode>): New pattern.\n\t(*reduc_plus_scal_<SVE_I:mode>): Replace with...\n\t(@aarch64_pred_reduc_<optab>_<mode>): ...this pattern, making the\n\tDImode result explicit.\n\t(reduc_plus_scal_<mode>): Update accordingly.\n\t(*reduc_<optab>_scal_<SVE_I:mode>): Rename to...\n\t(@aarch64_pred_reduc_<optab>_<SVE_I:mode>): ...this.\n\t(*reduc_<optab>_scal_<SVE_F:mode>): Rename to...\n\t(@aarch64_pred_reduc_<optab>_<SVE_F:mode>): ...this.\n\t(*aarch64_sve_tbl<mode>): Rename to...\n\t(@aarch64_sve_tbl<mode>): ...this.\n\t(@aarch64_sve_compact<mode>): New pattern.\n\t(*aarch64_sve_dup_lane<mode>): Rename to...\n\t(@aarch64_sve_dup_lane<mode>): ...this.\n\t(@aarch64_sve_dupq_lane<mode>): New pattern.\n\t(@aarch64_sve_splice<mode>): Likewise.\n\t(aarch64_sve_<perm_insn><mode>): Rename to...\n\t(@aarch64_sve_<perm_insn><mode>): ...this.\n\t(*aarch64_sve_ext<mode>): Rename to...\n\t(@aarch64_sve_ext<mode>): ...this.\n\t(aarch64_sve_<su>unpk<perm_hilo>_<SVE_BHSI:mode>): Add a \"@\" marker.\n\t(*aarch64_sve_<optab>_nontrunc<SVE_F:mode><SVE_HSDI:mode>): Rename\n\tto...\n\t(@aarch64_sve_<optab>_nontrunc<SVE_F:mode><SVE_HSDI:mode>): ...this.\n\t(*aarch64_sve_<optab>_trunc<VNx2DF_ONLY:mode><VNx4SI_ONLY:mode>):\n\tRename to...\n\t(@aarch64_sve_<optab>_trunc<VNx2DF_ONLY:mode><VNx4SI_ONLY:mode>):\n\t...this.\n\t(@cond_<optab>_nontrunc<SVE_F:mode><SVE_HSDI:mode>): New expander.\n\t(@cond_<optab>_trunc<VNx2DF_ONLY:mode><VNx4SI_ONLY:mode>): Likewise.\n\t(*cond_<optab>_trunc<VNx2DF_ONLY:mode><VNx4SI_ONLY:mode>): New pattern.\n\t(*aarch64_sve_<optab>_nonextend<SVE_HSDI:mode><SVE_F:mode>): Rename\n\tto...\n\t(@aarch64_sve_<optab>_nonextend<SVE_HSDI:mode><SVE_F:mode>): ...this.\n\t(aarch64_sve_<optab>_extend<VNx4SI_ONLY:mode><VNx2DF_ONLY:mode>): Add\n\ta \"@\" marker.\n\t(@cond_<optab>_nonextend<SVE_HSDI:mode><SVE_F:mode>): New expander.\n\t(@cond_<optab>_extend<VNx4SI_ONLY:mode><VNx2DF_ONLY:mode>): Likewise.\n\t(*cond_<optab>_extend<VNx4SI_ONLY:mode><VNx2DF_ONLY:mode>): New\n\tpattern.\n\t(*aarch64_sve_<optab>_trunc<SVE_SDF:mode><SVE_HSF:mode>): Rename to...\n\t(@aarch64_sve_<optab>_trunc<SVE_SDF:mode><SVE_HSF:mode>): ...this.\n\t(@cond_<optab>_trunc<SVE_SDF:mode><SVE_HSF:mode>): New expander.\n\t(*cond_<optab>_trunc<SVE_SDF:mode><SVE_HSF:mode>): New pattern.\n\t(aarch64_sve_<optab>_nontrunc<SVE_HSF:mode><SVE_SDF:mode>): Add a\n\t\"@\" marker.\n\t(@cond_<optab>_nontrunc<SVE_HSF:mode><SVE_SDF:mode>): New expander.\n\t(*cond_<optab>_nontrunc<SVE_HSF:mode><SVE_SDF:mode>): New pattern.\n\t(aarch64_sve_punpk<perm_hilo>_<mode>): Add a \"@\" marker.\n\t(@aarch64_brk<SVE_BRK_UNARY:brk_op>): New pattern.\n\t(*aarch64_brk<SVE_BRK_UNARY:brk_op>_cc): Likewise.\n\t(*aarch64_brk<SVE_BRK_UNARY:brk_op>_ptest): Likewise.\n\t(@aarch64_brk<SVE_BRK_BINARY:brk_op>): Likewise.\n\t(*aarch64_brk<SVE_BRK_BINARY:brk_op>_cc): Likewise.\n\t(*aarch64_brk<SVE_BRK_BINARY:brk_op>_ptest): Likewise.\n\t(@aarch64_sve_<SVE_PITER:sve_pred_op><mode>): Likewise.\n\t(*aarch64_sve_<SVE_PITER:sve_pred_op><mode>_cc): Likewise.\n\t(*aarch64_sve_<SVE_PITER:sve_pred_op><mode>_ptest): Likewise.\n\t(aarch64_sve_cnt_pat): Likewise.\n\t(@aarch64_sve_<ANY_PLUS:inc_dec><DI_ONLY:mode>_pat): Likewise.\n\t(*aarch64_sve_incsi_pat): Likewise.\n\t(@aarch64_sve_<SAT_PLUS:inc_dec><SI_ONLY:mode>_pat): Likewise.\n\t(@aarch64_sve_<ANY_PLUS:inc_dec><VNx2DI_ONLY:mode>_pat): Likewise.\n\t(@aarch64_sve_<ANY_PLUS:inc_dec><VNx4SI_ONLY:mode>_pat): Likewise.\n\t(@aarch64_sve_<ANY_PLUS:inc_dec><VNx8HI_ONLY:mode>_pat): New expander.\n\t(*aarch64_sve_<ANY_PLUS:inc_dec><VNx8HI_ONLY:mode>_pat): New pattern.\n\t(@aarch64_sve_<ANY_MINUS:inc_dec><DI_ONLY:mode>_pat): Likewise.\n\t(*aarch64_sve_decsi_pat): Likewise.\n\t(@aarch64_sve_<SAT_MINUS:inc_dec><SI_ONLY:mode>_pat): Likewise.\n\t(@aarch64_sve_<ANY_MINUS:inc_dec><VNx2DI_ONLY:mode>_pat): Likewise.\n\t(@aarch64_sve_<ANY_MINUS:inc_dec><VNx4SI_ONLY:mode>_pat): Likewise.\n\t(@aarch64_sve_<ANY_MINUS:inc_dec><VNx8HI_ONLY:mode>_pat): New expander.\n\t(*aarch64_sve_<ANY_MINUS:inc_dec><VNx8HI_ONLY:mode>_pat): New pattern.\n\t(@aarch64_pred_cntp<mode>): Likewise.\n\t(@aarch64_sve_<ANY_PLUS:inc_dec><DI_ONLY:mode><PRED_ALL:mode>_cntp):\n\tNew expander.\n\t(*aarch64_sve_<ANY_PLUS:inc_dec><DI_ONLY:mode><PRED_ALL:mode>_cntp)\n\t(*aarch64_incsi<PRED_ALL:mode>_cntp): New patterns.\n\t(@aarch64_sve_<SAT_PLUS:inc_dec><SI_ONLY:mode><PRED_ALL:mode>_cntp):\n\tNew expander.\n\t(*aarch64_sve_<SAT_PLUS:inc_dec><SI_ONLY:mode><PRED_ALL:mode>_cntp):\n\tNew pattern.\n\t(@aarch64_sve_<ANY_PLUS:inc_dec><VNx2DI_ONLY:mode>_cntp): New expander.\n\t(*aarch64_sve_<ANY_PLUS:inc_dec><VNx2DI_ONLY:mode>_cntp): New pattern.\n\t(@aarch64_sve_<ANY_PLUS:inc_dec><VNx4SI_ONLY:mode>_cntp): New expander.\n\t(*aarch64_sve_<ANY_PLUS:inc_dec><VNx4SI_ONLY:mode>_cntp): New pattern.\n\t(@aarch64_sve_<ANY_PLUS:inc_dec><VNx8HI_ONLY:mode>_cntp): New expander.\n\t(*aarch64_sve_<ANY_PLUS:inc_dec><VNx8HI_ONLY:mode>_cntp): New pattern.\n\t(@aarch64_sve_<ANY_MINUS:inc_dec><DI_ONLY:mode><PRED_ALL:mode>_cntp):\n\tNew expander.\n\t(*aarch64_sve_<ANY_MINUS:inc_dec><DI_ONLY:mode><PRED_ALL:mode>_cntp)\n\t(*aarch64_incsi<PRED_ALL:mode>_cntp): New patterns.\n\t(@aarch64_sve_<SAT_MINUS:inc_dec><SI_ONLY:mode><PRED_ALL:mode>_cntp):\n\tNew expander.\n\t(*aarch64_sve_<SAT_MINUS:inc_dec><SI_ONLY:mode><PRED_ALL:mode>_cntp):\n\tNew pattern.\n\t(@aarch64_sve_<ANY_MINUS:inc_dec><VNx2DI_ONLY:mode>_cntp): New\n\texpander.\n\t(*aarch64_sve_<ANY_MINUS:inc_dec><VNx2DI_ONLY:mode>_cntp): New pattern.\n\t(@aarch64_sve_<ANY_MINUS:inc_dec><VNx4SI_ONLY:mode>_cntp): New\n\texpander.\n\t(*aarch64_sve_<ANY_MINUS:inc_dec><VNx4SI_ONLY:mode>_cntp): New pattern.\n\t(@aarch64_sve_<ANY_MINUS:inc_dec><VNx8HI_ONLY:mode>_cntp): New\n\texpander.\n\t(*aarch64_sve_<ANY_MINUS:inc_dec><VNx8HI_ONLY:mode>_cntp): New pattern.\n\t* config/aarch64/arm_sve.h: New file.\n\t* config/aarch64/aarch64-sve-builtins.h: Likewise.\n\t* config/aarch64/aarch64-sve-builtins.cc: Likewise.\n\t* config/aarch64/aarch64-sve-builtins.def: Likewise.\n\t* config/aarch64/aarch64-sve-builtins-base.h: Likewise.\n\t* config/aarch64/aarch64-sve-builtins-base.cc: Likewise.\n\t* config/aarch64/aarch64-sve-builtins-base.def: Likewise.\n\t* config/aarch64/aarch64-sve-builtins-functions.h: Likewise.\n\t* config/aarch64/aarch64-sve-builtins-shapes.h: Likewise.\n\t* config/aarch64/aarch64-sve-builtins-shapes.cc: Likewise.\n\ngcc/testsuite/\n\t* g++.target/aarch64/sve/acle/aarch64-sve-acle.exp: New file.\n\t* g++.target/aarch64/sve/acle/general-c++: New test directory.\n\t* gcc.target/aarch64/sve/acle/aarch64-sve-acle.exp: New file.\n\t* gcc.target/aarch64/sve/acle/general: New test directory.\n\t* gcc.target/aarch64/sve/acle/general-c: Likewise.\n\nCo-Authored-By: Kugan Vivekanandarajah <kuganv@linaro.org>\nCo-Authored-By: Prathamesh Kulkarni <prathamesh.kulkarni@linaro.org>\n\nFrom-SVN: r277563", "tree": {"sha": "0c882f73a8839f944b941539c9e04324e4b7b352", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c882f73a8839f944b941539c9e04324e4b7b352"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "28350fd1bee1e238e9c57b04c0796e1e17b659e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28350fd1bee1e238e9c57b04c0796e1e17b659e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28350fd1bee1e238e9c57b04c0796e1e17b659e4"}], "stats": {"total": 23527, "additions": 23235, "deletions": 292}, "files": [{"sha": "937a179ec72b3bbd336759e51aa9fe8f3a29b3c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -1,3 +1,444 @@\n+2019-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n+\t    Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n+\t    Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\n+\t* config.gcc (aarch64*-*-*): Add arm_sve.h to extra_headers.\n+\tAdd aarch64-sve-builtins.o, aarch64-sve-builtins-shapes.o and\n+\taarch64-sve-builtins-base.o to extra_objs.  Add\n+\taarch64-sve-builtins.h and aarch64-sve-builtins.cc to target_gtfiles.\n+\t* config/aarch64/t-aarch64 (aarch64-sve-builtins.o): New rule.\n+\t(aarch64-sve-builtins-shapes.o): Likewise.\n+\t(aarch64-sve-builtins-base.o): New rules.\n+\t* config/aarch64/aarch64-c.c (aarch64_pragma_aarch64): New function.\n+\t(aarch64_resolve_overloaded_builtin): Likewise.\n+\t(aarch64_check_builtin_call): Likewise.\n+\t(aarch64_register_pragmas): Install aarch64_resolve_overloaded_builtin\n+\tand aarch64_check_builtin_call in targetm.  Register the GCC aarch64\n+\tpragma.\n+\t* config/aarch64/aarch64-protos.h (AARCH64_FOR_SVPRFOP): New macro.\n+\t(aarch64_svprfop): New enum.\n+\t(AARCH64_BUILTIN_SVE): New aarch64_builtin_class enum value.\n+\t(aarch64_sve_int_mode, aarch64_sve_data_mode): Declare.\n+\t(aarch64_fold_sve_cnt_pat, aarch64_output_sve_prefetch): Likewise.\n+\t(aarch64_output_sve_cnt_pat_immediate): Likewise.\n+\t(aarch64_output_sve_ptrues, aarch64_sve_ptrue_svpattern_p): Likewise.\n+\t(aarch64_sve_sqadd_sqsub_immediate_p, aarch64_sve_ldff1_operand_p)\n+\t(aarch64_sve_ldnf1_operand_p, aarch64_sve_prefetch_operand_p)\n+\t(aarch64_ptrue_all_mode, aarch64_convert_sve_data_to_pred): Likewise.\n+\t(aarch64_expand_sve_dupq, aarch64_replace_reg_mode): Likewise.\n+\t(aarch64_sve::init_builtins, aarch64_sve::handle_arm_sve_h): Likewise.\n+\t(aarch64_sve::builtin_decl, aarch64_sve::builtin_type_p): Likewise.\n+\t(aarch64_sve::mangle_builtin_type): Likewise.\n+\t(aarch64_sve::resolve_overloaded_builtin): Likewise.\n+\t(aarch64_sve::check_builtin_call, aarch64_sve::gimple_fold_builtin)\n+\t(aarch64_sve::expand_builtin): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_sve_data_mode): Make public.\n+\t(aarch64_sve_int_mode): Likewise.\n+\t(aarch64_ptrue_all_mode): New function.\n+\t(aarch64_convert_sve_data_to_pred): Make public.\n+\t(svprfop_token): New function.\n+\t(aarch64_output_sve_prefetch): Likewise.\n+\t(aarch64_fold_sve_cnt_pat): Likewise.\n+\t(aarch64_output_sve_cnt_pat_immediate): Likewise.\n+\t(aarch64_sve_move_pred_via_while): Use gen_while with UNSPEC_WHILE_LO\n+\tinstead of gen_while_ult.\n+\t(aarch64_replace_reg_mode): Make public.\n+\t(aarch64_init_builtins): Call aarch64_sve::init_builtins.\n+\t(aarch64_fold_builtin): Handle AARCH64_BUILTIN_SVE.\n+\t(aarch64_gimple_fold_builtin, aarch64_expand_builtin): Likewise.\n+\t(aarch64_builtin_decl, aarch64_builtin_reciprocal): Likewise.\n+\t(aarch64_mangle_type): Call aarch64_sve::mangle_type.\n+\t(aarch64_sve_sqadd_sqsub_immediate_p): New function.\n+\t(aarch64_sve_ptrue_svpattern_p): Likewise.\n+\t(aarch64_sve_pred_valid_immediate): Check\n+\taarch64_sve_ptrue_svpattern_p.\n+\t(aarch64_sve_ldff1_operand_p, aarch64_sve_ldnf1_operand_p)\n+\t(aarch64_sve_prefetch_operand_p, aarch64_output_sve_ptrues): New\n+\tfunctions.\n+\t* config/aarch64/aarch64.md (UNSPEC_LDNT1_SVE, UNSPEC_STNT1_SVE)\n+\t(UNSPEC_LDFF1_GATHER, UNSPEC_PTRUE, UNSPEC_WHILE_LE, UNSPEC_WHILE_LS)\n+\t(UNSPEC_WHILE_LT, UNSPEC_CLASTA, UNSPEC_UPDATE_FFR)\n+\t(UNSPEC_UPDATE_FFRT, UNSPEC_RDFFR, UNSPEC_WRFFR)\n+\t(UNSPEC_SVE_LANE_SELECT, UNSPEC_SVE_CNT_PAT, UNSPEC_SVE_PREFETCH)\n+\t(UNSPEC_SVE_PREFETCH_GATHER, UNSPEC_SVE_COMPACT, UNSPEC_SVE_SPLICE):\n+\tNew unspecs.\n+\t* config/aarch64/iterators.md (SI_ONLY, DI_ONLY, VNx8HI_ONLY)\n+\t(VNx2DI_ONLY, SVE_PARTIAL, VNx8_NARROW, VNx8_WIDE, VNx4_NARROW)\n+\t(VNx4_WIDE, VNx2_NARROW, VNx2_WIDE, PRED_HSD): New mode iterators.\n+\t(UNSPEC_ADR, UNSPEC_BRKA, UNSPEC_BRKB, UNSPEC_BRKN, UNSPEC_BRKPA)\n+\t(UNSPEC_BRKPB, UNSPEC_PFIRST, UNSPEC_PNEXT, UNSPEC_CNTP, UNSPEC_SADDV)\n+\t(UNSPEC_UADDV, UNSPEC_FMLA, UNSPEC_FMLS, UNSPEC_FEXPA, UNSPEC_FTMAD)\n+\t(UNSPEC_FTSMUL, UNSPEC_FTSSEL, UNSPEC_COND_CMPEQ_WIDE): New unspecs.\n+\t(UNSPEC_COND_CMPGE_WIDE, UNSPEC_COND_CMPGT_WIDE): Likewise.\n+\t(UNSPEC_COND_CMPHI_WIDE, UNSPEC_COND_CMPHS_WIDE): Likewise.\n+\t(UNSPEC_COND_CMPLE_WIDE, UNSPEC_COND_CMPLO_WIDE): Likewise.\n+\t(UNSPEC_COND_CMPLS_WIDE, UNSPEC_COND_CMPLT_WIDE): Likewise.\n+\t(UNSPEC_COND_CMPNE_WIDE, UNSPEC_COND_FCADD90, UNSPEC_COND_FCADD270)\n+\t(UNSPEC_COND_FCMLA, UNSPEC_COND_FCMLA90, UNSPEC_COND_FCMLA180)\n+\t(UNSPEC_COND_FCMLA270, UNSPEC_COND_FMAX, UNSPEC_COND_FMIN): Likewise.\n+\t(UNSPEC_COND_FMULX, UNSPEC_COND_FRECPX, UNSPEC_COND_FSCALE): Likewise.\n+\t(UNSPEC_LASTA, UNSPEC_ASHIFT_WIDE, UNSPEC_ASHIFTRT_WIDE): Likewise.\n+\t(UNSPEC_LSHIFTRT_WIDE, UNSPEC_LDFF1, UNSPEC_LDNF1): Likewise.\n+\t(Vesize): Handle partial vector modes.\n+\t(self_mask, narrower_mask, sve_lane_con, sve_lane_pair_con): New\n+\tmode attributes.\n+\t(UBINQOPS, ANY_PLUS, SAT_PLUS, ANY_MINUS, SAT_MINUS): New code\n+\titerators.\n+\t(s, paired_extend, inc_dec): New code attributes.\n+\t(SVE_INT_ADDV, CLAST, LAST): New int iterators.\n+\t(SVE_INT_UNARY): Add UNSPEC_RBIT.\n+\t(SVE_FP_UNARY, SVE_FP_UNARY_INT): New int iterators.\n+\t(SVE_FP_BINARY, SVE_FP_BINARY_INT): Likewise.\n+\t(SVE_COND_FP_UNARY): Add UNSPEC_COND_FRECPX.\n+\t(SVE_COND_FP_BINARY): Add UNSPEC_COND_FMAX, UNSPEC_COND_FMIN and\n+\tUNSPEC_COND_FMULX.\n+\t(SVE_COND_FP_BINARY_INT, SVE_COND_FP_ADD): New int iterators.\n+\t(SVE_COND_FP_SUB, SVE_COND_FP_MUL): Likewise.\n+\t(SVE_COND_FP_BINARY_I1): Add UNSPEC_COND_FMAX and UNSPEC_COND_FMIN.\n+\t(SVE_COND_FP_BINARY_REG): Add UNSPEC_COND_FMULX.\n+\t(SVE_COND_FCADD, SVE_COND_FP_MAXMIN, SVE_COND_FCMLA)\n+\t(SVE_COND_INT_CMP_WIDE, SVE_FP_TERNARY_LANE, SVE_CFP_TERNARY_LANE)\n+\t(SVE_WHILE, SVE_SHIFT_WIDE, SVE_LDFF1_LDNF1, SVE_BRK_UNARY)\n+\t(SVE_BRK_BINARY, SVE_PITER): New int iterators.\n+\t(optab): Handle UNSPEC_SADDV, UNSPEC_UADDV, UNSPEC_FRECPE,\n+\tUNSPEC_FRECPS, UNSPEC_RSQRTE, UNSPEC_RSQRTS, UNSPEC_RBIT,\n+\tUNSPEC_SMUL_HIGHPART, UNSPEC_UMUL_HIGHPART, UNSPEC_FMLA, UNSPEC_FMLS,\n+\tUNSPEC_FCMLA, UNSPEC_FCMLA90, UNSPEC_FCMLA180, UNSPEC_FCMLA270,\n+\tUNSPEC_FEXPA, UNSPEC_FTSMUL, UNSPEC_FTSSEL, UNSPEC_COND_FCADD90,\n+\tUNSPEC_COND_FCADD270, UNSPEC_COND_FCMLA, UNSPEC_COND_FCMLA90,\n+\tUNSPEC_COND_FCMLA180, UNSPEC_COND_FCMLA270, UNSPEC_COND_FMAX,\n+\tUNSPEC_COND_FMIN, UNSPEC_COND_FMULX, UNSPEC_COND_FRECPX and\n+\tUNSPEC_COND_FSCALE.\n+\t(maxmin_uns): Handle UNSPEC_COND_FMAX and UNSPEC_COND_FMIN.\n+\t(binqops_op, binqops_op_rev, last_op): New int attributes.\n+\t(su): Handle UNSPEC_SADDV and UNSPEC_UADDV.\n+\t(fn, ab): New int attributes.\n+\t(cmp_op): Handle UNSPEC_COND_CMP*_WIDE and UNSPEC_WHILE_*.\n+\t(while_optab_cmp, brk_op, sve_pred_op): New int attributes.\n+\t(sve_int_op): Handle UNSPEC_SMUL_HIGHPART, UNSPEC_UMUL_HIGHPART,\n+\tUNSPEC_ASHIFT_WIDE, UNSPEC_ASHIFTRT_WIDE, UNSPEC_LSHIFTRT_WIDE and\n+\tUNSPEC_RBIT.\n+\t(sve_fp_op): Handle UNSPEC_FRECPE, UNSPEC_FRECPS, UNSPEC_RSQRTE,\n+\tUNSPEC_RSQRTS, UNSPEC_FMLA, UNSPEC_FMLS, UNSPEC_FEXPA, UNSPEC_FTSMUL,\n+\tUNSPEC_FTSSEL, UNSPEC_COND_FMAX, UNSPEC_COND_FMIN, UNSPEC_COND_FMULX,\n+\tUNSPEC_COND_FRECPX and UNSPEC_COND_FSCALE.\n+\t(sve_fp_op_rev): Handle UNSPEC_COND_FMAX, UNSPEC_COND_FMIN and\n+\tUNSPEC_COND_FMULX.\n+\t(rot): Handle UNSPEC_COND_FCADD* and UNSPEC_COND_FCMLA*.\n+\t(brk_reg_con, brk_reg_opno): New int attributes.\n+\t(sve_pred_fp_rhs1_operand, sve_pred_fp_rhs2_operand): Handle\n+\tUNSPEC_COND_FMAX, UNSPEC_COND_FMIN and UNSPEC_COND_FMULX.\n+\t(sve_pred_fp_rhs2_immediate): Handle UNSPEC_COND_FMAX and\n+\tUNSPEC_COND_FMIN.\n+\t(max_elem_bits): New int attribute.\n+\t(min_elem_bits): Handle UNSPEC_RBIT.\n+\t* config/aarch64/predicates.md (subreg_lowpart_operator): Handle\n+\tTRUNCATE as well as SUBREG.\n+\t(ascending_int_parallel, aarch64_simd_reg_or_minus_one)\n+\t(aarch64_sve_ldff1_operand, aarch64_sve_ldnf1_operand)\n+\t(aarch64_sve_prefetch_operand, aarch64_sve_ptrue_svpattern_immediate)\n+\t(aarch64_sve_qadd_immediate, aarch64_sve_qsub_immediate)\n+\t(aarch64_sve_gather_immediate_b, aarch64_sve_gather_immediate_h)\n+\t(aarch64_sve_gather_immediate_w, aarch64_sve_gather_immediate_d)\n+\t(aarch64_sve_sqadd_operand, aarch64_sve_gather_offset_b)\n+\t(aarch64_sve_gather_offset_h, aarch64_sve_gather_offset_w)\n+\t(aarch64_sve_gather_offset_d, aarch64_gather_scale_operand_b)\n+\t(aarch64_gather_scale_operand_h): New predicates.\n+\t* config/aarch64/constraints.md (UPb, UPd, UPh, UPw, Utf, Utn, vgb)\n+\t(vgd, vgh, vgw, vsQ, vsS): New constraints.\n+\t* config/aarch64/aarch64-sve.md: Add a note on the FFR handling.\n+\t(*aarch64_sve_reinterpret<mode>): Allow any source register\n+\tinstead of requiring an exact match.\n+\t(*aarch64_sve_ptruevnx16bi_cc, *aarch64_sve_ptrue<mode>_cc)\n+\t(*aarch64_sve_ptruevnx16bi_ptest, *aarch64_sve_ptrue<mode>_ptest)\n+\t(aarch64_wrffr, aarch64_update_ffr_for_load, aarch64_copy_ffr_to_ffrt)\n+\t(aarch64_rdffr, aarch64_rdffr_z, *aarch64_rdffr_z_ptest)\n+\t(*aarch64_rdffr_ptest, *aarch64_rdffr_z_cc, *aarch64_rdffr_cc)\n+\t(aarch64_update_ffrt): New patterns.\n+\t(@aarch64_load_<ANY_EXTEND:optab><VNx8_WIDE:mode><VNx8_NARROW:mode>)\n+\t(@aarch64_load_<ANY_EXTEND:optab><VNx4_WIDE:mode><VNx4_NARROW:mode>)\n+\t(@aarch64_load_<ANY_EXTEND:optab><VNx2_WIDE:mode><VNx2_NARROW:mode>)\n+\t(@aarch64_ld<fn>f1<mode>): New patterns.\n+\t(@aarch64_ld<fn>f1_<ANY_EXTEND:optab><VNx8_WIDE:mode><VNx8_NARROW:mode>)\n+\t(@aarch64_ld<fn>f1_<ANY_EXTEND:optab><VNx4_WIDE:mode><VNx4_NARROW:mode>)\n+\t(@aarch64_ld<fn>f1_<ANY_EXTEND:optab><VNx2_WIDE:mode><VNx2_NARROW:mode>)\n+\t(@aarch64_ldnt1<mode>): New patterns.\n+\t(gather_load<mode>): Use aarch64_sve_gather_offset_<Vesize> for\n+\tthe scalar part of the address.\n+\t(mask_gather_load<SVE_S:mode>): Use aarch64_sve_gather_offset_w for the\n+\tscalar part of the addresse and add an alternative for handling\n+\tnonzero offsets.\n+\t(mask_gather_load<SVE_D:mode>): Likewise aarch64_sve_gather_offset_d.\n+\t(*mask_gather_load<mode>_sxtw, *mask_gather_load<mode>_uxtw)\n+\t(@aarch64_gather_load_<ANY_EXTEND:optab><VNx4_WIDE:mode><VNx4_NARROW:mode>)\n+\t(@aarch64_gather_load_<ANY_EXTEND:optab><VNx2_WIDE:mode><VNx2_NARROW:mode>)\n+\t(*aarch64_gather_load_<ANY_EXTEND:optab><VNx2_WIDE:mode><VNx2_NARROW:mode>_sxtw)\n+\t(*aarch64_gather_load_<ANY_EXTEND:optab><VNx2_WIDE:mode><VNx2_NARROW:mode>_uxtw)\n+\t(@aarch64_ldff1_gather<SVE_S:mode>, @aarch64_ldff1_gather<SVE_D:mode>)\n+\t(*aarch64_ldff1_gather<mode>_sxtw, *aarch64_ldff1_gather<mode>_uxtw)\n+\t(@aarch64_ldff1_gather_<ANY_EXTEND:optab><VNx4_WIDE:mode><VNx4_NARROW:mode>)\n+\t(@aarch64_ldff1_gather_<ANY_EXTEND:optab><VNx2_WIDE:mode><VNx2_NARROW:mode>)\n+\t(*aarch64_ldff1_gather_<ANY_EXTEND:optab><VNx2_WIDE:mode><VNx2_NARROW:mode>_sxtw)\n+\t(*aarch64_ldff1_gather_<ANY_EXTEND:optab><VNx2_WIDE:mode><VNx2_NARROW:mode>_uxtw)\n+\t(@aarch64_sve_prefetch<mode>): New patterns.\n+\t(@aarch64_sve_gather_prefetch<SVE_I:mode><VNx4SI_ONLY:mode>)\n+\t(@aarch64_sve_gather_prefetch<SVE_I:mode><VNx2DI_ONLY:mode>)\n+\t(*aarch64_sve_gather_prefetch<SVE_I:mode><VNx2DI_ONLY:mode>_sxtw)\n+\t(*aarch64_sve_gather_prefetch<SVE_I:mode><VNx2DI_ONLY:mode>_uxtw)\n+\t(@aarch64_store_trunc<VNx8_NARROW:mode><VNx8_WIDE:mode>)\n+\t(@aarch64_store_trunc<VNx4_NARROW:mode><VNx4_WIDE:mode>)\n+\t(@aarch64_store_trunc<VNx2_NARROW:mode><VNx2_WIDE:mode>)\n+\t(@aarch64_stnt1<mode>): New patterns.\n+\t(scatter_store<mode>): Use aarch64_sve_gather_offset_<Vesize> for\n+\tthe scalar part of the address.\n+\t(mask_scatter_store<SVE_S:mode>): Use aarch64_sve_gather_offset_w for\n+\tthe scalar part of the addresse and add an alternative for handling\n+\tnonzero offsets.\n+\t(mask_scatter_store<SVE_D:mode>): Likewise aarch64_sve_gather_offset_d.\n+\t(*mask_scatter_store<mode>_sxtw, *mask_scatter_store<mode>_uxtw)\n+\t(@aarch64_scatter_store_trunc<VNx4_NARROW:mode><VNx4_WIDE:mode>)\n+\t(@aarch64_scatter_store_trunc<VNx2_NARROW:mode><VNx2_WIDE:mode>)\n+\t(*aarch64_scatter_store_trunc<VNx2_NARROW:mode><VNx2_WIDE:mode>_sxtw)\n+\t(*aarch64_scatter_store_trunc<VNx2_NARROW:mode><VNx2_WIDE:mode>_uxtw):\n+\tNew patterns.\n+\t(vec_duplicate<mode>): Use QI as the mode of the input operand.\n+\t(extract_last_<mode>): Generalize to...\n+\t(@extract_<LAST:last_op>_<mode>): ...this.\n+\t(*<SVE_INT_UNARY:optab><mode>2): Rename to...\n+\t(@aarch64_pred_<SVE_INT_UNARY:optab><mode>): ...this.\n+\t(@cond_<SVE_INT_UNARY:optab><mode>): New expander.\n+\t(@aarch64_pred_sxt<SVE_HSDI:mode><SVE_PARTIAL:mode>): New pattern.\n+\t(@aarch64_cond_sxt<SVE_HSDI:mode><SVE_PARTIAL:mode>): Likewise.\n+\t(@aarch64_pred_cnot<mode>, @cond_cnot<mode>): New expanders.\n+\t(@aarch64_sve_<SVE_FP_UNARY_INT:optab><mode>): New pattern.\n+\t(@aarch64_sve_<SVE_FP_UNARY:optab><mode>): Likewise.\n+\t(*<SVE_COND_FP_UNARY:optab><mode>2): Rename to...\n+\t(@aarch64_pred_<SVE_COND_FP_UNARY:optab><mode>): ...this.\n+\t(@cond_<SVE_COND_FP_UNARY:optab><mode>): New expander.\n+\t(*<SVE_INT_BINARY_IMM:optab><mode>3): Rename to...\n+\t(@aarch64_pred_<SVE_INT_BINARY_IMM:optab><mode>): ...this.\n+\t(@aarch64_adr<mode>, *aarch64_adr_sxtw): New patterns.\n+\t(*aarch64_adr_uxtw_unspec): Likewise.\n+\t(*aarch64_adr_uxtw): Rename to...\n+\t(*aarch64_adr_uxtw_and): ...this.\n+\t(@aarch64_adr<mode>_shift): New expander.\n+\t(*aarch64_adr_shift_sxtw): New pattern.\n+\t(aarch64_<su>abd<mode>_3): Rename to...\n+\t(@aarch64_pred_<su>abd<mode>): ...this.\n+\t(<su>abd<mode>_3): Update accordingly.\n+\t(@aarch64_cond_<su>abd<mode>): New expander.\n+\t(@aarch64_<SBINQOPS:su_optab><optab><mode>): New pattern.\n+\t(@aarch64_<UBINQOPS:su_optab><optab><mode>): Likewise.\n+\t(*<su>mul<mode>3_highpart): Rename to...\n+\t(@aarch64_pred_<optab><mode>): ...this.\n+\t(@cond_<MUL_HIGHPART:optab><mode>): New expander.\n+\t(*cond_<MUL_HIGHPART:optab><mode>_2): New pattern.\n+\t(*cond_<MUL_HIGHPART:optab><mode>_z): Likewise.\n+\t(*<SVE_INT_BINARY_SD:optab><mode>3): Rename to...\n+\t(@aarch64_pred_<SVE_INT_BINARY_SD:optab><mode>): ...this.\n+\t(cond_<SVE_INT_BINARY_SD:optab><mode>): Add a \"@\" marker.\n+\t(@aarch64_bic<mode>, @cond_bic<mode>): New expanders.\n+\t(*v<ASHIFT:optab><mode>3): Rename to...\n+\t(@aarch64_pred_<ASHIFT:optab><mode>): ...this.\n+\t(@aarch64_sve_<SVE_SHIFT_WIDE:sve_int_op><mode>): New pattern.\n+\t(@cond_<SVE_SHIFT_WIDE:sve_int_op><mode>): New expander.\n+\t(*cond_<SVE_SHIFT_WIDE:sve_int_op><mode>_m): New pattern.\n+\t(*cond_<SVE_SHIFT_WIDE:sve_int_op><mode>_z): Likewise.\n+\t(@cond_asrd<mode>): New expander.\n+\t(*cond_asrd<mode>_2, *cond_asrd<mode>_z): New patterns.\n+\t(sdiv_pow2<mode>3): Expand to *cond_asrd<mode>_2.\n+\t(*sdiv_pow2<mode>3): Delete.\n+\t(@cond_<SVE_COND_FP_BINARY_INT:optab><mode>): New expander.\n+\t(*cond_<SVE_COND_FP_BINARY_INT:optab><mode>_2): New pattern.\n+\t(*cond_<SVE_COND_FP_BINARY_INT:optab><mode>_any): Likewise.\n+\t(@aarch64_sve_<SVE_FP_BINARY:optab><mode>): New pattern.\n+\t(@aarch64_sve_<SVE_FP_BINARY_INT:optab><mode>): Likewise.\n+\t(*<SVE_COND_FP_BINARY_REG:optab><mode>3): Rename to...\n+\t(@aarch64_pred_<SVE_COND_FP_BINARY_REG:optab><mode>): ...this.\n+\t(@aarch64_pred_<SVE_COND_FP_BINARY_INT:optab><mode>): New pattern.\n+\t(cond_<SVE_COND_FP_BINARY:optab><mode>): Add a \"@\" marker.\n+\t(*add<SVE_F:mode>3): Rename to...\n+\t(@aarch64_pred_add<SVE_F:mode>): ...this and add alternatives\n+\tfor SVE_STRICT_GP.\n+\t(@aarch64_pred_<SVE_COND_FCADD:optab><mode>): New pattern.\n+\t(@cond_<SVE_COND_FCADD:optab><mode>): New expander.\n+\t(*cond_<SVE_COND_FCADD:optab><mode>_2): New pattern.\n+\t(*cond_<SVE_COND_FCADD:optab><mode>_any): Likewise.\n+\t(*sub<SVE_F:mode>3): Rename to...\n+\t(@aarch64_pred_sub<SVE_F:mode>): ...this and add alternatives\n+\tfor SVE_STRICT_GP.\n+\t(@aarch64_pred_abd<SVE_F:mode>): New expander.\n+\t(*fabd<SVE_F:mode>3): Rename to...\n+\t(*aarch64_pred_abd<SVE_F:mode>): ...this.\n+\t(@aarch64_cond_abd<SVE_F:mode>): New expander.\n+\t(*mul<SVE_F:mode>3): Rename to...\n+\t(@aarch64_pred_<SVE_F:optab><mode>): ...this and add alternatives\n+\tfor SVE_STRICT_GP.\n+\t(@aarch64_mul_lane_<SVE_F:mode>): New pattern.\n+\t(*<SVE_COND_FP_MAXMIN_PUBLIC:optab><mode>3): Rename and generalize\n+\tto...\n+\t(@aarch64_pred_<SVE_COND_FP_MAXMIN:optab><mode>): ...this.\n+\t(*<LOGICAL:optab><PRED_ALL:mode>3_ptest): New pattern.\n+\t(*<nlogical><PRED_ALL:mode>3): Rename to...\n+\t(aarch64_pred_<nlogical><PRED_ALL:mode>_z): ...this.\n+\t(*<nlogical><PRED_ALL:mode>3_cc): New pattern.\n+\t(*<nlogical><PRED_ALL:mode>3_ptest): Likewise.\n+\t(*<logical_nn><PRED_ALL:mode>3): Rename to...\n+\t(aarch64_pred_<logical_nn><mode>_z): ...this.\n+\t(*<logical_nn><PRED_ALL:mode>3_cc): New pattern.\n+\t(*<logical_nn><PRED_ALL:mode>3_ptest): Likewise.\n+\t(*fma<SVE_I:mode>4): Rename to...\n+\t(@aarch64_pred_fma<SVE_I:mode>): ...this.\n+\t(*fnma<SVE_I:mode>4): Rename to...\n+\t(@aarch64_pred_fnma<SVE_I:mode>): ...this.\n+\t(@aarch64_<sur>dot_prod_lane<vsi2qi>): New pattern.\n+\t(*<SVE_FP_TERNARY:optab><mode>4): Rename to...\n+\t(@aarch64_pred_<SVE_FP_TERNARY:optab><mode>): ...this.\n+\t(cond_<SVE_FP_TERNARY:optab><mode>): Add a \"@\" marker.\n+\t(@aarch64_<SVE_FP_TERNARY_LANE:optab>_lane_<mode>): New pattern.\n+\t(@aarch64_pred_<SVE_COND_FCMLA:optab><mode>): Likewise.\n+\t(@cond_<SVE_COND_FCMLA:optab><mode>): New expander.\n+\t(*cond_<SVE_COND_FCMLA:optab><mode>_4): New pattern.\n+\t(*cond_<SVE_COND_FCMLA:optab><mode>_any): Likewise.\n+\t(@aarch64_<FCMLA:optab>_lane_<mode>): Likewise.\n+\t(@aarch64_sve_tmad<mode>): Likewise.\n+\t(vcond_mask_<SVE_ALL:mode><vpred>): Add a \"@\" marker.\n+\t(*aarch64_sel_dup<mode>): Rename to...\n+\t(@aarch64_sel_dup<mode>): ...this.\n+\t(@aarch64_pred_cmp<cmp_op><SVE_I:mode>_wide): New pattern.\n+\t(*aarch64_pred_cmp<cmp_op><SVE_I:mode>_wide_cc): Likewise.\n+\t(*aarch64_pred_cmp<cmp_op><SVE_I:mode>_wide_ptest): Likewise.\n+\t(@while_ult<GPI:mode><PRED_ALL:mode>): Generalize to...\n+\t(@while_<while_optab_cmp><GPI:mode><PRED_ALL:mode>): ...this.\n+\t(*while_ult<GPI:mode><PRED_ALL:mode>_cc): Generalize to.\n+\t(*while_<while_optab_cmp><GPI:mode><PRED_ALL:mode>_cc): ...this.\n+\t(*while_<while_optab_cmp><GPI:mode><PRED_ALL:mode>_ptest): New pattern.\n+\t(*fcm<cmp_op><mode>): Rename to...\n+\t(@aarch64_pred_fcm<cmp_op><mode>): ...this.  Make operand order\n+\tmatch @aarch64_pred_cmp<cmp_op><SVE_I:mode>.\n+\t(*fcmuo<mode>): Rename to...\n+\t(@aarch64_pred_fcmuo<mode>): ...this.  Make operand order\n+\tmatch @aarch64_pred_cmp<cmp_op><SVE_I:mode>.\n+\t(@aarch64_pred_fac<cmp_op><mode>): New expander.\n+\t(@vcond_mask_<PRED_ALL:mode><mode>): New pattern.\n+\t(fold_extract_last_<mode>): Generalize to...\n+\t(@fold_extract_<last_op>_<mode>): ...this.\n+\t(@aarch64_fold_extract_vector_<last_op>_<mode>): New pattern.\n+\t(*reduc_plus_scal_<SVE_I:mode>): Replace with...\n+\t(@aarch64_pred_reduc_<optab>_<mode>): ...this pattern, making the\n+\tDImode result explicit.\n+\t(reduc_plus_scal_<mode>): Update accordingly.\n+\t(*reduc_<optab>_scal_<SVE_I:mode>): Rename to...\n+\t(@aarch64_pred_reduc_<optab>_<SVE_I:mode>): ...this.\n+\t(*reduc_<optab>_scal_<SVE_F:mode>): Rename to...\n+\t(@aarch64_pred_reduc_<optab>_<SVE_F:mode>): ...this.\n+\t(*aarch64_sve_tbl<mode>): Rename to...\n+\t(@aarch64_sve_tbl<mode>): ...this.\n+\t(@aarch64_sve_compact<mode>): New pattern.\n+\t(*aarch64_sve_dup_lane<mode>): Rename to...\n+\t(@aarch64_sve_dup_lane<mode>): ...this.\n+\t(@aarch64_sve_dupq_lane<mode>): New pattern.\n+\t(@aarch64_sve_splice<mode>): Likewise.\n+\t(aarch64_sve_<perm_insn><mode>): Rename to...\n+\t(@aarch64_sve_<perm_insn><mode>): ...this.\n+\t(*aarch64_sve_ext<mode>): Rename to...\n+\t(@aarch64_sve_ext<mode>): ...this.\n+\t(aarch64_sve_<su>unpk<perm_hilo>_<SVE_BHSI:mode>): Add a \"@\" marker.\n+\t(*aarch64_sve_<optab>_nontrunc<SVE_F:mode><SVE_HSDI:mode>): Rename\n+\tto...\n+\t(@aarch64_sve_<optab>_nontrunc<SVE_F:mode><SVE_HSDI:mode>): ...this.\n+\t(*aarch64_sve_<optab>_trunc<VNx2DF_ONLY:mode><VNx4SI_ONLY:mode>):\n+\tRename to...\n+\t(@aarch64_sve_<optab>_trunc<VNx2DF_ONLY:mode><VNx4SI_ONLY:mode>):\n+\t...this.\n+\t(@cond_<optab>_nontrunc<SVE_F:mode><SVE_HSDI:mode>): New expander.\n+\t(@cond_<optab>_trunc<VNx2DF_ONLY:mode><VNx4SI_ONLY:mode>): Likewise.\n+\t(*cond_<optab>_trunc<VNx2DF_ONLY:mode><VNx4SI_ONLY:mode>): New pattern.\n+\t(*aarch64_sve_<optab>_nonextend<SVE_HSDI:mode><SVE_F:mode>): Rename\n+\tto...\n+\t(@aarch64_sve_<optab>_nonextend<SVE_HSDI:mode><SVE_F:mode>): ...this.\n+\t(aarch64_sve_<optab>_extend<VNx4SI_ONLY:mode><VNx2DF_ONLY:mode>): Add\n+\ta \"@\" marker.\n+\t(@cond_<optab>_nonextend<SVE_HSDI:mode><SVE_F:mode>): New expander.\n+\t(@cond_<optab>_extend<VNx4SI_ONLY:mode><VNx2DF_ONLY:mode>): Likewise.\n+\t(*cond_<optab>_extend<VNx4SI_ONLY:mode><VNx2DF_ONLY:mode>): New\n+\tpattern.\n+\t(*aarch64_sve_<optab>_trunc<SVE_SDF:mode><SVE_HSF:mode>): Rename to...\n+\t(@aarch64_sve_<optab>_trunc<SVE_SDF:mode><SVE_HSF:mode>): ...this.\n+\t(@cond_<optab>_trunc<SVE_SDF:mode><SVE_HSF:mode>): New expander.\n+\t(*cond_<optab>_trunc<SVE_SDF:mode><SVE_HSF:mode>): New pattern.\n+\t(aarch64_sve_<optab>_nontrunc<SVE_HSF:mode><SVE_SDF:mode>): Add a\n+\t\"@\" marker.\n+\t(@cond_<optab>_nontrunc<SVE_HSF:mode><SVE_SDF:mode>): New expander.\n+\t(*cond_<optab>_nontrunc<SVE_HSF:mode><SVE_SDF:mode>): New pattern.\n+\t(aarch64_sve_punpk<perm_hilo>_<mode>): Add a \"@\" marker.\n+\t(@aarch64_brk<SVE_BRK_UNARY:brk_op>): New pattern.\n+\t(*aarch64_brk<SVE_BRK_UNARY:brk_op>_cc): Likewise.\n+\t(*aarch64_brk<SVE_BRK_UNARY:brk_op>_ptest): Likewise.\n+\t(@aarch64_brk<SVE_BRK_BINARY:brk_op>): Likewise.\n+\t(*aarch64_brk<SVE_BRK_BINARY:brk_op>_cc): Likewise.\n+\t(*aarch64_brk<SVE_BRK_BINARY:brk_op>_ptest): Likewise.\n+\t(@aarch64_sve_<SVE_PITER:sve_pred_op><mode>): Likewise.\n+\t(*aarch64_sve_<SVE_PITER:sve_pred_op><mode>_cc): Likewise.\n+\t(*aarch64_sve_<SVE_PITER:sve_pred_op><mode>_ptest): Likewise.\n+\t(aarch64_sve_cnt_pat): Likewise.\n+\t(@aarch64_sve_<ANY_PLUS:inc_dec><DI_ONLY:mode>_pat): Likewise.\n+\t(*aarch64_sve_incsi_pat): Likewise.\n+\t(@aarch64_sve_<SAT_PLUS:inc_dec><SI_ONLY:mode>_pat): Likewise.\n+\t(@aarch64_sve_<ANY_PLUS:inc_dec><VNx2DI_ONLY:mode>_pat): Likewise.\n+\t(@aarch64_sve_<ANY_PLUS:inc_dec><VNx4SI_ONLY:mode>_pat): Likewise.\n+\t(@aarch64_sve_<ANY_PLUS:inc_dec><VNx8HI_ONLY:mode>_pat): New expander.\n+\t(*aarch64_sve_<ANY_PLUS:inc_dec><VNx8HI_ONLY:mode>_pat): New pattern.\n+\t(@aarch64_sve_<ANY_MINUS:inc_dec><DI_ONLY:mode>_pat): Likewise.\n+\t(*aarch64_sve_decsi_pat): Likewise.\n+\t(@aarch64_sve_<SAT_MINUS:inc_dec><SI_ONLY:mode>_pat): Likewise.\n+\t(@aarch64_sve_<ANY_MINUS:inc_dec><VNx2DI_ONLY:mode>_pat): Likewise.\n+\t(@aarch64_sve_<ANY_MINUS:inc_dec><VNx4SI_ONLY:mode>_pat): Likewise.\n+\t(@aarch64_sve_<ANY_MINUS:inc_dec><VNx8HI_ONLY:mode>_pat): New expander.\n+\t(*aarch64_sve_<ANY_MINUS:inc_dec><VNx8HI_ONLY:mode>_pat): New pattern.\n+\t(@aarch64_pred_cntp<mode>): Likewise.\n+\t(@aarch64_sve_<ANY_PLUS:inc_dec><DI_ONLY:mode><PRED_ALL:mode>_cntp):\n+\tNew expander.\n+\t(*aarch64_sve_<ANY_PLUS:inc_dec><DI_ONLY:mode><PRED_ALL:mode>_cntp)\n+\t(*aarch64_incsi<PRED_ALL:mode>_cntp): New patterns.\n+\t(@aarch64_sve_<SAT_PLUS:inc_dec><SI_ONLY:mode><PRED_ALL:mode>_cntp):\n+\tNew expander.\n+\t(*aarch64_sve_<SAT_PLUS:inc_dec><SI_ONLY:mode><PRED_ALL:mode>_cntp):\n+\tNew pattern.\n+\t(@aarch64_sve_<ANY_PLUS:inc_dec><VNx2DI_ONLY:mode>_cntp): New expander.\n+\t(*aarch64_sve_<ANY_PLUS:inc_dec><VNx2DI_ONLY:mode>_cntp): New pattern.\n+\t(@aarch64_sve_<ANY_PLUS:inc_dec><VNx4SI_ONLY:mode>_cntp): New expander.\n+\t(*aarch64_sve_<ANY_PLUS:inc_dec><VNx4SI_ONLY:mode>_cntp): New pattern.\n+\t(@aarch64_sve_<ANY_PLUS:inc_dec><VNx8HI_ONLY:mode>_cntp): New expander.\n+\t(*aarch64_sve_<ANY_PLUS:inc_dec><VNx8HI_ONLY:mode>_cntp): New pattern.\n+\t(@aarch64_sve_<ANY_MINUS:inc_dec><DI_ONLY:mode><PRED_ALL:mode>_cntp):\n+\tNew expander.\n+\t(*aarch64_sve_<ANY_MINUS:inc_dec><DI_ONLY:mode><PRED_ALL:mode>_cntp)\n+\t(*aarch64_incsi<PRED_ALL:mode>_cntp): New patterns.\n+\t(@aarch64_sve_<SAT_MINUS:inc_dec><SI_ONLY:mode><PRED_ALL:mode>_cntp):\n+\tNew expander.\n+\t(*aarch64_sve_<SAT_MINUS:inc_dec><SI_ONLY:mode><PRED_ALL:mode>_cntp):\n+\tNew pattern.\n+\t(@aarch64_sve_<ANY_MINUS:inc_dec><VNx2DI_ONLY:mode>_cntp): New\n+\texpander.\n+\t(*aarch64_sve_<ANY_MINUS:inc_dec><VNx2DI_ONLY:mode>_cntp): New pattern.\n+\t(@aarch64_sve_<ANY_MINUS:inc_dec><VNx4SI_ONLY:mode>_cntp): New\n+\texpander.\n+\t(*aarch64_sve_<ANY_MINUS:inc_dec><VNx4SI_ONLY:mode>_cntp): New pattern.\n+\t(@aarch64_sve_<ANY_MINUS:inc_dec><VNx8HI_ONLY:mode>_cntp): New\n+\texpander.\n+\t(*aarch64_sve_<ANY_MINUS:inc_dec><VNx8HI_ONLY:mode>_cntp): New pattern.\n+\t* config/aarch64/arm_sve.h: New file.\n+\t* config/aarch64/aarch64-sve-builtins.h: Likewise.\n+\t* config/aarch64/aarch64-sve-builtins.cc: Likewise.\n+\t* config/aarch64/aarch64-sve-builtins.def: Likewise.\n+\t* config/aarch64/aarch64-sve-builtins-base.h: Likewise.\n+\t* config/aarch64/aarch64-sve-builtins-base.cc: Likewise.\n+\t* config/aarch64/aarch64-sve-builtins-base.def: Likewise.\n+\t* config/aarch64/aarch64-sve-builtins-functions.h: Likewise.\n+\t* config/aarch64/aarch64-sve-builtins-shapes.h: Likewise.\n+\t* config/aarch64/aarch64-sve-builtins-shapes.cc: Likewise.\n+\n 2019-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/aarch64/aarch64-sve.md (@aarch64_sve_rev<PRED_ALL:mode>):"}, {"sha": "d74bcbb9856922a930c1318703d14916cfc159a0", "filename": "gcc/config.gcc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -315,12 +315,12 @@ m32c*-*-*)\n         ;;\n aarch64*-*-*)\n \tcpu_type=aarch64\n-\textra_headers=\"arm_fp16.h arm_neon.h arm_acle.h\"\n+\textra_headers=\"arm_fp16.h arm_neon.h arm_acle.h arm_sve.h\"\n \tc_target_objs=\"aarch64-c.o\"\n \tcxx_target_objs=\"aarch64-c.o\"\n \td_target_objs=\"aarch64-d.o\"\n-\textra_objs=\"aarch64-builtins.o aarch-common.o cortex-a57-fma-steering.o aarch64-speculation.o falkor-tag-collision-avoidance.o aarch64-bti-insert.o\"\n-\ttarget_gtfiles=\"\\$(srcdir)/config/aarch64/aarch64-builtins.c\"\n+\textra_objs=\"aarch64-builtins.o aarch-common.o aarch64-sve-builtins.o aarch64-sve-builtins-shapes.o aarch64-sve-builtins-base.o cortex-a57-fma-steering.o aarch64-speculation.o falkor-tag-collision-avoidance.o aarch64-bti-insert.o\"\n+\ttarget_gtfiles=\"\\$(srcdir)/config/aarch64/aarch64-builtins.c \\$(srcdir)/config/aarch64/aarch64-sve-builtins.h \\$(srcdir)/config/aarch64/aarch64-sve-builtins.cc\"\n \ttarget_has_targetm_common=yes\n \t;;\n alpha*-*-*)"}, {"sha": "7c322ca0813caea8894abd0106dec04a75e714dc", "filename": "gcc/config/aarch64/aarch64-c.c", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-c.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -243,11 +243,83 @@ aarch64_pragma_target_parse (tree args, tree pop_target)\n   return true;\n }\n \n+/* Implement \"#pragma GCC aarch64\".  */\n+static void\n+aarch64_pragma_aarch64 (cpp_reader *)\n+{\n+  tree x;\n+  if (pragma_lex (&x) != CPP_STRING)\n+    {\n+      error (\"%<#pragma GCC aarch64%> requires a string parameter\");\n+      return;\n+    }\n+\n+  const char *name = TREE_STRING_POINTER (x);\n+  if (strcmp (name, \"arm_sve.h\") == 0)\n+    aarch64_sve::handle_arm_sve_h ();\n+  else\n+    error (\"unknown %<#pragma GCC aarch64%> option %qs\", name);\n+}\n+\n+/* Implement TARGET_RESOLVE_OVERLOADED_BUILTIN.  */\n+static tree\n+aarch64_resolve_overloaded_builtin (unsigned int uncast_location,\n+\t\t\t\t    tree fndecl, void *uncast_arglist)\n+{\n+  vec<tree, va_gc> empty = {};\n+  location_t location = (location_t) uncast_location;\n+  vec<tree, va_gc> *arglist = (uncast_arglist\n+\t\t\t       ? (vec<tree, va_gc> *) uncast_arglist\n+\t\t\t       : &empty);\n+  unsigned int code = DECL_MD_FUNCTION_CODE (fndecl);\n+  unsigned int subcode = code >> AARCH64_BUILTIN_SHIFT;\n+  tree new_fndecl;\n+  switch (code & AARCH64_BUILTIN_CLASS)\n+    {\n+    case AARCH64_BUILTIN_GENERAL:\n+      return NULL_TREE;\n+\n+    case AARCH64_BUILTIN_SVE:\n+      new_fndecl = aarch64_sve::resolve_overloaded_builtin (location, subcode,\n+\t\t\t\t\t\t\t    arglist);\n+      break;\n+    }\n+  if (new_fndecl == NULL_TREE || new_fndecl == error_mark_node)\n+    return new_fndecl;\n+  return build_function_call_vec (location, vNULL, new_fndecl, arglist,\n+\t\t\t\t  NULL, fndecl);\n+}\n+\n+/* Implement TARGET_CHECK_BUILTIN_CALL.  */\n+static bool\n+aarch64_check_builtin_call (location_t loc, vec<location_t> arg_loc,\n+\t\t\t    tree fndecl, tree orig_fndecl,\n+\t\t\t    unsigned int nargs, tree *args)\n+{\n+  unsigned int code = DECL_MD_FUNCTION_CODE (fndecl);\n+  unsigned int subcode = code >> AARCH64_BUILTIN_SHIFT;\n+  switch (code & AARCH64_BUILTIN_CLASS)\n+    {\n+    case AARCH64_BUILTIN_GENERAL:\n+      return true;\n+\n+    case AARCH64_BUILTIN_SVE:\n+      return aarch64_sve::check_builtin_call (loc, arg_loc, subcode,\n+\t\t\t\t\t      orig_fndecl, nargs, args);\n+    }\n+  gcc_unreachable ();\n+}\n+\n /* Implement REGISTER_TARGET_PRAGMAS.  */\n \n void\n aarch64_register_pragmas (void)\n {\n   /* Update pragma hook to allow parsing #pragma GCC target.  */\n   targetm.target_option.pragma_parse = aarch64_pragma_target_parse;\n+\n+  targetm.resolve_overloaded_builtin = aarch64_resolve_overloaded_builtin;\n+  targetm.check_builtin_call = aarch64_check_builtin_call;\n+\n+  c_register_pragma (\"GCC\", \"aarch64\", aarch64_pragma_aarch64);\n }"}, {"sha": "15f288b9ee33fb1c7300888284eb7f80b1e82f66", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -426,19 +426,40 @@ extern struct tune_params aarch64_tune_params;\n   T (MUL3, mul3, 30) \\\n   T (ALL, all, 31)\n \n+/* The available SVE prefetch operations, known in the ACLE as \"svprfop\".  */\n+#define AARCH64_FOR_SVPRFOP(T) \\\n+  T (PLDL1KEEP, pldl1keep, 0) \\\n+  T (PLDL1STRM, pldl1strm, 1) \\\n+  T (PLDL2KEEP, pldl2keep, 2) \\\n+  T (PLDL2STRM, pldl2strm, 3) \\\n+  T (PLDL3KEEP, pldl3keep, 4) \\\n+  T (PLDL3STRM, pldl3strm, 5) \\\n+  T (PSTL1KEEP, pstl1keep, 8) \\\n+  T (PSTL1STRM, pstl1strm, 9) \\\n+  T (PSTL2KEEP, pstl2keep, 10) \\\n+  T (PSTL2STRM, pstl2strm, 11) \\\n+  T (PSTL3KEEP, pstl3keep, 12) \\\n+  T (PSTL3STRM, pstl3strm, 13)\n+\n #define AARCH64_SVENUM(UPPER, LOWER, VALUE) AARCH64_SV_##UPPER = VALUE,\n enum aarch64_svpattern {\n   AARCH64_FOR_SVPATTERN (AARCH64_SVENUM)\n   AARCH64_NUM_SVPATTERNS\n };\n+\n+enum aarch64_svprfop {\n+  AARCH64_FOR_SVPRFOP (AARCH64_SVENUM)\n+  AARCH64_NUM_SVPRFOPS\n+};\n #undef AARCH64_SVENUM\n \n /* It's convenient to divide the built-in function codes into groups,\n    rather than having everything in a single enum.  This type enumerates\n    those groups.  */\n enum aarch64_builtin_class\n {\n-  AARCH64_BUILTIN_GENERAL\n+  AARCH64_BUILTIN_GENERAL,\n+  AARCH64_BUILTIN_SVE\n };\n \n /* Built-in function codes are structured so that the low\n@@ -489,8 +510,11 @@ bool aarch64_masks_and_shift_for_bfi_p (scalar_int_mode, unsigned HOST_WIDE_INT,\n \t\t\t\t\tunsigned HOST_WIDE_INT);\n bool aarch64_zero_extend_const_eq (machine_mode, rtx, machine_mode, rtx);\n bool aarch64_move_imm (HOST_WIDE_INT, machine_mode);\n+machine_mode aarch64_sve_int_mode (machine_mode);\n opt_machine_mode aarch64_sve_pred_mode (unsigned int);\n+opt_machine_mode aarch64_sve_data_mode (scalar_mode, poly_uint64);\n bool aarch64_sve_mode_p (machine_mode);\n+HOST_WIDE_INT aarch64_fold_sve_cnt_pat (aarch64_svpattern, unsigned int);\n bool aarch64_sve_cnt_immediate_p (rtx);\n bool aarch64_sve_scalar_inc_dec_immediate_p (rtx);\n bool aarch64_sve_addvl_addpl_immediate_p (rtx);\n@@ -501,14 +525,17 @@ bool aarch64_mov_operand_p (rtx, machine_mode);\n rtx aarch64_reverse_mask (machine_mode, unsigned int);\n bool aarch64_offset_7bit_signed_scaled_p (machine_mode, poly_int64);\n bool aarch64_offset_9bit_signed_unscaled_p (machine_mode, poly_int64);\n+char *aarch64_output_sve_prefetch (const char *, rtx, const char *);\n char *aarch64_output_sve_cnt_immediate (const char *, const char *, rtx);\n+char *aarch64_output_sve_cnt_pat_immediate (const char *, const char *, rtx *);\n char *aarch64_output_sve_scalar_inc_dec (rtx);\n char *aarch64_output_sve_addvl_addpl (rtx);\n char *aarch64_output_sve_vector_inc_dec (const char *, rtx);\n char *aarch64_output_scalar_simd_mov_immediate (rtx, scalar_int_mode);\n char *aarch64_output_simd_mov_immediate (rtx, unsigned,\n \t\t\tenum simd_immediate_check w = AARCH64_CHECK_MOV);\n char *aarch64_output_sve_mov_immediate (rtx);\n+char *aarch64_output_sve_ptrues (rtx);\n bool aarch64_pad_reg_upward (machine_mode, const_tree, bool);\n bool aarch64_regno_ok_for_base_p (int, bool);\n bool aarch64_regno_ok_for_index_p (int, bool);\n@@ -517,11 +544,13 @@ bool aarch64_simd_check_vect_par_cnst_half (rtx op, machine_mode mode,\n \t\t\t\t\t    bool high);\n bool aarch64_simd_scalar_immediate_valid_for_move (rtx, scalar_int_mode);\n bool aarch64_simd_shift_imm_p (rtx, machine_mode, bool);\n+bool aarch64_sve_ptrue_svpattern_p (rtx, struct simd_immediate_info *);\n bool aarch64_simd_valid_immediate (rtx, struct simd_immediate_info *,\n \t\t\tenum simd_immediate_check w = AARCH64_CHECK_MOV);\n rtx aarch64_check_zero_based_sve_index_immediate (rtx);\n bool aarch64_sve_index_immediate_p (rtx);\n bool aarch64_sve_arith_immediate_p (rtx, bool);\n+bool aarch64_sve_sqadd_sqsub_immediate_p (rtx, bool);\n bool aarch64_sve_bitmask_immediate_p (rtx);\n bool aarch64_sve_dup_immediate_p (rtx);\n bool aarch64_sve_cmp_immediate_p (rtx, bool);\n@@ -552,7 +581,10 @@ rtx aarch64_simd_gen_const_vector_dup (machine_mode, HOST_WIDE_INT);\n bool aarch64_simd_mem_operand_p (rtx);\n bool aarch64_sve_ld1r_operand_p (rtx);\n bool aarch64_sve_ld1rq_operand_p (rtx);\n+bool aarch64_sve_ldff1_operand_p (rtx);\n+bool aarch64_sve_ldnf1_operand_p (rtx);\n bool aarch64_sve_ldr_operand_p (rtx);\n+bool aarch64_sve_prefetch_operand_p (rtx, machine_mode);\n bool aarch64_sve_struct_memory_operand_p (rtx);\n rtx aarch64_simd_vect_par_cnst_half (machine_mode, int, bool);\n rtx aarch64_gen_stepped_int_parallel (unsigned int, int, int);\n@@ -568,6 +600,9 @@ const char * aarch64_output_probe_sve_stack_clash (rtx, rtx, rtx, rtx);\n void aarch64_err_no_fpadvsimd (machine_mode);\n void aarch64_expand_epilogue (bool);\n rtx aarch64_ptrue_all (unsigned int);\n+opt_machine_mode aarch64_ptrue_all_mode (rtx);\n+rtx aarch64_convert_sve_data_to_pred (rtx, machine_mode, rtx);\n+rtx aarch64_expand_sve_dupq (rtx, machine_mode, rtx);\n void aarch64_expand_mov_immediate (rtx, rtx);\n rtx aarch64_ptrue_reg (machine_mode);\n rtx aarch64_pfalse_reg (machine_mode);\n@@ -576,6 +611,7 @@ bool aarch64_sve_same_pred_for_ptest_p (rtx *, rtx *);\n void aarch64_emit_sve_pred_move (rtx, rtx, rtx);\n void aarch64_expand_sve_mem_move (rtx, rtx, machine_mode);\n bool aarch64_maybe_expand_sve_subreg_move (rtx, rtx);\n+rtx aarch64_replace_reg_mode (rtx, machine_mode);\n void aarch64_split_sve_subreg_move (rtx, rtx, rtx);\n void aarch64_expand_prologue (void);\n void aarch64_expand_vector_init (rtx, rtx);\n@@ -664,6 +700,20 @@ tree aarch64_general_builtin_decl (unsigned, bool);\n tree aarch64_general_builtin_rsqrt (unsigned int);\n tree aarch64_builtin_vectorized_function (unsigned int, tree, tree);\n \n+namespace aarch64_sve {\n+  void init_builtins ();\n+  void handle_arm_sve_h ();\n+  tree builtin_decl (unsigned, bool);\n+  bool builtin_type_p (const_tree);\n+  const char *mangle_builtin_type (const_tree);\n+  tree resolve_overloaded_builtin (location_t, unsigned int,\n+\t\t\t\t   vec<tree, va_gc> *);\n+  bool check_builtin_call (location_t, vec<location_t>, unsigned int,\n+\t\t\t   tree, unsigned int, tree *);\n+  gimple *gimple_fold_builtin (unsigned int, gimple_stmt_iterator *, gcall *);\n+  rtx expand_builtin (unsigned int, tree, rtx);\n+}\n+\n extern void aarch64_split_combinev16qi (rtx operands[3]);\n extern void aarch64_expand_vec_perm (rtx, rtx, rtx, rtx, unsigned int);\n extern void aarch64_expand_sve_vec_perm (rtx, rtx, rtx, rtx);"}, {"sha": "ce70f80e98ffeb419a3ba683cb58cddd36f03c72", "filename": "gcc/config/aarch64/aarch64-sve-builtins-base.cc", "status": "added", "additions": 2704, "deletions": 0, "changes": 2704, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-base.cc?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,2704 @@\n+/* ACLE support for AArch64 SVE (__ARM_FEATURE_SVE intrinsics)\n+   Copyright (C) 2018-2019 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"memmodel.h\"\n+#include \"insn-codes.h\"\n+#include \"optabs.h\"\n+#include \"recog.h\"\n+#include \"expr.h\"\n+#include \"basic-block.h\"\n+#include \"function.h\"\n+#include \"fold-const.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimplify.h\"\n+#include \"explow.h\"\n+#include \"emit-rtl.h\"\n+#include \"tree-vector-builder.h\"\n+#include \"rtx-vector-builder.h\"\n+#include \"vec-perm-indices.h\"\n+#include \"aarch64-sve-builtins.h\"\n+#include \"aarch64-sve-builtins-shapes.h\"\n+#include \"aarch64-sve-builtins-base.h\"\n+#include \"aarch64-sve-builtins-functions.h\"\n+\n+using namespace aarch64_sve;\n+\n+namespace {\n+\n+/* Expand a call to svmad, or svmla after reordering its operands.\n+   Make _m forms merge with argument MERGE_ARGNO.  */\n+static rtx\n+expand_mad (function_expander &e,\n+\t    unsigned int merge_argno = DEFAULT_MERGE_ARGNO)\n+{\n+  if (e.pred == PRED_x)\n+    {\n+      insn_code icode;\n+      if (e.type_suffix (0).integer_p)\n+\ticode = code_for_aarch64_pred_fma (e.vector_mode (0));\n+      else\n+\ticode = code_for_aarch64_pred (UNSPEC_COND_FMLA, e.vector_mode (0));\n+      return e.use_pred_x_insn (icode);\n+    }\n+\n+  insn_code icode = e.direct_optab_handler (cond_fma_optab);\n+  return e.use_cond_insn (icode, merge_argno);\n+}\n+\n+/* Expand a call to svmsb, or svmls after reordering its operands.\n+   Make _m forms merge with argument MERGE_ARGNO.  */\n+static rtx\n+expand_msb (function_expander &e,\n+\t    unsigned int merge_argno = DEFAULT_MERGE_ARGNO)\n+{\n+  if (e.pred == PRED_x)\n+    {\n+      insn_code icode;\n+      if (e.type_suffix (0).integer_p)\n+\ticode = code_for_aarch64_pred_fnma (e.vector_mode (0));\n+      else\n+\ticode = code_for_aarch64_pred (UNSPEC_COND_FMLS, e.vector_mode (0));\n+      return e.use_pred_x_insn (icode);\n+    }\n+\n+  insn_code icode = e.direct_optab_handler (cond_fnma_optab);\n+  return e.use_cond_insn (icode, merge_argno);\n+}\n+\n+class svabd_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* The integer operations are represented as the subtraction of the\n+       minimum from the maximum, with the signedness of the instruction\n+       keyed off the signedness of the maximum operation.  */\n+    rtx_code max_code = e.type_suffix (0).unsigned_p ? UMAX : SMAX;\n+    insn_code icode;\n+    if (e.pred == PRED_x)\n+      {\n+\tif (e.type_suffix (0).integer_p)\n+\t  icode = code_for_aarch64_pred_abd (max_code, e.vector_mode (0));\n+\telse\n+\t  icode = code_for_aarch64_pred_abd (e.vector_mode (0));\n+\treturn e.use_pred_x_insn (icode);\n+      }\n+\n+    if (e.type_suffix (0).integer_p)\n+      icode = code_for_aarch64_cond_abd (max_code, e.vector_mode (0));\n+    else\n+      icode = code_for_aarch64_cond_abd (e.vector_mode (0));\n+    return e.use_cond_insn (icode);\n+  }\n+};\n+\n+/* Implements svacge, svacgt, svacle and svaclt.  */\n+class svac_impl : public function_base\n+{\n+public:\n+  CONSTEXPR svac_impl (int unspec) : m_unspec (unspec) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    e.add_ptrue_hint (0, e.gp_mode (0));\n+    insn_code icode = code_for_aarch64_pred_fac (m_unspec, e.vector_mode (0));\n+    return e.use_exact_insn (icode);\n+  }\n+\n+  /* The unspec code for the underlying comparison.  */\n+  int m_unspec;\n+};\n+\n+class svadda_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* Put the predicate last, as required by mask_fold_left_plus_optab.  */\n+    e.rotate_inputs_left (0, 3);\n+    machine_mode mode = e.vector_mode (0);\n+    insn_code icode = direct_optab_handler (mask_fold_left_plus_optab, mode);\n+    return e.use_exact_insn (icode);\n+  }\n+};\n+\n+/* Implements svadr[bhwd].  */\n+class svadr_bhwd_impl : public function_base\n+{\n+public:\n+  CONSTEXPR svadr_bhwd_impl (unsigned int shift) : m_shift (shift) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    machine_mode mode = GET_MODE (e.args[0]);\n+    if (m_shift == 0)\n+      return e.use_exact_insn (code_for_aarch64_adr (mode));\n+\n+    /* Turn the access size into an extra shift argument.  */\n+    rtx shift = gen_int_mode (m_shift, GET_MODE_INNER (mode));\n+    e.args.quick_push (expand_vector_broadcast (mode, shift));\n+    return e.use_exact_insn (code_for_aarch64_adr_shift (mode));\n+  }\n+\n+  /* How many bits left to shift the vector displacement.  */\n+  unsigned int m_shift;\n+};\n+\n+class svasrd_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return e.use_cond_insn (code_for_cond_asrd (e.vector_mode (0)));\n+  }\n+};\n+\n+class svbic_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* Convert svbic of a constant into svand of its inverse.  */\n+    if (CONST_INT_P (e.args[2]))\n+      {\n+\tmachine_mode mode = GET_MODE_INNER (e.vector_mode (0));\n+\te.args[2] = simplify_unary_operation (NOT, mode, e.args[2], mode);\n+\treturn e.map_to_rtx_codes (AND, AND, -1);\n+      }\n+\n+    if (e.type_suffix_ids[0] == TYPE_SUFFIX_b)\n+      {\n+\tgcc_assert (e.pred == PRED_z);\n+\treturn e.use_exact_insn (CODE_FOR_aarch64_pred_bicvnx16bi_z);\n+      }\n+\n+    if (e.pred == PRED_x)\n+      return e.use_unpred_insn (code_for_aarch64_bic (e.vector_mode (0)));\n+\n+    return e.use_cond_insn (code_for_cond_bic (e.vector_mode (0)));\n+  }\n+};\n+\n+/* Implements svbrkn, svbrkpa and svbrkpb.  */\n+class svbrk_binary_impl : public function_base\n+{\n+public:\n+  CONSTEXPR svbrk_binary_impl (int unspec) : m_unspec (unspec) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return e.use_exact_insn (code_for_aarch64_brk (m_unspec));\n+  }\n+\n+  /* The unspec code associated with the operation.  */\n+  int m_unspec;\n+};\n+\n+/* Implements svbrka and svbrkb.  */\n+class svbrk_unary_impl : public function_base\n+{\n+public:\n+  CONSTEXPR svbrk_unary_impl (int unspec) : m_unspec (unspec) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return e.use_cond_insn (code_for_aarch64_brk (m_unspec));\n+  }\n+\n+  /* The unspec code associated with the operation.  */\n+  int m_unspec;\n+};\n+\n+class svcadd_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* Convert the rotation amount into a specific unspec.  */\n+    int rot = INTVAL (e.args[3]);\n+    e.args.ordered_remove (3);\n+    int unspec = (rot == 90 ? UNSPEC_COND_FCADD90\n+\t\t  : rot == 270 ? UNSPEC_COND_FCADD270\n+\t\t  : (gcc_unreachable (), 0));\n+    return e.map_to_unspecs (-1, -1, unspec);\n+  }\n+};\n+\n+/* Implements svclasta and svclastb.  */\n+class svclast_impl : public quiet<function_base>\n+{\n+public:\n+  CONSTEXPR svclast_impl (int unspec) : m_unspec (unspec) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* Match the fold_extract_optab order.  */\n+    std::swap (e.args[0], e.args[1]);\n+    machine_mode mode = e.vector_mode (0);\n+    insn_code icode;\n+    if (e.mode_suffix_id == MODE_n)\n+      icode = code_for_fold_extract (m_unspec, mode);\n+    else\n+      icode = code_for_aarch64_fold_extract_vector (m_unspec, mode);\n+    return e.use_exact_insn (icode);\n+  }\n+\n+  /* The unspec code associated with the operation.  */\n+  int m_unspec;\n+};\n+\n+class svcmla_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* Convert the rotation amount into a specific unspec.  */\n+    int rot = INTVAL (e.args[4]);\n+    e.args.ordered_remove (4);\n+    int unspec = (rot == 0 ? UNSPEC_COND_FCMLA\n+\t\t  : rot == 90 ? UNSPEC_COND_FCMLA90\n+\t\t  : rot == 180 ? UNSPEC_COND_FCMLA180\n+\t\t  : rot == 270 ? UNSPEC_COND_FCMLA270\n+\t\t  : (gcc_unreachable (), 0));\n+\n+    /* Make the operand order the same as the one used by the fma optabs,\n+       with the accumulator last.  */\n+    e.rotate_inputs_left (1, 4);\n+    return e.map_to_unspecs (-1, -1, unspec, 3);\n+  }\n+};\n+\n+class svcmla_lane_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* Convert the rotation amount into a specific unspec.  */\n+    int rot = INTVAL (e.args[4]);\n+    e.args.ordered_remove (4);\n+    int unspec = (rot == 0 ? UNSPEC_FCMLA\n+\t\t  : rot == 90 ? UNSPEC_FCMLA90\n+\t\t  : rot == 180 ? UNSPEC_FCMLA180\n+\t\t  : rot == 270 ? UNSPEC_FCMLA270\n+\t\t  : (gcc_unreachable (), 0));\n+\n+    /* Make the operand order the same as the one used by the fma optabs,\n+       with the accumulator last.  */\n+    e.rotate_inputs_left (0, 4);\n+    insn_code icode = code_for_aarch64_lane (unspec, e.vector_mode (0));\n+    return e.use_exact_insn (icode);\n+  }\n+};\n+\n+/* Implements svcmp<cc> (except svcmpuo, which is handled separately).  */\n+class svcmp_impl : public function_base\n+{\n+public:\n+  CONSTEXPR svcmp_impl (tree_code code, int unspec_for_fp)\n+    : m_code (code), m_unspec_for_fp (unspec_for_fp) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    machine_mode mode = e.vector_mode (0);\n+\n+    /* Comparisons are UNSPEC_PRED_Z operations and so need a hint\n+       operand.  */\n+    e.add_ptrue_hint (0, e.gp_mode (0));\n+\n+    if (e.type_suffix (0).integer_p)\n+      {\n+\tbool unsigned_p = e.type_suffix (0).unsigned_p;\n+\trtx_code code = get_rtx_code (m_code, unsigned_p);\n+\treturn e.use_exact_insn (code_for_aarch64_pred_cmp (code, mode));\n+      }\n+\n+    insn_code icode = code_for_aarch64_pred_fcm (m_unspec_for_fp, mode);\n+    return e.use_exact_insn (icode);\n+  }\n+\n+  /* The tree code associated with the comparison.  */\n+  tree_code m_code;\n+\n+  /* The unspec code to use for floating-point comparisons.  */\n+  int m_unspec_for_fp;\n+};\n+\n+/* Implements svcmp<cc>_wide.  */\n+class svcmp_wide_impl : public function_base\n+{\n+public:\n+  CONSTEXPR svcmp_wide_impl (tree_code code, int unspec_for_sint,\n+\t\t\t     int unspec_for_uint)\n+    : m_code (code), m_unspec_for_sint (unspec_for_sint),\n+      m_unspec_for_uint (unspec_for_uint) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    machine_mode mode = e.vector_mode (0);\n+    bool unsigned_p = e.type_suffix (0).unsigned_p;\n+    rtx_code code = get_rtx_code (m_code, unsigned_p);\n+\n+    /* Comparisons are UNSPEC_PRED_Z operations and so need a hint\n+       operand.  */\n+    e.add_ptrue_hint (0, e.gp_mode (0));\n+\n+    /* If the argument is a constant that the unwidened comparisons\n+       can handle directly, use them instead.  */\n+    insn_code icode = code_for_aarch64_pred_cmp (code, mode);\n+    rtx op2 = unwrap_const_vec_duplicate (e.args[3]);\n+    if (CONSTANT_P (op2)\n+\t&& insn_data[icode].operand[4].predicate (op2, DImode))\n+      {\n+\te.args[3] = op2;\n+\treturn e.use_exact_insn (icode);\n+      }\n+\n+    int unspec = (unsigned_p ? m_unspec_for_uint : m_unspec_for_sint);\n+    return e.use_exact_insn (code_for_aarch64_pred_cmp_wide (unspec, mode));\n+  }\n+\n+  /* The tree code associated with the comparison.  */\n+  tree_code m_code;\n+\n+  /* The unspec codes for signed and unsigned wide comparisons\n+     respectively.  */\n+  int m_unspec_for_sint;\n+  int m_unspec_for_uint;\n+};\n+\n+class svcmpuo_impl : public quiet<function_base>\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    e.add_ptrue_hint (0, e.gp_mode (0));\n+    return e.use_exact_insn (code_for_aarch64_pred_fcmuo (e.vector_mode (0)));\n+  }\n+};\n+\n+class svcnot_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    machine_mode mode = e.vector_mode (0);\n+    if (e.pred == PRED_x)\n+      {\n+\t/* The pattern for CNOT includes an UNSPEC_PRED_Z, so needs\n+\t   a ptrue hint.  */\n+\te.add_ptrue_hint (0, e.gp_mode (0));\n+\treturn e.use_pred_x_insn (code_for_aarch64_pred_cnot (mode));\n+      }\n+\n+    return e.use_cond_insn (code_for_cond_cnot (mode), 0);\n+  }\n+};\n+\n+/* Implements svcnt[bhwd], which count the number of elements\n+   in a particular vector mode.  */\n+class svcnt_bhwd_impl : public function_base\n+{\n+public:\n+  CONSTEXPR svcnt_bhwd_impl (machine_mode ref_mode) : m_ref_mode (ref_mode) {}\n+\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    tree count = build_int_cstu (TREE_TYPE (f.lhs),\n+\t\t\t\t GET_MODE_NUNITS (m_ref_mode));\n+    return gimple_build_assign (f.lhs, count);\n+  }\n+\n+  rtx\n+  expand (function_expander &) const OVERRIDE\n+  {\n+    return gen_int_mode (GET_MODE_NUNITS (m_ref_mode), DImode);\n+  }\n+\n+  /* The mode of the vector associated with the [bhwd] suffix.  */\n+  machine_mode m_ref_mode;\n+};\n+\n+/* Implements svcnt[bhwd]_pat.  */\n+class svcnt_bhwd_pat_impl : public svcnt_bhwd_impl\n+{\n+public:\n+  CONSTEXPR svcnt_bhwd_pat_impl (machine_mode ref_mode)\n+    : svcnt_bhwd_impl (ref_mode) {}\n+\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    tree pattern_arg = gimple_call_arg (f.call, 0);\n+    aarch64_svpattern pattern = (aarch64_svpattern) tree_to_shwi (pattern_arg);\n+\n+    if (pattern == AARCH64_SV_ALL)\n+      /* svcvnt[bwhd]_pat (SV_ALL) == svcnt[bwhd] ().  */\n+      return svcnt_bhwd_impl::fold (f);\n+\n+    /* See whether we can count the number of elements in the pattern\n+       at compile time.  */\n+    unsigned int elements_per_vq = 128 / GET_MODE_UNIT_BITSIZE (m_ref_mode);\n+    HOST_WIDE_INT value = aarch64_fold_sve_cnt_pat (pattern, elements_per_vq);\n+    if (value >= 0)\n+      {\n+\ttree count = build_int_cstu (TREE_TYPE (f.lhs), value);\n+\treturn gimple_build_assign (f.lhs, count);\n+      }\n+\n+    return NULL;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    unsigned int elements_per_vq = 128 / GET_MODE_UNIT_BITSIZE (m_ref_mode);\n+    e.args.quick_push (gen_int_mode (elements_per_vq, DImode));\n+    e.args.quick_push (const1_rtx);\n+    return e.use_exact_insn (CODE_FOR_aarch64_sve_cnt_pat);\n+  }\n+};\n+\n+class svcntp_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    machine_mode mode = e.vector_mode (0);\n+    e.add_ptrue_hint (0, mode);\n+    return e.use_exact_insn (code_for_aarch64_pred_cntp (mode));\n+  }\n+};\n+\n+class svcompact_impl : public quiet<function_base>\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return e.use_exact_insn (code_for_aarch64_sve_compact (e.vector_mode (0)));\n+  }\n+};\n+\n+/* Implements svcreate2, svcreate3 and svcreate4.  */\n+class svcreate_impl : public quiet<multi_vector_function>\n+{\n+public:\n+  CONSTEXPR svcreate_impl (unsigned int vectors_per_tuple)\n+    : quiet<multi_vector_function> (vectors_per_tuple) {}\n+\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    unsigned int nargs = gimple_call_num_args (f.call);\n+    tree lhs_type = TREE_TYPE (f.lhs);\n+\n+    /* Replace the call with a clobber of the result (to prevent it from\n+       becoming upwards exposed) followed by stores into each individual\n+       vector of tuple.\n+\n+       The fold routines expect the replacement statement to have the\n+       same lhs as the original call, so return the clobber statement\n+       rather than the final vector store.  */\n+    gassign *clobber = gimple_build_assign (f.lhs, build_clobber (lhs_type));\n+\n+    for (unsigned int i = nargs; i-- > 0; )\n+      {\n+\ttree rhs_vector = gimple_call_arg (f.call, i);\n+\ttree field = tuple_type_field (TREE_TYPE (f.lhs));\n+\ttree lhs_array = build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t\t unshare_expr (f.lhs), field, NULL_TREE);\n+\ttree lhs_vector = build4 (ARRAY_REF, TREE_TYPE (rhs_vector),\n+\t\t\t\t  lhs_array, size_int (i),\n+\t\t\t\t  NULL_TREE, NULL_TREE);\n+\tgassign *assign = gimple_build_assign (lhs_vector, rhs_vector);\n+\tgsi_insert_after (f.gsi, assign, GSI_SAME_STMT);\n+      }\n+    return clobber;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    rtx lhs_tuple = e.get_nonoverlapping_reg_target ();\n+\n+    /* Record that LHS_TUPLE is dead before the first store.  */\n+    emit_clobber (lhs_tuple);\n+    for (unsigned int i = 0; i < e.args.length (); ++i)\n+      {\n+\t/* Use an lvalue subreg to refer to vector I in LHS_TUPLE.  */\n+\trtx lhs_vector = simplify_gen_subreg (GET_MODE (e.args[i]),\n+\t\t\t\t\t      lhs_tuple, GET_MODE (lhs_tuple),\n+\t\t\t\t\t      i * BYTES_PER_SVE_VECTOR);\n+\temit_move_insn (lhs_vector, e.args[i]);\n+      }\n+    return lhs_tuple;\n+  }\n+};\n+\n+class svcvt_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    machine_mode mode0 = e.vector_mode (0);\n+    machine_mode mode1 = e.vector_mode (1);\n+    insn_code icode;\n+    /* All this complication comes from the need to select four things\n+       simultaneously:\n+\n+       (1) the kind of conversion (int<-float, float<-int, float<-float)\n+       (2) signed vs. unsigned integers, where relevant\n+       (3) the predication mode, which must be the wider of the predication\n+\t   modes for MODE0 and MODE1\n+       (4) the predication type (m, x or z)\n+\n+       The only supported int<->float conversions for which the integer is\n+       narrower than the float are SI<->DF.  It's therefore more convenient\n+       to handle (3) by defining two patterns for int<->float conversions:\n+       one in which the integer is at least as wide as the float and so\n+       determines the predication mode, and another single SI<->DF pattern\n+       in which the float's mode determines the predication mode (which is\n+       always VNx2BI in that case).\n+\n+       The names of the patterns follow the optab convention of giving\n+       the source mode before the destination mode.  */\n+    if (e.type_suffix (1).integer_p)\n+      {\n+\tint unspec = (e.type_suffix (1).unsigned_p\n+\t\t      ? UNSPEC_COND_UCVTF\n+\t\t      : UNSPEC_COND_SCVTF);\n+\tif (e.type_suffix (0).element_bytes <= e.type_suffix (1).element_bytes)\n+\t  icode = (e.pred == PRED_x\n+\t\t   ? code_for_aarch64_sve_nonextend (unspec, mode1, mode0)\n+\t\t   : code_for_cond_nonextend (unspec, mode1, mode0));\n+\telse\n+\t  icode = (e.pred == PRED_x\n+\t\t   ? code_for_aarch64_sve_extend (unspec, mode1, mode0)\n+\t\t   : code_for_cond_extend (unspec, mode1, mode0));\n+      }\n+    else\n+      {\n+\tint unspec = (!e.type_suffix (0).integer_p ? UNSPEC_COND_FCVT\n+\t\t      : e.type_suffix (0).unsigned_p ? UNSPEC_COND_FCVTZU\n+\t\t      : UNSPEC_COND_FCVTZS);\n+\tif (e.type_suffix (0).element_bytes >= e.type_suffix (1).element_bytes)\n+\t  icode = (e.pred == PRED_x\n+\t\t   ? code_for_aarch64_sve_nontrunc (unspec, mode1, mode0)\n+\t\t   : code_for_cond_nontrunc (unspec, mode1, mode0));\n+\telse\n+\t  icode = (e.pred == PRED_x\n+\t\t   ? code_for_aarch64_sve_trunc (unspec, mode1, mode0)\n+\t\t   : code_for_cond_trunc (unspec, mode1, mode0));\n+      }\n+\n+    if (e.pred == PRED_x)\n+      return e.use_pred_x_insn (icode);\n+    return e.use_cond_insn (icode);\n+  }\n+};\n+\n+class svdot_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* In the optab, the multiplication operands come before the accumulator\n+       operand.  The optab is keyed off the multiplication mode.  */\n+    e.rotate_inputs_left (0, 3);\n+    insn_code icode\n+      = e.direct_optab_handler_for_sign (sdot_prod_optab, udot_prod_optab,\n+\t\t\t\t\t 0, GET_MODE (e.args[0]));\n+    return e.use_unpred_insn (icode);\n+  }\n+};\n+\n+class svdot_lane_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* Use the same ordering as the dot_prod_optab, with the\n+       accumulator last.  */\n+    e.rotate_inputs_left (0, 4);\n+    int unspec = (e.type_suffix (0).unsigned_p ? UNSPEC_UDOT : UNSPEC_SDOT);\n+    machine_mode mode = e.vector_mode (0);\n+    return e.use_exact_insn (code_for_aarch64_dot_prod_lane (unspec, mode));\n+  }\n+};\n+\n+class svdup_impl : public quiet<function_base>\n+{\n+public:\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    tree vec_type = TREE_TYPE (f.lhs);\n+    tree rhs = gimple_call_arg (f.call, f.pred == PRED_none ? 0 : 1);\n+\n+    if (f.pred == PRED_none || f.pred == PRED_x)\n+      {\n+\tif (CONSTANT_CLASS_P (rhs))\n+\t  {\n+\t    if (f.type_suffix (0).bool_p)\n+\t      return (tree_to_shwi (rhs)\n+\t\t      ? f.fold_to_ptrue ()\n+\t\t      : f.fold_to_pfalse ());\n+\n+\t    tree rhs_vector = build_vector_from_val (vec_type, rhs);\n+\t    return gimple_build_assign (f.lhs, rhs_vector);\n+\t  }\n+\n+\t/* Avoid folding _b to a VEC_DUPLICATE_EXPR, since to do that we\n+\t   would need to introduce an extra and unwanted conversion to\n+\t   the truth vector element type.  */\n+\tif (!f.type_suffix (0).bool_p)\n+\t  return gimple_build_assign (f.lhs, VEC_DUPLICATE_EXPR, rhs);\n+      }\n+\n+    return NULL;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    if (e.pred == PRED_none || e.pred == PRED_x)\n+      /* There's no benefit to using predicated instructions for _x here.  */\n+      return e.use_unpred_insn (e.direct_optab_handler (vec_duplicate_optab));\n+\n+    /* Model predicated svdups as a SEL in which the \"true\" value is\n+       the duplicate of the function argument and the \"false\" value\n+       is the value of inactive lanes.  */\n+    insn_code icode;\n+    machine_mode mode = e.vector_mode (0);\n+    if (valid_for_const_vector_p (GET_MODE_INNER (mode), e.args.last ()))\n+      /* Duplicate the constant to fill a vector.  The pattern optimizes\n+\t various cases involving constant operands, falling back to SEL\n+\t if necessary.  */\n+      icode = code_for_vcond_mask (mode, mode);\n+    else\n+      /* Use the pattern for selecting between a duplicated scalar\n+\t variable and a vector fallback.  */\n+      icode = code_for_aarch64_sel_dup (mode);\n+    return e.use_vcond_mask_insn (icode);\n+  }\n+};\n+\n+class svdup_lane_impl : public quiet<function_base>\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* The native DUP lane has an index range of 64 bytes.  */\n+    machine_mode mode = e.vector_mode (0);\n+    if (CONST_INT_P (e.args[1])\n+\t&& IN_RANGE (INTVAL (e.args[1]) * GET_MODE_UNIT_SIZE (mode), 0, 63))\n+      return e.use_exact_insn (code_for_aarch64_sve_dup_lane (mode));\n+\n+    /* Treat svdup_lane as if it were svtbl_n.  */\n+    return e.use_exact_insn (code_for_aarch64_sve_tbl (e.vector_mode (0)));\n+  }\n+};\n+\n+class svdupq_impl : public quiet<function_base>\n+{\n+public:\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    tree vec_type = TREE_TYPE (f.lhs);\n+    unsigned int nargs = gimple_call_num_args (f.call);\n+    /* For predicates, pad out each argument so that we have one element\n+       per bit.  */\n+    unsigned int factor = (f.type_suffix (0).bool_p\n+\t\t\t   ? f.type_suffix (0).element_bytes : 1);\n+    tree_vector_builder builder (vec_type, nargs * factor, 1);\n+    for (unsigned int i = 0; i < nargs; ++i)\n+      {\n+\ttree elt = gimple_call_arg (f.call, i);\n+\tif (!CONSTANT_CLASS_P (elt))\n+\t  return NULL;\n+\tbuilder.quick_push (elt);\n+\tfor (unsigned int j = 1; j < factor; ++j)\n+\t  builder.quick_push (build_zero_cst (TREE_TYPE (vec_type)));\n+      }\n+    return gimple_build_assign (f.lhs, builder.build ());\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    machine_mode mode = e.vector_mode (0);\n+    unsigned int elements_per_vq = e.args.length ();\n+    if (GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL)\n+      {\n+\t/* Construct a vector of integers so that we can compare them against\n+\t   zero below.  Zero vs. nonzero is the only distinction that\n+\t   matters.  */\n+\tmode = aarch64_sve_int_mode (mode);\n+\tfor (unsigned int i = 0; i < elements_per_vq; ++i)\n+\t  e.args[i] = simplify_gen_unary (ZERO_EXTEND, GET_MODE_INNER (mode),\n+\t\t\t\t\t  e.args[i], QImode);\n+      }\n+\n+    /* Get the 128-bit Advanced SIMD vector for this data size.  */\n+    scalar_mode element_mode = GET_MODE_INNER (mode);\n+    machine_mode vq_mode = aarch64_vq_mode (element_mode).require ();\n+    gcc_assert (known_eq (elements_per_vq, GET_MODE_NUNITS (vq_mode)));\n+\n+    /* Put the arguments into a 128-bit Advanced SIMD vector.  We want\n+       argument N to go into architectural lane N, whereas Advanced SIMD\n+       vectors are loaded memory lsb to register lsb.  We therefore need\n+       to reverse the elements for big-endian targets.  */\n+    rtx vq_reg = gen_reg_rtx (vq_mode);\n+    rtvec vec = rtvec_alloc (elements_per_vq);\n+    for (unsigned int i = 0; i < elements_per_vq; ++i)\n+      {\n+\tunsigned int argno = BYTES_BIG_ENDIAN ? elements_per_vq - i - 1 : i;\n+\tRTVEC_ELT (vec, i) = e.args[argno];\n+      }\n+    aarch64_expand_vector_init (vq_reg, gen_rtx_PARALLEL (vq_mode, vec));\n+\n+    /* If the result is a boolean, compare the data vector against zero.  */\n+    if (mode != e.vector_mode (0))\n+      {\n+\trtx data_dupq = aarch64_expand_sve_dupq (NULL, mode, vq_reg);\n+\treturn aarch64_convert_sve_data_to_pred (e.possible_target,\n+\t\t\t\t\t\t e.vector_mode (0), data_dupq);\n+      }\n+\n+    return aarch64_expand_sve_dupq (e.possible_target, mode, vq_reg);\n+  }\n+};\n+\n+class svdupq_lane_impl : public quiet<function_base>\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    machine_mode mode = e.vector_mode (0);\n+    rtx index = e.args[1];\n+    if (CONST_INT_P (index) && IN_RANGE (INTVAL (index), 0, 3))\n+      {\n+\t/* Use the .Q form of DUP, which is the native instruction for\n+\t   this function.  */\n+\tinsn_code icode = code_for_aarch64_sve_dupq_lane (mode);\n+\tunsigned int num_indices = e.elements_per_vq (0);\n+\trtx indices = aarch64_gen_stepped_int_parallel\n+\t  (num_indices, INTVAL (index) * num_indices, 1);\n+\n+\te.add_output_operand (icode);\n+\te.add_input_operand (icode, e.args[0]);\n+\te.add_fixed_operand (indices);\n+\treturn e.generate_insn (icode);\n+      }\n+\n+    /* Build a .D TBL index for the pairs of doublewords that we want to\n+       duplicate.  */\n+    if (CONST_INT_P (index))\n+      {\n+\t/* The index vector is a constant.  */\n+\trtx_vector_builder builder (VNx2DImode, 2, 1);\n+\tbuilder.quick_push (gen_int_mode (INTVAL (index) * 2, DImode));\n+\tbuilder.quick_push (gen_int_mode (INTVAL (index) * 2 + 1, DImode));\n+\tindex = builder.build ();\n+      }\n+    else\n+      {\n+\t/* Duplicate INDEX * 2 to fill a DImode vector.  The ACLE spec\n+\t   explicitly allows the top of the index to be dropped.  */\n+\tindex = force_reg (DImode, simplify_gen_binary (ASHIFT, DImode,\n+\t\t\t\t\t\t\tindex, const1_rtx));\n+\tindex = expand_vector_broadcast (VNx2DImode, index);\n+\n+\t/* Get an alternating 0, 1 predicate.  */\n+\trtx_vector_builder builder (VNx2BImode, 2, 1);\n+\tbuilder.quick_push (const0_rtx);\n+\tbuilder.quick_push (constm1_rtx);\n+\trtx pg = force_reg (VNx2BImode, builder.build ());\n+\n+\t/* Add one to the odd elements of the index.  */\n+\trtx one = force_reg (VNx2DImode, CONST1_RTX (VNx2DImode));\n+\trtx target = gen_reg_rtx (VNx2DImode);\n+\temit_insn (gen_cond_addvnx2di (target, pg, index, one, index));\n+\tindex = target;\n+      }\n+\n+    e.args[0] = gen_lowpart (VNx2DImode, e.args[0]);\n+    e.args[1] = index;\n+    return e.use_exact_insn (CODE_FOR_aarch64_sve_tblvnx2di);\n+  }\n+};\n+\n+class svext_impl : public quiet<function_base>\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return e.use_exact_insn (code_for_aarch64_sve_ext (e.vector_mode (0)));\n+  }\n+};\n+\n+/* Implements svextb, svexth and svextw.  */\n+class svext_bhw_impl : public function_base\n+{\n+public:\n+  CONSTEXPR svext_bhw_impl (scalar_int_mode from_mode)\n+    : m_from_mode (from_mode) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    if (e.type_suffix (0).unsigned_p)\n+      {\n+\t/* Convert to an AND.  The widest we go is 0xffffffff, which fits\n+\t   in a CONST_INT.  */\n+\te.args.quick_push (GEN_INT (GET_MODE_MASK (m_from_mode)));\n+\tif (e.pred == PRED_m)\n+\t  /* We now have arguments \"(inactive, pg, op, mask)\".  Convert this\n+\t     to \"(pg, op, mask, inactive)\" so that the order matches svand_m\n+\t     with an extra argument on the end.  Take the inactive elements\n+\t     from this extra argument.  */\n+\t  e.rotate_inputs_left (0, 4);\n+\treturn e.map_to_rtx_codes (AND, AND, -1, 3);\n+      }\n+\n+    machine_mode wide_mode = e.vector_mode (0);\n+    poly_uint64 nunits = GET_MODE_NUNITS (wide_mode);\n+    machine_mode narrow_mode\n+      = aarch64_sve_data_mode (m_from_mode, nunits).require ();\n+    if (e.pred == PRED_x)\n+      {\n+\tinsn_code icode = code_for_aarch64_pred_sxt (wide_mode, narrow_mode);\n+\treturn e.use_pred_x_insn (icode);\n+      }\n+\n+    insn_code icode = code_for_aarch64_cond_sxt (wide_mode, narrow_mode);\n+    return e.use_cond_insn (icode);\n+  }\n+\n+  /* The element mode that we're extending from.  */\n+  scalar_int_mode m_from_mode;\n+};\n+\n+/* Implements svget2, svget3 and svget4.  */\n+class svget_impl : public quiet<multi_vector_function>\n+{\n+public:\n+  CONSTEXPR svget_impl (unsigned int vectors_per_tuple)\n+    : quiet<multi_vector_function> (vectors_per_tuple) {}\n+\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    /* Fold into a normal gimple component access.  */\n+    tree rhs_tuple = gimple_call_arg (f.call, 0);\n+    tree index = gimple_call_arg (f.call, 1);\n+    tree field = tuple_type_field (TREE_TYPE (rhs_tuple));\n+    tree rhs_array = build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t     rhs_tuple, field, NULL_TREE);\n+    tree rhs_vector = build4 (ARRAY_REF, TREE_TYPE (f.lhs),\n+\t\t\t      rhs_array, index, NULL_TREE, NULL_TREE);\n+    return gimple_build_assign (f.lhs, rhs_vector);\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* Fold the access into a subreg rvalue.  */\n+    return simplify_gen_subreg (e.vector_mode (0), e.args[0],\n+\t\t\t\tGET_MODE (e.args[0]),\n+\t\t\t\tINTVAL (e.args[1]) * BYTES_PER_SVE_VECTOR);\n+  }\n+};\n+\n+class svindex_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return e.use_exact_insn (e.direct_optab_handler (vec_series_optab));\n+  }\n+};\n+\n+class svinsr_impl : public quiet<function_base>\n+{\n+public:\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    gcall *new_call = gimple_build_call_internal (IFN_VEC_SHL_INSERT, 2,\n+\t\t\t\t\t\t  gimple_call_arg (f.call, 0),\n+\t\t\t\t\t\t  gimple_call_arg (f.call, 1));\n+    gimple_call_set_lhs (new_call, f.lhs);\n+    return new_call;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    insn_code icode = direct_optab_handler (vec_shl_insert_optab,\n+\t\t\t\t\t    e.vector_mode (0));\n+    return e.use_exact_insn (icode);\n+  }\n+};\n+\n+/* Implements svlasta and svlastb.  */\n+class svlast_impl : public quiet<function_base>\n+{\n+public:\n+  CONSTEXPR svlast_impl (int unspec) : m_unspec (unspec) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return e.use_exact_insn (code_for_extract (m_unspec, e.vector_mode (0)));\n+  }\n+\n+  /* The unspec code associated with the operation.  */\n+  int m_unspec;\n+};\n+\n+class svld1_impl : public full_width_access\n+{\n+public:\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return CP_READ_MEMORY;\n+  }\n+\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    tree vectype = f.vector_type (0);\n+\n+    /* Get the predicate and base pointer.  */\n+    gimple_seq stmts = NULL;\n+    tree pred = f.convert_pred (stmts, vectype, 0);\n+    tree base = f.fold_contiguous_base (stmts, vectype);\n+    gsi_insert_seq_before (f.gsi, stmts, GSI_SAME_STMT);\n+\n+    tree cookie = f.load_store_cookie (TREE_TYPE (vectype));\n+    gcall *new_call = gimple_build_call_internal (IFN_MASK_LOAD, 3,\n+\t\t\t\t\t\t  base, cookie, pred);\n+    gimple_call_set_lhs (new_call, f.lhs);\n+    return new_call;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    insn_code icode = convert_optab_handler (maskload_optab,\n+\t\t\t\t\t     e.vector_mode (0), e.gp_mode (0));\n+    return e.use_contiguous_load_insn (icode);\n+  }\n+};\n+\n+/* Implements extending contiguous forms of svld1.  */\n+class svld1_extend_impl : public extending_load\n+{\n+public:\n+  CONSTEXPR svld1_extend_impl (type_suffix_index memory_type)\n+    : extending_load (memory_type) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    insn_code icode = code_for_aarch64_load (extend_rtx_code (),\n+\t\t\t\t\t     e.vector_mode (0),\n+\t\t\t\t\t     e.memory_vector_mode ());\n+    return e.use_contiguous_load_insn (icode);\n+  }\n+};\n+\n+class svld1_gather_impl : public full_width_access\n+{\n+public:\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return CP_READ_MEMORY;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    e.prepare_gather_address_operands (1);\n+    /* Put the predicate last, as required by mask_gather_load_optab.  */\n+    e.rotate_inputs_left (0, 5);\n+    machine_mode mem_mode = e.memory_vector_mode ();\n+    insn_code icode = direct_optab_handler (mask_gather_load_optab, mem_mode);\n+    return e.use_exact_insn (icode);\n+  }\n+};\n+\n+/* Implements extending forms of svld1_gather.  */\n+class svld1_gather_extend_impl : public extending_load\n+{\n+public:\n+  CONSTEXPR svld1_gather_extend_impl (type_suffix_index memory_type)\n+    : extending_load (memory_type) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    e.prepare_gather_address_operands (1);\n+    /* Put the predicate last, since the extending gathers use the same\n+       operand order as mask_gather_load_optab.  */\n+    e.rotate_inputs_left (0, 5);\n+    insn_code icode = code_for_aarch64_gather_load (extend_rtx_code (),\n+\t\t\t\t\t\t    e.vector_mode (0),\n+\t\t\t\t\t\t    e.memory_vector_mode ());\n+    return e.use_exact_insn (icode);\n+  }\n+};\n+\n+class svld1rq_impl : public function_base\n+{\n+public:\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return CP_READ_MEMORY;\n+  }\n+\n+  tree\n+  memory_scalar_type (const function_instance &fi) const OVERRIDE\n+  {\n+    return fi.scalar_type (0);\n+  }\n+\n+  machine_mode\n+  memory_vector_mode (const function_instance &fi) const OVERRIDE\n+  {\n+    return aarch64_vq_mode (GET_MODE_INNER (fi.vector_mode (0))).require ();\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    insn_code icode = code_for_aarch64_sve_ld1rq (e.vector_mode (0));\n+    return e.use_contiguous_load_insn (icode);\n+  }\n+};\n+\n+/* Implements svld2, svld3 and svld4.  */\n+class svld234_impl : public full_width_access\n+{\n+public:\n+  CONSTEXPR svld234_impl (unsigned int vectors_per_tuple)\n+    : full_width_access (vectors_per_tuple) {}\n+\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return CP_READ_MEMORY;\n+  }\n+\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    tree tuple_type = TREE_TYPE (f.lhs);\n+    tree vectype = f.vector_type (0);\n+\n+    /* Get the predicate and base pointer.  */\n+    gimple_seq stmts = NULL;\n+    tree pred = f.convert_pred (stmts, vectype, 0);\n+    tree base = f.fold_contiguous_base (stmts, vectype);\n+    gsi_insert_seq_before (f.gsi, stmts, GSI_SAME_STMT);\n+\n+    /* Emit two statements: a clobber of the lhs, so that it isn't\n+       upwards exposed, and then the load itself.\n+\n+       The fold routines expect the replacement statement to have the\n+       same lhs as the original call, so return the clobber statement\n+       rather than the load.  */\n+    gimple *clobber = gimple_build_assign (f.lhs, build_clobber (tuple_type));\n+\n+    /* View the loaded data as an array of vectors.  */\n+    tree field = tuple_type_field (tuple_type);\n+    tree lhs_array = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (field),\n+\t\t\t     unshare_expr (f.lhs));\n+\n+    /* Emit the load itself.  */\n+    tree cookie = f.load_store_cookie (TREE_TYPE (vectype));\n+    gcall *new_call = gimple_build_call_internal (IFN_MASK_LOAD_LANES, 3,\n+\t\t\t\t\t\t  base, cookie, pred);\n+    gimple_call_set_lhs (new_call, lhs_array);\n+    gsi_insert_after (f.gsi, new_call, GSI_SAME_STMT);\n+\n+    return clobber;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    machine_mode tuple_mode = TYPE_MODE (TREE_TYPE (e.call_expr));\n+    insn_code icode = convert_optab_handler (vec_mask_load_lanes_optab,\n+\t\t\t\t\t     tuple_mode, e.vector_mode (0));\n+    return e.use_contiguous_load_insn (icode);\n+  }\n+};\n+\n+class svldff1_gather_impl : public full_width_access\n+{\n+public:\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return CP_READ_MEMORY | CP_READ_FFR | CP_WRITE_FFR;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* See the block comment in aarch64-sve.md for details about the\n+       FFR handling.  */\n+    emit_insn (gen_aarch64_update_ffr_for_load ());\n+\n+    e.prepare_gather_address_operands (1);\n+    /* Put the predicate last, since ldff1_gather uses the same operand\n+       order as mask_gather_load_optab.  */\n+    e.rotate_inputs_left (0, 5);\n+    machine_mode mem_mode = e.memory_vector_mode ();\n+    return e.use_exact_insn (code_for_aarch64_ldff1_gather (mem_mode));\n+  }\n+};\n+\n+/* Implements extending forms of svldff1_gather.  */\n+class svldff1_gather_extend : public extending_load\n+{\n+public:\n+  CONSTEXPR svldff1_gather_extend (type_suffix_index memory_type)\n+    : extending_load (memory_type) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* See the block comment in aarch64-sve.md for details about the\n+       FFR handling.  */\n+    emit_insn (gen_aarch64_update_ffr_for_load ());\n+\n+    e.prepare_gather_address_operands (1);\n+    /* Put the predicate last, since ldff1_gather uses the same operand\n+       order as mask_gather_load_optab.  */\n+    e.rotate_inputs_left (0, 5);\n+    insn_code icode = code_for_aarch64_ldff1_gather (extend_rtx_code (),\n+\t\t\t\t\t\t     e.vector_mode (0),\n+\t\t\t\t\t\t     e.memory_vector_mode ());\n+    return e.use_exact_insn (icode);\n+  }\n+};\n+\n+class svldnt1_impl : public full_width_access\n+{\n+public:\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return CP_READ_MEMORY;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    insn_code icode = code_for_aarch64_ldnt1 (e.vector_mode (0));\n+    return e.use_contiguous_load_insn (icode);\n+  }\n+};\n+\n+/* Implements svldff1 and svldnf1.  */\n+class svldxf1_impl : public full_width_access\n+{\n+public:\n+  CONSTEXPR svldxf1_impl (int unspec) : m_unspec (unspec) {}\n+\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return CP_READ_MEMORY | CP_READ_FFR | CP_WRITE_FFR;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* See the block comment in aarch64-sve.md for details about the\n+       FFR handling.  */\n+    emit_insn (gen_aarch64_update_ffr_for_load ());\n+\n+    machine_mode mode = e.vector_mode (0);\n+    return e.use_contiguous_load_insn (code_for_aarch64_ldf1 (m_unspec, mode));\n+  }\n+\n+  /* The unspec associated with the load.  */\n+  int m_unspec;\n+};\n+\n+/* Implements extending contiguous forms of svldff1 and svldnf1.  */\n+class svldxf1_extend_impl : public extending_load\n+{\n+public:\n+  CONSTEXPR svldxf1_extend_impl (type_suffix_index memory_type, int unspec)\n+    : extending_load (memory_type), m_unspec (unspec) {}\n+\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return CP_READ_MEMORY | CP_READ_FFR | CP_WRITE_FFR;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* See the block comment in aarch64-sve.md for details about the\n+       FFR handling.  */\n+    emit_insn (gen_aarch64_update_ffr_for_load ());\n+\n+    insn_code icode = code_for_aarch64_ldf1 (m_unspec, extend_rtx_code (),\n+\t\t\t\t\t     e.vector_mode (0),\n+\t\t\t\t\t     e.memory_vector_mode ());\n+    return e.use_contiguous_load_insn (icode);\n+  }\n+\n+  /* The unspec associated with the load.  */\n+  int m_unspec;\n+};\n+\n+class svlen_impl : public quiet<function_base>\n+{\n+public:\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    /* The argument only exists for its type.  */\n+    tree rhs_type = TREE_TYPE (gimple_call_arg (f.call, 0));\n+    tree count = build_int_cstu (TREE_TYPE (f.lhs),\n+\t\t\t\t TYPE_VECTOR_SUBPARTS (rhs_type));\n+    return gimple_build_assign (f.lhs, count);\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* The argument only exists for its type.  */\n+    return gen_int_mode (GET_MODE_NUNITS (e.vector_mode (0)), DImode);\n+  }\n+};\n+\n+class svmad_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return expand_mad (e);\n+  }\n+};\n+\n+class svmla_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* Put the accumulator at the end (argument 3), but keep it as the\n+       merge input for _m functions.  */\n+    e.rotate_inputs_left (1, 4);\n+    return expand_mad (e, 3);\n+  }\n+};\n+\n+/* Base class for svmla_lane and svmls_lane.  */\n+class svmla_svmls_lane_impl : public function_base\n+{\n+public:\n+  CONSTEXPR svmla_svmls_lane_impl (int unspec)\n+    : m_unspec (unspec) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* Put the operands in the normal (fma ...) order, with the accumulator\n+       last.  This fits naturally since that's also the unprinted operand\n+       in the asm output.  */\n+    e.rotate_inputs_left (0, 4);\n+    insn_code icode = code_for_aarch64_lane (m_unspec, e.vector_mode (0));\n+    return e.use_exact_insn (icode);\n+  }\n+\n+  /* The unspec code associated with the operation.  */\n+  int m_unspec;\n+};\n+\n+class svmls_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* Put the accumulator at the end (argument 3), but keep it as the\n+       merge input for _m functions.  */\n+    e.rotate_inputs_left (1, 4);\n+    return expand_msb (e, 3);\n+  }\n+};\n+\n+class svmov_impl : public function_base\n+{\n+public:\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    return gimple_build_assign (f.lhs, BIT_AND_EXPR,\n+\t\t\t\tgimple_call_arg (f.call, 0),\n+\t\t\t\tgimple_call_arg (f.call, 1));\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* The canonical form for the assembler alias \"MOV Pa.B, Pb/Z, Pc.B\"\n+       is \"AND Pa.B, Pb/Z, Pc.B, Pc.B\".  */\n+    gcc_assert (e.pred == PRED_z);\n+    e.args.quick_push (e.args[1]);\n+    return e.use_exact_insn (CODE_FOR_aarch64_pred_andvnx16bi_z);\n+  }\n+};\n+\n+class svmsb_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return expand_msb (e);\n+  }\n+};\n+\n+class svmul_lane_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return e.use_exact_insn (code_for_aarch64_mul_lane (e.vector_mode (0)));\n+  }\n+};\n+\n+class svnand_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    gcc_assert (e.pred == PRED_z);\n+    return e.use_exact_insn (CODE_FOR_aarch64_pred_nandvnx16bi_z);\n+  }\n+};\n+\n+class svnor_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    gcc_assert (e.pred == PRED_z);\n+    return e.use_exact_insn (CODE_FOR_aarch64_pred_norvnx16bi_z);\n+  }\n+};\n+\n+class svnot_impl : public rtx_code_function\n+{\n+public:\n+  CONSTEXPR svnot_impl () : rtx_code_function (NOT, NOT, -1) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    if (e.type_suffix_ids[0] == TYPE_SUFFIX_b)\n+      {\n+\t/* The canonical form for the assembler alias \"NOT Pa.B, Pb/Z, Pc.B\"\n+\t   is \"EOR Pa.B, Pb/Z, Pb.B, Pc.B\".  */\n+\tgcc_assert (e.pred == PRED_z);\n+\te.args.quick_insert (1, e.args[0]);\n+\treturn e.use_exact_insn (CODE_FOR_aarch64_pred_xorvnx16bi_z);\n+      }\n+    return rtx_code_function::expand (e);\n+  }\n+};\n+\n+class svorn_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    gcc_assert (e.pred == PRED_z);\n+    return e.use_exact_insn (CODE_FOR_aarch64_pred_ornvnx16bi_z);\n+  }\n+};\n+\n+class svpfalse_impl : public function_base\n+{\n+public:\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    return f.fold_to_pfalse ();\n+  }\n+\n+  rtx\n+  expand (function_expander &) const OVERRIDE\n+  {\n+    return CONST0_RTX (VNx16BImode);\n+  }\n+};\n+\n+/* Implements svpfirst and svpnext, which share the same .md patterns.  */\n+class svpfirst_svpnext_impl : public function_base\n+{\n+public:\n+  CONSTEXPR svpfirst_svpnext_impl (int unspec) : m_unspec (unspec) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    machine_mode mode = e.vector_mode (0);\n+    e.add_ptrue_hint (0, mode);\n+    return e.use_exact_insn (code_for_aarch64_sve (m_unspec, mode));\n+  }\n+\n+  /* The unspec associated with the operation.  */\n+  int m_unspec;\n+};\n+\n+/* Implements contiguous forms of svprf[bhwd].  */\n+class svprf_bhwd_impl : public function_base\n+{\n+public:\n+  CONSTEXPR svprf_bhwd_impl (machine_mode mode) : m_mode (mode) {}\n+\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return CP_PREFETCH_MEMORY;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    e.prepare_prefetch_operands ();\n+    insn_code icode = code_for_aarch64_sve_prefetch (m_mode);\n+    return e.use_contiguous_prefetch_insn (icode);\n+  }\n+\n+  /* The mode that we'd use to hold one vector of prefetched data.  */\n+  machine_mode m_mode;\n+};\n+\n+/* Implements svprf[bhwd]_gather.  */\n+class svprf_bhwd_gather_impl : public function_base\n+{\n+public:\n+  CONSTEXPR svprf_bhwd_gather_impl (machine_mode mode) : m_mode (mode) {}\n+\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return CP_PREFETCH_MEMORY;\n+  }\n+\n+  machine_mode\n+  memory_vector_mode (const function_instance &) const OVERRIDE\n+  {\n+    return m_mode;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    e.prepare_prefetch_operands ();\n+    e.prepare_gather_address_operands (1);\n+\n+    /* Insert a zero operand to identify the mode of the memory being\n+       accessed.  This goes between the gather operands and prefetch\n+       operands created above.  */\n+    e.args.quick_insert (5, CONST0_RTX (m_mode));\n+\n+    machine_mode reg_mode = GET_MODE (e.args[2]);\n+    insn_code icode = code_for_aarch64_sve_gather_prefetch (m_mode, reg_mode);\n+    return e.use_exact_insn (icode);\n+  }\n+\n+  /* The mode that we'd use to hold one vector of prefetched data.  */\n+  machine_mode m_mode;\n+};\n+\n+/* Implements svptest_any, svptest_first and svptest_last.  */\n+class svptest_impl : public function_base\n+{\n+public:\n+  CONSTEXPR svptest_impl (rtx_code compare) : m_compare (compare) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* See whether GP is an exact ptrue for some predicate mode;\n+       i.e. whether converting the GP to that mode will not drop\n+       set bits and will leave all significant bits set.  */\n+    machine_mode wide_mode;\n+    int hint;\n+    if (aarch64_ptrue_all_mode (e.args[0]).exists (&wide_mode))\n+      hint = SVE_KNOWN_PTRUE;\n+    else\n+      {\n+\thint = SVE_MAYBE_NOT_PTRUE;\n+\twide_mode = VNx16BImode;\n+      }\n+\n+    /* Generate the PTEST itself.  */\n+    rtx pg = force_reg (VNx16BImode, e.args[0]);\n+    rtx wide_pg = gen_lowpart (wide_mode, pg);\n+    rtx hint_rtx = gen_int_mode (hint, DImode);\n+    rtx op = force_reg (wide_mode, gen_lowpart (wide_mode, e.args[1]));\n+    emit_insn (gen_aarch64_ptestvnx16bi (pg, wide_pg, hint_rtx, op));\n+\n+    /* Get the location of the boolean result.  We can provide SImode and\n+       DImode values directly; rely on generic code to convert others.  */\n+    rtx target = e.possible_target;\n+    if (!target\n+\t|| !REG_P (target)\n+\t|| (GET_MODE (target) != SImode && GET_MODE (target) != DImode))\n+      target = gen_reg_rtx (DImode);\n+\n+    /* Generate a CSET to convert the CC result of the PTEST to a boolean.  */\n+    rtx cc_reg = gen_rtx_REG (CC_NZCmode, CC_REGNUM);\n+    rtx compare = gen_rtx_fmt_ee (m_compare, GET_MODE (target),\n+\t\t\t\t  cc_reg, const0_rtx);\n+    emit_insn (gen_rtx_SET (target, compare));\n+    return target;\n+  }\n+\n+  /* The comparison code associated with ptest condition.  */\n+  rtx_code m_compare;\n+};\n+\n+class svptrue_impl : public function_base\n+{\n+public:\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    return f.fold_to_ptrue ();\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return aarch64_ptrue_all (e.type_suffix (0).element_bytes);\n+  }\n+};\n+\n+class svptrue_pat_impl : public function_base\n+{\n+public:\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    tree pattern_arg = gimple_call_arg (f.call, 0);\n+    aarch64_svpattern pattern = (aarch64_svpattern) tree_to_shwi (pattern_arg);\n+\n+    if (pattern == AARCH64_SV_ALL)\n+      /* svptrue_pat_bN (SV_ALL) == svptrue_bN ().  */\n+      return f.fold_to_ptrue ();\n+\n+    /* See whether we can count the number of elements in the pattern\n+       at compile time.  If so, construct a predicate with that number\n+       of 1s followed by all 0s.  */\n+    int nelts_per_vq = f.elements_per_vq (0);\n+    HOST_WIDE_INT value = aarch64_fold_sve_cnt_pat (pattern, nelts_per_vq);\n+    if (value >= 0)\n+      return f.fold_to_vl_pred (value);\n+\n+    return NULL;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* In rtl, the predicate is represented as the constant:\n+\n+         (const:V16BI (unspec:V16BI [(const_int PATTERN)\n+\t\t\t\t     (const_vector:VnnBI [zeros])]\n+\t\t\t\t    UNSPEC_PTRUE))\n+\n+       where nn determines the element size.  */\n+    rtvec vec = gen_rtvec (2, e.args[0], CONST0_RTX (e.vector_mode (0)));\n+    return gen_rtx_CONST (VNx16BImode,\n+\t\t\t  gen_rtx_UNSPEC (VNx16BImode, vec, UNSPEC_PTRUE));\n+  }\n+};\n+\n+class svqadd_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return e.expand_signed_unpred_op (SS_PLUS, US_PLUS);\n+  }\n+};\n+\n+/* Implements svqdec[bhwd]{,_pat} and svqinc[bhwd]{,_pat}.  */\n+class svqdec_svqinc_bhwd_impl : public function_base\n+{\n+public:\n+  CONSTEXPR svqdec_svqinc_bhwd_impl (rtx_code code_for_sint,\n+\t\t\t\t     rtx_code code_for_uint,\n+\t\t\t\t     scalar_int_mode elem_mode)\n+    : m_code_for_sint (code_for_sint),\n+      m_code_for_uint (code_for_uint),\n+      m_elem_mode (elem_mode)\n+  {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* Treat non-_pat functions in the same way as _pat functions with\n+       an SV_ALL argument.  */\n+    if (e.args.length () == 2)\n+      e.args.quick_insert (1, gen_int_mode (AARCH64_SV_ALL, DImode));\n+\n+    /* Insert the number of elements per 128-bit block as a fake argument,\n+       between the pattern and the multiplier.  Arguments 1, 2 and 3 then\n+       correspond exactly with the 3 UNSPEC_SVE_CNT_PAT operands; see\n+       aarch64_sve_cnt_pat for details.  */\n+    unsigned int elements_per_vq = 128 / GET_MODE_BITSIZE (m_elem_mode);\n+    e.args.quick_insert (2, gen_int_mode (elements_per_vq, DImode));\n+\n+    rtx_code code = (e.type_suffix (0).unsigned_p\n+\t\t     ? m_code_for_uint\n+\t\t     : m_code_for_sint);\n+\n+    /* Choose between operating on integer scalars or integer vectors.  */\n+    machine_mode mode = e.vector_mode (0);\n+    if (e.mode_suffix_id == MODE_n)\n+      mode = GET_MODE_INNER (mode);\n+    return e.use_exact_insn (code_for_aarch64_sve_pat (code, mode));\n+  }\n+\n+  /* The saturating addition or subtraction codes to use for signed and\n+     unsigned values respectively.  */\n+  rtx_code m_code_for_sint;\n+  rtx_code m_code_for_uint;\n+\n+  /* The integer mode associated with the [bhwd] suffix.  */\n+  scalar_int_mode m_elem_mode;\n+};\n+\n+/* Implements svqdec[bhwd]{,_pat}.  */\n+class svqdec_bhwd_impl : public svqdec_svqinc_bhwd_impl\n+{\n+public:\n+  CONSTEXPR svqdec_bhwd_impl (scalar_int_mode elem_mode)\n+    : svqdec_svqinc_bhwd_impl (SS_MINUS, US_MINUS, elem_mode) {}\n+};\n+\n+/* Implements svqinc[bhwd]{,_pat}.  */\n+class svqinc_bhwd_impl : public svqdec_svqinc_bhwd_impl\n+{\n+public:\n+  CONSTEXPR svqinc_bhwd_impl (scalar_int_mode elem_mode)\n+    : svqdec_svqinc_bhwd_impl (SS_PLUS, US_PLUS, elem_mode) {}\n+};\n+\n+/* Implements svqdecp and svqincp.  */\n+class svqdecp_svqincp_impl : public function_base\n+{\n+public:\n+  CONSTEXPR svqdecp_svqincp_impl (rtx_code code_for_sint,\n+\t\t\t\t  rtx_code code_for_uint)\n+    : m_code_for_sint (code_for_sint),\n+      m_code_for_uint (code_for_uint)\n+  {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    rtx_code code = (e.type_suffix (0).unsigned_p\n+\t\t     ? m_code_for_uint\n+\t\t     : m_code_for_sint);\n+    insn_code icode;\n+    if (e.mode_suffix_id == MODE_n)\n+      {\n+\t/* Increment or decrement a scalar (whose mode is given by the first\n+\t   type suffix) by the number of active elements in a predicate\n+\t   (whose mode is given by the second type suffix).  */\n+\tmachine_mode mode = GET_MODE_INNER (e.vector_mode (0));\n+\ticode = code_for_aarch64_sve_cntp (code, mode, e.vector_mode (1));\n+      }\n+    else\n+      /* Increment a vector by the number of active elements in a predicate,\n+\t with the vector mode determining the predicate mode.  */\n+      icode = code_for_aarch64_sve_cntp (code, e.vector_mode (0));\n+    return e.use_exact_insn (icode);\n+  }\n+\n+  /* The saturating addition or subtraction codes to use for signed and\n+     unsigned values respectively.  */\n+  rtx_code m_code_for_sint;\n+  rtx_code m_code_for_uint;\n+};\n+\n+class svqsub_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return e.expand_signed_unpred_op (SS_MINUS, US_MINUS);\n+  }\n+};\n+\n+class svrdffr_impl : public function_base\n+{\n+public:\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return CP_READ_FFR;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* See the block comment in aarch64-sve.md for details about the\n+       FFR handling.  */\n+    emit_insn (gen_aarch64_copy_ffr_to_ffrt ());\n+    rtx result = e.use_exact_insn (e.pred == PRED_z\n+\t\t\t\t   ? CODE_FOR_aarch64_rdffr_z\n+\t\t\t\t   : CODE_FOR_aarch64_rdffr);\n+    emit_insn (gen_aarch64_update_ffrt ());\n+    return result;\n+  }\n+};\n+\n+class svreinterpret_impl : public quiet<function_base>\n+{\n+public:\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    /* Punt to rtl if the effect of the reinterpret on registers does not\n+       conform to GCC's endianness model.  */\n+    if (!targetm.can_change_mode_class (f.vector_mode (0),\n+\t\t\t\t\tf.vector_mode (1), FP_REGS))\n+      return NULL;\n+\n+    /* Otherwise svreinterpret corresponds directly to a VIEW_CONVERT_EXPR\n+       reinterpretation.  */\n+    tree rhs = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (f.lhs),\n+\t\t       gimple_call_arg (f.call, 0));\n+    return gimple_build_assign (f.lhs, VIEW_CONVERT_EXPR, rhs);\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    machine_mode mode = e.vector_mode (0);\n+    return e.use_exact_insn (code_for_aarch64_sve_reinterpret (mode));\n+  }\n+};\n+\n+class svrev_impl : public permute\n+{\n+public:\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    /* Punt for now on _b16 and wider; we'd need more complex evpc logic\n+       to rerecognize the result.  */\n+    if (f.type_suffix (0).bool_p && f.type_suffix (0).element_bits > 8)\n+      return NULL;\n+\n+    /* Permute as { nelts - 1, nelts - 2, nelts - 3, ... }.  */\n+    poly_int64 nelts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (f.lhs));\n+    vec_perm_builder builder (nelts, 1, 3);\n+    for (int i = 0; i < 3; ++i)\n+      builder.quick_push (nelts - i - 1);\n+    return fold_permute (f, builder);\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return e.use_exact_insn (code_for_aarch64_sve_rev (e.vector_mode (0)));\n+  }\n+};\n+\n+class svsel_impl : public quiet<function_base>\n+{\n+public:\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    /* svsel corresponds exactly to VEC_COND_EXPR.  */\n+    gimple_seq stmts = NULL;\n+    tree pred = f.convert_pred (stmts, f.vector_type (0), 0);\n+    gsi_insert_seq_before (f.gsi, stmts, GSI_SAME_STMT);\n+    return gimple_build_assign (f.lhs, VEC_COND_EXPR, pred,\n+\t\t\t\tgimple_call_arg (f.call, 1),\n+\t\t\t\tgimple_call_arg (f.call, 2));\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* svsel (cond, truev, falsev) is vcond_mask (truev, falsev, cond).  */\n+    e.rotate_inputs_left (0, 3);\n+    insn_code icode = convert_optab_handler (vcond_mask_optab,\n+\t\t\t\t\t     e.vector_mode (0),\n+\t\t\t\t\t     e.gp_mode (0));\n+    return e.use_exact_insn (icode);\n+  }\n+};\n+\n+/* Implements svset2, svset3 and svset4.  */\n+class svset_impl : public quiet<multi_vector_function>\n+{\n+public:\n+  CONSTEXPR svset_impl (unsigned int vectors_per_tuple)\n+    : quiet<multi_vector_function> (vectors_per_tuple) {}\n+\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    tree rhs_tuple = gimple_call_arg (f.call, 0);\n+    tree index = gimple_call_arg (f.call, 1);\n+    tree rhs_vector = gimple_call_arg (f.call, 2);\n+\n+    /* Replace the call with two statements: a copy of the full tuple\n+       to the call result, followed by an update of the individual vector.\n+\n+       The fold routines expect the replacement statement to have the\n+       same lhs as the original call, so return the copy statement\n+       rather than the field update.  */\n+    gassign *copy = gimple_build_assign (unshare_expr (f.lhs), rhs_tuple);\n+\n+    /* Get a reference to the individual vector.  */\n+    tree field = tuple_type_field (TREE_TYPE (f.lhs));\n+    tree lhs_array = build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t     f.lhs, field, NULL_TREE);\n+    tree lhs_vector = build4 (ARRAY_REF, TREE_TYPE (rhs_vector),\n+\t\t\t      lhs_array, index, NULL_TREE, NULL_TREE);\n+    gassign *update = gimple_build_assign (lhs_vector, rhs_vector);\n+    gsi_insert_after (f.gsi, update, GSI_SAME_STMT);\n+\n+    return copy;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    rtx rhs_tuple = e.args[0];\n+    unsigned int index = INTVAL (e.args[1]);\n+    rtx rhs_vector = e.args[2];\n+\n+    /* First copy the full tuple to the target register.  */\n+    rtx lhs_tuple = e.get_nonoverlapping_reg_target ();\n+    emit_move_insn (lhs_tuple, rhs_tuple);\n+\n+    /* ...then update the individual vector.  */\n+    rtx lhs_vector = simplify_gen_subreg (GET_MODE (rhs_vector),\n+\t\t\t\t\t  lhs_tuple, GET_MODE (lhs_tuple),\n+\t\t\t\t\t  index * BYTES_PER_SVE_VECTOR);\n+    emit_move_insn (lhs_vector, rhs_vector);\n+    return lhs_vector;\n+  }\n+};\n+\n+class svsetffr_impl : public function_base\n+{\n+public:\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return CP_WRITE_FFR;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    e.args.quick_push (CONSTM1_RTX (VNx16BImode));\n+    return e.use_exact_insn (CODE_FOR_aarch64_wrffr);\n+  }\n+};\n+\n+class svsplice_impl : public quiet<function_base>\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return e.use_exact_insn (code_for_aarch64_sve_splice (e.vector_mode (0)));\n+  }\n+};\n+\n+class svst1_impl : public full_width_access\n+{\n+public:\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return CP_WRITE_MEMORY;\n+  }\n+\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    tree vectype = f.vector_type (0);\n+\n+    /* Get the predicate and base pointer.  */\n+    gimple_seq stmts = NULL;\n+    tree pred = f.convert_pred (stmts, vectype, 0);\n+    tree base = f.fold_contiguous_base (stmts, vectype);\n+    gsi_insert_seq_before (f.gsi, stmts, GSI_SAME_STMT);\n+\n+    tree cookie = f.load_store_cookie (TREE_TYPE (vectype));\n+    tree rhs = gimple_call_arg (f.call, gimple_call_num_args (f.call) - 1);\n+    return gimple_build_call_internal (IFN_MASK_STORE, 4,\n+\t\t\t\t       base, cookie, pred, rhs);\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    insn_code icode = convert_optab_handler (maskstore_optab,\n+\t\t\t\t\t     e.vector_mode (0), e.gp_mode (0));\n+    return e.use_contiguous_store_insn (icode);\n+  }\n+};\n+\n+class svst1_scatter_impl : public full_width_access\n+{\n+public:\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return CP_WRITE_MEMORY;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    e.prepare_gather_address_operands (1);\n+    /* Put the predicate last, as required by mask_scatter_store_optab.  */\n+    e.rotate_inputs_left (0, 6);\n+    insn_code icode = direct_optab_handler (mask_scatter_store_optab,\n+\t\t\t\t\t    e.memory_vector_mode ());\n+    return e.use_exact_insn (icode);\n+  }\n+};\n+\n+/* Implements truncating forms of svst1_scatter.  */\n+class svst1_scatter_truncate_impl : public truncating_store\n+{\n+public:\n+  CONSTEXPR svst1_scatter_truncate_impl (scalar_int_mode to_mode)\n+    : truncating_store (to_mode) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    e.prepare_gather_address_operands (1);\n+    /* Put the predicate last, since the truncating scatters use the same\n+       operand order as mask_scatter_store_optab.  */\n+    e.rotate_inputs_left (0, 6);\n+    insn_code icode = code_for_aarch64_scatter_store_trunc\n+      (e.memory_vector_mode (), e.vector_mode (0));\n+    return e.use_exact_insn (icode);\n+  }\n+};\n+\n+/* Implements truncating contiguous forms of svst1.  */\n+class svst1_truncate_impl : public truncating_store\n+{\n+public:\n+  CONSTEXPR svst1_truncate_impl (scalar_int_mode to_mode)\n+    : truncating_store (to_mode) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    insn_code icode = code_for_aarch64_store_trunc (e.memory_vector_mode (),\n+\t\t\t\t\t\t    e.vector_mode (0));\n+    return e.use_contiguous_store_insn (icode);\n+  }\n+};\n+\n+/* Implements svst2, svst3 and svst4.  */\n+class svst234_impl : public full_width_access\n+{\n+public:\n+  CONSTEXPR svst234_impl (unsigned int vectors_per_tuple)\n+    : full_width_access (vectors_per_tuple) {}\n+\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return CP_WRITE_MEMORY;\n+  }\n+\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    tree vectype = f.vector_type (0);\n+\n+    /* Get the predicate and base pointer.  */\n+    gimple_seq stmts = NULL;\n+    tree pred = f.convert_pred (stmts, vectype, 0);\n+    tree base = f.fold_contiguous_base (stmts, vectype);\n+    gsi_insert_seq_before (f.gsi, stmts, GSI_SAME_STMT);\n+\n+    /* View the stored data as an array of vectors.  */\n+    unsigned int num_args = gimple_call_num_args (f.call);\n+    tree rhs_tuple = gimple_call_arg (f.call, num_args - 1);\n+    tree field = tuple_type_field (TREE_TYPE (rhs_tuple));\n+    tree rhs_array = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (field), rhs_tuple);\n+\n+    tree cookie = f.load_store_cookie (TREE_TYPE (vectype));\n+    return gimple_build_call_internal (IFN_MASK_STORE_LANES, 4,\n+\t\t\t\t       base, cookie, pred, rhs_array);\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    machine_mode tuple_mode = GET_MODE (e.args.last ());\n+    insn_code icode = convert_optab_handler (vec_mask_store_lanes_optab,\n+\t\t\t\t\t     tuple_mode, e.vector_mode (0));\n+    return e.use_contiguous_store_insn (icode);\n+  }\n+};\n+\n+class svstnt1_impl : public full_width_access\n+{\n+public:\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return CP_WRITE_MEMORY;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    insn_code icode = code_for_aarch64_stnt1 (e.vector_mode (0));\n+    return e.use_contiguous_store_insn (icode);\n+  }\n+};\n+\n+class svsub_impl : public rtx_code_function\n+{\n+public:\n+  CONSTEXPR svsub_impl ()\n+    : rtx_code_function (MINUS, MINUS, UNSPEC_COND_FSUB) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* Canonicalize subtractions of constants to additions.  */\n+    machine_mode mode = e.vector_mode (0);\n+    if (e.try_negating_argument (2, mode))\n+      return e.map_to_rtx_codes (PLUS, PLUS, UNSPEC_COND_FADD);\n+\n+    return rtx_code_function::expand (e);\n+  }\n+};\n+\n+class svtbl_impl : public permute\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return e.use_exact_insn (code_for_aarch64_sve_tbl (e.vector_mode (0)));\n+  }\n+};\n+\n+class svtmad_impl : public function_base\n+{\n+public:\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return e.use_exact_insn (code_for_aarch64_sve_tmad (e.vector_mode (0)));\n+  }\n+};\n+\n+/* Implements svtrn1 and svtrn2.  */\n+class svtrn_impl : public binary_permute\n+{\n+public:\n+  CONSTEXPR svtrn_impl (int base)\n+    : binary_permute (base ? UNSPEC_TRN2 : UNSPEC_TRN1), m_base (base) {}\n+\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    /* svtrn1: { 0, nelts, 2, nelts + 2, 4, nelts + 4, ... }\n+       svtrn2: as for svtrn1, but with 1 added to each index.  */\n+    poly_uint64 nelts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (f.lhs));\n+    vec_perm_builder builder (nelts, 2, 3);\n+    for (unsigned int i = 0; i < 3; ++i)\n+      {\n+\tbuilder.quick_push (m_base + i * 2);\n+\tbuilder.quick_push (m_base + i * 2 + nelts);\n+      }\n+    return fold_permute (f, builder);\n+  }\n+\n+  /* 0 for svtrn1, 1 for svtrn2.  */\n+  unsigned int m_base;\n+};\n+\n+/* Base class for svundef{,2,3,4}.  */\n+class svundef_impl : public quiet<multi_vector_function>\n+{\n+public:\n+  CONSTEXPR svundef_impl (unsigned int vectors_per_tuple)\n+    : quiet<multi_vector_function> (vectors_per_tuple) {}\n+\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    /* Don't fold svundef at the gimple level.  There's no exact\n+       correspondence for SSA_NAMEs, and we explicitly don't want\n+       to generate a specific value (like an all-zeros vector).  */\n+    if (vectors_per_tuple () == 1)\n+      return NULL;\n+    return gimple_build_assign (f.lhs, build_clobber (TREE_TYPE (f.lhs)));\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    rtx target = e.get_reg_target ();\n+    emit_clobber (copy_rtx (target));\n+    return target;\n+  }\n+};\n+\n+/* Implements svunpklo and svunpkhi.  */\n+class svunpk_impl : public quiet<function_base>\n+{\n+public:\n+  CONSTEXPR svunpk_impl (bool high_p) : m_high_p (high_p) {}\n+\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    /* Don't fold the predicate ops, since every bit of the svbool_t\n+       result is significant.  */\n+    if (f.type_suffix_ids[0] == TYPE_SUFFIX_b)\n+      return NULL;\n+\n+    /* The first half in memory is VEC_UNPACK_LO_EXPR for little-endian\n+       and VEC_UNPACK_HI_EXPR for big-endian.  */\n+    bool high_p = BYTES_BIG_ENDIAN ? !m_high_p : m_high_p;\n+    tree_code code = high_p ? VEC_UNPACK_HI_EXPR : VEC_UNPACK_LO_EXPR;\n+    return gimple_build_assign (f.lhs, code, gimple_call_arg (f.call, 0));\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    machine_mode mode = GET_MODE (e.args[0]);\n+    unsigned int unpacku = m_high_p ? UNSPEC_UNPACKUHI : UNSPEC_UNPACKULO;\n+    unsigned int unpacks = m_high_p ? UNSPEC_UNPACKSHI : UNSPEC_UNPACKSLO;\n+    insn_code icode;\n+    if (GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL)\n+      icode = code_for_aarch64_sve_punpk (unpacku, mode);\n+    else\n+      {\n+\tint unspec = e.type_suffix (0).unsigned_p ? unpacku : unpacks;\n+\ticode = code_for_aarch64_sve_unpk (unspec, unspec, mode);\n+      }\n+    return e.use_exact_insn (icode);\n+  }\n+\n+  /* True for svunpkhi, false for svunpklo.  */\n+  bool m_high_p;\n+};\n+\n+/* Implements svuzp1 and svuzp2.  */\n+class svuzp_impl : public binary_permute\n+{\n+public:\n+  CONSTEXPR svuzp_impl (unsigned int base)\n+    : binary_permute (base ? UNSPEC_UZP2 : UNSPEC_UZP1), m_base (base) {}\n+\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    /* svuzp1: { 0, 2, 4, 6, ... }\n+       svuzp2: { 1, 3, 5, 7, ... }.  */\n+    poly_uint64 nelts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (f.lhs));\n+    vec_perm_builder builder (nelts, 1, 3);\n+    for (unsigned int i = 0; i < 3; ++i)\n+      builder.quick_push (m_base + i * 2);\n+    return fold_permute (f, builder);\n+  }\n+\n+  /* 0 for svuzp1, 1 for svuzp2.  */\n+  unsigned int m_base;\n+};\n+\n+/* A function_base for svwhilele and svwhilelt functions.  */\n+class svwhile_impl : public function_base\n+{\n+public:\n+  CONSTEXPR svwhile_impl (int unspec_for_sint, int unspec_for_uint, bool eq_p)\n+    : m_unspec_for_sint (unspec_for_sint),\n+      m_unspec_for_uint (unspec_for_uint), m_eq_p (eq_p)\n+  {}\n+\n+  /* Try to fold a call by treating its arguments as constants of type T.  */\n+  template<typename T>\n+  gimple *\n+  fold_type (gimple_folder &f) const\n+  {\n+    /* Only handle cases in which both operands are constant.  */\n+    T arg0, arg1;\n+    if (!poly_int_tree_p (gimple_call_arg (f.call, 0), &arg0)\n+\t|| !poly_int_tree_p (gimple_call_arg (f.call, 1), &arg1))\n+      return NULL;\n+\n+    /* Check whether the result is known to be all-false.  */\n+    if (m_eq_p ? known_gt (arg0, arg1) : known_ge (arg0, arg1))\n+      return f.fold_to_pfalse ();\n+\n+    /* Punt if we can't tell at compile time whether the result\n+       is all-false.  */\n+    if (m_eq_p ? maybe_gt (arg0, arg1) : maybe_ge (arg0, arg1))\n+      return NULL;\n+\n+    /* At this point we know the result has at least one set element.  */\n+    poly_uint64 diff = arg1 - arg0;\n+    poly_uint64 nelts = GET_MODE_NUNITS (f.vector_mode (0));\n+\n+    /* Canonicalize the svwhilele form to the svwhilelt form.  Subtract\n+       from NELTS rather than adding to DIFF, to prevent overflow.  */\n+    if (m_eq_p)\n+      nelts -= 1;\n+\n+    /* Check whether the result is known to be all-true.  */\n+    if (known_ge (diff, nelts))\n+      return f.fold_to_ptrue ();\n+\n+    /* Punt if DIFF might not be the actual number of set elements\n+       in the result.  Conditional equality is fine.  */\n+    if (maybe_gt (diff, nelts))\n+      return NULL;\n+\n+    /* At this point we know that the predicate will have DIFF set elements\n+       for svwhilelt and DIFF + 1 set elements for svwhilele (which stops\n+       after rather than before ARG1 is reached).  See if we can create\n+       the predicate at compile time.  */\n+    unsigned HOST_WIDE_INT vl;\n+    if (diff.is_constant (&vl))\n+      /* Overflow is no longer possible after the checks above.  */\n+      return f.fold_to_vl_pred (m_eq_p ? vl + 1 : vl);\n+\n+    return NULL;\n+  }\n+\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    if (f.type_suffix (1).unsigned_p)\n+      return fold_type<poly_uint64> (f);\n+    else\n+      return fold_type<poly_int64> (f);\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* Suffix 0 determines the predicate mode, suffix 1 determines the\n+       scalar mode and signedness.  */\n+    int unspec = (e.type_suffix (1).unsigned_p\n+\t\t  ? m_unspec_for_uint\n+\t\t  : m_unspec_for_sint);\n+    machine_mode pred_mode = e.vector_mode (0);\n+    scalar_mode reg_mode = GET_MODE_INNER (e.vector_mode (1));\n+    return e.use_exact_insn (code_for_while (unspec, reg_mode, pred_mode));\n+  }\n+\n+  /* The unspec codes associated with signed and unsigned operations\n+     respectively.  */\n+  int m_unspec_for_sint;\n+  int m_unspec_for_uint;\n+\n+  /* True svwhilele, false for svwhilelt.  */\n+  bool m_eq_p;\n+};\n+\n+class svwrffr_impl : public function_base\n+{\n+public:\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return CP_WRITE_FFR;\n+  }\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return e.use_exact_insn (CODE_FOR_aarch64_wrffr);\n+  }\n+};\n+\n+/* Implements svzip1 and svzip2.  */\n+class svzip_impl : public binary_permute\n+{\n+public:\n+  CONSTEXPR svzip_impl (unsigned int base)\n+    : binary_permute (base ? UNSPEC_ZIP2 : UNSPEC_ZIP1), m_base (base) {}\n+\n+  gimple *\n+  fold (gimple_folder &f) const OVERRIDE\n+  {\n+    /* svzip1: { 0, nelts, 1, nelts + 1, 2, nelts + 2, ... }\n+       svzip2: as for svzip1, but with nelts / 2 added to each index.  */\n+    poly_uint64 nelts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (f.lhs));\n+    poly_uint64 base = m_base * exact_div (nelts, 2);\n+    vec_perm_builder builder (nelts, 2, 3);\n+    for (unsigned int i = 0; i < 3; ++i)\n+      {\n+\tbuilder.quick_push (base + i);\n+\tbuilder.quick_push (base + i + nelts);\n+      }\n+    return fold_permute (f, builder);\n+  }\n+\n+  /* 0 for svzip1, 1 for svzip2.  */\n+  unsigned int m_base;\n+};\n+\n+} /* end anonymous namespace */\n+\n+namespace aarch64_sve {\n+\n+FUNCTION (svabd, svabd_impl,)\n+FUNCTION (svabs, quiet<rtx_code_function>, (ABS, ABS, UNSPEC_COND_FABS))\n+FUNCTION (svacge, svac_impl, (UNSPEC_COND_FCMGE))\n+FUNCTION (svacgt, svac_impl, (UNSPEC_COND_FCMGT))\n+FUNCTION (svacle, svac_impl, (UNSPEC_COND_FCMLE))\n+FUNCTION (svaclt, svac_impl, (UNSPEC_COND_FCMLT))\n+FUNCTION (svadd, rtx_code_function, (PLUS, PLUS, UNSPEC_COND_FADD))\n+FUNCTION (svadda, svadda_impl,)\n+FUNCTION (svaddv, reduction, (UNSPEC_SADDV, UNSPEC_UADDV, UNSPEC_FADDV))\n+FUNCTION (svadrb, svadr_bhwd_impl, (0))\n+FUNCTION (svadrd, svadr_bhwd_impl, (3))\n+FUNCTION (svadrh, svadr_bhwd_impl, (1))\n+FUNCTION (svadrw, svadr_bhwd_impl, (2))\n+FUNCTION (svand, rtx_code_function, (AND, AND))\n+FUNCTION (svandv, reduction, (UNSPEC_ANDV))\n+FUNCTION (svasr, rtx_code_function, (ASHIFTRT, ASHIFTRT))\n+FUNCTION (svasr_wide, shift_wide, (ASHIFTRT, UNSPEC_ASHIFTRT_WIDE))\n+FUNCTION (svasrd, svasrd_impl,)\n+FUNCTION (svbic, svbic_impl,)\n+FUNCTION (svbrka, svbrk_unary_impl, (UNSPEC_BRKA))\n+FUNCTION (svbrkb, svbrk_unary_impl, (UNSPEC_BRKB))\n+FUNCTION (svbrkn, svbrk_binary_impl, (UNSPEC_BRKN))\n+FUNCTION (svbrkpa, svbrk_binary_impl, (UNSPEC_BRKPA))\n+FUNCTION (svbrkpb, svbrk_binary_impl, (UNSPEC_BRKPB))\n+FUNCTION (svcadd, svcadd_impl,)\n+FUNCTION (svclasta, svclast_impl, (UNSPEC_CLASTA))\n+FUNCTION (svclastb, svclast_impl, (UNSPEC_CLASTB))\n+FUNCTION (svcls, unary_count, (CLRSB))\n+FUNCTION (svclz, unary_count, (CLZ))\n+FUNCTION (svcmla, svcmla_impl,)\n+FUNCTION (svcmla_lane, svcmla_lane_impl,)\n+FUNCTION (svcmpeq, svcmp_impl, (EQ_EXPR, UNSPEC_COND_FCMEQ))\n+FUNCTION (svcmpeq_wide, svcmp_wide_impl, (EQ_EXPR, UNSPEC_COND_CMPEQ_WIDE,\n+\t\t\t\t\t  UNSPEC_COND_CMPEQ_WIDE))\n+FUNCTION (svcmpge, svcmp_impl, (GE_EXPR, UNSPEC_COND_FCMGE))\n+FUNCTION (svcmpge_wide, svcmp_wide_impl, (GE_EXPR, UNSPEC_COND_CMPGE_WIDE,\n+\t\t\t\t\t  UNSPEC_COND_CMPHS_WIDE))\n+FUNCTION (svcmpgt, svcmp_impl, (GT_EXPR, UNSPEC_COND_FCMGT))\n+FUNCTION (svcmpgt_wide, svcmp_wide_impl, (GT_EXPR, UNSPEC_COND_CMPGT_WIDE,\n+\t\t\t\t\t  UNSPEC_COND_CMPHI_WIDE))\n+FUNCTION (svcmple, svcmp_impl, (LE_EXPR, UNSPEC_COND_FCMLE))\n+FUNCTION (svcmple_wide, svcmp_wide_impl, (LE_EXPR, UNSPEC_COND_CMPLE_WIDE,\n+\t\t\t\t\t  UNSPEC_COND_CMPLS_WIDE))\n+FUNCTION (svcmplt, svcmp_impl, (LT_EXPR, UNSPEC_COND_FCMLT))\n+FUNCTION (svcmplt_wide, svcmp_wide_impl, (LT_EXPR, UNSPEC_COND_CMPLT_WIDE,\n+\t\t\t\t\t  UNSPEC_COND_CMPLO_WIDE))\n+FUNCTION (svcmpne, svcmp_impl, (NE_EXPR, UNSPEC_COND_FCMNE))\n+FUNCTION (svcmpne_wide, svcmp_wide_impl, (NE_EXPR, UNSPEC_COND_CMPNE_WIDE,\n+\t\t\t\t\t  UNSPEC_COND_CMPNE_WIDE))\n+FUNCTION (svcmpuo, svcmpuo_impl,)\n+FUNCTION (svcnot, svcnot_impl,)\n+FUNCTION (svcnt, unary_count, (POPCOUNT))\n+FUNCTION (svcntb, svcnt_bhwd_impl, (VNx16QImode))\n+FUNCTION (svcntb_pat, svcnt_bhwd_pat_impl, (VNx16QImode))\n+FUNCTION (svcntd, svcnt_bhwd_impl, (VNx2DImode))\n+FUNCTION (svcntd_pat, svcnt_bhwd_pat_impl, (VNx2DImode))\n+FUNCTION (svcnth, svcnt_bhwd_impl, (VNx8HImode))\n+FUNCTION (svcnth_pat, svcnt_bhwd_pat_impl, (VNx8HImode))\n+FUNCTION (svcntp, svcntp_impl,)\n+FUNCTION (svcntw, svcnt_bhwd_impl, (VNx4SImode))\n+FUNCTION (svcntw_pat, svcnt_bhwd_pat_impl, (VNx4SImode))\n+FUNCTION (svcompact, svcompact_impl,)\n+FUNCTION (svcreate2, svcreate_impl, (2))\n+FUNCTION (svcreate3, svcreate_impl, (3))\n+FUNCTION (svcreate4, svcreate_impl, (4))\n+FUNCTION (svcvt, svcvt_impl,)\n+FUNCTION (svdiv, rtx_code_function, (DIV, UDIV, UNSPEC_COND_FDIV))\n+FUNCTION (svdivr, rtx_code_function_rotated, (DIV, UDIV, UNSPEC_COND_FDIV))\n+FUNCTION (svdot, svdot_impl,)\n+FUNCTION (svdot_lane, svdot_lane_impl,)\n+FUNCTION (svdup, svdup_impl,)\n+FUNCTION (svdup_lane, svdup_lane_impl,)\n+FUNCTION (svdupq, svdupq_impl,)\n+FUNCTION (svdupq_lane, svdupq_lane_impl,)\n+FUNCTION (sveor, rtx_code_function, (XOR, XOR, -1))\n+FUNCTION (sveorv, reduction, (UNSPEC_XORV))\n+FUNCTION (svexpa, unspec_based_function, (-1, -1, UNSPEC_FEXPA))\n+FUNCTION (svext, svext_impl,)\n+FUNCTION (svextb, svext_bhw_impl, (QImode))\n+FUNCTION (svexth, svext_bhw_impl, (HImode))\n+FUNCTION (svextw, svext_bhw_impl, (SImode))\n+FUNCTION (svget2, svget_impl, (2))\n+FUNCTION (svget3, svget_impl, (3))\n+FUNCTION (svget4, svget_impl, (4))\n+FUNCTION (svindex, svindex_impl,)\n+FUNCTION (svinsr, svinsr_impl,)\n+FUNCTION (svlasta, svlast_impl, (UNSPEC_LASTA))\n+FUNCTION (svlastb, svlast_impl, (UNSPEC_LASTB))\n+FUNCTION (svld1, svld1_impl,)\n+FUNCTION (svld1_gather, svld1_gather_impl,)\n+FUNCTION (svld1rq, svld1rq_impl,)\n+FUNCTION (svld1sb, svld1_extend_impl, (TYPE_SUFFIX_s8))\n+FUNCTION (svld1sb_gather, svld1_gather_extend_impl, (TYPE_SUFFIX_s8))\n+FUNCTION (svld1sh, svld1_extend_impl, (TYPE_SUFFIX_s16))\n+FUNCTION (svld1sh_gather, svld1_gather_extend_impl, (TYPE_SUFFIX_s16))\n+FUNCTION (svld1sw, svld1_extend_impl, (TYPE_SUFFIX_s32))\n+FUNCTION (svld1sw_gather, svld1_gather_extend_impl, (TYPE_SUFFIX_s32))\n+FUNCTION (svld1ub, svld1_extend_impl, (TYPE_SUFFIX_u8))\n+FUNCTION (svld1ub_gather, svld1_gather_extend_impl, (TYPE_SUFFIX_u8))\n+FUNCTION (svld1uh, svld1_extend_impl, (TYPE_SUFFIX_u16))\n+FUNCTION (svld1uh_gather, svld1_gather_extend_impl, (TYPE_SUFFIX_u16))\n+FUNCTION (svld1uw, svld1_extend_impl, (TYPE_SUFFIX_u32))\n+FUNCTION (svld1uw_gather, svld1_gather_extend_impl, (TYPE_SUFFIX_u32))\n+FUNCTION (svld2, svld234_impl, (2))\n+FUNCTION (svld3, svld234_impl, (3))\n+FUNCTION (svld4, svld234_impl, (4))\n+FUNCTION (svldff1, svldxf1_impl, (UNSPEC_LDFF1))\n+FUNCTION (svldff1_gather, svldff1_gather_impl,)\n+FUNCTION (svldff1sb, svldxf1_extend_impl, (TYPE_SUFFIX_s8, UNSPEC_LDFF1))\n+FUNCTION (svldff1sb_gather, svldff1_gather_extend, (TYPE_SUFFIX_s8))\n+FUNCTION (svldff1sh, svldxf1_extend_impl, (TYPE_SUFFIX_s16, UNSPEC_LDFF1))\n+FUNCTION (svldff1sh_gather, svldff1_gather_extend, (TYPE_SUFFIX_s16))\n+FUNCTION (svldff1sw, svldxf1_extend_impl, (TYPE_SUFFIX_s32, UNSPEC_LDFF1))\n+FUNCTION (svldff1sw_gather, svldff1_gather_extend, (TYPE_SUFFIX_s32))\n+FUNCTION (svldff1ub, svldxf1_extend_impl, (TYPE_SUFFIX_u8, UNSPEC_LDFF1))\n+FUNCTION (svldff1ub_gather, svldff1_gather_extend, (TYPE_SUFFIX_u8))\n+FUNCTION (svldff1uh, svldxf1_extend_impl, (TYPE_SUFFIX_u16, UNSPEC_LDFF1))\n+FUNCTION (svldff1uh_gather, svldff1_gather_extend, (TYPE_SUFFIX_u16))\n+FUNCTION (svldff1uw, svldxf1_extend_impl, (TYPE_SUFFIX_u32, UNSPEC_LDFF1))\n+FUNCTION (svldff1uw_gather, svldff1_gather_extend, (TYPE_SUFFIX_u32))\n+FUNCTION (svldnf1, svldxf1_impl, (UNSPEC_LDNF1))\n+FUNCTION (svldnf1sb, svldxf1_extend_impl, (TYPE_SUFFIX_s8, UNSPEC_LDNF1))\n+FUNCTION (svldnf1sh, svldxf1_extend_impl, (TYPE_SUFFIX_s16, UNSPEC_LDNF1))\n+FUNCTION (svldnf1sw, svldxf1_extend_impl, (TYPE_SUFFIX_s32, UNSPEC_LDNF1))\n+FUNCTION (svldnf1ub, svldxf1_extend_impl, (TYPE_SUFFIX_u8, UNSPEC_LDNF1))\n+FUNCTION (svldnf1uh, svldxf1_extend_impl, (TYPE_SUFFIX_u16, UNSPEC_LDNF1))\n+FUNCTION (svldnf1uw, svldxf1_extend_impl, (TYPE_SUFFIX_u32, UNSPEC_LDNF1))\n+FUNCTION (svldnt1, svldnt1_impl,)\n+FUNCTION (svlen, svlen_impl,)\n+FUNCTION (svlsl, rtx_code_function, (ASHIFT, ASHIFT))\n+FUNCTION (svlsl_wide, shift_wide, (ASHIFT, UNSPEC_ASHIFT_WIDE))\n+FUNCTION (svlsr, rtx_code_function, (LSHIFTRT, LSHIFTRT))\n+FUNCTION (svlsr_wide, shift_wide, (LSHIFTRT, UNSPEC_LSHIFTRT_WIDE))\n+FUNCTION (svmad, svmad_impl,)\n+FUNCTION (svmax, rtx_code_function, (SMAX, UMAX, UNSPEC_COND_FMAX))\n+FUNCTION (svmaxnm, unspec_based_function, (-1, -1, UNSPEC_COND_FMAXNM))\n+FUNCTION (svmaxnmv, reduction, (UNSPEC_FMAXNMV))\n+FUNCTION (svmaxv, reduction, (UNSPEC_SMAXV, UNSPEC_UMAXV, UNSPEC_FMAXV))\n+FUNCTION (svmin, rtx_code_function, (SMIN, UMIN, UNSPEC_COND_FMIN))\n+FUNCTION (svminnm, unspec_based_function, (-1, -1, UNSPEC_COND_FMINNM))\n+FUNCTION (svminnmv, reduction, (UNSPEC_FMINNMV))\n+FUNCTION (svminv, reduction, (UNSPEC_SMINV, UNSPEC_UMINV, UNSPEC_FMINV))\n+FUNCTION (svmla, svmla_impl,)\n+FUNCTION (svmla_lane, svmla_svmls_lane_impl, (UNSPEC_FMLA))\n+FUNCTION (svmls, svmls_impl,)\n+FUNCTION (svmls_lane, svmla_svmls_lane_impl, (UNSPEC_FMLS))\n+FUNCTION (svmov, svmov_impl,)\n+FUNCTION (svmsb, svmsb_impl,)\n+FUNCTION (svmul, rtx_code_function, (MULT, MULT, UNSPEC_COND_FMUL))\n+FUNCTION (svmul_lane, svmul_lane_impl,)\n+FUNCTION (svmulh, unspec_based_function, (UNSPEC_SMUL_HIGHPART,\n+\t\t\t\t\t  UNSPEC_UMUL_HIGHPART, -1))\n+FUNCTION (svmulx, unspec_based_function, (-1, -1, UNSPEC_COND_FMULX))\n+FUNCTION (svnand, svnand_impl,)\n+FUNCTION (svneg, quiet<rtx_code_function>, (NEG, NEG, UNSPEC_COND_FNEG))\n+FUNCTION (svnmad, unspec_based_function, (-1, -1, UNSPEC_COND_FNMLA))\n+FUNCTION (svnmla, unspec_based_function_rotated, (-1, -1, UNSPEC_COND_FNMLA))\n+FUNCTION (svnmls, unspec_based_function_rotated, (-1, -1, UNSPEC_COND_FNMLS))\n+FUNCTION (svnmsb, unspec_based_function, (-1, -1, UNSPEC_COND_FNMLS))\n+FUNCTION (svnor, svnor_impl,)\n+FUNCTION (svnot, svnot_impl,)\n+FUNCTION (svorn, svorn_impl,)\n+FUNCTION (svorr, rtx_code_function, (IOR, IOR))\n+FUNCTION (svorv, reduction, (UNSPEC_IORV))\n+FUNCTION (svpfalse, svpfalse_impl,)\n+FUNCTION (svpfirst, svpfirst_svpnext_impl, (UNSPEC_PFIRST))\n+FUNCTION (svpnext, svpfirst_svpnext_impl, (UNSPEC_PNEXT))\n+FUNCTION (svprfb, svprf_bhwd_impl, (VNx16QImode))\n+FUNCTION (svprfb_gather, svprf_bhwd_gather_impl, (VNx16QImode))\n+FUNCTION (svprfd, svprf_bhwd_impl, (VNx2DImode))\n+FUNCTION (svprfd_gather, svprf_bhwd_gather_impl, (VNx2DImode))\n+FUNCTION (svprfh, svprf_bhwd_impl, (VNx8HImode))\n+FUNCTION (svprfh_gather, svprf_bhwd_gather_impl, (VNx8HImode))\n+FUNCTION (svprfw, svprf_bhwd_impl, (VNx4SImode))\n+FUNCTION (svprfw_gather, svprf_bhwd_gather_impl, (VNx4SImode))\n+FUNCTION (svptest_any, svptest_impl, (NE))\n+FUNCTION (svptest_first, svptest_impl, (LT))\n+FUNCTION (svptest_last, svptest_impl, (LTU))\n+FUNCTION (svptrue, svptrue_impl,)\n+FUNCTION (svptrue_pat, svptrue_pat_impl,)\n+FUNCTION (svqadd, svqadd_impl,)\n+FUNCTION (svqdecb, svqdec_bhwd_impl, (QImode))\n+FUNCTION (svqdecb_pat, svqdec_bhwd_impl, (QImode))\n+FUNCTION (svqdecd, svqdec_bhwd_impl, (DImode))\n+FUNCTION (svqdecd_pat, svqdec_bhwd_impl, (DImode))\n+FUNCTION (svqdech, svqdec_bhwd_impl, (HImode))\n+FUNCTION (svqdech_pat, svqdec_bhwd_impl, (HImode))\n+FUNCTION (svqdecp, svqdecp_svqincp_impl, (SS_MINUS, US_MINUS))\n+FUNCTION (svqdecw, svqdec_bhwd_impl, (SImode))\n+FUNCTION (svqdecw_pat, svqdec_bhwd_impl, (SImode))\n+FUNCTION (svqincb, svqinc_bhwd_impl, (QImode))\n+FUNCTION (svqincb_pat, svqinc_bhwd_impl, (QImode))\n+FUNCTION (svqincd, svqinc_bhwd_impl, (DImode))\n+FUNCTION (svqincd_pat, svqinc_bhwd_impl, (DImode))\n+FUNCTION (svqinch, svqinc_bhwd_impl, (HImode))\n+FUNCTION (svqinch_pat, svqinc_bhwd_impl, (HImode))\n+FUNCTION (svqincp, svqdecp_svqincp_impl, (SS_PLUS, US_PLUS))\n+FUNCTION (svqincw, svqinc_bhwd_impl, (SImode))\n+FUNCTION (svqincw_pat, svqinc_bhwd_impl, (SImode))\n+FUNCTION (svqsub, svqsub_impl,)\n+FUNCTION (svrbit, unspec_based_function, (UNSPEC_RBIT, UNSPEC_RBIT, -1))\n+FUNCTION (svrdffr, svrdffr_impl,)\n+FUNCTION (svrecpe, unspec_based_function, (-1, -1, UNSPEC_FRECPE))\n+FUNCTION (svrecps, unspec_based_function, (-1, -1, UNSPEC_FRECPS))\n+FUNCTION (svrecpx, unspec_based_function, (-1, -1, UNSPEC_COND_FRECPX))\n+FUNCTION (svreinterpret, svreinterpret_impl,)\n+FUNCTION (svrev, svrev_impl,)\n+FUNCTION (svrevb, unspec_based_function, (UNSPEC_REVB, UNSPEC_REVB, -1))\n+FUNCTION (svrevh, unspec_based_function, (UNSPEC_REVH, UNSPEC_REVH, -1))\n+FUNCTION (svrevw, unspec_based_function, (UNSPEC_REVW, UNSPEC_REVW, -1))\n+FUNCTION (svrinta, unspec_based_function, (-1, -1, UNSPEC_COND_FRINTA))\n+FUNCTION (svrinti, unspec_based_function, (-1, -1, UNSPEC_COND_FRINTI))\n+FUNCTION (svrintm, unspec_based_function, (-1, -1, UNSPEC_COND_FRINTM))\n+FUNCTION (svrintn, unspec_based_function, (-1, -1, UNSPEC_COND_FRINTN))\n+FUNCTION (svrintp, unspec_based_function, (-1, -1, UNSPEC_COND_FRINTP))\n+FUNCTION (svrintx, unspec_based_function, (-1, -1, UNSPEC_COND_FRINTX))\n+FUNCTION (svrintz, unspec_based_function, (-1, -1, UNSPEC_COND_FRINTZ))\n+FUNCTION (svrsqrte, unspec_based_function, (-1, -1, UNSPEC_RSQRTE))\n+FUNCTION (svrsqrts, unspec_based_function, (-1, -1, UNSPEC_RSQRTS))\n+FUNCTION (svscale, unspec_based_function, (-1, -1, UNSPEC_COND_FSCALE))\n+FUNCTION (svsel, svsel_impl,)\n+FUNCTION (svset2, svset_impl, (2))\n+FUNCTION (svset3, svset_impl, (3))\n+FUNCTION (svset4, svset_impl, (4))\n+FUNCTION (svsetffr, svsetffr_impl,)\n+FUNCTION (svsplice, svsplice_impl,)\n+FUNCTION (svsqrt, rtx_code_function, (SQRT, SQRT, UNSPEC_COND_FSQRT))\n+FUNCTION (svst1, svst1_impl,)\n+FUNCTION (svst1_scatter, svst1_scatter_impl,)\n+FUNCTION (svst1b, svst1_truncate_impl, (QImode))\n+FUNCTION (svst1b_scatter, svst1_scatter_truncate_impl, (QImode))\n+FUNCTION (svst1h, svst1_truncate_impl, (HImode))\n+FUNCTION (svst1h_scatter, svst1_scatter_truncate_impl, (HImode))\n+FUNCTION (svst1w, svst1_truncate_impl, (SImode))\n+FUNCTION (svst1w_scatter, svst1_scatter_truncate_impl, (SImode))\n+FUNCTION (svst2, svst234_impl, (2))\n+FUNCTION (svst3, svst234_impl, (3))\n+FUNCTION (svst4, svst234_impl, (4))\n+FUNCTION (svstnt1, svstnt1_impl,)\n+FUNCTION (svsub, svsub_impl,)\n+FUNCTION (svsubr, rtx_code_function_rotated, (MINUS, MINUS, UNSPEC_COND_FSUB))\n+FUNCTION (svtbl, svtbl_impl,)\n+FUNCTION (svtmad, svtmad_impl,)\n+FUNCTION (svtrn1, svtrn_impl, (0))\n+FUNCTION (svtrn2, svtrn_impl, (1))\n+FUNCTION (svtsmul, unspec_based_function, (-1, -1, UNSPEC_FTSMUL))\n+FUNCTION (svtssel, unspec_based_function, (-1, -1, UNSPEC_FTSSEL))\n+FUNCTION (svundef, svundef_impl, (1))\n+FUNCTION (svundef2, svundef_impl, (2))\n+FUNCTION (svundef3, svundef_impl, (3))\n+FUNCTION (svundef4, svundef_impl, (4))\n+FUNCTION (svunpkhi, svunpk_impl, (true))\n+FUNCTION (svunpklo, svunpk_impl, (false))\n+FUNCTION (svuzp1, svuzp_impl, (0))\n+FUNCTION (svuzp2, svuzp_impl, (1))\n+FUNCTION (svwhilele, svwhile_impl, (UNSPEC_WHILE_LE, UNSPEC_WHILE_LS, true))\n+FUNCTION (svwhilelt, svwhile_impl, (UNSPEC_WHILE_LT, UNSPEC_WHILE_LO, false))\n+FUNCTION (svwrffr, svwrffr_impl,)\n+FUNCTION (svzip1, svzip_impl, (0))\n+FUNCTION (svzip2, svzip_impl, (1))\n+\n+} /* end namespace aarch64_sve */"}, {"sha": "a678ee8f4eebad5a8be113968a08185f1fe848d7", "filename": "gcc/config/aarch64/aarch64-sve-builtins-base.def", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-base.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-base.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-base.def?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,318 @@\n+/* ACLE support for AArch64 SVE (__ARM_FEATURE_SVE intrinsics)\n+   Copyright (C) 2018-2019 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#define REQUIRED_EXTENSIONS 0\n+DEF_SVE_FUNCTION (svabd, binary_opt_n, all_data, mxz)\n+DEF_SVE_FUNCTION (svabs, unary, all_float_and_signed, mxz)\n+DEF_SVE_FUNCTION (svacge, compare_opt_n, all_float, implicit)\n+DEF_SVE_FUNCTION (svacgt, compare_opt_n, all_float, implicit)\n+DEF_SVE_FUNCTION (svacle, compare_opt_n, all_float, implicit)\n+DEF_SVE_FUNCTION (svaclt, compare_opt_n, all_float, implicit)\n+DEF_SVE_FUNCTION (svadd, binary_opt_n, all_data, mxz)\n+DEF_SVE_FUNCTION (svadda, fold_left, all_float, implicit)\n+DEF_SVE_FUNCTION (svaddv, reduction_wide, all_data, implicit)\n+DEF_SVE_FUNCTION (svadrb, adr_offset, none, none)\n+DEF_SVE_FUNCTION (svadrd, adr_index, none, none)\n+DEF_SVE_FUNCTION (svadrh, adr_index, none, none)\n+DEF_SVE_FUNCTION (svadrw, adr_index, none, none)\n+DEF_SVE_FUNCTION (svand, binary_opt_n, all_integer, mxz)\n+DEF_SVE_FUNCTION (svand, binary_opt_n, b, z)\n+DEF_SVE_FUNCTION (svandv, reduction, all_integer, implicit)\n+DEF_SVE_FUNCTION (svasr, binary_uint_opt_n, all_signed, mxz)\n+DEF_SVE_FUNCTION (svasr_wide, binary_uint64_opt_n, bhs_signed, mxz)\n+DEF_SVE_FUNCTION (svasrd, shift_right_imm, all_signed, mxz)\n+DEF_SVE_FUNCTION (svbic, binary_opt_n, all_integer, mxz)\n+DEF_SVE_FUNCTION (svbic, binary_opt_n, b, z)\n+DEF_SVE_FUNCTION (svbrka, unary, b, mz)\n+DEF_SVE_FUNCTION (svbrkb, unary, b, mz)\n+DEF_SVE_FUNCTION (svbrkn, binary, b, z)\n+DEF_SVE_FUNCTION (svbrkpa, binary, b, z)\n+DEF_SVE_FUNCTION (svbrkpb, binary, b, z)\n+DEF_SVE_FUNCTION (svcadd, binary_rotate, all_float, mxz)\n+DEF_SVE_FUNCTION (svclasta, clast, all_data, implicit)\n+DEF_SVE_FUNCTION (svclastb, clast, all_data, implicit)\n+DEF_SVE_FUNCTION (svcls, unary_count, all_signed, mxz)\n+DEF_SVE_FUNCTION (svclz, unary_count, all_integer, mxz)\n+DEF_SVE_FUNCTION (svcmla, ternary_rotate, all_float, mxz)\n+DEF_SVE_FUNCTION (svcmla_lane, ternary_lane_rotate, hs_float, none)\n+DEF_SVE_FUNCTION (svcmpeq, compare_opt_n, all_data, implicit)\n+DEF_SVE_FUNCTION (svcmpeq_wide, compare_wide_opt_n, bhs_signed, implicit)\n+DEF_SVE_FUNCTION (svcmpge, compare_opt_n, all_data, implicit)\n+DEF_SVE_FUNCTION (svcmpge_wide, compare_wide_opt_n, bhs_integer, implicit)\n+DEF_SVE_FUNCTION (svcmpgt, compare_opt_n, all_data, implicit)\n+DEF_SVE_FUNCTION (svcmpgt_wide, compare_wide_opt_n, bhs_integer, implicit)\n+DEF_SVE_FUNCTION (svcmple, compare_opt_n, all_data, implicit)\n+DEF_SVE_FUNCTION (svcmple_wide, compare_wide_opt_n, bhs_integer, implicit)\n+DEF_SVE_FUNCTION (svcmplt, compare_opt_n, all_data, implicit)\n+DEF_SVE_FUNCTION (svcmplt_wide, compare_wide_opt_n, bhs_integer, implicit)\n+DEF_SVE_FUNCTION (svcmpne, compare_opt_n, all_data, implicit)\n+DEF_SVE_FUNCTION (svcmpne_wide, compare_wide_opt_n, bhs_signed, implicit)\n+DEF_SVE_FUNCTION (svcmpuo, compare_opt_n, all_float, implicit)\n+DEF_SVE_FUNCTION (svcnot, unary, all_integer, mxz)\n+DEF_SVE_FUNCTION (svcnt, unary_count, all_data, mxz)\n+DEF_SVE_FUNCTION (svcntb, count_inherent, none, none)\n+DEF_SVE_FUNCTION (svcntb_pat, count_pat, none, none)\n+DEF_SVE_FUNCTION (svcntd, count_inherent, none, none)\n+DEF_SVE_FUNCTION (svcntd_pat, count_pat, none, none)\n+DEF_SVE_FUNCTION (svcnth, count_inherent, none, none)\n+DEF_SVE_FUNCTION (svcnth_pat, count_pat, none, none)\n+DEF_SVE_FUNCTION (svcntp, count_pred, all_pred, implicit)\n+DEF_SVE_FUNCTION (svcntw, count_inherent, none, none)\n+DEF_SVE_FUNCTION (svcntw_pat, count_pat, none, none)\n+DEF_SVE_FUNCTION (svcompact, unary, sd_data, implicit)\n+DEF_SVE_FUNCTION (svcreate2, create, all_data, none)\n+DEF_SVE_FUNCTION (svcreate3, create, all_data, none)\n+DEF_SVE_FUNCTION (svcreate4, create, all_data, none)\n+DEF_SVE_FUNCTION (svcvt, unary_convert, cvt, mxz)\n+DEF_SVE_FUNCTION (svdiv, binary_opt_n, all_float_and_sd_integer, mxz)\n+DEF_SVE_FUNCTION (svdivr, binary_opt_n, all_float_and_sd_integer, mxz)\n+DEF_SVE_FUNCTION (svdot, ternary_qq_opt_n, sd_integer, none)\n+DEF_SVE_FUNCTION (svdot_lane, ternary_qq_lane, sd_integer, none)\n+DEF_SVE_FUNCTION (svdup, unary_n, all_data, mxz_or_none)\n+DEF_SVE_FUNCTION (svdup, unary_n, all_pred, none)\n+DEF_SVE_FUNCTION (svdup_lane, binary_uint_n, all_data, none)\n+DEF_SVE_FUNCTION (svdupq, dupq, all_data, none)\n+DEF_SVE_FUNCTION (svdupq, dupq, all_pred, none)\n+DEF_SVE_FUNCTION (svdupq_lane, binary_uint64_n, all_data, none)\n+DEF_SVE_FUNCTION (sveor, binary_opt_n, all_integer, mxz)\n+DEF_SVE_FUNCTION (sveor, binary_opt_n, b, z)\n+DEF_SVE_FUNCTION (sveorv, reduction, all_integer, implicit)\n+DEF_SVE_FUNCTION (svexpa, unary_uint, all_float, none)\n+DEF_SVE_FUNCTION (svext, ext, all_data, none)\n+DEF_SVE_FUNCTION (svextb, unary, hsd_integer, mxz)\n+DEF_SVE_FUNCTION (svexth, unary, sd_integer, mxz)\n+DEF_SVE_FUNCTION (svextw, unary, d_integer, mxz)\n+DEF_SVE_FUNCTION (svget2, get, all_data, none)\n+DEF_SVE_FUNCTION (svget3, get, all_data, none)\n+DEF_SVE_FUNCTION (svget4, get, all_data, none)\n+DEF_SVE_FUNCTION (svindex, binary_scalar, all_integer, none)\n+DEF_SVE_FUNCTION (svinsr, binary_n, all_data, none)\n+DEF_SVE_FUNCTION (svlasta, reduction, all_data, implicit)\n+DEF_SVE_FUNCTION (svlastb, reduction, all_data, implicit)\n+DEF_SVE_FUNCTION (svld1, load, all_data, implicit)\n+DEF_SVE_FUNCTION (svld1_gather, load_gather_sv, sd_data, implicit)\n+DEF_SVE_FUNCTION (svld1_gather, load_gather_vs, sd_data, implicit)\n+DEF_SVE_FUNCTION (svld1rq, load_replicate, all_data, implicit)\n+DEF_SVE_FUNCTION (svld1sb, load_ext, hsd_integer, implicit)\n+DEF_SVE_FUNCTION (svld1sb_gather, load_ext_gather_offset, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svld1sh, load_ext, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svld1sh_gather, load_ext_gather_offset, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svld1sh_gather, load_ext_gather_index, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svld1sw, load_ext, d_integer, implicit)\n+DEF_SVE_FUNCTION (svld1sw_gather, load_ext_gather_offset, d_integer, implicit)\n+DEF_SVE_FUNCTION (svld1sw_gather, load_ext_gather_index, d_integer, implicit)\n+DEF_SVE_FUNCTION (svld1ub, load_ext, hsd_integer, implicit)\n+DEF_SVE_FUNCTION (svld1ub_gather, load_ext_gather_offset, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svld1uh, load_ext, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svld1uh_gather, load_ext_gather_offset, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svld1uh_gather, load_ext_gather_index, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svld1uw, load_ext, d_integer, implicit)\n+DEF_SVE_FUNCTION (svld1uw_gather, load_ext_gather_offset, d_integer, implicit)\n+DEF_SVE_FUNCTION (svld1uw_gather, load_ext_gather_index, d_integer, implicit)\n+DEF_SVE_FUNCTION (svldff1, load, all_data, implicit)\n+DEF_SVE_FUNCTION (svldff1_gather, load_gather_sv, sd_data, implicit)\n+DEF_SVE_FUNCTION (svldff1_gather, load_gather_vs, sd_data, implicit)\n+DEF_SVE_FUNCTION (svldff1sb, load_ext, hsd_integer, implicit)\n+DEF_SVE_FUNCTION (svldff1sb_gather, load_ext_gather_offset, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svldff1sh, load_ext, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svldff1sh_gather, load_ext_gather_offset, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svldff1sh_gather, load_ext_gather_index, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svldff1sw, load_ext, d_integer, implicit)\n+DEF_SVE_FUNCTION (svldff1sw_gather, load_ext_gather_offset, d_integer, implicit)\n+DEF_SVE_FUNCTION (svldff1sw_gather, load_ext_gather_index, d_integer, implicit)\n+DEF_SVE_FUNCTION (svldff1ub, load_ext, hsd_integer, implicit)\n+DEF_SVE_FUNCTION (svldff1ub_gather, load_ext_gather_offset, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svldff1uh, load_ext, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svldff1uh_gather, load_ext_gather_offset, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svldff1uh_gather, load_ext_gather_index, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svldff1uw, load_ext, d_integer, implicit)\n+DEF_SVE_FUNCTION (svldff1uw_gather, load_ext_gather_offset, d_integer, implicit)\n+DEF_SVE_FUNCTION (svldff1uw_gather, load_ext_gather_index, d_integer, implicit)\n+DEF_SVE_FUNCTION (svldnf1, load, all_data, implicit)\n+DEF_SVE_FUNCTION (svldnf1sb, load_ext, hsd_integer, implicit)\n+DEF_SVE_FUNCTION (svldnf1sh, load_ext, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svldnf1sw, load_ext, d_integer, implicit)\n+DEF_SVE_FUNCTION (svldnf1ub, load_ext, hsd_integer, implicit)\n+DEF_SVE_FUNCTION (svldnf1uh, load_ext, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svldnf1uw, load_ext, d_integer, implicit)\n+DEF_SVE_FUNCTION (svldnt1, load, all_data, implicit)\n+DEF_SVE_FUNCTION (svld2, load, all_data, implicit)\n+DEF_SVE_FUNCTION (svld3, load, all_data, implicit)\n+DEF_SVE_FUNCTION (svld4, load, all_data, implicit)\n+DEF_SVE_FUNCTION (svlen, count_vector, all_data, none)\n+DEF_SVE_FUNCTION (svlsl, binary_uint_opt_n, all_integer, mxz)\n+DEF_SVE_FUNCTION (svlsl_wide, binary_uint64_opt_n, bhs_integer, mxz)\n+DEF_SVE_FUNCTION (svlsr, binary_uint_opt_n, all_unsigned, mxz)\n+DEF_SVE_FUNCTION (svlsr_wide, binary_uint64_opt_n, bhs_unsigned, mxz)\n+DEF_SVE_FUNCTION (svmad, ternary_opt_n, all_data, mxz)\n+DEF_SVE_FUNCTION (svmax, binary_opt_n, all_data, mxz)\n+DEF_SVE_FUNCTION (svmaxnm, binary_opt_n, all_float, mxz)\n+DEF_SVE_FUNCTION (svmaxnmv, reduction, all_float, implicit)\n+DEF_SVE_FUNCTION (svmaxv, reduction, all_data, implicit)\n+DEF_SVE_FUNCTION (svmin, binary_opt_n, all_data, mxz)\n+DEF_SVE_FUNCTION (svminnm, binary_opt_n, all_float, mxz)\n+DEF_SVE_FUNCTION (svminnmv, reduction, all_float, implicit)\n+DEF_SVE_FUNCTION (svminv, reduction, all_data, implicit)\n+DEF_SVE_FUNCTION (svmla, ternary_opt_n, all_data, mxz)\n+DEF_SVE_FUNCTION (svmla_lane, ternary_lane, all_float, none)\n+DEF_SVE_FUNCTION (svmls, ternary_opt_n, all_data, mxz)\n+DEF_SVE_FUNCTION (svmls_lane, ternary_lane, all_float, none)\n+DEF_SVE_FUNCTION (svmov, unary, b, z)\n+DEF_SVE_FUNCTION (svmsb, ternary_opt_n, all_data, mxz)\n+DEF_SVE_FUNCTION (svmul, binary_opt_n, all_data, mxz)\n+DEF_SVE_FUNCTION (svmul_lane, binary_lane, all_float, none)\n+DEF_SVE_FUNCTION (svmulh, binary_opt_n, all_integer, mxz)\n+DEF_SVE_FUNCTION (svmulx, binary_opt_n, all_float, mxz)\n+DEF_SVE_FUNCTION (svnand, binary_opt_n, b, z)\n+DEF_SVE_FUNCTION (svneg, unary, all_float_and_signed, mxz)\n+DEF_SVE_FUNCTION (svnmad, ternary_opt_n, all_float, mxz)\n+DEF_SVE_FUNCTION (svnmla, ternary_opt_n, all_float, mxz)\n+DEF_SVE_FUNCTION (svnmls, ternary_opt_n, all_float, mxz)\n+DEF_SVE_FUNCTION (svnmsb, ternary_opt_n, all_float, mxz)\n+DEF_SVE_FUNCTION (svnor, binary_opt_n, b, z)\n+DEF_SVE_FUNCTION (svnot, unary, all_integer, mxz)\n+DEF_SVE_FUNCTION (svnot, unary, b, z)\n+DEF_SVE_FUNCTION (svorn, binary_opt_n, b, z)\n+DEF_SVE_FUNCTION (svorr, binary_opt_n, all_integer, mxz)\n+DEF_SVE_FUNCTION (svorr, binary_opt_n, b, z)\n+DEF_SVE_FUNCTION (svorv, reduction, all_integer, implicit)\n+DEF_SVE_FUNCTION (svpfalse, inherent_b, b, none)\n+DEF_SVE_FUNCTION (svpfirst, unary, b, implicit)\n+DEF_SVE_FUNCTION (svpnext, unary_pred, all_pred, implicit)\n+DEF_SVE_FUNCTION (svprfb, prefetch, none, implicit)\n+DEF_SVE_FUNCTION (svprfb_gather, prefetch_gather_offset, none, implicit)\n+DEF_SVE_FUNCTION (svprfd, prefetch, none, implicit)\n+DEF_SVE_FUNCTION (svprfd_gather, prefetch_gather_index, none, implicit)\n+DEF_SVE_FUNCTION (svprfh, prefetch, none, implicit)\n+DEF_SVE_FUNCTION (svprfh_gather, prefetch_gather_index, none, implicit)\n+DEF_SVE_FUNCTION (svprfw, prefetch, none, implicit)\n+DEF_SVE_FUNCTION (svprfw_gather, prefetch_gather_index, none, implicit)\n+DEF_SVE_FUNCTION (svptest_any, ptest, none, implicit)\n+DEF_SVE_FUNCTION (svptest_first, ptest, none, implicit)\n+DEF_SVE_FUNCTION (svptest_last, ptest, none, implicit)\n+DEF_SVE_FUNCTION (svptrue, inherent, all_pred, none)\n+DEF_SVE_FUNCTION (svptrue_pat, pattern_pred, all_pred, none)\n+DEF_SVE_FUNCTION (svqadd, binary_opt_n, all_integer, none)\n+DEF_SVE_FUNCTION (svqdecb, inc_dec, sd_integer, none)\n+DEF_SVE_FUNCTION (svqdecb_pat, inc_dec_pat, sd_integer, none)\n+DEF_SVE_FUNCTION (svqdecd, inc_dec, d_integer, none)\n+DEF_SVE_FUNCTION (svqdecd, inc_dec, sd_integer, none)\n+DEF_SVE_FUNCTION (svqdecd_pat, inc_dec_pat, d_integer, none)\n+DEF_SVE_FUNCTION (svqdecd_pat, inc_dec_pat, sd_integer, none)\n+DEF_SVE_FUNCTION (svqdech, inc_dec, h_integer, none)\n+DEF_SVE_FUNCTION (svqdech, inc_dec, sd_integer, none)\n+DEF_SVE_FUNCTION (svqdech_pat, inc_dec_pat, h_integer, none)\n+DEF_SVE_FUNCTION (svqdech_pat, inc_dec_pat, sd_integer, none)\n+DEF_SVE_FUNCTION (svqdecp, inc_dec_pred, hsd_integer, none)\n+DEF_SVE_FUNCTION (svqdecp, inc_dec_pred_scalar, inc_dec_n, none)\n+DEF_SVE_FUNCTION (svqdecw, inc_dec, s_integer, none)\n+DEF_SVE_FUNCTION (svqdecw, inc_dec, sd_integer, none)\n+DEF_SVE_FUNCTION (svqdecw_pat, inc_dec_pat, s_integer, none)\n+DEF_SVE_FUNCTION (svqdecw_pat, inc_dec_pat, sd_integer, none)\n+DEF_SVE_FUNCTION (svqincb, inc_dec, sd_integer, none)\n+DEF_SVE_FUNCTION (svqincb_pat, inc_dec_pat, sd_integer, none)\n+DEF_SVE_FUNCTION (svqincd, inc_dec, d_integer, none)\n+DEF_SVE_FUNCTION (svqincd, inc_dec, sd_integer, none)\n+DEF_SVE_FUNCTION (svqincd_pat, inc_dec_pat, d_integer, none)\n+DEF_SVE_FUNCTION (svqincd_pat, inc_dec_pat, sd_integer, none)\n+DEF_SVE_FUNCTION (svqinch, inc_dec, h_integer, none)\n+DEF_SVE_FUNCTION (svqinch, inc_dec, sd_integer, none)\n+DEF_SVE_FUNCTION (svqinch_pat, inc_dec_pat, h_integer, none)\n+DEF_SVE_FUNCTION (svqinch_pat, inc_dec_pat, sd_integer, none)\n+DEF_SVE_FUNCTION (svqincp, inc_dec_pred, hsd_integer, none)\n+DEF_SVE_FUNCTION (svqincp, inc_dec_pred_scalar, inc_dec_n, none)\n+DEF_SVE_FUNCTION (svqincw, inc_dec, s_integer, none)\n+DEF_SVE_FUNCTION (svqincw, inc_dec, sd_integer, none)\n+DEF_SVE_FUNCTION (svqincw_pat, inc_dec_pat, s_integer, none)\n+DEF_SVE_FUNCTION (svqincw_pat, inc_dec_pat, sd_integer, none)\n+DEF_SVE_FUNCTION (svqsub, binary_opt_n, all_integer, none)\n+DEF_SVE_FUNCTION (svrbit, unary, all_integer, mxz)\n+DEF_SVE_FUNCTION (svrdffr, rdffr, none, z_or_none)\n+DEF_SVE_FUNCTION (svrecpe, unary, all_float, none)\n+DEF_SVE_FUNCTION (svrecps, binary, all_float, none)\n+DEF_SVE_FUNCTION (svrecpx, unary, all_float, mxz)\n+DEF_SVE_FUNCTION (svreinterpret, unary_convert, reinterpret, none)\n+DEF_SVE_FUNCTION (svrev, unary, all_data, none)\n+DEF_SVE_FUNCTION (svrev, unary_pred, all_pred, none)\n+DEF_SVE_FUNCTION (svrevb, unary, hsd_integer, mxz)\n+DEF_SVE_FUNCTION (svrevh, unary, sd_integer, mxz)\n+DEF_SVE_FUNCTION (svrevw, unary, d_integer, mxz)\n+DEF_SVE_FUNCTION (svrinta, unary, all_float, mxz)\n+DEF_SVE_FUNCTION (svrinti, unary, all_float, mxz)\n+DEF_SVE_FUNCTION (svrintm, unary, all_float, mxz)\n+DEF_SVE_FUNCTION (svrintn, unary, all_float, mxz)\n+DEF_SVE_FUNCTION (svrintp, unary, all_float, mxz)\n+DEF_SVE_FUNCTION (svrintx, unary, all_float, mxz)\n+DEF_SVE_FUNCTION (svrintz, unary, all_float, mxz)\n+DEF_SVE_FUNCTION (svrsqrte, unary, all_float, none)\n+DEF_SVE_FUNCTION (svrsqrts, binary, all_float, none)\n+DEF_SVE_FUNCTION (svscale, binary_int_opt_n, all_float, mxz)\n+DEF_SVE_FUNCTION (svsel, binary, all_data, implicit)\n+DEF_SVE_FUNCTION (svsel, binary, b, implicit)\n+DEF_SVE_FUNCTION (svset2, set, all_data, none)\n+DEF_SVE_FUNCTION (svset3, set, all_data, none)\n+DEF_SVE_FUNCTION (svset4, set, all_data, none)\n+DEF_SVE_FUNCTION (svsetffr, setffr, none, none)\n+DEF_SVE_FUNCTION (svsplice, binary, all_data, implicit)\n+DEF_SVE_FUNCTION (svsqrt, unary, all_float, mxz)\n+DEF_SVE_FUNCTION (svst1, store, all_data, implicit)\n+DEF_SVE_FUNCTION (svst1_scatter, store_scatter_index, sd_data, implicit)\n+DEF_SVE_FUNCTION (svst1_scatter, store_scatter_offset, sd_data, implicit)\n+DEF_SVE_FUNCTION (svst1b, store, hsd_integer, implicit)\n+DEF_SVE_FUNCTION (svst1b_scatter, store_scatter_offset, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svst1h, store, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svst1h_scatter, store_scatter_index, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svst1h_scatter, store_scatter_offset, sd_integer, implicit)\n+DEF_SVE_FUNCTION (svst1w, store, d_integer, implicit)\n+DEF_SVE_FUNCTION (svst1w_scatter, store_scatter_index, d_integer, implicit)\n+DEF_SVE_FUNCTION (svst1w_scatter, store_scatter_offset, d_integer, implicit)\n+DEF_SVE_FUNCTION (svst2, store, all_data, implicit)\n+DEF_SVE_FUNCTION (svst3, store, all_data, implicit)\n+DEF_SVE_FUNCTION (svst4, store, all_data, implicit)\n+DEF_SVE_FUNCTION (svstnt1, store, all_data, implicit)\n+DEF_SVE_FUNCTION (svsub, binary_opt_n, all_data, mxz)\n+DEF_SVE_FUNCTION (svsubr, binary_opt_n, all_data, mxz)\n+DEF_SVE_FUNCTION (svtbl, binary_uint, all_data, none)\n+DEF_SVE_FUNCTION (svtmad, tmad, all_float, none)\n+DEF_SVE_FUNCTION (svtrn1, binary, all_data, none)\n+DEF_SVE_FUNCTION (svtrn1, binary_pred, all_pred, none)\n+DEF_SVE_FUNCTION (svtrn2, binary, all_data, none)\n+DEF_SVE_FUNCTION (svtrn2, binary_pred, all_pred, none)\n+DEF_SVE_FUNCTION (svtsmul, binary_uint, all_float, none)\n+DEF_SVE_FUNCTION (svtssel, binary_uint, all_float, none)\n+DEF_SVE_FUNCTION (svundef, inherent, all_data, none)\n+DEF_SVE_FUNCTION (svundef2, inherent, all_data, none)\n+DEF_SVE_FUNCTION (svundef3, inherent, all_data, none)\n+DEF_SVE_FUNCTION (svundef4, inherent, all_data, none)\n+DEF_SVE_FUNCTION (svunpkhi, unary_widen, hsd_integer, none)\n+DEF_SVE_FUNCTION (svunpkhi, unary_widen, b, none)\n+DEF_SVE_FUNCTION (svunpklo, unary_widen, hsd_integer, none)\n+DEF_SVE_FUNCTION (svunpklo, unary_widen, b, none)\n+DEF_SVE_FUNCTION (svuzp1, binary, all_data, none)\n+DEF_SVE_FUNCTION (svuzp1, binary_pred, all_pred, none)\n+DEF_SVE_FUNCTION (svuzp2, binary, all_data, none)\n+DEF_SVE_FUNCTION (svuzp2, binary_pred, all_pred, none)\n+DEF_SVE_FUNCTION (svwhilele, compare_scalar, while, none)\n+DEF_SVE_FUNCTION (svwhilelt, compare_scalar, while, none)\n+DEF_SVE_FUNCTION (svwrffr, setffr, none, implicit)\n+DEF_SVE_FUNCTION (svzip1, binary, all_data, none)\n+DEF_SVE_FUNCTION (svzip1, binary_pred, all_pred, none)\n+DEF_SVE_FUNCTION (svzip2, binary, all_data, none)\n+DEF_SVE_FUNCTION (svzip2, binary_pred, all_pred, none)\n+#undef REQUIRED_EXTENSIONS"}, {"sha": "41ab12f4e35460603657e3b4f324545b5d10442f", "filename": "gcc/config/aarch64/aarch64-sve-builtins-base.h", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-base.h?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,283 @@\n+/* ACLE support for AArch64 SVE (__ARM_FEATURE_SVE intrinsics)\n+   Copyright (C) 2018-2019 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_AARCH64_SVE_BUILTINS_BASE_H\n+#define GCC_AARCH64_SVE_BUILTINS_BASE_H\n+\n+namespace aarch64_sve\n+{\n+  namespace functions\n+  {\n+    extern const function_base *const svabd;\n+    extern const function_base *const svabs;\n+    extern const function_base *const svacge;\n+    extern const function_base *const svacgt;\n+    extern const function_base *const svacle;\n+    extern const function_base *const svaclt;\n+    extern const function_base *const svadd;\n+    extern const function_base *const svadda;\n+    extern const function_base *const svaddv;\n+    extern const function_base *const svadrb;\n+    extern const function_base *const svadrd;\n+    extern const function_base *const svadrh;\n+    extern const function_base *const svadrw;\n+    extern const function_base *const svand;\n+    extern const function_base *const svandv;\n+    extern const function_base *const svasr;\n+    extern const function_base *const svasr_wide;\n+    extern const function_base *const svasrd;\n+    extern const function_base *const svbic;\n+    extern const function_base *const svbrka;\n+    extern const function_base *const svbrkb;\n+    extern const function_base *const svbrkn;\n+    extern const function_base *const svbrkpa;\n+    extern const function_base *const svbrkpb;\n+    extern const function_base *const svcadd;\n+    extern const function_base *const svclasta;\n+    extern const function_base *const svclastb;\n+    extern const function_base *const svcls;\n+    extern const function_base *const svclz;\n+    extern const function_base *const svcmla;\n+    extern const function_base *const svcmla_lane;\n+    extern const function_base *const svcmpeq;\n+    extern const function_base *const svcmpeq_wide;\n+    extern const function_base *const svcmpge;\n+    extern const function_base *const svcmpge_wide;\n+    extern const function_base *const svcmpgt;\n+    extern const function_base *const svcmpgt_wide;\n+    extern const function_base *const svcmple;\n+    extern const function_base *const svcmple_wide;\n+    extern const function_base *const svcmplt;\n+    extern const function_base *const svcmplt_wide;\n+    extern const function_base *const svcmpne;\n+    extern const function_base *const svcmpne_wide;\n+    extern const function_base *const svcmpuo;\n+    extern const function_base *const svcnot;\n+    extern const function_base *const svcnt;\n+    extern const function_base *const svcntb;\n+    extern const function_base *const svcntb_pat;\n+    extern const function_base *const svcntd;\n+    extern const function_base *const svcntd_pat;\n+    extern const function_base *const svcnth;\n+    extern const function_base *const svcnth_pat;\n+    extern const function_base *const svcntp;\n+    extern const function_base *const svcntw;\n+    extern const function_base *const svcntw_pat;\n+    extern const function_base *const svcompact;\n+    extern const function_base *const svcreate2;\n+    extern const function_base *const svcreate3;\n+    extern const function_base *const svcreate4;\n+    extern const function_base *const svcvt;\n+    extern const function_base *const svdiv;\n+    extern const function_base *const svdivr;\n+    extern const function_base *const svdot;\n+    extern const function_base *const svdot_lane;\n+    extern const function_base *const svdup;\n+    extern const function_base *const svdup_lane;\n+    extern const function_base *const svdupq;\n+    extern const function_base *const svdupq_lane;\n+    extern const function_base *const sveor;\n+    extern const function_base *const sveorv;\n+    extern const function_base *const svexpa;\n+    extern const function_base *const svext;\n+    extern const function_base *const svextb;\n+    extern const function_base *const svexth;\n+    extern const function_base *const svextw;\n+    extern const function_base *const svget2;\n+    extern const function_base *const svget3;\n+    extern const function_base *const svget4;\n+    extern const function_base *const svindex;\n+    extern const function_base *const svinsr;\n+    extern const function_base *const svlasta;\n+    extern const function_base *const svlastb;\n+    extern const function_base *const svld1;\n+    extern const function_base *const svld1_gather;\n+    extern const function_base *const svld1rq;\n+    extern const function_base *const svld1sb;\n+    extern const function_base *const svld1sb_gather;\n+    extern const function_base *const svld1sh;\n+    extern const function_base *const svld1sh_gather;\n+    extern const function_base *const svld1sw;\n+    extern const function_base *const svld1sw_gather;\n+    extern const function_base *const svld1ub;\n+    extern const function_base *const svld1ub_gather;\n+    extern const function_base *const svld1uh;\n+    extern const function_base *const svld1uh_gather;\n+    extern const function_base *const svld1uw;\n+    extern const function_base *const svld1uw_gather;\n+    extern const function_base *const svld2;\n+    extern const function_base *const svld3;\n+    extern const function_base *const svld4;\n+    extern const function_base *const svldff1;\n+    extern const function_base *const svldff1_gather;\n+    extern const function_base *const svldff1sb;\n+    extern const function_base *const svldff1sb_gather;\n+    extern const function_base *const svldff1sh;\n+    extern const function_base *const svldff1sh_gather;\n+    extern const function_base *const svldff1sw;\n+    extern const function_base *const svldff1sw_gather;\n+    extern const function_base *const svldff1ub;\n+    extern const function_base *const svldff1ub_gather;\n+    extern const function_base *const svldff1uh;\n+    extern const function_base *const svldff1uh_gather;\n+    extern const function_base *const svldff1uw;\n+    extern const function_base *const svldff1uw_gather;\n+    extern const function_base *const svldnf1;\n+    extern const function_base *const svldnf1sb;\n+    extern const function_base *const svldnf1sh;\n+    extern const function_base *const svldnf1sw;\n+    extern const function_base *const svldnf1ub;\n+    extern const function_base *const svldnf1uh;\n+    extern const function_base *const svldnf1uw;\n+    extern const function_base *const svldnt1;\n+    extern const function_base *const svlen;\n+    extern const function_base *const svlsl;\n+    extern const function_base *const svlsl_wide;\n+    extern const function_base *const svlsr;\n+    extern const function_base *const svlsr_wide;\n+    extern const function_base *const svmad;\n+    extern const function_base *const svmax;\n+    extern const function_base *const svmaxnm;\n+    extern const function_base *const svmaxnmv;\n+    extern const function_base *const svmaxv;\n+    extern const function_base *const svmin;\n+    extern const function_base *const svminnm;\n+    extern const function_base *const svminnmv;\n+    extern const function_base *const svminv;\n+    extern const function_base *const svmla;\n+    extern const function_base *const svmla_lane;\n+    extern const function_base *const svmls;\n+    extern const function_base *const svmls_lane;\n+    extern const function_base *const svmov;\n+    extern const function_base *const svmsb;\n+    extern const function_base *const svmul;\n+    extern const function_base *const svmul_lane;\n+    extern const function_base *const svmulh;\n+    extern const function_base *const svmulx;\n+    extern const function_base *const svnand;\n+    extern const function_base *const svneg;\n+    extern const function_base *const svnmad;\n+    extern const function_base *const svnmla;\n+    extern const function_base *const svnmls;\n+    extern const function_base *const svnmsb;\n+    extern const function_base *const svnor;\n+    extern const function_base *const svnot;\n+    extern const function_base *const svorn;\n+    extern const function_base *const svorr;\n+    extern const function_base *const svorv;\n+    extern const function_base *const svpfalse;\n+    extern const function_base *const svpfirst;\n+    extern const function_base *const svpnext;\n+    extern const function_base *const svprfb;\n+    extern const function_base *const svprfb_gather;\n+    extern const function_base *const svprfd;\n+    extern const function_base *const svprfd_gather;\n+    extern const function_base *const svprfh;\n+    extern const function_base *const svprfh_gather;\n+    extern const function_base *const svprfw;\n+    extern const function_base *const svprfw_gather;\n+    extern const function_base *const svptest_any;\n+    extern const function_base *const svptest_first;\n+    extern const function_base *const svptest_last;\n+    extern const function_base *const svptrue;\n+    extern const function_base *const svptrue_pat;\n+    extern const function_base *const svqadd;\n+    extern const function_base *const svqdecb;\n+    extern const function_base *const svqdecb_pat;\n+    extern const function_base *const svqdecd;\n+    extern const function_base *const svqdecd_pat;\n+    extern const function_base *const svqdech;\n+    extern const function_base *const svqdech_pat;\n+    extern const function_base *const svqdecp;\n+    extern const function_base *const svqdecw;\n+    extern const function_base *const svqdecw_pat;\n+    extern const function_base *const svqincb;\n+    extern const function_base *const svqincb_pat;\n+    extern const function_base *const svqincd;\n+    extern const function_base *const svqincd_pat;\n+    extern const function_base *const svqinch;\n+    extern const function_base *const svqinch_pat;\n+    extern const function_base *const svqincp;\n+    extern const function_base *const svqincw;\n+    extern const function_base *const svqincw_pat;\n+    extern const function_base *const svqsub;\n+    extern const function_base *const svrbit;\n+    extern const function_base *const svrdffr;\n+    extern const function_base *const svrecpe;\n+    extern const function_base *const svrecps;\n+    extern const function_base *const svrecpx;\n+    extern const function_base *const svreinterpret;\n+    extern const function_base *const svrev;\n+    extern const function_base *const svrevb;\n+    extern const function_base *const svrevh;\n+    extern const function_base *const svrevw;\n+    extern const function_base *const svrinta;\n+    extern const function_base *const svrinti;\n+    extern const function_base *const svrintm;\n+    extern const function_base *const svrintn;\n+    extern const function_base *const svrintp;\n+    extern const function_base *const svrintx;\n+    extern const function_base *const svrintz;\n+    extern const function_base *const svrsqrte;\n+    extern const function_base *const svrsqrts;\n+    extern const function_base *const svscale;\n+    extern const function_base *const svsel;\n+    extern const function_base *const svset2;\n+    extern const function_base *const svset3;\n+    extern const function_base *const svset4;\n+    extern const function_base *const svsetffr;\n+    extern const function_base *const svsplice;\n+    extern const function_base *const svsqrt;\n+    extern const function_base *const svst1;\n+    extern const function_base *const svst1_scatter;\n+    extern const function_base *const svst1b;\n+    extern const function_base *const svst1b_scatter;\n+    extern const function_base *const svst1h;\n+    extern const function_base *const svst1h_scatter;\n+    extern const function_base *const svst1w;\n+    extern const function_base *const svst1w_scatter;\n+    extern const function_base *const svst2;\n+    extern const function_base *const svst3;\n+    extern const function_base *const svst4;\n+    extern const function_base *const svstnt1;\n+    extern const function_base *const svsub;\n+    extern const function_base *const svsubr;\n+    extern const function_base *const svtbl;\n+    extern const function_base *const svtmad;\n+    extern const function_base *const svtrn1;\n+    extern const function_base *const svtrn2;\n+    extern const function_base *const svtsmul;\n+    extern const function_base *const svtssel;\n+    extern const function_base *const svundef;\n+    extern const function_base *const svundef2;\n+    extern const function_base *const svundef3;\n+    extern const function_base *const svundef4;\n+    extern const function_base *const svunpkhi;\n+    extern const function_base *const svunpklo;\n+    extern const function_base *const svuzp1;\n+    extern const function_base *const svuzp2;\n+    extern const function_base *const svwhilele;\n+    extern const function_base *const svwhilelt;\n+    extern const function_base *const svwrffr;\n+    extern const function_base *const svzip1;\n+    extern const function_base *const svzip2;\n+  }\n+}\n+\n+#endif"}, {"sha": "0df7306976f4c7dc5d0f404a4eb08c2d7088c96d", "filename": "gcc/config/aarch64/aarch64-sve-builtins-functions.h", "status": "added", "additions": 444, "deletions": 0, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-functions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-functions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-functions.h?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,444 @@\n+/* ACLE support for AArch64 SVE (function_base classes)\n+   Copyright (C) 2018-2019 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_AARCH64_SVE_BUILTINS_FUNCTIONS_H\n+#define GCC_AARCH64_SVE_BUILTINS_FUNCTIONS_H\n+\n+namespace aarch64_sve {\n+\n+/* Wrap T, which is derived from function_base, and indicate that the\n+   function never has side effects.  It is only necessary to use this\n+   wrapper on functions that might have floating-point suffixes, since\n+   otherwise we assume by default that the function has no side effects.  */\n+template<typename T>\n+class quiet : public T\n+{\n+public:\n+  CONSTEXPR quiet () : T () {}\n+\n+  /* Unfortunately we can't use parameter packs yet.  */\n+  template<typename T1>\n+  CONSTEXPR quiet (const T1 &t1) : T (t1) {}\n+\n+  template<typename T1, typename T2>\n+  CONSTEXPR quiet (const T1 &t1, const T2 &t2) : T (t1, t2) {}\n+\n+  template<typename T1, typename T2, typename T3>\n+  CONSTEXPR quiet (const T1 &t1, const T2 &t2, const T3 &t3)\n+    : T (t1, t2, t3) {}\n+\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return 0;\n+  }\n+};\n+\n+/* A function_base that sometimes or always operates on tuples of\n+   vectors.  */\n+class multi_vector_function : public function_base\n+{\n+public:\n+  CONSTEXPR multi_vector_function (unsigned int vectors_per_tuple)\n+    : m_vectors_per_tuple (vectors_per_tuple) {}\n+\n+  unsigned int\n+  vectors_per_tuple () const OVERRIDE\n+  {\n+    return m_vectors_per_tuple;\n+  }\n+\n+  /* The number of vectors in a tuple, or 1 if the function only operates\n+     on single vectors.  */\n+  unsigned int m_vectors_per_tuple;\n+};\n+\n+/* A function_base that loads or stores contiguous memory elements\n+   without extending or truncating them.  */\n+class full_width_access : public multi_vector_function\n+{\n+public:\n+  CONSTEXPR full_width_access (unsigned int vectors_per_tuple = 1)\n+    : multi_vector_function (vectors_per_tuple) {}\n+\n+  tree\n+  memory_scalar_type (const function_instance &fi) const OVERRIDE\n+  {\n+    return fi.scalar_type (0);\n+  }\n+\n+  machine_mode\n+  memory_vector_mode (const function_instance &fi) const OVERRIDE\n+  {\n+    machine_mode mode = fi.vector_mode (0);\n+    if (m_vectors_per_tuple != 1)\n+      mode = targetm.array_mode (mode, m_vectors_per_tuple).require ();\n+    return mode;\n+  }\n+};\n+\n+/* A function_base that loads elements from memory and extends them\n+   to a wider element.  The memory element type is a fixed part of\n+   the function base name.  */\n+class extending_load : public function_base\n+{\n+public:\n+  CONSTEXPR extending_load (type_suffix_index memory_type)\n+    : m_memory_type (memory_type) {}\n+\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return CP_READ_MEMORY;\n+  }\n+\n+  tree\n+  memory_scalar_type (const function_instance &) const OVERRIDE\n+  {\n+    return scalar_types[type_suffixes[m_memory_type].vector_type];\n+  }\n+\n+  machine_mode\n+  memory_vector_mode (const function_instance &fi) const OVERRIDE\n+  {\n+    machine_mode mem_mode = type_suffixes[m_memory_type].vector_mode;\n+    machine_mode reg_mode = fi.vector_mode (0);\n+    return aarch64_sve_data_mode (GET_MODE_INNER (mem_mode),\n+\t\t\t\t  GET_MODE_NUNITS (reg_mode)).require ();\n+  }\n+\n+  /* Return the rtx code associated with the kind of extension that\n+     the load performs.  */\n+  rtx_code\n+  extend_rtx_code () const\n+  {\n+    return (type_suffixes[m_memory_type].unsigned_p\n+\t    ? ZERO_EXTEND : SIGN_EXTEND);\n+  }\n+\n+  /* The type of the memory elements.  This is part of the function base\n+     name rather than a true type suffix.  */\n+  type_suffix_index m_memory_type;\n+};\n+\n+/* A function_base that truncates vector elements and stores them to memory.\n+   The memory element width is a fixed part of the function base name.  */\n+class truncating_store : public function_base\n+{\n+public:\n+  CONSTEXPR truncating_store (scalar_int_mode to_mode) : m_to_mode (to_mode) {}\n+\n+  unsigned int\n+  call_properties (const function_instance &) const OVERRIDE\n+  {\n+    return CP_WRITE_MEMORY;\n+  }\n+\n+  tree\n+  memory_scalar_type (const function_instance &fi) const OVERRIDE\n+  {\n+    /* In truncating stores, the signedness of the memory element is defined\n+       to be the same as the signedness of the vector element.  The signedness\n+       doesn't make any difference to the behavior of the function.  */\n+    type_class_index tclass = fi.type_suffix (0).tclass;\n+    unsigned int element_bits = GET_MODE_BITSIZE (m_to_mode);\n+    type_suffix_index suffix = find_type_suffix (tclass, element_bits);\n+    return scalar_types[type_suffixes[suffix].vector_type];\n+  }\n+\n+  machine_mode\n+  memory_vector_mode (const function_instance &fi) const OVERRIDE\n+  {\n+    poly_uint64 nunits = GET_MODE_NUNITS (fi.vector_mode (0));\n+    return aarch64_sve_data_mode (m_to_mode, nunits).require ();\n+  }\n+\n+  /* The mode of a single memory element.  */\n+  scalar_int_mode m_to_mode;\n+};\n+\n+/* A function_base for functions that have an associated rtx code.\n+   It supports all forms of predication except PRED_implicit.  */\n+class rtx_code_function : public function_base\n+{\n+public:\n+  CONSTEXPR rtx_code_function (rtx_code code_for_sint, rtx_code code_for_uint,\n+\t\t\t       int unspec_for_fp = -1)\n+    : m_code_for_sint (code_for_sint), m_code_for_uint (code_for_uint),\n+      m_unspec_for_fp (unspec_for_fp) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return e.map_to_rtx_codes (m_code_for_sint, m_code_for_uint,\n+\t\t\t       m_unspec_for_fp);\n+  }\n+\n+  /* The rtx code to use for signed and unsigned integers respectively.\n+     Can be UNKNOWN for functions that don't have integer forms.  */\n+  rtx_code m_code_for_sint;\n+  rtx_code m_code_for_uint;\n+\n+  /* The UNSPEC_COND_* to use for floating-point operations.  Can be -1\n+     for functions that only operate on integers.  */\n+  int m_unspec_for_fp;\n+};\n+\n+/* Like rtx_code_function, but for functions that take what is normally\n+   the final argument first.  One use of this class is to handle binary\n+   reversed operations; another is to handle MLA-style operations that\n+   are normally expressed in GCC as MAD-style operations.  */\n+class rtx_code_function_rotated : public function_base\n+{\n+public:\n+  CONSTEXPR rtx_code_function_rotated (rtx_code code_for_sint,\n+\t\t\t\t       rtx_code code_for_uint,\n+\t\t\t\t       int unspec_for_fp = -1)\n+    : m_code_for_sint (code_for_sint), m_code_for_uint (code_for_uint),\n+      m_unspec_for_fp (unspec_for_fp) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* Rotate the inputs into their normal order, but continue to make _m\n+       functions merge with what was originally the first vector argument.  */\n+    unsigned int nargs = e.args.length ();\n+    e.rotate_inputs_left (e.pred != PRED_none ? 1 : 0, nargs);\n+    return e.map_to_rtx_codes (m_code_for_sint, m_code_for_uint,\n+\t\t\t       m_unspec_for_fp, nargs - 1);\n+  }\n+\n+  /* The rtx code to use for signed and unsigned integers respectively.\n+     Can be UNKNOWN for functions that don't have integer forms.  */\n+  rtx_code m_code_for_sint;\n+  rtx_code m_code_for_uint;\n+\n+  /* The UNSPEC_COND_* to use for floating-point operations.  Can be -1\n+     for functions that only operate on integers.  */\n+  int m_unspec_for_fp;\n+};\n+\n+/* A function_base for functions that have an associated unspec code.\n+   It supports all forms of predication except PRED_implicit.  */\n+class unspec_based_function : public function_base\n+{\n+public:\n+  CONSTEXPR unspec_based_function (int unspec_for_sint, int unspec_for_uint,\n+\t\t\t\t   int unspec_for_fp)\n+    : m_unspec_for_sint (unspec_for_sint),\n+      m_unspec_for_uint (unspec_for_uint),\n+      m_unspec_for_fp (unspec_for_fp)\n+  {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    return e.map_to_unspecs (m_unspec_for_sint, m_unspec_for_uint,\n+\t\t\t     m_unspec_for_fp);\n+  }\n+\n+  /* The unspec code associated with signed-integer, unsigned-integer\n+     and floating-point operations respectively.  */\n+  int m_unspec_for_sint;\n+  int m_unspec_for_uint;\n+  int m_unspec_for_fp;\n+};\n+\n+/* Like unspec_based_function, but for functions that take what is normally\n+   the final argument first.  One use of this class is to handle binary\n+   reversed operations; another is to handle MLA-style operations that\n+   are normally expressed in GCC as MAD-style operations.  */\n+class unspec_based_function_rotated : public function_base\n+{\n+public:\n+  CONSTEXPR unspec_based_function_rotated (int unspec_for_sint,\n+\t\t\t\t\t   int unspec_for_uint,\n+\t\t\t\t\t   int unspec_for_fp)\n+    : m_unspec_for_sint (unspec_for_sint),\n+      m_unspec_for_uint (unspec_for_uint),\n+      m_unspec_for_fp (unspec_for_fp)\n+  {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* Rotate the inputs into their normal order, but continue to make _m\n+       functions merge with what was originally the first vector argument.  */\n+    unsigned int nargs = e.args.length ();\n+    e.rotate_inputs_left (e.pred != PRED_none ? 1 : 0, nargs);\n+    return e.map_to_unspecs (m_unspec_for_sint, m_unspec_for_uint,\n+\t\t\t     m_unspec_for_fp, nargs - 1);\n+  }\n+\n+  /* The unspec code associated with signed-integer, unsigned-integer\n+     and floating-point operations respectively.  */\n+  int m_unspec_for_sint;\n+  int m_unspec_for_uint;\n+  int m_unspec_for_fp;\n+};\n+\n+/* A function_base for functions that permute their arguments.  */\n+class permute : public quiet<function_base>\n+{\n+public:\n+  /* Fold a unary or binary permute with the permute vector given by\n+     BUILDER.  */\n+  gimple *\n+  fold_permute (const gimple_folder &f, const vec_perm_builder &builder) const\n+  {\n+    /* Punt for now on _b16 and wider; we'd need more complex evpc logic\n+       to rerecognize the result.  */\n+    if (f.type_suffix (0).bool_p && f.type_suffix (0).element_bits > 8)\n+      return NULL;\n+\n+    unsigned int nargs = gimple_call_num_args (f.call);\n+    poly_uint64 nelts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (f.lhs));\n+    vec_perm_indices indices (builder, nargs, nelts);\n+    tree perm_type = build_vector_type (ssizetype, nelts);\n+    return gimple_build_assign (f.lhs, VEC_PERM_EXPR,\n+\t\t\t\tgimple_call_arg (f.call, 0),\n+\t\t\t\tgimple_call_arg (f.call, nargs - 1),\n+\t\t\t\tvec_perm_indices_to_tree (perm_type, indices));\n+  }\n+};\n+\n+/* A function_base for functions that permute two vectors using a fixed\n+   choice of indices.  */\n+class binary_permute : public permute\n+{\n+public:\n+  CONSTEXPR binary_permute (int unspec) : m_unspec (unspec) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    insn_code icode = code_for_aarch64_sve (m_unspec, e.vector_mode (0));\n+    return e.use_exact_insn (icode);\n+  }\n+\n+  /* The unspec code associated with the operation.  */\n+  int m_unspec;\n+};\n+\n+/* A function_base for functions that reduce a vector to a scalar.  */\n+class reduction : public function_base\n+{\n+public:\n+  CONSTEXPR reduction (int unspec)\n+    : m_unspec_for_sint (unspec),\n+      m_unspec_for_uint (unspec),\n+      m_unspec_for_fp (unspec)\n+  {}\n+\n+  CONSTEXPR reduction (int unspec_for_sint, int unspec_for_uint,\n+\t\t       int unspec_for_fp)\n+    : m_unspec_for_sint (unspec_for_sint),\n+      m_unspec_for_uint (unspec_for_uint),\n+      m_unspec_for_fp (unspec_for_fp)\n+  {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    machine_mode mode = e.vector_mode (0);\n+    int unspec = (!e.type_suffix (0).integer_p ? m_unspec_for_fp\n+\t\t  : e.type_suffix (0).unsigned_p ? m_unspec_for_uint\n+\t\t  : m_unspec_for_sint);\n+    /* There's no distinction between SADDV and UADDV for 64-bit elements;\n+       the signed versions only exist for narrower elements.  */\n+    if (GET_MODE_UNIT_BITSIZE (mode) == 64 && unspec == UNSPEC_SADDV)\n+      unspec = UNSPEC_UADDV;\n+    return e.use_exact_insn (code_for_aarch64_pred_reduc (unspec, mode));\n+  }\n+\n+  /* The unspec code associated with signed-integer, unsigned-integer\n+     and floating-point operations respectively.  */\n+  int m_unspec_for_sint;\n+  int m_unspec_for_uint;\n+  int m_unspec_for_fp;\n+};\n+\n+/* A function_base for functions that shift narrower-than-64-bit values\n+   by 64-bit amounts.  */\n+class shift_wide : public function_base\n+{\n+public:\n+  CONSTEXPR shift_wide (rtx_code code, int wide_unspec)\n+    : m_code (code), m_wide_unspec (wide_unspec) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    machine_mode mode = e.vector_mode (0);\n+    machine_mode elem_mode = GET_MODE_INNER (mode);\n+\n+    /* If the argument is a constant that the normal shifts can handle\n+       directly, use them instead.  */\n+    rtx shift = unwrap_const_vec_duplicate (e.args.last ());\n+    if (aarch64_simd_shift_imm_p (shift, elem_mode, m_code == ASHIFT))\n+      {\n+\te.args.last () = shift;\n+\treturn e.map_to_rtx_codes (m_code, m_code, -1);\n+      }\n+\n+    if (e.pred == PRED_x)\n+      return e.use_unpred_insn (code_for_aarch64_sve (m_wide_unspec, mode));\n+\n+    return e.use_cond_insn (code_for_cond (m_wide_unspec, mode));\n+  }\n+\n+  /* The rtx code associated with a \"normal\" shift.  */\n+  rtx_code m_code;\n+\n+  /* The unspec code associated with the wide shift.  */\n+  int m_wide_unspec;\n+};\n+\n+/* A function_base for unary functions that count bits.  */\n+class unary_count : public quiet<function_base>\n+{\n+public:\n+  CONSTEXPR unary_count (rtx_code code) : m_code (code) {}\n+\n+  rtx\n+  expand (function_expander &e) const OVERRIDE\n+  {\n+    /* The md patterns treat the operand as an integer.  */\n+    machine_mode mode = mode_for_int_vector (e.vector_mode (0)).require ();\n+    e.args.last () = gen_lowpart (mode, e.args.last ());\n+\n+    if (e.pred == PRED_x)\n+      return e.use_pred_x_insn (code_for_aarch64_pred (m_code, mode));\n+\n+    return e.use_cond_insn (code_for_cond (m_code, mode));\n+  }\n+\n+  /* The rtx code associated with the operation.  */\n+  rtx_code m_code;\n+};\n+\n+}\n+\n+/* Declare the global function base NAME, creating it from an instance\n+   of class CLASS with constructor arguments ARGS.  */\n+#define FUNCTION(NAME, CLASS, ARGS) \\\n+  namespace { static CONSTEXPR const CLASS NAME##_obj ARGS; } \\\n+  namespace functions { const function_base *const NAME = &NAME##_obj; }\n+\n+#endif"}, {"sha": "6ab233bf15e556a58ce67940d71e17d14bee1ec0", "filename": "gcc/config/aarch64/aarch64-sve-builtins-shapes.cc", "status": "added", "additions": 2236, "deletions": 0, "changes": 2236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-shapes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-shapes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-shapes.cc?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,2236 @@\n+/* ACLE support for AArch64 SVE (function shapes)\n+   Copyright (C) 2018-2019 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"memmodel.h\"\n+#include \"insn-codes.h\"\n+#include \"optabs.h\"\n+#include \"aarch64-sve-builtins.h\"\n+#include \"aarch64-sve-builtins-shapes.h\"\n+\n+/* In the comments below, _t0 represents the first type suffix and _t1\n+   represents the second.  Square brackets enclose characters that are\n+   present in only the full name, not the overloaded name.  Governing\n+   predicate arguments and predicate suffixes are not shown, since they\n+   depend on the predication type, which is a separate piece of\n+   information from the shape.\n+\n+   Non-overloaded functions may have additional suffixes beyond the\n+   ones shown, if those suffixes don't affect the types in the type\n+   signature.  E.g. the predicate form of svtrn1 has a _b<bits> suffix,\n+   but this does not affect the prototype, which is always\n+   \"svbool_t(svbool_t, svbool_t)\".  */\n+\n+namespace aarch64_sve {\n+\n+/* Return a representation of \"const T *\".  */\n+static tree\n+build_const_pointer (tree t)\n+{\n+  return build_pointer_type (build_qualified_type (t, TYPE_QUAL_CONST));\n+}\n+\n+/* If INSTANCE has a governing predicate, add it to the list of argument\n+   types in ARGUMENT_TYPES.  RETURN_TYPE is the type returned by the\n+   function.  */\n+static void\n+apply_predication (const function_instance &instance, tree return_type,\n+\t\t   vec<tree> &argument_types)\n+{\n+  if (instance.pred != PRED_none)\n+    {\n+      argument_types.quick_insert (0, get_svbool_t ());\n+      /* For unary merge operations, the first argument is a vector with\n+\t the same type as the result.  */\n+      if (argument_types.length () == 2 && instance.pred == PRED_m)\n+\targument_types.quick_insert (0, return_type);\n+    }\n+}\n+\n+/* Parse and move past an element type in FORMAT and return it as a type\n+   suffix.  The format is:\n+\n+   [01]    - the element type in type suffix 0 or 1 of INSTANCE\n+   f<bits> - a floating-point type with the given number of bits\n+   f[01]   - a floating-point type with the same width as type suffix 0 or 1\n+   h<elt>  - a half-sized version of <elt>\n+   p       - a predicate (represented as TYPE_SUFFIX_b)\n+   q<elt>  - a quarter-sized version of <elt>\n+   s<bits> - a signed type with the given number of bits\n+   s[01]   - a signed type with the same width as type suffix 0 or 1\n+   u<bits> - an unsigned type with the given number of bits\n+   u[01]   - an unsigned type with the same width as type suffix 0 or 1\n+   w<elt>  - a 64-bit version of <elt> if <elt> is integral, otherwise <elt>\n+\n+   where <elt> is another element type.  */\n+static type_suffix_index\n+parse_element_type (const function_instance &instance, const char *&format)\n+{\n+  int ch = *format++;\n+\n+  if (ch == 'f' || ch == 's' || ch == 'u')\n+    {\n+      type_class_index tclass = (ch == 'f' ? TYPE_float\n+\t\t\t\t : ch == 's' ? TYPE_signed\n+\t\t\t\t : TYPE_unsigned);\n+      char *end;\n+      unsigned int bits = strtol (format, &end, 10);\n+      format = end;\n+      if (bits == 0 || bits == 1)\n+\tbits = instance.type_suffix (bits).element_bits;\n+      return find_type_suffix (tclass, bits);\n+    }\n+\n+  if (ch == 'w')\n+    {\n+      type_suffix_index suffix = parse_element_type (instance, format);\n+      if (type_suffixes[suffix].integer_p)\n+\treturn find_type_suffix (type_suffixes[suffix].tclass, 64);\n+      return suffix;\n+    }\n+\n+  if (ch == 'p')\n+    return TYPE_SUFFIX_b;\n+\n+  if (ch == 'q')\n+    {\n+      type_suffix_index suffix = parse_element_type (instance, format);\n+      return find_type_suffix (type_suffixes[suffix].tclass,\n+\t\t\t       type_suffixes[suffix].element_bits / 4);\n+    }\n+\n+  if (ch == 'h')\n+    {\n+      type_suffix_index suffix = parse_element_type (instance, format);\n+      /* Widening and narrowing doesn't change the type for predicates;\n+\t everything's still an svbool_t.  */\n+      if (suffix == TYPE_SUFFIX_b)\n+\treturn suffix;\n+      return find_type_suffix (type_suffixes[suffix].tclass,\n+\t\t\t       type_suffixes[suffix].element_bits / 2);\n+    }\n+\n+  if (ch == '0' || ch == '1')\n+    return instance.type_suffix_ids[ch - '0'];\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Read and return a type from FORMAT for function INSTANCE.  Advance\n+   FORMAT beyond the type string.  The format is:\n+\n+   _       - void\n+   al      - array pointer for loads\n+   ap      - array pointer for prefetches\n+   as      - array pointer for stores\n+   b       - base vector type (from a _<m0>base suffix)\n+   d       - displacement vector type (from a _<m1>index or _<m1>offset suffix)\n+   e<name> - an enum with the given name\n+   s<elt>  - a scalar type with the given element suffix\n+   t<elt>  - a vector or tuple type with given element suffix [*1]\n+   v<elt>  - a vector with the given element suffix\n+\n+   where <elt> has the format described above parse_element_type\n+\n+   [*1] the vectors_per_tuple function indicates whether the type should\n+        be a tuple, and if so, how many vectors it should contain.  */\n+static tree\n+parse_type (const function_instance &instance, const char *&format)\n+{\n+  int ch = *format++;\n+\n+  if (ch == '_')\n+    return void_type_node;\n+\n+  if (ch == 'a')\n+    {\n+      ch = *format++;\n+      if (ch == 'l')\n+\treturn build_const_pointer (instance.memory_scalar_type ());\n+      if (ch == 'p')\n+\treturn const_ptr_type_node;\n+      if (ch == 's')\n+\treturn build_pointer_type (instance.memory_scalar_type ());\n+      gcc_unreachable ();\n+    }\n+\n+  if (ch == 'b')\n+    return instance.base_vector_type ();\n+\n+  if (ch == 'd')\n+    return instance.displacement_vector_type ();\n+\n+  if (ch == 'e')\n+    {\n+      if (strncmp (format, \"pattern\", 7) == 0)\n+\t{\n+\t  format += 7;\n+\t  return acle_svpattern;\n+\t}\n+      if (strncmp (format, \"prfop\", 5) == 0)\n+\t{\n+\t  format += 5;\n+\t  return acle_svprfop;\n+\t}\n+      gcc_unreachable ();\n+    }\n+\n+  if (ch == 's')\n+    {\n+      type_suffix_index suffix = parse_element_type (instance, format);\n+      return scalar_types[type_suffixes[suffix].vector_type];\n+    }\n+\n+  if (ch == 't')\n+    {\n+      type_suffix_index suffix = parse_element_type (instance, format);\n+      vector_type_index vector_type = type_suffixes[suffix].vector_type;\n+      unsigned int num_vectors = instance.vectors_per_tuple ();\n+      return acle_vector_types[num_vectors - 1][vector_type];\n+    }\n+\n+  if (ch == 'v')\n+    {\n+      type_suffix_index suffix = parse_element_type (instance, format);\n+      return acle_vector_types[0][type_suffixes[suffix].vector_type];\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Read and move past any argument count at FORMAT for the function\n+   signature of INSTANCE.  The counts are:\n+\n+   *q: one argument per element in a 128-bit quadword (as for svdupq)\n+   *t: one argument per vector in a tuple (as for svcreate)\n+\n+   Otherwise the count is 1.  */\n+static unsigned int\n+parse_count (const function_instance &instance, const char *&format)\n+{\n+  if (format[0] == '*' && format[1] == 'q')\n+    {\n+      format += 2;\n+      return instance.elements_per_vq (0);\n+    }\n+  if (format[0] == '*' && format[1] == 't')\n+    {\n+      format += 2;\n+      return instance.vectors_per_tuple ();\n+    }\n+  return 1;\n+}\n+\n+/* Read a type signature for INSTANCE from FORMAT.  Add the argument types\n+   to ARGUMENT_TYPES and return the return type.\n+\n+   The format is a comma-separated list of types (as for parse_type),\n+   with the first type being the return type and the rest being the\n+   argument types.  Each argument type can be followed by an optional\n+   count (as for parse_count).  */\n+static tree\n+parse_signature (const function_instance &instance, const char *format,\n+\t\t vec<tree> &argument_types)\n+{\n+  tree return_type = parse_type (instance, format);\n+  while (format[0] == ',')\n+    {\n+      format += 1;\n+      tree argument_type = parse_type (instance, format);\n+      unsigned int count = parse_count (instance, format);\n+      for (unsigned int i = 0; i < count; ++i)\n+\targument_types.quick_push (argument_type);\n+    }\n+  gcc_assert (format[0] == 0);\n+  return return_type;\n+}\n+\n+/* Add one function instance for GROUP, using mode suffix MODE_SUFFIX_ID,\n+   the type suffixes at index TI and the predication suffix at index PI.\n+   The other arguments are as for build_all.  */\n+static void\n+build_one (function_builder &b, const char *signature,\n+\t   const function_group_info &group, mode_suffix_index mode_suffix_id,\n+\t   unsigned int ti, unsigned int pi, bool force_direct_overloads)\n+{\n+  /* Byte forms of svdupq take 16 arguments.  */\n+  auto_vec<tree, 16> argument_types;\n+  function_instance instance (group.base_name, *group.base, *group.shape,\n+\t\t\t      mode_suffix_id, group.types[ti],\n+\t\t\t      group.preds[pi]);\n+  tree return_type = parse_signature (instance, signature, argument_types);\n+  apply_predication (instance, return_type, argument_types);\n+  b.add_unique_function (instance, return_type, argument_types,\n+\t\t\t group.required_extensions, force_direct_overloads);\n+}\n+\n+/* Add a function instance for every type and predicate combination\n+   in GROUP, which describes some sort of gather or scatter operation.\n+   If the function has any type suffixes (as for loads and stores),\n+   the first function type suffix specifies either a 32-bit or a 64-bit\n+   type; use MODE32 for the former and MODE64 for the latter.  If the\n+   function has no type suffixes (as for prefetches), add one MODE32 form\n+   and one MODE64 form for each predication type.\n+\n+   The other arguments are as for build_all.  */\n+static void\n+build_32_64 (function_builder &b, const char *signature,\n+\t     const function_group_info &group, mode_suffix_index mode32,\n+\t     mode_suffix_index mode64, bool force_direct_overloads = false)\n+{\n+  for (unsigned int pi = 0; group.preds[pi] != NUM_PREDS; ++pi)\n+    if (group.types[0][0] == NUM_TYPE_SUFFIXES)\n+      {\n+\tbuild_one (b, signature, group, mode32, 0, pi,\n+\t\t   force_direct_overloads);\n+\tbuild_one (b, signature, group, mode64, 0, pi,\n+\t\t   force_direct_overloads);\n+      }\n+    else\n+      for (unsigned int ti = 0; group.types[ti][0] != NUM_TYPE_SUFFIXES; ++ti)\n+\t{\n+\t  unsigned int bits = type_suffixes[group.types[ti][0]].element_bits;\n+\t  gcc_assert (bits == 32 || bits == 64);\n+\t  mode_suffix_index mode = bits == 32 ? mode32 : mode64;\n+\t  build_one (b, signature, group, mode, ti, pi,\n+\t\t     force_direct_overloads);\n+\t}\n+}\n+\n+/* For every type and predicate combination in GROUP, add one function\n+   that takes a scalar (pointer) base and a signed vector array index,\n+   and another that instead takes an unsigned vector array index.\n+   The vector array index has the same element size as the first\n+   function type suffix.  SIGNATURE is as for build_all.  */\n+static void\n+build_sv_index (function_builder &b, const char *signature,\n+\t\tconst function_group_info &group)\n+{\n+  build_32_64 (b, signature, group, MODE_s32index, MODE_s64index);\n+  build_32_64 (b, signature, group, MODE_u32index, MODE_u64index);\n+}\n+\n+/* Like build_sv_index, but taking vector byte offsets instead of vector\n+   array indices.  */\n+static void\n+build_sv_offset (function_builder &b, const char *signature,\n+\t\t const function_group_info &group)\n+{\n+  build_32_64 (b, signature, group, MODE_s32offset, MODE_s64offset);\n+  build_32_64 (b, signature, group, MODE_u32offset, MODE_u64offset);\n+}\n+\n+/* For every type and predicate combination in GROUP, add a function\n+   that takes a vector base address and no displacement.  The vector\n+   base has the same element size as the first type suffix.\n+\n+   The other arguments are as for build_all.  */\n+static void\n+build_v_base (function_builder &b, const char *signature,\n+\t      const function_group_info &group,\n+\t      bool force_direct_overloads = false)\n+{\n+  build_32_64 (b, signature, group, MODE_u32base, MODE_u64base,\n+\t       force_direct_overloads);\n+}\n+\n+/* Like build_v_base, but for functions that also take a scalar array\n+   index.  */\n+static void\n+build_vs_index (function_builder &b, const char *signature,\n+\t\tconst function_group_info &group,\n+\t\tbool force_direct_overloads = false)\n+{\n+  build_32_64 (b, signature, group, MODE_u32base_index, MODE_u64base_index,\n+\t       force_direct_overloads);\n+}\n+\n+/* Like build_v_base, but for functions that also take a scalar byte\n+   offset.  */\n+static void\n+build_vs_offset (function_builder &b, const char *signature,\n+\t\t const function_group_info &group,\n+\t\t bool force_direct_overloads = false)\n+{\n+  build_32_64 (b, signature, group, MODE_u32base_offset, MODE_u64base_offset,\n+\t       force_direct_overloads);\n+}\n+\n+/* Add a function instance for every type and predicate combination\n+   in GROUP.  Take the function base name from GROUP and the mode suffix\n+   from MODE_SUFFIX_ID.  Use SIGNATURE to construct the function signature\n+   without a governing predicate, then use apply_predication to add in the\n+   predicate.  FORCE_DIRECT_OVERLOADS is true if there is a one-to-one\n+   mapping between \"short\" and \"full\" names, and if standard overload\n+   resolution therefore isn't necessary.  */\n+static void\n+build_all (function_builder &b, const char *signature,\n+\t   const function_group_info &group, mode_suffix_index mode_suffix_id,\n+\t   bool force_direct_overloads = false)\n+{\n+  for (unsigned int pi = 0; group.preds[pi] != NUM_PREDS; ++pi)\n+    for (unsigned int ti = 0;\n+\t ti == 0 || group.types[ti][0] != NUM_TYPE_SUFFIXES; ++ti)\n+      build_one (b, signature, group, mode_suffix_id, ti, pi,\n+\t\t force_direct_overloads);\n+}\n+\n+/* Declare the function shape NAME, pointing it to an instance\n+   of class <NAME>_def.  */\n+#define SHAPE(NAME) \\\n+  static CONSTEXPR const NAME##_def NAME##_obj; \\\n+  namespace shapes { const function_shape *const NAME = &NAME##_obj; }\n+\n+/* Base class for functions that are not overloaded.  */\n+struct nonoverloaded_base : public function_shape\n+{\n+  bool\n+  explicit_type_suffix_p (unsigned int) const OVERRIDE\n+  {\n+    return true;\n+  }\n+\n+  tree\n+  resolve (function_resolver &) const OVERRIDE\n+  {\n+    gcc_unreachable ();\n+  }\n+};\n+\n+/* Base class for overloaded functions.  Bit N of EXPLICIT_MASK is true\n+   if type suffix N appears in the overloaded name.  */\n+template<unsigned int EXPLICIT_MASK>\n+struct overloaded_base : public function_shape\n+{\n+  bool\n+  explicit_type_suffix_p (unsigned int i) const OVERRIDE\n+  {\n+    return (EXPLICIT_MASK >> i) & 1;\n+  }\n+};\n+\n+/* Base class for adr_index and adr_offset.  */\n+struct adr_base : public overloaded_base<0>\n+{\n+  /* The function takes two arguments: a vector base and a vector displacement\n+     (either an index or an offset).  Resolve based on them both.  */\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    mode_suffix_index mode;\n+    if (!r.check_gp_argument (2, i, nargs)\n+\t|| (mode = r.resolve_adr_address (0)) == MODE_none)\n+      return error_mark_node;\n+\n+    return r.resolve_to (mode);\n+  };\n+};\n+\n+/* Base class for inc_dec and inc_dec_pat.  */\n+struct inc_dec_base : public overloaded_base<0>\n+{\n+  CONSTEXPR inc_dec_base (bool pat_p) : m_pat_p (pat_p) {}\n+\n+  /* Resolve based on the first argument only, which must be either a\n+     scalar or a vector.  If it's a scalar, it must be a 32-bit or\n+     64-bit integer.  */\n+  tree\n+  resolve (function_resolver &r) const\n+  {\n+    unsigned int i, nargs;\n+    if (!r.check_gp_argument (m_pat_p ? 3 : 2, i, nargs)\n+\t|| !r.require_vector_or_scalar_type (i))\n+      return error_mark_node;\n+\n+    mode_suffix_index mode;\n+    type_suffix_index type;\n+    if (r.scalar_argument_p (i))\n+      {\n+\tmode = MODE_n;\n+\ttype = r.infer_integer_scalar_type (i);\n+      }\n+    else\n+      {\n+\tmode = MODE_none;\n+\ttype = r.infer_vector_type (i);\n+      }\n+    if (type == NUM_TYPE_SUFFIXES)\n+      return error_mark_node;\n+\n+    for (++i; i < nargs; ++i)\n+      if (!r.require_integer_immediate (i))\n+\treturn error_mark_node;\n+\n+    return r.resolve_to (mode, type);\n+  }\n+\n+  bool\n+  check (function_checker &c) const OVERRIDE\n+  {\n+    return c.require_immediate_range (m_pat_p ? 2 : 1, 1, 16);\n+  }\n+\n+  bool m_pat_p;\n+};\n+\n+/* Base class for load and load_replicate.  */\n+struct load_contiguous_base : public overloaded_base<0>\n+{\n+  /* Resolve a call based purely on a pointer argument.  The other arguments\n+     are a governing predicate and (for MODE_vnum) a vnum offset.  */\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    bool vnum_p = r.mode_suffix_id == MODE_vnum;\n+    gcc_assert (r.mode_suffix_id == MODE_none || vnum_p);\n+\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (vnum_p ? 2 : 1, i, nargs)\n+\t|| (type = r.infer_pointer_type (i)) == NUM_TYPE_SUFFIXES\n+\t|| (vnum_p && !r.require_scalar_type (i + 1, \"int64_t\")))\n+      return error_mark_node;\n+\n+    return r.resolve_to (r.mode_suffix_id, type);\n+  }\n+};\n+\n+/* Base class for load_ext_gather_index and load_ext_gather_offset,\n+   which differ only in the units of the displacement.  */\n+struct load_ext_gather_base : public overloaded_base<1>\n+{\n+  /* Resolve a gather load that takes one of:\n+\n+     - a scalar pointer base and a vector displacement\n+     - a vector base with no displacement or\n+     - a vector base and a scalar displacement\n+\n+     The function has an explicit type suffix that determines the type\n+     of the loaded data.  */\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    /* No resolution is needed for a vector base with no displacement;\n+       there's a one-to-one mapping between short and long names.  */\n+    gcc_assert (r.displacement_units () != UNITS_none);\n+\n+    type_suffix_index type = r.type_suffix_ids[0];\n+\n+    unsigned int i, nargs;\n+    mode_suffix_index mode;\n+    if (!r.check_gp_argument (2, i, nargs)\n+\t|| (mode = r.resolve_gather_address (i, type, true)) == MODE_none)\n+      return error_mark_node;\n+\n+    return r.resolve_to (mode, type);\n+  }\n+};\n+\n+/* Base class for prefetch_gather_index and prefetch_gather_offset,\n+   which differ only in the units of the displacement.  */\n+struct prefetch_gather_base : public overloaded_base<0>\n+{\n+  /* Resolve a gather prefetch that takes one of:\n+\n+     - a scalar pointer base (const void *) and a vector displacement\n+     - a vector base with no displacement or\n+     - a vector base and a scalar displacement\n+\n+     The prefetch operation is the final argument.  This is purely a\n+     mode-based resolution; there are no type suffixes.  */\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    bool has_displacement_p = r.displacement_units () != UNITS_none;\n+\n+    unsigned int i, nargs;\n+    mode_suffix_index mode;\n+    if (!r.check_gp_argument (has_displacement_p ? 3 : 2, i, nargs)\n+\t|| (mode = r.resolve_gather_address (i, NUM_TYPE_SUFFIXES,\n+\t\t\t\t\t     false)) == MODE_none\n+\t|| !r.require_integer_immediate (nargs - 1))\n+      return error_mark_node;\n+\n+    return r.resolve_to (mode);\n+  }\n+};\n+\n+/* Base class for store_scatter_index and store_scatter_offset,\n+   which differ only in the units of the displacement.  */\n+struct store_scatter_base : public overloaded_base<0>\n+{\n+  /* Resolve a scatter store that takes one of:\n+\n+     - a scalar pointer base and a vector displacement\n+     - a vector base with no displacement or\n+     - a vector base and a scalar displacement\n+\n+     The stored data is the final argument, and it determines the\n+     type suffix.  */\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    bool has_displacement_p = r.displacement_units () != UNITS_none;\n+\n+    unsigned int i, nargs;\n+    mode_suffix_index mode;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (has_displacement_p ? 3 : 2, i, nargs)\n+\t|| (type = r.infer_sd_vector_type (nargs - 1)) == NUM_TYPE_SUFFIXES\n+\t|| (mode = r.resolve_gather_address (i, type, false)) == MODE_none)\n+      return error_mark_node;\n+\n+    return r.resolve_to (mode, type);\n+  }\n+};\n+\n+/* sv<m0>_t svfoo[_m0base]_[m1]index(sv<m0>_t, sv<m1>_t)\n+\n+   for all valid combinations of vector base type <m0> and vector\n+   displacement type <m1>.  */\n+struct adr_index_def : public adr_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_index);\n+    build_all (b, \"b,b,d\", group, MODE_u32base_s32index);\n+    build_all (b, \"b,b,d\", group, MODE_u32base_u32index);\n+    build_all (b, \"b,b,d\", group, MODE_u64base_s64index);\n+    build_all (b, \"b,b,d\", group, MODE_u64base_u64index);\n+  }\n+};\n+SHAPE (adr_index)\n+\n+/* sv<m0>_t svfoo[_m0base]_[m1]offset(sv<m0>_t, sv<m1>_t).\n+\n+   for all valid combinations of vector base type <m0> and vector\n+   displacement type <m1>.  */\n+struct adr_offset_def : public adr_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_offset);\n+    build_all (b, \"b,b,d\", group, MODE_u32base_s32offset);\n+    build_all (b, \"b,b,d\", group, MODE_u32base_u32offset);\n+    build_all (b, \"b,b,d\", group, MODE_u64base_s64offset);\n+    build_all (b, \"b,b,d\", group, MODE_u64base_u64offset);\n+  }\n+};\n+SHAPE (adr_offset)\n+\n+/* sv<t0>_t svfoo[_t0](sv<t0>_t, sv<t0>_t)\n+\n+   i.e. a binary operation with uniform types, but with no scalar form.  */\n+struct binary_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,v0\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    return r.resolve_uniform (2);\n+  }\n+};\n+SHAPE (binary)\n+\n+/* sv<t0>_t svfoo[_t0](sv<t0>_t, sv<t0:int>_t)\n+   sv<t0>_t svfoo[_n_t0](sv<t0>_t, <t0:int>_t).\n+\n+   i.e. a version of the standard binary shape binary_opt_n in which\n+   the final argument is always a signed integer.  */\n+struct binary_int_opt_n_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,vs0\", group, MODE_none);\n+    build_all (b, \"v0,v0,ss0\", group, MODE_n);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (2, i, nargs)\n+\t|| (type = r.infer_vector_type (i)) == NUM_TYPE_SUFFIXES)\n+      return error_mark_node;\n+\n+    return r.finish_opt_n_resolution (i + 1, i, type, TYPE_signed);\n+  }\n+};\n+SHAPE (binary_int_opt_n)\n+\n+/* sv<t0>_t svfoo_<t0>(sv<t0>_t, sv<t0>_t, uint64_t)\n+\n+   where the final argument is an integer constant expression in the\n+   range [0, 16 / sizeof (<t0>_t) - 1].  */\n+struct binary_lane_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,v0,su64\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    return r.resolve_uniform (2, 1);\n+  }\n+\n+  bool\n+  check (function_checker &c) const OVERRIDE\n+  {\n+    return c.require_immediate_lane_index (2);\n+  }\n+};\n+SHAPE (binary_lane)\n+\n+/* sv<t0>_t svfoo[_n_t0](sv<t0>_t, <t0>_t).\n+\n+   i.e. a binary operation in which the final argument is always a scalar\n+   rather than a vector.  */\n+struct binary_n_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_n);\n+    build_all (b, \"v0,v0,s0\", group, MODE_n);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (2, i, nargs)\n+\t|| (type = r.infer_vector_type (i)) == NUM_TYPE_SUFFIXES\n+\t|| !r.require_derived_scalar_type (i + 1, r.SAME_TYPE_CLASS))\n+      return error_mark_node;\n+\n+    return r.resolve_to (r.mode_suffix_id, type);\n+  }\n+};\n+SHAPE (binary_n)\n+\n+/* sv<t0>_t svfoo[_t0](sv<t0>_t, sv<t0>_t)\n+   sv<t0>_t svfoo[_n_t0](sv<t0>_t, <t0>_t)\n+\n+   i.e. the standard shape for binary operations that operate on\n+   uniform types.  */\n+struct binary_opt_n_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,v0\", group, MODE_none);\n+    /* _b functions do not have an _n form, but are classified as\n+       binary_opt_n so that they can be overloaded with vector\n+       functions.  */\n+    if (group.types[0][0] == TYPE_SUFFIX_b)\n+      gcc_assert (group.types[0][1] == NUM_TYPE_SUFFIXES);\n+    else\n+      build_all (b, \"v0,v0,s0\", group, MODE_n);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    return r.resolve_uniform_opt_n (2);\n+  }\n+};\n+SHAPE (binary_opt_n)\n+\n+/* svbool_t svfoo(svbool_t, svbool_t).  */\n+struct binary_pred_def : public nonoverloaded_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    build_all (b, \"v0,v0,v0\", group, MODE_none);\n+  }\n+};\n+SHAPE (binary_pred)\n+\n+/* sv<t0>_t svfoo[_<t0>](sv<t0>_t, sv<t0>_t, uint64_t)\n+\n+   where the final argument must be 90 or 270.  */\n+struct binary_rotate_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,v0,su64\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    return r.resolve_uniform (2, 1);\n+  }\n+\n+  bool\n+  check (function_checker &c) const OVERRIDE\n+  {\n+    return c.require_immediate_either_or (2, 90, 270);\n+  }\n+};\n+SHAPE (binary_rotate)\n+\n+/* sv<t0>_t svfoo_t0(<t0>_t, <t0>_t)\n+\n+   i.e. a binary function that takes two scalars and returns a vector.\n+   An explicit type suffix is required.  */\n+struct binary_scalar_def : public nonoverloaded_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    build_all (b, \"v0,s0,s0\", group, MODE_none);\n+  }\n+};\n+SHAPE (binary_scalar)\n+\n+/* sv<t0>_t svfoo[_t0](sv<t0>_t, sv<t0:uint>_t)\n+\n+   i.e. a version of \"binary\" in which the final argument is always an\n+   unsigned integer.  */\n+struct binary_uint_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,vu0\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (2, i, nargs)\n+\t|| (type = r.infer_vector_type (i)) == NUM_TYPE_SUFFIXES\n+\t|| !r.require_derived_vector_type (i + 1, i, type, TYPE_unsigned))\n+      return error_mark_node;\n+\n+    return r.resolve_to (r.mode_suffix_id, type);\n+  }\n+};\n+SHAPE (binary_uint)\n+\n+/* sv<t0>_t svfoo[_t0](sv<t0>_t, <t0:uint>_t)\n+\n+   i.e. a version of binary_n in which the final argument is always an\n+   unsigned integer.  */\n+struct binary_uint_n_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,su0\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (2, i, nargs)\n+\t|| (type = r.infer_vector_type (i)) == NUM_TYPE_SUFFIXES\n+\t|| !r.require_derived_scalar_type (i + 1, TYPE_unsigned))\n+      return error_mark_node;\n+\n+    return r.resolve_to (r.mode_suffix_id, type);\n+  }\n+};\n+SHAPE (binary_uint_n)\n+\n+/* sv<t0>_t svfoo[_t0](sv<t0>_t, sv<t0:uint>_t)\n+   sv<t0>_t svfoo[_n_t0](sv<t0>_t, <t0:uint>_t)\n+\n+   i.e. a version of the standard binary shape binary_opt_n in which\n+   the final argument is always an unsigned integer.  */\n+struct binary_uint_opt_n_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,vu0\", group, MODE_none);\n+    build_all (b, \"v0,v0,su0\", group, MODE_n);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (2, i, nargs)\n+\t|| (type = r.infer_vector_type (i)) == NUM_TYPE_SUFFIXES)\n+      return error_mark_node;\n+\n+    return r.finish_opt_n_resolution (i + 1, i, type, TYPE_unsigned);\n+  }\n+};\n+SHAPE (binary_uint_opt_n)\n+\n+/* sv<t0>_t svfoo[_t0](sv<t0>_t, uint64_t).\n+\n+   i.e. a version of binary_n in which the final argument is always\n+   a 64-bit unsigned integer.  */\n+struct binary_uint64_n_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,su64\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (2, i, nargs)\n+\t|| (type = r.infer_vector_type (i)) == NUM_TYPE_SUFFIXES\n+\t|| !r.require_scalar_type (i + 1, \"uint64_t\"))\n+      return error_mark_node;\n+\n+    return r.resolve_to (r.mode_suffix_id, type);\n+  }\n+};\n+SHAPE (binary_uint64_n)\n+\n+/* sv<t0>_t svfoo[_t0](sv<t0>_t, svuint64_t)\n+   sv<t0>_t svfoo[_n_t0](sv<t0>_t, uint64_t)\n+\n+   i.e. a version of the standard binary shape binary_opt_n in which\n+   the final argument is always a uint64_t.  */\n+struct binary_uint64_opt_n_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,vu64\", group, MODE_none);\n+    build_all (b, \"v0,v0,su64\", group, MODE_n);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (2, i, nargs)\n+\t|| (type = r.infer_vector_type (i)) == NUM_TYPE_SUFFIXES)\n+      return error_mark_node;\n+\n+    return r.finish_opt_n_resolution (i + 1, i, type, TYPE_unsigned, 64);\n+  }\n+};\n+SHAPE (binary_uint64_opt_n)\n+\n+/* sv<t0>_t svfoo[_t0](sv<t0>_t, sv<t0>_t)\n+   <t0>_t svfoo[_n_t0](<t0>_t, sv<t0>_t).  */\n+struct clast_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,v0\", group, MODE_none);\n+    build_all (b, \"s0,s0,v0\", group, MODE_n);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    if (!r.check_gp_argument (2, i, nargs)\n+\t|| !r.require_vector_or_scalar_type (i))\n+      return error_mark_node;\n+\n+    if (r.scalar_argument_p (i))\n+      {\n+\ttype_suffix_index type;\n+\tif (!r.require_derived_scalar_type (i, r.SAME_TYPE_CLASS)\n+\t    || (type = r.infer_vector_type (i + 1)) == NUM_TYPE_SUFFIXES)\n+\t  return error_mark_node;\n+\treturn r.resolve_to (MODE_n, type);\n+      }\n+    else\n+      {\n+\ttype_suffix_index type;\n+\tif ((type = r.infer_vector_type (i)) == NUM_TYPE_SUFFIXES\n+\t    || !r.require_matching_vector_type (i + 1, type))\n+\t  return error_mark_node;\n+\treturn r.resolve_to (MODE_none, type);\n+      }\n+  }\n+};\n+SHAPE (clast)\n+\n+/* svbool_t svfoo[_t0](sv<t0>_t, sv<t0>_t)\n+   svbool_t svfoo[_n_t0](sv<t0>_t, <t0>_t)\n+\n+   i.e. a comparison between two vectors, or between a vector and a scalar.  */\n+struct compare_opt_n_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"vp,v0,v0\", group, MODE_none);\n+    build_all (b, \"vp,v0,s0\", group, MODE_n);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    return r.resolve_uniform_opt_n (2);\n+  }\n+};\n+SHAPE (compare_opt_n)\n+\n+/* svbool_t svfoo_t0[_t1](<t1>_t, <t1>_t)\n+\n+   where _t0 is a _b<bits> suffix that describes the predicate result.\n+   There is no direct relationship between the element sizes of _t0\n+   and _t1.  */\n+struct compare_scalar_def : public overloaded_base<1>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"vp,s1,s1\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (2, i, nargs)\n+\t|| (type = r.infer_integer_scalar_type (i)) == NUM_TYPE_SUFFIXES\n+\t|| !r.require_matching_integer_scalar_type (i + 1, i, type))\n+      return error_mark_node;\n+\n+    return r.resolve_to (r.mode_suffix_id, r.type_suffix_ids[0], type);\n+  }\n+};\n+SHAPE (compare_scalar)\n+\n+/* svbool_t svfoo[_t0](sv<t0>_t, svint64_t)  (for signed t0)\n+   svbool_t svfoo[_n_t0](sv<t0>_t, int64_t)  (for signed t0)\n+   svbool_t svfoo[_t0](sv<t0>_t, svuint64_t)  (for unsigned t0)\n+   svbool_t svfoo[_n_t0](sv<t0>_t, uint64_t)  (for unsigned t0)\n+\n+   i.e. a comparison in which the second argument is 64 bits.  */\n+struct compare_wide_opt_n_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"vp,v0,vw0\", group, MODE_none);\n+    build_all (b, \"vp,v0,sw0\", group, MODE_n);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (2, i, nargs)\n+\t|| (type = r.infer_vector_type (i)) == NUM_TYPE_SUFFIXES)\n+      return error_mark_node;\n+\n+    return r.finish_opt_n_resolution (i + 1, i, type, r.SAME_TYPE_CLASS, 64);\n+  }\n+};\n+SHAPE (compare_wide_opt_n)\n+\n+/* uint64_t svfoo().  */\n+struct count_inherent_def : public nonoverloaded_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    build_all (b, \"su64\", group, MODE_none);\n+  }\n+};\n+SHAPE (count_inherent)\n+\n+/* uint64_t svfoo(enum svpattern).  */\n+struct count_pat_def : public nonoverloaded_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    build_all (b, \"su64,epattern\", group, MODE_none);\n+  }\n+};\n+SHAPE (count_pat)\n+\n+/* uint64_t svfoo(svbool_t).  */\n+struct count_pred_def : public nonoverloaded_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    build_all (b, \"su64,vp\", group, MODE_none);\n+  }\n+};\n+SHAPE (count_pred)\n+\n+/* uint64_t svfoo[_t0](sv<t0>_t).  */\n+struct count_vector_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"su64,v0\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    return r.resolve_uniform (1);\n+  }\n+};\n+SHAPE (count_vector)\n+\n+/* sv<t0>xN_t svfoo[_t0](sv<t0>_t, ..., sv<t0>_t)\n+\n+   where there are N arguments in total.  */\n+struct create_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"t0,v0*t\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    return r.resolve_uniform (r.vectors_per_tuple ());\n+  }\n+};\n+SHAPE (create)\n+\n+/* sv<t0>_t svfoo[_n]_t0(<t0>_t, ..., <t0>_t)\n+\n+   where there are enough arguments to fill 128 bits of data (or to\n+   control 128 bits of data in the case of predicates).  */\n+struct dupq_def : public overloaded_base<1>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    /* The \"_n\" suffix is optional; the full name has it, but the short\n+       name doesn't.  */\n+    build_all (b, \"v0,s0*q\", group, MODE_n, true);\n+  }\n+\n+  tree\n+  resolve (function_resolver &) const OVERRIDE\n+  {\n+    /* The short forms just make \"_n\" implicit, so no resolution is needed.  */\n+    gcc_unreachable ();\n+  }\n+};\n+SHAPE (dupq)\n+\n+/* sv<t0>_t svfoo[_t0](sv<t0>_t, sv<t0>_t, uint64_t)\n+\n+   where the final argument is an integer constant expression that when\n+   multiplied by the number of bytes in t0 is in the range [0, 255].  */\n+struct ext_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,v0,su64\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    return r.resolve_uniform (2, 1);\n+  }\n+\n+  bool\n+  check (function_checker &c) const OVERRIDE\n+  {\n+    unsigned int bytes = c.type_suffix (0).element_bytes;\n+    return c.require_immediate_range (2, 0, 256 / bytes - 1);\n+  }\n+};\n+SHAPE (ext)\n+\n+/* <t0>_t svfoo[_t0](<t0>_t, sv<t0>_t).  */\n+struct fold_left_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"s0,s0,v0\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (2, i, nargs)\n+\t|| !r.require_derived_scalar_type (i, r.SAME_TYPE_CLASS)\n+\t|| (type = r.infer_vector_type (i + 1)) == NUM_TYPE_SUFFIXES)\n+      return error_mark_node;\n+\n+    return r.resolve_to (r.mode_suffix_id, type);\n+  }\n+};\n+SHAPE (fold_left)\n+\n+/* sv<t0>_t svfoo[_t0](sv<t0>xN_t, uint64_t)\n+\n+   where the final argument is an integer constant expression in\n+   the range [0, N - 1].  */\n+struct get_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,t0,su64\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (2, i, nargs)\n+\t|| (type = r.infer_tuple_type (i)) == NUM_TYPE_SUFFIXES\n+\t|| !r.require_integer_immediate (i + 1))\n+      return error_mark_node;\n+\n+    return r.resolve_to (r.mode_suffix_id, type);\n+  }\n+\n+  bool\n+  check (function_checker &c) const OVERRIDE\n+  {\n+    unsigned int nvectors = c.vectors_per_tuple ();\n+    return c.require_immediate_range (1, 0, nvectors - 1);\n+  }\n+};\n+SHAPE (get)\n+\n+/* sv<t0>_t svfoo[_t0](sv<t0>_t, uint64_t)\n+   <t0>_t svfoo[_n_t0](<t0>_t, uint64_t)\n+\n+   where the t0 in the vector form is a signed or unsigned integer\n+   whose size is tied to the [bhwd] suffix of \"svfoo\".  */\n+struct inc_dec_def : public inc_dec_base\n+{\n+  CONSTEXPR inc_dec_def () : inc_dec_base (false) {}\n+\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    /* These functions are unusual in that the type suffixes for\n+       the scalar and vector forms are not related.  The vector\n+       form always has exactly two potential suffixes while the\n+       scalar form always has four.  */\n+    if (group.types[2][0] == NUM_TYPE_SUFFIXES)\n+      build_all (b, \"v0,v0,su64\", group, MODE_none);\n+    else\n+      build_all (b, \"s0,s0,su64\", group, MODE_n);\n+  }\n+};\n+SHAPE (inc_dec)\n+\n+/* sv<t0>_t svfoo[_t0](sv<t0>_t, enum svpattern, uint64_t)\n+   <t0>_t svfoo[_n_t0](<t0>_t, enum svpattern, uint64_t)\n+\n+   where the t0 in the vector form is a signed or unsigned integer\n+   whose size is tied to the [bhwd] suffix of \"svfoo\".  */\n+struct inc_dec_pat_def : public inc_dec_base\n+{\n+  CONSTEXPR inc_dec_pat_def () : inc_dec_base (true) {}\n+\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    /* These functions are unusual in that the type suffixes for\n+       the scalar and vector forms are not related.  The vector\n+       form always has exactly two potential suffixes while the\n+       scalar form always has four.  */\n+    if (group.types[2][0] == NUM_TYPE_SUFFIXES)\n+      build_all (b, \"v0,v0,epattern,su64\", group, MODE_none);\n+    else\n+      build_all (b, \"s0,s0,epattern,su64\", group, MODE_n);\n+  }\n+};\n+SHAPE (inc_dec_pat)\n+\n+/* sv<t0>_t svfoo[_t0](sv<t0>_t, svbool_t).  */\n+struct inc_dec_pred_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,vp\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (2, i, nargs)\n+\t|| (type = r.infer_vector_type (i)) == NUM_TYPE_SUFFIXES\n+\t|| !r.require_vector_type (i + 1, VECTOR_TYPE_svbool_t))\n+      return error_mark_node;\n+\n+    return r.resolve_to (r.mode_suffix_id, type);\n+  }\n+};\n+SHAPE (inc_dec_pred)\n+\n+/* <t0>_t svfoo[_n_t0]_t1(<t0>_t, svbool_t)\n+\n+   where _t1 is a _b<bits> suffix that describes the svbool_t argument.  */\n+struct inc_dec_pred_scalar_def : public overloaded_base<2>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_n);\n+    build_all (b, \"s0,s0,vp\", group, MODE_n);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (2, i, nargs)\n+\t|| (type = r.infer_integer_scalar_type (i)) == NUM_TYPE_SUFFIXES\n+\t|| !r.require_vector_type (i + 1, VECTOR_TYPE_svbool_t))\n+      return error_mark_node;\n+\n+    return r.resolve_to (r.mode_suffix_id, type, r.type_suffix_ids[1]);\n+  }\n+};\n+SHAPE (inc_dec_pred_scalar)\n+\n+/* sv<t0>[xN]_t svfoo_t0().  */\n+struct inherent_def : public nonoverloaded_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    build_all (b, \"t0\", group, MODE_none);\n+  }\n+};\n+SHAPE (inherent)\n+\n+/* svbool_t svfoo[_b]().  */\n+struct inherent_b_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    /* The \"_b\" suffix is optional; the full name has it, but the short\n+       name doesn't.  */\n+    build_all (b, \"v0\", group, MODE_none, true);\n+  }\n+\n+  tree\n+  resolve (function_resolver &) const OVERRIDE\n+  {\n+    /* The short forms just make \"_b\" implicit, so no resolution is needed.  */\n+    gcc_unreachable ();\n+  }\n+};\n+SHAPE (inherent_b)\n+\n+/* sv<t0>[xN]_t svfoo[_t0](const <t0>_t *)\n+   sv<t0>[xN]_t svfoo_vnum[_t0](const <t0>_t *, int64_t).  */\n+struct load_def : public load_contiguous_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    b.add_overloaded_functions (group, MODE_vnum);\n+    build_all (b, \"t0,al\", group, MODE_none);\n+    build_all (b, \"t0,al,ss64\", group, MODE_vnum);\n+  }\n+};\n+SHAPE (load)\n+\n+/* sv<t0>_t svfoo_t0(const <X>_t *)\n+   sv<t0>_t svfoo_vnum_t0(const <X>_t *, int64_t)\n+\n+   where <X> is determined by the function base name.  */\n+struct load_ext_def : public nonoverloaded_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    build_all (b, \"t0,al\", group, MODE_none);\n+    build_all (b, \"t0,al,ss64\", group, MODE_vnum);\n+  }\n+};\n+SHAPE (load_ext)\n+\n+/* sv<t0>_t svfoo_[s32]index_t0(const <X>_t *, svint32_t)\n+   sv<t0>_t svfoo_[s64]index_t0(const <X>_t *, svint64_t)\n+   sv<t0>_t svfoo_[u32]index_t0(const <X>_t *, svuint32_t)\n+   sv<t0>_t svfoo_[u64]index_t0(const <X>_t *, svuint64_t)\n+\n+   sv<t0>_t svfoo[_u32base]_index_t0(svuint32_t, int64_t)\n+   sv<t0>_t svfoo[_u64base]_index_t0(svuint64_t, int64_t)\n+\n+   where <X> is determined by the function base name.  */\n+struct load_ext_gather_index_def : public load_ext_gather_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_index);\n+    build_sv_index (b, \"t0,al,d\", group);\n+    build_vs_index (b, \"t0,b,ss64\", group);\n+  }\n+};\n+SHAPE (load_ext_gather_index)\n+\n+/* sv<t0>_t svfoo_[s32]offset_t0(const <X>_t *, svint32_t)\n+   sv<t0>_t svfoo_[s64]offset_t0(const <X>_t *, svint64_t)\n+   sv<t0>_t svfoo_[u32]offset_t0(const <X>_t *, svuint32_t)\n+   sv<t0>_t svfoo_[u64]offset_t0(const <X>_t *, svuint64_t)\n+\n+   sv<t0>_t svfoo[_u32base]_t0(svuint32_t)\n+   sv<t0>_t svfoo[_u64base]_t0(svuint64_t)\n+\n+   sv<t0>_t svfoo[_u32base]_offset_t0(svuint32_t, int64_t)\n+   sv<t0>_t svfoo[_u64base]_offset_t0(svuint64_t, int64_t)\n+\n+   where <X> is determined by the function base name.  */\n+struct load_ext_gather_offset_def : public load_ext_gather_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_offset);\n+    build_sv_offset (b, \"t0,al,d\", group);\n+    build_v_base (b, \"t0,b\", group, true);\n+    build_vs_offset (b, \"t0,b,ss64\", group);\n+  }\n+};\n+SHAPE (load_ext_gather_offset)\n+\n+/* sv<t0>_t svfoo_[s32]index[_t0](const <t0>_t *, svint32_t)\n+   sv<t0>_t svfoo_[s64]index[_t0](const <t0>_t *, svint64_t)\n+   sv<t0>_t svfoo_[u32]index[_t0](const <t0>_t *, svuint32_t)\n+   sv<t0>_t svfoo_[u64]index[_t0](const <t0>_t *, svuint64_t)\n+\n+   sv<t0>_t svfoo_[s32]offset[_t0](const <t0>_t *, svint32_t)\n+   sv<t0>_t svfoo_[s64]offset[_t0](const <t0>_t *, svint64_t)\n+   sv<t0>_t svfoo_[u32]offset[_t0](const <t0>_t *, svuint32_t)\n+   sv<t0>_t svfoo_[u64]offset[_t0](const <t0>_t *, svuint64_t).  */\n+struct load_gather_sv_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_index);\n+    b.add_overloaded_functions (group, MODE_offset);\n+    build_sv_index (b, \"t0,al,d\", group);\n+    build_sv_offset (b, \"t0,al,d\", group);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    mode_suffix_index mode;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (2, i, nargs)\n+\t|| (type = r.infer_pointer_type (i, true)) == NUM_TYPE_SUFFIXES\n+\t|| (mode = r.resolve_sv_displacement (i + 1, type, true),\n+\t    mode == MODE_none))\n+      return error_mark_node;\n+\n+    return r.resolve_to (mode, type);\n+  }\n+};\n+SHAPE (load_gather_sv)\n+\n+/* sv<t0>_t svfoo[_u32base]_t0(svuint32_t)\n+   sv<t0>_t svfoo[_u64base]_t0(svuint64_t)\n+\n+   sv<t0>_t svfoo[_u32base]_index_t0(svuint32_t, int64_t)\n+   sv<t0>_t svfoo[_u64base]_index_t0(svuint64_t, int64_t)\n+\n+   sv<t0>_t svfoo[_u32base]_offset_t0(svuint32_t, int64_t)\n+   sv<t0>_t svfoo[_u64base]_offset_t0(svuint64_t, int64_t).  */\n+struct load_gather_vs_def : public overloaded_base<1>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    /* The base vector mode is optional; the full name has it but the\n+       short name doesn't.  There is no ambiguity with SHAPE_load_gather_sv\n+       because the latter uses an implicit type suffix.  */\n+    build_v_base (b, \"t0,b\", group, true);\n+    build_vs_index (b, \"t0,b,ss64\", group, true);\n+    build_vs_offset (b, \"t0,b,ss64\", group, true);\n+  }\n+\n+  tree\n+  resolve (function_resolver &) const OVERRIDE\n+  {\n+    /* The short name just makes the base vector mode implicit;\n+       no resolution is needed.  */\n+    gcc_unreachable ();\n+  }\n+};\n+SHAPE (load_gather_vs)\n+\n+/* sv<t0>_t svfoo[_t0](const <t0>_t *)\n+\n+   The only difference from \"load\" is that this shape has no vnum form.  */\n+struct load_replicate_def : public load_contiguous_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"t0,al\", group, MODE_none);\n+  }\n+};\n+SHAPE (load_replicate)\n+\n+/* svbool_t svfoo(enum svpattern).  */\n+struct pattern_pred_def : public nonoverloaded_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    build_all (b, \"vp,epattern\", group, MODE_none);\n+  }\n+};\n+SHAPE (pattern_pred)\n+\n+/* void svfoo(const void *, svprfop)\n+   void svfoo_vnum(const void *, int64_t, svprfop).  */\n+struct prefetch_def : public nonoverloaded_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    build_all (b, \"_,ap,eprfop\", group, MODE_none);\n+    build_all (b, \"_,ap,ss64,eprfop\", group, MODE_vnum);\n+  }\n+};\n+SHAPE (prefetch)\n+\n+/* void svfoo_[s32]index(const void *, svint32_t, svprfop)\n+   void svfoo_[s64]index(const void *, svint64_t, svprfop)\n+   void svfoo_[u32]index(const void *, svuint32_t, svprfop)\n+   void svfoo_[u64]index(const void *, svuint64_t, svprfop)\n+\n+   void svfoo[_u32base](svuint32_t, svprfop)\n+   void svfoo[_u64base](svuint64_t, svprfop)\n+\n+   void svfoo[_u32base]_index(svuint32_t, int64_t, svprfop)\n+   void svfoo[_u64base]_index(svuint64_t, int64_t, svprfop).  */\n+struct prefetch_gather_index_def : public prefetch_gather_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    b.add_overloaded_functions (group, MODE_index);\n+    build_sv_index (b, \"_,ap,d,eprfop\", group);\n+    build_v_base (b, \"_,b,eprfop\", group);\n+    build_vs_index (b, \"_,b,ss64,eprfop\", group);\n+  }\n+};\n+SHAPE (prefetch_gather_index)\n+\n+/* void svfoo_[s32]offset(const void *, svint32_t, svprfop)\n+   void svfoo_[s64]offset(const void *, svint64_t, svprfop)\n+   void svfoo_[u32]offset(const void *, svuint32_t, svprfop)\n+   void svfoo_[u64]offset(const void *, svuint64_t, svprfop)\n+\n+   void svfoo[_u32base](svuint32_t, svprfop)\n+   void svfoo[_u64base](svuint64_t, svprfop)\n+\n+   void svfoo[_u32base]_offset(svuint32_t, int64_t, svprfop)\n+   void svfoo[_u64base]_offset(svuint64_t, int64_t, svprfop).  */\n+struct prefetch_gather_offset_def : public prefetch_gather_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    b.add_overloaded_functions (group, MODE_offset);\n+    build_sv_offset (b, \"_,ap,d,eprfop\", group);\n+    build_v_base (b, \"_,b,eprfop\", group);\n+    build_vs_offset (b, \"_,b,ss64,eprfop\", group);\n+  }\n+};\n+SHAPE (prefetch_gather_offset)\n+\n+/* bool svfoo(svbool_t).  */\n+struct ptest_def : public nonoverloaded_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    build_all (b, \"sp,vp\", group, MODE_none);\n+  }\n+};\n+SHAPE (ptest)\n+\n+/* svbool_t svfoo().  */\n+struct rdffr_def : public nonoverloaded_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    build_all (b, \"vp\", group, MODE_none);\n+  }\n+};\n+SHAPE (rdffr)\n+\n+/* <t0>_t svfoo[_t0](sv<t0>_t).  */\n+struct reduction_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"s0,v0\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    return r.resolve_uniform (1);\n+  }\n+};\n+SHAPE (reduction)\n+\n+/* int64_t svfoo[_t0](sv<t0>_t)  (for signed t0)\n+   uint64_t svfoo[_t0](sv<t0>_t)  (for unsigned t0)\n+   <t0>_t svfoo[_t0](sv<t0>_t)  (for floating-point t0)\n+\n+   i.e. a version of \"reduction\" in which the return type for integers\n+   always has 64 bits.  */\n+struct reduction_wide_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"sw0,v0\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    return r.resolve_uniform (1);\n+  }\n+};\n+SHAPE (reduction_wide)\n+\n+/* sv<t0>xN_t svfoo[_t0](sv<t0>xN_t, uint64_t, sv<t0>_t)\n+\n+   where the second argument is an integer constant expression in the\n+   range [0, N - 1].  */\n+struct set_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"t0,t0,su64,v0\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (3, i, nargs)\n+\t|| (type = r.infer_tuple_type (i)) == NUM_TYPE_SUFFIXES\n+\t|| !r.require_integer_immediate (i + 1)\n+\t|| !r.require_derived_vector_type (i + 2, i, type))\n+      return error_mark_node;\n+\n+    return r.resolve_to (r.mode_suffix_id, type);\n+  }\n+\n+  bool\n+  check (function_checker &c) const OVERRIDE\n+  {\n+    unsigned int nvectors = c.vectors_per_tuple ();\n+    return c.require_immediate_range (1, 0, nvectors - 1);\n+  }\n+};\n+SHAPE (set)\n+\n+/* void svfoo().  */\n+struct setffr_def : public nonoverloaded_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    build_all (b, \"_\", group, MODE_none);\n+  }\n+};\n+SHAPE (setffr)\n+\n+/* sv<t0>_t svfoo[_n_t0])(sv<t0>_t, uint64_t)\n+\n+   where the final argument must be an integer constant expression in the\n+   range [1, sizeof (<t0>_t) * 8].  */\n+struct shift_right_imm_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_n);\n+    build_all (b, \"v0,v0,su64\", group, MODE_n);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    return r.resolve_uniform (1, 1);\n+  }\n+\n+  bool\n+  check (function_checker &c) const OVERRIDE\n+  {\n+    unsigned int bits = c.type_suffix (0).element_bits;\n+    return c.require_immediate_range (1, 1, bits);\n+  }\n+};\n+SHAPE (shift_right_imm)\n+\n+/* void svfoo[_t0](<X>_t *, sv<t0>[xN]_t)\n+   void svfoo_vnum[_t0](<X>_t *, int64_t, sv<t0>[xN]_t)\n+\n+   where <X> might be tied to <t0> (for non-truncating stores) or might\n+   depend on the function base name (for truncating stores).  */\n+struct store_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    b.add_overloaded_functions (group, MODE_vnum);\n+    build_all (b, \"_,as,t0\", group, MODE_none);\n+    build_all (b, \"_,as,ss64,t0\", group, MODE_vnum);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    bool vnum_p = r.mode_suffix_id == MODE_vnum;\n+    gcc_assert (r.mode_suffix_id == MODE_none || vnum_p);\n+\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (vnum_p ? 3 : 2, i, nargs)\n+\t|| !r.require_pointer_type (i)\n+\t|| (vnum_p && !r.require_scalar_type (i + 1, \"int64_t\"))\n+\t|| ((type = r.infer_tuple_type (nargs - 1)) == NUM_TYPE_SUFFIXES))\n+      return error_mark_node;\n+\n+    return r.resolve_to (r.mode_suffix_id, type);\n+  }\n+};\n+SHAPE (store)\n+\n+/* void svfoo_[s32]index[_t0](<X>_t *, svint32_t, sv<t0>_t)\n+   void svfoo_[s64]index[_t0](<X>_t *, svint64_t, sv<t0>_t)\n+   void svfoo_[u32]index[_t0](<X>_t *, svuint32_t, sv<t0>_t)\n+   void svfoo_[u64]index[_t0](<X>_t *, svuint64_t, sv<t0>_t)\n+\n+   void svfoo[_u32base]_index[_t0](svuint32_t, int64_t, sv<t0>_t)\n+   void svfoo[_u64base]_index[_t0](svuint64_t, int64_t, sv<t0>_t)\n+\n+   where <X> might be tied to <t0> (for non-truncating stores) or might\n+   depend on the function base name (for truncating stores).  */\n+struct store_scatter_index_def : public store_scatter_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_index);\n+    build_sv_index (b, \"_,as,d,t0\", group);\n+    build_vs_index (b, \"_,b,ss64,t0\", group);\n+  }\n+};\n+SHAPE (store_scatter_index)\n+\n+/* void svfoo_[s32]offset[_t0](<X>_t *, svint32_t, sv<t0>_t)\n+   void svfoo_[s64]offset[_t0](<X>_t *, svint64_t, sv<t0>_t)\n+   void svfoo_[u32]offset[_t0](<X>_t *, svuint32_t, sv<t0>_t)\n+   void svfoo_[u64]offset[_t0](<X>_t *, svuint64_t, sv<t0>_t)\n+\n+   void svfoo[_u32base_t0](svuint32_t, sv<t0>_t)\n+   void svfoo[_u64base_t0](svuint64_t, sv<t0>_t)\n+\n+   void svfoo[_u32base]_offset[_t0](svuint32_t, int64_t, sv<t0>_t)\n+   void svfoo[_u64base]_offset[_t0](svuint64_t, int64_t, sv<t0>_t)\n+\n+   where <X> might be tied to <t0> (for non-truncating stores) or might\n+   depend on the function base name (for truncating stores).  */\n+struct store_scatter_offset_def : public store_scatter_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    b.add_overloaded_functions (group, MODE_offset);\n+    build_sv_offset (b, \"_,as,d,t0\", group);\n+    build_v_base (b, \"_,b,t0\", group);\n+    build_vs_offset (b, \"_,b,ss64,t0\", group);\n+  }\n+};\n+SHAPE (store_scatter_offset)\n+\n+/* svbool_t svfoo[_<t0>](sv<t0>_t, sv<t0>_t, sv<t0>_t, uint64_t)\n+\n+   where the final argument is an integer constant expression in the\n+   range [0, 16 / sizeof (<t0>_t) - 1].  */\n+struct ternary_lane_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,v0,v0,su64\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    return r.resolve_uniform (3, 1);\n+  }\n+\n+  bool\n+  check (function_checker &c) const OVERRIDE\n+  {\n+    return c.require_immediate_lane_index (3);\n+  }\n+};\n+SHAPE (ternary_lane)\n+\n+/* svbool_t svfoo[_<t0>](sv<t0>_t, sv<t0>_t, sv<t0>_t, uint64_t, uint64_t)\n+\n+   where the penultimate argument is an integer constant expression in\n+   the range [0, 8 / sizeof (<t0>_t) - 1] and where the final argument\n+   is an integer constant expression in {0, 90, 180, 270}.  */\n+struct ternary_lane_rotate_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,v0,v0,su64,su64\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    return r.resolve_uniform (3, 2);\n+  }\n+\n+  bool\n+  check (function_checker &c) const OVERRIDE\n+  {\n+    return (c.require_immediate_lane_index (3, 2)\n+\t    && c.require_immediate_one_of (4, 0, 90, 180, 270));\n+  }\n+};\n+SHAPE (ternary_lane_rotate)\n+\n+/* sv<t0>_t svfoo[_t0](sv<t0>_t, sv<t0>_t, sv<t0>_t)\n+   sv<t0>_t svfoo[_n_t0](sv<t0>_t, sv<t0>_t, <t0>_t)\n+\n+   i.e. the standard shape for ternary operations that operate on\n+   uniform types.  */\n+struct ternary_opt_n_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,v0,v0\", group, MODE_none);\n+    build_all (b, \"v0,v0,v0,s0\", group, MODE_n);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    return r.resolve_uniform_opt_n (3);\n+  }\n+};\n+SHAPE (ternary_opt_n)\n+\n+/* sv<t0>_t svfoo[_t0](sv<t0>_t, sv<t0.quarter>_t, sv<t0.quarter>_t, uint64_t)\n+\n+   where the final argument is an integer constant expression in the range\n+   [0, 16 / sizeof (<t0>_t) - 1].  */\n+struct ternary_qq_lane_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,vq0,vq0,su64\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (4, i, nargs)\n+\t|| (type = r.infer_vector_type (i)) == NUM_TYPE_SUFFIXES\n+\t|| !r.require_derived_vector_type (i + 1, i, type, r.SAME_TYPE_CLASS,\n+\t\t\t\t\t   r.QUARTER_SIZE)\n+\t|| !r.require_derived_vector_type (i + 2, i, type, r.SAME_TYPE_CLASS,\n+\t\t\t\t\t   r.QUARTER_SIZE)\n+\t|| !r.require_integer_immediate (i + 3))\n+      return error_mark_node;\n+\n+    return r.resolve_to (r.mode_suffix_id, type);\n+  }\n+\n+  bool\n+  check (function_checker &c) const OVERRIDE\n+  {\n+    return c.require_immediate_lane_index (3, 4);\n+  }\n+};\n+SHAPE (ternary_qq_lane)\n+\n+/* sv<t0>_t svfoo[_t0](sv<t0>_t, sv<t0.quarter>_t, sv<t0.quarter>_t)\n+   sv<t0>_t svfoo[_n_t0](sv<t0>_t, sv<t0.quarter>_t, <t0.quarter>_t)\n+\n+   i.e. a version of the standard ternary shape ternary_opt_n in which\n+   the element type of the last two arguments is the quarter-sized\n+   equivalent of <t0>.  */\n+struct ternary_qq_opt_n_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,vq0,vq0\", group, MODE_none);\n+    build_all (b, \"v0,v0,vq0,sq0\", group, MODE_n);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (3, i, nargs)\n+\t|| (type = r.infer_vector_type (i)) == NUM_TYPE_SUFFIXES\n+\t|| !r.require_derived_vector_type (i + 1, i, type, r.SAME_TYPE_CLASS,\n+\t\t\t\t\t   r.QUARTER_SIZE))\n+      return error_mark_node;\n+\n+    return r.finish_opt_n_resolution (i + 2, i, type, r.SAME_TYPE_CLASS,\n+\t\t\t\t      r.QUARTER_SIZE);\n+  }\n+};\n+SHAPE (ternary_qq_opt_n)\n+\n+/* svbool_t svfoo[_<t0>](sv<t0>_t, sv<t0>_t, sv<t0>_t, uint64_t)\n+\n+   where the final argument is an integer constant expression in\n+   {0, 90, 180, 270}.  */\n+struct ternary_rotate_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,v0,v0,su64\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    return r.resolve_uniform (3, 1);\n+  }\n+\n+  bool\n+  check (function_checker &c) const OVERRIDE\n+  {\n+    return c.require_immediate_one_of (3, 0, 90, 180, 270);\n+  }\n+};\n+SHAPE (ternary_rotate)\n+\n+/* svbool_t svfoo[_<t0>](sv<t0>_t, sv<t0>_t, uint64_t)\n+\n+   where the final argument is an integer constant expression in the\n+   range [0, 7].  */\n+struct tmad_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0,v0,su64\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    return r.resolve_uniform (2, 1);\n+  }\n+\n+  bool\n+  check (function_checker &c) const OVERRIDE\n+  {\n+    return c.require_immediate_range (2, 0, 7);\n+  }\n+};\n+SHAPE (tmad)\n+\n+/* sv<t0>_t svfoo[_t0](sv<t0>_t)\n+\n+   i.e. the standard shape for unary operations that operate on\n+   uniform types.  */\n+struct unary_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v0\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    return r.resolve_unary ();\n+  }\n+};\n+SHAPE (unary)\n+\n+/* sv<t0>_t svfoo_t0[_t1](svbool_t, sv<t1>_t)\n+\n+   where the target type <t0> must be specified explicitly but the source\n+   type <t1> can be inferred.  */\n+struct unary_convert_def : public overloaded_base<1>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,v1\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    return r.resolve_unary (r.type_suffix (0).tclass,\n+\t\t\t    r.type_suffix (0).element_bits);\n+  }\n+};\n+SHAPE (unary_convert)\n+\n+/* sv<t0:uint>_t svfoo[_t0](sv<t0>_t)\n+\n+   i.e. a version of \"unary\" in which the returned vector contains\n+   unsigned integers.  */\n+struct unary_count_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"vu0,v0\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    return r.resolve_unary (TYPE_unsigned);\n+  }\n+};\n+SHAPE (unary_count)\n+\n+/* sv<t0>_t svfoo[_n]_t0(<t0>_t).  */\n+struct unary_n_def : public overloaded_base<1>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    /* The \"_n\" suffix is optional; the full name has it, but the short\n+       name doesn't.  */\n+    build_all (b, \"v0,s0\", group, MODE_n, true);\n+  }\n+\n+  tree\n+  resolve (function_resolver &) const OVERRIDE\n+  {\n+    /* The short forms just make \"_n\" implicit, so no resolution is needed.  */\n+    gcc_unreachable ();\n+  }\n+};\n+SHAPE (unary_n)\n+\n+/* svbool_t svfoo(svbool_t).  */\n+struct unary_pred_def : public nonoverloaded_base\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    build_all (b, \"v0,v0\", group, MODE_none);\n+  }\n+};\n+SHAPE (unary_pred)\n+\n+/* sv<t0>_t svfoo[_t0](sv<t0:uint>_t)\n+\n+   where <t0> always belongs a certain type class, and where <t0:uint>\n+   therefore uniquely determines <t0>.  */\n+struct unary_uint_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,vu0\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (1, i, nargs)\n+\t|| (type = r.infer_unsigned_vector_type (i)) == NUM_TYPE_SUFFIXES)\n+      return error_mark_node;\n+\n+    /* Search for a valid suffix with the same number of bits as TYPE.  */\n+    unsigned int element_bits = type_suffixes[type].element_bits;\n+    if (type_suffixes[type].unsigned_p)\n+      for (unsigned int j = 0; j < NUM_TYPE_SUFFIXES; ++j)\n+\tif (type_suffixes[j].element_bits == element_bits)\n+\t  if (tree res = r.lookup_form (r.mode_suffix_id,\n+\t\t\t\t\ttype_suffix_index (j)))\n+\t    return res;\n+\n+    return r.report_no_such_form (type);\n+  }\n+};\n+SHAPE (unary_uint)\n+\n+/* sv<t0>_t svfoo[_<t0>](sv<t0:half>_t)\n+\n+   i.e. a version of \"unary\" in which the source elements are half the\n+   size of the destination elements, but have the same type class.  */\n+struct unary_widen_def : public overloaded_base<0>\n+{\n+  void\n+  build (function_builder &b, const function_group_info &group) const OVERRIDE\n+  {\n+    b.add_overloaded_functions (group, MODE_none);\n+    build_all (b, \"v0,vh0\", group, MODE_none);\n+  }\n+\n+  tree\n+  resolve (function_resolver &r) const OVERRIDE\n+  {\n+    unsigned int i, nargs;\n+    type_suffix_index type;\n+    if (!r.check_gp_argument (1, i, nargs)\n+\t|| (type = r.infer_vector_type (i)) == NUM_TYPE_SUFFIXES)\n+      return error_mark_node;\n+\n+    /* There is only a single form for predicates.  */\n+    if (type == TYPE_SUFFIX_b)\n+      return r.resolve_to (r.mode_suffix_id, type);\n+\n+    if (type_suffixes[type].integer_p\n+\t&& type_suffixes[type].element_bits < 64)\n+      {\n+\ttype_suffix_index wide_suffix\n+\t  = find_type_suffix (type_suffixes[type].tclass,\n+\t\t\t      type_suffixes[type].element_bits * 2);\n+\tif (tree res = r.lookup_form (r.mode_suffix_id, wide_suffix))\n+\t  return res;\n+      }\n+\n+    return r.report_no_such_form (type);\n+  }\n+};\n+SHAPE (unary_widen)\n+\n+}"}, {"sha": "1a102e09b73c0e1111b8a53ee6234c8ef675a7b3", "filename": "gcc/config/aarch64/aarch64-sve-builtins-shapes.h", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-shapes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-shapes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-shapes.h?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,146 @@\n+/* ACLE support for AArch64 SVE (function shapes)\n+   Copyright (C) 2018-2019 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_AARCH64_SVE_BUILTINS_SHAPES_H\n+#define GCC_AARCH64_SVE_BUILTINS_SHAPES_H\n+\n+namespace aarch64_sve\n+{\n+  /* The naming convention is:\n+\n+     - to use the name of the function if the rules are very specific to\n+       a particular function (e.g. svext, for which the range of the\n+       final immediate value is in no way generic).\n+\n+     - to use names like \"unary\" etc. if the rules are somewhat generic,\n+       especially if there are no ranges involved.\n+\n+     When using generic names, the handling of the final vector argument\n+     can be modified as follows:\n+\n+     - an \"_n\" suffix changes the argument from a vector to a scalar.\n+\n+     - an \"_opt_n\" suffix says that there are two forms of each function:\n+       one in which the argument is the usual vector, and one in which it\n+       is replaced by a scalar.\n+\n+     - \"_int\" and \"_uint\" replace the argument's element type with a\n+       signed or unsigned integer of the same width.  The suffixes above\n+       then indicate whether this final argument is or might be a scalar.\n+\n+     - \"_int64\" and \"_uint64\" similarly replace the argument's element type\n+       with int64_t or uint64_t.\n+\n+     - \"_wide\" replaces the argument's element type with a 64-bit integer\n+       of the same signedness.  This only makes sense for integer elements.\n+\n+     - \"_lane\" indicates that the argument is indexed by a constant lane\n+       number, provided as an immediately-following argument of type uint64_t.\n+\n+     Also:\n+\n+     - \"inherent\" means that the function takes no arguments.\n+\n+     - \"_rotate\" means that the final argument is a rotation amount\n+       (0, 90, 180 or 270).\n+\n+     - \"_scalar\" indicates that all data arguments are scalars rather\n+       than vectors.\n+\n+     - in gather/scatter addresses, \"sv\" stands for \"scalar base,\n+       vector displacement\" while \"vs\" stands for \"vector base,\n+       scalar displacement\".\n+\n+     - \"_pred\" indicates that the function takes an svbool_t argument\n+       that does not act as a governing predicate..  */\n+  namespace shapes\n+  {\n+    extern const function_shape *const adr_index;\n+    extern const function_shape *const adr_offset;\n+    extern const function_shape *const binary;\n+    extern const function_shape *const binary_int_opt_n;\n+    extern const function_shape *const binary_lane;\n+    extern const function_shape *const binary_n;\n+    extern const function_shape *const binary_opt_n;\n+    extern const function_shape *const binary_pred;\n+    extern const function_shape *const binary_rotate;\n+    extern const function_shape *const binary_scalar;\n+    extern const function_shape *const binary_uint;\n+    extern const function_shape *const binary_uint_n;\n+    extern const function_shape *const binary_uint_opt_n;\n+    extern const function_shape *const binary_uint64_n;\n+    extern const function_shape *const binary_uint64_opt_n;\n+    extern const function_shape *const clast;\n+    extern const function_shape *const compare_opt_n;\n+    extern const function_shape *const compare_scalar;\n+    extern const function_shape *const compare_wide_opt_n;\n+    extern const function_shape *const count_inherent;\n+    extern const function_shape *const count_pat;\n+    extern const function_shape *const count_pred;\n+    extern const function_shape *const count_vector;\n+    extern const function_shape *const create;\n+    extern const function_shape *const dupq;\n+    extern const function_shape *const ext;\n+    extern const function_shape *const fold_left;\n+    extern const function_shape *const get;\n+    extern const function_shape *const inc_dec;\n+    extern const function_shape *const inc_dec_pat;\n+    extern const function_shape *const inc_dec_pred;\n+    extern const function_shape *const inc_dec_pred_scalar;\n+    extern const function_shape *const inherent;\n+    extern const function_shape *const inherent_b;\n+    extern const function_shape *const load;\n+    extern const function_shape *const load_ext;\n+    extern const function_shape *const load_ext_gather_index;\n+    extern const function_shape *const load_ext_gather_offset;\n+    extern const function_shape *const load_gather_sv;\n+    extern const function_shape *const load_gather_vs;\n+    extern const function_shape *const load_replicate;\n+    extern const function_shape *const pattern_pred;\n+    extern const function_shape *const prefetch;\n+    extern const function_shape *const prefetch_gather_index;\n+    extern const function_shape *const prefetch_gather_offset;\n+    extern const function_shape *const ptest;\n+    extern const function_shape *const rdffr;\n+    extern const function_shape *const reduction;\n+    extern const function_shape *const reduction_wide;\n+    extern const function_shape *const set;\n+    extern const function_shape *const setffr;\n+    extern const function_shape *const shift_right_imm;\n+    extern const function_shape *const store;\n+    extern const function_shape *const store_scatter_index;\n+    extern const function_shape *const store_scatter_offset;\n+    extern const function_shape *const ternary_lane;\n+    extern const function_shape *const ternary_lane_rotate;\n+    extern const function_shape *const ternary_opt_n;\n+    extern const function_shape *const ternary_qq_lane;\n+    extern const function_shape *const ternary_qq_opt_n;\n+    extern const function_shape *const ternary_rotate;\n+    extern const function_shape *const tmad;\n+    extern const function_shape *const unary;\n+    extern const function_shape *const unary_convert;\n+    extern const function_shape *const unary_count;\n+    extern const function_shape *const unary_n;\n+    extern const function_shape *const unary_pred;\n+    extern const function_shape *const unary_uint;\n+    extern const function_shape *const unary_widen;\n+  }\n+}\n+\n+#endif"}, {"sha": "70d7b1a165d0103c9a6649325fff76722a54ed74", "filename": "gcc/config/aarch64/aarch64-sve-builtins.cc", "status": "added", "additions": 3313, "deletions": 0, "changes": 3313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc"}, {"sha": "da00019a5fce67366e01bbc4bb8e089e0f2b9b58", "filename": "gcc/config/aarch64/aarch64-sve-builtins.def", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.def?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,98 @@\n+/* Builtin lists for AArch64 SVE\n+   Copyright (C) 2018-2019 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef DEF_SVE_MODE\n+#define DEF_SVE_MODE(A, B, C, D)\n+#endif\n+\n+#ifndef DEF_SVE_TYPE\n+#define DEF_SVE_TYPE(A, B, C, D)\n+#endif\n+\n+#ifndef DEF_SVE_TYPE_SUFFIX\n+#define DEF_SVE_TYPE_SUFFIX(A, B, C, D, E)\n+#endif\n+\n+#ifndef DEF_SVE_FUNCTION\n+#define DEF_SVE_FUNCTION(A, B, C, D)\n+#endif\n+\n+DEF_SVE_MODE (n, none, none, none)\n+DEF_SVE_MODE (index, none, none, elements)\n+DEF_SVE_MODE (offset, none, none, bytes)\n+DEF_SVE_MODE (s32index, none, svint32_t, elements)\n+DEF_SVE_MODE (s32offset, none, svint32_t, bytes)\n+DEF_SVE_MODE (s64index,  none, svint64_t, elements)\n+DEF_SVE_MODE (s64offset, none, svint64_t, bytes)\n+DEF_SVE_MODE (u32base, svuint32_t, none, none)\n+DEF_SVE_MODE (u32base_index, svuint32_t, none, elements)\n+DEF_SVE_MODE (u32base_offset, svuint32_t, none, bytes)\n+DEF_SVE_MODE (u32base_s32index, svuint32_t, svint32_t, elements)\n+DEF_SVE_MODE (u32base_s32offset, svuint32_t, svint32_t, bytes)\n+DEF_SVE_MODE (u32base_u32index, svuint32_t, svuint32_t, elements)\n+DEF_SVE_MODE (u32base_u32offset, svuint32_t, svuint32_t, bytes)\n+DEF_SVE_MODE (u32index, none, svuint32_t, elements)\n+DEF_SVE_MODE (u32offset, none, svuint32_t, bytes)\n+DEF_SVE_MODE (u64base, svuint64_t, none, none)\n+DEF_SVE_MODE (u64base_index, svuint64_t, none, elements)\n+DEF_SVE_MODE (u64base_offset, svuint64_t, none, bytes)\n+DEF_SVE_MODE (u64base_s64index, svuint64_t, svint64_t, elements)\n+DEF_SVE_MODE (u64base_s64offset, svuint64_t, svint64_t, bytes)\n+DEF_SVE_MODE (u64base_u64index, svuint64_t, svuint64_t, elements)\n+DEF_SVE_MODE (u64base_u64offset, svuint64_t, svuint64_t, bytes)\n+DEF_SVE_MODE (u64index, none, svuint64_t, elements)\n+DEF_SVE_MODE (u64offset, none, svuint64_t, bytes)\n+DEF_SVE_MODE (vnum, none, none, vectors)\n+\n+DEF_SVE_TYPE (svbool_t, 10, __SVBool_t, boolean_type_node)\n+DEF_SVE_TYPE (svfloat16_t, 13, __SVFloat16_t, aarch64_fp16_type_node)\n+DEF_SVE_TYPE (svfloat32_t, 13, __SVFloat32_t, float_type_node)\n+DEF_SVE_TYPE (svfloat64_t, 13, __SVFloat64_t, double_type_node)\n+DEF_SVE_TYPE (svint8_t, 10, __SVInt8_t, intQI_type_node)\n+DEF_SVE_TYPE (svint16_t, 11, __SVInt16_t, intHI_type_node)\n+DEF_SVE_TYPE (svint32_t, 11, __SVInt32_t, intSI_type_node)\n+DEF_SVE_TYPE (svint64_t, 11, __SVInt64_t, intDI_type_node)\n+DEF_SVE_TYPE (svuint8_t, 11, __SVUint8_t, unsigned_intQI_type_node)\n+DEF_SVE_TYPE (svuint16_t, 12, __SVUint16_t, unsigned_intHI_type_node)\n+DEF_SVE_TYPE (svuint32_t, 12, __SVUint32_t, unsigned_intSI_type_node)\n+DEF_SVE_TYPE (svuint64_t, 12, __SVUint64_t, unsigned_intDI_type_node)\n+\n+DEF_SVE_TYPE_SUFFIX (b, svbool_t, bool, 8, VNx16BImode)\n+DEF_SVE_TYPE_SUFFIX (b8, svbool_t, bool, 8, VNx16BImode)\n+DEF_SVE_TYPE_SUFFIX (b16, svbool_t, bool, 16, VNx8BImode)\n+DEF_SVE_TYPE_SUFFIX (b32, svbool_t, bool, 32, VNx4BImode)\n+DEF_SVE_TYPE_SUFFIX (b64, svbool_t, bool, 64, VNx2BImode)\n+DEF_SVE_TYPE_SUFFIX (f16, svfloat16_t, float, 16, VNx8HFmode)\n+DEF_SVE_TYPE_SUFFIX (f32, svfloat32_t, float, 32, VNx4SFmode)\n+DEF_SVE_TYPE_SUFFIX (f64, svfloat64_t, float, 64, VNx2DFmode)\n+DEF_SVE_TYPE_SUFFIX (s8, svint8_t, signed, 8, VNx16QImode)\n+DEF_SVE_TYPE_SUFFIX (s16, svint16_t, signed, 16, VNx8HImode)\n+DEF_SVE_TYPE_SUFFIX (s32, svint32_t, signed, 32, VNx4SImode)\n+DEF_SVE_TYPE_SUFFIX (s64, svint64_t, signed, 64, VNx2DImode)\n+DEF_SVE_TYPE_SUFFIX (u8, svuint8_t, unsigned, 8, VNx16QImode)\n+DEF_SVE_TYPE_SUFFIX (u16, svuint16_t, unsigned, 16, VNx8HImode)\n+DEF_SVE_TYPE_SUFFIX (u32, svuint32_t, unsigned, 32, VNx4SImode)\n+DEF_SVE_TYPE_SUFFIX (u64, svuint64_t, unsigned, 64, VNx2DImode)\n+\n+#include \"aarch64-sve-builtins-base.def\"\n+\n+#undef DEF_SVE_FUNCTION\n+#undef DEF_SVE_TYPE_SUFFIX\n+#undef DEF_SVE_TYPE\n+#undef DEF_SVE_MODE"}, {"sha": "73b07c71e5d68f308521d3d66a58c05d0f99f378", "filename": "gcc/config/aarch64/aarch64-sve-builtins.h", "status": "added", "additions": 873, "deletions": 0, "changes": 873, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.h?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,873 @@\n+/* ACLE support for AArch64 SVE\n+   Copyright (C) 2018-2019 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_AARCH64_SVE_BUILTINS_H\n+#define GCC_AARCH64_SVE_BUILTINS_H\n+\n+/* The full name of an SVE ACLE function is the concatenation of:\n+\n+   - the base name (\"svadd\", etc.)\n+   - the \"mode\" suffix (\"_n\", \"_index\", etc.)\n+   - the type suffixes (\"_s32\", \"_b8\", etc.)\n+   - the predication suffix (\"_x\", \"_z\", etc.)\n+\n+   Each piece of information is individually useful, so we retain this\n+   classification throughout:\n+\n+   - function_base represents the base name\n+\n+   - mode_suffix_index represents the mode suffix\n+\n+   - type_suffix_index represents individual type suffixes, while\n+     type_suffix_pair represents a pair of them\n+\n+   - prediction_index extends the predication suffix with an additional\n+     alternative: PRED_implicit for implicitly-predicated operations\n+\n+   In addition to its unique full name, a function may have a shorter\n+   overloaded alias.  This alias removes pieces of the suffixes that\n+   can be inferred from the arguments, such as by shortening the mode\n+   suffix or dropping some of the type suffixes.  The base name and the\n+   predication suffix stay the same.\n+\n+   The function_shape class describes what arguments a given function\n+   takes and what its overloaded alias is called.  In broad terms,\n+   function_base describes how the underlying instruction behaves while\n+   function_shape describes how that instruction has been presented at\n+   the language level.\n+\n+   The static list of functions uses function_group to describe a group\n+   of related functions.  The function_builder class is responsible for\n+   expanding this static description into a list of individual functions\n+   and registering the associated built-in functions.  function_instance\n+   describes one of these individual functions in terms of the properties\n+   described above.\n+\n+   The classes involved in compiling a function call are:\n+\n+   - function_resolver, which resolves an overloaded function call to a\n+     specific function_instance and its associated function decl\n+\n+   - function_checker, which checks whether the values of the arguments\n+     conform to the ACLE specification\n+\n+   - gimple_folder, which tries to fold a function call at the gimple level\n+\n+   - function_expander, which expands a function call into rtl instructions\n+\n+   function_resolver and function_checker operate at the language level\n+   and so are associated with the function_shape.  gimple_folder and\n+   function_expander are concerned with the behavior of the function\n+   and so are associated with the function_base.\n+\n+   Note that we've specifically chosen not to fold calls in the frontend,\n+   since SVE intrinsics will hardly ever fold a useful language-level\n+   constant.  */\n+namespace aarch64_sve\n+{\n+/* The maximum number of vectors in an ACLE tuple type.  */\n+const unsigned int MAX_TUPLE_SIZE = 4;\n+\n+/* Used to represent the default merge argument index for _m functions.\n+   The actual index depends on how many arguments the function takes.  */\n+const unsigned int DEFAULT_MERGE_ARGNO = ~0U;\n+\n+/* Flags that describe what a function might do, in addition to reading\n+   its arguments and returning a result.  */\n+const unsigned int CP_READ_FPCR = 1U << 0;\n+const unsigned int CP_RAISE_FP_EXCEPTIONS = 1U << 1;\n+const unsigned int CP_READ_MEMORY = 1U << 2;\n+const unsigned int CP_PREFETCH_MEMORY = 1U << 3;\n+const unsigned int CP_WRITE_MEMORY = 1U << 4;\n+const unsigned int CP_READ_FFR = 1U << 5;\n+const unsigned int CP_WRITE_FFR = 1U << 6;\n+\n+/* Enumerates the SVE predicate and (data) vector types, together called\n+   \"vector types\" for brevity.  */\n+enum vector_type_index\n+{\n+#define DEF_SVE_TYPE(ACLE_NAME, NCHARS, ABI_NAME, SCALAR_TYPE) \\\n+  VECTOR_TYPE_ ## ACLE_NAME,\n+#include \"aarch64-sve-builtins.def\"\n+  NUM_VECTOR_TYPES\n+};\n+\n+/* Classifies the available measurement units for an address displacement.  */\n+enum units_index\n+{\n+  UNITS_none,\n+  UNITS_bytes,\n+  UNITS_elements,\n+  UNITS_vectors\n+};\n+\n+/* Describes the various uses of a governing predicate.  */\n+enum predication_index\n+{\n+  /* No governing predicate is present.  */\n+  PRED_none,\n+\n+  /* A governing predicate is present but there is no predication suffix\n+     associated with it.  This is used when the result is neither a vector\n+     nor a predicate, since the distinction between \"zeroing\" and \"merging\"\n+     doesn't apply in that case.  It is also used when a suffix would be\n+     redundant (such as for loads and comparisons, which are inherently\n+     zeroing operations).  */\n+  PRED_implicit,\n+\n+  /* Merging predication: copy inactive lanes from the first data argument\n+     to the vector result.  */\n+  PRED_m,\n+\n+  /* \"Don't care\" predication: set inactive lanes of the vector result\n+     to arbitrary values.  */\n+  PRED_x,\n+\n+  /* Zero predication: set inactive lanes of the vector result to zero.  */\n+  PRED_z,\n+\n+  NUM_PREDS\n+};\n+\n+/* Classifies element types, based on type suffixes with the bit count\n+   removed.  */\n+enum type_class_index\n+{\n+  TYPE_bool,\n+  TYPE_float,\n+  TYPE_signed,\n+  TYPE_unsigned,\n+  NUM_TYPE_CLASSES\n+};\n+\n+/* Classifies an operation into \"modes\"; for example, to distinguish\n+   vector-scalar operations from vector-vector operations, or to\n+   distinguish between different addressing modes.  This classification\n+   accounts for the function suffixes that occur between the base name\n+   and the first type suffix.  */\n+enum mode_suffix_index\n+{\n+#define DEF_SVE_MODE(NAME, BASE, DISPLACEMENT, UNITS) MODE_##NAME,\n+#include \"aarch64-sve-builtins.def\"\n+  MODE_none\n+};\n+\n+/* Enumerates the possible type suffixes.  Each suffix is associated with\n+   a vector type, but for predicates provides extra information about the\n+   element size.  */\n+enum type_suffix_index\n+{\n+#define DEF_SVE_TYPE_SUFFIX(NAME, ACLE_TYPE, CLASS, BITS, MODE) \\\n+  TYPE_SUFFIX_ ## NAME,\n+#include \"aarch64-sve-builtins.def\"\n+  NUM_TYPE_SUFFIXES\n+};\n+\n+/* Combines two type suffixes.  */\n+typedef enum type_suffix_index type_suffix_pair[2];\n+\n+class function_base;\n+class function_shape;\n+\n+/* Static information about a mode suffix.  */\n+struct mode_suffix_info\n+{\n+  /* The suffix string itself.  */\n+  const char *string;\n+\n+  /* The type of the vector base address, or NUM_VECTOR_TYPES if the\n+     mode does not include a vector base address.  */\n+  vector_type_index base_vector_type;\n+\n+  /* The type of the vector displacement, or NUM_VECTOR_TYPES if the\n+     mode does not include a vector displacement.  (Note that scalar\n+     displacements are always int64_t.)  */\n+  vector_type_index displacement_vector_type;\n+\n+  /* The units in which the vector or scalar displacement is measured,\n+     or UNITS_none if the mode doesn't take a displacement.  */\n+  units_index displacement_units;\n+};\n+\n+/* Static information about a type suffix.  */\n+struct type_suffix_info\n+{\n+  /* The suffix string itself.  */\n+  const char *string;\n+\n+  /* The associated ACLE vector or predicate type.  */\n+  vector_type_index vector_type : 8;\n+\n+  /* What kind of type the suffix represents.  */\n+  type_class_index tclass : 8;\n+\n+  /* The number of bits and bytes in an element.  For predicates this\n+     measures the associated data elements.  */\n+  unsigned int element_bits : 8;\n+  unsigned int element_bytes : 8;\n+\n+  /* True if the suffix is for an integer type.  */\n+  unsigned int integer_p : 1;\n+  /* True if the suffix is for an unsigned type.  */\n+  unsigned int unsigned_p : 1;\n+  /* True if the suffix is for a floating-point type.  */\n+  unsigned int float_p : 1;\n+  /* True if the suffix is for a boolean type.  */\n+  unsigned int bool_p : 1;\n+  unsigned int spare : 12;\n+\n+  /* The associated vector or predicate mode.  */\n+  machine_mode vector_mode : 16;\n+};\n+\n+/* Static information about a set of functions.  */\n+struct function_group_info\n+{\n+  /* The base name, as a string.  */\n+  const char *base_name;\n+\n+  /* Describes the behavior associated with the function base name.  */\n+  const function_base *const *base;\n+\n+  /* The shape of the functions, as described above the class definition.\n+     It's possible to have entries with the same base name but different\n+     shapes.  */\n+  const function_shape *const *shape;\n+\n+  /* A list of the available type suffixes, and of the available predication\n+     types.  The function supports every combination of the two.\n+\n+     The list of type suffixes is terminated by two NUM_TYPE_SUFFIXES\n+     while the list of predication types is terminated by NUM_PREDS.\n+     The list of type suffixes is lexicographically ordered based\n+     on the index value.  */\n+  const type_suffix_pair *types;\n+  const predication_index *preds;\n+\n+  /* The architecture extensions that the functions require, as a set of\n+     AARCH64_FL_* flags.  */\n+  uint64_t required_extensions;\n+};\n+\n+/* Describes a single fully-resolved function (i.e. one that has a\n+   unique full name).  */\n+class GTY((user)) function_instance\n+{\n+public:\n+  function_instance (const char *, const function_base *,\n+\t\t     const function_shape *, mode_suffix_index,\n+\t\t     const type_suffix_pair &, predication_index);\n+\n+  bool operator== (const function_instance &) const;\n+  bool operator!= (const function_instance &) const;\n+  hashval_t hash () const;\n+\n+  unsigned int call_properties () const;\n+  bool reads_global_state_p () const;\n+  bool modifies_global_state_p () const;\n+  bool could_trap_p () const;\n+\n+  unsigned int vectors_per_tuple () const;\n+  tree memory_scalar_type () const;\n+  machine_mode memory_vector_mode () const;\n+\n+  const mode_suffix_info &mode_suffix () const;\n+  tree base_vector_type () const;\n+  tree displacement_vector_type () const;\n+  units_index displacement_units () const;\n+\n+  const type_suffix_info &type_suffix (unsigned int) const;\n+  tree scalar_type (unsigned int) const;\n+  tree vector_type (unsigned int) const;\n+  tree tuple_type (unsigned int) const;\n+  unsigned int elements_per_vq (unsigned int i) const;\n+  machine_mode vector_mode (unsigned int) const;\n+  machine_mode gp_mode (unsigned int) const;\n+\n+  /* The properties of the function.  (The explicit \"enum\"s are required\n+     for gengtype.)  */\n+  const char *base_name;\n+  const function_base *base;\n+  const function_shape *shape;\n+  enum mode_suffix_index mode_suffix_id;\n+  type_suffix_pair type_suffix_ids;\n+  enum predication_index pred;\n+};\n+\n+class registered_function;\n+\n+/* A class for building and registering function decls.  */\n+class function_builder\n+{\n+public:\n+  function_builder ();\n+  ~function_builder ();\n+\n+  void add_unique_function (const function_instance &, tree,\n+\t\t\t    vec<tree> &, uint64_t, bool);\n+  void add_overloaded_function (const function_instance &, uint64_t);\n+  void add_overloaded_functions (const function_group_info &,\n+\t\t\t\t mode_suffix_index);\n+\n+  void register_function_group (const function_group_info &);\n+\n+private:\n+  void append_name (const char *);\n+  char *finish_name ();\n+\n+  char *get_name (const function_instance &, bool);\n+\n+  tree get_attributes (const function_instance &);\n+\n+  registered_function &add_function (const function_instance &,\n+\t\t\t\t     const char *, tree, tree, uint64_t, bool);\n+\n+  /* The function type to use for functions that are resolved by\n+     function_resolver.  */\n+  tree m_overload_type;\n+\n+  /* True if we should create a separate decl for each instance of an\n+     overloaded function, instead of using function_resolver.  */\n+  bool m_direct_overloads;\n+\n+  /* Used for building up function names.  */\n+  obstack m_string_obstack;\n+\n+  /* Maps all overloaded function names that we've registered so far\n+     to their associated function_instances.  */\n+  hash_map<nofree_string_hash, registered_function *> m_overload_names;\n+};\n+\n+/* A base class for handling calls to built-in functions.  */\n+class function_call_info : public function_instance\n+{\n+public:\n+  function_call_info (location_t, const function_instance &, tree);\n+\n+  bool function_returns_void_p ();\n+\n+  /* The location of the call.  */\n+  location_t location;\n+\n+  /* The FUNCTION_DECL that is being called.  */\n+  tree fndecl;\n+};\n+\n+/* A class for resolving an overloaded function call.  */\n+class function_resolver : public function_call_info\n+{\n+public:\n+  enum { SAME_SIZE = 256, HALF_SIZE, QUARTER_SIZE };\n+  static const type_class_index SAME_TYPE_CLASS = NUM_TYPE_CLASSES;\n+\n+  function_resolver (location_t, const function_instance &, tree,\n+\t\t     vec<tree, va_gc> &);\n+\n+  tree get_vector_type (type_suffix_index);\n+  const char *get_scalar_type_name (type_suffix_index);\n+  tree get_argument_type (unsigned int);\n+  bool scalar_argument_p (unsigned int);\n+\n+  tree report_no_such_form (type_suffix_index);\n+  tree lookup_form (mode_suffix_index,\n+\t\t    type_suffix_index = NUM_TYPE_SUFFIXES,\n+\t\t    type_suffix_index = NUM_TYPE_SUFFIXES);\n+  tree resolve_to (mode_suffix_index,\n+\t\t   type_suffix_index = NUM_TYPE_SUFFIXES,\n+\t\t   type_suffix_index = NUM_TYPE_SUFFIXES);\n+\n+  type_suffix_index infer_integer_scalar_type (unsigned int);\n+  type_suffix_index infer_pointer_type (unsigned int, bool = false);\n+  type_suffix_index infer_vector_or_tuple_type (unsigned int, unsigned int);\n+  type_suffix_index infer_vector_type (unsigned int);\n+  type_suffix_index infer_integer_vector_type (unsigned int);\n+  type_suffix_index infer_unsigned_vector_type (unsigned int);\n+  type_suffix_index infer_sd_vector_type (unsigned int);\n+  type_suffix_index infer_tuple_type (unsigned int);\n+\n+  bool require_vector_or_scalar_type (unsigned int);\n+\n+  bool require_vector_type (unsigned int, vector_type_index);\n+  bool require_matching_vector_type (unsigned int, type_suffix_index);\n+  bool require_derived_vector_type (unsigned int, unsigned int,\n+\t\t\t\t    type_suffix_index,\n+\t\t\t\t    type_class_index = SAME_TYPE_CLASS,\n+\t\t\t\t    unsigned int = SAME_SIZE);\n+\n+  bool require_scalar_type (unsigned int, const char *);\n+  bool require_pointer_type (unsigned int);\n+  bool require_matching_integer_scalar_type (unsigned int, unsigned int,\n+\t\t\t\t\t     type_suffix_index);\n+  bool require_derived_scalar_type (unsigned int, type_class_index,\n+\t\t\t\t    unsigned int = SAME_SIZE);\n+  bool require_integer_immediate (unsigned int);\n+\n+  vector_type_index infer_vector_base_type (unsigned int);\n+  vector_type_index infer_vector_displacement_type (unsigned int);\n+\n+  mode_suffix_index resolve_sv_displacement (unsigned int,\n+\t\t\t\t\t     type_suffix_index, bool);\n+  mode_suffix_index resolve_gather_address (unsigned int,\n+\t\t\t\t\t    type_suffix_index, bool);\n+  mode_suffix_index resolve_adr_address (unsigned int);\n+\n+  bool check_num_arguments (unsigned int);\n+  bool check_gp_argument (unsigned int, unsigned int &, unsigned int &);\n+  tree resolve_unary (type_class_index = SAME_TYPE_CLASS,\n+\t\t      unsigned int = SAME_SIZE);\n+  tree resolve_uniform (unsigned int, unsigned int = 0);\n+  tree resolve_uniform_opt_n (unsigned int);\n+  tree finish_opt_n_resolution (unsigned int, unsigned int, type_suffix_index,\n+\t\t\t\ttype_class_index = SAME_TYPE_CLASS,\n+\t\t\t\tunsigned int = SAME_SIZE);\n+\n+  tree resolve ();\n+\n+private:\n+  /* The arguments to the overloaded function.  */\n+  vec<tree, va_gc> &m_arglist;\n+};\n+\n+/* A class for checking that the semantic constraints on a function call are\n+   satisfied, such as arguments being integer constant expressions with\n+   a particular range.  The parent class's FNDECL is the decl that was\n+   called in the original source, before overload resolution.  */\n+class function_checker : public function_call_info\n+{\n+public:\n+  function_checker (location_t, const function_instance &, tree,\n+\t\t    tree, unsigned int, tree *);\n+\n+  bool require_immediate_either_or (unsigned int, HOST_WIDE_INT,\n+\t\t\t\t    HOST_WIDE_INT);\n+  bool require_immediate_enum (unsigned int, tree);\n+  bool require_immediate_lane_index (unsigned int, unsigned int = 1);\n+  bool require_immediate_one_of (unsigned int, HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t HOST_WIDE_INT, HOST_WIDE_INT);\n+  bool require_immediate_range (unsigned int, HOST_WIDE_INT, HOST_WIDE_INT);\n+\n+  bool check ();\n+\n+private:\n+  bool argument_exists_p (unsigned int);\n+\n+  bool require_immediate (unsigned int, HOST_WIDE_INT &);\n+\n+  /* The type of the resolved function.  */\n+  tree m_fntype;\n+\n+  /* The arguments to the function.  */\n+  unsigned int m_nargs;\n+  tree *m_args;\n+\n+  /* The first argument not associated with the function's predication\n+     type.  */\n+  unsigned int m_base_arg;\n+};\n+\n+/* A class for folding a gimple function call.  */\n+class gimple_folder : public function_call_info\n+{\n+public:\n+  gimple_folder (const function_instance &, tree,\n+\t\t gimple_stmt_iterator *, gcall *);\n+\n+  tree convert_pred (gimple_seq &, tree, unsigned int);\n+  tree fold_contiguous_base (gimple_seq &, tree);\n+  tree load_store_cookie (tree);\n+\n+  gimple *fold_to_pfalse ();\n+  gimple *fold_to_ptrue ();\n+  gimple *fold_to_vl_pred (unsigned int);\n+\n+  gimple *fold ();\n+\n+  /* Where to insert extra statements that feed the final replacement.  */\n+  gimple_stmt_iterator *gsi;\n+\n+  /* The call we're folding.  */\n+  gcall *call;\n+\n+  /* The result of the call, or null if none.  */\n+  tree lhs;\n+};\n+\n+/* A class for expanding a function call into RTL.  */\n+class function_expander : public function_call_info\n+{\n+public:\n+  function_expander (const function_instance &, tree, tree, rtx);\n+  rtx expand ();\n+\n+  insn_code direct_optab_handler (optab, unsigned int = 0);\n+  insn_code direct_optab_handler_for_sign (optab, optab, unsigned int = 0,\n+\t\t\t\t\t   machine_mode = E_VOIDmode);\n+\n+  bool overlaps_input_p (rtx);\n+\n+  rtx get_contiguous_base (machine_mode);\n+  rtx get_fallback_value (machine_mode, unsigned int,\n+\t\t\t  unsigned int, unsigned int &);\n+  rtx get_reg_target ();\n+  rtx get_nonoverlapping_reg_target ();\n+\n+  void add_output_operand (insn_code);\n+  void add_input_operand (insn_code, rtx);\n+  void add_integer_operand (HOST_WIDE_INT);\n+  void add_mem_operand (machine_mode, rtx);\n+  void add_address_operand (rtx);\n+  void add_fixed_operand (rtx);\n+  rtx generate_insn (insn_code);\n+\n+  void prepare_gather_address_operands (unsigned int);\n+  void prepare_prefetch_operands ();\n+  void add_ptrue_hint (unsigned int, machine_mode);\n+  void rotate_inputs_left (unsigned int, unsigned int);\n+  bool try_negating_argument (unsigned int, machine_mode);\n+\n+  rtx use_exact_insn (insn_code);\n+  rtx use_unpred_insn (insn_code);\n+  rtx use_pred_x_insn (insn_code);\n+  rtx use_cond_insn (insn_code, unsigned int = DEFAULT_MERGE_ARGNO);\n+  rtx use_vcond_mask_insn (insn_code, unsigned int = DEFAULT_MERGE_ARGNO);\n+  rtx use_contiguous_load_insn (insn_code);\n+  rtx use_contiguous_prefetch_insn (insn_code);\n+  rtx use_contiguous_store_insn (insn_code);\n+\n+  rtx map_to_rtx_codes (rtx_code, rtx_code, int,\n+\t\t\tunsigned int = DEFAULT_MERGE_ARGNO);\n+  rtx map_to_unspecs (int, int, int, unsigned int = DEFAULT_MERGE_ARGNO);\n+  rtx expand_signed_unpred_op (rtx_code, rtx_code);\n+\n+  /* The function call expression.  */\n+  tree call_expr;\n+\n+  /* For functions that return a value, this is the preferred location\n+     of that value.  It could be null or could have a different mode\n+     from the function return type.  */\n+  rtx possible_target;\n+\n+  /* The expanded arguments.  */\n+  auto_vec<rtx, 16> args;\n+\n+private:\n+  /* Used to build up the operands to an instruction.  */\n+  auto_vec<expand_operand, 8> m_ops;\n+};\n+\n+/* Provides information about a particular function base name, and handles\n+   tasks related to the base name.  */\n+class function_base\n+{\n+public:\n+  /* Return a set of CP_* flags that describe what the function might do,\n+     in addition to reading its arguments and returning a result.  */\n+  virtual unsigned int call_properties (const function_instance &) const;\n+\n+  /* If the function operates on tuples of vectors, return the number\n+     of vectors in the tuples, otherwise return 1.  */\n+  virtual unsigned int vectors_per_tuple () const { return 1; }\n+\n+  /* If the function addresses memory, return the type of a single\n+     scalar memory element.  */\n+  virtual tree\n+  memory_scalar_type (const function_instance &) const\n+  {\n+    gcc_unreachable ();\n+  }\n+\n+  /* If the function addresses memory, return a vector mode whose\n+     GET_MODE_NUNITS is the number of elements addressed and whose\n+     GET_MODE_INNER is the mode of a single scalar memory element.  */\n+  virtual machine_mode\n+  memory_vector_mode (const function_instance &) const\n+  {\n+    gcc_unreachable ();\n+  }\n+\n+  /* Try to fold the given gimple call.  Return the new gimple statement\n+     on success, otherwise return null.  */\n+  virtual gimple *fold (gimple_folder &) const { return NULL; }\n+\n+  /* Expand the given call into rtl.  Return the result of the function,\n+     or an arbitrary value if the function doesn't return a result.  */\n+  virtual rtx expand (function_expander &) const = 0;\n+};\n+\n+/* Classifies functions into \"shapes\".  The idea is to take all the\n+   type signatures for a set of functions, remove the governing predicate\n+   (if any), and classify what's left based on:\n+\n+   - the number of arguments\n+\n+   - the process of determining the types in the signature from the mode\n+     and type suffixes in the function name (including types that are not\n+     affected by the suffixes)\n+\n+   - which arguments must be integer constant expressions, and what range\n+     those arguments have\n+\n+   - the process for mapping overloaded names to \"full\" names.  */\n+class function_shape\n+{\n+public:\n+  virtual bool explicit_type_suffix_p (unsigned int) const = 0;\n+\n+  /* Define all functions associated with the given group.  */\n+  virtual void build (function_builder &,\n+\t\t      const function_group_info &) const = 0;\n+\n+  /* Try to resolve the overloaded call.  Return the non-overloaded\n+     function decl on success and error_mark_node on failure.  */\n+  virtual tree resolve (function_resolver &) const = 0;\n+\n+  /* Check whether the given call is semantically valid.  Return true\n+     if it is, otherwise report an error and return false.  */\n+  virtual bool check (function_checker &) const { return true; }\n+};\n+\n+/* RAII class for enabling enough SVE features to define the built-in\n+   types and implement the arm_sve.h pragma.  */\n+class sve_switcher\n+{\n+public:\n+  sve_switcher ();\n+  ~sve_switcher ();\n+\n+private:\n+  unsigned long m_old_isa_flags;\n+  bool m_old_have_regs_of_mode[MAX_MACHINE_MODE];\n+};\n+\n+extern const type_suffix_info type_suffixes[NUM_TYPE_SUFFIXES + 1];\n+extern const mode_suffix_info mode_suffixes[MODE_none + 1];\n+\n+extern tree scalar_types[NUM_VECTOR_TYPES];\n+extern tree acle_vector_types[MAX_TUPLE_SIZE][NUM_VECTOR_TYPES + 1];\n+extern tree acle_svpattern;\n+extern tree acle_svprfop;\n+\n+/* Return the ACLE type svbool_t.  */\n+inline tree\n+get_svbool_t (void)\n+{\n+  return acle_vector_types[0][VECTOR_TYPE_svbool_t];\n+}\n+\n+/* Try to find a mode with the given mode_suffix_info fields.  Return the\n+   mode on success or MODE_none on failure.  */\n+inline mode_suffix_index\n+find_mode_suffix (vector_type_index base_vector_type,\n+\t\t  vector_type_index displacement_vector_type,\n+\t\t  units_index displacement_units)\n+{\n+  for (unsigned int mode_i = 0; mode_i < ARRAY_SIZE (mode_suffixes); ++mode_i)\n+    {\n+      const mode_suffix_info &mode = mode_suffixes[mode_i];\n+      if (mode.base_vector_type == base_vector_type\n+\t  && mode.displacement_vector_type == displacement_vector_type\n+\t  && mode.displacement_units == displacement_units)\n+\treturn mode_suffix_index (mode_i);\n+    }\n+  return MODE_none;\n+}\n+\n+/* Return the type suffix associated with ELEMENT_BITS-bit elements of type\n+   class TCLASS.  */\n+inline type_suffix_index\n+find_type_suffix (type_class_index tclass, unsigned int element_bits)\n+{\n+  for (unsigned int i = 0; i < NUM_TYPE_SUFFIXES; ++i)\n+    if (type_suffixes[i].tclass == tclass\n+\t&& type_suffixes[i].element_bits == element_bits)\n+      return type_suffix_index (i);\n+  gcc_unreachable ();\n+}\n+\n+/* Return the single field in tuple type TYPE.  */\n+inline tree\n+tuple_type_field (tree type)\n+{\n+  for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+    if (TREE_CODE (field) == FIELD_DECL)\n+      return field;\n+  gcc_unreachable ();\n+}\n+\n+inline function_instance::\n+function_instance (const char *base_name_in,\n+\t\t   const function_base *base_in,\n+\t\t   const function_shape *shape_in,\n+\t\t   mode_suffix_index mode_suffix_id_in,\n+\t\t   const type_suffix_pair &type_suffix_ids_in,\n+\t\t   predication_index pred_in)\n+  : base_name (base_name_in), base (base_in), shape (shape_in),\n+    mode_suffix_id (mode_suffix_id_in), pred (pred_in)\n+{\n+  memcpy (type_suffix_ids, type_suffix_ids_in, sizeof (type_suffix_ids));\n+}\n+\n+inline bool\n+function_instance::operator== (const function_instance &other) const\n+{\n+  return (base == other.base\n+\t  && shape == other.shape\n+\t  && mode_suffix_id == other.mode_suffix_id\n+\t  && pred == other.pred\n+\t  && type_suffix_ids[0] == other.type_suffix_ids[0]\n+\t  && type_suffix_ids[1] == other.type_suffix_ids[1]);\n+}\n+\n+inline bool\n+function_instance::operator!= (const function_instance &other) const\n+{\n+  return !operator== (other);\n+}\n+\n+/* If the function operates on tuples of vectors, return the number\n+   of vectors in the tuples, otherwise return 1.  */\n+inline unsigned int\n+function_instance::vectors_per_tuple () const\n+{\n+  return base->vectors_per_tuple ();\n+}\n+\n+/* If the function addresses memory, return the type of a single\n+   scalar memory element.  */\n+inline tree\n+function_instance::memory_scalar_type () const\n+{\n+  return base->memory_scalar_type (*this);\n+}\n+\n+/* If the function addresses memory, return a vector mode whose\n+   GET_MODE_NUNITS is the number of elements addressed and whose\n+   GET_MODE_INNER is the mode of a single scalar memory element.  */\n+inline machine_mode\n+function_instance::memory_vector_mode () const\n+{\n+  return base->memory_vector_mode (*this);\n+}\n+\n+/* Return information about the function's mode suffix.  */\n+inline const mode_suffix_info &\n+function_instance::mode_suffix () const\n+{\n+  return mode_suffixes[mode_suffix_id];\n+}\n+\n+/* Return the type of the function's vector base address argument,\n+   or null it doesn't have a vector base address.  */\n+inline tree\n+function_instance::base_vector_type () const\n+{\n+  return acle_vector_types[0][mode_suffix ().base_vector_type];\n+}\n+\n+/* Return the type of the function's vector index or offset argument,\n+   or null if doesn't have a vector index or offset argument.  */\n+inline tree\n+function_instance::displacement_vector_type () const\n+{\n+  return acle_vector_types[0][mode_suffix ().displacement_vector_type];\n+}\n+\n+/* If the function takes a vector or scalar displacement, return the units\n+   in which the displacement is measured, otherwise return UNITS_none.  */\n+inline units_index\n+function_instance::displacement_units () const\n+{\n+  return mode_suffix ().displacement_units;\n+}\n+\n+/* Return information about type suffix I.  */\n+inline const type_suffix_info &\n+function_instance::type_suffix (unsigned int i) const\n+{\n+  return type_suffixes[type_suffix_ids[i]];\n+}\n+\n+/* Return the scalar type associated with type suffix I.  */\n+inline tree\n+function_instance::scalar_type (unsigned int i) const\n+{\n+  return scalar_types[type_suffix (i).vector_type];\n+}\n+\n+/* Return the vector type associated with type suffix I.  */\n+inline tree\n+function_instance::vector_type (unsigned int i) const\n+{\n+  return acle_vector_types[0][type_suffix (i).vector_type];\n+}\n+\n+/* If the function operates on tuples of vectors, return the tuple type\n+   associated with type suffix I, otherwise return the vector type associated\n+   with type suffix I.  */\n+inline tree\n+function_instance::tuple_type (unsigned int i) const\n+{\n+  unsigned int num_vectors = vectors_per_tuple ();\n+  return acle_vector_types[num_vectors - 1][type_suffix (i).vector_type];\n+}\n+\n+/* Return the number of elements of type suffix I that fit within a\n+   128-bit block.  */\n+inline unsigned int\n+function_instance::elements_per_vq (unsigned int i) const\n+{\n+  return 128 / type_suffix (i).element_bits;\n+}\n+\n+/* Return the vector or predicate mode associated with type suffix I.  */\n+inline machine_mode\n+function_instance::vector_mode (unsigned int i) const\n+{\n+  return type_suffix (i).vector_mode;\n+}\n+\n+/* Return the mode of the governing predicate to use when operating on\n+   type suffix I.  */\n+inline machine_mode\n+function_instance::gp_mode (unsigned int i) const\n+{\n+  return aarch64_sve_pred_mode (type_suffix (i).element_bytes).require ();\n+}\n+\n+/* Return true if the function has no return value.  */\n+inline bool\n+function_call_info::function_returns_void_p ()\n+{\n+  return TREE_TYPE (TREE_TYPE (fndecl)) == void_type_node;\n+}\n+\n+/* Default implementation of function::call_properties, with conservatively\n+   correct behavior for floating-point instructions.  */\n+inline unsigned int\n+function_base::call_properties (const function_instance &instance) const\n+{\n+  unsigned int flags = 0;\n+  if (instance.type_suffix (0).float_p || instance.type_suffix (1).float_p)\n+    flags |= CP_READ_FPCR | CP_RAISE_FP_EXCEPTIONS;\n+  return flags;\n+}\n+\n+}\n+\n+#endif"}, {"sha": "57db06a3a770409a152e88801b83babc68395fc9", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 4000, "deletions": 266, "changes": 4266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc"}, {"sha": "9cafef46f38d71c6527d9fe39bd7638405bfb5c1", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 257, "deletions": 6, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -1744,7 +1744,7 @@ aarch64_get_mask_mode (poly_uint64 nunits, poly_uint64 nbytes)\n \n /* Return the SVE vector mode that has NUNITS elements of mode INNER_MODE.  */\n \n-static opt_machine_mode\n+opt_machine_mode\n aarch64_sve_data_mode (scalar_mode inner_mode, poly_uint64 nunits)\n {\n   enum mode_class mclass = (is_a <scalar_float_mode> (inner_mode)\n@@ -1772,7 +1772,7 @@ aarch64_sve_element_int_mode (machine_mode mode)\n    Unlike mode_for_int_vector, this can handle the case in which\n    MODE is a predicate (and thus has a different total size).  */\n \n-static machine_mode\n+machine_mode\n aarch64_sve_int_mode (machine_mode mode)\n {\n   scalar_int_mode int_mode = aarch64_sve_element_int_mode (mode);\n@@ -2764,6 +2764,27 @@ aarch64_widest_sve_pred_elt_size (rtx_vector_builder &builder)\n   return mask & -mask;\n }\n \n+/* If VNx16BImode rtx X is a canonical PTRUE for a predicate mode,\n+   return that predicate mode, otherwise return opt_machine_mode ().  */\n+\n+opt_machine_mode\n+aarch64_ptrue_all_mode (rtx x)\n+{\n+  gcc_assert (GET_MODE (x) == VNx16BImode);\n+  if (GET_CODE (x) != CONST_VECTOR\n+      || !CONST_VECTOR_DUPLICATE_P (x)\n+      || !CONST_INT_P (CONST_VECTOR_ENCODED_ELT (x, 0))\n+      || INTVAL (CONST_VECTOR_ENCODED_ELT (x, 0)) == 0)\n+    return opt_machine_mode ();\n+\n+  unsigned int nelts = const_vector_encoded_nelts (x);\n+  for (unsigned int i = 1; i < nelts; ++i)\n+    if (CONST_VECTOR_ENCODED_ELT (x, i) != const0_rtx)\n+      return opt_machine_mode ();\n+\n+  return aarch64_sve_pred_mode (nelts);\n+}\n+\n /* BUILDER is a predicate constant of mode VNx16BI.  Consider the value\n    that the constant would have with predicate element size ELT_SIZE\n    (ignoring the upper bits in each element) and return:\n@@ -2948,14 +2969,86 @@ aarch64_sve_emit_int_cmp (rtx target, machine_mode pred_mode, rtx_code cmp,\n    the corresponding SVE predicate mode.  Use TARGET for the result\n    if it's nonnull and convenient.  */\n \n-static rtx\n+rtx\n aarch64_convert_sve_data_to_pred (rtx target, machine_mode mode, rtx src)\n {\n   machine_mode src_mode = GET_MODE (src);\n   return aarch64_sve_emit_int_cmp (target, mode, NE, src_mode,\n \t\t\t\t   src, CONST0_RTX (src_mode));\n }\n \n+/* Return the assembly token for svprfop value PRFOP.  */\n+\n+static const char *\n+svprfop_token (enum aarch64_svprfop prfop)\n+{\n+  switch (prfop)\n+    {\n+#define CASE(UPPER, LOWER, VALUE) case AARCH64_SV_##UPPER: return #LOWER;\n+    AARCH64_FOR_SVPRFOP (CASE)\n+#undef CASE\n+    case AARCH64_NUM_SVPRFOPS:\n+      break;\n+    }\n+  gcc_unreachable ();\n+}\n+\n+/* Return the assembly string for an SVE prefetch operation with\n+   mnemonic MNEMONIC, given that PRFOP_RTX is the prefetch operation\n+   and that SUFFIX is the format for the remaining operands.  */\n+\n+char *\n+aarch64_output_sve_prefetch (const char *mnemonic, rtx prfop_rtx,\n+\t\t\t     const char *suffix)\n+{\n+  static char buffer[128];\n+  aarch64_svprfop prfop = (aarch64_svprfop) INTVAL (prfop_rtx);\n+  unsigned int written = snprintf (buffer, sizeof (buffer), \"%s\\t%s, %s\",\n+\t\t\t\t   mnemonic, svprfop_token (prfop), suffix);\n+  gcc_assert (written < sizeof (buffer));\n+  return buffer;\n+}\n+\n+/* Check whether we can calculate the number of elements in PATTERN\n+   at compile time, given that there are NELTS_PER_VQ elements per\n+   128-bit block.  Return the value if so, otherwise return -1.  */\n+\n+HOST_WIDE_INT\n+aarch64_fold_sve_cnt_pat (aarch64_svpattern pattern, unsigned int nelts_per_vq)\n+{\n+  unsigned int vl, const_vg;\n+  if (pattern >= AARCH64_SV_VL1 && pattern <= AARCH64_SV_VL8)\n+    vl = 1 + (pattern - AARCH64_SV_VL1);\n+  else if (pattern >= AARCH64_SV_VL16 && pattern <= AARCH64_SV_VL256)\n+    vl = 16 << (pattern - AARCH64_SV_VL16);\n+  else if (aarch64_sve_vg.is_constant (&const_vg))\n+    {\n+      /* There are two vector granules per quadword.  */\n+      unsigned int nelts = (const_vg / 2) * nelts_per_vq;\n+      switch (pattern)\n+\t{\n+\tcase AARCH64_SV_POW2: return 1 << floor_log2 (nelts);\n+\tcase AARCH64_SV_MUL4: return nelts & -4;\n+\tcase AARCH64_SV_MUL3: return (nelts / 3) * 3;\n+\tcase AARCH64_SV_ALL: return nelts;\n+\tdefault: gcc_unreachable ();\n+\t}\n+    }\n+  else\n+    return -1;\n+\n+  /* There are two vector granules per quadword.  */\n+  poly_uint64 nelts_all = exact_div (aarch64_sve_vg, 2) * nelts_per_vq;\n+  if (known_le (vl, nelts_all))\n+    return vl;\n+\n+  /* Requesting more elements than are available results in a PFALSE.  */\n+  if (known_gt (vl, nelts_all))\n+    return 0;\n+\n+  return -1;\n+}\n+\n /* Return true if we can move VALUE into a register using a single\n    CNT[BHWD] instruction.  */\n \n@@ -3038,6 +3131,24 @@ aarch64_output_sve_cnt_immediate (const char *prefix, const char *operands,\n \t\t\t\t\t   value.coeffs[1], 0);\n }\n \n+/* Return the asm string for an instruction with a CNT-like vector size\n+   operand (a vector pattern followed by a multiplier in the range [1, 16]).\n+   PREFIX is the mnemonic without the size suffix and OPERANDS is the\n+   first part of the operands template (the part that comes before the\n+   vector size itself).  CNT_PAT[0..2] are the operands of the\n+   UNSPEC_SVE_CNT_PAT; see aarch64_sve_cnt_pat for details.  */\n+\n+char *\n+aarch64_output_sve_cnt_pat_immediate (const char *prefix,\n+\t\t\t\t      const char *operands, rtx *cnt_pat)\n+{\n+  aarch64_svpattern pattern = (aarch64_svpattern) INTVAL (cnt_pat[0]);\n+  unsigned int nelts_per_vq = INTVAL (cnt_pat[1]);\n+  unsigned int factor = INTVAL (cnt_pat[2]) * nelts_per_vq;\n+  return aarch64_output_sve_cnt_immediate (prefix, operands, pattern,\n+\t\t\t\t\t   factor, nelts_per_vq);\n+}\n+\n /* Return true if we can add X using a single SVE INC or DEC instruction.  */\n \n bool\n@@ -3904,7 +4015,8 @@ aarch64_sve_move_pred_via_while (rtx target, machine_mode mode,\n {\n   rtx limit = force_reg (DImode, gen_int_mode (vl, DImode));\n   target = aarch64_target_reg (target, mode);\n-  emit_insn (gen_while_ult (DImode, mode, target, const0_rtx, limit));\n+  emit_insn (gen_while (UNSPEC_WHILE_LO, DImode, mode,\n+\t\t\ttarget, const0_rtx, limit));\n   return target;\n }\n \n@@ -4416,7 +4528,7 @@ aarch64_maybe_expand_sve_subreg_move (rtx dest, rtx src)\n    attributes.  Unlike gen_lowpart, this doesn't care whether the\n    mode change is valid.  */\n \n-static rtx\n+rtx\n aarch64_replace_reg_mode (rtx x, machine_mode mode)\n {\n   if (GET_MODE (x) == mode)\n@@ -11718,6 +11830,7 @@ static void\n aarch64_init_builtins ()\n {\n   aarch64_general_init_builtins ();\n+  aarch64_sve::init_builtins ();\n }\n \n /* Implement TARGET_FOLD_BUILTIN.  */\n@@ -11731,6 +11844,9 @@ aarch64_fold_builtin (tree fndecl, int nargs, tree *args, bool)\n     {\n     case AARCH64_BUILTIN_GENERAL:\n       return aarch64_general_fold_builtin (subcode, type, nargs, args);\n+\n+    case AARCH64_BUILTIN_SVE:\n+      return NULL_TREE;\n     }\n   gcc_unreachable ();\n }\n@@ -11749,6 +11865,10 @@ aarch64_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case AARCH64_BUILTIN_GENERAL:\n       new_stmt = aarch64_general_gimple_fold_builtin (subcode, stmt);\n       break;\n+\n+    case AARCH64_BUILTIN_SVE:\n+      new_stmt = aarch64_sve::gimple_fold_builtin (subcode, gsi, stmt);\n+      break;\n     }\n \n   if (!new_stmt)\n@@ -11769,6 +11889,9 @@ aarch64_expand_builtin (tree exp, rtx target, rtx, machine_mode, int ignore)\n     {\n     case AARCH64_BUILTIN_GENERAL:\n       return aarch64_general_expand_builtin (subcode, exp, target, ignore);\n+\n+    case AARCH64_BUILTIN_SVE:\n+      return aarch64_sve::expand_builtin (subcode, exp, target);\n     }\n   gcc_unreachable ();\n }\n@@ -11782,6 +11905,9 @@ aarch64_builtin_decl (unsigned int code, bool initialize_p)\n     {\n     case AARCH64_BUILTIN_GENERAL:\n       return aarch64_general_builtin_decl (subcode, initialize_p);\n+\n+    case AARCH64_BUILTIN_SVE:\n+      return aarch64_sve::builtin_decl (subcode, initialize_p);\n     }\n   gcc_unreachable ();\n }\n@@ -11815,6 +11941,9 @@ aarch64_builtin_reciprocal (tree fndecl)\n     {\n     case AARCH64_BUILTIN_GENERAL:\n       return aarch64_general_builtin_rsqrt (subcode);\n+\n+    case AARCH64_BUILTIN_SVE:\n+      return NULL_TREE;\n     }\n   gcc_unreachable ();\n }\n@@ -15259,7 +15388,12 @@ aarch64_mangle_type (const_tree type)\n   /* Mangle AArch64-specific internal types.  TYPE_NAME is non-NULL_TREE for\n      builtin types.  */\n   if (TYPE_NAME (type) != NULL)\n-    return aarch64_general_mangle_builtin_type (type);\n+    {\n+      const char *res;\n+      if ((res = aarch64_general_mangle_builtin_type (type))\n+\t  || (res = aarch64_sve::mangle_builtin_type (type)))\n+\treturn res;\n+    }\n \n   /* Use the default mangling.  */\n   return NULL;\n@@ -15417,6 +15551,27 @@ aarch64_sve_arith_immediate_p (rtx x, bool negate_p)\n   return IN_RANGE (val, 0, 0xff00);\n }\n \n+/* Return true if X is a valid immediate for the SVE SQADD and SQSUB\n+   instructions.  Negate X first if NEGATE_P is true.  */\n+\n+bool\n+aarch64_sve_sqadd_sqsub_immediate_p (rtx x, bool negate_p)\n+{\n+  rtx elt;\n+\n+  if (!const_vec_duplicate_p (x, &elt)\n+      || !CONST_INT_P (elt))\n+    return false;\n+\n+  if (!aarch64_sve_arith_immediate_p (x, negate_p))\n+    return false;\n+\n+  /* After the optional negation, the immediate must be nonnegative.\n+     E.g. a saturating add of -127 must be done via SQSUB Zn.B, Zn.B, #127\n+     instead of SQADD Zn.B, Zn.B, #129.  */\n+  return negate_p == (INTVAL (elt) < 0);\n+}\n+\n /* Return true if X is a valid immediate operand for an SVE logical\n    instruction such as AND.  */\n \n@@ -15649,12 +15804,45 @@ aarch64_sve_valid_immediate (unsigned HOST_WIDE_INT val64,\n   return false;\n }\n \n+/* Return true if X is an UNSPEC_PTRUE constant of the form:\n+\n+       (const (unspec [PATTERN ZERO] UNSPEC_PTRUE))\n+\n+   where PATTERN is the svpattern as a CONST_INT and where ZERO\n+   is a zero constant of the required PTRUE mode (which can have\n+   fewer elements than X's mode, if zero bits are significant).\n+\n+   If so, and if INFO is nonnull, describe the immediate in INFO.  */\n+bool\n+aarch64_sve_ptrue_svpattern_p (rtx x, struct simd_immediate_info *info)\n+{\n+  if (GET_CODE (x) != CONST)\n+    return false;\n+\n+  x = XEXP (x, 0);\n+  if (GET_CODE (x) != UNSPEC || XINT (x, 1) != UNSPEC_PTRUE)\n+    return false;\n+\n+  if (info)\n+    {\n+      aarch64_svpattern pattern\n+\t= (aarch64_svpattern) INTVAL (XVECEXP (x, 0, 0));\n+      machine_mode pred_mode = GET_MODE (XVECEXP (x, 0, 1));\n+      scalar_int_mode int_mode = aarch64_sve_element_int_mode (pred_mode);\n+      *info = simd_immediate_info (int_mode, pattern);\n+    }\n+  return true;\n+}\n+\n /* Return true if X is a valid SVE predicate.  If INFO is nonnull, use\n    it to describe valid immediates.  */\n \n static bool\n aarch64_sve_pred_valid_immediate (rtx x, simd_immediate_info *info)\n {\n+  if (aarch64_sve_ptrue_svpattern_p (x, info))\n+    return true;\n+\n   if (x == CONST0_RTX (GET_MODE (x)))\n     {\n       if (info)\n@@ -16063,6 +16251,35 @@ aarch64_sve_ld1rq_operand_p (rtx op)\n   return false;\n }\n \n+/* Return true if OP is a valid MEM operand for an SVE LDFF1 instruction.  */\n+bool\n+aarch64_sve_ldff1_operand_p (rtx op)\n+{\n+  if (!MEM_P (op))\n+    return false;\n+\n+  struct aarch64_address_info addr;\n+  if (!aarch64_classify_address (&addr, XEXP (op, 0), GET_MODE (op), false))\n+    return false;\n+\n+  if (addr.type == ADDRESS_REG_IMM)\n+    return known_eq (addr.const_offset, 0);\n+\n+  return addr.type == ADDRESS_REG_REG;\n+}\n+\n+/* Return true if OP is a valid MEM operand for an SVE LDNF1 instruction.  */\n+bool\n+aarch64_sve_ldnf1_operand_p (rtx op)\n+{\n+  struct aarch64_address_info addr;\n+\n+  return (MEM_P (op)\n+\t  && aarch64_classify_address (&addr, XEXP (op, 0),\n+\t\t\t\t       GET_MODE (op), false)\n+\t  && addr.type == ADDRESS_REG_IMM);\n+}\n+\n /* Return true if OP is a valid MEM operand for an SVE LDR instruction.\n    The conditions for STR are the same.  */\n bool\n@@ -16076,6 +16293,21 @@ aarch64_sve_ldr_operand_p (rtx op)\n \t  && addr.type == ADDRESS_REG_IMM);\n }\n \n+/* Return true if OP is a valid address for an SVE PRF[BHWD] instruction,\n+   addressing memory of mode MODE.  */\n+bool\n+aarch64_sve_prefetch_operand_p (rtx op, machine_mode mode)\n+{\n+  struct aarch64_address_info addr;\n+  if (!aarch64_classify_address (&addr, op, mode, false))\n+    return false;\n+\n+  if (addr.type == ADDRESS_REG_IMM)\n+    return known_eq (addr.const_offset, 0);\n+\n+  return addr.type == ADDRESS_REG_REG;\n+}\n+\n /* Return true if OP is a valid MEM operand for an SVE_STRUCT mode.\n    We need to be able to access the individual pieces, so the range\n    is different from LD[234] and ST[234].  */\n@@ -17704,6 +17936,25 @@ aarch64_output_sve_mov_immediate (rtx const_vector)\n   return templ;\n }\n \n+/* Return the asm template for a PTRUES.  CONST_UNSPEC is the\n+   aarch64_sve_ptrue_svpattern_immediate that describes the predicate\n+   pattern.  */\n+\n+char *\n+aarch64_output_sve_ptrues (rtx const_unspec)\n+{\n+  static char templ[40];\n+\n+  struct simd_immediate_info info;\n+  bool is_valid = aarch64_simd_valid_immediate (const_unspec, &info);\n+  gcc_assert (is_valid && info.insn == simd_immediate_info::PTRUE);\n+\n+  char element_char = sizetochar (GET_MODE_BITSIZE (info.elt_mode));\n+  snprintf (templ, sizeof (templ), \"ptrues\\t%%0.%c, %s\", element_char,\n+\t    svpattern_token (info.u.pattern));\n+  return templ;\n+}\n+\n /* Split operands into moves from op[1] + op[2] into op[0].  */\n \n void"}, {"sha": "d1fe17366d2b663a09fb76c4ad87a76c9b700ec6", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -226,28 +226,48 @@\n     UNSPEC_XPACLRI\n     UNSPEC_LD1_SVE\n     UNSPEC_ST1_SVE\n+    UNSPEC_LDNT1_SVE\n+    UNSPEC_STNT1_SVE\n     UNSPEC_LD1RQ\n     UNSPEC_LD1_GATHER\n+    UNSPEC_LDFF1_GATHER\n     UNSPEC_ST1_SCATTER\n     UNSPEC_PRED_X\n     UNSPEC_PRED_Z\n     UNSPEC_PTEST\n+    UNSPEC_PTRUE\n     UNSPEC_UNPACKSHI\n     UNSPEC_UNPACKUHI\n     UNSPEC_UNPACKSLO\n     UNSPEC_UNPACKULO\n     UNSPEC_PACK\n+    UNSPEC_WHILE_LE\n     UNSPEC_WHILE_LO\n+    UNSPEC_WHILE_LS\n+    UNSPEC_WHILE_LT\n     UNSPEC_LDN\n     UNSPEC_STN\n     UNSPEC_INSR\n+    UNSPEC_CLASTA\n     UNSPEC_CLASTB\n     UNSPEC_FADDA\n     UNSPEC_REV_SUBREG\n     UNSPEC_REINTERPRET\n     UNSPEC_SPECULATION_TRACKER\n     UNSPEC_COPYSIGN\n     UNSPEC_TTEST\t\t; Represent transaction test.\n+    UNSPEC_UPDATE_FFR\n+    UNSPEC_UPDATE_FFRT\n+    UNSPEC_RDFFR\n+    UNSPEC_WRFFR\n+    ;; Represents an SVE-style lane index, in which the indexing applies\n+    ;; within the containing 128-bit block.\n+    UNSPEC_SVE_LANE_SELECT\n+    UNSPEC_SVE_CNT_PAT\n+    UNSPEC_SVE_PREFETCH\n+    UNSPEC_SVE_PREFETCH_GATHER\n+    UNSPEC_SVE_COMPACT\n+    UNSPEC_SVE_SPLICE\n ])\n \n (define_c_enum \"unspecv\" ["}, {"sha": "b76d321a47e88a0e61bde3d99c8e15841ecdb055", "filename": "gcc/config/aarch64/arm_sve.h", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Farm_sve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Farm_sve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Farm_sve.h?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,36 @@\n+/* AArch64 SVE intrinsics include file.\n+   Copyright (C) 2018-2019 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _ARM_SVE_H_\n+#define _ARM_SVE_H_\n+\n+#include <stdint.h>\n+\n+typedef __fp16 float16_t;\n+typedef float float32_t;\n+typedef double float64_t;\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+#endif"}, {"sha": "d0c3dd5bc1f1b61457299b30241c02e3e101b608", "filename": "gcc/config/aarch64/constraints.md", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fconstraints.md?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -257,6 +257,38 @@\n \t\t\t\t\t\t  true,\n \t\t\t\t\t\t  ADDR_QUERY_LDP_STP_N)\")))\n \n+(define_address_constraint \"UPb\"\n+  \"@internal\n+   An address valid for SVE PRFB instructions.\"\n+  (match_test \"aarch64_sve_prefetch_operand_p (op, VNx16QImode)\"))\n+\n+(define_address_constraint \"UPd\"\n+  \"@internal\n+   An address valid for SVE PRFD instructions.\"\n+  (match_test \"aarch64_sve_prefetch_operand_p (op, VNx2DImode)\"))\n+\n+(define_address_constraint \"UPh\"\n+  \"@internal\n+   An address valid for SVE PRFH instructions.\"\n+  (match_test \"aarch64_sve_prefetch_operand_p (op, VNx8HImode)\"))\n+\n+(define_address_constraint \"UPw\"\n+  \"@internal\n+   An address valid for SVE PRFW instructions.\"\n+  (match_test \"aarch64_sve_prefetch_operand_p (op, VNx4SImode)\"))\n+\n+(define_memory_constraint \"Utf\"\n+  \"@internal\n+   An address valid for SVE LDFF1 instructions.\"\n+  (and (match_code \"mem\")\n+       (match_test \"aarch64_sve_ldff1_operand_p (op)\")))\n+\n+(define_memory_constraint \"Utn\"\n+  \"@internal\n+   An address valid for SVE LDNF1 instructions.\"\n+  (and (match_code \"mem\")\n+       (match_test \"aarch64_sve_ldnf1_operand_p (op)\")))\n+\n (define_memory_constraint \"Utr\"\n   \"@internal\n    An address valid for SVE LDR and STR instructions (as distinct from\n@@ -395,6 +427,30 @@\n  An address valid for a prefetch instruction.\"\n  (match_test \"aarch64_address_valid_for_prefetch_p (op, true)\"))\n \n+(define_constraint \"vgb\"\n+  \"@internal\n+   A constraint that matches an immediate offset valid for SVE LD1B\n+   gather instructions.\"\n+ (match_operand 0 \"aarch64_sve_gather_immediate_b\"))\n+\n+(define_constraint \"vgd\"\n+  \"@internal\n+   A constraint that matches an immediate offset valid for SVE LD1D\n+   gather instructions.\"\n+ (match_operand 0 \"aarch64_sve_gather_immediate_d\"))\n+\n+(define_constraint \"vgh\"\n+  \"@internal\n+   A constraint that matches an immediate offset valid for SVE LD1H\n+   gather instructions.\"\n+ (match_operand 0 \"aarch64_sve_gather_immediate_h\"))\n+\n+(define_constraint \"vgw\"\n+  \"@internal\n+   A constraint that matches an immediate offset valid for SVE LD1W\n+   gather instructions.\"\n+ (match_operand 0 \"aarch64_sve_gather_immediate_w\"))\n+\n (define_constraint \"vsa\"\n   \"@internal\n    A constraint that matches an immediate operand valid for SVE\n@@ -437,6 +493,18 @@\n    is valid for SVE SUB instructions.\"\n  (match_operand 0 \"aarch64_sve_sub_arith_immediate\"))\n \n+(define_constraint \"vsQ\"\n+  \"@internal\n+   Like vsa, but additionally check that the immediate is nonnegative\n+   when interpreted as a signed value.\"\n+ (match_operand 0 \"aarch64_sve_qadd_immediate\"))\n+\n+(define_constraint \"vsS\"\n+  \"@internal\n+   Like vsn, but additionally check that the immediate is negative\n+   when interpreted as a signed value.\"\n+ (match_operand 0 \"aarch64_sve_qsub_immediate\"))\n+\n (define_constraint \"vsl\"\n   \"@internal\n    A constraint that matches an immediate operand valid for SVE logical"}, {"sha": "d0ede24e9b042f584d9a04c9e7c1b716c59705ca", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 330, "deletions": 13, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -35,6 +35,10 @@\n ;; Iterator for QI and HI modes\n (define_mode_iterator SHORT [QI HI])\n \n+;; Iterators for single modes, for \"@\" patterns.\n+(define_mode_iterator SI_ONLY [SI])\n+(define_mode_iterator DI_ONLY [DI])\n+\n ;; Iterator for all integer modes (up to 64-bit)\n (define_mode_iterator ALLI [QI HI SI DI])\n \n@@ -285,7 +289,9 @@\n \t\t\t       VNx8HF VNx4SF VNx2DF])\n \n ;; Iterators for single modes, for \"@\" patterns.\n+(define_mode_iterator VNx8HI_ONLY [VNx8HI])\n (define_mode_iterator VNx4SI_ONLY [VNx4SI])\n+(define_mode_iterator VNx2DI_ONLY [VNx2DI])\n (define_mode_iterator VNx2DF_ONLY [VNx2DF])\n \n ;; All SVE vector structure modes.\n@@ -335,12 +341,33 @@\n ;; All SVE floating-point vector modes.\n (define_mode_iterator SVE_F [VNx8HF VNx4SF VNx2DF])\n \n+;; All partial SVE modes.\n+(define_mode_iterator SVE_PARTIAL [VNx2QI\n+\t\t\t\t   VNx4QI VNx2HI\n+\t\t\t\t   VNx8QI VNx4HI VNx2SI])\n+\n+;; Modes involved in extending or truncating SVE data, for 8 elements per\n+;; 128-bit block.\n+(define_mode_iterator VNx8_NARROW [VNx8QI])\n+(define_mode_iterator VNx8_WIDE [VNx8HI])\n+\n+;; ...same for 4 elements per 128-bit block.\n+(define_mode_iterator VNx4_NARROW [VNx4QI VNx4HI])\n+(define_mode_iterator VNx4_WIDE [VNx4SI])\n+\n+;; ...same for 2 elements per 128-bit block.\n+(define_mode_iterator VNx2_NARROW [VNx2QI VNx2HI VNx2SI])\n+(define_mode_iterator VNx2_WIDE [VNx2DI])\n+\n ;; All SVE predicate modes.\n (define_mode_iterator PRED_ALL [VNx16BI VNx8BI VNx4BI VNx2BI])\n \n ;; SVE predicate modes that control 8-bit, 16-bit or 32-bit elements.\n (define_mode_iterator PRED_BHS [VNx16BI VNx8BI VNx4BI])\n \n+;; SVE predicate modes that control 16-bit, 32-bit or 64-bit elements.\n+(define_mode_iterator PRED_HSD [VNx8BI VNx4BI VNx2BI])\n+\n ;; ------------------------------------------------------------------\n ;; Unspec enumerations for Advance SIMD. These could well go into\n ;; aarch64.md but for their use in int_iterators here.\n@@ -483,7 +510,18 @@\n     UNSPEC_FMLSL\t; Used in aarch64-simd.md.\n     UNSPEC_FMLAL2\t; Used in aarch64-simd.md.\n     UNSPEC_FMLSL2\t; Used in aarch64-simd.md.\n+    UNSPEC_ADR\t\t; Used in aarch64-sve.md.\n     UNSPEC_SEL\t\t; Used in aarch64-sve.md.\n+    UNSPEC_BRKA\t\t; Used in aarch64-sve.md.\n+    UNSPEC_BRKB\t\t; Used in aarch64-sve.md.\n+    UNSPEC_BRKN\t\t; Used in aarch64-sve.md.\n+    UNSPEC_BRKPA\t; Used in aarch64-sve.md.\n+    UNSPEC_BRKPB\t; Used in aarch64-sve.md.\n+    UNSPEC_PFIRST\t; Used in aarch64-sve.md.\n+    UNSPEC_PNEXT\t; Used in aarch64-sve.md.\n+    UNSPEC_CNTP\t\t; Used in aarch64-sve.md.\n+    UNSPEC_SADDV\t; Used in aarch64-sve.md.\n+    UNSPEC_UADDV\t; Used in aarch64-sve.md.\n     UNSPEC_ANDV\t\t; Used in aarch64-sve.md.\n     UNSPEC_IORV\t\t; Used in aarch64-sve.md.\n     UNSPEC_XORV\t\t; Used in aarch64-sve.md.\n@@ -495,11 +533,33 @@\n     UNSPEC_REVW\t\t; Used in aarch64-sve.md.\n     UNSPEC_SMUL_HIGHPART ; Used in aarch64-sve.md.\n     UNSPEC_UMUL_HIGHPART ; Used in aarch64-sve.md.\n+    UNSPEC_FMLA\t\t; Used in aarch64-sve.md.\n+    UNSPEC_FMLS\t\t; Used in aarch64-sve.md.\n+    UNSPEC_FEXPA\t; Used in aarch64-sve.md.\n+    UNSPEC_FTMAD\t; Used in aarch64-sve.md.\n+    UNSPEC_FTSMUL\t; Used in aarch64-sve.md.\n+    UNSPEC_FTSSEL\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_CMPEQ_WIDE ; Used in aarch64-sve.md.\n+    UNSPEC_COND_CMPGE_WIDE ; Used in aarch64-sve.md.\n+    UNSPEC_COND_CMPGT_WIDE ; Used in aarch64-sve.md.\n+    UNSPEC_COND_CMPHI_WIDE ; Used in aarch64-sve.md.\n+    UNSPEC_COND_CMPHS_WIDE ; Used in aarch64-sve.md.\n+    UNSPEC_COND_CMPLE_WIDE ; Used in aarch64-sve.md.\n+    UNSPEC_COND_CMPLO_WIDE ; Used in aarch64-sve.md.\n+    UNSPEC_COND_CMPLS_WIDE ; Used in aarch64-sve.md.\n+    UNSPEC_COND_CMPLT_WIDE ; Used in aarch64-sve.md.\n+    UNSPEC_COND_CMPNE_WIDE ; Used in aarch64-sve.md.\n     UNSPEC_COND_FABS\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FADD\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_FCADD90\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_FCADD270 ; Used in aarch64-sve.md.\n     UNSPEC_COND_FCMEQ\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FCMGE\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FCMGT\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_FCMLA\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_FCMLA90\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_FCMLA180 ; Used in aarch64-sve.md.\n+    UNSPEC_COND_FCMLA270 ; Used in aarch64-sve.md.\n     UNSPEC_COND_FCMLE\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FCMLT\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FCMNE\t; Used in aarch64-sve.md.\n@@ -508,26 +568,37 @@\n     UNSPEC_COND_FCVTZS\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FCVTZU\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FDIV\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_FMAX\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FMAXNM\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_FMIN\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FMINNM\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FMLA\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FMLS\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FMUL\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_FMULX\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FNEG\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FNMLA\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FNMLS\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_FRECPX\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FRINTA\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FRINTI\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FRINTM\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FRINTN\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FRINTP\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FRINTX\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FRINTZ\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_FSCALE\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FSQRT\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FSUB\t; Used in aarch64-sve.md.\n     UNSPEC_COND_SCVTF\t; Used in aarch64-sve.md.\n     UNSPEC_COND_UCVTF\t; Used in aarch64-sve.md.\n+    UNSPEC_LASTA\t; Used in aarch64-sve.md.\n     UNSPEC_LASTB\t; Used in aarch64-sve.md.\n+    UNSPEC_ASHIFT_WIDE  ; Used in aarch64-sve.md.\n+    UNSPEC_ASHIFTRT_WIDE ; Used in aarch64-sve.md.\n+    UNSPEC_LSHIFTRT_WIDE ; Used in aarch64-sve.md.\n+    UNSPEC_LDFF1\t; Used in aarch64-sve.md.\n+    UNSPEC_LDNF1\t; Used in aarch64-sve.md.\n     UNSPEC_FCADD90\t; Used in aarch64-simd.md.\n     UNSPEC_FCADD270\t; Used in aarch64-simd.md.\n     UNSPEC_FCMLA\t; Used in aarch64-simd.md.\n@@ -723,9 +794,11 @@\n (define_mode_attr Vetype_fourth [(VNx4SI \"b\") (VNx2DI \"h\")])\n \n ;; Equivalent of \"size\" for a vector element.\n-(define_mode_attr Vesize [(VNx16QI \"b\")\n-\t\t\t  (VNx8HI  \"h\") (VNx8HF  \"h\")\n-\t\t\t  (VNx4SI  \"w\") (VNx4SF  \"w\")\n+(define_mode_attr Vesize [(VNx16QI \"b\") (VNx8QI  \"b\")\n+\t\t\t  (VNx4QI  \"b\") (VNx2QI  \"b\")\n+\t\t\t  (VNx8HI  \"h\") (VNx4HI  \"h\")\n+\t\t\t  (VNx2HI  \"h\") (VNx8HF  \"h\")\n+\t\t\t  (VNx4SI  \"w\") (VNx2SI  \"w\") (VNx4SF  \"w\")\n \t\t\t  (VNx2DI  \"d\") (VNx2DF  \"d\")\n \t\t\t  (VNx32QI \"b\") (VNx48QI \"b\") (VNx64QI \"b\")\n \t\t\t  (VNx16HI \"h\") (VNx24HI \"h\") (VNx32HI \"h\")\n@@ -1221,6 +1294,26 @@\n (define_mode_attr data_bytes [(VNx16BI \"1\") (VNx8BI \"2\")\n \t\t\t      (VNx4BI \"4\") (VNx2BI \"8\")])\n \n+;; Two-nybble mask for partial vector modes: nunits, byte size.\n+(define_mode_attr self_mask [(VNx8QI \"0x81\")\n+\t\t\t     (VNx4QI \"0x41\")\n+\t\t\t     (VNx2QI \"0x21\")\n+\t\t\t     (VNx4HI \"0x42\")\n+\t\t\t     (VNx2HI \"0x22\")\n+\t\t\t     (VNx2SI \"0x24\")])\n+\n+;; For full vector modes, the mask of narrower modes, encoded as above.\n+(define_mode_attr narrower_mask [(VNx8HI \"0x81\")\n+\t\t\t\t (VNx4SI \"0x43\")\n+\t\t\t\t (VNx2DI \"0x27\")])\n+\n+;; The constraint to use for an SVE [SU]DOT, FMUL, FMLA or FMLS lane index.\n+(define_mode_attr sve_lane_con [(VNx4SI \"y\") (VNx2DI \"x\")\n+\t\t\t\t(VNx8HF \"y\") (VNx4SF \"y\") (VNx2DF \"x\")])\n+\n+;; The constraint to use for an SVE FCMLA lane index.\n+(define_mode_attr sve_lane_pair_con [(VNx8HF \"y\") (VNx4SF \"x\")])\n+\n ;; -------------------------------------------------------------------\n ;; Code Iterators\n ;; -------------------------------------------------------------------\n@@ -1291,6 +1384,21 @@\n ;; Code iterator for signed variants of vector saturating binary ops.\n (define_code_iterator SBINQOPS [ss_plus ss_minus])\n \n+;; Code iterator for unsigned variants of vector saturating binary ops.\n+(define_code_iterator UBINQOPS [us_plus us_minus])\n+\n+;; Modular and saturating addition.\n+(define_code_iterator ANY_PLUS [plus ss_plus us_plus])\n+\n+;; Saturating addition.\n+(define_code_iterator SAT_PLUS [ss_plus us_plus])\n+\n+;; Modular and saturating subtraction.\n+(define_code_iterator ANY_MINUS [minus ss_minus us_minus])\n+\n+;; Saturating subtraction.\n+(define_code_iterator SAT_MINUS [ss_minus us_minus])\n+\n ;; Comparison operators for <F>CM.\n (define_code_iterator COMPARISONS [lt le eq ge gt])\n \n@@ -1441,6 +1549,15 @@\n \t\t      (smax \"s\") (umax \"u\")\n \t\t      (smin \"s\") (umin \"u\")])\n \n+;; \"s\" for signed ops, empty for unsigned ones.\n+(define_code_attr s [(sign_extend \"s\") (zero_extend \"\")])\n+\n+;; Map signed/unsigned ops to the corresponding extension.\n+(define_code_attr paired_extend [(ss_plus \"sign_extend\")\n+\t\t\t\t (us_plus \"zero_extend\")\n+\t\t\t\t (ss_minus \"sign_extend\")\n+\t\t\t\t (us_minus \"zero_extend\")])\n+\n ;; Whether a shift is left or right.\n (define_code_attr lr [(ashift \"l\") (ashiftrt \"r\") (lshiftrt \"r\")])\n \n@@ -1574,6 +1691,9 @@\n    (ior \"register_operand\")\n    (xor \"register_operand\")])\n \n+(define_code_attr inc_dec [(minus \"dec\") (ss_minus \"sqdec\") (us_minus \"uqdec\")\n+\t\t\t   (plus \"inc\") (ss_plus \"sqinc\") (us_plus \"uqinc\")])\n+\n ;; -------------------------------------------------------------------\n ;; Int Iterators.\n ;; -------------------------------------------------------------------\n@@ -1593,6 +1713,8 @@\n (define_int_iterator FMAXMINV [UNSPEC_FMAXV UNSPEC_FMINV\n \t\t\t       UNSPEC_FMAXNMV UNSPEC_FMINNMV])\n \n+(define_int_iterator SVE_INT_ADDV [UNSPEC_SADDV UNSPEC_UADDV])\n+\n (define_int_iterator LOGICALF [UNSPEC_ANDF UNSPEC_IORF UNSPEC_XORF])\n \n (define_int_iterator HADDSUB [UNSPEC_SHADD UNSPEC_UHADD\n@@ -1714,7 +1836,20 @@\n \n (define_int_iterator MUL_HIGHPART [UNSPEC_SMUL_HIGHPART UNSPEC_UMUL_HIGHPART])\n \n-(define_int_iterator SVE_INT_UNARY [UNSPEC_REVB UNSPEC_REVH UNSPEC_REVW])\n+(define_int_iterator CLAST [UNSPEC_CLASTA UNSPEC_CLASTB])\n+\n+(define_int_iterator LAST [UNSPEC_LASTA UNSPEC_LASTB])\n+\n+(define_int_iterator SVE_INT_UNARY [UNSPEC_RBIT UNSPEC_REVB\n+\t\t\t\t    UNSPEC_REVH UNSPEC_REVW])\n+\n+(define_int_iterator SVE_FP_UNARY [UNSPEC_FRECPE UNSPEC_RSQRTE])\n+\n+(define_int_iterator SVE_FP_UNARY_INT [UNSPEC_FEXPA])\n+\n+(define_int_iterator SVE_FP_BINARY [UNSPEC_FRECPS UNSPEC_RSQRTS])\n+\n+(define_int_iterator SVE_FP_BINARY_INT [UNSPEC_FTSMUL UNSPEC_FTSSEL])\n \n (define_int_iterator SVE_INT_REDUCTION [UNSPEC_ANDV\n \t\t\t\t\tUNSPEC_IORV\n@@ -1732,6 +1867,7 @@\n \n (define_int_iterator SVE_COND_FP_UNARY [UNSPEC_COND_FABS\n \t\t\t\t\tUNSPEC_COND_FNEG\n+\t\t\t\t\tUNSPEC_COND_FRECPX\n \t\t\t\t\tUNSPEC_COND_FRINTA\n \t\t\t\t\tUNSPEC_COND_FRINTI\n \t\t\t\t\tUNSPEC_COND_FRINTM\n@@ -1747,16 +1883,36 @@\n \n (define_int_iterator SVE_COND_FP_BINARY [UNSPEC_COND_FADD\n \t\t\t\t\t UNSPEC_COND_FDIV\n+\t\t\t\t\t UNSPEC_COND_FMAX\n \t\t\t\t\t UNSPEC_COND_FMAXNM\n+\t\t\t\t\t UNSPEC_COND_FMIN\n \t\t\t\t\t UNSPEC_COND_FMINNM\n \t\t\t\t\t UNSPEC_COND_FMUL\n+\t\t\t\t\t UNSPEC_COND_FMULX\n \t\t\t\t\t UNSPEC_COND_FSUB])\n \n-(define_int_iterator SVE_COND_FP_BINARY_I1 [UNSPEC_COND_FMAXNM\n+(define_int_iterator SVE_COND_FP_BINARY_INT [UNSPEC_COND_FSCALE])\n+\n+(define_int_iterator SVE_COND_FP_ADD [UNSPEC_COND_FADD])\n+(define_int_iterator SVE_COND_FP_SUB [UNSPEC_COND_FSUB])\n+(define_int_iterator SVE_COND_FP_MUL [UNSPEC_COND_FMUL])\n+\n+(define_int_iterator SVE_COND_FP_BINARY_I1 [UNSPEC_COND_FMAX\n+\t\t\t\t\t    UNSPEC_COND_FMAXNM\n+\t\t\t\t\t    UNSPEC_COND_FMIN\n \t\t\t\t\t    UNSPEC_COND_FMINNM\n \t\t\t\t\t    UNSPEC_COND_FMUL])\n \n-(define_int_iterator SVE_COND_FP_BINARY_REG [UNSPEC_COND_FDIV])\n+(define_int_iterator SVE_COND_FP_BINARY_REG [UNSPEC_COND_FDIV\n+\t\t\t\t\t     UNSPEC_COND_FMULX])\n+\n+(define_int_iterator SVE_COND_FCADD [UNSPEC_COND_FCADD90\n+\t\t\t\t     UNSPEC_COND_FCADD270])\n+\n+(define_int_iterator SVE_COND_FP_MAXMIN [UNSPEC_COND_FMAX\n+\t\t\t\t\t UNSPEC_COND_FMAXNM\n+\t\t\t\t\t UNSPEC_COND_FMIN\n+\t\t\t\t\t UNSPEC_COND_FMINNM])\n \n ;; Floating-point max/min operations that correspond to optabs,\n ;; as opposed to those that are internal to the port.\n@@ -1768,6 +1924,22 @@\n \t\t\t\t\t  UNSPEC_COND_FNMLA\n \t\t\t\t\t  UNSPEC_COND_FNMLS])\n \n+(define_int_iterator SVE_COND_FCMLA [UNSPEC_COND_FCMLA\n+\t\t\t\t     UNSPEC_COND_FCMLA90\n+\t\t\t\t     UNSPEC_COND_FCMLA180\n+\t\t\t\t     UNSPEC_COND_FCMLA270])\n+\n+(define_int_iterator SVE_COND_INT_CMP_WIDE [UNSPEC_COND_CMPEQ_WIDE\n+\t\t\t\t\t    UNSPEC_COND_CMPGE_WIDE\n+\t\t\t\t\t    UNSPEC_COND_CMPGT_WIDE\n+\t\t\t\t\t    UNSPEC_COND_CMPHI_WIDE\n+\t\t\t\t\t    UNSPEC_COND_CMPHS_WIDE\n+\t\t\t\t\t    UNSPEC_COND_CMPLE_WIDE\n+\t\t\t\t\t    UNSPEC_COND_CMPLO_WIDE\n+\t\t\t\t\t    UNSPEC_COND_CMPLS_WIDE\n+\t\t\t\t\t    UNSPEC_COND_CMPLT_WIDE\n+\t\t\t\t\t    UNSPEC_COND_CMPNE_WIDE])\n+\n ;; SVE FP comparisons that accept #0.0.\n (define_int_iterator SVE_COND_FP_CMP_I0 [UNSPEC_COND_FCMEQ\n \t\t\t\t\t UNSPEC_COND_FCMGE\n@@ -1781,6 +1953,20 @@\n \t\t\t\t\t  UNSPEC_COND_FCMLE\n \t\t\t\t\t  UNSPEC_COND_FCMLT])\n \n+(define_int_iterator SVE_FP_TERNARY_LANE [UNSPEC_FMLA UNSPEC_FMLS])\n+\n+(define_int_iterator SVE_CFP_TERNARY_LANE [UNSPEC_FCMLA UNSPEC_FCMLA90\n+\t\t\t\t\t   UNSPEC_FCMLA180 UNSPEC_FCMLA270])\n+\n+(define_int_iterator SVE_WHILE [UNSPEC_WHILE_LE UNSPEC_WHILE_LO\n+\t\t\t\tUNSPEC_WHILE_LS UNSPEC_WHILE_LT])\n+\n+(define_int_iterator SVE_SHIFT_WIDE [UNSPEC_ASHIFT_WIDE\n+\t\t\t\t     UNSPEC_ASHIFTRT_WIDE\n+\t\t\t\t     UNSPEC_LSHIFTRT_WIDE])\n+\n+(define_int_iterator SVE_LDFF1_LDNF1 [UNSPEC_LDFF1 UNSPEC_LDNF1])\n+\n (define_int_iterator FCADD [UNSPEC_FCADD90\n \t\t\t    UNSPEC_FCADD270])\n \n@@ -1792,6 +1978,12 @@\n (define_int_iterator FRINTNZX [UNSPEC_FRINT32Z UNSPEC_FRINT32X\n \t\t\t       UNSPEC_FRINT64Z UNSPEC_FRINT64X])\n \n+(define_int_iterator SVE_BRK_UNARY [UNSPEC_BRKA UNSPEC_BRKB])\n+\n+(define_int_iterator SVE_BRK_BINARY [UNSPEC_BRKN UNSPEC_BRKPA UNSPEC_BRKPB])\n+\n+(define_int_iterator SVE_PITER [UNSPEC_PFIRST UNSPEC_PNEXT])\n+\n ;; Iterators for atomic operations.\n \n (define_int_iterator ATOMIC_LDOP\n@@ -1816,9 +2008,16 @@\n (define_int_attr optab [(UNSPEC_ANDF \"and\")\n \t\t\t(UNSPEC_IORF \"ior\")\n \t\t\t(UNSPEC_XORF \"xor\")\n+\t\t\t(UNSPEC_SADDV \"sadd\")\n+\t\t\t(UNSPEC_UADDV \"uadd\")\n \t\t\t(UNSPEC_ANDV \"and\")\n \t\t\t(UNSPEC_IORV \"ior\")\n \t\t\t(UNSPEC_XORV \"xor\")\n+\t\t\t(UNSPEC_FRECPE \"frecpe\")\n+\t\t\t(UNSPEC_FRECPS \"frecps\")\n+\t\t\t(UNSPEC_RSQRTE \"frsqrte\")\n+\t\t\t(UNSPEC_RSQRTS \"frsqrts\")\n+\t\t\t(UNSPEC_RBIT \"rbit\")\n \t\t\t(UNSPEC_REVB \"revb\")\n \t\t\t(UNSPEC_REVH \"revh\")\n \t\t\t(UNSPEC_REVW \"revw\")\n@@ -1831,27 +2030,49 @@\n \t\t\t(UNSPEC_FMAXV \"smax_nan\")\n \t\t\t(UNSPEC_FMINNMV \"smin\")\n \t\t\t(UNSPEC_FMINV \"smin_nan\")\n+\t\t        (UNSPEC_SMUL_HIGHPART \"smulh\")\n+\t\t        (UNSPEC_UMUL_HIGHPART \"umulh\")\n+\t\t\t(UNSPEC_FMLA \"fma\")\n+\t\t\t(UNSPEC_FMLS \"fnma\")\n+\t\t\t(UNSPEC_FCMLA \"fcmla\")\n+\t\t\t(UNSPEC_FCMLA90 \"fcmla90\")\n+\t\t\t(UNSPEC_FCMLA180 \"fcmla180\")\n+\t\t\t(UNSPEC_FCMLA270 \"fcmla270\")\n+\t\t\t(UNSPEC_FEXPA \"fexpa\")\n+\t\t\t(UNSPEC_FTSMUL \"ftsmul\")\n+\t\t\t(UNSPEC_FTSSEL \"ftssel\")\n \t\t\t(UNSPEC_COND_FABS \"abs\")\n \t\t\t(UNSPEC_COND_FADD \"add\")\n+\t\t\t(UNSPEC_COND_FCADD90 \"cadd90\")\n+\t\t\t(UNSPEC_COND_FCADD270 \"cadd270\")\n+\t\t\t(UNSPEC_COND_FCMLA \"fcmla\")\n+\t\t\t(UNSPEC_COND_FCMLA90 \"fcmla90\")\n+\t\t\t(UNSPEC_COND_FCMLA180 \"fcmla180\")\n+\t\t\t(UNSPEC_COND_FCMLA270 \"fcmla270\")\n \t\t\t(UNSPEC_COND_FCVT \"fcvt\")\n \t\t\t(UNSPEC_COND_FCVTZS \"fix_trunc\")\n \t\t\t(UNSPEC_COND_FCVTZU \"fixuns_trunc\")\n \t\t\t(UNSPEC_COND_FDIV \"div\")\n+\t\t\t(UNSPEC_COND_FMAX \"smax_nan\")\n \t\t\t(UNSPEC_COND_FMAXNM \"smax\")\n+\t\t\t(UNSPEC_COND_FMIN \"smin_nan\")\n \t\t\t(UNSPEC_COND_FMINNM \"smin\")\n \t\t\t(UNSPEC_COND_FMLA \"fma\")\n \t\t\t(UNSPEC_COND_FMLS \"fnma\")\n \t\t\t(UNSPEC_COND_FMUL \"mul\")\n+\t\t\t(UNSPEC_COND_FMULX \"mulx\")\n \t\t\t(UNSPEC_COND_FNEG \"neg\")\n \t\t\t(UNSPEC_COND_FNMLA \"fnms\")\n \t\t\t(UNSPEC_COND_FNMLS \"fms\")\n+\t\t\t(UNSPEC_COND_FRECPX \"frecpx\")\n \t\t\t(UNSPEC_COND_FRINTA \"round\")\n \t\t\t(UNSPEC_COND_FRINTI \"nearbyint\")\n \t\t\t(UNSPEC_COND_FRINTM \"floor\")\n \t\t\t(UNSPEC_COND_FRINTN \"frintn\")\n \t\t\t(UNSPEC_COND_FRINTP \"ceil\")\n \t\t\t(UNSPEC_COND_FRINTX \"rint\")\n \t\t\t(UNSPEC_COND_FRINTZ \"btrunc\")\n+\t\t\t(UNSPEC_COND_FSCALE \"fscale\")\n \t\t\t(UNSPEC_COND_FSQRT \"sqrt\")\n \t\t\t(UNSPEC_COND_FSUB \"sub\")\n \t\t\t(UNSPEC_COND_SCVTF \"float\")\n@@ -1869,7 +2090,9 @@\n \t\t\t      (UNSPEC_FMINV \"smin_nan\")\n \t\t\t      (UNSPEC_FMAXNM \"fmax\")\n \t\t\t      (UNSPEC_FMINNM \"fmin\")\n+\t\t\t      (UNSPEC_COND_FMAX \"fmax_nan\")\n \t\t\t      (UNSPEC_COND_FMAXNM \"fmax\")\n+\t\t\t      (UNSPEC_COND_FMIN \"fmin_nan\")\n \t\t\t      (UNSPEC_COND_FMINNM \"fmin\")])\n \n (define_int_attr  maxmin_uns_op [(UNSPEC_UMAXV \"umax\")\n@@ -1885,13 +2108,28 @@\n \t\t\t\t (UNSPEC_FMAXNM \"fmaxnm\")\n \t\t\t\t (UNSPEC_FMINNM \"fminnm\")])\n \n+(define_code_attr binqops_op [(ss_plus \"sqadd\")\n+\t\t\t      (us_plus \"uqadd\")\n+\t\t\t      (ss_minus \"sqsub\")\n+\t\t\t      (us_minus \"uqsub\")])\n+\n+(define_code_attr binqops_op_rev [(ss_plus \"sqsub\")\n+\t\t\t\t  (ss_minus \"sqadd\")])\n+\n ;; The SVE logical instruction that implements an unspec.\n (define_int_attr logicalf_op [(UNSPEC_ANDF \"and\")\n \t\t \t      (UNSPEC_IORF \"orr\")\n \t\t\t      (UNSPEC_XORF \"eor\")])\n \n+(define_int_attr last_op [(UNSPEC_CLASTA \"after_last\")\n+\t\t\t  (UNSPEC_CLASTB \"last\")\n+\t\t\t  (UNSPEC_LASTA \"after_last\")\n+\t\t\t  (UNSPEC_LASTB \"last\")])\n+\n ;; \"s\" for signed operations and \"u\" for unsigned ones.\n-(define_int_attr su [(UNSPEC_UNPACKSHI \"s\")\n+(define_int_attr su [(UNSPEC_SADDV \"s\")\n+\t\t     (UNSPEC_UADDV \"u\")\n+\t\t     (UNSPEC_UNPACKSHI \"s\")\n \t\t     (UNSPEC_UNPACKUHI \"u\")\n \t\t     (UNSPEC_UNPACKSLO \"s\")\n \t\t     (UNSPEC_UNPACKULO \"u\")\n@@ -1961,6 +2199,11 @@\n (define_int_attr bt [(UNSPEC_SMULLB \"b\") (UNSPEC_UMULLB \"b\")\n \t\t     (UNSPEC_SMULLT \"t\") (UNSPEC_UMULLT \"t\")])\n \n+(define_int_attr fn [(UNSPEC_LDFF1 \"f\") (UNSPEC_LDNF1 \"n\")])\n+\n+(define_int_attr ab [(UNSPEC_CLASTA \"a\") (UNSPEC_CLASTB \"b\")\n+\t\t     (UNSPEC_LASTA \"a\") (UNSPEC_LASTB \"b\")])\n+\n (define_int_attr addsub [(UNSPEC_SHADD \"add\")\n \t\t\t (UNSPEC_UHADD \"add\")\n \t\t\t (UNSPEC_SRHADD \"add\")\n@@ -2102,13 +2345,37 @@\n \t\t\t      (UNSPEC_FRINT64Z \"frint64z\") (UNSPEC_FRINT64X \"frint64x\")])\n \n ;; The condition associated with an UNSPEC_COND_<xx>.\n-(define_int_attr cmp_op [(UNSPEC_COND_FCMEQ \"eq\")\n+(define_int_attr cmp_op [(UNSPEC_COND_CMPEQ_WIDE \"eq\")\n+\t\t\t (UNSPEC_COND_CMPGE_WIDE \"ge\")\n+\t\t\t (UNSPEC_COND_CMPGT_WIDE \"gt\")\n+\t\t\t (UNSPEC_COND_CMPHI_WIDE \"hi\")\n+\t\t\t (UNSPEC_COND_CMPHS_WIDE \"hs\")\n+\t\t\t (UNSPEC_COND_CMPLE_WIDE \"le\")\n+\t\t\t (UNSPEC_COND_CMPLO_WIDE \"lo\")\n+\t\t\t (UNSPEC_COND_CMPLS_WIDE \"ls\")\n+\t\t\t (UNSPEC_COND_CMPLT_WIDE \"lt\")\n+\t\t\t (UNSPEC_COND_CMPNE_WIDE \"ne\")\n+\t\t\t (UNSPEC_COND_FCMEQ \"eq\")\n \t\t\t (UNSPEC_COND_FCMGE \"ge\")\n \t\t\t (UNSPEC_COND_FCMGT \"gt\")\n \t\t\t (UNSPEC_COND_FCMLE \"le\")\n \t\t\t (UNSPEC_COND_FCMLT \"lt\")\n \t\t\t (UNSPEC_COND_FCMNE \"ne\")\n-\t\t\t (UNSPEC_COND_FCMUO \"uo\")])\n+\t\t\t (UNSPEC_WHILE_LE \"le\")\n+\t\t\t (UNSPEC_WHILE_LO \"lo\")\n+\t\t\t (UNSPEC_WHILE_LS \"ls\")\n+\t\t\t (UNSPEC_WHILE_LT \"lt\")])\n+\n+(define_int_attr while_optab_cmp [(UNSPEC_WHILE_LE \"le\")\n+\t\t\t\t  (UNSPEC_WHILE_LO \"ult\")\n+\t\t\t\t  (UNSPEC_WHILE_LS \"ule\")\n+\t\t\t\t  (UNSPEC_WHILE_LT \"lt\")])\n+\n+(define_int_attr brk_op [(UNSPEC_BRKA \"a\") (UNSPEC_BRKB \"b\")\n+\t\t\t (UNSPEC_BRKN \"n\")\n+\t\t\t (UNSPEC_BRKPA \"pa\") (UNSPEC_BRKPB \"pb\")])\n+\n+(define_int_attr sve_pred_op [(UNSPEC_PFIRST \"pfirst\") (UNSPEC_PNEXT \"pnext\")])\n \n (define_int_attr sve_int_op [(UNSPEC_ANDV \"andv\")\n \t\t\t     (UNSPEC_IORV \"orv\")\n@@ -2117,45 +2384,74 @@\n \t\t\t     (UNSPEC_UMINV \"uminv\")\n \t\t\t     (UNSPEC_SMAXV \"smaxv\")\n \t\t\t     (UNSPEC_SMINV \"sminv\")\n+\t\t\t     (UNSPEC_SMUL_HIGHPART \"smulh\")\n+\t\t\t     (UNSPEC_UMUL_HIGHPART \"umulh\")\n+\t\t\t     (UNSPEC_ASHIFT_WIDE \"lsl\")\n+\t\t\t     (UNSPEC_ASHIFTRT_WIDE \"asr\")\n+\t\t\t     (UNSPEC_LSHIFTRT_WIDE \"lsr\")\n+\t\t\t     (UNSPEC_RBIT \"rbit\")\n \t\t\t     (UNSPEC_REVB \"revb\")\n \t\t\t     (UNSPEC_REVH \"revh\")\n \t\t\t     (UNSPEC_REVW \"revw\")])\n \n-(define_int_attr sve_fp_op [(UNSPEC_FADDV \"faddv\")\n+(define_int_attr sve_fp_op [(UNSPEC_FRECPE \"frecpe\")\n+\t\t\t    (UNSPEC_FRECPS \"frecps\")\n+\t\t\t    (UNSPEC_RSQRTE \"frsqrte\")\n+\t\t\t    (UNSPEC_RSQRTS \"frsqrts\")\n+\t\t\t    (UNSPEC_FADDV \"faddv\")\n \t\t\t    (UNSPEC_FMAXNMV \"fmaxnmv\")\n \t\t\t    (UNSPEC_FMAXV \"fmaxv\")\n \t\t\t    (UNSPEC_FMINNMV \"fminnmv\")\n \t\t\t    (UNSPEC_FMINV \"fminv\")\n+\t\t\t    (UNSPEC_FMLA \"fmla\")\n+\t\t\t    (UNSPEC_FMLS \"fmls\")\n+\t\t\t    (UNSPEC_FEXPA \"fexpa\")\n+\t\t\t    (UNSPEC_FTSMUL \"ftsmul\")\n+\t\t\t    (UNSPEC_FTSSEL \"ftssel\")\n \t\t\t    (UNSPEC_COND_FABS \"fabs\")\n \t\t\t    (UNSPEC_COND_FADD \"fadd\")\n \t\t\t    (UNSPEC_COND_FDIV \"fdiv\")\n+\t\t\t    (UNSPEC_COND_FMAX \"fmax\")\n \t\t\t    (UNSPEC_COND_FMAXNM \"fmaxnm\")\n+\t\t\t    (UNSPEC_COND_FMIN \"fmin\")\n \t\t\t    (UNSPEC_COND_FMINNM \"fminnm\")\n \t\t\t    (UNSPEC_COND_FMUL \"fmul\")\n+\t\t\t    (UNSPEC_COND_FMULX \"fmulx\")\n \t\t\t    (UNSPEC_COND_FNEG \"fneg\")\n+\t\t\t    (UNSPEC_COND_FRECPX \"frecpx\")\n \t\t\t    (UNSPEC_COND_FRINTA \"frinta\")\n \t\t\t    (UNSPEC_COND_FRINTI \"frinti\")\n \t\t\t    (UNSPEC_COND_FRINTM \"frintm\")\n \t\t\t    (UNSPEC_COND_FRINTN \"frintn\")\n \t\t\t    (UNSPEC_COND_FRINTP \"frintp\")\n \t\t\t    (UNSPEC_COND_FRINTX \"frintx\")\n \t\t\t    (UNSPEC_COND_FRINTZ \"frintz\")\n+\t\t\t    (UNSPEC_COND_FSCALE \"fscale\")\n \t\t\t    (UNSPEC_COND_FSQRT \"fsqrt\")\n \t\t\t    (UNSPEC_COND_FSUB \"fsub\")])\n \n (define_int_attr sve_fp_op_rev [(UNSPEC_COND_FADD \"fadd\")\n \t\t\t\t(UNSPEC_COND_FDIV \"fdivr\")\n+\t\t\t\t(UNSPEC_COND_FMAX \"fmax\")\n \t\t\t\t(UNSPEC_COND_FMAXNM \"fmaxnm\")\n+\t\t\t\t(UNSPEC_COND_FMIN \"fmin\")\n \t\t\t\t(UNSPEC_COND_FMINNM \"fminnm\")\n \t\t\t\t(UNSPEC_COND_FMUL \"fmul\")\n+\t\t\t\t(UNSPEC_COND_FMULX \"fmulx\")\n \t\t\t\t(UNSPEC_COND_FSUB \"fsubr\")])\n \n (define_int_attr rot [(UNSPEC_FCADD90 \"90\")\n \t\t      (UNSPEC_FCADD270 \"270\")\n \t\t      (UNSPEC_FCMLA \"0\")\n \t\t      (UNSPEC_FCMLA90 \"90\")\n \t\t      (UNSPEC_FCMLA180 \"180\")\n-\t\t      (UNSPEC_FCMLA270 \"270\")])\n+\t\t      (UNSPEC_FCMLA270 \"270\")\n+\t\t      (UNSPEC_COND_FCADD90 \"90\")\n+\t\t      (UNSPEC_COND_FCADD270 \"270\")\n+\t\t      (UNSPEC_COND_FCMLA \"0\")\n+\t\t      (UNSPEC_COND_FCMLA90 \"90\")\n+\t\t      (UNSPEC_COND_FCMLA180 \"180\")\n+\t\t      (UNSPEC_COND_FCMLA270 \"270\")])\n \n (define_int_attr sve_fmla_op [(UNSPEC_COND_FMLA \"fmla\")\n \t\t\t      (UNSPEC_COND_FMLS \"fmls\")\n@@ -2167,33 +2463,54 @@\n \t\t\t      (UNSPEC_COND_FNMLA \"fnmad\")\n \t\t\t      (UNSPEC_COND_FNMLS \"fnmsb\")])\n \n+;; The register constraint to use for the final operand in a binary BRK.\n+(define_int_attr brk_reg_con [(UNSPEC_BRKN \"0\")\n+\t\t\t      (UNSPEC_BRKPA \"Upa\") (UNSPEC_BRKPB \"Upa\")])\n+\n+;; The register number to print for the above.\n+(define_int_attr brk_reg_opno [(UNSPEC_BRKN \"0\")\n+\t\t\t       (UNSPEC_BRKPA \"3\") (UNSPEC_BRKPB \"3\")])\n+\n ;; The predicate to use for the first input operand in a floating-point\n ;; <optab><mode>3 pattern.\n (define_int_attr sve_pred_fp_rhs1_operand\n   [(UNSPEC_COND_FADD \"register_operand\")\n    (UNSPEC_COND_FDIV \"register_operand\")\n+   (UNSPEC_COND_FMAX \"register_operand\")\n    (UNSPEC_COND_FMAXNM \"register_operand\")\n+   (UNSPEC_COND_FMIN \"register_operand\")\n    (UNSPEC_COND_FMINNM \"register_operand\")\n    (UNSPEC_COND_FMUL \"register_operand\")\n+   (UNSPEC_COND_FMULX \"register_operand\")\n    (UNSPEC_COND_FSUB \"aarch64_sve_float_arith_operand\")])\n \n ;; The predicate to use for the second input operand in a floating-point\n ;; <optab><mode>3 pattern.\n (define_int_attr sve_pred_fp_rhs2_operand\n   [(UNSPEC_COND_FADD \"aarch64_sve_float_arith_with_sub_operand\")\n    (UNSPEC_COND_FDIV \"register_operand\")\n+   (UNSPEC_COND_FMAX \"aarch64_sve_float_maxmin_operand\")\n    (UNSPEC_COND_FMAXNM \"aarch64_sve_float_maxmin_operand\")\n+   (UNSPEC_COND_FMIN \"aarch64_sve_float_maxmin_operand\")\n    (UNSPEC_COND_FMINNM \"aarch64_sve_float_maxmin_operand\")\n    (UNSPEC_COND_FMUL \"aarch64_sve_float_mul_operand\")\n+   (UNSPEC_COND_FMULX \"register_operand\")\n    (UNSPEC_COND_FSUB \"register_operand\")])\n \n ;; Likewise for immediates only.\n (define_int_attr sve_pred_fp_rhs2_immediate\n-  [(UNSPEC_COND_FMAXNM \"aarch64_sve_float_maxmin_immediate\")\n+  [(UNSPEC_COND_FMAX \"aarch64_sve_float_maxmin_immediate\")\n+   (UNSPEC_COND_FMAXNM \"aarch64_sve_float_maxmin_immediate\")\n+   (UNSPEC_COND_FMIN \"aarch64_sve_float_maxmin_immediate\")\n    (UNSPEC_COND_FMINNM \"aarch64_sve_float_maxmin_immediate\")\n    (UNSPEC_COND_FMUL \"aarch64_sve_float_mul_immediate\")])\n \n+;; The maximum number of element bits that an instruction can handle.\n+(define_int_attr max_elem_bits [(UNSPEC_UADDV \"64\") (UNSPEC_SADDV \"32\")\n+\t\t\t\t(UNSPEC_PFIRST \"8\") (UNSPEC_PNEXT \"64\")])\n+\n ;; The minimum number of element bits that an instruction can handle.\n-(define_int_attr min_elem_bits [(UNSPEC_REVB \"16\")\n+(define_int_attr min_elem_bits [(UNSPEC_RBIT \"8\")\n+\t\t\t\t(UNSPEC_REVB \"16\")\n \t\t\t\t(UNSPEC_REVH \"32\")\n \t\t\t\t(UNSPEC_REVW \"64\")])"}, {"sha": "2c5c53c716d98036192b9d97f0a4cf99a7c885f0", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 86, "deletions": 3, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -46,9 +46,10 @@\n   return CONST_INT_P (op) && IN_RANGE (INTVAL (op), 1, 3);\n })\n \n-(define_special_predicate \"subreg_lowpart_operator\"\n-  (and (match_code \"subreg\")\n-       (match_test \"subreg_lowpart_p (op)\")))\n+(define_predicate \"subreg_lowpart_operator\"\n+  (ior (match_code \"truncate\")\n+       (and (match_code \"subreg\")\n+\t    (match_test \"subreg_lowpart_p (op)\"))))\n \n (define_predicate \"aarch64_ccmp_immediate\"\n   (and (match_code \"const_int\")\n@@ -457,6 +458,12 @@\n   return aarch64_stepped_int_parallel_p (op, -1);\n })\n \n+(define_predicate \"ascending_int_parallel\"\n+  (match_code \"parallel\")\n+{\n+  return aarch64_stepped_int_parallel_p (op, 1);\n+})\n+\n (define_special_predicate \"aarch64_simd_lshift_imm\"\n   (match_code \"const,const_vector\")\n {\n@@ -491,6 +498,10 @@\n \t    (match_test \"op == const0_rtx\")\n \t    (match_operand 0 \"aarch64_simd_or_scalar_imm_zero\"))))\n \n+(define_predicate \"aarch64_simd_reg_or_minus_one\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"aarch64_simd_imm_minus_one\")))\n+\n (define_predicate \"aarch64_simd_struct_operand\"\n   (and (match_code \"mem\")\n        (match_test \"TARGET_SIMD && aarch64_simd_mem_operand_p (op)\")))\n@@ -577,12 +588,24 @@\n   (and (match_code \"mem\")\n        (match_test \"aarch64_sve_ld1rq_operand_p (op)\")))\n \n+(define_predicate \"aarch64_sve_ldff1_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"aarch64_sve_ldff1_operand_p (op)\")))\n+\n+(define_predicate \"aarch64_sve_ldnf1_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"aarch64_sve_ldnf1_operand_p (op)\")))\n+\n ;; Like memory_operand, but restricted to addresses that are valid for\n ;; SVE LDR and STR instructions.\n (define_predicate \"aarch64_sve_ldr_operand\"\n   (and (match_code \"mem\")\n        (match_test \"aarch64_sve_ldr_operand_p (op)\")))\n \n+(define_special_predicate \"aarch64_sve_prefetch_operand\"\n+  (and (match_code \"reg, plus\")\n+       (match_test \"aarch64_sve_prefetch_operand_p (op, mode)\")))\n+\n (define_predicate \"aarch64_sve_nonimmediate_operand\"\n   (ior (match_operand 0 \"register_operand\")\n        (match_operand 0 \"aarch64_sve_ldr_operand\")))\n@@ -607,6 +630,10 @@\n   (ior (match_operand 0 \"register_operand\")\n        (match_operand 0 \"aarch64_sve_ld1r_operand\")))\n \n+(define_predicate \"aarch64_sve_ptrue_svpattern_immediate\"\n+  (and (match_code \"const\")\n+       (match_test \"aarch64_sve_ptrue_svpattern_p (op, NULL)\")))\n+\n (define_predicate \"aarch64_sve_arith_immediate\"\n   (and (match_code \"const,const_vector\")\n        (match_test \"aarch64_sve_arith_immediate_p (op, false)\")))\n@@ -615,10 +642,37 @@\n   (and (match_code \"const,const_vector\")\n        (match_test \"aarch64_sve_arith_immediate_p (op, true)\")))\n \n+(define_predicate \"aarch64_sve_qadd_immediate\"\n+  (and (match_code \"const,const_vector\")\n+       (match_test \"aarch64_sve_sqadd_sqsub_immediate_p (op, false)\")))\n+\n+(define_predicate \"aarch64_sve_qsub_immediate\"\n+  (and (match_code \"const,const_vector\")\n+       (match_test \"aarch64_sve_sqadd_sqsub_immediate_p (op, true)\")))\n+\n (define_predicate \"aarch64_sve_vector_inc_dec_immediate\"\n   (and (match_code \"const,const_vector\")\n        (match_test \"aarch64_sve_vector_inc_dec_immediate_p (op)\")))\n \n+(define_predicate \"aarch64_sve_gather_immediate_b\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 31)\")))\n+\n+(define_predicate \"aarch64_sve_gather_immediate_h\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 62)\")\n+       (match_test \"(INTVAL (op) & 1) == 0\")))\n+\n+(define_predicate \"aarch64_sve_gather_immediate_w\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 124)\")\n+       (match_test \"(INTVAL (op) & 3) == 0\")))\n+\n+(define_predicate \"aarch64_sve_gather_immediate_d\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 248)\")\n+       (match_test \"(INTVAL (op) & 7) == 0\")))\n+\n (define_predicate \"aarch64_sve_uxtb_immediate\"\n   (and (match_code \"const_vector\")\n        (match_test \"GET_MODE_UNIT_BITSIZE (GET_MODE (op)) > 8\")\n@@ -702,6 +756,11 @@\n        (match_operand 0 \"aarch64_sve_sub_arith_immediate\")\n        (match_operand 0 \"aarch64_sve_vector_inc_dec_immediate\")))\n \n+(define_predicate \"aarch64_sve_sqadd_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"aarch64_sve_qadd_immediate\")\n+       (match_operand 0 \"aarch64_sve_qsub_immediate\")))\n+\n (define_predicate \"aarch64_sve_pred_and_operand\"\n   (ior (match_operand 0 \"register_operand\")\n        (match_operand 0 \"aarch64_sve_uxt_immediate\")))\n@@ -710,6 +769,22 @@\n   (ior (match_operand 0 \"register_operand\")\n        (match_operand 0 \"aarch64_sve_logical_immediate\")))\n \n+(define_predicate \"aarch64_sve_gather_offset_b\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"aarch64_sve_gather_immediate_b\")))\n+\n+(define_predicate \"aarch64_sve_gather_offset_h\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"aarch64_sve_gather_immediate_h\")))\n+\n+(define_predicate \"aarch64_sve_gather_offset_w\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"aarch64_sve_gather_immediate_w\")))\n+\n+(define_predicate \"aarch64_sve_gather_offset_d\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"aarch64_sve_gather_immediate_d\")))\n+\n (define_predicate \"aarch64_sve_lshift_operand\"\n   (ior (match_operand 0 \"register_operand\")\n        (match_operand 0 \"aarch64_simd_lshift_imm\")))\n@@ -772,6 +847,14 @@\n        (ior (match_test \"INTVAL (op) == SVE_RELAXED_GP\")\n \t    (match_test \"INTVAL (op) == SVE_STRICT_GP\"))))\n \n+(define_predicate \"aarch64_gather_scale_operand_b\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) == 1\")))\n+\n+(define_predicate \"aarch64_gather_scale_operand_h\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) == 1 || INTVAL (op) == 2\")))\n+\n (define_predicate \"aarch64_gather_scale_operand_w\"\n   (and (match_code \"const_int\")\n        (match_test \"INTVAL (op) == 1 || INTVAL (op) == 4\")))"}, {"sha": "28e1c7aecdd68bbac2ce3a875c3df416650aa8e1", "filename": "gcc/config/aarch64/t-aarch64", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Ft-aarch64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Fconfig%2Faarch64%2Ft-aarch64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Ft-aarch64?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -40,6 +40,43 @@ aarch64-builtins.o: $(srcdir)/config/aarch64/aarch64-builtins.c $(CONFIG_H) \\\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t\t$(srcdir)/config/aarch64/aarch64-builtins.c\n \n+aarch64-sve-builtins.o: $(srcdir)/config/aarch64/aarch64-sve-builtins.cc \\\n+  $(srcdir)/config/aarch64/aarch64-sve-builtins.def \\\n+  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \\\n+  $(TM_P_H) memmodel.h insn-codes.h $(OPTABS_H) $(RECOG_H) $(DIAGNOSTIC_H) \\\n+  $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) fold-const.h $(GIMPLE_H) \\\n+  gimple-iterator.h gimplify.h explow.h $(EMIT_RTL_H) tree-vector-builder.h \\\n+  stor-layout.h $(REG_H) alias.h gimple-fold.h langhooks.h \\\n+  stringpool.h \\\n+  $(srcdir)/config/aarch64/aarch64-sve-builtins.h \\\n+  $(srcdir)/config/aarch64/aarch64-sve-builtins-shapes.h \\\n+  $(srcdir)/config/aarch64/aarch64-sve-builtins-base.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\t$(srcdir)/config/aarch64/aarch64-sve-builtins.cc\n+\n+aarch64-sve-builtins-shapes.o: \\\n+  $(srcdir)/config/aarch64/aarch64-sve-builtins-shapes.cc \\\n+  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \\\n+  $(TM_P_H) memmodel.h insn-codes.h $(OPTABS_H) \\\n+  $(srcdir)/config/aarch64/aarch64-sve-builtins.h \\\n+  $(srcdir)/config/aarch64/aarch64-sve-builtins-shapes.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\t$(srcdir)/config/aarch64/aarch64-sve-builtins-shapes.cc\n+\n+aarch64-sve-builtins-base.o: \\\n+  $(srcdir)/config/aarch64/aarch64-sve-builtins-base.cc \\\n+  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \\\n+  $(TM_P_H) memmodel.h insn-codes.h $(OPTABS_H) $(RECOG_H) \\\n+  $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) fold-const.h $(GIMPLE_H) \\\n+  gimple-iterator.h gimplify.h explow.h $(EMIT_RTL_H) tree-vector-builder.h \\\n+  rtx-vector-builder.h vec-perm-indices.h \\\n+  $(srcdir)/config/aarch64/aarch64-sve-builtins.h \\\n+  $(srcdir)/config/aarch64/aarch64-sve-builtins-shapes.h \\\n+  $(srcdir)/config/aarch64/aarch64-sve-builtins-base.h \\\n+  $(srcdir)/config/aarch64/aarch64-sve-builtins-functions.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\t$(srcdir)/config/aarch64/aarch64-sve-builtins-base.cc\n+\n aarch64-builtin-iterators.h: $(srcdir)/config/aarch64/geniterators.sh \\\n \t$(srcdir)/config/aarch64/iterators.md\n \t$(SHELL) $(srcdir)/config/aarch64/geniterators.sh \\"}, {"sha": "0507477512ec25baa6117bf010aba0154a229318", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -1,3 +1,13 @@\n+2019-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n+\t    Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n+\t    Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\n+\t* g++.target/aarch64/sve/acle/aarch64-sve-acle.exp: New file.\n+\t* g++.target/aarch64/sve/acle/general-c++: New test directory.\n+\t* gcc.target/aarch64/sve/acle/aarch64-sve-acle.exp: New file.\n+\t* gcc.target/aarch64/sve/acle/general: New test directory.\n+\t* gcc.target/aarch64/sve/acle/general-c: Likewise.\n+\n 2019-10-29  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/92241"}, {"sha": "54c43a3accf15216fa48d8e90fc6d72302afc458", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/aarch64-sve-acle.exp", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Faarch64-sve-acle.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Faarch64-sve-acle.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Faarch64-sve-acle.exp?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,55 @@\n+#  Specific regression driver for AArch64 SVE.\n+#  Copyright (C) 2009-2019 Free Software Foundation, Inc.\n+#  Contributed by ARM Ltd.\n+#\n+#  This file is part of GCC.\n+#\n+#  GCC is free software; you can redistribute it and/or modify it\n+#  under the terms of the GNU General Public License as published by\n+#  the Free Software Foundation; either version 3, or (at your option)\n+#  any later version.\n+#\n+#  GCC is distributed in the hope that it will be useful, but\n+#  WITHOUT ANY WARRANTY; without even the implied warranty of\n+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+#  General Public License for more details.\n+#\n+#  You should have received a copy of the GNU General Public License\n+#  along with GCC; see the file COPYING3.  If not see\n+#  <http://www.gnu.org/licenses/>.  */\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't an AArch64 target.\n+if {![istarget aarch64*-*-*] } {\n+    return\n+}\n+\n+# Load support procs.\n+load_lib g++-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CXXFLAGS\n+if ![info exists DEFAULT_CXXFLAGS] then {\n+    set DEFAULT_CXXFLAGS \" -pedantic-errors -Wno-long-long\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Force SVE if we're not testing it already.\n+if { [check_effective_target_aarch64_sve] } {\n+    set sve_flags \"\"\n+} else {\n+    set sve_flags \"-march=armv8.2-a+sve\"\n+}\n+\n+# Main loop.\n+set gcc_subdir [string replace $subdir 0 2 gcc]\n+set files [glob -nocomplain \\\n+\t       \"$srcdir/$gcc_subdir/general/*.c\" \\\n+\t       \"$srcdir/$subdir/general-c++/*.\\[cC\\]\"]\n+dg-runtest [lsort $files] \"$sve_flags\" $DEFAULT_CXXFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "44aa10e20c0f87eb78013e9b5f72b81b418a9738", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/add_1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fadd_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fadd_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fadd_1.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+\n+#include \"add_1.h\"\n+\n+svuint8_t\n+f1 (svbool_t pg, svuint8_t x, svint8_t y)\n+{\n+  return svadd_u8_x (pg, x, y); /* { dg-error \"cannot convert 'svint8_t' to 'svuint8_t'\" } */\n+}"}, {"sha": "d441328a39b23d1ee212cc88e2b41272c90998b3", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/add_1.h", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fadd_1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fadd_1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fadd_1.h?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,2 @@\n+#pragma GCC system_header\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-message \"initializing argument 3\" } */"}, {"sha": "fcfb0f489912bade1b6a325fbe1c0d6c1beb85a8", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/add_2.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fadd_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fadd_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fadd_2.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+\n+#include \"add_2.h\"\n+\n+void\n+f1 (svbool_t pg, svuint8_t x, svint8_t y)\n+{\n+  svadd_x (pg, x); /* { dg-error {no matching function for call to 'svadd_x\\(svbool_t&, svuint8_t&\\)'} } */\n+  svadd_x (pg, x, x, x); /* { dg-error {no matching function for call to 'svadd_x\\(svbool_t&, svuint8_t&, svuint8_t&, svuint8_t&\\)'} } */\n+  svadd_x (x, x, x); /* { dg-error {no matching function for call to 'svadd_x\\(svuint8_t&, svuint8_t&, svuint8_t&\\)'} } */\n+  svadd_x (pg, pg, pg); /* { dg-error {no matching function for call to 'svadd_x\\(svbool_t&, svbool_t&, svbool_t&\\)'} } */\n+  svadd_x (pg, 1, x); /* { dg-error {no matching function for call to 'svadd_x\\(svbool_t&, int, svuint8_t&\\)'} } */\n+  svadd_x (pg, x, y); /* { dg-error {no matching function for call to 'svadd_x\\(svbool_t&, svuint8_t&, svint8_t&\\)'} } */\n+}"}, {"sha": "2b3a520d3dec0263017de9f9f3124d98d0883deb", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/add_2.h", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fadd_2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fadd_2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fadd_2.h?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,9 @@\n+#pragma GCC system_header\n+#pragma GCC aarch64 \"arm_sve.h\"\n+/* { dg-message {note: candidate: 'svfloat16_t svadd_x\\(svbool_t, svfloat16_t, svfloat16_t\\)'} \"\" { target *-*-* } 3 } */\n+/* { dg-message {note: *candidate expects 3 arguments, 2 provided} \"\" { target *-*-* } 3 } */\n+/* { dg-message {note: *candidate expects 3 arguments, 4 provided} \"\" { target *-*-* } 3 } */\n+/* { dg-message {note: *no known conversion for argument 1 from 'svuint8_t' to 'svbool_t'} \"\" { target *-*-* } 3 } */\n+/* { dg-message {note: *no known conversion for argument 2 from 'svbool_t' to 'svfloat16_t'} \"\" { target *-*-* } 3 } */\n+/* { dg-message {note: *no known conversion for argument 2 from 'int' to 'svfloat16_t'} \"\" { target *-*-* } 3 } */\n+/* { dg-message {note: *no known conversion for argument 2 from 'svuint8_t' to 'svfloat16_t'} \"\" { target *-*-* } 3 } */"}, {"sha": "1d811fc76329f125ba48493edbf6d2b275881b14", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/add_3.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fadd_3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fadd_3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fadd_3.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -fnon-call-exceptions\" } */\n+\n+#include <arm_sve.h>\n+\n+svint8_t\n+foo (svbool_t pg, svint8_t a, svint8_t b)\n+{\n+  try\n+    {\n+      a = svadd_m (pg, a, b);\n+    }\n+  catch (...)\n+    {\n+      a = b;\n+    }\n+  return a;\n+}\n+\n+/* { dg-final { scan-tree-dump-not {__cxa_begin_catch} \"optimized\" } } */"}, {"sha": "a73934f5668880a14a3703c23cb58a081d2b53d3", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/asrd_1.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fasrd_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fasrd_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fasrd_1.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c++11 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+constexpr uint64_t const_add (uint64_t a, uint64_t b) { return a + b; }\n+uint64_t add (uint64_t a, uint64_t b) { return a + b; }\n+\n+void\n+f1 (svbool_t pg, svuint8_t u8, svint8_t s8, svint16_t s16,\n+    svint32_t s32, svint64_t s64, int x)\n+{\n+  const int one = 1;\n+  u8 = svasrd_x (pg, u8, 1); /* { dg-error {no matching function for call to 'svasrd_x\\(svbool_t&, svuint8_t&, [^)]*\\)'} } */\n+  s8 = svasrd_x (pg, s8, x); /* { dg-error \"argument 3 of 'svasrd_x' must be an integer constant expression\" } */\n+  s8 = svasrd_x (pg, s8, one);\n+  s8 = svasrd_x (pg, s8, 0.4); /* { dg-error {passing 0 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 8\\]} } */\n+  s8 = svasrd_x (pg, s8, 1.0);\n+  s8 = svasrd_x (pg, s8, 0); /* { dg-error {passing 0 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 8\\]} } */\n+  s8 = svasrd_x (pg, s8, 1);\n+  s8 = svasrd_x (pg, s8, 1 + 1);\n+  s8 = svasrd_x (pg, s8, const_add (1, 1));\n+  s8 = svasrd_x (pg, s8, add (1, 1)); /* { dg-error \"argument 3 of 'svasrd_x' must be an integer constant expression\" } */\n+  s8 = svasrd_x (pg, s8, 8);\n+  s8 = svasrd_x (pg, s8, 9); /* { dg-error {passing 9 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 8\\]} } */\n+  s8 = svasrd_x (pg, s8, (uint64_t (1) << 62) + 1); /* { dg-error {passing [^ ]* to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 8\\]} } */\n+  s16 = svasrd_x (pg, s16, 0); /* { dg-error {passing 0 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 16\\]} } */\n+  s16 = svasrd_x (pg, s16, 1);\n+  s16 = svasrd_x (pg, s16, 16);\n+  s16 = svasrd_x (pg, s16, 17); /* { dg-error {passing 17 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 16\\]} } */\n+  s32 = svasrd_x (pg, s32, 0); /* { dg-error {passing 0 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 32\\]} } */\n+  s32 = svasrd_x (pg, s32, 1);\n+  s32 = svasrd_x (pg, s32, 32);\n+  s32 = svasrd_x (pg, s32, 33); /* { dg-error {passing 33 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 32\\]} } */\n+  s64 = svasrd_x (pg, s64, 0); /* { dg-error {passing 0 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 64\\]} } */\n+  s64 = svasrd_x (pg, s64, 1);\n+  s64 = svasrd_x (pg, s64, 64);\n+  s64 = svasrd_x (pg, s64, 65); /* { dg-error {passing 65 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 64\\]} } */\n+}"}, {"sha": "bbe7ba72bfaf083f09a22cbfb7cb5ea247b63b11", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/asrd_2.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fasrd_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fasrd_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fasrd_2.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c++11 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+constexpr uint64_t const_add (uint64_t a, uint64_t b) { return a + b; }\n+uint64_t add (uint64_t a, uint64_t b) { return a + b; }\n+\n+void\n+f1 (svbool_t pg, svint8_t s8, svint16_t s16, svint32_t s32, svint64_t s64,\n+    int x)\n+{\n+  const int one = 1;\n+  s8 = svasrd_n_s8_x (pg, s8, x); /* { dg-error \"argument 3 of 'svasrd_n_s8_x' must be an integer constant expression\" } */\n+  s8 = svasrd_n_s8_x (pg, s8, one);\n+  s8 = svasrd_n_s8_x (pg, s8, 0.4); /* { dg-error {passing 0 to argument 3 of 'svasrd_n_s8_x', which expects a value in the range \\[1, 8\\]} } */\n+  s8 = svasrd_n_s8_x (pg, s8, 1.0);\n+  s8 = svasrd_n_s8_x (pg, s8, 0); /* { dg-error {passing 0 to argument 3 of 'svasrd_n_s8_x', which expects a value in the range \\[1, 8\\]} } */\n+  s8 = svasrd_n_s8_x (pg, s8, 1);\n+  s8 = svasrd_n_s8_x (pg, s8, 1 + 1);\n+  s8 = svasrd_n_s8_x (pg, s8, const_add (1, 1));\n+  s8 = svasrd_n_s8_x (pg, s8, add (1, 1)); /* { dg-error \"argument 3 of 'svasrd_n_s8_x' must be an integer constant expression\" } */\n+  s8 = svasrd_n_s8_x (pg, s8, 8);\n+  s8 = svasrd_n_s8_x (pg, s8, 9); /* { dg-error {passing 9 to argument 3 of 'svasrd_n_s8_x', which expects a value in the range \\[1, 8\\]} } */\n+  s8 = svasrd_n_s8_x (pg, s8, (uint64_t (1) << 62) + 1); /* { dg-error {passing [^ ]* to argument 3 of 'svasrd_n_s8_x', which expects a value in the range \\[1, 8\\]} } */\n+  s16 = svasrd_n_s16_x (pg, s16, 0); /* { dg-error {passing 0 to argument 3 of 'svasrd_n_s16_x', which expects a value in the range \\[1, 16\\]} } */\n+  s16 = svasrd_n_s16_x (pg, s16, 1);\n+  s16 = svasrd_n_s16_x (pg, s16, 16);\n+  s16 = svasrd_n_s16_x (pg, s16, 17); /* { dg-error {passing 17 to argument 3 of 'svasrd_n_s16_x', which expects a value in the range \\[1, 16\\]} } */\n+  s32 = svasrd_n_s32_x (pg, s32, 0); /* { dg-error {passing 0 to argument 3 of 'svasrd_n_s32_x', which expects a value in the range \\[1, 32\\]} } */\n+  s32 = svasrd_n_s32_x (pg, s32, 1);\n+  s32 = svasrd_n_s32_x (pg, s32, 32);\n+  s32 = svasrd_n_s32_x (pg, s32, 33); /* { dg-error {passing 33 to argument 3 of 'svasrd_n_s32_x', which expects a value in the range \\[1, 32\\]} } */\n+  s64 = svasrd_n_s64_x (pg, s64, 0); /* { dg-error {passing 0 to argument 3 of 'svasrd_n_s64_x', which expects a value in the range \\[1, 64\\]} } */\n+  s64 = svasrd_n_s64_x (pg, s64, 1);\n+  s64 = svasrd_n_s64_x (pg, s64, 64);\n+  s64 = svasrd_n_s64_x (pg, s64, 65); /* { dg-error {passing 65 to argument 3 of 'svasrd_n_s64_x', which expects a value in the range \\[1, 64\\]} } */\n+}"}, {"sha": "5ebd770b272ec65a25a262248e036d2df22f2518", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/asrd_3.C", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fasrd_3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fasrd_3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fasrd_3.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c++11 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+constexpr uint64_t const_add (uint64_t a, uint64_t b) { return a + b; }\n+uint64_t add (uint64_t a, uint64_t b) { return a + b; }\n+\n+template<uint64_t N, typename T>\n+T shift (svbool_t pg, T v) { return svasrd_x (pg, v, N); }\n+/* { dg-error {no matching function for call to 'svasrd_x\\(svbool_t&,} \"\" { target *-*-* } .-1 } */\n+/* { dg-error {passing 0 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 8\\]} \"\" { target *-*-* } .-2 } */\n+/* { dg-error {passing 9 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 8\\]} \"\" { target *-*-* } .-3 } */\n+/* { dg-error {passing 0 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 16\\]} \"\" { target *-*-* } .-4 } */\n+/* { dg-error {passing 17 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 16\\]} \"\" { target *-*-* } .-5 } */\n+/* { dg-error {passing 0 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 32\\]} \"\" { target *-*-* } .-6 } */\n+/* { dg-error {passing 33 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 32\\]} \"\" { target *-*-* } .-7 } */\n+/* { dg-error {passing 0 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 64\\]} \"\" { target *-*-* } .-8 } */\n+/* { dg-error {passing 65 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 64\\]} \"\" { target *-*-* } .-9 } */\n+\n+template<typename T>\n+T shift1 (svbool_t pg, T v, uint64_t n) { return svasrd_x (pg, v, n); }\n+\n+template<typename T>\n+T shift2 (svbool_t pg, T v, uint64_t n) { return svasrd_x (pg, v, n); }\n+/* { dg-error {argument 3 of 'svasrd_x' must be an integer constant expression} \"\" { target *-*-* } .-1 } */\n+\n+void\n+f1 (svbool_t pg, svuint8_t u8, svint8_t s8, svint16_t s16,\n+    svint32_t s32, svint64_t s64)\n+{\n+  u8 = shift <1> (pg, u8);\n+  s8 = shift <0> (pg, s8);\n+  s8 = shift <1> (pg, s8);\n+  s8 = shift <8> (pg, s8);\n+  s8 = shift <9> (pg, s8);\n+  s16 = shift <0> (pg, s16);\n+  s16 = shift <1> (pg, s16);\n+  s16 = shift <16> (pg, s16);\n+  s16 = shift <17> (pg, s16);\n+  s32 = shift <0> (pg, s32);\n+  s32 = shift <1> (pg, s32);\n+  s32 = shift <32> (pg, s32);\n+  s32 = shift <33> (pg, s32);\n+  s64 = shift <0> (pg, s64);\n+  s64 = shift <1> (pg, s64);\n+  s64 = shift <64> (pg, s64);\n+  s64 = shift <65> (pg, s64);\n+\n+  s8 = shift2 (pg, s8, 1);\n+}"}, {"sha": "bbc9f9010be3fc888af97bb15458e28f60a6e3c8", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/cntb_pat.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcntb_pat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcntb_pat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcntb_pat.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test (svpattern pat, int i)\n+{\n+  svcntb_pat (pat); /* { dg-error \"argument 1 of 'svcntb_pat' must be an integer constant expression\" } */\n+  svcntb_pat (i); /* { dg-error \"invalid conversion from 'int' to 'svpattern'\" } */\n+   /* { dg-error \"argument 1 of 'svcntb_pat' must be an integer constant expression\" \"\" { target *-*-* } .-1 } */\n+  svcntb_pat ((svpattern) -1); /* { dg-error \"passing 4294967295 to argument 1 of 'svcntb_pat', which expects a valid 'svpattern' value\" } */\n+  svcntb_pat ((svpattern) 0);\n+  svcntb_pat ((svpattern) 1);\n+  svcntb_pat ((svpattern) 2);\n+  svcntb_pat ((svpattern) 3);\n+  svcntb_pat ((svpattern) 4);\n+  svcntb_pat ((svpattern) 5);\n+  svcntb_pat ((svpattern) 6);\n+  svcntb_pat ((svpattern) 7);\n+  svcntb_pat ((svpattern) 8);\n+  svcntb_pat ((svpattern) 9);\n+  svcntb_pat ((svpattern) 10);\n+  svcntb_pat ((svpattern) 11);\n+  svcntb_pat ((svpattern) 12);\n+  svcntb_pat ((svpattern) 13);\n+  svcntb_pat ((svpattern) 14); /* { dg-error \"passing 14 to argument 1 of 'svcntb_pat', which expects a valid 'svpattern' value\" } */\n+  svcntb_pat ((svpattern) 15); /* { dg-error \"passing 15 to argument 1 of 'svcntb_pat', which expects a valid 'svpattern' value\" } */\n+  svcntb_pat ((svpattern) 16); /* { dg-error \"passing 16 to argument 1 of 'svcntb_pat', which expects a valid 'svpattern' value\" } */\n+  svcntb_pat ((svpattern) 17); /* { dg-error \"passing 17 to argument 1 of 'svcntb_pat', which expects a valid 'svpattern' value\" } */\n+  svcntb_pat ((svpattern) 18); /* { dg-error \"passing 18 to argument 1 of 'svcntb_pat', which expects a valid 'svpattern' value\" } */\n+  svcntb_pat ((svpattern) 19); /* { dg-error \"passing 19 to argument 1 of 'svcntb_pat', which expects a valid 'svpattern' value\" } */\n+  svcntb_pat ((svpattern) 20); /* { dg-error \"passing 20 to argument 1 of 'svcntb_pat', which expects a valid 'svpattern' value\" } */\n+  svcntb_pat ((svpattern) 21); /* { dg-error \"passing 21 to argument 1 of 'svcntb_pat', which expects a valid 'svpattern' value\" } */\n+  svcntb_pat ((svpattern) 22); /* { dg-error \"passing 22 to argument 1 of 'svcntb_pat', which expects a valid 'svpattern' value\" } */\n+  svcntb_pat ((svpattern) 23); /* { dg-error \"passing 23 to argument 1 of 'svcntb_pat', which expects a valid 'svpattern' value\" } */\n+  svcntb_pat ((svpattern) 24); /* { dg-error \"passing 24 to argument 1 of 'svcntb_pat', which expects a valid 'svpattern' value\" } */\n+  svcntb_pat ((svpattern) 25); /* { dg-error \"passing 25 to argument 1 of 'svcntb_pat', which expects a valid 'svpattern' value\" } */\n+  svcntb_pat ((svpattern) 26); /* { dg-error \"passing 26 to argument 1 of 'svcntb_pat', which expects a valid 'svpattern' value\" } */\n+  svcntb_pat ((svpattern) 27); /* { dg-error \"passing 27 to argument 1 of 'svcntb_pat', which expects a valid 'svpattern' value\" } */\n+  svcntb_pat ((svpattern) 28); /* { dg-error \"passing 28 to argument 1 of 'svcntb_pat', which expects a valid 'svpattern' value\" } */\n+  svcntb_pat ((svpattern) 29);\n+  svcntb_pat ((svpattern) 30);\n+  svcntb_pat ((svpattern) 31);\n+  svcntb_pat ((svpattern) 32); /* { dg-error \"passing 32 to argument 1 of 'svcntb_pat', which expects a valid 'svpattern' value\" } */\n+}"}, {"sha": "1b939cdf7be04d22f7ed0813404ba49afcd4baee", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/conversion_1.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fconversion_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fconversion_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fconversion_1.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+template<typename T>\n+struct S\n+{\n+  S(T);\n+  operator T() const;\n+  void *base;\n+};\n+\n+void f(svbool_t pg, const S<svuint8_t> &u8a, const S<svuint8_t> &u8b,\n+       const S<svint8_t> &s8a)\n+{\n+  svadd_x(pg, u8a, u8b);\n+  svadd_x(pg, u8a, 1);\n+  svadd_x(pg, s8a, u8b); // { dg-error \"no matching function for call\" }\n+  svadd_x(pg, s8a, 1);\n+}"}, {"sha": "247fd85ece46c6ab2402a99811308f7eb5c51201", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/create2_1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcreate2_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcreate2_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcreate2_1.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svuint8x2_t *ptr, svbool_t pg, svuint8_t u8, svfloat64_t f64,\n+    svuint8x2_t u8x2)\n+{\n+  *ptr = svcreate2 (u8); /* { dg-error {no matching function for call to 'svcreate2\\(svuint8_t\\&\\)'} } */\n+  *ptr = svcreate2 (u8, u8, u8); /* { dg-error {no matching function for call to 'svcreate2\\(svuint8_t\\&, svuint8_t\\&, svuint8_t\\&\\)'} } */\n+  *ptr = svcreate2 (u8x2, u8x2); /* { dg-error {no matching function for call to 'svcreate2\\(svuint8x2_t\\&, svuint8x2_t\\&\\)'} } */\n+  *ptr = svcreate2 (u8, f64); /* { dg-error {no matching function for call to 'svcreate2\\(svuint8_t\\&, svfloat64_t\\&\\)'} } */\n+  *ptr = svcreate2 (u8, pg); /* { dg-error {no matching function for call to 'svcreate2\\(svuint8_t\\&, svbool_t\\&\\)'} } */\n+  *ptr = svcreate2 (u8, u8);\n+  *ptr = svcreate2 (f64, f64); /* { dg-error {cannot convert 'svfloat64x2_t' to 'svuint8x2_t' in assignment} } */\n+}"}, {"sha": "10f3231fa540a47e3bd54f7e06a726f1b8809b70", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/create2_2.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcreate2_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcreate2_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcreate2_2.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svuint8x2_t *ptr, svbool_t pg, svuint8_t u8, svfloat64_t f64,\n+    svuint8x2_t u8x2)\n+{\n+  *ptr = svcreate2_u8 (u8); /* { dg-error {too few arguments to function '[^']*'} } */\n+  *ptr = svcreate2_u8 (u8, u8, u8); /* { dg-error {too many arguments to function '[^']*'} } */\n+  *ptr = svcreate2_u8 (u8x2, u8x2); /* { dg-error {cannot convert 'svuint8x2_t' to 'svuint8_t'} } */\n+  *ptr = svcreate2_u8 (u8, f64); /* { dg-error {cannot convert 'svfloat64_t' to 'svuint8_t'} } */\n+  *ptr = svcreate2_u8 (pg, u8); /* { dg-error {cannot convert 'svbool_t' to 'svuint8_t'} } */\n+  *ptr = svcreate2_u8 (u8, u8);\n+  *ptr = svcreate2_f64 (f64, f64); /* { dg-error {cannot convert 'svfloat64x2_t' to 'svuint8x2_t' in assignment} } */\n+}"}, {"sha": "ff013634d5104cead2af0e89b1c4d4beb97f04ea", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/create3_1.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcreate3_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcreate3_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcreate3_1.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svfloat16x3_t *ptr, svbool_t pg, svfloat16_t f16, svfloat64_t f64,\n+    svfloat16x3_t f16x3)\n+{\n+  *ptr = svcreate3 (f16); /* { dg-error {no matching function for call to 'svcreate3\\(svfloat16_t\\&\\)'} } */\n+  *ptr = svcreate3 (f16, f16); /* { dg-error {no matching function for call to 'svcreate3\\(svfloat16_t\\&, svfloat16_t\\&\\)'} } */\n+  *ptr = svcreate3 (f16, f16, f16, f16); /* { dg-error {no matching function for call to 'svcreate3\\(svfloat16_t\\&, svfloat16_t\\&, svfloat16_t\\&, svfloat16_t\\&\\)'} } */\n+  *ptr = svcreate3 (f16x3, f16x3, f16x3); /* { dg-error {no matching function for call to 'svcreate3\\(svfloat16x3_t\\&, svfloat16x3_t\\&, svfloat16x3_t\\&\\)'} } */\n+  *ptr = svcreate3 (f16, f16, f64); /* { dg-error {no matching function for call to 'svcreate3\\(svfloat16_t\\&, svfloat16_t\\&, svfloat64_t\\&\\)'} } */\n+  *ptr = svcreate3 (f16, pg, f16); /* { dg-error {no matching function for call to 'svcreate3\\(svfloat16_t\\&, svbool_t\\&, svfloat16_t\\&\\)'} } */\n+  *ptr = svcreate3 (f16, f16, f16);\n+  *ptr = svcreate3 (f64, f64, f64); /* { dg-error {cannot convert 'svfloat64x3_t' to 'svfloat16x3_t' in assignment} } */\n+}"}, {"sha": "07a72b1e2319ccd62532a98b65caf767ce869c49", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/create3_2.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcreate3_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcreate3_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcreate3_2.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svfloat16x3_t *ptr, svbool_t pg, svfloat16_t f16, svfloat64_t f64,\n+    svfloat16x3_t f16x3)\n+{\n+  *ptr = svcreate3_f16 (f16); /* { dg-error {too few arguments to function '[^']*'} } */\n+  *ptr = svcreate3_f16 (f16, f16); /* { dg-error {too few arguments to function '[^']*'} } */\n+  *ptr = svcreate3_f16 (f16, f16, f16, f16); /* { dg-error {too many arguments to function '[^']*'} } */\n+  *ptr = svcreate3_f16 (f16x3, f16x3, f16x3); /* { dg-error {cannot convert 'svfloat16x3_t' to 'svfloat16_t'} } */\n+  *ptr = svcreate3_f16 (f16, f16, f64); /* { dg-error {cannot convert 'svfloat64_t' to 'svfloat16_t'} } */\n+  *ptr = svcreate3_f16 (f16, pg, f16); /* { dg-error {cannot convert 'svbool_t' to 'svfloat16_t'} } */\n+  *ptr = svcreate3_f16 (f16, f16, f16);\n+  *ptr = svcreate3_f64 (f64, f64, f64); /* { dg-error {cannot convert 'svfloat64x3_t' to 'svfloat16x3_t' in assignment} } */\n+}"}, {"sha": "2785d90114f9c2309ea3aa4bc99ede7ee4ccac7b", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/create4_1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcreate4_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcreate4_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcreate4_1.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svint32x4_t *ptr, svbool_t pg, svint32_t s32, svfloat64_t f64,\n+    svint32x4_t s32x4)\n+{\n+  *ptr = svcreate4 (s32); /* { dg-error {no matching function for call to 'svcreate4\\(svint32_t\\&\\)'} } */\n+  *ptr = svcreate4 (s32, s32); /* { dg-error {no matching function for call to 'svcreate4\\(svint32_t\\&, svint32_t\\&\\)'} } */\n+  *ptr = svcreate4 (s32, s32, s32); /* { dg-error {no matching function for call to 'svcreate4\\(svint32_t\\&, svint32_t\\&, svint32_t\\&\\)'} } */\n+  *ptr = svcreate4 (s32, s32, s32, s32, s32); /* { dg-error {no matching function for call to 'svcreate4\\(svint32_t\\&, svint32_t\\&, svint32_t\\&, svint32_t\\&, svint32_t\\&\\)'} } */\n+  *ptr = svcreate4 (s32x4, s32x4, s32x4, s32x4); /* { dg-error {no matching function for call to 'svcreate4\\(svint32x4_t\\&, svint32x4_t\\&, svint32x4_t\\&, svint32x4_t\\&\\)'} } */\n+  *ptr = svcreate4 (s32, s32, s32, f64); /* { dg-error {no matching function for call to 'svcreate4\\(svint32_t\\&, svint32_t\\&, svint32_t\\&, svfloat64_t\\&\\)'} } */\n+  *ptr = svcreate4 (s32, pg, s32, s32); /* { dg-error {no matching function for call to 'svcreate4\\(svint32_t\\&, svbool_t\\&, svint32_t\\&, svint32_t\\&\\)'} } */\n+  *ptr = svcreate4 (s32, s32, s32, s32);\n+  *ptr = svcreate4 (f64, f64, f64, f64); /* { dg-error {cannot convert 'svfloat64x4_t' to 'svint32x4_t' in assignment} } */\n+}"}, {"sha": "68f21a1d407763e2322e7b2ece7ef621a4a8e70d", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/create4_2.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcreate4_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcreate4_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fcreate4_2.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svint32x4_t *ptr, svbool_t pg, svint32_t s32, svfloat64_t f64,\n+    svint32x4_t s32x4)\n+{\n+  *ptr = svcreate4_s32 (s32); /* { dg-error {too few arguments to function '[^']*'} } */\n+  *ptr = svcreate4_s32 (s32, s32); /* { dg-error {too few arguments to function '[^']*'} } */\n+  *ptr = svcreate4_s32 (s32, s32, s32); /* { dg-error {too few arguments to function '[^']*'} } */\n+  *ptr = svcreate4_s32 (s32, s32, s32, s32, s32); /* { dg-error {too many arguments to function '[^']*'} } */\n+  *ptr = svcreate4_s32 (s32x4, s32x4, s32x4, s32x4); /* { dg-error {cannot convert 'svint32x4_t' to 'svint32_t'} } */\n+  *ptr = svcreate4_s32 (s32, s32, s32, f64); /* { dg-error {cannot convert 'svfloat64_t' to 'svint32_t'} } */\n+  *ptr = svcreate4_s32 (s32, pg, s32, s32); /* { dg-error {cannot convert 'svbool_t' to 'svint32_t'} } */\n+  *ptr = svcreate4_s32 (s32, s32, s32, s32);\n+  *ptr = svcreate4_f64 (f64, f64, f64, f64); /* { dg-error {cannot convert 'svfloat64x4_t' to 'svint32x4_t' in assignment} } */\n+}"}, {"sha": "93397c82f752f34e0ab66b79caacf8a9991195bb", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/dot_1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fdot_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fdot_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fdot_1.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+\n+#include \"dot_1.h\"\n+\n+svuint32_t\n+f1 (svuint32_t x, svint8_t y, svuint8_t z)\n+{\n+  return svdot_u32 (x, y, z); /* { dg-error \"cannot convert 'svint8_t' to 'svuint8_t'\" } */\n+}"}, {"sha": "aef02f20bcbd76b20cc53ad55cf3533d638ca520", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/dot_1.h", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fdot_1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fdot_1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fdot_1.h?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,2 @@\n+#pragma GCC system_header\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-message \"initializing argument 2\" } */"}, {"sha": "2084ed82887c55f48fef6b5d7ecad0961ed47394", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/dot_2.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fdot_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fdot_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fdot_2.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+\n+#include \"dot_2.h\"\n+\n+void\n+f1 (svuint32_t x, svint8_t y, svuint8_t z)\n+{\n+  svdot (x, y); /* { dg-error {no matching function for call to 'svdot\\(svuint32_t&, svint8_t&\\)'} } */\n+  svdot (x, x, x); /* { dg-error {no matching function for call to 'svdot\\(svuint32_t&, svuint32_t&, svuint32_t&\\)'} } */\n+  svdot (1, z, z); /* { dg-error {no matching function for call to 'svdot\\(int, svuint8_t&, svuint8_t&\\)'} } */\n+  svdot (x, y, z); /* { dg-error {no matching function for call to 'svdot\\(svuint32_t&, svint8_t&, svuint8_t&\\)'} } */\n+}"}, {"sha": "3e4a9c794381c394ffb236bda7bd76005d88feeb", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/dot_2.h", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fdot_2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fdot_2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fdot_2.h?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,7 @@\n+#pragma GCC system_header\n+#pragma GCC aarch64 \"arm_sve.h\"\n+/* { dg-message {note: candidate: 'svuint32_t svdot\\(svuint32_t, svuint8_t, svuint8_t\\)'} \"\" { target *-*-* } 3 } */\n+/* { dg-message {note: *candidate expects 3 arguments, 2 provided} \"\" { target *-*-* } 3 } */\n+/* { dg-message {note: *no known conversion for argument 2 from 'svuint32_t' to 'svuint8_t'} \"\" { target *-*-* } 3 } */\n+/* { dg-message {note: *no known conversion for argument 1 from 'int' to 'svuint32_t'} \"\" { target *-*-* } 3 } */\n+/* { dg-message {note: *no known conversion for argument 2 from 'svint8_t' to 'svuint8_t'} \"\" { target *-*-* } 3 } */"}, {"sha": "8f18810c0cecb20068162645fe9b0e7a504b2058", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/func_redef_1.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+int svadd_n_u8_x; /* { dg-message \"note: previous declaration 'int svadd_n_u8_x'\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-error {'svuint8_t svadd_n_u8_x\\(svbool_t, svuint8_t, [^)\\n]*\\)' redeclared as different kind of entity} } */"}, {"sha": "a67f9f756f05b73f04e34efea6ae42deb7810129", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/func_redef_2.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+int svadd_n_u8_x = 1; /* { dg-message \"note: previous declaration 'int svadd_n_u8_x'\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-error {'svuint8_t svadd_n_u8_x\\(svbool_t, svuint8_t, [^)\\n]*\\)' redeclared as different kind of entity} } */"}, {"sha": "74b820fe6fb6adec168353910ea502a26ca59a3e", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/func_redef_3.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+\n+/* Although not supported, there's nothing to stop the user overloading\n+   the sv* functions.  */\n+extern __SVInt8_t svadd_u8_x (__SVBool_t, __SVInt8_t, __SVInt8_t);\n+\n+#pragma GCC aarch64 \"arm_sve.h\""}, {"sha": "9591e3d01d6a433ec4b46a794042fc713aa96223", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/func_redef_4.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_4.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+\n+/* Although somewhat suspect, this isn't actively wrong, and doesn't need\n+   to be diagnosed.  Any attempt to call the function before including\n+   arm_sve.h will lead to a link failure.  (Same for taking its address,\n+   etc.)  */\n+extern __SVUint8_t svadd_u8_x (__SVBool_t, __SVUint8_t, __SVUint8_t);\n+\n+#pragma GCC aarch64 \"arm_sve.h\""}, {"sha": "f87201984b8398eb91ba0a1e58e391534a5981f2", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/func_redef_5.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_5.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+\n+__SVUint8_t\n+svadd_u8_x (__SVBool_t pg, __SVUint8_t x, __SVUint8_t y)\n+{\n+  return x;\n+}\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+svuint8_t\n+f (svbool_t pg, svuint8_t x, svuint8_t y)\n+{\n+  return svadd_u8_x (pg, x, y);\n+}"}, {"sha": "a65e0d65c1923e1c02c871517a1c7a1ede9ed4a4", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/func_redef_6.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_6.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+typedef int svadd_u8_x; /* { dg-message \"note: previous declaration 'typedef int svadd_u8_x'\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-error {'svuint8_t svadd_u8_x\\(svbool_t, svuint8_t, svuint8_t\\)' redeclared as different kind of entity} } */"}, {"sha": "1f2e4bf66a3b9bc1513e99ab1acb0b041c078f9a", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/func_redef_7.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ffunc_redef_7.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+\n+__SVUint8_t\n+svadd_x (__SVBool_t pg, __SVUint8_t x, __SVUint8_t y)\n+{\n+  return x;\n+}\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+svuint8_t\n+f (svbool_t pg, svuint8_t x, svuint8_t y)\n+{\n+  return svadd_x (pg, x, y);\n+}"}, {"sha": "8d6bb230799192db6f1f77aafab4cdbb502cf0d0", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/get2_1.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fget2_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fget2_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fget2_1.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c++11 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+constexpr uint64_t const_sub (uint64_t a, uint64_t b) { return a - b; }\n+uint64_t add (uint64_t a, uint64_t b) { return a + b; }\n+\n+svfloat64_t\n+f1 (svbool_t pg, svuint8_t u8, svuint8x2_t u8x2, svuint8x3_t u8x3, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  u8 = svget2 (u8x2); /* { dg-error {no matching function for call to 'svget2\\(svuint8x2_t\\&\\)'} } */\n+  u8 = svget2 (u8x2, 1, 2); /* { dg-error {no matching function for call to 'svget2\\(svuint8x2_t\\&, int, int\\)'} } */\n+  u8 = svget2 (u8, 0); /* { dg-error {no matching function for call to 'svget2\\(svuint8_t\\&, int\\)'} } */\n+  u8 = svget2 (u8x3, 0); /* { dg-error {no matching function for call to 'svget2\\(svuint8x3_t\\&, int\\)'} } */\n+  u8 = svget2 (pg, 0); /* { dg-error {no matching function for call to 'svget2\\(svbool_t\\&, int\\)'} } */\n+  u8 = svget2 (u8x2, x); /* { dg-error \"argument 2 of 'svget2' must be an integer constant expression\" } */\n+  u8 = svget2 (u8x2, 0);\n+  f64 = svget2 (u8x2, 0); /* { dg-error \"cannot convert 'svuint8_t' to 'svfloat64_t' in assignment\" } */\n+  u8 = svget2 (u8x2, 1);\n+  u8 = svget2 (u8x2, 2); /* { dg-error {passing 2 to argument 2 of 'svget2', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2 (u8x2, 3); /* { dg-error {passing 3 to argument 2 of 'svget2', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2 (u8x2, 4); /* { dg-error {passing 4 to argument 2 of 'svget2', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2 (u8x2, 5); /* { dg-error {passing 5 to argument 2 of 'svget2', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2 (u8x2, ~0U); /* { dg-error {passing [^ ]* to argument 2 of 'svget2', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2 (u8x2, one);\n+  u8 = svget2 (u8x2, 3 - 2);\n+  u8 = svget2 (u8x2, 1.0);\n+  u8 = svget2 (u8x2, const_sub (5, 4));\n+  u8 = svget2 (u8x2, const_sub (6, 4)); /* { dg-error {passing 2 to argument 2 of 'svget2', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2 (u8x2, const_sub (7, 4)); /* { dg-error {passing 3 to argument 2 of 'svget2', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2 (u8x2, const_sub (8, 4)); /* { dg-error {passing 4 to argument 2 of 'svget2', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2 (u8x2, add (0, 0)); /* { dg-error \"argument 2 of 'svget2' must be an integer constant expression\" } */\n+\n+  return f64;\n+}"}, {"sha": "9c7674be11eb14310dcb9d587fdc0415f4b3b0eb", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/get2_2.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fget2_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fget2_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fget2_2.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c++11 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+constexpr uint64_t const_sub (uint64_t a, uint64_t b) { return a - b; }\n+uint64_t add (uint64_t a, uint64_t b) { return a + b; }\n+\n+svfloat64_t\n+f1 (svbool_t pg, svuint8_t u8, svuint8x2_t u8x2, svuint8x3_t u8x3, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  u8 = svget2_u8 (u8x2); /* { dg-error {too few arguments to function '[^']*'} } */\n+  u8 = svget2_u8 (u8x2, 1, 2); /* { dg-error {too many arguments to function '[^']*'} } */\n+  u8 = svget2_u8 (u8, 0); /* { dg-error {cannot convert 'svuint8_t' to 'svuint8x2_t'} } */\n+  u8 = svget2_u8 (u8x3, 0); /* { dg-error {cannot convert 'svuint8x3_t' to 'svuint8x2_t'} } */\n+  u8 = svget2_u8 (pg, 0); /* { dg-error {cannot convert 'svbool_t' to 'svuint8x2_t'} } */\n+  u8 = svget2_u8 (u8x2, x); /* { dg-error \"argument 2 of 'svget2_u8' must be an integer constant expression\" } */\n+  u8 = svget2_u8 (u8x2, 0);\n+  f64 = svget2_u8 (u8x2, 0); /* { dg-error \"cannot convert 'svuint8_t' to 'svfloat64_t' in assignment\" } */\n+  u8 = svget2_u8 (u8x2, 1);\n+  u8 = svget2_u8 (u8x2, 2); /* { dg-error {passing 2 to argument 2 of 'svget2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2_u8 (u8x2, 3); /* { dg-error {passing 3 to argument 2 of 'svget2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2_u8 (u8x2, 4); /* { dg-error {passing 4 to argument 2 of 'svget2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2_u8 (u8x2, 5); /* { dg-error {passing 5 to argument 2 of 'svget2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2_u8 (u8x2, ~0U); /* { dg-error {passing [^ ]* to argument 2 of 'svget2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2_u8 (u8x2, one);\n+  u8 = svget2_u8 (u8x2, 3 - 2);\n+  u8 = svget2_u8 (u8x2, 1.0);\n+  u8 = svget2_u8 (u8x2, const_sub (5, 4));\n+  u8 = svget2_u8 (u8x2, const_sub (6, 4)); /* { dg-error {passing 2 to argument 2 of 'svget2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2_u8 (u8x2, const_sub (7, 4)); /* { dg-error {passing 3 to argument 2 of 'svget2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2_u8 (u8x2, const_sub (8, 4)); /* { dg-error {passing 4 to argument 2 of 'svget2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2_u8 (u8x2, add (0, 0)); /* { dg-error \"argument 2 of 'svget2_u8' must be an integer constant expression\" } */\n+\n+  return f64;\n+}"}, {"sha": "bd8808a8b475599eba27aa1a821eb9e5931495b2", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/get3_1.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fget3_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fget3_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fget3_1.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c++11 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+constexpr uint64_t const_sub (uint64_t a, uint64_t b) { return a - b; }\n+uint64_t add (uint64_t a, uint64_t b) { return a + b; }\n+\n+svfloat64_t\n+f1 (svbool_t pg, svfloat16_t f16, svfloat16x3_t f16x3, svfloat16x4_t f16x4,\n+    int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  f16 = svget3 (f16x3); /* { dg-error {no matching function for call to 'svget3\\(svfloat16x3_t\\&\\)'} } */\n+  f16 = svget3 (f16x3, 1, 2); /* { dg-error {no matching function for call to 'svget3\\(svfloat16x3_t\\&, int, int\\)'} } */\n+  f16 = svget3 (f16, 0); /* { dg-error {no matching function for call to 'svget3\\(svfloat16_t\\&, int\\)'} } */\n+  f16 = svget3 (f16x4, 0); /* { dg-error {no matching function for call to 'svget3\\(svfloat16x4_t\\&, int\\)'} } */\n+  f16 = svget3 (pg, 0); /* { dg-error {no matching function for call to 'svget3\\(svbool_t\\&, int\\)'} } */\n+  f16 = svget3 (f16x3, x); /* { dg-error \"argument 2 of 'svget3' must be an integer constant expression\" } */\n+  f16 = svget3 (f16x3, 0);\n+  f64 = svget3 (f16x3, 0); /* { dg-error \"cannot convert 'svfloat16_t' to 'svfloat64_t' in assignment\" } */\n+  f16 = svget3 (f16x3, 1);\n+  f16 = svget3 (f16x3, 2);\n+  f16 = svget3 (f16x3, 3); /* { dg-error {passing 3 to argument 2 of 'svget3', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3 (f16x3, 4); /* { dg-error {passing 4 to argument 2 of 'svget3', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3 (f16x3, 5); /* { dg-error {passing 5 to argument 2 of 'svget3', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3 (f16x3, ~0U); /* { dg-error {passing [^ ]* to argument 2 of 'svget3', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3 (f16x3, one);\n+  f16 = svget3 (f16x3, 3 - 2);\n+  f16 = svget3 (f16x3, 1.0);\n+  f16 = svget3 (f16x3, const_sub (5, 4));\n+  f16 = svget3 (f16x3, const_sub (6, 4));\n+  f16 = svget3 (f16x3, const_sub (7, 4)); /* { dg-error {passing 3 to argument 2 of 'svget3', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3 (f16x3, const_sub (8, 4)); /* { dg-error {passing 4 to argument 2 of 'svget3', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3 (f16x3, add (0, 0)); /* { dg-error \"argument 2 of 'svget3' must be an integer constant expression\" } */\n+\n+  return f64;\n+}"}, {"sha": "d526947d1ab53a7fd69e01c3289df0c14814ae39", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/get3_2.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fget3_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fget3_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fget3_2.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c++11 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+constexpr uint64_t const_sub (uint64_t a, uint64_t b) { return a - b; }\n+uint64_t add (uint64_t a, uint64_t b) { return a + b; }\n+\n+svfloat64_t\n+f1 (svbool_t pg, svfloat16_t f16, svfloat16x3_t f16x3, svfloat16x4_t f16x4,\n+    int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  f16 = svget3_f16 (f16x3); /* { dg-error {too few arguments to function '[^']*'} } */\n+  f16 = svget3_f16 (f16x3, 1, 2); /* { dg-error {too many arguments to function '[^']*'} } */\n+  f16 = svget3_f16 (f16, 0); /* { dg-error {cannot convert 'svfloat16_t' to 'svfloat16x3_t'} } */\n+  f16 = svget3_f16 (f16x4, 0); /* { dg-error {cannot convert 'svfloat16x4_t' to 'svfloat16x3_t'} } */\n+  f16 = svget3_f16 (pg, 0); /* { dg-error {cannot convert 'svbool_t' to 'svfloat16x3_t'} } */\n+  f16 = svget3_f16 (f16x3, x); /* { dg-error \"argument 2 of 'svget3_f16' must be an integer constant expression\" } */\n+  f16 = svget3_f16 (f16x3, 0);\n+  f64 = svget3_f16 (f16x3, 0); /* { dg-error \"cannot convert 'svfloat16_t' to 'svfloat64_t' in assignment\" } */\n+  f16 = svget3_f16 (f16x3, 1);\n+  f16 = svget3_f16 (f16x3, 2);\n+  f16 = svget3_f16 (f16x3, 3); /* { dg-error {passing 3 to argument 2 of 'svget3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3_f16 (f16x3, 4); /* { dg-error {passing 4 to argument 2 of 'svget3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3_f16 (f16x3, 5); /* { dg-error {passing 5 to argument 2 of 'svget3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3_f16 (f16x3, ~0U); /* { dg-error {passing [^ ]* to argument 2 of 'svget3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3_f16 (f16x3, one);\n+  f16 = svget3_f16 (f16x3, 3 - 2);\n+  f16 = svget3_f16 (f16x3, 1.0);\n+  f16 = svget3_f16 (f16x3, const_sub (5, 4));\n+  f16 = svget3_f16 (f16x3, const_sub (6, 4));\n+  f16 = svget3_f16 (f16x3, const_sub (7, 4)); /* { dg-error {passing 3 to argument 2 of 'svget3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3_f16 (f16x3, const_sub (8, 4)); /* { dg-error {passing 4 to argument 2 of 'svget3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3_f16 (f16x3, add (0, 0)); /* { dg-error \"argument 2 of 'svget3_f16' must be an integer constant expression\" } */\n+\n+  return f64;\n+}"}, {"sha": "19853dece5b004ccf9098776da16eea6503cb527", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/get4_1.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fget4_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fget4_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fget4_1.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c++11 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+constexpr uint64_t const_sub (uint64_t a, uint64_t b) { return a - b; }\n+uint64_t add (uint64_t a, uint64_t b) { return a + b; }\n+\n+svfloat64_t\n+f1 (svbool_t pg, svint32_t s32, svint32x4_t s32x4, svint32x2_t s32x2, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  s32 = svget4 (s32x4); /* { dg-error {no matching function for call to 'svget4\\(svint32x4_t\\&\\)'} } */\n+  s32 = svget4 (s32x4, 1, 2); /* { dg-error {no matching function for call to 'svget4\\(svint32x4_t\\&, int, int\\)'} } */\n+  s32 = svget4 (s32, 0); /* { dg-error {no matching function for call to 'svget4\\(svint32_t\\&, int\\)'} } */\n+  s32 = svget4 (s32x2, 0); /* { dg-error {no matching function for call to 'svget4\\(svint32x2_t\\&, int\\)'} } */\n+  s32 = svget4 (pg, 0); /* { dg-error {no matching function for call to 'svget4\\(svbool_t\\&, int\\)'} } */\n+  s32 = svget4 (s32x4, x); /* { dg-error \"argument 2 of 'svget4' must be an integer constant expression\" } */\n+  s32 = svget4 (s32x4, 0);\n+  f64 = svget4 (s32x4, 0); /* { dg-error \"cannot convert 'svint32_t' to 'svfloat64_t' in assignment\" } */\n+  s32 = svget4 (s32x4, 1);\n+  s32 = svget4 (s32x4, 2);\n+  s32 = svget4 (s32x4, 3);\n+  s32 = svget4 (s32x4, 4); /* { dg-error {passing 4 to argument 2 of 'svget4', which expects a value in the range \\[0, 3\\]} } */\n+  s32 = svget4 (s32x4, 5); /* { dg-error {passing 5 to argument 2 of 'svget4', which expects a value in the range \\[0, 3\\]} } */\n+  s32 = svget4 (s32x4, ~0U); /* { dg-error {passing [^ ]* to argument 2 of 'svget4', which expects a value in the range \\[0, 3\\]} } */\n+  s32 = svget4 (s32x4, one);\n+  s32 = svget4 (s32x4, 3 - 2);\n+  s32 = svget4 (s32x4, 1.0);\n+  s32 = svget4 (s32x4, const_sub (5, 4));\n+  s32 = svget4 (s32x4, const_sub (6, 4));\n+  s32 = svget4 (s32x4, const_sub (7, 4));\n+  s32 = svget4 (s32x4, const_sub (8, 4)); /* { dg-error {passing 4 to argument 2 of 'svget4', which expects a value in the range \\[0, 3\\]} } */\n+  s32 = svget4 (s32x4, add (0, 0)); /* { dg-error \"argument 2 of 'svget4' must be an integer constant expression\" } */\n+\n+  return f64;\n+}"}, {"sha": "7a0979225267e9cce5e3d2427505bc32081a4503", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/get4_2.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fget4_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fget4_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fget4_2.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c++11 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+constexpr uint64_t const_sub (uint64_t a, uint64_t b) { return a - b; }\n+uint64_t add (uint64_t a, uint64_t b) { return a + b; }\n+\n+svfloat64_t\n+f1 (svbool_t pg, svint32_t s32, svint32x4_t s32x4, svint32x2_t s32x2, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  s32 = svget4_s32 (s32x4); /* { dg-error {too few arguments to function '[^']*'} } */\n+  s32 = svget4_s32 (s32x4, 1, 2); /* { dg-error {too many arguments to function '[^']*'} } */\n+  s32 = svget4_s32 (s32, 0); /* { dg-error {cannot convert 'svint32_t' to 'svint32x4_t'} } */\n+  s32 = svget4_s32 (s32x2, 0); /* { dg-error {cannot convert 'svint32x2_t' to 'svint32x4_t'} } */\n+  s32 = svget4_s32 (pg, 0); /* { dg-error {cannot convert 'svbool_t' to 'svint32x4_t'} } */\n+  s32 = svget4_s32 (s32x4, x); /* { dg-error \"argument 2 of 'svget4_s32' must be an integer constant expression\" } */\n+  s32 = svget4_s32 (s32x4, 0);\n+  f64 = svget4_s32 (s32x4, 0); /* { dg-error \"cannot convert 'svint32_t' to 'svfloat64_t' in assignment\" } */\n+  s32 = svget4_s32 (s32x4, 1);\n+  s32 = svget4_s32 (s32x4, 2);\n+  s32 = svget4_s32 (s32x4, 3);\n+  s32 = svget4_s32 (s32x4, 4); /* { dg-error {passing 4 to argument 2 of 'svget4_s32', which expects a value in the range \\[0, 3\\]} } */\n+  s32 = svget4_s32 (s32x4, 5); /* { dg-error {passing 5 to argument 2 of 'svget4_s32', which expects a value in the range \\[0, 3\\]} } */\n+  s32 = svget4_s32 (s32x4, ~0U); /* { dg-error {passing [^ ]* to argument 2 of 'svget4_s32', which expects a value in the range \\[0, 3\\]} } */\n+  s32 = svget4_s32 (s32x4, one);\n+  s32 = svget4_s32 (s32x4, 3 - 2);\n+  s32 = svget4_s32 (s32x4, 1.0);\n+  s32 = svget4_s32 (s32x4, const_sub (5, 4));\n+  s32 = svget4_s32 (s32x4, const_sub (6, 4));\n+  s32 = svget4_s32 (s32x4, const_sub (7, 4));\n+  s32 = svget4_s32 (s32x4, const_sub (8, 4)); /* { dg-error {passing 4 to argument 2 of 'svget4_s32', which expects a value in the range \\[0, 3\\]} } */\n+  s32 = svget4_s32 (s32x4, add (0, 0)); /* { dg-error \"argument 2 of 'svget4_s32' must be an integer constant expression\" } */\n+\n+  return f64;\n+}"}, {"sha": "fb31e947dfd1532cee7ab7c5737297b7673c859e", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/lsl_wide_1.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Flsl_wide_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Flsl_wide_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Flsl_wide_1.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+svuint8_t\n+f1 (svbool_t pg, svuint8_t x, svint8_t w, svuint64_t y)\n+{\n+  svlsl_wide_u8_x (pg, x, x); /* { dg-error \"cannot convert 'svuint8_t' to 'svuint64_t'\" } */\n+  svlsl_wide_u8_x (pg, x); /* { dg-error {too few arguments to function 'svuint8_t svlsl_wide_u8_x\\(svbool_t, svuint8_t, svuint64_t\\)'} } */\n+  svlsl_wide_u8_x (pg, x, y, x); /* { dg-error {too many arguments to function 'svuint8_t svlsl_wide_u8_x\\(svbool_t, svuint8_t, svuint64_t\\)'} } */\n+  return svlsl_wide_s8_x (pg, w, y); /* { dg-error {cannot convert 'svint8_t' to 'svuint8_t' in return} } */\n+}"}, {"sha": "95d341dc5ed97f300c759342c0f65d046dad3f34", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/lsl_wide_2.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Flsl_wide_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Flsl_wide_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Flsl_wide_2.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+void\n+f1 (svbool_t pg, svuint8_t x, svuint64_t y)\n+{\n+  svlsl_wide_x (pg, x); /* { dg-error {no matching function for call to 'svlsl_wide_x\\(svbool_t&, svuint8_t&\\)'} } */\n+  svlsl_wide_x (pg, x, x, x, x); /* { dg-error {no matching function for call to 'svlsl_wide_x\\(svbool_t&, svuint8_t&, svuint8_t&, svuint8_t&, svuint8_t&\\)'} } */\n+  svlsl_wide_x (x, x, y); /* { dg-error {no matching function for call to 'svlsl_wide_x\\(svuint8_t&, svuint8_t&, svuint64_t&\\)'} } */\n+  svlsl_wide_x (pg, 1, y); /* { dg-error {no matching function for call to 'svlsl_wide_x\\(svbool_t&, int, svuint64_t&\\)'} } */\n+  svlsl_wide_x (pg, x, x); /* { dg-error {no matching function for call to 'svlsl_wide_x\\(svbool_t&, svuint8_t&, svuint8_t&\\)'} } */\n+  svlsl_wide_x (pg, y, y); /* { dg-error {no matching function for call to 'svlsl_wide_x\\(svbool_t&, svuint64_t&, svuint64_t&\\)'} } */\n+}"}, {"sha": "1138f2e22de7db23820929f99ad3f346e0f9cae9", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/mangle_1.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_1.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void f1(svbool_t) {}\n+void f2(svint8_t) {}\n+void f3(svint16_t) {}\n+void f4(svint32_t) {}\n+void f5(svint64_t) {}\n+void f6(svuint8_t) {}\n+void f7(svuint16_t) {}\n+void f8(svuint32_t) {}\n+void f9(svuint64_t) {}\n+void f10(svfloat16_t) {}\n+void f11(svfloat32_t) {}\n+void f12(svfloat64_t) {}\n+\n+/* { dg-final { scan-assembler \"_Z2f110__SVBool_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f210__SVInt8_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f311__SVInt16_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f411__SVInt32_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f511__SVInt64_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f611__SVUint8_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f712__SVUint16_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f812__SVUint32_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f912__SVUint64_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f1013__SVFloat16_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f1113__SVFloat32_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f1213__SVFloat64_t:\" } } */"}, {"sha": "575b262b282c4f98224ae6c0d7d5d265d7ce4303", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/mangle_2.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_2.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+\n+void f1(__SVBool_t) {}\n+void f2(__SVInt8_t) {}\n+void f3(__SVInt16_t) {}\n+void f4(__SVInt32_t) {}\n+void f5(__SVInt64_t) {}\n+void f6(__SVUint8_t) {}\n+void f7(__SVUint16_t) {}\n+void f8(__SVUint32_t) {}\n+void f9(__SVUint64_t) {}\n+void f10(__SVFloat16_t) {}\n+void f11(__SVFloat32_t) {}\n+void f12(__SVFloat64_t) {}\n+\n+/* { dg-final { scan-assembler \"_Z2f110__SVBool_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f210__SVInt8_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f311__SVInt16_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f411__SVInt32_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f511__SVInt64_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f611__SVUint8_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f712__SVUint16_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f812__SVUint32_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f912__SVUint64_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f1013__SVFloat16_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f1113__SVFloat32_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f1213__SVFloat64_t:\" } } */"}, {"sha": "8f64f7c2ee2320b28295e660292a33c040554861", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/mangle_3.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_3.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-msve-vector-bits=256\" } */\n+\n+#include <arm_sve.h>\n+\n+typedef __SVInt8_t t1;\n+typedef svint8_t t2;\n+/* Distinct from svint8_t, but compatible with it.  */\n+typedef int8_t t3 __attribute__((vector_size(32)));\n+\n+void f1(t1) {}\n+void f2(t2) {}\n+void f3(t3) {}\n+void f4(t1 &a, t2 &b, t3 &c) { a = b = c; }\n+\n+/* { dg-final { scan-assembler \"_Z2f110__SVInt8_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f210__SVInt8_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f3Dv32_a:\" } } */"}, {"sha": "7cdc6cb0c4eae89d9597477d22a777a128aa16fe", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/mangle_4.C", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_4.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,75 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void f1(svint8x2_t) {}\n+void f2(svint16x2_t) {}\n+void f3(svint32x2_t) {}\n+void f4(svint64x2_t) {}\n+void f5(svuint8x2_t) {}\n+void f6(svuint16x2_t) {}\n+void f7(svuint32x2_t) {}\n+void f8(svuint64x2_t) {}\n+void f9(svfloat16x2_t) {}\n+void f10(svfloat32x2_t) {}\n+void f11(svfloat64x2_t) {}\n+\n+void g1(svint8x3_t) {}\n+void g2(svint16x3_t) {}\n+void g3(svint32x3_t) {}\n+void g4(svint64x3_t) {}\n+void g5(svuint8x3_t) {}\n+void g6(svuint16x3_t) {}\n+void g7(svuint32x3_t) {}\n+void g8(svuint64x3_t) {}\n+void g9(svfloat16x3_t) {}\n+void g10(svfloat32x3_t) {}\n+void g11(svfloat64x3_t) {}\n+\n+void h1(svint8x4_t) {}\n+void h2(svint16x4_t) {}\n+void h3(svint32x4_t) {}\n+void h4(svint64x4_t) {}\n+void h5(svuint8x4_t) {}\n+void h6(svuint16x4_t) {}\n+void h7(svuint32x4_t) {}\n+void h8(svuint64x4_t) {}\n+void h9(svfloat16x4_t) {}\n+void h10(svfloat32x4_t) {}\n+void h11(svfloat64x4_t) {}\n+\n+/* { dg-final { scan-assembler \"_Z2f110svint8x2_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f211svint16x2_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f311svint32x2_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f411svint64x2_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f511svuint8x2_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f612svuint16x2_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f712svuint32x2_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f812svuint64x2_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f913svfloat16x2_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f1013svfloat32x2_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f1113svfloat64x2_t:\" } } */\n+\n+/* { dg-final { scan-assembler \"_Z2g110svint8x3_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2g211svint16x3_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2g311svint32x3_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2g411svint64x3_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2g511svuint8x3_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2g612svuint16x3_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2g712svuint32x3_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2g812svuint64x3_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2g913svfloat16x3_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z3g1013svfloat32x3_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z3g1113svfloat64x3_t:\" } } */\n+\n+/* { dg-final { scan-assembler \"_Z2h110svint8x4_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2h211svint16x4_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2h311svint32x4_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2h411svint64x4_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2h511svuint8x4_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2h612svuint16x4_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2h712svuint32x4_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2h812svuint64x4_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z2h913svfloat16x4_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z3h1013svfloat32x4_t:\" } } */\n+/* { dg-final { scan-assembler \"_Z3h1113svfloat64x4_t:\" } } */"}, {"sha": "80c3ad74fb8d8938de13aaba7dd2685454b59a96", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/set2_1.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fset2_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fset2_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fset2_1.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c++11 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+constexpr uint64_t const_sub (uint64_t a, uint64_t b) { return a - b; }\n+uint64_t add (uint64_t a, uint64_t b) { return a + b; }\n+\n+svfloat64_t\n+f1 (svbool_t pg, svuint8_t u8, svuint8x2_t u8x2, svint8x2_t s8x2,\n+    svuint8x3_t u8x3, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  u8x2 = svset2 (u8x2); /* { dg-error {no matching function for call to 'svset2\\(svuint8x2_t\\&\\)'} } */\n+  u8x2 = svset2 (u8x2, 1); /* { dg-error {no matching function for call to 'svset2\\(svuint8x2_t\\&, int\\)'} } */\n+  u8x2 = svset2 (u8x2, 1, u8, 2); /* { dg-error {no matching function for call to 'svset2\\(svuint8x2_t\\&, int, svuint8_t\\&, int\\)'} } */\n+  u8x2 = svset2 (u8, 0, u8); /* { dg-error {no matching function for call to 'svset2\\(svuint8_t\\&, int, svuint8_t\\&\\)'} } */\n+  u8x2 = svset2 (s8x2, 0, u8); /* { dg-error {no matching function for call to 'svset2\\(svint8x2_t\\&, int, svuint8_t\\&\\)'} } */\n+  u8x2 = svset2 (u8x3, 0, u8); /* { dg-error {no matching function for call to 'svset2\\(svuint8x3_t\\&, int, svuint8_t\\&\\)'} } */\n+  u8x2 = svset2 (pg, 0, u8); /* { dg-error {no matching function for call to 'svset2\\(svbool_t\\&, int, svuint8_t\\&\\)'} } */\n+  u8x2 = svset2 (u8x2, 0, f64); /* { dg-error {no matching function for call to 'svset2\\(svuint8x2_t\\&, int, svfloat64_t\\&\\)'} } */\n+  u8x2 = svset2 (u8x2, 0, u8x2); /* { dg-error {no matching function for call to 'svset2\\(svuint8x2_t\\&, int, svuint8x2_t\\&\\)'} } */\n+  u8x2 = svset2 (u8x2, 0, pg); /* { dg-error {no matching function for call to 'svset2\\(svuint8x2_t\\&, int, svbool_t\\&\\)'} } */\n+  u8x2 = svset2 (u8x2, x, u8); /* { dg-error \"argument 2 of 'svset2' must be an integer constant expression\" } */\n+  u8x2 = svset2 (u8x2, 0, u8);\n+  s8x2 = svset2 (u8x2, 0, u8); /* { dg-error {cannot convert 'svuint8x2_t' to 'svint8x2_t' in assignment} } */\n+  u8x2 = svset2 (u8x2, 1, u8);\n+  u8x2 = svset2 (u8x2, 2, u8); /* { dg-error {passing 2 to argument 2 of 'svset2', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2 (u8x2, 3, u8); /* { dg-error {passing 3 to argument 2 of 'svset2', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2 (u8x2, 4, u8); /* { dg-error {passing 4 to argument 2 of 'svset2', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2 (u8x2, 5, u8); /* { dg-error {passing 5 to argument 2 of 'svset2', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2 (u8x2, ~0U, u8); /* { dg-error {passing [^ ]* to argument 2 of 'svset2', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2 (u8x2, one, u8);\n+  u8x2 = svset2 (u8x2, 3 - 2, u8);\n+  u8x2 = svset2 (u8x2, 1.0, u8);\n+  u8x2 = svset2 (u8x2, const_sub (5, 4), u8);\n+  u8x2 = svset2 (u8x2, const_sub (6, 4), u8); /* { dg-error {passing 2 to argument 2 of 'svset2', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2 (u8x2, const_sub (7, 4), u8); /* { dg-error {passing 3 to argument 2 of 'svset2', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2 (u8x2, const_sub (8, 4), u8); /* { dg-error {passing 4 to argument 2 of 'svset2', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2 (u8x2, add (0, 0), u8); /* { dg-error \"argument 2 of 'svset2' must be an integer constant expression\" } */\n+\n+  return f64;\n+}"}, {"sha": "1433b78ba2f09ce3339a45a50a9cdb8330d1a371", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/set2_2.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fset2_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fset2_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fset2_2.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c++11 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+constexpr uint64_t const_sub (uint64_t a, uint64_t b) { return a - b; }\n+uint64_t add (uint64_t a, uint64_t b) { return a + b; }\n+\n+svfloat64_t\n+f1 (svbool_t pg, svuint8_t u8, svuint8x2_t u8x2, svint8x2_t s8x2,\n+    svuint8x3_t u8x3, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  u8x2 = svset2_u8 (u8x2); /* { dg-error {too few arguments to function '[^']*'} } */\n+  u8x2 = svset2_u8 (u8x2, 1); /* { dg-error {too few arguments to function '[^']*'} } */\n+  u8x2 = svset2_u8 (u8x2, 1, u8, 2); /* { dg-error {too many arguments to function '[^']*'} } */\n+  u8x2 = svset2_u8 (u8, 0, u8); /* { dg-error {cannot convert 'svuint8_t' to 'svuint8x2_t'} } */\n+  u8x2 = svset2_u8 (s8x2, 0, u8); /* { dg-error {cannot convert 'svint8x2_t' to 'svuint8x2_t'} } */\n+  u8x2 = svset2_u8 (u8x3, 0, u8); /* { dg-error {cannot convert 'svuint8x3_t' to 'svuint8x2_t'} } */\n+  u8x2 = svset2_u8 (pg, 0, u8); /* { dg-error {cannot convert 'svbool_t' to 'svuint8x2_t'} } */\n+  u8x2 = svset2_u8 (u8x2, 0, f64); /* { dg-error {cannot convert 'svfloat64_t' to 'svuint8_t'} } */\n+  u8x2 = svset2_u8 (u8x2, 0, u8x2); /* { dg-error {cannot convert 'svuint8x2_t' to 'svuint8_t'} } */\n+  u8x2 = svset2_u8 (u8x2, 0, pg); /* { dg-error {cannot convert 'svbool_t' to 'svuint8_t'} } */\n+  u8x2 = svset2_u8 (u8x2, x, u8); /* { dg-error \"argument 2 of 'svset2_u8' must be an integer constant expression\" } */\n+  u8x2 = svset2_u8 (u8x2, 0, u8);\n+  s8x2 = svset2_u8 (u8x2, 0, u8); /* { dg-error {cannot convert 'svuint8x2_t' to 'svint8x2_t' in assignment} } */\n+  u8x2 = svset2_u8 (u8x2, 1, u8);\n+  u8x2 = svset2_u8 (u8x2, 2, u8); /* { dg-error {passing 2 to argument 2 of 'svset2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2_u8 (u8x2, 3, u8); /* { dg-error {passing 3 to argument 2 of 'svset2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2_u8 (u8x2, 4, u8); /* { dg-error {passing 4 to argument 2 of 'svset2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2_u8 (u8x2, 5, u8); /* { dg-error {passing 5 to argument 2 of 'svset2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2_u8 (u8x2, ~0U, u8); /* { dg-error {passing [^ ]* to argument 2 of 'svset2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2_u8 (u8x2, one, u8);\n+  u8x2 = svset2_u8 (u8x2, 3 - 2, u8);\n+  u8x2 = svset2_u8 (u8x2, 1.0, u8);\n+  u8x2 = svset2_u8 (u8x2, const_sub (5, 4), u8);\n+  u8x2 = svset2_u8 (u8x2, const_sub (6, 4), u8); /* { dg-error {passing 2 to argument 2 of 'svset2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2_u8 (u8x2, const_sub (7, 4), u8); /* { dg-error {passing 3 to argument 2 of 'svset2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2_u8 (u8x2, const_sub (8, 4), u8); /* { dg-error {passing 4 to argument 2 of 'svset2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2_u8 (u8x2, add (0, 0), u8); /* { dg-error \"argument 2 of 'svset2_u8' must be an integer constant expression\" } */\n+\n+  return f64;\n+}"}, {"sha": "9bb4f7a04b3ae90e1419faf1a7a820d225ddbec4", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/set3_1.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fset3_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fset3_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fset3_1.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c++11 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+constexpr uint64_t const_sub (uint64_t a, uint64_t b) { return a - b; }\n+uint64_t add (uint64_t a, uint64_t b) { return a + b; }\n+\n+svfloat64_t\n+f1 (svbool_t pg, svfloat16_t f16, svfloat16x3_t f16x3, svuint16x3_t u16x3,\n+    svfloat16x4_t f16x4, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  f16x3 = svset3 (f16x3); /* { dg-error {no matching function for call to 'svset3\\(svfloat16x3_t\\&\\)'} } */\n+  f16x3 = svset3 (f16x3, 1); /* { dg-error {no matching function for call to 'svset3\\(svfloat16x3_t\\&, int\\)'} } */\n+  f16x3 = svset3 (f16x3, 1, f16, 2); /* { dg-error {no matching function for call to 'svset3\\(svfloat16x3_t\\&, int, svfloat16_t\\&, int\\)'} } */\n+  f16x3 = svset3 (f16, 0, f16); /* { dg-error {no matching function for call to 'svset3\\(svfloat16_t\\&, int, svfloat16_t\\&\\)'} } */\n+  f16x3 = svset3 (u16x3, 0, f16); /* { dg-error {no matching function for call to 'svset3\\(svuint16x3_t\\&, int, svfloat16_t\\&\\)'} } */\n+  f16x3 = svset3 (f16x4, 0, f16); /* { dg-error {no matching function for call to 'svset3\\(svfloat16x4_t\\&, int, svfloat16_t\\&\\)'} } */\n+  f16x3 = svset3 (pg, 0, f16); /* { dg-error {no matching function for call to 'svset3\\(svbool_t\\&, int, svfloat16_t\\&\\)'} } */\n+  f16x3 = svset3 (f16x3, 0, f64); /* { dg-error {no matching function for call to 'svset3\\(svfloat16x3_t\\&, int, svfloat64_t\\&\\)'} } */\n+  f16x3 = svset3 (f16x3, 0, f16x3); /* { dg-error {no matching function for call to 'svset3\\(svfloat16x3_t\\&, int, svfloat16x3_t\\&\\)'} } */\n+  f16x3 = svset3 (f16x3, 0, pg); /* { dg-error {no matching function for call to 'svset3\\(svfloat16x3_t\\&, int, svbool_t\\&\\)'} } */\n+  f16x3 = svset3 (f16x3, x, f16); /* { dg-error \"argument 2 of 'svset3' must be an integer constant expression\" } */\n+  f16x3 = svset3 (f16x3, 0, f16);\n+  u16x3 = svset3 (f16x3, 0, f16); /* { dg-error {cannot convert 'svfloat16x3_t' to 'svuint16x3_t' in assignment} } */\n+  f16x3 = svset3 (f16x3, 1, f16);\n+  f16x3 = svset3 (f16x3, 2, f16);\n+  f16x3 = svset3 (f16x3, 3, f16); /* { dg-error {passing 3 to argument 2 of 'svset3', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3 (f16x3, 4, f16); /* { dg-error {passing 4 to argument 2 of 'svset3', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3 (f16x3, 5, f16); /* { dg-error {passing 5 to argument 2 of 'svset3', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3 (f16x3, ~0U, f16); /* { dg-error {passing [^ ]* to argument 2 of 'svset3', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3 (f16x3, one, f16);\n+  f16x3 = svset3 (f16x3, 3 - 2, f16);\n+  f16x3 = svset3 (f16x3, 1.0, f16);\n+  f16x3 = svset3 (f16x3, const_sub (5, 4), f16);\n+  f16x3 = svset3 (f16x3, const_sub (6, 4), f16);\n+  f16x3 = svset3 (f16x3, const_sub (7, 4), f16); /* { dg-error {passing 3 to argument 2 of 'svset3', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3 (f16x3, const_sub (8, 4), f16); /* { dg-error {passing 4 to argument 2 of 'svset3', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3 (f16x3, add (0, 0), f16); /* { dg-error \"argument 2 of 'svset3' must be an integer constant expression\" } */\n+\n+  return f64;\n+}"}, {"sha": "0bb60492484df55182dfde21c8c22ef28a7ca313", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/set3_2.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fset3_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fset3_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fset3_2.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c++11 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+constexpr uint64_t const_sub (uint64_t a, uint64_t b) { return a - b; }\n+uint64_t add (uint64_t a, uint64_t b) { return a + b; }\n+\n+svfloat64_t\n+f1 (svbool_t pg, svfloat16_t f16, svfloat16x3_t f16x3, svuint16x3_t u16x3,\n+    svfloat16x4_t f16x4, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  f16x3 = svset3_f16 (f16x3); /* { dg-error {too few arguments to function '[^']*'} } */\n+  f16x3 = svset3_f16 (f16x3, 1); /* { dg-error {too few arguments to function '[^']*'} } */\n+  f16x3 = svset3_f16 (f16x3, 1, f16, 2); /* { dg-error {too many arguments to function '[^']*'} } */\n+  f16x3 = svset3_f16 (f16, 0, f16); /* { dg-error {cannot convert 'svfloat16_t' to 'svfloat16x3_t'} } */\n+  f16x3 = svset3_f16 (u16x3, 0, f16); /* { dg-error {cannot convert 'svuint16x3_t' to 'svfloat16x3_t'} } */\n+  f16x3 = svset3_f16 (f16x4, 0, f16); /* { dg-error {cannot convert 'svfloat16x4_t' to 'svfloat16x3_t'} } */\n+  f16x3 = svset3_f16 (pg, 0, f16); /* { dg-error {cannot convert 'svbool_t' to 'svfloat16x3_t'} } */\n+  f16x3 = svset3_f16 (f16x3, 0, f64); /* { dg-error {cannot convert 'svfloat64_t' to 'svfloat16_t'} } */\n+  f16x3 = svset3_f16 (f16x3, 0, f16x3); /* { dg-error {cannot convert 'svfloat16x3_t' to 'svfloat16_t'} } */\n+  f16x3 = svset3_f16 (f16x3, 0, pg); /* { dg-error {cannot convert 'svbool_t' to 'svfloat16_t'} } */\n+  f16x3 = svset3_f16 (f16x3, x, f16); /* { dg-error \"argument 2 of 'svset3_f16' must be an integer constant expression\" } */\n+  f16x3 = svset3_f16 (f16x3, 0, f16);\n+  u16x3 = svset3_f16 (f16x3, 0, f16); /* { dg-error {cannot convert 'svfloat16x3_t' to 'svuint16x3_t' in assignment} } */\n+  f16x3 = svset3_f16 (f16x3, 1, f16);\n+  f16x3 = svset3_f16 (f16x3, 2, f16);\n+  f16x3 = svset3_f16 (f16x3, 3, f16); /* { dg-error {passing 3 to argument 2 of 'svset3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3_f16 (f16x3, 4, f16); /* { dg-error {passing 4 to argument 2 of 'svset3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3_f16 (f16x3, 5, f16); /* { dg-error {passing 5 to argument 2 of 'svset3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3_f16 (f16x3, ~0U, f16); /* { dg-error {passing [^ ]* to argument 2 of 'svset3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3_f16 (f16x3, one, f16);\n+  f16x3 = svset3_f16 (f16x3, 3 - 2, f16);\n+  f16x3 = svset3_f16 (f16x3, 1.0, f16);\n+  f16x3 = svset3_f16 (f16x3, const_sub (5, 4), f16);\n+  f16x3 = svset3_f16 (f16x3, const_sub (6, 4), f16);\n+  f16x3 = svset3_f16 (f16x3, const_sub (7, 4), f16); /* { dg-error {passing 3 to argument 2 of 'svset3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3_f16 (f16x3, const_sub (8, 4), f16); /* { dg-error {passing 4 to argument 2 of 'svset3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3_f16 (f16x3, add (0, 0), f16); /* { dg-error \"argument 2 of 'svset3_f16' must be an integer constant expression\" } */\n+\n+  return f64;\n+}"}, {"sha": "dc5dae872f48bb6e14d8d636caabc8229808aa74", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/set4_1.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fset4_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fset4_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fset4_1.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c++11 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+constexpr uint64_t const_sub (uint64_t a, uint64_t b) { return a - b; }\n+uint64_t add (uint64_t a, uint64_t b) { return a + b; }\n+\n+svfloat64_t\n+f1 (svbool_t pg, svint32_t s32, svint32x4_t s32x4, svfloat32x4_t f32x4,\n+    svint32x2_t s32x2, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  s32x4 = svset4 (s32x4); /* { dg-error {no matching function for call to 'svset4\\(svint32x4_t\\&\\)'} } */\n+  s32x4 = svset4 (s32x4, 1); /* { dg-error {no matching function for call to 'svset4\\(svint32x4_t\\&, int\\)'} } */\n+  s32x4 = svset4 (s32x4, 1, s32, 2); /* { dg-error {no matching function for call to 'svset4\\(svint32x4_t\\&, int, svint32_t\\&, int\\)'} } */\n+  s32x4 = svset4 (s32, 0, s32); /* { dg-error {no matching function for call to 'svset4\\(svint32_t\\&, int, svint32_t\\&\\)'} } */\n+  s32x4 = svset4 (f32x4, 0, s32); /* { dg-error {no matching function for call to 'svset4\\(svfloat32x4_t\\&, int, svint32_t\\&\\)'} } */\n+  s32x4 = svset4 (s32x2, 0, s32); /* { dg-error {no matching function for call to 'svset4\\(svint32x2_t\\&, int, svint32_t\\&\\)'} } */\n+  s32x4 = svset4 (pg, 0, s32); /* { dg-error {no matching function for call to 'svset4\\(svbool_t\\&, int, svint32_t\\&\\)'} } */\n+  s32x4 = svset4 (s32x4, 0, f64); /* { dg-error {no matching function for call to 'svset4\\(svint32x4_t\\&, int, svfloat64_t\\&\\)'} } */\n+  s32x4 = svset4 (s32x4, 0, s32x4); /* { dg-error {no matching function for call to 'svset4\\(svint32x4_t\\&, int, svint32x4_t\\&\\)'} } */\n+  s32x4 = svset4 (s32x4, 0, pg); /* { dg-error {no matching function for call to 'svset4\\(svint32x4_t\\&, int, svbool_t\\&\\)'} } */\n+  s32x4 = svset4 (s32x4, x, s32); /* { dg-error \"argument 2 of 'svset4' must be an integer constant expression\" } */\n+  s32x4 = svset4 (s32x4, 0, s32);\n+  f32x4 = svset4 (s32x4, 0, s32); /* { dg-error {cannot convert 'svint32x4_t' to 'svfloat32x4_t' in assignment} } */\n+  s32x4 = svset4 (s32x4, 1, s32);\n+  s32x4 = svset4 (s32x4, 2, s32);\n+  s32x4 = svset4 (s32x4, 3, s32);\n+  s32x4 = svset4 (s32x4, 4, s32); /* { dg-error {passing 4 to argument 2 of 'svset4', which expects a value in the range \\[0, 3\\]} } */\n+  s32x4 = svset4 (s32x4, 5, s32); /* { dg-error {passing 5 to argument 2 of 'svset4', which expects a value in the range \\[0, 3\\]} } */\n+  s32x4 = svset4 (s32x4, ~0U, s32); /* { dg-error {passing [^ ]* to argument 2 of 'svset4', which expects a value in the range \\[0, 3\\]} } */\n+  s32x4 = svset4 (s32x4, one, s32);\n+  s32x4 = svset4 (s32x4, 3 - 2, s32);\n+  s32x4 = svset4 (s32x4, 1.0, s32);\n+  s32x4 = svset4 (s32x4, const_sub (5, 4), s32);\n+  s32x4 = svset4 (s32x4, const_sub (6, 4), s32);\n+  s32x4 = svset4 (s32x4, const_sub (7, 4), s32);\n+  s32x4 = svset4 (s32x4, const_sub (8, 4), s32); /* { dg-error {passing 4 to argument 2 of 'svset4', which expects a value in the range \\[0, 3\\]} } */\n+  s32x4 = svset4 (s32x4, add (0, 0), s32); /* { dg-error \"argument 2 of 'svset4' must be an integer constant expression\" } */\n+\n+  return f64;\n+}"}, {"sha": "762a6db742702fabe7af1df05cfba56658af7b48", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/set4_2.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fset4_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fset4_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fset4_2.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c++11 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+constexpr uint64_t const_sub (uint64_t a, uint64_t b) { return a - b; }\n+uint64_t add (uint64_t a, uint64_t b) { return a + b; }\n+\n+svfloat64_t\n+f1 (svbool_t pg, svint32_t s32, svint32x4_t s32x4, svfloat32x4_t f32x4,\n+    svint32x2_t s32x2, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  s32x4 = svset4_s32 (s32x4); /* { dg-error {too few arguments to function '[^']*'} } */\n+  s32x4 = svset4_s32 (s32x4, 1); /* { dg-error {too few arguments to function '[^']*'} } */\n+  s32x4 = svset4_s32 (s32x4, 1, s32, 2); /* { dg-error {too many arguments to function '[^']*'} } */\n+  s32x4 = svset4_s32 (s32, 0, s32); /* { dg-error {cannot convert 'svint32_t' to 'svint32x4_t'} } */\n+  s32x4 = svset4_s32 (f32x4, 0, s32); /* { dg-error {cannot convert 'svfloat32x4_t' to 'svint32x4_t'} } */\n+  s32x4 = svset4_s32 (s32x2, 0, s32); /* { dg-error {cannot convert 'svint32x2_t' to 'svint32x4_t'} } */\n+  s32x4 = svset4_s32 (pg, 0, s32); /* { dg-error {cannot convert 'svbool_t' to 'svint32x4_t'} } */\n+  s32x4 = svset4_s32 (s32x4, 0, f64); /* { dg-error {cannot convert 'svfloat64_t' to 'svint32_t'} } */\n+  s32x4 = svset4_s32 (s32x4, 0, s32x4); /* { dg-error {cannot convert 'svint32x4_t' to 'svint32_t'} } */\n+  s32x4 = svset4_s32 (s32x4, 0, pg); /* { dg-error {cannot convert 'svbool_t' to 'svint32_t'} } */\n+  s32x4 = svset4_s32 (s32x4, x, s32); /* { dg-error \"argument 2 of 'svset4_s32' must be an integer constant expression\" } */\n+  s32x4 = svset4_s32 (s32x4, 0, s32);\n+  f32x4 = svset4_s32 (s32x4, 0, s32); /* { dg-error {cannot convert 'svint32x4_t' to 'svfloat32x4_t' in assignment} } */\n+  s32x4 = svset4_s32 (s32x4, 1, s32);\n+  s32x4 = svset4_s32 (s32x4, 2, s32);\n+  s32x4 = svset4_s32 (s32x4, 3, s32);\n+  s32x4 = svset4_s32 (s32x4, 4, s32); /* { dg-error {passing 4 to argument 2 of 'svset4_s32', which expects a value in the range \\[0, 3\\]} } */\n+  s32x4 = svset4_s32 (s32x4, 5, s32); /* { dg-error {passing 5 to argument 2 of 'svset4_s32', which expects a value in the range \\[0, 3\\]} } */\n+  s32x4 = svset4_s32 (s32x4, ~0U, s32); /* { dg-error {passing [^ ]* to argument 2 of 'svset4_s32', which expects a value in the range \\[0, 3\\]} } */\n+  s32x4 = svset4_s32 (s32x4, one, s32);\n+  s32x4 = svset4_s32 (s32x4, 3 - 2, s32);\n+  s32x4 = svset4_s32 (s32x4, 1.0, s32);\n+  s32x4 = svset4_s32 (s32x4, const_sub (5, 4), s32);\n+  s32x4 = svset4_s32 (s32x4, const_sub (6, 4), s32);\n+  s32x4 = svset4_s32 (s32x4, const_sub (7, 4), s32);\n+  s32x4 = svset4_s32 (s32x4, const_sub (8, 4), s32); /* { dg-error {passing 4 to argument 2 of 'svset4_s32', which expects a value in the range \\[0, 3\\]} } */\n+  s32x4 = svset4_s32 (s32x4, add (0, 0), s32); /* { dg-error \"argument 2 of 'svset4_s32' must be an integer constant expression\" } */\n+\n+  return f64;\n+}"}, {"sha": "ff25900321ab81fe5abd0706e15a8fd867cfaf7f", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_1.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+int svbool_t; /* { dg-message \"note: previous declaration 'int svbool_t'\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"  /* { dg-error {'typedef [^'\\n]* svbool_t' redeclared as different kind of entity} } */"}, {"sha": "86d87fa3773088fd445ff9fb13bf5f8242dcdd87", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_10.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_10.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+typedef int svint8x2_t;\n+\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-error {conflicting declaration 'typedef struct svint8x2_t svint8x2_t'} } */"}, {"sha": "741d10eaf67dda4833c54de0afcf13035ab758fe", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_11.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_11.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+\n+struct svint8x2_t;\n+\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-error {conflicting declaration 'typedef struct svint8x2_t svint8x2_t'} } */\n+\n+svint8_t f (svint8x2_t x) { return x.__val[0]; } /* { dg-error {'x' has incomplete type} } */"}, {"sha": "fc6a07ac6a74d5adea8e0dac972cc2f702541dae", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_12.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_12.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+\n+typedef struct svint8x2_t svint8x2_t;\n+\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-error {conflicting declaration 'typedef struct svint8x2_t svint8x2_t'} } */\n+\n+svint8_t f (svint8x2_t x) { return x.__val[0]; } /* { dg-error {'x' has incomplete type} } */"}, {"sha": "161aacb7bd013d8e3c094540b8f1cb4a5d13942d", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_13.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_13.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+struct svint8x2_t {};\n+\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-error {conflicting declaration 'typedef struct svint8x2_t svint8x2_t'} } */"}, {"sha": "83191118f6c3bb4761297b38c759f48e1ee3f376", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_14.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_14.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+enum svpattern { FOO }; /* { dg-message \"note: previous definition here\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-error \"multiple definition of 'enum svpattern'\" } */"}, {"sha": "71e35a4eb0d33bca66012ee10f0e6c37a5287ca3", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_15.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_15.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+enum svpattern { FOO }; /* { dg-error \"multiple definition of 'enum svpattern'\" } */\n+enum foo { SV_ALL }; /* { dg-error \"'SV_ALL' conflicts with a previous declaration\" } */\n+typedef int SV_POW2; /* { dg-error \"'typedef int SV_POW2' redeclared as different kind of entity\" } */\n+int SV_VL3; /* { dg-error \"'int SV_VL3' redeclared as different kind of entity\" } */"}, {"sha": "277064d314c559bfc3c5bac398b548193242d28b", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_16.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_16.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+struct svpattern { int x; };\n+\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-error \"'svpattern' referred to as enum\" } */"}, {"sha": "e4bcda6fbaae81e2a3811796041f26a0d4b731ec", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_17.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_17.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+struct svpattern { int x; }; /* { dg-error \"'svpattern' referred to as 'struct'\" } */"}, {"sha": "b6706150be1871d2dc8be8efe03ac2bdc988c9da", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_18.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_18.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+int svpattern; /* OK in C.  */\n+\n+#pragma GCC aarch64 \"arm_sve.h\""}, {"sha": "c6379f76260080c1ccd34935594d4db16ce21f50", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_19.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_19.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+int svpattern; /* OK in C.  */"}, {"sha": "5baf599321c232c3f5bd1b84605051fcee7f072c", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_2.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+int svint8_t; /* { dg-message \"note: previous declaration 'int svint8_t\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"  /* { dg-error {'typedef [^'\\n]* svint8_t' redeclared as different kind of entity} } */"}, {"sha": "3ba19f596a62ea6580ae6643c90e332b10f21552", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_20.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_20.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+\n+enum foo { SV_VL4 };\n+typedef int SV_POW2;\n+int SV_ALL;\n+\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-error \"'SV_VL4' conflicts with a previous declaration\" } */\n+/* { dg-error \"'SV_POW2' redeclared as different kind of entity\" \"\" { target *-*-* } .-1 } */\n+/* { dg-error \"'SV_ALL' redeclared as different kind of entity\" \"\" { target *-*-* } .-2 } */"}, {"sha": "a8d7bdcc7bdbe50512ffd9c4c37405c7ef6e5c11", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_3.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+int svuint16_t; /* { dg-message \"note: previous declaration 'int svuint16_t'\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-error {'typedef [^'\\n]* svuint16_t' redeclared as different kind of entity} } */"}, {"sha": "c0563d0ee01a26f2ca2b4d60162d0c7f4fd420e8", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_4.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_4.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+int svfloat32_t; /* { dg-message \"note: previous declaration 'int svfloat32_t'\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"  /* { dg-error {'typedef [^'\\n]* svfloat32_t' redeclared as different kind of entity} } */"}, {"sha": "ee28e952760809d9012de2ae813d3de393c3f541", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_5.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_5.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+typedef int svbool_t; /* { dg-message \"note: previous declaration as 'typedef int svbool_t'\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"  /* { dg-error {conflicting declaration '[^'\\n]* svbool_t'} } */"}, {"sha": "85c17eab6505dadf93c3e32b610c0989d52dddf8", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_6.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_6.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+\n+typedef __SVBool_t svbool_t;\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+"}, {"sha": "3a0dfb1c034aa9c080df86c0a971a52a19feaad9", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_7.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_7.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+\n+int svint8x2_t;\n+\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-error {'typedef struct svint8x2_t svint8x2_t' redeclared as different kind of entity} } */\n+\n+void f (struct svint8x2_t) {} /* { dg-error {incomplete type} } */\n+void g () { int &x = svint8x2_t; }"}, {"sha": "9b0df9137a955f1c51d807856d28d6b0265fd2cf", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_8.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_8.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+\n+struct svint8x2_t;\n+\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-error {conflicting declaration 'typedef struct svint8x2_t svint8x2_t'} } */\n+\n+void f (svint8x2_t) {} /* { dg-error {incomplete type} } */"}, {"sha": "43068da78f85985f80536bbff89b6a9d6ce6937c", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/type_redef_9.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Ftype_redef_9.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+int svint8x2_t; /* { dg-error {'int svint8x2_t' redeclared as different kind of entity} } */\n+\n+void f (struct svint8x2_t) {} /* { dg-error {using typedef-name 'svint8x2_t' after 'struct'} } */\n+void g () { int &x = svint8x2_t; } /* { dg-error {expected primary-expression before ';' token} } */"}, {"sha": "9571e668b815cf3fec6c6f29651ae805316b29d6", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/whilele_1.C", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fwhilele_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fwhilele_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fwhilele_1.C?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,81 @@\n+// { dg-do compile }\n+\n+#include <arm_sve.h>\n+\n+enum foo { A, B };\n+\n+void\n+test (int8_t s8, int16_t s16, int32_t s32, int64_t s64,\n+      uint8_t u8, uint16_t u16, uint32_t u32, uint64_t u64,\n+      bool b, foo e, int *ptr, float f32, svbool_t pg,\n+      svint32_t vec)\n+{\n+  svwhilele_b8 (s32); // { dg-error {no matching function for call to 'svwhilele_b8\\(int32_t&\\)'} }\n+  svwhilele_b8 (s32, s32, s32); // { dg-error {no matching function for call to 'svwhilele_b8\\(int32_t&, int32_t&, int32_t&\\)'} }\n+\n+  svwhilele_b8 (b, b);\n+  svwhilele_b8 (e, e);\n+  svwhilele_b8 (s8, s8);\n+  svwhilele_b8 (u8, u8);\n+  svwhilele_b8 (s16, s16);\n+  svwhilele_b8 (u16, u16);\n+  svwhilele_b8 (ptr, ptr); // { dg-error {no matching function for call to 'svwhilele_b8\\(int\\*&, int\\*&\\)'} }\n+  // { dg-error {invalid conversion from 'int\\*' to '[^']*'} \"\" { target *-*-* } .-1 }\n+  svwhilele_b8 (f32, f32); // { dg-error {call of overloaded 'svwhilele_b8\\(float&, float&\\)' is ambiguous} }\n+  svwhilele_b8 (pg, pg); // { dg-error {no matching function for call to 'svwhilele_b8\\(svbool_t&, svbool_t&\\)'} }\n+  svwhilele_b8 (vec, vec); // { dg-error {no matching function for call to 'svwhilele_b8\\(svint32_t&, svint32_t&\\)'} }\n+\n+  svwhilele_b8 (s32, b);\n+  svwhilele_b8 (s32, e);\n+  svwhilele_b8 (s32, s8);\n+  svwhilele_b8 (s32, u8);\n+  svwhilele_b8 (s32, s16);\n+  svwhilele_b8 (s32, u16);\n+\n+  svwhilele_b8 (u32, b); // { dg-error {call of overloaded 'svwhilele_b8\\(uint32_t&, bool&\\)' is ambiguous} }\n+  svwhilele_b8 (u32, e); // { dg-error {call of overloaded 'svwhilele_b8\\(uint32_t&, foo&\\)' is ambiguous} }\n+  svwhilele_b8 (u32, s8); // { dg-error {call of overloaded 'svwhilele_b8\\(uint32_t&, int8_t&\\)' is ambiguous} }\n+  svwhilele_b8 (u32, u8); // { dg-error {call of overloaded 'svwhilele_b8\\(uint32_t&, uint8_t&\\)' is ambiguous} }\n+  svwhilele_b8 (u32, s16); // { dg-error {call of overloaded 'svwhilele_b8\\(uint32_t&, int16_t&\\)' is ambiguous} }\n+  svwhilele_b8 (u32, u16); // { dg-error {call of overloaded 'svwhilele_b8\\(uint32_t&, uint16_t&\\)' is ambiguous} }\n+\n+  svwhilele_b8 (s32, s32);\n+  svwhilele_b8 (s32, u32); // { dg-error {call of overloaded 'svwhilele_b8\\(int32_t&, uint32_t&\\)' is ambiguous} }\n+  svwhilele_b8 (s32, s64); // { dg-error {call of overloaded 'svwhilele_b8\\(int32_t&, int64_t&\\)' is ambiguous} }\n+  svwhilele_b8 (s32, u64); // { dg-error {call of overloaded 'svwhilele_b8\\(int32_t&, uint64_t&\\)' is ambiguous} }\n+\n+  svwhilele_b8 (u32, s32); // { dg-error {call of overloaded 'svwhilele_b8\\(uint32_t&, int32_t&\\)' is ambiguous} }\n+  svwhilele_b8 (u32, u32);\n+  svwhilele_b8 (u32, s64); // { dg-error {call of overloaded 'svwhilele_b8\\(uint32_t&, int64_t&\\)' is ambiguous} }\n+  svwhilele_b8 (u32, u64); // { dg-error {call of overloaded 'svwhilele_b8\\(uint32_t&, uint64_t&\\)' is ambiguous} }\n+\n+  svwhilele_b8 (s64, s32); // { dg-error {call of overloaded 'svwhilele_b8\\(int64_t&, int32_t&\\)' is ambiguous} }\n+  svwhilele_b8 (s64, u32); // { dg-error {call of overloaded 'svwhilele_b8\\(int64_t&, uint32_t&\\)' is ambiguous} }\n+  svwhilele_b8 (s64, s64);\n+  svwhilele_b8 (s64, u64); // { dg-error {call of overloaded 'svwhilele_b8\\(int64_t&, uint64_t&\\)' is ambiguous} }\n+\n+  svwhilele_b8 (u64, s32); // { dg-error {call of overloaded 'svwhilele_b8\\(uint64_t&, int32_t&\\)' is ambiguous} }\n+  svwhilele_b8 (u64, u32); // { dg-error {call of overloaded 'svwhilele_b8\\(uint64_t&, uint32_t&\\)' is ambiguous} }\n+  svwhilele_b8 (u64, s64); // { dg-error {call of overloaded 'svwhilele_b8\\(uint64_t&, int64_t&\\)' is ambiguous} }\n+  svwhilele_b8 (u64, u64);\n+\n+  svwhilele_b8 (0, s32);\n+  svwhilele_b8 (0, u32); // { dg-error {call of overloaded 'svwhilele_b8\\(int, uint32_t&\\)' is ambiguous} }\n+  svwhilele_b8 (0, s64); // { dg-error {call of overloaded 'svwhilele_b8\\(int, int64_t&\\)' is ambiguous} }\n+  svwhilele_b8 (0, u64); // { dg-error {call of overloaded 'svwhilele_b8\\(int, uint64_t&\\)' is ambiguous} }\n+\n+  svwhilele_b8 (s32, 0);\n+  svwhilele_b8 (u32, 0); // { dg-error {call of overloaded 'svwhilele_b8\\(uint32_t&, int\\)' is ambiguous} }\n+  svwhilele_b8 (s64, 0); // { dg-error {call of overloaded 'svwhilele_b8\\(int64_t&, int\\)' is ambiguous} }\n+  svwhilele_b8 (u64, 0); // { dg-error {call of overloaded 'svwhilele_b8\\(uint64_t&, int\\)' is ambiguous} }\n+\n+  svwhilele_b8 (0U, s32); // { dg-error {call of overloaded 'svwhilele_b8\\(unsigned int, int32_t&\\)' is ambiguous} }\n+  svwhilele_b8 (0U, u32);\n+  svwhilele_b8 (0U, s64); // { dg-error {call of overloaded 'svwhilele_b8\\(unsigned int, int64_t&\\)' is ambiguous} }\n+  svwhilele_b8 (0U, u64); // { dg-error {call of overloaded 'svwhilele_b8\\(unsigned int, uint64_t&\\)' is ambiguous} }\n+\n+  svwhilele_b8 (s32, 0U); // { dg-error {call of overloaded 'svwhilele_b8\\(int32_t&, unsigned int\\)' is ambiguous} }\n+  svwhilele_b8 (u32, 0U);\n+  svwhilele_b8 (s64, 0U); // { dg-error {call of overloaded 'svwhilele_b8\\(int64_t&, unsigned int\\)' is ambiguous} }\n+  svwhilele_b8 (u64, 0U); // { dg-error {call of overloaded 'svwhilele_b8\\(uint64_t&, unsigned int\\)' is ambiguous} }\n+}"}, {"sha": "34d9dfd430aabe7443a5e3a6cb3ce4e9fa4d2b82", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/aarch64-sve-acle.exp", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Faarch64-sve-acle.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Faarch64-sve-acle.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Faarch64-sve-acle.exp?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,54 @@\n+#  Specific regression driver for AArch64 SVE.\n+#  Copyright (C) 2009-2019 Free Software Foundation, Inc.\n+#  Contributed by ARM Ltd.\n+#\n+#  This file is part of GCC.\n+#\n+#  GCC is free software; you can redistribute it and/or modify it\n+#  under the terms of the GNU General Public License as published by\n+#  the Free Software Foundation; either version 3, or (at your option)\n+#  any later version.\n+#\n+#  GCC is distributed in the hope that it will be useful, but\n+#  WITHOUT ANY WARRANTY; without even the implied warranty of\n+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+#  General Public License for more details.\n+#\n+#  You should have received a copy of the GNU General Public License\n+#  along with GCC; see the file COPYING3.  If not see\n+#  <http://www.gnu.org/licenses/>.  */\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't an AArch64 target.\n+if {![istarget aarch64*-*-*] } {\n+    return\n+}\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Force SVE if we're not testing it already.\n+if { [check_effective_target_aarch64_sve] } {\n+    set sve_flags \"\"\n+} else {\n+    set sve_flags \"-march=armv8.2-a+sve\"\n+}\n+\n+# Main loop.\n+# FIXME: This should include general/*.c too, but leave that until the\n+# C frontend allows initialization of SVE vectors.\n+set files [glob -nocomplain $srcdir/$subdir/general-c/*.c]\n+dg-runtest [lsort $files] \"$sve_flags\" $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "714265ed1f1d3f8fdacaf52d733b10712f7d06e2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/adr_index_1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fadr_index_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fadr_index_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fadr_index_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, uint32_t *u32_ptr, svuint8_t u8, svuint16_t u16,\n+    svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64, svfloat64_t f64)\n+{\n+  svadrh_index (u32); /* { dg-error {too few arguments to function 'svadrh_index'} } */\n+  svadrh_index (u32, u32, u32); /* { dg-error {too many arguments to function 'svadrh_index'} } */\n+  svadrh_index (u32_ptr, s32); /* { dg-error {passing '[^']*\\*'[^\\n]* to argument 1 of 'svadrh_index', which expects an SVE vector type} } */\n+  svadrh_index (0, s32); /* { dg-error {passing 'int' to argument 1 of 'svadrh_index', which expects an SVE vector type} } */\n+  svadrh_index (u16, u16); /* { dg-error {passing 'svuint16_t' to argument 1 of 'svadrh_index', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svadrh_index (s32, s32); /* { dg-error {passing 'svint32_t' to argument 1 of 'svadrh_index', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svadrh_index (f32, s32); /* { dg-error {passing 'svfloat32_t' to argument 1 of 'svadrh_index', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svadrh_index (pg, s32); /* { dg-error {passing 'svbool_t' to argument 1 of 'svadrh_index', which expects 'svuint32_t' or 'svuint64_t'} } */\n+\n+  svadrh_index (u32, 0); /* { dg-error {passing 'int' to argument 2 of 'svadrh_index', which expects an SVE vector type} } */\n+  svadrh_index (u32, u8); /* { dg-error {passing 'svuint8_t' to argument 2 of 'svadrh_index', which expects a vector of 32-bit or 64-bit integers} } */\n+  svadrh_index (u32, u16); /* { dg-error {passing 'svuint16_t' to argument 2 of 'svadrh_index', which expects a vector of 32-bit or 64-bit integers} } */\n+  svadrh_index (u32, pg); /* { dg-error {passing 'svbool_t' to argument 2 of 'svadrh_index', which expects a vector of integers} } */\n+\n+  svadrh_index (u32, s32);\n+  svadrh_index (u32, u32);\n+  svadrh_index (u32, f32); /* { dg-error {passing 'svfloat32_t' to argument 2 of 'svadrh_index', which expects a vector of integers} } */\n+  svadrh_index (u32, s64); /* { dg-error {cannot combine a base of type 'svuint32_t' with an index of type 'svint64_t'} } */\n+  svadrh_index (u32, u64); /* { dg-error {cannot combine a base of type 'svuint32_t' with an index of type 'svuint64_t'} } */\n+  svadrh_index (u32, f64); /* { dg-error {passing 'svfloat64_t' to argument 2 of 'svadrh_index', which expects a vector of integers} } */\n+\n+  svadrh_index (u64, s32); /* { dg-error {cannot combine a base of type 'svuint64_t' with an index of type 'svint32_t'} } */\n+  svadrh_index (u64, u32); /* { dg-error {cannot combine a base of type 'svuint64_t' with an index of type 'svuint32_t'} } */\n+  svadrh_index (u64, f32); /* { dg-error {passing 'svfloat32_t' to argument 2 of 'svadrh_index', which expects a vector of integers} } */\n+  svadrh_index (u64, s64);\n+  svadrh_index (u64, u64);\n+  svadrh_index (u64, f64); /* { dg-error {passing 'svfloat64_t' to argument 2 of 'svadrh_index', which expects a vector of integers} } */\n+}"}, {"sha": "528d7ac51ef8b7f1f81b6548142100443e0dcd41", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/adr_offset_1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fadr_offset_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fadr_offset_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fadr_offset_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, uint32_t *u32_ptr, svuint8_t u8, svuint16_t u16,\n+    svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64, svfloat64_t f64)\n+{\n+  svadrb_offset (u32); /* { dg-error {too few arguments to function 'svadrb_offset'} } */\n+  svadrb_offset (u32, u32, u32); /* { dg-error {too many arguments to function 'svadrb_offset'} } */\n+  svadrb_offset (u32_ptr, s32); /* { dg-error {passing '[^']*\\*'[^\\n]* to argument 1 of 'svadrb_offset', which expects an SVE vector type} } */\n+  svadrb_offset (0, s32); /* { dg-error {passing 'int' to argument 1 of 'svadrb_offset', which expects an SVE vector type} } */\n+  svadrb_offset (u16, u16); /* { dg-error {passing 'svuint16_t' to argument 1 of 'svadrb_offset', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svadrb_offset (s32, s32); /* { dg-error {passing 'svint32_t' to argument 1 of 'svadrb_offset', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svadrb_offset (f32, s32); /* { dg-error {passing 'svfloat32_t' to argument 1 of 'svadrb_offset', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svadrb_offset (pg, s32); /* { dg-error {passing 'svbool_t' to argument 1 of 'svadrb_offset', which expects 'svuint32_t' or 'svuint64_t'} } */\n+\n+  svadrb_offset (u32, 0); /* { dg-error {passing 'int' to argument 2 of 'svadrb_offset', which expects an SVE vector type} } */\n+  svadrb_offset (u32, u8); /* { dg-error {passing 'svuint8_t' to argument 2 of 'svadrb_offset', which expects a vector of 32-bit or 64-bit integers} } */\n+  svadrb_offset (u32, u16); /* { dg-error {passing 'svuint16_t' to argument 2 of 'svadrb_offset', which expects a vector of 32-bit or 64-bit integers} } */\n+  svadrb_offset (u32, pg); /* { dg-error {passing 'svbool_t' to argument 2 of 'svadrb_offset', which expects a vector of integers} } */\n+\n+  svadrb_offset (u32, s32);\n+  svadrb_offset (u32, u32);\n+  svadrb_offset (u32, f32); /* { dg-error {passing 'svfloat32_t' to argument 2 of 'svadrb_offset', which expects a vector of integers} } */\n+  svadrb_offset (u32, s64); /* { dg-error {cannot combine a base of type 'svuint32_t' with an offset of type 'svint64_t'} } */\n+  svadrb_offset (u32, u64); /* { dg-error {cannot combine a base of type 'svuint32_t' with an offset of type 'svuint64_t'} } */\n+  svadrb_offset (u32, f64); /* { dg-error {passing 'svfloat64_t' to argument 2 of 'svadrb_offset', which expects a vector of integers} } */\n+\n+  svadrb_offset (u64, s32); /* { dg-error {cannot combine a base of type 'svuint64_t' with an offset of type 'svint32_t'} } */\n+  svadrb_offset (u64, u32); /* { dg-error {cannot combine a base of type 'svuint64_t' with an offset of type 'svuint32_t'} } */\n+  svadrb_offset (u64, f32); /* { dg-error {passing 'svfloat32_t' to argument 2 of 'svadrb_offset', which expects a vector of integers} } */\n+  svadrb_offset (u64, s64);\n+  svadrb_offset (u64, u64);\n+  svadrb_offset (u64, f64); /* { dg-error {passing 'svfloat64_t' to argument 2 of 'svadrb_offset', which expects a vector of integers} } */\n+}"}, {"sha": "8ce89fa10535a97f6e66d87cd30250d4016a3370", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/binary_1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+svuint8_t\n+f1 (svbool_t pg, svuint8_t u8, svint16_t s16)\n+{\n+  svzip1 (pg); /* { dg-error {too few arguments to function 'svzip1'} } */\n+  svzip1 (pg, u8, u8); /* { dg-error {too many arguments to function 'svzip1'} } */\n+  svzip1 (pg, u8); /* { dg-error {passing 'svuint8_t' to argument 2 of 'svzip1', but previous arguments had type 'svbool_t'} } */\n+  svzip1 (u8, pg); /* { dg-error {passing 'svbool_t' to argument 2 of 'svzip1', but previous arguments had type 'svuint8_t'} } */\n+  svzip1 (u8, s16); /* { dg-error {passing 'svint16_t' to argument 2 of 'svzip1', but previous arguments had type 'svuint8_t'} } */\n+  svzip1 (u8, 0); /* { dg-error {passing 'int' to argument 2 of 'svzip1', which expects an SVE vector type} } */\n+}"}, {"sha": "965e9a13cce236116c814adb633af682f0165bc3", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/binary_int_opt_n.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_int_opt_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_int_opt_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_int_opt_n.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svfloat16_t f16, svint16_t s16, svuint16_t u16,\n+    svfloat32_t f32, svint32_t s32, svuint32_t u32)\n+{\n+  svscale_x (pg, f16); /* { dg-error {too few arguments to function 'svscale_x'} } */\n+  svscale_x (pg, f16, s16, s16); /* { dg-error {too many arguments to function 'svscale_x'} } */\n+  svscale_x (s32, f16, s32); /* { dg-error {passing 'svint32_t' to argument 1 of 'svscale_x', which expects 'svbool_t'} } */\n+  svscale_x (1, f16, s32); /* { dg-error {passing 'int' to argument 1 of 'svscale_x', which expects 'svbool_t'} } */\n+  svscale_x (pg, pg, s16); /* { dg-error {'svscale_x' has no form that takes 'svbool_t' arguments} } */\n+  svscale_x (pg, 1, s16); /* { dg-error {passing 'int' to argument 2 of 'svscale_x', which expects an SVE vector type} } */\n+  svscale_x (pg, f16, s16);\n+  svscale_x (pg, f16, u16); /* { dg-error {passing 'svuint16_t' to argument 3 of 'svscale_x', which expects a vector of signed integers} } */\n+  svscale_x (pg, f16, f16); /* { dg-error {passing 'svfloat16_t' to argument 3 of 'svscale_x', which expects a vector of signed integers} } */\n+  svscale_x (pg, f16, s32); /* { dg-error {arguments 2 and 3 of 'svscale_x' must have the same element size, but the values passed here have type 'svfloat16_t' and 'svint32_t' respectively} } */\n+  svscale_x (pg, f16, u32); /* { dg-error {passing 'svuint32_t' to argument 3 of 'svscale_x', which expects a vector of signed integers} } */\n+  svscale_x (pg, f16, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svscale_x', which expects a vector of signed integers} } */\n+  svscale_x (pg, f16, pg); /* { dg-error {passing 'svbool_t' to argument 3 of 'svscale_x', which expects a vector of signed integers} } */\n+  svscale_x (pg, f16, 0);\n+  svscale_x (pg, s16, s16); /* { dg-error {'svscale_x' has no form that takes 'svint16_t' arguments} } */\n+  svscale_x (pg, s16, u16); /* { dg-error {passing 'svuint16_t' to argument 3 of 'svscale_x', which expects a vector of signed integers} } */\n+  svscale_x (pg, s16, s32); /* { dg-error {'svscale_x' has no form that takes 'svint16_t' arguments} } */\n+  svscale_x (pg, s16, u32); /* { dg-error {passing 'svuint32_t' to argument 3 of 'svscale_x', which expects a vector of signed integers} } */\n+  svscale_x (pg, u16, s16); /* { dg-error {'svscale_x' has no form that takes 'svuint16_t' arguments} } */\n+}"}, {"sha": "f1879ca6e0d87d4314dd0ae1eb601ecda4508cbb", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/binary_lane_1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_lane_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_lane_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_lane_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svfloat16_t f16, svfloat32_t f32, svfloat64_t f64,\n+    svint32_t s32, int i)\n+{\n+  svmul_lane (f32, f32); /* { dg-error {too few arguments to function 'svmul_lane'} } */\n+  svmul_lane (f32, f32, 0, 0); /* { dg-error {too many arguments to function 'svmul_lane'} } */\n+  svmul_lane (pg, pg, 0); /* { dg-error {'svmul_lane' has no form that takes 'svbool_t' arguments} } */\n+  svmul_lane (s32, s32, 0); /* { dg-error {'svmul_lane' has no form that takes 'svint32_t' arguments} } */\n+  svmul_lane (1, f32, 0); /* { dg-error {passing 'int' to argument 1 of 'svmul_lane', which expects an SVE vector type} } */\n+  svmul_lane (f32, 1, 0); /* { dg-error {passing 'int' to argument 2 of 'svmul_lane', which expects an SVE vector type} } */\n+  svmul_lane (f32, f64, 0); /* { dg-error {passing 'svfloat64_t' to argument 2 of 'svmul_lane', but previous arguments had type 'svfloat32_t'} } */\n+  svmul_lane (f32, f32, s32); /* { dg-error {argument 3 of 'svmul_lane' must be an integer constant expression} } */\n+  svmul_lane (f32, f32, i); /* { dg-error {argument 3 of 'svmul_lane' must be an integer constant expression} } */\n+\n+  svmul_lane (f16, f16, 0);\n+  svmul_lane (f16, f16, 7);\n+  svmul_lane (f16, f16, 8); /* { dg-error {passing 8 to argument 3 of 'svmul_lane', which expects a value in the range \\[0, 7\\]} } */\n+  svmul_lane (f16, f16, -1); /* { dg-error {passing -1 to argument 3 of 'svmul_lane', which expects a value in the range \\[0, 7\\]} } */\n+\n+  svmul_lane (f32, f32, 0);\n+  svmul_lane (f32, f32, 3);\n+  svmul_lane (f32, f32, 4); /* { dg-error {passing 4 to argument 3 of 'svmul_lane', which expects a value in the range \\[0, 3\\]} } */\n+  svmul_lane (f32, f32, -1); /* { dg-error {passing -1 to argument 3 of 'svmul_lane', which expects a value in the range \\[0, 3\\]} } */\n+\n+  svmul_lane (f64, f64, 0);\n+  svmul_lane (f64, f64, 1);\n+  svmul_lane (f64, f64, 2); /* { dg-error {passing 2 to argument 3 of 'svmul_lane', which expects a value in the range \\[0, 1\\]} } */\n+  svmul_lane (f64, f64, -1); /* { dg-error {passing -1 to argument 3 of 'svmul_lane', which expects a value in the range \\[0, 1\\]} } */\n+}"}, {"sha": "0c69e66a15a91b8d36ad4621b2234a4abe93755b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/binary_n_1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_n_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_n_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_n_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svuint8_t u8, svfloat16_t f16, int i, float f)\n+{\n+  svinsr (u8); /* { dg-error {too few arguments to function 'svinsr'} } */\n+  svinsr (u8, 0, 0); /* { dg-error {too many arguments to function 'svinsr'} } */\n+  svinsr (0, 0); /* { dg-error {passing 'int' to argument 1 of 'svinsr', which expects an SVE vector type} } */\n+  svinsr (u8, 0);\n+  svinsr (u8, -1);\n+  svinsr (u8, i);\n+  svinsr (u8, f);\n+  svinsr (u8, u8); /* { dg-error {passing 'svuint8_t' to argument 2 of 'svinsr', which expects a scalar element} } */\n+  svinsr (pg, 0); /* { dg-error {'svinsr' has no form that takes 'svbool_t' arguments} } */\n+  svinsr (f16, f);\n+  svinsr (f16, f16); /* { dg-error {passing 'svfloat16_t' to argument 2 of 'svinsr', which expects a scalar element} } */\n+}"}, {"sha": "29615e5bede748357e2e678a761b494d5c6dd49a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/binary_opt_n_1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_opt_n_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_opt_n_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_opt_n_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+svuint8_t\n+f1 (svbool_t pg, svuint8_t u8, svint8_t s8)\n+{\n+  svadd_u8_x (pg, u8, s8); /* { dg-error {incompatible type for argument 3 of 'svadd_u8_x'} } */\n+  svadd_u8_x (pg, u8); /* { dg-error {too few arguments to function 'svadd_u8_x'} } */\n+  svadd_u8_x (pg, u8, u8, u8); /* { dg-error {too many arguments to function 'svadd_u8_x'} } */\n+  return svadd_s8_x (pg, s8, s8); /* { dg-error {incompatible types when returning type 'svint8_t' but 'svuint8_t' was expected} } */\n+}"}, {"sha": "9fa83ca99c26e023ac6cc06a3bba641a57a077c2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/binary_opt_n_2.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_opt_n_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_opt_n_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_opt_n_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svint8_t s8, svuint8_t u8,\n+    svint16_t s16, svuint16_t u16, svfloat16_t f16)\n+{\n+  svadd_x (pg, u8); /* { dg-error {too few arguments to function 'svadd_x'} } */\n+  svadd_x (pg, u8, u8, u8); /* { dg-error {too many arguments to function 'svadd_x'} } */\n+  svadd_x (u8, u8, u8); /* { dg-error {passing 'svuint8_t' to argument 1 of 'svadd_x', which expects 'svbool_t'} } */\n+  svadd_x (pg, pg, pg); /* { dg-error {'svadd_x' has no form that takes 'svbool_t' arguments} } */\n+  svadd_x (pg, 1, u8); /* { dg-error {passing 'int' to argument 2 of 'svadd_x', which expects an SVE vector type} } */\n+  svadd_x (pg, u8, s8); /* { dg-error {passing 'svint8_t' to argument 3 of 'svadd_x', but previous arguments had type 'svuint8_t'} } */\n+  svadd_x (pg, u8, u8);\n+  svadd_x (pg, u8, s16); /* { dg-error {passing 'svint16_t' to argument 3 of 'svadd_x', but previous arguments had type 'svuint8_t'} } */\n+  svadd_x (pg, u8, u16); /* { dg-error {passing 'svuint16_t' to argument 3 of 'svadd_x', but previous arguments had type 'svuint8_t'} } */\n+  svadd_x (pg, u8, f16); /* { dg-error {passing 'svfloat16_t' to argument 3 of 'svadd_x', but previous arguments had type 'svuint8_t'} } */\n+  svadd_x (pg, u8, pg); /* { dg-error {passing 'svbool_t' to argument 3 of 'svadd_x', but previous arguments had type 'svuint8_t'} } */\n+  svadd_x (pg, u8, 0);\n+\n+  svadd_x (pg, f16, s16); /* { dg-error {passing 'svint16_t' to argument 3 of 'svadd_x', but previous arguments had type 'svfloat16_t'} } */\n+  svadd_x (pg, f16, u16); /* { dg-error {passing 'svuint16_t' to argument 3 of 'svadd_x', but previous arguments had type 'svfloat16_t'} } */\n+  svadd_x (pg, f16, f16);\n+  svadd_x (pg, f16, 1);\n+}"}, {"sha": "4d0b253e3526e4b0c2edb15b12881f28662a972c", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/binary_opt_n_3.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_opt_n_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_opt_n_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_opt_n_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svint8_t s8, svuint8_t u8,\n+    svint16_t s16, svuint16_t u16, svfloat16_t f16)\n+{\n+  svand_z (pg, u8); /* { dg-error {too few arguments to function 'svand_z'} } */\n+  svand_z (pg, u8, u8, u8); /* { dg-error {too many arguments to function 'svand_z'} } */\n+  svand_z (u8, u8, u8); /* { dg-error {passing 'svuint8_t' to argument 1 of 'svand_z', which expects 'svbool_t'} } */\n+  svand_z (pg, pg, pg);\n+  svand_z (pg, 1, u8); /* { dg-error {passing 'int' to argument 2 of 'svand_z', which expects an SVE vector type} } */\n+  svand_z (pg, u8, s8); /* { dg-error {passing 'svint8_t' to argument 3 of 'svand_z', but previous arguments had type 'svuint8_t'} } */\n+  svand_z (pg, u8, u8);\n+  svand_z (pg, u8, s16); /* { dg-error {passing 'svint16_t' to argument 3 of 'svand_z', but previous arguments had type 'svuint8_t'} } */\n+  svand_z (pg, u8, u16); /* { dg-error {passing 'svuint16_t' to argument 3 of 'svand_z', but previous arguments had type 'svuint8_t'} } */\n+  svand_z (pg, u8, f16); /* { dg-error {passing 'svfloat16_t' to argument 3 of 'svand_z', but previous arguments had type 'svuint8_t'} } */\n+  svand_z (pg, u8, pg); /* { dg-error {passing 'svbool_t' to argument 3 of 'svand_z', but previous arguments had type 'svuint8_t'} } */\n+  svand_z (pg, u8, 0);\n+\n+  svand_z (pg, pg, u8); /* { dg-error {passing 'svuint8_t' to argument 3 of 'svand_z', but previous arguments had type 'svbool_t'} } */\n+  svand_z (pg, pg, 0); /* { dg-error {passing 'int' to argument 3 of 'svand_z', but its 'svbool_t' form does not accept scalars} } */\n+\n+  svand_z (pg, f16, s16); /* { dg-error {passing 'svint16_t' to argument 3 of 'svand_z', but previous arguments had type 'svfloat16_t'} } */\n+  svand_z (pg, f16, u16); /* { dg-error {passing 'svuint16_t' to argument 3 of 'svand_z', but previous arguments had type 'svfloat16_t'} } */\n+  svand_z (pg, f16, f16); /* { dg-error {'svand_z' has no form that takes 'svfloat16_t' arguments} } */\n+  svand_z (pg, f16, 1); /* { dg-error {'svand_z' has no form that takes 'svfloat16_t' arguments} } */\n+}"}, {"sha": "8ffe91bce0de545a312c64bb1e64d4666d61b26b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/binary_rotate_1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_rotate_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_rotate_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_rotate_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svfloat32_t f32, svfloat64_t f64, svint32_t s32, int i)\n+{\n+  svcadd_x (pg, f32, f32); /* { dg-error {too few arguments to function 'svcadd_x'} } */\n+  svcadd_x (pg, f32, f32, 90, 90); /* { dg-error {too many arguments to function 'svcadd_x'} } */\n+  svcadd_x (f32, f32, f32, 90); /* { dg-error {passing 'svfloat32_t' to argument 1 of 'svcadd_x', which expects 'svbool_t'} } */\n+  svcadd_x (pg, pg, pg, 90); /* { dg-error {'svcadd_x' has no form that takes 'svbool_t' arguments} } */\n+  svcadd_x (pg, s32, s32, 90); /* { dg-error {'svcadd_x' has no form that takes 'svint32_t' arguments} } */\n+  svcadd_x (pg, 1, f32, 90); /* { dg-error {passing 'int' to argument 2 of 'svcadd_x', which expects an SVE vector type} } */\n+  svcadd_x (pg, f32, 1, 90); /* { dg-error {passing 'int' to argument 3 of 'svcadd_x', which expects an SVE vector type} } */\n+  svcadd_x (pg, f32, f64, 90); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svcadd_x', but previous arguments had type 'svfloat32_t'} } */\n+  svcadd_x (pg, f32, f32, s32); /* { dg-error {argument 4 of 'svcadd_x' must be an integer constant expression} } */\n+  svcadd_x (pg, f32, f32, i); /* { dg-error {argument 4 of 'svcadd_x' must be an integer constant expression} } */\n+  svcadd_x (pg, f32, f32, -90); /* { dg-error {passing -90 to argument 4 of 'svcadd_x', which expects either 90 or 270} } */\n+  svcadd_x (pg, f32, f32, 0); /* { dg-error {passing 0 to argument 4 of 'svcadd_x', which expects either 90 or 270} } */\n+  svcadd_x (pg, f32, f32, 1); /* { dg-error {passing 1 to argument 4 of 'svcadd_x', which expects either 90 or 270} } */\n+  svcadd_x (pg, f32, f32, 90);\n+  svcadd_x (pg, f32, f32, 180); /* { dg-error {passing 180 to argument 4 of 'svcadd_x', which expects either 90 or 270} } */\n+  svcadd_x (pg, f32, f32, 270);\n+}"}, {"sha": "c8ca5f7464b54f9fb309062674f74c9035cae422", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/binary_uint64_n_1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_uint64_n_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_uint64_n_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_uint64_n_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svuint8_t u8, int i, float f)\n+{\n+  svdupq_lane (u8); /* { dg-error {too few arguments to function 'svdupq_lane'} } */\n+  svdupq_lane (u8, 0, 0); /* { dg-error {too many arguments to function 'svdupq_lane'} } */\n+  svdupq_lane (0, 0); /* { dg-error {passing 'int' to argument 1 of 'svdupq_lane', which expects an SVE vector type} } */\n+  svdupq_lane (u8, 0);\n+  svdupq_lane (u8, -1);\n+  svdupq_lane (u8, i);\n+  svdupq_lane (u8, f);\n+  svdupq_lane (u8, u8); /* { dg-error {passing 'svuint8_t' to argument 2 of 'svdupq_lane', which expects 'uint64_t'} } */\n+  svdupq_lane (pg, 0); /* { dg-error {'svdupq_lane' has no form that takes 'svbool_t' arguments} } */\n+}"}, {"sha": "27726a80fb49fe21a1d1fa17d2ef7f6956cbeaaa", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/binary_uint64_opt_n_1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_uint64_opt_n_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_uint64_opt_n_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_uint64_opt_n_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+svuint8_t\n+f1 (svbool_t pg, svuint8_t u8, svint8_t s8, svuint64_t u64)\n+{\n+  svlsl_wide_u8_x (pg, u8, u8); /* { dg-error {incompatible type for argument 3 of 'svlsl_wide_u8_x'} } */\n+  svlsl_wide_u8_x (pg, u8); /* { dg-error {too few arguments to function 'svlsl_wide_u8_x'} } */\n+  svlsl_wide_u8_x (pg, u8, u64, u8); /* { dg-error {too many arguments to function 'svlsl_wide_u8_x'} } */\n+  return svlsl_wide_s8_x (pg, s8, u64); /* { dg-error {incompatible types when returning type 'svint8_t' but 'svuint8_t' was expected} } */\n+}"}, {"sha": "be217394f9f676f02d75fdc9bbda304687c6ccfa", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/binary_uint64_opt_n_2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_uint64_opt_n_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_uint64_opt_n_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_uint64_opt_n_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svuint8_t u8, svuint64_t u64)\n+{\n+  svlsl_wide_x (pg, u8); /* { dg-error {too few arguments to function 'svlsl_wide_x'} } */\n+  svlsl_wide_x (pg, u8, u8, u8); /* { dg-error {too many arguments to function 'svlsl_wide_x'} } */\n+  svlsl_wide_x (u8, u8, u64); /* { dg-error {passing 'svuint8_t' to argument 1 of 'svlsl_wide_x', which expects 'svbool_t'} } */\n+  svlsl_wide_x (pg, 1, u64); /* { dg-error {passing 'int' to argument 2 of 'svlsl_wide_x', which expects an SVE vector type} } */\n+  svlsl_wide_x (pg, u8, u8); /* { dg-error {passing 'svuint8_t' to argument 3 of 'svlsl_wide_x', which expects 'svuint64_t'} } */\n+  svlsl_wide_x (pg, u64, u64); /* { dg-error {'svlsl_wide_x' has no form that takes 'svuint64_t' arguments} } */\n+}"}, {"sha": "8f86c50b681d43f415f3d9224abff5e60a5d597d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/binary_uint_1.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_uint_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_uint_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_uint_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svuint8_t u8, svint8_t s8, svuint16_t u16, svint16_t s16,\n+    svfloat16_t f16)\n+{\n+  svtbl (u8); /* { dg-error {too few arguments to function 'svtbl'} } */\n+  svtbl (u8, u8, u8); /* { dg-error {too many arguments to function 'svtbl'} } */\n+  svtbl (pg, pg); /* { dg-error {passing 'svbool_t' to argument 2 of 'svtbl', which expects a vector of unsigned integers} } */\n+  svtbl (pg, u8); /* { dg-error {'svtbl' has no form that takes 'svbool_t' arguments} } */\n+\n+  svtbl (u8, 0); /* { dg-error {passing 'int' to argument 2 of 'svtbl', which expects an SVE vector type} } */\n+  svtbl (u8, u8);\n+  svtbl (u8, s8); /* { dg-error {passing 'svint8_t' to argument 2 of 'svtbl', which expects a vector of unsigned integers} } */\n+  svtbl (u8, u16); /* { dg-error {arguments 1 and 2 of 'svtbl' must have the same element size, but the values passed here have type 'svuint8_t' and 'svuint16_t' respectively} } */\n+  svtbl (u8, s16); /* { dg-error {passing 'svint16_t' to argument 2 of 'svtbl', which expects a vector of unsigned integers} } */\n+  svtbl (u8, pg); /* { dg-error {passing 'svbool_t' to argument 2 of 'svtbl', which expects a vector of unsigned integers} } */\n+\n+  svtbl (s8, u8);\n+  svtbl (s8, s8); /* { dg-error {passing 'svint8_t' to argument 2 of 'svtbl', which expects a vector of unsigned integers} } */\n+  svtbl (s8, u16); /* { dg-error {arguments 1 and 2 of 'svtbl' must have the same element size, but the values passed here have type 'svint8_t' and 'svuint16_t' respectively} } */\n+  svtbl (s8, s16); /* { dg-error {passing 'svint16_t' to argument 2 of 'svtbl', which expects a vector of unsigned integers} } */\n+  svtbl (s8, pg); /* { dg-error {passing 'svbool_t' to argument 2 of 'svtbl', which expects a vector of unsigned integers} } */\n+\n+  svtbl (u16, u8); /* { dg-error {arguments 1 and 2 of 'svtbl' must have the same element size, but the values passed here have type 'svuint16_t' and 'svuint8_t' respectively} } */\n+  svtbl (u16, s8); /* { dg-error {passing 'svint8_t' to argument 2 of 'svtbl', which expects a vector of unsigned integers} } */\n+  svtbl (u16, u16);\n+  svtbl (u16, s16); /* { dg-error {passing 'svint16_t' to argument 2 of 'svtbl', which expects a vector of unsigned integers} } */\n+  svtbl (u16, f16); /* { dg-error {passing 'svfloat16_t' to argument 2 of 'svtbl', which expects a vector of unsigned integers} } */\n+\n+  svtbl (s16, u8); /* { dg-error {arguments 1 and 2 of 'svtbl' must have the same element size, but the values passed here have type 'svint16_t' and 'svuint8_t' respectively} } */\n+  svtbl (s16, s8); /* { dg-error {passing 'svint8_t' to argument 2 of 'svtbl', which expects a vector of unsigned integers} } */\n+  svtbl (s16, u16);\n+  svtbl (s16, s16); /* { dg-error {passing 'svint16_t' to argument 2 of 'svtbl', which expects a vector of unsigned integers} } */\n+  svtbl (s16, f16); /* { dg-error {passing 'svfloat16_t' to argument 2 of 'svtbl', which expects a vector of unsigned integers} } */\n+\n+  svtbl (f16, u8); /* { dg-error {arguments 1 and 2 of 'svtbl' must have the same element size, but the values passed here have type 'svfloat16_t' and 'svuint8_t' respectively} } */\n+  svtbl (f16, s8); /* { dg-error {passing 'svint8_t' to argument 2 of 'svtbl', which expects a vector of unsigned integers} } */\n+  svtbl (f16, u16);\n+  svtbl (f16, s16); /* { dg-error {passing 'svint16_t' to argument 2 of 'svtbl', which expects a vector of unsigned integers} } */\n+  svtbl (f16, f16); /* { dg-error {passing 'svfloat16_t' to argument 2 of 'svtbl', which expects a vector of unsigned integers} } */\n+}"}, {"sha": "36a902e69c5e9374e9e3c60a227b7e24b0b56d38", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/binary_uint_n_1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_uint_n_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_uint_n_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_uint_n_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svuint8_t u8, int i, float f)\n+{\n+  svdup_lane (u8); /* { dg-error {too few arguments to function 'svdup_lane'} } */\n+  svdup_lane (u8, 0, 0); /* { dg-error {too many arguments to function 'svdup_lane'} } */\n+  svdup_lane (0, 0); /* { dg-error {passing 'int' to argument 1 of 'svdup_lane', which expects an SVE vector type} } */\n+  svdup_lane (u8, 0);\n+  svdup_lane (u8, -1);\n+  svdup_lane (u8, i);\n+  svdup_lane (u8, f);\n+  svdup_lane (u8, u8); /* { dg-error {passing 'svuint8_t' to argument 2 of 'svdup_lane', which expects a scalar integer} } */\n+  svdup_lane (pg, 0); /* { dg-error {'svdup_lane' has no form that takes 'svbool_t' arguments} } */\n+}"}, {"sha": "b162ab4050ef266bf4a15227b399355567633835", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/binary_uint_opt_n_1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_uint_opt_n_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_uint_opt_n_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fbinary_uint_opt_n_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svfloat16_t f16, svint16_t s16, svuint16_t u16,\n+    svfloat32_t f32, svint32_t s32, svuint32_t u32)\n+{\n+  svlsl_x (pg, s16); /* { dg-error {too few arguments to function 'svlsl_x'} } */\n+  svlsl_x (pg, s16, u16, u16); /* { dg-error {too many arguments to function 'svlsl_x'} } */\n+  svlsl_x (s32, s32, u32); /* { dg-error {passing 'svint32_t' to argument 1 of 'svlsl_x', which expects 'svbool_t'} } */\n+  svlsl_x (1, s32, u32); /* { dg-error {passing 'int' to argument 1 of 'svlsl_x', which expects 'svbool_t'} } */\n+  svlsl_x (pg, pg, u16); /* { dg-error {'svlsl_x' has no form that takes 'svbool_t' arguments} } */\n+  svlsl_x (pg, 1, s16); /* { dg-error {passing 'int' to argument 2 of 'svlsl_x', which expects an SVE vector type} } */\n+  svlsl_x (pg, s16, s16); /* { dg-error {passing 'svint16_t' to argument 3 of 'svlsl_x', which expects a vector of unsigned integers} } */\n+  svlsl_x (pg, s16, u16);\n+  svlsl_x (pg, s16, f16); /* { dg-error {passing 'svfloat16_t' to argument 3 of 'svlsl_x', which expects a vector of unsigned integers} } */\n+  svlsl_x (pg, s16, s32); /* { dg-error {passing 'svint32_t' to argument 3 of 'svlsl_x', which expects a vector of unsigned integers} } */\n+  svlsl_x (pg, s16, u32); /* { dg-error {arguments 2 and 3 of 'svlsl_x' must have the same element size, but the values passed here have type 'svint16_t' and 'svuint32_t' respectively} } */\n+  svlsl_x (pg, s16, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svlsl_x', which expects a vector of unsigned integers} } */\n+  svlsl_x (pg, s16, pg); /* { dg-error {passing 'svbool_t' to argument 3 of 'svlsl_x', which expects a vector of unsigned integers} } */\n+  svlsl_x (pg, s16, 0);\n+  svlsl_x (pg, f16, s16); /* { dg-error {passing 'svint16_t' to argument 3 of 'svlsl_x', which expects a vector of unsigned integers} } */\n+  svlsl_x (pg, f16, u16); /* { dg-error {'svlsl_x' has no form that takes 'svfloat16_t' arguments} } */\n+  svlsl_x (pg, f16, s32); /* { dg-error {passing 'svint32_t' to argument 3 of 'svlsl_x', which expects a vector of unsigned integers} } */\n+  svlsl_x (pg, f16, u32); /* { dg-error {'svlsl_x' has no form that takes 'svfloat16_t' arguments} } */\n+}"}, {"sha": "cb9ac946c0c6c0e23eb306b5b1cf500283f8b6da", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/clast_1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fclast_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fclast_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fclast_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,15 @@\n+#include <arm_sve.h>\n+\n+void\n+test (svbool_t pg, svint32_t s32, svint64_t s64, int i)\n+{\n+  svclasta (pg, 1); /* { dg-error {too few arguments to function 'svclasta'} } */\n+  svclasta (pg, 1, s32, 1); /* { dg-error {too many arguments to function 'svclasta'} } */\n+  svclasta (1, 1, s32); /* { dg-error {passing 'int' to argument 1 of 'svclasta', which expects 'svbool_t'} } */\n+  svclasta (pg, 1, 1); /* { dg-error {passing 'int' to argument 3 of 'svclasta', which expects an SVE vector type} } */\n+  svclasta (pg, 1, pg); /* { dg-error {'svclasta' has no form that takes 'svbool_t' arguments} } */\n+  svclasta (pg, i, s32);\n+  svclasta (pg, s32, 1); /* { dg-error {passing 'int' to argument 3 of 'svclasta', which expects an SVE vector type} } */\n+  svclasta (pg, s32, s64); /* { dg-error {passing 'svint64_t' to argument 3 of 'svclasta', but previous arguments had type 'svint32_t'} } */\n+  svclasta (pg, pg, pg); /* { dg-error {'svclasta' has no form that takes 'svbool_t' arguments} } */\n+}"}, {"sha": "71c8e86d5da3d293810c4a6ecc9ffe3636576174", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/compare_opt_n_1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcompare_opt_n_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcompare_opt_n_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcompare_opt_n_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svint8_t s8, svuint8_t u8,\n+    svint16_t s16, svuint16_t u16, svfloat16_t f16)\n+{\n+  svcmpeq (pg, u8); /* { dg-error {too few arguments to function 'svcmpeq'} } */\n+  svcmpeq (pg, u8, u8, u8); /* { dg-error {too many arguments to function 'svcmpeq'} } */\n+  svcmpeq (u8, u8, u8); /* { dg-error {passing 'svuint8_t' to argument 1 of 'svcmpeq', which expects 'svbool_t'} } */\n+  svcmpeq (pg, pg, pg); /* { dg-error {'svcmpeq' has no form that takes 'svbool_t' arguments} } */\n+  svcmpeq (pg, 1, u8); /* { dg-error {passing 'int' to argument 2 of 'svcmpeq', which expects an SVE vector type} } */\n+  svcmpeq (pg, u8, s8); /* { dg-error {passing 'svint8_t' to argument 3 of 'svcmpeq', but previous arguments had type 'svuint8_t'} } */\n+  svcmpeq (pg, u8, u8);\n+  svcmpeq (pg, u8, s16); /* { dg-error {passing 'svint16_t' to argument 3 of 'svcmpeq', but previous arguments had type 'svuint8_t'} } */\n+  svcmpeq (pg, u8, u16); /* { dg-error {passing 'svuint16_t' to argument 3 of 'svcmpeq', but previous arguments had type 'svuint8_t'} } */\n+  svcmpeq (pg, u8, f16); /* { dg-error {passing 'svfloat16_t' to argument 3 of 'svcmpeq', but previous arguments had type 'svuint8_t'} } */\n+  svcmpeq (pg, u8, pg); /* { dg-error {passing 'svbool_t' to argument 3 of 'svcmpeq', but previous arguments had type 'svuint8_t'} } */\n+  svcmpeq (pg, u8, 0);\n+\n+  svcmpeq (pg, f16, s16); /* { dg-error {passing 'svint16_t' to argument 3 of 'svcmpeq', but previous arguments had type 'svfloat16_t'} } */\n+  svcmpeq (pg, f16, u16); /* { dg-error {passing 'svuint16_t' to argument 3 of 'svcmpeq', but previous arguments had type 'svfloat16_t'} } */\n+  svcmpeq (pg, f16, f16);\n+  svcmpeq (pg, f16, 1);\n+}"}, {"sha": "d5a60f841a907f9baa456d27cb6b1d94f84a0268", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/compare_scalar_1.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcompare_scalar_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcompare_scalar_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcompare_scalar_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,85 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+#include <stdbool.h>\n+\n+enum signed_enum { SA = -1, SB };\n+enum unsigned_enum { UA, UB };\n+\n+void\n+test (int8_t s8, int16_t s16, int32_t s32, int64_t s64,\n+      uint8_t u8, uint16_t u16, uint32_t u32, uint64_t u64,\n+      bool b, enum signed_enum se, enum unsigned_enum ue,\n+      int *ptr, float f32, svbool_t pg, svint32_t vec)\n+{\n+  svwhilele_b8 (s32); /* { dg-error {too few arguments to function 'svwhilele_b8'} } */\n+  svwhilele_b8 (s32, s32, s32); /* { dg-error {too many arguments to function 'svwhilele_b8'} } */\n+\n+  svwhilele_b8 (b, b);\n+  svwhilele_b8 (se, se);\n+  svwhilele_b8 (ue, ue);\n+  svwhilele_b8 (s8, s8);\n+  svwhilele_b8 (u8, u8);\n+  svwhilele_b8 (s16, s16);\n+  svwhilele_b8 (u16, u16);\n+  svwhilele_b8 (ptr, ptr); /* { dg-error {passing 'int \\*' to argument 1 of 'svwhilele_b8', which expects a 32-bit or 64-bit integer type} } */\n+  svwhilele_b8 (f32, f32); /* { dg-error {passing 'float' to argument 1 of 'svwhilele_b8', which expects a 32-bit or 64-bit integer type} } */\n+  svwhilele_b8 (pg, pg); /* { dg-error {passing 'svbool_t' to argument 1 of 'svwhilele_b8', which expects a 32-bit or 64-bit integer type} } */\n+  svwhilele_b8 (vec, vec); /* { dg-error {passing 'svint32_t' to argument 1 of 'svwhilele_b8', which expects a 32-bit or 64-bit integer type} } */\n+\n+  svwhilele_b8 (s32, b);\n+  svwhilele_b8 (s32, se);\n+  svwhilele_b8 (s32, ue); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'int32_t' but argument 2 has type 'uint32_t'} } */\n+  svwhilele_b8 (s32, s8);\n+  svwhilele_b8 (s32, u8);\n+  svwhilele_b8 (s32, s16);\n+  svwhilele_b8 (s32, u16);\n+\n+  svwhilele_b8 (u32, b); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'uint32_t' but argument 2 has type 'int32_t'} } */\n+  svwhilele_b8 (u32, se); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'uint32_t' but argument 2 has type 'int32_t'} } */\n+  svwhilele_b8 (u32, ue);\n+  svwhilele_b8 (u32, s8); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'uint32_t' but argument 2 has type 'int32_t'} } */\n+  svwhilele_b8 (u32, u8); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'uint32_t' but argument 2 has type 'int32_t'} } */\n+  svwhilele_b8 (u32, s16); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'uint32_t' but argument 2 has type 'int32_t'} } */\n+  svwhilele_b8 (u32, u16); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'uint32_t' but argument 2 has type 'int32_t'} } */\n+\n+  svwhilele_b8 (s32, s32);\n+  svwhilele_b8 (s32, u32); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'int32_t' but argument 2 has type 'uint32_t'} } */\n+  svwhilele_b8 (s32, s64); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'int32_t' but argument 2 has type 'int64_t'} } */\n+  svwhilele_b8 (s32, u64); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'int32_t' but argument 2 has type 'uint64_t'} } */\n+\n+  svwhilele_b8 (u32, s32); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'uint32_t' but argument 2 has type 'int32_t'} } */\n+  svwhilele_b8 (u32, u32);\n+  svwhilele_b8 (u32, s64); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'uint32_t' but argument 2 has type 'int64_t'} } */\n+  svwhilele_b8 (u32, u64); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'uint32_t' but argument 2 has type 'uint64_t'} } */\n+\n+  svwhilele_b8 (s64, s32); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'int64_t' but argument 2 has type 'int32_t'} } */\n+  svwhilele_b8 (s64, u32); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'int64_t' but argument 2 has type 'uint32_t'} } */\n+  svwhilele_b8 (s64, s64);\n+  svwhilele_b8 (s64, u64); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'int64_t' but argument 2 has type 'uint64_t'} } */\n+\n+  svwhilele_b8 (u64, s32); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'uint64_t' but argument 2 has type 'int32_t'} } */\n+  svwhilele_b8 (u64, u32); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'uint64_t' but argument 2 has type 'uint32_t'} } */\n+  svwhilele_b8 (u64, s64); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'uint64_t' but argument 2 has type 'int64_t'} } */\n+  svwhilele_b8 (u64, u64);\n+\n+  svwhilele_b8 (0, s32);\n+  svwhilele_b8 (0, u32); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'int32_t' but argument 2 has type 'uint32_t'} } */\n+  svwhilele_b8 (0, s64); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'int32_t' but argument 2 has type 'int64_t'} } */\n+  svwhilele_b8 (0, u64); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'int32_t' but argument 2 has type 'uint64_t'} } */\n+\n+  svwhilele_b8 (s32, 0);\n+  svwhilele_b8 (u32, 0); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'uint32_t' but argument 2 has type 'int32_t'} } */\n+  svwhilele_b8 (s64, 0); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'int64_t' but argument 2 has type 'int32_t'} } */\n+  svwhilele_b8 (u64, 0); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'uint64_t' but argument 2 has type 'int32_t'} } */\n+\n+  svwhilele_b8 (0U, s32); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'uint32_t' but argument 2 has type 'int32_t'} } */\n+  svwhilele_b8 (0U, u32);\n+  svwhilele_b8 (0U, s64); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'uint32_t' but argument 2 has type 'int64_t'} } */\n+  svwhilele_b8 (0U, u64); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'uint32_t' but argument 2 has type 'uint64_t'} } */\n+\n+  svwhilele_b8 (s32, 0U); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'int32_t' but argument 2 has type 'uint32_t'} } */\n+  svwhilele_b8 (u32, 0U);\n+  svwhilele_b8 (s64, 0U); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'int64_t' but argument 2 has type 'uint32_t'} } */\n+  svwhilele_b8 (u64, 0U); /* { dg-error {call to 'svwhilele_b8' is ambiguous; argument 1 has type 'uint64_t' but argument 2 has type 'uint32_t'} } */\n+}"}, {"sha": "fc5e45663619dff4946b00bc298ffb50fcc9253d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/compare_wide_opt_n_1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcompare_wide_opt_n_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcompare_wide_opt_n_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcompare_wide_opt_n_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+svuint8_t\n+f1 (svbool_t pg, svuint8_t u8, svint8_t s8, svint64_t s64, svuint64_t u64,\n+    svfloat32_t f32, svfloat64_t f64, unsigned int x)\n+{\n+  svcmpeq_wide (pg, s8); /* { dg-error {too few arguments to function 'svcmpeq_wide'} } */\n+  svcmpeq_wide (pg, s8, s64, s8); /* { dg-error {too many arguments to function 'svcmpeq_wide'} } */\n+  svcmpeq_wide (s8, s8, s64); /* { dg-error {passing 'svint8_t' to argument 1 of 'svcmpeq_wide', which expects 'svbool_t'} } */\n+  svcmpeq_wide (pg, 0, s64); /* { dg-error {passing 'int' to argument 2 of 'svcmpeq_wide', which expects an SVE vector type} } */\n+  svcmpeq_wide (pg, s8, 0);\n+  svcmpeq_wide (pg, s8, x);\n+  svcmpeq_wide (pg, s8, s8); /* { dg-error {passing 'svint8_t' to argument 3 of 'svcmpeq_wide', which expects a vector of 64-bit elements} } */\n+  svcmpeq_wide (pg, s8, u8); /* { dg-error {passing 'svuint8_t' to argument 3 of 'svcmpeq_wide', which expects a vector of 64-bit elements} } */\n+  svcmpeq_wide (pg, s8, s64);\n+  svcmpeq_wide (pg, s8, u64); /* { dg-error {arguments 2 and 3 of 'svcmpeq_wide' must have the same signedness, but the values passed here have type 'svint8_t' and 'svuint64_t' respectively} } */\n+  svcmpeq_wide (pg, u8, s8); /* { dg-error {passing 'svint8_t' to argument 3 of 'svcmpeq_wide', which expects a vector of 64-bit elements} } */\n+  svcmpeq_wide (pg, u8, u64); /* { dg-error {'svcmpeq_wide' has no form that takes 'svuint8_t' arguments} } */\n+  svcmpeq_wide (pg, s64, s64); /* { dg-error {'svcmpeq_wide' has no form that takes 'svint64_t' arguments} } */\n+  svcmpeq_wide (pg, f32, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svcmpeq_wide', which expects a vector of 64-bit elements} } */\n+  svcmpeq_wide (pg, f32, f64); /* { dg-error {'svcmpeq_wide' has no form that takes 'svfloat32_t' arguments} } */\n+  svcmpeq_wide (pg, f64, f64); /* { dg-error {'svcmpeq_wide' has no form that takes 'svfloat64_t' arguments} } */\n+  svcmpeq_wide (pg, pg, pg); /* { dg-error {passing 'svbool_t' to argument 3 of 'svcmpeq_wide', which expects a vector of 64-bit elements} } */\n+}"}, {"sha": "8dd76a553567380f519426ac028c84e92f2b8008", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/count_pat_1.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcount_pat_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcount_pat_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcount_pat_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,42 @@\n+#include <arm_sve.h>\n+\n+void\n+test (enum svpattern pat, int i)\n+{\n+  svcntb_pat (pat); /* { dg-error {argument 1 of 'svcntb_pat' must be an integer constant expression} } */\n+  svcntb_pat (i); /* { dg-error {argument 1 of 'svcntb_pat' must be an integer constant expression} } */\n+  svcntb_pat ((enum svpattern) -1); /* { dg-error {passing 4294967295 to argument 1 of 'svcntb_pat', which expects a valid 'enum svpattern' value} } */\n+  svcntb_pat ((enum svpattern) 0);\n+  svcntb_pat ((enum svpattern) 1);\n+  svcntb_pat ((enum svpattern) 2);\n+  svcntb_pat ((enum svpattern) 3);\n+  svcntb_pat ((enum svpattern) 4);\n+  svcntb_pat ((enum svpattern) 5);\n+  svcntb_pat ((enum svpattern) 6);\n+  svcntb_pat ((enum svpattern) 7);\n+  svcntb_pat ((enum svpattern) 8);\n+  svcntb_pat ((enum svpattern) 9);\n+  svcntb_pat ((enum svpattern) 10);\n+  svcntb_pat ((enum svpattern) 11);\n+  svcntb_pat ((enum svpattern) 12);\n+  svcntb_pat ((enum svpattern) 13);\n+  svcntb_pat ((enum svpattern) 14); /* { dg-error {passing 14 to argument 1 of 'svcntb_pat', which expects a valid 'enum svpattern' value} } */\n+  svcntb_pat ((enum svpattern) 15); /* { dg-error {passing 15 to argument 1 of 'svcntb_pat', which expects a valid 'enum svpattern' value} } */\n+  svcntb_pat ((enum svpattern) 16); /* { dg-error {passing 16 to argument 1 of 'svcntb_pat', which expects a valid 'enum svpattern' value} } */\n+  svcntb_pat ((enum svpattern) 17); /* { dg-error {passing 17 to argument 1 of 'svcntb_pat', which expects a valid 'enum svpattern' value} } */\n+  svcntb_pat ((enum svpattern) 18); /* { dg-error {passing 18 to argument 1 of 'svcntb_pat', which expects a valid 'enum svpattern' value} } */\n+  svcntb_pat ((enum svpattern) 19); /* { dg-error {passing 19 to argument 1 of 'svcntb_pat', which expects a valid 'enum svpattern' value} } */\n+  svcntb_pat ((enum svpattern) 20); /* { dg-error {passing 20 to argument 1 of 'svcntb_pat', which expects a valid 'enum svpattern' value} } */\n+  svcntb_pat ((enum svpattern) 21); /* { dg-error {passing 21 to argument 1 of 'svcntb_pat', which expects a valid 'enum svpattern' value} } */\n+  svcntb_pat ((enum svpattern) 22); /* { dg-error {passing 22 to argument 1 of 'svcntb_pat', which expects a valid 'enum svpattern' value} } */\n+  svcntb_pat ((enum svpattern) 23); /* { dg-error {passing 23 to argument 1 of 'svcntb_pat', which expects a valid 'enum svpattern' value} } */\n+  svcntb_pat ((enum svpattern) 24); /* { dg-error {passing 24 to argument 1 of 'svcntb_pat', which expects a valid 'enum svpattern' value} } */\n+  svcntb_pat ((enum svpattern) 25); /* { dg-error {passing 25 to argument 1 of 'svcntb_pat', which expects a valid 'enum svpattern' value} } */\n+  svcntb_pat ((enum svpattern) 26); /* { dg-error {passing 26 to argument 1 of 'svcntb_pat', which expects a valid 'enum svpattern' value} } */\n+  svcntb_pat ((enum svpattern) 27); /* { dg-error {passing 27 to argument 1 of 'svcntb_pat', which expects a valid 'enum svpattern' value} } */\n+  svcntb_pat ((enum svpattern) 28); /* { dg-error {passing 28 to argument 1 of 'svcntb_pat', which expects a valid 'enum svpattern' value} } */\n+  svcntb_pat ((enum svpattern) 29);\n+  svcntb_pat ((enum svpattern) 30);\n+  svcntb_pat ((enum svpattern) 31);\n+  svcntb_pat ((enum svpattern) 32); /* { dg-error {passing 32 to argument 1 of 'svcntb_pat', which expects a valid 'enum svpattern' value} } */\n+}"}, {"sha": "daf9e0d5beb2f88807547ae504a4b35327d2b66c", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/count_vector_1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcount_vector_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcount_vector_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcount_vector_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svuint32_t u32, svuint32x2_t u32x2)\n+{\n+  svlen (); /* { dg-error {too few arguments to function 'svlen'} } */\n+  svlen (u32, u32); /* { dg-error {too many arguments to function 'svlen'} } */\n+  svlen (0); /* { dg-error {passing 'int' to argument 1 of 'svlen', which expects an SVE vector type} } */\n+  svlen (pg); /* { dg-error {'svlen' has no form that takes 'svbool_t' arguments} } */\n+  svlen (u32x2); /* { dg-error {passing 'svuint32x2_t' to argument 1 of 'svlen', which expects a single SVE vector rather than a tuple} } */\n+}"}, {"sha": "31321a0464931e5b78ce3b2b889bd323a998f0c2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/create_1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcreate_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcreate_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcreate_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svuint8x2_t *ptr, svbool_t pg, svuint8_t u8, svfloat64_t f64,\n+    svuint8x2_t u8x2, int x)\n+{\n+  *ptr = svcreate2 (u8); /* { dg-error {too few arguments to function 'svcreate2'} } */\n+  *ptr = svcreate2 (u8, u8, u8); /* { dg-error {too many arguments to function 'svcreate2'} } */\n+  *ptr = svcreate2 (u8x2, u8x2); /* { dg-error {passing 'svuint8x2_t' to argument 1 of 'svcreate2', which expects a single SVE vector rather than a tuple} } */\n+  *ptr = svcreate2 (u8, f64); /* { dg-error {passing 'svfloat64_t' to argument 2 of 'svcreate2', but previous arguments had type 'svuint8_t'} } */\n+  *ptr = svcreate2 (u8, pg); /* { dg-error {passing 'svbool_t' to argument 2 of 'svcreate2', but previous arguments had type 'svuint8_t'} } */\n+  *ptr = svcreate2 (u8, x); /* { dg-error {passing 'int' to argument 2 of 'svcreate2', which expects an SVE vector type} } */\n+  *ptr = svcreate2 (x, u8); /* { dg-error {passing 'int' to argument 1 of 'svcreate2', which expects an SVE vector type} } */\n+  *ptr = svcreate2 (pg, u8); /* { dg-error {passing 'svuint8_t' to argument 2 of 'svcreate2', but previous arguments had type 'svbool_t'} } */\n+  *ptr = svcreate2 (pg, pg); /* { dg-error {'svcreate2' has no form that takes 'svbool_t' arguments} } */\n+  *ptr = svcreate2 (u8, u8);\n+  *ptr = svcreate2 (f64, f64); /* { dg-error {incompatible types when assigning to type 'svuint8x2_t' from type 'svfloat64x2_t'} } */\n+}"}, {"sha": "28ad16c2de4967e8c77ef317a89070477d5a707f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/create_2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcreate_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcreate_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcreate_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svuint8x2_t *ptr, svbool_t pg, svuint8_t u8, svfloat64_t f64,\n+    svuint8x2_t u8x2, int x)\n+{\n+  *ptr = svcreate2_u8 (u8); /* { dg-error {too few arguments to function 'svcreate2_u8'} } */\n+  *ptr = svcreate2_u8 (u8, u8, u8); /* { dg-error {too many arguments to function 'svcreate2_u8'} } */\n+  *ptr = svcreate2_u8 (u8x2, u8x2); /* { dg-error {incompatible type for argument 1 of 'svcreate2_u8'} } */\n+  /* { dg-error {incompatible type for argument 2 of 'svcreate2_u8'} \"\" { target *-*-* } .-1 } */\n+  *ptr = svcreate2_u8 (u8, f64); /* { dg-error {incompatible type for argument 2 of 'svcreate2_u8'} } */\n+  *ptr = svcreate2_u8 (u8, pg); /* { dg-error {incompatible type for argument 2 of 'svcreate2_u8'} } */\n+  *ptr = svcreate2_u8 (u8, x); /* { dg-error {incompatible type for argument 2 of 'svcreate2_u8'} } */\n+  *ptr = svcreate2_u8 (x, u8); /* { dg-error {incompatible type for argument 1 of 'svcreate2_u8'} } */\n+  *ptr = svcreate2_u8 (pg, u8); /* { dg-error {incompatible type for argument 1 of 'svcreate2_u8'} } */\n+  *ptr = svcreate2_u8 (pg, pg); /* { dg-error {incompatible type for argument 1 of 'svcreate2_u8'} } */\n+  /* { dg-error {incompatible type for argument 2 of 'svcreate2_u8'} \"\" { target *-*-* } .-1 } */\n+  *ptr = svcreate2_u8 (u8, u8);\n+  *ptr = svcreate2_f64 (f64, f64); /* { dg-error {incompatible types when assigning to type 'svuint8x2_t' from type 'svfloat64x2_t'} } */\n+}"}, {"sha": "a88e56b318d9994f7ac3bb2654d852f65ccd3308", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/create_3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcreate_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcreate_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcreate_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svfloat16x3_t *ptr, svbool_t pg, svfloat16_t f16, svfloat64_t f64,\n+    svfloat16x3_t f16x3, int x)\n+{\n+  *ptr = svcreate3 (f16); /* { dg-error {too few arguments to function 'svcreate3'} } */\n+  *ptr = svcreate3 (f16, f16); /* { dg-error {too few arguments to function 'svcreate3'} } */\n+  *ptr = svcreate3 (f16, f16, f16, f16); /* { dg-error {too many arguments to function 'svcreate3'} } */\n+  *ptr = svcreate3 (f16x3, f16x3, f16x3); /* { dg-error {passing 'svfloat16x3_t' to argument 1 of 'svcreate3', which expects a single SVE vector rather than a tuple} } */\n+  *ptr = svcreate3 (f16, f16, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svcreate3', but previous arguments had type 'svfloat16_t'} } */\n+  *ptr = svcreate3 (f16, pg, f16); /* { dg-error {passing 'svbool_t' to argument 2 of 'svcreate3', but previous arguments had type 'svfloat16_t'} } */\n+  *ptr = svcreate3 (f16, x, f16); /* { dg-error {passing 'int' to argument 2 of 'svcreate3', which expects an SVE vector type} } */\n+  *ptr = svcreate3 (x, f16, f16); /* { dg-error {passing 'int' to argument 1 of 'svcreate3', which expects an SVE vector type} } */\n+  *ptr = svcreate3 (pg, f16, f16); /* { dg-error {passing 'svfloat16_t' to argument 2 of 'svcreate3', but previous arguments had type 'svbool_t'} } */\n+  *ptr = svcreate3 (pg, pg, pg); /* { dg-error {'svcreate3' has no form that takes 'svbool_t' arguments} } */\n+  *ptr = svcreate3 (f16, f16, f16);\n+  *ptr = svcreate3 (f64, f64, f64); /* { dg-error {incompatible types when assigning to type 'svfloat16x3_t' from type 'svfloat64x3_t'} } */\n+}"}, {"sha": "c111e9f29594c5c19b48bd09eb2fa5dde579dcf6", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/create_4.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcreate_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcreate_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcreate_4.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svfloat16x3_t *ptr, svbool_t pg, svfloat16_t f16, svfloat64_t f64,\n+    svfloat16x3_t f16x3, int x)\n+{\n+  *ptr = svcreate3_f16 (f16); /* { dg-error {too few arguments to function 'svcreate3_f16'} } */\n+  *ptr = svcreate3_f16 (f16, f16); /* { dg-error {too few arguments to function 'svcreate3_f16'} } */\n+  *ptr = svcreate3_f16 (f16, f16, f16, f16); /* { dg-error {too many arguments to function 'svcreate3_f16'} } */\n+  *ptr = svcreate3_f16 (f16x3, f16x3, f16x3); /* { dg-error {incompatible type for argument 1 of 'svcreate3_f16'} } */\n+  /* { dg-error {incompatible type for argument 2 of 'svcreate3_f16'} \"\" { target *-*-* } .-1 } */\n+  /* { dg-error {incompatible type for argument 3 of 'svcreate3_f16'} \"\" { target *-*-* } .-2 } */\n+  *ptr = svcreate3_f16 (f16, f16, f64); /* { dg-error {incompatible type for argument 3 of 'svcreate3_f16'} } */\n+  *ptr = svcreate3_f16 (f16, pg, f16); /* { dg-error {incompatible type for argument 2 of 'svcreate3_f16'} } */\n+  *ptr = svcreate3_f16 (f16, x, f16); /* { dg-error {incompatible type for argument 2 of 'svcreate3_f16'} } */\n+  *ptr = svcreate3_f16 (x, f16, f16); /* { dg-error {incompatible type for argument 1 of 'svcreate3_f16'} } */\n+  *ptr = svcreate3_f16 (pg, f16, f16); /* { dg-error {incompatible type for argument 1 of 'svcreate3_f16'} } */\n+  *ptr = svcreate3_f16 (pg, pg, pg); /* { dg-error {incompatible type for argument 1 of 'svcreate3_f16'} } */\n+  /* { dg-error {incompatible type for argument 2 of 'svcreate3_f16'} \"\" { target *-*-* } .-1 } */\n+  /* { dg-error {incompatible type for argument 3 of 'svcreate3_f16'} \"\" { target *-*-* } .-2 } */\n+  *ptr = svcreate3_f16 (f16, f16, f16);\n+  *ptr = svcreate3_f64 (f64, f64, f64); /* { dg-error {incompatible types when assigning to type 'svfloat16x3_t' from type 'svfloat64x3_t'} } */\n+}"}, {"sha": "fed12450627a17ead21face399bcc79f913a5dc2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/create_5.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcreate_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcreate_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcreate_5.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svint32x4_t *ptr, svbool_t pg, svint32_t s32, svfloat64_t f64,\n+    svint32x4_t s32x4, int x)\n+{\n+  *ptr = svcreate4 (s32); /* { dg-error {too few arguments to function 'svcreate4'} } */\n+  *ptr = svcreate4 (s32, s32); /* { dg-error {too few arguments to function 'svcreate4'} } */\n+  *ptr = svcreate4 (s32, s32, s32); /* { dg-error {too few arguments to function 'svcreate4'} } */\n+  *ptr = svcreate4 (s32, s32, s32, s32, s32); /* { dg-error {too many arguments to function 'svcreate4'} } */\n+  *ptr = svcreate4 (s32x4, s32x4, s32x4, s32x4); /* { dg-error {passing 'svint32x4_t' to argument 1 of 'svcreate4', which expects a single SVE vector rather than a tuple} } */\n+  *ptr = svcreate4 (s32, s32, s32, f64); /* { dg-error {passing 'svfloat64_t' to argument 4 of 'svcreate4', but previous arguments had type 'svint32_t'} } */\n+  *ptr = svcreate4 (s32, s32, pg, s32); /* { dg-error {passing 'svbool_t' to argument 3 of 'svcreate4', but previous arguments had type 'svint32_t'} } */\n+  *ptr = svcreate4 (s32, x, s32, s32); /* { dg-error {passing 'int' to argument 2 of 'svcreate4', which expects an SVE vector type} } */\n+  *ptr = svcreate4 (x, s32, s32, s32); /* { dg-error {passing 'int' to argument 1 of 'svcreate4', which expects an SVE vector type} } */\n+  *ptr = svcreate4 (pg, s32, s32, s32); /* { dg-error {passing 'svint32_t' to argument 2 of 'svcreate4', but previous arguments had type 'svbool_t'} } */\n+  *ptr = svcreate4 (pg, pg, pg, pg); /* { dg-error {'svcreate4' has no form that takes 'svbool_t' arguments} } */\n+  *ptr = svcreate4 (s32, s32, s32, s32);\n+  *ptr = svcreate4 (f64, f64, f64, f64); /* { dg-error {incompatible types when assigning to type 'svint32x4_t' from type 'svfloat64x4_t'} } */\n+}"}, {"sha": "b9e298acf02cd726b2b5cc5c0dbb77c7e8befd5e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/create_6.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcreate_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcreate_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fcreate_6.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svint32x4_t *ptr, svbool_t pg, svint32_t s32, svfloat64_t f64,\n+    svint32x4_t s32x4, int x)\n+{\n+  *ptr = svcreate4_s32 (s32); /* { dg-error {too few arguments to function 'svcreate4_s32'} } */\n+  *ptr = svcreate4_s32 (s32, s32); /* { dg-error {too few arguments to function 'svcreate4_s32'} } */\n+  *ptr = svcreate4_s32 (s32, s32, s32); /* { dg-error {too few arguments to function 'svcreate4_s32'} } */\n+  *ptr = svcreate4_s32 (s32, s32, s32, s32, s32); /* { dg-error {too many arguments to function 'svcreate4_s32'} } */\n+  *ptr = svcreate4_s32 (s32x4, s32x4, s32x4, s32x4); /* { dg-error {incompatible type for argument 1 of 'svcreate4_s32'} } */\n+  /* { dg-error {incompatible type for argument 2 of 'svcreate4_s32'} \"\" { target *-*-* } .-1 } */\n+  /* { dg-error {incompatible type for argument 3 of 'svcreate4_s32'} \"\" { target *-*-* } .-2 } */\n+  /* { dg-error {incompatible type for argument 4 of 'svcreate4_s32'} \"\" { target *-*-* } .-3 } */\n+  *ptr = svcreate4_s32 (s32, s32, s32, f64); /* { dg-error {incompatible type for argument 4 of 'svcreate4_s32'} } */\n+  *ptr = svcreate4_s32 (s32, s32, pg, s32); /* { dg-error {incompatible type for argument 3 of 'svcreate4_s32'} } */\n+  *ptr = svcreate4_s32 (s32, x, s32, s32); /* { dg-error {incompatible type for argument 2 of 'svcreate4_s32'} } */\n+  *ptr = svcreate4_s32 (x, s32, s32, s32); /* { dg-error {incompatible type for argument 1 of 'svcreate4_s32'} } */\n+  *ptr = svcreate4_s32 (pg, s32, s32, s32); /* { dg-error {incompatible type for argument 1 of 'svcreate4_s32'} } */\n+  *ptr = svcreate4_s32 (pg, pg, pg, pg); /* { dg-error {incompatible type for argument 1 of 'svcreate4_s32'} } */\n+  /* { dg-error {incompatible type for argument 2 of 'svcreate4_s32'} \"\" { target *-*-* } .-1 } */\n+  /* { dg-error {incompatible type for argument 3 of 'svcreate4_s32'} \"\" { target *-*-* } .-2 } */\n+  /* { dg-error {incompatible type for argument 4 of 'svcreate4_s32'} \"\" { target *-*-* } .-3 } */\n+  *ptr = svcreate4_s32 (s32, s32, s32, s32);\n+  *ptr = svcreate4_f64 (f64, f64, f64, f64); /* { dg-error {incompatible types when assigning to type 'svint32x4_t' from type 'svfloat64x4_t'} } */\n+}"}, {"sha": "bdce3926d27007faf5986d0d756ee5314e201f52", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/ext_1.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fext_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fext_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fext_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svint8_t s8, svuint8_t u8, svint16_t s16, svuint16_t u16,\n+    svfloat16_t f16, svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64, svfloat64_t f64, int i)\n+{\n+  svext (pg, pg, 0); /* { dg-error {'svext' has no form that takes 'svbool_t' arguments} } */\n+  svext (s8, s8, i); /* { dg-error {argument 3 of 'svext' must be an integer constant expression} } */\n+\n+  svext (s8, s8, -1); /* { dg-error {passing -1 to argument 3 of 'svext', which expects a value in the range \\[0, 255\\]} } */\n+  svext (s8, s8, 0);\n+  svext (s8, s8, 255);\n+  svext (s8, s8, 256); /* { dg-error {passing 256 to argument 3 of 'svext', which expects a value in the range \\[0, 255\\]} } */\n+\n+  svext (u8, u8, -1); /* { dg-error {passing -1 to argument 3 of 'svext', which expects a value in the range \\[0, 255\\]} } */\n+  svext (u8, u8, 0);\n+  svext (u8, u8, 255);\n+  svext (u8, u8, 256); /* { dg-error {passing 256 to argument 3 of 'svext', which expects a value in the range \\[0, 255\\]} } */\n+\n+  svext (s16, s16, -1); /* { dg-error {passing -1 to argument 3 of 'svext', which expects a value in the range \\[0, 127\\]} } */\n+  svext (s16, s16, 0);\n+  svext (s16, s16, 127);\n+  svext (s16, s16, 128); /* { dg-error {passing 128 to argument 3 of 'svext', which expects a value in the range \\[0, 127\\]} } */\n+\n+  svext (u16, u16, -1); /* { dg-error {passing -1 to argument 3 of 'svext', which expects a value in the range \\[0, 127\\]} } */\n+  svext (u16, u16, 0);\n+  svext (u16, u16, 127);\n+  svext (u16, u16, 128); /* { dg-error {passing 128 to argument 3 of 'svext', which expects a value in the range \\[0, 127\\]} } */\n+\n+  svext (f16, f16, -1); /* { dg-error {passing -1 to argument 3 of 'svext', which expects a value in the range \\[0, 127\\]} } */\n+  svext (f16, f16, 0);\n+  svext (f16, f16, 127);\n+  svext (f16, f16, 128); /* { dg-error {passing 128 to argument 3 of 'svext', which expects a value in the range \\[0, 127\\]} } */\n+\n+  svext (s32, s32, -1); /* { dg-error {passing -1 to argument 3 of 'svext', which expects a value in the range \\[0, 63\\]} } */\n+  svext (s32, s32, 0);\n+  svext (s32, s32, 63);\n+  svext (s32, s32, 64); /* { dg-error {passing 64 to argument 3 of 'svext', which expects a value in the range \\[0, 63\\]} } */\n+\n+  svext (u32, u32, -1); /* { dg-error {passing -1 to argument 3 of 'svext', which expects a value in the range \\[0, 63\\]} } */\n+  svext (u32, u32, 0);\n+  svext (u32, u32, 63);\n+  svext (u32, u32, 64); /* { dg-error {passing 64 to argument 3 of 'svext', which expects a value in the range \\[0, 63\\]} } */\n+\n+  svext (f32, f32, -1); /* { dg-error {passing -1 to argument 3 of 'svext', which expects a value in the range \\[0, 63\\]} } */\n+  svext (f32, f32, 0);\n+  svext (f32, f32, 63);\n+  svext (f32, f32, 64); /* { dg-error {passing 64 to argument 3 of 'svext', which expects a value in the range \\[0, 63\\]} } */\n+\n+  svext (s64, s64, -1); /* { dg-error {passing -1 to argument 3 of 'svext', which expects a value in the range \\[0, 31\\]} } */\n+  svext (s64, s64, 0);\n+  svext (s64, s64, 31);\n+  svext (s64, s64, 32); /* { dg-error {passing 32 to argument 3 of 'svext', which expects a value in the range \\[0, 31\\]} } */\n+\n+  svext (u64, u64, -1); /* { dg-error {passing -1 to argument 3 of 'svext', which expects a value in the range \\[0, 31\\]} } */\n+  svext (u64, u64, 0);\n+  svext (u64, u64, 31);\n+  svext (u64, u64, 32); /* { dg-error {passing 32 to argument 3 of 'svext', which expects a value in the range \\[0, 31\\]} } */\n+\n+  svext (f64, f64, -1); /* { dg-error {passing -1 to argument 3 of 'svext', which expects a value in the range \\[0, 31\\]} } */\n+  svext (f64, f64, 0);\n+  svext (f64, f64, 31);\n+  svext (f64, f64, 32); /* { dg-error {passing 32 to argument 3 of 'svext', which expects a value in the range \\[0, 31\\]} } */\n+}"}, {"sha": "1d292786df9e7c00e05653ad8b652a1d912909a5", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/fold_left_1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffold_left_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffold_left_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffold_left_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+svuint8_t\n+f1 (svbool_t pg, int i, float f, double d, void *ptr, svfloat32_t f32,\n+    svint32_t i32)\n+{\n+  svadda (pg, f); /* { dg-error {too few arguments to function 'svadda'} } */\n+  svadda (pg, f, f32, f32); /* { dg-error {too many arguments to function 'svadda'} } */\n+  svadda (f32, f, f32); /* { dg-error {passing 'svfloat32_t' to argument 1 of 'svadda', which expects 'svbool_t'} } */\n+  svadda (pg, i, f32);\n+  svadda (pg, f, f32);\n+  svadda (pg, d, f32);\n+  svadda (pg, ptr, f32); /* { dg-error {incompatible type for argument 2 of 'svadda_f32'} } */\n+  svadda (pg, pg, f32); /* { dg-error {passing 'svbool_t' to argument 2 of 'svadda', which expects a scalar element} } */\n+  svadda (pg, f32, f32); /* { dg-error {passing 'svfloat32_t' to argument 2 of 'svadda', which expects a scalar element} } */\n+  svadda (pg, f, f); /* { dg-error {passing 'float' to argument 3 of 'svadda', which expects an SVE vector type} } */\n+  svadda (pg, i, i32); /* { dg-error {'svadda' has no form that takes 'svint32_t' arguments} } */\n+  svadda (pg, i, i); /* { dg-error {passing 'int' to argument 3 of 'svadda', which expects an SVE vector type} } */\n+}"}, {"sha": "e1b99fa361b46dfd62b92c6814b83cc839b97ac5", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/func_redef_1.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffunc_redef_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffunc_redef_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffunc_redef_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+int svadd_n_u8_x; /* { dg-message \"note: previous declaration of 'svadd_n_u8_x' was here\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"  /* { dg-error {'svadd_n_u8_x' redeclared} } */"}, {"sha": "7f653f1173fdd501cdfdeb94bb11239d45c01804", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/func_redef_2.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffunc_redef_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffunc_redef_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffunc_redef_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+int svadd_n_u8_x = 1; /* { dg-message \"note: previous definition of 'svadd_n_u8_x' was here\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"  /* { dg-error {'svadd_n_u8_x' redeclared} } */"}, {"sha": "d9ff15a6c3ce3d742246b3c31a3f3c094ad60320", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/func_redef_3.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffunc_redef_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffunc_redef_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffunc_redef_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+extern __SVInt8_t svadd_u8_x (__SVBool_t, __SVInt8_t, __SVInt8_t); /* { dg-message \"note: previous declaration of 'svadd_u8_x' was here\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"  /* { dg-error {conflicting types for 'svadd_u8_x'} } */"}, {"sha": "9591e3d01d6a433ec4b46a794042fc713aa96223", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/func_redef_4.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffunc_redef_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffunc_redef_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffunc_redef_4.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+\n+/* Although somewhat suspect, this isn't actively wrong, and doesn't need\n+   to be diagnosed.  Any attempt to call the function before including\n+   arm_sve.h will lead to a link failure.  (Same for taking its address,\n+   etc.)  */\n+extern __SVUint8_t svadd_u8_x (__SVBool_t, __SVUint8_t, __SVUint8_t);\n+\n+#pragma GCC aarch64 \"arm_sve.h\""}, {"sha": "85923611d8e6139ceadcc235024a517bbc02cb19", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/func_redef_5.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffunc_redef_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffunc_redef_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffunc_redef_5.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+\n+/* There's no requirement to diagnose this.  In particular, arm_sve.h\n+   is allowed to use macros to implement the functions, and defining\n+   a macro that matches an existing symbol would not be diagnosed.\n+\n+   At the moment this works like other built-ins in the sense that the\n+   explicit definition \"wins\".  This isn't supported behavior though.  */\n+__SVUint8_t\n+svadd_u8_x (__SVBool_t pg, __SVUint8_t x, __SVUint8_t y)\n+{\n+  return x;\n+}\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+svuint8_t\n+f (svbool_t pg, svuint8_t x, svuint8_t y)\n+{\n+  return svadd_u8_x (pg, x, y);\n+}"}, {"sha": "1f04e46444977f1dbaded812f4e07087a3a8b560", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/func_redef_6.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffunc_redef_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffunc_redef_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ffunc_redef_6.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+typedef int svadd_u8_x; /* { dg-message \"note: previous declaration of 'svadd_u8_x' was here\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"  /* { dg-error {'svadd_u8_x' redeclared} } */"}, {"sha": "a3ac08fa80f05c371de365c587803cdde716a089", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/get_1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fget_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fget_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fget_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+svfloat64_t\n+f1 (svbool_t pg, svuint8_t u8, svuint8x2_t u8x2, svuint8x3_t u8x3, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  u8 = svget2 (u8x2); /* { dg-error {too few arguments to function 'svget2'} } */\n+  u8 = svget2 (u8x2, 1, 2); /* { dg-error {too many arguments to function 'svget2'} } */\n+  u8 = svget2 (u8, 0); /* { dg-error {passing single vector 'svuint8_t' to argument 1 of 'svget2', which expects a tuple of 2 vectors} } */\n+  u8 = svget2 (u8x3, 0); /* { dg-error {passing 'svuint8x3_t' to argument 1 of 'svget2', which expects a tuple of 2 vectors} } */\n+  u8 = svget2 (pg, 0); /* { dg-error {passing 'svbool_t' to argument 1 of 'svget2', which expects a tuple of 2 vectors} } */\n+  u8 = svget2 (u8x2, x); /* { dg-error {argument 2 of 'svget2' must be an integer constant expression} } */\n+  u8 = svget2 (u8x2, 0);\n+  f64 = svget2 (u8x2, 0); /* { dg-error {incompatible types when assigning to type 'svfloat64_t' from type 'svuint8_t'} } */\n+  u8 = svget2 (u8x2, 1);\n+  u8 = svget2 (u8x2, 2); /* { dg-error {passing 2 to argument 2 of 'svget2', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2 (u8x2, 3); /* { dg-error {passing 3 to argument 2 of 'svget2', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2 (u8x2, 4); /* { dg-error {passing 4 to argument 2 of 'svget2', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2 (u8x2, 5); /* { dg-error {passing 5 to argument 2 of 'svget2', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2 (u8x2, ~0U); /* { dg-error {passing [^ ]* to argument 2 of 'svget2', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2 (u8x2, one); /* { dg-error {argument 2 of 'svget2' must be an integer constant expression} } */\n+  u8 = svget2 (u8x2, 3 - 2);\n+  u8 = svget2 (u8x2, 1.0);\n+\n+  return f64;\n+}"}, {"sha": "4eee2439e964bf6293c068e4a1373c316db02d2b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/get_2.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fget_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fget_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fget_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+svfloat64_t\n+f1 (svbool_t pg, svuint8_t u8, svuint8x2_t u8x2, svint8x2_t s8x2,\n+    svuint8x3_t u8x3, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  u8 = svget2_u8 (u8x2); /* { dg-error {too few arguments to function 'svget2_u8'} } */\n+  u8 = svget2_u8 (u8x2, 1, 2); /* { dg-error {too many arguments to function 'svget2_u8'} } */\n+  u8 = svget2_u8 (u8, 0); /* { dg-error {incompatible type for argument 1 of 'svget2_u8'} } */\n+  u8 = svget2_u8 (s8x2, 0); /* { dg-error {incompatible type for argument 1 of 'svget2_u8'} } */\n+  u8 = svget2_u8 (u8x3, 0); /* { dg-error {incompatible type for argument 1 of 'svget2_u8'} } */\n+  u8 = svget2_u8 (pg, 0); /* { dg-error {incompatible type for argument 1 of 'svget2_u8'} } */\n+  u8 = svget2_u8 (u8x2, x); /* { dg-error {argument 2 of 'svget2_u8' must be an integer constant expression} } */\n+  u8 = svget2_u8 (u8x2, 0);\n+  f64 = svget2_u8 (u8x2, 0); /* { dg-error {incompatible types when assigning to type 'svfloat64_t' from type 'svuint8_t'} } */\n+  u8 = svget2_u8 (u8x2, 1);\n+  u8 = svget2_u8 (u8x2, 2); /* { dg-error {passing 2 to argument 2 of 'svget2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2_u8 (u8x2, 3); /* { dg-error {passing 3 to argument 2 of 'svget2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2_u8 (u8x2, 4); /* { dg-error {passing 4 to argument 2 of 'svget2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2_u8 (u8x2, 5); /* { dg-error {passing 5 to argument 2 of 'svget2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2_u8 (u8x2, ~0U); /* { dg-error {passing [^ ]* to argument 2 of 'svget2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8 = svget2_u8 (u8x2, one); /* { dg-error {argument 2 of 'svget2_u8' must be an integer constant expression} } */\n+  u8 = svget2_u8 (u8x2, 3 - 2);\n+  u8 = svget2_u8 (u8x2, 1.0);\n+\n+  return f64;\n+}"}, {"sha": "0e7b2e2276657f7234fb3138e314b70cf68545b7", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/get_3.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fget_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fget_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fget_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+svfloat64_t\n+f1 (svbool_t pg, svfloat16_t f16, svfloat16x3_t f16x3, svfloat16x4_t f16x4,\n+    int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  f16 = svget3 (f16x3); /* { dg-error {too few arguments to function 'svget3'} } */\n+  f16 = svget3 (f16x3, 1, 2); /* { dg-error {too many arguments to function 'svget3'} } */\n+  f16 = svget3 (f16, 0); /* { dg-error {passing single vector 'svfloat16_t' to argument 1 of 'svget3', which expects a tuple of 3 vectors} } */\n+  f16 = svget3 (f16x4, 0); /* { dg-error {passing 'svfloat16x4_t' to argument 1 of 'svget3', which expects a tuple of 3 vectors} } */\n+  f16 = svget3 (pg, 0); /* { dg-error {passing 'svbool_t' to argument 1 of 'svget3', which expects a tuple of 3 vectors} } */\n+  f16 = svget3 (f16x3, x); /* { dg-error {argument 2 of 'svget3' must be an integer constant expression} } */\n+  f16 = svget3 (f16x3, 0);\n+  f64 = svget3 (f16x3, 0); /* { dg-error {incompatible types when assigning to type 'svfloat64_t' from type 'svfloat16_t'} } */\n+  f16 = svget3 (f16x3, 1);\n+  f16 = svget3 (f16x3, 2);\n+  f16 = svget3 (f16x3, 3); /* { dg-error {passing 3 to argument 2 of 'svget3', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3 (f16x3, 4); /* { dg-error {passing 4 to argument 2 of 'svget3', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3 (f16x3, 5); /* { dg-error {passing 5 to argument 2 of 'svget3', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3 (f16x3, ~0U); /* { dg-error {passing [^ ]* to argument 2 of 'svget3', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3 (f16x3, one); /* { dg-error {argument 2 of 'svget3' must be an integer constant expression} } */\n+  f16 = svget3 (f16x3, 3 - 2);\n+  f16 = svget3 (f16x3, 1.0);\n+\n+  return f64;\n+}"}, {"sha": "72b4f82a66b75289362b3cc857554da742340f7f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/get_4.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fget_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fget_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fget_4.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+svfloat64_t\n+f1 (svbool_t pg, svfloat16_t f16, svfloat16x3_t f16x3, svfloat32x3_t f32x3,\n+    svfloat16x4_t f16x4, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  f16 = svget3_f16 (f16x3); /* { dg-error {too few arguments to function 'svget3_f16'} } */\n+  f16 = svget3_f16 (f16x3, 1, 2); /* { dg-error {too many arguments to function 'svget3_f16'} } */\n+  f16 = svget3_f16 (f16, 0); /* { dg-error {incompatible type for argument 1 of 'svget3_f16'} } */\n+  f16 = svget3_f16 (f32x3, 0); /* { dg-error {incompatible type for argument 1 of 'svget3_f16'} } */\n+  f16 = svget3_f16 (f16x4, 0); /* { dg-error {incompatible type for argument 1 of 'svget3_f16'} } */\n+  f16 = svget3_f16 (pg, 0); /* { dg-error {incompatible type for argument 1 of 'svget3_f16'} } */\n+  f16 = svget3_f16 (f16x3, x); /* { dg-error {argument 2 of 'svget3_f16' must be an integer constant expression} } */\n+  f16 = svget3_f16 (f16x3, 0);\n+  f64 = svget3_f16 (f16x3, 0); /* { dg-error {incompatible types when assigning to type 'svfloat64_t' from type 'svfloat16_t'} } */\n+  f16 = svget3_f16 (f16x3, 1);\n+  f16 = svget3_f16 (f16x3, 2);\n+  f16 = svget3_f16 (f16x3, 3); /* { dg-error {passing 3 to argument 2 of 'svget3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3_f16 (f16x3, 4); /* { dg-error {passing 4 to argument 2 of 'svget3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3_f16 (f16x3, 5); /* { dg-error {passing 5 to argument 2 of 'svget3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3_f16 (f16x3, ~0U); /* { dg-error {passing [^ ]* to argument 2 of 'svget3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16 = svget3_f16 (f16x3, one); /* { dg-error {argument 2 of 'svget3_f16' must be an integer constant expression} } */\n+  f16 = svget3_f16 (f16x3, 3 - 2);\n+  f16 = svget3_f16 (f16x3, 1.0);\n+\n+  return f64;\n+}"}, {"sha": "b0b69b95e2000bc106d98ec5c5834aaa72aca15b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/get_5.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fget_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fget_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fget_5.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+svfloat64_t\n+f1 (svbool_t pg, svint32_t s32, svint32x4_t s32x4, svint32x2_t s32x2, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  s32 = svget4 (s32x4); /* { dg-error {too few arguments to function 'svget4'} } */\n+  s32 = svget4 (s32x4, 1, 2); /* { dg-error {too many arguments to function 'svget4'} } */\n+  s32 = svget4 (s32, 0); /* { dg-error {passing single vector 'svint32_t' to argument 1 of 'svget4', which expects a tuple of 4 vectors} } */\n+  s32 = svget4 (s32x2, 0); /* { dg-error {passing 'svint32x2_t' to argument 1 of 'svget4', which expects a tuple of 4 vectors} } */\n+  s32 = svget4 (pg, 0); /* { dg-error {passing 'svbool_t' to argument 1 of 'svget4', which expects a tuple of 4 vectors} } */\n+  s32 = svget4 (s32x4, x); /* { dg-error {argument 2 of 'svget4' must be an integer constant expression} } */\n+  s32 = svget4 (s32x4, 0);\n+  f64 = svget4 (s32x4, 0); /* { dg-error {incompatible types when assigning to type 'svfloat64_t' from type 'svint32_t'} } */\n+  s32 = svget4 (s32x4, 1);\n+  s32 = svget4 (s32x4, 2);\n+  s32 = svget4 (s32x4, 3);\n+  s32 = svget4 (s32x4, 4); /* { dg-error {passing 4 to argument 2 of 'svget4', which expects a value in the range \\[0, 3\\]} } */\n+  s32 = svget4 (s32x4, 5); /* { dg-error {passing 5 to argument 2 of 'svget4', which expects a value in the range \\[0, 3\\]} } */\n+  s32 = svget4 (s32x4, ~0U); /* { dg-error {passing [^ ]* to argument 2 of 'svget4', which expects a value in the range \\[0, 3\\]} } */\n+  s32 = svget4 (s32x4, one); /* { dg-error {argument 2 of 'svget4' must be an integer constant expression} } */\n+  s32 = svget4 (s32x4, 3 - 2);\n+  s32 = svget4 (s32x4, 1.0);\n+\n+  return f64;\n+}"}, {"sha": "3801c0c4e2719575d64b38be13ab9e4dd82d09f8", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/get_6.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fget_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fget_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fget_6.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+svfloat64_t\n+f1 (svbool_t pg, svint32_t s32, svint32x4_t s32x4, svfloat32x4_t f32x4,\n+    svint32x2_t s32x2, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  s32 = svget4_s32 (s32x4); /* { dg-error {too few arguments to function 'svget4_s32'} } */\n+  s32 = svget4_s32 (s32x4, 1, 2); /* { dg-error {too many arguments to function 'svget4_s32'} } */\n+  s32 = svget4_s32 (s32, 0); /* { dg-error {incompatible type for argument 1 of 'svget4_s32'} } */\n+  s32 = svget4_s32 (f32x4, 0); /* { dg-error {incompatible type for argument 1 of 'svget4_s32'} } */\n+  s32 = svget4_s32 (s32x2, 0); /* { dg-error {incompatible type for argument 1 of 'svget4_s32'} } */\n+  s32 = svget4_s32 (pg, 0); /* { dg-error {incompatible type for argument 1 of 'svget4_s32'} } */\n+  s32 = svget4_s32 (s32x4, x); /* { dg-error {argument 2 of 'svget4_s32' must be an integer constant expression} } */\n+  s32 = svget4_s32 (s32x4, 0);\n+  f64 = svget4_s32 (s32x4, 0); /* { dg-error {incompatible types when assigning to type 'svfloat64_t' from type 'svint32_t'} } */\n+  s32 = svget4_s32 (s32x4, 1);\n+  s32 = svget4_s32 (s32x4, 2);\n+  s32 = svget4_s32 (s32x4, 3);\n+  s32 = svget4_s32 (s32x4, 4); /* { dg-error {passing 4 to argument 2 of 'svget4_s32', which expects a value in the range \\[0, 3\\]} } */\n+  s32 = svget4_s32 (s32x4, 5); /* { dg-error {passing 5 to argument 2 of 'svget4_s32', which expects a value in the range \\[0, 3\\]} } */\n+  s32 = svget4_s32 (s32x4, ~0U); /* { dg-error {passing [^ ]* to argument 2 of 'svget4_s32', which expects a value in the range \\[0, 3\\]} } */\n+  s32 = svget4_s32 (s32x4, one); /* { dg-error {argument 2 of 'svget4_s32' must be an integer constant expression} } */\n+  s32 = svget4_s32 (s32x4, 3 - 2);\n+  s32 = svget4_s32 (s32x4, 1.0);\n+\n+  return f64;\n+}"}, {"sha": "dcd291da67e354d627b58b30a16487969ece7a9d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/inc_dec_1.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,37 @@\n+#include <arm_sve.h>\n+\n+void\n+test (svbool_t pg, svint8_t s8, svuint8_t u8,\n+      svint16_t s16, svuint16_t u16, svint32_t s32, svuint32_t u32,\n+      svint64_t s64, svuint64_t u64, int16_t sh, uint16_t uh,\n+      int32_t sw, uint32_t uw, int64_t sd, uint64_t ud,\n+      float f, int i)\n+{\n+  svqincb (sw); /* { dg-error {too few arguments to function 'svqincb'} } */\n+  svqincb (sw, 1, 1); /* { dg-error {too many arguments to function 'svqincb'} } */\n+\n+  svqincb (pg, 1); /* { dg-error {'svqincb' has no form that takes 'svbool_t' arguments} } */\n+  svqincb (s8, 1); /* { dg-error {'svqincb' has no form that takes 'svint8_t' arguments} } */\n+  svqincb (u8, 1); /* { dg-error {'svqincb' has no form that takes 'svuint8_t' arguments} } */\n+  svqincb (s16, 1); /* { dg-error {'svqincb' has no form that takes 'svint16_t' arguments} } */\n+  svqincb (u16, 1); /* { dg-error {'svqincb' has no form that takes 'svuint16_t' arguments} } */\n+  svqincb (s32, 1); /* { dg-error {'svqincb' has no form that takes 'svint32_t' arguments} } */\n+  svqincb (u32, 1); /* { dg-error {'svqincb' has no form that takes 'svuint32_t' arguments} } */\n+  svqincb (s64, 1); /* { dg-error {'svqincb' has no form that takes 'svint64_t' arguments} } */\n+  svqincb (u64, 1); /* { dg-error {'svqincb' has no form that takes 'svuint64_t' arguments} } */\n+  svqincb (sh, 1);\n+  svqincb (sw, 1);\n+  svqincb (sd, 1);\n+  svqincb (uh, 1);\n+  svqincb (uw, 1);\n+  svqincb (ud, 1);\n+  svqincb (f, 1); /* { dg-error {passing 'float' to argument 1 of 'svqincb', which expects a 32-bit or 64-bit integer type} } */\n+  svqincb (ud, i); /* { dg-error {argument 2 of 'svqincb' must be an integer constant expression} } */\n+\n+  svqincb (sw, -1); /* { dg-error {passing -1 to argument 2 of 'svqincb', which expects a value in the range \\[1, 16\\]} } */\n+  svqincb (sw, 0); /* { dg-error {passing 0 to argument 2 of 'svqincb', which expects a value in the range \\[1, 16\\]} } */\n+  svqincb (sw, 1);\n+  svqincb (sw, 2);\n+  svqincb (sw, 16);\n+  svqincb (sw, 17); /* { dg-error {passing 17 to argument 2 of 'svqincb', which expects a value in the range \\[1, 16\\]} } */\n+}"}, {"sha": "e5acad187779daa12a5ace753b06b6a55bd310be", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/inc_dec_2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,13 @@\n+#include <arm_sve.h>\n+\n+void\n+test (int32_t sw, int i)\n+{\n+  svqincb_n_s32 (sw, -1); /* { dg-error {passing -1 to argument 2 of 'svqincb_n_s32', which expects a value in the range \\[1, 16\\]} } */\n+  svqincb_n_s32 (sw, 0); /* { dg-error {passing 0 to argument 2 of 'svqincb_n_s32', which expects a value in the range \\[1, 16\\]} } */\n+  svqincb_n_s32 (sw, 1);\n+  svqincb_n_s32 (sw, 2);\n+  svqincb_n_s32 (sw, 16);\n+  svqincb_n_s32 (sw, 17); /* { dg-error {passing 17 to argument 2 of 'svqincb_n_s32', which expects a value in the range \\[1, 16\\]} } */\n+  svqincb_n_s32 (sw, i); /* { dg-error {argument 2 of 'svqincb_n_s32' must be an integer constant expression} } */\n+}"}, {"sha": "351e7757fe27042c97ad80b78d4388c1c053e853", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/inc_dec_3.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,26 @@\n+#include <arm_sve.h>\n+\n+void\n+test (svbool_t pg, svint8_t s8, svuint8_t u8,\n+      svint16_t s16, svuint16_t u16, svint32_t s32, svuint32_t u32,\n+      svint64_t s64, svuint64_t u64, int16_t sh, uint16_t uh,\n+      int32_t sw, uint32_t uw, int64_t sd, uint64_t ud,\n+      float f)\n+{\n+  svqinch (pg, 1); /* { dg-error {'svqinch' has no form that takes 'svbool_t' arguments} } */\n+  svqinch (s8, 1); /* { dg-error {'svqinch' has no form that takes 'svint8_t' arguments} } */\n+  svqinch (u8, 1); /* { dg-error {'svqinch' has no form that takes 'svuint8_t' arguments} } */\n+  svqinch (s16, 1);\n+  svqinch (u16, 1);\n+  svqinch (s32, 1); /* { dg-error {'svqinch' has no form that takes 'svint32_t' arguments} } */\n+  svqinch (u32, 1); /* { dg-error {'svqinch' has no form that takes 'svuint32_t' arguments} } */\n+  svqinch (s64, 1); /* { dg-error {'svqinch' has no form that takes 'svint64_t' arguments} } */\n+  svqinch (u64, 1); /* { dg-error {'svqinch' has no form that takes 'svuint64_t' arguments} } */\n+  svqinch (sh, 1);\n+  svqinch (sw, 1);\n+  svqinch (sd, 1);\n+  svqinch (uh, 1);\n+  svqinch (uw, 1);\n+  svqinch (ud, 1);\n+  svqinch (f, 1); /* { dg-error {passing 'float' to argument 1 of 'svqinch', which expects a 32-bit or 64-bit integer type} } */\n+}"}, {"sha": "e071c022906262736699986eb882fbab3e08edee", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/inc_dec_4.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_4.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,26 @@\n+#include <arm_sve.h>\n+\n+void\n+test (svbool_t pg, svint8_t s8, svuint8_t u8,\n+      svint16_t s16, svuint16_t u16, svint32_t s32, svuint32_t u32,\n+      svint64_t s64, svuint64_t u64, int16_t sh, uint16_t uh,\n+      int32_t sw, uint32_t uw, int64_t sd, uint64_t ud,\n+      float f)\n+{\n+  svqincw (pg, 1); /* { dg-error {'svqincw' has no form that takes 'svbool_t' arguments} } */\n+  svqincw (s8, 1); /* { dg-error {'svqincw' has no form that takes 'svint8_t' arguments} } */\n+  svqincw (u8, 1); /* { dg-error {'svqincw' has no form that takes 'svuint8_t' arguments} } */\n+  svqincw (s16, 1); /* { dg-error {'svqincw' has no form that takes 'svint16_t' arguments} } */\n+  svqincw (u16, 1); /* { dg-error {'svqincw' has no form that takes 'svuint16_t' arguments} } */\n+  svqincw (s32, 1);\n+  svqincw (u32, 1);\n+  svqincw (s64, 1); /* { dg-error {'svqincw' has no form that takes 'svint64_t' arguments} } */\n+  svqincw (u64, 1); /* { dg-error {'svqincw' has no form that takes 'svuint64_t' arguments} } */\n+  svqincw (sh, 1);\n+  svqincw (sw, 1);\n+  svqincw (sd, 1);\n+  svqincw (uh, 1);\n+  svqincw (uw, 1);\n+  svqincw (ud, 1);\n+  svqincw (f, 1); /* { dg-error {passing 'float' to argument 1 of 'svqincw', which expects a 32-bit or 64-bit integer type} } */\n+}"}, {"sha": "be9c76928932492c4a144259bf68a9c9070bf78c", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/inc_dec_5.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_5.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,26 @@\n+#include <arm_sve.h>\n+\n+void\n+test (svbool_t pg, svint8_t s8, svuint8_t u8,\n+      svint16_t s16, svuint16_t u16, svint32_t s32, svuint32_t u32,\n+      svint64_t s64, svuint64_t u64, int16_t sh, uint16_t uh,\n+      int32_t sw, uint32_t uw, int64_t sd, uint64_t ud,\n+      float f)\n+{\n+  svqincd (pg, 1); /* { dg-error {'svqincd' has no form that takes 'svbool_t' arguments} } */\n+  svqincd (s8, 1); /* { dg-error {'svqincd' has no form that takes 'svint8_t' arguments} } */\n+  svqincd (u8, 1); /* { dg-error {'svqincd' has no form that takes 'svuint8_t' arguments} } */\n+  svqincd (s16, 1); /* { dg-error {'svqincd' has no form that takes 'svint16_t' arguments} } */\n+  svqincd (u16, 1); /* { dg-error {'svqincd' has no form that takes 'svuint16_t' arguments} } */\n+  svqincd (s32, 1); /* { dg-error {'svqincd' has no form that takes 'svint32_t' arguments} } */\n+  svqincd (u32, 1); /* { dg-error {'svqincd' has no form that takes 'svuint32_t' arguments} } */\n+  svqincd (s64, 1);\n+  svqincd (u64, 1);\n+  svqincd (sh, 1);\n+  svqincd (sw, 1);\n+  svqincd (sd, 1);\n+  svqincd (uh, 1);\n+  svqincd (uw, 1);\n+  svqincd (ud, 1);\n+  svqincd (f, 1); /* { dg-error {passing 'float' to argument 1 of 'svqincd', which expects a 32-bit or 64-bit integer type} } */\n+}"}, {"sha": "f2e5841d47e4a5ed0e0f1b113db3c9bdabeaf27a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/inc_dec_pat_1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pat_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pat_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pat_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,47 @@\n+#include <arm_sve.h>\n+\n+void\n+test (enum svpattern pat, svbool_t pg, svint8_t s8, svuint8_t u8,\n+      svint16_t s16, svuint16_t u16, svint32_t s32, svuint32_t u32,\n+      svint64_t s64, svuint64_t u64, int16_t sh, uint16_t uh,\n+      int32_t sw, uint32_t uw, int64_t sd, uint64_t ud,\n+      float f, int i)\n+{\n+  svqincb_pat (sw, pat); /* { dg-error {too few arguments to function 'svqincb_pat'} } */\n+  svqincb_pat (sw, pat, 1, 1); /* { dg-error {too many arguments to function 'svqincb_pat'} } */\n+\n+  svqincb_pat (pg, SV_ALL, 1); /* { dg-error {'svqincb_pat' has no form that takes 'svbool_t' arguments} } */\n+  svqincb_pat (s8, SV_ALL, 1); /* { dg-error {'svqincb_pat' has no form that takes 'svint8_t' arguments} } */\n+  svqincb_pat (u8, SV_ALL, 1); /* { dg-error {'svqincb_pat' has no form that takes 'svuint8_t' arguments} } */\n+  svqincb_pat (s16, SV_ALL, 1); /* { dg-error {'svqincb_pat' has no form that takes 'svint16_t' arguments} } */\n+  svqincb_pat (u16, SV_ALL, 1); /* { dg-error {'svqincb_pat' has no form that takes 'svuint16_t' arguments} } */\n+  svqincb_pat (s32, SV_ALL, 1); /* { dg-error {'svqincb_pat' has no form that takes 'svint32_t' arguments} } */\n+  svqincb_pat (u32, SV_ALL, 1); /* { dg-error {'svqincb_pat' has no form that takes 'svuint32_t' arguments} } */\n+  svqincb_pat (s64, SV_ALL, 1); /* { dg-error {'svqincb_pat' has no form that takes 'svint64_t' arguments} } */\n+  svqincb_pat (u64, SV_ALL, 1); /* { dg-error {'svqincb_pat' has no form that takes 'svuint64_t' arguments} } */\n+  svqincb_pat (sh, SV_ALL, 1);\n+  svqincb_pat (sw, SV_ALL, 1);\n+  svqincb_pat (sd, SV_ALL, 1);\n+  svqincb_pat (uh, SV_ALL, 1);\n+  svqincb_pat (uw, SV_ALL, 1);\n+  svqincb_pat (ud, SV_ALL, 1);\n+  svqincb_pat (f, SV_ALL, 1); /* { dg-error {passing 'float' to argument 1 of 'svqincb_pat', which expects a 32-bit or 64-bit integer type} } */\n+\n+  svqincb_pat (sw, pat, 1); /* { dg-error {argument 2 of 'svqincb_pat' must be an integer constant expression} } */\n+  svqincb_pat (sw, i, 1); /* { dg-error {argument 2 of 'svqincb_pat' must be an integer constant expression} } */\n+  svqincb_pat (sw, (enum svpattern) -1, 1); /* { dg-error {passing 4294967295 to argument 2 of 'svqincb_pat', which expects a valid 'enum svpattern' value} } */\n+  svqincb_pat (sw, (enum svpattern) 0, 1);\n+  svqincb_pat (sw, (enum svpattern) 13, 1);\n+  svqincb_pat (sw, (enum svpattern) 14, 1); /* { dg-error {passing 14 to argument 2 of 'svqincb_pat', which expects a valid 'enum svpattern' value} } */\n+  svqincb_pat (sw, (enum svpattern) 28, 1); /* { dg-error {passing 28 to argument 2 of 'svqincb_pat', which expects a valid 'enum svpattern' value} } */\n+  svqincb_pat (sw, (enum svpattern) 29, 1);\n+  svqincb_pat (sw, (enum svpattern) 31, 1);\n+  svqincb_pat (sw, (enum svpattern) 32, 1); /* { dg-error {passing 32 to argument 2 of 'svqincb_pat', which expects a valid 'enum svpattern' value} } */\n+\n+  svqincb_pat (sw, SV_POW2, -1); /* { dg-error {passing -1 to argument 3 of 'svqincb_pat', which expects a value in the range \\[1, 16\\]} } */\n+  svqincb_pat (sw, SV_POW2, 0); /* { dg-error {passing 0 to argument 3 of 'svqincb_pat', which expects a value in the range \\[1, 16\\]} } */\n+  svqincb_pat (sw, SV_POW2, 1);\n+  svqincb_pat (sw, SV_POW2, 2);\n+  svqincb_pat (sw, SV_POW2, 16);\n+  svqincb_pat (sw, SV_POW2, 17); /* { dg-error {passing 17 to argument 3 of 'svqincb_pat', which expects a value in the range \\[1, 16\\]} } */\n+}"}, {"sha": "c1c1ab9d97d32f4d689a8671526d7d0d76dd0959", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/inc_dec_pat_2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pat_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pat_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pat_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,23 @@\n+#include <arm_sve.h>\n+\n+void\n+test (int32_t sw, enum svpattern pat, int i)\n+{\n+  svqincb_pat_n_s32 (sw, pat, 1); /* { dg-error {argument 2 of 'svqincb_pat_n_s32' must be an integer constant expression} } */\n+  svqincb_pat_n_s32 (sw, i, 1); /* { dg-error {argument 2 of 'svqincb_pat_n_s32' must be an integer constant expression} } */\n+  svqincb_pat_n_s32 (sw, (enum svpattern) -1, 1); /* { dg-error {passing 4294967295 to argument 2 of 'svqincb_pat_n_s32', which expects a valid 'enum svpattern' value} } */\n+  svqincb_pat_n_s32 (sw, (enum svpattern) 0, 1);\n+  svqincb_pat_n_s32 (sw, (enum svpattern) 13, 1);\n+  svqincb_pat_n_s32 (sw, (enum svpattern) 14, 1); /* { dg-error {passing 14 to argument 2 of 'svqincb_pat_n_s32', which expects a valid 'enum svpattern' value} } */\n+  svqincb_pat_n_s32 (sw, (enum svpattern) 28, 1); /* { dg-error {passing 28 to argument 2 of 'svqincb_pat_n_s32', which expects a valid 'enum svpattern' value} } */\n+  svqincb_pat_n_s32 (sw, (enum svpattern) 29, 1);\n+  svqincb_pat_n_s32 (sw, (enum svpattern) 31, 1);\n+  svqincb_pat_n_s32 (sw, (enum svpattern) 32, 1); /* { dg-error {passing 32 to argument 2 of 'svqincb_pat_n_s32', which expects a valid 'enum svpattern' value} } */\n+\n+  svqincb_pat_n_s32 (sw, SV_POW2, -1); /* { dg-error {passing -1 to argument 3 of 'svqincb_pat_n_s32', which expects a value in the range \\[1, 16\\]} } */\n+  svqincb_pat_n_s32 (sw, SV_POW2, 0); /* { dg-error {passing 0 to argument 3 of 'svqincb_pat_n_s32', which expects a value in the range \\[1, 16\\]} } */\n+  svqincb_pat_n_s32 (sw, SV_POW2, 1);\n+  svqincb_pat_n_s32 (sw, SV_POW2, 2);\n+  svqincb_pat_n_s32 (sw, SV_POW2, 16);\n+  svqincb_pat_n_s32 (sw, SV_POW2, 17); /* { dg-error {passing 17 to argument 3 of 'svqincb_pat_n_s32', which expects a value in the range \\[1, 16\\]} } */\n+}"}, {"sha": "4126b2461b81187d64d7f2f0e3e19c5b09b3850c", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/inc_dec_pat_3.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pat_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pat_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pat_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,26 @@\n+#include <arm_sve.h>\n+\n+void\n+test (svbool_t pg, svint8_t s8, svuint8_t u8,\n+      svint16_t s16, svuint16_t u16, svint32_t s32, svuint32_t u32,\n+      svint64_t s64, svuint64_t u64, int16_t sh, uint16_t uh,\n+      int32_t sw, uint32_t uw, int64_t sd, uint64_t ud,\n+      float f)\n+{\n+  svqinch_pat (pg, SV_ALL, 1); /* { dg-error {'svqinch_pat' has no form that takes 'svbool_t' arguments} } */\n+  svqinch_pat (s8, SV_ALL, 1); /* { dg-error {'svqinch_pat' has no form that takes 'svint8_t' arguments} } */\n+  svqinch_pat (u8, SV_ALL, 1); /* { dg-error {'svqinch_pat' has no form that takes 'svuint8_t' arguments} } */\n+  svqinch_pat (s16, SV_ALL, 1);\n+  svqinch_pat (u16, SV_ALL, 1);\n+  svqinch_pat (s32, SV_ALL, 1); /* { dg-error {'svqinch_pat' has no form that takes 'svint32_t' arguments} } */\n+  svqinch_pat (u32, SV_ALL, 1); /* { dg-error {'svqinch_pat' has no form that takes 'svuint32_t' arguments} } */\n+  svqinch_pat (s64, SV_ALL, 1); /* { dg-error {'svqinch_pat' has no form that takes 'svint64_t' arguments} } */\n+  svqinch_pat (u64, SV_ALL, 1); /* { dg-error {'svqinch_pat' has no form that takes 'svuint64_t' arguments} } */\n+  svqinch_pat (sh, SV_ALL, 1);\n+  svqinch_pat (sw, SV_ALL, 1);\n+  svqinch_pat (sd, SV_ALL, 1);\n+  svqinch_pat (uh, SV_ALL, 1);\n+  svqinch_pat (uw, SV_ALL, 1);\n+  svqinch_pat (ud, SV_ALL, 1);\n+  svqinch_pat (f, SV_ALL, 1); /* { dg-error {passing 'float' to argument 1 of 'svqinch_pat', which expects a 32-bit or 64-bit integer type} } */\n+}"}, {"sha": "9aabbd714e9895a56fd7bc7d94d3b2b85225a88e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/inc_dec_pat_4.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pat_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pat_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pat_4.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,26 @@\n+#include <arm_sve.h>\n+\n+void\n+test (svbool_t pg, svint8_t s8, svuint8_t u8,\n+      svint16_t s16, svuint16_t u16, svint32_t s32, svuint32_t u32,\n+      svint64_t s64, svuint64_t u64, int16_t sh, uint16_t uh,\n+      int32_t sw, uint32_t uw, int64_t sd, uint64_t ud,\n+      float f)\n+{\n+  svqincw_pat (pg, SV_ALL, 1); /* { dg-error {'svqincw_pat' has no form that takes 'svbool_t' arguments} } */\n+  svqincw_pat (s8, SV_ALL, 1); /* { dg-error {'svqincw_pat' has no form that takes 'svint8_t' arguments} } */\n+  svqincw_pat (u8, SV_ALL, 1); /* { dg-error {'svqincw_pat' has no form that takes 'svuint8_t' arguments} } */\n+  svqincw_pat (s16, SV_ALL, 1); /* { dg-error {'svqincw_pat' has no form that takes 'svint16_t' arguments} } */\n+  svqincw_pat (u16, SV_ALL, 1); /* { dg-error {'svqincw_pat' has no form that takes 'svuint16_t' arguments} } */\n+  svqincw_pat (s32, SV_ALL, 1);\n+  svqincw_pat (u32, SV_ALL, 1);\n+  svqincw_pat (s64, SV_ALL, 1); /* { dg-error {'svqincw_pat' has no form that takes 'svint64_t' arguments} } */\n+  svqincw_pat (u64, SV_ALL, 1); /* { dg-error {'svqincw_pat' has no form that takes 'svuint64_t' arguments} } */\n+  svqincw_pat (sh, SV_ALL, 1);\n+  svqincw_pat (sw, SV_ALL, 1);\n+  svqincw_pat (sd, SV_ALL, 1);\n+  svqincw_pat (uh, SV_ALL, 1);\n+  svqincw_pat (uw, SV_ALL, 1);\n+  svqincw_pat (ud, SV_ALL, 1);\n+  svqincw_pat (f, SV_ALL, 1); /* { dg-error {passing 'float' to argument 1 of 'svqincw_pat', which expects a 32-bit or 64-bit integer type} } */\n+}"}, {"sha": "5df88c6490514ce57461cd8937d2eebccc4f2a74", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/inc_dec_pat_5.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pat_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pat_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pat_5.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,26 @@\n+#include <arm_sve.h>\n+\n+void\n+test (svbool_t pg, svint8_t s8, svuint8_t u8,\n+      svint16_t s16, svuint16_t u16, svint32_t s32, svuint32_t u32,\n+      svint64_t s64, svuint64_t u64, int16_t sh, uint16_t uh,\n+      int32_t sw, uint32_t uw, int64_t sd, uint64_t ud,\n+      float f)\n+{\n+  svqincd_pat (pg, SV_ALL, 1); /* { dg-error {'svqincd_pat' has no form that takes 'svbool_t' arguments} } */\n+  svqincd_pat (s8, SV_ALL, 1); /* { dg-error {'svqincd_pat' has no form that takes 'svint8_t' arguments} } */\n+  svqincd_pat (u8, SV_ALL, 1); /* { dg-error {'svqincd_pat' has no form that takes 'svuint8_t' arguments} } */\n+  svqincd_pat (s16, SV_ALL, 1); /* { dg-error {'svqincd_pat' has no form that takes 'svint16_t' arguments} } */\n+  svqincd_pat (u16, SV_ALL, 1); /* { dg-error {'svqincd_pat' has no form that takes 'svuint16_t' arguments} } */\n+  svqincd_pat (s32, SV_ALL, 1); /* { dg-error {'svqincd_pat' has no form that takes 'svint32_t' arguments} } */\n+  svqincd_pat (u32, SV_ALL, 1); /* { dg-error {'svqincd_pat' has no form that takes 'svuint32_t' arguments} } */\n+  svqincd_pat (s64, SV_ALL, 1);\n+  svqincd_pat (u64, SV_ALL, 1);\n+  svqincd_pat (sh, SV_ALL, 1);\n+  svqincd_pat (sw, SV_ALL, 1);\n+  svqincd_pat (sd, SV_ALL, 1);\n+  svqincd_pat (uh, SV_ALL, 1);\n+  svqincd_pat (uw, SV_ALL, 1);\n+  svqincd_pat (ud, SV_ALL, 1);\n+  svqincd_pat (f, SV_ALL, 1); /* { dg-error {passing 'float' to argument 1 of 'svqincd_pat', which expects a 32-bit or 64-bit integer type} } */\n+}"}, {"sha": "a61afcd2db6f7469719c0afccb7d2040bf14ce9f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/inc_dec_pred_1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pred_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pred_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pred_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+#include <arm_sve.h>\n+\n+void\n+test (svbool_t pg, svint8_t s8, svuint8_t u8,\n+      svint16_t s16, svuint16_t u16, svint32_t s32, svuint32_t u32,\n+      svint64_t s64, svuint64_t u64, int i)\n+{\n+  svqincp (s32); /* { dg-error {too few arguments to function 'svqincp'} } */\n+  svqincp (s32, pg, pg); /* { dg-error {too many arguments to function 'svqincp'} } */\n+  svqincp (i, pg); /* { dg-error {passing 'int' to argument 1 of 'svqincp', which expects an SVE vector type} } */\n+  svqincp (pg, pg); /* { dg-error {'svqincp' has no form that takes 'svbool_t' arguments} } */\n+  svqincp (s8, pg); /* { dg-error {'svqincp' has no form that takes 'svint8_t' arguments} } */\n+  svqincp (u8, pg); /* { dg-error {'svqincp' has no form that takes 'svuint8_t' arguments} } */\n+  svqincp (s16, pg);\n+  svqincp (u16, pg);\n+  svqincp (s32, pg);\n+  svqincp (u32, pg);\n+  svqincp (s64, pg);\n+  svqincp (u64, pg);\n+  svqincp (u64, 0); /* { dg-error {passing 'int' to argument 2 of 'svqincp', which expects 'svbool_t'} } */\n+  svqincp (u64, u64); /* { dg-error {passing 'svuint64_t' to argument 2 of 'svqincp', which expects 'svbool_t'} } */\n+}"}, {"sha": "94ebe7e7aaff43584dbfdcd6ef27a6fb7f10b95a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/inc_dec_pred_scalar_1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pred_scalar_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pred_scalar_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Finc_dec_pred_scalar_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,19 @@\n+#include <arm_sve.h>\n+\n+void\n+test (svbool_t pg, svint32_t s32, svuint64_t u64, int16_t sh, uint16_t uh,\n+      int32_t sw, uint32_t uw, int64_t sd, uint64_t ud)\n+{\n+  svqincp_b8 (s32); /* { dg-error {too few arguments to function 'svqincp_b8'} } */\n+  svqincp_b8 (s32, pg, pg); /* { dg-error {too many arguments to function 'svqincp_b8'} } */\n+  svqincp_b8 (pg, pg); /* { dg-error {passing 'svbool_t' to argument 1 of 'svqincp_b8', which expects a 32-bit or 64-bit integer type} } */\n+  svqincp_b8 (s32, pg); /* { dg-error {passing 'svint32_t' to argument 1 of 'svqincp_b8', which expects a 32-bit or 64-bit integer type} } */\n+  svqincp_b8 (sh, pg);\n+  svqincp_b8 (uh, pg);\n+  svqincp_b8 (sw, pg);\n+  svqincp_b8 (uw, pg);\n+  svqincp_b8 (sd, pg);\n+  svqincp_b8 (ud, pg);\n+  svqincp_b8 (ud, 0); /* { dg-error {passing 'int' to argument 2 of 'svqincp_b8', which expects 'svbool_t'} } */\n+  svqincp_b8 (ud, u64); /* { dg-error {passing 'svuint64_t' to argument 2 of 'svqincp_b8', which expects 'svbool_t'} } */\n+}"}, {"sha": "91f37f6a53d7ba85ebc45f668c0079e3e3b66c42", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/ld1sh_gather_1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fld1sh_gather_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fld1sh_gather_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fld1sh_gather_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -Wpointer-sign\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { int i; };\n+\n+void\n+f1 (svbool_t pg, short *s16_ptr, unsigned short *u16_ptr,\n+    svint8_t s8, svint16_t s16,\n+    svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64, svfloat64_t f64, struct s s)\n+{\n+  svld1sh_gather_index (pg, s16_ptr, s32); /* { dg-warning {implicit declaration of function 'svld1sh_gather_index'; did you mean 'svld1_gather_index'} } */\n+  svld1sh_gather_index_u32 (pg, s16_ptr); /* { dg-error {too few arguments to function 'svld1sh_gather_index_u32'} } */\n+  svld1sh_gather_index_u32 (pg, s16_ptr, s32, 0); /* { dg-error {too many arguments to function 'svld1sh_gather_index_u32'} } */\n+  svld1sh_gather_index_u32 (pg, u16_ptr, s32); /* { dg-warning {pointer targets in passing argument 2 of 'svld1sh_gather_s32index_u32' differ in signedness} } */\n+  svld1sh_gather_index_u32 (pg, s16_ptr, pg); /* { dg-error {passing 'svbool_t' to argument 3 of 'svld1sh_gather_index_u32', which expects a vector of 32-bit integers} } */\n+  svld1sh_gather_index_u32 (pg, s16_ptr, s8); /* { dg-error {passing 'svint8_t' to argument 3 of 'svld1sh_gather_index_u32', which expects a vector of 32-bit integers} } */\n+  svld1sh_gather_index_u32 (pg, s16_ptr, s16); /* { dg-error {passing 'svint16_t' to argument 3 of 'svld1sh_gather_index_u32', which expects a vector of 32-bit integers} } */\n+  svld1sh_gather_index_u32 (pg, s16_ptr, s32);\n+  svld1sh_gather_index_u32 (pg, s16_ptr, u32);\n+  svld1sh_gather_index_u32 (pg, s16_ptr, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svld1sh_gather_index_u32', which expects a vector of 32-bit integers} } */\n+  svld1sh_gather_index_u32 (pg, s16_ptr, s64); /* { dg-error {passing 'svint64_t' to argument 3 of 'svld1sh_gather_index_u32', which expects a vector of 32-bit integers} } */\n+  svld1sh_gather_index_u32 (pg, s16_ptr, u64); /* { dg-error {passing 'svuint64_t' to argument 3 of 'svld1sh_gather_index_u32', which expects a vector of 32-bit integers} } */\n+  svld1sh_gather_index_u32 (pg, s16_ptr, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svld1sh_gather_index_u32', which expects a vector of 32-bit integers} } */\n+\n+  svld1sh_gather_index_u32 (pg, 0, s32);\n+  svld1sh_gather_index_u32 (pg, s, s32); /* { dg-error {'struct s' to argument 2 of 'svld1sh_gather_index_u32', which expects a vector or pointer base address} } */\n+\n+  svld1sh_gather_index_u32 (pg, pg, 0); /* { dg-error {passing 'svbool_t' to argument 2 of 'svld1sh_gather_index_u32', which expects 'svuint32_t'} } */\n+  svld1sh_gather_index_u32 (pg, s32, 0); /* { dg-error {passing 'svint32_t' to argument 2 of 'svld1sh_gather_index_u32', which expects 'svuint32_t'} } */\n+  svld1sh_gather_index_u32 (pg, u32, 0);\n+  svld1sh_gather_index_u32 (pg, u64, 0); /* { dg-error {passing 'svuint64_t' to argument 2 of 'svld1sh_gather_index_u32', which expects 'svuint32_t'} } */\n+}"}, {"sha": "34f989bf8bb93200e87021808b105f2314403f3f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/load_1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { signed char x; };\n+\n+svuint8_t\n+f1 (svbool_t pg, signed char *s8_ptr, void *void_ptr, struct s *s_ptr,\n+    float *f32_ptr, _Complex float *cf32_ptr, int **ptr_ptr)\n+{\n+  svld1 (pg); /* { dg-error {too few arguments to function 'svld1'} } */\n+  svld1 (pg, s8_ptr, 0); /* { dg-error {too many arguments to function 'svld1'} } */\n+  svld1 (0, s8_ptr); /* { dg-error {passing 'int' to argument 1 of 'svld1', which expects 'svbool_t'} } */\n+  svld1 (pg, 0); /* { dg-error {passing 'int' to argument 2 of 'svld1', which expects a pointer type} } */\n+  svld1 (pg, (int *) 0);\n+  svld1 (pg, void_ptr); /* { dg-error {passing 'void \\*' to argument 2 of 'svld1', but 'void' is not a valid SVE element type} } */\n+  svld1 (pg, s_ptr); /* { dg-error {passing 'struct s \\*' to argument 2 of 'svld1', but 'struct s' is not a valid SVE element type} } */\n+  svld1 (pg, f32_ptr);\n+  svld1 (pg, cf32_ptr); /* { dg-error {passing '_Complex float \\*' to argument 2 of 'svld1', but 'complex float' is not a valid SVE element type} } */\n+  svld1 (pg, ptr_ptr); /* { dg-error {passing 'int \\*\\*' to argument 2 of 'svld1', but 'int \\*' is not a valid SVE element type} } */\n+  return svld1 (pg, s8_ptr); /* { dg-error {incompatible types when returning type 'svint8_t' but 'svuint8_t' was expected} } */\n+}"}, {"sha": "beb07f138d78bc2631564bdc866d129aef89ed7e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/load_2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { signed char x; };\n+\n+svuint8_t\n+f1 (svbool_t pg, signed char *s8_ptr, void *void_ptr, struct s *s_ptr,\n+    float *f32_ptr, _Complex float *cf32_ptr)\n+{\n+  svld1_s8 (pg); /* { dg-error {too few arguments to function 'svld1_s8'} } */\n+  svld1_s8 (pg, s8_ptr, 0); /* { dg-error {too many arguments to function 'svld1_s8'} } */\n+  svld1_s8 (0, 0); /* { dg-error {incompatible type for argument 1 of 'svld1_s8'} } */\n+  svld1_s8 (pg, 0);\n+  svld1_s32 (pg, (int *) 0);\n+  svld1_s8 (pg, void_ptr);\n+  svld1_s8 (pg, s_ptr); /* { dg-warning {passing argument 2 of 'svld1_s8' from incompatible pointer type} } */\n+  svld1_f32 (pg, f32_ptr);\n+  svld1_f32 (pg, cf32_ptr); /* { dg-warning {passing argument 2 of 'svld1_f32' from incompatible pointer type} } */\n+  return svld1_s8 (pg, s8_ptr); /* { dg-error {incompatible types when returning type 'svint8_t' but 'svuint8_t' was expected} } */\n+}"}, {"sha": "770203f64c8bf4d20b796a5df8a9e22145c27c48", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/load_3.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { signed char x; };\n+\n+svuint8_t\n+f1 (svbool_t pg, signed char *s8_ptr, svint8_t s8)\n+{\n+  svld1_vnum (pg); /* { dg-error {too few arguments to function 'svld1_vnum'} } */\n+  svld1_vnum (pg, s8_ptr); /* { dg-error {too few arguments to function 'svld1_vnum'} } */\n+  svld1_vnum (pg, s8_ptr, 0, 0); /* { dg-error {too many arguments to function 'svld1_vnum'} } */\n+  svld1_vnum (0, s8_ptr, 0); /* { dg-error {passing 'int' to argument 1 of 'svld1_vnum', which expects 'svbool_t'} } */\n+  svld1_vnum (pg, 0, 0); /* { dg-error {passing 'int' to argument 2 of 'svld1_vnum', which expects a pointer type} } */\n+  svld1_vnum (pg, s8_ptr, s8_ptr); /* { dg-warning \"passing argument 3 of 'svld1_vnum_s8' makes integer from pointer without a cast\" } */\n+  svld1_vnum (pg, s8_ptr, s8); /* { dg-error {passing 'svint8_t' to argument 3 of 'svld1_vnum', which expects 'int64_t'} } */\n+}"}, {"sha": "91f37f6a53d7ba85ebc45f668c0079e3e3b66c42", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/load_ext_gather_index_1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_ext_gather_index_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_ext_gather_index_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_ext_gather_index_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -Wpointer-sign\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { int i; };\n+\n+void\n+f1 (svbool_t pg, short *s16_ptr, unsigned short *u16_ptr,\n+    svint8_t s8, svint16_t s16,\n+    svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64, svfloat64_t f64, struct s s)\n+{\n+  svld1sh_gather_index (pg, s16_ptr, s32); /* { dg-warning {implicit declaration of function 'svld1sh_gather_index'; did you mean 'svld1_gather_index'} } */\n+  svld1sh_gather_index_u32 (pg, s16_ptr); /* { dg-error {too few arguments to function 'svld1sh_gather_index_u32'} } */\n+  svld1sh_gather_index_u32 (pg, s16_ptr, s32, 0); /* { dg-error {too many arguments to function 'svld1sh_gather_index_u32'} } */\n+  svld1sh_gather_index_u32 (pg, u16_ptr, s32); /* { dg-warning {pointer targets in passing argument 2 of 'svld1sh_gather_s32index_u32' differ in signedness} } */\n+  svld1sh_gather_index_u32 (pg, s16_ptr, pg); /* { dg-error {passing 'svbool_t' to argument 3 of 'svld1sh_gather_index_u32', which expects a vector of 32-bit integers} } */\n+  svld1sh_gather_index_u32 (pg, s16_ptr, s8); /* { dg-error {passing 'svint8_t' to argument 3 of 'svld1sh_gather_index_u32', which expects a vector of 32-bit integers} } */\n+  svld1sh_gather_index_u32 (pg, s16_ptr, s16); /* { dg-error {passing 'svint16_t' to argument 3 of 'svld1sh_gather_index_u32', which expects a vector of 32-bit integers} } */\n+  svld1sh_gather_index_u32 (pg, s16_ptr, s32);\n+  svld1sh_gather_index_u32 (pg, s16_ptr, u32);\n+  svld1sh_gather_index_u32 (pg, s16_ptr, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svld1sh_gather_index_u32', which expects a vector of 32-bit integers} } */\n+  svld1sh_gather_index_u32 (pg, s16_ptr, s64); /* { dg-error {passing 'svint64_t' to argument 3 of 'svld1sh_gather_index_u32', which expects a vector of 32-bit integers} } */\n+  svld1sh_gather_index_u32 (pg, s16_ptr, u64); /* { dg-error {passing 'svuint64_t' to argument 3 of 'svld1sh_gather_index_u32', which expects a vector of 32-bit integers} } */\n+  svld1sh_gather_index_u32 (pg, s16_ptr, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svld1sh_gather_index_u32', which expects a vector of 32-bit integers} } */\n+\n+  svld1sh_gather_index_u32 (pg, 0, s32);\n+  svld1sh_gather_index_u32 (pg, s, s32); /* { dg-error {'struct s' to argument 2 of 'svld1sh_gather_index_u32', which expects a vector or pointer base address} } */\n+\n+  svld1sh_gather_index_u32 (pg, pg, 0); /* { dg-error {passing 'svbool_t' to argument 2 of 'svld1sh_gather_index_u32', which expects 'svuint32_t'} } */\n+  svld1sh_gather_index_u32 (pg, s32, 0); /* { dg-error {passing 'svint32_t' to argument 2 of 'svld1sh_gather_index_u32', which expects 'svuint32_t'} } */\n+  svld1sh_gather_index_u32 (pg, u32, 0);\n+  svld1sh_gather_index_u32 (pg, u64, 0); /* { dg-error {passing 'svuint64_t' to argument 2 of 'svld1sh_gather_index_u32', which expects 'svuint32_t'} } */\n+}"}, {"sha": "dae4d0ce120a52ea329a78e339fc77c2c301f9b0", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/load_ext_gather_offset_1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_ext_gather_offset_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_ext_gather_offset_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_ext_gather_offset_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { int i; };\n+\n+void\n+f1 (svbool_t pg, signed char *s8_ptr, short *s16_ptr,\n+    svint8_t s8, svint16_t s16,\n+    svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64, svfloat64_t f64, struct s s)\n+{\n+  svld1sb_gather_offset (pg, s8_ptr, s32); /* { dg-warning {implicit declaration of function 'svld1sb_gather_offset'; did you mean 'svld1_gather_offset'} } */\n+  svld1sb_gather_offset_s32 (pg, s8_ptr); /* { dg-error {too few arguments to function 'svld1sb_gather_offset_s32'} } */\n+  svld1sb_gather_offset_s32 (pg, s8_ptr, s32, 0); /* { dg-error {too many arguments to function 'svld1sb_gather_offset_s32'} } */\n+  svld1sb_gather_offset_s32 (pg, s16_ptr, s32); /* { dg-warning {passing argument 2 of 'svld1sb_gather_s32offset_s32' from incompatible pointer type} } */\n+  svld1sb_gather_offset_s32 (pg, s8_ptr, pg); /* { dg-error {passing 'svbool_t' to argument 3 of 'svld1sb_gather_offset_s32', which expects a vector of 32-bit integers} } */\n+  svld1sb_gather_offset_s32 (pg, s8_ptr, s8); /* { dg-error {passing 'svint8_t' to argument 3 of 'svld1sb_gather_offset_s32', which expects a vector of 32-bit integers} } */\n+  svld1sb_gather_offset_s32 (pg, s8_ptr, s16); /* { dg-error {passing 'svint16_t' to argument 3 of 'svld1sb_gather_offset_s32', which expects a vector of 32-bit integers} } */\n+  svld1sb_gather_offset_s32 (pg, s8_ptr, s32);\n+  svld1sb_gather_offset_s32 (pg, s8_ptr, u32);\n+  svld1sb_gather_offset_s32 (pg, s8_ptr, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svld1sb_gather_offset_s32', which expects a vector of 32-bit integers} } */\n+  svld1sb_gather_offset_s32 (pg, s8_ptr, s64); /* { dg-error {passing 'svint64_t' to argument 3 of 'svld1sb_gather_offset_s32', which expects a vector of 32-bit integers} } */\n+  svld1sb_gather_offset_s32 (pg, s8_ptr, u64); /* { dg-error {passing 'svuint64_t' to argument 3 of 'svld1sb_gather_offset_s32', which expects a vector of 32-bit integers} } */\n+  svld1sb_gather_offset_s32 (pg, s8_ptr, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svld1sb_gather_offset_s32', which expects a vector of 32-bit integers} } */\n+\n+  svld1sb_gather_offset_s32 (pg, 0, s32);\n+  svld1sb_gather_offset_s32 (pg, s, s32); /* { dg-error {'struct s' to argument 2 of 'svld1sb_gather_offset_s32', which expects a vector or pointer base address} } */\n+\n+  svld1sb_gather_offset_s32 (pg, pg, 0); /* { dg-error {passing 'svbool_t' to argument 2 of 'svld1sb_gather_offset_s32', which expects 'svuint32_t'} } */\n+  svld1sb_gather_offset_s32 (pg, s32, 0); /* { dg-error {passing 'svint32_t' to argument 2 of 'svld1sb_gather_offset_s32', which expects 'svuint32_t'} } */\n+  svld1sb_gather_offset_s32 (pg, u32, 0);\n+  svld1sb_gather_offset_s32 (pg, u64, 0); /* { dg-error {passing 'svuint64_t' to argument 2 of 'svld1sb_gather_offset_s32', which expects 'svuint32_t'} } */\n+}"}, {"sha": "1bc66977cdf9f4a65e1eb311b640b9121516a7cf", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/load_ext_gather_offset_2.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_ext_gather_offset_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_ext_gather_offset_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_ext_gather_offset_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { int i; };\n+\n+void\n+f1 (svbool_t pg, signed char *s8_ptr, short *s16_ptr,\n+    svint8_t s8, svint16_t s16,\n+    svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64, svfloat64_t f64, struct s s)\n+{\n+  svld1sb_gather_offset (pg, s8_ptr, s32); /* { dg-warning {implicit declaration of function 'svld1sb_gather_offset'; did you mean 'svld1_gather_offset'} } */\n+  svld1sb_gather_offset_u32 (pg, s8_ptr); /* { dg-error {too few arguments to function 'svld1sb_gather_offset_u32'} } */\n+  svld1sb_gather_offset_u32 (pg, s8_ptr, s32, 0); /* { dg-error {too many arguments to function 'svld1sb_gather_offset_u32'} } */\n+  svld1sb_gather_offset_u32 (pg, s16_ptr, s32); /* { dg-warning {passing argument 2 of 'svld1sb_gather_s32offset_u32' from incompatible pointer type} } */\n+  svld1sb_gather_offset_u32 (pg, s8_ptr, pg); /* { dg-error {passing 'svbool_t' to argument 3 of 'svld1sb_gather_offset_u32', which expects a vector of 32-bit integers} } */\n+  svld1sb_gather_offset_u32 (pg, s8_ptr, s8); /* { dg-error {passing 'svint8_t' to argument 3 of 'svld1sb_gather_offset_u32', which expects a vector of 32-bit integers} } */\n+  svld1sb_gather_offset_u32 (pg, s8_ptr, s16); /* { dg-error {passing 'svint16_t' to argument 3 of 'svld1sb_gather_offset_u32', which expects a vector of 32-bit integers} } */\n+  svld1sb_gather_offset_u32 (pg, s8_ptr, s32);\n+  svld1sb_gather_offset_u32 (pg, s8_ptr, u32);\n+  svld1sb_gather_offset_u32 (pg, s8_ptr, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svld1sb_gather_offset_u32', which expects a vector of 32-bit integers} } */\n+  svld1sb_gather_offset_u32 (pg, s8_ptr, s64); /* { dg-error {passing 'svint64_t' to argument 3 of 'svld1sb_gather_offset_u32', which expects a vector of 32-bit integers} } */\n+  svld1sb_gather_offset_u32 (pg, s8_ptr, u64); /* { dg-error {passing 'svuint64_t' to argument 3 of 'svld1sb_gather_offset_u32', which expects a vector of 32-bit integers} } */\n+  svld1sb_gather_offset_u32 (pg, s8_ptr, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svld1sb_gather_offset_u32', which expects a vector of 32-bit integers} } */\n+\n+  svld1sb_gather_offset_u32 (pg, 0, s32);\n+  svld1sb_gather_offset_u32 (pg, s, s32); /* { dg-error {'struct s' to argument 2 of 'svld1sb_gather_offset_u32', which expects a vector or pointer base address} } */\n+\n+  svld1sb_gather_offset_u32 (pg, pg, 0); /* { dg-error {passing 'svbool_t' to argument 2 of 'svld1sb_gather_offset_u32', which expects 'svuint32_t'} } */\n+  svld1sb_gather_offset_u32 (pg, s32, 0); /* { dg-error {passing 'svint32_t' to argument 2 of 'svld1sb_gather_offset_u32', which expects 'svuint32_t'} } */\n+  svld1sb_gather_offset_u32 (pg, u32, 0);\n+  svld1sb_gather_offset_u32 (pg, u64, 0); /* { dg-error {passing 'svuint64_t' to argument 2 of 'svld1sb_gather_offset_u32', which expects 'svuint32_t'} } */\n+}"}, {"sha": "6522889dbe79bfb080c4c499a701c9a768578a79", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/load_ext_gather_offset_3.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_ext_gather_offset_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_ext_gather_offset_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_ext_gather_offset_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { int i; };\n+\n+void\n+f1 (svbool_t pg, signed char *s8_ptr, short *s16_ptr,\n+    svint8_t s8, svint16_t s16,\n+    svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64, svfloat64_t f64, struct s s)\n+{\n+  svld1sb_gather_offset (pg, s8_ptr, s64); /* { dg-warning {implicit declaration of function 'svld1sb_gather_offset'; did you mean 'svld1_gather_offset'} } */\n+  svld1sb_gather_offset_s64 (pg, s8_ptr); /* { dg-error {too few arguments to function 'svld1sb_gather_offset_s64'} } */\n+  svld1sb_gather_offset_s64 (pg, s8_ptr, s64, 0); /* { dg-error {too many arguments to function 'svld1sb_gather_offset_s64'} } */\n+  svld1sb_gather_offset_s64 (pg, s16_ptr, s64); /* { dg-warning {passing argument 2 of 'svld1sb_gather_s64offset_s64' from incompatible pointer type} } */\n+  svld1sb_gather_offset_s64 (pg, s8_ptr, pg); /* { dg-error {passing 'svbool_t' to argument 3 of 'svld1sb_gather_offset_s64', which expects a vector of 64-bit integers} } */\n+  svld1sb_gather_offset_s64 (pg, s8_ptr, s8); /* { dg-error {passing 'svint8_t' to argument 3 of 'svld1sb_gather_offset_s64', which expects a vector of 64-bit integers} } */\n+  svld1sb_gather_offset_s64 (pg, s8_ptr, s16); /* { dg-error {passing 'svint16_t' to argument 3 of 'svld1sb_gather_offset_s64', which expects a vector of 64-bit integers} } */\n+  svld1sb_gather_offset_s64 (pg, s8_ptr, s32); /* { dg-error {passing 'svint32_t' to argument 3 of 'svld1sb_gather_offset_s64', which expects a vector of 64-bit integers} } */\n+  svld1sb_gather_offset_s64 (pg, s8_ptr, u32); /* { dg-error {passing 'svuint32_t' to argument 3 of 'svld1sb_gather_offset_s64', which expects a vector of 64-bit integers} } */\n+  svld1sb_gather_offset_s64 (pg, s8_ptr, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svld1sb_gather_offset_s64', which expects a vector of 64-bit integers} } */\n+  svld1sb_gather_offset_s64 (pg, s8_ptr, s64);\n+  svld1sb_gather_offset_s64 (pg, s8_ptr, u64);\n+  svld1sb_gather_offset_s64 (pg, s8_ptr, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svld1sb_gather_offset_s64', which expects a vector of 64-bit integers} } */\n+\n+  svld1sb_gather_offset_s64 (pg, 0, s64);\n+  svld1sb_gather_offset_s64 (pg, s, s64); /* { dg-error {'struct s' to argument 2 of 'svld1sb_gather_offset_s64', which expects a vector or pointer base address} } */\n+\n+  svld1sb_gather_offset_s64 (pg, pg, 0); /* { dg-error {passing 'svbool_t' to argument 2 of 'svld1sb_gather_offset_s64', which expects 'svuint64_t'} } */\n+  svld1sb_gather_offset_s64 (pg, s32, 0); /* { dg-error {passing 'svint32_t' to argument 2 of 'svld1sb_gather_offset_s64', which expects 'svuint64_t'} } */\n+  svld1sb_gather_offset_s64 (pg, u32, 0); /* { dg-error {passing 'svuint32_t' to argument 2 of 'svld1sb_gather_offset_s64', which expects 'svuint64_t'} } */\n+  svld1sb_gather_offset_s64 (pg, u64, 0);\n+}"}, {"sha": "025621989099422548c5fac1a48f5535254cfb1f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/load_ext_gather_offset_4.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_ext_gather_offset_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_ext_gather_offset_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_ext_gather_offset_4.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { int i; };\n+\n+void\n+f1 (svbool_t pg, signed char *s8_ptr, short *s16_ptr,\n+    svint8_t s8, svint16_t s16,\n+    svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64, svfloat64_t f64, struct s s)\n+{\n+  svld1sb_gather_offset (pg, s8_ptr, s64); /* { dg-warning {implicit declaration of function 'svld1sb_gather_offset'; did you mean 'svld1_gather_offset'} } */\n+  svld1sb_gather_offset_u64 (pg, s8_ptr); /* { dg-error {too few arguments to function 'svld1sb_gather_offset_u64'} } */\n+  svld1sb_gather_offset_u64 (pg, s8_ptr, s64, 0); /* { dg-error {too many arguments to function 'svld1sb_gather_offset_u64'} } */\n+  svld1sb_gather_offset_u64 (pg, s16_ptr, s64); /* { dg-warning {passing argument 2 of 'svld1sb_gather_s64offset_u64' from incompatible pointer type} } */\n+  svld1sb_gather_offset_u64 (pg, s8_ptr, pg); /* { dg-error {passing 'svbool_t' to argument 3 of 'svld1sb_gather_offset_u64', which expects a vector of 64-bit integers} } */\n+  svld1sb_gather_offset_u64 (pg, s8_ptr, s8); /* { dg-error {passing 'svint8_t' to argument 3 of 'svld1sb_gather_offset_u64', which expects a vector of 64-bit integers} } */\n+  svld1sb_gather_offset_u64 (pg, s8_ptr, s16); /* { dg-error {passing 'svint16_t' to argument 3 of 'svld1sb_gather_offset_u64', which expects a vector of 64-bit integers} } */\n+  svld1sb_gather_offset_u64 (pg, s8_ptr, s32); /* { dg-error {passing 'svint32_t' to argument 3 of 'svld1sb_gather_offset_u64', which expects a vector of 64-bit integers} } */\n+  svld1sb_gather_offset_u64 (pg, s8_ptr, u32); /* { dg-error {passing 'svuint32_t' to argument 3 of 'svld1sb_gather_offset_u64', which expects a vector of 64-bit integers} } */\n+  svld1sb_gather_offset_u64 (pg, s8_ptr, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svld1sb_gather_offset_u64', which expects a vector of 64-bit integers} } */\n+  svld1sb_gather_offset_u64 (pg, s8_ptr, s64);\n+  svld1sb_gather_offset_u64 (pg, s8_ptr, u64);\n+  svld1sb_gather_offset_u64 (pg, s8_ptr, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svld1sb_gather_offset_u64', which expects a vector of 64-bit integers} } */\n+\n+  svld1sb_gather_offset_u64 (pg, 0, s64);\n+  svld1sb_gather_offset_u64 (pg, s, s64); /* { dg-error {'struct s' to argument 2 of 'svld1sb_gather_offset_u64', which expects a vector or pointer base address} } */\n+\n+  svld1sb_gather_offset_u64 (pg, pg, 0); /* { dg-error {passing 'svbool_t' to argument 2 of 'svld1sb_gather_offset_u64', which expects 'svuint64_t'} } */\n+  svld1sb_gather_offset_u64 (pg, s32, 0); /* { dg-error {passing 'svint32_t' to argument 2 of 'svld1sb_gather_offset_u64', which expects 'svuint64_t'} } */\n+  svld1sb_gather_offset_u64 (pg, u32, 0); /* { dg-error {passing 'svuint32_t' to argument 2 of 'svld1sb_gather_offset_u64', which expects 'svuint64_t'} } */\n+  svld1sb_gather_offset_u64 (pg, u64, 0);\n+}"}, {"sha": "8d57aa020ead4822f59ee19f60c1ae2cb2ae26a2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/load_ext_gather_offset_5.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_ext_gather_offset_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_ext_gather_offset_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_ext_gather_offset_5.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { int i; };\n+\n+void\n+f1 (svbool_t pg, unsigned char *s8_ptr, unsigned short *s16_ptr,\n+    svint8_t s8, svint16_t s16,\n+    svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64, svfloat64_t f64, struct s s)\n+{\n+  svld1ub_gather_offset (pg, s8_ptr, s32); /* { dg-warning {implicit declaration of function 'svld1ub_gather_offset'; did you mean 'svld1_gather_offset'} } */\n+  svld1ub_gather_offset_s32 (pg, s8_ptr); /* { dg-error {too few arguments to function 'svld1ub_gather_offset_s32'} } */\n+  svld1ub_gather_offset_s32 (pg, s8_ptr, s32, 0); /* { dg-error {too many arguments to function 'svld1ub_gather_offset_s32'} } */\n+  svld1ub_gather_offset_s32 (pg, s16_ptr, s32); /* { dg-warning {passing argument 2 of 'svld1ub_gather_s32offset_s32' from incompatible pointer type} } */\n+  svld1ub_gather_offset_s32 (pg, s8_ptr, pg); /* { dg-error {passing 'svbool_t' to argument 3 of 'svld1ub_gather_offset_s32', which expects a vector of 32-bit integers} } */\n+  svld1ub_gather_offset_s32 (pg, s8_ptr, s8); /* { dg-error {passing 'svint8_t' to argument 3 of 'svld1ub_gather_offset_s32', which expects a vector of 32-bit integers} } */\n+  svld1ub_gather_offset_s32 (pg, s8_ptr, s16); /* { dg-error {passing 'svint16_t' to argument 3 of 'svld1ub_gather_offset_s32', which expects a vector of 32-bit integers} } */\n+  svld1ub_gather_offset_s32 (pg, s8_ptr, s32);\n+  svld1ub_gather_offset_s32 (pg, s8_ptr, u32);\n+  svld1ub_gather_offset_s32 (pg, s8_ptr, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svld1ub_gather_offset_s32', which expects a vector of 32-bit integers} } */\n+  svld1ub_gather_offset_s32 (pg, s8_ptr, s64); /* { dg-error {passing 'svint64_t' to argument 3 of 'svld1ub_gather_offset_s32', which expects a vector of 32-bit integers} } */\n+  svld1ub_gather_offset_s32 (pg, s8_ptr, u64); /* { dg-error {passing 'svuint64_t' to argument 3 of 'svld1ub_gather_offset_s32', which expects a vector of 32-bit integers} } */\n+  svld1ub_gather_offset_s32 (pg, s8_ptr, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svld1ub_gather_offset_s32', which expects a vector of 32-bit integers} } */\n+\n+  svld1ub_gather_offset_s32 (pg, 0, s32);\n+  svld1ub_gather_offset_s32 (pg, s, s32); /* { dg-error {'struct s' to argument 2 of 'svld1ub_gather_offset_s32', which expects a vector or pointer base address} } */\n+\n+  svld1ub_gather_offset_s32 (pg, pg, 0); /* { dg-error {passing 'svbool_t' to argument 2 of 'svld1ub_gather_offset_s32', which expects 'svuint32_t'} } */\n+  svld1ub_gather_offset_s32 (pg, s32, 0); /* { dg-error {passing 'svint32_t' to argument 2 of 'svld1ub_gather_offset_s32', which expects 'svuint32_t'} } */\n+  svld1ub_gather_offset_s32 (pg, u32, 0);\n+  svld1ub_gather_offset_s32 (pg, u64, 0); /* { dg-error {passing 'svuint64_t' to argument 2 of 'svld1ub_gather_offset_s32', which expects 'svuint32_t'} } */\n+}"}, {"sha": "21566a9d96d2aa168cc686bf02cb2815a6d8bdab", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/load_gather_sv_1.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_gather_sv_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_gather_sv_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_gather_sv_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { signed char x; };\n+\n+svuint32_t\n+f1 (svbool_t pg, signed char *s8_ptr, short *s16_ptr,\n+    int32_t *s32_ptr, uint32_t *u32_ptr, float *f32_ptr,\n+    int64_t *s64_ptr, uint64_t *u64_ptr, double *f64_ptr,\n+    void *void_ptr, struct s *s_ptr, _Complex float *cf32_ptr, int **ptr_ptr,\n+    svint8_t s8, svint16_t s16,\n+    svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64, svfloat64_t f64)\n+{\n+  svld1_gather_offset (pg, s32_ptr); /* { dg-error {too few arguments to function 'svld1_gather_offset'} } */\n+  svld1_gather_offset (pg, s32_ptr, s32, 0); /* { dg-error {too many arguments to function 'svld1_gather_offset'} } */\n+  svld1_gather_offset (0, s32_ptr, s32); /* { dg-error {passing 'int' to argument 1 of 'svld1_gather_offset', which expects 'svbool_t'} } */\n+  svld1_gather_offset (pg, 0, s32); /* { dg-error {passing 'int' to argument 2 of 'svld1_gather_offset', which expects a pointer type} } */\n+  svld1_gather_offset (pg, (int *) 0, s32);\n+  svld1_gather_offset (pg, void_ptr, s32); /* { dg-error {passing 'void \\*' to argument 2 of 'svld1_gather_offset', but 'void' is not a valid SVE element type} } */\n+  svld1_gather_offset (pg, s_ptr, s32); /* { dg-error {passing 'struct s \\*' to argument 2 of 'svld1_gather_offset', but 'struct s' is not a valid SVE element type} } */\n+  svld1_gather_offset (pg, f32_ptr, s32);\n+  svld1_gather_offset (pg, cf32_ptr, s32); /* { dg-error {passing '_Complex float \\*' to argument 2 of 'svld1_gather_offset', but 'complex float' is not a valid SVE element type} } */\n+  svld1_gather_offset (pg, ptr_ptr, u64); /* { dg-error {passing 'int \\*\\*' to argument 2 of 'svld1_gather_offset', but 'int \\*' is not a valid SVE element type} } */\n+  svld1_gather_offset (pg, u32, 0); /* { dg-error {passing 'svuint32_t' to argument 2 of 'svld1_gather_offset', which expects a pointer type} } */\n+  /* { dg-message {an explicit type suffix is needed when using a vector of base addresses} \"\" { target *-*-* } .-1 } */\n+  svld1_gather_offset (pg, u64, 0); /* { dg-error {passing 'svuint64_t' to argument 2 of 'svld1_gather_offset', which expects a pointer type} } */\n+  /* { dg-message {an explicit type suffix is needed when using a vector of base addresses} \"\" { target *-*-* } .-1 } */\n+\n+  svld1_gather_offset (pg, s8_ptr, s8); /* { dg-error {passing 'signed char \\*' to argument 2 of 'svld1_gather_offset', which expects a pointer to 32-bit or 64-bit elements} } */\n+  svld1_gather_offset (pg, s8_ptr, s32); /* { dg-error {passing 'signed char \\*' to argument 2 of 'svld1_gather_offset', which expects a pointer to 32-bit or 64-bit elements} } */\n+  svld1_gather_offset (pg, s16_ptr, s16); /* { dg-error {passing 'short( int)? \\*' to argument 2 of 'svld1_gather_offset', which expects a pointer to 32-bit or 64-bit elements} } */\n+  svld1_gather_offset (pg, s16_ptr, s32); /* { dg-error {passing 'short( int)? \\*' to argument 2 of 'svld1_gather_offset', which expects a pointer to 32-bit or 64-bit elements} } */\n+\n+  svld1_gather_offset (pg, s32_ptr, s32);\n+  svld1_gather_offset (pg, s32_ptr, u32);\n+  svld1_gather_offset (pg, s32_ptr, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svld1_gather_offset', which when loading 'svint32_t' expects a vector of 32-bit integers} } */\n+  svld1_gather_offset (pg, s32_ptr, s64); /* { dg-error {passing 'svint64_t' to argument 3 of 'svld1_gather_offset', which when loading 'svint32_t' expects a vector of 32-bit integers} } */\n+  svld1_gather_offset (pg, s32_ptr, u64); /* { dg-error {passing 'svuint64_t' to argument 3 of 'svld1_gather_offset', which when loading 'svint32_t' expects a vector of 32-bit integers} } */\n+  svld1_gather_offset (pg, s32_ptr, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svld1_gather_offset', which when loading 'svint32_t' expects a vector of 32-bit integers} } */\n+\n+  svld1_gather_offset (pg, u32_ptr, s32);\n+  svld1_gather_offset (pg, u32_ptr, u32);\n+  svld1_gather_offset (pg, u32_ptr, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svld1_gather_offset', which when loading 'svuint32_t' expects a vector of 32-bit integers} } */\n+  svld1_gather_offset (pg, u32_ptr, s64); /* { dg-error {passing 'svint64_t' to argument 3 of 'svld1_gather_offset', which when loading 'svuint32_t' expects a vector of 32-bit integers} } */\n+  svld1_gather_offset (pg, u32_ptr, u64); /* { dg-error {passing 'svuint64_t' to argument 3 of 'svld1_gather_offset', which when loading 'svuint32_t' expects a vector of 32-bit integers} } */\n+  svld1_gather_offset (pg, u32_ptr, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svld1_gather_offset', which when loading 'svuint32_t' expects a vector of 32-bit integers} } */\n+\n+  svld1_gather_offset (pg, f32_ptr, s32);\n+  svld1_gather_offset (pg, f32_ptr, u32);\n+  svld1_gather_offset (pg, f32_ptr, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svld1_gather_offset', which when loading 'svfloat32_t' expects a vector of 32-bit integers} } */\n+  svld1_gather_offset (pg, f32_ptr, s64); /* { dg-error {passing 'svint64_t' to argument 3 of 'svld1_gather_offset', which when loading 'svfloat32_t' expects a vector of 32-bit integers} } */\n+  svld1_gather_offset (pg, f32_ptr, u64); /* { dg-error {passing 'svuint64_t' to argument 3 of 'svld1_gather_offset', which when loading 'svfloat32_t' expects a vector of 32-bit integers} } */\n+  svld1_gather_offset (pg, f32_ptr, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svld1_gather_offset', which when loading 'svfloat32_t' expects a vector of 32-bit integers} } */\n+\n+  svld1_gather_offset (pg, s64_ptr, s32); /* { dg-error {passing 'svint32_t' to argument 3 of 'svld1_gather_offset', which when loading 'svint64_t' expects a vector of 64-bit integers} } */\n+  svld1_gather_offset (pg, s64_ptr, u32); /* { dg-error {passing 'svuint32_t' to argument 3 of 'svld1_gather_offset', which when loading 'svint64_t' expects a vector of 64-bit integers} } */\n+  svld1_gather_offset (pg, s64_ptr, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svld1_gather_offset', which when loading 'svint64_t' expects a vector of 64-bit integers} } */\n+  svld1_gather_offset (pg, s64_ptr, s64);\n+  svld1_gather_offset (pg, s64_ptr, u64);\n+  svld1_gather_offset (pg, s64_ptr, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svld1_gather_offset', which when loading 'svint64_t' expects a vector of 64-bit integers} } */\n+\n+  svld1_gather_offset (pg, u64_ptr, s32); /* { dg-error {passing 'svint32_t' to argument 3 of 'svld1_gather_offset', which when loading 'svuint64_t' expects a vector of 64-bit integers} } */\n+  svld1_gather_offset (pg, u64_ptr, u32); /* { dg-error {passing 'svuint32_t' to argument 3 of 'svld1_gather_offset', which when loading 'svuint64_t' expects a vector of 64-bit integers} } */\n+  svld1_gather_offset (pg, u64_ptr, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svld1_gather_offset', which when loading 'svuint64_t' expects a vector of 64-bit integers} } */\n+  svld1_gather_offset (pg, u64_ptr, s64);\n+  svld1_gather_offset (pg, u64_ptr, u64);\n+  svld1_gather_offset (pg, u64_ptr, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svld1_gather_offset', which when loading 'svuint64_t' expects a vector of 64-bit integers} } */\n+\n+  svld1_gather_offset (pg, f64_ptr, s32); /* { dg-error {passing 'svint32_t' to argument 3 of 'svld1_gather_offset', which when loading 'svfloat64_t' expects a vector of 64-bit integers} } */\n+  svld1_gather_offset (pg, f64_ptr, u32); /* { dg-error {passing 'svuint32_t' to argument 3 of 'svld1_gather_offset', which when loading 'svfloat64_t' expects a vector of 64-bit integers} } */\n+  svld1_gather_offset (pg, f64_ptr, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svld1_gather_offset', which when loading 'svfloat64_t' expects a vector of 64-bit integers} } */\n+  svld1_gather_offset (pg, f64_ptr, s64);\n+  svld1_gather_offset (pg, f64_ptr, u64);\n+  svld1_gather_offset (pg, f64_ptr, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svld1_gather_offset', which when loading 'svfloat64_t' expects a vector of 64-bit integers} } */\n+\n+  return svld1_gather_offset (pg, s32_ptr, s32); /* { dg-error {incompatible types when returning type 'svint32_t' but 'svuint32_t' was expected} } */\n+}"}, {"sha": "4c15fc40c1095b1b914ede4c1cc40be9f60cfec1", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/load_gather_sv_2.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_gather_sv_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_gather_sv_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_gather_sv_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { signed char x; };\n+\n+svuint32_t\n+f1 (svbool_t pg, signed char *s8_ptr, short *s16_ptr,\n+    int32_t *s32_ptr, uint32_t *u32_ptr, float *f32_ptr,\n+    int64_t *s64_ptr, uint64_t *u64_ptr, double *f64_ptr,\n+    void *void_ptr, struct s *s_ptr, _Complex float *cf32_ptr, int **ptr_ptr,\n+    svint8_t s8, svint16_t s16,\n+    svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64, svfloat64_t f64)\n+{\n+  svld1_gather_index (pg, s32_ptr); /* { dg-error {too few arguments to function 'svld1_gather_index'} } */\n+  svld1_gather_index (pg, s32_ptr, s32, 0); /* { dg-error {too many arguments to function 'svld1_gather_index'} } */\n+  svld1_gather_index (0, s32_ptr, s32); /* { dg-error {passing 'int' to argument 1 of 'svld1_gather_index', which expects 'svbool_t'} } */\n+  svld1_gather_index (pg, 0, s32); /* { dg-error {passing 'int' to argument 2 of 'svld1_gather_index', which expects a pointer type} } */\n+  svld1_gather_index (pg, (int *) 0, s32);\n+  svld1_gather_index (pg, void_ptr, s32); /* { dg-error {passing 'void \\*' to argument 2 of 'svld1_gather_index', but 'void' is not a valid SVE element type} } */\n+  svld1_gather_index (pg, s_ptr, s32); /* { dg-error {passing 'struct s \\*' to argument 2 of 'svld1_gather_index', but 'struct s' is not a valid SVE element type} } */\n+  svld1_gather_index (pg, f32_ptr, s32);\n+  svld1_gather_index (pg, cf32_ptr, s32); /* { dg-error {passing '_Complex float \\*' to argument 2 of 'svld1_gather_index', but 'complex float' is not a valid SVE element type} } */\n+  svld1_gather_index (pg, ptr_ptr, u64); /* { dg-error {passing 'int \\*\\*' to argument 2 of 'svld1_gather_index', but 'int \\*' is not a valid SVE element type} } */\n+  svld1_gather_index (pg, u32, 0); /* { dg-error {passing 'svuint32_t' to argument 2 of 'svld1_gather_index', which expects a pointer type} } */\n+  /* { dg-message {an explicit type suffix is needed when using a vector of base addresses} \"\" { target *-*-* } .-1 } */\n+  svld1_gather_index (pg, u64, 0); /* { dg-error {passing 'svuint64_t' to argument 2 of 'svld1_gather_index', which expects a pointer type} } */\n+  /* { dg-message {an explicit type suffix is needed when using a vector of base addresses} \"\" { target *-*-* } .-1 } */\n+\n+  svld1_gather_index (pg, s8_ptr, s8); /* { dg-error {passing 'signed char \\*' to argument 2 of 'svld1_gather_index', which expects a pointer to 32-bit or 64-bit elements} } */\n+  svld1_gather_index (pg, s8_ptr, s32); /* { dg-error {passing 'signed char \\*' to argument 2 of 'svld1_gather_index', which expects a pointer to 32-bit or 64-bit elements} } */\n+  svld1_gather_index (pg, s16_ptr, s16); /* { dg-error {passing 'short( int)? \\*' to argument 2 of 'svld1_gather_index', which expects a pointer to 32-bit or 64-bit elements} } */\n+  svld1_gather_index (pg, s16_ptr, s32); /* { dg-error {passing 'short( int)? \\*' to argument 2 of 'svld1_gather_index', which expects a pointer to 32-bit or 64-bit elements} } */\n+\n+  svld1_gather_index (pg, s32_ptr, s32);\n+  svld1_gather_index (pg, s32_ptr, u32);\n+  svld1_gather_index (pg, s32_ptr, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svld1_gather_index', which when loading 'svint32_t' expects a vector of 32-bit integers} } */\n+  svld1_gather_index (pg, s32_ptr, s64); /* { dg-error {passing 'svint64_t' to argument 3 of 'svld1_gather_index', which when loading 'svint32_t' expects a vector of 32-bit integers} } */\n+  svld1_gather_index (pg, s32_ptr, u64); /* { dg-error {passing 'svuint64_t' to argument 3 of 'svld1_gather_index', which when loading 'svint32_t' expects a vector of 32-bit integers} } */\n+  svld1_gather_index (pg, s32_ptr, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svld1_gather_index', which when loading 'svint32_t' expects a vector of 32-bit integers} } */\n+\n+  svld1_gather_index (pg, u32_ptr, s32);\n+  svld1_gather_index (pg, u32_ptr, u32);\n+  svld1_gather_index (pg, u32_ptr, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svld1_gather_index', which when loading 'svuint32_t' expects a vector of 32-bit integers} } */\n+  svld1_gather_index (pg, u32_ptr, s64); /* { dg-error {passing 'svint64_t' to argument 3 of 'svld1_gather_index', which when loading 'svuint32_t' expects a vector of 32-bit integers} } */\n+  svld1_gather_index (pg, u32_ptr, u64); /* { dg-error {passing 'svuint64_t' to argument 3 of 'svld1_gather_index', which when loading 'svuint32_t' expects a vector of 32-bit integers} } */\n+  svld1_gather_index (pg, u32_ptr, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svld1_gather_index', which when loading 'svuint32_t' expects a vector of 32-bit integers} } */\n+\n+  svld1_gather_index (pg, f32_ptr, s32);\n+  svld1_gather_index (pg, f32_ptr, u32);\n+  svld1_gather_index (pg, f32_ptr, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svld1_gather_index', which when loading 'svfloat32_t' expects a vector of 32-bit integers} } */\n+  svld1_gather_index (pg, f32_ptr, s64); /* { dg-error {passing 'svint64_t' to argument 3 of 'svld1_gather_index', which when loading 'svfloat32_t' expects a vector of 32-bit integers} } */\n+  svld1_gather_index (pg, f32_ptr, u64); /* { dg-error {passing 'svuint64_t' to argument 3 of 'svld1_gather_index', which when loading 'svfloat32_t' expects a vector of 32-bit integers} } */\n+  svld1_gather_index (pg, f32_ptr, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svld1_gather_index', which when loading 'svfloat32_t' expects a vector of 32-bit integers} } */\n+\n+  svld1_gather_index (pg, s64_ptr, s32); /* { dg-error {passing 'svint32_t' to argument 3 of 'svld1_gather_index', which when loading 'svint64_t' expects a vector of 64-bit integers} } */\n+  svld1_gather_index (pg, s64_ptr, u32); /* { dg-error {passing 'svuint32_t' to argument 3 of 'svld1_gather_index', which when loading 'svint64_t' expects a vector of 64-bit integers} } */\n+  svld1_gather_index (pg, s64_ptr, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svld1_gather_index', which when loading 'svint64_t' expects a vector of 64-bit integers} } */\n+  svld1_gather_index (pg, s64_ptr, s64);\n+  svld1_gather_index (pg, s64_ptr, u64);\n+  svld1_gather_index (pg, s64_ptr, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svld1_gather_index', which when loading 'svint64_t' expects a vector of 64-bit integers} } */\n+\n+  svld1_gather_index (pg, u64_ptr, s32); /* { dg-error {passing 'svint32_t' to argument 3 of 'svld1_gather_index', which when loading 'svuint64_t' expects a vector of 64-bit integers} } */\n+  svld1_gather_index (pg, u64_ptr, u32); /* { dg-error {passing 'svuint32_t' to argument 3 of 'svld1_gather_index', which when loading 'svuint64_t' expects a vector of 64-bit integers} } */\n+  svld1_gather_index (pg, u64_ptr, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svld1_gather_index', which when loading 'svuint64_t' expects a vector of 64-bit integers} } */\n+  svld1_gather_index (pg, u64_ptr, s64);\n+  svld1_gather_index (pg, u64_ptr, u64);\n+  svld1_gather_index (pg, u64_ptr, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svld1_gather_index', which when loading 'svuint64_t' expects a vector of 64-bit integers} } */\n+\n+  svld1_gather_index (pg, f64_ptr, s32); /* { dg-error {passing 'svint32_t' to argument 3 of 'svld1_gather_index', which when loading 'svfloat64_t' expects a vector of 64-bit integers} } */\n+  svld1_gather_index (pg, f64_ptr, u32); /* { dg-error {passing 'svuint32_t' to argument 3 of 'svld1_gather_index', which when loading 'svfloat64_t' expects a vector of 64-bit integers} } */\n+  svld1_gather_index (pg, f64_ptr, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svld1_gather_index', which when loading 'svfloat64_t' expects a vector of 64-bit integers} } */\n+  svld1_gather_index (pg, f64_ptr, s64);\n+  svld1_gather_index (pg, f64_ptr, u64);\n+  svld1_gather_index (pg, f64_ptr, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svld1_gather_index', which when loading 'svfloat64_t' expects a vector of 64-bit integers} } */\n+\n+  return svld1_gather_index (pg, s32_ptr, s32); /* { dg-error {incompatible types when returning type 'svint32_t' but 'svuint32_t' was expected} } */\n+}"}, {"sha": "d4ff76ea87175ee1bba64c81e2580286ca5b6568", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/load_replicate_1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_replicate_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_replicate_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fload_replicate_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { signed char x; };\n+\n+svuint8_t\n+f1 (svbool_t pg, signed char *s8_ptr, void *void_ptr, struct s *s_ptr,\n+    float *f32_ptr, _Complex float *cf32_ptr, int **ptr_ptr)\n+{\n+  svld1rq (pg); /* { dg-error {too few arguments to function 'svld1rq'} } */\n+  svld1rq (pg, s8_ptr, 0); /* { dg-error {too many arguments to function 'svld1rq'} } */\n+  svld1rq (0, s8_ptr); /* { dg-error {passing 'int' to argument 1 of 'svld1rq', which expects 'svbool_t'} } */\n+  svld1rq (pg, 0); /* { dg-error {passing 'int' to argument 2 of 'svld1rq', which expects a pointer type} } */\n+  svld1rq (pg, (int *) 0);\n+  svld1rq (pg, void_ptr); /* { dg-error {passing 'void \\*' to argument 2 of 'svld1rq', but 'void' is not a valid SVE element type} } */\n+  svld1rq (pg, s_ptr); /* { dg-error {passing 'struct s \\*' to argument 2 of 'svld1rq', but 'struct s' is not a valid SVE element type} } */\n+  svld1rq (pg, f32_ptr);\n+  svld1rq (pg, cf32_ptr); /* { dg-error {passing '_Complex float \\*' to argument 2 of 'svld1rq', but 'complex float' is not a valid SVE element type} } */\n+  svld1rq (pg, ptr_ptr); /* { dg-error {passing 'int \\*\\*' to argument 2 of 'svld1rq', but 'int \\*' is not a valid SVE element type} } */\n+  return svld1rq (pg, s8_ptr); /* { dg-error {incompatible types when returning type 'svint8_t' but 'svuint8_t' was expected} } */\n+}"}, {"sha": "99b61bdf10440f833df30592f321b62541bec1d1", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/pattern_pred_1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fpattern_pred_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fpattern_pred_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fpattern_pred_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,14 @@\n+#include <arm_sve.h>\n+\n+void\n+test ()\n+{\n+  svptrue_pat_b16 ((enum svpattern) -1); /* { dg-error {passing 4294967295 to argument 1 of 'svptrue_pat_b16', which expects a valid 'enum svpattern' value} } */\n+  svptrue_pat_b16 ((enum svpattern) 0);\n+  svptrue_pat_b16 ((enum svpattern) 13);\n+  svptrue_pat_b16 ((enum svpattern) 14); /* { dg-error {passing 14 to argument 1 of 'svptrue_pat_b16', which expects a valid 'enum svpattern' value} } */\n+  svptrue_pat_b16 ((enum svpattern) 28); /* { dg-error {passing 28 to argument 1 of 'svptrue_pat_b16', which expects a valid 'enum svpattern' value} } */\n+  svptrue_pat_b16 ((enum svpattern) 29);\n+  svptrue_pat_b16 ((enum svpattern) 31);\n+  svptrue_pat_b16 ((enum svpattern) 32); /* { dg-error {passing 32 to argument 1 of 'svptrue_pat_b16', which expects a valid 'enum svpattern' value} } */\n+}"}, {"sha": "316f77fc77528049a0c641b000c0f1fd3cc63d72", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/prefetch_1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, int32_t *s32_ptr, enum svprfop op)\n+{\n+  svprfb (pg, s32_ptr, op); /* { dg-error {argument 3 of 'svprfb' must be an integer constant expression} } */\n+  svprfb (pg, s32_ptr, (enum svprfop) -1); /* { dg-error {passing 4294967295 to argument 3 of 'svprfb', which expects a valid 'enum svprfop' value} } */\n+  svprfb (pg, s32_ptr, (enum svprfop) 0);\n+  svprfb (pg, s32_ptr, (enum svprfop) 5);\n+  svprfb (pg, s32_ptr, (enum svprfop) 6); /* { dg-error {passing 6 to argument 3 of 'svprfb', which expects a valid 'enum svprfop' value} } */\n+  svprfb (pg, s32_ptr, (enum svprfop) 7); /* { dg-error {passing 7 to argument 3 of 'svprfb', which expects a valid 'enum svprfop' value} } */\n+  svprfb (pg, s32_ptr, (enum svprfop) 8);\n+  svprfb (pg, s32_ptr, (enum svprfop) 14); /* { dg-error {passing 14 to argument 3 of 'svprfb', which expects a valid 'enum svprfop' value} } */\n+}"}, {"sha": "c33c95440ae90fc8573db2f1824aa10317208fae", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/prefetch_gather_index_1.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_gather_index_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_gather_index_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_gather_index_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { int i; };\n+\n+void\n+f1 (svbool_t pg, int32_t *s32_ptr, void *void_ptr, void **ptr_ptr,\n+    svint8_t s8, svuint8_t u8, svint16_t s16, svuint16_t u16, svfloat16_t f16,\n+    svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64, svfloat64_t f64, enum svprfop op,\n+    struct s s)\n+{\n+  svprfh_gather_index (pg, s32_ptr, s32); /* { dg-error {too few arguments to function 'svprfh_gather_index'} } */\n+  svprfh_gather_index (pg, s32_ptr, s32, SV_PLDL1KEEP, 0); /* { dg-error {too many arguments to function 'svprfh_gather_index'} } */\n+  svprfh_gather_index (0, s32_ptr, s32, SV_PLDL1KEEP); /* { dg-error {passing 'int' to argument 1 of 'svprfh_gather_index', which expects 'svbool_t'} } */\n+  svprfh_gather_index (pg, 0, s32, SV_PLDL1KEEP);\n+  svprfh_gather_index (pg, (int *) 0, s32, SV_PLDL1KEEP);\n+  svprfh_gather_index (pg, void_ptr, s32, SV_PLDL1KEEP);\n+  svprfh_gather_index (pg, ptr_ptr, s32, SV_PLDL1KEEP);\n+  svprfh_gather_index (pg, s, s32, SV_PLDL1KEEP); /* { dg-error {passing 'struct s' to argument 2 of 'svprfh_gather_index', which expects a vector or pointer base address} } */\n+\n+  svprfh_gather_index (pg, s32_ptr, s8, SV_PLDL1KEEP); /* { dg-error {passing 'svint8_t' to argument 3 of 'svprfh_gather_index', which expects a vector of 32-bit or 64-bit integers} } */\n+  svprfh_gather_index (pg, s32_ptr, u8, SV_PLDL1KEEP); /* { dg-error {passing 'svuint8_t' to argument 3 of 'svprfh_gather_index', which expects a vector of 32-bit or 64-bit integers} } */\n+  svprfh_gather_index (pg, s32_ptr, s16, SV_PLDL1KEEP); /* { dg-error {passing 'svint16_t' to argument 3 of 'svprfh_gather_index', which expects a vector of 32-bit or 64-bit integers} } */\n+  svprfh_gather_index (pg, s32_ptr, u16, SV_PLDL1KEEP); /* { dg-error {passing 'svuint16_t' to argument 3 of 'svprfh_gather_index', which expects a vector of 32-bit or 64-bit integers} } */\n+  svprfh_gather_index (pg, s32_ptr, f16, SV_PLDL1KEEP); /* { dg-error {passing 'svfloat16_t' to argument 3 of 'svprfh_gather_index', which expects a vector of integers} } */\n+  svprfh_gather_index (pg, s32_ptr, s32, SV_PLDL1KEEP);\n+  svprfh_gather_index (pg, s32_ptr, u32, SV_PLDL1KEEP);\n+  svprfh_gather_index (pg, s32_ptr, f32, SV_PLDL1KEEP); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svprfh_gather_index', which expects a vector of integers} } */\n+  svprfh_gather_index (pg, s32_ptr, s64, SV_PLDL1KEEP);\n+  svprfh_gather_index (pg, s32_ptr, u64, SV_PLDL1KEEP);\n+  svprfh_gather_index (pg, s32_ptr, f64, SV_PLDL1KEEP); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svprfh_gather_index', which expects a vector of integers} } */\n+\n+  svprfh_gather_index (pg, u8, 0, SV_PLDL1KEEP); /* { dg-error {passing 'svuint8_t' to argument 2 of 'svprfh_gather_index', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svprfh_gather_index (pg, u16, 0, SV_PLDL1KEEP); /* { dg-error {passing 'svuint16_t' to argument 2 of 'svprfh_gather_index', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svprfh_gather_index (pg, s32, 0, SV_PLDL1KEEP); /* { dg-error {passing 'svint32_t' to argument 2 of 'svprfh_gather_index', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svprfh_gather_index (pg, u32, 0, SV_PLDL1KEEP);\n+  svprfh_gather_index (pg, f32, 0, SV_PLDL1KEEP); /* { dg-error {passing 'svfloat32_t' to argument 2 of 'svprfh_gather_index', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svprfh_gather_index (pg, s64, 0, SV_PLDL1KEEP); /* { dg-error {passing 'svint64_t' to argument 2 of 'svprfh_gather_index', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svprfh_gather_index (pg, u64, 0, SV_PLDL1KEEP);\n+  svprfh_gather_index (pg, f64, 0, SV_PLDL1KEEP); /* { dg-error {passing 'svfloat64_t' to argument 2 of 'svprfh_gather_index', which expects 'svuint32_t' or 'svuint64_t'} } */\n+\n+  svprfh_gather_index (pg, s32_ptr, s32, op); /* { dg-error {argument 4 of 'svprfh_gather_index' must be an integer constant expression} } */\n+  svprfh_gather_index (pg, s32_ptr, s32, (enum svprfop) -1); /* { dg-error {passing 4294967295 to argument 4 of 'svprfh_gather_index', which expects a valid 'enum svprfop' value} } */\n+  svprfh_gather_index (pg, s32_ptr, s32, (enum svprfop) 0);\n+  svprfh_gather_index (pg, s32_ptr, s32, (enum svprfop) 5);\n+  svprfh_gather_index (pg, s32_ptr, s32, (enum svprfop) 6); /* { dg-error {passing 6 to argument 4 of 'svprfh_gather_index', which expects a valid 'enum svprfop' value} } */\n+  svprfh_gather_index (pg, s32_ptr, s32, (enum svprfop) 7); /* { dg-error {passing 7 to argument 4 of 'svprfh_gather_index', which expects a valid 'enum svprfop' value} } */\n+  svprfh_gather_index (pg, s32_ptr, s32, (enum svprfop) 8);\n+  svprfh_gather_index (pg, s32_ptr, s32, (enum svprfop) 14); /* { dg-error {passing 14 to argument 4 of 'svprfh_gather_index', which expects a valid 'enum svprfop' value} } */\n+}"}, {"sha": "3d77973059e09f0a1a95015d55b5bf2a579e0454", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/prefetch_gather_index_2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_gather_index_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_gather_index_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_gather_index_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, int32_t *s32_ptr, svint32_t s32, enum svprfop op)\n+{\n+  svprfh_gather_s32index (pg, s32_ptr, s32, op); /* { dg-error {argument 4 of 'svprfh_gather_s32index' must be an integer constant expression} } */\n+  svprfh_gather_s32index (pg, s32_ptr, s32, (enum svprfop) -1); /* { dg-error {passing 4294967295 to argument 4 of 'svprfh_gather_s32index', which expects a valid 'enum svprfop' value} } */\n+  svprfh_gather_s32index (pg, s32_ptr, s32, (enum svprfop) 0);\n+  svprfh_gather_s32index (pg, s32_ptr, s32, (enum svprfop) 5);\n+  svprfh_gather_s32index (pg, s32_ptr, s32, (enum svprfop) 6); /* { dg-error {passing 6 to argument 4 of 'svprfh_gather_s32index', which expects a valid 'enum svprfop' value} } */\n+  svprfh_gather_s32index (pg, s32_ptr, s32, (enum svprfop) 7); /* { dg-error {passing 7 to argument 4 of 'svprfh_gather_s32index', which expects a valid 'enum svprfop' value} } */\n+  svprfh_gather_s32index (pg, s32_ptr, s32, (enum svprfop) 8);\n+  svprfh_gather_s32index (pg, s32_ptr, s32, (enum svprfop) 14); /* { dg-error {passing 14 to argument 4 of 'svprfh_gather_s32index', which expects a valid 'enum svprfop' value} } */\n+}"}, {"sha": "cc61901cb0e5f2a3182506aba4d76b668a10ff76", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/prefetch_gather_offset_1.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_gather_offset_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_gather_offset_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_gather_offset_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { int i; };\n+\n+void\n+f1 (svbool_t pg, int32_t *s32_ptr, void *void_ptr, void **ptr_ptr,\n+    svint8_t s8, svuint8_t u8, svint16_t s16, svuint16_t u16, svfloat16_t f16,\n+    svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64, svfloat64_t f64, enum svprfop op,\n+    struct s s)\n+{\n+  svprfb_gather_offset (pg, s32_ptr, s32); /* { dg-error {too few arguments to function 'svprfb_gather_offset'} } */\n+  svprfb_gather_offset (pg, s32_ptr, s32, SV_PLDL1KEEP, 0); /* { dg-error {too many arguments to function 'svprfb_gather_offset'} } */\n+  svprfb_gather_offset (0, s32_ptr, s32, SV_PLDL1KEEP); /* { dg-error {passing 'int' to argument 1 of 'svprfb_gather_offset', which expects 'svbool_t'} } */\n+  svprfb_gather_offset (pg, 0, s32, SV_PLDL1KEEP);\n+  svprfb_gather_offset (pg, (int *) 0, s32, SV_PLDL1KEEP);\n+  svprfb_gather_offset (pg, void_ptr, s32, SV_PLDL1KEEP);\n+  svprfb_gather_offset (pg, ptr_ptr, s32, SV_PLDL1KEEP);\n+  svprfb_gather_offset (pg, s, s32, SV_PLDL1KEEP); /* { dg-error {passing 'struct s' to argument 2 of 'svprfb_gather_offset', which expects a vector or pointer base address} } */\n+\n+  svprfb_gather_offset (pg, s32_ptr, s8, SV_PLDL1KEEP); /* { dg-error {passing 'svint8_t' to argument 3 of 'svprfb_gather_offset', which expects a vector of 32-bit or 64-bit integers} } */\n+  svprfb_gather_offset (pg, s32_ptr, u8, SV_PLDL1KEEP); /* { dg-error {passing 'svuint8_t' to argument 3 of 'svprfb_gather_offset', which expects a vector of 32-bit or 64-bit integers} } */\n+  svprfb_gather_offset (pg, s32_ptr, s16, SV_PLDL1KEEP); /* { dg-error {passing 'svint16_t' to argument 3 of 'svprfb_gather_offset', which expects a vector of 32-bit or 64-bit integers} } */\n+  svprfb_gather_offset (pg, s32_ptr, u16, SV_PLDL1KEEP); /* { dg-error {passing 'svuint16_t' to argument 3 of 'svprfb_gather_offset', which expects a vector of 32-bit or 64-bit integers} } */\n+  svprfb_gather_offset (pg, s32_ptr, f16, SV_PLDL1KEEP); /* { dg-error {passing 'svfloat16_t' to argument 3 of 'svprfb_gather_offset', which expects a vector of integers} } */\n+  svprfb_gather_offset (pg, s32_ptr, s32, SV_PLDL1KEEP);\n+  svprfb_gather_offset (pg, s32_ptr, u32, SV_PLDL1KEEP);\n+  svprfb_gather_offset (pg, s32_ptr, f32, SV_PLDL1KEEP); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svprfb_gather_offset', which expects a vector of integers} } */\n+  svprfb_gather_offset (pg, s32_ptr, s64, SV_PLDL1KEEP);\n+  svprfb_gather_offset (pg, s32_ptr, u64, SV_PLDL1KEEP);\n+  svprfb_gather_offset (pg, s32_ptr, f64, SV_PLDL1KEEP); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svprfb_gather_offset', which expects a vector of integers} } */\n+\n+  svprfb_gather_offset (pg, u8, 0, SV_PLDL1KEEP); /* { dg-error {passing 'svuint8_t' to argument 2 of 'svprfb_gather_offset', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svprfb_gather_offset (pg, u16, 0, SV_PLDL1KEEP); /* { dg-error {passing 'svuint16_t' to argument 2 of 'svprfb_gather_offset', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svprfb_gather_offset (pg, s32, 0, SV_PLDL1KEEP); /* { dg-error {passing 'svint32_t' to argument 2 of 'svprfb_gather_offset', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svprfb_gather_offset (pg, u32, 0, SV_PLDL1KEEP);\n+  svprfb_gather_offset (pg, f32, 0, SV_PLDL1KEEP); /* { dg-error {passing 'svfloat32_t' to argument 2 of 'svprfb_gather_offset', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svprfb_gather_offset (pg, s64, 0, SV_PLDL1KEEP); /* { dg-error {passing 'svint64_t' to argument 2 of 'svprfb_gather_offset', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svprfb_gather_offset (pg, u64, 0, SV_PLDL1KEEP);\n+  svprfb_gather_offset (pg, f64, 0, SV_PLDL1KEEP); /* { dg-error {passing 'svfloat64_t' to argument 2 of 'svprfb_gather_offset', which expects 'svuint32_t' or 'svuint64_t'} } */\n+\n+  svprfb_gather_offset (pg, s32_ptr, s32, op); /* { dg-error {argument 4 of 'svprfb_gather_offset' must be an integer constant expression} } */\n+  svprfb_gather_offset (pg, s32_ptr, s32, (enum svprfop) -1); /* { dg-error {passing 4294967295 to argument 4 of 'svprfb_gather_offset', which expects a valid 'enum svprfop' value} } */\n+  svprfb_gather_offset (pg, s32_ptr, s32, (enum svprfop) 0);\n+  svprfb_gather_offset (pg, s32_ptr, s32, (enum svprfop) 5);\n+  svprfb_gather_offset (pg, s32_ptr, s32, (enum svprfop) 6); /* { dg-error {passing 6 to argument 4 of 'svprfb_gather_offset', which expects a valid 'enum svprfop' value} } */\n+  svprfb_gather_offset (pg, s32_ptr, s32, (enum svprfop) 7); /* { dg-error {passing 7 to argument 4 of 'svprfb_gather_offset', which expects a valid 'enum svprfop' value} } */\n+  svprfb_gather_offset (pg, s32_ptr, s32, (enum svprfop) 8);\n+  svprfb_gather_offset (pg, s32_ptr, s32, (enum svprfop) 14); /* { dg-error {passing 14 to argument 4 of 'svprfb_gather_offset', which expects a valid 'enum svprfop' value} } */\n+}"}, {"sha": "b74721fadceb0133f37bea7523b74acfe8642d7a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/prefetch_gather_offset_2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_gather_offset_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_gather_offset_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_gather_offset_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svint8_t s8, svuint8_t u8,\n+    svint16_t s16, svuint16_t u16, svfloat16_t f16,\n+    svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64, svfloat64_t f64, enum svprfop op)\n+{\n+  svprfb_gather (pg, u32); /* { dg-error {too few arguments to function 'svprfb_gather'} } */\n+  svprfb_gather (pg, u32, SV_PLDL1KEEP, 0); /* { dg-error {too many arguments to function 'svprfb_gather'} } */\n+  svprfb_gather (0, u32, SV_PLDL1KEEP); /* { dg-error {passing 'int' to argument 1 of 'svprfb_gather', which expects 'svbool_t'} } */\n+  svprfb_gather (pg, 0, SV_PLDL1KEEP); /* { dg-error {passing 'int' to argument 2 of 'svprfb_gather', which expects an SVE vector type} } */\n+\n+  svprfb_gather (pg, s8, SV_PLDL1KEEP); /* { dg-error {passing 'svint8_t' to argument 2 of 'svprfb_gather', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svprfb_gather (pg, u8, SV_PLDL1KEEP); /* { dg-error {passing 'svuint8_t' to argument 2 of 'svprfb_gather', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svprfb_gather (pg, s16, SV_PLDL1KEEP); /* { dg-error {passing 'svint16_t' to argument 2 of 'svprfb_gather', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svprfb_gather (pg, u16, SV_PLDL1KEEP); /* { dg-error {passing 'svuint16_t' to argument 2 of 'svprfb_gather', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svprfb_gather (pg, f16, SV_PLDL1KEEP); /* { dg-error {passing 'svfloat16_t' to argument 2 of 'svprfb_gather', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svprfb_gather (pg, s32, SV_PLDL1KEEP); /* { dg-error {passing 'svint32_t' to argument 2 of 'svprfb_gather', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svprfb_gather (pg, u32, SV_PLDL1KEEP);\n+  svprfb_gather (pg, f32, SV_PLDL1KEEP); /* { dg-error {passing 'svfloat32_t' to argument 2 of 'svprfb_gather', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svprfb_gather (pg, s64, SV_PLDL1KEEP); /* { dg-error {passing 'svint64_t' to argument 2 of 'svprfb_gather', which expects 'svuint32_t' or 'svuint64_t'} } */\n+  svprfb_gather (pg, u64, SV_PLDL1KEEP);\n+  svprfb_gather (pg, f64, SV_PLDL1KEEP); /* { dg-error {passing 'svfloat64_t' to argument 2 of 'svprfb_gather', which expects 'svuint32_t' or 'svuint64_t'} } */\n+\n+  svprfb_gather (pg, u32, op); /* { dg-error {argument 3 of 'svprfb_gather' must be an integer constant expression} } */\n+  svprfb_gather (pg, u32, (enum svprfop) -1); /* { dg-error {passing 4294967295 to argument 3 of 'svprfb_gather', which expects a valid 'enum svprfop' value} } */\n+  svprfb_gather (pg, u32, (enum svprfop) 0);\n+  svprfb_gather (pg, u32, (enum svprfop) 5);\n+  svprfb_gather (pg, u32, (enum svprfop) 6); /* { dg-error {passing 6 to argument 3 of 'svprfb_gather', which expects a valid 'enum svprfop' value} } */\n+  svprfb_gather (pg, u32, (enum svprfop) 7); /* { dg-error {passing 7 to argument 3 of 'svprfb_gather', which expects a valid 'enum svprfop' value} } */\n+  svprfb_gather (pg, u32, (enum svprfop) 8);\n+  svprfb_gather (pg, u32, (enum svprfop) 14); /* { dg-error {passing 14 to argument 3 of 'svprfb_gather', which expects a valid 'enum svprfop' value} } */\n+}"}, {"sha": "24b4aa190022e20ceb2f3368ece40fccc1e4e35d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/prefetch_gather_offset_3.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_gather_offset_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_gather_offset_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_gather_offset_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, int32_t *s32_ptr, svint32_t s32, enum svprfop op)\n+{\n+  svprfb_gather_s32offset (pg, s32_ptr, s32, op); /* { dg-error {argument 4 of 'svprfb_gather_s32offset' must be an integer constant expression} } */\n+  svprfb_gather_s32offset (pg, s32_ptr, s32, (enum svprfop) -1); /* { dg-error {passing 4294967295 to argument 4 of 'svprfb_gather_s32offset', which expects a valid 'enum svprfop' value} } */\n+  svprfb_gather_s32offset (pg, s32_ptr, s32, (enum svprfop) 0);\n+  svprfb_gather_s32offset (pg, s32_ptr, s32, (enum svprfop) 5);\n+  svprfb_gather_s32offset (pg, s32_ptr, s32, (enum svprfop) 6); /* { dg-error {passing 6 to argument 4 of 'svprfb_gather_s32offset', which expects a valid 'enum svprfop' value} } */\n+  svprfb_gather_s32offset (pg, s32_ptr, s32, (enum svprfop) 7); /* { dg-error {passing 7 to argument 4 of 'svprfb_gather_s32offset', which expects a valid 'enum svprfop' value} } */\n+  svprfb_gather_s32offset (pg, s32_ptr, s32, (enum svprfop) 8);\n+  svprfb_gather_s32offset (pg, s32_ptr, s32, (enum svprfop) 14); /* { dg-error {passing 14 to argument 4 of 'svprfb_gather_s32offset', which expects a valid 'enum svprfop' value} } */\n+}"}, {"sha": "63ccdc5a44932edf0a29b954ba5f06ef9b2a9eb4", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/prefetch_gather_offset_4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_gather_offset_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_gather_offset_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fprefetch_gather_offset_4.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svuint32_t u32, enum svprfop op)\n+{\n+  svprfb_gather_u32base (pg, u32, op); /* { dg-error {argument 3 of 'svprfb_gather_u32base' must be an integer constant expression} } */\n+  svprfb_gather_u32base (pg, u32, (enum svprfop) -1); /* { dg-error {passing 4294967295 to argument 3 of 'svprfb_gather_u32base', which expects a valid 'enum svprfop' value} } */\n+  svprfb_gather_u32base (pg, u32, (enum svprfop) 0);\n+  svprfb_gather_u32base (pg, u32, (enum svprfop) 5);\n+  svprfb_gather_u32base (pg, u32, (enum svprfop) 6); /* { dg-error {passing 6 to argument 3 of 'svprfb_gather_u32base', which expects a valid 'enum svprfop' value} } */\n+  svprfb_gather_u32base (pg, u32, (enum svprfop) 7); /* { dg-error {passing 7 to argument 3 of 'svprfb_gather_u32base', which expects a valid 'enum svprfop' value} } */\n+  svprfb_gather_u32base (pg, u32, (enum svprfop) 8);\n+  svprfb_gather_u32base (pg, u32, (enum svprfop) 14); /* { dg-error {passing 14 to argument 3 of 'svprfb_gather_u32base', which expects a valid 'enum svprfop' value} } */\n+}"}, {"sha": "ab0ef304a31385c0ba533bc0ef9eccab78071792", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/reduction_1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Freduction_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Freduction_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Freduction_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svuint32x2_t u32x2)\n+{\n+  svorv (pg); /* { dg-error {too few arguments to function 'svorv'} } */\n+  svorv (pg, u32, u32); /* { dg-error {too many arguments to function 'svorv'} } */\n+  svorv (0, u32); /* { dg-error {passing 'int' to argument 1 of 'svorv', which expects 'svbool_t'} } */\n+  svorv (u32, u32); /* { dg-error {passing 'svuint32_t' to argument 1 of 'svorv', which expects 'svbool_t'} } */\n+  svorv (pg, 0); /* { dg-error {passing 'int' to argument 2 of 'svorv', which expects an SVE vector type} } */\n+  svorv (pg, pg); /* { dg-error {'svorv' has no form that takes 'svbool_t' arguments} } */\n+  svorv (pg, s32);\n+  svorv (pg, u32);\n+  svorv (pg, f32); /* { dg-error {'svorv' has no form that takes 'svfloat32_t' arguments} } */\n+  svorv (pg, u32x2); /* { dg-error {passing 'svuint32x2_t' to argument 2 of 'svorv', which expects a single SVE vector rather than a tuple} } */\n+}"}, {"sha": "f99a2887bf6926de87d9d9a770d063784d7f4109", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/reduction_wide_1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Freduction_wide_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Freduction_wide_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Freduction_wide_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svuint32x2_t u32x2)\n+{\n+  svaddv (pg); /* { dg-error {too few arguments to function 'svaddv'} } */\n+  svaddv (pg, u32, u32); /* { dg-error {too many arguments to function 'svaddv'} } */\n+  svaddv (0, u32); /* { dg-error {passing 'int' to argument 1 of 'svaddv', which expects 'svbool_t'} } */\n+  svaddv (u32, u32); /* { dg-error {passing 'svuint32_t' to argument 1 of 'svaddv', which expects 'svbool_t'} } */\n+  svaddv (pg, 0); /* { dg-error {passing 'int' to argument 2 of 'svaddv', which expects an SVE vector type} } */\n+  svaddv (pg, pg); /* { dg-error {'svaddv' has no form that takes 'svbool_t' arguments} } */\n+  svaddv (pg, s32);\n+  svaddv (pg, u32);\n+  svaddv (pg, f32);\n+  svaddv (pg, u32x2); /* { dg-error {passing 'svuint32x2_t' to argument 2 of 'svaddv', which expects a single SVE vector rather than a tuple} } */\n+}"}, {"sha": "f07c76102caafcd06626a308865ad68c3578bfc5", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/set_1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fset_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fset_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fset_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+svfloat64_t\n+f1 (svbool_t pg, svuint8_t u8, svuint8x2_t u8x2, svuint8x3_t u8x3, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  u8x2 = svset2 (u8x2); /* { dg-error {too few arguments to function 'svset2'} } */\n+  u8x2 = svset2 (u8x2, 1); /* { dg-error {too few arguments to function 'svset2'} } */\n+  u8x2 = svset2 (u8x2, 1, u8, 3); /* { dg-error {too many arguments to function 'svset2'} } */\n+  u8x2 = svset2 (u8, 0, u8); /* { dg-error {passing single vector 'svuint8_t' to argument 1 of 'svset2', which expects a tuple of 2 vectors} } */\n+  u8x2 = svset2 (u8x3, 0, u8); /* { dg-error {passing 'svuint8x3_t' to argument 1 of 'svset2', which expects a tuple of 2 vectors} } */\n+  u8x2 = svset2 (pg, 0, u8); /* { dg-error {passing 'svbool_t' to argument 1 of 'svset2', which expects a tuple of 2 vectors} } */\n+  u8x2 = svset2 (u8x2, 0, u8x2); /* { dg-error {passing 'svuint8x2_t' to argument 3 of 'svset2', which expects a single SVE vector rather than a tuple} } */\n+  u8x2 = svset2 (u8x2, 0, f64); /* { dg-error {passing 'svfloat64_t' instead of the expected 'svuint8_t' to argument 3 of 'svset2', after passing 'svuint8x2_t' to argument 1} } */\n+  u8x2 = svset2 (u8x2, 0, pg); /* { dg-error {passing 'svbool_t' instead of the expected 'svuint8_t' to argument 3 of 'svset2', after passing 'svuint8x2_t' to argument 1} } */\n+  u8x2 = svset2 (u8x2, x, u8); /* { dg-error {argument 2 of 'svset2' must be an integer constant expression} } */\n+  u8x2 = svset2 (u8x2, 0, u8);\n+  f64 = svset2 (u8x2, 0, u8); /* { dg-error {incompatible types when assigning to type 'svfloat64_t' from type 'svuint8x2_t'} } */\n+  u8x2 = svset2 (u8x2, 1, u8);\n+  u8x2 = svset2 (u8x2, 2, u8); /* { dg-error {passing 2 to argument 2 of 'svset2', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2 (u8x2, 3, u8); /* { dg-error {passing 3 to argument 2 of 'svset2', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2 (u8x2, 4, u8); /* { dg-error {passing 4 to argument 2 of 'svset2', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2 (u8x2, 5, u8); /* { dg-error {passing 5 to argument 2 of 'svset2', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2 (u8x2, ~0U, u8); /* { dg-error {passing [^ ]* to argument 2 of 'svset2', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2 (u8x2, one, u8); /* { dg-error {argument 2 of 'svset2' must be an integer constant expression} } */\n+  u8x2 = svset2 (u8x2, 3 - 2, u8);\n+  u8x2 = svset2 (u8x2, 1.0, u8);\n+\n+  return f64;\n+}"}, {"sha": "ae277eafd17736a2c5077a47834ad1441e9dc72a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/set_2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fset_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fset_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fset_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+svfloat64_t\n+f1 (svbool_t pg, svuint8_t u8, svuint8x2_t u8x2, svint8x2_t s8x2,\n+    svuint8x3_t u8x3, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  u8x2 = svset2_u8 (u8x2); /* { dg-error {too few arguments to function 'svset2_u8'} } */\n+  u8x2 = svset2_u8 (u8x2, 1); /* { dg-error {too few arguments to function 'svset2_u8'} } */\n+  u8x2 = svset2_u8 (u8x2, 1, u8, 3); /* { dg-error {too many arguments to function 'svset2_u8'} } */\n+  u8x2 = svset2_u8 (u8, 0, u8); /* { dg-error {incompatible type for argument 1 of 'svset2_u8'} } */\n+  u8x2 = svset2_u8 (s8x2, 0, u8); /* { dg-error {incompatible type for argument 1 of 'svset2_u8'} } */\n+  u8x2 = svset2_u8 (u8x3, 0, u8); /* { dg-error {incompatible type for argument 1 of 'svset2_u8'} } */\n+  u8x2 = svset2_u8 (pg, 0, u8); /* { dg-error {incompatible type for argument 1 of 'svset2_u8'} } */\n+  u8x2 = svset2_u8 (u8x2, 0, u8x2); /* { dg-error {incompatible type for argument 3 of 'svset2_u8'} } */\n+  u8x2 = svset2_u8 (u8x2, 0, f64); /* { dg-error {incompatible type for argument 3 of 'svset2_u8'} } */\n+  u8x2 = svset2_u8 (u8x2, 0, pg); /* { dg-error {incompatible type for argument 3 of 'svset2_u8'} } */\n+  u8x2 = svset2_u8 (u8x2, x, u8); /* { dg-error {argument 2 of 'svset2_u8' must be an integer constant expression} } */\n+  u8x2 = svset2_u8 (u8x2, 0, u8);\n+  f64 = svset2_u8 (u8x2, 0, u8); /* { dg-error {incompatible types when assigning to type 'svfloat64_t' from type 'svuint8x2_t'} } */\n+  u8x2 = svset2_u8 (u8x2, 1, u8);\n+  u8x2 = svset2_u8 (u8x2, 2, u8); /* { dg-error {passing 2 to argument 2 of 'svset2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2_u8 (u8x2, 3, u8); /* { dg-error {passing 3 to argument 2 of 'svset2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2_u8 (u8x2, 4, u8); /* { dg-error {passing 4 to argument 2 of 'svset2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2_u8 (u8x2, 5, u8); /* { dg-error {passing 5 to argument 2 of 'svset2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2_u8 (u8x2, ~0U, u8); /* { dg-error {passing [^ ]* to argument 2 of 'svset2_u8', which expects a value in the range \\[0, 1\\]} } */\n+  u8x2 = svset2_u8 (u8x2, one, u8); /* { dg-error {argument 2 of 'svset2_u8' must be an integer constant expression} } */\n+  u8x2 = svset2_u8 (u8x2, 3 - 2, u8);\n+  u8x2 = svset2_u8 (u8x2, 1.0, u8);\n+\n+  return f64;\n+}"}, {"sha": "543a1bea8f3f2c5a99b464fe0f71175e65a9aa79", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/set_3.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fset_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fset_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fset_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+svfloat64_t\n+f1 (svbool_t pg, svfloat16_t f16, svfloat16x3_t f16x3, svfloat16x4_t f16x4,\n+    int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  f16x3 = svset3 (f16x3); /* { dg-error {too few arguments to function 'svset3'} } */\n+  f16x3 = svset3 (f16x3, 1); /* { dg-error {too few arguments to function 'svset3'} } */\n+  f16x3 = svset3 (f16x3, 1, f16, 3); /* { dg-error {too many arguments to function 'svset3'} } */\n+  f16x3 = svset3 (f16, 0, f16); /* { dg-error {passing single vector 'svfloat16_t' to argument 1 of 'svset3', which expects a tuple of 3 vectors} } */\n+  f16x3 = svset3 (f16x4, 0, f16); /* { dg-error {passing 'svfloat16x4_t' to argument 1 of 'svset3', which expects a tuple of 3 vectors} } */\n+  f16x3 = svset3 (pg, 0, f16); /* { dg-error {passing 'svbool_t' to argument 1 of 'svset3', which expects a tuple of 3 vectors} } */\n+  f16x3 = svset3 (f16x3, 0, f16x3); /* { dg-error {passing 'svfloat16x3_t' to argument 3 of 'svset3', which expects a single SVE vector rather than a tuple} } */\n+  f16x3 = svset3 (f16x3, 0, f64); /* { dg-error {passing 'svfloat64_t' instead of the expected 'svfloat16_t' to argument 3 of 'svset3', after passing 'svfloat16x3_t' to argument 1} } */\n+  f16x3 = svset3 (f16x3, 0, pg); /* { dg-error {passing 'svbool_t' instead of the expected 'svfloat16_t' to argument 3 of 'svset3', after passing 'svfloat16x3_t' to argument 1} } */\n+  f16x3 = svset3 (f16x3, x, f16); /* { dg-error {argument 2 of 'svset3' must be an integer constant expression} } */\n+  f16x3 = svset3 (f16x3, 0, f16);\n+  f64 = svset3 (f16x3, 0, f16); /* { dg-error {incompatible types when assigning to type 'svfloat64_t' from type 'svfloat16x3_t'} } */\n+  f16x3 = svset3 (f16x3, 1, f16);\n+  f16x3 = svset3 (f16x3, 2, f16);\n+  f16x3 = svset3 (f16x3, 3, f16); /* { dg-error {passing 3 to argument 2 of 'svset3', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3 (f16x3, 4, f16); /* { dg-error {passing 4 to argument 2 of 'svset3', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3 (f16x3, 5, f16); /* { dg-error {passing 5 to argument 2 of 'svset3', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3 (f16x3, ~0U, f16); /* { dg-error {passing [^ ]* to argument 2 of 'svset3', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3 (f16x3, one, f16); /* { dg-error {argument 2 of 'svset3' must be an integer constant expression} } */\n+  f16x3 = svset3 (f16x3, 3 - 2, f16);\n+  f16x3 = svset3 (f16x3, 1.0, f16);\n+\n+  return f64;\n+}"}, {"sha": "198b034071fb2183f8f9c9c3651ca072a451c1cc", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/set_4.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fset_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fset_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fset_4.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+svfloat64_t\n+f1 (svbool_t pg, svfloat16_t f16, svfloat16x3_t f16x3, svuint16x3_t u16x3,\n+    svfloat16x4_t f16x4, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  f16x3 = svset3_f16 (f16x3); /* { dg-error {too few arguments to function 'svset3_f16'} } */\n+  f16x3 = svset3_f16 (f16x3, 1); /* { dg-error {too few arguments to function 'svset3_f16'} } */\n+  f16x3 = svset3_f16 (f16x3, 1, f16, 3); /* { dg-error {too many arguments to function 'svset3_f16'} } */\n+  f16x3 = svset3_f16 (f16, 0, f16); /* { dg-error {incompatible type for argument 1 of 'svset3_f16'} } */\n+  f16x3 = svset3_f16 (u16x3, 0, f16); /* { dg-error {incompatible type for argument 1 of 'svset3_f16'} } */\n+  f16x3 = svset3_f16 (f16x4, 0, f16); /* { dg-error {incompatible type for argument 1 of 'svset3_f16'} } */\n+  f16x3 = svset3_f16 (pg, 0, f16); /* { dg-error {incompatible type for argument 1 of 'svset3_f16'} } */\n+  f16x3 = svset3_f16 (f16x3, 0, f16x3); /* { dg-error {incompatible type for argument 3 of 'svset3_f16'} } */\n+  f16x3 = svset3_f16 (f16x3, 0, f64); /* { dg-error {incompatible type for argument 3 of 'svset3_f16'} } */\n+  f16x3 = svset3_f16 (f16x3, 0, pg); /* { dg-error {incompatible type for argument 3 of 'svset3_f16'} } */\n+  f16x3 = svset3_f16 (f16x3, x, f16); /* { dg-error {argument 2 of 'svset3_f16' must be an integer constant expression} } */\n+  f16x3 = svset3_f16 (f16x3, 0, f16);\n+  f64 = svset3_f16 (f16x3, 0, f16); /* { dg-error {incompatible types when assigning to type 'svfloat64_t' from type 'svfloat16x3_t'} } */\n+  f16x3 = svset3_f16 (f16x3, 1, f16);\n+  f16x3 = svset3_f16 (f16x3, 2, f16);\n+  f16x3 = svset3_f16 (f16x3, 3, f16); /* { dg-error {passing 3 to argument 2 of 'svset3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3_f16 (f16x3, 4, f16); /* { dg-error {passing 4 to argument 2 of 'svset3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3_f16 (f16x3, 5, f16); /* { dg-error {passing 5 to argument 2 of 'svset3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3_f16 (f16x3, ~0U, f16); /* { dg-error {passing [^ ]* to argument 2 of 'svset3_f16', which expects a value in the range \\[0, 2\\]} } */\n+  f16x3 = svset3_f16 (f16x3, one, f16); /* { dg-error {argument 2 of 'svset3_f16' must be an integer constant expression} } */\n+  f16x3 = svset3_f16 (f16x3, 3 - 2, f16);\n+  f16x3 = svset3_f16 (f16x3, 1.0, f16);\n+\n+  return f64;\n+}"}, {"sha": "be911a73176e5bdf26baeac9541b5757aeddc36e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/set_5.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fset_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fset_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fset_5.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+svfloat64_t\n+f1 (svbool_t pg, svint32_t s32, svint32x4_t s32x4, svint32x2_t s32x2, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  s32x4 = svset4 (s32x4); /* { dg-error {too few arguments to function 'svset4'} } */\n+  s32x4 = svset4 (s32x4, 1); /* { dg-error {too few arguments to function 'svset4'} } */\n+  s32x4 = svset4 (s32x4, 1, s32, 3); /* { dg-error {too many arguments to function 'svset4'} } */\n+  s32x4 = svset4 (s32, 0, s32); /* { dg-error {passing single vector 'svint32_t' to argument 1 of 'svset4', which expects a tuple of 4 vectors} } */\n+  s32x4 = svset4 (s32x2, 0, s32); /* { dg-error {passing 'svint32x2_t' to argument 1 of 'svset4', which expects a tuple of 4 vectors} } */\n+  s32x4 = svset4 (pg, 0, s32); /* { dg-error {passing 'svbool_t' to argument 1 of 'svset4', which expects a tuple of 4 vectors} } */\n+  s32x4 = svset4 (s32x4, 0, s32x4); /* { dg-error {passing 'svint32x4_t' to argument 3 of 'svset4', which expects a single SVE vector rather than a tuple} } */\n+  s32x4 = svset4 (s32x4, 0, f64); /* { dg-error {passing 'svfloat64_t' instead of the expected 'svint32_t' to argument 3 of 'svset4', after passing 'svint32x4_t' to argument 1} } */\n+  s32x4 = svset4 (s32x4, 0, pg); /* { dg-error {passing 'svbool_t' instead of the expected 'svint32_t' to argument 3 of 'svset4', after passing 'svint32x4_t' to argument 1} } */\n+  s32x4 = svset4 (s32x4, x, s32); /* { dg-error {argument 2 of 'svset4' must be an integer constant expression} } */\n+  s32x4 = svset4 (s32x4, 0, s32);\n+  f64 = svset4 (s32x4, 0, s32); /* { dg-error {incompatible types when assigning to type 'svfloat64_t' from type 'svint32x4_t'} } */\n+  s32x4 = svset4 (s32x4, 1, s32);\n+  s32x4 = svset4 (s32x4, 2, s32);\n+  s32x4 = svset4 (s32x4, 3, s32);\n+  s32x4 = svset4 (s32x4, 4, s32); /* { dg-error {passing 4 to argument 2 of 'svset4', which expects a value in the range \\[0, 3\\]} } */\n+  s32x4 = svset4 (s32x4, 5, s32); /* { dg-error {passing 5 to argument 2 of 'svset4', which expects a value in the range \\[0, 3\\]} } */\n+  s32x4 = svset4 (s32x4, ~0U, s32); /* { dg-error {passing [^ ]* to argument 2 of 'svset4', which expects a value in the range \\[0, 3\\]} } */\n+  s32x4 = svset4 (s32x4, one, s32); /* { dg-error {argument 2 of 'svset4' must be an integer constant expression} } */\n+  s32x4 = svset4 (s32x4, 3 - 2, s32);\n+  s32x4 = svset4 (s32x4, 1.0, s32);\n+\n+  return f64;\n+}"}, {"sha": "cec4354133c371f1d4323f974ac6acbe4fb69b5d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/set_6.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fset_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fset_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fset_6.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+svfloat64_t\n+f1 (svbool_t pg, svint32_t s32, svint32x4_t s32x4, svfloat32x4_t f32x4,\n+    svint32x2_t s32x2, int x)\n+{\n+  const int one = 1;\n+  svfloat64_t f64;\n+\n+  s32x4 = svset4_s32 (s32x4); /* { dg-error {too few arguments to function 'svset4_s32'} } */\n+  s32x4 = svset4_s32 (s32x4, 1); /* { dg-error {too few arguments to function 'svset4_s32'} } */\n+  s32x4 = svset4_s32 (s32x4, 1, s32, 3); /* { dg-error {too many arguments to function 'svset4_s32'} } */\n+  s32x4 = svset4_s32 (s32, 0, s32); /* { dg-error {incompatible type for argument 1 of 'svset4_s32'} } */\n+  s32x4 = svset4_s32 (f32x4, 0, s32); /* { dg-error {incompatible type for argument 1 of 'svset4_s32'} } */\n+  s32x4 = svset4_s32 (s32x2, 0, s32); /* { dg-error {incompatible type for argument 1 of 'svset4_s32'} } */\n+  s32x4 = svset4_s32 (pg, 0, s32); /* { dg-error {incompatible type for argument 1 of 'svset4_s32'} } */\n+  s32x4 = svset4_s32 (s32x4, 0, s32x4); /* { dg-error {incompatible type for argument 3 of 'svset4_s32'} } */\n+  s32x4 = svset4_s32 (s32x4, 0, f64); /* { dg-error {incompatible type for argument 3 of 'svset4_s32'} } */\n+  s32x4 = svset4_s32 (s32x4, 0, pg); /* { dg-error {incompatible type for argument 3 of 'svset4_s32'} } */\n+  s32x4 = svset4_s32 (s32x4, x, s32); /* { dg-error {argument 2 of 'svset4_s32' must be an integer constant expression} } */\n+  s32x4 = svset4_s32 (s32x4, 0, s32);\n+  f64 = svset4_s32 (s32x4, 0, s32); /* { dg-error {incompatible types when assigning to type 'svfloat64_t' from type 'svint32x4_t'} } */\n+  s32x4 = svset4_s32 (s32x4, 1, s32);\n+  s32x4 = svset4_s32 (s32x4, 2, s32);\n+  s32x4 = svset4_s32 (s32x4, 3, s32);\n+  s32x4 = svset4_s32 (s32x4, 4, s32); /* { dg-error {passing 4 to argument 2 of 'svset4_s32', which expects a value in the range \\[0, 3\\]} } */\n+  s32x4 = svset4_s32 (s32x4, 5, s32); /* { dg-error {passing 5 to argument 2 of 'svset4_s32', which expects a value in the range \\[0, 3\\]} } */\n+  s32x4 = svset4_s32 (s32x4, ~0U, s32); /* { dg-error {passing [^ ]* to argument 2 of 'svset4_s32', which expects a value in the range \\[0, 3\\]} } */\n+  s32x4 = svset4_s32 (s32x4, one, s32); /* { dg-error {argument 2 of 'svset4_s32' must be an integer constant expression} } */\n+  s32x4 = svset4_s32 (s32x4, 3 - 2, s32);\n+  s32x4 = svset4_s32 (s32x4, 1.0, s32);\n+\n+  return f64;\n+}"}, {"sha": "4dd9a9c7627a1c63d30a58a39a5cab21557a3fe5", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/shift_right_imm_1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fshift_right_imm_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fshift_right_imm_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fshift_right_imm_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svuint8_t u8, svint8_t s8, svint16_t s16,\n+    svint32_t s32, svint64_t s64, int x)\n+{\n+  const int one = 1;\n+  u8 = svasrd_x (pg, u8, 1); /* { dg-error {'svasrd_x' has no form that takes 'svuint8_t' arguments} } */\n+  s8 = svasrd_x (pg, s8, x); /* { dg-error {argument 3 of 'svasrd_x' must be an integer constant expression} } */\n+  s8 = svasrd_x (pg, s8, one); /* { dg-error {argument 3 of 'svasrd_x' must be an integer constant expression} } */\n+  s8 = svasrd_x (pg, s8, 0.4); /* { dg-error {passing 0 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 8\\]} } */\n+  s8 = svasrd_x (pg, s8, 1.0);\n+  s8 = svasrd_x (pg, s8, 0); /* { dg-error {passing 0 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 8\\]} } */\n+  s8 = svasrd_x (pg, s8, 1);\n+  s8 = svasrd_x (pg, s8, 1 + 1);\n+  s8 = svasrd_x (pg, s8, 8);\n+  s8 = svasrd_x (pg, s8, 9); /* { dg-error {passing 9 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 8\\]} } */\n+  s8 = svasrd_x (pg, s8, (1ULL << 62) + 1); /* { dg-error {passing [^ ]* to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 8\\]} } */\n+  s16 = svasrd_x (pg, s16, 0); /* { dg-error {passing 0 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 16\\]} } */\n+  s16 = svasrd_x (pg, s16, 1);\n+  s16 = svasrd_x (pg, s16, 16);\n+  s16 = svasrd_x (pg, s16, 17); /* { dg-error {passing 17 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 16\\]} } */\n+  s32 = svasrd_x (pg, s32, 0); /* { dg-error {passing 0 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 32\\]} } */\n+  s32 = svasrd_x (pg, s32, 1);\n+  s32 = svasrd_x (pg, s32, 32);\n+  s32 = svasrd_x (pg, s32, 33); /* { dg-error {passing 33 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 32\\]} } */\n+  s64 = svasrd_x (pg, s64, 0); /* { dg-error {passing 0 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 64\\]} } */\n+  s64 = svasrd_x (pg, s64, 1);\n+  s64 = svasrd_x (pg, s64, 64);\n+  s64 = svasrd_x (pg, s64, 65); /* { dg-error {passing 65 to argument 3 of 'svasrd_x', which expects a value in the range \\[1, 64\\]} } */\n+}"}, {"sha": "4970689e90307ee81a86ceae4e025f1755d2d28f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/shift_right_imm_2.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fshift_right_imm_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fshift_right_imm_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fshift_right_imm_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c99 -Wall -Wextra\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svint8_t s8, svint16_t s16, svint32_t s32, svint64_t s64,\n+    int x)\n+{\n+  const int one = 1;\n+  s8 = svasrd_n_s8_x (pg, s8, x); /* { dg-error {argument 3 of 'svasrd_n_s8_x' must be an integer constant expression} } */\n+  s8 = svasrd_n_s8_x (pg, s8, one); /* { dg-error {argument 3 of 'svasrd_n_s8_x' must be an integer constant expression} } */\n+  s8 = svasrd_n_s8_x (pg, s8, 0.4); /* { dg-error {passing 0 to argument 3 of 'svasrd_n_s8_x', which expects a value in the range \\[1, 8\\]} } */\n+  s8 = svasrd_n_s8_x (pg, s8, 1.0);\n+  s8 = svasrd_n_s8_x (pg, s8, 0); /* { dg-error {passing 0 to argument 3 of 'svasrd_n_s8_x', which expects a value in the range \\[1, 8\\]} } */\n+  s8 = svasrd_n_s8_x (pg, s8, 1);\n+  s8 = svasrd_n_s8_x (pg, s8, 1 + 1);\n+  s8 = svasrd_n_s8_x (pg, s8, 8);\n+  s8 = svasrd_n_s8_x (pg, s8, 9); /* { dg-error {passing 9 to argument 3 of 'svasrd_n_s8_x', which expects a value in the range \\[1, 8\\]} } */\n+  s8 = svasrd_n_s8_x (pg, s8, (1ULL << 62) + 1); /* { dg-error {passing [^ ]* to argument 3 of 'svasrd_n_s8_x', which expects a value in the range \\[1, 8\\]} } */\n+  s16 = svasrd_n_s16_x (pg, s16, 0); /* { dg-error {passing 0 to argument 3 of 'svasrd_n_s16_x', which expects a value in the range \\[1, 16\\]} } */\n+  s16 = svasrd_n_s16_x (pg, s16, 1);\n+  s16 = svasrd_n_s16_x (pg, s16, 16);\n+  s16 = svasrd_n_s16_x (pg, s16, 17); /* { dg-error {passing 17 to argument 3 of 'svasrd_n_s16_x', which expects a value in the range \\[1, 16\\]} } */\n+  s32 = svasrd_n_s32_x (pg, s32, 0); /* { dg-error {passing 0 to argument 3 of 'svasrd_n_s32_x', which expects a value in the range \\[1, 32\\]} } */\n+  s32 = svasrd_n_s32_x (pg, s32, 1);\n+  s32 = svasrd_n_s32_x (pg, s32, 32);\n+  s32 = svasrd_n_s32_x (pg, s32, 33); /* { dg-error {passing 33 to argument 3 of 'svasrd_n_s32_x', which expects a value in the range \\[1, 32\\]} } */\n+  s64 = svasrd_n_s64_x (pg, s64, 0); /* { dg-error {passing 0 to argument 3 of 'svasrd_n_s64_x', which expects a value in the range \\[1, 64\\]} } */\n+  s64 = svasrd_n_s64_x (pg, s64, 1);\n+  s64 = svasrd_n_s64_x (pg, s64, 64);\n+  s64 = svasrd_n_s64_x (pg, s64, 65); /* { dg-error {passing 65 to argument 3 of 'svasrd_n_s64_x', which expects a value in the range \\[1, 64\\]} } */\n+}"}, {"sha": "267db83f70fa7baab1d966a8a5c33cd50e82a4f3", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/store_1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fstore_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fstore_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fstore_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { signed char x; };\n+\n+svuint8_t\n+f1 (svbool_t pg, signed char *s8_ptr, void *void_ptr, struct s *s_ptr,\n+    float *f32_ptr, _Complex float *cf32_ptr, svint8_t s8, svfloat32_t f32,\n+    struct s s)\n+{\n+  svst1 (pg, s8_ptr); /* { dg-error {too few arguments to function 'svst1'} } */\n+  svst1 (pg, s8_ptr, s8, 0); /* { dg-error {too many arguments to function 'svst1'} } */\n+  svst1 (0, s8_ptr, s8); /* { dg-error {passing 'int' to argument 1 of 'svst1', which expects 'svbool_t'} } */\n+  svst1 (pg, void_ptr, 0); /* { dg-error {passing 'int' to argument 3 of 'svst1', which expects an SVE vector type} } */\n+  svst1 (pg, void_ptr, pg); /* { dg-error {'svst1' has no form that takes 'svbool_t' arguments} } */\n+  svst1 (pg, 0, s8);\n+  svst1 (pg, (int *) 0, s8); /* { dg-warning \"passing argument 2 of 'svst1_s8' from incompatible pointer type\" } */\n+  svst1 (pg, void_ptr, s8);\n+  svst1 (pg, s_ptr, s8); /* { dg-warning \"passing argument 2 of 'svst1_s8' from incompatible pointer type\" } */\n+  svst1 (pg, f32_ptr, s8); /* { dg-warning \"passing argument 2 of 'svst1_s8' from incompatible pointer type\" } */\n+  svst1 (pg, f32_ptr, f32);\n+  svst1 (pg, cf32_ptr, f32); /* { dg-warning \"passing argument 2 of 'svst1_f32' from incompatible pointer type\" } */\n+  svst1 (pg, s, s8); /* { dg-error {passing 'struct s' to argument 2 of 'svst1', which expects a scalar pointer} } */\n+}"}, {"sha": "4e4fb3c6d66b957baf2850c777e11a57d9fbe336", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/store_2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fstore_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fstore_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fstore_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { signed char x; };\n+\n+svuint8_t\n+f1 (svbool_t pg, signed char *s8_ptr, void *void_ptr, struct s *s_ptr,\n+    float *f32_ptr, _Complex float *cf32_ptr, svint8_t s8, svfloat32_t f32)\n+{\n+  svst1_vnum (pg, s8_ptr, 0); /* { dg-error {too few arguments to function 'svst1_vnum'} } */\n+  svst1_vnum (pg, s8_ptr, 0, s8, 0); /* { dg-error {too many arguments to function 'svst1_vnum'} } */\n+  svst1_vnum (0, s8_ptr, 0, s8); /* { dg-error {passing 'int' to argument 1 of 'svst1_vnum', which expects 'svbool_t'} } */\n+  svst1_vnum (pg, s8_ptr, pg, s8); /* { dg-error {passing 'svbool_t' to argument 3 of 'svst1_vnum', which expects 'int64_t'} } */\n+  svst1_vnum (pg, s8_ptr, s8, s8); /* { dg-error {passing 'svint8_t' to argument 3 of 'svst1_vnum', which expects 'int64_t'} } */\n+  svst1_vnum (pg, s8_ptr, void_ptr, s8); /* { dg-warning \"passing argument 3 of 'svst1_vnum_s8' makes integer from pointer without a cast\" } */\n+  svst1_vnum (pg, void_ptr, 0, 0); /* { dg-error {passing 'int' to argument 4 of 'svst1_vnum', which expects an SVE vector type} } */\n+  svst1_vnum (pg, void_ptr, 0, pg); /* { dg-error {'svst1_vnum' has no form that takes 'svbool_t' arguments} } */\n+  svst1_vnum (pg, 0, 0, s8);\n+  svst1_vnum (pg, (int *) 0, 0, s8); /* { dg-warning \"passing argument 2 of 'svst1_vnum_s8' from incompatible pointer type\" } */\n+  svst1_vnum (pg, void_ptr, 0, s8);\n+  svst1_vnum (pg, s_ptr, 0, s8); /* { dg-warning \"passing argument 2 of 'svst1_vnum_s8' from incompatible pointer type\" } */\n+  svst1_vnum (pg, f32_ptr, 0, s8); /* { dg-warning \"passing argument 2 of 'svst1_vnum_s8' from incompatible pointer type\" } */\n+  svst1_vnum (pg, f32_ptr, 0, f32);\n+  svst1_vnum (pg, cf32_ptr, 0, f32); /* { dg-warning \"passing argument 2 of 'svst1_vnum_f32' from incompatible pointer type\" } */\n+}"}, {"sha": "3209149b619a8bd495fb8aa71c7b2a4ae6de1f22", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/store_scatter_index_1.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fstore_scatter_index_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fstore_scatter_index_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fstore_scatter_index_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,101 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { signed char x; };\n+\n+svuint32_t\n+f1 (svbool_t pg, signed char *s8_ptr, short *s16_ptr,\n+    int32_t *s32_ptr, uint32_t *u32_ptr, float *f32_ptr,\n+    int64_t *s64_ptr, uint64_t *u64_ptr, double *f64_ptr,\n+    void *void_ptr, struct s *s_ptr, _Complex float *cf32_ptr,\n+    svint8_t s8, svuint8_t u8, svint16_t s16, svuint16_t u16, svfloat16_t f16,\n+    svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64, svfloat64_t f64, struct s s)\n+{\n+  svst1_scatter_index (pg, s32_ptr, s32); /* { dg-error {too few arguments to function 'svst1_scatter_index'} } */\n+  svst1_scatter_index (pg, s32_ptr, s32, s32, 0); /* { dg-error {too many arguments to function 'svst1_scatter_index'} } */\n+  svst1_scatter_index (0, s32_ptr, s32, s32); /* { dg-error {passing 'int' to argument 1 of 'svst1_scatter_index', which expects 'svbool_t'} } */\n+  svst1_scatter_index (pg, 0, s32, s32);\n+  svst1_scatter_index (pg, (int *) 0, s32, s32);\n+  svst1_scatter_index (pg, void_ptr, s32, s32);\n+  svst1_scatter_index (pg, s_ptr, s32, s32); /* { dg-warning \"passing argument 2 of 'svst1_scatter_s32index_s32' from incompatible pointer type\" } */\n+  svst1_scatter_index (pg, f32_ptr, s32, s32); /* { dg-warning \"passing argument 2 of 'svst1_scatter_s32index_s32' from incompatible pointer type\" } */\n+  svst1_scatter_index (pg, f32_ptr, s32, f32);\n+  svst1_scatter_index (pg, cf32_ptr, s32, f32); /* { dg-warning \"passing argument 2 of 'svst1_scatter_s32index_f32' from incompatible pointer type\" } */\n+  svst1_scatter_index (pg, s, s32, s32); /* { dg-error {passing 'struct s' to argument 2 of 'svst1_scatter_index', which expects a vector or pointer base address} } */\n+\n+  svst1_scatter_index (pg, u32, void_ptr, s32); /* { dg-warning \"passing argument 3 of 'svst1_scatter_u32base_index_s32' makes integer from pointer without a cast\" } */\n+  svst1_scatter_index (pg, u32, pg, s32); /* { dg-error {passing 'svbool_t' to argument 3 of 'svst1_scatter_index', which expects 'int64_t'} } */\n+  svst1_scatter_index (pg, u32, s32, s32); /* { dg-error {passing 'svint32_t' to argument 3 of 'svst1_scatter_index', which expects 'int64_t'} } */\n+\n+  svst1_scatter_index (pg, void_ptr, u32, pg); /* { dg-error {passing 'svbool_t' to argument 4 of 'svst1_scatter_index', which expects a vector of 32-bit or 64-bit elements} } */\n+\n+  svst1_scatter_index (pg, s8_ptr, u32, s8); /* { dg-error {passing 'svint8_t' to argument 4 of 'svst1_scatter_index', which expects a vector of 32-bit or 64-bit elements} } */\n+  svst1_scatter_index (pg, s8_ptr, u32, u8); /* { dg-error {passing 'svuint8_t' to argument 4 of 'svst1_scatter_index', which expects a vector of 32-bit or 64-bit elements} } */\n+\n+  svst1_scatter_index (pg, s16_ptr, u32, s16); /* { dg-error {passing 'svint16_t' to argument 4 of 'svst1_scatter_index', which expects a vector of 32-bit or 64-bit elements} } */\n+  svst1_scatter_index (pg, s16_ptr, u32, u16); /* { dg-error {passing 'svuint16_t' to argument 4 of 'svst1_scatter_index', which expects a vector of 32-bit or 64-bit elements} } */\n+  svst1_scatter_index (pg, s16_ptr, u32, f16); /* { dg-error {passing 'svfloat16_t' to argument 4 of 'svst1_scatter_index', which expects a vector of 32-bit or 64-bit elements} } */\n+\n+  svst1_scatter_index (pg, u32, 0, s32);\n+  svst1_scatter_index (pg, s32, 0, s32); /* { dg-error {passing 'svint32_t' to argument 2 of 'svst1_scatter_index', which expects 'svuint32_t'} } */\n+\n+  svst1_scatter_index (pg, u32, 0, u32);\n+  svst1_scatter_index (pg, s32, 0, u32); /* { dg-error {passing 'svint32_t' to argument 2 of 'svst1_scatter_index', which expects 'svuint32_t'} } */\n+\n+  svst1_scatter_index (pg, u32, 0, f32);\n+  svst1_scatter_index (pg, s32, 0, f32); /* { dg-error {passing 'svint32_t' to argument 2 of 'svst1_scatter_index', which expects 'svuint32_t'} } */\n+\n+  svst1_scatter_index (pg, u64, 0, s64);\n+  svst1_scatter_index (pg, s64, 0, s64); /* { dg-error {passing 'svint64_t' to argument 2 of 'svst1_scatter_index', which expects 'svuint64_t'} } */\n+\n+  svst1_scatter_index (pg, u64, 0, u64);\n+  svst1_scatter_index (pg, s64, 0, u64); /* { dg-error {passing 'svint64_t' to argument 2 of 'svst1_scatter_index', which expects 'svuint64_t'} } */\n+\n+  svst1_scatter_index (pg, u64, 0, f64);\n+  svst1_scatter_index (pg, s64, 0, f64); /* { dg-error {passing 'svint64_t' to argument 2 of 'svst1_scatter_index', which expects 'svuint64_t'} } */\n+\n+  svst1_scatter_index (pg, s32_ptr, s32, s32);\n+  svst1_scatter_index (pg, s32_ptr, u32, s32);\n+  svst1_scatter_index (pg, s32_ptr, f32, s32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svst1_scatter_index', which when storing 'svint32_t' expects a vector of 32-bit integers} } */\n+  svst1_scatter_index (pg, s32_ptr, s64, s32); /* { dg-error {passing 'svint64_t' to argument 3 of 'svst1_scatter_index', which when storing 'svint32_t' expects a vector of 32-bit integers} } */\n+  svst1_scatter_index (pg, s32_ptr, u64, s32); /* { dg-error {passing 'svuint64_t' to argument 3 of 'svst1_scatter_index', which when storing 'svint32_t' expects a vector of 32-bit integers} } */\n+  svst1_scatter_index (pg, s32_ptr, f64, s32); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svst1_scatter_index', which when storing 'svint32_t' expects a vector of 32-bit integers} } */\n+\n+  svst1_scatter_index (pg, u32_ptr, s32, u32);\n+  svst1_scatter_index (pg, u32_ptr, u32, u32);\n+  svst1_scatter_index (pg, u32_ptr, f32, u32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svst1_scatter_index', which when storing 'svuint32_t' expects a vector of 32-bit integers} } */\n+  svst1_scatter_index (pg, u32_ptr, s64, u32); /* { dg-error {passing 'svint64_t' to argument 3 of 'svst1_scatter_index', which when storing 'svuint32_t' expects a vector of 32-bit integers} } */\n+  svst1_scatter_index (pg, u32_ptr, u64, u32); /* { dg-error {passing 'svuint64_t' to argument 3 of 'svst1_scatter_index', which when storing 'svuint32_t' expects a vector of 32-bit integers} } */\n+  svst1_scatter_index (pg, u32_ptr, f64, u32); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svst1_scatter_index', which when storing 'svuint32_t' expects a vector of 32-bit integers} } */\n+\n+  svst1_scatter_index (pg, f32_ptr, s32, f32);\n+  svst1_scatter_index (pg, f32_ptr, u32, f32);\n+  svst1_scatter_index (pg, f32_ptr, f32, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svst1_scatter_index', which when storing 'svfloat32_t' expects a vector of 32-bit integers} } */\n+  svst1_scatter_index (pg, f32_ptr, s64, f32); /* { dg-error {passing 'svint64_t' to argument 3 of 'svst1_scatter_index', which when storing 'svfloat32_t' expects a vector of 32-bit integers} } */\n+  svst1_scatter_index (pg, f32_ptr, u64, f32); /* { dg-error {passing 'svuint64_t' to argument 3 of 'svst1_scatter_index', which when storing 'svfloat32_t' expects a vector of 32-bit integers} } */\n+  svst1_scatter_index (pg, f32_ptr, f64, f32); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svst1_scatter_index', which when storing 'svfloat32_t' expects a vector of 32-bit integers} } */\n+\n+  svst1_scatter_index (pg, s64_ptr, s32, s64); /* { dg-error {passing 'svint32_t' to argument 3 of 'svst1_scatter_index', which when storing 'svint64_t' expects a vector of 64-bit integers} } */\n+  svst1_scatter_index (pg, s64_ptr, u32, s64); /* { dg-error {passing 'svuint32_t' to argument 3 of 'svst1_scatter_index', which when storing 'svint64_t' expects a vector of 64-bit integers} } */\n+  svst1_scatter_index (pg, s64_ptr, f32, s64); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svst1_scatter_index', which when storing 'svint64_t' expects a vector of 64-bit integers} } */\n+  svst1_scatter_index (pg, s64_ptr, s64, s64);\n+  svst1_scatter_index (pg, s64_ptr, u64, s64);\n+  svst1_scatter_index (pg, s64_ptr, f64, s64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svst1_scatter_index', which when storing 'svint64_t' expects a vector of 64-bit integers} } */\n+\n+  svst1_scatter_index (pg, u64_ptr, s32, u64); /* { dg-error {passing 'svint32_t' to argument 3 of 'svst1_scatter_index', which when storing 'svuint64_t' expects a vector of 64-bit integers} } */\n+  svst1_scatter_index (pg, u64_ptr, u32, u64); /* { dg-error {passing 'svuint32_t' to argument 3 of 'svst1_scatter_index', which when storing 'svuint64_t' expects a vector of 64-bit integers} } */\n+  svst1_scatter_index (pg, u64_ptr, f32, u64); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svst1_scatter_index', which when storing 'svuint64_t' expects a vector of 64-bit integers} } */\n+  svst1_scatter_index (pg, u64_ptr, s64, u64);\n+  svst1_scatter_index (pg, u64_ptr, u64, u64);\n+  svst1_scatter_index (pg, u64_ptr, f64, u64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svst1_scatter_index', which when storing 'svuint64_t' expects a vector of 64-bit integers} } */\n+\n+  svst1_scatter_index (pg, f64_ptr, s32, f64); /* { dg-error {passing 'svint32_t' to argument 3 of 'svst1_scatter_index', which when storing 'svfloat64_t' expects a vector of 64-bit integers} } */\n+  svst1_scatter_index (pg, f64_ptr, u32, f64); /* { dg-error {passing 'svuint32_t' to argument 3 of 'svst1_scatter_index', which when storing 'svfloat64_t' expects a vector of 64-bit integers} } */\n+  svst1_scatter_index (pg, f64_ptr, f32, f64); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svst1_scatter_index', which when storing 'svfloat64_t' expects a vector of 64-bit integers} } */\n+  svst1_scatter_index (pg, f64_ptr, s64, f64);\n+  svst1_scatter_index (pg, f64_ptr, u64, f64);\n+  svst1_scatter_index (pg, f64_ptr, f64, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svst1_scatter_index', which when storing 'svfloat64_t' expects a vector of 64-bit integers} } */\n+}"}, {"sha": "10abf758c2fbdd50550b7c238c9601adfc43a6f0", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/store_scatter_offset_1.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fstore_scatter_offset_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fstore_scatter_offset_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fstore_scatter_offset_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { signed char x; };\n+\n+svuint32_t\n+f1 (svbool_t pg, svint8_t s8, svuint8_t u8, svint16_t s16, svuint16_t u16,\n+    svfloat16_t f16, svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64, svfloat64_t f64)\n+{\n+  svst1_scatter (pg, u32); /* { dg-error {too few arguments to function 'svst1_scatter'} } */\n+  svst1_scatter (pg, u32, u32, 0); /* { dg-error {too many arguments to function 'svst1_scatter'} } */\n+  svst1_scatter (0, u32, u32); /* { dg-error {passing 'int' to argument 1 of 'svst1_scatter', which expects 'svbool_t'} } */\n+  svst1_scatter (pg, 0, u32); /* { dg-error {passing 'int' to argument 2 of 'svst1_scatter', which expects an SVE vector type} } */\n+  svst1_scatter (pg, u32, 0); /* { dg-error {passing 'int' to argument 3 of 'svst1_scatter', which expects an SVE vector type} } */\n+\n+  svst1_scatter (pg, u32, pg); /* { dg-error {passing 'svbool_t' to argument 3 of 'svst1_scatter', which expects a vector of 32-bit or 64-bit elements} } */\n+\n+  svst1_scatter (pg, u32, s8); /* { dg-error {passing 'svint8_t' to argument 3 of 'svst1_scatter', which expects a vector of 32-bit or 64-bit elements} } */\n+  svst1_scatter (pg, u32, u8); /* { dg-error {passing 'svuint8_t' to argument 3 of 'svst1_scatter', which expects a vector of 32-bit or 64-bit elements} } */\n+\n+  svst1_scatter (pg, u32, s16); /* { dg-error {passing 'svint16_t' to argument 3 of 'svst1_scatter', which expects a vector of 32-bit or 64-bit elements} } */\n+  svst1_scatter (pg, u32, u16); /* { dg-error {passing 'svuint16_t' to argument 3 of 'svst1_scatter', which expects a vector of 32-bit or 64-bit elements} } */\n+  svst1_scatter (pg, u32, f16); /* { dg-error {passing 'svfloat16_t' to argument 3 of 'svst1_scatter', which expects a vector of 32-bit or 64-bit elements} } */\n+\n+  svst1_scatter (pg, u32, s32);\n+  svst1_scatter (pg, s32, s32); /* { dg-error {passing 'svint32_t' to argument 2 of 'svst1_scatter', which expects 'svuint32_t'} } */\n+\n+  svst1_scatter (pg, u32, u32);\n+  svst1_scatter (pg, s32, u32); /* { dg-error {passing 'svint32_t' to argument 2 of 'svst1_scatter', which expects 'svuint32_t'} } */\n+\n+  svst1_scatter (pg, u32, f32);\n+  svst1_scatter (pg, s32, f32); /* { dg-error {passing 'svint32_t' to argument 2 of 'svst1_scatter', which expects 'svuint32_t'} } */\n+\n+  svst1_scatter (pg, u64, s64);\n+  svst1_scatter (pg, s64, s64); /* { dg-error {passing 'svint64_t' to argument 2 of 'svst1_scatter', which expects 'svuint64_t'} } */\n+\n+  svst1_scatter (pg, u64, u64);\n+  svst1_scatter (pg, s64, u64); /* { dg-error {passing 'svint64_t' to argument 2 of 'svst1_scatter', which expects 'svuint64_t'} } */\n+\n+  svst1_scatter (pg, u64, f64);\n+  svst1_scatter (pg, s64, f64); /* { dg-error {passing 'svint64_t' to argument 2 of 'svst1_scatter', which expects 'svuint64_t'} } */\n+}"}, {"sha": "8ee8129fa103e7672738cb05da72682fca0a3376", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/store_scatter_offset_2.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fstore_scatter_offset_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fstore_scatter_offset_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fstore_scatter_offset_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,101 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <arm_sve.h>\n+\n+struct s { signed char x; };\n+\n+svuint32_t\n+f1 (svbool_t pg, signed char *s8_ptr, short *s16_ptr,\n+    int32_t *s32_ptr, uint32_t *u32_ptr, float *f32_ptr,\n+    int64_t *s64_ptr, uint64_t *u64_ptr, double *f64_ptr,\n+    void *void_ptr, struct s *s_ptr, _Complex float *cf32_ptr,\n+    svint8_t s8, svuint8_t u8, svint16_t s16, svuint16_t u16, svfloat16_t f16,\n+    svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64, svfloat64_t f64, struct s s)\n+{\n+  svst1_scatter_offset (pg, s32_ptr, s32); /* { dg-error {too few arguments to function 'svst1_scatter_offset'} } */\n+  svst1_scatter_offset (pg, s32_ptr, s32, s32, 0); /* { dg-error {too many arguments to function 'svst1_scatter_offset'} } */\n+  svst1_scatter_offset (0, s32_ptr, s32, s32); /* { dg-error {passing 'int' to argument 1 of 'svst1_scatter_offset', which expects 'svbool_t'} } */\n+  svst1_scatter_offset (pg, 0, s32, s32);\n+  svst1_scatter_offset (pg, (int *) 0, s32, s32);\n+  svst1_scatter_offset (pg, void_ptr, s32, s32);\n+  svst1_scatter_offset (pg, s_ptr, s32, s32); /* { dg-warning \"passing argument 2 of 'svst1_scatter_s32offset_s32' from incompatible pointer type\" } */\n+  svst1_scatter_offset (pg, f32_ptr, s32, s32); /* { dg-warning \"passing argument 2 of 'svst1_scatter_s32offset_s32' from incompatible pointer type\" } */\n+  svst1_scatter_offset (pg, f32_ptr, s32, f32);\n+  svst1_scatter_offset (pg, cf32_ptr, s32, f32); /* { dg-warning \"passing argument 2 of 'svst1_scatter_s32offset_f32' from incompatible pointer type\" } */\n+  svst1_scatter_offset (pg, s, s32, s32); /* { dg-error {passing 'struct s' to argument 2 of 'svst1_scatter_offset', which expects a vector or pointer base address} } */\n+\n+  svst1_scatter_offset (pg, u32, void_ptr, s32); /* { dg-warning \"passing argument 3 of 'svst1_scatter_u32base_offset_s32' makes integer from pointer without a cast\" } */\n+  svst1_scatter_offset (pg, u32, pg, s32); /* { dg-error {passing 'svbool_t' to argument 3 of 'svst1_scatter_offset', which expects 'int64_t'} } */\n+  svst1_scatter_offset (pg, u32, s32, s32); /* { dg-error {passing 'svint32_t' to argument 3 of 'svst1_scatter_offset', which expects 'int64_t'} } */\n+\n+  svst1_scatter_offset (pg, void_ptr, u32, pg); /* { dg-error {passing 'svbool_t' to argument 4 of 'svst1_scatter_offset', which expects a vector of 32-bit or 64-bit elements} } */\n+\n+  svst1_scatter_offset (pg, s8_ptr, u32, s8); /* { dg-error {passing 'svint8_t' to argument 4 of 'svst1_scatter_offset', which expects a vector of 32-bit or 64-bit elements} } */\n+  svst1_scatter_offset (pg, s8_ptr, u32, u8); /* { dg-error {passing 'svuint8_t' to argument 4 of 'svst1_scatter_offset', which expects a vector of 32-bit or 64-bit elements} } */\n+\n+  svst1_scatter_offset (pg, s16_ptr, u32, s16); /* { dg-error {passing 'svint16_t' to argument 4 of 'svst1_scatter_offset', which expects a vector of 32-bit or 64-bit elements} } */\n+  svst1_scatter_offset (pg, s16_ptr, u32, u16); /* { dg-error {passing 'svuint16_t' to argument 4 of 'svst1_scatter_offset', which expects a vector of 32-bit or 64-bit elements} } */\n+  svst1_scatter_offset (pg, s16_ptr, u32, f16); /* { dg-error {passing 'svfloat16_t' to argument 4 of 'svst1_scatter_offset', which expects a vector of 32-bit or 64-bit elements} } */\n+\n+  svst1_scatter_offset (pg, u32, 0, s32);\n+  svst1_scatter_offset (pg, s32, 0, s32); /* { dg-error {passing 'svint32_t' to argument 2 of 'svst1_scatter_offset', which expects 'svuint32_t'} } */\n+\n+  svst1_scatter_offset (pg, u32, 0, u32);\n+  svst1_scatter_offset (pg, s32, 0, u32); /* { dg-error {passing 'svint32_t' to argument 2 of 'svst1_scatter_offset', which expects 'svuint32_t'} } */\n+\n+  svst1_scatter_offset (pg, u32, 0, f32);\n+  svst1_scatter_offset (pg, s32, 0, f32); /* { dg-error {passing 'svint32_t' to argument 2 of 'svst1_scatter_offset', which expects 'svuint32_t'} } */\n+\n+  svst1_scatter_offset (pg, u64, 0, s64);\n+  svst1_scatter_offset (pg, s64, 0, s64); /* { dg-error {passing 'svint64_t' to argument 2 of 'svst1_scatter_offset', which expects 'svuint64_t'} } */\n+\n+  svst1_scatter_offset (pg, u64, 0, u64);\n+  svst1_scatter_offset (pg, s64, 0, u64); /* { dg-error {passing 'svint64_t' to argument 2 of 'svst1_scatter_offset', which expects 'svuint64_t'} } */\n+\n+  svst1_scatter_offset (pg, u64, 0, f64);\n+  svst1_scatter_offset (pg, s64, 0, f64); /* { dg-error {passing 'svint64_t' to argument 2 of 'svst1_scatter_offset', which expects 'svuint64_t'} } */\n+\n+  svst1_scatter_offset (pg, s32_ptr, s32, s32);\n+  svst1_scatter_offset (pg, s32_ptr, u32, s32);\n+  svst1_scatter_offset (pg, s32_ptr, f32, s32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svint32_t' expects a vector of 32-bit integers} } */\n+  svst1_scatter_offset (pg, s32_ptr, s64, s32); /* { dg-error {passing 'svint64_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svint32_t' expects a vector of 32-bit integers} } */\n+  svst1_scatter_offset (pg, s32_ptr, u64, s32); /* { dg-error {passing 'svuint64_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svint32_t' expects a vector of 32-bit integers} } */\n+  svst1_scatter_offset (pg, s32_ptr, f64, s32); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svint32_t' expects a vector of 32-bit integers} } */\n+\n+  svst1_scatter_offset (pg, u32_ptr, s32, u32);\n+  svst1_scatter_offset (pg, u32_ptr, u32, u32);\n+  svst1_scatter_offset (pg, u32_ptr, f32, u32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svuint32_t' expects a vector of 32-bit integers} } */\n+  svst1_scatter_offset (pg, u32_ptr, s64, u32); /* { dg-error {passing 'svint64_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svuint32_t' expects a vector of 32-bit integers} } */\n+  svst1_scatter_offset (pg, u32_ptr, u64, u32); /* { dg-error {passing 'svuint64_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svuint32_t' expects a vector of 32-bit integers} } */\n+  svst1_scatter_offset (pg, u32_ptr, f64, u32); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svuint32_t' expects a vector of 32-bit integers} } */\n+\n+  svst1_scatter_offset (pg, f32_ptr, s32, f32);\n+  svst1_scatter_offset (pg, f32_ptr, u32, f32);\n+  svst1_scatter_offset (pg, f32_ptr, f32, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svfloat32_t' expects a vector of 32-bit integers} } */\n+  svst1_scatter_offset (pg, f32_ptr, s64, f32); /* { dg-error {passing 'svint64_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svfloat32_t' expects a vector of 32-bit integers} } */\n+  svst1_scatter_offset (pg, f32_ptr, u64, f32); /* { dg-error {passing 'svuint64_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svfloat32_t' expects a vector of 32-bit integers} } */\n+  svst1_scatter_offset (pg, f32_ptr, f64, f32); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svfloat32_t' expects a vector of 32-bit integers} } */\n+\n+  svst1_scatter_offset (pg, s64_ptr, s32, s64); /* { dg-error {passing 'svint32_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svint64_t' expects a vector of 64-bit integers} } */\n+  svst1_scatter_offset (pg, s64_ptr, u32, s64); /* { dg-error {passing 'svuint32_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svint64_t' expects a vector of 64-bit integers} } */\n+  svst1_scatter_offset (pg, s64_ptr, f32, s64); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svint64_t' expects a vector of 64-bit integers} } */\n+  svst1_scatter_offset (pg, s64_ptr, s64, s64);\n+  svst1_scatter_offset (pg, s64_ptr, u64, s64);\n+  svst1_scatter_offset (pg, s64_ptr, f64, s64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svint64_t' expects a vector of 64-bit integers} } */\n+\n+  svst1_scatter_offset (pg, u64_ptr, s32, u64); /* { dg-error {passing 'svint32_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svuint64_t' expects a vector of 64-bit integers} } */\n+  svst1_scatter_offset (pg, u64_ptr, u32, u64); /* { dg-error {passing 'svuint32_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svuint64_t' expects a vector of 64-bit integers} } */\n+  svst1_scatter_offset (pg, u64_ptr, f32, u64); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svuint64_t' expects a vector of 64-bit integers} } */\n+  svst1_scatter_offset (pg, u64_ptr, s64, u64);\n+  svst1_scatter_offset (pg, u64_ptr, u64, u64);\n+  svst1_scatter_offset (pg, u64_ptr, f64, u64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svuint64_t' expects a vector of 64-bit integers} } */\n+\n+  svst1_scatter_offset (pg, f64_ptr, s32, f64); /* { dg-error {passing 'svint32_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svfloat64_t' expects a vector of 64-bit integers} } */\n+  svst1_scatter_offset (pg, f64_ptr, u32, f64); /* { dg-error {passing 'svuint32_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svfloat64_t' expects a vector of 64-bit integers} } */\n+  svst1_scatter_offset (pg, f64_ptr, f32, f64); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svfloat64_t' expects a vector of 64-bit integers} } */\n+  svst1_scatter_offset (pg, f64_ptr, s64, f64);\n+  svst1_scatter_offset (pg, f64_ptr, u64, f64);\n+  svst1_scatter_offset (pg, f64_ptr, f64, f64); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svst1_scatter_offset', which when storing 'svfloat64_t' expects a vector of 64-bit integers} } */\n+}"}, {"sha": "bbd1f91bef8da751317cfb1c6a3009aaee130574", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/ternary_lane_1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_lane_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_lane_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_lane_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svfloat16_t f16, svfloat32_t f32, svfloat64_t f64,\n+    svint32_t s32, int i)\n+{\n+  svmla_lane (f32, f32, f32); /* { dg-error {too few arguments to function 'svmla_lane'} } */\n+  svmla_lane (f32, f32, f32, 0, 0); /* { dg-error {too many arguments to function 'svmla_lane'} } */\n+  svmla_lane (pg, pg, pg, 0); /* { dg-error {'svmla_lane' has no form that takes 'svbool_t' arguments} } */\n+  svmla_lane (s32, s32, s32, 0); /* { dg-error {'svmla_lane' has no form that takes 'svint32_t' arguments} } */\n+  svmla_lane (1, f32, f32, 0); /* { dg-error {passing 'int' to argument 1 of 'svmla_lane', which expects an SVE vector type} } */\n+  svmla_lane (f32, 1, f32, 0); /* { dg-error {passing 'int' to argument 2 of 'svmla_lane', which expects an SVE vector type} } */\n+  svmla_lane (f32, f32, 1, 0); /* { dg-error {passing 'int' to argument 3 of 'svmla_lane', which expects an SVE vector type} } */\n+  svmla_lane (f32, f64, f32, 0); /* { dg-error {passing 'svfloat64_t' to argument 2 of 'svmla_lane', but previous arguments had type 'svfloat32_t'} } */\n+  svmla_lane (f32, f32, f64, 0); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svmla_lane', but previous arguments had type 'svfloat32_t'} } */\n+  svmla_lane (f32, f32, f32, s32); /* { dg-error {argument 4 of 'svmla_lane' must be an integer constant expression} } */\n+  svmla_lane (f32, f32, f32, i); /* { dg-error {argument 4 of 'svmla_lane' must be an integer constant expression} } */\n+\n+  svmla_lane (f16, f16, f16, 0);\n+  svmla_lane (f16, f16, f16, 7);\n+  svmla_lane (f16, f16, f16, 8); /* { dg-error {passing 8 to argument 4 of 'svmla_lane', which expects a value in the range \\[0, 7\\]} } */\n+  svmla_lane (f16, f16, f16, -1); /* { dg-error {passing -1 to argument 4 of 'svmla_lane', which expects a value in the range \\[0, 7\\]} } */\n+\n+  svmla_lane (f32, f32, f32, 0);\n+  svmla_lane (f32, f32, f32, 3);\n+  svmla_lane (f32, f32, f32, 4); /* { dg-error {passing 4 to argument 4 of 'svmla_lane', which expects a value in the range \\[0, 3\\]} } */\n+  svmla_lane (f32, f32, f32, -1); /* { dg-error {passing -1 to argument 4 of 'svmla_lane', which expects a value in the range \\[0, 3\\]} } */\n+\n+  svmla_lane (f64, f64, f64, 0);\n+  svmla_lane (f64, f64, f64, 1);\n+  svmla_lane (f64, f64, f64, 2); /* { dg-error {passing 2 to argument 4 of 'svmla_lane', which expects a value in the range \\[0, 1\\]} } */\n+  svmla_lane (f64, f64, f64, -1); /* { dg-error {passing -1 to argument 4 of 'svmla_lane', which expects a value in the range \\[0, 1\\]} } */\n+}"}, {"sha": "bccc6c7e229d5cffe92754fc379fd1abb8b3cf68", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/ternary_lane_rotate_1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_lane_rotate_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_lane_rotate_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_lane_rotate_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svfloat16_t f16, svfloat32_t f32, svfloat64_t f64,\n+    svint32_t s32, int i)\n+{\n+  svcmla_lane (f32, f32, f32, 0); /* { dg-error {too few arguments to function 'svcmla_lane'} } */\n+  svcmla_lane (f32, f32, f32, 0, 90, 90); /* { dg-error {too many arguments to function 'svcmla_lane'} } */\n+  svcmla_lane (pg, pg, pg, 0, 90); /* { dg-error {'svcmla_lane' has no form that takes 'svbool_t' arguments} } */\n+  svcmla_lane (s32, s32, s32, 0, 90); /* { dg-error {'svcmla_lane' has no form that takes 'svint32_t' arguments} } */\n+  svcmla_lane (f64, f64, f64, 0, 90); /* { dg-error {'svcmla_lane' has no form that takes 'svfloat64_t' arguments} } */\n+  svcmla_lane (1, f32, f32, 0, 90); /* { dg-error {passing 'int' to argument 1 of 'svcmla_lane', which expects an SVE vector type} } */\n+  svcmla_lane (f32, 1, f32, 0, 90); /* { dg-error {passing 'int' to argument 2 of 'svcmla_lane', which expects an SVE vector type} } */\n+  svcmla_lane (f32, f32, 1, 0, 90); /* { dg-error {passing 'int' to argument 3 of 'svcmla_lane', which expects an SVE vector type} } */\n+  svcmla_lane (f32, f64, f32, 0, 90); /* { dg-error {passing 'svfloat64_t' to argument 2 of 'svcmla_lane', but previous arguments had type 'svfloat32_t'} } */\n+  svcmla_lane (f32, f32, f64, 0, 90); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svcmla_lane', but previous arguments had type 'svfloat32_t'} } */\n+  svcmla_lane (f32, f32, f32, s32, 0); /* { dg-error {argument 4 of 'svcmla_lane' must be an integer constant expression} } */\n+  svcmla_lane (f32, f32, f32, i, 0); /* { dg-error {argument 4 of 'svcmla_lane' must be an integer constant expression} } */\n+\n+  svcmla_lane (f16, f16, f16, 0, 0);\n+  svcmla_lane (f16, f16, f16, 3, 0);\n+  svcmla_lane (f16, f16, f16, 4, 0); /* { dg-error {passing 4 to argument 4 of 'svcmla_lane', which expects a value in the range \\[0, 3\\]} } */\n+  svcmla_lane (f16, f16, f16, -1, 0); /* { dg-error {passing -1 to argument 4 of 'svcmla_lane', which expects a value in the range \\[0, 3\\]} } */\n+\n+  svcmla_lane (f32, f32, f32, 0, 0);\n+  svcmla_lane (f32, f32, f32, 1, 0);\n+  svcmla_lane (f32, f32, f32, 2, 0); /* { dg-error {passing 2 to argument 4 of 'svcmla_lane', which expects a value in the range \\[0, 1\\]} } */\n+  svcmla_lane (f32, f32, f32, -1, 0); /* { dg-error {passing -1 to argument 4 of 'svcmla_lane', which expects a value in the range \\[0, 1\\]} } */\n+\n+  svcmla_lane (f32, f32, f32, 0, -90); /* { dg-error {passing -90 to argument 5 of 'svcmla_lane', which expects 0, 90, 180 or 270} } */\n+  svcmla_lane (f32, f32, f32, 0, 0);\n+  svcmla_lane (f32, f32, f32, 0, 1); /* { dg-error {passing 1 to argument 5 of 'svcmla_lane', which expects 0, 90, 180 or 270} } */\n+  svcmla_lane (f32, f32, f32, 0, 90);\n+  svcmla_lane (f32, f32, f32, 0, 180);\n+  svcmla_lane (f32, f32, f32, 0, 270);\n+}"}, {"sha": "c4a80e9daa2aad156693e164ef8eb09b69922154", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/ternary_opt_n_1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_opt_n_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_opt_n_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_opt_n_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svint8_t s8, svuint8_t u8,\n+    svint16_t s16, svuint16_t u16, svfloat16_t f16)\n+{\n+  svmla_x (pg, u8, u8); /* { dg-error {too few arguments to function 'svmla_x'} } */\n+  svmla_x (pg, u8, u8, u8, u8); /* { dg-error {too many arguments to function 'svmla_x'} } */\n+  svmla_x (u8, u8, u8, u8); /* { dg-error {passing 'svuint8_t' to argument 1 of 'svmla_x', which expects 'svbool_t'} } */\n+  svmla_x (pg, pg, pg, pg); /* { dg-error {'svmla_x' has no form that takes 'svbool_t' arguments} } */\n+  svmla_x (pg, 1, u8, u8); /* { dg-error {passing 'int' to argument 2 of 'svmla_x', which expects an SVE vector type} } */\n+  svmla_x (pg, u8, s8, u8); /* { dg-error {passing 'svint8_t' to argument 3 of 'svmla_x', but previous arguments had type 'svuint8_t'} } */\n+  svmla_x (pg, u8, u8, u8);\n+  svmla_x (pg, u8, s16, u8); /* { dg-error {passing 'svint16_t' to argument 3 of 'svmla_x', but previous arguments had type 'svuint8_t'} } */\n+  svmla_x (pg, u8, u16, u8); /* { dg-error {passing 'svuint16_t' to argument 3 of 'svmla_x', but previous arguments had type 'svuint8_t'} } */\n+  svmla_x (pg, u8, f16, u8); /* { dg-error {passing 'svfloat16_t' to argument 3 of 'svmla_x', but previous arguments had type 'svuint8_t'} } */\n+  svmla_x (pg, u8, pg, u8); /* { dg-error {passing 'svbool_t' to argument 3 of 'svmla_x', but previous arguments had type 'svuint8_t'} } */\n+  svmla_x (pg, u8, 0, u8); /* { dg-error {passing 'int' to argument 3 of 'svmla_x', which expects an SVE vector type} } */\n+  svmla_x (pg, u8, u8, s8); /* { dg-error {passing 'svint8_t' to argument 4 of 'svmla_x', but previous arguments had type 'svuint8_t'} } */\n+  svmla_x (pg, u8, u8, s16); /* { dg-error {passing 'svint16_t' to argument 4 of 'svmla_x', but previous arguments had type 'svuint8_t'} } */\n+  svmla_x (pg, u8, u8, u16); /* { dg-error {passing 'svuint16_t' to argument 4 of 'svmla_x', but previous arguments had type 'svuint8_t'} } */\n+  svmla_x (pg, u8, u8, f16); /* { dg-error {passing 'svfloat16_t' to argument 4 of 'svmla_x', but previous arguments had type 'svuint8_t'} } */\n+  svmla_x (pg, u8, u8, pg); /* { dg-error {passing 'svbool_t' to argument 4 of 'svmla_x', but previous arguments had type 'svuint8_t'} } */\n+  svmla_x (pg, u8, u8, 0);\n+\n+  svmla_x (pg, f16, s16, f16); /* { dg-error {passing 'svint16_t' to argument 3 of 'svmla_x', but previous arguments had type 'svfloat16_t'} } */\n+  svmla_x (pg, f16, u16, f16); /* { dg-error {passing 'svuint16_t' to argument 3 of 'svmla_x', but previous arguments had type 'svfloat16_t'} } */\n+  svmla_x (pg, f16, f16, s16); /* { dg-error {passing 'svint16_t' to argument 4 of 'svmla_x', but previous arguments had type 'svfloat16_t'} } */\n+  svmla_x (pg, f16, f16, u16); /* { dg-error {passing 'svuint16_t' to argument 4 of 'svmla_x', but previous arguments had type 'svfloat16_t'} } */\n+  svmla_x (pg, f16, f16, f16);\n+  svmla_x (pg, f16, f16, 1);\n+}"}, {"sha": "e81552b64a9954415dc841678fc44cfb967926d6", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/ternary_qq_lane_1.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_qq_lane_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_qq_lane_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_qq_lane_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svint8_t s8, svuint8_t u8, svint16_t s16, svuint16_t u16,\n+    svint32_t s32, svuint32_t u32, svint64_t s64, svuint64_t u64,\n+    svfloat32_t f32, int i)\n+{\n+  svdot_lane (u32, u8, u8); /* { dg-error {too few arguments to function 'svdot_lane'} } */\n+  svdot_lane (u32, u8, u8, 0, 0); /* { dg-error {too many arguments to function 'svdot_lane'} } */\n+  svdot_lane (0, u8, u8, 0); /* { dg-error {passing 'int' to argument 1 of 'svdot_lane', which expects an SVE vector type} } */\n+  svdot_lane (pg, u8, u8, 0); /* { dg-error {'svdot_lane' has no form that takes 'svbool_t' arguments} } */\n+  svdot_lane (u8, u8, u8, 0); /* { dg-error {'svdot_lane' has no form that takes 'svuint8_t' arguments} } */\n+  svdot_lane (f32, u8, u8, 0); /* { dg-error {'svdot_lane' has no form that takes 'svfloat32_t' arguments} } */\n+  svdot_lane (u32, u8, u8, 0);\n+  svdot_lane (u32, 0, u8, 0); /* { dg-error {passing 'int' to argument 2 of 'svdot_lane', which expects an SVE vector type} } */\n+  svdot_lane (u32, u8, 0, 0); /* { dg-error {passing 'int' to argument 3 of 'svdot_lane', which expects an SVE vector type} } */\n+\n+  svdot_lane (s32, s8, s8, 0);\n+  svdot_lane (s32, u8, s8, 0); /* { dg-error {arguments 1 and 2 of 'svdot_lane' must have the same signedness, but the values passed here have type 'svint32_t' and 'svuint8_t' respectively} } */\n+  svdot_lane (s32, s8, u8, 0); /* { dg-error {arguments 1 and 3 of 'svdot_lane' must have the same signedness, but the values passed here have type 'svint32_t' and 'svuint8_t' respectively} } */\n+  svdot_lane (s32, s32, s32, 0); /* { dg-error {passing 'svint32_t' instead of the expected 'svint8_t' to argument 2 of 'svdot_lane', after passing 'svint32_t' to argument 1} } */\n+\n+  svdot_lane (u32, u8, u8, 0);\n+  svdot_lane (u32, s8, u8, 0); /* { dg-error {arguments 1 and 2 of 'svdot_lane' must have the same signedness, but the values passed here have type 'svuint32_t' and 'svint8_t' respectively} } */\n+  svdot_lane (u32, u8, s8, 0); /* { dg-error {arguments 1 and 3 of 'svdot_lane' must have the same signedness, but the values passed here have type 'svuint32_t' and 'svint8_t' respectively} } */\n+  svdot_lane (u32, u32, u32, 0); /* { dg-error {passing 'svuint32_t' instead of the expected 'svuint8_t' to argument 2 of 'svdot_lane', after passing 'svuint32_t' to argument 1} } */\n+\n+  svdot_lane (s64, s16, s16, 0);\n+  svdot_lane (s64, u16, s16, 0); /* { dg-error {arguments 1 and 2 of 'svdot_lane' must have the same signedness, but the values passed here have type 'svint64_t' and 'svuint16_t' respectively} } */\n+  svdot_lane (s64, s16, u16, 0); /* { dg-error {arguments 1 and 3 of 'svdot_lane' must have the same signedness, but the values passed here have type 'svint64_t' and 'svuint16_t' respectively} } */\n+  svdot_lane (s64, s64, s64, 0); /* { dg-error {passing 'svint64_t' instead of the expected 'svint16_t' to argument 2 of 'svdot_lane', after passing 'svint64_t' to argument 1} } */\n+\n+  svdot_lane (u64, u16, u16, 0);\n+  svdot_lane (u64, s16, u16, 0); /* { dg-error {arguments 1 and 2 of 'svdot_lane' must have the same signedness, but the values passed here have type 'svuint64_t' and 'svint16_t' respectively} } */\n+  svdot_lane (u64, u16, s16, 0); /* { dg-error {arguments 1 and 3 of 'svdot_lane' must have the same signedness, but the values passed here have type 'svuint64_t' and 'svint16_t' respectively} } */\n+  svdot_lane (u64, u64, u64, 0); /* { dg-error {passing 'svuint64_t' instead of the expected 'svuint16_t' to argument 2 of 'svdot_lane', after passing 'svuint64_t' to argument 1} } */\n+\n+  svdot_lane (s32, s8, s8, i); /* { dg-error {argument 4 of 'svdot_lane' must be an integer constant expression} } */\n+  svdot_lane (s32, s8, s8, 0);\n+  svdot_lane (s32, s8, s8, 3);\n+  svdot_lane (s32, s8, s8, 4);  /* { dg-error {passing 4 to argument 4 of 'svdot_lane', which expects a value in the range \\[0, 3\\]} } */\n+  svdot_lane (s32, s8, s8, -1);  /* { dg-error {passing -1 to argument 4 of 'svdot_lane', which expects a value in the range \\[0, 3\\]} } */\n+\n+  svdot_lane (u32, u8, u8, i); /* { dg-error {argument 4 of 'svdot_lane' must be an integer constant expression} } */\n+  svdot_lane (u32, u8, u8, 0);\n+  svdot_lane (u32, u8, u8, 3);\n+  svdot_lane (u32, u8, u8, 4);  /* { dg-error {passing 4 to argument 4 of 'svdot_lane', which expects a value in the range \\[0, 3\\]} } */\n+  svdot_lane (u32, u8, u8, -1);  /* { dg-error {passing -1 to argument 4 of 'svdot_lane', which expects a value in the range \\[0, 3\\]} } */\n+\n+  svdot_lane (s64, s16, s16, i); /* { dg-error {argument 4 of 'svdot_lane' must be an integer constant expression} } */\n+  svdot_lane (s64, s16, s16, 0);\n+  svdot_lane (s64, s16, s16, 1);\n+  svdot_lane (s64, s16, s16, 2);  /* { dg-error {passing 2 to argument 4 of 'svdot_lane', which expects a value in the range \\[0, 1\\]} } */\n+  svdot_lane (s64, s16, s16, -1);  /* { dg-error {passing -1 to argument 4 of 'svdot_lane', which expects a value in the range \\[0, 1\\]} } */\n+\n+  svdot_lane (u64, u16, u16, i); /* { dg-error {argument 4 of 'svdot_lane' must be an integer constant expression} } */\n+  svdot_lane (u64, u16, u16, 0);\n+  svdot_lane (u64, u16, u16, 1);\n+  svdot_lane (u64, u16, u16, 2);  /* { dg-error {passing 2 to argument 4 of 'svdot_lane', which expects a value in the range \\[0, 1\\]} } */\n+  svdot_lane (u64, u16, u16, -1);  /* { dg-error {passing -1 to argument 4 of 'svdot_lane', which expects a value in the range \\[0, 1\\]} } */\n+}"}, {"sha": "b41e6fcceb4d227bd6d4d56fb7f618480f157e75", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/ternary_qq_opt_n_1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_qq_opt_n_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_qq_opt_n_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_qq_opt_n_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+svint32_t\n+f1 (svuint32_t u32, svuint8_t u8, svint8_t s8)\n+{\n+  svdot_u32 (u32); /* { dg-error {too few arguments to function 'svdot_u32'} } */\n+  svdot_u32 (u32, u8, u8, u32); /* { dg-error {too many arguments to function 'svdot_u32'} } */\n+  svdot_u32 (u32, u32, u8); /* { dg-error {incompatible type for argument 2 of 'svdot_u32'} } */\n+  svdot_u32 (u32, s8, u8); /* { dg-error {incompatible type for argument 2 of 'svdot_u32'} } */\n+  svdot_u32 (u32, u8, u32); /* { dg-error {incompatible type for argument 3 of 'svdot_u32'} } */\n+  svdot_u32 (u32, u8, s8); /* { dg-error {incompatible type for argument 3 of 'svdot_u32'} } */\n+  return svdot_u32 (u32, u8, u8); /* { dg-error {incompatible types when returning type 'svuint32_t' but 'svint32_t' was expected} } */\n+}"}, {"sha": "fee4096fe0e33999d86a96200cbabf77e1cd6d94", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/ternary_qq_opt_n_2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_qq_opt_n_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_qq_opt_n_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_qq_opt_n_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svint8_t s8, svuint8_t u8, svuint32_t u32,\n+    svfloat32_t f32)\n+{\n+  svdot (u32, u8); /* { dg-error {too few arguments to function 'svdot'} } */\n+  svdot (u32, u8, u8, u8); /* { dg-error {too many arguments to function 'svdot'} } */\n+  svdot (0, u8, u8); /* { dg-error {passing 'int' to argument 1 of 'svdot', which expects an SVE vector type} } */\n+  svdot (pg, u8, u8); /* { dg-error {'svdot' has no form that takes 'svbool_t' arguments} } */\n+  svdot (u8, u8, u8); /* { dg-error {'svdot' has no form that takes 'svuint8_t' arguments} } */\n+  svdot (f32, u8, u8); /* { dg-error {'svdot' has no form that takes 'svfloat32_t' arguments} } */\n+  svdot (u32, u8, u8);\n+  svdot (u32, 0, u8); /* { dg-error {passing 'int' to argument 2 of 'svdot', which expects an SVE vector type} } */\n+  svdot (u32, s8, u8); /* { dg-error {arguments 1 and 2 of 'svdot' must have the same signedness, but the values passed here have type 'svuint32_t' and 'svint8_t' respectively} } */\n+  svdot (u32, u8, 0);\n+  svdot (u32, u8, s8); /* { dg-error {arguments 1 and 3 of 'svdot' must have the same signedness, but the values passed here have type 'svuint32_t' and 'svint8_t' respectively} } */\n+  svdot (u32, u32, u32); /* { dg-error {passing 'svuint32_t' instead of the expected 'svuint8_t' to argument 2 of 'svdot', after passing 'svuint32_t' to argument 1} } */\n+}"}, {"sha": "f340e3d1e75cc914b5b1ee81585b9f5c7bbd0dff", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/ternary_rotate_1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_rotate_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_rotate_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fternary_rotate_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svfloat32_t f32, svfloat64_t f64, svint32_t s32, int i)\n+{\n+  svcmla_x (pg, f32, f32, f32); /* { dg-error {too few arguments to function 'svcmla_x'} } */\n+  svcmla_x (pg, f32, f32, f32, 90, 90); /* { dg-error {too many arguments to function 'svcmla_x'} } */\n+  svcmla_x (f32, f32, f32, f32, 90); /* { dg-error {passing 'svfloat32_t' to argument 1 of 'svcmla_x', which expects 'svbool_t'} } */\n+  svcmla_x (pg, pg, pg, pg, 90); /* { dg-error {'svcmla_x' has no form that takes 'svbool_t' arguments} } */\n+  svcmla_x (pg, s32, s32, s32, 90); /* { dg-error {'svcmla_x' has no form that takes 'svint32_t' arguments} } */\n+  svcmla_x (pg, 1, f32, f32, 90); /* { dg-error {passing 'int' to argument 2 of 'svcmla_x', which expects an SVE vector type} } */\n+  svcmla_x (pg, f32, 1, f32, 90); /* { dg-error {passing 'int' to argument 3 of 'svcmla_x', which expects an SVE vector type} } */\n+  svcmla_x (pg, f32, f32, 1, 90); /* { dg-error {passing 'int' to argument 4 of 'svcmla_x', which expects an SVE vector type} } */\n+  svcmla_x (pg, f32, f64, f32, 90); /* { dg-error {passing 'svfloat64_t' to argument 3 of 'svcmla_x', but previous arguments had type 'svfloat32_t'} } */\n+  svcmla_x (pg, f32, f32, f64, 90); /* { dg-error {passing 'svfloat64_t' to argument 4 of 'svcmla_x', but previous arguments had type 'svfloat32_t'} } */\n+  svcmla_x (pg, f32, f32, f32, s32); /* { dg-error {argument 5 of 'svcmla_x' must be an integer constant expression} } */\n+  svcmla_x (pg, f32, f32, f32, i); /* { dg-error {argument 5 of 'svcmla_x' must be an integer constant expression} } */\n+  svcmla_x (pg, f32, f32, f32, -90); /* { dg-error {passing -90 to argument 5 of 'svcmla_x', which expects 0, 90, 180 or 270} } */\n+  svcmla_x (pg, f32, f32, f32, 0);\n+  svcmla_x (pg, f32, f32, f32, 1); /* { dg-error {passing 1 to argument 5 of 'svcmla_x', which expects 0, 90, 180 or 270} } */\n+  svcmla_x (pg, f32, f32, f32, 90);\n+  svcmla_x (pg, f32, f32, f32, 180);\n+  svcmla_x (pg, f32, f32, f32, 270);\n+}"}, {"sha": "8b98fc24d661a0517611404e47e0235e86d6db3a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/tmad_1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftmad_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftmad_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftmad_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svfloat32_t f32, svfloat64_t f64, svint32_t s32, int i)\n+{\n+  svtmad (f32, f32); /* { dg-error {too few arguments to function 'svtmad'} } */\n+  svtmad (f32, f32, 0, 0); /* { dg-error {too many arguments to function 'svtmad'} } */\n+  svtmad (pg, pg, 0); /* { dg-error {'svtmad' has no form that takes 'svbool_t' arguments} } */\n+  svtmad (s32, s32, 0); /* { dg-error {'svtmad' has no form that takes 'svint32_t' arguments} } */\n+  svtmad (1, f32, 0); /* { dg-error {passing 'int' to argument 1 of 'svtmad', which expects an SVE vector type} } */\n+  svtmad (f32, 1, 0); /* { dg-error {passing 'int' to argument 2 of 'svtmad', which expects an SVE vector type} } */\n+  svtmad (f32, f64, 0); /* { dg-error {passing 'svfloat64_t' to argument 2 of 'svtmad', but previous arguments had type 'svfloat32_t'} } */\n+  svtmad (f32, f32, s32); /* { dg-error {argument 3 of 'svtmad' must be an integer constant expression} } */\n+  svtmad (f32, f32, i); /* { dg-error {argument 3 of 'svtmad' must be an integer constant expression} } */\n+  svtmad (f32, f32, -1); /* { dg-error {passing -1 to argument 3 of 'svtmad', which expects a value in the range \\[0, 7\\]} } */\n+  svtmad (f32, f32, 0);\n+  svtmad (f32, f32, 1);\n+  svtmad (f32, f32, 7);\n+  svtmad (f32, f32, 8); /* { dg-error {passing 8 to argument 3 of 'svtmad', which expects a value in the range \\[0, 7\\]} } */\n+}"}, {"sha": "70b2d9dd1aba0b27e95e64f0bc2792aa460f69c5", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_1.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+int svbool_t; /* { dg-message \"note: previous declaration of 'svbool_t' was here\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"  /* { dg-error {'svbool_t' redeclared} } */"}, {"sha": "8278c1cad3e68568f3af52a8a23183f269e40b60", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_10.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_10.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+typedef struct svint8x2_t svint8x2_t; /* { dg-message \"note: previous declaration of 'svint8x2_t' was here\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"  /* { dg-error {conflicting types for 'svint8x2_t'} } */"}, {"sha": "2147df72cfd23041876414cb4bc93a195031d053", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_11.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_11.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+\n+/* This isn't explicitly allowed or disallowed, but mustn't ICE.  */\n+struct svint8x2_t;\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+void\n+f (svint8x2_t *a, struct svint8x2_t *b)\n+{\n+  *a = *b; /* { dg-error {dereferencing pointer to incomplete type} } */\n+}"}, {"sha": "1a6ccbd05422c1418f8675f30a39a74a168d8e52", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_12.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_12.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+\n+/* This isn't explicitly allowed or disallowed, but mustn't ICE.  */\n+struct svint8x2_t { int x; };\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+void\n+f (svint8x2_t *a, struct svint8x2_t *b)\n+{\n+  *a = *b; /* { dg-error {incompatible types} } */\n+}"}, {"sha": "62bab1f8469b6fdc59e305e5e259ac7af2d28d45", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_13.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_13.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"  /* { dg-message \"note: previous declaration of 'svint8x2_t' was here\" } */\n+\n+int svint8x2_t;  /* { dg-error {'svint8x2_t' redeclared} } */"}, {"sha": "0f00db1fbd41f25d938b00f133bd2510159ff9d1", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_14.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_14.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+enum svpattern { FOO }; /* { dg-message \"note: originally defined here\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-error {redeclaration of 'enum svpattern'} } */"}, {"sha": "ea972174972ccd461cbaa99816d42ea862bea44d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_15.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_15.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-message \"note: originally defined here\" } */\n+\n+enum svpattern { FOO }; /* { dg-error {redeclaration of 'enum svpattern'} } */\n+enum foo { SV_ALL }; /* { dg-error {redeclaration of enumerator 'SV_ALL'} } */\n+typedef int SV_POW2; /* { dg-error {'SV_POW2' redeclared as different kind of symbol} } */\n+int SV_VL3; /* { dg-error {'SV_VL3' redeclared as different kind of symbol} } */"}, {"sha": "a59dabc6cfb5edc8bfcc56aa35a441c5ec618e3f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_16.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_16.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+struct svpattern { int x; };\n+\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-error {'svpattern' defined as wrong kind of tag} } */"}, {"sha": "027fdb2b96b250631157ff91621cc960d67a78e3", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_17.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_17.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+struct svpattern { int x; }; /* { dg-error {'svpattern' defined as wrong kind of tag} } */"}, {"sha": "b6706150be1871d2dc8be8efe03ac2bdc988c9da", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_18.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_18.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+int svpattern; /* OK in C.  */\n+\n+#pragma GCC aarch64 \"arm_sve.h\""}, {"sha": "c6379f76260080c1ccd34935594d4db16ce21f50", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_19.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_19.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+int svpattern; /* OK in C.  */"}, {"sha": "ffd86ae7bfef3eda0f29ac81c1b8ead827c1fb35", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_2.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+int svint8_t; /* { dg-message \"note: previous declaration of 'svint8_t' was here\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"  /* { dg-error {'svint8_t' redeclared} } */"}, {"sha": "3d770a9560f832ddf88e60c1c2bbdfb04c8c6365", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_20.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_20.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+\n+enum foo { SV_VL4 };\n+typedef int SV_POW2;\n+int SV_ALL;\n+\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-error {redeclaration of enumerator 'SV_VL4'} } */\n+/* { dg-error {'SV_POW2' redeclared as different kind of symbol} \"\" { target *-*-* } .-1 } */\n+/* { dg-error {'SV_ALL' redeclared as different kind of symbol} \"\" { target *-*-* } .-2 } */"}, {"sha": "f42dd96804f0197c8745f6d4ad289faf444d2667", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_3.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+int svuint16_t; /* { dg-message \"note: previous declaration of 'svuint16_t' was here\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"  /* { dg-error {'svuint16_t' redeclared} } */"}, {"sha": "91c95a1f5fb41f0a8d870e7b9f4136fca112d84d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_4.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_4.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+int svfloat32_t; /* { dg-message \"note: previous declaration of 'svfloat32_t' was here\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"  /* { dg-error {'svfloat32_t' redeclared} } */"}, {"sha": "3cb6b8a1c981ab41e03a00a39b914adc9eac0275", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_5.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_5.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+typedef int svbool_t; /* { dg-message \"note: previous declaration of 'svbool_t' was here\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"  /* { dg-error {conflicting types for 'svbool_t'} } */"}, {"sha": "c051897b6d1679fa407d1cec24e9b3b4af50412d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_6.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_6.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+\n+typedef __SVBool_t svbool_t; /* { dg-message \"note: previous declaration of 'svbool_t' was here\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-error {redefinition of typedef 'svbool_t'} } */\n+"}, {"sha": "fd40631549d01cfa8f5d27e2388675369523dacc", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_7.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_7.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu90\" } */\n+\n+typedef __SVBool_t svbool_t;\n+\n+/* Without -pedantic-errors this should compile.  */\n+#pragma GCC aarch64 \"arm_sve.h\""}, {"sha": "41614a3045f763418a90d4e8600bc85348fdb89f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_8.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_8.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+int svint8x2_t; /* { dg-message \"note: previous declaration of 'svint8x2_t' was here\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"  /* { dg-error {'svint8x2_t' redeclared} } */"}, {"sha": "83b6855df9b085015b9b141e3823129ee8bffdba", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/type_redef_9.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Ftype_redef_9.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+\n+typedef int svint8x2_t; /* { dg-message \"note: previous declaration of 'svint8x2_t' was here\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"  /* { dg-error {conflicting types for 'svint8x2_t'} } */"}, {"sha": "eef85a01d9ec95224e1600d5e69ff690962282c6", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/unary_1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svint32_t s32, svuint32_t u32, svfloat32_t f32)\n+{\n+  svabs_m (s32, pg); /* { dg-error {too few arguments to function 'svabs_m'} } */\n+  svabs_m (s32, pg, s32, s32); /* { dg-error {too many arguments to function 'svabs_m'} } */\n+  svabs_m (0, pg, s32); /* { dg-error {passing 'int' to argument 1 of 'svabs_m', which expects an SVE vector type} } */\n+  svabs_m (s32, s32, s32); /* { dg-error {passing 'svint32_t' to argument 2 of 'svabs_m', which expects 'svbool_t'} } */\n+  svabs_m (s32, 0, s32); /* { dg-error {passing 'int' to argument 2 of 'svabs_m', which expects 'svbool_t'} } */\n+  svabs_m (s32, pg, s32);\n+  svabs_m (u32, pg, u32); /* { dg-error {'svabs_m' has no form that takes 'svuint32_t' arguments} } */\n+  svabs_m (f32, pg, f32);\n+  svabs_m (s32, pg, u32); /* { dg-error {passing 'svuint32_t' to argument 3 of 'svabs_m', but previous arguments had type 'svint32_t'} } */\n+  svabs_m (s32, pg, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svabs_m', but previous arguments had type 'svint32_t'} } */\n+  svabs_m (s32, pg, pg); /* { dg-error {passing 'svbool_t' to argument 3 of 'svabs_m', but previous arguments had type 'svint32_t'} } */\n+  svabs_m (pg, pg, s32); /* { dg-error {passing 'svint32_t' to argument 3 of 'svabs_m', but previous arguments had type 'svbool_t'} } */\n+  svabs_m (pg, pg, pg); /* { dg-error {'svabs_m' has no form that takes 'svbool_t' arguments} } */\n+}"}, {"sha": "e94673a66f52c566412e438b2a5b54732c52bab9", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/unary_2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svint8_t s8, svuint8_t u8)\n+{\n+  svabs_x (pg); /* { dg-error {too few arguments to function 'svabs_x'} } */\n+  svabs_x (pg, s8, s8); /* { dg-error {too many arguments to function 'svabs_x'} } */\n+  svabs_x (s8, s8); /* { dg-error {passing 'svint8_t' to argument 1 of 'svabs_x', which expects 'svbool_t'} } */\n+  svabs_x (pg, pg); /* { dg-error {'svabs_x' has no form that takes 'svbool_t' arguments} } */\n+  svabs_x (pg, 1); /* { dg-error {passing 'int' to argument 2 of 'svabs_x', which expects an SVE vector type} } */\n+  svabs_x (pg, s8);\n+  svabs_x (pg, u8); /* { dg-error {'svabs_x' has no form that takes 'svuint8_t' arguments} } */\n+}"}, {"sha": "caa4e623d3f5f85dd4bed35bc0974b2b7270a01a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/unary_convert_1.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_convert_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_convert_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_convert_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,73 @@\n+#include <arm_sve.h>\n+\n+void\n+test (svbool_t pg, svint8_t s8, svuint8_t u8,\n+      svint16_t s16, svuint16_t u16, svint32_t s32, svuint32_t u32,\n+      svint64_t s64, svuint64_t u64, svfloat16_t f16, svfloat32_t f32,\n+      svfloat64_t f64)\n+{\n+  svcvt_f64_x (pg); /* { dg-error {too few arguments to function 'svcvt_f64_x'} } */\n+  svcvt_f64_x (pg, s32, 0); /* { dg-error {too many arguments to function 'svcvt_f64_x'} } */\n+  svcvt_f64_x (s32, s32); /* { dg-error {passing 'svint32_t' to argument 1 of 'svcvt_f64_x', which expects 'svbool_t'} } */\n+  svcvt_f64_x (pg, 0); /* { dg-error {passing 'int' to argument 2 of 'svcvt_f64_x', which expects an SVE vector type} } */\n+\n+  svcvt_f64_x (pg, s8); /* { dg-error {'svcvt_f64_x' has no form that takes 'svint8_t' arguments} } */\n+  svcvt_f64_x (pg, s16); /* { dg-error {'svcvt_f64_x' has no form that takes 'svint16_t' arguments} } */\n+  svcvt_f64_x (pg, s32);\n+  svcvt_f64_x (pg, s64);\n+  svcvt_f64_x (pg, u8); /* { dg-error {'svcvt_f64_x' has no form that takes 'svuint8_t' arguments} } */\n+  svcvt_f64_x (pg, u16); /* { dg-error {'svcvt_f64_x' has no form that takes 'svuint16_t' arguments} } */\n+  svcvt_f64_x (pg, u32);\n+  svcvt_f64_x (pg, u64);\n+  svcvt_f64_x (pg, f16);\n+  svcvt_f64_x (pg, f32);\n+  svcvt_f64_x (pg, f64); /* { dg-error {'svcvt_f64_x' has no form that takes 'svfloat64_t' arguments} } */\n+\n+  svcvt_f32_x (pg, s8); /* { dg-error {'svcvt_f32_x' has no form that takes 'svint8_t' arguments} } */\n+  svcvt_f32_x (pg, s16); /* { dg-error {'svcvt_f32_x' has no form that takes 'svint16_t' arguments} } */\n+  svcvt_f32_x (pg, s32);\n+  svcvt_f32_x (pg, s64);\n+  svcvt_f32_x (pg, u8); /* { dg-error {'svcvt_f32_x' has no form that takes 'svuint8_t' arguments} } */\n+  svcvt_f32_x (pg, u16); /* { dg-error {'svcvt_f32_x' has no form that takes 'svuint16_t' arguments} } */\n+  svcvt_f32_x (pg, u32);\n+  svcvt_f32_x (pg, u64);\n+  svcvt_f32_x (pg, f16);\n+  svcvt_f32_x (pg, f32); /* { dg-error {'svcvt_f32_x' has no form that takes 'svfloat32_t' arguments} } */\n+  svcvt_f32_x (pg, f64);\n+\n+  svcvt_f16_x (pg, s8); /* { dg-error {'svcvt_f16_x' has no form that takes 'svint8_t' arguments} } */\n+  svcvt_f16_x (pg, s16);\n+  svcvt_f16_x (pg, s32);\n+  svcvt_f16_x (pg, s64);\n+  svcvt_f16_x (pg, u8); /* { dg-error {'svcvt_f16_x' has no form that takes 'svuint8_t' arguments} } */\n+  svcvt_f16_x (pg, u16);\n+  svcvt_f16_x (pg, u32);\n+  svcvt_f16_x (pg, u64);\n+  svcvt_f16_x (pg, f16); /* { dg-error {'svcvt_f16_x' has no form that takes 'svfloat16_t' arguments} } */\n+  svcvt_f16_x (pg, f32);\n+  svcvt_f16_x (pg, f64);\n+\n+  svcvt_s64_x (pg, f16);\n+  svcvt_s64_x (pg, f32);\n+  svcvt_s64_x (pg, f64);\n+\n+  svcvt_s32_x (pg, f16);\n+  svcvt_s32_x (pg, f32);\n+  svcvt_s32_x (pg, f64);\n+\n+  svcvt_s16_x (pg, f16);\n+  svcvt_s16_x (pg, f32); /* { dg-error {'svcvt_s16_x' has no form that takes 'svfloat32_t' arguments} } */\n+  svcvt_s16_x (pg, f64); /* { dg-error {'svcvt_s16_x' has no form that takes 'svfloat64_t' arguments} } */\n+\n+  svcvt_u64_x (pg, f16);\n+  svcvt_u64_x (pg, f32);\n+  svcvt_u64_x (pg, f64);\n+\n+  svcvt_u32_x (pg, f16);\n+  svcvt_u32_x (pg, f32);\n+  svcvt_u32_x (pg, f64);\n+\n+  svcvt_u16_x (pg, f16);\n+  svcvt_u16_x (pg, f32); /* { dg-error {'svcvt_u16_x' has no form that takes 'svfloat32_t' arguments} } */\n+  svcvt_u16_x (pg, f64); /* { dg-error {'svcvt_u16_x' has no form that takes 'svfloat64_t' arguments} } */\n+}"}, {"sha": "ddbd93b697c356064976303b494f5471af7af006", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/unary_convert_2.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_convert_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_convert_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_convert_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,76 @@\n+#include <arm_sve.h>\n+\n+void\n+test (svbool_t pg, svint8_t s8, svuint8_t u8,\n+      svint16_t s16, svuint16_t u16, svint32_t s32, svuint32_t u32,\n+      svint64_t s64, svuint64_t u64, svfloat16_t f16, svfloat32_t f32,\n+      svfloat64_t f64)\n+{\n+  svcvt_f64_m (f64, pg); /* { dg-error {too few arguments to function 'svcvt_f64_m'} } */\n+  svcvt_f64_m (f64, pg, s32, 0); /* { dg-error {too many arguments to function 'svcvt_f64_m'} } */\n+  svcvt_f64_m (f32, pg, s32); /* { dg-error {passing 'svfloat32_t' to argument 1 of 'svcvt_f64_m', which expects 'svfloat64_t'} } */\n+  svcvt_f64_m (0, pg, s32); /* { dg-error {passing 'int' to argument 1 of 'svcvt_f64_m', which expects 'svfloat64_t'} } */\n+  svcvt_f64_m (pg, pg, s32); /* { dg-error {passing 'svbool_t' to argument 1 of 'svcvt_f64_m', which expects 'svfloat64_t'} } */\n+  svcvt_f64_m (f64, s32, s32); /* { dg-error {passing 'svint32_t' to argument 2 of 'svcvt_f64_m', which expects 'svbool_t'} } */\n+  svcvt_f64_m (f64, pg, 0); /* { dg-error {passing 'int' to argument 3 of 'svcvt_f64_m', which expects an SVE vector type} } */\n+\n+  svcvt_f64_m (f64, pg, s8); /* { dg-error {'svcvt_f64_m' has no form that takes 'svint8_t' arguments} } */\n+  svcvt_f64_m (f64, pg, s16); /* { dg-error {'svcvt_f64_m' has no form that takes 'svint16_t' arguments} } */\n+  svcvt_f64_m (f64, pg, s32);\n+  svcvt_f64_m (f64, pg, s64);\n+  svcvt_f64_m (f64, pg, u8); /* { dg-error {'svcvt_f64_m' has no form that takes 'svuint8_t' arguments} } */\n+  svcvt_f64_m (f64, pg, u16); /* { dg-error {'svcvt_f64_m' has no form that takes 'svuint16_t' arguments} } */\n+  svcvt_f64_m (f64, pg, u32);\n+  svcvt_f64_m (f64, pg, u64);\n+  svcvt_f64_m (f64, pg, f16);\n+  svcvt_f64_m (f64, pg, f32);\n+  svcvt_f64_m (f64, pg, f64); /* { dg-error {'svcvt_f64_m' has no form that takes 'svfloat64_t' arguments} } */\n+\n+  svcvt_f32_m (f32, pg, s8); /* { dg-error {'svcvt_f32_m' has no form that takes 'svint8_t' arguments} } */\n+  svcvt_f32_m (f32, pg, s16); /* { dg-error {'svcvt_f32_m' has no form that takes 'svint16_t' arguments} } */\n+  svcvt_f32_m (f32, pg, s32);\n+  svcvt_f32_m (f32, pg, s64);\n+  svcvt_f32_m (f32, pg, u8); /* { dg-error {'svcvt_f32_m' has no form that takes 'svuint8_t' arguments} } */\n+  svcvt_f32_m (f32, pg, u16); /* { dg-error {'svcvt_f32_m' has no form that takes 'svuint16_t' arguments} } */\n+  svcvt_f32_m (f32, pg, u32);\n+  svcvt_f32_m (f32, pg, u64);\n+  svcvt_f32_m (f32, pg, f16);\n+  svcvt_f32_m (f32, pg, f32); /* { dg-error {'svcvt_f32_m' has no form that takes 'svfloat32_t' arguments} } */\n+  svcvt_f32_m (f32, pg, f64);\n+\n+  svcvt_f16_m (f16, pg, s8); /* { dg-error {'svcvt_f16_m' has no form that takes 'svint8_t' arguments} } */\n+  svcvt_f16_m (f16, pg, s16);\n+  svcvt_f16_m (f16, pg, s32);\n+  svcvt_f16_m (f16, pg, s64);\n+  svcvt_f16_m (f16, pg, u8); /* { dg-error {'svcvt_f16_m' has no form that takes 'svuint8_t' arguments} } */\n+  svcvt_f16_m (f16, pg, u16);\n+  svcvt_f16_m (f16, pg, u32);\n+  svcvt_f16_m (f16, pg, u64);\n+  svcvt_f16_m (f16, pg, f16); /* { dg-error {'svcvt_f16_m' has no form that takes 'svfloat16_t' arguments} } */\n+  svcvt_f16_m (f16, pg, f32);\n+  svcvt_f16_m (f16, pg, f64);\n+\n+  svcvt_s64_m (s64, pg, f16);\n+  svcvt_s64_m (s64, pg, f32);\n+  svcvt_s64_m (s64, pg, f64);\n+\n+  svcvt_s32_m (s32, pg, f16);\n+  svcvt_s32_m (s32, pg, f32);\n+  svcvt_s32_m (s32, pg, f64);\n+\n+  svcvt_s16_m (s16, pg, f16);\n+  svcvt_s16_m (s16, pg, f32); /* { dg-error {'svcvt_s16_m' has no form that takes 'svfloat32_t' arguments} } */\n+  svcvt_s16_m (s16, pg, f64); /* { dg-error {'svcvt_s16_m' has no form that takes 'svfloat64_t' arguments} } */\n+\n+  svcvt_u64_m (u64, pg, f16);\n+  svcvt_u64_m (u64, pg, f32);\n+  svcvt_u64_m (u64, pg, f64);\n+\n+  svcvt_u32_m (u32, pg, f16);\n+  svcvt_u32_m (u32, pg, f32);\n+  svcvt_u32_m (u32, pg, f64);\n+\n+  svcvt_u16_m (u16, pg, f16);\n+  svcvt_u16_m (u16, pg, f32); /* { dg-error {'svcvt_u16_m' has no form that takes 'svfloat32_t' arguments} } */\n+  svcvt_u16_m (u16, pg, f64); /* { dg-error {'svcvt_u16_m' has no form that takes 'svfloat64_t' arguments} } */\n+}"}, {"sha": "888b52513ef60bcd069bc7b166638b81e04bd87f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/unary_count_1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_count_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_count_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_count_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64)\n+{\n+  svclz_m (u32, pg); /* { dg-error {too few arguments to function 'svclz_m'} } */\n+  svclz_m (u32, pg, s32, s32); /* { dg-error {too many arguments to function 'svclz_m'} } */\n+  svclz_m (0, pg, f32); /* { dg-error {passing 'int' to argument 1 of 'svclz_m', which expects an SVE vector type} } */\n+  svclz_m (u32, u32, f32); /* { dg-error {passing 'svuint32_t' to argument 2 of 'svclz_m', which expects 'svbool_t'} } */\n+  svclz_m (u32, 0, f32); /* { dg-error {passing 'int' to argument 2 of 'svclz_m', which expects 'svbool_t'} } */\n+  svclz_m (u32, pg, s32);\n+  svclz_m (u32, pg, u32);\n+  svclz_m (u32, pg, f32); /* { dg-error {'svclz_m' has no form that takes 'svfloat32_t' arguments} } */\n+  svclz_m (u32, pg, pg); /* { dg-error {'svclz_m' has no form that takes 'svbool_t' arguments} } */\n+\n+  svclz_m (pg, pg, s32); /* { dg-error {passing 'svbool_t' to argument 1 of 'svclz_m', which expects a vector of unsigned integers} } */\n+  svclz_m (s32, pg, s32); /* { dg-error {passing 'svint32_t' to argument 1 of 'svclz_m', which expects a vector of unsigned integers} } */\n+  svclz_m (f32, pg, s32); /* { dg-error {passing 'svfloat32_t' to argument 1 of 'svclz_m', which expects a vector of unsigned integers} } */\n+  svclz_m (s64, pg, s32); /* { dg-error {passing 'svint64_t' to argument 1 of 'svclz_m', which expects a vector of unsigned integers} } */\n+  svclz_m (u64, pg, s32); /* { dg-error {arguments 1 and 3 of 'svclz_m' must have the same element size, but the values passed here have type 'svuint64_t' and 'svint32_t' respectively} } */\n+}"}, {"sha": "233e847e9037771c8693072c2445067d048f7b31", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/unary_count_2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_count_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_count_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_count_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-flax-vector-conversions\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+    svint64_t s64, svuint64_t u64)\n+{\n+  svclz_m (u32, pg); /* { dg-error {too few arguments to function 'svclz_m'} } */\n+  svclz_m (u32, pg, s32, s32); /* { dg-error {too many arguments to function 'svclz_m'} } */\n+  svclz_m (0, pg, f32); /* { dg-error {passing 'int' to argument 1 of 'svclz_m', which expects an SVE vector type} } */\n+  svclz_m (u32, u32, f32); /* { dg-error {passing 'svuint32_t' to argument 2 of 'svclz_m', which expects 'svbool_t'} } */\n+  svclz_m (u32, 0, f32); /* { dg-error {passing 'int' to argument 2 of 'svclz_m', which expects 'svbool_t'} } */\n+  svclz_m (u32, pg, s32);\n+  svclz_m (u32, pg, u32);\n+  svclz_m (u32, pg, f32); /* { dg-error {'svclz_m' has no form that takes 'svfloat32_t' arguments} } */\n+  svclz_m (u32, pg, pg); /* { dg-error {'svclz_m' has no form that takes 'svbool_t' arguments} } */\n+\n+  svclz_m (pg, pg, s32); /* { dg-error {passing 'svbool_t' to argument 1 of 'svclz_m', which expects a vector of unsigned integers} } */\n+  svclz_m (s32, pg, s32); /* { dg-error {passing 'svint32_t' to argument 1 of 'svclz_m', which expects a vector of unsigned integers} } */\n+  svclz_m (f32, pg, s32); /* { dg-error {passing 'svfloat32_t' to argument 1 of 'svclz_m', which expects a vector of unsigned integers} } */\n+  svclz_m (s64, pg, s32); /* { dg-error {passing 'svint64_t' to argument 1 of 'svclz_m', which expects a vector of unsigned integers} } */\n+  svclz_m (u64, pg, s32); /* { dg-error {arguments 1 and 3 of 'svclz_m' must have the same element size, but the values passed here have type 'svuint64_t' and 'svint32_t' respectively} } */\n+}"}, {"sha": "da57b07ea84d630b14f483f952ed5349795a9711", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/unary_count_3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_count_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_count_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_count_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svuint8_t u8)\n+{\n+  svcnt_x (pg); /* { dg-error {too few arguments to function 'svcnt_x'} } */\n+  svcnt_x (pg, u8, u8); /* { dg-error {too many arguments to function 'svcnt_x'} } */\n+  svcnt_x (u8, u8); /* { dg-error {passing 'svuint8_t' to argument 1 of 'svcnt_x', which expects 'svbool_t'} } */\n+  svcnt_x (pg, pg); /* { dg-error {'svcnt_x' has no form that takes 'svbool_t' arguments} } */\n+  svcnt_x (pg, 1); /* { dg-error {passing 'int' to argument 2 of 'svcnt_x', which expects an SVE vector type} } */\n+  svcnt_x (pg, u8);\n+}"}, {"sha": "9c8acdf2d117e6035256a9c217aac4b5228061ae", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/unary_uint_1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_uint_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_uint_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_uint_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+\n+#include <arm_sve.h>\n+\n+void\n+f1 (svbool_t pg, svint8_t s8, svuint8_t u8,\n+    svint16_t s16, svuint16_t u16, svfloat16_t f16)\n+{\n+  svexpa (); /* { dg-error {too few arguments to function 'svexpa'} } */\n+  svexpa (u16, u16); /* { dg-error {too many arguments to function 'svexpa'} } */\n+  svexpa (1); /* { dg-error {passing 'int' to argument 1 of 'svexpa', which expects an SVE vector type} } */\n+  svexpa (pg); /* { dg-error {passing 'svbool_t' to argument 1 of 'svexpa', which expects a vector of unsigned integers} } */\n+  svexpa (s8); /* { dg-error {passing 'svint8_t' to argument 1 of 'svexpa', which expects a vector of unsigned integers} } */\n+  svexpa (s16); /* { dg-error {passing 'svint16_t' to argument 1 of 'svexpa', which expects a vector of unsigned integers} } */\n+  svexpa (f16); /* { dg-error {passing 'svfloat16_t' to argument 1 of 'svexpa', which expects a vector of unsigned integers} } */\n+\n+  svexpa (u8); /* { dg-error {'svexpa' has no form that takes 'svuint8_t' arguments} } */\n+  svexpa (u16);\n+}"}, {"sha": "95a97a72efdab7c318408cfc24351e6078347634", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/unary_widen_1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_widen_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_widen_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Funary_widen_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,25 @@\n+#include <arm_sve.h>\n+\n+void\n+test (svbool_t pg, svint8_t s8, svuint8_t u8,\n+      svint16_t s16, svuint16_t u16, svfloat16_t f16,\n+      svint32_t s32, svuint32_t u32, svfloat32_t f32,\n+      svint64_t s64, svuint64_t u64, svfloat64_t f64, float f, int i)\n+{\n+  svunpklo (); /* { dg-error {too few arguments to function 'svunpklo'} } */\n+  svunpklo (pg, s8); /* { dg-error {too many arguments to function 'svunpklo'} } */\n+  svunpklo (i); /* { dg-error {passing 'int' to argument 1 of 'svunpklo', which expects an SVE vector type} } */\n+  svunpklo (f); /* { dg-error {passing 'float' to argument 1 of 'svunpklo', which expects an SVE vector type} } */\n+  svunpklo (pg);\n+  svunpklo (s8);\n+  svunpklo (s16);\n+  svunpklo (s32);\n+  svunpklo (s64); /* { dg-error {'svunpklo' has no form that takes 'svint64_t' arguments} } */\n+  svunpklo (u8);\n+  svunpklo (u16);\n+  svunpklo (u32);\n+  svunpklo (u64); /* { dg-error {'svunpklo' has no form that takes 'svuint64_t' arguments} } */\n+  svunpklo (f16); /* { dg-error {'svunpklo' has no form that takes 'svfloat16_t' arguments} } */\n+  svunpklo (f32); /* { dg-error {'svunpklo' has no form that takes 'svfloat32_t' arguments} } */\n+  svunpklo (f64); /* { dg-error {'svunpklo' has no form that takes 'svfloat64_t' arguments} } */\n+}"}, {"sha": "37524c2eded5cb731674a5a7091ed2cccc6aa148", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/undeclared_1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fundeclared_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fundeclared_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fundeclared_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,17 @@\n+#include <arm_sve.h>\n+\n+void\n+f (svint8_t s8, svuint16_t u16, svfloat32_t f32,\n+   svint16x2_t s16x2, svuint32x3_t u32x3, svfloat64x4_t f64x4,\n+   svbool_t pg)\n+{\n+  s8 = no_ret_s8 (); /* { dg-error {incompatible types when assigning to type 'svint8_t' from type 'int'} } */\n+  u16 = no_ret_u16 (); /* { dg-error {incompatible types when assigning to type 'svuint16_t' from type 'int'} } */\n+  f32 = no_ret_f32 (); /* { dg-error {incompatible types when assigning to type 'svfloat32_t' from type 'int'} } */\n+  s16x2 = no_ret_s16x2 (); /* { dg-error {incompatible types when assigning to type 'svint16x2_t' from type 'int'} } */\n+  u32x3 = no_ret_u32x3 (); /* { dg-error {incompatible types when assigning to type 'svuint32x3_t' from type 'int'} } */\n+  f64x4 = no_ret_f64x4 (); /* { dg-error {incompatible types when assigning to type 'svfloat64x4_t' from type 'int'} } */\n+  pg = no_ret_pg (); /* { dg-error {incompatible types when assigning to type 'svbool_t' from type 'int'} } */\n+\n+  no_pass_args (pg, u16, f32, s16x2, u32x3, f64x4, pg);\n+}"}, {"sha": "7e869bda8a1cf798c5b7a1db4a18204465df11e3", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general-c/undeclared_2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fundeclared_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fundeclared_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2Fundeclared_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,15 @@\n+#include <arm_sve.h>\n+\n+void\n+f (svint8_t s8, svuint16_t u16, svfloat32_t f32,\n+   svint16x2_t s16x2, svuint32x3_t u32x3, svfloat64x4_t f64x4,\n+   svbool_t pg)\n+{\n+  s8 = svlsr_x (pg, s8, 1); /* { dg-error {'svlsr_x' has no form that takes 'svint8_t' arguments} } */\n+  u16 = svneg_x (pg, u16); /* { dg-error {'svneg_x' has no form that takes 'svuint16_t' arguments} } */\n+  f32 = svclz_x (pg, f32); /* { dg-error {'svclz_x' has no form that takes 'svfloat32_t' arguments} } */\n+  s16x2 = svcreate2 (s8); /* { dg-error {too few arguments to function 'svcreate2'} } */\n+  u32x3 = svcreate3 (u16, u16, f32); /* { dg-error {passing 'svfloat32_t' to argument 3 of 'svcreate3', but previous arguments had type 'svuint16_t'} } */\n+  f64x4 = svcreate4 (f32, f32, f32, f32, f32); /* { dg-error {too many arguments to function 'svcreate4'} } */\n+  pg = svadd_x (pg, pg, pg); /* { dg-error {'svadd_x' has no form that takes 'svbool_t' arguments} } */\n+}"}, {"sha": "f5c6285f8606b0a9af1e3fb1ba99c516ed2f2acb", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/add_1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fadd_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fadd_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fadd_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+foo (svint8_t *res1, svint8_t *res2, svbool_t pg, svint8_t a, svint8_t b)\n+{\n+  *res1 = svadd_m (pg, a, b);\n+  *res2 = svadd_m (pg, a, b);\n+}\n+\n+/* { dg-final { scan-tree-dump-times {svadd_s8_m|svadd_m} 1 \"optimized\" } } */"}, {"sha": "59348cece976b302c42a9e22a4c1bf75901113c5", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/and_1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fand_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fand_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fand_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, svbool_t x, svbool_t y, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svand_z (pg, x, y);\n+  *any = svptest_any (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)\n+{\n+  svbool_t res = svand_z (pg, x, y);\n+  return svptest_any (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tands\\t} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tand\\t} } } */"}, {"sha": "e1c484995be7ffd59df3100f4e6f7b919a484a68", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/bic_1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbic_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbic_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbic_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, svbool_t x, svbool_t y, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svbic_z (pg, x, y);\n+  *any = svptest_any (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)\n+{\n+  svbool_t res = svbic_z (pg, x, y);\n+  return svptest_any (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tbics\\t} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tbic\\t} } } */"}, {"sha": "24aa8f317c4e526801cc889726e4747425e9ed53", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/brka_1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrka_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrka_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrka_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, svbool_t x, svbool_t y, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svbrka_m (x, pg, y);\n+  *any = svptest_any (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)\n+{\n+  svbool_t res = svbrka_m (x, pg, y);\n+  return svptest_any (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tbrkas\\tp[0-9]+\\.b, p[0-9]+/m,} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tbrka\\t} } } */"}, {"sha": "8aa3388678d9078575801232fe8e1b5a3772a321", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/brka_2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrka_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrka_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrka_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, svbool_t x, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svbrka_z (pg, x);\n+  *any = svptest_any (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg, svbool_t x, int *any)\n+{\n+  svbool_t res = svbrka_z (pg, x);\n+  return svptest_any (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tbrkas\\tp[0-9]+\\.b, p[0-9]+/z,} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tbrka\\t} } } */"}, {"sha": "07e3622ed6a86d7e3be6f5050d1808e2d920ca77", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkb_1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrkb_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrkb_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrkb_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, svbool_t x, svbool_t y, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svbrkb_m (x, pg, y);\n+  *any = svptest_any (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)\n+{\n+  svbool_t res = svbrkb_m (x, pg, y);\n+  return svptest_any (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tbrkbs\\tp[0-9]+\\.b, p[0-9]+/m,} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tbrkb\\t} } } */"}, {"sha": "ee677cedd06b813861f2d145f964041587163cfb", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkb_2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrkb_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrkb_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrkb_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, svbool_t x, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svbrkb_z (pg, x);\n+  *any = svptest_any (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg, svbool_t x, int *any)\n+{\n+  svbool_t res = svbrkb_z (pg, x);\n+  return svptest_any (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tbrkbs\\tp[0-9]+\\.b, p[0-9]+/z,} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tbrkb\\t} } } */"}, {"sha": "7fd9318c13fe81a8bc2581530d292c3842630228", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkn_1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrkn_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrkn_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrkn_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, svbool_t x, svbool_t y, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svbrkn_z (pg, x, y);\n+  *any = svptest_any (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)\n+{\n+  svbool_t res = svbrkn_z (pg, x, y);\n+  return svptest_any (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tbrkns\\t} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tbrkn\\t} } } */"}, {"sha": "18cca370c6572d0de4d382d23204b021c308d704", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkpa_1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrkpa_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrkpa_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrkpa_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, svbool_t x, svbool_t y, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svbrkpa_z (pg, x, y);\n+  *any = svptest_any (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)\n+{\n+  svbool_t res = svbrkpa_z (pg, x, y);\n+  return svptest_any (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tbrkpas\\t} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tbrkpa\\t} } } */"}, {"sha": "73eb7094db98077d2dfe099bf1da1d0b7b0976b2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkpb_1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrkpb_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrkpb_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fbrkpb_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, svbool_t x, svbool_t y, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svbrkpb_z (pg, x, y);\n+  *any = svptest_any (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)\n+{\n+  svbool_t res = svbrkpb_z (pg, x, y);\n+  return svptest_any (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tbrkpbs\\t} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tbrkpb\\t} } } */"}, {"sha": "dd8f6c4942491b62bbd9335f0d06fb7d5f6dc080", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/cmpeq_1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcmpeq_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcmpeq_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcmpeq_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, svint8_t x, svint64_t y, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svcmpeq_wide (pg, x, y);\n+  *any = svptest_any (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg, svint8_t x, svint64_t y, int *any)\n+{\n+  svbool_t res = svcmpeq_wide (pg, x, y);\n+  return svptest_any (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\t} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tptest\\t} } } */"}, {"sha": "028d37516cc88f30625b8548da8e01181ad919b2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/cmpeq_2.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcmpeq_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcmpeq_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcmpeq_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, svint8_t x, svint8_t y, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svcmpeq (pg, x, y);\n+  *any = svptest_any (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg, svint8_t x, svint8_t y, int *any)\n+{\n+  svbool_t res = svcmpeq (pg, x, y);\n+  return svptest_any (pg, res);\n+}\n+\n+void\n+test3 (svbool_t pg, svint8_t x, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svcmpeq (pg, x, 10);\n+  *any = svptest_any (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test4 (svbool_t pg, svint8_t x, int *any)\n+{\n+  svbool_t res = svcmpeq (pg, x, 10);\n+  return svptest_any (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\t} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\t[^\\n]*, #10} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tptest\\t} } } */"}, {"sha": "115b26c8e30fa762232b94685a42477b676797f7", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/cmpeq_3.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcmpeq_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcmpeq_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcmpeq_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, svfloat32_t x, svfloat32_t y, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svcmpeq (pg, x, y);\n+  *any = svptest_any (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg, svfloat32_t x, svfloat32_t y, int *any)\n+{\n+  svbool_t res = svcmpeq (pg, x, y);\n+  return svptest_any (pg, res);\n+}\n+\n+void\n+test3 (svbool_t pg, svfloat32_t x, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svcmpeq (pg, x, 0.0);\n+  *any = svptest_any (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test4 (svbool_t pg, svfloat32_t x, int *any)\n+{\n+  svbool_t res = svcmpeq (pg, x, 0.0);\n+  return svptest_any (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\t} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\t[^\\n]*, #0\\.0} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tptest\\t} 4 } } */"}, {"sha": "d57a75c205f84a3021f72dca077db924d2602fdd", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/cntb_pat_1.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcntb_pat_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcntb_pat_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcntb_pat_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,132 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O -msve-vector-bits=256\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/*\n+** cntb_pow2:\n+**\tmov\tx0, #?32\n+**\tret\n+*/\n+uint64_t cntb_pow2 () { return svcntb_pat (SV_POW2); }\n+\n+/*\n+** cntb_vl1:\n+**\tmov\tx0, #?1\n+**\tret\n+*/\n+uint64_t cntb_vl1 () { return svcntb_pat (SV_VL1); }\n+\n+/*\n+** cntb_vl2:\n+**\tmov\tx0, #?2\n+**\tret\n+*/\n+uint64_t cntb_vl2 () { return svcntb_pat (SV_VL2); }\n+\n+/*\n+** cntb_vl3:\n+**\tmov\tx0, #?3\n+**\tret\n+*/\n+uint64_t cntb_vl3 () { return svcntb_pat (SV_VL3); }\n+\n+/*\n+** cntb_vl4:\n+**\tmov\tx0, #?4\n+**\tret\n+*/\n+uint64_t cntb_vl4 () { return svcntb_pat (SV_VL4); }\n+\n+/*\n+** cntb_vl5:\n+**\tmov\tx0, #?5\n+**\tret\n+*/\n+uint64_t cntb_vl5 () { return svcntb_pat (SV_VL5); }\n+\n+/*\n+** cntb_vl6:\n+**\tmov\tx0, #?6\n+**\tret\n+*/\n+uint64_t cntb_vl6 () { return svcntb_pat (SV_VL6); }\n+\n+/*\n+** cntb_vl7:\n+**\tmov\tx0, #?7\n+**\tret\n+*/\n+uint64_t cntb_vl7 () { return svcntb_pat (SV_VL7); }\n+\n+/*\n+** cntb_vl8:\n+**\tmov\tx0, #?8\n+**\tret\n+*/\n+uint64_t cntb_vl8 () { return svcntb_pat (SV_VL8); }\n+\n+/*\n+** cntb_vl16:\n+**\tmov\tx0, #?16\n+**\tret\n+*/\n+uint64_t cntb_vl16 () { return svcntb_pat (SV_VL16); }\n+\n+/*\n+** cntb_vl32:\n+**\tmov\tx0, #?32\n+**\tret\n+*/\n+uint64_t cntb_vl32 () { return svcntb_pat (SV_VL32); }\n+\n+/*\n+** cntb_vl64:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cntb_vl64 () { return svcntb_pat (SV_VL64); }\n+\n+/*\n+** cntb_vl128:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cntb_vl128 () { return svcntb_pat (SV_VL128); }\n+\n+/*\n+** cntb_vl256:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cntb_vl256 () { return svcntb_pat (SV_VL256); }\n+\n+/*\n+** cntb_mul3:\n+**\tmov\tx0, #?30\n+**\tret\n+*/\n+uint64_t cntb_mul3 () { return svcntb_pat (SV_MUL3); }\n+\n+/*\n+** cntb_mul4:\n+**\tmov\tx0, #?32\n+**\tret\n+*/\n+uint64_t cntb_mul4 () { return svcntb_pat (SV_MUL4); }\n+\n+/*\n+** cntb_all:\n+**\tmov\tx0, #?32\n+**\tret\n+*/\n+uint64_t cntb_all () { return svcntb_pat (SV_ALL); }\n+\n+#ifdef __cplusplus\n+}\n+#endif"}, {"sha": "d93a320543f49fb94a0466d160fe2e0505c8eabd", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/cntd_pat_1.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcntd_pat_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcntd_pat_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcntd_pat_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,132 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O -msve-vector-bits=256\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/*\n+** cntd_pow2:\n+**\tmov\tx0, #?4\n+**\tret\n+*/\n+uint64_t cntd_pow2 () { return svcntd_pat (SV_POW2); }\n+\n+/*\n+** cntd_vl1:\n+**\tmov\tx0, #?1\n+**\tret\n+*/\n+uint64_t cntd_vl1 () { return svcntd_pat (SV_VL1); }\n+\n+/*\n+** cntd_vl2:\n+**\tmov\tx0, #?2\n+**\tret\n+*/\n+uint64_t cntd_vl2 () { return svcntd_pat (SV_VL2); }\n+\n+/*\n+** cntd_vl3:\n+**\tmov\tx0, #?3\n+**\tret\n+*/\n+uint64_t cntd_vl3 () { return svcntd_pat (SV_VL3); }\n+\n+/*\n+** cntd_vl4:\n+**\tmov\tx0, #?4\n+**\tret\n+*/\n+uint64_t cntd_vl4 () { return svcntd_pat (SV_VL4); }\n+\n+/*\n+** cntd_vl5:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cntd_vl5 () { return svcntd_pat (SV_VL5); }\n+\n+/*\n+** cntd_vl6:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cntd_vl6 () { return svcntd_pat (SV_VL6); }\n+\n+/*\n+** cntd_vl7:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cntd_vl7 () { return svcntd_pat (SV_VL7); }\n+\n+/*\n+** cntd_vl8:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cntd_vl8 () { return svcntd_pat (SV_VL8); }\n+\n+/*\n+** cntd_vl16:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cntd_vl16 () { return svcntd_pat (SV_VL16); }\n+\n+/*\n+** cntd_vl32:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cntd_vl32 () { return svcntd_pat (SV_VL32); }\n+\n+/*\n+** cntd_vl64:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cntd_vl64 () { return svcntd_pat (SV_VL64); }\n+\n+/*\n+** cntd_vl128:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cntd_vl128 () { return svcntd_pat (SV_VL128); }\n+\n+/*\n+** cntd_vl256:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cntd_vl256 () { return svcntd_pat (SV_VL256); }\n+\n+/*\n+** cntd_mul3:\n+**\tmov\tx0, #?3\n+**\tret\n+*/\n+uint64_t cntd_mul3 () { return svcntd_pat (SV_MUL3); }\n+\n+/*\n+** cntd_mul4:\n+**\tmov\tx0, #?4\n+**\tret\n+*/\n+uint64_t cntd_mul4 () { return svcntd_pat (SV_MUL4); }\n+\n+/*\n+** cntd_all:\n+**\tmov\tx0, #?4\n+**\tret\n+*/\n+uint64_t cntd_all () { return svcntd_pat (SV_ALL); }\n+\n+#ifdef __cplusplus\n+}\n+#endif"}, {"sha": "bd988f53d4f13879d8409e5210e10df4b64a7052", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/cnth_pat_1.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcnth_pat_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcnth_pat_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcnth_pat_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,132 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O -msve-vector-bits=256\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/*\n+** cnth_pow2:\n+**\tmov\tx0, #?16\n+**\tret\n+*/\n+uint64_t cnth_pow2 () { return svcnth_pat (SV_POW2); }\n+\n+/*\n+** cnth_vl1:\n+**\tmov\tx0, #?1\n+**\tret\n+*/\n+uint64_t cnth_vl1 () { return svcnth_pat (SV_VL1); }\n+\n+/*\n+** cnth_vl2:\n+**\tmov\tx0, #?2\n+**\tret\n+*/\n+uint64_t cnth_vl2 () { return svcnth_pat (SV_VL2); }\n+\n+/*\n+** cnth_vl3:\n+**\tmov\tx0, #?3\n+**\tret\n+*/\n+uint64_t cnth_vl3 () { return svcnth_pat (SV_VL3); }\n+\n+/*\n+** cnth_vl4:\n+**\tmov\tx0, #?4\n+**\tret\n+*/\n+uint64_t cnth_vl4 () { return svcnth_pat (SV_VL4); }\n+\n+/*\n+** cnth_vl5:\n+**\tmov\tx0, #?5\n+**\tret\n+*/\n+uint64_t cnth_vl5 () { return svcnth_pat (SV_VL5); }\n+\n+/*\n+** cnth_vl6:\n+**\tmov\tx0, #?6\n+**\tret\n+*/\n+uint64_t cnth_vl6 () { return svcnth_pat (SV_VL6); }\n+\n+/*\n+** cnth_vl7:\n+**\tmov\tx0, #?7\n+**\tret\n+*/\n+uint64_t cnth_vl7 () { return svcnth_pat (SV_VL7); }\n+\n+/*\n+** cnth_vl8:\n+**\tmov\tx0, #?8\n+**\tret\n+*/\n+uint64_t cnth_vl8 () { return svcnth_pat (SV_VL8); }\n+\n+/*\n+** cnth_vl16:\n+**\tmov\tx0, #?16\n+**\tret\n+*/\n+uint64_t cnth_vl16 () { return svcnth_pat (SV_VL16); }\n+\n+/*\n+** cnth_vl32:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cnth_vl32 () { return svcnth_pat (SV_VL32); }\n+\n+/*\n+** cnth_vl64:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cnth_vl64 () { return svcnth_pat (SV_VL64); }\n+\n+/*\n+** cnth_vl128:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cnth_vl128 () { return svcnth_pat (SV_VL128); }\n+\n+/*\n+** cnth_vl256:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cnth_vl256 () { return svcnth_pat (SV_VL256); }\n+\n+/*\n+** cnth_mul3:\n+**\tmov\tx0, #?15\n+**\tret\n+*/\n+uint64_t cnth_mul3 () { return svcnth_pat (SV_MUL3); }\n+\n+/*\n+** cnth_mul4:\n+**\tmov\tx0, #?16\n+**\tret\n+*/\n+uint64_t cnth_mul4 () { return svcnth_pat (SV_MUL4); }\n+\n+/*\n+** cnth_all:\n+**\tmov\tx0, #?16\n+**\tret\n+*/\n+uint64_t cnth_all () { return svcnth_pat (SV_ALL); }\n+\n+#ifdef __cplusplus\n+}\n+#endif"}, {"sha": "53c8435b14e67e44c0d8800fcb665a317ae34001", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/cntw_pat_1.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcntw_pat_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcntw_pat_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fcntw_pat_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,132 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O -msve-vector-bits=256\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/*\n+** cntw_pow2:\n+**\tmov\tx0, #?8\n+**\tret\n+*/\n+uint64_t cntw_pow2 () { return svcntw_pat (SV_POW2); }\n+\n+/*\n+** cntw_vl1:\n+**\tmov\tx0, #?1\n+**\tret\n+*/\n+uint64_t cntw_vl1 () { return svcntw_pat (SV_VL1); }\n+\n+/*\n+** cntw_vl2:\n+**\tmov\tx0, #?2\n+**\tret\n+*/\n+uint64_t cntw_vl2 () { return svcntw_pat (SV_VL2); }\n+\n+/*\n+** cntw_vl3:\n+**\tmov\tx0, #?3\n+**\tret\n+*/\n+uint64_t cntw_vl3 () { return svcntw_pat (SV_VL3); }\n+\n+/*\n+** cntw_vl4:\n+**\tmov\tx0, #?4\n+**\tret\n+*/\n+uint64_t cntw_vl4 () { return svcntw_pat (SV_VL4); }\n+\n+/*\n+** cntw_vl5:\n+**\tmov\tx0, #?5\n+**\tret\n+*/\n+uint64_t cntw_vl5 () { return svcntw_pat (SV_VL5); }\n+\n+/*\n+** cntw_vl6:\n+**\tmov\tx0, #?6\n+**\tret\n+*/\n+uint64_t cntw_vl6 () { return svcntw_pat (SV_VL6); }\n+\n+/*\n+** cntw_vl7:\n+**\tmov\tx0, #?7\n+**\tret\n+*/\n+uint64_t cntw_vl7 () { return svcntw_pat (SV_VL7); }\n+\n+/*\n+** cntw_vl8:\n+**\tmov\tx0, #?8\n+**\tret\n+*/\n+uint64_t cntw_vl8 () { return svcntw_pat (SV_VL8); }\n+\n+/*\n+** cntw_vl16:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cntw_vl16 () { return svcntw_pat (SV_VL16); }\n+\n+/*\n+** cntw_vl32:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cntw_vl32 () { return svcntw_pat (SV_VL32); }\n+\n+/*\n+** cntw_vl64:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cntw_vl64 () { return svcntw_pat (SV_VL64); }\n+\n+/*\n+** cntw_vl128:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cntw_vl128 () { return svcntw_pat (SV_VL128); }\n+\n+/*\n+** cntw_vl256:\n+**\tmov\tx0, #?0\n+**\tret\n+*/\n+uint64_t cntw_vl256 () { return svcntw_pat (SV_VL256); }\n+\n+/*\n+** cntw_mul3:\n+**\tmov\tx0, #?6\n+**\tret\n+*/\n+uint64_t cntw_mul3 () { return svcntw_pat (SV_MUL3); }\n+\n+/*\n+** cntw_mul4:\n+**\tmov\tx0, #?8\n+**\tret\n+*/\n+uint64_t cntw_mul4 () { return svcntw_pat (SV_MUL4); }\n+\n+/*\n+** cntw_all:\n+**\tmov\tx0, #?8\n+**\tret\n+*/\n+uint64_t cntw_all () { return svcntw_pat (SV_ALL); }\n+\n+#ifdef __cplusplus\n+}\n+#endif"}, {"sha": "0442efef3ca6b6c145d176b804ef5da656ee555b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/debug_1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdebug_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdebug_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdebug_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-options \"-g\" } */\n+\n+#include <arm_sve.h>\n+\n+svbool_t f_b (svbool_t x) { return x; }\n+svint8_t f_s8 (svint8_t x) { return x; }\n+svuint8_t f_u8 (svuint8_t x) { return x; }\n+svint16_t f_s16 (svint16_t x) { return x; }\n+svuint16_t f_u16 (svuint16_t x) { return x; }\n+svfloat16_t f_f16 (svfloat16_t x) { return x; }\n+svint32_t f_s32 (svint32_t x) { return x; }\n+svuint32_t f_u32 (svuint32_t x) { return x; }\n+svfloat32_t f_f32 (svfloat32_t x) { return x; }\n+svint64_t f_s64 (svint64_t x) { return x; }\n+svuint64_t f_u64 (svuint64_t x) { return x; }\n+svfloat64_t f_f64 (svfloat64_t x) { return x; }"}, {"sha": "63a26d2e9d9339b8a10fbe29f35f971b881a6125", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/debug_2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdebug_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdebug_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdebug_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-options \"-g\" } */\n+\n+#include <arm_sve.h>\n+\n+svbool_t f_b (svbool_t x) { return svptrue_b32 (); }\n+svint8_t f_s8 (svint8_t x) { return svdup_s8 (0); }\n+svuint8_t f_u8 (svuint8_t x) { return svdup_u8 (1); }\n+svint16_t f_s16 (svint16_t x) { return svdup_s16 (2); }\n+svuint16_t f_u16 (svuint16_t x) { return svdup_u16 (3); }\n+svfloat16_t f_f16 (svfloat16_t x) { return svdup_f16 (4); }\n+svint32_t f_s32 (svint32_t x) { return svdup_s32 (5); }\n+svuint32_t f_u32 (svuint32_t x) { return svdup_u32 (6); }\n+svfloat32_t f_f32 (svfloat32_t x) { return svdup_f32 (7); }\n+svint64_t f_s64 (svint64_t x) { return svdup_s64 (8); }\n+svuint64_t f_u64 (svuint64_t x) { return svdup_u64 (9); }\n+svfloat64_t f_f64 (svfloat64_t x) { return svdup_f64 (10); }"}, {"sha": "ac151e465105e74e1bbb53e610c77a072df8cc9e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/debug_3.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdebug_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdebug_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdebug_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-options \"-g\" } */\n+\n+#include <arm_sve.h>\n+\n+svint8x2_t f2_s8 (svint8x2_t x) { return x; }\n+svuint8x2_t f2_u8 (svuint8x2_t x) { return x; }\n+svint16x2_t f2_s16 (svint16x2_t x) { return x; }\n+svuint16x2_t f2_u16 (svuint16x2_t x) { return x; }\n+svfloat16x2_t f2_f16 (svfloat16x2_t x) { return x; }\n+svint32x2_t f2_s32 (svint32x2_t x) { return x; }\n+svuint32x2_t f2_u32 (svuint32x2_t x) { return x; }\n+svfloat32x2_t f2_f32 (svfloat32x2_t x) { return x; }\n+svint64x2_t f2_s64 (svint64x2_t x) { return x; }\n+svuint64x2_t f2_u64 (svuint64x2_t x) { return x; }\n+svfloat64x2_t f2_f64 (svfloat64x2_t x) { return x; }\n+\n+svint8x3_t f3_s8 (svint8x3_t x) { return x; }\n+svuint8x3_t f3_u8 (svuint8x3_t x) { return x; }\n+svint16x3_t f3_s16 (svint16x3_t x) { return x; }\n+svuint16x3_t f3_u16 (svuint16x3_t x) { return x; }\n+svfloat16x3_t f3_f16 (svfloat16x3_t x) { return x; }\n+svint32x3_t f3_s32 (svint32x3_t x) { return x; }\n+svuint32x3_t f3_u32 (svuint32x3_t x) { return x; }\n+svfloat32x3_t f3_f32 (svfloat32x3_t x) { return x; }\n+svint64x3_t f3_s64 (svint64x3_t x) { return x; }\n+svuint64x3_t f3_u64 (svuint64x3_t x) { return x; }\n+svfloat64x3_t f3_f64 (svfloat64x3_t x) { return x; }\n+\n+svint8x4_t f4_s8 (svint8x4_t x) { return x; }\n+svuint8x4_t f4_u8 (svuint8x4_t x) { return x; }\n+svint16x4_t f4_s16 (svint16x4_t x) { return x; }\n+svuint16x4_t f4_u16 (svuint16x4_t x) { return x; }\n+svfloat16x4_t f4_f16 (svfloat16x4_t x) { return x; }\n+svint32x4_t f4_s32 (svint32x4_t x) { return x; }\n+svuint32x4_t f4_u32 (svuint32x4_t x) { return x; }\n+svfloat32x4_t f4_f42 (svfloat32x4_t x) { return x; }\n+svint64x4_t f4_s64 (svint64x4_t x) { return x; }\n+svuint64x4_t f4_u64 (svuint64x4_t x) { return x; }\n+svfloat64x4_t f4_f64 (svfloat64x4_t x) { return x; }"}, {"sha": "9b3c3697c275a14410d505dbc44906a877857c76", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/double_pragma_1.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdouble_pragma_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdouble_pragma_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdouble_pragma_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+/* It doesn't really matter if this produces errors about redefinitions,\n+   but it mustn't trigger an ICE.  */\n+#pragma GCC aarch64 \"arm_sve.h\"\n+#pragma GCC aarch64 \"arm_sve.h\" /* { dg-error \"duplicate definition of 'arm_sve.h'\" } */"}, {"sha": "d71507baa02bb9f7018374fb255f6d1f82f95c00", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/dupq_1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mlittle-endian\" } */\n+\n+#include <arm_sve.h>\n+\n+svint32_t\n+dupq (int x)\n+{\n+  return svdupq_s32 (x, 1, 2, 3);\n+}\n+\n+/* { dg-final { scan-assembler {\\tldr\\tq[0-9]+,} } } */\n+/* { dg-final { scan-assembler {\\tins\\tv[0-9]+\\.s\\[0\\], w0\\n} } } */\n+/* { dg-final { scan-assembler {\\tdup\\tz[0-9]+\\.q, z[0-9]+\\.q\\[0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.word\\t1\\n\\t\\.word\\t2\\n\\t\\.word\\t3\\n} } } */"}, {"sha": "f8f797c9747c620f73df4174db70b767fb8b5163", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/dupq_10.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_10.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+svbool_t __attribute__ ((noipa))\n+make_b8 (int8_t x0, int8_t x1, int8_t x2, int8_t x3,\n+\t int8_t x4, int8_t x5, int8_t x6, int8_t x7,\n+\t int8_t x8, int8_t x9, int8_t xa, int8_t xb,\n+\t int8_t xc, int8_t xd, int8_t xe, int8_t xf)\n+{\n+  return svdupq_b8 (x0, x1, x2, x3, x4, x5, x6, x7,\n+\t\t    x8, x9, xa, xb, xc, xd, xe, xf);\n+}\n+\n+svbool_t __attribute__ ((noipa))\n+make_b16 (int16_t x0, int16_t x1, int16_t x2, int16_t x3,\n+\t  int16_t x4, int16_t x5, int16_t x6, int16_t x7)\n+{\n+  return svdupq_b16 (x0, x1, x2, x3, x4, x5, x6, x7);\n+}\n+\n+svbool_t __attribute__ ((noipa))\n+make_b32 (int32_t x0, int32_t x1, int32_t x2, int32_t x3)\n+{\n+  return svdupq_b32 (x0, x1, x2, x3);\n+}\n+\n+svbool_t __attribute__ ((noipa))\n+make_b64 (int64_t x0, int64_t x1)\n+{\n+  return svdupq_b64 (x0, x1);\n+}\n+\n+int8_t a[16] = { 1, 0, 0, -3, 0, 9, 11, 0, 0, 1, 0, -4, 9, 9, 0, 0 };\n+\n+int\n+main ()\n+{\n+  svbool_t pg = svptrue_pat_b8 (SV_VL16);\n+  svbool_t b8 = make_b8 (a[0], a[1], a[2], a[3],\n+\t\t\t a[4], a[5], a[6], a[7],\n+\t\t\t a[8], a[9], a[10], a[11],\n+\t\t\t a[12], a[13], a[14], a[15]);\n+  if (svptest_any (svptrue_b8 (),\n+\t\t   sveor_z (pg, b8, svcmpne (pg, svld1 (pg, a), 0))))\n+    __builtin_abort ();\n+\n+  svbool_t b16 = make_b16 (a[0], a[1], a[2], a[3],\n+\t\t\t   a[4], a[5], a[6], a[7]);\n+  if (svptest_any (svptrue_b16 (),\n+\t\t   sveor_z (pg, b16, svcmpne (pg, svld1sb_u16 (pg, a), 0))))\n+    __builtin_abort ();\n+\n+  svbool_t b32 = make_b32 (a[0], a[1], a[2], a[3]);\n+  if (svptest_any (svptrue_b32 (),\n+\t\t   sveor_z (pg, b32, svcmpne (pg, svld1sb_u32 (pg, a), 0))))\n+    __builtin_abort ();\n+\n+  svbool_t b64 = make_b64 (a[0], a[1]);\n+  if (svptest_any (svptrue_b64 (),\n+\t\t   sveor_z (pg, b64, svcmpne (pg, svld1sb_u64 (pg, a), 0))))\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "d494943a27533445c8e7bf71d01a5efb003fd11a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/dupq_2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mbig-endian\" } */\n+\n+/* To avoid needing big-endian header files.  */\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+svint32_t\n+dupq (int x)\n+{\n+  return svdupq_s32 (x, 1, 2, 3);\n+}\n+\n+/* { dg-final { scan-assembler {\\tldr\\tq[0-9]+,} } } */\n+/* { dg-final { scan-assembler {\\tins\\tv[0-9]+\\.s\\[0\\], w0\\n} } } */\n+/* { dg-final { scan-assembler {\\tdup\\tz[0-9]+\\.q, z[0-9]+\\.q\\[0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.word\\t3\\n\\t\\.word\\t2\\n\\t\\.word\\t1\\n} } } */"}, {"sha": "4bc8259df073ccb7d19dff333140536e11d8ceea", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/dupq_3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mlittle-endian\" } */\n+\n+/* To avoid needing big-endian header files.  */\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+svint32_t\n+dupq (int x)\n+{\n+  return svdupq_s32 (0, 1, x, 3);\n+}\n+\n+/* { dg-final { scan-assembler {\\tldr\\tq[0-9]+,} } } */\n+/* { dg-final { scan-assembler {\\tins\\tv[0-9]+\\.s\\[2\\], w0\\n} } } */\n+/* { dg-final { scan-assembler {\\tdup\\tz[0-9]+\\.q, z[0-9]+\\.q\\[0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.word\\t0\\n\\t\\.word\\t1\\n\\t\\.word\\t[^\\n]*\\n\\t\\.word\\t3\\n} } } */"}, {"sha": "6f9f9f2f22f54f76c13545fe362e90d794640c77", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/dupq_4.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_4.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mbig-endian\" } */\n+\n+/* To avoid needing big-endian header files.  */\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+svint32_t\n+dupq (int x)\n+{\n+  return svdupq_s32 (0, 1, x, 3);\n+}\n+\n+/* { dg-final { scan-assembler {\\tldr\\tq[0-9]+,} } } */\n+/* { dg-final { scan-assembler {\\tins\\tv[0-9]+\\.s\\[2\\], w0\\n} } } */\n+/* { dg-final { scan-assembler {\\tdup\\tz[0-9]+\\.q, z[0-9]+\\.q\\[0\\]\\n} } } */\n+/* { dg-final { scan-assembler {\\t\\.word\\t3\\n\\t\\.word\\t[^\\n]*\\n\\t\\.word\\t1\\n\\t\\.word\\t0\\n} } } */"}, {"sha": "53426c9af5aec61ae009ed2ad78da488530f899e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/dupq_5.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_5.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mlittle-endian\" } */\n+\n+#include <arm_sve.h>\n+\n+svint32_t\n+dupq (int x1, int x2, int x3, int x4)\n+{\n+  return svdupq_s32 (x1, x2, x3, x4);\n+}\n+\n+/* { dg-final { scan-assembler-not {\\tldr\\t} } } */\n+/* { dg-final { scan-assembler {, [wx]0\\n} } } */\n+/* { dg-final { scan-assembler {\\tins\\tv[0-9]+\\.s\\[1\\], w1\\n} } } */\n+/* { dg-final { scan-assembler {\\tins\\tv[0-9]+\\.s\\[2\\], w2\\n} } } */\n+/* { dg-final { scan-assembler {\\tins\\tv[0-9]+\\.s\\[3\\], w3\\n} } } */\n+/* { dg-final { scan-assembler {\\tdup\\tz[0-9]+\\.q, z[0-9]+\\.q\\[0\\]\\n} } } */"}, {"sha": "dfce5e7a12a9d3c1930a3cbe35bb4954a4a00be2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/dupq_6.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_6.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mbig-endian\" } */\n+\n+/* To avoid needing big-endian header files.  */\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+svint32_t\n+dupq (int x1, int x2, int x3, int x4)\n+{\n+  return svdupq_s32 (x1, x2, x3, x4);\n+}\n+\n+/* { dg-final { scan-assembler-not {\\tldr\\t} } } */\n+/* { dg-final { scan-assembler {, [wx]0\\n} } } */\n+/* { dg-final { scan-assembler {\\tins\\tv[0-9]+\\.s\\[1\\], w1\\n} } } */\n+/* { dg-final { scan-assembler {\\tins\\tv[0-9]+\\.s\\[2\\], w2\\n} } } */\n+/* { dg-final { scan-assembler {\\tins\\tv[0-9]+\\.s\\[3\\], w3\\n} } } */\n+/* { dg-final { scan-assembler {\\tdup\\tz[0-9]+\\.q, z[0-9]+\\.q\\[0\\]\\n} } } */"}, {"sha": "08decb5f980b4f0457e16c8e3aac07a2e3a2f149", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/dupq_7.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_7.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+svint8_t __attribute__ ((noipa))\n+make_s8 (int8_t x0, int8_t x1, int8_t x2, int8_t x3,\n+\t int8_t x4, int8_t x5, int8_t x6, int8_t x7,\n+\t int8_t x8, int8_t x9, int8_t xa, int8_t xb,\n+\t int8_t xc, int8_t xd, int8_t xe, int8_t xf)\n+{\n+  return svdupq_s8 (x0, x1, x2, x3, x4, x5, x6, x7,\n+\t\t    x8, x9, xa, xb, xc, xd, xe, xf);\n+}\n+\n+svint16_t __attribute__ ((noipa))\n+make_s16 (int16_t x0, int16_t x1, int16_t x2, int16_t x3,\n+\t  int16_t x4, int16_t x5, int16_t x6, int16_t x7)\n+{\n+  return svdupq_s16 (x0, x1, x2, x3, x4, x5, x6, x7);\n+}\n+\n+svint32_t __attribute__ ((noipa))\n+make_s32 (int32_t x0, int32_t x1, int32_t x2, int32_t x3)\n+{\n+  return svdupq_s32 (x0, x1, x2, x3);\n+}\n+\n+svint64_t __attribute__ ((noipa))\n+make_s64 (int64_t x0, int64_t x1)\n+{\n+  return svdupq_s64 (x0, x1);\n+}\n+\n+int8_t a[16] = { 1, -44, 91, -24, 101, -55, 77, 83,\n+\t\t -30, 69, 121, -128, -1, 13, 127, 26 };\n+int16_t b[8] = { -716, -10288, 30604, -19258, -9418, -10435, -16001, 7300 };\n+int32_t c[4] = { 1268374995, -1023602831, -891830021, -1793452959 };\n+int64_t d[2] = { 0x123456789abcdefLL, -0x123456789abcdefLL };\n+\n+int\n+main ()\n+{\n+  svbool_t pg = svptrue_pat_b8 (SV_VL16);\n+  svint8_t s8 = make_s8 (a[0], a[1], a[2], a[3],\n+\t\t\t a[4], a[5], a[6], a[7],\n+\t\t\t a[8], a[9], a[10], a[11],\n+\t\t\t a[12], a[13], a[14], a[15]);\n+  if (svptest_any (svptrue_b8 (), svcmpne (pg, s8, svld1 (pg, a))))\n+    __builtin_abort ();\n+\n+  svint16_t s16 = make_s16 (b[0], b[1], b[2], b[3],\n+\t\t\t    b[4], b[5], b[6], b[7]);\n+  if (svptest_any (svptrue_b8 (), svcmpne (pg, s16, svld1 (pg, b))))\n+    __builtin_abort ();\n+\n+  svint32_t s32 = make_s32 (c[0], c[1], c[2], c[3]);\n+  if (svptest_any (svptrue_b8 (), svcmpne (pg, s32, svld1 (pg, c))))\n+    __builtin_abort ();\n+\n+  svint64_t s64 = make_s64 (d[0], d[1]);\n+  if (svptest_any (svptrue_b8 (), svcmpne (pg, s64, svld1 (pg, d))))\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "c20fb7324ed409aeae2f1a040d03a26098ff43f5", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/dupq_8.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_8.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+svuint8_t __attribute__ ((noipa))\n+make_u8 (uint8_t x0, uint8_t x1, uint8_t x2, uint8_t x3,\n+\t uint8_t x4, uint8_t x5, uint8_t x6, uint8_t x7,\n+\t uint8_t x8, uint8_t x9, uint8_t xa, uint8_t xb,\n+\t uint8_t xc, uint8_t xd, uint8_t xe, uint8_t xf)\n+{\n+  return svdupq_u8 (x0, x1, x2, x3, x4, x5, x6, x7,\n+\t\t    x8, x9, xa, xb, xc, xd, xe, xf);\n+}\n+\n+svuint16_t __attribute__ ((noipa))\n+make_u16 (uint16_t x0, uint16_t x1, uint16_t x2, uint16_t x3,\n+\t  uint16_t x4, uint16_t x5, uint16_t x6, uint16_t x7)\n+{\n+  return svdupq_u16 (x0, x1, x2, x3, x4, x5, x6, x7);\n+}\n+\n+svuint32_t __attribute__ ((noipa))\n+make_u32 (uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3)\n+{\n+  return svdupq_u32 (x0, x1, x2, x3);\n+}\n+\n+svuint64_t __attribute__ ((noipa))\n+make_u64 (uint64_t x0, uint64_t x1)\n+{\n+  return svdupq_u64 (x0, x1);\n+}\n+\n+uint8_t a[16] = { 1, 212, 91, 232, 101, 201, 77, 83,\n+\t\t  226, 69, 121, 128, 255, 13, 127, 26 };\n+uint16_t b[8] = { 64820, 55248, 30604, 46278, 56118, 55101, 49535, 7300 };\n+uint32_t c[4] = { 1268374995, 3271364465, 3403137275, 2501514337 };\n+uint64_t d[2] = { 0x123456789abcdefULL, 0xfedcba9876543210ULL };\n+\n+int\n+main ()\n+{\n+  svbool_t pg = svptrue_pat_b8 (SV_VL16);\n+  svuint8_t u8 = make_u8 (a[0], a[1], a[2], a[3],\n+\t\t\t  a[4], a[5], a[6], a[7],\n+\t\t\t  a[8], a[9], a[10], a[11],\n+\t\t\t  a[12], a[13], a[14], a[15]);\n+  if (svptest_any (svptrue_b8 (), svcmpne (pg, u8, svld1 (pg, a))))\n+    __builtin_abort ();\n+\n+  svuint16_t u16 = make_u16 (b[0], b[1], b[2], b[3],\n+\t\t\t     b[4], b[5], b[6], b[7]);\n+  if (svptest_any (svptrue_b8 (), svcmpne (pg, u16, svld1 (pg, b))))\n+    __builtin_abort ();\n+\n+  svuint32_t u32 = make_u32 (c[0], c[1], c[2], c[3]);\n+  if (svptest_any (svptrue_b8 (), svcmpne (pg, u32, svld1 (pg, c))))\n+    __builtin_abort ();\n+\n+  svuint64_t u64 = make_u64 (d[0], d[1]);\n+  if (svptest_any (svptrue_b8 (), svcmpne (pg, u64, svld1 (pg, d))))\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "b29aa9474e2b3cd855cc5711cdeef308e68c370b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/dupq_9.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_9.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+svfloat16_t __attribute__ ((noipa))\n+make_f16 (float16_t x0, float16_t x1, float16_t x2, float16_t x3,\n+\t  float16_t x4, float16_t x5, float16_t x6, float16_t x7)\n+{\n+  return svdupq_f16 (x0, x1, x2, x3, x4, x5, x6, x7);\n+}\n+\n+svfloat32_t __attribute__ ((noipa))\n+make_f32 (float32_t x0, float32_t x1, float32_t x2, float32_t x3)\n+{\n+  return svdupq_f32 (x0, x1, x2, x3);\n+}\n+\n+svfloat64_t __attribute__ ((noipa))\n+make_f64 (float64_t x0, float64_t x1)\n+{\n+  return svdupq_f64 (x0, x1);\n+}\n+\n+float16_t a[8] = { 1.0, -4.25, 9.75, 6.5, -2.125, 5.5, -3.75, 7.625 };\n+float32_t b[4] = { 1.0, -90.25, -11.75, 141.5 };\n+float64_t c[2] = { 9221.5, -4491.25 };\n+\n+int\n+main ()\n+{\n+  svbool_t pg = svptrue_pat_b8 (SV_VL16);\n+  svfloat16_t f16 = make_f16 (a[0], a[1], a[2], a[3],\n+\t\t\t      a[4], a[5], a[6], a[7]);\n+  if (svptest_any (svptrue_b8 (), svcmpne (pg, f16, svld1 (pg, a))))\n+    __builtin_abort ();\n+\n+  svfloat32_t f32 = make_f32 (b[0], b[1], b[2], b[3]);\n+  if (svptest_any (svptrue_b8 (), svcmpne (pg, f32, svld1 (pg, b))))\n+    __builtin_abort ();\n+\n+  svfloat64_t f64 = make_f64 (c[0], c[1]);\n+  if (svptest_any (svptrue_b8 (), svcmpne (pg, f64, svld1 (pg, c))))\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "32ccb08d6573c77c277e9929abed65c3a94b2f41", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/dupq_lane_1.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,87 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+#ifndef TYPE\n+#define TYPE svint8_t\n+#define DUPQ svdupq_lane_s8\n+#define INDEX svindex_s8\n+#define COUNT 16\n+#endif\n+\n+#define BASE 42\n+\n+TYPE __attribute__ ((noipa))\n+dupq_var (TYPE x, uint64_t y)\n+{\n+  return DUPQ (x, y);\n+}\n+\n+TYPE __attribute__ ((noipa))\n+dupq_0 (TYPE x)\n+{\n+  return DUPQ (x, 0);\n+}\n+\n+TYPE __attribute__ ((noipa))\n+dupq_1 (TYPE x)\n+{\n+  return DUPQ (x, 1);\n+}\n+\n+TYPE __attribute__ ((noipa))\n+dupq_2 (TYPE x)\n+{\n+  return DUPQ (x, 2);\n+}\n+\n+TYPE __attribute__ ((noipa))\n+dupq_3 (TYPE x)\n+{\n+  return DUPQ (x, 3);\n+}\n+\n+TYPE __attribute__ ((noipa))\n+dupq_4 (TYPE x)\n+{\n+  return DUPQ (x, 4);\n+}\n+\n+void __attribute__ ((noipa))\n+check (TYPE x, uint64_t y)\n+{\n+  svbool_t pg = svptrue_b8 ();\n+  if (y * 2 >= svcntd ())\n+    {\n+      if (svptest_any (pg, svcmpne (pg, x, 0)))\n+\t__builtin_abort ();\n+    }\n+  else\n+    {\n+      TYPE repeat = svand_x (pg, INDEX (0, 1), COUNT - 1);\n+      TYPE expected = svadd_x (pg, repeat, BASE + y * COUNT);\n+      if (svptest_any (pg, svcmpne (pg, x, expected)))\n+\t__builtin_abort ();\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  TYPE x = INDEX (BASE, 1);\n+\n+  check (dupq_0 (x), 0);\n+  check (dupq_1 (x), 1);\n+  check (dupq_2 (x), 2);\n+  check (dupq_3 (x), 3);\n+  check (dupq_4 (x), 4);\n+\n+  for (int i = 0; i < 63; ++i)\n+    {\n+      check (dupq_var (x, i), i);\n+      check (dupq_var (x, (uint64_t) 1 << i), (uint64_t) 1 << i);\n+    }\n+\n+  return 0;\n+}"}, {"sha": "40de1c7dc0e0e5e6a246bfe7f1345ef62fb5723d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/dupq_lane_2.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2\" } */\n+\n+#define TYPE svuint8_t\n+#define DUPQ svdupq_lane_u8\n+#define INDEX svindex_u8\n+#define COUNT 16\n+\n+#include \"dupq_lane_1.c\""}, {"sha": "4ebe895453fe1b5745aa4d1358f801c31bc885b1", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/dupq_lane_3.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2\" } */\n+\n+#define TYPE svint16_t\n+#define DUPQ svdupq_lane_s16\n+#define INDEX svindex_s16\n+#define COUNT 8\n+\n+#include \"dupq_lane_1.c\""}, {"sha": "1be20c8e1970d8dab519641eb516ecd02d156b7f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/dupq_lane_4.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_4.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2\" } */\n+\n+#define TYPE svuint16_t\n+#define DUPQ svdupq_lane_u16\n+#define INDEX svindex_u16\n+#define COUNT 8\n+\n+#include \"dupq_lane_1.c\""}, {"sha": "67554d06a9bb6b4cb55161ae8739669f7a505303", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/dupq_lane_5.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_5.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2\" } */\n+\n+#define TYPE svint32_t\n+#define DUPQ svdupq_lane_s32\n+#define INDEX svindex_s32\n+#define COUNT 4\n+\n+#include \"dupq_lane_1.c\""}, {"sha": "1914d2368e5074c9e6f200e1359106cf7e78f42b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/dupq_lane_6.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_6.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2\" } */\n+\n+#define TYPE svuint32_t\n+#define DUPQ svdupq_lane_u32\n+#define INDEX svindex_u32\n+#define COUNT 4\n+\n+#include \"dupq_lane_1.c\""}, {"sha": "d7a8e52f8cd6f25024fd6aeeef1896cd76e407fb", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/dupq_lane_7.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_7.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2\" } */\n+\n+#define TYPE svint64_t\n+#define DUPQ svdupq_lane_s64\n+#define INDEX svindex_s64\n+#define COUNT 2\n+\n+#include \"dupq_lane_1.c\""}, {"sha": "68655fefa3e7d10af0d4d75943a318bdff73a7c7", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/dupq_lane_8.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fdupq_lane_8.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2\" } */\n+\n+#define TYPE svuint64_t\n+#define DUPQ svdupq_lane_u64\n+#define INDEX svindex_u64\n+#define COUNT 2\n+\n+#include \"dupq_lane_1.c\""}, {"sha": "357b0bfb8323128447494547c4ecc638ff2fc3a8", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/eor_1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Feor_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Feor_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Feor_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, svbool_t x, svbool_t y, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = sveor_z (pg, x, y);\n+  *any = svptest_any (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)\n+{\n+  svbool_t res = sveor_z (pg, x, y);\n+  return svptest_any (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\teors\\t} 2 } } */\n+/* { dg-final { scan-assembler-not {\\teor\\t} } } */"}, {"sha": "c68a9ed991e2655621cece7876e4120aa1730fee", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/ld1_1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fld1_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fld1_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fld1_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/*\n+** nop1:\n+**\tret\n+*/\n+void nop1 (int8_t *s) { svld1 (svptrue_b8 (), s); }\n+\n+/*\n+** nop2:\n+**\tret\n+*/\n+void nop2 (svbool_t pg, int16_t *s) { svld1 (pg, s); }\n+\n+#ifdef __cplusplus\n+}\n+#endif"}, {"sha": "79f8bee1fda95028a61c62724aed2e3a3e888af4", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/ldff1_1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+/* Make sure that SETFFR comes first, however high the priority of the\n+   LDFF1 is.  */\n+svint8_t\n+foo (svbool_t pg, int8_t *ptr)\n+{\n+  svsetffr ();\n+  svint8_t x = svldff1 (pg, ptr);\n+  x = svadd_x (pg, x, x);\n+  x = svmul_x (pg, x, x);\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler {\\tsetffr\\n.*\\tldff1b\\t} } } */"}, {"sha": "7c3c8d8b59543c4660ab48c0ca1aba7b355bbcfa", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/ldff1_2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+/* Make sure that RDFFR comes after the LDFF1 and that the RDFFRs can\n+   be CSEd.  */\n+svint8_t\n+foo (svbool_t pg, int8_t *__restrict ptr,\n+     svbool_t *__restrict *__restrict preds)\n+{\n+  svsetffr ();\n+  svint8_t x = svldff1 (pg, ptr);\n+  *preds[0] = svrdffr ();\n+  *preds[1] = svrdffr ();\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler {\\tsetffr\\n.*\\tldff1b\\t.*\\trdffr\\t} } } */\n+/* { dg-final { scan-assembler-times {\\trdffr\\t} 1 } } */"}, {"sha": "41ad0bcea00f287757dd510b21915decafbc48c1", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/ldff1_3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+/* Make sure that LDFF1s can be reordered.  The load of x should come due\n+   to its longer dependence chain.  */\n+svint8_t\n+foo (int8_t *ptr1, int8_t *ptr2)\n+{\n+  svsetffr ();\n+  svbool_t pg = svptrue_b8 ();\n+  svint8_t y = svldff1 (pg, ptr2);\n+  svint8_t x = svldff1 (pg, ptr1);\n+  x = svadd_x (pg, x, x);\n+  x = svmul_x (pg, x, x);\n+  x = svadd_x (pg, x, y);\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler {\\tldff1b\\tz[0-9]+\\.b, p[0-7]/z, \\[x0\\]\\n.*\\tldff1b\\tz[0-9]+\\.b, p[0-7]/z, \\[x1\\]\\n} } } */"}, {"sha": "c27302139a1e8f054990a80ae7ad4e6422386e70", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/ldff1_4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_4.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+/* Make sure that we can use RDFFRS to test for a fault.  */\n+svint8_t\n+foo (svbool_t pg, int8_t *ptr, int *fault)\n+{\n+  svsetffr ();\n+  svint8_t x = svldff1 (pg, ptr);\n+  *fault = svptest_any (pg, svrdffr_z (pg));\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler {\\tsetffr\\n.*\\tldff1b\\t.*\\trdffrs\\t} } } */\n+/* { dg-final { scan-assembler-not {\\trdffr\\t} } } */"}, {"sha": "76e7ab8ba5e6162c1d88fd526efa58b3c65936ee", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/ldff1_5.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_5.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+/* Make sure that we can use RDFFRS to read the FFR while testing for a\n+   fault.  */\n+svint8_t\n+foo (svbool_t pg, int8_t *ptr, svbool_t *pred, int *fault)\n+{\n+  svsetffr ();\n+  svint8_t x = svldff1 (pg, ptr);\n+  svbool_t ffr = svrdffr_z (pg);\n+  *fault = svptest_any (pg, ffr);\n+  *pred = ffr;\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler {\\tsetffr\\n.*\\tldff1b\\t.*\\trdffrs\\t} } } */\n+/* { dg-final { scan-assembler-not {\\trdffr\\t} } } */"}, {"sha": "7110e5f1a14966b797c5967704ff87f7f5fa14a1", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/ldff1_6.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_6.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+/* Make sure that we can use RDFFRS to test for a fault.  */\n+svint8_t\n+foo (svbool_t pg, int8_t *ptr, int *fault)\n+{\n+  svsetffr ();\n+  svint8_t x = svldff1 (pg, ptr);\n+  *fault = svptest_any (svptrue_b8 (), svrdffr ());\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler {\\tsetffr\\n.*\\tldff1b\\t.*\\trdffrs\\t} } } */\n+/* { dg-final { scan-assembler-not {\\trdffr\\t} } } */"}, {"sha": "355fe91f1b79763f2467b1d9241aea4ef792fa6c", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/ldff1_7.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fldff1_7.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+/* Make sure that we can use RDFFRS to read the FFR while testing for a\n+   fault.  */\n+svint8_t\n+foo (svbool_t pg, int8_t *ptr, svbool_t *pred, int *fault)\n+{\n+  svsetffr ();\n+  svint8_t x = svldff1 (pg, ptr);\n+  svbool_t ffr = svrdffr ();\n+  *fault = svptest_any (svptrue_b8 (), ffr);\n+  *pred = ffr;\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler {\\tsetffr\\n.*\\tldff1b\\t.*\\trdffrs\\t} } } */\n+/* { dg-final { scan-assembler-not {\\trdffr\\t} } } */"}, {"sha": "0bc54c0499840523e9ff896ec2f18a93c57877c6", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/nand_1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fnand_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fnand_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fnand_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, svbool_t x, svbool_t y, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svnand_z (pg, x, y);\n+  *any = svptest_any (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)\n+{\n+  svbool_t res = svnand_z (pg, x, y);\n+  return svptest_any (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tnands\\t} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tnand\\t} } } */"}, {"sha": "7973294d16423cef176fb7ab6930a430e8ef97dd", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/nor_1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fnor_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fnor_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fnor_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, svbool_t x, svbool_t y, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svnor_z (pg, x, y);\n+  *any = svptest_any (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)\n+{\n+  svbool_t res = svnor_z (pg, x, y);\n+  return svptest_any (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tnors\\t} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tnor\\t} } } */"}, {"sha": "09dfacd222d67e6344f8a99e7183accb219098f7", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/nosve_1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fnosve_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fnosve_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fnosve_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-options \"-march=armv8-a\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+void\n+f (svbool_t *x, svint8_t *y)\n+{\n+  *x = svptrue_b8 (); /* { dg-error {ACLE function '(svbool_t svptrue_b8\\(\\)|svptrue_b8)' requires ISA extension 'sve'} } */\n+  /* { dg-message {note: you can enable 'sve' using the command-line option '-march', or by using the 'target' attribute or pragma} \"\" { target *-*-* } .-1 } */\n+  *x = svptrue_b8 ();\n+  *x = svptrue_b8 ();\n+  *x = svptrue_b8 ();\n+  *x = svptrue_b8 ();\n+  *x = svptrue_b8 ();\n+  *x = svptrue_b8 ();\n+  *y = svadd_m (*x, *y, 1);\n+}"}, {"sha": "594be1cf4ef19ae5a9d48b2f7e9cdb4457e851fa", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/nosve_2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fnosve_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fnosve_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fnosve_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-options \"-march=armv8-a\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+#pragma GCC target \"+sve\"\n+\n+void\n+f (svbool_t *x, svint8_t *y)\n+{\n+  *x = svptrue_b8 ();\n+  *y = svadd_m (*x, *y, 1);\n+}\n+\n+/* { dg-final { scan-assembler {\\tadd\\tz[0-9]+\\.b, p[0-7]/m, z[0-9]+\\.b, z[0-9]+\\.b\\n} } } */"}, {"sha": "85f4eb3c006f8dbe6fc0332312e9b294080b5d8f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/nosve_3.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fnosve_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fnosve_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fnosve_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-options \"-march=armv8-a\" } */\n+\n+#pragma GCC aarch64 \"arm_sve.h\"\n+\n+void __attribute__ ((target(\"+sve\")))\n+f (svbool_t *x, svint8_t *y)\n+{\n+  *x = svptrue_b8 ();\n+  *y = svadd_m (*x, *y, 1);\n+}\n+\n+/* { dg-final { scan-assembler {\\tadd\\tz[0-9]+\\.b, p[0-7]/m, z[0-9]+\\.b, z[0-9]+\\.b\\n} } } */"}, {"sha": "c3ed1eb618b4197a99fc0109b43026fc3f058226", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/orn_1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Forn_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Forn_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Forn_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, svbool_t x, svbool_t y, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svorn_z (pg, x, y);\n+  *any = svptest_any (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)\n+{\n+  svbool_t res = svorn_z (pg, x, y);\n+  return svptest_any (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\torns\\t} 2 } } */\n+/* { dg-final { scan-assembler-not {\\torn\\t} } } */"}, {"sha": "4456fa630f02b0d4809edafa27ea36fee1d8bca5", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/orr_1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Forr_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Forr_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Forr_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, svbool_t x, svbool_t y, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svorr_z (pg, x, y);\n+  *any = svptest_any (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)\n+{\n+  svbool_t res = svorr_z (pg, x, y);\n+  return svptest_any (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\torrs\\t} 2 } } */\n+/* { dg-final { scan-assembler-not {\\torr\\t} } } */"}, {"sha": "de1ff691ab62c940bfde1d5fb78cbc642c425729", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/pfirst_1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fpfirst_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fpfirst_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fpfirst_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, int *last, svbool_t *ptr)\n+{\n+  svbool_t res = svpfirst (pg, svpfalse ());\n+  *last = svptest_last (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg)\n+{\n+  svbool_t res = svpfirst (pg, svpfalse ());\n+  return svptest_last (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tpfirst\\t} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tptest\\t} } } */"}, {"sha": "bf59cb96310846554d13f78790e15c3357e95c78", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/pnext_1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fpnext_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fpnext_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fpnext_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, svbool_t prev, int *last, svbool_t *ptr)\n+{\n+  svbool_t res = svpnext_b8 (pg, prev);\n+  *last = svptest_last (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg, svbool_t prev)\n+{\n+  svbool_t res = svpnext_b8 (pg, prev);\n+  return svptest_last (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tpnext\\t} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tptest\\t} } } */"}, {"sha": "9926a2beedf0059dba72fc8e27dfed16d8e6c037", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/pnext_2.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fpnext_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fpnext_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fpnext_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (svbool_t pg, svbool_t prev, int *last, svbool_t *ptr)\n+{\n+  svbool_t res = svpnext_b16 (pg, prev);\n+  *last = svptest_last (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (svbool_t pg, svbool_t prev)\n+{\n+  svbool_t res = svpnext_b16 (pg, prev);\n+  return svptest_last (pg, res);\n+}\n+\n+void\n+test3 (svbool_t pg, svbool_t prev, int *last, svbool_t *ptr)\n+{\n+  svbool_t res = svpnext_b32 (pg, prev);\n+  *last = svptest_last (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test4 (svbool_t pg, svbool_t prev)\n+{\n+  svbool_t res = svpnext_b32 (pg, prev);\n+  return svptest_last (pg, res);\n+}\n+\n+void\n+test5 (svbool_t pg, svbool_t prev, int *last, svbool_t *ptr)\n+{\n+  svbool_t res = svpnext_b64 (pg, prev);\n+  *last = svptest_last (pg, res);\n+  *ptr = res;\n+}\n+\n+int\n+test6 (svbool_t pg, svbool_t prev)\n+{\n+  svbool_t res = svpnext_b64 (pg, prev);\n+  return svptest_last (pg, res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tpnext\\t} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tptest\\t} 6 } } */"}, {"sha": "69bbb1ed09f18881f641c9a400a9502d631f1e03", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/ptrue_pat_1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fptrue_pat_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fptrue_pat_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fptrue_pat_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (int *last, svbool_t *ptr)\n+{\n+  svbool_t res = svptrue_pat_b8 (SV_VL32);\n+  *last = svptest_last (svptrue_b8 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 ()\n+{\n+  svbool_t res = svptrue_pat_b8 (SV_VL32);\n+  return svptest_last (svptrue_b8 (), res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tptrues\\tp[0-9]+\\.b, vl32\\n} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tptrue\\t} { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-not {\\tptest\\t} } } */"}, {"sha": "ede83405e9afd5ce3017464c72a9cb52c751cfdc", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/ptrue_pat_2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fptrue_pat_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fptrue_pat_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fptrue_pat_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (int *last, svbool_t *ptr)\n+{\n+  svbool_t res = svptrue_pat_b16 (SV_VL16);\n+  *last = svptest_last (svptrue_b16 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 ()\n+{\n+  svbool_t res = svptrue_pat_b16 (SV_VL16);\n+  return svptest_last (svptrue_b16 (), res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tptrues\\tp[0-9]+\\.h, vl16\\n} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tptrue\\t} { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-not {\\tptest\\t} } } */"}, {"sha": "d2eb3fc305062d427cc1bdc73e3a5837bab2e032", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/ptrue_pat_3.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fptrue_pat_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fptrue_pat_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fptrue_pat_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (int *last, svbool_t *ptr)\n+{\n+  svbool_t res = svptrue_pat_b32 (SV_VL16);\n+  *last = svptest_last (svptrue_b32 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 ()\n+{\n+  svbool_t res = svptrue_pat_b32 (SV_VL16);\n+  return svptest_last (svptrue_b32 (), res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tptrues\\tp[0-9]+\\.s, vl16\\n} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tptrue\\t} { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-not {\\tptest\\t} } } */"}, {"sha": "59a21da9ef8093a563a39efe188b169ab19cf1fd", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/ptrue_pat_4.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fptrue_pat_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fptrue_pat_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fptrue_pat_4.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svptrue_pat_b64 (SV_VL7);\n+  *any = svptest_any (svptrue_b64 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 ()\n+{\n+  svbool_t res = svptrue_pat_b64 (SV_VL7);\n+  return svptest_any (svptrue_b64 (), res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tptrues\\tp[0-9]+\\.d, vl7\\n} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tptrue\\t} { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-not {\\tptest\\t} } } */"}, {"sha": "c8f6d8aca482b9124cfa317d16a8453508076c97", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/ptrue_pat_5.c", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fptrue_pat_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fptrue_pat_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fptrue_pat_5.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,188 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+b8_b16_1 (int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svptrue_pat_b8 (SV_VL64);\n+  *any = svptest_any (svptrue_b16 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+b8_b16_2 ()\n+{\n+  svbool_t res = svptrue_pat_b8 (SV_VL64);\n+  return svptest_any (svptrue_b16 (), res);\n+}\n+\n+void\n+b8_b32_1 (int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svptrue_pat_b8 (SV_VL32);\n+  *any = svptest_any (svptrue_b32 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+b8_b32_2 ()\n+{\n+  svbool_t res = svptrue_pat_b8 (SV_VL32);\n+  return svptest_any (svptrue_b32 (), res);\n+}\n+\n+void\n+b8_b64_1 (int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svptrue_pat_b8 (SV_VL128);\n+  *any = svptest_any (svptrue_b64 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+b8_b64_2 ()\n+{\n+  svbool_t res = svptrue_pat_b8 (SV_VL128);\n+  return svptest_any (svptrue_b64 (), res);\n+}\n+\n+void\n+b16_b8_1 (int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svptrue_pat_b16 (SV_VL32);\n+  *any = svptest_any (svptrue_b8 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+b16_b8_2 ()\n+{\n+  svbool_t res = svptrue_pat_b16 (SV_VL32);\n+  return svptest_any (svptrue_b8 (), res);\n+}\n+\n+void\n+b16_b32_1 (int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svptrue_pat_b16 (SV_VL16);\n+  *any = svptest_any (svptrue_b32 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+b16_b32_2 ()\n+{\n+  svbool_t res = svptrue_pat_b16 (SV_VL16);\n+  return svptest_any (svptrue_b32 (), res);\n+}\n+\n+void\n+b16_b64_1 (int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svptrue_pat_b16 (SV_VL64);\n+  *any = svptest_any (svptrue_b64 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+b16_b64_2 ()\n+{\n+  svbool_t res = svptrue_pat_b16 (SV_VL64);\n+  return svptest_any (svptrue_b64 (), res);\n+}\n+\n+void\n+b32_b8_1 (int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svptrue_pat_b32 (SV_VL16);\n+  *any = svptest_any (svptrue_b8 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+b32_b8_2 ()\n+{\n+  svbool_t res = svptrue_pat_b32 (SV_VL16);\n+  return svptest_any (svptrue_b8 (), res);\n+}\n+\n+void\n+b32_b16_1 (int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svptrue_pat_b32 (SV_VL6);\n+  *any = svptest_any (svptrue_b16 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+b32_b16_2 ()\n+{\n+  svbool_t res = svptrue_pat_b32 (SV_VL6);\n+  return svptest_any (svptrue_b16 (), res);\n+}\n+\n+void\n+b32_b64_1 (int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svptrue_pat_b32 (SV_VL32);\n+  *any = svptest_any (svptrue_b64 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+b32_b64_2 ()\n+{\n+  svbool_t res = svptrue_pat_b32 (SV_VL32);\n+  return svptest_any (svptrue_b64 (), res);\n+}\n+\n+void\n+b64_b8_1 (int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svptrue_pat_b64 (SV_VL7);\n+  *any = svptest_any (svptrue_b8 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+b64_b8_2 ()\n+{\n+  svbool_t res = svptrue_pat_b64 (SV_VL7);\n+  return svptest_any (svptrue_b8 (), res);\n+}\n+\n+void\n+b64_b16_1 (int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svptrue_pat_b64 (SV_VL16);\n+  *any = svptest_any (svptrue_b16 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+b64_b16_2 ()\n+{\n+  svbool_t res = svptrue_pat_b64 (SV_VL16);\n+  return svptest_any (svptrue_b16 (), res);\n+}\n+\n+void\n+b64_b32_1 (int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svptrue_pat_b64 (SV_VL32);\n+  *any = svptest_any (svptrue_b32 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+b64_b32_2 ()\n+{\n+  svbool_t res = svptrue_pat_b64 (SV_VL32);\n+  return svptest_any (svptrue_b32 (), res);\n+}\n+\n+/* { dg-final { scan-assembler-not {\\tptrues\\n} } } */\n+/* { dg-final { scan-assembler-times {\\tptrue\\t} 48 } } */\n+/* { dg-final { scan-assembler-times {\\tptest\\t} 24 } } */"}, {"sha": "ba512f40659320ac8613507756f6a4ea74402916", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/qincb_1.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fqincb_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fqincb_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fqincb_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/*\n+** qincb_s32_s:\n+**\tsqincb\tx0, w0, all, mul #15\n+**\tret\n+*/\n+uint64_t qincb_s32_s (int32_t x) { return svqincb (x, 15); }\n+\n+/*\n+** qincb_s32_z:\n+**\tsqincb\tx([0-9]+), w0, all, mul #15\n+**\tuxtw\tx0, w\\1\n+**\tret\n+*/\n+uint64_t qincb_s32_z (int32_t x) { return (uint32_t) svqincb (x, 15); }\n+\n+/*\n+** qincb_u32_s:\n+**\tuqincb\t(w[0-9]+), all, mul #15\n+**\tsxtw\tx0, \\1\n+**\tret\n+*/\n+uint64_t qincb_u32_s (uint32_t x) { return (int32_t) svqincb (x, 15); }\n+\n+/*\n+** qincb_u32_z:\n+**\tuqincb\tw0, all, mul #15\n+**\tret\n+*/\n+uint64_t qincb_u32_z (uint32_t x) { return svqincb (x, 15); }\n+\n+#ifdef __cplusplus\n+}\n+#endif"}, {"sha": "50892c85acaa538220c938de5e828a7b78f36ddc", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/struct_1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fstruct_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fstruct_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fstruct_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,16 @@\n+#include <arm_sve.h>\n+\n+void\n+f (svint8x2_t *a, svint8x2_t *b)\n+{\n+  svint8_t *ptr;\n+  svint8x2_t x = *a;\n+  *a = *b;\n+  a = &x;\n+  (void) (a == b);\n+  (void) (a != b);\n+  (void) (a < b);\n+  (void) (a > b);\n+  (void) (a <= b);\n+  (void) (a >= b);\n+}"}, {"sha": "1d5523e3132643a738189683fcf313fe79b82dc7", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/whilele_1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (int32_t x, int32_t y, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svwhilele_b8 (x, y);\n+  *any = svptest_last (svptrue_b8 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (int32_t x, int32_t y)\n+{\n+  svbool_t res = svwhilele_b8 (x, y);\n+  return svptest_last (svptrue_b8 (), res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\twhilele\\t} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tptrue\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tptest\\t} } } */"}, {"sha": "ca339c41c6eb7bf162ffcc6a72817722abc0975c", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/whilele_10.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_10.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+/* { dg-final { scan-assembler-not {\\twhilele\\t} } } */\n+/* { dg-final { scan-assembler-not {\\twhilelt\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tptrue\\t} } } */\n+\n+void\n+test1 (svbool_t *ptr)\n+{\n+  *ptr = svwhilele_b32_u32 (-1, 0);\n+}\n+\n+void\n+test2 (svbool_t *ptr)\n+{\n+  *ptr = svwhilele_b16_u64 (0x80000000, 0);\n+}\n+\n+void\n+test3 (svbool_t *ptr)\n+{\n+  *ptr = svwhilele_b8_u64 (0x8000000000000001ULL, 0x7ffffffffffffffeULL);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tpfalse\\tp[0-7]\\.b\\n} 3 } } */"}, {"sha": "02084600760404814152442e69de689074f7b4cb", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/whilele_2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (int32_t x, int32_t y, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svwhilele_b16 (x, y);\n+  *any = svptest_last (svptrue_b16 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (int32_t x, int32_t y)\n+{\n+  svbool_t res = svwhilele_b16 (x, y);\n+  return svptest_last (svptrue_b16 (), res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\twhilele\\t} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tptrue\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tptest\\t} } } */"}, {"sha": "4a1045cf631ce2143760cd5d6483feaeb2278938", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/whilele_3.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (int32_t x, int32_t y, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svwhilele_b32 (x, y);\n+  *any = svptest_last (svptrue_b32 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (int32_t x, int32_t y)\n+{\n+  svbool_t res = svwhilele_b32 (x, y);\n+  return svptest_last (svptrue_b32 (), res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\twhilele\\t} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tptrue\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tptest\\t} } } */"}, {"sha": "f6fb0d0992f8d184c6d62d175f9e4256180fb852", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/whilele_4.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_4.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+void\n+test1 (int32_t x, int32_t y, int *any, svbool_t *ptr)\n+{\n+  svbool_t res = svwhilele_b64 (x, y);\n+  *any = svptest_last (svptrue_b64 (), res);\n+  *ptr = res;\n+}\n+\n+int\n+test2 (int32_t x, int32_t y)\n+{\n+  svbool_t res = svwhilele_b64 (x, y);\n+  return svptest_last (svptrue_b64 (), res);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\twhilele\\t} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tptrue\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tptest\\t} } } */"}, {"sha": "ada958b29c1ef31d4d42f9e18c871c02b87b7601", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/whilele_5.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_5.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+/* { dg-final { scan-assembler-not {\\twhilele\\t} } } */\n+/* { dg-final { scan-assembler-not {\\twhilelt\\t} } } */\n+\n+void\n+test1 (svbool_t *ptr)\n+{\n+  *ptr = svwhilele_b32_s32 (-8, -8);\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.[bhsd], vl1\\n} } } */\n+\n+void\n+test2 (svbool_t *ptr)\n+{\n+  *ptr = svwhilele_b16_s64 (-1, 1);\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.h, vl3\\n} } } */\n+\n+void\n+test3 (svbool_t *ptr)\n+{\n+  *ptr = svwhilele_b16_s32 (0x7ffffffb, 0x7fffffff);\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.h, vl5\\n} } } */\n+\n+void\n+test4 (svbool_t *ptr)\n+{\n+  *ptr = svwhilele_b8_s64 (svcntb (), svcntb () + 6);\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.b, vl7\\n} } } */\n+\n+void\n+test5 (svbool_t *ptr)\n+{\n+  *ptr = svwhilele_b64_s64 (0, 1);\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.d, vl2\\n} } } */"}, {"sha": "00d92ba8a47fbd5a34144f41112d4008a64fdc41", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/whilele_6.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_6.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+/* { dg-final { scan-assembler-not {\\twhilele\\t} } } */\n+/* { dg-final { scan-assembler-not {\\twhilelt\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tptrue\\t} } } */\n+\n+void\n+test1 (svbool_t *ptr)\n+{\n+  *ptr = svwhilele_b32_s32 (-8, -9);\n+}\n+\n+void\n+test2 (svbool_t *ptr)\n+{\n+  *ptr = svwhilele_b16_s64 (50, -1);\n+}\n+\n+void\n+test3 (svbool_t *ptr)\n+{\n+  *ptr = svwhilele_b16_s32 (0x7ffffffb, 0x80000000);\n+}\n+\n+void\n+test4 (svbool_t *ptr)\n+{\n+  *ptr = svwhilele_b8_s64 (svcntb (), 15);\n+}\n+\n+void\n+test5 (svbool_t *ptr)\n+{\n+  *ptr = svwhilele_b8_s64 (svcntb (), svcntw ());\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tpfalse\\tp[0-7]\\.b\\n} 5 } } */"}, {"sha": "92488f5972f7b92506c9bbdb485366c00943311c", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/whilele_7.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_7.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+/* { dg-final { scan-assembler-not {\\twhilel[et]\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tpfalse\\t} } } */\n+\n+void\n+test1 (svbool_t *ptr)\n+{\n+  *ptr = svwhilele_b8_s32 (-svcnth (), svcnth () - 1);\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.b, all\\n} } } */\n+\n+void\n+test2 (svbool_t *ptr)\n+{\n+  *ptr = svwhilele_b16_s64 (1, svcntw () * 2);\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.h, all\\n} } } */\n+\n+void\n+test3 (svbool_t *ptr)\n+{\n+  *ptr = svwhilele_b32_s32 (svcntd (), svcntw () + svcntd () - 1);\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.s, all\\n} } } */"}, {"sha": "e7f81a86f31d79d98e7f1e9ffb83e3a7dc187f96", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/whilele_9.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilele_9.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+/* { dg-final { scan-assembler-not {\\twhilele\\t} } } */\n+/* { dg-final { scan-assembler-not {\\twhilelt\\t} } } */\n+\n+void\n+test1 (svbool_t *ptr)\n+{\n+  *ptr = svwhilele_b32_u32 (1, 3);\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.s, vl3\\n} } } */\n+\n+void\n+test2 (svbool_t *ptr)\n+{\n+  *ptr = svwhilele_b16_u64 (svcntd (), svcntd () + 5);\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.h, vl6\\n} } } */\n+\n+void\n+test3 (svbool_t *ptr)\n+{\n+  *ptr = svwhilele_b8_u32 (0x7ffffffb, 0x80000002);\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.b, vl8\\n} } } */"}, {"sha": "5c8f97e2f269f95b523dedc1818d286e228e371b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/whilelt_1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilelt_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilelt_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilelt_1.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+/* { dg-final { scan-assembler-not {\\twhilele\\t} } } */\n+/* { dg-final { scan-assembler-not {\\twhilelt\\t} } } */\n+\n+void\n+test1 (svbool_t *ptr)\n+{\n+  *ptr = svwhilelt_b32_s32 (-8, -7);\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.[bhsd], vl1\\n} } } */\n+\n+void\n+test2 (svbool_t *ptr)\n+{\n+  *ptr = svwhilelt_b16_s64 (-1, 2);\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.h, vl3\\n} } } */\n+\n+void\n+test3 (svbool_t *ptr)\n+{\n+  *ptr = svwhilelt_b16_s32 (0x7ffffffa, 0x7fffffff);\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.h, vl5\\n} } } */\n+\n+void\n+test4 (svbool_t *ptr)\n+{\n+  *ptr = svwhilelt_b8_s64 (svcntb (), svcntb () + 7);\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.b, vl7\\n} } } */\n+\n+void\n+test5 (svbool_t *ptr)\n+{\n+  *ptr = svwhilelt_b64_s64 (0, 2);\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.d, vl2\\n} } } */"}, {"sha": "2be3a5b0c3e14e66768305b2f8fece7b29b5ba9d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/whilelt_2.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilelt_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilelt_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilelt_2.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+/* { dg-final { scan-assembler-not {\\twhilele\\t} } } */\n+/* { dg-final { scan-assembler-not {\\twhilelt\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tptrue\\t} } } */\n+\n+void\n+test1 (svbool_t *ptr)\n+{\n+  *ptr = svwhilelt_b32_s32 (0, 0);\n+}\n+\n+void\n+test2 (svbool_t *ptr)\n+{\n+  *ptr = svwhilelt_b16_s64 (50, -1);\n+}\n+\n+void\n+test3 (svbool_t *ptr)\n+{\n+  *ptr = svwhilelt_b16_s32 (0x7ffffffb, 0x80000000);\n+}\n+\n+void\n+test4 (svbool_t *ptr)\n+{\n+  *ptr = svwhilelt_b8_s64 (svcntb (), svcntb ());\n+}\n+\n+void\n+test5 (svbool_t *ptr)\n+{\n+  *ptr = svwhilelt_b8_s64 (svcntb (), svcntw ());\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tpfalse\\tp[0-7]\\.b\\n} 5 } } */"}, {"sha": "650b2652fec96d979e530ce275b240e7f1be2c23", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/whilelt_3.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilelt_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624d0f07d51b7fa8bc99142bd0e8380fb9e7badc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilelt_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fwhilelt_3.c?ref=624d0f07d51b7fa8bc99142bd0e8380fb9e7badc", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <arm_sve.h>\n+\n+/* { dg-final { scan-assembler-not {\\twhilel[et]\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tpfalse\\t} } } */\n+\n+void\n+test1 (svbool_t *ptr)\n+{\n+  *ptr = svwhilelt_b8_s32 (-svcnth (), svcnth ());\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.b, all\\n} } } */\n+\n+void\n+test2 (svbool_t *ptr)\n+{\n+  *ptr = svwhilelt_b16_s64 (0, svcntw () * 2);\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.h, all\\n} } } */\n+\n+void\n+test3 (svbool_t *ptr)\n+{\n+  *ptr = svwhilelt_b32_s32 (svcntd (), svcntw () + svcntd ());\n+}\n+\n+/* { dg-final { scan-assembler {\\tptrue\\tp[0-7]\\.s, all\\n} } } */"}]}