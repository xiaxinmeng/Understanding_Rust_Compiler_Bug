{"sha": "b2c6e7979854d03e0153fc702298a6fbbf268eb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJjNmU3OTc5ODU0ZDAzZTAxNTNmYzcwMjI5OGE2ZmJiZjI2OGViNg==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2007-03-02T10:58:26Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2007-03-02T10:58:26Z"}, "message": "AnnotationInvocationHandler.java: Moved from Classpath to libgcj local.\n\n2007-03-02  Andrew Haley  <aph@redhat.com>\n\n\t* sun/reflect/annotation/AnnotationInvocationHandler.java: Moved\n\tfrom Classpath to libgcj local.\n\nFrom-SVN: r122470", "tree": {"sha": "f57e2c930100bd1f00cba542bab0188debe3214f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f57e2c930100bd1f00cba542bab0188debe3214f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2c6e7979854d03e0153fc702298a6fbbf268eb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2c6e7979854d03e0153fc702298a6fbbf268eb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2c6e7979854d03e0153fc702298a6fbbf268eb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2c6e7979854d03e0153fc702298a6fbbf268eb6/comments", "author": null, "committer": null, "parents": [{"sha": "cee690f1844f3da539acd66917847ba57905206e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cee690f1844f3da539acd66917847ba57905206e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cee690f1844f3da539acd66917847ba57905206e"}], "stats": {"total": 396, "additions": 396, "deletions": 0}, "files": [{"sha": "f132d81bad8fb43663cf2a53e4a98e544d90f7b8", "filename": "libjava/sun/reflect/annotation/AnnotationInvocationHandler.java", "status": "added", "additions": 396, "deletions": 0, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2c6e7979854d03e0153fc702298a6fbbf268eb6/libjava%2Fsun%2Freflect%2Fannotation%2FAnnotationInvocationHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2c6e7979854d03e0153fc702298a6fbbf268eb6/libjava%2Fsun%2Freflect%2Fannotation%2FAnnotationInvocationHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsun%2Freflect%2Fannotation%2FAnnotationInvocationHandler.java?ref=b2c6e7979854d03e0153fc702298a6fbbf268eb6", "patch": "@@ -0,0 +1,396 @@\n+/* sun.reflect.annotation.AnnotationInvocationHandler\n+   Copyright (C) 2006\n+   Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package sun.reflect.annotation;\n+\n+import java.io.Serializable;\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.AnnotationTypeMismatchException;\n+import java.lang.annotation.IncompleteAnnotationException;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+/**\n+ * This class exists for serialization compatibility with the JDK.\n+ * VMs can choose to implement annotations by constructing proxies\n+ * with this invocation handler, but that is not required.\n+ * If a different strategy for proxy objects is chosen, they can\n+ * have a writeReplace method to substitute a Proxy based on this\n+ * invocation handler is used for serialization.\n+ */\n+public final class AnnotationInvocationHandler\n+  implements InvocationHandler, Serializable\n+{\n+    private static final long serialVersionUID = 6182022883658399397L;\n+    private final Class type;\n+    private final Map memberValues;\n+\n+    /**\n+     * Construct a new invocation handler for an annotation proxy.\n+     * Note that the VM is responsible for filling the memberValues map\n+     * with the default values of all the annotation members.\n+     */\n+    public AnnotationInvocationHandler(Class type, Map memberValues)\n+    {\n+        this.type = type;\n+        this.memberValues = memberValues;\n+    }\n+\n+    public static Annotation create(Class type, Map memberValues)\n+    {\n+      for (Method m : type.getDeclaredMethods())\n+\t{\n+\t  String name = m.getName();\n+\t  if (! memberValues.containsKey(name))\n+\t    {\n+\t      // FIXME: what to do about exceptions here?\n+\t      memberValues.put(name, m.getDefaultValue());\n+\t    }\n+\t}\n+      AnnotationInvocationHandler handler\n+\t= new AnnotationInvocationHandler(type, memberValues);\n+      return (Annotation) Proxy.newProxyInstance(type.getClassLoader(),\n+\t\t\t\t\t\t new Class[] { type },\n+\t\t\t\t\t\t handler);\n+    }\n+\n+    /**\n+     * Compare an instance of AnnotationInvocationHandler with another object.\n+     * Note that the other object does not have to be an\n+     * AnnotationInvocationHandler, any implementation of the annotation\n+     * interface is allowed to be compared for equality.\n+     * Note that this makes the equals method asymmetric, but this behavior\n+     * is specified by Annotation.equals and identical to the JDK.\n+     *\n+     * This method is public for use by other parts of the VM. Some VMs\n+     * (can) use different representations of annotations that reuse this\n+     * method.\n+     */\n+    public static boolean equals(Class type, Map memberValues, Object other)\n+    {\n+        if (type.isInstance(other))\n+        {\n+            try\n+            {\n+                Method[] methods = type.getDeclaredMethods();\n+                if (methods.length == memberValues.size())\n+                {\n+                    for (int i = 0; i < methods.length; i++)\n+                    {\n+                        String key = methods[i].getName();\n+                        Object val = methods[i].invoke(other, new Object[0]);\n+                        if (! deepEquals(memberValues.get(key), val))\n+                        {\n+                            return false;\n+                        }\n+                    }\n+                    return true;\n+                }\n+            }\n+            catch (IllegalAccessException _)\n+            {\n+                // Ignore exception, like the JDK\n+            }\n+            catch (InvocationTargetException _)\n+            {\n+                // Ignore exception, like the JDK\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static boolean deepEquals(Object o1, Object o2)\n+    {\n+        if (o1 == o2)\n+            return true;\n+\n+        if (o1 == null || o2 == null)\n+            return false;\n+\n+        if (o1 instanceof boolean[] && o2 instanceof boolean[])\n+            return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n+\n+        if (o1 instanceof byte[] && o2 instanceof byte[])\n+            return Arrays.equals((byte[]) o1, (byte[]) o2);\n+\n+        if (o1 instanceof char[] && o2 instanceof char[])\n+            return Arrays.equals((char[]) o1, (char[]) o2);\n+\n+        if (o1 instanceof short[] && o2 instanceof short[])\n+            return Arrays.equals((short[]) o1, (short[]) o2);\n+\n+        if (o1 instanceof int[] && o2 instanceof int[])\n+            return Arrays.equals((int[]) o1, (int[]) o2);\n+\n+        if (o1 instanceof float[] && o2 instanceof float[])\n+            return Arrays.equals((float[]) o1, (float[]) o2);\n+\n+        if (o1 instanceof long[] && o2 instanceof long[])\n+            return Arrays.equals((long[]) o1, (long[]) o2);\n+\n+        if (o1 instanceof double[] && o2 instanceof double[])\n+            return Arrays.equals((double[]) o1, (double[]) o2);\n+\n+        if (o1 instanceof Object[] && o2 instanceof Object[])\n+            return Arrays.equals((Object[]) o1, (Object[]) o2);\n+\n+        return o1.equals(o2);\n+    }\n+\n+    private static int deepHashCode(Object obj)\n+    {\n+        if (obj instanceof boolean[])\n+            return Arrays.hashCode((boolean[]) obj);\n+\n+        if (obj instanceof byte[])\n+            return Arrays.hashCode((byte[]) obj);\n+\n+        if (obj instanceof char[])\n+            return Arrays.hashCode((char[]) obj);\n+\n+        if (obj instanceof short[])\n+            return Arrays.hashCode((short[]) obj);\n+\n+        if (obj instanceof int[])\n+            return Arrays.hashCode((int[]) obj);\n+\n+        if (obj instanceof float[])\n+            return Arrays.hashCode((float[]) obj);\n+\n+        if (obj instanceof long[])\n+            return Arrays.hashCode((long[]) obj);\n+\n+        if (obj instanceof double[])\n+            return Arrays.hashCode((double[]) obj);\n+\n+        if (obj instanceof Object[])\n+            return Arrays.hashCode((Object[]) obj);\n+\n+        return obj.hashCode();\n+    }\n+\n+    /**\n+     * Compute the hashCode for an annotation. Note that the algorithm is\n+     * specified by Annotation.hashCode.\n+     *\n+     * This method is public for use by other parts of the VM. Some VMs\n+     * (can) use different representations of annotations that reuse this\n+     * method.\n+     */\n+    public static int hashCode(Class type, Map memberValues)\n+    {\n+        int h = 0;\n+        Iterator iter = memberValues.keySet().iterator();\n+        while (iter.hasNext())\n+        {\n+            Object key = iter.next();\n+            Object val = memberValues.get(key);\n+            h += deepHashCode(val) ^ 127 * key.hashCode();\n+        }\n+        return h;\n+    }\n+\n+    private static String deepToString(Object obj)\n+    {\n+        if (obj instanceof boolean[])\n+            return Arrays.toString((boolean[]) obj);\n+\n+        if (obj instanceof byte[])\n+            return Arrays.toString((byte[]) obj);\n+\n+        if (obj instanceof char[])\n+            return Arrays.toString((char[]) obj);\n+\n+        if (obj instanceof short[])\n+            return Arrays.toString((short[]) obj);\n+\n+        if (obj instanceof int[])\n+            return Arrays.toString((int[]) obj);\n+\n+        if (obj instanceof float[])\n+            return Arrays.toString((float[]) obj);\n+\n+        if (obj instanceof long[])\n+            return Arrays.toString((long[]) obj);\n+\n+        if (obj instanceof double[])\n+            return Arrays.toString((double[]) obj);\n+\n+        if (obj instanceof Object[])\n+            return Arrays.toString((Object[]) obj);\n+\n+        return obj.toString();\n+    }\n+\n+    /**\n+     * This method is public for use by other parts of the VM. Some VMs\n+     * (can) use different representations of annotations that reuse this\n+     * method.\n+     */\n+    public static String toString(Class type, Map memberValues)\n+    {\n+        StringBuffer sb = new StringBuffer();\n+        sb.append('@').append(type.getName()).append('(');\n+        String sep = \"\";\n+        Iterator iter = memberValues.keySet().iterator();\n+        while (iter.hasNext())\n+        {\n+            Object key = iter.next();\n+            Object val = memberValues.get(key);\n+            sb.append(sep).append(key).append('=').append(deepToString(val));\n+            sep = \", \";\n+        }\n+        sb.append(')');\n+        return sb.toString();\n+    }\n+\n+    private static Class getBoxedReturnType(Method method)\n+    {\n+        Class returnType = method.getReturnType();\n+\n+        if (returnType == boolean.class)\n+            return Boolean.class;\n+\n+        if (returnType == byte.class)\n+            return Byte.class;\n+\n+        if (returnType == char.class)\n+            return Character.class;\n+\n+        if (returnType == short.class)\n+            return Short.class;\n+\n+        if (returnType == int.class)\n+            return Integer.class;\n+\n+        if (returnType == float.class)\n+            return Float.class;\n+\n+        if (returnType == long.class)\n+            return Long.class;\n+\n+        if (returnType == double.class)\n+            return Double.class;\n+\n+        return returnType;\n+    }\n+\n+    private Object arrayClone(Object obj)\n+    {\n+        if (obj instanceof boolean[])\n+\t    return ((boolean[]) obj).clone();\n+\n+        if (obj instanceof byte[])\n+\t    return ((byte[]) obj).clone();\n+\n+        if (obj instanceof char[])\n+\t    return ((char[]) obj).clone();\n+\n+        if (obj instanceof short[])\n+\t    return ((short[]) obj).clone();\n+\n+        if (obj instanceof int[])\n+\t    return ((int[]) obj).clone();\n+\n+        if (obj instanceof float[])\n+\t    return ((float[]) obj).clone();\n+\n+        if (obj instanceof long[])\n+\t    return ((long[]) obj).clone();\n+\n+        if (obj instanceof double[])\n+\t    return ((double[]) obj).clone();\n+\n+        if (obj instanceof Object[])\n+\t    return ((Object[]) obj).clone();\n+\n+        return obj;\n+    }\n+\n+    public Object invoke(Object proxy, Method method, Object[] args)\n+      throws Throwable\n+    {\n+        String methodName = method.getName().intern();\n+        if (args == null || args.length == 0)\n+        {\n+            if (methodName == \"toString\")\n+            {\n+                return toString(type, memberValues);\n+            }\n+            else if (methodName == \"hashCode\")\n+            {\n+                return Integer.valueOf(hashCode(type, memberValues));\n+            }\n+            else if (methodName == \"annotationType\")\n+            {\n+                return type;\n+            }\n+            else\n+            {\n+                Object val = memberValues.get(methodName);\n+                if (val == null)\n+                {\n+                    throw new IncompleteAnnotationException(type, methodName);\n+                }\n+                if (! getBoxedReturnType(method).isInstance(val))\n+                {\n+                    throw new AnnotationTypeMismatchException(method,\n+                        val.getClass().getName());\n+                }\n+\t\tif (val.getClass().isArray())\n+\t\t{\n+\t\t    val = arrayClone(val);\n+\t\t}\n+                return val;\n+            }\n+        }\n+        else if (args.length == 1)\n+        {\n+            if (methodName == \"equals\")\n+            {\n+                return Boolean.valueOf(equals(type, memberValues, args[0]));\n+            }\n+        }\n+        throw new InternalError(\"Invalid annotation proxy\");\n+    }\n+}"}]}