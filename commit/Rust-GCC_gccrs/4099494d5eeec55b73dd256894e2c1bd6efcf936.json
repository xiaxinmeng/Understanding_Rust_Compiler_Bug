{"sha": "4099494d5eeec55b73dd256894e2c1bd6efcf936", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA5OTQ5NGQ1ZWVlYzU1YjczZGQyNTY4OTRlMmMxYmQ2ZWZjZjkzNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@linux.vnet.ibm.com", "date": "2014-02-07T14:50:19Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-02-07T14:50:19Z"}, "message": "s390.c: Include tree-pass.h and context.h.\n\ngcc/\n\t* config/s390/s390.c: Include tree-pass.h and context.h.\n\t(s390_early_mach): New function, split out from...\n\t(s390_emit_prologue): ...here.\n\t(pass_data_s390_early_mach): New pass structure.\n\t(pass_s390_early_mach): New class.\n\t(s390_option_override): Create and register early_mach pass.\n\tMove to end of file.\n\nFrom-SVN: r207603", "tree": {"sha": "5690bf87cd495b90836e1c25d96950370149c1ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5690bf87cd495b90836e1c25d96950370149c1ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4099494d5eeec55b73dd256894e2c1bd6efcf936", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4099494d5eeec55b73dd256894e2c1bd6efcf936", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4099494d5eeec55b73dd256894e2c1bd6efcf936", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4099494d5eeec55b73dd256894e2c1bd6efcf936/comments", "author": null, "committer": null, "parents": [{"sha": "3489cc3363c657e70b5c4dd25abf6f0de6d83c72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3489cc3363c657e70b5c4dd25abf6f0de6d83c72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3489cc3363c657e70b5c4dd25abf6f0de6d83c72"}], "stats": {"total": 517, "additions": 291, "deletions": 226}, "files": [{"sha": "e0a759ba1fa6592e5481230f9262bd42e35cffbc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4099494d5eeec55b73dd256894e2c1bd6efcf936/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4099494d5eeec55b73dd256894e2c1bd6efcf936/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4099494d5eeec55b73dd256894e2c1bd6efcf936", "patch": "@@ -1,3 +1,13 @@\n+2014-02-07  Richard Sandiford  <rsandifo@linux.vnet.ibm.com>\n+\n+\t* config/s390/s390.c: Include tree-pass.h and context.h.\n+\t(s390_early_mach): New function, split out from...\n+\t(s390_emit_prologue): ...here.\n+\t(pass_data_s390_early_mach): New pass structure.\n+\t(pass_s390_early_mach): New class.\n+\t(s390_option_override): Create and register early_mach pass.\n+\tMove to end of file.\n+\n 2014-02-07  Richard Sandiford  <rsandifo@linux.vnet.ibm.com>\n \n \t* var-tracking.c (vt_stack_adjustments): Don't require stack_adjusts"}, {"sha": "3e7548f6159f338601301fafcdd2f203e95ed364", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 281, "deletions": 226, "changes": 507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4099494d5eeec55b73dd256894e2c1bd6efcf936/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4099494d5eeec55b73dd256894e2c1bd6efcf936/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=4099494d5eeec55b73dd256894e2c1bd6efcf936", "patch": "@@ -68,6 +68,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"cfgloop.h\"\n #include \"opts.h\"\n+#include \"tree-pass.h\"\n+#include \"context.h\"\n \n /* Define the specific costs for a given cpu.  */\n \n@@ -1678,220 +1680,6 @@ s390_init_machine_status (void)\n   return ggc_alloc_cleared_machine_function ();\n }\n \n-static void\n-s390_option_override (void)\n-{\n-  unsigned int i;\n-  cl_deferred_option *opt;\n-  vec<cl_deferred_option> *v =\n-    (vec<cl_deferred_option> *) s390_deferred_options;\n-\n-  if (v)\n-    FOR_EACH_VEC_ELT (*v, i, opt)\n-      {\n-\tswitch (opt->opt_index)\n-\t  {\n-\t  case OPT_mhotpatch:\n-\t    s390_hotpatch_trampoline_halfwords = (opt->value) ?\n-\t      s390_hotpatch_trampoline_halfwords_default : -1;\n-\t    break;\n-\t  case OPT_mhotpatch_:\n-\t    {\n-\t      int val;\n-\n-\t      val = integral_argument (opt->arg);\n-\t      if (val == -1)\n-\t\t{\n-\t\t  /* argument is not a plain number */\n-\t\t  error (\"argument to %qs should be a non-negative integer\",\n-\t\t\t \"-mhotpatch=\");\n-\t\t  break;\n-\t\t}\n-\t      else if (val > s390_hotpatch_trampoline_halfwords_max)\n-\t\t{\n-\t\t  error (\"argument to %qs is too large (max. %d)\",\n-\t\t\t \"-mhotpatch=\", s390_hotpatch_trampoline_halfwords_max);\n-\t\t  break;\n-\t\t}\n-\t      s390_hotpatch_trampoline_halfwords = val;\n-\t      break;\n-\t    }\n-\t  default:\n-\t    gcc_unreachable ();\n-\t  }\n-      }\n-\n-  /* Set up function hooks.  */\n-  init_machine_status = s390_init_machine_status;\n-\n-  /* Architecture mode defaults according to ABI.  */\n-  if (!(target_flags_explicit & MASK_ZARCH))\n-    {\n-      if (TARGET_64BIT)\n-\ttarget_flags |= MASK_ZARCH;\n-      else\n-\ttarget_flags &= ~MASK_ZARCH;\n-    }\n-\n-  /* Set the march default in case it hasn't been specified on\n-     cmdline.  */\n-  if (s390_arch == PROCESSOR_max)\n-    {\n-      s390_arch_string = TARGET_ZARCH? \"z900\" : \"g5\";\n-      s390_arch = TARGET_ZARCH ? PROCESSOR_2064_Z900 : PROCESSOR_9672_G5;\n-      s390_arch_flags = processor_flags_table[(int)s390_arch];\n-    }\n-\n-  /* Determine processor to tune for.  */\n-  if (s390_tune == PROCESSOR_max)\n-    {\n-      s390_tune = s390_arch;\n-      s390_tune_flags = s390_arch_flags;\n-    }\n-\n-  /* Sanity checks.  */\n-  if (TARGET_ZARCH && !TARGET_CPU_ZARCH)\n-    error (\"z/Architecture mode not supported on %s\", s390_arch_string);\n-  if (TARGET_64BIT && !TARGET_ZARCH)\n-    error (\"64-bit ABI not supported in ESA/390 mode\");\n-\n-  /* Use hardware DFP if available and not explicitly disabled by\n-     user. E.g. with -m31 -march=z10 -mzarch   */\n-  if (!(target_flags_explicit & MASK_HARD_DFP) && TARGET_DFP)\n-    target_flags |= MASK_HARD_DFP;\n-\n-  /* Enable hardware transactions if available and not explicitly\n-     disabled by user.  E.g. with -m31 -march=zEC12 -mzarch */\n-  if (!(target_flags_explicit & MASK_OPT_HTM) && TARGET_CPU_HTM && TARGET_ZARCH)\n-    target_flags |= MASK_OPT_HTM;\n-\n-  if (TARGET_HARD_DFP && !TARGET_DFP)\n-    {\n-      if (target_flags_explicit & MASK_HARD_DFP)\n-\t{\n-\t  if (!TARGET_CPU_DFP)\n-\t    error (\"hardware decimal floating point instructions\"\n-\t\t   \" not available on %s\", s390_arch_string);\n-\t  if (!TARGET_ZARCH)\n-\t    error (\"hardware decimal floating point instructions\"\n-\t\t   \" not available in ESA/390 mode\");\n-\t}\n-      else\n-\ttarget_flags &= ~MASK_HARD_DFP;\n-    }\n-\n-  if ((target_flags_explicit & MASK_SOFT_FLOAT) && TARGET_SOFT_FLOAT)\n-    {\n-      if ((target_flags_explicit & MASK_HARD_DFP) && TARGET_HARD_DFP)\n-\terror (\"-mhard-dfp can%'t be used in conjunction with -msoft-float\");\n-\n-      target_flags &= ~MASK_HARD_DFP;\n-    }\n-\n-  /* Set processor cost function.  */\n-  switch (s390_tune)\n-    {\n-    case PROCESSOR_2084_Z990:\n-      s390_cost = &z990_cost;\n-      break;\n-    case PROCESSOR_2094_Z9_109:\n-      s390_cost = &z9_109_cost;\n-      break;\n-    case PROCESSOR_2097_Z10:\n-      s390_cost = &z10_cost;\n-      break;\n-    case PROCESSOR_2817_Z196:\n-      s390_cost = &z196_cost;\n-      break;\n-    case PROCESSOR_2827_ZEC12:\n-      s390_cost = &zEC12_cost;\n-      break;\n-    default:\n-      s390_cost = &z900_cost;\n-    }\n-\n-  if (TARGET_BACKCHAIN && TARGET_PACKED_STACK && TARGET_HARD_FLOAT)\n-    error (\"-mbackchain -mpacked-stack -mhard-float are not supported \"\n-\t   \"in combination\");\n-\n-  if (s390_stack_size)\n-    {\n-      if (s390_stack_guard >= s390_stack_size)\n-\terror (\"stack size must be greater than the stack guard value\");\n-      else if (s390_stack_size > 1 << 16)\n-\terror (\"stack size must not be greater than 64k\");\n-    }\n-  else if (s390_stack_guard)\n-    error (\"-mstack-guard implies use of -mstack-size\");\n-\n-#ifdef TARGET_DEFAULT_LONG_DOUBLE_128\n-  if (!(target_flags_explicit & MASK_LONG_DOUBLE_128))\n-    target_flags |= MASK_LONG_DOUBLE_128;\n-#endif\n-\n-  if (s390_tune == PROCESSOR_2097_Z10\n-      || s390_tune == PROCESSOR_2817_Z196\n-      || s390_tune == PROCESSOR_2827_ZEC12)\n-    {\n-      maybe_set_param_value (PARAM_MAX_UNROLLED_INSNS, 100,\n-\t\t\t     global_options.x_param_values,\n-\t\t\t     global_options_set.x_param_values);\n-      maybe_set_param_value (PARAM_MAX_UNROLL_TIMES, 32,\n-\t\t\t     global_options.x_param_values,\n-\t\t\t     global_options_set.x_param_values);\n-      maybe_set_param_value (PARAM_MAX_COMPLETELY_PEELED_INSNS, 2000,\n-\t\t\t     global_options.x_param_values,\n-\t\t\t     global_options_set.x_param_values);\n-      maybe_set_param_value (PARAM_MAX_COMPLETELY_PEEL_TIMES, 64,\n-\t\t\t     global_options.x_param_values,\n-\t\t\t     global_options_set.x_param_values);\n-    }\n-\n-  maybe_set_param_value (PARAM_MAX_PENDING_LIST_LENGTH, 256,\n-\t\t\t global_options.x_param_values,\n-\t\t\t global_options_set.x_param_values);\n-  /* values for loop prefetching */\n-  maybe_set_param_value (PARAM_L1_CACHE_LINE_SIZE, 256,\n-\t\t\t global_options.x_param_values,\n-\t\t\t global_options_set.x_param_values);\n-  maybe_set_param_value (PARAM_L1_CACHE_SIZE, 128,\n-\t\t\t global_options.x_param_values,\n-\t\t\t global_options_set.x_param_values);\n-  /* s390 has more than 2 levels and the size is much larger.  Since\n-     we are always running virtualized assume that we only get a small\n-     part of the caches above l1.  */\n-  maybe_set_param_value (PARAM_L2_CACHE_SIZE, 1500,\n-\t\t\t global_options.x_param_values,\n-\t\t\t global_options_set.x_param_values);\n-  maybe_set_param_value (PARAM_PREFETCH_MIN_INSN_TO_MEM_RATIO, 2,\n-\t\t\t global_options.x_param_values,\n-\t\t\t global_options_set.x_param_values);\n-  maybe_set_param_value (PARAM_SIMULTANEOUS_PREFETCHES, 6,\n-\t\t\t global_options.x_param_values,\n-\t\t\t global_options_set.x_param_values);\n-\n-  /* This cannot reside in s390_option_optimization_table since HAVE_prefetch\n-     requires the arch flags to be evaluated already.  Since prefetching\n-     is beneficial on s390, we enable it if available.  */\n-  if (flag_prefetch_loop_arrays < 0 && HAVE_prefetch && optimize >= 3)\n-    flag_prefetch_loop_arrays = 1;\n-\n-  /* Use the alternative scheduling-pressure algorithm by default.  */\n-  maybe_set_param_value (PARAM_SCHED_PRESSURE_ALGORITHM, 2,\n-                         global_options.x_param_values,\n-                         global_options_set.x_param_values);\n-\n-  if (TARGET_TPF)\n-    {\n-      /* Don't emit DWARF3/4 unless specifically selected.  The TPF\n-\t debuggers do not yet support DWARF 3/4.  */\n-      if (!global_options_set.x_dwarf_strict) \n-\tdwarf_strict = 1;\n-      if (!global_options_set.x_dwarf_version)\n-\tdwarf_version = 2;\n-    }\n-}\n-\n /* Map for smallest class containing reg regno.  */\n \n const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER] =\n@@ -8832,16 +8620,14 @@ s390_restore_gprs_from_fprs (void)\n     }\n }\n \n-/* Expand the prologue into a bunch of separate insns.  */\n \n-void\n-s390_emit_prologue (void)\n+/* A pass run immediately before shrink-wrapping and prologue and epilogue\n+   generation.  */\n+\n+static unsigned int\n+s390_early_mach (void)\n {\n-  rtx insn, addr;\n-  rtx temp_reg;\n-  int i;\n-  int offset;\n-  int next_fpr = 0;\n+  rtx insn;\n \n   /* Try to get rid of the FPR clobbers.  */\n   s390_optimize_nonescaping_tx ();\n@@ -8851,17 +8637,57 @@ s390_emit_prologue (void)\n \n   /* Annotate all constant pool references to let the scheduler know\n      they implicitly use the base register.  */\n-\n-  push_topmost_sequence ();\n-\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n       {\n \tannotate_constant_pool_refs (&PATTERN (insn));\n \tdf_insn_rescan (insn);\n       }\n+  return 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_s390_early_mach =\n+{\n+  RTL_PASS, /* type */\n+  \"early_mach\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_MACH_DEP, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_df_verify | TODO_df_finish\n+    | TODO_verify_rtl_sharing ), /* todo_flags_finish */\n+};\n \n-  pop_topmost_sequence ();\n+class pass_s390_early_mach : public rtl_opt_pass\n+{\n+public:\n+  pass_s390_early_mach (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_s390_early_mach, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return s390_early_mach (); }\n+\n+}; // class pass_s390_early_mach\n+\n+} // anon namespace\n+\n+/* Expand the prologue into a bunch of separate insns.  */\n+\n+void\n+s390_emit_prologue (void)\n+{\n+  rtx insn, addr;\n+  rtx temp_reg;\n+  int i;\n+  int offset;\n+  int next_fpr = 0;\n \n   /* Choose best register to use for temp use within prologue.\n      See below for why TPF must use the register 1.  */\n@@ -11928,6 +11754,235 @@ s390_loop_unroll_adjust (unsigned nunroll, struct loop *loop)\n     }\n }\n \n+static void\n+s390_option_override (void)\n+{\n+  unsigned int i;\n+  cl_deferred_option *opt;\n+  vec<cl_deferred_option> *v =\n+    (vec<cl_deferred_option> *) s390_deferred_options;\n+\n+  if (v)\n+    FOR_EACH_VEC_ELT (*v, i, opt)\n+      {\n+\tswitch (opt->opt_index)\n+\t  {\n+\t  case OPT_mhotpatch:\n+\t    s390_hotpatch_trampoline_halfwords = (opt->value) ?\n+\t      s390_hotpatch_trampoline_halfwords_default : -1;\n+\t    break;\n+\t  case OPT_mhotpatch_:\n+\t    {\n+\t      int val;\n+\n+\t      val = integral_argument (opt->arg);\n+\t      if (val == -1)\n+\t\t{\n+\t\t  /* argument is not a plain number */\n+\t\t  error (\"argument to %qs should be a non-negative integer\",\n+\t\t\t \"-mhotpatch=\");\n+\t\t  break;\n+\t\t}\n+\t      else if (val > s390_hotpatch_trampoline_halfwords_max)\n+\t\t{\n+\t\t  error (\"argument to %qs is too large (max. %d)\",\n+\t\t\t \"-mhotpatch=\", s390_hotpatch_trampoline_halfwords_max);\n+\t\t  break;\n+\t\t}\n+\t      s390_hotpatch_trampoline_halfwords = val;\n+\t      break;\n+\t    }\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+      }\n+\n+  /* Set up function hooks.  */\n+  init_machine_status = s390_init_machine_status;\n+\n+  /* Architecture mode defaults according to ABI.  */\n+  if (!(target_flags_explicit & MASK_ZARCH))\n+    {\n+      if (TARGET_64BIT)\n+\ttarget_flags |= MASK_ZARCH;\n+      else\n+\ttarget_flags &= ~MASK_ZARCH;\n+    }\n+\n+  /* Set the march default in case it hasn't been specified on\n+     cmdline.  */\n+  if (s390_arch == PROCESSOR_max)\n+    {\n+      s390_arch_string = TARGET_ZARCH? \"z900\" : \"g5\";\n+      s390_arch = TARGET_ZARCH ? PROCESSOR_2064_Z900 : PROCESSOR_9672_G5;\n+      s390_arch_flags = processor_flags_table[(int)s390_arch];\n+    }\n+\n+  /* Determine processor to tune for.  */\n+  if (s390_tune == PROCESSOR_max)\n+    {\n+      s390_tune = s390_arch;\n+      s390_tune_flags = s390_arch_flags;\n+    }\n+\n+  /* Sanity checks.  */\n+  if (TARGET_ZARCH && !TARGET_CPU_ZARCH)\n+    error (\"z/Architecture mode not supported on %s\", s390_arch_string);\n+  if (TARGET_64BIT && !TARGET_ZARCH)\n+    error (\"64-bit ABI not supported in ESA/390 mode\");\n+\n+  /* Use hardware DFP if available and not explicitly disabled by\n+     user. E.g. with -m31 -march=z10 -mzarch   */\n+  if (!(target_flags_explicit & MASK_HARD_DFP) && TARGET_DFP)\n+    target_flags |= MASK_HARD_DFP;\n+\n+  /* Enable hardware transactions if available and not explicitly\n+     disabled by user.  E.g. with -m31 -march=zEC12 -mzarch */\n+  if (!(target_flags_explicit & MASK_OPT_HTM) && TARGET_CPU_HTM && TARGET_ZARCH)\n+    target_flags |= MASK_OPT_HTM;\n+\n+  if (TARGET_HARD_DFP && !TARGET_DFP)\n+    {\n+      if (target_flags_explicit & MASK_HARD_DFP)\n+\t{\n+\t  if (!TARGET_CPU_DFP)\n+\t    error (\"hardware decimal floating point instructions\"\n+\t\t   \" not available on %s\", s390_arch_string);\n+\t  if (!TARGET_ZARCH)\n+\t    error (\"hardware decimal floating point instructions\"\n+\t\t   \" not available in ESA/390 mode\");\n+\t}\n+      else\n+\ttarget_flags &= ~MASK_HARD_DFP;\n+    }\n+\n+  if ((target_flags_explicit & MASK_SOFT_FLOAT) && TARGET_SOFT_FLOAT)\n+    {\n+      if ((target_flags_explicit & MASK_HARD_DFP) && TARGET_HARD_DFP)\n+\terror (\"-mhard-dfp can%'t be used in conjunction with -msoft-float\");\n+\n+      target_flags &= ~MASK_HARD_DFP;\n+    }\n+\n+  /* Set processor cost function.  */\n+  switch (s390_tune)\n+    {\n+    case PROCESSOR_2084_Z990:\n+      s390_cost = &z990_cost;\n+      break;\n+    case PROCESSOR_2094_Z9_109:\n+      s390_cost = &z9_109_cost;\n+      break;\n+    case PROCESSOR_2097_Z10:\n+      s390_cost = &z10_cost;\n+      break;\n+    case PROCESSOR_2817_Z196:\n+      s390_cost = &z196_cost;\n+      break;\n+    case PROCESSOR_2827_ZEC12:\n+      s390_cost = &zEC12_cost;\n+      break;\n+    default:\n+      s390_cost = &z900_cost;\n+    }\n+\n+  if (TARGET_BACKCHAIN && TARGET_PACKED_STACK && TARGET_HARD_FLOAT)\n+    error (\"-mbackchain -mpacked-stack -mhard-float are not supported \"\n+\t   \"in combination\");\n+\n+  if (s390_stack_size)\n+    {\n+      if (s390_stack_guard >= s390_stack_size)\n+\terror (\"stack size must be greater than the stack guard value\");\n+      else if (s390_stack_size > 1 << 16)\n+\terror (\"stack size must not be greater than 64k\");\n+    }\n+  else if (s390_stack_guard)\n+    error (\"-mstack-guard implies use of -mstack-size\");\n+\n+#ifdef TARGET_DEFAULT_LONG_DOUBLE_128\n+  if (!(target_flags_explicit & MASK_LONG_DOUBLE_128))\n+    target_flags |= MASK_LONG_DOUBLE_128;\n+#endif\n+\n+  if (s390_tune == PROCESSOR_2097_Z10\n+      || s390_tune == PROCESSOR_2817_Z196\n+      || s390_tune == PROCESSOR_2827_ZEC12)\n+    {\n+      maybe_set_param_value (PARAM_MAX_UNROLLED_INSNS, 100,\n+\t\t\t     global_options.x_param_values,\n+\t\t\t     global_options_set.x_param_values);\n+      maybe_set_param_value (PARAM_MAX_UNROLL_TIMES, 32,\n+\t\t\t     global_options.x_param_values,\n+\t\t\t     global_options_set.x_param_values);\n+      maybe_set_param_value (PARAM_MAX_COMPLETELY_PEELED_INSNS, 2000,\n+\t\t\t     global_options.x_param_values,\n+\t\t\t     global_options_set.x_param_values);\n+      maybe_set_param_value (PARAM_MAX_COMPLETELY_PEEL_TIMES, 64,\n+\t\t\t     global_options.x_param_values,\n+\t\t\t     global_options_set.x_param_values);\n+    }\n+\n+  maybe_set_param_value (PARAM_MAX_PENDING_LIST_LENGTH, 256,\n+\t\t\t global_options.x_param_values,\n+\t\t\t global_options_set.x_param_values);\n+  /* values for loop prefetching */\n+  maybe_set_param_value (PARAM_L1_CACHE_LINE_SIZE, 256,\n+\t\t\t global_options.x_param_values,\n+\t\t\t global_options_set.x_param_values);\n+  maybe_set_param_value (PARAM_L1_CACHE_SIZE, 128,\n+\t\t\t global_options.x_param_values,\n+\t\t\t global_options_set.x_param_values);\n+  /* s390 has more than 2 levels and the size is much larger.  Since\n+     we are always running virtualized assume that we only get a small\n+     part of the caches above l1.  */\n+  maybe_set_param_value (PARAM_L2_CACHE_SIZE, 1500,\n+\t\t\t global_options.x_param_values,\n+\t\t\t global_options_set.x_param_values);\n+  maybe_set_param_value (PARAM_PREFETCH_MIN_INSN_TO_MEM_RATIO, 2,\n+\t\t\t global_options.x_param_values,\n+\t\t\t global_options_set.x_param_values);\n+  maybe_set_param_value (PARAM_SIMULTANEOUS_PREFETCHES, 6,\n+\t\t\t global_options.x_param_values,\n+\t\t\t global_options_set.x_param_values);\n+\n+  /* This cannot reside in s390_option_optimization_table since HAVE_prefetch\n+     requires the arch flags to be evaluated already.  Since prefetching\n+     is beneficial on s390, we enable it if available.  */\n+  if (flag_prefetch_loop_arrays < 0 && HAVE_prefetch && optimize >= 3)\n+    flag_prefetch_loop_arrays = 1;\n+\n+  /* Use the alternative scheduling-pressure algorithm by default.  */\n+  maybe_set_param_value (PARAM_SCHED_PRESSURE_ALGORITHM, 2,\n+                         global_options.x_param_values,\n+                         global_options_set.x_param_values);\n+\n+  if (TARGET_TPF)\n+    {\n+      /* Don't emit DWARF3/4 unless specifically selected.  The TPF\n+\t debuggers do not yet support DWARF 3/4.  */\n+      if (!global_options_set.x_dwarf_strict) \n+\tdwarf_strict = 1;\n+      if (!global_options_set.x_dwarf_version)\n+\tdwarf_version = 2;\n+    }\n+\n+  /* Register a target-specific optimization-and-lowering pass\n+     to run immediately before prologue and epilogue generation.\n+\n+     Registering the pass must be done at start up.  It's\n+     convenient to do it here.  */\n+  opt_pass *new_pass = new pass_s390_early_mach (g);\n+  struct register_pass_info insert_pass_s390_early_mach =\n+    {\n+      new_pass,\t\t\t/* pass */\n+      \"pro_and_epilogue\",\t/* reference_pass_name */\n+      1,\t\t\t/* ref_pass_instance_number */\n+      PASS_POS_INSERT_BEFORE\t/* po_op */\n+    };\n+  register_pass (&insert_pass_s390_early_mach);\n+}\n+\n /* Initialize GCC target structure.  */\n \n #undef  TARGET_ASM_ALIGNED_HI_OP"}]}