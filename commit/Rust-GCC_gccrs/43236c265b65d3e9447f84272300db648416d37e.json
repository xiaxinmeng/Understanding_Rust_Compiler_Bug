{"sha": "43236c265b65d3e9447f84272300db648416d37e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDMyMzZjMjY1YjY1ZDNlOTQ0N2Y4NDI3MjMwMGRiNjQ4NDE2ZDM3ZQ==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-11-03T10:39:15Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-11-03T10:39:15Z"}, "message": "In gcc/objc/: 2010-11-03 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/objc/:\n2010-11-03  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc-act.c (maybe_make_artificial_property_decl): New.\n        (objc_maybe_build_component_ref): Call\n        maybe_make_artificial_property_decl if a property can not be\n        found.  Do not call objc_finish_message_expr if\n        PROPERTY_HAS_NO_GETTER.\n        * objc-act.h Updated comments.\n        (PROPERTY_HAS_NO_GETTER): New.\n        (PROPERTY_HAS_NO_SETTER): New.\n        * objc-tree.def: Updated comment.\n\nIn gcc/testsuite/:\n2010-11-03  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc.dg/property/dotsyntax-1.m: New.\n        * objc.dg/property/dotsyntax-2.m: New.\n        * obj-c++.dg/property/dotsyntax-1.mm: New.\n        * obj-c++.dg/property/dotsyntax-2.mm: New.\n\nFrom-SVN: r166237", "tree": {"sha": "343b86bc8aefd1ff013b186a12e04ffedd18269c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/343b86bc8aefd1ff013b186a12e04ffedd18269c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43236c265b65d3e9447f84272300db648416d37e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43236c265b65d3e9447f84272300db648416d37e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43236c265b65d3e9447f84272300db648416d37e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43236c265b65d3e9447f84272300db648416d37e/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "87c20fe7623b31c72d31b015254fd7f7964f2ead", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87c20fe7623b31c72d31b015254fd7f7964f2ead", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87c20fe7623b31c72d31b015254fd7f7964f2ead"}], "stats": {"total": 448, "additions": 435, "deletions": 13}, "files": [{"sha": "1d78c0c8c2fc51df735b0e0fa481cb5b2087cdee", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43236c265b65d3e9447f84272300db648416d37e/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43236c265b65d3e9447f84272300db648416d37e/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=43236c265b65d3e9447f84272300db648416d37e", "patch": "@@ -1,3 +1,15 @@\n+2010-11-03  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc-act.c (maybe_make_artificial_property_decl): New.\n+\t(objc_maybe_build_component_ref): Call\n+\tmaybe_make_artificial_property_decl if a property can not be\n+\tfound.  Do not call objc_finish_message_expr if\n+\tPROPERTY_HAS_NO_GETTER.\n+\t* objc-act.h Updated comments.\n+\t(PROPERTY_HAS_NO_GETTER): New.\n+\t(PROPERTY_HAS_NO_SETTER): New.\n+\t* objc-tree.def: Updated comment.\n+\t\n 2010-11-01  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tImplemented format and noreturn attributes for Objective-C methods."}, {"sha": "cfbcb3c6826c155f6518a8b26d1e4102aac3c15b", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 124, "deletions": 10, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43236c265b65d3e9447f84272300db648416d37e/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43236c265b65d3e9447f84272300db648416d37e/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=43236c265b65d3e9447f84272300db648416d37e", "patch": "@@ -1053,16 +1053,102 @@ lookup_property (tree interface_type, tree property)\n   return inter;\n }\n \n+/* This is a subroutine of objc_maybe_build_component_ref.  Search the\n+   list of methods in the interface (and, failing that, protocol list)\n+   provided for a 'setter' or 'getter' for 'component' with default\n+   names (ie, if 'component' is \"name\", then search for \"name\" and\n+   \"setName:\").  If any is found, then create an artificial property\n+   that uses them.  Return NULL_TREE if 'getter' or 'setter' could not\n+   be found.  */\n+static tree\n+maybe_make_artificial_property_decl (tree interface, tree protocol_list, tree component, bool is_class)\n+{\n+  tree getter_name = component;\n+  tree setter_name = get_identifier (objc_build_property_setter_name (component));\n+  tree getter = NULL_TREE;\n+  tree setter = NULL_TREE;\n+\n+  if (interface)\n+    {\n+      int flags = 0;\n+\n+      if (is_class)\n+\tflags = OBJC_LOOKUP_CLASS;\n+      \n+      getter = lookup_method_static (interface, getter_name, flags);\n+      setter = lookup_method_static (interface, setter_name, flags);\n+    }\n+\n+  /* Try the protocol_list if we didn't find anything in the interface.  */\n+  if (!getter && !setter)\n+    {\n+      getter = lookup_method_in_protocol_list (protocol_list, getter_name, is_class);\n+      setter = lookup_method_in_protocol_list (protocol_list, setter_name, is_class);\n+    }\n+\n+  /* There needs to be at least a getter or setter for this to be a\n+     valid 'object.component' syntax.  */\n+  if (getter || setter)\n+    {\n+      /* Yes ... determine the type of the expression.  */\n+      tree property_decl;\n+      tree type;\n+      \n+      if (getter)\n+\ttype = TREE_VALUE (TREE_TYPE (getter));\n+      else\n+\ttype = TREE_VALUE (TREE_TYPE (METHOD_SEL_ARGS (setter)));\n+      \n+      /* Create an artificial property declaration with the\n+\t information we collected on the type and getter/setter\n+\t names.  */\n+      property_decl = make_node (PROPERTY_DECL);\n+      \n+      TREE_TYPE (property_decl) = type;\n+      DECL_SOURCE_LOCATION (property_decl) = input_location;\n+      TREE_DEPRECATED (property_decl) = 0;\n+      DECL_ARTIFICIAL (property_decl) = 1;\n+\t      \n+      /* Add property-specific information.  Note that one of\n+\t PROPERTY_GETTER_NAME or PROPERTY_SETTER_NAME may refer to a\n+\t non-existing method; this will generate an error when the\n+\t expression is later compiled.  At this stage we don't know if\n+\t the getter or setter will be used, so we can't generate an\n+\t error.  */\n+      PROPERTY_NAME (property_decl) = component;\n+      PROPERTY_GETTER_NAME (property_decl) = getter_name;\n+      PROPERTY_SETTER_NAME (property_decl) = setter_name;\n+      PROPERTY_READONLY (property_decl) = 0;\n+      PROPERTY_NONATOMIC (property_decl) = 0;\n+      PROPERTY_ASSIGN_SEMANTICS (property_decl) = 0;\n+      PROPERTY_IVAR_NAME (property_decl) = NULL_TREE;\n+      PROPERTY_DYNAMIC (property_decl) = 0;\n+\n+      if (!getter)\n+\tPROPERTY_HAS_NO_GETTER (property_decl) = 1;\n+\n+      /* The following is currently unused, but it's nice to have\n+\t there.  We may use it if we need in the future.  */\n+      if (!setter)\n+\tPROPERTY_HAS_NO_SETTER (property_decl) = 1;\n+\n+      return property_decl;\n+    }\n+\n+  return NULL_TREE;\n+}\n \n /* This hook routine is invoked by the parser when an expression such\n    as 'xxx.yyy' is parsed.  We get a chance to process these\n    expressions in a way that is specified to Objective-C (to implement\n-   properties, or non-fragile ivars).  If the expression is not an\n-   Objective-C specified expression, we should return NULL_TREE; else\n-   we return the expression.\n-\n-   At the moment this only implements properties (not non-fragile\n-   ivars yet), ie 'object.property'.  */\n+   the Objective-C 2.0 dot-syntax, properties, or non-fragile ivars).\n+   If the expression is not an Objective-C specified expression, we\n+   should return NULL_TREE; else we return the expression.\n+\n+   At the moment this only implements dot-syntax and properties (not\n+   non-fragile ivars yet), ie 'object.property' or 'object.component'\n+   where 'component' is not a declared property, but a valid getter or\n+   setter for it could be found.  */\n tree\n objc_maybe_build_component_ref (tree object, tree property_ident)\n {\n@@ -1089,6 +1175,17 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t\t      : NULL_TREE);\n       if (rprotos)\n \tx = lookup_property_in_protocol_list (rprotos, property_ident);\n+\n+      if (x == NULL_TREE)\n+\t{\n+\t  /* Ok, no property.  Maybe it was an object.component\n+\t     dot-syntax without a declared property.  Look for\n+\t     getter/setter methods and internally declare an artifical\n+\t     property based on them if found.  */\n+\t  x = maybe_make_artificial_property_decl (NULL_TREE, rprotos, \n+\t\t\t\t\t\t   property_ident,\n+\t\t\t\t\t\t   false);\n+\t}\n     }\n   else\n     {\n@@ -1115,6 +1212,14 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \n \t  if (x == NULL_TREE)\n \t    x = lookup_property_in_protocol_list (protocol_list, property_ident);\n+\n+\t  if (x == NULL_TREE)\n+\t    {\n+\t      /* Ok, no property.  Try the dot-syntax without a\n+\t\t declared property.  */\n+\t      x = maybe_make_artificial_property_decl (interface_type, protocol_list, \n+\t\t\t\t\t\t       property_ident, false);\n+\t    }\n \t}\n     }\n \n@@ -1144,10 +1249,16 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \n \t TODO: This can be made more efficient; in particular we don't\n \t need to build the whole message call, we could just work on\n-\t the selector.  */\n-      objc_finish_message_expr (object,\n-\t\t\t\tPROPERTY_GETTER_NAME (x),\n-\t\t\t\tNULL_TREE);\n+\t the selector.\n+\n+\t If the PROPERTY_HAS_NO_GETTER() (ie, it is an artificial\n+\t property decl created to deal with a dotsyntax not really\n+\t referring to an existing property) then do not try to build a\n+\t call to the getter as there is no getter.  */\n+      if (!PROPERTY_HAS_NO_GETTER (x))\n+\tobjc_finish_message_expr (object,\n+\t\t\t\t  PROPERTY_GETTER_NAME (x),\n+\t\t\t\t  NULL_TREE);\n       \n       return expression;\n     }\n@@ -1197,6 +1308,9 @@ objc_maybe_build_modify_expr (tree lhs, tree rhs)\n \t{\n \t  tree setter_argument = build_tree_list (NULL_TREE, rhs);\n \t  tree setter;\n+\n+\t  /* TODO: Check that the setter return type is 'void'.  */\n+\n \t  /* TODO: Decay argument in C.  */\n \t  setter = objc_finish_message_expr (object_expr, \n \t\t\t\t\t     PROPERTY_SETTER_NAME (property_decl),"}, {"sha": "9478d72fbccf1a5f9603bf1dc7630ae25344ca4c", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43236c265b65d3e9447f84272300db648416d37e/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43236c265b65d3e9447f84272300db648416d37e/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=43236c265b65d3e9447f84272300db648416d37e", "patch": "@@ -62,6 +62,11 @@ tree objc_eh_personality (void);\n \n /* TREE_TYPE is the type (int, float, etc) of the property.  */\n \n+/* DECL_ARTIFICIAL is set to 1 if the PROPERTY_DECL is an artificial\n+   property declaration created when the dot-syntax object.component\n+   is used with no actual @property matching the component, but a\n+   valid getter/setter.  */\n+\n /* PROPERTY_NAME is the name of the property.  */\n #define PROPERTY_NAME(DECL) DECL_NAME(DECL)\n \n@@ -99,17 +104,31 @@ typedef enum objc_property_assign_semantics {\n    declaration has been parsed); otherwise, it is set to 0.  */\n #define PROPERTY_DYNAMIC(DECL) DECL_LANG_FLAG_2 (DECL)\n \n+/* PROPERTY_HAS_NO_GETTER can be 0 or 1.  Normally it is 0, but if\n+   this is an artificial PROPERTY_DECL that we generate even without a\n+   getter, it is set to 1.  */\n+#define PROPERTY_HAS_NO_GETTER(DECL) DECL_LANG_FLAG_3 (DECL)\n+\n+/* PROPERTY_HAS_NO_SETTER can be 0 or 1.  Normally it is 0, but if\n+   this is an artificial PROPERTY_DECL that we generate even without a\n+   setter, it is set to 1.  */\n+#define PROPERTY_HAS_NO_SETTER(DECL) DECL_LANG_FLAG_4 (DECL)\n \n /* PROPERTY_REF.  A PROPERTY_REF represents an 'object.property'\n-   expression.  */\n+   expression.  It is normally used for property access, but when\n+   the Objective-C 2.0 \"dot-syntax\" (object.component) is used\n+   with no matching property, a PROPERTY_REF is still created to\n+   represent it, with an artificial PROPERTY_DECL.  */\n \n /* PROPERTY_REF_OBJECT is the object whose property we are\n    accessing.  */\n #define PROPERTY_REF_OBJECT(NODE) TREE_OPERAND (PROPERTY_REF_CHECK (NODE), 0)\n \n /* PROPERTY_REF_PROPERTY_DECL is the PROPERTY_DECL for the property\n    used in the expression.  From it, you can get the property type,\n-   and the getter/setter names.  */\n+   and the getter/setter names.  This PROPERTY_DECL could be artificial\n+   if we are processing an 'object.component' syntax with no matching \n+   declared property.  */\n #define PROPERTY_REF_PROPERTY_DECL(NODE) TREE_OPERAND (PROPERTY_REF_CHECK (NODE), 1)\n \n "}, {"sha": "7316675c3bd1675802b60a0328d0fc2f88aa54d5", "filename": "gcc/objc/objc-tree.def", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43236c265b65d3e9447f84272300db648416d37e/gcc%2Fobjc%2Fobjc-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43236c265b65d3e9447f84272300db648416d37e/gcc%2Fobjc%2Fobjc-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-tree.def?ref=43236c265b65d3e9447f84272300db648416d37e", "patch": "@@ -55,7 +55,11 @@ DEFTREECODE (CLASS_REFERENCE_EXPR, \"class_reference_expr\", tcc_expression, 1)\n     * else, it will remain as a PROPERTY_REF until we get to\n       gimplification; at that point, we convert each PROPERTY_REF into\n       a 'getter' call during ObjC/ObjC++ gimplify.\n-*/\n+\n+  Please note that when the Objective-C 2.0 \"dot-syntax\" 'object.component' \n+  is encountered, where 'component' is not a property but there are valid\n+  setter/getter methods for it, an artificial PROPERTY_DECL is generated\n+  and used in the PROPERTY_REF.  */\n DEFTREECODE (PROPERTY_REF, \"property_ref\", tcc_expression, 2)\n \n /*"}, {"sha": "a8851e499a0dcf5b6681be5582d3cdae3693a38c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43236c265b65d3e9447f84272300db648416d37e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43236c265b65d3e9447f84272300db648416d37e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=43236c265b65d3e9447f84272300db648416d37e", "patch": "@@ -1,3 +1,10 @@\n+2010-11-03  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc.dg/property/dotsyntax-1.m: New.\n+\t* objc.dg/property/dotsyntax-2.m: New.\t\n+\t* obj-c++.dg/property/dotsyntax-1.mm: New.\n+\t* obj-c++.dg/property/dotsyntax-2.mm: New.\t\n+\n 2010-11-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/46165"}, {"sha": "8bc3b3a595750d64c9187a74a2e18acbf2a9d952", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-1.mm", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43236c265b65d3e9447f84272300db648416d37e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43236c265b65d3e9447f84272300db648416d37e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-1.mm?ref=43236c265b65d3e9447f84272300db648416d37e", "patch": "@@ -0,0 +1,62 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+\n+/* Test the 'dot syntax' without a declarated property.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+  id b;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (int) count;\n+- (void) setCount: (int)value;\n+- (id) next;\n+- (void) setNext: (id)value;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)value\n+{\n+  a = value;\n+}\n+- (id) next\n+{\n+  return b;\n+}\n+- (void) setNext: (id)value\n+{\n+  b = value;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  object.count = 40;\n+  if (object.count != 40)\n+    abort ();\n+\n+  object.next = object;\n+  if (object.next != object)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "ba615a318257274e9826ede1d77b65fb3b91167d", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-2.mm", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43236c265b65d3e9447f84272300db648416d37e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-2.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43236c265b65d3e9447f84272300db648416d37e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-2.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-2.mm?ref=43236c265b65d3e9447f84272300db648416d37e", "patch": "@@ -0,0 +1,71 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+\n+/* Test the 'dot syntax' without a declarated property.  This tests the case where\n+   only the setter (or only the getter) exists.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+  id b;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (int) a;\n+- (void) setCount: (int)value;\n+- (id) b;\n+- (void) setNext: (id)value;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (int) a\n+{\n+  return a;\n+}\n+- (void) setCount: (int)value\n+{\n+  a = value;\n+}\n+- (id) b\n+{\n+  return b;\n+}\n+- (void) setNext: (id)value\n+{\n+  b = value;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  /* This should work because -setCount: exists (even if -count does\n+     not).  */\n+  object.count = 40;\n+\n+  /* This should work because -a exists (even if -setA: does not).  */\n+  if (object.a != 40)\n+    abort ();\n+\n+  /* This should work because -setNext: exists (even if -next does\n+     not).  */\n+  object.next = object;\n+\n+  /* This should work because -b exists (even if -setB: does not).  */\n+  if (object.b != object)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "8bc3b3a595750d64c9187a74a2e18acbf2a9d952", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-1.m", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43236c265b65d3e9447f84272300db648416d37e/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43236c265b65d3e9447f84272300db648416d37e/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-1.m?ref=43236c265b65d3e9447f84272300db648416d37e", "patch": "@@ -0,0 +1,62 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+\n+/* Test the 'dot syntax' without a declarated property.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+  id b;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (int) count;\n+- (void) setCount: (int)value;\n+- (id) next;\n+- (void) setNext: (id)value;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)value\n+{\n+  a = value;\n+}\n+- (id) next\n+{\n+  return b;\n+}\n+- (void) setNext: (id)value\n+{\n+  b = value;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  object.count = 40;\n+  if (object.count != 40)\n+    abort ();\n+\n+  object.next = object;\n+  if (object.next != object)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "ba615a318257274e9826ede1d77b65fb3b91167d", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-2.m", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43236c265b65d3e9447f84272300db648416d37e/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43236c265b65d3e9447f84272300db648416d37e/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-2.m?ref=43236c265b65d3e9447f84272300db648416d37e", "patch": "@@ -0,0 +1,71 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+\n+/* Test the 'dot syntax' without a declarated property.  This tests the case where\n+   only the setter (or only the getter) exists.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+  id b;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (int) a;\n+- (void) setCount: (int)value;\n+- (id) b;\n+- (void) setNext: (id)value;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (int) a\n+{\n+  return a;\n+}\n+- (void) setCount: (int)value\n+{\n+  a = value;\n+}\n+- (id) b\n+{\n+  return b;\n+}\n+- (void) setNext: (id)value\n+{\n+  b = value;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  /* This should work because -setCount: exists (even if -count does\n+     not).  */\n+  object.count = 40;\n+\n+  /* This should work because -a exists (even if -setA: does not).  */\n+  if (object.a != 40)\n+    abort ();\n+\n+  /* This should work because -setNext: exists (even if -next does\n+     not).  */\n+  object.next = object;\n+\n+  /* This should work because -b exists (even if -setB: does not).  */\n+  if (object.b != object)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}]}