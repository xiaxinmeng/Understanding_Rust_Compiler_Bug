{"sha": "916ce577ad109be69a3100fc79b3933d741eb990", "node_id": "C_kwDOANBUbNoAKDkxNmNlNTc3YWQxMDliZTY5YTMxMDBmYzc5YjM5MzNkNzQxZWI5OTA", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2023-02-08T12:58:45Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2023-02-16T14:38:38Z"}, "message": "libstdc++: Implement P2255R2 dangling checks for std::pair\n\nThis uses the new __reference_constructs_from_temporary built-in to\nidentify when a std::pair constructor will bind a reference to a\ntemporary that goes out of scope at the end of the constructor.  For\nexample, std::pair<const long&, int> p(1, 2); will call the pair<const\nlong&, int>::pair(U1&&, U2&&) constructor with U1=int and U2=int. In the\nconstructor body a temporary long will be created and the p.first member\nwill bind to that temporary. When the constructor returns, the reference\nis immediately dangling. P2255 requires the constructor to be deleted to\nprevent this bug.\n\nAlthough P2255 was approved for C++23, it fixes a longstanding LWG issue\nin older standards, and it turns silent runtime undefined behaviour into\na compilation error. Because of that, the dangling checks are applied\nall the way back to C++98.  However, if these changes cause too much\ncode to be rejected (e.g. in cases where the dangling reference is never\nused after the constructor returns) then we can consider removing them\nfor C++20 and older standards.\n\nThe affected constructors are deleted for C++20 and later, when concepts\nare available to simplify the constructor constraints. For C++17 and\nearlier the overload sets are complicated and awkward to maintain, so\nthe dangling checks are done in static assertions in the constructor\nbodies, instead of being SFINAE-friendly constraints. The pre-C++17\nassertions are only enabled for Debug Mode, to avoid introducing a\nbreaking change in Stage 4. We should consider enabling them by default\nin Stage 1 for GCC 14.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/stl_pair.h (pair) [C++20]: Add non-dangling\n\tconstraints to constructors and add deleted overloads for the\n\tdangling cases, as per P2255R2.\n\t(pair) [!C++20 && _GLIBCXX_DEBUG]: Add static assertions to\n\tmake dangling cases ill-formed.\n\t* testsuite/20_util/pair/dangling_ref.cc: New test.", "tree": {"sha": "76e1fc2fd9e4f6372c08cc4f34a020ae20253e09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76e1fc2fd9e4f6372c08cc4f34a020ae20253e09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/916ce577ad109be69a3100fc79b3933d741eb990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916ce577ad109be69a3100fc79b3933d741eb990", "html_url": "https://github.com/Rust-GCC/gccrs/commit/916ce577ad109be69a3100fc79b3933d741eb990", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916ce577ad109be69a3100fc79b3933d741eb990/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "866555b170016c49beb869a78cbecdeb07c63135", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/866555b170016c49beb869a78cbecdeb07c63135", "html_url": "https://github.com/Rust-GCC/gccrs/commit/866555b170016c49beb869a78cbecdeb07c63135"}], "stats": {"total": 179, "additions": 164, "deletions": 15}, "files": [{"sha": "3f1624f40b4e410ed134d6ad093394a63bbc4bbf", "filename": "libstdc++-v3/include/bits/stl_pair.h", "status": "modified", "additions": 97, "deletions": 15, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916ce577ad109be69a3100fc79b3933d741eb990/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916ce577ad109be69a3100fc79b3933d741eb990/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h?ref=916ce577ad109be69a3100fc79b3933d741eb990", "patch": "@@ -281,6 +281,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    return is_convertible_v<_U2, _T2>;\n \t  return false;\n \t}\n+\n+      // True if construction from _U1 and _U2 would create a dangling ref.\n+      template<typename _U1, typename _U2>\n+\tstatic constexpr bool\n+\t_S_dangles()\n+\t{\n+#if __has_builtin(__reference_constructs_from_temporary)\n+\t  if constexpr (__reference_constructs_from_temporary(_T1, _U1&&))\n+\t    return true;\n+\t  else\n+\t    return __reference_constructs_from_temporary(_T2, _U2&&);\n+#else\n+\t  return false;\n+#endif\n+\t}\n       /// @endcond\n \n     public:\n@@ -295,51 +310,80 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       /// Constructor accepting two values of arbitrary types\n       template<typename _U1, typename _U2>\n-\trequires (_S_constructible<_U1, _U2>())\n+\trequires (_S_constructible<_U1, _U2>()) && (!_S_dangles<_U1, _U2>())\n \tconstexpr explicit(!_S_convertible<_U1, _U2>())\n \tpair(_U1&& __x, _U2&& __y)\n \tnoexcept(_S_nothrow_constructible<_U1, _U2>())\n \t: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))\n \t{ }\n \n+      template<typename _U1, typename _U2>\n+\trequires (_S_constructible<_U1, _U2>()) && (_S_dangles<_U1, _U2>())\n+\tconstexpr explicit(!_S_convertible<_U1, _U2>())\n+\tpair(_U1&&, _U2&&) = delete;\n+\n       /// Converting constructor from a const `pair<U1, U2>` lvalue\n       template<typename _U1, typename _U2>\n \trequires (_S_constructible<const _U1&, const _U2&>())\n+\t  && (!_S_dangles<_U1, _U2>())\n \tconstexpr explicit(!_S_convertible<const _U1&, const _U2&>())\n \tpair(const pair<_U1, _U2>& __p)\n \tnoexcept(_S_nothrow_constructible<const _U1&, const _U2&>())\n \t: first(__p.first), second(__p.second)\n \t{ }\n \n+      template<typename _U1, typename _U2>\n+\trequires (_S_constructible<const _U1&, const _U2&>())\n+\t      && (_S_dangles<const _U1&, const _U2&>())\n+\tconstexpr explicit(!_S_convertible<const _U1&, const _U2&>())\n+\tpair(const pair<_U1, _U2>&) = delete;\n+\n       /// Converting constructor from a non-const `pair<U1, U2>` rvalue\n       template<typename _U1, typename _U2>\n-\trequires (_S_constructible<_U1, _U2>())\n+\trequires (_S_constructible<_U1, _U2>()) && (!_S_dangles<_U1, _U2>())\n \tconstexpr explicit(!_S_convertible<_U1, _U2>())\n \tpair(pair<_U1, _U2>&& __p)\n \tnoexcept(_S_nothrow_constructible<_U1, _U2>())\n \t: first(std::forward<_U1>(__p.first)),\n \t  second(std::forward<_U2>(__p.second))\n \t{ }\n \n+      template<typename _U1, typename _U2>\n+\trequires (_S_constructible<_U1, _U2>()) && (_S_dangles<_U1, _U2>())\n+\tconstexpr explicit(!_S_convertible<_U1, _U2>())\n+\tpair(pair<_U1, _U2>&&) = delete;\n+\n #if __cplusplus > 202002L\n       /// Converting constructor from a non-const `pair<U1, U2>` lvalue\n       template<typename _U1, typename _U2>\n-\trequires (_S_constructible<_U1&, _U2&>())\n+\trequires (_S_constructible<_U1&, _U2&>()) && (!_S_dangles<_U1&, _U2&>())\n \tconstexpr explicit(!_S_convertible<_U1&, _U2&>())\n \tpair(pair<_U1, _U2>& __p)\n \tnoexcept(_S_nothrow_constructible<_U1&, _U2&>())\n \t: first(__p.first), second(__p.second)\n \t{ }\n \n+      template<typename _U1, typename _U2>\n+\trequires (_S_constructible<_U1&, _U2&>()) && (_S_dangles<_U1&, _U2&>())\n+\tconstexpr explicit(!_S_convertible<_U1&, _U2&>())\n+\tpair(pair<_U1, _U2>&) = delete;\n+\n       /// Converting constructor from a const `pair<U1, U2>` rvalue\n       template<typename _U1, typename _U2>\n \trequires (_S_constructible<const _U1, const _U2>())\n+\t  && (!_S_dangles<const _U1, const _U2>())\n \tconstexpr explicit(!_S_convertible<const _U1, const _U2>())\n \tpair(const pair<_U1, _U2>&& __p)\n \tnoexcept(_S_nothrow_constructible<const _U1, const _U2>())\n \t: first(std::forward<const _U1>(__p.first)),\n \t  second(std::forward<const _U2>(__p.second))\n \t{ }\n+\n+      template<typename _U1, typename _U2>\n+\trequires (_S_constructible<const _U1, const _U2>())\n+\t  && (_S_dangles<const _U1, const _U2>())\n+\tconstexpr explicit(!_S_convertible<const _U1, const _U2>())\n+\tpair(const pair<_U1, _U2>&&) = delete;\n #endif // C++23\n \n   private:\n@@ -463,6 +507,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #else // !__cpp_lib_concepts\n       // C++11/14/17 implementation using enable_if, partially constexpr.\n \n+      /// @cond undocumented\n+      // Error if construction from _U1 and _U2 would create a dangling ref.\n+#if __has_builtin(__reference_constructs_from_temporary) \\\n+      && defined _GLIBCXX_DEBUG\n+# define __glibcxx_no_dangling_refs(_U1, _U2) \\\n+  static_assert(!__reference_constructs_from_temporary(_T1, _U1) \\\n+\t       && !__reference_constructs_from_temporary(_T2, _U2), \\\n+\t\t\"std::pair constructor creates a dangling reference\")\n+#else\n+# define __glibcxx_no_dangling_refs(_U1, _U2)\n+#endif\n+      /// @endcond\n+\n       /** The default constructor creates @c first and @c second using their\n        *  respective default constructors.  */\n       template <typename _U1 = _T1,\n@@ -525,8 +582,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t                 && _PCCFP<_U1, _U2>::template\n \t\t\t   _ImplicitlyConvertiblePair<_U1, _U2>(),\n \t\t\t  bool>::type=true>\n-        constexpr pair(const pair<_U1, _U2>& __p)\n-        : first(__p.first), second(__p.second) { }\n+\tconstexpr pair(const pair<_U1, _U2>& __p)\n+\t: first(__p.first), second(__p.second)\n+\t{ __glibcxx_no_dangling_refs(const _U1&, const _U2&); }\n \n       template<typename _U1, typename _U2, typename\n \t       enable_if<_PCCFP<_U1, _U2>::template\n@@ -535,7 +593,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t   _ImplicitlyConvertiblePair<_U1, _U2>(),\n                          bool>::type=false>\n \texplicit constexpr pair(const pair<_U1, _U2>& __p)\n-\t: first(__p.first), second(__p.second) { }\n+\t: first(__p.first), second(__p.second)\n+\t{ __glibcxx_no_dangling_refs(const _U1&, const _U2&); }\n \n #if _GLIBCXX_USE_DEPRECATED\n #if defined(__DEPRECATED)\n@@ -575,7 +634,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_GLIBCXX_DEPRECATED_PAIR_CTOR\n \tconstexpr\n \tpair(_U1&& __x, __zero_as_null_pointer_constant, ...)\n-\t: first(std::forward<_U1>(__x)), second(nullptr) { }\n+\t: first(std::forward<_U1>(__x)), second(nullptr)\n+\t{ __glibcxx_no_dangling_refs(_U1&&, std::nullptr_t); }\n \n       template<typename _U1,\n \t       __enable_if_t<__and_<__not_<is_reference<_U1>>,\n@@ -587,7 +647,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_GLIBCXX_DEPRECATED_PAIR_CTOR\n \texplicit constexpr\n \tpair(_U1&& __x, __zero_as_null_pointer_constant, ...)\n-\t: first(std::forward<_U1>(__x)), second(nullptr) { }\n+\t: first(std::forward<_U1>(__x)), second(nullptr)\n+\t{ __glibcxx_no_dangling_refs(_U1&&, std::nullptr_t); }\n \n       template<typename _U2,\n \t       __enable_if_t<__and_<is_pointer<_T1>,\n@@ -599,7 +660,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_GLIBCXX_DEPRECATED_PAIR_CTOR\n \tconstexpr\n \tpair(__zero_as_null_pointer_constant, _U2&& __y, ...)\n-\t: first(nullptr), second(std::forward<_U2>(__y)) { }\n+\t: first(nullptr), second(std::forward<_U2>(__y))\n+\t{ __glibcxx_no_dangling_refs(std::nullptr_t, _U2&&); }\n \n       template<typename _U2,\n \t       __enable_if_t<__and_<is_pointer<_T1>,\n@@ -611,7 +673,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_GLIBCXX_DEPRECATED_PAIR_CTOR\n \texplicit constexpr\n \tpair(__zero_as_null_pointer_constant, _U2&& __y, ...)\n-\t: first(nullptr), second(std::forward<_U2>(__y)) { }\n+\t: first(nullptr), second(std::forward<_U2>(__y))\n+\t{ __glibcxx_no_dangling_refs(std::nullptr_t, _U2&&); }\n #undef _GLIBCXX_DEPRECATED_PAIR_CTOR\n #endif\n \n@@ -622,7 +685,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),\n                          bool>::type=true>\n \tconstexpr pair(_U1&& __x, _U2&& __y)\n-\t: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }\n+\t: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))\n+\t{ __glibcxx_no_dangling_refs(_U1&&, _U2&&); }\n \n       template<typename _U1, typename _U2, typename\n \t       enable_if<_PCCP::template\n@@ -631,7 +695,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),\n                          bool>::type=false>\n \texplicit constexpr pair(_U1&& __x, _U2&& __y)\n-\t: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }\n+\t: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))\n+\t{ __glibcxx_no_dangling_refs(_U1&&, _U2&&); }\n \n \n       template<typename _U1, typename _U2, typename\n@@ -642,7 +707,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                          bool>::type=true>\n \tconstexpr pair(pair<_U1, _U2>&& __p)\n \t: first(std::forward<_U1>(__p.first)),\n-\t  second(std::forward<_U2>(__p.second)) { }\n+\t  second(std::forward<_U2>(__p.second))\n+\t{ __glibcxx_no_dangling_refs(_U1&&, _U2&&); }\n \n       template<typename _U1, typename _U2, typename\n \t       enable_if<_PCCFP<_U1, _U2>::template\n@@ -652,7 +718,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                          bool>::type=false>\n \texplicit constexpr pair(pair<_U1, _U2>&& __p)\n \t: first(std::forward<_U1>(__p.first)),\n-\t  second(std::forward<_U2>(__p.second)) { }\n+\t  second(std::forward<_U2>(__p.second))\n+\t{ __glibcxx_no_dangling_refs(_U1&&, _U2&&); }\n+\n+#undef __glibcxx_no_dangling_refs\n \n       pair&\n       operator=(__conditional_t<__and_<is_copy_assignable<_T1>,\n@@ -714,7 +783,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       /// Templated constructor to convert from other pairs.\n       template<typename _U1, typename _U2>\n \tpair(const pair<_U1, _U2>& __p)\n-\t: first(__p.first), second(__p.second) { }\n+\t: first(__p.first), second(__p.second)\n+\t{\n+#if __has_builtin(__reference_constructs_from_temporary)\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wunused-local-typedefs\"\n+\t  typedef int _DanglingCheck1[\n+\t    __reference_constructs_from_temporary(_T1, const _U1&) ? -1 : 1\n+\t\t      ];\n+\t  typedef int _DanglingCheck2[\n+\t    __reference_constructs_from_temporary(_T2, const _U2&) ? -1 : 1\n+\t\t      ];\n+#pragma GCC diagnostic pop\n+#endif\n+\t}\n #endif // C++11\n     };\n "}, {"sha": "8e0c34816ddc52f5e550da601510b4df9dbf82fb", "filename": "libstdc++-v3/testsuite/20_util/pair/dangling_ref.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916ce577ad109be69a3100fc79b3933d741eb990/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fdangling_ref.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916ce577ad109be69a3100fc79b3933d741eb990/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fdangling_ref.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fdangling_ref.cc?ref=916ce577ad109be69a3100fc79b3933d741eb990", "patch": "@@ -0,0 +1,67 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-Wno-unused-variable\" }\n+// { dg-additional-options \"-D_GLIBCXX_DEBUG\" { target c++17_down } }\n+\n+#include <utility>\n+\n+#if __cplusplus >= 202002L\n+// For C++20 and later, constructors are constrained to disallow dangling.\n+static_assert(!std::is_constructible_v<std::pair<const int&, int>, long, int>);\n+static_assert(!std::is_constructible_v<std::pair<int, const int&>, int, long>);\n+static_assert(!std::is_constructible_v<std::pair<const int&, int>,\n+\t\t\t\t       std::pair<long, long>>);\n+static_assert(!std::is_constructible_v<std::pair<int, const int&>,\n+\t\t\t\t       std::pair<long, long>>);\n+static_assert(!std::is_constructible_v<std::pair<const int&, int>,\n+\t\t\t\t       const std::pair<long, long>&>);\n+static_assert(!std::is_constructible_v<std::pair<int, const int&>,\n+\t\t\t\t       const std::pair<long, long>&>);\n+#endif\n+\n+void\n+test_binary_ctors()\n+{\n+  std::pair<const int&, int> p1(1L, 2);\n+  // { dg-error \"here\" \"\" { target c++17_down } 24 }\n+  // { dg-error \"use of deleted function\" \"\" { target c++20 } 24 }\n+\n+  std::pair<int, const int&> p2(1, 2L);\n+  // { dg-error \"here\" \"\" { target c++17_down } 28 }\n+  // { dg-error \"use of deleted function\" \"\" { target c++20 } 28 }\n+\n+  std::pair<const int&, const int&> p3(1L, 2L);\n+  // { dg-error \"here\" \"\" { target c++17_down } 32 }\n+  // { dg-error \"use of deleted function\" \"\" { target c++20 } 32 }\n+}\n+\n+void\n+test_converting_ctors()\n+{\n+  std::pair<long, long> p0;\n+\n+  std::pair<const int&, int> p1(p0);\n+  // { dg-error \"here\" \"\" { target c++17_down } 42 }\n+  // { dg-error \"use of deleted function\" \"\" { target c++20 } 42 }\n+\n+  std::pair<int, const int&> p2(p0);\n+  // { dg-error \"here\" \"\" { target c++17_down } 46 }\n+  // { dg-error \"use of deleted function\" \"\" { target c++20 } 46 }\n+\n+  std::pair<const int&, const int&> p3(p0);\n+  // { dg-error \"here\" \"\" { target c++17_down } 50 }\n+  // { dg-error \"use of deleted function\" \"\" { target c++20 } 50 }\n+\n+  std::pair<const int&, int> p4(std::move(p0));\n+  // { dg-error \"here\" \"\" { target c++17_down } 54 }\n+  // { dg-error \"use of deleted function\" \"\" { target c++20 } 54 }\n+\n+  std::pair<int, const int&> p5(std::move(p0));\n+  // { dg-error \"here\" \"\" { target c++17_down } 58 }\n+  // { dg-error \"use of deleted function\" \"\" { target c++20 } 58 }\n+\n+  std::pair<const int&, const int&> p6(std::move(p0));\n+  // { dg-error \"here\" \"\" { target c++17_down } 62 }\n+  // { dg-error \"use of deleted function\" \"\" { target c++20 } 62 }\n+}\n+\n+// { dg-error \"static assert.* dangling reference\" \"\" { target { c++17_down } } 0 }"}]}