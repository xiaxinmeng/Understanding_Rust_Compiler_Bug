{"sha": "af1682fc3aaff288f7ac95cf5585971cef15f0ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYxNjgyZmMzYWFmZjI4OGY3YWM5NWNmNTU4NTk3MWNlZjE1ZjBhYg==", "commit": {"author": {"name": "Andrew Sadek", "email": "andrew.sadek.se@gmail.com", "date": "2018-04-30T11:16:55Z"}, "committer": {"name": "Michael Eager", "email": "eager@gcc.gnu.org", "date": "2018-04-30T11:16:55Z"}, "message": "Microblaze Target: PIC data text relative \n2018-04-30 Andrew Sadek  <andrew.sadek.se@gmail.com>\n\ngcc/ChangeLog:\n\t* config/microblaze/microblaze.opt: add new option -mpic-data-text-rel.\n\t* config/microblaze/microblaze-protos.h (microblaze_constant_address_p):\n\tAdd declaration.\n\t* gcc/config/microblaze/microblaze.h (microblaze_constant_address_p):\n\tCONSTANT_ADDRESS_P definition to microblaze_constant_address_p.\n\t* config/microblaze/microblaze.c (TARGET_PIC_DATA_TEXT_REL):\n\tNew addressing mode for data-text relative position indepenedent code.\n\t(microblaze_classify_unspec): add 'UNSPEC_TEXT' case ->\n\t'ADDRESS_SYMBOLIC_TXT_REL'.\n\t(microblaze_classify_address): Add handling for UNSPEC + CONST_INT.\n\t(microblaze_legitimate_pic_operand): Exclude function calls from\n\tpic operands in case of TARGET_PIC_DATA_TEXT_REL option.\n\t(microblaze_legitimize_address): Generate 'UNSPEC_TEXT' for all possible\n\taddresses cases.\n\t(microblaze_address_insns): Add 'ADDRESS_SYMBOLIC_TXT_REL' case.\n\t(print_operand): Add 'ADDRESS_SYMBOLIC_TXT_REL' case.\n\t(print_operand_address): Add 'ADDRESS_SYMBOLIC_TXT_REL' case + handling\n\tfor 'address + offset'.\n\t(microblaze_expand_prologue): Add new function prologue call for\n\t'r20' assignation.\n\t(microblaze_asm_generate_pic_addr_dif_vec): Override new target hook\n\t'TARGET_ASM_GENERATE_PIC_ADDR_DIFF_VEC' to disable address diff vector\n\ttable in case of TARGET_PIC_DATA_TEXT_REL.\n\t(expand_pic_symbol_ref): Add handling for 'UNSPEC_TEXT'.\n\t* gcc/config/microblaze/microblaze.md (TARGET_PIC_DATA_TEXT_REL):\n\tAdd new macros 'UNSPEC_TEXT',\n\t'UNSPEC_SET_TEXT' + add rule for setting r20 in function prologue\n\t+ exclude function calls from 'UNSPEC_PLT' in case of data text\n\trelative mode.\n\t* doc/tm.texi.in (TARGET_ASM_GENERATE_PIC_ADDR_DIFF_VEC): Add\n\tnew target hook for generating address diff vector tables in case of\n\tflag_pic.\n\t* doc/tm.texi : Regenerate.\n\t* stmt.c (TARGET_ASM_GENERATE_PIC_ADDR_DIFF_VEC): Append new condition\n\t'targetm.asm_out.generate_pic_addr_diff_vec' to flag_pic in case\n\tof addr diff vector generation.\n\t* target.def (TARGET_ASM_GENERATE_PIC_ADDR_DIFF_VEC): Add\n\ttarget hook definition.\n\t* targhooks.h, gcc/targhooks.c (TARGET_ASM_GENERATE_PIC_ADDR_DIFF_VEC):\n\tAdd default function for generate_pic_addr_diff_vec -> flag_pic.\n\t* doc/invoke.texi (Add new pic option): Add new microblaze pic\n\toption for data text relative.\n\ntestsuite/ChangeLog:\n\t* gcc.target/microblaze/others/data_var1.c: Include\n\tPIC case of r20 base register.\n\t* gcc.target/microblaze/others/data_var2.c: Ditto.\n\t* gcc.target/microblaze/others/picdtr.c: Add new\n\ttest case for -mpic-is-data-text-relative.\n\t* gcc.target/microblaze/others/sdata_var1.c: Add\n\t* gcc.target/microblaze/others/sdata_var2.c: Ditto.\n\t* gcc.target/microblaze/others/sdata_var3.c: Ditto.\n\t* gcc.target/microblaze/others/sdata_var4.c: Ditto.\n\t* gcc.target/microblaze/others/sdata_var5.c: Ditto.\n\t* gcc.target/microblaze/others/sdata_var6.c: Ditto.\n\t* gcc.target/microblaze/others/string_cst1_gpopt.c:\tDitto.\n\t* gcc.target/microblaze/others/string_cst2_gpopt.c: Ditto.\n\nFrom-SVN: r259758", "tree": {"sha": "a18a830cd4148874dcac4c70eb18dd4b43f54a1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a18a830cd4148874dcac4c70eb18dd4b43f54a1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af1682fc3aaff288f7ac95cf5585971cef15f0ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af1682fc3aaff288f7ac95cf5585971cef15f0ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af1682fc3aaff288f7ac95cf5585971cef15f0ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af1682fc3aaff288f7ac95cf5585971cef15f0ab/comments", "author": {"login": "andrewsadek", "id": 35325900, "node_id": "MDQ6VXNlcjM1MzI1OTAw", "avatar_url": "https://avatars.githubusercontent.com/u/35325900?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andrewsadek", "html_url": "https://github.com/andrewsadek", "followers_url": "https://api.github.com/users/andrewsadek/followers", "following_url": "https://api.github.com/users/andrewsadek/following{/other_user}", "gists_url": "https://api.github.com/users/andrewsadek/gists{/gist_id}", "starred_url": "https://api.github.com/users/andrewsadek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andrewsadek/subscriptions", "organizations_url": "https://api.github.com/users/andrewsadek/orgs", "repos_url": "https://api.github.com/users/andrewsadek/repos", "events_url": "https://api.github.com/users/andrewsadek/events{/privacy}", "received_events_url": "https://api.github.com/users/andrewsadek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5885f02733f9bab7e9508bfebbeed5b3c9254aaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5885f02733f9bab7e9508bfebbeed5b3c9254aaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5885f02733f9bab7e9508bfebbeed5b3c9254aaa"}], "stats": {"total": 375, "additions": 319, "deletions": 56}, "files": [{"sha": "0949337a68428cbe5688a935ab1b8001d0559acf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -1,3 +1,50 @@\n+2018-04-30 Andrew Sadek  <andrew.sadek.se@gmail.com>\n+\n+\tMicroblaze Target: PIC data text relative\n+\n+\t* config/microblaze/microblaze.opt: add new option -mpic-data-text-rel.\n+\t* config/microblaze/microblaze-protos.h (microblaze_constant_address_p):\n+\tAdd declaration.\n+\t* gcc/config/microblaze/microblaze.h (microblaze_constant_address_p):\n+\tCONSTANT_ADDRESS_P definition to microblaze_constant_address_p.\n+\t* config/microblaze/microblaze.c (TARGET_PIC_DATA_TEXT_REL):\n+\tNew addressing mode for data-text relative position indepenedent code.\n+\t(microblaze_classify_unspec): add 'UNSPEC_TEXT' case ->\n+\t'ADDRESS_SYMBOLIC_TXT_REL'.\n+\t(microblaze_classify_address): Add handling for UNSPEC + CONST_INT.\n+\t(microblaze_legitimate_pic_operand): Exclude function calls from\n+\tpic operands in case of TARGET_PIC_DATA_TEXT_REL option.\n+\t(microblaze_legitimize_address): Generate 'UNSPEC_TEXT' for all possible\n+\taddresses cases.\n+\t(microblaze_address_insns): Add 'ADDRESS_SYMBOLIC_TXT_REL' case.\n+\t(print_operand): Add 'ADDRESS_SYMBOLIC_TXT_REL' case.\n+\t(print_operand_address): Add 'ADDRESS_SYMBOLIC_TXT_REL' case + handling\n+\tfor 'address + offset'.\n+\t(microblaze_expand_prologue): Add new function prologue call for\n+\t'r20' assignation.\n+\t(microblaze_asm_generate_pic_addr_dif_vec): Override new target hook\n+\t'TARGET_ASM_GENERATE_PIC_ADDR_DIFF_VEC' to disable address diff vector\n+\ttable in case of TARGET_PIC_DATA_TEXT_REL.\n+\t(expand_pic_symbol_ref): Add handling for 'UNSPEC_TEXT'.\n+\t* gcc/config/microblaze/microblaze.md (TARGET_PIC_DATA_TEXT_REL):\n+\tAdd new macros 'UNSPEC_TEXT',\n+\t'UNSPEC_SET_TEXT' + add rule for setting r20 in function prologue\n+\t+ exclude function calls from 'UNSPEC_PLT' in case of data text\n+\trelative mode.\n+\t* doc/tm.texi.in (TARGET_ASM_GENERATE_PIC_ADDR_DIFF_VEC): Add\n+\tnew target hook for generating address diff vector tables in case of\n+\tflag_pic.\n+\t* doc/tm.texi : Regenerate.\n+\t* stmt.c (TARGET_ASM_GENERATE_PIC_ADDR_DIFF_VEC): Append new condition\n+\t'targetm.asm_out.generate_pic_addr_diff_vec' to flag_pic in case\n+\tof addr diff vector generation.\n+\t* target.def (TARGET_ASM_GENERATE_PIC_ADDR_DIFF_VEC): Add\n+\ttarget hook definition.\n+\t* targhooks.h, gcc/targhooks.c (TARGET_ASM_GENERATE_PIC_ADDR_DIFF_VEC):\n+\tAdd default function for generate_pic_addr_diff_vec -> flag_pic.\n+\t* doc/invoke.texi (Add new pic option): Add new microblaze pic\n+\toption for data text relative.\n+\n 2018-04-30  Richard Biener  <rguenther@suse.de>\n \n \t* tree-chrec.h (evolution_function_is_constant_p): Remove"}, {"sha": "515b713a3d793aaa8fc7c73c6cab7ccb8d393eb0", "filename": "gcc/config/microblaze/microblaze-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze-protos.h?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -24,6 +24,7 @@\n \n #ifdef RTX_CODE\n extern int pic_address_needs_scratch (rtx);\n+extern bool microblaze_constant_address_p (rtx x);\n extern void expand_block_move        (rtx *);\n extern void microblaze_expand_prologue (void);\n extern void microblaze_expand_epilogue (void);"}, {"sha": "06aa50e25560eba2bb13a4d165894328bb2e3280", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 175, "deletions": 35, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -91,7 +91,8 @@ enum microblaze_address_type\n   ADDRESS_SYMBOLIC,\n   ADDRESS_GOTOFF,\n   ADDRESS_PLT,\n-  ADDRESS_TLS\n+  ADDRESS_TLS,\n+  ADDRESS_SYMBOLIC_TXT_REL\n };\n \n /* Classifies symbols\n@@ -650,6 +651,10 @@ microblaze_classify_unspec (struct microblaze_address_info *info, rtx x)\n       info->type = ADDRESS_TLS;\n       info->tls_type = tls_reloc (INTVAL (XVECEXP (x, 0, 1)));\n     }\n+  else if (XINT (x, 1) == UNSPEC_TEXT)\n+    {\n+      info->type = ADDRESS_SYMBOLIC_TXT_REL;\n+    }\n   else\n     {\n       return false;\n@@ -701,8 +706,10 @@ get_base_reg (rtx x)\n }\n \n /* Return true if X is a valid address for machine mode MODE.  If it is,\n-   fill in INFO appropriately.  STRICT is true if we should only accept\n-   hard base registers.  \n+   fill in INFO appropriately.\n+   STRICT > 0 if we should only accept hard base registers.\n+   STRICT = 2 if the operand address is being printed thus\n+   function has been called by print_operand_address.\n \n       type                     regA      regB    offset      symbol\n \n@@ -728,13 +735,15 @@ microblaze_classify_address (struct microblaze_address_info *info, rtx x,\n {\n   rtx xplus0;\n   rtx xplus1;\n+  rtx offset;\n \n   info->type = ADDRESS_INVALID;\n   info->regA = NULL;\n   info->regB = NULL;\n   info->offset = NULL;\n   info->symbol = NULL;\n   info->symbol_type = SYMBOL_TYPE_INVALID;\n+  offset = NULL;\n \n   switch (GET_CODE (x))\n     {\n@@ -795,8 +804,13 @@ microblaze_classify_address (struct microblaze_address_info *info, rtx x,\n \t\t/* for (plus x const_int) just look at x.  */\n \t\tif (GET_CODE (xconst0) == PLUS\n \t\t    && GET_CODE (XEXP (xconst0, 1)) == CONST_INT\n-\t\t    && SMALL_INT (XEXP (xconst0, 1)))\n+\t\t    && (SMALL_INT (XEXP (xconst0, 1))\n+\t\t       || GET_CODE (XEXP (xconst0, 0)) == UNSPEC))\n \t\t  {\n+\t\t    /* Hold CONST_INT Value in offset in case of\n+\t\t       UNSPEC + CONST_INT.  */\n+\t\t    offset = XEXP (xconst0, 1);\n+\n \t\t    /* This is ok as info->symbol is set to xplus1 the full\n \t\t       const-expression below.  */\n \t\t    xconst0 = XEXP (xconst0, 0);\n@@ -814,6 +828,15 @@ microblaze_classify_address (struct microblaze_address_info *info, rtx x,\n \t\t    return true;\n \t\t  }\n \n+\t\tif (GET_CODE (xconst0) == UNSPEC && TARGET_PIC_DATA_TEXT_REL)\n+\t\t  {\n+\t\t    if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+\t\t      return false;\n+\n+\t\t    info->offset = offset;\n+\t\t    return microblaze_classify_unspec (info, xconst0);\n+\t\t  }\n+\n \t\t/* Not base + symbol || base + UNSPEC.  */\n \t\treturn false;\n \n@@ -858,6 +881,15 @@ microblaze_classify_address (struct microblaze_address_info *info, rtx x,\n \t     return !(flag_pic && pic_address_needs_scratch (x));\n \t  }\n \n+\t/* Avoid error in print_operand_address in case UNSPEC\n+\t is removed from SYMBOL or LABEL REFS during optimization.  */\n+\tif ((GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n+\t    && flag_pic && TARGET_PIC_DATA_TEXT_REL && strict == 2)\n+\t  {\n+\t    info->type = ADDRESS_SYMBOLIC_TXT_REL;\n+\t    return true;\n+\t  }\n+\n \tif (flag_pic == 2)\n \t  return false;\n \telse if (microblaze_tls_symbol_p(x))\n@@ -893,6 +925,15 @@ microblaze_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n   return microblaze_classify_address (&addr, x, mode, strict);\n }\n \n+bool\n+microblaze_constant_address_p (rtx x)\n+{\n+  return ((GET_CODE (x) == LABEL_REF) || (GET_CODE (x) == SYMBOL_REF)\n+\t  || GET_CODE (x) == CONST_INT\n+\t  || (GET_CODE (x) == CONST\n+\t  && ! (flag_pic && pic_address_needs_scratch (x))));\n+}\n+\n int\n microblaze_valid_pic_const (rtx x)\n {\n@@ -910,7 +951,8 @@ microblaze_valid_pic_const (rtx x)\n int\n microblaze_legitimate_pic_operand (rtx x)\n {\n-  if (flag_pic == 2 && (symbol_mentioned_p(x) || label_mentioned_p(x)))\n+  if (flag_pic == 2 && (symbol_mentioned_p (x) || label_mentioned_p (x))\n+      && !(TARGET_PIC_DATA_TEXT_REL && call_insn_operand (x,VOIDmode)))\n     return 0;\n \n   if (microblaze_tls_referenced_p(x))\n@@ -1024,17 +1066,35 @@ microblaze_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t\t}\n \t      else if (flag_pic == 2)\n \t\t{\n-\t\t  rtx pic_ref, reg;\n-\t\t  reg = gen_reg_rtx (Pmode);\n-\n-\t\t  pic_ref = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, xplus1),\n-\t\t\t\t\t    UNSPEC_GOTOFF);\n-\t\t  pic_ref = gen_rtx_CONST (Pmode, pic_ref);\n-\t\t  pic_ref = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, pic_ref);\n-\t\t  pic_ref = gen_const_mem (Pmode, pic_ref);\n-\t\t  emit_move_insn (reg, pic_ref);\n-\t\t  result = gen_rtx_PLUS (Pmode, xplus0, reg);\n-\t\t  return result;\n+\t\t  if (!TARGET_PIC_DATA_TEXT_REL)\n+\t\t    {\n+\t\t      rtx pic_ref, reg;\n+\t\t      reg = gen_reg_rtx (Pmode);\n+\n+\t\t      pic_ref = gen_rtx_UNSPEC (Pmode,\n+\t\t\t\t\t\tgen_rtvec (1, xplus1),\n+\t\t\t\t\t\tUNSPEC_GOTOFF);\n+\t\t      pic_ref = gen_rtx_CONST (Pmode, pic_ref);\n+\t\t      pic_ref = gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t      pic_offset_table_rtx, pic_ref);\n+\t\t      pic_ref = gen_const_mem (Pmode, pic_ref);\n+\t\t      emit_move_insn (reg, pic_ref);\n+\t\t      result = gen_rtx_PLUS (Pmode, xplus0, reg);\n+\t\t      return result;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      rtx pic_ref, reg;\n+\t\t      reg = gen_reg_rtx (Pmode);\n+\t\t      pic_ref = gen_rtx_UNSPEC (Pmode,\n+\t\t\t\t\t\tgen_rtvec (1, xplus1),\n+\t\t\t\t\t\tUNSPEC_TEXT);\n+\t\t      pic_ref = gen_rtx_CONST (Pmode, pic_ref);\n+\t\t      emit_insn (gen_addsi3 (reg,\n+\t\t\t\t pic_offset_table_rtx, xplus0));\n+\t\t      result = gen_rtx_PLUS (Pmode, reg, pic_ref);\n+\t\t      return result;\n+\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -1047,19 +1107,31 @@ microblaze_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n         {\n           reg = microblaze_legitimize_tls_address (xinsn, NULL_RTX);\n         }\n-      else\n+      else if (flag_pic == 2)\n         {\n-          rtx pic_ref;\n+\t  if (reload_in_progress)\n+\t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n \n-          if (reload_in_progress)\n-            df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n+\t  if (!TARGET_PIC_DATA_TEXT_REL)\n+\t    {\n+\t      rtx pic_ref;\n \n-          pic_ref = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, xinsn), UNSPEC_GOTOFF);\n-          pic_ref = gen_rtx_CONST (Pmode, pic_ref);\n-          pic_ref = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, pic_ref);\n-          pic_ref = gen_const_mem (Pmode, pic_ref);\n-          reg = pic_ref;\n-        }\n+\t      pic_ref = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, xinsn), UNSPEC_GOTOFF);\n+\t      pic_ref = gen_rtx_CONST (Pmode, pic_ref);\n+\t      pic_ref = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, pic_ref);\n+\t      pic_ref = gen_const_mem (Pmode, pic_ref);\n+\t      reg = pic_ref;\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx pic_ref;\n+\n+\t      pic_ref = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, xinsn), UNSPEC_TEXT);\n+\t      pic_ref = gen_rtx_CONST (Pmode, pic_ref);\n+\t      pic_ref = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, pic_ref);\n+\t      reg = pic_ref;\n+\t    }\n+\t}\n       return reg;\n     }\n \n@@ -1388,6 +1460,7 @@ microblaze_address_insns (rtx x, machine_mode mode)\n \tcase ADDRESS_REG_INDEX:\n \t  return 1;\n \tcase ADDRESS_SYMBOLIC:\n+\tcase ADDRESS_SYMBOLIC_TXT_REL:\n \tcase ADDRESS_GOTOFF:\n \t  return 2;\n \tcase ADDRESS_TLS:\n@@ -2066,7 +2139,7 @@ compute_frame_size (HOST_WIDE_INT size)\n \n   total_size = var_size + args_size;\n \n-  if (flag_pic == 2)\n+  if (flag_pic == 2 && !TARGET_PIC_DATA_TEXT_REL)\n     /* force setting GOT.  */\n     df_set_regs_ever_live (MB_ABI_PIC_ADDR_REGNUM, true);\n \n@@ -2322,6 +2395,7 @@ print_operand (FILE * file, rtx op, int letter)\n \t    case ADDRESS_REG:\n \t    case ADDRESS_CONST_INT:\n \t    case ADDRESS_SYMBOLIC:\n+\t    case ADDRESS_SYMBOLIC_TXT_REL:\n \t    case ADDRESS_GOTOFF:\n \t    case ADDRESS_TLS:\n \t      fputs (\"i\", file);\n@@ -2489,7 +2563,7 @@ print_operand_address (FILE * file, rtx addr)\n {\n   struct microblaze_address_info info;\n   enum microblaze_address_type type;\n-  if (!microblaze_classify_address (&info, addr, GET_MODE (addr), 1))\n+  if (!microblaze_classify_address (&info, addr, GET_MODE (addr), 2))\n     fatal_insn (\"insn contains an invalid address !\", addr);\n \n   type = info.type;\n@@ -2515,6 +2589,7 @@ print_operand_address (FILE * file, rtx addr)\n       output_addr_const (file, info.offset);\n       break;\n     case ADDRESS_SYMBOLIC:\n+    case ADDRESS_SYMBOLIC_TXT_REL:\n     case ADDRESS_GOTOFF:\n     case ADDRESS_PLT:\n     case ADDRESS_TLS:\n@@ -2529,6 +2604,16 @@ print_operand_address (FILE * file, rtx addr)\n \t{\n \t  fputs (\"@PLT\", file);\n \t}\n+      else if (type == ADDRESS_SYMBOLIC_TXT_REL)\n+    {\n+      if (info.offset != NULL && CONST_INT_P (info.offset)\n+\t  && INTVAL (info.offset) > 0)\n+\t{\n+\t  fprintf (file, \"+\");\n+\t  output_addr_const (file, info.offset);\n+\t}\n+      fputs (\"@TXTREL\", file);\n+    }\n       else if (type == ADDRESS_TLS)\n \t{\n \t  switch (info.tls_type)\n@@ -2888,7 +2973,6 @@ microblaze_expand_prologue (void)\n   if (flag_stack_usage_info)\n     current_function_static_stack_size = fsiz;\n \n-\n   /* If this function is a varargs function, store any registers that\n      would normally hold arguments ($5 - $10) on the stack.  */\n   if (((TYPE_ARG_TYPES (fntype) != 0\n@@ -2913,7 +2997,6 @@ microblaze_expand_prologue (void)\n \n \t  offset += GET_MODE_SIZE (SImode);\n \t}\n-\n     }\n \n   if (fsiz > 0)\n@@ -2960,8 +3043,18 @@ microblaze_expand_prologue (void)\n   if ((flag_pic == 2 || TLS_NEEDS_GOT )\n       && df_regs_ever_live_p (MB_ABI_PIC_ADDR_REGNUM))\n     {\n-      SET_REGNO (pic_offset_table_rtx, MB_ABI_PIC_ADDR_REGNUM);\n-      emit_insn (gen_set_got (pic_offset_table_rtx));\t/* setting GOT.  */\n+      if ((flag_pic == 2 && !TARGET_PIC_DATA_TEXT_REL) || TLS_NEEDS_GOT)\n+\t{\n+\t  SET_REGNO (pic_offset_table_rtx, MB_ABI_PIC_ADDR_REGNUM);\n+\t  /* setting GOT.  */\n+\t  emit_insn (gen_set_got (pic_offset_table_rtx));\n+\t}\n+      else\n+\t{\n+\t  SET_REGNO (pic_offset_table_rtx, MB_ABI_PIC_ADDR_REGNUM);\n+\t  /* setting start of text.  */\n+\t  emit_insn (gen_set_text (pic_offset_table_rtx));\n+\t}\n     }\n \n   /* If we are profiling, make sure no instructions are scheduled before\n@@ -3154,6 +3247,14 @@ microblaze_elf_in_small_data_p (const_tree decl)\n   return (size > 0 && size <= microblaze_section_threshold);\n }\n \n+/* We need to disable address diff vectors in\n+case of pic data text relative mode.  */\n+\n+static bool\n+microblaze_gen_pic_addr_dif_vec (void)\n+{\n+  return (flag_pic && !TARGET_PIC_DATA_TEXT_REL);\n+}\n \n static section *\n microblaze_select_section (tree decl, int reloc, unsigned HOST_WIDE_INT align)\n@@ -3187,10 +3288,19 @@ static rtx\n expand_pic_symbol_ref (machine_mode mode ATTRIBUTE_UNUSED, rtx op)\n {\n   rtx result;\n-  result = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op), UNSPEC_GOTOFF);\n+  bool isFunc = (GET_CODE (op) == SYMBOL_REF\n+\t\t && (SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_FUNCTION));\n+  result = (!TARGET_PIC_DATA_TEXT_REL)\n+\t    ? gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op), UNSPEC_GOTOFF)\n+\t    : gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op), UNSPEC_TEXT);\n   result = gen_rtx_CONST (Pmode, result);\n-  result = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, result);\n-  result = gen_const_mem (Pmode, result);\n+  result = (TARGET_PIC_DATA_TEXT_REL && isFunc)\n+\t    ? gen_rtx_PLUS (Pmode, gen_raw_REG (Pmode,\n+\t\t\t    get_base_reg (op)), result)\n+\t    : gen_rtx_PLUS (Pmode, pic_offset_table_rtx, result);\n+  result = (!TARGET_PIC_DATA_TEXT_REL)\n+\t    ? gen_const_mem (Pmode, result) : result;\n+\n   return result;\n }\n \n@@ -3294,10 +3404,37 @@ microblaze_expand_move (machine_mode mode, rtx operands[])\n \t  if (reload_in_progress)\n \t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n \t  result = expand_pic_symbol_ref (mode, op1);\n+\n+\t  if (TARGET_PIC_DATA_TEXT_REL && GET_CODE (op0) == REG\n+\t      && REGNO (op0) >= FIRST_PSEUDO_REGISTER)\n+\t    result = force_reg (SImode, result);\n+\n \t  emit_move_insn (op0, result);\n \t  return true;\n \t}\n     }\n+  if (GET_CODE (op1) == PLUS && GET_CODE (XEXP (op1,1)) == CONST)\n+    {\n+      rtx p0, p1, result, temp;\n+\n+      p0 = XEXP (XEXP (op1,1), 0);\n+\n+      if (GET_CODE (p0) == PLUS)\n+\t{\n+\t  p1 = XEXP (p0, 1);\n+\t  p0 = XEXP (p0, 0);\n+\t}\n+\n+      if (GET_CODE (p0) == UNSPEC && GET_CODE (p1) == CONST_INT\n+\t  && flag_pic && TARGET_PIC_DATA_TEXT_REL)\n+\t{\n+\t  result = gen_rtx_CONST (Pmode, p0);\n+\t  result = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, result);\n+\t  temp = force_reg (SImode, result);\n+\t  emit_move_insn (op0, gen_rtx_PLUS (SImode, temp, p1));\n+\t  return true;\n+\t}\n+    }\n   /* Handle Case of (const (plus symbol const_int)).  */\n   if (GET_CODE (op1) == CONST && GET_CODE (XEXP (op1,0)) == PLUS)\n     {\n@@ -3912,6 +4049,9 @@ microblaze_starting_frame_offset (void)\n #undef TARGET_LEGITIMATE_CONSTANT_P\n #define TARGET_LEGITIMATE_CONSTANT_P microblaze_legitimate_constant_p\n \n+#undef  TARGET_ASM_GENERATE_PIC_ADDR_DIFF_VEC\n+#define TARGET_ASM_GENERATE_PIC_ADDR_DIFF_VEC\tmicroblaze_gen_pic_addr_dif_vec\n+\n #undef TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG microblaze_machine_dependent_reorg\n "}, {"sha": "c05bed6e323b733d02ad9564995749b28bf5026d", "filename": "gcc/config/microblaze/microblaze.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -518,11 +518,7 @@ typedef struct microblaze_args\n \n /* Identify valid constant addresses.  Exclude if PIC addr which \n    needs scratch register.  */\n-#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-    || GET_CODE (X) == CONST_INT \t\t                        \\\n-    || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n-\t&& ! (flag_pic && pic_address_needs_scratch (X))))\n+#define CONSTANT_ADDRESS_P(X)\tmicroblaze_constant_address_p(X)\n \n /* Define this, so that when PIC, reload won't try to reload invalid\n    addresses which require two reload registers.  */"}, {"sha": "bec346f60ff60e780f00f19f370e7ebd43266f38", "filename": "gcc/config/microblaze/microblaze.md", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -41,6 +41,8 @@\n   (UNSPEC_CMP\t\t104)    ;; signed compare\n   (UNSPEC_CMPU\t\t105)    ;; unsigned compare\n   (UNSPEC_TLS           106)    ;; jump table\n+  (UNSPEC_SET_TEXT      107)    ;; set text start\n+  (UNSPEC_TEXT          108)    ;; data text relative\n ])\n \n (define_c_enum \"unspec\" [\n@@ -1848,7 +1850,7 @@\n   {\n     gcc_assert (GET_MODE (operands[0]) == Pmode);\n \n-    if (!flag_pic)\n+    if (!flag_pic || TARGET_PIC_DATA_TEXT_REL)\n       emit_jump_insn (gen_tablejump_internal1 (operands[0], operands[1]));\n     else\n       emit_jump_insn (gen_tablejump_internal3 (operands[0], operands[1]));\n@@ -2053,7 +2055,8 @@\n   {\n     rtx addr = XEXP (operands[0], 0);\n \n-    if (flag_pic == 2 && GET_CODE (addr) == SYMBOL_REF \n+    if (flag_pic == 2 && !TARGET_PIC_DATA_TEXT_REL\n+    && GET_CODE (addr) == SYMBOL_REF\n \t&& !SYMBOL_REF_LOCAL_P (addr)) \n       {\n         rtx temp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_PLT);\n@@ -2156,7 +2159,8 @@\n   {\n     rtx addr = XEXP (operands[1], 0);\n \n-    if (flag_pic == 2 && GET_CODE (addr) == SYMBOL_REF\n+    if (flag_pic == 2 && !TARGET_PIC_DATA_TEXT_REL\n+    && GET_CODE (addr) == SYMBOL_REF\n \t&& !SYMBOL_REF_LOCAL_P (addr)) \n       {\n         rtx temp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_PLT);\n@@ -2313,6 +2317,18 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"12\")])\n \n+;; The insn to set TEXT.\n+;; The hardcoded number \"8\" accounts for $pc difference\n+;; between \"mfs\" and \"addik\" instructions.\n+(define_insn \"set_text\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+    (unspec:SI[(const_int 0)] UNSPEC_SET_TEXT))]\n+  \"\"\n+  \"mfs\\t%0,rpc\\n\\taddik\\t%0,%0,8@TXTPCREL\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"12\")])\n+\n+\n ;; This insn gives the count of leading number of zeros for the second\n ;; operand and stores the result in first operand.\n (define_insn \"clzsi2\""}, {"sha": "2f34541c225118ce276237794af72766de8011c1", "filename": "gcc/config/microblaze/microblaze.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.opt?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -127,5 +127,9 @@ mxl-prefetch\n Target Mask(PREFETCH)\n Use hardware prefetch instruction\n \n+mpic-data-is-text-relative\n+Target Mask(PIC_DATA_TEXT_REL)\n+Data referenced by offset from start of text instead of GOT (with -fPIC/-fPIE).\n+\n mxl-mode-xilkernel\n Target"}, {"sha": "e45f467155a7d0b85c39937ae2708b0c6ca70463", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -867,7 +867,8 @@ Objective-C and Objective-C++ Dialects}.\n -mmemcpy  -mxl-soft-mul  -mxl-soft-div  -mxl-barrel-shift @gol\n -mxl-pattern-compare  -mxl-stack-check  -mxl-gp-opt  -mno-clearbss @gol\n -mxl-multiply-high  -mxl-float-convert  -mxl-float-sqrt @gol\n--mbig-endian  -mlittle-endian  -mxl-reorder  -mxl-mode-@var{app-model}}\n+-mbig-endian  -mlittle-endian  -mxl-reorder  -mxl-mode-@var{app-model}\n+-mpic-data-is-text-relative}\n \n @emph{MIPS Options}\n @gccoptlist{-EL  -EB  -march=@var{arch}  -mtune=@var{arch} @gol\n@@ -20113,6 +20114,12 @@ Select application model @var{app-model}.  Valid models are\n @item executable\n normal executable (default), uses startup code @file{crt0.o}.\n \n+@item -mpic-data-is-text-relative\n+@opindex mpic-data-is-text-relative\n+Assume that the displacement between the text and data segments is fixed\n+at static link time.  This allows data to be referenced by offset from start of\n+text address instead of GOT since PC-relative addressing is not supported.\n+\n @item xmdstub\n for use with Xilinx Microprocessor Debugger (XMD) based\n software intrusive debug agent called xmdstub. This uses startup file"}, {"sha": "9d92ed1c3d387c4371b36dafadb86022d365b50e", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -7491,6 +7491,14 @@ when the target cannot support (some kinds of) dynamic relocations\n in read-only sections even in executables.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_ASM_GENERATE_PIC_ADDR_DIFF_VEC (void)\n+Return true to generate ADDR_DIF_VEC table\n+or false to generate ADDR_VEC table for jumps in case of -fPIC.\n+\n+The default version of this function returns true if flag_pic\n+equals true and false otherwise\n+@end deftypefn\n+\n @deftypefn {Target Hook} {section *} TARGET_ASM_SELECT_SECTION (tree @var{exp}, int @var{reloc}, unsigned HOST_WIDE_INT @var{align})\n Return the section into which @var{exp} should be placed.  You can\n assume that @var{exp} is either a @code{VAR_DECL} node or a constant of"}, {"sha": "5732a2a4515ac7b087bfe328f43983f429b69773", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -4922,6 +4922,8 @@ This macro is irrelevant if there is no separate readonly data section.\n \n @hook TARGET_ASM_RELOC_RW_MASK\n \n+@hook TARGET_ASM_GENERATE_PIC_ADDR_DIFF_VEC\n+\n @hook TARGET_ASM_SELECT_SECTION\n \n @defmac USE_SELECT_SECTION_FOR_FUNCTIONS"}, {"sha": "b8df18181377a13923000f7f85c0706c7ac08252", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -853,7 +853,8 @@ emit_case_dispatch_table (tree index_expr, tree index_type,\n   /* Output the table.  */\n   emit_label (table_label);\n \n-  if (CASE_VECTOR_PC_RELATIVE || flag_pic)\n+  if (CASE_VECTOR_PC_RELATIVE\n+\t  || (flag_pic && targetm.asm_out.generate_pic_addr_diff_vec ()))\n     emit_jump_table_data (gen_rtx_ADDR_DIFF_VEC (CASE_VECTOR_MODE,\n \t\t\t\t\t\t gen_rtx_LABEL_REF (Pmode,\n \t\t\t\t\t\t\t\t    table_label),"}, {"sha": "2f7bca99ec24880ae69975160298b42476a2aae4", "filename": "gcc/target.def", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -507,6 +507,18 @@ in read-only sections even in executables.\",\n  int, (void),\n  default_reloc_rw_mask)\n \n+ /* Return a flag for either generating ADDR_DIF_VEC table\n+ or ADDR_VEC table for jumps in case of -fPIC/-fPIE.  */\n+DEFHOOK\n+(generate_pic_addr_diff_vec,\n+\"Return true to generate ADDR_DIF_VEC table\\n\\\n+or false to generate ADDR_VEC table for jumps in case of -fPIC.\\n\\\n+\\n\\\n+The default version of this function returns true if flag_pic\\n\\\n+equals true and false otherwise\",\n+ bool, (void),\n+ default_generate_pic_addr_diff_vec)\n+\n  /* Return a section for EXP.  It may be a DECL or a constant.  RELOC\n     is nonzero if runtime relocations must be applied; bit 1 will be\n     set if the runtime relocations require non-local name resolution."}, {"sha": "749e24ae17875f1b07c6d2b3cdeb8d18e7143aea", "filename": "gcc/targhooks.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -1196,6 +1196,15 @@ default_reloc_rw_mask (void)\n   return flag_pic ? 3 : 0;\n }\n \n+/* By default, address diff vectors are generated\n+for jump tables when flag_pic is true.  */\n+\n+bool\n+default_generate_pic_addr_diff_vec (void)\n+{\n+  return flag_pic;\n+}\n+\n /* By default, do no modification. */\n tree default_mangle_decl_assembler_name (tree decl ATTRIBUTE_UNUSED,\n \t\t\t\t\t tree id)"}, {"sha": "56951556525e94cfee1838c57d5fc49fe52efa75", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -175,6 +175,7 @@ extern machine_mode default_secondary_memory_needed_mode (machine_mode);\n extern void default_target_option_override (void);\n extern void hook_void_bitmap (bitmap);\n extern int default_reloc_rw_mask (void);\n+extern bool default_generate_pic_addr_diff_vec (void);\n extern tree default_mangle_decl_assembler_name (tree, tree);\n extern tree default_emutls_var_fields (tree, tree *);\n extern tree default_emutls_var_init (tree, tree, tree);"}, {"sha": "093cd365662433ef32dbc2892ffa15121a90a217", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -1,3 +1,23 @@\n+2018-04-30 Andrew Sadek  <andrew.sadek.se@gmail.com>\n+\n+\tMicroblaze Target: PIC data text relative\n+\n+\t* gcc.target/microblaze/others/data_var1.c: Include\n+\tPIC case of r20 base register.\n+\t* gcc.target/microblaze/others/data_var2.c: Ditto.\n+\t* gcc.target/microblaze/others/picdtr.c: Add new\n+\ttest case for -mpic-is-data-text-relative.\n+\t* gcc.target/microblaze/others/sdata_var1.c: Add\n+\t* gcc.target/microblaze/others/sdata_var2.c: Ditto.\n+\t* gcc.target/microblaze/others/sdata_var3.c: Ditto.\n+\t* gcc.target/microblaze/others/sdata_var4.c: Ditto.\n+\t* gcc.target/microblaze/others/sdata_var5.c: Ditto.\n+\t* gcc.target/microblaze/others/sdata_var6.c: Ditto.\n+\t* gcc.target/microblaze/others/string_cst1_gpopt.c:\n+\tDitto.\n+\t* gcc.target/microblaze/others/string_cst2_gpopt.c:\n+\tDitto.\n+\n 2018-04-30  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/28364"}, {"sha": "5826913d5d03b216f3d711aac694ce0e83c272d9", "filename": "gcc/testsuite/gcc.target/microblaze/others/data_var1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fdata_var1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fdata_var1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fdata_var1.c?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -3,6 +3,6 @@ int global;\n \n int testfunc ()\n {\n-/* { dg-final { scan-assembler \"\\lwi\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r0\" } } */\n+/* { dg-final { scan-assembler \"\\lwi\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(0|20)\" } } */\n     return global;\n }"}, {"sha": "97b091f10fc58cb57bc1980673e075300883b54f", "filename": "gcc/testsuite/gcc.target/microblaze/others/data_var2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fdata_var2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fdata_var2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fdata_var2.c?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -3,6 +3,6 @@ int global = 10;\n \n int testfunc ()\n {\n-/* { dg-final { scan-assembler \"\\lwi\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r0\" } } */\n+/* { dg-final { scan-assembler \"\\lwi\\tr(\\[0-9]\\|\\[1-2]\\[0-9]\\|3\\[0-1]),r(0|20)\" } } */\n     return global;\n }"}, {"sha": "d79034e1a07db2130d6163d9566c7deb247aa4d4", "filename": "gcc/testsuite/gcc.target/microblaze/others/sdata_var1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var1.c?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-mxl-gp-opt\" } */\n+/* { dg-options \"-mxl-gp-opt -fno-pic\" } */\n \n /* { dg-final { scan-assembler \"\\.sbss\\[^2]+\" } } */\n typedef int Boolean;"}, {"sha": "21b9115d795ba4cdd81f9b3c1bc566d09d2e8975", "filename": "gcc/testsuite/gcc.target/microblaze/others/sdata_var2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var2.c?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-mxl-gp-opt\" } */\n+/* { dg-options \"-mxl-gp-opt -fno-pic\" } */\n \n /* { dg-final { scan-assembler \"\\.sdata\\[^2]+\" } } */\n int global = 10;"}, {"sha": "2f233138fc169601a1fa4ae4cb0b2a7b34aba1c0", "filename": "gcc/testsuite/gcc.target/microblaze/others/sdata_var3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var3.c?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-mxl-gp-opt\" } */\n+/* { dg-options \"-mxl-gp-opt -fno-pic\" } */\n \n extern int a;\n "}, {"sha": "dc74e2d7d2cefe5dcf55c6cc424f7c7eb35f1b49", "filename": "gcc/testsuite/gcc.target/microblaze/others/sdata_var4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var4.c?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-mxl-gp-opt -G 16\" } */\n+/* { dg-options \"-mxl-gp-opt -G 16 -fno-pic\" } */\n \n /* { dg-final { scan-assembler \"\\.sbss\\[^2]+\" } } */\n struct test_s {"}, {"sha": "c0c3cb3bbba1168d52782420e74cf87e48fe3bf6", "filename": "gcc/testsuite/gcc.target/microblaze/others/sdata_var5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var5.c?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-mxl-gp-opt -G 16\" } */\n+/* { dg-options \"-mxl-gp-opt -G 16 -fno-pic\" } */\n \n /* { dg-final { scan-assembler \"\\.sdata\\[^2]+\" } } */\n struct test_s {"}, {"sha": "a23a2c76fe8cc58cc592b7df2a73a61fd324c7f4", "filename": "gcc/testsuite/gcc.target/microblaze/others/sdata_var6.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fsdata_var6.c?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -1,5 +1,4 @@\n-/* { dg-options \"-mxl-gp-opt -G 16\" } */\n-\n+/* { dg-options \"-mxl-gp-opt -G 16 -fno-pic\" } */\n struct test_s {\n     int a;\n     int b;"}, {"sha": "5bf390b3ea7281003ad00abd70715a7926cd672a", "filename": "gcc/testsuite/gcc.target/microblaze/others/string_cst1_gpopt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstring_cst1_gpopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstring_cst1_gpopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstring_cst1_gpopt.c?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-mxl-gp-opt\" } */\n+/* { dg-options \"-mxl-gp-opt -fno-pic\" } */\n \n #include <string.h>\n "}, {"sha": "2ad6673d2ef6ae4fdf65fd6e5d5dfac4726ee2bc", "filename": "gcc/testsuite/gcc.target/microblaze/others/string_cst2_gpopt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstring_cst2_gpopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1682fc3aaff288f7ac95cf5585971cef15f0ab/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstring_cst2_gpopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmicroblaze%2Fothers%2Fstring_cst2_gpopt.c?ref=af1682fc3aaff288f7ac95cf5585971cef15f0ab", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-mxl-gp-opt\" } */\n+/* { dg-options \"-mxl-gp-opt -fno-pic\" } */\n \n #include <string.h>\n "}]}