{"sha": "608a080c3f6e5a8338ff99658b27e226cbba7a67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA4YTA4MGMzZjZlNWE4MzM4ZmY5OTY1OGIyN2UyMjZjYmJhN2E2Nw==", "commit": {"author": {"name": "Antony Polukhin", "email": "antoshkka@gmail.com", "date": "2019-05-31T10:35:03Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-05-31T10:35:03Z"}, "message": "PR libstdc++/71579 assert that type traits are not misused with incomplete types\n\nThis patch adds static asserts for type traits misuse with incomplete\nclasses and unions. This gives a nice readable error message instead\nof an UB and odr-violations.\n\nSome features of the patch:\n* each type trait has it's own static_assert inside. This gives better\ndiagnostics than the approach with putting the assert into a helper\nstructure and using it in each trait.\n* the result of completeness check is not memorized by the compiler.\nThis gives no false positive after the first failed check.\n* some of the compiler builtins already implement the check. But not\nall of them! So the asserts are in all the type_traits that may\nbenefit from the check. This also makes the behavior of libstdc++ more\nconsistent across different (non GCC) compilers.\n* std::is_base_of does not have the assert as it works well in many\ncases with incomplete types\n\n2019-05-31  Antony Polukhin  <antoshkka@gmail.com>\n\n\tPR libstdc++/71579\n\t* include/std/type_traits __type_identity, __is_complete_or_unbounded):\n\tNew helpers for checking preconditions in traits.\n\t(is_trivial, is_trivially_copyable, is_standard_layout, is_pod)\n\t(is_literal_type, is_empty, is_polymorphic, is_final, is_abstract)\n\t(is_destructible, is_nothrow_destructible, is_constructible)\n\t(is_default_constructible, is_copy_constructible)\n\t(is_move_constructible, is_nothrow_default_constructible)\n\t(is_nothrow_constructible, is_nothrow_copy_constructible)\n\t(is_nothrow_move_constructible, is_copy_assignable, is_move_assignable)\n\t(is_nothrow_assignable, is_nothrow_copy_assignable)\n\t(is_nothrow_move_assignable, is_trivially_constructible)\n\t(is_trivially_copy_constructible, is_trivially_move_constructible)\n\tis_trivially_assignable, is_trivially_copy_assignable)\n\t(is_trivially_move_assignable, is_trivially_destructible)\n\t(alignment_of, is_swappable, is_nothrow_swappable, is_invocable)\n\t(is_invocable_r, is_nothrow_invocable)\n\t(has_unique_object_representations, is_aggregate): Add static_asserts\n\tto make sure that type traits are not misused with incomplete types.\n\t(__is_constructible_impl, __is_nothrow_default_constructible_impl)\n\t(__is_nothrow_constructible_impl, __is_nothrow_assignable_impl): New\n\tbase characteristics without assertions that can be reused in other\n\ttraits.\n\t* testsuite/20_util/is_complete_or_unbounded/memoization.cc: New test.\n\t* testsuite/20_util/is_complete_or_unbounded/memoization_neg.cc: New\n\ttest.\n\t* testsuite/20_util/is_complete_or_unbounded/value.cc: New test.\n\t* testsuite/20_util/is_abstract/incomplete_neg.cc: New test.\n\t* testsuite/20_util/is_aggregate/incomplete_neg.cc: New test.\n\t* testsuite/20_util/is_class/value.cc: Check incomplete type.\n\t* testsuite/20_util/is_function/value.cc: Likewise.\n\t* testsuite/20_util/is_move_constructible/incomplete_neg.cc: New test.\n\t* testsuite/20_util/is_nothrow_move_assignable/incomplete_neg.cc: New\n\ttest.\n\t* testsuite/20_util/is_polymorphic/incomplete_neg.cc: New test.\n\t* testsuite/20_util/is_reference/value.cc: Check incomplete types.\n\t* testsuite/20_util/is_unbounded_array/value.cc: Likewise.\n\t* testsuite/20_util/is_union/value.cc: Likewise.\n\t* testsuite/20_util/is_void/value.cc: Likewise.\n\t* testsuite/util/testsuite_tr1.h: Add incomplete union type.\n\nFrom-SVN: r271806", "tree": {"sha": "de5f6c1cbbc45c5383532c6088dce9fa44f24b70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de5f6c1cbbc45c5383532c6088dce9fa44f24b70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/608a080c3f6e5a8338ff99658b27e226cbba7a67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/608a080c3f6e5a8338ff99658b27e226cbba7a67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/608a080c3f6e5a8338ff99658b27e226cbba7a67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/608a080c3f6e5a8338ff99658b27e226cbba7a67/comments", "author": {"login": "apolukhin", "id": 1700098, "node_id": "MDQ6VXNlcjE3MDAwOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1700098?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apolukhin", "html_url": "https://github.com/apolukhin", "followers_url": "https://api.github.com/users/apolukhin/followers", "following_url": "https://api.github.com/users/apolukhin/following{/other_user}", "gists_url": "https://api.github.com/users/apolukhin/gists{/gist_id}", "starred_url": "https://api.github.com/users/apolukhin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apolukhin/subscriptions", "organizations_url": "https://api.github.com/users/apolukhin/orgs", "repos_url": "https://api.github.com/users/apolukhin/repos", "events_url": "https://api.github.com/users/apolukhin/events{/privacy}", "received_events_url": "https://api.github.com/users/apolukhin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aeedf0770557f01e46b95c220496e1b6d8b96149", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeedf0770557f01e46b95c220496e1b6d8b96149", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aeedf0770557f01e46b95c220496e1b6d8b96149"}], "stats": {"total": 695, "additions": 614, "deletions": 81}, "files": [{"sha": "3fe84943e7b535f892f414def11d460972b3f4f0", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=608a080c3f6e5a8338ff99658b27e226cbba7a67", "patch": "@@ -1,3 +1,46 @@\n+2019-05-31  Antony Polukhin  <antoshkka@gmail.com>\n+\n+\tPR libstdc++/71579\n+\t* include/std/type_traits __type_identity, __is_complete_or_unbounded):\n+\tNew helpers for checking preconditions in traits.\n+\t(is_trivial, is_trivially_copyable, is_standard_layout, is_pod)\n+\t(is_literal_type, is_empty, is_polymorphic, is_final, is_abstract)\n+\t(is_destructible, is_nothrow_destructible, is_constructible)\n+\t(is_default_constructible, is_copy_constructible)\n+\t(is_move_constructible, is_nothrow_default_constructible)\n+\t(is_nothrow_constructible, is_nothrow_copy_constructible)\n+\t(is_nothrow_move_constructible, is_copy_assignable, is_move_assignable)\n+\t(is_nothrow_assignable, is_nothrow_copy_assignable)\n+\t(is_nothrow_move_assignable, is_trivially_constructible)\n+\t(is_trivially_copy_constructible, is_trivially_move_constructible)\n+\tis_trivially_assignable, is_trivially_copy_assignable)\n+\t(is_trivially_move_assignable, is_trivially_destructible)\n+\t(alignment_of, is_swappable, is_nothrow_swappable, is_invocable)\n+\t(is_invocable_r, is_nothrow_invocable)\n+\t(has_unique_object_representations, is_aggregate): Add static_asserts\n+\tto make sure that type traits are not misused with incomplete types.\n+\t(__is_constructible_impl, __is_nothrow_default_constructible_impl)\n+\t(__is_nothrow_constructible_impl, __is_nothrow_assignable_impl): New\n+\tbase characteristics without assertions that can be reused in other\n+\ttraits.\n+\t* testsuite/20_util/is_complete_or_unbounded/memoization.cc: New test.\n+\t* testsuite/20_util/is_complete_or_unbounded/memoization_neg.cc: New\n+\ttest.\n+\t* testsuite/20_util/is_complete_or_unbounded/value.cc: New test.\n+\t* testsuite/20_util/is_abstract/incomplete_neg.cc: New test.\n+\t* testsuite/20_util/is_aggregate/incomplete_neg.cc: New test.\n+\t* testsuite/20_util/is_class/value.cc: Check incomplete type.\n+\t* testsuite/20_util/is_function/value.cc: Likewise.\n+\t* testsuite/20_util/is_move_constructible/incomplete_neg.cc: New test.\n+\t* testsuite/20_util/is_nothrow_move_assignable/incomplete_neg.cc: New\n+\ttest.\n+\t* testsuite/20_util/is_polymorphic/incomplete_neg.cc: New test.\n+\t* testsuite/20_util/is_reference/value.cc: Check incomplete types.\n+\t* testsuite/20_util/is_unbounded_array/value.cc: Likewise.\n+\t* testsuite/20_util/is_union/value.cc: Likewise.\n+\t* testsuite/20_util/is_void/value.cc: Likewise.\n+\t* testsuite/util/testsuite_tr1.h: Add incomplete union type.\n+\n 2019-05-31  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/bits/random.h (random_device::_M_init(const char*, size_t)):"}, {"sha": "78a113af415a391344853cf262a07530504affd4", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 253, "deletions": 81, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=608a080c3f6e5a8338ff99658b27e226cbba7a67", "patch": "@@ -91,6 +91,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<bool, typename, typename>\n     struct conditional;\n \n+  template <typename _Type>\n+    struct __type_identity {\n+      using type = _Type;\n+    };\n+\n   template<typename...>\n     struct __or_;\n \n@@ -177,6 +182,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n #endif // C++17\n \n+  // Forward declarations\n+  template<typename>\n+    struct is_reference;\n+  template<typename>\n+    struct is_function;\n+  template<typename>\n+    struct is_void;\n+  template<typename>\n+    struct __is_array_unknown_bounds;\n+\n+  // Helper functions that return false_type for incomplete classes,\n+  // incomplete unions and arrays of known bound from those.\n+\n+  template <typename _T, size_t = sizeof(_T)>\n+    constexpr true_type __is_complete_or_unbounded(__type_identity<_T>)\n+    { return {}; }\n+\n+  template <typename _TypeIdentity,\n+      typename _NestedType = typename _TypeIdentity::type>\n+    constexpr typename __or_<\n+      is_reference<_NestedType>,\n+      is_function<_NestedType>,\n+      is_void<_NestedType>,\n+      __is_array_unknown_bounds<_NestedType>\n+    >::type __is_complete_or_unbounded(_TypeIdentity)\n+    { return {}; }\n+\n   // For several sfinae-friendly trait implementations we transport both the\n   // result information (as the member type) and the failure information (no\n   // member type). This is very similar to std::enable_if, but we cannot use\n@@ -398,9 +430,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct is_rvalue_reference<_Tp&&>\n     : public true_type { };\n \n-  template<typename>\n-    struct is_function;\n-\n   template<typename>\n     struct __is_member_object_pointer_helper\n     : public false_type { };\n@@ -671,59 +700,86 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n     struct is_trivial\n     : public integral_constant<bool, __is_trivial(_Tp)>\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   // is_trivially_copyable\n   template<typename _Tp>\n     struct is_trivially_copyable\n     : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   /// is_standard_layout\n   template<typename _Tp>\n     struct is_standard_layout\n     : public integral_constant<bool, __is_standard_layout(_Tp)>\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   /// is_pod\n   // Could use is_standard_layout && is_trivial instead of the builtin.\n   template<typename _Tp>\n     struct is_pod\n     : public integral_constant<bool, __is_pod(_Tp)>\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   /// is_literal_type\n   template<typename _Tp>\n     struct is_literal_type\n     : public integral_constant<bool, __is_literal_type(_Tp)>\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   /// is_empty\n   template<typename _Tp>\n     struct is_empty\n     : public integral_constant<bool, __is_empty(_Tp)>\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   /// is_polymorphic\n   template<typename _Tp>\n     struct is_polymorphic\n     : public integral_constant<bool, __is_polymorphic(_Tp)>\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n #if __cplusplus >= 201402L\n #define __cpp_lib_is_final 201402L\n   /// is_final\n   template<typename _Tp>\n     struct is_final\n     : public integral_constant<bool, __is_final(_Tp)>\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n #endif\n \n   /// is_abstract\n   template<typename _Tp>\n     struct is_abstract\n     : public integral_constant<bool, __is_abstract(_Tp)>\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   template<typename _Tp,\n \t   bool = is_arithmetic<_Tp>::value>\n@@ -828,7 +884,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n     struct is_destructible\n     : public __is_destructible_safe<_Tp>::type\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   // is_nothrow_destructible requires that is_destructible is\n   // satisfied as well.  We realize that by mimicing the\n@@ -876,19 +935,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n     struct is_nothrow_destructible\n     : public __is_nt_destructible_safe<_Tp>::type\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n+\n+  template<typename _Tp, typename... _Args>\n+    struct __is_constructible_impl\n+    : public __bool_constant<__is_constructible(_Tp, _Args...)>\n     { };\n \n   /// is_constructible\n   template<typename _Tp, typename... _Args>\n     struct is_constructible\n-      : public __bool_constant<__is_constructible(_Tp, _Args...)>\n-    { };\n+      : public __is_constructible_impl<_Tp, _Args...>\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   /// is_default_constructible\n   template<typename _Tp>\n     struct is_default_constructible\n-    : public is_constructible<_Tp>::type\n-    { };\n+    : public __is_constructible_impl<_Tp>::type\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n     struct __is_copy_constructible_impl;\n@@ -899,14 +972,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Tp>\n     struct __is_copy_constructible_impl<_Tp, true>\n-    : public is_constructible<_Tp, const _Tp&>\n+    : public __is_constructible_impl<_Tp, const _Tp&>\n     { };\n \n   /// is_copy_constructible\n   template<typename _Tp>\n     struct is_copy_constructible\n     : public __is_copy_constructible_impl<_Tp>\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n     struct __is_move_constructible_impl;\n@@ -917,14 +993,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Tp>\n     struct __is_move_constructible_impl<_Tp, true>\n-    : public is_constructible<_Tp, _Tp&&>\n+    : public __is_constructible_impl<_Tp, _Tp&&>\n     { };\n \n   /// is_move_constructible\n   template<typename _Tp>\n     struct is_move_constructible\n     : public __is_move_constructible_impl<_Tp>\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   template<typename _Tp>\n     struct __is_nt_default_constructible_atom\n@@ -946,12 +1025,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public __is_nt_default_constructible_atom<_Tp>\n     { };\n \n+  template<typename _Tp>\n+    using __is_nothrow_default_constructible_impl\n+      = __and_<__is_constructible_impl<_Tp>,\n+\t       __is_nt_default_constructible_impl<_Tp>>;\n+\n   /// is_nothrow_default_constructible\n   template<typename _Tp>\n     struct is_nothrow_default_constructible\n-    : public __and_<is_default_constructible<_Tp>,\n-                    __is_nt_default_constructible_impl<_Tp>>\n-    { };\n+    : public __is_nothrow_default_constructible_impl<_Tp>::type\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   template<typename _Tp, typename... _Args>\n     struct __is_nt_constructible_impl\n@@ -966,16 +1052,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Tp>\n     struct __is_nt_constructible_impl<_Tp>\n-    : public is_nothrow_default_constructible<_Tp>\n+    : public __is_nothrow_default_constructible_impl<_Tp>\n     { };\n \n-  /// is_nothrow_constructible\n   template<typename _Tp, typename... _Args>\n-    struct is_nothrow_constructible\n-    : public __and_<is_constructible<_Tp, _Args...>,\n+    struct __is_nothrow_constructible_impl\n+    : public __and_<__is_constructible_impl<_Tp, _Args...>,\n \t\t    __is_nt_constructible_impl<_Tp, _Args...>>\n     { };\n \n+  /// is_nothrow_constructible\n+  template<typename _Tp, typename... _Args>\n+    struct is_nothrow_constructible\n+    : public __is_nothrow_constructible_impl<_Tp, _Args...>::type\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n+\n   template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n     struct __is_nothrow_copy_constructible_impl;\n \n@@ -985,14 +1079,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Tp>\n     struct __is_nothrow_copy_constructible_impl<_Tp, true>\n-    : public is_nothrow_constructible<_Tp, const _Tp&>\n+    : public __is_nothrow_constructible_impl<_Tp, const _Tp&>\n     { };\n \n   /// is_nothrow_copy_constructible\n   template<typename _Tp>\n     struct is_nothrow_copy_constructible\n-    : public __is_nothrow_copy_constructible_impl<_Tp>\n-    { };\n+    : public __is_nothrow_copy_constructible_impl<_Tp>::type\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n     struct __is_nothrow_move_constructible_impl;\n@@ -1003,20 +1100,26 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Tp>\n     struct __is_nothrow_move_constructible_impl<_Tp, true>\n-    : public is_nothrow_constructible<_Tp, _Tp&&>\n+    : public __is_nothrow_constructible_impl<_Tp, _Tp&&>\n     { };\n \n   /// is_nothrow_move_constructible\n   template<typename _Tp>\n     struct is_nothrow_move_constructible\n-    : public __is_nothrow_move_constructible_impl<_Tp>\n-    { };\n+    : public __is_nothrow_move_constructible_impl<_Tp>::type\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   /// is_assignable\n   template<typename _Tp, typename _Up>\n     struct is_assignable\n-      : public __bool_constant<__is_assignable(_Tp, _Up)>\n-    { };\n+    : public __bool_constant<__is_assignable(_Tp, _Up)>\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n     struct __is_copy_assignable_impl;\n@@ -1027,14 +1130,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Tp>\n     struct __is_copy_assignable_impl<_Tp, true>\n-    : public is_assignable<_Tp&, const _Tp&>\n+    : public __bool_constant<__is_assignable(_Tp&, const _Tp&)>\n     { };\n \n   /// is_copy_assignable\n   template<typename _Tp>\n     struct is_copy_assignable\n-    : public __is_copy_assignable_impl<_Tp>\n-    { };\n+    : public __is_copy_assignable_impl<_Tp>::type\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n     struct __is_move_assignable_impl;\n@@ -1045,27 +1151,38 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Tp>\n     struct __is_move_assignable_impl<_Tp, true>\n-    : public is_assignable<_Tp&, _Tp&&>\n+    : public __bool_constant<__is_assignable(_Tp&, _Tp&&)>\n     { };\n \n   /// is_move_assignable\n   template<typename _Tp>\n     struct is_move_assignable\n-    : public __is_move_assignable_impl<_Tp>\n-    { };\n+    : public __is_move_assignable_impl<_Tp>::type\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   template<typename _Tp, typename _Up>\n     struct __is_nt_assignable_impl\n     : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>\n     { };\n \n-  /// is_nothrow_assignable\n   template<typename _Tp, typename _Up>\n-    struct is_nothrow_assignable\n-    : public __and_<is_assignable<_Tp, _Up>,\n+    struct __is_nothrow_assignable_impl\n+    : public __and_<__bool_constant<__is_assignable(_Tp, _Up)>,\n \t\t    __is_nt_assignable_impl<_Tp, _Up>>\n     { };\n \n+  /// is_nothrow_assignable\n+  template<typename _Tp, typename _Up>\n+    struct is_nothrow_assignable\n+    : public __is_nothrow_assignable_impl<_Tp, _Up>\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n+\n   template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n     struct __is_nt_copy_assignable_impl;\n \n@@ -1075,14 +1192,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Tp>\n     struct __is_nt_copy_assignable_impl<_Tp, true>\n-    : public is_nothrow_assignable<_Tp&, const _Tp&>\n+    : public __is_nothrow_assignable_impl<_Tp&, const _Tp&>\n     { };\n \n   /// is_nothrow_copy_assignable\n   template<typename _Tp>\n     struct is_nothrow_copy_assignable\n     : public __is_nt_copy_assignable_impl<_Tp>\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n     struct __is_nt_move_assignable_impl;\n@@ -1093,26 +1213,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Tp>\n     struct __is_nt_move_assignable_impl<_Tp, true>\n-    : public is_nothrow_assignable<_Tp&, _Tp&&>\n+    : public __is_nothrow_assignable_impl<_Tp&, _Tp&&>\n     { };\n \n   /// is_nothrow_move_assignable\n   template<typename _Tp>\n     struct is_nothrow_move_assignable\n     : public __is_nt_move_assignable_impl<_Tp>\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   /// is_trivially_constructible\n   template<typename _Tp, typename... _Args>\n     struct is_trivially_constructible\n     : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)>\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   /// is_trivially_default_constructible\n   template<typename _Tp>\n     struct is_trivially_default_constructible\n-    : public is_trivially_constructible<_Tp>::type\n-    { };\n+    : public __bool_constant<__is_trivially_constructible(_Tp)>\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   struct __do_is_implicitly_default_constructible_impl\n   {\n@@ -1140,12 +1269,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template <typename _Tp>\n     struct __is_implicitly_default_constructible\n-    : public __and_<is_default_constructible<_Tp>,\n+    : public __and_<__is_constructible_impl<_Tp>,\n \t\t    __is_implicitly_default_constructible_safe<_Tp>>\n     { };\n \n-  /// is_trivially_copy_constructible\n-\n   template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n     struct __is_trivially_copy_constructible_impl;\n \n@@ -1155,17 +1282,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Tp>\n     struct __is_trivially_copy_constructible_impl<_Tp, true>\n-    : public __and_<is_copy_constructible<_Tp>,\n+    : public __and_<__is_copy_constructible_impl<_Tp>,\n \t\t    integral_constant<bool,\n \t\t\t__is_trivially_constructible(_Tp, const _Tp&)>>\n     { };\n \n+  /// is_trivially_copy_constructible\n   template<typename _Tp>\n     struct is_trivially_copy_constructible\n     : public __is_trivially_copy_constructible_impl<_Tp>\n-    { };\n-\n-  /// is_trivially_move_constructible\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n     struct __is_trivially_move_constructible_impl;\n@@ -1176,23 +1305,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Tp>\n     struct __is_trivially_move_constructible_impl<_Tp, true>\n-    : public __and_<is_move_constructible<_Tp>,\n+    : public __and_<__is_move_constructible_impl<_Tp>,\n \t\t    integral_constant<bool,\n \t\t\t__is_trivially_constructible(_Tp, _Tp&&)>>\n     { };\n \n+  /// is_trivially_move_constructible\n   template<typename _Tp>\n     struct is_trivially_move_constructible\n     : public __is_trivially_move_constructible_impl<_Tp>\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   /// is_trivially_assignable\n   template<typename _Tp, typename _Up>\n     struct is_trivially_assignable\n     : public __bool_constant<__is_trivially_assignable(_Tp, _Up)>\n-    { };\n-\n-  /// is_trivially_copy_assignable\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n     struct __is_trivially_copy_assignable_impl;\n@@ -1206,12 +1340,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public __bool_constant<__is_trivially_assignable(_Tp&, const _Tp&)>\n     { };\n \n+  /// is_trivially_copy_assignable\n   template<typename _Tp>\n     struct is_trivially_copy_assignable\n     : public __is_trivially_copy_assignable_impl<_Tp>\n-    { };\n-\n-  /// is_trivially_move_assignable\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n     struct __is_trivially_move_assignable_impl;\n@@ -1225,32 +1361,46 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public __bool_constant<__is_trivially_assignable(_Tp&, _Tp&&)>\n     { };\n \n+  /// is_trivially_move_assignable\n   template<typename _Tp>\n     struct is_trivially_move_assignable\n     : public __is_trivially_move_assignable_impl<_Tp>\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   /// is_trivially_destructible\n   template<typename _Tp>\n     struct is_trivially_destructible\n-    : public __and_<is_destructible<_Tp>,\n+    : public __and_<__is_destructible_safe<_Tp>,\n \t\t    __bool_constant<__has_trivial_destructor(_Tp)>>\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n \n   /// has_virtual_destructor\n   template<typename _Tp>\n     struct has_virtual_destructor\n     : public integral_constant<bool, __has_virtual_destructor(_Tp)>\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n \n   // type property queries.\n \n   /// alignment_of\n   template<typename _Tp>\n     struct alignment_of\n-    : public integral_constant<std::size_t, alignof(_Tp)> { };\n+    : public integral_constant<std::size_t, alignof(_Tp)>\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   /// rank\n   template<typename>\n@@ -1336,7 +1486,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public __is_convertible_helper<_From, _To>::type\n     { };\n \n-    template<typename _From, typename _To,\n+  template<typename _From, typename _To,\n            bool = __or_<is_void<_From>, is_function<_To>,\n                         is_array<_To>>::value>\n     struct __is_nt_convertible_helper\n@@ -2577,13 +2727,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n     struct is_swappable\n     : public __is_swappable_impl<_Tp>::type\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   /// is_nothrow_swappable\n   template<typename _Tp>\n     struct is_nothrow_swappable\n     : public __is_nothrow_swappable_impl<_Tp>::type\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n #if __cplusplus >= 201402L\n   /// is_swappable_v\n@@ -2774,20 +2930,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Fn, typename... _ArgTypes>\n     struct is_invocable\n     : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),\n+\t\"_Fn must be a complete class or an unbounded array\");\n+    };\n \n   /// std::is_invocable_r\n   template<typename _Ret, typename _Fn, typename... _ArgTypes>\n     struct is_invocable_r\n     : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),\n+\t\"_Fn must be a complete class or an unbounded array\");\n+    };\n \n   /// std::is_nothrow_invocable\n   template<typename _Fn, typename... _ArgTypes>\n     struct is_nothrow_invocable\n     : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>,\n-             __call_is_nothrow_<_Fn, _ArgTypes...>>::type\n-    { };\n+\t     __call_is_nothrow_<_Fn, _ArgTypes...>>::type\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),\n+\t\"_Fn must be a complete class or an unbounded array\");\n+    };\n \n   template<typename _Result, typename _Ret, typename = void>\n     struct __is_nt_invocable_impl : false_type { };\n@@ -2993,7 +3158,10 @@ template <typename _From, typename _To>\n     : bool_constant<__has_unique_object_representations(\n       remove_cv_t<remove_all_extents_t<_Tp>>\n       )>\n-    { };\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   template<typename _Tp>\n     inline constexpr bool has_unique_object_representations_v\n@@ -3005,7 +3173,11 @@ template <typename _From, typename _To>\n   /// is_aggregate\n   template<typename _Tp>\n     struct is_aggregate\n-    : bool_constant<__is_aggregate(remove_cv_t<_Tp>)> { };\n+    : bool_constant<__is_aggregate(remove_cv_t<_Tp>)>\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n \n   /// is_aggregate_v\n   template<typename _Tp>"}, {"sha": "94f4ecd6000b8e2a948e88ae402adf9f3d79c7c4", "filename": "libstdc++-v3/testsuite/20_util/is_abstract/incomplete_neg.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_abstract%2Fincomplete_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_abstract%2Fincomplete_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_abstract%2Fincomplete_neg.cc?ref=608a080c3f6e5a8338ff99658b27e226cbba7a67", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-prune-output \"invalid use of incomplete type\" }\n+// { dg-prune-output \"must be a complete\" }\n+//\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+\n+class X;\n+\n+void test01()\n+{\n+  std::is_abstract<X>();\t\t// { dg-error \"required from here\" }\n+}"}, {"sha": "8a3dd551cbb856df5a213fc265177612e6bac176", "filename": "libstdc++-v3/testsuite/20_util/is_aggregate/incomplete_neg.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_aggregate%2Fincomplete_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_aggregate%2Fincomplete_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_aggregate%2Fincomplete_neg.cc?ref=608a080c3f6e5a8338ff99658b27e226cbba7a67", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile { target c++17 } }\n+//\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-error \"must be a complete class\" \"\" { target *-*-* } 0 }\n+\n+#include <type_traits>\n+\n+class X;\n+\n+void test01()\n+{\n+  std::is_aggregate<X>();\t\t// { dg-error \"required from here\" }\n+}"}, {"sha": "801dc679a21890e24d6a9581826a190570bb7009", "filename": "libstdc++-v3/testsuite/20_util/is_class/value.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_class%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_class%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_class%2Fvalue.cc?ref=608a080c3f6e5a8338ff99658b27e226cbba7a67", "patch": "@@ -27,6 +27,7 @@ void test01()\n \n   // Positive tests.\n   static_assert(test_category<is_class, ClassType>(true), \"\");\n+  static_assert(test_category<is_class, IncompleteClass>(true), \"\");\n   static_assert(test_category<is_class, DerivedType>(true), \"\");\n   static_assert(test_category<is_class, ConvType>(true), \"\");\n   static_assert(test_category<is_class, AbstractClass>(true), \"\");\n@@ -47,4 +48,5 @@ void test01()\n   static_assert(test_category<is_class, int (ClassType::*) (int)>(false), \"\");\n   static_assert(test_category<is_class, int (int)>(false), \"\");\n   static_assert(test_category<is_class, EnumType>(false), \"\");\n+  static_assert(test_category<is_class, IncompleteUnion>(false), \"\");\n }"}, {"sha": "83afb40cd180abb9e8e4553b1f8df8b32c4612ea", "filename": "libstdc++-v3/testsuite/20_util/is_complete_or_unbounded/memoization.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_complete_or_unbounded%2Fmemoization.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_complete_or_unbounded%2Fmemoization.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_complete_or_unbounded%2Fmemoization.cc?ref=608a080c3f6e5a8338ff99658b27e226cbba7a67", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile { target c++11 } }\n+\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+\n+struct X;\n+static_assert(\n+  !std::__is_complete_or_unbounded(std::__type_identity<X>{}), \"error\");\n+\n+struct X{};\n+static_assert(\n+  std::__is_complete_or_unbounded(std::__type_identity<X>{}),\n+  \"Result memoized. This leads to worse diagnostics\");"}, {"sha": "04b83a21c019d91aa7ba4f0f97bc00bdf04dcea1", "filename": "libstdc++-v3/testsuite/20_util/is_complete_or_unbounded/memoization_neg.cc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_complete_or_unbounded%2Fmemoization_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_complete_or_unbounded%2Fmemoization_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_complete_or_unbounded%2Fmemoization_neg.cc?ref=608a080c3f6e5a8338ff99658b27e226cbba7a67", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-prune-output \"must be a complete\" }\n+\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+\n+struct X;\n+constexpr bool res_incomplete = std::is_move_constructible<X>::value; // { dg-error \"required from here\" }\n+\n+struct X{};\n+constexpr bool res_complete = std::is_default_constructible<X>::value; // { dg-bogus \"required from here\" }"}, {"sha": "5a03ad67a30dc157a4e86ea5e37c0dbb09465652", "filename": "libstdc++-v3/testsuite/20_util/is_complete_or_unbounded/value.cc", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_complete_or_unbounded%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_complete_or_unbounded%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_complete_or_unbounded%2Fvalue.cc?ref=608a080c3f6e5a8338ff99658b27e226cbba7a67", "patch": "@@ -0,0 +1,100 @@\n+// { dg-do compile { target c++11 } }\n+\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+\n+\n+struct incomplete_type;\n+class incomplete_type2;\n+union incomplete_union;\n+enum class incomplete_enum: int;\n+enum incomplete_enum2: int;\n+static_assert(!std::__is_complete_or_unbounded(std::__type_identity<incomplete_type>{}), \"\");\n+static_assert(!std::__is_complete_or_unbounded(std::__type_identity<incomplete_type2>{}), \"\");\n+static_assert(!std::__is_complete_or_unbounded(std::__type_identity<incomplete_union>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<incomplete_enum>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<incomplete_enum2>{}), \"\");\n+\n+static_assert(!std::__is_complete_or_unbounded(std::__type_identity<incomplete_type[42]>{}), \"\");\n+static_assert(!std::__is_complete_or_unbounded(std::__type_identity<incomplete_type2[42]>{}), \"\");\n+static_assert(!std::__is_complete_or_unbounded(std::__type_identity<incomplete_union[42]>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<incomplete_enum[42]>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<incomplete_enum2[42]>{}), \"\");\n+\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<incomplete_type[]>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<incomplete_type2[]>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<incomplete_union[]>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<incomplete_enum[]>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<incomplete_enum2[]>{}), \"\");\n+\n+\n+struct complete_type{ ~complete_type() = delete; };\n+class complete_type2{ int i; };\n+union complete_union{};\n+enum class complete_enum: int {};\n+enum complete_enum2: int {};\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<complete_type>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<complete_type2>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<complete_union>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<complete_enum>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<complete_enum2>{}), \"\");\n+\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<complete_type[42]>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<complete_type2[42]>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<complete_union[42]>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<complete_enum[42]>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<complete_enum2[42]>{}), \"\");\n+\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<complete_type[]>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<complete_type2[]>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<complete_union[]>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<complete_enum[]>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<complete_enum2[]>{}), \"\");\n+\n+\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<const complete_type>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<const complete_type2>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<const complete_union>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<const complete_enum>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<const complete_enum2>{}), \"\");\n+\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<incomplete_type*>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<complete_type*>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<const incomplete_type*>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<const complete_type*>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<incomplete_type&>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<complete_type&>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<incomplete_type&&>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<complete_type&&>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<int complete_type::*>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<int (complete_type::*)(int)>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<int incomplete_type::*>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<int (incomplete_type::*)(int)>{}), \"\");\n+\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<void(*)() noexcept>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<void(...) noexcept>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<void(&)(int)>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<void(*)()>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<void(incomplete_type)>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<void(&)()>{}), \"\");\n+\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<std::nullptr_t>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<void>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<void*>{}), \"\");\n+static_assert(std::__is_complete_or_unbounded(std::__type_identity<const void* const>{}), \"\");"}, {"sha": "7b94b58b6cbf125f09cbcc4382ceff0699b5e4a7", "filename": "libstdc++-v3/testsuite/20_util/is_function/value.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_function%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_function%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_function%2Fvalue.cc?ref=608a080c3f6e5a8338ff99658b27e226cbba7a67", "patch": "@@ -46,4 +46,6 @@ void test01()\n   \n   // Sanity check.\n   static_assert(test_category<is_function, ClassType>(false), \"\");\n+  static_assert(test_category<is_function, IncompleteClass>(false), \"\");\n+  static_assert(test_category<is_function, IncompleteUnion>(false), \"\");\n }"}, {"sha": "d6a08d7763971fb5610c8cd7cf531f2f4aad1232", "filename": "libstdc++-v3/testsuite/20_util/is_move_constructible/incomplete_neg.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_move_constructible%2Fincomplete_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_move_constructible%2Fincomplete_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_move_constructible%2Fincomplete_neg.cc?ref=608a080c3f6e5a8338ff99658b27e226cbba7a67", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile { target c++11 } }\n+//\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-error \"must be a complete class\" \"\" { target *-*-* } 0 }\n+\n+#include <type_traits>\n+\n+class X;\n+\n+void test01()\n+{\n+  std::is_move_constructible<X>();\t\t// { dg-error \"required from here\" }\n+}"}, {"sha": "ebceec5474bde86a15de091e108be5bd4ee5d57c", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_move_assignable/incomplete_neg.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_move_assignable%2Fincomplete_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_move_assignable%2Fincomplete_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_move_assignable%2Fincomplete_neg.cc?ref=608a080c3f6e5a8338ff99658b27e226cbba7a67", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile { target c++11 } }\n+//\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-error \"must be a complete class\" \"\" { target *-*-* } 0 }\n+\n+#include <type_traits>\n+\n+class X;\n+\n+void test01()\n+{\n+  std::is_nothrow_move_assignable<X>();\t\t// { dg-error \"required from here\" }\n+}"}, {"sha": "8cd1b402a41fba6a34bef339b15b9fdeaefaf180", "filename": "libstdc++-v3/testsuite/20_util/is_polymorphic/incomplete_neg.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_polymorphic%2Fincomplete_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_polymorphic%2Fincomplete_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_polymorphic%2Fincomplete_neg.cc?ref=608a080c3f6e5a8338ff99658b27e226cbba7a67", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-prune-output \"invalid use of incomplete type\" }\n+// { dg-prune-output \"must be a complete\" }\n+//\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+\n+class X;\n+\n+void test01()\n+{\n+  std::is_polymorphic<X>();\t\t// { dg-error \"required from here\" }\n+}"}, {"sha": "4676894a5e91a51adba15e5a6e9a7802e32f84d2", "filename": "libstdc++-v3/testsuite/20_util/is_reference/value.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_reference%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_reference%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_reference%2Fvalue.cc?ref=608a080c3f6e5a8338ff99658b27e226cbba7a67", "patch": "@@ -33,8 +33,11 @@ void test01()\n   static_assert(test_category<is_reference, int&&>(true), \"\");\n   static_assert(test_category<is_reference, ClassType&&>(true), \"\");\n   static_assert(test_category<is_reference, int(&&)(int)>(true), \"\");\n+  static_assert(test_category<is_reference, IncompleteClass&>(true), \"\");\n+  static_assert(test_category<is_reference, const IncompleteClass&>(true), \"\");\n \n   // Sanity check.\n   static_assert(test_category<is_reference, ClassType>(false), \"\");\n+  static_assert(test_category<is_reference, IncompleteClass>(false), \"\");\n }\n "}, {"sha": "bca0e3cb82e416cf675d8b421a6efacab1997273", "filename": "libstdc++-v3/testsuite/20_util/is_unbounded_array/value.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_unbounded_array%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_unbounded_array%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_unbounded_array%2Fvalue.cc?ref=608a080c3f6e5a8338ff99658b27e226cbba7a67", "patch": "@@ -44,13 +44,17 @@ void test01()\n   static_assert(test_category<is_unbounded_array, ClassType[]>(true), \"\");\n   static_assert(test_category<is_unbounded_array, ClassType[2][3]>(false), \"\");\n   static_assert(test_category<is_unbounded_array, ClassType[][3]>(true), \"\");\n+  static_assert(test_category<is_unbounded_array, IncompleteClass[2][3]>(false), \"\");\n+  static_assert(test_category<is_unbounded_array, IncompleteClass[][3]>(true), \"\");\n   static_assert(test_category<is_unbounded_array, int(*)[2]>(false), \"\");\n   static_assert(test_category<is_unbounded_array, int(*)[]>(false), \"\");\n   static_assert(test_category<is_unbounded_array, int(&)[2]>(false), \"\");\n   static_assert(test_category<is_unbounded_array, int(&)[]>(false), \"\");\n \n   // Sanity check.\n   static_assert(test_category<is_unbounded_array, ClassType>(false), \"\");\n+  static_assert(test_category<is_unbounded_array, IncompleteClass>(false), \"\");\n+  static_assert(test_category<is_unbounded_array, IncompleteUnion>(false), \"\");\n }\n \n template <class... T> void pos()"}, {"sha": "54df151e0255e2b19363e4f3e08a38d44fa515dc", "filename": "libstdc++-v3/testsuite/20_util/is_union/value.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_union%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_union%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_union%2Fvalue.cc?ref=608a080c3f6e5a8338ff99658b27e226cbba7a67", "patch": "@@ -27,6 +27,7 @@ void test01()\n \n   // Positive tests.\n   static_assert(test_category<is_union, UnionType>(true), \"\");\n+  static_assert(test_category<is_union, IncompleteUnion>(true), \"\");\n \n   // Negative tests.\n   static_assert(test_category<is_union, ClassType>(false), \"\");\n@@ -47,4 +48,5 @@ void test01()\n   static_assert(test_category<is_union, int (ClassType::*) (int)>(false), \"\");\n   static_assert(test_category<is_union, int (int)>(false), \"\");\n   static_assert(test_category<is_union, EnumType>(false), \"\");\n+  static_assert(test_category<is_union, IncompleteClass>(false), \"\");\n }"}, {"sha": "dc116f7ad098123016b5e0785cfb5dc3c50da99c", "filename": "libstdc++-v3/testsuite/20_util/is_void/value.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_void%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_void%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_void%2Fvalue.cc?ref=608a080c3f6e5a8338ff99658b27e226cbba7a67", "patch": "@@ -47,4 +47,6 @@ void test01()\n \n   // Sanity check.\n   static_assert(test_category<is_void, ClassType>(false), \"\");\n+  static_assert(test_category<is_void, IncompleteClass>(false), \"\");\n+  static_assert(test_category<is_void, IncompleteUnion>(false), \"\");\n }"}, {"sha": "2e1cbb096b0f978f7645c58b3e0aaab842c56413", "filename": "libstdc++-v3/testsuite/util/testsuite_tr1.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_tr1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/608a080c3f6e5a8338ff99658b27e226cbba7a67/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_tr1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_tr1.h?ref=608a080c3f6e5a8338ff99658b27e226cbba7a67", "patch": "@@ -126,6 +126,8 @@ namespace __gnu_test\n \n   union UnionType { };\n \n+  union IncompleteUnion;\n+\n   class IncompleteClass;\n \n   struct ExplicitClass"}]}