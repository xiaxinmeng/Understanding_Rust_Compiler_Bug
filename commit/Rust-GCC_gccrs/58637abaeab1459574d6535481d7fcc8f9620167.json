{"sha": "58637abaeab1459574d6535481d7fcc8f9620167", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg2MzdhYmFlYWIxNDU5NTc0ZDY1MzU0ODFkN2ZjYzhmOTYyMDE2Nw==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-31T11:26:33Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-31T12:31:58Z"}, "message": "Add type resolution for qualified-type-paths\n\nQualified type paths are similar to qualified path expressions, in that\nthey must resolve the projection of the trait onto a type to receive the\ncorrect associated type information.", "tree": {"sha": "74750b724153748468cb93c4051454368c5e959c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74750b724153748468cb93c4051454368c5e959c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58637abaeab1459574d6535481d7fcc8f9620167", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58637abaeab1459574d6535481d7fcc8f9620167", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58637abaeab1459574d6535481d7fcc8f9620167", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58637abaeab1459574d6535481d7fcc8f9620167/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e7108c3582f772c28864bd08934b00dfa3539fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e7108c3582f772c28864bd08934b00dfa3539fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e7108c3582f772c28864bd08934b00dfa3539fd"}], "stats": {"total": 350, "additions": 284, "deletions": 66}, "files": [{"sha": "64b9247de8d72e7e24802cac44041f206bef3ab3", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58637abaeab1459574d6535481d7fcc8f9620167/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58637abaeab1459574d6535481d7fcc8f9620167/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=58637abaeab1459574d6535481d7fcc8f9620167", "patch": "@@ -83,6 +83,7 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check-util.o \\\n     rust/rust-hir-trait-resolve.o \\\n     rust/rust-hir-const-fold.o \\\n+    rust/rust-hir-type-check-type.o \\\n     rust/rust-lint-marklive.o \\\n     rust/rust-hir-type-check-path.o \\\n     $(END)"}, {"sha": "dd03499092dfc6d3b1ecffc9db9f01c15d4be23e", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58637abaeab1459574d6535481d7fcc8f9620167/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58637abaeab1459574d6535481d7fcc8f9620167/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=58637abaeab1459574d6535481d7fcc8f9620167", "patch": "@@ -0,0 +1,229 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+TypeCheckType::visit (HIR::TypePath &path)\n+{\n+  // lookup the Node this resolves to\n+  NodeId ref;\n+  auto nid = path.get_mappings ().get_nodeid ();\n+  if (!resolver->lookup_resolved_type (nid, &ref))\n+    {\n+      rust_fatal_error (path.get_locus (), \"failed to resolve node '%d' to HIR\",\n+\t\t\tnid);\n+      return;\n+    }\n+\n+  HirId hir_lookup;\n+  if (!context->lookup_type_by_node_id (ref, &hir_lookup))\n+    {\n+      rust_error_at (path.get_locus (), \"failed to lookup HIR %d for node '%s'\",\n+\t\t     ref, path.as_string ().c_str ());\n+      return;\n+    }\n+\n+  TyTy::BaseType *lookup = nullptr;\n+  if (!context->lookup_type (hir_lookup, &lookup))\n+    {\n+      rust_error_at (path.get_locus (), \"failed to lookup HIR TyTy\");\n+      return;\n+    }\n+\n+  TyTy::BaseType *path_type = lookup->clone ();\n+  path_type->set_ref (path.get_mappings ().get_hirid ());\n+\n+  HIR::TypePathSegment *final_seg = path.get_final_segment ().get ();\n+  HIR::GenericArgs args = TypeCheckResolveGenericArguments::resolve (final_seg);\n+\n+  bool is_big_self = final_seg->is_ident_only ()\n+\t\t     && (final_seg->as_string ().compare (\"Self\") == 0);\n+\n+  if (path_type->needs_generic_substitutions ())\n+    {\n+      if (is_big_self)\n+\t{\n+\t  translated = path_type;\n+\t  return;\n+\t}\n+\n+      translated = SubstMapper::Resolve (path_type, path.get_locus (), &args);\n+      if (translated->get_kind () != TyTy::TypeKind::ERROR\n+\t  && mappings != nullptr)\n+\t{\n+\t  check_for_unconstrained (args.get_type_args ());\n+\t}\n+    }\n+  else if (!args.is_empty ())\n+    {\n+      rust_error_at (path.get_locus (),\n+\t\t     \"TypePath %s declares generic arguments but \"\n+\t\t     \"the type %s does not have any\",\n+\t\t     path.as_string ().c_str (),\n+\t\t     translated->as_string ().c_str ());\n+    }\n+  else\n+    {\n+      translated = path_type;\n+    }\n+}\n+\n+void\n+TypeCheckType::visit (HIR::QualifiedPathInType &path)\n+{\n+  HIR::QualifiedPathType qual_path_type = path.get_path_type ();\n+  TyTy::BaseType *root\n+    = TypeCheckType::Resolve (qual_path_type.get_type ().get ());\n+  if (root->get_kind () == TyTy::TypeKind::ERROR)\n+    {\n+      rust_debug_loc (path.get_locus (), \"failed to resolve the root\");\n+      return;\n+    }\n+\n+  if (!qual_path_type.has_as_clause ())\n+    {\n+      // then this is just a normal path-in-expression\n+      NodeId root_resolved_node_id = UNKNOWN_NODEID;\n+      bool ok = resolver->lookup_resolved_type (\n+\tqual_path_type.get_type ()->get_mappings ().get_nodeid (),\n+\t&root_resolved_node_id);\n+      rust_assert (ok);\n+\n+      resolve_segments (root_resolved_node_id, path.get_segments (), 0,\n+\t\t\ttranslated, path.get_mappings (), path.get_locus ());\n+    }\n+\n+  // Resolve the trait now\n+  TraitReference *trait_ref\n+    = TraitResolver::Resolve (*qual_path_type.get_trait ().get ());\n+  if (trait_ref->is_error ())\n+    return;\n+\n+  // does this type actually implement this type-bound?\n+  if (!TypeBoundsProbe::is_bound_satisfied_for_type (root, trait_ref))\n+    return;\n+\n+  // we need resolve to the impl block\n+  NodeId impl_resolved_id = UNKNOWN_NODEID;\n+  bool ok = resolver->lookup_resolved_name (\n+    qual_path_type.get_mappings ().get_nodeid (), &impl_resolved_id);\n+  rust_assert (ok);\n+\n+  HirId impl_block_id;\n+  ok = mappings->lookup_node_to_hir (path.get_mappings ().get_crate_num (),\n+\t\t\t\t     impl_resolved_id, &impl_block_id);\n+  rust_assert (ok);\n+\n+  AssociatedImplTrait *lookup_associated = nullptr;\n+  bool found_impl_trait\n+    = context->lookup_associated_trait_impl (impl_block_id, &lookup_associated);\n+  rust_assert (found_impl_trait);\n+\n+  DefId resolved_item_id = UNKNOWN_DEFID;\n+  std::unique_ptr<HIR::TypePathSegment> &item_seg\n+    = path.get_associated_segment ();\n+\n+  const TraitItemReference *trait_item_ref = nullptr;\n+  ok\n+    = trait_ref->lookup_trait_item (item_seg->get_ident_segment ().as_string (),\n+\t\t\t\t    &trait_item_ref);\n+  if (!ok)\n+    {\n+      rust_error_at (item_seg->get_locus (), \"unknown associated item\");\n+      return;\n+    }\n+  resolved_item_id = trait_item_ref->get_mappings ().get_defid ();\n+\n+  // project\n+  lookup_associated->setup_associated_types ();\n+\n+  translated = lookup_associated->get_projected_type (\n+    trait_item_ref, root, item_seg->get_mappings ().get_hirid (),\n+    item_seg->get_locus ());\n+\n+  if (translated->get_kind () == TyTy::TypeKind::PLACEHOLDER)\n+    {\n+      // lets grab the actual projection type\n+      TyTy::PlaceholderType *p\n+\t= static_cast<TyTy::PlaceholderType *> (translated);\n+      if (p->can_resolve ())\n+\t{\n+\t  translated = p->resolve ();\n+\t}\n+    }\n+\n+  if (item_seg->get_type () == HIR::TypePathSegment::SegmentType::GENERIC)\n+    {\n+      HIR::TypePathSegmentGeneric &generic_seg\n+\t= static_cast<HIR::TypePathSegmentGeneric &> (*item_seg.get ());\n+\n+      // turbo-fish segment path::<ty>\n+      if (generic_seg.has_generic_args ())\n+\t{\n+\t  if (!translated->can_substitute ())\n+\t    {\n+\t      rust_error_at (item_seg->get_locus (),\n+\t\t\t     \"substitutions not supported for %s\",\n+\t\t\t     translated->as_string ().c_str ());\n+\t      translated\n+\t\t= new TyTy::ErrorType (path.get_mappings ().get_hirid ());\n+\t      return;\n+\t    }\n+\t  translated = SubstMapper::Resolve (translated, path.get_locus (),\n+\t\t\t\t\t     &generic_seg.get_generic_args ());\n+\t}\n+    }\n+\n+  TyTy::ProjectionType *projection\n+    = new TyTy::ProjectionType (qual_path_type.get_mappings ().get_hirid (),\n+\t\t\t\tTyTy::TyVar (root->get_ref ()), trait_ref,\n+\t\t\t\tresolved_item_id, lookup_associated);\n+  context->insert_type (qual_path_type.get_mappings (), projection);\n+\n+  // continue on as a path-in-expression\n+  NodeId root_resolved_node_id = trait_item_ref->get_mappings ().get_nodeid ();\n+  bool fully_resolved = path.get_segments ().empty ();\n+  if (fully_resolved)\n+    {\n+      resolver->insert_resolved_name (path.get_mappings ().get_nodeid (),\n+\t\t\t\t      root_resolved_node_id);\n+      context->insert_receiver (path.get_mappings ().get_hirid (), root);\n+      return;\n+    }\n+\n+  resolve_segments (root_resolved_node_id, path.get_segments (), 0, translated,\n+\t\t    path.get_mappings (), path.get_locus ());\n+}\n+\n+void\n+TypeCheckType::resolve_segments (\n+  NodeId root_resolved_node_id,\n+  std::vector<std::unique_ptr<HIR::TypePathSegment>> &segments, size_t offset,\n+  TyTy::BaseType *tyseg, const Analysis::NodeMapping &expr_mappings,\n+  Location expr_locus)\n+{\n+  gcc_unreachable ();\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "c02a3693e206ec205d55a7b978152b7bde763533", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 8, "deletions": 66, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58637abaeab1459574d6535481d7fcc8f9620167/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58637abaeab1459574d6535481d7fcc8f9620167/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=58637abaeab1459574d6535481d7fcc8f9620167", "patch": "@@ -1,4 +1,3 @@\n-\n // Copyright (C) 2020 Free Software Foundation, Inc.\n \n // This file is part of GCC.\n@@ -117,72 +116,9 @@ class TypeCheckType : public TypeCheckBase\n       = new TyTy::TupleType (tuple.get_mappings ().get_hirid (), fields);\n   }\n \n-  void visit (HIR::TypePath &path) override\n-  {\n-    // lookup the Node this resolves to\n-    NodeId ref;\n-    auto nid = path.get_mappings ().get_nodeid ();\n-    if (!resolver->lookup_resolved_type (nid, &ref))\n-      {\n-\trust_fatal_error (path.get_locus (),\n-\t\t\t  \"failed to resolve node '%d' to HIR\", nid);\n-\treturn;\n-      }\n-\n-    HirId hir_lookup;\n-    if (!context->lookup_type_by_node_id (ref, &hir_lookup))\n-      {\n-\trust_error_at (path.get_locus (),\n-\t\t       \"failed to lookup HIR %d for node '%s'\", ref,\n-\t\t       path.as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    TyTy::BaseType *lookup = nullptr;\n-    if (!context->lookup_type (hir_lookup, &lookup))\n-      {\n-\trust_error_at (path.get_locus (), \"failed to lookup HIR TyTy\");\n-\treturn;\n-      }\n-\n-    TyTy::BaseType *path_type = lookup->clone ();\n-    path_type->set_ref (path.get_mappings ().get_hirid ());\n-\n-    HIR::TypePathSegment *final_seg = path.get_final_segment ().get ();\n-    HIR::GenericArgs args\n-      = TypeCheckResolveGenericArguments::resolve (final_seg);\n+  void visit (HIR::TypePath &path) override;\n \n-    bool is_big_self = final_seg->is_ident_only ()\n-\t\t       && (final_seg->as_string ().compare (\"Self\") == 0);\n-\n-    if (path_type->needs_generic_substitutions ())\n-      {\n-\tif (is_big_self)\n-\t  {\n-\t    translated = path_type;\n-\t    return;\n-\t  }\n-\n-\ttranslated = SubstMapper::Resolve (path_type, path.get_locus (), &args);\n-\tif (translated->get_kind () != TyTy::TypeKind::ERROR\n-\t    && mappings != nullptr)\n-\t  {\n-\t    check_for_unconstrained (args.get_type_args ());\n-\t  }\n-      }\n-    else if (!args.is_empty ())\n-      {\n-\trust_error_at (path.get_locus (),\n-\t\t       \"TypePath %s declares generic arguments but \"\n-\t\t       \"the type %s does not have any\",\n-\t\t       path.as_string ().c_str (),\n-\t\t       translated->as_string ().c_str ());\n-      }\n-    else\n-      {\n-\ttranslated = path_type;\n-      }\n-  }\n+  void visit (HIR::QualifiedPathInType &path) override;\n \n   void visit (HIR::ArrayType &type) override;\n \n@@ -246,6 +182,12 @@ class TypeCheckType : public TypeCheckBase\n       }\n   }\n \n+  void resolve_segments (\n+    NodeId root_resolved_node_id,\n+    std::vector<std::unique_ptr<HIR::TypePathSegment>> &segments, size_t offset,\n+    TyTy::BaseType *tyseg, const Analysis::NodeMapping &expr_mappings,\n+    Location expr_locus);\n+\n   std::vector<TyTy::SubstitutionParamMapping> *subst_mappings;\n   TyTy::BaseType *translated;\n };"}, {"sha": "a55b965baf0bffae71889072696c8cda0457817b", "filename": "gcc/testsuite/rust/compile/torture/traits12.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58637abaeab1459574d6535481d7fcc8f9620167/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits12.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58637abaeab1459574d6535481d7fcc8f9620167/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits12.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits12.rs?ref=58637abaeab1459574d6535481d7fcc8f9620167", "patch": "@@ -0,0 +1,29 @@\n+trait Foo {\n+    type A;\n+\n+    fn test(a: Self::A) -> Self::A {\n+        a\n+    }\n+}\n+\n+struct Bar(i32);\n+// { dg-warning \"struct is never constructed\" \"\" { target *-*-* } .-1 }\n+\n+impl Foo for Bar {\n+    type A = i32;\n+}\n+\n+struct Baz(f32);\n+// { dg-warning \"struct is never constructed\" \"\" { target *-*-* } .-1 }\n+\n+impl Foo for Baz {\n+    type A = f32;\n+}\n+\n+fn main() {\n+    let a: <Baz as Foo>::A;\n+    a = 123f32;\n+\n+    let b;\n+    b = <Baz as Foo>::test(a);\n+}"}, {"sha": "326f03907567fcb83062879ed1d8a210b7de4773", "filename": "gcc/testsuite/rust/compile/torture/traits13.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58637abaeab1459574d6535481d7fcc8f9620167/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits13.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58637abaeab1459574d6535481d7fcc8f9620167/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits13.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits13.rs?ref=58637abaeab1459574d6535481d7fcc8f9620167", "patch": "@@ -0,0 +1,17 @@\n+trait Trait {\n+    const FOO: usize;\n+    type Target;\n+}\n+\n+struct S;\n+// { dg-warning \"struct is never constructed\" \"\" { target *-*-* } .-1 }\n+\n+impl Trait for S {\n+    const FOO: usize = 0;\n+    type Target = usize;\n+}\n+\n+fn main() {\n+    let a: <S as Trait>::Target;\n+    a = <S as Trait>::FOO;\n+}"}]}