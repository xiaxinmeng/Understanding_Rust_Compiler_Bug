{"sha": "58d94a32b4cfe6065b736cac38f73d9a8deaa5d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThkOTRhMzJiNGNmZTYwNjViNzM2Y2FjMzhmNzNkOWE4ZGVhYTVkNA==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2020-05-07T14:08:03Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-06T11:35:24Z"}, "message": "[Ada] Use Stream_Element_Arrays internally for secure hash computations\n\ngcc/ada/\n\n\t* libgnat/g-sechas.ads, libgnat/g-sechas.adb: Refactor to use\n\tStream_Element_Array as the internal buffer type.\n\t* libgnat/g-shshco.adb: Adjust to use Stream_Element_Offset\n\tinstead of Integer as the index in the internal state buffer.", "tree": {"sha": "11a871ea97e9ba3bc63c3c6afd286e3143c9549c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11a871ea97e9ba3bc63c3c6afd286e3143c9549c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58d94a32b4cfe6065b736cac38f73d9a8deaa5d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58d94a32b4cfe6065b736cac38f73d9a8deaa5d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58d94a32b4cfe6065b736cac38f73d9a8deaa5d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58d94a32b4cfe6065b736cac38f73d9a8deaa5d4/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aaa3a6753574594b73746ddaf6e3b4e042a6a586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaa3a6753574594b73746ddaf6e3b4e042a6a586", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaa3a6753574594b73746ddaf6e3b4e042a6a586"}], "stats": {"total": 159, "additions": 84, "deletions": 75}, "files": [{"sha": "bd9757174d7343ebe075489463fd6dad1dd61967", "filename": "gcc/ada/libgnat/g-sechas.adb", "status": "modified", "additions": 68, "deletions": 60, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58d94a32b4cfe6065b736cac38f73d9a8deaa5d4/gcc%2Fada%2Flibgnat%2Fg-sechas.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58d94a32b4cfe6065b736cac38f73d9a8deaa5d4/gcc%2Fada%2Flibgnat%2Fg-sechas.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-sechas.adb?ref=58d94a32b4cfe6065b736cac38f73d9a8deaa5d4", "patch": "@@ -40,25 +40,25 @@ package body GNAT.Secure_Hashes is\n    type Fill_Buffer_Access is\n      access procedure\n        (M     : in out Message_State;\n-        S     : String;\n-        First : Natural;\n-        Last  : out Natural);\n-   --  A procedure to transfer data from S, starting at First, into M's block\n+        SEA   : Stream_Element_Array;\n+        First : Stream_Element_Offset;\n+        Last  : out Stream_Element_Offset);\n+   --  A procedure to transfer data from SEA, starting at First, into M's block\n    --  buffer until either the block buffer is full or all data from S has been\n    --  consumed.\n \n    procedure Fill_Buffer_Copy\n      (M     : in out Message_State;\n-      S     : String;\n-      First : Natural;\n-      Last  : out Natural);\n+      SEA   : Stream_Element_Array;\n+      First : Stream_Element_Offset;\n+      Last  : out Stream_Element_Offset);\n    --  Transfer procedure which just copies data from S to M\n \n    procedure Fill_Buffer_Swap\n      (M     : in out Message_State;\n-      S     : String;\n-      First : Natural;\n-      Last  : out Natural);\n+      SEA   : Stream_Element_Array;\n+      First : Stream_Element_Offset;\n+      Last  : out Stream_Element_Offset);\n    --  Transfer procedure which swaps bytes from S when copying into M. S must\n    --  have even length. Note that the swapping is performed considering pairs\n    --  starting at S'First, even if S'First /= First (that is, if\n@@ -75,22 +75,23 @@ package body GNAT.Secure_Hashes is\n \n    procedure Fill_Buffer_Copy\n      (M     : in out Message_State;\n-      S     : String;\n-      First : Natural;\n-      Last  : out Natural)\n+      SEA   : Stream_Element_Array;\n+      First : Stream_Element_Offset;\n+      Last  : out Stream_Element_Offset)\n    is\n-      Buf_String : String (M.Buffer'Range);\n-      for Buf_String'Address use M.Buffer'Address;\n-      pragma Import (Ada, Buf_String);\n+      Buf_SEA : Stream_Element_Array (M.Buffer'Range);\n+      for Buf_SEA'Address use M.Buffer'Address;\n+      pragma Import (Ada, Buf_SEA);\n \n-      Length : constant Natural :=\n-                 Natural'Min (M.Block_Length - M.Last, S'Last - First + 1);\n+      Length : constant Stream_Element_Offset :=\n+                 Stream_Element_Offset'Min\n+                    (M.Block_Length - M.Last, SEA'Last - First + 1);\n \n    begin\n       pragma Assert (Length > 0);\n \n-      Buf_String (M.Last + 1 .. M.Last + Length) :=\n-        S (First .. First + Length - 1);\n+      Buf_SEA (M.Last + 1 .. M.Last + Length) :=\n+        SEA (First .. First + Length - 1);\n       M.Last := M.Last + Length;\n       Last := First + Length - 1;\n    end Fill_Buffer_Copy;\n@@ -101,20 +102,21 @@ package body GNAT.Secure_Hashes is\n \n    procedure Fill_Buffer_Swap\n      (M     : in out Message_State;\n-      S     : String;\n-      First : Natural;\n-      Last  : out Natural)\n+      SEA   : Stream_Element_Array;\n+      First : Stream_Element_Offset;\n+      Last  : out Stream_Element_Offset)\n    is\n-      pragma Assert (S'Length mod 2 = 0);\n-      Length : constant Natural :=\n-                  Natural'Min (M.Block_Length - M.Last, S'Last - First + 1);\n+      pragma Assert (SEA'Length mod 2 = 0);\n+      Length : constant Stream_Element_Offset :=\n+                  Stream_Element_Offset'Min\n+                     (M.Block_Length - M.Last, SEA'Last - First + 1);\n    begin\n       Last := First;\n       while Last - First < Length loop\n          M.Buffer (M.Last + 1 + Last - First) :=\n-           (if (Last - S'First) mod 2 = 0\n-            then S (Last + 1)\n-            else S (Last - 1));\n+           (if (Last - SEA'First) mod 2 = 0\n+            then SEA (Last + 1)\n+            else SEA (Last - 1));\n          Last := Last + 1;\n       end loop;\n       M.Last := M.Last + Length;\n@@ -146,7 +148,7 @@ package body GNAT.Secure_Hashes is\n \n       procedure Update\n         (C           : in out Context;\n-         S           : String;\n+         SEA         : Stream_Element_Array;\n          Fill_Buffer : Fill_Buffer_Access);\n       --  Internal common routine for all Update procedures\n \n@@ -161,8 +163,7 @@ package body GNAT.Secure_Hashes is\n       ------------\n \n       function Digest (C : Context) return Message_Digest is\n-         Hash_Bits : Stream_Element_Array\n-                       (1 .. Stream_Element_Offset (Hash_Length));\n+         Hash_Bits : Stream_Element_Array (1 .. Hash_Length);\n       begin\n          Final (C, Hash_Bits);\n          return MD : Message_Digest do\n@@ -185,8 +186,7 @@ package body GNAT.Secure_Hashes is\n       end Digest;\n \n       function Digest (C : Context) return Binary_Message_Digest is\n-         Hash_Bits : Stream_Element_Array\n-                       (1 .. Stream_Element_Offset (Hash_Length));\n+         Hash_Bits : Stream_Element_Array (1 .. Hash_Length);\n       begin\n          Final (C, Hash_Bits);\n          return Hash_Bits;\n@@ -223,25 +223,25 @@ package body GNAT.Secure_Hashes is\n       is\n          FC : Context := C;\n \n-         Zeroes : Natural;\n+         Zeroes : Stream_Element_Count;\n          --  Number of 0 bytes in padding\n \n          Message_Length : Unsigned_64 := FC.M_State.Length;\n          --  Message length in bytes\n \n-         Size_Length : constant Natural :=\n+         Size_Length : constant Stream_Element_Count :=\n                          2 * Hash_State.Word'Size / 8;\n          --  Length in bytes of the size representation\n \n       begin\n          Zeroes := (Block_Length - 1 - Size_Length - FC.M_State.Last)\n                      mod FC.M_State.Block_Length;\n          declare\n-            Pad : String (1 .. 1 + Zeroes + Size_Length) :=\n-                    (1 => Character'Val (128), others => ASCII.NUL);\n+            Pad : Stream_Element_Array (1 .. 1 + Zeroes + Size_Length) :=\n+                    (1 => 128, others => 0);\n \n-            Index       : Natural;\n-            First_Index : Natural;\n+            Index       : Stream_Element_Offset;\n+            First_Index : Stream_Element_Offset;\n \n          begin\n             First_Index := (if Hash_Bit_Order = Low_Order_First\n@@ -255,12 +255,12 @@ package body GNAT.Secure_Hashes is\n                   --  Message_Length is in bytes, but we need to store it as\n                   --  a bit count.\n \n-                  Pad (Index) := Character'Val\n+                  Pad (Index) := Stream_Element\n                                    (Shift_Left (Message_Length and 16#1f#, 3));\n                   Message_Length := Shift_Right (Message_Length, 5);\n \n                else\n-                  Pad (Index) := Character'Val (Message_Length and 16#ff#);\n+                  Pad (Index) := Stream_Element (Message_Length and 16#ff#);\n                   Message_Length := Shift_Right (Message_Length, 8);\n                end if;\n \n@@ -308,7 +308,7 @@ package body GNAT.Secure_Hashes is\n \n          return C : Context (KL => (if Key'Length <= Key_Length'Last\n                                     then Key'Length\n-                                    else Stream_Element_Offset (Hash_Length)))\n+                                    else Hash_Length))\n          do\n             --  Set Key (if longer than block length, first hash it)\n \n@@ -361,30 +361,37 @@ package body GNAT.Secure_Hashes is\n \n       procedure Update\n         (C           : in out Context;\n-         S           : String;\n+         SEA         : Stream_Element_Array;\n          Fill_Buffer : Fill_Buffer_Access)\n       is\n-         Last : Natural;\n+         First, Last : Stream_Element_Offset;\n \n       begin\n-         C.M_State.Length := C.M_State.Length + S'Length;\n+         if SEA'Length = 0 then\n+            return;\n+         end if;\n+\n+         C.M_State.Length := C.M_State.Length + SEA'Length;\n \n-         Last := S'First - 1;\n-         while Last < S'Last loop\n-            Fill_Buffer (C.M_State, S, Last + 1, Last);\n+         First := SEA'First;\n+         loop\n+            Fill_Buffer (C.M_State, SEA, First, Last);\n \n             if C.M_State.Last = Block_Length then\n                Transform (C.H_State, C.M_State);\n                C.M_State.Last := 0;\n             end if;\n+\n+            exit when Last = SEA'Last;\n+            First := Last + 1;\n          end loop;\n       end Update;\n \n       ------------\n       -- Update --\n       ------------\n \n-      procedure Update (C : in out Context; Input : String) is\n+      procedure Update (C : in out Context; Input : Stream_Element_Array) is\n       begin\n          Update (C, Input, Fill_Buffer_Copy'Access);\n       end Update;\n@@ -393,25 +400,26 @@ package body GNAT.Secure_Hashes is\n       -- Update --\n       ------------\n \n-      procedure Update (C : in out Context; Input : Stream_Element_Array) is\n-         S : String (1 .. Input'Length);\n-         for S'Address use Input'Address;\n-         pragma Import (Ada, S);\n+      procedure Update (C : in out Context; Input : String) is\n+         pragma Assert (Input'Length <= Stream_Element_Offset'Last);\n+         SEA : Stream_Element_Array (1 .. Input'Length);\n+         for SEA'Address use Input'Address;\n+         pragma Import (Ada, SEA);\n       begin\n-         Update (C, S, Fill_Buffer_Copy'Access);\n+         Update (C, SEA, Fill_Buffer_Copy'Access);\n       end Update;\n \n       -----------------\n       -- Wide_Update --\n       -----------------\n \n       procedure Wide_Update (C : in out Context; Input : Wide_String) is\n-         S : String (1 .. 2 * Input'Length);\n-         for S'Address use Input'Address;\n-         pragma Import (Ada, S);\n+         SEA : Stream_Element_Array (1 .. 2 * Input'Length);\n+         for SEA'Address use Input'Address;\n+         pragma Import (Ada, SEA);\n       begin\n          Update\n-           (C, S,\n+           (C, SEA,\n             (if System.Default_Bit_Order /= Low_Order_First\n              then Fill_Buffer_Swap'Access\n              else Fill_Buffer_Copy'Access));\n@@ -460,7 +468,7 @@ package body GNAT.Secure_Hashes is\n       -------------\n \n       procedure To_Hash (H : State; H_Bits : out Stream_Element_Array) is\n-         Hash_Words : constant Natural := H'Size / Word'Size;\n+         Hash_Words : constant Stream_Element_Offset := H'Size / Word'Size;\n          Result     : State (1 .. Hash_Words) :=\n                         H (H'Last - Hash_Words + 1 .. H'Last);\n "}, {"sha": "2edc2e358ac3fda92f7f518b0bf60bbf1894bbcc", "filename": "gcc/ada/libgnat/g-sechas.ads", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58d94a32b4cfe6065b736cac38f73d9a8deaa5d4/gcc%2Fada%2Flibgnat%2Fg-sechas.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58d94a32b4cfe6065b736cac38f73d9a8deaa5d4/gcc%2Fada%2Flibgnat%2Fg-sechas.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-sechas.ads?ref=58d94a32b4cfe6065b736cac38f73d9a8deaa5d4", "patch": "@@ -44,16 +44,16 @@ with System;\n \n package GNAT.Secure_Hashes is\n \n-   type Buffer_Type is new String;\n+   type Buffer_Type is new Stream_Element_Array;\n    for Buffer_Type'Alignment use 8;\n    --  Secure hash functions use a string buffer that is also accessed as an\n    --  array of words, which may require up to 64 bit alignment.\n \n    --  The function-independent part of processing state: A buffer of data\n    --  being accumulated until a complete block is ready for hashing.\n \n-   type Message_State (Block_Length : Natural) is record\n-      Last : Natural := 0;\n+   type Message_State (Block_Length : Stream_Element_Count) is record\n+      Last : Stream_Element_Offset := 0;\n       --  Index of last used element in Buffer\n \n       Length : Interfaces.Unsigned_64 := 0;\n@@ -81,7 +81,7 @@ package GNAT.Secure_Hashes is\n \n    package Hash_Function_State is\n \n-      type State is array (Natural range <>) of Word;\n+      type State is array (Stream_Element_Offset range <>) of Word;\n       --  Used to store a hash function's internal state\n \n       procedure To_Hash\n@@ -97,13 +97,13 @@ package GNAT.Secure_Hashes is\n    --  secure hash function is an instance of this generic package.\n \n    generic\n-      Block_Words : Natural;\n+      Block_Words : Stream_Element_Count;\n       --  Number of words in each block\n \n-      State_Words : Natural;\n+      State_Words : Stream_Element_Count;\n       --  Number of words in internal state\n \n-      Hash_Words : Natural;\n+      Hash_Words : Stream_Element_Count;\n       --  Number of words in the final hash (must be no greater than\n       --  State_Words).\n \n@@ -157,11 +157,10 @@ package GNAT.Secure_Hashes is\n       --  the Wide_String version, each Wide_Character is processed low order\n       --  byte first.\n \n-      Word_Length : constant Natural := Hash_State.Word'Size / 8;\n-      Hash_Length : constant Natural := Hash_Words * Word_Length;\n+      Word_Length : constant Stream_Element_Offset := Hash_State.Word'Size / 8;\n+      Hash_Length : constant Stream_Element_Offset := Hash_Words * Word_Length;\n \n-      subtype Binary_Message_Digest is\n-        Stream_Element_Array (1 .. Stream_Element_Offset (Hash_Length));\n+      subtype Binary_Message_Digest is Stream_Element_Array (1 .. Hash_Length);\n       --  The fixed-length byte array returned by Digest, providing\n       --  the hash in binary representation.\n \n@@ -176,7 +175,7 @@ package GNAT.Secure_Hashes is\n       --  Wide_Update) on a default initialized Context, followed by Digest\n       --  on the resulting Context.\n \n-      subtype Message_Digest is String (1 .. 2 * Hash_Length);\n+      subtype Message_Digest is String (1 .. 2 * Integer (Hash_Length));\n       --  The fixed-length string returned by Digest, providing the hash in\n       --  hexadecimal representation.\n \n@@ -199,11 +198,12 @@ package GNAT.Secure_Hashes is\n \n    private\n \n-      Block_Length : constant Natural := Block_Words * Word_Length;\n+      Block_Length : constant Stream_Element_Count :=\n+         Block_Words * Word_Length;\n       --  Length in bytes of a data block\n \n       subtype Key_Length is\n-        Stream_Element_Offset range 0 .. Stream_Element_Offset (Block_Length);\n+        Stream_Element_Offset range 0 .. Block_Length;\n \n       --  KL is 0 for a normal hash context, > 0 for HMAC\n "}, {"sha": "89e27f087dffe427313f01ba4d1f7d8fd1c3210f", "filename": "gcc/ada/libgnat/g-shshco.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58d94a32b4cfe6065b736cac38f73d9a8deaa5d4/gcc%2Fada%2Flibgnat%2Fg-shshco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58d94a32b4cfe6065b736cac38f73d9a8deaa5d4/gcc%2Fada%2Flibgnat%2Fg-shshco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-shshco.adb?ref=58d94a32b4cfe6065b736cac38f73d9a8deaa5d4", "patch": "@@ -108,7 +108,8 @@ package body GNAT.Secure_Hashes.SHA2_Common is\n       --  3. Perform transformation rounds\n \n       for T in 0 .. Rounds - 1 loop\n-         T1 := H + Sigma1 (E) + Ch (E, F, G) + K (T) + W (T);\n+         T1 := H + Sigma1 (E) + Ch (E, F, G)\n+             + K (Stream_Element_Offset (T)) + W (T);\n          T2 := Sigma0 (A) + Maj (A, B, C);\n          H := G;\n          G := F;"}]}