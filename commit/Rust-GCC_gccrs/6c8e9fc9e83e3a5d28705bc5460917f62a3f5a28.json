{"sha": "6c8e9fc9e83e3a5d28705bc5460917f62a3f5a28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM4ZTlmYzllODNlM2E1ZDI4NzA1YmM1NDYwOTE3ZjYyYTNmNWEyOA==", "commit": {"author": {"name": "Alexander Monakov", "email": "amonakov@ispras.ru", "date": "2011-06-08T09:59:23Z"}, "committer": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2011-06-08T09:59:23Z"}, "message": "re PR rtl-optimization/49303 (ICE: vinsn_detach, at sel-sched-ir.c:1277 w/ -O3 on ia64 in r174558)\n\n\tPR rtl-optimization/49303\n\t* sel-sched.c (move_op): Use correct type for 'res'.  Verify that\n\tcode_motion_path_driver returned 0 or 1.\n\t(sel_region_finish): Clear h_d_i_d.\n\ntestsuite:\n\t* gcc.target/ia64/pr49303.c: New test.\n\nFrom-SVN: r174801", "tree": {"sha": "ca536f735bdbfe3960e007f1ab9a9c984da784a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca536f735bdbfe3960e007f1ab9a9c984da784a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c8e9fc9e83e3a5d28705bc5460917f62a3f5a28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c8e9fc9e83e3a5d28705bc5460917f62a3f5a28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c8e9fc9e83e3a5d28705bc5460917f62a3f5a28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c8e9fc9e83e3a5d28705bc5460917f62a3f5a28/comments", "author": {"login": "amonakov", "id": 1997391, "node_id": "MDQ6VXNlcjE5OTczOTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1997391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amonakov", "html_url": "https://github.com/amonakov", "followers_url": "https://api.github.com/users/amonakov/followers", "following_url": "https://api.github.com/users/amonakov/following{/other_user}", "gists_url": "https://api.github.com/users/amonakov/gists{/gist_id}", "starred_url": "https://api.github.com/users/amonakov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amonakov/subscriptions", "organizations_url": "https://api.github.com/users/amonakov/orgs", "repos_url": "https://api.github.com/users/amonakov/repos", "events_url": "https://api.github.com/users/amonakov/events{/privacy}", "received_events_url": "https://api.github.com/users/amonakov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0bad0e237a165500108ae56d06a1f1ae91bae5fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bad0e237a165500108ae56d06a1f1ae91bae5fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bad0e237a165500108ae56d06a1f1ae91bae5fd"}], "stats": {"total": 202, "additions": 201, "deletions": 1}, "files": [{"sha": "294e5d7a5a9cb4ae842c1db8333bac2f2b12ebe0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c8e9fc9e83e3a5d28705bc5460917f62a3f5a28/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c8e9fc9e83e3a5d28705bc5460917f62a3f5a28/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c8e9fc9e83e3a5d28705bc5460917f62a3f5a28", "patch": "@@ -1,3 +1,10 @@\n+2011-06-08  Alexander Monakov  <amonakov@ispras.ru>\n+\n+\tPR rtl-optimization/49303\n+\t* sel-sched.c (move_op): Use correct type for 'res'.  Verify that\n+\tcode_motion_path_driver returned 0 or 1.\n+\t(sel_region_finish): Clear h_d_i_d.\n+\n 2011-06-08  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh.c (prepare_move_operands): Set pic register"}, {"sha": "8a39d80d2506adfbccba03d0e96d56234ba8b83d", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c8e9fc9e83e3a5d28705bc5460917f62a3f5a28/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c8e9fc9e83e3a5d28705bc5460917f62a3f5a28/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=6c8e9fc9e83e3a5d28705bc5460917f62a3f5a28", "patch": "@@ -6675,7 +6675,7 @@ move_op (insn_t insn, av_set_t orig_ops, expr_t expr_vliw,\n {\n   struct moveop_static_params sparams;\n   struct cmpd_local_params lparams;\n-  bool res;\n+  int res;\n \n   /* Init params for code_motion_path_driver.  */\n   sparams.dest = dest;\n@@ -6694,6 +6694,8 @@ move_op (insn_t insn, av_set_t orig_ops, expr_t expr_vliw,\n   code_motion_path_driver_info = &move_op_hooks;\n   res = code_motion_path_driver (insn, orig_ops, NULL, &lparams, &sparams);\n \n+  gcc_assert (res != -1);\n+\n   if (sparams.was_renamed)\n     EXPR_WAS_RENAMED (expr_vliw) = true;\n \n@@ -7269,6 +7271,7 @@ sel_region_finish (bool reset_sched_cycles_p)\n \n   finish_deps_global ();\n   sched_finish_luids ();\n+  VEC_free (haifa_deps_insn_data_def, heap, h_d_i_d);\n \n   sel_finish_bbs ();\n   BITMAP_FREE (blocks_to_reschedule);"}, {"sha": "5142ccb3223b169517fd7e76b8746de3975b1b32", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c8e9fc9e83e3a5d28705bc5460917f62a3f5a28/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c8e9fc9e83e3a5d28705bc5460917f62a3f5a28/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6c8e9fc9e83e3a5d28705bc5460917f62a3f5a28", "patch": "@@ -1,3 +1,8 @@\n+2011-06-08  Alexander Monakov  <amonakov@ispras.ru>\n+\n+\tPR rtl-optimization/49303\n+\t* gcc.target/ia64/pr49303.c: New test.\n+\n 2011-06-08  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/18918"}, {"sha": "2d88304f83ecf30381a91ce9276ed4ee0c5e9f5e", "filename": "gcc/testsuite/gcc.target/ia64/pr49303.c", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c8e9fc9e83e3a5d28705bc5460917f62a3f5a28/gcc%2Ftestsuite%2Fgcc.target%2Fia64%2Fpr49303.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c8e9fc9e83e3a5d28705bc5460917f62a3f5a28/gcc%2Ftestsuite%2Fgcc.target%2Fia64%2Fpr49303.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fia64%2Fpr49303.c?ref=6c8e9fc9e83e3a5d28705bc5460917f62a3f5a28", "patch": "@@ -0,0 +1,185 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-w -O2 -fselective-scheduling2 -fsel-sched-pipelining\" } */\n+\n+typedef struct rtx_def *rtx;\n+typedef const struct rtx_def *const_rtx;\n+typedef struct basic_block_def *basic_block;\n+enum machine_mode {\n+  VOIDmode, BLKmode, CCmode, CCImode, BImode, QImode, HImode, SImode, DImode, TImode, OImode, QQmode, HQmode, SQmode, DQmode, TQmode, UQQmode, UHQmode, USQmode, UDQmode, UTQmode, HAmode, SAmode, DAmode, TAmode, UHAmode, USAmode, UDAmode, UTAmode, SFmode, DFmode, XFmode, RFmode, TFmode, SDmode, DDmode, TDmode, CQImode, CHImode, CSImode, CDImode, CTImode, COImode, SCmode, DCmode, XCmode, RCmode, TCmode, V4QImode, V2HImode, V8QImode, V4HImode, V2SImode, V16QImode, V8HImode, V4SImode, V2SFmode, V4SFmode, MAX_MACHINE_MODE, MIN_MODE_RANDOM = VOIDmode, MAX_MODE_RANDOM = BLKmode, MIN_MODE_CC = CCmode, MAX_MODE_CC = CCImode, MIN_MODE_INT = QImode, MAX_MODE_INT = OImode, MIN_MODE_PARTIAL_INT = VOIDmode, MAX_MODE_PARTIAL_INT = VOIDmode, MIN_MODE_FRACT = QQmode, MAX_MODE_FRACT = TQmode, MIN_MODE_UFRACT = UQQmode, MAX_MODE_UFRACT = UTQmode, MIN_MODE_ACCUM = HAmode, MAX_MODE_ACCUM = TAmode, MIN_MODE_UACCUM = UHAmode, MAX_MODE_UACCUM = UTAmode, MIN_MODE_FLOAT = SFmode, MAX_MODE_FLOAT = TFmode, MIN_MODE_DECIMAL_FLOAT = SDmode, MAX_MODE_DECIMAL_FLOAT = TDmode, MIN_MODE_COMPLEX_INT = CQImode, MAX_MODE_COMPLEX_INT = COImode, MIN_MODE_COMPLEX_FLOAT = SCmode, MAX_MODE_COMPLEX_FLOAT = TCmode, MIN_MODE_VECTOR_INT = V4QImode, MAX_MODE_VECTOR_INT = V4SImode, MIN_MODE_VECTOR_FRACT = VOIDmode, MAX_MODE_VECTOR_FRACT = VOIDmode, MIN_MODE_VECTOR_UFRACT = VOIDmode, MAX_MODE_VECTOR_UFRACT = VOIDmode, MIN_MODE_VECTOR_ACCUM = VOIDmode, MAX_MODE_VECTOR_ACCUM = VOIDmode, MIN_MODE_VECTOR_UACCUM = VOIDmode, MAX_MODE_VECTOR_UACCUM = VOIDmode, MIN_MODE_VECTOR_FLOAT = V2SFmode, MAX_MODE_VECTOR_FLOAT = V4SFmode, NUM_MACHINE_MODES = MAX_MACHINE_MODE };\n+struct real_value {\n+};\n+extern void vec_assert_fail (const char *, const char * ,const char *file_,unsigned line_,const char *function_) __attribute__ ((__noreturn__));\n+typedef struct vec_prefix {\n+  unsigned num;\n+};\n+enum rtx_code {\n+  UNKNOWN , VALUE , DEBUG_EXPR , EXPR_LIST , INSN_LIST , SEQUENCE , ADDRESS , DEBUG_INSN , INSN , JUMP_INSN , CALL_INSN , BARRIER , CODE_LABEL , NOTE , COND_EXEC , PARALLEL , ASM_INPUT , ASM_OPERANDS , UNSPEC , UNSPEC_VOLATILE , ADDR_VEC , ADDR_DIFF_VEC , PREFETCH , SET , USE , CLOBBER , CALL , RETURN , EH_RETURN , TRAP_IF , CONST_INT , CONST_FIXED , CONST_DOUBLE , CONST_VECTOR , CONST_STRING , CONST , PC , REG , SCRATCH , SUBREG , STRICT_LOW_PART , CONCAT , CONCATN , MEM , LABEL_REF , SYMBOL_REF , CC0 , IF_THEN_ELSE , COMPARE , PLUS , MINUS , NEG , MULT , SS_MULT , US_MULT , DIV , SS_DIV , US_DIV , MOD , UDIV , UMOD , AND , IOR , XOR , NOT , ASHIFT , ROTATE , ASHIFTRT , LSHIFTRT , ROTATERT , SMIN , SMAX , UMIN , UMAX , PRE_DEC , PRE_INC , POST_DEC , POST_INC , PRE_MODIFY , POST_MODIFY , NE , EQ , GE , GT , LE , LT , GEU , GTU , LEU , LTU , UNORDERED , ORDERED , UNEQ , UNGE , UNGT , UNLE , UNLT , LTGT , SIGN_EXTEND , ZERO_EXTEND , TRUNCATE , FLOAT_EXTEND , FLOAT_TRUNCATE , FLOAT , FIX , UNSIGNED_FLOAT , UNSIGNED_FIX , FRACT_CONVERT , UNSIGNED_FRACT_CONVERT , SAT_FRACT , UNSIGNED_SAT_FRACT , ABS , SQRT , BSWAP , FFS , CLZ , CTZ , POPCOUNT , PARITY , SIGN_EXTRACT , ZERO_EXTRACT , HIGH , LO_SUM , VEC_MERGE , VEC_SELECT , VEC_CONCAT , VEC_DUPLICATE , SS_PLUS , US_PLUS , SS_MINUS , SS_NEG , US_NEG , SS_ABS , SS_ASHIFT , US_ASHIFT , US_MINUS , SS_TRUNCATE , US_TRUNCATE , FMA , VAR_LOCATION , DEBUG_IMPLICIT_PTR , ENTRY_VALUE , LAST_AND_UNUSED_RTX_CODE};\n+enum rtx_class {\n+  RTX_COMPARE, RTX_COMM_COMPARE, RTX_BIN_ARITH, RTX_COMM_ARITH, RTX_UNARY, RTX_EXTRA, RTX_MATCH, RTX_INSN, RTX_OBJ, RTX_CONST_OBJ, RTX_TERNARY, RTX_BITFIELD_OPS, RTX_AUTOINC };\n+extern const enum rtx_class rtx_class[((int) LAST_AND_UNUSED_RTX_CODE)];\n+union rtunion_def {\n+  int rt_int;\n+  unsigned int rt_uint;\n+  rtx rt_rtx;\n+};\n+typedef union rtunion_def rtunion;\n+struct rtx_def {\n+  __extension__ enum rtx_code code: 16;\n+  __extension__ enum machine_mode mode : 8;\n+  unsigned int unchanging : 1;\n+  union u {\n+    rtunion fld[1];\n+  }\n+  u;\n+};\n+static __inline__ unsigned int rhs_regno (const_rtx x) {\n+  return (((x)->u.fld[0]).rt_uint);\n+}\n+struct regstat_n_sets_and_refs_t {\n+  int sets;\n+};\n+extern struct regstat_n_sets_and_refs_t *regstat_n_sets_and_refs;\n+static __inline__ int REG_N_SETS (int regno) {\n+  return regstat_n_sets_and_refs[regno].sets;\n+}\n+struct target_regs {\n+  unsigned char x_hard_regno_nregs[334][MAX_MACHINE_MODE];\n+};\n+extern struct target_regs default_target_regs;\n+static __inline__ unsigned int end_hard_regno (enum machine_mode mode, unsigned int regno) {\n+  return regno + ((&default_target_regs)->x_hard_regno_nregs)[regno][(int) mode];\n+}\n+struct function {\n+  struct eh_status *eh;\n+  struct control_flow_graph *cfg;\n+};\n+extern struct function *cfun;\n+typedef struct VEC_edge_gc {\n+}\n+VEC_edge_gc;\n+struct basic_block_def {\n+  VEC_edge_gc *preds;\n+  struct basic_block_def *next_bb;\n+  int index;\n+}\n+VEC_basic_block_gc;\n+struct control_flow_graph {\n+  basic_block x_entry_block_ptr;\n+}\n+bitmap_obstack;\n+typedef struct bitmap_element_def {\n+}\n+bitmap_element;\n+typedef struct bitmap_head_def {\n+  bitmap_element *first;\n+  bitmap_element *current;\n+}\n+bitmap_head;\n+struct dataflow {\n+  struct df_problem *problem;\n+  void *block_info;\n+  unsigned int block_info_size;\n+};\n+struct df_insn_info {\n+  int luid;\n+};\n+struct df_d {\n+  struct dataflow *problems_by_index[(7 + 1)];\n+  struct df_insn_info **insns;\n+};\n+struct df_lr_bb_info {\n+  bitmap_head def;\n+  bitmap_head in;\n+};\n+extern struct df_d *df;\n+static __inline__ struct df_lr_bb_info * df_lr_get_bb_info (unsigned int index) {\n+  if (index < (df->problems_by_index[1])->block_info_size) return &((struct df_lr_bb_info *) (df->problems_by_index[1])->block_info)[index];\n+  else return ((void *)0);\n+}\n+typedef struct reg_stat_struct {\n+  int last_set_label;\n+  unsigned long last_set_nonzero_bits;\n+  char last_set_invalid;\n+}\n+reg_stat_type;\n+typedef struct VEC_reg_stat_type_base {\n+  struct vec_prefix prefix;\n+  reg_stat_type vec[1];\n+}\n+VEC_reg_stat_type_base;\n+static __inline__ reg_stat_type *VEC_reg_stat_type_base_index (VEC_reg_stat_type_base *vec_, unsigned ix_ ,const char *file_,unsigned line_,const char *function_) {\n+  (void)((vec_ && ix_ < vec_->prefix.num) ? 0 : (vec_assert_fail (\"index\",\"VEC(reg_stat_type,base)\" ,file_,line_,function_), 0));\n+  return &vec_->vec[ix_];\n+}\n+typedef struct VEC_reg_stat_type_heap {\n+  VEC_reg_stat_type_base base;\n+}\n+VEC_reg_stat_type_heap;\n+static VEC_reg_stat_type_heap *reg_stat;\n+static int mem_last_set;\n+static int label_tick;\n+int get_last_value_validate (rtx *loc, rtx insn, int tick, int replace)\n+{\n+  rtx x = *loc;\n+  int i, j;\n+  if ((((enum rtx_code) (x)->code) == REG))\n+    {\n+      unsigned int regno = (rhs_regno(x));\n+      unsigned int endregno = (((((rhs_regno(x))) < 334)) ? end_hard_regno (((enum machine_mode) (x)->mode), (rhs_regno(x))) : (rhs_regno(x)) + 1);\n+      for (j = regno;\n+\t   j < endregno;\n+\t   j++)\n+\t{\n+\t  reg_stat_type *rsp = (VEC_reg_stat_type_base_index(((reg_stat) ? &(reg_stat)->base : 0),j ,\"/gcc/combine.c\",12640,__FUNCTION__));\n+\t  if (\n+\t      rsp->last_set_invalid\n+\t      ||\n+\t      (\n+\t       (\n+\t\tregno >= 334\n+\t\t&& REG_N_SETS (regno) == 1\n+\t\t&& (!bitmap_bit_p ((&(df_lr_get_bb_info((((cfun + 0)->cfg->x_entry_block_ptr)->next_bb)->index))->in), regno) )\n+\t       )\n+\t       && rsp->last_set_label > tick\n+\t      )\n+\t     )\n+\t    {\n+\t      return replace;\n+\t    }\n+\t}\n+    }\n+  else if ((((enum rtx_code) (x)->code) == MEM)\n+\t   &&\n+\t   (\n+\t    (\n+\t     {\n+\t     __typeof ((x)) const _rtx = ((x));\n+\t     _rtx;\n+\t     }\n+\t    )->unchanging\n+\t   )\n+\t   &&\n+\t   (\n+\t    tick != label_tick\n+\t    || ((((df->insns[((((insn)->u.fld[0]).rt_int))]))->luid)) <= mem_last_set\n+\t   )\n+\t  )\n+    {\n+\t{\n+\t  if (\n+\t      i == 1\n+\t     )\n+\t    {\n+\t      rtx x0 = (((x)->u.fld[0]).rt_rtx);\n+\t      rtx x1 = (((x)->u.fld[1]).rt_rtx);\n+\t      if ((((rtx_class[(int) (((enum rtx_code) (x1)->code))]) & (~1)) == (RTX_COMM_ARITH & (~1)))\n+\t\t  &&\n+\t\t  (\n+\t\t   x0 == (((x1)->u.fld[0]).rt_rtx)\n+\t\t  )\n+\t\t )\n+\t\treturn get_last_value_validate (&(((x1)->u.fld[x0 == (((x1)->u.fld[0]).rt_rtx) ? 1 : 0]).rt_rtx) , insn, tick, replace);\n+\t    }\n+\t}\n+    }\n+}"}]}