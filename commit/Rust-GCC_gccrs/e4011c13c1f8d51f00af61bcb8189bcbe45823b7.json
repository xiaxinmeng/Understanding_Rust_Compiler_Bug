{"sha": "e4011c13c1f8d51f00af61bcb8189bcbe45823b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQwMTFjMTNjMWY4ZDUxZjAwYWY2MWJjYjgxODliY2JlNDU4MjNiNw==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-09-12T14:26:58Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-09-12T19:34:38Z"}, "message": "d: Build TYPE_DECLs for non-numeric enum types.\n\nThis is done so that the DWARF pass will emit a DW_TAG_typedef where the\nmember type of an enum can't be represented in an ENUMERAL_TYPE.\n\ngcc/d/ChangeLog:\n\n\t* d-builtins.cc (d_build_d_type_nodes): Call build_ctype() on all\n\tbasic front-end types.\n\t* decl.cc (DeclVisitor::visit (EnumDeclaration *)): Always add decl to\n\tcurrent binding level.\n\t(build_type_decl): Build TYPE_DECL as a typedef if not for an enum or\n\trecord type.\n\t* types.cc (TypeVisitor::visit (TypeEnum *)): Set underlying type for\n\tENUMERAL_TYPEs.  Build TYPE_DECL for non-numeric enums.", "tree": {"sha": "613e7276d4ebf04ef64d1546cff0fdded9d58bd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/613e7276d4ebf04ef64d1546cff0fdded9d58bd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4011c13c1f8d51f00af61bcb8189bcbe45823b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4011c13c1f8d51f00af61bcb8189bcbe45823b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4011c13c1f8d51f00af61bcb8189bcbe45823b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4011c13c1f8d51f00af61bcb8189bcbe45823b7/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49482217e0ade3fe92ea050c01f5f7a6ddc31e95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49482217e0ade3fe92ea050c01f5f7a6ddc31e95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49482217e0ade3fe92ea050c01f5f7a6ddc31e95"}], "stats": {"total": 35, "additions": 24, "deletions": 11}, "files": [{"sha": "72e2d3a71685335ce97a3827633e25dbb9d94fa4", "filename": "gcc/d/d-builtins.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4011c13c1f8d51f00af61bcb8189bcbe45823b7/gcc%2Fd%2Fd-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4011c13c1f8d51f00af61bcb8189bcbe45823b7/gcc%2Fd%2Fd-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-builtins.cc?ref=e4011c13c1f8d51f00af61bcb8189bcbe45823b7", "patch": "@@ -848,6 +848,14 @@ d_build_d_type_nodes (void)\n   ireal_type_node = build_distinct_type_copy (long_double_type_node);\n   TYPE_IMAGINARY_FLOAT (ireal_type_node) = 1;\n \n+  /* Calling build_ctype() links the front-end Type to the GCC node,\n+     and sets the TYPE_NAME to the D language type.  */\n+  for (unsigned ty = 0; ty < TMAX; ty++)\n+    {\n+      if (Type::basic[ty] != NULL)\n+\tbuild_ctype (Type::basic[ty]);\n+    }\n+\n   /* Used for ModuleInfo, ClassInfo, and Interface decls.  */\n   unknown_type_node = make_node (RECORD_TYPE);\n "}, {"sha": "161a85a842be4769d9fa47005d05377e6c055c47", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4011c13c1f8d51f00af61bcb8189bcbe45823b7/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4011c13c1f8d51f00af61bcb8189bcbe45823b7/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=e4011c13c1f8d51f00af61bcb8189bcbe45823b7", "patch": "@@ -618,13 +618,13 @@ class DeclVisitor : public Visitor\n \t  d_linkonce_linkage (d->sinit);\n \n \td_finish_decl (d->sinit);\n-\n-\t/* Add this decl to the current binding level.  */\n-\ttree ctype = build_ctype (d->type);\n-\tif (TREE_CODE (ctype) == ENUMERAL_TYPE && TYPE_NAME (ctype))\n-\t  d_pushdecl (TYPE_NAME (ctype));\n       }\n \n+    /* Add this decl to the current binding level.  */\n+    tree ctype = build_ctype (d->type);\n+    if (TYPE_NAME (ctype))\n+      d_pushdecl (TYPE_NAME (ctype));\n+\n     d->semanticRun = PASSobj;\n   }\n \n@@ -2270,8 +2270,6 @@ build_type_decl (tree type, Dsymbol *dsym)\n   if (TYPE_STUB_DECL (type))\n     return;\n \n-  gcc_assert (!POINTER_TYPE_P (type));\n-\n   /* If a templated type, use the template instance name, as that includes all\n      template parameters.  */\n   const char *name = dsym->parent->isTemplateInstance ()\n@@ -2281,7 +2279,6 @@ build_type_decl (tree type, Dsymbol *dsym)\n \t\t\t  get_identifier (name), type);\n   SET_DECL_ASSEMBLER_NAME (decl, get_identifier (d_mangle_decl (dsym)));\n   TREE_PUBLIC (decl) = 1;\n-  DECL_ARTIFICIAL (decl) = 1;\n   DECL_CONTEXT (decl) = d_decl_context (dsym);\n \n   TYPE_CONTEXT (type) = DECL_CONTEXT (decl);\n@@ -2290,9 +2287,14 @@ build_type_decl (tree type, Dsymbol *dsym)\n   /* Not sure if there is a need for separate TYPE_DECLs in\n      TYPE_NAME and TYPE_STUB_DECL.  */\n   if (TREE_CODE (type) == ENUMERAL_TYPE || RECORD_OR_UNION_TYPE_P (type))\n-    TYPE_STUB_DECL (type) = decl;\n+    {\n+      DECL_ARTIFICIAL (decl) = 1;\n+      TYPE_STUB_DECL (type) = decl;\n+    }\n+  else if (type != TYPE_MAIN_VARIANT (type))\n+    DECL_ORIGINAL_TYPE (decl) = TYPE_MAIN_VARIANT (type);\n \n-  rest_of_decl_compilation (decl, SCOPE_FILE_SCOPE_P (decl), 0);\n+  rest_of_decl_compilation (decl, DECL_FILE_SCOPE_P (decl), 0);\n }\n \n /* Create a declaration for field NAME of a given TYPE, setting the flags"}, {"sha": "6df1e78c07494cf051d07934b69928f418d8656b", "filename": "gcc/d/types.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4011c13c1f8d51f00af61bcb8189bcbe45823b7/gcc%2Fd%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4011c13c1f8d51f00af61bcb8189bcbe45823b7/gcc%2Fd%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypes.cc?ref=e4011c13c1f8d51f00af61bcb8189bcbe45823b7", "patch": "@@ -859,14 +859,17 @@ class TypeVisitor : public Visitor\n \t   For these, we simplify this a little by using the base type directly\n \t   instead of building an ENUMERAL_TYPE.  */\n \tt->ctype = build_variant_type_copy (basetype);\n+\tbuild_type_decl (t->ctype, t->sym);\n       }\n     else\n       {\n \tt->ctype = make_node (ENUMERAL_TYPE);\n-\tENUM_IS_SCOPED (t->ctype) = 1;\n \tTYPE_LANG_SPECIFIC (t->ctype) = build_lang_type (t);\n \td_keep (t->ctype);\n \n+\tENUM_IS_SCOPED (t->ctype) = 1;\n+\tTREE_TYPE (t->ctype) = basetype;\n+\n \tif (flag_short_enums)\n \t  TYPE_PACKED (t->ctype) = 1;\n "}]}