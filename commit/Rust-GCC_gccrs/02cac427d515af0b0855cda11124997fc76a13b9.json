{"sha": "02cac427d515af0b0855cda11124997fc76a13b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJjYWM0MjdkNTE1YWYwYjA4NTVjZGExMTEyNDk5N2ZjNzZhMTNiOQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "1999-09-09T12:07:46Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "1999-09-09T12:07:46Z"}, "message": "extend.texi (Volatiles): New node.\n\ngcc/ChangeLog:\n\t* extend.texi (Volatiles): New node.\ngcc/cp/ChangeLog:\n\t* cp-tree.h (convert_to_void): Prototype new function.\n\t(require_complete_type_in_void): Remove prototype.\n\t* cvt.c (convert_to_void): New function.\n\t(ocp_convert): Use convert_to_void.\n\t* decl.c (cplus_expand_expr_stmt): Likewise, for complete\n\texpressions.\n\t* typeck.c (require_complete_type_in_void): Remove function.\n\t(build_compound_expr): Use convert_to_void.\n\t(build_static_cast): Likewise.\n\t(build_c_cast): Likewise.\n\t* semantics.c (finish_expr_stmt): Do not decay full expressions.\n\n\t* typeck.c (build_x_compound_expr): Add FIXME.\n\nFrom-SVN: r29233", "tree": {"sha": "88b5b117435e72426ca1237680e644cce728803b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88b5b117435e72426ca1237680e644cce728803b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02cac427d515af0b0855cda11124997fc76a13b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02cac427d515af0b0855cda11124997fc76a13b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02cac427d515af0b0855cda11124997fc76a13b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02cac427d515af0b0855cda11124997fc76a13b9/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fb3f91c9a888e175c2d2e39ed9017b59f4c99876", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb3f91c9a888e175c2d2e39ed9017b59f4c99876", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb3f91c9a888e175c2d2e39ed9017b59f4c99876"}], "stats": {"total": 382, "additions": 259, "deletions": 123}, "files": [{"sha": "56c5145f719cd498cd0989470d2b19b09dd0a520", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02cac427d515af0b0855cda11124997fc76a13b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02cac427d515af0b0855cda11124997fc76a13b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02cac427d515af0b0855cda11124997fc76a13b9", "patch": "@@ -1,3 +1,7 @@\n+Thu Sep  9 12:32:57 BST 1999  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* extend.texi (Volatiles): New node.\n+\n Thu Sep  9 12:20:34 1999  Nick Clifton  <nickc@cygnus.com>\n \n \t* toplev.c (documented_lang_options): "}, {"sha": "5819ecabc7f1b0d4a34e9f679e77ed683d12db2e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02cac427d515af0b0855cda11124997fc76a13b9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02cac427d515af0b0855cda11124997fc76a13b9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=02cac427d515af0b0855cda11124997fc76a13b9", "patch": "@@ -1,3 +1,19 @@\n+1999-09-09  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* cp-tree.h (convert_to_void): Prototype new function.\n+\t(require_complete_type_in_void): Remove prototype.\n+\t* cvt.c (convert_to_void): New function.\n+\t(ocp_convert): Use convert_to_void.\n+\t* decl.c (cplus_expand_expr_stmt): Likewise, for complete\n+\texpressions.\n+\t* typeck.c (require_complete_type_in_void): Remove function.\n+\t(build_compound_expr): Use convert_to_void.\n+\t(build_static_cast): Likewise.\n+\t(build_c_cast): Likewise.\n+\t* semantics.c (finish_expr_stmt): Do not decay full expressions.\n+\t\n+\t* typeck.c (build_x_compound_expr): Add FIXME.\n+\n 1999-09-08  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (lang_decl_flags): Remove permanent_attr."}, {"sha": "fa6a7fa09bbe56771210c24170d439766d7e51a7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02cac427d515af0b0855cda11124997fc76a13b9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02cac427d515af0b0855cda11124997fc76a13b9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=02cac427d515af0b0855cda11124997fc76a13b9", "patch": "@@ -3044,6 +3044,7 @@ extern tree convert_pointer_to_real\t\tPROTO((tree, tree));\n extern tree convert_pointer_to\t\t\tPROTO((tree, tree));\n extern tree ocp_convert\t\t\t\tPROTO((tree, tree, int, int));\n extern tree cp_convert\t\t\t\tPROTO((tree, tree));\n+extern tree convert_to_void\t\t\tPROTO((tree, const char */*implicit context*/));\n extern tree convert\t\t\t\tPROTO((tree, tree));\n extern tree convert_force\t\t\tPROTO((tree, tree, int));\n extern tree build_type_conversion\t\tPROTO((tree, tree, int));\n@@ -3718,7 +3719,6 @@ extern int string_conv_p\t\t\tPROTO((tree, tree, int));\n extern tree condition_conversion\t\tPROTO((tree));\n extern tree target_type\t\t\t\tPROTO((tree));\n extern tree require_complete_type\t\tPROTO((tree));\n-extern tree require_complete_type_in_void\tPROTO((tree));\n extern tree complete_type\t\t\tPROTO((tree));\n extern tree complete_type_or_else               PROTO((tree, tree));\n extern int type_unknown_p\t\t\tPROTO((tree));"}, {"sha": "7ea55bd85959b1d7d8d8851b42c116564a5e39a2", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 135, "deletions": 4, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02cac427d515af0b0855cda11124997fc76a13b9/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02cac427d515af0b0855cda11124997fc76a13b9/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=02cac427d515af0b0855cda11124997fc76a13b9", "patch": "@@ -715,10 +715,7 @@ ocp_convert (type, expr, convtype, flags)\n \n   if (code == VOID_TYPE && (convtype & CONV_STATIC))\n     {\n-      e = require_complete_type_in_void (e);\n-      if (e != error_mark_node)\n-        e = build1 (CONVERT_EXPR, void_type_node, e);\n-\n+      e = convert_to_void (e, /*implicit=*/NULL);\n       return e;\n     }\n \n@@ -856,6 +853,140 @@ ocp_convert (type, expr, convtype, flags)\n   return error_mark_node;\n }\n \n+/* When an expression is used in a void context, its value is discarded and\n+   no lvalue-rvalue and similar conversions happen [expr.static.cast/4,\n+   stmt.expr/1, expr.comma/1].  This permits dereferencing an incomplete type\n+   in a void context. The C++ standard does not define what an `access' to an\n+   object is, but there is reason to beleive that it is the lvalue to rvalue\n+   conversion -- if it were not, `*&*p = 1' would violate [expr]/4 in that it\n+   accesses `*p' not to calculate the value to be stored. But, dcl.type.cv/8\n+   indicates that volatile semantics should be the same between C and C++\n+   where ever possible. C leaves it implementation defined as to what\n+   constitutes an access to a volatile. So, we interpret `*vp' as a read of\n+   the volatile object `vp' points to, unless that is an incomplete type. For\n+   volatile references we do not do this interpretation, because that would\n+   make it impossible to ignore the reference return value from functions. We\n+   issue warnings in the confusing cases.\n+   \n+   IMPLICIT is tells us the context of an implicit void conversion.  */\n+\n+tree\n+convert_to_void (expr, implicit)\n+     tree expr;\n+     const char *implicit;\n+{\n+  if (expr == error_mark_node)\n+    return expr;\n+  if (!TREE_TYPE (expr))\n+    return expr;\n+  if (same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (expr)), void_type_node))\n+    return expr;\n+  switch (TREE_CODE (expr))\n+    {\n+    case COND_EXPR:\n+      {\n+        /* The two parts of a cond expr might be separate lvalues.  */\n+        tree op1 = TREE_OPERAND (expr,1);\n+        tree op2 = TREE_OPERAND (expr,2);\n+        tree new_op1 = convert_to_void (op1, implicit);\n+        tree new_op2 = convert_to_void (op2, implicit);\n+        \n+        if (new_op1 != op1 || new_op2 != op2)\n+          expr = build (COND_EXPR,\n+                        implicit ? TREE_TYPE (expr) : void_type_node,\n+                        TREE_OPERAND (expr, 0), new_op1, new_op2);\n+        break;\n+      }\n+    \n+    case COMPOUND_EXPR:\n+      {\n+        /* The second part of a compound expr contains the value.  */\n+        tree op1 = TREE_OPERAND (expr,1);\n+        tree new_op1 = convert_to_void (op1, implicit);\n+        \n+        if (new_op1 != op1)\n+          expr = build (COMPOUND_EXPR, TREE_TYPE (new_op1),\n+                        TREE_OPERAND (expr, 0), new_op1);\n+        break;\n+      }\n+    \n+    case NON_LVALUE_EXPR:\n+    case NOP_EXPR:\n+      /* These have already decayed to rvalue. */\n+      break;\n+    \n+    case CALL_EXPR:   /* we have a special meaning for volatile void fn() */\n+      break;\n+    \n+    case INDIRECT_REF:\n+      {\n+        tree type = TREE_TYPE (expr);\n+        int is_reference = TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0)))\n+                           == REFERENCE_TYPE;\n+        int is_volatile = TYPE_VOLATILE (type);\n+        int is_complete = TYPE_SIZE (complete_type (type)) != NULL_TREE;\n+        \n+        if (is_volatile && !is_complete)\n+          cp_warning (\"object of incomplete type `%T' will not be accessed in %s\",\n+                      type, implicit ? implicit : \"void context\");\n+        else if (is_reference && is_volatile)\n+          cp_warning (\"object of type `%T' will not be accessed in %s\",\n+                      TREE_TYPE (TREE_OPERAND (expr, 0)),\n+                      implicit ? implicit : \"void context\");\n+        if (is_reference || !is_volatile || !is_complete)\n+          expr = TREE_OPERAND (expr, 0);\n+      \n+        break;\n+      }\n+    \n+    case VAR_DECL:\n+      {\n+        /* External variables might be incomplete.  */\n+        tree type = TREE_TYPE (expr);\n+        int is_complete = TYPE_SIZE (complete_type (type)) != NULL_TREE;\n+        \n+        if (TYPE_VOLATILE (type) && !is_complete)\n+          cp_warning (\"object `%E' of incomplete type `%T' will not be accessed in %s\",\n+                      expr, type, implicit ? implicit : \"void context\");\n+        break;\n+      }\n+    \n+    default:;\n+    }\n+  {\n+    tree probe = expr;\n+  \n+    if (TREE_CODE (probe) == ADDR_EXPR)\n+      probe = TREE_OPERAND (expr, 0);\n+    if (!is_overloaded_fn (probe))\n+      ;/* OK */\n+    else if (really_overloaded_fn (probe))\n+        {\n+          /* [over.over] enumerates the places where we can take the address\n+             of an overloaded function, and this is not one of them.  */\n+          cp_pedwarn (\"%s has no context for overloaded function name `%E'\",\n+                      implicit ? implicit : \"void cast\", expr);\n+        }\n+    else if (implicit && probe == expr)\n+      /* Only warn when there is no &.  */\n+      cp_warning (\"%s is a reference, not call, to function `%E'\",\n+                    implicit, expr);\n+  }\n+  \n+  if (expr != error_mark_node\n+      && !same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (expr)), void_type_node))\n+    {\n+      /* FIXME: This is where we should check for expressions with no\n+         effects.  At the moment we do that in both build_x_component_expr\n+         and expand_expr_stmt -- inconsistently too.  For the moment\n+         leave implicit void conversions unadorned so that expand_expr_stmt\n+         has a chance of detecting some of the cases.  */\n+      if (!implicit)\n+        expr = build1 (CONVERT_EXPR, void_type_node, expr);\n+    }\n+  return expr;\n+}\n+\n /* Create an expression whose value is that of EXPR,\n    converted to type TYPE.  The TREE_TYPE of the value\n    is always TYPE.  This function implements all reasonable"}, {"sha": "3286709116fe827df400dbef87665043d33be18d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02cac427d515af0b0855cda11124997fc76a13b9/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02cac427d515af0b0855cda11124997fc76a13b9/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=02cac427d515af0b0855cda11124997fc76a13b9", "patch": "@@ -14336,25 +14336,15 @@ void\n cplus_expand_expr_stmt (exp)\n      tree exp;\n {\n-  exp = require_complete_type_in_void (exp);\n+  if (stmts_are_full_exprs_p)\n+    exp = convert_to_void (exp, \"statement\");\n   \n-  if (TREE_CODE (exp) == FUNCTION_DECL)\n-    {\n-      cp_warning (\"reference, not call, to function `%D'\", exp);\n-      warning (\"at this point in file\");\n-    }\n-\n #if 0\n   /* We should do this eventually, but right now this causes regex.o from\n      libg++ to miscompile, and tString to core dump.  */\n   exp = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (exp), exp);\n #endif\n \n-  /* Strip unused implicit INDIRECT_REFs of references.  */\n-  if (TREE_CODE (exp) == INDIRECT_REF\n-      && TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == REFERENCE_TYPE)\n-    exp = TREE_OPERAND (exp, 0);\n-\n   /* If we don't do this, we end up down inside expand_expr\n      trying to do TYPE_MODE on the ERROR_MARK, and really\n      go outside the bounds of the type.  */"}, {"sha": "822027e4eab032afe947ecfbbb843daa5562430e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02cac427d515af0b0855cda11124997fc76a13b9/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02cac427d515af0b0855cda11124997fc76a13b9/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=02cac427d515af0b0855cda11124997fc76a13b9", "patch": "@@ -79,9 +79,10 @@ finish_expr_stmt (expr)\n \t  emit_line_note (input_filename, lineno);\n \t  /* Do default conversion if safe and possibly important,\n \t     in case within ({...}).  */\n-\t  if ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE\n-\t       && lvalue_p (expr))\n-\t      || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE)\n+\t  if (!stmts_are_full_exprs_p &&\n+\t      ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE\n+\t        && lvalue_p (expr))\n+\t       || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE))\n \t    expr = default_conversion (expr);\n \n \t  if (stmts_are_full_exprs_p)"}, {"sha": "506103b5e1d0c31864dc14c6e4147c84cd2d7d79", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 15, "deletions": 103, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02cac427d515af0b0855cda11124997fc76a13b9/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02cac427d515af0b0855cda11124997fc76a13b9/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=02cac427d515af0b0855cda11124997fc76a13b9", "patch": "@@ -128,100 +128,6 @@ require_complete_type (value)\n     return error_mark_node;\n }\n \n-/* Makes sure EXPR is a complete type when used in a void context, like a\n-   whole expression, or lhs of a comma operator. Issue a diagnostic and\n-   return error_mark_node on failure. This is a little tricky, because some\n-   valid void types look stunningly similar to invalid void types. We err on\n-   the side of caution */\n-\n-tree\n-require_complete_type_in_void (expr)\n-     tree expr;\n-{\n-  switch (TREE_CODE (expr))\n-    {\n-    case COND_EXPR:\n-      {\n-        tree op;\n-        \n-        op = TREE_OPERAND (expr,2);\n-        op = require_complete_type_in_void (op);\n-        TREE_OPERAND (expr,2) = op;\n-        if (op == error_mark_node)\n-          {\n-            expr = op;\n-            break;\n-          }\n-        \n-        /* fallthrough */\n-      }\n-    \n-    case COMPOUND_EXPR:\n-      {\n-        tree op;\n-        \n-        op = TREE_OPERAND (expr,1);\n-        op = require_complete_type_in_void (op);\n-        TREE_OPERAND (expr,1) = op;\n-        if (op == error_mark_node)\n-          {\n-            expr = op;\n-            break;\n-          }\n-        \n-        break;\n-      }\n-    \n-    case NON_LVALUE_EXPR:\n-    case NOP_EXPR:\n-      {\n-        tree op;\n-        \n-        op = TREE_OPERAND (expr,0);\n-        op = require_complete_type_in_void (op);\n-        TREE_OPERAND (expr,0) = op;\n-        if (op == error_mark_node)\n-          {\n-            expr = op;\n-            break;\n-          }\n-        break;\n-      }\n-    \n-    case CALL_EXPR:   /* function call return can be ignored */\n-    case RTL_EXPR:    /* RTL nodes have no value */\n-    case DELETE_EXPR: /* delete expressions have no type */\n-    case VEC_DELETE_EXPR:\n-    case INTEGER_CST: /* used for null pointer */\n-    case EXIT_EXPR:   /* have no return */\n-    case LOOP_EXPR:   /* have no return */\n-    case BIND_EXPR:   /* have no return */\n-    case STMT_EXPR: /* have no return */\n-    case THROW_EXPR:  /* have no return */\n-    case MODIFY_EXPR: /* sometimes this has a void type, but that's ok */\n-    case CONVERT_EXPR:  /* sometimes has a void type */\n-      break;\n-    \n-    case INDIRECT_REF:\n-      {\n-        tree op = TREE_OPERAND (expr,0);\n-        \n-        /* Calling a function returning a reference has an implicit\n-           dereference applied. We don't want to make that an error. */\n-        if (TREE_CODE (op) == CALL_EXPR\n-            && TREE_CODE (TREE_TYPE (op)) == REFERENCE_TYPE)\n-          break;\n-        /* else fallthrough */\n-      }\n-    \n-    default:\n-      expr = require_complete_type (expr);\n-      break;\n-    }\n-\n-  return expr;\n-}\n-\n /* Try to complete TYPE, if it is incomplete.  For example, if TYPE is\n    a template instantiation, do the instantiation.  Returns TYPE,\n    whether or not it could be completed, unless something goes\n@@ -5160,6 +5066,7 @@ build_x_compound_expr (list)\n \n   if (! TREE_SIDE_EFFECTS (TREE_VALUE (list)))\n     {\n+      /* FIXME: This test should be in the implicit cast to void of the LHS. */\n       /* the left-hand operand of a comma expression is like an expression\n          statement: we should warn if it doesn't have any side-effects,\n          unless it was explicitly cast to (void).  */\n@@ -5208,7 +5115,7 @@ build_compound_expr (list)\n     }\n \n   first = TREE_VALUE (list);\n-  first = require_complete_type_in_void (first);\n+  first = convert_to_void (first, \"lhs of comma\");\n   if (first == error_mark_node)\n     return error_mark_node;\n   \n@@ -5251,7 +5158,10 @@ build_static_cast (type, expr)\n     expr = TREE_OPERAND (expr, 0);\n \n   if (TREE_CODE (type) == VOID_TYPE)\n-    return build1 (CONVERT_EXPR, type, expr);\n+    {\n+      expr = convert_to_void (expr, /*implicit=*/NULL);\n+      return expr;\n+    }\n \n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     return (convert_from_reference\n@@ -5539,6 +5449,14 @@ build_c_cast (type, expr)\n       return t;\n     }\n \n+  if (TREE_CODE (type) == VOID_TYPE)\n+    {\n+      /* Conversion to void does not cause any of the normal function to\n+       * pointer, array to pointer and lvalue to rvalue decays.  */\n+      \n+      value = convert_to_void (value, /*implicit=*/NULL);\n+      return value;\n+    }\n   /* Convert functions and arrays to pointers and\n      convert references to their expanded types,\n      but don't convert any other types.  If, however, we are\n@@ -5607,13 +5525,7 @@ build_c_cast (type, expr)\n     warning (\"cast to pointer from integer of different size\");\n #endif\n \n-  if (TREE_CODE (type) == VOID_TYPE)\n-    {\n-      value = require_complete_type_in_void (value);\n-      if (value != error_mark_node)\n-        value = build1 (CONVERT_EXPR, void_type_node, value);\n-    }\n-  else if (TREE_CODE (type) == REFERENCE_TYPE)\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n     value = (convert_from_reference\n \t     (convert_to_reference (type, value, CONV_C_CAST,\n \t\t\t\t    LOOKUP_COMPLAIN, NULL_TREE)));"}, {"sha": "5b5f3b116c6fd16c197865f902de3e218c60dd08", "filename": "gcc/extend.texi", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02cac427d515af0b0855cda11124997fc76a13b9/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02cac427d515af0b0855cda11124997fc76a13b9/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=02cac427d515af0b0855cda11124997fc76a13b9", "patch": "@@ -3157,6 +3157,7 @@ Predefined Macros,cpp.info,The C Preprocessor}).\n @menu\n * Naming Results::      Giving a name to C++ function return values.\n * Min and Max::\t\tC++ Minimum and maximum operators.\n+* Volatiles::\t\tWhat constitutes an access to a volatile object.\n * C++ Interface::       You can use a single C++ header file for both\n                          declarations and definitions.\n * Template Instantiation:: Methods for ensuring that exactly one copy of\n@@ -3323,6 +3324,87 @@ Since @code{<?} and @code{>?} are built into the compiler, they properly\n handle expressions with side-effects;  @w{@samp{int min = i++ <? j++;}}\n works correctly.\n \n+@node Volatiles\n+@section When is a Volatile Object Accessed?\n+@cindex accessing volatiles\n+@cindex volatile read\n+@cindex volatile write\n+@cindex volatile access\n+\n+Both the C and C++ standard have the concept of volatile objects. These\n+are normally accessed by pointers and used for accessing hardware. The\n+standards encourage compilers to refrain from optimizations on\n+concerning accesses to volatile objects that it might perform on\n+non-volatile objects. The C standard leaves it implementation defined\n+as to what constitutes a volatile access. The C++ standard omits to\n+specify this, except to say that C++ should behave in a similar manner\n+to C with respect to volatiles, where possible. The minimum either\n+standard specifies is that at a sequence point all previous access to\n+volatile objects have stabilized and no subsequent accesses have\n+occurred. Thus an implementation is free to reorder and combine\n+volatile accesses which occur between sequence points, but cannot do so\n+for accesses across a sequence point. The use of volatiles does not\n+allow you to violate the restriction on updating objects multiple times\n+within a sequence point.\n+\n+In most expressions, it is intuitively obvious what is a read and what is\n+a write. For instance\n+\n+@example\n+volatile int *dst = <somevalue>;\n+volatile int *src = <someothervalue>;\n+*dst = *src;\n+@end example\n+\n+@noindent\n+will cause a read of the volatile object pointed to by @var{src} and stores the\n+value into the volatile object pointed to by @var{dst}. There is no\n+guarantee that these reads and writes are atomic, especially for objects\n+larger than @code{int}.\n+\n+Less obvious expressions are where something which looks like an access\n+is used in a void context. An example would be,\n+\n+@example\n+volatile int *src = <somevalue>;\n+*src;\n+@end example\n+\n+With C, such expressions are rvalues, and as rvalues cause a read of\n+the object, gcc interprets this as a read of the volatile being pointed\n+to. The C++ standard specifies that such expressions do not undergo\n+lvalue to rvalue conversion, and that the type of the dereferenced\n+object may be incomplete. The C++ standard does not specify explicitly\n+that it is this lvalue to rvalue conversion which is responsible for\n+causing an access. However, there is reason to believe that it is,\n+because otherwise certain simple expressions become undefined. However,\n+because it would surprise most programmers, g++ treats dereferencing a\n+pointer to volatile object of complete type in a void context as a read\n+of the object. When the object has incomplete type, g++ issues a\n+warning.\n+\n+@example\n+struct S;\n+struct T @{int m;@};\n+volatile S *ptr1 = <somevalue>;\n+volatile T *ptr2 = <somevalue>;\n+*ptr1;\n+*ptr2;\n+@end example\n+\n+In this example, a warning is issued for @code{*ptr1}, and @code{*ptr2}\n+causes a read of the object pointed to. If you wish to force an error on\n+the first case, you must force a conversion to rvalue with, for instance\n+a static cast, @code{static_cast<S>(*ptr1)}.\n+\n+When using a reference to volatile, g++ does not treat equivalent\n+expressions as accesses to volatiles, but instead issues a warning that\n+no volatile is accessed. The rationale for this is that otherwise it\n+becomes difficult to determine where volatile access occur, and not\n+possible to ignore the return value from functions returning volatile\n+references. Again, if you wish to force a read, cast the reference to\n+an rvalue.\n+\n @node C++ Interface\n @section Declarations and Definitions in One Header\n "}]}