{"sha": "1f3a33633dd06a8e4861180ab20c9136361c69e6", "node_id": "C_kwDOANBUbNoAKDFmM2EzMzYzM2RkMDZhOGU0ODYxMTgwYWIyMGM5MTM2MzYxYzY5ZTY", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-11-08T06:52:45Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-11-08T06:52:45Z"}, "message": "Add loads/stores relative to static chain in ipa-modref\n\nAdds tracking of accesses relative to static chain into modref\nload/stores analysis.  This helps some Fortran benchmarks however it is still\nquite limited.  One problem is that we never discover functions with nested\nfunctions as const, pure or not accessing global memory because it contains\n__builtin_dward_cfa call which we believe to be non-pure.\n\nBootstrapped/regtested x86_64-linux.  Plan to commit it tomorrow if there are\nno complains and once periodic testers picks today modref changes.\n\nHonza\n\ngcc/ChangeLog:\n\n\t* ipa-modref-tree.h (enum modref_special_parms): New enum.\n\t(struct modref_access_node): update for special parms.\n\t(struct modref_ref_node): Likewise.\n\t(struct modref_parm_map): Likewise.\n\t(struct modref_tree): Likewise.\n\t* ipa-modref.c (dump_access): Likewise.\n\t(get_access): Detect static chain.\n\t(parm_map_for_arg): Take tree as arg instead of\n\tstmt and index.\n\t(merge_call_side_effects): Compute map for static chain.\n\t(process_fnspec): Update.\n\t(struct escape_point): Remove retslot_arg and static_chain_arg.\n\t(analyze_parms): Update.\n\t(compute_parm_map): Update.\n\t(propagate_unknown_call): Update.\n\t(modref_propagate_in_scc): Update.\n\t(modref_merge_call_site_flags): Update.\n\t(ipa_merge_modref_summary_after_inlining): Update.\n\t* tree-ssa-alias.c (modref_may_conflict): Handle static chain.\n\t* ipa-modref-tree.c (test_merge): Update.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/modref-12.c: New test.", "tree": {"sha": "d25e2b725823cf4a6055b9844dd82d65809425e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d25e2b725823cf4a6055b9844dd82d65809425e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f3a33633dd06a8e4861180ab20c9136361c69e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3a33633dd06a8e4861180ab20c9136361c69e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f3a33633dd06a8e4861180ab20c9136361c69e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3a33633dd06a8e4861180ab20c9136361c69e6/comments", "author": null, "committer": null, "parents": [{"sha": "14e355df30534b1d07018e2934948a09fa5a8e52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14e355df30534b1d07018e2934948a09fa5a8e52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14e355df30534b1d07018e2934948a09fa5a8e52"}], "stats": {"total": 253, "additions": 158, "deletions": 95}, "files": [{"sha": "d0ee487f9fa19b420b656581a4a5f61f4987feeb", "filename": "gcc/ipa-modref-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3a33633dd06a8e4861180ab20c9136361c69e6/gcc%2Fipa-modref-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3a33633dd06a8e4861180ab20c9136361c69e6/gcc%2Fipa-modref-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.c?ref=1f3a33633dd06a8e4861180ab20c9136361c69e6", "patch": "@@ -138,7 +138,7 @@ test_merge ()\n   t2->insert (3, 4, a, false);\n   t2->insert (3, 5, a, false);\n \n-  t1->merge (t2, NULL, false);\n+  t1->merge (t2, NULL, NULL, false);\n \n   ASSERT_FALSE (t1->every_base);\n   ASSERT_NE (t1->bases, NULL);"}, {"sha": "be5efcbb68f9821108491277ed6bac1af5c16be9", "filename": "gcc/ipa-modref-tree.h", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3a33633dd06a8e4861180ab20c9136361c69e6/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3a33633dd06a8e4861180ab20c9136361c69e6/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=1f3a33633dd06a8e4861180ab20c9136361c69e6", "patch": "@@ -42,6 +42,18 @@ along with GCC; see the file COPYING3.  If not see\n \n struct ipa_modref_summary;\n \n+/* parm indexes greater than 0 are normal parms.\n+   Some negative values have special meaning.  */\n+enum modref_special_parms {\n+  MODREF_UNKNOWN_PARM = -1,\n+  MODREF_STATIC_CHAIN_PARM = -2,\n+  MODREF_RETSLOT_PARM = -3,\n+  /* Used in modref_parm_map to tak references which can be removed\n+     from the summary during summary update since they now points to loca\n+     memory.  */\n+  MODREF_LOCAL_MEMORY_PARM = -4\n+};\n+\n /* Memory access.  */\n struct GTY(()) modref_access_node\n {\n@@ -65,12 +77,12 @@ struct GTY(()) modref_access_node\n   /* Return true if access node holds no useful info.  */\n   bool useful_p () const\n     {\n-      return parm_index != -1;\n+      return parm_index != MODREF_UNKNOWN_PARM;\n     }\n   /* Return true if range info is useful.  */\n   bool range_info_useful_p () const\n     {\n-      return parm_index != -1 && parm_offset_known\n+      return parm_index != MODREF_UNKNOWN_PARM && parm_offset_known\n \t     && (known_size_p (size)\n \t\t || known_size_p (max_size)\n \t\t || known_ge (offset, 0));\n@@ -80,7 +92,7 @@ struct GTY(()) modref_access_node\n     {\n       if (parm_index != a.parm_index)\n \treturn false;\n-      if (parm_index >= 0)\n+      if (parm_index != MODREF_UNKNOWN_PARM)\n \t{\n \t  if (parm_offset_known != a.parm_offset_known)\n \t    return false;\n@@ -101,7 +113,7 @@ struct GTY(()) modref_access_node\n   bool contains (const modref_access_node &a) const\n     {\n       poly_int64 aoffset_adj = 0;\n-      if (parm_index >= 0)\n+      if (parm_index != MODREF_UNKNOWN_PARM)\n \t{\n \t  if (parm_index != a.parm_index)\n \t    return false;\n@@ -211,7 +223,7 @@ struct GTY(()) modref_access_node\n \n       /* We assume that containment was tested earlier.  */\n       gcc_checking_assert (!contains (a) && !a.contains (*this));\n-      if (parm_index >= 0)\n+      if (parm_index != MODREF_UNKNOWN_PARM)\n \t{\n \t  if (parm_index != a.parm_index)\n \t    return false;\n@@ -350,8 +362,8 @@ struct GTY(()) modref_access_node\n     {\n       if (parm_index != a.parm_index)\n \t{\n-\t  gcc_checking_assert (parm_index != -1);\n-\t  parm_index = -1;\n+\t  gcc_checking_assert (parm_index != MODREF_UNKNOWN_PARM);\n+\t  parm_index = MODREF_UNKNOWN_PARM;\n \t  return;\n \t}\n \n@@ -454,7 +466,7 @@ struct GTY(()) modref_access_node\n \n /* Access node specifying no useful info.  */\n const modref_access_node unspecified_modref_access_node\n-\t\t = {0, -1, -1, 0, -1, false, 0};\n+\t\t = {0, -1, -1, 0, MODREF_UNKNOWN_PARM, false, 0};\n \n template <typename T>\n struct GTY((user)) modref_ref_node\n@@ -506,6 +518,12 @@ struct GTY((user)) modref_ref_node\n     size_t i, j;\n     modref_access_node *a2;\n \n+    /* Only the following kind of paramters needs to be tracked.\n+       We do not track return slots because they are seen as a direct store\n+       in the caller.  */\n+    gcc_checking_assert (a.parm_index >= 0\n+\t\t\t || a.parm_index == MODREF_STATIC_CHAIN_PARM\n+\t\t\t || a.parm_index == MODREF_UNKNOWN_PARM);\n     if (flag_checking)\n       verify ();\n \n@@ -734,9 +752,7 @@ struct GTY((user)) modref_base_node\n struct modref_parm_map\n {\n   /* Index of parameter we translate to.\n-     -1 indicates that parameter is unknown\n-     -2 indicates that parameter points to local memory and access can be\n-\tdiscarded.  */\n+     Values from special_params enum are permitted too.  */\n   int parm_index;\n   bool parm_offset_known;\n   poly_int64 parm_offset;\n@@ -946,10 +962,11 @@ struct GTY((user)) modref_tree\n  }\n \n   /* Merge OTHER into the tree.\n-     PARM_MAP, if non-NULL, maps parm indexes of callee to caller.  -2 is used\n-     to signalize that parameter is local and does not need to be tracked.\n+     PARM_MAP, if non-NULL, maps parm indexes of callee to caller.\n+     Similar CHAIN_MAP, if non-NULL, maps static chain of callee to caller.\n      Return true if something has changed.  */\n   bool merge (modref_tree <T> *other, vec <modref_parm_map> *parm_map,\n+\t      modref_parm_map *static_chain_map,\n \t      bool record_accesses)\n   {\n     if (!other || every_base)\n@@ -1003,21 +1020,21 @@ struct GTY((user)) modref_tree\n \t\t  {\n \t\t    modref_access_node a = *access_node;\n \n-\t\t    if (a.parm_index != -1 && parm_map)\n+\t\t    if (a.parm_index != MODREF_UNKNOWN_PARM && parm_map)\n \t\t      {\n \t\t\tif (a.parm_index >= (int)parm_map->length ())\n-\t\t\t  a.parm_index = -1;\n-\t\t\telse if ((*parm_map) [a.parm_index].parm_index == -2)\n-\t\t\t  continue;\n+\t\t\t  a.parm_index = MODREF_UNKNOWN_PARM;\n \t\t\telse\n \t\t\t  {\n-\t\t\t    a.parm_offset\n-\t\t\t\t += (*parm_map) [a.parm_index].parm_offset;\n-\t\t\t    a.parm_offset_known\n-\t\t\t\t &= (*parm_map)\n-\t\t\t\t\t [a.parm_index].parm_offset_known;\n-\t\t\t    a.parm_index\n-\t\t\t\t = (*parm_map) [a.parm_index].parm_index;\n+\t\t\t    modref_parm_map &m\n+\t\t\t\t    = a.parm_index == MODREF_STATIC_CHAIN_PARM\n+\t\t\t\t      ? *static_chain_map\n+\t\t\t\t      : (*parm_map) [a.parm_index];\n+\t\t\t    if (m.parm_index == MODREF_LOCAL_MEMORY_PARM)\n+\t\t\t      continue;\n+\t\t\t    a.parm_offset += m.parm_offset;\n+\t\t\t    a.parm_offset_known &= m.parm_offset_known;\n+\t\t\t    a.parm_index = m.parm_index;\n \t\t\t  }\n \t\t      }\n \t\t    changed |= insert (base_node->base, ref_node->ref, a,\n@@ -1033,7 +1050,7 @@ struct GTY((user)) modref_tree\n   /* Copy OTHER to THIS.  */\n   void copy_from (modref_tree <T> *other)\n   {\n-    merge (other, NULL, false);\n+    merge (other, NULL, NULL, false);\n   }\n \n   /* Search BASE in tree; return NULL if failed.  */\n@@ -1065,7 +1082,7 @@ struct GTY((user)) modref_tree\n \t    if (ref_node->every_access)\n \t      return true;\n \t    FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n-\t      if (access_node->parm_index < 0)\n+\t      if (access_node->parm_index == MODREF_UNKNOWN_PARM)\n \t\treturn true;\n \t  }\n       }\n@@ -1127,7 +1144,7 @@ struct GTY((user)) modref_tree\n \t\t  if (access_node->parm_index < (int)map->length ())\n \t\t    access_node->parm_index = (*map)[access_node->parm_index];\n \t\t  else\n-\t\t    access_node->parm_index = -1;\n+\t\t    access_node->parm_index = MODREF_UNKNOWN_PARM;\n \t\t}\n \t  }\n       }"}, {"sha": "4429bcea8030f8d36dc060148afac1cdbbbe96dc", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 89, "deletions": 63, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3a33633dd06a8e4861180ab20c9136361c69e6/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3a33633dd06a8e4861180ab20c9136361c69e6/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=1f3a33633dd06a8e4861180ab20c9136361c69e6", "patch": "@@ -426,9 +426,14 @@ static void\n dump_access (modref_access_node *a, FILE *out)\n {\n   fprintf (out, \"          access:\");\n-  if (a->parm_index != -1)\n+  if (a->parm_index != MODREF_UNKNOWN_PARM)\n     {\n-      fprintf (out, \" Parm %i\", a->parm_index);\n+      if (a->parm_index >= 0)\n+\tfprintf (out, \" Parm %i\", a->parm_index);\n+      else if (a->parm_index == MODREF_STATIC_CHAIN_PARM)\n+\tfprintf (out, \" Static chain\");\n+      else\n+\tgcc_unreachable ();\n       if (a->parm_offset_known)\n \t{\n \t  fprintf (out, \" param offset:\");\n@@ -697,40 +702,40 @@ get_access (ao_ref *ref)\n \n   base = ao_ref_base (ref);\n   modref_access_node a = {ref->offset, ref->size, ref->max_size,\n-\t\t\t  0, -1, false, 0};\n+\t\t\t  0, MODREF_UNKNOWN_PARM, false, 0};\n   if (TREE_CODE (base) == MEM_REF || TREE_CODE (base) == TARGET_MEM_REF)\n     {\n       tree memref = base;\n       base = TREE_OPERAND (base, 0);\n+\n       if (TREE_CODE (base) == SSA_NAME\n \t  && SSA_NAME_IS_DEFAULT_DEF (base)\n \t  && TREE_CODE (SSA_NAME_VAR (base)) == PARM_DECL)\n \t{\n \t  a.parm_index = 0;\n-\t  for (tree t = DECL_ARGUMENTS (current_function_decl);\n-\t       t != SSA_NAME_VAR (base); t = DECL_CHAIN (t))\n-\t    {\n-\t      if (!t)\n-\t\t{\n-\t\t  a.parm_index = -1;\n-\t\t  break;\n-\t\t}\n-\t      a.parm_index++;\n-\t    }\n-\t  if (TREE_CODE (memref) == MEM_REF)\n-\t    {\n-\t      a.parm_offset_known\n-\t\t = wi::to_poly_wide (TREE_OPERAND\n-\t\t\t\t\t (memref, 1)).to_shwi (&a.parm_offset);\n-\t    }\n+\t  if (cfun->static_chain_decl\n+\t      && base == ssa_default_def (cfun, cfun->static_chain_decl))\n+\t    a.parm_index = MODREF_STATIC_CHAIN_PARM;\n \t  else\n-\t    a.parm_offset_known = false;\n+\t    for (tree t = DECL_ARGUMENTS (current_function_decl);\n+\t\t t != SSA_NAME_VAR (base); t = DECL_CHAIN (t))\n+\t      a.parm_index++;\n+\t}\n+      else\n+\ta.parm_index = MODREF_UNKNOWN_PARM;\n+\n+      if (a.parm_index != MODREF_UNKNOWN_PARM\n+\t  && TREE_CODE (memref) == MEM_REF)\n+\t{\n+\t  a.parm_offset_known\n+\t     = wi::to_poly_wide (TREE_OPERAND\n+\t\t\t\t     (memref, 1)).to_shwi (&a.parm_offset);\n \t}\n       else\n-\ta.parm_index = -1;\n+\ta.parm_offset_known = false;\n     }\n   else\n-    a.parm_index = -1;\n+    a.parm_index = MODREF_UNKNOWN_PARM;\n   return a;\n }\n \n@@ -858,12 +863,11 @@ ignore_stores_p (tree caller, int flags)\n   return false;\n }\n \n-/* Determine parm_map for argument I of STMT.  */\n+/* Determine parm_map for argument OP.  */\n \n modref_parm_map\n-parm_map_for_arg (gimple *stmt, int i)\n+parm_map_for_arg (tree op)\n {\n-  tree op = gimple_call_arg (stmt, i);\n   bool offset_known;\n   poly_int64 offset;\n   struct modref_parm_map parm_map;\n@@ -882,7 +886,7 @@ parm_map_for_arg (gimple *stmt, int i)\n \t{\n \t  if (!t)\n \t    {\n-\t      index = -1;\n+\t      index = MODREF_UNKNOWN_PARM;\n \t      break;\n \t    }\n \t  index++;\n@@ -892,9 +896,9 @@ parm_map_for_arg (gimple *stmt, int i)\n       parm_map.parm_offset = offset;\n     }\n   else if (points_to_local_or_readonly_memory_p (op))\n-    parm_map.parm_index = -2;\n+    parm_map.parm_index = MODREF_LOCAL_MEMORY_PARM;\n   else\n-    parm_map.parm_index = -1;\n+    parm_map.parm_index = MODREF_UNKNOWN_PARM;\n   return parm_map;\n }\n \n@@ -911,6 +915,7 @@ merge_call_side_effects (modref_summary *cur_summary,\n \t\t\t bool record_adjustments)\n {\n   auto_vec <modref_parm_map, 32> parm_map;\n+  modref_parm_map chain_map;\n   bool changed = false;\n \n   /* We can not safely optimize based on summary of callee if it does\n@@ -931,7 +936,7 @@ merge_call_side_effects (modref_summary *cur_summary,\n   parm_map.safe_grow_cleared (gimple_call_num_args (stmt), true);\n   for (unsigned i = 0; i < gimple_call_num_args (stmt); i++)\n     {\n-      parm_map[i] = parm_map_for_arg (stmt, i);\n+      parm_map[i] = parm_map_for_arg (gimple_call_arg (stmt, i));\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \" %i\", parm_map[i].parm_index);\n@@ -943,16 +948,30 @@ merge_call_side_effects (modref_summary *cur_summary,\n \t    }\n \t}\n     }\n+  if (gimple_call_chain (stmt))\n+    {\n+      chain_map = parm_map_for_arg (gimple_call_chain (stmt));\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"static chain %i\", chain_map.parm_index);\n+\t  if (chain_map.parm_offset_known)\n+\t    {\n+\t      fprintf (dump_file, \" offset:\");\n+\t      print_dec ((poly_int64_pod)chain_map.parm_offset,\n+\t\t\t dump_file, SIGNED);\n+\t    }\n+\t}\n+    }\n   if (dump_file)\n     fprintf (dump_file, \"\\n\");\n \n   /* Merge with callee's summary.  */\n   changed |= cur_summary->loads->merge (callee_summary->loads, &parm_map,\n-\t\t\t\t\trecord_adjustments);\n+\t\t\t\t\t&chain_map, record_adjustments);\n   if (!ignore_stores)\n     {\n       changed |= cur_summary->stores->merge (callee_summary->stores,\n-\t\t\t\t\t     &parm_map,\n+\t\t\t\t\t     &parm_map, &chain_map,\n \t\t\t\t\t     record_adjustments);\n       if (!cur_summary->writes_errno\n \t  && callee_summary->writes_errno)\n@@ -1078,11 +1097,12 @@ process_fnspec (modref_summary *cur_summary,\n \telse if (!fnspec.arg_specified_p (i)\n \t\t || fnspec.arg_maybe_read_p (i))\n \t  {\n-\t    modref_parm_map map = parm_map_for_arg (call, i);\n+\t    modref_parm_map map = parm_map_for_arg\n+\t\t\t\t\t(gimple_call_arg (call, i));\n \n-\t    if (map.parm_index == -2)\n+\t    if (map.parm_index == MODREF_LOCAL_MEMORY_PARM)\n \t      continue;\n-\t    if (map.parm_index == -1)\n+\t    if (map.parm_index == MODREF_UNKNOWN_PARM)\n \t      {\n \t\tcollapse_loads (cur_summary, cur_summary_lto);\n \t\tbreak;\n@@ -1113,11 +1133,12 @@ process_fnspec (modref_summary *cur_summary,\n \telse if (!fnspec.arg_specified_p (i)\n \t\t || fnspec.arg_maybe_written_p (i))\n \t  {\n-\t    modref_parm_map map = parm_map_for_arg (call, i);\n+\t    modref_parm_map map = parm_map_for_arg\n+\t\t\t\t\t (gimple_call_arg (call, i));\n \n-\t    if (map.parm_index == -2)\n+\t    if (map.parm_index == MODREF_LOCAL_MEMORY_PARM)\n \t      continue;\n-\t    if (map.parm_index == -1)\n+\t    if (map.parm_index == MODREF_UNKNOWN_PARM)\n \t      {\n \t\tcollapse_stores (cur_summary, cur_summary_lto);\n \t\tbreak;\n@@ -1429,12 +1450,6 @@ deref_flags (int flags, bool ignore_stores)\n \n struct escape_point\n {\n-  /* Extra hidden args we keep track of.  */\n-  enum hidden_args\n-  {\n-    retslot_arg = -1,\n-    static_chain_arg = -2\n-  };\n   /* Value escapes to this call.  */\n   gcall *call;\n   /* Argument it escapes to.  */\n@@ -2410,7 +2425,7 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n \t  if (summary_lto)\n \t    summary_lto->retslot_flags = flags;\n \t  eaf_analysis.record_escape_points (retslot,\n-\t\t\t\t\t     escape_point::retslot_arg, flags);\n+\t\t\t\t\t     MODREF_RETSLOT_PARM, flags);\n \t}\n     }\n   if (static_chain)\n@@ -2425,7 +2440,7 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n \t  if (summary_lto)\n \t    summary_lto->static_chain_flags = flags;\n \t  eaf_analysis.record_escape_points (static_chain,\n-\t\t\t\t\t     escape_point::static_chain_arg,\n+\t\t\t\t\t     MODREF_STATIC_CHAIN_PARM,\n \t\t\t\t\t     flags);\n \t}\n     }\n@@ -3586,7 +3601,7 @@ compute_parm_map (cgraph_edge *callee_edge, vec<modref_parm_map> *parm_map)\n \t{\n \t  if (es && es->param[i].points_to_local_or_readonly_memory)\n \t    {\n-\t      (*parm_map)[i].parm_index = -2;\n+\t      (*parm_map)[i].parm_index = MODREF_LOCAL_MEMORY_PARM;\n \t      continue;\n \t    }\n \n@@ -3600,7 +3615,7 @@ compute_parm_map (cgraph_edge *callee_edge, vec<modref_parm_map> *parm_map)\n \t\t\t\t\t\t (callee_pi, i));\n \t      if (cst && points_to_local_or_readonly_memory_p (cst))\n \t\t{\n-\t\t  (*parm_map)[i].parm_index = -2;\n+\t\t  (*parm_map)[i].parm_index = MODREF_LOCAL_MEMORY_PARM;\n \t\t  continue;\n \t\t}\n \t    }\n@@ -3798,9 +3813,9 @@ propagate_unknown_call (cgraph_node *node,\n \t\t   || fnspec.arg_maybe_read_p (i))\n \t    {\n \t      modref_parm_map map = parm_map[i];\n-\t      if (map.parm_index == -2)\n+\t      if (map.parm_index == MODREF_LOCAL_MEMORY_PARM)\n \t\tcontinue;\n-\t      if (map.parm_index == -1)\n+\t      if (map.parm_index == MODREF_UNKNOWN_PARM)\n \t\t{\n \t\t  collapse_loads (cur_summary, cur_summary_lto);\n \t\t  break;\n@@ -3828,9 +3843,9 @@ propagate_unknown_call (cgraph_node *node,\n \t\t   || fnspec.arg_maybe_written_p (i))\n \t    {\n \t      modref_parm_map map = parm_map[i];\n-\t      if (map.parm_index == -2)\n+\t      if (map.parm_index == MODREF_LOCAL_MEMORY_PARM)\n \t\tcontinue;\n-\t      if (map.parm_index == -1)\n+\t      if (map.parm_index == MODREF_UNKNOWN_PARM)\n \t\t{\n \t\t  collapse_stores (cur_summary, cur_summary_lto);\n \t\t  break;\n@@ -4030,19 +4045,24 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \n \n \t      auto_vec <modref_parm_map, 32> parm_map;\n+\t      modref_parm_map chain_map;\n+\t      /* TODO: Once we get jump functions for static chains we could\n+\t\t compute this.  */\n+\t      chain_map.parm_index = MODREF_UNKNOWN_PARM;\n \n \t      compute_parm_map (callee_edge, &parm_map);\n \n \t      /* Merge in callee's information.  */\n \t      if (callee_summary)\n \t\t{\n \t\t  changed |= cur_summary->loads->merge\n-\t\t\t\t  (callee_summary->loads, &parm_map, !first);\n+\t\t\t\t  (callee_summary->loads, &parm_map,\n+\t\t\t\t   &chain_map, !first);\n \t\t  if (!ignore_stores)\n \t\t    {\n \t\t      changed |= cur_summary->stores->merge\n \t\t\t\t      (callee_summary->stores, &parm_map,\n-\t\t\t\t       !first);\n+\t\t\t\t       &chain_map, !first);\n \t\t      if (!cur_summary->writes_errno\n \t\t\t  && callee_summary->writes_errno)\n \t\t\t{\n@@ -4055,12 +4075,12 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t{\n \t\t  changed |= cur_summary_lto->loads->merge\n \t\t\t\t  (callee_summary_lto->loads, &parm_map,\n-\t\t\t\t   !first);\n+\t\t\t\t   &chain_map, !first);\n \t\t  if (!ignore_stores)\n \t\t    {\n \t\t      changed |= cur_summary_lto->stores->merge\n \t\t\t\t      (callee_summary_lto->stores, &parm_map,\n-\t\t\t\t       !first);\n+\t\t\t\t       &chain_map, !first);\n \t\t      if (!cur_summary_lto->writes_errno\n \t\t\t  && callee_summary_lto->writes_errno)\n \t\t\t{\n@@ -4223,9 +4243,9 @@ modref_merge_call_site_flags (escape_summary *sum,\n       if (!(flags & EAF_UNUSED)\n \t  && cur_summary && ee->parm_index < (int)cur_summary->arg_flags.length ())\n \t{\n-\t  eaf_flags_t &f = ee->parm_index == escape_point::retslot_arg\n+\t  eaf_flags_t &f = ee->parm_index == MODREF_RETSLOT_PARM\n \t\t\t   ? cur_summary->retslot_flags\n-\t\t\t   : ee->parm_index == escape_point::static_chain_arg\n+\t\t\t   : ee->parm_index == MODREF_STATIC_CHAIN_PARM\n \t\t\t   ? cur_summary->static_chain_flags\n \t\t\t   : cur_summary->arg_flags[ee->parm_index];\n \t  if ((f & flags) != f)\n@@ -4240,9 +4260,9 @@ modref_merge_call_site_flags (escape_summary *sum,\n \t  && cur_summary_lto\n \t  && ee->parm_index < (int)cur_summary_lto->arg_flags.length ())\n \t{\n-\t  eaf_flags_t &f = ee->parm_index == escape_point::retslot_arg\n+\t  eaf_flags_t &f = ee->parm_index == MODREF_RETSLOT_PARM\n \t\t\t   ? cur_summary_lto->retslot_flags\n-\t\t\t   : ee->parm_index == escape_point::static_chain_arg\n+\t\t\t   : ee->parm_index == MODREF_STATIC_CHAIN_PARM\n \t\t\t   ? cur_summary_lto->static_chain_flags\n \t\t\t   : cur_summary_lto->arg_flags[ee->parm_index];\n \t  if ((f & flags_lto) != f)\n@@ -4428,24 +4448,30 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n   if (callee_info || callee_info_lto)\n     {\n       auto_vec <modref_parm_map, 32> parm_map;\n+      modref_parm_map chain_map;\n+      /* TODO: Once we get jump functions for static chains we could\n+\t compute this.  */\n+      chain_map.parm_index = MODREF_UNKNOWN_PARM;\n \n       compute_parm_map (edge, &parm_map);\n \n       if (!ignore_stores)\n \t{\n \t  if (to_info && callee_info)\n-\t    to_info->stores->merge (callee_info->stores, &parm_map, false);\n+\t    to_info->stores->merge (callee_info->stores, &parm_map,\n+\t\t\t\t    &chain_map, false);\n \t  if (to_info_lto && callee_info_lto)\n \t    to_info_lto->stores->merge (callee_info_lto->stores, &parm_map,\n-\t\t\t\t\tfalse);\n+\t\t\t\t\t&chain_map, false);\n \t}\n       if (!(flags & (ECF_CONST | ECF_NOVOPS)))\n \t{\n \t  if (to_info && callee_info)\n-\t    to_info->loads->merge (callee_info->loads, &parm_map, false);\n+\t    to_info->loads->merge (callee_info->loads, &parm_map,\n+\t\t\t\t   &chain_map, false);\n \t  if (to_info_lto && callee_info_lto)\n \t    to_info_lto->loads->merge (callee_info_lto->loads, &parm_map,\n-\t\t\t\t       false);\n+\t\t\t\t       &chain_map, false);\n \t}\n     }\n "}, {"sha": "f8ce0470c4a88d40e5c5b5414f202c14835b4706", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-12.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3a33633dd06a8e4861180ab20c9136361c69e6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3a33633dd06a8e4861180ab20c9136361c69e6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-12.c?ref=1f3a33633dd06a8e4861180ab20c9136361c69e6", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\"  } */\n+void foo ();\n+int\n+test()\n+{\n+  struct {int a,b;} a = {0,0};\n+  __attribute__ ((noinline))\n+  void nested ()\n+  {\n+\t  a.b++;\n+  }\n+  nested ();\n+  return a.a;\n+}\n+/* { dg-final { scan-tree-dump \"return 0\" \"optimized\"} } */"}, {"sha": "eabf6805f2b4a9f72c09cc80a38e6d26dbac089e", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3a33633dd06a8e4861180ab20c9136361c69e6/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3a33633dd06a8e4861180ab20c9136361c69e6/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=1f3a33633dd06a8e4861180ab20c9136361c69e6", "patch": "@@ -2594,14 +2594,18 @@ modref_may_conflict (const gimple *stmt,\n \t      if (num_tests >= max_tests)\n \t\treturn true;\n \n-\t      if (access_node->parm_index == -1\n-\t\t  || (unsigned)access_node->parm_index\n-\t\t     >= gimple_call_num_args (stmt))\n+\t      if (access_node->parm_index == MODREF_UNKNOWN_PARM\n+\t\t  || access_node->parm_index\n+\t\t     >= (int)gimple_call_num_args (stmt))\n \t\treturn true;\n \n \t      alias_stats.modref_baseptr_tests++;\n+\t      tree arg;\n \n-\t      tree arg = gimple_call_arg (stmt, access_node->parm_index);\n+\t      if (access_node->parm_index == MODREF_STATIC_CHAIN_PARM)\n+\t\targ = gimple_call_chain (stmt);\n+\t      else\n+\t\targ = gimple_call_arg (stmt, access_node->parm_index);\n \n \t      if (integer_zerop (arg) && flag_delete_null_pointer_checks)\n \t\tcontinue;"}]}