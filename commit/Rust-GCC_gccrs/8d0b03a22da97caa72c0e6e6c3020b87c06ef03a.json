{"sha": "8d0b03a22da97caa72c0e6e6c3020b87c06ef03a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQwYjAzYTIyZGE5N2NhYTcyYzBlNmU2YzMwMjBiODdjMDZlZjAzYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-04-06T23:07:13Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-04-06T23:07:13Z"}, "message": "Use backend interface for constant switch statements.\n\n\t* go-gcc.cc (if_statement): Use build3_loc.\n\t(Gcc_backend::switch_statement): New function.\n\t(Gcc_backend::statement_list): New function.\n\nFrom-SVN: r172066", "tree": {"sha": "023ebebfe6e01bf9532e434a4cd616d10b5c4872", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/023ebebfe6e01bf9532e434a4cd616d10b5c4872"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d0b03a22da97caa72c0e6e6c3020b87c06ef03a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d0b03a22da97caa72c0e6e6c3020b87c06ef03a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d0b03a22da97caa72c0e6e6c3020b87c06ef03a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d0b03a22da97caa72c0e6e6c3020b87c06ef03a/comments", "author": null, "committer": null, "parents": [{"sha": "d17b0ae1cab1220ed4e43c8972bb962379ef1f7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d17b0ae1cab1220ed4e43c8972bb962379ef1f7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d17b0ae1cab1220ed4e43c8972bb962379ef1f7d"}], "stats": {"total": 352, "additions": 271, "deletions": 81}, "files": [{"sha": "3ee5fb10c0cda17e3b15763498e75021f923a068", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d0b03a22da97caa72c0e6e6c3020b87c06ef03a/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d0b03a22da97caa72c0e6e6c3020b87c06ef03a/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=8d0b03a22da97caa72c0e6e6c3020b87c06ef03a", "patch": "@@ -1,3 +1,9 @@\n+2011-04-06  Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-gcc.cc (if_statement): Use build3_loc.\n+\t(Gcc_backend::switch_statement): New function.\n+\t(Gcc_backend::statement_list): New function.\n+\n 2011-04-06  Ian Lance Taylor  <iant@google.com>\n \n \t* go-gcc.cc (Gcc_backend::if_statement): New function."}, {"sha": "f9efb3c9e9bf3c97212f831eada69ac87c892653", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 90, "deletions": 3, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d0b03a22da97caa72c0e6e6c3020b87c06ef03a/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d0b03a22da97caa72c0e6e6c3020b87c06ef03a/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=8d0b03a22da97caa72c0e6e6c3020b87c06ef03a", "patch": "@@ -180,6 +180,15 @@ class Gcc_backend : public Backend\n   if_statement(Bexpression* condition, Bstatement* then_block,\n \t       Bstatement* else_block, source_location);\n \n+  Bstatement*\n+  switch_statement(Bexpression* value,\n+\t\t   const std::vector<std::vector<Bexpression*> >& cases,\n+\t\t   const std::vector<Bstatement*>& statements,\n+\t\t   source_location);\n+\n+  Bstatement*\n+  statement_list(const std::vector<Bstatement*>&);\n+\n   // Labels.\n \n   Blabel*\n@@ -310,12 +319,90 @@ Gcc_backend::if_statement(Bexpression* condition, Bstatement* then_block,\n       || then_tree == error_mark_node\n       || else_tree == error_mark_node)\n     return this->make_statement(error_mark_node);\n-  tree ret = build3(COND_EXPR, void_type_node, cond_tree, then_tree,\n-\t\t    else_tree);\n-  SET_EXPR_LOCATION(ret, location);\n+  tree ret = build3_loc(location, COND_EXPR, void_type_node, cond_tree,\n+\t\t\tthen_tree, else_tree);\n   return this->make_statement(ret);\n }\n \n+// Switch.\n+\n+Bstatement*\n+Gcc_backend::switch_statement(\n+    Bexpression* value,\n+    const std::vector<std::vector<Bexpression*> >& cases,\n+    const std::vector<Bstatement*>& statements,\n+    source_location switch_location)\n+{\n+  gcc_assert(cases.size() == statements.size());\n+\n+  tree stmt_list = NULL_TREE;\n+  std::vector<std::vector<Bexpression*> >::const_iterator pc = cases.begin();\n+  for (std::vector<Bstatement*>::const_iterator ps = statements.begin();\n+       ps != statements.end();\n+       ++ps, ++pc)\n+    {\n+      if (pc->empty())\n+\t{\n+\t  source_location loc = (*ps != NULL\n+\t\t\t\t ? EXPR_LOCATION((*ps)->get_tree())\n+\t\t\t\t : UNKNOWN_LOCATION);\n+\t  tree label = create_artificial_label(loc);\n+\t  tree c = build3_loc(loc, CASE_LABEL_EXPR, void_type_node, NULL_TREE,\n+\t\t\t      NULL_TREE, label);\n+\t  append_to_statement_list(c, &stmt_list);\n+\t}\n+      else\n+\t{\n+\t  for (std::vector<Bexpression*>::const_iterator pcv = pc->begin();\n+\t       pcv != pc->end();\n+\t       ++pcv)\n+\t    {\n+\t      tree t = (*pcv)->get_tree();\n+\t      if (t == error_mark_node)\n+\t\treturn this->make_statement(error_mark_node);\n+\t      source_location loc = EXPR_LOCATION(t);\n+\t      tree label = create_artificial_label(loc);\n+\t      tree c = build3_loc(loc, CASE_LABEL_EXPR, void_type_node,\n+\t\t\t\t  (*pcv)->get_tree(), NULL_TREE, label);\n+\t      append_to_statement_list(c, &stmt_list);\n+\t    }\n+\t}\n+\n+      if (*ps != NULL)\n+\t{\n+\t  tree t = (*ps)->get_tree();\n+\t  if (t == error_mark_node)\n+\t    return this->make_statement(error_mark_node);\n+\t  append_to_statement_list(t, &stmt_list);\n+\t}\n+    }\n+\n+  tree tv = value->get_tree();\n+  if (tv == error_mark_node)\n+    return this->make_statement(error_mark_node);\n+  tree t = build3_loc(switch_location, SWITCH_EXPR, void_type_node,\n+\t\t      tv, stmt_list, NULL_TREE);\n+  return this->make_statement(t);\n+}\n+\n+// List of statements.\n+\n+Bstatement*\n+Gcc_backend::statement_list(const std::vector<Bstatement*>& statements)\n+{\n+  tree stmt_list = NULL_TREE;\n+  for (std::vector<Bstatement*>::const_iterator p = statements.begin();\n+       p != statements.end();\n+       ++p)\n+    {\n+      tree t = (*p)->get_tree();\n+      if (t == error_mark_node)\n+\treturn this->make_statement(error_mark_node);\n+      append_to_statement_list(t, &stmt_list);\n+    }\n+  return this->make_statement(stmt_list);\n+}\n+\n // Make a label.\n \n Blabel*"}, {"sha": "01f3cfa4c2bec586b81a3f58dec9484aabc2c9b7", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d0b03a22da97caa72c0e6e6c3020b87c06ef03a/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d0b03a22da97caa72c0e6e6c3020b87c06ef03a/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=8d0b03a22da97caa72c0e6e6c3020b87c06ef03a", "patch": "@@ -127,6 +127,23 @@ class Backend\n   if_statement(Bexpression* condition, Bstatement* then_block,\n \t       Bstatement* else_block, source_location) = 0;\n \n+  // Create a switch statement where the case values are constants.\n+  // CASES and STATEMENTS must have the same number of entries.  If\n+  // VALUE matches any of the list in CASES[i], which will all be\n+  // integers, then STATEMENTS[i] is executed.  STATEMENTS[i] will\n+  // either end with a goto statement or will fall through into\n+  // STATEMENTS[i + 1].  CASES[i] is empty for the default clause,\n+  // which need not be last.\n+  virtual Bstatement*\n+  switch_statement(Bexpression* value,\n+\t\t   const std::vector<std::vector<Bexpression*> >& cases,\n+\t\t   const std::vector<Bstatement*>& statements,\n+\t\t   source_location) = 0;\n+\n+  // Create a single statement from a list of statements.\n+  virtual Bstatement*\n+  statement_list(const std::vector<Bstatement*>&) = 0;\n+\n   // Labels.\n   \n   // Create a new label.  NAME will be empty if this is a label"}, {"sha": "f84b2d4ae92311d067cd22f1700b026e1c3bd452", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 143, "deletions": 70, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d0b03a22da97caa72c0e6e6c3020b87c06ef03a/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d0b03a22da97caa72c0e6e6c3020b87c06ef03a/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=8d0b03a22da97caa72c0e6e6c3020b87c06ef03a", "patch": "@@ -2934,6 +2934,55 @@ Statement::make_if_statement(Expression* cond, Block* then_block,\n   return new If_statement(cond, then_block, else_block, location);\n }\n \n+// Class Case_clauses::Hash_integer_value.\n+\n+class Case_clauses::Hash_integer_value\n+{\n+ public:\n+  size_t\n+  operator()(Expression*) const;\n+};\n+\n+size_t\n+Case_clauses::Hash_integer_value::operator()(Expression* pe) const\n+{\n+  Type* itype;\n+  mpz_t ival;\n+  mpz_init(ival);\n+  if (!pe->integer_constant_value(true, ival, &itype))\n+    gcc_unreachable();\n+  size_t ret = mpz_get_ui(ival);\n+  mpz_clear(ival);\n+  return ret;\n+}\n+\n+// Class Case_clauses::Eq_integer_value.\n+\n+class Case_clauses::Eq_integer_value\n+{\n+ public:\n+  bool\n+  operator()(Expression*, Expression*) const;\n+};\n+\n+bool\n+Case_clauses::Eq_integer_value::operator()(Expression* a, Expression* b) const\n+{\n+  Type* atype;\n+  Type* btype;\n+  mpz_t aval;\n+  mpz_t bval;\n+  mpz_init(aval);\n+  mpz_init(bval);\n+  if (!a->integer_constant_value(true, aval, &atype)\n+      || !b->integer_constant_value(true, bval, &btype))\n+    gcc_unreachable();\n+  bool ret = mpz_cmp(aval, bval) == 0;\n+  mpz_clear(aval);\n+  mpz_clear(bval);\n+  return ret;\n+}\n+\n // Class Case_clauses::Case_clause.\n \n // Traversal.\n@@ -3090,76 +3139,82 @@ Case_clauses::Case_clause::may_fall_through() const\n   return this->statements_->may_fall_through();\n }\n \n-// Build up the body of a SWITCH_EXPR.\n+// Convert the case values and statements to the backend\n+// representation.  BREAK_LABEL is the label which break statements\n+// should branch to.  CASE_CONSTANTS is used to detect duplicate\n+// constants.  *CASES should be passed as an empty vector; the values\n+// for this case will be added to it.  If this is the default case,\n+// *CASES will remain empty.  This returns the statement to execute if\n+// one of these cases is selected.\n \n-void\n-Case_clauses::Case_clause::get_constant_tree(Translate_context* context,\n-\t\t\t\t\t     Unnamed_label* break_label,\n-\t\t\t\t\t     Case_constants* case_constants,\n-\t\t\t\t\t     tree* stmt_list) const\n+Bstatement*\n+Case_clauses::Case_clause::get_backend(Translate_context* context,\n+\t\t\t\t       Unnamed_label* break_label,\n+\t\t\t\t       Case_constants* case_constants,\n+\t\t\t\t       std::vector<Bexpression*>* cases) const\n {\n   if (this->cases_ != NULL)\n     {\n+      gcc_assert(!this->is_default_);\n       for (Expression_list::const_iterator p = this->cases_->begin();\n \t   p != this->cases_->end();\n \t   ++p)\n \t{\n-\t  Type* itype;\n-\t  mpz_t ival;\n-\t  mpz_init(ival);\n-\t  if (!(*p)->integer_constant_value(true, ival, &itype))\n+\t  Expression* e = *p;\n+\t  if (e->classification() != Expression::EXPRESSION_INTEGER)\n \t    {\n-\t      // Something went wrong.  This can happen with a\n-\t      // negative constant and an unsigned switch value.\n-\t      gcc_assert(saw_errors());\n-\t      continue;\n-\t    }\n-\t  gcc_assert(itype != NULL);\n-\t  tree type_tree = itype->get_tree(context->gogo());\n-\t  tree val = Expression::integer_constant_tree(ival, type_tree);\n-\t  mpz_clear(ival);\n-\n-\t  if (val != error_mark_node)\n-\t    {\n-\t      gcc_assert(TREE_CODE(val) == INTEGER_CST);\n-\n-\t      std::pair<Case_constants::iterator, bool> ins =\n-\t\tcase_constants->insert(val);\n-\t      if (!ins.second)\n+\t      Type* itype;\n+\t      mpz_t ival;\n+\t      mpz_init(ival);\n+\t      if (!(*p)->integer_constant_value(true, ival, &itype))\n \t\t{\n-\t\t  // Value was already present.\n-\t\t  warning_at(this->location_, 0,\n-\t\t\t     \"duplicate case value will never match\");\n+\t\t  // Something went wrong.  This can happen with a\n+\t\t  // negative constant and an unsigned switch value.\n+\t\t  gcc_assert(saw_errors());\n \t\t  continue;\n \t\t}\n+\t      gcc_assert(itype != NULL);\n+\t      e = Expression::make_integer(&ival, itype, e->location());\n+\t      mpz_clear(ival);\n+\t    }\n \n-\t      tree label = create_artificial_label(this->location_);\n-\t      append_to_statement_list(build3(CASE_LABEL_EXPR, void_type_node,\n-\t\t\t\t\t      val, NULL_TREE, label),\n-\t\t\t\t       stmt_list);\n+\t  std::pair<Case_constants::iterator, bool> ins =\n+\t    case_constants->insert(e);\n+\t  if (!ins.second)\n+\t    {\n+\t      // Value was already present.\n+\t      error_at(this->location_, \"duplicate case in switch\");\n+\t      continue;\n \t    }\n+\n+\t  tree case_tree = e->get_tree(context);\n+\t  Bexpression* case_expr = tree_to_expr(case_tree);\n+\t  cases->push_back(case_expr);\n \t}\n     }\n \n-  if (this->is_default_)\n-    {\n-      tree label = create_artificial_label(this->location_);\n-      append_to_statement_list(build3(CASE_LABEL_EXPR, void_type_node,\n-\t\t\t\t      NULL_TREE, NULL_TREE, label),\n-\t\t\t       stmt_list);\n-    }\n+  Bstatement* statements;\n+  if (this->statements_ == NULL)\n+    statements = NULL;\n+  else\n+    statements = tree_to_stat(this->statements_->get_tree(context));\n \n-  if (this->statements_ != NULL)\n-    {\n-      tree block_tree = this->statements_->get_tree(context);\n-      if (block_tree != error_mark_node)\n-\tappend_to_statement_list(block_tree, stmt_list);\n-    }\n+  Bstatement* break_stat;\n+  if (this->is_fallthrough_)\n+    break_stat = NULL;\n+  else\n+    break_stat = break_label->get_goto(context, this->location_);\n \n-  if (!this->is_fallthrough_)\n+  if (statements == NULL)\n+    return break_stat;\n+  else if (break_stat == NULL)\n+    return statements;\n+  else\n     {\n-      Bstatement* g = break_label->get_goto(context, this->location_);\n-      append_to_statement_list(stat_to_tree(g), stmt_list);\n+      std::vector<Bstatement*> list(2);\n+      list[0] = statements;\n+      list[1] = break_stat;\n+      return context->backend()->statement_list(list);\n     }\n }\n \n@@ -3297,20 +3352,32 @@ Case_clauses::may_fall_through() const\n   return !found_default;\n }\n \n-// Return a tree when all case expressions are constants.\n+// Convert the cases to the backend representation.  This sets\n+// *ALL_CASES and *ALL_STATEMENTS.\n \n-tree\n-Case_clauses::get_constant_tree(Translate_context* context,\n-\t\t\t\tUnnamed_label* break_label) const\n+void\n+Case_clauses::get_backend(Translate_context* context,\n+\t\t\t  Unnamed_label* break_label,\n+\t\t\t  std::vector<std::vector<Bexpression*> >* all_cases,\n+\t\t\t  std::vector<Bstatement*>* all_statements) const\n {\n   Case_constants case_constants;\n-  tree stmt_list = NULL_TREE;\n+\n+  size_t c = this->clauses_.size();\n+  all_cases->resize(c);\n+  all_statements->resize(c);\n+\n+  size_t i = 0;\n   for (Clauses::const_iterator p = this->clauses_.begin();\n        p != this->clauses_.end();\n-       ++p)\n-    p->get_constant_tree(context, break_label, &case_constants,\n-\t\t\t &stmt_list);\n-  return stmt_list;\n+       ++p, ++i)\n+    {\n+      std::vector<Bexpression*> cases;\n+      Bstatement* stat = p->get_backend(context, break_label, &case_constants,\n+\t\t\t\t\t&cases);\n+      (*all_cases)[i].swap(cases);\n+      (*all_statements)[i] = stat;\n+    }\n }\n \n // A constant switch statement.  A Switch_statement is lowered to this\n@@ -3401,22 +3468,28 @@ tree\n Constant_switch_statement::do_get_tree(Translate_context* context)\n {\n   tree switch_val_tree = this->val_->get_tree(context);\n+  Bexpression* switch_val_expr = tree_to_expr(switch_val_tree);\n \n   Unnamed_label* break_label = this->break_label_;\n   if (break_label == NULL)\n     break_label = new Unnamed_label(this->location());\n \n-  tree stmt_list = NULL_TREE;\n-  tree s = build3(SWITCH_EXPR, void_type_node, switch_val_tree,\n-\t\t  this->clauses_->get_constant_tree(context, break_label),\n-\t\t  NULL_TREE);\n-  SET_EXPR_LOCATION(s, this->location());\n-  append_to_statement_list(s, &stmt_list);\n-\n-  Bstatement* ldef = break_label->get_definition(context);\n-  append_to_statement_list(stat_to_tree(ldef), &stmt_list);\n-\n-  return stmt_list;\n+  std::vector<std::vector<Bexpression*> > all_cases;\n+  std::vector<Bstatement*> all_statements;\n+  this->clauses_->get_backend(context, break_label, &all_cases,\n+\t\t\t      &all_statements);\n+\n+  Bstatement* switch_statement;\n+  switch_statement = context->backend()->switch_statement(switch_val_expr,\n+\t\t\t\t\t\t\t  all_cases,\n+\t\t\t\t\t\t\t  all_statements,\n+\t\t\t\t\t\t\t  this->location());\n+\n+  std::vector<Bstatement*> stats(2);\n+  stats[0] = switch_statement;\n+  stats[1] = break_label->get_definition(context);\n+  Bstatement* ret = context->backend()->statement_list(stats);\n+  return stat_to_tree(ret);\n }\n \n // Class Switch_statement."}, {"sha": "826cd0cc05f14e50080316a64b69d2dc3820ed1e", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d0b03a22da97caa72c0e6e6c3020b87c06ef03a/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d0b03a22da97caa72c0e6e6c3020b87c06ef03a/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=8d0b03a22da97caa72c0e6e6c3020b87c06ef03a", "patch": "@@ -39,6 +39,8 @@ class Case_clauses;\n class Type_case_clauses;\n class Select_clauses;\n class Typed_identifier_list;\n+class Bexpression;\n+class Bstatement;\n \n // This class is used to traverse assignments made by a statement\n // which makes assignments.\n@@ -1162,13 +1164,18 @@ class Case_clauses\n \n   // Return the body of a SWITCH_EXPR when all the clauses are\n   // constants.\n-  tree\n-  get_constant_tree(Translate_context*, Unnamed_label* break_label) const;\n+  void\n+  get_backend(Translate_context*, Unnamed_label* break_label,\n+\t      std::vector<std::vector<Bexpression*> >* all_cases,\n+\t      std::vector<Bstatement*>* all_statements) const;\n \n  private:\n   // For a constant tree we need to keep a record of constants we have\n   // already seen.  Note that INTEGER_CST trees are interned.\n-  typedef Unordered_set(tree) Case_constants;\n+  class Hash_integer_value;\n+  class Eq_integer_value;\n+  typedef Unordered_set_hash(Expression*, Hash_integer_value,\n+\t\t\t     Eq_integer_value) Case_constants;\n \n   // One case clause.\n   class Case_clause\n@@ -1226,11 +1233,11 @@ class Case_clauses\n     bool\n     may_fall_through() const;\n \n-    // Build up the body of a SWITCH_EXPR when the case expressions\n-    // are constant.\n-    void\n-    get_constant_tree(Translate_context*, Unnamed_label* break_label,\n-\t\t      Case_constants* case_constants, tree* stmt_list) const;\n+    // Convert the case values and statements to the backend\n+    // representation.\n+    Bstatement*\n+    get_backend(Translate_context*, Unnamed_label* break_label,\n+\t\tCase_constants*, std::vector<Bexpression*>* cases) const;\n \n    private:\n     // The list of case expressions."}]}