{"sha": "69b182fda603ed65448103a22ce4ad76744e6229", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjliMTgyZmRhNjAzZWQ2NTQ0ODEwM2EyMmNlNGFkNzY3NDRlNjIyOQ==", "commit": {"author": {"name": "Andreas Tobler", "email": "a.tobler@schweiz.ch", "date": "2003-09-18T18:23:47Z"}, "committer": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2003-09-18T18:23:47Z"}, "message": "types.c (double): Add AIX and Darwin to the right TYPEDEF.\n\n2003-09-18  Andreas Tobler  <a.tobler@schweiz.ch>\n\t    David Edelsohn  <edelsohn@gnu.org>\n\n\t* src/types.c (double): Add AIX and Darwin to the right TYPEDEF.\n\t* src/powerpc/aix_closure.S: Remove the pointer to the outgoing\n\tparameter stack.\n\t* src/powerpc/darwin_closure.S: Likewise.\n\t* src/powerpc/ffi_darwin.c (ffi_prep_args): Handle structures\n\taccording to the Darwin/AIX ABI.\n\t(ffi_prep_cif_machdep): Likewise.\n\t(ffi_closure_helper_DARWIN): Likewise.\n\tRemove the outgoing parameter stack logic. Simplify the evaluation\n\tof the different CASE types.\n\t(ffi_prep_clousure): Avoid the casts on lvalues. Change the branch\n\tstatement in the trampoline code.\n\nCo-Authored-By: David Edelsohn <edelsohn@gnu.org>\n\nFrom-SVN: r71530", "tree": {"sha": "99afd39ab065417371a20ca4fe2ef9d169b8e006", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99afd39ab065417371a20ca4fe2ef9d169b8e006"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69b182fda603ed65448103a22ce4ad76744e6229", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69b182fda603ed65448103a22ce4ad76744e6229", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69b182fda603ed65448103a22ce4ad76744e6229", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69b182fda603ed65448103a22ce4ad76744e6229/comments", "author": null, "committer": null, "parents": [{"sha": "85b22f7857a745d8ec12d88d61b770a598208ecf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85b22f7857a745d8ec12d88d61b770a598208ecf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85b22f7857a745d8ec12d88d61b770a598208ecf"}], "stats": {"total": 368, "additions": 184, "deletions": 184}, "files": [{"sha": "1dd4096112d4136e05ed45bbdc0f67b2d711dcf5", "filename": "libffi/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b182fda603ed65448103a22ce4ad76744e6229/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b182fda603ed65448103a22ce4ad76744e6229/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=69b182fda603ed65448103a22ce4ad76744e6229", "patch": "@@ -1,3 +1,19 @@\n+2003-09-18  Andreas Tobler  <a.tobler@schweiz.ch>\n+\t    David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* src/types.c (double): Add AIX and Darwin to the right TYPEDEF.\n+\t* src/powerpc/aix_closure.S: Remove the pointer to the outgoing\n+\tparameter stack.\n+\t* src/powerpc/darwin_closure.S: Likewise.\n+\t* src/powerpc/ffi_darwin.c (ffi_prep_args): Handle structures\n+\taccording to the Darwin/AIX ABI.\n+\t(ffi_prep_cif_machdep): Likewise.\n+\t(ffi_closure_helper_DARWIN): Likewise.\n+\tRemove the outgoing parameter stack logic. Simplify the evaluation\n+\tof the different CASE types.\n+\t(ffi_prep_clousure): Avoid the casts on lvalues. Change the branch\n+\tstatement in the trampoline code.\n+\n 2003-09-18  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* src/sh/ffi.c (ffi_prep_args): Take account into the alignement"}, {"sha": "bb5818b44c23b07ccda45854fd9817325ef50a63", "filename": "libffi/src/powerpc/aix_closure.S", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b182fda603ed65448103a22ce4ad76744e6229/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b182fda603ed65448103a22ce4ad76744e6229/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S?ref=69b182fda603ed65448103a22ce4ad76744e6229", "patch": "@@ -105,8 +105,8 @@ ffi_closure_ASM:\n \t\n \t/* 24 Bytes (Linkage Area) */\n \t/* 32 Bytes (params) */\n-\t/* 104 Bytes (13*8 from FPR) */ \n-\t/* 8 Bytes (result)\n+\t/* 104 Bytes (13*8 from FPR) */\n+\t/* 8 Bytes (result) */\n \t/* 168 Bytes */\n \t\n \tstwu r1,-176(r1)\t/* skip over caller save area\n@@ -144,20 +144,16 @@ ffi_closure_ASM:\n \t/* set up registers for the routine that actually does the work */\n \t/* get the context pointer from the trampoline */\n \tmr r3,r11\n-\t\n+\n \t/* now load up the pointer to the result storage */\n \taddi r4,r1,160\n-\t\n+\n \t/* now load up the pointer to the saved gpr registers */\n \taddi r5,r1,200\n \n \t/* now load up the pointer to the saved fpr registers */\n \taddi r6,r1,56\n \n-\t/* now load up the pointer to the outgoing parameter  */\n-\t/* stack in the previous frame */\n-\taddi r7,r1,232\n-\t\n \t/* make the call */\n \tbl .ffi_closure_helper_DARWIN\n \tnop"}, {"sha": "5dfa44b4fddf1b66fd01f3f533e88651b24142ad", "filename": "libffi/src/powerpc/darwin_closure.S", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b182fda603ed65448103a22ce4ad76744e6229/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b182fda603ed65448103a22ce4ad76744e6229/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S?ref=69b182fda603ed65448103a22ce4ad76744e6229", "patch": "@@ -31,7 +31,7 @@\n .text\n \t.align 2\t\n .globl _ffi_closure_ASM\n-\t\n+\n .text\n \t.align 2\n _ffi_closure_ASM:\n@@ -44,13 +44,13 @@ LCFI0:\n \t   104 Bytes (13*8 from FPR)\t\n \t   8 Bytes (result)\n \t   168 Bytes  */\n-\t\n+\n \tstwu\tr1,-176(r1)\t/* skip over caller save area\n \t\t\t\tkeep stack aligned to 16  */\n LCFI1:\t\t\n \t/* we want to build up an area for the parameters passed\n \tin registers (both floating point and integer)  */\n-\t\n+\n \t/* we store gpr 3 to gpr 10 (aligned to 4)\n \tin the parents outgoing area  */\n \tstw   r3, 200(r1)\n@@ -80,23 +80,19 @@ LCFI1:\n \t/* set up registers for the routine that actually does the work */\n \t/* get the context pointer from the trampoline */\n \tmr r3,r11\n-\t\n+\n \t/* now load up the pointer to the result storage */\n \taddi r4,r1,160\n-\t\n+\n \t/* now load up the pointer to the saved gpr registers  */\n \taddi r5,r1,200\n \n \t/* now load up the pointer to the saved fpr registers */\n \taddi r6,r1,56\n \n-\t/* now load up the pointer to the outgoing parameter\n-\tstack in the previous frame  */\n-\taddi r7,r1,232\n-\t\n \t/* make the call */\n \tbl\tLffi_closure_helper_DARWIN$stub\n-\t\n+\n \t/* now r3 contains the return type */\n \t/* so use it to look up in a table */\n \t/* so we know how to deal with each type */\n@@ -114,7 +110,7 @@ LFE1:\n /* Each of the ret_typeX code fragments has to be exactly 16 bytes long  */\n /* (4 instructions). For cache effectiveness we align to a 16 byte boundary  */\n /* first.  */\n-\t\n+\n \t.align 4\n \n \tnop\n@@ -234,7 +230,7 @@ Lfinish:\n \tlwz\tr0,8(r1)\t\t/* get return address  */\n \tmtlr\tr0\t\t\t/* reset link register  */\n \tblr\n-\t\t\n+\t\n /* END(ffi_closure_ASM)  */\t\n \n .data"}, {"sha": "fee5243db71f86fe22149a1526c0f7738e9e7182", "filename": "libffi/src/powerpc/ffi_darwin.c", "status": "modified", "additions": 155, "deletions": 163, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b182fda603ed65448103a22ce4ad76744e6229/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b182fda603ed65448103a22ce4ad76744e6229/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c?ref=69b182fda603ed65448103a22ce4ad76744e6229", "patch": "@@ -29,7 +29,7 @@\n #include <ffi_common.h>\n \n #include <stdlib.h>\n-   \n+\n extern void ffi_closure_ASM(void);\n \n enum {\n@@ -81,8 +81,7 @@ enum { ASM_NEEDS_REGISTERS = 4 };\n void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n /*@=exportheader@*/\n {\n-  const unsigned bytes = ecif->cif->bytes;\n-  const unsigned flags = ecif->cif->flags; \n+  const unsigned flags = ecif->cif->flags;\n \n   /* 'stacktop' points at the previous backchain pointer.  */\n   unsigned *const stacktop = stack + (ecif->cif->bytes / sizeof(unsigned));\n@@ -96,12 +95,13 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n   /* 'next_arg' grows up as we put parameters in it.  */\n   unsigned *next_arg = stack + 6; // 6 reserved posistions. \n \n-  int i=ecif->cif->nargs;\n+  int i = ecif->cif->nargs;\n   double double_tmp;\n-  float float_tmp;\n   void **p_argv = ecif->avalue;\n   unsigned gprvalue;\n   ffi_type** ptr = ecif->cif->arg_types;\n+  char *dest_cpy;\n+  unsigned size_al = 0;\n \n   /* Check that everything starts aligned properly.  */\n   FFI_ASSERT(((unsigned)(char *)stack & 0xF) == 0);\n@@ -163,16 +163,29 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n \t  gprvalue = *(signed short *)*p_argv;\n \t  goto putgpr;\n \n-        case FFI_TYPE_STRUCT:\n+\tcase FFI_TYPE_STRUCT:\n \n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-        case FFI_TYPE_LONGDOUBLE:\n+\tcase FFI_TYPE_LONGDOUBLE:\n #endif\n-\t  \n-\t  memcpy((char*)next_arg, (char *)*p_argv, (*ptr)->size);\n-\t  next_arg+=(((((*ptr)->size) + 3) & ~0x3)/4);\t\n-        break;\t  \n-\t  \n+\t  dest_cpy = (char *) next_arg;\n+\n+\t  /* Structures that match the basic modes (QI 1 byte, HI 2 bytes,\n+\t     SI 4 bytes) are aligned as if they were those modes.\n+\t     Structures with 3 byte in size are padded upwards.  */\n+\t  size_al = (*ptr)->size;\n+\t  /* If the first member of the struct is a double, then align\n+\t     the struct to double-word.\n+\t     Type 3 is defined in include/ffi.h. #define FFI_TYPE_DOUBLE 3.  */\n+\t  if ((*ptr)->elements[0]->type == 3)\n+\t    size_al = ALIGN((*ptr)->size, 8);\n+\t  if (size_al < 3 && ecif->cif->abi == FFI_DARWIN)\n+\t    dest_cpy += 4 - size_al;\n+\n+\t  memcpy((char *)dest_cpy, (char *)*p_argv, size_al);\n+\t  next_arg += (size_al + 3) / 4;\n+\t  break;\n+\n \tcase FFI_TYPE_INT:\n    \tcase FFI_TYPE_UINT32:\n \tcase FFI_TYPE_SINT32:\n@@ -187,7 +200,6 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n     }\n \n   /* Check that we didn't overrun the stack...  */\n-  //FFI_ASSERT(copy_space >= (char *)next_arg);\n   //FFI_ASSERT(gpr_base <= stacktop - ASM_NEEDS_REGISTERS);\n   //FFI_ASSERT((unsigned *)fpr_base\n   //\t     <= stacktop - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS);\n@@ -203,7 +215,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n   unsigned bytes;\n   int fparg_count = 0, intarg_count = 0;\n   unsigned flags = 0;\n-  unsigned struct_copy_size = 0;\n+  unsigned size_al = 0;\n \n   /* All the machine-independent calculation of cif->bytes will be wrong.\n      Redo the calculation for DARWIN.  */\n@@ -281,7 +293,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \t     on the stack.  If they go on the stack, they must\n \t     be 8-byte-aligned.  */\n \t  if (intarg_count == NUM_GPR_ARG_REGISTERS-1\n-\t      || intarg_count >= NUM_GPR_ARG_REGISTERS && intarg_count%2 != 0)\n+\t      || (intarg_count >= NUM_GPR_ARG_REGISTERS && intarg_count%2 != 0))\n \t    intarg_count++;\n \t  intarg_count += 2;\n \t  break;\n@@ -290,7 +302,13 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \tcase FFI_TYPE_LONGDOUBLE:\n #endif\n-\t  intarg_count+=(((*ptr)->size + 3) & ~0x3)/4;\n+\t  size_al = (*ptr)->size;\n+\t  /* If the first member of the struct is a double, then align\n+\t     the struct to double-word.\n+\t     Type 3 is defined in include/ffi.h. #define FFI_TYPE_DOUBLE 3.  */\n+\t  if ((*ptr)->elements[0]->type == 3)\n+\t    size_al = ALIGN((*ptr)->size, 8);\n+\t  intarg_count += (size_al + 3) / 4;\n \t  break;\n \n \tdefault:\n@@ -303,9 +321,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \n   if (fparg_count != 0)\n     flags |= FLAG_FP_ARGUMENTS;\n-  if (struct_copy_size != 0)\n-    flags |= FLAG_ARG_NEEDS_COPY;\n-  \n+\n   /* Space for the FPR registers, if needed.  */\n   if (fparg_count != 0)\n     bytes += NUM_FPR_ARG_REGISTERS * sizeof(double);\n@@ -321,7 +337,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \n   cif->flags = flags;\n   cif->bytes = bytes;\n-  \n+\n   return FFI_OK;\n }\n \n@@ -349,7 +365,7 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n \n   ecif.cif = cif;\n   ecif.avalue = avalue;\n-  \n+\n   /* If the return value is a struct and we don't have a return\t*/\n   /* value address then we need to make one\t\t        */\n \n@@ -362,7 +378,7 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n     }\n   else\n     ecif.rvalue = rvalue;\n-    \n+\n   switch (cif->abi) \n     {\n     case FFI_AIX:\n@@ -385,7 +401,7 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n \n static void flush_icache(char *);\n static void flush_range(char *, int);\n-   \n+\n /* The layout of a function descriptor.  A C function pointer really    */\n /* points to one of these.                                              */\n \n@@ -397,7 +413,7 @@ typedef struct aix_fd_struct {\n /* here I'd like to add the stack frame layout we use in darwin_closure.S\n  * and aix_clsoure.S\n  *\n-/* SP previous -> +---------------------------------------+ <--- child frame\n+ * SP previous -> +---------------------------------------+ <--- child frame\n                   | back chain to caller 4                | \n                   +---------------------------------------+ 4\n                   | saved CR 4                            | \n@@ -441,7 +457,7 @@ SP current -->    +---------------------------------------+ 176 <- parent frame\n                   | .                                     |\n                   | r10                                   |\n                   +---------------------------------------+ 232\n-                  | PST area, overflow part               | \n+                  | overflow part                         | \n                   +---------------------------------------+ xxx\n                   | ????                                  | \n                   +---------------------------------------+ xxx\n@@ -456,32 +472,32 @@ ffi_prep_closure (ffi_closure* closure,\n   unsigned int *tramp;\n   struct ffi_aix_trampoline_struct *tramp_aix;\n   aix_fd *fd;\n- \n+\n   switch (cif->abi)\n     {  \n     case FFI_DARWIN:\n \n       FFI_ASSERT (cif->abi == FFI_DARWIN);\n \n       tramp = (unsigned int *) &closure->tramp[0];\n-      tramp[0] = 0x7c0802a6;  /*   mflr    r0 */\n-      tramp[1] = 0x4800000d;  /*   bl      10 <trampoline_initial+0x10> */\n-      tramp[4] = 0x7d6802a6;  /*   mflr    r11 */\n-      tramp[5] = 0x818b0000;  /*   lwz     r12,0(r11)  /* function address */\n-      tramp[6] = 0x7c0803a6;  /*   mtlr    r0  */\n-      tramp[7] = 0x7d8903a6;  /*   mtctr   r12 */\n-      tramp[8] = 0x816b0004;  /*   lwz     r11,4(r11)  /* static chain */\n-      tramp[9] = 0x4e800420;  /*   bctr */\n-      *(void **) &tramp[2] = (void *)ffi_closure_ASM; /* function */\n-      *(void **) &tramp[3] = (void *)closure;          /* context */\n+      tramp[0] = 0x7c0802a6;  /*   mflr    r0  */\n+      tramp[1] = 0x429f000d;  /*   bcl-    20,4*cr7+so,0x10  */\n+      tramp[4] = 0x7d6802a6;  /*   mflr    r11  */\n+      tramp[5] = 0x818b0000;  /*   lwz     r12,0(r11) function address  */\n+      tramp[6] = 0x7c0803a6;  /*   mtlr    r0   */\n+      tramp[7] = 0x7d8903a6;  /*   mtctr   r12  */\n+      tramp[8] = 0x816b0004;  /*   lwz     r11,4(r11) static chain  */\n+      tramp[9] = 0x4e800420;  /*   bctr  */\n+      tramp[2] = (unsigned long) ffi_closure_ASM; /* function  */\n+      tramp[3] = (unsigned long) closure; /* context  */\n \n       closure->cif = cif;\n       closure->fun = fun;\n       closure->user_data = user_data;\n \n-      /* Flush the icache. Only necessary on Darwin  */\n+      /* Flush the icache. Only necessary on Darwin.  */\n       flush_range(&closure->tramp[0],FFI_TRAMPOLINE_SIZE);\n-     \n+\n       break;\n \n     case FFI_AIX:\n@@ -530,8 +546,14 @@ flush_range(char * addr1, int size)\n   flush_icache(addr1+size-1);\n }\n \n-int ffi_closure_helper_DARWIN (ffi_closure*, void*, unsigned long*,\n-                                     unsigned long*, unsigned long*);\n+typedef union\n+{\n+  float f;\n+  double d;\n+} ffi_dblfl;\n+\n+int ffi_closure_helper_DARWIN (ffi_closure*, void*,\n+\t\t\t       unsigned long*, ffi_dblfl*);\n \n /* Basically the trampoline invokes ffi_closure_ASM, and on\n  * entry, r11 holds the address of the closure.\n@@ -541,15 +563,13 @@ int ffi_closure_helper_DARWIN (ffi_closure*, void*, unsigned long*,\n  * following helper function to do most of the work\n  */\n \n-int\n-ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n-            unsigned long * pgr, unsigned long * pfr,\n-            unsigned long * pst)\n+int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n+\t\t\t       unsigned long * pgr, ffi_dblfl * pfr)\n {\n-  /* rvalue is the pointer to space for return value in closure assembly */\n-  /* pgr is the pointer to where r3-r10 are stored in ffi_closure_ASM */\n-  /* pfr is the pointer to where f1-f13 are stored in ffi_closure_ASM */\n-  /* pst is the pointer to outgoing parameter stack in original caller */\n+  /* rvalue is the pointer to space for return value in closure assembly\n+     pgr is the pointer to where r3-r10 are stored in ffi_closure_ASM\n+     pfr is the pointer to where f1-f13 are stored in ffi_closure_ASM.  */\n+\n \n   void **          avalue;\n   ffi_type **      arg_types;\n@@ -558,6 +578,7 @@ ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n   long             ng;   /* number of general registers already used */\n   ffi_cif *        cif;\n   double           temp;\n+  unsigned         size_al;\n \n   cif = closure->cif;\n   avalue = alloca(cif->nargs * sizeof(void *));\n@@ -569,9 +590,9 @@ ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n      returns the data directly to the caller.  */\n   if (cif->rtype->type == FFI_TYPE_STRUCT)\n     {\n-      rvalue = (void *)pgr;\n-      ng++;      \n+      rvalue = (void *) *pgr;\n       pgr++;\n+      ng++;\n     }\n \n   i = 0;\n@@ -582,131 +603,102 @@ ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n   while (i < avn)\n     {\n       switch (arg_types[i]->type)\n-        {\n-        case FFI_TYPE_SINT8:\n-        case FFI_TYPE_UINT8:\n-        /* there are 8 gpr registers used to pass values */\n-          if (ng < 8) {\n-             avalue[i] = (((char *)pgr)+3);\n-             ng++;\n-             pgr++;\n-          } else {\n-             avalue[i] = (((char *)pst)+3);\n-             pst++;\n-          }\n-          break;\n-\n-        case FFI_TYPE_SINT16:\n-        case FFI_TYPE_UINT16:\n-        /* there are 8 gpr registers used to pass values */\n-          if (ng < 8) {\n-             avalue[i] = (((char *)pgr)+2);\n-             ng++;\n-             pgr++;\n-          } else {\n-             avalue[i] = (((char *)pst)+2);\n-             pst++;\n-          }\n-          break;\n-\n-        case FFI_TYPE_SINT32:\n-        case FFI_TYPE_UINT32:\n-        case FFI_TYPE_POINTER:\n-        case FFI_TYPE_STRUCT:\n-        /* there are 8 gpr registers used to pass values */\n-          if (ng < 8) {  \n-             avalue[i] = pgr;\n-             ng++;\n-             pgr++;\n-          } else {\n-             avalue[i] = pst;\n-             pst++;\n-          }\n-          break;\n-\n-        case FFI_TYPE_SINT64:\n-        case FFI_TYPE_UINT64:\n-          /* long long ints are passed in two gpr's if available or in \n-           * the pst, one place is a bit odd, when a long long passes\n-\t   * the boundary between gpr and pst area we have to increment\n-\t   * the pst by one.\n-           */\n-           if (ng < 7) {\n-              avalue[i] = pgr;\n-              ng+=2;\n-              pgr+=2;\n-           } else if (ng == 7) {\n-              avalue[i] = pgr;\n-              ng++;\n-              pgr++;\n-              pst++;\n-           } else {\n-              avalue[i] = pst;\n-              pst+=2;\n-           }\n-           break;\n-\n-        case FFI_TYPE_FLOAT:\n-          /* a float value consumes a GPR\n-           *\n-           * there are 13 64bit floating point registers \n+\t{\n+\tcase FFI_TYPE_SINT8:\n+\tcase FFI_TYPE_UINT8:\n+\t  avalue[i] = (char *) pgr + 3;\n+\t  ng++;\n+\t  pgr++;\n+\t  break;\n+\n+\tcase FFI_TYPE_SINT16:\n+\tcase FFI_TYPE_UINT16:\n+\t  avalue[i] = (char *) pgr + 2;\n+\t  ng++;\n+\t  pgr++;\n+\t  break;\n+\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_POINTER:\n+\t  avalue[i] = pgr;\n+\t  ng++;\n+\t  pgr++;\n+\t  break;\n+\n+\tcase FFI_TYPE_STRUCT:\n+\t  /* Structures that match the basic modes (QI 1 byte, HI 2 bytes,\n+\t     SI 4 bytes) are aligned as if they were those modes.  */\n+\t  size_al = arg_types[i]->size;\n+\t  /* If the first member of the struct is a double, then align\n+\t     the struct to double-word.\n+\t     Type 3 is defined in include/ffi.h. #define FFI_TYPE_DOUBLE 3.  */\n+\t  if (arg_types[i]->elements[0]->type == 3)\n+\t    size_al = ALIGN(arg_types[i]->size, 8);\n+\t  if (size_al < 3 && cif->abi == FFI_DARWIN)\n+\t    avalue[i] = (void*) pgr + 4 - size_al;\n+\t  else\n+\t    avalue[i] = (void*) pgr;\n+\t  ng += (size_al + 3) / 4;\n+\t  pgr += (size_al + 3) / 4;\n+\t  break;\n+\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_UINT64:\n+\t  /* Long long ints are passed in two gpr's.  */\n+\t  avalue[i] = pgr;\n+\t  ng += 2;\n+\t  pgr += 2;\n+\t  break;\n+\n+\tcase FFI_TYPE_FLOAT:\n+\t  /* a float value consumes a GPR\n+\t   *\n+\t   * here are 13 64bit floating point registers.\n \t   */\n-          \n-\t  if ((ng > 7) && (nf < 13)) {\n-\t     pst++;\n-\t  }\n-          if (nf < 13) {\n-\t     temp = *(double*)pfr;\n-             *(float*)pfr = (float)temp;\n-             avalue[i] = pfr;\n-             nf++;\n-             pfr+=2;\n-             ng++;\n-\t     pgr++;\n-\t         \n-          } else {\n-             avalue[i] = pst;\n-             nf++;\n-             pst++;\n-          }\n-          break;\n-\n-        case FFI_TYPE_DOUBLE:\n+\t  if (nf < NUM_FPR_ARG_REGISTERS)\n+\t    {\n+\t      temp = pfr->d;\n+\t      pfr->f = (float)temp;\n+\t      avalue[i] = pfr;\n+\t      pfr++;\n+\t    }\n+\t  else\n+\t    {\n+\t      avalue[i] = pgr;\n+\t    }\n+\t  nf++;\n+\t  ng++;\n+\t  pgr++;\n+\t  break;\n+\n+\tcase FFI_TYPE_DOUBLE:\n \t  /* a double value consumes two GPRs\n-           *  \n-           * there are 13 64bit floating point registers \n+\t   *\n+\t   * There are 13 64bit floating point registers.\n \t   */\n-\n-\t  if ((ng == 7) && (nf < 13)) {\n-             pst++;\t/* if only one gpr is left the double steals it */\n-\t  } else if ((ng > 7) && (nf < 13)) {\n-\t     pst+=2;\t/* a double consumes two GPRs in Darwin/AIX */\n-\t  }\n-          if (nf < 13) {\n-             avalue[i] = pfr;\n-             nf++;\n-             pfr+=2;\n-\t     ng+=2;\n-\t     pgr+=2;\n-\n-          } else {\n-             avalue[i] = pst;\n-             nf++;\n-             pst+=2;\n-          }\n-          break;\n+\t  if (nf < NUM_FPR_ARG_REGISTERS)\n+\t    {\n+\t      avalue[i] = pfr;\n+\t      pfr++;\n+\t    }\n+\t  else\n+\t    {\n+\t      avalue[i] = pgr;\n+\t    }\n+\t  nf++;\n+\t  ng += 2;\n+\t  pgr += 2;\n+\t  break;\n \n         default:\n           FFI_ASSERT(0);\n-       \n         }\n-\n       i++;\n     }\n \n   (closure->fun) (cif, rvalue, avalue, closure->user_data);\n \n   /* Tell ffi_closure_ASM to perform return type promotions.  */\n   return cif->rtype->type;\n-\n }"}, {"sha": "725df348c926f91ae749e689d85d07739894ca9b", "filename": "libffi/src/types.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b182fda603ed65448103a22ce4ad76744e6229/libffi%2Fsrc%2Ftypes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b182fda603ed65448103a22ce4ad76744e6229/libffi%2Fsrc%2Ftypes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Ftypes.c?ref=69b182fda603ed65448103a22ce4ad76744e6229", "patch": "@@ -76,7 +76,7 @@ FFI_INTEGRAL_TYPEDEF(sint64, 8, 8, FFI_TYPE_SINT64);\n FFI_INTEGRAL_TYPEDEF(double, 8, 4, FFI_TYPE_DOUBLE);\n FFI_INTEGRAL_TYPEDEF(longdouble, 12, 4, FFI_TYPE_LONGDOUBLE);\n \n-#elif defined ARM || defined SH || defined POWERPC64\n+#elif defined ARM || defined SH || defined POWERPC64 || defined POWERPC_AIX || defined POWERPC_DARWIN\n \n FFI_INTEGRAL_TYPEDEF(double, 8, 4, FFI_TYPE_DOUBLE);\n FFI_INTEGRAL_TYPEDEF(longdouble, 8, 4, FFI_TYPE_LONGDOUBLE);"}]}