{"sha": "d74d8807cc43f9d05e099eca871a590fb458c245", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc0ZDg4MDdjYzQzZjlkMDVlMDk5ZWNhODcxYTU5MGZiNDU4YzI0NQ==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2010-07-21T13:44:38Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2010-07-21T13:44:38Z"}, "message": "trans.h (gfc_get_return_label): Removed.\n\n2010-07-21  Daniel Kraft  <d@domob.eu>\n\n\t* trans.h (gfc_get_return_label): Removed.\n\t(gfc_generate_return): New method.\n\t(gfc_trans_deferred_vars): Update gfc_wrapped_block rather than\n\treturning a tree directly.\n\t* trans-stmt.c (gfc_trans_return): Use `gfc_generate_return'.\n\t(gfc_trans_block_construct): Update for new interface to\n\t`gfc_trans_deferred_vars'.\n\t* trans-decl.c (current_function_return_label): Removed.\n\t(current_procedure_symbol): New variable.\n\t(gfc_get_return_label): Removed.\n\t(gfc_trans_deferred_vars): Update gfc_wrapped_block rather than\n\treturning a tree directly.\n\t(get_proc_result), (gfc_generate_return): New methods.\n\t(gfc_generate_function_code): Clean up and do init/cleanup here\n\talso with gfc_wrapped_block.  Remove return-label but rather\n\treturn directly.\n\nFrom-SVN: r162373", "tree": {"sha": "3afbfb5397c9f4875f557b7dd7084ea182554630", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3afbfb5397c9f4875f557b7dd7084ea182554630"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d74d8807cc43f9d05e099eca871a590fb458c245", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d74d8807cc43f9d05e099eca871a590fb458c245", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d74d8807cc43f9d05e099eca871a590fb458c245", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d74d8807cc43f9d05e099eca871a590fb458c245/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "426797b226b4934a571b8e0e0e7bd9f495fd45f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/426797b226b4934a571b8e0e0e7bd9f495fd45f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/426797b226b4934a571b8e0e0e7bd9f495fd45f9"}], "stats": {"total": 323, "additions": 164, "deletions": 159}, "files": [{"sha": "fa32e0bfa98bc03e2a915ac5279cffbba8972cc5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74d8807cc43f9d05e099eca871a590fb458c245/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74d8807cc43f9d05e099eca871a590fb458c245/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d74d8807cc43f9d05e099eca871a590fb458c245", "patch": "@@ -1,3 +1,22 @@\n+2010-07-21  Daniel Kraft  <d@domob.eu>\n+\n+\t* trans.h (gfc_get_return_label): Removed.\n+\t(gfc_generate_return): New method.\n+\t(gfc_trans_deferred_vars): Update gfc_wrapped_block rather than\n+\treturning a tree directly.\n+\t* trans-stmt.c (gfc_trans_return): Use `gfc_generate_return'.\n+\t(gfc_trans_block_construct): Update for new interface to\n+\t`gfc_trans_deferred_vars'.\n+\t* trans-decl.c (current_function_return_label): Removed.\n+\t(current_procedure_symbol): New variable.\n+\t(gfc_get_return_label): Removed.\n+\t(gfc_trans_deferred_vars): Update gfc_wrapped_block rather than\n+\treturning a tree directly.\n+\t(get_proc_result), (gfc_generate_return): New methods.\n+\t(gfc_generate_function_code): Clean up and do init/cleanup here\n+\talso with gfc_wrapped_block.  Remove return-label but rather\n+\treturn directly.\n+\n 2010-07-19  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/44929"}, {"sha": "326afd76e18b3f52f8c9668a335eb2810ee622c7", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 128, "deletions": 137, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74d8807cc43f9d05e099eca871a590fb458c245/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74d8807cc43f9d05e099eca871a590fb458c245/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=d74d8807cc43f9d05e099eca871a590fb458c245", "patch": "@@ -55,8 +55,6 @@ along with GCC; see the file COPYING3.  If not see\n static GTY(()) tree current_fake_result_decl;\n static GTY(()) tree parent_fake_result_decl;\n \n-static GTY(()) tree current_function_return_label;\n-\n \n /* Holds the variable DECLs for the current function.  */\n \n@@ -75,6 +73,9 @@ static GTY(()) tree saved_local_decls;\n \n static gfc_namespace *module_namespace;\n \n+/* The currently processed procedure symbol.  */\n+static gfc_symbol* current_procedure_symbol = NULL;\n+\n \n /* List of static constructor functions.  */\n \n@@ -237,28 +238,6 @@ gfc_build_label_decl (tree label_id)\n }\n \n \n-/* Returns the return label for the current function.  */\n-\n-tree\n-gfc_get_return_label (void)\n-{\n-  char name[GFC_MAX_SYMBOL_LEN + 10];\n-\n-  if (current_function_return_label)\n-    return current_function_return_label;\n-\n-  sprintf (name, \"__return_%s\",\n-\t   IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));\n-\n-  current_function_return_label =\n-    gfc_build_label_decl (get_identifier (name));\n-\n-  DECL_ARTIFICIAL (current_function_return_label) = 1;\n-\n-  return current_function_return_label;\n-}\n-\n-\n /* Set the backend source location of a decl.  */\n \n void\n@@ -3089,18 +3068,15 @@ init_intent_out_dt (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n     Initialization of ASSIGN statement auxiliary variable.\n     Automatic deallocation.  */\n \n-tree\n-gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n+void\n+gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n {\n   locus loc;\n   gfc_symbol *sym;\n   gfc_formal_arglist *f;\n   stmtblock_t tmpblock;\n-  gfc_wrapped_block try_block;\n   bool seen_trans_deferred_array = false;\n \n-  gfc_start_wrapped_block (&try_block, fnbody);\n-\n   /* Deal with implicit return variables.  Explicit return variables will\n      already have been added.  */\n   if (gfc_return_by_reference (proc_sym) && proc_sym->result == proc_sym)\n@@ -3122,17 +3098,17 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n       else if (proc_sym->as)\n \t{\n \t  tree result = TREE_VALUE (current_fake_result_decl);\n-\t  gfc_trans_dummy_array_bias (proc_sym, result, &try_block);\n+\t  gfc_trans_dummy_array_bias (proc_sym, result, block);\n \n \t  /* An automatic character length, pointer array result.  */\n \t  if (proc_sym->ts.type == BT_CHARACTER\n \t\t&& TREE_CODE (proc_sym->ts.u.cl->backend_decl) == VAR_DECL)\n-\t    gfc_trans_dummy_character (proc_sym, proc_sym->ts.u.cl, &try_block);\n+\t    gfc_trans_dummy_character (proc_sym, proc_sym->ts.u.cl, block);\n \t}\n       else if (proc_sym->ts.type == BT_CHARACTER)\n \t{\n \t  if (TREE_CODE (proc_sym->ts.u.cl->backend_decl) == VAR_DECL)\n-\t    gfc_trans_dummy_character (proc_sym, proc_sym->ts.u.cl, &try_block);\n+\t    gfc_trans_dummy_character (proc_sym, proc_sym->ts.u.cl, block);\n \t}\n       else\n \tgcc_assert (gfc_option.flag_f2c\n@@ -3142,7 +3118,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n   /* Initialize the INTENT(OUT) derived type dummy arguments.  This\n      should be done here so that the offsets and lbounds of arrays\n      are available.  */\n-  init_intent_out_dt (proc_sym, &try_block);\n+  init_intent_out_dt (proc_sym, block);\n \n   for (sym = proc_sym->tlink; sym != proc_sym; sym = sym->tlink)\n     {\n@@ -3154,23 +3130,23 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t    {\n \t    case AS_EXPLICIT:\n \t      if (sym->attr.dummy || sym->attr.result)\n-\t\tgfc_trans_dummy_array_bias (sym, sym->backend_decl, &try_block);\n+\t\tgfc_trans_dummy_array_bias (sym, sym->backend_decl, block);\n \t      else if (sym->attr.pointer || sym->attr.allocatable)\n \t\t{\n \t\t  if (TREE_STATIC (sym->backend_decl))\n \t\t    gfc_trans_static_array_pointer (sym);\n \t\t  else\n \t\t    {\n \t\t      seen_trans_deferred_array = true;\n-\t\t      gfc_trans_deferred_array (sym, &try_block);\n+\t\t      gfc_trans_deferred_array (sym, block);\n \t\t    }\n \t\t}\n \t      else\n \t\t{\n \t\t  if (sym_has_alloc_comp)\n \t\t    {\n \t\t      seen_trans_deferred_array = true;\n-\t\t      gfc_trans_deferred_array (sym, &try_block);\n+\t\t      gfc_trans_deferred_array (sym, block);\n \t\t    }\n \t\t  else if (sym->ts.type == BT_DERIVED\n \t\t\t     && sym->value\n@@ -3179,15 +3155,15 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t\t    {\n \t\t      gfc_start_block (&tmpblock);\n \t\t      gfc_init_default_dt (sym, &tmpblock, false);\n-\t\t      gfc_add_init_cleanup (&try_block,\n+\t\t      gfc_add_init_cleanup (block,\n \t\t\t\t\t    gfc_finish_block (&tmpblock),\n \t\t\t\t\t    NULL_TREE);\n \t\t    }\n \n \t\t  gfc_get_backend_locus (&loc);\n \t\t  gfc_set_backend_locus (&sym->declared_at);\n \t\t  gfc_trans_auto_array_allocation (sym->backend_decl,\n-\t\t\t\t\t\t   sym, &try_block);\n+\t\t\t\t\t\t   sym, block);\n \t\t  gfc_set_backend_locus (&loc);\n \t\t}\n \t      break;\n@@ -3198,26 +3174,26 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \n \t      /* We should always pass assumed size arrays the g77 way.  */\n \t      if (sym->attr.dummy)\n-\t\tgfc_trans_g77_array (sym, &try_block);\n+\t\tgfc_trans_g77_array (sym, block);\n \t      break;\n \n \t    case AS_ASSUMED_SHAPE:\n \t      /* Must be a dummy parameter.  */\n \t      gcc_assert (sym->attr.dummy);\n \n-\t      gfc_trans_dummy_array_bias (sym, sym->backend_decl, &try_block);\n+\t      gfc_trans_dummy_array_bias (sym, sym->backend_decl, block);\n \t      break;\n \n \t    case AS_DEFERRED:\n \t      seen_trans_deferred_array = true;\n-\t      gfc_trans_deferred_array (sym, &try_block);\n+\t      gfc_trans_deferred_array (sym, block);\n \t      break;\n \n \t    default:\n \t      gcc_unreachable ();\n \t    }\n \t  if (sym_has_alloc_comp && !seen_trans_deferred_array)\n-\t    gfc_trans_deferred_array (sym, &try_block);\n+\t    gfc_trans_deferred_array (sym, block);\n \t}\n       else if (sym->attr.allocatable\n \t       || (sym->ts.type == BT_CLASS\n@@ -3253,26 +3229,26 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t      if (!sym->attr.result)\n \t\ttmp = gfc_deallocate_with_status (se.expr, NULL_TREE,\n \t\t\t\t\t\t  true, NULL);\n-\t      gfc_add_init_cleanup (&try_block, gfc_finish_block (&init), tmp);\n+\t      gfc_add_init_cleanup (block, gfc_finish_block (&init), tmp);\n \t    }\n \t}\n       else if (sym_has_alloc_comp)\n-\tgfc_trans_deferred_array (sym, &try_block);\n+\tgfc_trans_deferred_array (sym, block);\n       else if (sym->ts.type == BT_CHARACTER)\n \t{\n \t  gfc_get_backend_locus (&loc);\n \t  gfc_set_backend_locus (&sym->declared_at);\n \t  if (sym->attr.dummy || sym->attr.result)\n-\t    gfc_trans_dummy_character (sym, sym->ts.u.cl, &try_block);\n+\t    gfc_trans_dummy_character (sym, sym->ts.u.cl, block);\n \t  else\n-\t    gfc_trans_auto_character_variable (sym, &try_block);\n+\t    gfc_trans_auto_character_variable (sym, block);\n \t  gfc_set_backend_locus (&loc);\n \t}\n       else if (sym->attr.assign)\n \t{\n \t  gfc_get_backend_locus (&loc);\n \t  gfc_set_backend_locus (&sym->declared_at);\n-\t  gfc_trans_assign_aux_var (sym, &try_block);\n+\t  gfc_trans_assign_aux_var (sym, block);\n \t  gfc_set_backend_locus (&loc);\n \t}\n       else if (sym->ts.type == BT_DERIVED\n@@ -3282,7 +3258,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t{\n \t  gfc_start_block (&tmpblock);\n \t  gfc_init_default_dt (sym, &tmpblock, false);\n-\t  gfc_add_init_cleanup (&try_block, gfc_finish_block (&tmpblock),\n+\t  gfc_add_init_cleanup (block, gfc_finish_block (&tmpblock),\n \t\t\t\tNULL_TREE);\n \t}\n       else\n@@ -3309,9 +3285,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \tgfc_trans_vla_type_sizes (proc_sym, &tmpblock);\n     }\n \n-  gfc_add_init_cleanup (&try_block, gfc_finish_block (&tmpblock), NULL_TREE);\n-\n-  return gfc_finish_wrapped_block (&try_block);\n+  gfc_add_init_cleanup (block, gfc_finish_block (&tmpblock), NULL_TREE);\n }\n \n static GTY ((param_is (struct module_htab_entry))) htab_t module_htab;\n@@ -4309,6 +4283,56 @@ create_main_function (tree fndecl)\n }\n \n \n+/* Get the result expression for a procedure.  */\n+\n+static tree\n+get_proc_result (gfc_symbol* sym)\n+{\n+  if (sym->attr.subroutine || sym == sym->result)\n+    {\n+      if (current_fake_result_decl != NULL)\n+\treturn TREE_VALUE (current_fake_result_decl);\n+\n+      return NULL_TREE;\n+    }\n+\n+  return sym->result->backend_decl;\n+}\n+\n+\n+/* Generate an appropriate return-statement for a procedure.  */\n+\n+tree\n+gfc_generate_return (void)\n+{\n+  gfc_symbol* sym;\n+  tree result;\n+  tree fndecl;\n+\n+  sym = current_procedure_symbol;\n+  fndecl = sym->backend_decl;\n+\n+  if (TREE_TYPE (DECL_RESULT (fndecl)) == void_type_node)\n+    result = NULL_TREE;\n+  else\n+    {\n+      result = get_proc_result (sym);\n+\n+      /* Set the return value to the dummy result variable.  The\n+\t types may be different for scalar default REAL functions\n+\t with -ff2c, therefore we have to convert.  */\n+      if (result != NULL_TREE)\n+\t{\n+\t  result = convert (TREE_TYPE (DECL_RESULT (fndecl)), result);\n+\t  result = fold_build2 (MODIFY_EXPR, TREE_TYPE (result),\n+\t\t\t\tDECL_RESULT (fndecl), result);\n+\t}\n+    }\n+\n+  return build1_v (RETURN_EXPR, result);\n+}\n+\n+\n /* Generate code for a function.  */\n \n void\n@@ -4318,16 +4342,18 @@ gfc_generate_function_code (gfc_namespace * ns)\n   tree old_context;\n   tree decl;\n   tree tmp;\n-  tree tmp2;\n-  stmtblock_t block;\n+  stmtblock_t init, cleanup;\n   stmtblock_t body;\n-  tree result;\n+  gfc_wrapped_block try_block;\n   tree recurcheckvar = NULL_TREE;\n   gfc_symbol *sym;\n+  gfc_symbol *previous_procedure_symbol;\n   int rank;\n   bool is_recursive;\n \n   sym = ns->proc_name;\n+  previous_procedure_symbol = current_procedure_symbol;\n+  current_procedure_symbol = sym;\n \n   /* Check that the frontend isn't still using this.  */\n   gcc_assert (sym->tlink == NULL);\n@@ -4349,7 +4375,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n \n   trans_function_start (sym);\n \n-  gfc_init_block (&block);\n+  gfc_init_block (&init);\n \n   if (ns->entries && ns->proc_name->ts.type == BT_CHARACTER)\n     {\n@@ -4388,34 +4414,32 @@ gfc_generate_function_code (gfc_namespace * ns)\n   else\n     current_fake_result_decl = NULL_TREE;\n \n-  current_function_return_label = NULL;\n+  is_recursive = sym->attr.recursive\n+\t\t || (sym->attr.entry_master\n+\t\t     && sym->ns->entries->sym->attr.recursive);\n+  if ((gfc_option.rtcheck & GFC_RTCHECK_RECURSION)\n+\t&& !is_recursive\n+\t&& !gfc_option.flag_recursive)\n+    {\n+      char * msg;\n+\n+      asprintf (&msg, \"Recursive call to nonrecursive procedure '%s'\",\n+\t\tsym->name);\n+      recurcheckvar = gfc_create_var (boolean_type_node, \"is_recursive\");\n+      TREE_STATIC (recurcheckvar) = 1;\n+      DECL_INITIAL (recurcheckvar) = boolean_false_node;\n+      gfc_add_expr_to_block (&init, recurcheckvar);\n+      gfc_trans_runtime_check (true, false, recurcheckvar, &init,\n+\t\t\t       &sym->declared_at, msg);\n+      gfc_add_modify (&init, recurcheckvar, boolean_true_node);\n+      gfc_free (msg);\n+    }\n \n   /* Now generate the code for the body of this function.  */\n   gfc_init_block (&body);\n \n-   is_recursive = sym->attr.recursive\n-\t\t  || (sym->attr.entry_master\n-\t\t      && sym->ns->entries->sym->attr.recursive);\n-   if ((gfc_option.rtcheck & GFC_RTCHECK_RECURSION)\n-\t  && !is_recursive\n-\t  && !gfc_option.flag_recursive)\n-     {\n-       char * msg;\n-\n-       asprintf (&msg, \"Recursive call to nonrecursive procedure '%s'\",\n-\t\t sym->name);\n-       recurcheckvar = gfc_create_var (boolean_type_node, \"is_recursive\");\n-       TREE_STATIC (recurcheckvar) = 1;\n-       DECL_INITIAL (recurcheckvar) = boolean_false_node;\n-       gfc_add_expr_to_block (&block, recurcheckvar);\n-       gfc_trans_runtime_check (true, false, recurcheckvar, &block,\n-\t\t\t\t&sym->declared_at, msg);\n-       gfc_add_modify (&block, recurcheckvar, boolean_true_node);\n-       gfc_free (msg);\n-    }\n-\n   if (TREE_TYPE (DECL_RESULT (fndecl)) != void_type_node\n-        && sym->attr.subroutine)\n+\t&& sym->attr.subroutine)\n     {\n       tree alternate_return;\n       alternate_return = gfc_get_fake_result_decl (sym, 0);\n@@ -4438,29 +4462,9 @@ gfc_generate_function_code (gfc_namespace * ns)\n   tmp = gfc_trans_code (ns->code);\n   gfc_add_expr_to_block (&body, tmp);\n \n-  /* Add a return label if needed.  */\n-  if (current_function_return_label)\n-    {\n-      tmp = build1_v (LABEL_EXPR, current_function_return_label);\n-      gfc_add_expr_to_block (&body, tmp);\n-    }\n-\n-  tmp = gfc_finish_block (&body);\n-  /* Add code to create and cleanup arrays.  */\n-  tmp = gfc_trans_deferred_vars (sym, tmp);\n-\n   if (TREE_TYPE (DECL_RESULT (fndecl)) != void_type_node)\n     {\n-      if (sym->attr.subroutine || sym == sym->result)\n-\t{\n-\t  if (current_fake_result_decl != NULL)\n-\t    result = TREE_VALUE (current_fake_result_decl);\n-\t  else\n-\t    result = NULL_TREE;\n-\t  current_fake_result_decl = NULL_TREE;\n-\t}\n-      else\n-\tresult = sym->result->backend_decl;\n+      tree result = get_proc_result (sym);\n \n       if (result != NULL_TREE\n \t    && sym->attr.function\n@@ -4470,24 +4474,12 @@ gfc_generate_function_code (gfc_namespace * ns)\n \t      && sym->ts.u.derived->attr.alloc_comp)\n \t    {\n \t      rank = sym->as ? sym->as->rank : 0;\n-\t      tmp2 = gfc_nullify_alloc_comp (sym->ts.u.derived, result, rank);\n-\t      gfc_add_expr_to_block (&block, tmp2);\n+\t      tmp = gfc_nullify_alloc_comp (sym->ts.u.derived, result, rank);\n+\t      gfc_add_expr_to_block (&init, tmp);\n \t    }\n \t  else if (sym->attr.allocatable && sym->attr.dimension == 0)\n-\t    gfc_add_modify (&block, result, fold_convert (TREE_TYPE (result),\n-\t\t\t\t\t\t\t  null_pointer_node));\n-\t}\n-\n-      gfc_add_expr_to_block (&block, tmp);\n-\n-      /* Reset recursion-check variable.  */\n-      if ((gfc_option.rtcheck & GFC_RTCHECK_RECURSION)\n-\t     && !is_recursive\n-\t     && !gfc_option.flag_openmp\n-\t     && recurcheckvar != NULL_TREE)\n-\t{\n-\t  gfc_add_modify (&block, recurcheckvar, boolean_false_node);\n-\t  recurcheckvar = NULL;\n+\t    gfc_add_modify (&init, result, fold_convert (TREE_TYPE (result),\n+\t\t\t\t\t\t\t null_pointer_node));\n \t}\n \n       if (result == NULL_TREE)\n@@ -4500,31 +4492,28 @@ gfc_generate_function_code (gfc_namespace * ns)\n \t  TREE_NO_WARNING(sym->backend_decl) = 1;\n \t}\n       else\n-\t{\n-\t  /* Set the return value to the dummy result variable.  The\n-\t     types may be different for scalar default REAL functions\n-\t     with -ff2c, therefore we have to convert.  */\n-\t  tmp = convert (TREE_TYPE (DECL_RESULT (fndecl)), result);\n-\t  tmp = fold_build2 (MODIFY_EXPR, TREE_TYPE (tmp),\n-\t\t\t     DECL_RESULT (fndecl), tmp);\n-\t  tmp = build1_v (RETURN_EXPR, tmp);\n-\t  gfc_add_expr_to_block (&block, tmp);\n-\t}\n+\tgfc_add_expr_to_block (&body, gfc_generate_return ());\n     }\n-  else\n+\n+  gfc_init_block (&cleanup);\n+\n+  /* Reset recursion-check variable.  */\n+  if ((gfc_option.rtcheck & GFC_RTCHECK_RECURSION)\n+\t && !is_recursive\n+\t && !gfc_option.flag_openmp\n+\t && recurcheckvar != NULL_TREE)\n     {\n-      gfc_add_expr_to_block (&block, tmp);\n-      /* Reset recursion-check variable.  */\n-      if ((gfc_option.rtcheck & GFC_RTCHECK_RECURSION)\n-\t     && !is_recursive\n-\t     && !gfc_option.flag_openmp\n-\t     && recurcheckvar != NULL_TREE)\n-\t{\n-\t  gfc_add_modify (&block, recurcheckvar, boolean_false_node);\n-\t  recurcheckvar = NULL_TREE;\n-\t}\n+      gfc_add_modify (&cleanup, recurcheckvar, boolean_false_node);\n+      recurcheckvar = NULL;\n     }\n \n+  /* Finish the function body and add init and cleanup code.  */\n+  tmp = gfc_finish_block (&body);\n+  gfc_start_wrapped_block (&try_block, tmp);\n+  /* Add code to create and cleanup arrays.  */\n+  gfc_trans_deferred_vars (sym, &try_block);\n+  gfc_add_init_cleanup (&try_block, gfc_finish_block (&init),\n+\t\t\tgfc_finish_block (&cleanup));\n \n   /* Add all the decls we created during processing.  */\n   decl = saved_function_decls;\n@@ -4539,7 +4528,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n     }\n   saved_function_decls = NULL_TREE;\n \n-  DECL_SAVED_TREE (fndecl) = gfc_finish_block (&block);\n+  DECL_SAVED_TREE (fndecl) = gfc_finish_wrapped_block (&try_block);\n   decl = getdecls ();\n \n   /* Finish off this function and send it for code generation.  */\n@@ -4590,6 +4579,8 @@ gfc_generate_function_code (gfc_namespace * ns)\n \n   if (sym->attr.is_main_program)\n     create_main_function (fndecl);\n+\n+  current_procedure_symbol = previous_procedure_symbol;\n }\n \n "}, {"sha": "8abdd885c2c79c3ac8bfc10146906ca7703a0661", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74d8807cc43f9d05e099eca871a590fb458c245/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74d8807cc43f9d05e099eca871a590fb458c245/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=d74d8807cc43f9d05e099eca871a590fb458c245", "patch": "@@ -491,7 +491,7 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n /* Translate the RETURN statement.  */\n \n tree\n-gfc_trans_return (gfc_code * code ATTRIBUTE_UNUSED)\n+gfc_trans_return (gfc_code * code)\n {\n   if (code->expr1)\n     {\n@@ -500,16 +500,16 @@ gfc_trans_return (gfc_code * code ATTRIBUTE_UNUSED)\n       tree result;\n \n       /* If code->expr is not NULL, this return statement must appear\n-         in a subroutine and current_fake_result_decl has already\n+\t in a subroutine and current_fake_result_decl has already\n \t been generated.  */\n \n       result = gfc_get_fake_result_decl (NULL, 0);\n       if (!result)\n-        {\n-          gfc_warning (\"An alternate return at %L without a * dummy argument\",\n-                        &code->expr1->where);\n-          return build1_v (GOTO_EXPR, gfc_get_return_label ());\n-        }\n+\t{\n+\t  gfc_warning (\"An alternate return at %L without a * dummy argument\",\n+\t\t\t&code->expr1->where);\n+\t  return gfc_generate_return ();\n+\t}\n \n       /* Start a new block for this statement.  */\n       gfc_init_se (&se, NULL);\n@@ -521,13 +521,12 @@ gfc_trans_return (gfc_code * code ATTRIBUTE_UNUSED)\n \t\t\t fold_convert (TREE_TYPE (result), se.expr));\n       gfc_add_expr_to_block (&se.pre, tmp);\n \n-      tmp = build1_v (GOTO_EXPR, gfc_get_return_label ());\n+      tmp = gfc_generate_return ();\n       gfc_add_expr_to_block (&se.pre, tmp);\n-      gfc_add_block_to_block (&se.pre, &se.post);\n       return gfc_finish_block (&se.pre);\n     }\n-  else\n-    return build1_v (GOTO_EXPR, gfc_get_return_label ());\n+\n+  return gfc_generate_return ();\n }\n \n \n@@ -847,8 +846,7 @@ gfc_trans_block_construct (gfc_code* code)\n {\n   gfc_namespace* ns;\n   gfc_symbol* sym;\n-  stmtblock_t body;\n-  tree tmp;\n+  gfc_wrapped_block body;\n \n   ns = code->ext.block.ns;\n   gcc_assert (ns);\n@@ -858,14 +856,12 @@ gfc_trans_block_construct (gfc_code* code)\n   gcc_assert (!sym->tlink);\n   sym->tlink = sym;\n \n-  gfc_start_block (&body);\n   gfc_process_block_locals (ns);\n \n-  tmp = gfc_trans_code (ns->code);\n-  tmp = gfc_trans_deferred_vars (sym, tmp);\n+  gfc_start_wrapped_block (&body, gfc_trans_code (ns->code));\n+  gfc_trans_deferred_vars (sym, &body);\n \n-  gfc_add_expr_to_block (&body, tmp);\n-  return gfc_finish_block (&body);\n+  return gfc_finish_wrapped_block (&body);\n }\n \n "}, {"sha": "cbed52b5f870121fcdb29394abd946654baa84d7", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74d8807cc43f9d05e099eca871a590fb458c245/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74d8807cc43f9d05e099eca871a590fb458c245/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=d74d8807cc43f9d05e099eca871a590fb458c245", "patch": "@@ -408,9 +408,6 @@ tree gfc_build_label_decl (tree);\n    Do not use if the function has an explicit result variable.  */\n tree gfc_get_fake_result_decl (gfc_symbol *, int);\n \n-/* Get the return label for the current function.  */\n-tree gfc_get_return_label (void);\n-\n /* Add a decl to the binding level for the current function.  */\n void gfc_add_decl_to_function (tree);\n \n@@ -456,6 +453,8 @@ void gfc_generate_function_code (gfc_namespace *);\n void gfc_generate_block_data (gfc_namespace *);\n /* Output a decl for a module variable.  */\n void gfc_generate_module_vars (gfc_namespace *);\n+/* Get the appropriate return statement for a procedure.  */\n+tree gfc_generate_return (void);\n \n struct GTY(()) module_htab_entry {\n   const char *name;\n@@ -533,7 +532,7 @@ tree gfc_build_library_function_decl_with_spec (tree name, const char *spec,\n void gfc_process_block_locals (gfc_namespace*);\n \n /* Output initialization/clean-up code that was deferred.  */\n-tree gfc_trans_deferred_vars (gfc_symbol*, tree);\n+void gfc_trans_deferred_vars (gfc_symbol*, gfc_wrapped_block *);\n \n /* somewhere! */\n tree pushdecl (tree);"}]}