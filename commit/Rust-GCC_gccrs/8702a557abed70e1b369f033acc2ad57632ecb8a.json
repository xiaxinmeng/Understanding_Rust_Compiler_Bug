{"sha": "8702a557abed70e1b369f033acc2ad57632ecb8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODcwMmE1NTdhYmVkNzBlMWIzNjlmMDMzYWNjMmFkNTc2MzJlY2I4YQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2006-01-11T20:39:42Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2006-01-11T20:39:42Z"}, "message": "tree-ssa-threadupdate.c (threaded_edges): New VEC to hold edge pairs.\n\n\n\t* tree-ssa-threadupdate.c (threaded_edges): New VEC to\n\thold edge pairs.\n\t(mark_threaded_blocks, register_jump_thread): New functions.\n\t(thread_through_all_blocks): Remove unwanted argument.  No\n\tlonger rely on e->aux to communicate thread target info.\n\tCall mark_threaded_blocks.  Release the threaded_blocks\n\tbitmap and threaded_edges vector when complete.\n\t* tree-ssa-dom.c (struct edge_info): Remove redirection_target field.\n\t(threaded_blocks): Remove.\n\t(tree_ssa_dominator_optimize): Remove initialization and\n\tfinalization of threaded_blocks.  Simplify call to\n\tthread_through_all_blocks.\n\t(thread_across_edge): Call register_jump_thread rather than\n\tstoring thread information into e->aux.\n\t(free_all_edge_infos): Simplify now that e->aux is no longer\n\tused to communicate with thread_through_all_blocks.\n\t* tree-flow.h (thread_through_all_blocks): Update prototype.\n\t(register_jump_thread): Prototype.\n\nFrom-SVN: r109602", "tree": {"sha": "7ab263d630f4add5c8eae0cdd38bbfdecac5c634", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ab263d630f4add5c8eae0cdd38bbfdecac5c634"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8702a557abed70e1b369f033acc2ad57632ecb8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8702a557abed70e1b369f033acc2ad57632ecb8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8702a557abed70e1b369f033acc2ad57632ecb8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8702a557abed70e1b369f033acc2ad57632ecb8a/comments", "author": null, "committer": null, "parents": [{"sha": "9be0cc75f123329373c012d9379e63d992f717bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9be0cc75f123329373c012d9379e63d992f717bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9be0cc75f123329373c012d9379e63d992f717bf"}], "stats": {"total": 117, "additions": 92, "deletions": 25}, "files": [{"sha": "b5fd19ccffbcb8a3ef8530be59ff2134e1066892", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8702a557abed70e1b369f033acc2ad57632ecb8a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8702a557abed70e1b369f033acc2ad57632ecb8a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8702a557abed70e1b369f033acc2ad57632ecb8a", "patch": "@@ -1,3 +1,24 @@\n+2006-01-11  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadupdate.c (threaded_edges): New VEC to\n+\thold edge pairs.\n+\t(mark_threaded_blocks, register_jump_thread): New functions.\n+\t(thread_through_all_blocks): Remove unwanted argument.  No\n+\tlonger rely on e->aux to communicate thread target info.\n+\tCall mark_threaded_blocks.  Release the threaded_blocks\n+\tbitmap and threaded_edges vector when complete.\n+\t* tree-ssa-dom.c (struct edge_info): Remove redirection_target field.\n+\t(threaded_blocks): Remove.\n+\t(tree_ssa_dominator_optimize): Remove initialization and\n+\tfinalization of threaded_blocks.  Simplify call to\n+\tthread_through_all_blocks.\n+\t(thread_across_edge): Call register_jump_thread rather than\n+\tstoring thread information into e->aux.\n+\t(free_all_edge_infos): Simplify now that e->aux is no longer\n+\tused to communicate with thread_through_all_blocks.\n+\t* tree-flow.h (thread_through_all_blocks): Update prototype.\n+\t(register_jump_thread): Prototype.\n+\t\n 2006-01-11  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* df-core.c (df_compact_blocks, df_bb_replace): Use"}, {"sha": "92a6035c6a978013abff248442aab8ddc8ca3d1f", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8702a557abed70e1b369f033acc2ad57632ecb8a/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8702a557abed70e1b369f033acc2ad57632ecb8a/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=8702a557abed70e1b369f033acc2ad57632ecb8a", "patch": "@@ -807,7 +807,8 @@ bool multiplier_allowed_in_address_p (HOST_WIDE_INT);\n unsigned multiply_by_cost (HOST_WIDE_INT, enum machine_mode);\n \n /* In tree-ssa-threadupdate.c.  */\n-extern bool thread_through_all_blocks (bitmap);\n+extern bool thread_through_all_blocks (void);\n+extern void register_jump_thread (edge, edge);\n \n /* In gimplify.c  */\n tree force_gimple_operand (tree, tree *, bool, tree);"}, {"sha": "b522fac3e44281e5db59db7448d464c69d04f9b5", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8702a557abed70e1b369f033acc2ad57632ecb8a/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8702a557abed70e1b369f033acc2ad57632ecb8a/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=8702a557abed70e1b369f033acc2ad57632ecb8a", "patch": "@@ -74,9 +74,6 @@ struct edge_info\n      and its maximum index rather than use a varray.  */\n   tree *cond_equivalences;\n   unsigned int max_cond_equivalences;\n-\n-  /* If we can thread this edge this field records the new target.  */\n-  edge redirection_target;\n };\n \n \n@@ -141,10 +138,6 @@ static VEC(tree,heap) *const_and_copies_stack;\n    know their exact value.  */\n static bitmap nonzero_vars;\n \n-/* Bitmap of blocks that are scheduled to be threaded through.  This\n-   is used to communicate with thread_through_blocks.  */\n-static bitmap threaded_blocks;\n-\n /* Stack of SSA_NAMEs which need their NONZERO_VARS property cleared\n    when the current block is finalized. \n \n@@ -326,10 +319,10 @@ free_all_edge_infos (void)\n \n \t  if (edge_info)\n \t    {\n-\t      e->aux = edge_info->redirection_target;\n \t      if (edge_info->cond_equivalences)\n \t\tfree (edge_info->cond_equivalences);\n \t      free (edge_info);\n+\t      e->aux = NULL;\n \t    }\n \t}\n     }\n@@ -372,7 +365,6 @@ tree_ssa_dominator_optimize (void)\n   vrp_variables_stack = VEC_alloc (tree, heap, 20);\n   stmts_to_rescan = VEC_alloc (tree, heap, 20);\n   nonzero_vars = BITMAP_ALLOC (NULL);\n-  threaded_blocks = BITMAP_ALLOC (NULL);\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n \n   /* Setup callbacks for the generic dominator tree walker.  */\n@@ -448,7 +440,7 @@ tree_ssa_dominator_optimize (void)\n       free_all_edge_infos ();\n \n       /* Thread jumps, creating duplicate blocks as needed.  */\n-      cfg_altered |= thread_through_all_blocks (threaded_blocks);\n+      cfg_altered |= thread_through_all_blocks ();\n \n       /* Removal of statements may make some EH edges dead.  Purge\n \t such edges from the CFG as needed.  */\n@@ -487,7 +479,6 @@ tree_ssa_dominator_optimize (void)\n \n       /* Reinitialize the various tables.  */\n       bitmap_clear (nonzero_vars);\n-      bitmap_clear (threaded_blocks);\n       htab_empty (avail_exprs);\n       htab_empty (vrp_data);\n \n@@ -533,7 +524,6 @@ tree_ssa_dominator_optimize (void)\n \n   /* Free nonzero_vars.  */\n   BITMAP_FREE (nonzero_vars);\n-  BITMAP_FREE (threaded_blocks);\n   BITMAP_FREE (need_eh_cleanup);\n   \n   VEC_free (tree, heap, avail_exprs_stack);\n@@ -924,8 +914,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t\tedge_info = (struct edge_info *) e->aux;\n \t      else\n \t\tedge_info = allocate_edge_info (e);\n-\t      edge_info->redirection_target = taken_edge;\n-\t      bitmap_set_bit (threaded_blocks, e->dest->index);\n+\t      register_jump_thread (e, taken_edge);\n \t    }\n \t}\n     }"}, {"sha": "b6264f5de547279c2b3195e294ce79bc064836a5", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 66, "deletions": 10, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8702a557abed70e1b369f033acc2ad57632ecb8a/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8702a557abed70e1b369f033acc2ad57632ecb8a/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=8702a557abed70e1b369f033acc2ad57632ecb8a", "patch": "@@ -147,6 +147,14 @@ struct local_info\n   bool jumps_threaded;\n };\n \n+/* Passes which use the jump threading code register jump threading\n+   opportunities as they are discovered.  We keep the registered\n+   jump threading opportunities in this vector as edge pairs\n+   (original_edge, target_edge).  */\n+DEF_VEC_ALLOC_P(edge,heap);\n+static VEC(edge,heap) *threaded_edges;\n+\n+\n /* Jump threading statistics.  */\n \n struct thread_stats_d\n@@ -802,34 +810,60 @@ thread_block (basic_block bb)\n   return local_info.jumps_threaded;\n }\n \n-/* Walk through all blocks and thread incoming edges to the block's\n-   destinations as requested.  This is the only entry point into this\n-   file.\n+/* Walk through the registered jump threads and convert them into a\n+   form convienent for this pass.\n+\n+   Any block which has incoming edges threaded to outgoing edges\n+   will have its entry in THREADED_BLOCK set.\n \n-   Blocks which have one or more incoming edges have INCOMING_EDGE_THREADED\n-   set in the block's annotation.\n+   Any threaded edge will have its new outgoing edge stored in the\n+   original edge's AUX field.\n \n-   Each edge that should be threaded has the new destination edge stored in\n-   the original edge's AUX field.\n+   This form avoids the need to walk all the edges in the CFG to\n+   discover blocks which need processing and avoids unnecessary\n+   hash table lookups to map from threaded edge to new target.  */\n \n-   This routine (or one of its callees) will clear INCOMING_EDGE_THREADED\n-   in the block annotations and the AUX field in the edges.\n+static void\n+mark_threaded_blocks (bitmap threaded_blocks)\n+{\n+  unsigned int i;\n+\n+  for (i = 0; i < VEC_length (edge, threaded_edges); i += 2)\n+    {\n+      edge e = VEC_index (edge, threaded_edges, i);\n+      edge e2 = VEC_index (edge, threaded_edges, i + 1);\n+\n+      e->aux = e2;\n+      bitmap_set_bit (threaded_blocks, e->dest->index);\n+    }\n+}\n+\n+\n+/* Walk through all blocks and thread incoming edges to the appropriate\n+   outgoing edge for each edge pair recorded in THREADED_EDGES.\n \n    It is the caller's responsibility to fix the dominance information\n    and rewrite duplicated SSA_NAMEs back into SSA form.\n \n    Returns true if one or more edges were threaded, false otherwise.  */\n \n bool\n-thread_through_all_blocks (bitmap threaded_blocks)\n+thread_through_all_blocks (void)\n {\n   bool retval = false;\n   unsigned int i;\n   bitmap_iterator bi;\n+  bitmap threaded_blocks;\n+\n+  if (threaded_edges == NULL)\n+    return false;\n \n+  threaded_blocks = BITMAP_ALLOC (NULL);\n   rediscover_loops_after_threading = false;\n   memset (&thread_stats, 0, sizeof (thread_stats));\n \n+  mark_threaded_blocks (threaded_blocks);\n+\n   EXECUTE_IF_SET_IN_BITMAP (threaded_blocks, 0, i, bi)\n     {\n       basic_block bb = BASIC_BLOCK (i);\n@@ -842,5 +876,27 @@ thread_through_all_blocks (bitmap threaded_blocks)\n     fprintf (dump_file, \"\\nJumps threaded: %lu\\n\",\n \t     thread_stats.num_threaded_edges);\n \n+  BITMAP_FREE (threaded_blocks);\n+  threaded_blocks = NULL;\n+  VEC_free (edge, heap, threaded_edges);\n+  threaded_edges = NULL;\n   return retval;\n }\n+\n+/* Register a jump threading opportunity.  We queue up all the jump\n+   threading opportunities discovered by a pass and update the CFG\n+   and SSA form all at once.\n+\n+   E is the edge we can thread, E2 is the new target edge.  ie, we\n+   are effectively recording that E->dest can be changed to E2->dest\n+   after fixing the SSA graph.  */\n+\n+void\n+register_jump_thread (edge e, edge e2)\n+{\n+  if (threaded_edges == NULL)\n+    threaded_edges = VEC_alloc (edge, heap, 10);\n+\n+  VEC_safe_push (edge, heap, threaded_edges, e);\n+  VEC_safe_push (edge, heap, threaded_edges, e2);\n+}"}]}