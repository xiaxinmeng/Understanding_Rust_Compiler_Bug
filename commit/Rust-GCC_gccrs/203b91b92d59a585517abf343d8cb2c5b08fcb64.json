{"sha": "203b91b92d59a585517abf343d8cb2c5b08fcb64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjAzYjkxYjkyZDU5YTU4NTUxN2FiZjM0M2Q4Y2IyYzViMDhmY2I2NA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-28T03:44:05Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-28T03:44:05Z"}, "message": "Initial revision\n\nFrom-SVN: r243", "tree": {"sha": "33830d68245c45ee44703bf27548ecdad78f577a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33830d68245c45ee44703bf27548ecdad78f577a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/203b91b92d59a585517abf343d8cb2c5b08fcb64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/203b91b92d59a585517abf343d8cb2c5b08fcb64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/203b91b92d59a585517abf343d8cb2c5b08fcb64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/203b91b92d59a585517abf343d8cb2c5b08fcb64/comments", "author": null, "committer": null, "parents": [{"sha": "5b879759e9662176d1c91193cdc0bc52ca452d36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b879759e9662176d1c91193cdc0bc52ca452d36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b879759e9662176d1c91193cdc0bc52ca452d36"}], "stats": {"total": 1371, "additions": 1371, "deletions": 0}, "files": [{"sha": "419f9739d2dbf1d9a884cb2444aa197abf062c0b", "filename": "gcc/libgcc2.c", "status": "added", "additions": 1371, "deletions": 0, "changes": 1371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/203b91b92d59a585517abf343d8cb2c5b08fcb64/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/203b91b92d59a585517abf343d8cb2c5b08fcb64/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=203b91b92d59a585517abf343d8cb2c5b08fcb64", "patch": "@@ -0,0 +1,1371 @@\n+/* More subroutines needed by GCC output code on some machines.  */\n+/* Compile this one with gcc.  */\n+/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+/* It is incorrect to include config.h here, because this file is being\n+   compiled for the target, and hence definitions concerning only the host\n+   do not apply.  */\n+\n+#include \"tm.h\"\n+#include \"gstddef.h\"\n+\n+/* Don't use `fancy_abort' here even if config.h says to use it.  */\n+#ifdef abort\n+#undef abort\n+#endif\n+\n+/* Need to undef this because LONG_TYPE_SIZE may rely upon GCC's\n+   internal `target_flags' variable.  */\n+#undef LONG_TYPE_SIZE\n+\n+#define LONG_TYPE_SIZE (sizeof (long) * BITS_PER_UNIT)\n+\n+#ifndef SItype\n+#define SItype long int\n+#endif\n+\n+/* long long ints are pairs of long ints in the order determined by\n+   WORDS_BIG_ENDIAN.  */\n+\n+#if WORDS_BIG_ENDIAN\n+  struct longlong {long high, low;};\n+#else\n+  struct longlong {long low, high;};\n+#endif\n+\n+/* We need this union to unpack/pack longlongs, since we don't have\n+   any arithmetic yet.  Incoming long long parameters are stored\n+   into the `ll' field, and the unpacked result is read from the struct\n+   longlong.  */\n+\n+typedef union\n+{\n+  struct longlong s;\n+  long long ll;\n+} long_long;\n+\n+#if defined (L_udivmoddi4) || defined (L_muldi3)\n+\n+#include \"longlong.h\"\n+\n+#endif /* udiv or mul */\n+\n+extern long long __fixunssfdi (float a);\n+extern long long __fixunsdfdi (double a);\n+\f\n+#if defined (L_negdi2) || defined (L_divdi3) || defined (L_moddi3)\n+#if defined (L_divdi3) || defined (L_moddi3)\n+static inline\n+#endif\n+long long\n+__negdi2 (u)\n+     long long u;\n+{\n+  long_long w;\n+  long_long uu;\n+\n+  uu.ll = u;\n+\n+  w.s.low = -uu.s.low;\n+  w.s.high = -uu.s.high - ((unsigned long) w.s.low > 0);\n+\n+  return w.ll;\n+}\n+#endif\n+\f\n+#ifdef L_lshldi3\n+long long\n+__lshldi3 (u, b)\n+     long long u;\n+     int b;\n+{\n+  long_long w;\n+  long bm;\n+  long_long uu;\n+\n+  if (b == 0)\n+    return u;\n+\n+  uu.ll = u;\n+\n+  bm = (sizeof (long) * BITS_PER_UNIT) - b;\n+  if (bm <= 0)\n+    {\n+      w.s.low = 0;\n+      w.s.high = (unsigned long)uu.s.low << -bm;\n+    }\n+  else\n+    {\n+      unsigned long carries = (unsigned long)uu.s.low >> bm;\n+      w.s.low = (unsigned long)uu.s.low << b;\n+      w.s.high = ((unsigned long)uu.s.high << b) | carries;\n+    }\n+\n+  return w.ll;\n+}\n+#endif\n+\n+#ifdef L_lshrdi3\n+long long\n+__lshrdi3 (u, b)\n+     long long u;\n+     int b;\n+{\n+  long_long w;\n+  long bm;\n+  long_long uu;\n+\n+  if (b == 0)\n+    return u;\n+\n+  uu.ll = u;\n+\n+  bm = (sizeof (long) * BITS_PER_UNIT) - b;\n+  if (bm <= 0)\n+    {\n+      w.s.high = 0;\n+      w.s.low = (unsigned long)uu.s.high >> -bm;\n+    }\n+  else\n+    {\n+      unsigned long carries = (unsigned long)uu.s.high << bm;\n+      w.s.high = (unsigned long)uu.s.high >> b;\n+      w.s.low = ((unsigned long)uu.s.low >> b) | carries;\n+    }\n+\n+  return w.ll;\n+}\n+#endif\n+\n+#ifdef L_ashldi3\n+long long\n+__ashldi3 (u, b)\n+     long long u;\n+     int b;\n+{\n+  long_long w;\n+  long bm;\n+  long_long uu;\n+\n+  if (b == 0)\n+    return u;\n+\n+  uu.ll = u;\n+\n+  bm = (sizeof (long) * BITS_PER_UNIT) - b;\n+  if (bm <= 0)\n+    {\n+      w.s.low = 0;\n+      w.s.high = (unsigned long)uu.s.low << -bm;\n+    }\n+  else\n+    {\n+      unsigned long carries = (unsigned long)uu.s.low >> bm;\n+      w.s.low = (unsigned long)uu.s.low << b;\n+      w.s.high = ((unsigned long)uu.s.high << b) | carries;\n+    }\n+\n+  return w.ll;\n+}\n+#endif\n+\n+#ifdef L_ashrdi3\n+long long\n+__ashrdi3 (u, b)\n+     long long u;\n+     int b;\n+{\n+  long_long w;\n+  long bm;\n+  long_long uu;\n+\n+  if (b == 0)\n+    return u;\n+\n+  uu.ll = u;\n+\n+  bm = (sizeof (long) * BITS_PER_UNIT) - b;\n+  if (bm <= 0)\n+    {\n+      /* w.s.high = 1..1 or 0..0 */\n+      w.s.high = uu.s.high >> (sizeof (long) * BITS_PER_UNIT - 1);\n+      w.s.low = uu.s.high >> -bm;\n+    }\n+  else\n+    {\n+      unsigned long carries = (unsigned long)uu.s.high << bm;\n+      w.s.high = uu.s.high >> b;\n+      w.s.low = ((unsigned long)uu.s.low >> b) | carries;\n+    }\n+\n+  return w.ll;\n+}\n+#endif\n+\f\n+#ifdef L_muldi3\n+long long\n+__muldi3 (u, v)\n+     long long u, v;\n+{\n+  long_long w;\n+  long_long uu, vv;\n+\n+  uu.ll = u,\n+  vv.ll = v;\n+\n+  w.ll = __umulsidi3 (uu.s.low, vv.s.low);\n+  w.s.high += ((unsigned long) uu.s.low * (unsigned long) vv.s.high\n+\t       + (unsigned long) uu.s.high * (unsigned long) vv.s.low);\n+\n+  return w.ll;\n+}\n+#endif\n+\f\n+#ifdef L_udivmoddi4\n+static const unsigned char __clz_tab[] =\n+{\n+  0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n+  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n+  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n+  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n+  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n+  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n+  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n+  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n+};\n+\n+unsigned long long\n+__udivmoddi4 (n, d, rp)\n+     unsigned long long n, d;\n+     unsigned long long int *rp;\n+{\n+  long_long ww;\n+  long_long nn, dd;\n+  long_long rr;\n+  unsigned long d0, d1, n0, n1, n2;\n+  unsigned long q0, q1;\n+  unsigned b, bm;\n+\n+  nn.ll = n;\n+  dd.ll = d;\n+\n+  d0 = dd.s.low;\n+  d1 = dd.s.high;\n+  n0 = nn.s.low;\n+  n1 = nn.s.high;\n+\n+#if !UDIV_NEEDS_NORMALIZATION\n+  if (d1 == 0)\n+    {\n+      if (d0 > n1)\n+\t{\n+\t  /* 0q = nn / 0D */\n+\n+\t  udiv_qrnnd (q0, n0, n1, n0, d0);\n+\t  q1 = 0;\n+\n+\t  /* Remainder in n0.  */\n+\t}\n+      else\n+\t{\n+\t  /* qq = NN / 0d */\n+\n+\t  if (d0 == 0)\n+\t    d0 = 1 / d0;\t/* Divide intentionally by zero.  */\n+\n+\t  udiv_qrnnd (q1, n1, 0, n1, d0);\n+\t  udiv_qrnnd (q0, n0, n1, n0, d0);\n+\n+\t  /* Remainder in n0.  */\n+\t}\n+\n+      if (rp != 0)\n+\t{\n+\t  rr.s.low = n0;\n+\t  rr.s.high = 0;\n+\t  *rp = rr.ll;\n+\t}\n+    }\n+\n+#else /* UDIV_NEEDS_NORMALIZATION */\n+\n+  if (d1 == 0)\n+    {\n+      if (d0 > n1)\n+\t{\n+\t  /* 0q = nn / 0D */\n+\n+\t  count_leading_zeros (bm, d0);\n+\n+\t  if (bm != 0)\n+\t    {\n+\t      /* Normalize, i.e. make the most significant bit of the\n+\t\t denominator set.  */\n+\n+\t      d0 = d0 << bm;\n+\t      n1 = (n1 << bm) | (n0 >> (LONG_TYPE_SIZE - bm));\n+\t      n0 = n0 << bm;\n+\t    }\n+\n+\t  udiv_qrnnd (q0, n0, n1, n0, d0);\n+\t  q1 = 0;\n+\n+\t  /* Remainder in n0 >> bm.  */\n+\t}\n+      else\n+\t{\n+\t  /* qq = NN / 0d */\n+\n+\t  if (d0 == 0)\n+\t    d0 = 1 / d0;\t/* Divide intentionally by zero.  */\n+\n+\t  count_leading_zeros (bm, d0);\n+\n+\t  if (bm == 0)\n+\t    {\n+\t      /* From (n1 >= d0) /\\ (the most significant bit of d0 is set),\n+\t\t conclude (the most significant bit of n1 is set) /\\ (the\n+\t\t leading quotient digit q1 = 1).\n+\n+\t\t This special case is necessary, not an optimization.\n+\t\t (Shifts counts of LONG_TYPE_SIZE are undefined.)  */\n+\n+\t      n1 -= d0;\n+\t      q1 = 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Normalize.  */\n+\n+\t      b = LONG_TYPE_SIZE - bm;\n+\n+\t      d0 = d0 << bm;\n+\t      n2 = n1 >> b;\n+\t      n1 = (n1 << bm) | (n0 >> b);\n+\t      n0 = n0 << bm;\n+\n+\t      udiv_qrnnd (q1, n1, n2, n1, d0);\n+\t    }\n+\n+\t  /* n1 != d0... */\n+\n+\t  udiv_qrnnd (q0, n0, n1, n0, d0);\n+\n+\t  /* Remainder in n0 >> bm.  */\n+\t}\n+\n+      if (rp != 0)\n+\t{\n+\t  rr.s.low = n0 >> bm;\n+\t  rr.s.high = 0;\n+\t  *rp = rr.ll;\n+\t}\n+    }\n+#endif /* UDIV_NEEDS_NORMALIZATION */\n+\n+  else\n+    {\n+      if (d1 > n1)\n+\t{\n+\t  /* 00 = nn / DD */\n+\n+\t  q0 = 0;\n+\t  q1 = 0;\n+\n+\t  /* Remainder in n1n0.  */\n+\t  if (rp != 0)\n+\t    {\n+\t      rr.s.low = n0;\n+\t      rr.s.high = n1;\n+\t      *rp = rr.ll;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* 0q = NN / dd */\n+\n+\t  count_leading_zeros (bm, d1);\n+\t  if (bm == 0)\n+\t    {\n+\t      /* From (n1 >= d1) /\\ (the most significant bit of d1 is set),\n+\t\t conclude (the most significant bit of n1 is set) /\\ (the\n+\t\t quotient digit q0 = 0 or 1).\n+\n+\t\t This special case is necessary, not an optimization.  */\n+\n+\t      /* The condition on the next line takes advantage of that\n+\t\t n1 >= d1 (true due to program flow).  */\n+\t      if (n1 > d1 || n0 >= d0)\n+\t\t{\n+\t\t  q0 = 1;\n+\t\t  sub_ddmmss (n1, n0, n1, n0, d1, d0);\n+\t\t}\n+\t      else\n+\t\tq0 = 0;\n+\n+\t      q1 = 0;\n+\n+\t      if (rp != 0)\n+\t\t{\n+\t\t  rr.s.low = n0;\n+\t\t  rr.s.high = n1;\n+\t\t  *rp = rr.ll;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      unsigned long m1, m0;\n+\t      /* Normalize.  */\n+\n+\t      b = LONG_TYPE_SIZE - bm;\n+\n+\t      d1 = (d1 << bm) | (d0 >> b);\n+\t      d0 = d0 << bm;\n+\t      n2 = n1 >> b;\n+\t      n1 = (n1 << bm) | (n0 >> b);\n+\t      n0 = n0 << bm;\n+\n+\t      udiv_qrnnd (q0, n1, n2, n1, d1);\n+\t      umul_ppmm (m1, m0, q0, d0);\n+\n+\t      if (m1 > n1 || (m1 == n1 && m0 > n0))\n+\t\t{\n+\t\t  q0--;\n+\t\t  sub_ddmmss (m1, m0, m1, m0, d1, d0);\n+\t\t}\n+\n+\t      q1 = 0;\n+\n+\t      /* Remainder in (n1n0 - m1m0) >> bm.  */\n+\t      if (rp != 0)\n+\t\t{\n+\t\t  sub_ddmmss (n1, n0, n1, n0, m1, m0);\n+\t\t  rr.s.low = (n1 << b) | (n0 >> bm);\n+\t\t  rr.s.high = n1 >> bm;\n+\t\t  *rp = rr.ll;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  ww.s.low = q0;\n+  ww.s.high = q1;\n+  return ww.ll;\n+}\n+#endif\n+\n+#ifdef L_divdi3\n+unsigned long long __udivmoddi4();\n+long long\n+__divdi3 (u, v)\n+     long long u, v;\n+{\n+  int c = 0;\n+  long_long uu, vv;\n+  long long w;\n+\n+  uu.ll = u;\n+  vv.ll = v;\n+\n+  if (uu.s.high < 0)\n+    c = ~c,\n+    uu.ll = __negdi2 (uu.ll);\n+  if (vv.s.high < 0)\n+    c = ~c,\n+    vv.ll = __negdi2 (vv.ll);\n+\n+  w = __udivmoddi4 (uu.ll, vv.ll, (unsigned long long *) 0);\n+  if (c)\n+    w = __negdi2 (w);\n+\n+  return w;\n+}\n+#endif\n+\n+#ifdef L_moddi3\n+unsigned long long __udivmoddi4();\n+long long\n+__moddi3 (u, v)\n+     long long u, v;\n+{\n+  int c = 0;\n+  long_long uu, vv;\n+  long long w;\n+\n+  uu.ll = u;\n+  vv.ll = v;\n+\n+  if (uu.s.high < 0)\n+    c = ~c,\n+    uu.ll = __negdi2 (uu.ll);\n+  if (vv.s.high < 0)\n+    vv.ll = __negdi2 (vv.ll);\n+\n+  (void) __udivmoddi4 (uu.ll, vv.ll, &w);\n+  if (c)\n+    w = __negdi2 (w);\n+\n+  return w;\n+}\n+#endif\n+\n+#ifdef L_umoddi3\n+unsigned long long __udivmoddi4();\n+unsigned long long\n+__umoddi3 (u, v)\n+     unsigned long long u, v;\n+{\n+  long long w;\n+\n+  (void) __udivmoddi4 (u, v, &w);\n+\n+  return w;\n+}\n+#endif\n+\n+#ifdef L_udivdi3\n+unsigned long long __udivmoddi4();\n+unsigned long long\n+__udivdi3 (n, d)\n+     unsigned long long n, d;\n+{\n+  return __udivmoddi4 (n, d, (unsigned long long *) 0);\n+}\n+#endif\n+\f\n+#ifdef L_cmpdi2\n+SItype\n+__cmpdi2 (a, b)\n+     long long a, b;\n+{\n+  long_long au, bu;\n+\n+  au.ll = a, bu.ll = b;\n+\n+  if (au.s.high < bu.s.high)\n+    return 0;\n+  else if (au.s.high > bu.s.high)\n+    return 2;\n+  if ((unsigned long) au.s.low < (unsigned long) bu.s.low)\n+    return 0;\n+  else if ((unsigned long) au.s.low > (unsigned long) bu.s.low)\n+    return 2;\n+  return 1;\n+}\n+#endif\n+\n+#ifdef L_ucmpdi2\n+SItype\n+__ucmpdi2 (a, b)\n+     long long a, b;\n+{\n+  long_long au, bu;\n+\n+  au.ll = a, bu.ll = b;\n+\n+  if ((unsigned long) au.s.high < (unsigned long) bu.s.high)\n+    return 0;\n+  else if ((unsigned long) au.s.high > (unsigned long) bu.s.high)\n+    return 2;\n+  if ((unsigned long) au.s.low < (unsigned long) bu.s.low)\n+    return 0;\n+  else if ((unsigned long) au.s.low > (unsigned long) bu.s.low)\n+    return 2;\n+  return 1;\n+}\n+#endif\n+\f\n+#ifdef L_fixunsdfdi\n+#define WORD_SIZE (sizeof (long) * BITS_PER_UNIT)\n+#define HIGH_WORD_COEFF (((long long) 1) << WORD_SIZE)\n+\n+long long\n+__fixunsdfdi (a)\n+     double a;\n+{\n+  double b;\n+  unsigned long long v;\n+\n+  if (a < 0)\n+    return 0;\n+\n+  /* Compute high word of result, as a flonum.  */\n+  b = (a / HIGH_WORD_COEFF);\n+  /* Convert that to fixed (but not to long long!),\n+     and shift it into the high word.  */\n+  v = (unsigned long int) b;\n+  v <<= WORD_SIZE;\n+  /* Remove high part from the double, leaving the low part as flonum.  */\n+  a -= (double)v;\n+  /* Convert that to fixed (but not to long long!) and add it in.\n+     Sometimes A comes out negative.  This is significant, since\n+     A has more bits than a long int does.  */\n+  if (a < 0)\n+    v -= (unsigned long int) (- a);\n+  else\n+    v += (unsigned long int) a;\n+  return v;\n+}\n+#endif\n+\n+#ifdef L_fixdfdi\n+long long\n+__fixdfdi (a)\n+     double a;\n+{\n+  if (a < 0)\n+    return - __fixunsdfdi (-a);\n+  return __fixunsdfdi (a);\n+}\n+#endif\n+\n+#ifdef L_fixunssfdi\n+#define WORD_SIZE (sizeof (long) * BITS_PER_UNIT)\n+#define HIGH_WORD_COEFF (((long long) 1) << WORD_SIZE)\n+\n+long long\n+__fixunssfdi (float original_a)\n+{\n+  /* Convert the float to a double, because that is surely not going\n+     to lose any bits.  Some day someone else can write a faster version\n+     that avoids converting to double, and verify it really works right.  */\n+  double a = original_a;\n+  double b;\n+  unsigned long long v;\n+\n+  if (a < 0)\n+    return 0;\n+\n+  /* Compute high word of result, as a flonum.  */\n+  b = (a / HIGH_WORD_COEFF);\n+  /* Convert that to fixed (but not to long long!),\n+     and shift it into the high word.  */\n+  v = (unsigned long int) b;\n+  v <<= WORD_SIZE;\n+  /* Remove high part from the double, leaving the low part as flonum.  */\n+  a -= (double)v;\n+  /* Convert that to fixed (but not to long long!) and add it in.\n+     Sometimes A comes out negative.  This is significant, since\n+     A has more bits than a long int does.  */\n+  if (a < 0)\n+    v -= (unsigned long int) (- a);\n+  else\n+    v += (unsigned long int) a;\n+  return v;\n+}\n+#endif\n+\n+#ifdef L_fixsfdi\n+long long\n+__fixsfdi (float a)\n+{\n+  if (a < 0)\n+    return - __fixunssfdi (-a);\n+  return __fixunssfdi (a);\n+}\n+#endif\n+\n+#ifdef L_floatdidf\n+#define WORD_SIZE (sizeof (long) * BITS_PER_UNIT)\n+#define HIGH_HALFWORD_COEFF (((long long) 1) << (WORD_SIZE / 2))\n+#define HIGH_WORD_COEFF (((long long) 1) << WORD_SIZE)\n+\n+double\n+__floatdidf (u)\n+     long long u;\n+{\n+  double d;\n+  int negate = 0;\n+\n+  if (u < 0)\n+    u = -u, negate = 1;\n+\n+  d = (unsigned int) (u >> WORD_SIZE);\n+  d *= HIGH_HALFWORD_COEFF;\n+  d *= HIGH_HALFWORD_COEFF;\n+  d += (unsigned int) (u & (HIGH_WORD_COEFF - 1));\n+\n+  return (negate ? -d : d);\n+}\n+#endif\n+\n+#ifdef L_floatdisf\n+#define WORD_SIZE (sizeof (long) * BITS_PER_UNIT)\n+#define HIGH_HALFWORD_COEFF (((long long) 1) << (WORD_SIZE / 2))\n+#define HIGH_WORD_COEFF (((long long) 1) << WORD_SIZE)\n+\n+float\n+__floatdisf (u)\n+     long long u;\n+{\n+  float f;\n+  int negate = 0;\n+\n+  if (u < 0)\n+    u = -u, negate = 1;\n+\n+  f = (unsigned int) (u >> WORD_SIZE);\n+  f *= HIGH_HALFWORD_COEFF;\n+  f *= HIGH_HALFWORD_COEFF;\n+  f += (unsigned int) (u & (HIGH_WORD_COEFF - 1));\n+\n+  return (negate ? -f : f);\n+}\n+#endif\n+\n+#ifdef L_fixunsdfsi\n+#include \"limits.h\"\n+\n+unsigned SItype\n+__fixunsdfsi (a)\n+     double a;\n+{\n+  if (a >= - (double) LONG_MIN)\n+    return (SItype) (a + LONG_MIN) - LONG_MIN;\n+  return (SItype) a;\n+}\n+#endif\n+\n+#ifdef L_fixunssfsi\n+#include \"limits.h\"\n+\n+unsigned SItype\n+__fixunssfsi (float a)\n+{\n+  if (a >= - (float) LONG_MIN)\n+    return (SItype) (a + LONG_MIN) - LONG_MIN;\n+  return (SItype) a;\n+}\n+#endif\n+\f\n+#ifdef L_varargs\n+#ifdef __i860__\n+#ifdef SVR4\n+\tasm (\"\t.text\");\n+\tasm (\"\t.align\t4\");\n+\n+\tasm (\".globl\t__builtin_saveregs\");\n+asm (\"__builtin_saveregs:\");\n+\tasm (\"\tandnot\t0x0f,%sp,%sp\");\t/* round down to 16-byte boundary */\n+\tasm (\"\tadds\t-96,%sp,%sp\");  /* allocate stack space for reg save\n+\t\t\t\t\t   area and also for a new va_list\n+\t\t\t\t\t   structure */\n+\t/* Save all argument registers in the arg reg save area.  The\n+\t   arg reg save area must have the following layout (according\n+\t   to the svr4 ABI):\n+\n+\t\tstruct {\n+\t\t  union  {\n+\t\t    float freg[8];\n+\t\t    double dreg[4];\n+\t\t  } float_regs;\n+\t\t  long\tireg[12];\n+\t\t};\n+\t*/\n+\n+\tasm (\"\tfst.q\t%f8,  0(%sp)\"); /* save floating regs (f8-f15)  */\n+\tasm (\"\tfst.q\t%f12,16(%sp)\"); \n+\n+\tasm (\"\tst.l\t%r16,32(%sp)\"); /* save integer regs (r16-r27) */\n+\tasm (\"\tst.l\t%r17,36(%sp)\"); \n+\tasm (\"\tst.l\t%r18,40(%sp)\");\n+\tasm (\"\tst.l\t%r19,44(%sp)\");\n+\tasm (\"\tst.l\t%r20,48(%sp)\");\n+\tasm (\"\tst.l\t%r21,52(%sp)\");\n+\tasm (\"\tst.l\t%r22,56(%sp)\");\n+\tasm (\"\tst.l\t%r23,60(%sp)\");\n+\tasm (\"\tst.l\t%r24,64(%sp)\");\n+\tasm (\"\tst.l\t%r25,68(%sp)\");\n+\tasm (\"\tst.l\t%r26,72(%sp)\");\n+\tasm (\"\tst.l\t%r27,76(%sp)\");\n+\n+\tasm (\"\tadds\t80,%sp,%r16\");  /* compute the address of the new\n+\t\t\t\t\t   va_list structure.  Put in into\n+\t\t\t\t\t   r16 so that it will be returned\n+\t\t\t\t\t   to the caller.  */\n+\n+\t/* Initialize all fields of the new va_list structure.  This\n+\t   structure looks like:\n+\n+\t\ttypedef struct {\n+\t\t    unsigned long\tireg_used;\n+\t\t    unsigned long\tfreg_used;\n+\t\t    long\t\t*reg_base;\n+\t\t    long\t\t*mem_ptr;\n+\t\t} va_list;\n+\t*/\n+\n+\tasm (\"\tst.l\t%r0, 0(%r16)\"); /* nfixed */\n+\tasm (\"\tst.l\t%r0, 4(%r16)\"); /* nfloating */\n+\tasm (\"  st.l    %sp, 8(%r16)\"); /* __va_ctl points to __va_struct.  */\n+\tasm (\"\tbri\t%r1\");\t\t/* delayed return */\n+\tasm (\"\tst.l\t%r28,12(%r16)\"); /* pointer to overflow args */\n+\n+#else /* not SVR4 */\n+\tasm (\"\t.text\");\n+\tasm (\"\t.align\t4\");\n+\n+\tasm (\".globl\t___builtin_saveregs\");\n+\tasm (\"___builtin_saveregs:\");\n+\tasm (\"\tmov\tsp,r30\");\n+\tasm (\"\tandnot\t0x0f,sp,sp\");\n+\tasm (\"\tadds\t-96,sp,sp\");  /* allocate sufficient space on the stack */\n+\n+/* Fill in the __va_struct.  */\n+\tasm (\"\tst.l\tr16, 0(sp)\"); /* save integer regs (r16-r27) */\n+\tasm (\"\tst.l\tr17, 4(sp)\"); /* int\tfixed[12] */\n+\tasm (\"\tst.l\tr18, 8(sp)\");\n+\tasm (\"\tst.l\tr19,12(sp)\");\n+\tasm (\"\tst.l\tr20,16(sp)\");\n+\tasm (\"\tst.l\tr21,20(sp)\");\n+\tasm (\"\tst.l\tr22,24(sp)\");\n+\tasm (\"\tst.l\tr23,28(sp)\");\n+\tasm (\"\tst.l\tr24,32(sp)\");\n+\tasm (\"\tst.l\tr25,36(sp)\");\n+\tasm (\"\tst.l\tr26,40(sp)\");\n+\tasm (\"\tst.l\tr27,44(sp)\");\n+\n+\tasm (\"\tfst.q\tf8, 48(sp)\"); /* save floating regs (f8-f15) */\n+\tasm (\"\tfst.q\tf12,64(sp)\"); /* int floating[8] */\n+\n+/* Fill in the __va_ctl.  */\n+\tasm (\"  st.l    sp, 80(sp)\"); /* __va_ctl points to __va_struct.  */\n+\tasm (\"\tst.l\tr28,84(sp)\"); /* pointer to more args */\n+\tasm (\"\tst.l\tr0, 88(sp)\"); /* nfixed */\n+\tasm (\"\tst.l\tr0, 92(sp)\"); /* nfloating */\n+\n+\tasm (\"\tadds\t80,sp,r16\");  /* return address of the __va_ctl.  */\n+\tasm (\"\tbri\tr1\");\n+\tasm (\"\tmov\tr30,sp\");\n+\t\t\t\t/* recover stack and pass address to start \n+\t\t\t\t   of data.  */\n+#endif /* not SVR4 */\n+#else /* not __i860__ */\n+#ifdef __sparc__\n+\tasm (\".global ___builtin_saveregs\");\n+\tasm (\"___builtin_saveregs:\");\n+\tasm (\"st %i0,[%fp+68]\");\n+\tasm (\"st %i1,[%fp+72]\");\n+\tasm (\"st %i2,[%fp+76]\");\n+\tasm (\"st %i3,[%fp+80]\");\n+\tasm (\"st %i4,[%fp+84]\");\n+\tasm (\"retl\");\n+\tasm (\"st %i5,[%fp+88]\");\n+#else /* not __sparc__ */\n+#if defined(__MIPSEL__) | defined(__R3000__) | defined(__R2000__) | defined(__mips__)\n+\n+  asm (\"\t.text\");\n+  asm (\"\t.ent __builtin_saveregs\");\n+  asm (\"\t.globl __builtin_saveregs\");\n+  asm (\"__builtin_saveregs:\");\n+  asm (\"\tsw\t$4,0($30)\");\n+  asm (\"\tsw\t$5,4($30)\");\n+  asm (\"\tsw\t$6,8($30)\");\n+  asm (\"\tsw\t$7,12($30)\");\n+  asm (\"\tj\t$31\");\n+  asm (\"\t.end __builtin_saveregs\");\n+#else /* not __mips__, etc. */\n+__builtin_saveregs ()\n+{\n+  abort ();\n+}\n+#endif /* not __mips__ */\n+#endif /* not __sparc__ */\n+#endif /* not __i860__ */\n+#endif\n+\f\n+#ifdef L_eprintf\n+#undef NULL /* Avoid errors if stdio.h and our stddef.h mismatch.  */\n+#include <stdio.h>\n+/* This is used by the `assert' macro.  */\n+void\n+__eprintf (string, expression, line, filename)\n+     char *string;\n+     char *expression;\n+     int line;\n+     char *filename;\n+{\n+  fprintf (stderr, string, expression, line, filename);\n+  fflush (stderr);\n+  abort ();\n+}\n+#endif\n+\n+#ifdef L_bb\n+/* Avoid warning from ranlib about empty object file.  */\n+void\n+__bb_avoid_warning ()\n+{}\n+\n+#if defined (__sun__) && defined (__mc68000__)\n+struct bb\n+{\n+  int initialized;\n+  char *filename;\n+  int *counts;\n+  int ncounts;\n+  int zero_word;\n+  int *addresses;\n+};\n+\n+extern int ___tcov_init;\n+\n+__bb_init_func (blocks)\n+\tstruct bb *blocks;\n+{\n+  if (! ___tcov_init)\n+    ___tcov_init_func ();\n+\n+  ___bb_link (blocks->filename, blocks->counts, blocks->ncounts);\n+}\n+\n+#endif\n+#endif\n+\f\n+/* frills for C++ */\n+\n+#ifdef L_builtin_new\n+typedef void (*vfp)(void);\n+\n+extern vfp __new_handler;\n+\n+void *\n+__builtin_new (sz)\n+     long sz;\n+{\n+  void *p;\n+\n+  p = (void *) malloc (sz);\n+  if (p == 0)\n+    (*__new_handler) ();\n+  return p;\n+}\n+#endif\n+\n+#ifdef L_builtin_New\n+typedef void (*vfp)(void);\n+\n+static void default_new_handler ();\n+\n+vfp __new_handler = default_new_handler;\n+\n+void *\n+__builtin_vec_new (p, maxindex, size, ctor)\n+     void *p;\n+     int maxindex, size;\n+     void (*ctor)(void *);\n+{\n+  int i, nelts = maxindex + 1;\n+  void *rval;\n+\n+  if (p == 0)\n+    p = (void *)__builtin_new (nelts * size);\n+\n+  rval = p;\n+\n+  for (i = 0; i < nelts; i++)\n+    {\n+      (*ctor) (p);\n+      p += size;\n+    }\n+\n+  return rval;\n+}\n+\n+vfp\n+__set_new_handler (handler)\n+     vfp handler;\n+{\n+  vfp prev_handler;\n+\n+  prev_handler = __new_handler;\n+  if (handler == 0) handler = default_new_handler;\n+  __new_handler = handler;\n+  return prev_handler;\n+}\n+\n+vfp\n+set_new_handler (handler)\n+     vfp handler;\n+{\n+  return __set_new_handler (handler);\n+}\n+\n+static void\n+default_new_handler ()\n+{\n+  /* don't use fprintf (stderr, ...) because it may need to call malloc.  */\n+  /* This should really print the name of the program, but that is hard to\n+     do.  We need a standard, clean way to get at the name.  */\n+  write (2, \"Virtual memory exceeded in `new'\\n\", 33);\n+  /* don't call exit () because that may call global destructors which\n+     may cause a loop.  */\n+  _exit (-1);\n+}\n+#endif\n+\f\n+#ifdef L_builtin_del\n+typedef void (*vfp)(void);\n+\n+void\n+__builtin_delete (ptr)\n+     void *ptr;\n+{\n+  if (ptr)\n+    free (ptr);\n+}\n+\n+void\n+__builtin_vec_delete (ptr, maxindex, size, dtor, auto_delete_vec, auto_delete)\n+     void *ptr;\n+     int maxindex, size;\n+     void (*dtor)();\n+     int auto_delete;\n+{\n+  int i, nelts = maxindex + 1;\n+  void *p = ptr;\n+\n+  ptr += nelts * size;\n+\n+  for (i = 0; i < nelts; i++)\n+    {\n+      ptr -= size;\n+      (*dtor) (ptr, auto_delete);\n+    }\n+\n+  if (auto_delete_vec)\n+    __builtin_delete (p);\n+}\n+\n+#endif\n+\n+#ifdef L_shtab\n+unsigned int __shtab[] = {\n+    0x00000001, 0x00000002, 0x00000004, 0x00000008,\n+    0x00000010, 0x00000020, 0x00000040, 0x00000080,\n+    0x00000100, 0x00000200, 0x00000400, 0x00000800,\n+    0x00001000, 0x00002000, 0x00004000, 0x00008000,\n+    0x00010000, 0x00020000, 0x00040000, 0x00080000,\n+    0x00100000, 0x00200000, 0x00400000, 0x00800000,\n+    0x01000000, 0x02000000, 0x04000000, 0x08000000,\n+    0x10000000, 0x20000000, 0x40000000, 0x80000000\n+  };\n+#endif\n+\f\n+#ifdef L_clear_cache\n+/* Clear part of an instruction cache.  */\n+\n+#define INSN_CACHE_PLANE_SIZE (INSN_CACHE_SIZE / INSN_CACHE_DEPTH)\n+\n+void\n+__clear_cache (beg, end)\n+     char *beg, *end;\n+{\n+#ifdef INSN_CACHE_SIZE\n+  static char array[INSN_CACHE_SIZE + INSN_CACHE_PLANE_SIZE + INSN_CACHE_LINE_WIDTH];\n+  static int initialized = 0;\n+  int offset;\n+  unsigned int start_addr, end_addr;\n+  typedef (*function_ptr) ();\n+\n+#if (INSN_CACHE_SIZE / INSN_CACHE_LINE_WIDTH) < 16\n+  /* It's cheaper to clear the whole cache.\n+     Put in a series of jump instructions so that calling the beginning\n+     of the cache will clear the whole thing.  */\n+\n+  if (! initialized)\n+    {\n+      int ptr = (((int) array + INSN_CACHE_LINE_WIDTH - 1)\n+\t\t & -INSN_CACHE_LINE_WIDTH);\n+      int end_ptr = ptr + INSN_CACHE_SIZE;\n+\n+      while (ptr < end_ptr)\n+\t{\n+\t  *(INSTRUCTION_TYPE *)ptr\n+\t    = JUMP_AHEAD_INSTRUCTION + INSN_CACHE_LINE_WIDTH;\n+\t  ptr += INSN_CACHE_LINE_WIDTH;\n+\t}\n+      *(INSTRUCTION_TYPE *)(ptr - INSN_CACHE_LINE_WIDTH) = RETURN_INSTRUCTION;\n+\n+      initialized = 1;\n+    }\n+\n+  /* Call the beginning of the sequence.  */\n+  (((function_ptr) (((int) array + INSN_CACHE_LINE_WIDTH - 1)\n+\t\t    & -INSN_CACHE_LINE_WIDTH))\n+   ());\n+\n+#else /* Cache is large.  */\n+\n+  if (! initialized)\n+    {\n+      int ptr = (((int) array + INSN_CACHE_LINE_WIDTH - 1)\n+\t\t & -INSN_CACHE_LINE_WIDTH);\n+\n+      while (ptr < (int) array + sizeof array)\n+\t{\n+\t  *(INSTRUCTION_TYPE *)ptr = RETURN_INSTRUCTION;\n+\t  ptr += INSN_CACHE_LINE_WIDTH;\n+\t}\n+\n+      initialized = 1;\n+    }\n+\n+  /* Find the location in array that occupies the same cache line as BEG.  */\n+\n+  offset = ((int) beg & -INSN_CACHE_LINE_WIDTH) & (INSN_CACHE_PLANE_SIZE - 1);\n+  start_addr = (((int) (array + INSN_CACHE_PLANE_SIZE - 1)\n+\t\t & -INSN_CACHE_PLANE_SIZE)\n+\t\t+ offset);\n+\n+  /* Compute the cache alignment of the place to stop clearing.  */\n+#if 0  /* This is not needed for gcc's purposes.  */\n+  /* If the block to clear is bigger than a cache plane,\n+     we clear the entire cache, and OFFSET is already correct.  */ \n+  if (end < beg + INSN_CACHE_PLANE_SIZE)\n+#endif\n+    offset = (((int) (end + INSN_CACHE_LINE_WIDTH - 1)\n+\t       & -INSN_CACHE_LINE_WIDTH)\n+\t      & (INSN_CACHE_PLANE_SIZE - 1));\n+\n+#if INSN_CACHE_DEPTH > 1\n+  end_addr = (start_addr & -INSN_CACHE_PLANE_SIZE) + offset;\n+  if (end_addr <= start_addr)\n+    end_addr += INSN_CACHE_PLANE_SIZE;\n+\n+  for (plane = 0; plane < INSN_CACHE_DEPTH; plane++)\n+    {\n+      int addr = start_addr + plane * INSN_CACHE_PLANE_SIZE;\n+      int stop = end_addr + plane * INSN_CACHE_PLANE_SIZE;\n+\n+      while (addr != stop)\n+\t{\n+\t  /* Call the return instruction at ADDR.  */\n+\t  ((function_ptr) addr) ();\n+\n+\t  addr += INSN_CACHE_LINE_WIDTH;\n+\t}\n+    }\n+#else /* just one plane */\n+  do\n+    {\n+      /* Call the return instruction at START_ADDR.  */\n+      ((function_ptr) start_addr) ();\n+\n+      start_addr += INSN_CACHE_LINE_WIDTH;\n+    }\n+  while ((start_addr % INSN_CACHE_SIZE) != offset);\n+#endif /* just one plane */\n+#endif /* Cache is large */\n+#endif /* Cache exists */\n+}\n+\n+#endif /* L_clear_cache */\n+\f\n+#ifdef L_trampoline\n+\n+/* Jump to a trampoline, loading the static chain address.  */\n+\n+#ifdef TRANSFER_FROM_TRAMPOLINE \n+TRANSFER_FROM_TRAMPOLINE \n+#endif\n+\n+#ifdef __convex__\n+\n+/* Make stack executable so we can call trampolines on stack.\n+   This is called from INITIALIZE_TRAMPOLINE in convex.h.  */\n+\n+#include <sys/mman.h>\n+#include <sys/vmparam.h>\n+#include <machine/machparam.h>\n+\n+void\n+__enable_execute_stack ()\n+{\n+  int fp;\n+  static unsigned lowest = USRSTACK;\n+  unsigned current = (unsigned) &fp & -NBPG;\n+\n+  if (lowest > current)\n+    {\n+      unsigned len = lowest - current;\n+      mremap (current, &len, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE);\n+      lowest = current;\n+    }\n+\n+  /* Clear instruction cache in case an old trampoline is in it. */\n+  asm (\"pich\");\n+}\n+#endif /* __convex__ */\n+#endif /* L_trampoline */\n+\f\n+#ifdef L__main\n+\n+#include \"gbl-ctors.h\"\n+\n+/* Run all the global destructors on exit from the program.  */\n+\n+void\n+__do_global_dtors ()\n+{\n+  int nptrs = *(int *)__DTOR_LIST__;\n+  int i;\n+\n+  /* Some systems place the number of pointers\n+     in the first word of the table.\n+     On other systems, that word is -1.\n+     In all cases, the table is null-terminated.  */\n+\n+  /* If the length is not recorded, count up to the null.  */\n+  if (nptrs == -1)\n+    for (nptrs = 0; __DTOR_LIST__[nptrs + 1] != 0; nptrs++);\n+\n+  /* GNU LD format.  */\n+  for (i = nptrs; i >= 1; i--)\n+    __DTOR_LIST__[i] ();\n+}\n+\n+#ifndef INIT_SECTION_ASM_OP\n+/* Run all the global constructors on entry to the program.  */\n+\n+#ifndef ON_EXIT /* DO_GLOBAL_CTORS_BODY uses ON_EXIT */\n+#define ON_EXIT(a, b)\n+#else\n+/* Make sure the exit routine is pulled in to define the globals as\n+   bss symbols, just in case the linker does not automatically pull\n+   bss definitions from the library.  */\n+\n+extern int _exit_dummy_decl;\n+int *_exit_dummy_ref = &_exit_dummy_decl;\n+#endif /* ON_EXIT */\n+\n+void\n+__do_global_ctors ()\n+{\n+  DO_GLOBAL_CTORS_BODY;\n+}\n+\n+/* Subroutine called automatically by `main'.\n+   Compiling a global function named `main'\n+   produces an automatic call to this function at the beginning.\n+\n+   For many systems, this routine calls __do_global_ctors.\n+   For systems which support a .init section we use the .init section\n+   to run __do_global_ctors, so we need not do anything here.  */\n+\n+void\n+__main ()\n+{\n+  /* Support recursive calls to `main': run initializers just once.  */\n+  static initialized = 0;\n+  if (! initialized)\n+    {\n+      initialized = 1;\n+      __do_global_ctors ();\n+    }\n+}\n+#endif /* no INIT_SECTION_ASM_OP */\n+\n+#endif /* L__main */\n+\f\n+#ifdef L_exit\n+\n+#include \"gbl-ctors.h\"\n+\n+/* Provide default definitions for the lists of constructors and\n+   destructors, so that we don't get linker errors.  These symbols are\n+   intentionally bss symbols, so that gld and/or collect will provide\n+   the right values.  */\n+\n+/* We declare the lists here with two elements each,\n+   so that they are valid empty lists if no other definition is loaded.  */\n+#ifndef INIT_SECTION_ASM_OP\n+func_ptr __CTOR_LIST__[2];\n+func_ptr __DTOR_LIST__[2];\n+#endif /* INIT_SECTION_ASM_OP */\n+\n+#ifndef ON_EXIT\n+\n+/* If we have no known way of registering our own __do_global_dtors\n+   routine so that it will be invoked at program exit time, then we\n+   have to define our own exit routine which will get this to happen.  */\n+\n+extern void __do_global_dtors ();\n+extern void _cleanup ();\n+extern void _exit ();\n+\n+void \n+exit (status)\n+     int status;\n+{\n+  __do_global_dtors ();\n+#ifdef EXIT_BODY\n+  EXIT_BODY;\n+#else\n+  _cleanup ();\n+#endif\n+  _exit (status);\n+}\n+\n+#else\n+int _exit_dummy_decl = 0;\t/* prevent compiler & linker warnings */\n+#endif\n+\n+#endif /* L_exit */\n+\f\n+/* In a.out systems, we need to have these dummy constructor and destructor\n+   lists in the library.\n+\n+   When using `collect', the first link will resolve __CTOR_LIST__\n+   and __DTOR_LIST__ to these symbols.  We will then run \"nm\" on the\n+   result, build the correct __CTOR_LIST__ and __DTOR_LIST__, and relink.\n+   Since we don't do the second link if no constructors existed, these\n+   dummies must be fully functional empty lists.\n+\n+   When using `gnu ld', these symbols will be used if there are no\n+   constructors.  If there are constructors, the N_SETV symbol defined\n+   by the linker from the N_SETT's in input files will define __CTOR_LIST__\n+   and __DTOR_LIST__ rather than its being allocated as common storage\n+   by the definitions below.\n+\n+   When using a linker that supports constructor and destructor segments,\n+   these definitions will not be used, since crtbegin.o and crtend.o\n+   (from crtstuff.c) will have already defined __CTOR_LIST__ and\n+    __DTOR_LIST__.  The crt*.o files are passed directly to the linker\n+   on its command line, by gcc.  */\n+\n+/* The list needs two elements:  one is ignored (the old count); the\n+   second is the terminating zero.  Since both values are zero, this\n+   declaration is not initialized, and it becomes `common'.  */\n+\n+#ifdef L_ctor_list\n+#include \"gbl-ctors.h\"\n+func_ptr __CTOR_LIST__[2];\n+#endif\n+\n+#ifdef L_dtor_list\n+#include \"gbl-ctors.h\"\n+func_ptr __DTOR_LIST__[2];\n+#endif"}]}