{"sha": "28cbf42c14d84ef906619aa7c180a72c6acea2fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhjYmY0MmMxNGQ4NGVmOTA2NjE5YWE3YzE4MGE3MmM2YWNlYTJmYg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-03-23T00:44:31Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-03-23T00:44:31Z"}, "message": "59th Cygnus<->FSF merge\n\nFrom-SVN: r9225", "tree": {"sha": "4f1e4e8ef3d2346d45415ed424a05c7b344ede61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f1e4e8ef3d2346d45415ed424a05c7b344ede61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28cbf42c14d84ef906619aa7c180a72c6acea2fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28cbf42c14d84ef906619aa7c180a72c6acea2fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28cbf42c14d84ef906619aa7c180a72c6acea2fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28cbf42c14d84ef906619aa7c180a72c6acea2fb/comments", "author": null, "committer": null, "parents": [{"sha": "e96a50ccad69f136f81e4d81b24282fa78dacb23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e96a50ccad69f136f81e4d81b24282fa78dacb23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e96a50ccad69f136f81e4d81b24282fa78dacb23"}], "stats": {"total": 808, "additions": 618, "deletions": 190}, "files": [{"sha": "331e139e1fe82e684b55e4ffe4a99c52c97b88f3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=28cbf42c14d84ef906619aa7c180a72c6acea2fb", "patch": "@@ -1,3 +1,188 @@\n+Wed Mar 22 15:10:34 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl2.c (finish_prevtable_vardecl, finish_vtable_vardecl): Revert\n+\tBrendan's last change and fix latent problem that causes TD entries\n+\tto not come out when the things that need them has yet to be\n+\texpanded.\n+\n+Wed Mar 22 15:12:00 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck.c (build_binary_op_nodefault, comparison ops): Update type0\n+\tand type1, since we might have changed op0 or op1.\n+\n+Wed Mar 22 13:33:45 1995  Jason Merrill  <jason@python.cygnus.com>\n+\n+\t* typeck.c (common_type): Don't mess up templates.\n+\n+Wed Mar 22 04:56:00 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck.c (common_type): Handle ptms properly.  Also handle \n+\tT* -> void*.\n+\t(build_binary_op_nodefault): New variable build_type controls what\n+\ttype is given to the expression when it is created.  Set this to\n+\tboolean_type_node for comparison ops instead of using result_type.\n+\t(comp_target_types): Allow T * -> void *.\n+\n+\t* cvt.c (cp_convert_to_pointer): Do access control when converting\n+\tptms, too.\n+\n+Tue Mar 21 17:25:06 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* parse.y (extern_lang_string): Catch use of linkage specs that\n+\taren't all naming the same language.\n+\n+\t* class.c (finish_struct): Delete accidental duplicate code.\n+\n+Tue Mar 21 14:00:57 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck.c (build_binary_op_nodefault): Disable pedwarns about\n+\tcomparing functions and incomplete types.\n+\n+\t* decl.c (finish_function): Only unset current_function_decl if\n+\t!nested.\n+\t(duplicate_decls): Last change went too far; we only want to stop\n+\tchecking for value/reference ambiguity.\n+\n+Tue Mar 21 01:26:39 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* gc.c (build_generic_desc): Zap the DECL_SIZE so that we can lay it\n+\tout fresh, as the new type may be larger.\n+\n+Mon Mar 20 19:01:10 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* expr.c (extract_init): Try to expand the RTL for the\n+\tinitialization and figure out what it will look like so we can avoid\n+\trun-time initialization.  Disabled for now.\n+\t(extract_scalar_init): Helper for scalar initialization.\n+\t(extract_aggr_init): Helper for aggregate initialization.\n+\n+\t* decl.c (duplicate_decls): Don't complain about ambiguous\n+\tdeclarations.\n+\t(obscure_complex_init): Now returns a tree.  Call extract_init if\n+\twe're optimizing and this is a toplevel decl.\n+\t(finish_decl): Update accordingly.\n+\n+\t* lex.c (check_newline): If we're just changing files (not pushing\n+\tor popping), update input_file_stack->name.\n+\n+Mon Mar 20 17:55:04 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* pt.c (type_unification): Only TEMPLATE_DECLs are handled right now\n+\tin the transitive unification code.\n+\n+Mon Mar 20 16:07:50 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* decl.c (shadow_tag): Don't allow inline, virtual, or explicit on\n+\tnon-functions.\n+\t(grokdeclarator): Don't allow friends to be defined in local classes.\n+\n+Sat Mar 18 04:03:33 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl2.c (finish_prevtable_vardecl): Use DECL_DECLARED_STATIC\n+\trather than DECL_SAVED_INSNS to decide whether or not this method\n+\twas declared inline.\n+\n+\t* method.c (synthesize_method): Turn off DECL_INLINE if\n+\tfunction_cannot_inline_p thinks we're too large.\n+\n+\t* typeck.c (build_indirect_ref): Use build_expr_type_conversion.\n+\n+Fri Mar 17 17:47:36 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* class.c (instantiate_type): Handle pmfs.\n+\n+\t* typeck.c (convert_for_assignment): Check types when assigning one\n+\tpmf to another.\n+\n+\t* decl.c (define_label): Fix logic for printing out the name of the\n+\tlabel in an error message.\n+\n+\t* error.c (dump_expr): Support ARRAY_REF.\n+\n+Fri Mar 17 17:43:02 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* decl2.c (finish_vtable_vardecl): Call build_t_desc here.\n+\t(finish_prevtable_vardecl): Instead of here.\n+\n+Fri Mar 17 14:40:45 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (expand_static_init): Also use expand_aggr_init if the\n+\tinitializer is a TREE_LIST.\t\n+\t(grokdeclarator): Only pedwarn about extra qualification if -pedantic.\n+\n+\t* pt.c (unify): Fix unification of return type.\n+\n+\t* expr.c (fixup_result_decl): Use store_expr, rather than\n+\temit_move_insn, to move the return value into the place where\n+\tcallers will expect it.\n+\n+Thu Mar 16 22:05:25 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* init.c (build_offset_ref): Call assmble_external on functions.\n+\t* typeck.c (build_component_ref): Ditto.\n+\n+Thu Mar 16 20:28:16 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* decl.c (struct saved_scope): Add members base_init_list and\n+\tmember_init_list.\n+\t(push_to_top_level): Save current_base_init_list and\n+\tcurrent_member_init_list to them.\n+\t(pop_from_top_level): Put it back.\n+\n+Thu Mar 16 19:21:14 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* pt.c (instantiate_template): Call assemble_external.\t\n+\n+Thu Mar 16 18:07:54 1995  Brendan Kehoe  (brendan@phydeaux.cygnus.com)\n+\n+\t* class.c: Include rtl.h, to get NULL_RTX.\n+\t(finish_struct): Also zero out DECL_SAVED_INSNS, to avoid problems\n+\ton hosts with different sizes for each part of the union.\n+\t* tree.c: Also include rtl.h.\n+\t(layout_basetypes): Same change for DECL_SAVED_INSNS.\n+\n+Thu Mar 16 13:57:36 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* pt.c (unify): Fix array domain unification for 64-bit targets.\n+\n+\t* decl2.c (finish_file): Push bizarre type decl before walking the\n+\tvtables the first time.\n+\t(walk_vtables): OK, don't set prev to vars if the vardecl_fn messed\n+\twith TREE_CHAIN (prev).\n+\n+\t* init.c (emit_base_init): Use convert_pointer_to_real instead of\n+\tconvert_pointer_to when converting to a direct base.\n+\n+Wed Mar 15 20:26:29 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* pt.c (type_unification): Handle transitive unification better.\n+\n+Wed Mar 15 13:56:16 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl2.c (walk_vtables): Always set prev to vars.\n+\t(mark_vtable_entries): Call assemble_external on the vtable entries.\n+\n+\t* class.c (finish_struct): Set the vtable's size to NULL_TREE before\n+        calling layout_decl, so that it gets updated properly.\n+\n+\tFinally re-enable dynamic synthesis.  This time it works.\n+\t* method.c (synthesize_method): Pass decl_function_context (fndecl)\n+\tto {push,pop}_cp_function_context.\n+\t* decl.c (push_cp_function_context): Now takes a tree argument.\n+\t(pop_cp_function_context): Ditto.\n+\t* call.c (build_method_call): Enable synthesis.\n+\t* lex.c (cons_up_default_function): Ditto.\n+\n+Tue Mar 14 19:14:19 1995  Doug Evans  <dje@chestnut.cygnus.com>\n+\n+\t* parse.y (setattrs): Chain onto prefix_attributes rather than\n+\tsetting it.\n+\n+Wed Mar 15 13:00:00 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* decl.c (pushdecl): Check if the type of the VAR_DECL is an\n+\terror_mark_node before trying to read TYPE_LANG_SPECIFIC. \n+\n Mon Mar 13 21:00:28 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n \n \t* decl.c (grokdeclarator, case ARRAY_REF): Wrap the exp with fold,"}, {"sha": "6007f00d0426fd3f7405cba1ad9e8029b64284c0", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=28cbf42c14d84ef906619aa7c180a72c6acea2fb", "patch": "@@ -167,6 +167,7 @@ OBJDEPS = ../stamp-objlist ../c-common.o ../c-pragma.o\n \n compiler: ../cc1plus\n ../cc1plus: $(P) $(CXX_OBJS) $(OBJDEPS) $(LIBDEPS)\n+\trm -f $@\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o ../cc1plus \\\n \t      $(CXX_OBJS) $(OBJS) $(LIBS)\n "}, {"sha": "9ba6d1894e7453641f8216658f9dfc61973dbfdb", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=28cbf42c14d84ef906619aa7c180a72c6acea2fb", "patch": "@@ -2379,7 +2379,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n   /* Declare external function if necessary. */\n   assemble_external (function);\n \n-#if 0\n+#if 1\n   /* Is it a synthesized method that needs to be synthesized?  */\n   if (DECL_ARTIFICIAL (function) && ! flag_no_inline\n       && DECL_SAVED_INSNS (function) == 0"}, {"sha": "d6e23156dc67259649b65eead0ab8d3932c7bbc5", "filename": "gcc/cp/class.c", "status": "modified", "additions": 13, "deletions": 43, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=28cbf42c14d84ef906619aa7c180a72c6acea2fb", "patch": "@@ -26,6 +26,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include <stdio.h>\n #include \"cp-tree.h\"\n #include \"flags.h\"\n+#include \"rtl.h\"\n \n #include \"obstack.h\"\n #define obstack_chunk_alloc xmalloc\n@@ -2963,6 +2964,11 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \n \t      DECL_CLASS_CONTEXT (x) = t;\n \n+\t      /* Do both of these, even though they're in the same union;\n+\t\t if the insn `r' member and the size `i' member are\n+\t\t different sizes, as on the alpha, the larger of the two\n+\t\t will end up with garbage in it.  */\n+\t      DECL_SAVED_INSNS (x) = NULL_RTX;\n \t      DECL_FIELD_SIZE (x) = 0;\n \n \t      /* The name of the field is the original field name\n@@ -3027,6 +3033,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t    fields = x;\n \t  last_x = x;\n \n+\t  DECL_SAVED_INSNS (x) = NULL_RTX;\n \t  DECL_FIELD_SIZE (x) = 0;\n \n \t  /* When this goes into scope, it will be a non-local reference.  */\n@@ -3505,6 +3512,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n       DECL_FIELD_CONTEXT (vfield) = t;\n       DECL_CLASS_CONTEXT (vfield) = t;\n       DECL_FCONTEXT (vfield) = t;\n+      DECL_SAVED_INSNS (vfield) = NULL_RTX;\n       DECL_FIELD_SIZE (vfield) = 0;\n       DECL_ALIGN (vfield) = TYPE_ALIGN (ptr_type_node);\n       if (CLASSTYPE_RTTI (t))\n@@ -3576,47 +3584,6 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   TYPE_ALIGN (t) = round_up_size;\n \n   /* Pass layout information about base classes to layout_type, if any.  */\n-\n-  {\n-    tree field;\n-    for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n-      {\n-\tif (TREE_STATIC (field))\n-\t  continue;\n-\tif (TREE_CODE (field) != FIELD_DECL)\n-\t  continue;\n-\n-\t/* If this field is an anonymous union,\n-\t   give each union-member the same position as the union has.\n-\n-\t   ??? This is a real kludge because it makes the structure\n-\t   of the types look strange.  This feature is only used by\n-\t   C++, which should have build_component_ref build two\n-\t   COMPONENT_REF operations, one for the union and one for\n-\t   the inner field.  We set the offset of this field to zero\n-\t   so that either the old or the correct method will work.\n-\t   Setting DECL_FIELD_CONTEXT is wrong unless the inner fields are\n-\t   moved into the type of this field, but nothing seems to break\n-\t   by doing this.  */\n-\n-\tif (DECL_NAME (field) == NULL_TREE\n-\t    && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n-\t  {\n-\t    tree uelt = TYPE_FIELDS (TREE_TYPE (field));\n-\t    for (; uelt; uelt = TREE_CHAIN (uelt))\n-\t      {\n-\t\tif (TREE_CODE (uelt) != FIELD_DECL)\n-\t\t  continue;\n-\n-\t\tDECL_FIELD_CONTEXT (uelt) = DECL_FIELD_CONTEXT (field);\n-\t\tDECL_FIELD_BITPOS (uelt) = DECL_FIELD_BITPOS (field);\n-\t      }\n-\n-\t    DECL_FIELD_BITPOS (field) = integer_zero_node;\n-\t  }\n-      }\n-  }\n-\n   if (n_baseclasses)\n     {\n       tree pseudo_basetype = TREE_TYPE (base_layout_decl);\n@@ -3911,6 +3878,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n       if (TREE_TYPE (TYPE_BINFO_VTABLE (t)) != atype)\n \t{\n \t  TREE_TYPE (TYPE_BINFO_VTABLE (t)) = atype;\n+\t  DECL_SIZE (TYPE_BINFO_VTABLE (t)) = 0;\n \t  layout_decl (TYPE_BINFO_VTABLE (t), 0);\n \t  /* At one time the vtable info was grabbed 2 words at a time.  This\n \t     fails on sparc unless you have 8-byte alignment.  (tiemann) */\n@@ -4726,6 +4694,9 @@ instantiate_type (lhstype, rhs, complain)\n \t   functions or member functions.  May have to undo what\n \t   `default_conversion' might do to lhstype.  */\n \n+\tif (TYPE_PTRMEMFUNC_P (lhstype))\n+\t  lhstype = TYPE_PTRMEMFUNC_FN_TYPE (lhstype);\n+\n \tif (TREE_CODE (lhstype) == POINTER_TYPE)\n \t  if (TREE_CODE (TREE_TYPE (lhstype)) == FUNCTION_TYPE\n \t      || TREE_CODE (TREE_TYPE (lhstype)) == METHOD_TYPE)\n@@ -4884,8 +4855,7 @@ instantiate_type (lhstype, rhs, complain)\n #endif\n \t  }\n \tif (complain)\n-\t  error (\"no compatible member functions named `%s'\",\n-\t\t IDENTIFIER_POINTER (name));\n+\t  cp_error (\"no compatible member functions named `%D'\", name);\n \treturn error_mark_node;\n       }\n "}, {"sha": "98ea89f09f1e91fa067299a72f9e0a9390979429", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=28cbf42c14d84ef906619aa7c180a72c6acea2fb", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for C++ parsing and type checking.\n-   Copyright (C) 1987, 1993, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1993, 1994, 1995 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC."}, {"sha": "7e880b44b99ba0e38afa227c85d67541c5ae037e", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=28cbf42c14d84ef906619aa7c180a72c6acea2fb", "patch": "@@ -155,6 +155,18 @@ cp_convert_to_pointer (type, expr)\n \t  && TREE_CODE (TREE_TYPE (intype)) == METHOD_TYPE)\n \treturn convert_fn_ptr (type, expr);\n \n+      if (TREE_CODE (TREE_TYPE (type)) == OFFSET_TYPE\n+\t  && TREE_CODE (TREE_TYPE (intype)) == OFFSET_TYPE)\n+\t{\n+\t  tree b1 = TYPE_OFFSET_BASETYPE (TREE_TYPE (type));\n+\t  tree b2 = TYPE_OFFSET_BASETYPE (TREE_TYPE (intype));\n+\t  tree binfo = get_binfo (b1, b2, 1);\n+\t  if (binfo == NULL_TREE)\n+\t    binfo = get_binfo (b2, b1, 1);\n+\t  if (binfo == error_mark_node)\n+\t    return error_mark_node;\n+\t}\n+\n       return build1 (NOP_EXPR, type, expr);\n     }\n "}, {"sha": "c9865e30de7ef63a233e6ecf8eb85d768268bc4b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 79, "deletions": 36, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=28cbf42c14d84ef906619aa7c180a72c6acea2fb", "patch": "@@ -1443,6 +1443,7 @@ struct saved_scope {\n   tree old_bindings;\n   struct saved_scope *prev;\n   tree class_name, class_type, class_decl, function_decl;\n+  tree base_init_list, member_init_list;\n   struct binding_level *class_bindings;\n   tree previous_class_type;\n   tree *lang_base, *lang_stack, lang_name;\n@@ -1519,6 +1520,8 @@ push_to_top_level ()\n   s->class_type = current_class_type;\n   s->class_decl = current_class_decl;\n   s->function_decl = current_function_decl;\n+  s->base_init_list = current_base_init_list;\n+  s->member_init_list = current_member_init_list;\n   s->class_bindings = class_binding_level;\n   s->previous_class_type = previous_class_type;\n   s->lang_stack = current_lang_stack;\n@@ -1571,6 +1574,8 @@ pop_from_top_level ()\n     C_C_D = CLASSTYPE_INST_VAR (current_class_type);\n   else\n     C_C_D = NULL_TREE;\n+  current_base_init_list = s->base_init_list;\n+  current_member_init_list = s->member_init_list;\n   current_function_decl = s->function_decl;\n   class_binding_level = s->class_bindings;\n   previous_class_type = s->previous_class_type;\n@@ -2230,7 +2235,7 @@ duplicate_decls (newdecl, olddecl)\n \t      cp_error_at (\"previous declaration `%#D' here\", olddecl);\n \t    }\n \t  else if (compparms (TYPE_ARG_TYPES (TREE_TYPE (newdecl)),\n-\t\t\t      TYPE_ARG_TYPES (TREE_TYPE (olddecl)), 2))\n+\t\t\t      TYPE_ARG_TYPES (TREE_TYPE (olddecl)), 3))\n \t    {\n \t      cp_error (\"new declaration `%#D'\", newdecl);\n \t      cp_error_at (\"ambiguates old declaration `%#D'\", olddecl);\n@@ -3061,6 +3066,7 @@ pushdecl (x)\n       /* Keep count of variables in this level with incomplete type.  */\n       /* RTTI TD entries are created while defining the type_info.  */\n       if (TREE_CODE (x) == VAR_DECL\n+\t  && TREE_TYPE (x) != error_mark_node\n \t  && TYPE_LANG_SPECIFIC (TREE_TYPE (x))\n \t  && TYPE_BEING_DEFINED (TREE_TYPE (x)))\n \t{\n@@ -3606,6 +3612,7 @@ define_label (filename, line, name)\n   else\n     {\n       tree uses, prev;\n+      int identified = 0;\n \n       /* Mark label as having been defined.  */\n       DECL_INITIAL (decl) = error_mark_node;\n@@ -3636,10 +3643,11 @@ define_label (filename, line, name)\n \t\t\t     && DECL_INITIAL (new_decls) != error_mark_node)\n \t\t\t    || TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (new_decls))))\n \t\t      {\n-\t\t\tif (IDENTIFIER_ERROR_LOCUS (decl) == NULL_TREE)\n-\t\t\t  cp_error (\"invalid jump to label `%D'\", decl);\n-\t\t\tSET_IDENTIFIER_ERROR_LOCUS (decl, current_function_decl);\n-\t\t\tcp_error (\"crosses initialization of `%D'\", new_decls);\n+\t\t\tif (! identified)\n+\t\t\t  cp_error (\"jump to label `%D'\", decl);\n+\t\t\tidentified = 1;\n+\t\t\tcp_error_at (\"  crosses initialization of `%#D'\",\n+\t\t\t\t     new_decls);\n \t\t      }\n \t\t    new_decls = TREE_CHAIN (new_decls);\n \t\t  }\n@@ -5259,7 +5267,10 @@ shadow_tag (declspecs)\n       else if (value == ridpointers[(int) RID_STATIC]\n \t       || value == ridpointers[(int) RID_EXTERN]\n \t       || value == ridpointers[(int) RID_AUTO]\n-\t       || value == ridpointers[(int) RID_REGISTER])\n+\t       || value == ridpointers[(int) RID_REGISTER]\n+\t       || value == ridpointers[(int) RID_INLINE]\n+\t       || value == ridpointers[(int) RID_VIRTUAL]\n+\t       || value == ridpointers[(int) RID_EXPLICIT])\n \tob_modifier = value;\n     }\n \n@@ -5290,9 +5301,19 @@ shadow_tag (declspecs)\n     {\n       /* Anonymous unions are objects, that's why we only check for\n \t inappropriate specifiers in this branch.  */\n+\n       if (ob_modifier)\n-\tcp_error (\"`%D' can only be specified for objects and functions\",\n-\t\t  ob_modifier);\n+\t{\n+\t  if (ob_modifier == ridpointers[(int) RID_INLINE]\n+\t      || ob_modifier == ridpointers[(int) RID_VIRTUAL])\n+\t    cp_error (\"`%D' can only be specified for functions\", ob_modifier);\n+\t  else if (ob_modifier == ridpointers[(int) RID_EXPLICIT])\n+\t    cp_error (\"`%D' can only be specified for constructors\",\n+\t\t      ob_modifier);\n+\t  else\n+\t    cp_error (\"`%D' can only be specified for objects and functions\",\n+\t\t      ob_modifier);\n+\t}\n \n       if (found_tag == 0)\n \tpedwarn (\"abstract declarator used as declaration\");\n@@ -5837,16 +5858,24 @@ grok_reference_init (decl, type, init, cleanupp)\n    it in with a dummy CONSTRUCTOR to force the variable into .data;\n    otherwise we can use error_mark_node.  */\n \n-static void\n-obscure_complex_init (decl)\n-     tree decl;\n+static tree\n+obscure_complex_init (decl, init)\n+     tree decl, init;\n {\n+  if (! flag_no_inline && TREE_STATIC (decl))\n+    {\n+      if (extract_init (decl, init))\n+\treturn NULL_TREE;\n+    }\n+\n   if (current_binding_level == global_binding_level\n       && ! DECL_COMMON (decl))\n     DECL_INITIAL (decl) = build (CONSTRUCTOR, TREE_TYPE (decl), NULL_TREE,\n \t\t\t\t NULL_TREE);\n   else\n     DECL_INITIAL (decl) = error_mark_node;\n+\n+  return init;\n }\n \n /* Finish processing of a declaration;\n@@ -6078,22 +6107,18 @@ finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t\t}\n \t    }\n #endif\n-\n-\t  /* We must hide the initializer so that expand_decl\n-\t     won't try to do something it does not understand.  */\n-\t  obscure_complex_init (decl);\n \t}\n       else\n \t{\n \tdont_use_constructor:\n \t  if (TREE_CODE (init) != TREE_VEC)\n \t    init = store_init_value (decl, init);\n-\n-\t  /* Don't let anyone try to initialize this variable\n-\t     until we are ready to do so.  */\n-\t  if (init)\n-\t    obscure_complex_init (decl);\n \t}\n+\n+      if (init)\n+\t/* We must hide the initializer so that expand_decl\n+\t   won't try to do something it does not understand.  */\n+\tinit = obscure_complex_init (decl, init);\n     }\n   else if (DECL_EXTERNAL (decl))\n     ;\n@@ -6120,7 +6145,7 @@ finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \n       if (TYPE_SIZE (type) != NULL_TREE\n \t  && TYPE_NEEDS_CONSTRUCTING (type))\n-\tobscure_complex_init (decl);\n+\tinit = obscure_complex_init (decl, NULL_TREE);\n     }\n   else if (TREE_CODE (decl) == VAR_DECL\n \t   && TREE_CODE (type) != REFERENCE_TYPE\n@@ -6589,7 +6614,8 @@ expand_static_init (decl, init)\n \t\t\t\t\t  integer_zero_node, 1), 0);\n       old_cleanups = cleanups_this_call;\n       expand_assignment (temp, integer_one_node, 0, 0);\n-      if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n+      if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl))\n+\t  || TREE_CODE (init) == TREE_LIST)\n \t{\n \t  expand_aggr_init (decl, init, 0, 0);\n \t  do_pending_stack_adjust ();\n@@ -8372,11 +8398,13 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t    RIDBIT_RESET (RID_FRIEND, specbits);\n \t\t    friendp = 0;\n \t\t  }\n+\t\tif (decl_context == NORMAL)\n+\t\t  error (\"friend declaration not in class definition\");\n+\t\tif (current_function_decl && funcdef_flag)\n+\t\t  cp_error (\"can't define friend function `%s' in a local class definition\",\n+\t\t\t    name);\n \t      }\n \n-\t    if (decl_context == NORMAL && friendp)\n-\t      error (\"friend declaration not in class definition\");\n-\n \t    /* Traditionally, declaring return type float means double.  */\n \n \t    if (flag_traditional\n@@ -8598,8 +8626,17 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t   basetype :: member .  */\n \n \t\tif (ctype == current_class_type)\n-\t\t  cp_pedwarn (\"extra qualification `%T::' on member `%s' ignored\",\n-\t\t\t      ctype, name);\n+\t\t  {\n+\t\t    /* class A {\n+\t\t         void A::f ();\n+\t\t       };\n+\n+\t\t       Is this ill-formed?  */\n+\n+\t\t    if (pedantic)\n+\t\t      cp_pedwarn (\"extra qualification `%T::' on member `%s' ignored\",\n+\t\t\t\t  ctype, name);\n+\t\t  }\n \t\telse if (TREE_CODE (type) == FUNCTION_TYPE)\n \t\t  {\n \t\t    if (current_class_type == NULL_TREE\n@@ -11307,7 +11344,7 @@ finish_function (lineno, call_poplevel, nested)\n       int ok_to_optimize_dtor = 0;\n \n       if (current_function_assigns_this)\n-\tcond = build (NE_EXPR, integer_type_node,\n+\tcond = build (NE_EXPR, boolean_type_node,\n \t\t      current_class_decl, integer_zero_node);\n       else\n \t{\n@@ -11756,8 +11793,14 @@ finish_function (lineno, call_poplevel, nested)\n   if (DECL_STATIC_DESTRUCTOR (fndecl))\n     static_dtors = perm_tree_cons (NULL_TREE, fndecl, static_dtors);\n \n-  /* Let the error reporting routines know that we're outside a function.  */\n-  current_function_decl = NULL_TREE;\n+  if (! nested)\n+    {\n+      /* Let the error reporting routines know that we're outside a\n+         function.  For a nested function, this value is used in\n+         pop_cp_function_context and then reset via pop_function_context.  */\n+      current_function_decl = NULL_TREE;\n+    }\n+\n   named_label_uses = NULL_TREE;\n }\n \f\n@@ -12190,13 +12233,13 @@ struct cp_function *cp_function_chain;\n    used during compilation of a C++ function.  */\n \n void\n-push_cp_function_context (toplev)\n-     int toplev;\n+push_cp_function_context (context)\n+     tree context;\n {\n   struct cp_function *p\n     = (struct cp_function *) xmalloc (sizeof (struct cp_function));\n \n-  push_function_context_to (toplev);\n+  push_function_context_to (context);\n \n   p->next = cp_function_chain;\n   cp_function_chain = p;\n@@ -12221,8 +12264,8 @@ push_cp_function_context (toplev)\n /* Restore the variables used during compilation of a C++ function.  */\n \n void\n-pop_cp_function_context (toplev)\n-     int toplev;\n+pop_cp_function_context (context)\n+     tree context;\n {\n   struct cp_function *p = cp_function_chain;\n   tree link;\n@@ -12244,7 +12287,7 @@ pop_cp_function_context (toplev)\n     }\n #endif\n \n-  pop_function_context_from (toplev);\n+  pop_function_context_from (context);\n \n   cp_function_chain = p->next;\n "}, {"sha": "633fc8b7e21833699d3217553f8686cca301022d", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 74, "deletions": 43, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=28cbf42c14d84ef906619aa7c180a72c6acea2fb", "patch": "@@ -1932,7 +1932,8 @@ build_push_scope (cname, name)\n   return rval;\n }\n \n-void cplus_decl_attributes (decl, attributes, prefix_attributes)\n+void\n+cplus_decl_attributes (decl, attributes, prefix_attributes)\n      tree decl, attributes, prefix_attributes;\n {\n   if (decl && decl != void_type_node)\n@@ -2463,7 +2464,14 @@ mark_vtable_entries (decl)\n \t  extern tree abort_fndecl;\n \t  if (flag_vtable_thunks)\n \t    fnaddr = TREE_VALUE (entries);\n-\t  TREE_OPERAND (fnaddr, 0) = abort_fndecl;\n+\t  TREE_OPERAND (fnaddr, 0) = fn = abort_fndecl;\n+\t}\n+      if (TREE_PUBLIC (fn) && ! TREE_ASM_WRITTEN (fn))\n+\t{\n+\t  int save_extern = DECL_EXTERNAL (fn);\n+\t  DECL_EXTERNAL (fn) = 1;\n+\t  assemble_external (fn);\n+\t  DECL_EXTERNAL (fn) = save_extern;\n \t}\n     }\n }\n@@ -2561,7 +2569,8 @@ finish_prevtable_vardecl (prev, vars)\n       for (method = CLASSTYPE_METHODS (ctype); method != NULL_TREE;\n \t   method = DECL_NEXT_METHOD (method))\n \t{\n-\t  if (DECL_VINDEX (method) != NULL_TREE && !DECL_SAVED_INSNS (method)\n+\t  if (DECL_VINDEX (method) != NULL_TREE\n+\t      && !DECL_DECLARED_STATIC (method)\n \t      && !DECL_ABSTRACT_VIRTUAL_P (method))\n \t    {\n \t      SET_CLASSTYPE_INTERFACE_KNOWN (ctype);\n@@ -2574,10 +2583,17 @@ finish_prevtable_vardecl (prev, vars)\n \n   import_export_vtable (vars, ctype, 1);\n \n+  /* We cannot use TREE_USED here, as it may be set by the expanding of a\n+     ctor that is used to build a global object.  The long term plan is to\n+     make the TD entries statically initialized and move this to\n+     finish_vtable_vardecl time.  */\n   if (flag_rtti && write_virtuals >= 0\n-      && ! DECL_EXTERNAL (vars) && (TREE_PUBLIC (vars) || TREE_USED (vars)))\n+      && ! DECL_EXTERNAL (vars) && (TREE_PUBLIC (vars) || 1 || TREE_USED (vars)))\n     {\n-      /* Kick out the type descriptor before writing out the vtable.  */\n+      /* Kick out the type descriptor before we dump out global\n+\t initializers, as they are initialized at run time and\n+\t we have to find them when we scan for things that need initialized\n+\t at the top level.  */\n       build_t_desc (ctype, 1);\n     }\n }\n@@ -2589,6 +2605,15 @@ finish_vtable_vardecl (prev, vars)\n   if (write_virtuals >= 0\n       && ! DECL_EXTERNAL (vars) && (TREE_PUBLIC (vars) || TREE_USED (vars)))\n     {\n+#if 0\n+      /* The long term plan it to make the TD entries statically initialized,\n+\t have the entries built and emitted here.  When that happens, this\n+\t can be enabled, and the other call to build_t_desc removed.  */\n+      /* Kick out the type descriptor before writing out the vtable.  */\n+      if (flag_rtti)\n+\tbuild_t_desc (DECL_CONTEXT (vars), 1);\n+#endif\n+\n       /* Write it out.  */\n       mark_vtable_entries (vars);\n       if (TREE_TYPE (DECL_INITIAL (vars)) == 0)\n@@ -2651,19 +2676,22 @@ walk_vtables (typedecl_fn, vardecl_fn)\n     {\n       register tree type = TREE_TYPE (vars);\n \n-      if (TREE_CODE (vars) == TYPE_DECL\n-\t  && type != error_mark_node\n-\t  && TYPE_LANG_SPECIFIC (type)\n-\t  && CLASSTYPE_VSIZE (type))\n+      if (TREE_CODE (vars) == VAR_DECL && DECL_VIRTUAL_P (vars))\n \t{\n-\t  if (typedecl_fn) (*typedecl_fn) (prev, vars);\n+\t  if (vardecl_fn) (*vardecl_fn) (prev, vars);\n+\n+\t  if (prev && TREE_CHAIN (prev) != vars)\n+\t    continue;\n \t}\n-      else if (TREE_CODE (vars) == VAR_DECL && DECL_VIRTUAL_P (vars))\n+      else if (TREE_CODE (vars) == TYPE_DECL\n+\t       && type != error_mark_node\n+\t       && TYPE_LANG_SPECIFIC (type)\n+\t       && CLASSTYPE_VSIZE (type))\n \t{\n-\t  if (vardecl_fn) (*vardecl_fn) (prev, vars);\n+\t  if (typedecl_fn) (*typedecl_fn) (prev, vars);\n \t}\n-      else\n-\tprev = vars;\n+\n+      prev = vars;\n     }\n }\n \n@@ -2805,6 +2833,31 @@ finish_file ()\n   interface_unknown = 1;\n   interface_only = 0;\n \n+#if 1\n+  /* The reason for pushing garbage onto the global_binding_level is to\n+     ensure that we can slice out _DECLs which pertain to virtual function\n+     tables.  If the last thing pushed onto the global_binding_level was a\n+     virtual function table, then slicing it out would slice away all the\n+     decls (i.e., we lose the head of the chain).\n+\n+     There are several ways of getting the same effect, from changing the\n+     way that iterators over the chain treat the elements that pertain to\n+     virtual function tables, moving the implementation of this code to\n+     decl.c (where we can manipulate global_binding_level directly),\n+     popping the garbage after pushing it and slicing away the vtable\n+     stuff, or just leaving it alone. */\n+\n+  /* Make last thing in global scope not be a virtual function table.  */\n+#if 0 /* not yet, should get fixed properly later */\n+  vars = make_type_decl (get_identifier (\" @%$#@!\"), integer_type_node);\n+#else\n+  vars = build_decl (TYPE_DECL, get_identifier (\" @%$#@!\"), integer_type_node);\n+#endif\n+  DECL_IGNORED_P (vars) = 1;\n+  SET_DECL_ARTIFICIAL (vars);\n+  pushdecl (vars);\n+#endif\n+\n   /* Walk to mark the inline functions we need, then output them so\n      that we can pick up any other tdecls that those routines need. */\n   walk_vtables ((void (*)())0, finish_prevtable_vardecl);\n@@ -3023,37 +3076,12 @@ finish_file ()\n \n   start_time = get_run_time ();\n \n-  /* Now delete from the chain of variables all virtual function tables.\n-     We output them all ourselves, because each will be treated specially.  */\n-\n-#if 1\n-  /* The reason for pushing garbage onto the global_binding_level is to\n-     ensure that we can slice out _DECLs which pertain to virtual function\n-     tables.  If the last thing pushed onto the global_binding_level was a\n-     virtual function table, then slicing it out would slice away all the\n-     decls (i.e., we lose the head of the chain).\n-\n-     There are several ways of getting the same effect, from changing the\n-     way that iterators over the chain treat the elements that pertain to\n-     virtual function tables, moving the implementation of this code to\n-     decl.c (where we can manipulate global_binding_level directly),\n-     popping the garbage after pushing it and slicing away the vtable\n-     stuff, or just leaving it alone. */\n-\n-  /* Make last thing in global scope not be a virtual function table.  */\n-#if 0 /* not yet, should get fixed properly later */\n-  vars = make_type_decl (get_identifier (\" @%$#@!\"), integer_type_node);\n-#else\n-  vars = build_decl (TYPE_DECL, get_identifier (\" @%$#@!\"), integer_type_node);\n-#endif\n-  DECL_IGNORED_P (vars) = 1;\n-  SET_DECL_ARTIFICIAL (vars);\n-  pushdecl (vars);\n-#endif\n-\n   if (flag_handle_signatures)\n     walk_sigtables ((void (*)())0, finish_sigtable_vardecl);\n \n+  for (fnname = saved_inlines; fnname; fnname = TREE_CHAIN (fnname))\n+    import_export_inline (TREE_VALUE (fnname));\n+\n   /* Now write out inline functions which had their addresses taken and\n      which were not declared virtual and which were not declared `extern\n      inline'.  */\n@@ -3089,7 +3117,7 @@ finish_file ()\n \t\tTREE_CHAIN (last) = TREE_CHAIN (place);\n \t\tcontinue;\n \t      }\n-\t    import_export_inline (decl);\n+\n \t    if (TREE_PUBLIC (decl)\n \t\t|| TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n \t\t|| flag_keep_inline_functions)\n@@ -3112,6 +3140,9 @@ finish_file ()\n       }\n   }\n \n+  /* Now delete from the chain of variables all virtual function tables.\n+     We output them all ourselves, because each will be treated specially.  */\n+\n   walk_vtables ((void (*)())0, prune_vtable_vardecl);\n \n   for (vars = getdecls (); vars; vars = TREE_CHAIN (vars))"}, {"sha": "d7bbff8d2849a1033e465552db5f9e9ebeeaaf63", "filename": "gcc/cp/error.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=28cbf42c14d84ef906619aa7c180a72c6acea2fb", "patch": "@@ -1142,6 +1142,13 @@ dump_expr (t, nop)\n       }\n       break;\n \n+    case ARRAY_REF:\n+      dump_expr (TREE_OPERAND (t, 0), 0);\n+      OB_PUTC ('[');\n+      dump_expr (TREE_OPERAND (t, 1), 0);\n+      OB_PUTC (']');\n+      break;\n+\n     case CONVERT_EXPR:\n       dump_unary_op (\"+\", t, nop);\n       break;"}, {"sha": "338065b00a9d1211b82d4fe59fb2a3d6ab85a1fa", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=28cbf42c14d84ef906619aa7c180a72c6acea2fb", "patch": "@@ -264,7 +264,7 @@ fixup_result_decl (decl, result)\n \t  REG_FUNCTION_VALUE_P (real_decl_result) = 1;\n \t  result = real_decl_result;\n \t}\n-      emit_move_insn (result, DECL_RTL (decl));\n+      store_expr (decl, result, 0);\n       emit_insn (gen_rtx (USE, VOIDmode, result));\n     }\n }\n@@ -274,9 +274,90 @@ fixup_result_decl (decl, result)\n    in some cases.  We cannot use `memory_operand' as a test\n    here because on most RISC machines, a variable's address\n    is not, by itself, a legitimate address.  */\n+\n int\n decl_in_memory_p (decl)\n      tree decl;\n {\n   return DECL_RTL (decl) != 0 && GET_CODE (DECL_RTL (decl)) == MEM;\n }\n+\n+/* Expand this initialization inline and see if it's simple enough that\n+   it can be done at compile-time.  */\n+\n+static tree\n+extract_aggr_init (decl, init)\n+     tree decl, init;\n+{\n+  return 0;\n+}\n+\n+static tree\n+extract_scalar_init (decl, init)\n+     tree decl, init;\n+{\n+  rtx value, insns, insn;\n+  extern struct obstack temporary_obstack;\n+  tree t = NULL_TREE;\n+\n+  push_obstacks (&temporary_obstack, &temporary_obstack);\n+  start_sequence ();\n+  value = expand_expr (init, NULL_RTX, VOIDmode, 0);\n+  insns = get_insns ();\n+  end_sequence ();\n+  reg_scan (insns, max_reg_num (), 0);\n+  jump_optimize (insns, 0, 0, 1);\n+  pop_obstacks ();\n+\n+  for (insn = insns; insn; insn = NEXT_INSN (insn))\n+    {\n+      rtx r, to;\n+\n+      if (GET_CODE (insn) == NOTE)\n+\tcontinue;\n+      else if (GET_CODE (insn) != INSN)\n+\treturn 0;\n+\n+      r = PATTERN (insn);\n+      if (GET_CODE (r) != SET)\n+\treturn 0;\n+\n+      to = XEXP (r, 0);\n+\n+      if (! (to == value ||\n+\t     (GET_CODE (to) == SUBREG && XEXP (to, 0) == value)))\n+\treturn 0;\n+\n+      r = XEXP (r, 1);\n+\n+      switch (GET_CODE (r))\n+\t{\n+\tcase CONST_INT:\n+\t  t = build_int_2 (XEXP (r, 0), 0);\n+\t  break;\n+\tdefault:\n+\t  return 0;\n+\t}\n+    }\n+\n+  return t; \n+}\n+\n+int\n+extract_init (decl, init)\n+     tree decl, init;\n+{\n+  return 0;\n+\n+  if (IS_AGGR_TYPE (TREE_TYPE (decl))\n+      || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n+    init = extract_aggr_init (decl, init);\n+  else\n+    init = extract_scalar_init (decl, init);\n+\n+  if (init == NULL_TREE)\n+    return 0;\n+\n+  DECL_INITIAL (decl) = init;\n+  return 1;\n+}"}, {"sha": "37376131d8c1cf5756e2f46a53a8d8c1009128c6", "filename": "gcc/cp/init.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=28cbf42c14d84ef906619aa7c180a72c6acea2fb", "patch": "@@ -571,7 +571,7 @@ emit_base_init (t, immediately)\n \n       if (init != void_list_node)\n \t{\n-\t  member = convert_pointer_to (base_binfo, current_class_decl);\n+\t  member = convert_pointer_to_real (base_binfo, current_class_decl);\n \t  expand_aggr_init_1 (base_binfo, 0,\n \t\t\t      build_indirect_ref (member, NULL_PTR), init,\n \t\t\t      BINFO_OFFSET_ZEROP (base_binfo), LOOKUP_NORMAL);\n@@ -1980,6 +1980,10 @@ build_offset_ref (cname, name)\n \t      && ((flag_save_memoized_contexts && global_bindings_p ())\n \t\t  || ! allocation_temporary_p ()))\n \t    fnfields = copy_list (fnfields);\n+\n+\t  for (t = TREE_VALUE (fnfields); t; t = DECL_CHAIN (t))\n+\t    assemble_external (t);\n+\n \t  t = build_tree_list (error_mark_node, fnfields);\n \t  TREE_TYPE (t) = build_offset_type (type, unknown_type_node);\n \t  return t;"}, {"sha": "895f2694e8776d3e1756740e5a46b46d612ad5ac", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=28cbf42c14d84ef906619aa7c180a72c6acea2fb", "patch": "@@ -1796,8 +1796,10 @@ cons_up_default_function (type, full_name, kind)\n   /* When on-the-fly synthesis works properly, remove the second and third\n      conditions here.  */\n   if (flag_keep_inline_functions\n+#if 0\n       || ! flag_no_inline\n       || complex\n+#endif\n       || ! DECL_EXTERNAL (fn))\n     {\n       struct pending_inline *t;\n@@ -2812,7 +2814,13 @@ check_newline ()\n       extract_interface_info ();\n \n       c = get_last_nonwhite_on_line ();\n-      if (c != EOF)\n+      if (c == EOF)\n+\t{\n+\t  /* Update the name in the top element of input_file_stack.  */\n+\t  if (input_file_stack)\n+\t    input_file_stack->name = input_filename;\n+\t}\n+      else\n \t{\n \t  put_back (c);\n "}, {"sha": "adbb97e0e503d22c47edc882a3aa80d20659d2b7", "filename": "gcc/cp/method.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=28cbf42c14d84ef906619aa7c180a72c6acea2fb", "patch": "@@ -2209,12 +2209,12 @@ synthesize_method (fndecl)\n      tree fndecl;\n {\n   int nested = (current_function_decl != NULL_TREE);\n-  int toplev = (decl_function_context (fndecl) == NULL_TREE);\n+  tree context = decl_function_context (fndecl);\n   char *f = input_filename;\n   tree base = DECL_CLASS_CONTEXT (fndecl);\n \n   if (nested)\n-    push_cp_function_context (toplev);\n+    push_cp_function_context (context);\n \n   input_filename = DECL_SOURCE_FILE (fndecl);\n   interface_unknown = CLASSTYPE_INTERFACE_UNKNOWN (base);\n@@ -2238,8 +2238,19 @@ synthesize_method (fndecl)\n     }\n \n   finish_function (lineno, 0, nested);\n+\n+  /* Do we really *want* to inline this function?  */\n+  if (DECL_INLINE (fndecl))\n+    {\n+      /* Turn off DECL_INLINE for the moment so function_cannot_inline_p\n+         will check our size.  */\n+      DECL_INLINE (fndecl) = 0;\n+      if (function_cannot_inline_p (fndecl) == 0)\n+\tDECL_INLINE (fndecl) = 1;\n+    }\n+\n   input_filename = f;\n   extract_interface_info ();\n   if (nested)\n-    pop_cp_function_context (toplev);\n+    pop_cp_function_context (context);\n }"}, {"sha": "d8d7eb8ef2ed2b94423ab11dee00b94dac025878", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=28cbf42c14d84ef906619aa7c180a72c6acea2fb", "patch": "@@ -402,8 +402,12 @@ any_id:\n \t;\n \n extern_lang_string:\n-\t  EXTERN_LANG_STRING\n+\tEXTERN_LANG_STRING\n \t\t{ push_lang_context ($1); }\n+\t| extern_lang_string EXTERN_LANG_STRING\n+\t\t{ if (current_lang_name != $2)\n+\t\t    cp_error (\"use of linkage spec `%D' is different from previous spec `%D'\", $2, current_lang_name);\n+\t\t  pop_lang_context (); push_lang_context ($2); }\n \t;\n \n template_header:\n@@ -1725,7 +1729,7 @@ object:\t  primary '.'\n \t;\n \n setattrs: /* empty */\n-\t\t{ prefix_attributes = $<ttype>0; }\n+\t\t{ prefix_attributes = chainon (prefix_attributes, $<ttype>0); }\n \t;\n \n decl:"}, {"sha": "e05265a07854163f57e29beee3678376a25b9076", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=28cbf42c14d84ef906619aa7c180a72c6acea2fb", "patch": "@@ -1712,6 +1712,8 @@ instantiate_template (tmpl, targ_ptr)\n   if (fndecl == error_mark_node)\n     goto exit;\n \n+  assemble_external (fndecl);\n+\n   /* If it's a static member fn in the template, we need to change it\n      into a FUNCTION_TYPE and chop off its this pointer.  */\n   if (TREE_CODE (TREE_TYPE (DECL_RESULT (tmpl))) == METHOD_TYPE\n@@ -2059,6 +2061,23 @@ type_unification (tparms, targs, parms, args, nsubsts, subr)\n       if (TREE_CODE_CLASS (TREE_CODE (arg)) != 't')\n \t{\n \t  my_friendly_assert (TREE_TYPE (arg) != NULL_TREE, 293);\n+\t  if (TREE_CODE (arg) == TREE_LIST\n+\t      && TREE_TYPE (arg) == unknown_type_node\n+\t      && TREE_CODE (TREE_VALUE (arg)) == TEMPLATE_DECL)\n+\t    {\n+\t      int nsubsts, ntparms;\n+\t      tree *targs;\n+\n+\t      /* Have to back unify here */\n+\t      arg = TREE_VALUE (arg);\n+\t      nsubsts = 0;\n+\t      ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (arg));\n+\t      targs = (tree *) alloca (sizeof (tree) * ntparms);\n+\t      parm = tree_cons (NULL_TREE, parm, NULL_TREE);\n+\t      return type_unification (DECL_TEMPLATE_PARMS (arg), targs,\n+\t\t\t\t       TYPE_ARG_TYPES (TREE_TYPE (arg)),\n+\t\t\t\t       parm, &nsubsts, 0);\n+\t    }\n \t  arg = TREE_TYPE (arg);\n \t}\n #endif\n@@ -2200,6 +2219,8 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts)\n \t\t    nsubsts);\n \n     case REFERENCE_TYPE:\n+      if (TREE_CODE (arg) == REFERENCE_TYPE)\n+\targ = TREE_TYPE (arg);\n       return unify (tparms, targs, ntparms, TREE_TYPE (parm), arg, nsubsts);\n \n     case ARRAY_TYPE:\n@@ -2242,8 +2263,6 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts)\n \ttree t1, t2;\n \tt1 = TREE_OPERAND (parm, 0);\n \tt2 = TREE_OPERAND (parm, 1);\n-\tif (TREE_CODE (t1) != TEMPLATE_CONST_PARM)\n-\t  return 1;\n \treturn unify (tparms, targs, ntparms, t1,\n \t\t      fold (build (PLUS_EXPR, integer_type_node, arg, t2)),\n \t\t      nsubsts);\n@@ -2299,6 +2318,9 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts)\n       if (TREE_CODE (arg) != FUNCTION_TYPE)\n \treturn 1;\n      check_args:\n+      if (unify (tparms, targs, ntparms, TREE_TYPE (parm),\n+\t\t TREE_TYPE (arg), nsubsts))\n+\treturn 1;\n       return type_unification (tparms, targs, TYPE_ARG_TYPES (parm),\n \t\t\t       TYPE_ARG_TYPES (arg), nsubsts, 1);\n "}, {"sha": "712a76f7923f78a5bec5ac282e80b21d0b56baf1", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=28cbf42c14d84ef906619aa7c180a72c6acea2fb", "patch": "@@ -24,6 +24,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"tree.h\"\n #include \"cp-tree.h\"\n #include \"flags.h\"\n+#include \"rtl.h\"\n \n #define CEIL(x,y) (((x) + (y) - 1) / (y))\n \n@@ -826,6 +827,7 @@ layout_basetypes (rec, binfos)\n \t  DECL_FIELD_CONTEXT (decl) = rec;\n \t  DECL_CLASS_CONTEXT (decl) = rec;\n \t  DECL_FCONTEXT (decl) = basetype;\n+\t  DECL_SAVED_INSNS (decl) = NULL_RTX;\n \t  DECL_FIELD_SIZE (decl) = 0;\n \t  DECL_ALIGN (decl) = TYPE_ALIGN (ptr_type_node);\n \t  TREE_CHAIN (decl) = vbase_decls;"}, {"sha": "2467882061bfb4f69b903be138da29820cecc314", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 103, "deletions": 56, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28cbf42c14d84ef906619aa7c180a72c6acea2fb/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=28cbf42c14d84ef906619aa7c180a72c6acea2fb", "patch": "@@ -369,12 +369,24 @@ common_type (t1, t2)\n  \t But ANSI C++ specifies doing this with the qualifiers.\n  \t So I turned it on again.  */\n       {\n-\ttree target = common_type (TYPE_MAIN_VARIANT (TREE_TYPE (t1)),\n-\t\t\t\t   TYPE_MAIN_VARIANT (TREE_TYPE (t2)));\n+\ttree tt1 = TYPE_MAIN_VARIANT (TREE_TYPE (t1));\n+\ttree tt2 = TYPE_MAIN_VARIANT (TREE_TYPE (t2));\n \tint constp\n \t  = TYPE_READONLY (TREE_TYPE (t1)) || TYPE_READONLY (TREE_TYPE (t2));\n \tint volatilep\n \t  = TYPE_VOLATILE (TREE_TYPE (t1)) || TYPE_VOLATILE (TREE_TYPE (t2));\n+\ttree target;\n+\n+\tif (tt1 == tt2)\n+\t  target = tt1;\n+\telse if ((IS_AGGR_TYPE_CODE (TREE_CODE (tt1))\n+\t\t  || TREE_CODE (tt1) == OFFSET_TYPE\n+\t\t  || TREE_CODE (tt1) == METHOD_TYPE)\n+\t\t && TREE_CODE (tt2) == TREE_CODE (tt1))\n+\t  target = common_type (tt1, tt2);\n+\telse\n+\t  target = void_type_node;\n+\n \ttarget = cp_build_type_variant (target, constp, volatilep);\n \tif (code1 == POINTER_TYPE)\n \t  t1 = build_pointer_type (target);\n@@ -480,17 +492,18 @@ common_type (t1, t2)\n       return build_type_attribute_variant (t1, attributes);\n \n     case OFFSET_TYPE:\n-      if (TYPE_OFFSET_BASETYPE (t1) == TYPE_OFFSET_BASETYPE (t2)\n-\t  && TREE_CODE (TREE_TYPE (t1)) == TREE_CODE (TREE_TYPE (t2)))\n+      if (TREE_CODE (TREE_TYPE (t1)) == TREE_CODE (TREE_TYPE (t2)))\n \t{\n-\t  tree basetype = TYPE_OFFSET_BASETYPE (t1);\n-\t  t1 = build_offset_type (basetype,\n-\t\t\t\t    common_type (TREE_TYPE (t1), TREE_TYPE (t2)));\n-\t}\n-      else\n-        compiler_error (\"common_type called with uncommon member types\");\n+\t  tree b1 = TYPE_OFFSET_BASETYPE (t1);\n+\t  tree b2 = TYPE_OFFSET_BASETYPE (t2);\n+\t  tree base;\n \n-      /* ... falls through ... */\n+\t  if (DERIVED_FROM_P (b1, b2) && binfo_or_else (b1, b2))\n+\t    return build_type_attribute_variant (t1, attributes);\n+\t  else if (binfo_or_else (b2, b1))\n+\t    return build_type_attribute_variant (t2, attributes);\n+\t}\n+      compiler_error (\"common_type called with uncommon member types\");\n \n     default:\n       return build_type_attribute_variant (t1, attributes);\n@@ -762,6 +775,17 @@ comp_target_types (ttl, ttr, nptrs)\n   if (ttl == ttr)\n     return 1;\n \n+  if (TREE_CODE (ttl) == VOID_TYPE\n+      && TREE_CODE (ttr) != FUNCTION_TYPE\n+      && TREE_CODE (ttr) != METHOD_TYPE\n+      && TREE_CODE (ttr) != OFFSET_TYPE)\n+    return 1;\n+  if (TREE_CODE (ttr) == VOID_TYPE\n+      && TREE_CODE (ttl) != FUNCTION_TYPE\n+      && TREE_CODE (ttl) != METHOD_TYPE\n+      && TREE_CODE (ttl) != OFFSET_TYPE)\n+    return -1;\n+  \n   if (TREE_CODE (ttr) != TREE_CODE (ttl))\n     return 0;\n \n@@ -1680,6 +1704,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t\t  my_friendly_assert (datum != error_mark_node, 310);\n \t\t\t  fndecl = build_vfn_ref (&addr, datum, DECL_VINDEX (fndecl));\n \t\t\t}\n+\t\t      assemble_external (fndecl);\n \t\t      return fndecl;\n \t\t    }\n \t\t  if (access == access_protected)\n@@ -1692,7 +1717,12 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t{\n \t\t  /* Just act like build_offset_ref, since the object does\n                      not matter unless we're actually calling the function.  */\n-\t\t  tree t = build_tree_list (error_mark_node, fndecls);\n+\t\t  tree t;\n+\n+\t\t  for (t = TREE_VALUE (fndecls); t; t = DECL_CHAIN (t))\n+\t\t    assemble_external (t);\n+\n+\t\t  t = build_tree_list (error_mark_node, fndecls);\n \t\t  TREE_TYPE (t) = build_offset_type (basetype,\n \t\t\t\t\t\t     unknown_type_node);\n \t\t  return t;\n@@ -1779,6 +1809,13 @@ build_indirect_ref (ptr, errorstring)\n   if (ptr == current_class_decl)\n     return C_C_D;\n \n+  ptr = build_expr_type_conversion (WANT_POINTER, pointer, 1);\n+  if (ptr)\n+    {\n+      pointer = ptr;\n+      type = TREE_TYPE (pointer);\n+    }\n+\n   if (TREE_CODE (type) == POINTER_TYPE || TREE_CODE (type) == REFERENCE_TYPE)\n     {\n       if (TREE_CODE (pointer) == ADDR_EXPR\n@@ -2821,6 +2858,10 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n      Zero means they need to be converted to RESULT_TYPE.  */\n   int converted = 0;\n \n+  /* Nonzero means create the expression with this type, rather than\n+     RESULT_TYPE.  */\n+  tree build_type = 0;\n+\n   /* Nonzero means after finally constructing the expression\n      give it this type.  Otherwise, give it type RESULT_TYPE.  */\n   tree final_type = 0;\n@@ -3064,42 +3105,17 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \n     case EQ_EXPR:\n     case NE_EXPR:\n-      result_type = boolean_type_node;\n-      converted = 1;\n+      build_type = boolean_type_node; \n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE)\n \t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE))\n \tshort_compare = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  register tree tt0 = TYPE_MAIN_VARIANT (TREE_TYPE (type0));\n \t  register tree tt1 = TYPE_MAIN_VARIANT (TREE_TYPE (type1));\n-\t  /* Anything compares with void *.  void * compares with anything.\n-\t     Otherwise, the targets must be the same.  */\n-\t  if (tt0 != tt1 && TREE_CODE (tt0) == RECORD_TYPE\n-\t      && TREE_CODE (tt1) == RECORD_TYPE)\n-\t    {\n-\t      tree base = common_base_type (tt0, tt1);\n-\t      if (base == NULL_TREE)\n-\t\tcp_pedwarn (\"comparison of distinct object pointer types `%T' and `%T'\", type0, type1);\n-\t      else if (base == error_mark_node)\n-\t\t{\n-\t\t  cp_error (\"comparison of pointer types `%T' and `%T' requires conversion to ambiguous supertype\", type0, type1);\n-\t\t  return error_mark_node;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (integer_zerop (op0))\n-\t\t    op0 = null_pointer_node;\n-\t\t  else\n-\t\t    op0 = convert_pointer_to (base, op0);\n-\t\t  if (integer_zerop (op1))\n-\t\t    op1 = null_pointer_node;\n-\t\t  else\n-\t\t    op1 = convert_pointer_to (base, op1);\n-\t\t}\n-\t    }\n-\t  else if (comp_target_types (type0, type1, 1))\n-\t    ;\n+\n+\t  if (comp_target_types (type0, type1, 1))\n+\t    result_type = common_type (type0, type1);\n \t  else if (tt0 == void_type_node)\n \t    {\n \t      if (pedantic && TREE_CODE (tt1) == FUNCTION_TYPE\n@@ -3225,10 +3241,11 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t{\n \t  return build_binary_op (code, op1, op0, 1);\n \t}\n-      else\n-\t/* If args are not valid, clear out RESULT_TYPE\n-\t   to cause an error message later.  */\n-\tresult_type = 0;\n+\n+      type0 = TREE_TYPE (op0);\n+      type1 = TREE_TYPE (op1);\n+      if (result_type == NULL_TREE)\n+\tresult_type = type0;\n       break;\n \n     case MAX_EXPR:\n@@ -3239,8 +3256,12 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  if (! comp_target_types (type0, type1, 1))\n-\t    cp_pedwarn (\"comparison of distinct pointer types `%T' and `%T' lacks a cast\",\n-\t\t\ttype0, type1);\n+\t    {\n+\t      cp_pedwarn (\"comparison of distinct pointer types `%T' and `%T' lacks a cast\",\n+\t\t\t  type0, type1);\n+\t      result_type = ptr_type_node;\n+\t    }\n+#if 0\n \t  else if ((TYPE_SIZE (TREE_TYPE (type0)) != 0)\n \t\t   != (TYPE_SIZE (TREE_TYPE (type1)) != 0))\n \t    cp_pedwarn (\"comparison of %scomplete and %scomplete pointers\",\n@@ -3250,15 +3271,20 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  else if (pedantic\n \t\t   && TREE_CODE (TREE_TYPE (type0)) == FUNCTION_TYPE)\n \t    pedwarn (\"ANSI C++ forbids ordered comparisons of pointers to functions\");\n-\t  result_type = common_type (type0, type1);\n+#endif\n+\t  else\n+\t    result_type = common_type (type0, type1);\n \t}\n+\n+      if (result_type == NULL_TREE)\n+\tresult_type = type0;\n       break;\n \n     case LE_EXPR:\n     case GE_EXPR:\n     case LT_EXPR:\n     case GT_EXPR:\n-      result_type = boolean_type_node;\n+      build_type = boolean_type_node;\n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE)\n \t   && (code1 == INTEGER_TYPE || code1 == REAL_TYPE))\n \tshort_compare = 1;\n@@ -3267,6 +3293,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  if (! comp_target_types (type0, type1, 1))\n \t    cp_pedwarn (\"comparison of distinct pointer types `%T' and `%T' lacks a cast\",\n \t\t\ttype0, type1);\n+#if 0\n \t  else if ((TYPE_SIZE (TREE_TYPE (type0)) != 0)\n \t\t   != (TYPE_SIZE (TREE_TYPE (type1)) != 0))\n \t    cp_pedwarn (\"comparison of %scomplete and %scomplete pointers\",\n@@ -3276,6 +3303,9 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  else if (pedantic \n \t\t   && TREE_CODE (TREE_TYPE (type0)) == FUNCTION_TYPE)\n \t    pedwarn (\"ANSI C++ forbids ordered comparisons of pointers to functions\");\n+#endif\n+\t  else\n+\t    result_type = common_type (type0, type1);\n \t}\n       else if (code0 == POINTER_TYPE && TREE_CODE (op1) == INTEGER_CST\n \t       && integer_zerop (op1))\n@@ -3299,9 +3329,11 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t    warning (\"comparison between pointer and integer\");\n \t  op0 = convert (TREE_TYPE (op1), op0);\n \t}\n-      else\n-\tresult_type = 0;\n-      converted = 1;\n+\n+      type0 = TREE_TYPE (op0);\n+      type1 = TREE_TYPE (op1);\n+      if (result_type == NULL_TREE)\n+\tresult_type = type0;\n       break;\n     }\n \n@@ -3437,7 +3469,8 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t    = shorten_compare (&xop0, &xop1, &xresult_type, &xresultcode);\n \t  if (val != 0)\n \t    return convert (boolean_type_node, val);\n-\t  op0 = xop0, op1 = xop1, result_type = boolean_type_node;\n+\t  op0 = xop0, op1 = xop1;\n+\t  converted = 1;\n \t  resultcode = xresultcode;\n \t}\n \n@@ -3544,8 +3577,11 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \top1 = convert (result_type, op1); \n     }\n \n+  if (build_type == NULL_TREE)\n+    build_type = result_type;\n+\n   {\n-    register tree result = build (resultcode, result_type, op0, op1);\n+    register tree result = build (resultcode, build_type, op0, op1);\n     register tree folded;\n \n     folded = fold (result);\n@@ -6731,11 +6767,22 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t     && TREE_CODE (rhstype) == POINTER_TYPE\n \t     && TREE_CODE (TREE_TYPE (rhstype)) == METHOD_TYPE)\n \t    || integer_zerop (rhs)\n-\t    || TYPE_PTRMEMFUNC_P (TREE_TYPE (rhs)))\n+\t    || TYPE_PTRMEMFUNC_P (rhstype))\n \t   && TYPE_PTRMEMFUNC_P (type))\n     {\n+      tree ttl = TYPE_PTRMEMFUNC_FN_TYPE (type);\n+      tree ttr = (TREE_CODE (rhstype) == POINTER_TYPE ? rhstype\n+\t\t    : TYPE_PTRMEMFUNC_FN_TYPE (type));\n+      int ctt = comp_target_types (ttl, ttr, 1);\n+\n+      if (ctt < 0)\n+\tcp_pedwarn (\"converting `%T' to `%T' is a contravariance violation\",\n+\t\t    ttr, ttl);\n+      else if (ctt == 0)\n+\tcp_error (\"%s to `%T' from `%T'\", errtype, ttl, ttr);\n+\n       /* compatible pointer to member functions. */\n-      return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), rhs, 0);\n+      return build_ptrmemfunc (ttl, rhs, 0);\n     }\n   else if (codel == ERROR_MARK || coder == ERROR_MARK)\n     return error_mark_node;"}]}