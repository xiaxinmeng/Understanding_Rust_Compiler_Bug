{"sha": "8736e836087d26129ec5e6e54bb687a3ad7a9d65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODczNmU4MzYwODdkMjYxMjllYzVlNmU1NGJiNjg3YTNhZDdhOWQ2NQ==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1995-03-03T03:45:02Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1995-03-03T03:45:02Z"}, "message": "Update CLEANUP_POINT_EXPR docs.\n\nFrom-SVN: r9118", "tree": {"sha": "373d4e719f8e255b0d359d3725e4f4dd214ead0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/373d4e719f8e255b0d359d3725e4f4dd214ead0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8736e836087d26129ec5e6e54bb687a3ad7a9d65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8736e836087d26129ec5e6e54bb687a3ad7a9d65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8736e836087d26129ec5e6e54bb687a3ad7a9d65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8736e836087d26129ec5e6e54bb687a3ad7a9d65/comments", "author": null, "committer": null, "parents": [{"sha": "f283f66b1f8eb2061535a609ae850998b9e44306", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f283f66b1f8eb2061535a609ae850998b9e44306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f283f66b1f8eb2061535a609ae850998b9e44306"}], "stats": {"total": 16, "additions": 14, "deletions": 2}, "files": [{"sha": "453e28864828d6704781c25371962cf033ae4405", "filename": "gcc/tree.def", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8736e836087d26129ec5e6e54bb687a3ad7a9d65/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8736e836087d26129ec5e6e54bb687a3ad7a9d65/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=8736e836087d26129ec5e6e54bb687a3ad7a9d65", "patch": "@@ -444,8 +444,20 @@ DEFTREECODE (METHOD_CALL_EXPR, \"method_call_expr\", \"e\", 4)\n DEFTREECODE (WITH_CLEANUP_EXPR, \"with_cleanup_expr\", \"e\", 3)\n \n /* Specify a cleanup point.\n-   Operand 0 is the expression that has cleanups that we want ensure are\n-   cleaned up.  */\n+   Operand 0 is an expression that may have cleanups.  If it does, those\n+   cleanups are executed after the expression is expanded.\n+\n+   Note that if the expression is a reference to storage, it is forced out\n+   of memory before the cleanups are run.  This is necessary to handle\n+   cases where the cleanups modify the storage referenced; in the\n+   expression 't.i', if 't' is a struct with an integer member 'i' and a\n+   cleanup which modifies 'i', the value of the expression depends on\n+   whether the cleanup is run before or after 't.i' is evaluated.  When\n+   expand_expr is run on 't.i', it returns a MEM.  This is not good enough;\n+   the value of 't.i' must be forced out of memory.\n+\n+   As a consequence, the operand of a CLEANUP_POINT_EXPR must not have\n+   BLKmode, because it will not be forced out of memory.  */\n DEFTREECODE (CLEANUP_POINT_EXPR, \"cleanup_point_expr\", \"e\", 1)\n \n /* The following two codes are used in languages that have types where"}]}