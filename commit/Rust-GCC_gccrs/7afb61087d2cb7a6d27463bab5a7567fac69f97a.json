{"sha": "7afb61087d2cb7a6d27463bab5a7567fac69f97a", "node_id": "C_kwDOANBUbNoAKDdhZmI2MTA4N2QyY2I3YTZkMjc0NjNiYWI1YTc1NjdmYWM2OWY5N2E", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2021-10-08T21:29:12Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2021-10-08T21:29:12Z"}, "message": "Fortran: Add diagnostic for F2018:C839 (TS29113:C535c)\n\n2021-10-08 Sandra Loosemore  <sandra@codesourcery.com>\n\n\tPR fortran/54753\n\ngcc/fortran/\n\t* interface.c (gfc_compare_actual_formal): Add diagnostic\n\tfor F2018:C839.  Refactor shared code and fix bugs with class\n\tarray info lookup, and extend similar diagnostic from PR94110\n\tto also cover class types.\n\ngcc/testsuite/\n\t* gfortran.dg/c-interop/c535c-1.f90: Rewrite and expand.\n\t* gfortran.dg/c-interop/c535c-2.f90: Remove xfails.\n\t* gfortran.dg/c-interop/c535c-3.f90: Likewise.\n\t* gfortran.dg/c-interop/c535c-4.f90: Likewise.\n\t* gfortran.dg/PR94110.f90: Extend to cover class types.", "tree": {"sha": "239c0e379896d7e88b355836812a470c54167227", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/239c0e379896d7e88b355836812a470c54167227"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7afb61087d2cb7a6d27463bab5a7567fac69f97a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7afb61087d2cb7a6d27463bab5a7567fac69f97a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7afb61087d2cb7a6d27463bab5a7567fac69f97a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7afb61087d2cb7a6d27463bab5a7567fac69f97a/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9046e0d46fc285e5c59c87182d48c8de0f7f929c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9046e0d46fc285e5c59c87182d48c8de0f7f929c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9046e0d46fc285e5c59c87182d48c8de0f7f929c"}], "stats": {"total": 304, "additions": 236, "deletions": 68}, "files": [{"sha": "2a71da75c724d7fe25e27dc432580f994d7878ee", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 89, "deletions": 11, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7afb61087d2cb7a6d27463bab5a7567fac69f97a/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7afb61087d2cb7a6d27463bab5a7567fac69f97a/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=7afb61087d2cb7a6d27463bab5a7567fac69f97a", "patch": "@@ -3061,6 +3061,8 @@ gfc_compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n   unsigned long actual_size, formal_size;\n   bool full_array = false;\n   gfc_array_ref *actual_arr_ref;\n+  gfc_array_spec *fas, *aas;\n+  bool pointer_dummy, pointer_arg, allocatable_arg;\n \n   actual = *ap;\n \n@@ -3329,13 +3331,60 @@ gfc_compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  return false;\n \t}\n \n-      if (f->sym->as\n-\t  && (f->sym->as->type == AS_ASSUMED_SHAPE\n-\t      || f->sym->as->type == AS_DEFERRED\n-\t      || (f->sym->as->type == AS_ASSUMED_RANK && f->sym->attr.pointer))\n-\t  && a->expr->expr_type == EXPR_VARIABLE\n-\t  && a->expr->symtree->n.sym->as\n-\t  && a->expr->symtree->n.sym->as->type == AS_ASSUMED_SIZE\n+      /* Class array variables and expressions store array info in a\n+\t different place from non-class objects; consolidate the logic\n+\t to access it here instead of repeating it below.  Note that\n+\t pointer_arg and allocatable_arg are not fully general and are\n+\t only used in a specific situation below with an assumed-rank\n+\t argument.  */\n+      if (f->sym->ts.type == BT_CLASS && CLASS_DATA (f->sym))\n+\t{\n+\t  gfc_component *classdata = CLASS_DATA (f->sym);\n+\t  fas = classdata->as;\n+\t  pointer_dummy = classdata->attr.class_pointer;\n+\t}\n+      else\n+\t{\n+\t  fas = f->sym->as;\n+\t  pointer_dummy = f->sym->attr.pointer;\n+\t}\n+\n+      if (a->expr->expr_type != EXPR_VARIABLE)\n+\t{\n+\t  aas = NULL;\n+\t  pointer_arg = false;\n+\t  allocatable_arg = false;\n+\t}\n+      else if (a->expr->ts.type == BT_CLASS\n+\t       && a->expr->symtree->n.sym\n+\t       && CLASS_DATA (a->expr->symtree->n.sym))\n+\t{\n+\t  gfc_component *classdata = CLASS_DATA (a->expr->symtree->n.sym);\n+\t  aas = classdata->as;\n+\t  pointer_arg = classdata->attr.class_pointer;\n+\t  allocatable_arg = classdata->attr.allocatable;\n+\t}\n+      else\n+\t{\n+\t  aas = a->expr->symtree->n.sym->as;\n+\t  pointer_arg = a->expr->symtree->n.sym->attr.pointer;\n+\t  allocatable_arg = a->expr->symtree->n.sym->attr.allocatable;\n+\t}\n+\n+      /* F2018:9.5.2(2) permits assumed-size whole array expressions as\n+\t actual arguments only if the shape is not required; thus it\n+\t cannot be passed to an assumed-shape array dummy.\n+\t F2018:15.5.2.(2) permits passing a nonpointer actual to an\n+\t intent(in) pointer dummy argument and this is accepted by\n+\t the compare_pointer check below, but this also requires shape\n+\t information.\n+\t There's more discussion of this in PR94110.  */\n+      if (fas\n+\t  && (fas->type == AS_ASSUMED_SHAPE\n+\t      || fas->type == AS_DEFERRED\n+\t      || (fas->type == AS_ASSUMED_RANK && pointer_dummy))\n+\t  && aas\n+\t  && aas->type == AS_ASSUMED_SIZE\n \t  && (a->expr->ref == NULL\n \t      || (a->expr->ref->type == REF_ARRAY\n \t\t  && a->expr->ref->u.ar.type == AR_FULL)))\n@@ -3346,6 +3395,35 @@ gfc_compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  return false;\n \t}\n \n+      /* Diagnose F2018 C839 (TS29113 C535c).  Here the problem is\n+\t passing an assumed-size array to an INTENT(OUT) assumed-rank\n+\t dummy when it doesn't have the size information needed to run\n+\t initializers and finalizers.  */\n+      if (f->sym->attr.intent == INTENT_OUT\n+\t  && fas\n+\t  && fas->type == AS_ASSUMED_RANK\n+\t  && aas\n+\t  && ((aas->type == AS_ASSUMED_SIZE\n+\t       && (a->expr->ref == NULL\n+\t\t   || (a->expr->ref->type == REF_ARRAY\n+\t\t       && a->expr->ref->u.ar.type == AR_FULL)))\n+\t      || (aas->type == AS_ASSUMED_RANK\n+\t\t  && !pointer_arg\n+\t\t  && !allocatable_arg))\n+\t  && (a->expr->ts.type == BT_CLASS\n+\t      || (a->expr->ts.type == BT_DERIVED\n+\t\t  && (gfc_is_finalizable (a->expr->ts.u.derived, NULL)\n+\t\t      || gfc_has_ultimate_allocatable (a->expr)\n+\t\t      || gfc_has_default_initializer\n+\t\t\t   (a->expr->ts.u.derived)))))\n+\t{\n+\t  if (where)\n+\t    gfc_error (\"Actual argument to assumed-rank INTENT(OUT) \"\n+\t\t       \"dummy %qs at %L cannot be of unknown size\",\n+\t\t       f->sym->name, where);\n+\t  return false;\n+\t}\n+\n       if (a->expr->expr_type != EXPR_NULL\n \t  && compare_pointer (f->sym, a->expr) == 0)\n \t{\n@@ -3479,7 +3557,7 @@ gfc_compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  && a->expr->expr_type == EXPR_VARIABLE\n \t  && a->expr->symtree->n.sym->as\n \t  && a->expr->symtree->n.sym->as->type == AS_ASSUMED_SHAPE\n-\t  && !(f->sym->as && f->sym->as->type == AS_ASSUMED_SHAPE))\n+\t  && !(fas && fas->type == AS_ASSUMED_SHAPE))\n \t{\n \t  if (where)\n \t    gfc_error (\"Assumed-shape actual argument at %L is \"\n@@ -3496,7 +3574,7 @@ gfc_compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \n       if (f->sym->attr.volatile_\n \t  && actual_arr_ref && actual_arr_ref->type == AR_SECTION\n-\t  && !(f->sym->as && f->sym->as->type == AS_ASSUMED_SHAPE))\n+\t  && !(fas && fas->type == AS_ASSUMED_SHAPE))\n \t{\n \t  if (where)\n \t    gfc_error (\"Array-section actual argument at %L is \"\n@@ -3514,8 +3592,8 @@ gfc_compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  && a->expr->expr_type == EXPR_VARIABLE\n \t  && a->expr->symtree->n.sym->attr.pointer\n \t  && a->expr->symtree->n.sym->as\n-\t  && !(f->sym->as\n-\t       && (f->sym->as->type == AS_ASSUMED_SHAPE\n+\t  && !(fas\n+\t       && (fas->type == AS_ASSUMED_SHAPE\n \t\t   || f->sym->attr.pointer)))\n \t{\n \t  if (where)"}, {"sha": "4e43332b64e5f1545910460cfaaab75c193cc095", "filename": "gcc/testsuite/gfortran.dg/PR94110.f90", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7afb61087d2cb7a6d27463bab5a7567fac69f97a/gcc%2Ftestsuite%2Fgfortran.dg%2FPR94110.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7afb61087d2cb7a6d27463bab5a7567fac69f97a/gcc%2Ftestsuite%2Fgfortran.dg%2FPR94110.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR94110.f90?ref=7afb61087d2cb7a6d27463bab5a7567fac69f97a", "patch": "@@ -9,6 +9,16 @@ program asa_p\n \n   integer, parameter :: n = 7\n \n+  type t\n+  end type t\n+\n+  interface\n+    subroutine fc2 (x)\n+      import :: t\n+      class(t), pointer, intent(in) :: x(..)\n+    end subroutine\n+  end interface\n+\n   integer :: p(n)\n   integer :: s\n \n@@ -84,5 +94,10 @@ function sum_p_ar(a) result(s)\n     return\n   end function sum_p_ar\n \n+  subroutine sub1(y)\n+    type(t), target :: y(*)\n+    call fc2 (y) ! { dg-error \"Actual argument for .x. cannot be an assumed-size array\" } \n+  end subroutine sub1\n+\n end program asa_p\n "}, {"sha": "2158c35be82aade4175e57a6b7eafa950ce7f507", "filename": "gcc/testsuite/gfortran.dg/c-interop/c535c-1.f90", "status": "modified", "additions": 126, "deletions": 49, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7afb61087d2cb7a6d27463bab5a7567fac69f97a/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7afb61087d2cb7a6d27463bab5a7567fac69f97a/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-1.f90?ref=7afb61087d2cb7a6d27463bab5a7567fac69f97a", "patch": "@@ -11,77 +11,154 @@\n ! This test file contains tests that are expected to issue diagnostics\n ! for invalid code.\n \n-module m\n-\n+module t\n   type :: t1\n     integer :: id\n     real :: xyz(3)\n   end type\n+end module  \n \n-contains\n+module m\n+  use t\n+\n+  ! Assumed-type dummies are (unlimited) polymorphic too, but F2018:C709\n+  ! already prohibits them from being declared intent(out).  So we only\n+  ! test dummies of class type that are polymorphic or unlimited\n+  ! polymorphic.\n+  interface\n+    subroutine poly (x, y)\n+      use t\n+      class(t1) :: x(..)\n+      class(t1), intent (out) :: y(..)\n+    end subroutine\n+    subroutine upoly (x, y)\n+      class(*) :: x(..)\n+      class(*), intent (out) :: y(..)\n+    end subroutine\n+  end interface\n \n-  subroutine s1_nonpolymorphic (x, y)\n-    type(t1) :: x(..)\n-    type(t1), intent(out) :: y(..)\n-  end subroutine\n+contains\n \n-  subroutine s1_polymorphic (x, y)  ! { dg-bogus \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n-    class(t1) :: x(..)\n-    class(t1), intent(out) :: y(..)\n+  ! The known-size calls should all be OK as they do not involve\n+  ! assumed-size or assumed-rank actual arguments.\n+  subroutine test_known_size_nonpolymorphic (a1, a2, n)\n+    integer :: n\n+    type(t1) :: a1(n,n), a2(n)\n+    call poly (a1, a2)\n+    call upoly (a1, a2)\n   end subroutine\n-\n-  subroutine s1_unlimited_polymorphic (x, y)  ! { dg-bogus \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n-    class(*) :: x(..)\n-    class(*), intent(out) :: y(..)\n+  subroutine test_known_size_polymorphic (a1, a2, n)\n+    integer :: n\n+    class(t1) :: a1(n,n), a2(n)\n+    call poly (a1, a2)\n+    call upoly (a1, a2)\n   end subroutine\n-\n-  ! These calls should all be OK as they do not involve assumed-size or\n-  ! assumed-rank actual arguments.\n-  subroutine test_known_size (a1, a2, n)\n+  subroutine test_known_size_unlimited_polymorphic (a1, a2, n)\n     integer :: n\n-    type(t1) :: a1(n,n), a2(n)\n+    class(*) :: a1(n,n), a2(n)\n+    call upoly (a1, a2)\n+  end subroutine\n \n-    call s1_nonpolymorphic (a1, a2)\n-    call s1_polymorphic (a1, a2)\n-    call s1_unlimited_polymorphic (a1, a2)\n+  ! Likewise passing a scalar as the assumed-rank argument.\n+  subroutine test_scalar_nonpolymorphic (a1, a2)\n+    type(t1) :: a1, a2\n+    call poly (a1, a2)\n+    call upoly (a1, a2)\n+  end subroutine\n+  subroutine test_scalar_polymorphic (a1, a2)\n+    class(t1) :: a1, a2\n+    call poly (a1, a2)\n+    call upoly (a1, a2)\n+  end subroutine\n+  subroutine test_scalar_unlimited_polymorphic (a1, a2)\n+    class(*) :: a1, a2\n+    call upoly (a1, a2)\n+  end subroutine\n+  \n+  ! The polymorphic cases for assumed-size are bad.\n+  subroutine test_assumed_size_nonpolymorphic (a1, a2)\n+    type(t1) :: a1(*), a2(*)\n+    call poly (a1, a2)  ! OK\n+    call upoly (a1, a2)  ! OK\n+  end subroutine\n+  subroutine test_assumed_size_polymorphic (a1, a2)\n+    class(t1) :: a1(*), a2(*)\n+    call poly (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" }\n+    call upoly (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" }\n+    call poly (a1(5), a2(4:7))\n+  end subroutine\n+  subroutine test_assumed_size_unlimited_polymorphic (a1, a2)\n+    class(*) :: a1(*), a2(*)\n+    call upoly (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" }\n   end subroutine\n \n-  ! The calls to the polymorphic functions should be rejected\n-  ! with an assumed-size array argument.\n-  subroutine test_assumed_size (a1, a2)\n+  ! The arguments being passed to poly/upoly in this set are *not*\n+  ! assumed size and should not error.\n+  subroutine test_not_assumed_size_nonpolymorphic (a1, a2)\n     type(t1) :: a1(*), a2(*)\n+    call poly (a1(5), a2(4:7))\n+    call upoly (a1(5), a2(4:7))\n+    call poly (a1(:10), a2(:-5))\n+    call upoly (a1(:10), a2(:-5))\n+  end subroutine\n+  subroutine test_not_assumed_size_polymorphic (a1, a2)\n+    class(t1) :: a1(*), a2(*)\n+    call poly (a1(5), a2(4:7))\n+    call upoly (a1(5), a2(4:7))\n+    call poly (a1(:10), a2(:-5))\n+    call upoly (a1(:10), a2(:-5))\n+  end subroutine\n+  subroutine test_not_assumed_size_unlimited_polymorphic (a1, a2)\n+    class(*) :: a1(*), a2(*)\n+    call upoly (a1(5), a2(4:7))\n+    call upoly (a1(:10), a2(:-5))\n+  end subroutine\n \n-    call s1_nonpolymorphic (a1, a2)\n-    call s1_polymorphic (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n-    call s1_unlimited_polymorphic (a1, a2) ! { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+  ! Polymorphic assumed-rank without pointer/allocatable is also bad.\n+  subroutine test_assumed_rank_nonpolymorphic (a1, a2)\n+    type(t1) :: a1(..), a2(..)\n+    call poly (a1, a2)  ! OK\n+    call upoly (a1, a2)  ! OK\n+  end subroutine\n+  subroutine test_assumed_rank_polymorphic (a1, a2)\n+    class(t1) :: a1(..), a2(..)\n+    call poly (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" }\n+    call upoly (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" }\n+  end subroutine\n+  subroutine test_assumed_rank_unlimited_polymorphic (a1, a2)\n+    class(*) :: a1(..), a2(..)\n+    call upoly (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" }\n   end subroutine\n \n-  ! These calls should be OK.\n-  subroutine test_assumed_rank_pointer (a1, a2)\n+  ! Pointer/allocatable assumed-rank should be OK.\n+  subroutine test_pointer_nonpolymorphic (a1, a2)\n     type(t1), pointer :: a1(..), a2(..)\n-\n-    call s1_nonpolymorphic (a1, a2)\n-    call s1_polymorphic (a1, a2)\n-    call s1_unlimited_polymorphic (a1, a2)\n+    call poly (a1, a2)\n+    call upoly (a1, a2)\n+  end subroutine\n+  subroutine test_pointer_polymorphic (a1, a2)\n+    class(t1), pointer :: a1(..), a2(..)\n+    call poly (a1, a2)\n+    call upoly (a1, a2)\n+  end subroutine\n+  subroutine test_pointer_unlimited_polymorphic (a1, a2)\n+    class(*), pointer :: a1(..), a2(..)\n+    call upoly (a1, a2)\n   end subroutine\n \n-  ! These calls should be OK.\n-  subroutine test_assumed_rank_allocatable (a1, a2)\n+  subroutine test_allocatable_nonpolymorphic (a1, a2)\n     type(t1), allocatable :: a1(..), a2(..)\n-\n-    call s1_nonpolymorphic (a1, a2)\n-    call s1_polymorphic (a1, a2)\n-    call s1_unlimited_polymorphic (a1, a2)\n+    call poly (a1, a2)\n+    call upoly (a1, a2)\n   end subroutine\n-  \n-  ! The calls to the polymorphic functions should be rejected\n-  ! with a nonallocatable nonpointer assumed-rank actual argument.\n-  subroutine test_assumed_rank_plain (a1, a2)\n-    type(t1) :: a1(..), a2(..)\n-\n-    call s1_nonpolymorphic (a1, a2)\n-    call s1_polymorphic (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n-    call s1_unlimited_polymorphic (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+  subroutine test_allocatable_polymorphic (a1, a2)\n+    class(t1), allocatable :: a1(..), a2(..)\n+    call poly (a1, a2)\n+    call upoly (a1, a2)\n+  end subroutine\n+  subroutine test_allocatable_unlimited_polymorphic (a1, a2)\n+    class(*), allocatable :: a1(..), a2(..)\n+    call upoly (a1, a2)\n   end subroutine\n \n end module"}, {"sha": "f232efae9fc35c220b669475e321e394cb4e10f0", "filename": "gcc/testsuite/gfortran.dg/c-interop/c535c-2.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7afb61087d2cb7a6d27463bab5a7567fac69f97a/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7afb61087d2cb7a6d27463bab5a7567fac69f97a/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-2.f90?ref=7afb61087d2cb7a6d27463bab5a7567fac69f97a", "patch": "@@ -45,7 +45,7 @@ subroutine test_known_size (a1, a2, n)\n   subroutine test_assumed_size (a1, a2)\n     type(t1) :: a1(*), a2(*)\n     \n-    call s1 (a1, a2)  !  { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+    call s1 (a1, a2)  !  { dg-error \"(A|a)ssumed.rank\" }\n   end subroutine\n \n   ! This call should be OK.\n@@ -67,7 +67,7 @@ subroutine test_assumed_rank_allocatable (a1, a2)\n   subroutine test_assumed_rank_plain (a1, a2)\n     type(t1) :: a1(..), a2(..)\n \n-    call s1 (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+    call s1 (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" }\n   end subroutine\n \n end module"}, {"sha": "50840a1ba5fddda6a2a8da099d78f9ed2fe1c310", "filename": "gcc/testsuite/gfortran.dg/c-interop/c535c-3.f90", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7afb61087d2cb7a6d27463bab5a7567fac69f97a/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7afb61087d2cb7a6d27463bab5a7567fac69f97a/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-3.f90?ref=7afb61087d2cb7a6d27463bab5a7567fac69f97a", "patch": "@@ -1,6 +1,5 @@\n ! PR 54753\n ! { dg-do compile }\n-! { dg-ice \"pr54753\" }\n !\n ! TS 29113\n ! C535c If an assumed-size or nonallocatable nonpointer assumed-rank\n@@ -45,7 +44,7 @@ subroutine test_known_size (a1, a2, n)\n   subroutine test_assumed_size (a1, a2)\n     type(t1) :: a1(*), a2(*)\n     \n-    call s1 (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+    call s1 (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" }\n   end subroutine\n \n   ! This call should be OK.\n@@ -67,7 +66,7 @@ subroutine test_assumed_rank_allocatable (a1, a2)\n   subroutine test_assumed_rank_plain (a1, a2)\n     type(t1) :: a1(..), a2(..)\n \n-    call s1 (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+    call s1 (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" }\n   end subroutine\n \n end module"}, {"sha": "dc380baf4657d4067c2937036a08b9a606c0bd05", "filename": "gcc/testsuite/gfortran.dg/c-interop/c535c-4.f90", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7afb61087d2cb7a6d27463bab5a7567fac69f97a/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7afb61087d2cb7a6d27463bab5a7567fac69f97a/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-4.f90?ref=7afb61087d2cb7a6d27463bab5a7567fac69f97a", "patch": "@@ -1,6 +1,5 @@\n ! PR 54753\n ! { dg-do compile }\n-! { dg-ice \"pr54753\" }\n !\n ! TS 29113\n ! C535c If an assumed-size or nonallocatable nonpointer assumed-rank\n@@ -45,7 +44,7 @@ subroutine test_known_size (a1, a2, n)\n   subroutine test_assumed_size (a1, a2)\n     type(t1) :: a1(*), a2(*)\n     \n-    call s1 (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+    call s1 (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" }\n   end subroutine\n \n   ! This call should be OK.\n@@ -67,7 +66,7 @@ subroutine test_assumed_rank_allocatable (a1, a2)\n   subroutine test_assumed_rank_plain (a1, a2)\n     type(t1) :: a1(..), a2(..)\n \n-    call s1 (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+    call s1 (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" }\n   end subroutine\n \n end module"}]}