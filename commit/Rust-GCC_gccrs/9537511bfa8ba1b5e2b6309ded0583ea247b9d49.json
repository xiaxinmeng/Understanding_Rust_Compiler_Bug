{"sha": "9537511bfa8ba1b5e2b6309ded0583ea247b9d49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTUzNzUxMWJmYThiYTFiNWUyYjYzMDlkZWQwNTgzZWEyNDdiOWQ0OQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2003-02-04T22:47:23Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2003-02-04T22:47:23Z"}, "message": "reload.c (find_reloads): Do not use the mode specified in the insn pattern as reload mode for address...\n\n\t* reload.c (find_reloads): Do not use the mode specified in the insn\n\tpattern as reload mode for address operands.  Do not generate optional\n\treloads for operands where a mandatory reload was already pushed.\n\nFrom-SVN: r62410", "tree": {"sha": "42f6f5502a1bb0672a9f31306e356f8af989735f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42f6f5502a1bb0672a9f31306e356f8af989735f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9537511bfa8ba1b5e2b6309ded0583ea247b9d49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9537511bfa8ba1b5e2b6309ded0583ea247b9d49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9537511bfa8ba1b5e2b6309ded0583ea247b9d49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9537511bfa8ba1b5e2b6309ded0583ea247b9d49/comments", "author": null, "committer": null, "parents": [{"sha": "2de2cd7851fa02594628e7fb79c077e23a2b4374", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2de2cd7851fa02594628e7fb79c077e23a2b4374", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2de2cd7851fa02594628e7fb79c077e23a2b4374"}], "stats": {"total": 27, "additions": 19, "deletions": 8}, "files": [{"sha": "dfafdec874aa44d5f82bdac464e3d35a47881a45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9537511bfa8ba1b5e2b6309ded0583ea247b9d49/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9537511bfa8ba1b5e2b6309ded0583ea247b9d49/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9537511bfa8ba1b5e2b6309ded0583ea247b9d49", "patch": "@@ -1,3 +1,9 @@\n+2003-02-04  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* reload.c (find_reloads): Do not use the mode specified in the insn\n+\tpattern as reload mode for address operands.  Do not generate optional \n+\treloads for operands where a mandatory reload was already pushed.\n+\n 2003-02-04  Richard Henderson  <rth@redhat.com>\n \n \t* longlong.h [alpha] (count_leading_zeros, count_trailing_zeros): Use"}, {"sha": "a2642aa7349973d080ff19a37fa9f5329de1cd52", "filename": "gcc/reload.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9537511bfa8ba1b5e2b6309ded0583ea247b9d49/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9537511bfa8ba1b5e2b6309ded0583ea247b9d49/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=9537511bfa8ba1b5e2b6309ded0583ea247b9d49", "patch": "@@ -2476,6 +2476,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   char pref_or_nothing[MAX_RECOG_OPERANDS];\n   /* Nonzero for a MEM operand whose entire address needs a reload.  */\n   int address_reloaded[MAX_RECOG_OPERANDS];\n+  /* Nonzero for an address operand that needs to be completely reloaded.  */\n+  int address_operand_reloaded[MAX_RECOG_OPERANDS];\n   /* Value of enum reload_type to use for operand.  */\n   enum reload_type operand_type[MAX_RECOG_OPERANDS];\n   /* Value of enum reload_type to use within address of operand.  */\n@@ -2655,6 +2657,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       RTX_CODE code = GET_CODE (recog_data.operand[i]);\n \n       address_reloaded[i] = 0;\n+      address_operand_reloaded[i] = 0;\n       operand_type[i] = (modified[i] == RELOAD_READ ? RELOAD_FOR_INPUT\n \t\t\t : modified[i] == RELOAD_WRITE ? RELOAD_FOR_OUTPUT\n \t\t\t : RELOAD_OTHER);\n@@ -2669,10 +2672,11 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       else if (constraints[i][0] == 'p'\n \t       || EXTRA_ADDRESS_CONSTRAINT (constraints[i][0], constraints[i]))\n \t{\n-\t  find_reloads_address (recog_data.operand_mode[i], (rtx*) 0,\n-\t\t\t\trecog_data.operand[i],\n-\t\t\t\trecog_data.operand_loc[i],\n-\t\t\t\ti, operand_type[i], ind_levels, insn);\n+\t  address_operand_reloaded[i]\n+\t    = find_reloads_address (recog_data.operand_mode[i], (rtx*) 0,\n+\t\t\t\t    recog_data.operand[i],\n+\t\t\t\t    recog_data.operand_loc[i],\n+\t\t\t\t    i, operand_type[i], ind_levels, insn);\n \n \t  /* If we now have a simple operand where we used to have a\n \t     PLUS or MULT, re-recognize and try again.  */\n@@ -2689,6 +2693,10 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n \t  recog_data.operand[i] = *recog_data.operand_loc[i];\n \t  substed_operand[i] = recog_data.operand[i];\n+\n+\t  /* Address operands are reloaded in their existing mode,\n+\t     no matter what is specified in the machine description.  */\n+\t  operand_mode[i] = GET_MODE (recog_data.operand[i]);\n \t}\n       else if (code == MEM)\n \t{\n@@ -3302,10 +3310,6 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t   the address into a base register.  */\n \t\t\tthis_alternative[i] = (int) MODE_BASE_REG_CLASS (VOIDmode);\n \t\t\tbadop = 0;\n-\n-\t\t\t/* Address constraints are reloaded in Pmode, no matter\n-\t\t\t   what mode is given in the machine description.  */\n-\t\t\toperand_mode[i] = Pmode;\n \t\t\tbreak;\n \t\t      }\n \n@@ -3878,6 +3882,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       }\n     else if (goal_alternative_matched[i] < 0\n \t     && goal_alternative_matches[i] < 0\n+\t     && !address_operand_reloaded[i]\n \t     && optimize)\n       {\n \t/* For each non-matching operand that's a MEM or a pseudo-register"}]}