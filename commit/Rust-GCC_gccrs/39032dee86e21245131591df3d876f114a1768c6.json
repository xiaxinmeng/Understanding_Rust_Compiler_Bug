{"sha": "39032dee86e21245131591df3d876f114a1768c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkwMzJkZWU4NmUyMTI0NTEzMTU5MWRmM2Q4NzZmMTE0YTE3NjhjNg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-05-09T08:14:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-05-09T08:14:44Z"}, "message": "tree-vrp.c (get_single_symbol): Add assert that we don't get overflowed constants as invariant part.\n\n2017-05-09  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vrp.c (get_single_symbol): Add assert that we don't\n\tget overflowed constants as invariant part.\n\t(compare_values_warnv): Add comment before the TREE_NO_WARNING\n\tchecks.  Use wi::cmp instead of recursing for integer constants.\n\t(compare_values): Just ignore whether we assumed undefined\n\toverflow instead of failing the compare.\n\t(extract_range_for_var_from_comparison_expr): Add comment before the\n\tTREE_NO_WARNING sets.\n\t(test_for_singularity): Likewise.\n\t(extract_range_from_comparison): Do not disable optimization\n\twhen we assumed undefined overflow.\n\t(extract_range_basic): Remove init of unused var.\n\nFrom-SVN: r247781", "tree": {"sha": "30f34d56161a5d9f19e05404acce2191ea551a55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30f34d56161a5d9f19e05404acce2191ea551a55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39032dee86e21245131591df3d876f114a1768c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39032dee86e21245131591df3d876f114a1768c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39032dee86e21245131591df3d876f114a1768c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39032dee86e21245131591df3d876f114a1768c6/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4ca2e6ec7cb634b3f2598026be638b768c926681", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ca2e6ec7cb634b3f2598026be638b768c926681", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ca2e6ec7cb634b3f2598026be638b768c926681"}], "stats": {"total": 60, "additions": 33, "deletions": 27}, "files": [{"sha": "cf2f88ee41b6cd4cd6989bf72f43c25563ed9ce0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39032dee86e21245131591df3d876f114a1768c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39032dee86e21245131591df3d876f114a1768c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39032dee86e21245131591df3d876f114a1768c6", "patch": "@@ -1,3 +1,18 @@\n+2017-05-09  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vrp.c (get_single_symbol): Add assert that we don't\n+\tget overflowed constants as invariant part.\n+\t(compare_values_warnv): Add comment before the TREE_NO_WARNING\n+\tchecks.  Use wi::cmp instead of recursing for integer constants.\n+\t(compare_values): Just ignore whether we assumed undefined\n+\toverflow instead of failing the compare.\n+\t(extract_range_for_var_from_comparison_expr): Add comment before the\n+\tTREE_NO_WARNING sets.\n+\t(test_for_singularity): Likewise.\n+\t(extract_range_from_comparison): Do not disable optimization\n+\twhen we assumed undefined overflow.\n+\t(extract_range_basic): Remove init of unused var.\n+\n 2017-05-09  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vrp.c (vrp_int_const_binop): Use wide-ints and simplify."}, {"sha": "a045dd080db7edc49477ffdbb0ddb7dc9bf37ca5", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39032dee86e21245131591df3d876f114a1768c6/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39032dee86e21245131591df3d876f114a1768c6/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=39032dee86e21245131591df3d876f114a1768c6", "patch": "@@ -803,6 +803,8 @@ get_single_symbol (tree t, bool *neg, tree *inv)\n   if (TREE_CODE (t) != SSA_NAME)\n     return NULL_TREE;\n \n+  gcc_assert (! inv_ || ! TREE_OVERFLOW_P (inv_));\n+\n   *neg = neg_;\n   *inv = inv_;\n   return t;\n@@ -1069,6 +1071,8 @@ compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)\n \treturn -2;\n \n       if (strict_overflow_p != NULL\n+\t  /* Symbolic range building sets TREE_NO_WARNING to declare\n+\t     that overflow doesn't happen.  */\n \t  && (!inv1 || !TREE_NO_WARNING (val1))\n \t  && (!inv2 || !TREE_NO_WARNING (val2)))\n \t*strict_overflow_p = true;\n@@ -1078,7 +1082,7 @@ compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)\n       if (!inv2)\n \tinv2 = build_int_cst (TREE_TYPE (val2), 0);\n \n-      return compare_values_warnv (inv1, inv2, strict_overflow_p);\n+      return wi::cmp (inv1, inv2, TYPE_SIGN (TREE_TYPE (val1)));\n     }\n \n   const bool cst1 = is_gimple_min_invariant (val1);\n@@ -1092,6 +1096,8 @@ compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)\n \treturn -2;\n \n       if (strict_overflow_p != NULL\n+\t  /* Symbolic range building sets TREE_NO_WARNING to declare\n+\t     that overflow doesn't happen.  */\n \t  && (!sym1 || !TREE_NO_WARNING (val1))\n \t  && (!sym2 || !TREE_NO_WARNING (val2)))\n \t*strict_overflow_p = true;\n@@ -1119,14 +1125,9 @@ compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)\n \n   if (!POINTER_TYPE_P (TREE_TYPE (val1)))\n     {\n-      /* We cannot compare overflowed values, except for overflow\n-\t infinities.  */\n+      /* We cannot compare overflowed values.  */\n       if (TREE_OVERFLOW (val1) || TREE_OVERFLOW (val2))\n-\t{\n-\t  if (strict_overflow_p != NULL)\n-\t    *strict_overflow_p = true;\n-\t  return -2;\n-\t}\n+\treturn -2;\n \n       return tree_int_cst_compare (val1, val2);\n     }\n@@ -1162,21 +1163,13 @@ compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)\n     }\n }\n \n-/* Compare values like compare_values_warnv, but treat comparisons of\n-   nonconstants which rely on undefined overflow as incomparable.  */\n+/* Compare values like compare_values_warnv.  */\n \n static int\n compare_values (tree val1, tree val2)\n {\n   bool sop;\n-  int ret;\n-\n-  sop = false;\n-  ret = compare_values_warnv (val1, val2, &sop);\n-  if (sop\n-      && (!is_gimple_min_invariant (val1) || !is_gimple_min_invariant (val2)))\n-    ret = -2;\n-  return ret;\n+  return compare_values_warnv (val1, val2, &sop);\n }\n \n \n@@ -1499,6 +1492,7 @@ extract_range_for_var_from_comparison_expr (tree var, enum tree_code cond_code,\n \t      else\n \t\tmax = fold_build2 (MINUS_EXPR, TREE_TYPE (max), max,\n \t\t\t\t   build_int_cst (TREE_TYPE (max), 1));\n+\t      /* Signal to compare_values_warnv this expr doesn't overflow.  */\n \t      if (EXPR_P (max))\n \t\tTREE_NO_WARNING (max) = 1;\n \t    }\n@@ -1538,6 +1532,7 @@ extract_range_for_var_from_comparison_expr (tree var, enum tree_code cond_code,\n \t      else\n \t\tmin = fold_build2 (PLUS_EXPR, TREE_TYPE (min), min,\n \t\t\t\t   build_int_cst (TREE_TYPE (min), 1));\n+\t      /* Signal to compare_values_warnv this expr doesn't overflow.  */\n \t      if (EXPR_P (min))\n \t\tTREE_NO_WARNING (min) = 1;\n \t    }\n@@ -3446,18 +3441,12 @@ static void\n extract_range_from_comparison (value_range *vr, enum tree_code code,\n \t\t\t       tree type, tree op0, tree op1)\n {\n-  bool sop = false;\n+  bool sop;\n   tree val;\n \n   val = vrp_evaluate_conditional_warnv_with_ops (code, op0, op1, false, &sop,\n   \t\t\t\t\t\t NULL);\n-\n-  /* A disadvantage of using a special infinity as an overflow\n-     representation is that we lose the ability to record overflow\n-     when we don't have an infinity.  So we have to ignore a result\n-     which relies on overflow.  */\n-\n-  if (val && !sop)\n+  if (val)\n     {\n       /* Since this expression was found on the RHS of an assignment,\n \t its type may be different from _Bool.  Convert VAL to EXPR's\n@@ -3587,7 +3576,7 @@ check_for_binary_op_overflow (enum tree_code subcode, tree type,\n static void\n extract_range_basic (value_range *vr, gimple *stmt)\n {\n-  bool sop = false;\n+  bool sop;\n   tree type = gimple_expr_type (stmt);\n \n   if (is_gimple_call (stmt))\n@@ -9496,6 +9485,7 @@ test_for_singularity (enum tree_code cond_code, tree op0,\n \t{\n \t  tree one = build_int_cst (TREE_TYPE (op0), 1);\n \t  max = fold_build2 (MINUS_EXPR, TREE_TYPE (op0), max, one);\n+\t  /* Signal to compare_values_warnv this expr doesn't overflow.  */\n \t  if (EXPR_P (max))\n \t    TREE_NO_WARNING (max) = 1;\n \t}\n@@ -9511,6 +9501,7 @@ test_for_singularity (enum tree_code cond_code, tree op0,\n \t{\n \t  tree one = build_int_cst (TREE_TYPE (op0), 1);\n \t  min = fold_build2 (PLUS_EXPR, TREE_TYPE (op0), min, one);\n+\t  /* Signal to compare_values_warnv this expr doesn't overflow.  */\n \t  if (EXPR_P (min))\n \t    TREE_NO_WARNING (min) = 1;\n \t}"}]}