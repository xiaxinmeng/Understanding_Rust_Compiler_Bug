{"sha": "34e8234204cb51e65f0e4b325634208a227cc8f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRlODIzNDIwNGNiNTFlNjVmMGU0YjMyNTYzNDIwOGEyMjdjYzhmMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-03-14T12:47:42Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-03-14T12:47:42Z"}, "message": "alias.c (struct alias_set_entry): Pack properly.\n\n2017-03-14  Richard Biener  <rguenther@suse.de>\n\n\t* alias.c (struct alias_set_entry): Pack properly.\n\t* cfgloop.h (struct loop): Likewise.\n\t* cse.c (struct set): Likewise.\n\t* ipa-utils.c (struct searchc_env): Likewise.\n\t* loop-invariant.c (struct invariant): Likewise.\n\t* lra-remat.c (struct cand): Likewise.\n\t* recog.c (struct change_t): Likewise.\n\t* rtl.h (struct address_info): Likewise.\n\t* symbol-summary.h (function_summary): Likewise.\n\t* tree-loop-distribution.c (struct partition): Likewise.\n\t* tree-object-size.c (struct object_size_info): Likewise.\n\t* tree-ssa-loop-ivopts.c (struct cost_pair): Likewise.\n\t* tree-ssa-threadupdate.c (struct ssa_local_info_t): Likewise.\n\t* tree-vect-data-refs.c (struct _vect_peel_info): Likewise.\n\t* tree-vect-slp.c (struct _slp_oprnd_info): Likewise.\n\t* tree-vect-stmts.c (struct simd_call_arg_info): Likewise.\n\t* tree-vectorizer.h (struct _loop_vec_info): Likewise.\n\t(struct _stmt_vec_info): Likewise.\n\nFrom-SVN: r246121", "tree": {"sha": "365347923620859b17381723ff0346cbc96bc340", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/365347923620859b17381723ff0346cbc96bc340"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34e8234204cb51e65f0e4b325634208a227cc8f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34e8234204cb51e65f0e4b325634208a227cc8f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34e8234204cb51e65f0e4b325634208a227cc8f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34e8234204cb51e65f0e4b325634208a227cc8f3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "546eb36c7e0ba37974489280059ca14166f07c26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546eb36c7e0ba37974489280059ca14166f07c26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/546eb36c7e0ba37974489280059ca14166f07c26"}], "stats": {"total": 171, "additions": 96, "deletions": 75}, "files": [{"sha": "7c38be3c7fe4e29dc267eb2711b312d782c6fd92", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=34e8234204cb51e65f0e4b325634208a227cc8f3", "patch": "@@ -1,3 +1,24 @@\n+2017-03-14  Richard Biener  <rguenther@suse.de>\n+\n+\t* alias.c (struct alias_set_entry): Pack properly.\n+\t* cfgloop.h (struct loop): Likewise.\n+\t* cse.c (struct set): Likewise.\n+\t* ipa-utils.c (struct searchc_env): Likewise.\n+\t* loop-invariant.c (struct invariant): Likewise.\n+\t* lra-remat.c (struct cand): Likewise.\n+\t* recog.c (struct change_t): Likewise.\n+\t* rtl.h (struct address_info): Likewise.\n+\t* symbol-summary.h (function_summary): Likewise.\n+\t* tree-loop-distribution.c (struct partition): Likewise.\n+\t* tree-object-size.c (struct object_size_info): Likewise.\n+\t* tree-ssa-loop-ivopts.c (struct cost_pair): Likewise.\n+\t* tree-ssa-threadupdate.c (struct ssa_local_info_t): Likewise.\n+\t* tree-vect-data-refs.c (struct _vect_peel_info): Likewise.\n+\t* tree-vect-slp.c (struct _slp_oprnd_info): Likewise.\n+\t* tree-vect-stmts.c (struct simd_call_arg_info): Likewise.\n+\t* tree-vectorizer.h (struct _loop_vec_info): Likewise.\n+\t(struct _stmt_vec_info): Likewise.\n+\n 2017-03-14  Martin Liska  <mliska@suse.cz>\n \n \tPR target/79892"}, {"sha": "93c136f27d022688f16728d23c69696f7add9c1f", "filename": "gcc/alias.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=34e8234204cb51e65f0e4b325634208a227cc8f3", "patch": "@@ -126,15 +126,6 @@ struct GTY(()) alias_set_entry {\n   /* The alias set number, as stored in MEM_ALIAS_SET.  */\n   alias_set_type alias_set;\n \n-  /* The children of the alias set.  These are not just the immediate\n-     children, but, in fact, all descendants.  So, if we have:\n-\n-       struct T { struct S s; float f; }\n-\n-     continuing our example above, the children here will be all of\n-     `int', `double', `float', and `struct S'.  */\n-  hash_map<alias_set_hash, int> *children;\n-\n   /* Nonzero if would have a child of zero: this effectively makes this\n      alias set the same as alias set zero.  */\n   bool has_zero_child;\n@@ -145,6 +136,15 @@ struct GTY(()) alias_set_entry {\n   bool is_pointer;\n   /* Nonzero if is_pointer or if one of childs have has_pointer set.  */\n   bool has_pointer;\n+\n+  /* The children of the alias set.  These are not just the immediate\n+     children, but, in fact, all descendants.  So, if we have:\n+\n+       struct T { struct S s; float f; }\n+\n+     continuing our example above, the children here will be all of\n+     `int', `double', `float', and `struct S'.  */\n+  hash_map<alias_set_hash, int> *children;\n };\n \n static int rtx_equal_for_memref_p (const_rtx, const_rtx);"}, {"sha": "a8bec1d48af1e7acfcaf48c7518afca195abb7cf", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=34e8234204cb51e65f0e4b325634208a227cc8f3", "patch": "@@ -167,21 +167,6 @@ struct GTY ((chain_next (\"%h.next\"))) loop {\n      nb_iterations.  */\n   widest_int nb_iterations_estimate;\n \n-  bool any_upper_bound;\n-  bool any_estimate;\n-  bool any_likely_upper_bound;\n-\n-  /* True if the loop can be parallel.  */\n-  bool can_be_parallel;\n-\n-  /* True if -Waggressive-loop-optimizations warned about this loop\n-     already.  */\n-  bool warned_aggressive_loop_optimizations;\n-\n-  /* An integer estimation of the number of iterations.  Estimate_state\n-     describes what is the state of the estimation.  */\n-  enum loop_estimation estimate_state;\n-\n   /* If > 0, an integer, where the user asserted that for any\n      I in [ 0, nb_iterations ) and for any J in\n      [ I, min ( I + safelen, nb_iterations ) ), the Ith and Jth iterations\n@@ -211,14 +196,29 @@ struct GTY ((chain_next (\"%h.next\"))) loop {\n      that might result in hard to track down bugs in niter/scev consumers.  */\n   unsigned constraints;\n \n+  /* An integer estimation of the number of iterations.  Estimate_state\n+     describes what is the state of the estimation.  */\n+  ENUM_BITFIELD(loop_estimation) estimate_state : 8;\n+\n+  unsigned any_upper_bound : 1;\n+  unsigned any_estimate : 1;\n+  unsigned any_likely_upper_bound : 1;\n+\n+  /* True if the loop can be parallel.  */\n+  unsigned can_be_parallel : 1;\n+\n+  /* True if -Waggressive-loop-optimizations warned about this loop\n+     already.  */\n+  unsigned warned_aggressive_loop_optimizations : 1;\n+\n   /* True if this loop should never be vectorized.  */\n-  bool dont_vectorize;\n+  unsigned dont_vectorize : 1;\n \n   /* True if we should try harder to vectorize this loop.  */\n-  bool force_vectorize;\n+  unsigned force_vectorize : 1;\n \n   /* True if the loop is part of an oacc kernels region.  */\n-  bool in_oacc_kernels_region;\n+  unsigned in_oacc_kernels_region : 1;\n \n   /* For SIMD loops, this is a unique identifier of the loop, referenced\n      by IFN_GOMP_SIMD_VF, IFN_GOMP_SIMD_LANE and IFN_GOMP_SIMD_LAST_LANE"}, {"sha": "6a968d1978832c25cda2a0726203f73c9ed37741", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=34e8234204cb51e65f0e4b325634208a227cc8f3", "patch": "@@ -4154,10 +4154,10 @@ struct set\n      The size of this field should match the size of the mode\n      field of struct rtx_def (see rtl.h).  */\n   ENUM_BITFIELD(machine_mode) mode : 8;\n-  /* A constant equivalent for SET_SRC, if any.  */\n-  rtx src_const;\n   /* Hash value of constant equivalent for SET_SRC.  */\n   unsigned src_const_hash;\n+  /* A constant equivalent for SET_SRC, if any.  */\n+  rtx src_const;\n   /* Table entry for constant equivalent for SET_SRC, if any.  */\n   struct table_elt *src_const_elt;\n   /* Table entry for the destination address.  */"}, {"sha": "959e31a68e6b878c481b97241e05a8b644bf3cc1", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=34e8234204cb51e65f0e4b325634208a227cc8f3", "patch": "@@ -58,8 +58,8 @@ ipa_print_order (FILE* out,\n \n struct searchc_env {\n   struct cgraph_node **stack;\n-  int stack_size;\n   struct cgraph_node **result;\n+  int stack_size;\n   int order_pos;\n   splay_tree nodes_marked_new;\n   bool reduce;"}, {"sha": "8292cea3e521e1bd0f4fe397cb393b2ba062766f", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=34e8234204cb51e65f0e4b325634208a227cc8f3", "patch": "@@ -108,14 +108,14 @@ struct invariant\n   /* The number of invariants which eqto this.  */\n   unsigned eqno;\n \n-  /* If we moved the invariant out of the loop, the register that contains its\n-     value.  */\n-  rtx reg;\n-\n   /* If we moved the invariant out of the loop, the original regno\n      that contained its value.  */\n   int orig_regno;\n \n+  /* If we moved the invariant out of the loop, the register that contains its\n+     value.  */\n+  rtx reg;\n+\n   /* The definition of the invariant.  */\n   struct def *def;\n \n@@ -134,12 +134,12 @@ struct invariant\n   /* Cost of the invariant.  */\n   unsigned cost;\n \n-  /* The invariants it depends on.  */\n-  bitmap depends_on;\n-\n   /* Used for detecting already visited invariants during determining\n      costs of movements.  */\n   unsigned stamp;\n+\n+  /* The invariants it depends on.  */\n+  bitmap depends_on;\n };\n \n /* Currently processed loop.  */"}, {"sha": "5a15075e7aa8581cc59604d170cf84c5963467bd", "filename": "gcc/lra-remat.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Flra-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Flra-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-remat.c?ref=34e8234204cb51e65f0e4b325634208a227cc8f3", "patch": "@@ -94,10 +94,10 @@ struct cand\n {\n   /* Index of the candidates in all_cands. */\n   int index;\n-  /* The candidate insn.  */\n-  rtx_insn *insn;\n   /* Insn pseudo regno for rematerialization.  */\n   int regno;\n+  /* The candidate insn.  */\n+  rtx_insn *insn;\n   /* Non-negative if a reload pseudo is in the insn instead of the\n      pseudo for rematerialization.  */\n   int reload_regno;"}, {"sha": "63cdc237240b9f354b8c7ba9a6161baa6065e18b", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=34e8234204cb51e65f0e4b325634208a227cc8f3", "patch": "@@ -182,9 +182,9 @@ struct change_t\n {\n   rtx object;\n   int old_code;\n+  bool unshare;\n   rtx *loc;\n   rtx old;\n-  bool unshare;\n };\n \n static change_t *changes;"}, {"sha": "93330425c00f26b19e30076cf91382418f9c49c2", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=34e8234204cb51e65f0e4b325634208a227cc8f3", "patch": "@@ -2021,6 +2021,9 @@ struct address_info {\n   /* The address space.  */\n   addr_space_t as;\n \n+  /* True if this is an RTX_AUTOINC address.  */\n+  bool autoinc_p;\n+\n   /* A pointer to the top-level address.  */\n   rtx *outer;\n \n@@ -2076,9 +2079,6 @@ struct address_info {\n \n   /* If BASE is nonnull, this is the code of the rtx that contains it.  */\n   enum rtx_code base_outer_code;\n-\n-  /* True if this is an RTX_AUTOINC address.  */\n-  bool autoinc_p;\n };\n \n /* This is used to bundle an rtx and a mode together so that the pair"}, {"sha": "d0246f4246715ec590a48b2bec151811ede83040", "filename": "gcc/symbol-summary.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Fsymbol-summary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Fsymbol-summary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymbol-summary.h?ref=34e8234204cb51e65f0e4b325634208a227cc8f3", "patch": "@@ -37,7 +37,7 @@ class GTY((user)) function_summary <T *>\n public:\n   /* Default construction takes SYMTAB as an argument.  */\n   function_summary (symbol_table *symtab, bool ggc = false): m_ggc (ggc),\n-    m_map (13, ggc), m_insertion_enabled (true), m_released (false),\n+    m_insertion_enabled (true), m_released (false), m_map (13, ggc),\n     m_symtab (symtab)\n   {\n     m_symtab_insertion_hook =\n@@ -205,6 +205,10 @@ class GTY((user)) function_summary <T *>\n     return *v;\n   }\n \n+  /* Indicates if insertion hook is enabled.  */\n+  bool m_insertion_enabled;\n+  /* Indicates if the summary is released.  */\n+  bool m_released;\n   /* Main summary store, where summary ID is used as key.  */\n   hash_map <map_hash, T *> m_map;\n   /* Internal summary insertion hook pointer.  */\n@@ -213,10 +217,6 @@ class GTY((user)) function_summary <T *>\n   cgraph_node_hook_list *m_symtab_removal_hook;\n   /* Internal summary duplication hook pointer.  */\n   cgraph_2node_hook_list *m_symtab_duplication_hook;\n-  /* Indicates if insertion hook is enabled.  */\n-  bool m_insertion_enabled;\n-  /* Indicates if the summary is released.  */\n-  bool m_released;\n   /* Symbol table the summary is registered to.  */\n   symbol_table *m_symtab;\n "}, {"sha": "1b9950eca8ee9ffebe91da58c2529abb09c9f5c5", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=34e8234204cb51e65f0e4b325634208a227cc8f3", "patch": "@@ -474,12 +474,12 @@ struct partition\n   bitmap stmts;\n   bitmap loops;\n   bool reduction_p;\n+  bool plus_one;\n   enum partition_kind kind;\n   /* data-references a kind != PKIND_NORMAL partition is about.  */\n   data_reference_p main_dr;\n   data_reference_p secondary_dr;\n   tree niter;\n-  bool plus_one;\n };\n \n "}, {"sha": "197847796eb72d94f503da909cc7c2e252b5aee3", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=34e8234204cb51e65f0e4b325634208a227cc8f3", "patch": "@@ -36,9 +36,9 @@ along with GCC; see the file COPYING3.  If not see\n struct object_size_info\n {\n   int object_size_type;\n-  bitmap visited, reexamine;\n-  int pass;\n+  unsigned char pass;\n   bool changed;\n+  bitmap visited, reexamine;\n   unsigned int *depths;\n   unsigned int *stack, *tos;\n };"}, {"sha": "8dc658812f248178c45cd1b4e270401a7e2caead", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=34e8234204cb51e65f0e4b325634208a227cc8f3", "patch": "@@ -346,12 +346,12 @@ struct cost_pair\n {\n   struct iv_cand *cand;\t/* The candidate.  */\n   comp_cost cost;\t/* The cost.  */\n+  enum tree_code comp;\t/* For iv elimination, the comparison.  */\n   bitmap depends_on;\t/* The list of invariants that have to be\n \t\t\t   preserved.  */\n   tree value;\t\t/* For final value elimination, the expression for\n \t\t\t   the final value of the iv.  For iv elimination,\n \t\t\t   the new bound to compare with.  */\n-  enum tree_code comp;\t/* For iv elimination, the comparison.  */\n   iv_inv_expr_ent *inv_expr; /* Loop invariant expression.  */\n };\n "}, {"sha": "e30ddd821ed6fa864a058278326f5f9d01d906ff", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=34e8234204cb51e65f0e4b325634208a227cc8f3", "patch": "@@ -235,12 +235,12 @@ struct ssa_local_info_t\n      and sharing a template for that block is considerably more difficult.  */\n   basic_block template_block;\n \n-  /* TRUE if we thread one or more jumps, FALSE otherwise.  */\n-  bool jumps_threaded;\n-\n   /* Blocks duplicated for the thread.  */\n   bitmap duplicate_blocks;\n \n+  /* TRUE if we thread one or more jumps, FALSE otherwise.  */\n+  bool jumps_threaded;\n+\n   /* When we have multiple paths through a joiner which reach different\n      final destinations, then we may need to correct for potential\n      profile insanities.  */"}, {"sha": "29164d1b53b7d415591f7f6447b52ae9c9d7f491", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=34e8234204cb51e65f0e4b325634208a227cc8f3", "patch": "@@ -1137,8 +1137,8 @@ vect_get_data_access_cost (struct data_reference *dr,\n \n typedef struct _vect_peel_info\n {\n-  int npeel;\n   struct data_reference *dr;\n+  int npeel;\n   unsigned int count;\n } *vect_peel_info;\n "}, {"sha": "e254aa0e49f2d8cd05213dbba9d52c83808803b6", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=34e8234204cb51e65f0e4b325634208a227cc8f3", "patch": "@@ -129,8 +129,8 @@ typedef struct _slp_oprnd_info\n   /* Information about the first statement, its vector def-type, type, the\n      operand itself in case it's constant, and an indication if it's a pattern\n      stmt.  */\n-  enum vect_def_type first_dt;\n   tree first_op_type;\n+  enum vect_def_type first_dt;\n   bool first_pattern;\n   bool second_pattern;\n } *slp_oprnd_info;"}, {"sha": "bfb7185f5e0eb7333e1a6cb74e2f5eb95b5f4f8e", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=34e8234204cb51e65f0e4b325634208a227cc8f3", "patch": "@@ -3074,8 +3074,8 @@ struct simd_call_arg_info\n {\n   tree vectype;\n   tree op;\n-  enum vect_def_type dt;\n   HOST_WIDE_INT linear_step;\n+  enum vect_def_type dt;\n   unsigned int align;\n   bool simd_lane_linear;\n };"}, {"sha": "12bb904abee5c0811576ad808bee451c6463a7fd", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e8234204cb51e65f0e4b325634208a227cc8f3/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=34e8234204cb51e65f0e4b325634208a227cc8f3", "patch": "@@ -240,9 +240,6 @@ typedef struct _loop_vec_info : public vec_info {\n      PARAM_MIN_VECT_LOOP_BOUND.  */\n   unsigned int th;\n \n-  /* Is the loop vectorizable? */\n-  bool vectorizable;\n-\n   /* Unrolling factor  */\n   int vectorization_factor;\n \n@@ -277,10 +274,6 @@ typedef struct _loop_vec_info : public vec_info {\n      runtime (loop versioning) misalignment check.  */\n   vec<gimple *> may_misalign_stmts;\n \n-  /* The unrolling factor needed to SLP the loop. In case of that pure SLP is\n-     applied to the loop, i.e., no unrolling is needed, this is 1.  */\n-  unsigned slp_unrolling_factor;\n-\n   /* Reduction cycles detected in the loop. Used in loop-aware SLP.  */\n   vec<gimple *> reductions;\n \n@@ -291,9 +284,16 @@ typedef struct _loop_vec_info : public vec_info {\n   /* Cost vector for a single scalar iteration.  */\n   vec<stmt_info_for_cost> scalar_cost_vec;\n \n+  /* The unrolling factor needed to SLP the loop. In case of that pure SLP is\n+     applied to the loop, i.e., no unrolling is needed, this is 1.  */\n+  unsigned slp_unrolling_factor;\n+\n   /* Cost of a single scalar iteration.  */\n   int single_scalar_iteration_cost;\n \n+  /* Is the loop vectorizable? */\n+  bool vectorizable;\n+\n   /* When we have grouped data accesses with gaps, we may introduce invalid\n      memory accesses.  We peel the last iteration of the loop to prevent\n      this.  */\n@@ -328,13 +328,13 @@ typedef struct _loop_vec_info : public vec_info {\n      vectorize this, so this field would be false.  */\n   bool no_data_dependencies;\n \n+  /* Mark loops having masked stores.  */\n+  bool has_mask_store;\n+\n   /* If if-conversion versioned this loop before conversion, this is the\n      loop version without if-conversion.  */\n   struct loop *scalar_loop;\n \n-  /* Mark loops having masked stores.  */\n-  bool has_mask_store;\n-\n   /* For loops being epilogues of already vectorized loops\n      this points to the original vectorized loop.  Otherwise NULL.  */\n   _loop_vec_info *orig_loop_info;\n@@ -555,6 +555,10 @@ typedef struct _stmt_vec_info {\n   /* Stmt is part of some pattern (computation idiom)  */\n   bool in_pattern_p;\n \n+  /* Is this statement vectorizable or should it be skipped in (partial)\n+     vectorization.  */\n+  bool vectorizable;\n+\n   /* The stmt to which this info struct refers to.  */\n   gimple *stmt;\n \n@@ -648,23 +652,19 @@ typedef struct _stmt_vec_info {\n      indicates whether the stmt needs to be vectorized.  */\n   enum vect_relevant relevant;\n \n-  /* Is this statement vectorizable or should it be skipped in (partial)\n-     vectorization.  */\n-  bool vectorizable;\n-\n   /* For loads if this is a gather, for stores if this is a scatter.  */\n   bool gather_scatter_p;\n \n   /* True if this is an access with loop-invariant stride.  */\n   bool strided_p;\n \n+  /* For both loads and stores.  */\n+  bool simd_lane_access_p;\n+\n   /* Classifies how the load or store is going to be implemented\n      for loop vectorization.  */\n   vect_memory_access_type memory_access_type;\n \n-  /* For both loads and stores.  */\n-  bool simd_lane_access_p;\n-\n   /* For reduction loops, this is the type of reduction.  */\n   enum vect_reduction_type v_reduc_type;\n "}]}