{"sha": "e191e5aeccd561c334dd5893a9db5e33b8333814", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE5MWU1YWVjY2Q1NjFjMzM0ZGQ1ODkzYTlkYjVlMzNiODMzMzgxNA==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2014-07-18T09:39:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-18T09:39:09Z"}, "message": "freeze.adb (Check_Component_Storage_Order): Fix enforcement of nesting rules for composites with different SSOs.\n\n2014-07-18  Thomas Quinot  <quinot@adacore.com>\n\n\t* freeze.adb (Check_Component_Storage_Order): Fix enforcement\n\tof nesting rules for composites with different SSOs.\n\n2014-07-18  Thomas Quinot  <quinot@adacore.com>\n\n\t* par_sco.adb (Is_Logical_Operator): An If_Expression is not\n\ta proper logical operator.\n\t(Has_Decision): An If_Expression indicates the presence of a decision\n\talthough it is not a logical operator.\n\nFrom-SVN: r212793", "tree": {"sha": "043b7e25fcb9978f88516a350571ec4b665f9ec1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/043b7e25fcb9978f88516a350571ec4b665f9ec1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e191e5aeccd561c334dd5893a9db5e33b8333814", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e191e5aeccd561c334dd5893a9db5e33b8333814", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e191e5aeccd561c334dd5893a9db5e33b8333814", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e191e5aeccd561c334dd5893a9db5e33b8333814/comments", "author": null, "committer": null, "parents": [{"sha": "783d035ba7b56cde1b862ee9f276a3af1e35a1d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/783d035ba7b56cde1b862ee9f276a3af1e35a1d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/783d035ba7b56cde1b862ee9f276a3af1e35a1d1"}], "stats": {"total": 79, "additions": 63, "deletions": 16}, "files": [{"sha": "5e3b31e1d21c792cd51d8c9d18ef3cacb3526a6f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e191e5aeccd561c334dd5893a9db5e33b8333814/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e191e5aeccd561c334dd5893a9db5e33b8333814/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e191e5aeccd561c334dd5893a9db5e33b8333814", "patch": "@@ -1,3 +1,15 @@\n+2014-07-18  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* freeze.adb (Check_Component_Storage_Order): Fix enforcement\n+\tof nesting rules for composites with different SSOs.\n+\n+2014-07-18  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* par_sco.adb (Is_Logical_Operator): An If_Expression is not\n+\ta proper logical operator.\n+\t(Has_Decision): An If_Expression indicates the presence of a decision\n+\talthough it is not a logical operator.\n+\n 2014-07-18  Robert Dewar  <dewar@adacore.com>\n \n \t* gnat_ugn.texi: Remove note that -gnatR not allowed with -gnatc."}, {"sha": "ab0334e6b87a778fed1687a1aa2e0a1fa2139cdb", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e191e5aeccd561c334dd5893a9db5e33b8333814/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e191e5aeccd561c334dd5893a9db5e33b8333814/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=e191e5aeccd561c334dd5893a9db5e33b8333814", "patch": "@@ -1086,7 +1086,7 @@ package body Freeze is\n       Err_Node  : Node_Id;\n \n       Comp_Byte_Aligned : Boolean;\n-      --  Set True for the record case, when Comp starts on a byte boundary\n+      --  Set for the record case, True if Comp starts on a byte boundary\n       --  (in which case it is allowed to have different storage order).\n \n       Comp_SSO_Differs  : Boolean;\n@@ -1095,6 +1095,20 @@ package body Freeze is\n \n       Component_Aliased : Boolean;\n \n+      function Is_Packed_Array (T : Entity_Id) return Boolean;\n+      --  True for a packed array type\n+\n+      ---------------------\n+      -- Is_Packed_Array --\n+      ---------------------\n+\n+      function Is_Packed_Array (T : Entity_Id) return Boolean is\n+      begin\n+         return Is_Array_Type (T) and then Is_Packed (T);\n+      end Is_Packed_Array;\n+\n+   --  Start of processing for Check_Component_Storage_Order\n+\n    begin\n       --  Record case\n \n@@ -1107,10 +1121,18 @@ package body Freeze is\n             Component_Aliased := False;\n \n          else\n-            Comp_Byte_Aligned :=\n-              Present (Component_Clause (Comp))\n-                and then\n-                  Normalized_First_Bit (Comp) mod System_Storage_Unit = 0;\n+            --  If a component clause is present, check whether component\n+            --  starts on a storage element boundary. Otherwise conservatively\n+            --  assume it does so only in the case where the record is not\n+            --  packed.\n+\n+            if Present (Component_Clause (Comp)) then\n+               Comp_Byte_Aligned :=\n+                 Normalized_First_Bit (Comp) mod System_Storage_Unit = 0;\n+            else\n+               Comp_Byte_Aligned := not Is_Packed (Encl_Type);\n+            end if;\n+\n             Component_Aliased := Is_Aliased (Comp);\n          end if;\n \n@@ -1120,7 +1142,6 @@ package body Freeze is\n          Err_Node  := Encl_Type;\n          Comp_Type := Component_Type (Encl_Type);\n \n-         Comp_Byte_Aligned := False;\n          Component_Aliased := Has_Aliased_Components (Encl_Type);\n       end if;\n \n@@ -1167,14 +1188,23 @@ package body Freeze is\n             --  Reject if component is a packed array, as it may be represented\n             --  as a scalar internally.\n \n-            if Is_Packed (Comp_Type) then\n+            if Is_Packed_Array (Comp_Type) then\n                Error_Msg_N\n                  (\"type of packed component must have same scalar \"\n                   & \"storage order as enclosing composite\", Err_Node);\n \n+            --  Reject if composite is a packed array, as it may be rewritten\n+            --  into an array of scalars.\n+\n+            elsif Is_Packed_Array (Encl_Type) then\n+               Error_Msg_N (\"type of packed array must have same scalar \"\n+                  & \"storage order as component\", Err_Node);\n+\n             --  Reject if not byte aligned\n \n-            elsif not Comp_Byte_Aligned then\n+            elsif Is_Record_Type (Encl_Type)\n+                    and then not Comp_Byte_Aligned\n+            then\n                Error_Msg_N\n                  (\"type of non-byte-aligned component must have same scalar \"\n                   & \"storage order as enclosing composite\", Err_Node);"}, {"sha": "215a81a9116d3bc9cca712ef079d675c8becb2cf", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e191e5aeccd561c334dd5893a9db5e33b8333814/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e191e5aeccd561c334dd5893a9db5e33b8333814/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=e191e5aeccd561c334dd5893a9db5e33b8333814", "patch": "@@ -100,10 +100,10 @@ package body Par_SCO is\n    --  contains a logical operator in its subtree).\n \n    function Is_Logical_Operator (N : Node_Id) return Boolean;\n-   --  N is the node for a subexpression. This procedure just tests N to see\n-   --  if it is a logical operator (including short circuit conditions, but\n-   --  excluding OR and AND) and returns True if so. It also returns True for\n-   --  an if expression. False in all other cases, no other processing is done.\n+   --  N is the node for a subexpression. This procedure determines whether N\n+   --  a logical operator (including short circuit conditions, but excluding\n+   --  OR and AND) and returns True if so. Note that in cases where True is\n+   --  returned, callers assume Nkind (N) in N_Op.\n \n    function To_Source_Location (S : Source_Ptr) return Source_Location;\n    --  Converts Source_Ptr value to Source_Location (line/col) format\n@@ -307,14 +307,17 @@ package body Par_SCO is\n    function Has_Decision (N : Node_Id) return Boolean is\n \n       function Check_Node (N : Node_Id) return Traverse_Result;\n+      --  Determine if Nkind (N) indicates the presence of a decision (i.e.\n+      --  N is a logical operator -- a decision in itelsf -- or an\n+      --  IF-expression -- whose Condition attribute is a decision).\n \n       ----------------\n       -- Check_Node --\n       ----------------\n \n       function Check_Node (N : Node_Id) return Traverse_Result is\n       begin\n-         if Is_Logical_Operator (N) then\n+         if Is_Logical_Operator (N) or else Nkind (N) = N_If_Expression then\n             return Abandon;\n          else\n             return OK;\n@@ -346,7 +349,8 @@ package body Par_SCO is\n    begin\n       SCO_Unit_Number_Table.Init;\n \n-      --  Set dummy 0'th entry in place for sort\n+      --  The SCO_Unit_Number_Table entry with index 0 is intentionally set\n+      --  aside to be used as temporary for sorting.\n \n       SCO_Unit_Number_Table.Increment_Last;\n    end Initialize;\n@@ -357,7 +361,7 @@ package body Par_SCO is\n \n    function Is_Logical_Operator (N : Node_Id) return Boolean is\n    begin\n-      return Nkind_In (N, N_Op_Not, N_And_Then, N_Or_Else, N_If_Expression);\n+      return Nkind_In (N, N_Op_Not, N_And_Then, N_Or_Else);\n    end Is_Logical_Operator;\n \n    -----------------------\n@@ -456,7 +460,8 @@ package body Par_SCO is\n \n                if Nkind_In (N, N_Op_Or, N_Or_Else) then\n                   C := '|';\n-               else\n+\n+               else pragma Assert (Nkind_In (N, N_Op_And, N_And_Then));\n                   C := '&';\n                end if;\n             end if;"}]}