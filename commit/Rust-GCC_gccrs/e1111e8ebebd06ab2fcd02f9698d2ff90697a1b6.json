{"sha": "e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTExMTFlOGViZWJkMDZhYjJmY2QwMmY5Njk4ZDJmZjkwNjk3YTFiNg==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2005-12-18T09:26:53Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2005-12-18T09:26:53Z"}, "message": "tree-tailcall.c (find_tail_calls): Use XNEW.\n\n        * tree-tailcall.c (find_tail_calls): Use XNEW.\n        * tree-ssa-dom.c (allocate_edge_info): Use XCNEW.\n        (free_all_edge_infos): Use explicit cast to convert from void\n        * *.\n        (vrp_free): Likewise.\n        (dom_opt_finalize_block): Likewise.\n        (record_equivalences_from_incoming_edge): Likewise.\n        (thread_across_edge): Likewise.  Use XCNEWVEC.\n        (record_cond): Use XCNEW.\n        (record_conditions): Use XNEWVEC.\n        (record_edge_info): Use XCNEWVEC.\n        (lookup_avail_expr): Use XNEW.\n        (record_range): Likewise.  Use GGC_NEW.\n        * tree-nested.c (var_map_hash): Use explicit cast to convert\n        * from\n        void *.\n        (var_map_eq): Likewise.\n        (lookup_field_for_decl): Likewise.\n        (convert_nonlocal_reference): Likewise.\n        (convert_local_reference): Likewise.\n        (convert_nl_goto_reference): Likewise.\n        (convert_nl_goto_receiver): Likewise.\n        (convert_call_expr): Likewise.\n        (convert_tramp_reference): Likewise.\n        (lookup_tramp_for_decl): Likewise.Use GGC_NEW.\n        (convert_nl_goto_reference): Likewise.\n        (lookup_field_for_decl): Use GGC_NEW.\n        (create_nesting_tree): Use GGC_CNEW.\n        * tree-ssa-phiopt.c (blocks_in_phiopt_order): Use XNEWVEC.\n        * tree-ssa-alias.c (init_alias_info): Use XCNEW.\n        (create_alias_map_for): Likewise.\n        (setup_pointers_and_addressables): Use XCNEWVEC.\n        (get_ptr_info): Use GGC_NEW.\n        (used_part_map_eq): Use explicit cast to convert from void *.\n        (up_lookup): Likewise.\n        (up_insert): Use XNEW.\n        (get_or_create_used_part_for): Use XCNEW.\n        (get_tmt_for): Likewise.\n        * tree-ssa-operands.c (ssa_operand_alloc): Use GGC_NEW.\n        * tree-ssa-pre.c (phi_trans_add): Use XNEW.\n        (bitmap_set_new): Use explicit cast to convert from void *.\n        (set_new): Likewise.\n        (insert_into_set): Likewise.\n        (pool_copy_list): Likewise.\n        (phi_translate): Likewise.\n        (create_value_expr_from): Likewise.\n        (insert_aux): Use XCNEWVEC.\n        (compute_avail): Use XNEWVEC.\n        * tree-ssa-live.c (calculate_live_on_entry): Likewise.\n        (sort_coalesce_list): Likewise.\n        (build_tree_conflict_graph): Use XCNEWVEC.\n        * tree-ssa-dce.c (tree_dce_init): Use XNEWVEC.\n        * tree-ssa-copy.c (init_copy_prop): Likewise.\n        (fini_copy_prop): Likewise.\n        * tree-ssa-uncprop.c (associate_equivalences_with_edges): Use\n        * XNEW\n        and XCNEWVEC.\n        (record_equiv): Use XNEW.\n        (uncprop_into_successor_phis): Use explicit cast to convert\n        * from\n        void *.\n        (uncprop_initialize_block): Likewise.\n\nFrom-SVN: r108747", "tree": {"sha": "b0e3f4d4a33eade27493478449c582c899ee90e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0e3f4d4a33eade27493478449c582c899ee90e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a1bdf726b709f7f6b70f391680a050f32b6e47ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1bdf726b709f7f6b70f391680a050f32b6e47ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1bdf726b709f7f6b70f391680a050f32b6e47ff"}], "stats": {"total": 238, "additions": 149, "deletions": 89}, "files": [{"sha": "119d50fff16217a1e9cfe33aa556020681472215", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6", "patch": "@@ -1,3 +1,64 @@\n+2005-12-17  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* tree-tailcall.c (find_tail_calls): Use XNEW.\n+\t* tree-ssa-dom.c (allocate_edge_info): Use XCNEW.\n+\t(free_all_edge_infos): Use explicit cast to convert from void *.\n+\t(vrp_free): Likewise.\n+\t(dom_opt_finalize_block): Likewise.\n+\t(record_equivalences_from_incoming_edge): Likewise.\n+\t(thread_across_edge): Likewise.  Use XCNEWVEC.\n+\t(record_cond): Use XCNEW.\n+\t(record_conditions): Use XNEWVEC.\n+\t(record_edge_info): Use XCNEWVEC.\n+\t(lookup_avail_expr): Use XNEW.\n+\t(record_range): Likewise.  Use GGC_NEW.\n+\t* tree-nested.c (var_map_hash): Use explicit cast to convert from\n+\tvoid *.\n+\t(var_map_eq): Likewise.\n+\t(lookup_field_for_decl): Likewise.\n+\t(convert_nonlocal_reference): Likewise.\n+\t(convert_local_reference): Likewise.\n+\t(convert_nl_goto_reference): Likewise.\n+\t(convert_nl_goto_receiver): Likewise.\n+\t(convert_call_expr): Likewise.\n+\t(convert_tramp_reference): Likewise.\n+\t(lookup_tramp_for_decl): Likewise.Use GGC_NEW.\n+\t(convert_nl_goto_reference): Likewise.\n+\t(lookup_field_for_decl): Use GGC_NEW.\n+\t(create_nesting_tree): Use GGC_CNEW.\n+\t* tree-ssa-phiopt.c (blocks_in_phiopt_order): Use XNEWVEC.\n+\t* tree-ssa-alias.c (init_alias_info): Use XCNEW.\n+\t(create_alias_map_for): Likewise.\n+\t(setup_pointers_and_addressables): Use XCNEWVEC.\n+\t(get_ptr_info): Use GGC_NEW.\n+\t(used_part_map_eq): Use explicit cast to convert from void *.\n+\t(up_lookup): Likewise.\n+\t(up_insert): Use XNEW.\n+\t(get_or_create_used_part_for): Use XCNEW.\n+\t(get_tmt_for): Likewise.\n+\t* tree-ssa-operands.c (ssa_operand_alloc): Use GGC_NEW.\n+\t* tree-ssa-pre.c (phi_trans_add): Use XNEW.\n+\t(bitmap_set_new): Use explicit cast to convert from void *.\n+\t(set_new): Likewise.\n+\t(insert_into_set): Likewise.\n+\t(pool_copy_list): Likewise.\n+\t(phi_translate): Likewise.\n+\t(create_value_expr_from): Likewise.\n+\t(insert_aux): Use XCNEWVEC.\n+\t(compute_avail): Use XNEWVEC.\n+\t* tree-ssa-live.c (calculate_live_on_entry): Likewise.\n+\t(sort_coalesce_list): Likewise.\n+\t(build_tree_conflict_graph): Use XCNEWVEC.\n+\t* tree-ssa-dce.c (tree_dce_init): Use XNEWVEC.\n+\t* tree-ssa-copy.c (init_copy_prop): Likewise.\n+\t(fini_copy_prop): Likewise.\n+\t* tree-ssa-uncprop.c (associate_equivalences_with_edges): Use XNEW\n+\tand XCNEWVEC.\n+\t(record_equiv): Use XNEW.\n+\t(uncprop_into_successor_phis): Use explicit cast to convert from\n+\tvoid *.\n+\t(uncprop_initialize_block): Likewise.\n+\n 2005-12-18  Dorit Nuzman  <dorit@il.ibm.com>\n \n \tPR tree-optimization/24378\t"}, {"sha": "d5309ec7a6ede30162d620ff125b18b2fb64eb00", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6", "patch": "@@ -108,15 +108,15 @@ struct nesting_info GTY ((chain_next (\"%h.next\")))\n static hashval_t\n var_map_hash (const void *x)\n {\n-  const struct var_map_elt *a = x;\n+  const struct var_map_elt *a = (const struct var_map_elt *) x;\n   return htab_hash_pointer (a->old);\n }\n \n static int\n var_map_eq (const void *x, const void *y)\n {\n-  const struct var_map_elt *a = x;\n-  const struct var_map_elt *b = y;\n+  const struct var_map_elt *a = (const struct var_map_elt *) x;\n+  const struct var_map_elt *b = (const struct var_map_elt *) y;\n   return a->old == b->old;\n }\n \n@@ -270,7 +270,7 @@ lookup_field_for_decl (struct nesting_info *info, tree decl,\n       gcc_assert (insert != INSERT);\n       return NULL;\n     }\n-  elt = *slot;\n+  elt = (struct var_map_elt *) *slot;\n \n   if (!elt && insert == INSERT)\n     {\n@@ -296,7 +296,7 @@ lookup_field_for_decl (struct nesting_info *info, tree decl,\n \n       insert_field_into_struct (get_frame_type (info), field);\n   \n-      elt = ggc_alloc (sizeof (*elt));\n+      elt = GGC_NEW (struct var_map_elt);\n       elt->old = decl;\n       elt->new = field;\n       *slot = elt;\n@@ -471,7 +471,7 @@ lookup_tramp_for_decl (struct nesting_info *info, tree decl,\n       gcc_assert (insert != INSERT);\n       return NULL;\n     }\n-  elt = *slot;\n+  elt = (struct var_map_elt *) *slot;\n \n   if (!elt && insert == INSERT)\n     {\n@@ -482,7 +482,7 @@ lookup_tramp_for_decl (struct nesting_info *info, tree decl,\n \n       insert_field_into_struct (get_frame_type (info), field);\n \n-      elt = ggc_alloc (sizeof (*elt));\n+      elt = GGC_NEW (struct var_map_elt);\n       elt->old = decl;\n       elt->new = field;\n       *slot = elt;\n@@ -706,7 +706,7 @@ check_for_nested_with_variably_modified (tree fndecl, tree orig_fndecl)\n static struct nesting_info *\n create_nesting_tree (struct cgraph_node *cgn)\n {\n-  struct nesting_info *info = ggc_calloc (1, sizeof (*info));\n+  struct nesting_info *info = GGC_CNEW (struct nesting_info);\n   info->var_map = htab_create_ggc (7, var_map_hash, var_map_eq, ggc_free);\n   info->context = cgn->decl;\n \n@@ -805,7 +805,7 @@ get_frame_field (struct nesting_info *info, tree target_context,\n static tree\n convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n {\n-  struct walk_stmt_info *wi = data;\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n   struct nesting_info *info = wi->info;\n   tree t = *tp;\n \n@@ -955,7 +955,7 @@ convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n static tree\n convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n {\n-  struct walk_stmt_info *wi = data;\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n   struct nesting_info *info = wi->info;\n   tree t = *tp, field, x;\n   bool save_val_only;\n@@ -1086,7 +1086,7 @@ convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n static tree\n convert_nl_goto_reference (tree *tp, int *walk_subtrees, void *data)\n {\n-  struct walk_stmt_info *wi = data;\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n   struct nesting_info *info = wi->info, *i;\n   tree t = *tp, label, new_label, target_context, x, arg, field;\n   struct var_map_elt *elt, dummy;\n@@ -1114,13 +1114,13 @@ convert_nl_goto_reference (tree *tp, int *walk_subtrees, void *data)\n      can insert the new label into the IL during a second pass.  */\n   dummy.old = label;\n   slot = htab_find_slot (i->var_map, &dummy, INSERT);\n-  elt = *slot;\n+  elt = (struct var_map_elt *) *slot;\n   if (elt == NULL)\n     {\n       new_label = create_artificial_label ();\n       DECL_NONLOCAL (new_label) = 1;\n \n-      elt = ggc_alloc (sizeof (*elt));\n+      elt = GGC_NEW (struct var_map_elt); \n       elt->old = label;\n       elt->new = new_label;\n       *slot = elt;\n@@ -1154,7 +1154,7 @@ convert_nl_goto_reference (tree *tp, int *walk_subtrees, void *data)\n static tree\n convert_nl_goto_receiver (tree *tp, int *walk_subtrees, void *data)\n {\n-  struct walk_stmt_info *wi = data;\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n   struct nesting_info *info = wi->info;\n   tree t = *tp, label, new_label, x;\n   struct var_map_elt *elt, dummy;\n@@ -1166,7 +1166,7 @@ convert_nl_goto_receiver (tree *tp, int *walk_subtrees, void *data)\n   label = LABEL_EXPR_LABEL (t);\n \n   dummy.old = label;\n-  elt = htab_find (info->var_map, &dummy);\n+  elt = (struct var_map_elt *) htab_find (info->var_map, &dummy);\n   if (!elt)\n     return NULL_TREE;\n   new_label = elt->new;\n@@ -1193,7 +1193,7 @@ convert_nl_goto_receiver (tree *tp, int *walk_subtrees, void *data)\n static tree\n convert_tramp_reference (tree *tp, int *walk_subtrees, void *data)\n {\n-  struct walk_stmt_info *wi = data;\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n   struct nesting_info *info = wi->info, *i;\n   tree t = *tp, decl, target_context, x, arg;\n \n@@ -1268,7 +1268,7 @@ convert_tramp_reference (tree *tp, int *walk_subtrees, void *data)\n static tree\n convert_call_expr (tree *tp, int *walk_subtrees, void *data)\n {\n-  struct walk_stmt_info *wi = data;\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n   struct nesting_info *info = wi->info;\n   tree t = *tp, decl, target_context;\n "}, {"sha": "76ede7744450259d595c20159aeb2790f95142c3", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6", "patch": "@@ -455,7 +455,7 @@ init_alias_info (void)\n   tree var;\n \n   bitmap_obstack_initialize (&alias_obstack);\n-  ai = xcalloc (1, sizeof (struct alias_info));\n+  ai = XCNEW (struct alias_info);\n   ai->ssa_names_visited = sbitmap_alloc (num_ssa_names);\n   sbitmap_zero (ai->ssa_names_visited);\n   VARRAY_TREE_INIT (ai->processed_ptrs, 50, \"processed_ptrs\");\n@@ -1148,7 +1148,7 @@ static void\n create_alias_map_for (tree var, struct alias_info *ai)\n {\n   struct alias_map_d *alias_map;\n-  alias_map = xcalloc (1, sizeof (*alias_map));\n+  alias_map = XCNEW (struct alias_map_d);\n   alias_map->var = var;\n   alias_map->set = get_alias_set (var);\n   ai->addressable_vars[ai->num_addressable_vars++] = alias_map;\n@@ -1194,9 +1194,8 @@ setup_pointers_and_addressables (struct alias_info *ai)\n      because some TREE_ADDRESSABLE variables will be marked\n      non-addressable below and only pointers with unique type tags are\n      going to be added to POINTERS.  */\n-  ai->addressable_vars = xcalloc (num_addressable_vars,\n-\t\t\t\t  sizeof (struct alias_map_d *));\n-  ai->pointers = xcalloc (num_pointers, sizeof (struct alias_map_d *));\n+  ai->addressable_vars = XCNEWVEC (struct alias_map_d *, num_addressable_vars);\n+  ai->pointers = XCNEWVEC (struct alias_map_d *, num_pointers);\n   ai->num_addressable_vars = 0;\n   ai->num_pointers = 0;\n \n@@ -1857,7 +1856,7 @@ get_tmt_for (tree ptr, struct alias_info *ai)\n       /* Add PTR to the POINTERS array.  Note that we are not interested in\n \t PTR's alias set.  Instead, we cache the alias set for the memory that\n \t PTR points to.  */\n-      alias_map = xcalloc (1, sizeof (*alias_map));\n+      alias_map = XCNEW (struct alias_map_d);\n       alias_map->var = ptr;\n       alias_map->set = tag_set;\n       ai->pointers[ai->num_pointers++] = alias_map;\n@@ -2019,7 +2018,7 @@ get_ptr_info (tree t)\n   pi = SSA_NAME_PTR_INFO (t);\n   if (pi == NULL)\n     {\n-      pi = ggc_alloc (sizeof (*pi));\n+      pi = GGC_NEW (struct ptr_info_def);\n       memset ((void *)pi, 0, sizeof (*pi));\n       SSA_NAME_PTR_INFO (t) = pi;\n     }\n@@ -2439,7 +2438,8 @@ struct used_part_map\n static int\n used_part_map_eq (const void *va, const void *vb)\n {\n-  const struct used_part_map  *a = va, *b = vb;\n+  const struct used_part_map *a = (const struct used_part_map *) va;\n+  const struct used_part_map *b = (const struct used_part_map *) vb;\n   return (a->uid == b->uid);\n }\n \n@@ -2467,7 +2467,7 @@ up_lookup (unsigned int uid)\n {\n   struct used_part_map *h, in;\n   in.uid = uid;\n-  h = htab_find_with_hash (used_portions, &in, uid);\n+  h = (struct used_part_map *) htab_find_with_hash (used_portions, &in, uid);\n   if (!h)\n     return NULL;\n   return h->to;\n@@ -2481,7 +2481,7 @@ up_insert (unsigned int uid, used_part_t to)\n   struct used_part_map *h;\n   void **loc;\n \n-  h = xmalloc (sizeof (struct used_part_map));\n+  h = XNEW (struct used_part_map);\n   h->uid = uid;\n   h->to = to;\n   loc = htab_find_slot_with_hash (used_portions, h,\n@@ -2501,7 +2501,7 @@ get_or_create_used_part_for (size_t uid)\n   used_part_t up;\n   if ((up = up_lookup (uid)) == NULL)\n     {\n-      up = xcalloc (1, sizeof (struct used_part));\n+      up = XCNEW (struct used_part);\n       up->minused = INT_MAX;\n       up->maxused = 0;\n       up->explicit_uses = false;\n@@ -2643,7 +2643,7 @@ create_overlap_variables_for (tree var)\n \t\t  && fosize == lastfosize\n \t\t  && currfotype == lastfotype))\n \t    continue;\n-\t  sv = ggc_alloc (sizeof (struct subvar));\n+\t  sv = GGC_NEW (struct subvar);\n \t  sv->offset = fo->offset;\n \t  sv->size = fosize;\n \t  sv->next = *subvars;"}, {"sha": "84f3cd1b248e5deea44f44ecbd1a2e53940fa741", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6", "patch": "@@ -847,10 +847,10 @@ init_copy_prop (bool phis_only)\n {\n   basic_block bb;\n \n-  copy_of = xmalloc (num_ssa_names * sizeof (*copy_of));\n+  copy_of = XNEWVEC (prop_value_t, num_ssa_names);\n   memset (copy_of, 0, num_ssa_names * sizeof (*copy_of));\n \n-  cached_last_copy_of = xmalloc (num_ssa_names * sizeof (*cached_last_copy_of));\n+  cached_last_copy_of = XNEWVEC (tree, num_ssa_names);\n   memset (cached_last_copy_of, 0, num_ssa_names * sizeof (*cached_last_copy_of));\n \n   FOR_EACH_BB (bb)\n@@ -902,7 +902,7 @@ fini_copy_prop (void)\n   \n   /* Set the final copy-of value for each variable by traversing the\n      copy-of chains.  */\n-  tmp = xmalloc (num_ssa_names * sizeof (*tmp));\n+  tmp = XNEWVEC (prop_value_t, num_ssa_names);\n   memset (tmp, 0, num_ssa_names * sizeof (*tmp));\n   for (i = 1; i < num_ssa_names; i++)\n     {"}, {"sha": "a5e612fff43ba0d80890b78bcdd92cf668c358ba", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6", "patch": "@@ -837,8 +837,7 @@ tree_dce_init (bool aggressive)\n     {\n       int i;\n \n-      control_dependence_map \n-\t= xmalloc (last_basic_block * sizeof (bitmap));\n+      control_dependence_map = XNEWVEC (bitmap, last_basic_block);\n       for (i = 0; i < last_basic_block; ++i)\n \tcontrol_dependence_map[i] = BITMAP_ALLOC (NULL);\n "}, {"sha": "a7203301d57d8efbda082da89a2333e49fbe194b", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6", "patch": "@@ -315,7 +315,7 @@ allocate_edge_info (edge e)\n {\n   struct edge_info *edge_info;\n \n-  edge_info = xcalloc (1, sizeof (struct edge_info));\n+  edge_info = XCNEW (struct edge_info);\n \n   e->aux = edge_info;\n   return edge_info;\n@@ -338,7 +338,7 @@ free_all_edge_infos (void)\n     {\n       FOR_EACH_EDGE (e, ei, bb->preds)\n         {\n-\t struct edge_info *edge_info = e->aux;\n+\t struct edge_info *edge_info = (struct edge_info *) e->aux;\n \n \t  if (edge_info)\n \t    {\n@@ -356,7 +356,7 @@ free_all_edge_infos (void)\n static void\n vrp_free (void *data)\n {\n-  struct vrp_hash_elt *elt = data;\n+  struct vrp_hash_elt *elt = (struct vrp_hash_elt *) data;\n   struct VEC(vrp_element_p,heap) **vrp_elt = &elt->records;\n \n   VEC_free (vrp_element_p, heap, *vrp_elt);\n@@ -770,7 +770,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t  unsigned int num, i = 0;\n \n \t  num = NUM_SSA_OPERANDS (stmt, (SSA_OP_USE | SSA_OP_VUSE));\n-\t  copy = xcalloc (num, sizeof (tree));\n+\t  copy = XCNEWVEC (tree, num);\n \n \t  /* Make a copy of the uses & vuses into USES_COPY, then cprop into\n \t     the operands.  */\n@@ -877,7 +877,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \n \t  /* Stuff the operator and operands into our dummy conditional\n \t     expression, creating the dummy conditional if necessary.  */\n-\t  dummy_cond = walk_data->global_data;\n+\t  dummy_cond = (tree) walk_data->global_data;\n \t  if (! dummy_cond)\n \t    {\n \t      dummy_cond = build2 (cond_code, boolean_type_node, op0, op1);\n@@ -934,7 +934,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t      struct edge_info *edge_info;\n \n \t      if (e->aux)\n-\t\tedge_info = e->aux;\n+\t\tedge_info = (struct edge_info *) e->aux;\n \t      else\n \t\tedge_info = allocate_edge_info (e);\n \t      edge_info->redirection_target = taken_edge;\n@@ -1119,7 +1119,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t  VEC_safe_push (tree, heap, avail_exprs_stack, NULL_TREE);\n \t  VEC_safe_push (tree, heap, const_and_copies_stack, NULL_TREE);\n \n-\t  edge_info = true_edge->aux;\n+\t  edge_info = (struct edge_info *) true_edge->aux;\n \n \t  /* If we have info associated with this edge, record it into\n \t     our equivalency tables.  */\n@@ -1160,7 +1160,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t  struct edge_info *edge_info;\n \t  unsigned int i;\n \n-\t  edge_info = false_edge->aux;\n+\t  edge_info = (struct edge_info *) false_edge->aux;\n \n \t  /* If we have info associated with this edge, record it into\n \t     our equivalency tables.  */\n@@ -1377,7 +1377,7 @@ record_equivalences_from_incoming_edge (basic_block bb)\n     {\n       unsigned int i;\n \n-      edge_info = e->aux;\n+      edge_info = (struct edge_info *) e->aux;\n \n       if (edge_info)\n \t{\n@@ -1496,7 +1496,7 @@ record_var_is_nonzero (tree var)\n static void\n record_cond (tree cond, tree value)\n {\n-  struct expr_hash_elt *element = xmalloc (sizeof (struct expr_hash_elt));\n+  struct expr_hash_elt *element = XCNEW (struct expr_hash_elt);\n   void **slot;\n \n   initialize_hash_element (cond, value, element);\n@@ -1546,7 +1546,7 @@ record_conditions (struct edge_info *edge_info, tree cond, tree inverted)\n     case LT_EXPR:\n     case GT_EXPR:\n       edge_info->max_cond_equivalences = 12;\n-      edge_info->cond_equivalences = xmalloc (12 * sizeof (tree));\n+      edge_info->cond_equivalences = XNEWVEC (tree, 12);\n       build_and_record_new_cond ((TREE_CODE (cond) == LT_EXPR\n \t\t\t\t  ? LE_EXPR : GE_EXPR),\n \t\t\t\t op0, op1, &edge_info->cond_equivalences[4]);\n@@ -1561,14 +1561,14 @@ record_conditions (struct edge_info *edge_info, tree cond, tree inverted)\n     case GE_EXPR:\n     case LE_EXPR:\n       edge_info->max_cond_equivalences = 6;\n-      edge_info->cond_equivalences = xmalloc (6 * sizeof (tree));\n+      edge_info->cond_equivalences = XNEWVEC (tree, 6);\n       build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n \t\t\t\t &edge_info->cond_equivalences[4]);\n       break;\n \n     case EQ_EXPR:\n       edge_info->max_cond_equivalences = 10;\n-      edge_info->cond_equivalences = xmalloc (10 * sizeof (tree));\n+      edge_info->cond_equivalences = XNEWVEC (tree, 10);\n       build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n \t\t\t\t &edge_info->cond_equivalences[4]);\n       build_and_record_new_cond (LE_EXPR, op0, op1,\n@@ -1579,7 +1579,7 @@ record_conditions (struct edge_info *edge_info, tree cond, tree inverted)\n \n     case UNORDERED_EXPR:\n       edge_info->max_cond_equivalences = 16;\n-      edge_info->cond_equivalences = xmalloc (16 * sizeof (tree));\n+      edge_info->cond_equivalences = XNEWVEC (tree, 16);\n       build_and_record_new_cond (NE_EXPR, op0, op1,\n \t\t\t\t &edge_info->cond_equivalences[4]);\n       build_and_record_new_cond (UNLE_EXPR, op0, op1,\n@@ -1597,7 +1597,7 @@ record_conditions (struct edge_info *edge_info, tree cond, tree inverted)\n     case UNLT_EXPR:\n     case UNGT_EXPR:\n       edge_info->max_cond_equivalences = 8;\n-      edge_info->cond_equivalences = xmalloc (8 * sizeof (tree));\n+      edge_info->cond_equivalences = XNEWVEC (tree, 8);\n       build_and_record_new_cond ((TREE_CODE (cond) == UNLT_EXPR\n \t\t\t\t  ? UNLE_EXPR : UNGE_EXPR),\n \t\t\t\t op0, op1, &edge_info->cond_equivalences[4]);\n@@ -1607,7 +1607,7 @@ record_conditions (struct edge_info *edge_info, tree cond, tree inverted)\n \n     case UNEQ_EXPR:\n       edge_info->max_cond_equivalences = 8;\n-      edge_info->cond_equivalences = xmalloc (8 * sizeof (tree));\n+      edge_info->cond_equivalences = XNEWVEC (tree, 8);\n       build_and_record_new_cond (UNLE_EXPR, op0, op1,\n \t\t\t\t &edge_info->cond_equivalences[4]);\n       build_and_record_new_cond (UNGE_EXPR, op0, op1,\n@@ -1616,7 +1616,7 @@ record_conditions (struct edge_info *edge_info, tree cond, tree inverted)\n \n     case LTGT_EXPR:\n       edge_info->max_cond_equivalences = 8;\n-      edge_info->cond_equivalences = xmalloc (8 * sizeof (tree));\n+      edge_info->cond_equivalences = XNEWVEC (tree, 8);\n       build_and_record_new_cond (NE_EXPR, op0, op1,\n \t\t\t\t &edge_info->cond_equivalences[4]);\n       build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n@@ -1625,7 +1625,7 @@ record_conditions (struct edge_info *edge_info, tree cond, tree inverted)\n \n     default:\n       edge_info->max_cond_equivalences = 4;\n-      edge_info->cond_equivalences = xmalloc (4 * sizeof (tree));\n+      edge_info->cond_equivalences = XNEWVEC (tree, 4);\n       break;\n     }\n \n@@ -2201,7 +2201,7 @@ record_edge_info (basic_block bb)\n \t    {\n \t      tree labels = SWITCH_LABELS (stmt);\n \t      int i, n_labels = TREE_VEC_LENGTH (labels);\n-\t      tree *info = xcalloc (last_basic_block, sizeof (tree));\n+\t      tree *info = XCNEWVEC (tree, last_basic_block);\n \t      edge e;\n \t      edge_iterator ei;\n \n@@ -2891,7 +2891,7 @@ lookup_avail_expr (tree stmt, bool insert)\n   void **slot;\n   tree lhs;\n   tree temp;\n-  struct expr_hash_elt *element = xmalloc (sizeof (struct expr_hash_elt));\n+  struct expr_hash_elt *element = XNEW (struct expr_hash_elt);\n \n   lhs = TREE_CODE (stmt) == MODIFY_EXPR ? TREE_OPERAND (stmt, 0) : NULL;\n \n@@ -3062,7 +3062,7 @@ record_range (tree cond, basic_block bb)\n       void **slot;\n \n \n-      vrp_hash_elt = xmalloc (sizeof (struct vrp_hash_elt));\n+      vrp_hash_elt = XNEW (struct vrp_hash_elt);\n       vrp_hash_elt->var = TREE_OPERAND (cond, 0);\n       vrp_hash_elt->records = NULL;\n       slot = htab_find_slot (vrp_data, vrp_hash_elt, INSERT);\n@@ -3075,7 +3075,7 @@ record_range (tree cond, basic_block bb)\n       vrp_hash_elt = (struct vrp_hash_elt *) *slot;\n       vrp_records_p = &vrp_hash_elt->records;\n \n-      element = ggc_alloc (sizeof (struct vrp_element));\n+      element = GGC_NEW (struct vrp_element);\n       element->low = NULL;\n       element->high = NULL;\n       element->cond = cond;"}, {"sha": "8c02a2b4b6618a32d1ef422b5cfddd9f9d0b0cd7", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6", "patch": "@@ -639,7 +639,7 @@ calculate_live_on_entry (var_map map)\n \t}\n     }\n \n-  stack = xmalloc (sizeof (int) * last_basic_block);\n+  stack = XNEWVEC (int, last_basic_block);\n   EXECUTE_IF_SET_IN_BITMAP (live->global, 0, i, bi)\n     {\n       live_worklist (live, stack, i);\n@@ -1224,7 +1224,7 @@ sort_coalesce_list (coalesce_list_p cl)\n   /* Only call qsort if there are more than 2 items.  */\n   if (num > 2)\n     {\n-      list = xmalloc (sizeof (partition_pair_p) * num);\n+      list = XNEWVEC (partition_pair_p, num);\n       count = 0;\n       for (p = chain; p != NULL; p = p->next)\n \tlist[count++] = p;\n@@ -1345,8 +1345,8 @@ build_tree_conflict_graph (tree_live_info_p liveinfo, tpa_p tpa,\n \n   live = BITMAP_ALLOC (NULL);\n \n-  partition_link = xcalloc (num_var_partitions (map) + 1, sizeof (int));\n-  tpa_nodes = xcalloc (tpa_num_trees (tpa), sizeof (int));\n+  partition_link = XCNEWVEC (int, num_var_partitions (map) + 1);\n+  tpa_nodes = XCNEWVEC (int, tpa_num_trees (tpa));\n   tpa_to_clear = VEC_alloc (int, heap, 50);\n \n   FOR_EACH_BB (bb)"}, {"sha": "41046c78f8515b6b2708bcd24bcf55a6c21eaca1", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6", "patch": "@@ -279,7 +279,7 @@ ssa_operand_alloc (unsigned size)\n   if (operand_memory_index + size >= SSA_OPERAND_MEMORY_SIZE)\n     {\n       struct ssa_operand_memory_d *ptr;\n-      ptr = ggc_alloc (sizeof (struct ssa_operand_memory_d));\n+      ptr = GGC_NEW (struct ssa_operand_memory_d);\n       ptr->next = operand_memory;\n       operand_memory = ptr;\n       operand_memory_index = 0;"}, {"sha": "5aba683bf065e4b35105dac8efd57eed262c35a3", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6", "patch": "@@ -247,7 +247,7 @@ static basic_block *\n blocks_in_phiopt_order (void)\n {\n   basic_block x, y;\n-  basic_block *order = xmalloc (sizeof (basic_block) * n_basic_blocks);\n+  basic_block *order = XNEWVEC (basic_block, n_basic_blocks);\n   unsigned n = n_basic_blocks - NUM_FIXED_BLOCKS; \n   unsigned np, i;\n   sbitmap visited = sbitmap_alloc (last_basic_block); "}, {"sha": "08964004d0aa8fe37c005014817b55dd56bd20fb", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6", "patch": "@@ -401,7 +401,7 @@ static inline void\n phi_trans_add (tree e, tree v, basic_block pred)\n {\n   void **slot;\n-  expr_pred_trans_t new_pair = xmalloc (sizeof (*new_pair));\n+  expr_pred_trans_t new_pair = XNEW (struct expr_pred_trans_d);\n   new_pair->e = e;\n   new_pair->pred = pred;\n   new_pair->v = v;\n@@ -476,7 +476,7 @@ value_insert_into_set_bitmap (value_set_t set, tree v)\n static bitmap_set_t \n bitmap_set_new (void)\n {\n-  bitmap_set_t ret = pool_alloc (bitmap_set_pool);\n+  bitmap_set_t ret = (bitmap_set_t) pool_alloc (bitmap_set_pool);\n   ret->expressions = BITMAP_ALLOC (&grand_bitmap_obstack);\n   ret->values = BITMAP_ALLOC (&grand_bitmap_obstack);\n   return ret;\n@@ -488,7 +488,7 @@ static value_set_t\n set_new  (bool indexed)\n {\n   value_set_t ret;\n-  ret = pool_alloc (value_set_pool);\n+  ret = (value_set_t) pool_alloc (value_set_pool);\n   ret->head = ret->tail = NULL;\n   ret->length = 0;\n   ret->indexed = indexed;\n@@ -519,7 +519,7 @@ bitmap_insert_into_set (bitmap_set_t set, tree expr)\n static void\n insert_into_set (value_set_t set, tree expr)\n {\n-  value_set_node_t newnode = pool_alloc (value_set_node_pool);\n+  value_set_node_t newnode = (value_set_node_t) pool_alloc (value_set_node_pool);\n   tree val = get_value_handle (expr);\n   gcc_assert (val);\n   \n@@ -920,15 +920,15 @@ pool_copy_list (tree list)\n \n   if (list == 0)\n     return 0;\n-  head = pool_alloc (list_node_pool);\n+  head = (tree) pool_alloc (list_node_pool);\n   \n   memcpy (head, list, tree_size (list));\n   prev = head;\n   \n   next = TREE_CHAIN (list);\n   while (next)\n     {\n-      TREE_CHAIN (prev) = pool_alloc (list_node_pool);\n+      TREE_CHAIN (prev) = (tree) pool_alloc (list_node_pool);\n       memcpy (TREE_CHAIN (prev), next, tree_size (next));\n       prev = TREE_CHAIN (prev);\n       next = TREE_CHAIN (next);\n@@ -1030,7 +1030,7 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t    \n \t    if (listchanged || (newop0 != oldop0) || (oldop2 != newop2))\n \t      {\n-\t\tnewexpr = pool_alloc (expression_node_pool);\n+\t\tnewexpr = (tree) pool_alloc (expression_node_pool);\n \t\tmemcpy (newexpr, expr, tree_size (expr));\n \t\tTREE_OPERAND (newexpr, 0) = newop0 == oldop0 ? oldop0 : get_value_handle (newop0);\n \t\tTREE_OPERAND (newexpr, 1) = listchanged ? newarglist : oldarglist;\n@@ -1068,7 +1068,7 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \tif (newop1 != oldop1 || newop2 != oldop2)\n \t  {\n \t    tree t;\n-\t    newexpr = pool_alloc (binary_node_pool);\n+\t    newexpr = (tree) pool_alloc (binary_node_pool);\n \t    memcpy (newexpr, expr, tree_size (expr));\n \t    TREE_OPERAND (newexpr, 0) = newop1 == oldop1 ? oldop1 : get_value_handle (newop1);\n \t    TREE_OPERAND (newexpr, 1) = newop2 == oldop2 ? oldop2 : get_value_handle (newop2);\n@@ -1102,7 +1102,7 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \tif (newop1 != oldop1)\n \t  {\n \t    tree t;\n-\t    newexpr = pool_alloc (unary_node_pool);\n+\t    newexpr = (tree) pool_alloc (unary_node_pool);\n \t    memcpy (newexpr, expr, tree_size (expr));\n \t    TREE_OPERAND (newexpr, 0) = get_value_handle (newop1);\n \t    t = fully_constant_expression (newexpr);\n@@ -1868,7 +1868,7 @@ insert_aux (basic_block block)\n \t\t\t  continue;\n \t\t\t}\n \t\t\t\t\t      \n-\t\t      avail = xcalloc (last_basic_block, sizeof (tree));\n+\t\t      avail = XCNEWVEC (tree, last_basic_block);\n \t\t      FOR_EACH_EDGE (pred, ei, block->preds)\n \t\t\t{\n \t\t\t  tree vprime;\n@@ -2072,7 +2072,7 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n       pool = expression_node_pool;\n     }\n \n-  vexpr = pool_alloc (pool);\n+  vexpr = (tree) pool_alloc (pool);\n   memcpy (vexpr, expr, tree_size (expr));\n   \n   /* This case is only for TREE_LIST's that appear as part of\n@@ -2365,7 +2365,7 @@ compute_avail (void)\n     }\n \n   /* Allocate the worklist.  */\n-  worklist = xmalloc (sizeof (basic_block) * n_basic_blocks);\n+  worklist = XNEWVEC (basic_block, n_basic_blocks);\n \n   /* Seed the algorithm by putting the dominator children of the entry\n      block on the worklist.  */"}, {"sha": "c79b120ce3dc9098c250339813f8a64b98b84b20", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6", "patch": "@@ -95,12 +95,12 @@ associate_equivalences_with_edges (void)\n \t  if (TREE_CODE (cond) == SSA_NAME\n \t      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (cond))\n \t    {\n-\t      equivalency = xmalloc (sizeof (struct edge_equivalency));\n+\t      equivalency = XNEW (struct edge_equivalency);\n \t      equivalency->rhs = constant_boolean_node (1, TREE_TYPE (cond));\n \t      equivalency->lhs = cond;\n \t      true_edge->aux = equivalency;\n \n-\t      equivalency = xmalloc (sizeof (struct edge_equivalency));\n+\t      equivalency = XNEW (struct edge_equivalency);\n \t      equivalency->rhs = constant_boolean_node (0, TREE_TYPE (cond));\n \t      equivalency->lhs = cond;\n \t      false_edge->aux = equivalency;\n@@ -121,14 +121,14 @@ associate_equivalences_with_edges (void)\n \t\t{\n \t\t  if (TREE_CODE (cond) == EQ_EXPR)\n \t\t    {\n-\t\t      equivalency = xmalloc (sizeof (struct edge_equivalency));\n+\t\t      equivalency = XNEW (struct edge_equivalency);\n \t\t      equivalency->lhs = op0;\n \t\t      equivalency->rhs = (integer_zerop (op1)\n \t\t\t\t\t  ? boolean_false_node\n \t\t\t\t\t  : boolean_true_node);\n \t\t      true_edge->aux = equivalency;\n \n-\t\t      equivalency = xmalloc (sizeof (struct edge_equivalency));\n+\t\t      equivalency = XNEW (struct edge_equivalency);\n \t\t      equivalency->lhs = op0;\n \t\t      equivalency->rhs = (integer_zerop (op1)\n \t\t\t\t\t  ? boolean_true_node\n@@ -137,14 +137,14 @@ associate_equivalences_with_edges (void)\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      equivalency = xmalloc (sizeof (struct edge_equivalency));\n+\t\t      equivalency = XNEW (struct edge_equivalency);\n \t\t      equivalency->lhs = op0;\n \t\t      equivalency->rhs = (integer_zerop (op1)\n \t\t\t\t\t  ? boolean_true_node\n \t\t\t\t\t  : boolean_false_node);\n \t\t      true_edge->aux = equivalency;\n \n-\t\t      equivalency = xmalloc (sizeof (struct edge_equivalency));\n+\t\t      equivalency = XNEW (struct edge_equivalency);\n \t\t      equivalency->lhs = op0;\n \t\t      equivalency->rhs = (integer_zerop (op1)\n \t\t\t\t\t  ? boolean_false_node\n@@ -168,7 +168,7 @@ associate_equivalences_with_edges (void)\n \t\t\t  || REAL_VALUES_EQUAL (dconst0, TREE_REAL_CST (op1))))\n \t\t    continue;\n \n-\t\t  equivalency = xmalloc (sizeof (struct edge_equivalency));\n+\t\t  equivalency = XNEW (struct edge_equivalency);\n \t\t  equivalency->lhs = op0;\n \t\t  equivalency->rhs = op1;\n \t\t  if (TREE_CODE (cond) == EQ_EXPR)\n@@ -194,7 +194,7 @@ associate_equivalences_with_edges (void)\n \t    {\n \t      tree labels = SWITCH_LABELS (stmt);\n \t      int i, n_labels = TREE_VEC_LENGTH (labels);\n-\t      tree *info = xcalloc (n_basic_blocks, sizeof (tree));\n+\t      tree *info = XCNEWVEC (tree, n_basic_blocks);\n \n \t      /* Walk over the case label vector.  Record blocks\n \t\t which are reached by a single case label which represents\n@@ -227,7 +227,7 @@ associate_equivalences_with_edges (void)\n \n \t\t      /* Record an equivalency on the edge from BB to basic\n \t\t\t block I.  */\n-\t\t      equivalency = xmalloc (sizeof (struct edge_equivalency));\n+\t\t      equivalency = XNEW (struct edge_equivalency);\n \t\t      equivalency->rhs = x;\n \t\t      equivalency->lhs = cond;\n \t\t      find_edge (bb, BASIC_BLOCK (i))->aux = equivalency;\n@@ -364,7 +364,7 @@ record_equiv (tree value, tree equivalence)\n   struct equiv_hash_elt *equiv_hash_elt;\n   void **slot;\n \n-  equiv_hash_elt = xmalloc (sizeof (struct equiv_hash_elt));\n+  equiv_hash_elt = XNEW (struct equiv_hash_elt);\n   equiv_hash_elt->value = value;\n   equiv_hash_elt->equivalences = NULL;\n \n@@ -486,7 +486,7 @@ uncprop_into_successor_phis (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n       /* Record any equivalency associated with E.  */\n       if (e->aux)\n \t{\n-\t  struct edge_equivalency *equiv = e->aux;\n+\t  struct edge_equivalency *equiv = (struct edge_equivalency *) e->aux;\n \t  record_equiv (equiv->rhs, equiv->lhs);\n \t}\n \n@@ -512,7 +512,7 @@ uncprop_into_successor_phis (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \n \t  if (slot)\n \t    {\n-\t      struct equiv_hash_elt *elt = *slot;\n+\t      struct equiv_hash_elt *elt = (struct equiv_hash_elt *) *slot;\n \t      int j;\n \n \t      /* Walk every equivalence with the same value.  If we find\n@@ -536,7 +536,7 @@ uncprop_into_successor_phis (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n       /* If we had an equivalence associated with this edge, remove it.  */\n       if (e->aux)\n \t{\n-\t  struct edge_equivalency *equiv = e->aux;\n+\t  struct edge_equivalency *equiv = (struct edge_equivalency *) e->aux;\n \t  remove_equivalence (equiv->rhs);\n \t}\n     }\n@@ -589,7 +589,7 @@ uncprop_initialize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \n       if (e && e->src == parent && e->aux)\n \t{\n-\t  struct edge_equivalency *equiv = e->aux;\n+\t  struct edge_equivalency *equiv = (struct edge_equivalency *) e->aux;\n \n \t  record_equiv (equiv->rhs, equiv->lhs);\n \t  VEC_safe_push (tree, heap, equiv_stack, equiv->rhs);"}, {"sha": "6778c9a816104ddd3dfa86ad7a87589f9566b29b", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=e1111e8ebebd06ab2fcd02f9698d2ff90697a1b6", "patch": "@@ -526,7 +526,7 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n   if (!tail_recursion && (m || a))\n     return;\n \n-  nw = xmalloc (sizeof (struct tailcall));\n+  nw = XNEW (struct tailcall);\n \n   nw->call_block = bb;\n   nw->call_bsi = bsi;"}]}