{"sha": "1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYzNGIxOGY3YmJmNDRiMTc4ZWU3NzBjOWNmZmRlZTVhZTA2ZmE0NA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-06-26T00:12:56Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-06-26T00:12:56Z"}, "message": "ra.h (add_neighbor): Fix -Wc++-compat and/or -Wcast-qual warnings.\n\n\t* ra.h (add_neighbor): Fix -Wc++-compat and/or -Wcast-qual\n\twarnings.\n\t* recog.c (check_asm_operands, validate_change_1): Likewise.\n\t* reg-stack.c (check_asm_stack_operands, subst_asm_stack_regs,\n\tsubst_asm_stack_regs): Likewise.\n\t* regclass.c (regclass, som_hash, som_eq, record_subregs_of_mode,\n\tcannot_change_mode_set_regs, invalid_mode_change_p): Likewise.\n\t* regmove.c (reg_is_remote_constant_p): Likewise.\n\t* regrename.c (regrename_optimize, scan_rtx_reg,\n\tkill_clobbered_value, kill_set_value, kill_autoinc_value):\n\tLikewise.\n\t* regstat.c (regstat_init_n_sets_and_refs, regstat_compute_ri,\n\tregstat_compute_calls_crossed): Likewise.\n\t* reload1.c (init_reload, new_insn_chain,\n\thas_nonexceptional_receiver, reload, copy_reloads,\n\tcalculate_needs_all_insns, init_elim_table): Likewise.\n\t* rtl-factoring.c (compute_rtx_cost, fill_hash_bucket): Likewise.\n\t* rtl.c (shallow_copy_rtx_stat): Likewise.\n\t* rtlanal.c (parms_set): Likewise.\n\t* sbitmap.c (sbitmap_alloc, sbitmap_alloc_with_popcount,\n\tsbitmap_resize, sbitmap_vector_alloc): Likewise.\n\t* sched-ebb.c (earliest_block_with_similiar_load,\n\tadd_deps_for_risky_insns): Likewise.\n\t* sched-rgn.c (find_rgns, gather_region_statistics, extend_rgns,\n\tschedule_region): Likewise.\n\t* see.c (eq_descriptor_pre_extension,\n\thash_descriptor_pre_extension, hash_del_pre_extension,\n\teq_descriptor_properties, hash_descriptor_properties,\n\thash_del_properties, see_seek_pre_extension_expr,\n\tsee_initialize_data_structures, see_print_register_properties,\n\tsee_print_pre_extension_expr, see_delete_merged_def_extension,\n\tsee_delete_unmerged_def_extension, see_emit_use_extension,\n\tsee_pre_delete_extension, see_map_extension, see_commit_changes,\n\tsee_analyze_merged_def_local_prop,\n\tsee_analyze_merged_def_local_prop,\n\tsee_analyze_unmerged_def_local_prop, see_analyze_use_local_prop,\n\tsee_set_prop_merged_def, see_set_prop_unmerged_def,\n\tsee_set_prop_unmerged_use, see_print_one_extension,\n\tsee_merge_one_use_extension, see_merge_one_def_extension,\n\tsee_store_reference_and_extension, see_update_uses_relevancy,\n\tsee_update_defs_relevancy): Likewise.\n\t* statistics.c (hash_statistics_hash, hash_statistics_eq,\n\thash_statistics_free, curr_statistics_hash): Likewise.\n\t* stmt.c (parse_output_constraint, decl_overlaps_hard_reg_set_p,\n\texpand_asm_operands, expand_return, case_bit_test_cmp,\n\texpand_case): Likewise.\n\t* stor-layout.c (start_record_layout): Likewise.\n\t* stringpool.c (ggc_alloc_string, gt_pch_n_S,\n\tgt_pch_save_stringpool): Likewise.\n\t* tree-data-ref.c (hash_stmt_vertex_info,\n\thave_similar_memory_accesses_1, ref_base_address_1): Likewise.\n\t* tree-ssa-phiopt.c (name_to_bb_hash): Likewise.\n\nFrom-SVN: r137128", "tree": {"sha": "1e79b077c85c12fc7ecd80c8be070e0eb0189618", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e79b077c85c12fc7ecd80c8be070e0eb0189618"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/comments", "author": null, "committer": null, "parents": [{"sha": "f0bbed4417c151731640d018d77aca2426688174", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0bbed4417c151731640d018d77aca2426688174", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0bbed4417c151731640d018d77aca2426688174"}], "stats": {"total": 327, "additions": 197, "deletions": 130}, "files": [{"sha": "96a896b5004bf5e9843956d15f3a5fcef89c5c28", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -1,3 +1,58 @@\n+2008-06-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* ra.h (add_neighbor): Fix -Wc++-compat and/or -Wcast-qual\n+\twarnings.\n+\t* recog.c (check_asm_operands, validate_change_1): Likewise.\n+\t* reg-stack.c (check_asm_stack_operands, subst_asm_stack_regs,\n+\tsubst_asm_stack_regs): Likewise.\n+\t* regclass.c (regclass, som_hash, som_eq, record_subregs_of_mode,\n+\tcannot_change_mode_set_regs, invalid_mode_change_p): Likewise.\n+\t* regmove.c (reg_is_remote_constant_p): Likewise.\n+\t* regrename.c (regrename_optimize, scan_rtx_reg,\n+\tkill_clobbered_value, kill_set_value, kill_autoinc_value):\n+\tLikewise.\n+\t* regstat.c (regstat_init_n_sets_and_refs, regstat_compute_ri,\n+\tregstat_compute_calls_crossed): Likewise.\n+\t* reload1.c (init_reload, new_insn_chain,\n+\thas_nonexceptional_receiver, reload, copy_reloads,\n+\tcalculate_needs_all_insns, init_elim_table): Likewise.\n+\t* rtl-factoring.c (compute_rtx_cost, fill_hash_bucket): Likewise.\n+\t* rtl.c (shallow_copy_rtx_stat): Likewise.\n+\t* rtlanal.c (parms_set): Likewise.\n+\t* sbitmap.c (sbitmap_alloc, sbitmap_alloc_with_popcount,\n+\tsbitmap_resize, sbitmap_vector_alloc): Likewise.\n+\t* sched-ebb.c (earliest_block_with_similiar_load,\n+\tadd_deps_for_risky_insns): Likewise.\n+\t* sched-rgn.c (find_rgns, gather_region_statistics, extend_rgns,\n+\tschedule_region): Likewise.\n+\t* see.c (eq_descriptor_pre_extension,\n+\thash_descriptor_pre_extension, hash_del_pre_extension,\n+\teq_descriptor_properties, hash_descriptor_properties,\n+\thash_del_properties, see_seek_pre_extension_expr,\n+\tsee_initialize_data_structures, see_print_register_properties,\n+\tsee_print_pre_extension_expr, see_delete_merged_def_extension,\n+\tsee_delete_unmerged_def_extension, see_emit_use_extension,\n+\tsee_pre_delete_extension, see_map_extension, see_commit_changes,\n+\tsee_analyze_merged_def_local_prop,\n+\tsee_analyze_merged_def_local_prop,\n+\tsee_analyze_unmerged_def_local_prop, see_analyze_use_local_prop,\n+\tsee_set_prop_merged_def, see_set_prop_unmerged_def,\n+\tsee_set_prop_unmerged_use, see_print_one_extension,\n+\tsee_merge_one_use_extension, see_merge_one_def_extension,\n+\tsee_store_reference_and_extension, see_update_uses_relevancy,\n+\tsee_update_defs_relevancy): Likewise.\n+\t* statistics.c (hash_statistics_hash, hash_statistics_eq,\n+\thash_statistics_free, curr_statistics_hash): Likewise.\n+\t* stmt.c (parse_output_constraint, decl_overlaps_hard_reg_set_p,\n+\texpand_asm_operands, expand_return, case_bit_test_cmp,\n+\texpand_case): Likewise.\n+\t* stor-layout.c (start_record_layout): Likewise.\n+\t* stringpool.c (ggc_alloc_string, gt_pch_n_S,\n+\tgt_pch_save_stringpool): Likewise.\n+\t* tree-data-ref.c (hash_stmt_vertex_info,\n+\thave_similar_memory_accesses_1, ref_base_address_1): Likewise.\n+\t* tree-ssa-phiopt.c (name_to_bb_hash): Likewise.\n+\n 2008-06-25 Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/36627"}, {"sha": "bd4195223943ef7b81cefc8e8e27f9dbd045b8a1", "filename": "gcc/ra.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fra.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fra.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.h?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -144,7 +144,7 @@ add_neighbor (int alloc_no, int neighbor)\n \n   if (adjlist == NULL || adjlist->index == ADJACENCY_VEC_LENGTH)\n     {\n-      adjacency_t *new = pool_alloc (adjacency_pool);\n+      adjacency_t *new = (adjacency_t *) pool_alloc (adjacency_pool);\n       new->index = 0;\n       new->next = adjlist;\n       adjlist = new;"}, {"sha": "a176ed30af68b70a46f340bda723c55a7c01a30a", "filename": "gcc/recog.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -145,8 +145,8 @@ check_asm_operands (rtx x)\n   if (noperands == 0)\n     return 1;\n \n-  operands = alloca (noperands * sizeof (rtx));\n-  constraints = alloca (noperands * sizeof (char *));\n+  operands = XALLOCAVEC (rtx, noperands);\n+  constraints = XALLOCAVEC (const char *, noperands);\n \n   decode_asm_operands (x, operands, NULL, constraints, NULL, NULL);\n \n@@ -221,7 +221,7 @@ validate_change_1 (rtx object, rtx *loc, rtx new, bool in_group, bool unshare)\n       else\n \tchanges_allocated *= 2;\n \n-      changes = xrealloc (changes, sizeof (change_t) * changes_allocated);\n+      changes = XRESIZEVEC (change_t, changes, changes_allocated);\n     }\n \n   changes[num_changes].object = object;"}, {"sha": "ffa06fd5752522f756a04beccaf39d3e2acc9e60", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -503,7 +503,7 @@ check_asm_stack_operands (rtx insn)\n \n   if (GET_CODE (body) == PARALLEL)\n     {\n-      clobber_reg = alloca (XVECLEN (body, 0) * sizeof (rtx));\n+      clobber_reg = XALLOCAVEC (rtx, XVECLEN (body, 0));\n \n       for (i = 0; i < XVECLEN (body, 0); i++)\n \tif (GET_CODE (XVECEXP (body, 0, i)) == CLOBBER)\n@@ -2012,9 +2012,9 @@ subst_asm_stack_regs (rtx insn, stack regstack)\n   for (i = 0, note = REG_NOTES (insn); note; note = XEXP (note, 1))\n     i++;\n \n-  note_reg = alloca (i * sizeof (rtx));\n-  note_loc = alloca (i * sizeof (rtx *));\n-  note_kind = alloca (i * sizeof (enum reg_note));\n+  note_reg = XALLOCAVEC (rtx, i);\n+  note_loc = XALLOCAVEC (rtx *, i);\n+  note_kind = XALLOCAVEC (enum reg_note, i);\n \n   n_notes = 0;\n   for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n@@ -2045,8 +2045,8 @@ subst_asm_stack_regs (rtx insn, stack regstack)\n \n   if (GET_CODE (body) == PARALLEL)\n     {\n-      clobber_reg = alloca (XVECLEN (body, 0) * sizeof (rtx));\n-      clobber_loc = alloca (XVECLEN (body, 0) * sizeof (rtx *));\n+      clobber_reg = XALLOCAVEC (rtx, XVECLEN (body, 0));\n+      clobber_loc = XALLOCAVEC (rtx *, XVECLEN (body, 0));\n \n       for (i = 0; i < XVECLEN (body, 0); i++)\n \tif (GET_CODE (XVECEXP (body, 0, i)) == CLOBBER)"}, {"sha": "dab3377976c599a380f729596db3153da25d6261", "filename": "gcc/regclass.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -1310,7 +1310,7 @@ regclass (rtx f, int nregs)\n \n   init_recog ();\n \n-  reg_renumber = xmalloc (max_regno * sizeof (short));\n+  reg_renumber = XNEWVEC (short, max_regno);\n   reg_pref = XCNEWVEC (struct reg_pref, max_regno);\n   memset (reg_renumber, -1, max_regno * sizeof (short));\n \n@@ -2500,15 +2500,18 @@ static htab_t subregs_of_mode;\n static hashval_t\n som_hash (const void *x)\n {\n-  const struct subregs_of_mode_node *a = x;\n+  const struct subregs_of_mode_node *const a =\n+    (const struct subregs_of_mode_node *) x;\n   return a->block;\n }\n \n static int\n som_eq (const void *x, const void *y)\n {\n-  const struct subregs_of_mode_node *a = x;\n-  const struct subregs_of_mode_node *b = y;\n+  const struct subregs_of_mode_node *const a =\n+    (const struct subregs_of_mode_node *) x;\n+  const struct subregs_of_mode_node *const b =\n+    (const struct subregs_of_mode_node *) y;\n   return a->block == b->block;\n }\n \n@@ -2533,7 +2536,7 @@ record_subregs_of_mode (rtx subreg)\n   dummy.block = regno & -8;\n   slot = htab_find_slot_with_hash (subregs_of_mode, &dummy,\n \t\t\t\t   dummy.block, INSERT);\n-  node = *slot;\n+  node = (struct subregs_of_mode_node *) *slot;\n   if (node == NULL)\n     {\n       node = XCNEW (struct subregs_of_mode_node);\n@@ -2605,7 +2608,8 @@ cannot_change_mode_set_regs (HARD_REG_SET *used, enum machine_mode from,\n \n   gcc_assert (subregs_of_mode);\n   dummy.block = regno & -8;\n-  node = htab_find_with_hash (subregs_of_mode, &dummy, dummy.block);\n+  node = (struct subregs_of_mode_node *)\n+    htab_find_with_hash (subregs_of_mode, &dummy, dummy.block);\n   if (node == NULL)\n     return;\n \n@@ -2632,7 +2636,8 @@ invalid_mode_change_p (unsigned int regno,\n \n   gcc_assert (subregs_of_mode);\n   dummy.block = regno & -8;\n-  node = htab_find_with_hash (subregs_of_mode, &dummy, dummy.block);\n+  node = (struct subregs_of_mode_node *)\n+    htab_find_with_hash (subregs_of_mode, &dummy, dummy.block);\n   if (node == NULL)\n     return false;\n "}, {"sha": "4a53defed242e5f1a0513f79ee8935cd223dcecf", "filename": "gcc/regmove.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -916,7 +916,7 @@ reg_is_remote_constant_p (rtx reg, rtx insn)\n   if (!reg_set_in_bb)\n     {\n       max_reg_computed = max = max_reg_num ();\n-      reg_set_in_bb = xcalloc (max, sizeof (*reg_set_in_bb));\n+      reg_set_in_bb = XCNEWVEC (basic_block, max);\n \n       FOR_EACH_BB (bb)\n \tFOR_BB_INSNS (bb, p)"}, {"sha": "220b22ab6da74accaa77f7093a258635d2a0b217", "filename": "gcc/regrename.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -189,7 +189,7 @@ regrename_optimize (void)\n   memset (tick, 0, sizeof tick);\n \n   gcc_obstack_init (&rename_obstack);\n-  first_obj = obstack_alloc (&rename_obstack, 0);\n+  first_obj = XOBNEWVAR (&rename_obstack, char, 0);\n \n   FOR_EACH_BB (bb)\n     {\n@@ -385,8 +385,7 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl,\n     {\n       if (type == OP_OUT)\n \t{\n-\t  struct du_chain *this\n-\t    = obstack_alloc (&rename_obstack, sizeof (struct du_chain));\n+\t  struct du_chain *this = XOBNEW (&rename_obstack, struct du_chain);\n \t  this->next_use = 0;\n \t  this->next_chain = open_chains;\n \t  this->loc = loc;\n@@ -438,7 +437,7 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl,\n \t\t be replaced with, terminate the chain.  */\n \t      if (cl != NO_REGS)\n \t\t{\n-\t\t  this = obstack_alloc (&rename_obstack, sizeof (struct du_chain));\n+\t\t  this = XOBNEW (&rename_obstack, struct du_chain);\n \t\t  this->next_use = 0;\n \t\t  this->next_chain = (*p)->next_chain;\n \t\t  this->loc = loc;\n@@ -1165,7 +1164,7 @@ init_value_data (struct value_data *vd)\n static void\n kill_clobbered_value (rtx x, const_rtx set, void *data)\n {\n-  struct value_data *vd = data;\n+  struct value_data *const vd = (struct value_data *) data;\n   if (GET_CODE (set) == CLOBBER)\n     kill_value (x, vd);\n }\n@@ -1176,7 +1175,7 @@ kill_clobbered_value (rtx x, const_rtx set, void *data)\n static void\n kill_set_value (rtx x, const_rtx set, void *data)\n {\n-  struct value_data *vd = data;\n+  struct value_data *const vd = (struct value_data *) data;\n   if (GET_CODE (set) != CLOBBER)\n     {\n       kill_value (x, vd);\n@@ -1193,7 +1192,7 @@ static int\n kill_autoinc_value (rtx *px, void *data)\n {\n   rtx x = *px;\n-  struct value_data *vd = data;\n+  struct value_data *const vd = (struct value_data *) data;\n \n   if (GET_RTX_CLASS (GET_CODE (x)) == RTX_AUTOINC)\n     {"}, {"sha": "2ec8c5bd7396c385997bcee8686f3403dfe759bb", "filename": "gcc/regstat.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fregstat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fregstat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregstat.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -60,7 +60,7 @@ regstat_init_n_sets_and_refs (void)\n   df_grow_reg_info ();\n   gcc_assert (!regstat_n_sets_and_refs);\n \n-  regstat_n_sets_and_refs = xmalloc (max_regno * sizeof (struct regstat_n_sets_and_refs_t));\n+  regstat_n_sets_and_refs = XNEWVEC (struct regstat_n_sets_and_refs_t, max_regno);\n \n   for (i = 0; i < max_regno; i++)\n     {\n@@ -344,7 +344,7 @@ regstat_compute_ri (void)\n   setjmp_crosses = BITMAP_ALLOC (&df_bitmap_obstack);\n   max_regno = max_reg_num ();\n   reg_info_p_size = max_regno;\n-  reg_info_p = xcalloc (max_regno, sizeof (struct reg_info_t));\n+  reg_info_p = XCNEWVEC (struct reg_info_t, max_regno);\n \n   FOR_EACH_BB (bb)\n     {\n@@ -488,7 +488,7 @@ regstat_compute_calls_crossed (void)\n   timevar_push (TV_REG_STATS);\n   max_regno = max_reg_num ();\n   reg_info_p_size = max_regno;\n-  reg_info_p = xcalloc (max_regno, sizeof (struct reg_info_t));\n+  reg_info_p = XCNEWVEC (struct reg_info_t, max_regno);\n \n   FOR_EACH_BB (bb)\n     {"}, {"sha": "b1e90884712ea2986cf72e74631cbb76928b9925", "filename": "gcc/reload1.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -498,7 +498,7 @@ init_reload (void)\n \n   /* Initialize obstack for our rtl allocation.  */\n   gcc_obstack_init (&reload_obstack);\n-  reload_startobj = obstack_alloc (&reload_obstack, 0);\n+  reload_startobj = XOBNEWVAR (&reload_obstack, char, 0);\n \n   INIT_REG_SET (&spilled_pseudos);\n   INIT_REG_SET (&pseudos_counted);\n@@ -515,7 +515,7 @@ new_insn_chain (void)\n \n   if (unused_insn_chains == 0)\n     {\n-      c = obstack_alloc (&reload_obstack, sizeof (struct insn_chain));\n+      c = XOBNEW (&reload_obstack, struct insn_chain);\n       INIT_REG_SET (&c->live_throughout);\n       INIT_REG_SET (&c->dead_or_set);\n     }\n@@ -633,7 +633,7 @@ has_nonexceptional_receiver (void)\n     return true;\n   \n   /* First determine which blocks can reach exit via normal paths.  */\n-  tos = worklist = xmalloc (sizeof (basic_block) * (n_basic_blocks + 1));\n+  tos = worklist = XNEWVEC (basic_block, n_basic_blocks + 1);\n \n   FOR_EACH_BB (bb)\n     bb->flags &= ~BB_REACHABLE;\n@@ -710,7 +710,7 @@ reload (rtx first, int global)\n \n   failure = 0;\n \n-  reload_firstobj = obstack_alloc (&reload_obstack, 0);\n+  reload_firstobj = XOBNEWVAR (&reload_obstack, char, 0);\n \n   /* Make sure that the last insn in the chain\n      is not something that needs reloading.  */\n@@ -1031,7 +1031,7 @@ reload (rtx first, int global)\n \t{\n \t  save_call_clobbered_regs ();\n \t  /* That might have allocated new insn_chain structures.  */\n-\t  reload_firstobj = obstack_alloc (&reload_obstack, 0);\n+\t  reload_firstobj = XOBNEWVAR (&reload_obstack, char, 0);\n \t}\n \n       calculate_needs_all_insns (global);\n@@ -1500,10 +1500,9 @@ static void\n copy_reloads (struct insn_chain *chain)\n {\n   chain->n_reloads = n_reloads;\n-  chain->rld = obstack_alloc (&reload_obstack,\n-\t\t\t      n_reloads * sizeof (struct reload));\n+  chain->rld = XOBNEWVEC (&reload_obstack, struct reload, n_reloads);\n   memcpy (chain->rld, rld, n_reloads * sizeof (struct reload));\n-  reload_insn_firstobj = obstack_alloc (&reload_obstack, 0);\n+  reload_insn_firstobj = XOBNEWVAR (&reload_obstack, char, 0);\n }\n \n /* Walk the chain of insns, and determine for each whether it needs reloads\n@@ -1517,7 +1516,7 @@ calculate_needs_all_insns (int global)\n \n   something_needs_elimination = 0;\n \n-  reload_insn_firstobj = obstack_alloc (&reload_obstack, 0);\n+  reload_insn_firstobj = XOBNEWVAR (&reload_obstack, char, 0);\n   for (chain = reload_insn_chain; chain != 0; chain = next)\n     {\n       rtx insn = chain->insn;\n@@ -3707,7 +3706,7 @@ init_elim_table (void)\n #endif\n \n   if (!reg_eliminate)\n-    reg_eliminate = xcalloc (sizeof (struct elim_table), NUM_ELIMINABLE_REGS);\n+    reg_eliminate = XCNEWVEC (struct elim_table, NUM_ELIMINABLE_REGS);\n \n   /* Does this function require a frame pointer?  */\n "}, {"sha": "07c66e20cc377133cf488e4fc1ba4bc21affc614", "filename": "gcc/rtl-factoring.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Frtl-factoring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Frtl-factoring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-factoring.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -323,14 +323,14 @@ compute_rtx_cost (rtx insn)\n   tmp_bucket.hash = compute_hash (insn);\n \n   /* Select the hash group.  */\n-  bucket = htab_find (hash_buckets, &tmp_bucket);\n+  bucket = (p_hash_bucket) htab_find (hash_buckets, &tmp_bucket);\n \n   if (bucket)\n   {\n     tmp_elem.insn = insn;\n \n     /* Select the insn.  */\n-    elem = htab_find (bucket->seq_candidates, &tmp_elem);\n+    elem = (p_hash_elem) htab_find (bucket->seq_candidates, &tmp_elem);\n \n     /* If INSN is parsed the cost will be the cached length.  */\n     if (elem)\n@@ -1319,7 +1319,7 @@ fill_hash_bucket (void)\n           tmp_bucket.hash = compute_hash (insn);\n \n           /* Select the hash group.  */\n-          bucket = htab_find (hash_buckets, &tmp_bucket);\n+          bucket = (p_hash_bucket) htab_find (hash_buckets, &tmp_bucket);\n \n           if (!bucket)\n             {"}, {"sha": "6d53a7800d1631065e794c74a985719d557262cf", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -323,7 +323,7 @@ shallow_copy_rtx_stat (const_rtx orig MEM_STAT_DECL)\n {\n   const unsigned int size = rtx_size (orig);\n   rtx const copy = (rtx) ggc_alloc_zone_pass_stat (size, &rtl_zone);\n-  return memcpy (copy, orig, size);\n+  return (rtx) memcpy (copy, orig, size);\n }\n \f\n /* Nonzero when we are generating CONCATs.  */"}, {"sha": "dec7daf0e3d55228a4dffeb9c31ec282a75f63dc", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -3266,7 +3266,7 @@ struct parms_set_data\n static void\n parms_set (rtx x, const_rtx pat ATTRIBUTE_UNUSED, void *data)\n {\n-  struct parms_set_data *d = data;\n+  struct parms_set_data *const d = (struct parms_set_data *) data;\n   if (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER\n       && TEST_HARD_REG_BIT (d->regs, REGNO (x)))\n     {"}, {"sha": "689cf97557668b26ac4062b45b9ae83976dd5e0e", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -79,7 +79,7 @@ sbitmap_alloc (unsigned int n_elms)\n   bytes = size * sizeof (SBITMAP_ELT_TYPE);\n   amt = (sizeof (struct simple_bitmap_def)\n \t + bytes - sizeof (SBITMAP_ELT_TYPE));\n-  bmap = xmalloc (amt);\n+  bmap = (sbitmap) xmalloc (amt);\n   bmap->n_bits = n_elms;\n   bmap->size = size;\n   bmap->popcount = NULL;\n@@ -92,7 +92,7 @@ sbitmap\n sbitmap_alloc_with_popcount (unsigned int n_elms)\n {\n   sbitmap const bmap = sbitmap_alloc (n_elms);  \n-  bmap->popcount = xmalloc (bmap->size * sizeof (unsigned char));\n+  bmap->popcount = XNEWVEC (unsigned char, bmap->size);\n   return bmap;\n }\n \n@@ -112,10 +112,9 @@ sbitmap_resize (sbitmap bmap, unsigned int n_elms, int def)\n     {\n       amt = (sizeof (struct simple_bitmap_def)\n \t    + bytes - sizeof (SBITMAP_ELT_TYPE));\n-      bmap = xrealloc (bmap, amt);\n+      bmap = (sbitmap) xrealloc (bmap, amt);\n       if (bmap->popcount)\n-\tbmap->popcount = xrealloc (bmap->popcount,\n-\t\t\t\t   size * sizeof (unsigned char));\n+\tbmap->popcount = XRESIZEVEC (unsigned char, bmap->popcount, size);\n     }\n \n   if (n_elms > bmap->n_bits)\n@@ -218,7 +217,7 @@ sbitmap_vector_alloc (unsigned int n_vecs, unsigned int n_elms)\n   }\n \n   amt = vector_bytes + (n_vecs * elm_bytes);\n-  bitmap_vector = xmalloc (amt);\n+  bitmap_vector = (sbitmap *) xmalloc (amt);\n \n   for (i = 0, offset = vector_bytes; i < n_vecs; i++, offset += elm_bytes)\n     {"}, {"sha": "58a89346cf0af9980b658347188c76f3b06cd370", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -335,7 +335,7 @@ earliest_block_with_similiar_load (basic_block last_block, rtx load_insn)\n \t\t    /* insn2 not guaranteed to be a 1 base reg load.  */\n \t\t    continue;\n \n-\t\t  for (bb = last_block; bb; bb = bb->aux)\n+\t\t  for (bb = last_block; bb; bb = (basic_block) bb->aux)\n \t\t    if (insn2_block == bb)\n \t\t      break;\n \n@@ -382,7 +382,7 @@ add_deps_for_risky_insns (rtx head, rtx tail)\n \t\tbb = earliest_block_with_similiar_load (last_block, insn);\n \t\tif (bb)\n \t\t  {\n-\t\t    bb = bb->aux;\n+\t\t    bb = (basic_block) bb->aux;\n \t\t    if (!bb)\n \t\t      break;\n \t\t    prev = BB_END (bb);\n@@ -436,7 +436,7 @@ add_deps_for_risky_insns (rtx head, rtx tail)\n   /* Maintain the invariant that bb->aux is clear after use.  */\n   while (last_block)\n     {\n-      bb = last_block->aux;\n+      bb = (basic_block) last_block->aux;\n       last_block->aux = NULL;\n       last_block = bb;\n     }"}, {"sha": "abb2c8d6f6cc923c0aa6f9186bec1d7f06fc96aa", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -700,7 +700,7 @@ find_rgns (void)\n       extend_regions_p = PARAM_VALUE (PARAM_MAX_SCHED_EXTEND_REGIONS_ITERS) > 0;\n       if (extend_regions_p)\n         {\n-          degree1 = xmalloc (last_basic_block * sizeof (int));\n+          degree1 = XNEWVEC (int, last_basic_block);\n           extended_rgn_header = sbitmap_alloc (last_basic_block);\n           sbitmap_zero (extended_rgn_header);\n \t}\n@@ -990,7 +990,7 @@ gather_region_statistics (int **rsp)\n \n       if (nr_blocks > a_sz)\n \t{\t \n-\t  a = xrealloc (a, nr_blocks * sizeof (*a));\n+\t  a = XRESIZEVEC (int, a, nr_blocks);\n \t  do\n \t    a[a_sz++] = 0;\n \t  while (a_sz != nr_blocks);\n@@ -1047,9 +1047,9 @@ extend_rgns (int *degree, int *idxp, sbitmap header, int *loop_hdr)\n \n   max_iter = PARAM_VALUE (PARAM_MAX_SCHED_EXTEND_REGIONS_ITERS);\n \n-  max_hdr = xmalloc (last_basic_block * sizeof (*max_hdr));\n+  max_hdr = XNEWVEC (int, last_basic_block);\n \n-  order = xmalloc (last_basic_block * sizeof (*order));\n+  order = XNEWVEC (int, last_basic_block);\n   post_order_compute (order, false, false);\n \n   for (i = nblocks - 1; i >= 0; i--)\n@@ -2685,7 +2685,7 @@ schedule_region (int rgn)\n   current_blocks = RGN_BLOCKS (rgn);\n   \n   /* See comments in add_block1, for what reasons we allocate +1 element.  */ \n-  ebb_head = xrealloc (ebb_head, (current_nr_blocks + 1) * sizeof (*ebb_head));\n+  ebb_head = XRESIZEVEC (int, ebb_head, current_nr_blocks + 1);\n   for (bb = 0; bb <= current_nr_blocks; bb++)\n     ebb_head[bb] = current_blocks + bb;\n "}, {"sha": "3dfaa41245f8c0eee3ab59d81a235a9045e02666", "filename": "gcc/see.c", "status": "modified", "additions": 53, "deletions": 42, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fsee.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fsee.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsee.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -807,8 +807,10 @@ see_gen_normalized_extension (rtx reg, enum rtx_code extension_code,\n static int\n eq_descriptor_pre_extension (const void *p1, const void *p2)\n {\n-  const struct see_pre_extension_expr *extension1 = p1;\n-  const struct see_pre_extension_expr *extension2 = p2;\n+  const struct see_pre_extension_expr *const extension1 =\n+    (const struct see_pre_extension_expr *) p1;\n+  const struct see_pre_extension_expr *const extension2 =\n+    (const struct see_pre_extension_expr *) p2;\n   rtx set1 = single_set (extension1->se_insn);\n   rtx set2 = single_set (extension2->se_insn);\n   rtx rhs1, rhs2;\n@@ -828,7 +830,8 @@ eq_descriptor_pre_extension (const void *p1, const void *p2)\n static hashval_t\n hash_descriptor_pre_extension (const void *p)\n {\n-  const struct see_pre_extension_expr *extension = p;\n+  const struct see_pre_extension_expr *const extension =\n+    (const struct see_pre_extension_expr *) p;\n   rtx set = single_set (extension->se_insn);\n   rtx rhs;\n \n@@ -846,7 +849,8 @@ hash_descriptor_pre_extension (const void *p)\n static void\n hash_del_pre_extension (void *p)\n {\n-  struct see_pre_extension_expr *extension = p;\n+  struct see_pre_extension_expr *const extension =\n+    (struct see_pre_extension_expr *) p;\n   struct see_occr *curr_occr = extension->antic_occr;\n   struct see_occr *next_occr = NULL;\n \n@@ -884,8 +888,10 @@ hash_del_pre_extension (void *p)\n static int\n eq_descriptor_properties (const void *p1, const void *p2)\n {\n-  const struct see_register_properties *curr_prop1 = p1;\n-  const struct see_register_properties *curr_prop2 = p2;\n+  const struct see_register_properties *const curr_prop1 =\n+    (const struct see_register_properties *) p1;\n+  const struct see_register_properties *const curr_prop2 =\n+    (const struct see_register_properties *) p2;\n \n   return curr_prop1->regno == curr_prop2->regno;\n }\n@@ -897,7 +903,8 @@ eq_descriptor_properties (const void *p1, const void *p2)\n static hashval_t\n hash_descriptor_properties (const void *p)\n {\n-  const struct see_register_properties *curr_prop = p;\n+  const struct see_register_properties *const curr_prop =\n+    (const struct see_register_properties *) p;\n   return curr_prop->regno;\n }\n \n@@ -906,7 +913,8 @@ hash_descriptor_properties (const void *p)\n static void\n hash_del_properties (void *p)\n {\n-  struct see_register_properties *curr_prop = p;\n+  struct see_register_properties *const curr_prop =\n+    (struct see_register_properties *) p;\n   free (curr_prop);\n }\n \n@@ -1031,7 +1039,7 @@ see_seek_pre_extension_expr (rtx extension, enum extension_type type)\n     /* This is the first time this extension instruction is encountered.  Store\n        it in the hash.  */\n     {\n-      (*slot_pre_exp) = xmalloc (sizeof (struct see_pre_extension_expr));\n+      (*slot_pre_exp) = XNEW (struct see_pre_extension_expr);\n       (*slot_pre_exp)->se_insn = extension;\n       (*slot_pre_exp)->bitmap_index =\n \t(htab_elements (see_pre_extension_hash) - 1);\n@@ -1352,16 +1360,16 @@ see_initialize_data_structures (void)\n     }\n \n   /*  Allocate web entries array for the union-find data structure.  */\n-  def_entry = xcalloc (defs_num, sizeof (struct web_entry));\n-  use_entry = xcalloc (uses_num, sizeof (struct web_entry));\n+  def_entry = XCNEWVEC (struct web_entry, defs_num);\n+  use_entry = XCNEWVEC (struct web_entry, uses_num);\n \n   /*  Allocate an array of splay trees.\n       One splay tree for each basic block.  */\n-  see_bb_splay_ar = xcalloc (last_bb, sizeof (splay_tree));\n+  see_bb_splay_ar = XCNEWVEC (splay_tree, last_bb);\n \n   /*  Allocate an array of hashes.\n       One hash for each basic block.  */\n-  see_bb_hash_ar = xcalloc (last_bb, sizeof (htab_t));\n+  see_bb_hash_ar = XCNEWVEC (htab_t, last_bb);\n \n   /*  Allocate the extension hash.  It will hold the extensions that we want\n       to PRE.  */\n@@ -1478,7 +1486,8 @@ see_want_to_be_merged_with_extension (rtx ref, rtx extension,\n static int\n see_print_register_properties (void **slot, void *b ATTRIBUTE_UNUSED)\n {\n-  struct see_register_properties *prop = *slot;\n+  const struct see_register_properties *const prop =\n+    (const struct see_register_properties *) *slot;\n \n   gcc_assert (prop);\n   fprintf (dump_file, \"Property found for register %d\\n\", prop->regno);\n@@ -1495,7 +1504,8 @@ see_print_register_properties (void **slot, void *b ATTRIBUTE_UNUSED)\n static int\n see_print_pre_extension_expr (void **slot, void *b ATTRIBUTE_UNUSED)\n {\n-  struct see_pre_extension_expr *pre_extension = *slot;\n+  const struct see_pre_extension_expr *const pre_extension =\n+    (const struct see_pre_extension_expr *) *slot;\n \n   gcc_assert (pre_extension\n   \t      && pre_extension->se_insn\n@@ -1520,7 +1530,7 @@ see_print_pre_extension_expr (void **slot, void *b ATTRIBUTE_UNUSED)\n static int\n see_delete_merged_def_extension (void **slot, void *b ATTRIBUTE_UNUSED)\n {\n-  rtx def_se = *slot;\n+  rtx def_se = (rtx) *slot;\n \n   if (dump_file)\n     {\n@@ -1548,7 +1558,7 @@ see_delete_merged_def_extension (void **slot, void *b ATTRIBUTE_UNUSED)\n static int\n see_delete_unmerged_def_extension (void **slot, void *b ATTRIBUTE_UNUSED)\n {\n-  rtx def_se = *slot;\n+  rtx def_se = (rtx) *slot;\n \n   if (dump_file)\n     {\n@@ -1571,7 +1581,7 @@ see_delete_unmerged_def_extension (void **slot, void *b ATTRIBUTE_UNUSED)\n static int\n see_emit_use_extension (void **slot, void *b)\n {\n-  rtx use_se = *slot;\n+  rtx use_se = (rtx) *slot;\n   struct see_ref_s *curr_ref_s = (struct see_ref_s *) b;\n \n   if (INSN_DELETED_P (use_se))\n@@ -1737,7 +1747,8 @@ see_pre_insert_extensions (struct see_pre_extension_expr **index_map)\n static int\n see_pre_delete_extension (void **slot, void *b ATTRIBUTE_UNUSED)\n {\n-  struct see_pre_extension_expr *expr = *slot;\n+  struct see_pre_extension_expr *const expr =\n+    (struct see_pre_extension_expr *) *slot;\n   struct see_occr *occr;\n   int indx = expr->bitmap_index;\n \n@@ -1768,8 +1779,9 @@ see_pre_delete_extension (void **slot, void *b ATTRIBUTE_UNUSED)\n static int\n see_map_extension (void **slot, void *b)\n {\n-  struct see_pre_extension_expr *expr = *slot;\n-  struct see_pre_extension_expr **index_map =\n+  struct see_pre_extension_expr *const expr =\n+    (struct see_pre_extension_expr *) *slot;\n+  struct see_pre_extension_expr **const index_map =\n     (struct see_pre_extension_expr **) b;\n \n   index_map[expr->bitmap_index] = expr;\n@@ -1792,8 +1804,7 @@ see_commit_changes (void)\n   bool did_insert = false;\n   int i;\n \n-  index_map = xcalloc (pre_extension_num,\n-  \t\t       sizeof (struct see_pre_extension_expr *));\n+  index_map = XCNEWVEC (struct see_pre_extension_expr *, pre_extension_num);\n \n   if (dump_file)\n     fprintf (dump_file,\n@@ -1842,7 +1853,7 @@ see_commit_changes (void)\n static int\n see_analyze_merged_def_local_prop (void **slot, void *b)\n {\n-  rtx def_se = *slot;\n+  rtx def_se = (rtx) *slot;\n   struct see_ref_s *curr_ref_s = (struct see_ref_s *) b;\n   rtx ref = curr_ref_s->insn;\n   struct see_pre_extension_expr *extension_expr;\n@@ -1880,7 +1891,7 @@ see_analyze_merged_def_local_prop (void **slot, void *b)\n       /* Set the available bit.  */\n       SET_BIT (comp[bb_num], indx);\n       /* Record the available occurrence.  */\n-      curr_occr = xmalloc (sizeof (struct see_occr));\n+      curr_occr = XNEW (struct see_occr);\n       curr_occr->next = NULL;\n       curr_occr->insn = def_se;\n       curr_occr->block_num = bb_num;\n@@ -1910,7 +1921,7 @@ see_analyze_merged_def_local_prop (void **slot, void *b)\n static int\n see_analyze_unmerged_def_local_prop (void **slot, void *b)\n {\n-  rtx def_se = *slot;\n+  rtx def_se = (rtx) *slot;\n   struct see_ref_s *curr_ref_s = (struct see_ref_s *) b;\n   rtx ref = curr_ref_s->insn;\n   struct see_pre_extension_expr *extension_expr;\n@@ -1958,7 +1969,7 @@ static int\n see_analyze_use_local_prop (void **slot, void *b)\n {\n   struct see_ref_s *curr_ref_s = (struct see_ref_s *) b;\n-  rtx use_se = *slot;\n+  rtx use_se = (rtx) *slot;\n   rtx ref = curr_ref_s->insn;\n   rtx dest_extension_reg = see_get_extension_reg (use_se, 1);\n   struct see_pre_extension_expr *extension_expr;\n@@ -1990,7 +2001,7 @@ see_analyze_use_local_prop (void **slot, void *b)\n       /* Set the anticipatable bit.  */\n       SET_BIT (antloc[bb_num], indx);\n       /* Record the anticipatable occurrence.  */\n-      curr_occr = xmalloc (sizeof (struct see_occr));\n+      curr_occr = XNEW (struct see_occr);\n       curr_occr->next = NULL;\n       curr_occr->insn = use_se;\n       curr_occr->block_num = bb_num;\n@@ -2008,7 +2019,7 @@ see_analyze_use_local_prop (void **slot, void *b)\n \t  /* Set the available bit.  */\n \t  SET_BIT (comp[bb_num], indx);\n \t  /* Record the available occurrence.  */\n-\t  curr_occr = xmalloc (sizeof (struct see_occr));\n+\t  curr_occr = XNEW (struct see_occr);\n \t  curr_occr->next = NULL;\n \t  curr_occr->insn = use_se;\n \t  curr_occr->block_num = bb_num;\n@@ -2032,7 +2043,7 @@ see_analyze_use_local_prop (void **slot, void *b)\n       /* Reset the killed bit.  */\n       RESET_BIT (ae_kill[bb_num], indx);\n       /* Record the available occurrence.  */\n-      curr_occr = xmalloc (sizeof (struct see_occr));\n+      curr_occr = XNEW (struct see_occr);\n       curr_occr->next = NULL;\n       curr_occr->insn = use_se;\n       curr_occr->block_num = bb_num;\n@@ -2155,7 +2166,7 @@ see_execute_LCM (void)\n static int\n see_set_prop_merged_def (void **slot, void *b)\n {\n-  rtx def_se = *slot;\n+  rtx def_se = (rtx) *slot;\n   struct see_ref_s *curr_ref_s = (struct see_ref_s *) b;\n   rtx insn = curr_ref_s->insn;\n   rtx dest_extension_reg = see_get_extension_reg (def_se, 1);\n@@ -2194,7 +2205,7 @@ see_set_prop_merged_def (void **slot, void *b)\n   else\n     {\n       /* Property doesn't exist yet.  */\n-      curr_prop = xmalloc (sizeof (struct see_register_properties));\n+      curr_prop = XNEW (struct see_register_properties);\n       curr_prop->regno = REGNO (dest_extension_reg);\n       curr_prop->last_def = ref_luid;\n       curr_prop->first_se_before_any_def = -1;\n@@ -2226,7 +2237,7 @@ see_set_prop_merged_def (void **slot, void *b)\n static int\n see_set_prop_unmerged_def (void **slot, void *b)\n {\n-  rtx def_se = *slot;\n+  rtx def_se = (rtx) *slot;\n   struct see_ref_s *curr_ref_s = (struct see_ref_s *) b;\n   rtx insn = curr_ref_s->insn;\n   rtx dest_extension_reg = see_get_extension_reg (def_se, 1);\n@@ -2265,7 +2276,7 @@ see_set_prop_unmerged_def (void **slot, void *b)\n   else\n     {\n       /* Property doesn't exist yet.  */\n-      curr_prop = xmalloc (sizeof (struct see_register_properties));\n+      curr_prop = XNEW (struct see_register_properties);\n       curr_prop->regno = REGNO (dest_extension_reg);\n       curr_prop->last_def = ref_luid;\n       curr_prop->first_se_before_any_def = -1;\n@@ -2299,7 +2310,7 @@ see_set_prop_unmerged_def (void **slot, void *b)\n static int\n see_set_prop_unmerged_use (void **slot, void *b)\n {\n-  rtx use_se = *slot;\n+  rtx use_se = (rtx) *slot;\n   struct see_ref_s *curr_ref_s = (struct see_ref_s *) b;\n   rtx insn = curr_ref_s->insn;\n   rtx dest_extension_reg = see_get_extension_reg (use_se, 1);\n@@ -2359,7 +2370,7 @@ see_set_prop_unmerged_use (void **slot, void *b)\n   else\n     {\n       /* Property doesn't exist yet.  Create a new one.  */\n-      curr_prop = xmalloc (sizeof (struct see_register_properties));\n+      curr_prop = XNEW (struct see_register_properties);\n       curr_prop->regno = REGNO (dest_extension_reg);\n       curr_prop->last_def = -1;\n       curr_prop->first_se_before_any_def = ref_luid;\n@@ -2389,7 +2400,7 @@ see_set_prop_unmerged_use (void **slot, void *b)\n static int\n see_print_one_extension (void **slot, void *b ATTRIBUTE_UNUSED)\n {\n-  rtx def_se = *slot;\n+  rtx def_se = (rtx) *slot;\n \n   gcc_assert (def_se && INSN_P (def_se));\n   print_rtl_single (dump_file, def_se);\n@@ -2619,7 +2630,7 @@ static int\n see_merge_one_use_extension (void **slot, void *b)\n {\n   struct see_ref_s *curr_ref_s = (struct see_ref_s *) b;\n-  rtx use_se = *slot;\n+  rtx use_se = (rtx) *slot;\n   rtx ref = curr_ref_s->merged_insn\n \t    ? curr_ref_s->merged_insn : curr_ref_s->insn;\n   rtx merged_ref_next = curr_ref_s->merged_insn\n@@ -2780,7 +2791,7 @@ static int\n see_merge_one_def_extension (void **slot, void *b)\n {\n   struct see_ref_s *curr_ref_s = (struct see_ref_s *) b;\n-  rtx def_se = *slot;\n+  rtx def_se = (rtx) *slot;\n   /* If the original insn was already merged with an extension before,\n      take the merged one.  */\n   rtx ref = curr_ref_s->merged_insn\n@@ -3160,7 +3171,7 @@ see_store_reference_and_extension (rtx ref_insn, rtx se_insn,\n      tree.  */\n   if (!stn)\n     {\n-      ref_s = xmalloc (sizeof (struct see_ref_s));\n+      ref_s = XNEW (struct see_ref_s);\n       ref_s->luid = DF_INSN_LUID (ref_insn);\n       ref_s->insn = ref_insn;\n       ref_s->merged_insn = NULL;\n@@ -3409,7 +3420,7 @@ see_update_uses_relevancy (rtx insn, struct df_ref *ref,\n     }\n \n   DF_REF_ID (ref) = index;\n-  curr_entry_extra_info = xmalloc (sizeof (struct see_entry_extra_info));\n+  curr_entry_extra_info = XNEW (struct see_entry_extra_info);\n   curr_entry_extra_info->relevancy = et;\n   curr_entry_extra_info->local_relevancy = et;\n   use_entry[index].extra_info = curr_entry_extra_info;\n@@ -3583,7 +3594,7 @@ see_update_defs_relevancy (rtx insn, struct df_ref *ref,\n \t\t\t   unsigned int index)\n {\n   struct see_entry_extra_info *curr_entry_extra_info \n-    = xmalloc (sizeof (struct see_entry_extra_info));\n+    = XNEW (struct see_entry_extra_info);\n   curr_entry_extra_info->relevancy = et;\n   curr_entry_extra_info->local_relevancy = et;\n "}, {"sha": "d2f665f3b20f7c468c35fe726381db35c78158a8", "filename": "gcc/statistics.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fstatistics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fstatistics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstatistics.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -53,7 +53,7 @@ static unsigned nr_statistics_hashes;\n static hashval_t\n hash_statistics_hash (const void *p)\n {\n-  statistics_counter_t *c = (statistics_counter_t *)p;\n+  const statistics_counter_t *const c = (const statistics_counter_t *)p;\n   return htab_hash_string (c->id) + c->val;\n }\n \n@@ -62,8 +62,8 @@ hash_statistics_hash (const void *p)\n static int\n hash_statistics_eq (const void *p, const void *q)\n {\n-  statistics_counter_t *c1 = (statistics_counter_t *)p;\n-  statistics_counter_t *c2 = (statistics_counter_t *)q;\n+  const statistics_counter_t *const c1 = (const statistics_counter_t *)p;\n+  const statistics_counter_t *const c2 = (const statistics_counter_t *)q;\n   return c1->val == c2->val && strcmp (c1->id, c2->id) == 0;\n }\n \n@@ -72,7 +72,7 @@ hash_statistics_eq (const void *p, const void *q)\n static void\n hash_statistics_free (void *p)\n {\n-  free ((void *)((statistics_counter_t *)p)->id);\n+  free (CONST_CAST(char *, ((statistics_counter_t *)p)->id));\n   free (p);\n }\n \n@@ -90,8 +90,7 @@ curr_statistics_hash (void)\n \n   if (idx >= nr_statistics_hashes)\n     {\n-      statistics_hashes = xrealloc (statistics_hashes,\n-\t\t\t\t    (idx + 1) * sizeof (htab_t));\n+      statistics_hashes = XRESIZEVEC (struct htab *, statistics_hashes, idx+1);\n       memset (statistics_hashes + nr_statistics_hashes, 0,\n \t      (idx + 1 - nr_statistics_hashes) * sizeof (htab_t));\n       nr_statistics_hashes = idx + 1;"}, {"sha": "af02f3402ce3d079e13cc0e3e30e364498ac0807", "filename": "gcc/stmt.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -333,7 +333,7 @@ parse_output_constraint (const char **constraint_p, int operand_num,\n \t\t *p, operand_num);\n \n       /* Make a copy of the constraint.  */\n-      buf = alloca (c_len + 1);\n+      buf = XALLOCAVEC (char, c_len + 1);\n       strcpy (buf, constraint);\n       /* Swap the first character and the `=' or `+'.  */\n       buf[p - constraint] = buf[0];\n@@ -565,7 +565,7 @@ decl_overlaps_hard_reg_set_p (tree *declp, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t\t\t      void *data)\n {\n   tree decl = *declp;\n-  const HARD_REG_SET *regs = data;\n+  const HARD_REG_SET *const regs = (const HARD_REG_SET *) data;\n \n   if (TREE_CODE (decl) == VAR_DECL)\n     {\n@@ -651,13 +651,11 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n   tree t;\n   int i;\n   /* Vector of RTX's of evaluated output operands.  */\n-  rtx *output_rtx = alloca (noutputs * sizeof (rtx));\n-  int *inout_opnum = alloca (noutputs * sizeof (int));\n-  rtx *real_output_rtx = alloca (noutputs * sizeof (rtx));\n-  enum machine_mode *inout_mode\n-    = alloca (noutputs * sizeof (enum machine_mode));\n-  const char **constraints\n-    = alloca ((noutputs + ninputs) * sizeof (const char *));\n+  rtx *output_rtx = XALLOCAVEC (rtx, noutputs);\n+  int *inout_opnum = XALLOCAVEC (int, noutputs);\n+  rtx *real_output_rtx = XALLOCAVEC (rtx, noutputs);\n+  enum machine_mode *inout_mode = XALLOCAVEC (enum machine_mode, noutputs);\n+  const char **constraints = XALLOCAVEC (const char *, noutputs + ninputs);\n   int old_generating_concat_p = generating_concat_p;\n \n   /* An ASM with no outputs needs to be treated as volatile, for now.  */\n@@ -1616,7 +1614,7 @@ expand_return (tree retval)\n       int n_regs = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n       unsigned int bitsize\n \t= MIN (TYPE_ALIGN (TREE_TYPE (retval_rhs)), BITS_PER_WORD);\n-      rtx *result_pseudos = alloca (sizeof (rtx) * n_regs);\n+      rtx *result_pseudos = XALLOCAVEC (rtx, n_regs);\n       rtx result_reg, src = NULL_RTX, dst = NULL_RTX;\n       rtx result_val = expand_normal (retval_rhs);\n       enum machine_mode tmpmode, result_reg_mode;\n@@ -2182,8 +2180,8 @@ bool lshift_cheap_p (void)\n static int\n case_bit_test_cmp (const void *p1, const void *p2)\n {\n-  const struct case_bit_test *d1 = p1;\n-  const struct case_bit_test *d2 = p2;\n+  const struct case_bit_test *const d1 = (const struct case_bit_test *) p1;\n+  const struct case_bit_test *const d2 = (const struct case_bit_test *) p2;\n \n   if (d2->bits != d1->bits)\n     return d2->bits - d1->bits;\n@@ -2547,7 +2545,7 @@ expand_case (tree exp)\n \t  /* Get table of labels to jump to, in order of case index.  */\n \n \t  ncases = tree_low_cst (range, 0) + 1;\n-\t  labelvec = alloca (ncases * sizeof (rtx));\n+\t  labelvec = XALLOCAVEC (rtx, ncases);\n \t  memset (labelvec, 0, ncases * sizeof (rtx));\n \n \t  for (n = case_list; n; n = n->right)"}, {"sha": "2b48ea60370227501ec60284c8710850f57c8cac", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -506,7 +506,7 @@ relayout_decl (tree decl)\n record_layout_info\n start_record_layout (tree t)\n {\n-  record_layout_info rli = xmalloc (sizeof (struct record_layout_info_s));\n+  record_layout_info rli = XNEW (struct record_layout_info_s);\n \n   rli->t = t;\n "}, {"sha": "9146fbf4f7d87e6a29e2b015ad8fa6451528df3d", "filename": "gcc/stringpool.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fstringpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Fstringpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstringpool.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -93,7 +93,7 @@ ggc_alloc_string (const char *contents, int length)\n   if (length == 1 && ISDIGIT (contents[0]))\n     return digit_string (contents[0] - '0');\n \n-  result = ggc_alloc (length + 1);\n+  result = GGC_NEWVAR (char, length + 1);\n   memcpy (result, contents, length + 1);\n   return (const char *) result;\n }\n@@ -207,8 +207,8 @@ gt_pch_p_S (void *obj ATTRIBUTE_UNUSED, void *x ATTRIBUTE_UNUSED,\n void\n gt_pch_n_S (const void *x)\n {\n-  gt_pch_note_object ((void *)x, (void *)x, &gt_pch_p_S,\n-\t\t      gt_types_enum_last);\n+  gt_pch_note_object (CONST_CAST (void *, x), CONST_CAST (void *, x),\n+\t\t      &gt_pch_p_S, gt_types_enum_last);\n }\n \f\n /* Handle saving and restoring the string pool for PCH.  */\n@@ -234,10 +234,10 @@ static GTY(()) struct string_pool_data * spd;\n void\n gt_pch_save_stringpool (void)\n {\n-  spd = ggc_alloc (sizeof (*spd));\n+  spd = GGC_NEW (struct string_pool_data);\n   spd->nslots = ident_hash->nslots;\n   spd->nelements = ident_hash->nelements;\n-  spd->entries = ggc_alloc (sizeof (spd->entries[0]) * spd->nslots);\n+  spd->entries = GGC_NEWVEC (struct ht_identifier *, spd->nslots);\n   memcpy (spd->entries, ident_hash->entries,\n \t  spd->nslots * sizeof (spd->entries[0]));\n }"}, {"sha": "c024b74e09cd175e6451aad943cc39cc8f54bf09", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -4780,8 +4780,9 @@ known_dependences_p (VEC (ddr_p, heap) *dependence_relations)\n static hashval_t\n hash_stmt_vertex_info (const void *elt)\n {\n-  struct rdg_vertex_info *rvi = (struct rdg_vertex_info *) elt;\n-  tree stmt = rvi->stmt;\n+  const struct rdg_vertex_info *const rvi =\n+    (const struct rdg_vertex_info *) elt;\n+  const_tree stmt = rvi->stmt;\n \n   return htab_hash_pointer (stmt);\n }\n@@ -4982,15 +4983,16 @@ have_similar_memory_accesses (tree s1, tree s2)\n static int\n have_similar_memory_accesses_1 (const void *s1, const void *s2)\n {\n-  return have_similar_memory_accesses ((tree) s1, (tree) s2);\n+  return have_similar_memory_accesses (CONST_CAST_TREE ((const_tree)s1),\n+\t\t\t\t       CONST_CAST_TREE ((const_tree)s2));\n }\n \n /* Helper function for the hashtab.  */\n \n static hashval_t\n ref_base_address_1 (const void *s)\n {\n-  tree stmt = (tree) s;\n+  tree stmt = CONST_CAST_TREE((const_tree)s);\n   unsigned i;\n   VEC (data_ref_loc, heap) *refs;\n   data_ref_loc *ref;"}, {"sha": "80917a88525bb071ed9fd4ca83319a81c70fef34", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1634b18f7bbf44b178ee770c9cffdee5ae06fa44/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=1634b18f7bbf44b178ee770c9cffdee5ae06fa44", "patch": "@@ -1115,8 +1115,8 @@ static struct pointer_set_t *nontrap_set;\n static hashval_t\n name_to_bb_hash (const void *p)\n {\n-  tree n = ((struct name_to_bb *)p)->ssa_name;\n-  return htab_hash_pointer (n) ^ ((struct name_to_bb *)p)->store;\n+  const_tree n = ((const struct name_to_bb *)p)->ssa_name;\n+  return htab_hash_pointer (n) ^ ((const struct name_to_bb *)p)->store;\n }\n \n /* The equality function of *P1 and *P2.  SSA_NAMEs are shared, so"}]}