{"sha": "a71024790309f81fdcf38e5150f081b300acd3b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTcxMDI0NzkwMzA5ZjgxZmRjZjM4ZTUxNTBmMDgxYjMwMGFjZDNiMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-09-30T21:25:52Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-09-30T21:25:52Z"}, "message": "re PR debug/13974 (bad line marker in debug info)\n\n\tPR debug/13974\n\t* cfgrtl.c (try_redirect_by_replacing_jump,\n\tforce_nonfallthru_and_redirect, commit_one_edge_insertion,\n\tcfg_layout_merge_blocks):  Do not attach any line number information\n\tto newly inserted instructions.\n\t* emit-rtl.c (emit_insn*_before, emit_insn*_after): Rename to\n\temit_insn_*_noloc.\n\t(emit_*insn_before, emit_insn*_after): New.\n\t(emit_*insn_before_setloc, emit_*insn_after_setloc): Do not overwrite\n\texisting locators.\n\t* rtl.h (emit_*insn_before_noloc, emit_*insn_after_noloc): Declare.\n\t(emit_*insn_before_sameloc, emit_*insn_after_sameloc): Kill.\n\nFrom-SVN: r88358", "tree": {"sha": "dae06d9ce92a27f5d915c142bf46cfdc29dea973", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dae06d9ce92a27f5d915c142bf46cfdc29dea973"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a71024790309f81fdcf38e5150f081b300acd3b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a71024790309f81fdcf38e5150f081b300acd3b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a71024790309f81fdcf38e5150f081b300acd3b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a71024790309f81fdcf38e5150f081b300acd3b1/comments", "author": null, "committer": null, "parents": [{"sha": "9108699053ebb8ac2493f3f9efa97d1e228182f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9108699053ebb8ac2493f3f9efa97d1e228182f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9108699053ebb8ac2493f3f9efa97d1e228182f5"}], "stats": {"total": 226, "additions": 170, "deletions": 56}, "files": [{"sha": "c3cf3a771ddcf225eae73d1b13135d69c5f36bc1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a71024790309f81fdcf38e5150f081b300acd3b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a71024790309f81fdcf38e5150f081b300acd3b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a71024790309f81fdcf38e5150f081b300acd3b1", "patch": "@@ -1,3 +1,18 @@\n+2004-09-30  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR debug/13974\n+\t* cfgrtl.c (try_redirect_by_replacing_jump,\n+\tforce_nonfallthru_and_redirect, commit_one_edge_insertion,\n+\tcfg_layout_merge_blocks):  Do not attach any line number information\n+\tto newly inserted instructions.\n+\t* emit-rtl.c (emit_insn*_before, emit_insn*_after): Rename to\n+\temit_insn_*_noloc.\n+\t(emit_*insn_before, emit_insn*_after): New.\n+\t(emit_*insn_before_setloc, emit_*insn_after_setloc): Do not overwrite\n+\texisting locators.\n+\t* rtl.h (emit_*insn_before_noloc, emit_*insn_after_noloc): Declare.\n+\t(emit_*insn_before_sameloc, emit_*insn_after_sameloc): Kill.\n+\n 2004-09-30  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390-protos.h (s390_arg_frame_offset): Remove."}, {"sha": "67b55f4b79adb3254696a1a420e44a067842b059", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a71024790309f81fdcf38e5150f081b300acd3b1/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a71024790309f81fdcf38e5150f081b300acd3b1/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=a71024790309f81fdcf38e5150f081b300acd3b1", "patch": "@@ -771,7 +771,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n       rtx target_label = block_label (target);\n       rtx barrier, label, table;\n \n-      emit_jump_insn_after (gen_jump (target_label), insn);\n+      emit_jump_insn_after_noloc (gen_jump (target_label), insn);\n       JUMP_LABEL (BB_END (src)) = target_label;\n       LABEL_NUSES (target_label)++;\n       if (dump_file)\n@@ -1150,15 +1150,15 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n   if (target == EXIT_BLOCK_PTR)\n     {\n #ifdef HAVE_return\n-\temit_jump_insn_after (gen_return (), BB_END (jump_block));\n+\temit_jump_insn_after_noloc (gen_return (), BB_END (jump_block));\n #else\n \tgcc_unreachable ();\n #endif\n     }\n   else\n     {\n       rtx label = block_label (target);\n-      emit_jump_insn_after (gen_jump (label), BB_END (jump_block));\n+      emit_jump_insn_after_noloc (gen_jump (label), BB_END (jump_block));\n       JUMP_LABEL (BB_END (jump_block)) = label;\n       LABEL_NUSES (label)++;\n     }\n@@ -1653,11 +1653,11 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \n   if (before)\n     {\n-      emit_insn_before (insns, before);\n+      emit_insn_before_noloc (insns, before);\n       last = prev_nonnote_insn (before);\n     }\n   else\n-    last = emit_insn_after (insns, after);\n+    last = emit_insn_after_noloc (insns, after);\n \n   if (returnjump_p (last))\n     {\n@@ -2779,7 +2779,7 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n     {\n       rtx first = BB_END (a), last;\n \n-      last = emit_insn_after (b->rbi->header, BB_END (a));\n+      last = emit_insn_after_noloc (b->rbi->header, BB_END (a));\n       delete_insn_chain (NEXT_INSN (first), last);\n       b->rbi->header = NULL;\n     }\n@@ -2789,7 +2789,7 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n     {\n       rtx first = unlink_insn_chain (BB_HEAD (b), BB_END (b));\n \n-      emit_insn_after (first, BB_END (a));\n+      emit_insn_after_noloc (first, BB_END (a));\n       /* Skip possible DELETED_LABEL insn.  */\n       if (!NOTE_INSN_BASIC_BLOCK_P (first))\n \tfirst = NEXT_INSN (first);"}, {"sha": "2a152c525c04e518e7be398a96eda7996a4185b8", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 126, "deletions": 21, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a71024790309f81fdcf38e5150f081b300acd3b1/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a71024790309f81fdcf38e5150f081b300acd3b1/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=a71024790309f81fdcf38e5150f081b300acd3b1", "patch": "@@ -3951,7 +3951,7 @@ remove_unnecessary_notes (void)\n /* Make X be output before the instruction BEFORE.  */\n \n rtx\n-emit_insn_before (rtx x, rtx before)\n+emit_insn_before_noloc (rtx x, rtx before)\n {\n   rtx last = before;\n   rtx insn;\n@@ -3998,7 +3998,7 @@ emit_insn_before (rtx x, rtx before)\n    and output it before the instruction BEFORE.  */\n \n rtx\n-emit_jump_insn_before (rtx x, rtx before)\n+emit_jump_insn_before_noloc (rtx x, rtx before)\n {\n   rtx insn, last = NULL_RTX;\n \n@@ -4041,7 +4041,7 @@ emit_jump_insn_before (rtx x, rtx before)\n    and output it before the instruction BEFORE.  */\n \n rtx\n-emit_call_insn_before (rtx x, rtx before)\n+emit_call_insn_before_noloc (rtx x, rtx before)\n {\n   rtx last = NULL_RTX, insn;\n \n@@ -4171,7 +4171,7 @@ emit_insn_after_1 (rtx first, rtx after)\n /* Make X be output after the insn AFTER.  */\n \n rtx\n-emit_insn_after (rtx x, rtx after)\n+emit_insn_after_noloc (rtx x, rtx after)\n {\n   rtx last = after;\n \n@@ -4227,7 +4227,7 @@ emit_insn_after_with_line_notes (rtx x, rtx after, rtx from)\n    and output it after the insn AFTER.  */\n \n rtx\n-emit_jump_insn_after (rtx x, rtx after)\n+emit_jump_insn_after_noloc (rtx x, rtx after)\n {\n   rtx last;\n \n@@ -4263,7 +4263,7 @@ emit_jump_insn_after (rtx x, rtx after)\n    and output it after the instruction AFTER.  */\n \n rtx\n-emit_call_insn_after (rtx x, rtx after)\n+emit_call_insn_after_noloc (rtx x, rtx after)\n {\n   rtx last;\n \n@@ -4364,19 +4364,19 @@ emit_note_copy_after (rtx orig, rtx after)\n   return note;\n }\n \f\n-/* Like emit_insn_after, but set INSN_LOCATOR according to SCOPE.  */\n+/* Like emit_insn_after_noloc, but set INSN_LOCATOR according to SCOPE.  */\n rtx\n emit_insn_after_setloc (rtx pattern, rtx after, int loc)\n {\n-  rtx last = emit_insn_after (pattern, after);\n+  rtx last = emit_insn_after_noloc (pattern, after);\n \n-  if (pattern == NULL_RTX)\n+  if (pattern == NULL_RTX || !loc)\n     return last;\n \n   after = NEXT_INSN (after);\n   while (1)\n     {\n-      if (active_insn_p (after))\n+      if (active_insn_p (after) && !INSN_LOCATOR (after))\n \tINSN_LOCATOR (after) = loc;\n       if (after == last)\n \tbreak;\n@@ -4385,19 +4385,29 @@ emit_insn_after_setloc (rtx pattern, rtx after, int loc)\n   return last;\n }\n \n-/* Like emit_jump_insn_after, but set INSN_LOCATOR according to SCOPE.  */\n+/* Like emit_insn_after_noloc, but set INSN_LOCATOR according to AFTER.  */\n+rtx\n+emit_insn_after (rtx pattern, rtx after)\n+{\n+  if (INSN_P (after))\n+    return emit_insn_after_setloc (pattern, after, INSN_LOCATOR (after));\n+  else\n+    return emit_insn_after_noloc (pattern, after);\n+}\n+\n+/* Like emit_jump_insn_after_noloc, but set INSN_LOCATOR according to SCOPE.  */\n rtx\n emit_jump_insn_after_setloc (rtx pattern, rtx after, int loc)\n {\n-  rtx last = emit_jump_insn_after (pattern, after);\n+  rtx last = emit_jump_insn_after_noloc (pattern, after);\n \n-  if (pattern == NULL_RTX)\n+  if (pattern == NULL_RTX || !loc)\n     return last;\n \n   after = NEXT_INSN (after);\n   while (1)\n     {\n-      if (active_insn_p (after))\n+      if (active_insn_p (after) && !INSN_LOCATOR (after))\n \tINSN_LOCATOR (after) = loc;\n       if (after == last)\n \tbreak;\n@@ -4406,19 +4416,29 @@ emit_jump_insn_after_setloc (rtx pattern, rtx after, int loc)\n   return last;\n }\n \n-/* Like emit_call_insn_after, but set INSN_LOCATOR according to SCOPE.  */\n+/* Like emit_jump_insn_after_noloc, but set INSN_LOCATOR according to AFTER.  */\n+rtx\n+emit_jump_insn_after (rtx pattern, rtx after)\n+{\n+  if (INSN_P (after))\n+    return emit_jump_insn_after_setloc (pattern, after, INSN_LOCATOR (after));\n+  else\n+    return emit_jump_insn_after_noloc (pattern, after);\n+}\n+\n+/* Like emit_call_insn_after_noloc, but set INSN_LOCATOR according to SCOPE.  */\n rtx\n emit_call_insn_after_setloc (rtx pattern, rtx after, int loc)\n {\n-  rtx last = emit_call_insn_after (pattern, after);\n+  rtx last = emit_call_insn_after_noloc (pattern, after);\n \n-  if (pattern == NULL_RTX)\n+  if (pattern == NULL_RTX || !loc)\n     return last;\n \n   after = NEXT_INSN (after);\n   while (1)\n     {\n-      if (active_insn_p (after))\n+      if (active_insn_p (after) && !INSN_LOCATOR (after))\n \tINSN_LOCATOR (after) = loc;\n       if (after == last)\n \tbreak;\n@@ -4427,27 +4447,112 @@ emit_call_insn_after_setloc (rtx pattern, rtx after, int loc)\n   return last;\n }\n \n-/* Like emit_insn_before, but set INSN_LOCATOR according to SCOPE.  */\n+/* Like emit_call_insn_after_noloc, but set INSN_LOCATOR according to AFTER.  */\n+rtx\n+emit_call_insn_after (rtx pattern, rtx after)\n+{\n+  if (INSN_P (after))\n+    return emit_call_insn_after_setloc (pattern, after, INSN_LOCATOR (after));\n+  else\n+    return emit_call_insn_after_noloc (pattern, after);\n+}\n+\n+/* Like emit_insn_before_noloc, but set INSN_LOCATOR according to SCOPE.  */\n rtx\n emit_insn_before_setloc (rtx pattern, rtx before, int loc)\n {\n   rtx first = PREV_INSN (before);\n-  rtx last = emit_insn_before (pattern, before);\n+  rtx last = emit_insn_before_noloc (pattern, before);\n+\n+  if (pattern == NULL_RTX || !loc)\n+    return last;\n+\n+  first = NEXT_INSN (first);\n+  while (1)\n+    {\n+      if (active_insn_p (first) && !INSN_LOCATOR (first))\n+\tINSN_LOCATOR (first) = loc;\n+      if (first == last)\n+\tbreak;\n+      first = NEXT_INSN (first);\n+    }\n+  return last;\n+}\n+\n+/* Like emit_insn_before_noloc, but set INSN_LOCATOR according to BEFORE.  */\n+rtx\n+emit_insn_before (rtx pattern, rtx before)\n+{\n+  if (INSN_P (before))\n+    return emit_insn_before_setloc (pattern, before, INSN_LOCATOR (before));\n+  else\n+    return emit_insn_before_noloc (pattern, before);\n+}\n+\n+/* like emit_insn_before_noloc, but set insn_locator according to scope.  */\n+rtx\n+emit_jump_insn_before_setloc (rtx pattern, rtx before, int loc)\n+{\n+  rtx first = PREV_INSN (before);\n+  rtx last = emit_jump_insn_before_noloc (pattern, before);\n+\n+  if (pattern == NULL_RTX)\n+    return last;\n+\n+  first = NEXT_INSN (first);\n+  while (1)\n+    {\n+      if (active_insn_p (first) && !INSN_LOCATOR (first))\n+\tINSN_LOCATOR (first) = loc;\n+      if (first == last)\n+\tbreak;\n+      first = NEXT_INSN (first);\n+    }\n+  return last;\n+}\n+\n+/* Like emit_jump_insn_before_noloc, but set INSN_LOCATOR according to BEFORE.  */\n+rtx\n+emit_jump_insn_before (rtx pattern, rtx before)\n+{\n+  if (INSN_P (before))\n+    return emit_jump_insn_before_setloc (pattern, before, INSN_LOCATOR (before));\n+  else\n+    return emit_jump_insn_before_noloc (pattern, before);\n+}\n+\n+/* like emit_insn_before_noloc, but set insn_locator according to scope.  */\n+rtx\n+emit_call_insn_before_setloc (rtx pattern, rtx before, int loc)\n+{\n+  rtx first = PREV_INSN (before);\n+  rtx last = emit_call_insn_before_noloc (pattern, before);\n \n   if (pattern == NULL_RTX)\n     return last;\n \n   first = NEXT_INSN (first);\n   while (1)\n     {\n-      if (active_insn_p (first))\n+      if (active_insn_p (first) && !INSN_LOCATOR (first))\n \tINSN_LOCATOR (first) = loc;\n       if (first == last)\n \tbreak;\n       first = NEXT_INSN (first);\n     }\n   return last;\n }\n+\n+/* like emit_call_insn_before_noloc,\n+   but set insn_locator according to before.  */\n+rtx\n+emit_call_insn_before (rtx pattern, rtx before)\n+{\n+  if (INSN_P (before))\n+    return emit_call_insn_before_setloc (pattern, before, INSN_LOCATOR (before));\n+  else\n+    return emit_call_insn_before_noloc (pattern, before);\n+}\n \f\n /* Take X and emit it at the end of the doubly-linked\n    INSN list."}, {"sha": "1370be1c3490d8bffb373441aba2cabfd724d24e", "filename": "gcc/gcse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a71024790309f81fdcf38e5150f081b300acd3b1/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a71024790309f81fdcf38e5150f081b300acd3b1/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=a71024790309f81fdcf38e5150f081b300acd3b1", "patch": "@@ -4108,7 +4108,7 @@ insert_insn_end_bb (struct expr *expr, basic_block bb, int pre)\n \t}\n #endif\n       /* FIXME: What if something in cc0/jump uses value set in new insn?  */\n-      new_insn = emit_insn_before (pat, insn);\n+      new_insn = emit_insn_before_noloc (pat, insn);\n     }\n \n   /* Likewise if the last insn is a call, as will happen in the presence\n@@ -4146,10 +4146,10 @@ insert_insn_end_bb (struct expr *expr, basic_block bb, int pre)\n \t     || NOTE_INSN_BASIC_BLOCK_P (insn))\n \tinsn = NEXT_INSN (insn);\n \n-      new_insn = emit_insn_before (pat, insn);\n+      new_insn = emit_insn_before_noloc (pat, insn);\n     }\n   else\n-    new_insn = emit_insn_after (pat, insn);\n+    new_insn = emit_insn_after_noloc (pat, insn);\n \n   while (1)\n     {\n@@ -6190,7 +6190,7 @@ insert_insn_start_bb (rtx insn, basic_block bb)\n       before = NEXT_INSN (before);\n     }\n \n-  insn = emit_insn_after (insn, prev);\n+  insn = emit_insn_after_noloc (insn, prev);\n \n   if (gcse_file)\n     {"}, {"sha": "7fc23bc9a71243295b7aa1f6b1c26d4684cfd184", "filename": "gcc/reload1.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a71024790309f81fdcf38e5150f081b300acd3b1/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a71024790309f81fdcf38e5150f081b300acd3b1/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=a71024790309f81fdcf38e5150f081b300acd3b1", "patch": "@@ -7008,25 +7008,25 @@ emit_reload_insns (struct insn_chain *chain)\n      reloads for the operand.  The RELOAD_OTHER output reloads are\n      output in descending order by reload number.  */\n \n-  emit_insn_before_sameloc (other_input_address_reload_insns, insn);\n-  emit_insn_before_sameloc (other_input_reload_insns, insn);\n+  emit_insn_before (other_input_address_reload_insns, insn);\n+  emit_insn_before (other_input_reload_insns, insn);\n \n   for (j = 0; j < reload_n_operands; j++)\n     {\n-      emit_insn_before_sameloc (inpaddr_address_reload_insns[j], insn);\n-      emit_insn_before_sameloc (input_address_reload_insns[j], insn);\n-      emit_insn_before_sameloc (input_reload_insns[j], insn);\n+      emit_insn_before (inpaddr_address_reload_insns[j], insn);\n+      emit_insn_before (input_address_reload_insns[j], insn);\n+      emit_insn_before (input_reload_insns[j], insn);\n     }\n \n-  emit_insn_before_sameloc (other_operand_reload_insns, insn);\n-  emit_insn_before_sameloc (operand_reload_insns, insn);\n+  emit_insn_before (other_operand_reload_insns, insn);\n+  emit_insn_before (operand_reload_insns, insn);\n \n   for (j = 0; j < reload_n_operands; j++)\n     {\n-      rtx x = emit_insn_after_sameloc (outaddr_address_reload_insns[j], insn);\n-      x = emit_insn_after_sameloc (output_address_reload_insns[j], x);\n-      x = emit_insn_after_sameloc (output_reload_insns[j], x);\n-      emit_insn_after_sameloc (other_output_reload_insns[j], x);\n+      rtx x = emit_insn_after (outaddr_address_reload_insns[j], insn);\n+      x = emit_insn_after (output_address_reload_insns[j], x);\n+      x = emit_insn_after (output_reload_insns[j], x);\n+      emit_insn_after (other_output_reload_insns[j], x);\n     }\n \n   /* For all the spill regs newly reloaded in this instruction,"}, {"sha": "ffc7ef5cb116567d64e522021f91eec1bf016272", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a71024790309f81fdcf38e5150f081b300acd3b1/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a71024790309f81fdcf38e5150f081b300acd3b1/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=a71024790309f81fdcf38e5150f081b300acd3b1", "patch": "@@ -1455,19 +1455,25 @@ extern rtx assign_temp (tree, int, int, int);\n \n /* In emit-rtl.c */\n extern rtx emit_insn_before (rtx, rtx);\n+extern rtx emit_insn_before_noloc (rtx, rtx);\n extern rtx emit_insn_before_setloc (rtx, rtx, int);\n extern rtx emit_jump_insn_before (rtx, rtx);\n+extern rtx emit_jump_insn_before_noloc (rtx, rtx);\n extern rtx emit_jump_insn_before_setloc (rtx, rtx, int);\n extern rtx emit_call_insn_before (rtx, rtx);\n+extern rtx emit_call_insn_before_noloc (rtx, rtx);\n extern rtx emit_call_insn_before_setloc (rtx, rtx, int);\n extern rtx emit_barrier_before (rtx);\n extern rtx emit_label_before (rtx, rtx);\n extern rtx emit_note_before (int, rtx);\n extern rtx emit_insn_after (rtx, rtx);\n+extern rtx emit_insn_after_noloc (rtx, rtx);\n extern rtx emit_insn_after_setloc (rtx, rtx, int);\n extern rtx emit_jump_insn_after (rtx, rtx);\n+extern rtx emit_jump_insn_after_noloc (rtx, rtx);\n extern rtx emit_jump_insn_after_setloc (rtx, rtx, int);\n extern rtx emit_call_insn_after (rtx, rtx);\n+extern rtx emit_call_insn_after_noloc (rtx, rtx);\n extern rtx emit_call_insn_after_setloc (rtx, rtx, int);\n extern rtx emit_barrier_after (rtx);\n extern rtx emit_label_after (rtx, rtx);\n@@ -1499,19 +1505,6 @@ extern rtx skip_consecutive_labels (rtx);\n extern rtx next_cc0_user (rtx);\n extern rtx prev_cc0_setter (rtx);\n \n-#define emit_insn_before_sameloc(INSN, BEFORE) \\\n-  emit_insn_before_setloc (INSN, BEFORE, INSN_LOCATOR (BEFORE))\n-#define emit_jump_insn_before_sameloc(INSN, BEFORE) \\\n-  emit_jump_insn_before_setloc (INSN, BEFORE, INSN_LOCATOR (BEFORE))\n-#define emit_call_insn_before_sameloc(INSN, BEFORE) \\\n-  emit_call_insn_before_setloc (INSN, BEFORE, INSN_LOCATOR (BEFORE))\n-#define emit_insn_after_sameloc(INSN, AFTER) \\\n-  emit_insn_after_setloc (INSN, AFTER, INSN_LOCATOR (AFTER))\n-#define emit_jump_insn_after_sameloc(INSN, AFTER) \\\n-  emit_jump_insn_after_setloc (INSN, AFTER, INSN_LOCATOR (AFTER))\n-#define emit_call_insn_after_sameloc(INSN, AFTER) \\\n-  emit_call_insn_after_setloc (INSN, AFTER, INSN_LOCATOR (AFTER))\n-\n /* In cfglayout.c  */\n extern tree choose_inner_scope (tree, tree);\n extern int insn_line (rtx);"}, {"sha": "83f039a5aaec71930f37d539639a7a17db8d878f", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a71024790309f81fdcf38e5150f081b300acd3b1/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a71024790309f81fdcf38e5150f081b300acd3b1/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=a71024790309f81fdcf38e5150f081b300acd3b1", "patch": "@@ -1855,6 +1855,7 @@ eliminate (void)\n \t  if (TREE_CODE (stmt) == MODIFY_EXPR\n \t      && TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME\n \t      && TREE_CODE (TREE_OPERAND (stmt ,1)) != SSA_NAME\n+\t      && TREE_CODE (TREE_OPERAND (stmt, 1)) != NOP_EXPR\n \t      && !is_gimple_min_invariant (TREE_OPERAND (stmt, 1))\n \t      && !stmt_ann (stmt)->has_volatile_ops)\n \t    {"}]}