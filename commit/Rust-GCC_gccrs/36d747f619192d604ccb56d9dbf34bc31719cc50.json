{"sha": "36d747f619192d604ccb56d9dbf34bc31719cc50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZkNzQ3ZjYxOTE5MmQ2MDRjY2I1NmQ5ZGJmMzRiYzMxNzE5Y2M1MA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-23T02:16:03Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-23T02:16:03Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r573", "tree": {"sha": "0989bebb418d5b0d432c9e59d1b5f5d0cffa4a58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0989bebb418d5b0d432c9e59d1b5f5d0cffa4a58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36d747f619192d604ccb56d9dbf34bc31719cc50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36d747f619192d604ccb56d9dbf34bc31719cc50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36d747f619192d604ccb56d9dbf34bc31719cc50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36d747f619192d604ccb56d9dbf34bc31719cc50/comments", "author": null, "committer": null, "parents": [{"sha": "929f36717e0b3aadec72370f359fc661487696fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/929f36717e0b3aadec72370f359fc661487696fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/929f36717e0b3aadec72370f359fc661487696fc"}], "stats": {"total": 27, "additions": 18, "deletions": 9}, "files": [{"sha": "3aebb70f67f579b470a042d6bb38606837b5a1a7", "filename": "gcc/expmed.c", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d747f619192d604ccb56d9dbf34bc31719cc50/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d747f619192d604ccb56d9dbf34bc31719cc50/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=36d747f619192d604ccb56d9dbf34bc31719cc50", "patch": "@@ -75,9 +75,10 @@ init_expmed ()\n   mult_cost = rtx_cost (gen_rtx (MULT, word_mode, reg, reg));\n   negate_cost = rtx_cost (gen_rtx (NEG, word_mode, reg));\n \n+  /* 999999 is chosen to avoid any plausible faster special case.  */\n   mult_is_very_cheap\n     = (rtx_cost (gen_rtx (MULT, word_mode, reg,\n-\t\t\t  gen_rtx (CONST_INT, VOIDmode, 128)))\n+\t\t\t  gen_rtx (CONST_INT, VOIDmode, 999999)))\n        < rtx_cost (gen_rtx (LSHIFT, word_mode, reg,\n \t\t\t    gen_rtx (CONST_INT, VOIDmode, 7))));\n \n@@ -90,9 +91,10 @@ init_expmed ()\n   for (i = 2;; i <<= 1)\n     {\n       lea = gen_rtx (SET, VOIDmode, reg,\n-\t\t     gen_rtx (PLUS, word_mode, reg,\n+\t\t     gen_rtx (PLUS, word_mode,\n \t\t\t      gen_rtx (MULT, word_mode, reg,\n-\t\t\t\t       gen_rtx (CONST_INT, VOIDmode, i))));\n+\t\t\t\t       gen_rtx (CONST_INT, VOIDmode, i)),\n+\t\t\t      reg));\n       /* Using 0 as second argument is not quite right,\n \t but what else is there to do?  */\n       if (recog (lea, 0, &dummy) < 0)\n@@ -2246,7 +2248,8 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t  rtx label = gen_label_rtx ();\n \t  if (! can_clobber_op0)\n \t    {\n-\t      adjusted_op0 = copy_to_suggested_reg (adjusted_op0, target);\n+\t      adjusted_op0 = copy_to_suggested_reg (adjusted_op0, target,\n+\t\t\t\t\t\t    compute_mode);\n \t      /* Copy op0 to a reg, since emit_cmp_insn will call emit_queue\n \t\t which will screw up mem refs for autoincrements.  */\n \t      op0 = force_reg (compute_mode, op0);\n@@ -2266,7 +2269,8 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t  rtx label = gen_label_rtx ();\n \t  if (! can_clobber_op0)\n \t    {\n-\t      adjusted_op0 = copy_to_suggested_reg (adjusted_op0, target);\n+\t      adjusted_op0 = copy_to_suggested_reg (adjusted_op0, target,\n+\t\t\t\t\t\t    compute_mode);\n \t      /* Copy op0 to a reg, since emit_cmp_insn will call emit_queue\n \t\t which will screw up mem refs for autoincrements.  */\n \t      op0 = force_reg (compute_mode, op0);\n@@ -2284,7 +2288,8 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n     case CEIL_MOD_EXPR:\n       if (! can_clobber_op0)\n \t{\n-\t  adjusted_op0 = copy_to_suggested_reg (adjusted_op0, target);\n+\t  adjusted_op0 = copy_to_suggested_reg (adjusted_op0, target,\n+\t\t\t\t\t\tcompute_mode);\n \t  /* Copy op0 to a reg, since emit_cmp_insn will call emit_queue\n \t     which will screw up mem refs for autoincrements.  */\n \t  op0 = force_reg (compute_mode, op0);\n@@ -2316,7 +2321,8 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n     case ROUND_MOD_EXPR:\n       if (! can_clobber_op0)\n \t{\n-\t  adjusted_op0 = copy_to_suggested_reg (adjusted_op0, target);\n+\t  adjusted_op0 = copy_to_suggested_reg (adjusted_op0, target,\n+\t\t\t\t\t\tcompute_mode);\n \t  /* Copy op0 to a reg, since emit_cmp_insn will call emit_queue\n \t     which will screw up mem refs for autoincrements.  */\n \t  op0 = force_reg (compute_mode, op0);\n@@ -2544,7 +2550,7 @@ expand_mult_add (x, target, mult, add, mode, unsignedp)\n {\n   tree type = type_for_mode (mode, unsignedp);\n   tree add_type = (GET_MODE (add) == VOIDmode\n-\t\t   ? type : type_for_mode (GET_MODE (add)));\n+\t\t   ? type : type_for_mode (GET_MODE (add), unsignedp));\n   tree result =  fold (build (PLUS_EXPR, type,\n \t\t\t      fold (build (MULT_EXPR, type,\n \t\t\t\t\t   make_tree (type, x),\n@@ -2884,7 +2890,7 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n \n \t Two operations that can do the above actions are ABS and FFS, so try\n \t them.  If that doesn't work, and MODE is smaller than a full word,\n-\t we can use zero-extention to the wider mode (an unsigned conversion)\n+\t we can use zero-extension to the wider mode (an unsigned conversion)\n \t as the operation.  */\n \n       if (abs_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n@@ -2913,6 +2919,9 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n \n       if (tem == 0 && (code == NE || BRANCH_COST > 1))\n \t{\n+\t  if (rtx_equal_p (subtarget, op0))\n+\t    subtarget = 0;\n+\n \t  tem = expand_unop (mode, neg_optab, op0, subtarget, 0);\n \t  tem = expand_binop (mode, ior_optab, tem, op0, subtarget, 0,\n \t\t\t      OPTAB_WIDEN);"}]}