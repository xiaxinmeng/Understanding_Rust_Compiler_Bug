{"sha": "78ff60c1ad15e72b056fe888a0b0d509c5e563a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhmZjYwYzFhZDE1ZTcyYjA1NmZlODg4YTBiMGQ1MDljNWU1NjNhOQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-08-09T15:55:18Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-08-09T15:55:18Z"}, "message": "re PR target/51244 ([SH] Inefficient conditional branch and code around T bit)\n\n\tPR target/51244\n\t* config/sh/sh.md: Add negc extu sequence peephole.\n\t(movrt, movnegt, movrt_negc, nott): Use t_reg_operand predicate.\n\t(*movrt_negc): New insn.\n\t* config/sh/sync.md (atomic_test_and_set): Pass gen_t_reg_rtx to\n\tgen_movnegt.\n\t* config/sh/sh.c (expand_cbranchsi4, sh_emit_scc_to_t,\n\tsh_emit_compare_and_branch, sh_emit_compare_and_set): Use get_t_reg_rtx.\n\t(sh_expand_t_scc): Pass gen_t_reg_rtx to gen_movnegt.\n\n\tPR target/51244\n\t* gcc.target/sh/pr51244-5: New.\n\t* gcc.target/sh/pr51244-6: New.\n\nFrom-SVN: r190258", "tree": {"sha": "30cb676505d2f7b7820589b606a4a69283685567", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30cb676505d2f7b7820589b606a4a69283685567"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78ff60c1ad15e72b056fe888a0b0d509c5e563a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78ff60c1ad15e72b056fe888a0b0d509c5e563a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78ff60c1ad15e72b056fe888a0b0d509c5e563a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78ff60c1ad15e72b056fe888a0b0d509c5e563a9/comments", "author": null, "committer": null, "parents": [{"sha": "284c32cfd8c0626f0a3db910aef583f75067a9c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/284c32cfd8c0626f0a3db910aef583f75067a9c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/284c32cfd8c0626f0a3db910aef583f75067a9c5"}], "stats": {"total": 154, "additions": 138, "deletions": 16}, "files": [{"sha": "318278a811a1187d0e73504c256273accf7611cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ff60c1ad15e72b056fe888a0b0d509c5e563a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ff60c1ad15e72b056fe888a0b0d509c5e563a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78ff60c1ad15e72b056fe888a0b0d509c5e563a9", "patch": "@@ -1,3 +1,15 @@\n+2012-08-09  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/51244\n+\t* config/sh/sh.md: Add negc extu sequence peephole.\n+\t(movrt, movnegt, movrt_negc, nott): Use t_reg_operand predicate.\n+\t(*movrt_negc): New insn.\n+\t* config/sh/sync.md (atomic_test_and_set): Pass gen_t_reg_rtx to\n+\tgen_movnegt.\n+\t* config/sh/sh.c (expand_cbranchsi4, sh_emit_scc_to_t,\n+\tsh_emit_compare_and_branch, sh_emit_compare_and_set): Use get_t_reg_rtx.\n+\t(sh_expand_t_scc): Pass gen_t_reg_rtx to gen_movnegt.\n+\n 2012-08-09  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/50751"}, {"sha": "afd6d3dae97a2201b8e6871a848ca80d4cf20806", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ff60c1ad15e72b056fe888a0b0d509c5e563a9/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ff60c1ad15e72b056fe888a0b0d509c5e563a9/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=78ff60c1ad15e72b056fe888a0b0d509c5e563a9", "patch": "@@ -1893,7 +1893,7 @@ expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int probability)\n       branch_expander = gen_branch_false;\n     default: ;\n     }\n-  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (SImode, T_REG),\n+  emit_insn (gen_rtx_SET (VOIDmode, get_t_reg_rtx (),\n                           gen_rtx_fmt_ee (comparison, SImode,\n                                           operands[1], operands[2])));\n   jump = emit_jump_insn (branch_expander (operands[3], get_t_reg_rtx ()));\n@@ -2129,7 +2129,7 @@ sh_emit_set_t_insn (rtx insn, enum machine_mode mode)\n void\n sh_emit_scc_to_t (enum rtx_code code, rtx op0, rtx op1)\n {\n-  rtx t_reg = gen_rtx_REG (SImode, T_REG);\n+  rtx t_reg = get_t_reg_rtx ();\n   enum rtx_code oldcode = code;\n   enum machine_mode mode;\n \n@@ -2304,7 +2304,7 @@ sh_emit_compare_and_branch (rtx *operands, enum machine_mode mode)\n     }\n \n   insn = gen_rtx_SET (VOIDmode,\n-\t\t      gen_rtx_REG (SImode, T_REG),\n+\t\t      get_t_reg_rtx (),\n \t\t      gen_rtx_fmt_ee (branch_code, SImode, op0, op1));\n \n   sh_emit_set_t_insn (insn, mode);\n@@ -2369,9 +2369,9 @@ sh_emit_compare_and_set (rtx *operands, enum machine_mode mode)\n   if (lab)\n     emit_label (lab);\n   if (invert)\n-    emit_insn (gen_movnegt (operands[0]));\n+    emit_insn (gen_movnegt (operands[0], get_t_reg_rtx ()));\n   else\n-    emit_move_insn (operands[0], gen_rtx_REG (SImode, T_REG));\n+    emit_move_insn (operands[0], get_t_reg_rtx ());\n }\n \f\n /* Functions to output assembly code.  */\n@@ -12121,7 +12121,7 @@ sh_expand_t_scc (rtx operands[])\n   if ((code == EQ && val == 1) || (code == NE && val == 0))\n     emit_insn (gen_movt (result, get_t_reg_rtx ()));\n   else if ((code == EQ && val == 0) || (code == NE && val == 1))\n-    emit_insn (gen_movnegt (result));\n+    emit_insn (gen_movnegt (result, get_t_reg_rtx ()));\n   else if (code == EQ || code == NE)\n     emit_insn (gen_move_insn (result, GEN_INT (code == NE)));\n   else"}, {"sha": "c95c904844ccd630b7a32102f80a1ccb4b7fafd9", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 48, "deletions": 9, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ff60c1ad15e72b056fe888a0b0d509c5e563a9/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ff60c1ad15e72b056fe888a0b0d509c5e563a9/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=78ff60c1ad15e72b056fe888a0b0d509c5e563a9", "patch": "@@ -9641,7 +9641,7 @@ label:\n \n (define_insn \"movrt\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(xor:SI (reg:SI T_REG) (const_int 1)))]\n+\t(xor:SI (match_operand:SI 1 \"t_reg_operand\" \"\") (const_int 1)))]\n   \"TARGET_SH2A\"\n   \"movrt\t%0\"\n   [(set_attr \"type\" \"arith\")])\n@@ -9794,28 +9794,66 @@ label:\n \n (define_expand \"movnegt\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n-\t(xor:SI (reg:SI T_REG) (const_int 1)))]\n-  \"\"\n+\t(xor:SI (match_operand:SI 1 \"t_reg_operand\" \"\") (const_int 1)))]\n+  \"TARGET_SH1\"\n {\n   if (TARGET_SH2A)\n-    emit_insn (gen_movrt (operands[0]));\n+    emit_insn (gen_movrt (operands[0], operands[1]));\n   else\n     {\n       rtx val = force_reg (SImode, gen_int_mode (-1, SImode));\n-      emit_insn (gen_movrt_negc (operands[0], val));\n+      emit_insn (gen_movrt_negc (operands[0], operands[1], val));\n     }\n   DONE;\n })\n \n (define_insn \"movrt_negc\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(xor:SI (reg:SI T_REG) (const_int 1)))\n+\t(xor:SI (match_operand:SI 1 \"t_reg_operand\" \"\") (const_int 1)))\n    (set (reg:SI T_REG) (const_int 1))\n-   (use (match_operand:SI 1 \"arith_reg_operand\" \"r\"))]\n+   (use (match_operand:SI 2 \"arith_reg_operand\" \"r\"))]\n   \"TARGET_SH1\"\n-  \"negc\t%1,%0\"\n+  \"negc\t%2,%0\"\n   [(set_attr \"type\" \"arith\")])\n \n+;; The -1 constant will not be CSE-ed for the *movrt_negc pattern, but the\n+;; pattern can be used by the combine pass.  Using a scratch reg for the\n+;; -1 constant results in slightly better register allocations compared to\n+;; generating a pseudo reg before reload.\n+(define_insn_and_split \"*movrt_negc\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(xor:SI (match_operand:SI 1 \"t_reg_operand\" \"\") (const_int 1)))\n+   (clobber (match_scratch:SI 2 \"=r\"))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1 && ! TARGET_SH2A\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 2) (const_int -1))\n+   (parallel\n+       [(set (match_dup 0) (xor:SI (match_dup 1) (const_int 1)))\n+\t(set (reg:SI T_REG) (const_int 1))\n+\t(use (match_dup 2))])])\n+\n+;; In some cases the zero extension does not get combined away and a \n+;; sequence like the following might remain:\n+;;\tmov\t#-1,r2\n+;;\ttst\tr1,r1\n+;;\tnegc\tr2,r1\n+;;\textu.b\tr1,r1\n+(define_peephole2\n+  [(parallel\n+       [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t     (xor:SI (match_operand:SI 1 \"t_reg_operand\" \"\") (const_int 1)))\n+\t(set (reg:SI T_REG) (const_int 1))\n+\t(use (match_operand:SI 2 \"arith_reg_operand\" \"\"))])\n+   (set (match_dup 0)\n+\t(zero_extend:SI (match_operand 3 \"arith_reg_operand\" \"\")))]\n+  \"TARGET_SH1 && REGNO (operands[0]) == REGNO (operands[3])\"\n+  [(parallel\n+       [(set (match_dup 0) (xor:SI (match_dup 1) (const_int 1)))\n+\t(set (reg:SI T_REG) (const_int 1))\n+\t(use (match_dup 2))])])\n+\n ;; The *negnegt pattern helps the combine pass to figure out how to fold \n ;; an explicit double T bit negation.\n (define_insn_and_split \"*negnegt\"\n@@ -9855,7 +9893,8 @@ label:\n   [(const_int 0)])\n \n (define_insn_and_split \"nott\"\n-  [(set (reg:SI T_REG) (xor:SI (reg:SI T_REG) (const_int 1)))]\n+  [(set (reg:SI T_REG)\n+\t(xor:SI (match_operand:SI 0 \"t_reg_operand\" \"\") (const_int 1)))]\n   \"TARGET_SH1\"\n {\n   gcc_assert (TARGET_SH2A);"}, {"sha": "6dabf873c17327793d17b50d7816cffeb738b99b", "filename": "gcc/config/sh/sync.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ff60c1ad15e72b056fe888a0b0d509c5e563a9/gcc%2Fconfig%2Fsh%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ff60c1ad15e72b056fe888a0b0d509c5e563a9/gcc%2Fconfig%2Fsh%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsync.md?ref=78ff60c1ad15e72b056fe888a0b0d509c5e563a9", "patch": "@@ -830,7 +830,7 @@\n   /* The result of the test op is the inverse of what we are\n      supposed to return.  Thus invert the T bit.  The inversion will be\n      potentially optimized away and integrated into surrounding code.  */\n-  emit_insn (gen_movnegt (operands[0]));\n+  emit_insn (gen_movnegt (operands[0], get_t_reg_rtx ()));\n   DONE;\n })\n "}, {"sha": "cffdd0b183475fda6a63a2751033978ee6b85d71", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ff60c1ad15e72b056fe888a0b0d509c5e563a9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ff60c1ad15e72b056fe888a0b0d509c5e563a9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=78ff60c1ad15e72b056fe888a0b0d509c5e563a9", "patch": "@@ -1,3 +1,9 @@\n+2012-08-09  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/51244\n+\t* gcc.target/sh/pr51244-5: New.\n+\t* gcc.target/sh/pr51244-6: New.\n+\n 2012-08-09  Michael Zolotukhin  <michael.v.zolotukhin@intel.com>\n \n \t* gcc.target/i386/adx-addxcarry32-3.c: New."}, {"sha": "a99889df3c0fd1ce9782fd3f9daa6097577b754f", "filename": "gcc/testsuite/gcc.target/sh/pr51244-5.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ff60c1ad15e72b056fe888a0b0d509c5e563a9/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ff60c1ad15e72b056fe888a0b0d509c5e563a9/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-5.c?ref=78ff60c1ad15e72b056fe888a0b0d509c5e563a9", "patch": "@@ -0,0 +1,50 @@\n+/* Check that no unnecessary sign or zero extension insn is generated after\n+   a negc or movrt insn that stores the inverted T bit in a reg.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } } */\n+/* { dg-final { scan-assembler-not \"extu|exts\" } } */\n+\n+int\n+test_00 (int a, int b, int* c, short* d, int x)\n+{\n+  *d = x != 0;\n+  *c = -1;\n+\n+  if (x != 0)\n+    return a > 0;\n+\n+  return 0;\n+}\n+\n+unsigned char\n+test_01 (int x)\n+{\n+  if (x < 58 && x > 47)\n+    return 1;\n+  return 0;\n+}\n+\n+char\n+test_02 (int x)\n+{\n+  if (x < 58 && x > 47)\n+    return 1;\n+  return 0;\n+}\n+\n+unsigned short\n+test_03 (int x)\n+{\n+  if (x < 58 && x > 47)\n+    return 1;\n+  return 0;\n+}\n+\n+short\n+test_04 (int x)\n+{\n+  if (x < 58 && x > 47)\n+    return 1;\n+  return 0;\n+}"}, {"sha": "cfd466197d9a65e359b1a7054c131c8dd0a4f9c4", "filename": "gcc/testsuite/gcc.target/sh/pr51244-6.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ff60c1ad15e72b056fe888a0b0d509c5e563a9/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ff60c1ad15e72b056fe888a0b0d509c5e563a9/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-6.c?ref=78ff60c1ad15e72b056fe888a0b0d509c5e563a9", "patch": "@@ -0,0 +1,15 @@\n+/* Check that no unnecessary sign or zero extension insn is generated after\n+   a negc or movrt insn that stores the inverted T bit in a reg.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m1\" \"-m2\" \"-m3\" \"-m4al\" \"*nofpu\" \"-m4-340*\" \"-m4-400*\" \"-m4-500*\" \"-m5*\" } { \"\" } }  */\n+/* { dg-final { scan-assembler-not \"extu|exts\" } } */\n+\n+float\n+test_00 (float q[4], float m[9])\n+{\n+  float s0 = m[0] + m[1];\n+  float s1 = m[0] - m[1];\n+\n+  return q[s0 > s1 ?  0 : 1];\n+}"}]}