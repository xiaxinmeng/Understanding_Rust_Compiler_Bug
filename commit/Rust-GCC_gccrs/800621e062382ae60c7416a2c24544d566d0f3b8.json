{"sha": "800621e062382ae60c7416a2c24544d566d0f3b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAwNjIxZTA2MjM4MmFlNjBjNzQxNmEyYzI0NTQ0ZDU2NmQwZjNiOA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-12-13T10:28:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:28:24Z"}, "message": "inline.adb (Back_End_Cannot_Inline): Use new flag Has_Pragma_Inline_Always instead of obsolete function Is_Always_Inlined\n\n2007-12-06  Robert Dewar  <dewar@adacore.com>\n\n\t* inline.adb (Back_End_Cannot_Inline): Use new flag\n\tHas_Pragma_Inline_Always instead of obsolete function Is_Always_Inlined\n\n\t* sem_ch6.ads, sem_ch6.adb (Analyze_Subprogram_Body): Use new flag\n\tHas_Pragma_Inline_Always instead.\n\tof obsolete function Is_Always_Inlined\n\t(Build_Body_To_Inline): Same change\n\t(Cannot_Inline): Same change\n\tDo not give warning on exception raise in No_Return function\n\n\t* sem_ch13.adb (Analyze_Record_Representation_Clause): If an inherited\n\tcomponent has two inconsistent component clauses in the same record\n\trepresentation clause, favor the message that complains about\n\tduplication rather than inconsistency.\n\tUpdate comments.\n\t(Record_Representation_Clause): Do not warn on missing component\n\tclauses for inherited components of a type extension.\n\t(Rep_Item_Too_Late): Do not attempt to link pragma into rep chain for\n\tan overloadable item if it is a pragma that can apply to multiple\n\toverloadable entities (e.g. Inline) because a pragma cannot be on\n\tmore than one chain at a time.\n\t(Validate_Unchecked_Conversion): Add code to warn on unchecked\n\tconversion where one of the operands is Ada.Calendar.Time.\n\t(Analyze_Attribute_Definition_Clause): Fix typo in error message.\n\tFor now, ignore Component_Size clause on VM targets, as done for\n\tpragma Pack.\n\nFrom-SVN: r130845", "tree": {"sha": "d50f838fb1e8219d36883568d882424842b7b349", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d50f838fb1e8219d36883568d882424842b7b349"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/800621e062382ae60c7416a2c24544d566d0f3b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/800621e062382ae60c7416a2c24544d566d0f3b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/800621e062382ae60c7416a2c24544d566d0f3b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/800621e062382ae60c7416a2c24544d566d0f3b8/comments", "author": null, "committer": null, "parents": [{"sha": "fcedf218ead3b73d095a88121224df3347c102a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcedf218ead3b73d095a88121224df3347c102a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcedf218ead3b73d095a88121224df3347c102a6"}], "stats": {"total": 349, "additions": 243, "deletions": 106}, "files": [{"sha": "20c99683744ae579f0ead44d2aa0af5cc05093d7", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800621e062382ae60c7416a2c24544d566d0f3b8/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800621e062382ae60c7416a2c24544d566d0f3b8/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=800621e062382ae60c7416a2c24544d566d0f3b8", "patch": "@@ -393,7 +393,7 @@ package body Inline is\n \n          --  If subprogram is marked Inline_Always, inlining is mandatory\n \n-         if Is_Always_Inlined (Subp) then\n+         if Has_Pragma_Inline_Always (Subp) then\n             return False;\n          end if;\n \n@@ -726,7 +726,7 @@ package body Inline is\n          E := First_Entity (P);\n \n          while Present (E) loop\n-            if Is_Always_Inlined (E)\n+            if Has_Pragma_Inline_Always (E)\n               or else (Front_End_Inlining and then Has_Pragma_Inline (E))\n             then\n                if not Is_Loaded (Bname) then"}, {"sha": "33a55a825b3d9680d0d05766410224262e916e23", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 154, "deletions": 39, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800621e062382ae60c7416a2c24544d566d0f3b8/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800621e062382ae60c7416a2c24544d566d0f3b8/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=800621e062382ae60c7416a2c24544d566d0f3b8", "patch": "@@ -1039,7 +1039,7 @@ package body Sem_Ch13 is\n \n             if Has_Component_Size_Clause (Btype) then\n                Error_Msg_N\n-                 (\"component size clase for& previously given\", Nam);\n+                 (\"component size clause for& previously given\", Nam);\n \n             elsif Csize /= No_Uint then\n                Check_Size (Expr, Component_Type (Btype), Csize, Biased);\n@@ -1058,34 +1058,50 @@ package body Sem_Ch13 is\n                --  that will be used to represent the biased subtype that\n                --  reflects the biased representation of components. We need\n                --  this subtype to get proper conversions on referencing\n-               --  elements of the array.\n-\n-               if Biased then\n-                  New_Ctyp :=\n-                    Make_Defining_Identifier (Loc,\n-                      Chars => New_External_Name (Chars (U_Ent), 'C', 0, 'T'));\n-\n-                  Decl :=\n-                    Make_Subtype_Declaration (Loc,\n-                      Defining_Identifier => New_Ctyp,\n-                      Subtype_Indication  =>\n-                        New_Occurrence_Of (Component_Type (Btype), Loc));\n-\n-                  Set_Parent (Decl, N);\n-                  Analyze (Decl, Suppress => All_Checks);\n-\n-                  Set_Has_Delayed_Freeze        (New_Ctyp, False);\n-                  Set_Esize                     (New_Ctyp, Csize);\n-                  Set_RM_Size                   (New_Ctyp, Csize);\n-                  Init_Alignment                (New_Ctyp);\n-                  Set_Has_Biased_Representation (New_Ctyp, True);\n-                  Set_Is_Itype                  (New_Ctyp, True);\n-                  Set_Associated_Node_For_Itype (New_Ctyp, U_Ent);\n-\n-                  Set_Component_Type (Btype, New_Ctyp);\n+               --  elements of the array. Note that component size clauses\n+               --  are ignored in VM mode.\n+\n+               if VM_Target = No_VM then\n+                  if Biased then\n+                     New_Ctyp :=\n+                       Make_Defining_Identifier (Loc,\n+                         Chars =>\n+                           New_External_Name (Chars (U_Ent), 'C', 0, 'T'));\n+\n+                     Decl :=\n+                       Make_Subtype_Declaration (Loc,\n+                         Defining_Identifier => New_Ctyp,\n+                         Subtype_Indication  =>\n+                           New_Occurrence_Of (Component_Type (Btype), Loc));\n+\n+                     Set_Parent (Decl, N);\n+                     Analyze (Decl, Suppress => All_Checks);\n+\n+                     Set_Has_Delayed_Freeze        (New_Ctyp, False);\n+                     Set_Esize                     (New_Ctyp, Csize);\n+                     Set_RM_Size                   (New_Ctyp, Csize);\n+                     Init_Alignment                (New_Ctyp);\n+                     Set_Has_Biased_Representation (New_Ctyp, True);\n+                     Set_Is_Itype                  (New_Ctyp, True);\n+                     Set_Associated_Node_For_Itype (New_Ctyp, U_Ent);\n+\n+                     Set_Component_Type (Btype, New_Ctyp);\n+                  end if;\n+\n+                  Set_Component_Size (Btype, Csize);\n+\n+               --  For VM case, we ignore component size clauses\n+\n+               else\n+                  --  Give a warning unless we are in GNAT mode, in which case\n+                  --  the warning is suppressed since it is not useful.\n+\n+                  if not GNAT_Mode then\n+                     Error_Msg_N\n+                       (\"?component size ignored in this configuration\", N);\n+                  end if;\n                end if;\n \n-               Set_Component_Size            (Btype, Csize);\n                Set_Has_Component_Size_Clause (Btype, True);\n                Set_Has_Non_Standard_Rep      (Btype, True);\n             end if;\n@@ -2190,14 +2206,19 @@ package body Sem_Ch13 is\n          end;\n       end if;\n \n-      --  Clear any existing component clauses for the type (this happens with\n-      --  derived types, where we are now overriding the original).\n+      --  For untagged types, clear any existing component clauses for the\n+      --  type. If the type is derived, this is what allows us to override\n+      --  a rep clause for the parent. For type extensions, the representation\n+      --  of the inherited components is inherited, so we want to keep previous\n+      --  component clauses for completeness.\n \n-      Comp := First_Component_Or_Discriminant (Rectype);\n-      while Present (Comp) loop\n-         Set_Component_Clause (Comp, Empty);\n-         Next_Component_Or_Discriminant (Comp);\n-      end loop;\n+      if not Is_Tagged_Type (Rectype) then\n+         Comp := First_Component_Or_Discriminant (Rectype);\n+         while Present (Comp) loop\n+            Set_Component_Clause (Comp, Empty);\n+            Next_Component_Or_Discriminant (Comp);\n+         end loop;\n+      end if;\n \n       --  All done if no component clauses\n \n@@ -2323,9 +2344,40 @@ package body Sem_Ch13 is\n                        (\"component clause is for non-existent field\", CC);\n \n                   elsif Present (Component_Clause (Comp)) then\n-                     Error_Msg_Sloc := Sloc (Component_Clause (Comp));\n-                     Error_Msg_N\n-                       (\"component clause previously given#\", CC);\n+\n+                     --  Diagose duplicate rep clause, or check consistency\n+                     --  if this is inherited component. In a double fault,\n+                     --  there may be a duplicate inconsistent clause for an\n+                     --  inherited component.\n+\n+                     if\n+                       Scope (Original_Record_Component (Comp)) = Rectype\n+                         or else Parent (Component_Clause (Comp)) = N\n+                     then\n+                        Error_Msg_Sloc := Sloc (Component_Clause (Comp));\n+                        Error_Msg_N (\"component clause previously given#\", CC);\n+\n+                     else\n+                        declare\n+                           Rep1 : constant Node_Id := Component_Clause (Comp);\n+\n+                        begin\n+                           if Intval (Position (Rep1)) /=\n+                                                   Intval (Position (CC))\n+                             or else Intval (First_Bit (Rep1)) /=\n+                                                   Intval (First_Bit (CC))\n+                             or else Intval (Last_Bit (Rep1)) /=\n+                                                   Intval (Last_Bit (CC))\n+                           then\n+                              Error_Msg_N (\"component clause inconsistent \"\n+                                & \"with representation of ancestor\", CC);\n+\n+                           elsif Warn_On_Redundant_Constructs then\n+                              Error_Msg_N (\"?redundant component clause \"\n+                                & \"for inherited component!\", CC);\n+                           end if;\n+                        end;\n+                     end if;\n \n                   else\n                      --  Make reference for field in record rep clause and set\n@@ -2684,6 +2736,7 @@ package body Sem_Ch13 is\n             while Present (Comp) loop\n                if Present (Component_Clause (Comp)) then\n                   Num_Repped_Components := Num_Repped_Components + 1;\n+\n                else\n                   Num_Unrepped_Components := Num_Unrepped_Components + 1;\n                end if;\n@@ -2702,6 +2755,7 @@ package body Sem_Ch13 is\n                Comp := First_Component_Or_Discriminant (Rectype);\n                while Present (Comp) loop\n                   if No (Component_Clause (Comp))\n+                    and then Comes_From_Source (Comp)\n                     and then (Is_Scalar_Type (Underlying_Type (Etype (Comp)))\n                                 or else Size_Known_At_Compile_Time\n                                              (Underlying_Type (Etype (Comp))))\n@@ -3413,6 +3467,17 @@ package body Sem_Ch13 is\n                return 0;\n             end if;\n \n+            --  Note: In the following two tests for LoSet and HiSet, it may\n+            --  seem redundant to test for N_Real_Literal here since normally\n+            --  one would assume that the test for the value being known at\n+            --  compile time includes this case. However, there is a glitch.\n+            --  If the real literal comes from folding a non-static expression,\n+            --  then we don't consider any non- static expression to be known\n+            --  at compile time if we are in configurable run time mode (needed\n+            --  in some cases to give a clearer definition of what is and what\n+            --  is not accepted). So the test is indeed needed. Without it, we\n+            --  would set neither Lo_Set nor Hi_Set and get an infinite loop.\n+\n             if not LoSet then\n                if Nkind (Type_Low_Bound (Ancest)) = N_Real_Literal\n                  or else Compile_Time_Known_Value (Type_Low_Bound (Ancest))\n@@ -3752,9 +3817,29 @@ package body Sem_Ch13 is\n          end if;\n       end if;\n \n-      --  No error, link item into head of chain of rep items for the entity\n+      --  No error, link item into head of chain of rep items for the entity,\n+      --  but avoid chaining if we have an overloadable entity, and the pragma\n+      --  is one that can apply to multiple overloaded entities.\n+\n+      if Is_Overloadable (T)\n+        and then Nkind (N) = N_Pragma\n+        and then (Chars (N) = Name_Convention\n+                    or else\n+                  Chars (N) = Name_Import\n+                    or else\n+                  Chars (N) = Name_Export\n+                    or else\n+                  Chars (N) = Name_External\n+                    or else\n+                  Chars (N) = Name_Interface)\n+      then\n+         null;\n+      else\n+         Record_Rep_Item (T, N);\n+      end if;\n+\n+      --  Rep item was OK, not too late\n \n-      Record_Rep_Item (T, N);\n       return False;\n    end Rep_Item_Too_Late;\n \n@@ -4186,6 +4271,36 @@ package body Sem_Ch13 is\n            (\"?conversion between pointers with different conventions!\", N);\n       end if;\n \n+      --  Warn if one of the operands is Ada.Calendar.Time. Do not emit a\n+      --  warning when compiling GNAT-related sources.\n+\n+      if Warn_On_Unchecked_Conversion\n+        and then not In_Predefined_Unit (N)\n+        and then RTU_Loaded (Ada_Calendar)\n+        and then\n+          (Chars (Source) = Name_Time\n+             or else\n+           Chars (Target) = Name_Time)\n+      then\n+         --  If Ada.Calendar is loaded and the name of one of the operands is\n+         --  Time, there is a good chance that this is Ada.Calendar.Time.\n+\n+         declare\n+            Calendar_Time : constant Entity_Id :=\n+                              Full_View (RTE (RO_CA_Time));\n+         begin\n+            pragma Assert (Present (Calendar_Time));\n+\n+            if Source = Calendar_Time\n+              or else Target = Calendar_Time\n+            then\n+               Error_Msg_N\n+                 (\"?representation of 'Time values may change between \" &\n+                  \"'G'N'A'T versions\", N);\n+            end if;\n+         end;\n+      end if;\n+\n       --  Make entry in unchecked conversion table for later processing\n       --  by Validate_Unchecked_Conversions, which will check sizes and\n       --  alignments (using values set by the back-end where possible)."}, {"sha": "5f513690c2e02202a45f0faf3cdbe857b91b677a", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 77, "deletions": 65, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800621e062382ae60c7416a2c24544d566d0f3b8/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800621e062382ae60c7416a2c24544d566d0f3b8/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=800621e062382ae60c7416a2c24544d566d0f3b8", "patch": "@@ -196,12 +196,6 @@ package body Sem_Ch6 is\n    --  Flag functions that can be called without parameters, i.e. those that\n    --  have no parameters, or those for which defaults exist for all parameters\n \n-   procedure Reference_Body_Formals (Spec : Entity_Id; Bod : Entity_Id);\n-   --  If there is a separate spec for a subprogram or generic subprogram, the\n-   --  formals of the body are treated as references to the corresponding\n-   --  formals of the spec. This reference does not count as an actual use of\n-   --  the formal, in order to diagnose formals that are unused in the body.\n-\n    procedure Set_Formal_Validity (Formal_Id : Entity_Id);\n    --  Formal_Id is an formal parameter entity. This procedure deals with\n    --  setting the proper validity status for this entity, which depends\n@@ -213,9 +207,8 @@ package body Sem_Ch6 is\n \n    procedure Analyze_Return_Statement (N : Node_Id) is\n \n-      pragma Assert (Nkind (N) = N_Simple_Return_Statement\n-                       or else\n-                     Nkind (N) = N_Extended_Return_Statement);\n+      pragma Assert (Nkind_In (N, N_Simple_Return_Statement,\n+                                  N_Extended_Return_Statement));\n \n       Returns_Object : constant Boolean :=\n                          Nkind (N) = N_Extended_Return_Statement\n@@ -914,14 +907,16 @@ package body Sem_Ch6 is\n       Par : constant Node_Id := Parent (N);\n \n    begin\n-      if        (Nkind (Par) = N_Function_Call and then N = Name (Par))\n+      if        (Nkind (Par) = N_Function_Call\n+                   and then N = Name (Par))\n         or else  Nkind (Par) = N_Function_Instantiation\n-        or else (Nkind (Par) = N_Indexed_Component and then N = Prefix (Par))\n+        or else (Nkind (Par) = N_Indexed_Component\n+                   and then N = Prefix (Par))\n         or else (Nkind (Par) = N_Pragma_Argument_Association\n                    and then not Is_Pragma_String_Literal (Par))\n         or else  Nkind (Par) = N_Subprogram_Renaming_Declaration\n-        or else  (Nkind (Par) = N_Attribute_Reference\n-                   and then Attribute_Name (Par) /= Name_Value)\n+        or else (Nkind (Par) = N_Attribute_Reference\n+                  and then Attribute_Name (Par) /= Name_Value)\n       then\n          Find_Direct_Name (N);\n \n@@ -1463,7 +1458,7 @@ package body Sem_Ch6 is\n          Write_Eol;\n       end if;\n \n-      Trace_Scope (N, Body_Id, \" Analyze subprogram\");\n+      Trace_Scope (N, Body_Id, \" Analyze subprogram: \");\n \n       --  Generic subprograms are handled separately. They always have a\n       --  generic specification. Determine whether current scope has a\n@@ -1945,7 +1940,7 @@ package body Sem_Ch6 is\n       elsif Present (Spec_Id)\n         and then Expander_Active\n         and then\n-          (Is_Always_Inlined (Spec_Id)\n+          (Has_Pragma_Inline_Always (Spec_Id)\n              or else (Has_Pragma_Inline (Spec_Id) and Front_End_Inlining))\n       then\n          Build_Body_To_Inline (N, Spec_Id);\n@@ -2092,13 +2087,14 @@ package body Sem_Ch6 is\n       --  initialized!\n \n       declare\n-         Stm : Node_Id := First (Statements (HSS));\n+         Stm : Node_Id;\n \n       begin\n          --  Skip initial labels (for one thing this occurs when we are in\n          --  front end ZCX mode, but in any case it is irrelevant), and also\n          --  initial Push_xxx_Error_Label nodes, which are also irrelevant.\n \n+         Stm := First (Statements (HSS));\n          while Nkind (Stm) = N_Label\n            or else Nkind (Stm) in N_Push_xxx_Label\n          loop\n@@ -2212,7 +2208,7 @@ package body Sem_Ch6 is\n       Trace_Scope\n         (N,\n          Defining_Entity (N),\n-         \" Analyze subprogram spec. \");\n+         \" Analyze subprogram spec: \");\n \n       if Debug_Flag_C then\n          Write_Str (\"====  Compiling subprogram spec \");\n@@ -2355,8 +2351,7 @@ package body Sem_Ch6 is\n          Set_Etype (Designator, Standard_Void_Type);\n       end if;\n \n-      --  Introduce new scope for analysis of the formals and of the\n-      --  return type.\n+      --  Introduce new scope for analysis of the formals and the return type\n \n       Set_Scope (Designator, Current_Scope);\n \n@@ -2495,12 +2490,10 @@ package body Sem_Ch6 is\n             then\n                Conv := Current_Entity (Id);\n \n-            elsif (Nkind (Id) = N_Selected_Component\n-                    or else Nkind (Id) = N_Expanded_Name)\n+            elsif Nkind_In (Id, N_Selected_Component, N_Expanded_Name)\n               and then Chars (Selector_Name (Id)) = Name_Unchecked_Conversion\n             then\n                Conv := Current_Entity (Selector_Name (Id));\n-\n             else\n                return False;\n             end if;\n@@ -2515,16 +2508,15 @@ package body Sem_Ch6 is\n \n       begin\n          D := First (Decls);\n-\n          while Present (D) loop\n-            if       (Nkind (D) = N_Function_Instantiation\n-                        and then not Is_Unchecked_Conversion (D))\n-              or else Nkind (D) = N_Protected_Type_Declaration\n-              or else Nkind (D) = N_Package_Declaration\n-              or else Nkind (D) = N_Package_Instantiation\n-              or else Nkind (D) = N_Subprogram_Body\n-              or else Nkind (D) = N_Procedure_Instantiation\n-              or else Nkind (D) = N_Task_Type_Declaration\n+            if (Nkind (D) = N_Function_Instantiation\n+                  and then not Is_Unchecked_Conversion (D))\n+              or else Nkind_In (D, N_Protected_Type_Declaration,\n+                                   N_Package_Declaration,\n+                                   N_Package_Instantiation,\n+                                   N_Subprogram_Body,\n+                                   N_Procedure_Instantiation,\n+                                   N_Task_Type_Declaration)\n             then\n                Cannot_Inline\n                  (\"cannot inline & (non-allowed declaration)?\", D, Subp);\n@@ -2550,13 +2542,13 @@ package body Sem_Ch6 is\n          while Present (S) loop\n             Stat_Count := Stat_Count + 1;\n \n-            if Nkind (S) = N_Abort_Statement\n-              or else Nkind (S) = N_Asynchronous_Select\n-              or else Nkind (S) = N_Conditional_Entry_Call\n-              or else Nkind (S) = N_Delay_Relative_Statement\n-              or else Nkind (S) = N_Delay_Until_Statement\n-              or else Nkind (S) = N_Selective_Accept\n-              or else Nkind (S) = N_Timed_Entry_Call\n+            if Nkind_In (S, N_Abort_Statement,\n+                            N_Asynchronous_Select,\n+                            N_Conditional_Entry_Call,\n+                            N_Delay_Relative_Statement,\n+                            N_Delay_Until_Statement,\n+                            N_Selective_Accept,\n+                            N_Timed_Entry_Call)\n             then\n                Cannot_Inline\n                  (\"cannot inline & (non-allowed statement)?\", S, Subp);\n@@ -2821,7 +2813,7 @@ package body Sem_Ch6 is\n       --  checks on inlining (forbidden declarations, handlers, etc).\n \n       if Stat_Count > Max_Size\n-        and then not Is_Always_Inlined (Subp)\n+        and then not Has_Pragma_Inline_Always (Subp)\n       then\n          Cannot_Inline (\"cannot inline& (body too large)?\", N, Subp);\n          return;\n@@ -2917,7 +2909,7 @@ package body Sem_Ch6 is\n       then\n          null;\n \n-      elsif Is_Always_Inlined (Subp) then\n+      elsif Has_Pragma_Inline_Always (Subp) then\n \n          --  Remove last character (question mark) to make this into an error,\n          --  because the Inline_Always pragma cannot be obeyed.\n@@ -3828,11 +3820,11 @@ package body Sem_Ch6 is\n          Decl := Unit_Declaration_Node (Subp);\n       end if;\n \n-      if Nkind (Decl) = N_Subprogram_Body\n-        or else Nkind (Decl) = N_Subprogram_Body_Stub\n-        or else Nkind (Decl) = N_Subprogram_Declaration\n-        or else Nkind (Decl) = N_Abstract_Subprogram_Declaration\n-        or else Nkind (Decl) = N_Subprogram_Renaming_Declaration\n+      if Nkind_In (Decl, N_Subprogram_Body,\n+                         N_Subprogram_Body_Stub,\n+                         N_Subprogram_Declaration,\n+                         N_Abstract_Subprogram_Declaration,\n+                         N_Subprogram_Renaming_Declaration)\n       then\n          Spec := Specification (Decl);\n \n@@ -3864,7 +3856,7 @@ package body Sem_Ch6 is\n       --  argument the signature that may match that of a standard operation.\n \n       elsif Nkind (Subp) = N_Defining_Operator_Symbol\n-        and then  Must_Not_Override (Spec)\n+        and then Must_Not_Override (Spec)\n       then\n          if Operator_Matches_Spec (Subp, Subp) then\n             Error_Msg_NE\n@@ -4023,9 +4015,9 @@ package body Sem_Ch6 is\n          --  Don't count exception junk\n \n            or else\n-             ((Nkind (Last_Stm) = N_Goto_Statement\n-                 or else Nkind (Last_Stm) = N_Label\n-                 or else Nkind (Last_Stm) = N_Object_Declaration)\n+             (Nkind_In (Last_Stm, N_Goto_Statement,\n+                                   N_Label,\n+                                   N_Object_Declaration)\n                 and then Exception_Junk (Last_Stm))\n            or else Nkind (Last_Stm) in N_Push_xxx_Label\n            or else Nkind (Last_Stm) in N_Pop_xxx_Label\n@@ -4111,7 +4103,6 @@ package body Sem_Ch6 is\n          elsif Kind = N_Case_Statement then\n             declare\n                Case_Alt : Node_Id;\n-\n             begin\n                Case_Alt := First_Non_Pragma (Alternatives (Last_Stm));\n                while Present (Case_Alt) loop\n@@ -4247,12 +4238,15 @@ package body Sem_Ch6 is\n          --  Otherwise we have the case of a procedure marked No_Return\n \n          else\n-            Error_Msg_N\n-              (\"?implied return after this statement will raise Program_Error\",\n-               Last_Stm);\n-            Error_Msg_NE\n-              (\"?procedure & is marked as No_Return\",\n-               Last_Stm, Proc);\n+            if not Raise_Exception_Call then\n+               Error_Msg_N\n+                 (\"?implied return after this statement \" &\n+                  \"will raise Program_Error\",\n+                  Last_Stm);\n+               Error_Msg_NE\n+                 (\"\\?procedure & is marked as No_Return!\",\n+                  Last_Stm, Proc);\n+            end if;\n \n             declare\n                RE : constant Node_Id :=\n@@ -4574,7 +4568,7 @@ package body Sem_Ch6 is\n       Are_Anonymous_Access_To_Subprogram_Types :=\n         Ekind (Type_1) = Ekind (Type_2)\n           and then\n-            (Ekind (Type_1) =  E_Anonymous_Access_Subprogram_Type\n+            (Ekind (Type_1) = E_Anonymous_Access_Subprogram_Type\n              or else\n                Ekind (Type_1) = E_Anonymous_Access_Protected_Subprogram_Type);\n \n@@ -6146,9 +6140,8 @@ package body Sem_Ch6 is\n                then\n                   return True;\n \n-               elsif (Nkind (N) = N_Private_Type_Declaration\n-                       or else\n-                      Nkind (N) = N_Private_Extension_Declaration)\n+               elsif Nkind_In (N, N_Private_Type_Declaration,\n+                                  N_Private_Extension_Declaration)\n                  and then Present (Defining_Identifier (N))\n                  and then T = Full_View (Defining_Identifier (N))\n                then\n@@ -6303,9 +6296,10 @@ package body Sem_Ch6 is\n          --  operation in a type derivation on for a generic actual.\n \n          if Nkind (Parent (Typ)) /= N_Full_Type_Declaration\n-           and then Nkind (Parent (Def_Id)) /= N_Subtype_Declaration\n-           and then Nkind (Parent (Def_Id)) /= N_Task_Type_Declaration\n-           and then Nkind (Parent (Def_Id)) /= N_Protected_Type_Declaration\n+           and then\n+             not Nkind_In (Parent (Def_Id), N_Subtype_Declaration,\n+                                            N_Task_Type_Declaration,\n+                                            N_Protected_Type_Declaration)\n          then\n             Collect_Abstract_Interfaces (Typ, Ifaces_List);\n \n@@ -6838,6 +6832,10 @@ package body Sem_Ch6 is\n       Default     : Node_Id;\n       Ptype       : Entity_Id;\n \n+      --  The following are used for setting Is_Only_Out_\n+      Num_Out_Params  : Nat       := 0;\n+      First_Out_Param : Entity_Id := Empty;\n+\n       function Is_Class_Wide_Default (D : Node_Id) return Boolean;\n       --  Check whether the default has a class-wide type. After analysis the\n       --  default has the type of the formal, so we must also check explicitly\n@@ -6895,8 +6893,8 @@ package body Sem_Ch6 is\n                elsif Is_Value_Type (Formal_Type) then\n                   null;\n \n-               elsif Nkind (Parent (T)) /= N_Access_Function_Definition\n-                 and then Nkind (Parent (T)) /= N_Access_Procedure_Definition\n+               elsif not Nkind_In (Parent (T), N_Access_Function_Definition,\n+                                               N_Access_Procedure_Definition)\n                then\n                   Error_Msg_N (\"invalid use of incomplete type\", Param_Spec);\n \n@@ -7075,10 +7073,24 @@ package body Sem_Ch6 is\n                   Apply_Scalar_Range_Check (Default, Formal_Type);\n                end if;\n             end if;\n+\n+         elsif Ekind (Formal) = E_Out_Parameter then\n+            Num_Out_Params := Num_Out_Params + 1;\n+\n+            if Num_Out_Params = 1 then\n+               First_Out_Param := Formal;\n+            end if;\n+\n+         elsif Ekind (Formal) = E_In_Out_Parameter then\n+            Num_Out_Params := Num_Out_Params + 1;\n          end if;\n \n          Next (Param_Spec);\n       end loop;\n+\n+      if Present (First_Out_Param) and then Num_Out_Params = 1 then\n+         Set_Is_Only_Out_Parameter (First_Out_Param);\n+      end if;\n    end Process_Formals;\n \n    ----------------------------"}, {"sha": "071aa75c44b9151a5915f64e39e5ed733f234abd", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800621e062382ae60c7416a2c24544d566d0f3b8/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800621e062382ae60c7416a2c24544d566d0f3b8/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=800621e062382ae60c7416a2c24544d566d0f3b8", "patch": "@@ -176,6 +176,16 @@ package Sem_Ch6 is\n    --  access parameter are attached to the Related_Nod which comes from the\n    --  context.\n \n+   procedure Reference_Body_Formals (Spec : Entity_Id; Bod : Entity_Id);\n+   --  If there is a separate spec for a subprogram or generic subprogram, the\n+   --  formals of the body are treated as references to the corresponding\n+   --  formals of the spec. This reference does not count as an actual use of\n+   --  the formal, in order to diagnose formals that are unused in the body.\n+   --  This procedure is also used in renaming_as_body declarations, where\n+   --  the formals of the specification must be treated as body formals that\n+   --  correspond to the previous subprogram declaration, and not as new\n+   --  entities with their defining entry in the cross-reference information.\n+\n    procedure Set_Actual_Subtypes (N : Node_Id; Subp : Entity_Id);\n    --  If the formals of a subprogram are unconstrained, build a subtype\n    --  declaration that uses the bounds or discriminants of the actual to"}]}