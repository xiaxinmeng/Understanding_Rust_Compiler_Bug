{"sha": "1e92bbb90760c6d3a55d9685228cf2e99dd40e8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU5MmJiYjkwNzYwYzZkM2E1NWQ5Njg1MjI4Y2YyZTk5ZGQ0MGU4Zg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2004-03-22T00:40:44Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2004-03-22T00:40:44Z"}, "message": "real.h (struct real_value): Use the same type for all bitfields.\n\n* real.h (struct real_value): Use the same type for all\nbitfields.  Rename exp to uexp.\n(REAL_EXP, SET_REAL_EXP): New accessor macros for uexp.\nAdjust all uses of exp...\n* builtins.c: ... here, ...\n* emit-rtl.c: ... here, and ...\n* real.c: ... and here.\n\nFrom-SVN: r79802", "tree": {"sha": "7b5c6d97adab6e033ff6faffa54cbc4e7d09046e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b5c6d97adab6e033ff6faffa54cbc4e7d09046e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e92bbb90760c6d3a55d9685228cf2e99dd40e8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e92bbb90760c6d3a55d9685228cf2e99dd40e8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e92bbb90760c6d3a55d9685228cf2e99dd40e8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e92bbb90760c6d3a55d9685228cf2e99dd40e8f/comments", "author": null, "committer": null, "parents": [{"sha": "9175d40929b58aed64a94ecd1b4b8dcb3642f35b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9175d40929b58aed64a94ecd1b4b8dcb3642f35b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9175d40929b58aed64a94ecd1b4b8dcb3642f35b"}], "stats": {"total": 183, "additions": 102, "deletions": 81}, "files": [{"sha": "d6faf06d24d538537101b1500719dcde23729383", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e92bbb90760c6d3a55d9685228cf2e99dd40e8f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e92bbb90760c6d3a55d9685228cf2e99dd40e8f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e92bbb90760c6d3a55d9685228cf2e99dd40e8f", "patch": "@@ -1,3 +1,13 @@\n+2004-03-21  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* real.h (struct real_value): Use the same type for all\n+\tbitfields.  Rename exp to uexp.\n+\t(REAL_EXP, SET_REAL_EXP): New accessor macros for uexp.\n+\tAdjust all uses of exp...\n+\t* builtins.c: ... here, ...\n+\t* emit-rtl.c: ... here, and ...\n+\t* real.c: ... and here.\n+\n 2004-03-21  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* pretty-print.c (pp_base_maybe_space): New function."}, {"sha": "58565f7731984bf9ca51a07b98c55c08afa117c3", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e92bbb90760c6d3a55d9685228cf2e99dd40e8f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e92bbb90760c6d3a55d9685228cf2e99dd40e8f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1e92bbb90760c6d3a55d9685228cf2e99dd40e8f", "patch": "@@ -6812,7 +6812,7 @@ fold_builtin (tree exp)\n \t      REAL_VALUE_TYPE cst;\n \n \t      real_convert (&cst, TYPE_MODE (type), &dconstpi);\n-\t      cst.exp -= 2;\n+\t      SET_REAL_EXP (&cst, REAL_EXP (&cst) - 2);\n \t      return build_real (type, cst);\n \t    }\n \t}"}, {"sha": "cb6f4cb639ca49f7c219dbe303795bb06a415ed6", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e92bbb90760c6d3a55d9685228cf2e99dd40e8f/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e92bbb90760c6d3a55d9685228cf2e99dd40e8f/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=1e92bbb90760c6d3a55d9685228cf2e99dd40e8f", "patch": "@@ -5313,7 +5313,7 @@ init_emit_once (int line_numbers)\n   REAL_VALUE_FROM_INT (dconstm2, -2, -1, double_mode);\n \n   dconsthalf = dconst1;\n-  dconsthalf.exp--;\n+  SET_REAL_EXP (&dconsthalf, REAL_EXP (&dconsthalf) - 1);\n \n   real_arithmetic (&dconstthird, RDIV_EXPR, &dconst1, &dconst3);\n "}, {"sha": "344fdcc3885e1d36a7df3c911579192ffbdbe81b", "filename": "gcc/real.c", "status": "modified", "additions": 79, "deletions": 77, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e92bbb90760c6d3a55d9685228cf2e99dd40e8f/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e92bbb90760c6d3a55d9685228cf2e99dd40e8f/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=1e92bbb90760c6d3a55d9685228cf2e99dd40e8f", "patch": "@@ -491,7 +491,7 @@ normalize (REAL_VALUE_TYPE *r)\n   if (i < 0)\n     {\n       r->class = rvc_zero;\n-      r->exp = 0;\n+      SET_REAL_EXP (r, 0);\n       return;\n     }\n \n@@ -503,14 +503,14 @@ normalize (REAL_VALUE_TYPE *r)\n \n   if (shift > 0)\n     {\n-      exp = r->exp - shift;\n+      exp = REAL_EXP (r) - shift;\n       if (exp > MAX_EXP)\n \tget_inf (r, r->sign);\n       else if (exp < -MAX_EXP)\n \tget_zero (r, r->sign);\n       else\n \t{\n-\t  r->exp = exp;\n+\t  SET_REAL_EXP (r, exp);\n \t  lshift_significand (r, r, shift);\n \t}\n     }\n@@ -581,15 +581,15 @@ do_add (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n     }\n \n   /* Swap the arguments such that A has the larger exponent.  */\n-  dexp = a->exp - b->exp;\n+  dexp = REAL_EXP (a) - REAL_EXP (b);\n   if (dexp < 0)\n     {\n       const REAL_VALUE_TYPE *t;\n       t = a, a = b, b = t;\n       dexp = -dexp;\n       sign ^= subtract_p;\n     }\n-  exp = a->exp;\n+  exp = REAL_EXP (a);\n \n   /* If the exponents are not identical, we need to shift the\n      significand of B down.  */\n@@ -639,7 +639,7 @@ do_add (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n \n   r->class = rvc_normal;\n   r->sign = sign;\n-  r->exp = exp;\n+  SET_REAL_EXP (r, exp);\n \n   /* Re-normalize the result.  */\n   normalize (r);\n@@ -748,8 +748,8 @@ do_multiply (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n \n       for (j = 0; j < 2; ++j)\n \t{\n-\t  int exp = (a->exp - (2*SIGSZ-1-i)*(HOST_BITS_PER_LONG/2)\n-\t\t     + (b->exp - (1-j)*(HOST_BITS_PER_LONG/2)));\n+\t  int exp = (REAL_EXP (a) - (2*SIGSZ-1-i)*(HOST_BITS_PER_LONG/2)\n+\t\t     + (REAL_EXP (b) - (1-j)*(HOST_BITS_PER_LONG/2)));\n \n \t  if (exp > MAX_EXP)\n \t    {\n@@ -765,7 +765,7 @@ do_multiply (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n \n \t  memset (&u, 0, sizeof (u));\n \t  u.class = rvc_normal;\n-\t  u.exp = exp;\n+\t  SET_REAL_EXP (&u, exp);\n \n \t  for (k = j; k < SIGSZ * 2; k += 2)\n \t    {\n@@ -863,7 +863,7 @@ do_divide (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n   rr->class = rvc_normal;\n   rr->sign = sign;\n \n-  exp = a->exp - b->exp + 1;\n+  exp = REAL_EXP (a) - REAL_EXP (b) + 1;\n   if (exp > MAX_EXP)\n     {\n       get_inf (r, sign);\n@@ -874,7 +874,7 @@ do_divide (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n       get_zero (r, sign);\n       return true;\n     }\n-  rr->exp = exp;\n+  SET_REAL_EXP (rr, exp);\n \n   inexact = div_significands (rr, a, b);\n \n@@ -935,9 +935,9 @@ do_compare (const REAL_VALUE_TYPE *a, const REAL_VALUE_TYPE *b,\n   if (a->sign != b->sign)\n     return -a->sign - -b->sign;\n \n-  if (a->exp > b->exp)\n+  if (REAL_EXP (a) > REAL_EXP (b))\n     ret = 1;\n-  else if (a->exp < b->exp)\n+  else if (REAL_EXP (a) < REAL_EXP (b))\n     ret = -1;\n   else\n     ret = cmp_significands (a, b);\n@@ -960,10 +960,10 @@ do_fix_trunc (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a)\n       break;\n \n     case rvc_normal:\n-      if (r->exp <= 0)\n+      if (REAL_EXP (r) <= 0)\n \tget_zero (r, r->sign);\n-      else if (r->exp < SIGNIFICAND_BITS)\n-\tclear_significand_below (r, SIGNIFICAND_BITS - r->exp);\n+      else if (REAL_EXP (r) < SIGNIFICAND_BITS)\n+\tclear_significand_below (r, SIGNIFICAND_BITS - REAL_EXP (r));\n       break;\n \n     default:\n@@ -1099,7 +1099,7 @@ real_exponent (const REAL_VALUE_TYPE *r)\n     case rvc_nan:\n       return (unsigned int)-1 >> 1;\n     case rvc_normal:\n-      return r->exp;\n+      return REAL_EXP (r);\n     default:\n       abort ();\n     }\n@@ -1119,13 +1119,13 @@ real_ldexp (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *op0, int exp)\n       break;\n \n     case rvc_normal:\n-      exp += op0->exp;\n+      exp += REAL_EXP (op0);\n       if (exp > MAX_EXP)\n \tget_inf (r, r->sign);\n       else if (exp < -MAX_EXP)\n \tget_zero (r, r->sign);\n       else\n-\tr->exp = exp;\n+\tSET_REAL_EXP (r, exp);\n       break;\n \n     default:\n@@ -1184,7 +1184,7 @@ real_identical (const REAL_VALUE_TYPE *a, const REAL_VALUE_TYPE *b)\n       return true;\n \n     case rvc_normal:\n-      if (a->exp != b->exp)\n+      if (REAL_EXP (a) != REAL_EXP (b))\n \treturn false;\n       break;\n \n@@ -1266,13 +1266,13 @@ real_to_integer (const REAL_VALUE_TYPE *r)\n       return i;\n \n     case rvc_normal:\n-      if (r->exp <= 0)\n+      if (REAL_EXP (r) <= 0)\n \tgoto underflow;\n       /* Only force overflow for unsigned overflow.  Signed overflow is\n \t undefined, so it doesn't matter what we return, and some callers\n \t expect to be able to use this routine for both signed and\n \t unsigned conversions.  */\n-      if (r->exp > HOST_BITS_PER_WIDE_INT)\n+      if (REAL_EXP (r) > HOST_BITS_PER_WIDE_INT)\n \tgoto overflow;\n \n       if (HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG)\n@@ -1286,7 +1286,7 @@ real_to_integer (const REAL_VALUE_TYPE *r)\n       else\n \tabort ();\n \n-      i >>= HOST_BITS_PER_WIDE_INT - r->exp;\n+      i >>= HOST_BITS_PER_WIDE_INT - REAL_EXP (r);\n \n       if (r->sign)\n \ti = -i;\n@@ -1328,7 +1328,7 @@ real_to_integer2 (HOST_WIDE_INT *plow, HOST_WIDE_INT *phigh,\n       break;\n \n     case rvc_normal:\n-      exp = r->exp;\n+      exp = REAL_EXP (r);\n       if (exp <= 0)\n \tgoto underflow;\n       /* Only force overflow for unsigned overflow.  Signed overflow is\n@@ -1383,7 +1383,7 @@ static unsigned long\n rtd_divmod (REAL_VALUE_TYPE *num, REAL_VALUE_TYPE *den)\n {\n   unsigned long q, msb;\n-  int expn = num->exp, expd = den->exp;\n+  int expn = REAL_EXP (num), expd = REAL_EXP (den);\n \n   if (expn < expd)\n     return 0;\n@@ -1404,7 +1404,7 @@ rtd_divmod (REAL_VALUE_TYPE *num, REAL_VALUE_TYPE *den)\n     }\n   while (--expn >= expd);\n \n-  num->exp = expd;\n+  SET_REAL_EXP (num, expd);\n   normalize (num);\n \n   return q;\n@@ -1455,7 +1455,7 @@ real_to_decimal (char *str, const REAL_VALUE_TYPE *r_orig, size_t buf_size,\n   /* Estimate the decimal exponent, and compute the length of the string it\n      will print as.  Be conservative and add one to account for possible\n      overflow or rounding error.  */\n-  dec_exp = r.exp * M_LOG10_2;\n+  dec_exp = REAL_EXP (&r) * M_LOG10_2;\n   for (max_digits = 1; dec_exp ; max_digits++)\n     dec_exp /= 10;\n \n@@ -1484,7 +1484,7 @@ real_to_decimal (char *str, const REAL_VALUE_TYPE *r_orig, size_t buf_size,\n \t and strip trailing decimal zeros.  */\n \n       u = r;\n-      u.exp = SIGNIFICAND_BITS - 1;\n+      SET_REAL_EXP (&u, SIGNIFICAND_BITS - 1);\n \n       /* Largest M, such that 10**2**M fits within SIGNIFICAND_BITS.  */\n       m = floor_log2 (max_digits);\n@@ -1508,15 +1508,16 @@ real_to_decimal (char *str, const REAL_VALUE_TYPE *r_orig, size_t buf_size,\n       while (--m >= 0);\n \n       /* Revert the scaling to integer that we performed earlier.  */\n-      u.exp += r.exp - (SIGNIFICAND_BITS - 1);\n+      SET_REAL_EXP (&u, REAL_EXP (&u) + REAL_EXP (&r)\n+\t\t    - (SIGNIFICAND_BITS - 1));\n       r = u;\n \n       /* Find power of 10.  Do this by dividing out 10**2**M when\n \t this is larger than the current remainder.  Fill PTEN with\n \t the power of 10 that we compute.  */\n-      if (r.exp > 0)\n+      if (REAL_EXP (&r) > 0)\n \t{\n-\t  m = floor_log2 ((int)(r.exp * M_LOG10_2)) + 1;\n+\t  m = floor_log2 ((int)(REAL_EXP (&r) * M_LOG10_2)) + 1;\n \t  do\n \t    {\n \t      const REAL_VALUE_TYPE *ptentwo = ten_to_ptwo (m);\n@@ -1552,7 +1553,7 @@ real_to_decimal (char *str, const REAL_VALUE_TYPE *r_orig, size_t buf_size,\n \t  do_multiply (&u, &v, ten);\n \n \t  /* Stop if we're now >= 1.  */\n-\t  if (u.exp > 0)\n+\t  if (REAL_EXP (&u) > 0)\n \t    break;\n \n \t  v = u;\n@@ -1563,7 +1564,7 @@ real_to_decimal (char *str, const REAL_VALUE_TYPE *r_orig, size_t buf_size,\n       /* Find power of 10.  Do this by multiplying in P=10**2**M when\n \t the current remainder is smaller than 1/P.  Fill PTEN with the\n \t power of 10 that we compute.  */\n-      m = floor_log2 ((int)(-r.exp * M_LOG10_2)) + 1;\n+      m = floor_log2 ((int)(-REAL_EXP (&r) * M_LOG10_2)) + 1;\n       do\n \t{\n \t  const REAL_VALUE_TYPE *ptentwo = ten_to_ptwo (m);\n@@ -1690,7 +1691,7 @@ void\n real_to_hexadecimal (char *str, const REAL_VALUE_TYPE *r, size_t buf_size,\n \t\t     size_t digits, int crop_trailing_zeros)\n {\n-  int i, j, exp = r->exp;\n+  int i, j, exp = REAL_EXP (r);\n   char *p, *first;\n   char exp_buf[16];\n   size_t max_digits;\n@@ -1849,7 +1850,7 @@ real_from_string (REAL_VALUE_TYPE *r, const char *str)\n \t}\n \n       r->class = rvc_normal;\n-      r->exp = exp;\n+      SET_REAL_EXP (r, exp);\n \n       normalize (r);\n     }\n@@ -1962,7 +1963,7 @@ real_from_integer (REAL_VALUE_TYPE *r, enum machine_mode mode,\n     {\n       r->class = rvc_normal;\n       r->sign = high < 0 && !unsigned_p;\n-      r->exp = 2 * HOST_BITS_PER_WIDE_INT;\n+      SET_REAL_EXP (r, 2 * HOST_BITS_PER_WIDE_INT);\n \n       if (r->sign)\n \t{\n@@ -2205,7 +2206,7 @@ real_maxval (REAL_VALUE_TYPE *r, int sign, enum machine_mode mode)\n   r->sign = sign;\n   r->signalling = 0;\n   r->canonical = 0;\n-  r->exp = fmt->emax * fmt->log2_b;\n+  SET_REAL_EXP (r, fmt->emax * fmt->log2_b);\n \n   np2 = SIGNIFICAND_BITS - fmt->p * fmt->log2_b;\n   memset (r->sig, -1, SIGSZ * sizeof (unsigned long));\n@@ -2227,7 +2228,7 @@ real_2expN (REAL_VALUE_TYPE *r, int n)\n   else\n     {\n       r->class = rvc_normal;\n-      r->exp = n;\n+      SET_REAL_EXP (r, n);\n       r->sig[SIGSZ-1] = SIG_MSB;\n     }\n }\n@@ -2275,38 +2276,38 @@ round_for_format (const struct real_format *fmt, REAL_VALUE_TYPE *r)\n      the true base.  */\n   if (fmt->log2_b != 1)\n     {\n-      int shift = r->exp & (fmt->log2_b - 1);\n+      int shift = REAL_EXP (r) & (fmt->log2_b - 1);\n       if (shift)\n \t{\n \t  shift = fmt->log2_b - shift;\n \t  r->sig[0] |= sticky_rshift_significand (r, r, shift);\n-\t  r->exp += shift;\n+\t  SET_REAL_EXP (r, REAL_EXP (r) + shift);\n \t}\n     }\n \n   /* Check the range of the exponent.  If we're out of range,\n      either underflow or overflow.  */\n-  if (r->exp > emax2)\n+  if (REAL_EXP (r) > emax2)\n     goto overflow;\n-  else if (r->exp <= emin2m1)\n+  else if (REAL_EXP (r) <= emin2m1)\n     {\n       int diff;\n \n       if (!fmt->has_denorm)\n \t{\n \t  /* Don't underflow completely until we've had a chance to round.  */\n-\t  if (r->exp < emin2m1)\n+\t  if (REAL_EXP (r) < emin2m1)\n \t    goto underflow;\n \t}\n       else\n \t{\n-\t  diff = emin2m1 - r->exp + 1;\n+\t  diff = emin2m1 - REAL_EXP (r) + 1;\n \t  if (diff > p2)\n \t    goto underflow;\n \n \t  /* De-normalize the significand.  */\n \t  r->sig[0] |= sticky_rshift_significand (r, r, diff);\n-\t  r->exp += diff;\n+\t  SET_REAL_EXP (r, REAL_EXP (r) + diff);\n \t}\n     }\n \n@@ -2335,27 +2336,28 @@ round_for_format (const struct real_format *fmt, REAL_VALUE_TYPE *r)\n \t  /* Overflow.  Means the significand had been all ones, and\n \t     is now all zeros.  Need to increase the exponent, and\n \t     possibly re-normalize it.  */\n-\t  if (++r->exp > emax2)\n+\t  SET_REAL_EXP (r, REAL_EXP (r) + 1);\n+\t  if (REAL_EXP (r) > emax2)\n \t    goto overflow;\n \t  r->sig[SIGSZ-1] = SIG_MSB;\n \n \t  if (fmt->log2_b != 1)\n \t    {\n-\t      int shift = r->exp & (fmt->log2_b - 1);\n+\t      int shift = REAL_EXP (r) & (fmt->log2_b - 1);\n \t      if (shift)\n \t\t{\n \t\t  shift = fmt->log2_b - shift;\n \t\t  rshift_significand (r, r, shift);\n-\t\t  r->exp += shift;\n-\t\t  if (r->exp > emax2)\n+\t\t  SET_REAL_EXP (r, REAL_EXP (r) + shift);\n+\t\t  if (REAL_EXP (r) > emax2)\n \t\t    goto overflow;\n \t\t}\n \t    }\n \t}\n     }\n \n   /* Catch underflow that we deferred until after rounding.  */\n-  if (r->exp <= emin2m1)\n+  if (REAL_EXP (r) <= emin2m1)\n     goto underflow;\n \n   /* Clear out trailing garbage.  */\n@@ -2497,7 +2499,7 @@ real_hash (const REAL_VALUE_TYPE *r)\n       return h;\n \n     case rvc_normal:\n-      h |= r->exp << 3;\n+      h |= REAL_EXP (r) << 3;\n       break;\n \n     case rvc_nan:\n@@ -2586,7 +2588,7 @@ encode_ieee_single (const struct real_format *fmt, long *buf,\n       if (denormal)\n \texp = 0;\n       else\n-      exp = r->exp + 127 - 1;\n+      exp = REAL_EXP (r) + 127 - 1;\n       image |= exp << 23;\n       image |= sig;\n       break;\n@@ -2616,7 +2618,7 @@ decode_ieee_single (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n \t{\n \t  r->class = rvc_normal;\n \t  r->sign = sign;\n-\t  r->exp = -126;\n+\t  SET_REAL_EXP (r, -126);\n \t  r->sig[SIGSZ-1] = image << 1;\n \t  normalize (r);\n \t}\n@@ -2643,7 +2645,7 @@ decode_ieee_single (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n     {\n       r->class = rvc_normal;\n       r->sign = sign;\n-      r->exp = exp - 127 + 1;\n+      SET_REAL_EXP (r, exp - 127 + 1);\n       r->sig[SIGSZ-1] = image | SIG_MSB;\n     }\n }\n@@ -2770,7 +2772,7 @@ encode_ieee_double (const struct real_format *fmt, long *buf,\n       if (denormal)\n \texp = 0;\n       else\n-\texp = r->exp + 1023 - 1;\n+\texp = REAL_EXP (r) + 1023 - 1;\n       image_hi |= exp << 20;\n       image_hi |= sig_hi;\n       image_lo = sig_lo;\n@@ -2817,7 +2819,7 @@ decode_ieee_double (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n \t{\n \t  r->class = rvc_normal;\n \t  r->sign = sign;\n-\t  r->exp = -1022;\n+\t  SET_REAL_EXP (r, -1022);\n \t  if (HOST_BITS_PER_LONG == 32)\n \t    {\n \t      image_hi = (image_hi << 1) | (image_lo >> 31);\n@@ -2860,7 +2862,7 @@ decode_ieee_double (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n     {\n       r->class = rvc_normal;\n       r->sign = sign;\n-      r->exp = exp - 1023 + 1;\n+      SET_REAL_EXP (r, exp - 1023 + 1);\n       if (HOST_BITS_PER_LONG == 32)\n \t{\n \t  r->sig[SIGSZ-1] = image_hi | SIG_MSB;\n@@ -2990,7 +2992,7 @@ encode_ieee_extended (const struct real_format *fmt, long *buf,\n \n     case rvc_normal:\n       {\n-\tint exp = r->exp;\n+\tint exp = REAL_EXP (r);\n \n \t/* Recall that IEEE numbers are interpreted as 1.F x 2**exp,\n \t   whereas the intermediate representation is 0.F x 2**exp.\n@@ -3076,7 +3078,7 @@ decode_ieee_extended (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n \t     and decrease the exponent to match.  In this case, Motorola\n \t     defines the explicit integer bit to be valid, so we don't\n \t     know whether the msb is set or not.  */\n-\t  r->exp = fmt->emin;\n+\t  SET_REAL_EXP (r, fmt->emin);\n \t  if (HOST_BITS_PER_LONG == 32)\n \t    {\n \t      r->sig[SIGSZ-1] = sig_hi;\n@@ -3120,7 +3122,7 @@ decode_ieee_extended (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n     {\n       r->class = rvc_normal;\n       r->sign = sign;\n-      r->exp = exp - 16383 + 1;\n+      SET_REAL_EXP (r, exp - 16383 + 1);\n       if (HOST_BITS_PER_LONG == 32)\n \t{\n \t  r->sig[SIGSZ-1] = sig_hi;\n@@ -3414,7 +3416,7 @@ encode_ieee_quad (const struct real_format *fmt, long *buf,\n       if (denormal)\n \texp = 0;\n       else\n-\texp = r->exp + 16383 - 1;\n+\texp = REAL_EXP (r) + 16383 - 1;\n       image3 |= exp << 16;\n \n       if (HOST_BITS_PER_LONG == 32)\n@@ -3494,7 +3496,7 @@ decode_ieee_quad (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n \t  r->class = rvc_normal;\n \t  r->sign = sign;\n \n-\t  r->exp = -16382 + (SIGNIFICAND_BITS - 112);\n+\t  SET_REAL_EXP (r, -16382 + (SIGNIFICAND_BITS - 112));\n \t  if (HOST_BITS_PER_LONG == 32)\n \t    {\n \t      r->sig[0] = image0;\n@@ -3545,7 +3547,7 @@ decode_ieee_quad (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n     {\n       r->class = rvc_normal;\n       r->sign = sign;\n-      r->exp = exp - 16383 + 1;\n+      SET_REAL_EXP (r, exp - 16383 + 1);\n \n       if (HOST_BITS_PER_LONG == 32)\n \t{\n@@ -3644,7 +3646,7 @@ encode_vax_f (const struct real_format *fmt ATTRIBUTE_UNUSED, long *buf,\n \n     case rvc_normal:\n       sig = (r->sig[SIGSZ-1] >> (HOST_BITS_PER_LONG - 24)) & 0x7fffff;\n-      exp = r->exp + 128;\n+      exp = REAL_EXP (r) + 128;\n \n       image = (sig << 16) & 0xffff0000;\n       image |= sign;\n@@ -3672,7 +3674,7 @@ decode_vax_f (const struct real_format *fmt ATTRIBUTE_UNUSED,\n     {\n       r->class = rvc_normal;\n       r->sign = (image >> 15) & 1;\n-      r->exp = exp - 128;\n+      SET_REAL_EXP (r, exp - 128);\n \n       image = ((image & 0x7f) << 16) | ((image >> 16) & 0xffff);\n       r->sig[SIGSZ-1] = (image << (HOST_BITS_PER_LONG - 24)) | SIG_MSB;\n@@ -3720,7 +3722,7 @@ encode_vax_d (const struct real_format *fmt ATTRIBUTE_UNUSED, long *buf,\n \n       /* Add the sign and exponent.  */\n       image0 |= sign;\n-      image0 |= (r->exp + 128) << 7;\n+      image0 |= (REAL_EXP (r) + 128) << 7;\n       break;\n \n     default:\n@@ -3755,7 +3757,7 @@ decode_vax_d (const struct real_format *fmt ATTRIBUTE_UNUSED,\n     {\n       r->class = rvc_normal;\n       r->sign = (image0 >> 15) & 1;\n-      r->exp = exp - 128;\n+      SET_REAL_EXP (r, exp - 128);\n \n       /* Rearrange the half-words of the external format into\n \t proper ascending order.  */\n@@ -3820,7 +3822,7 @@ encode_vax_g (const struct real_format *fmt ATTRIBUTE_UNUSED, long *buf,\n \n       /* Add the sign and exponent.  */\n       image0 |= sign;\n-      image0 |= (r->exp + 1024) << 4;\n+      image0 |= (REAL_EXP (r) + 1024) << 4;\n       break;\n \n     default:\n@@ -3855,7 +3857,7 @@ decode_vax_g (const struct real_format *fmt ATTRIBUTE_UNUSED,\n     {\n       r->class = rvc_normal;\n       r->sign = (image0 >> 15) & 1;\n-      r->exp = exp - 1024;\n+      SET_REAL_EXP (r, exp - 1024);\n \n       /* Rearrange the half-words of the external format into\n \t proper ascending order.  */\n@@ -3970,7 +3972,7 @@ encode_i370_single (const struct real_format *fmt ATTRIBUTE_UNUSED,\n \n     case rvc_normal:\n       sig = (r->sig[SIGSZ-1] >> (HOST_BITS_PER_LONG - 24)) & 0xffffff;\n-      exp = ((r->exp / 4) + 64) << 24;\n+      exp = ((REAL_EXP (r) / 4) + 64) << 24;\n       image = sign | exp | sig;\n       break;\n \n@@ -3998,7 +4000,7 @@ decode_i370_single (const struct real_format *fmt ATTRIBUTE_UNUSED,\n     {\n       r->class = rvc_normal;\n       r->sign = sign;\n-      r->exp = (exp - 64) * 4;\n+      SET_REAL_EXP (r, (exp - 64) * 4);\n       r->sig[SIGSZ-1] = sig << (HOST_BITS_PER_LONG - 24);\n       normalize (r);\n     }\n@@ -4039,7 +4041,7 @@ encode_i370_double (const struct real_format *fmt ATTRIBUTE_UNUSED,\n \t  image_hi >>= 8;\n \t}\n \n-      exp = ((r->exp / 4) + 64) << 24;\n+      exp = ((REAL_EXP (r) / 4) + 64) << 24;\n       image_hi |= sign | exp;\n       break;\n \n@@ -4076,7 +4078,7 @@ decode_i370_double (const struct real_format *fmt ATTRIBUTE_UNUSED,\n     {\n       r->class = rvc_normal;\n       r->sign = sign;\n-      r->exp = (exp - 64) * 4 + (SIGNIFICAND_BITS - 56);\n+      SET_REAL_EXP (r, (exp - 64) * 4 + (SIGNIFICAND_BITS - 56));\n \n       if (HOST_BITS_PER_LONG == 32)\n \t{\n@@ -4174,7 +4176,7 @@ encode_c4x_single (const struct real_format *fmt ATTRIBUTE_UNUSED,\n       break;\n \n     case rvc_normal:\n-      exp = r->exp - 1;\n+      exp = REAL_EXP (r) - 1;\n       sig = (r->sig[SIGSZ-1] >> (HOST_BITS_PER_LONG - 24)) & 0x7fffff;\n       if (r->sign)\n \t{\n@@ -4222,7 +4224,7 @@ decode_c4x_single (const struct real_format *fmt ATTRIBUTE_UNUSED,\n \t}\n       sig = (sig << (HOST_BITS_PER_LONG - 24)) | SIG_MSB;\n \n-      r->exp = exp + 1;\n+      SET_REAL_EXP (r, exp + 1);\n       r->sig[SIGSZ-1] = sig;\n     }\n }\n@@ -4247,7 +4249,7 @@ encode_c4x_extended (const struct real_format *fmt ATTRIBUTE_UNUSED,\n       break;\n \n     case rvc_normal:\n-      exp = r->exp - 1;\n+      exp = REAL_EXP (r) - 1;\n \n       sig = r->sig[SIGSZ-1];\n       if (HOST_BITS_PER_LONG == 64)\n@@ -4311,7 +4313,7 @@ decode_c4x_extended (const struct real_format *fmt ATTRIBUTE_UNUSED,\n \tsig = sig << 1 << 31;\n       sig |= SIG_MSB;\n \n-      r->exp = exp + 1;\n+      SET_REAL_EXP (r, exp + 1);\n       r->sig[SIGSZ-1] = sig;\n     }\n }"}, {"sha": "475ab4563fe709397de08cdedc2a60d240fc647b", "filename": "gcc/real.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e92bbb90760c6d3a55d9685228cf2e99dd40e8f/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e92bbb90760c6d3a55d9685228cf2e99dd40e8f/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=1e92bbb90760c6d3a55d9685228cf2e99dd40e8f", "patch": "@@ -42,14 +42,23 @@ enum real_value_class {\n \n struct real_value GTY(())\n {\n-  ENUM_BITFIELD (real_value_class) class : 2;\n+  /* Use the same underlying type for all bit-fields, so as to make\n+     sure they're packed together, otherwise REAL_VALUE_TYPE_SIZE will\n+     be miscomputed.  */\n+  unsigned int /* ENUM_BITFIELD (real_value_class) */ class : 2;\n   unsigned int sign : 1;\n   unsigned int signalling : 1;\n   unsigned int canonical : 1;\n-  signed int exp : EXP_BITS;\n+  unsigned int uexp : EXP_BITS;\n   unsigned long sig[SIGSZ];\n };\n \n+#define REAL_EXP(REAL) \\\n+  ((int)((REAL)->uexp ^ (unsigned int)(1 << (EXP_BITS - 1))) \\\n+   - (1 << (EXP_BITS - 1)))\n+#define SET_REAL_EXP(REAL, EXP) \\\n+  ((REAL)->uexp = ((unsigned int)(EXP) & (unsigned int)((1 << EXP_BITS) - 1)))\n+\n /* Various headers condition prototypes on #ifdef REAL_VALUE_TYPE, so it\n    needs to be a macro.  We do need to continue to have a structure tag\n    so that other headers can forward declare it.  */"}]}