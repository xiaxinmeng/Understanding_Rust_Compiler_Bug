{"sha": "fc90a8f2eeefbac428a73d6ea8c146f8e5446154", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM5MGE4ZjJlZWVmYmFjNDI4YTczZDZlYThjMTQ2ZjhlNTQ0NjE1NA==", "commit": {"author": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-08-06T15:01:10Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-08-06T15:01:10Z"}, "message": "trans-array.c (gfc_trans_allocate_array_storage, [...]): For functions...\n\n\t* trans-array.c (gfc_trans_allocate_array_storage,\n\tgfc_trans_allocate_temp_array, gfc_add_loop_ss_code,\n\tgfc_conv_loop_setup):\n\tFor functions, if the shape of the result is not known\n\tin compile-time, generate an empty array descriptor for\n\tthe result and let the callee to allocate the memory.\n\t(gfc_trans_dummy_array_bias): Do nothing for pointers.\n\t(gfc_conv_expr_descriptor): Use function return values directly.\n\t* trans-expr.c (gfc_conv_function_call): Always add byref call\n\tinsn to pre chain.\n\t(gfc_trans_pointer_assignment): Add comments.\n\t(gfc_trans_arrayfunc_assign): Don't chain on expression.\ntestsuite/\n\t* gfortran.dg/ret_array_1.f90: New test.\n\t* gfortran.dg/ret_pointer_1.f90: New test.\n\nFrom-SVN: r85642", "tree": {"sha": "dbe748fd35c50e2ed5669c9b2a7e62111f61759b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbe748fd35c50e2ed5669c9b2a7e62111f61759b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc90a8f2eeefbac428a73d6ea8c146f8e5446154", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc90a8f2eeefbac428a73d6ea8c146f8e5446154", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc90a8f2eeefbac428a73d6ea8c146f8e5446154", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc90a8f2eeefbac428a73d6ea8c146f8e5446154/comments", "author": null, "committer": null, "parents": [{"sha": "160ff372bdfdc91ecaf2aad59f865de95c5be2df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/160ff372bdfdc91ecaf2aad59f865de95c5be2df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/160ff372bdfdc91ecaf2aad59f865de95c5be2df"}], "stats": {"total": 359, "additions": 291, "deletions": 68}, "files": [{"sha": "a3e1480a15f424b640a60216415684f338262c27", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc90a8f2eeefbac428a73d6ea8c146f8e5446154/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc90a8f2eeefbac428a73d6ea8c146f8e5446154/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fc90a8f2eeefbac428a73d6ea8c146f8e5446154", "patch": "@@ -1,3 +1,18 @@\n+2004-08-06  Victor Leikehman  <lei@il.ibm.com>\n+\tPaul Brook  <paul@codesourcery.com>\n+\n+\t* trans-array.c (gfc_trans_allocate_array_storage,\n+\tgfc_trans_allocate_temp_array, gfc_add_loop_ss_code,\n+\tgfc_conv_loop_setup): For functions, if the shape of the result\n+\tis not known in compile-time, generate an empty array descriptor for\n+\tthe result and let the callee to allocate the memory.\n+\t(gfc_trans_dummy_array_bias): Do nothing for pointers.\n+\t(gfc_conv_expr_descriptor): Use function return values directly.\n+\t* trans-expr.c (gfc_conv_function_call): Always add byref call\n+\tinsn to pre chain.\n+\t(gfc_trans_pointer_assignment): Add comments.\n+\t(gfc_trans_arrayfunc_assign): Don't chain on expression.\n+\n 2004-08-01  Roger Sayle  <roger@eyesopen.com>\n \n \t* options.c (gfc_init_options): Don't warn about the use GNU"}, {"sha": "b950ec9243d5b48bf8db2c7742c4d44c2aec536b", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 158, "deletions": 51, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc90a8f2eeefbac428a73d6ea8c146f8e5446154/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc90a8f2eeefbac428a73d6ea8c146f8e5446154/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=fc90a8f2eeefbac428a73d6ea8c146f8e5446154", "patch": "@@ -436,7 +436,9 @@ gfc_trans_static_array_pointer (gfc_symbol * sym)\n \n \n /* Generate code to allocate an array temporary, or create a variable to\n-   hold the data.  */\n+   hold the data.  If size is NULL zero the descriptor so that so that the\n+   callee will allocate the array.  Also generates code to free the array\n+   afterwards.  */\n \n static void\n gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n@@ -450,38 +452,54 @@ gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n \n   desc = info->descriptor;\n   data = gfc_conv_descriptor_data (desc);\n-  onstack = gfc_can_put_var_on_stack (size);\n-  if (onstack)\n+  if (size == NULL_TREE)\n     {\n-      /* Make a temporary variable to hold the data.  */\n-      tmp = fold (build (MINUS_EXPR, TREE_TYPE (nelem), nelem,\n-\t\t\t integer_one_node));\n-      tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node, tmp);\n-      tmp = build_array_type (gfc_get_element_type (TREE_TYPE (desc)), tmp);\n-      tmp = gfc_create_var (tmp, \"A\");\n-      tmp = gfc_build_addr_expr (TREE_TYPE (data), tmp);\n-      gfc_add_modify_expr (&loop->pre, data, tmp);\n+      /* A callee allocated array.  */\n+      gfc_add_modify_expr (&loop->pre, data, convert (TREE_TYPE (data), \n+                                                      gfc_index_zero_node));\n       info->data = data;\n       info->offset = gfc_index_zero_node;\n-\n+      onstack = FALSE;\n     }\n   else\n     {\n-      /* Allocate memory to hold the data.  */\n-      args = gfc_chainon_list (NULL_TREE, size);\n+      /* Allocate the temporary.  */\n+      onstack = gfc_can_put_var_on_stack (size);\n+\n+      if (onstack)\n+\t{\n+\t  /* Make a temporary variable to hold the data.  */\n+\t  tmp = fold (build (MINUS_EXPR, TREE_TYPE (nelem), nelem,\n+\t\t\t     integer_one_node));\n+\t  tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node,\n+\t\t\t\t  tmp);\n+\t  tmp = build_array_type (gfc_get_element_type (TREE_TYPE (desc)),\n+\t\t\t\t  tmp);\n+\t  tmp = gfc_create_var (tmp, \"A\");\n+\t  tmp = gfc_build_addr_expr (TREE_TYPE (data), tmp);\n+\t  gfc_add_modify_expr (&loop->pre, data, tmp);\n+\t  info->data = data;\n+\t  info->offset = gfc_index_zero_node;\n \n-      if (gfc_index_integer_kind == 4)\n-\ttmp = gfor_fndecl_internal_malloc;\n-      else if (gfc_index_integer_kind == 8)\n-\ttmp = gfor_fndecl_internal_malloc64;\n+\t}\n       else\n-\tabort ();\n-      tmp = gfc_build_function_call (tmp, args);\n-      tmp = convert (TREE_TYPE (data), tmp);\n-      gfc_add_modify_expr (&loop->pre, data, tmp);\n+\t{\n+\t  /* Allocate memory to hold the data.  */\n+\t  args = gfc_chainon_list (NULL_TREE, size);\n \n-      info->data = data;\n-      info->offset = gfc_index_zero_node;\n+\t  if (gfc_index_integer_kind == 4)\n+\t    tmp = gfor_fndecl_internal_malloc;\n+\t  else if (gfc_index_integer_kind == 8)\n+\t    tmp = gfor_fndecl_internal_malloc64;\n+\t  else\n+\t    abort ();\n+\t  tmp = gfc_build_function_call (tmp, args);\n+\t  tmp = convert (TREE_TYPE (data), tmp);\n+\t  gfc_add_modify_expr (&loop->pre, data, tmp);\n+\n+\t  info->data = data;\n+\t  info->offset = gfc_index_zero_node;\n+\t}\n     }\n \n   /* The offset is zero because we create temporaries with a zero\n@@ -501,9 +519,11 @@ gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n \n \n /* Generate code to allocate and initialize the descriptor for a temporary\n-   array.  Fills in the descriptor, data and offset fields of info.  Also\n-   adjusts the loop variables to be zero-based.  Returns the size of the\n-   array.  */\n+   array.  This is used for both temporaries needed by the scaparizer, and\n+   functions returning arrays.  Adjusts the loop variables to be zero-based,\n+   and calculates the loop bounds for callee allocated arrays.\n+   Also fills in the descriptor, data and offset fields of info if known.\n+   Returns the size of the array, or NULL for a callee allocated array.  */\n \n tree\n gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n@@ -526,7 +546,9 @@ gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n \tassert (integer_zerop (loop->from[n]));\n       else\n \t{\n-\t  loop->to[n] = fold (build (MINUS_EXPR, gfc_array_index_type,\n+\t  /* Callee allocated arrays may not have a known bound yet.  */\n+          if (loop->to[n])\n+              loop->to[n] = fold (build (MINUS_EXPR, gfc_array_index_type,\n \t\t\t\t     loop->to[n], loop->from[n]));\n \t  loop->from[n] = gfc_index_zero_node;\n \t}\n@@ -566,6 +588,18 @@ gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n \n   for (n = 0; n < info->dimen; n++)\n     {\n+      if (loop->to[n] == NULL_TREE)\n+        {\n+\t  /* For a callee allocated array express the loop bounds in terms\n+\t     of the descriptor fields.  */\n+          tmp = build (MINUS_EXPR, gfc_array_index_type,\n+                       gfc_conv_descriptor_ubound (desc, gfc_rank_cst[n]),\n+                       gfc_conv_descriptor_lbound (desc, gfc_rank_cst[n]));\n+          loop->to[n] = tmp;\n+          size = NULL_TREE;\n+          continue;\n+        }\n+        \n       /* Store the stride and bound components in the descriptor.  */\n       tmp = gfc_conv_descriptor_stride (desc, gfc_rank_cst[n]);\n       gfc_add_modify_expr (&loop->pre, tmp, size);\n@@ -589,7 +623,8 @@ gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n \n   /* Get the size of the array.  */\n   nelem = size;\n-  size = fold (build (MULT_EXPR, gfc_array_index_type, size,\n+  if (size)\n+    size = fold (build (MULT_EXPR, gfc_array_index_type, size,\n \t\t      TYPE_SIZE_UNIT (gfc_get_element_type (type))));\n \n   gfc_trans_allocate_array_storage (loop, info, size, nelem);\n@@ -985,7 +1020,6 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss)\n /* Add the pre and post chains for all the scalar expressions in a SS chain\n    to loop.  This is called after the loop parameters have been calculated,\n    but before the actual scalarizing loops.  */\n-/*GCC ARRAYS*/\n \n static void\n gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript)\n@@ -1065,6 +1099,10 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript)\n \t  gfc_trans_array_constructor (loop, ss);\n \t  break;\n \n+        case GFC_SS_TEMP:\n+          /* Do nothing.  This will be handled later.  */\n+          break;\n+\n \tdefault:\n \t  abort ();\n \t}\n@@ -2256,8 +2294,14 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t      continue;\n \t    }\n \n-\t  /* We don't know how to handle functions yet.\n-\t     This may not be possible in all cases.  */\n+\t  /* TODO: Pick the best bound if we have a choice between a\n+\t     functions and something else.  */\n+          if (ss->type == GFC_SS_FUNCTION)\n+            {\n+              loopspec[n] = ss;\n+              continue;\n+            }\n+\n \t  if (ss->type != GFC_SS_SECTION)\n \t    continue;\n \n@@ -2333,6 +2377,11 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t\t\t\t\t\t\t  &loop->pre);\n \t      break;\n \n+            case GFC_SS_FUNCTION:\n+\t      /* The loop bound will be set when we generate the call.  */\n+              assert (loop->to[n] == NULL_TREE);\n+              break;\n+\n \t    default:\n \t      abort ();\n \t    }\n@@ -2359,6 +2408,11 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t}\n     }\n \n+  /* Add all the scalar code that can be taken out of the loops.\n+     This may include calculating the loop bounds, so do it before\n+     allocating the temporary.  */\n+  gfc_add_loop_ss_code (loop, loop->ss, false);\n+\n   /* If we want a temporary then create it.  */\n   if (loop->temp_ss != NULL)\n     {\n@@ -2373,9 +2427,6 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t\t\t\t     tmp, len);\n     }\n \n-  /* Add all the scalar code that can be taken out of the loops.  */\n-  gfc_add_loop_ss_code (loop, loop->ss, false);\n-\n   for (n = 0; n < loop->temp_dim; n++)\n     loopspec[loop->order[n]] = NULL;\n \n@@ -3012,6 +3063,10 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n   int checkparm;\n   int no_repack;\n \n+  /* Do nothing for pointer and allocatable arrays.  */\n+  if (sym->attr.pointer || sym->attr.allocatable)\n+    return body;\n+\n   if (sym->attr.dummy && gfc_is_nodesc_array (sym))\n     return gfc_trans_g77_array (sym, body);\n \n@@ -3284,15 +3339,17 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n   tree start;\n   tree offset;\n   int full;\n+  gfc_ss *vss;\n \n   assert (ss != gfc_ss_terminator);\n \n   /* TODO: Pass constant array constructors without a temporary.  */\n-  /* If we have a linear array section, we can pass it directly.  Otherwise\n-     we need to copy it into a temporary.  */\n-  if (expr->expr_type == EXPR_VARIABLE)\n+  /* Special case things we know we can pass easily.  */\n+  switch (expr->expr_type)\n     {\n-      gfc_ss *vss;\n+    case EXPR_VARIABLE:\n+      /* If we have a linear array section, we can pass it directly.\n+\t Otherwise we need to copy it into a temporary.  */\n \n       /* Find the SS for the array section.  */\n       secss = ss;\n@@ -3352,8 +3409,8 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  else if (se->want_pointer)\n \t    {\n \t      /* We pass full arrays directly.  This means that pointers and\n-\t         allocatable arrays should also work.  */\n-\t      se->expr = gfc_build_addr_expr (NULL, desc);\n+\t\t allocatable arrays should also work.  */\n+\t      se->expr = gfc_build_addr_expr (NULL_TREE, desc);\n \t    }\n \t  else\n \t    {\n@@ -3363,14 +3420,53 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t    se->string_length = expr->symtree->n.sym->ts.cl->backend_decl;\n \t  return;\n \t}\n-    }\n-  else\n-    {\n+      break;\n+      \n+    case EXPR_FUNCTION:\n+      /* A transformational function return value will be a temporary\n+\t array descriptor.  We still need to go through the scalarizer\n+\t to create the descriptor.  Elemental functions ar handled as\n+\t arbitary expressions, ie. copy to a temporary.  */\n+      secss = ss;\n+      /* Look for the SS for this function.  */\n+      while (secss != gfc_ss_terminator\n+\t     && (secss->type != GFC_SS_FUNCTION || secss->expr != expr))\n+      \tsecss = secss->next;\n+\n+      if (se->direct_byref)\n+\t{\n+\t  assert (secss != gfc_ss_terminator);\n+\n+\t  /* For pointer assignments pass the descriptor directly.  */\n+\t  se->ss = secss;\n+\t  se->expr = gfc_build_addr_expr (NULL, se->expr);\n+\t  gfc_conv_expr (se, expr);\n+\t  return;\n+\t}\n+\n+      if (secss == gfc_ss_terminator)\n+\t{\n+\t  /* Elemental function.  */\n+\t  need_tmp = 1;\n+\t  info = NULL;\n+\t}\n+      else\n+\t{\n+\t  /* Transformational function.  */\n+\t  info = &secss->data.info;\n+\t  need_tmp = 0;\n+\t}\n+      break;\n+\n+    default:\n+      /* Something complicated.  Copy it into a temporary.  */\n       need_tmp = 1;\n       secss = NULL;\n       info = NULL;\n+      break;\n     }\n \n+\n   gfc_init_loopinfo (&loop);\n \n   /* Associate the SS with the loop.  */\n@@ -3445,11 +3541,25 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       assert (is_gimple_lvalue (desc));\n       se->expr = gfc_build_addr_expr (NULL, desc);\n     }\n+  else if (expr->expr_type == EXPR_FUNCTION)\n+    {\n+      desc = info->descriptor;\n+\n+      if (se->want_pointer)\n+\tse->expr = gfc_build_addr_expr (NULL_TREE, desc);\n+      else\n+\tse->expr = desc;\n+\n+      if (expr->ts.type == BT_CHARACTER)\n+\tse->string_length = expr->symtree->n.sym->ts.cl->backend_decl;\n+    }\n   else\n     {\n-      /* We pass sections without copying to a temporary.  A function may\n-         decide to repack the array to speed up access, but we're not\n-         bothered about that here.  */\n+      /* We pass sections without copying to a temporary.  Make a new\n+\t descriptor and point it at the section we want.  The loop variable\n+\t limits will be the limits of the section.\n+\t A function may decide to repack the array to speed up access, but\n+\t we're not bothered about that here.  */\n       int dim;\n       tree parm;\n       tree parmtype;\n@@ -3458,13 +3568,10 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       tree to;\n       tree base;\n \n-      /* set the string_length for a character array.  */\n+      /* Set the string_length for a character array.  */\n       if (expr->ts.type == BT_CHARACTER)\n \tse->string_length = expr->symtree->n.sym->ts.cl->backend_decl;\n \n-      /* Otherwise make a new descriptor and point it at the section we\n-         want.  The loop variable limits will be the limits of the section.\n-       */\n       desc = info->descriptor;\n       assert (secss && secss != gfc_ss_terminator);\n       if (se->direct_byref)"}, {"sha": "67f5809bab6338cd8955e403af41b1a82b102618", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc90a8f2eeefbac428a73d6ea8c146f8e5446154/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc90a8f2eeefbac428a73d6ea8c146f8e5446154/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=fc90a8f2eeefbac428a73d6ea8c146f8e5446154", "patch": "@@ -1171,29 +1171,34 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n     TREE_SIDE_EFFECTS (se->expr) = 1;\n #endif\n \n-  if (byref && !se->direct_byref)\n+  if (byref)\n     {\n+      /* Add the function call to the pre chain.  There is no expression.  */\n       gfc_add_expr_to_block (&se->pre, se->expr);\n+      se->expr = NULL_TREE;\n \n-      if (sym->result->attr.dimension)\n+      if (!se->direct_byref)\n \t{\n-\t  if (flag_bounds_check)\n+\t  if (sym->result->attr.dimension)\n \t    {\n-\t      /* Check the data pointer hasn't been modified.  This would happen\n-\t         in a function returning a pointer.  */\n-\t      tmp = gfc_conv_descriptor_data (info->descriptor);\n-\t      tmp = build (NE_EXPR, boolean_type_node, tmp, info->data);\n-\t      gfc_trans_runtime_check (tmp, gfc_strconst_fault, &se->pre);\n+\t      if (flag_bounds_check)\n+\t\t{\n+\t\t  /* Check the data pointer hasn't been modified.  This would\n+\t\t     happen in a function returning a pointer.  */\n+\t\t  tmp = gfc_conv_descriptor_data (info->descriptor);\n+\t\t  tmp = build (NE_EXPR, boolean_type_node, tmp, info->data);\n+\t\t  gfc_trans_runtime_check (tmp, gfc_strconst_fault, &se->pre);\n+\t\t}\n+\t      se->expr = info->descriptor;\n \t    }\n-\t  se->expr = info->descriptor;\n-\t}\n-      else if (sym->ts.type == BT_CHARACTER)\n-\t{\n-\t  se->expr = var;\n-\t  se->string_length = len;\n+\t  else if (sym->ts.type == BT_CHARACTER)\n+\t    {\n+\t      se->expr = var;\n+\t      se->string_length = len;\n+\t    }\n+\t  else\n+\t    abort ();\n \t}\n-      else\n-\tabort ();\n     }\n }\n \n@@ -1637,6 +1642,8 @@ gfc_trans_pointer_assign (gfc_code * code)\n }\n \n \n+/* Generate code for a pointer assignment.  */\n+\n tree\n gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n {\n@@ -1654,6 +1661,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n   rss = gfc_walk_expr (expr2);\n   if (lss == gfc_ss_terminator)\n     {\n+      /* Scalar pointers.  */\n       lse.want_pointer = 1;\n       gfc_conv_expr (&lse, expr1);\n       assert (rss == gfc_ss_terminator);\n@@ -1669,6 +1677,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n     }\n   else\n     {\n+      /* Array pointer.  */\n       gfc_conv_expr_descriptor (&lse, expr1, lss);\n       /* Implement Nullify.  */\n       if (expr2->expr_type == EXPR_NULL)\n@@ -1796,7 +1805,6 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n   se.ss = gfc_walk_expr (expr2);\n   assert (se.ss != gfc_ss_terminator);\n   gfc_conv_function_expr (&se, expr2);\n-  gfc_add_expr_to_block (&se.pre, se.expr);\n   gfc_add_block_to_block (&se.pre, &se.post);\n \n   return gfc_finish_block (&se.pre);"}, {"sha": "f2d9a977be5d3778b94f2c0c6f992107f4ef4856", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc90a8f2eeefbac428a73d6ea8c146f8e5446154/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc90a8f2eeefbac428a73d6ea8c146f8e5446154/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fc90a8f2eeefbac428a73d6ea8c146f8e5446154", "patch": "@@ -1,3 +1,8 @@\n+2004-08-06  Paul Brook  <paul@codesourcery.com>\n+\n+\t* gfortran.dg/ret_array_1.f90: New test.\n+\t* gfortran.dg/ret_pointer_1.f90: New test.\n+\n 2004-08-06  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* gcc.dg/missing-field-init-[12].c: New tests."}, {"sha": "45e5a07c109bf6821e68bff871027614f0656d6b", "filename": "gcc/testsuite/gfortran.dg/ret_array_1.f90", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc90a8f2eeefbac428a73d6ea8c146f8e5446154/gcc%2Ftestsuite%2Fgfortran.dg%2Fret_array_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc90a8f2eeefbac428a73d6ea8c146f8e5446154/gcc%2Ftestsuite%2Fgfortran.dg%2Fret_array_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fret_array_1.f90?ref=fc90a8f2eeefbac428a73d6ea8c146f8e5446154", "patch": "@@ -0,0 +1,63 @@\n+! { dg-do run }\n+! Test functions returning arrays of indeterminate size.\n+program ret_array_1\n+  integer, dimension(:, :), allocatable :: a\n+  integer, dimension(2) :: b\n+\n+  allocate (a(2, 3))\n+  a = reshape ((/1, 2, 3, 4, 5, 6/), (/2, 3/))\n+  \n+  ! Using the return value as an actual argument\n+  b = 0;\n+  b = sum (transpose (a), 1);\n+  if (any (b .ne. (/9, 12/))) call abort ()\n+\n+  ! Using the return value in an expression\n+  b = 0;\n+  b = sum (transpose (a) + 1, 1);\n+  if (any (b .ne. (/12, 15/))) call abort ()\n+\n+  ! Same again testing a user function\n+! TODO: enable these once this is implemented\n+!  b = 0;\n+!  b = sum (my_transpose (a), 1);\n+!  if (any (b .ne. (/9, 12/))) call abort ()\n+!\n+!  ! Using the return value in an expression\n+!  b = 0;\n+!  b = sum (my_transpose (a) + 1, 1);\n+!  if (any (b .ne. (/12, 15/))) call abort ()\n+contains\n+subroutine test(x, n)\n+  integer, dimension (:, :) :: x\n+  integer n\n+\n+  if (any (shape (x) .ne. (/3, 2/))) call abort\n+  if (any (x .ne. (n + reshape((/1, 4, 2, 5, 3, 6/), (/3, 2/))))) call abort\n+end subroutine\n+\n+function my_transpose (x) result (r)\n+  interface\n+    pure function obfuscate (i)\n+      integer obfuscate\n+      integer, intent(in) :: i\n+    end function\n+  end interface\n+  integer, dimension (:, :) :: x\n+  integer, dimension (obfuscate(ubound(x, 2)), &\n+                      obfuscate(ubound(x, 1))) :: r\n+  integer i\n+\n+  do i = 1, ubound(x, 1)\n+    r(:, i) = x(i, :)\n+  end do\n+end function\n+end program\n+\n+pure function obfuscate (i)\n+  integer obfuscate\n+  integer, intent(in) :: i\n+\n+  obfuscate = i\n+end function\n+"}, {"sha": "5e87d1f1d2bfc70d5263ffb2777b17dc89f00368", "filename": "gcc/testsuite/gfortran.dg/ret_pointer_1.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc90a8f2eeefbac428a73d6ea8c146f8e5446154/gcc%2Ftestsuite%2Fgfortran.dg%2Fret_pointer_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc90a8f2eeefbac428a73d6ea8c146f8e5446154/gcc%2Ftestsuite%2Fgfortran.dg%2Fret_pointer_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fret_pointer_1.f90?ref=fc90a8f2eeefbac428a73d6ea8c146f8e5446154", "patch": "@@ -0,0 +1,25 @@\n+! PR16898 : XFAILed because of problems with aliasing of array descriptors.\n+!  Basically a and r get put in different alias sets, then the rtl optimizars\n+!  wreak havoc when foo is inlined.\n+! { dg-do run { xfail *-*-* } }\n+! Test functions returning array pointers\n+program ret_pointer_1\n+  integer, pointer, dimension(:) :: a\n+  integer, target, dimension(2) :: b\n+  integer, pointer, dimension (:) :: p\n+\n+  a => NULL()\n+  a => foo()\n+  p => b\n+  if (.not. associated (a, p)) call abort\n+contains\n+subroutine bar(p)\n+  integer, pointer, dimension(:) :: p\n+end subroutine\n+function foo() result(r)\n+  integer, pointer, dimension(:) :: r\n+\n+  r => b\n+end function\n+end program\n+"}]}