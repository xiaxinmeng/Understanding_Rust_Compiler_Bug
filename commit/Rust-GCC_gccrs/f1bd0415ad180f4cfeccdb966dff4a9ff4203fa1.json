{"sha": "f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFiZDA0MTVhZDE4MGY0Y2ZlY2NkYjk2NmRmZjRhOWZmNDIwM2ZhMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-27T16:35:08Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-27T16:35:08Z"}, "message": "[multiple changes]\n\n2014-01-27  Robert Dewar  <dewar@adacore.com>\n\n\t* a-wichha.adb (Character_Set_Version): Change to output proper\n\tvalue.\n\n2014-01-27  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb (Is_Input_Only_State): Removed.\n\t(Is_Non_Volatile_State): Removed.\n\t(Is_Output_State): Removed.\n\t* einfo.ads (Is_Input_Only_State): Remove attribute and\n\tsubprogram. Update related entity.\n\t(Is_Non_Volatile_State):\n\tRemove attribute and subprogram. Update related entity.\n\t(Is_Output_State): Removed attribute and subprogram. Update\n\trelated entity.\n\t* exp_ch6.adb (Expand_Subprogram_Contract): Update comment on\n\tgenerated code.\n\t* sem_ch3.adb (Analyze_Declarations): Analyze the contract of\n\tan object, not just variables.\n\t(Analyze_Object_Contract): New routine.\n\t(Analyze_Variable_Contract): Removed.\n\t(Process_Discriminants): Detect an illegal use of volatile\n\tdiscriminant in SPARK mode.\n\t* sem_ch5.adb (Analyze_Iterator_Specification):\n\tDetect an illegal use of volatile loop variable.\n\t(Analyze_Loop_Parameter_Specification): Detect an illegal use\n\tof volatile loop variable.\n\t* sem_ch6.adb (Process_Formals): Update the volatile object\n\tdetection. Detect an illegal formal of mode IN OUT or OUT in\n\tSPARK mode. Enhance the error messages with references.\n\t* sem_ch12.adb (Instantiate_Object): Update the volatile object\n\tdetection. Enhance the error messages with references.\n\t* sem_prag.adb (Analyze_Abstract_State): Enhance the error\n\tmessages with references.\n\t(Analyze_Contract_Case): Enhance the error messages with references.\n\t(Analyze_External_Property): Call Check_Duplicate_Property to process\n\tan external property.\n\t(Analyze_External_Property_In_Decl_Part): New routine.\n\t(Analyze_External_State_In_Decl_Part): Removed.\n\t(Analyze_Global_Item): Detect an illegal\n\tuse of a volatile constant. Detect an illegal use\n\tof a variable with enabled Effective_Reads. Enhance\n\tthe error messages with references. Remove obsolete\n\tchecks concerning Input_Only and Output_Only states.\n\t(Analyze_Initialization_Item): Enhance the error messages\n\twith references.\n\t(Analyze_Initializes_In_Decl_Part): Do not\n\tcollect the states and variables when the initialization list\n\tis null.\n\t(Analyze_Input_Item): Enhance the error messages with references.\n\t(Analyze_Input_Output): Enhance the error messages with references.\n\t(Analyze_Pragma): Enhance the error messages with references.\n\t(Analyze_Refinement_Clause): Code reformatting.\n\t(Analyze_Refined_Depends_In_Decl_Part):\n\tRename global variable Global to Reg_Global and update all\n\toccurrences. Add local variables D7 and D8. Update the error\n\tmessages with references. Update the call to Collect_Global_Items.\n\t(Analyze_Refined_Global_In_Decl_Part): Add local variables\n\tHas_Proof_In_State, Proof_In_Constits and Proof_In_Items. Update\n\tthe call to Collect_Global_Items.  Account for a Proof_In state\n\tin null / useless refinement checks. Verify the coverage of\n\tProof_In states.\n\t(Check_Dependency_Clause): Remove local variable\n\tOut_Constits. Remove the retrieval and removal of constituents\n\tfor an Output_Only state. Remove the reporting of unused\n\tOutput_Only state constituents.\n\t(Check_Duplicate_Mode): Enhance\n\tthe error message with a reference.\n\t(Check_Duplicate_Property): New routine.\n\t(Check_Duplicate_Option): Enhance the error message with a reference.\n\t(Check_External_Properties): Enhance the error message with a reference.\n\t(Check_Function_Return): Enhance the error message with a reference.\n\t(Check_In_Out_States): Update\n\tcomment on usage. Add a specialized error message for Proof_In\n\tconstituents. Enhance the error message with a reference.\n\t(Check_Input_States): Update comment on usage. Account for\n\tpossible Proof_In constituents. Enhance the error message\n\twith a areference.\n\t(Check_Matching_Constituent): Enhance the error message with a\n\treference.\n\t(Check_Matching_State): Enchance the error message with a reference.\n\t(Check_Mode): Add local variable From_Global. Update the call to\n\tFind_Mode.  Emit more precise error messages concerning extra items\n\t(Check_Mode_Restriction_In_Enclosing_Context): Consider\n\tpragma Refined_Global.\tEnhance the error message with a\n\treference.\n\t(Check_Mode_Restriction_In_Function): Enhance the error message with\n\ta reference.\n\t(Check_Output_States): Update comment on usage. Add local variable\n\tPosted.  Account for possible Proof_In constituents. Produce a detailed\n\tlist of missing constituents.\n\t(Check_Proof_In_States): New routine.\n\t(Check_Refined_Global_Item): Handle Proof_In\n\tconstituents. Enchance the error message with a reference.\n\t(Collect_Global_Items): Add formal parameters Proof_In_Items\n\tand Has_Proof_In_State. Update the comment on usage. Account\n\tfor Proof_In items.\n\t(Create_Or_Modify_Clause): Enchance\n\tthe error message with a reference.\n\t(Find_Mode): Add\n\tformal parameter From_Global. Update the comment on usage.\n\tDetect when the mode is governed by pragma [Refined_]Global.\n\t(Output_Constituents): Removed.\n\t(Report_Extra_Constituents):\n\tReport extra Proof_In constituents.\n\t(Report_Unused_Constituents): Removed.\n\t(Usage_Error): Code reformatting. Enhance the error\n\tmessages with reference.\n\t* sem_prag.ads (Analyze_External_Property_In_Decl_Part): New routine.\n\t(Analyze_External_State_In_Decl_Part): Removed.\n\t* sem_res.adb (Resolve_Actuals): Update the volatile object\n\tdetection. Enhance the error message with a reference.\n\t(Resolve_Entity_Name): Update the volatile object\n\tdetection. Enhance the error message with a reference.\n\t* sem_util.adb (Is_Refined_State): Add a guard to avoid a crash.\n\t(Is_SPARK_Volatile_Object): New routine.\n\t(Has_Volatile_Component): New routine.\n\t* sem_util.ads (Is_Delegate): Alphabetized.\n\t(Is_SPARK_Volatile_Object): New routine.\n\t(Has_Volatile_Component): New routine.\n\t* snames.ads-tmpl: Remove names Name_Input_Only and Name_Output_Only.\n\n2014-01-27  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.adb: Resolve fully prefix of 'Update.\n\nFrom-SVN: r207138", "tree": {"sha": "2c5472aa2ddf56f13df141e20cf81a4f3a8ad166", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c5472aa2ddf56f13df141e20cf81a4f3a8ad166"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/comments", "author": null, "committer": null, "parents": [{"sha": "904e5ccd59800428a4beb46ef7cb20313d1f4e05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/904e5ccd59800428a4beb46ef7cb20313d1f4e05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/904e5ccd59800428a4beb46ef7cb20313d1f4e05"}], "stats": {"total": 1349, "additions": 849, "deletions": 500}, "files": [{"sha": "8f9f89fb1bff799bb8f0044f45a908e7bed5fd1a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "patch": "@@ -1,3 +1,130 @@\n+2014-01-27  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-wichha.adb (Character_Set_Version): Change to output proper\n+\tvalue.\n+\n+2014-01-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.adb (Is_Input_Only_State): Removed.\n+\t(Is_Non_Volatile_State): Removed.\n+\t(Is_Output_State): Removed.\n+\t* einfo.ads (Is_Input_Only_State): Remove attribute and\n+\tsubprogram. Update related entity.\n+\t(Is_Non_Volatile_State):\n+\tRemove attribute and subprogram. Update related entity.\n+\t(Is_Output_State): Removed attribute and subprogram. Update\n+\trelated entity.\n+\t* exp_ch6.adb (Expand_Subprogram_Contract): Update comment on\n+\tgenerated code.\n+\t* sem_ch3.adb (Analyze_Declarations): Analyze the contract of\n+\tan object, not just variables.\n+\t(Analyze_Object_Contract): New routine.\n+\t(Analyze_Variable_Contract): Removed.\n+\t(Process_Discriminants): Detect an illegal use of volatile\n+\tdiscriminant in SPARK mode.\n+\t* sem_ch5.adb (Analyze_Iterator_Specification):\n+\tDetect an illegal use of volatile loop variable.\n+\t(Analyze_Loop_Parameter_Specification): Detect an illegal use\n+\tof volatile loop variable.\n+\t* sem_ch6.adb (Process_Formals): Update the volatile object\n+\tdetection. Detect an illegal formal of mode IN OUT or OUT in\n+\tSPARK mode. Enhance the error messages with references.\n+\t* sem_ch12.adb (Instantiate_Object): Update the volatile object\n+\tdetection. Enhance the error messages with references.\n+\t* sem_prag.adb (Analyze_Abstract_State): Enhance the error\n+\tmessages with references.\n+\t(Analyze_Contract_Case): Enhance the error messages with references.\n+\t(Analyze_External_Property): Call Check_Duplicate_Property to process\n+\tan external property.\n+\t(Analyze_External_Property_In_Decl_Part): New routine.\n+\t(Analyze_External_State_In_Decl_Part): Removed.\n+\t(Analyze_Global_Item): Detect an illegal\n+\tuse of a volatile constant. Detect an illegal use\n+\tof a variable with enabled Effective_Reads. Enhance\n+\tthe error messages with references. Remove obsolete\n+\tchecks concerning Input_Only and Output_Only states.\n+\t(Analyze_Initialization_Item): Enhance the error messages\n+\twith references.\n+\t(Analyze_Initializes_In_Decl_Part): Do not\n+\tcollect the states and variables when the initialization list\n+\tis null.\n+\t(Analyze_Input_Item): Enhance the error messages with references.\n+\t(Analyze_Input_Output): Enhance the error messages with references.\n+\t(Analyze_Pragma): Enhance the error messages with references.\n+\t(Analyze_Refinement_Clause): Code reformatting.\n+\t(Analyze_Refined_Depends_In_Decl_Part):\n+\tRename global variable Global to Reg_Global and update all\n+\toccurrences. Add local variables D7 and D8. Update the error\n+\tmessages with references. Update the call to Collect_Global_Items.\n+\t(Analyze_Refined_Global_In_Decl_Part): Add local variables\n+\tHas_Proof_In_State, Proof_In_Constits and Proof_In_Items. Update\n+\tthe call to Collect_Global_Items.  Account for a Proof_In state\n+\tin null / useless refinement checks. Verify the coverage of\n+\tProof_In states.\n+\t(Check_Dependency_Clause): Remove local variable\n+\tOut_Constits. Remove the retrieval and removal of constituents\n+\tfor an Output_Only state. Remove the reporting of unused\n+\tOutput_Only state constituents.\n+\t(Check_Duplicate_Mode): Enhance\n+\tthe error message with a reference.\n+\t(Check_Duplicate_Property): New routine.\n+\t(Check_Duplicate_Option): Enhance the error message with a reference.\n+\t(Check_External_Properties): Enhance the error message with a reference.\n+\t(Check_Function_Return): Enhance the error message with a reference.\n+\t(Check_In_Out_States): Update\n+\tcomment on usage. Add a specialized error message for Proof_In\n+\tconstituents. Enhance the error message with a reference.\n+\t(Check_Input_States): Update comment on usage. Account for\n+\tpossible Proof_In constituents. Enhance the error message\n+\twith a areference.\n+\t(Check_Matching_Constituent): Enhance the error message with a\n+\treference.\n+\t(Check_Matching_State): Enchance the error message with a reference.\n+\t(Check_Mode): Add local variable From_Global. Update the call to\n+\tFind_Mode.  Emit more precise error messages concerning extra items\n+\t(Check_Mode_Restriction_In_Enclosing_Context): Consider\n+\tpragma Refined_Global.\tEnhance the error message with a\n+\treference.\n+\t(Check_Mode_Restriction_In_Function): Enhance the error message with\n+\ta reference.\n+\t(Check_Output_States): Update comment on usage. Add local variable\n+\tPosted.  Account for possible Proof_In constituents. Produce a detailed\n+\tlist of missing constituents.\n+\t(Check_Proof_In_States): New routine.\n+\t(Check_Refined_Global_Item): Handle Proof_In\n+\tconstituents. Enchance the error message with a reference.\n+\t(Collect_Global_Items): Add formal parameters Proof_In_Items\n+\tand Has_Proof_In_State. Update the comment on usage. Account\n+\tfor Proof_In items.\n+\t(Create_Or_Modify_Clause): Enchance\n+\tthe error message with a reference.\n+\t(Find_Mode): Add\n+\tformal parameter From_Global. Update the comment on usage.\n+\tDetect when the mode is governed by pragma [Refined_]Global.\n+\t(Output_Constituents): Removed.\n+\t(Report_Extra_Constituents):\n+\tReport extra Proof_In constituents.\n+\t(Report_Unused_Constituents): Removed.\n+\t(Usage_Error): Code reformatting. Enhance the error\n+\tmessages with reference.\n+\t* sem_prag.ads (Analyze_External_Property_In_Decl_Part): New routine.\n+\t(Analyze_External_State_In_Decl_Part): Removed.\n+\t* sem_res.adb (Resolve_Actuals): Update the volatile object\n+\tdetection. Enhance the error message with a reference.\n+\t(Resolve_Entity_Name): Update the volatile object\n+\tdetection. Enhance the error message with a reference.\n+\t* sem_util.adb (Is_Refined_State): Add a guard to avoid a crash.\n+\t(Is_SPARK_Volatile_Object): New routine.\n+\t(Has_Volatile_Component): New routine.\n+\t* sem_util.ads (Is_Delegate): Alphabetized.\n+\t(Is_SPARK_Volatile_Object): New routine.\n+\t(Has_Volatile_Component): New routine.\n+\t* snames.ads-tmpl: Remove names Name_Input_Only and Name_Output_Only.\n+\n+2014-01-27  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_attr.adb: Resolve fully prefix of 'Update.\n+\n 2014-01-27  Ben Brosgol  <brosgol@adacore.com>\n \n \t* gnat_rm.texi: Minor clarifications."}, {"sha": "8d02236111c6fb72e93a5459dd4ff0650f6c154f", "filename": "gcc/ada/a-wichha.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fa-wichha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fa-wichha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wichha.adb?ref=f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "patch": "@@ -33,9 +33,13 @@ with Ada.Wide_Characters.Unicode; use Ada.Wide_Characters.Unicode;\n \n package body Ada.Wide_Characters.Handling is\n \n+   ---------------------------\n+   -- Character_Set_Version --\n+   ---------------------------\n+\n    function Character_Set_Version return String is\n    begin\n-      return \"Unicode 6.2\";\n+      return \"Unicode 4.0\";\n    end Character_Set_Version;\n \n    ---------------------"}, {"sha": "578e26b842bfcc26ce00eff7514df69f89192c2e", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "patch": "@@ -6912,28 +6912,6 @@ package body Einfo is\n       end if;\n    end Is_Ghost_Subprogram;\n \n-   -------------------------\n-   -- Is_Input_Only_State --\n-   -------------------------\n-\n-   function Is_Input_Only_State (Id : E) return B is\n-   begin\n-      return\n-        Ekind (Id) = E_Abstract_State\n-          and then Has_Option (Id, Name_Input_Only);\n-   end Is_Input_Only_State;\n-\n-   ---------------------------\n-   -- Is_Non_Volatile_State --\n-   ---------------------------\n-\n-   function Is_Non_Volatile_State (Id : E) return B is\n-   begin\n-      return\n-        Ekind (Id) = E_Abstract_State\n-          and then Has_Option (Id, Name_Non_Volatile);\n-   end Is_Non_Volatile_State;\n-\n    -------------------\n    -- Is_Null_State --\n    -------------------\n@@ -6944,17 +6922,6 @@ package body Einfo is\n         Ekind (Id) = E_Abstract_State and then Nkind (Parent (Id)) = N_Null;\n    end Is_Null_State;\n \n-   ---------------------\n-   -- Is_Output_State --\n-   ---------------------\n-\n-   function Is_Output_Only_State (Id : E) return B is\n-   begin\n-      return\n-        Ekind (Id) = E_Abstract_State\n-          and then Has_Option (Id, Name_Output_Only);\n-   end Is_Output_Only_State;\n-\n    -----------------------------------\n    -- Is_Package_Or_Generic_Package --\n    -----------------------------------"}, {"sha": "352574311c0c03c4851461e7abf3e5989ad62525", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "patch": "@@ -2400,10 +2400,6 @@ package Einfo is\n --       inherited by their instances. It is also set on the body entities\n --       of inlined subprograms. See also Has_Pragma_Inline.\n \n---    Is_Input_Only_State (synthesized)\n---       Applies to all entities, true for abstract states that are subject to\n---       option Input_Only.\n-\n --    Is_Instantiated (Flag126)\n --       Defined in generic packages and generic subprograms. Set if the unit\n --       is instantiated from somewhere in the extended main source unit. This\n@@ -2593,10 +2589,6 @@ package Einfo is\n --       set right, at which point, these comments can be removed, and the\n --       tests for static subtypes greatly simplified.\n \n---    Is_Non_Volatile_State (synthesized)\n---       Applies to all entities, true for abstract states that are subject to\n---       option Non_Volatile.\n-\n --    Is_Null_Init_Proc (Flag178)\n --       Defined in procedure entities. Set for generated init proc procedures\n --       (used to initialize composite types), if the code for the procedure\n@@ -2637,10 +2629,6 @@ package Einfo is\n --       Applies to all entities, true for ordinary fixed point types and\n --       subtypes.\n \n---    Is_Output_Only_State (synthesized)\n---       Applies to all entities, true for abstract states that are subject to\n---       option Output_Only.\n-\n --    Is_Package_Or_Generic_Package (synthesized)\n --       Applies to all entities. True for packages and generic packages.\n --       False for all other entities.\n@@ -5167,10 +5155,7 @@ package Einfo is\n    --    Has_Non_Null_Refinement             (synth)\n    --    Has_Null_Refinement                 (synth)\n    --    Is_External_State                   (synth)\n-   --    Is_Input_Only_State                 (synth)\n    --    Is_Null_State                       (synth)\n-   --    Is_Output_Only_State                (synth)\n-   --    Is_Non_Volatile_State               (synth)\n \n    --  E_Access_Protected_Subprogram_Type\n    --    Equivalent_Type                     (Node18)\n@@ -6787,10 +6772,7 @@ package Einfo is\n    function Is_Finalizer                        (Id : E) return B;\n    function Is_Ghost_Entity                     (Id : E) return B;\n    function Is_Ghost_Subprogram                 (Id : E) return B;\n-   function Is_Input_Only_State                 (Id : E) return B;\n-   function Is_Non_Volatile_State               (Id : E) return B;\n    function Is_Null_State                       (Id : E) return B;\n-   function Is_Output_Only_State                (Id : E) return B;\n    function Is_Package_Or_Generic_Package       (Id : E) return B;\n    function Is_Prival                           (Id : E) return B;\n    function Is_Protected_Component              (Id : E) return B;"}, {"sha": "8e1e9547072aeb4db1a1f6c40488f266a1a82212", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "patch": "@@ -9477,7 +9477,7 @@ package body Exp_Ch6 is\n       --          <postconditions from body>\n       --          <postconditions from spec>\n       --          <inherited postconditions>\n-      --          <contract cases>\n+      --          <contract case consequences>\n       --          <invariant check of function result (if applicable)>\n       --          <invariant and predicate checks of parameters>\n       --       end _Postconditions;\n@@ -9486,6 +9486,7 @@ package body Exp_Ch6 is\n       --       <preconditions from spec>\n       --       <preconditions from body>\n       --       <refined preconditions from body>\n+      --       <contract case conditions>\n \n       --       <source declarations>\n       --    begin"}, {"sha": "ee1841196ffa57d14396d7b06b18385662df2a15", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "patch": "@@ -6064,6 +6064,7 @@ package body Sem_Attr is\n \n       begin\n          Check_E1;\n+         Check_Ada_2012_Attribute;\n \n          if not Is_Object_Reference (P) then\n             Error_Attr_P (\"prefix of attribute % must denote an object\");\n@@ -10477,8 +10478,11 @@ package body Sem_Attr is\n                --  Set the Etype of the aggregate to that of the prefix, even\n                --  though the aggregate may not be a proper representation of a\n                --  value of the type (missing or duplicated associations, etc.)\n+               --  Complete resolution of the prefix. Note that in Ada 2012 it\n+               --  can be a qualified expression that is e.g. an aggregate.\n \n                Set_Etype (Aggr, Typ);\n+               Resolve (Prefix (N), Typ);\n \n                --  For an array type, resolve expressions with the component\n                --  type of the array."}, {"sha": "565df4edf0782cd90282b791d19891e2205cce96", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "patch": "@@ -9846,11 +9846,11 @@ package body Sem_Ch12 is\n \n       if SPARK_Mode = On\n         and then Present (Actual)\n-        and then Is_Volatile_Object (Actual)\n+        and then Is_SPARK_Volatile_Object (Actual)\n       then\n          Error_Msg_N\n            (\"volatile object cannot act as actual in generic instantiation \"\n-            & \"(SPARK RM 7.1.3(4))\", Actual);\n+            & \"(SPARK RM 7.1.3(8))\", Actual);\n       end if;\n \n       return List;"}, {"sha": "56bd43a003711f8d64da8dc45a160b58a0d7f5f0", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 116, "deletions": 75, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "patch": "@@ -91,10 +91,10 @@ package body Sem_Ch3 is\n    --  abstract interface types implemented by a record type or a derived\n    --  record type.\n \n-   procedure Analyze_Variable_Contract (Var_Id : Entity_Id);\n-   --  Analyze all delayed aspects chained on the contract of variable Var_Id\n-   --  as if they appeared at the end of the declarative region. The aspects\n-   --  to be considered are:\n+   procedure Analyze_Object_Contract (Obj_Id : Entity_Id);\n+   --  Analyze all delayed aspects chained on the contract of object Obj_Id as\n+   --  if they appeared at the end of the declarative region. The aspects to be\n+   --  considered are:\n    --    Async_Readers\n    --    Async_Writers\n    --    Effective_Reads\n@@ -2478,10 +2478,8 @@ package body Sem_Ch3 is\n          elsif Nkind (Decl) = N_Subprogram_Declaration then\n             Analyze_Subprogram_Contract (Defining_Entity (Decl));\n \n-         elsif Nkind (Decl) = N_Object_Declaration\n-           and then Ekind (Defining_Entity (Decl)) = E_Variable\n-         then\n-            Analyze_Variable_Contract (Defining_Entity (Decl));\n+         elsif Nkind (Decl) = N_Object_Declaration then\n+            Analyze_Object_Contract (Defining_Entity (Decl));\n          end if;\n \n          Next (Decl);\n@@ -3071,6 +3069,106 @@ package body Sem_Ch3 is\n       end if;\n    end Analyze_Number_Declaration;\n \n+   -----------------------------\n+   -- Analyze_Object_Contract --\n+   -----------------------------\n+\n+   procedure Analyze_Object_Contract (Obj_Id : Entity_Id) is\n+      AR_Val : Boolean := False;\n+      AW_Val : Boolean := False;\n+      ER_Val : Boolean := False;\n+      EW_Val : Boolean := False;\n+      Items  : Node_Id;\n+      Nam    : Name_Id;\n+      Prag   : Node_Id;\n+      Seen   : Boolean := False;\n+\n+   begin\n+      if Ekind (Obj_Id) = E_Constant then\n+\n+         --  A constant cannot be volatile. This check is only relevant when\n+         --  SPARK_Mode is on as it is not standard Ada legality rule. Do not\n+         --  flag internally-generated constants that map generic formals to\n+         --  actuals in instantiations.\n+\n+         if SPARK_Mode = On\n+           and then Is_SPARK_Volatile_Object (Obj_Id)\n+           and then No (Corresponding_Generic_Association (Parent (Obj_Id)))\n+         then\n+            Error_Msg_N\n+              (\"constant cannot be volatile (SPARK RM 7.1.3(4))\", Obj_Id);\n+         end if;\n+\n+      else pragma Assert (Ekind (Obj_Id) = E_Variable);\n+\n+         --  The following checks are only relevant when SPARK_Mode is on as\n+         --  they are not standard Ada legality rules.\n+\n+         if SPARK_Mode = On then\n+\n+            --  A non-volatile object cannot have volatile components\n+\n+            if not Is_SPARK_Volatile_Object (Obj_Id)\n+              and then Has_Volatile_Component (Etype (Obj_Id))\n+            then\n+               Error_Msg_N\n+                 (\"non-volatile variable & cannot have volatile components \"\n+                  & \"(SPARK RM 7.1.3(6))\", Obj_Id);\n+\n+            --  The declaration of a volatile object must appear at the library\n+            --  level.\n+\n+            elsif Is_SPARK_Volatile_Object (Obj_Id)\n+              and then not Is_Library_Level_Entity (Obj_Id)\n+            then\n+               Error_Msg_N\n+                 (\"volatile variable & must be declared at library level \"\n+                  & \"(SPARK RM 7.1.3(5))\", Obj_Id);\n+            end if;\n+         end if;\n+\n+         --  Examine the contract\n+\n+         Items := Contract (Obj_Id);\n+\n+         if Present (Items) then\n+\n+            --  Analyze classification pragmas\n+\n+            Prag := Classifications (Items);\n+            while Present (Prag) loop\n+               Nam := Pragma_Name (Prag);\n+\n+               if Nam = Name_Async_Readers then\n+                  Analyze_External_Property_In_Decl_Part (Prag, AR_Val);\n+                  Seen := True;\n+\n+               elsif Nam = Name_Async_Writers then\n+                  Analyze_External_Property_In_Decl_Part (Prag, AW_Val);\n+                  Seen := True;\n+\n+               elsif Nam = Name_Effective_Reads then\n+                  Analyze_External_Property_In_Decl_Part (Prag, ER_Val);\n+                  Seen := True;\n+\n+               else pragma Assert (Nam = Name_Effective_Writes);\n+                  Analyze_External_Property_In_Decl_Part (Prag, EW_Val);\n+                  Seen := True;\n+               end if;\n+\n+               Prag := Next_Pragma (Prag);\n+            end loop;\n+         end if;\n+\n+         --  Once all external properties have been processed, verify their\n+         --  mutual interaction.\n+\n+         if Seen then\n+            Check_External_Properties (Obj_Id, AR_Val, AW_Val, ER_Val, EW_Val);\n+         end if;\n+      end if;\n+   end Analyze_Object_Contract;\n+\n    --------------------------------\n    -- Analyze_Object_Declaration --\n    --------------------------------\n@@ -4889,73 +4987,6 @@ package body Sem_Ch3 is\n       end if;\n    end Analyze_Subtype_Indication;\n \n-   -------------------------------\n-   -- Analyze_Variable_Contract --\n-   -------------------------------\n-\n-   procedure Analyze_Variable_Contract (Var_Id : Entity_Id) is\n-      Items  : constant Node_Id := Contract (Var_Id);\n-      AR_Val : Boolean := False;\n-      AW_Val : Boolean := False;\n-      ER_Val : Boolean := False;\n-      EW_Val : Boolean := False;\n-      Nam    : Name_Id;\n-      Prag   : Node_Id;\n-      Seen   : Boolean := False;\n-\n-   begin\n-      --  The declaration of a volatile variable must appear at the library\n-      --  level. The check is only relevant when SPARK_Mode is on as it is not\n-      --  standard Ada legality rule.\n-\n-      if SPARK_Mode = On\n-        and then Is_Volatile_Object (Var_Id)\n-        and then not Is_Library_Level_Entity (Var_Id)\n-      then\n-         Error_Msg_N\n-           (\"volatile variable & must be declared at library level (SPARK RM \"\n-            & \"7.1.3(3))\", Var_Id);\n-      end if;\n-\n-      --  Examine the contract\n-\n-      if Present (Items) then\n-\n-         --  Analyze classification pragmas\n-\n-         Prag := Classifications (Items);\n-         while Present (Prag) loop\n-            Nam := Pragma_Name (Prag);\n-\n-            if Nam = Name_Async_Readers then\n-               Analyze_External_State_In_Decl_Part (Prag, AR_Val);\n-               Seen := True;\n-\n-            elsif Nam = Name_Async_Writers then\n-               Analyze_External_State_In_Decl_Part (Prag, AW_Val);\n-               Seen := True;\n-\n-            elsif Nam = Name_Effective_Reads then\n-               Analyze_External_State_In_Decl_Part (Prag, ER_Val);\n-               Seen := True;\n-\n-            else pragma Assert (Nam = Name_Effective_Writes);\n-               Analyze_External_State_In_Decl_Part (Prag, EW_Val);\n-               Seen := True;\n-            end if;\n-\n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-      end if;\n-\n-      --  Once all external properties have been processed, verify their mutual\n-      --  interaction.\n-\n-      if Seen then\n-         Check_External_Properties (Var_Id, AR_Val, AW_Val, ER_Val, EW_Val);\n-      end if;\n-   end Analyze_Variable_Contract;\n-\n    --------------------------\n    -- Analyze_Variant_Part --\n    --------------------------\n@@ -18076,6 +18107,16 @@ package body Sem_Ch3 is\n             end if;\n          end if;\n \n+         --  A discriminant cannot be volatile. This check is only relevant\n+         --  when SPARK_Mode is on as it is not standard Ada legality rule.\n+\n+         if SPARK_Mode = On\n+           and then Is_SPARK_Volatile_Object (Defining_Identifier (Discr))\n+         then\n+            Error_Msg_N\n+              (\"discriminant cannot be volatile (SPARK RM 7.1.3(6))\", Discr);\n+         end if;\n+\n          Next (Discr);\n       end loop;\n "}, {"sha": "581edf413835c04894b86493abb12b80e82ea35e", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "patch": "@@ -1921,6 +1921,14 @@ package body Sem_Ch5 is\n             end loop;\n          end if;\n       end if;\n+\n+      --  A loop parameter cannot be volatile. This check is peformed only when\n+      --  SPARK_Mode is on as it is not a standard Ada legality check.\n+\n+      if SPARK_Mode = On and then Is_SPARK_Volatile_Object (Ent) then\n+         Error_Msg_N\n+           (\"loop parameter cannot be volatile (SPARK RM 7.1.3(6))\", Ent);\n+      end if;\n    end Analyze_Iterator_Specification;\n \n    -------------------\n@@ -2550,6 +2558,14 @@ package body Sem_Ch5 is\n             end if;\n          end;\n       end if;\n+\n+      --  A loop parameter cannot be volatile. This check is peformed only when\n+      --  SPARK_Mode is on as it is not a standard Ada legality check.\n+\n+      if SPARK_Mode = On and then Is_SPARK_Volatile_Object (Id) then\n+         Error_Msg_N\n+           (\"loop parameter cannot be volatile (SPARK RM 7.1.3(6))\", Id);\n+      end if;\n    end Analyze_Loop_Parameter_Specification;\n \n    ----------------------------"}, {"sha": "eea7ea50ab5328069d680d31070532626a78015f", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "patch": "@@ -11233,17 +11233,26 @@ package body Sem_Ch6 is\n             Null_Exclusion_Static_Checks (Param_Spec);\n          end if;\n \n-         --  A function cannot have a volatile formal parameter. The following\n-         --  check is relevant when SPARK_Mode is on as it is not a standard\n-         --  Ada legality rule.\n+         --  The following checks are relevant when SPARK_Mode is on as these\n+         --  are not standard Ada legality rules.\n \n          if SPARK_Mode = On\n-           and then Is_Volatile_Object (Formal)\n            and then Ekind_In (Scope (Formal), E_Function, E_Generic_Function)\n          then\n-            Error_Msg_N\n-              (\"function cannot have a volatile formal parameter (SPARK RM \"\n-               & \"7.1.3(6))\", Formal);\n+            --  A function cannot have a parameter of mode IN OUT or OUT\n+\n+            if Ekind_In (Formal, E_In_Out_Parameter, E_Out_Parameter) then\n+               Error_Msg_N\n+                 (\"function cannot have parameter of mode `OUT` or `IN OUT` \"\n+                  & \"(SPARK RM 6.1)\", Formal);\n+\n+            --  A function cannot have a volatile formal parameter\n+\n+            elsif Is_SPARK_Volatile_Object (Formal) then\n+               Error_Msg_N\n+                 (\"function cannot have a volatile formal parameter (SPARK RM \"\n+                  & \"7.1.3(10))\", Formal);\n+            end if;\n          end if;\n \n       <<Continue>>"}, {"sha": "85d504937186d653693e47a06945a4b0d60f5450", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 469, "deletions": 343, "changes": 812, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "patch": "@@ -204,21 +204,23 @@ package body Sem_Prag is\n    --  in identifiers to represent these attribute references.\n \n    procedure Collect_Global_Items\n-     (Prag             : Node_Id;\n-      In_Items         : in out Elist_Id;\n-      In_Out_Items     : in out Elist_Id;\n-      Out_Items        : in out Elist_Id;\n-      Has_In_State     : out Boolean;\n-      Has_In_Out_State : out Boolean;\n-      Has_Out_State    : out Boolean;\n-      Has_Null_State   : out Boolean);\n+     (Prag               : Node_Id;\n+      In_Items           : in out Elist_Id;\n+      In_Out_Items       : in out Elist_Id;\n+      Out_Items          : in out Elist_Id;\n+      Proof_In_Items     : in out Elist_Id;\n+      Has_In_State       : out Boolean;\n+      Has_In_Out_State   : out Boolean;\n+      Has_Out_State      : out Boolean;\n+      Has_Proof_In_State : out Boolean;\n+      Has_Null_State     : out Boolean);\n    --  Subsidiary to the analysis of pragma Refined_Depends/Refined_Global.\n-   --  Prag denotes pragma [Refined_]Global. Gather all input, in out and\n-   --  output items of Prag in lists In_Items, In_Out_Items and Out_Items.\n-   --  Flags Has_In_State, Has_In_Out_State and Has_Out_State are set when\n-   --  there is at least one abstract state with visible refinement available\n-   --  in the corresponding mode. Flag Has_Null_State is set when at least\n-   --  state has a null refinement.\n+   --  Prag denotes pragma [Refined_]Global. Gather all input, in out, output\n+   --  and Proof_In items of Prag in lists In_Items, In_Out_Items, Out_Items\n+   --  and Proof_In_Items. Flags Has_In_State, Has_In_Out_State, Has_Out_State\n+   --  and Has_Proof_In_State are set when there is at least one abstract state\n+   --  with visible refinement available in the corresponding mode. Flag\n+   --  Has_Null_State is set when at least state has a null refinement.\n \n    procedure Collect_Subprogram_Inputs_Outputs\n      (Subp_Id      : Entity_Id;\n@@ -402,16 +404,16 @@ package body Sem_Prag is\n             if Nkind (Case_Guard) = N_Others_Choice then\n                if Others_Seen then\n                   Error_Msg_N\n-                    (\"only one others choice allowed in aspect Contract_Cases\",\n-                     Case_Guard);\n+                    (\"only one others choice allowed in aspect Contract_Cases \"\n+                     & \"(SPARK RM 6.1.3(1))\", Case_Guard);\n                else\n                   Others_Seen := True;\n                end if;\n \n             elsif Others_Seen then\n                Error_Msg_N\n-                 (\"others must be the last choice in aspect Contract_Cases\",\n-                  N);\n+                 (\"others must be the last choice in aspect Contract_Cases \"\n+                  & \"(SPARK RM 6.1.3(1))\", N);\n             end if;\n \n             --  Preanalyze the case guard and consequence\n@@ -717,13 +719,15 @@ package body Sem_Prag is\n                   Error_Msg_Name_1 := Name_Result;\n                   Error_Msg_N\n                     (\"prefix of attribute % must denote the enclosing \"\n-                     & \"function\", Item);\n+                     & \"function (SPARK RM 6.1.5(11))\", Item);\n \n                --  Function'Result is allowed to appear on the output side of a\n                --  dependency clause.\n \n                elsif Is_Input then\n-                  Error_Msg_N (\"function result cannot act as input\", Item);\n+                  Error_Msg_N\n+                    (\"function result cannot act as input (SPARK RM 6.1.5(6))\",\n+                     Item);\n \n                elsif Null_Seen then\n                   Error_Msg_N\n@@ -753,7 +757,7 @@ package body Sem_Prag is\n                      if not Is_Last then\n                         Error_Msg_N\n                           (\"null output list must be the last clause in a \"\n-                           & \"dependency relation\", Item);\n+                           & \"dependency relation (SPARK RM 6.1.5(12))\", Item);\n \n                      --  Catch a useless dependence of the form:\n                      --    null =>+ ...\n@@ -817,7 +821,7 @@ package body Sem_Prag is\n                      then\n                         Error_Msg_N\n                           (\"input of a null output list appears in multiple \"\n-                           & \"input lists\", Item);\n+                           & \"input lists (SPARK RM 6.1.5(13))\", Item);\n                      end if;\n \n                      --  Add an input or a self-referential output to the list\n@@ -852,7 +856,8 @@ package body Sem_Prag is\n                         elsif Has_Visible_Refinement (Item_Id) then\n                            Error_Msg_NE\n                              (\"cannot mention state & in global refinement, \"\n-                              & \"use its constituents instead\", Item, Item_Id);\n+                              & \"use its constituents instead (SPARK RM \"\n+                              & \"6.1.5(3))\", Item, Item_Id);\n                            return;\n                         end if;\n                      end if;\n@@ -871,15 +876,15 @@ package body Sem_Prag is\n                   else\n                      Error_Msg_N\n                         (\"item must denote variable, state or formal \"\n-                         & \"parameter\", Item);\n+                         & \"parameter (SPARK RM 6.1.5(1))\", Item);\n                   end if;\n \n                --  All other input/output items are illegal\n \n                else\n                   Error_Msg_N\n-                    (\"item must denote variable, state or formal parameter\",\n-                     Item);\n+                    (\"item must denote variable, state or formal parameter \"\n+                     & \"(SPARK RM 6.1.5(1))\", Item);\n                end if;\n             end if;\n          end Analyze_Input_Output;\n@@ -936,8 +941,8 @@ package body Sem_Prag is\n       begin\n          if Ekind (Spec_Id) = E_Function and then not Result_Seen then\n             Error_Msg_NE\n-              (\"result of & must appear in exactly one output list\",\n-               N, Spec_Id);\n+              (\"result of & must appear in exactly one output list (SPARK RM \"\n+               & \"6.1.5(10))\", N, Spec_Id);\n          end if;\n       end Check_Function_Return;\n \n@@ -952,22 +957,26 @@ package body Sem_Prag is\n          Self_Ref : Boolean)\n       is\n          procedure Find_Mode\n-           (Is_Input  : out Boolean;\n-            Is_Output : out Boolean);\n+           (Is_Input    : out Boolean;\n+            Is_Output   : out Boolean;\n+            From_Global : out Boolean);\n          --  Find the mode of Item_Id. Flags Is_Input and Is_Output are set\n-         --  depending on the mode.\n+         --  depending on the mode. Flag From_Global is set when the mode is\n+         --  determined by pragma [Refined_]Global.\n \n          ---------------\n          -- Find_Mode --\n          ---------------\n \n          procedure Find_Mode\n-           (Is_Input  : out Boolean;\n-            Is_Output : out Boolean)\n+           (Is_Input    : out Boolean;\n+            Is_Output   : out Boolean;\n+            From_Global : out Boolean)\n          is\n          begin\n-            Is_Input  := False;\n-            Is_Output := False;\n+            Is_Input    := False;\n+            Is_Output   := False;\n+            From_Global := False;\n \n             --  Abstract state cases\n \n@@ -978,28 +987,20 @@ package body Sem_Prag is\n \n                if Global_Seen then\n                   if Appears_In (Subp_Inputs, Item_Id) then\n-                     Is_Input := True;\n+                     Is_Input    := True;\n+                     From_Global := True;\n                   end if;\n \n                   if Appears_In (Subp_Outputs, Item_Id) then\n-                     Is_Output := True;\n+                     Is_Output   := True;\n+                     From_Global := True;\n                   end if;\n \n-               --  Otherwise the mode of the state is the one defined in pragma\n-               --  Abstract_State. An In_Out state lacks both Input_Only and\n-               --  Output_Only modes.\n+               --  Otherwise the state has a default IN OUT mode\n \n-               elsif not Is_Input_Only_State (Item_Id)\n-                 and then not Is_Output_Only_State (Item_Id)\n-               then\n+               else\n                   Is_Input  := True;\n                   Is_Output := True;\n-\n-               elsif Is_Input_Only_State (Item_Id) then\n-                  Is_Input := True;\n-\n-               elsif Is_Output_Only_State (Item_Id) then\n-                  Is_Output := True;\n                end if;\n \n             --  Parameter cases\n@@ -1048,11 +1049,13 @@ package body Sem_Prag is\n                   if Appears_In (Subp_Inputs, Item_Id)\n                     or else Is_Unconstrained_Or_Tagged_Item (Item_Id)\n                   then\n-                     Is_Input := True;\n+                     Is_Input    := True;\n+                     From_Global := True;\n                   end if;\n \n                   if Appears_In (Subp_Outputs, Item_Id) then\n-                     Is_Output := True;\n+                     Is_Output   := True;\n+                     From_Global := True;\n                   end if;\n \n                --  Otherwise the variable has a default IN OUT mode\n@@ -1068,32 +1071,49 @@ package body Sem_Prag is\n \n          Item_Is_Input  : Boolean;\n          Item_Is_Output : Boolean;\n+         From_Global    : Boolean;\n \n       --  Start of processing for Check_Mode\n \n       begin\n-         Find_Mode (Item_Is_Input, Item_Is_Output);\n+         Find_Mode (Item_Is_Input, Item_Is_Output, From_Global);\n \n          --  Input item\n \n          if Is_Input then\n             if not Item_Is_Input then\n-               Error_Msg_NE\n-                 (\"item & must have mode `IN` or `IN OUT`\", Item, Item_Id);\n+               if From_Global then\n+                  Error_Msg_NE\n+                    (\"item & must have mode `IN` or `IN OUT`\", Item, Item_Id);\n+               else\n+                  Error_Msg_NE\n+                    (\"item & appears as extra in input list\", Item, Item_Id);\n+               end if;\n             end if;\n \n          --  Self-referential item\n \n          elsif Self_Ref then\n             if not Item_Is_Input or else not Item_Is_Output then\n-               Error_Msg_NE (\"item & must have mode `IN OUT`\", Item, Item_Id);\n+               if From_Global then\n+                  Error_Msg_NE\n+                    (\"item & must have mode `IN OUT`\", Item, Item_Id);\n+               else\n+                  Error_Msg_NE\n+                    (\"item & appears as extra in In_Out list\", Item, Item_Id);\n+               end if;\n             end if;\n \n          --  Output item\n \n          elsif not Item_Is_Output then\n-            Error_Msg_NE\n-              (\"item & must have mode `OUT` or `IN OUT`\", Item, Item_Id);\n+            if From_Global then\n+               Error_Msg_NE\n+                 (\"item & must have mode `OUT` or `IN OUT`\", Item, Item_Id);\n+            else\n+               Error_Msg_NE\n+                 (\"item & appears as extra in output list\", Item, Item_Id);\n+            end if;\n          end if;\n       end Check_Mode;\n \n@@ -1121,14 +1141,14 @@ package body Sem_Prag is\n \n             if Is_Input then\n                Error_Msg_NE\n-                 (\"item & must appear in at least one input list of aspect \"\n-                  & \"Depends\", Item, Item_Id);\n+                 (\"item & must appear in at least one input dependence list \"\n+                  & \"(SPARK RM 6.1.5(8))\", Item, Item_Id);\n \n-               --  Case of OUT parameter for which Is_Input is set\n+               --  Refine the error message for unconstrained OUT parameters\n+               --  by giving the reason for the illegality.\n+\n+               if Ekind (Item_Id) = E_Out_Parameter then\n \n-               if Nkind (Item) = N_Defining_Identifier\n-                 and then Ekind (Item) = E_Out_Parameter\n-               then\n                   --  One case is an unconstrained array where the bounds\n                   --  must be read, if we have this case, output a message\n                   --  indicating why the OUT parameter is read.\n@@ -1167,8 +1187,8 @@ package body Sem_Prag is\n \n             else\n                Error_Msg_NE\n-                 (\"item & must appear in exactly one output list of aspect \"\n-                  & \"Depends\", Item, Item_Id);\n+                 (\"item & must appear in exactly one output dependence list \"\n+                  & \"(SPARK RM 6.1.5(10))\", Item, Item_Id);\n             end if;\n          end Usage_Error;\n \n@@ -1375,7 +1395,9 @@ package body Sem_Prag is\n             --  appear in the input list of a relation.\n \n             elsif Is_Attribute_Result (Output) then\n-               Error_Msg_N (\"function result cannot depend on itself\", Output);\n+               Error_Msg_N\n+                 (\"function result cannot depend on itself (SPARK RM \"\n+                  & \"6.1.5(10))\", Output);\n                return;\n             end if;\n \n@@ -1683,11 +1705,11 @@ package body Sem_Prag is\n       end if;\n    end Analyze_Depends_In_Decl_Part;\n \n-   -----------------------------------------\n-   -- Analyze_External_State_In_Decl_Part --\n-   -----------------------------------------\n+   --------------------------------------------\n+   -- Analyze_External_Property_In_Decl_Part --\n+   --------------------------------------------\n \n-   procedure Analyze_External_State_In_Decl_Part\n+   procedure Analyze_External_Property_In_Decl_Part\n      (N        : Node_Id;\n       Expr_Val : out Boolean)\n    is\n@@ -1701,16 +1723,19 @@ package body Sem_Prag is\n       --  The Async / Effective pragmas must apply to a volatile object other\n       --  than a formal subprogram parameter.\n \n-      if Is_Volatile_Object (Obj) then\n+      if Is_SPARK_Volatile_Object (Obj) then\n          if Is_Entity_Name (Obj)\n            and then Present (Entity (Obj))\n            and then Is_Formal (Entity (Obj))\n          then\n             Error_Msg_N\n-              (\"external state % cannot apply to a formal parameter\", N);\n+              (\"external property % cannot apply to a formal parameter \"\n+               & \"(SPARK RM 7.1.3(2))\", N);\n          end if;\n       else\n-         Error_Msg_N (\"external state % must apply to a volatile object\", N);\n+         Error_Msg_N\n+           (\"external property % must apply to a volatile object (SPARK RM \"\n+            & \"7.1.3(2))\", N);\n       end if;\n \n       --  Ensure that the expression (if present) is static Boolean. A missing\n@@ -1725,10 +1750,11 @@ package body Sem_Prag is\n             Expr_Val := Is_True (Expr_Value (Expr));\n          else\n             Error_Msg_Name_1 := Pragma_Name (N);\n-            Error_Msg_N (\"expression of % must be static\", Expr);\n+            Error_Msg_N\n+              (\"expression of % must be static (SPARK RM 7.1.2(5))\", Expr);\n          end if;\n       end if;\n-   end Analyze_External_State_In_Decl_Part;\n+   end Analyze_External_Property_In_Decl_Part;\n \n    ---------------------------------\n    -- Analyze_Global_In_Decl_Part --\n@@ -1833,19 +1859,31 @@ package body Sem_Prag is\n                if Is_Formal (Item_Id) then\n                   if Scope (Item_Id) = Spec_Id then\n                      Error_Msg_N\n-                       (\"global item cannot reference formal parameter\", Item);\n+                       (\"global item cannot reference formal parameter \"\n+                        & \"(SPARK RM 6.1.4(6))\", Item);\n                      return;\n                   end if;\n \n+               --  A constant cannot act as a global item. Do this check first\n+               --  to provide a better error diagnostic.\n+\n+               elsif Ekind (Item_Id) = E_Constant then\n+                  Error_Msg_N\n+                    (\"global item cannot denote a constant (SPARK RM \"\n+                     & \"6.1.4(7))\", Item);\n+\n                --  The only legal references are those to abstract states and\n                --  variables.\n \n                elsif not Ekind_In (Item_Id, E_Abstract_State, E_Variable) then\n                   Error_Msg_N\n-                    (\"global item must denote variable or state\", Item);\n+                    (\"global item must denote variable or state (SPARK RM \"\n+                     & \"6.1.4(4))\", Item);\n                   return;\n                end if;\n \n+               --  State related checks\n+\n                if Ekind (Item_Id) = E_Abstract_State then\n \n                   --  The state acts as a constituent of some other state.\n@@ -1868,7 +1906,25 @@ package body Sem_Prag is\n                   elsif Has_Visible_Refinement (Item_Id) then\n                      Error_Msg_NE\n                        (\"cannot mention state & in global refinement, use its \"\n-                        & \"constituents instead\", Item, Item_Id);\n+                        & \"constituents instead (SPARK RM 6.1.4(8))\",\n+                        Item, Item_Id);\n+                     return;\n+                  end if;\n+\n+               --  Variable related checks\n+\n+               else\n+                  --  A volatile object with property Effective_Reads set to\n+                  --  True must have mode Output or In_Out.\n+\n+                  if Is_SPARK_Volatile_Object (Item_Id)\n+                    and then Effective_Reads_Enabled (Item_Id)\n+                    and then Global_Mode = Name_Input\n+                  then\n+                     Error_Msg_NE\n+                       (\"volatile global item & with property Effective_Reads \"\n+                        & \"must have mode In_Out or Output (SPARK RM \"\n+                        & \"7.1.3(11))\", Item, Item_Id);\n                      return;\n                   end if;\n                end if;\n@@ -1884,38 +1940,12 @@ package body Sem_Prag is\n             --  Some form of illegal construct masquerading as a name\n \n             else\n-               Error_Msg_N (\"global item must denote variable or state\", Item);\n+               Error_Msg_N\n+                 (\"global item must denote variable or state (SPARK RM \"\n+                  & \"6.1.4(4))\", Item);\n                return;\n             end if;\n \n-            --  At this point we know that the global item is one of the two\n-            --  valid choices. Perform mode- and usage-specific checks.\n-\n-            if Ekind (Item_Id) = E_Abstract_State\n-              and then Is_External_State (Item_Id)\n-            then\n-               --  A global item of mode In_Out or Output cannot denote an\n-               --  external Input_Only state.\n-\n-               if Is_Input_Only_State (Item_Id)\n-                 and then Nam_In (Global_Mode, Name_In_Out, Name_Output)\n-               then\n-                  Error_Msg_N\n-                    (\"global item of mode In_Out or Output cannot reference \"\n-                     & \"External Input_Only state\", Item);\n-\n-               --  A global item of mode In_Out or Input cannot reference an\n-               --  external Output_Only state.\n-\n-               elsif Is_Output_Only_State (Item_Id)\n-                 and then Nam_In (Global_Mode, Name_In_Out, Name_Input)\n-               then\n-                  Error_Msg_N\n-                    (\"global item of mode In_Out or Input cannot reference \"\n-                     & \"External Output_Only state\", Item);\n-               end if;\n-            end if;\n-\n             --  Verify that an output does not appear as an input in an\n             --  enclosing subprogram.\n \n@@ -1928,19 +1958,20 @@ package body Sem_Prag is\n             --  a standard Ada legality rule.\n \n             if SPARK_Mode = On\n-              and then Is_Volatile_Object (Item)\n+              and then Is_SPARK_Volatile_Object (Item)\n               and then Ekind_In (Spec_Id, E_Function, E_Generic_Function)\n             then\n-               Error_Msg_N\n-                 (\"volatile object cannot act as global item of a function \"\n-                  & \"(SPARK RM 7.1.3(5))\", Item);\n+               Error_Msg_NE\n+                 (\"volatile object & cannot act as global item of a function \"\n+                  & \"(SPARK RM 7.1.3(9))\", Item, Item_Id);\n             end if;\n \n             --  The same entity might be referenced through various way. Check\n             --  the entity of the item rather than the item itself.\n \n             if Contains (Seen, Item_Id) then\n-               Error_Msg_N (\"duplicate global item\", Item);\n+               Error_Msg_N\n+                 (\"duplicate global item (SPARK RM 6.1.4(11))\", Item);\n \n             --  Add the entity of the current item to the list of processed\n             --  items.\n@@ -1960,7 +1991,7 @@ package body Sem_Prag is\n          is\n          begin\n             if Status then\n-               Error_Msg_N (\"duplicate global mode\", Mode);\n+               Error_Msg_N (\"duplicate global mode (SPARK RM 6.1.4(9))\", Mode);\n             end if;\n \n             Status := True;\n@@ -1986,7 +2017,10 @@ package body Sem_Prag is\n             Context := Scope (Subp_Id);\n             while Present (Context) and then Context /= Standard_Standard loop\n                if Is_Subprogram (Context)\n-                 and then Present (Get_Pragma (Context, Pragma_Global))\n+                 and then\n+                   (Present (Get_Pragma (Context, Pragma_Global))\n+                      or else\n+                    Present (Get_Pragma (Context, Pragma_Refined_Global)))\n                then\n                   Collect_Subprogram_Inputs_Outputs\n                     (Subp_Id      => Context,\n@@ -2001,8 +2035,8 @@ package body Sem_Prag is\n                     and then not Appears_In (Outputs, Item_Id)\n                   then\n                      Error_Msg_NE\n-                       (\"global item & cannot have mode In_Out or Output\",\n-                        Item, Item_Id);\n+                       (\"global item & cannot have mode In_Out or Output \"\n+                        & \"(SPARK RM 6.1.4(12))\", Item, Item_Id);\n                      Error_Msg_NE\n                        (\"\\item already appears as input of subprogram &\",\n                         Item, Context);\n@@ -2025,7 +2059,8 @@ package body Sem_Prag is\n          begin\n             if Ekind (Spec_Id) = E_Function then\n                Error_Msg_N\n-                 (\"global mode & not applicable to functions\", Mode);\n+                 (\"global mode & is not applicable to functions (SPARK RM \"\n+                  & \"6.1.4(10))\", Mode);\n             end if;\n          end Check_Mode_Restriction_In_Function;\n \n@@ -2460,12 +2495,15 @@ package body Sem_Prag is\n                      Error_Msg_Name_1 := Chars (Pack_Id);\n                      Error_Msg_NE\n                        (\"initialization item & must appear in the visible \"\n-                        & \"declarations of package %\", Item, Item_Id);\n+                        & \"declarations of package % (SPARK RM 7.1.5(7))\",\n+                        Item, Item_Id);\n \n                   --  Detect a duplicate use of the same initialization item\n \n                   elsif Contains (Items_Seen, Item_Id) then\n-                     Error_Msg_N (\"duplicate initialization item\", Item);\n+                     Error_Msg_N\n+                       (\"duplicate initialization item (SPARK RM 7.1.5(5))\",\n+                        Item);\n \n                   --  The item is legal, add it to the list of processed states\n                   --  and variables.\n@@ -2479,15 +2517,16 @@ package body Sem_Prag is\n \n                else\n                   Error_Msg_N\n-                    (\"initialization item must denote variable or state\",\n-                     Item);\n+                    (\"initialization item must denote variable or state \"\n+                     & \"(SPARK RM 7.1.5(3))\", Item);\n                end if;\n \n             --  Some form of illegal construct masquerading as a name\n \n             else\n                Error_Msg_N\n-                 (\"initialization item must denote variable or state\", Item);\n+                 (\"initialization item must denote variable or state (SPARK \"\n+                  & \"RM 7.1.5(3))\", Item);\n             end if;\n          end if;\n       end Analyze_Initialization_Item;\n@@ -2555,12 +2594,14 @@ package body Sem_Prag is\n                         Error_Msg_Name_1 := Chars (Pack_Id);\n                         Error_Msg_NE\n                           (\"input item & cannot denote a visible variable or \"\n-                           & \"state in package %\", Input, Input_Id);\n+                           & \"state of package % (SPARK RM 7.1.5(4))\",\n+                           Input, Input_Id);\n \n                      --  Detect a duplicate use of the same input item\n \n                      elsif Contains (Inputs_Seen, Input_Id) then\n-                        Error_Msg_N (\"duplicate input item\", Input);\n+                        Error_Msg_N\n+                          (\"duplicate input item (SPARK RM 7.1.5(5))\", Input);\n \n                      --  Input is legal, add it to the list of processed inputs\n \n@@ -2677,22 +2718,22 @@ package body Sem_Prag is\n    begin\n       Set_Analyzed (N);\n \n-      --  Initialize the various lists used during analysis\n-\n-      Collect_States_And_Variables;\n-\n-      --  All done if result is null\n+      --  Nothing to do when the initialization list is empty\n \n       if Nkind (Inits) = N_Null then\n          return;\n       end if;\n \n-      --  Single and multiple initialization clauses must appear as an\n-      --  aggregate. If this is not the case, then either the parser or\n-      --  the analysis of the pragma failed to produce an aggregate.\n+      --  Single and multiple initialization clauses appear as an aggregate. If\n+      --  this is not the case, then either the parser or the analysis of the\n+      --  pragma failed to produce an aggregate.\n \n       pragma Assert (Nkind (Inits) = N_Aggregate);\n \n+      --  Initialize the various lists used during analysis\n+\n+      Collect_States_And_Variables;\n+\n       if Present (Expressions (Inits)) then\n          Init := First (Expressions (Inits));\n          while Present (Init) loop\n@@ -9674,6 +9715,14 @@ package body Sem_Prag is\n                   Status : in out Boolean);\n                --  Flag Status denotes whether a particular option has been\n                --  seen while processing a state. This routine verifies that\n+               --  Opt is not a duplicate option and sets the flag Status.\n+\n+               procedure Check_Duplicate_Property\n+                 (Prop   : Node_Id;\n+                  Status : in out Boolean);\n+               --  Flag Status denotes whether a particular property has been\n+               --  seen while processing option External. This routine verifies\n+               --  that Prop is not a duplicate property and sets flag Status.\n                --  Opt is not a duplicate property and sets the flag Status.\n \n                -----------------------------\n@@ -9802,7 +9851,7 @@ package body Sem_Prag is\n                      else\n                         Error_Msg_N\n                           (\"expression of external state property must be \"\n-                           & \"static\", Expr);\n+                           & \"static (SPARK RM 7.1.2(5))\", Expr);\n                      end if;\n \n                   --  The lack of expression defaults the property to True\n@@ -9815,19 +9864,19 @@ package body Sem_Prag is\n \n                   if Nkind (Prop) = N_Identifier then\n                      if Chars (Prop) = Name_Async_Readers then\n-                        Check_Duplicate_Option (Prop, AR_Seen);\n+                        Check_Duplicate_Property (Prop, AR_Seen);\n                         AR_Val := Expr_Val;\n \n                      elsif Chars (Prop) = Name_Async_Writers then\n-                        Check_Duplicate_Option (Prop, AW_Seen);\n+                        Check_Duplicate_Property (Prop, AW_Seen);\n                         AW_Val := Expr_Val;\n \n                      elsif Chars (Prop) = Name_Effective_Reads then\n-                        Check_Duplicate_Option (Prop, ER_Seen);\n+                        Check_Duplicate_Property (Prop, ER_Seen);\n                         ER_Val := Expr_Val;\n \n                      else\n-                        Check_Duplicate_Option (Prop, EW_Seen);\n+                        Check_Duplicate_Property (Prop, EW_Seen);\n                         EW_Val := Expr_Val;\n                      end if;\n \n@@ -9889,12 +9938,31 @@ package body Sem_Prag is\n                is\n                begin\n                   if Status then\n-                     Error_Msg_N (\"duplicate state option\", Opt);\n+                     Error_Msg_N\n+                       (\"duplicate state option (SPARK RM 7.1.4(1))\", Opt);\n                   end if;\n \n                   Status := True;\n                end Check_Duplicate_Option;\n \n+               ------------------------------\n+               -- Check_Duplicate_Property --\n+               ------------------------------\n+\n+               procedure Check_Duplicate_Property\n+                 (Prop   : Node_Id;\n+                  Status : in out Boolean)\n+               is\n+               begin\n+                  if Status then\n+                     Error_Msg_N\n+                       (\"duplicate external property (SPARK RM 7.1.4(2))\",\n+                        Prop);\n+                  end if;\n+\n+                  Status := True;\n+               end Check_Duplicate_Property;\n+\n                --  Local variables\n \n                Errors    : constant Nat := Serious_Errors_Detected;\n@@ -9960,10 +10028,20 @@ package body Sem_Prag is\n                        and then Chars (Opt) = Name_External\n                      then\n                         Analyze_External_Option (Opt);\n+\n+                     --  When an erroneous option Part_Of is without a parent\n+                     --  state, it appears in the list of expression of the\n+                     --  aggregate rather than the component associations.\n+\n+                     elsif Chars (Opt) = Name_Part_Of then\n+                        Error_Msg_N\n+                          (\"option Part_Of must denote an abstract state \"\n+                           & \"(SPARK RM 7.1.4(9))\", Opt);\n+\n                      else\n                         Error_Msg_N\n-                          (\"simple option not allowed in state declaration\",\n-                           Opt);\n+                          (\"simple option not allowed in state declaration \"\n+                           & \"(SPARK RM 7.1.4(3))\", Opt);\n                      end if;\n \n                      Next (Opt);\n@@ -10876,7 +10954,8 @@ package body Sem_Prag is\n             --  If we get here, then the pragma applies to a non-object\n             --  construct, issue a generic error.\n \n-            Error_Pragma (\"pragma % must apply to a volatile object\");\n+            Error_Pragma\n+              (\"pragma % must apply to a volatile object (SPARK RM 7.1.3(2))\");\n          end Async_Effective;\n \n          ------------------\n@@ -18023,7 +18102,7 @@ package body Sem_Prag is\n             then\n                Error_Msg_NE\n                  (\"useless refinement, package & does not define abstract \"\n-                  & \"states\", N, Spec_Id);\n+                  & \"states (SPARK RM 7.2.2(3))\", N, Spec_Id);\n                return;\n             end if;\n \n@@ -20619,12 +20698,12 @@ package body Sem_Prag is\n       Depends      : Node_Id;\n       --  The corresponding Depends pragma along with its clauses\n \n-      Global : Node_Id := Empty;\n-      --  The corresponding Refined_Global pragma (if any)\n-\n       Out_Items : Elist_Id := No_Elist;\n       --  All output items as defined in pragma Refined_Global (if any)\n \n+      Ref_Global : Node_Id := Empty;\n+      --  The corresponding Refined_Global pragma (if any)\n+\n       Refinements : List_Id := No_List;\n       --  The clauses of pragma Refined_Depends\n \n@@ -20649,14 +20728,6 @@ package body Sem_Prag is\n          --  clause Ref_Clause. If flag Do_Checks is set, the routine reports\n          --  missed or extra input items.\n \n-         function Output_Constituents (State_Id : Entity_Id) return Elist_Id;\n-         --  Given a state denoted by State_Id, return a list of all output\n-         --  constituents that may be referenced within Refined_Depends. The\n-         --  contents of the list depend on whether Refined_Global is present.\n-\n-         procedure Report_Unused_Constituents (Constits : Elist_Id);\n-         --  Emit errors for all constituents found in list Constits\n-\n          ------------------\n          -- Inputs_Match --\n          ------------------\n@@ -20969,86 +21040,6 @@ package body Sem_Prag is\n             return Result;\n          end Inputs_Match;\n \n-         -------------------------\n-         -- Output_Constituents --\n-         -------------------------\n-\n-         function Output_Constituents (State_Id : Entity_Id) return Elist_Id is\n-            Item_Elmt : Elmt_Id;\n-            Item_Id   : Entity_Id;\n-            Result    : Elist_Id := No_Elist;\n-\n-         begin\n-            --  The related subprogram is subject to pragma Refined_Global. All\n-            --  usable output constituents are defined in its output item list.\n-\n-            if Present (Global) then\n-               Item_Elmt := First_Elmt (Out_Items);\n-               while Present (Item_Elmt) loop\n-                  Item_Id := Node (Item_Elmt);\n-\n-                  --  The constituent is part of the refinement of the input\n-                  --  state, add it to the result list.\n-\n-                  if Refined_State (Item_Id) = State_Id then\n-                     Add_Item (Item_Id, Result);\n-                  end if;\n-\n-                  Next_Elmt (Item_Elmt);\n-               end loop;\n-\n-            --  When pragma Refined_Global is not present, the usable output\n-            --  constituents are all the constituents as defined in pragma\n-            --  Refined_State. Note that the elements are copied because the\n-            --  algorithm trims the list and this should not be reflected in\n-            --  the state itself.\n-\n-            else\n-               Result := New_Copy_Elist (Refinement_Constituents (State_Id));\n-            end if;\n-\n-            return Result;\n-         end Output_Constituents;\n-\n-         --------------------------------\n-         -- Report_Unused_Constituents --\n-         --------------------------------\n-\n-         procedure Report_Unused_Constituents (Constits : Elist_Id) is\n-            Constit : Entity_Id;\n-            Elmt    : Elmt_Id;\n-            Posted  : Boolean := False;\n-\n-         begin\n-            if Present (Constits) then\n-               Elmt := First_Elmt (Constits);\n-               while Present (Elmt) loop\n-                  Constit := Node (Elmt);\n-\n-                  --  A constituent must always refine a state\n-\n-                  pragma Assert (Present (Refined_State (Constit)));\n-\n-                  --  When a state has a visible refinement and its mode is\n-                  --  Output_Only, all its constituents must be used as\n-                  --  outputs.\n-\n-                  if not Posted then\n-                     Posted := True;\n-                     Error_Msg_NE\n-                       (\"output only state & must be replaced by all its \"\n-                        & \"constituents in dependence refinement\",\n-                        N, Refined_State (Constit));\n-                  end if;\n-\n-                  Error_Msg_NE\n-                    (\"\\  constituent & is missing in output list\", N, Constit);\n-\n-                  Next_Elmt (Elmt);\n-               end loop;\n-            end if;\n-         end Report_Unused_Constituents;\n-\n          --  Local variables\n \n          Dep_Output      : constant Node_Id := First (Choices (Dep_Clause));\n@@ -21071,10 +21062,6 @@ package body Sem_Prag is\n          --  Flag set when the output of clause Dep_Clause is a state with\n          --  visible refinement.\n \n-         Out_Constits : Elist_Id := No_Elist;\n-         --  This list contains the entities all output constituents of state\n-         --  Dep_Id as defined in pragma Refined_State.\n-\n       --  Start of processing for Check_Dependency_Clause\n \n       begin\n@@ -21177,15 +21164,6 @@ package body Sem_Prag is\n                   elsif Has_Non_Null_Refinement (Dep_Id) then\n                      Has_Refined_State := True;\n \n-                     --  Store the entities of all output constituents of an\n-                     --  Output_Only state with visible refinement.\n-\n-                     if No (Out_Constits)\n-                       and then Is_Output_Only_State (Dep_Id)\n-                     then\n-                        Out_Constits := Output_Constituents (Dep_Id);\n-                     end if;\n-\n                      if Is_Entity_Name (Ref_Output) then\n                         Ref_Id := Entity_Of (Ref_Output);\n \n@@ -21204,12 +21182,6 @@ package body Sem_Prag is\n                         then\n                            Has_Constituent := True;\n                            Remove (Ref_Clause);\n-\n-                           --  The matching constituent may act as an output\n-                           --  for an Output_Only state. Remove the item from\n-                           --  the available output constituents.\n-\n-                           Remove (Out_Constits, Ref_Id);\n                         end if;\n                      end if;\n \n@@ -21296,11 +21268,6 @@ package body Sem_Prag is\n                   Ref_Clause);\n             end if;\n          end if;\n-\n-         --  Emit errors for all unused constituents of an Output_Only state\n-         --  with visible refinement.\n-\n-         Report_Unused_Constituents (Out_Constits);\n       end Check_Dependency_Clause;\n \n       --------------------------\n@@ -21343,8 +21310,8 @@ package body Sem_Prag is\n       --  The following are dummy variables that capture unused output of\n       --  routine Collect_Global_Items.\n \n-      D1, D2         : Elist_Id := No_Elist;\n-      D3, D4, D5, D6 : Boolean;\n+      D1, D2, D3         : Elist_Id := No_Elist;\n+      D4, D5, D6, D7, D8 : Boolean;\n \n    --  Start of processing for Analyze_Refined_Depends_In_Decl_Part\n \n@@ -21357,8 +21324,8 @@ package body Sem_Prag is\n \n       if No (Depends) then\n          Error_Msg_NE\n-           (\"useless refinement, subprogram & lacks dependence clauses\",\n-            N, Spec_Id);\n+           (\"useless refinement, subprogram & lacks dependence clauses (SPARK \"\n+            & \"RM 7.2.5(2))\", N, Spec_Id);\n          return;\n       end if;\n \n@@ -21371,7 +21338,7 @@ package body Sem_Prag is\n       if Nkind (Deps) = N_Null then\n          Error_Msg_NE\n            (\"useless refinement, subprogram & does not depend on abstract \"\n-            & \"state with visible refinement\", N, Spec_Id);\n+            & \"state with visible refinement (SPARK RM 7.2.5(2))\", N, Spec_Id);\n          return;\n       end if;\n \n@@ -21395,18 +21362,20 @@ package body Sem_Prag is\n          --  verifying the use of constituents that apply to output states with\n          --  visible refinement.\n \n-         Global := Get_Pragma (Body_Id, Pragma_Refined_Global);\n+         Ref_Global := Get_Pragma (Body_Id, Pragma_Refined_Global);\n \n-         if Present (Global) then\n+         if Present (Ref_Global) then\n             Collect_Global_Items\n-              (Prag             => Global,\n-               In_Items         => D1,\n-               In_Out_Items     => D2,\n-               Out_Items        => Out_Items,\n-               Has_In_State     => D3,\n-               Has_In_Out_State => D4,\n-               Has_Out_State    => D5,\n-               Has_Null_State   => D6);\n+              (Prag               => Ref_Global,\n+               In_Items           => D1,\n+               In_Out_Items       => D2,\n+               Out_Items          => Out_Items,\n+               Proof_In_Items     => D3,\n+               Has_In_State       => D4,\n+               Has_In_Out_State   => D5,\n+               Has_Out_State      => D6,\n+               Has_Proof_In_State => D7,\n+               Has_Null_State     => D8);\n          end if;\n \n          if Nkind (Refs) = N_Null then\n@@ -21455,29 +21424,32 @@ package body Sem_Prag is\n       Global : Node_Id;\n       --  The corresponding Global pragma\n \n-      Has_In_State     : Boolean := False;\n-      Has_In_Out_State : Boolean := False;\n-      Has_Out_State    : Boolean := False;\n+      Has_In_State       : Boolean := False;\n+      Has_In_Out_State   : Boolean := False;\n+      Has_Out_State      : Boolean := False;\n+      Has_Proof_In_State : Boolean := False;\n       --  These flags are set when the corresponding Global pragma has a state\n-      --  of mode Input, In_Out and Output respectively with a visible\n+      --  of mode Input, In_Out, Output or Proof_In respectively with a visible\n       --  refinement.\n \n       Has_Null_State : Boolean := False;\n       --  This flag is set when the corresponding Global pragma has at least\n       --  one state with a null refinement.\n \n-      In_Constits     : Elist_Id := No_Elist;\n-      In_Out_Constits : Elist_Id := No_Elist;\n-      Out_Constits    : Elist_Id := No_Elist;\n-      --  These lists contain the entities of all Input, In_Out and Output\n-      --  constituents that appear in Refined_Global and participate in state\n-      --  refinement.\n-\n-      In_Items     : Elist_Id := No_Elist;\n-      In_Out_Items : Elist_Id := No_Elist;\n-      Out_Items    : Elist_Id := No_Elist;\n-      --  These list contain the entities of all Input, In_Out and Output items\n-      --  defined in the corresponding Global pragma.\n+      In_Constits       : Elist_Id := No_Elist;\n+      In_Out_Constits   : Elist_Id := No_Elist;\n+      Out_Constits      : Elist_Id := No_Elist;\n+      Proof_In_Constits : Elist_Id := No_Elist;\n+      --  These lists contain the entities of all Input, In_Out, Output and\n+      --  Proof_In constituents that appear in Refined_Global and participate\n+      --  in state refinement.\n+\n+      In_Items       : Elist_Id := No_Elist;\n+      In_Out_Items   : Elist_Id := No_Elist;\n+      Out_Items      : Elist_Id := No_Elist;\n+      Proof_In_Items : Elist_Id := No_Elist;\n+      --  These list contain the entities of all Input, In_Out, Output and\n+      --  Proof_In items defined in the corresponding Global pragma.\n \n       procedure Check_In_Out_States;\n       --  Determine whether the corresponding Global pragma mentions In_Out\n@@ -21487,22 +21459,29 @@ package body Sem_Prag is\n       --    2) there is at least one Input and one Output constituent\n       --    3) not all constituents are present and one of them is of mode\n       --       Output.\n-      --  This routine may remove elements from In_Constits, In_Out_Constits\n-      --  and Out_Constits.\n+      --  This routine may remove elements from In_Constits, In_Out_Constits,\n+      --  Out_Constits and Proof_In_Constits.\n \n       procedure Check_Input_States;\n       --  Determine whether the corresponding Global pragma mentions Input\n       --  states with visible refinement and if so, ensure that at least one of\n       --  its constituents appears as an Input item in Refined_Global.\n-      --  This routine may remove elements from In_Constits, In_Out_Constits\n-      --  and Out_Constits.\n+      --  This routine may remove elements from In_Constits, In_Out_Constits,\n+      --  Out_Constits and Proof_In_Constits.\n \n       procedure Check_Output_States;\n       --  Determine whether the corresponding Global pragma mentions Output\n       --  states with visible refinement and if so, ensure that all of its\n-      --  constituents appear as Output items in Refined_Global. This routine\n-      --  may remove elements from In_Constits, In_Out_Constits and\n-      --  Out_Constits.\n+      --  constituents appear as Output items in Refined_Global.\n+      --  This routine may remove elements from In_Constits, In_Out_Constits,\n+      --  Out_Constits and Proof_In_Constits.\n+\n+      procedure Check_Proof_In_States;\n+      --  Determine whether the corresponding Global pragma mentions Proof_In\n+      --  states with visible refinement and if so, ensure that at least one of\n+      --  its constituents appears as a Proof_In item in Refined_Global.\n+      --  This routine may remove elements from In_Constits, In_Out_Constits,\n+      --  Out_Constits and Proof_In_Constits.\n \n       procedure Check_Refined_Global_List\n         (List        : Node_Id;\n@@ -21564,6 +21543,16 @@ package body Sem_Prag is\n                elsif Present_Then_Remove (Out_Constits, Constit_Id) then\n                   Out_Seen := True;\n \n+               --  A Proof_In constituent cannot participate in the completion\n+               --  of an Output state.\n+\n+               elsif Present_Then_Remove (Proof_In_Constits, Constit_Id) then\n+                  Error_Msg_Name_1 := Chars (State_Id);\n+                  Error_Msg_NE\n+                    (\"constituent & of state % must have mode Input, In_Out \"\n+                     & \"or Output in global refinement (SPARK RM 7.2.4(5))\",\n+                     N, Constit_Id);\n+\n                else\n                   Has_Missing := True;\n                end if;\n@@ -21591,7 +21580,7 @@ package body Sem_Prag is\n             else\n                Error_Msg_NE\n                  (\"global refinement of state & redefines the mode of its \"\n-                  & \"constituents\", N, State_Id);\n+                  & \"constituents (SPARK RM 7.2.4(5))\", N, State_Id);\n             end if;\n          end Check_Constituent_Usage;\n \n@@ -21632,7 +21621,8 @@ package body Sem_Prag is\n          procedure Check_Constituent_Usage (State_Id : Entity_Id);\n          --  Determine whether at least one constituent of state State_Id with\n          --  visible refinement is used and has mode Input. Ensure that the\n-         --  remaining constituents do not have In_Out or Output modes.\n+         --  remaining constituents do not have In_Out, Output or Proof_In\n+         --  modes.\n \n          -----------------------------\n          -- Check_Constituent_Usage --\n@@ -21654,15 +21644,16 @@ package body Sem_Prag is\n                   In_Seen := True;\n \n                --  The constituent appears in the global refinement, but has\n-               --  mode In_Out or Output.\n+               --  mode In_Out, Output or Proof_In.\n \n                elsif Present_Then_Remove (In_Out_Constits, Constit_Id)\n                  or else Present_Then_Remove (Out_Constits, Constit_Id)\n+                 or else Present_Then_Remove (Proof_In_Constits, Constit_Id)\n                then\n                   Error_Msg_Name_1 := Chars (State_Id);\n                   Error_Msg_NE\n                     (\"constituent & of state % must have mode Input in global \"\n-                     & \"refinement\", N, Constit_Id);\n+                     & \"refinement (SPARK RM 7.2.4(5))\", N, Constit_Id);\n                end if;\n \n                Next_Elmt (Constit_Elmt);\n@@ -21724,6 +21715,7 @@ package body Sem_Prag is\n          procedure Check_Constituent_Usage (State_Id : Entity_Id) is\n             Constit_Elmt : Elmt_Id;\n             Constit_Id   : Entity_Id;\n+            Posted       : Boolean := False;\n \n          begin\n             Constit_Elmt := First_Elmt (Refinement_Constituents (State_Id));\n@@ -21733,14 +21725,32 @@ package body Sem_Prag is\n                if Present_Then_Remove (Out_Constits, Constit_Id) then\n                   null;\n \n-               else\n-                  Remove (In_Constits, Constit_Id);\n-                  Remove (In_Out_Constits, Constit_Id);\n+               --  The constituent appears in the global refinement, but has\n+               --  mode Input, In_Out or Proof_In.\n \n+               elsif Present_Then_Remove (In_Constits, Constit_Id)\n+                 or else Present_Then_Remove (In_Out_Constits, Constit_Id)\n+                 or else Present_Then_Remove (Proof_In_Constits, Constit_Id)\n+               then\n                   Error_Msg_Name_1 := Chars (State_Id);\n                   Error_Msg_NE\n                     (\"constituent & of state % must have mode Output in \"\n-                     & \"global refinement\", N, Constit_Id);\n+                     & \"global refinement (SPARK RM 7.2.4(5))\", N, Constit_Id);\n+\n+               --  The constituent is altogether missing\n+\n+               else\n+                  if not Posted then\n+                     Posted := True;\n+                     Error_Msg_NE\n+                       (\"output state & must be replaced by all its \"\n+                        & \"constituents in global refinement (SPARK RM \"\n+                        & \"7.2.5(3))\", N, State_Id);\n+                  end if;\n+\n+                  Error_Msg_NE\n+                    (\"\\  constituent & is missing in output list\",\n+                     N, Constit_Id);\n                end if;\n \n                Next_Elmt (Constit_Elmt);\n@@ -21777,6 +21787,90 @@ package body Sem_Prag is\n          end if;\n       end Check_Output_States;\n \n+      ---------------------------\n+      -- Check_Proof_In_States --\n+      ---------------------------\n+\n+      procedure Check_Proof_In_States is\n+         procedure Check_Constituent_Usage (State_Id : Entity_Id);\n+         --  Determine whether at least one constituent of state State_Id with\n+         --  visible refinement is used and has mode Proof_In. Ensure that the\n+         --  remaining constituents do not have Input, In_Out or Output modes.\n+\n+         -----------------------------\n+         -- Check_Constituent_Usage --\n+         -----------------------------\n+\n+         procedure Check_Constituent_Usage (State_Id : Entity_Id) is\n+            Constit_Elmt  : Elmt_Id;\n+            Constit_Id    : Entity_Id;\n+            Proof_In_Seen : Boolean := False;\n+\n+         begin\n+            Constit_Elmt := First_Elmt (Refinement_Constituents (State_Id));\n+            while Present (Constit_Elmt) loop\n+               Constit_Id := Node (Constit_Elmt);\n+\n+               --  At least one of the constituents appears as Proof_In\n+\n+               if Present_Then_Remove (Proof_In_Constits, Constit_Id) then\n+                  Proof_In_Seen := True;\n+\n+               --  The constituent appears in the global refinement, but has\n+               --  mode Input, In_Out or Output.\n+\n+               elsif Present_Then_Remove (In_Constits, Constit_Id)\n+                 or else Present_Then_Remove (In_Out_Constits, Constit_Id)\n+                 or else Present_Then_Remove (Out_Constits, Constit_Id)\n+               then\n+                  Error_Msg_Name_1 := Chars (State_Id);\n+                  Error_Msg_NE\n+                    (\"constituent & of state % must have mode Proof_In in \"\n+                     & \"global refinement (SPARK RM 7.2.4(5))\", N, Constit_Id);\n+               end if;\n+\n+               Next_Elmt (Constit_Elmt);\n+            end loop;\n+\n+            --  Not one of the constituents appeared as Proof_In\n+\n+            if not Proof_In_Seen then\n+               Error_Msg_NE\n+                 (\"global refinement of state & must include at least one \"\n+                  & \"constituent of mode Proof_In\", N, State_Id);\n+            end if;\n+         end Check_Constituent_Usage;\n+\n+         --  Local variables\n+\n+         Item_Elmt : Elmt_Id;\n+         Item_Id   : Entity_Id;\n+\n+      --  Start of processing for Check_Proof_In_States\n+\n+      begin\n+         --  Inspect the Proof_In items of the corresponding Global pragma\n+         --  looking for a state with a visible refinement.\n+\n+         if Has_Proof_In_State and then Present (Proof_In_Items) then\n+            Item_Elmt := First_Elmt (Proof_In_Items);\n+            while Present (Item_Elmt) loop\n+               Item_Id := Node (Item_Elmt);\n+\n+               --  Ensure that at least one of the constituents is utilized and\n+               --  is of mode Proof_In\n+\n+               if Ekind (Item_Id) = E_Abstract_State\n+                 and then Has_Non_Null_Refinement (Item_Id)\n+               then\n+                  Check_Constituent_Usage (Item_Id);\n+               end if;\n+\n+               Next_Elmt (Item_Elmt);\n+            end loop;\n+         end if;\n+      end Check_Proof_In_States;\n+\n       -------------------------------\n       -- Check_Refined_Global_List --\n       -------------------------------\n@@ -21836,6 +21930,9 @@ package body Sem_Prag is\n \n                elsif Global_Mode = Name_Output then\n                   Add_Item (Item_Id, Out_Constits);\n+\n+               elsif Global_Mode = Name_Proof_In then\n+                  Add_Item (Item_Id, Proof_In_Constits);\n                end if;\n \n             --  When not a constituent, ensure that both occurrences of the\n@@ -21856,11 +21953,15 @@ package body Sem_Prag is\n                   Inconsistent_Mode_Error (Name_Output);\n                end if;\n \n+            elsif Contains (Proof_In_Items, Item_Id) then\n+               null;\n+\n             --  The item does not appear in the corresponding Global pragma, it\n             --  must be an extra.\n \n             else\n-               Error_Msg_NE (\"extra global item &\", Item, Item_Id);\n+               Error_Msg_NE\n+                 (\"extra global item & (SPARK RM 7.2.4(3))\", Item, Item_Id);\n             end if;\n          end Check_Refined_Global_Item;\n \n@@ -21981,6 +22082,7 @@ package body Sem_Prag is\n          Report_Extra_Constituents_In_List (In_Constits);\n          Report_Extra_Constituents_In_List (In_Out_Constits);\n          Report_Extra_Constituents_In_List (Out_Constits);\n+         Report_Extra_Constituents_In_List (Proof_In_Constits);\n       end Report_Extra_Constituents;\n \n       --  Local variables\n@@ -22008,14 +22110,16 @@ package body Sem_Prag is\n       --  Extract all relevant items from the corresponding Global pragma\n \n       Collect_Global_Items\n-        (Prag             => Global,\n-         In_Items         => In_Items,\n-         In_Out_Items     => In_Out_Items,\n-         Out_Items        => Out_Items,\n-         Has_In_State     => Has_In_State,\n-         Has_In_Out_State => Has_In_Out_State,\n-         Has_Out_State    => Has_Out_State,\n-         Has_Null_State   => Has_Null_State);\n+        (Prag               => Global,\n+         In_Items           => In_Items,\n+         In_Out_Items       => In_Out_Items,\n+         Out_Items          => Out_Items,\n+         Proof_In_Items     => Proof_In_Items,\n+         Has_In_State       => Has_In_State,\n+         Has_In_Out_State   => Has_In_Out_State,\n+         Has_Out_State      => Has_Out_State,\n+         Has_Proof_In_State => Has_Proof_In_State,\n+         Has_Null_State     => Has_Null_State);\n \n       --  The corresponding Global pragma must mention at least one state with\n       --  a visible refinement at the point Refined_Global is processed. States\n@@ -22024,6 +22128,7 @@ package body Sem_Prag is\n       if not Has_In_State\n         and then not Has_In_Out_State\n         and then not Has_Out_State\n+        and then not Has_Proof_In_State\n         and then not Has_Null_State\n       then\n          Error_Msg_NE\n@@ -22040,7 +22145,8 @@ package body Sem_Prag is\n         and then\n           (Present (In_Items)\n             or else Present (In_Out_Items)\n-            or else Present (Out_Items))\n+            or else Present (Out_Items)\n+            or else Present (Proof_In_Items))\n         and then not Has_Null_State\n       then\n          Error_Msg_NE\n@@ -22083,6 +22189,13 @@ package body Sem_Prag is\n          Check_Output_States;\n       end if;\n \n+      --  For Proof_In states with visible refinement, at least one constituent\n+      --  must be used as Proof_In in the global refinement.\n+\n+      if Serious_Errors_Detected = Errors then\n+         Check_Proof_In_States;\n+      end if;\n+\n       --  Emit errors for all constituents that belong to other states with\n       --  visible refinement that do not appear in Global.\n \n@@ -22275,7 +22388,8 @@ package body Sem_Prag is\n                Error_Msg_Name_1 := Chars (Spec_Id);\n                Error_Msg_NE\n                  (\"cannot use & in refinement, constituent is not a hidden \"\n-                  & \"state of package %\", Constit, Constit_Id);\n+                  & \"state of package % (SPARK RM 7.2.2(9))\",\n+                  Constit, Constit_Id);\n             end Check_Matching_Constituent;\n \n             --  Local variables\n@@ -22335,8 +22449,8 @@ package body Sem_Prag is\n \n                   else\n                      Error_Msg_NE\n-                       (\"constituent & must denote a variable or state\",\n-                        Constit, Constit_Id);\n+                       (\"constituent & must denote a variable or state (SPARK \"\n+                        & \"RM 7.2.2(5))\", Constit, Constit_Id);\n                   end if;\n \n                --  The constituent is illegal\n@@ -22362,7 +22476,8 @@ package body Sem_Prag is\n \n             if Contains (Refined_States_Seen, State_Id) then\n                Error_Msg_NE\n-                 (\"duplicate refinement of state &\", State, State_Id);\n+                 (\"duplicate refinement of state & (SPARK RM 7.2.2(8))\",\n+                  State, State_Id);\n                return;\n             end if;\n \n@@ -22432,25 +22547,28 @@ package body Sem_Prag is\n                        (\"& must denote an abstract state\", State, State_Id);\n                   end if;\n \n-                  --  Enforce SPARK RM (6.1.5(4)): A global item shall not\n-                  --  denote a state abstraction whose refinement is visible\n-                  --  (a state abstraction cannot be named within its enclosing\n-                  --  package's body other than in its refinement).\n+                  --  A global item cannot denote a state abstraction whose\n+                  --  refinement is visible, in other words a state abstraction\n+                  --  cannot be named within its enclosing package's body other\n+                  --  than in its refinement.\n \n                   if Has_Body_References (State_Id) then\n                      declare\n-                        Ref : Elmt_Id;\n-                        Nod : Node_Id;\n+                        Ref      : Node_Id;\n+                        Ref_Elmt : Elmt_Id;\n+\n                      begin\n-                        Ref := First_Elmt (Body_References (State_Id));\n-                        while Present (Ref) loop\n-                           Nod := Node (Ref);\n+                        Ref_Elmt := First_Elmt (Body_References (State_Id));\n+                        while Present (Ref_Elmt) loop\n+                           Ref := Node (Ref_Elmt);\n+\n                            Error_Msg_N\n-                             (\"global reference to & not allowed \"\n-                              & \"(SPARK RM 6.1.5(4))\", Nod);\n+                             (\"global reference to & not allowed (SPARK RM \"\n+                              & \"6.1.4(8))\", Ref);\n                            Error_Msg_Sloc := Sloc (State);\n-                           Error_Msg_N (\"\\refinement of & is visible#\", Nod);\n-                           Next_Elmt (Ref);\n+                           Error_Msg_N (\"\\refinement of & is visible#\", Ref);\n+\n+                           Next_Elmt (Ref_Elmt);\n                         end loop;\n                      end;\n                   end if;\n@@ -22783,7 +22901,8 @@ package body Sem_Prag is\n \n       else\n          Error_Msg_N\n-           (\"illegal combination of external state properties\", Item);\n+           (\"illegal combination of external properties (SPARK RM 7.1.2(6))\",\n+            Item);\n       end if;\n    end Check_External_Properties;\n \n@@ -22927,14 +23046,16 @@ package body Sem_Prag is\n    --------------------------\n \n    procedure Collect_Global_Items\n-     (Prag             : Node_Id;\n-      In_Items         : in out Elist_Id;\n-      In_Out_Items     : in out Elist_Id;\n-      Out_Items        : in out Elist_Id;\n-      Has_In_State     : out Boolean;\n-      Has_In_Out_State : out Boolean;\n-      Has_Out_State    : out Boolean;\n-      Has_Null_State   : out Boolean)\n+     (Prag               : Node_Id;\n+      In_Items           : in out Elist_Id;\n+      In_Out_Items       : in out Elist_Id;\n+      Out_Items          : in out Elist_Id;\n+      Proof_In_Items     : in out Elist_Id;\n+      Has_In_State       : out Boolean;\n+      Has_In_Out_State   : out Boolean;\n+      Has_Out_State      : out Boolean;\n+      Has_Proof_In_State : out Boolean;\n+      Has_Null_State     : out Boolean)\n    is\n       procedure Process_Global_List\n         (List : Node_Id;\n@@ -22979,6 +23100,8 @@ package body Sem_Prag is\n                      Has_In_Out_State := True;\n                   elsif Mode = Name_Output then\n                      Has_Out_State := True;\n+                  elsif Mode = Name_Proof_In then\n+                     Has_Proof_In_State := True;\n                   end if;\n                end if;\n             end if;\n@@ -22991,6 +23114,8 @@ package body Sem_Prag is\n                Add_Item (Item_Id, In_Out_Items);\n             elsif Mode = Name_Output then\n                Add_Item (Item_Id, Out_Items);\n+            elsif Mode = Name_Proof_In then\n+               Add_Item (Item_Id, Proof_In_Items);\n             end if;\n          end Process_Global_Item;\n \n@@ -23063,10 +23188,11 @@ package body Sem_Prag is\n    begin\n       --  Assume that no states have been encountered\n \n-      Has_In_State     := False;\n-      Has_In_Out_State := False;\n-      Has_Out_State    := False;\n-      Has_Null_State   := False;\n+      Has_In_State       := False;\n+      Has_In_Out_State   := False;\n+      Has_Out_State      := False;\n+      Has_Proof_In_State := False;\n+      Has_Null_State     := False;\n \n       Process_Global_List (Items);\n    end Collect_Global_Items;"}, {"sha": "730643a1c5159582bdfd6a8b6a98de7279b6ffa8", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "patch": "@@ -60,7 +60,7 @@ package Sem_Prag is\n    --  Perform full analysis of delayed pragma Depends. This routine is also\n    --  capable of performing basic analysis of pragma Refined_Depends.\n \n-   procedure Analyze_External_State_In_Decl_Part\n+   procedure Analyze_External_Property_In_Decl_Part\n      (N        : Node_Id;\n       Expr_Val : out Boolean);\n    --  Perform full analysis of delayed pragmas Async_Readers, Async_Writers,"}, {"sha": "59986f521af7743d256cd6c4e53923e908708947", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "patch": "@@ -4041,6 +4041,16 @@ package body Sem_Res is\n                then\n                   Apply_Discriminant_Check (A, F_Typ);\n \n+                  --  For view conversions of a discriminated object, apply\n+                  --  check to object itself, the conversion alreay has the\n+                  --  proper type.\n+\n+                  if Nkind (A) = N_Type_Conversion\n+                    and then Is_Constrained (Etype (Expression (A)))\n+                  then\n+                     Apply_Discriminant_Check (Expression (A), F_Typ);\n+                  end if;\n+\n                elsif Is_Access_Type (F_Typ)\n                  and then Is_Array_Type (Designated_Type (F_Typ))\n                  and then Is_Constrained (Designated_Type (F_Typ))\n@@ -4254,7 +4264,7 @@ package body Sem_Res is\n             --  they are not standard Ada legality rule.\n \n             if SPARK_Mode = On\n-              and then Is_Volatile_Object (A)\n+              and then Is_SPARK_Volatile_Object (A)\n             then\n                --  A volatile object may act as an actual parameter when the\n                --  corresponding formal is of a non-scalar volatile type.\n@@ -4273,7 +4283,7 @@ package body Sem_Res is\n                else\n                   Error_Msg_N\n                     (\"volatile object cannot act as actual in a call (SPARK \"\n-                     & \"RM 7.1.3(8))\", A);\n+                     & \"RM 7.1.3(12))\", A);\n                end if;\n             end if;\n \n@@ -6497,8 +6507,7 @@ package body Sem_Res is\n       --  standard Ada legality rules.\n \n       if SPARK_Mode = On\n-        and then Ekind (E) = E_Variable\n-        and then Is_Volatile_Object (E)\n+        and then Is_SPARK_Volatile_Object (E)\n         and then\n           (Async_Writers_Enabled (E)\n              or else Effective_Reads_Enabled (E))\n@@ -6555,7 +6564,7 @@ package body Sem_Res is\n          if not Usage_OK then\n             Error_Msg_N\n               (\"volatile object cannot appear in this context (SPARK RM \"\n-               & \"7.1.3(9))\", N);\n+               & \"7.1.3(13))\", N);\n          end if;\n       end if;\n    end Resolve_Entity_Name;"}, {"sha": "d41eb3a75a519fd2496ac36474ae1bb00876a450", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "patch": "@@ -3729,14 +3729,9 @@ package body Sem_Util is\n          else\n             Item_Id := Entity_Of (Item);\n \n-            --  Defend against junk\n-\n-            if No (Item_Id) then\n-               return False;\n-            end if;\n-\n             return\n-              Ekind (Item_Id) = E_Abstract_State\n+              Present (Item_Id)\n+                and then Ekind (Item_Id) = E_Abstract_State\n                 and then Has_Visible_Refinement (Item_Id);\n          end if;\n       end Is_Refined_State;\n@@ -8097,6 +8092,34 @@ package body Sem_Util is\n       end if;\n    end Has_Tagged_Component;\n \n+   ----------------------------\n+   -- Has_Volatile_Component --\n+   ----------------------------\n+\n+   function Has_Volatile_Component (Typ : Entity_Id) return Boolean is\n+      Comp : Entity_Id;\n+\n+   begin\n+      if Has_Volatile_Components (Typ) then\n+         return True;\n+\n+      elsif Is_Array_Type (Typ) then\n+         return Is_Volatile (Component_Type (Typ));\n+\n+      elsif Is_Record_Type (Typ) then\n+         Comp := First_Component (Typ);\n+         while Present (Comp) loop\n+            if Is_Volatile_Object (Comp) then\n+               return True;\n+            end if;\n+\n+            Comp := Next_Component (Comp);\n+         end loop;\n+      end if;\n+\n+      return False;\n+   end Has_Volatile_Component;\n+\n    -------------------------\n    -- Implementation_Kind --\n    -------------------------\n@@ -10827,6 +10850,37 @@ package body Sem_Util is\n       end if;\n    end Is_SPARK_Object_Reference;\n \n+   ------------------------------\n+   -- Is_SPARK_Volatile_Object --\n+   ------------------------------\n+\n+   function Is_SPARK_Volatile_Object (N : Node_Id) return Boolean is\n+   begin\n+      if Nkind (N) = N_Defining_Identifier then\n+         return Is_Volatile (N) or else Is_Volatile (Etype (N));\n+\n+      elsif Is_Entity_Name (N) then\n+         return\n+           Is_SPARK_Volatile_Object (Entity (N))\n+             or else Is_Volatile (Etype (N));\n+\n+      elsif Nkind (N) = N_Expanded_Name then\n+         return Is_SPARK_Volatile_Object (Entity (N));\n+\n+      elsif Nkind (N) = N_Indexed_Component then\n+         return Is_SPARK_Volatile_Object (Prefix (N));\n+\n+      elsif Nkind (N) = N_Selected_Component then\n+         return\n+           Is_SPARK_Volatile_Object (Prefix (N))\n+             or else\n+           Is_SPARK_Volatile_Object (Selector_Name (N));\n+\n+      else\n+         return False;\n+      end if;\n+   end Is_SPARK_Volatile_Object;\n+\n    ------------------\n    -- Is_Statement --\n    ------------------"}, {"sha": "3c512df64fc745e415903a272b1807d75a36fbd9", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "patch": "@@ -886,6 +886,10 @@ package Sem_Util is\n    --  component is present. This function is used to check if \"=\" has to be\n    --  expanded into a bunch component comparisons.\n \n+   function Has_Volatile_Component (Typ : Entity_Id) return Boolean;\n+   --  Given an arbitrary type, determine whether it contains at least one\n+   --  volatile component.\n+\n    function Implementation_Kind (Subp : Entity_Id) return Name_Id;\n    --  Subp is a subprogram marked with pragma Implemented. Return the specific\n    --  implementation requirement which the pragma imposes. The return value is\n@@ -1015,6 +1019,11 @@ package Sem_Util is\n    --  First determine whether type T is an interface and then check whether\n    --  it is of protected, synchronized or task kind.\n \n+   function Is_Delegate (T : Entity_Id) return Boolean;\n+   --  Returns true if type T represents a delegate. A Delegate is the CIL\n+   --  object used to represent access-to-subprogram types. This is only\n+   --  relevant to CIL, will always return false for other targets.\n+\n    function Is_Dependent_Component_Of_Mutable_Object\n      (Object : Node_Id) return Boolean;\n    --  Returns True if Object is the name of a subcomponent that depends on\n@@ -1165,6 +1174,13 @@ package Sem_Util is\n    function Is_SPARK_Object_Reference (N : Node_Id) return Boolean;\n    --  Determines if the tree referenced by N represents an object in SPARK\n \n+   function Is_SPARK_Volatile_Object (N : Node_Id) return Boolean;\n+   --  Determine whether an arbitrary node denotes a volatile object reference\n+   --  according to the semantics of SPARK. To qualify as volatile, an object\n+   --  must be subject to aspect/pragma Volatile or Atomic or have a [sub]type\n+   --  subject to the same attributes. Note that volatile components do not\n+   --  render an object volatile.\n+\n    function Is_Statement (N : Node_Id) return Boolean;\n    pragma Inline (Is_Statement);\n    --  Check if the node N is a statement node. Note that this includes\n@@ -1215,11 +1231,6 @@ package Sem_Util is\n    --  Determine whether an operator is one of the intrinsics defined\n    --  in the DEC system extension.\n \n-   function Is_Delegate (T : Entity_Id) return Boolean;\n-   --  Returns true if type T represents a delegate. A Delegate is the CIL\n-   --  object used to represent access-to-subprogram types. This is only\n-   --  relevant to CIL, will always return false for other targets.\n-\n    function Is_Variable\n      (N                 : Node_Id;\n       Use_Original_Node : Boolean := True) return Boolean;"}, {"sha": "6321d467edc0b4903224ef20801ec0fcbd88edb1", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=f1bd0415ad180f4cfeccdb966dff4a9ff4203fa1", "patch": "@@ -724,7 +724,6 @@ package Snames is\n    Name_In_Out                         : constant Name_Id := N + $;\n    Name_Increases                      : constant Name_Id := N + $;\n    Name_Info                           : constant Name_Id := N + $;\n-   Name_Input_Only                     : constant Name_Id := N + $;\n    Name_Internal                       : constant Name_Id := N + $;\n    Name_Link_Name                      : constant Name_Id := N + $;\n    Name_Lowercase                      : constant Name_Id := N + $;\n@@ -761,7 +760,6 @@ package Snames is\n    Name_Non_Volatile                   : constant Name_Id := N + $;\n    Name_On                             : constant Name_Id := N + $;\n    Name_Optional                       : constant Name_Id := N + $;\n-   Name_Output_Only                    : constant Name_Id := N + $;\n    Name_Policy                         : constant Name_Id := N + $;\n    Name_Parameter_Types                : constant Name_Id := N + $;\n    Name_Part_Of                        : constant Name_Id := N + $;"}]}