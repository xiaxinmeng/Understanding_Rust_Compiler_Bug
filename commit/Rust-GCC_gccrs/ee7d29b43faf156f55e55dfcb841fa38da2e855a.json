{"sha": "ee7d29b43faf156f55e55dfcb841fa38da2e855a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU3ZDI5YjQzZmFmMTU2ZjU1ZTU1ZGZjYjg0MWZhMzhkYTJlODU1YQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-12-10T09:41:08Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-12-10T09:41:08Z"}, "message": "re PR ipa/68331 ([meta-bug] fipa-pta issues)\n\n2015-12-10  Richard Biener  <rguenther@suse.de>\n\n\tPR ipa/68331\n\t* tree-ssa-structalias.c (set_uids_in_ptset): Add fndecl\n\tparameter and make vars_contains_nonlocal properly have\n\tfunction-scope semantics in IPA mode.\n\t(find_what_var_points_to): Add fndecl parameter.\n\t(find_what_p_points_to): Likewise.\n\t(pt_solution_includes_global): Remove IPA PTA early out.\n\t(compute_points_to_sets): Adjust.\n\t(ipa_pta_execute): Likewise.  Clear final_solutions after\n\teach function.\n\n\t* gcc.dg/torture/ipa-pta-3.c: New testcase.\n\t* g++.dg/ipa/ipa-pta-1.C: Likewise.\n\nFrom-SVN: r231498", "tree": {"sha": "d9310279809b94e076740c9f2881ea95cf1aea97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9310279809b94e076740c9f2881ea95cf1aea97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee7d29b43faf156f55e55dfcb841fa38da2e855a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee7d29b43faf156f55e55dfcb841fa38da2e855a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee7d29b43faf156f55e55dfcb841fa38da2e855a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee7d29b43faf156f55e55dfcb841fa38da2e855a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e53ed9f4c5712c151aadd5fa8891f189d5b9615e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e53ed9f4c5712c151aadd5fa8891f189d5b9615e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e53ed9f4c5712c151aadd5fa8891f189d5b9615e"}], "stats": {"total": 142, "additions": 115, "deletions": 27}, "files": [{"sha": "eac591761082ae63d5532090761f08c65d507eae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7d29b43faf156f55e55dfcb841fa38da2e855a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7d29b43faf156f55e55dfcb841fa38da2e855a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee7d29b43faf156f55e55dfcb841fa38da2e855a", "patch": "@@ -1,3 +1,16 @@\n+2015-12-10  Richard Biener  <rguenther@suse.de>\n+\n+\tPR ipa/68331\n+\t* tree-ssa-structalias.c (set_uids_in_ptset): Add fndecl\n+\tparameter and make vars_contains_nonlocal properly have\n+\tfunction-scope semantics in IPA mode.\n+\t(find_what_var_points_to): Add fndecl parameter.\n+\t(find_what_p_points_to): Likewise.\n+\t(pt_solution_includes_global): Remove IPA PTA early out.\n+\t(compute_points_to_sets): Adjust.\n+\t(ipa_pta_execute): Likewise.  Clear final_solutions after\n+\teach function.\n+\n 2015-12-10  Tom de Vries  <tom@codesourcery.com>\n \n \tPR ada/65102"}, {"sha": "6141624b7b9006c761682a6d28a2dbd8a24db7ec", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7d29b43faf156f55e55dfcb841fa38da2e855a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7d29b43faf156f55e55dfcb841fa38da2e855a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ee7d29b43faf156f55e55dfcb841fa38da2e855a", "patch": "@@ -1,3 +1,9 @@\n+2015-12-10  Richard Biener  <rguenther@suse.de>\n+\n+\tPR ipa/68331\n+\t* gcc.dg/torture/ipa-pta-3.c: New testcase.\n+\t* g++.dg/ipa/ipa-pta-1.C: Likewise.\n+\n 2015-12-10  Richard Biener  <rguenther@suse.de>\n \n \tPR ipa/68721"}, {"sha": "a3d12f5f0c9182c34da76ee83ac083de5f1b29ac", "filename": "gcc/testsuite/g++.dg/ipa/ipa-pta-1.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7d29b43faf156f55e55dfcb841fa38da2e855a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-pta-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7d29b43faf156f55e55dfcb841fa38da2e855a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-pta-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-pta-1.C?ref=ee7d29b43faf156f55e55dfcb841fa38da2e855a", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fipa-pta\"  } */\n+\n+struct A {                                                                      \n+  A() {ptr=&b;}                                                                 \n+  A(const A &a) {ptr = &b;}                                                     \n+  void test() { if (ptr != &b) __builtin_abort ();}                             \n+  int b;                                                                        \n+  int *ptr;                                                                     \n+};                                                                              \n+\n+A test1(A a)\n+{\n+  a.test();\n+  return a;\n+}\n+A test2(A a)\n+{\n+  a.test();\n+  return a;\n+}\n+__attribute__ ((noinline))\n+static void\n+test_me (A (*t)(A))\n+{\n+  struct A a, b=t(a);\n+  b.test ();\n+}\n+int\n+main()\n+{\n+  test_me (test1);\n+  test_me (test2);\n+  return 0;\n+}"}, {"sha": "c3ef3682f2b286572ad819fc5ff29eb9ccf64294", "filename": "gcc/testsuite/gcc.dg/torture/ipa-pta-3.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7d29b43faf156f55e55dfcb841fa38da2e855a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fipa-pta-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7d29b43faf156f55e55dfcb841fa38da2e855a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fipa-pta-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fipa-pta-3.c?ref=ee7d29b43faf156f55e55dfcb841fa38da2e855a", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-fipa-pta\" } */\n+\n+extern void abort (void);\n+extern void *malloc (__SIZE_TYPE__);\n+\n+static int *p;\n+static void __attribute__((noinline,noclone)) foo ()\n+{\n+  p = (int *) malloc (24);\n+  *p = 2;\n+}\n+int main()\n+{\n+  foo ();\n+  if (*p != 2)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "5d29e5cca669a0a33d6a5bb4b2bed278be413b5e", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 42, "deletions": 27, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7d29b43faf156f55e55dfcb841fa38da2e855a/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7d29b43faf156f55e55dfcb841fa38da2e855a/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=ee7d29b43faf156f55e55dfcb841fa38da2e855a", "patch": "@@ -159,9 +159,7 @@\n \n    The is_global_var bit which marks escape points is overly conservative\n    in IPA mode.  Split it to is_escape_point and is_global_var - only\n-   externally visible globals are escape points in IPA mode.  This is\n-   also needed to fix the pt_solution_includes_global predicate\n-   (and thus ptr_deref_may_alias_global_p).\n+   externally visible globals are escape points in IPA mode.\n \n    The way we introduce DECL_PT_UID to avoid fixing up all points-to\n    sets in the translation unit when we copy a DECL during inlining\n@@ -186,6 +184,7 @@\n    propagating it simply like the clobber / uses solutions.  The\n    solution can go alongside the non-IPA espaced solution and be\n    used to query which vars escape the unit through a function.\n+   This is also required to make the escaped-HEAP trick work in IPA mode.\n \n    We never put function decls in points-to sets so we do not\n    keep the set of called functions for indirect calls.\n@@ -6150,7 +6149,8 @@ shared_bitmap_add (bitmap pt_vars)\n /* Set bits in INTO corresponding to the variable uids in solution set FROM.  */\n \n static void\n-set_uids_in_ptset (bitmap into, bitmap from, struct pt_solution *pt)\n+set_uids_in_ptset (bitmap into, bitmap from, struct pt_solution *pt,\n+\t\t   tree fndecl)\n {\n   unsigned int i;\n   bitmap_iterator bi;\n@@ -6188,7 +6188,19 @@ set_uids_in_ptset (bitmap into, bitmap from, struct pt_solution *pt)\n \t  /* Add the decl to the points-to set.  Note that the points-to\n \t     set contains global variables.  */\n \t  bitmap_set_bit (into, DECL_PT_UID (vi->decl));\n-\t  if (vi->is_global_var)\n+\t  if (vi->is_global_var\n+\t      /* In IPA mode the escaped_heap trick doesn't work as\n+\t\t ESCAPED is escaped from the unit but\n+\t\t pt_solution_includes_global needs to answer true for\n+\t\t all variables not automatic within a function.\n+\t\t For the same reason is_global_var is not the\n+\t\t correct flag to track - local variables from other\n+\t\t functions also need to be considered global.\n+\t\t Conveniently all HEAP vars are not put in function\n+\t\t scope.  */\n+\t      || (in_ipa_mode\n+\t\t  && fndecl\n+\t\t  && ! auto_var_in_fn_p (vi->decl, fndecl)))\n \t    pt->vars_contains_nonlocal = true;\n \t}\n     }\n@@ -6198,7 +6210,7 @@ set_uids_in_ptset (bitmap into, bitmap from, struct pt_solution *pt)\n /* Compute the points-to solution *PT for the variable VI.  */\n \n static struct pt_solution\n-find_what_var_points_to (varinfo_t orig_vi)\n+find_what_var_points_to (tree fndecl, varinfo_t orig_vi)\n {\n   unsigned int i;\n   bitmap_iterator bi;\n@@ -6263,7 +6275,7 @@ find_what_var_points_to (varinfo_t orig_vi)\n   finished_solution = BITMAP_GGC_ALLOC ();\n   stats.points_to_sets_created++;\n \n-  set_uids_in_ptset (finished_solution, vi->solution, pt);\n+  set_uids_in_ptset (finished_solution, vi->solution, pt, fndecl);\n   result = shared_bitmap_lookup (finished_solution);\n   if (!result)\n     {\n@@ -6282,7 +6294,7 @@ find_what_var_points_to (varinfo_t orig_vi)\n /* Given a pointer variable P, fill in its points-to set.  */\n \n static void\n-find_what_p_points_to (tree p)\n+find_what_p_points_to (tree fndecl, tree p)\n {\n   struct ptr_info_def *pi;\n   tree lookup_p = p;\n@@ -6301,7 +6313,7 @@ find_what_p_points_to (tree p)\n     return;\n \n   pi = get_ptr_info (p);\n-  pi->pt = find_what_var_points_to (vi);\n+  pi->pt = find_what_var_points_to (fndecl, vi);\n }\n \n \n@@ -6467,12 +6479,6 @@ pt_solution_includes_global (struct pt_solution *pt)\n   if (pt->ipa_escaped)\n     return pt_solution_includes_global (&ipa_escaped_pt);\n \n-  /* ???  This predicate is not correct for the IPA-PTA solution\n-     as we do not properly distinguish between unit escape points\n-     and global variables.  */\n-  if (cfun->gimple_df->ipa_pta)\n-    return true;\n-\n   return false;\n }\n \n@@ -6969,7 +6975,8 @@ compute_points_to_sets (void)\n   solve_constraints ();\n \n   /* Compute the points-to set for ESCAPED used for call-clobber analysis.  */\n-  cfun->gimple_df->escaped = find_what_var_points_to (get_varinfo (escaped_id));\n+  cfun->gimple_df->escaped = find_what_var_points_to (cfun->decl,\n+\t\t\t\t\t\t      get_varinfo (escaped_id));\n \n   /* Make sure the ESCAPED solution (which is used as placeholder in\n      other solutions) does not reference itself.  This simplifies\n@@ -6982,7 +6989,7 @@ compute_points_to_sets (void)\n       tree ptr = ssa_name (i);\n       if (ptr\n \t  && POINTER_TYPE_P (TREE_TYPE (ptr)))\n-\tfind_what_p_points_to (ptr);\n+\tfind_what_p_points_to (cfun->decl, ptr);\n     }\n \n   /* Compute the call-used/clobbered sets.  */\n@@ -7004,7 +7011,7 @@ compute_points_to_sets (void)\n \t    memset (pt, 0, sizeof (struct pt_solution));\n \t  else if ((vi = lookup_call_use_vi (stmt)) != NULL)\n \t    {\n-\t      *pt = find_what_var_points_to (vi);\n+\t      *pt = find_what_var_points_to (cfun->decl, vi);\n \t      /* Escaped (and thus nonlocal) variables are always\n \t         implicitly used by calls.  */\n \t      /* ???  ESCAPED can be empty even though NONLOCAL\n@@ -7025,7 +7032,7 @@ compute_points_to_sets (void)\n \t    memset (pt, 0, sizeof (struct pt_solution));\n \t  else if ((vi = lookup_call_clobber_vi (stmt)) != NULL)\n \t    {\n-\t      *pt = find_what_var_points_to (vi);\n+\t      *pt = find_what_var_points_to (cfun->decl, vi);\n \t      /* Escaped (and thus nonlocal) variables are always\n \t         implicitly clobbered by calls.  */\n \t      /* ???  ESCAPED can be empty even though NONLOCAL\n@@ -7565,7 +7572,7 @@ ipa_pta_execute (void)\n      ???  Note that the computed escape set is not correct\n      for the whole unit as we fail to consider graph edges to\n      externally visible functions.  */\n-  ipa_escaped_pt = find_what_var_points_to (get_varinfo (escaped_id));\n+  ipa_escaped_pt = find_what_var_points_to (NULL, get_varinfo (escaped_id));\n \n   /* Make sure the ESCAPED solution (which is used as placeholder in\n      other solutions) does not reference itself.  This simplifies\n@@ -7591,7 +7598,7 @@ ipa_pta_execute (void)\n \t{\n \t  if (ptr\n \t      && POINTER_TYPE_P (TREE_TYPE (ptr)))\n-\t    find_what_p_points_to (ptr);\n+\t    find_what_p_points_to (node->decl, ptr);\n \t}\n \n       /* Compute the call-use and call-clobber sets for indirect calls\n@@ -7625,10 +7632,10 @@ ipa_pta_execute (void)\n \t\t{\n \t\t  *gimple_call_clobber_set (stmt)\n \t\t     = find_what_var_points_to\n-\t\t         (first_vi_for_offset (fi, fi_clobbers));\n+\t\t         (node->decl, first_vi_for_offset (fi, fi_clobbers));\n \t\t  *gimple_call_use_set (stmt)\n \t\t     = find_what_var_points_to\n-\t\t         (first_vi_for_offset (fi, fi_uses));\n+\t\t         (node->decl, first_vi_for_offset (fi, fi_uses));\n \t\t}\n \t      /* Handle direct calls to external functions.  */\n \t      else if (decl)\n@@ -7638,7 +7645,7 @@ ipa_pta_execute (void)\n \t\t    memset (pt, 0, sizeof (struct pt_solution));\n \t\t  else if ((vi = lookup_call_use_vi (stmt)) != NULL)\n \t\t    {\n-\t\t      *pt = find_what_var_points_to (vi);\n+\t\t      *pt = find_what_var_points_to (node->decl, vi);\n \t\t      /* Escaped (and thus nonlocal) variables are always\n \t\t\t implicitly used by calls.  */\n \t\t      /* ???  ESCAPED can be empty even though NONLOCAL\n@@ -7659,7 +7666,7 @@ ipa_pta_execute (void)\n \t\t    memset (pt, 0, sizeof (struct pt_solution));\n \t\t  else if ((vi = lookup_call_clobber_vi (stmt)) != NULL)\n \t\t    {\n-\t\t      *pt = find_what_var_points_to (vi);\n+\t\t      *pt = find_what_var_points_to (node->decl, vi);\n \t\t      /* Escaped (and thus nonlocal) variables are always\n \t\t\t implicitly clobbered by calls.  */\n \t\t      /* ???  ESCAPED can be empty even though NONLOCAL\n@@ -7719,13 +7726,15 @@ ipa_pta_execute (void)\n \t\t\t  if (!uses->anything)\n \t\t\t    {\n \t\t\t      sol = find_what_var_points_to\n-\t\t\t\t      (first_vi_for_offset (vi, fi_uses));\n+\t\t\t\t      (node->decl,\n+\t\t\t\t       first_vi_for_offset (vi, fi_uses));\n \t\t\t      pt_solution_ior_into (uses, &sol);\n \t\t\t    }\n \t\t\t  if (!clobbers->anything)\n \t\t\t    {\n \t\t\t      sol = find_what_var_points_to\n-\t\t\t\t      (first_vi_for_offset (vi, fi_clobbers));\n+\t\t\t\t      (node->decl,\n+\t\t\t\t       first_vi_for_offset (vi, fi_clobbers));\n \t\t\t      pt_solution_ior_into (clobbers, &sol);\n \t\t\t    }\n \t\t\t}\n@@ -7735,6 +7744,12 @@ ipa_pta_execute (void)\n \t}\n \n       fn->gimple_df->ipa_pta = true;\n+\n+      /* We have to re-set the final-solution cache after each function\n+         because what is a \"global\" is dependent on function context.  */\n+      final_solutions->empty ();\n+      obstack_free (&final_solutions_obstack, NULL);\n+      gcc_obstack_init (&final_solutions_obstack);\n     }\n \n   delete_points_to_sets ();"}]}