{"sha": "b9e75696307f710a22c726e72b00e7a7161ad89f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjllNzU2OTYzMDdmNzEwYTIyYzcyNmU3MmIwMGU3YTcxNjFhZDg5Zg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2006-06-30T01:15:56Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2006-06-30T01:15:56Z"}, "message": "re PR c++/26905 (default-visibility class symbol improperly resolved as hidden-visibility)\n\n        PR c++/26905\n        PR c++/26612\n        PR c++/27000\n        PR c++/26984\n        PR c++/19134\n        * tree.c (build_decl_stat): Don't hande #pragma visibility here.\n        * c-common.c (c_determine_visibility): Handle it here.\n        * c-decl.c (finish_decl): Call c_determine_visibility for\n        functions, too.\n        * flags.h (enum symbol_visibility): Sort from most to least visibility.\n        * tree.h: Likewise.\n        * varasm.c (default_assemble_visibility): Likewise.\n        * c-common.c (handle_visibility_attribute): Complain about trying\n        to give visibility to an already defined class, or trying to change\n        declared visibility. Always attach the attribute.\n        * cp/decl2.c (determine_visibility): Overhaul.\n        (determine_visibility_from_class): Likewise.\n        (min_vis_r, type_visibility, constrain_visibility): New fns.\n        (constrain_visibility_for_template): Likewise.\n        (constrain_class_visibility): Likewise.\n        * cp/decl.c (cp_finish_decl): Call determine_visibility for function\n        decls, too.\n        * cp/name-lookup.c (pushtag): Call determine_visibility.\n        * cp/decl.c (duplicate_decls): Don't copy visibility from template to\n        specialization.\n        * cp/pt.c (check_explicit_specialization): Likewise.\n        (lookup_template_class, tsubst_decl): Call determine_visibility.\n        * cp/class.c (finish_struct_1): Call constrain_class_visibility.\n\n        PR c++/26905\n        PR c++/21675\n        PR c++/17470\n        * cp/parser.c (cp_parser_explicit_instantiation): Pass the attributes\n        to grokdeclarator.\n        (cp_parser_type_specifier): Allow 'enum __attribute ((...)) E'.\n        (cp_parser_enum_specifier): Likewise.\n        (cp_parser_elaborated_type_specifier): Apply attributes if this\n        declares only the class.\n        (cp_parser_class_specifier): Apply leading attributes immediately.\n        * cp/semantics.c (begin_class_definition): Add attributes parameter,\n        apply them to the type.\n        * attribs.c (decl_attributes): Ignore type-in-place attributes\n        once the type has been defined.\n\n        PR c++/21581\n        PR c++/25915\n        * cp/tree.c (decl_anon_ns_mem_p): New function.\n        * cp/cp-tree.h: Declare it.\n        * cp/decl2.c (determine_visibility): Make anonymous namespace\n        members static.\n        (min_vis_r, constrain_visibility): Likewise.\n        * cp/rtti.c (create_pseudo_type_info): Set TREE_PUBLIC on\n        pseudo-types.\n        * cp/decl.c (cxx_init_decl_processing): Set TREE_PUBLIC on\n        global_namespace.\n        * cp/name-lookup.c (push_namespace_with_attribs): Don't set TREE_PUBLIC\n        on anonymous namespaces.\n\nFrom-SVN: r115086", "tree": {"sha": "93c1ec7ec5a70cb4b7384fa239594ed2f1288585", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93c1ec7ec5a70cb4b7384fa239594ed2f1288585"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9e75696307f710a22c726e72b00e7a7161ad89f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9e75696307f710a22c726e72b00e7a7161ad89f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9e75696307f710a22c726e72b00e7a7161ad89f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9e75696307f710a22c726e72b00e7a7161ad89f/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dc2843f38c04c81e9f20a6e9e6ae9637ace6e08c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc2843f38c04c81e9f20a6e9e6ae9637ace6e08c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc2843f38c04c81e9f20a6e9e6ae9637ace6e08c"}], "stats": {"total": 1094, "additions": 887, "deletions": 207}, "files": [{"sha": "e5cc18a211868b0fe7f5c61b4a7abc4beac3e581", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -1,3 +1,27 @@\n+2006-06-29  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/26905\n+\tPR c++/26612\n+\tPR c++/27000\n+\tPR c++/26984\n+\tPR c++/19134\n+\t* tree.c (build_decl_stat): Don't hande #pragma visibility here.\n+\t* c-common.c (c_determine_visibility): Handle it here.\n+\t* c-decl.c (finish_decl): Call c_determine_visibility for \n+\tfunctions, too.\n+\t* flags.h (enum symbol_visibility): Sort from most to least visibility.\n+\t* tree.h: Likewise.\n+\t* varasm.c (default_assemble_visibility): Likewise.\n+\t* c-common.c (handle_visibility_attribute): Complain about trying\n+\tto give visibility to an already defined class, or trying to change\n+\tdeclared visibility. Always attach the attribute.\n+\n+\tPR c++/26905\n+\tPR c++/21675\n+\tPR c++/17470\n+\t* attribs.c (decl_attributes): Ignore type-in-place attributes\n+\tonce the type has been defined.\n+\n 2006-06-29  Roger Sayle  <roger@eyesopen.com>\n \n \tPR middle-end/27428"}, {"sha": "7377c57691dfe0b4d91b17965f7201587debe184", "filename": "gcc/attribs.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -250,6 +250,14 @@ decl_attributes (tree *node, tree attributes, int flags)\n \t    }\n \t}\n \n+      if (TYPE_P (*anode)\n+\t  && (flags & (int) ATTR_FLAG_TYPE_IN_PLACE)\n+\t  && TYPE_SIZE (*anode) != NULL_TREE)\n+\t{\n+\t  warning (OPT_Wattributes, \"type attributes ignored after type is already defined\");\n+\t  continue;\n+\t}\n+\n       if (spec->handler != NULL)\n \treturned_attrs = chainon ((*spec->handler) (anode, name, args,\n \t\t\t\t\t\t    flags, &no_add_attrs),"}, {"sha": "ac7dd7ddee3de4c4257153e7e88f1475ff52facc", "filename": "gcc/c-common.c", "status": "modified", "additions": 44, "deletions": 20, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -4876,21 +4876,28 @@ handle_weakref_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n static tree\n handle_visibility_attribute (tree *node, tree name, tree args,\n \t\t\t     int ARG_UNUSED (flags),\n-\t\t\t     bool *no_add_attrs)\n+\t\t\t     bool *ARG_UNUSED (no_add_attrs))\n {\n   tree decl = *node;\n   tree id = TREE_VALUE (args);\n-\n-  *no_add_attrs = true;\n+  enum symbol_visibility vis;\n \n   if (TYPE_P (*node))\n     {\n-      if (TREE_CODE (*node) != RECORD_TYPE && TREE_CODE (*node) != UNION_TYPE)\n-       {\n-\t warning (OPT_Wattributes, \"%qE attribute ignored on non-class types\",\n-\t\t  name);\n-\t return NULL_TREE;\n-       }\n+      if (TREE_CODE (*node) == ENUMERAL_TYPE)\n+\t/* OK */;\n+      else if (TREE_CODE (*node) != RECORD_TYPE && TREE_CODE (*node) != UNION_TYPE)\n+\t{\n+\t  warning (OPT_Wattributes, \"%qE attribute ignored on non-class types\",\n+\t\t   name);\n+\t  return NULL_TREE;\n+\t}\n+      else if (TYPE_FIELDS (*node))\n+\t{\n+\t  error (\"%qE attribute ignored because %qT is already defined\",\n+\t\t name, *node);\n+\t  return NULL_TREE;\n+\t}\n     }\n   else if (decl_function_context (decl) != 0 || !TREE_PUBLIC (decl))\n     {\n@@ -4919,23 +4926,33 @@ handle_visibility_attribute (tree *node, tree name, tree args,\n     }\n \n   if (strcmp (TREE_STRING_POINTER (id), \"default\") == 0)\n-    DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;\n+    vis = VISIBILITY_DEFAULT;\n   else if (strcmp (TREE_STRING_POINTER (id), \"internal\") == 0)\n-    DECL_VISIBILITY (decl) = VISIBILITY_INTERNAL;\n+    vis = VISIBILITY_INTERNAL;\n   else if (strcmp (TREE_STRING_POINTER (id), \"hidden\") == 0)\n-    DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;\n+    vis = VISIBILITY_HIDDEN;\n   else if (strcmp (TREE_STRING_POINTER (id), \"protected\") == 0)\n-    DECL_VISIBILITY (decl) = VISIBILITY_PROTECTED;\n+    vis = VISIBILITY_PROTECTED;\n   else\n-    error (\"visibility argument must be one of \\\"default\\\", \\\"hidden\\\", \\\"protected\\\" or \\\"internal\\\"\");\n+    {\n+      error (\"visibility argument must be one of \\\"default\\\", \\\"hidden\\\", \\\"protected\\\" or \\\"internal\\\"\");\n+      vis = VISIBILITY_DEFAULT;\n+    }\n+\n+  if (DECL_VISIBILITY_SPECIFIED (decl)\n+      && vis != DECL_VISIBILITY (decl)\n+      && lookup_attribute (\"visibility\", (TYPE_P (*node)\n+\t\t\t\t\t  ? TYPE_ATTRIBUTES (*node)\n+\t\t\t\t\t  : DECL_ATTRIBUTES (decl))))\n+    error (\"%qD redeclared with different visibility\", decl);\n+\n+  DECL_VISIBILITY (decl) = vis;\n   DECL_VISIBILITY_SPECIFIED (decl) = 1;\n \n-  /* For decls only, go ahead and attach the attribute to the node as well.\n-     This is needed so we can determine whether we have VISIBILITY_DEFAULT\n-     because the visibility was not specified, or because it was explicitly\n-     overridden from the class visibility.  */\n-  if (DECL_P (*node))\n-    *no_add_attrs = false;\n+  /* Go ahead and attach the attribute to the node as well.  This is needed\n+     so we can determine whether we have VISIBILITY_DEFAULT because the\n+     visibility was not specified, or because it was explicitly overridden\n+     from the containing scope.  */\n \n   return NULL_TREE;\n }\n@@ -4972,6 +4989,13 @@ c_determine_visibility (tree decl)\n       return true;\n     }\n \n+  /* Set default visibility to whatever the user supplied with\n+     visibility_specified depending on #pragma GCC visibility.  */\n+  if (!DECL_VISIBILITY_SPECIFIED (decl))\n+    {\n+      DECL_VISIBILITY (decl) = default_visibility;\n+      DECL_VISIBILITY_SPECIFIED (decl) = visibility_options.inpragma;\n+    }\n   return false;\n }\n "}, {"sha": "250be0e055dbba224409effb44d2fad3fc0926ff", "filename": "gcc/c-decl.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -3459,18 +3459,16 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n   /* If #pragma weak was used, mark the decl weak now.  */\n   maybe_apply_pragma_weak (decl);\n \n-  /* If this is a variable definition, determine its ELF visibility.  */\n-  if (TREE_CODE (decl) == VAR_DECL\n-      && TREE_STATIC (decl)\n-      && !DECL_EXTERNAL (decl))\n-    c_determine_visibility (decl);\n-\n   /* Output the assembler code and/or RTL code for variables and functions,\n      unless the type is an undefined structure or union.\n      If not, it will get done when the type is completed.  */\n \n   if (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == FUNCTION_DECL)\n     {\n+      /* Determine the ELF visibility.  */\n+      if (TREE_PUBLIC (decl))\n+\tc_determine_visibility (decl);\n+\n       /* This is a no-op in c-lang.c or something real in objc-act.c.  */\n       if (c_dialect_objc ())\n \tobjc_check_decl (decl);"}, {"sha": "c9eb4b9d7d453eb72b9e90729850a15f0eac9eb3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -1,3 +1,51 @@\n+2006-06-29  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/26905\n+\tPR c++/26612\n+\tPR c++/27000\n+\tPR c++/26984\n+\tPR c++/19134\n+\t* decl2.c (determine_visibility): Overhaul.\n+\t(determine_visibility_from_class): Likewise.\n+\t(min_vis_r, type_visibility, constrain_visibility): New fns.\n+\t(constrain_visibility_for_template): Likewise.\n+\t(constrain_class_visibility): Likewise.\n+\t* decl.c (cp_finish_decl): Call determine_visibility for function\n+\tdecls, too.\n+\t* name-lookup.c (pushtag): Call determine_visibility.\n+\t* decl.c (duplicate_decls): Don't copy visibility from template to\n+\tspecialization.\n+\t* pt.c (check_explicit_specialization): Likewise.\n+\t(lookup_template_class, tsubst_decl): Call determine_visibility.\n+\t* class.c (finish_struct_1): Call constrain_class_visibility.\n+\n+\tPR c++/26905\n+\tPR c++/21675\n+\tPR c++/17470\n+\t* parser.c (cp_parser_explicit_instantiation): Pass the attributes\n+\tto grokdeclarator.\n+\t(cp_parser_type_specifier): Allow 'enum __attribute ((...)) E'.\n+\t(cp_parser_enum_specifier): Likewise.\n+\t(cp_parser_elaborated_type_specifier): Apply attributes if this\n+\tdeclares only the class.\n+\t(cp_parser_class_specifier): Apply leading attributes immediately.\n+\t* semantics.c (begin_class_definition): Add attributes parameter,\n+\tapply them to the type.\n+\n+\tPR c++/21581\n+\tPR c++/25915\n+\t* tree.c (decl_anon_ns_mem_p): New function.\n+\t* cp-tree.h: Declare it.\n+\t* decl2.c (determine_visibility): Make anonymous namespace\n+\tmembers static.\n+\t(min_vis_r, constrain_visibility): Likewise.\n+\t* rtti.c (create_pseudo_type_info): Set TREE_PUBLIC on\n+\tpseudo-types.\n+\t* decl.c (cxx_init_decl_processing): Set TREE_PUBLIC on\n+\tglobal_namespace.\n+\t* name-lookup.c (push_namespace_with_attribs): Don't set TREE_PUBLIC\n+\ton anonymous namespaces.\n+\n 2006-06-28  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/27424"}, {"sha": "9761c5c41a7d55db1ab8607747686e2d7f570ce1", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -5084,6 +5084,9 @@ finish_struct_1 (tree t)\n       DECL_SORTED_FIELDS (TYPE_MAIN_DECL (t)) = field_vec;\n     }\n \n+  /* Complain if one of the field types requires lower visibility.  */\n+  constrain_class_visibility (t);\n+\n   /* Make the rtl for any new vtables we have created, and unmark\n      the base types we marked.  */\n   finish_vtbls (t);"}, {"sha": "20e704cc2f35595de9b694ba6a49f346fc262853", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -3965,6 +3965,8 @@ extern tree coerce_new_type\t\t\t(tree);\n extern tree coerce_delete_type\t\t\t(tree);\n extern void comdat_linkage\t\t\t(tree);\n extern void determine_visibility\t\t(tree);\n+extern void constrain_class_visibility\t\t(tree);\n+extern void update_member_visibility\t\t(tree);\n extern void import_export_decl\t\t\t(tree);\n extern tree build_cleanup\t\t\t(tree);\n extern tree build_offset_ref_call_from_tree\t(tree, tree);\n@@ -4271,7 +4273,7 @@ extern tree finish_fname\t\t\t(tree);\n extern void finish_translation_unit\t\t(void);\n extern tree finish_template_type_parm\t\t(tree, tree);\n extern tree finish_template_template_parm       (tree, tree);\n-extern tree begin_class_definition\t\t(tree);\n+extern tree begin_class_definition\t\t(tree, tree);\n extern void finish_template_decl\t\t(tree);\n extern tree finish_template_type\t\t(tree, tree, int);\n extern tree finish_base_specifier\t\t(tree, tree, bool);\n@@ -4353,6 +4355,7 @@ extern tree array_type_nelts_top\t\t(tree);\n extern tree break_out_target_exprs\t\t(tree);\n extern tree get_type_decl\t\t\t(tree);\n extern tree decl_namespace_context\t\t(tree);\n+extern bool decl_anon_ns_mem_p\t\t\t(tree);\n extern tree lvalue_type\t\t\t\t(tree);\n extern tree error_type\t\t\t\t(tree);\n extern int varargs_function_p\t\t\t(tree);"}, {"sha": "49d192024729a10b23f66d8895a6237c9bf136e3", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -1857,6 +1857,11 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \n \t  SET_DECL_TEMPLATE_SPECIALIZATION (olddecl);\n \n+\t  /* Don't propagate visibility from the template to the\n+\t     specialization here.  We'll do that in determine_visibility if\n+\t     appropriate.  */\n+\t  DECL_VISIBILITY_SPECIFIED (olddecl) = 0;\n+\n \t  /* [temp.expl.spec/14] We don't inline explicit specialization\n \t     just because the primary template says so.  */\n \t}\n@@ -3119,6 +3124,7 @@ cxx_init_decl_processing (void)\n   gcc_assert (global_namespace == NULL_TREE);\n   global_namespace = build_lang_decl (NAMESPACE_DECL, global_scope_name,\n \t\t\t\t      void_type_node);\n+  TREE_PUBLIC (global_namespace) = 1;\n   begin_scope (sk_namespace, global_namespace);\n \n   current_lang_name = NULL_TREE;\n@@ -5240,6 +5246,9 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n       else\n \tabstract_virtuals_error (decl, type);\n \n+      /* This needs to happen after the linkage is set. */\n+      determine_visibility (decl);\n+\n       if (TREE_CODE (decl) == FUNCTION_DECL\n \t  || TREE_TYPE (decl) == error_mark_node)\n \t/* No initialization required.  */\n@@ -5263,10 +5272,6 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t\tinitialize_local_var (decl, init);\n \t    }\n \n-\t  /* The variable is being defined, so determine its visibility.\n-\t     This needs to happen after the linkage is set. */\n-\t  determine_visibility (decl);\n-\n \t  /* If a variable is defined, and then a subsequent\n \t     definition with external linkage is encountered, we will\n \t     get here twice for the same variable.  We want to avoid"}, {"sha": "0a12a3806585722459f20efbb35ab3fedd048ada", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 257, "deletions": 63, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -1533,6 +1533,110 @@ maybe_emit_vtables (tree ctype)\n   return true;\n }\n \n+/* A special return value from type_visibility meaning internal\n+   linkage.  */\n+\n+enum { VISIBILITY_STATIC = VISIBILITY_INTERNAL+1 };\n+\n+/* walk_tree helper function for type_visibility.  */\n+\n+static tree\n+min_vis_r (tree *tp, int *walk_subtrees, void *data)\n+{\n+  int *vis_p = (int *)data;\n+  if (! TYPE_P (*tp))\n+    {\n+      *walk_subtrees = 0;\n+    }\n+  else if (CLASS_TYPE_P (*tp))\n+    {\n+      if (!TREE_PUBLIC (TYPE_MAIN_DECL (*tp)))\n+\t{\n+\t  *vis_p = VISIBILITY_STATIC;\n+\t  return *tp;\n+\t}\n+      else if (CLASSTYPE_VISIBILITY (*tp) > *vis_p)\n+\t*vis_p = CLASSTYPE_VISIBILITY (*tp);\n+    }\n+  return NULL;\n+}\n+\n+/* Returns the visibility of TYPE, which is the minimum visibility of its\n+   component types.  */\n+\n+static int\n+type_visibility (tree type)\n+{\n+  int vis = VISIBILITY_DEFAULT;\n+  walk_tree_without_duplicates (&type, min_vis_r, &vis);\n+  return vis;\n+}\n+\n+/* Limit the visibility of DECL to VISIBILITY.  SPECIFIED is true if the\n+   constraint comes from an attribute or pragma; REASON is the source of\n+   the constraint.  */\n+\n+static bool\n+constrain_visibility (tree decl, int visibility, bool specified,\n+\t\t      const char *reason)\n+{\n+  if (visibility == VISIBILITY_STATIC)\n+    {\n+      TREE_PUBLIC (decl) = 0;\n+      DECL_INTERFACE_KNOWN (decl) = 1;\n+      if (DECL_LANG_SPECIFIC (decl))\n+\tDECL_NOT_REALLY_EXTERN (decl) = 1;\n+    }\n+  else if (visibility > DECL_VISIBILITY (decl))\n+    {\n+      if (lookup_attribute (\"visibility\", DECL_ATTRIBUTES (decl)))\n+\twarning (OPT_Wattributes, \"%q+D: visibility attribute requests \"\n+\t\t \"greater visibility than its %s allows\", decl, reason);\n+      DECL_VISIBILITY (decl) = visibility;\n+      if (!DECL_VISIBILITY_SPECIFIED (decl))\n+\tDECL_VISIBILITY_SPECIFIED (decl) = specified;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Constrain the visibility of DECL based on the visbility of its template\n+   arguments.  */\n+\n+static void\n+constrain_visibility_for_template (tree decl, tree targs)\n+{\n+  /* If this is a template instantiation, check the innermost\n+     template args for visibility constraints.  The outer template\n+     args are covered by the class check.  */\n+  tree args = INNERMOST_TEMPLATE_ARGS (targs);\n+  int i;\n+  for (i = TREE_VEC_LENGTH (args); i > 0; --i)\n+    {\n+      int vis = 0;\n+\n+      tree arg = TREE_VEC_ELT (args, i-1);\n+      if (TYPE_P (arg))\n+\tvis = type_visibility (arg);\n+      else if (TREE_TYPE (arg) && POINTER_TYPE_P (TREE_TYPE (arg)))\n+\t{\n+\t  STRIP_NOPS (arg);\n+\t  if (TREE_CODE (arg) == ADDR_EXPR)\n+\t    arg = TREE_OPERAND (arg, 0);\n+\t  if (TREE_CODE (arg) == VAR_DECL\n+\t      || TREE_CODE (arg) == FUNCTION_DECL)\n+\t    {\n+\t      if (! TREE_PUBLIC (arg))\n+\t\tvis = VISIBILITY_STATIC;\n+\t      else\n+\t\tvis = DECL_VISIBILITY (arg);\n+\t    }\n+\t}\n+      if (vis)\n+\tconstrain_visibility (decl, vis, false, \"template parameter\");\n+    }\n+}\n+\n /* Like c_determine_visibility, but with additional C++-specific\n    behavior.\n \n@@ -1544,12 +1648,18 @@ maybe_emit_vtables (tree ctype)\n \n    Note that because namespaces have multiple independent definitions,\n    namespace visibility is handled elsewhere using the #pragma visibility\n-   machinery rather than by decorating the namespace declaration.  */\n+   machinery rather than by decorating the namespace declaration.\n+\n+   The goal is for constraints from the type to give a diagnostic, and\n+   other constraints to be applied silently.  */\n \n void\n determine_visibility (tree decl)\n {\n-  tree class_type;\n+  tree class_type = NULL_TREE;\n+  bool use_template;\n+\n+  /* Remember that all decls get VISIBILITY_DEFAULT when built.  */\n \n   /* Only relevant for names with external linkage.  */\n   if (!TREE_PUBLIC (decl))\n@@ -1560,9 +1670,30 @@ determine_visibility (tree decl)\n      maybe_clone_body.  */\n   gcc_assert (!DECL_CLONED_FUNCTION_P (decl));\n \n-  /* Give the common code a chance to make a determination.  */\n-  if (c_determine_visibility (decl))\n-    return;\n+  if (TREE_CODE (decl) == TYPE_DECL)\n+    {\n+      if (CLASS_TYPE_P (TREE_TYPE (decl)))\n+\tuse_template = CLASSTYPE_USE_TEMPLATE (TREE_TYPE (decl));\n+      else if (TYPE_TEMPLATE_INFO (TREE_TYPE (decl)))\n+\tuse_template = 1;\n+      else\n+\tuse_template = 0;\n+    }\n+  else if (DECL_LANG_SPECIFIC (decl))\n+    use_template = DECL_USE_TEMPLATE (decl);\n+  else\n+    use_template = 0;\n+\n+  /* Anything that is exported must have default visibility.  */\n+  if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+      && lookup_attribute (\"dllexport\",\n+\t\t\t   TREE_CODE (decl) == TYPE_DECL\n+\t\t\t   ? TYPE_ATTRIBUTES (TREE_TYPE (decl))\n+\t\t\t   : DECL_ATTRIBUTES (decl)))\n+    {\n+      DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;\n+      DECL_VISIBILITY_SPECIFIED (decl) = 1;\n+    }\n \n   /* If DECL is a member of a class, visibility specifiers on the\n      class can influence the visibility of the DECL.  */\n@@ -1574,84 +1705,147 @@ determine_visibility (tree decl)\n     class_type = TREE_TYPE (DECL_NAME (decl));\n   else\n     {\n+      /* Not a class member.  */\n+\n       /* Virtual tables have DECL_CONTEXT set to their associated class,\n \t so they are automatically handled above.  */\n       gcc_assert (TREE_CODE (decl) != VAR_DECL\n \t\t  || !DECL_VTABLE_OR_VTT_P (decl));\n \n       if (DECL_FUNCTION_SCOPE_P (decl))\n \t{\n+\t  /* Local statics and classes get the visibility of their\n+\t     containing function.  */\n \t  tree fn = DECL_CONTEXT (decl);\n \t  DECL_VISIBILITY (decl) = DECL_VISIBILITY (fn);\n \t  DECL_VISIBILITY_SPECIFIED (decl) = DECL_VISIBILITY_SPECIFIED (fn);\n-\t}\n \n-      /* Entities not associated with any class just get the\n-\t visibility specified by their attributes.  */\n-      return;\n+\t  /* Local classes in templates have CLASSTYPE_USE_TEMPLATE set,\n+\t     but have no TEMPLATE_INFO, so don't try to check it.  */\n+\t  use_template = 0;\n+\t}\n+      else if (TREE_CODE (decl) == VAR_DECL && DECL_TINFO_P (decl))\n+\t{\n+\t  /* tinfo visibility is based on the type it's for.  */\n+\t  constrain_visibility\n+\t    (decl, type_visibility (TREE_TYPE (DECL_NAME (decl))),\n+\t     false, \"type\");\n+\t}\n+      else if (use_template)\n+\t/* Template instantiations and specializations get visibility based\n+\t   on their template unless they override it with an attribute.  */;\n+      else if (! DECL_VISIBILITY_SPECIFIED (decl))\n+\t{\n+\t  /* Set default visibility to whatever the user supplied with\n+\t     #pragma GCC visibility or a namespace visibility attribute.  */\n+\t  DECL_VISIBILITY (decl) = default_visibility;\n+\t  DECL_VISIBILITY_SPECIFIED (decl) = visibility_options.inpragma;\n+\t}\n     }\n \n-  /* By default, static data members and function members receive\n-     the visibility of their containing class.  */\n-  if (class_type)\n+  if (use_template)\n     {\n-      determine_visibility_from_class (decl, class_type);\n-\n-      /* Give the target a chance to override the visibility associated\n-\t with DECL.  */\n-      if (TREE_CODE (decl) == VAR_DECL\n-\t  && (DECL_TINFO_P (decl)\n-\t      || (DECL_VTABLE_OR_VTT_P (decl)\n-\t\t  /* Construction virtual tables are not exported because\n-\t\t     they cannot be referred to from other object files;\n-\t\t     their name is not standardized by the ABI.  */\n-\t\t  && !DECL_CONSTRUCTION_VTABLE_P (decl)))\n-\t  && TREE_PUBLIC (decl)\n-\t  && !DECL_REALLY_EXTERN (decl)\n-\t  && DECL_VISIBILITY_SPECIFIED (decl)\n-\t  && (!class_type || !CLASSTYPE_VISIBILITY_SPECIFIED (class_type)))\n-\ttargetm.cxx.determine_class_data_visibility (decl);\n+      tree tinfo = (TREE_CODE (decl) == TYPE_DECL\n+\t\t    ? TYPE_TEMPLATE_INFO (TREE_TYPE (decl))\n+\t\t    : DECL_TEMPLATE_INFO (decl));\n+      tree args = TI_ARGS (tinfo);\n+      int depth = TMPL_ARGS_DEPTH (args);\n+\n+      /* If the template has explicit visibility and the specialization\n+\t doesn't, use the visibility from the template.  */\n+      if (!DECL_VISIBILITY_SPECIFIED (decl))\n+\t{\n+\t  tree pattern = DECL_TEMPLATE_RESULT (TI_TEMPLATE (tinfo));\n+\t  DECL_VISIBILITY (decl) = DECL_VISIBILITY (pattern);\n+\t}\n+\n+      /* FIXME should TMPL_ARGS_DEPTH really return 1 for null input? */\n+      if (args && depth > template_class_depth (class_type))\n+\t/* Don't let it have more visibility than its template type\n+\t   arguments.  */\n+\tconstrain_visibility_for_template (decl, args);\n     }\n+  \n+  if (class_type)\n+    determine_visibility_from_class (decl, class_type);\n+\n+  /* Don't let it have more visibility than its type.  */\n+  if (TREE_CODE (decl) != TYPE_DECL)\n+    if (constrain_visibility (decl, type_visibility (TREE_TYPE (decl)),\n+\t\t\t      false, \"type\"))\n+      warning (OPT_Wattributes, \"\\\n+%q+D declared with greater visibility than its type\",\n+\t       decl);\n+\n+  if (decl_anon_ns_mem_p (decl))\n+    /* Names in an anonymous namespace get internal linkage.\n+       This might change once we implement export.  */\n+    constrain_visibility (decl, VISIBILITY_STATIC,\n+\t\t\t  false, \"namespace\");\n }\n \n+/* By default, static data members and function members receive\n+   the visibility of their containing class.  */\n+\n static void\n determine_visibility_from_class (tree decl, tree class_type)\n {\n-  if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-      && lookup_attribute (\"dllexport\", TYPE_ATTRIBUTES (class_type)))\n-    {\n-      DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;\n-      DECL_VISIBILITY_SPECIFIED (decl) = 1;\n-    }\n-  else if (TREE_CODE (decl) == FUNCTION_DECL\n-\t   && DECL_DECLARED_INLINE_P (decl)\n-\t   && visibility_options.inlines_hidden)\n-    {\n-      /* Don't change it if it has been set explicitly by user.  */\n-      if (!DECL_VISIBILITY_SPECIFIED (decl))\n-\t{\n-\t  DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;\n-\t  DECL_VISIBILITY_SPECIFIED (decl) = 1;\n-\t}\n-    }\n-  else if (CLASSTYPE_VISIBILITY_SPECIFIED (class_type))\n-    {\n-      DECL_VISIBILITY (decl) = CLASSTYPE_VISIBILITY (class_type);\n-      DECL_VISIBILITY_SPECIFIED (decl) = 1;\n-    }\n-  else if (TYPE_CLASS_SCOPE_P (class_type))\n-    determine_visibility_from_class (decl, TYPE_CONTEXT (class_type));\n-  else if (TYPE_FUNCTION_SCOPE_P (class_type))\n-    {\n-      tree fn = TYPE_CONTEXT (class_type);\n-      DECL_VISIBILITY (decl) = DECL_VISIBILITY (fn);\n-      DECL_VISIBILITY_SPECIFIED (decl) = DECL_VISIBILITY_SPECIFIED (fn);\n-    }\n-  else if (!DECL_VISIBILITY_SPECIFIED (decl))\n-    {\n-      DECL_VISIBILITY (decl) = CLASSTYPE_VISIBILITY (class_type);\n-      DECL_VISIBILITY_SPECIFIED (decl) = 0;\n-    }\n+  if (visibility_options.inlines_hidden\n+      /* Don't do this for inline templates; specializations might not be\n+\t inline, and we don't want them to inherit the hidden\n+\t visibility.  We'll set it here for all inline instantiations.  */\n+      && !processing_template_decl\n+      && ! DECL_VISIBILITY_SPECIFIED (decl)\n+      && TREE_CODE (decl) == FUNCTION_DECL\n+      && DECL_DECLARED_INLINE_P (decl))\n+    DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;\n+\n+  /* The decl can't have more visibility than its class.  */\n+  constrain_visibility (decl, CLASSTYPE_VISIBILITY (class_type),\n+\t\t\tCLASSTYPE_VISIBILITY_SPECIFIED (class_type),\n+\t\t\t\"class\");\n+\n+  /* Give the target a chance to override the visibility associated\n+     with DECL.  */\n+  if (TREE_CODE (decl) == VAR_DECL\n+      && (DECL_TINFO_P (decl)\n+\t  || (DECL_VTABLE_OR_VTT_P (decl)\n+\t      /* Construction virtual tables are not exported because\n+\t\t they cannot be referred to from other object files;\n+\t\t their name is not standardized by the ABI.  */\n+\t      && !DECL_CONSTRUCTION_VTABLE_P (decl)))\n+      && TREE_PUBLIC (decl)\n+      && !DECL_REALLY_EXTERN (decl)\n+      && DECL_VISIBILITY_SPECIFIED (decl)\n+      && (!class_type || !CLASSTYPE_VISIBILITY_SPECIFIED (class_type)))\n+    targetm.cxx.determine_class_data_visibility (decl);\n+}\n+\n+/* Constrain the visibility of a class TYPE based on the visibility of its\n+   field types.  Warn if any fields require lesser visibility.  */\n+\n+void\n+constrain_class_visibility (tree type)\n+{\n+  tree decl = TYPE_MAIN_DECL (type);\n+  tree binfo = TYPE_BINFO (type);\n+  tree t;\n+  int i;\n+\n+  for (t = TYPE_FIELDS (type); t; t = TREE_CHAIN (t))\n+    if (TREE_CODE (t) == FIELD_DECL)\n+      if (constrain_visibility (decl, type_visibility (TREE_TYPE (t)),\n+\t\t\t\tfalse, \"field type\"))\n+\twarning (OPT_Wattributes, \"\\\n+%qT declared with greater visibility than the type of its field %qD\",\n+\t\t type, t);\n+\n+  for (i = 0; BINFO_BASE_ITERATE (binfo, i, t); ++i)\n+    if (constrain_visibility (decl, type_visibility (TREE_TYPE (t)),\n+\t\t\t      false, \"base type\"))\n+      warning (OPT_Wattributes, \"\\\n+%qT declared with greater visibility than its base %qT\",\n+\t       type, TREE_TYPE (t));\n }\n \n /* DECL is a FUNCTION_DECL or VAR_DECL.  If the object file linkage"}, {"sha": "43d74dc968e771b1c8b0cda88c8460c6c9fdae98", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -3039,7 +3039,12 @@ push_namespace_with_attribs (tree name, tree attributes)\n       /* Make a new namespace, binding the name to it.  */\n       d = build_lang_decl (NAMESPACE_DECL, name, void_type_node);\n       DECL_CONTEXT (d) = FROB_CONTEXT (current_namespace);\n-      TREE_PUBLIC (d) = 1;\n+      /* The name of this namespace is not visible to other translation\n+\t units if it is an anonymous namespace or member thereof.  */\n+      if (anon || decl_anon_ns_mem_p (current_namespace))\n+\tTREE_PUBLIC (d) = 0;\n+      else\n+\tTREE_PUBLIC (d) = 1;\n       pushdecl (d);\n       if (anon)\n \t{\n@@ -3086,15 +3091,6 @@ push_namespace_with_attribs (tree name, tree attributes)\n       push_visibility (TREE_STRING_POINTER (x));\n       goto found;\n     }\n-#if 0\n-  if (anon)\n-    {\n-      /* Anonymous namespaces default to hidden visibility.  This might\n-\t change once we implement export.  */\n-      current_binding_level->has_visibility = 1;\n-      push_visibility (\"hidden\");\n-    }\n-#endif\n  found:\n #endif\n \n@@ -4914,6 +4910,10 @@ pushtag (tree name, tree type, tag_scope scope)\n   gcc_assert (TREE_CODE (decl) == TYPE_DECL);\n   TYPE_STUB_DECL (type) = decl;\n \n+  /* Set type visibility now if this is a forward declaration.  */\n+  TREE_PUBLIC (decl) = 1;\n+  determine_visibility (decl);\n+\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, type);\n }\n \f"}, {"sha": "63a6b88ea416cc1d13b035e8c73897e55e6d028c", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 47, "deletions": 29, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -9412,7 +9412,7 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n       if (declarator != cp_error_declarator)\n \t{\n \t  decl = grokdeclarator (declarator, &decl_specifiers,\n-\t\t\t\t NORMAL, 0, NULL);\n+\t\t\t\t NORMAL, 0, &decl_specifiers.attributes);\n \t  /* Turn access control back on for names used during\n \t     template instantiation.  */\n \t  pop_deferring_access_checks ();\n@@ -9561,22 +9561,11 @@ cp_parser_type_specifier (cp_parser* parser,\n   switch (keyword)\n     {\n     case RID_ENUM:\n-      /* 'enum' [identifier] '{' introduces an enum-specifier;\n-\t 'enum' <anything else> introduces an elaborated-type-specifier.  */\n-      if (cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_OPEN_BRACE\n-\t  || (cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_NAME\n-\t      && cp_lexer_peek_nth_token (parser->lexer, 3)->type\n-\t\t == CPP_OPEN_BRACE))\n+      /* Look for the enum-specifier.  */\n+      type_spec = cp_parser_enum_specifier (parser);\n+      /* If that worked, we're done.  */\n+      if (type_spec)\n \t{\n-\t  if (parser->num_template_parameter_lists)\n-\t    {\n-\t      error (\"template declaration of %qs\", \"enum\");\n-\t      cp_parser_skip_to_end_of_block_or_statement (parser);\n-\t      type_spec = error_mark_node;\n-\t    }\n-\t  else\n-\t    type_spec = cp_parser_enum_specifier (parser);\n-\n \t  if (declares_class_or_enum)\n \t    *declares_class_or_enum = 2;\n \t  if (decl_specs)\n@@ -10078,6 +10067,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t\t\t\t\t /*type_p=*/true,\n \t\t\t\t\t is_declaration);\n   /* For everything but enumeration types, consider a template-id.  */\n+  /* For an enumeration type, consider only a plain identifier.  */\n   if (tag_type != enum_type)\n     {\n       bool template_p = false;\n@@ -10109,7 +10099,6 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \ttype = TREE_TYPE (decl);\n     }\n \n-  /* For an enumeration type, consider only a plain identifier.  */\n   if (!type)\n     {\n       identifier = cp_parser_identifier (parser);\n@@ -10237,11 +10226,6 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t  else\n \t    ts = ts_global;\n \n-\t  /* Warn about attributes. They are ignored.  */\n-\t  if (attributes)\n-\t    warning (OPT_Wattributes,\n-\t\t     \"type attributes are honored only at type definition\");\n-\n \t  template_p =\n \t    (parser->num_template_parameter_lists\n \t     && (cp_parser_next_token_starts_class_definition_p (parser)\n@@ -10254,6 +10238,21 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t  type = xref_tag (tag_type, identifier, ts, template_p);\n \t}\n     }\n+\n+  /* Allow attributes on forward declarations of classes.  */\n+  if (attributes)\n+    {\n+      if (tag_type != enum_type && CLASSTYPE_TEMPLATE_INSTANTIATION (type)\n+\t  && ! processing_explicit_instantiation)\n+\twarning (OPT_Wattributes,\n+\t\t \"attributes ignored on template instantiation\");\n+      else if (is_declaration && cp_parser_declares_only_class_p (parser))\n+\tcplus_decl_attributes (&type, attributes, (int) ATTR_FLAG_TYPE_IN_PLACE);\n+      else\n+\twarning (OPT_Wattributes,\n+\t\t \"attributes ignored on elaborated-type-specifier that is not a forward declaration\");\n+    }\n+\n   if (tag_type != enum_type)\n     cp_parser_check_class_key (tag_type, type);\n \n@@ -10270,27 +10269,43 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n      enum identifier [opt] { enumerator-list [opt] }\n \n    GNU Extensions:\n-     enum identifier [opt] { enumerator-list [opt] } attributes\n+     enum attributes[opt] identifier [opt] { enumerator-list [opt] }\n+       attributes[opt]\n \n-   Returns an ENUM_TYPE representing the enumeration.  */\n+   Returns an ENUM_TYPE representing the enumeration, or NULL_TREE\n+   if the token stream isn't an enum-specifier after all.  */\n \n static tree\n cp_parser_enum_specifier (cp_parser* parser)\n {\n   tree identifier;\n   tree type;\n+  tree attributes;\n+\n+  /* Parse tentatively so that we can back up if we don't find a\n+     enum-specifier.  */\n+  cp_parser_parse_tentatively (parser);\n \n   /* Caller guarantees that the current token is 'enum', an identifier\n      possibly follows, and the token after that is an opening brace.\n      If we don't have an identifier, fabricate an anonymous name for\n      the enumeration being defined.  */\n   cp_lexer_consume_token (parser->lexer);\n \n+  attributes = cp_parser_attributes_opt (parser);\n+\n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     identifier = cp_parser_identifier (parser);\n   else\n     identifier = make_anon_name ();\n \n+  /* Look for the `{' but don't consume it yet.  */\n+  if (!cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+    cp_parser_simulate_error (parser);\n+\n+  if (!cp_parser_parse_definitely (parser))\n+    return NULL_TREE;\n+\n   /* Issue an error message if type-definitions are forbidden here.  */\n   cp_parser_check_type_definition (parser);\n \n@@ -10302,6 +10317,12 @@ cp_parser_enum_specifier (cp_parser* parser)\n   /* Consume the opening brace.  */\n   cp_lexer_consume_token (parser->lexer);\n \n+  if (type == error_mark_node)\n+    {\n+      cp_parser_skip_to_end_of_block_or_statement (parser);\n+      return error_mark_node;\n+    }\n+\n   /* If the next token is not '}', then there are some enumerators.  */\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_BRACE))\n     cp_parser_enumerator_list (parser, type);\n@@ -12917,7 +12938,7 @@ cp_parser_class_specifier (cp_parser* parser)\n       scope = CP_DECL_CONTEXT (TYPE_MAIN_DECL (type));\n       old_scope = push_inner_scope (scope);\n     }\n-  type = begin_class_definition (type);\n+  type = begin_class_definition (type, attributes);\n \n   if (type == error_mark_node)\n     /* If the type is erroneous, skip the entire body of the class.  */\n@@ -12934,10 +12955,7 @@ cp_parser_class_specifier (cp_parser* parser)\n   has_trailing_semicolon = (token->type == CPP_SEMICOLON);\n   /* Look for trailing attributes to apply to this class.  */\n   if (cp_parser_allow_gnu_extensions_p (parser))\n-    {\n-      tree sub_attr = cp_parser_attributes_opt (parser);\n-      attributes = chainon (attributes, sub_attr);\n-    }\n+    attributes = cp_parser_attributes_opt (parser);\n   if (type != error_mark_node)\n     type = finish_struct (type, attributes);\n   if (nested_name_specifier_p)"}, {"sha": "873ef51990ec1883d069afe48bfb6eac1e194a11", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -2140,13 +2140,7 @@ check_explicit_specialization (tree declarator,\n \t     template it specializes.  */\n \t  TREE_PRIVATE (decl) = TREE_PRIVATE (gen_tmpl);\n \t  TREE_PROTECTED (decl) = TREE_PROTECTED (gen_tmpl);\n-\t  /* The specialization has the same visibility as the\n-\t     template it specializes.  */\n-\t  if (DECL_VISIBILITY_SPECIFIED (gen_tmpl))\n-\t    {\n-\t      DECL_VISIBILITY_SPECIFIED (decl) = 1;\n-\t      DECL_VISIBILITY (decl) = DECL_VISIBILITY (gen_tmpl);\n-\t    }\n+\n \t  /* If DECL is a friend declaration, declared using an\n \t     unqualified name, the namespace associated with DECL may\n \t     have been set incorrectly.  For example, in:\n@@ -3592,9 +3586,9 @@ convert_nontype_argument (tree type, tree expr)\n \n       if (!constant_address_p)\n \t{\n-\t    error (\"%qE is not a valid template argument for type %qT \"\n-\t\t  \"because it is not a constant pointer\", expr, type);\n-\t    return NULL_TREE;\n+\t  error (\"%qE is not a valid template argument for type %qT \"\n+\t\t \"because it is not a constant pointer\", expr, type);\n+\t  return NULL_TREE;\n \t}\n     }\n   /* [temp.arg.nontype]/5, bullet 3\n@@ -4782,6 +4776,10 @@ lookup_template_class (tree d1,\n \t   code that generates debugging information will crash.  */\n \tDECL_IGNORED_P (TYPE_STUB_DECL (t)) = 1;\n \n+      /* Possibly limit visibility based on template args.  */\n+      TREE_PUBLIC (type_decl) = 1;\n+      determine_visibility (type_decl);\n+\n       POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n     }\n   timevar_pop (TV_NAME_LOOKUP);\n@@ -6588,6 +6586,11 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t  SET_DECL_FRIEND_CONTEXT (r,\n \t\t\t\t   tsubst (DECL_FRIEND_CONTEXT (t),\n \t\t\t\t\t    args, complain, in_decl));\n+\n+\t/* Possibly limit visibility based on template args.  */\n+\tDECL_VISIBILITY (r) = VISIBILITY_DEFAULT;\n+\tDECL_VISIBILITY_SPECIFIED (r) = 0;\n+\tdetermine_visibility (r);\n       }\n       break;\n \n@@ -6760,6 +6763,13 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \tif (CODE_CONTAINS_STRUCT (TREE_CODE (t), TS_DECL_WRTL))\n \t  SET_DECL_RTL (r, NULL_RTX);\n \tDECL_SIZE (r) = DECL_SIZE_UNIT (r) = 0;\n+\tif (TREE_CODE (r) == VAR_DECL)\n+\t  {\n+\t    /* Possibly limit visibility based on template args.  */\n+\t    DECL_VISIBILITY (r) = VISIBILITY_DEFAULT;\n+\t    DECL_VISIBILITY_SPECIFIED (r) = 0;\n+\t    determine_visibility (r);\n+\t  }\n \n \tif (!local_p)\n \t  {"}, {"sha": "18beb7906f972e7fcd87fbaff040e5f78fc34055", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -1156,6 +1156,10 @@ create_pseudo_type_info (int tk, const char *real_name, ...)\n   ti->name = get_identifier (real_name);\n   ti->vtable = NULL_TREE;\n \n+  /* Pretend this is public so determine_visibility doesn't give vtables\n+     internal linkage.  */\n+  TREE_PUBLIC (TYPE_MAIN_DECL (ti->type)) = 1;\n+\n   va_end (ap);\n }\n "}, {"sha": "c5b3fbb0f627457cea3319610c9ac6f0d1d9cfc7", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -2161,7 +2161,7 @@ check_template_template_default_arg (tree argument)\n /* Begin a class definition, as indicated by T.  */\n \n tree\n-begin_class_definition (tree t)\n+begin_class_definition (tree t, tree attributes)\n {\n   if (t == error_mark_node)\n     return error_mark_node;\n@@ -2200,6 +2200,9 @@ begin_class_definition (tree t)\n   maybe_process_partial_specialization (t);\n   pushclass (t);\n   TYPE_BEING_DEFINED (t) = 1;\n+\n+  cplus_decl_attributes (&t, attributes, (int) ATTR_FLAG_TYPE_IN_PLACE);\n+\n   if (flag_pack_struct)\n     {\n       tree v;"}, {"sha": "c1c6719e8ef6bfe96e28ec8601aeaf835eb7cde1", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -1385,6 +1385,30 @@ decl_namespace_context (tree decl)\n     }\n }\n \n+/* Returns true if decl is within an anonymous namespace, however deeply\n+   nested, or false otherwise.  */\n+\n+bool\n+decl_anon_ns_mem_p (tree decl)\n+{\n+  while (1)\n+    {\n+      if (decl == NULL_TREE)\n+\treturn false;\n+      if (TREE_CODE (decl) == NAMESPACE_DECL\n+\t  && DECL_NAME (decl) == NULL_TREE)\n+\treturn true;\n+      /* Classes and namespaces inside anonymous namespaces have\n+         TREE_PUBLIC == 0, so we can shortcut the search.  */\n+      else if (TYPE_P (decl))\n+\treturn (TREE_PUBLIC (TYPE_NAME (decl)) == 0);\n+      else if (TREE_CODE (decl) == NAMESPACE_DECL)\n+\treturn (TREE_PUBLIC (decl) == 0);\n+      else\n+\tdecl = DECL_CONTEXT (decl);\n+    }\n+}\n+\n /* Return truthvalue of whether T1 is the same tree structure as T2.\n    Return 1 if they are the same. Return 0 if they are different.  */\n \n@@ -2181,7 +2205,8 @@ decl_linkage (tree decl)\n      template instantiations have internal linkage (in the object\n      file), but the symbols should still be treated as having external\n      linkage from the point of view of the language.  */\n-  if (TREE_CODE (decl) != TYPE_DECL && DECL_LANG_SPECIFIC (decl) && DECL_COMDAT (decl))\n+  if (TREE_CODE (decl) != TYPE_DECL && DECL_LANG_SPECIFIC (decl)\n+      && DECL_COMDAT (decl))\n     return lk_external;\n \n   /* Things in local scope do not have linkage, if they don't have"}, {"sha": "91b52945866d6bf6c169e0b35ed2dac90d32a669", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 58, "deletions": 22, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -2409,10 +2409,10 @@ consistently, so that the same entity should not be declared with\n different settings of the attribute.\n \n In C++, the visibility attribute applies to types as well as functions\n-and objects, because in C++ types have linkage.  There are some bugs\n-in the C++ support for this flag, for example a template which has a\n-hidden type as a parameter is not properly hidden.\n-@c bugzilla 26612\n+and objects, because in C++ types have linkage.  A class must not have\n+greater visibility than its non-static data member types and bases,\n+and class members default to the visibility of their class.  Also, a\n+declaration must not have greater visibility than its type.\n \n In C++, you can mark member functions and static member variables of a\n class with the visibility attribute.  This is useful if if you know a\n@@ -2423,6 +2423,17 @@ the One Definition Rule; for example, it is not useful to mark a\n method which is defined inside a class definition as hidden without\n marking the whole class as hidden.\n \n+A C++ namespace declaration can also have the visibility attribute.\n+This attribute applies only to the particular namespace body, not to\n+other definitions of the same namespace; it is equivalent to using\n+@samp{#pragma GCC visibility} before and after the namespace\n+definition (@pxref{Visibility Pragmas}).\n+\n+In C++, if a template argument has limited visibility, this\n+restriction is implicitly propagated to the template instantiation.\n+Otherwise, template instantiations and specializations default to the\n+visibility of their template.\n+\n @item warn_unused_result\n @cindex @code{warn_unused_result} attribute\n The @code{warn_unused_result} attribute causes a warning to be emitted\n@@ -2604,10 +2615,7 @@ does not arise there.\n An attribute specifier list may appear as part of a @code{struct},\n @code{union} or @code{enum} specifier.  It may go either immediately\n after the @code{struct}, @code{union} or @code{enum} keyword, or after\n-the closing brace.  It is ignored if the content of the structure, union\n-or enumerated type is not defined in the specifier in which the\n-attribute specifier list is used---that is, in usages such as\n-@code{struct __attribute__((foo)) bar} with no following opening brace.\n+the closing brace.  The former syntax is preferred.\n Where attribute specifiers follow the closing brace, they are considered\n to relate to the structure, union or enumerated type defined, not to any\n enclosing declaration the type specifier appears in, and the type\n@@ -3382,28 +3390,28 @@ placed in either the @code{.bss_below100} section or the\n @cindex type attributes\n \n The keyword @code{__attribute__} allows you to specify special\n-attributes of @code{struct} and @code{union} types when you define such\n-types.  This keyword is followed by an attribute specification inside\n-double parentheses.  Six attributes are currently defined for types:\n-@code{aligned}, @code{packed}, @code{transparent_union}, @code{unused},\n-@code{deprecated} and @code{may_alias}.  Other attributes are defined for\n-functions (@pxref{Function Attributes}) and for variables\n-(@pxref{Variable Attributes}).\n+attributes of @code{struct} and @code{union} types when you define\n+such types.  This keyword is followed by an attribute specification\n+inside double parentheses.  Seven attributes are currently defined for\n+types: @code{aligned}, @code{packed}, @code{transparent_union},\n+@code{unused}, @code{deprecated}, @code{visibility}, and\n+@code{may_alias}.  Other attributes are defined for functions\n+(@pxref{Function Attributes}) and for variables (@pxref{Variable\n+Attributes}).\n \n You may also specify any one of these attributes with @samp{__}\n preceding and following its keyword.  This allows you to use these\n attributes in header files without being concerned about a possible\n macro of the same name.  For example, you may use @code{__aligned__}\n instead of @code{aligned}.\n \n-You may specify the @code{aligned} and @code{transparent_union}\n-attributes either in a @code{typedef} declaration or just past the\n-closing curly brace of a complete enum, struct or union type\n-@emph{definition} and the @code{packed} attribute only past the closing\n-brace of a definition.\n+You may specify type attributes either in a @code{typedef} declaration\n+or in an enum, struct or union type declaration or definition.\n \n-You may also specify attributes between the enum, struct or union\n-tag and the name of the type rather than after the closing brace.\n+For an enum, struct or union type, you may specify attributes either\n+between the enum, struct or union tag and the name of the type, or\n+just past the closing curly brace of the @emph{definition}.  The\n+former syntax is preferred.\n \n @xref{Attribute Syntax}, for details of the exact syntax for using\n attributes.\n@@ -3652,6 +3660,13 @@ declaration, the above program would abort when compiled with\n @option{-fstrict-aliasing}, which is on by default at @option{-O2} or\n above in recent GCC versions.\n \n+@item visibility\n+\n+In C++, attribute visibility (@pxref{Function Attributes}) can also be\n+applied to class, struct, union and enum types.  Unlike other type\n+attributes, the attribute must appear between the initial keyword and\n+the name of the type; it cannot appear after the body of the type.\n+\n @subsection ARM Type Attributes\n \n On those ARM targets that support @code{dllimport} (such as Symbian\n@@ -9454,6 +9469,7 @@ for further explanation.\n * Structure-Packing Pragmas::\n * Weak Pragmas::\n * Diagnostic Pragmas::\n+* Visibility Pragmas::\n @end menu\n \n @node ARM Pragmas\n@@ -9750,6 +9766,26 @@ strict control over project policies.\n \n @end table\n \n+@node Visibility Pragmas\n+@subsection Visibility Pragmas\n+\n+@table @code\n+@item #pragma GCC visibility push(@var{visibility})\n+@itemx #pragma GCC visibility pop\n+@cindex pragma, visibility\n+\n+This pragma allows the user to set the visibility for multiple\n+declarations without having to give each a visibility attribute\n+@xref{Function Attributes}, for more information about visibility and\n+the attribute syntax.\n+\n+In C++, @samp{#pragma GCC visibility} affects only namespace-scope\n+declarations.  Class members and template specializations are not\n+affected; if you want to override the visibility for a particular\n+member or instantiation, you must use an attribute.\n+\n+@end table\n+\n @node Unnamed Fields\n @section Unnamed struct/union fields within structs/unions\n @cindex struct"}, {"sha": "0c5e382f851886e71a7a83c47e7e31e4a09b87fd", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -1619,16 +1619,10 @@ when used within the DSO@.  Enabling this option can have a dramatic effect\n on load and link times of a DSO as it massively reduces the size of the\n dynamic export table when the library makes heavy use of templates.\n \n-The behavior of this switch is not quite the same as marking the\n-methods as hidden directly.  Normally if there is a class with default\n-visibility which has a hidden method, the effect of this is that the\n-method must be defined in only one shared object.  This switch does\n-not have this restriction.\n-\n You may mark a method as having a visibility explicitly to negate the\n effect of the switch for that method.  For example, if you do want to\n-compare pointers to a particular inline method, you might mark it as\n-having default visibility.\n+compare pointers to a particular inline method, or the method has\n+local static data, you might mark it as having default visibility.\n \n @item -fno-weak\n @opindex fno-weak\n@@ -13506,6 +13500,20 @@ expecting to be compiled with visibility other than the default.  You\n may need to explicitly say @samp{#pragma GCC visibility push(default)}\n before including any such headers.\n \n+@samp{extern} declarations are not affected by @samp{-fvisibility}, so\n+a lot of code can be recompiled with @samp{-fvisibility=hidden} with\n+no modifications.  However, this means that calls to @samp{extern}\n+functions with no explicit visibility will use the PLT, so it is more\n+effective to use @samp{__attribute ((visibility))} and/or\n+@samp{#pragma GCC visibility} to tell the compiler which @samp{extern}\n+declarations should be treated as hidden.\n+\n+Note that @samp{-fvisibility} does affect C++ vague linkage\n+entities. This means that, for instance, an exception class that will\n+be thrown between DSOs must be explicitly marked with default\n+visibility so that the @samp{type_info} nodes will be unified between\n+the DSOs.\n+\n An overview of these techniques, their benefits and how to use them\n is at @w{@uref{http://gcc.gnu.org/wiki/Visibility}}.\n "}, {"sha": "5e4583450a00f044bafa5191c4c9b07caffb7ee3", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -58,15 +58,16 @@ extern enum debug_info_level debug_info_level;\n    debugging information.  */\n extern bool use_gnu_debug_info_extensions;\n \n-/* Enumerate visibility settings.  */\n+/* Enumerate visibility settings.  This is deliberately ordered from most\n+   to least visibility.  */\n #ifndef SYMBOL_VISIBILITY_DEFINED\n #define SYMBOL_VISIBILITY_DEFINED\n enum symbol_visibility\n {\n   VISIBILITY_DEFAULT,\n-  VISIBILITY_INTERNAL,\n+  VISIBILITY_PROTECTED,\n   VISIBILITY_HIDDEN,\n-  VISIBILITY_PROTECTED\n+  VISIBILITY_INTERNAL\n };\n #endif\n "}, {"sha": "c7e5f7a9fd97167d9838bda41f74fc8e04d5a8cb", "filename": "gcc/testsuite/g++.dg/ext/attrib14.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib14.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -3,11 +3,11 @@\n // parsing of the class, causing some variants to have it and some not.\n \n struct __attribute__((bogus)) A\n-{\n+{\t\t\t\t// { dg-warning \"ignored\" \"\" }\n     virtual ~A();\n     void foo(const A&);\n     void bar(const A&);\n-};\t\t\t\t// { dg-warning \"ignored\" \"\" }\n+};\n \n void A::foo(const A&)   {}\n void A::bar(const A& a) { foo(a); }"}, {"sha": "6672f7525af5563c4c5f3405c15ae5816d05058e", "filename": "gcc/testsuite/g++.dg/ext/attrib9.C", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib9.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -1,5 +1,10 @@\n-class __attribute__((unused)) C;\t//  { dg-warning \"type attributes\" }\n-struct __attribute__((unused)) S;\t//  { dg-warning \"type attributes\" }\n-union __attribute__((unused)) U;\t//  { dg-warning \"type attributes\" }\n+class __attribute__((unused)) C;\n+struct __attribute__((unused)) S;\n+union __attribute__((unused)) U;\n enum e {};\n-enum __attribute__((unused)) e;\t\t//  { dg-warning \"type attributes\" }\n+enum __attribute__((unused)) e;\t// { dg-warning \"already defined\" }\n+\n+struct __attribute((unused)) B *p;\t//  { dg-warning \"attributes\" }\n+\n+template <class T> struct A { };\n+struct __attribute((unused)) A<int>;\t//  { dg-warning \"attributes\" }"}, {"sha": "16647b2281456d5d215a28f79999d11d07392c4b", "filename": "gcc/testsuite/g++.dg/ext/visibility/anon1.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fanon1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fanon1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fanon1.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -1,8 +1,8 @@\n // PR c++/21581\n-// Test for anonymous namespace default hidden visibility\n+// Test for anonymous namespace internal linkage\n \n-// { dg-require-visibility \"\" }\n-// { dg-final-NOT { scan-hidden \"_ZN.*1fEv\" } }\n+// { dg-do compile }\n+// { dg-final { scan-assembler-not \"globl.*_ZN.*1fEv\" } }\n \n namespace\n {"}, {"sha": "1d8e479b9ff55aae04b50557326abee5498429dc", "filename": "gcc/testsuite/g++.dg/ext/visibility/anon2.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fanon2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fanon2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fanon2.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -0,0 +1,11 @@\n+// Test for propagation of anonymous namespace internal linkage\n+\n+// { dg-do compile }\n+// { dg-final { scan-assembler-not \"globl.*_Z1fv\" } }\n+\n+namespace\n+{\n+  struct A { };\n+}\n+\n+A f () { }"}, {"sha": "b25999e8ee96e295aff05ebb4298c0c23b78ea65", "filename": "gcc/testsuite/g++.dg/ext/visibility/assign1.C", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fassign1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fassign1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fassign1.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -6,11 +6,12 @@ struct B {\n   B& operator=(const B&);\n };\n \n-struct D : public B {\n+struct __attribute__((visibility(\"hidden\"))) D : public B {\n   // The implicit assignment operator should be hidden.\n-} __attribute__((visibility(\"hidden\")));\n+};\n \n-D d1, d2;\n+__attribute__((visibility(\"hidden\"))) D d1;\n+__attribute__((visibility(\"hidden\"))) D d2;\n \n void f() {\n   d1 = d2;"}, {"sha": "d5265146da5c6e10888f9dde40bb4b04133fe141", "filename": "gcc/testsuite/g++.dg/ext/visibility/class1.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fclass1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fclass1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fclass1.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -0,0 +1,20 @@\n+// PR c++/26905\n+// Init should not be hidden, so calling it should use the PLT.\n+\n+// { dg-require-visibility \"\" }\n+// { dg-options \"-fpic\" }\n+// { dg-do compile { target i?86-*-* x86_64-*-* } }\n+// { dg-final { scan-assembler \"InitEv@PLT\" } }\n+\n+#pragma GCC visibility push(hidden)\n+struct __attribute__ ((visibility (\"default\"))) nsINIParser\n+{\n+    static void Init();\n+};\n+\n+__attribute__ ((visibility (\"default\")))\n+void\n+CheckCompatibility(void)\n+{\n+  nsINIParser::Init();\n+}"}, {"sha": "853686cf392eb163456ab7712db734b1be8bb8ec", "filename": "gcc/testsuite/g++.dg/ext/visibility/fvisibility-override2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ffvisibility-override2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ffvisibility-override2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ffvisibility-override2.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -6,7 +6,7 @@\n \n class Foo\n {\n-  __attribute__ ((visibility (\"default\"))) void method();\n+  __attribute__ ((visibility (\"internal\"))) void method();\n };\n \n void Foo::method() { }"}, {"sha": "f4574820d328755ab47a4aee360bf8d647611c86", "filename": "gcc/testsuite/g++.dg/ext/visibility/prop1.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fprop1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fprop1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fprop1.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -0,0 +1,23 @@\n+// Test for propagation of visibility through template arguments\n+\n+// { dg-do compile }\n+// { dg-require-visibility \"\" }\n+// { dg-final { scan-hidden \"_Z1fIN1N1AEEvT_\" } }\n+// { dg-final { scan-hidden \"_Z1hIXadL_ZN1N1iEEEEvv\" } }\n+\n+namespace N __attribute ((__visibility__ (\"hidden\")))\n+{\n+  struct A { };\n+  int i;\n+}\n+\n+template <class T> void f (T) { }\n+template <int *I> void h() { }\n+\n+void g()\n+{\n+  N::A a;\n+  f(a);\n+  h<&N::i>();\n+}\n+"}, {"sha": "75c8554185285a7262b71376edf029f442059bf6", "filename": "gcc/testsuite/g++.dg/ext/visibility/redecl1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fredecl1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fredecl1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fredecl1.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -0,0 +1,7 @@\n+// Test that we complain about redeclaration with different visibility\n+\n+struct __attribute((visibility(\"hidden\"))) B;\n+struct __attribute((visibility(\"default\"))) B;\t// { dg-warning \"visibility\" }\n+\n+__attribute ((visibility (\"hidden\"))) void f();\t// { dg-warning \"previous\" }\n+__attribute ((visibility (\"default\"))) void f(); // { dg-warning \"visibility\" }"}, {"sha": "c5cee0d4b17ad4db9309e338837952a4416f5d22", "filename": "gcc/testsuite/g++.dg/ext/visibility/template1.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ftemplate1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ftemplate1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ftemplate1.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -0,0 +1,35 @@\n+// PR c++/19134\n+// -fvisibility-inlines-hidden doesn't apply to non-inline specializations\n+\n+// { dg-require-visibility \"\" }\n+// { dg-options \"-fvisibility-inlines-hidden\" }\n+// { dg-final { scan-not-hidden \"_ZN1AIiE3fooEv\" } }\n+// { dg-final { scan-not-hidden \"_ZN1AIiE3barEv\" } }\n+// { dg-final { scan-hidden \"_ZN1AIlE3fooEv\" } }\n+// { dg-final { scan-hidden \"_ZN1AIlE3barEv\" } }\n+// { dg-final { scan-hidden \"_ZN1AIcE3barEv\" } }\n+\n+template<class T>\n+struct A {\n+  void foo() {};\n+  __attribute ((visibility (\"hidden\"))) void bar();\n+};\n+\n+// This has default visibility.\n+template<> void A<int>::foo() {}\n+\n+// This has hidden visibility because of -fvisibility-inlines-hidden.\n+template<> inline void A<long>::foo() {}\n+// Force the inline out.\n+void f () { A<long> a; a.foo(); }\n+\n+// This has default visibility.\n+template<> __attribute ((visibility (\"default\"))) void A<int>::bar() {}\n+\n+// This inherits hidden visibility from its template.\n+template<> void A<long>::bar() { }\n+\n+// This also has hidden visibility; #pragma vis doesn't affect class members.\n+#pragma GCC visibility push(default)\n+template<> void A<char>::bar() { }\n+#pragma GCC visibility pop"}, {"sha": "8db96db564942a6f09af1154e590971b370ab88e", "filename": "gcc/testsuite/g++.dg/ext/visibility/template2.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ftemplate2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ftemplate2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ftemplate2.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -0,0 +1,35 @@\n+// PR c++/27000\n+// Implicitly instantiated templates should not be affected by\n+// #pragma visibility.\n+\n+/* { dg-do compile } */\n+/* { dg-require-visibility \"\" } */\n+/* { dg-final { scan-not-hidden \"_ZN1SIiED1Ev\" } } */\n+/* { dg-final { scan-not-hidden \"_ZN1SIiEC1ERKi\" } } */\n+\n+template <class T>\n+struct S\n+{\n+  S (const T &);\n+  ~S ();\n+  T t;\n+};\n+\n+template <class T>\n+S<T>::S (const T &x)\n+{\n+  t = x;\n+}\n+\n+template <class T>\n+S<T>::~S ()\n+{\n+}\n+\n+#pragma GCC visibility push(hidden)\n+struct U\n+{\n+  S<int> s;\n+  U () : s (6) { }\n+} u;\n+#pragma GCC visibility pop"}, {"sha": "69cb6caba77451927e53126c87cc8cd8a1cd3263", "filename": "gcc/testsuite/g++.dg/ext/visibility/template3.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ftemplate3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ftemplate3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ftemplate3.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/17470\n+// Test that we can give visibility to explicit template instantiations\n+\n+// { dg-require-visibility \"\" }\n+// { dg-final { scan-hidden \"_ZN1AIlE1fEl\" } }\n+// { dg-final { scan-hidden \"_ZN1AIiE1fEi\" } }\n+// { dg-final { scan-not-hidden \"_ZN1AIcE1fEc\" } }\n+// { dg-final { scan-hidden \"_Z8identityIdET_S0_\" } }\n+// { dg-final { scan-not-hidden \"_Z8identityIiET_S0_\" } }\n+\n+template <class T> T identity(T t) { return t; }\n+template  __attribute__((visibility(\"hidden\"))) double identity(double);\n+template int identity(int);\n+\n+\n+template <class T> struct A { void f (T); };\n+template <class T> void A<T>::f (T) { }\n+template struct __attribute ((visibility (\"hidden\"))) A<int>;\n+template<> struct  __attribute ((visibility (\"hidden\"))) A<long> { void f(long); };\n+// inherits hidden visibility from its class\n+void A<long>::f (long) { }\n+template struct A<char>;"}, {"sha": "add63a5934bb28854b23cadd4e62c47be4f7fa4b", "filename": "gcc/testsuite/g++.dg/ext/visibility/template4.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ftemplate4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ftemplate4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ftemplate4.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -0,0 +1,39 @@\n+// Test for explicit visibility on template vs. #pragma vis at explicit\n+// instantiation/specialization point for plain function templates.\n+\n+// { dg-require-visibility \"\" }\n+// { dg-final { scan-hidden \"_Z3fooIdEvT_\" } }\n+// { dg-final { scan-hidden \"_Z3fooIlEvT_\" } }\n+// { dg-final { scan-hidden \"_Z3fooIcEvT_\" } }\n+// { dg-final { scan-hidden \"_Z3fooIiEvT_\" } }\n+// { dg-final { scan-not-hidden \"_Z3fooIfEvT_\" } }\n+// { dg-final { scan-not-hidden \"_Z3fooIsEvT_\" } }\n+\n+// { dg-final { scan-hidden \"_Z3barIdEvT_\" } }\n+// { dg-final { scan-hidden \"_Z3barIlEvT_\" } }\n+// { dg-final { scan-hidden \"_Z3barIiEvT_\" } }\n+// { dg-final { scan-hidden \"_Z3barIcEvT_\" } }\n+// { dg-final { scan-not-hidden \"_Z3barIfEvT_\" } }\n+// { dg-final { scan-not-hidden \"_Z3barIsEvT_\" } }\n+\n+#pragma GCC visibility push(hidden)\n+template <class T> void bar(T) { }\n+#pragma GCC visibility pop\n+template void bar (long);\n+template<> void bar (double) { }\n+template __attribute ((visibility (\"default\"))) void bar (short);\n+template<> __attribute ((visibility (\"default\"))) void bar (float) { }\n+#pragma GCC visibility push(default)\n+template<> void bar(char) { }\n+template void bar(int);\n+#pragma GCC visibility pop\n+\n+template <class T> __attribute ((visibility (\"hidden\"))) void foo(T) { }\n+template void foo (long);\n+template<> void foo (double) { }\n+template __attribute ((visibility (\"default\"))) void foo (short);\n+template<> __attribute ((visibility (\"default\"))) void foo (float) { }\n+#pragma GCC visibility push(default)\n+template<> void foo(char) { }\n+template void foo(int);\n+#pragma GCC visibility pop"}, {"sha": "99dfc1cd76deea64fedc7bab38670b58a55621d9", "filename": "gcc/testsuite/g++.dg/ext/visibility/typeinfo1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ftypeinfo1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ftypeinfo1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Ftypeinfo1.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/26984\n+// lazily generated typeinfos should not be affected by #pragma vis, but\n+// they should be affected by the visibility of the type they describe.\n+\n+// { dg-require-visibility \"\" }\n+// { dg-options \"-fvisibility-inlines-hidden\" }\n+// { dg-final { scan-not-hidden \"_ZTIPPi\" } }\n+// { dg-final { scan-not-hidden \"_ZTSPPi\" } }\n+// { dg-final { scan-hidden \"_ZTIP1A\" } }\n+// { dg-final { scan-hidden \"_ZTSP1A\" } }\n+\n+#include <typeinfo>\n+\n+#pragma GCC visibility push(hidden)\n+const std::type_info* t = &(typeid(int **));\n+struct A { };\n+#pragma GCC visibility pop\n+\n+const std::type_info* t2 = &(typeid(A *));"}, {"sha": "770600368de026f37ea5dd36846fc1606dd50975", "filename": "gcc/testsuite/g++.dg/ext/visibility/virtual.C", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fvirtual.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fvirtual.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fvirtual.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -1,9 +1,15 @@\n-/* Test that setting visibility for class affects virtual table. */\n+/* Test that setting visibility for class affects virtual table, VTT and\n+   type_info name and node. */\n /* { dg-do compile } */\n /* { dg-require-visibility \"\" } */\n /* { dg-final { scan-hidden \"ZTV3Foo\" } } */\n+/* { dg-final { scan-hidden \"ZTT3Foo\" } } */\n+/* { dg-final { scan-hidden \"ZTS3Foo\" } } */\n+/* { dg-final { scan-hidden \"ZTI3Foo\" } } */\n \n-class __attribute__ ((visibility (\"hidden\"))) Foo\n+struct A { };\n+\n+class __attribute__ ((visibility (\"hidden\"))) Foo: virtual public A\n {\n   virtual void method();\n };"}, {"sha": "3b6b85f365af122a611984b037e50866460e5123", "filename": "gcc/testsuite/g++.dg/ext/visibility/warn1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fwarn1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fwarn1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fwarn1.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -0,0 +1,13 @@\n+// Warn when a declaration is specified with greater visibility than that\n+// of its type.\n+\n+// { dg-do compile }\n+// { dg-require-visibility \"\" }\n+// { dg-final { scan-hidden \"_Z1fv\" } }\n+\n+namespace N __attribute ((__visibility__ (\"hidden\")))\n+{\n+  struct A { };\n+}\n+\n+N::A f() { } // { dg-warning \"visibility\" \"\" }"}, {"sha": "1baf8b9e83ad981ae46bb679762bac4a692f3aa7", "filename": "gcc/testsuite/g++.dg/ext/visibility/warn2.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fwarn2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fwarn2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fwarn2.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -0,0 +1,19 @@\n+// Complain when a class is specified with greater visibility than one of\n+// its members' types or bases, and when a declaration has greater\n+// visibility than its type.\n+\n+// { dg-require-visibility \"\" }\n+\n+namespace N __attribute ((__visibility__ (\"hidden\")))\n+{\n+  struct A { };\n+}\n+\n+struct B\n+{\t\t\t\t// { dg-warning \"visibility\" }\n+  N::A a;\n+};\n+\n+B f () { }\t\t\t// { dg-warning \"visibility\" }\n+\n+struct C: public N::A { };\t// { dg-warning \"visibility\" }"}, {"sha": "705748ad7116a62f10d1b2f49cbe4c79af408872", "filename": "gcc/testsuite/g++.dg/ext/visibility/warn3.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fwarn3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fwarn3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fwarn3.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -0,0 +1,11 @@\n+// Warn when a class member is specified to have greater visibility than\n+// its class.\n+\n+// { dg-require-visibility \"\" }\n+\n+struct __attribute ((visibility (\"hidden\"))) A\n+{\n+  __attribute ((visibility (\"default\"))) void f (); // { dg-warning \"visibility\" }\n+};\n+\n+void A::f() { }"}, {"sha": "e405e7a74c822be479bcaec1723023d02264bf2e", "filename": "gcc/testsuite/g++.dg/ext/visibility/warn4.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fwarn4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fwarn4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fwarn4.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -0,0 +1,10 @@\n+// Error if we try to give an instantiation visibility after it's already\n+// been instantiated.\n+\n+// { dg-require-visibility \"\" }\n+\n+template <class T> struct A { void f (T); };\n+template <class T> void A<T>::f (T) { }\n+\n+A<double> ad;\n+template struct __attribute ((visibility (\"hidden\"))) A<double>; // { dg-error \"already defined\" }"}, {"sha": "a7c5ea3e5622829c71e2a7d9b4ddd043cf2d8b2f", "filename": "gcc/testsuite/g++.old-deja/g++.pt/enum5.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fenum5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fenum5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fenum5.C?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -1,4 +1,4 @@\n // { dg-do assemble  }\n \n-template <> // { dg-error \"\" } template declaration of enum\n-enum E {e};\n+template <>\n+enum E {e}; // { dg-error \"\" } template declaration of enum"}, {"sha": "15171e3de65367b0273304bd71e4c6880211b468", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -3133,14 +3133,6 @@ build_decl_stat (enum tree_code code, tree name, tree type MEM_STAT_DECL)\n   else if (code == FUNCTION_DECL)\n     DECL_MODE (t) = FUNCTION_MODE;\n \n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n-    {\n-      /* Set default visibility to whatever the user supplied with\n-\t visibility_specified depending on #pragma GCC visibility.  */\n-      DECL_VISIBILITY (t) = default_visibility;\n-      DECL_VISIBILITY_SPECIFIED (t) = visibility_options.inpragma;\n-    }\n-\n   return t;\n }\n "}, {"sha": "792ae10e0184e4208b2cb42fef7570764f516e43", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -1067,7 +1067,7 @@ extern void omp_clause_range_check_failed (const tree, const char *, int,\n \n #define TREE_OVERFLOW(NODE) (CST_CHECK (NODE)->common.public_flag)\n \n-/* In a VAR_DECL or FUNCTION_DECL,\n+/* In a VAR_DECL, FUNCTION_DECL, NAMESPACE_DECL or TYPE_DECL,\n    nonzero means name is to be accessible from outside this module.\n    In an IDENTIFIER_NODE, nonzero means an external declaration\n    accessible from outside this module was previously seen\n@@ -2264,9 +2264,9 @@ struct tree_binfo GTY (())\n enum symbol_visibility\n {\n   VISIBILITY_DEFAULT,\n-  VISIBILITY_INTERNAL,\n+  VISIBILITY_PROTECTED,\n   VISIBILITY_HIDDEN,\n-  VISIBILITY_PROTECTED\n+  VISIBILITY_INTERNAL\n };\n #endif\n "}, {"sha": "a10d954d0c6e6c9df6e9bc451724095019c07919", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e75696307f710a22c726e72b00e7a7161ad89f/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=b9e75696307f710a22c726e72b00e7a7161ad89f", "patch": "@@ -5033,7 +5033,7 @@ void\n default_assemble_visibility (tree decl, int vis)\n {\n   static const char * const visibility_types[] = {\n-    NULL, \"internal\", \"hidden\", \"protected\"\n+    NULL, \"protected\", \"hidden\", \"internal\"\n   };\n \n   const char *name, *type;"}]}