{"sha": "47be95094bc2d5c79320234a35e5049e0514fff1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdiZTk1MDk0YmMyZDVjNzkzMjAyMzRhMzVlNTA0OWUwNTE0ZmZmMQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2018-12-05T06:47:11Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2018-12-05T06:47:11Z"}, "message": "[PR85569] skip constexpr target_expr constructor dummy type conversion\n\nThe testcase is the work-around testcase for the PR; even that had\nstarted failing.  The problem was that, when unqualifying the type of\na TARGET_EXPR, we'd create a variant of the type, then request the\nconversion of the TARGET_EXPR_INITIAL to that variant type.  Though\nthe types are different pointer-wise, they're the same_type_p, so the\nresulting modified expr compares cp_tree_equal to the original, which\nmaybe_constant_value flags as an error.  There's no reason to\nconstruct an alternate TARGET_EXPR or CONSTRUCTOR just because of an\nequivalent type, except for another spot that expected pointer\nequality that would no longer be satisfied.  Without relaxing the\nassert in constexpr_call_hasher::equal, g++.robertl/eb73.C would\ntrigger an assertion failure.\n\n\nfor  gcc/cp/ChangeLog\n\n\tPR c++/85569\n\t* constexpr.c (adjust_temp_type): Test for type equality with\n\tsame_type_p.\n\t(constexpr_call_hasher::equal): Likewise.\n\nfor  gcc/testsuite/ChangeLog\n\n\tPR c++/85569\n\t* g++.dg/cpp1z/pr85569.C: New.\n\nFrom-SVN: r266816", "tree": {"sha": "a7af895bf2672ac18041041a977b2953ab63e6fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7af895bf2672ac18041041a977b2953ab63e6fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47be95094bc2d5c79320234a35e5049e0514fff1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47be95094bc2d5c79320234a35e5049e0514fff1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47be95094bc2d5c79320234a35e5049e0514fff1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47be95094bc2d5c79320234a35e5049e0514fff1/comments", "author": null, "committer": null, "parents": [{"sha": "9d2e2d29baed70d965365c77aa3a8b8611f03cb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d2e2d29baed70d965365c77aa3a8b8611f03cb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d2e2d29baed70d965365c77aa3a8b8611f03cb9"}], "stats": {"total": 109, "additions": 107, "deletions": 2}, "files": [{"sha": "3958992a57a56561c4ced6c7ad5faba38ad442c3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47be95094bc2d5c79320234a35e5049e0514fff1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47be95094bc2d5c79320234a35e5049e0514fff1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=47be95094bc2d5c79320234a35e5049e0514fff1", "patch": "@@ -1,3 +1,10 @@\n+2018-12-05  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR c++/85569\n+\t* constexpr.c (adjust_temp_type): Test for type equality with\n+\tsame_type_p.\n+\t(constexpr_call_hasher::equal): Likewise.\n+\n 2018-12-04  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/84636"}, {"sha": "a668d14e8bf5c270e917d8dad9dbac18998fa585", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47be95094bc2d5c79320234a35e5049e0514fff1/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47be95094bc2d5c79320234a35e5049e0514fff1/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=47be95094bc2d5c79320234a35e5049e0514fff1", "patch": "@@ -1060,7 +1060,7 @@ constexpr_call_hasher::equal (constexpr_call *lhs, constexpr_call *rhs)\n     {\n       tree lhs_arg = TREE_VALUE (lhs_bindings);\n       tree rhs_arg = TREE_VALUE (rhs_bindings);\n-      gcc_assert (TREE_TYPE (lhs_arg) == TREE_TYPE (rhs_arg));\n+      gcc_assert (same_type_p (TREE_TYPE (lhs_arg), TREE_TYPE (rhs_arg)));\n       if (!cp_tree_equal (lhs_arg, rhs_arg))\n         return false;\n       lhs_bindings = TREE_CHAIN (lhs_bindings);\n@@ -1276,7 +1276,7 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n static tree\n adjust_temp_type (tree type, tree temp)\n {\n-  if (TREE_TYPE (temp) == type)\n+  if (same_type_p (TREE_TYPE (temp), type))\n     return temp;\n   /* Avoid wrapping an aggregate value in a NOP_EXPR.  */\n   if (TREE_CODE (temp) == CONSTRUCTOR)"}, {"sha": "8b74eb02bfbd6a0910903c45e2ae3537a7a97698", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47be95094bc2d5c79320234a35e5049e0514fff1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47be95094bc2d5c79320234a35e5049e0514fff1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=47be95094bc2d5c79320234a35e5049e0514fff1", "patch": "@@ -1,3 +1,8 @@\n+2018-12-05  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR c++/85569\n+\t* g++.dg/cpp1z/pr85569.C: New.\n+\n 2018-12-05  Chenghua Xu  <paul.hua.gm@gmail.com>\n \n \t* gcc.target/mips/msa.c: Adjusted clti_<su>.df $wn,$wn,5"}, {"sha": "aec543041a0f4c7ed2b0d591551e4aa5a9c5e587", "filename": "gcc/testsuite/g++.dg/cpp1z/pr85569.C", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47be95094bc2d5c79320234a35e5049e0514fff1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fpr85569.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47be95094bc2d5c79320234a35e5049e0514fff1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fpr85569.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fpr85569.C?ref=47be95094bc2d5c79320234a35e5049e0514fff1", "patch": "@@ -0,0 +1,93 @@\n+// { dg-do compile { target c++17 } }\n+\n+#include <utility>\n+#include <tuple>\n+\n+#define LIFT_FWD(x) std::forward<decltype(x)>(x)\n+\n+template <typename T>\n+inline\n+constexpr\n+auto\n+equal(\n+  T &&t)\n+{\n+  return [t = std::forward<T>(t)](const auto& obj)\n+    -> decltype(obj == t)\n+    {\n+      return obj == t;\n+    };\n+}\n+\n+template <typename F, typename T>\n+struct is_tuple_invocable;\n+\n+template <typename F, typename ... Ts>\n+struct is_tuple_invocable<F, std::tuple<Ts...>>\n+{\n+  using type = typename std::is_invocable<F, Ts...>::type;\n+};\n+\n+template <typename F>\n+inline\n+constexpr\n+auto\n+compose(\n+  F&& f\n+)\n+  noexcept\n+-> F\n+{\n+  return std::forward<F>(f);\n+}\n+\n+namespace detail {\n+  template <typename F, typename Tail, typename ... T>\n+  inline\n+  constexpr\n+  auto\n+  compose(\n+    std::true_type,\n+    F&& f,\n+    Tail&& tail,\n+    T&& ... objs)\n+  noexcept(noexcept(f(tail(std::forward<T>(objs)...))))\n+  -> decltype(f(tail(std::forward<T>(objs)...)))\n+  {\n+    return f(tail(std::forward<T>(objs)...));\n+  }\n+}\n+template <typename F, typename ... Fs>\n+inline\n+constexpr\n+auto\n+compose(\n+  F&& f,\n+  Fs&&... fs)\n+{\n+  return [f = std::forward<F>(f), tail = compose(std::forward<Fs>(fs)...)]\n+    (auto&& ... objs)\n+    -> decltype(detail::compose(typename std::is_invocable<decltype(compose(std::forward<Fs>(fs)...)), decltype(objs)...>::type{},\n+                                f,\n+                                compose(std::forward<Fs>(fs)...),\n+                                LIFT_FWD(objs)...))\n+  {\n+    using tail_type = decltype(compose(std::forward<Fs>(fs)...));\n+    \n+#ifndef NOT_VIA_TUPLE\n+    using args_type = std::tuple<decltype(objs)...>;\n+    constexpr auto unitail = typename is_tuple_invocable<tail_type, args_type>::type{};\n+#else\n+    constexpr auto unitail = typename std::is_invocable<tail_type, decltype(objs)...>::type{};\n+#endif\n+\n+    return detail::compose(unitail,  f, tail, LIFT_FWD(objs)...);\n+  };\n+}\n+\n+template <auto N>\n+constexpr auto eq = equal(N);\n+\n+static_assert(compose(eq<3>,\n+\t\t      std::plus<>{})(1,2),\n+              \"compose is constexpr\");"}]}