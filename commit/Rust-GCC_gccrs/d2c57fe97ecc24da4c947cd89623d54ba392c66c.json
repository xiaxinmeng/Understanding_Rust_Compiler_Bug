{"sha": "d2c57fe97ecc24da4c947cd89623d54ba392c66c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJjNTdmZTk3ZWNjMjRkYTRjOTQ3Y2Q4OTYyM2Q1NGJhMzkyYzY2Yw==", "commit": {"author": {"name": "Andi Kleen", "email": "ak@linux.intel.com", "date": "2010-08-05T14:25:45Z"}, "committer": {"name": "Andi Kleen", "email": "ak@gcc.gnu.org", "date": "2010-08-05T14:25:45Z"}, "message": "lto-plugin.c: Include <hashtab.h>\n\n* lto-plugin.c: Include <hashtab.h>\n        (sym_aux): Add next_conflict field to save conflict chains.\n        (plugin_file_info): Add conflicts symtab.\n        (parse_table_entry): Initialize aux->next_conflict.\n        (process_symtab): Increment found.\n        (dump_symtab): Add.\n        (finish_conflict_resolution): Add.\n        (free_symtab): Add.\n        (write_resolution): Remove symbols loop and move into\n        dump_symtab. Call dump_symtab for main symbol and conflicts table.\n        Call free_symtab to free conflicts table.\n        (SWAP): Add.\n        (eq_sym): Add.\n        (hash_sym): Add.\n        (symbol_strength): Add.\n        (resolve_conflicts): Add.\n        (claim_file_handler): Add n variable. Check return value of\n        process_symtab. Call resolve_conflicts.\n\nFrom-SVN: r162915", "tree": {"sha": "d37207a27d2c22ebb8923ef8f16ac8c6ebd735dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d37207a27d2c22ebb8923ef8f16ac8c6ebd735dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2c57fe97ecc24da4c947cd89623d54ba392c66c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2c57fe97ecc24da4c947cd89623d54ba392c66c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2c57fe97ecc24da4c947cd89623d54ba392c66c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2c57fe97ecc24da4c947cd89623d54ba392c66c/comments", "author": null, "committer": null, "parents": [{"sha": "2645f11a7cb4a97c409c3e01bfb0a1cde413b1b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2645f11a7cb4a97c409c3e01bfb0a1cde413b1b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2645f11a7cb4a97c409c3e01bfb0a1cde413b1b6"}], "stats": {"total": 251, "additions": 242, "deletions": 9}, "files": [{"sha": "6f6c4e8908c60f6122cddfb53dd2775df3b8f9aa", "filename": "lto-plugin/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2c57fe97ecc24da4c947cd89623d54ba392c66c/lto-plugin%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2c57fe97ecc24da4c947cd89623d54ba392c66c/lto-plugin%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2FChangeLog?ref=d2c57fe97ecc24da4c947cd89623d54ba392c66c", "patch": "@@ -1,3 +1,24 @@\n+2010-08-05  Andi Kleen  <ak@linux.intel.com>\n+\n+\t* lto-plugin.c: Include <hashtab.h>\n+\t(sym_aux): Add next_conflict field to save conflict chains.\n+\t(plugin_file_info): Add conflicts symtab.\n+\t(parse_table_entry): Initialize aux->next_conflict.\n+\t(process_symtab): Increment found.\n+\t(dump_symtab): Add.\n+\t(finish_conflict_resolution): Add.\n+\t(free_symtab): Add.\n+\t(write_resolution): Remove symbols loop and move into\n+\tdump_symtab. Call dump_symtab for main symbol and conflicts table.\n+\tCall free_symtab to free conflicts table.\n+\t(SWAP): Add.\n+\t(eq_sym): Add.\n+\t(hash_sym): Add.\n+\t(symbol_strength): Add.\n+\t(resolve_conflicts): Add.\n+\t(claim_file_handler): Add n variable. Check return value of\n+\tprocess_symtab. Call resolve_conflicts.\n+\n 2010-07-27  Andi Kleen <ak@linux.intel.com>\n \n \t* lto-plugin.c (translate): Remove debug fprintf."}, {"sha": "dc51b48bc5ace84878a653d73e466ca4fd42d2eb", "filename": "lto-plugin/lto-plugin.c", "status": "modified", "additions": 221, "deletions": 9, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2c57fe97ecc24da4c947cd89623d54ba392c66c/lto-plugin%2Flto-plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2c57fe97ecc24da4c947cd89623d54ba392c66c/lto-plugin%2Flto-plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2Flto-plugin.c?ref=d2c57fe97ecc24da4c947cd89623d54ba392c66c", "patch": "@@ -44,6 +44,7 @@ along with this program; see the file COPYING3.  If not see\n #include <sys/wait.h>\n #include <stdbool.h>\n #include <libiberty.h>\n+#include <hashtab.h>\n \n /* The presence of gelf.h is checked by the toplevel configure script.  */\n #include <gelf.h>\n@@ -59,6 +60,7 @@ struct sym_aux\n {\n   uint32_t slot;\n   unsigned id;\n+  unsigned next_conflict;\n };\n \n struct plugin_symtab\n@@ -76,6 +78,7 @@ struct plugin_file_info\n   char *name;\n   void *handle;\n   struct plugin_symtab symtab;\n+  struct plugin_symtab conflicts;\n };\n \n \n@@ -183,6 +186,8 @@ parse_table_entry (char *p, struct ld_plugin_symbol *entry,\n \n   entry->resolution = LDPR_UNKNOWN;\n \n+  aux->next_conflict = -1;\n+\n   return p;\n }\n \n@@ -246,7 +251,7 @@ process_symtab (Elf *elf, struct plugin_symtab *out)\n \t  if (s)\n \t      sscanf (s, \".%x\", &out->id);\n \t  translate (elf_getdata (section, NULL), out);\n-\t  found = 1;\n+\t  found++;\n \t}\n     }\n   return found;\n@@ -303,6 +308,82 @@ free_2 (void)\n   arguments_file_name = NULL;\n }\n \n+/* Dump SYMTAB to resolution file F. */\n+\n+static void\n+dump_symtab (FILE *f, struct plugin_symtab *symtab)\n+{\n+  unsigned j;\n+\n+  for (j = 0; j < symtab->nsyms; j++)\n+    {\n+      uint32_t slot = symtab->aux[j].slot;\n+      unsigned int resolution = symtab->syms[j].resolution;\n+      \n+      assert (resolution != LDPR_UNKNOWN);\n+\n+      fprintf (f, \"%d %x %s %s\\n\", slot, symtab->aux[j].id,\n+\t       lto_resolution_str[resolution], \n+\t       symtab->syms[j].name);\n+    }\n+}\n+\n+/* Finish the conflicts' resolution information after the linker resolved\n+   the original symbols */\n+\n+static void\n+finish_conflict_resolution (struct plugin_symtab *symtab, \n+\t\t\t   struct plugin_symtab *conflicts)\n+{\n+  int i, j;\n+\n+  if (conflicts->nsyms == 0)\n+    return;\n+\n+  for (i = 0; i < symtab->nsyms; i++)\n+    { \n+      int resolution;\n+\n+      if (symtab->aux[i].next_conflict == -1)\n+\tcontinue;\n+\n+      switch (symtab->syms[i].def) \n+\t{\n+\tcase LDPK_DEF:\n+\tcase LDPK_COMMON: /* ??? */\n+\t  resolution = LDPR_RESOLVED_IR; \n+\t  break;\n+\tcase LDPK_WEAKDEF:\n+\t  resolution = LDPR_PREEMPTED_IR;\n+\t  break;\n+\tcase LDPK_UNDEF:\n+\tcase LDPK_WEAKUNDEF:\n+\t  resolution = symtab->syms[i].resolution;\n+\t  break;\n+\tdefault:\n+\t  assert (0);\n+\t}\n+\n+      assert (resolution != LDPR_UNKNOWN);\n+\n+      for (j = symtab->aux[i].next_conflict; \n+\t   j != -1; \n+\t   j = conflicts->aux[j].next_conflict)\n+\tconflicts->syms[j].resolution = resolution;\n+    }\n+}\n+\n+/* Free symbol table SYMTAB. */\n+\n+static void\n+free_symtab (struct plugin_symtab *symtab)\n+{\n+  free (symtab->syms);\n+  symtab->syms = NULL;\n+  free (symtab->aux);\n+  symtab->aux = NULL;\n+}\n+\n /*  Writes the relocations to disk. */\n \n static void\n@@ -322,18 +403,17 @@ write_resolution (void)\n       struct plugin_file_info *info = &claimed_files[i];\n       struct plugin_symtab *symtab = &info->symtab;\n       struct ld_plugin_symbol *syms = symtab->syms;\n-      unsigned j;\n \n       get_symbols (info->handle, symtab->nsyms, syms);\n \n-      fprintf (f, \"%s %d\\n\", info->name, info->symtab.nsyms);\n+      finish_conflict_resolution (symtab, &info->conflicts);\n \n-      for (j = 0; j < info->symtab.nsyms; j++)\n+      fprintf (f, \"%s %d\\n\", info->name, symtab->nsyms + info->conflicts.nsyms);\n+      dump_symtab (f, symtab);\n+      if (info->conflicts.nsyms)\n \t{\n-\t  uint32_t slot = symtab->aux[j].slot;\n-\t  unsigned int resolution = syms[j].resolution;\n-\t  fprintf (f, \"%d %x %s %s\\n\", slot, symtab->aux[j].id,\n-\t\t   lto_resolution_str[resolution], syms[j].name);\n+\t  dump_symtab (f, &info->conflicts);\n+\t  free_symtab (&info->conflicts);\n \t}\n     }\n   fclose (f);\n@@ -550,6 +630,130 @@ cleanup_handler (void)\n   return LDPS_OK;\n }\n \n+#define SWAP(type, a, b) \\\n+  do { type tmp_; tmp_ = (a); (a) = (b); (b) = tmp_; } while(0)\n+\n+/* Compare two hash table entries */\n+\n+static int eq_sym (const void *a, const void *b)\n+{\n+  const struct ld_plugin_symbol *as = (const struct ld_plugin_symbol *)a;\n+  const struct ld_plugin_symbol *bs = (const struct ld_plugin_symbol *)b;\n+\n+  return !strcmp (as->name, bs->name);\n+}\n+\n+/* Hash a symbol */\n+\n+static hashval_t hash_sym (const void *a)\n+{\n+  const struct ld_plugin_symbol *as = (const struct ld_plugin_symbol *)a;\n+\n+  return htab_hash_string (as->name);\n+}\n+\n+/* Determine how strong a symbol is */\n+\n+static int symbol_strength (struct ld_plugin_symbol *s)\n+{\n+  switch (s->def) \n+    { \n+    case LDPK_UNDEF:\n+    case LDPK_WEAKUNDEF:\n+      return 0;\n+    case LDPK_WEAKDEF:\n+      return 1;\n+    default:\n+      return 2;\n+    }\n+}\n+\n+/* In the ld -r case we can get dups in the LTO symbol tables, where\n+   the same symbol can have different resolutions (e.g. undefined and defined).\n+\n+   We have to keep that in the LTO symbol tables, but the dups confuse\n+   gold and then finally gcc by supplying incorrect resolutions.\n+\n+   Problem is that the main gold symbol table doesn't know about subids\n+   and does not distingush the same symbols in different states.\n+\n+   So we drop duplicates from the linker visible symbol table\n+   and keep them in a private table. Then later do own symbol\n+   resolution for the duplicated based on the results for the\n+   originals.\n+\n+   Then when writing out the resolution file readd the dropped symbols.\n+   \n+   XXX how to handle common? */\n+\n+static void\n+resolve_conflicts (struct plugin_symtab *t, struct plugin_symtab *conflicts)\n+{\n+  htab_t symtab = htab_create (t->nsyms, hash_sym, eq_sym, NULL);\n+  int i;\n+  int out;\n+  int outlen;\n+\n+  outlen = t->nsyms;\n+  conflicts->syms = xmalloc (sizeof (struct ld_plugin_symbol) * outlen);\n+  conflicts->aux = xmalloc (sizeof (struct sym_aux) * outlen);\n+\n+  /* Move all duplicate symbols into the auxillary conflicts table. */\n+  out = 0;\n+  for (i = 0; i < t->nsyms; i++) \n+    {\n+      struct ld_plugin_symbol *s = &t->syms[i];\n+      struct sym_aux *aux = &t->aux[i];\n+      void **slot;\n+\n+      slot = htab_find_slot (symtab, s, INSERT);\n+      if (*slot != NULL)\n+\t{\n+\t  int cnf;\n+\t  struct ld_plugin_symbol *orig = (struct ld_plugin_symbol *)*slot;\n+\t  struct sym_aux *orig_aux = &t->aux[orig - t->syms];\n+\n+\t  /* Always let the linker resolve the strongest symbol */\n+\t  if (symbol_strength (orig) < symbol_strength (s)) \n+\t    {\n+\t      SWAP (struct ld_plugin_symbol, *orig, *s);\n+\t      SWAP (uint32_t, orig_aux->slot, aux->slot);\n+\t      SWAP (unsigned, orig_aux->id, aux->id);\n+\t      /* Don't swap conflict chain pointer */\n+\t    } \n+\n+\t  /* Move current symbol into the conflicts table */\n+\t  cnf = conflicts->nsyms++;\n+\t  conflicts->syms[cnf] = *s;\n+\t  conflicts->aux[cnf] = *aux;\n+\t  aux = &conflicts->aux[cnf];\n+\n+\t  /* Update conflicts chain of the original symbol */\n+\t  aux->next_conflict = orig_aux->next_conflict;\n+\t  orig_aux->next_conflict = cnf;\n+\n+\t  continue;\n+\t}\n+\n+      /* Remove previous duplicates in the main table */\n+      if (out < i)\n+\t{\n+\t  t->syms[out] = *s;\n+\t  t->aux[out] = *aux;\n+\t}\n+\n+      /* Put original into the hash table */\n+      *slot = &t->syms[out];\n+      out++;\n+    }\n+\n+  assert (conflicts->nsyms <= outlen);\n+  assert (conflicts->nsyms + out == t->nsyms);\n+  \n+  t->nsyms = out;\n+  htab_delete (symtab);\n+}\n+\n /* Callback used by gold to check if the plugin will claim FILE. Writes\n    the result in CLAIMED. */\n \n@@ -559,6 +763,7 @@ claim_file_handler (const struct ld_plugin_input_file *file, int *claimed)\n   enum ld_plugin_status status;\n   Elf *elf;\n   struct plugin_file_info lto_file;\n+  int n;\n \n   memset (&lto_file, 0, sizeof (struct plugin_file_info));\n \n@@ -597,9 +802,16 @@ claim_file_handler (const struct ld_plugin_input_file *file, int *claimed)\n \n   *claimed = 0;\n \n-  if (!elf || !process_symtab (elf, &lto_file.symtab))\n+  if (!elf)\n+    goto err;\n+\n+  n = process_symtab (elf, &lto_file.symtab);\n+  if (n == 0)\n     goto err;\n \n+  if (n > 1)\n+    resolve_conflicts (&lto_file.symtab, &lto_file.conflicts);\n+\n   status = add_symbols (file->handle, lto_file.symtab.nsyms,\n \t\t\tlto_file.symtab.syms);\n   check (status == LDPS_OK, LDPL_FATAL, \"could not add symbols\");"}]}