{"sha": "3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NhNzVjZDU1MDMwYTUzYTg1OGJkYmU5YWJhNmQ4N2Y2YjFlOTBiOA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-11-05T13:54:57Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-11-05T13:54:57Z"}, "message": "Libsanitizer: merge from trunk with merge.sh.\n\n2019-11-05  Martin Liska  <mliska@suse.cz>\n\n\t* all source files: Merge from upstream r375507.\n\nFrom-SVN: r277834", "tree": {"sha": "c3eb5c5658e168b819d23dd20aa46d614089c649", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3eb5c5658e168b819d23dd20aa46d614089c649"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9bae89924afc811bd10e249856bf78dd19f20df2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bae89924afc811bd10e249856bf78dd19f20df2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bae89924afc811bd10e249856bf78dd19f20df2"}], "stats": {"total": 4974, "additions": 2758, "deletions": 2216}, "files": [{"sha": "3a926394b733c2ea2f315d0d6bf6471a434bbb7a", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -1,3 +1,7 @@\n+2019-11-05  Martin Liska  <mliska@suse.cz>\n+\n+\t* all source files: Merge from upstream r375507.\n+\n 2019-10-22  Tamar Christina  <tamar.christina@arm.com>\n \n \tPR sanitizer/92154"}, {"sha": "b7bf2529910987419ff3980c0415e1223a8b0abe", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -1,4 +1,4 @@\n-368656\n+375507\n \n The first line of this file holds the svn revision number of the\n last merge done from the master library sources."}, {"sha": "c9e9f5a93d0d123c48bb0e8b62a2218813ca3e69", "filename": "libsanitizer/asan/asan_allocator.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_allocator.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_allocator.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -1075,7 +1075,7 @@ IgnoreObjectResult IgnoreObjectLocked(const void *p) {\n }  // namespace __lsan\n \n // ---------------------- Interface ---------------- {{{1\n-using namespace __asan;  // NOLINT\n+using namespace __asan;\n \n // ASan allocator doesn't reserve extra bytes, so normally we would\n // just return \"size\". We don't want to expose our redzone sizes, etc here."}, {"sha": "c01360b52fc948342dc5d2236b36b5865a34033b", "filename": "libsanitizer/asan/asan_debugging.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_debugging.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_debugging.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_debugging.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -25,7 +25,7 @@ using namespace __asan;\n \n static void FindInfoForStackVar(uptr addr, const char *frame_descr, uptr offset,\n                                 char *name, uptr name_size,\n-                                uptr &region_address, uptr &region_size) {\n+                                uptr *region_address, uptr *region_size) {\n   InternalMmapVector<StackVarDescr> vars;\n   vars.reserve(16);\n   if (!ParseFrameDescription(frame_descr, &vars)) {\n@@ -39,8 +39,8 @@ static void FindInfoForStackVar(uptr addr, const char *frame_descr, uptr offset,\n       // the whole name and then terminate with '\\0'.\n       internal_strlcpy(name, vars[i].name_pos,\n                        Min(name_size, vars[i].name_len + 1));\n-      region_address = addr - (offset - vars[i].beg);\n-      region_size = vars[i].size;\n+      *region_address = addr - (offset - vars[i].beg);\n+      *region_size = vars[i].size;\n       return;\n     }\n   }\n@@ -108,7 +108,7 @@ const char *__asan_locate_address(uptr addr, char *name, uptr name_size,\n       // region_{address,size} are already 0\n     } else {\n       FindInfoForStackVar(addr, stack->frame_descr, stack->offset, name,\n-                          name_size, region_address, region_size);\n+                          name_size, &region_address, &region_size);\n     }\n   } else if (auto global = descr.AsGlobal()) {\n     region_kind = \"global\";"}, {"sha": "ee0e2061559e0641a57b5d7f939b3982fcdf5019", "filename": "libsanitizer/asan/asan_descriptions.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_descriptions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_descriptions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_descriptions.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -203,7 +203,7 @@ class AddressDescription {\n   AddressDescription() = default;\n   // shouldLockThreadRegistry allows us to skip locking if we're sure we already\n   // have done it.\n-  AddressDescription(uptr addr, bool shouldLockThreadRegistry = true)\n+  explicit AddressDescription(uptr addr, bool shouldLockThreadRegistry = true)\n       : AddressDescription(addr, 1, shouldLockThreadRegistry) {}\n   AddressDescription(uptr addr, uptr access_size,\n                      bool shouldLockThreadRegistry = true);"}, {"sha": "541c6e0353b57ac08a7147c658eed11f94540335", "filename": "libsanitizer/asan/asan_errors.cpp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_errors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_errors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_errors.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -35,7 +35,8 @@ static void OnStackUnwind(const SignalContext &sig,\n   // corresponding code in the sanitizer_common and we use this callback to\n   // print it.\n   static_cast<const ScarinessScoreBase *>(callback_context)->Print();\n-  stack->Unwind(sig.pc, sig.bp, sig.context, fast);\n+  stack->Unwind(StackTrace::GetNextInstructionPc(sig.pc), sig.bp, sig.context,\n+                fast);\n }\n \n void ErrorDeadlySignal::Print() {\n@@ -244,7 +245,7 @@ void ErrorInvalidPosixMemalignAlignment::Print() {\n       \"ERROR: AddressSanitizer: invalid alignment requested in posix_memalign: \"\n       \"%zd, alignment must be a power of two and a multiple of sizeof(void*) \"\n       \"== %zd (thread %s)\\n\",\n-      alignment, sizeof(void*), AsanThreadIdAndName(tid).c_str());  // NOLINT\n+      alignment, sizeof(void *), AsanThreadIdAndName(tid).c_str());\n   Printf(\"%s\", d.Default());\n   stack->Print();\n   PrintHintAllocatorCannotReturnNull();"}, {"sha": "a7fda2fd9f5d6bca1dbe4bdae9d35eda7528debd", "filename": "libsanitizer/asan/asan_errors.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_errors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_errors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_errors.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -48,7 +48,8 @@ struct ErrorDeadlySignal : ErrorBase {\n       scariness.Scare(10, \"stack-overflow\");\n     } else if (!signal.is_memory_access) {\n       scariness.Scare(10, \"signal\");\n-    } else if (signal.addr < GetPageSizeCached()) {\n+    } else if (signal.is_true_faulting_addr &&\n+               signal.addr < GetPageSizeCached()) {\n       scariness.Scare(10, \"null-deref\");\n     } else if (signal.addr == signal.pc) {\n       scariness.Scare(60, \"wild-jump\");"}, {"sha": "43c70dbca56ba5440a69fbc907b8b65b64a3d7f1", "filename": "libsanitizer/asan/asan_flags.inc", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.inc?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -139,10 +139,10 @@ ASAN_FLAG(\n     \"If >= 2, detect operations like <, <=, >, >= and - on invalid pointer \"\n     \"pairs (e.g. when pointers belong to different objects); \"\n     \"If == 1, detect invalid operations only when both pointers are non-null.\")\n-ASAN_FLAG(\n-    bool, detect_container_overflow, true,\n-    \"If true, honor the container overflow annotations. See \"\n-    \"https://github.com/google/sanitizers/wiki/AddressSanitizerContainerOverflow\")\n+ASAN_FLAG(bool, detect_container_overflow, true,\n+          \"If true, honor the container overflow annotations. See \"\n+          \"https://github.com/google/sanitizers/wiki/\"\n+          \"AddressSanitizerContainerOverflow\")\n ASAN_FLAG(int, detect_odr_violation, 2,\n           \"If >=2, detect violation of One-Definition-Rule (ODR); \"\n           \"If ==1, detect ODR-violation only if the two variables \"\n@@ -158,5 +158,6 @@ ASAN_FLAG(bool, allocator_frees_and_returns_null_on_realloc_zero, true,\n ASAN_FLAG(bool, verify_asan_link_order, true,\n           \"Check position of ASan runtime in library list (needs to be disabled\"\n           \" when other library has to be preloaded system-wide)\")\n-ASAN_FLAG(bool, windows_hook_rtl_allocators, false,\n-          \"(Windows only) enable hooking of Rtl(Allocate|Free|Size|ReAllocate)Heap.\")\n+ASAN_FLAG(\n+    bool, windows_hook_rtl_allocators, false,\n+    \"(Windows only) enable hooking of Rtl(Allocate|Free|Size|ReAllocate)Heap.\")"}, {"sha": "9d7dbc6f264cea7b80a71a91da37cfa0cfbbd0db", "filename": "libsanitizer/asan/asan_globals.cpp", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_globals.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_globals.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -154,6 +154,23 @@ static void CheckODRViolationViaIndicator(const Global *g) {\n   }\n }\n \n+// Check ODR violation for given global G by checking if it's already poisoned.\n+// We use this method in case compiler doesn't use private aliases for global\n+// variables.\n+static void CheckODRViolationViaPoisoning(const Global *g) {\n+  if (__asan_region_is_poisoned(g->beg, g->size_with_redzone)) {\n+    // This check may not be enough: if the first global is much larger\n+    // the entire redzone of the second global may be within the first global.\n+    for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n+      if (g->beg == l->g->beg &&\n+          (flags()->detect_odr_violation >= 2 || g->size != l->g->size) &&\n+          !IsODRViolationSuppressed(g->name))\n+        ReportODRViolation(g, FindRegistrationSite(g),\n+                           l->g, FindRegistrationSite(l->g));\n+    }\n+  }\n+}\n+\n // Clang provides two different ways for global variables protection:\n // it can poison the global itself or its private alias. In former\n // case we may poison same symbol multiple times, that can help us to\n@@ -199,6 +216,8 @@ static void RegisterGlobal(const Global *g) {\n     // where two globals with the same name are defined in different modules.\n     if (UseODRIndicator(g))\n       CheckODRViolationViaIndicator(g);\n+    else\n+      CheckODRViolationViaPoisoning(g);\n   }\n   if (CanPoisonMemory())\n     PoisonRedZones(*g);\n@@ -208,8 +227,7 @@ static void RegisterGlobal(const Global *g) {\n   list_of_all_globals = l;\n   if (g->has_dynamic_init) {\n     if (!dynamic_init_globals) {\n-      dynamic_init_globals =\n-          new (allocator_for_globals) VectorOfGlobals;  // NOLINT\n+      dynamic_init_globals = new (allocator_for_globals) VectorOfGlobals;\n       dynamic_init_globals->reserve(kDynamicInitGlobalsInitialCapacity);\n     }\n     DynInitGlobal dyn_global = { *g, false };\n@@ -296,8 +314,7 @@ void PrintGlobalLocation(InternalScopedString *str, const __asan_global &g) {\n } // namespace __asan\n \n // ---------------------- Interface ---------------- {{{1\n-using namespace __asan;  // NOLINT\n-\n+using namespace __asan;\n \n // Apply __asan_register_globals to all globals found in the same loaded\n // executable or shared library as `flag'. The flag tracks whether globals have\n@@ -345,7 +362,7 @@ void __asan_register_globals(__asan_global *globals, uptr n) {\n   BlockingMutexLock lock(&mu_for_globals);\n   if (!global_registration_site_vector) {\n     global_registration_site_vector =\n-        new (allocator_for_globals) GlobalRegistrationSiteVector;  // NOLINT\n+        new (allocator_for_globals) GlobalRegistrationSiteVector;\n     global_registration_site_vector->reserve(128);\n   }\n   GlobalRegistrationSite site = {stack_id, &globals[0], &globals[n - 1]};"}, {"sha": "19af88ab12b40ab2dbe6b572a3119b79711cb2e6", "filename": "libsanitizer/asan/asan_globals_win.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_globals_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_globals_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals_win.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -15,8 +15,8 @@\n \n namespace __asan {\n \n-#pragma section(\".ASAN$GA\", read, write)  // NOLINT\n-#pragma section(\".ASAN$GZ\", read, write)  // NOLINT\n+#pragma section(\".ASAN$GA\", read, write)\n+#pragma section(\".ASAN$GZ\", read, write)\n extern \"C\" __declspec(allocate(\".ASAN$GA\"))\n     ALIGNED(sizeof(__asan_global)) __asan_global __asan_globals_start = {};\n extern \"C\" __declspec(allocate(\".ASAN$GZ\"))\n@@ -49,8 +49,8 @@ static void unregister_dso_globals() {\n }\n \n // Register globals\n-#pragma section(\".CRT$XCU\", long, read)  // NOLINT\n-#pragma section(\".CRT$XTX\", long, read)  // NOLINT\n+#pragma section(\".CRT$XCU\", long, read)\n+#pragma section(\".CRT$XTX\", long, read)\n extern \"C\" __declspec(allocate(\".CRT$XCU\"))\n void (*const __asan_dso_reg_hook)() = &register_dso_globals;\n extern \"C\" __declspec(allocate(\".CRT$XTX\"))"}, {"sha": "b19cf25c7cd00ddede212ee932b4f8d0065814c9", "filename": "libsanitizer/asan/asan_interceptors.cpp", "status": "modified", "additions": 84, "deletions": 37, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_interceptors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_interceptors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -79,7 +79,7 @@ int OnExit() {\n } // namespace __asan\n \n // ---------------------- Wrappers ---------------- {{{1\n-using namespace __asan;  // NOLINT\n+using namespace __asan;\n \n DECLARE_REAL_AND_INTERCEPTOR(void *, malloc, uptr)\n DECLARE_REAL_AND_INTERCEPTOR(void, free, void *)\n@@ -164,6 +164,11 @@ DECLARE_REAL_AND_INTERCEPTOR(void, free, void *)\n     ASAN_MEMSET_IMPL(ctx, block, c, size);                  \\\n   } while (false)\n \n+#if CAN_SANITIZE_LEAKS\n+#define COMMON_INTERCEPTOR_STRERROR()                       \\\n+  __lsan::ScopedInterceptorDisabler disabler\n+#endif\n+\n #include \"sanitizer_common/sanitizer_common_interceptors.inc\"\n #include \"sanitizer_common/sanitizer_signal_interceptors.inc\"\n \n@@ -373,26 +378,26 @@ DEFINE_REAL(char*, index, const char *string, int c)\n \n // For both strcat() and strncat() we need to check the validity of |to|\n // argument irrespective of the |from| length.\n-INTERCEPTOR(char*, strcat, char *to, const char *from) {  // NOLINT\n-  void *ctx;\n-  ASAN_INTERCEPTOR_ENTER(ctx, strcat);  // NOLINT\n-  ENSURE_ASAN_INITED();\n-  if (flags()->replace_str) {\n-    uptr from_length = REAL(strlen)(from);\n-    ASAN_READ_RANGE(ctx, from, from_length + 1);\n-    uptr to_length = REAL(strlen)(to);\n-    ASAN_READ_STRING_OF_LEN(ctx, to, to_length, to_length);\n-    ASAN_WRITE_RANGE(ctx, to + to_length, from_length + 1);\n-    // If the copying actually happens, the |from| string should not overlap\n-    // with the resulting string starting at |to|, which has a length of\n-    // to_length + from_length + 1.\n-    if (from_length > 0) {\n-      CHECK_RANGES_OVERLAP(\"strcat\", to, from_length + to_length + 1,\n-                           from, from_length + 1);\n+  INTERCEPTOR(char *, strcat, char *to, const char *from) {\n+    void *ctx;\n+    ASAN_INTERCEPTOR_ENTER(ctx, strcat);\n+    ENSURE_ASAN_INITED();\n+    if (flags()->replace_str) {\n+      uptr from_length = REAL(strlen)(from);\n+      ASAN_READ_RANGE(ctx, from, from_length + 1);\n+      uptr to_length = REAL(strlen)(to);\n+      ASAN_READ_STRING_OF_LEN(ctx, to, to_length, to_length);\n+      ASAN_WRITE_RANGE(ctx, to + to_length, from_length + 1);\n+      // If the copying actually happens, the |from| string should not overlap\n+      // with the resulting string starting at |to|, which has a length of\n+      // to_length + from_length + 1.\n+      if (from_length > 0) {\n+        CHECK_RANGES_OVERLAP(\"strcat\", to, from_length + to_length + 1, from,\n+                             from_length + 1);\n+      }\n     }\n+    return REAL(strcat)(to, from);\n   }\n-  return REAL(strcat)(to, from);  // NOLINT\n-}\n \n INTERCEPTOR(char*, strncat, char *to, const char *from, uptr size) {\n   void *ctx;\n@@ -413,16 +418,17 @@ INTERCEPTOR(char*, strncat, char *to, const char *from, uptr size) {\n   return REAL(strncat)(to, from, size);\n }\n \n-INTERCEPTOR(char*, strcpy, char *to, const char *from) {  // NOLINT\n+INTERCEPTOR(char *, strcpy, char *to, const char *from) {\n   void *ctx;\n-  ASAN_INTERCEPTOR_ENTER(ctx, strcpy);  // NOLINT\n+  ASAN_INTERCEPTOR_ENTER(ctx, strcpy);\n #if SANITIZER_MAC\n-  if (UNLIKELY(!asan_inited)) return REAL(strcpy)(to, from);  // NOLINT\n+  if (UNLIKELY(!asan_inited))\n+    return REAL(strcpy)(to, from);\n #endif\n   // strcpy is called from malloc_default_purgeable_zone()\n   // in __asan::ReplaceSystemAlloc() on Mac.\n   if (asan_init_is_running) {\n-    return REAL(strcpy)(to, from);  // NOLINT\n+    return REAL(strcpy)(to, from);\n   }\n   ENSURE_ASAN_INITED();\n   if (flags()->replace_str) {\n@@ -431,7 +437,7 @@ INTERCEPTOR(char*, strcpy, char *to, const char *from) {  // NOLINT\n     ASAN_READ_RANGE(ctx, from, from_size);\n     ASAN_WRITE_RANGE(ctx, to, from_size);\n   }\n-  return REAL(strcpy)(to, from);  // NOLINT\n+  return REAL(strcpy)(to, from);\n }\n \n INTERCEPTOR(char*, strdup, const char *s) {\n@@ -479,16 +485,15 @@ INTERCEPTOR(char*, strncpy, char *to, const char *from, uptr size) {\n   return REAL(strncpy)(to, from, size);\n }\n \n-INTERCEPTOR(long, strtol, const char *nptr,  // NOLINT\n-            char **endptr, int base) {\n+INTERCEPTOR(long, strtol, const char *nptr, char **endptr, int base) {\n   void *ctx;\n   ASAN_INTERCEPTOR_ENTER(ctx, strtol);\n   ENSURE_ASAN_INITED();\n   if (!flags()->replace_str) {\n     return REAL(strtol)(nptr, endptr, base);\n   }\n   char *real_endptr;\n-  long result = REAL(strtol)(nptr, &real_endptr, base);  // NOLINT\n+  long result = REAL(strtol)(nptr, &real_endptr, base);\n   StrtolFixAndCheck(ctx, nptr, endptr, real_endptr, base);\n   return result;\n }\n@@ -514,7 +519,7 @@ INTERCEPTOR(int, atoi, const char *nptr) {\n   return result;\n }\n \n-INTERCEPTOR(long, atol, const char *nptr) {  // NOLINT\n+INTERCEPTOR(long, atol, const char *nptr) {\n   void *ctx;\n   ASAN_INTERCEPTOR_ENTER(ctx, atol);\n #if SANITIZER_MAC\n@@ -525,60 +530,94 @@ INTERCEPTOR(long, atol, const char *nptr) {  // NOLINT\n     return REAL(atol)(nptr);\n   }\n   char *real_endptr;\n-  long result = REAL(strtol)(nptr, &real_endptr, 10);  // NOLINT\n+  long result = REAL(strtol)(nptr, &real_endptr, 10);\n   FixRealStrtolEndptr(nptr, &real_endptr);\n   ASAN_READ_STRING(ctx, nptr, (real_endptr - nptr) + 1);\n   return result;\n }\n \n #if ASAN_INTERCEPT_ATOLL_AND_STRTOLL\n-INTERCEPTOR(long long, strtoll, const char *nptr,  // NOLINT\n-            char **endptr, int base) {\n+INTERCEPTOR(long long, strtoll, const char *nptr, char **endptr, int base) {\n   void *ctx;\n   ASAN_INTERCEPTOR_ENTER(ctx, strtoll);\n   ENSURE_ASAN_INITED();\n   if (!flags()->replace_str) {\n     return REAL(strtoll)(nptr, endptr, base);\n   }\n   char *real_endptr;\n-  long long result = REAL(strtoll)(nptr, &real_endptr, base);  // NOLINT\n+  long long result = REAL(strtoll)(nptr, &real_endptr, base);\n   StrtolFixAndCheck(ctx, nptr, endptr, real_endptr, base);\n   return result;\n }\n \n-INTERCEPTOR(long long, atoll, const char *nptr) {  // NOLINT\n+INTERCEPTOR(long long, atoll, const char *nptr) {\n   void *ctx;\n   ASAN_INTERCEPTOR_ENTER(ctx, atoll);\n   ENSURE_ASAN_INITED();\n   if (!flags()->replace_str) {\n     return REAL(atoll)(nptr);\n   }\n   char *real_endptr;\n-  long long result = REAL(strtoll)(nptr, &real_endptr, 10);  // NOLINT\n+  long long result = REAL(strtoll)(nptr, &real_endptr, 10);\n   FixRealStrtolEndptr(nptr, &real_endptr);\n   ASAN_READ_STRING(ctx, nptr, (real_endptr - nptr) + 1);\n   return result;\n }\n #endif  // ASAN_INTERCEPT_ATOLL_AND_STRTOLL\n \n-#if ASAN_INTERCEPT___CXA_ATEXIT\n+#if ASAN_INTERCEPT___CXA_ATEXIT || ASAN_INTERCEPT_ATEXIT\n static void AtCxaAtexit(void *unused) {\n   (void)unused;\n   StopInitOrderChecking();\n }\n+#endif\n \n+#if ASAN_INTERCEPT___CXA_ATEXIT\n INTERCEPTOR(int, __cxa_atexit, void (*func)(void *), void *arg,\n             void *dso_handle) {\n #if SANITIZER_MAC\n   if (UNLIKELY(!asan_inited)) return REAL(__cxa_atexit)(func, arg, dso_handle);\n #endif\n   ENSURE_ASAN_INITED();\n+#if CAN_SANITIZE_LEAKS\n+  __lsan::ScopedInterceptorDisabler disabler;\n+#endif\n   int res = REAL(__cxa_atexit)(func, arg, dso_handle);\n   REAL(__cxa_atexit)(AtCxaAtexit, nullptr, nullptr);\n   return res;\n }\n #endif  // ASAN_INTERCEPT___CXA_ATEXIT\n \n+#if ASAN_INTERCEPT_ATEXIT\n+INTERCEPTOR(int, atexit, void (*func)()) {\n+  ENSURE_ASAN_INITED();\n+#if CAN_SANITIZE_LEAKS\n+  __lsan::ScopedInterceptorDisabler disabler;\n+#endif\n+  // Avoid calling real atexit as it is unrechable on at least on Linux.\n+  int res = REAL(__cxa_atexit)((void (*)(void *a))func, nullptr, nullptr);\n+  REAL(__cxa_atexit)(AtCxaAtexit, nullptr, nullptr);\n+  return res;\n+}\n+#endif\n+\n+#if ASAN_INTERCEPT_PTHREAD_ATFORK\n+extern \"C\" {\n+extern int _pthread_atfork(void (*prepare)(), void (*parent)(),\n+                           void (*child)());\n+};\n+\n+INTERCEPTOR(int, pthread_atfork, void (*prepare)(), void (*parent)(),\n+            void (*child)()) {\n+#if CAN_SANITIZE_LEAKS\n+  __lsan::ScopedInterceptorDisabler disabler;\n+#endif\n+  // REAL(pthread_atfork) cannot be called due to symbol indirections at least\n+  // on NetBSD\n+  return _pthread_atfork(prepare, parent, child);\n+}\n+#endif\n+\n #if ASAN_INTERCEPT_VFORK\n DEFINE_REAL(int, vfork)\n DECLARE_EXTERN_INTERCEPTOR_AND_WRAPPER(int, vfork)\n@@ -594,8 +633,8 @@ void InitializeAsanInterceptors() {\n   InitializeSignalInterceptors();\n \n   // Intercept str* functions.\n-  ASAN_INTERCEPT_FUNC(strcat);  // NOLINT\n-  ASAN_INTERCEPT_FUNC(strcpy);  // NOLINT\n+  ASAN_INTERCEPT_FUNC(strcat);\n+  ASAN_INTERCEPT_FUNC(strcpy);\n   ASAN_INTERCEPT_FUNC(strncat);\n   ASAN_INTERCEPT_FUNC(strncpy);\n   ASAN_INTERCEPT_FUNC(strdup);\n@@ -661,6 +700,14 @@ void InitializeAsanInterceptors() {\n   ASAN_INTERCEPT_FUNC(__cxa_atexit);\n #endif\n \n+#if ASAN_INTERCEPT_ATEXIT\n+  ASAN_INTERCEPT_FUNC(atexit);\n+#endif\n+\n+#if ASAN_INTERCEPT_PTHREAD_ATFORK\n+  ASAN_INTERCEPT_FUNC(pthread_atfork);\n+#endif\n+\n #if ASAN_INTERCEPT_VFORK\n   ASAN_INTERCEPT_FUNC(vfork);\n #endif"}, {"sha": "344a64bd83d330553bca41f066b004092b6632df", "filename": "libsanitizer/asan/asan_interceptors.h", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -80,12 +80,7 @@ void InitializePlatformInterceptors();\n #if ASAN_HAS_EXCEPTIONS && !SANITIZER_WINDOWS && !SANITIZER_SOLARIS && \\\n     !SANITIZER_NETBSD\n # define ASAN_INTERCEPT___CXA_THROW 1\n-# if ! defined(ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION) \\\n-     || ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n-# else\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 0\n-# endif\n+# define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n # if defined(_GLIBCXX_SJLJ_EXCEPTIONS) || (SANITIZER_IOS && defined(__arm__))\n #  define ASAN_INTERCEPT__UNWIND_SJLJ_RAISEEXCEPTION 1\n # else\n@@ -104,6 +99,12 @@ void InitializePlatformInterceptors();\n # define ASAN_INTERCEPT___CXA_ATEXIT 0\n #endif\n \n+#if SANITIZER_NETBSD\n+# define ASAN_INTERCEPT_ATEXIT 1\n+#else\n+# define ASAN_INTERCEPT_ATEXIT 0\n+#endif\n+\n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n # define ASAN_INTERCEPT___STRDUP 1\n #else\n@@ -117,6 +118,12 @@ void InitializePlatformInterceptors();\n # define ASAN_INTERCEPT_VFORK 0\n #endif\n \n+#if SANITIZER_NETBSD\n+# define ASAN_INTERCEPT_PTHREAD_ATFORK 1\n+#else\n+# define ASAN_INTERCEPT_PTHREAD_ATFORK 0\n+#endif\n+\n DECLARE_REAL(int, memcmp, const void *a1, const void *a2, uptr size)\n DECLARE_REAL(char*, strchr, const char *str, int c)\n DECLARE_REAL(SIZE_T, strlen, const char *s)"}, {"sha": "ccdd5159042cf895688d7e23951990504eba6c6c", "filename": "libsanitizer/asan/asan_interceptors_memintrinsics.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -16,7 +16,7 @@\n #include \"asan_stack.h\"\n #include \"asan_suppressions.h\"\n \n-using namespace __asan;  // NOLINT\n+using namespace __asan;\n \n void *__asan_memcpy(void *to, const void *from, uptr size) {\n   ASAN_MEMCPY_IMPL(nullptr, to, from, size);"}, {"sha": "a8d3f5d3473c4018add5a431a63435afc4a37294", "filename": "libsanitizer/asan/asan_mac.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -205,7 +205,7 @@ void asan_dispatch_call_block_and_release(void *block) {\n \n }  // namespace __asan\n \n-using namespace __asan;  // NOLINT\n+using namespace __asan;\n \n // Wrap |ctxt| and |func| into an asan_block_context_t.\n // The caller retains control of the allocated context."}, {"sha": "faa8968a5d009208edd051cf6b7ac7940bffa967", "filename": "libsanitizer/asan/asan_malloc_linux.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_malloc_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_malloc_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_linux.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -27,7 +27,7 @@\n #include \"asan_stack.h\"\n \n // ---------------------- Replacement functions ---------------- {{{1\n-using namespace __asan;  // NOLINT\n+using namespace __asan;\n \n static uptr allocated_for_dlsym;\n static uptr last_dlsym_alloc_size_in_words;"}, {"sha": "13c6f652119bb9ed5e7121e6cd4adb56c63123ff", "filename": "libsanitizer/asan/asan_malloc_win.cpp", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_malloc_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_malloc_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_win.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -54,7 +54,7 @@ size_t WINAPI HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);\n BOOL WINAPI HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);\n }\n \n-using namespace __asan;  // NOLINT\n+using namespace __asan;\n \n // MT: Simply defining functions with the same signature in *.obj\n // files overrides the standard functions in the CRT.\n@@ -528,10 +528,11 @@ void ReplaceSystemMalloc() {\n                                      (uptr)WRAP(RtlAllocateHeap),\n                                      (uptr *)&REAL(RtlAllocateHeap));\n   } else {\n-#define INTERCEPT_UCRT_FUNCTION(func)                                         \\\n-  if (!INTERCEPT_FUNCTION_DLLIMPORT(\"ucrtbase.dll\",                           \\\n-                                    \"api-ms-win-core-heap-l1-1-0.dll\", func)) \\\n-    VPrintf(2, \"Failed to intercept ucrtbase.dll import %s\\n\", #func);\n+#define INTERCEPT_UCRT_FUNCTION(func)                                  \\\n+  if (!INTERCEPT_FUNCTION_DLLIMPORT(                                   \\\n+          \"ucrtbase.dll\", \"api-ms-win-core-heap-l1-1-0.dll\", func)) {  \\\n+    VPrintf(2, \"Failed to intercept ucrtbase.dll import %s\\n\", #func); \\\n+  }\n     INTERCEPT_UCRT_FUNCTION(HeapAlloc);\n     INTERCEPT_UCRT_FUNCTION(HeapFree);\n     INTERCEPT_UCRT_FUNCTION(HeapReAlloc);"}, {"sha": "41fb49ee46d460774a487c638b2c58531b8ac8d0", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -163,7 +163,7 @@ static const u64 kDefaultShort64bitShadowOffset =\n static const u64 kAArch64_ShadowOffset64 = 1ULL << 36;\n static const u64 kMIPS32_ShadowOffset32 = 0x0aaa0000;\n static const u64 kMIPS64_ShadowOffset64 = 1ULL << 37;\n-static const u64 kPPC64_ShadowOffset64 = 1ULL << 41;\n+static const u64 kPPC64_ShadowOffset64 = 1ULL << 44;\n static const u64 kSystemZ_ShadowOffset64 = 1ULL << 52;\n static const u64 kSPARC64_ShadowOffset64 = 1ULL << 43;  // 0x80000000000\n static const u64 kFreeBSD_ShadowOffset32 = 1ULL << 30;  // 0x40000000"}, {"sha": "5dfcc00fd5d1450285902d072571535ca6013929", "filename": "libsanitizer/asan/asan_new_delete.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_new_delete.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_new_delete.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_new_delete.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -48,7 +48,7 @@ COMMENT_EXPORT(\"??_V@YAXPAX@Z\")                   // operator delete[]\n #define CXX_OPERATOR_ATTRIBUTE INTERCEPTOR_ATTRIBUTE\n #endif\n \n-using namespace __asan;  // NOLINT\n+using namespace __asan;\n \n // FreeBSD prior v9.2 have wrong definition of 'size_t'.\n // http://svnweb.freebsd.org/base?view=revision&revision=232261"}, {"sha": "f3fbe684e2cbc75930502fb5b4424df8034b2660", "filename": "libsanitizer/asan/asan_poisoning.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_poisoning.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_poisoning.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -92,7 +92,7 @@ void AsanPoisonOrUnpoisonIntraObjectRedzone(uptr ptr, uptr size, bool poison) {\n }  // namespace __asan\n \n // ---------------------- Interface ---------------- {{{1\n-using namespace __asan;  // NOLINT\n+using namespace __asan;\n \n // Current implementation of __asan_(un)poison_memory_region doesn't check\n // that user program (un)poisons the memory it owns. It poisons memory"}, {"sha": "2e6ce436d03061f7c3054d9c0f2474c7f309dfc4", "filename": "libsanitizer/asan/asan_report.cpp", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -410,8 +410,12 @@ static bool IsInvalidPointerPair(uptr a1, uptr a2) {\n \n static INLINE void CheckForInvalidPointerPair(void *p1, void *p2) {\n   switch (flags()->detect_invalid_pointer_pairs) {\n-    case 0 : return;\n-    case 1 : if (p1 == nullptr || p2 == nullptr) return; break;\n+    case 0:\n+      return;\n+    case 1:\n+      if (p1 == nullptr || p2 == nullptr)\n+        return;\n+      break;\n   }\n \n   uptr a1 = reinterpret_cast<uptr>(p1);\n@@ -472,7 +476,7 @@ void ReportGenericError(uptr pc, uptr bp, uptr sp, uptr addr, bool is_write,\n }  // namespace __asan\n \n // --------------------------- Interface --------------------- {{{1\n-using namespace __asan;  // NOLINT\n+using namespace __asan;\n \n void __asan_report_error(uptr pc, uptr bp, uptr sp, uptr addr, int is_write,\n                          uptr access_size, u32 exp) {"}, {"sha": "ecd568c5981bbc0ece6403a287b8689d9602a012", "filename": "libsanitizer/asan/asan_rtems.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_rtems.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_rtems.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtems.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -181,11 +181,11 @@ static void ThreadStartHook(void *hook, uptr os_id) {\n       asanThreadRegistry().GetThreadLocked(thread->tid())->status;\n   DCHECK(status == ThreadStatusCreated || status == ThreadStatusRunning);\n   // Determine whether we are starting or restarting the thread.\n-  if (status == ThreadStatusCreated)\n+  if (status == ThreadStatusCreated) {\n     // In lieu of AsanThread::ThreadStart.\n     asanThreadRegistry().StartThread(thread->tid(), os_id, ThreadType::Regular,\n                                      nullptr);\n-  else {\n+  } else {\n     // In a thread restart, a thread may resume execution at an\n     // arbitrary function entry point, with its stack and TLS state\n     // reset.  We unpoison the stack in that case."}, {"sha": "594d7752eea627d8f0bf8b7988871623687c363f", "filename": "libsanitizer/asan/asan_rtl.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_rtl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_rtl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -402,7 +402,6 @@ static void AsanInitInternal() {\n   asan_init_is_running = true;\n \n   CacheBinaryName();\n-  CheckASLR();\n \n   // Initialize flags. This must be done early, because most of the\n   // initialization steps look at flags().\n@@ -450,6 +449,7 @@ static void AsanInitInternal() {\n   SetLowLevelAllocateCallback(OnLowLevelAllocate);\n \n   InitializeAsanInterceptors();\n+  CheckASLR();\n \n   // Enable system log (\"adb logcat\") on Android.\n   // Doing this before interceptors are initialized crashes in:\n@@ -542,7 +542,7 @@ void AsanInitFromRtl() {\n // (and thus normal initializers from .preinit_array or modules haven't run).\n \n class AsanInitializer {\n-public:  // NOLINT\n+ public:\n   AsanInitializer() {\n     AsanInitFromRtl();\n   }\n@@ -554,7 +554,7 @@ static AsanInitializer asan_initializer;\n } // namespace __asan\n \n // ---------------------- Interface ---------------- {{{1\n-using namespace __asan;  // NOLINT\n+using namespace __asan;\n \n void NOINLINE __asan_handle_no_return() {\n   if (asan_init_is_running)"}, {"sha": "3932973c225e2be9ecfc2c7eae285e0f93e68a11", "filename": "libsanitizer/asan/asan_scariness_score.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_scariness_score.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_scariness_score.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_scariness_score.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -43,7 +43,7 @@ struct ScarinessScoreBase {\n       internal_strlcat(descr, \"-\", sizeof(descr));\n     internal_strlcat(descr, reason, sizeof(descr));\n     score += add_to_score;\n-  };\n+  }\n   int GetScore() const { return score; }\n   const char *GetDescription() const { return descr; }\n   void Print() const {"}, {"sha": "17324932a86f92e7be95acf821c31011fbe1bb16", "filename": "libsanitizer/asan/asan_shadow_setup.cpp", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_shadow_setup.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_shadow_setup.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_shadow_setup.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -30,14 +30,13 @@ void ReserveShadowMemoryRange(uptr beg, uptr end, const char *name) {\n   CHECK_EQ(((end + 1) % GetMmapGranularity()), 0);\n   uptr size = end - beg + 1;\n   DecreaseTotalMmap(size);  // Don't count the shadow against mmap_limit_mb.\n-  if (!MmapFixedNoReserve(beg, size, name)) {\n+  if (!MmapFixedSuperNoReserve(beg, size, name)) {\n     Report(\n         \"ReserveShadowMemoryRange failed while trying to map 0x%zx bytes. \"\n         \"Perhaps you're using ulimit -v\\n\",\n         size);\n     Abort();\n   }\n-  SetShadowRegionHugePageMode(beg, size);\n   if (common_flags()->use_madv_dontdump) DontDumpShadowMemory(beg, size);\n }\n "}, {"sha": "00ded8f5ef50700c5814ba7d4c3b646dac7086b5", "filename": "libsanitizer/asan/asan_stats.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_stats.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_stats.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stats.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -133,7 +133,7 @@ static void PrintAccumulatedStats() {\n }  // namespace __asan\n \n // ---------------------- Interface ---------------- {{{1\n-using namespace __asan;  // NOLINT\n+using namespace __asan;\n \n uptr __sanitizer_get_current_allocated_bytes() {\n   AsanStats stats;"}, {"sha": "8cb2c3e3b9b6a49132d24e7a8669591bee111b40", "filename": "libsanitizer/asan/asan_suppressions.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_suppressions.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_suppressions.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_suppressions.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -36,7 +36,7 @@ SANITIZER_INTERFACE_WEAK_DEF(const char *, __asan_default_suppressions, void) {\n \n void InitializeSuppressions() {\n   CHECK_EQ(nullptr, suppression_ctx);\n-  suppression_ctx = new (suppression_placeholder)  // NOLINT\n+  suppression_ctx = new (suppression_placeholder)\n       SuppressionContext(kSuppressionTypes, ARRAY_SIZE(kSuppressionTypes));\n   suppression_ctx->ParseFromFile(flags()->suppressions);\n   if (&__asan_default_suppressions)"}, {"sha": "6734d9a1668c7ccbd7f6f75ccea394bc755d95e9", "filename": "libsanitizer/asan/asan_thread.cpp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_thread.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_thread.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -367,8 +367,9 @@ uptr AsanThread::GetStackVariableShadowStart(uptr addr) {\n   } else if (has_fake_stack()) {\n     bottom = fake_stack()->AddrIsInFakeStack(addr);\n     CHECK(bottom);\n-  } else\n+  } else {\n     return 0;\n+  }\n \n   uptr aligned_addr = RoundDownTo(addr, SANITIZER_WORDSIZE / 8);  // align addr.\n   u8 *shadow_ptr = (u8*)MemToShadow(aligned_addr);\n@@ -505,7 +506,7 @@ void EnsureMainThreadIDIsCorrect() {\n } // namespace __lsan\n \n // ---------------------- Interface ---------------- {{{1\n-using namespace __asan;  // NOLINT\n+using namespace __asan;\n \n extern \"C\" {\n SANITIZER_INTERFACE_ATTRIBUTE"}, {"sha": "417892aaedd8edc1fb754c892bb9d44fa6ddbfa4", "filename": "libsanitizer/asan/asan_win.cpp", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -29,7 +29,7 @@\n #include \"sanitizer_common/sanitizer_win.h\"\n #include \"sanitizer_common/sanitizer_win_defs.h\"\n \n-using namespace __asan;  // NOLINT\n+using namespace __asan;\n \n extern \"C\" {\n SANITIZER_INTERFACE_ATTRIBUTE\n@@ -106,7 +106,7 @@ INTERCEPTOR_WINAPI(void, RaiseException, void *a, void *b, void *c, void *d) {\n \n INTERCEPTOR_WINAPI(EXCEPTION_DISPOSITION, __C_specific_handler,\n                    _EXCEPTION_RECORD *a, void *b, _CONTEXT *c,\n-                   _DISPATCHER_CONTEXT *d) {  // NOLINT\n+                   _DISPATCHER_CONTEXT *d) {\n   CHECK(REAL(__C_specific_handler));\n   __asan_handle_no_return();\n   return REAL(__C_specific_handler)(a, b, c, d);\n@@ -362,7 +362,7 @@ bool HandleDlopenInit() {\n // beginning of C++ initialization. We set our priority to XCAB to run\n // immediately after the CRT runs. This way, our exception filter is called\n // first and we can delegate to their filter if appropriate.\n-#pragma section(\".CRT$XCAB\", long, read)  // NOLINT\n+#pragma section(\".CRT$XCAB\", long, read)\n __declspec(allocate(\".CRT$XCAB\")) int (*__intercept_seh)() =\n     __asan_set_seh_filter;\n \n@@ -375,7 +375,7 @@ static void NTAPI asan_thread_init(void *module, DWORD reason, void *reserved) {\n     __asan_init();\n }\n \n-#pragma section(\".CRT$XLAB\", long, read)  // NOLINT\n+#pragma section(\".CRT$XLAB\", long, read)\n __declspec(allocate(\".CRT$XLAB\")) void(NTAPI *__asan_tls_init)(\n     void *, unsigned long, void *) = asan_thread_init;\n #endif\n@@ -389,7 +389,7 @@ static void NTAPI asan_thread_exit(void *module, DWORD reason, void *reserved) {\n   }\n }\n \n-#pragma section(\".CRT$XLY\", long, read)  // NOLINT\n+#pragma section(\".CRT$XLY\", long, read)\n __declspec(allocate(\".CRT$XLY\")) void(NTAPI *__asan_tls_exit)(\n     void *, unsigned long, void *) = asan_thread_exit;\n "}, {"sha": "a5671cc9dffd5dc1b2a2998c3f320979a98a63d5", "filename": "libsanitizer/asan/asan_win_dll_thunk.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -67,10 +67,10 @@ INTERCEPT_LIBRARY_FUNCTION(memcmp);\n INTERCEPT_LIBRARY_FUNCTION(memcpy);\n INTERCEPT_LIBRARY_FUNCTION(memmove);\n INTERCEPT_LIBRARY_FUNCTION(memset);\n-INTERCEPT_LIBRARY_FUNCTION(strcat);  // NOLINT\n+INTERCEPT_LIBRARY_FUNCTION(strcat);\n INTERCEPT_LIBRARY_FUNCTION(strchr);\n INTERCEPT_LIBRARY_FUNCTION(strcmp);\n-INTERCEPT_LIBRARY_FUNCTION(strcpy);  // NOLINT\n+INTERCEPT_LIBRARY_FUNCTION(strcpy);\n INTERCEPT_LIBRARY_FUNCTION(strcspn);\n INTERCEPT_LIBRARY_FUNCTION(strdup);\n INTERCEPT_LIBRARY_FUNCTION(strlen);\n@@ -135,15 +135,15 @@ static int asan_dll_thunk_init() {\n   return 0;\n }\n \n-#pragma section(\".CRT$XIB\", long, read)  // NOLINT\n+#pragma section(\".CRT$XIB\", long, read)\n __declspec(allocate(\".CRT$XIB\")) int (*__asan_preinit)() = asan_dll_thunk_init;\n \n static void WINAPI asan_thread_init(void *mod, unsigned long reason,\n                                     void *reserved) {\n   if (reason == /*DLL_PROCESS_ATTACH=*/1) asan_dll_thunk_init();\n }\n \n-#pragma section(\".CRT$XLAB\", long, read)  // NOLINT\n+#pragma section(\".CRT$XLAB\", long, read)\n __declspec(allocate(\".CRT$XLAB\")) void (WINAPI *__asan_tls_init)(void *,\n     unsigned long, void *) = asan_thread_init;\n "}, {"sha": "f0b5ec9eef7f99db7b139cabc78e7ba24c72eeed", "filename": "libsanitizer/asan/asan_win_dynamic_runtime_thunk.cpp", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -32,12 +32,12 @@\n #include \"asan_interface.inc\"\n \n // First, declare CRT sections we'll be using in this file\n-#pragma section(\".CRT$XIB\", long, read)  // NOLINT\n-#pragma section(\".CRT$XID\", long, read)  // NOLINT\n-#pragma section(\".CRT$XCAB\", long, read)  // NOLINT\n-#pragma section(\".CRT$XTW\", long, read)  // NOLINT\n-#pragma section(\".CRT$XTY\", long, read)  // NOLINT\n-#pragma section(\".CRT$XLAB\", long, read)  // NOLINT\n+#pragma section(\".CRT$XIB\", long, read)\n+#pragma section(\".CRT$XID\", long, read)\n+#pragma section(\".CRT$XCAB\", long, read)\n+#pragma section(\".CRT$XTW\", long, read)\n+#pragma section(\".CRT$XTY\", long, read)\n+#pragma section(\".CRT$XLAB\", long, read)\n \n ////////////////////////////////////////////////////////////////////////////////\n // Define a copy of __asan_option_detect_stack_use_after_return that should be"}, {"sha": "81546e5df71aff3e896e2651a6779d33935a7d28", "filename": "libsanitizer/include/sanitizer/dfsan_interface.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -112,7 +112,7 @@ void dfsan_weak_hook_strncmp(void *caller_pc, const char *s1, const char *s2,\n }  // extern \"C\"\n \n template <typename T>\n-void dfsan_set_label(dfsan_label label, T &data) {  // NOLINT\n+void dfsan_set_label(dfsan_label label, T &data) { // NOLINT\n   dfsan_set_label(label, (void *)&data, sizeof(T));\n }\n "}, {"sha": "8052bc1d56b38c5861f252f2f999ca4a0f0ee747", "filename": "libsanitizer/include/sanitizer/tsan_interface_atomic.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface_atomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface_atomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface_atomic.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -17,10 +17,10 @@\n extern \"C\" {\n #endif\n \n-typedef char     __tsan_atomic8;\n-typedef short    __tsan_atomic16;  // NOLINT\n-typedef int      __tsan_atomic32;\n-typedef long     __tsan_atomic64;  // NOLINT\n+typedef char __tsan_atomic8;\n+typedef short __tsan_atomic16;\n+typedef int __tsan_atomic32;\n+typedef long __tsan_atomic64;\n #if defined(__SIZEOF_INT128__) \\\n     || (__clang_major__ * 100 + __clang_minor__ >= 302)\n __extension__ typedef __int128 __tsan_atomic128;"}, {"sha": "59fc6c3c184c7b2666dd486983910b67268ad703", "filename": "libsanitizer/include/sanitizer/ubsan_interface.h", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Finclude%2Fsanitizer%2Fubsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Finclude%2Fsanitizer%2Fubsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fubsan_interface.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -0,0 +1,32 @@\n+//===-- sanitizer/ubsan_interface.h -----------------------------*- C++ -*-===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of UBSanitizer (UBSan).\n+//\n+// Public interface header.\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_UBSAN_INTERFACE_H\n+#define SANITIZER_UBSAN_INTERFACE_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+/// User-provided default option settings.\n+///\n+/// You can provide your own implementation of this function to return a string\n+/// containing UBSan runtime options (for example,\n+/// <c>verbosity=1:halt_on_error=0</c>).\n+///\n+/// \\returns Default options string.\n+const char* __ubsan_default_options(void);\n+\n+#ifdef __cplusplus\n+}  // extern \"C\"\n+#endif\n+\n+#endif  // SANITIZER_UBSAN_INTERFACE_H"}, {"sha": "d27a8ccf92a8e9381da0087d3481f208a4e6a1a4", "filename": "libsanitizer/interception/interception.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Finterception%2Finterception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Finterception%2Finterception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -272,9 +272,9 @@ const interpose_substitution substitution_##func_name[] \\\n // INTERCEPT_FUNCTION macro, only its name.\n namespace __interception {\n #if defined(_WIN64)\n-typedef unsigned long long uptr;  // NOLINT\n+typedef unsigned long long uptr;\n #else\n-typedef unsigned long uptr;  // NOLINT\n+typedef unsigned long uptr;\n #endif  // _WIN64\n }  // namespace __interception\n "}, {"sha": "1a1c327e61240867869f0b749f99d6813f62f279", "filename": "libsanitizer/interception/interception_win.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Finterception%2Finterception_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Finterception%2Finterception_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -883,8 +883,8 @@ uptr InternalGetProcAddress(void *module, const char *func_name) {\n   // Check that the module header is full and present.\n   RVAPtr<IMAGE_DOS_HEADER> dos_stub(module, 0);\n   RVAPtr<IMAGE_NT_HEADERS> headers(module, dos_stub->e_lfanew);\n-  if (!module || dos_stub->e_magic != IMAGE_DOS_SIGNATURE || // \"MZ\"\n-      headers->Signature != IMAGE_NT_SIGNATURE ||           // \"PE\\0\\0\"\n+  if (!module || dos_stub->e_magic != IMAGE_DOS_SIGNATURE ||  // \"MZ\"\n+      headers->Signature != IMAGE_NT_SIGNATURE ||             // \"PE\\0\\0\"\n       headers->FileHeader.SizeOfOptionalHeader <\n           sizeof(IMAGE_OPTIONAL_HEADER)) {\n     return 0;\n@@ -963,8 +963,8 @@ bool OverrideImportedFunction(const char *module_to_patch,\n   // Check that the module header is full and present.\n   RVAPtr<IMAGE_DOS_HEADER> dos_stub(module, 0);\n   RVAPtr<IMAGE_NT_HEADERS> headers(module, dos_stub->e_lfanew);\n-  if (!module || dos_stub->e_magic != IMAGE_DOS_SIGNATURE || // \"MZ\"\n-      headers->Signature != IMAGE_NT_SIGNATURE ||            // \"PE\\0\\0\"\n+  if (!module || dos_stub->e_magic != IMAGE_DOS_SIGNATURE ||  // \"MZ\"\n+      headers->Signature != IMAGE_NT_SIGNATURE ||             // \"PE\\0\\0\"\n       headers->FileHeader.SizeOfOptionalHeader <\n           sizeof(IMAGE_OPTIONAL_HEADER)) {\n     return false;"}, {"sha": "4ce03046ffb7fbe550da6f3d274ae80fa54d135b", "filename": "libsanitizer/lsan/lsan.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Flsan%2Flsan.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Flsan%2Flsan.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -50,7 +50,7 @@ void __sanitizer::BufferedStackTrace::UnwindImpl(\n   }\n }\n \n-using namespace __lsan;  // NOLINT\n+using namespace __lsan;\n \n static void InitializeFlags() {\n   // Set all the default values.\n@@ -89,7 +89,7 @@ static void InitializeFlags() {\n \n static void OnStackUnwind(const SignalContext &sig, const void *,\n                           BufferedStackTrace *stack) {\n-  stack->Unwind(sig.pc, sig.bp, sig.context,\n+  stack->Unwind(StackTrace::GetNextInstructionPc(sig.pc), sig.bp, sig.context,\n                 common_flags()->fast_unwind_on_fatal);\n }\n "}, {"sha": "9ff9f4c5d1c977d32b7ce668e7a810691bae3215", "filename": "libsanitizer/lsan/lsan_common.cpp", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Flsan%2Flsan_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Flsan%2Flsan_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -84,7 +84,7 @@ static const char kStdSuppressions[] =\n \n void InitializeSuppressions() {\n   CHECK_EQ(nullptr, suppression_ctx);\n-  suppression_ctx = new (suppression_placeholder) // NOLINT\n+  suppression_ctx = new (suppression_placeholder)\n       SuppressionContext(kSuppressionTypes, ARRAY_SIZE(kSuppressionTypes));\n   suppression_ctx->ParseFromFile(flags()->suppressions);\n   if (&__lsan_default_suppressions)\n@@ -104,7 +104,7 @@ InternalMmapVector<RootRegion> const *GetRootRegions() { return root_regions; }\n void InitializeRootRegions() {\n   CHECK(!root_regions);\n   ALIGNED(64) static char placeholder[sizeof(InternalMmapVector<RootRegion>)];\n-  root_regions = new (placeholder) InternalMmapVector<RootRegion>();  // NOLINT\n+  root_regions = new (placeholder) InternalMmapVector<RootRegion>();\n }\n \n const char *MaybeCallLsanDefaultOptions() {\n@@ -162,7 +162,7 @@ void ScanRangeForPointers(uptr begin, uptr end,\n   uptr pp = begin;\n   if (pp % alignment)\n     pp = pp + alignment - pp % alignment;\n-  for (; pp + sizeof(void *) <= end; pp += alignment) {  // NOLINT\n+  for (; pp + sizeof(void *) <= end; pp += alignment) {\n     void *p = *reinterpret_cast<void **>(pp);\n     if (!CanBeAHeapPointer(reinterpret_cast<uptr>(p))) continue;\n     uptr chunk = PointsIntoChunk(p);\n@@ -535,7 +535,7 @@ static void ReportIfNotSuspended(ThreadContextBase *tctx, void *arg) {\n     if (i >= suspended_threads.size() || suspended_threads[i] != tctx->os_id)\n       Report(\"Running thread %d was not suspended. False leaks are possible.\\n\",\n              tctx->os_id);\n-  };\n+  }\n }\n \n static void ReportUnsuspendedThreads(\n@@ -570,11 +570,7 @@ static bool CheckForLeaks() {\n   EnsureMainThreadIDIsCorrect();\n   CheckForLeaksParam param;\n   param.success = false;\n-  LockThreadRegistry();\n-  LockAllocator();\n-  DoStopTheWorld(CheckForLeaksCallback, &param);\n-  UnlockAllocator();\n-  UnlockThreadRegistry();\n+  LockStuffAndStopTheWorld(CheckForLeaksCallback, &param);\n \n   if (!param.success) {\n     Report(\"LeakSanitizer has encountered a fatal error.\\n\");\n@@ -794,7 +790,7 @@ void EnableInThisThread() { }\n }\n #endif // CAN_SANITIZE_LEAKS\n \n-using namespace __lsan;  // NOLINT\n+using namespace __lsan;\n \n extern \"C\" {\n SANITIZER_INTERFACE_ATTRIBUTE"}, {"sha": "d24abe31b71b524e3f545410e772ce6744170ba8", "filename": "libsanitizer/lsan/lsan_common.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Flsan%2Flsan_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Flsan%2Flsan_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -129,8 +129,9 @@ struct RootRegion {\n InternalMmapVector<RootRegion> const *GetRootRegions();\n void ScanRootRegion(Frontier *frontier, RootRegion const &region,\n                     uptr region_begin, uptr region_end, bool is_readable);\n-// Run stoptheworld while holding any platform-specific locks.\n-void DoStopTheWorld(StopTheWorldCallback callback, void* argument);\n+// Run stoptheworld while holding any platform-specific locks, as well as the\n+// allocator and thread registry locks.\n+void LockStuffAndStopTheWorld(StopTheWorldCallback callback, void* argument);\n \n void ScanRangeForPointers(uptr begin, uptr end,\n                           Frontier *frontier,"}, {"sha": "ea1a4a2f569d0648a06b3b25d6e73a865dbab14d", "filename": "libsanitizer/lsan/lsan_common_linux.cpp", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Flsan%2Flsan_common_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Flsan%2Flsan_common_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_linux.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -115,10 +115,14 @@ void HandleLeaks() {\n   if (common_flags()->exitcode) Die();\n }\n \n-static int DoStopTheWorldCallback(struct dl_phdr_info *info, size_t size,\n-                                  void *data) {\n+static int LockStuffAndStopTheWorldCallback(struct dl_phdr_info *info,\n+                                            size_t size, void *data) {\n+  LockThreadRegistry();\n+  LockAllocator();\n   DoStopTheWorldParam *param = reinterpret_cast<DoStopTheWorldParam *>(data);\n   StopTheWorld(param->callback, param->argument);\n+  UnlockAllocator();\n+  UnlockThreadRegistry();\n   return 1;\n }\n \n@@ -130,9 +134,9 @@ static int DoStopTheWorldCallback(struct dl_phdr_info *info, size_t size,\n // while holding the libdl lock in the parent thread, we can safely reenter it\n // in the tracer. The solution is to run stoptheworld from a dl_iterate_phdr()\n // callback in the parent thread.\n-void DoStopTheWorld(StopTheWorldCallback callback, void *argument) {\n+void LockStuffAndStopTheWorld(StopTheWorldCallback callback, void *argument) {\n   DoStopTheWorldParam param = {callback, argument};\n-  dl_iterate_phdr(DoStopTheWorldCallback, &param);\n+  dl_iterate_phdr(LockStuffAndStopTheWorldCallback, &param);\n }\n \n } // namespace __lsan"}, {"sha": "c1804e93c11db7ce667102bbe925300815d9891b", "filename": "libsanitizer/lsan/lsan_common_mac.cpp", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Flsan%2Flsan_common_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Flsan%2Flsan_common_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_mac.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -193,8 +193,12 @@ void ProcessPlatformSpecificAllocations(Frontier *frontier) {\n // causes rare race conditions.\n void HandleLeaks() {}\n \n-void DoStopTheWorld(StopTheWorldCallback callback, void *argument) {\n+void LockStuffAndStopTheWorld(StopTheWorldCallback callback, void *argument) {\n+  LockThreadRegistry();\n+  LockAllocator();\n   StopTheWorld(callback, argument);\n+  UnlockAllocator();\n+  UnlockThreadRegistry();\n }\n \n } // namespace __lsan"}, {"sha": "f642bb807bc88ff6f14bb13cfbd7640ebbd4c050", "filename": "libsanitizer/lsan/lsan_interceptors.cpp", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Flsan%2Flsan_interceptors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Flsan%2Flsan_interceptors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_interceptors.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -345,6 +345,55 @@ INTERCEPTOR(void, thr_exit, tid_t *state) {\n #define LSAN_MAYBE_INTERCEPT_THR_EXIT\n #endif\n \n+#if SANITIZER_INTERCEPT___CXA_ATEXIT\n+INTERCEPTOR(int, __cxa_atexit, void (*func)(void *), void *arg,\n+            void *dso_handle) {\n+  __lsan::ScopedInterceptorDisabler disabler;\n+  return REAL(__cxa_atexit)(func, arg, dso_handle);\n+}\n+#define LSAN_MAYBE_INTERCEPT___CXA_ATEXIT INTERCEPT_FUNCTION(__cxa_atexit)\n+#else\n+#define LSAN_MAYBE_INTERCEPT___CXA_ATEXIT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_ATEXIT\n+INTERCEPTOR(int, atexit, void (*f)()) {\n+  __lsan::ScopedInterceptorDisabler disabler;\n+  return REAL(__cxa_atexit)((void (*)(void *a))f, 0, 0);\n+}\n+#define LSAN_MAYBE_INTERCEPT_ATEXIT INTERCEPT_FUNCTION(atexit)\n+#else\n+#define LSAN_MAYBE_INTERCEPT_ATEXIT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTHREAD_ATFORK\n+extern \"C\" {\n+extern int _pthread_atfork(void (*prepare)(), void (*parent)(),\n+                           void (*child)());\n+};\n+\n+INTERCEPTOR(int, pthread_atfork, void (*prepare)(), void (*parent)(),\n+            void (*child)()) {\n+  __lsan::ScopedInterceptorDisabler disabler;\n+  // REAL(pthread_atfork) cannot be called due to symbol indirections at least\n+  // on NetBSD\n+  return _pthread_atfork(prepare, parent, child);\n+}\n+#define LSAN_MAYBE_INTERCEPT_PTHREAD_ATFORK INTERCEPT_FUNCTION(pthread_atfork)\n+#else\n+#define LSAN_MAYBE_INTERCEPT_PTHREAD_ATFORK\n+#endif\n+\n+#if SANITIZER_INTERCEPT_STRERROR\n+INTERCEPTOR(char *, strerror, int errnum) {\n+  __lsan::ScopedInterceptorDisabler disabler;\n+  return REAL(strerror)(errnum);\n+}\n+#define LSAN_MAYBE_INTERCEPT_STRERROR INTERCEPT_FUNCTION(strerror)\n+#else\n+#define LSAN_MAYBE_INTERCEPT_STRERROR\n+#endif\n+\n struct ThreadParam {\n   void *(*callback)(void *arg);\n   void *param;\n@@ -454,6 +503,12 @@ void InitializeInterceptors() {\n   LSAN_MAYBE_INTERCEPT__LWP_EXIT;\n   LSAN_MAYBE_INTERCEPT_THR_EXIT;\n \n+  LSAN_MAYBE_INTERCEPT___CXA_ATEXIT;\n+  LSAN_MAYBE_INTERCEPT_ATEXIT;\n+  LSAN_MAYBE_INTERCEPT_PTHREAD_ATFORK;\n+\n+  LSAN_MAYBE_INTERCEPT_STRERROR;\n+\n #if !SANITIZER_NETBSD && !SANITIZER_FREEBSD\n   if (pthread_key_create(&g_thread_finalize_key, &thread_finalize)) {\n     Report(\"LeakSanitizer: failed to create thread key.\\n\");"}, {"sha": "b96893e2801b3b226c32ab308c1bfd12313ed130", "filename": "libsanitizer/lsan/lsan_mac.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Flsan%2Flsan_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Flsan%2Flsan_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_mac.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -90,7 +90,7 @@ extern \"C\" void lsan_dispatch_call_block_and_release(void *block) {\n \n }  // namespace __lsan\n \n-using namespace __lsan;  // NOLINT\n+using namespace __lsan;\n \n // Wrap |ctxt| and |func| into an lsan_block_context_t.\n // The caller retains control of the allocated context."}, {"sha": "2f74fbef260fdfaf146121477f3f38c371597a3f", "filename": "libsanitizer/merge.sh", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fmerge.sh?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -74,7 +74,6 @@ merge lib/tsan/rtl tsan\n merge lib/sanitizer_common sanitizer_common\n merge lib/interception interception\n merge lib/ubsan ubsan\n-merge lib/BlocksRuntime/ BlocksRuntime\n \n # Need to merge lib/builtins/assembly.h file:\n mkdir -p builtins"}, {"sha": "fc426f0e74f48297139c83d032d5583a5437bd50", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_checks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -54,7 +54,7 @@ INLINE bool CheckAlignedAllocAlignmentAndSize(uptr alignment, uptr size) {\n // and a multiple of sizeof(void *).\n INLINE bool CheckPosixMemalignAlignment(uptr alignment) {\n   return alignment != 0 && IsPowerOfTwo(alignment) &&\n-         (alignment % sizeof(void *)) == 0; // NOLINT\n+         (alignment % sizeof(void *)) == 0;\n }\n \n // Returns true if calloc(size, n) call overflows on size*n calculation."}, {"sha": "d74e08010d5de2d562e8aff4902fc0ca72e4e24a", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_report.cpp", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_report.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -106,10 +106,11 @@ void NORETURN ReportInvalidPosixMemalignAlignment(uptr alignment,\n   {\n     ScopedAllocatorErrorReport report(\"invalid-posix-memalign-alignment\",\n                                       stack);\n-    Report(\"ERROR: %s: invalid alignment requested in \"\n-           \"posix_memalign: %zd, alignment must be a power of two and a \"\n-           \"multiple of sizeof(void*) == %zd\\n\", SanitizerToolName, alignment,\n-           sizeof(void*));  // NOLINT\n+    Report(\n+        \"ERROR: %s: invalid alignment requested in \"\n+        \"posix_memalign: %zd, alignment must be a power of two and a \"\n+        \"multiple of sizeof(void*) == %zd\\n\",\n+        SanitizerToolName, alignment, sizeof(void *));\n   }\n   Die();\n }"}, {"sha": "803af3285e189b581be1dd28766d3ffb0f21b7df", "filename": "libsanitizer/sanitizer_common/sanitizer_asm.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_asm.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -60,7 +60,9 @@\n \n #if defined(__ELF__) && (defined(__GNU__) || defined(__FreeBSD__) || \\\n                          defined(__Fuchsia__) || defined(__linux__))\n-#define NO_EXEC_STACK_DIRECTIVE .section .note.GNU-stack,\"\",%progbits // NOLINT\n+// clang-format off\n+#define NO_EXEC_STACK_DIRECTIVE .section .note.GNU-stack,\"\",%progbits  // NOLINT\n+// clang-format on\n #else\n #define NO_EXEC_STACK_DIRECTIVE\n #endif"}, {"sha": "6a7c5465dcbbc17b0d5daeb084caecb82662e4bb", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_msvc.h", "status": "modified", "additions": 27, "deletions": 36, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -20,44 +20,35 @@ extern \"C\" void _mm_mfence();\n #pragma intrinsic(_mm_mfence)\n extern \"C\" void _mm_pause();\n #pragma intrinsic(_mm_pause)\n-extern \"C\" char _InterlockedExchange8(   // NOLINT\n-    char volatile *Addend, char Value);  // NOLINT\n+extern \"C\" char _InterlockedExchange8(char volatile *Addend, char Value);\n #pragma intrinsic(_InterlockedExchange8)\n-extern \"C\" short _InterlockedExchange16(   // NOLINT\n-    short volatile *Addend, short Value);  // NOLINT\n+extern \"C\" short _InterlockedExchange16(short volatile *Addend, short Value);\n #pragma intrinsic(_InterlockedExchange16)\n-extern \"C\" long _InterlockedExchange(    // NOLINT\n-    long volatile *Addend, long Value);  // NOLINT\n+extern \"C\" long _InterlockedExchange(long volatile *Addend, long Value);\n #pragma intrinsic(_InterlockedExchange)\n-extern \"C\" long _InterlockedExchangeAdd(  // NOLINT\n-    long volatile * Addend, long Value);  // NOLINT\n+extern \"C\" long _InterlockedExchangeAdd(long volatile *Addend, long Value);\n #pragma intrinsic(_InterlockedExchangeAdd)\n-extern \"C\" char _InterlockedCompareExchange8(  // NOLINT\n-    char volatile *Destination,                // NOLINT\n-    char Exchange, char Comparand);            // NOLINT\n+extern \"C\" char _InterlockedCompareExchange8(char volatile *Destination,\n+                                             char Exchange, char Comparand);\n #pragma intrinsic(_InterlockedCompareExchange8)\n-extern \"C\" short _InterlockedCompareExchange16(  // NOLINT\n-    short volatile *Destination,                 // NOLINT\n-    short Exchange, short Comparand);            // NOLINT\n+extern \"C\" short _InterlockedCompareExchange16(short volatile *Destination,\n+                                               short Exchange, short Comparand);\n #pragma intrinsic(_InterlockedCompareExchange16)\n-extern \"C\"\n-long long _InterlockedCompareExchange64(  // NOLINT\n-    long long volatile *Destination,              // NOLINT\n-    long long Exchange, long long Comparand);     // NOLINT\n+extern \"C\" long long _InterlockedCompareExchange64(\n+    long long volatile *Destination, long long Exchange, long long Comparand);\n #pragma intrinsic(_InterlockedCompareExchange64)\n extern \"C\" void *_InterlockedCompareExchangePointer(\n     void *volatile *Destination,\n     void *Exchange, void *Comparand);\n #pragma intrinsic(_InterlockedCompareExchangePointer)\n-extern \"C\"\n-long __cdecl _InterlockedCompareExchange(  // NOLINT\n-    long volatile *Destination,            // NOLINT\n-    long Exchange, long Comparand);        // NOLINT\n+extern \"C\" long __cdecl _InterlockedCompareExchange(long volatile *Destination,\n+                                                    long Exchange,\n+                                                    long Comparand);\n #pragma intrinsic(_InterlockedCompareExchange)\n \n #ifdef _WIN64\n-extern \"C\" long long _InterlockedExchangeAdd64(     // NOLINT\n-    long long volatile * Addend, long long Value);  // NOLINT\n+extern \"C\" long long _InterlockedExchangeAdd64(long long volatile *Addend,\n+                                               long long Value);\n #pragma intrinsic(_InterlockedExchangeAdd64)\n #endif\n \n@@ -115,41 +106,41 @@ INLINE u32 atomic_fetch_add(volatile atomic_uint32_t *a,\n     u32 v, memory_order mo) {\n   (void)mo;\n   DCHECK(!((uptr)a % sizeof(*a)));\n-  return (u32)_InterlockedExchangeAdd(\n-      (volatile long*)&a->val_dont_use, (long)v);  // NOLINT\n+  return (u32)_InterlockedExchangeAdd((volatile long *)&a->val_dont_use,\n+                                      (long)v);\n }\n \n INLINE uptr atomic_fetch_add(volatile atomic_uintptr_t *a,\n     uptr v, memory_order mo) {\n   (void)mo;\n   DCHECK(!((uptr)a % sizeof(*a)));\n #ifdef _WIN64\n-  return (uptr)_InterlockedExchangeAdd64(\n-      (volatile long long*)&a->val_dont_use, (long long)v);  // NOLINT\n+  return (uptr)_InterlockedExchangeAdd64((volatile long long *)&a->val_dont_use,\n+                                         (long long)v);\n #else\n-  return (uptr)_InterlockedExchangeAdd(\n-      (volatile long*)&a->val_dont_use, (long)v);  // NOLINT\n+  return (uptr)_InterlockedExchangeAdd((volatile long *)&a->val_dont_use,\n+                                       (long)v);\n #endif\n }\n \n INLINE u32 atomic_fetch_sub(volatile atomic_uint32_t *a,\n     u32 v, memory_order mo) {\n   (void)mo;\n   DCHECK(!((uptr)a % sizeof(*a)));\n-  return (u32)_InterlockedExchangeAdd(\n-      (volatile long*)&a->val_dont_use, -(long)v);  // NOLINT\n+  return (u32)_InterlockedExchangeAdd((volatile long *)&a->val_dont_use,\n+                                      -(long)v);\n }\n \n INLINE uptr atomic_fetch_sub(volatile atomic_uintptr_t *a,\n     uptr v, memory_order mo) {\n   (void)mo;\n   DCHECK(!((uptr)a % sizeof(*a)));\n #ifdef _WIN64\n-  return (uptr)_InterlockedExchangeAdd64(\n-      (volatile long long*)&a->val_dont_use, -(long long)v);  // NOLINT\n+  return (uptr)_InterlockedExchangeAdd64((volatile long long *)&a->val_dont_use,\n+                                         -(long long)v);\n #else\n-  return (uptr)_InterlockedExchangeAdd(\n-      (volatile long*)&a->val_dont_use, -(long)v);  // NOLINT\n+  return (uptr)_InterlockedExchangeAdd((volatile long *)&a->val_dont_use,\n+                                       -(long)v);\n #endif\n }\n "}, {"sha": "f5f9f49d8cffc4168bd50240ed0bf077436634f8", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -323,7 +323,7 @@ static int InstallMallocFreeHooks(void (*malloc_hook)(const void *, uptr),\n \n } // namespace __sanitizer\n \n-using namespace __sanitizer;  // NOLINT\n+using namespace __sanitizer;\n \n extern \"C\" {\n SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_report_error_summary,"}, {"sha": "87b8f02b5b730158f61569fb5d9b8dfceb898ec5", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -100,6 +100,8 @@ void UnmapOrDie(void *addr, uptr size);\n void *MmapOrDieOnFatalError(uptr size, const char *mem_type);\n bool MmapFixedNoReserve(uptr fixed_addr, uptr size, const char *name = nullptr)\n      WARN_UNUSED_RESULT;\n+bool MmapFixedSuperNoReserve(uptr fixed_addr, uptr size,\n+                             const char *name = nullptr) WARN_UNUSED_RESULT;\n void *MmapNoReserveOrDie(uptr size, const char *mem_type);\n void *MmapFixedOrDie(uptr fixed_addr, uptr size, const char *name = nullptr);\n // Behaves just like MmapFixedOrDie, but tolerates out of memory condition, in\n@@ -337,18 +339,18 @@ void ReportMmapWriteExec(int prot);\n // Math\n #if SANITIZER_WINDOWS && !defined(__clang__) && !defined(__GNUC__)\n extern \"C\" {\n-unsigned char _BitScanForward(unsigned long *index, unsigned long mask);  // NOLINT\n-unsigned char _BitScanReverse(unsigned long *index, unsigned long mask);  // NOLINT\n+unsigned char _BitScanForward(unsigned long *index, unsigned long mask);\n+unsigned char _BitScanReverse(unsigned long *index, unsigned long mask);\n #if defined(_WIN64)\n-unsigned char _BitScanForward64(unsigned long *index, unsigned __int64 mask);  // NOLINT\n-unsigned char _BitScanReverse64(unsigned long *index, unsigned __int64 mask);  // NOLINT\n+unsigned char _BitScanForward64(unsigned long *index, unsigned __int64 mask);\n+unsigned char _BitScanReverse64(unsigned long *index, unsigned __int64 mask);\n #endif\n }\n #endif\n \n INLINE uptr MostSignificantSetBitIndex(uptr x) {\n   CHECK_NE(x, 0U);\n-  unsigned long up;  // NOLINT\n+  unsigned long up;\n #if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)\n # ifdef _WIN64\n   up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);\n@@ -365,7 +367,7 @@ INLINE uptr MostSignificantSetBitIndex(uptr x) {\n \n INLINE uptr LeastSignificantSetBitIndex(uptr x) {\n   CHECK_NE(x, 0U);\n-  unsigned long up;  // NOLINT\n+  unsigned long up;\n #if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)\n # ifdef _WIN64\n   up = __builtin_ctzll(x);\n@@ -879,6 +881,11 @@ struct SignalContext {\n   bool is_memory_access;\n   enum WriteFlag { UNKNOWN, READ, WRITE } write_flag;\n \n+  // In some cases the kernel cannot provide the true faulting address; `addr`\n+  // will be zero then.  This field allows to distinguish between these cases\n+  // and dereferences of null.\n+  bool is_true_faulting_addr;\n+\n   // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n   // constructor\n   SignalContext() = default;\n@@ -891,7 +898,8 @@ struct SignalContext {\n         context(context),\n         addr(GetAddress()),\n         is_memory_access(IsMemoryAccess()),\n-        write_flag(GetWriteFlag()) {\n+        write_flag(GetWriteFlag()),\n+        is_true_faulting_addr(IsTrueFaultingAddress()) {\n     InitPcSpBp();\n   }\n \n@@ -912,6 +920,7 @@ struct SignalContext {\n   uptr GetAddress() const;\n   WriteFlag GetWriteFlag() const;\n   bool IsMemoryAccess() const;\n+  bool IsTrueFaultingAddress() const;\n };\n \n void InitializePlatformEarly();\n@@ -971,7 +980,7 @@ INLINE u32 GetNumberOfCPUsCached() {\n }  // namespace __sanitizer\n \n inline void *operator new(__sanitizer::operator_new_size_type size,\n-                          __sanitizer::LowLevelAllocator &alloc) {\n+                          __sanitizer::LowLevelAllocator &alloc) {  // NOLINT\n   return alloc.Allocate(size);\n }\n "}, {"sha": "50e3558b52e87275987a6ba4522a0ea66e02e382", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 89, "deletions": 29, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -36,6 +36,7 @@\n //   COMMON_INTERCEPTOR_MMAP_IMPL\n //   COMMON_INTERCEPTOR_COPY_STRING\n //   COMMON_INTERCEPTOR_STRNDUP_IMPL\n+//   COMMON_INTERCEPTOR_STRERROR\n //===----------------------------------------------------------------------===//\n \n #include \"interception/interception.h\"\n@@ -301,6 +302,10 @@ bool PlatformHasDifferentMemcpyAndMemmove();\n   return new_mem;\n #endif\n \n+#ifndef COMMON_INTERCEPTOR_STRERROR\n+#define COMMON_INTERCEPTOR_STRERROR() {}\n+#endif\n+\n struct FileMetadata {\n   // For open_memstream().\n   char **addr;\n@@ -1267,9 +1272,8 @@ INTERCEPTOR(int, puts, char *s) {\n #endif\n \n #if SANITIZER_INTERCEPT_PRCTL\n-INTERCEPTOR(int, prctl, int option, unsigned long arg2,\n-            unsigned long arg3,                        // NOLINT\n-            unsigned long arg4, unsigned long arg5) {  // NOLINT\n+INTERCEPTOR(int, prctl, int option, unsigned long arg2, unsigned long arg3,\n+            unsigned long arg4, unsigned long arg5) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, prctl, option, arg2, arg3, arg4, arg5);\n   static const int PR_SET_NAME = 15;\n@@ -1701,22 +1705,22 @@ INTERCEPTOR(int, __fprintf_chk, __sanitizer_FILE *stream, SIZE_T size,\n FORMAT_INTERCEPTOR_IMPL(__fprintf_chk, vfprintf, stream, format)\n #endif\n \n-INTERCEPTOR(int, sprintf, char *str, const char *format, ...) // NOLINT\n-FORMAT_INTERCEPTOR_IMPL(sprintf, vsprintf, str, format) // NOLINT\n+INTERCEPTOR(int, sprintf, char *str, const char *format, ...)\n+FORMAT_INTERCEPTOR_IMPL(sprintf, vsprintf, str, format)\n \n #if SANITIZER_INTERCEPT___PRINTF_CHK\n INTERCEPTOR(int, __sprintf_chk, char *str, int flag, SIZE_T size_to,\n-            const char *format, ...) // NOLINT\n-FORMAT_INTERCEPTOR_IMPL(__sprintf_chk, vsprintf, str, format) // NOLINT\n+            const char *format, ...)\n+FORMAT_INTERCEPTOR_IMPL(__sprintf_chk, vsprintf, str, format)\n #endif\n \n INTERCEPTOR(int, snprintf, char *str, SIZE_T size, const char *format, ...)\n FORMAT_INTERCEPTOR_IMPL(snprintf, vsnprintf, str, size, format)\n \n #if SANITIZER_INTERCEPT___PRINTF_CHK\n INTERCEPTOR(int, __snprintf_chk, char *str, SIZE_T size, int flag,\n-            SIZE_T size_to, const char *format, ...) // NOLINT\n-FORMAT_INTERCEPTOR_IMPL(__snprintf_chk, vsnprintf, str, size, format) // NOLINT\n+            SIZE_T size_to, const char *format, ...)\n+FORMAT_INTERCEPTOR_IMPL(__snprintf_chk, vsnprintf, str, size, format)\n #endif\n \n INTERCEPTOR(int, asprintf, char **strp, const char *format, ...)\n@@ -3071,13 +3075,14 @@ INTERCEPTOR(int, sendmmsg, int fd, struct __sanitizer_mmsghdr *msgvec,\n     COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n   }\n   int res = REAL(sendmmsg)(fd, msgvec, vlen, flags);\n-  if (res >= 0 && msgvec)\n+  if (res >= 0 && msgvec) {\n     for (int i = 0; i < res; ++i) {\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, &msgvec[i].msg_len,\n                                      sizeof(msgvec[i].msg_len));\n       if (common_flags()->intercept_send)\n         read_msghdr(ctx, &msgvec[i].msg_hdr, msgvec[i].msg_len);\n     }\n+  }\n   return res;\n }\n #define INIT_SENDMMSG COMMON_INTERCEPT_FUNCTION(sendmmsg);\n@@ -3208,20 +3213,21 @@ INTERCEPTOR(uptr, ptrace, int request, int pid, void *addr, void *data) {\n   __sanitizer_iovec local_iovec;\n \n   if (data) {\n-    if (request == ptrace_setregs)\n+    if (request == ptrace_setregs) {\n       COMMON_INTERCEPTOR_READ_RANGE(ctx, data, struct_user_regs_struct_sz);\n-    else if (request == ptrace_setfpregs)\n+    } else if (request == ptrace_setfpregs) {\n       COMMON_INTERCEPTOR_READ_RANGE(ctx, data, struct_user_fpregs_struct_sz);\n-    else if (request == ptrace_setfpxregs)\n+    } else if (request == ptrace_setfpxregs) {\n       COMMON_INTERCEPTOR_READ_RANGE(ctx, data, struct_user_fpxregs_struct_sz);\n-    else if (request == ptrace_setvfpregs)\n+    } else if (request == ptrace_setvfpregs) {\n       COMMON_INTERCEPTOR_READ_RANGE(ctx, data, struct_user_vfpregs_struct_sz);\n-    else if (request == ptrace_setsiginfo)\n+    } else if (request == ptrace_setsiginfo) {\n       COMMON_INTERCEPTOR_READ_RANGE(ctx, data, siginfo_t_sz);\n+\n     // Some kernel might zero the iovec::iov_base in case of invalid\n     // write access.  In this case copy the invalid address for further\n     // inspection.\n-    else if (request == ptrace_setregset || request == ptrace_getregset) {\n+    } else if (request == ptrace_setregset || request == ptrace_getregset) {\n       __sanitizer_iovec *iovec = (__sanitizer_iovec*)data;\n       COMMON_INTERCEPTOR_READ_RANGE(ctx, iovec, sizeof(*iovec));\n       local_iovec = *iovec;\n@@ -3238,19 +3244,19 @@ INTERCEPTOR(uptr, ptrace, int request, int pid, void *addr, void *data) {\n   if (!res && data) {\n     // Note that PEEK* requests assign different meaning to the return value.\n     // This function does not handle them (nor does it need to).\n-    if (request == ptrace_getregs)\n+    if (request == ptrace_getregs) {\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_regs_struct_sz);\n-    else if (request == ptrace_getfpregs)\n+    } else if (request == ptrace_getfpregs) {\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_fpregs_struct_sz);\n-    else if (request == ptrace_getfpxregs)\n+    } else if (request == ptrace_getfpxregs) {\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_fpxregs_struct_sz);\n-    else if (request == ptrace_getvfpregs)\n+    } else if (request == ptrace_getvfpregs) {\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_vfpregs_struct_sz);\n-    else if (request == ptrace_getsiginfo)\n+    } else if (request == ptrace_getsiginfo) {\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, siginfo_t_sz);\n-    else if (request == ptrace_geteventmsg)\n+    } else if (request == ptrace_geteventmsg) {\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, sizeof(unsigned long));\n-    else if (request == ptrace_getregset) {\n+    } else if (request == ptrace_getregset) {\n       __sanitizer_iovec *iovec = (__sanitizer_iovec*)data;\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iovec, sizeof(*iovec));\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, local_iovec.iov_base,\n@@ -3676,6 +3682,7 @@ INTERCEPTOR(int, sched_getparam, int pid, void *param) {\n INTERCEPTOR(char *, strerror, int errnum) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, strerror, errnum);\n+  COMMON_INTERCEPTOR_STRERROR();\n   char *res = REAL(strerror)(errnum);\n   if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n   return res;\n@@ -6716,7 +6723,7 @@ INTERCEPTOR(wchar_t *, wcscat, wchar_t *dst, const wchar_t *src) {\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, dst, (dst_size + 1) * sizeof(wchar_t));\n   COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst + dst_size,\n                                  (src_size + 1) * sizeof(wchar_t));\n-  return REAL(wcscat)(dst, src);  // NOLINT\n+  return REAL(wcscat)(dst, src);\n }\n \n INTERCEPTOR(wchar_t *, wcsncat, wchar_t *dst, const wchar_t *src, SIZE_T n) {\n@@ -6729,7 +6736,7 @@ INTERCEPTOR(wchar_t *, wcsncat, wchar_t *dst, const wchar_t *src, SIZE_T n) {\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, dst, (dst_size + 1) * sizeof(wchar_t));\n   COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst + dst_size,\n                                  (src_size + 1) * sizeof(wchar_t));\n-  return REAL(wcsncat)(dst, src, n);  // NOLINT\n+  return REAL(wcsncat)(dst, src, n);\n }\n #define INIT_WCSCAT                  \\\n   COMMON_INTERCEPT_FUNCTION(wcscat); \\\n@@ -7843,10 +7850,11 @@ INTERCEPTOR(int, modctl, int operation, void *argp) {\n     if (iov)\n       COMMON_INTERCEPTOR_WRITE_RANGE(\n           ctx, iov->iov_base, Min(iov_len,  iov->iov_len));\n-  } else if (operation == modctl_exists)\n+  } else if (operation == modctl_exists) {\n     ret = REAL(modctl)(operation, argp);\n-  else\n+  } else {\n     ret = REAL(modctl)(operation, argp);\n+  }\n \n   return ret;\n }\n@@ -9565,11 +9573,60 @@ INTERCEPTOR(SSIZE_T, getrandom, void *buf, SIZE_T buflen, unsigned int flags) {\n #define INIT_GETRANDOM\n #endif\n \n+#if SANITIZER_INTERCEPT_CRYPT\n+INTERCEPTOR(char *, crypt, char *key, char *salt) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, crypt, key, salt);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, key, internal_strlen(key) + 1);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, salt, internal_strlen(salt) + 1);\n+  char *res = REAL(crypt)(key, salt);\n+  if (res != nullptr)\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, internal_strlen(res) + 1);\n+  return res;\n+}\n+#define INIT_CRYPT COMMON_INTERCEPT_FUNCTION(crypt);\n+#else\n+#define INIT_CRYPT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_CRYPT_R\n+INTERCEPTOR(char *, crypt_r, char *key, char *salt, void *data) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, crypt_r, key, salt, data);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, key, internal_strlen(key) + 1);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, salt, internal_strlen(salt) + 1);\n+  char *res = REAL(crypt_r)(key, salt, data);\n+  if (res != nullptr) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data,\n+                                   __sanitizer::struct_crypt_data_sz);\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, internal_strlen(res) + 1);\n+  }\n+  return res;\n+}\n+#define INIT_CRYPT_R COMMON_INTERCEPT_FUNCTION(crypt_r);\n+#else\n+#define INIT_CRYPT_R\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETENTROPY\n+INTERCEPTOR(int, getentropy, void *buf, SIZE_T buflen) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getentropy, buf, buflen);\n+  int r = REAL(getentropy)(buf, buflen);\n+  if (r == 0) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n+  }\n+  return r;\n+}\n+#define INIT_GETENTROPY COMMON_INTERCEPT_FUNCTION(getentropy)\n+#else\n+#define INIT_GETENTROPY\n+#endif\n+\n static void InitializeCommonInterceptors() {\n #if SI_POSIX\n   static u64 metadata_mem[sizeof(MetadataHashMap) / sizeof(u64) + 1];\n-  interceptor_metadata_map =\n-      new ((void *)&metadata_mem) MetadataHashMap();  // NOLINT\n+  interceptor_metadata_map = new ((void *)&metadata_mem) MetadataHashMap();\n #endif\n \n   INIT_MMAP;\n@@ -9864,6 +9921,9 @@ static void InitializeCommonInterceptors() {\n   INIT_GETUSERSHELL;\n   INIT_SL_INIT;\n   INIT_GETRANDOM;\n+  INIT_CRYPT;\n+  INIT_CRYPT_R;\n+  INIT_GETENTROPY;\n \n   INIT___PRINTF_CHK;\n }"}, {"sha": "c78b6e10b689597dd0fafaff957384da299d38da", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interface.inc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface.inc?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -14,6 +14,7 @@ INTERFACE_FUNCTION(__sanitizer_set_death_callback)\n INTERFACE_FUNCTION(__sanitizer_set_report_path)\n INTERFACE_FUNCTION(__sanitizer_set_report_fd)\n INTERFACE_FUNCTION(__sanitizer_verify_contiguous_container)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_on_print)\n INTERFACE_WEAK_FUNCTION(__sanitizer_report_error_summary)\n INTERFACE_WEAK_FUNCTION(__sanitizer_sandbox_on_notify)\n // Sanitizer weak hooks"}, {"sha": "f18cee66b84318705f0fb87a7d460706926c50c0", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_fuchsia.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_fuchsia.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -36,7 +36,7 @@\n #include <zircon/sanitizer.h>\n #include <zircon/syscalls.h>\n \n-using namespace __sanitizer;  // NOLINT\n+using namespace __sanitizer;\n \n namespace __sancov {\n namespace {\n@@ -198,8 +198,8 @@ void InitializeCoverage(bool enabled, const char *dir) {\n }  // namespace __sanitizer\n \n extern \"C\" {\n-SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_dump_coverage(  // NOLINT\n-    const uptr *pcs, uptr len) {\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_dump_coverage(const uptr *pcs,\n+                                                             uptr len) {\n   UNIMPLEMENTED();\n }\n "}, {"sha": "6a75792f92624d29b16932c8c649c0c32c4fd0ee", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_libcdep_new.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep_new.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep_new.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep_new.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -166,8 +166,8 @@ void InitializeCoverage(bool enabled, const char *dir) {\n } // namespace __sanitizer\n \n extern \"C\" {\n-SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_dump_coverage(  // NOLINT\n-    const uptr* pcs, uptr len) {\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_dump_coverage(const uptr* pcs,\n+                                                             uptr len) {\n   return __sancov::SanitizerDumpCoverage(pcs, len);\n }\n "}, {"sha": "e7d6563393cfd596c9ed45a245cff0793203fa8c", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_win_sections.cpp", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_sections.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_sections.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_sections.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -31,7 +31,7 @@ extern \"C\" {\n // Use uint64_t so the linker won't need to add any padding if it tries to word\n // align the start of the 8-bit counters array. The array will always start 8\n // bytes after __start_sancov_cntrs.\n-#pragma section(\".SCOV$CA\", read, write)  // NOLINT\n+#pragma section(\".SCOV$CA\", read, write)\n __declspec(allocate(\".SCOV$CA\")) uint64_t __start___sancov_cntrs = 0;\n \n // Even though we said not to align __stop__sancov_cntrs (using the \"align\"\n@@ -41,13 +41,13 @@ __declspec(allocate(\".SCOV$CA\")) uint64_t __start___sancov_cntrs = 0;\n // padding would be added to align .SCOVP$Z, However, if .SCOV$CZ section is 1\n // byte, the linker won't try to align it on an 8-byte boundary, so use a\n // uint8_t for __stop_sancov_cntrs.\n-#pragma section(\".SCOV$CZ\", read, write)  // NOLINT\n+#pragma section(\".SCOV$CZ\", read, write)\n __declspec(allocate(\".SCOV$CZ\")) __declspec(align(1)) uint8_t\n     __stop___sancov_cntrs = 0;\n \n-#pragma section(\".SCOV$GA\", read, write)  // NOLINT\n+#pragma section(\".SCOV$GA\", read, write)\n __declspec(allocate(\".SCOV$GA\")) uint64_t __start___sancov_guards = 0;\n-#pragma section(\".SCOV$GZ\", read, write)  // NOLINT\n+#pragma section(\".SCOV$GZ\", read, write)\n __declspec(allocate(\".SCOV$GZ\")) __declspec(align(1)) uint8_t\n     __stop___sancov_guards = 0;\n \n@@ -56,9 +56,9 @@ __declspec(allocate(\".SCOV$GZ\")) __declspec(align(1)) uint8_t\n // constant it should be merged with the .rdata section.\n #pragma comment(linker, \"/MERGE:.SCOV=.data\")\n \n-#pragma section(\".SCOVP$A\", read)  // NOLINT\n+#pragma section(\".SCOVP$A\", read)\n __declspec(allocate(\".SCOVP$A\")) uint64_t __start___sancov_pcs = 0;\n-#pragma section(\".SCOVP$Z\", read)  // NOLINT\n+#pragma section(\".SCOVP$Z\", read)\n __declspec(allocate(\".SCOVP$Z\")) __declspec(align(1)) uint8_t\n     __stop___sancov_pcs = 0;\n "}, {"sha": "79930d79425016f1d3aefb53b826b2b1ff7a5ceb", "filename": "libsanitizer/sanitizer_common/sanitizer_file.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -199,7 +199,7 @@ char *FindPathToBinary(const char *name) {\n \n } // namespace __sanitizer\n \n-using namespace __sanitizer;  // NOLINT\n+using namespace __sanitizer;\n \n extern \"C\" {\n void __sanitizer_set_report_path(const char *path) {"}, {"sha": "1e2bc6652617965a6043fbf7a0cac4ae6753268a", "filename": "libsanitizer/sanitizer_common/sanitizer_flag_parser.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -83,8 +83,9 @@ void FlagParser::parse_flag(const char *env_option_name) {\n       Printf(\"%s: ERROR: expected '=' in %s\\n\", SanitizerToolName,\n              env_option_name);\n       Die();\n-    } else\n+    } else {\n       fatal_error(\"expected '='\");\n+    }\n   }\n   char *name = ll_strndup(buf_ + name_start, pos_ - name_start);\n "}, {"sha": "c24ad25626badc4e84a3e74c7996f0457d41701b", "filename": "libsanitizer/sanitizer_common/sanitizer_flag_parser.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -24,7 +24,7 @@ class FlagHandlerBase {\n   virtual bool Parse(const char *value) { return false; }\n \n  protected:\n-  ~FlagHandlerBase() {};\n+  ~FlagHandlerBase() {}\n };\n \n template <typename T>\n@@ -144,7 +144,7 @@ class FlagParser {\n template <typename T>\n static void RegisterFlag(FlagParser *parser, const char *name, const char *desc,\n                          T *var) {\n-  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);  // NOLINT\n+  FlagHandler<T> *fh = new (FlagParser::Alloc) FlagHandler<T>(var);\n   parser->RegisterHandler(name, fh, desc);\n }\n "}, {"sha": "66a0a5579ed386bc8104c3162c74fbd22a6d5d25", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -92,11 +92,11 @@ class FlagHandlerInclude : public FlagHandlerBase {\n };\n \n void RegisterIncludeFlags(FlagParser *parser, CommonFlags *cf) {\n-  FlagHandlerInclude *fh_include = new (FlagParser::Alloc) // NOLINT\n+  FlagHandlerInclude *fh_include = new (FlagParser::Alloc)\n       FlagHandlerInclude(parser, /*ignore_missing*/ false);\n   parser->RegisterHandler(\"include\", fh_include,\n                           \"read more options from the given file\");\n-  FlagHandlerInclude *fh_include_if_exists = new (FlagParser::Alloc) // NOLINT\n+  FlagHandlerInclude *fh_include_if_exists = new (FlagParser::Alloc)\n       FlagHandlerInclude(parser, /*ignore_missing*/ true);\n   parser->RegisterHandler(\n       \"include_if_exists\", fh_include_if_exists,"}, {"sha": "6e2c6137f0ce7fa25d2b07fee67ce6bf46161248", "filename": "libsanitizer/sanitizer_common/sanitizer_fuchsia.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -502,7 +502,7 @@ uptr GetRSS() { UNIMPLEMENTED(); }\n \n }  // namespace __sanitizer\n \n-using namespace __sanitizer;  // NOLINT\n+using namespace __sanitizer;\n \n extern \"C\" {\n void __sanitizer_startup_hook(int argc, char **argv, char **envp,"}, {"sha": "86ad3a5e2c2aa5ef498aa8ac3751e5b1873d0622", "filename": "libsanitizer/sanitizer_common/sanitizer_getauxval.h", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_getauxval.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_getauxval.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_getauxval.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -9,22 +9,18 @@\n // Common getauxval() guards and definitions.\n // getauxval() is not defined until glibc version 2.16, or until API level 21\n // for Android.\n+// Implement the getauxval() compat function for NetBSD.\n //\n //===----------------------------------------------------------------------===//\n \n #ifndef SANITIZER_GETAUXVAL_H\n #define SANITIZER_GETAUXVAL_H\n \n #include \"sanitizer_platform.h\"\n+#include \"sanitizer_glibc_version.h\"\n \n #if SANITIZER_LINUX || SANITIZER_FUCHSIA\n \n-# include <features.h>\n-\n-# ifndef __GLIBC_PREREQ\n-#  define __GLIBC_PREREQ(x, y) 0\n-# endif\n-\n # if __GLIBC_PREREQ(2, 16) || (SANITIZER_ANDROID && __ANDROID_API__ >= 21) || \\\n      SANITIZER_FUCHSIA\n #  define SANITIZER_USE_GETAUXVAL 1\n@@ -38,10 +34,26 @@\n // The weak getauxval definition allows to check for the function at runtime.\n // This is useful for Android, when compiled at a lower API level yet running\n // on a more recent platform that offers the function.\n-extern \"C\" SANITIZER_WEAK_ATTRIBUTE\n-unsigned long getauxval(unsigned long type);  // NOLINT\n+extern \"C\" SANITIZER_WEAK_ATTRIBUTE unsigned long getauxval(unsigned long type);\n # endif\n \n-#endif // SANITIZER_LINUX || SANITIZER_FUCHSIA\n+#elif SANITIZER_NETBSD\n+\n+#define SANITIZER_USE_GETAUXVAL 1\n+\n+#include <dlfcn.h>\n+#include <elf.h>\n+\n+static inline decltype(AuxInfo::a_v) getauxval(decltype(AuxInfo::a_type) type) {\n+  for (const AuxInfo *aux = (const AuxInfo *)_dlauxinfo();\n+       aux->a_type != AT_NULL; ++aux) {\n+    if (type == aux->a_type)\n+      return aux->a_v;\n+  }\n+\n+  return 0;\n+}\n+\n+#endif\n \n #endif // SANITIZER_GETAUXVAL_H"}, {"sha": "47175f20aa01a0e2d5613145ff9b52ce15775f38", "filename": "libsanitizer/sanitizer_common/sanitizer_glibc_version.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_glibc_version.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_glibc_version.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_glibc_version.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -0,0 +1,26 @@\n+//===-- sanitizer_glibc_version.h -----------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of Sanitizer common code.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_GLIBC_VERSION_H\n+#define SANITIZER_GLIBC_VERSION_H\n+\n+#include \"sanitizer_platform.h\"\n+\n+#if SANITIZER_LINUX || SANITIZER_FUCHSIA\n+#include <features.h>\n+#endif\n+\n+#ifndef __GLIBC_PREREQ\n+#define __GLIBC_PREREQ(x, y) 0\n+#endif\n+\n+#endif"}, {"sha": "03ef7c1788cdb1658adfb99be9c6fe1a59849d09", "filename": "libsanitizer/sanitizer_common/sanitizer_interceptors_ioctl_netbsd.inc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_interceptors_ioctl_netbsd.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_interceptors_ioctl_netbsd.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_interceptors_ioctl_netbsd.inc?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -1404,7 +1404,7 @@ static void ioctl_table_fill() {\n   _(SNDCTL_DSP_SKIP, NONE, 0);\n   _(SNDCTL_DSP_SILENCE, NONE, 0);\n #undef _\n-}\n+}  // NOLINT\n \n static bool ioctl_initialized = false;\n "}, {"sha": "00226305e07cef5be10e682c30d1e80ae75bc0a6", "filename": "libsanitizer/sanitizer_common/sanitizer_internal_defs.h", "status": "modified", "additions": 49, "deletions": 26, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -133,27 +133,27 @@ namespace __sanitizer {\n \n #if defined(_WIN64)\n // 64-bit Windows uses LLP64 data model.\n-typedef unsigned long long uptr;  // NOLINT\n-typedef signed   long long sptr;  // NOLINT\n+typedef unsigned long long uptr;\n+typedef signed long long sptr;\n #else\n-typedef unsigned long uptr;  // NOLINT\n-typedef signed   long sptr;  // NOLINT\n+typedef unsigned long uptr;\n+typedef signed long sptr;\n #endif  // defined(_WIN64)\n #if defined(__x86_64__)\n // Since x32 uses ILP32 data model in 64-bit hardware mode, we must use\n // 64-bit pointer to unwind stack frame.\n-typedef unsigned long long uhwptr;  // NOLINT\n+typedef unsigned long long uhwptr;\n #else\n-typedef uptr uhwptr;   // NOLINT\n+typedef uptr uhwptr;\n #endif\n typedef unsigned char u8;\n-typedef unsigned short u16;  // NOLINT\n+typedef unsigned short u16;\n typedef unsigned int u32;\n-typedef unsigned long long u64;  // NOLINT\n-typedef signed   char s8;\n-typedef signed   short s16;  // NOLINT\n-typedef signed   int s32;\n-typedef signed   long long s64;  // NOLINT\n+typedef unsigned long long u64;\n+typedef signed char s8;\n+typedef signed short s16;\n+typedef signed int s32;\n+typedef signed long long s64;\n #if SANITIZER_WINDOWS\n // On Windows, files are HANDLE, which is a synonim of void*.\n // Use void* to avoid including <windows.h> everywhere.\n@@ -264,7 +264,7 @@ typedef ALIGNED(1) s64 us64;\n \n #if SANITIZER_WINDOWS\n }  // namespace __sanitizer\n-typedef unsigned long DWORD;  // NOLINT\n+typedef unsigned long DWORD;\n namespace __sanitizer {\n typedef DWORD thread_return_t;\n # define THREAD_CALLING_CONV __stdcall\n@@ -419,18 +419,41 @@ inline void Trap() {\n \n }  // namespace __sanitizer\n \n-namespace __asan  { using namespace __sanitizer; }  // NOLINT\n-namespace __dsan  { using namespace __sanitizer; }  // NOLINT\n-namespace __dfsan { using namespace __sanitizer; }  // NOLINT\n-namespace __lsan  { using namespace __sanitizer; }  // NOLINT\n-namespace __msan  { using namespace __sanitizer; }  // NOLINT\n-namespace __hwasan  { using namespace __sanitizer; }  // NOLINT\n-namespace __tsan  { using namespace __sanitizer; }  // NOLINT\n-namespace __scudo { using namespace __sanitizer; }  // NOLINT\n-namespace __ubsan { using namespace __sanitizer; }  // NOLINT\n-namespace __xray  { using namespace __sanitizer; }  // NOLINT\n-namespace __interception  { using namespace __sanitizer; }  // NOLINT\n-namespace __hwasan  { using namespace __sanitizer; }  // NOLINT\n-\n+namespace __asan {\n+using namespace __sanitizer;\n+}\n+namespace __dsan {\n+using namespace __sanitizer;\n+}\n+namespace __dfsan {\n+using namespace __sanitizer;\n+}\n+namespace __lsan {\n+using namespace __sanitizer;\n+}\n+namespace __msan {\n+using namespace __sanitizer;\n+}\n+namespace __hwasan {\n+using namespace __sanitizer;\n+}\n+namespace __tsan {\n+using namespace __sanitizer;\n+}\n+namespace __scudo {\n+using namespace __sanitizer;\n+}\n+namespace __ubsan {\n+using namespace __sanitizer;\n+}\n+namespace __xray {\n+using namespace __sanitizer;\n+}\n+namespace __interception {\n+using namespace __sanitizer;\n+}\n+namespace __hwasan {\n+using namespace __sanitizer;\n+}\n \n #endif  // SANITIZER_DEFS_H"}, {"sha": "4bc04b486870c6e459ef969e67bcec498c991b02", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.cpp", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -63,10 +63,11 @@ void *internal_memmove(void *dest, const void *src, uptr n) {\n     for (i = 0; i < signed_n; ++i)\n       d[i] = s[i];\n   } else {\n-    if (d > s && signed_n > 0)\n-      for (i = signed_n - 1; i >= 0 ; --i) {\n+    if (d > s && signed_n > 0) {\n+      for (i = signed_n - 1; i >= 0; --i) {\n         d[i] = s[i];\n       }\n+    }\n   }\n   return dest;\n }\n@@ -270,9 +271,9 @@ bool mem_is_zero(const char *beg, uptr size) {\n   for (; aligned_beg < aligned_end; aligned_beg++)\n     all |= *aligned_beg;\n   // Epilogue.\n-  if ((char*)aligned_end >= beg)\n-    for (const char *mem = (char*)aligned_end; mem < end; mem++)\n-      all |= *mem;\n+  if ((char *)aligned_end >= beg) {\n+    for (const char *mem = (char *)aligned_end; mem < end; mem++) all |= *mem;\n+  }\n   return all == 0;\n }\n "}, {"sha": "0b53da6c349f281b302c98977f6b619f83e4ab04", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cpp", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -1062,8 +1062,6 @@ uptr GetMaxUserVirtualAddress() {\n uptr GetPageSize() {\n #if SANITIZER_LINUX && (defined(__x86_64__) || defined(__i386__))\n   return EXEC_PAGESIZE;\n-#elif SANITIZER_USE_GETAUXVAL\n-  return getauxval(AT_PAGESZ);\n #elif SANITIZER_FREEBSD || SANITIZER_NETBSD\n // Use sysctl as sysconf can trigger interceptors internally.\n   int pz = 0;\n@@ -1072,6 +1070,8 @@ uptr GetPageSize() {\n   int rv = internal_sysctl(mib, 2, &pz, &pzl, nullptr, 0);\n   CHECK_EQ(rv, 0);\n   return (uptr)pz;\n+#elif SANITIZER_USE_GETAUXVAL\n+  return getauxval(AT_PAGESZ);\n #else\n   return sysconf(_SC_PAGESIZE);  // EXEC_PAGESIZE may not be trustworthy.\n #endif\n@@ -1849,6 +1849,12 @@ SignalContext::WriteFlag SignalContext::GetWriteFlag() const {\n #endif\n }\n \n+bool SignalContext::IsTrueFaultingAddress() const {\n+  auto si = static_cast<const siginfo_t *>(siginfo);\n+  // SIGSEGV signals without a true fault address have si_code set to 128.\n+  return si->si_signo == SIGSEGV && si->si_code != 128;\n+}\n+\n void SignalContext::DumpAllRegisters(void *context) {\n   // FIXME: Implement this.\n }\n@@ -2011,6 +2017,35 @@ void CheckASLR() {\n     CHECK_NE(personality(old_personality | ADDR_NO_RANDOMIZE), -1);\n     ReExec();\n   }\n+#elif SANITIZER_FREEBSD\n+  int aslr_pie;\n+  uptr len = sizeof(aslr_pie);\n+#if SANITIZER_WORDSIZE == 64\n+  if (UNLIKELY(internal_sysctlbyname(\"kern.elf64.aslr.pie_enable\",\n+      &aslr_pie, &len, NULL, 0) == -1)) {\n+    // We're making things less 'dramatic' here since\n+    // the OID is not necessarily guaranteed to be here\n+    // just yet regarding FreeBSD release\n+    return;\n+  }\n+\n+  if (aslr_pie > 0) {\n+    Printf(\"This sanitizer is not compatible with enabled ASLR \"\n+           \"and binaries compiled with PIE\\n\");\n+    Die();\n+  }\n+#endif\n+  // there might be 32 bits compat for 64 bits\n+  if (UNLIKELY(internal_sysctlbyname(\"kern.elf32.aslr.pie_enable\",\n+      &aslr_pie, &len, NULL, 0) == -1)) {\n+    return;\n+  }\n+\n+  if (aslr_pie > 0) {\n+    Printf(\"This sanitizer is not compatible with enabled ASLR \"\n+           \"and binaries compiled with PIE\\n\");\n+    Die();\n+  }\n #else\n   // Do nothing\n #endif"}, {"sha": "cd503718205a18807445b65c126296005d3ecd77", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cpp", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -23,6 +23,7 @@\n #include \"sanitizer_flags.h\"\n #include \"sanitizer_freebsd.h\"\n #include \"sanitizer_getauxval.h\"\n+#include \"sanitizer_glibc_version.h\"\n #include \"sanitizer_linux.h\"\n #include \"sanitizer_placement_new.h\"\n #include \"sanitizer_procmaps.h\"\n@@ -188,11 +189,7 @@ __attribute__((unused)) static bool GetLibcVersion(int *major, int *minor,\n static uptr g_tls_size;\n \n #ifdef __i386__\n-# ifndef __GLIBC_PREREQ\n-#  define CHECK_GET_TLS_STATIC_INFO_VERSION 1\n-# else\n-#  define CHECK_GET_TLS_STATIC_INFO_VERSION (!__GLIBC_PREREQ(2, 27))\n-# endif\n+# define CHECK_GET_TLS_STATIC_INFO_VERSION (!__GLIBC_PREREQ(2, 27))\n #else\n # define CHECK_GET_TLS_STATIC_INFO_VERSION 0\n #endif\n@@ -701,13 +698,9 @@ u32 GetNumberOfCPUs() {\n #elif SANITIZER_SOLARIS\n   return sysconf(_SC_NPROCESSORS_ONLN);\n #else\n-#if defined(CPU_COUNT)\n   cpu_set_t CPUs;\n   CHECK_EQ(sched_getaffinity(0, sizeof(cpu_set_t), &CPUs), 0);\n   return CPU_COUNT(&CPUs);\n-#else\n-  return 1;\n-#endif\n #endif\n }\n "}, {"sha": "ea4bd02aa92e4580bcf4f1c49a540722d70af9b7", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cpp", "status": "modified", "additions": 105, "deletions": 21, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -13,6 +13,7 @@\n #include \"sanitizer_platform.h\"\n #if SANITIZER_MAC\n #include \"sanitizer_mac.h\"\n+#include \"interception/interception.h\"\n \n // Use 64-bit inodes in file operations. ASan does not support OS X 10.5, so\n // the clients will most certainly use 64-bit ones as well.\n@@ -36,7 +37,7 @@\n extern char **environ;\n #endif\n \n-#if defined(__has_include) && __has_include(<os/trace.h>) && defined(__BLOCKS__)\n+#if defined(__has_include) && __has_include(<os/trace.h>)\n #define SANITIZER_OS_TRACE 1\n #include <os/trace.h>\n #else\n@@ -64,7 +65,9 @@ extern \"C\" {\n #include <pthread.h>\n #include <sched.h>\n #include <signal.h>\n+#include <spawn.h>\n #include <stdlib.h>\n+#include <sys/ioctl.h>\n #include <sys/mman.h>\n #include <sys/resource.h>\n #include <sys/stat.h>\n@@ -239,27 +242,102 @@ int internal_sysctlbyname(const char *sname, void *oldp, uptr *oldlenp,\n                       (size_t)newlen);\n }\n \n-int internal_forkpty(int *aparent) {\n-  int parent, worker;\n-  if (openpty(&parent, &worker, nullptr, nullptr, nullptr) == -1) return -1;\n-  int pid = internal_fork();\n-  if (pid == -1) {\n-    close(parent);\n-    close(worker);\n-    return -1;\n+static fd_t internal_spawn_impl(const char *argv[], pid_t *pid) {\n+  fd_t master_fd = kInvalidFd;\n+  fd_t slave_fd = kInvalidFd;\n+\n+  auto fd_closer = at_scope_exit([&] {\n+    internal_close(master_fd);\n+    internal_close(slave_fd);\n+  });\n+\n+  // We need a new pseudoterminal to avoid buffering problems. The 'atos' tool\n+  // in particular detects when it's talking to a pipe and forgets to flush the\n+  // output stream after sending a response.\n+  master_fd = posix_openpt(O_RDWR);\n+  if (master_fd == kInvalidFd) return kInvalidFd;\n+\n+  int res = grantpt(master_fd) || unlockpt(master_fd);\n+  if (res != 0) return kInvalidFd;\n+\n+  // Use TIOCPTYGNAME instead of ptsname() to avoid threading problems.\n+  char slave_pty_name[128];\n+  res = ioctl(master_fd, TIOCPTYGNAME, slave_pty_name);\n+  if (res == -1) return kInvalidFd;\n+\n+  slave_fd = internal_open(slave_pty_name, O_RDWR);\n+  if (slave_fd == kInvalidFd) return kInvalidFd;\n+\n+  // File descriptor actions\n+  posix_spawn_file_actions_t acts;\n+  res = posix_spawn_file_actions_init(&acts);\n+  if (res != 0) return kInvalidFd;\n+\n+  auto acts_cleanup = at_scope_exit([&] {\n+    posix_spawn_file_actions_destroy(&acts);\n+  });\n+\n+  res = posix_spawn_file_actions_adddup2(&acts, slave_fd, STDIN_FILENO) ||\n+        posix_spawn_file_actions_adddup2(&acts, slave_fd, STDOUT_FILENO) ||\n+        posix_spawn_file_actions_addclose(&acts, slave_fd);\n+  if (res != 0) return kInvalidFd;\n+\n+  // Spawn attributes\n+  posix_spawnattr_t attrs;\n+  res = posix_spawnattr_init(&attrs);\n+  if (res != 0) return kInvalidFd;\n+\n+  auto attrs_cleanup  = at_scope_exit([&] {\n+    posix_spawnattr_destroy(&attrs);\n+  });\n+\n+  // In the spawned process, close all file descriptors that are not explicitly\n+  // described by the file actions object. This is Darwin-specific extension.\n+  res = posix_spawnattr_setflags(&attrs, POSIX_SPAWN_CLOEXEC_DEFAULT);\n+  if (res != 0) return kInvalidFd;\n+\n+  // posix_spawn\n+  char **argv_casted = const_cast<char **>(argv);\n+  char **env = GetEnviron();\n+  res = posix_spawn(pid, argv[0], &acts, &attrs, argv_casted, env);\n+  if (res != 0) return kInvalidFd;\n+\n+  // Disable echo in the new terminal, disable CR.\n+  struct termios termflags;\n+  tcgetattr(master_fd, &termflags);\n+  termflags.c_oflag &= ~ONLCR;\n+  termflags.c_lflag &= ~ECHO;\n+  tcsetattr(master_fd, TCSANOW, &termflags);\n+\n+  // On success, do not close master_fd on scope exit.\n+  fd_t fd = master_fd;\n+  master_fd = kInvalidFd;\n+\n+  return fd;\n+}\n+\n+fd_t internal_spawn(const char *argv[], pid_t *pid) {\n+  // The client program may close its stdin and/or stdout and/or stderr thus\n+  // allowing open/posix_openpt to reuse file descriptors 0, 1 or 2. In this\n+  // case the communication is broken if either the parent or the child tries to\n+  // close or duplicate these descriptors. We temporarily reserve these\n+  // descriptors here to prevent this.\n+  fd_t low_fds[3];\n+  size_t count = 0;\n+\n+  for (; count < 3; count++) {\n+    low_fds[count] = posix_openpt(O_RDWR);\n+    if (low_fds[count] >= STDERR_FILENO)\n+      break;\n   }\n-  if (pid == 0) {\n-    close(parent);\n-    if (login_tty(worker) != 0) {\n-      // We already forked, there's not much we can do.  Let's quit.\n-      Report(\"login_tty failed (errno %d)\\n\", errno);\n-      internal__exit(1);\n-    }\n-  } else {\n-    *aparent = parent;\n-    close(worker);\n+\n+  fd_t fd = internal_spawn_impl(argv, pid);\n+\n+  for (; count > 0; count--) {\n+    internal_close(low_fds[count]);\n   }\n-  return pid;\n+\n+  return fd;\n }\n \n uptr internal_rename(const char *oldpath, const char *newpath) {\n@@ -676,6 +754,12 @@ SignalContext::WriteFlag SignalContext::GetWriteFlag() const {\n #endif\n }\n \n+bool SignalContext::IsTrueFaultingAddress() const {\n+  auto si = static_cast<const siginfo_t *>(siginfo);\n+  // \"Real\" SIGSEGV codes (e.g., SEGV_MAPERR, SEGV_MAPERR) are non-zero.\n+  return si->si_signo == SIGSEGV && si->si_code != 0;\n+}\n+\n static void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n   ucontext_t *ucontext = (ucontext_t*)context;\n # if defined(__aarch64__)\n@@ -1122,7 +1206,7 @@ bool GetRandom(void *buffer, uptr length, bool blocking) {\n   if (!buffer || !length || length > 256)\n     return false;\n   // arc4random never fails.\n-  arc4random_buf(buffer, length);\n+  REAL(arc4random_buf)(buffer, length);\n   return true;\n }\n "}, {"sha": "61a6b82ef8184b98833ca482b6040cc6a9d3f198", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -13,6 +13,7 @@\n #ifndef SANITIZER_PLATFORM_INTERCEPTORS_H\n #define SANITIZER_PLATFORM_INTERCEPTORS_H\n \n+#include \"sanitizer_glibc_version.h\"\n #include \"sanitizer_internal_defs.h\"\n \n #if SANITIZER_POSIX\n@@ -331,10 +332,9 @@\n #define SANITIZER_INTERCEPT_ETHER_HOST \\\n   (SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_ETHER_R (SI_FREEBSD || SI_LINUX_NOT_ANDROID)\n-#define SANITIZER_INTERCEPT_SHMCTL          \\\n-  (SI_NETBSD || SI_OPENBSD || SI_SOLARIS || \\\n-  ((SI_FREEBSD || SI_LINUX_NOT_ANDROID) && \\\n-    SANITIZER_WORDSIZE == 64))  // NOLINT\n+#define SANITIZER_INTERCEPT_SHMCTL                                       \\\n+  (((SI_FREEBSD || SI_LINUX_NOT_ANDROID) && SANITIZER_WORDSIZE == 64) || \\\n+   SI_NETBSD || SI_OPENBSD || SI_SOLARIS)  // NOLINT\n #define SANITIZER_INTERCEPT_RANDOM_R SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PTHREAD_ATTR_GET SI_POSIX\n #define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSCHED \\\n@@ -489,7 +489,8 @@\n   SI_NOT_RTEMS)\n #define SANITIZER_INTERCEPT_REALLOCARRAY SI_POSIX\n #define SANITIZER_INTERCEPT_ALIGNED_ALLOC (!SI_MAC && SI_NOT_RTEMS)\n-#define SANITIZER_INTERCEPT_MALLOC_USABLE_SIZE (!SI_MAC && !SI_OPENBSD)\n+#define SANITIZER_INTERCEPT_MALLOC_USABLE_SIZE \\\n+  (!SI_MAC && !SI_OPENBSD && !SI_NETBSD)\n #define SANITIZER_INTERCEPT_MCHECK_MPROBE SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_WCSCAT SI_POSIX\n #define SANITIZER_INTERCEPT_WCSDUP SI_POSIX\n@@ -561,11 +562,18 @@\n #define SANITIZER_INTERCEPT_FUNOPEN (SI_NETBSD || SI_FREEBSD)\n #define SANITIZER_INTERCEPT_FUNOPEN2 SI_NETBSD\n #define SANITIZER_INTERCEPT_GETFSENT (SI_FREEBSD || SI_NETBSD || SI_MAC)\n-#define SANITIZER_INTERCEPT_ARC4RANDOM (SI_FREEBSD || SI_NETBSD)\n+#define SANITIZER_INTERCEPT_ARC4RANDOM (SI_FREEBSD || SI_NETBSD || SI_MAC)\n #define SANITIZER_INTERCEPT_FDEVNAME SI_FREEBSD\n #define SANITIZER_INTERCEPT_GETUSERSHELL (SI_POSIX && !SI_ANDROID)\n #define SANITIZER_INTERCEPT_SL_INIT (SI_FREEBSD || SI_NETBSD)\n-\n-#define SANITIZER_INTERCEPT_GETRANDOM SI_LINUX\n+#define SANITIZER_INTERCEPT_CRYPT (SI_POSIX && !SI_ANDROID)\n+#define SANITIZER_INTERCEPT_CRYPT_R (SI_LINUX && !SI_ANDROID)\n+\n+#define SANITIZER_INTERCEPT_GETRANDOM \\\n+  ((SI_LINUX && __GLIBC_PREREQ(2, 25)) || SI_FREEBSD)\n+#define SANITIZER_INTERCEPT___CXA_ATEXIT SI_NETBSD\n+#define SANITIZER_INTERCEPT_ATEXIT SI_NETBSD\n+#define SANITIZER_INTERCEPT_PTHREAD_ATFORK SI_NETBSD\n+#define SANITIZER_INTERCEPT_GETENTROPY SI_FREEBSD\n \n #endif  // #ifndef SANITIZER_PLATFORM_INTERCEPTORS_H"}, {"sha": "71cf5b9c35715c85a26018d3824212a5689305db", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_freebsd.h", "status": "modified", "additions": 545, "deletions": 545, "changes": 1090, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -30,373 +30,373 @@\n #include <sys/_types.h>\n \n namespace __sanitizer {\n-  extern unsigned struct_utsname_sz;\n-  extern unsigned struct_stat_sz;\n+extern unsigned struct_utsname_sz;\n+extern unsigned struct_stat_sz;\n #if defined(__powerpc64__)\n-  const unsigned struct___old_kernel_stat_sz = 0;\n+const unsigned struct___old_kernel_stat_sz = 0;\n #else\n-  const unsigned struct___old_kernel_stat_sz = 32;\n+const unsigned struct___old_kernel_stat_sz = 32;\n #endif\n-  extern unsigned struct_rusage_sz;\n-  extern unsigned siginfo_t_sz;\n-  extern unsigned struct_itimerval_sz;\n-  extern unsigned pthread_t_sz;\n-  extern unsigned pthread_mutex_t_sz;\n-  extern unsigned pthread_cond_t_sz;\n-  extern unsigned pid_t_sz;\n-  extern unsigned timeval_sz;\n-  extern unsigned uid_t_sz;\n-  extern unsigned gid_t_sz;\n-  extern unsigned fpos_t_sz;\n-  extern unsigned mbstate_t_sz;\n-  extern unsigned struct_timezone_sz;\n-  extern unsigned struct_tms_sz;\n-  extern unsigned struct_itimerspec_sz;\n-  extern unsigned struct_sigevent_sz;\n-  extern unsigned struct_sched_param_sz;\n-  extern unsigned struct_statfs64_sz;\n-  extern unsigned struct_statfs_sz;\n-  extern unsigned struct_sockaddr_sz;\n-  extern unsigned ucontext_t_sz;\n-  extern unsigned struct_rlimit_sz;\n-  extern unsigned struct_utimbuf_sz;\n-  extern unsigned struct_timespec_sz;\n-  extern unsigned struct_regmatch_sz;\n-  extern unsigned struct_regex_sz;\n-  extern unsigned struct_FTS_sz;\n-  extern unsigned struct_FTSENT_sz;\n-  extern const int unvis_valid;\n-  extern const int unvis_validpush;\n-\n-  struct __sanitizer_iocb {\n-    u64   aio_data;\n-    u32   aio_key_or_aio_reserved1; // Simply crazy.\n-    u32   aio_reserved1_or_aio_key; // Luckily, we don't need these.\n-    u16   aio_lio_opcode;\n-    s16   aio_reqprio;\n-    u32   aio_fildes;\n-    u64   aio_buf;\n-    u64   aio_nbytes;\n-    s64   aio_offset;\n-    u64   aio_reserved2;\n-    u64   aio_reserved3;\n-  };\n-\n-  struct __sanitizer_io_event {\n-    u64 data;\n-    u64 obj;\n-    u64 res;\n-    u64 res2;\n-  };\n-\n-  const unsigned iocb_cmd_pread = 0;\n-  const unsigned iocb_cmd_pwrite = 1;\n-  const unsigned iocb_cmd_preadv = 7;\n-  const unsigned iocb_cmd_pwritev = 8;\n-\n-  struct __sanitizer___sysctl_args {\n-    int *name;\n-    int nlen;\n-    void *oldval;\n-    uptr *oldlenp;\n-    void *newval;\n-    uptr newlen;\n-    unsigned long ___unused[4];\n-  };\n-\n-  struct __sanitizer_ipc_perm {\n-    unsigned int cuid;\n-    unsigned int cgid;\n-    unsigned int uid;\n-    unsigned int gid;\n-    unsigned short mode;\n-    unsigned short seq;\n-    long key;\n-  };\n-\n-  struct __sanitizer_shmid_ds {\n-    __sanitizer_ipc_perm shm_perm;\n-    unsigned long shm_segsz;\n-    unsigned int shm_lpid;\n-    unsigned int shm_cpid;\n-    int shm_nattch;\n-    unsigned long shm_atime;\n-    unsigned long shm_dtime;\n-    unsigned long shm_ctime;\n-  };\n-\n-  extern unsigned struct_msqid_ds_sz;\n-  extern unsigned struct_mq_attr_sz;\n-  extern unsigned struct_timeb_sz;\n-  extern unsigned struct_statvfs_sz;\n-\n-  struct __sanitizer_iovec {\n-    void *iov_base;\n-    uptr iov_len;\n-  };\n-\n-  struct __sanitizer_ifaddrs {\n-    struct __sanitizer_ifaddrs *ifa_next;\n-    char *ifa_name;\n-    unsigned int ifa_flags;\n-    void *ifa_addr;    // (struct sockaddr *)\n-    void *ifa_netmask; // (struct sockaddr *)\n-# undef ifa_dstaddr\n-    void *ifa_dstaddr; // (struct sockaddr *)\n-    void *ifa_data;\n-  };\n-\n-  typedef unsigned __sanitizer_pthread_key_t;\n-\n-  struct __sanitizer_passwd {\n-    char *pw_name;\n-    char *pw_passwd;\n-    int pw_uid;\n-    int pw_gid;\n-    long pw_change;\n-    char *pw_class;\n-    char *pw_gecos;\n-    char *pw_dir;\n-    char *pw_shell;\n-    long pw_expire;\n-    int pw_fields;\n-  };\n-\n-  struct __sanitizer_group {\n-    char *gr_name;\n-    char *gr_passwd;\n-    int gr_gid;\n-    char **gr_mem;\n-  };\n-\n-#if defined(__LP64___)\n-  typedef long long __sanitizer_time_t;\n+extern unsigned struct_rusage_sz;\n+extern unsigned siginfo_t_sz;\n+extern unsigned struct_itimerval_sz;\n+extern unsigned pthread_t_sz;\n+extern unsigned pthread_mutex_t_sz;\n+extern unsigned pthread_cond_t_sz;\n+extern unsigned pid_t_sz;\n+extern unsigned timeval_sz;\n+extern unsigned uid_t_sz;\n+extern unsigned gid_t_sz;\n+extern unsigned fpos_t_sz;\n+extern unsigned mbstate_t_sz;\n+extern unsigned struct_timezone_sz;\n+extern unsigned struct_tms_sz;\n+extern unsigned struct_itimerspec_sz;\n+extern unsigned struct_sigevent_sz;\n+extern unsigned struct_sched_param_sz;\n+extern unsigned struct_statfs64_sz;\n+extern unsigned struct_statfs_sz;\n+extern unsigned struct_sockaddr_sz;\n+extern unsigned ucontext_t_sz;\n+extern unsigned struct_rlimit_sz;\n+extern unsigned struct_utimbuf_sz;\n+extern unsigned struct_timespec_sz;\n+extern unsigned struct_regmatch_sz;\n+extern unsigned struct_regex_sz;\n+extern unsigned struct_FTS_sz;\n+extern unsigned struct_FTSENT_sz;\n+extern const int unvis_valid;\n+extern const int unvis_validpush;\n+\n+struct __sanitizer_iocb {\n+  u64 aio_data;\n+  u32 aio_key_or_aio_reserved1;  // Simply crazy.\n+  u32 aio_reserved1_or_aio_key;  // Luckily, we don't need these.\n+  u16 aio_lio_opcode;\n+  s16 aio_reqprio;\n+  u32 aio_fildes;\n+  u64 aio_buf;\n+  u64 aio_nbytes;\n+  s64 aio_offset;\n+  u64 aio_reserved2;\n+  u64 aio_reserved3;\n+};\n+\n+struct __sanitizer_io_event {\n+  u64 data;\n+  u64 obj;\n+  u64 res;\n+  u64 res2;\n+};\n+\n+const unsigned iocb_cmd_pread = 0;\n+const unsigned iocb_cmd_pwrite = 1;\n+const unsigned iocb_cmd_preadv = 7;\n+const unsigned iocb_cmd_pwritev = 8;\n+\n+struct __sanitizer___sysctl_args {\n+  int *name;\n+  int nlen;\n+  void *oldval;\n+  uptr *oldlenp;\n+  void *newval;\n+  uptr newlen;\n+  unsigned long ___unused[4];\n+};\n+\n+struct __sanitizer_ipc_perm {\n+  unsigned int cuid;\n+  unsigned int cgid;\n+  unsigned int uid;\n+  unsigned int gid;\n+  unsigned short mode;\n+  unsigned short seq;\n+  long key;\n+};\n+\n+#if !defined(__i386__)\n+typedef long long __sanitizer_time_t;\n #else\n-  typedef long __sanitizer_time_t;\n+typedef long __sanitizer_time_t;\n #endif\n \n-  typedef long __sanitizer_suseconds_t;\n-\n-  struct __sanitizer_timeval {\n-    __sanitizer_time_t tv_sec;\n-    __sanitizer_suseconds_t tv_usec;\n-  };\n-\n-  struct __sanitizer_itimerval {\n-    struct __sanitizer_timeval it_interval;\n-    struct __sanitizer_timeval it_value;\n-  };\n-\n-  struct __sanitizer_timeb {\n-    __sanitizer_time_t time;\n-    unsigned short millitm;\n-    short timezone;\n-    short dstflag;\n-  };\n-\n-  struct __sanitizer_ether_addr {\n-    u8 octet[6];\n-  };\n-\n-  struct __sanitizer_tm {\n-    int tm_sec;\n-    int tm_min;\n-    int tm_hour;\n-    int tm_mday;\n-    int tm_mon;\n-    int tm_year;\n-    int tm_wday;\n-    int tm_yday;\n-    int tm_isdst;\n-    long int tm_gmtoff;\n-    const char *tm_zone;\n-  };\n-\n-  struct __sanitizer_msghdr {\n-    void *msg_name;\n-    unsigned msg_namelen;\n-    struct __sanitizer_iovec *msg_iov;\n-    unsigned msg_iovlen;\n-    void *msg_control;\n-    unsigned msg_controllen;\n-    int msg_flags;\n-  };\n-\n-  struct __sanitizer_cmsghdr {\n-    unsigned cmsg_len;\n-    int cmsg_level;\n-    int cmsg_type;\n-  };\n-\n-  struct __sanitizer_dirent {\n+struct __sanitizer_shmid_ds {\n+  __sanitizer_ipc_perm shm_perm;\n+  unsigned long shm_segsz;\n+  unsigned int shm_lpid;\n+  unsigned int shm_cpid;\n+  int shm_nattch;\n+  __sanitizer_time_t shm_atime;\n+  __sanitizer_time_t shm_dtime;\n+  __sanitizer_time_t shm_ctime;\n+};\n+\n+extern unsigned struct_msqid_ds_sz;\n+extern unsigned struct_mq_attr_sz;\n+extern unsigned struct_timeb_sz;\n+extern unsigned struct_statvfs_sz;\n+\n+struct __sanitizer_iovec {\n+  void *iov_base;\n+  uptr iov_len;\n+};\n+\n+struct __sanitizer_ifaddrs {\n+  struct __sanitizer_ifaddrs *ifa_next;\n+  char *ifa_name;\n+  unsigned int ifa_flags;\n+  void *ifa_addr;     // (struct sockaddr *)\n+  void *ifa_netmask;  // (struct sockaddr *)\n+# undef ifa_dstaddr\n+  void *ifa_dstaddr;  // (struct sockaddr *)\n+  void *ifa_data;\n+};\n+\n+typedef unsigned __sanitizer_pthread_key_t;\n+\n+struct __sanitizer_passwd {\n+  char *pw_name;\n+  char *pw_passwd;\n+  int pw_uid;\n+  int pw_gid;\n+  __sanitizer_time_t pw_change;\n+  char *pw_class;\n+  char *pw_gecos;\n+  char *pw_dir;\n+  char *pw_shell;\n+  __sanitizer_time_t pw_expire;\n+  int pw_fields;\n+};\n+\n+struct __sanitizer_group {\n+  char *gr_name;\n+  char *gr_passwd;\n+  int gr_gid;\n+  char **gr_mem;\n+};\n+\n+typedef long __sanitizer_suseconds_t;\n+\n+struct __sanitizer_timeval {\n+  __sanitizer_time_t tv_sec;\n+  __sanitizer_suseconds_t tv_usec;\n+};\n+\n+struct __sanitizer_itimerval {\n+  struct __sanitizer_timeval it_interval;\n+  struct __sanitizer_timeval it_value;\n+};\n+\n+struct __sanitizer_timeb {\n+  __sanitizer_time_t time;\n+  unsigned short millitm;\n+  short timezone;\n+  short dstflag;\n+};\n+\n+struct __sanitizer_ether_addr {\n+  u8 octet[6];\n+};\n+\n+struct __sanitizer_tm {\n+  int tm_sec;\n+  int tm_min;\n+  int tm_hour;\n+  int tm_mday;\n+  int tm_mon;\n+  int tm_year;\n+  int tm_wday;\n+  int tm_yday;\n+  int tm_isdst;\n+  long int tm_gmtoff;\n+  const char *tm_zone;\n+};\n+\n+struct __sanitizer_msghdr {\n+  void *msg_name;\n+  unsigned msg_namelen;\n+  struct __sanitizer_iovec *msg_iov;\n+  unsigned msg_iovlen;\n+  void *msg_control;\n+  unsigned msg_controllen;\n+  int msg_flags;\n+};\n+\n+struct __sanitizer_cmsghdr {\n+  unsigned cmsg_len;\n+  int cmsg_level;\n+  int cmsg_type;\n+};\n+\n+struct __sanitizer_dirent {\n #if defined(__INO64)\n-    unsigned long long d_fileno;\n-    unsigned long long d_off;\n+  unsigned long long d_fileno;\n+  unsigned long long d_off;\n #else\n-    unsigned int d_fileno;\n+  unsigned int d_fileno;\n #endif\n-    unsigned short d_reclen;\n-    // more fields that we don't care about\n-  };\n+  unsigned short d_reclen;\n+  // more fields that we don't care about\n+};\n \n // 'clock_t' is 32 bits wide on x64 FreeBSD\n-  typedef int __sanitizer_clock_t;\n-  typedef int __sanitizer_clockid_t;\n+typedef int __sanitizer_clock_t;\n+typedef int __sanitizer_clockid_t;\n \n-#if defined(_LP64) || defined(__x86_64__) || defined(__powerpc__)\\\n-                   || defined(__mips__)\n-  typedef unsigned __sanitizer___kernel_uid_t;\n-  typedef unsigned __sanitizer___kernel_gid_t;\n+#if defined(_LP64) || defined(__x86_64__) || defined(__powerpc__) || \\\n+    defined(__mips__)\n+typedef unsigned __sanitizer___kernel_uid_t;\n+typedef unsigned __sanitizer___kernel_gid_t;\n #else\n-  typedef unsigned short __sanitizer___kernel_uid_t;\n-  typedef unsigned short __sanitizer___kernel_gid_t;\n+typedef unsigned short __sanitizer___kernel_uid_t;\n+typedef unsigned short __sanitizer___kernel_gid_t;\n #endif\n-  typedef long long __sanitizer___kernel_off_t;\n+typedef long long __sanitizer___kernel_off_t;\n \n #if defined(__powerpc__) || defined(__mips__)\n-  typedef unsigned int __sanitizer___kernel_old_uid_t;\n-  typedef unsigned int __sanitizer___kernel_old_gid_t;\n+typedef unsigned int __sanitizer___kernel_old_uid_t;\n+typedef unsigned int __sanitizer___kernel_old_gid_t;\n #else\n-  typedef unsigned short __sanitizer___kernel_old_uid_t;\n-  typedef unsigned short __sanitizer___kernel_old_gid_t;\n+typedef unsigned short __sanitizer___kernel_old_uid_t;\n+typedef unsigned short __sanitizer___kernel_old_gid_t;\n #endif\n \n-  typedef long long __sanitizer___kernel_loff_t;\n-  typedef struct {\n-    unsigned long fds_bits[1024 / (8 * sizeof(long))];\n-  } __sanitizer___kernel_fd_set;\n-\n-  // This thing depends on the platform. We are only interested in the upper\n-  // limit. Verified with a compiler assert in .cpp.\n-  const int pthread_attr_t_max_sz = 128;\n-  union __sanitizer_pthread_attr_t {\n-    char size[pthread_attr_t_max_sz]; // NOLINT\n-    void *align;\n-  };\n-\n-  const unsigned old_sigset_t_sz = sizeof(unsigned long);\n-\n-  struct __sanitizer_sigset_t {\n-     // uint32_t * 4\n-     unsigned int __bits[4];\n-  };\n-\n-  typedef __sanitizer_sigset_t __sanitizer_kernel_sigset_t;\n-\n-  struct __sanitizer_siginfo {\n-    // The size is determined by looking at sizeof of real siginfo_t on linux.\n-    u64 opaque[128 / sizeof(u64)];\n-  };\n-\n-  using __sanitizer_sighandler_ptr = void (*)(int sig);\n-  using __sanitizer_sigactionhandler_ptr =\n-      void (*)(int sig, __sanitizer_siginfo *siginfo, void *uctx);\n-\n-  struct __sanitizer_sigaction {\n-    union {\n-      __sanitizer_sigactionhandler_ptr sigaction;\n-      __sanitizer_sighandler_ptr handler;\n-    };\n-    int sa_flags;\n-    __sanitizer_sigset_t sa_mask;\n-  };\n-\n-  struct __sanitizer_sem_t {\n-    u32 data[4];\n-  };\n-\n-  extern const uptr sig_ign;\n-  extern const uptr sig_dfl;\n-  extern const uptr sig_err;\n-  extern const uptr sa_siginfo;\n-\n-  extern int af_inet;\n-  extern int af_inet6;\n-  uptr __sanitizer_in_addr_sz(int af);\n-\n-  struct __sanitizer_dl_phdr_info {\n-    uptr dlpi_addr;\n-    const char *dlpi_name;\n-    const void *dlpi_phdr;\n-    short dlpi_phnum;\n-  };\n-\n-  extern unsigned struct_ElfW_Phdr_sz;\n-\n-  struct __sanitizer_addrinfo {\n-    int ai_flags;\n-    int ai_family;\n-    int ai_socktype;\n-    int ai_protocol;\n-    unsigned ai_addrlen;\n-    char *ai_canonname;\n-    void *ai_addr;\n-    struct __sanitizer_addrinfo *ai_next;\n-  };\n-\n-  struct __sanitizer_hostent {\n-    char *h_name;\n-    char **h_aliases;\n-    int h_addrtype;\n-    int h_length;\n-    char **h_addr_list;\n-  };\n-\n-  struct __sanitizer_pollfd {\n-    int fd;\n-    short events;\n-    short revents;\n-  };\n-\n-  typedef unsigned __sanitizer_nfds_t;\n-\n-  struct __sanitizer_glob_t {\n-    uptr gl_pathc;\n-    uptr gl_matchc;\n-    uptr gl_offs;\n-    int gl_flags;\n-    char **gl_pathv;\n-    int (*gl_errfunc)(const char*, int);\n-    void (*gl_closedir)(void *dirp);\n-    struct dirent *(*gl_readdir)(void *dirp);\n-    void *(*gl_opendir)(const char*);\n-    int (*gl_lstat)(const char*, void* /* struct stat* */);\n-    int (*gl_stat)(const char*, void* /* struct stat* */);\n-  };\n-\n-  extern int glob_nomatch;\n-  extern int glob_altdirfunc;\n-\n-  extern unsigned path_max;\n-\n-  struct __sanitizer_wordexp_t {\n-    uptr we_wordc;\n-    char **we_wordv;\n-    uptr we_offs;\n-    char *we_strings;\n-    uptr we_nbytes;\n-  };\n-\n-  typedef void __sanitizer_FILE;\n-\n-  extern unsigned struct_shminfo_sz;\n-  extern unsigned struct_shm_info_sz;\n-  extern int shmctl_ipc_stat;\n-  extern int shmctl_ipc_info;\n-  extern int shmctl_shm_info;\n-  extern int shmctl_shm_stat;\n-\n-  extern unsigned struct_utmpx_sz;\n-\n-  extern int map_fixed;\n-\n-  // ioctl arguments\n-  struct __sanitizer_ifconf {\n-    int ifc_len;\n-    union {\n-      void *ifcu_req;\n-    } ifc_ifcu;\n+typedef long long __sanitizer___kernel_loff_t;\n+typedef struct {\n+  unsigned long fds_bits[1024 / (8 * sizeof(long))];\n+} __sanitizer___kernel_fd_set;\n+\n+// This thing depends on the platform. We are only interested in the upper\n+// limit. Verified with a compiler assert in .cpp.\n+union __sanitizer_pthread_attr_t {\n+  char size[128];\n+  void *align;\n+};\n+\n+const unsigned old_sigset_t_sz = sizeof(unsigned long);\n+\n+struct __sanitizer_sigset_t {\n+  // uint32_t * 4\n+  unsigned int __bits[4];\n+};\n+\n+typedef __sanitizer_sigset_t __sanitizer_kernel_sigset_t;\n+\n+struct __sanitizer_siginfo {\n+  // The size is determined by looking at sizeof of real siginfo_t on linux.\n+  u64 opaque[128 / sizeof(u64)];\n+};\n+\n+using __sanitizer_sighandler_ptr = void (*)(int sig);\n+using __sanitizer_sigactionhandler_ptr = void (*)(int sig,\n+                                                  __sanitizer_siginfo *siginfo,\n+                                                  void *uctx);\n+\n+struct __sanitizer_sigaction {\n+  union {\n+    __sanitizer_sigactionhandler_ptr sigaction;\n+    __sanitizer_sighandler_ptr handler;\n   };\n+  int sa_flags;\n+  __sanitizer_sigset_t sa_mask;\n+};\n+\n+struct __sanitizer_sem_t {\n+  u32 data[4];\n+};\n+\n+extern const uptr sig_ign;\n+extern const uptr sig_dfl;\n+extern const uptr sig_err;\n+extern const uptr sa_siginfo;\n+\n+extern int af_inet;\n+extern int af_inet6;\n+uptr __sanitizer_in_addr_sz(int af);\n+\n+struct __sanitizer_dl_phdr_info {\n+  uptr dlpi_addr;\n+  const char *dlpi_name;\n+  const void *dlpi_phdr;\n+  short dlpi_phnum;\n+};\n+\n+extern unsigned struct_ElfW_Phdr_sz;\n+\n+struct __sanitizer_addrinfo {\n+  int ai_flags;\n+  int ai_family;\n+  int ai_socktype;\n+  int ai_protocol;\n+  unsigned ai_addrlen;\n+  char *ai_canonname;\n+  void *ai_addr;\n+  struct __sanitizer_addrinfo *ai_next;\n+};\n+\n+struct __sanitizer_hostent {\n+  char *h_name;\n+  char **h_aliases;\n+  int h_addrtype;\n+  int h_length;\n+  char **h_addr_list;\n+};\n+\n+struct __sanitizer_pollfd {\n+  int fd;\n+  short events;\n+  short revents;\n+};\n+\n+typedef unsigned __sanitizer_nfds_t;\n+\n+struct __sanitizer_glob_t {\n+  uptr gl_pathc;\n+  uptr gl_matchc;\n+  uptr gl_offs;\n+  int gl_flags;\n+  char **gl_pathv;\n+  int (*gl_errfunc)(const char *, int);\n+  void (*gl_closedir)(void *dirp);\n+  struct dirent *(*gl_readdir)(void *dirp);\n+  void *(*gl_opendir)(const char *);\n+  int (*gl_lstat)(const char *, void * /* struct stat* */);\n+  int (*gl_stat)(const char *, void * /* struct stat* */);\n+};\n+\n+extern int glob_nomatch;\n+extern int glob_altdirfunc;\n+\n+extern unsigned path_max;\n+\n+struct __sanitizer_wordexp_t {\n+  uptr we_wordc;\n+  char **we_wordv;\n+  uptr we_offs;\n+  char *we_strings;\n+  uptr we_nbytes;\n+};\n+\n+typedef void __sanitizer_FILE;\n+\n+extern unsigned struct_shminfo_sz;\n+extern unsigned struct_shm_info_sz;\n+extern int shmctl_ipc_stat;\n+extern int shmctl_ipc_info;\n+extern int shmctl_shm_info;\n+extern int shmctl_shm_stat;\n+\n+extern unsigned struct_utmpx_sz;\n+\n+extern int map_fixed;\n+\n+// ioctl arguments\n+struct __sanitizer_ifconf {\n+  int ifc_len;\n+  union {\n+    void *ifcu_req;\n+  } ifc_ifcu;\n+};\n \n #define IOC_NRBITS 8\n #define IOC_TYPEBITS 8\n@@ -432,204 +432,204 @@ namespace __sanitizer {\n #define IOC_NR(nr) (((nr) >> IOC_NRSHIFT) & IOC_NRMASK)\n #define IOC_SIZE(nr) (((nr) >> IOC_SIZESHIFT) & IOC_SIZEMASK)\n \n-  extern unsigned struct_ifreq_sz;\n-  extern unsigned struct_termios_sz;\n-  extern unsigned struct_winsize_sz;\n-\n-  extern unsigned struct_copr_buffer_sz;\n-  extern unsigned struct_copr_debug_buf_sz;\n-  extern unsigned struct_copr_msg_sz;\n-  extern unsigned struct_midi_info_sz;\n-  extern unsigned struct_mtget_sz;\n-  extern unsigned struct_mtop_sz;\n-  extern unsigned struct_rtentry_sz;\n-  extern unsigned struct_sbi_instrument_sz;\n-  extern unsigned struct_seq_event_rec_sz;\n-  extern unsigned struct_synth_info_sz;\n-  extern unsigned struct_vt_mode_sz;\n-\n-  extern const unsigned long __sanitizer_bufsiz;\n-  extern unsigned struct_audio_buf_info_sz;\n-  extern unsigned struct_ppp_stats_sz;\n-  extern unsigned struct_sioc_sg_req_sz;\n-  extern unsigned struct_sioc_vif_req_sz;\n-\n-  // ioctl request identifiers\n-\n-  // A special value to mark ioctls that are not present on the target platform,\n-  // when it can not be determined without including any system headers.\n-  extern const unsigned IOCTL_NOT_PRESENT;\n-\n-  extern unsigned IOCTL_FIOASYNC;\n-  extern unsigned IOCTL_FIOCLEX;\n-  extern unsigned IOCTL_FIOGETOWN;\n-  extern unsigned IOCTL_FIONBIO;\n-  extern unsigned IOCTL_FIONCLEX;\n-  extern unsigned IOCTL_FIOSETOWN;\n-  extern unsigned IOCTL_SIOCADDMULTI;\n-  extern unsigned IOCTL_SIOCATMARK;\n-  extern unsigned IOCTL_SIOCDELMULTI;\n-  extern unsigned IOCTL_SIOCGIFADDR;\n-  extern unsigned IOCTL_SIOCGIFBRDADDR;\n-  extern unsigned IOCTL_SIOCGIFCONF;\n-  extern unsigned IOCTL_SIOCGIFDSTADDR;\n-  extern unsigned IOCTL_SIOCGIFFLAGS;\n-  extern unsigned IOCTL_SIOCGIFMETRIC;\n-  extern unsigned IOCTL_SIOCGIFMTU;\n-  extern unsigned IOCTL_SIOCGIFNETMASK;\n-  extern unsigned IOCTL_SIOCGPGRP;\n-  extern unsigned IOCTL_SIOCSIFADDR;\n-  extern unsigned IOCTL_SIOCSIFBRDADDR;\n-  extern unsigned IOCTL_SIOCSIFDSTADDR;\n-  extern unsigned IOCTL_SIOCSIFFLAGS;\n-  extern unsigned IOCTL_SIOCSIFMETRIC;\n-  extern unsigned IOCTL_SIOCSIFMTU;\n-  extern unsigned IOCTL_SIOCSIFNETMASK;\n-  extern unsigned IOCTL_SIOCSPGRP;\n-  extern unsigned IOCTL_TIOCCONS;\n-  extern unsigned IOCTL_TIOCEXCL;\n-  extern unsigned IOCTL_TIOCGETD;\n-  extern unsigned IOCTL_TIOCGPGRP;\n-  extern unsigned IOCTL_TIOCGWINSZ;\n-  extern unsigned IOCTL_TIOCMBIC;\n-  extern unsigned IOCTL_TIOCMBIS;\n-  extern unsigned IOCTL_TIOCMGET;\n-  extern unsigned IOCTL_TIOCMSET;\n-  extern unsigned IOCTL_TIOCNOTTY;\n-  extern unsigned IOCTL_TIOCNXCL;\n-  extern unsigned IOCTL_TIOCOUTQ;\n-  extern unsigned IOCTL_TIOCPKT;\n-  extern unsigned IOCTL_TIOCSCTTY;\n-  extern unsigned IOCTL_TIOCSETD;\n-  extern unsigned IOCTL_TIOCSPGRP;\n-  extern unsigned IOCTL_TIOCSTI;\n-  extern unsigned IOCTL_TIOCSWINSZ;\n-  extern unsigned IOCTL_SIOCGETSGCNT;\n-  extern unsigned IOCTL_SIOCGETVIFCNT;\n-  extern unsigned IOCTL_MTIOCGET;\n-  extern unsigned IOCTL_MTIOCTOP;\n-  extern unsigned IOCTL_SIOCADDRT;\n-  extern unsigned IOCTL_SIOCDELRT;\n-  extern unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE;\n-  extern unsigned IOCTL_SNDCTL_DSP_GETFMTS;\n-  extern unsigned IOCTL_SNDCTL_DSP_NONBLOCK;\n-  extern unsigned IOCTL_SNDCTL_DSP_POST;\n-  extern unsigned IOCTL_SNDCTL_DSP_RESET;\n-  extern unsigned IOCTL_SNDCTL_DSP_SETFMT;\n-  extern unsigned IOCTL_SNDCTL_DSP_SETFRAGMENT;\n-  extern unsigned IOCTL_SNDCTL_DSP_SPEED;\n-  extern unsigned IOCTL_SNDCTL_DSP_STEREO;\n-  extern unsigned IOCTL_SNDCTL_DSP_SUBDIVIDE;\n-  extern unsigned IOCTL_SNDCTL_DSP_SYNC;\n-  extern unsigned IOCTL_SNDCTL_FM_4OP_ENABLE;\n-  extern unsigned IOCTL_SNDCTL_FM_LOAD_INSTR;\n-  extern unsigned IOCTL_SNDCTL_MIDI_INFO;\n-  extern unsigned IOCTL_SNDCTL_MIDI_PRETIME;\n-  extern unsigned IOCTL_SNDCTL_SEQ_CTRLRATE;\n-  extern unsigned IOCTL_SNDCTL_SEQ_GETINCOUNT;\n-  extern unsigned IOCTL_SNDCTL_SEQ_GETOUTCOUNT;\n-  extern unsigned IOCTL_SNDCTL_SEQ_NRMIDIS;\n-  extern unsigned IOCTL_SNDCTL_SEQ_NRSYNTHS;\n-  extern unsigned IOCTL_SNDCTL_SEQ_OUTOFBAND;\n-  extern unsigned IOCTL_SNDCTL_SEQ_PANIC;\n-  extern unsigned IOCTL_SNDCTL_SEQ_PERCMODE;\n-  extern unsigned IOCTL_SNDCTL_SEQ_RESET;\n-  extern unsigned IOCTL_SNDCTL_SEQ_RESETSAMPLES;\n-  extern unsigned IOCTL_SNDCTL_SEQ_SYNC;\n-  extern unsigned IOCTL_SNDCTL_SEQ_TESTMIDI;\n-  extern unsigned IOCTL_SNDCTL_SEQ_THRESHOLD;\n-  extern unsigned IOCTL_SNDCTL_SYNTH_INFO;\n-  extern unsigned IOCTL_SNDCTL_SYNTH_MEMAVL;\n-  extern unsigned IOCTL_SNDCTL_TMR_CONTINUE;\n-  extern unsigned IOCTL_SNDCTL_TMR_METRONOME;\n-  extern unsigned IOCTL_SNDCTL_TMR_SELECT;\n-  extern unsigned IOCTL_SNDCTL_TMR_SOURCE;\n-  extern unsigned IOCTL_SNDCTL_TMR_START;\n-  extern unsigned IOCTL_SNDCTL_TMR_STOP;\n-  extern unsigned IOCTL_SNDCTL_TMR_TEMPO;\n-  extern unsigned IOCTL_SNDCTL_TMR_TIMEBASE;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_ALTPCM;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_BASS;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_CAPS;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_CD;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_DEVMASK;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_ENHANCE;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_IGAIN;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_IMIX;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_LINE1;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_LINE2;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_LINE3;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_LINE;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_LOUD;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_MIC;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_MUTE;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_OGAIN;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_PCM;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_RECLEV;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_RECMASK;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_RECSRC;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_SPEAKER;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_STEREODEVS;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_SYNTH;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_TREBLE;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_VOLUME;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_ALTPCM;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_BASS;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_CD;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_ENHANCE;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_IGAIN;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_IMIX;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE1;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE2;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE3;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_LOUD;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_MIC;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_MUTE;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_OGAIN;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_PCM;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_RECLEV;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_RECSRC;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_SPEAKER;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_SYNTH;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_TREBLE;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_VOLUME;\n-  extern unsigned IOCTL_SOUND_PCM_READ_BITS;\n-  extern unsigned IOCTL_SOUND_PCM_READ_CHANNELS;\n-  extern unsigned IOCTL_SOUND_PCM_READ_FILTER;\n-  extern unsigned IOCTL_SOUND_PCM_READ_RATE;\n-  extern unsigned IOCTL_SOUND_PCM_WRITE_CHANNELS;\n-  extern unsigned IOCTL_SOUND_PCM_WRITE_FILTER;\n-  extern unsigned IOCTL_VT_ACTIVATE;\n-  extern unsigned IOCTL_VT_GETMODE;\n-  extern unsigned IOCTL_VT_OPENQRY;\n-  extern unsigned IOCTL_VT_RELDISP;\n-  extern unsigned IOCTL_VT_SETMODE;\n-  extern unsigned IOCTL_VT_WAITACTIVE;\n-  extern unsigned IOCTL_GIO_SCRNMAP;\n-  extern unsigned IOCTL_KDDISABIO;\n-  extern unsigned IOCTL_KDENABIO;\n-  extern unsigned IOCTL_KDGETLED;\n-  extern unsigned IOCTL_KDGETMODE;\n-  extern unsigned IOCTL_KDGKBMODE;\n-  extern unsigned IOCTL_KDGKBTYPE;\n-  extern unsigned IOCTL_KDMKTONE;\n-  extern unsigned IOCTL_KDSETLED;\n-  extern unsigned IOCTL_KDSETMODE;\n-  extern unsigned IOCTL_KDSKBMODE;\n-\n-  extern const int si_SEGV_MAPERR;\n-  extern const int si_SEGV_ACCERR;\n-\n-  struct __sanitizer_cap_rights {\n-    u64 cr_rights[2];\n-  };\n-\n-  typedef struct __sanitizer_cap_rights __sanitizer_cap_rights_t;\n-  extern unsigned struct_cap_rights_sz;\n-\n-  extern unsigned struct_fstab_sz;\n-  extern unsigned struct_StringList_sz;\n+extern unsigned struct_ifreq_sz;\n+extern unsigned struct_termios_sz;\n+extern unsigned struct_winsize_sz;\n+\n+extern unsigned struct_copr_buffer_sz;\n+extern unsigned struct_copr_debug_buf_sz;\n+extern unsigned struct_copr_msg_sz;\n+extern unsigned struct_midi_info_sz;\n+extern unsigned struct_mtget_sz;\n+extern unsigned struct_mtop_sz;\n+extern unsigned struct_rtentry_sz;\n+extern unsigned struct_sbi_instrument_sz;\n+extern unsigned struct_seq_event_rec_sz;\n+extern unsigned struct_synth_info_sz;\n+extern unsigned struct_vt_mode_sz;\n+\n+extern const unsigned long __sanitizer_bufsiz;\n+extern unsigned struct_audio_buf_info_sz;\n+extern unsigned struct_ppp_stats_sz;\n+extern unsigned struct_sioc_sg_req_sz;\n+extern unsigned struct_sioc_vif_req_sz;\n+\n+// ioctl request identifiers\n+\n+// A special value to mark ioctls that are not present on the target platform,\n+// when it can not be determined without including any system headers.\n+extern const unsigned IOCTL_NOT_PRESENT;\n+\n+extern unsigned IOCTL_FIOASYNC;\n+extern unsigned IOCTL_FIOCLEX;\n+extern unsigned IOCTL_FIOGETOWN;\n+extern unsigned IOCTL_FIONBIO;\n+extern unsigned IOCTL_FIONCLEX;\n+extern unsigned IOCTL_FIOSETOWN;\n+extern unsigned IOCTL_SIOCADDMULTI;\n+extern unsigned IOCTL_SIOCATMARK;\n+extern unsigned IOCTL_SIOCDELMULTI;\n+extern unsigned IOCTL_SIOCGIFADDR;\n+extern unsigned IOCTL_SIOCGIFBRDADDR;\n+extern unsigned IOCTL_SIOCGIFCONF;\n+extern unsigned IOCTL_SIOCGIFDSTADDR;\n+extern unsigned IOCTL_SIOCGIFFLAGS;\n+extern unsigned IOCTL_SIOCGIFMETRIC;\n+extern unsigned IOCTL_SIOCGIFMTU;\n+extern unsigned IOCTL_SIOCGIFNETMASK;\n+extern unsigned IOCTL_SIOCGPGRP;\n+extern unsigned IOCTL_SIOCSIFADDR;\n+extern unsigned IOCTL_SIOCSIFBRDADDR;\n+extern unsigned IOCTL_SIOCSIFDSTADDR;\n+extern unsigned IOCTL_SIOCSIFFLAGS;\n+extern unsigned IOCTL_SIOCSIFMETRIC;\n+extern unsigned IOCTL_SIOCSIFMTU;\n+extern unsigned IOCTL_SIOCSIFNETMASK;\n+extern unsigned IOCTL_SIOCSPGRP;\n+extern unsigned IOCTL_TIOCCONS;\n+extern unsigned IOCTL_TIOCEXCL;\n+extern unsigned IOCTL_TIOCGETD;\n+extern unsigned IOCTL_TIOCGPGRP;\n+extern unsigned IOCTL_TIOCGWINSZ;\n+extern unsigned IOCTL_TIOCMBIC;\n+extern unsigned IOCTL_TIOCMBIS;\n+extern unsigned IOCTL_TIOCMGET;\n+extern unsigned IOCTL_TIOCMSET;\n+extern unsigned IOCTL_TIOCNOTTY;\n+extern unsigned IOCTL_TIOCNXCL;\n+extern unsigned IOCTL_TIOCOUTQ;\n+extern unsigned IOCTL_TIOCPKT;\n+extern unsigned IOCTL_TIOCSCTTY;\n+extern unsigned IOCTL_TIOCSETD;\n+extern unsigned IOCTL_TIOCSPGRP;\n+extern unsigned IOCTL_TIOCSTI;\n+extern unsigned IOCTL_TIOCSWINSZ;\n+extern unsigned IOCTL_SIOCGETSGCNT;\n+extern unsigned IOCTL_SIOCGETVIFCNT;\n+extern unsigned IOCTL_MTIOCGET;\n+extern unsigned IOCTL_MTIOCTOP;\n+extern unsigned IOCTL_SIOCADDRT;\n+extern unsigned IOCTL_SIOCDELRT;\n+extern unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE;\n+extern unsigned IOCTL_SNDCTL_DSP_GETFMTS;\n+extern unsigned IOCTL_SNDCTL_DSP_NONBLOCK;\n+extern unsigned IOCTL_SNDCTL_DSP_POST;\n+extern unsigned IOCTL_SNDCTL_DSP_RESET;\n+extern unsigned IOCTL_SNDCTL_DSP_SETFMT;\n+extern unsigned IOCTL_SNDCTL_DSP_SETFRAGMENT;\n+extern unsigned IOCTL_SNDCTL_DSP_SPEED;\n+extern unsigned IOCTL_SNDCTL_DSP_STEREO;\n+extern unsigned IOCTL_SNDCTL_DSP_SUBDIVIDE;\n+extern unsigned IOCTL_SNDCTL_DSP_SYNC;\n+extern unsigned IOCTL_SNDCTL_FM_4OP_ENABLE;\n+extern unsigned IOCTL_SNDCTL_FM_LOAD_INSTR;\n+extern unsigned IOCTL_SNDCTL_MIDI_INFO;\n+extern unsigned IOCTL_SNDCTL_MIDI_PRETIME;\n+extern unsigned IOCTL_SNDCTL_SEQ_CTRLRATE;\n+extern unsigned IOCTL_SNDCTL_SEQ_GETINCOUNT;\n+extern unsigned IOCTL_SNDCTL_SEQ_GETOUTCOUNT;\n+extern unsigned IOCTL_SNDCTL_SEQ_NRMIDIS;\n+extern unsigned IOCTL_SNDCTL_SEQ_NRSYNTHS;\n+extern unsigned IOCTL_SNDCTL_SEQ_OUTOFBAND;\n+extern unsigned IOCTL_SNDCTL_SEQ_PANIC;\n+extern unsigned IOCTL_SNDCTL_SEQ_PERCMODE;\n+extern unsigned IOCTL_SNDCTL_SEQ_RESET;\n+extern unsigned IOCTL_SNDCTL_SEQ_RESETSAMPLES;\n+extern unsigned IOCTL_SNDCTL_SEQ_SYNC;\n+extern unsigned IOCTL_SNDCTL_SEQ_TESTMIDI;\n+extern unsigned IOCTL_SNDCTL_SEQ_THRESHOLD;\n+extern unsigned IOCTL_SNDCTL_SYNTH_INFO;\n+extern unsigned IOCTL_SNDCTL_SYNTH_MEMAVL;\n+extern unsigned IOCTL_SNDCTL_TMR_CONTINUE;\n+extern unsigned IOCTL_SNDCTL_TMR_METRONOME;\n+extern unsigned IOCTL_SNDCTL_TMR_SELECT;\n+extern unsigned IOCTL_SNDCTL_TMR_SOURCE;\n+extern unsigned IOCTL_SNDCTL_TMR_START;\n+extern unsigned IOCTL_SNDCTL_TMR_STOP;\n+extern unsigned IOCTL_SNDCTL_TMR_TEMPO;\n+extern unsigned IOCTL_SNDCTL_TMR_TIMEBASE;\n+extern unsigned IOCTL_SOUND_MIXER_READ_ALTPCM;\n+extern unsigned IOCTL_SOUND_MIXER_READ_BASS;\n+extern unsigned IOCTL_SOUND_MIXER_READ_CAPS;\n+extern unsigned IOCTL_SOUND_MIXER_READ_CD;\n+extern unsigned IOCTL_SOUND_MIXER_READ_DEVMASK;\n+extern unsigned IOCTL_SOUND_MIXER_READ_ENHANCE;\n+extern unsigned IOCTL_SOUND_MIXER_READ_IGAIN;\n+extern unsigned IOCTL_SOUND_MIXER_READ_IMIX;\n+extern unsigned IOCTL_SOUND_MIXER_READ_LINE1;\n+extern unsigned IOCTL_SOUND_MIXER_READ_LINE2;\n+extern unsigned IOCTL_SOUND_MIXER_READ_LINE3;\n+extern unsigned IOCTL_SOUND_MIXER_READ_LINE;\n+extern unsigned IOCTL_SOUND_MIXER_READ_LOUD;\n+extern unsigned IOCTL_SOUND_MIXER_READ_MIC;\n+extern unsigned IOCTL_SOUND_MIXER_READ_MUTE;\n+extern unsigned IOCTL_SOUND_MIXER_READ_OGAIN;\n+extern unsigned IOCTL_SOUND_MIXER_READ_PCM;\n+extern unsigned IOCTL_SOUND_MIXER_READ_RECLEV;\n+extern unsigned IOCTL_SOUND_MIXER_READ_RECMASK;\n+extern unsigned IOCTL_SOUND_MIXER_READ_RECSRC;\n+extern unsigned IOCTL_SOUND_MIXER_READ_SPEAKER;\n+extern unsigned IOCTL_SOUND_MIXER_READ_STEREODEVS;\n+extern unsigned IOCTL_SOUND_MIXER_READ_SYNTH;\n+extern unsigned IOCTL_SOUND_MIXER_READ_TREBLE;\n+extern unsigned IOCTL_SOUND_MIXER_READ_VOLUME;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_ALTPCM;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_BASS;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_CD;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_ENHANCE;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_IGAIN;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_IMIX;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE1;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE2;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE3;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_LOUD;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_MIC;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_MUTE;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_OGAIN;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_PCM;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_RECLEV;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_RECSRC;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_SPEAKER;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_SYNTH;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_TREBLE;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_VOLUME;\n+extern unsigned IOCTL_SOUND_PCM_READ_BITS;\n+extern unsigned IOCTL_SOUND_PCM_READ_CHANNELS;\n+extern unsigned IOCTL_SOUND_PCM_READ_FILTER;\n+extern unsigned IOCTL_SOUND_PCM_READ_RATE;\n+extern unsigned IOCTL_SOUND_PCM_WRITE_CHANNELS;\n+extern unsigned IOCTL_SOUND_PCM_WRITE_FILTER;\n+extern unsigned IOCTL_VT_ACTIVATE;\n+extern unsigned IOCTL_VT_GETMODE;\n+extern unsigned IOCTL_VT_OPENQRY;\n+extern unsigned IOCTL_VT_RELDISP;\n+extern unsigned IOCTL_VT_SETMODE;\n+extern unsigned IOCTL_VT_WAITACTIVE;\n+extern unsigned IOCTL_GIO_SCRNMAP;\n+extern unsigned IOCTL_KDDISABIO;\n+extern unsigned IOCTL_KDENABIO;\n+extern unsigned IOCTL_KDGETLED;\n+extern unsigned IOCTL_KDGETMODE;\n+extern unsigned IOCTL_KDGKBMODE;\n+extern unsigned IOCTL_KDGKBTYPE;\n+extern unsigned IOCTL_KDMKTONE;\n+extern unsigned IOCTL_KDSETLED;\n+extern unsigned IOCTL_KDSETMODE;\n+extern unsigned IOCTL_KDSKBMODE;\n+\n+extern const int si_SEGV_MAPERR;\n+extern const int si_SEGV_ACCERR;\n+\n+struct __sanitizer_cap_rights {\n+  u64 cr_rights[2];\n+};\n+\n+typedef struct __sanitizer_cap_rights __sanitizer_cap_rights_t;\n+extern unsigned struct_cap_rights_sz;\n+\n+extern unsigned struct_fstab_sz;\n+extern unsigned struct_StringList_sz;\n } // namespace __sanitizer\n \n #define CHECK_TYPE_SIZE(TYPE) \\"}, {"sha": "842bc789f4793117134a82a7fe18a8cc60dbf5ce", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cpp", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -26,12 +26,9 @@\n \n // With old kernels (and even new kernels on powerpc) asm/stat.h uses types that\n // are not defined anywhere in userspace headers. Fake them. This seems to work\n-// fine with newer headers, too.  Beware that with <sys/stat.h>, struct stat\n-// takes the form of struct stat64 on 32-bit platforms if _FILE_OFFSET_BITS=64.\n-// Also, for some platforms (e.g. mips) there are additional members in the\n-// <sys/stat.h> struct stat:s.\n+// fine with newer headers, too.\n #include <linux/posix_types.h>\n-#if defined(__x86_64__)\n+#if defined(__x86_64__) ||  defined(__mips__)\n #include <sys/stat.h>\n #else\n #define ino_t __kernel_ino_t"}, {"sha": "9852e6ba78794ea81958bbdfad8625e3dd67f477", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -22,6 +22,10 @@\n #ifdef _FILE_OFFSET_BITS\n #undef _FILE_OFFSET_BITS\n #endif\n+\n+// Must go after undef _FILE_OFFSET_BITS.\n+#include \"sanitizer_glibc_version.h\"\n+\n #include <arpa/inet.h>\n #include <dirent.h>\n #include <grp.h>\n@@ -136,6 +140,7 @@ typedef struct user_fpregs elf_fpregset_t;\n #include <linux/serial.h>\n #include <sys/msg.h>\n #include <sys/ipc.h>\n+#include <crypt.h>\n #endif // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n #if SANITIZER_ANDROID\n@@ -236,6 +241,7 @@ namespace __sanitizer {\n   unsigned struct_ustat_sz = SIZEOF_STRUCT_USTAT;\n   unsigned struct_rlimit64_sz = sizeof(struct rlimit64);\n   unsigned struct_statvfs64_sz = sizeof(struct statvfs64);\n+  unsigned struct_crypt_data_sz = sizeof(struct crypt_data);\n #endif // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n@@ -1005,10 +1011,6 @@ CHECK_SIZE_AND_OFFSET(cmsghdr, cmsg_len);\n CHECK_SIZE_AND_OFFSET(cmsghdr, cmsg_level);\n CHECK_SIZE_AND_OFFSET(cmsghdr, cmsg_type);\n \n-#ifndef __GLIBC_PREREQ\n-#define __GLIBC_PREREQ(x, y) 0\n-#endif\n-\n #if SANITIZER_LINUX && (__ANDROID_API__ >= 21 || __GLIBC_PREREQ (2, 14))\n CHECK_TYPE_SIZE(mmsghdr);\n CHECK_SIZE_AND_OFFSET(mmsghdr, msg_hdr);\n@@ -1129,9 +1131,8 @@ CHECK_SIZE_AND_OFFSET(ipc_perm, cgid);\n #if (!defined(__aarch64__) || !SANITIZER_LINUX || __GLIBC_PREREQ (2, 21)) && \\\n     !defined(__arm__)\n /* On aarch64 glibc 2.20 and earlier provided incorrect mode field.  */\n-/* On Arm glibc 2.31 and later provide a different mode field, this field is\n-   never used by libsanitizer so we can simply ignore this assert for all glibc\n-   versions.  */\n+/* On Arm newer glibc provide a different mode field, it's hard to detect\n+   so just disable the check.  */\n CHECK_SIZE_AND_OFFSET(ipc_perm, mode);\n #endif\n "}, {"sha": "db2c4f07b3ae4f91f3549f4e695a8304e89369d8", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 1085, "deletions": 1083, "changes": 2168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -19,844 +19,846 @@\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_platform.h\"\n \n-# define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) ((link_map*)(handle))\n-\n-#ifndef __GLIBC_PREREQ\n-#define __GLIBC_PREREQ(x, y) 0\n+#if defined(__sparc__)\n+// FIXME: This can't be included from tsan which does not support sparc yet.\n+#include \"sanitizer_glibc_version.h\"\n #endif\n \n+# define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) ((link_map*)(handle))\n+\n namespace __sanitizer {\n-  extern unsigned struct_utsname_sz;\n-  extern unsigned struct_stat_sz;\n+extern unsigned struct_utsname_sz;\n+extern unsigned struct_stat_sz;\n #if !SANITIZER_IOS\n-  extern unsigned struct_stat64_sz;\n-#endif\n-  extern unsigned struct_rusage_sz;\n-  extern unsigned siginfo_t_sz;\n-  extern unsigned struct_itimerval_sz;\n-  extern unsigned pthread_t_sz;\n-  extern unsigned pthread_mutex_t_sz;\n-  extern unsigned pthread_cond_t_sz;\n-  extern unsigned pid_t_sz;\n-  extern unsigned timeval_sz;\n-  extern unsigned uid_t_sz;\n-  extern unsigned gid_t_sz;\n-  extern unsigned mbstate_t_sz;\n-  extern unsigned struct_timezone_sz;\n-  extern unsigned struct_tms_sz;\n-  extern unsigned struct_itimerspec_sz;\n-  extern unsigned struct_sigevent_sz;\n-  extern unsigned struct_sched_param_sz;\n-  extern unsigned struct_statfs64_sz;\n-  extern unsigned struct_regex_sz;\n-  extern unsigned struct_regmatch_sz;\n+extern unsigned struct_stat64_sz;\n+#endif\n+extern unsigned struct_rusage_sz;\n+extern unsigned siginfo_t_sz;\n+extern unsigned struct_itimerval_sz;\n+extern unsigned pthread_t_sz;\n+extern unsigned pthread_mutex_t_sz;\n+extern unsigned pthread_cond_t_sz;\n+extern unsigned pid_t_sz;\n+extern unsigned timeval_sz;\n+extern unsigned uid_t_sz;\n+extern unsigned gid_t_sz;\n+extern unsigned mbstate_t_sz;\n+extern unsigned struct_timezone_sz;\n+extern unsigned struct_tms_sz;\n+extern unsigned struct_itimerspec_sz;\n+extern unsigned struct_sigevent_sz;\n+extern unsigned struct_sched_param_sz;\n+extern unsigned struct_statfs64_sz;\n+extern unsigned struct_regex_sz;\n+extern unsigned struct_regmatch_sz;\n \n #if !SANITIZER_ANDROID\n-  extern unsigned struct_fstab_sz;\n-  extern unsigned struct_statfs_sz;\n-  extern unsigned struct_sockaddr_sz;\n-  extern unsigned ucontext_t_sz;\n+extern unsigned struct_fstab_sz;\n+extern unsigned struct_statfs_sz;\n+extern unsigned struct_sockaddr_sz;\n+extern unsigned ucontext_t_sz;\n #endif // !SANITIZER_ANDROID\n \n #if SANITIZER_LINUX\n \n #if defined(__x86_64__)\n-  const unsigned struct_kernel_stat_sz = 144;\n-  const unsigned struct_kernel_stat64_sz = 0;\n+const unsigned struct_kernel_stat_sz = 144;\n+const unsigned struct_kernel_stat64_sz = 0;\n #elif defined(__i386__)\n-  const unsigned struct_kernel_stat_sz = 64;\n-  const unsigned struct_kernel_stat64_sz = 96;\n+const unsigned struct_kernel_stat_sz = 64;\n+const unsigned struct_kernel_stat64_sz = 96;\n #elif defined(__arm__)\n-  const unsigned struct_kernel_stat_sz = 64;\n-  const unsigned struct_kernel_stat64_sz = 104;\n+const unsigned struct_kernel_stat_sz = 64;\n+const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__aarch64__)\n-  const unsigned struct_kernel_stat_sz = 128;\n-  const unsigned struct_kernel_stat64_sz = 104;\n+const unsigned struct_kernel_stat_sz = 128;\n+const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__powerpc__) && !defined(__powerpc64__)\n-  const unsigned struct_kernel_stat_sz = 72;\n-  const unsigned struct_kernel_stat64_sz = 104;\n+const unsigned struct_kernel_stat_sz = 72;\n+const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__powerpc64__)\n-  const unsigned struct_kernel_stat_sz = 144;\n-  const unsigned struct_kernel_stat64_sz = 104;\n+const unsigned struct_kernel_stat_sz = 144;\n+const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__mips__)\n-  const unsigned struct_kernel_stat_sz =\n-                 SANITIZER_ANDROID ? FIRST_32_SECOND_64(104, 128) :\n-                                     FIRST_32_SECOND_64(144, 216);\n-  const unsigned struct_kernel_stat64_sz = 104;\n+const unsigned struct_kernel_stat_sz = SANITIZER_ANDROID\n+                                           ? FIRST_32_SECOND_64(104, 128)\n+                                           : FIRST_32_SECOND_64(160, 216);\n+const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__s390__) && !defined(__s390x__)\n-  const unsigned struct_kernel_stat_sz = 64;\n-  const unsigned struct_kernel_stat64_sz = 104;\n+const unsigned struct_kernel_stat_sz = 64;\n+const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__s390x__)\n-  const unsigned struct_kernel_stat_sz = 144;\n-  const unsigned struct_kernel_stat64_sz = 0;\n+const unsigned struct_kernel_stat_sz = 144;\n+const unsigned struct_kernel_stat64_sz = 0;\n #elif defined(__sparc__) && defined(__arch64__)\n-  const unsigned struct___old_kernel_stat_sz = 0;\n-  const unsigned struct_kernel_stat_sz = 104;\n-  const unsigned struct_kernel_stat64_sz = 144;\n+const unsigned struct___old_kernel_stat_sz = 0;\n+const unsigned struct_kernel_stat_sz = 104;\n+const unsigned struct_kernel_stat64_sz = 144;\n #elif defined(__sparc__) && !defined(__arch64__)\n-  const unsigned struct___old_kernel_stat_sz = 0;\n-  const unsigned struct_kernel_stat_sz = 64;\n-  const unsigned struct_kernel_stat64_sz = 104;\n-#endif\n-  struct __sanitizer_perf_event_attr {\n-    unsigned type;\n-    unsigned size;\n-    // More fields that vary with the kernel version.\n-  };\n+const unsigned struct___old_kernel_stat_sz = 0;\n+const unsigned struct_kernel_stat_sz = 64;\n+const unsigned struct_kernel_stat64_sz = 104;\n+#endif\n+struct __sanitizer_perf_event_attr {\n+  unsigned type;\n+  unsigned size;\n+  // More fields that vary with the kernel version.\n+};\n \n-  extern unsigned struct_epoll_event_sz;\n-  extern unsigned struct_sysinfo_sz;\n-  extern unsigned __user_cap_header_struct_sz;\n-  extern unsigned __user_cap_data_struct_sz;\n-  extern unsigned struct_new_utsname_sz;\n-  extern unsigned struct_old_utsname_sz;\n-  extern unsigned struct_oldold_utsname_sz;\n+extern unsigned struct_epoll_event_sz;\n+extern unsigned struct_sysinfo_sz;\n+extern unsigned __user_cap_header_struct_sz;\n+extern unsigned __user_cap_data_struct_sz;\n+extern unsigned struct_new_utsname_sz;\n+extern unsigned struct_old_utsname_sz;\n+extern unsigned struct_oldold_utsname_sz;\n \n-  const unsigned struct_kexec_segment_sz = 4 * sizeof(unsigned long);\n+const unsigned struct_kexec_segment_sz = 4 * sizeof(unsigned long);\n #endif  // SANITIZER_LINUX\n \n #if SANITIZER_LINUX\n \n #if defined(__powerpc64__) || defined(__s390__)\n-  const unsigned struct___old_kernel_stat_sz = 0;\n+const unsigned struct___old_kernel_stat_sz = 0;\n #elif !defined(__sparc__)\n-  const unsigned struct___old_kernel_stat_sz = 32;\n-#endif\n-\n-  extern unsigned struct_rlimit_sz;\n-  extern unsigned struct_utimbuf_sz;\n-  extern unsigned struct_timespec_sz;\n-\n-  struct __sanitizer_iocb {\n-    u64   aio_data;\n-    u32   aio_key_or_aio_reserved1; // Simply crazy.\n-    u32   aio_reserved1_or_aio_key; // Luckily, we don't need these.\n-    u16   aio_lio_opcode;\n-    s16   aio_reqprio;\n-    u32   aio_fildes;\n-    u64   aio_buf;\n-    u64   aio_nbytes;\n-    s64   aio_offset;\n-    u64   aio_reserved2;\n-    u64   aio_reserved3;\n-  };\n+const unsigned struct___old_kernel_stat_sz = 32;\n+#endif\n \n-  struct __sanitizer_io_event {\n-    u64 data;\n-    u64 obj;\n-    u64 res;\n-    u64 res2;\n-  };\n+extern unsigned struct_rlimit_sz;\n+extern unsigned struct_utimbuf_sz;\n+extern unsigned struct_timespec_sz;\n+\n+struct __sanitizer_iocb {\n+  u64 aio_data;\n+  u32 aio_key_or_aio_reserved1;  // Simply crazy.\n+  u32 aio_reserved1_or_aio_key;  // Luckily, we don't need these.\n+  u16 aio_lio_opcode;\n+  s16 aio_reqprio;\n+  u32 aio_fildes;\n+  u64 aio_buf;\n+  u64 aio_nbytes;\n+  s64 aio_offset;\n+  u64 aio_reserved2;\n+  u64 aio_reserved3;\n+};\n \n-  const unsigned iocb_cmd_pread = 0;\n-  const unsigned iocb_cmd_pwrite = 1;\n-  const unsigned iocb_cmd_preadv = 7;\n-  const unsigned iocb_cmd_pwritev = 8;\n-\n-  struct __sanitizer___sysctl_args {\n-    int *name;\n-    int nlen;\n-    void *oldval;\n-    uptr *oldlenp;\n-    void *newval;\n-    uptr newlen;\n-    unsigned long ___unused[4];\n-  };\n+struct __sanitizer_io_event {\n+  u64 data;\n+  u64 obj;\n+  u64 res;\n+  u64 res2;\n+};\n \n-  const unsigned old_sigset_t_sz = sizeof(unsigned long);\n+const unsigned iocb_cmd_pread = 0;\n+const unsigned iocb_cmd_pwrite = 1;\n+const unsigned iocb_cmd_preadv = 7;\n+const unsigned iocb_cmd_pwritev = 8;\n+\n+struct __sanitizer___sysctl_args {\n+  int *name;\n+  int nlen;\n+  void *oldval;\n+  uptr *oldlenp;\n+  void *newval;\n+  uptr newlen;\n+  unsigned long ___unused[4];\n+};\n \n-  struct __sanitizer_sem_t {\n+const unsigned old_sigset_t_sz = sizeof(unsigned long);\n+\n+struct __sanitizer_sem_t {\n #if SANITIZER_ANDROID && defined(_LP64)\n-    int data[4];\n+  int data[4];\n #elif SANITIZER_ANDROID && !defined(_LP64)\n-    int data;\n+  int data;\n #elif SANITIZER_LINUX\n-    uptr data[4];\n+  uptr data[4];\n #endif\n-  };\n+};\n #endif // SANITIZER_LINUX\n \n #if SANITIZER_ANDROID\n-  struct __sanitizer_struct_mallinfo {\n-    uptr v[10];\n-  };\n+struct __sanitizer_struct_mallinfo {\n+  uptr v[10];\n+};\n #endif\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n-  struct __sanitizer_struct_mallinfo {\n-    int v[10];\n-  };\n+struct __sanitizer_struct_mallinfo {\n+  int v[10];\n+};\n \n-  extern unsigned struct_ustat_sz;\n-  extern unsigned struct_rlimit64_sz;\n-  extern unsigned struct_statvfs64_sz;\n+extern unsigned struct_ustat_sz;\n+extern unsigned struct_rlimit64_sz;\n+extern unsigned struct_statvfs64_sz;\n \n-  struct __sanitizer_ipc_perm {\n-    int __key;\n-    int uid;\n-    int gid;\n-    int cuid;\n-    int cgid;\n+struct __sanitizer_ipc_perm {\n+  int __key;\n+  int uid;\n+  int gid;\n+  int cuid;\n+  int cgid;\n #ifdef __powerpc__\n-    unsigned mode;\n-    unsigned __seq;\n-    u64 __unused1;\n-    u64 __unused2;\n+  unsigned mode;\n+  unsigned __seq;\n+  u64 __unused1;\n+  u64 __unused2;\n #elif defined(__sparc__)\n #if defined(__arch64__)\n-    unsigned mode;\n-    unsigned short __pad1;\n+  unsigned mode;\n+  unsigned short __pad1;\n #else\n-    unsigned short __pad1;\n-    unsigned short mode;\n-    unsigned short __pad2;\n+  unsigned short __pad1;\n+  unsigned short mode;\n+  unsigned short __pad2;\n #endif\n-    unsigned short __seq;\n-    unsigned long long __unused1;\n-    unsigned long long __unused2;\n+  unsigned short __seq;\n+  unsigned long long __unused1;\n+  unsigned long long __unused2;\n #elif defined(__mips__) || defined(__aarch64__) || defined(__s390x__)\n-    unsigned int mode;\n-    unsigned short __seq;\n-    unsigned short __pad1;\n-    unsigned long __unused1;\n-    unsigned long __unused2;\n+  unsigned int mode;\n+  unsigned short __seq;\n+  unsigned short __pad1;\n+  unsigned long __unused1;\n+  unsigned long __unused2;\n #else\n-    unsigned short mode;\n-    unsigned short __pad1;\n-    unsigned short __seq;\n-    unsigned short __pad2;\n+  unsigned short mode;\n+  unsigned short __pad1;\n+  unsigned short __seq;\n+  unsigned short __pad2;\n #if defined(__x86_64__) && !defined(_LP64)\n-    u64 __unused1;\n-    u64 __unused2;\n+  u64 __unused1;\n+  u64 __unused2;\n #else\n-    unsigned long __unused1;\n-    unsigned long __unused2;\n+  unsigned long __unused1;\n+  unsigned long __unused2;\n #endif\n #endif\n-  };\n+};\n \n-  struct __sanitizer_shmid_ds {\n-    __sanitizer_ipc_perm shm_perm;\n-  #if defined(__sparc__)\n-  #if !defined(__arch64__)\n-    u32 __pad1;\n-  #endif\n-    long shm_atime;\n-  #if !defined(__arch64__)\n-    u32 __pad2;\n-  #endif\n-    long shm_dtime;\n-  #if !defined(__arch64__)\n-    u32 __pad3;\n-  #endif\n-    long shm_ctime;\n-    uptr shm_segsz;\n-    int shm_cpid;\n-    int shm_lpid;\n-    unsigned long shm_nattch;\n-    unsigned long __glibc_reserved1;\n-    unsigned long __glibc_reserved2;\n-  #else\n-  #ifndef __powerpc__\n-    uptr shm_segsz;\n-  #elif !defined(__powerpc64__)\n-    uptr __unused0;\n-  #endif\n-  #if defined(__x86_64__) && !defined(_LP64)\n-    u64 shm_atime;\n-    u64 shm_dtime;\n-    u64 shm_ctime;\n-  #else\n-    uptr shm_atime;\n-  #if !defined(_LP64) && !defined(__mips__)\n-    uptr __unused1;\n-  #endif\n-    uptr shm_dtime;\n-  #if !defined(_LP64) && !defined(__mips__)\n-    uptr __unused2;\n-  #endif\n-    uptr shm_ctime;\n-  #if !defined(_LP64) && !defined(__mips__)\n-    uptr __unused3;\n-  #endif\n-  #endif\n-  #ifdef __powerpc__\n-    uptr shm_segsz;\n-  #endif\n-    int shm_cpid;\n-    int shm_lpid;\n-  #if defined(__x86_64__) && !defined(_LP64)\n-    u64 shm_nattch;\n-    u64 __unused4;\n-    u64 __unused5;\n-  #else\n-    uptr shm_nattch;\n-    uptr __unused4;\n-    uptr __unused5;\n-  #endif\n+struct __sanitizer_shmid_ds {\n+  __sanitizer_ipc_perm shm_perm;\n+#if defined(__sparc__)\n+#if !defined(__arch64__)\n+  u32 __pad1;\n #endif\n-  };\n+  long shm_atime;\n+#if !defined(__arch64__)\n+  u32 __pad2;\n+#endif\n+  long shm_dtime;\n+#if !defined(__arch64__)\n+  u32 __pad3;\n+#endif\n+  long shm_ctime;\n+  uptr shm_segsz;\n+  int shm_cpid;\n+  int shm_lpid;\n+  unsigned long shm_nattch;\n+  unsigned long __glibc_reserved1;\n+  unsigned long __glibc_reserved2;\n+#else\n+#ifndef __powerpc__\n+  uptr shm_segsz;\n+#elif !defined(__powerpc64__)\n+  uptr __unused0;\n+#endif\n+#if defined(__x86_64__) && !defined(_LP64)\n+  u64 shm_atime;\n+  u64 shm_dtime;\n+  u64 shm_ctime;\n+#else\n+  uptr shm_atime;\n+#if !defined(_LP64) && !defined(__mips__)\n+  uptr __unused1;\n+#endif\n+  uptr shm_dtime;\n+#if !defined(_LP64) && !defined(__mips__)\n+  uptr __unused2;\n+#endif\n+  uptr shm_ctime;\n+#if !defined(_LP64) && !defined(__mips__)\n+  uptr __unused3;\n+#endif\n+#endif\n+#ifdef __powerpc__\n+  uptr shm_segsz;\n+#endif\n+  int shm_cpid;\n+  int shm_lpid;\n+#if defined(__x86_64__) && !defined(_LP64)\n+  u64 shm_nattch;\n+  u64 __unused4;\n+  u64 __unused5;\n+#else\n+  uptr shm_nattch;\n+  uptr __unused4;\n+  uptr __unused5;\n+#endif\n+#endif\n+};\n #endif\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n-  extern unsigned struct_msqid_ds_sz;\n-  extern unsigned struct_mq_attr_sz;\n-  extern unsigned struct_timex_sz;\n-  extern unsigned struct_statvfs_sz;\n+extern unsigned struct_msqid_ds_sz;\n+extern unsigned struct_mq_attr_sz;\n+extern unsigned struct_timex_sz;\n+extern unsigned struct_statvfs_sz;\n+extern unsigned struct_crypt_data_sz;\n #endif  // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n-  struct __sanitizer_iovec {\n-    void *iov_base;\n-    uptr iov_len;\n-  };\n+struct __sanitizer_iovec {\n+  void *iov_base;\n+  uptr iov_len;\n+};\n \n #if !SANITIZER_ANDROID\n-  struct __sanitizer_ifaddrs {\n-    struct __sanitizer_ifaddrs *ifa_next;\n-    char *ifa_name;\n-    unsigned int ifa_flags;\n-    void *ifa_addr;    // (struct sockaddr *)\n-    void *ifa_netmask; // (struct sockaddr *)\n-    // This is a union on Linux.\n+struct __sanitizer_ifaddrs {\n+  struct __sanitizer_ifaddrs *ifa_next;\n+  char *ifa_name;\n+  unsigned int ifa_flags;\n+  void *ifa_addr;     // (struct sockaddr *)\n+  void *ifa_netmask;  // (struct sockaddr *)\n+  // This is a union on Linux.\n # ifdef ifa_dstaddr\n # undef ifa_dstaddr\n # endif\n-    void *ifa_dstaddr; // (struct sockaddr *)\n-    void *ifa_data;\n-  };\n+  void *ifa_dstaddr;  // (struct sockaddr *)\n+  void *ifa_data;\n+};\n #endif  // !SANITIZER_ANDROID\n \n #if SANITIZER_MAC\n-  typedef unsigned long __sanitizer_pthread_key_t;\n+typedef unsigned long __sanitizer_pthread_key_t;\n #else\n-  typedef unsigned __sanitizer_pthread_key_t;\n+typedef unsigned __sanitizer_pthread_key_t;\n #endif\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n \n-  struct __sanitizer_XDR {\n-    int x_op;\n-    void *x_ops;\n-    uptr x_public;\n-    uptr x_private;\n-    uptr x_base;\n-    unsigned x_handy;\n-  };\n+struct __sanitizer_XDR {\n+  int x_op;\n+  void *x_ops;\n+  uptr x_public;\n+  uptr x_private;\n+  uptr x_base;\n+  unsigned x_handy;\n+};\n \n-  const int __sanitizer_XDR_ENCODE = 0;\n-  const int __sanitizer_XDR_DECODE = 1;\n-  const int __sanitizer_XDR_FREE = 2;\n+const int __sanitizer_XDR_ENCODE = 0;\n+const int __sanitizer_XDR_DECODE = 1;\n+const int __sanitizer_XDR_FREE = 2;\n #endif\n \n-  struct __sanitizer_passwd {\n-    char *pw_name;\n-    char *pw_passwd;\n-    int pw_uid;\n-    int pw_gid;\n+struct __sanitizer_passwd {\n+  char *pw_name;\n+  char *pw_passwd;\n+  int pw_uid;\n+  int pw_gid;\n #if SANITIZER_MAC\n-    long pw_change;\n-    char *pw_class;\n+  long pw_change;\n+  char *pw_class;\n #endif\n #if !(SANITIZER_ANDROID && (SANITIZER_WORDSIZE == 32))\n-    char *pw_gecos;\n+  char *pw_gecos;\n #endif\n-    char *pw_dir;\n-    char *pw_shell;\n+  char *pw_dir;\n+  char *pw_shell;\n #if SANITIZER_MAC\n-    long pw_expire;\n+  long pw_expire;\n #endif\n-  };\n+};\n \n-  struct __sanitizer_group {\n-    char *gr_name;\n-    char *gr_passwd;\n-    int gr_gid;\n-    char **gr_mem;\n-  };\n+struct __sanitizer_group {\n+  char *gr_name;\n+  char *gr_passwd;\n+  int gr_gid;\n+  char **gr_mem;\n+};\n \n #if defined(__x86_64__) && !defined(_LP64)\n-  typedef long long __sanitizer_time_t;\n+typedef long long __sanitizer_time_t;\n #else\n-  typedef long __sanitizer_time_t;\n+typedef long __sanitizer_time_t;\n #endif\n \n-  typedef long __sanitizer_suseconds_t;\n+typedef long __sanitizer_suseconds_t;\n \n-  struct __sanitizer_timeval {\n-    __sanitizer_time_t tv_sec;\n-    __sanitizer_suseconds_t tv_usec;\n-  };\n+struct __sanitizer_timeval {\n+  __sanitizer_time_t tv_sec;\n+  __sanitizer_suseconds_t tv_usec;\n+};\n \n-  struct __sanitizer_itimerval {\n-    struct __sanitizer_timeval it_interval;\n-    struct __sanitizer_timeval it_value;\n-  };\n+struct __sanitizer_itimerval {\n+  struct __sanitizer_timeval it_interval;\n+  struct __sanitizer_timeval it_value;\n+};\n \n-  struct __sanitizer_timeb {\n-    __sanitizer_time_t time;\n-    unsigned short millitm;\n-    short timezone;\n-    short dstflag;\n-  };\n+struct __sanitizer_timeb {\n+  __sanitizer_time_t time;\n+  unsigned short millitm;\n+  short timezone;\n+  short dstflag;\n+};\n \n-  struct __sanitizer_ether_addr {\n-    u8 octet[6];\n-  };\n+struct __sanitizer_ether_addr {\n+  u8 octet[6];\n+};\n \n-  struct __sanitizer_tm {\n-    int tm_sec;\n-    int tm_min;\n-    int tm_hour;\n-    int tm_mday;\n-    int tm_mon;\n-    int tm_year;\n-    int tm_wday;\n-    int tm_yday;\n-    int tm_isdst;\n-    long int tm_gmtoff;\n-    const char *tm_zone;\n-  };\n+struct __sanitizer_tm {\n+  int tm_sec;\n+  int tm_min;\n+  int tm_hour;\n+  int tm_mday;\n+  int tm_mon;\n+  int tm_year;\n+  int tm_wday;\n+  int tm_yday;\n+  int tm_isdst;\n+  long int tm_gmtoff;\n+  const char *tm_zone;\n+};\n \n #if SANITIZER_LINUX\n-  struct __sanitizer_mntent {\n-    char *mnt_fsname;\n-    char *mnt_dir;\n-    char *mnt_type;\n-    char *mnt_opts;\n-    int mnt_freq;\n-    int mnt_passno;\n-  };\n+struct __sanitizer_mntent {\n+  char *mnt_fsname;\n+  char *mnt_dir;\n+  char *mnt_type;\n+  char *mnt_opts;\n+  int mnt_freq;\n+  int mnt_passno;\n+};\n \n-  struct __sanitizer_file_handle {\n-    unsigned int handle_bytes;\n-    int handle_type;\n-    unsigned char f_handle[1];  // variable sized\n-  };\n+struct __sanitizer_file_handle {\n+  unsigned int handle_bytes;\n+  int handle_type;\n+  unsigned char f_handle[1];  // variable sized\n+};\n #endif\n \n #if SANITIZER_MAC\n-  struct __sanitizer_msghdr {\n-    void *msg_name;\n-    unsigned msg_namelen;\n-    struct __sanitizer_iovec *msg_iov;\n-    unsigned msg_iovlen;\n-    void *msg_control;\n-    unsigned msg_controllen;\n-    int msg_flags;\n-  };\n-  struct __sanitizer_cmsghdr {\n-    unsigned cmsg_len;\n-    int cmsg_level;\n-    int cmsg_type;\n-  };\n+struct __sanitizer_msghdr {\n+  void *msg_name;\n+  unsigned msg_namelen;\n+  struct __sanitizer_iovec *msg_iov;\n+  unsigned msg_iovlen;\n+  void *msg_control;\n+  unsigned msg_controllen;\n+  int msg_flags;\n+};\n+struct __sanitizer_cmsghdr {\n+  unsigned cmsg_len;\n+  int cmsg_level;\n+  int cmsg_type;\n+};\n #else\n-  struct __sanitizer_msghdr {\n-    void *msg_name;\n-    unsigned msg_namelen;\n-    struct __sanitizer_iovec *msg_iov;\n-    uptr msg_iovlen;\n-    void *msg_control;\n-    uptr msg_controllen;\n-    int msg_flags;\n-  };\n-  struct __sanitizer_cmsghdr {\n-    uptr cmsg_len;\n-    int cmsg_level;\n-    int cmsg_type;\n-  };\n+struct __sanitizer_msghdr {\n+  void *msg_name;\n+  unsigned msg_namelen;\n+  struct __sanitizer_iovec *msg_iov;\n+  uptr msg_iovlen;\n+  void *msg_control;\n+  uptr msg_controllen;\n+  int msg_flags;\n+};\n+struct __sanitizer_cmsghdr {\n+  uptr cmsg_len;\n+  int cmsg_level;\n+  int cmsg_type;\n+};\n #endif\n \n #if SANITIZER_LINUX\n-  struct __sanitizer_mmsghdr {\n-    __sanitizer_msghdr msg_hdr;\n-    unsigned int msg_len;\n-  };\n+struct __sanitizer_mmsghdr {\n+  __sanitizer_msghdr msg_hdr;\n+  unsigned int msg_len;\n+};\n #endif\n \n #if SANITIZER_MAC\n-  struct __sanitizer_dirent {\n-    unsigned long long d_ino;\n-    unsigned long long d_seekoff;\n-    unsigned short d_reclen;\n-    // more fields that we don't care about\n-  };\n+struct __sanitizer_dirent {\n+  unsigned long long d_ino;\n+  unsigned long long d_seekoff;\n+  unsigned short d_reclen;\n+  // more fields that we don't care about\n+};\n #elif SANITIZER_ANDROID || defined(__x86_64__)\n-  struct __sanitizer_dirent {\n-    unsigned long long d_ino;\n-    unsigned long long d_off;\n-    unsigned short d_reclen;\n-    // more fields that we don't care about\n-  };\n+struct __sanitizer_dirent {\n+  unsigned long long d_ino;\n+  unsigned long long d_off;\n+  unsigned short d_reclen;\n+  // more fields that we don't care about\n+};\n #else\n-  struct __sanitizer_dirent {\n-    uptr d_ino;\n-    uptr d_off;\n-    unsigned short d_reclen;\n-    // more fields that we don't care about\n-  };\n+struct __sanitizer_dirent {\n+  uptr d_ino;\n+  uptr d_off;\n+  unsigned short d_reclen;\n+  // more fields that we don't care about\n+};\n #endif\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n-  struct __sanitizer_dirent64 {\n-    unsigned long long d_ino;\n-    unsigned long long d_off;\n-    unsigned short d_reclen;\n-    // more fields that we don't care about\n-  };\n+struct __sanitizer_dirent64 {\n+  unsigned long long d_ino;\n+  unsigned long long d_off;\n+  unsigned short d_reclen;\n+  // more fields that we don't care about\n+};\n #endif\n \n #if defined(__x86_64__) && !defined(_LP64)\n-  typedef long long __sanitizer_clock_t;\n+typedef long long __sanitizer_clock_t;\n #else\n-  typedef long __sanitizer_clock_t;\n+typedef long __sanitizer_clock_t;\n #endif\n \n #if SANITIZER_LINUX\n-  typedef int __sanitizer_clockid_t;\n+typedef int __sanitizer_clockid_t;\n #endif\n \n #if SANITIZER_LINUX\n-#if defined(_LP64) || defined(__x86_64__) || defined(__powerpc__)\\\n-                   || defined(__mips__)\n-  typedef unsigned __sanitizer___kernel_uid_t;\n-  typedef unsigned __sanitizer___kernel_gid_t;\n+#if defined(_LP64) || defined(__x86_64__) || defined(__powerpc__) || \\\n+    defined(__mips__)\n+typedef unsigned __sanitizer___kernel_uid_t;\n+typedef unsigned __sanitizer___kernel_gid_t;\n #else\n-  typedef unsigned short __sanitizer___kernel_uid_t;\n-  typedef unsigned short __sanitizer___kernel_gid_t;\n+typedef unsigned short __sanitizer___kernel_uid_t;\n+typedef unsigned short __sanitizer___kernel_gid_t;\n #endif\n #if defined(__x86_64__) && !defined(_LP64)\n-  typedef long long __sanitizer___kernel_off_t;\n+typedef long long __sanitizer___kernel_off_t;\n #else\n-  typedef long __sanitizer___kernel_off_t;\n+typedef long __sanitizer___kernel_off_t;\n #endif\n \n #if defined(__powerpc__) || defined(__mips__)\n-  typedef unsigned int __sanitizer___kernel_old_uid_t;\n-  typedef unsigned int __sanitizer___kernel_old_gid_t;\n+typedef unsigned int __sanitizer___kernel_old_uid_t;\n+typedef unsigned int __sanitizer___kernel_old_gid_t;\n #else\n-  typedef unsigned short __sanitizer___kernel_old_uid_t;\n-  typedef unsigned short __sanitizer___kernel_old_gid_t;\n+typedef unsigned short __sanitizer___kernel_old_uid_t;\n+typedef unsigned short __sanitizer___kernel_old_gid_t;\n #endif\n \n-  typedef long long __sanitizer___kernel_loff_t;\n-  typedef struct {\n-    unsigned long fds_bits[1024 / (8 * sizeof(long))];\n-  } __sanitizer___kernel_fd_set;\n+typedef long long __sanitizer___kernel_loff_t;\n+typedef struct {\n+  unsigned long fds_bits[1024 / (8 * sizeof(long))];\n+} __sanitizer___kernel_fd_set;\n #endif\n \n-  // This thing depends on the platform. We are only interested in the upper\n-  // limit. Verified with a compiler assert in .cpp.\n-  const int pthread_attr_t_max_sz = 128;\n-  union __sanitizer_pthread_attr_t {\n-    char size[pthread_attr_t_max_sz]; // NOLINT\n-    void *align;\n-  };\n+// This thing depends on the platform. We are only interested in the upper\n+// limit. Verified with a compiler assert in .cpp.\n+union __sanitizer_pthread_attr_t {\n+  char size[128];\n+  void *align;\n+};\n \n #if SANITIZER_ANDROID\n # if SANITIZER_MIPS\n-  typedef unsigned long __sanitizer_sigset_t[16/sizeof(unsigned long)];\n+typedef unsigned long __sanitizer_sigset_t[16 / sizeof(unsigned long)];\n # else\n-  typedef unsigned long __sanitizer_sigset_t;\n+typedef unsigned long __sanitizer_sigset_t;\n # endif\n #elif SANITIZER_MAC\n-  typedef unsigned __sanitizer_sigset_t;\n+typedef unsigned __sanitizer_sigset_t;\n #elif SANITIZER_LINUX\n-  struct __sanitizer_sigset_t {\n-    // The size is determined by looking at sizeof of real sigset_t on linux.\n-    uptr val[128 / sizeof(uptr)];\n-  };\n+struct __sanitizer_sigset_t {\n+  // The size is determined by looking at sizeof of real sigset_t on linux.\n+  uptr val[128 / sizeof(uptr)];\n+};\n #endif\n \n-  struct __sanitizer_siginfo {\n-    // The size is determined by looking at sizeof of real siginfo_t on linux.\n-    u64 opaque[128 / sizeof(u64)];\n-  };\n+struct __sanitizer_siginfo {\n+  // The size is determined by looking at sizeof of real siginfo_t on linux.\n+  u64 opaque[128 / sizeof(u64)];\n+};\n \n-  using __sanitizer_sighandler_ptr = void (*)(int sig);\n-  using __sanitizer_sigactionhandler_ptr =\n-      void (*)(int sig, __sanitizer_siginfo *siginfo, void *uctx);\n+using __sanitizer_sighandler_ptr = void (*)(int sig);\n+using __sanitizer_sigactionhandler_ptr = void (*)(int sig,\n+                                                  __sanitizer_siginfo *siginfo,\n+                                                  void *uctx);\n \n-  // Linux system headers define the 'sa_handler' and 'sa_sigaction' macros.\n+// Linux system headers define the 'sa_handler' and 'sa_sigaction' macros.\n #if SANITIZER_ANDROID && (SANITIZER_WORDSIZE == 64)\n-  struct __sanitizer_sigaction {\n-    unsigned sa_flags;\n-    union {\n-      __sanitizer_sigactionhandler_ptr sigaction;\n-      __sanitizer_sighandler_ptr handler;\n-    };\n-    __sanitizer_sigset_t sa_mask;\n-    void (*sa_restorer)();\n+struct __sanitizer_sigaction {\n+  unsigned sa_flags;\n+  union {\n+    __sanitizer_sigactionhandler_ptr sigaction;\n+    __sanitizer_sighandler_ptr handler;\n   };\n+  __sanitizer_sigset_t sa_mask;\n+  void (*sa_restorer)();\n+};\n #elif SANITIZER_ANDROID && SANITIZER_MIPS32  // check this before WORDSIZE == 32\n-  struct __sanitizer_sigaction {\n-    unsigned sa_flags;\n-    union {\n-      __sanitizer_sigactionhandler_ptr sigaction;\n-      __sanitizer_sighandler_ptr handler;\n-    };\n-    __sanitizer_sigset_t sa_mask;\n+struct __sanitizer_sigaction {\n+  unsigned sa_flags;\n+  union {\n+    __sanitizer_sigactionhandler_ptr sigaction;\n+    __sanitizer_sighandler_ptr handler;\n   };\n+  __sanitizer_sigset_t sa_mask;\n+};\n #elif SANITIZER_ANDROID && (SANITIZER_WORDSIZE == 32)\n-  struct __sanitizer_sigaction {\n-    union {\n-      __sanitizer_sigactionhandler_ptr sigaction;\n-      __sanitizer_sighandler_ptr handler;\n-    };\n-    __sanitizer_sigset_t sa_mask;\n-    uptr sa_flags;\n-    void (*sa_restorer)();\n+struct __sanitizer_sigaction {\n+  union {\n+    __sanitizer_sigactionhandler_ptr sigaction;\n+    __sanitizer_sighandler_ptr handler;\n   };\n+  __sanitizer_sigset_t sa_mask;\n+  uptr sa_flags;\n+  void (*sa_restorer)();\n+};\n #else // !SANITIZER_ANDROID\n-  struct __sanitizer_sigaction {\n+struct __sanitizer_sigaction {\n #if defined(__mips__) && !SANITIZER_FREEBSD\n-    unsigned int sa_flags;\n+  unsigned int sa_flags;\n #endif\n-    union {\n-      __sanitizer_sigactionhandler_ptr sigaction;\n-      __sanitizer_sighandler_ptr handler;\n-    };\n+  union {\n+    __sanitizer_sigactionhandler_ptr sigaction;\n+    __sanitizer_sighandler_ptr handler;\n+  };\n #if SANITIZER_FREEBSD\n-    int sa_flags;\n-    __sanitizer_sigset_t sa_mask;\n+  int sa_flags;\n+  __sanitizer_sigset_t sa_mask;\n #else\n #if defined(__s390x__)\n-    int sa_resv;\n+  int sa_resv;\n #else\n-    __sanitizer_sigset_t sa_mask;\n+  __sanitizer_sigset_t sa_mask;\n #endif\n #ifndef __mips__\n #if defined(__sparc__)\n #if __GLIBC_PREREQ (2, 20)\n-    // On sparc glibc 2.19 and earlier sa_flags was unsigned long.\n+  // On sparc glibc 2.19 and earlier sa_flags was unsigned long.\n #if defined(__arch64__)\n-    // To maintain ABI compatibility on sparc64 when switching to an int,\n-    // __glibc_reserved0 was added.\n-    int __glibc_reserved0;\n+  // To maintain ABI compatibility on sparc64 when switching to an int,\n+  // __glibc_reserved0 was added.\n+  int __glibc_reserved0;\n #endif\n-    int sa_flags;\n+  int sa_flags;\n #else\n-    unsigned long sa_flags;\n+  unsigned long sa_flags;\n #endif\n #else\n-    int sa_flags;\n+  int sa_flags;\n #endif\n #endif\n #endif\n #if SANITIZER_LINUX\n-    void (*sa_restorer)();\n+  void (*sa_restorer)();\n #endif\n #if defined(__mips__) && (SANITIZER_WORDSIZE == 32)\n-    int sa_resv[1];\n+  int sa_resv[1];\n #endif\n #if defined(__s390x__)\n-    __sanitizer_sigset_t sa_mask;\n+  __sanitizer_sigset_t sa_mask;\n #endif\n-  };\n+};\n #endif // !SANITIZER_ANDROID\n \n #if defined(__mips__)\n-  struct __sanitizer_kernel_sigset_t {\n-    uptr sig[2];\n-  };\n+struct __sanitizer_kernel_sigset_t {\n+  uptr sig[2];\n+};\n #else\n-  struct __sanitizer_kernel_sigset_t {\n-    u8 sig[8];\n-  };\n+struct __sanitizer_kernel_sigset_t {\n+  u8 sig[8];\n+};\n #endif\n \n-  // Linux system headers define the 'sa_handler' and 'sa_sigaction' macros.\n+// Linux system headers define the 'sa_handler' and 'sa_sigaction' macros.\n #if SANITIZER_MIPS\n-  struct __sanitizer_kernel_sigaction_t {\n-    unsigned int sa_flags;\n-    union {\n-      void (*handler)(int signo);\n-      void (*sigaction)(int signo, __sanitizer_siginfo *info, void *ctx);\n-    };\n-    __sanitizer_kernel_sigset_t sa_mask;\n-    void (*sa_restorer)(void);\n+struct __sanitizer_kernel_sigaction_t {\n+  unsigned int sa_flags;\n+  union {\n+    void (*handler)(int signo);\n+    void (*sigaction)(int signo, __sanitizer_siginfo *info, void *ctx);\n   };\n+  __sanitizer_kernel_sigset_t sa_mask;\n+  void (*sa_restorer)(void);\n+};\n #else\n-  struct __sanitizer_kernel_sigaction_t {\n-    union {\n-      void (*handler)(int signo);\n-      void (*sigaction)(int signo, __sanitizer_siginfo *info, void *ctx);\n-    };\n-    unsigned long sa_flags;\n-    void (*sa_restorer)(void);\n-    __sanitizer_kernel_sigset_t sa_mask;\n+struct __sanitizer_kernel_sigaction_t {\n+  union {\n+    void (*handler)(int signo);\n+    void (*sigaction)(int signo, __sanitizer_siginfo *info, void *ctx);\n   };\n+  unsigned long sa_flags;\n+  void (*sa_restorer)(void);\n+  __sanitizer_kernel_sigset_t sa_mask;\n+};\n #endif\n \n-  extern const uptr sig_ign;\n-  extern const uptr sig_dfl;\n-  extern const uptr sig_err;\n-  extern const uptr sa_siginfo;\n+extern const uptr sig_ign;\n+extern const uptr sig_dfl;\n+extern const uptr sig_err;\n+extern const uptr sa_siginfo;\n \n #if SANITIZER_LINUX\n-  extern int e_tabsz;\n+extern int e_tabsz;\n #endif\n \n-  extern int af_inet;\n-  extern int af_inet6;\n-  uptr __sanitizer_in_addr_sz(int af);\n+extern int af_inet;\n+extern int af_inet6;\n+uptr __sanitizer_in_addr_sz(int af);\n \n #if SANITIZER_LINUX\n-  struct __sanitizer_dl_phdr_info {\n-    uptr dlpi_addr;\n-    const char *dlpi_name;\n-    const void *dlpi_phdr;\n-    short dlpi_phnum;\n-  };\n+struct __sanitizer_dl_phdr_info {\n+  uptr dlpi_addr;\n+  const char *dlpi_name;\n+  const void *dlpi_phdr;\n+  short dlpi_phnum;\n+};\n \n-  extern unsigned struct_ElfW_Phdr_sz;\n+extern unsigned struct_ElfW_Phdr_sz;\n #endif\n \n-  struct __sanitizer_addrinfo {\n-    int ai_flags;\n-    int ai_family;\n-    int ai_socktype;\n-    int ai_protocol;\n+struct __sanitizer_addrinfo {\n+  int ai_flags;\n+  int ai_family;\n+  int ai_socktype;\n+  int ai_protocol;\n #if SANITIZER_ANDROID || SANITIZER_MAC\n-    unsigned ai_addrlen;\n-    char *ai_canonname;\n-    void *ai_addr;\n+  unsigned ai_addrlen;\n+  char *ai_canonname;\n+  void *ai_addr;\n #else // LINUX\n-    unsigned ai_addrlen;\n-    void *ai_addr;\n-    char *ai_canonname;\n+  unsigned ai_addrlen;\n+  void *ai_addr;\n+  char *ai_canonname;\n #endif\n-    struct __sanitizer_addrinfo *ai_next;\n-  };\n+  struct __sanitizer_addrinfo *ai_next;\n+};\n \n-  struct __sanitizer_hostent {\n-    char *h_name;\n-    char **h_aliases;\n-    int h_addrtype;\n-    int h_length;\n-    char **h_addr_list;\n-  };\n+struct __sanitizer_hostent {\n+  char *h_name;\n+  char **h_aliases;\n+  int h_addrtype;\n+  int h_length;\n+  char **h_addr_list;\n+};\n \n-  struct __sanitizer_pollfd {\n-    int fd;\n-    short events;\n-    short revents;\n-  };\n+struct __sanitizer_pollfd {\n+  int fd;\n+  short events;\n+  short revents;\n+};\n \n #if SANITIZER_ANDROID || SANITIZER_MAC\n-  typedef unsigned __sanitizer_nfds_t;\n+typedef unsigned __sanitizer_nfds_t;\n #else\n-  typedef unsigned long __sanitizer_nfds_t;\n+typedef unsigned long __sanitizer_nfds_t;\n #endif\n \n #if !SANITIZER_ANDROID\n # if SANITIZER_LINUX\n-  struct __sanitizer_glob_t {\n-    uptr gl_pathc;\n-    char **gl_pathv;\n-    uptr gl_offs;\n-    int gl_flags;\n-\n-    void (*gl_closedir)(void *dirp);\n-    void *(*gl_readdir)(void *dirp);\n-    void *(*gl_opendir)(const char *);\n-    int (*gl_lstat)(const char *, void *);\n-    int (*gl_stat)(const char *, void *);\n-  };\n+struct __sanitizer_glob_t {\n+  uptr gl_pathc;\n+  char **gl_pathv;\n+  uptr gl_offs;\n+  int gl_flags;\n+\n+  void (*gl_closedir)(void *dirp);\n+  void *(*gl_readdir)(void *dirp);\n+  void *(*gl_opendir)(const char *);\n+  int (*gl_lstat)(const char *, void *);\n+  int (*gl_stat)(const char *, void *);\n+};\n # endif  // SANITIZER_LINUX\n \n # if SANITIZER_LINUX\n-  extern int glob_nomatch;\n-  extern int glob_altdirfunc;\n+extern int glob_nomatch;\n+extern int glob_altdirfunc;\n # endif\n #endif  // !SANITIZER_ANDROID\n \n-  extern unsigned path_max;\n+extern unsigned path_max;\n \n-  struct __sanitizer_wordexp_t {\n-    uptr we_wordc;\n-    char **we_wordv;\n-    uptr we_offs;\n-  };\n+struct __sanitizer_wordexp_t {\n+  uptr we_wordc;\n+  char **we_wordv;\n+  uptr we_offs;\n+};\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n-  struct __sanitizer_FILE {\n-    int _flags;\n-    char *_IO_read_ptr;\n-    char *_IO_read_end;\n-    char *_IO_read_base;\n-    char *_IO_write_base;\n-    char *_IO_write_ptr;\n-    char *_IO_write_end;\n-    char *_IO_buf_base;\n-    char *_IO_buf_end;\n-    char *_IO_save_base;\n-    char *_IO_backup_base;\n-    char *_IO_save_end;\n-    void *_markers;\n-    __sanitizer_FILE *_chain;\n-    int _fileno;\n-  };\n+struct __sanitizer_FILE {\n+  int _flags;\n+  char *_IO_read_ptr;\n+  char *_IO_read_end;\n+  char *_IO_read_base;\n+  char *_IO_write_base;\n+  char *_IO_write_ptr;\n+  char *_IO_write_end;\n+  char *_IO_buf_base;\n+  char *_IO_buf_end;\n+  char *_IO_save_base;\n+  char *_IO_backup_base;\n+  char *_IO_save_end;\n+  void *_markers;\n+  __sanitizer_FILE *_chain;\n+  int _fileno;\n+};\n # define SANITIZER_HAS_STRUCT_FILE 1\n #else\n-  typedef void __sanitizer_FILE;\n+typedef void __sanitizer_FILE;\n # define SANITIZER_HAS_STRUCT_FILE 0\n #endif\n \n-#if SANITIZER_LINUX && !SANITIZER_ANDROID && \\\n-  (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n-    defined(__powerpc64__) || defined(__aarch64__) || defined(__arm__) || \\\n-    defined(__s390__))\n-  extern unsigned struct_user_regs_struct_sz;\n-  extern unsigned struct_user_fpregs_struct_sz;\n-  extern unsigned struct_user_fpxregs_struct_sz;\n-  extern unsigned struct_user_vfpregs_struct_sz;\n-\n-  extern int ptrace_peektext;\n-  extern int ptrace_peekdata;\n-  extern int ptrace_peekuser;\n-  extern int ptrace_getregs;\n-  extern int ptrace_setregs;\n-  extern int ptrace_getfpregs;\n-  extern int ptrace_setfpregs;\n-  extern int ptrace_getfpxregs;\n-  extern int ptrace_setfpxregs;\n-  extern int ptrace_getvfpregs;\n-  extern int ptrace_setvfpregs;\n-  extern int ptrace_getsiginfo;\n-  extern int ptrace_setsiginfo;\n-  extern int ptrace_getregset;\n-  extern int ptrace_setregset;\n-  extern int ptrace_geteventmsg;\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID &&                               \\\n+    (defined(__i386) || defined(__x86_64) || defined(__mips64) ||          \\\n+     defined(__powerpc64__) || defined(__aarch64__) || defined(__arm__) || \\\n+     defined(__s390__))\n+extern unsigned struct_user_regs_struct_sz;\n+extern unsigned struct_user_fpregs_struct_sz;\n+extern unsigned struct_user_fpxregs_struct_sz;\n+extern unsigned struct_user_vfpregs_struct_sz;\n+\n+extern int ptrace_peektext;\n+extern int ptrace_peekdata;\n+extern int ptrace_peekuser;\n+extern int ptrace_getregs;\n+extern int ptrace_setregs;\n+extern int ptrace_getfpregs;\n+extern int ptrace_setfpregs;\n+extern int ptrace_getfpxregs;\n+extern int ptrace_setfpxregs;\n+extern int ptrace_getvfpregs;\n+extern int ptrace_setvfpregs;\n+extern int ptrace_getsiginfo;\n+extern int ptrace_setsiginfo;\n+extern int ptrace_getregset;\n+extern int ptrace_setregset;\n+extern int ptrace_geteventmsg;\n #endif\n \n #if SANITIZER_LINUX  && !SANITIZER_ANDROID\n-  extern unsigned struct_shminfo_sz;\n-  extern unsigned struct_shm_info_sz;\n-  extern int shmctl_ipc_stat;\n-  extern int shmctl_ipc_info;\n-  extern int shmctl_shm_info;\n-  extern int shmctl_shm_stat;\n+extern unsigned struct_shminfo_sz;\n+extern unsigned struct_shm_info_sz;\n+extern int shmctl_ipc_stat;\n+extern int shmctl_ipc_info;\n+extern int shmctl_shm_info;\n+extern int shmctl_shm_stat;\n #endif\n \n #if !SANITIZER_MAC && !SANITIZER_FREEBSD\n-  extern unsigned struct_utmp_sz;\n+extern unsigned struct_utmp_sz;\n #endif\n #if !SANITIZER_ANDROID\n-  extern unsigned struct_utmpx_sz;\n+extern unsigned struct_utmpx_sz;\n #endif\n \n-  extern int map_fixed;\n+extern int map_fixed;\n \n-  // ioctl arguments\n-  struct __sanitizer_ifconf {\n-    int ifc_len;\n-    union {\n-      void *ifcu_req;\n-    } ifc_ifcu;\n+// ioctl arguments\n+struct __sanitizer_ifconf {\n+  int ifc_len;\n+  union {\n+    void *ifcu_req;\n+  } ifc_ifcu;\n #if SANITIZER_MAC\n-  } __attribute__((packed));\n+} __attribute__((packed));\n #else\n-  };\n+};\n #endif\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n@@ -932,519 +934,519 @@ struct __sanitizer_cookie_io_functions_t {\n #define IOC_SIZE(nr) (((nr) >> IOC_SIZESHIFT) & IOC_SIZEMASK)\n #endif\n \n-  extern unsigned struct_ifreq_sz;\n-  extern unsigned struct_termios_sz;\n-  extern unsigned struct_winsize_sz;\n+extern unsigned struct_ifreq_sz;\n+extern unsigned struct_termios_sz;\n+extern unsigned struct_winsize_sz;\n \n #if SANITIZER_LINUX\n-  extern unsigned struct_arpreq_sz;\n-  extern unsigned struct_cdrom_msf_sz;\n-  extern unsigned struct_cdrom_multisession_sz;\n-  extern unsigned struct_cdrom_read_audio_sz;\n-  extern unsigned struct_cdrom_subchnl_sz;\n-  extern unsigned struct_cdrom_ti_sz;\n-  extern unsigned struct_cdrom_tocentry_sz;\n-  extern unsigned struct_cdrom_tochdr_sz;\n-  extern unsigned struct_cdrom_volctrl_sz;\n-  extern unsigned struct_ff_effect_sz;\n-  extern unsigned struct_floppy_drive_params_sz;\n-  extern unsigned struct_floppy_drive_struct_sz;\n-  extern unsigned struct_floppy_fdc_state_sz;\n-  extern unsigned struct_floppy_max_errors_sz;\n-  extern unsigned struct_floppy_raw_cmd_sz;\n-  extern unsigned struct_floppy_struct_sz;\n-  extern unsigned struct_floppy_write_errors_sz;\n-  extern unsigned struct_format_descr_sz;\n-  extern unsigned struct_hd_driveid_sz;\n-  extern unsigned struct_hd_geometry_sz;\n-  extern unsigned struct_input_absinfo_sz;\n-  extern unsigned struct_input_id_sz;\n-  extern unsigned struct_mtpos_sz;\n-  extern unsigned struct_termio_sz;\n-  extern unsigned struct_vt_consize_sz;\n-  extern unsigned struct_vt_sizes_sz;\n-  extern unsigned struct_vt_stat_sz;\n+extern unsigned struct_arpreq_sz;\n+extern unsigned struct_cdrom_msf_sz;\n+extern unsigned struct_cdrom_multisession_sz;\n+extern unsigned struct_cdrom_read_audio_sz;\n+extern unsigned struct_cdrom_subchnl_sz;\n+extern unsigned struct_cdrom_ti_sz;\n+extern unsigned struct_cdrom_tocentry_sz;\n+extern unsigned struct_cdrom_tochdr_sz;\n+extern unsigned struct_cdrom_volctrl_sz;\n+extern unsigned struct_ff_effect_sz;\n+extern unsigned struct_floppy_drive_params_sz;\n+extern unsigned struct_floppy_drive_struct_sz;\n+extern unsigned struct_floppy_fdc_state_sz;\n+extern unsigned struct_floppy_max_errors_sz;\n+extern unsigned struct_floppy_raw_cmd_sz;\n+extern unsigned struct_floppy_struct_sz;\n+extern unsigned struct_floppy_write_errors_sz;\n+extern unsigned struct_format_descr_sz;\n+extern unsigned struct_hd_driveid_sz;\n+extern unsigned struct_hd_geometry_sz;\n+extern unsigned struct_input_absinfo_sz;\n+extern unsigned struct_input_id_sz;\n+extern unsigned struct_mtpos_sz;\n+extern unsigned struct_termio_sz;\n+extern unsigned struct_vt_consize_sz;\n+extern unsigned struct_vt_sizes_sz;\n+extern unsigned struct_vt_stat_sz;\n #endif  // SANITIZER_LINUX\n \n #if SANITIZER_LINUX\n-  extern unsigned struct_copr_buffer_sz;\n-  extern unsigned struct_copr_debug_buf_sz;\n-  extern unsigned struct_copr_msg_sz;\n-  extern unsigned struct_midi_info_sz;\n-  extern unsigned struct_mtget_sz;\n-  extern unsigned struct_mtop_sz;\n-  extern unsigned struct_rtentry_sz;\n-  extern unsigned struct_sbi_instrument_sz;\n-  extern unsigned struct_seq_event_rec_sz;\n-  extern unsigned struct_synth_info_sz;\n-  extern unsigned struct_vt_mode_sz;\n+extern unsigned struct_copr_buffer_sz;\n+extern unsigned struct_copr_debug_buf_sz;\n+extern unsigned struct_copr_msg_sz;\n+extern unsigned struct_midi_info_sz;\n+extern unsigned struct_mtget_sz;\n+extern unsigned struct_mtop_sz;\n+extern unsigned struct_rtentry_sz;\n+extern unsigned struct_sbi_instrument_sz;\n+extern unsigned struct_seq_event_rec_sz;\n+extern unsigned struct_synth_info_sz;\n+extern unsigned struct_vt_mode_sz;\n #endif // SANITIZER_LINUX\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n-  extern unsigned struct_ax25_parms_struct_sz;\n-  extern unsigned struct_cyclades_monitor_sz;\n-  extern unsigned struct_input_keymap_entry_sz;\n-  extern unsigned struct_ipx_config_data_sz;\n-  extern unsigned struct_kbdiacrs_sz;\n-  extern unsigned struct_kbentry_sz;\n-  extern unsigned struct_kbkeycode_sz;\n-  extern unsigned struct_kbsentry_sz;\n-  extern unsigned struct_mtconfiginfo_sz;\n-  extern unsigned struct_nr_parms_struct_sz;\n-  extern unsigned struct_scc_modem_sz;\n-  extern unsigned struct_scc_stat_sz;\n-  extern unsigned struct_serial_multiport_struct_sz;\n-  extern unsigned struct_serial_struct_sz;\n-  extern unsigned struct_sockaddr_ax25_sz;\n-  extern unsigned struct_unimapdesc_sz;\n-  extern unsigned struct_unimapinit_sz;\n+extern unsigned struct_ax25_parms_struct_sz;\n+extern unsigned struct_cyclades_monitor_sz;\n+extern unsigned struct_input_keymap_entry_sz;\n+extern unsigned struct_ipx_config_data_sz;\n+extern unsigned struct_kbdiacrs_sz;\n+extern unsigned struct_kbentry_sz;\n+extern unsigned struct_kbkeycode_sz;\n+extern unsigned struct_kbsentry_sz;\n+extern unsigned struct_mtconfiginfo_sz;\n+extern unsigned struct_nr_parms_struct_sz;\n+extern unsigned struct_scc_modem_sz;\n+extern unsigned struct_scc_stat_sz;\n+extern unsigned struct_serial_multiport_struct_sz;\n+extern unsigned struct_serial_struct_sz;\n+extern unsigned struct_sockaddr_ax25_sz;\n+extern unsigned struct_unimapdesc_sz;\n+extern unsigned struct_unimapinit_sz;\n #endif  // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n-  extern const unsigned long __sanitizer_bufsiz;\n+extern const unsigned long __sanitizer_bufsiz;\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n-  extern unsigned struct_audio_buf_info_sz;\n-  extern unsigned struct_ppp_stats_sz;\n+extern unsigned struct_audio_buf_info_sz;\n+extern unsigned struct_ppp_stats_sz;\n #endif  // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n \n #if !SANITIZER_ANDROID && !SANITIZER_MAC\n-  extern unsigned struct_sioc_sg_req_sz;\n-  extern unsigned struct_sioc_vif_req_sz;\n-#endif\n-\n-  // ioctl request identifiers\n-\n-  // A special value to mark ioctls that are not present on the target platform,\n-  // when it can not be determined without including any system headers.\n-  extern const unsigned IOCTL_NOT_PRESENT;\n-\n-  extern unsigned IOCTL_FIOASYNC;\n-  extern unsigned IOCTL_FIOCLEX;\n-  extern unsigned IOCTL_FIOGETOWN;\n-  extern unsigned IOCTL_FIONBIO;\n-  extern unsigned IOCTL_FIONCLEX;\n-  extern unsigned IOCTL_FIOSETOWN;\n-  extern unsigned IOCTL_SIOCADDMULTI;\n-  extern unsigned IOCTL_SIOCATMARK;\n-  extern unsigned IOCTL_SIOCDELMULTI;\n-  extern unsigned IOCTL_SIOCGIFADDR;\n-  extern unsigned IOCTL_SIOCGIFBRDADDR;\n-  extern unsigned IOCTL_SIOCGIFCONF;\n-  extern unsigned IOCTL_SIOCGIFDSTADDR;\n-  extern unsigned IOCTL_SIOCGIFFLAGS;\n-  extern unsigned IOCTL_SIOCGIFMETRIC;\n-  extern unsigned IOCTL_SIOCGIFMTU;\n-  extern unsigned IOCTL_SIOCGIFNETMASK;\n-  extern unsigned IOCTL_SIOCGPGRP;\n-  extern unsigned IOCTL_SIOCSIFADDR;\n-  extern unsigned IOCTL_SIOCSIFBRDADDR;\n-  extern unsigned IOCTL_SIOCSIFDSTADDR;\n-  extern unsigned IOCTL_SIOCSIFFLAGS;\n-  extern unsigned IOCTL_SIOCSIFMETRIC;\n-  extern unsigned IOCTL_SIOCSIFMTU;\n-  extern unsigned IOCTL_SIOCSIFNETMASK;\n-  extern unsigned IOCTL_SIOCSPGRP;\n-  extern unsigned IOCTL_TIOCCONS;\n-  extern unsigned IOCTL_TIOCEXCL;\n-  extern unsigned IOCTL_TIOCGETD;\n-  extern unsigned IOCTL_TIOCGPGRP;\n-  extern unsigned IOCTL_TIOCGWINSZ;\n-  extern unsigned IOCTL_TIOCMBIC;\n-  extern unsigned IOCTL_TIOCMBIS;\n-  extern unsigned IOCTL_TIOCMGET;\n-  extern unsigned IOCTL_TIOCMSET;\n-  extern unsigned IOCTL_TIOCNOTTY;\n-  extern unsigned IOCTL_TIOCNXCL;\n-  extern unsigned IOCTL_TIOCOUTQ;\n-  extern unsigned IOCTL_TIOCPKT;\n-  extern unsigned IOCTL_TIOCSCTTY;\n-  extern unsigned IOCTL_TIOCSETD;\n-  extern unsigned IOCTL_TIOCSPGRP;\n-  extern unsigned IOCTL_TIOCSTI;\n-  extern unsigned IOCTL_TIOCSWINSZ;\n+extern unsigned struct_sioc_sg_req_sz;\n+extern unsigned struct_sioc_vif_req_sz;\n+#endif\n+\n+// ioctl request identifiers\n+\n+// A special value to mark ioctls that are not present on the target platform,\n+// when it can not be determined without including any system headers.\n+extern const unsigned IOCTL_NOT_PRESENT;\n+\n+extern unsigned IOCTL_FIOASYNC;\n+extern unsigned IOCTL_FIOCLEX;\n+extern unsigned IOCTL_FIOGETOWN;\n+extern unsigned IOCTL_FIONBIO;\n+extern unsigned IOCTL_FIONCLEX;\n+extern unsigned IOCTL_FIOSETOWN;\n+extern unsigned IOCTL_SIOCADDMULTI;\n+extern unsigned IOCTL_SIOCATMARK;\n+extern unsigned IOCTL_SIOCDELMULTI;\n+extern unsigned IOCTL_SIOCGIFADDR;\n+extern unsigned IOCTL_SIOCGIFBRDADDR;\n+extern unsigned IOCTL_SIOCGIFCONF;\n+extern unsigned IOCTL_SIOCGIFDSTADDR;\n+extern unsigned IOCTL_SIOCGIFFLAGS;\n+extern unsigned IOCTL_SIOCGIFMETRIC;\n+extern unsigned IOCTL_SIOCGIFMTU;\n+extern unsigned IOCTL_SIOCGIFNETMASK;\n+extern unsigned IOCTL_SIOCGPGRP;\n+extern unsigned IOCTL_SIOCSIFADDR;\n+extern unsigned IOCTL_SIOCSIFBRDADDR;\n+extern unsigned IOCTL_SIOCSIFDSTADDR;\n+extern unsigned IOCTL_SIOCSIFFLAGS;\n+extern unsigned IOCTL_SIOCSIFMETRIC;\n+extern unsigned IOCTL_SIOCSIFMTU;\n+extern unsigned IOCTL_SIOCSIFNETMASK;\n+extern unsigned IOCTL_SIOCSPGRP;\n+extern unsigned IOCTL_TIOCCONS;\n+extern unsigned IOCTL_TIOCEXCL;\n+extern unsigned IOCTL_TIOCGETD;\n+extern unsigned IOCTL_TIOCGPGRP;\n+extern unsigned IOCTL_TIOCGWINSZ;\n+extern unsigned IOCTL_TIOCMBIC;\n+extern unsigned IOCTL_TIOCMBIS;\n+extern unsigned IOCTL_TIOCMGET;\n+extern unsigned IOCTL_TIOCMSET;\n+extern unsigned IOCTL_TIOCNOTTY;\n+extern unsigned IOCTL_TIOCNXCL;\n+extern unsigned IOCTL_TIOCOUTQ;\n+extern unsigned IOCTL_TIOCPKT;\n+extern unsigned IOCTL_TIOCSCTTY;\n+extern unsigned IOCTL_TIOCSETD;\n+extern unsigned IOCTL_TIOCSPGRP;\n+extern unsigned IOCTL_TIOCSTI;\n+extern unsigned IOCTL_TIOCSWINSZ;\n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n-  extern unsigned IOCTL_SIOCGETSGCNT;\n-  extern unsigned IOCTL_SIOCGETVIFCNT;\n+extern unsigned IOCTL_SIOCGETSGCNT;\n+extern unsigned IOCTL_SIOCGETVIFCNT;\n #endif\n #if SANITIZER_LINUX\n-  extern unsigned IOCTL_EVIOCGABS;\n-  extern unsigned IOCTL_EVIOCGBIT;\n-  extern unsigned IOCTL_EVIOCGEFFECTS;\n-  extern unsigned IOCTL_EVIOCGID;\n-  extern unsigned IOCTL_EVIOCGKEY;\n-  extern unsigned IOCTL_EVIOCGKEYCODE;\n-  extern unsigned IOCTL_EVIOCGLED;\n-  extern unsigned IOCTL_EVIOCGNAME;\n-  extern unsigned IOCTL_EVIOCGPHYS;\n-  extern unsigned IOCTL_EVIOCGRAB;\n-  extern unsigned IOCTL_EVIOCGREP;\n-  extern unsigned IOCTL_EVIOCGSND;\n-  extern unsigned IOCTL_EVIOCGSW;\n-  extern unsigned IOCTL_EVIOCGUNIQ;\n-  extern unsigned IOCTL_EVIOCGVERSION;\n-  extern unsigned IOCTL_EVIOCRMFF;\n-  extern unsigned IOCTL_EVIOCSABS;\n-  extern unsigned IOCTL_EVIOCSFF;\n-  extern unsigned IOCTL_EVIOCSKEYCODE;\n-  extern unsigned IOCTL_EVIOCSREP;\n-  extern unsigned IOCTL_BLKFLSBUF;\n-  extern unsigned IOCTL_BLKGETSIZE;\n-  extern unsigned IOCTL_BLKRAGET;\n-  extern unsigned IOCTL_BLKRASET;\n-  extern unsigned IOCTL_BLKROGET;\n-  extern unsigned IOCTL_BLKROSET;\n-  extern unsigned IOCTL_BLKRRPART;\n-  extern unsigned IOCTL_CDROMAUDIOBUFSIZ;\n-  extern unsigned IOCTL_CDROMEJECT;\n-  extern unsigned IOCTL_CDROMEJECT_SW;\n-  extern unsigned IOCTL_CDROMMULTISESSION;\n-  extern unsigned IOCTL_CDROMPAUSE;\n-  extern unsigned IOCTL_CDROMPLAYMSF;\n-  extern unsigned IOCTL_CDROMPLAYTRKIND;\n-  extern unsigned IOCTL_CDROMREADAUDIO;\n-  extern unsigned IOCTL_CDROMREADCOOKED;\n-  extern unsigned IOCTL_CDROMREADMODE1;\n-  extern unsigned IOCTL_CDROMREADMODE2;\n-  extern unsigned IOCTL_CDROMREADRAW;\n-  extern unsigned IOCTL_CDROMREADTOCENTRY;\n-  extern unsigned IOCTL_CDROMREADTOCHDR;\n-  extern unsigned IOCTL_CDROMRESET;\n-  extern unsigned IOCTL_CDROMRESUME;\n-  extern unsigned IOCTL_CDROMSEEK;\n-  extern unsigned IOCTL_CDROMSTART;\n-  extern unsigned IOCTL_CDROMSTOP;\n-  extern unsigned IOCTL_CDROMSUBCHNL;\n-  extern unsigned IOCTL_CDROMVOLCTRL;\n-  extern unsigned IOCTL_CDROMVOLREAD;\n-  extern unsigned IOCTL_CDROM_GET_UPC;\n-  extern unsigned IOCTL_FDCLRPRM;\n-  extern unsigned IOCTL_FDDEFPRM;\n-  extern unsigned IOCTL_FDFLUSH;\n-  extern unsigned IOCTL_FDFMTBEG;\n-  extern unsigned IOCTL_FDFMTEND;\n-  extern unsigned IOCTL_FDFMTTRK;\n-  extern unsigned IOCTL_FDGETDRVPRM;\n-  extern unsigned IOCTL_FDGETDRVSTAT;\n-  extern unsigned IOCTL_FDGETDRVTYP;\n-  extern unsigned IOCTL_FDGETFDCSTAT;\n-  extern unsigned IOCTL_FDGETMAXERRS;\n-  extern unsigned IOCTL_FDGETPRM;\n-  extern unsigned IOCTL_FDMSGOFF;\n-  extern unsigned IOCTL_FDMSGON;\n-  extern unsigned IOCTL_FDPOLLDRVSTAT;\n-  extern unsigned IOCTL_FDRAWCMD;\n-  extern unsigned IOCTL_FDRESET;\n-  extern unsigned IOCTL_FDSETDRVPRM;\n-  extern unsigned IOCTL_FDSETEMSGTRESH;\n-  extern unsigned IOCTL_FDSETMAXERRS;\n-  extern unsigned IOCTL_FDSETPRM;\n-  extern unsigned IOCTL_FDTWADDLE;\n-  extern unsigned IOCTL_FDWERRORCLR;\n-  extern unsigned IOCTL_FDWERRORGET;\n-  extern unsigned IOCTL_HDIO_DRIVE_CMD;\n-  extern unsigned IOCTL_HDIO_GETGEO;\n-  extern unsigned IOCTL_HDIO_GET_32BIT;\n-  extern unsigned IOCTL_HDIO_GET_DMA;\n-  extern unsigned IOCTL_HDIO_GET_IDENTITY;\n-  extern unsigned IOCTL_HDIO_GET_KEEPSETTINGS;\n-  extern unsigned IOCTL_HDIO_GET_MULTCOUNT;\n-  extern unsigned IOCTL_HDIO_GET_NOWERR;\n-  extern unsigned IOCTL_HDIO_GET_UNMASKINTR;\n-  extern unsigned IOCTL_HDIO_SET_32BIT;\n-  extern unsigned IOCTL_HDIO_SET_DMA;\n-  extern unsigned IOCTL_HDIO_SET_KEEPSETTINGS;\n-  extern unsigned IOCTL_HDIO_SET_MULTCOUNT;\n-  extern unsigned IOCTL_HDIO_SET_NOWERR;\n-  extern unsigned IOCTL_HDIO_SET_UNMASKINTR;\n-  extern unsigned IOCTL_MTIOCPOS;\n-  extern unsigned IOCTL_PPPIOCGASYNCMAP;\n-  extern unsigned IOCTL_PPPIOCGDEBUG;\n-  extern unsigned IOCTL_PPPIOCGFLAGS;\n-  extern unsigned IOCTL_PPPIOCGUNIT;\n-  extern unsigned IOCTL_PPPIOCGXASYNCMAP;\n-  extern unsigned IOCTL_PPPIOCSASYNCMAP;\n-  extern unsigned IOCTL_PPPIOCSDEBUG;\n-  extern unsigned IOCTL_PPPIOCSFLAGS;\n-  extern unsigned IOCTL_PPPIOCSMAXCID;\n-  extern unsigned IOCTL_PPPIOCSMRU;\n-  extern unsigned IOCTL_PPPIOCSXASYNCMAP;\n-  extern unsigned IOCTL_SIOCDARP;\n-  extern unsigned IOCTL_SIOCDRARP;\n-  extern unsigned IOCTL_SIOCGARP;\n-  extern unsigned IOCTL_SIOCGIFENCAP;\n-  extern unsigned IOCTL_SIOCGIFHWADDR;\n-  extern unsigned IOCTL_SIOCGIFMAP;\n-  extern unsigned IOCTL_SIOCGIFMEM;\n-  extern unsigned IOCTL_SIOCGIFNAME;\n-  extern unsigned IOCTL_SIOCGIFSLAVE;\n-  extern unsigned IOCTL_SIOCGRARP;\n-  extern unsigned IOCTL_SIOCGSTAMP;\n-  extern unsigned IOCTL_SIOCSARP;\n-  extern unsigned IOCTL_SIOCSIFENCAP;\n-  extern unsigned IOCTL_SIOCSIFHWADDR;\n-  extern unsigned IOCTL_SIOCSIFLINK;\n-  extern unsigned IOCTL_SIOCSIFMAP;\n-  extern unsigned IOCTL_SIOCSIFMEM;\n-  extern unsigned IOCTL_SIOCSIFSLAVE;\n-  extern unsigned IOCTL_SIOCSRARP;\n-  extern unsigned IOCTL_SNDCTL_COPR_HALT;\n-  extern unsigned IOCTL_SNDCTL_COPR_LOAD;\n-  extern unsigned IOCTL_SNDCTL_COPR_RCODE;\n-  extern unsigned IOCTL_SNDCTL_COPR_RCVMSG;\n-  extern unsigned IOCTL_SNDCTL_COPR_RDATA;\n-  extern unsigned IOCTL_SNDCTL_COPR_RESET;\n-  extern unsigned IOCTL_SNDCTL_COPR_RUN;\n-  extern unsigned IOCTL_SNDCTL_COPR_SENDMSG;\n-  extern unsigned IOCTL_SNDCTL_COPR_WCODE;\n-  extern unsigned IOCTL_SNDCTL_COPR_WDATA;\n-  extern unsigned IOCTL_TCFLSH;\n-  extern unsigned IOCTL_TCGETA;\n-  extern unsigned IOCTL_TCGETS;\n-  extern unsigned IOCTL_TCSBRK;\n-  extern unsigned IOCTL_TCSBRKP;\n-  extern unsigned IOCTL_TCSETA;\n-  extern unsigned IOCTL_TCSETAF;\n-  extern unsigned IOCTL_TCSETAW;\n-  extern unsigned IOCTL_TCSETS;\n-  extern unsigned IOCTL_TCSETSF;\n-  extern unsigned IOCTL_TCSETSW;\n-  extern unsigned IOCTL_TCXONC;\n-  extern unsigned IOCTL_TIOCGLCKTRMIOS;\n-  extern unsigned IOCTL_TIOCGSOFTCAR;\n-  extern unsigned IOCTL_TIOCINQ;\n-  extern unsigned IOCTL_TIOCLINUX;\n-  extern unsigned IOCTL_TIOCSERCONFIG;\n-  extern unsigned IOCTL_TIOCSERGETLSR;\n-  extern unsigned IOCTL_TIOCSERGWILD;\n-  extern unsigned IOCTL_TIOCSERSWILD;\n-  extern unsigned IOCTL_TIOCSLCKTRMIOS;\n-  extern unsigned IOCTL_TIOCSSOFTCAR;\n-  extern unsigned IOCTL_VT_DISALLOCATE;\n-  extern unsigned IOCTL_VT_GETSTATE;\n-  extern unsigned IOCTL_VT_RESIZE;\n-  extern unsigned IOCTL_VT_RESIZEX;\n-  extern unsigned IOCTL_VT_SENDSIG;\n-  extern unsigned IOCTL_MTIOCGET;\n-  extern unsigned IOCTL_MTIOCTOP;\n-  extern unsigned IOCTL_SIOCADDRT;\n-  extern unsigned IOCTL_SIOCDELRT;\n-  extern unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE;\n-  extern unsigned IOCTL_SNDCTL_DSP_GETFMTS;\n-  extern unsigned IOCTL_SNDCTL_DSP_NONBLOCK;\n-  extern unsigned IOCTL_SNDCTL_DSP_POST;\n-  extern unsigned IOCTL_SNDCTL_DSP_RESET;\n-  extern unsigned IOCTL_SNDCTL_DSP_SETFMT;\n-  extern unsigned IOCTL_SNDCTL_DSP_SETFRAGMENT;\n-  extern unsigned IOCTL_SNDCTL_DSP_SPEED;\n-  extern unsigned IOCTL_SNDCTL_DSP_STEREO;\n-  extern unsigned IOCTL_SNDCTL_DSP_SUBDIVIDE;\n-  extern unsigned IOCTL_SNDCTL_DSP_SYNC;\n-  extern unsigned IOCTL_SNDCTL_FM_4OP_ENABLE;\n-  extern unsigned IOCTL_SNDCTL_FM_LOAD_INSTR;\n-  extern unsigned IOCTL_SNDCTL_MIDI_INFO;\n-  extern unsigned IOCTL_SNDCTL_MIDI_PRETIME;\n-  extern unsigned IOCTL_SNDCTL_SEQ_CTRLRATE;\n-  extern unsigned IOCTL_SNDCTL_SEQ_GETINCOUNT;\n-  extern unsigned IOCTL_SNDCTL_SEQ_GETOUTCOUNT;\n-  extern unsigned IOCTL_SNDCTL_SEQ_NRMIDIS;\n-  extern unsigned IOCTL_SNDCTL_SEQ_NRSYNTHS;\n-  extern unsigned IOCTL_SNDCTL_SEQ_OUTOFBAND;\n-  extern unsigned IOCTL_SNDCTL_SEQ_PANIC;\n-  extern unsigned IOCTL_SNDCTL_SEQ_PERCMODE;\n-  extern unsigned IOCTL_SNDCTL_SEQ_RESET;\n-  extern unsigned IOCTL_SNDCTL_SEQ_RESETSAMPLES;\n-  extern unsigned IOCTL_SNDCTL_SEQ_SYNC;\n-  extern unsigned IOCTL_SNDCTL_SEQ_TESTMIDI;\n-  extern unsigned IOCTL_SNDCTL_SEQ_THRESHOLD;\n-  extern unsigned IOCTL_SNDCTL_SYNTH_INFO;\n-  extern unsigned IOCTL_SNDCTL_SYNTH_MEMAVL;\n-  extern unsigned IOCTL_SNDCTL_TMR_CONTINUE;\n-  extern unsigned IOCTL_SNDCTL_TMR_METRONOME;\n-  extern unsigned IOCTL_SNDCTL_TMR_SELECT;\n-  extern unsigned IOCTL_SNDCTL_TMR_SOURCE;\n-  extern unsigned IOCTL_SNDCTL_TMR_START;\n-  extern unsigned IOCTL_SNDCTL_TMR_STOP;\n-  extern unsigned IOCTL_SNDCTL_TMR_TEMPO;\n-  extern unsigned IOCTL_SNDCTL_TMR_TIMEBASE;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_ALTPCM;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_BASS;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_CAPS;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_CD;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_DEVMASK;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_ENHANCE;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_IGAIN;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_IMIX;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_LINE1;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_LINE2;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_LINE3;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_LINE;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_LOUD;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_MIC;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_MUTE;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_OGAIN;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_PCM;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_RECLEV;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_RECMASK;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_RECSRC;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_SPEAKER;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_STEREODEVS;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_SYNTH;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_TREBLE;\n-  extern unsigned IOCTL_SOUND_MIXER_READ_VOLUME;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_ALTPCM;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_BASS;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_CD;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_ENHANCE;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_IGAIN;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_IMIX;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE1;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE2;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE3;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_LOUD;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_MIC;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_MUTE;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_OGAIN;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_PCM;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_RECLEV;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_RECSRC;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_SPEAKER;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_SYNTH;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_TREBLE;\n-  extern unsigned IOCTL_SOUND_MIXER_WRITE_VOLUME;\n-  extern unsigned IOCTL_SOUND_PCM_READ_BITS;\n-  extern unsigned IOCTL_SOUND_PCM_READ_CHANNELS;\n-  extern unsigned IOCTL_SOUND_PCM_READ_FILTER;\n-  extern unsigned IOCTL_SOUND_PCM_READ_RATE;\n-  extern unsigned IOCTL_SOUND_PCM_WRITE_CHANNELS;\n-  extern unsigned IOCTL_SOUND_PCM_WRITE_FILTER;\n-  extern unsigned IOCTL_VT_ACTIVATE;\n-  extern unsigned IOCTL_VT_GETMODE;\n-  extern unsigned IOCTL_VT_OPENQRY;\n-  extern unsigned IOCTL_VT_RELDISP;\n-  extern unsigned IOCTL_VT_SETMODE;\n-  extern unsigned IOCTL_VT_WAITACTIVE;\n+extern unsigned IOCTL_EVIOCGABS;\n+extern unsigned IOCTL_EVIOCGBIT;\n+extern unsigned IOCTL_EVIOCGEFFECTS;\n+extern unsigned IOCTL_EVIOCGID;\n+extern unsigned IOCTL_EVIOCGKEY;\n+extern unsigned IOCTL_EVIOCGKEYCODE;\n+extern unsigned IOCTL_EVIOCGLED;\n+extern unsigned IOCTL_EVIOCGNAME;\n+extern unsigned IOCTL_EVIOCGPHYS;\n+extern unsigned IOCTL_EVIOCGRAB;\n+extern unsigned IOCTL_EVIOCGREP;\n+extern unsigned IOCTL_EVIOCGSND;\n+extern unsigned IOCTL_EVIOCGSW;\n+extern unsigned IOCTL_EVIOCGUNIQ;\n+extern unsigned IOCTL_EVIOCGVERSION;\n+extern unsigned IOCTL_EVIOCRMFF;\n+extern unsigned IOCTL_EVIOCSABS;\n+extern unsigned IOCTL_EVIOCSFF;\n+extern unsigned IOCTL_EVIOCSKEYCODE;\n+extern unsigned IOCTL_EVIOCSREP;\n+extern unsigned IOCTL_BLKFLSBUF;\n+extern unsigned IOCTL_BLKGETSIZE;\n+extern unsigned IOCTL_BLKRAGET;\n+extern unsigned IOCTL_BLKRASET;\n+extern unsigned IOCTL_BLKROGET;\n+extern unsigned IOCTL_BLKROSET;\n+extern unsigned IOCTL_BLKRRPART;\n+extern unsigned IOCTL_CDROMAUDIOBUFSIZ;\n+extern unsigned IOCTL_CDROMEJECT;\n+extern unsigned IOCTL_CDROMEJECT_SW;\n+extern unsigned IOCTL_CDROMMULTISESSION;\n+extern unsigned IOCTL_CDROMPAUSE;\n+extern unsigned IOCTL_CDROMPLAYMSF;\n+extern unsigned IOCTL_CDROMPLAYTRKIND;\n+extern unsigned IOCTL_CDROMREADAUDIO;\n+extern unsigned IOCTL_CDROMREADCOOKED;\n+extern unsigned IOCTL_CDROMREADMODE1;\n+extern unsigned IOCTL_CDROMREADMODE2;\n+extern unsigned IOCTL_CDROMREADRAW;\n+extern unsigned IOCTL_CDROMREADTOCENTRY;\n+extern unsigned IOCTL_CDROMREADTOCHDR;\n+extern unsigned IOCTL_CDROMRESET;\n+extern unsigned IOCTL_CDROMRESUME;\n+extern unsigned IOCTL_CDROMSEEK;\n+extern unsigned IOCTL_CDROMSTART;\n+extern unsigned IOCTL_CDROMSTOP;\n+extern unsigned IOCTL_CDROMSUBCHNL;\n+extern unsigned IOCTL_CDROMVOLCTRL;\n+extern unsigned IOCTL_CDROMVOLREAD;\n+extern unsigned IOCTL_CDROM_GET_UPC;\n+extern unsigned IOCTL_FDCLRPRM;\n+extern unsigned IOCTL_FDDEFPRM;\n+extern unsigned IOCTL_FDFLUSH;\n+extern unsigned IOCTL_FDFMTBEG;\n+extern unsigned IOCTL_FDFMTEND;\n+extern unsigned IOCTL_FDFMTTRK;\n+extern unsigned IOCTL_FDGETDRVPRM;\n+extern unsigned IOCTL_FDGETDRVSTAT;\n+extern unsigned IOCTL_FDGETDRVTYP;\n+extern unsigned IOCTL_FDGETFDCSTAT;\n+extern unsigned IOCTL_FDGETMAXERRS;\n+extern unsigned IOCTL_FDGETPRM;\n+extern unsigned IOCTL_FDMSGOFF;\n+extern unsigned IOCTL_FDMSGON;\n+extern unsigned IOCTL_FDPOLLDRVSTAT;\n+extern unsigned IOCTL_FDRAWCMD;\n+extern unsigned IOCTL_FDRESET;\n+extern unsigned IOCTL_FDSETDRVPRM;\n+extern unsigned IOCTL_FDSETEMSGTRESH;\n+extern unsigned IOCTL_FDSETMAXERRS;\n+extern unsigned IOCTL_FDSETPRM;\n+extern unsigned IOCTL_FDTWADDLE;\n+extern unsigned IOCTL_FDWERRORCLR;\n+extern unsigned IOCTL_FDWERRORGET;\n+extern unsigned IOCTL_HDIO_DRIVE_CMD;\n+extern unsigned IOCTL_HDIO_GETGEO;\n+extern unsigned IOCTL_HDIO_GET_32BIT;\n+extern unsigned IOCTL_HDIO_GET_DMA;\n+extern unsigned IOCTL_HDIO_GET_IDENTITY;\n+extern unsigned IOCTL_HDIO_GET_KEEPSETTINGS;\n+extern unsigned IOCTL_HDIO_GET_MULTCOUNT;\n+extern unsigned IOCTL_HDIO_GET_NOWERR;\n+extern unsigned IOCTL_HDIO_GET_UNMASKINTR;\n+extern unsigned IOCTL_HDIO_SET_32BIT;\n+extern unsigned IOCTL_HDIO_SET_DMA;\n+extern unsigned IOCTL_HDIO_SET_KEEPSETTINGS;\n+extern unsigned IOCTL_HDIO_SET_MULTCOUNT;\n+extern unsigned IOCTL_HDIO_SET_NOWERR;\n+extern unsigned IOCTL_HDIO_SET_UNMASKINTR;\n+extern unsigned IOCTL_MTIOCPOS;\n+extern unsigned IOCTL_PPPIOCGASYNCMAP;\n+extern unsigned IOCTL_PPPIOCGDEBUG;\n+extern unsigned IOCTL_PPPIOCGFLAGS;\n+extern unsigned IOCTL_PPPIOCGUNIT;\n+extern unsigned IOCTL_PPPIOCGXASYNCMAP;\n+extern unsigned IOCTL_PPPIOCSASYNCMAP;\n+extern unsigned IOCTL_PPPIOCSDEBUG;\n+extern unsigned IOCTL_PPPIOCSFLAGS;\n+extern unsigned IOCTL_PPPIOCSMAXCID;\n+extern unsigned IOCTL_PPPIOCSMRU;\n+extern unsigned IOCTL_PPPIOCSXASYNCMAP;\n+extern unsigned IOCTL_SIOCDARP;\n+extern unsigned IOCTL_SIOCDRARP;\n+extern unsigned IOCTL_SIOCGARP;\n+extern unsigned IOCTL_SIOCGIFENCAP;\n+extern unsigned IOCTL_SIOCGIFHWADDR;\n+extern unsigned IOCTL_SIOCGIFMAP;\n+extern unsigned IOCTL_SIOCGIFMEM;\n+extern unsigned IOCTL_SIOCGIFNAME;\n+extern unsigned IOCTL_SIOCGIFSLAVE;\n+extern unsigned IOCTL_SIOCGRARP;\n+extern unsigned IOCTL_SIOCGSTAMP;\n+extern unsigned IOCTL_SIOCSARP;\n+extern unsigned IOCTL_SIOCSIFENCAP;\n+extern unsigned IOCTL_SIOCSIFHWADDR;\n+extern unsigned IOCTL_SIOCSIFLINK;\n+extern unsigned IOCTL_SIOCSIFMAP;\n+extern unsigned IOCTL_SIOCSIFMEM;\n+extern unsigned IOCTL_SIOCSIFSLAVE;\n+extern unsigned IOCTL_SIOCSRARP;\n+extern unsigned IOCTL_SNDCTL_COPR_HALT;\n+extern unsigned IOCTL_SNDCTL_COPR_LOAD;\n+extern unsigned IOCTL_SNDCTL_COPR_RCODE;\n+extern unsigned IOCTL_SNDCTL_COPR_RCVMSG;\n+extern unsigned IOCTL_SNDCTL_COPR_RDATA;\n+extern unsigned IOCTL_SNDCTL_COPR_RESET;\n+extern unsigned IOCTL_SNDCTL_COPR_RUN;\n+extern unsigned IOCTL_SNDCTL_COPR_SENDMSG;\n+extern unsigned IOCTL_SNDCTL_COPR_WCODE;\n+extern unsigned IOCTL_SNDCTL_COPR_WDATA;\n+extern unsigned IOCTL_TCFLSH;\n+extern unsigned IOCTL_TCGETA;\n+extern unsigned IOCTL_TCGETS;\n+extern unsigned IOCTL_TCSBRK;\n+extern unsigned IOCTL_TCSBRKP;\n+extern unsigned IOCTL_TCSETA;\n+extern unsigned IOCTL_TCSETAF;\n+extern unsigned IOCTL_TCSETAW;\n+extern unsigned IOCTL_TCSETS;\n+extern unsigned IOCTL_TCSETSF;\n+extern unsigned IOCTL_TCSETSW;\n+extern unsigned IOCTL_TCXONC;\n+extern unsigned IOCTL_TIOCGLCKTRMIOS;\n+extern unsigned IOCTL_TIOCGSOFTCAR;\n+extern unsigned IOCTL_TIOCINQ;\n+extern unsigned IOCTL_TIOCLINUX;\n+extern unsigned IOCTL_TIOCSERCONFIG;\n+extern unsigned IOCTL_TIOCSERGETLSR;\n+extern unsigned IOCTL_TIOCSERGWILD;\n+extern unsigned IOCTL_TIOCSERSWILD;\n+extern unsigned IOCTL_TIOCSLCKTRMIOS;\n+extern unsigned IOCTL_TIOCSSOFTCAR;\n+extern unsigned IOCTL_VT_DISALLOCATE;\n+extern unsigned IOCTL_VT_GETSTATE;\n+extern unsigned IOCTL_VT_RESIZE;\n+extern unsigned IOCTL_VT_RESIZEX;\n+extern unsigned IOCTL_VT_SENDSIG;\n+extern unsigned IOCTL_MTIOCGET;\n+extern unsigned IOCTL_MTIOCTOP;\n+extern unsigned IOCTL_SIOCADDRT;\n+extern unsigned IOCTL_SIOCDELRT;\n+extern unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE;\n+extern unsigned IOCTL_SNDCTL_DSP_GETFMTS;\n+extern unsigned IOCTL_SNDCTL_DSP_NONBLOCK;\n+extern unsigned IOCTL_SNDCTL_DSP_POST;\n+extern unsigned IOCTL_SNDCTL_DSP_RESET;\n+extern unsigned IOCTL_SNDCTL_DSP_SETFMT;\n+extern unsigned IOCTL_SNDCTL_DSP_SETFRAGMENT;\n+extern unsigned IOCTL_SNDCTL_DSP_SPEED;\n+extern unsigned IOCTL_SNDCTL_DSP_STEREO;\n+extern unsigned IOCTL_SNDCTL_DSP_SUBDIVIDE;\n+extern unsigned IOCTL_SNDCTL_DSP_SYNC;\n+extern unsigned IOCTL_SNDCTL_FM_4OP_ENABLE;\n+extern unsigned IOCTL_SNDCTL_FM_LOAD_INSTR;\n+extern unsigned IOCTL_SNDCTL_MIDI_INFO;\n+extern unsigned IOCTL_SNDCTL_MIDI_PRETIME;\n+extern unsigned IOCTL_SNDCTL_SEQ_CTRLRATE;\n+extern unsigned IOCTL_SNDCTL_SEQ_GETINCOUNT;\n+extern unsigned IOCTL_SNDCTL_SEQ_GETOUTCOUNT;\n+extern unsigned IOCTL_SNDCTL_SEQ_NRMIDIS;\n+extern unsigned IOCTL_SNDCTL_SEQ_NRSYNTHS;\n+extern unsigned IOCTL_SNDCTL_SEQ_OUTOFBAND;\n+extern unsigned IOCTL_SNDCTL_SEQ_PANIC;\n+extern unsigned IOCTL_SNDCTL_SEQ_PERCMODE;\n+extern unsigned IOCTL_SNDCTL_SEQ_RESET;\n+extern unsigned IOCTL_SNDCTL_SEQ_RESETSAMPLES;\n+extern unsigned IOCTL_SNDCTL_SEQ_SYNC;\n+extern unsigned IOCTL_SNDCTL_SEQ_TESTMIDI;\n+extern unsigned IOCTL_SNDCTL_SEQ_THRESHOLD;\n+extern unsigned IOCTL_SNDCTL_SYNTH_INFO;\n+extern unsigned IOCTL_SNDCTL_SYNTH_MEMAVL;\n+extern unsigned IOCTL_SNDCTL_TMR_CONTINUE;\n+extern unsigned IOCTL_SNDCTL_TMR_METRONOME;\n+extern unsigned IOCTL_SNDCTL_TMR_SELECT;\n+extern unsigned IOCTL_SNDCTL_TMR_SOURCE;\n+extern unsigned IOCTL_SNDCTL_TMR_START;\n+extern unsigned IOCTL_SNDCTL_TMR_STOP;\n+extern unsigned IOCTL_SNDCTL_TMR_TEMPO;\n+extern unsigned IOCTL_SNDCTL_TMR_TIMEBASE;\n+extern unsigned IOCTL_SOUND_MIXER_READ_ALTPCM;\n+extern unsigned IOCTL_SOUND_MIXER_READ_BASS;\n+extern unsigned IOCTL_SOUND_MIXER_READ_CAPS;\n+extern unsigned IOCTL_SOUND_MIXER_READ_CD;\n+extern unsigned IOCTL_SOUND_MIXER_READ_DEVMASK;\n+extern unsigned IOCTL_SOUND_MIXER_READ_ENHANCE;\n+extern unsigned IOCTL_SOUND_MIXER_READ_IGAIN;\n+extern unsigned IOCTL_SOUND_MIXER_READ_IMIX;\n+extern unsigned IOCTL_SOUND_MIXER_READ_LINE1;\n+extern unsigned IOCTL_SOUND_MIXER_READ_LINE2;\n+extern unsigned IOCTL_SOUND_MIXER_READ_LINE3;\n+extern unsigned IOCTL_SOUND_MIXER_READ_LINE;\n+extern unsigned IOCTL_SOUND_MIXER_READ_LOUD;\n+extern unsigned IOCTL_SOUND_MIXER_READ_MIC;\n+extern unsigned IOCTL_SOUND_MIXER_READ_MUTE;\n+extern unsigned IOCTL_SOUND_MIXER_READ_OGAIN;\n+extern unsigned IOCTL_SOUND_MIXER_READ_PCM;\n+extern unsigned IOCTL_SOUND_MIXER_READ_RECLEV;\n+extern unsigned IOCTL_SOUND_MIXER_READ_RECMASK;\n+extern unsigned IOCTL_SOUND_MIXER_READ_RECSRC;\n+extern unsigned IOCTL_SOUND_MIXER_READ_SPEAKER;\n+extern unsigned IOCTL_SOUND_MIXER_READ_STEREODEVS;\n+extern unsigned IOCTL_SOUND_MIXER_READ_SYNTH;\n+extern unsigned IOCTL_SOUND_MIXER_READ_TREBLE;\n+extern unsigned IOCTL_SOUND_MIXER_READ_VOLUME;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_ALTPCM;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_BASS;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_CD;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_ENHANCE;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_IGAIN;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_IMIX;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE1;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE2;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE3;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_LOUD;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_MIC;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_MUTE;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_OGAIN;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_PCM;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_RECLEV;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_RECSRC;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_SPEAKER;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_SYNTH;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_TREBLE;\n+extern unsigned IOCTL_SOUND_MIXER_WRITE_VOLUME;\n+extern unsigned IOCTL_SOUND_PCM_READ_BITS;\n+extern unsigned IOCTL_SOUND_PCM_READ_CHANNELS;\n+extern unsigned IOCTL_SOUND_PCM_READ_FILTER;\n+extern unsigned IOCTL_SOUND_PCM_READ_RATE;\n+extern unsigned IOCTL_SOUND_PCM_WRITE_CHANNELS;\n+extern unsigned IOCTL_SOUND_PCM_WRITE_FILTER;\n+extern unsigned IOCTL_VT_ACTIVATE;\n+extern unsigned IOCTL_VT_GETMODE;\n+extern unsigned IOCTL_VT_OPENQRY;\n+extern unsigned IOCTL_VT_RELDISP;\n+extern unsigned IOCTL_VT_SETMODE;\n+extern unsigned IOCTL_VT_WAITACTIVE;\n #endif  // SANITIZER_LINUX\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n-  extern unsigned IOCTL_CYGETDEFTHRESH;\n-  extern unsigned IOCTL_CYGETDEFTIMEOUT;\n-  extern unsigned IOCTL_CYGETMON;\n-  extern unsigned IOCTL_CYGETTHRESH;\n-  extern unsigned IOCTL_CYGETTIMEOUT;\n-  extern unsigned IOCTL_CYSETDEFTHRESH;\n-  extern unsigned IOCTL_CYSETDEFTIMEOUT;\n-  extern unsigned IOCTL_CYSETTHRESH;\n-  extern unsigned IOCTL_CYSETTIMEOUT;\n-  extern unsigned IOCTL_EQL_EMANCIPATE;\n-  extern unsigned IOCTL_EQL_ENSLAVE;\n-  extern unsigned IOCTL_EQL_GETMASTRCFG;\n-  extern unsigned IOCTL_EQL_GETSLAVECFG;\n-  extern unsigned IOCTL_EQL_SETMASTRCFG;\n-  extern unsigned IOCTL_EQL_SETSLAVECFG;\n-  extern unsigned IOCTL_EVIOCGKEYCODE_V2;\n-  extern unsigned IOCTL_EVIOCGPROP;\n-  extern unsigned IOCTL_EVIOCSKEYCODE_V2;\n-  extern unsigned IOCTL_FS_IOC_GETFLAGS;\n-  extern unsigned IOCTL_FS_IOC_GETVERSION;\n-  extern unsigned IOCTL_FS_IOC_SETFLAGS;\n-  extern unsigned IOCTL_FS_IOC_SETVERSION;\n-  extern unsigned IOCTL_GIO_CMAP;\n-  extern unsigned IOCTL_GIO_FONT;\n-  extern unsigned IOCTL_GIO_UNIMAP;\n-  extern unsigned IOCTL_GIO_UNISCRNMAP;\n-  extern unsigned IOCTL_KDADDIO;\n-  extern unsigned IOCTL_KDDELIO;\n-  extern unsigned IOCTL_KDGETKEYCODE;\n-  extern unsigned IOCTL_KDGKBDIACR;\n-  extern unsigned IOCTL_KDGKBENT;\n-  extern unsigned IOCTL_KDGKBLED;\n-  extern unsigned IOCTL_KDGKBMETA;\n-  extern unsigned IOCTL_KDGKBSENT;\n-  extern unsigned IOCTL_KDMAPDISP;\n-  extern unsigned IOCTL_KDSETKEYCODE;\n-  extern unsigned IOCTL_KDSIGACCEPT;\n-  extern unsigned IOCTL_KDSKBDIACR;\n-  extern unsigned IOCTL_KDSKBENT;\n-  extern unsigned IOCTL_KDSKBLED;\n-  extern unsigned IOCTL_KDSKBMETA;\n-  extern unsigned IOCTL_KDSKBSENT;\n-  extern unsigned IOCTL_KDUNMAPDISP;\n-  extern unsigned IOCTL_LPABORT;\n-  extern unsigned IOCTL_LPABORTOPEN;\n-  extern unsigned IOCTL_LPCAREFUL;\n-  extern unsigned IOCTL_LPCHAR;\n-  extern unsigned IOCTL_LPGETIRQ;\n-  extern unsigned IOCTL_LPGETSTATUS;\n-  extern unsigned IOCTL_LPRESET;\n-  extern unsigned IOCTL_LPSETIRQ;\n-  extern unsigned IOCTL_LPTIME;\n-  extern unsigned IOCTL_LPWAIT;\n-  extern unsigned IOCTL_MTIOCGETCONFIG;\n-  extern unsigned IOCTL_MTIOCSETCONFIG;\n-  extern unsigned IOCTL_PIO_CMAP;\n-  extern unsigned IOCTL_PIO_FONT;\n-  extern unsigned IOCTL_PIO_UNIMAP;\n-  extern unsigned IOCTL_PIO_UNIMAPCLR;\n-  extern unsigned IOCTL_PIO_UNISCRNMAP;\n-  extern unsigned IOCTL_SCSI_IOCTL_GET_IDLUN;\n-  extern unsigned IOCTL_SCSI_IOCTL_PROBE_HOST;\n-  extern unsigned IOCTL_SCSI_IOCTL_TAGGED_DISABLE;\n-  extern unsigned IOCTL_SCSI_IOCTL_TAGGED_ENABLE;\n-  extern unsigned IOCTL_SIOCAIPXITFCRT;\n-  extern unsigned IOCTL_SIOCAIPXPRISLT;\n-  extern unsigned IOCTL_SIOCAX25ADDUID;\n-  extern unsigned IOCTL_SIOCAX25DELUID;\n-  extern unsigned IOCTL_SIOCAX25GETPARMS;\n-  extern unsigned IOCTL_SIOCAX25GETUID;\n-  extern unsigned IOCTL_SIOCAX25NOUID;\n-  extern unsigned IOCTL_SIOCAX25SETPARMS;\n-  extern unsigned IOCTL_SIOCDEVPLIP;\n-  extern unsigned IOCTL_SIOCIPXCFGDATA;\n-  extern unsigned IOCTL_SIOCNRDECOBS;\n-  extern unsigned IOCTL_SIOCNRGETPARMS;\n-  extern unsigned IOCTL_SIOCNRRTCTL;\n-  extern unsigned IOCTL_SIOCNRSETPARMS;\n-  extern unsigned IOCTL_SNDCTL_DSP_GETISPACE;\n-  extern unsigned IOCTL_SNDCTL_DSP_GETOSPACE;\n-  extern unsigned IOCTL_TIOCGSERIAL;\n-  extern unsigned IOCTL_TIOCSERGETMULTI;\n-  extern unsigned IOCTL_TIOCSERSETMULTI;\n-  extern unsigned IOCTL_TIOCSSERIAL;\n-  extern unsigned IOCTL_GIO_SCRNMAP;\n-  extern unsigned IOCTL_KDDISABIO;\n-  extern unsigned IOCTL_KDENABIO;\n-  extern unsigned IOCTL_KDGETLED;\n-  extern unsigned IOCTL_KDGETMODE;\n-  extern unsigned IOCTL_KDGKBMODE;\n-  extern unsigned IOCTL_KDGKBTYPE;\n-  extern unsigned IOCTL_KDMKTONE;\n-  extern unsigned IOCTL_KDSETLED;\n-  extern unsigned IOCTL_KDSETMODE;\n-  extern unsigned IOCTL_KDSKBMODE;\n-  extern unsigned IOCTL_KIOCSOUND;\n-  extern unsigned IOCTL_PIO_SCRNMAP;\n-#endif\n-\n-  extern const int si_SEGV_MAPERR;\n-  extern const int si_SEGV_ACCERR;\n+extern unsigned IOCTL_CYGETDEFTHRESH;\n+extern unsigned IOCTL_CYGETDEFTIMEOUT;\n+extern unsigned IOCTL_CYGETMON;\n+extern unsigned IOCTL_CYGETTHRESH;\n+extern unsigned IOCTL_CYGETTIMEOUT;\n+extern unsigned IOCTL_CYSETDEFTHRESH;\n+extern unsigned IOCTL_CYSETDEFTIMEOUT;\n+extern unsigned IOCTL_CYSETTHRESH;\n+extern unsigned IOCTL_CYSETTIMEOUT;\n+extern unsigned IOCTL_EQL_EMANCIPATE;\n+extern unsigned IOCTL_EQL_ENSLAVE;\n+extern unsigned IOCTL_EQL_GETMASTRCFG;\n+extern unsigned IOCTL_EQL_GETSLAVECFG;\n+extern unsigned IOCTL_EQL_SETMASTRCFG;\n+extern unsigned IOCTL_EQL_SETSLAVECFG;\n+extern unsigned IOCTL_EVIOCGKEYCODE_V2;\n+extern unsigned IOCTL_EVIOCGPROP;\n+extern unsigned IOCTL_EVIOCSKEYCODE_V2;\n+extern unsigned IOCTL_FS_IOC_GETFLAGS;\n+extern unsigned IOCTL_FS_IOC_GETVERSION;\n+extern unsigned IOCTL_FS_IOC_SETFLAGS;\n+extern unsigned IOCTL_FS_IOC_SETVERSION;\n+extern unsigned IOCTL_GIO_CMAP;\n+extern unsigned IOCTL_GIO_FONT;\n+extern unsigned IOCTL_GIO_UNIMAP;\n+extern unsigned IOCTL_GIO_UNISCRNMAP;\n+extern unsigned IOCTL_KDADDIO;\n+extern unsigned IOCTL_KDDELIO;\n+extern unsigned IOCTL_KDGETKEYCODE;\n+extern unsigned IOCTL_KDGKBDIACR;\n+extern unsigned IOCTL_KDGKBENT;\n+extern unsigned IOCTL_KDGKBLED;\n+extern unsigned IOCTL_KDGKBMETA;\n+extern unsigned IOCTL_KDGKBSENT;\n+extern unsigned IOCTL_KDMAPDISP;\n+extern unsigned IOCTL_KDSETKEYCODE;\n+extern unsigned IOCTL_KDSIGACCEPT;\n+extern unsigned IOCTL_KDSKBDIACR;\n+extern unsigned IOCTL_KDSKBENT;\n+extern unsigned IOCTL_KDSKBLED;\n+extern unsigned IOCTL_KDSKBMETA;\n+extern unsigned IOCTL_KDSKBSENT;\n+extern unsigned IOCTL_KDUNMAPDISP;\n+extern unsigned IOCTL_LPABORT;\n+extern unsigned IOCTL_LPABORTOPEN;\n+extern unsigned IOCTL_LPCAREFUL;\n+extern unsigned IOCTL_LPCHAR;\n+extern unsigned IOCTL_LPGETIRQ;\n+extern unsigned IOCTL_LPGETSTATUS;\n+extern unsigned IOCTL_LPRESET;\n+extern unsigned IOCTL_LPSETIRQ;\n+extern unsigned IOCTL_LPTIME;\n+extern unsigned IOCTL_LPWAIT;\n+extern unsigned IOCTL_MTIOCGETCONFIG;\n+extern unsigned IOCTL_MTIOCSETCONFIG;\n+extern unsigned IOCTL_PIO_CMAP;\n+extern unsigned IOCTL_PIO_FONT;\n+extern unsigned IOCTL_PIO_UNIMAP;\n+extern unsigned IOCTL_PIO_UNIMAPCLR;\n+extern unsigned IOCTL_PIO_UNISCRNMAP;\n+extern unsigned IOCTL_SCSI_IOCTL_GET_IDLUN;\n+extern unsigned IOCTL_SCSI_IOCTL_PROBE_HOST;\n+extern unsigned IOCTL_SCSI_IOCTL_TAGGED_DISABLE;\n+extern unsigned IOCTL_SCSI_IOCTL_TAGGED_ENABLE;\n+extern unsigned IOCTL_SIOCAIPXITFCRT;\n+extern unsigned IOCTL_SIOCAIPXPRISLT;\n+extern unsigned IOCTL_SIOCAX25ADDUID;\n+extern unsigned IOCTL_SIOCAX25DELUID;\n+extern unsigned IOCTL_SIOCAX25GETPARMS;\n+extern unsigned IOCTL_SIOCAX25GETUID;\n+extern unsigned IOCTL_SIOCAX25NOUID;\n+extern unsigned IOCTL_SIOCAX25SETPARMS;\n+extern unsigned IOCTL_SIOCDEVPLIP;\n+extern unsigned IOCTL_SIOCIPXCFGDATA;\n+extern unsigned IOCTL_SIOCNRDECOBS;\n+extern unsigned IOCTL_SIOCNRGETPARMS;\n+extern unsigned IOCTL_SIOCNRRTCTL;\n+extern unsigned IOCTL_SIOCNRSETPARMS;\n+extern unsigned IOCTL_SNDCTL_DSP_GETISPACE;\n+extern unsigned IOCTL_SNDCTL_DSP_GETOSPACE;\n+extern unsigned IOCTL_TIOCGSERIAL;\n+extern unsigned IOCTL_TIOCSERGETMULTI;\n+extern unsigned IOCTL_TIOCSERSETMULTI;\n+extern unsigned IOCTL_TIOCSSERIAL;\n+extern unsigned IOCTL_GIO_SCRNMAP;\n+extern unsigned IOCTL_KDDISABIO;\n+extern unsigned IOCTL_KDENABIO;\n+extern unsigned IOCTL_KDGETLED;\n+extern unsigned IOCTL_KDGETMODE;\n+extern unsigned IOCTL_KDGKBMODE;\n+extern unsigned IOCTL_KDGKBTYPE;\n+extern unsigned IOCTL_KDMKTONE;\n+extern unsigned IOCTL_KDSETLED;\n+extern unsigned IOCTL_KDSETMODE;\n+extern unsigned IOCTL_KDSKBMODE;\n+extern unsigned IOCTL_KIOCSOUND;\n+extern unsigned IOCTL_PIO_SCRNMAP;\n+#endif\n+\n+extern const int si_SEGV_MAPERR;\n+extern const int si_SEGV_ACCERR;\n }  // namespace __sanitizer\n \n #define CHECK_TYPE_SIZE(TYPE) \\\n   COMPILER_CHECK(sizeof(__sanitizer_##TYPE) == sizeof(TYPE))\n \n-#define CHECK_SIZE_AND_OFFSET(CLASS, MEMBER)                       \\\n-  COMPILER_CHECK(sizeof(((__sanitizer_##CLASS *) NULL)->MEMBER) == \\\n-                 sizeof(((CLASS *) NULL)->MEMBER));                \\\n-  COMPILER_CHECK(offsetof(__sanitizer_##CLASS, MEMBER) ==          \\\n+#define CHECK_SIZE_AND_OFFSET(CLASS, MEMBER)                      \\\n+  COMPILER_CHECK(sizeof(((__sanitizer_##CLASS *)NULL)->MEMBER) == \\\n+                 sizeof(((CLASS *)NULL)->MEMBER));                \\\n+  COMPILER_CHECK(offsetof(__sanitizer_##CLASS, MEMBER) ==         \\\n                  offsetof(CLASS, MEMBER))\n \n // For sigaction, which is a function and struct at the same time,\n // and thus requires explicit \"struct\" in sizeof() expression.\n-#define CHECK_STRUCT_SIZE_AND_OFFSET(CLASS, MEMBER)                       \\\n-  COMPILER_CHECK(sizeof(((struct __sanitizer_##CLASS *) NULL)->MEMBER) == \\\n-                 sizeof(((struct CLASS *) NULL)->MEMBER));                \\\n-  COMPILER_CHECK(offsetof(struct __sanitizer_##CLASS, MEMBER) ==          \\\n+#define CHECK_STRUCT_SIZE_AND_OFFSET(CLASS, MEMBER)                      \\\n+  COMPILER_CHECK(sizeof(((struct __sanitizer_##CLASS *)NULL)->MEMBER) == \\\n+                 sizeof(((struct CLASS *)NULL)->MEMBER));                \\\n+  COMPILER_CHECK(offsetof(struct __sanitizer_##CLASS, MEMBER) ==         \\\n                  offsetof(struct CLASS, MEMBER))\n \n #define SIGACTION_SYMNAME sigaction"}, {"sha": "77ae6e6a44dbd96dd00feaac6925ee1555579637", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_solaris.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -68,7 +68,7 @@ struct __sanitizer_ipc_perm {\n #if !defined(_LP64)\n   int pad[4];\n #endif\n-  };\n+};\n \n struct __sanitizer_shmid_ds {\n   __sanitizer_ipc_perm shm_perm;\n@@ -237,9 +237,8 @@ typedef int __sanitizer_clockid_t;\n \n // This thing depends on the platform. We are only interested in the upper\n // limit. Verified with a compiler assert in .cpp.\n-const int pthread_attr_t_max_sz = 128;\n union __sanitizer_pthread_attr_t {\n-  char size[pthread_attr_t_max_sz]; // NOLINT\n+  char size[128];\n   void *align;\n };\n "}, {"sha": "d890a3a317737cdeddb31ddf35c429c53454e1d7", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -312,6 +312,8 @@ const char *SignalContext::Describe() const {\n       return \"SEGV\";\n     case SIGBUS:\n       return \"BUS\";\n+    case SIGTRAP:\n+      return \"TRAP\";\n   }\n   return \"UNKNOWN SIGNAL\";\n }"}, {"sha": "05fb0f630207c5951e8c8a7f18fa24c6752f3931", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -63,7 +63,7 @@ uptr internal_ptrace(int request, int pid, void *addr, void *data);\n uptr internal_waitpid(int pid, int *status, int options);\n \n int internal_fork();\n-int internal_forkpty(int *amaster);\n+fd_t internal_spawn(const char *argv[], pid_t *pid);\n \n int internal_sysctl(const int *name, unsigned int namelen, void *oldp,\n                     uptr *oldlenp, const void *newp, uptr newlen);"}, {"sha": "304b3a01a08b6ac06e8dae266e5c4bc116cf8be6", "filename": "libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cpp", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -304,11 +304,13 @@ void PlatformPrepareForSandboxing(__sanitizer_sandbox_arguments *args) {\n   MemoryMappingLayout::CacheMemoryMappings();\n }\n \n-bool MmapFixedNoReserve(uptr fixed_addr, uptr size, const char *name) {\n+static bool MmapFixed(uptr fixed_addr, uptr size, int additional_flags,\n+                      const char *name) {\n   size = RoundUpTo(size, GetPageSizeCached());\n   fixed_addr = RoundDownTo(fixed_addr, GetPageSizeCached());\n-  uptr p = MmapNamed((void *)fixed_addr, size, PROT_READ | PROT_WRITE,\n-                     MAP_PRIVATE | MAP_FIXED | MAP_NORESERVE | MAP_ANON, name);\n+  uptr p =\n+      MmapNamed((void *)fixed_addr, size, PROT_READ | PROT_WRITE,\n+                MAP_PRIVATE | MAP_FIXED | additional_flags | MAP_ANON, name);\n   int reserrno;\n   if (internal_iserror(p, &reserrno)) {\n     Report(\"ERROR: %s failed to \"\n@@ -320,6 +322,24 @@ bool MmapFixedNoReserve(uptr fixed_addr, uptr size, const char *name) {\n   return true;\n }\n \n+bool MmapFixedNoReserve(uptr fixed_addr, uptr size, const char *name) {\n+  return MmapFixed(fixed_addr, size, MAP_NORESERVE, name);\n+}\n+\n+bool MmapFixedSuperNoReserve(uptr fixed_addr, uptr size, const char *name) {\n+#if SANITIZER_FREEBSD\n+  if (common_flags()->no_huge_pages_for_shadow)\n+    return MmapFixedNoReserve(fixed_addr, size, name);\n+  // MAP_NORESERVE is implicit with FreeBSD\n+  return MmapFixed(fixed_addr, size, MAP_ALIGNED_SUPER, name);\n+#else\n+  bool r = MmapFixedNoReserve(fixed_addr, size, name);\n+  if (r)\n+    SetShadowRegionHugePageMode(fixed_addr, size);\n+  return r;\n+#endif\n+}\n+\n uptr ReservedAddressRange::Init(uptr size, const char *name, uptr fixed_addr) {\n   base_ = fixed_addr ? MmapFixedNoAccess(fixed_addr, size, name)\n                      : MmapNoAccess(size);"}, {"sha": "a032787114bb9824dbcb803406db59545df13a16", "filename": "libsanitizer/sanitizer_common/sanitizer_printf.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -229,15 +229,15 @@ void SetPrintfAndReportCallback(void (*callback)(const char *)) {\n // Can be overriden in frontend.\n #if SANITIZER_GO && defined(TSAN_EXTERNAL_HOOKS)\n // Implementation must be defined in frontend.\n-extern \"C\" void OnPrint(const char *str);\n+extern \"C\" void __sanitizer_on_print(const char *str);\n #else\n-SANITIZER_INTERFACE_WEAK_DEF(void, OnPrint, const char *str) {\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_on_print, const char *str) {\n   (void)str;\n }\n #endif\n \n static void CallPrintfAndReportCallback(const char *str) {\n-  OnPrint(str);\n+  __sanitizer_on_print(str);\n   if (PrintfAndReportCallback)\n     PrintfAndReportCallback(str);\n }"}, {"sha": "d0e5245f84dab815a6d1ee31f08a77a15df6cfe4", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -37,7 +37,7 @@ struct MemoryMappedSegmentData;\n \n class MemoryMappedSegment {\n  public:\n-  MemoryMappedSegment(char *buff = nullptr, uptr size = 0)\n+  explicit MemoryMappedSegment(char *buff = nullptr, uptr size = 0)\n       : filename(buff), filename_size(size), data_(nullptr) {}\n   ~MemoryMappedSegment() {}\n "}, {"sha": "d02afcfe87ae0879034d1f9a8446e3e7df52787b", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_mac.cpp", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -181,13 +181,14 @@ const mach_header *get_dyld_hdr() {\n // Note that the segment addresses are not necessarily sorted.\n template <u32 kLCSegment, typename SegmentCommand>\n static bool NextSegmentLoad(MemoryMappedSegment *segment,\n-MemoryMappedSegmentData *seg_data, MemoryMappingLayoutData &layout_data) {\n-  const char *lc = layout_data.current_load_cmd_addr;\n-  layout_data.current_load_cmd_addr += ((const load_command *)lc)->cmdsize;\n+                            MemoryMappedSegmentData *seg_data,\n+                            MemoryMappingLayoutData *layout_data) {\n+  const char *lc = layout_data->current_load_cmd_addr;\n+  layout_data->current_load_cmd_addr += ((const load_command *)lc)->cmdsize;\n   if (((const load_command *)lc)->cmd == kLCSegment) {\n     const SegmentCommand* sc = (const SegmentCommand *)lc;\n     uptr base_virt_addr, addr_mask;\n-    if (layout_data.current_image == kDyldImageIdx) {\n+    if (layout_data->current_image == kDyldImageIdx) {\n       base_virt_addr = (uptr)get_dyld_hdr();\n       // vmaddr is masked with 0xfffff because on macOS versions < 10.12,\n       // it contains an absolute address rather than an offset for dyld.\n@@ -198,7 +199,7 @@ MemoryMappedSegmentData *seg_data, MemoryMappingLayoutData &layout_data) {\n       addr_mask = 0xfffff;\n     } else {\n       base_virt_addr =\n-          (uptr)_dyld_get_image_vmaddr_slide(layout_data.current_image);\n+          (uptr)_dyld_get_image_vmaddr_slide(layout_data->current_image);\n       addr_mask = ~0;\n     }\n \n@@ -219,18 +220,18 @@ MemoryMappedSegmentData *seg_data, MemoryMappingLayoutData &layout_data) {\n \n     // Return the initial protection.\n     segment->protection = sc->initprot;\n-    segment->offset = (layout_data.current_filetype ==\n+    segment->offset = (layout_data->current_filetype ==\n                        /*MH_EXECUTE*/ 0x2)\n                           ? sc->vmaddr\n                           : sc->fileoff;\n     if (segment->filename) {\n-      const char *src = (layout_data.current_image == kDyldImageIdx)\n+      const char *src = (layout_data->current_image == kDyldImageIdx)\n                             ? kDyldPath\n-                            : _dyld_get_image_name(layout_data.current_image);\n+                            : _dyld_get_image_name(layout_data->current_image);\n       internal_strncpy(segment->filename, src, segment->filename_size);\n     }\n-    segment->arch = layout_data.current_arch;\n-    internal_memcpy(segment->uuid, layout_data.current_uuid, kModuleUUIDSize);\n+    segment->arch = layout_data->current_arch;\n+    internal_memcpy(segment->uuid, layout_data->current_uuid, kModuleUUIDSize);\n     return true;\n   }\n   return false;\n@@ -331,14 +332,14 @@ bool MemoryMappingLayout::Next(MemoryMappedSegment *segment) {\n #ifdef MH_MAGIC_64\n         case MH_MAGIC_64: {\n           if (NextSegmentLoad<LC_SEGMENT_64, struct segment_command_64>(\n-          segment, segment->data_, data_))\n+                  segment, segment->data_, &data_))\n             return true;\n           break;\n         }\n #endif\n         case MH_MAGIC: {\n           if (NextSegmentLoad<LC_SEGMENT, struct segment_command>(\n-          segment, segment->data_, data_))\n+                  segment, segment->data_, &data_))\n             return true;\n           break;\n         }"}, {"sha": "ef14fb704eed394acf0be36505eaae5f952fa6d2", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cpp", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -60,8 +60,8 @@ static inline uhwptr *GetCanonicFrame(uptr bp,\n   // Nope, this does not look right either. This means the frame after next does\n   // not have a valid frame pointer, but we can still extract the caller PC.\n   // Unfortunately, there is no way to decide between GCC and LLVM frame\n-  // layouts. Assume GCC.\n-  return bp_prev - 1;\n+  // layouts. Assume LLVM.\n+  return bp_prev;\n #else\n   return (uhwptr*)bp;\n #endif\n@@ -84,21 +84,14 @@ void BufferedStackTrace::UnwindFast(uptr pc, uptr bp, uptr stack_top,\n          IsAligned((uptr)frame, sizeof(*frame)) &&\n          size < max_depth) {\n #ifdef __powerpc__\n-    // PowerPC ABIs specify that the return address is saved on the\n-    // *caller's* stack frame.  Thus we must dereference the back chain\n-    // to find the caller frame before extracting it.\n+    // PowerPC ABIs specify that the return address is saved at offset\n+    // 16 of the *caller's* stack frame.  Thus we must dereference the\n+    // back chain to find the caller frame before extracting it.\n     uhwptr *caller_frame = (uhwptr*)frame[0];\n     if (!IsValidFrame((uptr)caller_frame, stack_top, bottom) ||\n         !IsAligned((uptr)caller_frame, sizeof(uhwptr)))\n       break;\n-    // For most ABIs the offset where the return address is saved is two\n-    // register sizes.  The exception is the SVR4 ABI, which uses an\n-    // offset of only one register size.\n-#ifdef _CALL_SYSV\n-    uhwptr pc1 = caller_frame[1];\n-#else\n     uhwptr pc1 = caller_frame[2];\n-#endif\n #elif defined(__s390__)\n     uhwptr pc1 = frame[14];\n #else"}, {"sha": "4ef305cf17991b4c211f186fd3ca92284ef409f5", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_libcdep.cpp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -150,8 +150,9 @@ void __sanitizer_symbolize_global(uptr data_addr, const char *fmt,\n }\n \n SANITIZER_INTERFACE_ATTRIBUTE\n-int __sanitizer_get_module_and_offset_for_pc( // NOLINT\n-    uptr pc, char *module_name, uptr module_name_len, uptr *pc_offset) {\n+int __sanitizer_get_module_and_offset_for_pc(uptr pc, char *module_name,\n+                                             uptr module_name_len,\n+                                             uptr *pc_offset) {\n   return __sanitizer::GetModuleAndOffsetForPc(pc, module_name, module_name_len,\n                                               pc_offset);\n }"}, {"sha": "651d5056dd9d5feb4a7ca2f8cd1fe52d2080fd77", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cpp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -223,10 +223,11 @@ bool ThreadSuspender::SuspendAllThreads() {\n       case ThreadLister::Ok:\n         break;\n     }\n-    for (tid_t tid : threads)\n+    for (tid_t tid : threads) {\n       if (SuspendThread(tid))\n         retry = true;\n-  };\n+    }\n+  }\n   return suspended_threads_list_.ThreadCount();\n }\n "}, {"sha": "2d88b1f72fa6d8a2e56e753aa903bfa40321c1c5", "filename": "libsanitizer/sanitizer_common/sanitizer_suppressions.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -42,7 +42,7 @@ class SuppressionContext {\n   void GetMatched(InternalMmapVector<Suppression *> *matched);\n \n  private:\n-  static const int kMaxSuppressionTypes = 32;\n+  static const int kMaxSuppressionTypes = 64;\n   const char **const suppression_types_;\n   const int suppression_types_num_;\n "}, {"sha": "c04797dd61b8b6d250046860125d41b66faba526", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_internal.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -76,7 +76,7 @@ class SymbolizerTool {\n // SymbolizerProcess may not be used from two threads simultaneously.\n class SymbolizerProcess {\n  public:\n-  explicit SymbolizerProcess(const char *path, bool use_forkpty = false);\n+  explicit SymbolizerProcess(const char *path, bool use_posix_spawn = false);\n   const char *SendCommand(const char *command);\n \n  protected:\n@@ -114,7 +114,7 @@ class SymbolizerProcess {\n   uptr times_restarted_;\n   bool failed_to_start_;\n   bool reported_invalid_path_;\n-  bool use_forkpty_;\n+  bool use_posix_spawn_;\n };\n \n class LLVMSymbolizerProcess;"}, {"sha": "3b19a6836ec53da3d2c4f71123e1e81cc6ffdecf", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libcdep.cpp", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -238,7 +238,8 @@ const LoadedModule *Symbolizer::FindModuleForAddress(uptr address) {\n //   <empty line>\n class LLVMSymbolizerProcess : public SymbolizerProcess {\n  public:\n-  explicit LLVMSymbolizerProcess(const char *path) : SymbolizerProcess(path) {}\n+  explicit LLVMSymbolizerProcess(const char *path)\n+      : SymbolizerProcess(path, /*use_posix_spawn=*/SANITIZER_MAC) {}\n \n  private:\n   bool ReachedEndOfOutput(const char *buffer, uptr length) const override {\n@@ -452,14 +453,14 @@ const char *LLVMSymbolizer::FormatAndSendCommand(const char *command_prefix,\n   return symbolizer_process_->SendCommand(buffer_);\n }\n \n-SymbolizerProcess::SymbolizerProcess(const char *path, bool use_forkpty)\n+SymbolizerProcess::SymbolizerProcess(const char *path, bool use_posix_spawn)\n     : path_(path),\n       input_fd_(kInvalidFd),\n       output_fd_(kInvalidFd),\n       times_restarted_(0),\n       failed_to_start_(false),\n       reported_invalid_path_(false),\n-      use_forkpty_(use_forkpty) {\n+      use_posix_spawn_(use_posix_spawn) {\n   CHECK(path_);\n   CHECK_NE(path_[0], '\\0');\n }"}, {"sha": "a619ed092f0bce054c6b7d2c28724fb65d3f8eb3", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_mac.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -50,14 +50,14 @@ bool DlAddrSymbolizer::SymbolizeData(uptr addr, DataInfo *datainfo) {\n class AtosSymbolizerProcess : public SymbolizerProcess {\n  public:\n   explicit AtosSymbolizerProcess(const char *path, pid_t parent_pid)\n-      : SymbolizerProcess(path, /*use_forkpty*/ true) {\n+      : SymbolizerProcess(path, /*use_posix_spawn*/ true) {\n     // Put the string command line argument in the object so that it outlives\n     // the call to GetArgV.\n     internal_snprintf(pid_str_, sizeof(pid_str_), \"%d\", parent_pid);\n   }\n \n  private:\n-  virtual bool StartSymbolizerSubprocess() override {\n+  bool StartSymbolizerSubprocess() override {\n     // Configure sandbox before starting atos process.\n     return SymbolizerProcess::StartSymbolizerSubprocess();\n   }"}, {"sha": "c123ecb11206cca14d1b78683e40aa45edc8d201", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cpp", "status": "modified", "additions": 15, "deletions": 67, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -33,10 +33,6 @@\n #include <sys/wait.h>\n #include <unistd.h>\n \n-#if SANITIZER_MAC\n-#include <util.h>  // for forkpty()\n-#endif  // SANITIZER_MAC\n-\n // C++ demangling function, as required by Itanium C++ ABI. This is weak,\n // because we do not require a C++ ABI library to be linked to a program\n // using sanitizers; if it's not present, we'll just use the mangled name.\n@@ -151,80 +147,32 @@ bool SymbolizerProcess::StartSymbolizerSubprocess() {\n     return false;\n   }\n \n-  int pid = -1;\n-\n-  int infd[2];\n-  internal_memset(&infd, 0, sizeof(infd));\n-  int outfd[2];\n-  internal_memset(&outfd, 0, sizeof(outfd));\n-  if (!CreateTwoHighNumberedPipes(infd, outfd)) {\n-    Report(\"WARNING: Can't create a socket pair to start \"\n-           \"external symbolizer (errno: %d)\\n\", errno);\n-    return false;\n-  }\n+  const char *argv[kArgVMax];\n+  GetArgV(path_, argv);\n+  pid_t pid;\n \n-  if (use_forkpty_) {\n+  if (use_posix_spawn_) {\n #if SANITIZER_MAC\n-    fd_t fd = kInvalidFd;\n-\n-    // forkpty redirects stdout and stderr into a single stream, so we would\n-    // receive error messages as standard replies. To avoid that, let's dup\n-    // stderr and restore it in the child.\n-    int saved_stderr = dup(STDERR_FILENO);\n-    CHECK_GE(saved_stderr, 0);\n-\n-    // We only need one pipe, for stdin of the child.\n-    close(outfd[0]);\n-    close(outfd[1]);\n-\n-    // Use forkpty to disable buffering in the new terminal.\n-    pid = internal_forkpty(&fd);\n-    if (pid == -1) {\n-      // forkpty() failed.\n-      Report(\"WARNING: failed to fork external symbolizer (errno: %d)\\n\",\n+    fd_t fd = internal_spawn(argv, &pid);\n+    if (fd == kInvalidFd) {\n+      Report(\"WARNING: failed to spawn external symbolizer (errno: %d)\\n\",\n              errno);\n       return false;\n-    } else if (pid == 0) {\n-      // Child subprocess.\n-\n-      // infd[0] is the child's reading end.\n-      close(infd[1]);\n-\n-      // Set up stdin to read from the pipe.\n-      CHECK_GE(dup2(infd[0], STDIN_FILENO), 0);\n-      close(infd[0]);\n-\n-      // Restore stderr.\n-      CHECK_GE(dup2(saved_stderr, STDERR_FILENO), 0);\n-      close(saved_stderr);\n-\n-      const char *argv[kArgVMax];\n-      GetArgV(path_, argv);\n-      execv(path_, const_cast<char **>(&argv[0]));\n-      internal__exit(1);\n     }\n \n-    // Input for the child, infd[1] is our writing end.\n-    output_fd_ = infd[1];\n-    close(infd[0]);\n-\n-    // Continue execution in parent process.\n     input_fd_ = fd;\n-\n-    close(saved_stderr);\n-\n-    // Disable echo in the new terminal, disable CR.\n-    struct termios termflags;\n-    tcgetattr(fd, &termflags);\n-    termflags.c_oflag &= ~ONLCR;\n-    termflags.c_lflag &= ~ECHO;\n-    tcsetattr(fd, TCSANOW, &termflags);\n+    output_fd_ = fd;\n #else  // SANITIZER_MAC\n     UNIMPLEMENTED();\n #endif  // SANITIZER_MAC\n   } else {\n-    const char *argv[kArgVMax];\n-    GetArgV(path_, argv);\n+    fd_t infd[2] = {}, outfd[2] = {};\n+    if (!CreateTwoHighNumberedPipes(infd, outfd)) {\n+      Report(\"WARNING: Can't create a socket pair to start \"\n+             \"external symbolizer (errno: %d)\\n\", errno);\n+      return false;\n+    }\n+\n     pid = StartSubprocess(path_, argv, /* stdin */ outfd[0],\n                           /* stdout */ infd[1]);\n     if (pid < 0) {"}, {"sha": "c26724ceb7a7d3648d72fe617ea2d4f25f94ceb8", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_report.cpp", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -106,8 +106,9 @@ void ReportMmapWriteExec(int prot) {\n   if (StackTrace::WillUseFastUnwind(fast)) {\n     GetThreadStackTopAndBottom(false, &top, &bottom);\n     stack->Unwind(kStackTraceMax, pc, bp, nullptr, top, bottom, true);\n-  } else\n+  } else {\n     stack->Unwind(kStackTraceMax, pc, 0, nullptr, 0, 0, false);\n+  }\n \n   Printf(\"%s\", d.Warning());\n   Report(\"WARNING: %s: writable-executable page usage\\n\", SanitizerToolName);\n@@ -190,9 +191,14 @@ static void ReportDeadlySignalImpl(const SignalContext &sig, u32 tid,\n   SanitizerCommonDecorator d;\n   Printf(\"%s\", d.Warning());\n   const char *description = sig.Describe();\n-  Report(\"ERROR: %s: %s on unknown address %p (pc %p bp %p sp %p T%d)\\n\",\n-         SanitizerToolName, description, (void *)sig.addr, (void *)sig.pc,\n-         (void *)sig.bp, (void *)sig.sp, tid);\n+  if (sig.is_memory_access && !sig.is_true_faulting_addr)\n+    Report(\"ERROR: %s: %s on unknown address (pc %p bp %p sp %p T%d)\\n\",\n+           SanitizerToolName, description, (void *)sig.pc, (void *)sig.bp,\n+           (void *)sig.sp, tid);\n+  else\n+    Report(\"ERROR: %s: %s on unknown address %p (pc %p bp %p sp %p T%d)\\n\",\n+           SanitizerToolName, description, (void *)sig.addr, (void *)sig.pc,\n+           (void *)sig.bp, (void *)sig.sp, tid);\n   Printf(\"%s\", d.Default());\n   if (sig.pc < GetPageSizeCached())\n     Report(\"Hint: pc points to the zero page.\\n\");\n@@ -202,7 +208,11 @@ static void ReportDeadlySignalImpl(const SignalContext &sig, u32 tid,\n             ? \"WRITE\"\n             : (sig.write_flag == SignalContext::READ ? \"READ\" : \"UNKNOWN\");\n     Report(\"The signal is caused by a %s memory access.\\n\", access_type);\n-    if (sig.addr < GetPageSizeCached())\n+    if (!sig.is_true_faulting_addr)\n+      Report(\"Hint: this fault was caused by a dereference of a high value \"\n+             \"address (see register values below).  Dissassemble the provided \"\n+             \"pc to learn which register was used.\\n\");\n+    else if (sig.addr < GetPageSizeCached())\n       Report(\"Hint: address points to the zero page.\\n\");\n   }\n   MaybeReportNonExecRegion(sig.pc);"}, {"sha": "84be6fc3234209fede5000c39145c4f722a86b26", "filename": "libsanitizer/sanitizer_common/sanitizer_termination.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_termination.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_termination.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_termination.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -84,7 +84,7 @@ void NORETURN CheckFailed(const char *file, int line, const char *cond,\n \n } // namespace __sanitizer\n \n-using namespace __sanitizer;  // NOLINT\n+using namespace __sanitizer;\n \n extern \"C\" {\n SANITIZER_INTERFACE_ATTRIBUTE"}, {"sha": "b2628dcc4dc1f68b1799f3a60021ae33aced9584", "filename": "libsanitizer/sanitizer_common/sanitizer_unwind_linux_libcdep.cpp", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -27,6 +27,8 @@\n \n namespace __sanitizer {\n \n+namespace {\n+\n //---------------------------- UnwindSlow --------------------------------------\n \n typedef struct {\n@@ -46,38 +48,6 @@ release_my_map_info_list_func release_my_map_info_list;\n unwind_backtrace_signal_arch_func unwind_backtrace_signal_arch;\n } // extern \"C\"\n \n-#if SANITIZER_ANDROID\n-void SanitizerInitializeUnwinder() {\n-  if (AndroidGetApiLevel() >= ANDROID_LOLLIPOP_MR1) return;\n-\n-  // Pre-lollipop Android can not unwind through signal handler frames with\n-  // libgcc unwinder, but it has a libcorkscrew.so library with the necessary\n-  // workarounds.\n-  void *p = dlopen(\"libcorkscrew.so\", RTLD_LAZY);\n-  if (!p) {\n-    VReport(1,\n-            \"Failed to open libcorkscrew.so. You may see broken stack traces \"\n-            \"in SEGV reports.\");\n-    return;\n-  }\n-  acquire_my_map_info_list =\n-      (acquire_my_map_info_list_func)(uptr)dlsym(p, \"acquire_my_map_info_list\");\n-  release_my_map_info_list =\n-      (release_my_map_info_list_func)(uptr)dlsym(p, \"release_my_map_info_list\");\n-  unwind_backtrace_signal_arch = (unwind_backtrace_signal_arch_func)(uptr)dlsym(\n-      p, \"unwind_backtrace_signal_arch\");\n-  if (!acquire_my_map_info_list || !release_my_map_info_list ||\n-      !unwind_backtrace_signal_arch) {\n-    VReport(1,\n-            \"Failed to find one of the required symbols in libcorkscrew.so. \"\n-            \"You may see broken stack traces in SEGV reports.\");\n-    acquire_my_map_info_list = 0;\n-    unwind_backtrace_signal_arch = 0;\n-    release_my_map_info_list = 0;\n-  }\n-}\n-#endif\n-\n #if defined(__arm__) && !SANITIZER_NETBSD\n // NetBSD uses dwarf EH\n #define UNWIND_STOP _URC_END_OF_STACK\n@@ -119,6 +89,40 @@ _Unwind_Reason_Code Unwind_Trace(struct _Unwind_Context *ctx, void *param) {\n   return UNWIND_CONTINUE;\n }\n \n+}  // namespace\n+\n+#if SANITIZER_ANDROID\n+void SanitizerInitializeUnwinder() {\n+  if (AndroidGetApiLevel() >= ANDROID_LOLLIPOP_MR1) return;\n+\n+  // Pre-lollipop Android can not unwind through signal handler frames with\n+  // libgcc unwinder, but it has a libcorkscrew.so library with the necessary\n+  // workarounds.\n+  void *p = dlopen(\"libcorkscrew.so\", RTLD_LAZY);\n+  if (!p) {\n+    VReport(1,\n+            \"Failed to open libcorkscrew.so. You may see broken stack traces \"\n+            \"in SEGV reports.\");\n+    return;\n+  }\n+  acquire_my_map_info_list =\n+      (acquire_my_map_info_list_func)(uptr)dlsym(p, \"acquire_my_map_info_list\");\n+  release_my_map_info_list =\n+      (release_my_map_info_list_func)(uptr)dlsym(p, \"release_my_map_info_list\");\n+  unwind_backtrace_signal_arch = (unwind_backtrace_signal_arch_func)(uptr)dlsym(\n+      p, \"unwind_backtrace_signal_arch\");\n+  if (!acquire_my_map_info_list || !release_my_map_info_list ||\n+      !unwind_backtrace_signal_arch) {\n+    VReport(1,\n+            \"Failed to find one of the required symbols in libcorkscrew.so. \"\n+            \"You may see broken stack traces in SEGV reports.\");\n+    acquire_my_map_info_list = 0;\n+    unwind_backtrace_signal_arch = 0;\n+    release_my_map_info_list = 0;\n+  }\n+}\n+#endif\n+\n void BufferedStackTrace::UnwindSlow(uptr pc, u32 max_depth) {\n   CHECK_GE(max_depth, 2);\n   size = 0;"}, {"sha": "31216f3ec3a6c6b2b211fea8898ee0498e2d952b", "filename": "libsanitizer/sanitizer_common/sanitizer_vector.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_vector.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -23,11 +23,7 @@ namespace __sanitizer {\n template<typename T>\n class Vector {\n  public:\n-  explicit Vector()\n-      : begin_()\n-      , end_()\n-      , last_() {\n-  }\n+  Vector() : begin_(), end_(), last_() {}\n \n   ~Vector() {\n     if (begin_)"}, {"sha": "36dde49d8708343337fe5b965b5408cec8c50d19", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cpp", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -239,6 +239,11 @@ bool MmapFixedNoReserve(uptr fixed_addr, uptr size, const char *name) {\n   return true;\n }\n \n+bool MmapFixedSuperNoReserve(uptr fixed_addr, uptr size, const char *name) {\n+  // FIXME: Windows support large pages too. Might be worth checking\n+  return MmapFixedNoReserve(fixed_addr, size, name);\n+}\n+\n // Memory space mapped by 'MmapFixedOrDie' must have been reserved by\n // 'MmapFixedNoAccess'.\n void *MmapFixedOrDie(uptr fixed_addr, uptr size, const char *name) {\n@@ -671,7 +676,7 @@ static int RunAtexit() {\n   return ret;\n }\n \n-#pragma section(\".CRT$XID\", long, read)  // NOLINT\n+#pragma section(\".CRT$XID\", long, read)\n __declspec(allocate(\".CRT$XID\")) int (*__run_atexit)() = RunAtexit;\n #endif\n \n@@ -940,6 +945,11 @@ bool SignalContext::IsMemoryAccess() const {\n   return GetWriteFlag() != SignalContext::UNKNOWN;\n }\n \n+bool SignalContext::IsTrueFaultingAddress() const {\n+  // FIXME: Provide real implementation for this. See Linux and Mac variants.\n+  return IsMemoryAccess();\n+}\n+\n SignalContext::WriteFlag SignalContext::GetWriteFlag() const {\n   EXCEPTION_RECORD *exception_record = (EXCEPTION_RECORD *)siginfo;\n   // The contents of this array are documented at"}, {"sha": "bfe38a3323674626bb33e48657bf19b744320171", "filename": "libsanitizer/sanitizer_common/sanitizer_win_defs.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_defs.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -43,6 +43,8 @@\n #define STRINGIFY_(A) #A\n #define STRINGIFY(A) STRINGIFY_(A)\n \n+#if !SANITIZER_GO\n+\n // ----------------- A workaround for the absence of weak symbols --------------\n // We don't have a direct equivalent of weak symbols when using MSVC, but we can\n // use the /alternatename directive to tell the linker to default a specific\n@@ -158,5 +160,15 @@\n //     return a >= b;\n //   }\n //\n+\n+#else // SANITIZER_GO\n+\n+// Go neither needs nor wants weak references.\n+// The shenanigans above don't work for gcc.\n+# define WIN_WEAK_EXPORT_DEF(ReturnType, Name, ...)                            \\\n+  extern \"C\" ReturnType Name(__VA_ARGS__)\n+\n+#endif // SANITIZER_GO\n+\n #endif // SANITIZER_WINDOWS\n #endif // SANITIZER_WIN_DEFS_H"}, {"sha": "1562c161a76260ab70aa84c1abbaec95149e9b00", "filename": "libsanitizer/sanitizer_common/sanitizer_win_dll_thunk.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dll_thunk.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dll_thunk.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dll_thunk.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -54,8 +54,8 @@ int dllThunkInterceptWhenPossible(const char* main_function,\n #define INTERFACE_WEAK_FUNCTION(Name) INTERCEPT_SANITIZER_WEAK_FUNCTION(Name)\n #include \"sanitizer_common_interface.inc\"\n \n-#pragma section(\".DLLTH$A\", read)  // NOLINT\n-#pragma section(\".DLLTH$Z\", read)  // NOLINT\n+#pragma section(\".DLLTH$A\", read)\n+#pragma section(\".DLLTH$Z\", read)\n \n typedef void (*DllThunkCB)();\n extern \"C\" {\n@@ -85,7 +85,7 @@ extern \"C\" int __dll_thunk_init() {\n \n // We want to call dll_thunk_init before C/C++ initializers / constructors are\n // executed, otherwise functions like memset might be invoked.\n-#pragma section(\".CRT$XIB\", long, read)  // NOLINT\n+#pragma section(\".CRT$XIB\", long, read)\n __declspec(allocate(\".CRT$XIB\")) int (*__dll_thunk_preinit)() =\n     __dll_thunk_init;\n \n@@ -94,7 +94,7 @@ static void WINAPI dll_thunk_thread_init(void *mod, unsigned long reason,\n   if (reason == /*DLL_PROCESS_ATTACH=*/1) __dll_thunk_init();\n }\n \n-#pragma section(\".CRT$XLAB\", long, read)  // NOLINT\n+#pragma section(\".CRT$XLAB\", long, read)\n __declspec(allocate(\".CRT$XLAB\")) void (WINAPI *__dll_thunk_tls_init)(void *,\n     unsigned long, void *) = dll_thunk_thread_init;\n "}, {"sha": "b14bbf76d9a765bb88702743e7f659709d4f81a1", "filename": "libsanitizer/sanitizer_common/sanitizer_win_weak_interception.cpp", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_weak_interception.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_weak_interception.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_weak_interception.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -38,6 +38,7 @@ int interceptWhenPossible(uptr dll_function, const char *real_function) {\n \n // Declare weak hooks.\n extern \"C\" {\n+void __sanitizer_on_print(const char *str);\n void __sanitizer_weak_hook_memcmp(uptr called_pc, const void *s1,\n                                   const void *s2, uptr n, int result);\n void __sanitizer_weak_hook_strcmp(uptr called_pc, const char *s1,\n@@ -53,8 +54,8 @@ void __sanitizer_weak_hook_strstr(uptr called_pc, const char *s1,\n #define INTERFACE_WEAK_FUNCTION(Name) INTERCEPT_SANITIZER_WEAK_FUNCTION(Name)\n #include \"sanitizer_common_interface.inc\"\n \n-#pragma section(\".WEAK$A\", read)  // NOLINT\n-#pragma section(\".WEAK$Z\", read)  // NOLINT\n+#pragma section(\".WEAK$A\", read)\n+#pragma section(\".WEAK$Z\", read)\n \n typedef void (*InterceptCB)();\n extern \"C\" {\n@@ -77,7 +78,7 @@ static int weak_intercept_init() {\n   return 0;\n }\n \n-#pragma section(\".CRT$XIB\", long, read)  // NOLINT\n+#pragma section(\".CRT$XIB\", long, read)\n __declspec(allocate(\".CRT$XIB\")) int (*__weak_intercept_preinit)() =\n     weak_intercept_init;\n \n@@ -86,7 +87,7 @@ static void WINAPI weak_intercept_thread_init(void *mod, unsigned long reason,\n   if (reason == /*DLL_PROCESS_ATTACH=*/1) weak_intercept_init();\n }\n \n-#pragma section(\".CRT$XLAB\", long, read)  // NOLINT\n+#pragma section(\".CRT$XLAB\", long, read)\n __declspec(allocate(\".CRT$XLAB\")) void(WINAPI *__weak_intercept_tls_init)(\n     void *, unsigned long, void *) = weak_intercept_thread_init;\n "}, {"sha": "298297af31eb6b56f02b4d117bd47f4466d52bf2", "filename": "libsanitizer/tsan/tsan_dispatch_defs.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_dispatch_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_dispatch_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_dispatch_defs.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -31,11 +31,11 @@ typedef void (^dispatch_block_t)(void);\n typedef void (^dispatch_io_handler_t)(bool done, dispatch_data_t data,\n                                       int error);\n \n-typedef long dispatch_once_t; // NOLINT\n+typedef long dispatch_once_t;\n typedef __sanitizer::u64 dispatch_time_t;\n-typedef int dispatch_fd_t; // NOLINT\n-typedef unsigned long dispatch_io_type_t; // NOLINT\n-typedef unsigned long dispatch_io_close_flags_t; // NOLINT\n+typedef int dispatch_fd_t;\n+typedef unsigned long dispatch_io_type_t;\n+typedef unsigned long dispatch_io_close_flags_t;\n \n extern \"C\" {\n void *dispatch_get_context(dispatch_object_t object);\n@@ -57,10 +57,10 @@ extern const dispatch_block_t _dispatch_data_destructor_munmap;\n #endif\n \n // Data types used in dispatch APIs\n-typedef unsigned long size_t; // NOLINT\n-typedef unsigned long uintptr_t; // NOLINT\n+typedef unsigned long size_t;\n+typedef unsigned long uintptr_t;\n typedef __sanitizer::s64 off_t;\n typedef __sanitizer::u16 mode_t;\n-typedef long long_t; // NOLINT\n+typedef long long_t;\n \n #endif  // TSAN_DISPATCH_DEFS_H"}, {"sha": "0faa1ee93a139ea3600b269f9f0ff029270003e1", "filename": "libsanitizer/tsan/tsan_external.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_external.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_external.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_external.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -25,7 +25,7 @@ static TagData registered_tags[kExternalTagMax] = {\n   {},\n   {\"Swift variable\", \"Swift access race\"},\n };\n-static atomic_uint32_t used_tags{kExternalTagFirstUserAvailable};  // NOLINT.\n+static atomic_uint32_t used_tags{kExternalTagFirstUserAvailable};\n static TagData *GetTagData(uptr tag) {\n   // Invalid/corrupted tag?  Better return NULL and let the caller deal with it.\n   if (tag >= atomic_load(&used_tags, memory_order_relaxed)) return nullptr;"}, {"sha": "50a6b56916aa7d4667c68907b5e8305871bdfef3", "filename": "libsanitizer/tsan/tsan_fd.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_fd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_fd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_fd.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -86,7 +86,8 @@ static FdDesc *fddesc(ThreadState *thr, uptr pc, int fd) {\n     else\n       user_free(thr, pc, p, false);\n   }\n-  return &((FdDesc*)l1)[fd % kTableSizeL2];  // NOLINT\n+  FdDesc *fds = reinterpret_cast<FdDesc *>(l1);\n+  return &fds[fd % kTableSizeL2];\n }\n \n // pd must be already ref'ed."}, {"sha": "5dacd3256abc9a009780a78c40644cb36762154d", "filename": "libsanitizer/tsan/tsan_interceptors_libdispatch.cpp", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interceptors_libdispatch.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interceptors_libdispatch.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_libdispatch.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -1,4 +1,4 @@\n-//===-- tsan_libdispatch.cpp ----------------------------------------------===//\n+//===-- tsan_interceptors_libdispatch.cpp ---------------------------------===//\n //\n // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n // See https://llvm.org/LICENSE.txt for license information.\n@@ -16,6 +16,7 @@\n #include \"tsan_interceptors.h\"\n #include \"tsan_rtl.h\"\n \n+#include \"BlocksRuntime/Block.h\"\n #include \"tsan_dispatch_defs.h\"\n \n namespace __tsan {", "previous_filename": "libsanitizer/tsan/tsan_libdispatch.cpp"}, {"sha": "aa29536d8616ee8d54dcb51ad4662e5eee989a25", "filename": "libsanitizer/tsan/tsan_interceptors_mac.cpp", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -23,13 +23,14 @@\n #include <errno.h>\n #include <libkern/OSAtomic.h>\n #include <objc/objc-sync.h>\n+#include <os/lock.h>\n #include <sys/ucontext.h>\n \n #if defined(__has_include) && __has_include(<xpc/xpc.h>)\n #include <xpc/xpc.h>\n #endif  // #if defined(__has_include) && __has_include(<xpc/xpc.h>)\n \n-typedef long long_t;  // NOLINT\n+typedef long long_t;\n \n extern \"C\" {\n int getcontext(ucontext_t *ucp) __attribute__((returns_twice));\n@@ -246,6 +247,45 @@ TSAN_INTERCEPTOR(void, os_lock_unlock, void *lock) {\n   REAL(os_lock_unlock)(lock);\n }\n \n+TSAN_INTERCEPTOR(void, os_unfair_lock_lock, os_unfair_lock_t lock) {\n+  if (!cur_thread()->is_inited || cur_thread()->is_dead) {\n+    return REAL(os_unfair_lock_lock)(lock);\n+  }\n+  SCOPED_TSAN_INTERCEPTOR(os_unfair_lock_lock, lock);\n+  REAL(os_unfair_lock_lock)(lock);\n+  Acquire(thr, pc, (uptr)lock);\n+}\n+\n+TSAN_INTERCEPTOR(void, os_unfair_lock_lock_with_options, os_unfair_lock_t lock,\n+                 u32 options) {\n+  if (!cur_thread()->is_inited || cur_thread()->is_dead) {\n+    return REAL(os_unfair_lock_lock_with_options)(lock, options);\n+  }\n+  SCOPED_TSAN_INTERCEPTOR(os_unfair_lock_lock_with_options, lock, options);\n+  REAL(os_unfair_lock_lock_with_options)(lock, options);\n+  Acquire(thr, pc, (uptr)lock);\n+}\n+\n+TSAN_INTERCEPTOR(bool, os_unfair_lock_trylock, os_unfair_lock_t lock) {\n+  if (!cur_thread()->is_inited || cur_thread()->is_dead) {\n+    return REAL(os_unfair_lock_trylock)(lock);\n+  }\n+  SCOPED_TSAN_INTERCEPTOR(os_unfair_lock_trylock, lock);\n+  bool result = REAL(os_unfair_lock_trylock)(lock);\n+  if (result)\n+    Acquire(thr, pc, (uptr)lock);\n+  return result;\n+}\n+\n+TSAN_INTERCEPTOR(void, os_unfair_lock_unlock, os_unfair_lock_t lock) {\n+  if (!cur_thread()->is_inited || cur_thread()->is_dead) {\n+    return REAL(os_unfair_lock_unlock)(lock);\n+  }\n+  SCOPED_TSAN_INTERCEPTOR(os_unfair_lock_unlock, lock);\n+  Release(thr, pc, (uptr)lock);\n+  REAL(os_unfair_lock_unlock)(lock);\n+}\n+\n #if defined(__has_include) && __has_include(<xpc/xpc.h>)\n \n TSAN_INTERCEPTOR(void, xpc_connection_set_event_handler,"}, {"sha": "cd318f8af93f078806dbb8a13e6fe07d8d471f0d", "filename": "libsanitizer/tsan/tsan_interceptors_mach_vm.cpp", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interceptors_mach_vm.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interceptors_mach_vm.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_mach_vm.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -0,0 +1,52 @@\n+//===-- tsan_interceptors_mach_vm.cpp -------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+// Interceptors for mach_vm_* user space memory routines on Darwin.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"interception/interception.h\"\n+#include \"tsan_interceptors.h\"\n+#include \"tsan_platform.h\"\n+\n+#include <mach/mach.h>\n+\n+namespace __tsan {\n+\n+static bool intersects_with_shadow(mach_vm_address_t *address,\n+                                   mach_vm_size_t size, int flags) {\n+  // VM_FLAGS_FIXED is 0x0, so we have to test for VM_FLAGS_ANYWHERE.\n+  if (flags & VM_FLAGS_ANYWHERE) return false;\n+  uptr ptr = *address;\n+  return !IsAppMem(ptr) || !IsAppMem(ptr + size - 1);\n+}\n+\n+TSAN_INTERCEPTOR(kern_return_t, mach_vm_allocate, vm_map_t target,\n+                 mach_vm_address_t *address, mach_vm_size_t size, int flags) {\n+  SCOPED_TSAN_INTERCEPTOR(mach_vm_allocate, target, address, size, flags);\n+  if (target != mach_task_self())\n+    return REAL(mach_vm_allocate)(target, address, size, flags);\n+  if (intersects_with_shadow(address, size, flags))\n+    return KERN_NO_SPACE;\n+  kern_return_t res = REAL(mach_vm_allocate)(target, address, size, flags);\n+  if (res == KERN_SUCCESS)\n+    MemoryRangeImitateWriteOrResetRange(thr, pc, *address, size);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(kern_return_t, mach_vm_deallocate, vm_map_t target,\n+                 mach_vm_address_t address, mach_vm_size_t size) {\n+  SCOPED_TSAN_INTERCEPTOR(mach_vm_deallocate, target, address, size);\n+  if (target != mach_task_self())\n+    return REAL(mach_vm_deallocate)(target, address, size);\n+  UnmapShadow(thr, address, size);\n+  return REAL(mach_vm_deallocate)(target, address, size);\n+}\n+\n+}  // namespace __tsan"}, {"sha": "8aea1e4ec0513bbddc55bd55e307fa456e26d03e", "filename": "libsanitizer/tsan/tsan_interceptors_posix.cpp", "status": "renamed", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -1,4 +1,4 @@\n-//===-- tsan_interceptors.cpp ---------------------------------------------===//\n+//===-- tsan_interceptors_posix.cpp ---------------------------------------===//\n //\n // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n // See https://llvm.org/LICENSE.txt for license information.\n@@ -31,8 +31,7 @@\n #include \"tsan_mman.h\"\n #include \"tsan_fd.h\"\n \n-\n-using namespace __tsan;  // NOLINT\n+using namespace __tsan;\n \n #if SANITIZER_FREEBSD || SANITIZER_MAC\n #define stdout __stdoutp\n@@ -41,9 +40,10 @@ using namespace __tsan;  // NOLINT\n \n #if SANITIZER_NETBSD\n #define dirfd(dirp) (*(int *)(dirp))\n-#define fileno_unlocked(fp) \\\n-  (((__sanitizer_FILE*)fp)->_file == -1 ? -1 : \\\n-   (int)(unsigned short)(((__sanitizer_FILE*)fp)->_file))  // NOLINT\n+#define fileno_unlocked(fp)              \\\n+  (((__sanitizer_FILE *)fp)->_file == -1 \\\n+       ? -1                              \\\n+       : (int)(unsigned short)(((__sanitizer_FILE *)fp)->_file))\n \n #define stdout ((__sanitizer_FILE*)&__sF[1])\n #define stderr ((__sanitizer_FILE*)&__sF[2])\n@@ -114,6 +114,7 @@ const int PTHREAD_MUTEX_RECURSIVE_NP = 2;\n const int EPOLL_CTL_ADD = 1;\n #endif\n const int SIGILL = 4;\n+const int SIGTRAP = 5;\n const int SIGABRT = 6;\n const int SIGFPE = 8;\n const int SIGSEGV = 11;\n@@ -133,7 +134,7 @@ const int PTHREAD_BARRIER_SERIAL_THREAD = 1234567;\n const int PTHREAD_BARRIER_SERIAL_THREAD = -1;\n #endif\n const int MAP_FIXED = 0x10;\n-typedef long long_t;  // NOLINT\n+typedef long long_t;\n \n // From /usr/include/unistd.h\n # define F_ULOCK 0      /* Unlock a previously locked region.  */\n@@ -723,12 +724,12 @@ TSAN_INTERCEPTOR(uptr, malloc_usable_size, void *p) {\n }\n #endif\n \n-TSAN_INTERCEPTOR(char*, strcpy, char *dst, const char *src) {  // NOLINT\n-  SCOPED_TSAN_INTERCEPTOR(strcpy, dst, src);  // NOLINT\n+TSAN_INTERCEPTOR(char *, strcpy, char *dst, const char *src) {\n+  SCOPED_TSAN_INTERCEPTOR(strcpy, dst, src);\n   uptr srclen = internal_strlen(src);\n   MemoryAccessRange(thr, pc, (uptr)dst, srclen + 1, true);\n   MemoryAccessRange(thr, pc, (uptr)src, srclen + 1, false);\n-  return REAL(strcpy)(dst, src);  // NOLINT\n+  return REAL(strcpy)(dst, src);\n }\n \n TSAN_INTERCEPTOR(char*, strncpy, char *dst, char *src, uptr n) {\n@@ -745,6 +746,8 @@ TSAN_INTERCEPTOR(char*, strdup, const char *str) {\n   return REAL(strdup)(str);\n }\n \n+// Zero out addr if it points into shadow memory and was provided as a hint\n+// only, i.e., MAP_FIXED is not set.\n static bool fix_mmap_addr(void **addr, long_t sz, int flags) {\n   if (*addr) {\n     if (!IsAppMem((uptr)*addr) || !IsAppMem((uptr)*addr + sz - 1)) {\n@@ -767,22 +770,14 @@ static void *mmap_interceptor(ThreadState *thr, uptr pc, Mmap real_mmap,\n   void *res = real_mmap(addr, sz, prot, flags, fd, off);\n   if (res != MAP_FAILED) {\n     if (fd > 0) FdAccess(thr, pc, fd);\n-    if (thr->ignore_reads_and_writes == 0)\n-      MemoryRangeImitateWrite(thr, pc, (uptr)res, sz);\n-    else\n-      MemoryResetRange(thr, pc, (uptr)res, sz);\n+    MemoryRangeImitateWriteOrResetRange(thr, pc, (uptr)res, sz);\n   }\n   return res;\n }\n \n TSAN_INTERCEPTOR(int, munmap, void *addr, long_t sz) {\n   SCOPED_TSAN_INTERCEPTOR(munmap, addr, sz);\n-  if (sz != 0) {\n-    // If sz == 0, munmap will return EINVAL and don't unmap any memory.\n-    DontNeedShadowFor((uptr)addr, sz);\n-    ScopedGlobalProcessor sgp;\n-    ctx->metamap.ResetRange(thr->proc(), (uptr)addr, (uptr)sz);\n-  }\n+  UnmapShadow(thr, (uptr)addr, sz);\n   int res = REAL(munmap)(addr, sz);\n   return res;\n }\n@@ -1968,10 +1963,10 @@ void ProcessPendingSignals(ThreadState *thr) {\n }  // namespace __tsan\n \n static bool is_sync_signal(ThreadSignalContext *sctx, int sig) {\n-  return sig == SIGSEGV || sig == SIGBUS || sig == SIGILL ||\n-      sig == SIGABRT || sig == SIGFPE || sig == SIGPIPE || sig == SIGSYS ||\n-      // If we are sending signal to ourselves, we must process it now.\n-      (sctx && sig == sctx->int_signal_send);\n+  return sig == SIGSEGV || sig == SIGBUS || sig == SIGILL || sig == SIGTRAP ||\n+         sig == SIGABRT || sig == SIGFPE || sig == SIGPIPE || sig == SIGSYS ||\n+         // If we are sending signal to ourselves, we must process it now.\n+         (sctx && sig == sctx->int_signal_send);\n }\n \n void ALWAYS_INLINE rtl_generic_sighandler(bool sigact, int sig,\n@@ -2666,7 +2661,7 @@ void InitializeInterceptors() {\n   TSAN_MAYBE_INTERCEPT_PVALLOC;\n   TSAN_INTERCEPT(posix_memalign);\n \n-  TSAN_INTERCEPT(strcpy);  // NOLINT\n+  TSAN_INTERCEPT(strcpy);\n   TSAN_INTERCEPT(strncpy);\n   TSAN_INTERCEPT(strdup);\n ", "previous_filename": "libsanitizer/tsan/tsan_interceptors.cpp"}, {"sha": "2b3a0889b70a4ac636f4cc8c046e015a6a1efec5", "filename": "libsanitizer/tsan/tsan_interface.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interface.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interface.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -17,7 +17,7 @@\n \n #define CALLERPC ((uptr)__builtin_return_address(0))\n \n-using namespace __tsan;  // NOLINT\n+using namespace __tsan;\n \n typedef u16 uint16_t;\n typedef u32 uint32_t;"}, {"sha": "6d7286ca5b8afbb22d82b1af0bc5bab3ca8a4084", "filename": "libsanitizer/tsan/tsan_interface.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -90,9 +90,14 @@ SANITIZER_INTERFACE_ATTRIBUTE\n void __tsan_external_write(void *addr, void *caller_pc, void *tag);\n \n SANITIZER_INTERFACE_ATTRIBUTE\n-void __tsan_read_range(void *addr, unsigned long size);  // NOLINT\n+void __tsan_read_range(void *addr, unsigned long size);\n SANITIZER_INTERFACE_ATTRIBUTE\n-void __tsan_write_range(void *addr, unsigned long size);  // NOLINT\n+void __tsan_write_range(void *addr, unsigned long size);\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __tsan_read_range_pc(void *addr, unsigned long size, void *pc);  // NOLINT\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __tsan_write_range_pc(void *addr, unsigned long size, void *pc);  // NOLINT\n \n // User may provide function that would be called right when TSan detects\n // an error. The argument 'report' is an opaque pointer that can be used to\n@@ -187,9 +192,9 @@ namespace __tsan {\n \n // These should match declarations from public tsan_interface_atomic.h header.\n typedef unsigned char      a8;\n-typedef unsigned short     a16;  // NOLINT\n+typedef unsigned short a16;\n typedef unsigned int       a32;\n-typedef unsigned long long a64;  // NOLINT\n+typedef unsigned long long a64;\n #if !SANITIZER_GO && (defined(__SIZEOF_INT128__) \\\n     || (__clang_major__ * 100 + __clang_minor__ >= 302)) && !defined(__mips64)\n __extension__ typedef __int128 a128;"}, {"sha": "99516d94bba3c2caec314ae0f15c886eb62fe14d", "filename": "libsanitizer/tsan/tsan_interface_ann.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interface_ann.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interface_ann.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_ann.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -24,7 +24,7 @@\n \n #define CALLERPC ((uptr)__builtin_return_address(0))\n \n-using namespace __tsan;  // NOLINT\n+using namespace __tsan;\n \n namespace __tsan {\n \n@@ -220,7 +220,7 @@ static void ReportMissedExpectedRace(ExpectRace *race) {\n }\n }  // namespace __tsan\n \n-using namespace __tsan;  // NOLINT\n+using namespace __tsan;\n \n extern \"C\" {\n void INTERFACE_ATTRIBUTE AnnotateHappensBefore(char *f, int l, uptr addr) {"}, {"sha": "3f459aff532cb6982a2054783ab8a2abd061c6d0", "filename": "libsanitizer/tsan/tsan_interface_atomic.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -25,7 +25,7 @@\n #include \"tsan_interface.h\"\n #include \"tsan_rtl.h\"\n \n-using namespace __tsan;  // NOLINT\n+using namespace __tsan;\n \n #if !SANITIZER_GO && __TSAN_HAS_INT128\n // Protects emulation of 128-bit atomic operations."}, {"sha": "f955ddf99247c5f162de02992ae017a4df8465ad", "filename": "libsanitizer/tsan/tsan_interface_inl.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interface_inl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interface_inl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_inl.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -15,7 +15,7 @@\n \n #define CALLERPC ((uptr)__builtin_return_address(0))\n \n-using namespace __tsan;  // NOLINT\n+using namespace __tsan;\n \n void __tsan_read1(void *addr) {\n   MemoryRead(cur_thread(), CALLERPC, (uptr)addr, kSizeLog1);\n@@ -122,3 +122,11 @@ void __tsan_read_range(void *addr, uptr size) {\n void __tsan_write_range(void *addr, uptr size) {\n   MemoryAccessRange(cur_thread(), CALLERPC, (uptr)addr, size, true);\n }\n+\n+void __tsan_read_range_pc(void *addr, uptr size, void *pc) {\n+  MemoryAccessRange(cur_thread(), (uptr)pc, (uptr)addr, size, false);\n+}\n+\n+void __tsan_write_range_pc(void *addr, uptr size, void *pc) {\n+  MemoryAccessRange(cur_thread(), (uptr)pc, (uptr)addr, size, true);\n+}"}, {"sha": "081c6ff1022e876e115ba9032e893acdfe74033d", "filename": "libsanitizer/tsan/tsan_interface_java.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interface_java.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interface_java.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_java.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -19,7 +19,7 @@\n #include \"sanitizer_common/sanitizer_stacktrace.h\"\n #include \"sanitizer_common/sanitizer_procmaps.h\"\n \n-using namespace __tsan;  // NOLINT\n+using namespace __tsan;\n \n const jptr kHeapAlignment = 8;\n "}, {"sha": "51b445251e09b028788d1fcc564e096ce1e6c5b6", "filename": "libsanitizer/tsan/tsan_interface_java.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interface_java.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_interface_java.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_java.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -31,7 +31,7 @@\n extern \"C\" {\n #endif\n \n-typedef unsigned long jptr;  // NOLINT\n+typedef unsigned long jptr;\n \n // Must be called before any other callback from Java.\n void __tsan_java_init(jptr heap_begin, jptr heap_size) INTERFACE_ATTRIBUTE;"}, {"sha": "72857b773fed62299dd270b60ddd9b3584643190", "filename": "libsanitizer/tsan/tsan_md5.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_md5.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_md5.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_md5.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -29,7 +29,7 @@ namespace __tsan {\n   SET(n)\n \n typedef unsigned int MD5_u32plus;\n-typedef unsigned long ulong_t;  // NOLINT\n+typedef unsigned long ulong_t;\n \n typedef struct {\n   MD5_u32plus lo, hi;"}, {"sha": "a5280d4472c9a8c742f6ee2d0d5ad4f9370e47f0", "filename": "libsanitizer/tsan/tsan_mman.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_mman.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_mman.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -79,11 +79,10 @@ enum MBlockType {\n void *internal_alloc(MBlockType typ, uptr sz);\n void internal_free(void *p);\n \n-template<typename T>\n-void DestroyAndFree(T *&p) {\n+template <typename T>\n+void DestroyAndFree(T *p) {\n   p->~T();\n   internal_free(p);\n-  p = 0;\n }\n \n }  // namespace __tsan"}, {"sha": "fc44a5221b5b0ff901988f9f5711bc2ae8ec9f85", "filename": "libsanitizer/tsan/tsan_new_delete.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_new_delete.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_new_delete.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_new_delete.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -17,7 +17,7 @@\n #include \"tsan_interceptors.h\"\n #include \"tsan_rtl.h\"\n \n-using namespace __tsan;  // NOLINT\n+using namespace __tsan;\n \n namespace std {\n struct nothrow_t {};"}, {"sha": "63eb14fcd3402abb8426ecfc30f2a62c4e32c9a7", "filename": "libsanitizer/tsan/tsan_platform.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -457,6 +457,8 @@ struct Mapping47 {\n   static const uptr kAppMemEnd     = 0x00e000000000ull;\n };\n \n+#define TSAN_RUNTIME_VMA 1\n+\n #elif SANITIZER_GO && defined(__aarch64__)\n \n /* Go on linux/aarch64 (48-bit VMA)"}, {"sha": "368f1ca8adf2cb4b8eaa3dbbf8133b5f005f3848", "filename": "libsanitizer/tsan/tsan_report.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -298,7 +298,7 @@ static bool FrameIsInternal(const SymbolizedStack *frame) {\n   const char *file = frame->info.file;\n   const char *module = frame->info.module;\n   if (file != 0 &&\n-      (internal_strstr(file, \"tsan_interceptors.cpp\") ||\n+      (internal_strstr(file, \"tsan_interceptors_posix.cpp\") ||\n        internal_strstr(file, \"sanitizer_common_interceptors.inc\") ||\n        internal_strstr(file, \"tsan_interface_\")))\n     return true;"}, {"sha": "3f3c0cce119c13ff665599eeff14d8b564ea9e22", "filename": "libsanitizer/tsan/tsan_rtl.cpp", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_rtl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_rtl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -239,6 +239,15 @@ void DontNeedShadowFor(uptr addr, uptr size) {\n   ReleaseMemoryPagesToOS(MemToShadow(addr), MemToShadow(addr + size));\n }\n \n+#if !SANITIZER_GO\n+void UnmapShadow(ThreadState *thr, uptr addr, uptr size) {\n+  if (size == 0) return;\n+  DontNeedShadowFor(addr, size);\n+  ScopedGlobalProcessor sgp;\n+  ctx->metamap.ResetRange(thr->proc(), addr, size);\n+}\n+#endif\n+\n void MapShadow(uptr addr, uptr size) {\n   // Global data is not 64K aligned, but there are no adjacent mappings,\n   // so we can get away with unaligned mapping.\n@@ -329,7 +338,7 @@ static void CheckShadowMapping() {\n #if !SANITIZER_GO\n static void OnStackUnwind(const SignalContext &sig, const void *,\n                           BufferedStackTrace *stack) {\n-  stack->Unwind(sig.pc, sig.bp, sig.context,\n+  stack->Unwind(StackTrace::GetNextInstructionPc(sig.pc), sig.bp, sig.context,\n                 common_flags()->fast_unwind_on_fatal);\n }\n \n@@ -987,6 +996,14 @@ void MemoryRangeImitateWrite(ThreadState *thr, uptr pc, uptr addr, uptr size) {\n   MemoryRangeSet(thr, pc, addr, size, s.raw());\n }\n \n+void MemoryRangeImitateWriteOrResetRange(ThreadState *thr, uptr pc, uptr addr,\n+                                         uptr size) {\n+  if (thr->ignore_reads_and_writes == 0)\n+    MemoryRangeImitateWrite(thr, pc, addr, size);\n+  else\n+    MemoryResetRange(thr, pc, addr, size);\n+}\n+\n ALWAYS_INLINE USED\n void FuncEntry(ThreadState *thr, uptr pc) {\n   StatInc(thr, StatFuncEnter);"}, {"sha": "c38fc43a9f848726ae40562b3de465d0a0a1d4bf", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -238,7 +238,7 @@ class Shadow : public FastState {\n       unsigned kS2AccessSize) {\n     bool res = false;\n     u64 diff = s1.addr0() - s2.addr0();\n-    if ((s64)diff < 0) {  // s1.addr0 < s2.addr0  // NOLINT\n+    if ((s64)diff < 0) {  // s1.addr0 < s2.addr0\n       // if (s1.addr0() + size1) > s2.addr0()) return true;\n       if (s1.size() > -diff)\n         res = true;\n@@ -680,6 +680,7 @@ void ALWAYS_INLINE StatSet(ThreadState *thr, StatType typ, u64 n) {\n void MapShadow(uptr addr, uptr size);\n void MapThreadTrace(uptr addr, uptr size, const char *name);\n void DontNeedShadowFor(uptr addr, uptr size);\n+void UnmapShadow(ThreadState *thr, uptr addr, uptr size);\n void InitializeShadowMemory();\n void InitializeInterceptors();\n void InitializeLibIgnore();\n@@ -759,6 +760,8 @@ void ALWAYS_INLINE MemoryWriteAtomic(ThreadState *thr, uptr pc,\n void MemoryResetRange(ThreadState *thr, uptr pc, uptr addr, uptr size);\n void MemoryRangeFreed(ThreadState *thr, uptr pc, uptr addr, uptr size);\n void MemoryRangeImitateWrite(ThreadState *thr, uptr pc, uptr addr, uptr size);\n+void MemoryRangeImitateWriteOrResetRange(ThreadState *thr, uptr pc, uptr addr,\n+                                         uptr size);\n \n void ThreadIgnoreBegin(ThreadState *thr, uptr pc, bool save_stack = true);\n void ThreadIgnoreEnd(ThreadState *thr, uptr pc);"}, {"sha": "8285e21aa1ec7a797dfcf4840ee5a7851106b497", "filename": "libsanitizer/tsan/tsan_rtl_ppc64.S", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -1,6 +1,5 @@\n #include \"tsan_ppc_regs.h\"\n \n-        .machine altivec\n         .section .text\n         .hidden __tsan_setjmp\n         .globl _setjmp"}, {"sha": "949beac1c5513f712a11094d9442ef240a96f3e3", "filename": "libsanitizer/tsan/tsan_rtl_report.cpp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_rtl_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_rtl_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_report.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -27,7 +27,7 @@\n \n namespace __tsan {\n \n-using namespace __sanitizer;  // NOLINT\n+using namespace __sanitizer;\n \n static ReportStack *SymbolizeStack(StackTrace trace);\n \n@@ -154,6 +154,7 @@ ScopedReportBase::ScopedReportBase(ReportType typ, uptr tag) {\n ScopedReportBase::~ScopedReportBase() {\n   ctx->report_mtx.Unlock();\n   DestroyAndFree(rep_);\n+  rep_ = nullptr;\n }\n \n void ScopedReportBase::AddStack(StackTrace stack, bool suppressable) {\n@@ -700,7 +701,7 @@ void ReportRace(ThreadState *thr) {\n   rep.AddLocation(addr_min, addr_max - addr_min);\n \n #if !SANITIZER_GO\n-  {  // NOLINT\n+  {\n     Shadow s(thr->racy_state[1]);\n     if (s.epoch() <= thr->last_sleep_clock.get(s.tid()))\n       rep.AddSleep(thr->last_sleep_stack_id);"}, {"sha": "a1c1bf81bf670af8a103214dba6b89e4c8076c42", "filename": "libsanitizer/tsan/tsan_suppressions.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_suppressions.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Ftsan%2Ftsan_suppressions.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -50,7 +50,7 @@ static const char *kSuppressionTypes[] = {\n \n void InitializeSuppressions() {\n   CHECK_EQ(nullptr, suppression_ctx);\n-  suppression_ctx = new (suppression_placeholder) // NOLINT\n+  suppression_ctx = new (suppression_placeholder)\n       SuppressionContext(kSuppressionTypes, ARRAY_SIZE(kSuppressionTypes));\n   suppression_ctx->ParseFromFile(flags()->suppressions);\n #if !SANITIZER_GO"}, {"sha": "33a8dfcde0269a013f57e2a6b25b47f5ade7fd5b", "filename": "libsanitizer/ubsan/ubsan_checks.inc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fubsan%2Fubsan_checks.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fubsan%2Fubsan_checks.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_checks.inc?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -18,6 +18,11 @@\n \n UBSAN_CHECK(GenericUB, \"undefined-behavior\", \"undefined\")\n UBSAN_CHECK(NullPointerUse, \"null-pointer-use\", \"null\")\n+UBSAN_CHECK(NullptrWithOffset, \"nullptr-with-offset\", \"pointer-overflow\")\n+UBSAN_CHECK(NullptrWithNonZeroOffset, \"nullptr-with-nonzero-offset\",\n+            \"pointer-overflow\")\n+UBSAN_CHECK(NullptrAfterNonZeroOffset, \"nullptr-after-nonzero-offset\",\n+            \"pointer-overflow\")\n UBSAN_CHECK(PointerOverflow, \"pointer-overflow\", \"pointer-overflow\")\n UBSAN_CHECK(MisalignedPointerUse, \"misaligned-pointer-use\", \"alignment\")\n UBSAN_CHECK(AlignmentAssumption, \"alignment-assumption\", \"alignment\")"}, {"sha": "1b2828d236d6e977a0aec0673da2c890876629c3", "filename": "libsanitizer/ubsan/ubsan_diag.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fubsan%2Fubsan_diag.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fubsan%2Fubsan_diag.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -404,7 +404,7 @@ static const char *kSuppressionTypes[] = {\n \n void __ubsan::InitializeSuppressions() {\n   CHECK_EQ(nullptr, suppression_ctx);\n-  suppression_ctx = new (suppression_placeholder) // NOLINT\n+  suppression_ctx = new (suppression_placeholder)\n       SuppressionContext(kSuppressionTypes, ARRAY_SIZE(kSuppressionTypes));\n   suppression_ctx->ParseFromFile(flags()->suppressions);\n }"}, {"sha": "721c2273f133a3b4f7158b7e7297d7e9078eaffa", "filename": "libsanitizer/ubsan/ubsan_flags.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fubsan%2Fubsan_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fubsan%2Fubsan_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_flags.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -54,7 +54,6 @@ void InitializeFlags() {\n   {\n     CommonFlags cf;\n     cf.CopyFrom(*common_flags());\n-    cf.print_summary = false;\n     cf.external_symbolizer_path = GetFlag(\"UBSAN_SYMBOLIZER_PATH\");\n     OverrideCommonFlags(cf);\n   }"}, {"sha": "3f9da75a12a8d34386977ba9e959eda2af27f298", "filename": "libsanitizer/ubsan/ubsan_handlers.cpp", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fubsan%2Fubsan_handlers.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fubsan%2Fubsan_handlers.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -691,14 +691,33 @@ static void handlePointerOverflowImpl(PointerOverflowData *Data,\n                                       ValueHandle Result,\n                                       ReportOptions Opts) {\n   SourceLocation Loc = Data->Loc.acquire();\n-  ErrorType ET = ErrorType::PointerOverflow;\n+  ErrorType ET;\n+\n+  if (Base == 0 && Result == 0)\n+    ET = ErrorType::NullptrWithOffset;\n+  else if (Base == 0 && Result != 0)\n+    ET = ErrorType::NullptrWithNonZeroOffset;\n+  else if (Base != 0 && Result == 0)\n+    ET = ErrorType::NullptrAfterNonZeroOffset;\n+  else\n+    ET = ErrorType::PointerOverflow;\n \n   if (ignoreReport(Loc, Opts, ET))\n     return;\n \n   ScopedReport R(Opts, Loc, ET);\n \n-  if ((sptr(Base) >= 0) == (sptr(Result) >= 0)) {\n+  if (ET == ErrorType::NullptrWithOffset) {\n+    Diag(Loc, DL_Error, ET, \"applying zero offset to null pointer\");\n+  } else if (ET == ErrorType::NullptrWithNonZeroOffset) {\n+    Diag(Loc, DL_Error, ET, \"applying non-zero offset %0 to null pointer\")\n+        << Result;\n+  } else if (ET == ErrorType::NullptrAfterNonZeroOffset) {\n+    Diag(\n+        Loc, DL_Error, ET,\n+        \"applying non-zero offset to non-null pointer %0 produced null pointer\")\n+        << (void *)Base;\n+  } else if ((sptr(Base) >= 0) == (sptr(Result) >= 0)) {\n     if (Base > Result)\n       Diag(Loc, DL_Error, ET,\n            \"addition of unsigned offset to %0 overflowed to %1\")\n@@ -800,21 +819,6 @@ void __ubsan_handle_cfi_bad_type(CFICheckFailData *Data, ValueHandle Vtable,\n \n }  // namespace __ubsan\n \n-void __ubsan::__ubsan_handle_cfi_bad_icall(CFIBadIcallData *CallData,\n-                                           ValueHandle Function) {\n-  GET_REPORT_OPTIONS(false);\n-  CFICheckFailData Data = {CFITCK_ICall, CallData->Loc, CallData->Type};\n-  handleCFIBadIcall(&Data, Function, Opts);\n-}\n-\n-void __ubsan::__ubsan_handle_cfi_bad_icall_abort(CFIBadIcallData *CallData,\n-                                                 ValueHandle Function) {\n-  GET_REPORT_OPTIONS(true);\n-  CFICheckFailData Data = {CFITCK_ICall, CallData->Loc, CallData->Type};\n-  handleCFIBadIcall(&Data, Function, Opts);\n-  Die();\n-}\n-\n void __ubsan::__ubsan_handle_cfi_check_fail(CFICheckFailData *Data,\n                                             ValueHandle Value,\n                                             uptr ValidVtable) {"}, {"sha": "22ca96422381c104798588f64c5ae370f3ef2f07", "filename": "libsanitizer/ubsan/ubsan_handlers.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fubsan%2Fubsan_handlers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fubsan%2Fubsan_handlers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -207,20 +207,12 @@ enum CFITypeCheckKind : unsigned char {\n   CFITCK_VMFCall,\n };\n \n-struct CFIBadIcallData {\n-  SourceLocation Loc;\n-  const TypeDescriptor &Type;\n-};\n-\n struct CFICheckFailData {\n   CFITypeCheckKind CheckKind;\n   SourceLocation Loc;\n   const TypeDescriptor &Type;\n };\n \n-/// \\brief Handle control flow integrity failure for indirect function calls.\n-RECOVERABLE(cfi_bad_icall, CFIBadIcallData *Data, ValueHandle Function)\n-\n /// \\brief Handle control flow integrity failures.\n RECOVERABLE(cfi_check_fail, CFICheckFailData *Data, ValueHandle Function,\n             uptr VtableIsValid)"}, {"sha": "71d7fb18c9b3a5e94039e3843113050f31fa1c9f", "filename": "libsanitizer/ubsan/ubsan_platform.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fubsan%2Fubsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fubsan%2Fubsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_platform.h?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -12,7 +12,6 @@\n #ifndef UBSAN_PLATFORM_H\n #define UBSAN_PLATFORM_H\n \n-#ifndef CAN_SANITIZE_UB\n // Other platforms should be easy to add, and probably work as-is.\n #if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__) ||        \\\n     defined(__NetBSD__) || defined(__OpenBSD__) || \\\n@@ -22,6 +21,5 @@\n #else\n # define CAN_SANITIZE_UB 0\n #endif\n-#endif //CAN_SANITIZE_UB\n \n #endif"}, {"sha": "2c91db8ca3974841a2314b86a97b6d259c9e0d9c", "filename": "libsanitizer/ubsan/ubsan_signals_standalone.cpp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fubsan%2Fubsan_signals_standalone.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8/libsanitizer%2Fubsan%2Fubsan_signals_standalone.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_signals_standalone.cpp?ref=3ca75cd55030a53a858bdbe9aba6d87f6b1e90b8", "patch": "@@ -45,8 +45,9 @@ namespace __ubsan {\n \n static void OnStackUnwind(const SignalContext &sig, const void *,\n                           BufferedStackTrace *stack) {\n-  ubsan_GetStackTrace(stack, kStackTraceMax, sig.pc, sig.bp, sig.context,\n-                common_flags()->fast_unwind_on_fatal);\n+  ubsan_GetStackTrace(stack, kStackTraceMax,\n+                      StackTrace::GetNextInstructionPc(sig.pc), sig.bp,\n+                      sig.context, common_flags()->fast_unwind_on_fatal);\n }\n \n static void UBsanOnDeadlySignal(int signo, void *siginfo, void *context) {"}]}