{"sha": "fa4586d8545f9730f9acdba8978b69f7cc026bb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE0NTg2ZDg1NDVmOTczMGY5YWNkYmE4OTc4YjY5ZjdjYzAyNmJiNg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-01-08T13:28:29Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-01-11T08:18:28Z"}, "message": "if-to-switch: remove memory leaks\n\ngcc/ChangeLog:\n\n\t* gimple-if-to-switch.cc (struct condition_info): Use auto_var.\n\t(if_chain::is_beneficial): Delete clusters\n\t(find_conditions): Make second argument of conditions_in_bbs a\n\tpointer so that we control over it's lifetime.\n\t(pass_if_to_switch::execute): Delete them.", "tree": {"sha": "99001aa04b3bab35cf46e64cf92debd6890046f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99001aa04b3bab35cf46e64cf92debd6890046f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa4586d8545f9730f9acdba8978b69f7cc026bb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa4586d8545f9730f9acdba8978b69f7cc026bb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa4586d8545f9730f9acdba8978b69f7cc026bb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa4586d8545f9730f9acdba8978b69f7cc026bb6/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcb3065b2ba6efb967c3a34fc34b09726f7579d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcb3065b2ba6efb967c3a34fc34b09726f7579d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcb3065b2ba6efb967c3a34fc34b09726f7579d1"}], "stats": {"total": 97, "additions": 56, "deletions": 41}, "files": [{"sha": "560753d0311850cea893f4680493bd46a7767c3f", "filename": "gcc/gimple-if-to-switch.cc", "status": "modified", "additions": 56, "deletions": 41, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4586d8545f9730f9acdba8978b69f7cc026bb6/gcc%2Fgimple-if-to-switch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4586d8545f9730f9acdba8978b69f7cc026bb6/gcc%2Fgimple-if-to-switch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-if-to-switch.cc?ref=fa4586d8545f9730f9acdba8978b69f7cc026bb6", "patch": "@@ -59,7 +59,7 @@ using namespace tree_switch_conversion;\n \n struct condition_info\n {\n-  typedef vec<std::pair<gphi *, tree>> mapping_vec;\n+  typedef auto_vec<std::pair<gphi *, tree>> mapping_vec;\n \n   condition_info (gcond *cond): m_cond (cond), m_bb (gimple_bb (cond)),\n     m_forwarder_bb (NULL), m_ranges (), m_true_edge (NULL), m_false_edge (NULL),\n@@ -75,7 +75,7 @@ struct condition_info\n   gcond *m_cond;\n   basic_block m_bb;\n   basic_block m_forwarder_bb;\n-  vec<range_entry> m_ranges;\n+  auto_vec<range_entry> m_ranges;\n   edge m_true_edge;\n   edge m_false_edge;\n   mapping_vec m_true_edge_phi_mapping;\n@@ -253,6 +253,10 @@ if_chain::is_beneficial ()\n   r = output.length () < filtered_clusters.length ();\n   if (r)\n     dump_clusters (&output, \"BT can be built\");\n+\n+  for (unsigned i = 0; i < output.length (); i++)\n+    delete output[i];\n+\n   output.release ();\n   return r;\n }\n@@ -377,7 +381,7 @@ convert_if_conditions_to_switch (if_chain *chain)\n \n static void\n find_conditions (basic_block bb,\n-\t\t hash_map<basic_block, condition_info> *conditions_in_bbs)\n+\t\t hash_map<basic_block, condition_info *> *conditions_in_bbs)\n {\n   gimple_stmt_iterator gsi = gsi_last_nondebug_bb (bb);\n   if (gsi_end_p (gsi))\n@@ -394,7 +398,7 @@ find_conditions (basic_block bb,\n   tree rhs = gimple_cond_rhs (cond);\n   tree_code code = gimple_cond_code (cond);\n \n-  condition_info info (cond);\n+  condition_info *info = new condition_info (cond);\n \n   gassign *def;\n   if (code == NE_EXPR\n@@ -405,49 +409,53 @@ find_conditions (basic_block bb,\n       enum tree_code rhs_code = gimple_assign_rhs_code (def);\n       if (rhs_code == BIT_IOR_EXPR)\n \t{\n-\t  info.m_ranges.safe_grow (2, true);\n-\t  init_range_entry (&info.m_ranges[0], gimple_assign_rhs1 (def), NULL);\n-\t  init_range_entry (&info.m_ranges[1], gimple_assign_rhs2 (def), NULL);\n+\t  info->m_ranges.safe_grow (2, true);\n+\t  init_range_entry (&info->m_ranges[0], gimple_assign_rhs1 (def), NULL);\n+\t  init_range_entry (&info->m_ranges[1], gimple_assign_rhs2 (def), NULL);\n \t}\n     }\n   else\n     {\n-      info.m_ranges.safe_grow (1, true);\n-      init_range_entry (&info.m_ranges[0], NULL_TREE, cond);\n+      info->m_ranges.safe_grow (1, true);\n+      init_range_entry (&info->m_ranges[0], NULL_TREE, cond);\n     }\n \n   /* All identified ranges must have equal expression and IN_P flag.  */\n-  if (!info.m_ranges.is_empty ())\n+  if (!info->m_ranges.is_empty ())\n     {\n       edge true_edge, false_edge;\n-      tree expr = info.m_ranges[0].exp;\n-      bool in_p = info.m_ranges[0].in_p;\n+      tree expr = info->m_ranges[0].exp;\n+      bool in_p = info->m_ranges[0].in_p;\n \n       extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n-      info.m_true_edge = in_p ? true_edge : false_edge;\n-      info.m_false_edge = in_p ? false_edge : true_edge;\n-\n-      for (unsigned i = 0; i < info.m_ranges.length (); ++i)\n-\tif (info.m_ranges[i].exp == NULL_TREE\n-\t    || !INTEGRAL_TYPE_P (TREE_TYPE (info.m_ranges[i].exp))\n-\t    || info.m_ranges[i].low == NULL_TREE\n-\t    || info.m_ranges[i].high == NULL_TREE\n-\t    || (TYPE_PRECISION (TREE_TYPE (info.m_ranges[i].low))\n-\t\t!= TYPE_PRECISION (TREE_TYPE (info.m_ranges[i].high))))\n-\t  return;\n-\n-      for (unsigned i = 1; i < info.m_ranges.length (); ++i)\n-\tif (info.m_ranges[i].exp != expr\n-\t    || info.m_ranges[i].in_p != in_p)\n-\t  return;\n-\n-      info.record_phi_mapping (info.m_true_edge,\n-\t\t\t       &info.m_true_edge_phi_mapping);\n-      info.record_phi_mapping (info.m_false_edge,\n-\t\t\t       &info.m_false_edge_phi_mapping);\n+      info->m_true_edge = in_p ? true_edge : false_edge;\n+      info->m_false_edge = in_p ? false_edge : true_edge;\n+\n+      for (unsigned i = 0; i < info->m_ranges.length (); ++i)\n+\tif (info->m_ranges[i].exp == NULL_TREE\n+\t    || !INTEGRAL_TYPE_P (TREE_TYPE (info->m_ranges[i].exp))\n+\t    || info->m_ranges[i].low == NULL_TREE\n+\t    || info->m_ranges[i].high == NULL_TREE\n+\t    || (TYPE_PRECISION (TREE_TYPE (info->m_ranges[i].low))\n+\t\t!= TYPE_PRECISION (TREE_TYPE (info->m_ranges[i].high))))\n+\t  goto exit;\n+\n+      for (unsigned i = 1; i < info->m_ranges.length (); ++i)\n+\tif (info->m_ranges[i].exp != expr\n+\t    || info->m_ranges[i].in_p != in_p)\n+\t  goto exit;\n+\n+      info->record_phi_mapping (info->m_true_edge,\n+\t\t\t\t&info->m_true_edge_phi_mapping);\n+      info->record_phi_mapping (info->m_false_edge,\n+\t\t\t\t&info->m_false_edge_phi_mapping);\n       conditions_in_bbs->put (bb, info);\n     }\n \n+  return;\n+\n+exit:\n+  delete info;\n }\n \n namespace {\n@@ -487,7 +495,7 @@ unsigned int\n pass_if_to_switch::execute (function *fun)\n {\n   auto_vec<if_chain *> all_candidates;\n-  hash_map<basic_block, condition_info> conditions_in_bbs;\n+  hash_map<basic_block, condition_info *> conditions_in_bbs;\n \n   basic_block bb;\n   FOR_EACH_BB_FN (bb, fun)\n@@ -507,9 +515,10 @@ pass_if_to_switch::execute (function *fun)\n \tcontinue;\n \n       bitmap_set_bit (seen_bbs, bb->index);\n-      condition_info *info = conditions_in_bbs.get (bb);\n-      if (info)\n+      condition_info **slot = conditions_in_bbs.get (bb);\n+      if (slot)\n \t{\n+\t  condition_info *info = *slot;\n \t  if_chain *chain = new if_chain ();\n \t  chain->m_entries.safe_push (info);\n \t  /* Try to find a chain starting in this BB.  */\n@@ -518,19 +527,19 @@ pass_if_to_switch::execute (function *fun)\n \t      if (!single_pred_p (gimple_bb (info->m_cond)))\n \t\tbreak;\n \t      edge e = single_pred_edge (gimple_bb (info->m_cond));\n-\t      condition_info *info2 = conditions_in_bbs.get (e->src);\n-\t      if (!info2 || info->m_ranges[0].exp != info2->m_ranges[0].exp)\n+\t      condition_info **info2 = conditions_in_bbs.get (e->src);\n+\t      if (!info2 || info->m_ranges[0].exp != (*info2)->m_ranges[0].exp)\n \t\tbreak;\n \n \t      /* It is important that the blocks are linked through FALSE_EDGE.\n \t\t For an expression of index != VALUE, true and false edges\n \t\t are flipped.  */\n-\t      if (info2->m_false_edge != e)\n+\t      if ((*info2)->m_false_edge != e)\n \t\tbreak;\n \n-\t      chain->m_entries.safe_push (info2);\n+\t      chain->m_entries.safe_push (*info2);\n \t      bitmap_set_bit (seen_bbs, e->src->index);\n-\t      info = info2;\n+\t      info = *info2;\n \t    }\n \n \t  chain->m_entries.reverse ();\n@@ -546,6 +555,8 @@ pass_if_to_switch::execute (function *fun)\n \t\t\t\t chain->m_entries.length ());\n \t      all_candidates.safe_push (chain);\n \t    }\n+\t  else\n+\t    delete chain;\n \t}\n     }\n \n@@ -557,6 +568,10 @@ pass_if_to_switch::execute (function *fun)\n \n   free (rpo);\n \n+  for (hash_map<basic_block, condition_info *>::iterator it\n+       = conditions_in_bbs.begin (); it != conditions_in_bbs.end (); ++it)\n+    delete (*it).second;\n+\n   if (!all_candidates.is_empty ())\n     {\n       free_dominance_info (CDI_DOMINATORS);"}]}