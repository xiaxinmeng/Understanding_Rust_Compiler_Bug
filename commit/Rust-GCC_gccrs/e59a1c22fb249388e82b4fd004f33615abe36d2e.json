{"sha": "e59a1c22fb249388e82b4fd004f33615abe36d2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU5YTFjMjJmYjI0OTM4OGU4MmI0ZmQwMDRmMzM2MTVhYmUzNmQyZQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-06-21T12:51:46Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-06-21T12:51:46Z"}, "message": "Make early return predictor more precise.\n\n2017-06-21  Martin Liska  <mliska@suse.cz>\n\n\tPR tree-optimization/79489\n\t* gimplify.c (maybe_add_early_return_predict_stmt): New\n\tfunction.\n\t(gimplify_return_expr): Call the function.\n\t* predict.c (tree_estimate_probability_bb): Remove handling\n\tof early return.\n\t* predict.def: Update comment about early return predictor.\n\t* gimple-predict.h (is_gimple_predict): New function.\n\t* predict.def: Change default value of early return to 66.\n\t* tree-tailcall.c (find_tail_calls): Skip GIMPLE_PREDICT\n\tstatements.\n\t* passes.def: Put pass_strip_predict_hints to the beginning of\n\tIPA passes.\n\nFrom-SVN: r249450", "tree": {"sha": "0ba9b3f978dc6746d354dccdfb340b58bb47cbfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ba9b3f978dc6746d354dccdfb340b58bb47cbfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e59a1c22fb249388e82b4fd004f33615abe36d2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e59a1c22fb249388e82b4fd004f33615abe36d2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e59a1c22fb249388e82b4fd004f33615abe36d2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e59a1c22fb249388e82b4fd004f33615abe36d2e/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ff9baa5f1c532a43d7d14a800f5a4a5c5757dca6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff9baa5f1c532a43d7d14a800f5a4a5c5757dca6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff9baa5f1c532a43d7d14a800f5a4a5c5757dca6"}], "stats": {"total": 101, "additions": 48, "deletions": 53}, "files": [{"sha": "12d0ee8a85ccc0718e6e50fa4c57e76b1eefe5d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59a1c22fb249388e82b4fd004f33615abe36d2e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59a1c22fb249388e82b4fd004f33615abe36d2e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e59a1c22fb249388e82b4fd004f33615abe36d2e", "patch": "@@ -1,3 +1,19 @@\n+2017-06-21  Martin Liska  <mliska@suse.cz>\n+\n+\tPR tree-optimization/79489\n+\t* gimplify.c (maybe_add_early_return_predict_stmt): New\n+\tfunction.\n+\t(gimplify_return_expr): Call the function.\n+\t* predict.c (tree_estimate_probability_bb): Remove handling\n+\tof early return.\n+\t* predict.def: Update comment about early return predictor.\n+\t* gimple-predict.h (is_gimple_predict): New function.\n+\t* predict.def: Change default value of early return to 66.\n+\t* tree-tailcall.c (find_tail_calls): Skip GIMPLE_PREDICT\n+\tstatements.\n+\t* passes.def: Put pass_strip_predict_hints to the beginning of\n+\tIPA passes.\n+\n 2017-06-21  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \t* dwarf2out.c (gen_decl_die): Remove the guard to skip file-scope"}, {"sha": "4ea6c3532f3fddaf862865d6f46b9c2de0ba6c0f", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59a1c22fb249388e82b4fd004f33615abe36d2e/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59a1c22fb249388e82b4fd004f33615abe36d2e/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=e59a1c22fb249388e82b4fd004f33615abe36d2e", "patch": "@@ -30,6 +30,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"calls.h\"\n #include \"gimple-iterator.h\"\n #include \"gimple-low.h\"\n+#include \"predict.h\"\n+#include \"gimple-predict.h\"\n \n /* The differences between High GIMPLE and Low GIMPLE are the\n    following:"}, {"sha": "0e6c2e1ea019f640f3163f2b10e0b5be71c711b2", "filename": "gcc/gimple-predict.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59a1c22fb249388e82b4fd004f33615abe36d2e/gcc%2Fgimple-predict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59a1c22fb249388e82b4fd004f33615abe36d2e/gcc%2Fgimple-predict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predict.h?ref=e59a1c22fb249388e82b4fd004f33615abe36d2e", "patch": "@@ -80,4 +80,12 @@ gimple_build_predict (enum br_predictor predictor, enum prediction outcome)\n   return p;\n }\n \n+/* Return true if GS is a GIMPLE_PREDICT statement.  */\n+\n+static inline bool\n+is_gimple_predict (const gimple *gs)\n+{\n+  return gimple_code (gs) == GIMPLE_PREDICT;\n+}\n+\n #endif  /* GCC_GIMPLE_PREDICT_H */"}, {"sha": "c645bcec9e680f243ef6c8649501e8b9773fb2b1", "filename": "gcc/gimplify.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59a1c22fb249388e82b4fd004f33615abe36d2e/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59a1c22fb249388e82b4fd004f33615abe36d2e/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=e59a1c22fb249388e82b4fd004f33615abe36d2e", "patch": "@@ -1428,6 +1428,20 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n   return GS_ALL_DONE;\n }\n \n+/* Maybe add early return predict statement to PRE_P sequence.  */\n+\n+static void\n+maybe_add_early_return_predict_stmt (gimple_seq *pre_p)\n+{\n+  /* If we are not in a conditional context, add PREDICT statement.  */\n+  if (gimple_conditional_context ())\n+    {\n+      gimple *predict = gimple_build_predict (PRED_TREE_EARLY_RETURN,\n+\t\t\t\t\t      NOT_TAKEN);\n+      gimplify_seq_add_stmt (pre_p, predict);\n+    }\n+}\n+\n /* Gimplify a RETURN_EXPR.  If the expression to be returned is not a\n    GIMPLE value, it is assigned to a new temporary and the statement is\n    re-written to return the temporary.\n@@ -1458,6 +1472,7 @@ gimplify_return_expr (tree stmt, gimple_seq *pre_p)\n       || TREE_CODE (ret_expr) == RESULT_DECL\n       || ret_expr == error_mark_node)\n     {\n+      maybe_add_early_return_predict_stmt (pre_p);\n       greturn *ret = gimple_build_return (ret_expr);\n       gimple_set_no_warning (ret, TREE_NO_WARNING (stmt));\n       gimplify_seq_add_stmt (pre_p, ret);\n@@ -1525,6 +1540,7 @@ gimplify_return_expr (tree stmt, gimple_seq *pre_p)\n \n   gimplify_and_add (TREE_OPERAND (stmt, 0), pre_p);\n \n+  maybe_add_early_return_predict_stmt (pre_p);\n   ret = gimple_build_return (result);\n   gimple_set_no_warning (ret, TREE_NO_WARNING (stmt));\n   gimplify_seq_add_stmt (pre_p, ret);"}, {"sha": "316e19d12e317cbf8d852155b93ce37fe5c78e9b", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59a1c22fb249388e82b4fd004f33615abe36d2e/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59a1c22fb249388e82b4fd004f33615abe36d2e/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=e59a1c22fb249388e82b4fd004f33615abe36d2e", "patch": "@@ -107,6 +107,7 @@ along with GCC; see the file COPYING3.  If not see\n \t     early optimizations again.  It is thus good idea to do this\n \t      late.  */\n \t  NEXT_PASS (pass_split_functions);\n+\t  NEXT_PASS (pass_strip_predict_hints);\n       POP_INSERT_PASSES ()\n       NEXT_PASS (pass_release_ssa_names);\n       NEXT_PASS (pass_rebuild_cgraph_edges);"}, {"sha": "790be9fbf16d57c639282c2c0e67f04a74c03b1e", "filename": "gcc/predict.c", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59a1c22fb249388e82b4fd004f33615abe36d2e/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59a1c22fb249388e82b4fd004f33615abe36d2e/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=e59a1c22fb249388e82b4fd004f33615abe36d2e", "patch": "@@ -2739,7 +2739,6 @@ tree_estimate_probability_bb (basic_block bb, bool local_only)\n {\n   edge e;\n   edge_iterator ei;\n-  gimple *last;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n@@ -2766,46 +2765,6 @@ tree_estimate_probability_bb (basic_block bb, bool local_only)\n \t    }\n \t}\n \n-      /* Predict early returns to be probable, as we've already taken\n-\t care for error returns and other cases are often used for\n-\t fast paths through function.\n-\n-\t Since we've already removed the return statements, we are\n-\t looking for CFG like:\n-\n-\t if (conditional)\n-\t {\n-\t ..\n-\t goto return_block\n-\t }\n-\t some other blocks\n-\t return_block:\n-\t return_stmt.  */\n-      if (e->dest != bb->next_bb\n-\t  && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n-\t  && single_succ_p (e->dest)\n-\t  && single_succ_edge (e->dest)->dest == EXIT_BLOCK_PTR_FOR_FN (cfun)\n-\t  && (last = last_stmt (e->dest)) != NULL\n-\t  && gimple_code (last) == GIMPLE_RETURN)\n-\t{\n-\t  edge e1;\n-\t  edge_iterator ei1;\n-\n-\t  if (single_succ_p (bb))\n-\t    {\n-\t      FOR_EACH_EDGE (e1, ei1, bb->preds)\n-\t\tif (!predicted_by_p (e1->src, PRED_NULL_RETURN)\n-\t\t    && !predicted_by_p (e1->src, PRED_CONST_RETURN)\n-\t\t    && !predicted_by_p (e1->src, PRED_NEGATIVE_RETURN))\n-\t\t  predict_edge_def (e1, PRED_TREE_EARLY_RETURN, NOT_TAKEN);\n-\t    }\n-\t  else\n-\t    if (!predicted_by_p (e->src, PRED_NULL_RETURN)\n-\t\t&& !predicted_by_p (e->src, PRED_CONST_RETURN)\n-\t\t&& !predicted_by_p (e->src, PRED_NEGATIVE_RETURN))\n-\t      predict_edge_def (e, PRED_TREE_EARLY_RETURN, NOT_TAKEN);\n-\t}\n-\n       /* Look for block we are guarding (ie we dominate it,\n \t but it doesn't postdominate us).  */\n       if (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun) && e->dest != bb"}, {"sha": "f7b2bf7738c1bbfeea6ec5b9cef1002ccb3c3640", "filename": "gcc/predict.def", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59a1c22fb249388e82b4fd004f33615abe36d2e/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59a1c22fb249388e82b4fd004f33615abe36d2e/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=e59a1c22fb249388e82b4fd004f33615abe36d2e", "patch": "@@ -128,18 +128,9 @@ DEF_PREDICTOR (PRED_POLYMORPHIC_CALL, \"polymorphic call\", HITRATE (59), 0)\n    indefinitely.  */\n DEF_PREDICTOR (PRED_RECURSIVE_CALL, \"recursive call\", HITRATE (75), 0)\n \n-/* Branch causing function to terminate is probably not taken. \n-   FIXME: early return currently predicts code:\n-   int foo (int a)\n-   {\n-      if (a)\n-\tbar();\n-      else\n-\tbar2();\n-   }\n-   even though there is no return statement involved.  We probably want to track\n-   this from FE or retire the predictor.  */\n-DEF_PREDICTOR (PRED_TREE_EARLY_RETURN, \"early return (on trees)\", HITRATE (54), 0)\n+/* Branch causing function to terminate is probably not taken.  */\n+DEF_PREDICTOR (PRED_TREE_EARLY_RETURN, \"early return (on trees)\", HITRATE (66),\n+\t       0)\n \n /* Branch containing goto is probably not taken.\n    FIXME: Currently not used.  */"}, {"sha": "6aa9a56462e57c4edf7d1a70eae1ffe57e04683e", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59a1c22fb249388e82b4fd004f33615abe36d2e/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59a1c22fb249388e82b4fd004f33615abe36d2e/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=e59a1c22fb249388e82b4fd004f33615abe36d2e", "patch": "@@ -421,6 +421,7 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n       if (gimple_code (stmt) == GIMPLE_LABEL\n \t  || gimple_code (stmt) == GIMPLE_RETURN\n \t  || gimple_code (stmt) == GIMPLE_NOP\n+\t  || gimple_code (stmt) == GIMPLE_PREDICT\n \t  || gimple_clobber_p (stmt)\n \t  || is_gimple_debug (stmt))\n \tcontinue;\n@@ -555,6 +556,7 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n \n       if (gimple_code (stmt) == GIMPLE_LABEL\n \t  || gimple_code (stmt) == GIMPLE_NOP\n+\t  || gimple_code (stmt) == GIMPLE_PREDICT\n \t  || gimple_clobber_p (stmt)\n \t  || is_gimple_debug (stmt))\n \tcontinue;"}]}