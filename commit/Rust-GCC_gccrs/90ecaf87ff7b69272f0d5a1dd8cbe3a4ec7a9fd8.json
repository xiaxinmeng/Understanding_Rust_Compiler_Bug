{"sha": "90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBlY2FmODdmZjdiNjkyNzJmMGQ1YTFkZDhjYmUzYTRlYzdhOWZkOA==", "commit": {"author": {"name": "Rodrigo Rivas Costa", "email": "rodrigorivascosta@gmail.com", "date": "2010-10-26T04:56:45Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-10-26T04:56:45Z"}, "message": "Implement opaque-enum-specifiers for C++0x.\n\ngcc/\n\t* tree.h (ENUM_IS_OPAQUE): New.\n\t* dwarf2out.c (gen_enumeration_type_die): Use ENUM_IS_OPAQUE.\ngcc/cp/\n\t* cp-tree.h (SET_OPAQUE_ENUM_P): New.\n\t(OPAQUE_ENUM_P): New.\n\t(ENUM_FIXED_UNDERLYING_TYPE_P): New.\n\t(start_enum): Update prototype.\n\t(finish_enum_value_list): New prototype.\n\t* parser.c (cp_parser_elaborated_type_specifier): Issue a pedwarn if\n\t\"enum class\" is used in an elaborated-type-specifier.\n\t(cp_parser_enum_specifier): Rewrite to parse opaque-enum-specifiers.\n\t* decl.c (copy_type_enum): New.\n\t(finish_enum_value_list): New, with code from finish_enum.\n\t(finish_enum): A lot of code removed. Added a gcc_assert.\n\t(start_enum): Add parameters enumtype and is_new.\n\tRewrite to work with opaque-enum-specifiers.\n\t* pt.c (maybe_process_partial_specialization): Allow for template\n\tspecialization of enumerations, with a pedwarn.\n\t(lookup_template_class): Update call to start_enum. Call to\n\tSET_OPAQUE_ENUM_P.\n\t(tsubst_enum): Call to begin_scope, finish_scope and\n\tfinish_enum_value_list.\n\nFrom-SVN: r165935", "tree": {"sha": "1bab3384ca044b2ac3dc7a0b9b2dbbbc8399e741", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bab3384ca044b2ac3dc7a0b9b2dbbbc8399e741"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/comments", "author": {"login": "rodrigorc", "id": 1128630, "node_id": "MDQ6VXNlcjExMjg2MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1128630?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rodrigorc", "html_url": "https://github.com/rodrigorc", "followers_url": "https://api.github.com/users/rodrigorc/followers", "following_url": "https://api.github.com/users/rodrigorc/following{/other_user}", "gists_url": "https://api.github.com/users/rodrigorc/gists{/gist_id}", "starred_url": "https://api.github.com/users/rodrigorc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rodrigorc/subscriptions", "organizations_url": "https://api.github.com/users/rodrigorc/orgs", "repos_url": "https://api.github.com/users/rodrigorc/repos", "events_url": "https://api.github.com/users/rodrigorc/events{/privacy}", "received_events_url": "https://api.github.com/users/rodrigorc/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f5c88dbfe7040583158ad45e4ef2801401a2732d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5c88dbfe7040583158ad45e4ef2801401a2732d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5c88dbfe7040583158ad45e4ef2801401a2732d"}], "stats": {"total": 1006, "additions": 853, "deletions": 153}, "files": [{"sha": "949fb10503e6f04ed2766ed16b48709249dd9f22", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -1,3 +1,9 @@\n+2010-10-25  Rodrigo Rivas Costa <rodrigorivascosta@gmail.com>\n+\n+\tImplement opaque-enum-specifiesr for C++0x\n+\t* tree.h (ENUM_IS_OPAQUE): New.\n+\t* dwarf2out.c (gen_enumeration_type_die): Use ENUM_IS_OPAQUE.\n+\n 2010-10-26  Jie Zhang  <jie@codesourcery.com>\n \n \t* stor-layout.c (layout_decl): Use the field's type to"}, {"sha": "5061af2a5ab0faea24eb93602236a9d692349811", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -1,3 +1,26 @@\n+2010-10-25  Rodrigo Rivas Costa <rodrigorivascosta@gmail.com>\n+\n+\tImplement opaque-enum-specifiers for C++0x.\n+\t* cp-tree.h (SET_OPAQUE_ENUM_P): New.\n+\t(OPAQUE_ENUM_P): New.\n+\t(ENUM_FIXED_UNDERLYING_TYPE_P): New.\n+\t(start_enum): Update prototype.\n+\t(finish_enum_value_list): New prototype.\n+\t* parser.c (cp_parser_elaborated_type_specifier): Issue a pedwarn if\n+\t\"enum class\" is used in an elaborated-type-specifier.\n+\t(cp_parser_enum_specifier): Rewrite to parse opaque-enum-specifiers.\n+\t* decl.c (copy_type_enum): New.\n+\t(finish_enum_value_list): New, with code from finish_enum.\n+\t(finish_enum): A lot of code removed. Added a gcc_assert.\n+\t(start_enum): Add parameters enumtype and is_new.\n+\tRewrite to work with opaque-enum-specifiers.\n+\t* pt.c (maybe_process_partial_specialization): Allow for template\n+\tspecialization of enumerations, with a pedwarn.\n+\t(lookup_template_class): Update call to start_enum. Call to\n+\tSET_OPAQUE_ENUM_P.\n+\t(tsubst_enum): Call to begin_scope, finish_scope and\n+\tfinish_enum_value_list.\n+\n 2010-10-24  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tRemoved Objective-C++ specific replacement of cxx_printable_name."}, {"sha": "da839eca7f9f4f052feeba9b7b73796fc57ca0e2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -3101,6 +3101,16 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define SET_SCOPED_ENUM_P(TYPE, VAL)                    \\\n   (ENUM_IS_SCOPED (TYPE) = (VAL))\n \n+#define SET_OPAQUE_ENUM_P(TYPE, VAL)                    \\\n+  (ENUM_IS_OPAQUE (TYPE) = (VAL))\n+\n+#define OPAQUE_ENUM_P(TYPE)\t\t\t\t\\\n+  (TREE_CODE (TYPE) == ENUMERAL_TYPE && ENUM_IS_OPAQUE (TYPE))\n+\n+/* Determines whether an ENUMERAL_TYPE has an explicit\n+   underlying type.  */\n+#define ENUM_FIXED_UNDERLYING_TYPE_P(NODE) (TYPE_LANG_FLAG_3 (NODE))\n+\n /* Returns the underlying type of the given enumeration type. The\n    underlying type is determined in different ways, depending on the\n    properties of the enum:\n@@ -4785,7 +4795,8 @@ extern bool grok_op_properties\t\t\t(tree, bool);\n extern tree xref_tag\t\t\t\t(enum tag_types, tree, tag_scope, bool);\n extern tree xref_tag_from_type\t\t\t(tree, tree, tag_scope);\n extern bool xref_basetypes\t\t\t(tree, tree);\n-extern tree start_enum\t\t\t\t(tree, tree, bool);\n+extern tree start_enum\t\t\t\t(tree, tree, tree, bool, bool *);\n+extern void finish_enum_value_list\t\t(tree);\n extern void finish_enum\t\t\t\t(tree);\n extern void build_enumerator\t\t\t(tree, tree, tree, location_t);\n extern tree lookup_enumerator\t\t\t(tree, tree);"}, {"sha": "14093307a5c2146e4faa1240dc490e4ddb601bc0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 160, "deletions": 102, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -92,6 +92,7 @@ static void layout_var_decl (tree);\n static tree check_initializer (tree, tree, int, tree *);\n static void make_rtl_for_nonlocal_decl (tree, tree, const char *);\n static void save_function_data (tree);\n+static void copy_type_enum (tree , tree);\n static void check_function_type (tree, tree);\n static void finish_constructor_body (void);\n static void begin_destructor_body (void);\n@@ -11309,106 +11310,172 @@ xref_basetypes (tree ref, tree base_list)\n }\n \n \f\n+/* Copies the enum-related properties from type SRC to type DST.\n+   Used with the underlying type of an enum and the enum itself.  */\n+static void\n+copy_type_enum (tree dst, tree src)\n+{\n+  TYPE_MIN_VALUE (dst) = TYPE_MIN_VALUE (src);\n+  TYPE_MAX_VALUE (dst) = TYPE_MAX_VALUE (src);\n+  TYPE_SIZE (dst) = TYPE_SIZE (src);\n+  TYPE_SIZE_UNIT (dst) = TYPE_SIZE_UNIT (src);\n+  SET_TYPE_MODE (dst, TYPE_MODE (src));\n+  TYPE_PRECISION (dst) = TYPE_PRECISION (src);\n+  TYPE_ALIGN (dst) = TYPE_ALIGN (src);\n+  TYPE_USER_ALIGN (dst) = TYPE_USER_ALIGN (src);\n+  TYPE_UNSIGNED (dst) = TYPE_UNSIGNED (src);\n+}\n+\n /* Begin compiling the definition of an enumeration type.\n    NAME is its name, \n \n+   if ENUMTYPE is not NULL_TREE then the type has alredy been found.\n+\n    UNDERLYING_TYPE is the type that will be used as the storage for\n    the enumeration type. This should be NULL_TREE if no storage type\n    was specified.\n \n    SCOPED_ENUM_P is true if this is a scoped enumeration type.\n \n+   if IS_NEW is not NULL, gets TRUE iff a new type is created.\n+\n    Returns the type object, as yet incomplete.\n    Also records info about it so that build_enumerator\n    may be used to declare the individual values as they are read.  */\n \n tree\n-start_enum (tree name, tree underlying_type, bool scoped_enum_p)\n+start_enum (tree name, tree enumtype, tree underlying_type,\n+\t    bool scoped_enum_p, bool *is_new)\n {\n-  tree enumtype;\n-\n+  tree prevtype = NULL_TREE;\n   gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n \n+  if (is_new)\n+    *is_new = false;\n+  /* [C++0x dcl.enum]p5:\n+\n+    If not explicitly specified, the underlying type of a scoped\n+    enumeration type is int.  */\n+  if (!underlying_type && scoped_enum_p)\n+    underlying_type = integer_type_node;\n+\n+  if (underlying_type)\n+    underlying_type = cv_unqualified (underlying_type);\n+\n   /* If this is the real definition for a previous forward reference,\n      fill in the contents in the same object that used to be the\n      forward reference.  */\n+  if (!enumtype)\n+    enumtype = lookup_and_check_tag (enum_type, name,\n+\t\t\t\t     /*tag_scope=*/ts_current,\n+\t\t\t\t     /*template_header_p=*/false);\n \n-  enumtype = lookup_and_check_tag (enum_type, name,\n-\t\t\t\t   /*tag_scope=*/ts_current,\n-\t\t\t\t   /*template_header_p=*/false);\n-\n-  if (enumtype != NULL_TREE && TREE_CODE (enumtype) == ENUMERAL_TYPE)\n+  /* In case of a template_decl, the only check that should be deferred\n+     to instantiation time is the comparison of underlying types.  */\n+  if (enumtype && TREE_CODE (enumtype) == ENUMERAL_TYPE)\n     {\n-      error_at (input_location, \"multiple definition of %q#T\", enumtype);\n-      error_at (DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (enumtype)),\n-\t\t\"previous definition here\");\n-      /* Clear out TYPE_VALUES, and start again.  */\n-      TYPE_VALUES (enumtype) = NULL_TREE;\n+      if (scoped_enum_p != SCOPED_ENUM_P (enumtype))\n+\t{\n+\t  error_at (input_location, \"scoped/unscoped mismatch \"\n+\t\t    \"in enum %q#T\", enumtype);\n+\t  error_at (DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (enumtype)),\n+\t\t    \"previous definition here\");\n+\t  enumtype = error_mark_node;\n+\t}\n+      else if (ENUM_FIXED_UNDERLYING_TYPE_P (enumtype) != !! underlying_type)\n+\t{\n+\t  error_at (input_location, \"underlying type mismatch \"\n+\t\t    \"in enum %q#T\", enumtype);\n+\t  error_at (DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (enumtype)),\n+\t\t    \"previous definition here\");\n+\t  enumtype = error_mark_node;\n+\t}\n+      else if (underlying_type && ENUM_UNDERLYING_TYPE (enumtype)\n+\t       && !dependent_type_p (underlying_type)\n+\t       && !dependent_type_p (ENUM_UNDERLYING_TYPE (enumtype))\n+\t       && !same_type_p (underlying_type,\n+\t\t\t\tENUM_UNDERLYING_TYPE (enumtype)))\n+\t{\n+\t  error_at (input_location, \"different underlying type \"\n+\t\t    \"in enum %q#T\", enumtype);\n+\t  error_at (DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (enumtype)),\n+\t\t    \"previous definition here\");\n+\t  underlying_type = NULL_TREE;\n+\t}\n     }\n-  else\n+\n+  if (!enumtype || TREE_CODE (enumtype) != ENUMERAL_TYPE\n+      || processing_template_decl)\n     {\n       /* In case of error, make a dummy enum to allow parsing to\n \t continue.  */\n       if (enumtype == error_mark_node)\n-\tname = make_anon_name ();\n+\t{\n+\t  name = make_anon_name ();\n+\t  enumtype = NULL_TREE;\n+\t}\n \n+      /* enumtype may be an ENUMERAL_TYPE if this is a redefinition\n+         of an opaque enum, or an opaque enum of an already defined\n+\t enumeration (C++0x only).\n+\t In any other case, it'll be NULL_TREE. */\n+      if (!enumtype)\n+\t{\n+\t  if (is_new)\n+\t    *is_new = true;\n+\t}\n+      prevtype = enumtype;\n       enumtype = cxx_make_type (ENUMERAL_TYPE);\n       enumtype = pushtag (name, enumtype, /*tag_scope=*/ts_current);\n-    }\n-\n-  if (enumtype == error_mark_node)\n-    return enumtype;\n-\n-  if (scoped_enum_p)\n-    {\n-      SET_SCOPED_ENUM_P (enumtype, 1);\n-      begin_scope (sk_scoped_enum, enumtype);\n-\n-      /* [C++0x dcl.enum]p5: \n+      if (enumtype == error_mark_node)\n+\treturn error_mark_node;\n \n-          If not explicitly specified, the underlying type of a scoped\n-          enumeration type is int.  */\n-      if (!underlying_type)\n-        underlying_type = integer_type_node;\n+      /* The enum is considered opaque until the opening '{' of the\n+\t enumerator list.  */\n+      SET_OPAQUE_ENUM_P (enumtype, true);\n+      ENUM_FIXED_UNDERLYING_TYPE_P (enumtype) = !! underlying_type;\n     }\n \n+  SET_SCOPED_ENUM_P (enumtype, scoped_enum_p);\n+\n   if (underlying_type)\n     {\n       if (CP_INTEGRAL_TYPE_P (underlying_type))\n         {\n-          TYPE_MIN_VALUE (enumtype) = TYPE_MIN_VALUE (underlying_type);\n-          TYPE_MAX_VALUE (enumtype) = TYPE_MAX_VALUE (underlying_type);\n-          TYPE_SIZE (enumtype) = TYPE_SIZE (underlying_type);\n-          TYPE_SIZE_UNIT (enumtype) = TYPE_SIZE_UNIT (underlying_type);\n-          SET_TYPE_MODE (enumtype, TYPE_MODE (underlying_type));\n-          TYPE_PRECISION (enumtype) = TYPE_PRECISION (underlying_type);\n-          TYPE_ALIGN (enumtype) = TYPE_ALIGN (underlying_type);\n-          TYPE_USER_ALIGN (enumtype) = TYPE_USER_ALIGN (underlying_type);\n-          TYPE_UNSIGNED (enumtype) = TYPE_UNSIGNED (underlying_type);\n+\t  copy_type_enum (enumtype, underlying_type);\n           ENUM_UNDERLYING_TYPE (enumtype) = underlying_type;\n         }\n-      else if (!dependent_type_p (underlying_type))\n+      else if (dependent_type_p (underlying_type))\n+\tENUM_UNDERLYING_TYPE (enumtype) = underlying_type;\n+      else\n         error (\"underlying type %<%T%> of %<%T%> must be an integral type\", \n                underlying_type, enumtype);\n     }\n \n-  return enumtype;\n+  /* If into a template class, the returned enum is always the first\n+     declaration (opaque or not) seen. This way all the references to\n+     this type will be to the same declaration. The following ones are used\n+     only to check for definition errors.  */\n+  if (prevtype && processing_template_decl)\n+    return prevtype;\n+  else\n+    return enumtype;\n }\n \n /* After processing and defining all the values of an enumeration type,\n-   install their decls in the enumeration type and finish it off.\n-   ENUMTYPE is the type object and VALUES a list of name-value pairs.  */\n+   install their decls in the enumeration type.\n+   ENUMTYPE is the type object.  */\n \n void\n-finish_enum (tree enumtype)\n+finish_enum_value_list (tree enumtype)\n {\n   tree values;\n+  tree underlying_type;\n   tree decl;\n-  tree minnode;\n-  tree maxnode;\n   tree value;\n+  tree minnode, maxnode;\n   tree t;\n-  tree underlying_type = NULL_TREE;\n+\n   bool fixed_underlying_type_p \n     = ENUM_UNDERLYING_TYPE (enumtype) != NULL_TREE;\n \n@@ -11425,10 +11492,6 @@ finish_enum (tree enumtype)\n \t   values;\n \t   values = TREE_CHAIN (values))\n \tTREE_TYPE (TREE_VALUE (values)) = enumtype;\n-      if (at_function_scope_p ())\n-\tadd_stmt (build_min (TAG_DEFN, enumtype));\n-      if (SCOPED_ENUM_P (enumtype))\n-\tfinish_scope ();\n       return;\n     }\n \n@@ -11438,34 +11501,34 @@ finish_enum (tree enumtype)\n       minnode = maxnode = NULL_TREE;\n \n       for (values = TYPE_VALUES (enumtype);\n-           values;\n-           values = TREE_CHAIN (values))\n-        {\n-          decl = TREE_VALUE (values);\n-\n-          /* [dcl.enum]: Following the closing brace of an enum-specifier,\n-             each enumerator has the type of its enumeration.  Prior to the\n-             closing brace, the type of each enumerator is the type of its\n-             initializing value.  */\n-          TREE_TYPE (decl) = enumtype;\n-\n-          /* Update the minimum and maximum values, if appropriate.  */\n-          value = DECL_INITIAL (decl);\n-          if (value == error_mark_node)\n-            value = integer_zero_node;\n-          /* Figure out what the minimum and maximum values of the\n-             enumerators are.  */\n-          if (!minnode)\n-            minnode = maxnode = value;\n-          else if (tree_int_cst_lt (maxnode, value))\n-            maxnode = value;\n-          else if (tree_int_cst_lt (value, minnode))\n-            minnode = value;\n-        }\n+\t   values;\n+\t   values = TREE_CHAIN (values))\n+\t{\n+\t  decl = TREE_VALUE (values);\n+\n+\t  /* [dcl.enum]: Following the closing brace of an enum-specifier,\n+\t     each enumerator has the type of its enumeration.  Prior to the\n+\t     closing brace, the type of each enumerator is the type of its\n+\t     initializing value.  */\n+\t  TREE_TYPE (decl) = enumtype;\n+\n+\t  /* Update the minimum and maximum values, if appropriate.  */\n+\t  value = DECL_INITIAL (decl);\n+\t  if (value == error_mark_node)\n+\t    value = integer_zero_node;\n+\t  /* Figure out what the minimum and maximum values of the\n+\t     enumerators are.  */\n+\t  if (!minnode)\n+\t    minnode = maxnode = value;\n+\t  else if (tree_int_cst_lt (maxnode, value))\n+\t    maxnode = value;\n+\t  else if (tree_int_cst_lt (value, minnode))\n+\t    minnode = value;\n+\t}\n     }\n   else\n     /* [dcl.enum]\n-       \n+\n        If the enumerator-list is empty, the underlying type is as if\n        the enumeration had a single enumerator with value 0.  */\n     minnode = maxnode = integer_zero_node;\n@@ -11530,15 +11593,7 @@ finish_enum (tree enumtype)\n          The value of sizeof() applied to an enumeration type, an object\n          of an enumeration type, or an enumerator, is the value of sizeof()\n          applied to the underlying type.  */\n-      TYPE_MIN_VALUE (enumtype) = TYPE_MIN_VALUE (underlying_type);\n-      TYPE_MAX_VALUE (enumtype) = TYPE_MAX_VALUE (underlying_type);\n-      TYPE_SIZE (enumtype) = TYPE_SIZE (underlying_type);\n-      TYPE_SIZE_UNIT (enumtype) = TYPE_SIZE_UNIT (underlying_type);\n-      SET_TYPE_MODE (enumtype, TYPE_MODE (underlying_type));\n-      TYPE_PRECISION (enumtype) = TYPE_PRECISION (underlying_type);\n-      TYPE_ALIGN (enumtype) = TYPE_ALIGN (underlying_type);\n-      TYPE_USER_ALIGN (enumtype) = TYPE_USER_ALIGN (underlying_type);\n-      TYPE_UNSIGNED (enumtype) = TYPE_UNSIGNED (underlying_type);\n+      copy_type_enum (enumtype, underlying_type);\n \n       /* Compute the minimum and maximum values for the type.\n \n@@ -11603,28 +11658,31 @@ finish_enum (tree enumtype)\n \n   /* Fix up all variant types of this enum type.  */\n   for (t = TYPE_MAIN_VARIANT (enumtype); t; t = TYPE_NEXT_VARIANT (t))\n-    {\n-      TYPE_VALUES (t) = TYPE_VALUES (enumtype);\n-      TYPE_MIN_VALUE (t) = TYPE_MIN_VALUE (enumtype);\n-      TYPE_MAX_VALUE (t) = TYPE_MAX_VALUE (enumtype);\n-      TYPE_SIZE (t) = TYPE_SIZE (enumtype);\n-      TYPE_SIZE_UNIT (t) = TYPE_SIZE_UNIT (enumtype);\n-      SET_TYPE_MODE (t, TYPE_MODE (enumtype));\n-      TYPE_PRECISION (t) = TYPE_PRECISION (enumtype);\n-      TYPE_ALIGN (t) = TYPE_ALIGN (enumtype);\n-      TYPE_USER_ALIGN (t) = TYPE_USER_ALIGN (enumtype);\n-      TYPE_UNSIGNED (t) = TYPE_UNSIGNED (enumtype);\n-      ENUM_UNDERLYING_TYPE (t) = ENUM_UNDERLYING_TYPE (enumtype);\n-    }\n-\n-  /* Finish up the scope of a scoped enumeration.  */\n-  if (SCOPED_ENUM_P (enumtype))\n-    finish_scope ();\n+    TYPE_VALUES (t) = TYPE_VALUES (enumtype);\n \n   /* Finish debugging output for this type.  */\n   rest_of_type_compilation (enumtype, namespace_bindings_p ());\n }\n \n+/* Finishes the enum type. This is called only the first time an\n+   enumeration is seen, be it opaque or odinary.\n+   ENUMTYPE is the type object.  */\n+\n+void\n+finish_enum (tree enumtype)\n+{\n+  if (processing_template_decl)\n+    {\n+      if (at_function_scope_p ())\n+\tadd_stmt (build_min (TAG_DEFN, enumtype));\n+      return;\n+    }\n+\n+  /* Here there should not be any variants of this type.  */\n+  gcc_assert (enumtype == TYPE_MAIN_VARIANT (enumtype)\n+\t      && !TYPE_NEXT_VARIANT (enumtype));\n+}\n+\n /* Build and install a CONST_DECL for an enumeration constant of the\n    enumeration type ENUMTYPE whose NAME and VALUE (if any) are provided.\n    LOC is the location of NAME."}, {"sha": "8ea805d6c374ec9798e4132d41ad5fe89972552a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 212, "deletions": 34, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -12920,17 +12920,17 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n       cp_lexer_consume_token (parser->lexer);\n       /* Remember that it's an enumeration type.  */\n       tag_type = enum_type;\n-      /* Parse the optional `struct' or `class' key (for C++0x scoped\n-         enums).  */\n+      /* Issue a warning if the `struct' or `class' key (for C++0x scoped\n+\t enums) is used here.  */\n       if (cp_lexer_next_token_is_keyword (parser->lexer, RID_CLASS)\n-          || cp_lexer_next_token_is_keyword (parser->lexer, RID_STRUCT))\n-        {\n-          if (cxx_dialect == cxx98)\n-            maybe_warn_cpp0x (CPP0X_SCOPED_ENUMS);\n-\n-          /* Consume the `struct' or `class'.  */\n-          cp_lexer_consume_token (parser->lexer);\n-        }\n+\t  || cp_lexer_next_token_is_keyword (parser->lexer, RID_STRUCT))\n+\t{\n+\t    pedwarn (input_location, 0, \"elaborated-type-specifier \"\n+\t\t      \"for a scoped enum must not use the %<%D%> keyword\",\n+\t\t      cp_lexer_peek_token (parser->lexer)->u.value);\n+\t  /* Consume the `struct' or `class' and parse it anyway.  */\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t}\n       /* Parse the attributes.  */\n       attributes = cp_parser_attributes_opt (parser);\n     }\n@@ -13220,7 +13220,11 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n /* Parse an enum-specifier.\n \n    enum-specifier:\n-     enum-key identifier [opt] enum-base [opt] { enumerator-list [opt] }\n+     enum-head { enumerator-list [opt] }\n+\n+   enum-head:\n+     enum-key identifier [opt] enum-base [opt]\n+     enum-key nested-name-specifier identifier enum-base [opt]\n \n    enum-key:\n      enum\n@@ -13230,6 +13234,9 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n    enum-base:   [C++0x]\n      : type-specifier-seq\n \n+   opaque-enum-specifier:\n+     enum-key identifier enum-base [opt] ;\n+\n    GNU Extensions:\n      enum-key attributes[opt] identifier [opt] enum-base [opt] \n        { enumerator-list [opt] }attributes[opt]\n@@ -13241,11 +13248,18 @@ static tree\n cp_parser_enum_specifier (cp_parser* parser)\n {\n   tree identifier;\n-  tree type;\n+  tree type = NULL_TREE;\n+  tree prev_scope;\n+  tree nested_name_specifier = NULL_TREE;\n   tree attributes;\n   bool scoped_enum_p = false;\n   bool has_underlying_type = false;\n+  bool nested_being_defined = false;\n+  bool new_value_list = false;\n+  bool is_new_type = false;\n+  bool is_anonymous = false;\n   tree underlying_type = NULL_TREE;\n+  cp_token *type_start_token = NULL;\n \n   /* Parse tentatively so that we can back up if we don't find a\n      enum-specifier.  */\n@@ -13262,7 +13276,7 @@ cp_parser_enum_specifier (cp_parser* parser)\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_CLASS)\n       || cp_lexer_next_token_is_keyword (parser->lexer, RID_STRUCT))\n     {\n-      if (cxx_dialect == cxx98)\n+      if (cxx_dialect < cxx0x)\n         maybe_warn_cpp0x (CPP0X_SCOPED_ENUMS);\n \n       /* Consume the `struct' or `class' token.  */\n@@ -13273,10 +13287,65 @@ cp_parser_enum_specifier (cp_parser* parser)\n \n   attributes = cp_parser_attributes_opt (parser);\n \n-  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n-    identifier = cp_parser_identifier (parser);\n+  /* Clear the qualification.  */\n+  parser->scope = NULL_TREE;\n+  parser->qualifying_scope = NULL_TREE;\n+  parser->object_scope = NULL_TREE;\n+\n+  /* Figure out in what scope the declaration is being placed.  */\n+  prev_scope = current_scope ();\n+\n+  type_start_token = cp_lexer_peek_token (parser->lexer);\n+\n+  push_deferring_access_checks (dk_no_check);\n+  nested_name_specifier\n+      = cp_parser_nested_name_specifier_opt (parser,\n+\t\t\t\t\t     /*typename_keyword_p=*/true,\n+\t\t\t\t\t     /*check_dependency_p=*/false,\n+\t\t\t\t\t     /*type_p=*/false,\n+\t\t\t\t\t     /*is_declaration=*/false);\n+\n+  if (nested_name_specifier)\n+    {\n+      tree name;\n+\n+      identifier = cp_parser_identifier (parser);\n+      name =  cp_parser_lookup_name (parser, identifier,\n+\t\t\t\t     enum_type,\n+\t\t\t\t     /*is_template=*/false,\n+\t\t\t\t     /*is_namespace=*/false,\n+\t\t\t\t     /*check_dependency=*/true,\n+\t\t\t\t     /*ambiguous_decls=*/NULL,\n+\t\t\t\t     input_location);\n+      if (name)\n+\t{\n+\t  type = TREE_TYPE (name);\n+\t  if (TREE_CODE (type) == TYPENAME_TYPE)\n+\t    {\n+\t      /* Are template enums allowed in ISO? */\n+\t      if (template_parm_scope_p ())\n+\t\tpedwarn (type_start_token->location, OPT_pedantic,\n+\t\t\t \"%qD is an enumeration template\", name);\n+\t      /* ignore a typename reference, for it will be solved by name\n+\t         in start_enum.  */\n+\t      type = NULL_TREE;\n+\t    }\n+\t}\n+      else\n+\terror_at (type_start_token->location,\n+\t\t  \"%qD is not an enumerator-name\", identifier);\n+    }\n   else\n-    identifier = make_anon_name ();\n+    {\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+\tidentifier = cp_parser_identifier (parser);\n+      else\n+\t{\n+\t  identifier = make_anon_name ();\n+\t  is_anonymous = true;\n+\t}\n+    }\n+  pop_deferring_access_checks ();\n \n   /* Check for the `:' that denotes a specified underlying type in C++0x.\n      Note that a ':' could also indicate a bitfield width, however.  */\n@@ -13296,7 +13365,7 @@ cp_parser_enum_specifier (cp_parser* parser)\n       if (!cp_parser_parse_definitely (parser))\n \treturn NULL_TREE;\n \n-      if (cxx_dialect == cxx98)\n+      if (cxx_dialect < cxx0x)\n         maybe_warn_cpp0x (CPP0X_SCOPED_ENUMS);\n \n       has_underlying_type = true;\n@@ -13314,38 +13383,129 @@ cp_parser_enum_specifier (cp_parser* parser)\n   /* Look for the `{' but don't consume it yet.  */\n   if (!cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n     {\n-      cp_parser_error (parser, \"expected %<{%>\");\n-      if (has_underlying_type)\n-\treturn NULL_TREE;\n+      if (cxx_dialect < cxx0x || (!scoped_enum_p && !underlying_type))\n+\t{\n+\t  cp_parser_error (parser, \"expected %<{%>\");\n+\t  if (has_underlying_type)\n+\t    return NULL_TREE;\n+\t}\n+      /* An opaque-enum-specifier must have a ';' here.  */\n+      if ((scoped_enum_p || underlying_type)\n+\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n+\t{\n+\t  cp_parser_error (parser, \"expected %<;%> or %<{%>\");\n+\t  if (has_underlying_type)\n+\t    return NULL_TREE;\n+\t}\n     }\n \n   if (!has_underlying_type && !cp_parser_parse_definitely (parser))\n     return NULL_TREE;\n \n+  if (nested_name_specifier)\n+    {\n+      if (CLASS_TYPE_P (nested_name_specifier))\n+\t{\n+\t  nested_being_defined = TYPE_BEING_DEFINED (nested_name_specifier);\n+\t  TYPE_BEING_DEFINED (nested_name_specifier) = 1;\n+\t  push_scope (nested_name_specifier);\n+\t}\n+      else if (TREE_CODE (nested_name_specifier) == NAMESPACE_DECL)\n+\t{\n+\t  push_nested_namespace (nested_name_specifier);\n+\t}\n+    }\n+\n   /* Issue an error message if type-definitions are forbidden here.  */\n   if (!cp_parser_check_type_definition (parser))\n     type = error_mark_node;\n   else\n     /* Create the new type.  We do this before consuming the opening\n        brace so the enum will be recorded as being on the line of its\n        tag (or the 'enum' keyword, if there is no tag).  */\n-    type = start_enum (identifier, underlying_type, scoped_enum_p);\n-  \n-  /* Consume the opening brace.  */\n-  cp_lexer_consume_token (parser->lexer);\n+    type = start_enum (identifier, type, underlying_type,\n+\t\t       scoped_enum_p, &is_new_type);\n \n-  if (type == error_mark_node)\n+  /* If the next token is not '{' it is an opaque-enum-specifier or an\n+     elaborated-type-specifier.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n     {\n-      cp_parser_skip_to_end_of_block_or_statement (parser);\n-      return error_mark_node;\n-    }\n+      if (nested_name_specifier)\n+\t{\n+\t  /* The following catches invalid code such as:\n+\t     enum class S<int>::E { A, B, C }; */\n+\t  if (!processing_specialization\n+\t      && CLASS_TYPE_P (nested_name_specifier)\n+\t      && CLASSTYPE_USE_TEMPLATE (nested_name_specifier))\n+\t    error_at (type_start_token->location, \"cannot add an enumerator \"\n+\t\t      \"list to a template instantiation\");\n+\n+\t  /* If that scope does not contain the scope in which the\n+\t     class was originally declared, the program is invalid.  */\n+\t  if (prev_scope && !is_ancestor (prev_scope, nested_name_specifier))\n+\t    {\n+\t      if (at_namespace_scope_p ())\n+\t\terror_at (type_start_token->location,\n+\t\t\t  \"declaration of %qD in namespace %qD which does not \"\n+\t\t\t  \"enclose %qD\",\n+\t\t\t  type, prev_scope, nested_name_specifier);\n+\t      else\n+\t\terror_at (type_start_token->location,\n+\t\t\t  \"declaration of %qD in %qD which does not enclose %qD\",\n+\t\t\t  type, prev_scope, nested_name_specifier);\n+\t      type = error_mark_node;\n+\t    }\n+\t}\n \n-  /* If the next token is not '}', then there are some enumerators.  */\n-  if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_BRACE))\n-    cp_parser_enumerator_list (parser, type);\n+      if (scoped_enum_p)\n+\tbegin_scope (sk_scoped_enum, type);\n \n-  /* Consume the final '}'.  */\n-  cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n+      /* Consume the opening brace.  */\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      if (type == error_mark_node)\n+\t; /* Nothing to add */\n+      else if (OPAQUE_ENUM_P (type)\n+\t       || (cxx_dialect > cxx98 && processing_specialization))\n+\t{\n+\t  new_value_list = true;\n+\t  SET_OPAQUE_ENUM_P (type, false);\n+\t  DECL_SOURCE_LOCATION (TYPE_NAME (type)) = type_start_token->location;\n+\t}\n+      else\n+\t{\n+\t  error_at (type_start_token->location, \"multiple definition of %q#T\", type);\n+\t  error_at (DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (type)),\n+\t\t    \"previous definition here\");\n+\t  type = error_mark_node;\n+\t}\n+\n+      if (type == error_mark_node)\n+\tcp_parser_skip_to_end_of_block_or_statement (parser);\n+      /* If the next token is not '}', then there are some enumerators.  */\n+      else if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_BRACE))\n+\tcp_parser_enumerator_list (parser, type);\n+\n+      /* Consume the final '}'.  */\n+      cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n+\n+      if (scoped_enum_p)\n+\tfinish_scope ();\n+    }\n+  else\n+    {\n+      /* If a ';' follows, then it is an opaque-enum-specifier\n+\tand additional restrictions apply.  */\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n+\t{\n+\t  if (is_anonymous)\n+\t    error_at (type_start_token->location,\n+\t\t      \"opaque-enum-specifier without name\");\n+\t  else if (nested_name_specifier)\n+\t    error_at (type_start_token->location,\n+\t\t      \"opaque-enum-specifier must use a simple identifier\");\n+\t}\n+    }\n \n   /* Look for trailing attributes to apply to this enumeration, and\n      apply them if appropriate.  */\n@@ -13359,8 +13519,26 @@ cp_parser_enum_specifier (cp_parser* parser)\n     }\n \n   /* Finish up the enumeration.  */\n-  finish_enum (type);\n+  if (type != error_mark_node)\n+    {\n+      if (new_value_list)\n+\tfinish_enum_value_list (type);\n+      if (is_new_type)\n+\tfinish_enum (type);\n+    }\n \n+  if (nested_name_specifier)\n+    {\n+      if (CLASS_TYPE_P (nested_name_specifier))\n+\t{\n+\t  TYPE_BEING_DEFINED (nested_name_specifier) = nested_being_defined;\n+\t  pop_scope (nested_name_specifier);\n+\t}\n+      else if (TREE_CODE (nested_name_specifier) == NAMESPACE_DECL)\n+\t{\n+\t  pop_nested_namespace (nested_name_specifier);\n+\t}\n+    }\n   return type;\n }\n "}, {"sha": "1de5d5527fda35f99e09a030faec6706517f375f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -907,8 +907,16 @@ maybe_process_partial_specialization (tree type)\n     }\n   else if (processing_specialization)\n     {\n-      error (\"explicit specialization of non-template %qT\", type);\n-      return error_mark_node;\n+       /* Someday C++0x may allow for enum template specialization.  */\n+      if (cxx_dialect > cxx98 && TREE_CODE (type) == ENUMERAL_TYPE\n+\t  && CLASS_TYPE_P (context) && CLASSTYPE_USE_TEMPLATE (context))\n+\tpedwarn (input_location, OPT_pedantic, \"template specialization \"\n+\t\t \"of %qD not allowed by ISO C++\", type);\n+      else\n+\t{\n+\t  error (\"explicit specialization of non-template %qT\", type);\n+\t  return error_mark_node;\n+\t}\n     }\n \n   return type;\n@@ -6657,10 +6665,10 @@ lookup_template_class (tree d1,\n \t  if (!is_dependent_type)\n \t    {\n \t      set_current_access_from_decl (TYPE_NAME (template_type));\n-\t      t = start_enum (TYPE_IDENTIFIER (template_type),\n-                              tsubst (ENUM_UNDERLYING_TYPE (template_type),\n-                                      arglist, complain, in_decl),\n-                              SCOPED_ENUM_P (template_type));\n+\t      t = start_enum (TYPE_IDENTIFIER (template_type), NULL_TREE,\n+\t\t\t      tsubst (ENUM_UNDERLYING_TYPE (template_type),\n+\t\t\t\t      arglist, complain, in_decl),\n+\t\t\t      SCOPED_ENUM_P (template_type), NULL);\n \t    }\n \t  else\n             {\n@@ -6671,6 +6679,7 @@ lookup_template_class (tree d1,\n               t = cxx_make_type (ENUMERAL_TYPE);\n               SET_SCOPED_ENUM_P (t, SCOPED_ENUM_P (template_type));\n             }\n+          SET_OPAQUE_ENUM_P (t, OPAQUE_ENUM_P (template_type));\n \t}\n       else\n \t{\n@@ -17309,6 +17318,9 @@ tsubst_enum (tree tag, tree newtag, tree args)\n {\n   tree e;\n \n+  if (SCOPED_ENUM_P (newtag))\n+    begin_scope (sk_scoped_enum, newtag);\n+\n   for (e = TYPE_VALUES (tag); e; e = TREE_CHAIN (e))\n     {\n       tree value;\n@@ -17329,7 +17341,12 @@ tsubst_enum (tree tag, tree newtag, tree args)\n \t(DECL_NAME (decl), value, newtag, DECL_SOURCE_LOCATION (decl));\n     }\n \n+  if (SCOPED_ENUM_P (newtag))\n+    finish_scope ();\n+\n+  finish_enum_value_list (newtag);\n   finish_enum (newtag);\n+\n   DECL_SOURCE_LOCATION (TYPE_NAME (newtag))\n     = DECL_SOURCE_LOCATION (TYPE_NAME (tag));\n }"}, {"sha": "bf248dcba60bebd55abd1921fbd8c96f0b1d84a7", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -18312,9 +18312,13 @@ gen_enumeration_type_die (tree type, dw_die_ref context_die)\n \t\t\t  scope_die_for (type, context_die), type);\n       equate_type_number_to_die (type, type_die);\n       add_name_attribute (type_die, type_tag (type));\n-      if ((dwarf_version >= 4 || !dwarf_strict)\n-\t  && ENUM_IS_SCOPED (type))\n-\tadd_AT_flag (type_die, DW_AT_enum_class, 1);\n+      if (dwarf_version >= 4 || !dwarf_strict)\n+\t{\n+\t  if (ENUM_IS_SCOPED (type))\n+\t    add_AT_flag (type_die, DW_AT_enum_class, 1);\n+\t  if (ENUM_IS_OPAQUE (type))\n+\t    add_AT_flag (type_die, DW_AT_declaration, 1);\n+\t}\n     }\n   else if (! TYPE_SIZE (type))\n     return type_die;"}, {"sha": "429ab84131cbcaae8240b0f017ad3d73e9307f2a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -1,3 +1,20 @@\n+2010-10-25  Rodrigo Rivas Costa <rodrigorivascosta@gmail.com>\n+\n+\tImplement opaque-enum-specifiers for C++0x\n+\t* g++.dg/cpp0x/forw_enum1.C: New.\n+\t* g++.dg/cpp0x/forw_enum2.C: New.\n+\t* g++.dg/cpp0x/forw_enum3.C: New.\n+\t* g++.dg/cpp0x/forw_enum4.C: New.\n+\t* g++.dg/cpp0x/forw_enum5.C: New.\n+\t* g++.dg/cpp0x/forw_enum6.C: New.\n+\t* g++.dg/cpp0x/forw_enum7.C: New.\n+\t* g++.dg/cpp0x/forw_enum8.C: New.\n+\t* g++.dg/cpp0x/forw_enum9.C: New.\n+\t* g++.dg/parse/enum3.C: Add new errors.\n+\t* g++.dg/cpp0x/scoped_enum.C: Avoid unwanted warning.\n+\t* g++.dg/cpp0x/auto9.C: Add new error.\n+\t* g++.dg/template/crash79.C: Add new errors.\n+\n 2010-10-26  Jie Zhang  <jie@codesourcery.com>\n \n \t* gcc.target/arm/volatile-bitfields-1.c: New test."}, {"sha": "ab90be55844bb9a6342d3a6c5643e668a8132538", "filename": "gcc/testsuite/g++.dg/cpp0x/auto9.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto9.C?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -74,7 +74,7 @@ C<auto> c;\t\t\t\t\t// { dg-error \"auto|invalid\" }\n C<auto *> c2;\t\t\t\t\t// { dg-error \"auto|invalid\" }\n \n enum : auto { EE = 0 };\t\t\t\t// { dg-error \"must be an integral type\" }\n-enum struct D : auto * { FF = 0 };\t\t// { dg-error \"declar|expected\" }\n+enum struct D : auto * { FF = 0 };\t\t// { dg-error \"must be an integral type|declar|expected\" }\n \n void\n bar ()"}, {"sha": "2817ae59573abab18b8348ed43eff8131a806b2d", "filename": "gcc/testsuite/g++.dg/cpp0x/forw_enum1.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum1.C?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -0,0 +1,45 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+// opaque enum declarations\n+enum class E1;\n+enum class E2 : int;\n+enum class E3 : short;\n+enum E4 : int;\n+enum E5 : short;\n+\n+// can be repeated\n+enum class E1;\n+enum class E2 : int;\n+enum class E3 : short;\n+enum E4 : int;\n+enum E5 : short;\n+\n+// are complete so we can declare variables\n+E1 b1;\n+E2 b2;\n+E3 b3;\n+E4 b4;\n+E5 b5;\n+\n+//even with elaborated-type-specifiers\n+enum E1 a1;\n+enum E2 a2;\n+enum E3 a3;\n+enum E4 a4;\n+enum E5 a5;\n+\n+// and the list can be added later\n+enum class E1 { e11, e12 };\n+enum class E2 : int { e21, e22 };\n+enum class E3 : short {e31, e32 };\n+enum E4 : int { e41, e42 };\n+enum E5 : short { e51, e52 };\n+\n+// more repetitions allowed\n+enum class E1;\n+enum class E2 : int;\n+enum class E3 : short;\n+enum E4 : int;\n+enum E5 : short;\n+"}, {"sha": "b6ad87148678ec303606dff21daee9264ae716ca", "filename": "gcc/testsuite/g++.dg/cpp0x/forw_enum2.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum2.C?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+struct S1\n+{\n+    struct S2\n+    {\n+        // opaque enum declarations\n+        enum class E1;\n+        enum class E2 : int;\n+        enum class E3 : short;\n+        enum E4 : int;\n+        enum E5 : short;\n+\n+        // can be repeated\n+        enum class E1;\n+        enum class E2 : int;\n+        enum class E3 : short;\n+        enum E4 : int;\n+        enum E5 : short;\n+    };\n+};\n+\n+// are complete so we can declare variables\n+S1::S2::E1 b1;\n+S1::S2::E2 b2;\n+S1::S2::E3 b3;\n+S1::S2::E4 b4;\n+S1::S2::E5 b5;\n+\n+//even with elaborated-type-specifiers\n+enum S1::S2::E1 a1;\n+enum S1::S2::E2 a2;\n+enum S1::S2::E3 a3;\n+enum S1::S2::E4 a4;\n+enum S1::S2::E5 a5;\n+\n+// and the list can be added later\n+enum class S1::S2::E1 { e11, e12 };\n+enum class S1::S2::E2 : int { e21, e22 };\n+enum class S1::S2::E3 : short {e31, e32 };\n+enum S1::S2::E4 : int { e41, e42 };\n+enum S1::S2::E5 : short { e51, e52 };\n+"}, {"sha": "4a7e9f98d47ca1fe808e830f15c9827634fb6790", "filename": "gcc/testsuite/g++.dg/cpp0x/forw_enum3.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum3.C?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+namespace S1\n+{\n+    namespace S2\n+    {\n+        // opaque enum declarations\n+        enum class E1;\n+        enum class E2 : int;\n+        enum class E3 : short;\n+        enum E4 : int;\n+        enum E5 : short;\n+\n+        // can be repeated\n+        enum class E1;\n+        enum class E2 : int;\n+        enum class E3 : short;\n+        enum E4 : int;\n+        enum E5 : short;\n+    }\n+}\n+\n+// are complete so we can declare variables\n+S1::S2::E1 b1;\n+S1::S2::E2 b2;\n+S1::S2::E3 b3;\n+S1::S2::E4 b4;\n+S1::S2::E5 b5;\n+\n+//even with elaborated-type-specifiers\n+enum S1::S2::E1 a1;\n+enum S1::S2::E2 a2;\n+enum S1::S2::E3 a3;\n+enum S1::S2::E4 a4;\n+enum S1::S2::E5 a5;\n+\n+// and the list can be added later\n+enum class S1::S2::E1 { e11, e12 };\n+enum class S1::S2::E2 : int { e21, e22 };\n+enum class S1::S2::E3 : short {e31, e32 };\n+enum S1::S2::E4 : int { e41, e42 };\n+enum S1::S2::E5 : short { e51, e52 };\n+"}, {"sha": "0fcc3bde0f5721480ad454b4aa86b29b971747cd", "filename": "gcc/testsuite/g++.dg/cpp0x/forw_enum4.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum4.C?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -0,0 +1,45 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template<typename T> struct S1\n+{\n+    struct S2\n+    {\n+        // opaque enum declarations\n+        enum class E1;\n+        enum class E2 : T;\n+        enum class E3 : short;\n+        enum E4 : T;\n+        enum E5 : short;\n+\n+        // can be repeated\n+        enum class E1;\n+        enum class E2 : T;\n+        enum class E3 : short;\n+        enum E4 : T;\n+        enum E5 : short;\n+    };\n+\n+    // are complete so we can declare variables\n+    typename S2::E1 b1;\n+    typename S2::E2 b2;\n+    typename S2::E3 b3;\n+    typename S2::E4 b4;\n+    typename S2::E5 b5;\n+\n+    //even with elaborated-type-specifiers\n+    enum S1::S2::E1 a1;\n+    enum S1::S2::E2 a2;\n+    enum S1::S2::E3 a3;\n+    enum S1::S2::E4 a4;\n+    enum S1::S2::E5 a5;\n+\n+    // and the list can be added later\n+    enum class S1::S2::E1 { e11, e12 };\n+    enum class S1::S2::E2 : T { e21, e22 };\n+    enum class S1::S2::E3 : short {e31, e32 };\n+    enum S1::S2::E4 : T { e41, e42 };\n+    enum S1::S2::E5 : short { e51, e52 };\n+};\n+\n+template struct S1<int>;"}, {"sha": "a2edfa7635c50b4be504d6bc51d36fe545389c6c", "filename": "gcc/testsuite/g++.dg/cpp0x/forw_enum5.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum5.C?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -0,0 +1,63 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+namespace one\n+{\n+    struct S\n+    {\n+        enum { A = 1, B = 2 };\n+        struct T\n+        {\n+            enum { B = 102 };\n+\n+            enum class E1;\n+            enum E2 : int;\n+        };\n+    };\n+\n+    enum class S::T::E1 { A1 = A, B1 = B, C1 };\n+    enum S::T::E2 : int { A1 = A, B1 = B, C1 };\n+\n+    static_assert(int(S::T::E1::A1) == 1, \"error\");\n+    static_assert(int(S::T::E1::B1) == 102, \"error\");\n+    static_assert(int(S::T::E1::C1) == 103, \"error\");\n+\n+    static_assert(int(S::T::E2::A1) == 1, \"error\");\n+    static_assert(int(S::T::E2::B1) == 102, \"error\");\n+    static_assert(int(S::T::E2::C1) == 103, \"error\");\n+    static_assert(int(S::T::A1) == 1, \"error\");\n+    static_assert(int(S::T::B1) == 102, \"error\");\n+    static_assert(int(S::T::C1) == 103, \"error\");\n+}\n+\n+\n+namespace two\n+{\n+    namespace S\n+    {\n+        enum { A = 1, B = 2 };\n+        namespace T\n+        {\n+            enum { B = 102 };\n+\n+            enum class E1;\n+            enum E2 : int;\n+        }\n+    }\n+\n+    enum class S::T::E1 { A1 = A, B1 = B, C1 };\n+    enum S::T::E2 : int { A1 = A, B1 = B, C1 };\n+\n+    static_assert(int(S::T::E1::A1) == 1, \"error\");\n+    static_assert(int(S::T::E1::B1) == 102, \"error\");\n+    static_assert(int(S::T::E1::C1) == 103, \"error\");\n+\n+    static_assert(int(S::T::E2::A1) == 1, \"error\");\n+    static_assert(int(S::T::E2::B1) == 102, \"error\");\n+    static_assert(int(S::T::E2::C1) == 103, \"error\");\n+    static_assert(int(S::T::A1) == 1, \"error\");\n+    static_assert(int(S::T::B1) == 102, \"error\");\n+    static_assert(int(S::T::C1) == 103, \"error\");\n+}\n+\n+"}, {"sha": "51ef6e43ec72b9e1482d9f3e4ee00aedd2cdbe0a", "filename": "gcc/testsuite/g++.dg/cpp0x/forw_enum6.C", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum6.C?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -0,0 +1,74 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+enum class E1 : int; // { dg-error \"previous definition\" }\n+enum E1 : int;  // { dg-error \"scoped/unscoped mismatch\" }\n+\n+enum E2 : int; // { dg-error \"previous definition\" }\n+enum class E2 : int;  // { dg-error \"scoped/unscoped mismatch\" }\n+\n+enum struct E3 : int;\n+enum class E3 : int; //ok\n+\n+enum class E4 : int; // { dg-error \"previous definition\" }\n+enum class E4 : long;  // { dg-error \"different underlying type\" }\n+\n+enum E5 : int; // { dg-error \"previous definition\" }\n+enum E5 : long;  // { dg-error \"different underlying type\" }\n+\n+enum E6 : int;\n+enum E6 : int; //ok\n+\n+enum class E7;\n+enum class E7 : int; //ok\n+\n+enum class E3 e3; // { dg-warning \"scoped enum must not use\" }\n+enum struct E3 e4; // { dg-warning \"scoped enum must not use\" }\n+enum E5 : int e5; // { dg-error \"expected|invalid type\" }\n+\n+enum E6 : int { a, b, c }; // { dg-error \"previous definition\" }\n+enum E6 : int { a, b, c }; // { dg-error \"multiple definition\" }\n+\n+enum class E7 { }; // { dg-error \"previous definition\" }\n+enum class E7 { a, b, c }; // { dg-error \"multiple definition\" }\n+\n+namespace N1\n+{\n+    struct D;\n+    enum class E6;\n+    enum E7 : int;\n+}\n+\n+enum class N1::E6; // { dg-error \"must use a simple identifier\" }\n+enum N1::E6 e6_1; //ok\n+enum ::N1::E6 e6_2; //ok\n+\n+namespace N2\n+{\n+    enum class N1::E6 { e1, e2, e3 }; // { dg-error \"does not enclose\" }\n+    enum N1::E7 : int { e1, e2, e3 }; // { dg-error \"does not enclose\" }\n+};\n+\n+enum class N1::E6 { e1, e2, e3 };\n+enum N1::E7 : int { e1, e2, e3 };\n+\n+struct S1\n+{\n+    struct D;\n+    enum class E6;\n+    enum E7 : int;\n+};\n+\n+enum class S1::E6; // { dg-error \"must use a simple identifier\" }\n+enum S1::E6 e6_3; //ok\n+enum ::S1::E6 e6_4; //ok\n+\n+struct S2\n+{\n+    enum class S1::E6 { e1, e2, e3 }; // { dg-error \"does not enclose\" }\n+    enum S1::E7 : int { e1, e2, e3 }; // { dg-error \"does not enclose\" }\n+};\n+\n+enum class S1::E6 { e1, e2, e3 };\n+enum S1::E7 : int { e1, e2, e3 };\n+"}, {"sha": "62e445c707b3bfd369b8d381edb28ecaab0818a7", "filename": "gcc/testsuite/g++.dg/cpp0x/forw_enum7.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum7.C?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template<typename T> struct S1\n+{\n+    enum E1 : int;\n+    enum E1 : T;\n+    enum class E2 : int;\n+    enum class E2 : T;\n+};\n+\n+template<typename T> enum S1<T>::E1 : int { e1 };\n+template<typename T> enum class S1<T>::E2 : T { e2 };\n+\n+S1<int>::E1 x1 = S1<int>::e1;\n+S1<int>::E1 x11 = S1<int>::E1::e1;\n+S1<int>::E2 x2 = S1<int>::E2::e2;\n+\n+enum S1<int>::E1 ex1 = S1<int>::e1;\n+enum S1<int>::E1 ex11 = S1<int>::E1::e1;\n+enum S1<int>::E2 ex2 = S1<int>::E2::e2;"}, {"sha": "c87aa5bf65223db725fcf6b91f76cf9c1c1ab37b", "filename": "gcc/testsuite/g++.dg/cpp0x/forw_enum8.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum8.C?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+//This instatiation is ok\n+template<typename T> struct S1\n+{\n+    enum E : int;\n+    enum E : T;\n+};\n+template struct S1<int>; //ok\n+\n+//This error is diagnosed at instantiation time\n+template<typename T> struct S2\n+{\n+    enum E : int;   // { dg-error \"previous definition\" }\n+    enum E : T;     // { dg-error \"different underlying type\" }\n+};\n+template struct S2<short>; // { dg-message \"instantiated from here\" }\n+\n+//This error is diagnosed at compilation time\n+template<typename T> struct S3\n+{\n+    enum E : int;   // { dg-error \"previous definition\" }\n+    enum E : short; // { dg-error \"different underlying type\" }\n+};\n+"}, {"sha": "da8cde27b40a95f8a13406117491c411dbb4b8c7", "filename": "gcc/testsuite/g++.dg/cpp0x/forw_enum9.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum9.C?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template<typename T> struct S1\n+{\n+    enum E1 : int;\n+    enum class E2 : int;\n+};\n+\n+template<typename T> enum S1<T>::E1 : int { e1 };\n+template<typename T> enum class S1<T>::E2 : T { e2 };\n+\n+template<> enum S1<int>::E1 : int { i1 };\n+template<> enum class S1<int>::E2 : int { i2 };\n+\n+S1<char>::E1 xci = S1<char>::e1;\n+S1<int>::E1 xi1 = S1<int>::i1;\n+\n+S1<char>::E2 xc2 = S1<char>::E2::e2;\n+S1<int>::E2 xi2 = S1<int>::E2::i2;\n+"}, {"sha": "c52a3fe769e30342596c94c0818c7cb9174e42d6", "filename": "gcc/testsuite/g++.dg/cpp0x/scoped_enum.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fscoped_enum.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fscoped_enum.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fscoped_enum.C?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -24,7 +24,7 @@ enum class Color3 {\n   Red\n };\n \n-enum class Color color;\n+enum Color color;\n enum Color3 color3;\n \n void f(int);"}, {"sha": "dc07193d389fc39e314bd7745b051435740c2d7b", "filename": "gcc/testsuite/g++.dg/parse/enum3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fenum3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fenum3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fenum3.C?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -1,5 +1,5 @@\n // PR c++/28261\n \n-struct A {};\n+struct A {}; // { dg-error \"A::A\" }\n \n-A::A (enum { e }) {} // { dg-error \"defined|token\" }\n+A::A (enum { e }) {} // { dg-error \"defined|prototype\" }"}, {"sha": "a18eac336b921028b05122e041d01d246badc1ef", "filename": "gcc/testsuite/g++.dg/template/crash79.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash79.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash79.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash79.C?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -4,6 +4,6 @@ struct A\n {\n   A(int);\n   template<int> enum { e }; // { dg-error \"template|expected\" }\n-}; // { dg-error \"expected\" }\n+};\n \n-A a(A::e);\n+A a(A::e); // { dg-error \"not a member\" }"}, {"sha": "d0616e4be554de093d35b3a0b91e251eabe84898", "filename": "gcc/testsuite/g++.old-deja/g++.jason/cond.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fcond.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fcond.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fcond.C?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -40,7 +40,7 @@ int main()\n   // { dg-error \"expected\" \"exp\" { target *-*-* } 39 }\n   \n   if (enum A { one, two, three } foo = one) // { dg-error \"defined\" \"def\" } \n-  // { dg-error \"expected\" \"expected\" { target *-*-* } 42 }\n+  // { dg-error \"not declared\" \"expected\" { target *-*-* } 42 }\n     ;\n \n   struct B { operator int () { return 2; } };"}, {"sha": "968a1bc92ac4341eb904978550357a3a905870f6", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=90ecaf87ff7b69272f0d5a1dd8cbe3a4ec7a9fd8", "patch": "@@ -1166,6 +1166,9 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n /* Used to mark scoped enums.  */\n #define ENUM_IS_SCOPED(NODE) (ENUMERAL_TYPE_CHECK (NODE)->base.static_flag)\n \n+/* Determines whether an ENUMERAL_TYPE has defined the list of constants. */\n+#define ENUM_IS_OPAQUE(NODE) (ENUMERAL_TYPE_CHECK (NODE)->base.private_flag)\n+\n /* In an expr node (usually a conversion) this means the node was made\n    implicitly and should not lead to any sort of warning.  In a decl node,\n    warnings concerning the decl should be suppressed.  This is used at"}]}