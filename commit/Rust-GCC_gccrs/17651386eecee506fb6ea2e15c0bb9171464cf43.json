{"sha": "17651386eecee506fb6ea2e15c0bb9171464cf43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc2NTEzODZlZWNlZTUwNmZiNmVhMmUxNWMwYmI5MTcxNDY0Y2Y0Mw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-11T08:53:34Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-11T08:53:34Z"}, "message": "(build_binary_op): When checking shift widths, don't assume target integer\nfits in a HOST_WIDE_INT.\n\nFrom-SVN: r2106", "tree": {"sha": "e3db093d35bf861c01d0764c4c692dbfe274047d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3db093d35bf861c01d0764c4c692dbfe274047d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17651386eecee506fb6ea2e15c0bb9171464cf43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17651386eecee506fb6ea2e15c0bb9171464cf43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17651386eecee506fb6ea2e15c0bb9171464cf43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17651386eecee506fb6ea2e15c0bb9171464cf43/comments", "author": null, "committer": null, "parents": [{"sha": "2d7243898e983c8df7abc4b51cfe9ef23327f0a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d7243898e983c8df7abc4b51cfe9ef23327f0a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d7243898e983c8df7abc4b51cfe9ef23327f0a9"}], "stats": {"total": 45, "additions": 28, "deletions": 17}, "files": [{"sha": "3181f15f5f2214417092d876f2a02e1bd9e62599", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17651386eecee506fb6ea2e15c0bb9171464cf43/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17651386eecee506fb6ea2e15c0bb9171464cf43/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=17651386eecee506fb6ea2e15c0bb9171464cf43", "patch": "@@ -2347,12 +2347,17 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t{\n \t  if (TREE_CODE (op1) == INTEGER_CST)\n \t    {\n-\t      if (TREE_INT_CST_LOW (op1) > 0)\n-\t\tshort_shift = 1;\n-\t      else if (TREE_INT_CST_LOW (op1) < 0)\n+\t      if (tree_int_cst_lt (op1, integer_zero_node))\n \t\twarning (\"shift count is negative\");\n-\t      if (TREE_INT_CST_LOW (op1) >= TYPE_PRECISION (type0))\n-\t\twarning (\"shift count >= width of type\");\n+\t      else\n+\t\t{\n+\t\t  if (TREE_INT_CST_LOW (op1) | TREE_INT_CST_HIGH (op1))\n+\t\t    short_shift = 1;\n+\t\t  if (TREE_INT_CST_HIGH (op1) != 0\n+\t\t      || ((unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (op1)\n+\t\t\t  >= TYPE_PRECISION (type0)))\n+\t\t    warning (\"shift count >= width of type\");\n+\t\t}\n \t    }\n \t  /* Use the type of the value to be shifted.\n \t     This is what most traditional C compilers do.  */\n@@ -2372,12 +2377,15 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n     case LSHIFT_EXPR:\n       if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)\n \t{\n-\t  if (TREE_CODE (op1) == INTEGER_CST\n-\t      && TREE_INT_CST_LOW (op1) < 0)\n-\t    warning (\"shift count is negative\");\n-\t  if (TREE_CODE (op1) == INTEGER_CST\n-\t      && TREE_INT_CST_LOW (op1) >= TYPE_PRECISION (type0))\n-\t    warning (\"shift count >= width of type\");\n+\t  if (TREE_CODE (op1) == INTEGER_CST)\n+\t    {\n+\t      if (tree_int_cst_lt (op1, integer_zero_node))\n+\t\twarning (\"shift count is negative\");\n+\t      else if (TREE_INT_CST_HIGH (op1) != 0\n+\t\t       || ((unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (op1)\n+\t\t\t   >= TYPE_PRECISION (type0)))\n+\t\twarning (\"shift count >= width of type\");\n+\t    }\n \t  /* Use the type of the value to be shifted.\n \t     This is what most traditional C compilers do.  */\n \t  result_type = type0;\n@@ -2397,12 +2405,15 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n     case LROTATE_EXPR:\n       if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)\n \t{\n-\t  if (TREE_CODE (op1) == INTEGER_CST\n-\t      && TREE_INT_CST_LOW (op1) < 0)\n-\t    warning (\"shift count is negative\");\n-\t  if (TREE_CODE (op1) == INTEGER_CST\n-\t      && TREE_INT_CST_LOW (op1) >= TYPE_PRECISION (type0))\n-\t    warning (\"shift count >= width of type\");\n+\t  if (TREE_CODE (op1) == INTEGER_CST)\n+\t    {\n+\t      if (tree_int_cst_lt (op1, integer_zero_node))\n+\t\twarning (\"shift count is negative\");\n+\t      else if (TREE_INT_CST_HIGH (op1) != 0\n+\t\t       || ((unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (op1)\n+\t\t\t   >= TYPE_PRECISION (type0)))\n+\t\twarning (\"shift count >= width of type\");\n+\t    }\n \t  /* Use the type of the value to be shifted.\n \t     This is what most traditional C compilers do.  */\n \t  result_type = type0;"}]}