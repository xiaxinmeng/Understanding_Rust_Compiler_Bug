{"sha": "a4174ebf41fcfc398b6868b1c71f3172993f76da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQxNzRlYmY0MWZjZmMzOThiNjg2OGIxYzcxZjMxNzI5OTNmNzZkYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2005-07-26T13:53:54Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-07-26T13:53:54Z"}, "message": "calls.c, [...]: Fix comment typos.\n\n\t* calls.c, fold-const.c, ipa-reference.c, ipa-type-escape.c,\n\ttree-ssa-reassoc.c, tree-ssa-structalias.c, vec.h,\n\tconfig/crx/crx.c, config/m32c/m32c.c, config/m32c/m32c.h: Fix\n\tcomment typos.\n\t* doc/c-tree.texi, doc/tree-ssa.texi: Fix typos.\n\nFrom-SVN: r102385", "tree": {"sha": "83ff3048fa7a8e7cb36c934689aa6162ade2a096", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83ff3048fa7a8e7cb36c934689aa6162ade2a096"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4174ebf41fcfc398b6868b1c71f3172993f76da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4174ebf41fcfc398b6868b1c71f3172993f76da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4174ebf41fcfc398b6868b1c71f3172993f76da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4174ebf41fcfc398b6868b1c71f3172993f76da/comments", "author": null, "committer": null, "parents": [{"sha": "783455db8ddf91d0777657edea22b3d285425e59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/783455db8ddf91d0777657edea22b3d285425e59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/783455db8ddf91d0777657edea22b3d285425e59"}], "stats": {"total": 44, "additions": 25, "deletions": 19}, "files": [{"sha": "feeaab36d9d3009c6f7d701b30046f78097c5e8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a4174ebf41fcfc398b6868b1c71f3172993f76da", "patch": "@@ -6,6 +6,12 @@\n \tconfig/crx/crx.c, config/crx/crx.h, config/crx/crx.md: Update\n \tFSF address.\n \n+\t* calls.c, fold-const.c, ipa-reference.c, ipa-type-escape.c,\n+\ttree-ssa-reassoc.c, tree-ssa-structalias.c, vec.h,\n+\tconfig/crx/crx.c, config/m32c/m32c.c, config/m32c/m32c.h: Fix\n+\tcomment typos.\n+\t* doc/c-tree.texi, doc/tree-ssa.texi: Fix typos.\n+\n 2005-07-26  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/22486"}, {"sha": "d51fbf6331bfe8a9ce64d9ca66e2cc7eb1bfd6b1", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=a4174ebf41fcfc398b6868b1c71f3172993f76da", "patch": "@@ -3634,7 +3634,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t\tuse = plus_constant (argblock,\n \t\t\t\t     argvec[argnum].locate.offset.constant);\n \t      else\n-\t\t/* When arguemnts are pushed, trying to tell alias.c where\n+\t\t/* When arguments are pushed, trying to tell alias.c where\n \t\t   exactly this argument is won't work, because the\n \t\t   auto-increment causes confusion.  So we merely indicate\n \t\t   that we access something with a known mode somewhere on"}, {"sha": "32b147d19ee189740a79d11b74358d5ffb6dc703", "filename": "gcc/config/crx/crx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Fconfig%2Fcrx%2Fcrx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Fconfig%2Fcrx%2Fcrx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.c?ref=a4174ebf41fcfc398b6868b1c71f3172993f76da", "patch": "@@ -1409,7 +1409,7 @@ crx_prepare_push_pop_string (int push_or_pop)\n       | | (alloca, variable    deallocated\n   Stack | length arrays).\n   grows +-------------------- Fp(x)\n-  down| | Local vaiables of X\n+  down| | Local variables of X\n   ward| +--------------------\n       | | Regs saved for X-1\n       | +==================== Sp(x-1)=Ap(x)"}, {"sha": "a04d8291095ddd29f9722f18cd5eb43060d4300b", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=a4174ebf41fcfc398b6868b1c71f3172993f76da", "patch": "@@ -1978,7 +1978,7 @@ m32c_asm_integer (rtx x, unsigned int size, int aligned_p)\n \n /* Output of Assembler Instructions */\n \n-/* We use a lookup table because the addressing modes are non-orthagonal.  */\n+/* We use a lookup table because the addressing modes are non-orthogonal.  */\n \n static struct\n {"}, {"sha": "fae6c5c9ffea5a9660101e4abd761a88f0fed0ee", "filename": "gcc/config/m32c/m32c.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Fconfig%2Fm32c%2Fm32c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Fconfig%2Fm32c%2Fm32c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.h?ref=a4174ebf41fcfc398b6868b1c71f3172993f76da", "patch": "@@ -353,7 +353,7 @@ enum reg_class\n #define BASE_REG_CLASS A_REGS\n #define INDEX_REG_CLASS NO_REGS\n \n-/* We primarily use the new \"long\" constraint names, with the intial\n+/* We primarily use the new \"long\" constraint names, with the initial\n    letter classifying the constraint type and following letters\n    specifying which.  The types are:\n "}, {"sha": "0163c5e2f858815c4b92e724f0367e31ec059913", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=a4174ebf41fcfc398b6868b1c71f3172993f76da", "patch": "@@ -1108,15 +1108,15 @@ For garbage collection and dynamic checking purposes, each @code{DECL}\n node structure type is required to have a unique enumerator value\n specified with it.\n For language specific @code{DECL} nodes, this new enumerator value\n-should go in the approriate @file{.def} file.\n+should go in the appropriate @file{.def} file.\n For @code{DECL} nodes that are part of the middle-end, the enumerator\n values are specified in @file{treestruct.def}.\n \n @item Update @code{union tree_node}\n In order to make your new structure type usable, it must be added to\n @code{union tree_node}.\n For language specific @code{DECL} nodes, a new entry should be added\n-to the approriate @file{.h} file of the form\n+to the appropriate @file{.h} file of the form\n @smallexample\n   struct tree_foo_decl GTY ((tag (\"TS_VAR_DECL\"))) foo_decl;\n @end smallexample\n@@ -1130,10 +1130,10 @@ contains one of the enumerated @code{DECL} node structures in the\n hierarchy, a simple lookup table is used.\n This lookup table needs to be kept up to date with the tree structure\n hierarchy, or else checking and containment macros will fail\n-inapproriately.\n+inappropriately.\n \n For language specific @code{DECL} nodes, their is an @code{init_ts}\n-function in an approriate @file{.c} file, which initializes the lookup\n+function in an appropriate @file{.c} file, which initializes the lookup\n table.\n Code setting up the table for new @code{DECL} nodes should be added\n there.\n@@ -1155,7 +1155,7 @@ goes into @file{tree.c}.\n @item Add macros to access any new fields and flags\n \n Each added field or flag should have a macro that is used to access\n-it, that performs approriate checking to ensure only the right type of\n+it, that performs appropriate checking to ensure only the right type of\n @code{DECL} nodes access the field.\n \n These macros generally take the following form"}, {"sha": "cbc08a1cf4dfc231bb32b1b43ef6416708c12a04", "filename": "gcc/doc/tree-ssa.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=a4174ebf41fcfc398b6868b1c71f3172993f76da", "patch": "@@ -436,7 +436,7 @@ the compiler does not know whether such a goto statement exits the\n first sequence or not, so we assume that it doesn't).\n \n After the second sequence is executed, if it completes normally by\n-falling off the end, execution continues whereever the first sequence\n+falling off the end, execution continues wherever the first sequence\n would have continued, by falling off the end, or doing a goto, etc.\n \n @code{TRY_FINALLY_EXPR} complicates the flow graph, since the cleanup"}, {"sha": "a2d6250953a501dcc732b0e2fd17aa14cec3c24b", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a4174ebf41fcfc398b6868b1c71f3172993f76da", "patch": "@@ -6712,7 +6712,7 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t}\n \n       /* Handle (T *)&A.B.C for A being of type T and B and C\n-\t living at offset zero.  This occours frequently in\n+\t living at offset zero.  This occurs frequently in\n \t C++ upcasting and then accessing the base.  */\n       if (TREE_CODE (op0) == ADDR_EXPR\n \t  && POINTER_TYPE_P (type)"}, {"sha": "f2f9252e8ac26ba79cfb55afc96b2a63386f285e", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=a4174ebf41fcfc398b6868b1c71f3172993f76da", "patch": "@@ -592,7 +592,7 @@ get_static_decl (int index)\n }\n \n /* Lookup the tree node for the static variable that has UID and\n-   conver the name to a string for debugging.  */\n+   convert the name to a string for debugging.  */\n \n static const char *\n get_static_name (int index)"}, {"sha": "19a2a1e08b59bf8793d64d8eb10477c56d1f761a", "filename": "gcc/ipa-type-escape.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Fipa-type-escape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Fipa-type-escape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.c?ref=a4174ebf41fcfc398b6868b1c71f3172993f76da", "patch": "@@ -487,7 +487,7 @@ mark_type (tree type, enum escape_t escape_status)\n       bitmap_set_bit (map, uid);\n       if (escape_status == FULL_ESCAPE)\n \t{\n-\t  /* Effeciency hack. When things are bad, do not mess around\n+\t  /* Efficiency hack. When things are bad, do not mess around\n \t     with this type anymore.  */\n \t  bitmap_set_bit (global_types_exposed_parameter, uid);\n \t}      \n@@ -1461,7 +1461,7 @@ close_type_seen (tree type)\n     return;\n   bitmap_set_bit (been_there_done_that, uid);\n \n-  /* If we are doing a language with a type heirarchy, mark all of\n+  /* If we are doing a language with a type hierarchy, mark all of\n      the superclasses.  */\n   if (TYPE_BINFO (type)) \n     for (binfo = TYPE_BINFO (type), i = 0;\n@@ -1568,7 +1568,7 @@ close_type_full_escape (tree type)\n \n   subtype_map = subtype_map_for_uid (uid, false);\n \n-  /* If we are doing a language with a type heirarchy, mark all of\n+  /* If we are doing a language with a type hierarchy, mark all of\n      the superclasses.  */\n   if (TYPE_BINFO (type)) \n     for (binfo = TYPE_BINFO (type), i = 0;"}, {"sha": "5514c3d355e0c199ec0f5fe719734975a58d2307", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=a4174ebf41fcfc398b6868b1c71f3172993f76da", "patch": "@@ -435,7 +435,7 @@ reassociate_expr (tree bexpr, block_stmt_iterator *currbsi)\n   unsigned int lhsrank = get_rank (lhs);\n   unsigned int rhsrank = get_rank (rhs);\n \n-  /* If unsafe math optimizations we can do reassociation for non integal\n+  /* If unsafe math optimizations we can do reassociation for non-integral\n      types.  */\n   if ((!INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n        || !INTEGRAL_TYPE_P (TREE_TYPE (rhs)))"}, {"sha": "76ce7ab83c054528735cb47a37589b91ccc08e80", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=a4174ebf41fcfc398b6868b1c71f3172993f76da", "patch": "@@ -2718,7 +2718,7 @@ update_alias_info (tree stmt, struct alias_info *ai)\n    1- If the constraint for PTR is ADDRESSOF for a non-structure\n       variable, then we can use it directly because adding or\n       subtracting a constant may not alter the original ADDRESSOF\n-      constraing (i.e., pointer arithmetic may not legally go outside\n+      constraint (i.e., pointer arithmetic may not legally go outside\n       an object's boundaries).\n \n    2- If the constraint for PTR is ADDRESSOF for a structure variable,\n@@ -3324,7 +3324,7 @@ find_what_p_points_to (tree p)\n \t      if (vi->is_artificial_var)\n \t\t{\n \t\t  /* FIXME.  READONLY should be handled better so that\n-\t\t     flow insensitive aliasing can disregard writeable\n+\t\t     flow insensitive aliasing can disregard writable\n \t\t     aliases.  */\n \t\t  if (vi->id == nothing_id)\n \t\t    pi->pt_null = 1;"}, {"sha": "14fcda4c27102b8bdef7225eb1a613975756a00d", "filename": "gcc/vec.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4174ebf41fcfc398b6868b1c71f3172993f76da/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=a4174ebf41fcfc398b6868b1c71f3172993f76da", "patch": "@@ -218,7 +218,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    VEC(T,A) *VEC_T_A_copy(VEC(T) *);\n \n    Copy the live elements of a vector into a new vector.  The new and\n-   old vectors need not be allocated by the same mechanim.  */\n+   old vectors need not be allocated by the same mechanism.  */\n \n #define VEC_copy(T,A,V) (VEC_OP(T,A,copy)(VEC_BASE(V) MEM_STAT_INFO))\n "}]}