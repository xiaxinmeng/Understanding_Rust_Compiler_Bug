{"sha": "d7438551ff5ffa0afeca2aa3efd13035b26bee34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc0Mzg1NTFmZjVmZmEwYWZlY2EyYWEzZWZkMTMwMzViMjZiZWUzNA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2015-06-05T18:44:53Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2015-06-05T18:44:53Z"}, "message": "Merge debug-early branch into mainline.\n\n\t* dwarf2out.c: Remove deferred_locations*.\n\t(dwarf2_debug_hooks): Add early_finish hook.\n\tRemove global_decl hook.\n\tAdd early_global_decl and late_global_decl hook.\n\tNew global early_dwarf.\n\tNew structure set_early_dwarf.\n\t(output_die): Indicate whether a DIE was generated early\n\twhen generating assembly with -dA.\n\t(struct limbo_die_struct): Document created_for field.\n\tRemove file_table_last_lookup.\n\t(remove_AT): Return TRUE if successful.\n\t(remove_child_TAG): Clear die_parent.\n\t(reparent_child): New function abstracted from...\n\t(splice_child_die): ...here.\n\t(new_die): ICE if a DIE ends up in limbo too late.\n\t(check_die): New.\n\t(defer_location): Remove.\n\t(add_subscript_info): Reuse DW_TAG_subrange_type if available.\n\t(fill_variable_array_bounds): New.\n\t(decl_start_label): Call fill_variable_array_bounds.\n\t(gen_formal_parameter_die): Rewrite to reuse previously generated\n\tDIEs.\n\t(gen_subprogram_die): Same.\n\t(gen_variable_die): Same.\n\t(gen_const_die): Same.\n\t(gen_label_die): Same.\n\t(gen_lexical_block_die): Same.\n\t(decl_will_get_specification_p): New.\n\t(local_function_static): New.\n\t(gen_struct_or_union_type_die): Fill in variable-length fields.\n\t(gen_typedef_die): Fill in variable-length typedefs.\n\t(gen_tagged_type_die): Gracefully return on error_mark_node.\n\tHandle re-entrancy.\n\t(gen_type_die_with_usage): Handle variable-length types.\n\tRemove duplicate code for ARRAY_TYPE case.\n\t(process_scope_var): Only process imported modules during early\n\tdwarf.\n\t(dwarf2out_early_global_decl): New.\n\t(dwarf2out_late_global_decl): Rename from dwarf2out_global_decl.\n\t(dwarf2out_type_decl): Set early_dwarf while calling\n\tdwarf2out_decl.\n\t(dwarf2out_decl): Verify that we did not recreate a previously\n\tgenerated DIE.\n\tDo not return on DECL_EXTERNALs in VAR_DECLs.\n\tAbstract some code to local_function_static.\n\t(lookup_filename): Remove use of file_table_last_lookup.\n\tGracefully exit on missing file_name.\n\t(dwarf2out_finish): Verify limbo list.\n\tRemove deferred_locations_list use.\n\tMove deferred_asm_name and limbo flushing to...\n\t(dwarf2out_early_finish): ...here.  New.\n\t(dwarf2out_c_finalize): Remove set of deferred_location_list,\n\tdeferred_asm_name, and file_table_last_lookup.\n\t* cgraph.h (referred_to_p): Add default argument.\n\t* cgraphunit.c (referred_to_p): Add and handle include_self\n\targument.\n\t(analyze_functions): Add first_time argument.\n\tCall check_global_declaration for all symbols.\n\tCall late_global_decl for nodes for moribund nodes.\n\t(finalize_compilation_unit): Add new argument to\n\tanalyze_functions.\n\tCall early_global_decl for functions.\n\tCall early_finish debug hook.\n\t* dbxout.c (dbxout_early_global_decl): New.\n\t(dbxout_late_global_decl): New.  Adapted from dbxout_global_decl.\n\t(dbx_debug_hooks): Add new hooks.\n\t(xcoff_debug_hooks): Same.\n\t* debug.c (do_nothing_debug_hooks): Add early_finish field.\n\tAdd early and late debug hooks.\n\tRemove global_decl hook.\n\t* debug.h (struct gcc_debug_hooks): Add early_finish,\n\tearly_global_decl, and late_global_decl fields.\n\tRemove global_decl field.\n\tDocument gcc_debug_hooks.\n\t* gengtype.c (output_typename): Remove.\n\t* godump.c (go_early_global_decl): New.\n\t(go_late_global_decl): New.\n\t(go_global_decl): Remove.\n\t(dump_go_spec_init): Remove global_decl.  Add\n\t{early,late}_global_decl.\n\t* langhooks-def.h (LANG_HOOKS_WRITE_GLOBALS): Remove.\n\t(LANG_HOOKS_POST_COMPILATION_PARSING_CLEANUPS): New.\n\t* langhooks.c (lhd_warn_unused_global_decl): Adjust comment.\n\t(write_global_declarations): Remove.\n\t(global_decl_processing): New.\n\t* langhooks.h (struct lang_hooks_for_decls): Remove\n\tfinal_write_globals field.\n\tAdd post_compilation_parsing_cleanups field.\n\t* passes.c (rest_of_decl_compilation): Call early_global_decl.\n\t* sdbout.c: Add early and late_global_decl hooks.  Remove\n\tsdbout_global_decl hook.\n\tAdd early_finish field for sdb_debug_hooks.\n\t(sdbout_global_decl): Remove.\n\t(sdbout_early_global_decl): New.\n\t(sdbout_late_global_decl): New.\n\t* timevar.def (TV_PHASE_LATE_PARSING_CLEANUPS): New.\n\t* toplev.c (check_global_declaration): Rename from\n\tcheck_global_declaration_1.\n\tAdapt to use symtab infrastructure.\n\t(check_global_declarations): Remove.\n\t(emit_debug_global_declarations): Remove.\n\t(compile_file): Remove call to final_write_globals langhook.\n\tRun the actual compilation process.\n\tPerform any post compilation parser cleanups.\n\tGenerate late debug info.\n\t* toplev.h (check_global_declaration): New.\n\t(check_global_declaration_1): Remove.\n\t(check_global_declarations): Remove.\n\t(write_global_declarations): Remove.\n\t(emit_debug_global_declarations): Remove.\n\t(global_decl_processing): New.\n\t* tree-core.h (struct tree_block): Add DIE field.\n\t* tree.h (BLOCK_DIE): New.\n\t* vmsdbgout.c (vmsdbgout_global_decl): Remove function and its use\n\tthroughout.\n\t(vmsdbgout_early_global_decl): New.\n\t(vmsdbgout_late_global_decl): New.\n\tAdd early_finish debug hook field to vmsdbg_debug_hooks.\n\tRemove vmsdbgout_decl to vmsdbgout_function_decl.\n\tAdd early and late_global_decl debug hooks.\n\nFrom-SVN: r224161", "tree": {"sha": "906774b04a2315e6e0109ec866407a4b6ee1195f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/906774b04a2315e6e0109ec866407a4b6ee1195f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7438551ff5ffa0afeca2aa3efd13035b26bee34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7438551ff5ffa0afeca2aa3efd13035b26bee34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7438551ff5ffa0afeca2aa3efd13035b26bee34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7438551ff5ffa0afeca2aa3efd13035b26bee34/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "46ba128114d3fd892b94c3767fb7a681088c7d79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46ba128114d3fd892b94c3767fb7a681088c7d79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46ba128114d3fd892b94c3767fb7a681088c7d79"}], "stats": {"total": 2070, "additions": 1414, "deletions": 656}, "files": [{"sha": "69cb8f9d1cc9f493d99adcbee7eed461c0318502", "filename": "gcc/ChangeLog", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -1,3 +1,126 @@\n+2015-06-05  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* dwarf2out.c: Remove deferred_locations*.\n+\t(dwarf2_debug_hooks): Add early_finish hook.\n+\tRemove global_decl hook.\n+\tAdd early_global_decl and late_global_decl hook.\n+\tNew global early_dwarf.\n+\tNew structure set_early_dwarf.\n+\t(output_die): Indicate whether a DIE was generated early\n+\twhen generating assembly with -dA.\n+\t(struct limbo_die_struct): Document created_for field.\n+\tRemove file_table_last_lookup.\n+\t(remove_AT): Return TRUE if successful.\n+\t(remove_child_TAG): Clear die_parent.\n+\t(reparent_child): New function abstracted from...\n+\t(splice_child_die): ...here.\n+\t(new_die): ICE if a DIE ends up in limbo too late.\n+\t(check_die): New.\n+\t(defer_location): Remove.\n+\t(add_subscript_info): Reuse DW_TAG_subrange_type if available.\n+\t(fill_variable_array_bounds): New.\n+\t(decl_start_label): Call fill_variable_array_bounds.\n+\t(gen_formal_parameter_die): Rewrite to reuse previously generated\n+\tDIEs.\n+\t(gen_subprogram_die): Same.\n+\t(gen_variable_die): Same.\n+\t(gen_const_die): Same.\n+\t(gen_label_die): Same.\n+\t(gen_lexical_block_die): Same.\n+\t(decl_will_get_specification_p): New.\n+\t(local_function_static): New.\n+\t(gen_struct_or_union_type_die): Fill in variable-length fields.\n+\t(gen_typedef_die): Fill in variable-length typedefs.\n+\t(gen_tagged_type_die): Gracefully return on error_mark_node.\n+\tHandle re-entrancy.\n+\t(gen_type_die_with_usage): Handle variable-length types.\n+\tRemove duplicate code for ARRAY_TYPE case.\n+\t(process_scope_var): Only process imported modules during early\n+\tdwarf.\n+\t(dwarf2out_early_global_decl): New.\n+\t(dwarf2out_late_global_decl): Rename from dwarf2out_global_decl.\n+\t(dwarf2out_type_decl): Set early_dwarf while calling\n+\tdwarf2out_decl.\n+\t(dwarf2out_decl): Verify that we did not recreate a previously\n+\tgenerated DIE.\n+\tDo not return on DECL_EXTERNALs in VAR_DECLs.\n+\tAbstract some code to local_function_static.\n+\t(lookup_filename): Remove use of file_table_last_lookup.\n+\tGracefully exit on missing file_name.\n+\t(dwarf2out_finish): Verify limbo list.\n+\tRemove deferred_locations_list use.\n+\tMove deferred_asm_name and limbo flushing to...\n+\t(dwarf2out_early_finish): ...here.  New.\n+\t(dwarf2out_c_finalize): Remove set of deferred_location_list,\n+\tdeferred_asm_name, and file_table_last_lookup.\n+\t* cgraph.h (referred_to_p): Add default argument.\n+\t* cgraphunit.c (referred_to_p): Add and handle include_self\n+\targument.\n+\t(analyze_functions): Add first_time argument.\n+\tCall check_global_declaration for all symbols.\n+\tCall late_global_decl for nodes for moribund nodes.\n+\t(finalize_compilation_unit): Add new argument to\n+\tanalyze_functions.\n+\tCall early_global_decl for functions.\n+\tCall early_finish debug hook.\n+\t* dbxout.c (dbxout_early_global_decl): New.\n+\t(dbxout_late_global_decl): New.  Adapted from dbxout_global_decl.\n+\t(dbx_debug_hooks): Add new hooks.\n+\t(xcoff_debug_hooks): Same.\n+\t* debug.c (do_nothing_debug_hooks): Add early_finish field.\n+\tAdd early and late debug hooks.\n+\tRemove global_decl hook.\n+\t* debug.h (struct gcc_debug_hooks): Add early_finish,\n+\tearly_global_decl, and late_global_decl fields.\n+\tRemove global_decl field.\n+\tDocument gcc_debug_hooks.\n+\t* gengtype.c (output_typename): Remove.\n+\t* godump.c (go_early_global_decl): New.\n+\t(go_late_global_decl): New.\n+\t(go_global_decl): Remove.\n+\t(dump_go_spec_init): Remove global_decl.  Add\n+\t{early,late}_global_decl.\n+\t* langhooks-def.h (LANG_HOOKS_WRITE_GLOBALS): Remove.\n+\t(LANG_HOOKS_POST_COMPILATION_PARSING_CLEANUPS): New.\n+\t* langhooks.c (lhd_warn_unused_global_decl): Adjust comment.\n+\t(write_global_declarations): Remove.\n+\t(global_decl_processing): New.\n+\t* langhooks.h (struct lang_hooks_for_decls): Remove\n+\tfinal_write_globals field.\n+\tAdd post_compilation_parsing_cleanups field.\n+\t* passes.c (rest_of_decl_compilation): Call early_global_decl.\n+\t* sdbout.c: Add early and late_global_decl hooks.  Remove\n+\tsdbout_global_decl hook.\n+\tAdd early_finish field for sdb_debug_hooks.\n+\t(sdbout_global_decl): Remove.\n+\t(sdbout_early_global_decl): New.\n+\t(sdbout_late_global_decl): New.\n+\t* timevar.def (TV_PHASE_LATE_PARSING_CLEANUPS): New.\n+\t* toplev.c (check_global_declaration): Rename from\n+\tcheck_global_declaration_1.\n+\tAdapt to use symtab infrastructure.\n+\t(check_global_declarations): Remove.\n+\t(emit_debug_global_declarations): Remove.\n+\t(compile_file): Remove call to final_write_globals langhook.\n+\tRun the actual compilation process.\n+\tPerform any post compilation parser cleanups.\n+\tGenerate late debug info.\n+\t* toplev.h (check_global_declaration): New.\n+\t(check_global_declaration_1): Remove.\n+\t(check_global_declarations): Remove.\n+\t(write_global_declarations): Remove.\n+\t(emit_debug_global_declarations): Remove.\n+\t(global_decl_processing): New.\n+\t* tree-core.h (struct tree_block): Add DIE field.\n+\t* tree.h (BLOCK_DIE): New.\n+\t* vmsdbgout.c (vmsdbgout_global_decl): Remove function and its use\n+\tthroughout.\n+\t(vmsdbgout_early_global_decl): New.\n+\t(vmsdbgout_late_global_decl): New.\n+\tAdd early_finish debug hook field to vmsdbg_debug_hooks.\n+\tRemove vmsdbgout_decl to vmsdbgout_function_decl.\n+\tAdd early and late_global_decl debug hooks.\n+\n 2015-06-05  Julian Brown  <julian@codesourcery.com>\n \t    Sandra Loosemore  <sandra@codesourcery.com>\n "}, {"sha": "e58d7af9b3ff0c94c9af540dcc0fafee0cca4cd0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -1,3 +1,17 @@\n+2015-06-05  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* gcc-interface/gigi.h (note_types_used_by_globals): Rename from\n+\tgnat_write_global_declarations.\n+\t* gcc-interface/misc.c (gnat_parse_file): Call\n+\tnote_types_used_by_globals.\n+\tRemove LANG_HOOKS_WRITE_GLOBALS.\n+\t* gcc-interface/utils.c: Rename global_decls to type_decls.\n+\t(gnat_write_global_declarations): Rename\n+\tto note_types_used_by_globals.\n+\tRemove call to finalize_compilation_unit.\n+\tRemove debug_hooks->global_decl() call for globals.\n+\t(gnat_pushdecls): Only insert into type_decls if TYPE_DECL.\n+\n 2015-06-04  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* gcc-interface/cuintp.c: Adjust includes for restructured coretypes.h."}, {"sha": "42e2cfb55be782a608767d7aeefc533fec94440f", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -5185,6 +5185,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       && !Present (Alias (gnat_entity))\n       && !(Present (Renamed_Object (gnat_entity)) && saved))\n     {\n+      /* ?? DECL_ARTIFICIAL, and possibly DECL_IGNORED_P below, should\n+\t be set before calling rest_of_decl_compilation above (through\n+\t create_var_decl_1).  This is because rest_of_decl_compilation\n+\t calls the debugging backend and will create a DIE without\n+\t DW_AT_artificial.\n+\n+\t This is currently causing gnat.dg/specs/debug1.ads to FAIL.  */\n       if (!Comes_From_Source (gnat_entity))\n \tDECL_ARTIFICIAL (gnu_decl) = 1;\n "}, {"sha": "b85f3512d40b138233492b51f428ecce57cbf721", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -531,8 +531,9 @@ extern tree gnat_type_for_size (unsigned precision, int unsignedp);\n    an unsigned type; otherwise a signed type is returned.  */\n extern tree gnat_type_for_mode (machine_mode mode, int unsignedp);\n \n-/* Emit debug info for all global variable declarations.  */\n-extern void gnat_write_global_declarations (void);\n+/* Keep track of types used at the global level and emit debug info\n+   for all global types.  */\n+extern void note_types_used_by_globals (void);\n \n /* Return the unsigned version of a TYPE_NODE, a scalar type.  */\n extern tree gnat_unsigned_type (tree type_node);"}, {"sha": "2eef7df63a7d23fc1407f852706ef427c71b30e1", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -117,6 +117,8 @@ gnat_parse_file (void)\n \n   /* Call the front end.  */\n   _ada_gnat1drv ();\n+\n+  note_types_used_by_globals ();\n }\n \n /* Return language mask for option processing.  */\n@@ -969,8 +971,6 @@ gnat_init_ts (void)\n #define LANG_HOOKS_GETDECLS\t\tlhd_return_null_tree_v\n #undef  LANG_HOOKS_PUSHDECL\n #define LANG_HOOKS_PUSHDECL\t\tgnat_return_tree\n-#undef  LANG_HOOKS_WRITE_GLOBALS\n-#define LANG_HOOKS_WRITE_GLOBALS\tgnat_write_global_declarations\n #undef  LANG_HOOKS_GET_ALIAS_SET\n #define LANG_HOOKS_GET_ALIAS_SET\tgnat_get_alias_set\n #undef  LANG_HOOKS_PRINT_DECL"}, {"sha": "307a84104844348d0de644cab54068e773a05cdf", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -224,8 +224,8 @@ static GTY((deletable)) struct gnat_binding_level *free_binding_level;\n /* The context to be used for global declarations.  */\n static GTY(()) tree global_context;\n \n-/* An array of global declarations.  */\n-static GTY(()) vec<tree, va_gc> *global_decls;\n+/* An array of global type declarations.  */\n+static GTY(()) vec<tree, va_gc> *type_decls;\n \n /* An array of builtin function declarations.  */\n static GTY(()) vec<tree, va_gc> *builtin_decls;\n@@ -756,7 +756,10 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \t    vec_safe_push (builtin_decls, decl);\n \t}\n       else if (global_bindings_p ())\n-\tvec_safe_push (global_decls, decl);\n+\t{\n+\t  if (TREE_CODE (decl) == TYPE_DECL)\n+\t    vec_safe_push (type_decls, decl);\n+\t}\n       else\n \t{\n \t  DECL_CHAIN (decl) = BLOCK_VARS (current_binding_level->block);\n@@ -5183,8 +5186,11 @@ smaller_form_type_p (tree type, tree orig_type)\n \n static GTY (()) tree dummy_global;\n \n+/* Keep track of types used at the global level and emit debug info\n+   for all global types.  */\n+\n void\n-gnat_write_global_declarations (void)\n+note_types_used_by_globals (void)\n {\n   unsigned int i;\n   tree iter;\n@@ -5214,26 +5220,12 @@ gnat_write_global_declarations (void)\n     }\n \n   /* Output debug information for all global type declarations first.  This\n-     ensures that global types whose compilation hasn't been finalized yet,\n+     ensures that global types whose compilation haven't been finalized yet,\n      for example pointers to Taft amendment types, have their compilation\n      finalized in the right context.  */\n-  FOR_EACH_VEC_SAFE_ELT (global_decls, i, iter)\n-    if (TREE_CODE (iter) == TYPE_DECL && !DECL_IGNORED_P (iter))\n+  FOR_EACH_VEC_SAFE_ELT (type_decls, i, iter)\n+    if (!DECL_IGNORED_P (iter))\n       debug_hooks->type_decl (iter, false);\n-\n-  /* Proceed to optimize and emit assembly. */\n-  symtab->finalize_compilation_unit ();\n-\n-  /* After cgraph has had a chance to emit everything that's going to\n-     be emitted, output debug information for the rest of globals.  */\n-  if (!seen_error ())\n-    {\n-      timevar_push (TV_SYMOUT);\n-      FOR_EACH_VEC_SAFE_ELT (global_decls, i, iter)\n-\tif (TREE_CODE (iter) != TYPE_DECL && !DECL_IGNORED_P (iter))\n-\t  debug_hooks->global_decl (iter);\n-      timevar_pop (TV_SYMOUT);\n-    }\n }\n \n /* ************************************************************************"}, {"sha": "6de6af54e07aa4886ad12c5e6ec67b6c60d4ba34", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -1,3 +1,8 @@\n+2015-06-05  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* c-common.h (c_parse_final_cleanups): New prototype.\n+\t* c-opts.c (c_common_parse_file): Call c_parse_final_cleanups.\n+\n 2015-06-04  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* array-notation-common.c: Adjust includes for restructured coretypes.h."}, {"sha": "af86e2687758fd870ddc3d35d70b336918f1fa49", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -887,6 +887,8 @@ extern HOST_WIDE_INT c_common_to_target_charset (HOST_WIDE_INT);\n /* This is the basic parsing function.  */\n extern void c_parse_file (void);\n \n+extern void c_parse_final_cleanups (void);\n+\n extern void warn_for_omitted_condop (location_t, tree);\n \n /* These macros provide convenient access to the various _STMT nodes.  */"}, {"sha": "971f5ebdd6af9a3b4cd358ea24fa8b16460b4316", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -1087,6 +1087,8 @@ c_common_parse_file (void)\n       if (!this_input_filename)\n \tbreak;\n     }\n+\n+  c_parse_final_cleanups ();\n }\n \n /* Returns the appropriate dump file for PHASE to dump with FLAGS.  */"}, {"sha": "d37a3ab09f1e160338be95323b0f38dd9e798cea", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -1,3 +1,17 @@\n+2015-06-05  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* c-decl.c (finish_struct): Save C_TYPE_INCOMPLETE_VARS and\n+\timmediately clobber it.\n+\t(c_write_global_declarations_1): Remove call to\n+\tcheck_global_declaration_1.\n+\t(c_write_global_declarations_2): Remove.\n+\t(c_write_final_cleanups): Rename from c_write_global_declarations.\n+\tRemove call to finalize_compilation_unit.\n+\tRemove calls to debugging hooks.\n+\t* c-objc-common.c: Adjust comment for c_warn_unused_global_decl.\n+\t* c-objc-common.h: Remove LANG_HOOKS_WRITE_GLOBALS.\n+\t* c-tree.h: Remove c_write_global_declarations.\n+\n 2015-06-04  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* c-array-notation.c: Adjust includes for restructured coretypes.h."}, {"sha": "77d1de9adbb073e37bc16b71f723f614c74b9408", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 22, "deletions": 46, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -7837,10 +7837,18 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n     }\n \n   /* If this structure or union completes the type of any previous\n-     variable declaration, lay it out and output its rtl.  */\n-  for (x = C_TYPE_INCOMPLETE_VARS (TYPE_MAIN_VARIANT (t));\n-       x;\n-       x = TREE_CHAIN (x))\n+     variable declaration, lay it out and output its rtl.\n+\n+     Note: C_TYPE_INCOMPLETE_VARS overloads TYPE_VFIELD which is used\n+     in dwarf2out via rest_of_decl_compilation below and means\n+     something totally different.  Since we will be clearing\n+     C_TYPE_INCOMPLETE_VARS shortly after we iterate through them,\n+     clear it ahead of time and avoid problems in dwarf2out.  Ideally,\n+     C_TYPE_INCOMPLETE_VARS should use some language specific\n+     node.  */\n+  tree incomplete_vars = C_TYPE_INCOMPLETE_VARS (TYPE_MAIN_VARIANT (t));\n+  C_TYPE_INCOMPLETE_VARS (TYPE_MAIN_VARIANT (t)) = 0;\n+  for (x = incomplete_vars; x; x = TREE_CHAIN (x))\n     {\n       tree decl = TREE_VALUE (x);\n       if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n@@ -7853,7 +7861,6 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \t  rest_of_decl_compilation (decl, toplevel, 0);\n \t}\n     }\n-  C_TYPE_INCOMPLETE_VARS (TYPE_MAIN_VARIANT (t)) = 0;\n \n   /* Update type location to the one of the definition, instead of e.g.\n      a forward declaration.  */\n@@ -10679,9 +10686,8 @@ finish_declspecs (struct c_declspecs *specs)\n   return specs;\n }\n \n-/* A subroutine of c_write_global_declarations.  Perform final processing\n-   on one file scope's declarations (or the external scope's declarations),\n-   GLOBALS.  */\n+/* Perform final processing on one file scope's declarations (or the\n+   external scope's declarations), GLOBALS.  */\n \n static void\n c_write_global_declarations_1 (tree globals)\n@@ -10694,7 +10700,7 @@ c_write_global_declarations_1 (tree globals)\n     {\n       /* Check for used but undefined static functions using the C\n \t standard's definition of \"used\", and set TREE_NO_WARNING so\n-\t that check_global_declarations doesn't repeat the check.  */\n+\t that check_global_declaration doesn't repeat the check.  */\n       if (TREE_CODE (decl) == FUNCTION_DECL\n \t  && DECL_INITIAL (decl) == 0\n \t  && DECL_EXTERNAL (decl)\n@@ -10715,21 +10721,6 @@ c_write_global_declarations_1 (tree globals)\n \treconsider |= wrapup_global_declaration_2 (decl);\n     }\n   while (reconsider);\n-\n-  for (decl = globals; decl; decl = DECL_CHAIN (decl))\n-    check_global_declaration_1 (decl);\n-}\n-\n-/* A subroutine of c_write_global_declarations Emit debug information for each\n-   of the declarations in GLOBALS.  */\n-\n-static void\n-c_write_global_declarations_2 (tree globals)\n-{\n-  tree decl;\n-\n-  for (decl = globals; decl ; decl = DECL_CHAIN (decl))\n-    debug_hooks->global_decl (decl);\n }\n \n /* Callback to collect a source_ref from a DECL.  */\n@@ -10779,8 +10770,11 @@ for_each_global_decl (void (*callback) (tree decl))\n     callback (decl);\n }\n \n+/* Perform any final parser cleanups and generate initial debugging\n+   information.  */\n+\n void\n-c_write_global_declarations (void)\n+c_parse_final_cleanups (void)\n {\n   tree t;\n   unsigned i;\n@@ -10789,6 +10783,7 @@ c_write_global_declarations (void)\n   if (pch_file)\n     return;\n \n+  timevar_stop (TV_PHASE_PARSING);\n   timevar_start (TV_PHASE_DEFERRED);\n \n   /* Do the Objective-C stuff.  This is where all the Objective-C\n@@ -10827,34 +10822,15 @@ c_write_global_declarations (void)\n     }\n \n   /* Process all file scopes in this compilation, and the external_scope,\n-     through wrapup_global_declarations and check_global_declarations.  */\n+     through wrapup_global_declarations.  */\n   FOR_EACH_VEC_ELT (*all_translation_units, i, t)\n     c_write_global_declarations_1 (BLOCK_VARS (DECL_INITIAL (t)));\n   c_write_global_declarations_1 (BLOCK_VARS (ext_block));\n \n   timevar_stop (TV_PHASE_DEFERRED);\n-  timevar_start (TV_PHASE_OPT_GEN);\n-\n-  /* We're done parsing; proceed to optimize and emit assembly.\n-     FIXME: shouldn't be the front end's responsibility to call this.  */\n-  symtab->finalize_compilation_unit ();\n-\n-  timevar_stop (TV_PHASE_OPT_GEN);\n-  timevar_start (TV_PHASE_DBGINFO);\n-\n-  /* After cgraph has had a chance to emit everything that's going to\n-     be emitted, output debug information for globals.  */\n-  if (!seen_error ())\n-    {\n-      timevar_push (TV_SYMOUT);\n-      FOR_EACH_VEC_ELT (*all_translation_units, i, t)\n-\tc_write_global_declarations_2 (BLOCK_VARS (DECL_INITIAL (t)));\n-      c_write_global_declarations_2 (BLOCK_VARS (ext_block));\n-      timevar_pop (TV_SYMOUT);\n-    }\n+  timevar_start (TV_PHASE_PARSING);\n \n   ext_block = NULL;\n-  timevar_stop (TV_PHASE_DBGINFO);\n }\n \n /* Register reserved keyword WORD as qualifier for address space AS.  */"}, {"sha": "68ba65f2e0374598a76d6dee94192d68061f089f", "filename": "gcc/c/c-objc-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-objc-common.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -49,7 +49,7 @@ c_missing_noreturn_ok_p (tree decl)\n   return flag_hosted && MAIN_NAME_P (DECL_ASSEMBLER_NAME (decl));\n }\n \n-/* Called from check_global_declarations.  */\n+/* Called from check_global_declaration.  */\n \n bool\n c_warn_unused_global_decl (const_tree decl)"}, {"sha": "50c9f54998c44f725d527eb3e7f479de2ca0b71f", "filename": "gcc/c/c-objc-common.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fc%2Fc-objc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fc%2Fc-objc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-objc-common.h?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -92,8 +92,6 @@ along with GCC; see the file COPYING3.  If not see\n \n #undef LANG_HOOKS_GETDECLS\n #define LANG_HOOKS_GETDECLS lhd_return_null_tree_v\n-#undef LANG_HOOKS_WRITE_GLOBALS\n-#define LANG_HOOKS_WRITE_GLOBALS c_write_global_declarations\n \n /* Hooks for tree gimplification.  */\n #undef LANG_HOOKS_GIMPLIFY_EXPR"}, {"sha": "28b58c636e46cefef9f5b430149b02d8ee88ce22", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -695,7 +695,6 @@ typedef void c_binding_oracle_function (enum c_oracle_request, tree identifier);\n extern c_binding_oracle_function *c_binding_oracle;\n \n extern void c_finish_incomplete_decl (tree);\n-extern void c_write_global_declarations (void);\n extern tree c_omp_reduction_id (enum tree_code, tree);\n extern tree c_omp_reduction_decl (tree);\n extern tree c_omp_reduction_lookup (tree, tree);"}, {"sha": "55864a279485e23c0c6d3f9bb1e647b77b97c63d", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -314,7 +314,7 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   bool needed_p (void);\n \n   /* Return true when there are references to the node.  */\n-  bool referred_to_p (void);\n+  bool referred_to_p (bool include_self = true);\n \n   /* Return true if NODE can be discarded by linker from the binary.  */\n   inline bool"}, {"sha": "722c4f4d0634d1c18ebd2de91f89d6c9ac61e0d1", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 47, "deletions": 6, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -403,10 +403,11 @@ cgraph_node::reset (void)\n   remove_all_references ();\n }\n \n-/* Return true when there are references to the node.  */\n+/* Return true when there are references to the node.  INCLUDE_SELF is\n+   true if a self reference counts as a reference.  */\n \n bool\n-symtab_node::referred_to_p (void)\n+symtab_node::referred_to_p (bool include_self)\n {\n   ipa_ref *ref = NULL;\n \n@@ -416,7 +417,13 @@ symtab_node::referred_to_p (void)\n   /* For functions check also calls.  */\n   cgraph_node *cn = dyn_cast <cgraph_node *> (this);\n   if (cn && cn->callers)\n-    return true;\n+    {\n+      if (include_self)\n+\treturn true;\n+      for (cgraph_edge *e = cn->callers; e; e = e->next_caller)\n+\tif (e->caller != this)\n+\t  return true;\n+    }\n   return false;\n }\n \n@@ -924,8 +931,12 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n static cgraph_node *first_analyzed;\n static varpool_node *first_analyzed_var;\n \n+/* FIRST_TIME is set to TRUE for the first time we are called for a\n+   translation unit from finalize_compilation_unit() or false\n+   otherwise.  */\n+\n static void\n-analyze_functions (void)\n+analyze_functions (bool first_time)\n {\n   /* Keep track of already processed nodes when called multiple times for\n      intermodule optimization.  */\n@@ -1097,6 +1108,13 @@ analyze_functions (void)\n       symtab_node::dump_table (symtab->dump_file);\n     }\n \n+  if (first_time)\n+    {\n+      symtab_node *snode;\n+      FOR_EACH_SYMBOL (snode)\n+\tcheck_global_declaration (snode->decl);\n+    }\n+\n   if (symtab->dump_file)\n     fprintf (symtab->dump_file, \"\\nRemoving unused symbols:\");\n \n@@ -1109,6 +1127,19 @@ analyze_functions (void)\n \t{\n \t  if (symtab->dump_file)\n \t    fprintf (symtab->dump_file, \" %s\", node->name ());\n+\n+\t  /* See if the debugger can use anything before the DECL\n+\t     passes away.  Perhaps it can notice a DECL that is now a\n+\t     constant and can tag the early DIE with an appropriate\n+\t     attribute.\n+\n+\t     Otherwise, this is the last chance the debug_hooks have\n+\t     at looking at optimized away DECLs, since\n+\t     late_global_decl will subsequently be called from the\n+\t     contents of the now pruned symbol table.  */\n+\t  if (!decl_function_context (node->decl))\n+\t    (*debug_hooks->late_global_decl) (node->decl);\n+\n \t  node->remove ();\n \t  continue;\n \t}\n@@ -2445,13 +2476,23 @@ symbol_table::finalize_compilation_unit (void)\n \n   /* Gimplify and lower all functions, compute reachability and\n      remove unreachable nodes.  */\n-  analyze_functions ();\n+  analyze_functions (/*first_time=*/true);\n \n   /* Mark alias targets necessary and emit diagnostics.  */\n   handle_alias_pairs ();\n \n   /* Gimplify and lower thunks.  */\n-  analyze_functions ();\n+  analyze_functions (/*first_time=*/false);\n+\n+  /* Emit early debug for reachable functions, and by consequence,\n+     locally scoped symbols.  */\n+  struct cgraph_node *cnode;\n+  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (cnode)\n+    (*debug_hooks->early_global_decl) (cnode->decl);\n+\n+  /* Clean up anything that needs cleaning up after initial debug\n+     generation.  */\n+  (*debug_hooks->early_finish) ();\n \n   /* Finally drive the pass manager.  */\n   compile ();"}, {"sha": "bb59bcc70fc43dc6a20380d6548f673251321c40", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -1,3 +1,36 @@\n+2015-06-05  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* cp-objcp-common.c: Adjust comment for\n+\tcxx_warn_unused_global_decl.\n+\t* cp-objcp-common.h (LANG_HOOKS_WRITE_GLOBALS): Remove\n+\t(LANG_HOOKS_POST_COMPILATION_PARSING_CLEANUPS): New.\n+\t* cp-tree.h (note_mangling_alias): Protoize.\n+\t(cp_write_global_declarations): Remove.\n+\t(cxx_post_compilation_parsing_cleanups): Protoize.\n+\t* decl.c (wrapup_globals_for_namespace): Remove use of DATA\n+\targument.\n+\t* decl2.c (mangling_aliases): New global.\n+\t(build_java_method_aliases): New.  Adapted from\n+\tcollect_candidates_for_java_method_aliases.\n+\t(collect_candidates_for_java_method_aliases): Remove.\n+\t(build_java_method_aliases): Remove.\n+\t(generate_mangling_aliases): New.\n+\t(note_mangling_alias): New.  Moved from mangle_decl.\n+\t(locus_at_end_of_parsing): New global.\n+\t(c_parse_final_cleanups): Rename from\n+\tcp_write_global_declarations.\n+\tUse locus_at_end_of_parsing.\n+\tCall generate_mangling_aliases.\n+\tRename call to collect_candidates_for_java_method_aliases into\n+\tbuild_java_method_aliases.\n+\tRemove call to finalize_compilation_unit.\n+\tMove vtable handling into cxx_post_compilation_parsing_cleanups.\n+\tDo not call check_global_declarations or\n+\temit_debug_global_declarations.\n+\t(cxx_post_compilation_parsing_cleanups): New.\n+\t* mangle.c (mangle_decl): Move code to note_mangling_alias.\n+\t* name-lookup.c (do_namespace_alias): Call early_global_decl.\n+\n 2015-06-05  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/52595"}, {"sha": "4c193a1dfd2d6dc52093269f772f9d3829b96063", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -57,7 +57,7 @@ cxx_get_alias_set (tree t)\n   return c_common_get_alias_set (t);\n }\n \n-/* Called from check_global_declarations.  */\n+/* Called from check_global_declaration.  */\n \n bool\n cxx_warn_unused_global_decl (const_tree decl)"}, {"sha": "c8572a7f4713ec46eb2b9155503681f063fc60f8", "filename": "gcc/cp/cp-objcp-common.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fcp%2Fcp-objcp-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fcp%2Fcp-objcp-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.h?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -84,8 +84,8 @@ extern void cp_common_init_ts (void);\n #define LANG_HOOKS_PRINT_ERROR_FUNCTION\tcxx_print_error_function\n #undef LANG_HOOKS_WARN_UNUSED_GLOBAL_DECL\n #define LANG_HOOKS_WARN_UNUSED_GLOBAL_DECL cxx_warn_unused_global_decl\n-#undef LANG_HOOKS_WRITE_GLOBALS\n-#define LANG_HOOKS_WRITE_GLOBALS cp_write_global_declarations\n+#undef LANG_HOOKS_POST_COMPILATION_PARSING_CLEANUPS\n+#define LANG_HOOKS_POST_COMPILATION_PARSING_CLEANUPS cxx_post_compilation_parsing_cleanups\n #undef  LANG_HOOKS_BUILTIN_FUNCTION\n #define LANG_HOOKS_BUILTIN_FUNCTION cxx_builtin_function\n #undef  LANG_HOOKS_BUILTIN_FUNCTION_EXT_SCOPE"}, {"sha": "fb1702cb1502dad64044d9db91bd4d8300ef3972", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -5469,7 +5469,7 @@ extern tree cp_reconstruct_complex_type\t\t(tree, tree);\n extern bool attributes_naming_typedef_ok\t(tree);\n extern void cplus_decl_attributes\t\t(tree *, tree, int);\n extern void finish_anon_union\t\t\t(tree);\n-extern void cp_write_global_declarations\t(void);\n+extern void cxx_post_compilation_parsing_cleanups (void);\n extern tree coerce_new_type\t\t\t(tree);\n extern tree coerce_delete_type\t\t\t(tree);\n extern void comdat_linkage\t\t\t(tree);"}, {"sha": "2bddce22d62f2b44b826e4d65f872b705edaeec6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -888,30 +888,19 @@ walk_namespaces (walk_namespaces_fn f, void* data)\n   return walk_namespaces_r (global_namespace, f, data);\n }\n \n-/* Call wrapup_globals_declarations for the globals in NAMESPACE.  If\n-   DATA is non-NULL, this is the last time we will call\n-   wrapup_global_declarations for this NAMESPACE.  */\n+/* Call wrapup_globals_declarations for the globals in NAMESPACE.  */\n \n int\n-wrapup_globals_for_namespace (tree name_space, void* data)\n+wrapup_globals_for_namespace (tree name_space, void* data ATTRIBUTE_UNUSED)\n {\n   cp_binding_level *level = NAMESPACE_LEVEL (name_space);\n   vec<tree, va_gc> *statics = level->static_decls;\n   tree *vec = statics->address ();\n   int len = statics->length ();\n-  int last_time = (data != 0);\n-\n-  if (last_time)\n-    {\n-      check_global_declarations (vec, len);\n-      emit_debug_global_declarations (vec, len);\n-      return 0;\n-    }\n \n   /* Write out any globals that need to be output.  */\n   return wrapup_global_declarations (vec, len);\n }\n-\n \f\n /* In C++, you don't have to write `struct S' to refer to `S'; you\n    can just use `S'.  We accomplish this by creating a TYPE_DECL as"}, {"sha": "c1b568b2c6478380ac790b992fa762d5e77da48e", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -4389,6 +4389,8 @@ dump_tu (void)\n     }\n }\n \n+static location_t locus_at_end_of_parsing;\n+\n /* Check the deallocation functions for CODE to see if we want to warn that\n    only one was defined.  */\n \n@@ -4436,17 +4438,16 @@ maybe_warn_sized_delete ()\n    first, since that way we only need to reverse the decls once.  */\n \n void\n-cp_write_global_declarations (void)\n+c_parse_final_cleanups (void)\n {\n   tree vars;\n   bool reconsider;\n   size_t i;\n-  location_t locus;\n   unsigned ssdf_count = 0;\n   int retries = 0;\n   tree decl;\n \n-  locus = input_location;\n+  locus_at_end_of_parsing = input_location;\n   at_eof = 1;\n \n   /* Bad parse errors.  Just forget about it.  */\n@@ -4463,6 +4464,9 @@ cp_write_global_declarations (void)\n       return;\n     }\n \n+  timevar_stop (TV_PHASE_PARSING);\n+  timevar_start (TV_PHASE_DEFERRED);\n+\n   symtab->process_same_body_aliases ();\n \n   /* Handle -fdump-ada-spec[-slim] */\n@@ -4478,8 +4482,6 @@ cp_write_global_declarations (void)\n \n   /* FIXME - huh?  was  input_line -= 1;*/\n \n-  timevar_start (TV_PHASE_DEFERRED);\n-\n   /* We now have to write out all the stuff we put off writing out.\n      These include:\n \n@@ -4575,7 +4577,7 @@ cp_write_global_declarations (void)\n \n \t  /* Set the line and file, so that it is obviously not from\n \t     the source file.  */\n-\t  input_location = locus;\n+\t  input_location = locus_at_end_of_parsing;\n \t  ssdf_body = start_static_storage_duration_function (ssdf_count);\n \n \t  /* Make sure the back end knows about all the variables.  */\n@@ -4601,15 +4603,15 @@ cp_write_global_declarations (void)\n \n \t  /* Finish up the static storage duration function for this\n \t     round.  */\n-\t  input_location = locus;\n+\t  input_location = locus_at_end_of_parsing;\n \t  finish_static_storage_duration_function (ssdf_body);\n \n \t  /* All those initializations and finalizations might cause\n \t     us to need more inline functions, more template\n \t     instantiations, etc.  */\n \t  reconsider = true;\n \t  ssdf_count++;\n-\t  /* ??? was:  locus.line++; */\n+\t  /* ??? was:  locus_at_end_of_parsing.line++; */\n \t}\n \n       /* Now do the same for thread_local variables.  */\n@@ -4752,7 +4754,7 @@ cp_write_global_declarations (void)\n \t\t\t\t(template_for_substitution (decl)))))\n \t{\n \t  warning (0, \"inline function %q+D used but never defined\", decl);\n-\t  /* Avoid a duplicate warning from check_global_declaration_1.  */\n+\t  /* Avoid a duplicate warning from check_global_declaration.  */\n \t  TREE_NO_WARNING (decl) = 1;\n \t}\n     }\n@@ -4779,12 +4781,13 @@ cp_write_global_declarations (void)\n   if (priority_info_map)\n     splay_tree_foreach (priority_info_map,\n \t\t\tgenerate_ctor_and_dtor_functions_for_priority,\n-\t\t\t/*data=*/&locus);\n+\t\t\t/*data=*/&locus_at_end_of_parsing);\n   else if (c_dialect_objc () && objc_static_init_needed_p ())\n     /* If this is obj-c++ and we need a static init, call\n        generate_ctor_or_dtor_function.  */\n     generate_ctor_or_dtor_function (/*constructor_p=*/true,\n-\t\t\t\t    DEFAULT_INIT_PRIORITY, &locus);\n+\t\t\t\t    DEFAULT_INIT_PRIORITY,\n+\t\t\t\t    &locus_at_end_of_parsing);\n \n   /* We're done with the splay-tree now.  */\n   if (priority_info_map)\n@@ -4800,42 +4803,13 @@ cp_write_global_declarations (void)\n   /* Generate Java hidden aliases.  */\n   build_java_method_aliases ();\n \n-  timevar_stop (TV_PHASE_DEFERRED);\n-  timevar_start (TV_PHASE_OPT_GEN);\n-\n   if (flag_vtable_verify)\n     {\n       vtv_recover_class_info ();\n       vtv_compute_class_hierarchy_transitive_closure ();\n       vtv_build_vtable_verify_fndecl ();\n     }\n \n-  symtab->finalize_compilation_unit ();\n-\n-  if (flag_vtable_verify)\n-    {\n-      /* Generate the special constructor initialization function that\n-         calls __VLTRegisterPairs, and give it a very high\n-         initialization priority.  This must be done after\n-         finalize_compilation_unit so that we have accurate\n-         information about which vtable will actually be emitted.  */\n-      vtv_generate_init_routine ();\n-    }\n-\n-  timevar_stop (TV_PHASE_OPT_GEN);\n-  timevar_start (TV_PHASE_CHECK_DBGINFO);\n-\n-  /* Now, issue warnings about static, but not defined, functions,\n-     etc., and emit debugging information.  */\n-  walk_namespaces (wrapup_globals_for_namespace, /*data=*/&reconsider);\n-  if (vec_safe_length (pending_statics) != 0)\n-    {\n-      check_global_declarations (pending_statics->address (),\n-\t\t\t\t pending_statics->length ());\n-      emit_debug_global_declarations (pending_statics->address (),\n-\t\t\t\t      pending_statics->length ());\n-    }\n-\n   perform_deferred_noexcept_checks ();\n \n   finish_repo ();\n@@ -4849,13 +4823,37 @@ cp_write_global_declarations (void)\n       dump_tree_statistics ();\n       dump_time_statistics ();\n     }\n-  input_location = locus;\n+\n+  timevar_stop (TV_PHASE_DEFERRED);\n+  timevar_start (TV_PHASE_PARSING);\n+}\n+\n+/* Perform any post compilation-proper cleanups for the C++ front-end.\n+   This should really go away.  No front-end should need to do\n+   anything past the compilation process.  */\n+\n+void\n+cxx_post_compilation_parsing_cleanups (void)\n+{\n+  timevar_start (TV_PHASE_LATE_PARSING_CLEANUPS);\n+\n+  if (flag_vtable_verify)\n+    {\n+      /* Generate the special constructor initialization function that\n+         calls __VLTRegisterPairs, and give it a very high\n+         initialization priority.  This must be done after\n+         finalize_compilation_unit so that we have accurate\n+         information about which vtable will actually be emitted.  */\n+      vtv_generate_init_routine ();\n+    }\n+\n+  input_location = locus_at_end_of_parsing;\n \n #ifdef ENABLE_CHECKING\n   validate_conversion_obstack ();\n #endif /* ENABLE_CHECKING */\n \n-  timevar_stop (TV_PHASE_CHECK_DBGINFO);\n+  timevar_stop (TV_PHASE_LATE_PARSING_CLEANUPS);\n }\n \n /* FN is an OFFSET_REF, DOTSTAR_EXPR or MEMBER_REF indicating the"}, {"sha": "e4baac3b959f10d2cb76866c9dc73cc9c9477ed5", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -3896,7 +3896,7 @@ do_namespace_alias (tree alias, tree name_space)\n \n   /* Emit debug info for namespace alias.  */\n   if (!building_stmt_list_p ())\n-    (*debug_hooks->global_decl) (alias);\n+    (*debug_hooks->early_global_decl) (alias);\n }\n \n /* Like pushdecl, only it places X in the current namespace,"}, {"sha": "138f5cfdf0e44d8aeb077d25a431ad6bae2675fe", "filename": "gcc/dbxout.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -345,7 +345,8 @@ static int dbxout_symbol_location (tree, tree, const char *, rtx);\n static void dbxout_symbol_name (tree, const char *, int);\n static void dbxout_common_name (tree, const char *, stab_code_type);\n static const char *dbxout_common_check (tree, int *);\n-static void dbxout_global_decl (tree);\n+static void dbxout_early_global_decl (tree);\n+static void dbxout_late_global_decl (tree);\n static void dbxout_type_decl (tree, int);\n static void dbxout_handle_pch (unsigned);\n static void debug_free_queue (void);\n@@ -367,6 +368,7 @@ const struct gcc_debug_hooks dbx_debug_hooks =\n   dbxout_init,\n   dbxout_finish,\n   debug_nothing_void,\n+  debug_nothing_void,\n   debug_nothing_int_charstar,\n   debug_nothing_int_charstar,\n   dbxout_start_source_file,\n@@ -386,7 +388,8 @@ const struct gcc_debug_hooks dbx_debug_hooks =\n #endif\n   debug_nothing_int,\t\t         /* end_function */\n   dbxout_function_decl,\n-  dbxout_global_decl,\t\t         /* global_decl */\n+  dbxout_early_global_decl,\t\t /* early_global_decl */\n+  dbxout_late_global_decl,\t\t /* late_global_decl */\n   dbxout_type_decl,\t\t\t /* type_decl */\n   debug_nothing_tree_tree_tree_bool,\t /* imported_module_or_decl */\n   debug_nothing_tree,\t\t         /* deferred_inline_function */\n@@ -407,6 +410,7 @@ const struct gcc_debug_hooks xcoff_debug_hooks =\n   dbxout_init,\n   dbxout_finish,\n   debug_nothing_void,\n+  debug_nothing_void,\n   debug_nothing_int_charstar,\n   debug_nothing_int_charstar,\n   dbxout_start_source_file,\n@@ -422,7 +426,8 @@ const struct gcc_debug_hooks xcoff_debug_hooks =\n   debug_nothing_tree,\t\t         /* begin_function */\n   xcoffout_end_function,\n   debug_nothing_tree,\t\t         /* function_decl */\n-  dbxout_global_decl,\t\t         /* global_decl */\n+  dbxout_early_global_decl,\t\t /* early_global_decl */\n+  dbxout_late_global_decl,\t\t /* late_global_decl */\n   dbxout_type_decl,\t\t\t /* type_decl */\n   debug_nothing_tree_tree_tree_bool,\t /* imported_module_or_decl */\n   debug_nothing_tree,\t\t         /* deferred_inline_function */\n@@ -1336,10 +1341,16 @@ dbxout_function_decl (tree decl)\n \n #endif /* DBX_DEBUGGING_INFO  */\n \n+static void\n+dbxout_early_global_decl (tree decl ATTRIBUTE_UNUSED)\n+{\n+  /* NYI for non-dwarf.  */\n+}\n+\n /* Debug information for a global DECL.  Called from toplev.c after\n    compilation proper has finished.  */\n static void\n-dbxout_global_decl (tree decl)\n+dbxout_late_global_decl (tree decl)\n {\n   if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl))\n     {"}, {"sha": "ed468f7077949d322b5c345f0e295f9f1e623144", "filename": "gcc/debug.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fdebug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fdebug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -33,6 +33,7 @@ const struct gcc_debug_hooks do_nothing_debug_hooks =\n {\n   debug_nothing_charstar,\n   debug_nothing_charstar,\n+  debug_nothing_void,\t\t\t/* early_finish */\n   debug_nothing_void,\n   debug_nothing_int_charstar,\n   debug_nothing_int_charstar,\n@@ -49,7 +50,8 @@ const struct gcc_debug_hooks do_nothing_debug_hooks =\n   debug_nothing_tree,\t\t         /* begin_function */\n   debug_nothing_int,\t\t         /* end_function */\n   debug_nothing_tree,\t\t         /* function_decl */\n-  debug_nothing_tree,\t\t         /* global_decl */\n+  debug_nothing_tree,\t         \t /* early_global_decl */\n+  debug_nothing_tree,\t         \t /* late_global_decl */\n   debug_nothing_tree_int,\t\t /* type_decl */\n   debug_nothing_tree_tree_tree_bool,\t /* imported_module_or_decl */\n   debug_nothing_tree,\t\t         /* deferred_inline_function */"}, {"sha": "e7e1334c1549b74344f8e98d729bdd6875b1c2bd", "filename": "gcc/debug.h", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.h?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -30,6 +30,9 @@ struct gcc_debug_hooks\n   /* Output debug symbols.  */\n   void (* finish) (const char *main_filename);\n \n+  /* Run cleanups necessary after early debug generation.  */\n+  void (* early_finish) (void);\n+\n   /* Called from cgraph_optimize before starting to assemble\n      functions/variables/toplevel asms.  */\n   void (* assembly_start) (void);\n@@ -89,12 +92,43 @@ struct gcc_debug_hooks\n   /* Debug information for a function DECL.  This might include the\n      function name (a symbol), its parameters, and the block that\n      makes up the function's body, and the local variables of the\n-     function.  */\n+     function.\n+\n+     This is only called for FUNCTION_DECLs.  It is part of the late\n+     debug pass and is called from rest_of_handle_final.\n+\n+     Location information is available at this point.\n+\n+     See the documentation for early_global_decl and late_global_decl\n+     for other entry points into the debugging back-ends for DECLs.  */\n   void (* function_decl) (tree decl);\n \n-  /* Debug information for a global DECL.  Called from toplev.c after\n-     compilation proper has finished.  */\n-  void (* global_decl) (tree decl);\n+  /* Debug information for a global DECL.  Called from the parser\n+     after the parsing process has finished.\n+\n+     This gets called for both variables and functions.\n+\n+     Location information is not available at this point, but it is a\n+     good probe point to get access to symbols before they get\n+     optimized away.\n+\n+     This hook may be called on VAR_DECLs or FUNCTION_DECLs.  It is up\n+     to the hook to use what it needs.  */\n+  void (* early_global_decl) (tree decl);\n+\n+  /* Augment debug information generated by early_global_decl with\n+     more complete debug info (if applicable).  Called from toplev.c\n+     after the compilation proper has finished and cgraph information\n+     is available.\n+\n+     This gets called for both variables and functions.\n+\n+     Location information is usually available at this point, unless\n+     the hook is being called for a decl that has been optimized away.\n+\n+     This hook may be called on VAR_DECLs or FUNCTION_DECLs.  It is up\n+     to the hook to use what it needs.  */\n+  void (* late_global_decl) (tree decl);\n \n   /* Debug information for a type DECL.  Called from toplev.c after\n      compilation proper, also from various language front ends to"}, {"sha": "2e3bee34abfc671feedb3a7fa16bda8669cb3c70", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 753, "deletions": 276, "changes": 1029, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -1263,16 +1263,6 @@ struct GTY((for_user)) dwarf_file_data {\n   int emitted_number;\n };\n \n-typedef struct GTY(()) deferred_locations_struct\n-{\n-  tree variable;\n-  dw_die_ref die;\n-} deferred_locations;\n-\n-\n-static GTY(()) vec<deferred_locations, va_gc> *deferred_locations_list;\n-\n-\n /* Describe an entry into the .debug_addr section.  */\n \n enum ate_kind {\n@@ -2443,6 +2433,7 @@ build_cfa_aligned_loc (dw_cfa_location *cfa,\n \n static void dwarf2out_init (const char *);\n static void dwarf2out_finish (const char *);\n+static void dwarf2out_early_finish (void);\n static void dwarf2out_assembly_start (void);\n static void dwarf2out_define (unsigned int, const char *);\n static void dwarf2out_undef (unsigned int, const char *);\n@@ -2452,7 +2443,8 @@ static void dwarf2out_function_decl (tree);\n static void dwarf2out_begin_block (unsigned, unsigned);\n static void dwarf2out_end_block (unsigned, unsigned);\n static bool dwarf2out_ignore_block (const_tree);\n-static void dwarf2out_global_decl (tree);\n+static void dwarf2out_early_global_decl (tree);\n+static void dwarf2out_late_global_decl (tree);\n static void dwarf2out_type_decl (tree, int);\n static void dwarf2out_imported_module_or_decl (tree, tree, tree, bool);\n static void dwarf2out_imported_module_or_decl_1 (tree, tree, tree,\n@@ -2469,6 +2461,7 @@ const struct gcc_debug_hooks dwarf2_debug_hooks =\n {\n   dwarf2out_init,\n   dwarf2out_finish,\n+  dwarf2out_early_finish,\n   dwarf2out_assembly_start,\n   dwarf2out_define,\n   dwarf2out_undef,\n@@ -2490,7 +2483,8 @@ const struct gcc_debug_hooks dwarf2_debug_hooks =\n   dwarf2out_begin_function,\n   dwarf2out_end_function,\t/* end_function */\n   dwarf2out_function_decl,\t/* function_decl */\n-  dwarf2out_global_decl,\n+  dwarf2out_early_global_decl,\n+  dwarf2out_late_global_decl,\n   dwarf2out_type_decl,\t\t/* type_decl */\n   dwarf2out_imported_module_or_decl,\n   debug_nothing_tree,\t\t/* deferred_inline_function */\n@@ -2635,6 +2629,14 @@ typedef struct GTY((chain_circular (\"%h.die_sib\"), for_user)) die_struct {\n }\n die_node;\n \n+/* Set to TRUE while dwarf2out_early_global_decl is running.  */\n+static bool early_dwarf;\n+struct set_early_dwarf {\n+  bool saved;\n+  set_early_dwarf () : saved(early_dwarf) { early_dwarf = true; }\n+  ~set_early_dwarf () { early_dwarf = saved; }\n+};\n+\n /* Evaluate 'expr' while 'c' is set to each child of DIE in order.  */\n #define FOR_EACH_CHILD(die, c, expr) do {\t\\\n   c = die->die_child;\t\t\t\t\\\n@@ -2685,9 +2687,13 @@ typedef struct GTY(()) comdat_type_struct\n }\n comdat_type_node;\n \n-/* The limbo die list structure.  */\n+/* A list of DIEs for which we can't determine ancestry (parent_die\n+   field) just yet.  Later in dwarf2out_finish we will fill in the\n+   missing bits.  */\n typedef struct GTY(()) limbo_die_struct {\n   dw_die_ref die;\n+  /* The tree for which this DIE was created.  We use this to\n+     determine ancestry later.  */\n   tree created_for;\n   struct limbo_die_struct *next;\n }\n@@ -2934,7 +2940,7 @@ static GTY((length (\"abbrev_die_table_allocated\")))\n /* Number of elements currently allocated for abbrev_die_table.  */\n static GTY(()) unsigned abbrev_die_table_allocated;\n \n-/* Number of elements in type_die_table currently in use.  */\n+/* Number of elements in abbrev_die_table currently in use.  */\n static GTY(()) unsigned abbrev_die_table_in_use;\n \n /* Size (in elements) of increments by which we may expand the\n@@ -3016,9 +3022,6 @@ static GTY(()) struct dwarf_file_data * last_emitted_file;\n /* Number of internal labels generated by gen_internal_sym().  */\n static GTY(()) int label_num;\n \n-/* Cached result of previous call to lookup_filename.  */\n-static GTY(()) struct dwarf_file_data * file_table_last_lookup;\n-\n static GTY(()) vec<die_arg_entry, va_gc> *tmpl_value_parm_die_table;\n \n /* Instances of generic types for which we need to generate debug\n@@ -3103,7 +3106,7 @@ static inline dw_die_ref get_AT_ref (dw_die_ref, enum dwarf_attribute);\n static bool is_cxx (void);\n static bool is_fortran (void);\n static bool is_ada (void);\n-static void remove_AT (dw_die_ref, enum dwarf_attribute);\n+static bool remove_AT (dw_die_ref, enum dwarf_attribute);\n static void remove_child_TAG (dw_die_ref, enum dwarf_tag);\n static void add_child_die (dw_die_ref, dw_die_ref);\n static dw_die_ref new_die (enum dwarf_tag, dw_die_ref, tree);\n@@ -4743,16 +4746,17 @@ is_ada (void)\n   return lang == DW_LANG_Ada95 || lang == DW_LANG_Ada83;\n }\n \n-/* Remove the specified attribute if present.  */\n+/* Remove the specified attribute if present.  Return TRUE if removal\n+   was successful.  */\n \n-static void\n+static bool\n remove_AT (dw_die_ref die, enum dwarf_attribute attr_kind)\n {\n   dw_attr_ref a;\n   unsigned ix;\n \n   if (! die)\n-    return;\n+    return false;\n \n   FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     if (a->dw_attr == attr_kind)\n@@ -4764,8 +4768,9 @@ remove_AT (dw_die_ref die, enum dwarf_attribute attr_kind)\n \t/* vec::ordered_remove should help reduce the number of abbrevs\n \t   that are needed.  */\n \tdie->die_attr->ordered_remove (ix);\n-\treturn;\n+\treturn true;\n       }\n+  return false;\n }\n \n /* Remove CHILD from its parent.  PREV must have the property that\n@@ -4839,6 +4844,7 @@ remove_child_TAG (dw_die_ref die, enum dwarf_tag tag)\n     while (c->die_tag == tag)\n       {\n \tremove_child_with_prev (c, prev);\n+\tc->die_parent = NULL;\n \t/* Might have removed every child.  */\n \tif (c == c->die_sib)\n \t  return;\n@@ -4868,15 +4874,28 @@ add_child_die (dw_die_ref die, dw_die_ref child_die)\n   die->die_child = child_die;\n }\n \n+/* Unassociate CHILD from its parent, and make its parent be\n+   NEW_PARENT.  */\n+\n+static void\n+reparent_child (dw_die_ref child, dw_die_ref new_parent)\n+{\n+  for (dw_die_ref p = child->die_parent->die_child; ; p = p->die_sib)\n+    if (p->die_sib == child)\n+      {\n+\tremove_child_with_prev (child, p);\n+\tbreak;\n+      }\n+  add_child_die (new_parent, child);\n+}\n+\n /* Move CHILD, which must be a child of PARENT or the DIE for which PARENT\n    is the specification, to the end of PARENT's list of children.\n    This is done by removing and re-adding it.  */\n \n static void\n splice_child_die (dw_die_ref parent, dw_die_ref child)\n {\n-  dw_die_ref p;\n-\n   /* We want the declaration DIE from inside the class, not the\n      specification DIE at toplevel.  */\n   if (child->die_parent != parent)\n@@ -4891,17 +4910,13 @@ splice_child_die (dw_die_ref parent, dw_die_ref child)\n \t      || (child->die_parent\n \t\t  == get_AT_ref (parent, DW_AT_specification)));\n \n-  for (p = child->die_parent->die_child; ; p = p->die_sib)\n-    if (p->die_sib == child)\n-      {\n-\tremove_child_with_prev (child, p);\n-\tbreak;\n-      }\n-\n-  add_child_die (parent, child);\n+  reparent_child (child, parent);\n }\n \n-/* Return a pointer to a newly created DIE node.  */\n+/* Create and return a new die with a parent of PARENT_DIE.  If\n+   PARENT_DIE is NULL, the new DIE is placed in limbo and an\n+   associated tree T must be supplied to determine parenthood\n+   later.  */\n \n static inline dw_die_ref\n new_die (enum dwarf_tag tag_value, dw_die_ref parent_die, tree t)\n@@ -4916,6 +4931,35 @@ new_die (enum dwarf_tag tag_value, dw_die_ref parent_die, tree t)\n     {\n       limbo_die_node *limbo_node;\n \n+      /* No DIEs created after early dwarf should end up in limbo,\n+\t because the limbo list should not persist past LTO\n+\t streaming.  */\n+      if (tag_value != DW_TAG_compile_unit\n+\t  /* These are allowed because they're generated while\n+\t     breaking out COMDAT units late.  */\n+\t  && tag_value != DW_TAG_type_unit\n+\t  && !early_dwarf\n+\t  /* Allow nested functions to live in limbo because they will\n+\t     only temporarily live there, as decls_for_scope will fix\n+\t     them up.  */\n+\t  && (TREE_CODE (t) != FUNCTION_DECL\n+\t      || !decl_function_context (t))\n+\t  /* Same as nested functions above but for types.  Types that\n+\t     are local to a function will be fixed in\n+\t     decls_for_scope.  */\n+\t  && (!RECORD_OR_UNION_TYPE_P (t)\n+\t      || !TYPE_CONTEXT (t)\n+\t      || TREE_CODE (TYPE_CONTEXT (t)) != FUNCTION_DECL)\n+\t  /* FIXME debug-early: Allow late limbo DIE creation for LTO,\n+\t     especially in the ltrans stage, but once we implement LTO\n+\t     dwarf streaming, we should remove this exception.  */\n+\t  && !in_lto_p)\n+\t{\n+\t  fprintf (stderr, \"symbol ended up in limbo too late:\");\n+\t  debug_generic_stmt (t);\n+\t  gcc_unreachable ();\n+\t}\n+\n       limbo_node = ggc_cleared_alloc<limbo_die_node> ();\n       limbo_node->die = die;\n       limbo_node->created_for = t;\n@@ -5647,6 +5691,34 @@ debug_dwarf (void)\n   print_indent = 0;\n   print_die (comp_unit_die (), stderr);\n }\n+\n+/* Sanity checks on DIEs.  */\n+\n+static void\n+check_die (dw_die_ref die)\n+{\n+  /* A debugging information entry that is a member of an abstract\n+     instance tree [that has DW_AT_inline] should not contain any\n+     attributes which describe aspects of the subroutine which vary\n+     between distinct inlined expansions or distinct out-of-line\n+     expansions.  */\n+  unsigned ix;\n+  dw_attr_ref a;\n+  bool inline_found = false;\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n+    if (a->dw_attr == DW_AT_inline && a->dw_attr_val.v.val_unsigned)\n+      inline_found = true;\n+  if (inline_found)\n+    {\n+      /* Catch the most common mistakes.  */\n+      FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n+\tgcc_assert (a->dw_attr != DW_AT_low_pc\n+\t\t    && a->dw_attr != DW_AT_high_pc\n+\t\t    && a->dw_attr != DW_AT_location\n+\t\t    && a->dw_attr != DW_AT_frame_base\n+\t\t    && a->dw_attr != DW_AT_GNU_all_call_sites);\n+    }\n+}\n \f\n /* Start a new compilation unit DIE for an include file.  OLD_UNIT is the CU\n    for the enclosing include file, if any.  BINCL_DIE is the DW_TAG_GNU_BINCL\n@@ -16101,17 +16173,6 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl, bool cache_p,\n   return tree_add_const_value_attribute_for_decl (die, decl);\n }\n \n-/* Add VARIABLE and DIE into deferred locations list.  */\n-\n-static void\n-defer_location (tree variable, dw_die_ref die)\n-{\n-  deferred_locations entry;\n-  entry.variable = variable;\n-  entry.die = die;\n-  vec_safe_push (deferred_locations_list, entry);\n-}\n-\n /* Helper function for tree_add_const_value_attribute.  Natively encode\n    initializer INIT into an array.  Return true if successful.  */\n \n@@ -16793,14 +16854,17 @@ add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr,\n /* Add subscript info to TYPE_DIE, describing an array TYPE, collapsing\n    possibly nested array subscripts in a flat sequence if COLLAPSE_P is true.\n    Note that the block of subscript information for an array type also\n-   includes information about the element type of the given array type.  */\n+   includes information about the element type of the given array type.\n+\n+   This function reuses previously set type and bound information if\n+   available.  */\n \n static void\n add_subscript_info (dw_die_ref type_die, tree type, bool collapse_p)\n {\n   unsigned dimension_number;\n   tree lower, upper;\n-  dw_die_ref subrange_die;\n+  dw_die_ref child = type_die->die_child;\n \n   for (dimension_number = 0;\n        TREE_CODE (type) == ARRAY_TYPE && (dimension_number == 0 || collapse_p);\n@@ -16814,15 +16878,46 @@ add_subscript_info (dw_die_ref type_die, tree type, bool collapse_p)\n       /* Arrays come in three flavors: Unspecified bounds, fixed bounds,\n \t and (in GNU C only) variable bounds.  Handle all three forms\n \t here.  */\n-      subrange_die = new_die (DW_TAG_subrange_type, type_die, NULL);\n+\n+      /* Find and reuse a previously generated DW_TAG_subrange_type if\n+\t available.\n+\n+         For multi-dimensional arrays, as we iterate through the\n+         various dimensions in the enclosing for loop above, we also\n+         iterate through the DIE children and pick at each\n+         DW_TAG_subrange_type previously generated (if available).\n+         Each child DW_TAG_subrange_type DIE describes the range of\n+         the current dimension.  At this point we should have as many\n+         DW_TAG_subrange_type's as we have dimensions in the\n+         array.  */\n+      dw_die_ref subrange_die = NULL;\n+      if (child)\n+\twhile (1)\n+\t  {\n+\t    child = child->die_sib;\n+\t    if (child->die_tag == DW_TAG_subrange_type)\n+\t      subrange_die = child;\n+\t    if (child == type_die->die_child)\n+\t      {\n+\t\t/* If we wrapped around, stop looking next time.  */\n+\t\tchild = NULL;\n+\t\tbreak;\n+\t      }\n+\t    if (child->die_tag == DW_TAG_subrange_type)\n+\t      break;\n+\t  }\n+      if (!subrange_die)\n+\tsubrange_die = new_die (DW_TAG_subrange_type, type_die, NULL);\n+\n       if (domain)\n \t{\n \t  /* We have an array type with specified bounds.  */\n \t  lower = TYPE_MIN_VALUE (domain);\n \t  upper = TYPE_MAX_VALUE (domain);\n \n \t  /* Define the index type.  */\n-\t  if (TREE_TYPE (domain))\n+\t  if (TREE_TYPE (domain)\n+\t      && !get_AT (subrange_die, DW_AT_type))\n \t    {\n \t      /* ??? This is probably an Ada unnamed subrange type.  Ignore the\n \t\t TREE_TYPE field.  We can't emit debug info for this\n@@ -16844,8 +16939,9 @@ add_subscript_info (dw_die_ref type_die, tree type, bool collapse_p)\n \t     to produce useful results, go ahead and output the lower\n \t     bound solo, and hope the debugger can cope.  */\n \n-\t  add_bound_info (subrange_die, DW_AT_lower_bound, lower, NULL);\n-\t  if (upper)\n+\t  if (!get_AT (subrange_die, DW_AT_lower_bound))\n+\t    add_bound_info (subrange_die, DW_AT_lower_bound, lower, NULL);\n+\t  if (upper && !get_AT (subrange_die, DW_AT_upper_bound))\n \t    add_bound_info (subrange_die, DW_AT_upper_bound, upper, NULL);\n \t}\n \n@@ -17472,14 +17568,32 @@ decl_start_label (tree decl)\n }\n #endif\n \f\n+/* For variable-length arrays that have been previously generated, but\n+   may be incomplete due to missing subscript info, fill the subscript\n+   info.  Return TRUE if this is one of those cases.  */\n+static bool\n+fill_variable_array_bounds (tree type)\n+{\n+  if (TREE_ASM_WRITTEN (type)\n+      && TREE_CODE (type) == ARRAY_TYPE\n+      && variably_modified_type_p (type, NULL))\n+    {\n+      dw_die_ref array_die = lookup_type_die (type);\n+      if (!array_die)\n+\treturn false;\n+      add_subscript_info (array_die, type, !is_ada ());\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* These routines generate the internal representation of the DIE's for\n    the compilation unit.  Debugging information is collected by walking\n    the declaration trees passed in from dwarf2out_decl().  */\n \n static void\n gen_array_type_die (tree type, dw_die_ref context_die)\n {\n-  dw_die_ref scope_die = scope_die_for (type, context_die);\n   dw_die_ref array_die;\n \n   /* GNU compilers represent multidimensional array types as sequences of one\n@@ -17493,6 +17607,11 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n      flexibilty wrt arrays of variable size.  */\n \n   bool collapse_nested_arrays = !is_ada ();\n+\n+  if (fill_variable_array_bounds (type))\n+    return;\n+\n+  dw_die_ref scope_die = scope_die_for (type, context_die);\n   tree element_type;\n \n   /* Emit DW_TAG_string_type for Fortran character types (with kind 1 only, as\n@@ -17848,15 +17967,82 @@ gen_formal_parameter_die (tree node, tree origin, bool emit_name_p,\n {\n   tree node_or_origin = node ? node : origin;\n   tree ultimate_origin;\n-  dw_die_ref parm_die\n-    = new_die (DW_TAG_formal_parameter, context_die, node);\n+  dw_die_ref parm_die = NULL;\n+  \n+  if (TREE_CODE_CLASS (TREE_CODE (node_or_origin)) == tcc_declaration)\n+    {\n+      parm_die = lookup_decl_die (node);\n+\n+      /* If the contexts differ, we may not be talking about the same\n+\t thing.  */\n+      if (parm_die && parm_die->die_parent != context_die)\n+\t{\n+\t  if (!DECL_ABSTRACT_P (node))\n+\t    {\n+\t      /* This can happen when creating an inlined instance, in\n+\t\t which case we need to create a new DIE that will get\n+\t\t annotated with DW_AT_abstract_origin.  */\n+\t      parm_die = NULL;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* FIXME: Reuse DIE even with a differing context.\n+\n+\t\t This happens when called through\n+\t\t dwarf2out_abstract_function for formal parameter\n+\t\t packs.  The issue is that we're calling\n+\t\t dwarf2out_abstract_function to build debug info for\n+\t\t the abstract instance of a function for which we have\n+\t\t already generated a DIE in\n+\t\t dwarf2out_early_global_decl.\n+\n+\t         Once we remove dwarf2out_abstract_function, this\n+\t         gcc_assert should be a gcc_unreachable.  */\n+\t      gcc_assert (parm_die->die_parent->die_tag\n+\t\t\t  == DW_TAG_GNU_formal_parameter_pack);\n+\t    }\n+\t}\n+\n+      if (parm_die && parm_die->die_parent == NULL)\n+\t{\n+\t  /* Check that parm_die already has the right attributes that\n+\t     we would have added below.  If any attributes are\n+\t     missing, fall through to add them.  */\n+\t  if (! DECL_ABSTRACT_P (node_or_origin)\n+\t      && !get_AT (parm_die, DW_AT_location)\n+\t      && !get_AT (parm_die, DW_AT_const_value))\n+\t    /* We are missing  location info, and are about to add it.  */\n+\t    ;\n+\t  else\n+\t    {\n+\t      add_child_die (context_die, parm_die);\n+\t      return parm_die;\n+\t    }\n+\t}\n+    }\n+\n+  /* If we have a previously generated DIE, use it, unless this is an\n+     concrete instance (origin != NULL), in which case we need a new\n+     DIE with a corresponding DW_AT_abstract_origin.  */\n+  bool reusing_die;\n+  if (parm_die && origin == NULL)\n+    reusing_die = true;\n+  else\n+    {\n+      parm_die = new_die (DW_TAG_formal_parameter, context_die, node);\n+      reusing_die = false;\n+    }\n \n   switch (TREE_CODE_CLASS (TREE_CODE (node_or_origin)))\n     {\n     case tcc_declaration:\n       ultimate_origin = decl_ultimate_origin (node_or_origin);\n       if (node || ultimate_origin)\n \torigin = ultimate_origin;\n+\n+      if (reusing_die)\n+\tgoto add_location;\n+\n       if (origin != NULL)\n \tadd_abstract_origin_attribute (parm_die, origin);\n       else if (emit_name_p)\n@@ -17876,6 +18062,7 @@ gen_formal_parameter_die (tree node, tree origin, bool emit_name_p,\n \t\t\t\tdecl_quals (node_or_origin),\n \t\t\t\tcontext_die);\n \t}\n+    add_location:\n       if (origin == NULL && DECL_ARTIFICIAL (node))\n \tadd_AT_flag (parm_die, DW_AT_artificial, 1);\n \n@@ -18207,7 +18394,16 @@ set_decl_abstract_flags (tree decl, vec<tree> &abstract_vec)\n }\n \n /* Generate the DWARF2 info for the \"abstract\" instance of a function which we\n-   may later generate inlined and/or out-of-line instances of.  */\n+   may later generate inlined and/or out-of-line instances of.\n+\n+   FIXME: In the early-dwarf world, this function, and most of the\n+          DECL_ABSTRACT code should be obsoleted.  The early DIE _is_\n+          the abstract instance.  All we would need to do is annotate\n+          the early DIE with the appropriate DW_AT_inline in late\n+          dwarf (perhaps in gen_inlined_subroutine_die).\n+\n+\t  However, we can't do this yet, because LTO streaming of DIEs\n+\t  has not been implemented yet.  */\n \n static void\n dwarf2out_abstract_function (tree decl)\n@@ -18389,26 +18585,94 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n {\n   tree origin = decl_ultimate_origin (decl);\n   dw_die_ref subr_die;\n-  tree outer_scope;\n   dw_die_ref old_die = lookup_decl_die (decl);\n+\n+  /* This function gets called multiple times for different stages of\n+     the debug process.  For example, for func() in this code:\n+\n+\tnamespace S\n+\t{\n+\t  void func() { ... }\n+\t}\n+\n+     ...we get called 4 times.  Twice in early debug and twice in\n+     late debug:\n+\n+     Early debug\n+     -----------\n+\n+       1. Once while generating func() within the namespace.  This is\n+          the declaration.  The declaration bit below is set, as the\n+          context is the namespace.\n+\n+\t  A new DIE will be generated with DW_AT_declaration set.\n+\n+       2. Once for func() itself.  This is the specification.  The\n+          declaration bit below is clear as the context is the CU.\n+\n+\t  We will use the cached DIE from (1) to create a new DIE with\n+\t  DW_AT_specification pointing to the declaration in (1).\n+\n+     Late debug via rest_of_handle_final()\n+     -------------------------------------\n+\n+       3. Once generating func() within the namespace.  This is also the\n+          declaration, as in (1), but this time we will early exit below\n+          as we have a cached DIE and a declaration needs no additional\n+          annotations (no locations), as the source declaration line\n+          info is enough.\n+\n+       4. Once for func() itself.  As in (2), this is the specification,\n+          but this time we will re-use the cached DIE, and just annotate\n+          it with the location information that should now be available.\n+\n+     For something without namespaces, but with abstract instances, we\n+     are also called a multiple times:\n+\n+        class Base\n+\t{\n+\tpublic:\n+\t  Base ();\t  // constructor declaration (1)\n+\t};\n+\n+\tBase::Base () { } // constructor specification (2)\n+\n+    Early debug\n+    -----------\n+\n+       1. Once for the Base() constructor by virtue of it being a\n+          member of the Base class.  This is done via\n+          rest_of_type_compilation.\n+\n+\t  This is a declaration, so a new DIE will be created with\n+\t  DW_AT_declaration.\n+\n+       2. Once for the Base() constructor definition, but this time\n+          while generating the abstract instance of the base\n+          constructor (__base_ctor) which is being generated via early\n+          debug of reachable functions.\n+\n+\t  Even though we have a cached version of the declaration (1),\n+\t  we will create a DW_AT_specification of the declaration DIE\n+\t  in (1).\n+\n+       3. Once for the __base_ctor itself, but this time, we generate\n+          an DW_AT_abstract_origin version of the DW_AT_specification in\n+\t  (2).\n+\n+    Late debug via rest_of_handle_final\n+    -----------------------------------\n+\n+       4. One final time for the __base_ctor (which will have a cached\n+          DIE with DW_AT_abstract_origin created in (3).  This time,\n+          we will just annotate the location information now\n+          available.\n+  */\n   int declaration = (current_function_decl != decl\n \t\t     || class_or_namespace_scope_p (context_die));\n \n   premark_used_types (DECL_STRUCT_FUNCTION (decl));\n \n-  /* It is possible to have both DECL_ABSTRACT_P and DECLARATION be true if we\n-     started to generate the abstract instance of an inline, decided to output\n-     its containing class, and proceeded to emit the declaration of the inline\n-     from the member list for the class.  If so, DECLARATION takes priority;\n-     we'll get back to the abstract instance when done with the class.  */\n-\n-  /* The class-scope declaration DIE must be the primary DIE.  */\n-  if (origin && declaration && class_or_namespace_scope_p (context_die))\n-    {\n-      origin = NULL;\n-      gcc_assert (!old_die);\n-    }\n-\n   /* Now that the C++ front end lazily declares artificial member fns, we\n      might need to retrofit the declaration into its class.  */\n   if (!declaration && !origin && !old_die\n@@ -18417,6 +18681,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n       && debug_info_level > DINFO_LEVEL_TERSE)\n     old_die = force_decl_die (decl);\n \n+  /* An inlined instance, tag a new DIE with DW_AT_abstract_origin.  */\n   if (origin != NULL)\n     {\n       gcc_assert (!declaration || local_scope_p (context_die));\n@@ -18426,19 +18691,32 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n       if (old_die && old_die->die_parent == NULL)\n \tadd_child_die (context_die, old_die);\n \n-      subr_die = new_die (DW_TAG_subprogram, context_die, decl);\n-      add_abstract_origin_attribute (subr_die, origin);\n-      /*  This is where the actual code for a cloned function is.\n-\t  Let's emit linkage name attribute for it.  This helps\n-\t  debuggers to e.g, set breakpoints into\n-\t  constructors/destructors when the user asks \"break\n-\t  K::K\".  */\n-      add_linkage_name (subr_die, decl);\n+      if (old_die && get_AT_ref (old_die, DW_AT_abstract_origin))\n+\t{\n+\t  /* If we have a DW_AT_abstract_origin we have a working\n+\t     cached version.  */\n+\t  subr_die = old_die;\n+\t}\n+      else\n+\t{\n+\t  subr_die = new_die (DW_TAG_subprogram, context_die, decl);\n+\t  add_abstract_origin_attribute (subr_die, origin);\n+\t  /*  This is where the actual code for a cloned function is.\n+\t      Let's emit linkage name attribute for it.  This helps\n+\t      debuggers to e.g, set breakpoints into\n+\t      constructors/destructors when the user asks \"break\n+\t      K::K\".  */\n+\t  add_linkage_name (subr_die, decl);\n+\t}\n     }\n+  /* A cached copy, possibly from early dwarf generation.  Reuse as\n+     much as possible.  */\n   else if (old_die)\n     {\n-      expanded_location s = expand_location (DECL_SOURCE_LOCATION (decl));\n-      struct dwarf_file_data * file_index = lookup_filename (s.file);\n+      /* A declaration that has been previously dumped needs no\n+\t additional information.  */\n+      if (declaration)\n+\treturn;\n \n       if (!get_AT_flag (old_die, DW_AT_declaration)\n \t  /* We can have a normal definition following an inline one in the\n@@ -18448,7 +18726,13 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t{\n \t  /* Detect and ignore this case, where we are trying to output\n \t     something we have already output.  */\n-\t  return;\n+\t  if (get_AT (old_die, DW_AT_low_pc)\n+\t      || get_AT (old_die, DW_AT_ranges))\n+\t    return;\n+\n+\t  /* If we have no location information, this must be a\n+\t     partially generated DIE from early dwarf generation.\n+\t     Fall through and generate it.  */\n \t}\n \n       /* If the definition comes from the same place as the declaration,\n@@ -18458,23 +18742,43 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t instances of inlines, since the spec requires the out-of-line copy\n \t to have the same parent.  For local class methods, this doesn't\n \t apply; we just use the old DIE.  */\n-      if ((is_cu_die (old_die->die_parent) || context_die == NULL)\n-\t  && (DECL_ARTIFICIAL (decl)\n-\t      || (get_AT_file (old_die, DW_AT_decl_file) == file_index\n-\t\t  && (get_AT_unsigned (old_die, DW_AT_decl_line)\n-\t\t      == (unsigned) s.line))))\n+      expanded_location s = expand_location (DECL_SOURCE_LOCATION (decl));\n+      struct dwarf_file_data * file_index = lookup_filename (s.file);\n+      if ((is_cu_die (old_die->die_parent)\n+\t   /* This condition fixes the inconsistency/ICE with the\n+\t      following Fortran test (or some derivative thereof) while\n+\t      building libgfortran:\n+\n+\t\t module some_m\n+\t\t contains\n+\t\t    logical function funky (FLAG)\n+\t\t      funky = .true.\n+\t\t   end function\n+\t\t end module\n+\t   */\n+\t   || old_die->die_parent->die_tag == DW_TAG_module\n+\t   || context_die == NULL)\n+\t   && (DECL_ARTIFICIAL (decl)\n+\t       || (get_AT_file (old_die, DW_AT_decl_file) == file_index\n+\t\t   && (get_AT_unsigned (old_die, DW_AT_decl_line)\n+\t\t       == (unsigned) s.line))))\n \t{\n \t  subr_die = old_die;\n \n-\t  /* Clear out the declaration attribute and the formal parameters.\n-\t     Do not remove all children, because it is possible that this\n-\t     declaration die was forced using force_decl_die(). In such\n-\t     cases die that forced declaration die (e.g. TAG_imported_module)\n-\t     is one of the children that we do not want to remove.  */\n-\t  remove_AT (subr_die, DW_AT_declaration);\n-\t  remove_AT (subr_die, DW_AT_object_pointer);\n-\t  remove_child_TAG (subr_die, DW_TAG_formal_parameter);\n+\t  /* Clear out the declaration attribute, but leave the\n+\t     parameters so they can be augmented with location\n+\t     information later.  Unless this was a declaration, in\n+\t     which case, wipe out the nameless parameters and recreate\n+\t     them further down.  */\n+\t  if (remove_AT (subr_die, DW_AT_declaration))\n+\t    {\n+\n+\t      remove_AT (subr_die, DW_AT_object_pointer);\n+\t      remove_child_TAG (subr_die, DW_TAG_formal_parameter);\n+\t    }\n \t}\n+      /* Make a specification pointing to the previously built\n+\t declaration.  */\n       else\n \t{\n \t  subr_die = new_die (DW_TAG_subprogram, context_die, decl);\n@@ -18496,6 +18800,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t    }\n \t}\n     }\n+  /* Create a fresh DIE for anything else.  */\n   else\n     {\n       subr_die = new_die (DW_TAG_subprogram, context_die, decl);\n@@ -18522,6 +18827,11 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n       add_accessibility_attribute (subr_die, decl);\n     }\n \n+  /* Unless we have an existing non-declaration DIE, equate the new\n+     DIE.  */\n+  if (!old_die || is_declaration_die (old_die))\n+    equate_decl_number_to_die (decl, subr_die);\n+\n   if (declaration)\n     {\n       if (!old_die || !get_AT (old_die, DW_AT_inline))\n@@ -18539,17 +18849,9 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t  if (lang_hooks.decls.function_decl_deleted_p (decl)\n \t      && (! dwarf_strict))\n \t    add_AT_flag (subr_die, DW_AT_GNU_deleted, 1);\n-\n-\t  /* The first time we see a member function, it is in the context of\n-\t     the class to which it belongs.  We make sure of this by emitting\n-\t     the class first.  The next time is the definition, which is\n-\t     handled above.  The two may come from the same source text.\n-\n-\t     Note that force_decl_die() forces function declaration die. It is\n-\t     later reused to represent definition.  */\n-\t  equate_decl_number_to_die (decl, subr_die);\n \t}\n     }\n+  /* Tag abstract instances with DW_AT_inline.  */\n   else if (DECL_ABSTRACT_P (decl))\n     {\n       if (DECL_DECLARED_INLINE_P (decl))\n@@ -18570,18 +18872,15 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n       if (DECL_DECLARED_INLINE_P (decl)\n \t  && lookup_attribute (\"artificial\", DECL_ATTRIBUTES (decl)))\n \tadd_AT_flag (subr_die, DW_AT_artificial, 1);\n-\n-      equate_decl_number_to_die (decl, subr_die);\n     }\n-  else if (!DECL_EXTERNAL (decl))\n+  /* For non DECL_EXTERNALs, if range information is available, fill\n+     the DIE with it.  */\n+  else if (!DECL_EXTERNAL (decl) && !early_dwarf)\n     {\n       HOST_WIDE_INT cfa_fb_offset;\n-      struct function *fun = DECL_STRUCT_FUNCTION (decl);\n \n-      if (!old_die || !get_AT (old_die, DW_AT_inline))\n-\tequate_decl_number_to_die (decl, subr_die);\n+      struct function *fun = DECL_STRUCT_FUNCTION (decl);\n \n-      gcc_checking_assert (fun);\n       if (!flag_reorder_blocks_and_partition)\n \t{\n \t  dw_fde_ref fde = fun->fde;\n@@ -18735,12 +19034,13 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n       compute_frame_pointer_to_fb_displacement (cfa_fb_offset);\n \n       if (fun->static_chain_decl)\n-\tadd_AT_location_description (subr_die, DW_AT_static_link,\n-\t\t loc_list_from_tree (fun->static_chain_decl, 2, NULL));\n+\tadd_AT_location_description\n+\t  (subr_die, DW_AT_static_link,\n+\t   loc_list_from_tree (fun->static_chain_decl, 2, NULL));\n     }\n \n   /* Generate child dies for template paramaters.  */\n-  if (debug_info_level > DINFO_LEVEL_TERSE)\n+  if (early_dwarf && debug_info_level > DINFO_LEVEL_TERSE)\n     gen_generic_params_dies (decl);\n \n   /* Now output descriptions of the arguments for this function. This gets\n@@ -18764,7 +19064,8 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n     {\n       /* Generate DIEs to represent all known formal parameters.  */\n       tree parm = DECL_ARGUMENTS (decl);\n-      tree generic_decl = lang_hooks.decls.get_generic_function_decl (decl);\n+      tree generic_decl = early_dwarf\n+\t? lang_hooks.decls.get_generic_function_decl (decl) : NULL;\n       tree generic_decl_parm = generic_decl\n \t\t\t\t? DECL_ARGUMENTS (generic_decl)\n \t\t\t\t: NULL;\n@@ -18829,11 +19130,14 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \tgen_unspecified_parameters_die (decl, subr_die);\n     }\n \n+  if (subr_die != old_die)\n+    /* Add the calling convention attribute if requested.  */\n+    add_calling_convention_attribute (subr_die, decl);\n+\n   /* Output Dwarf info for all of the stuff within the body of the function\n-     (if it has one - it may be just a declaration).  */\n-  outer_scope = DECL_INITIAL (decl);\n+     (if it has one - it may be just a declaration).\n \n-  /* OUTER_SCOPE is a pointer to the outermost BLOCK node created to represent\n+     OUTER_SCOPE is a pointer to the outermost BLOCK node created to represent\n      a function.  This BLOCK actually represents the outermost binding contour\n      for the function, i.e. the contour in which the function's formal\n      parameters and labels get declared. Curiously, it appears that the front\n@@ -18847,6 +19151,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n      a BLOCK node representing the function's outermost pair of curly braces,\n      and any blocks used for the base and member initializers of a C++\n      constructor function.  */\n+  tree outer_scope = DECL_INITIAL (decl);\n   if (! declaration && outer_scope && TREE_CODE (outer_scope) != ERROR_MARK)\n     {\n       int call_site_note_count = 0;\n@@ -18856,6 +19161,9 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n       if (DECL_NAME (DECL_RESULT (decl)))\n \tgen_decl_die (DECL_RESULT (decl), NULL, subr_die);\n \n+      /* The first time through decls_for_scope we will generate the\n+\t DIEs for the locals.  The second time, we fill in the\n+\t location info.  */\n       decls_for_scope (outer_scope, subr_die);\n \n       if (call_arg_locations && !dwarf_strict)\n@@ -19007,10 +19315,6 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n       call_site_count = -1;\n       tail_call_site_count = -1;\n     }\n-\n-  if (subr_die != old_die)\n-    /* Add the calling convention attribute if requested.  */\n-    add_calling_convention_attribute (subr_die, decl);\n }\n \n /* Returns a hash value for X (which really is a die_struct).  */\n@@ -19030,6 +19334,33 @@ block_die_hasher::equal (die_struct *x, die_struct *y)\n   return x->decl_id == y->decl_id && x->die_parent == y->die_parent;\n }\n \n+/* Return TRUE if DECL, which may have been previously generated as\n+   OLD_DIE, is a candidate for a DW_AT_specification.  DECLARATION is\n+   true if decl (or its origin) is either an extern declaration or a\n+   class/namespace scoped declaration.\n+\n+   The declare_in_namespace support causes us to get two DIEs for one\n+   variable, both of which are declarations.  We want to avoid\n+   considering one to be a specification, so we must test for\n+   DECLARATION and DW_AT_declaration.  */\n+static inline bool\n+decl_will_get_specification_p (dw_die_ref old_die, tree decl, bool declaration)\n+{\n+  return (old_die && TREE_STATIC (decl) && !declaration\n+\t  && get_AT_flag (old_die, DW_AT_declaration) == 1);\n+}\n+\n+/* Return true if DECL is a local static.  */\n+\n+static inline bool\n+local_function_static (tree decl)\n+{\n+  gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+  return TREE_STATIC (decl)\n+    && DECL_CONTEXT (decl)\n+    && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL;\n+}\n+\n /* Generate a DIE to represent a declared data object.\n    Either DECL or ORIGIN must be non-null.  */\n \n@@ -19042,7 +19373,7 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n   tree ultimate_origin;\n   dw_die_ref var_die;\n   dw_die_ref old_die = decl ? lookup_decl_die (decl) : NULL;\n-  dw_die_ref origin_die;\n+  dw_die_ref origin_die = NULL;\n   bool declaration = (DECL_EXTERNAL (decl_or_origin)\n \t\t      || class_or_namespace_scope_p (context_die));\n   bool specialization_p = false;\n@@ -19157,12 +19488,38 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n       return;\n     }\n \n-  /* If the compiler emitted a definition for the DECL declaration\n-     and if we already emitted a DIE for it, don't emit a second\n-     DIE for it again. Allow re-declarations of DECLs that are\n-     inside functions, though.  */\n-  if (old_die && declaration && !local_scope_p (context_die))\n-    return;\n+  if (old_die)\n+    {\n+      if (declaration)\n+\t{\n+\t  /* A declaration that has been previously dumped, needs no\n+\t     further annotations, since it doesn't need location on\n+\t     the second pass.  */\n+\t  return;\n+\t}\n+      else if (decl_will_get_specification_p (old_die, decl, declaration)\n+\t       && !get_AT (old_die, DW_AT_specification))\n+\t{\n+\t  /* Fall-thru so we can make a new variable die along with a\n+\t     DW_AT_specification.  */\n+\t}\n+      else if (origin && old_die->die_parent != context_die)\n+\t{\n+\t  /* If we will be creating an inlined instance, we need a\n+\t     new DIE that will get annotated with\n+\t     DW_AT_abstract_origin.  Clear things so we can get a\n+\t     new DIE.  */\n+\t  gcc_assert (!DECL_ABSTRACT_P (decl));\n+\t  old_die = NULL;\n+\t}\n+      else\n+\t{\n+\t  /* If a DIE was dumped early, it still needs location info.\n+\t     Skip to where we fill the location bits.  */\n+\t  var_die = old_die;\n+\t  goto gen_variable_die_location;\n+\t}\n+    }\n \n   /* For static data members, the declaration in the class is supposed\n      to have DW_TAG_member tag; the specification should still be\n@@ -19172,7 +19529,6 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n   else\n     var_die = new_die (DW_TAG_variable, context_die, decl);\n \n-  origin_die = NULL;\n   if (origin != NULL)\n     origin_die = add_abstract_origin_attribute (var_die, origin);\n \n@@ -19183,14 +19539,8 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n      copy decls and set the DECL_ABSTRACT_P flag on them instead of\n      sharing them.\n \n-     ??? Duplicated blocks have been rewritten to use .debug_ranges.\n-\n-     ??? The declare_in_namespace support causes us to get two DIEs for one\n-     variable, both of which are declarations.  We want to avoid considering\n-     one to be a specification, so we must test that this DIE is not a\n-     declaration.  */\n-  else if (old_die && TREE_STATIC (decl) && ! declaration\n-\t   && get_AT_flag (old_die, DW_AT_declaration) == 1)\n+     ??? Duplicated blocks have been rewritten to use .debug_ranges.  */\n+  else if (decl_will_get_specification_p (old_die, decl, declaration))\n     {\n       /* This is a definition of a C++ class level static.  */\n       add_AT_specification (var_die, old_die);\n@@ -19244,9 +19594,11 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n   if (declaration)\n     add_AT_flag (var_die, DW_AT_declaration, 1);\n \n-  if (decl && (DECL_ABSTRACT_P (decl) || declaration || old_die == NULL))\n+  if (decl && (DECL_ABSTRACT_P (decl)\n+\t       || !old_die || is_declaration_die (old_die)))\n     equate_decl_number_to_die (decl, var_die);\n \n+ gen_variable_die_location:\n   if (! declaration\n       && (! DECL_ABSTRACT_P (decl_or_origin)\n \t  /* Local static vars are shared between all clones/inlines,\n@@ -19259,13 +19611,11 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n \t to add it again.  */\n       && (origin_die == NULL || get_AT (origin_die, DW_AT_location) == NULL))\n     {\n-      if (TREE_CODE (decl_or_origin) == VAR_DECL && TREE_STATIC (decl_or_origin)\n-          && !TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl_or_origin)))\n-\tdefer_location (decl_or_origin, var_die);\n+      if (early_dwarf)\n+\tadd_pubname (decl_or_origin, var_die);\n       else\n-        add_location_or_const_value_attribute (var_die, decl_or_origin,\n+\tadd_location_or_const_value_attribute (var_die, decl_or_origin,\n \t\t\t\t\t       decl == NULL, DW_AT_location);\n-      add_pubname (decl_or_origin, var_die);\n     }\n   else\n     tree_add_const_value_attribute_for_decl (var_die, decl_or_origin);\n@@ -19279,7 +19629,12 @@ gen_const_die (tree decl, dw_die_ref context_die)\n   dw_die_ref const_die;\n   tree type = TREE_TYPE (decl);\n \n+  const_die = lookup_decl_die (decl);\n+  if (const_die)\n+    return;\n+\n   const_die = new_die (DW_TAG_constant, context_die, decl);\n+  equate_decl_number_to_die (decl, const_die);\n   add_name_and_src_coords_attributes (const_die, decl);\n   add_type_attribute (const_die, type, TYPE_QUAL_CONST, context_die);\n   if (TREE_PUBLIC (decl))\n@@ -19295,14 +19650,20 @@ static void\n gen_label_die (tree decl, dw_die_ref context_die)\n {\n   tree origin = decl_ultimate_origin (decl);\n-  dw_die_ref lbl_die = new_die (DW_TAG_label, context_die, decl);\n+  dw_die_ref lbl_die = lookup_decl_die (decl);\n   rtx insn;\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n-  if (origin != NULL)\n-    add_abstract_origin_attribute (lbl_die, origin);\n-  else\n-    add_name_and_src_coords_attributes (lbl_die, decl);\n+  if (!lbl_die)\n+    {\n+      lbl_die = new_die (DW_TAG_label, context_die, decl);\n+      equate_decl_number_to_die (decl, lbl_die);\n+\n+      if (origin != NULL)\n+\tadd_abstract_origin_attribute (lbl_die, origin);\n+      else\n+\tadd_name_and_src_coords_attributes (lbl_die, decl);\n+    }\n \n   if (DECL_ABSTRACT_P (decl))\n     equate_decl_number_to_die (decl, lbl_die);\n@@ -19456,13 +19817,56 @@ add_high_low_attributes (tree stmt, dw_die_ref die)\n static void\n gen_lexical_block_die (tree stmt, dw_die_ref context_die)\n {\n-  dw_die_ref stmt_die = new_die (DW_TAG_lexical_block, context_die, stmt);\n+  dw_die_ref old_die = BLOCK_DIE (stmt);\n+  dw_die_ref stmt_die;\n+  if (!old_die)\n+    {\n+      stmt_die = new_die (DW_TAG_lexical_block, context_die, stmt);\n+      BLOCK_DIE (stmt) = stmt_die;\n+    }\n+\n+  if (BLOCK_ABSTRACT (stmt))\n+    {\n+      if (old_die)\n+\t{\n+#ifdef ENABLE_CHECKING\n+\t  /* This must have been generated early and it won't even\n+\t     need location information since it's a DW_AT_inline\n+\t     function.  */\n+\t  for (dw_die_ref c = context_die; c; c = c->die_parent)\n+\t    if (c->die_tag == DW_TAG_inlined_subroutine\n+\t\t|| c->die_tag == DW_TAG_subprogram)\n+\t      {\n+\t\tgcc_assert (get_AT (c, DW_AT_inline));\n+\t\tbreak;\n+\t      }\n+#endif\n+\t  return;\n+\t}\n+    }\n+  else if (BLOCK_ABSTRACT_ORIGIN (stmt))\n+    {\n+      /* If this is an inlined instance, create a new lexical die for\n+\t anything below to attach DW_AT_abstract_origin to.  */\n+      if (old_die)\n+\t{\n+\t  stmt_die = new_die (DW_TAG_lexical_block, context_die, stmt);\n+\t  BLOCK_DIE (stmt) = stmt_die;\n+\t  old_die = NULL;\n+\t}\n+    }\n \n-  if (call_arg_locations)\n-    BLOCK_DIE (stmt) = stmt_die;\n+  if (old_die)\n+    stmt_die = old_die;\n \n-  if (! BLOCK_ABSTRACT (stmt) && TREE_ASM_WRITTEN (stmt))\n-    add_high_low_attributes (stmt, stmt_die);\n+  if (!early_dwarf)\n+    {\n+      /* A non abstract block whose blocks have already been reordered\n+\t should have the instruction range for this block.  If so, set the\n+\t high/low attributes.  */\n+      if (! BLOCK_ABSTRACT (stmt) && TREE_ASM_WRITTEN (stmt))\n+\tadd_high_low_attributes (stmt, stmt_die);\n+    }\n \n   decls_for_scope (stmt, stmt_die);\n }\n@@ -19957,6 +20361,18 @@ static void\n gen_struct_or_union_type_die (tree type, dw_die_ref context_die,\n \t\t\t\tenum debug_info_usage usage)\n {\n+  /* Fill in the bound of variable-length fields in late dwarf if\n+     still incomplete.  */\n+  if (TREE_ASM_WRITTEN (type)\n+      && variably_modified_type_p (type, NULL)\n+      && !early_dwarf)\n+    {\n+      tree member;\n+      for (member = TYPE_FIELDS (type); member; member = DECL_CHAIN (member))\n+\tfill_variable_array_bounds (TREE_TYPE (member));\n+      return;\n+    }\n+\n   dw_die_ref type_die = lookup_type_die (type);\n   dw_die_ref scope_die = 0;\n   int nested = 0;\n@@ -20076,7 +20492,11 @@ gen_typedef_die (tree decl, dw_die_ref context_die)\n   tree origin;\n \n   if (TREE_ASM_WRITTEN (decl))\n-    return;\n+    {\n+      if (DECL_ORIGINAL_TYPE (decl))\n+\tfill_variable_array_bounds (DECL_ORIGINAL_TYPE (decl));\n+      return;\n+    }\n \n   TREE_ASM_WRITTEN (decl) = 1;\n   type_die = new_die (DW_TAG_typedef, context_die, decl);\n@@ -20092,13 +20512,19 @@ gen_typedef_die (tree decl, dw_die_ref context_die)\n \t{\n \t  type = DECL_ORIGINAL_TYPE (decl);\n \n+\t  if (type == error_mark_node)\n+\t    return;\n+\n \t  gcc_assert (type != TREE_TYPE (decl));\n \t  equate_type_number_to_die (TREE_TYPE (decl), type_die);\n \t}\n       else\n \t{\n \t  type = TREE_TYPE (decl);\n \n+\t  if (type == error_mark_node)\n+\t    return;\n+\n \t  if (is_naming_typedef_decl (TYPE_NAME (type)))\n \t    {\n \t      /* Here, we are in the case of decl being a typedef naming\n@@ -20159,13 +20585,15 @@ gen_tagged_type_die (tree type,\n       || !is_tagged_type (type))\n     return;\n \n+  if (TREE_ASM_WRITTEN (type))\n+    need_pop = 0;\n   /* If this is a nested type whose containing class hasn't been written\n      out yet, writing it out will cover this one, too.  This does not apply\n      to instantiations of member class templates; they need to be added to\n      the containing class as they are generated.  FIXME: This hurts the\n      idea of combining type decls from multiple TUs, since we can't predict\n      what set of template instantiations we'll get.  */\n-  if (TYPE_CONTEXT (type)\n+  else if (TYPE_CONTEXT (type)\n       && AGGREGATE_TYPE_P (TYPE_CONTEXT (type))\n       && ! TREE_ASM_WRITTEN (TYPE_CONTEXT (type)))\n     {\n@@ -20297,7 +20725,18 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n     }\n \n   if (TREE_ASM_WRITTEN (type))\n-    return;\n+    {\n+      /* Variable-length types may be incomplete even if\n+\t TREE_ASM_WRITTEN.  For such types, fall through to\n+\t gen_array_type_die() and possibly fill in\n+\t DW_AT_{upper,lower}_bound attributes.  */\n+      if ((TREE_CODE (type) != ARRAY_TYPE\n+\t   && TREE_CODE (type) != RECORD_TYPE\n+\t   && TREE_CODE (type) != UNION_TYPE\n+\t   && TREE_CODE (type) != QUAL_UNION_TYPE)\n+\t  || !variably_modified_type_p (type, NULL))\n+\treturn;\n+    }\n \n   switch (TREE_CODE (type))\n     {\n@@ -20349,9 +20788,6 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n       break;\n \n     case ARRAY_TYPE:\n-      gen_array_type_die (type, context_die);\n-      break;\n-\n     case VECTOR_TYPE:\n       gen_array_type_die (type, context_die);\n       break;\n@@ -20522,8 +20958,11 @@ process_scope_var (tree stmt, tree decl, tree origin, dw_die_ref context_die)\n   if (die != NULL && die->die_parent == NULL)\n     add_child_die (context_die, die);\n   else if (TREE_CODE (decl_or_origin) == IMPORTED_DECL)\n-    dwarf2out_imported_module_or_decl_1 (decl_or_origin, DECL_NAME (decl_or_origin),\n-\t\t\t\t\t stmt, context_die);\n+    {\n+      if (early_dwarf)\n+\tdwarf2out_imported_module_or_decl_1 (decl_or_origin, DECL_NAME (decl_or_origin),\n+\t\t\t\t\t     stmt, context_die);\n+    }\n   else\n     gen_decl_die (decl, origin, context_die);\n }\n@@ -20759,7 +21198,9 @@ setup_namespace_context (tree thing, dw_die_ref context_die)\n    type) within its namespace, if appropriate.\n \n    For compatibility with older debuggers, namespace DIEs only contain\n-   declarations; all definitions are emitted at CU scope.  */\n+   declarations; all definitions are emitted at CU scope, with\n+   DW_AT_specification pointing to the declaration (like with class\n+   members).  */\n \n static dw_die_ref\n declare_in_namespace (tree thing, dw_die_ref context_die)\n@@ -21076,16 +21517,65 @@ gen_decl_die (tree decl, tree origin, dw_die_ref context_die)\n   return NULL;\n }\n \f\n-/* Output debug information for global decl DECL.  Called from toplev.c after\n-   compilation proper has finished.  */\n+/* Output initial debug information for global DECL.  Called at the\n+   end of the parsing process.\n+\n+   This is the initial debug generation process.  As such, the DIEs\n+   generated may be incomplete.  A later debug generation pass\n+   (dwarf2out_late_global_decl) will augment the information generated\n+   in this pass (e.g., with complete location info).  */\n+\n+static void\n+dwarf2out_early_global_decl (tree decl)\n+{\n+  set_early_dwarf s;\n+\n+  /* gen_decl_die() will set DECL_ABSTRACT because\n+     cgraph_function_possibly_inlined_p() returns true.  This is in\n+     turn will cause DW_AT_inline attributes to be set.\n+\n+     This happens because at early dwarf generation, there is no\n+     cgraph information, causing cgraph_function_possibly_inlined_p()\n+     to return true.  Trick cgraph_function_possibly_inlined_p()\n+     while we generate dwarf early.  */\n+  bool save = symtab->global_info_ready;\n+  symtab->global_info_ready = true;\n+\n+  /* We don't handle TYPE_DECLs.  If required, they'll be reached via\n+     other DECLs and they can point to template types or other things\n+     that dwarf2out can't handle when done via dwarf2out_decl.  */\n+  if (TREE_CODE (decl) != TYPE_DECL\n+      && TREE_CODE (decl) != PARM_DECL)\n+    {\n+      tree save_fndecl = current_function_decl;\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t{\n+\t  /* No cfun means the symbol has no body, so there's nothing\n+\t     to emit.  */\n+\t  if (!DECL_STRUCT_FUNCTION (decl))\n+\t    goto early_decl_exit;\n+\n+\t  current_function_decl = decl;\n+\t}\n+      dwarf2out_decl (decl);\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\tcurrent_function_decl = save_fndecl;\n+    }\n+ early_decl_exit:\n+  symtab->global_info_ready = save;\n+}\n+\n+/* Output debug information for global decl DECL.  Called from\n+   toplev.c after compilation proper has finished.  */\n \n static void\n-dwarf2out_global_decl (tree decl)\n+dwarf2out_late_global_decl (tree decl)\n {\n-  /* Output DWARF2 information for file-scope tentative data object\n-     declarations, file-scope (extern) function declarations (which\n-     had no corresponding body) and file-scope tagged type declarations\n-     and definitions which have not yet been forced out.  */\n+  /* Output any global decls we missed or fill-in any location\n+     information we were unable to determine on the first pass.\n+\n+     Skip over functions because they were handled by the\n+     debug_hooks->function_decl() call in rest_of_handle_final.  */\n   if ((TREE_CODE (decl) != FUNCTION_DECL || !DECL_INITIAL (decl))\n       && !POINTER_BOUNDS_P (decl))\n     dwarf2out_decl (decl);\n@@ -21097,7 +21587,10 @@ static void\n dwarf2out_type_decl (tree decl, int local)\n {\n   if (!local)\n-    dwarf2out_decl (decl);\n+    {\n+      set_early_dwarf s;\n+      dwarf2out_decl (decl);\n+    }\n }\n \n /* Output debug information for imported module or decl DECL.\n@@ -21205,6 +21698,8 @@ dwarf2out_imported_module_or_decl (tree decl, tree name, tree context,\n \n   gcc_assert (decl);\n \n+  set_early_dwarf s;\n+\n   /* To emit DW_TAG_imported_module or DW_TAG_imported_decl, we need two DIEs.\n      We need decl DIE for reference and scope die. First, get DIE for the decl\n      itself.  */\n@@ -21231,7 +21726,6 @@ dwarf2out_imported_module_or_decl (tree decl, tree name, tree context,\n \n   /* OK, now we have DIEs for decl as well as scope. Emit imported die.  */\n   dwarf2out_imported_module_or_decl_1 (decl, name, context, scope_die);\n-\n }\n \n /* Output debug information for namelists.   */\n@@ -21271,7 +21765,7 @@ gen_namelist_decl (tree name, dw_die_ref scope_die, tree item_decls)\n }\n \n \n-/* Write the debugging output for DECL.  */\n+/* Write the debugging output for DECL and return the DIE.  */\n \n static void\n dwarf2out_decl (tree decl)\n@@ -21330,21 +21824,8 @@ dwarf2out_decl (tree decl)\n       break;\n \n     case VAR_DECL:\n-      /* Ignore this VAR_DECL if it refers to a file-scope extern data object\n-\t declaration and if the declaration was never even referenced from\n-\t within this entire compilation unit.  We suppress these DIEs in\n-\t order to save space in the .debug section (by eliminating entries\n-\t which are probably useless).  Note that we must not suppress\n-\t block-local extern declarations (whether used or not) because that\n-\t would screw-up the debugger's name lookup mechanism and cause it to\n-\t miss things which really ought to be in scope at a given point.  */\n-      if (DECL_EXTERNAL (decl) && !TREE_USED (decl))\n-\treturn;\n-\n       /* For local statics lookup proper context die.  */\n-      if (TREE_STATIC (decl)\n-\t  && DECL_CONTEXT (decl)\n-\t  && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)\n+      if (local_function_static (decl))\n \tcontext_die = lookup_decl_die (DECL_CONTEXT (decl));\n \n       /* If we are in terse mode, don't generate any DIEs to represent any\n@@ -21399,6 +21880,10 @@ dwarf2out_decl (tree decl)\n     }\n \n   gen_decl_die (decl, NULL, context_die);\n+\n+  dw_die_ref die = lookup_decl_die (decl);\n+  if (die)\n+    check_die (die);\n }\n \n /* Write the debugging output for DECL.  */\n@@ -21485,23 +21970,16 @@ dwarf_file_hasher::hash (dwarf_file_data *p)\n    section) and references to those files numbers (in the .debug_srcinfo\n    and.debug_macinfo sections).  If the filename given as an argument is not\n    found in our current list, add it to the list and assign it the next\n-   available unique index number.  In order to speed up searches, we remember\n-   the index of the filename was looked up last.  This handles the majority of\n-   all searches.  */\n+   available unique index number.  */\n \n static struct dwarf_file_data *\n lookup_filename (const char *file_name)\n {\n   struct dwarf_file_data * created;\n \n-  /* Check to see if the file name that was searched on the previous\n-     call matches this file name.  If so, return the index.  */\n-  if (file_table_last_lookup\n-      && (file_name == file_table_last_lookup->filename\n-\t  || filename_cmp (file_table_last_lookup->filename, file_name) == 0))\n-    return file_table_last_lookup;\n+  if (!file_name)\n+    return NULL;\n \n-  /* Didn't match the previous lookup, search the table.  */\n   dwarf_file_data **slot\n     = file_table->find_slot_with_hash (file_name, htab_hash_string (file_name),\n \t\t\t\t       INSERT);\n@@ -24550,11 +25028,12 @@ optimize_location_lists (dw_die_ref die)\n static void\n dwarf2out_finish (const char *filename)\n {\n-  limbo_die_node *node, *next_node;\n   comdat_type_node *ctnode;\n-  unsigned int i;\n   dw_die_ref main_comp_unit_die;\n \n+  /* Flush out any latecomers to the limbo party.  */\n+  dwarf2out_early_finish ();\n+\n   /* PCH might result in DW_AT_producer string being restored from the\n      header compilation, so always fill it with empty string initially\n      and overwrite only here.  */\n@@ -24584,65 +25063,6 @@ dwarf2out_finish (const char *filename)\n \tadd_comp_dir_attribute (comp_unit_die ());\n     }\n \n-  if (deferred_locations_list)\n-    for (i = 0; i < deferred_locations_list->length (); i++)\n-      {\n-\tadd_location_or_const_value_attribute (\n-\t    (*deferred_locations_list)[i].die,\n-\t    (*deferred_locations_list)[i].variable,\n-\t    false,\n-\t    DW_AT_location);\n-      }\n-\n-  /* Traverse the limbo die list, and add parent/child links.  The only\n-     dies without parents that should be here are concrete instances of\n-     inline functions, and the comp_unit_die.  We can ignore the comp_unit_die.\n-     For concrete instances, we can get the parent die from the abstract\n-     instance.  */\n-  for (node = limbo_die_list; node; node = next_node)\n-    {\n-      dw_die_ref die = node->die;\n-      next_node = node->next;\n-\n-      if (die->die_parent == NULL)\n-\t{\n-\t  dw_die_ref origin = get_AT_ref (die, DW_AT_abstract_origin);\n-\n-\t  if (origin && origin->die_parent)\n-\t    add_child_die (origin->die_parent, die);\n-\t  else if (is_cu_die (die))\n-\t    ;\n-\t  else if (seen_error ())\n-\t    /* It's OK to be confused by errors in the input.  */\n-\t    add_child_die (comp_unit_die (), die);\n-\t  else\n-\t    {\n-\t      /* In certain situations, the lexical block containing a\n-\t\t nested function can be optimized away, which results\n-\t\t in the nested function die being orphaned.  Likewise\n-\t\t with the return type of that nested function.  Force\n-\t\t this to be a child of the containing function.\n-\n-\t\t It may happen that even the containing function got fully\n-\t\t inlined and optimized out.  In that case we are lost and\n-\t\t assign the empty child.  This should not be big issue as\n-\t\t the function is likely unreachable too.  */\n-\t      gcc_assert (node->created_for);\n-\n-\t      if (DECL_P (node->created_for))\n-\t\torigin = get_context_die (DECL_CONTEXT (node->created_for));\n-\t      else if (TYPE_P (node->created_for))\n-\t\torigin = scope_die_for (node->created_for, comp_unit_die ());\n-\t      else\n-\t\torigin = comp_unit_die ();\n-\n-\t      add_child_die (origin, die);\n-\t    }\n-\t}\n-    }\n-\n-  limbo_die_list = NULL;\n-\n #if ENABLE_ASSERT_CHECKING\n   {\n     dw_die_ref die = comp_unit_die (), c;\n@@ -24652,23 +25072,6 @@ dwarf2out_finish (const char *filename)\n   resolve_addr (comp_unit_die ());\n   move_marked_base_types ();\n \n-  for (node = deferred_asm_name; node; node = node->next)\n-    {\n-      tree decl = node->created_for;\n-      /* When generating LTO bytecode we can not generate new assembler\n-         names at this point and all important decls got theirs via\n-\t free-lang-data.  */\n-      if (((!flag_generate_lto && !flag_generate_offload)\n-\t   || DECL_ASSEMBLER_NAME_SET_P (decl))\n-\t  && DECL_ASSEMBLER_NAME (decl) != DECL_NAME (decl))\n-\t{\n-\t  add_linkage_attr (node->die, decl);\n-\t  move_linkage_attr (node->die);\n-\t}\n-    }\n-\n-  deferred_asm_name = NULL;\n-\n   /* Walk through the list of incomplete types again, trying once more to\n      emit full debugging info for them.  */\n   retry_incomplete_types ();\n@@ -24707,6 +25110,7 @@ dwarf2out_finish (const char *filename)\n   /* Traverse the DIE's and add add sibling attributes to those DIE's\n      that have children.  */\n   add_sibling_attributes (comp_unit_die ());\n+  limbo_die_node *node;\n   for (node = limbo_die_list; node; node = node->next)\n     add_sibling_attributes (node->die);\n   for (ctnode = comdat_type_list; ctnode != NULL; ctnode = ctnode->next)\n@@ -24968,6 +25372,83 @@ dwarf2out_finish (const char *filename)\n     output_indirect_strings ();\n }\n \n+/* Perform any cleanups needed after the early debug generation pass\n+   has run.  */\n+\n+static void\n+dwarf2out_early_finish (void)\n+{\n+  limbo_die_node *node, *next_node;\n+\n+  /* Add DW_AT_linkage_name for all deferred DIEs.  */\n+  for (node = deferred_asm_name; node; node = node->next)\n+    {\n+      tree decl = node->created_for;\n+      if (DECL_ASSEMBLER_NAME (decl) != DECL_NAME (decl)\n+\t  /* A missing DECL_ASSEMBLER_NAME can be a constant DIE that\n+\t     ended up in in deferred_asm_name before we knew it was\n+\t     constant and never written to disk.  */\n+\t  && DECL_ASSEMBLER_NAME (decl))\n+\t{\n+\t  add_linkage_attr (node->die, decl);\n+\t  move_linkage_attr (node->die);\n+\t}\n+    }\n+  deferred_asm_name = NULL;\n+\n+  /* Traverse the limbo die list, and add parent/child links.  The only\n+     dies without parents that should be here are concrete instances of\n+     inline functions, and the comp_unit_die.  We can ignore the comp_unit_die.\n+     For concrete instances, we can get the parent die from the abstract\n+     instance.\n+\n+     The point here is to flush out the limbo list so that it is empty\n+     and we don't need to stream it for LTO.  */\n+  for (node = limbo_die_list; node; node = next_node)\n+    {\n+      dw_die_ref die = node->die;\n+      next_node = node->next;\n+\n+      if (die->die_parent == NULL)\n+\t{\n+\t  dw_die_ref origin = get_AT_ref (die, DW_AT_abstract_origin);\n+\n+\t  if (origin && origin->die_parent)\n+\t    add_child_die (origin->die_parent, die);\n+\t  else if (is_cu_die (die))\n+\t    ;\n+\t  else if (seen_error ())\n+\t    /* It's OK to be confused by errors in the input.  */\n+\t    add_child_die (comp_unit_die (), die);\n+\t  else\n+\t    {\n+\t      /* In certain situations, the lexical block containing a\n+\t\t nested function can be optimized away, which results\n+\t\t in the nested function die being orphaned.  Likewise\n+\t\t with the return type of that nested function.  Force\n+\t\t this to be a child of the containing function.\n+\n+\t\t It may happen that even the containing function got fully\n+\t\t inlined and optimized out.  In that case we are lost and\n+\t\t assign the empty child.  This should not be big issue as\n+\t\t the function is likely unreachable too.  */\n+\t      gcc_assert (node->created_for);\n+\n+\t      if (DECL_P (node->created_for))\n+\t\torigin = get_context_die (DECL_CONTEXT (node->created_for));\n+\t      else if (TYPE_P (node->created_for))\n+\t\torigin = scope_die_for (node->created_for, comp_unit_die ());\n+\t      else\n+\t\torigin = comp_unit_die ();\n+\n+\t      add_child_die (origin, die);\n+\t    }\n+\t}\n+    }\n+\n+  limbo_die_list = NULL;\n+}\n+\n /* Reset all state within dwarf2out.c so that we can rerun the compiler\n    within the same process.  For use by toplev::finalize.  */\n \n@@ -25006,13 +25487,10 @@ dwarf2out_c_finalize (void)\n   cold_text_section = NULL;\n   current_unit_personality = NULL;\n \n-  deferred_locations_list = NULL;\n-\n   next_die_offset = 0;\n   single_comp_unit_die = NULL;\n   comdat_type_list = NULL;\n   limbo_die_list = NULL;\n-  deferred_asm_name = NULL;\n   file_table = NULL;\n   decl_die_table = NULL;\n   common_block_die_table = NULL;\n@@ -25045,7 +25523,6 @@ dwarf2out_c_finalize (void)\n   poc_label_num = 0;\n   last_emitted_file = NULL;\n   label_num = 0;\n-  file_table_last_lookup = NULL;\n   tmpl_value_parm_die_table = NULL;\n   generic_type_instances = NULL;\n   frame_pointer_fb_offset = 0;"}, {"sha": "c4958ee1d5fc7fb53c85a5e4a3c78f0753317c04", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -1,3 +1,13 @@\n+2015-06-05  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* f95-lang.c (gfc_write_global_declarations): Remove.\n+\t(LANG_HOOKS_WRITE_GLOBALS): Remove.\n+\t(gfc_write_global_declarations): Move code from here to...\n+\t(gfc_be_parse_file): ...here.\n+\tCall global_decl_processing.\n+\t* trans-decl.c (gfc_emit_parameter_debug_info): Rename global_decl\n+\tto early_global_decl.\n+\n 2015-06-05  Russell Whitesides  <russelldub@gmail.com>\n \t    Steven G. Kargl  <kargl@gcc.gnu.org>\n "}, {"sha": "f439427aca3175f3d960c5b3f0fc239bd69b4808", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 12, "deletions": 29, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -94,7 +94,6 @@ static bool global_bindings_p (void);\n /* Each front end provides its own.  */\n static bool gfc_init (void);\n static void gfc_finish (void);\n-static void gfc_write_global_declarations (void);\n static void gfc_be_parse_file (void);\n static alias_set_type gfc_get_alias_set (tree);\n static void gfc_init_ts (void);\n@@ -121,7 +120,6 @@ static const struct attribute_spec gfc_attribute_table[] =\n #undef LANG_HOOKS_NAME\n #undef LANG_HOOKS_INIT\n #undef LANG_HOOKS_FINISH\n-#undef LANG_HOOKS_WRITE_GLOBALS\n #undef LANG_HOOKS_OPTION_LANG_MASK\n #undef LANG_HOOKS_INIT_OPTIONS_STRUCT\n #undef LANG_HOOKS_INIT_OPTIONS\n@@ -155,7 +153,6 @@ static const struct attribute_spec gfc_attribute_table[] =\n #define LANG_HOOKS_NAME                 \"GNU Fortran\"\n #define LANG_HOOKS_INIT                 gfc_init\n #define LANG_HOOKS_FINISH               gfc_finish\n-#define LANG_HOOKS_WRITE_GLOBALS\tgfc_write_global_declarations\n #define LANG_HOOKS_OPTION_LANG_MASK\tgfc_option_lang_mask\n #define LANG_HOOKS_INIT_OPTIONS_STRUCT  gfc_init_options_struct\n #define LANG_HOOKS_INIT_OPTIONS         gfc_init_options\n@@ -226,9 +223,21 @@ gfc_be_parse_file (void)\n   while (!global_bindings_p ())\n     poplevel (0, 0);\n \n+  /* Finalize all of the globals.\n+\n+     Emulated tls lowering needs to see all TLS variables before we\n+     call finalize_compilation_unit.  The C/C++ front ends manage this\n+     by calling decl_rest_of_compilation on each global and static\n+     variable as they are seen.  The Fortran front end waits until\n+     here.  */\n+  for (tree decl = getdecls (); decl ; decl = DECL_CHAIN (decl))\n+    rest_of_decl_compilation (decl, true, true);\n+\n   /* Switch to the default tree diagnostics here, because there may be\n      diagnostics before gfc_finish().  */\n   gfc_diagnostics_finish ();\n+\n+  global_decl_processing ();\n }\n \n \n@@ -272,32 +281,6 @@ gfc_finish (void)\n   return;\n }\n \n-/* ??? This is something of a hack.\n-\n-   Emulated tls lowering needs to see all TLS variables before we call\n-   finalize_compilation_unit.  The C/C++ front ends manage this\n-   by calling decl_rest_of_compilation on each global and static variable\n-   as they are seen.  The Fortran front end waits until this hook.\n-\n-   A Correct solution is for finalize_compilation_unit not to be\n-   called during the WRITE_GLOBALS langhook, and have that hook only do what\n-   its name suggests and write out globals.  But the C++ and Java front ends\n-   have (unspecified) problems with aliases that gets in the way.  It has\n-   been suggested that these problems would be solved by completing the\n-   conversion to cgraph-based aliases.  */\n-\n-static void\n-gfc_write_global_declarations (void)\n-{\n-  tree decl;\n-\n-  /* Finalize all of the globals.  */\n-  for (decl = getdecls(); decl ; decl = DECL_CHAIN (decl))\n-    rest_of_decl_compilation (decl, true, true);\n-\n-  write_global_declarations ();\n-}\n-\n /* These functions and variables deal with binding contours.  We only\n    need these functions for the list of PARM_DECLs, but we leave the\n    functions more general; these are a simplified version of the"}, {"sha": "65bd37d748c09740cdfc78acba26fa7b796e82e3", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -4828,7 +4828,7 @@ gfc_emit_parameter_debug_info (gfc_symbol *sym)\n \t\t\t\t\t      TREE_TYPE (decl),\n \t\t\t\t\t      sym->attr.dimension,\n \t\t\t\t\t      false, false);\n-  debug_hooks->global_decl (decl);\n+  debug_hooks->early_global_decl (decl);\n }\n \n "}, {"sha": "eda1db7f10fcaf54d52aada3069386ffc0d80f20", "filename": "gcc/gengtype.c", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -4720,33 +4720,6 @@ write_roots (pair_p variables, bool emit_pch)\n    this funcion will have to be adjusted to be more like\n    output_mangled_typename.  */\n \n-static void\n-output_typename (outf_p of, const_type_p t)\n-{\n-  switch (t->kind)\n-    {\n-    case TYPE_STRING:\n-      oprintf (of, \"str\");\n-      break;\n-    case TYPE_SCALAR:\n-      oprintf (of, \"scalar\");\n-      break;\n-    case TYPE_POINTER:\n-      output_typename (of, t->u.p);\n-      break;\n-    case TYPE_STRUCT:\n-    case TYPE_USER_STRUCT:\n-    case TYPE_UNION:\n-    case TYPE_LANG_STRUCT:\n-      oprintf (of, \"%s\", t->u.s.tag);\n-      break;\n-    case TYPE_NONE:\n-    case TYPE_UNDEFINED:\n-    case TYPE_ARRAY:\n-      gcc_unreachable ();\n-    }\n-}\n-\n #define INDENT 2\n \n /* Dumps the value of typekind KIND.  */"}, {"sha": "f996de2a3e5a7df6a52b3b6e9a24c972269cf518", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -1,3 +1,12 @@\n+2015-06-05  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* go-gcc.cc (write_global_definitions): Remove call to\n+\tfinalize_compilation_unit.\n+\tRemove Go specific debug generation.\n+\t* go-lang.c (go_langhook_parse_file): Call go_write_globals.\n+\t(go_langhook_write_globals): Remove.\n+\tRemove LANG_HOOKS_WRITE_GLOBALS everywhere.\n+\n 2015-06-04  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* go-backend.c: Adjust includes for restructured coretypes.h."}, {"sha": "65f4181fde902b207cffbff0aa74e229897ccdb9", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -3020,7 +3020,8 @@ Gcc_backend::lookup_builtin(const std::string& name)\n }\n \n // Write the definitions for all TYPE_DECLS, CONSTANT_DECLS,\n-// FUNCTION_DECLS, and VARIABLE_DECLS declared globally.\n+// FUNCTION_DECLS, and VARIABLE_DECLS declared globally, as well as\n+// emit early debugging information.\n \n void\n Gcc_backend::write_global_definitions(\n@@ -3093,11 +3094,6 @@ Gcc_backend::write_global_definitions(\n \n   wrapup_global_declarations(defs, i);\n \n-  symtab->finalize_compilation_unit();\n-\n-  check_global_declarations(defs, i);\n-  emit_debug_global_declarations(defs, i);\n-\n   delete[] defs;\n }\n "}, {"sha": "28db40aa401ef57832ef28d74eac1cbd5368ed3b", "filename": "gcc/go/go-lang.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fgo%2Fgo-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fgo%2Fgo-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-lang.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -307,6 +307,9 @@ go_langhook_parse_file (void)\n {\n   go_parse_input_files (in_fnames, num_in_fnames, flag_syntax_only,\n \t\t\tgo_require_return_statement);\n+\n+  /* Final processing of globals and early debug info generation.  */\n+  go_write_globals ();\n }\n \n static tree\n@@ -452,14 +455,6 @@ go_langhook_getdecls (void)\n   return NULL;\n }\n \n-/* Write out globals.  */\n-\n-static void\n-go_langhook_write_globals (void)\n-{\n-  go_write_globals ();\n-}\n-\n /* Go specific gimplification.  We need to gimplify\n    CALL_EXPR_STATIC_CHAIN, because the gimplifier doesn't handle\n    it.  */\n@@ -557,7 +552,6 @@ go_localize_identifier (const char *ident)\n #undef LANG_HOOKS_GLOBAL_BINDINGS_P\n #undef LANG_HOOKS_PUSHDECL\n #undef LANG_HOOKS_GETDECLS\n-#undef LANG_HOOKS_WRITE_GLOBALS\n #undef LANG_HOOKS_GIMPLIFY_EXPR\n #undef LANG_HOOKS_EH_PERSONALITY\n \n@@ -574,7 +568,6 @@ go_localize_identifier (const char *ident)\n #define LANG_HOOKS_GLOBAL_BINDINGS_P\tgo_langhook_global_bindings_p\n #define LANG_HOOKS_PUSHDECL\t\tgo_langhook_pushdecl\n #define LANG_HOOKS_GETDECLS\t\tgo_langhook_getdecls\n-#define LANG_HOOKS_WRITE_GLOBALS\tgo_langhook_write_globals\n #define LANG_HOOKS_GIMPLIFY_EXPR\tgo_langhook_gimplify_expr\n #define LANG_HOOKS_EH_PERSONALITY\tgo_langhook_eh_personality\n "}, {"sha": "da39d1fb0e96bbe1bbd55bae9775898bd5fd3209", "filename": "gcc/godump.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fgodump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fgodump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgodump.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -511,13 +511,19 @@ go_function_decl (tree decl)\n   go_decl (decl);\n }\n \n+static void\n+go_early_global_decl (tree decl)\n+{\n+  go_decl (decl);\n+  real_debug_hooks->early_global_decl (decl);\n+}\n+\n /* A global variable decl.  */\n \n static void\n-go_global_decl (tree decl)\n+go_late_global_decl (tree decl)\n {\n-  real_debug_hooks->global_decl (decl);\n-  go_decl (decl);\n+  real_debug_hooks->late_global_decl (decl);\n }\n \n /* A type declaration.  */\n@@ -1457,7 +1463,8 @@ dump_go_spec_init (const char *filename, const struct gcc_debug_hooks *hooks)\n   go_debug_hooks.define = go_define;\n   go_debug_hooks.undef = go_undef;\n   go_debug_hooks.function_decl = go_function_decl;\n-  go_debug_hooks.global_decl = go_global_decl;\n+  go_debug_hooks.early_global_decl = go_early_global_decl;\n+  go_debug_hooks.late_global_decl = go_late_global_decl;\n   go_debug_hooks.type_decl = go_type_decl;\n \n   macro_hash = htab_create (100, macro_hash_hashval, macro_hash_eq,"}, {"sha": "ebd3f178f4a7485610b203a65efc217868f25330", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -1,3 +1,15 @@\n+2015-06-05  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* class.c: Remove pending_static_fields.\n+\t(add_field): Remove use of pending_static_fields.\n+\t(java_write_globals): Remove.\n+\t* decl.c (java_mark_class_local): Remove use of\n+\tpending_static_fields.\n+\t* java-tree.h: Remove pending_static_fields and\n+\tjava_write_globals.\n+\t* jcf-parse.c (java_parse_file): Call global_decl_processing.\n+\t* lang.c (LANG_HOOKS_WRITE_GLOBALS): Remove.\n+\n 2015-06-04  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* boehm.c: Adjust includes for restructured coretypes.h."}, {"sha": "1d66c7250cd14e7cf71d9ba085c96cce0aa4d6a3", "filename": "gcc/java/class.c", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -120,10 +120,6 @@ static GTY(()) vec<tree, va_gc> *registered_class;\n    currently being compiled.  */\n static GTY(()) tree this_classdollar;\n \n-/* A list of static class fields.  This is to emit proper debug\n-   info for them.  */\n-vec<tree, va_gc> *pending_static_fields;\n-\n /* Return the node that most closely represents the class whose name\n    is IDENT.  Start the search from NODE (followed by its siblings).\n    Return NULL if an appropriate node does not exist.  */\n@@ -892,8 +888,6 @@ add_field (tree klass, tree name, tree field_type, int flags)\n       /* Considered external unless we are compiling it into this\n \t object file.  */\n       DECL_EXTERNAL (field) = (is_compiled_class (klass) != 2);\n-      if (!DECL_EXTERNAL (field))\n-\tvec_safe_push (pending_static_fields, field);\n     }\n \n   return field;\n@@ -3270,17 +3264,4 @@ in_same_package (tree name1, tree name2)\n   return (pkg1 == pkg2);\n }\n \n-/* lang_hooks.decls.final_write_globals: perform final processing on\n-   global variables.  */\n-\n-void\n-java_write_globals (void)\n-{\n-  tree *vec = vec_safe_address (pending_static_fields);\n-  int len = vec_safe_length (pending_static_fields);\n-  write_global_declarations ();\n-  emit_debug_global_declarations (vec, len);\n-  vec_free (pending_static_fields);\n-}\n-\n #include \"gt-java-class.h\""}, {"sha": "de75eb6d94e536f15a82bca370a6554478652d6e", "filename": "gcc/java/decl.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -1967,11 +1967,7 @@ java_mark_class_local (tree klass)\n \n   for (t = TYPE_FIELDS (klass); t ; t = DECL_CHAIN (t))\n     if (FIELD_STATIC (t))\n-      {\n-\tif (DECL_EXTERNAL (t))\n-\t  vec_safe_push (pending_static_fields, t);\n-\tjava_mark_decl_local (t);\n-      }\n+      java_mark_decl_local (t);\n \n   for (t = TYPE_METHODS (klass); t ; t = DECL_CHAIN (t))\n     if (!METHOD_ABSTRACT (t))"}, {"sha": "58a60b8c3a5d1a718c2df89c99f39ec54b992438", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -1194,10 +1194,6 @@ extern void rewrite_reflection_indexes (void *);\n \n int cxx_keyword_p (const char *name, int length);\n \n-extern GTY(()) vec<tree, va_gc> *pending_static_fields;\n-\n-extern void java_write_globals (void);   \n-\n #define DECL_FINAL(DECL) DECL_LANG_FLAG_3 (DECL)\n \n /* Access flags etc for a method (a FUNCTION_DECL): */"}, {"sha": "ba216a1672b70fd47c5c4880277b12791eb41868", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -1996,6 +1996,9 @@ java_parse_file (void)\n   /* Arrange for any necessary initialization to happen.  */\n   java_emit_static_constructor ();\n   gcc_assert (global_bindings_p ());\n+\n+  /* Do final processing on globals.  */\n+  global_decl_processing ();\n }\n \n "}, {"sha": "84b1680d5a82e27099175e774f8e9f60e58462b5", "filename": "gcc/java/lang.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -146,8 +146,6 @@ struct GTY(()) language_function {\n #define LANG_HOOKS_DECL_PRINTABLE_NAME lang_printable_name\n #undef LANG_HOOKS_PRINT_ERROR_FUNCTION\n #define LANG_HOOKS_PRINT_ERROR_FUNCTION\tjava_print_error_function\n-#undef LANG_HOOKS_WRITE_GLOBALS\n-#define LANG_HOOKS_WRITE_GLOBALS java_write_globals\n \n #undef LANG_HOOKS_TYPE_FOR_MODE\n #define LANG_HOOKS_TYPE_FOR_MODE java_type_for_mode"}, {"sha": "18ac84d9df3ed513ca3332ce504c679fdc32ca7c", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -205,7 +205,7 @@ extern tree lhd_make_node (enum tree_code);\n #define LANG_HOOKS_FUNCTION_DECL_EXPLICIT_P hook_bool_tree_false\n #define LANG_HOOKS_FUNCTION_DECL_DELETED_P hook_bool_tree_false\n #define LANG_HOOKS_WARN_UNUSED_GLOBAL_DECL lhd_warn_unused_global_decl\n-#define LANG_HOOKS_WRITE_GLOBALS write_global_declarations\n+#define LANG_HOOKS_POST_COMPILATION_PARSING_CLEANUPS NULL\n #define LANG_HOOKS_DECL_OK_FOR_SIBCALL\tlhd_decl_ok_for_sibcall\n #define LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE hook_bool_const_tree_false\n #define LANG_HOOKS_OMP_PREDETERMINED_SHARING lhd_omp_predetermined_sharing\n@@ -230,7 +230,7 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_FUNCTION_PARM_EXPANDED_FROM_PACK_P, \\\n   LANG_HOOKS_GET_GENERIC_FUNCTION_DECL, \\\n   LANG_HOOKS_WARN_UNUSED_GLOBAL_DECL, \\\n-  LANG_HOOKS_WRITE_GLOBALS, \\\n+  LANG_HOOKS_POST_COMPILATION_PARSING_CLEANUPS, \\\n   LANG_HOOKS_DECL_OK_FOR_SIBCALL, \\\n   LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE, \\\n   LANG_HOOKS_OMP_PREDETERMINED_SHARING, \\"}, {"sha": "a1fe9955370ede0f80d7a63d89c87f32dc22ceb2", "filename": "gcc/langhooks.c", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -136,12 +136,12 @@ lhd_print_tree_nothing (FILE * ARG_UNUSED (file),\n {\n }\n \n-/* Called from check_global_declarations.  */\n+/* Called from check_global_declaration.  */\n \n bool\n lhd_warn_unused_global_decl (const_tree decl)\n {\n-  /* This is what used to exist in check_global_declarations.  Probably\n+  /* This is what used to exist in check_global_declaration.  Probably\n      not many of these actually apply to non-C languages.  */\n \n   if (TREE_CODE (decl) == FUNCTION_DECL && DECL_DECLARED_INLINE_P (decl))\n@@ -308,14 +308,17 @@ lhd_decl_ok_for_sibcall (const_tree decl ATTRIBUTE_UNUSED)\n   return true;\n }\n \n-/* lang_hooks.decls.final_write_globals: perform final processing on\n-   global variables.  */\n+/* Generic global declaration processing.  This is meant to be called\n+   by the front-ends at the end of parsing.  C/C++ do their own thing,\n+   but other front-ends may call this.  */\n+\n void\n-write_global_declarations (void)\n+global_decl_processing (void)\n {\n   tree globals, decl, *vec;\n   int len, i;\n \n+  timevar_stop (TV_PHASE_PARSING);\n   timevar_start (TV_PHASE_DEFERRED);\n   /* Really define vars that have had only a tentative definition.\n      Really output inline functions that must actually be callable\n@@ -332,20 +335,9 @@ write_global_declarations (void)\n     vec[len - i - 1] = decl;\n \n   wrapup_global_declarations (vec, len);\n-  check_global_declarations (vec, len);\n   timevar_stop (TV_PHASE_DEFERRED);\n \n-  timevar_start (TV_PHASE_OPT_GEN);\n-  /* This lang hook is dual-purposed, and also finalizes the\n-     compilation unit.  */\n-  symtab->finalize_compilation_unit ();\n-  timevar_stop (TV_PHASE_OPT_GEN);\n-\n-  timevar_start (TV_PHASE_DBGINFO);\n-  emit_debug_global_declarations (vec, len);\n-  timevar_stop (TV_PHASE_DBGINFO);\n-\n-  /* Clean up.  */\n+  timevar_start (TV_PHASE_PARSING);\n   free (vec);\n }\n "}, {"sha": "d8d01fa3b87b59f85927a3bf246e948b0d8c8f3b", "filename": "gcc/langhooks.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -184,9 +184,11 @@ struct lang_hooks_for_decls\n      We will already have checked that it has static binding.  */\n   bool (*warn_unused_global) (const_tree);\n \n-  /* Obtain a list of globals and do final output on them at end\n-     of compilation */\n-  void (*final_write_globals) (void);\n+  /* Perform any post compilation-proper parser cleanups and\n+     processing.  This is currently only needed for the C++ parser,\n+     which hopefully can be cleaned up so this hook is no longer\n+     necessary.  */\n+  void (*post_compilation_parsing_cleanups) (void);\n \n   /* True if this decl may be called via a sibcall.  */\n   bool (*ok_for_sibcall) (const_tree);"}, {"sha": "5ba6a4f9de9c7a4e5d6cecd392e125917cb9694c", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -1,3 +1,8 @@\n+2015-06-05  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* lto-lang.c (lto_write_globals): Remove.\n+\t(LANG_HOOKS_WRITE_GLOBALS): Same.\n+\n 2015-06-04  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* lto-lang.c: Adjust includes for restructured coretypes.h."}, {"sha": "e1d6b7f2bf966ca0ce82d0c1756db344c04cb229", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -1113,19 +1113,6 @@ lto_getdecls (void)\n   return NULL_TREE;\n }\n \n-static void\n-lto_write_globals (void)\n-{\n-  if (flag_wpa)\n-    return;\n-\n-  /* Output debug info for global variables.  */  \n-  varpool_node *vnode;\n-  FOR_EACH_DEFINED_VARIABLE (vnode)\n-    if (!decl_function_context (vnode->decl))\n-      debug_hooks->global_decl (vnode->decl);\n-}\n-\n static tree\n lto_builtin_function (tree decl)\n {\n@@ -1331,8 +1318,6 @@ static void lto_init_ts (void)\n #define LANG_HOOKS_PUSHDECL lto_pushdecl\n #undef LANG_HOOKS_GETDECLS\n #define LANG_HOOKS_GETDECLS lto_getdecls\n-#undef LANG_HOOKS_WRITE_GLOBALS\n-#define LANG_HOOKS_WRITE_GLOBALS lto_write_globals\n #undef LANG_HOOKS_REGISTER_BUILTIN_TYPE\n #define LANG_HOOKS_REGISTER_BUILTIN_TYPE lto_register_builtin_type\n #undef LANG_HOOKS_BUILTIN_FUNCTION"}, {"sha": "03327a52703767f569c0b859a76cfb1078e06e43", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -1,3 +1,9 @@\n+2015-06-05  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* objc-act.c (objc_write_global_declarations): Adjust comment.\n+\t* objc-gnu-runtime-abi-01.c (build_selector_table_decl): Set\n+\tTREE_USED bit.\n+\n 2015-06-04  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* objc-act.c: Adjust includes for restructured coretypes.h."}, {"sha": "f42f67993c81fc1733af81632d5090ba28edcb91", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -435,8 +435,7 @@ objc_init (void)\n   return true;\n }\n \n-/* This is called automatically (at the very end of compilation) by\n-   c_write_global_declarations and cp_write_global_declarations.  */\n+/* This is called at the end of parsing by the C/C++ parsers.  */\n void\n objc_write_global_declarations (void)\n {"}, {"sha": "6986645d60dc003201abe83d244a29498e5be7e9", "filename": "gcc/objc/objc-gnu-runtime-abi-01.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -497,6 +497,8 @@ build_selector_table_decl (void)\n   temp = build_array_type (objc_selector_template, NULL_TREE);\n \n   UOBJC_SELECTOR_TABLE_decl = start_var_decl (temp, \"_OBJC_SELECTOR_TABLE\");\n+  /* Squash `defined but not used' warning check_global_declaration.  */\n+  TREE_USED (UOBJC_SELECTOR_TABLE_decl) = 1;\n   OBJCMETA (UOBJC_SELECTOR_TABLE_decl, objc_meta, meta_base);\n }\n "}, {"sha": "720e6471e7408175f7308f374b9b4db4f350a395", "filename": "gcc/passes.c", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -288,6 +288,56 @@ rest_of_decl_compilation (tree decl,\n   else if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl)\n \t   && TREE_STATIC (decl))\n     varpool_node::get_create (decl);\n+\n+  /* Generate early debug for global variables.  Any local variables will\n+     be handled by either handling reachable functions from\n+     finalize_compilation_unit (and by consequence, locally scoped\n+     symbols), or by rest_of_type_compilation below.\n+\n+     Also, pick up function prototypes, which will be mostly ignored\n+     by the different early_global_decl() hooks, but will at least be\n+     used by Go's hijack of the debug_hooks to implement\n+     -fdump-go-spec.  */\n+  if (!in_lto_p\n+      && (TREE_CODE (decl) != FUNCTION_DECL\n+\t  /* This will pick up function prototypes with no bodies,\n+\t     which are not visible in finalize_compilation_unit()\n+\t     while iterating with FOR_EACH_*_FUNCTION through the\n+\t     symbol table.  */\n+\t  || !DECL_SAVED_TREE (decl))\n+\n+      /* We need to check both decl_function_context and\n+\t current_function_decl here to make sure local extern\n+\t declarations end up with the correct context.\n+\n+\t For local extern declarations, decl_function_context is\n+\t empty, but current_function_decl is set to the function where\n+\t the extern was declared .  Without the check for\n+\t !current_function_decl below, the local extern ends up\n+\t incorrectly with a top-level context.\n+\n+\t For example:\n+\n+\t namespace S\n+\t {\n+\t   int\n+\t   f()\n+\t   {\n+\t     {\n+\t       int i = 42;\n+\t       {\n+\t         extern int i; // Local extern declaration.\n+\t\t return i;\n+\t       }\n+\t     }\n+\t   }\n+\t }\n+      */\n+      && !decl_function_context (decl)\n+      && !current_function_decl\n+\n+      && !decl_type_context (decl))\n+    (*debug_hooks->early_global_decl) (decl);\n }\n \n /* Called after finishing a record, union or enumeral type.  */"}, {"sha": "15d0805e230e5490d6c4eeb8390c448ba397236e", "filename": "gcc/sdbout.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -125,7 +125,8 @@ static void sdbout_begin_block\t\t(unsigned int, unsigned int);\n static void sdbout_end_block\t\t(unsigned int, unsigned int);\n static void sdbout_source_line\t\t(unsigned int, const char *, int, bool);\n static void sdbout_end_epilogue\t\t(unsigned int, const char *);\n-static void sdbout_global_decl\t\t(tree);\n+static void sdbout_early_global_decl\t(tree);\n+static void sdbout_late_global_decl\t(tree);\n static void sdbout_begin_prologue\t(unsigned int, const char *);\n static void sdbout_end_prologue\t\t(unsigned int, const char *);\n static void sdbout_begin_function\t(tree);\n@@ -148,7 +149,6 @@ static void sdbout_field_types\t\t(tree);\n static void sdbout_one_type\t\t(tree);\n static void sdbout_parms\t\t(tree);\n static void sdbout_reg_parms\t\t(tree);\n-static void sdbout_global_decl\t\t(tree);\n \n /* Random macros describing parts of SDB data.  */\n \n@@ -285,6 +285,7 @@ const struct gcc_debug_hooks sdb_debug_hooks =\n {\n   sdbout_init,\t\t\t         /* init */\n   sdbout_finish,\t\t         /* finish */\n+  debug_nothing_void,\t\t\t /* early_finish */\n   debug_nothing_void,\t\t\t /* assembly_start */\n   debug_nothing_int_charstar,\t         /* define */\n   debug_nothing_int_charstar,\t         /* undef */\n@@ -301,7 +302,8 @@ const struct gcc_debug_hooks sdb_debug_hooks =\n   sdbout_begin_function,\t         /* begin_function */\n   sdbout_end_function,\t\t         /* end_function */\n   debug_nothing_tree,\t\t         /* function_decl */\n-  sdbout_global_decl,\t\t         /* global_decl */\n+  sdbout_early_global_decl,\t\t /* early_global_decl */\n+  sdbout_late_global_decl,\t\t /* late_global_decl */\n   sdbout_symbol,\t\t\t /* type_decl */\n   debug_nothing_tree_tree_tree_bool,\t /* imported_module_or_decl */\n   debug_nothing_tree,\t\t         /* deferred_inline_function */\n@@ -1427,11 +1429,20 @@ sdbout_reg_parms (tree parms)\n       }\n }\n \n-/* Output debug information for a global DECL.  Called from toplev.c\n-   after compilation proper has finished.  */\n+/* Output early debug information for a global DECL.  Called from\n+   rest_of_decl_compilation during parsing.  */\n \n static void\n-sdbout_global_decl (tree decl)\n+sdbout_early_global_decl (tree decl ATTRIBUTE_UNUSED)\n+{\n+  /* NYI for non-dwarf.  */\n+}\n+\n+/* Output late debug information for a global DECL after location\n+   information is available.  */\n+\n+static void\n+sdbout_late_global_decl (tree decl)\n {\n   if (TREE_CODE (decl) == VAR_DECL\n       && !DECL_EXTERNAL (decl)"}, {"sha": "334d4091be8d7fc2bfb8116e8d5787222e05f32d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -1,3 +1,20 @@\n+2015-06-05  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* g++.dg/cpp0x/pr57101.C: Add warning.\n+\t* g++.dg/debug/dwarf2/dwarf4-typedef.C: Same.\n+\t* g++.dg/ext/visibility/anon7.C: Same.\n+\t* g++.dg/ipa/pr63587-2.C: Same.\n+\t* g++.dg/opt/dump1.C: Same.\n+\t* g++.dg/opt/pr59622-3.C: Same.\n+\t* g++.dg/opt/pr59622.C: Same.\n+\t* g++.dg/torture/pr46383.C: Same.\n+\t* gcc.dg/dfp/pragma-float-const-decimal64-8.c: Same.\n+\t* g++.dg/debug/dwarf2/auto1.C: Adjust for early dwarf.\n+\t* g++.dg/lto/pr65549_0.C: Add { } to used but never defined\n+\tfunctions.\n+\t* gfortran.dg/intent_out_8.f90: Same.\n+\t* gfortran.dg/warn_target_lifetime_3.f90: Same.\n+\n 2015-06-05  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/66377"}, {"sha": "1db444e22ef43a4f442ece52722d250e4e07aa6c", "filename": "gcc/testsuite/g++.dg/cpp0x/pr57101.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr57101.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr57101.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr57101.C?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -160,7 +160,7 @@ namespace std\n     typedef _Alloc allocator_type;\n     template < typename _Key_compare > struct _Rb_tree_impl\n     {\n-      _Rb_tree_impl (_Key_compare, _Node_allocator);\n+      _Rb_tree_impl (_Key_compare, _Node_allocator); // { dg-warning \"used but never defined\" }\n     };\n     _Rb_tree_impl < _Compare > _M_impl;\n   _Rb_tree (_Compare __comp, allocator_type __a):"}, {"sha": "c04e923d8b6eb5db34970f695bbb2c39f9a45053", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/auto1.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fauto1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fauto1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fauto1.C?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -10,14 +10,14 @@\n // .uleb128 0x5    # (DIE (0x4c) DW_TAG_unspecified_type)\n // .long   .LASF6  # DW_AT_name: \"auto\"\n //...\n+// .uleb128 0x9    # (DIE (0x87) DW_TAG_base_type)\n+// .ascii \"int\\0\"  # DW_AT_name\n+//...\n // .uleb128 0x7    # (DIE (0x57) DW_TAG_subprogram)\n // .long   0x33    # DW_AT_specification\n // .long   0x87    # DW_AT_type\n-//...\n-// .uleb128 0x9    # (DIE (0x87) DW_TAG_base_type)\n-// .ascii \"int\\0\"  # DW_AT_name\n \n-// { dg-final { scan-assembler \"a1.*(0x\\[0-9a-f]+)\\[^\\n\\r]*DW_AT_type.*\\\\1. DW_TAG_unspecified_type.*DW_AT_specification\\[\\n\\r]{1,2}\\[^\\n\\r]*(0x\\[0-9a-f]+)\\[^\\n\\r]*DW_AT_type.*\\\\2. DW_TAG_base_type\" } }\n+// { dg-final { scan-assembler \"a1.*(0x\\[0-9a-f]+)\\[^\\n\\r]*DW_AT_type.*\\\\1. DW_TAG_unspecified_type.*(0x\\[0-9a-f]+). DW_TAG_base_type.*DW_AT_specification\\[\\n\\r]{1,2}\\[^\\n\\r]*\\\\2\\[^\\n\\r]*DW_AT_type\" } }\n \n struct A\n {"}, {"sha": "cd1a0afe8680999dc60fa7586f0d107f1782a086", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/dwarf4-typedef.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fdwarf4-typedef.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fdwarf4-typedef.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fdwarf4-typedef.C?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -6,7 +6,7 @@\n namespace {\n \n struct A {\n-  virtual ~A();\n+  virtual ~A(); // { dg-warning \"used but never defined\" }\n };\n \n struct B : public A {"}, {"sha": "1aa239e922a044a5bb1e674b847a5fd6f1eca318", "filename": "gcc/testsuite/g++.dg/ext/visibility/anon7.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fanon7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fanon7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fanon7.C?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -4,7 +4,7 @@\n namespace\n {\n   struct A {\n-    static int bar ();\n+    static int bar ();\t\t// { dg-error \"used but never defined\" \"\" }\n     static int i;\t\t// { dg-error \"used, but not defined\" \"\" { xfail *-*-* } }\n     static int j;\n     static int k;"}, {"sha": "a15f17e7ca335a4433b1ae892d5a92c31b1df1de", "filename": "gcc/testsuite/g++.dg/ipa/pr63587-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr63587-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr63587-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr63587-2.C?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -178,7 +178,7 @@ public:\n   }\n };\n template <typename AttributeValueT>\n-attribute_actor<AttributeValueT> attr (attribute_name);\n+attribute_actor<AttributeValueT> attr (attribute_name); // { dg-warning \"used but never defined\" }\n terminal<>::type stream;\n template <typename LeftT, typename ImplT> class attribute_output_terminal\n {"}, {"sha": "889cc994a58fdd30d9af6b8811bd062106a6ded2", "filename": "gcc/testsuite/g++.dg/lto/pr65549_0.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65549_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65549_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65549_0.C?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -25,7 +25,7 @@ struct C<_Functor(_ArgTypes...)>\n                            typename remove_reference<_Functor>::type>::value,\n                        _Functor> {};\n template <typename _Tp> using result_of_t = typename C<_Tp>::type;\n-template <typename> void forward();\n+template <typename> void forward() { }\n template <typename _Tp> _Tp move(_Tp) {}\n namespace __cxx11 {\n class basic_string typedef string;\n@@ -119,7 +119,7 @@ class H {\n   template <typename Func> void schedule(Func func) {\n     G __trans_tmp_1;\n     struct task_with_ready_state {\n-      task_with_ready_state(Func, G);\n+      task_with_ready_state(Func, G) { };\n     };\n     std::make_unique<task_with_ready_state>(std::move(func), __trans_tmp_1);\n     _promise->schedule(std::move(func));"}, {"sha": "f74d0247832d871c9b3ac8f458eb04af3dc69f36", "filename": "gcc/testsuite/g++.dg/opt/dump1.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdump1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdump1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdump1.C?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -311,7 +311,7 @@ namespace std __attribute__ ((__visibility__ (\"default\")))\n     typename __add_ref<\n                       typename tuple_element<__i, tuple<_Elements...>>::type\n                     >::type\n-    get(tuple<_Elements...>& __t) noexcept;\n+    get(tuple<_Elements...>& __t) noexcept; // { dg-warning \"used but never defined\" }\n   template<std::size_t... _Indexes>\n     struct _Index_tuple\n     {};\n@@ -386,7 +386,7 @@ namespace std __attribute__ ((__visibility__ (\"default\")))\n     };\n   template<typename _Callable, typename... _Args>\n     typename _Bind_simple_helper<_Callable, _Args...>::__type\n-    __bind_simple(_Callable&& __callable, _Args&&... __args)\n+    __bind_simple(_Callable&& __callable, _Args&&... __args)  // { dg-warning \"used but never defined\" }\n   ;\n   union _Any_data\n   ;\n@@ -403,7 +403,7 @@ namespace std __attribute__ ((__visibility__ (\"default\")))\n       {\n       protected:\n  static _Functor*\n- _M_get_pointer(const _Any_data& __source)\n+ _M_get_pointer(const _Any_data& __source)  // { dg-warning \"used but never defined\" }\n  ;\n       };\n   };\n@@ -510,7 +510,7 @@ namespace std __attribute__ ((__visibility__ (\"default\")))\n         _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)\n  { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }\n       static pointer\n-      allocate(_Alloc& __a, size_type __n)\n+      allocate(_Alloc& __a, size_type __n)  // { dg-warning \"used but never defined\" }\n       ;\n       template<typename _Tp, typename... _Args>\n  static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)"}, {"sha": "94d66aafe6b3140ccc4fb4ddf3922cabc1ad5f57", "filename": "gcc/testsuite/g++.dg/opt/pr59622-3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr59622-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr59622-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr59622-3.C?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -8,7 +8,7 @@ namespace\n {\n   struct A\n   {\n-    virtual C foo ();\n+    virtual C foo (); // { dg-warning \"used but never defined\" }\n     C bar () { return foo (); }\n   };\n }"}, {"sha": "f62cf41242d72445317fbd8f76d2914f670a768a", "filename": "gcc/testsuite/g++.dg/opt/pr59622.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr59622.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr59622.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr59622.C?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -6,7 +6,7 @@ namespace\n {\n   struct A\n   {\n-    virtual int foo ();\n+    virtual int foo (); // { dg-warning \"used but never defined\" }\n     int bar () { return foo (); }\n   };\n }"}, {"sha": "e4810c5ada87040949cc7e49de46f4b3a7a57049", "filename": "gcc/testsuite/g++.dg/torture/pr46383.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr46383.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr46383.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr46383.C?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -69,9 +69,9 @@ template < class Tr, class Derived, class Element, class Previous, class Triangu\n   Mesher_level(Previous_level& previous)\n     : previous_level(previous)\n   { }\n-  Vertex_handle insert(Point p, Zone& z) ;\n-  Zone conflicts_zone(const Point& p, Element e) ;\n-  Element get_next_element() ;\n+  Vertex_handle insert(Point p, Zone& z) ; // { dg-warning \"used but never defined\" }\n+  Zone conflicts_zone(const Point& p, Element e) ; // { dg-warning \"used but never defined\" }\n+  Element get_next_element() ; // { dg-warning \"used but never defined\" }\n   template <class Mesh_visitor> void before_insertion(Element& e, const Point& p, Zone& zone, Mesh_visitor visitor) {\n     visitor.before_insertion(e, p, zone);\n   }\n@@ -171,7 +171,7 @@ template <typename Tr> struct Triangulation_mesher_level_traits_3\n       tr.is_infinite(f) ;\n       new_facet<false>(f);\n     }\n-    template <bool remove_from_complex_if_not_in_restricted_Delaunay> void new_facet (const Facet& f) ;\n+    template <bool remove_from_complex_if_not_in_restricted_Delaunay> void new_facet (const Facet& f) ; // { dg-warning \"used but never defined\" }\n     void after_insertion_handle_opposite_facet (const Facet& f) {\n       after_insertion_handle_incident_facet (f);\n     }"}, {"sha": "a54c9008b9f2de2f7287c83a0a9a57180700c0d9", "filename": "gcc/testsuite/gcc.dg/dfp/pragma-float-const-decimal64-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fpragma-float-const-decimal64-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fpragma-float-const-decimal64-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fpragma-float-const-decimal64-8.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -145,7 +145,7 @@ f9 (void)\n double\n f10 (void)\n {\n-  void foo10 (void)\n+  void foo10 (void) /* { dg-warning \"defined but not used\" } */\n   {\n     a = 1.0;\n   }"}, {"sha": "6360314dd2cce7db045636336ed3ca8a95114baa", "filename": "gcc/testsuite/gfortran.dg/intent_out_8.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_8.f90?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -10,7 +10,7 @@\n \n contains\n \n-  subroutine foo(x)\n+  subroutine foo(x)             ! { dg-warning \"defined but not used\" }\n     type(t), intent(out) :: x\n   end subroutine\n "}, {"sha": "6c8ea5b945834126a88b46704b2f3729ad6c1869", "filename": "gcc/testsuite/gfortran.dg/warn_target_lifetime_3.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarn_target_lifetime_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarn_target_lifetime_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarn_target_lifetime_3.f90?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -10,7 +10,7 @@ subroutine test\n   integer, target :: t\n   p => t\n contains\n-  subroutine sub()\n+  subroutine sub()               ! { dg-warning \"defined but not used\" }\n     if (p /= 0) return\n   end subroutine\n end subroutine\n@@ -22,7 +22,7 @@ subroutine test\n     integer, target :: t2\n     p2 => t2 ! { dg-warning \"Pointer at .1. in pointer assignment might outlive the pointer target\" }\n   contains\n-    subroutine sub()\n+    subroutine sub()             ! { dg-warning \"defined but not used\" }\n       if (p2 /= 0) return\n     end subroutine\n   end subroutine"}, {"sha": "efac4b791ad19b0e558705f254b658fcb8671f96", "filename": "gcc/timevar.def", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -31,11 +31,17 @@\n \n /* The total execution time.  */\n DEFTIMEVAR (TV_TOTAL                 , \"total time\")\n-/* The compiler phases.  These must be mutually exclusive.\n-   Ideally, they would sum to near the total time.  */\n+/* The compiler phases.\n+\n+   These must be mutually exclusive, and the NAME field must begin\n+   with \"phase\".\n+\n+   Also, their sum must be within a millionth of the total time (see\n+   validate_phases).  */\n DEFTIMEVAR (TV_PHASE_SETUP           , \"phase setup\")\n DEFTIMEVAR (TV_PHASE_PARSING         , \"phase parsing\")\n DEFTIMEVAR (TV_PHASE_DEFERRED        , \"phase lang. deferred\")\n+DEFTIMEVAR (TV_PHASE_LATE_PARSING_CLEANUPS, \"phase late parsing cleanups\")\n DEFTIMEVAR (TV_PHASE_OPT_GEN         , \"phase opt and generate\")\n DEFTIMEVAR (TV_PHASE_DBGINFO         , \"phase debug info\")\n DEFTIMEVAR (TV_PHASE_CHECK_DBGINFO   , \"phase check & debug info\")"}, {"sha": "fd2ac4e7f2ef12814d7f007fc0f160fab06a2b48", "filename": "gcc/toplev.c", "status": "modified", "additions": 37, "deletions": 41, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -492,25 +492,25 @@ wrapup_global_declarations (tree *vec, int len)\n   return output_something;\n }\n \n-/* A subroutine of check_global_declarations.  Issue appropriate warnings\n-   for the global declaration DECL.  */\n+/* Issue appropriate warnings for the global declaration DECL.  */\n \n void\n-check_global_declaration_1 (tree decl)\n+check_global_declaration (tree decl)\n {\n   /* Warn about any function declared static but not defined.  We don't\n      warn about variables, because many programs have static variables\n      that exist only to get some text into the object file.  */\n+  symtab_node *snode = symtab_node::get (decl);\n   if (TREE_CODE (decl) == FUNCTION_DECL\n       && DECL_INITIAL (decl) == 0\n       && DECL_EXTERNAL (decl)\n       && ! DECL_ARTIFICIAL (decl)\n       && ! TREE_NO_WARNING (decl)\n       && ! TREE_PUBLIC (decl)\n       && (warn_unused_function\n-\t  || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n+\t  || snode->referred_to_p (/*include_self=*/false)))\n     {\n-      if (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n+      if (snode->referred_to_p (/*include_self=*/false))\n \tpedwarn (input_location, 0, \"%q+F used but never defined\", decl);\n       else\n \twarning (OPT_Wunused_function, \"%q+F declared %<static%> but never defined\", decl);\n@@ -525,6 +525,10 @@ check_global_declaration_1 (tree decl)\n        || (warn_unused_variable\n \t   && TREE_CODE (decl) == VAR_DECL && ! TREE_READONLY (decl)))\n       && ! DECL_IN_SYSTEM_HEADER (decl)\n+      && ! snode->referred_to_p (/*include_self=*/false)\n+      /* This TREE_USED check is needed in addition to referred_to_p\n+\t above, because the `__unused__' attribute is not being\n+\t considered for referred_to_p.  */\n       && ! TREE_USED (decl)\n       /* The TREE_USED bit for file-scope decls is kept in the identifier,\n \t to handle multiple external decls in different scopes.  */\n@@ -535,6 +539,10 @@ check_global_declaration_1 (tree decl)\n       && ! TREE_THIS_VOLATILE (decl)\n       /* Global register variables must be declared to reserve them.  */\n       && ! (TREE_CODE (decl) == VAR_DECL && DECL_REGISTER (decl))\n+      /* Global ctors and dtors are called by the runtime.  */\n+      && (TREE_CODE (decl) != FUNCTION_DECL\n+\t  || (!DECL_STATIC_CONSTRUCTOR (decl)\n+\t      && !DECL_STATIC_DESTRUCTOR (decl)))\n       /* Otherwise, ask the language.  */\n       && lang_hooks.decls.warn_unused_global (decl))\n     warning ((TREE_CODE (decl) == FUNCTION_DECL)\n@@ -543,38 +551,6 @@ check_global_declaration_1 (tree decl)\n \t     \"%q+D defined but not used\", decl);\n }\n \n-/* Issue appropriate warnings for the global declarations in V (of\n-   which there are LEN).  */\n-\n-void\n-check_global_declarations (tree *v, int len)\n-{\n-  int i;\n-\n-  for (i = 0; i < len; i++)\n-    check_global_declaration_1 (v[i]);\n-}\n-\n-/* Emit debugging information for all global declarations in VEC.  */\n-\n-void\n-emit_debug_global_declarations (tree *vec, int len)\n-{\n-  int i;\n-\n-  /* Avoid confusing the debug information machinery when there are errors.  */\n-  if (seen_error ())\n-    return;\n-  /* No need for debug info in object files when producing slimLTO.  */\n-  if (!in_lto_p && flag_lto && !flag_fat_lto_objects)\n-    return;\n-\n-  timevar_push (TV_SYMOUT);\n-  for (i = 0; i < len; i++)\n-    debug_hooks->global_decl (vec[i]);\n-  timevar_pop (TV_SYMOUT);\n-}\n-\n /* Compile an entire translation unit.  Write a file of assembly\n    output and various debugging dumps.  */\n \n@@ -584,8 +560,7 @@ compile_file (void)\n   timevar_start (TV_PHASE_PARSING);\n   timevar_push (TV_PARSE_GLOBAL);\n \n-  /* Call the parser, which parses the entire file (calling\n-     rest_of_compilation for each function).  */\n+  /* Parse entire file and generate initial debug information.  */\n   lang_hooks.parse_file ();\n \n   timevar_pop (TV_PARSE_GLOBAL);\n@@ -602,12 +577,33 @@ compile_file (void)\n \n   ggc_protect_identifiers = false;\n \n-  /* This must also call finalize_compilation_unit.  */\n-  lang_hooks.decls.final_write_globals ();\n+  /* Run the actual compilation process.  */\n+  if (!in_lto_p)\n+    {\n+      timevar_start (TV_PHASE_OPT_GEN);\n+      symtab->finalize_compilation_unit ();\n+      timevar_stop (TV_PHASE_OPT_GEN);\n+    }\n+\n+  /* Perform any post compilation-proper parser cleanups and\n+     processing.  This is currently only needed for the C++ parser,\n+     which can be hopefully cleaned up so this hook is no longer\n+     necessary.  */\n+  if (lang_hooks.decls.post_compilation_parsing_cleanups)\n+    lang_hooks.decls.post_compilation_parsing_cleanups ();\n \n   if (seen_error ())\n     return;\n \n+  /* After the parser has generated debugging information, augment\n+     this information with any new location/etc information that may\n+     have become available after the compilation proper.  */\n+  timevar_start (TV_PHASE_DBGINFO);\n+  symtab_node *node;\n+  FOR_EACH_DEFINED_SYMBOL (node)\n+    debug_hooks->late_global_decl (node->decl);\n+  timevar_stop (TV_PHASE_DBGINFO);\n+\n   timevar_start (TV_PHASE_LATE_ASM);\n \n   /* Compilation unit is finalized.  When producing non-fat LTO object, we are"}, {"sha": "3bddcbb147b2b6ae74133c6271ae8fc43ff0d4eb", "filename": "gcc/toplev.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -59,10 +59,9 @@ extern void announce_function (tree);\n extern void wrapup_global_declaration_1 (tree);\n extern bool wrapup_global_declaration_2 (tree);\n extern bool wrapup_global_declarations (tree *, int);\n-extern void check_global_declaration_1 (tree);\n-extern void check_global_declarations (tree *, int);\n-extern void emit_debug_global_declarations (tree *, int);\n-extern void write_global_declarations (void);\n+extern void check_global_declaration (tree);\n+\n+extern void global_decl_processing (void);\n \n extern void dump_memory_report (bool);\n extern void dump_profile_report (void);"}, {"sha": "c92b3ea8bd8cbb70dca5165f3cf0d74964549eab", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -1093,6 +1093,7 @@ build_one_array (gswitch *swtch, int num, tree arr_index_type,\n       DECL_IGNORED_P (decl) = 1;\n       TREE_CONSTANT (decl) = 1;\n       TREE_READONLY (decl) = 1;\n+      DECL_IGNORED_P (decl) = 1;\n       varpool_node::finalize_decl (decl);\n \n       fetch = build4 (ARRAY_REF, value_type, decl, tidx, NULL_TREE,"}, {"sha": "252f40cff8cdbaf086ccf2890b904dbcb2ac658c", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7438551ff5ffa0afeca2aa3efd13035b26bee34/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=d7438551ff5ffa0afeca2aa3efd13035b26bee34", "patch": "@@ -171,7 +171,8 @@ static void vmsdbgout_begin_epilogue (unsigned int, const char *);\n static void vmsdbgout_end_epilogue (unsigned int, const char *);\n static void vmsdbgout_begin_function (tree);\n static void vmsdbgout_decl (tree);\n-static void vmsdbgout_global_decl (tree);\n+static void vmsdbgout_early_global_decl (tree);\n+static void vmsdbgout_late_global_decl (tree);\n static void vmsdbgout_type_decl (tree, int);\n static void vmsdbgout_abstract_function (tree);\n \n@@ -180,6 +181,7 @@ static void vmsdbgout_abstract_function (tree);\n const struct gcc_debug_hooks vmsdbg_debug_hooks\n = {vmsdbgout_init,\n    vmsdbgout_finish,\n+   debug_nothing_void,\n    vmsdbgout_assembly_start,\n    vmsdbgout_define,\n    vmsdbgout_undef,\n@@ -195,8 +197,9 @@ const struct gcc_debug_hooks vmsdbg_debug_hooks\n    vmsdbgout_end_epilogue,\n    vmsdbgout_begin_function,\n    vmsdbgout_end_function,\n-   vmsdbgout_decl,\n-   vmsdbgout_global_decl,\n+   vmsdbgout_function_decl,\n+   vmsdbgout_early_global_decl,\n+   vmsdbgout_late_global_decl,\n    vmsdbgout_type_decl,\t\t  /* type_decl */\n    debug_nothing_tree_tree_tree_bool, /* imported_module_or_decl */\n    debug_nothing_tree,\t\t  /* deferred_inline_function */\n@@ -1509,7 +1512,7 @@ vmsdbgout_undef (unsigned int lineno, const char *buffer)\n /* Not implemented in VMS Debug.  */\n \n static void\n-vmsdbgout_decl (tree decl)\n+vmsdbgout_function_decl (tree decl)\n {\n   if (write_symbols == VMS_AND_DWARF2_DEBUG)\n     (*dwarf2_debug_hooks.function_decl) (decl);\n@@ -1518,10 +1521,19 @@ vmsdbgout_decl (tree decl)\n /* Not implemented in VMS Debug.  */\n \n static void\n-vmsdbgout_global_decl (tree decl)\n+vmsdbgout_early_global_decl (tree decl)\n {\n   if (write_symbols == VMS_AND_DWARF2_DEBUG)\n-    (*dwarf2_debug_hooks.global_decl) (decl);\n+    (*dwarf2_debug_hooks.early_global_decl) (decl);\n+}\n+\n+/* Not implemented in VMS Debug.  */\n+\n+static void\n+vmsdbgout_late_global_decl (tree decl)\n+{\n+  if (write_symbols == VMS_AND_DWARF2_DEBUG)\n+    (*dwarf2_debug_hooks.late_global_decl) (decl);\n }\n \n /* Not implemented in VMS Debug.  */"}]}