{"sha": "59bef1891833dd26e5820047c87f9b1d6b115ee9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTliZWYxODkxODMzZGQyNmU1ODIwMDQ3Yzg3ZjliMWQ2YjExNWVlOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-02-20T21:57:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-02-20T21:57:23Z"}, "message": "i386.c (ix86_expand_vector_move): Use the mode of the operand, rather than assuming TImode.\n\n        * config/i386/i386.c (ix86_expand_vector_move): Use the mode\n        of the operand, rather than assuming TImode.\n        (ix86_expand_binop_builtin): Cope with commutative patterns\n        using nonimmediate_operand for both operands.\n        (ix86_expand_timode_binop_builtin): Likewise.\n        (ix86_expand_store_builtin): Validate operand 1.\n        (ix86_expand_unop1_builtin): Likewise.\n\nFrom-SVN: r49912", "tree": {"sha": "6d2a14cdcfe337cb01f96718208b12d5bcfbf6af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d2a14cdcfe337cb01f96718208b12d5bcfbf6af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59bef1891833dd26e5820047c87f9b1d6b115ee9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59bef1891833dd26e5820047c87f9b1d6b115ee9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59bef1891833dd26e5820047c87f9b1d6b115ee9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59bef1891833dd26e5820047c87f9b1d6b115ee9/comments", "author": null, "committer": null, "parents": [{"sha": "9338ffe610bc23fd9d31bd22a83cb5fdadd05d0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9338ffe610bc23fd9d31bd22a83cb5fdadd05d0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9338ffe610bc23fd9d31bd22a83cb5fdadd05d0a"}], "stats": {"total": 38, "additions": 34, "deletions": 4}, "files": [{"sha": "bbcf0f12e2756083e206d7598cb5860e1406bc23", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59bef1891833dd26e5820047c87f9b1d6b115ee9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59bef1891833dd26e5820047c87f9b1d6b115ee9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=59bef1891833dd26e5820047c87f9b1d6b115ee9", "patch": "@@ -1,3 +1,13 @@\n+2002-02-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.c (ix86_expand_vector_move): Use the mode\n+\tof the operand, rather than assuming TImode.\n+\t(ix86_expand_binop_builtin): Cope with commutative patterns\n+\tusing nonimmediate_operand for both operands.\n+\t(ix86_expand_timode_binop_builtin): Likewise.\n+\t(ix86_expand_store_builtin): Validate operand 1.\n+\t(ix86_expand_unop1_builtin): Likewise.\n+\n 2002-02-20  Philip Blundell  <philb@gnu.org>\n \t\n \tPR 5705"}, {"sha": "fd84c07239eb9f7913ef89c6e989b8f442e00988", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59bef1891833dd26e5820047c87f9b1d6b115ee9/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59bef1891833dd26e5820047c87f9b1d6b115ee9/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=59bef1891833dd26e5820047c87f9b1d6b115ee9", "patch": "@@ -6732,7 +6732,7 @@ ix86_expand_vector_move (mode, operands)\n       && !register_operand (operands[1], mode)\n       && operands[1] != CONST0_RTX (mode))\n     {\n-      rtx temp = force_reg (TImode, operands[1]);\n+      rtx temp = force_reg (GET_MODE (operands[1]), operands[1]);\n       emit_move_insn (operands[0], temp);\n       return;\n     }\n@@ -11363,6 +11363,12 @@ ix86_expand_binop_builtin (icode, arglist, target)\n   if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n     op1 = copy_to_mode_reg (mode1, op1);\n \n+  /* In the commutative cases, both op0 and op1 are nonimmediate_operand,\n+     yet one of the two must not be a memory.  This is normally enforced\n+     by expanders, but we didn't bother to create one here.  */\n+  if (GET_CODE (op0) == MEM && GET_CODE (op1) == MEM)\n+    op0 = copy_to_mode_reg (mode0, op0);\n+\n   pat = GEN_FCN (icode) (target, op0, op1);\n   if (! pat)\n     return 0;\n@@ -11395,6 +11401,12 @@ ix86_expand_timode_binop_builtin (icode, arglist, target)\n   if (! (*insn_data[icode].operand[2].predicate) (op1, TImode))\n     op1 = copy_to_mode_reg (TImode, op1);\n \n+  /* In the commutative cases, both op0 and op1 are nonimmediate_operand,\n+     yet one of the two must not be a memory.  This is normally enforced\n+     by expanders, but we didn't bother to create one here.  */\n+  if (GET_CODE (op0) == MEM && GET_CODE (op1) == MEM)\n+    op0 = copy_to_mode_reg (TImode, op0);\n+\n   pat = GEN_FCN (icode) (target, op0, op1);\n   if (! pat)\n     return 0;\n@@ -11422,6 +11434,10 @@ ix86_expand_store_builtin (icode, arglist)\n     op1 = safe_vector_operand (op1, mode1);\n \n   op0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));\n+\n+  if (! (*insn_data[icode].operand[1].predicate) (op1, mode1))\n+    op1 = copy_to_mode_reg (mode1, op1);\n+\n   pat = GEN_FCN (icode) (op0, op1);\n   if (pat)\n     emit_insn (pat);\n@@ -11476,7 +11492,7 @@ ix86_expand_unop1_builtin (icode, arglist, target)\n {\n   rtx pat;\n   tree arg0 = TREE_VALUE (arglist);\n-  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+  rtx op1, op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n   enum machine_mode tmode = insn_data[icode].operand[0].mode;\n   enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n \n@@ -11490,8 +11506,12 @@ ix86_expand_unop1_builtin (icode, arglist, target)\n \n   if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n     op0 = copy_to_mode_reg (mode0, op0);\n-\n-  pat = GEN_FCN (icode) (target, op0, op0);\n+  \n+  op1 = op0;\n+  if (! (*insn_data[icode].operand[2].predicate) (op1, mode0))\n+    op1 = copy_to_mode_reg (mode0, op1);\n+  \n+  pat = GEN_FCN (icode) (target, op0, op1);\n   if (! pat)\n     return 0;\n   emit_insn (pat);"}]}