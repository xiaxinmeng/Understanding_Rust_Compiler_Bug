{"sha": "2c851ddd1c40ec8c1adf8e92ce830e5e22b4a267", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM4NTFkZGQxYzQwZWM4YzFhZGY4ZTkyY2U4MzBlNWUyMmI0YTI2Nw==", "commit": {"author": {"name": "Pascal Obry", "email": "obry@adacore.com", "date": "2007-04-06T09:15:56Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:15:56Z"}, "message": "s-osprim-mingw.adb (Timed_Delay): Use the right clock (standard one or the monotonic used by Ada.Real_Time) to...\n\n2007-04-06  Pascal Obry  <obry@adacore.com>\n\n\t* s-osprim-mingw.adb (Timed_Delay): Use the right clock (standard one\n\tor the monotonic used by Ada.Real_Time) to compute the sleep duration\n\ton Windows.\n\nFrom-SVN: r123546", "tree": {"sha": "092f27b61c5cb3f1ab8ec29f84c0d7590185bfd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/092f27b61c5cb3f1ab8ec29f84c0d7590185bfd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c851ddd1c40ec8c1adf8e92ce830e5e22b4a267", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c851ddd1c40ec8c1adf8e92ce830e5e22b4a267", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c851ddd1c40ec8c1adf8e92ce830e5e22b4a267", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c851ddd1c40ec8c1adf8e92ce830e5e22b4a267/comments", "author": {"login": "TurboGit", "id": 467069, "node_id": "MDQ6VXNlcjQ2NzA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/467069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TurboGit", "html_url": "https://github.com/TurboGit", "followers_url": "https://api.github.com/users/TurboGit/followers", "following_url": "https://api.github.com/users/TurboGit/following{/other_user}", "gists_url": "https://api.github.com/users/TurboGit/gists{/gist_id}", "starred_url": "https://api.github.com/users/TurboGit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TurboGit/subscriptions", "organizations_url": "https://api.github.com/users/TurboGit/orgs", "repos_url": "https://api.github.com/users/TurboGit/repos", "events_url": "https://api.github.com/users/TurboGit/events{/privacy}", "received_events_url": "https://api.github.com/users/TurboGit/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2d7475246d0e0e573138fd47bd31a091df0dc4ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d7475246d0e0e573138fd47bd31a091df0dc4ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d7475246d0e0e573138fd47bd31a091df0dc4ae"}], "stats": {"total": 95, "additions": 40, "deletions": 55}, "files": [{"sha": "dd306ad849109255833a6e53f70ee82dcff6693c", "filename": "gcc/ada/s-osinte-vxworks.adb", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c851ddd1c40ec8c1adf8e92ce830e5e22b4a267/gcc%2Fada%2Fs-osinte-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c851ddd1c40ec8c1adf8e92ce830e5e22b4a267/gcc%2Fada%2Fs-osinte-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-vxworks.adb?ref=2c851ddd1c40ec8c1adf8e92ce830e5e22b4a267", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                   B o d y                                --\n --                                                                          --\n---             Copyright (C) 1997-2006 Free Software Foundation             --\n+--         Copyright (C) 1997-2006, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is the VxWorks version.\n+--  This is the VxWorks version\n \n --  This package encapsulates all direct interfaces to OS services\n --  that are needed by children of System.\n@@ -45,7 +45,7 @@ package body System.OS_Interface is\n    use type Interfaces.C.int;\n \n    Low_Priority : constant := 255;\n-   --  VxWorks native (default) lowest scheduling priority.\n+   --  VxWorks native (default) lowest scheduling priority\n \n    ------------\n    -- getpid --\n@@ -123,12 +123,13 @@ package body System.OS_Interface is\n    function To_Timespec (D : Duration) return timespec is\n       S : time_t;\n       F : Duration;\n+\n    begin\n       S := time_t (Long_Long_Integer (D));\n       F := D - Duration (S);\n \n-      --  If F has negative value due to a round-up, adjust for positive F\n-      --  value.\n+      --  If F is negative due to a round-up, adjust for positive F value\n+\n       if F < 0.0 then\n          S := S - 1;\n          F := F + 1.0;\n@@ -151,16 +152,15 @@ package body System.OS_Interface is\n    -- To_Clock_Ticks --\n    --------------------\n \n-   --  ??? - For now, we'll always get the system clock rate\n-   --  since it is allowed to be changed during run-time in\n-   --  VxWorks. A better method would be to provide an operation\n-   --  to set it that so we can always know its value.\n-   --\n-   --  Another thing we should probably allow for is a resultant\n-   --  tick count greater than int'Last. This should probably\n-   --  be a procedure with two output parameters, one in the\n-   --  range 0 .. int'Last, and another representing the overflow\n-   --  count.\n+   --  ??? - For now, we'll always get the system clock rate since it is\n+   --  allowed to be changed during run-time in VxWorks. A better method would\n+   --  be to provide an operation to set it that so we can always know its\n+   --  value.\n+\n+   --  Another thing we should probably allow for is a resultant tick count\n+   --  greater than int'Last. This should probably be a procedure with two\n+   --  output parameters, one in the range 0 .. int'Last, and another\n+   --  representing the overflow count.\n \n    function To_Clock_Ticks (D : Duration) return int is\n       Ticks          : Long_Long_Integer;\n@@ -195,13 +195,4 @@ package body System.OS_Interface is\n       return int (Ticks);\n    end To_Clock_Ticks;\n \n-   ----------------\n-   -- VX_FP_TASK --\n-   ----------------\n-\n-   function VX_FP_TASK return int is\n-   begin\n-      return 16#0008#;\n-   end VX_FP_TASK;\n-\n end System.OS_Interface;"}, {"sha": "7952ba24b83a686b251253e4ad7160823548f77e", "filename": "gcc/ada/s-osinte-vxworks.ads", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c851ddd1c40ec8c1adf8e92ce830e5e22b4a267/gcc%2Fada%2Fs-osinte-vxworks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c851ddd1c40ec8c1adf8e92ce830e5e22b4a267/gcc%2Fada%2Fs-osinte-vxworks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-vxworks.ads?ref=2c851ddd1c40ec8c1adf8e92ce830e5e22b4a267", "patch": "@@ -275,9 +275,6 @@ package System.OS_Interface is\n    VX_FP_PRIVATE_ENV : constant := 16#0080#;\n    VX_NO_STACK_FILL  : constant := 16#0100#;\n \n-   function VX_FP_TASK return int;\n-   pragma Inline (VX_FP_TASK);\n-\n    function taskSpawn\n      (name          : System.Address;  --  Pointer to task name\n       priority      : int;"}, {"sha": "2621c60a0b7342c8cb065f987b6edb1e47eabcab", "filename": "gcc/ada/s-taprop-vxworks.adb", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c851ddd1c40ec8c1adf8e92ce830e5e22b4a267/gcc%2Fada%2Fs-taprop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c851ddd1c40ec8c1adf8e92ce830e5e22b4a267/gcc%2Fada%2Fs-taprop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vxworks.adb?ref=2c851ddd1c40ec8c1adf8e92ce830e5e22b4a267", "patch": "@@ -263,15 +263,18 @@ package body System.Task_Primitives.Operations is\n    -- Initialize_Lock --\n    ---------------------\n \n-   procedure Initialize_Lock (Prio : System.Any_Priority; L : access Lock) is\n+   procedure Initialize_Lock\n+     (Prio : System.Any_Priority; L : not null access Lock) is\n    begin\n       L.Mutex := semMCreate (SEM_Q_PRIORITY + SEM_INVERSION_SAFE);\n       L.Prio_Ceiling := int (Prio);\n       L.Protocol := Mutex_Protocol;\n       pragma Assert (L.Mutex /= 0);\n    end Initialize_Lock;\n \n-   procedure Initialize_Lock (L : access RTS_Lock; Level : Lock_Level) is\n+   procedure Initialize_Lock\n+     (L : not null access RTS_Lock; Level : Lock_Level)\n+   is\n       pragma Unreferenced (Level);\n \n    begin\n@@ -285,14 +288,14 @@ package body System.Task_Primitives.Operations is\n    -- Finalize_Lock --\n    -------------------\n \n-   procedure Finalize_Lock (L : access Lock) is\n+   procedure Finalize_Lock (L : not null access Lock) is\n       Result : int;\n    begin\n       Result := semDelete (L.Mutex);\n       pragma Assert (Result = 0);\n    end Finalize_Lock;\n \n-   procedure Finalize_Lock (L : access RTS_Lock) is\n+   procedure Finalize_Lock (L : not null access RTS_Lock) is\n       Result : int;\n    begin\n       Result := semDelete (L.Mutex);\n@@ -303,7 +306,9 @@ package body System.Task_Primitives.Operations is\n    -- Write_Lock --\n    ----------------\n \n-   procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n+   procedure Write_Lock\n+     (L : not null access Lock; Ceiling_Violation : out Boolean)\n+   is\n       Result : int;\n    begin\n       if L.Protocol = Prio_Protect\n@@ -320,7 +325,7 @@ package body System.Task_Primitives.Operations is\n    end Write_Lock;\n \n    procedure Write_Lock\n-     (L           : access RTS_Lock;\n+     (L           : not null access RTS_Lock;\n       Global_Lock : Boolean := False)\n    is\n       Result : int;\n@@ -344,7 +349,8 @@ package body System.Task_Primitives.Operations is\n    -- Read_Lock --\n    ---------------\n \n-   procedure Read_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n+   procedure Read_Lock\n+     (L : not null access Lock; Ceiling_Violation : out Boolean) is\n    begin\n       Write_Lock (L, Ceiling_Violation);\n    end Read_Lock;\n@@ -353,14 +359,16 @@ package body System.Task_Primitives.Operations is\n    -- Unlock --\n    ------------\n \n-   procedure Unlock (L : access Lock) is\n+   procedure Unlock (L : not null access Lock) is\n       Result : int;\n    begin\n       Result := semGive (L.Mutex);\n       pragma Assert (Result = 0);\n    end Unlock;\n \n-   procedure Unlock (L : access RTS_Lock; Global_Lock : Boolean := False) is\n+   procedure Unlock\n+     (L : not null access RTS_Lock; Global_Lock : Boolean := False)\n+   is\n       Result : int;\n    begin\n       if not Single_Lock or else Global_Lock then\n@@ -903,12 +911,13 @@ package body System.Task_Primitives.Operations is\n          Name_Address : System.Address;\n          --  Task name we are going to hand down to VxWorks\n \n-         Task_Options : aliased int;\n-         --  VxWorks options we are going to set for the created task,\n-         --  a combination of VX_optname_TASK attributes.\n-\n-         function To_int  is new Unchecked_Conversion (unsigned_int, int);\n-         function To_uint is new Unchecked_Conversion (int, unsigned_int);\n+         function Get_Task_Options return int;\n+         pragma Import (C, Get_Task_Options, \"__gnat_get_task_options\");\n+         --  Function that returns the options to be set for the task that we\n+         --  are creating. We fetch the options assigned to the current task,\n+         --  so offering some user level control over the options for a task\n+         --  hierarchy, and force VX_FP_TASK because it is almost always\n+         --  required.\n \n       begin\n          --  If there is no Ada task name handy, let VxWorks choose one.\n@@ -923,24 +932,12 @@ package body System.Task_Primitives.Operations is\n             Name_Address := Name'Address;\n          end if;\n \n-         --  For task options, we fetch the options assigned to the current\n-         --  task, so offering some user level control over the options for a\n-         --  task hierarchy, and force VX_FP_TASK because it is almost always\n-         --  required.\n-\n-         if taskOptionsGet (taskIdSelf, Task_Options'Access) /= OK then\n-            Task_Options := 0;\n-         end if;\n-\n-         Task_Options :=\n-           To_int (To_uint (Task_Options) or To_uint (VX_FP_TASK));\n-\n          --  Now spawn the VxWorks task for real\n \n          T.Common.LL.Thread := taskSpawn\n            (Name_Address,\n             To_VxWorks_Priority (int (Priority)),\n-            Task_Options,\n+            Get_Task_Options,\n             Adjusted_Stack_Size,\n             Wrapper,\n             To_Address (T));"}]}