{"sha": "8125704bd0b552cf5ea0d84e4d5f74544b0446fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODEyNTcwNGJkMGI1NTJjZjVlYTBkODRlNGQ1Zjc0NTQ0YjA0NDZmYQ==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@redhat.com", "date": "2001-11-29T18:12:37Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2001-11-29T18:12:37Z"}, "message": "emit-rtl.c (gen_lowpart_common): Fix conversion of REAL_VALUE_TYPEs to an array of target integers.\n\n        * emit-rtl.c (gen_lowpart_common): Fix conversion of\n        REAL_VALUE_TYPEs to an array of target integers.  Fix extraction\n        of low part of those arrays for 32bit and 64bit hosts.\n\nFrom-SVN: r47446", "tree": {"sha": "bef4d46a4315839be469b124f09a3ba4c90da806", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bef4d46a4315839be469b124f09a3ba4c90da806"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8125704bd0b552cf5ea0d84e4d5f74544b0446fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8125704bd0b552cf5ea0d84e4d5f74544b0446fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8125704bd0b552cf5ea0d84e4d5f74544b0446fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8125704bd0b552cf5ea0d84e4d5f74544b0446fa/comments", "author": null, "committer": null, "parents": [{"sha": "c87222f0749e8a97e3843355be012a9243ffd4f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c87222f0749e8a97e3843355be012a9243ffd4f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c87222f0749e8a97e3843355be012a9243ffd4f3"}], "stats": {"total": 58, "additions": 24, "deletions": 34}, "files": [{"sha": "8a97e84ac1e23c05cb3e1e33c27416f22c9d6b0c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8125704bd0b552cf5ea0d84e4d5f74544b0446fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8125704bd0b552cf5ea0d84e4d5f74544b0446fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8125704bd0b552cf5ea0d84e4d5f74544b0446fa", "patch": "@@ -1,3 +1,9 @@\n+Thu Nov 29 11:12:59 2001  Geoffrey Keating (geoffk@redhat.com)\n+\n+        * emit-rtl.c (gen_lowpart_common): Fix conversion of \n+        REAL_VALUE_TYPEs to an array of target integers.  Fix extraction\n+        of low part of those arrays for 32bit and 64bit hosts.\n+\n 2001-11-29  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* Makefile.in (insn-output.o): Depend on insn-codes.h."}, {"sha": "f3fda29e6dc539ae0836fa0e329ee4f98b68e981", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 18, "deletions": 34, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8125704bd0b552cf5ea0d84e4d5f74544b0446fa/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8125704bd0b552cf5ea0d84e4d5f74544b0446fa/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=8125704bd0b552cf5ea0d84e4d5f74544b0446fa", "patch": "@@ -1027,59 +1027,43 @@ gen_lowpart_common (mode, x)\n       long i[4];  /* Only the low 32 bits of each 'long' are used.  */\n       int endian = WORDS_BIG_ENDIAN ? 1 : 0;\n \n+      /* Convert 'r' into an array of four 32-bit words in target word\n+         order.  */\n       REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n       switch (GET_MODE_BITSIZE (GET_MODE (x)))\n \t{\n \tcase 32:\n-\t  REAL_VALUE_TO_TARGET_SINGLE (r, i[endian]);\n-\t  i[1 - endian] = 0;\n-\t  break;\n+          REAL_VALUE_TO_TARGET_SINGLE (r, i[3 * endian]);\n+\t  i[1] = 0;\n+\t  i[2] = 0;\n+          i[3 - 3 * endian] = 0;\n+          break;\n \tcase 64:\n-\t  REAL_VALUE_TO_TARGET_DOUBLE (r, i);\n-\t  break;\n+          REAL_VALUE_TO_TARGET_DOUBLE (r, i + 2 * endian);\n+\t  i[2 - 2 * endian] = 0;\n+\t  i[3 - 2 * endian] = 0;\n+          break;\n \tcase 96:\n \t  REAL_VALUE_TO_TARGET_LONG_DOUBLE (r, i + endian);\n-\t  i[3-3*endian] = 0;\n+\t  i[3 - 3 * endian] = 0;\n \t  break;\n \tcase 128:\n \t  REAL_VALUE_TO_TARGET_LONG_DOUBLE (r, i);\n \t  break;\n \tdefault:\n \t  abort ();\n \t}\n-\n       /* Now, pack the 32-bit elements of the array into a CONST_DOUBLE\n \t and return it.  */\n #if HOST_BITS_PER_WIDE_INT == 32\n-      return immed_double_const (i[endian], i[1 - endian], mode);\n+      return immed_double_const (i[3 * endian], i[1 + endian], mode);\n #else\n-      {\n-\tint c;\n-\n-\tif (HOST_BITS_PER_WIDE_INT != 64)\n-\t  abort ();\n-\n-\tfor (c = 0; c < 4; c++)\n-\t  i[c] &= ~ (0L);\n+      if (HOST_BITS_PER_WIDE_INT != 64)\n+\tabort ();\n \n-\tswitch (GET_MODE_BITSIZE (GET_MODE (x)))\n-\t  {\n-\t  case 32:\n-\t  case 64:\n-\t    return immed_double_const (((unsigned long) i[endian]) |\n-\t\t\t\t       (((HOST_WIDE_INT) i[1-endian]) << 32),\n-\t\t\t\t       0, mode);\n-\t  case 96:\n-\t  case 128:\n-\t    return immed_double_const (((unsigned long) i[endian*3]) |\n-\t\t\t\t       (((HOST_WIDE_INT) i[1+endian]) << 32),\n-\t\t\t\t       ((unsigned long) i[2-endian]) |\n-\t\t\t\t       (((HOST_WIDE_INT) i[3-endian*3]) << 32),\n-\t\t\t\t       mode);\n-\t  default:\n-\t    abort ();\n-\t  }\n-      }\n+      return immed_double_const (i[3 * endian] | (i[1 + endian] << 32),\n+\t\t\t\t i[2 - endian] | (i [3 - 3 * endian] << 32),\n+\t\t\t\t mode);\n #endif\n     }\n #endif /* ifndef REAL_ARITHMETIC */"}]}