{"sha": "649d196dbd78a119786f204d36b7c5d4dcb3a949", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ5ZDE5NmRiZDc4YTExOTc4NmYyMDRkMzZiN2M1ZDRkY2IzYTk0OQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-12-05T09:12:29Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-12-05T09:12:29Z"}, "message": "re PR tree-optimization/59374 (-ftree-slp-vectorize breaks unique_ptr's move constructor)\n\n2013-12-05  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/59374\n\t* tree-vect-data-refs.c (vect_slp_analyze_data_ref_dependence):\n\tCommonize known and unknown dependence case fixing the allowed\n\tread-write dependence case and dropping code that should not\n\tmatter.\n\n\t* gcc.dg/torture/pr59374-1.c: New testcase.\n\t* gcc.dg/torture/pr59374-2.c: Likewise.\n\nFrom-SVN: r205694", "tree": {"sha": "581b088790017147d3fe787fcd4730f516826751", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/581b088790017147d3fe787fcd4730f516826751"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/649d196dbd78a119786f204d36b7c5d4dcb3a949", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/649d196dbd78a119786f204d36b7c5d4dcb3a949", "html_url": "https://github.com/Rust-GCC/gccrs/commit/649d196dbd78a119786f204d36b7c5d4dcb3a949", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/649d196dbd78a119786f204d36b7c5d4dcb3a949/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9eb8c09fdae1c41a03d30a1a386dafbf25cb1b82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eb8c09fdae1c41a03d30a1a386dafbf25cb1b82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eb8c09fdae1c41a03d30a1a386dafbf25cb1b82"}], "stats": {"total": 140, "additions": 82, "deletions": 58}, "files": [{"sha": "ae5070481368013e3d7bdcc40925f9f3bb8c74e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649d196dbd78a119786f204d36b7c5d4dcb3a949/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649d196dbd78a119786f204d36b7c5d4dcb3a949/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=649d196dbd78a119786f204d36b7c5d4dcb3a949", "patch": "@@ -1,3 +1,11 @@\n+2013-12-05  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/59374\n+\t* tree-vect-data-refs.c (vect_slp_analyze_data_ref_dependence):\n+\tCommonize known and unknown dependence case fixing the allowed\n+\tread-write dependence case and dropping code that should not\n+\tmatter.\n+\n 2013-12-05  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n \t* config/ia64/ia64.md (prologue_allocate_stack): Block auto-"}, {"sha": "12fbdcd49f601de2ef1400090fcecd2a64a181c4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649d196dbd78a119786f204d36b7c5d4dcb3a949/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649d196dbd78a119786f204d36b7c5d4dcb3a949/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=649d196dbd78a119786f204d36b7c5d4dcb3a949", "patch": "@@ -1,3 +1,9 @@\n+2013-12-05  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/59374\n+\t* gcc.dg/torture/pr59374-1.c: New testcase.\n+\t* gcc.dg/torture/pr59374-2.c: Likewise.\n+\n 2013-12-05  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n \t* gcc.target/ia64/pr52731.c: New."}, {"sha": "6230ae9ca3d01d659c31dac1cdd2bf127685453f", "filename": "gcc/testsuite/gcc.dg/torture/pr59374-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649d196dbd78a119786f204d36b7c5d4dcb3a949/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr59374-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649d196dbd78a119786f204d36b7c5d4dcb3a949/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr59374-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr59374-1.c?ref=649d196dbd78a119786f204d36b7c5d4dcb3a949", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-ftree-slp-vectorize\" } */\n+\n+extern void abort (void);\n+\n+static struct X { void *a; void *b; } a, b;\n+\n+void __attribute__((noinline))\n+foo (void)\n+{\n+  void *tem = a.b;\n+  a.b = (void *)0;\n+  b.b = tem;\n+  b.a = a.a;\n+}\n+\n+int main()\n+{\n+  a.b = &a;\n+  foo ();\n+  if (b.b != &a)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "d791b987ef61aa76581ab91acc911e452187fb18", "filename": "gcc/testsuite/gcc.dg/torture/pr59374-2.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649d196dbd78a119786f204d36b7c5d4dcb3a949/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr59374-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649d196dbd78a119786f204d36b7c5d4dcb3a949/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr59374-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr59374-2.c?ref=649d196dbd78a119786f204d36b7c5d4dcb3a949", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-ftree-slp-vectorize\" } */\n+\n+extern void abort (void);\n+\n+static struct X { void *a; void *b; } a, b;\n+static struct X *p;\n+\n+void __attribute__((noinline))\n+foo (void)\n+{\n+  void *tem = a.b;\n+  p->b = (void *)0;\n+  b.b = tem;\n+  b.a = a.a;\n+}\n+\n+int main()\n+{\n+  p = &a;\n+  a.b = &a;\n+  foo ();\n+  if (b.b != &a)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "741586067bfa053e9ab3701562b8fcfa3d44f99b", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 18, "deletions": 58, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649d196dbd78a119786f204d36b7c5d4dcb3a949/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649d196dbd78a119786f204d36b7c5d4dcb3a949/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=649d196dbd78a119786f204d36b7c5d4dcb3a949", "patch": "@@ -497,31 +497,17 @@ vect_slp_analyze_data_ref_dependence (struct data_dependence_relation *ddr)\n   /* Unknown data dependence.  */\n   if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n     {\n-      gimple earlier_stmt;\n-\n-      if (dump_enabled_p ())\n-        {\n-          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                           \"can't determine dependence between \");\n-          dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (dra));\n-          dump_printf (MSG_MISSED_OPTIMIZATION,  \" and \");\n-          dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (drb));\n+      if  (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"can't determine dependence between \");\n+\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (dra));\n+\t  dump_printf (MSG_MISSED_OPTIMIZATION,  \" and \");\n+\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (drb));\n \t  dump_printf (MSG_MISSED_OPTIMIZATION,  \"\\n\");\n-        }\n-\n-      /* We do not vectorize basic blocks with write-write dependencies.  */\n-      if (DR_IS_WRITE (dra) && DR_IS_WRITE (drb))\n-        return true;\n-\n-      /* Check that it's not a load-after-store dependence.  */\n-      earlier_stmt = get_earlier_stmt (DR_STMT (dra), DR_STMT (drb));\n-      if (DR_IS_WRITE (STMT_VINFO_DATA_REF (vinfo_for_stmt (earlier_stmt))))\n-        return true;\n-\n-      return false;\n+\t}\n     }\n-\n-  if (dump_enabled_p ())\n+  else if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location,\n \t\t       \"determined dependence between \");\n@@ -531,49 +517,23 @@ vect_slp_analyze_data_ref_dependence (struct data_dependence_relation *ddr)\n       dump_printf (MSG_NOTE,  \"\\n\");\n     }\n \n-  /* Do not vectorize basic blocks with write-write dependences.  */\n+  /* We do not vectorize basic blocks with write-write dependencies.  */\n   if (DR_IS_WRITE (dra) && DR_IS_WRITE (drb))\n     return true;\n \n-  /* Check dependence between DRA and DRB for basic block vectorization.\n-     If the accesses share same bases and offsets, we can compare their initial\n-     constant offsets to decide whether they differ or not.  In case of a read-\n-     write dependence we check that the load is before the store to ensure that\n-     vectorization will not change the order of the accesses.  */\n-\n-  HOST_WIDE_INT type_size_a, type_size_b, init_a, init_b;\n-  gimple earlier_stmt;\n-\n-  /* Check that the data-refs have same bases and offsets.  If not, we can't\n-     determine if they are dependent.  */\n-  if (!operand_equal_p (DR_BASE_ADDRESS (dra), DR_BASE_ADDRESS (drb), 0)\n-      || !dr_equal_offsets_p (dra, drb))\n-    return true;\n-\n-  /* Check the types.  */\n-  type_size_a = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dra))));\n-  type_size_b = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (drb))));\n-\n-  if (type_size_a != type_size_b\n-      || !types_compatible_p (TREE_TYPE (DR_REF (dra)),\n-                              TREE_TYPE (DR_REF (drb))))\n-    return true;\n-\n-  init_a = TREE_INT_CST_LOW (DR_INIT (dra));\n-  init_b = TREE_INT_CST_LOW (DR_INIT (drb));\n-\n-  /* Two different locations - no dependence.  */\n-  if (init_a != init_b)\n-    return false;\n-\n-  /* We have a read-write dependence.  Check that the load is before the store.\n+  /* If we have a read-write dependence check that the load is before the store.\n      When we vectorize basic blocks, vector load can be only before\n      corresponding scalar load, and vector store can be only after its\n      corresponding scalar store.  So the order of the acceses is preserved in\n      case the load is before the store.  */\n-  earlier_stmt = get_earlier_stmt (DR_STMT (dra), DR_STMT (drb));\n+  gimple earlier_stmt = get_earlier_stmt (DR_STMT (dra), DR_STMT (drb));\n   if (DR_IS_READ (STMT_VINFO_DATA_REF (vinfo_for_stmt (earlier_stmt))))\n-    return false;\n+    {\n+      /* That only holds for load-store pairs taking part in vectorization.  */\n+      if (STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dra)))\n+\t  && STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (drb))))\n+\treturn false;\n+    }\n \n   return true;\n }"}]}