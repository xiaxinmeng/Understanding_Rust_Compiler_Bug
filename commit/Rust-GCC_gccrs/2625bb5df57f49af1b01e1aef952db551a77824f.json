{"sha": "2625bb5df57f49af1b01e1aef952db551a77824f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYyNWJiNWRmNTdmNDlhZjFiMDFlMWFlZjk1MmRiNTUxYTc3ODI0Zg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-12-08T09:20:35Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-12-08T09:20:35Z"}, "message": "builtins.c (fold_builtin_0): Remove unused ignore parameter.\n\n2014-12-08  Richard Biener  <rguenther@suse.de>\n\n\t* builtins.c (fold_builtin_0): Remove unused ignore parameter.\n\t(fold_builtin_1): Likewise.\n\t(fold_builtin_3): Likewise.\n\t(fold_builtin_varargs): Likewise.\n\t(fold_builtin_2): Likewise.  Do not fold stpcpy here.\n\t(fold_builtin_n): Adjust.\n\t(fold_builtin_stpcpy): Move to gimple-fold.c.\n\t(gimple_fold_builtin_stpcpy): Moved and gimplified from builtins.c.\n\t(gimple_fold_builtin): Fold stpcpy here.\n\nFrom-SVN: r218477", "tree": {"sha": "c5a996ea6a1db3480234071383e2dce66694b665", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5a996ea6a1db3480234071383e2dce66694b665"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2625bb5df57f49af1b01e1aef952db551a77824f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2625bb5df57f49af1b01e1aef952db551a77824f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2625bb5df57f49af1b01e1aef952db551a77824f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2625bb5df57f49af1b01e1aef952db551a77824f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b0122457bc82d5ae39a9b32655713dd279224ed4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0122457bc82d5ae39a9b32655713dd279224ed4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0122457bc82d5ae39a9b32655713dd279224ed4"}], "stats": {"total": 179, "additions": 99, "deletions": 80}, "files": [{"sha": "f17774fe3ffe00d631d9ce50de8a772f6335929c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2625bb5df57f49af1b01e1aef952db551a77824f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2625bb5df57f49af1b01e1aef952db551a77824f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2625bb5df57f49af1b01e1aef952db551a77824f", "patch": "@@ -1,3 +1,15 @@\n+2014-12-08  Richard Biener  <rguenther@suse.de>\n+\n+\t* builtins.c (fold_builtin_0): Remove unused ignore parameter.\n+\t(fold_builtin_1): Likewise.\n+\t(fold_builtin_3): Likewise.\n+\t(fold_builtin_varargs): Likewise.\n+\t(fold_builtin_2): Likewise.  Do not fold stpcpy here.\n+\t(fold_builtin_n): Adjust.\n+\t(fold_builtin_stpcpy): Move to gimple-fold.c.\n+\t(gimple_fold_builtin_stpcpy): Moved and gimplified from builtins.c.\n+\t(gimple_fold_builtin): Fold stpcpy here.\n+\n 2014-12-07  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* symtab.c (symtab_node::verify): Check for section attribute before"}, {"sha": "7cbac60851c6ca37bd1d1cfed0075ec0faba73fe", "filename": "gcc/builtins.c", "status": "modified", "additions": 21, "deletions": 80, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2625bb5df57f49af1b01e1aef952db551a77824f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2625bb5df57f49af1b01e1aef952db551a77824f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=2625bb5df57f49af1b01e1aef952db551a77824f", "patch": "@@ -191,11 +191,11 @@ static tree fold_builtin_fabs (location_t, tree, tree);\n static tree fold_builtin_abs (location_t, tree, tree);\n static tree fold_builtin_unordered_cmp (location_t, tree, tree, tree, enum tree_code,\n \t\t\t\t\tenum tree_code);\n-static tree fold_builtin_0 (location_t, tree, bool);\n-static tree fold_builtin_1 (location_t, tree, tree, bool);\n-static tree fold_builtin_2 (location_t, tree, tree, tree, bool);\n-static tree fold_builtin_3 (location_t, tree, tree, tree, tree, bool);\n-static tree fold_builtin_varargs (location_t, tree, tree*, int, bool);\n+static tree fold_builtin_0 (location_t, tree);\n+static tree fold_builtin_1 (location_t, tree, tree);\n+static tree fold_builtin_2 (location_t, tree, tree, tree);\n+static tree fold_builtin_3 (location_t, tree, tree, tree, tree);\n+static tree fold_builtin_varargs (location_t, tree, tree*, int);\n \n static tree fold_builtin_strpbrk (location_t, tree, tree, tree);\n static tree fold_builtin_strstr (location_t, tree, tree, tree);\n@@ -8657,47 +8657,6 @@ fold_builtin_exponent (location_t loc, tree fndecl, tree arg,\n   return NULL_TREE;\n }\n \n-/* Fold function call to builtin stpcpy with arguments DEST and SRC.\n-   Return NULL_TREE if no simplification can be made.  */\n-\n-static tree\n-fold_builtin_stpcpy (location_t loc, tree fndecl, tree dest, tree src)\n-{\n-  tree fn, len, lenp1, call, type;\n-\n-  if (!validate_arg (dest, POINTER_TYPE)\n-      || !validate_arg (src, POINTER_TYPE))\n-    return NULL_TREE;\n-\n-  len = c_strlen (src, 1);\n-  if (!len\n-      || TREE_CODE (len) != INTEGER_CST)\n-    return NULL_TREE;\n-\n-  if (optimize_function_for_size_p (cfun)\n-      /* If length is zero it's small enough.  */\n-      && !integer_zerop (len))\n-    return NULL_TREE;\n-\n-  fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n-  if (!fn)\n-    return NULL_TREE;\n-\n-  lenp1 = size_binop_loc (loc, PLUS_EXPR,\n-\t\t\t  fold_convert_loc (loc, size_type_node, len),\n-\t\t\t  build_int_cst (size_type_node, 1));\n-  /* We use dest twice in building our expression.  Save it from\n-     multiple expansions.  */\n-  dest = builtin_save_expr (dest);\n-  call = build_call_expr_loc (loc, fn, 3, dest, src, lenp1);\n-\n-  type = TREE_TYPE (TREE_TYPE (fndecl));\n-  dest = fold_build_pointer_plus_loc (loc, dest, len);\n-  dest = fold_convert_loc (loc, type, dest);\n-  dest = omit_one_operand_loc (loc, type, dest, call);\n-  return dest;\n-}\n-\n /* Fold function call to builtin memchr.  ARG1, ARG2 and LEN are the\n    arguments to the call, and TYPE is its return type.\n    Return NULL_TREE if no simplification can be made.  */\n@@ -9857,11 +9816,10 @@ fold_builtin_arith_overflow (location_t loc, enum built_in_function fcode,\n }\n \n /* Fold a call to built-in function FNDECL with 0 arguments.\n-   IGNORE is true if the result of the function call is ignored.  This\n-   function returns NULL_TREE if no simplification was possible.  */\n+   This function returns NULL_TREE if no simplification was possible.  */\n \n static tree\n-fold_builtin_0 (location_t loc, tree fndecl, bool ignore ATTRIBUTE_UNUSED)\n+fold_builtin_0 (location_t loc, tree fndecl)\n {\n   tree type = TREE_TYPE (TREE_TYPE (fndecl));\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n@@ -9886,11 +9844,10 @@ fold_builtin_0 (location_t loc, tree fndecl, bool ignore ATTRIBUTE_UNUSED)\n }\n \n /* Fold a call to built-in function FNDECL with 1 argument, ARG0.\n-   IGNORE is true if the result of the function call is ignored.  This\n-   function returns NULL_TREE if no simplification was possible.  */\n+   This function returns NULL_TREE if no simplification was possible.  */\n \n static tree\n-fold_builtin_1 (location_t loc, tree fndecl, tree arg0, bool)\n+fold_builtin_1 (location_t loc, tree fndecl, tree arg0)\n {\n   tree type = TREE_TYPE (TREE_TYPE (fndecl));\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n@@ -10301,11 +10258,10 @@ fold_builtin_1 (location_t loc, tree fndecl, tree arg0, bool)\n }\n \n /* Fold a call to built-in function FNDECL with 2 arguments, ARG0 and ARG1.\n-   IGNORE is true if the result of the function call is ignored.  This\n-   function returns NULL_TREE if no simplification was possible.  */\n+   This function returns NULL_TREE if no simplification was possible.  */\n \n static tree\n-fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1, bool ignore)\n+fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1)\n {\n   tree type = TREE_TYPE (TREE_TYPE (fndecl));\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n@@ -10392,19 +10348,6 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1, bool ignore)\n     case BUILT_IN_RINDEX:\n       return fold_builtin_strrchr (loc, arg0, arg1, type);\n \n-    case BUILT_IN_STPCPY:\n-      if (ignore)\n-\t{\n-\t  tree fn = builtin_decl_implicit (BUILT_IN_STRCPY);\n-\t  if (!fn)\n-\t    break;\n-\n-\t  return build_call_expr_loc (loc, fn, 2, arg0, arg1);\n-\t}\n-      else\n-\treturn fold_builtin_stpcpy (loc, fndecl, arg0, arg1);\n-      break;\n-\n     case BUILT_IN_STRCMP:\n       return fold_builtin_strcmp (loc, arg0, arg1);\n \n@@ -10469,12 +10412,12 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1, bool ignore)\n }\n \n /* Fold a call to built-in function FNDECL with 3 arguments, ARG0, ARG1,\n-   and ARG2.  IGNORE is true if the result of the function call is ignored.\n+   and ARG2.\n    This function returns NULL_TREE if no simplification was possible.  */\n \n static tree\n fold_builtin_3 (location_t loc, tree fndecl,\n-\t\ttree arg0, tree arg1, tree arg2, bool)\n+\t\ttree arg0, tree arg1, tree arg2)\n {\n   tree type = TREE_TYPE (TREE_TYPE (fndecl));\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n@@ -10543,26 +10486,26 @@ fold_builtin_3 (location_t loc, tree fndecl,\n    simplification was possible.  */\n \n tree\n-fold_builtin_n (location_t loc, tree fndecl, tree *args, int nargs, bool ignore)\n+fold_builtin_n (location_t loc, tree fndecl, tree *args, int nargs, bool)\n {\n   tree ret = NULL_TREE;\n \n   switch (nargs)\n     {\n     case 0:\n-      ret = fold_builtin_0 (loc, fndecl, ignore);\n+      ret = fold_builtin_0 (loc, fndecl);\n       break;\n     case 1:\n-      ret = fold_builtin_1 (loc, fndecl, args[0], ignore);\n+      ret = fold_builtin_1 (loc, fndecl, args[0]);\n       break;\n     case 2:\n-      ret = fold_builtin_2 (loc, fndecl, args[0], args[1], ignore);\n+      ret = fold_builtin_2 (loc, fndecl, args[0], args[1]);\n       break;\n     case 3:\n-      ret = fold_builtin_3 (loc, fndecl, args[0], args[1], args[2], ignore);\n+      ret = fold_builtin_3 (loc, fndecl, args[0], args[1], args[2]);\n       break;\n     default:\n-      ret = fold_builtin_varargs (loc, fndecl, args, nargs, ignore);\n+      ret = fold_builtin_varargs (loc, fndecl, args, nargs);\n       break;\n     }\n   if (ret)\n@@ -11656,12 +11599,10 @@ fold_builtin_object_size (tree ptr, tree ost)\n    need special handling; we need to store the arguments in a convenient\n    data structure before attempting any folding.  Fortunately there are\n    only a few builtins that fall into this category.  FNDECL is the\n-   function, EXP is the CALL_EXPR for the call, and IGNORE is true if the\n-   result of the function call is ignored.  */\n+   function, EXP is the CALL_EXPR for the call.  */\n \n static tree\n-fold_builtin_varargs (location_t loc, tree fndecl, tree *args, int nargs,\n-\t\t      bool ignore ATTRIBUTE_UNUSED)\n+fold_builtin_varargs (location_t loc, tree fndecl, tree *args, int nargs)\n {\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n   tree ret = NULL_TREE;"}, {"sha": "e71e0954f6cab2a140158a450076bd2e492f6228", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2625bb5df57f49af1b01e1aef952db551a77824f/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2625bb5df57f49af1b01e1aef952db551a77824f/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=2625bb5df57f49af1b01e1aef952db551a77824f", "patch": "@@ -2052,6 +2052,70 @@ gimple_fold_builtin_stxncpy_chk (gimple_stmt_iterator *gsi,\n   return true;\n }\n \n+/* Fold function call to builtin stpcpy with arguments DEST and SRC.\n+   Return NULL_TREE if no simplification can be made.  */\n+\n+static bool\n+gimple_fold_builtin_stpcpy (gimple_stmt_iterator *gsi)\n+{\n+  gcall *stmt = as_a <gcall *> (gsi_stmt (*gsi));\n+  location_t loc = gimple_location (stmt);\n+  tree dest = gimple_call_arg (stmt, 0);\n+  tree src = gimple_call_arg (stmt, 1);\n+  tree fn, len, lenp1;\n+\n+  /* If the result is unused, replace stpcpy with strcpy.  */\n+  if (gimple_call_lhs (stmt) == NULL_TREE)\n+    {\n+      tree fn = builtin_decl_implicit (BUILT_IN_STRCPY);\n+      if (!fn)\n+\treturn false;\n+      gimple_call_set_fndecl (stmt, fn);\n+      fold_stmt (gsi);\n+      return true;\n+    }\n+\n+  len = c_strlen (src, 1);\n+  if (!len\n+      || TREE_CODE (len) != INTEGER_CST)\n+    return false;\n+\n+  if (optimize_function_for_size_p (cfun)\n+      /* If length is zero it's small enough.  */\n+      && !integer_zerop (len))\n+    return false;\n+\n+  /* If the source has a known length replace stpcpy with memcpy.  */\n+  fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n+  if (!fn)\n+    return false;\n+\n+  gimple_seq stmts = NULL;\n+  tree tem = gimple_convert (&stmts, loc, size_type_node, len);\n+  lenp1 = gimple_build (&stmts, loc, PLUS_EXPR, size_type_node,\n+\t\t\ttem, build_int_cst (size_type_node, 1));\n+  gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+  gcall *repl = gimple_build_call (fn, 3, dest, src, lenp1);\n+  gimple_set_vuse (repl, gimple_vuse (stmt));\n+  gimple_set_vdef (repl, gimple_vdef (stmt));\n+  if (gimple_vdef (repl)\n+      && TREE_CODE (gimple_vdef (repl)) == SSA_NAME)\n+    SSA_NAME_DEF_STMT (gimple_vdef (repl)) = repl;\n+  gsi_insert_before (gsi, repl, GSI_SAME_STMT);\n+  /* Replace the result with dest + len.  */\n+  stmts = NULL;\n+  tem = gimple_convert (&stmts, loc, sizetype, len);\n+  gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+  gassign *ret = gimple_build_assign (gimple_call_lhs (stmt),\n+\t\t\t\t      POINTER_PLUS_EXPR, dest, tem);\n+  gsi_replace (gsi, ret, true);\n+  /* Finally fold the memcpy call.  */\n+  gimple_stmt_iterator gsi2 = *gsi;\n+  gsi_prev (&gsi2);\n+  fold_stmt (&gsi2);\n+  return true;\n+}\n+\n /* Fold a call EXP to {,v}snprintf having NARGS passed as ARGS.  Return\n    NULL_TREE if a normal call should be emitted rather than expanding\n    the function inline.  FCODE is either BUILT_IN_SNPRINTF_CHK or\n@@ -2849,6 +2913,8 @@ gimple_fold_builtin (gimple_stmt_iterator *gsi)\n \t\t\t\t\t     gimple_call_arg (stmt, 2),\n \t\t\t\t\t     gimple_call_arg (stmt, 3),\n \t\t\t\t\t     fcode);\n+    case BUILT_IN_STPCPY:\n+      return gimple_fold_builtin_stpcpy (gsi);\n     case BUILT_IN_STRCPY_CHK:\n     case BUILT_IN_STPCPY_CHK:\n       return gimple_fold_builtin_stxcpy_chk (gsi,"}]}