{"sha": "b7dce216c7aabe73aae567e6565f44676246a518", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdkY2UyMTZjN2FhYmU3M2FhZTU2N2U2NTY1ZjQ0Njc2MjQ2YTUxOA==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2015-05-13T15:26:14Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2015-05-13T15:26:14Z"}, "message": "[tree-ssa-math-opts] Expand pow (x, CONST) using square roots when possible\n\n\t* params.def (PARAM_MAX_POW_SQRT_DEPTH): New param.\n\t* tree-ssa-math-opts.c: Include params.h\n\t(pow_synth_sqrt_info): New struct.\n\t(representable_as_half_series_p): New function.\n\t(get_fn_chain): Likewise.\n\t(print_nested_fn): Likewise.\n\t(dump_fractional_sqrt_sequence): Likewise.\n\t(dump_integer_part): Likewise.\n\t(expand_pow_as_sqrts): Likewise.\n\t(gimple_expand_builtin_pow): Use above to attempt to expand\n\tpow as series of square roots.  Removed now unused variables.\n\n\t* gcc.target/aarch64/pow-sqrt-synth-1.c: New test.\n\t* gcc.dg/pow-sqrt.x: New file.\n\t* gcc.dg/pow-sqrt-1.c: New test.\n\t* gcc.dg/pow-sqrt-2.c: Likewise.\n\t* gcc.dg/pow-sqrt-3.c: Likewise.\n\nFrom-SVN: r223167", "tree": {"sha": "e2d5e277b402d4d751638756eee12266bbada3e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2d5e277b402d4d751638756eee12266bbada3e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7dce216c7aabe73aae567e6565f44676246a518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7dce216c7aabe73aae567e6565f44676246a518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7dce216c7aabe73aae567e6565f44676246a518", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7dce216c7aabe73aae567e6565f44676246a518/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "da80c6b81f6162937acea26d014063f772ae1305", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da80c6b81f6162937acea26d014063f772ae1305", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da80c6b81f6162937acea26d014063f772ae1305"}], "stats": {"total": 576, "additions": 491, "deletions": 85}, "files": [{"sha": "ce50a3625e905b6d5616e562a0f6691ebe3cc3a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7dce216c7aabe73aae567e6565f44676246a518/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7dce216c7aabe73aae567e6565f44676246a518/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7dce216c7aabe73aae567e6565f44676246a518", "patch": "@@ -1,3 +1,17 @@\n+2015-05-13  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* params.def (PARAM_MAX_POW_SQRT_DEPTH): New param.\n+\t* tree-ssa-math-opts.c: Include params.h\n+\t(pow_synth_sqrt_info): New struct.\n+\t(representable_as_half_series_p): New function.\n+\t(get_fn_chain): Likewise.\n+\t(print_nested_fn): Likewise.\n+\t(dump_fractional_sqrt_sequence): Likewise.\n+\t(dump_integer_part): Likewise.\n+\t(expand_pow_as_sqrts): Likewise.\n+\t(gimple_expand_builtin_pow): Use above to attempt to expand\n+\tpow as series of square roots.  Removed now unused variables.\n+\n 2015-05-13  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/alpha.c (alpha_emit_set_long_const): Remove c1 argument."}, {"sha": "3e4ba3ad6ceda9d87ae4150d045572ac9808bb24", "filename": "gcc/params.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7dce216c7aabe73aae567e6565f44676246a518/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7dce216c7aabe73aae567e6565f44676246a518/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=b7dce216c7aabe73aae567e6565f44676246a518", "patch": "@@ -262,6 +262,14 @@ DEFPARAM(PARAM_MAX_HOIST_DEPTH,\n \t \"Maximum depth of search in the dominator tree for expressions to hoist\",\n \t 30, 0, 0)\n \n+\n+/* When synthesizing expnonentiation by a real constant operations using square\n+   roots, this controls how deep sqrt chains we are willing to generate.  */\n+DEFPARAM(PARAM_MAX_POW_SQRT_DEPTH,\n+\t \"max-pow-sqrt-depth\",\n+\t \"Maximum depth of sqrt chains to use when synthesizing exponentiation by a real constant\",\n+\t 5, 1, 32)\n+\n /* This parameter limits the number of insns in a loop that will be unrolled,\n    and by how much the loop is unrolled.\n "}, {"sha": "5daa442ba994401942bf72fe7bc4e00c2facf9b1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7dce216c7aabe73aae567e6565f44676246a518/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7dce216c7aabe73aae567e6565f44676246a518/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b7dce216c7aabe73aae567e6565f44676246a518", "patch": "@@ -1,3 +1,11 @@\n+2015-05-13  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* gcc.target/aarch64/pow-sqrt-synth-1.c: New test.\n+\t* gcc.dg/pow-sqrt.x: New file.\n+\t* gcc.dg/pow-sqrt-1.c: New test.\n+\t* gcc.dg/pow-sqrt-2.c: Likewise.\n+\t* gcc.dg/pow-sqrt-3.c: Likewise.\n+\n 2015-05-13  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/66123"}, {"sha": "0793b6f9eaf8100d50e20b2db5375d3da16158e7", "filename": "gcc/testsuite/gcc.dg/pow-sqrt-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7dce216c7aabe73aae567e6565f44676246a518/gcc%2Ftestsuite%2Fgcc.dg%2Fpow-sqrt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7dce216c7aabe73aae567e6565f44676246a518/gcc%2Ftestsuite%2Fgcc.dg%2Fpow-sqrt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpow-sqrt-1.c?ref=b7dce216c7aabe73aae567e6565f44676246a518", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ffast-math --param max-pow-sqrt-depth=5\" } */\n+\n+#define EXPN (-6 * (0.5*0.5*0.5*0.5))\n+\n+#include \"pow-sqrt.x\""}, {"sha": "b2fada49e85316a4490684d1d25901a0ef06b4d2", "filename": "gcc/testsuite/gcc.dg/pow-sqrt-2.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7dce216c7aabe73aae567e6565f44676246a518/gcc%2Ftestsuite%2Fgcc.dg%2Fpow-sqrt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7dce216c7aabe73aae567e6565f44676246a518/gcc%2Ftestsuite%2Fgcc.dg%2Fpow-sqrt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpow-sqrt-2.c?ref=b7dce216c7aabe73aae567e6565f44676246a518", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ffast-math --param max-pow-sqrt-depth=5\" } */\n+\n+#define EXPN (-5.875)\n+#include \"pow-sqrt.x\""}, {"sha": "18c7231a5bbb5bfb6a0ac250df6975c3862ae6bf", "filename": "gcc/testsuite/gcc.dg/pow-sqrt-3.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7dce216c7aabe73aae567e6565f44676246a518/gcc%2Ftestsuite%2Fgcc.dg%2Fpow-sqrt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7dce216c7aabe73aae567e6565f44676246a518/gcc%2Ftestsuite%2Fgcc.dg%2Fpow-sqrt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpow-sqrt-3.c?ref=b7dce216c7aabe73aae567e6565f44676246a518", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ffast-math --param max-pow-sqrt-depth=3\" } */\n+\n+#define EXPN (1.25)\n+#include \"pow-sqrt.x\""}, {"sha": "bd744c611c426c131754d4d766638609835f5085", "filename": "gcc/testsuite/gcc.dg/pow-sqrt.x", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7dce216c7aabe73aae567e6565f44676246a518/gcc%2Ftestsuite%2Fgcc.dg%2Fpow-sqrt.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7dce216c7aabe73aae567e6565f44676246a518/gcc%2Ftestsuite%2Fgcc.dg%2Fpow-sqrt.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpow-sqrt.x?ref=b7dce216c7aabe73aae567e6565f44676246a518", "patch": "@@ -0,0 +1,30 @@\n+\n+extern void abort (void);\n+\n+\n+__attribute__((noinline)) double\n+real_pow (double x, double pow_exp)\n+{\n+  return __builtin_pow (x, pow_exp);\n+}\n+\n+#define EPS (0.000000000000000000001)\n+\n+#define SYNTH_POW(X, Y) __builtin_pow (X, Y)\n+volatile double arg;\n+\n+int\n+main (void)\n+{\n+  double i_arg = 0.1;\n+\n+  for (arg = i_arg; arg < 100.0; arg += 1.0)\n+    {\n+      double synth_res = SYNTH_POW (arg, EXPN);\n+      double real_res = real_pow (arg, EXPN);\n+\n+      if (__builtin_abs (SYNTH_POW (arg, EXPN) - real_pow (arg, EXPN)) > EPS)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "52514fb23b163f5eeb3c8261474f7122949b429a", "filename": "gcc/testsuite/gcc.target/aarch64/pow-sqrt-synth-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7dce216c7aabe73aae567e6565f44676246a518/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpow-sqrt-synth-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7dce216c7aabe73aae567e6565f44676246a518/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpow-sqrt-synth-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpow-sqrt-synth-1.c?ref=b7dce216c7aabe73aae567e6565f44676246a518", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-tree-sincos -Ofast --param max-pow-sqrt-depth=8\" } */\n+\n+\n+double\n+foo (double a)\n+{\n+  return __builtin_pow (a, -5.875);\n+}\n+\n+double\n+foof (double a)\n+{\n+  return __builtin_pow (a, 0.75f);\n+}\n+\n+double\n+bar (double a)\n+{\n+  return __builtin_pow (a, 1.0 + 0.00390625);\n+}\n+\n+double\n+baz (double a)\n+{\n+  return __builtin_pow (a, -1.25) + __builtin_pow (a, 5.75) - __builtin_pow (a, 3.375);\n+}\n+\n+#define N 256\n+void\n+vecfoo (double *a)\n+{\n+  for (int i = 0; i < N; i++)\n+    a[i] = __builtin_pow (a[i], 1.25);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"synthesizing\" 7 \"sincos\" } } */\n+/* { dg-final { cleanup-tree-dump \"sincos\" } } */\n\\ No newline at end of file"}, {"sha": "11288b1b56bc5f08dfb7f016f9cf36904f8ba95a", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 377, "deletions": 85, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7dce216c7aabe73aae567e6565f44676246a518/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7dce216c7aabe73aae567e6565f44676246a518/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=b7dce216c7aabe73aae567e6565f44676246a518", "patch": "@@ -143,6 +143,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"gimple-pretty-print.h\"\n #include \"builtins.h\"\n+#include \"params.h\"\n \n /* FIXME: RTL headers have to be included here for optabs.  */\n #include \"rtl.h\"\t\t/* Because optabs.h wants enum rtx_code.  */\n@@ -1148,6 +1149,357 @@ build_and_insert_cast (gimple_stmt_iterator *gsi, location_t loc,\n   return result;\n }\n \n+struct pow_synth_sqrt_info\n+{\n+  bool *factors;\n+  unsigned int deepest;\n+  unsigned int num_mults;\n+};\n+\n+/* Return true iff the real value C can be represented as a\n+   sum of powers of 0.5 up to N.  That is:\n+   C == SUM<i from 1..N> (a[i]*(0.5**i)) where a[i] is either 0 or 1.\n+   Record in INFO the various parameters of the synthesis algorithm such\n+   as the factors a[i], the maximum 0.5 power and the number of\n+   multiplications that will be required.  */\n+\n+bool\n+representable_as_half_series_p (REAL_VALUE_TYPE c, unsigned n,\n+\t\t\t\t struct pow_synth_sqrt_info *info)\n+{\n+  REAL_VALUE_TYPE factor = dconsthalf;\n+  REAL_VALUE_TYPE remainder = c;\n+\n+  info->deepest = 0;\n+  info->num_mults = 0;\n+  memset (info->factors, 0, n * sizeof (bool));\n+\n+  for (unsigned i = 0; i < n; i++)\n+    {\n+      REAL_VALUE_TYPE res;\n+\n+      /* If something inexact happened bail out now.  */\n+      if (REAL_ARITHMETIC (res, MINUS_EXPR, remainder, factor))\n+\treturn false;\n+\n+      /* We have hit zero.  The number is representable as a sum\n+         of powers of 0.5.  */\n+      if (REAL_VALUES_EQUAL (res, dconst0))\n+\t{\n+\t  info->factors[i] = true;\n+\t  info->deepest = i + 1;\n+\t  return true;\n+\t}\n+      else if (!REAL_VALUE_NEGATIVE (res))\n+\t{\n+\t  remainder = res;\n+\t  info->factors[i] = true;\n+\t  info->num_mults++;\n+\t}\n+      else\n+\tinfo->factors[i] = false;\n+\n+      REAL_ARITHMETIC (factor, MULT_EXPR, factor, dconsthalf);\n+    }\n+  return false;\n+}\n+\n+/* Return the tree corresponding to FN being applied\n+   to ARG N times at GSI and LOC.\n+   Look up previous results from CACHE if need be.\n+   cache[0] should contain just plain ARG i.e. FN applied to ARG 0 times.  */\n+\n+static tree\n+get_fn_chain (tree arg, unsigned int n, gimple_stmt_iterator *gsi,\n+\t      tree fn, location_t loc, tree *cache)\n+{\n+  tree res = cache[n];\n+  if (!res)\n+    {\n+      tree prev = get_fn_chain (arg, n - 1, gsi, fn, loc, cache);\n+      res = build_and_insert_call (gsi, loc, fn, prev);\n+      cache[n] = res;\n+    }\n+\n+  return res;\n+}\n+\n+/* Print to STREAM the repeated application of function FNAME to ARG\n+   N times.  So, for FNAME = \"foo\", ARG = \"x\", N = 2 it would print:\n+   \"foo (foo (x))\".  */\n+\n+static void\n+print_nested_fn (FILE* stream, const char *fname, const char* arg,\n+\t\t unsigned int n)\n+{\n+  if (n == 0)\n+    fprintf (stream, \"%s\", arg);\n+  else\n+    {\n+      fprintf (stream, \"%s (\", fname);\n+      print_nested_fn (stream, fname, arg, n - 1);\n+      fprintf (stream, \")\");\n+    }\n+}\n+\n+/* Print to STREAM the fractional sequence of sqrt chains\n+   applied to ARG, described by INFO.  Used for the dump file.  */\n+\n+static void\n+dump_fractional_sqrt_sequence (FILE *stream, const char *arg,\n+\t\t\t        struct pow_synth_sqrt_info *info)\n+{\n+  for (unsigned int i = 0; i < info->deepest; i++)\n+    {\n+      bool is_set = info->factors[i];\n+      if (is_set)\n+\t{\n+\t  print_nested_fn (stream, \"sqrt\", arg, i + 1);\n+\t  if (i != info->deepest - 1)\n+\t    fprintf (stream, \" * \");\n+\t}\n+    }\n+}\n+\n+/* Print to STREAM a representation of raising ARG to an integer\n+   power N.  Used for the dump file.  */\n+\n+static void\n+dump_integer_part (FILE *stream, const char* arg, HOST_WIDE_INT n)\n+{\n+  if (n > 1)\n+    fprintf (stream, \"powi (%s, \" HOST_WIDE_INT_PRINT_DEC \")\", arg, n);\n+  else if (n == 1)\n+    fprintf (stream, \"%s\", arg);\n+}\n+\n+/* Attempt to synthesize a POW[F] (ARG0, ARG1) call using chains of\n+   square roots.  Place at GSI and LOC.  Limit the maximum depth\n+   of the sqrt chains to MAX_DEPTH.  Return the tree holding the\n+   result of the expanded sequence or NULL_TREE if the expansion failed.\n+\n+   This routine assumes that ARG1 is a real number with a fractional part\n+   (the integer exponent case will have been handled earlier in\n+   gimple_expand_builtin_pow).\n+\n+   For ARG1 > 0.0:\n+   * For ARG1 composed of a whole part WHOLE_PART and a fractional part\n+     FRAC_PART i.e. WHOLE_PART == floor (ARG1) and\n+                    FRAC_PART == ARG1 - WHOLE_PART:\n+     Produce POWI (ARG0, WHOLE_PART) * POW (ARG0, FRAC_PART) where\n+     POW (ARG0, FRAC_PART) is expanded as a product of square root chains\n+     if it can be expressed as such, that is if FRAC_PART satisfies:\n+     FRAC_PART == <SUM from i = 1 until MAX_DEPTH> (a[i] * (0.5**i))\n+     where integer a[i] is either 0 or 1.\n+\n+     Example:\n+     POW (x, 3.625) == POWI (x, 3) * POW (x, 0.625)\n+       --> POWI (x, 3) * SQRT (x) * SQRT (SQRT (SQRT (x)))\n+\n+   For ARG1 < 0.0 there are two approaches:\n+   * (A) Expand to 1.0 / POW (ARG0, -ARG1) where POW (ARG0, -ARG1)\n+         is calculated as above.\n+\n+     Example:\n+     POW (x, -5.625) == 1.0 / POW (x, 5.625)\n+       -->  1.0 / (POWI (x, 5) * SQRT (x) * SQRT (SQRT (SQRT (x))))\n+\n+   * (B) : WHOLE_PART := - ceil (abs (ARG1))\n+           FRAC_PART  := ARG1 - WHOLE_PART\n+     and expand to POW (x, FRAC_PART) / POWI (x, WHOLE_PART).\n+     Example:\n+     POW (x, -5.875) == POW (x, 0.125) / POWI (X, 6)\n+       --> SQRT (SQRT (SQRT (x))) / (POWI (x, 6))\n+\n+   For ARG1 < 0.0 we choose between (A) and (B) depending on\n+   how many multiplications we'd have to do.\n+   So, for the example in (B): POW (x, -5.875), if we were to\n+   follow algorithm (A) we would produce:\n+   1.0 / POWI (X, 5) * SQRT (X) * SQRT (SQRT (X)) * SQRT (SQRT (SQRT (X)))\n+   which contains more multiplications than approach (B).\n+\n+   Hopefully, this approach will eliminate potentially expensive POW library\n+   calls when unsafe floating point math is enabled and allow the compiler to\n+   further optimise the multiplies, square roots and divides produced by this\n+   function.  */\n+\n+static tree\n+expand_pow_as_sqrts (gimple_stmt_iterator *gsi, location_t loc,\n+\t\t     tree arg0, tree arg1, HOST_WIDE_INT max_depth)\n+{\n+  tree type = TREE_TYPE (arg0);\n+  machine_mode mode = TYPE_MODE (type);\n+  tree sqrtfn = mathfn_built_in (type, BUILT_IN_SQRT);\n+  bool one_over = true;\n+\n+  if (!sqrtfn)\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (arg1) != REAL_CST)\n+    return NULL_TREE;\n+\n+  REAL_VALUE_TYPE exp_init = TREE_REAL_CST (arg1);\n+\n+  gcc_assert (max_depth > 0);\n+  tree *cache = XALLOCAVEC (tree, max_depth + 1);\n+\n+  struct pow_synth_sqrt_info synth_info;\n+  synth_info.factors = XALLOCAVEC (bool, max_depth + 1);\n+  synth_info.deepest = 0;\n+  synth_info.num_mults = 0;\n+\n+  bool neg_exp = REAL_VALUE_NEGATIVE (exp_init);\n+  REAL_VALUE_TYPE exp = real_value_abs (&exp_init);\n+\n+  /* The whole and fractional parts of exp.  */\n+  REAL_VALUE_TYPE whole_part;\n+  REAL_VALUE_TYPE frac_part;\n+\n+  real_floor (&whole_part, mode, &exp);\n+  REAL_ARITHMETIC (frac_part, MINUS_EXPR, exp, whole_part);\n+\n+\n+  REAL_VALUE_TYPE ceil_whole = dconst0;\n+  REAL_VALUE_TYPE ceil_fract = dconst0;\n+\n+  if (neg_exp)\n+    {\n+      real_ceil (&ceil_whole, mode, &exp);\n+      REAL_ARITHMETIC (ceil_fract, MINUS_EXPR, ceil_whole, exp);\n+    }\n+\n+  if (!representable_as_half_series_p (frac_part, max_depth, &synth_info))\n+    return NULL_TREE;\n+\n+  /* Check whether it's more profitable to not use 1.0 / ...  */\n+  if (neg_exp)\n+    {\n+      struct pow_synth_sqrt_info alt_synth_info;\n+      alt_synth_info.factors = XALLOCAVEC (bool, max_depth + 1);\n+      alt_synth_info.deepest = 0;\n+      alt_synth_info.num_mults = 0;\n+\n+      if (representable_as_half_series_p (ceil_fract, max_depth,\n+\t\t\t\t\t   &alt_synth_info)\n+\t  && alt_synth_info.deepest <= synth_info.deepest\n+\t  && alt_synth_info.num_mults < synth_info.num_mults)\n+\t{\n+\t  whole_part = ceil_whole;\n+\t  frac_part = ceil_fract;\n+\t  synth_info.deepest = alt_synth_info.deepest;\n+\t  synth_info.num_mults = alt_synth_info.num_mults;\n+\t  memcpy (synth_info.factors, alt_synth_info.factors,\n+\t\t  (max_depth + 1) * sizeof (bool));\n+\t  one_over = false;\n+\t}\n+    }\n+\n+  HOST_WIDE_INT n = real_to_integer (&whole_part);\n+  REAL_VALUE_TYPE cint;\n+  real_from_integer (&cint, VOIDmode, n, SIGNED);\n+\n+  if (!real_identical (&whole_part, &cint))\n+    return NULL_TREE;\n+\n+  if (powi_cost (n) + synth_info.num_mults > POWI_MAX_MULTS)\n+    return NULL_TREE;\n+\n+  memset (cache, 0, (max_depth + 1) * sizeof (tree));\n+\n+  tree integer_res = n == 0 ? build_real (type, dconst1) : arg0;\n+\n+  /* Calculate the integer part of the exponent.  */\n+  if (n > 1)\n+    {\n+      integer_res = gimple_expand_builtin_powi (gsi, loc, arg0, n);\n+      if (!integer_res)\n+\treturn NULL_TREE;\n+    }\n+\n+  if (dump_file)\n+    {\n+      char string[64];\n+\n+      real_to_decimal (string, &exp_init, sizeof (string), 0, 1);\n+      fprintf (dump_file, \"synthesizing pow (x, %s) as:\\n\", string);\n+\n+      if (neg_exp)\n+\t{\n+\t  if (one_over)\n+\t    {\n+\t      fprintf (dump_file, \"1.0 / (\");\n+\t      dump_integer_part (dump_file, \"x\", n);\n+\t      if (n > 0)\n+\t        fprintf (dump_file, \" * \");\n+\t      dump_fractional_sqrt_sequence (dump_file, \"x\", &synth_info);\n+\t      fprintf (dump_file, \")\");\n+\t    }\n+\t  else\n+\t    {\n+\t      dump_fractional_sqrt_sequence (dump_file, \"x\", &synth_info);\n+\t      fprintf (dump_file, \" / (\");\n+\t      dump_integer_part (dump_file, \"x\", n);\n+\t      fprintf (dump_file, \")\");\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  dump_fractional_sqrt_sequence (dump_file, \"x\", &synth_info);\n+\t  if (n > 0)\n+\t    fprintf (dump_file, \" * \");\n+\t  dump_integer_part (dump_file, \"x\", n);\n+\t}\n+\n+      fprintf (dump_file, \"\\ndeepest sqrt chain: %d\\n\", synth_info.deepest);\n+    }\n+\n+\n+  tree fract_res = NULL_TREE;\n+  cache[0] = arg0;\n+\n+  /* Calculate the fractional part of the exponent.  */\n+  for (unsigned i = 0; i < synth_info.deepest; i++)\n+    {\n+      if (synth_info.factors[i])\n+\t{\n+\t  tree sqrt_chain = get_fn_chain (arg0, i + 1, gsi, sqrtfn, loc, cache);\n+\n+\t  if (!fract_res)\n+\t      fract_res = sqrt_chain;\n+\n+\t  else\n+\t    fract_res = build_and_insert_binop (gsi, loc, \"powroot\", MULT_EXPR,\n+\t\t\t\t\t   fract_res, sqrt_chain);\n+\t}\n+    }\n+\n+  tree res = NULL_TREE;\n+\n+  if (neg_exp)\n+    {\n+      if (one_over)\n+\t{\n+\t  if (n > 0)\n+\t    res = build_and_insert_binop (gsi, loc, \"powroot\", MULT_EXPR,\n+\t\t\t\t\t   fract_res, integer_res);\n+\t  else\n+\t    res = fract_res;\n+\n+\t  res = build_and_insert_binop (gsi, loc, \"powrootrecip\", RDIV_EXPR,\n+\t\t\t\t\t  build_real (type, dconst1), res);\n+\t}\n+      else\n+\t{\n+\t  res = build_and_insert_binop (gsi, loc, \"powroot\", RDIV_EXPR,\n+\t\t\t\t\t fract_res, integer_res);\n+\t}\n+    }\n+  else\n+    res = build_and_insert_binop (gsi, loc, \"powroot\", MULT_EXPR,\n+\t\t\t\t   fract_res, integer_res);\n+  return res;\n+}\n+\n /* ARG0 and ARG1 are the two arguments to a pow builtin call in GSI\n    with location info LOC.  If possible, create an equivalent and\n    less expensive sequence of statements prior to GSI, and return an\n@@ -1157,13 +1509,17 @@ static tree\n gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc, \n \t\t\t   tree arg0, tree arg1)\n {\n-  REAL_VALUE_TYPE c, cint, dconst1_4, dconst3_4, dconst1_3, dconst1_6;\n+  REAL_VALUE_TYPE c, cint, dconst1_3, dconst1_4, dconst1_6;\n   REAL_VALUE_TYPE c2, dconst3;\n   HOST_WIDE_INT n;\n-  tree type, sqrtfn, cbrtfn, sqrt_arg0, sqrt_sqrt, result, cbrt_x, powi_cbrt_x;\n+  tree type, sqrtfn, cbrtfn, sqrt_arg0, result, cbrt_x, powi_cbrt_x;\n   machine_mode mode;\n+  bool speed_p = optimize_bb_for_speed_p (gsi_bb (*gsi));\n   bool hw_sqrt_exists, c_is_int, c2_is_int;\n \n+  dconst1_4 = dconst1;\n+  SET_REAL_EXP (&dconst1_4, REAL_EXP (&dconst1_4) - 2);\n+\n   /* If the exponent isn't a constant, there's nothing of interest\n      to be done.  */\n   if (TREE_CODE (arg1) != REAL_CST)\n@@ -1179,7 +1535,7 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n   if (c_is_int\n       && ((n >= -1 && n <= 2)\n \t  || (flag_unsafe_math_optimizations\n-\t      && optimize_bb_for_speed_p (gsi_bb (*gsi))\n+\t      && speed_p\n \t      && powi_cost (n) <= POWI_MAX_MULTS)))\n     return gimple_expand_builtin_powi (gsi, loc, arg0, n);\n \n@@ -1196,49 +1552,8 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n       && !HONOR_SIGNED_ZEROS (mode))\n     return build_and_insert_call (gsi, loc, sqrtfn, arg0);\n \n-  /* Optimize pow(x,0.25) = sqrt(sqrt(x)).  Assume on most machines that\n-     a builtin sqrt instruction is smaller than a call to pow with 0.25,\n-     so do this optimization even if -Os.  Don't do this optimization\n-     if we don't have a hardware sqrt insn.  */\n-  dconst1_4 = dconst1;\n-  SET_REAL_EXP (&dconst1_4, REAL_EXP (&dconst1_4) - 2);\n   hw_sqrt_exists = optab_handler (sqrt_optab, mode) != CODE_FOR_nothing;\n \n-  if (flag_unsafe_math_optimizations\n-      && sqrtfn\n-      && REAL_VALUES_EQUAL (c, dconst1_4)\n-      && hw_sqrt_exists)\n-    {\n-      /* sqrt(x)  */\n-      sqrt_arg0 = build_and_insert_call (gsi, loc, sqrtfn, arg0);\n-\n-      /* sqrt(sqrt(x))  */\n-      return build_and_insert_call (gsi, loc, sqrtfn, sqrt_arg0);\n-    }\n-      \n-  /* Optimize pow(x,0.75) = sqrt(x) * sqrt(sqrt(x)) unless we are\n-     optimizing for space.  Don't do this optimization if we don't have\n-     a hardware sqrt insn.  */\n-  real_from_integer (&dconst3_4, VOIDmode, 3, SIGNED);\n-  SET_REAL_EXP (&dconst3_4, REAL_EXP (&dconst3_4) - 2);\n-\n-  if (flag_unsafe_math_optimizations\n-      && sqrtfn\n-      && optimize_function_for_speed_p (cfun)\n-      && REAL_VALUES_EQUAL (c, dconst3_4)\n-      && hw_sqrt_exists)\n-    {\n-      /* sqrt(x)  */\n-      sqrt_arg0 = build_and_insert_call (gsi, loc, sqrtfn, arg0);\n-\n-      /* sqrt(sqrt(x))  */\n-      sqrt_sqrt = build_and_insert_call (gsi, loc, sqrtfn, sqrt_arg0);\n-\n-      /* sqrt(x) * sqrt(sqrt(x))  */\n-      return build_and_insert_binop (gsi, loc, \"powroot\", MULT_EXPR,\n-\t\t\t\t     sqrt_arg0, sqrt_sqrt);\n-    }\n-\n   /* Optimize pow(x,1./3.) = cbrt(x).  This requires unsafe math\n      optimizations since 1./3. is not exactly representable.  If x\n      is negative and finite, the correct value of pow(x,1./3.) is\n@@ -1263,7 +1578,7 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n       && sqrtfn\n       && cbrtfn\n       && (gimple_val_nonnegative_real_p (arg0) || !HONOR_NANS (mode))\n-      && optimize_function_for_speed_p (cfun)\n+      && speed_p\n       && hw_sqrt_exists\n       && REAL_VALUES_EQUAL (c, dconst1_6))\n     {\n@@ -1274,54 +1589,31 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n       return build_and_insert_call (gsi, loc, cbrtfn, sqrt_arg0);\n     }\n \n-  /* Optimize pow(x,c), where n = 2c for some nonzero integer n\n-     and c not an integer, into\n-\n-       sqrt(x) * powi(x, n/2),                n > 0;\n-       1.0 / (sqrt(x) * powi(x, abs(n/2))),   n < 0.\n-\n-     Do not calculate the powi factor when n/2 = 0.  */\n-  real_arithmetic (&c2, MULT_EXPR, &c, &dconst2);\n-  n = real_to_integer (&c2);\n-  real_from_integer (&cint, VOIDmode, n, SIGNED);\n-  c2_is_int = real_identical (&c2, &cint);\n \n+  /* Attempt to expand the POW as a product of square root chains.\n+     Expand the 0.25 case even when otpimising for size.  */\n   if (flag_unsafe_math_optimizations\n       && sqrtfn\n-      && c2_is_int\n-      && !c_is_int\n-      && optimize_function_for_speed_p (cfun))\n+      && hw_sqrt_exists\n+      && (speed_p || REAL_VALUES_EQUAL (c, dconst1_4))\n+      && !HONOR_SIGNED_ZEROS (mode))\n     {\n-      tree powi_x_ndiv2 = NULL_TREE;\n-\n-      /* Attempt to fold powi(arg0, abs(n/2)) into multiplies.  If not\n-         possible or profitable, give up.  Skip the degenerate case when\n-         n is 1 or -1, where the result is always 1.  */\n-      if (absu_hwi (n) != 1)\n-\t{\n-\t  powi_x_ndiv2 = gimple_expand_builtin_powi (gsi, loc, arg0,\n-\t\t\t\t\t\t     abs_hwi (n / 2));\n-\t  if (!powi_x_ndiv2)\n-\t    return NULL_TREE;\n-\t}\n+      unsigned int max_depth = speed_p\n+\t\t\t\t? PARAM_VALUE (PARAM_MAX_POW_SQRT_DEPTH)\n+\t\t\t\t: 2;\n \n-      /* Calculate sqrt(x).  When n is not 1 or -1, multiply it by the\n-\t result of the optimal multiply sequence just calculated.  */\n-      sqrt_arg0 = build_and_insert_call (gsi, loc, sqrtfn, arg0);\n+      tree expand_with_sqrts\n+\t= expand_pow_as_sqrts (gsi, loc, arg0, arg1, max_depth);\n \n-      if (absu_hwi (n) == 1)\n-\tresult = sqrt_arg0;\n-      else\n-\tresult = build_and_insert_binop (gsi, loc, \"powroot\", MULT_EXPR,\n-\t\t\t\t\t sqrt_arg0, powi_x_ndiv2);\n-\n-      /* If n is negative, reciprocate the result.  */\n-      if (n < 0)\n-\tresult = build_and_insert_binop (gsi, loc, \"powroot\", RDIV_EXPR,\n-\t\t\t\t\t build_real (type, dconst1), result);\n-      return result;\n+      if (expand_with_sqrts)\n+\treturn expand_with_sqrts;\n     }\n \n+  real_arithmetic (&c2, MULT_EXPR, &c, &dconst2);\n+  n = real_to_integer (&c2);\n+  real_from_integer (&cint, VOIDmode, n, SIGNED);\n+  c2_is_int = real_identical (&c2, &cint);\n+\n   /* Optimize pow(x,c), where 3c = n for some nonzero integer n, into\n \n      powi(x, n/3) * powi(cbrt(x), n%3),                    n > 0;"}]}