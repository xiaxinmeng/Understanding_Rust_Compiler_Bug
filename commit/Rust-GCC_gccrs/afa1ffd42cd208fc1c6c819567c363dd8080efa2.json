{"sha": "afa1ffd42cd208fc1c6c819567c363dd8080efa2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZhMWZmZDQyY2QyMDhmYzFjNmM4MTk1NjdjMzYzZGQ4MDgwZWZhMg==", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2020-07-13T10:42:18Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-20T07:21:28Z"}, "message": "[Ada] Support for new aspect Subprogram_Variant on recursive subprograms\n\ngcc/ada/\n\n\t* aspects.ads: Introduce Subprogram_Variant aspect with the\n\tfollowing properties: GNAT-specific, with mandatory expression,\n\tnot a representation aspect, never delayed.\n\t* contracts.adb (Expand_Subprogram_Contract): Mention new aspect\n\tin the comment.\n\t(Add_Contract_Item): Support addition of pragma\n\tSubprogram_Variant to N_Contract node.\n\t(Analyze_Entry_Or_Subprogram_Contract): Mention new aspect in\n\tthe comment; add pragma Subprogram_Variant to N_Contract node.\n\t(Build_Postconditions_Procedure): Adapt call to\n\tInsert_Before_First_Source_Declaration, which is now reused in\n\texpansion of new aspect.\n\t(Process_Contract_Cases_For): Also process Subprogram_Variant,\n\twhich is stored in N_Contract node together with Contract_Cases.\n\t* contracts.ads (Analyze_Entry_Or_Subprogram_Contract): Mention\n\tnew aspect in the comment.\n\t(Analyze_Entry_Or_Subprogram_Body_Contract): Likewise.\n\t* einfo.adb (Get_Pragma): Support retrieval of new pragma.\n\t* einfo.ads (Get_Pragma): Likewise.\n\t* exp_ch6.adb (Check_Subprogram_Variant): New routine for\n\temitting call to check Subprogram_Variant expressions at run\n\ttime.\n\t(Expand_Call_Helper): Check Subprogram_Variant expressions at\n\trecursive calls.\n\t* exp_prag.adb (Make_Op): Moved from expansion of pragma\n\tLoop_Variant to Exp_Util, so it is now reused for expansion of\n\tpragma Subprogram_Variant.\n\t(Process_Variant): Adapt call to Make_Op after moving it to\n\tExp_Util.\n\t(Expand_Pragma_Subprogram_Variant): New routine.\n\t* exp_prag.ads (Expand_Pragma_Subprogram_Variant): Likewise.\n\t* exp_util.adb (Make_Variant_Comparison): Moved from Exp_Prag\n\t(see above).\n\t* exp_util.ads (Make_Variant_Comparison): Likewise.\n\t* inline.adb (Remove_Aspects_And_Pragmas): Handle aspect/pragma\n\tSubprogram_Variant just like similar contracts.\n\t* par-prag.adb (Prag): Likewise.\n\t* sem.adb (Insert_Before_First_Source_Declaration): Moved from\n\tContracts (see above).\n\t* sem.ads (Insert_Before_First_Source_Declaration): Likewise.\n\t* sem_ch12.adb: Mention new aspect in the comment about\n\t\"Implementation of Generic Contracts\", just like similar aspects\n\tare mentioned there.\n\t* sem_ch13.adb (Insert_Pragma): Mention new aspect in the\n\tcomment, because this routine is now used for Subprogram_Variant\n\tjust like for other similar aspects.\n\t(Analyze_Aspect_Specifications): Mention new aspect in comments;\n\tit is handled just like aspect Contract_Cases.\n\t(Check_Aspect_At_Freeze_Point): Do not expect aspect\n\tSubprogram_Variant just like we don't expect aspect\n\tContract_Cases.\n\t* sem_prag.adb (Ensure_Aggregate_Form): Now also used for pragma\n\tSubprogram_Variant, so update comment.\n\t(Analyze_Pragma): Add initial checks for pragma\n\tSubprogram_Variant.\n\t(Analyze_Subprogram_Variant_In_Decl_Part): New routine with\n\tsecondary checks on the new pragma.\n\t(Sig_Flags): Handle references within pragma Subprogram_Variant\n\texpression just like references in similar pragma\n\tContract_Cases.\n\t(Is_Valid_Assertion_Kind): Handle Subprogram_Variant just like\n\tother similar contracts.\n\t* sem_prag.ads (Analyze_Subprogram_Variant_In_Decl_Part): New\n\troutine.\n\t* sem_res.adb (Same_Or_Aliased_Subprograms): Moved to Sem_Util,\n\tso it can be reused for detection of recursive calls where\n\tSubprogram_Variant needs to be verified.\n\t* sem_util.adb (Is_Subprogram_Contract_Annotation): Handle new\n\tSubprogram_Variant annotation just like other similar\n\tannotations.\n\t(Same_Or_Aliased_Subprograms): Moved from Sem_Res (see above).\n\t* sem_util.ads (Is_Subprogram_Contract_Annotation): Mention new\n\taspect in the comment.\n\t(Same_Or_Aliased_Subprograms): Moved from Sem_Res (see above).\n\t* sinfo.ads (N_Contract): Document handling of\n\tSubprogram_Variant.\n\t* snames.ads-tmpl: Add name for the internally generated\n\tprocedure with checks for Subprogram_Variant expression, name\n\tfor the new aspect and new pragma corresponding to aspect\n\tSubprogram_Variant.", "tree": {"sha": "0c3d58b77acc62b511f160449849d48056f086b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c3d58b77acc62b511f160449849d48056f086b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afa1ffd42cd208fc1c6c819567c363dd8080efa2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afa1ffd42cd208fc1c6c819567c363dd8080efa2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afa1ffd42cd208fc1c6c819567c363dd8080efa2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afa1ffd42cd208fc1c6c819567c363dd8080efa2/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87eb6d2c2a9a9fbea23b91c01fa64fcf1f3825df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87eb6d2c2a9a9fbea23b91c01fa64fcf1f3825df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87eb6d2c2a9a9fbea23b91c01fa64fcf1f3825df"}], "stats": {"total": 975, "additions": 845, "deletions": 130}, "files": [{"sha": "d8931004fda15896e799c9a43bc329d1ea0d548f", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -153,6 +153,7 @@ package Aspects is\n       Aspect_Storage_Size,\n       Aspect_Stream_Size,\n       Aspect_String_Literal,\n+      Aspect_Subprogram_Variant,            -- GNAT\n       Aspect_Suppress,\n       Aspect_Synchronization,\n       Aspect_Test_Case,                     -- GNAT\n@@ -426,6 +427,7 @@ package Aspects is\n       Aspect_Storage_Size               => Expression,\n       Aspect_Stream_Size                => Expression,\n       Aspect_String_Literal             => Name,\n+      Aspect_Subprogram_Variant         => Expression,\n       Aspect_Suppress                   => Name,\n       Aspect_Synchronization            => Name,\n       Aspect_Test_Case                  => Expression,\n@@ -526,6 +528,7 @@ package Aspects is\n       Aspect_Storage_Size                 => True,\n       Aspect_Stream_Size                  => True,\n       Aspect_String_Literal               => False,\n+      Aspect_Subprogram_Variant           => False,\n       Aspect_Suppress                     => False,\n       Aspect_Synchronization              => False,\n       Aspect_Test_Case                    => False,\n@@ -700,6 +703,7 @@ package Aspects is\n       Aspect_Storage_Size                 => Name_Storage_Size,\n       Aspect_Stream_Size                  => Name_Stream_Size,\n       Aspect_String_Literal               => Name_String_Literal,\n+      Aspect_Subprogram_Variant           => Name_Subprogram_Variant,\n       Aspect_Suppress                     => Name_Suppress,\n       Aspect_Suppress_Debug_Info          => Name_Suppress_Debug_Info,\n       Aspect_Suppress_Initialization      => Name_Suppress_Initialization,\n@@ -955,6 +959,7 @@ package Aspects is\n       Aspect_Relaxed_Initialization       => Never_Delay,\n       Aspect_SPARK_Mode                   => Never_Delay,\n       Aspect_Static                       => Never_Delay,\n+      Aspect_Subprogram_Variant           => Never_Delay,\n       Aspect_Synchronization              => Never_Delay,\n       Aspect_Test_Case                    => Never_Delay,\n       Aspect_Unimplemented                => Never_Delay,"}, {"sha": "e633e19c1d84822e7c078903fff753f7683340b8", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 28, "deletions": 59, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -69,8 +69,8 @@ package body Contracts is\n    procedure Expand_Subprogram_Contract (Body_Id : Entity_Id);\n    --  Expand the contracts of a subprogram body and its correspoding spec (if\n    --  any). This routine processes all [refined] pre- and postconditions as\n-   --  well as Contract_Cases, invariants and predicates. Body_Id denotes the\n-   --  entity of the subprogram body.\n+   --  well as Contract_Cases, Subprogram_Variant, invariants and predicates.\n+   --  Body_Id denotes the entity of the subprogram body.\n \n    -----------------------\n    -- Add_Contract_Item --\n@@ -200,7 +200,10 @@ package body Contracts is\n          then\n             Add_Classification;\n \n-         elsif Prag_Nam in Name_Contract_Cases | Name_Test_Case then\n+         elsif Prag_Nam in Name_Contract_Cases\n+                         | Name_Subprogram_Variant\n+                         | Name_Test_Case\n+         then\n             Add_Contract_Test_Case;\n \n          elsif Prag_Nam in Name_Postcondition | Name_Precondition then\n@@ -550,8 +553,8 @@ package body Contracts is\n       end if;\n \n       --  Deal with preconditions, [refined] postconditions, Contract_Cases,\n-      --  invariants and predicates associated with body and its spec. Do not\n-      --  expand the contract of subprogram body stubs.\n+      --  Subprogram_Variant, invariants and predicates associated with body\n+      --  and its spec. Do not expand the contract of subprogram body stubs.\n \n       if Nkind (Body_Decl) = N_Subprogram_Body then\n          Expand_Subprogram_Contract (Body_Id);\n@@ -686,6 +689,10 @@ package body Contracts is\n                else\n                   Analyze_Contract_Cases_In_Decl_Part (Prag, Freeze_Id);\n                end if;\n+\n+            elsif Prag_Nam = Name_Subprogram_Variant then\n+               Analyze_Subprogram_Variant_In_Decl_Part (Prag);\n+\n             else\n                pragma Assert (Prag_Nam = Name_Test_Case);\n                Analyze_Test_Case_In_Decl_Part (Prag);\n@@ -1941,58 +1948,13 @@ package body Contracts is\n          Stmts   : List_Id;\n          Result  : Entity_Id)\n       is\n-         procedure Insert_Before_First_Source_Declaration (Stmt : Node_Id);\n-         --  Insert node Stmt before the first source declaration of the\n-         --  related subprogram's body. If no such declaration exists, Stmt\n-         --  becomes the last declaration.\n-\n-         --------------------------------------------\n-         -- Insert_Before_First_Source_Declaration --\n-         --------------------------------------------\n-\n-         procedure Insert_Before_First_Source_Declaration (Stmt : Node_Id) is\n-            Decls : constant List_Id := Declarations (Body_Decl);\n-            Decl  : Node_Id;\n-\n-         begin\n-            --  Inspect the declarations of the related subprogram body looking\n-            --  for the first source declaration.\n-\n-            if Present (Decls) then\n-               Decl := First (Decls);\n-               while Present (Decl) loop\n-                  if Comes_From_Source (Decl) then\n-                     Insert_Before (Decl, Stmt);\n-                     return;\n-                  end if;\n-\n-                  Next (Decl);\n-               end loop;\n-\n-               --  If we get there, then the subprogram body lacks any source\n-               --  declarations. The body of _Postconditions now acts as the\n-               --  last declaration.\n-\n-               Append (Stmt, Decls);\n-\n-            --  Ensure that the body has a declaration list\n-\n-            else\n-               Set_Declarations (Body_Decl, New_List (Stmt));\n-            end if;\n-         end Insert_Before_First_Source_Declaration;\n-\n-         --  Local variables\n-\n          Loc       : constant Source_Ptr := Sloc (Body_Decl);\n          Params    : List_Id := No_List;\n          Proc_Bod  : Node_Id;\n          Proc_Decl : Node_Id;\n          Proc_Id   : Entity_Id;\n          Proc_Spec : Node_Id;\n \n-      --  Start of processing for Build_Postconditions_Procedure\n-\n       begin\n          --  Nothing to do if there are no actions to check on exit\n \n@@ -2051,7 +2013,8 @@ package body Contracts is\n          --  order reference. The body of _Postconditions must be placed after\n          --  the declaration of Temp to preserve correct visibility.\n \n-         Insert_Before_First_Source_Declaration (Proc_Decl);\n+         Insert_Before_First_Source_Declaration\n+           (Proc_Decl, Declarations (Body_Decl));\n          Analyze (Proc_Decl);\n \n          --  Set an explicit End_Label to override the sloc of the implicit\n@@ -2092,14 +2055,20 @@ package body Contracts is\n             if Present (Items) then\n                Prag := Contract_Test_Cases (Items);\n                while Present (Prag) loop\n-                  if Pragma_Name (Prag) = Name_Contract_Cases\n-                    and then Is_Checked (Prag)\n-                  then\n-                     Expand_Pragma_Contract_Cases\n-                       (CCs     => Prag,\n-                        Subp_Id => Subp_Id,\n-                        Decls   => Declarations (Body_Decl),\n-                        Stmts   => Stmts);\n+                  if Is_Checked (Prag) then\n+                     if Pragma_Name (Prag) = Name_Contract_Cases then\n+                        Expand_Pragma_Contract_Cases\n+                          (CCs     => Prag,\n+                           Subp_Id => Subp_Id,\n+                           Decls   => Declarations (Body_Decl),\n+                           Stmts   => Stmts);\n+\n+                     elsif Pragma_Name (Prag) = Name_Subprogram_Variant then\n+                        Expand_Pragma_Subprogram_Variant\n+                          (Prag       => Prag,\n+                           Subp_Id    => Subp_Id,\n+                           Body_Decls => Declarations (Body_Decl));\n+                     end if;\n                   end if;\n \n                   Prag := Next_Pragma (Prag);"}, {"sha": "4782ef59cb2c78fc95a9e225343886eb69d32e13", "filename": "gcc/ada/contracts.ads", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fcontracts.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fcontracts.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.ads?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -69,15 +69,16 @@ package Contracts is\n    --  subprogram body Body_Id as if they appeared at the end of a declarative\n    --  region. Pragmas in question are:\n    --\n-   --    Contract_Cases   (stand alone subprogram body)\n-   --    Depends          (stand alone subprogram body)\n-   --    Global           (stand alone subprogram body)\n-   --    Postcondition    (stand alone subprogram body)\n-   --    Precondition     (stand alone subprogram body)\n+   --    Contract_Cases     (stand alone subprogram body)\n+   --    Depends            (stand alone subprogram body)\n+   --    Global             (stand alone subprogram body)\n+   --    Postcondition      (stand alone subprogram body)\n+   --    Precondition       (stand alone subprogram body)\n    --    Refined_Depends\n    --    Refined_Global\n    --    Refined_Post\n-   --    Test_Case        (stand alone subprogram body)\n+   --    Subprogram_Variant (stand alone subprogram body)\n+   --    Test_Case          (stand alone subprogram body)\n \n    procedure Analyze_Entry_Or_Subprogram_Contract\n      (Subp_Id   : Entity_Id;\n@@ -91,6 +92,7 @@ package Contracts is\n    --    Global\n    --    Postcondition\n    --    Precondition\n+   --    Subprogram_Variant\n    --    Test_Case\n    --\n    --  Freeze_Id is the entity of a [generic] package body or a [generic]"}, {"sha": "f1cdb19656381967aef3edaffa5fe0865458019d", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -7660,10 +7660,11 @@ package body Einfo is\n                  Id = Pragma_Refined_State              or else\n                  Id = Pragma_Volatile_Function;\n \n-      --  Contract / test case pragmas\n+      --  Contract / subprogram variant / test case pragmas\n \n       Is_CTC : constant Boolean :=\n                   Id = Pragma_Contract_Cases            or else\n+                  Id = Pragma_Subprogram_Variant        or else\n                   Id = Pragma_Test_Case;\n \n       --  Pre / postcondition pragmas"}, {"sha": "c60c070224c828c0e59165e5543b5643cae9e644", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -8521,6 +8521,7 @@ package Einfo is\n    --    Refined_Global\n    --    Refined_Post\n    --    Refined_State\n+   --    Subprogram_Variant\n    --    Test_Case\n    --    Volatile_Function\n "}, {"sha": "5d8e48bcc5c8803cfe009460a232fbb5704e2634", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -2800,6 +2800,10 @@ package body Exp_Ch6 is\n       --  though useless predicate checks will be generally removed by\n       --  back-end optimizations.\n \n+      procedure Check_Subprogram_Variant;\n+      --  Emit a call to the internally generated procedure with checks for\n+      --  aspect Subprogrgram_Variant, if present and enabled.\n+\n       function Inherited_From_Formal (S : Entity_Id) return Entity_Id;\n       --  Within an instance, a type derived from an untagged formal derived\n       --  type inherits from the original parent, not from the actual. The\n@@ -3058,6 +3062,37 @@ package body Exp_Ch6 is\n          end if;\n       end Can_Fold_Predicate_Call;\n \n+      ------------------------------\n+      -- Check_Subprogram_Variant --\n+      ------------------------------\n+\n+      procedure Check_Subprogram_Variant is\n+         Variant_Prag : constant Node_Id :=\n+           Get_Pragma (Current_Scope, Pragma_Subprogram_Variant);\n+\n+         Variant_Proc : Entity_Id;\n+\n+      begin\n+         if Present (Variant_Prag) and then Is_Checked (Variant_Prag) then\n+\n+            --  Analysis of the pragma rewrites its argument with a reference\n+            --  to the internally generated procedure.\n+\n+            Variant_Proc :=\n+              Entity\n+                (Expression\n+                   (First\n+                      (Pragma_Argument_Associations (Variant_Prag))));\n+\n+            Insert_Action (Call_Node,\n+              Make_Procedure_Call_Statement (Loc,\n+                 Name                   =>\n+                   New_Occurrence_Of (Variant_Proc, Loc),\n+                 Parameter_Associations =>\n+                   New_Copy_List (Parameter_Associations (Call_Node))));\n+         end if;\n+      end Check_Subprogram_Variant;\n+\n       ---------------------------\n       -- Inherited_From_Formal --\n       ---------------------------\n@@ -4650,6 +4685,18 @@ package body Exp_Ch6 is\n \n       Expand_Actuals (Call_Node, Subp, Post_Call);\n \n+      --  If it is a recursive call then call the internal procedure that\n+      --  verifies Subprogram_Variant contract (if present and enabled).\n+      --  Detecting calls to subprogram aliases is necessary for recursive\n+      --  calls in instances of generic subprograms, where the renaming of\n+      --  the current subprogram is called.\n+\n+      if Is_Subprogram (Subp)\n+        and then Same_Or_Aliased_Subprograms (Subp, Current_Scope)\n+      then\n+         Check_Subprogram_Variant;\n+      end if;\n+\n       --  Verify that the actuals do not share storage. This check must be done\n       --  on the caller side rather that inside the subprogram to avoid issues\n       --  of parameter passing."}, {"sha": "f4b15fa251cdb3328a607e69d79a67747087daa6", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 334, "deletions": 29, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -2321,32 +2321,6 @@ package body Exp_Prag is\n       ---------------------\n \n       procedure Process_Variant (Variant : Node_Id; Is_Last : Boolean) is\n-         function Make_Op\n-           (Loc      : Source_Ptr;\n-            Curr_Val : Node_Id;\n-            Old_Val  : Node_Id) return Node_Id;\n-         --  Generate a comparison between Curr_Val and Old_Val depending on\n-         --  the change mode (Increases / Decreases) of the variant.\n-\n-         -------------\n-         -- Make_Op --\n-         -------------\n-\n-         function Make_Op\n-           (Loc      : Source_Ptr;\n-            Curr_Val : Node_Id;\n-            Old_Val  : Node_Id) return Node_Id\n-         is\n-         begin\n-            if Chars (Variant) = Name_Increases then\n-               return Make_Op_Gt (Loc, Curr_Val, Old_Val);\n-            else pragma Assert (Chars (Variant) = Name_Decreases);\n-               return Make_Op_Lt (Loc, Curr_Val, Old_Val);\n-            end if;\n-         end Make_Op;\n-\n-         --  Local variables\n-\n          Expr     : constant Node_Id    := Expression (Variant);\n          Expr_Typ : constant Entity_Id  := Etype (Expr);\n          Loc      : constant Source_Ptr := Sloc (Expr);\n@@ -2355,8 +2329,6 @@ package body Exp_Prag is\n          Old_Id   : Entity_Id;\n          Prag     : Node_Id;\n \n-      --  Start of processing for Process_Variant\n-\n       begin\n          --  All temporaries generated in this routine must be inserted before\n          --  the related loop statement. Ensure that the proper scope is on the\n@@ -2467,7 +2439,8 @@ package body Exp_Prag is\n                  Expression => Make_Identifier (Loc, Name_Loop_Variant)),\n                Make_Pragma_Argument_Association (Loc,\n                  Expression =>\n-                   Make_Op (Loc,\n+                   Make_Variant_Comparison (Loc,\n+                     Mode     => Chars (Variant),\n                      Curr_Val => New_Occurrence_Of (Curr_Id, Loc),\n                      Old_Val  => New_Occurrence_Of (Old_Id, Loc)))));\n \n@@ -2650,6 +2623,338 @@ package body Exp_Prag is\n       end if;\n    end Expand_Pragma_Relative_Deadline;\n \n+   --------------------------------------\n+   -- Expand_Pragma_Subprogram_Variant --\n+   --------------------------------------\n+\n+   --  Aspect Subprogram_Variant is expanded in the following manner:\n+\n+   --  Original code\n+\n+   --     procedure Proc (Param : T) with\n+   --        with Variant (Increases => Incr_Expr,\n+   --                      Decreases => Decr_Expr)\n+   --        <declarations>\n+   --     is\n+   --        <source statements>\n+   --        Proc (New_Param_Value);\n+   --     end Proc;\n+\n+   --  Expanded code\n+\n+   --     procedure Proc (Param : T) is\n+   --        Old_Incr : constant <type of Incr_Expr> := <Incr_Expr>;\n+   --        Old_Decr : constant <type of Decr_Expr> := <Decr_Expr> ;\n+   --\n+   --        procedure Variants (Param : T);\n+   --\n+   --        procedure Variants (Param : T) is\n+   --           Curr_Incr : constant <type of Incr_Expr> := <Incr_Expr>;\n+   --           Curr_Decr : constant <type of Decr_Expr> := <Decr_Expr>;\n+   --        begin\n+   --           if Curr_Incr /= Old_Incr then\n+   --              pragma Check (Variant, Curr_Incr > Old_Incr);\n+   --           else\n+   --              pragma Check (Variant, Curr_Decr < Old_Decr);\n+   --           end if;\n+   --        end Variants;\n+   --\n+   --        <declarations>\n+   --     begin\n+   --        <source statements>\n+   --        Variants (New_Param_Value);\n+   --        Proc (New_Param_Value);\n+   --     end Proc;\n+\n+   procedure Expand_Pragma_Subprogram_Variant\n+     (Prag       : Node_Id;\n+      Subp_Id    : Node_Id;\n+      Body_Decls : List_Id)\n+   is\n+      Curr_Decls : List_Id;\n+      If_Stmt    : Node_Id := Empty;\n+\n+      function Formal_Param_Map\n+        (Old_Subp : Entity_Id;\n+         New_Subp : Entity_Id) return Elist_Id;\n+      --  Given two subprogram entities Old_Subp and New_Subp with the same\n+      --  number of formal parameters return a list of the form:\n+      --\n+      --    old formal 1\n+      --    new formal 1\n+      --    old formal 2\n+      --    new formal 2\n+      --    ...\n+      --\n+      --  as required by New_Copy_Tree to replace references to formal\n+      --  parameters of Old_Subp with references to formal parameters of\n+      --  New_Subp.\n+\n+      procedure Process_Variant\n+        (Variant    : Node_Id;\n+         Formal_Map : Elist_Id;\n+         Prev_Decl  : in out Node_Id;\n+         Is_Last    : Boolean);\n+      --  Process a single increasing / decreasing termination variant given by\n+      --  a component association Variant. Formal_Map is a list of formal\n+      --  parameters of the annotated subprogram and of the internal procedure\n+      --  that verifies the variant in the format required by New_Copy_Tree.\n+      --  The Old_... object created by this routine will be appended after\n+      --  Prev_Decl and is stored in this parameter for a next call to this\n+      --  routine. Is_Last is True when there are no more variants to process.\n+\n+      ----------------------\n+      -- Formal_Param_Map --\n+      ----------------------\n+\n+      function Formal_Param_Map\n+        (Old_Subp : Entity_Id;\n+         New_Subp : Entity_Id) return Elist_Id\n+      is\n+         Old_Formal : Entity_Id := First_Formal (Old_Subp);\n+         New_Formal : Entity_Id := First_Formal (New_Subp);\n+\n+         Param_Map : Elist_Id;\n+      begin\n+         if Present (Old_Formal) then\n+            Param_Map := New_Elmt_List;\n+            while Present (Old_Formal) and then Present (New_Formal) loop\n+               Append_Elmt (Old_Formal,  Param_Map);\n+               Append_Elmt (New_Formal, Param_Map);\n+\n+               Next_Formal (Old_Formal);\n+               Next_Formal (New_Formal);\n+            end loop;\n+\n+            return Param_Map;\n+         else\n+            return No_Elist;\n+         end if;\n+      end Formal_Param_Map;\n+\n+      ---------------------\n+      -- Process_Variant --\n+      ---------------------\n+\n+      procedure Process_Variant\n+        (Variant    : Node_Id;\n+         Formal_Map : Elist_Id;\n+         Prev_Decl  : in out Node_Id;\n+         Is_Last    : Boolean)\n+      is\n+         Expr     : constant Node_Id    := Expression (Variant);\n+         Expr_Typ : constant Entity_Id  := Etype (Expr);\n+         Loc      : constant Source_Ptr := Sloc (Expr);\n+\n+         Old_Id    : Entity_Id;\n+         Old_Decl  : Node_Id;\n+         Curr_Id   : Entity_Id;\n+         Curr_Decl : Node_Id;\n+         Prag      : Node_Id;\n+\n+      begin\n+         --  Create temporaries that store the old values of the associated\n+         --  expression.\n+\n+         --  Generate:\n+         --    Old : constant <type of Expr> := <Expr>;\n+\n+         Old_Id := Make_Temporary (Loc, 'P');\n+\n+         Old_Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Old_Id,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Occurrence_Of (Expr_Typ, Loc),\n+             Expression          => New_Copy_Tree (Expr));\n+\n+         Insert_After_And_Analyze (Prev_Decl, Old_Decl);\n+\n+         Prev_Decl := Old_Decl;\n+\n+         --  Generate:\n+         --    Curr : constant <type of Expr> := <Expr>;\n+\n+         Curr_Id := Make_Temporary (Loc, 'C');\n+\n+         Curr_Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Curr_Id,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Occurrence_Of (Expr_Typ, Loc),\n+             Expression          =>\n+               New_Copy_Tree (Expr, Map => Formal_Map));\n+\n+         Append (Curr_Decl, Curr_Decls);\n+\n+         --  Generate:\n+         --    pragma Check (Variant, Curr <|> Old);\n+\n+         Prag :=\n+           Make_Pragma (Loc,\n+             Chars                        => Name_Check,\n+             Pragma_Argument_Associations => New_List (\n+               Make_Pragma_Argument_Association (Loc,\n+                 Expression =>\n+                   Make_Identifier (Loc,\n+                     Name_Subprogram_Variant)),\n+               Make_Pragma_Argument_Association (Loc,\n+                 Expression =>\n+                   Make_Variant_Comparison (Loc,\n+                     Mode     => Chars (First (Choices (Variant))),\n+                     Curr_Val => New_Occurrence_Of (Curr_Id, Loc),\n+                     Old_Val  => New_Occurrence_Of (Old_Id, Loc)))));\n+\n+         --  Generate:\n+         --    if Curr /= Old then\n+         --       <Prag>;\n+\n+         if No (If_Stmt) then\n+\n+            --  When there is just one termination variant, do not compare\n+            --  the old and current value for equality, just check the\n+            --  pragma.\n+\n+            if Is_Last then\n+               If_Stmt := Prag;\n+            else\n+               If_Stmt :=\n+                 Make_If_Statement (Loc,\n+                   Condition       =>\n+                     Make_Op_Ne (Loc,\n+                       Left_Opnd  => New_Occurrence_Of (Curr_Id, Loc),\n+                       Right_Opnd => New_Occurrence_Of (Old_Id, Loc)),\n+                   Then_Statements => New_List (Prag));\n+            end if;\n+\n+            --  Generate:\n+            --    else\n+            --       <Prag>;\n+            --    end if;\n+\n+         elsif Is_Last then\n+            Set_Else_Statements (If_Stmt, New_List (Prag));\n+\n+            --  Generate:\n+            --    elsif Curr /= Old then\n+            --       <Prag>;\n+\n+         else\n+            if Elsif_Parts (If_Stmt) = No_List then\n+               Set_Elsif_Parts (If_Stmt, New_List);\n+            end if;\n+\n+            Append_To (Elsif_Parts (If_Stmt),\n+              Make_Elsif_Part (Loc,\n+              Condition       =>\n+              Make_Op_Ne (Loc,\n+                Left_Opnd  => New_Occurrence_Of (Curr_Id, Loc),\n+                Right_Opnd => New_Occurrence_Of (Old_Id, Loc)),\n+              Then_Statements => New_List (Prag)));\n+         end if;\n+      end Process_Variant;\n+\n+      --  Local variables\n+\n+      Loc : constant Source_Ptr := Sloc (Prag);\n+\n+      Aggr         : Node_Id;\n+      Formal_Map   : Elist_Id;\n+      Last         : Node_Id;\n+      Last_Variant : Node_Id;\n+      Proc_Bod     : Node_Id;\n+      Proc_Decl    : Node_Id;\n+      Proc_Id      : Entity_Id;\n+      Proc_Spec    : Node_Id;\n+      Variant      : Node_Id;\n+\n+   begin\n+      --  Do nothing if pragma is not present or is disabled\n+\n+      if Is_Ignored (Prag) then\n+         return;\n+      end if;\n+\n+      Aggr := Expression (First (Pragma_Argument_Associations (Prag)));\n+\n+      --  The expansion of Subprogram Variant is quite distributed as it\n+      --  produces various statements to capture and compare the arguments.\n+      --  To preserve the original context, set the Is_Assertion_Expr flag.\n+      --  This aids the Ghost legality checks when verifying the placement\n+      --  of a reference to a Ghost entity.\n+\n+      In_Assertion_Expr := In_Assertion_Expr + 1;\n+\n+      --  Create declaration of the procedure that compares values of the\n+      --  variant expressions captured at the start of subprogram with their\n+      --  values at the recursive call of the subprogram.\n+\n+      Proc_Id := Make_Defining_Identifier (Loc, Name_uVariants);\n+\n+      Proc_Spec :=\n+        Make_Procedure_Specification\n+          (Loc,\n+           Defining_Unit_Name       => Proc_Id,\n+           Parameter_Specifications => Copy_Parameter_List (Subp_Id));\n+\n+      Proc_Decl :=\n+        Make_Subprogram_Declaration (Loc, Proc_Spec);\n+\n+      Insert_Before_First_Source_Declaration (Proc_Decl, Body_Decls);\n+      Analyze (Proc_Decl);\n+\n+      --  Create a mapping between formals of the annotated subprogram (which\n+      --  are used to compute values of the variant expression at the start of\n+      --  subprogram) and formals of the internal procedure (which are used to\n+      --  compute values of of the variant expression at the recursive call).\n+\n+      Formal_Map :=\n+        Formal_Param_Map (Old_Subp => Subp_Id, New_Subp => Proc_Id);\n+\n+      --  Process invidual increasing / decreasing variants\n+\n+      Last         := Proc_Decl;\n+      Curr_Decls   := New_List;\n+      Last_Variant := Nlists.Last (Component_Associations (Aggr));\n+\n+      Variant := First (Component_Associations (Aggr));\n+      while Present (Variant) loop\n+         Process_Variant\n+           (Variant    => Variant,\n+            Formal_Map => Formal_Map,\n+            Prev_Decl  => Last,\n+            Is_Last    => Variant = Last_Variant);\n+         Next (Variant);\n+      end loop;\n+\n+      --  Create a subprogram body with declarations of objects that capture\n+      --  the current values of variant expressions at a recursive call and an\n+      --  if-then-else statement that compares current with old values.\n+\n+      Proc_Bod :=\n+        Make_Subprogram_Body (Loc,\n+          Specification              =>\n+            Copy_Subprogram_Spec (Proc_Spec),\n+          Declarations               => Curr_Decls,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => New_List (If_Stmt),\n+              End_Label  => Make_Identifier (Loc, Chars (Proc_Id))));\n+\n+      Insert_After_And_Analyze (Last, Proc_Bod);\n+\n+      --  Restore assertion context\n+\n+      In_Assertion_Expr := In_Assertion_Expr - 1;\n+\n+      --  Rewrite the aspect expression, which is no longer needed, with\n+      --  a reference to the procedure that has just been created. We will\n+      --  generate a call to this procedure at each recursive call of the\n+      --  subprogram that has been annotated with Subprogram_Variant.\n+\n+      Rewrite (Aggr, New_Occurrence_Of (Proc_Id, Loc));\n+   end Expand_Pragma_Subprogram_Variant;\n+\n    -------------------------------------------\n    -- Expand_Pragma_Suppress_Initialization --\n    -------------------------------------------"}, {"sha": "59f0d6a4f2fe41850630c0f318452be2d3ed4d44", "filename": "gcc/ada/exp_prag.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fexp_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fexp_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.ads?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -49,4 +49,15 @@ package Exp_Prag is\n    --  applies to package Pack_Id. N denotes the related package spec or\n    --  body.\n \n+   procedure Expand_Pragma_Subprogram_Variant\n+     (Prag       : Node_Id;\n+      Subp_Id    : Entity_Id;\n+      Body_Decls : List_Id);\n+   --  Given pragma Subprogram_Variant Prag, create the circuitry needed\n+   --  to evaluate variant expressions at the subprogram entry and at the\n+   --  recursive call. Subp_Id is the related subprogram for which the pragma\n+   --  applies and Body_Decls are its body declarations. On exit, the argument\n+   --  of Prag is replaced with a reference to procedure with checks for the\n+   --  variant expressions.\n+\n end Exp_Prag;"}, {"sha": "508381763d338972377dbaca20e2d533651af17c", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -9930,6 +9930,24 @@ package body Exp_Util is\n               Constraints => List_Constr));\n    end Make_Subtype_From_Expr;\n \n+   -----------------------------\n+   -- Make_Variant_Comparison --\n+   -----------------------------\n+\n+   function Make_Variant_Comparison\n+     (Loc      : Source_Ptr;\n+      Mode     : Name_Id;\n+      Curr_Val : Node_Id;\n+      Old_Val  : Node_Id) return Node_Id\n+   is\n+   begin\n+      if Mode = Name_Increases then\n+         return Make_Op_Gt (Loc, Curr_Val, Old_Val);\n+      else pragma Assert (Mode = Name_Decreases);\n+         return Make_Op_Lt (Loc, Curr_Val, Old_Val);\n+      end if;\n+   end Make_Variant_Comparison;\n+\n    ---------------\n    -- Map_Types --\n    ---------------"}, {"sha": "cb288bd0c0e6a4f29f55ab8f28e63aea44ffe7fe", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -910,6 +910,15 @@ package Exp_Util is\n    --  wide type. Set Related_Id to request an external name for the subtype\n    --  rather than an internal temporary.\n \n+   function Make_Variant_Comparison\n+     (Loc      : Source_Ptr;\n+      Mode     : Name_Id;\n+      Curr_Val : Node_Id;\n+      Old_Val  : Node_Id) return Node_Id;\n+   --  Subsidiary to the expansion of pragmas Loop_Variant and\n+   --  Subprogram_Variant. Generate a comparison between Curr_Val and Old_Val\n+   --  depending on the variant mode (Increases / Decreases).\n+\n    procedure Map_Types (Parent_Type : Entity_Id; Derived_Type : Entity_Id);\n    --  Establish the following mapping between the attributes of tagged parent\n    --  type Parent_Type and tagged derived type Derived_Type."}, {"sha": "b4d56b620a6c7d87c696505525f628769da58087", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -317,6 +317,7 @@ package body Inline is\n    --    Refined_Global\n    --    Refined_Depends\n    --    Refined_Post\n+   --    Subprogram_Variant\n    --    Test_Case\n    --    Unmodified\n    --    Unreferenced\n@@ -5119,6 +5120,7 @@ package body Inline is\n                                         | Name_Refined_Global\n                                         | Name_Refined_Depends\n                                         | Name_Refined_Post\n+                                        | Name_Subprogram_Variant\n                                         | Name_Test_Case\n                                         | Name_Unmodified\n                                         | Name_Unreferenced"}, {"sha": "5783c33d2dbdc0765aba5b3a7dca44c1d2176ec5", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -1496,6 +1496,7 @@ begin\n          | Pragma_Storage_Unit\n          | Pragma_Stream_Convert\n          | Pragma_Subtitle\n+         | Pragma_Subprogram_Variant\n          | Pragma_Suppress\n          | Pragma_Suppress_Debug_Info\n          | Pragma_Suppress_Exception_Locations"}, {"sha": "7a67a4371448892a671c511622efbcf9dafac214", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -1193,6 +1193,38 @@ package body Sem is\n       end if;\n    end Insert_Before_And_Analyze;\n \n+   --------------------------------------------\n+   -- Insert_Before_First_Source_Declaration --\n+   --------------------------------------------\n+\n+   procedure Insert_Before_First_Source_Declaration\n+     (Stmt  : Node_Id;\n+      Decls : List_Id)\n+   is\n+      Decl : Node_Id;\n+   begin\n+      --  Inspect the declarations of the related subprogram body looking for\n+      --  the first source declaration.\n+\n+      pragma Assert (Present (Decls));\n+\n+      Decl := First (Decls);\n+      while Present (Decl) loop\n+         if Comes_From_Source (Decl) then\n+            Insert_Before (Decl, Stmt);\n+            return;\n+         end if;\n+\n+         Next (Decl);\n+      end loop;\n+\n+      --  If we get there, then the subprogram body lacks any source\n+      --  declarations. The body of _Postconditions now acts as the\n+      --  last declaration.\n+\n+      Append (Stmt, Decls);\n+   end Insert_Before_First_Source_Declaration;\n+\n    -----------------------------------\n    -- Insert_List_After_And_Analyze --\n    -----------------------------------"}, {"sha": "6003997e89d644143c728215cb5aa15a78a9b835", "filename": "gcc/ada/sem.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.ads?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -671,6 +671,13 @@ package Sem is\n    --  Suppress argument is present, then the analysis is done with the\n    --  specified check suppressed (can be All_Checks to suppress all checks).\n \n+   procedure Insert_Before_First_Source_Declaration\n+     (Stmt  : Node_Id;\n+      Decls : List_Id);\n+   --  Insert node Stmt before the first source declaration of the related\n+   --  subprogram's body. If no such declaration exists, Stmt becomes the last\n+   --  declaration.\n+\n    function External_Ref_In_Generic (E : Entity_Id) return Boolean;\n    --  Return True if we are in the context of a generic and E is\n    --  external (more global) to it."}, {"sha": "4fbb6e56b68eda57328d1ada990b418446c4eff9", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -270,6 +270,7 @@ package body Sem_Ch12 is\n    --                                Refined_Depends\n    --                                Refined_Global\n    --                                Refined_Post\n+   --                                Subprogram_Variant\n    --                                Test_Case\n \n    --  Most package contract annotations utilize forward references to classify"}, {"sha": "63ca3211f4367fbe8c67f99ebc2a57a1fa28d410", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -1544,6 +1544,7 @@ package body Sem_Ch13 is\n       --    Refined_Global\n       --    Refined_State\n       --    SPARK_Mode\n+      --    Subprogram_Variant\n       --    Warnings\n       --  Insert pragma Prag such that it mimics the placement of a source\n       --  pragma of the same kind. Flag Is_Generic should be set when the\n@@ -1764,10 +1765,10 @@ package body Sem_Ch13 is\n       --  analyzed right now.\n \n       --  Note that there is a special handling for Pre, Post, Test_Case,\n-      --  Contract_Cases aspects. In these cases, we do not have to worry\n-      --  about delay issues, since the pragmas themselves deal with delay\n-      --  of visibility for the expression analysis. Thus, we just insert\n-      --  the pragma after the node N.\n+      --  Contract_Cases and Subprogram_Variant aspects. In these cases, we do\n+      --  not have to worry about delay issues, since the pragmas themselves\n+      --  deal with delay of visibility for the expression analysis. Thus, we\n+      --  just insert the pragma after the node N.\n \n       --  Loop through aspects\n \n@@ -4192,8 +4193,8 @@ package body Sem_Ch13 is\n \n                --  Case 4: Aspects requiring special handling\n \n-               --  Pre/Post/Test_Case/Contract_Cases whose corresponding\n-               --  pragmas take care of the delay.\n+               --  Pre/Post/Test_Case/Contract_Cases/Subprogram_Variant whose\n+               --  corresponding pragmas take care of the delay.\n \n                --  Pre/Post\n \n@@ -4402,6 +4403,19 @@ package body Sem_Ch13 is\n                   Insert_Pragma (Aitem);\n                   goto Continue;\n \n+               --  Subprogram_Variant\n+\n+               when Aspect_Subprogram_Variant =>\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Nam);\n+\n+                  Decorate (Aspect, Aitem);\n+                  Insert_Pragma (Aitem);\n+                  goto Continue;\n+\n                --  Case 5: Special handling for aspects with an optional\n                --  boolean argument.\n \n@@ -10855,6 +10869,7 @@ package body Sem_Ch13 is\n             | Aspect_Refined_State\n             | Aspect_Relaxed_Initialization\n             | Aspect_SPARK_Mode\n+            | Aspect_Subprogram_Variant\n             | Aspect_Test_Case\n             | Aspect_Unimplemented\n             | Aspect_Volatile_Function"}, {"sha": "67b3d35f4fd2062d25be51b6300a0ac63f11c6ed", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 285, "deletions": 4, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -4070,10 +4070,10 @@ package body Sem_Prag is\n       procedure Ensure_Aggregate_Form (Arg : Node_Id);\n       --  Subsidiary routine to the processing of pragmas Abstract_State,\n       --  Contract_Cases, Depends, Global, Initializes, Refined_Depends,\n-      --  Refined_Global and Refined_State. Transform argument Arg into\n-      --  an aggregate if not one already. N_Null is never transformed.\n-      --  Arg may denote an aspect specification or a pragma argument\n-      --  association.\n+      --  Refined_Global, Refined_State and Subprogram_Variant. Transform\n+      --  argument Arg into an aggregate if not one already. N_Null is never\n+      --  transformed. Arg may denote an aspect specification or a pragma\n+      --  argument association.\n \n       procedure Error_Pragma (Msg : String);\n       pragma No_Return (Error_Pragma);\n@@ -23898,6 +23898,139 @@ package body Sem_Prag is\n             end if;\n          end Style_Checks;\n \n+         ------------------------\n+         -- Subprogram_Variant --\n+         ------------------------\n+\n+         --  pragma Subprogram_Variant ( SUBPROGRAM_VARIANT_ITEM\n+         --                           {, SUBPROGRAM_VARIANT_ITEM } );\n+\n+         --  SUBPROGRAM_VARIANT_ITEM ::=\n+         --    CHANGE_DIRECTION => discrete_EXPRESSION\n+\n+         --  CHANGE_DIRECTION ::= Increases | Decreases\n+\n+         --  Characteristics:\n+\n+         --    * Analysis - The annotation undergoes initial checks to verify\n+         --    the legal placement and context. Secondary checks preanalyze the\n+         --    expressions in:\n+\n+         --       Analyze_Subprogram_Variant_In_Decl_Part\n+\n+         --    * Expansion - The annotation is expanded during the expansion of\n+         --    the related subprogram [body] contract as performed in:\n+\n+         --       Expand_Subprogram_Contract\n+\n+         --    * Template - The annotation utilizes the generic template of the\n+         --    related subprogram [body] when it is:\n+\n+         --       aspect on subprogram declaration\n+         --       aspect on stand-alone subprogram body\n+         --       pragma on stand-alone subprogram body\n+\n+         --    The annotation must prepare its own template when it is:\n+\n+         --       pragma on subprogram declaration\n+\n+         --    * Globals - Capture of global references must occur after full\n+         --    analysis.\n+\n+         --    * Instance - The annotation is instantiated automatically when\n+         --    the related generic subprogram [body] is instantiated except for\n+         --    the \"pragma on subprogram declaration\" case. In that scenario\n+         --    the annotation must instantiate itself.\n+\n+         when Pragma_Subprogram_Variant => Subprogram_Variant : declare\n+            Spec_Id   : Entity_Id;\n+            Subp_Decl : Node_Id;\n+            Subp_Spec : Node_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_No_Identifiers;\n+            Check_Arg_Count (1);\n+\n+            --  Ensure the proper placement of the pragma. Subprogram_Variant\n+            --  must be associated with a subprogram declaration or a body that\n+            --  acts as a spec.\n+\n+            Subp_Decl :=\n+              Find_Related_Declaration_Or_Body (N, Do_Checks => True);\n+\n+            --  Generic subprogram\n+\n+            if Nkind (Subp_Decl) = N_Generic_Subprogram_Declaration then\n+               null;\n+\n+            --  Body acts as spec\n+\n+            elsif Nkind (Subp_Decl) = N_Subprogram_Body\n+              and then No (Corresponding_Spec (Subp_Decl))\n+            then\n+               null;\n+\n+            --  Body stub acts as spec\n+\n+            elsif Nkind (Subp_Decl) = N_Subprogram_Body_Stub\n+              and then No (Corresponding_Spec_Of_Stub (Subp_Decl))\n+            then\n+               null;\n+\n+            --  Subprogram\n+\n+            elsif Nkind (Subp_Decl) = N_Subprogram_Declaration then\n+               Subp_Spec := Specification (Subp_Decl);\n+\n+               --  Pragma Subprogram_Variant is forbidden on null procedures,\n+               --  as this may lead to potential ambiguities in behavior when\n+               --  interface null procedures are involved. Also, it just\n+               --  wouldn't make sense, because null procedure is not\n+               --  recursive.\n+\n+               if Nkind (Subp_Spec) = N_Procedure_Specification\n+                 and then Null_Present (Subp_Spec)\n+               then\n+                  Error_Msg_N (Fix_Error\n+                    (\"pragma % cannot apply to null procedure\"), N);\n+                  return;\n+               end if;\n+\n+            else\n+               Pragma_Misplaced;\n+               return;\n+            end if;\n+\n+            Spec_Id := Unique_Defining_Entity (Subp_Decl);\n+\n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Ghost_Pragma (N, Spec_Id);\n+            Ensure_Aggregate_Form (Get_Argument (N, Spec_Id));\n+\n+            --  Chain the pragma on the contract for further processing by\n+            --  Analyze_Contract_Cases_In_Decl_Part.\n+\n+            Add_Contract_Item (N, Defining_Entity (Subp_Decl));\n+\n+            --  Fully analyze the pragma when it appears inside a subprogram\n+            --  body because it cannot benefit from forward references.\n+\n+            if Nkind (Subp_Decl) in N_Subprogram_Body\n+                                  | N_Subprogram_Body_Stub\n+            then\n+               --  The legality checks of pragma Subprogram_Variant are\n+               --  affected by the SPARK mode in effect and the volatility\n+               --  of the context. Analyze all pragmas in a specific order.\n+\n+               Analyze_If_Present (Pragma_SPARK_Mode);\n+               Analyze_If_Present (Pragma_Volatile_Function);\n+               Analyze_Subprogram_Variant_In_Decl_Part (N);\n+            end if;\n+         end Subprogram_Variant;\n+\n          --------------\n          -- Subtitle --\n          --------------\n@@ -28918,6 +29051,152 @@ package body Sem_Prag is\n       Set_Is_Analyzed_Pragma (N);\n    end Analyze_Refined_State_In_Decl_Part;\n \n+   ---------------------------------------------\n+   -- Analyze_Subprogram_Variant_In_Decl_Part --\n+   ---------------------------------------------\n+\n+   --  WARNING: This routine manages Ghost regions. Return statements must be\n+   --  replaced by gotos which jump to the end of the routine and restore the\n+   --  Ghost mode.\n+\n+   procedure Analyze_Subprogram_Variant_In_Decl_Part\n+     (N         : Node_Id;\n+      Freeze_Id : Entity_Id := Empty)\n+   is\n+      Subp_Decl : constant Node_Id   := Find_Related_Declaration_Or_Body (N);\n+      Spec_Id   : constant Entity_Id := Unique_Defining_Entity (Subp_Decl);\n+\n+      procedure Analyze_Variant (Variant : Node_Id);\n+      --  Verify the legality of a single contract case\n+\n+      ---------------------\n+      -- Analyze_Variant --\n+      ---------------------\n+\n+      procedure Analyze_Variant (Variant : Node_Id) is\n+         Direction       : Node_Id;\n+         Expr            : Node_Id;\n+         Errors          : Nat;\n+         Extra_Direction : Node_Id;\n+\n+      begin\n+         if Nkind (Variant) /= N_Component_Association then\n+            Error_Msg_N (\"wrong syntax in subprogram variant\", Variant);\n+            return;\n+         end if;\n+\n+         Direction := First (Choices (Variant));\n+         Expr      := Expression (Variant);\n+\n+         --  Each variant must have exactly one direction\n+\n+         Extra_Direction := Next (Direction);\n+\n+         if Present (Extra_Direction) then\n+            Error_Msg_N\n+              (\"subprogram variant case must have exactly one direction\",\n+               Extra_Direction);\n+         end if;\n+\n+         --  Check placement of OTHERS if available (SPARK RM 6.1.3(1))\n+\n+         if Nkind (Direction) = N_Identifier then\n+            if Chars (Direction) /= Name_Decreases\n+                 and then\n+               Chars (Direction) /= Name_Increases\n+            then\n+               Error_Msg_N (\"wrong direction\", Direction);\n+            end if;\n+         else\n+            Error_Msg_N (\"wrong syntax\", Direction);\n+         end if;\n+\n+         Errors := Serious_Errors_Detected;\n+         Preanalyze_Assert_Expression (Expr, Any_Discrete);\n+\n+         --  Emit a clarification message when the variant expression\n+         --  contains at least one undefined reference, possibly due\n+         --  to contract freezing.\n+\n+         if Errors /= Serious_Errors_Detected\n+           and then Present (Freeze_Id)\n+           and then Has_Undefined_Reference (Expr)\n+         then\n+            Contract_Freeze_Error (Spec_Id, Freeze_Id);\n+         end if;\n+      end Analyze_Variant;\n+\n+      --  Local variables\n+\n+      Variants : constant Node_Id := Expression (Get_Argument (N, Spec_Id));\n+\n+      Saved_GM  : constant Ghost_Mode_Type := Ghost_Mode;\n+      Saved_IGR : constant Node_Id         := Ignored_Ghost_Region;\n+      --  Save the Ghost-related attributes to restore on exit\n+\n+      Variant       : Node_Id;\n+      Restore_Scope : Boolean := False;\n+\n+   --  Start of processing for Analyze_Subprogram_Variant_In_Decl_Part\n+\n+   begin\n+      --  Do not analyze the pragma multiple times\n+\n+      if Is_Analyzed_Pragma (N) then\n+         return;\n+      end if;\n+\n+      --  Set the Ghost mode in effect from the pragma. Due to the delayed\n+      --  analysis of the pragma, the Ghost mode at point of declaration and\n+      --  point of analysis may not necessarily be the same. Use the mode in\n+      --  effect at the point of declaration.\n+\n+      Set_Ghost_Mode (N);\n+\n+      --  Single and multiple contract cases must appear in aggregate form. If\n+      --  this is not the case, then either the parser of the analysis of the\n+      --  pragma failed to produce an aggregate.\n+\n+      pragma Assert (Nkind (Variants) = N_Aggregate);\n+\n+      if Present (Component_Associations (Variants)) then\n+\n+         --  Ensure that the formal parameters are visible when analyzing all\n+         --  clauses. This falls out of the general rule of aspects pertaining\n+         --  to subprogram declarations.\n+\n+         if not In_Open_Scopes (Spec_Id) then\n+            Restore_Scope := True;\n+            Push_Scope (Spec_Id);\n+\n+            if Is_Generic_Subprogram (Spec_Id) then\n+               Install_Generic_Formals (Spec_Id);\n+            else\n+               Install_Formals (Spec_Id);\n+            end if;\n+         end if;\n+\n+         Variant := First (Component_Associations (Variants));\n+         while Present (Variant) loop\n+            Analyze_Variant (Variant);\n+            Next (Variant);\n+         end loop;\n+\n+         if Restore_Scope then\n+            End_Scope;\n+         end if;\n+\n+      --  Otherwise the pragma is illegal\n+\n+      else\n+         Error_Msg_N (\"wrong syntax for subprogram variant\", N);\n+      end if;\n+\n+      Set_Is_Analyzed_Pragma (N);\n+\n+      Restore_Ghost_Region (Saved_GM, Saved_IGR);\n+   end Analyze_Subprogram_Variant_In_Decl_Part;\n+\n    ------------------------------------\n    -- Analyze_Test_Case_In_Decl_Part --\n    ------------------------------------\n@@ -30983,6 +31262,7 @@ package body Sem_Prag is\n       Pragma_Storage_Unit                   =>  0,\n       Pragma_Stream_Convert                 =>  0,\n       Pragma_Style_Checks                   =>  0,\n+      Pragma_Subprogram_Variant             => -1,\n       Pragma_Subtitle                       =>  0,\n       Pragma_Suppress                       =>  0,\n       Pragma_Suppress_All                   =>  0,\n@@ -31274,6 +31554,7 @@ package body Sem_Prag is\n             | Name_Predicate\n             | Name_Refined_Post\n             | Name_Statement_Assertions\n+            | Name_Subprogram_Variant\n          =>\n             return True;\n "}, {"sha": "fd7a0cdc29255d52cb31299418d92519a3e99781", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -265,6 +265,13 @@ package Sem_Prag is\n    --  the entity of [generic] package body or [generic] subprogram body which\n    --  caused \"freezing\" of the related contract where the pragma resides.\n \n+   procedure Analyze_Subprogram_Variant_In_Decl_Part\n+     (N         : Node_Id;\n+      Freeze_Id : Entity_Id := Empty);\n+   --  Perform full analysis of delayed pragma Subprogram_Variant. Freeze_Id is\n+   --  the entity of [generic] package body or [generic] subprogram body which\n+   --  caused \"freezing\" of the related contract where the pragma resides.\n+\n    procedure Analyze_Test_Case_In_Decl_Part (N : Node_Id);\n    --  Perform preanalysis of pragma Test_Case\n "}, {"sha": "ae7c5b7ac893f60b4ac8672dcbb56723de302315", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -6124,27 +6124,6 @@ package body Sem_Res is\n    ------------------\n \n    procedure Resolve_Call (N : Node_Id; Typ : Entity_Id) is\n-      function Same_Or_Aliased_Subprograms\n-        (S : Entity_Id;\n-         E : Entity_Id) return Boolean;\n-      --  Returns True if the subprogram entity S is the same as E or else\n-      --  S is an alias of E.\n-\n-      ---------------------------------\n-      -- Same_Or_Aliased_Subprograms --\n-      ---------------------------------\n-\n-      function Same_Or_Aliased_Subprograms\n-        (S : Entity_Id;\n-         E : Entity_Id) return Boolean\n-      is\n-         Subp_Alias : constant Entity_Id := Alias (S);\n-      begin\n-         return S = E or else (Present (Subp_Alias) and then Subp_Alias = E);\n-      end Same_Or_Aliased_Subprograms;\n-\n-      --  Local variables\n-\n       Loc      : constant Source_Ptr := Sloc (N);\n       Subp     : constant Node_Id    := Name (N);\n       Body_Id  : Entity_Id;\n@@ -6157,8 +6136,6 @@ package body Sem_Res is\n       Rtype    : Entity_Id;\n       Scop     : Entity_Id;\n \n-   --  Start of processing for Resolve_Call\n-\n    begin\n       --  Preserve relevant elaboration-related attributes of the context which\n       --  are no longer available or very expensive to recompute once analysis,"}, {"sha": "085ec69473b67ed992f2948917102ea9742aed07", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -19037,6 +19037,7 @@ package body Sem_Util is\n         or else Nam = Name_Refined_Depends\n         or else Nam = Name_Refined_Global\n         or else Nam = Name_Refined_Post\n+        or else Nam = Name_Subprogram_Variant\n         or else Nam = Name_Test_Case;\n    end Is_Subprogram_Contract_Annotation;\n \n@@ -26242,6 +26243,19 @@ package body Sem_Util is\n       end if;\n    end Same_Object;\n \n+   ---------------------------------\n+   -- Same_Or_Aliased_Subprograms --\n+   ---------------------------------\n+\n+   function Same_Or_Aliased_Subprograms\n+     (S : Entity_Id;\n+      E : Entity_Id) return Boolean\n+   is\n+      Subp_Alias : constant Entity_Id := Alias (S);\n+   begin\n+      return S = E or else (Present (Subp_Alias) and then Subp_Alias = E);\n+   end Same_Or_Aliased_Subprograms;\n+\n    ---------------\n    -- Same_Type --\n    ---------------"}, {"sha": "181c657d7289e41c48dd7760d3696c3d6de2b2c1", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -2148,6 +2148,7 @@ package Sem_Util is\n    --    Refined_Depends\n    --    Refined_Global\n    --    Refined_Post\n+   --    Subprogram_Variant\n    --    Test_Case\n \n    function Is_Subprogram_Stub_Without_Prior_Declaration\n@@ -2824,6 +2825,12 @@ package Sem_Util is\n    --  mean that different objects are designated, just that this could not\n    --  be reliably determined at compile time.\n \n+   function Same_Or_Aliased_Subprograms\n+     (S : Entity_Id;\n+      E : Entity_Id) return Boolean;\n+   --  Returns True if the subprogram entity S is the same as E or else S is an\n+   --  alias of E.\n+\n    function Same_Type (T1, T2 : Entity_Id) return Boolean;\n    --  Determines if T1 and T2 represent exactly the same type. Two types\n    --  are the same if they are identical, or if one is an unconstrained"}, {"sha": "231ebb586abb247c578a5a0f1c3768cb629e99cb", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -7945,8 +7945,8 @@ package Sinfo is\n       --  operation) are also in this list.\n \n       --  Contract_Test_Cases contains a collection of pragmas that correspond\n-      --  to aspects/pragmas Contract_Cases and Test_Case. The ordering in the\n-      --  list is in LIFO fashion.\n+      --  to aspects/pragmas Contract_Cases, Test_Case and Subprogram_Variant.\n+      --  The ordering in the list is in LIFO fashion.\n \n       --  Classifications contains pragmas that either declare, categorize, or\n       --  establish dependencies between subprogram or package inputs and"}, {"sha": "8d457b50097868811a06fd6490a8e9204272e5d2", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa1ffd42cd208fc1c6c819567c363dd8080efa2/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=afa1ffd42cd208fc1c6c819567c363dd8080efa2", "patch": "@@ -196,6 +196,7 @@ package Snames is\n    Name_uTask_Name                     : constant Name_Id := N + $;\n    Name_uTrace_Sp                      : constant Name_Id := N + $;\n    Name_uType_Invariant                : constant Name_Id := N + $;\n+   Name_uVariants                      : constant Name_Id := N + $;\n \n    --  Names of predefined primitives used in the expansion of dispatching\n    --  requeue and select statements, Abort, 'Callable and 'Terminated.\n@@ -668,6 +669,7 @@ package Snames is\n    Name_Source_Reference               : constant Name_Id := N + $; -- GNAT\n    Name_Static_Elaboration_Desired     : constant Name_Id := N + $; -- GNAT\n    Name_Stream_Convert                 : constant Name_Id := N + $; -- GNAT\n+   Name_Subprogram_Variant             : constant Name_Id := N + $; -- GNAT\n    Name_Subtitle                       : constant Name_Id := N + $; -- GNAT\n    Name_Suppress_All                   : constant Name_Id := N + $; -- GNAT\n    Name_Suppress_Debug_Info            : constant Name_Id := N + $; -- GNAT\n@@ -2102,6 +2104,7 @@ package Snames is\n       Pragma_Source_Reference,\n       Pragma_Static_Elaboration_Desired,\n       Pragma_Stream_Convert,\n+      Pragma_Subprogram_Variant,\n       Pragma_Subtitle,\n       Pragma_Suppress_All,\n       Pragma_Suppress_Debug_Info,"}]}