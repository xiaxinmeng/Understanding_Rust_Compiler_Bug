{"sha": "dfd6ece2cb3000d9882a7448b8e8ca379a9949b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZkNmVjZTJjYjMwMDBkOTg4MmE3NDQ4YjhlOGNhMzc5YTk5NDliOQ==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-07-02T19:53:24Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-07-02T19:53:24Z"}, "message": "trans-types.h (gfc_add_field_to_struct): Add tree ** parameter.\n\n\t* trans-types.h (gfc_add_field_to_struct): Add tree ** parameter.\n\t* trans-types.c (gfc_add_field_to_struct_1): New function, most\n\tof which comes from...\n\t(gfc_add_field_to_struct): ...here.  Call it.  Add new parameter.\n\t(gfc_get_desc_dim_type): Call gfc_add_field_to_struct_1 for\n\tbuilding fields.\n\t(gfc_get_array_descriptor_base): Likewise.\n\t(gfc_get_mixed_entry_union): Likewise.\n\t(gfc_get_derived_type): Add extra chain parameter for\n\tgfc_add_field_to_struct.\n\t* trans-stmt.c (gfc_trans_character_select): Likewise.\n\t* trans-io.c (gfc_build_st_parameter): Likewise.\n\nFrom-SVN: r161738", "tree": {"sha": "6f03ec4e9f3206b3a12d1205d91d3a68e28415f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f03ec4e9f3206b3a12d1205d91d3a68e28415f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfd6ece2cb3000d9882a7448b8e8ca379a9949b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfd6ece2cb3000d9882a7448b8e8ca379a9949b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfd6ece2cb3000d9882a7448b8e8ca379a9949b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfd6ece2cb3000d9882a7448b8e8ca379a9949b9/comments", "author": null, "committer": null, "parents": [{"sha": "0acba2b4cc842831c3893d172082e65ce291608e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0acba2b4cc842831c3893d172082e65ce291608e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0acba2b4cc842831c3893d172082e65ce291608e"}], "stats": {"total": 154, "additions": 88, "deletions": 66}, "files": [{"sha": "6fbf2d532f9feda2242458f9b725055d23f0a4bd", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd6ece2cb3000d9882a7448b8e8ca379a9949b9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd6ece2cb3000d9882a7448b8e8ca379a9949b9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=dfd6ece2cb3000d9882a7448b8e8ca379a9949b9", "patch": "@@ -1,3 +1,18 @@\n+2010-07-02  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* trans-types.h (gfc_add_field_to_struct): Add tree ** parameter.\n+\t* trans-types.c (gfc_add_field_to_struct_1): New function, most\n+\tof which comes from...\n+\t(gfc_add_field_to_struct): ...here.  Call it.  Add new parameter.\n+\t(gfc_get_desc_dim_type): Call gfc_add_field_to_struct_1 for\n+\tbuilding fields.\n+\t(gfc_get_array_descriptor_base): Likewise.\n+\t(gfc_get_mixed_entry_union): Likewise.\n+\t(gfc_get_derived_type): Add extra chain parameter for\n+\tgfc_add_field_to_struct.\n+\t* trans-stmt.c (gfc_trans_character_select): Likewise.\n+\t* trans-io.c (gfc_build_st_parameter): Likewise.\n+\n 2010-06-29  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/44718"}, {"sha": "9926d2fb8a1dcfaca168dc15027515d959335bfa", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd6ece2cb3000d9882a7448b8e8ca379a9949b9/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd6ece2cb3000d9882a7448b8e8ca379a9949b9/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=dfd6ece2cb3000d9882a7448b8e8ca379a9949b9", "patch": "@@ -156,6 +156,7 @@ gfc_build_st_parameter (enum ioparam_type ptype, tree *types)\n   char name[64];\n   size_t len;\n   tree t = make_node (RECORD_TYPE);\n+  tree *chain = NULL;\n \n   len = strlen (st_parameter[ptype].name);\n   gcc_assert (len <= sizeof (name) - sizeof (\"__st_parameter_\"));\n@@ -177,12 +178,12 @@ gfc_build_st_parameter (enum ioparam_type ptype, tree *types)\n \tcase IOPARM_type_pad:\n \t  p->field = gfc_add_field_to_struct (&TYPE_FIELDS (t), t,\n \t\t\t\t\t      get_identifier (p->name),\n-\t\t\t\t\t      types[p->type]);\n+\t\t\t\t\t      types[p->type], &chain);\n \t  break;\n \tcase IOPARM_type_char1:\n \t  p->field = gfc_add_field_to_struct (&TYPE_FIELDS (t), t,\n \t\t\t\t\t      get_identifier (p->name),\n-\t\t\t\t\t      pchar_type_node);\n+\t\t\t\t\t      pchar_type_node, &chain);\n \t  /* FALLTHROUGH */\n \tcase IOPARM_type_char2:\n \t  len = strlen (p->name);\n@@ -191,17 +192,19 @@ gfc_build_st_parameter (enum ioparam_type ptype, tree *types)\n \t  memcpy (name + len, \"_len\", sizeof (\"_len\"));\n \t  p->field_len = gfc_add_field_to_struct (&TYPE_FIELDS (t), t,\n \t\t\t\t\t\t  get_identifier (name),\n-\t\t\t\t\t\t  gfc_charlen_type_node);\n+\t\t\t\t\t\t  gfc_charlen_type_node,\n+\t\t\t\t\t\t  &chain);\n \t  if (p->type == IOPARM_type_char2)\n \t    p->field = gfc_add_field_to_struct (&TYPE_FIELDS (t), t,\n \t\t\t\t\t\tget_identifier (p->name),\n-\t\t\t\t\t\tpchar_type_node);\n+\t\t\t\t\t\tpchar_type_node, &chain);\n \t  break;\n \tcase IOPARM_type_common:\n \t  p->field\n \t    = gfc_add_field_to_struct (&TYPE_FIELDS (t), t,\n \t\t\t\t       get_identifier (p->name),\n-\t\t\t\t       st_parameter[IOPARM_ptype_common].type);\n+\t\t\t\t       st_parameter[IOPARM_ptype_common].type,\n+\t\t\t\t       &chain);\n \t  break;\n \tcase IOPARM_type_num:\n \t  gcc_unreachable ();"}, {"sha": "15f2acb27d3a3108f85263516ddc9bda735adb74", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd6ece2cb3000d9882a7448b8e8ca379a9949b9/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd6ece2cb3000d9882a7448b8e8ca379a9949b9/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=dfd6ece2cb3000d9882a7448b8e8ca379a9949b9", "patch": "@@ -1633,6 +1633,7 @@ gfc_trans_character_select (gfc_code *code)\n \n   if (select_struct[k] == NULL)\n     {\n+      tree *chain = NULL;\n       select_struct[k] = make_node (RECORD_TYPE);\n \n       if (code->expr1->ts.kind == 1)\n@@ -1646,7 +1647,7 @@ gfc_trans_character_select (gfc_code *code)\n #define ADD_FIELD(NAME, TYPE)\t\t\t\t\t\\\n   ss_##NAME[k] = gfc_add_field_to_struct\t\t\t\t\\\n      (&(TYPE_FIELDS (select_struct[k])), select_struct[k],\t\\\n-      get_identifier (stringize(NAME)), TYPE)\n+      get_identifier (stringize(NAME)), TYPE, &chain)\n \n       ADD_FIELD (string1, pchartype);\n       ADD_FIELD (string1_len, gfc_charlen_type_node);"}, {"sha": "f4e78c25d4f821229306c2f08dc311e998c9f4fc", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 62, "deletions": 59, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd6ece2cb3000d9882a7448b8e8ca379a9949b9/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd6ece2cb3000d9882a7448b8e8ca379a9949b9/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=dfd6ece2cb3000d9882a7448b8e8ca379a9949b9", "patch": "@@ -86,6 +86,7 @@ gfc_character_info gfc_character_kinds[MAX_CHARACTER_KINDS + 1];\n static GTY(()) tree gfc_character_types[MAX_CHARACTER_KINDS + 1];\n static GTY(()) tree gfc_pcharacter_types[MAX_CHARACTER_KINDS + 1];\n \n+static tree gfc_add_field_to_struct_1 (tree *, tree, tree, tree, tree **);\n \n /* The integer kind to use for array indices.  This will be set to the\n    proper value based on target information from the backend.  */\n@@ -1232,8 +1233,7 @@ static tree\n gfc_get_desc_dim_type (void)\n {\n   tree type;\n-  tree decl;\n-  tree fieldlist;\n+  tree fieldlist = NULL_TREE, decl, *chain = NULL;\n \n   if (gfc_desc_dim_type)\n     return gfc_desc_dim_type;\n@@ -1245,26 +1245,20 @@ gfc_get_desc_dim_type (void)\n   TYPE_PACKED (type) = 1;\n \n   /* Consists of the stride, lbound and ubound members.  */\n-  decl = build_decl (input_location,\n-\t\t     FIELD_DECL,\n-\t\t     get_identifier (\"stride\"), gfc_array_index_type);\n-  DECL_CONTEXT (decl) = type;\n+  decl = gfc_add_field_to_struct_1 (&fieldlist, type,\n+\t\t\t\t    get_identifier (\"stride\"),\n+\t\t\t\t    gfc_array_index_type, &chain);\n   TREE_NO_WARNING (decl) = 1;\n-  fieldlist = decl;\n \n-  decl = build_decl (input_location,\n-\t\t     FIELD_DECL,\n-\t\t     get_identifier (\"lbound\"), gfc_array_index_type);\n-  DECL_CONTEXT (decl) = type;\n+  decl = gfc_add_field_to_struct_1 (&fieldlist, type,\n+\t\t\t\t    get_identifier (\"lbound\"),\n+\t\t\t\t    gfc_array_index_type, &chain);\n   TREE_NO_WARNING (decl) = 1;\n-  fieldlist = chainon (fieldlist, decl);\n \n-  decl = build_decl (input_location,\n-\t\t     FIELD_DECL,\n-\t\t     get_identifier (\"ubound\"), gfc_array_index_type);\n-  DECL_CONTEXT (decl) = type;\n+  decl = gfc_add_field_to_struct_1 (&fieldlist, type,\n+\t\t\t\t    get_identifier (\"ubound\"),\n+\t\t\t\t    gfc_array_index_type, &chain);\n   TREE_NO_WARNING (decl) = 1;\n-  fieldlist = chainon (fieldlist, decl);\n \n   /* Finish off the type.  */\n   TYPE_FIELDS (type) = fieldlist;\n@@ -1540,7 +1534,7 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed,\n static tree\n gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted)\n {\n-  tree fat_type, fieldlist, decl, arraytype;\n+  tree fat_type, fieldlist = NULL_TREE, decl, arraytype, *chain = NULL;\n   char name[16 + 2*GFC_RANK_DIGITS + 1 + 1];\n   int idx = 2 * (codimen + dimen - 1) + restricted;\n \n@@ -1555,28 +1549,23 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted)\n   TYPE_NAME (fat_type) = get_identifier (name);\n \n   /* Add the data member as the first element of the descriptor.  */\n-  decl = build_decl (input_location,\n-\t\t     FIELD_DECL, get_identifier (\"data\"),\n-\t\t     restricted ? prvoid_type_node : ptr_type_node);\n-\n-  DECL_CONTEXT (decl) = fat_type;\n-  fieldlist = decl;\n+  decl = gfc_add_field_to_struct_1 (&fieldlist, fat_type,\n+\t\t\t\t    get_identifier (\"data\"),\n+\t\t\t\t    (restricted\n+\t\t\t\t     ? prvoid_type_node\n+\t\t\t\t     : ptr_type_node), &chain);\n \n   /* Add the base component.  */\n-  decl = build_decl (input_location,\n-\t\t     FIELD_DECL, get_identifier (\"offset\"),\n-\t\t     gfc_array_index_type);\n-  DECL_CONTEXT (decl) = fat_type;\n+  decl = gfc_add_field_to_struct_1 (&fieldlist, fat_type,\n+\t\t\t\t    get_identifier (\"offset\"),\n+\t\t\t\t    gfc_array_index_type, &chain);\n   TREE_NO_WARNING (decl) = 1;\n-  fieldlist = chainon (fieldlist, decl);\n \n   /* Add the dtype component.  */\n-  decl = build_decl (input_location,\n-\t\t     FIELD_DECL, get_identifier (\"dtype\"),\n-\t\t     gfc_array_index_type);\n-  DECL_CONTEXT (decl) = fat_type;\n+  decl = gfc_add_field_to_struct_1 (&fieldlist, fat_type,\n+\t\t\t\t    get_identifier (\"dtype\"),\n+\t\t\t\t    gfc_array_index_type, &chain);\n   TREE_NO_WARNING (decl) = 1;\n-  fieldlist = chainon (fieldlist, decl);\n \n   /* Build the array type for the stride and bound components.  */\n   arraytype =\n@@ -1585,11 +1574,10 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted)\n \t\t\t\t\tgfc_index_zero_node,\n \t\t\t\t\tgfc_rank_cst[codimen + dimen - 1]));\n \n-  decl = build_decl (input_location,\n-\t\t     FIELD_DECL, get_identifier (\"dim\"), arraytype);\n-  DECL_CONTEXT (decl) = fat_type;\n+  decl = gfc_add_field_to_struct_1 (&fieldlist, fat_type,\n+\t\t\t\t    get_identifier (\"dim\"),\n+\t\t\t\t    arraytype, &chain);\n   TREE_NO_WARNING (decl) = 1;\n-  fieldlist = chainon (fieldlist, decl);\n \n   /* Finish off the type.  */\n   TYPE_FIELDS (fat_type) = fieldlist;\n@@ -1853,26 +1841,44 @@ gfc_finish_type (tree type)\n }\n \f\n /* Add a field of given NAME and TYPE to the context of a UNION_TYPE\n-   or RECORD_TYPE pointed to by STYPE.  The new field is chained\n-   to the fieldlist pointed to by FIELDLIST.\n+   or RECORD_TYPE pointed to by CONTEXT.  The new field is chained\n+   to the fieldlist pointed to by FIELDLIST through *CHAIN.\n \n    Returns a pointer to the new field.  */\n \n+static tree\n+gfc_add_field_to_struct_1 (tree *fieldlist, tree context,\n+\t\t\t\t tree name, tree type, tree **chain)\n+{\n+  tree decl = build_decl (input_location, FIELD_DECL, name, type);\n+\n+  DECL_CONTEXT (decl) = context;\n+  TREE_CHAIN (decl) = NULL_TREE;\n+  if (*fieldlist == NULL_TREE)\n+    *fieldlist = decl;\n+  if (chain != NULL)\n+    {\n+      if (*chain != NULL)\n+\t**chain = decl;\n+      *chain = &TREE_CHAIN (decl);\n+    }\n+\n+  return decl;\n+}\n+\n+/* Like `gfc_add_field_to_struct_1', but adds alignment\n+   information.  */\n+\n tree\n gfc_add_field_to_struct (tree *fieldlist, tree context,\n-\t\t\t tree name, tree type)\n+\t\t\t tree name, tree type, tree **chain)\n {\n-  tree decl;\n+  tree decl = gfc_add_field_to_struct_1 (fieldlist, context,\n+\t\t\t\t\t name, type, chain);\n \n-  decl = build_decl (input_location,\n-\t\t     FIELD_DECL, name, type);\n-\n-  DECL_CONTEXT (decl) = context;\n   DECL_INITIAL (decl) = 0;\n   DECL_ALIGN (decl) = 0;\n   DECL_USER_ALIGN (decl) = 0;\n-  TREE_CHAIN (decl) = NULL_TREE;\n-  *fieldlist = chainon (*fieldlist, decl);\n \n   return decl;\n }\n@@ -1950,6 +1956,7 @@ gfc_get_derived_type (gfc_symbol * derived)\n {\n   tree typenode = NULL, field = NULL, field_type = NULL, fieldlist = NULL;\n   tree canonical = NULL_TREE;\n+  tree *chain = NULL;\n   bool got_canonical = false;\n   gfc_component *c;\n   gfc_dt_list *dt;\n@@ -1975,7 +1982,7 @@ gfc_get_derived_type (gfc_symbol * derived)\n \t\t\t\t derived->backend_decl,\n \t\t\t\t get_identifier (derived->components->name),\n \t\t\t\t gfc_typenode_for_spec (\n-\t\t\t\t   &(derived->components->ts)));\n+\t\t\t\t &(derived->components->ts)), NULL);\n \n       derived->ts.kind = gfc_index_integer_kind;\n       derived->ts.type = BT_INTEGER;\n@@ -2146,7 +2153,8 @@ gfc_get_derived_type (gfc_symbol * derived)\n \tfield_type = build_pointer_type (field_type);\n \n       field = gfc_add_field_to_struct (&fieldlist, typenode,\n-\t\t\t\t       get_identifier (c->name), field_type);\n+\t\t\t\t       get_identifier (c->name),\n+\t\t\t\t       field_type, &chain);\n       if (c->loc.lb)\n \tgfc_set_decl_location (field, &c->loc);\n       else if (derived->declared_at.lb)\n@@ -2224,8 +2232,8 @@ static tree\n gfc_get_mixed_entry_union (gfc_namespace *ns)\n {\n   tree type;\n-  tree decl;\n   tree fieldlist;\n+  tree *chain = NULL;\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_entry_list *el, *el2;\n \n@@ -2248,14 +2256,9 @@ gfc_get_mixed_entry_union (gfc_namespace *ns)\n \t  break;\n \n       if (el == el2)\n-\t{\n-\t  decl = build_decl (input_location,\n-\t\t\t     FIELD_DECL,\n-\t\t\t     get_identifier (el->sym->result->name),\n-\t\t\t     gfc_sym_type (el->sym->result));\n-\t  DECL_CONTEXT (decl) = type;\n-\t  fieldlist = chainon (fieldlist, decl);\n-\t}\n+\tgfc_add_field_to_struct_1 (&fieldlist, type,\n+\t\t\t\t   get_identifier (el->sym->result->name),\n+\t\t\t\t   gfc_sym_type (el->sym->result), &chain);\n     }\n \n   /* Finish off the type.  */"}, {"sha": "0949b77eac2abfe93bb9e8ec053009119c0ad7c6", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd6ece2cb3000d9882a7448b8e8ca379a9949b9/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd6ece2cb3000d9882a7448b8e8ca379a9949b9/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=dfd6ece2cb3000d9882a7448b8e8ca379a9949b9", "patch": "@@ -77,7 +77,7 @@ tree gfc_get_array_type_bounds (tree, int, int, tree *, tree *, int,\n tree gfc_get_nodesc_array_type (tree, gfc_array_spec *, gfc_packed, bool);\n \n /* Add a field of given name and type to a UNION_TYPE or RECORD_TYPE.  */\n-tree gfc_add_field_to_struct (tree *, tree, tree, tree);\n+tree gfc_add_field_to_struct (tree *, tree, tree, tree, tree **);\n \n /* Layout and output debugging info for a type.  */\n void gfc_finish_type (tree);"}]}