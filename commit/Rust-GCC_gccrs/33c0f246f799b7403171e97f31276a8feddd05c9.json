{"sha": "33c0f246f799b7403171e97f31276a8feddd05c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNjMGYyNDZmNzk5Yjc0MDMxNzFlOTdmMzEyNzZhOGZlZGRkMDVjOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-30T10:26:18Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-30T11:28:42Z"}, "message": "tree-optimization/97626 - handle SCCs properly in SLP stmt analysis\n\nThis makes sure to roll-back the whole SCC when we fail stmt\nanalysis, otherwise the optimistic visited treatment breaks down\nwith different entries.  Rollback is easy when tracking additions\nto visited in a vector which also makes the whole thing cheaper\nthan the two hash-sets used before.\n\n2020-10-30  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/97626\n\t* tree-vect-slp.c (vect_slp_analyze_node_operations):\n\tExchange the lvisited hash-set for a vector, roll back\n\trecursive adds to visited when analysis failed.\n\t(vect_slp_analyze_operations): Likewise.\n\n\t* gcc.dg/vect/bb-slp-pr97626.c: New testcase.", "tree": {"sha": "dcefa6830ca686873ca6eb113d6b45402c282517", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcefa6830ca686873ca6eb113d6b45402c282517"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33c0f246f799b7403171e97f31276a8feddd05c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33c0f246f799b7403171e97f31276a8feddd05c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33c0f246f799b7403171e97f31276a8feddd05c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33c0f246f799b7403171e97f31276a8feddd05c9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cafae2c5baf161d4cff83a5d089952fb9d3b7d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cafae2c5baf161d4cff83a5d089952fb9d3b7d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cafae2c5baf161d4cff83a5d089952fb9d3b7d3"}], "stats": {"total": 68, "additions": 55, "deletions": 13}, "files": [{"sha": "943d8a62de74673653200e40b0eef462bc37ffb4", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr97626.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c0f246f799b7403171e97f31276a8feddd05c9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr97626.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c0f246f799b7403171e97f31276a8feddd05c9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr97626.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr97626.c?ref=33c0f246f799b7403171e97f31276a8feddd05c9", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+\n+struct {\n+  int x;\n+  int y;\n+} do_plasma_rect;\n+\n+int do_plasma_context_0, do_plasma_x2, do_plasma_y2, do_plasma_plasma_depth,\n+    do_plasma_xm, do_plasma_ym;\n+void gegl_buffer_set();\n+\n+void do_plasma(int x1, int y1) {\n+  if (__builtin_expect(({\n+                         int _g_boolean_var_;\n+                         if (do_plasma_context_0)\n+                           _g_boolean_var_ = 1;\n+                         else\n+                           _g_boolean_var_ = 0;\n+                         _g_boolean_var_;\n+                       }),\n+                       0)) {\n+    do_plasma_rect.x = x1;\n+    do_plasma_rect.y = y1;\n+    gegl_buffer_set();\n+  }\n+  do_plasma_xm = (x1 + do_plasma_x2) / 2;\n+  do_plasma_ym = (y1 + do_plasma_y2) / 2;\n+  if (do_plasma_plasma_depth) {\n+    do_plasma_rect.x = do_plasma_xm;\n+    do_plasma_rect.y = do_plasma_ym;\n+    return;\n+  }\n+  do_plasma(do_plasma_xm, do_plasma_ym);\n+}"}, {"sha": "56dc59e11a668bf05d397f0ad6c1a215ba3ba5f1", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c0f246f799b7403171e97f31276a8feddd05c9/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c0f246f799b7403171e97f31276a8feddd05c9/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=33c0f246f799b7403171e97f31276a8feddd05c9", "patch": "@@ -3487,8 +3487,8 @@ vect_prologue_cost_for_slp (slp_tree node,\n static bool\n vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n \t\t\t\t  slp_instance node_instance,\n-\t\t\t\t  hash_set<slp_tree> &visited,\n-\t\t\t\t  hash_set<slp_tree> &lvisited,\n+\t\t\t\t  hash_set<slp_tree> &visited_set,\n+\t\t\t\t  vec<slp_tree> &visited_vec,\n \t\t\t\t  stmt_vector_for_cost *cost_vec)\n {\n   int i, j;\n@@ -3511,24 +3511,33 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n \n   /* If we already analyzed the exact same set of scalar stmts we're done.\n      We share the generated vector stmts for those.  */\n-  if (visited.contains (node)\n-      || lvisited.add (node))\n+  if (visited_set.add (node))\n     return true;\n+  visited_vec.safe_push (node);\n \n   bool res = true;\n+  unsigned visited_rec_start = visited_vec.length ();\n+  unsigned cost_vec_rec_start = cost_vec->length ();\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     {\n       res = vect_slp_analyze_node_operations (vinfo, child, node_instance,\n-\t\t\t\t\t      visited, lvisited, cost_vec);\n+\t\t\t\t\t      visited_set, visited_vec,\n+\t\t\t\t\t      cost_vec);\n       if (!res)\n \tbreak;\n     }\n \n   if (res)\n     res = vect_slp_analyze_node_operations_1 (vinfo, node, node_instance,\n \t\t\t\t\t      cost_vec);\n+  /* If analysis failed we have to pop all recursive visited nodes\n+     plus ourselves.  */\n   if (!res)\n-    lvisited.remove (node);\n+    {\n+      while (visited_vec.length () >= visited_rec_start)\n+\tvisited_set.remove (visited_vec.pop ());\n+      cost_vec->truncate (cost_vec_rec_start);\n+    }\n \n   /* When the node can be vectorized cost invariant nodes it references.\n      This is not done in DFS order to allow the refering node\n@@ -3543,9 +3552,9 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n \t  /* Perform usual caching, note code-generation still\n \t     code-gens these nodes multiple times but we expect\n \t     to CSE them later.  */\n-\t  && !visited.contains (child)\n-\t  && !lvisited.add (child))\n+\t  && !visited_set.add (child))\n \t{\n+\t  visited_vec.safe_push (child);\n \t  /* ???  After auditing more code paths make a \"default\"\n \t     and push the vector type from NODE to all children\n \t     if it is not already set.  */\n@@ -3705,14 +3714,14 @@ vect_slp_analyze_operations (vec_info *vinfo)\n   hash_set<slp_tree> visited;\n   for (i = 0; vinfo->slp_instances.iterate (i, &instance); )\n     {\n-      hash_set<slp_tree> lvisited;\n+      auto_vec<slp_tree> visited_vec;\n       stmt_vector_for_cost cost_vec;\n       cost_vec.create (2);\n       if (is_a <bb_vec_info> (vinfo))\n \tvect_location = instance->location ();\n       if (!vect_slp_analyze_node_operations (vinfo,\n \t\t\t\t\t     SLP_INSTANCE_TREE (instance),\n-\t\t\t\t\t     instance, visited, lvisited,\n+\t\t\t\t\t     instance, visited, visited_vec,\n \t\t\t\t\t     &cost_vec)\n \t  /* Instances with a root stmt require vectorized defs for the\n \t     SLP tree root.  */\n@@ -3729,12 +3738,11 @@ vect_slp_analyze_operations (vec_info *vinfo)\n \t  vect_free_slp_instance (instance);\n           vinfo->slp_instances.ordered_remove (i);\n \t  cost_vec.release ();\n+\t  while (!visited_vec.is_empty ())\n+\t    visited.remove (visited_vec.pop ());\n \t}\n       else\n \t{\n-\t  for (hash_set<slp_tree>::iterator x = lvisited.begin();\n-\t       x != lvisited.end(); ++x)\n-\t    visited.add (*x);\n \t  i++;\n \n \t  /* For BB vectorization remember the SLP graph entry"}]}