{"sha": "9f1363cd0d72667eac019840e929e64431ee5d4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWYxMzYzY2QwZDcyNjY3ZWFjMDE5ODQwZTkyOWU2NDQzMWVlNWQ0ZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-12-16T08:09:05Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-12-16T08:09:05Z"}, "message": "re PR middle-end/58956 (wrong code at -O1 and above (affecting gcc 4.6 to trunk))\n\n\tPR middle-end/58956\n\tPR middle-end/59470\n\t* gimple-walk.h (walk_stmt_load_store_addr_fn): New typedef.\n\t(walk_stmt_load_store_addr_ops, walk_stmt_load_store_ops): Use it\n\tfor callback params.\n\t* gimple-walk.c (walk_stmt_load_store_ops): Likewise.\n\t(walk_stmt_load_store_addr_ops): Likewise.  Adjust all callback\n\tcalls to supply the gimple operand containing the base tree\n\tas an extra argument.\n\t* tree-ssa-ter.c: Include gimple-walk.h.\n\t(find_ssaname, find_ssaname_in_store): New helper functions.\n\t(find_replaceable_in_bb): For calls or GIMPLE_ASM, only set\n\tsame_root_var if USE is used somewhere in the stores of the stmt.\n\t* ipa-prop.c (visit_ref_for_mod_analysis): Remove name of the stmt\n\targument and ATTRIBUTE_UNUSED, add another unnamed tree argument.\n\t* ipa-pure-const.c (check_load, check_store, check_ipa_load,\n\tcheck_ipa_store): Likewise.\n\t* gimple.c (gimple_ior_addresses_taken_1, check_loadstore): Likewise.\n\t* ipa-split.c (test_nonssa_use, mark_nonssa_use): Likewise.\n\t(verify_non_ssa_vars, visit_bb): Adjust their callers.\n\t* cfgexpand.c (add_scope_conflicts_1): Use\n\twalk_stmt_load_store_addr_fn type for visit variable.\n\t(visit_op, visit_conflict): Remove name of the stmt\n\targument and ATTRIBUTE_UNUSED, add another unnamed tree argument.\n\t* tree-sra.c (asm_visit_addr): Likewise.  Remove name of the data\n\targument and ATTRIBUTE_UNUSED.\n\t* cgraphbuild.c (mark_address, mark_load, mark_store): Add another\n\tunnamed tree argument.\n\t* gimple-ssa-isolate-paths.c (check_loadstore): Likewise.  Remove\n\tATTRIBUTE_UNUSED from stmt parameter.\n\n\t* gcc.target/i386/pr59470.c: New test.\n\nFrom-SVN: r206009", "tree": {"sha": "05010ae56236744b03a8fd2cb1415586dd321f47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05010ae56236744b03a8fd2cb1415586dd321f47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f1363cd0d72667eac019840e929e64431ee5d4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f1363cd0d72667eac019840e929e64431ee5d4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f1363cd0d72667eac019840e929e64431ee5d4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f1363cd0d72667eac019840e929e64431ee5d4e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "317c1849286a2acdf6e72bc2b0973d52b4ba5202", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/317c1849286a2acdf6e72bc2b0973d52b4ba5202", "html_url": "https://github.com/Rust-GCC/gccrs/commit/317c1849286a2acdf6e72bc2b0973d52b4ba5202"}], "stats": {"total": 251, "additions": 178, "deletions": 73}, "files": [{"sha": "95d657481322180a184f0ba72583c25b7e072a3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9f1363cd0d72667eac019840e929e64431ee5d4e", "patch": "@@ -1,3 +1,36 @@\n+2013-12-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/58956\n+\tPR middle-end/59470\n+\t* gimple-walk.h (walk_stmt_load_store_addr_fn): New typedef.\n+\t(walk_stmt_load_store_addr_ops, walk_stmt_load_store_ops): Use it\n+\tfor callback params.\n+\t* gimple-walk.c (walk_stmt_load_store_ops): Likewise.\n+\t(walk_stmt_load_store_addr_ops): Likewise.  Adjust all callback\n+\tcalls to supply the gimple operand containing the base tree\n+\tas an extra argument.\n+\t* tree-ssa-ter.c: Include gimple-walk.h.\n+\t(find_ssaname, find_ssaname_in_store): New helper functions.\n+\t(find_replaceable_in_bb): For calls or GIMPLE_ASM, only set\n+\tsame_root_var if USE is used somewhere in the stores of the stmt.\n+\t* ipa-prop.c (visit_ref_for_mod_analysis): Remove name of the stmt\n+\targument and ATTRIBUTE_UNUSED, add another unnamed tree argument.\n+\t* ipa-pure-const.c (check_load, check_store, check_ipa_load,\n+\tcheck_ipa_store): Likewise.\n+\t* gimple.c (gimple_ior_addresses_taken_1, check_loadstore): Likewise.\n+\t* ipa-split.c (test_nonssa_use, mark_nonssa_use): Likewise.\n+\t(verify_non_ssa_vars, visit_bb): Adjust their callers.\n+\t* cfgexpand.c (add_scope_conflicts_1): Use\n+\twalk_stmt_load_store_addr_fn type for visit variable.\n+\t(visit_op, visit_conflict): Remove name of the stmt\n+\targument and ATTRIBUTE_UNUSED, add another unnamed tree argument.\n+\t* tree-sra.c (asm_visit_addr): Likewise.  Remove name of the data\n+\targument and ATTRIBUTE_UNUSED.\n+\t* cgraphbuild.c (mark_address, mark_load, mark_store): Add another\n+\tunnamed tree argument.\n+\t* gimple-ssa-isolate-paths.c (check_loadstore): Likewise.  Remove\n+\tATTRIBUTE_UNUSED from stmt parameter.\n+\n 2013-12-16  Chung-Lin Tang  <cltang@codesourcery.com>\n \n \t* opts-common.c (integral_argument): Add support for"}, {"sha": "7a939753fdff2105e302baff40319bb5af7a8448", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=9f1363cd0d72667eac019840e929e64431ee5d4e", "patch": "@@ -365,7 +365,7 @@ stack_var_conflict_p (size_t x, size_t y)\n    enter its partition number into bitmap DATA.  */\n \n static bool\n-visit_op (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n+visit_op (gimple, tree op, tree, void *data)\n {\n   bitmap active = (bitmap)data;\n   op = get_base_address (op);\n@@ -385,7 +385,7 @@ visit_op (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n    from bitmap DATA.  */\n \n static bool\n-visit_conflict (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n+visit_conflict (gimple, tree op, tree, void *data)\n {\n   bitmap active = (bitmap)data;\n   op = get_base_address (op);\n@@ -419,7 +419,7 @@ add_scope_conflicts_1 (basic_block bb, bitmap work, bool for_conflict)\n   edge e;\n   edge_iterator ei;\n   gimple_stmt_iterator gsi;\n-  bool (*visit)(gimple, tree, void *);\n+  walk_stmt_load_store_addr_fn visit;\n \n   bitmap_clear (work);\n   FOR_EACH_EDGE (e, ei, bb->preds)"}, {"sha": "bf790b0fe61888884a4ed3d8711a13c1cf3a3b66", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=9f1363cd0d72667eac019840e929e64431ee5d4e", "patch": "@@ -224,7 +224,7 @@ compute_call_stmt_bb_frequency (tree decl, basic_block bb)\n /* Mark address taken in STMT.  */\n \n static bool\n-mark_address (gimple stmt, tree addr, void *data)\n+mark_address (gimple stmt, tree addr, tree, void *data)\n {\n   addr = get_base_address (addr);\n   if (TREE_CODE (addr) == FUNCTION_DECL)\n@@ -251,7 +251,7 @@ mark_address (gimple stmt, tree addr, void *data)\n /* Mark load of T.  */\n \n static bool\n-mark_load (gimple stmt, tree t, void *data)\n+mark_load (gimple stmt, tree t, tree, void *data)\n {\n   t = get_base_address (t);\n   if (t && TREE_CODE (t) == FUNCTION_DECL)\n@@ -279,7 +279,7 @@ mark_load (gimple stmt, tree t, void *data)\n /* Mark store of T.  */\n \n static bool\n-mark_store (gimple stmt, tree t, void *data)\n+mark_store (gimple stmt, tree t, tree, void *data)\n {\n   t = get_base_address (t);\n   if (t && TREE_CODE (t) == VAR_DECL"}, {"sha": "dd1f4f8502512d92e9147f3b609ee0a9b7e68a8b", "filename": "gcc/gimple-ssa-isolate-paths.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Fgimple-ssa-isolate-paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Fgimple-ssa-isolate-paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-isolate-paths.c?ref=9f1363cd0d72667eac019840e929e64431ee5d4e", "patch": "@@ -55,7 +55,7 @@ static bool cfg_altered;\n    This routine only makes a superficial check for a dereference.  Thus,\n    it must only be used if it is safe to return a false negative.  */\n static bool\n-check_loadstore (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n+check_loadstore (gimple stmt, tree op, tree, void *data)\n {\n   if ((TREE_CODE (op) == MEM_REF || TREE_CODE (op) == TARGET_MEM_REF)\n       && operand_equal_p (TREE_OPERAND (op, 0), (tree)data, 0))"}, {"sha": "1f8b2f4f0e7f8a534cf2ee78f1999d9ebdfe32fd", "filename": "gcc/gimple-walk.c", "status": "modified", "additions": 50, "deletions": 44, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Fgimple-walk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Fgimple-walk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-walk.c?ref=9f1363cd0d72667eac019840e929e64431ee5d4e", "patch": "@@ -649,66 +649,70 @@ get_base_loadstore (tree op)\n \n /* For the statement STMT call the callbacks VISIT_LOAD, VISIT_STORE and\n    VISIT_ADDR if non-NULL on loads, store and address-taken operands\n-   passing the STMT, the base of the operand and DATA to it.  The base\n-   will be either a decl, an indirect reference (including TARGET_MEM_REF)\n-   or the argument of an address expression.\n+   passing the STMT, the base of the operand, the operand itself containing\n+   the base and DATA to it.  The base will be either a decl, an indirect\n+   reference (including TARGET_MEM_REF) or the argument of an address\n+   expression.\n    Returns the results of these callbacks or'ed.  */\n \n bool\n walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n-\t\t\t       bool (*visit_load)(gimple, tree, void *),\n-\t\t\t       bool (*visit_store)(gimple, tree, void *),\n-\t\t\t       bool (*visit_addr)(gimple, tree, void *))\n+\t\t\t       walk_stmt_load_store_addr_fn visit_load,\n+\t\t\t       walk_stmt_load_store_addr_fn visit_store,\n+\t\t\t       walk_stmt_load_store_addr_fn visit_addr)\n {\n   bool ret = false;\n   unsigned i;\n   if (gimple_assign_single_p (stmt))\n     {\n-      tree lhs, rhs;\n+      tree lhs, rhs, arg;\n       if (visit_store)\n \t{\n-\t  lhs = get_base_loadstore (gimple_assign_lhs (stmt));\n+\t  arg = gimple_assign_lhs (stmt);\n+\t  lhs = get_base_loadstore (arg);\n \t  if (lhs)\n-\t    ret |= visit_store (stmt, lhs, data);\n+\t    ret |= visit_store (stmt, lhs, arg, data);\n \t}\n-      rhs = gimple_assign_rhs1 (stmt);\n+      arg = gimple_assign_rhs1 (stmt);\n+      rhs = arg;\n       while (handled_component_p (rhs))\n \trhs = TREE_OPERAND (rhs, 0);\n       if (visit_addr)\n \t{\n \t  if (TREE_CODE (rhs) == ADDR_EXPR)\n-\t    ret |= visit_addr (stmt, TREE_OPERAND (rhs, 0), data);\n+\t    ret |= visit_addr (stmt, TREE_OPERAND (rhs, 0), arg, data);\n \t  else if (TREE_CODE (rhs) == TARGET_MEM_REF\n \t\t   && TREE_CODE (TMR_BASE (rhs)) == ADDR_EXPR)\n-\t    ret |= visit_addr (stmt, TREE_OPERAND (TMR_BASE (rhs), 0), data);\n+\t    ret |= visit_addr (stmt, TREE_OPERAND (TMR_BASE (rhs), 0), arg,\n+\t\t\t       data);\n \t  else if (TREE_CODE (rhs) == OBJ_TYPE_REF\n \t\t   && TREE_CODE (OBJ_TYPE_REF_OBJECT (rhs)) == ADDR_EXPR)\n \t    ret |= visit_addr (stmt, TREE_OPERAND (OBJ_TYPE_REF_OBJECT (rhs),\n-\t\t\t\t\t\t   0), data);\n+\t\t\t\t\t\t   0), arg, data);\n \t  else if (TREE_CODE (rhs) == CONSTRUCTOR)\n \t    {\n \t      unsigned int ix;\n \t      tree val;\n \n \t      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (rhs), ix, val)\n \t\tif (TREE_CODE (val) == ADDR_EXPR)\n-\t\t  ret |= visit_addr (stmt, TREE_OPERAND (val, 0), data);\n+\t\t  ret |= visit_addr (stmt, TREE_OPERAND (val, 0), arg, data);\n \t\telse if (TREE_CODE (val) == OBJ_TYPE_REF\n \t\t\t && TREE_CODE (OBJ_TYPE_REF_OBJECT (val)) == ADDR_EXPR)\n \t\t  ret |= visit_addr (stmt,\n \t\t\t\t     TREE_OPERAND (OBJ_TYPE_REF_OBJECT (val),\n-\t\t\t\t\t\t   0), data);\n+\t\t\t\t\t\t   0), arg, data);\n \t    }\n           lhs = gimple_assign_lhs (stmt);\n \t  if (TREE_CODE (lhs) == TARGET_MEM_REF\n               && TREE_CODE (TMR_BASE (lhs)) == ADDR_EXPR)\n-            ret |= visit_addr (stmt, TREE_OPERAND (TMR_BASE (lhs), 0), data);\n+\t    ret |= visit_addr (stmt, TREE_OPERAND (TMR_BASE (lhs), 0), lhs, data);\n \t}\n       if (visit_load)\n \t{\n \t  rhs = get_base_loadstore (rhs);\n \t  if (rhs)\n-\t    ret |= visit_load (stmt, rhs, data);\n+\t    ret |= visit_load (stmt, rhs, arg, data);\n \t}\n     }\n   else if (visit_addr\n@@ -721,56 +725,57 @@ walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n \t  if (op == NULL_TREE)\n \t    ;\n \t  else if (TREE_CODE (op) == ADDR_EXPR)\n-\t    ret |= visit_addr (stmt, TREE_OPERAND (op, 0), data);\n+\t    ret |= visit_addr (stmt, TREE_OPERAND (op, 0), op, data);\n \t  /* COND_EXPR and VCOND_EXPR rhs1 argument is a comparison\n \t     tree with two operands.  */\n \t  else if (i == 1 && COMPARISON_CLASS_P (op))\n \t    {\n \t      if (TREE_CODE (TREE_OPERAND (op, 0)) == ADDR_EXPR)\n \t\tret |= visit_addr (stmt, TREE_OPERAND (TREE_OPERAND (op, 0),\n-\t\t\t\t\t\t       0), data);\n+\t\t\t\t\t\t       0), op, data);\n \t      if (TREE_CODE (TREE_OPERAND (op, 1)) == ADDR_EXPR)\n \t\tret |= visit_addr (stmt, TREE_OPERAND (TREE_OPERAND (op, 1),\n-\t\t\t\t\t\t       0), data);\n+\t\t\t\t\t\t       0), op, data);\n \t    }\n \t}\n     }\n   else if (is_gimple_call (stmt))\n     {\n       if (visit_store)\n \t{\n-\t  tree lhs = gimple_call_lhs (stmt);\n-\t  if (lhs)\n+\t  tree arg = gimple_call_lhs (stmt);\n+\t  if (arg)\n \t    {\n-\t      lhs = get_base_loadstore (lhs);\n+\t      tree lhs = get_base_loadstore (arg);\n \t      if (lhs)\n-\t\tret |= visit_store (stmt, lhs, data);\n+\t\tret |= visit_store (stmt, lhs, arg, data);\n \t    }\n \t}\n       if (visit_load || visit_addr)\n \tfor (i = 0; i < gimple_call_num_args (stmt); ++i)\n \t  {\n-\t    tree rhs = gimple_call_arg (stmt, i);\n+\t    tree arg = gimple_call_arg (stmt, i);\n \t    if (visit_addr\n-\t\t&& TREE_CODE (rhs) == ADDR_EXPR)\n-\t      ret |= visit_addr (stmt, TREE_OPERAND (rhs, 0), data);\n+\t\t&& TREE_CODE (arg) == ADDR_EXPR)\n+\t      ret |= visit_addr (stmt, TREE_OPERAND (arg, 0), arg, data);\n \t    else if (visit_load)\n \t      {\n-\t\trhs = get_base_loadstore (rhs);\n+\t\ttree rhs = get_base_loadstore (arg);\n \t\tif (rhs)\n-\t\t  ret |= visit_load (stmt, rhs, data);\n+\t\t  ret |= visit_load (stmt, rhs, arg, data);\n \t      }\n \t  }\n       if (visit_addr\n \t  && gimple_call_chain (stmt)\n \t  && TREE_CODE (gimple_call_chain (stmt)) == ADDR_EXPR)\n \tret |= visit_addr (stmt, TREE_OPERAND (gimple_call_chain (stmt), 0),\n-\t\t\t   data);\n+\t\t\t   gimple_call_chain (stmt), data);\n       if (visit_addr\n \t  && gimple_call_return_slot_opt_p (stmt)\n \t  && gimple_call_lhs (stmt) != NULL_TREE\n \t  && TREE_ADDRESSABLE (TREE_TYPE (gimple_call_lhs (stmt))))\n-\tret |= visit_addr (stmt, gimple_call_lhs (stmt), data);\n+\tret |= visit_addr (stmt, gimple_call_lhs (stmt),\n+\t\t\t   gimple_call_lhs (stmt), data);\n     }\n   else if (gimple_code (stmt) == GIMPLE_ASM)\n     {\n@@ -786,7 +791,7 @@ walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n \t    tree link = gimple_asm_output_op (stmt, i);\n \t    tree op = get_base_loadstore (TREE_VALUE (link));\n \t    if (op && visit_store)\n-\t      ret |= visit_store (stmt, op, data);\n+\t      ret |= visit_store (stmt, op, TREE_VALUE (link), data);\n \t    if (visit_addr)\n \t      {\n \t\tconstraint = TREE_STRING_POINTER\n@@ -795,7 +800,7 @@ walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n \t\tparse_output_constraint (&constraint, i, 0, 0, &allows_mem,\n \t\t\t\t\t &allows_reg, &is_inout);\n \t\tif (op && !allows_reg && allows_mem)\n-\t\t  ret |= visit_addr (stmt, op, data);\n+\t\t  ret |= visit_addr (stmt, op, TREE_VALUE (link), data);\n \t      }\n \t  }\n       if (visit_load || visit_addr)\n@@ -805,14 +810,14 @@ walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n \t    tree op = TREE_VALUE (link);\n \t    if (visit_addr\n \t\t&& TREE_CODE (op) == ADDR_EXPR)\n-\t      ret |= visit_addr (stmt, TREE_OPERAND (op, 0), data);\n+\t      ret |= visit_addr (stmt, TREE_OPERAND (op, 0), op, data);\n \t    else if (visit_load || visit_addr)\n \t      {\n \t\top = get_base_loadstore (op);\n \t\tif (op)\n \t\t  {\n \t\t    if (visit_load)\n-\t\t      ret |= visit_load (stmt, op, data);\n+\t\t      ret |= visit_load (stmt, op, TREE_VALUE (link), data);\n \t\t    if (visit_addr)\n \t\t      {\n \t\t\tconstraint = TREE_STRING_POINTER\n@@ -821,7 +826,8 @@ walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n \t\t\t\t\t\t0, oconstraints,\n \t\t\t\t\t\t&allows_mem, &allows_reg);\n \t\t\tif (!allows_reg && allows_mem)\n-\t\t\t  ret |= visit_addr (stmt, op, data);\n+\t\t\t  ret |= visit_addr (stmt, op, TREE_VALUE (link),\n+\t\t\t\t\t     data);\n \t\t      }\n \t\t  }\n \t      }\n@@ -834,12 +840,12 @@ walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n \t{\n \t  if (visit_addr\n \t      && TREE_CODE (op) == ADDR_EXPR)\n-\t    ret |= visit_addr (stmt, TREE_OPERAND (op, 0), data);\n+\t    ret |= visit_addr (stmt, TREE_OPERAND (op, 0), op, data);\n \t  else if (visit_load)\n \t    {\n-\t      op = get_base_loadstore (op);\n-\t      if (op)\n-\t\tret |= visit_load (stmt, op, data);\n+\t      tree base = get_base_loadstore (op);\n+\t      if (base)\n+\t\tret |= visit_load (stmt, base, op, data);\n \t    }\n \t}\n     }\n@@ -850,15 +856,15 @@ walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n \t{\n \t  tree op = gimple_phi_arg_def (stmt, i);\n \t  if (TREE_CODE (op) == ADDR_EXPR)\n-\t    ret |= visit_addr (stmt, TREE_OPERAND (op, 0), data);\n+\t    ret |= visit_addr (stmt, TREE_OPERAND (op, 0), op, data);\n \t}\n     }\n   else if (visit_addr\n \t   && gimple_code (stmt) == GIMPLE_GOTO)\n     {\n       tree op = gimple_goto_dest (stmt);\n       if (TREE_CODE (op) == ADDR_EXPR)\n-\tret |= visit_addr (stmt, TREE_OPERAND (op, 0), data);\n+\tret |= visit_addr (stmt, TREE_OPERAND (op, 0), op, data);\n     }\n \n   return ret;\n@@ -869,8 +875,8 @@ walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n \n bool\n walk_stmt_load_store_ops (gimple stmt, void *data,\n-\t\t\t  bool (*visit_load)(gimple, tree, void *),\n-\t\t\t  bool (*visit_store)(gimple, tree, void *))\n+\t\t\t  walk_stmt_load_store_addr_fn visit_load,\n+\t\t\t  walk_stmt_load_store_addr_fn visit_store)\n {\n   return walk_stmt_load_store_addr_ops (stmt, data,\n \t\t\t\t\tvisit_load, visit_store, NULL);"}, {"sha": "82982e48b1a97a3a2012b8245ee444fe36e87ee0", "filename": "gcc/gimple-walk.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Fgimple-walk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Fgimple-walk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-walk.h?ref=9f1363cd0d72667eac019840e929e64431ee5d4e", "patch": "@@ -89,11 +89,12 @@ extern gimple walk_gimple_seq (gimple_seq, walk_stmt_fn, walk_tree_fn,\n extern tree walk_gimple_op (gimple, walk_tree_fn, struct walk_stmt_info *);\n extern tree walk_gimple_stmt (gimple_stmt_iterator *, walk_stmt_fn,\n \t\t\t      walk_tree_fn, struct walk_stmt_info *);\n+typedef bool (*walk_stmt_load_store_addr_fn) (gimple, tree, tree, void *);\n extern bool walk_stmt_load_store_addr_ops (gimple, void *,\n-\t\t\t\t\t   bool (*)(gimple, tree, void *),\n-\t\t\t\t\t   bool (*)(gimple, tree, void *),\n-\t\t\t\t\t   bool (*)(gimple, tree, void *));\n+\t\t\t\t\t   walk_stmt_load_store_addr_fn,\n+\t\t\t\t\t   walk_stmt_load_store_addr_fn,\n+\t\t\t\t\t   walk_stmt_load_store_addr_fn);\n extern bool walk_stmt_load_store_ops (gimple, void *,\n-\t\t\t\t      bool (*)(gimple, tree, void *),\n-\t\t\t\t      bool (*)(gimple, tree, void *));\n+\t\t\t\t      walk_stmt_load_store_addr_fn,\n+\t\t\t\t      walk_stmt_load_store_addr_fn);\n #endif /* GCC_GIMPLE_WALK_H */"}, {"sha": "38e209fabc9d9bfc8d5adc147c59b759c2fa8003", "filename": "gcc/gimple.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=9f1363cd0d72667eac019840e929e64431ee5d4e", "patch": "@@ -2326,8 +2326,7 @@ gimple_get_alias_set (tree t)\n /* Helper for gimple_ior_addresses_taken_1.  */\n \n static bool\n-gimple_ior_addresses_taken_1 (gimple stmt ATTRIBUTE_UNUSED,\n-\t\t\t      tree addr, void *data)\n+gimple_ior_addresses_taken_1 (gimple, tree addr, tree, void *data)\n {\n   bitmap addresses_taken = (bitmap)data;\n   addr = get_base_address (addr);\n@@ -2496,7 +2495,7 @@ nonfreeing_call_p (gimple call)\n    This routine only makes a superficial check for a dereference.  Thus\n    it must only be used if it is safe to return a false negative.  */\n static bool\n-check_loadstore (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n+check_loadstore (gimple, tree op, tree, void *data)\n {\n   if ((TREE_CODE (op) == MEM_REF || TREE_CODE (op) == TARGET_MEM_REF)\n       && operand_equal_p (TREE_OPERAND (op, 0), (tree)data, 0))"}, {"sha": "5a337f7ce3e3ea2a07da1f269ba8b10ae201c3c8", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=9f1363cd0d72667eac019840e929e64431ee5d4e", "patch": "@@ -2061,8 +2061,7 @@ ipa_analyze_stmt_uses (struct cgraph_node *node, struct ipa_node_params *info,\n    passed in DATA.  */\n \n static bool\n-visit_ref_for_mod_analysis (gimple stmt ATTRIBUTE_UNUSED,\n-\t\t\t     tree op, void *data)\n+visit_ref_for_mod_analysis (gimple, tree op, tree, void *data)\n {\n   struct ipa_node_params *info = (struct ipa_node_params *) data;\n "}, {"sha": "fd10fe357f029cfb7ffb9265ffea519de9de1b44", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=9f1363cd0d72667eac019840e929e64431ee5d4e", "patch": "@@ -589,7 +589,7 @@ check_call (funct_state local, gimple call, bool ipa)\n /* Wrapper around check_decl for loads in local more.  */\n \n static bool\n-check_load (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n+check_load (gimple, tree op, tree, void *data)\n {\n   if (DECL_P (op))\n     check_decl ((funct_state)data, op, false, false);\n@@ -601,7 +601,7 @@ check_load (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n /* Wrapper around check_decl for stores in local more.  */\n \n static bool\n-check_store (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n+check_store (gimple, tree op, tree, void *data)\n {\n   if (DECL_P (op))\n     check_decl ((funct_state)data, op, true, false);\n@@ -613,7 +613,7 @@ check_store (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n /* Wrapper around check_decl for loads in ipa mode.  */\n \n static bool\n-check_ipa_load (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n+check_ipa_load (gimple, tree op, tree, void *data)\n {\n   if (DECL_P (op))\n     check_decl ((funct_state)data, op, false, true);\n@@ -625,7 +625,7 @@ check_ipa_load (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n /* Wrapper around check_decl for stores in ipa mode.  */\n \n static bool\n-check_ipa_store (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n+check_ipa_store (gimple, tree op, tree, void *data)\n {\n   if (DECL_P (op))\n     check_decl ((funct_state)data, op, true, true);"}, {"sha": "6d9334882ed39d7d128d3d9d8b5fa98a1e9f63f0", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=9f1363cd0d72667eac019840e929e64431ee5d4e", "patch": "@@ -156,7 +156,7 @@ static tree find_retval (basic_block return_bb);\n    variable, check it if it is present in bitmap passed via DATA.  */\n \n static bool\n-test_nonssa_use (gimple stmt ATTRIBUTE_UNUSED, tree t, void *data)\n+test_nonssa_use (gimple, tree t, tree, void *data)\n {\n   t = get_base_address (t);\n \n@@ -249,7 +249,7 @@ verify_non_ssa_vars (struct split_point *current, bitmap non_ssa_vars,\n \t    }\n \t  if (gimple_code (stmt) == GIMPLE_LABEL\n \t      && test_nonssa_use (stmt, gimple_label_label (stmt),\n-\t\t\t\t  non_ssa_vars))\n+\t\t\t\t  NULL_TREE, non_ssa_vars))\n \t  {\n \t    ok = false;\n \t    goto done;\n@@ -278,7 +278,7 @@ verify_non_ssa_vars (struct split_point *current, bitmap non_ssa_vars,\n \t      if (virtual_operand_p (gimple_phi_result (stmt)))\n \t\tcontinue;\n \t      if (TREE_CODE (op) != SSA_NAME\n-\t\t  && test_nonssa_use (stmt, op, non_ssa_vars))\n+\t\t  && test_nonssa_use (stmt, op, op, non_ssa_vars))\n \t\t{\n \t\t  ok = false;\n \t\t  goto done;\n@@ -714,7 +714,7 @@ find_retval (basic_block return_bb)\n    Return true when access to T prevents splitting the function.  */\n \n static bool\n-mark_nonssa_use (gimple stmt ATTRIBUTE_UNUSED, tree t, void *data)\n+mark_nonssa_use (gimple, tree t, tree, void *data)\n {\n   t = get_base_address (t);\n \n@@ -874,7 +874,7 @@ visit_bb (basic_block bb, basic_block return_bb,\n \t    if (TREE_CODE (op) == SSA_NAME)\n \t      bitmap_set_bit (used_ssa_names, SSA_NAME_VERSION (op));\n \t    else\n-\t      can_split &= !mark_nonssa_use (stmt, op, non_ssa_vars);\n+\t      can_split &= !mark_nonssa_use (stmt, op, op, non_ssa_vars);\n \t  }\n       }\n   return can_split;"}, {"sha": "e7c54bc2898fbed7394a0e5c4a4cb986b698c2d9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9f1363cd0d72667eac019840e929e64431ee5d4e", "patch": "@@ -1,3 +1,9 @@\n+2013-12-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/58956\n+\tPR middle-end/59470\n+\t* gcc.target/i386/pr59470.c: New test.\n+\n 2013-12-14   Jan Hubicka  <jh@suse.cz>\n \n \tPR ipa/59265"}, {"sha": "0d9952fb4b0b626a3aeb9e15ab1fc011317ec47a", "filename": "gcc/testsuite/gcc.target/i386/pr59470.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr59470.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr59470.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr59470.c?ref=9f1363cd0d72667eac019840e929e64431ee5d4e", "patch": "@@ -0,0 +1,17 @@\n+/* PR middle-end/58956 */\n+/* PR middle-end/59470 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+int a, b, d[1024];\n+\n+int\n+main ()\n+{\n+  int c = a;\n+  asm (\"{movl $6, (%2); movl $1, %0|mov dword ptr [%2], 6; mov %0, 1}\"\n+       : \"=r\" (d[c]) : \"rm\" (b), \"r\" (&a) : \"memory\");\n+  if (d[0] != 1 || d[6] != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "47765416e68e13216f5d3fec9d42f969d16d8974", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=9f1363cd0d72667eac019840e929e64431ee5d4e", "patch": "@@ -1223,8 +1223,7 @@ build_accesses_from_assign (gimple stmt)\n    GIMPLE_ASM operands with memory constrains which cannot be scalarized.  */\n \n static bool\n-asm_visit_addr (gimple stmt ATTRIBUTE_UNUSED, tree op,\n-\t\tvoid *data ATTRIBUTE_UNUSED)\n+asm_visit_addr (gimple, tree op, tree, void *)\n {\n   op = get_base_address (op);\n   if (op"}, {"sha": "cefe47c6d5f3c9d6b149ab5f2f4baac1808b5748", "filename": "gcc/tree-ssa-ter.c", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Ftree-ssa-ter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f1363cd0d72667eac019840e929e64431ee5d4e/gcc%2Ftree-ssa-ter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ter.c?ref=9f1363cd0d72667eac019840e929e64431ee5d4e", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-ter.h\"\n #include \"tree-outof-ssa.h\"\n #include \"flags.h\"\n+#include \"gimple-walk.h\"\n \n \n /* Temporary Expression Replacement (TER)\n@@ -554,6 +555,30 @@ mark_replaceable (temp_expr_table_p tab, tree var, bool more_replacing)\n }\n \n \n+/* Helper function for find_ssaname_in_stores.  Called via walk_tree to\n+   find a SSA_NAME DATA somewhere in *TP.  */\n+\n+static tree\n+find_ssaname (tree *tp, int *walk_subtrees, void *data)\n+{\n+  tree var = (tree) data;\n+  if (*tp == var)\n+    return var;\n+  else if (IS_TYPE_OR_DECL_P (*tp))\n+    *walk_subtrees = 0;\n+  return NULL_TREE;\n+}\n+\n+/* Helper function for find_replaceable_in_bb.  Return true if SSA_NAME DATA\n+   is used somewhere in T, which is a store in the statement.  Called via\n+   walk_stmt_load_store_addr_ops.  */\n+\n+static bool\n+find_ssaname_in_store (gimple, tree, tree t, void *data)\n+{\n+  return walk_tree (&t, find_ssaname, data, NULL) != NULL_TREE;\n+}\n+\n /* This function processes basic block BB, and looks for variables which can\n    be replaced by their expressions.  Results are stored in the table TAB.  */\n \n@@ -618,7 +643,27 @@ find_replaceable_in_bb (temp_expr_table_p tab, basic_block bb)\n \t\t      && gimple_assign_single_p (def_stmt)\n \t\t      && stmt_may_clobber_ref_p (stmt,\n \t\t\t\t\t\t gimple_assign_rhs1 (def_stmt)))\n-\t\t    same_root_var = true;\n+\t\t    {\n+\t\t      /* For calls, it is not a problem if USE is among\n+\t\t\t call's arguments or say OBJ_TYPE_REF argument,\n+\t\t\t all those necessarily need to be evaluated before\n+\t\t\t the call that may clobber the memory.  But if\n+\t\t\t LHS of the call refers to USE, expansion might\n+\t\t\t evaluate it after the call, prevent TER in that\n+\t\t\t case.\n+\t\t\t For inline asm, allow TER of loads into input\n+\t\t\t arguments, but disallow TER for USEs that occur\n+\t\t\t somewhere in outputs.  */\n+\t\t      if (is_gimple_call (stmt)\n+\t\t\t  || gimple_code (stmt) == GIMPLE_ASM)\n+\t\t\t{\n+\t\t\t  if (walk_stmt_load_store_ops (stmt, use, NULL,\n+\t\t\t\t\t\t\tfind_ssaname_in_store))\n+\t\t\t    same_root_var = true;\n+\t\t\t}\n+\t\t      else\n+\t\t\tsame_root_var = true;\n+\t\t    }\n \t\t}\n \n \t      /* Mark expression as replaceable unless stmt is volatile, or the"}]}