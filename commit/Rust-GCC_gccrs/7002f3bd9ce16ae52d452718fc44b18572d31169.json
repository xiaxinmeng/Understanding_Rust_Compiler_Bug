{"sha": "7002f3bd9ce16ae52d452718fc44b18572d31169", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAwMmYzYmQ5Y2UxNmFlNTJkNDUyNzE4ZmM0NGIxODU3MmQzMTE2OQ==", "commit": {"author": {"name": "Igor Zamyatin", "email": "igor.zamyatin@intel.com", "date": "2015-01-20T08:29:09Z"}, "committer": {"name": "Ilya Enkovich", "email": "ienkovich@gcc.gnu.org", "date": "2015-01-20T08:29:09Z"}, "message": "re PR bootstrap/64676 (SEGV in tree-ssa-structalias.c solve_constraint)\n\ngcc/\n\n\tPR bootstrap/64676\n\tRevert:\n\t2015-01-19  Igor Zamyatin  <igor.zamyatin@intel.com>\n\n\tPR rtl-optimization/64081\n\t* loop-iv.c (def_pred_latch_p): New function.\n\t(latch_dominating_def): Allow specific cases with non-single\n\tdefinitions.\n\t(iv_get_reaching_def): Likewise.\n\t(check_complex_exit_p): New function.\n\t(check_simple_exit): Use check_complex_exit_p to allow certain cases\n\twith exits not executing on any iteration.\n\ngcc/testsuite/\n\n\tPR bootstrap/64676\n\tRevert:\n\t2014-01-19  Igor Zamyatin  <igor.zamyatin@intel.com>\n\n\tPR rtl-optimization/64081\n\t* gcc.dg/pr64081.c: New test.\n\nFrom-SVN: r219880", "tree": {"sha": "795636fd50f97efcf92b36580bc45b8c20d812a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/795636fd50f97efcf92b36580bc45b8c20d812a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7002f3bd9ce16ae52d452718fc44b18572d31169", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7002f3bd9ce16ae52d452718fc44b18572d31169", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7002f3bd9ce16ae52d452718fc44b18572d31169", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7002f3bd9ce16ae52d452718fc44b18572d31169/comments", "author": {"login": "Garra1980", "id": 25365940, "node_id": "MDQ6VXNlcjI1MzY1OTQw", "avatar_url": "https://avatars.githubusercontent.com/u/25365940?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Garra1980", "html_url": "https://github.com/Garra1980", "followers_url": "https://api.github.com/users/Garra1980/followers", "following_url": "https://api.github.com/users/Garra1980/following{/other_user}", "gists_url": "https://api.github.com/users/Garra1980/gists{/gist_id}", "starred_url": "https://api.github.com/users/Garra1980/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Garra1980/subscriptions", "organizations_url": "https://api.github.com/users/Garra1980/orgs", "repos_url": "https://api.github.com/users/Garra1980/repos", "events_url": "https://api.github.com/users/Garra1980/events{/privacy}", "received_events_url": "https://api.github.com/users/Garra1980/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a5fcfb6df9ad330f16233739216eca00ee7efa1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5fcfb6df9ad330f16233739216eca00ee7efa1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5fcfb6df9ad330f16233739216eca00ee7efa1f"}], "stats": {"total": 192, "additions": 39, "deletions": 153}, "files": [{"sha": "1879743fd0ca99e24b0b97a3b6281ef202e0e54c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7002f3bd9ce16ae52d452718fc44b18572d31169/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7002f3bd9ce16ae52d452718fc44b18572d31169/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7002f3bd9ce16ae52d452718fc44b18572d31169", "patch": "@@ -1,3 +1,18 @@\n+2015-01-20  Igor Zamyatin  <igor.zamyatin@intel.com>\n+\n+\tPR bootstrap/64676\n+\tRevert:\n+\t2015-01-19  Igor Zamyatin  <igor.zamyatin@intel.com>\n+\n+\tPR rtl-optimization/64081\n+\t* loop-iv.c (def_pred_latch_p): New function.\n+\t(latch_dominating_def): Allow specific cases with non-single\n+\tdefinitions.\n+\t(iv_get_reaching_def): Likewise.\n+\t(check_complex_exit_p): New function.\n+\t(check_simple_exit): Use check_complex_exit_p to allow certain cases\n+\twith exits not executing on any iteration.\n+\n 2015-01-19  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR lto/45375"}, {"sha": "de2b15a8fef734a0cbf53b798959852dbf3f0990", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 15, "deletions": 112, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7002f3bd9ce16ae52d452718fc44b18572d31169/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7002f3bd9ce16ae52d452718fc44b18572d31169/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=7002f3bd9ce16ae52d452718fc44b18572d31169", "patch": "@@ -332,72 +332,34 @@ iv_analysis_loop_init (struct loop *loop)\n   check_iv_ref_table_size ();\n }\n \n-/* Return true if D_REF is defined in an immediate predecessor of the\n-   current loop's latch block.  Otherwise return false.  */\n-\n-static bool\n-def_pred_latch_p (df_ref d_ref)\n-{\n-  basic_block bb = DF_REF_BB (d_ref);\n-  edge_iterator ei;\n-  edge e;\n-\n-  FOR_EACH_EDGE (e, ei, current_loop->latch->preds)\n-    {\n-      if (e->src == bb)\n-\treturn true;\n-    }\n-  return false;\n-}\n-\n /* Finds the definition of REG that dominates loop latch and stores\n    it to DEF.  Returns false if there is not a single definition\n-   dominating the latch or all defs are same and they are on different\n-   predecessors of loop latch.  If REG has no definition in loop, DEF\n+   dominating the latch.  If REG has no definition in loop, DEF\n    is set to NULL and true is returned.  */\n \n static bool\n latch_dominating_def (rtx reg, df_ref *def)\n {\n   df_ref single_rd = NULL, adef;\n-  unsigned regno = REGNO (reg), def_num = 0;\n+  unsigned regno = REGNO (reg);\n   struct df_rd_bb_info *bb_info = DF_RD_BB_INFO (current_loop->latch);\n \n   for (adef = DF_REG_DEF_CHAIN (regno); adef; adef = DF_REF_NEXT_REG (adef))\n     {\n-      /* Initialize this to true for the very first iteration when\n-\t SINGLE_RD is NULL.  */\n-      bool def_pred_latch = true;\n-\n       if (!bitmap_bit_p (df->blocks_to_analyze, DF_REF_BBNO (adef))\n \t  || !bitmap_bit_p (&bb_info->out, DF_REF_ID (adef)))\n \tcontinue;\n \n-      /* More than one reaching definition is ok in case definitions are\n-\t in predecessors of latch block and those definitions are the same.\n-\t Probably this could be relaxed and check for sub-dominance instead\n-\t predecessor.  */\n-      def_num++;\n+      /* More than one reaching definition.  */\n       if (single_rd)\n-\t{\n-\t  if (!(def_pred_latch = def_pred_latch_p (adef))\n-\t      || !rtx_equal_p (PATTERN (DF_REF_INSN (single_rd)),\n-\t\t\t       PATTERN (DF_REF_INSN (adef))))\n-\t    return false;\n-\t}\n+\treturn false;\n+\n+      if (!just_once_each_iteration_p (current_loop, DF_REF_BB (adef)))\n+\treturn false;\n \n       single_rd = adef;\n     }\n \n-  /* If we have single definition it has to be executed on each iteration.  */\n-  if ((def_num == 1) && single_rd\n-      && !just_once_each_iteration_p (current_loop, DF_REF_BB (single_rd)))\n-    return false;\n-\n-  /* Make sure all preds contain definitions.  */\n-  if (def_num != EDGE_COUNT (current_loop->latch->preds))\n-    return false;\n-\n   *def = single_rd;\n   return true;\n }\n@@ -407,10 +369,10 @@ latch_dominating_def (rtx reg, df_ref *def)\n static enum iv_grd_result\n iv_get_reaching_def (rtx_insn *insn, rtx reg, df_ref *def)\n {\n-  df_ref use, adef = NULL;\n+  df_ref use, adef;\n   basic_block def_bb, use_bb;\n   rtx_insn *def_insn;\n-  bool dom_p, dom_latch_p = false;\n+  bool dom_p;\n \n   *def = NULL;\n   if (!simple_reg_p (reg))\n@@ -425,26 +387,11 @@ iv_get_reaching_def (rtx_insn *insn, rtx reg, df_ref *def)\n   if (!DF_REF_CHAIN (use))\n     return GRD_INVARIANT;\n \n-  adef = DF_REF_CHAIN (use)->ref;\n-  /* Having more than one reaching def is ok once all defs are in blocks which\n-     are latch's predecessors.  */\n+  /* More than one reaching def.  */\n   if (DF_REF_CHAIN (use)->next)\n-    {\n-      df_link* defs;\n-      unsigned int def_num = 0;\n-\n-      for (defs = DF_REF_CHAIN (use); defs; defs = defs->next)\n-\t{\n-\t  if (!def_pred_latch_p (defs->ref))\n-\t    return GRD_INVALID;\n-\t  def_num++;\n-\t}\n-      /* Make sure all preds contain definitions.  */\n-      if (def_num != EDGE_COUNT (current_loop->latch->preds))\n-\treturn GRD_INVALID;\n+    return GRD_INVALID;\n \n-      dom_latch_p = true;\n-    }\n+  adef = DF_REF_CHAIN (use)->ref;\n \n   /* We do not handle setting only part of the register.  */\n   if (DF_REF_FLAGS (adef) & DF_REF_READ_WRITE)\n@@ -467,8 +414,8 @@ iv_get_reaching_def (rtx_insn *insn, rtx reg, df_ref *def)\n \n   /* The definition does not dominate the use.  This is still OK if\n      this may be a use of a biv, i.e. if the def_bb dominates loop\n-     latch or all defs are in latch's predecessors.  */\n-  if (dom_latch_p || just_once_each_iteration_p (current_loop, def_bb))\n+     latch.  */\n+  if (just_once_each_iteration_p (current_loop, def_bb))\n     return GRD_MAYBE_BIV;\n \n   return GRD_INVALID;\n@@ -2981,49 +2928,6 @@ iv_number_of_iterations (struct loop *loop, rtx_insn *insn, rtx condition,\n   return;\n }\n \n-/* Return true if LOOP has a complex exit, but is still good for further\n-   analysis.  Return false otherwise.  BB is LOOP's exit block.  */\n-\n-static bool\n-check_complex_exit_p (struct loop* loop, basic_block bb)\n-{\n-  edge e;\n-  basic_block pred, exit;\n-\n-  if (EDGE_COUNT (bb->preds) > 1)\n-    return false;\n-\n-  e = EDGE_PRED (bb, 0);\n-\n-  pred = e->src;\n-  if (EDGE_COUNT (pred->succs) != 2)\n-    return false;\n-\n-  /* Predecessor must be tested (at least) once during any iteration.  */\n-  if (!dominated_by_p (CDI_DOMINATORS, loop->latch, pred))\n-    return false;\n-\n-  if (EDGE_SUCC (pred, 0)->dest == bb)\n-    exit = EDGE_SUCC (pred, 1)->dest;\n-  else\n-    exit = EDGE_SUCC (pred, 0)->dest;\n-\n-  /* Check that EXIT is really loop exit.  */\n-  if (flow_bb_inside_loop_p (loop, exit))\n-    {\n-      edge_iterator eei;\n-      edge ee;\n-\n-      FOR_EACH_EDGE (ee, eei, exit->succs)\n-\t{\n-\t  if (!flow_bb_inside_loop_p (loop, ee->dest))\n-\t    return true;\n-\t}\n-    }\n-  return false;\n-\n-}\n-\n /* Checks whether E is a simple exit from LOOP and stores its description\n    into DESC.  */\n \n@@ -3043,8 +2947,7 @@ check_simple_exit (struct loop *loop, edge e, struct niter_desc *desc)\n     return;\n \n   /* It must be tested (at least) once during any iteration.  */\n-  if (!dominated_by_p (CDI_DOMINATORS, loop->latch, exit_bb)\n-      && !check_complex_exit_p (loop, exit_bb))\n+  if (!dominated_by_p (CDI_DOMINATORS, loop->latch, exit_bb))\n     return;\n \n   /* It must end in a simple conditional jump.  */"}, {"sha": "83f2e29fa0f4e78aa2e981932a63f0db45a01ba5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7002f3bd9ce16ae52d452718fc44b18572d31169/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7002f3bd9ce16ae52d452718fc44b18572d31169/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7002f3bd9ce16ae52d452718fc44b18572d31169", "patch": "@@ -1,3 +1,12 @@\n+2015-01-20  Igor Zamyatin  <igor.zamyatin@intel.com>\n+\n+\tPR bootstrap/64676\n+\tRevert:\n+\t2014-01-19  Igor Zamyatin  <igor.zamyatin@intel.com>\n+\n+\tPR rtl-optimization/64081\n+\t* gcc.dg/pr64081.c: New test.\n+\n 2015-01-19  David Malcolm  <dmalcolm@redhat.com>\n \n \t* jit.dg/harness.h: Include <unistd.h>."}, {"sha": "6151d0054a486c6c24b7564bf8110c417b66adb3", "filename": "gcc/testsuite/gcc.dg/pr64081.c", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5fcfb6df9ad330f16233739216eca00ee7efa1f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr64081.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5fcfb6df9ad330f16233739216eca00ee7efa1f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr64081.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr64081.c?ref=a5fcfb6df9ad330f16233739216eca00ee7efa1f", "patch": "@@ -1,41 +0,0 @@\n-/* PR rtl-optimization/64081 */\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -funroll-loops -fdump-rtl-loop2_unroll\" } */\n-\n-long token;\n-long *data;\n-long *arr1;\n-long *arr2;\n-\n-int main (int argc, const char* argv[])\n-{\n-  unsigned long i;\n-  static long pos, start, count;\n-  static int dir;\n-\n-  pos = 0;\n-  dir = 1;\n-\n-  for (i = 0; i < argc; i++)\n-    {\n-      start = pos;\n-      for (count = 0; count <= 400; count++)\n-\t{\n-\t  if (token == data[pos])\n-\t    break;\n-\t  if (dir == 1)\n-\t    pos = arr1[pos];\n-\t  else\n-\t    pos = arr2[pos];\n-\t  if (pos == -1)\n-\t    {\n-\t      pos = start;\n-\t      dir = !dir;\n-\t    }\n-\t}\n-    }\n-  return pos + dir;\n-}\n-\n-/* { dg-final { scan-rtl-dump \"loop unrolled 7 times\" \"loop2_unroll\" } } */\n-/* { dg-final { cleanup-rtl-dump \"loop*\" } } */"}]}