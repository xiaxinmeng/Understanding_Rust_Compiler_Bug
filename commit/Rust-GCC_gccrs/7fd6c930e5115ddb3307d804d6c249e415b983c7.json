{"sha": "7fd6c930e5115ddb3307d804d6c249e415b983c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZkNmM5MzBlNTExNWRkYjMzMDdkODA0ZDZjMjQ5ZTQxNWI5ODNjNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-09-04T16:09:10Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-09-04T16:09:10Z"}, "message": "* enquire.c: Remove.\n\nFrom-SVN: r56795", "tree": {"sha": "26bc59954e699ba7441f76abca909c938dda2c24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26bc59954e699ba7441f76abca909c938dda2c24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fd6c930e5115ddb3307d804d6c249e415b983c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fd6c930e5115ddb3307d804d6c249e415b983c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fd6c930e5115ddb3307d804d6c249e415b983c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fd6c930e5115ddb3307d804d6c249e415b983c7/comments", "author": null, "committer": null, "parents": [{"sha": "502e6d5a4700a303275118d46b70733d9e47a6e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/502e6d5a4700a303275118d46b70733d9e47a6e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/502e6d5a4700a303275118d46b70733d9e47a6e8"}], "stats": {"total": 2891, "additions": 4, "deletions": 2887}, "files": [{"sha": "a4bf43162632415955c639c9aa50d51f2739c5e3", "filename": "contrib/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd6c930e5115ddb3307d804d6c249e415b983c7/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd6c930e5115ddb3307d804d6c249e415b983c7/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=7fd6c930e5115ddb3307d804d6c249e415b983c7", "patch": "@@ -1,3 +1,7 @@\n+2002-09-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* enquire.c: Remove.\n+\n 2002-08-14  Mark Mitchell  <mark@codesourcery.com>\n \n \t* gennews (files): Add GCC 3.2 files."}, {"sha": "8b4bdda3d52e8f51c69e6f2fd9cdcedf1e582d7d", "filename": "contrib/enquire.c", "status": "removed", "additions": 0, "deletions": 2887, "changes": 2887, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502e6d5a4700a303275118d46b70733d9e47a6e8/contrib%2Fenquire.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502e6d5a4700a303275118d46b70733d9e47a6e8/contrib%2Fenquire.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fenquire.c?ref=502e6d5a4700a303275118d46b70733d9e47a6e8", "patch": "@@ -1,2887 +0,0 @@\n-/* Everything you wanted to know about your machine and C compiler,\n-   but didn't know who to ask.  */\n-\n-#ifndef VERSION\n-#define VERSION \"4.3\"\n-#endif\n-\n-/* Author: Steven Pemberton, CWI, Amsterdam; steven@cwi.nl\n-   Bugfixes and upgrades gratefully received.\n-\n-   Copyright (c) 1988, 1989, 1990 Steven Pemberton, CWI, Amsterdam.\n-   All rights reserved.\n-\n-   Changes by Richard Stallman:\n-   Undef CHAR_BIT, etc., if defined in stdio.h, Richard Stallman, Aug 90.\n-   In EPROP, avoid a <= old if bad is set, Richard Stallman, May 91.\n-   Use gstddef.h, not stddef.h, Richard Stallman, Nov 91.\n-   Don't declare malloc, instead cast the value, Richard Stallman, Nov 91.\n-   Include sys/types.h before signal.h, Apr 92.\n-   Support NO_LONG_DOUBLE_IO in f_define and f_rep; new fn fake_f_rep, Apr 92.\n-   Enclose -f output in #ifndef _FLOAT_H___, Richard Stallman, May 92.\n-\n-   Change by Jim Wilson:\n-   Add #undef before every #define, Dec 92.\n-   Use stddef.h not gstddef.h, Mar 94.\n-\n-   Changes by Paul Eggert, installed Feb 93:\n-   (fake_f_rep): Clear all of u, initially.  Make the ints in u unsigned.\n-   (f_define): Use ordinary constants for long double\n-   if it's same width as double.  Make __convert_long_double_i unsigned.\n-   Richard Stallman, May 93:\n-   In F_check, check NO_LONG_DOUBLE_IO.\n-\n-   Changes by Stephen Moshier, installed Sep 93:\n-   (FPROP): Recognize 80387 or 68881 XFmode format.\n-\n-   Change by Manfred Hollstein, installed Mar 98:\n-   (bitpattern): Change type of variable i to unsigned int.\n-\n-\n-   COMPILING\n-   With luck and a following wind, just the following will work:\n-\tcc enquire.c -o enquire\n-   You may get some messages about unreachable code, which you can ignore.\n-\n-   If your compiler doesn't support:\t\tadd flag:\n-\tsigned char (eg pcc)\t\t\t-DNO_SC\n-\tunsigned char\t\t\t\t-DNO_UC\n-\tunsigned short and long\t\t\t-DNO_UI\n-\tvoid\t\t\t\t\t-DNO_VOID\n-\tsignal(), or setjmp/longjmp()\t\t-DNO_SIG\n-\t%Lf in printf\t\t\t\t-DNO_LONG_DOUBLE_IO\n-\n-   Try to compile first with no flags, and see if you get any errors -\n-   you might be surprised. (Most non-ANSI compilers need -DNO_SC, though.)\n-   Some compilers need a -f flag for floating point.\n-\n-   Don't use any optimisation flags: the program may not work if you do.\n-   Though \"while (a+1.0-a-1.0 == 0.0)\" may look like \"while(1)\" to an\n-   optimiser, to a floating-point unit there's a world of difference.\n-\n-   Some compilers offer various flags for different floating point\n-   modes; it's worth trying all possible combinations of these.\n-\n-   Add -DID=\\\"name\\\" if you want the machine/flags identified in the output.\n-\n-   FAULTY COMPILERS\n-   Because of bugs and/or inadequacies, some compilers need the following\n-   defines:\n-\n-   If your C preprocessor doesn't have the predefined __FILE__ macro, and\n-   you don't want to call this file enquire.c but, say, tell.c, add the\n-   flag -DFILENAME=\\\"tell.c\\\" .\n-\n-   Some compilers won't accept the line \"#include FILENAME\".\n-   Add flag -DNO_FILE. In that case, this file *must* be called enquire.c.\n-\n-   Some compilers can't cope with \"#ifdef __FILE__\". Use -DFILENAME=\n-   or -DNO_FILE as above.\n-\n-   Some naughty compilers define __STDC__, but don't really support it.\n-   Some define it as 0, in which case we treat it as undefined.\n-   But if your compiler defines it, and isn't really ANSI C,\n-   add flag -DNO_STDC. (To those compiler writers: for shame).\n-\n-   Some naughty compilers define __STDC__, but don't have the stddef.h\n-   include file. Add flag -DNO_STDDEF.\n-\n-   Summary of naughty-compiler flags:\n-   If your compiler doesn't support:\t\t add flag:\n-\t__FILE__ (and you changed the filename)\t-DFILENAME=\\\"name.c\\\"\n-\t#ifdef __FILE__\t\t\t\t-DNO_FILE or -DFILENAME=...\n-\t#include FILENAME\t\t\t-DNO_FILE\n-\t__STDC__ (properly)\t\t\t-DNO_STDC\n-\tstddef.h\t\t\t\t-DNO_STDDEF\n-\n-   Some systems crash when you try to malloc all store. To save users of\n-   such defective systems too much grief, they may compile with -DNO_MEM,\n-   which ignores that bit of the code.\n-\n-   While it is not our policy to support defective compilers, pity has been\n-   taken on people with compilers that can't produce object files bigger than\n-   32k (especially since it was an easy addition). Compile the program\n-   into separate parts like this:\n-       cc -DSEP -DPASS0 -o p0.o <other flags> enquire.c\n-       cc -DSEP -DPASS1 -o p1.o <other flags> enquire.c\n-       cc -DSEP -DPASS2 -o p2.o <other flags> enquire.c\n-       cc -DSEP -DPASS3 -o p3.o <other flags> enquire.c\n-       cc -o enquire p0.o p1.o p2.o p3.o\n-\n-   SYSTEM DEPENDENCIES\n-   You may possibly need to add some calls to signal() for other sorts of\n-   exception on your machine than SIGFPE, and SIGOVER. See lines beginning\n-   #ifdef SIGxxx in main() (and communicate the differences to me!).\n-\n-   OUTPUT\n-   Run without argument to get the information as English text. If run\n-   with argument -l (e.g. enquire -l), output is a series of #define's for\n-   the ANSI standard limits.h include file, excluding MB_MAX_CHAR. If run\n-   with argument -f, output is a series of #define's for the ANSI standard\n-   float.h include file (according to ANSI C Draft of Dec 7, 1988).\n-   Flag -v gives verbose output: output includes the English text above\n-   as C comments. The program exit(0)'s if everything went ok, otherwise\n-   it exits with a positive number, telling how many problems there were.\n-\n-   VERIFYING THE COMPILER\n-   If, having produced the float.h and limits.h header files, you want to\n-   verify that the compiler reads them back correctly (there are a lot of\n-   boundary cases, of course, like minimum and maximum numbers), you can\n-   recompile enquire.c with -DVERIFY set (plus the other flags that you used\n-   when compiling the version that produced the header files). This then\n-   recompiles the program so that it #includes \"limits.h\" and \"float.h\",\n-   and checks that the constants it finds there are the same as the\n-   constants it produces. Run the resulting program with enquire -fl.\n-   Very few compilers have passed without error.\n-   NB: You *must* recompile with the same compiler and flags, otherwise\n-   you may get odd results.\n-\n-   You can also use this option if your compiler already has both files,\n-   and you want to confirm that this program produces the right results.\n-\n-   TROUBLESHOOTING.\n-   This program is now quite trustworthy, and suspicious and wrong output\n-   may well be caused by bugs in the compiler, not in the program (however\n-   of course, this is not guaranteed, and no responsibility can be\n-   accepted, etc.)\n-\n-   The program only works if overflows are ignored by the C system or\n-   are catchable with signal().\n-\n-   If the program fails to run to completion (often with the error message\n-   \"Unexpected signal at point x\"), this often turns out to be a bug in the\n-   C compiler's run-time system. Check what was about to be printed, and\n-   try to narrow the problem down.\n-\n-   Another possible problem is that you have compiled the program to produce\n-   loss-of-precision arithmetic traps. The program cannot cope with these,\n-   and you should re-compile without them. (They should never be the default).\n-\n-   Make sure you compiled with optimisation turned off.\n-\n-   Output preceded by *** WARNING: identifies behaviour of the C system\n-   deemed incorrect by the program. Likely problems are that printf or\n-   scanf don't cope properly with certain boundary numbers: this program\n-   goes to a lot of trouble to calculate its values, and these values\n-   are mostly boundary numbers. Experience has shown that often printf\n-   cannot cope with these values, and so in an attempt to increase\n-   confidence in the output, for each float and double that is printed,\n-   the printed value is checked by using sscanf to read it back.\n-       Care is taken that numbers are printed with enough digits to uniquely\n-   identify them, and therefore that they can be read back identically.\n-   If the number read back is different, then there is probably a bug in\n-   printf or sscanf, and the program prints the warning message.\n-   If the two numbers in the warning look identical, then printf is more\n-   than likely rounding the last digit(s) incorrectly. To put you at ease\n-   that the two really are different, the bit patterns of the two numbers\n-   are also printed. The difference is very likely in the last bit.\n-       Many scanf's read the minimum double back as 0.0, and similarly cause\n-   overflow when reading the maximum double. This program quite ruthlessly\n-   declares all these behaviours faulty. The point is that if you get\n-   one of these warnings, the output may be wrong, so you should check\n-   the result carefully if you intend to use the results. Of course, printf\n-   and sscanf may both be wrong, and cancel each other out, so you should\n-   check the output carefully anyway.\n-\n-   The warning that \"a cast didn't work\" refers to cases like this:\n-\n-      float f;\n-      #define C 1.234567890123456789\n-      f= C;\n-      if (f != (float) C) printf (\"Wrong!\");\n-\n-   A faulty compiler will widen f to double and ignore the cast to float,\n-   and because there is more accuracy in a double than a float, fail to\n-   recognise that they are the same. In the actual case in point, f and C\n-   are passed as parameters to a function that discovers they are not equal,\n-   so it's just possible that the error was in the parameter passing,\n-   not in the cast (see function Validate()).\n-   For ANSI C, which has float constants, the error message is \"constant has\n-   wrong precision\".\n-\n-   REPORTING PROBLEMS\n-   If the program doesn't work for you for any reason that can't be\n-   narrowed down to a problem in the C compiler, or it has to be changed in\n-   order to get it to compile, or it produces suspicious output (like a very\n-   low maximum float, for instance), please mail the problem and an example\n-   of the incorrect output to steven@cwi.nl or ..!hp4nl!cwi.nl!steven, so that\n-   improvements can be worked into future versions; cwi.nl is the European\n-   backbone, and is connected to uunet and other fine hosts.\n-\n-   The program tries to catch and diagnose bugs in the compiler/run-time\n-   system. I would be especially pleased to have reports of failures so\n-   that I can improve this service.\n-\n-   I apologise unreservedly for the contorted use of the preprocessor...\n-\n-   THE SMALL PRINT\n-   You may copy and distribute verbatim copies of this source file.\n-\n-   You may modify this source file, and copy and distribute such\n-   modified versions, provided that you leave the copyright notice\n-   at the top of the file and also cause the modified file to carry\n-   prominent notices stating that you changed the files and the date\n-   of any change; and cause the whole of any work that you distribute\n-   or publish, that in whole or in part contains or is a derivative of\n-   this program or any part thereof, to be licensed at no charge to\n-   all third parties on terms identical to those here.\n-\n-   If you do have a fix to any problem, please send it to me, so that\n-   other people can have the benefits.\n-\n-   While every effort has been taken to make this program as reliable as\n-   possible, no responsibility can be taken for the correctness of the\n-   output, nor suitability for any particular use.\n-\n-   This program is an offshoot of a project funded by public funds.\n-   If you use this program for research or commercial use (i.e. more\n-   than just for the fun of knowing about your compiler) mailing a short\n-   note of acknowledgement may help keep enquire.c supported.\n-\n-   ACKNOWLEDGEMENTS\n-   Many people have given time and ideas to making this program what it is.\n-   To all of them thanks, and apologies for not mentioning them by name.\n-\n-   HISTORY\n-   Originally started as a program to generate configuration constants\n-   for a large piece of software we were writing, which later took on\n-   a life of its own...\n-   1.0 Length 6658!; end 1984?\n-       Unix only. Only printed a dozen maximum int/double values.\n-   2.0 Length 10535; Spring 1985\n-       Prints values as #defines (about 20 of them)\n-       More extensive floating point, using Cody and Waite\n-       Handles signals better\n-       Programs around optimisations\n-       Handles Cybers\n-   3.0 Length 12648; Aug 1987; prints about 42 values\n-       Added PASS stuff, so treats float as well as double\n-   4.0 Length 33891; Feb 1989; prints around 85 values\n-       First GNU version (for gcc, where they call it hard-params.c)\n-       Generates float.h and limits.h files\n-       Handles long double\n-       Generates warnings for dubious output\n-   4.1 Length 47738; April 1989\n-       Added VERIFY and TEST\n-   4.2 Length 63442; Feb 1990\n-       Added SEP\n-       Fixed eps/epsneg\n-       Added check for pseudo-unsigned chars\n-       Added description for each #define output\n-       Added check for absence of defines during verify\n-       Added prototypes\n-       Added NO_STDC and NO_FILE\n-       Fixed alignments output\n-   4.3 Length 75000; Oct 1990; around 114 lines of output\n-       Function xmalloc defined, Richard Stallman, June 89.\n-       Alignments computed from member offsets rather than structure sizes,\n-          Richard Stallman, Oct 89.\n-       Print whether char* and int* pointers have the same format;\n-          also char * and function *.\n-       Update to Draft C version Dec 7, 1988\n-\t  - types of constants produced in limits.h\n-\t    (whether to put a U after unsigned shorts and chars and\n-\t     whether to output -1024 as (-1023-1))\n-\t  - values of SCHAR_MIN/MAX\n-\t  - values of *_EPSILON (not the smallest but the effective smallest)\n-       Added FILENAME, since standard C doesn't allow #define __FILE__\n-       Renamed from config.c to enquire.c\n-       Added size_t and ptrdiff_t enquiries\n-       Added promotion enquiries\n-       Added type checks of #defines\n-       Added NO_STDDEF\n-       Changed endian to allow for cases where not all bits are used\n-       Sanity check for max integrals\n-       Fixed definition of setjmp for -DNO_SIG\n-       Moved #define ... 0.0L inside #ifdef STDC, in case some cpp's tokenize\n-       Added NO_MEM\n-*/\n-\n-/* Set FILENAME to the name of this file */\n-#ifndef FILENAME\n-#ifdef NO_FILE\n-#define FILENAME \"enquire.c\"\n-#else\n-#ifdef __FILE__ /* It's a compiler bug if this fails. Compile with -DNO_FILE */\n-#define FILENAME __FILE__\n-#else\n-#define FILENAME \"enquire.c\"\n-#endif /* __FILE__ */\n-#endif /* NO_FILE */\n-#endif /* FILENAME */\n-\n-/* If PASS isn't defined, then this is the first pass over this file.  */\n-#ifndef PASS\n-#ifndef SEP\n-#define PASS 1\n-#define PASS0 1\n-#define PASS1 1\n-#endif /* SEP */\n-\n-/* A description of the ANSI constants */\n-#define D_CHAR_BIT \"Number of bits in a storage unit\"\n-#define D_CHAR_MAX \"Maximum char\"\n-#define D_CHAR_MIN \"Minimum char\"\n-#define D_SCHAR_MAX \"Maximum signed char\"\n-#define D_SCHAR_MIN \"Minimum signed char\"\n-#define D_UCHAR_MAX \"Maximum unsigned char (minimum is always 0)\"\n-\n-#define D_INT_MAX \"Maximum %s\"\n-#define D_INT_MIN \"Minimum %s\"\n-#define D_UINT_MAX \"Maximum unsigned %s (minimum is always 0)\"\n-\n-#define D_FLT_ROUNDS \"Addition rounds to 0: zero, 1: nearest, 2: +inf, 3: -inf, -1: unknown\"\n-#define D_FLT_RADIX \"Radix of exponent representation\"\n-#define D_MANT_DIG \"Number of base-FLT_RADIX digits in the significand of a %s\"\n-#define D_DIG \"Number of decimal digits of precision in a %s\"\n-#define D_MIN_EXP \"Minimum int x such that FLT_RADIX**(x-1) is a normalised %s\"\n-#define D_MIN_10_EXP \"Minimum int x such that 10**x is a normalised %s\"\n-#define D_MAX_EXP \"Maximum int x such that FLT_RADIX**(x-1) is a representable %s\"\n-#define D_MAX_10_EXP \"Maximum int x such that 10**x is a representable %s\"\n-#define D_MAX \"Maximum %s\"\n-#define D_EPSILON \"Difference between 1.0 and the minimum %s greater than 1.0\"\n-#define D_MIN \"Minimum normalised %s\"\n-\n-/* Procedure just marks the functions that don't return a result */\n-#ifdef NO_VOID\n-#define Procedure int\n-#else\n-#define Procedure void\n-#endif\n-\n-/* Some bad compilers define __STDC__, when they don't support it.\n-   Compile with -DNO_STDC to get round this.\n-*/\n-#ifndef NO_STDC\n-#ifdef __STDC__\n-#if __STDC__ /* If __STDC__ is 0, assume it isn't supported */\n-#define STDC\n-#endif\n-#endif\n-#endif\n-\n-/* Stuff different for ANSI C, and old C:\n-   ARGS and NOARGS are used for function prototypes.\n-   Volatile is used to reduce the chance of optimisation,\n-      and to prevent variables being put in registers (when setjmp/longjmp\n-      wouldn't work as we want)\n-   Long_double is the longest floating point type available.\n-   stdc is used in tests like \"if (stdc)\", which is less ugly than #ifdef.\n-   U is output after unsigned constants.\n- */\n-#ifdef STDC\n-\n-#define ARGS(x) x\n-#define NOARGS (void)\n-#define Volatile volatile\n-#define Long_double long double\n-#define stdc 1\n-#define U \"U\"\n-\n-#else /* Old style C */\n-\n-#define ARGS(x) ()\n-#define NOARGS ()\n-#define Volatile static\n-#define Long_double double\n-#define stdc 0\n-#define U \"\"\n-\n-#endif /* STDC */\n-\n-/* include files */\n-/* Stdio.h might include limits.h, and limits.h might include float.h, and\n-   float.h is probably the float.h put together by the gcc makefile to\n-   cause errors.  We use our special define to assure float.h that we don't\n-   really need it.  */\n-#define __GCC_FLOAT_NOT_NEEDED   \n-#include <stdio.h>\n-\n-#ifdef STDC\n-#ifndef NO_STDDEF\n-#include <stddef.h> /* for size_t: if this fails, define NO_STDDEF */\n-#endif\n-#endif\n-\n-#ifdef NO_SIG\n-#define jmp_buf int\n-#else\n-#include <sys/types.h>\n-#include <signal.h>\n-#include <setjmp.h>\n-#endif\n-\n-/* Kludge around the possibility that <stdio.h> includes <limits.h> */\n-#ifdef CHAR_BIT\n-#undef CHAR_BIT\n-#undef CHAR_MAX\n-#undef CHAR_MIN\n-#undef SCHAR_MAX\n-#undef SCHAR_MIN\n-#undef UCHAR_MAX\n-#undef UCHAR_MIN\n-#endif\n-\n-#ifdef VERIFY\n-#include \"limits.h\"\n-#endif\n-\n-#ifndef SYS_FLOAT_H_WRAP\n-#define SYS_FLOAT_H_WRAP 0\n-#endif\n-\n-#if SYS_FLOAT_H_WRAP || defined VERIFY\n-#include \"float.h\"\n-#endif\n-\n-#define Vprintf if (V) printf\n-#define Unexpected(place) if (setjmp(lab)!=0) croak(place)\n-#define fabs(x) (((x)<0.0)?(-x):(x))\n-\n-#endif /* PASS */\n-\n-#ifdef PASS0\n-\n-/* Prototypes for what's to come: */\n-\n-int false NOARGS;\n-\n-#ifdef NO_STDDEF\n-char *malloc (); /* Old style prototype */\n-#else\n-char *malloc ARGS((size_t size));\n-#endif\n-\n-Procedure exit ARGS((int status));\n-\n-char *f_rep ARGS((int precision, Long_double val));\n-char *fake_f_rep ARGS((char *type, Long_double val));\n-\n-int maximum_int NOARGS;\n-int cprop NOARGS;\n-int basic NOARGS;\n-Procedure sprop NOARGS;\n-Procedure iprop NOARGS;\n-Procedure lprop NOARGS;\n-Procedure usprop NOARGS;\n-Procedure uiprop NOARGS;\n-Procedure ulprop NOARGS;\n-int fprop ARGS((int bits_per_byte));\n-int dprop ARGS((int bits_per_byte));\n-int ldprop ARGS((int bits_per_byte));\n-Procedure efprop ARGS((int fprec, int dprec, int lprec));\n-Procedure edprop ARGS((int fprec, int dprec, int lprec));\n-Procedure eldprop ARGS((int fprec, int dprec, int lprec));\n-\n-int setmode ARGS((char *s));\n-Procedure farewell ARGS((int bugs));\n-Procedure describe ARGS((char *description, char *extra));\n-Procedure missing ARGS((char *s));\n-Procedure fmissing ARGS((char *s));\n-Procedure check_defines NOARGS;\n-Procedure bitpattern ARGS((char *p, unsigned int size));\n-int ceil_log ARGS((int base, Long_double x));\n-Procedure croak ARGS((int place));\n-Procedure eek_a_bug ARGS((char *problem));\n-Procedure endian ARGS((int bits_per_byte));\n-int exponent ARGS((Long_double x, double *fract, int *exp));\n-int floor_log ARGS((int base, Long_double x));\n-Procedure f_define ARGS((char *desc, char *extra, char *sort, char *name,\n-\t\t\t int prec, Long_double val, Long_double req,\n-\t\t\t char *mark));\n-Procedure i_define ARGS((char *desc, char *extra, char *sort, char *name,\n-\t\t\t long val, long lim, long req, char *mark));\n-Procedure u_define ARGS((char *desc, char *extra, char *sort, char *name,\n-\t\t\t unsigned long val, unsigned long req, char *mark));\n-\n-#ifdef NO_SIG  /* There's no signal(), or setjmp/longjmp() */\n-\n-\t/* Dummy routines instead */\n-\n-\tint setjmp ARGS((int lab));\n-\n-\tint lab=1;\n-\tint setjmp(lab) int lab; { return(0); }\n-\tProcedure signal(i, p) int i, (*p)(); {}\n-\n-#else\n-\tjmp_buf lab;\n-\tProcedure overflow(sig) int sig; { /* what to do on over/underflow */\n-\t\tsignal(sig, overflow);\n-\t\tlongjmp(lab, 1);\n-\t}\n-\n-#endif /*NO_SIG*/\n-\n-int V= 0,\t/* verbose */\n-    L= 0,\t/* produce limits.h */\n-    F= 0,\t/* produce float.h  */\n-    bugs=0;\t/* The number of (possible) bugs in the output */\n-\n-char co[4], oc[4]; /* Comment starter and ender symbols */\n-\n-int bits_per_byte; /* the number of bits per unit returned by sizeof() */\n-int flt_rounds;    /* The calculated value of FLT_ROUNDS */\n-int flt_radix;     /* The calculated value of FLT_RADIX */\n-\n-#ifdef TEST\n-/* Set the fp modes on a SUN with 68881 chip, to check that different\n-   rounding modes etc. get properly detected.\n-   Compile with -f68881 for cc, -m68881 for gcc, and with additional flag\n-   -DTEST. Run with additional parameter +hex-number, to set the 68881 mode\n-   register to hex-number\n-*/\n-\n-/* Bits 0x30 = rounding mode */\n-#define ROUND_BITS\t0x30\n-#define TO_NEAREST\t0x00\n-#define TO_ZERO\t\t0x10\n-#define TO_MINUS_INF\t0x20\n-#define TO_PLUS_INF\t0x30 /* The SUN FP user's guide seems to be wrong here */\n-\n-/* Bits 0xc0 = extended rounding */\n-#define EXT_BITS\t0xc0\n-#define ROUND_EXTENDED\t0x00\n-#define ROUND_SINGLE\t0x40\n-#define ROUND_DOUBLE\t0x80\n-\n-/* Enabled traps */\n-#define EXE_INEX1  0x100\n-#define EXE_INEX2  0x200\n-#define EXE_DZ\t   0x400\n-#define EXE_UNFL   0x800\n-#define EXE_OVFL  0x1000\n-#define EXE_OPERR 0x2000\n-#define EXE_SNAN  0x4000\n-#define EXE_BSUN  0x8000\n-\n-/* Only used for testing, on a Sun with 68881 chip */\n-/* Print the FP mode */\n-printmode(new) unsigned new; {\n-\tfpmode_(&new);\n-\tprintf(\"New fp mode:\\n\");\n-\tprintf(\"  Round toward \");\n-\tswitch (new & ROUND_BITS) {\n-\t      case TO_NEAREST:   printf(\"nearest\"); break;\n-\t      case TO_ZERO:      printf(\"zero\"); break;\n-\t      case TO_MINUS_INF: printf(\"minus infinity\"); break;\n-\t      case TO_PLUS_INF:  printf(\"plus infinity\"); break;\n-\t      default: printf(\"???\"); break;\n-\t}\n-\n-\tprintf(\"\\n  Extended rounding precision: \");\n-\n-\tswitch (new & EXT_BITS) {\n-\t      case ROUND_EXTENDED: printf(\"extended\"); break;\n-\t      case ROUND_SINGLE:   printf(\"single\"); break;\n-\t      case ROUND_DOUBLE:   printf(\"double\"); break;\n-\t      default: printf(\"???\"); break;\n-\t}\n-\n-\tprintf(\"\\n  Enabled exceptions:\");\n-\tif (new & (unsigned) EXE_INEX1) printf(\" inex1\");\n-\tif (new & (unsigned) EXE_INEX2) printf(\" inex2\");\n-\tif (new & (unsigned) EXE_DZ)    printf(\" dz\");\n-\tif (new & (unsigned) EXE_UNFL)  printf(\" unfl\");\n-\tif (new & (unsigned) EXE_OVFL)  printf(\" ovfl\");\n-\tif (new & (unsigned) EXE_OPERR) printf(\" operr\");\n-\tif (new & (unsigned) EXE_SNAN)  printf(\" snan\");\n-\tif (new & (unsigned) EXE_BSUN)  printf(\" bsun\");\n-\tprintf(\"\\n\");\n-}\n-\n-/* Only used for testing, on a Sun with 68881 chip */\n-/* Set the FP mode */\n-int setmode(s) char *s; {\n-\tunsigned mode=0, dig;\n-\tchar c;\n-\n-\twhile (*s) {\n-\t\tc= *s++;\n-\t\tif  (c>='0' && c<='9') dig= c-'0';\n-\t\telse if (c>='a' && c<='f') dig= c-'a'+10;\n-\t\telse if (c>='A' && c<='F') dig= c-'A'+10;\n-\t\telse return 1;\n-\t\tmode= mode<<4 | dig;\n-\t}\n-\tprintmode(mode);\n-\treturn 0;\n-}\n-#else\n-/* ARGSUSED */\n-int setmode(s) char *s; {\n-\tfprintf(stderr, \"Can't set mode: not compiled with TEST\\n\");\n-\treturn(1);\n-}\n-#endif\n-\n-Procedure farewell(bugs) int bugs; {\n-\tif (bugs == 0) exit(0);\n-\tprintf(\"\\n%sFor hints on dealing with the \", co);\n-\tif (bugs == 1) printf(\"problem\");\n-\telse printf(\"%d problems\", bugs);\n-\tprintf(\" above\\n   see the section 'TROUBLESHOOTING' in the file \");\n-\tprintf(\"%s%s\\n\", FILENAME, oc);\n-\texit(bugs);\n-}\n-\n-/* The program has received a signal where it wasn't expecting one */\n-Procedure croak(place) int place; {\n-\tprintf(\"*** Unexpected signal at point %d\\n\", place);\n-\tfarewell(bugs+1); /* An exit isn't essential here, but avoids loops */\n-}\n-\n-/* This is here in case alloca.c is used, which calls this.  */\n-char *xmalloc(size) unsigned size; {\n-\tchar *value = (char *)malloc(size);\n-\tif (value == 0) {\n-\t\tfprintf(stderr, \"Virtual memory exceeded\\n\");\n-\t\texit(bugs+1);\n-\t}\n-\treturn value;\n-}\n-\n-int maxint;\n-\n-int maximum_int() {\n-\t/* Find the maximum integer */\n-\tVolatile int newi, int_max, two=2;\n-\n-\t/* Calculate maxint ***********************************/\n-\t/* Calculate 2**n-1 until overflow - then use the previous value  */\n-\n-\tnewi=1; int_max=0;\n-\n-\tif (setjmp(lab)==0) { /* Yields int_max */\n-\t\twhile(newi>int_max) {\n-\t\t\tint_max=newi;\n-\t\t\tnewi=newi*two+1;\n-\t\t}\n-\t}\n-\tUnexpected(0);\n-\treturn int_max;\n-}\n-\n-int main(argc, argv) int argc; char *argv[]; {\n-\tint dprec, fprec, lprec;\n-\tint i; char *s; int bad;\n-\n-#ifdef SIGFPE\n-\tsignal(SIGFPE, overflow);\n-#endif\n-#ifdef SIGOVER\n-\tsignal(SIGOVER, overflow);\n-#endif\n-/* Add more calls as necessary */\n-\n-\tUnexpected(1);\n-\n-\tbad=0;\n-\tfor (i=1; i < argc; i++) {\n-\t\ts= argv[i];\n-\t\tif (*s == '-') {\n-\t\t\ts++;\n-\t\t\twhile (*s) {\n-\t\t\t\tswitch (*(s++)) {\n-\t\t\t\t      case 'v': V=1; break;\n-\t\t\t\t      case 'l': L=1; break;\n-\t\t\t\t      case 'f': F=1; break;\n-\t\t\t\t      default: bad=1; break;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else if (*s == '+') {\n-\t\t\ts++;\n-\t\t\tbad= setmode(s);\n-\t\t} else bad= 1;\n-\t}\n-\tif (bad) {\n-\t\tfprintf(stderr,\n-\t\t\t\"Usage: %s [-vlf]\\n  v=Verbose l=Limits.h f=Float.h\\n\",\n-\t\t\targv[0]);\n-\t\texit(1);\n-\t}\n-\tif (L || F) {\n-\t\tco[0]= '/'; oc[0]= ' ';\n-\t\tco[1]= '*'; oc[1]= '*';\n-\t\tco[2]= ' '; oc[2]= '/';\n-\t\tco[3]= '\\0'; oc[3]= '\\0';\n-\t} else {\n-\t\tco[0]= '\\0'; oc[0]= '\\0';\n-\t\tV=1;\n-\t}\n-\n-\tif (L) printf(\"%slimits.h%s\\n\", co, oc);\n-\tif (F) printf(\"%sfloat.h%s\\n\", co, oc);\n-\tif (F) {\n-\t\tprintf (\"#ifndef _FLOAT_H___\\n\");\n-\t\tprintf (\"#define _FLOAT_H___\\n\");\n-\t\tif (SYS_FLOAT_H_WRAP)\n-\t\t\tprintf (\" #include_next <float.h>\\n\");\n-\t}\n-#ifdef ID\n-\tprintf(\"%sProduced on %s by enquire version %s, CWI, Amsterdam%s\\n\",\n-\t       co, ID, VERSION, oc);\n-#else\n-\tprintf(\"%sProduced by enquire version %s, CWI, Amsterdam%s\\n\",\n-\t       co, VERSION, oc);\n-#endif\n-\n-#ifdef VERIFY\n-\tprintf(\"%sVerification phase%s\\n\", co, oc);\n-#endif\n-\n-#ifdef NO_SIG\n-\tVprintf(\"%sCompiled without signal(): %s%s\\n\",\n-\t\tco,\n-\t\t\"there's nothing that can be done if overflow occurs\",\n-\t\toc);\n-#endif\n-#ifdef NO_SC\n-\tVprintf(\"%sCompiled without signed char%s\\n\", co, oc);\n-#endif\n-#ifdef NO_UC\n-\tVprintf(\"%Compiled without unsigned char%s\\n\", co, oc);\n-#endif\n-#ifdef NO_UI\n-\tVprintf(\"%Compiled without unsigned short or long%s\\n\", co, oc);\n-#endif\n-#ifdef __STDC__\n-\tVprintf(\"%sCompiler claims to be ANSI C level %d%s\\n\",\n-\t\tco, __STDC__, oc);\n-#else\n-\tVprintf(\"%sCompiler does not claim to be ANSI C%s\\n\", co, oc);\n-#endif\n-\tprintf(\"\\n\");\n-\tcheck_defines();\n-\n-\tmaxint= maximum_int();\n-\tbits_per_byte= basic();\n-\tVprintf(\"\\n\");\n-\tif (F||V) {\n-\t\tfprec= fprop(bits_per_byte);\n-\t\tdprec= dprop(bits_per_byte);\n-\t\tlprec= ldprop(bits_per_byte);\n-\t\tefprop(fprec, dprec, lprec);\n-\t\tedprop(fprec, dprec, lprec);\n-\t\teldprop(fprec, dprec, lprec);\n-\t}\n-#ifndef NO_MEM\n-\tif (V) {\n-\t\tunsigned int size;\n-\t\tlong total;\n-\t\t/* An extra goody: the approximate amount of data-space */\n-\t\t/* Allocate store until no more available */\n-\t\t/* Different implementations have a different argument type\n-\t\t   to malloc. Here we assume that it's the same type as\n-\t\t   that which sizeof() returns */\n-\t\tsize=1<<((bits_per_byte*sizeof(int))-2);\n-\t\ttotal=0;\n-\t\twhile (size!=0) {\n-\t\t\twhile ( malloc((false()?sizeof(int):size)) !=\n-\t\t\t        (char *)NULL\n-\t\t\t       ) {\n-\t\t\t\ttotal+=(size/2);\n-\t\t\t}\n-\t\t\tsize/=2;\n-\t\t}\n-\n-\t\tVprintf(\"%sMemory allocable ~= %ld Kbytes%s\\n\",\n-\t\t\tco, (total+511)/512, oc);\n-\t}\n-#endif\n-\tif (F) {\n-\t\tprintf (\"#endif %s _FLOAT_H___%s\\n\", co, oc);\n-\t}\n-\tfarewell(bugs);\n-\treturn bugs; /* To keep compilers and lint happy */\n-}\n-\n-Procedure eek_a_bug(problem) char *problem; {\n-\t/* The program has discovered a problem */\n-\tprintf(\"\\n%s*** WARNING: %s%s\\n\", co, problem, oc);\n-\tbugs++;\n-}\n-\n-Procedure describe(description, extra) char *description, *extra; {\n-\t/* Produce the description for a #define */\n-\tprintf(\"   %s\", co);\n-\tprintf(description, extra);\n-\tprintf(\"%s\\n\", oc);\n-}\n-\n-Procedure i_define(desc, extra, sort, name, val, lim, req, mark)\n-     char *desc, *extra, *sort, *name; long val, lim, req; char *mark; {\n-\tif (SYS_FLOAT_H_WRAP && F && val == req)\n-\t\treturn;\n-\t/* Produce a #define for a signed int type */\n-\tdescribe(desc, extra);\n-\tprintf(\"#undef %s%s\\n\", sort, name);\n-\tif (val >= 0) {\n-\t\tprintf(\"#define %s%s %ld%s\\n\", sort, name, val, mark);\n-\t} else if (val + lim < 0) {\n-\t\t/* We may not produce a constant like -1024 if the max\n-\t\t   allowable value is 1023. It has then to be output as\n-\t\t   -1023-1. lim is the max allowable value.  */\n-\t\tprintf(\"#define %s%s (%ld%s%ld%s)\\n\",\n-\t\t       sort, name, -lim, mark, val+lim, mark);\n-\t} else {\n-\t\tprintf(\"#define %s%s (%ld%s)\\n\", sort, name, val, mark);\n-\t}\n-#ifdef VERIFY\n-\tif (val != req) {\n-\t\tprintf(\"%s*** Verify failed for above #define!\\n\", co);\n-\t\tprintf(\"       Compiler has %ld for value%s\\n\\n\", req, oc);\n-\t\tbugs++;\n-\t}\n-#endif\n-\tVprintf(\"\\n\");\n-}\n-\n-Procedure u_define(desc, extra, sort, name, val, req, mark)\n-     char *desc, *extra, *sort, *name; unsigned long val, req; char *mark; {\n-\t/* Produce a #define for an unsigned value */\n-\tdescribe(desc, extra);\n-\tprintf(\"#undef %s%s\\n\", sort, name);\n-\tprintf(\"#define %s%s %lu%s%s\\n\", sort, name, val, U, mark);\n-#ifdef VERIFY\n-\tif (val != req) {\n-\t\tprintf(\"%s*** Verify failed for above #define!\\n\", co);\n-\t\tprintf(\"       Compiler has %lu for value%s\\n\\n\", req, oc);\n-\t\tbugs++;\n-\t}\n-#endif\n-\tVprintf(\"\\n\");\n-}\n-\n-Procedure f_define(desc, extra, sort, name, precision, val, req, mark)\n-     char *desc, *extra, *sort, *name; int precision;\n-     Long_double val, req; char *mark; {\n-\tif (SYS_FLOAT_H_WRAP && F && val == req)\n-\t\treturn;\n-\t/* Produce a #define for a float/double/long double */\n-\tdescribe(desc, extra);\n-\tprintf (\"#undef %s%s\\n\", sort, name);\n-\tif (stdc) {\n-#ifdef NO_LONG_DOUBLE_IO\n-\t\tstatic int union_defined = 0;\n-\t\tif (sizeof(double) != sizeof(Long_double)\n-\t\t    && !strcmp(sort, \"LDBL\")) {\n-\t\t\tif (!union_defined) {\n-\t\t\t\tprintf(\"#ifndef __LDBL_UNION__\\n\");\n-\t\t\t\tprintf(\"#define __LDBL_UNION__\\n\");\n-\t\t\t\tprintf(\"union __convert_long_double {\\n\");\n-\t\t\t\tprintf(\"  unsigned __convert_long_double_i[4];\\n\");\n-\t\t\t\tprintf(\"  long double __convert_long_double_d;\\n\");\n-\t\t\t\tprintf(\"};\\n\");\n-\t\t\t\tprintf(\"#endif\\n\");\n-\t\t\t\tunion_defined = 1;\n-\t\t\t}\n-\t\t\tprintf(\"#define %s%s %s\\n\",\n-\t\t\t       sort, name, fake_f_rep(\"long double\", val));\n-\t\t} else {\n-\t\t\tprintf(\"#define %s%s %s%s\\n\",\n-\t\t\t       sort, name, f_rep(precision, val), mark);\n-\t\t}\n-#else\n-\t\tprintf(\"#define %s%s %s%s\\n\",\n-\t\t       sort, name, f_rep(precision, val), mark);\n-#endif\n-\t} else if (*mark == 'F') {\n-\t\t/* non-ANSI C has no float constants, so cast the constant */\n-\t\tprintf(\"#define %s%s ((float)%s)\\n\",\n-\t\t       sort, name, f_rep(precision, val));\n-\t} else {\n-\t\tprintf(\"#define %s%s %s\\n\", sort, name, f_rep(precision, val));\n-\t}\n-\tVprintf(\"\\n\");\n-}\n-\n-int floor_log(base, x) int base; Long_double x; {\n-\t/* return floor(log base(x)) */\n-\tint r=0;\n-\twhile (x>=base) { r++; x/=base; }\n-\treturn r;\n-}\n-\n-int ceil_log(base, x) int base; Long_double x; {\n-\tint r=0;\n-\twhile (x>1.0) { r++; x/=base; }\n-\treturn r;\n-}\n-\n-int exponent(x, fract, exp) Long_double x; double *fract; int *exp; {\n-\t/* Split x into a fraction and a power of ten;\n-\t   returns 0 if x is unusable, 1 otherwise.\n-\t   Only used for error messages about faulty output.\n-\t*/\n-\tint r=0, neg=0;\n-\tLong_double old;\n-\t*fract=0.0; *exp=0;\n-\tif (x<0.0) {\n-\t\tx= -x;\n-\t\tneg= 1;\n-\t}\n-\tif (x==0.0) return 1;\n-\tif (x>=10.0) {\n-\t\twhile (x>=10.0) {\n-\t\t\told=x; r++; x/=10.0;\n-\t\t\tif (old==x) return 0;\n-\t\t}\n-\t} else {\n-\t\twhile (x<1.0) {\n-\t\t\told=x; r--; x*=10.0;\n-\t\t\tif (old==x) return 0;\n-\t\t}\n-\t}\n-\tif (neg) *fract= (double) -x;\n-\telse *fract=(double) x;\n-\t*exp=r;\n-\treturn 1;\n-}\n-\n-/* Print a value of type TYPE with value VAL,\n-   assuming that sprintf can't handle this type properly (without truncation).\n-   We create an expression that uses type casting to create the value from\n-   a bit pattern.  */\n-\n-char *fake_f_rep(type, val) char *type; Long_double val; {\n-\tstatic char buf[1024];\n-\tunion { unsigned int i[4]; Long_double ld;} u;\n-\tu.i[0] = u.i[1] = u.i[2] = u.i[3] = 0;\n-\tu.ld = val;\n-\tsprintf(buf, \"(__extension__ ((union __convert_long_double) {__convert_long_double_i: {0x%x, 0x%x, 0x%x, 0x%x}}).__convert_long_double_d)\",\n-\t\tu.i[0], u.i[1], u.i[2], u.i[3]);\n-\treturn buf;\n-}\n-\n-char *f_rep(precision, val) int precision; Long_double val; {\n-\t/* Return the floating representation of val */\n-\tstatic char buf[1024];\n-#ifdef NO_LONG_DOUBLE_IO\n-\tif (1)\n-#else\n-\tif (sizeof(double) == sizeof(Long_double))\n-#endif\n-\t{\n-\t\tdouble d = val;\n-\t\t/* Assume they're the same, and use non-stdc format */\n-\t\t/* This is for stdc compilers using non-stdc libraries */\n-\t\tsprintf(buf, \"%.*e\", precision, d);\n-\t} else {\n-\t\t/* It had better support Le then */\n-\t\tsprintf(buf, \"%.*Le\", precision, val);\n-\t}\n-\treturn buf;\n-}\n-\n-Procedure bitpattern(p, size) char *p; unsigned int size; {\n-\t/* Printf the bit-pattern of p */\n-\tchar c;\n-\tunsigned int i;\n-\tint j;\n-\n-\tfor (i=1; i<=size; i++) {\n-\t\tc= *p;\n-\t\tp++;\n-\t\tfor (j=bits_per_byte-1; j>=0; j--)\n-\t\t\tprintf(\"%c\", (c>>j)&1 ? '1' : '0');\n-\t\tif (i!=size) printf(\" \");\n-\t}\n-}\n-\n-#define Order(x, px, mode)\\\n-   printf(\"%s%s \", co, mode); for (i=0; i<sizeof(x); i++) px[i]= ab[i]; \\\n-   for (i=1; i<=sizeof(x); i++) { c=((x>>(bits_per_byte*(sizeof(x)-i)))&mask);\\\n-      putchar(c==0 ? '?' : (char)c); }\\\n-   printf(\"%s\\n\", oc);\n-\n-Procedure endian(bits_per_byte) int bits_per_byte; {\n-\t/* Printf the byte-order used on this machine */\n-\t/*unsigned*/ short s=0;\n-\t/*unsigned*/ int j=0;\n-\t/*unsigned*/ long l=0;\n-\n-\tchar *ps= (char *) &s,\n-\t     *pj= (char *) &j,\n-\t     *pl= (char *) &l,\n-\t     *ab= \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n-\tunsigned int mask, i, c;\n-\n-\tmask=0;\n-\tfor (i=1; i<=(unsigned)bits_per_byte; i++) mask= (mask<<1)|1;\n-\n-\tif (V) {\n-\t\tprintf(\"%sCHARACTER ORDER%s\\n\", co, oc);\n-\t\tOrder(s, ps, \"short:\");\n-\t\tOrder(j, pj, \"int:  \");\n-\t\tOrder(l, pl, \"long: \");\n-\t}\n-}\n-\n-Procedure missing(s) char *s; {\n-\tprintf(\"%s*** #define %s missing from limits.h%s\\n\", co, s, oc);\n-\tbugs++;\n-}\n-\n-Procedure fmissing(s) char *s; {\n-\tprintf(\"%s*** #define %s missing from float.h%s\\n\", co, s, oc);\n-\tbugs++;\n-}\n-\n-/* To try and fool optimisers */\n-int false() { return 0; }\n-\n-#define Promoted(x) (false()?(x):(-1))\n-#define is_signed(x) (Promoted(x) < 0)\n-#define sign_of(x) ((x)?\"signed\":\"unsigned\")\n-#define Signed 1\n-#define Unsigned 0\n-#define sgn(x) ((is_signed(x))?Signed:Unsigned)\n-\n-#define showtype(t, x) Vprintf(\"%s%s %s %s%s\\n\", co, t, sign_of(is_signed(x)), type_of(sizeof(x)), oc)\n-\n-char *type_of(x) int x; {\n-\tif (x == sizeof(char)) {\n-\t\tif (sizeof(char) == sizeof(int)) return \"char/short/int\";\n-\t\tif (sizeof(char) == sizeof(short)) return \"char/short\";\n-\t\treturn \"char\";\n-\t}\n-\tif (x == sizeof(short)) {\n-\t\tif (sizeof(short) == sizeof(int)) return \"short/int\";\n-\t\treturn \"short\";\n-\t}\n-\tif (x == sizeof(int)) {\n-\t\tif (sizeof(int) == sizeof(long)) return \"int/long\";\n-\t\treturn \"int\";\n-\t}\n-\tif (x == sizeof(long)) return \"long\";\n-\treturn \"unknown-type\";\n-}\n-\n-char *ftype_of(x) int x; {\n-\tif (x == sizeof(float)) {\n-\t\treturn \"float\";\n-\t}\n-\tif (x == sizeof(double)) {\n-\t\tif (sizeof(double) == sizeof(Long_double))\n-\t\t  return \"(long)double\";\n-\t\treturn \"double\";\n-\t}\n-\tif (x == sizeof(Long_double)) {\n-\t\treturn \"long double\";\n-\t}\n-\treturn \"unknown-type\";\n-}\n-\n-Procedure typerr(name, esign, esize, sign, size)\n-  char *name; int esign, esize, sign, size;\n-{\n-       Vprintf(\"*** %s has wrong type: expected %s %s, found %s %s\\n\",\n-\t       name, sign_of(esign), type_of(esize),\n-\t       sign_of(sign), type_of(size));\n-}\n-\n-Procedure ftyperr(name, esize, size) char *name; int esize, size; {\n-       Vprintf(\"*** %s has wrong type: expected %s, found %s\\n\",\n-\t       name, ftype_of(esize), ftype_of(size));\n-}\n-\n-int promotions() {\n-\tint si = 0; long sl = 0;\n-\tunsigned int ui; unsigned long ul;\n-\tshort ss; unsigned short us;\n-\n-\tVprintf(\"\\n%sPROMOTIONS%s\\n\", co, oc);\n-\n-\tif (\n-\t    /* Possible warnings here; no problem */\n-\t    (sizeof(Promoted(si)) != sizeof(int)) ||\n-\t    (sizeof(Promoted(sl)) != sizeof(long)) ||\n-\t    (sizeof(Promoted(ss)) != sizeof(int)) ||\n-\t    (sizeof(Promoted(ui)) != sizeof(int)) ||\n-\t    (sizeof(Promoted(ul)) != sizeof(long)) ||\n-\t    (sizeof(Promoted(us)) != sizeof(int)) ||\n-\t    is_signed(ui) || is_signed(ul) ||\n-\t    !is_signed(si) || !is_signed(sl)\n-\t    )\n-\t  {\n-\t    eek_a_bug(\"promotions don't work properly in conditional expressions\\n\");\n-\t  }\n-\n-\tshowtype(\"unsigned short promotes to\", Promoted((unsigned short) 0));\n-\tshowtype(\"long+unsigned gives\", sl+ui);\n-\treturn 0;\n-}\n-\n-#define checktype(x, n, s, t) if((sgn(x)!=s)||(sizeof(x)!=sizeof(t))) typerr(n, s, sizeof(t), sign_of(x), sizeof(x));\n-\n-#define fchecktype(x, n, t) if (sizeof(x) != sizeof(t)) ftyperr(n, sizeof(x), sizeof(t));\n-\n-Procedure check_defines() {\n-\t/* ensure that all #defines are present and have the correct type */\n-#ifdef VERIFY\n-\tint usign;\n-\n-#ifdef NO_UI\n-\tusign= Signed;\n-#else\n-\t/* Implementations promote unsigned short differently */\n-\tusign= is_signed((unsigned short) 0);\n-#endif\n-\n-\tif (L) {\n-#ifdef CHAR_BIT\n-\tchecktype(CHAR_BIT, \"CHAR_BIT\", Signed, int);\n-#else\n-\tmissing(\"CHAR_BIT\");\n-#endif\n-#ifdef CHAR_MAX\n-\tchecktype(CHAR_MAX, \"CHAR_MAX\", Signed, int);\n-#else\n-\tmissing(\"CHAR_MAX\");\n-#endif\n-#ifdef CHAR_MIN\n-\tchecktype(CHAR_MIN, \"CHAR_MIN\", Signed, int);\n-#else\n-\tmissing(\"CHAR_MIN\");\n-#endif\n-#ifdef SCHAR_MAX\n-\tchecktype(SCHAR_MAX, \"SCHAR_MAX\", Signed, int);\n-#else\n-\tmissing(\"SCHAR_MAX\");\n-#endif\n-#ifdef SCHAR_MIN\n-\tchecktype(SCHAR_MIN, \"SCHAR_MIN\", Signed, int);\n-#else\n-\tmissing(\"SCHAR_MIN\");\n-#endif\n-#ifdef UCHAR_MAX\n-\tchecktype(UCHAR_MAX, \"UCHAR_MAX\", Signed, int);\n-#else\n-\tmissing(\"UCHAR_MAX\");\n-#endif\n-#ifdef SHRT_MAX\n-\tchecktype(SHRT_MAX, \"SHRT_MAX\", Signed, int);\n-#else\n-\tmissing(\"SHRT_MAX\");\n-#endif\n-#ifdef SHRT_MIN\n-\tchecktype(SHRT_MIN, \"SHRT_MIN\", Signed, int);\n-#else\n-\tmissing(\"SHRT_MIN\");\n-#endif\n-#ifdef INT_MAX\n-\tchecktype(INT_MAX, \"INT_MAX\", Signed, int);\n-#else\n-\tmissing(\"INT_MAX\");\n-#endif\n-#ifdef INT_MIN\n-\tchecktype(INT_MIN, \"INT_MIN\", Signed, int);\n-#else\n-\tmissing(\"INT_MIN\");\n-#endif\n-#ifdef LONG_MAX\n-\tchecktype(LONG_MAX, \"LONG_MAX\", Signed, long);\n-#else\n-\tmissing(\"LONG_MAX\");\n-#endif\n-#ifdef LONG_MIN\n-\tchecktype(LONG_MIN, \"LONG_MIN\", Signed, long);\n-#else\n-\tmissing(\"LONG_MIN\");\n-#endif\n-#ifdef USHRT_MAX\n-\tchecktype(USHRT_MAX, \"USHRT_MAX\", usign, int);\n-#else\n-\tmissing(\"USHRT_MAX\");\n-#endif\n-#ifdef UINT_MAX\n-\tchecktype(UINT_MAX, \"UINT_MAX\", Unsigned, int);\n-#else\n-\tmissing(\"UINT_MAX\");\n-#endif\n-#ifdef ULONG_MAX\n-\tchecktype(ULONG_MAX, \"ULONG_MAX\", Unsigned, long);\n-#else\n-\tmissing(\"ULONG_MAX\");\n-#endif\n-\t} /* if (L) */\n-\n-\tif (F) {\n-#ifdef FLT_RADIX\n-\tchecktype(FLT_RADIX, \"FLT_RADIX\", Signed, int);\n-#else\n-\tfmissing(\"FLT_RADIX\");\n-#endif\n-#ifdef FLT_MANT_DIG\n-\tchecktype(FLT_MANT_DIG, \"FLT_MANT_DIG\", Signed, int);\n-#else\n-\tfmissing(\"FLT_MANT_DIG\");\n-#endif\n-#ifdef FLT_DIG\n-\tchecktype(FLT_DIG, \"FLT_DIG\", Signed, int);\n-#else\n-\tfmissing(\"FLT_DIG\");\n-#endif\n-#ifdef FLT_ROUNDS\n-\tchecktype(FLT_ROUNDS, \"FLT_ROUNDS\", Signed, int);\n-#else\n-\tfmissing(\"FLT_ROUNDS\");\n-#endif\n-#ifdef FLT_EPSILON\n-\tfchecktype(FLT_EPSILON, \"FLT_EPSILON\", float);\n-#else\n-\tfmissing(\"FLT_EPSILON\");\n-#endif\n-#ifdef FLT_MIN_EXP\n-\tchecktype(FLT_MIN_EXP, \"FLT_MIN_EXP\", Signed, int);\n-#else\n-\tfmissing(\"FLT_MIN_EXP\");\n-#endif\n-#ifdef FLT_MIN\n-\tfchecktype(FLT_MIN, \"FLT_MIN\", float);\n-#else\n-\tfmissing(\"FLT_MIN\");\n-#endif\n-#ifdef FLT_MIN_10_EXP\n-\tchecktype(FLT_MIN_10_EXP, \"FLT_MIN_10_EXP\", Signed, int);\n-#else\n-\tfmissing(\"FLT_MIN_10_EXP\");\n-#endif\n-#ifdef FLT_MAX_EXP\n-\tchecktype(FLT_MAX_EXP, \"FLT_MAX_EXP\", Signed, int);\n-#else\n-\tfmissing(\"FLT_MAX_EXP\");\n-#endif\n-#ifdef FLT_MAX\n-\tfchecktype(FLT_MAX, \"FLT_MAX\", float);\n-#else\n-\tfmissing(\"FLT_MAX\");\n-#endif\n-#ifdef FLT_MAX_10_EXP\n-\tchecktype(FLT_MAX_10_EXP, \"FLT_MAX_10_EXP\", Signed, int);\n-#else\n-\tfmissing(\"FLT_MAX_10_EXP\");\n-#endif\n-#ifdef DBL_MANT_DIG\n-\tchecktype(DBL_MANT_DIG, \"DBL_MANT_DIG\", Signed, int);\n-#else\n-\tfmissing(\"DBL_MANT_DIG\");\n-#endif\n-#ifdef DBL_DIG\n-\tchecktype(DBL_DIG, \"DBL_DIG\", Signed, int);\n-#else\n-\tfmissing(\"DBL_DIG\");\n-#endif\n-#ifdef DBL_EPSILON\n-\tfchecktype(DBL_EPSILON, \"DBL_EPSILON\", double);\n-#else\n-\tfmissing(\"DBL_EPSILON\");\n-#endif\n-#ifdef DBL_MIN_EXP\n-\tchecktype(DBL_MIN_EXP, \"DBL_MIN_EXP\", Signed, int);\n-#else\n-\tfmissing(\"DBL_MIN_EXP\");\n-#endif\n-#ifdef DBL_MIN\n-\tfchecktype(DBL_MIN, \"DBL_MIN\", double);\n-#else\n-\tfmissing(\"DBL_MIN\");\n-#endif\n-#ifdef DBL_MIN_10_EXP\n-\tchecktype(DBL_MIN_10_EXP, \"DBL_MIN_10_EXP\", Signed, int);\n-#else\n-\tfmissing(\"DBL_MIN_10_EXP\");\n-#endif\n-#ifdef DBL_MAX_EXP\n-\tchecktype(DBL_MAX_EXP, \"DBL_MAX_EXP\", Signed, int);\n-#else\n-\tfmissing(\"DBL_MAX_EXP\");\n-#endif\n-#ifdef DBL_MAX\n-\tfchecktype(DBL_MAX, \"DBL_MAX\", double);\n-#else\n-\tfmissing(\"DBL_MAX\");\n-#endif\n-#ifdef DBL_MAX_10_EXP\n-\tchecktype(DBL_MAX_10_EXP, \"DBL_MAX_10_EXP\", Signed, int);\n-#else\n-\tfmissing(\"DBL_MAX_10_EXP\");\n-#endif\n-#ifdef STDC\n-#ifdef LDBL_MANT_DIG\n-\tchecktype(LDBL_MANT_DIG, \"LDBL_MANT_DIG\", Signed, int);\n-#else\n-\tfmissing(\"LDBL_MANT_DIG\");\n-#endif\n-#ifdef LDBL_DIG\n-\tchecktype(LDBL_DIG, \"LDBL_DIG\", Signed, int);\n-#else\n-\tfmissing(\"LDBL_DIG\");\n-#endif\n-#ifdef LDBL_EPSILON\n-\tfchecktype(LDBL_EPSILON, \"LDBL_EPSILON\", long double);\n-#else\n-\tfmissing(\"LDBL_EPSILON\");\n-#endif\n-#ifdef LDBL_MIN_EXP\n-\tchecktype(LDBL_MIN_EXP, \"LDBL_MIN_EXP\", Signed, int);\n-#else\n-\tfmissing(\"LDBL_MIN_EXP\");\n-#endif\n-#ifdef LDBL_MIN\n-\tfchecktype(LDBL_MIN, \"LDBL_MIN\", long double);\n-#else\n-\tfmissing(\"LDBL_MIN\");\n-#endif\n-#ifdef LDBL_MIN_10_EXP\n-\tchecktype(LDBL_MIN_10_EXP, \"LDBL_MIN_10_EXP\", Signed, int);\n-#else\n-\tfmissing(\"LDBL_MIN_10_EXP\");\n-#endif\n-#ifdef LDBL_MAX_EXP\n-\tchecktype(LDBL_MAX_EXP, \"LDBL_MAX_EXP\", Signed, int);\n-#else\n-\tfmissing(\"LDBL_MAX_EXP\");\n-#endif\n-#ifdef LDBL_MAX\n-\tfchecktype(LDBL_MAX, \"LDBL_MAX\", long double);\n-#else\n-\tfmissing(\"LDBL_MAX\");\n-#endif\n-#ifdef LDBL_MAX_10_EXP\n-\tchecktype(LDBL_MAX_10_EXP, \"LDBL_MAX_10_EXP\", Signed, int);\n-#else\n-\tfmissing(\"LDBL_MAX_10_EXP\");\n-#endif\n-#endif /* STDC */\n-\t} /* if (F) */\n-#endif /* VERIFY */\n-}\n-\n-#ifdef VERIFY\n-#ifndef SCHAR_MAX\n-#define SCHAR_MAX\tchar_max\n-#endif\n-#ifndef SCHAR_MIN\n-#define SCHAR_MIN\tchar_min\n-#endif\n-#ifndef UCHAR_MAX\n-#define UCHAR_MAX\tchar_max\n-#endif\n-#endif /* VERIFY */\n-\n-#ifndef CHAR_BIT\n-#define CHAR_BIT\tchar_bit\n-#endif\n-#ifndef CHAR_MAX\n-#define CHAR_MAX\tchar_max\n-#endif\n-#ifndef CHAR_MIN\n-#define CHAR_MIN\tchar_min\n-#endif\n-#ifndef SCHAR_MAX\n-#define SCHAR_MAX\tchar_max\n-#endif\n-#ifndef SCHAR_MIN\n-#define SCHAR_MIN\tchar_min\n-#endif\n-#ifndef UCHAR_MAX\n-#define UCHAR_MAX\tchar_max\n-#endif\n-\n-int cprop() {\n-\t/* Properties of type char */\n-\tVolatile char c, char_max, char_min;\n-\tVolatile int bits_per_byte, c_signed;\n-\tlong char_bit;\n-\n-\tUnexpected(2);\n-\n-\t/* Calculate number of bits per character *************************/\n-\tc=1; bits_per_byte=0;\n-\tdo { c=c<<1; bits_per_byte++; } while(c!=0);\n-\tc= (char)(-1);\n-\tif (((int)c)<0) c_signed=1;\n-\telse c_signed=0;\n-\tVprintf(\"%schar = %d bits, %ssigned%s\\n\",\n-\t\tco, (int)sizeof(c)*bits_per_byte, (c_signed?\"\":\"un\"), oc);\n-\tchar_bit=(long)(sizeof(c)*bits_per_byte);\n-\tif (L) i_define(D_CHAR_BIT, \"\", \"CHAR\", \"_BIT\",\n-\t\t\tchar_bit, 0L, (long) CHAR_BIT, \"\");\n-\n-\tc=0; char_max=0;\n-\tc++;\n-\tif (bits_per_byte <= 16) {\n-\t     if (setjmp(lab)==0) { /* Yields char_max */\n-\t\t  while (c>char_max) {\n-\t\t       char_max=c;\n-\t\t       c++;\n-\t\t  }\n-\t     } else {\n-\t\t  Vprintf(\"%sCharacter overflow generates a trap!%s\\n\",\n-\t\t\t  co, oc);\n-\t     }\n-\t     c=0; char_min=0;\n-\t     c--;\n-\t     if (setjmp(lab)==0) { /* Yields char_min */\n-\t\t  while (c<char_min) {\n-\t\t       char_min=c;\n-\t\t       c--;\n-\t\t  }\n-\t     }\n-\t} else {\n-\t     /* An exhaustive search here is impracticable ;-)  */\n-\t     c = (1 << (bits_per_byte - 1)) - 1;\n-\t     char_max = c;\n-\t     c++;\n-\t     if (c > char_max)\n-\t\t  char_max = ~0;\n-\t     c = 0;\n-\t     char_min = 0;\n-\t     c--;\n-\t     if (c < char_min) {\n-\t\t  c = (1 << (bits_per_byte - 1)) - 1;\n-\t\t  c = -c;\n-\t\t  char_min = c;\n-\t\t  c--;\n-\t\t  if (c < char_min)\n-\t\t       char_min = c;\n-\t     }\n-\t}\n-\tif (c_signed && char_min == 0) {\n-\t\tVprintf(\"%sBEWARE! Chars are pseudo-unsigned:%s\\n\", co, oc);\n-\t\tVprintf(\"%s   %s%s%s\\n\",\n-\t\t\t\"They contain only nonnegative values, \",\n-\t\t\t\"but sign extend when used as integers.\", co, oc);\n-\t}\n-\tUnexpected(3);\n-\n-\tif (L) {\n-\t\t/* Because of the integer promotions, you must use a U after\n-\t\t   the MAX_CHARS in the following cases */\n-\t\tif ((sizeof(char) == sizeof(int)) && !c_signed) {\n-\t\t\tu_define(D_CHAR_MAX, \"\", \"CHAR\", \"_MAX\",\n-\t\t\t\t (long) char_max,\n-\t\t\t\t (long) CHAR_MAX, \"\");\n-\t\t} else {\n-\t\t\ti_define(D_CHAR_MAX, \"\", \"CHAR\", \"_MAX\",\n-\t\t\t\t (long) char_max, 0L,\n-\t\t\t\t (long) CHAR_MAX, \"\");\n-\t\t}\n-\t\ti_define(D_CHAR_MIN, \"\", \"CHAR\", \"_MIN\",\n-\t\t\t (long) char_min, (long) maxint,\n-\t\t\t (long) CHAR_MIN, \"\");\n-\t\tif (c_signed) {\n-\t\t\ti_define(D_SCHAR_MAX, \"\", \"SCHAR\", \"_MAX\",\n-\t\t\t\t (long) char_max, 0L,\n-\t\t\t\t (long) SCHAR_MAX, \"\");\n-\t\t\ti_define(D_SCHAR_MIN, \"\", \"SCHAR\", \"_MIN\",\n-\t\t\t\t (long) char_min, (long) maxint,\n-\t\t\t\t (long) SCHAR_MIN, \"\");\n-\t\t} else {\n-\t\t\tif (sizeof(char) == sizeof(int)) {\n-\t\t\t\tu_define(D_UCHAR_MAX, \"\", \"UCHAR\", \"_MAX\",\n-\t\t\t\t\t (long) char_max,\n-\t\t\t\t\t (long) UCHAR_MAX, \"\");\n-\t\t\t} else {\n-\t\t\t\ti_define(D_UCHAR_MAX, \"\", \"UCHAR\", \"_MAX\",\n-\t\t\t\t\t (long) char_max, 0L,\n-\t\t\t\t\t (long) UCHAR_MAX, \"\");\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (c_signed) {\n-#ifndef NO_UC\n-\t\t\tVolatile unsigned char c, char_max;\n-\t\t\tc=0; char_max=0;\n-\t\t\tc++;\n-\t\t\tif (setjmp(lab)==0) { /* Yields char_max */\n-\t\t\t\twhile (c>char_max) {\n-\t\t\t\t\tchar_max=c;\n-\t\t\t\t\tc++;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tUnexpected(4);\n-\t\t\tif (sizeof(char) == sizeof(int)) {\n-\t\t\t\tu_define(D_UCHAR_MAX, \"\", \"UCHAR\", \"_MAX\",\n-\t\t\t\t\t (long) char_max,\n-\t\t\t\t\t (long) UCHAR_MAX, \"\");\n-\t\t\t} else {\n-\t\t\t\ti_define(D_UCHAR_MAX, \"\", \"UCHAR\", \"_MAX\",\n-\t\t\t\t\t (long) char_max, 0L,\n-\t\t\t\t\t (long) UCHAR_MAX, \"\");\n-\t\t\t}\n-#endif\n-\t\t} else {\n-#ifndef NO_SC\n-/* Define NO_SC if this gives a syntax error */ Volatile signed char c, char_max, char_min;\n-\t\t\tc=0; char_max=0;\n-\t\t\tc++;\n-\t\t\tif (setjmp(lab)==0) { /* Yields char_max */\n-\t\t\t\twhile (c>char_max) {\n-\t\t\t\t\tchar_max=c;\n-\t\t\t\t\tc++;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tc=0; char_min=0;\n-\t\t\tc--;\n-\t\t\tif (setjmp(lab)==0) { /* Yields char_min */\n-\t\t\t\twhile (c<char_min) {\n-\t\t\t\t\tchar_min=c;\n-\t\t\t\t\tc--;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tUnexpected(5);\n-\t\t\ti_define(D_SCHAR_MIN, \"\", \"SCHAR\", \"_MIN\",\n-\t\t\t\t (long) char_min, (long) maxint,\n-\t\t\t\t (long) SCHAR_MIN, \"\");\n-\t\t\ti_define(D_SCHAR_MAX, \"\", \"SCHAR\", \"_MAX\",\n-\t\t\t\t (long) char_max, 0L,\n-\t\t\t\t (long) SCHAR_MAX, \"\");\n-#endif /* NO_SC */\n-\t\t}\n-\t}\n-\treturn bits_per_byte;\n-}\n-\n-int basic() {\n-\t/* The properties of the basic types.\n-\t   Returns number of bits per sizeof unit */\n-\tVolatile int bits_per_byte;\n-\ttypedef int function ();\n-\tint variable;\n-\tint *p, *q;\n-\n-\tVprintf(\"%sSIZES%s\\n\", co, oc);\n-\tbits_per_byte= cprop();\n-\n-\t/* Shorts, ints and longs *****************************************/\n-\tVprintf(\"%sshort=%d int=%d long=%d float=%d double=%d bits %s\\n\",\n-\t\tco,\n-\t\t(int) sizeof(short)*bits_per_byte,\n-\t\t(int) sizeof(int)*bits_per_byte,\n-\t\t(int) sizeof(long)*bits_per_byte,\n-\t\t(int) sizeof(float)*bits_per_byte,\n-\t\t(int) sizeof(double)*bits_per_byte, oc);\n-\tif (stdc) {\n-\t\tVprintf(\"%slong double=%d bits%s\\n\",\n-\t\t\tco, (int) sizeof(Long_double)*bits_per_byte, oc);\n-\t}\n-\tVprintf(\"%schar*=%d bits%s%s\\n\",\n-\t\tco, (int)sizeof(char *)*bits_per_byte,\n-\t\tsizeof(char *)>sizeof(int)?\" BEWARE! larger than int!\":\"\",\n-\t\toc);\n-\tVprintf(\"%sint* =%d bits%s%s\\n\",\n-\t\tco, (int)sizeof(int *)*bits_per_byte,\n-\t\tsizeof(int *)>sizeof(int)?\" BEWARE! larger than int!\":\"\",\n-\t\toc);\n-\tVprintf(\"%sfunc*=%d bits%s%s\\n\",\n-\t\tco, (int)sizeof(function *)*bits_per_byte,\n-\t\tsizeof(function *)>sizeof(int)?\" BEWARE! larger than int!\":\"\",\n-\t\toc);\n-if (V) printf (\"%s%s %s %s%s\\n\", co, \"Type size_t is\",\n-\t\t       ((((false()?( sizeof(int)):(-1))  < 0) )?\n-\t\t\t\"signed\":\"unsigned\") ,\n-\t\t       type_of(sizeof(\n-\t\t\t\t      sizeof(int)+0\n-\t\t\t\t      )\n-\t\t\t       ),\n-\t       oc);\n-\tshowtype(\"Type size_t is\", sizeof(0));\n-\n-\t/* Alignment constants ********************************************/\n-\n-#define alignment(TYPE) \\\n-\t((long)((char *)&((struct{char c; TYPE d;}*)0)->d - (char *) 0))\n-\n-\tVprintf(\"\\n%sALIGNMENTS%s\\n\", co, oc);\n-\n-\tVprintf(\"%schar=%ld short=%ld int=%ld long=%ld%s\\n\",\n-\t\tco,\n-\t\talignment(char), alignment(short),\n-\t\talignment(int), alignment(long),\n-\t\toc);\n-\n-\tVprintf(\"%sfloat=%ld double=%ld%s\\n\",\n-\t\tco,\n-\t\talignment(float), alignment(double),\n-\t\toc);\n-\n-\tif (stdc) {\n-\t\tVprintf(\"%slong double=%ld%s\\n\",\n-\t\t\tco,\n-\t\t\talignment(Long_double),\n-\t\t\toc);\n-\t}\n-\tVprintf(\"%schar*=%ld int*=%ld func*=%ld%s\\n\",\n-\t\tco,\n-\t\talignment(char *), alignment(int *), alignment(function *),\n-\t\toc);\n-\n-\tVprintf(\"\\n\");\n-\n-\t/* Ten little endians *********************************************/\n-\n-\tendian(bits_per_byte);\n-\n-\t/* Pointers *******************************************************/\n-\n-\tVprintf(\"\\n%sPROPERTIES OF POINTERS%s\\n\", co, oc);\n-\n-\tif ((long) (char *) &variable == (long) (int *) &variable) {\n-\t\tVprintf(\"%sChar and int pointer formats seem identical%s\\n\",\n-\t\t       co, oc);\n-\t} else {\n-\t\tVprintf(\"%sChar and int pointer formats are different%s\\n\",\n-\t\t       co, oc);\n-\t}\n-\tif ((long) (char *) &variable == (long) (function *) &variable) {\n-\t\tVprintf(\"%sChar and function pointer formats seem identical%s\\n\",\n-\t\t       co, oc);\n-\t} else {\n-\t\tVprintf(\"%sChar and function pointer formats are different%s\\n\",\n-\t\t       co, oc);\n-\t}\n-\n-\tif (V) {\n-\t\tif (\"abcd\"==\"abcd\")\n-\t\t\tprintf(\"%sStrings are shared%s\\n\", co, oc);\n-\t\telse printf(\"%sStrings are not shared%s\\n\", co, oc);\n-\t}\n-\n-\tp=0; q=0;\n-\tshowtype(\"Type ptrdiff_t is\", p-q);\n-\n-\tVprintf(\"\\n%sPROPERTIES OF INTEGRAL TYPES%s\\n\", co, oc);\n-\n-\tsprop();\n-\tiprop();\n-\tlprop();\n-\tusprop();\n-\tuiprop();\n-\tulprop();\n-\n-\tpromotions();\n-\n-\tUnexpected(6);\n-\n-\treturn bits_per_byte;\n-}\n-\n-#else /* not PASS0 */\n-\n-#ifdef SEP\n-extern jmp_buf lab;\n-extern int V, L, F, bugs, bits_per_byte;\n-extern char co[], oc[];\n-extern char *f_rep();\n-#endif /* SEP */\n-#endif /* ifdef PASS0 */\n-\n-/* As I said, I apologise for the contortions below. The functions are\n-   expanded by the preprocessor twice or three times (for float and double,\n-   and maybe for long double, and for short, int and long). That way,\n-   I never make a change to one that I forget to make to the other.\n-   You can look on it as C's fault for not supporting multi-line macro's.\n-   This whole file is read 3 times by the preprocessor, with PASSn set for\n-   n=1, 2 or 3, to decide which parts to reprocess.\n-*/\n-\n-/* #undef on an already undefined thing is (wrongly) flagged as an error\n-   by some compilers, therefore the #ifdef that follows:\n-*/\n-#ifdef Number\n-#undef Number\n-#undef THING\n-#undef Thing\n-#undef thing\n-#undef FPROP\n-#undef Fname\n-#undef Store\n-#undef Sum\n-#undef Diff\n-#undef Mul\n-#undef Div\n-#undef ZERO\n-#undef HALF\n-#undef ONE\n-#undef TWO\n-#undef THREE\n-#undef FOUR\n-#undef Self\n-#undef F_check\n-#undef Validate\n-#undef EPROP\n-#undef MARK\n-\n-/* These are the float.h constants */\n-#undef F_RADIX\n-#undef F_MANT_DIG\n-#undef F_DIG\n-#undef F_ROUNDS\n-#undef F_EPSILON\n-#undef F_MIN_EXP\n-#undef F_MIN\n-#undef F_MIN_10_EXP\n-#undef F_MAX_EXP\n-#undef F_MAX\n-#undef F_MAX_10_EXP\n-#endif\n-\n-#ifdef Integer\n-#undef Integer\n-#undef INT\n-#undef IPROP\n-#undef Iname\n-#undef UPROP\n-#undef Uname\n-#undef OK_UI\n-#undef IMARK\n-\n-#undef I_MAX\n-#undef I_MIN\n-#undef U_MAX\n-#endif\n-\n-#ifdef PASS1\n-\n-/* Define the things we're going to use this pass */\n-\n-#define Number\tfloat\n-#define THING\t\"FLOAT\"\n-#define Thing\t\"Float\"\n-#define thing\t\"float\"\n-#define Fname\t\"FLT\"\n-#define FPROP\tfprop\n-#define Store\tfStore\n-#define Sum\tfSum\n-#define Diff\tfDiff\n-#define Mul\tfMul\n-#define Div\tfDiv\n-#define ZERO\t0.0\n-#define HALF\t0.5\n-#define ONE\t1.0\n-#define TWO\t2.0\n-#define THREE\t3.0\n-#define FOUR\t4.0\n-#define Self\tfSelf\n-#define F_check\tfCheck\n-#define MARK\t\"F\"\n-#ifdef VERIFY\n-#define Validate(prec, val, req, same) fValidate(prec, val, req, same)\n-#endif\n-\n-#define EPROP\tefprop\n-\n-#define Integer\tshort\n-#define INT\t\"short\"\n-#define IPROP\tsprop\n-#define Iname\t\"SHRT\"\n-#ifndef NO_UI\n-#define OK_UI 1\n-#endif\n-#define IMARK\t\"\"\n-\n-#define UPROP\tusprop\n-#define Uname\t\"USHRT\"\n-\n-#ifdef SHRT_MAX\n-#define I_MAX\t\tSHRT_MAX\n-#endif\n-#ifdef SHRT_MIN\n-#define I_MIN\t\tSHRT_MIN\n-#endif\n-#ifdef USHRT_MAX\n-#define U_MAX\t\tUSHRT_MAX\n-#endif\n-\n-#ifdef FLT_RADIX\n-#define F_RADIX\t\tFLT_RADIX\n-#endif\n-#ifdef FLT_MANT_DIG\n-#define F_MANT_DIG\tFLT_MANT_DIG\n-#endif\n-#ifdef FLT_DIG\n-#define F_DIG\t\tFLT_DIG\n-#endif\n-#ifdef FLT_ROUNDS\n-#define F_ROUNDS\tFLT_ROUNDS\n-#endif\n-#ifdef FLT_EPSILON\n-#define F_EPSILON\tFLT_EPSILON\n-#endif\n-#ifdef FLT_MIN_EXP\n-#define F_MIN_EXP\tFLT_MIN_EXP\n-#endif\n-#ifdef FLT_MIN\n-#define F_MIN\t\tFLT_MIN\n-#endif\n-#ifdef FLT_MIN_10_EXP\n-#define F_MIN_10_EXP\tFLT_MIN_10_EXP\n-#endif\n-#ifdef FLT_MAX_EXP\n-#define F_MAX_EXP\tFLT_MAX_EXP\n-#endif\n-#ifdef FLT_MAX\n-#define F_MAX\t\tFLT_MAX\n-#endif\n-#ifdef FLT_MAX_10_EXP\n-#define F_MAX_10_EXP\tFLT_MAX_10_EXP\n-#endif\n-\n-#endif /* PASS1 */\n-\n-#ifdef PASS2\n-\n-#define Number\tdouble\n-#define THING\t\"DOUBLE\"\n-#define Thing\t\"Double\"\n-#define thing\t\"double\"\n-#define Fname\t\"DBL\"\n-#define FPROP\tdprop\n-#define Store\tdStore\n-#define Sum\tdSum\n-#define Diff\tdDiff\n-#define Mul\tdMul\n-#define Div\tdDiv\n-#define ZERO\t0.0\n-#define HALF\t0.5\n-#define ONE\t1.0\n-#define TWO\t2.0\n-#define THREE\t3.0\n-#define FOUR\t4.0\n-#define Self\tdSelf\n-#define F_check\tdCheck\n-#define MARK\t\"\"\n-#ifdef VERIFY\n-#define Validate(prec, val, req, same) dValidate(prec, val, req, same)\n-#endif\n-\n-#define EPROP\tedprop\n-\n-#define Integer\tint\n-#define INT\t\"int\"\n-#define IPROP\tiprop\n-#define Iname\t\"INT\"\n-#define OK_UI\t1 /* Unsigned int is always possible */\n-#define IMARK\t\"\"\n-\n-#define UPROP\tuiprop\n-#define Uname\t\"UINT\"\n-\n-#ifdef INT_MAX\n-#define I_MAX\t\tINT_MAX\n-#endif\n-#ifdef INT_MIN\n-#define I_MIN\t\tINT_MIN\n-#endif\n-#ifdef UINT_MAX\n-#define U_MAX\t\tUINT_MAX\n-#endif\n-\n-#ifdef DBL_MANT_DIG\n-#define F_MANT_DIG\tDBL_MANT_DIG\n-#endif\n-#ifdef DBL_DIG\n-#define F_DIG\t\tDBL_DIG\n-#endif\n-#ifdef DBL_EPSILON\n-#define F_EPSILON\tDBL_EPSILON\n-#endif\n-#ifdef DBL_MIN_EXP\n-#define F_MIN_EXP\tDBL_MIN_EXP\n-#endif\n-#ifdef DBL_MIN\n-#define F_MIN\t\tDBL_MIN\n-#endif\n-#ifdef DBL_MIN_10_EXP\n-#define F_MIN_10_EXP\tDBL_MIN_10_EXP\n-#endif\n-#ifdef DBL_MAX_EXP\n-#define F_MAX_EXP\tDBL_MAX_EXP\n-#endif\n-#ifdef DBL_MAX\n-#define F_MAX\t\tDBL_MAX\n-#endif\n-#ifdef DBL_MAX_10_EXP\n-#define F_MAX_10_EXP\tDBL_MAX_10_EXP\n-#endif\n-\n-#endif /* PASS2 */\n-\n-#ifdef PASS3\n-\n-#ifdef STDC\n-#define Number\tlong double\n-\n-#define ZERO\t0.0L\n-#define HALF\t0.5L\n-#define ONE\t1.0L\n-#define TWO\t2.0L\n-#define THREE\t3.0L\n-#define FOUR\t4.0L\n-#endif\n-\n-#define THING\t\"LONG DOUBLE\"\n-#define Thing\t\"Long double\"\n-#define thing\t\"long double\"\n-#define Fname\t\"LDBL\"\n-#define FPROP\tldprop\n-#define Store\tldStore\n-#define Sum\tldSum\n-#define Diff\tldDiff\n-#define Mul\tldMul\n-#define Div\tldDiv\n-#define Self\tldSelf\n-#define F_check\tldCheck\n-#define MARK\t\"L\"\n-#ifdef VERIFY\n-#define Validate(prec, val, req, same) ldValidate(prec, val, req, same)\n-#endif\n-\n-#define EPROP\teldprop\n-\n-#define Integer\tlong\n-#define INT\t\"long\"\n-#define IPROP\tlprop\n-#define Iname\t\"LONG\"\n-#ifndef NO_UI\n-#define OK_UI\t1\n-#endif\n-#define IMARK\t\"L\"\n-\n-#define UPROP\tulprop\n-#define Uname\t\"ULONG\"\n-\n-#ifdef LONG_MAX\n-#define I_MAX\tLONG_MAX\n-#endif\n-#ifdef LONG_MIN\n-#define I_MIN\tLONG_MIN\n-#endif\n-#ifdef ULONG_MAX\n-#define U_MAX\tULONG_MAX\n-#endif\n-\n-#ifdef LDBL_MANT_DIG\n-#define F_MANT_DIG\tLDBL_MANT_DIG\n-#endif\n-#ifdef LDBL_DIG\n-#define F_DIG\t\tLDBL_DIG\n-#endif\n-#ifdef LDBL_EPSILON\n-#define F_EPSILON\tLDBL_EPSILON\n-#endif\n-#ifdef LDBL_MIN_EXP\n-#define F_MIN_EXP\tLDBL_MIN_EXP\n-#endif\n-#ifdef LDBL_MIN\n-#define F_MIN\t\tLDBL_MIN\n-#endif\n-#ifdef LDBL_MIN_10_EXP\n-#define F_MIN_10_EXP\tLDBL_MIN_10_EXP\n-#endif\n-#ifdef LDBL_MAX_EXP\n-#define F_MAX_EXP\tLDBL_MAX_EXP\n-#endif\n-#ifdef LDBL_MAX\n-#define F_MAX\t\tLDBL_MAX\n-#endif\n-#ifdef LDBL_MAX_10_EXP\n-#define F_MAX_10_EXP\tLDBL_MAX_10_EXP\n-#endif\n-\n-#endif /* PASS3 */\n-\n-#define UNDEFINED (-2)\n-\n-#ifndef I_MAX\n-#define I_MAX\t((unsigned long) UNDEFINED)\n-#endif\n-#ifndef I_MIN\n-#define I_MIN\t((unsigned long) UNDEFINED)\n-#endif\n-#ifndef U_MAX\n-#define U_MAX\t((unsigned long) UNDEFINED)\n-#endif\n-\n-#ifndef F_RADIX\n-#define F_RADIX\t\tUNDEFINED\n-#endif\n-#ifndef F_MANT_DIG\n-#define F_MANT_DIG\tUNDEFINED\n-#endif\n-#ifndef F_DIG\n-#define F_DIG\t\tUNDEFINED\n-#endif\n-#ifndef F_ROUNDS\n-#define F_ROUNDS\tUNDEFINED\n-#endif\n-#ifndef F_EPSILON\n-#define F_EPSILON\t((Number) UNDEFINED)\n-#endif\n-#ifndef F_MIN_EXP\n-#define F_MIN_EXP\tUNDEFINED\n-#endif\n-#ifndef F_MIN\n-#define F_MIN\t\t((Number) UNDEFINED)\n-#endif\n-#ifndef F_MIN_10_EXP\n-#define F_MIN_10_EXP\tUNDEFINED\n-#endif\n-#ifndef F_MAX_EXP\n-#define F_MAX_EXP\tUNDEFINED\n-#endif\n-#ifndef F_MAX\n-#define F_MAX\t\t((Number) UNDEFINED)\n-#endif\n-#ifndef F_MAX_10_EXP\n-#define F_MAX_10_EXP\tUNDEFINED\n-#endif\n-\n-#ifndef VERIFY\n-#define Validate(prec, val, req, same) {;}\n-#endif\n-\n-#ifdef Integer\n-\n-Procedure IPROP() {\n-\t/* the properties of short, int, and long */\n-\tVolatile Integer newi, int_max, maxeri, int_min, minneri;\n-\tVolatile int ibits, ipower, two=2;\n-\n-\t/* Calculate max short/int/long ***********************************/\n-\t/* Calculate 2**n-1 until overflow - then use the previous value  */\n-\n-\tnewi=1; int_max=0;\n-\n-\tif (setjmp(lab)==0) { /* Yields int_max */\n-\t\tfor(ipower=0; newi>int_max; ipower++) {\n-\t\t\tint_max=newi;\n-\t\t\tnewi=newi*two+1;\n-\t\t}\n-\t\tVprintf(\"%sOverflow of a%s %s does not generate a trap%s\\n\",\n-\t\t\tco, INT[0]=='i'?\"n\":\"\", INT, oc);\n-\t} else {\n-\t\tVprintf(\"%sOverflow of a%s %s generates a trap%s\\n\",\n-\t\t\tco, INT[0]=='i'?\"n\":\"\", INT, oc);\n-\t}\n-\tUnexpected(7);\n-\n-\t/* Minimum value: assume either two's or one's complement *********/\n-\tint_min= -int_max;\n-\tif (setjmp(lab)==0) { /* Yields int_min */\n-\t\tif (int_min-1 < int_min) int_min--;\n-\t}\n-\tUnexpected(8);\n-\n-\t/* Now for those daft Cybers */\n-\n-\tmaxeri=0; newi=int_max;\n-\n-\tif (setjmp(lab)==0) { /* Yields maxeri */\n-\t\tfor(ibits=ipower; newi>maxeri; ibits++) {\n-\t\t\tmaxeri=newi;\n-\t\t\tnewi=newi+newi+1;\n-\t\t}\n-\t}\n-\tUnexpected(9);\n-\n-\tminneri= -maxeri;\n-\tif (setjmp(lab)==0) { /* Yields minneri */\n-\t\tif (minneri-1 < minneri) minneri--;\n-\t}\n-\tUnexpected(10);\n-\n-\tVprintf(\"%sMaximum %s = %ld (= 2**%d-1)%s\\n\",\n-\t\tco, INT, (long)int_max, ipower, oc);\n-\tVprintf(\"%sMinimum %s = %ld%s\\n\", co, INT, (long)int_min, oc);\n-\n-\tif (L) i_define(D_INT_MAX, INT, Iname, \"_MAX\",\n-\t\t\t(long) int_max, 0L,\n-\t\t\t(long) I_MAX, IMARK);\n-\tif (L) i_define(D_INT_MIN, INT, Iname, \"_MIN\",\n-\t\t\t(long) int_min, (long) (PASS==1?maxint:int_max),\n-\t\t\t(long) I_MIN, IMARK);\n-\n-\tif(int_max < 0) { /* It has happened */\n-\t\teek_a_bug(\"signed integral comparison faulty?\");\n-\t}\n-\n-\tif (maxeri>int_max) {\n-\t\tVprintf(\"%sThere is a larger %s, %ld (= 2**%d-1), %s %s%s\\n\",\n-\t\t\tco, INT, (long)maxeri, ibits,\n-\t\t\t\"but only for addition, not multiplication\",\n-\t\t\t\"(I smell a Cyber!)\",\n-\t\t\toc);\n-\t}\n-\n-\tif (minneri<int_min) {\n-\t\tVprintf(\"%sThere is a smaller %s, %ld, %s %s%s\\n\",\n-\t\t\tco, INT, (long)minneri,\n-\t\t\t\"but only for addition, not multiplication\",\n-\t\t\t\"(I smell a Cyber!)\",\n-\t\t\toc);\n-\t}\n-}\n-\n-Procedure UPROP () {\n-\t/* The properties of unsigned short/int/long */\n-#ifdef OK_UI\n-\tVolatile unsigned Integer u_max, newi, two;\n-\tnewi=1; u_max=0; two=2;\n-\n-\tif (setjmp(lab)==0) { /* Yields u_max */\n-\t\twhile(newi>u_max) {\n-\t\t\tu_max=newi;\n-\t\t\tnewi=newi*two+1;\n-\t\t}\n-\t}\n-\tUnexpected(11);\n-\tVprintf(\"%sMaximum unsigned %s = %lu%s\\n\",\n-\t\tco, INT, (unsigned long) u_max, oc);\n-\n-\t/* Oh woe: new standard C defines value preserving promotions */\n-\tif (L) {\n-\t\tif (PASS == 1 && sizeof(short) < sizeof(int)) {\n-\t\t\t/* Special only for short */\n-\t\t\ti_define(D_UINT_MAX, INT, Uname, \"_MAX\",\n-\t\t\t\t (unsigned long) u_max, 0L,\n-\t\t\t\t (unsigned long) U_MAX, IMARK);\n-\t\t} else {\n-\t\t\tu_define(D_UINT_MAX, INT, Uname, \"_MAX\",\n-\t\t\t\t (unsigned long) u_max,\n-\t\t\t\t (unsigned long) U_MAX, IMARK);\n-\t\t}\n-\t}\n-#endif\n-}\n-\n-#endif /* Integer */\n-\n-#ifdef Number\n-\n-/* The following routines are intended to defeat any attempt at optimisation\n-   or use of extended precision, and to defeat faulty narrowing casts.\n-   The weird prototypes are because of widening incompatibilities.\n-*/\n-#ifdef STDC\n-#define ARGS1(atype, a) (atype a)\n-#define ARGS2(atype, a, btype, b) (atype a, btype b)\n-#else\n-#define ARGS1(atype, a) (a) atype a;\n-#define ARGS2(atype, a, btype, b) (a, b) atype a; btype b;\n-#endif\n-\n-Procedure Store ARGS2(Number, a, Number *, b) { *b=a; }\n-Number Sum ARGS2(Number, a, Number, b) {Number r; Store(a+b, &r); return (r); }\n-Number Diff ARGS2(Number, a, Number, b){Number r; Store(a-b, &r); return (r); }\n-Number Mul ARGS2(Number, a, Number, b) {Number r; Store(a*b, &r); return (r); }\n-Number Div ARGS2(Number, a, Number, b) {Number r; Store(a/b, &r); return (r); }\n-Number Self ARGS1(Number, a)\t       {Number r; Store(a,   &r); return (r); }\n-\n-Procedure F_check ARGS((int precision, Long_double val1));\n-\n-Procedure F_check(precision, val1) int precision; Long_double val1; {\n-\t/* You don't think I'm going to go to all the trouble of writing\n-\t   a program that works out what all sorts of values are, only to\n-\t   have printf go and print the wrong values out, do you?\n-\t   No, you're right, so this function tries to see if printf\n-\t   has written the right value, by reading it back again.\n-\t   This introduces a new problem of course: suppose printf writes\n-\t   the correct value, and scanf reads it back wrong... oh well.\n-\t   But I'm adamant about this: the precision given is enough\n-\t   to uniquely identify the printed number, therefore I insist\n-\t   that sscanf read the number back identically. Harsh yes, but\n-\t   sometimes you've got to be cruel to be kind.\n-\t*/\n-\tNumber val, new, diff;\n-\tdouble rem;\n-\tint e;\n-\tchar *rep;\n-\tchar *f2;\n-\n-#ifdef NO_LONG_DOUBLE_IO\n-\tdouble new1;\n-\t/* On the Sun 3, sscanf clobbers 4 words,\n-\t   which leads to a crash when this function tries to return.  */\n-\tf2= \"%le\";   /* Input */\n-\t/* It is no use checking long doubles if we can't\n-\t   read and write them.  */\n-\tif (sizeof (Number) > sizeof(double))\n-\t  return;\n-#else\n-\tLong_double new1;\n-\tif (sizeof(double) == sizeof(Long_double)) {\n-\t\t/* Assume they're the same, and use non-stdc format */\n-\t\t/* This is for stdc compilers using non-stdc libraries */\n-\t\tf2= \"%le\";   /* Input */\n-\t} else {\n-\t\t/* It had better support Le then */\n-\t\tf2= \"%Le\";\n-\t}\n-#endif\n-\tval= val1;\n-\trep= f_rep(precision, (Long_double) val);\n-\tif (setjmp(lab)==0) {\n-\t\tsscanf(rep, f2, &new1);\n-\t} else {\n-\t\teek_a_bug(\"sscanf caused a trap\");\n-\t\tprintf(\"%s    scanning: %s format: %s%s\\n\\n\", co, rep, f2, oc);\n-\t\tUnexpected(12);\n-\t\treturn;\n-\t}\n-\n-\tif (setjmp(lab)==0) { /* See if new is usable */\n-\t\tnew= new1;\n-\t\tif (new != 0.0) {\n-\t\t\tdiff= val/new - 1.0;\n-\t\t\tif (diff < 0.1) diff= 1.0;\n-\t\t\t/* That should be enough to generate a trap */\n-\t\t}\n-\t} else {\n-\t\teek_a_bug(\"sscanf returned an unusable number\");\n-\t\tprintf(\"%s    scanning: %s with format: %s%s\\n\\n\",\n-\t\t       co, rep, f2, oc);\n-\t\tUnexpected(13);\n-\t\treturn;\n-\t}\n-\n-\tUnexpected(14);\n-\tif (new != val) {\n-\t\teek_a_bug(\"Possibly bad output from printf above\");\n-\t\tif (!exponent((Long_double)val, &rem, &e)) {\n-\t\t\tprintf(\"%s    but value was an unusable number%s\\n\\n\",\n-\t\t\t       co, oc);\n-\t\t\treturn;\n-\t\t}\n-\t\tprintf(\"%s    expected value around %.*fe%d, bit pattern:\\n    \",\n-\t\t       co, precision, rem, e);\n-\t\tbitpattern((char *) &val, (unsigned)sizeof(val));\n-\t\tprintf (\"%s\\n\", oc);\n-\t\tprintf(\"%s    sscanf gave           %s, bit pattern:\\n    \",\n-\t\t       co, f_rep(precision, (Long_double) new));\n-\t\tbitpattern((char *) &new, (unsigned)sizeof(new));\n-\t\tprintf (\"%s\\n\", oc);\n-\t\tif (setjmp(lab) == 0) {\n-\t\t\tdiff= val-new;\n-\t\t\tprintf(\"%s    difference= %s%s\\n\\n\",\n-\t\t\t       co, f_rep(precision, (Long_double) diff), oc);\n-\t\t} /* else forget it */\n-\t\tUnexpected(15);\n-\t}\n-}\n-\n-#ifdef VERIFY\n-Procedure Validate(prec, val, req, same) int prec, same; Long_double val, req; {\n-\t/* Check that the compiler has read a #define value correctly */\n-\tUnexpected(16);\n-\tif (!same) {\n-\t\tprintf(\"%s*** Verify failed for above #define!\\n\", co);\n-\t\tif (setjmp(lab) == 0) { /* for the case that req == nan */\n-\t\t\tprintf(\"       Compiler has %s for value%s\\n\",\n-\t\t\t       f_rep(prec, req), oc);\n-\t\t} else {\n-\t\t\tprintf(\"       Compiler has %s for value%s\\n\",\n-\t\t\t       \"an unusable number\", oc);\n-\t\t}\n-\t\tif (setjmp(lab) == 0) {\n-\t\t\tF_check(prec, (Long_double) req);\n-\t\t} /*else forget it*/\n-\t\tif (setjmp(lab) == 0) {\n-\t\t\tif (req > 0.0 && val > 0.0) {\n-\t\t\t\tprintf(\"%s    difference= %s%s\\n\",\n-\t\t\t\t       co, f_rep(prec, val-req), oc);\n-\t\t\t}\n-\t\t} /*else forget it*/\n-\t\tUnexpected(17);\n-\t\tprintf(\"\\n\");\n-\t\tbugs++;\n-\t} else if (val != req) {\n-\t\tif (stdc) eek_a_bug(\"constant has the wrong precision\");\n-\t\telse eek_a_bug(\"the cast didn't work\");\n-\t\tprintf(\"\\n\");\n-\t}\n-}\n-#endif /* VERIFY */\n-\n-int FPROP(bits_per_byte) int bits_per_byte; {\n-\t/* Properties of floating types, using algorithms by Cody and Waite\n-\t   from MA Malcolm, as modified by WM Gentleman and SB Marovich.\n-\t   Further extended by S Pemberton.\n-\n-\t   Returns the number of digits in the fraction.\n-\t*/\n-\n-\tVolatile int\n-\t\ti, f_radix, iexp, irnd, mrnd, f_rounds, f_mant_dig,\n-\t\tiz, k, inf, machep, f_max_exp, f_min_exp, mx, negeps,\n-\t\tmantbits, digs, f_dig, trap,\n-\t\thidden, normal, f_min_10_exp, f_max_10_exp;\n-\tVolatile Number\n-\t\ta, b, base, basein, basem1, f_epsilon, epsneg,\n-\t\teps, epsp1, etop, ebot,\n-\t\tf_max, newxmax, f_min, xminner, y, y1, z, z1, z2;\n-\n-\tUnexpected(18);\n-\n-\tVprintf(\"%sPROPERTIES OF %s%s\\n\", co, THING, oc);\n-\n-\t/* Base and size of significand **************************************/\n-\t/* First repeatedly double until adding 1 has no effect.\t  */\n-\t/* For instance, if base is 10, with 3 significant digits\t  */\n-\t/* it will try 1, 2, 4, 8, ... 512, 1024, and stop there,\t  */\n-\t/* since 1024 is only representable as 1020.\t\t\t  */\n-\ta=1.0;\n-\tif (setjmp(lab)==0) { /* inexact trap? */\n-\t\tdo { a=Sum(a, a); }\n-\t\twhile (Diff(Diff(Sum(a, ONE), a), ONE) == ZERO);\n-\t} else {\n-\t\tfprintf(stderr, \"*** Program got loss-of-precision trap!\\n\");\n-\t\t/* And supporting those is just TOO much trouble! */\n-\t\tfarewell(bugs+1);\n-\t}\n-\tUnexpected(19);\n-\t/* Now double until you find a number that can be added to the\t  */\n-\t/* above number. For 1020 this is 8 or 16, depending whether the  */\n-\t/* result is rounded or truncated.\t\t\t\t  */\n-\t/* In either case the result is 1030. 1030-1020= the base, 10.\t  */\n-\tb=1.0;\n-\tdo { b=Sum(b, b); } while ((base=Diff(Sum(a, b), a)) == ZERO);\n-\tf_radix=base;\n-\tVprintf(\"%sBase = %d%s\\n\", co, f_radix, oc);\n-\n-\t/* Sanity check; if base<2, I can't guarantee the rest will work  */\n-\tif (f_radix < 2) {\n-\t\teek_a_bug(\"Function return or parameter passing faulty? (This is a guess.)\");\n-\t\tprintf(\"\\n\");\n-\t\treturn(0);\n-\t}\n-\n-\tif (PASS == 1) { /* only for FLT */\n-\t\tflt_radix= f_radix;\n-\t\tif (F) i_define(D_FLT_RADIX, \"\", \"FLT\", \"_RADIX\",\n-\t\t\t\t(long) f_radix, 0L, (long) F_RADIX, \"\");\n-\t} else if (f_radix != flt_radix) {\n-\t\tprintf(\"\\n%s*** WARNING: %s %s (%d) %s%s\\n\",\n-\t\t       co, thing, \"arithmetic has a different radix\",\n-\t\t       f_radix, \"from float\", oc);\n-\t\tbugs++;\n-\t}\n-\n-\t/* Now the number of digits precision */\n-\tf_mant_dig=0; b=1.0;\n-\tdo { f_mant_dig++; b=Mul(b, base); }\n-\twhile (Diff(Diff(Sum(b, ONE), b), ONE) == ZERO);\n-\tf_dig=floor_log(10, (Long_double)(b/base)) + (base==10?1:0);\n-\tVprintf(\"%sSignificant base digits = %d %s %d %s%s\\n\",\n-\t\tco, f_mant_dig, \"(= at least\", f_dig, \"decimal digits)\", oc);\n-\tif (F) i_define(D_MANT_DIG, thing, Fname, \"_MANT_DIG\",\n-\t\t\t(long) f_mant_dig, 0L, (long) F_MANT_DIG, \"\");\n-\tif (F) i_define(D_DIG, thing, Fname, \"_DIG\",\n-\t\t\t(long) f_dig, 0L, (long) F_DIG, \"\");\n-\tdigs= ceil_log(10, (Long_double)b); /* the number of digits to printf */\n-\n-\t/* Rounding *******************************************************/\n-\tbasem1=Diff(base, HALF);\n-\tif (Diff(Sum(a, basem1), a) != ZERO) {\n-\t\tif (f_radix == 2) basem1=0.375;\n-\t\telse basem1=1.0;\n-\t\tif (Diff(Sum(a, basem1), a) != ZERO) irnd=2; /* away from 0 */\n-\t\telse irnd=1; /* to nearest */\n-\t} else irnd=0; /* towards 0 */\n-\n-\tbasem1=Diff(base, HALF);\n-\n-\tif (Diff(Diff(-a, basem1), -a) != ZERO) {\n-\t\tif (f_radix == 2) basem1=0.375;\n-\t\telse basem1=1.0;\n-\t\tif (Diff(Diff(-a, basem1), -a) != ZERO) mrnd=2; /* away from 0*/\n-\t\telse mrnd=1; /* to nearest */\n-\t} else mrnd=0; /* towards 0 */\n-\n-\tf_rounds= -1; /* Unknown rounding */\n-\tif (irnd==0 && mrnd==0) f_rounds=0; /* zero = chops */\n-\tif (irnd==1 && mrnd==1) f_rounds=1; /* nearest */\n-\tif (irnd==2 && mrnd==0) f_rounds=2; /* +inf */\n-\tif (irnd==0 && mrnd==2) f_rounds=3; /* -inf */\n-\n-\tif (f_rounds != -1) {\n-\t\tVprintf(\"%sArithmetic rounds towards \", co);\n-\t\tswitch (f_rounds) {\n-\t\t      case 0: Vprintf(\"zero (i.e. it chops)\"); break;\n-\t\t      case 1: Vprintf(\"nearest\"); break;\n-\t\t      case 2: Vprintf(\"+infinity\"); break;\n-\t\t      case 3: Vprintf(\"-infinity\"); break;\n-\t\t      default: Vprintf(\"???\"); break;\n-\t\t}\n-\t\tVprintf(\"%s\\n\", oc);\n-\t} else { /* Hmm, try to give some help here */\n-\t\tVprintf(\"%sArithmetic rounds oddly: %s\\n\", co, oc);\n-\t\tVprintf(\"%s    Negative numbers %s%s\\n\",\n-\t\t\tco, mrnd==0 ? \"towards zero\" :\n-\t\t\t    mrnd==1 ? \"to nearest\" :\n-\t\t\t\t      \"away from zero\",\n-\t\t\toc);\n-\t\tVprintf(\"%s    Positive numbers %s%s\\n\",\n-\t\t\tco, irnd==0 ? \"towards zero\" :\n-\t\t\t    irnd==1 ? \"to nearest\" :\n-\t\t\t\t      \"away from zero\",\n-\t\t\toc);\n-\t}\n-\t/* An extra goody */\n-\tif (f_radix == 2 && f_rounds == 1) {\n-\t\tif (Diff(Sum(a, ONE), a) != ZERO) {\n-\t\t\tVprintf(\"%s   Tie breaking rounds up%s\\n\", co, oc);\n-\t\t} else if (Diff(Sum(a, THREE), a) == FOUR) {\n-\t\t\tVprintf(\"%s   Tie breaking rounds to even%s\\n\", co, oc);\n-\t\t} else {\n-\t\t\tVprintf(\"%s   Tie breaking rounds down%s\\n\", co, oc);\n-\t\t}\n-\t}\n-\tif (PASS == 1) { /* only for FLT */\n-\t\tflt_rounds= f_rounds;\n-\t\t/* Prefer system float.h definition of F_ROUNDS,\n-\t\t   since it's more likely to be right than our \"1\".  */\n-\t\tif (F && (!SYS_FLOAT_H_WRAP || F_ROUNDS == UNDEFINED))\n-\t\t  i_define(D_FLT_ROUNDS, \"\", \"FLT\", \"_ROUNDS\",\n-\t\t\t   (long) f_rounds, 1L, (long) F_ROUNDS, \"\");\n-\t} else if (f_rounds != flt_rounds) {\n-\t\tprintf(\"\\n%s*** WARNING: %s %s (%d) %s%s\\n\",\n-\t\t       co, thing, \"arithmetic rounds differently\",\n-\t\t       f_rounds, \"from float\", oc);\n-\t\tbugs++;\n-\t}\n-\n-\t/* Various flavours of epsilon ************************************/\n-\tnegeps=f_mant_dig+f_mant_dig;\n-\tbasein=1.0/base;\n-\ta=1.0;\n-\tfor(i=1; i<=negeps; i++) a*=basein;\n-\n-\tb=a;\n-\twhile (Diff(Diff(ONE, a), ONE) == ZERO) {\n-\t\ta*=base;\n-\t\tnegeps--;\n-\t}\n-\tnegeps= -negeps;\n-\tVprintf(\"%sSmallest x such that 1.0-base**x != 1.0 = %d%s\\n\",\n-\t\tco, negeps, oc);\n-\n-\tetop = ONE;\n-\tebot = ZERO;\n-\teps = Sum(ebot, Div(Diff(etop, ebot), TWO));\n-\t/* find the smallest epsneg (1-epsneg != 1) by binary search.\n-\t   ebot and etop are the current bounds */\n-\twhile (eps != ebot && eps != etop) {\n-\t\tepsp1 = Diff(ONE, eps);\n-\t\tif (epsp1 < ONE) etop = eps;\n-\t\telse ebot = eps;\n-\t\teps = Sum(ebot, Div(Diff(etop, ebot), TWO));\n-\t}\n-\teps= etop;\n-\t/* Sanity check */\n-\tif (Diff(ONE, etop) >= ONE || Diff(ONE, ebot) != ONE) {\n-\t\teek_a_bug(\"internal error calculating epsneg\");\n-\t}\n-\tVprintf(\"%sSmallest x such that 1.0-x != 1.0 = %s%s\\n\",\n-\t\tco, f_rep(digs, (Long_double) eps), oc);\n-\tif (V) F_check(digs, (Long_double) eps);\n-\n-\tepsneg=a;\n-\tif ((f_radix!=2) && irnd) {\n-\t/*\ta=(a*(1.0+a))/(1.0+1.0); => */\n-\t\ta=Div(Mul(a, Sum(ONE, a)), Sum(ONE, ONE));\n-\t/*\tif ((1.0-a)-1.0 != 0.0) epsneg=a; => */\n-\t\tif (Diff(Diff(ONE, a), ONE) != ZERO) epsneg=a;\n-\t}\n-\t/* epsneg is used later */\n-\tUnexpected(20);\n-\n-\tmachep= -f_mant_dig-f_mant_dig;\n-\ta=b;\n-\twhile (Diff(Sum(ONE, a), ONE) == ZERO) { a*=base; machep++; }\n-\tVprintf(\"%sSmallest x such that 1.0+base**x != 1.0 = %d%s\\n\",\n-\t\tco, machep, oc);\n-\n-\tetop = ONE;\n-\tebot = ZERO;\n-\teps = Sum(ebot, Div(Diff(etop, ebot), TWO));\n-\t/* find the smallest eps (1+eps != 1) by binary search.\n-\t   ebot and etop are the current bounds */\n-\twhile (eps != ebot && eps != etop) {\n-\t\tepsp1 = Sum(ONE, eps);\n-\t\tif (epsp1 > ONE) etop = eps;\n-\t\telse ebot = eps;\n-\t\teps = Sum(ebot, Div(Diff(etop, ebot), TWO));\n-\t}\n-\t/* Sanity check */\n-\tif (Sum(ONE, etop) <= ONE || Sum(ONE, ebot) != ONE) {\n-\t\teek_a_bug(\"internal error calculating eps\");\n-\t}\n-\tf_epsilon=etop;\n-\n-\tVprintf(\"%sSmallest x such that 1.0+x != 1.0 = %s%s\\n\",\n-\t\tco, f_rep(digs, (Long_double) f_epsilon), oc);\n-\n-\tf_epsilon= Diff(Sum(ONE, f_epsilon), ONE); /* New C standard defn */\n-\tVprintf(\"%s(Above number + 1.0) - 1.0 = %s%s\\n\",\n-\t\tco, f_rep(digs, (Long_double) (f_epsilon)), oc);\n-\n-\t/* Possible loss of precision warnings here from non-stdc compilers */\n-\tif (F) f_define(D_EPSILON, thing,\n-\t\t\tFname, \"_EPSILON\", digs,\n-\t\t\t(Long_double) f_epsilon,\n-\t\t\t(Long_double) F_EPSILON, MARK);\n-\tif (V || F) F_check(digs, (Long_double) f_epsilon);\n-\tUnexpected(21);\n-\tif (F) Validate(digs, (Long_double) f_epsilon, (Long_double) F_EPSILON,\n-\t\t\tf_epsilon == Self(F_EPSILON));\n-\tUnexpected(22);\n-\n-\t/* Extra chop info *************************************************/\n-\tif (f_rounds == 0) {\n-\t\tif (Diff(Mul(Sum(ONE,f_epsilon),ONE),ONE) !=  ZERO) {\n-\t\t\tVprintf(\"%sAlthough arithmetic chops, it uses guard digits%s\\n\", co, oc);\n-\t\t}\n-\t}\n-\n-\t/* Size of and minimum normalised exponent ************************/\n-\ty=0; i=0; k=1; z=basein; z1=(1.0+f_epsilon)/base;\n-\n-\t/* Coarse search for the largest power of two */\n-\tif (setjmp(lab)==0) { /* for underflow trap */ /* Yields i, k, y, y1 */\n-\t\tdo {\n-\t\t\ty=z; y1=z1;\n-\t\t\tz=Mul(y,y); z1=Mul(z1, y);\n-\t\t\ta=Mul(z,ONE);\n-\t\t\tz2=Div(z1,y);\n-\t\t\tif (z2 != y1) break;\n-\t\t\tif ((Sum(a,a) == ZERO) || (fabs(z) >= y)) break;\n-\t\t\ti++;\n-\t\t\tk+=k;\n-\t\t} while(1);\n-\t} else {\n-\t\tVprintf(\"%s%s underflow generates a trap%s\\n\", co, Thing, oc);\n-\t}\n-\tUnexpected(23);\n-\n-\tif (f_radix != 10) {\n-\t\tiexp=i+1; /* for the sign */\n-\t\tmx=k+k;\n-\t} else {\n-\t\tiexp=2;\n-\t\tiz=f_radix;\n-\t\twhile (k >= iz) { iz*=f_radix; iexp++; }\n-\t\tmx=iz+iz-1;\n-\t}\n-\n-\t/* Fine tune starting with y and y1 */\n-\tif (setjmp(lab)==0) { /* for underflow trap */ /* Yields k, f_min */\n-\t\tdo {\n-\t\t\tf_min=y; z1=y1;\n-\t\t\ty=Div(y,base); y1=Div(y1,base);\n-\t\t\ta=Mul(y,ONE);\n-\t\t\tz2=Mul(y1,base);\n-\t\t\tif (z2 != z1) break;\n-\t\t\tif ((Sum(a,a) == ZERO) || (fabs(y) >= f_min)) break;\n-\t\t\tk++;\n-\t\t} while (1);\n-\t}\n-\tUnexpected(24);\n-\n-\tf_min_exp=(-k)+1;\n-\n-\tif ((mx <= k+k-3) && (f_radix != 10)) { mx+=mx; iexp+=1; }\n-\tVprintf(\"%sNumber of bits used for exponent = %d%s\\n\", co, iexp, oc);\n-\tVprintf(\"%sMinimum normalised exponent = %d%s\\n\", co, f_min_exp-1, oc);\n-\tif (F)\n-\t  i_define(D_MIN_EXP, thing, Fname, \"_MIN_EXP\",\n-\t\t   (long) f_min_exp, (long) maxint, (long) F_MIN_EXP, \"\");\n-\n-\tif (setjmp(lab)==0) {\n-\t\tVprintf(\"%sMinimum normalised positive number = %s%s\\n\",\n-\t\t\tco, f_rep(digs, (Long_double) f_min), oc);\n-\t} else {\n-\t\teek_a_bug(\"printf can't print the smallest normalised number\");\n-\t\tprintf(\"\\n\");\n-\t}\n-\tUnexpected(25);\n-\t/* Possible loss of precision warnings here from non-stdc compilers */\n-\tif (setjmp(lab) == 0) {\n-\t\tif (F) f_define(D_MIN, thing,\n-\t\t\t\tFname, \"_MIN\", digs,\n-\t\t\t\t(Long_double) f_min,\n-\t\t\t\t(Long_double) F_MIN, MARK);\n-\t\tif (V || F) F_check(digs, (Long_double) f_min);\n-\t} else {\n-\t\teek_a_bug(\"xxx_MIN caused a trap\");\n-\t\tprintf(\"\\n\");\n-\t}\n-\n-\tif (setjmp(lab) == 0) {\n-\t\tif (F) Validate(digs, (Long_double) f_min, (Long_double) F_MIN,\n-\t\t\t\tf_min == Self(F_MIN));\n-\t} else {\n-\t\tprintf(\"%s*** Verify failed for above #define!\\n    %s %s\\n\\n\",\n-\t\t       co, \"Compiler has an unusable number for value\", oc);\n-\t\tbugs++;\n-\t}\n-\tUnexpected(26);\n-\n-\ta=1.0; f_min_10_exp=0;\n-\twhile (a > f_min*10.0) { a/=10.0; f_min_10_exp--; }\n-\tif (F) i_define(D_MIN_10_EXP, thing, Fname, \"_MIN_10_EXP\",\n-\t\t\t(long) f_min_10_exp, (long) maxint,\n-\t\t\t(long) F_MIN_10_EXP, \"\");\n-\n-\t/* Minimum exponent ************************************************/\n-\tif (setjmp(lab)==0) { /* for underflow trap */ /* Yields xminner */\n-\t\tdo {\n-\t\t\txminner=y;\n-\t\t\ty=Div(y,base);\n-\t\t\ta=Mul(y,ONE);\n-\t\t\tif ((Sum(a,a) == ZERO) || (fabs(y) >= xminner)) break;\n-\t\t} while (1);\n-\t}\n-\tUnexpected(27);\n-\n-\tif (xminner != 0.0 && xminner != f_min) {\n-\t\tnormal= 0;\n-\t\tVprintf(\"%sThe smallest numbers are not kept normalised%s\\n\",\n-\t\t\tco, oc);\n-\t\tif (setjmp(lab)==0) {\n-\t\t    Vprintf(\"%sSmallest unnormalised positive number = %s%s\\n\",\n-\t\t\t    co, f_rep(digs, (Long_double) xminner), oc);\n-\t\t    if (V) F_check(digs, (Long_double) xminner);\n-\t\t} else {\n-\t\t\teek_a_bug(\"printf can't print the smallest unnormalised number.\");\n-\t\t\tprintf(\"\\n\");\n-\t\t}\n-\t\tUnexpected(28);\n-\t} else {\n-\t\tnormal= 1;\n-\t\tVprintf(\"%sThe smallest numbers are normalised%s\\n\", co, oc);\n-\t}\n-\n-\t/* Maximum exponent ************************************************/\n-\tf_max_exp=2; f_max=1.0; newxmax=base+1.0;\n-\tinf=0; trap=0;\n-\twhile (f_max<newxmax) {\n-\t\tf_max=newxmax;\n-\t\tif (setjmp(lab) == 0) { /* Yields inf, f_max_exp */\n-\t\t\tnewxmax=Mul(newxmax, base);\n-\t\t} else {\n-\t\t\ttrap=1;\n-\t\t\tbreak;\n-\t\t}\n-\t\tif (Div(newxmax, base) != f_max) {\n-\t\t\tinf=1; /* ieee infinity */\n-\t\t\tbreak;\n-\t\t}\n-\t\tf_max_exp++;\n-\t}\n-\tUnexpected(29);\n-\tif (trap) {\n-\t\tVprintf(\"%s%s overflow generates a trap%s\\n\", co, Thing, oc);\n-\t}\n-\n-\tif (inf) Vprintf(\"%sThere is an 'infinite' value%s\\n\", co, oc);\n-\tVprintf(\"%sMaximum exponent = %d%s\\n\", co, f_max_exp, oc);\n-\tif (F) i_define(D_MAX_EXP, thing, Fname, \"_MAX_EXP\",\n-\t\t\t(long) f_max_exp, 0L, (long) F_MAX_EXP, \"\");\n-\n-\t/* Largest number ***************************************************/\n-\tf_max=Diff(ONE, epsneg);\n-\tif (Mul(f_max,ONE) != f_max) f_max=Diff(ONE, Mul(base,epsneg));\n-\tfor (i=1; i<=f_max_exp; i++) f_max=Mul(f_max, base);\n-\n-\tif (setjmp(lab)==0) {\n-\t\tVprintf(\"%sMaximum number = %s%s\\n\",\n-\t\t\tco, f_rep(digs, (Long_double) f_max), oc);\n-\t} else {\n-\t\teek_a_bug(\"printf can't print the largest double.\");\n-\t\tprintf(\"\\n\");\n-\t}\n-\tif (setjmp(lab)==0) {\n-\t/* Possible loss of precision warnings here from non-stdc compilers */\n-\t\tif (F) f_define(D_MAX, thing,\n-\t\t\t\tFname, \"_MAX\", digs,\n-\t\t\t\t(Long_double) f_max,\n-\t\t\t\t(Long_double) F_MAX, MARK);\n-\t\tif (V || F) F_check(digs, (Long_double) f_max);\n-\t} else {\n-\t\teek_a_bug(\"xxx_MAX caused a trap\");\n-\t\tprintf(\"\\n\");\n-\t}\n-\tif (setjmp(lab)==0) {\n-\t\tif (F) Validate(digs, (Long_double) f_max, (Long_double) F_MAX,\n-\t\t\t\tf_max == Self(F_MAX));\n-\t} else {\n-\t\tprintf(\"%s*** Verify failed for above #define!\\n    %s %s\\n\\n\",\n-\t\t       co, \"Compiler has an unusable number for value\", oc);\n-\t\tbugs++;\n-\t}\n-\tUnexpected(30);\n-\n-\ta=1.0; f_max_10_exp=0;\n-\twhile (a < f_max/10.0) { a*=10.0; f_max_10_exp++; }\n-\tif (F) i_define(D_MAX_10_EXP, thing, Fname, \"_MAX_10_EXP\",\n-\t\t\t(long) f_max_10_exp, 0L, (long) F_MAX_10_EXP, \"\");\n-\n-\t/* Hidden bit + sanity check ****************************************/\n-\tif (f_radix != 10) {\n-\t\thidden=0;\n-\t\tmantbits=floor_log(2, (Long_double)f_radix)*f_mant_dig;\n-\t\tif (mantbits == 64\n-\t\t    && iexp == 15\n-\t\t    && f_max_exp+f_min_exp > 0 /* ??? f_min_exp may be wrong.  */\n-\t\t    && mantbits+iexp+17 == (int)sizeof(Number)*bits_per_byte) {\n-\t\t\tVprintf(\"%sArithmetic probably doesn't use a hidden bit%s\\n\", co, oc);\n-\t\t\tVprintf(\"%sIt's probably 80387 or 68881 extended real%s\\n\", co, oc);\n-\t\t\tgoto is_extended;\n-\t\t}\n-\t\tif (mantbits+iexp == (int)sizeof(Number)*bits_per_byte) {\n-\t\t\thidden=1;\n-\t\t\tVprintf(\"%sArithmetic uses a hidden bit%s\\n\", co, oc);\n-\t\t} else if (mantbits+iexp+1 == (int)sizeof(Number)*bits_per_byte) {\n-\t\t\tVprintf(\"%sArithmetic doesn't use a hidden bit%s\\n\",\n-\t\t\t\tco, oc);\n-\t\t} else {\n-\t\t\tprintf(\"\\n%s%s\\n    %s %s %s!%s\\n\\n\",\n-\t\t\t       co,\n-\t\t\t       \"*** Something fishy here!\",\n-\t\t\t       \"Exponent size + significand size doesn't match\",\n-\t\t\t       \"with the size of a\", thing,\n-\t\t\t       oc);\n-\t\t}\n-\t\tif (hidden && f_radix == 2 && f_max_exp+f_min_exp==3) {\n-\t\t\tVprintf(\"%sIt looks like %s length IEEE format%s\\n\",\n-\t\t\t\tco, f_mant_dig==24 ? \"single\" :\n-\t\t\t\t    f_mant_dig==53 ? \"double\" :\n-\t\t\t\t    f_mant_dig >53 ? \"extended\" :\n-\t\t\t\t\t\t\"some\", oc);\n-is_extended:\n-\t\t\tif (f_rounds != 1 || normal) {\n-\t\t\t\tVprintf(\"%s   though \", co);\n-\t\t\t\tif (f_rounds != 1) {\n-\t\t\t\t\tVprintf(\"the rounding is unusual\");\n-\t\t\t\t\tif (normal) Vprintf(\" and \");\n-\t\t\t\t}\n-\t\t\t\tif (normal) Vprintf(\"the normalisation is unusual\");\n-\t\t\t\tVprintf(\"%s\\n\", oc);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tVprintf(\"%sIt doesn't look like IEEE format%s\\n\",\n-\t\t\t\tco, oc);\n-\t\t}\n-\t}\n-\tprintf(\"\\n\"); /* regardless of verbosity */\n-\treturn f_mant_dig;\n-}\n-\n-Procedure EPROP(fprec, dprec, lprec) int fprec, dprec, lprec; {\n-\t/* See if expressions are evaluated in extended precision.\n-\t   Some compilers optimise even if you don't want it,\n-\t   and then this function fails to produce the right result.\n-\t   We try to diagnose this if it happens.\n-\t*/\n-\tVolatile int eprec;\n-\tVolatile double a, b, base, old;\n-\tVolatile Number d, oldd, dbase, one, zero;\n-\tVolatile int bad=0;\n-\n-\t/* Size of significand **************************************/\n-\ta=1.0;\n-\tif (setjmp(lab) == 0) { /* Yields nothing */\n-\t\tdo { old=a; a=a+a; }\n-\t\twhile ((((a+1.0)-a)-1.0) == 0.0 && a>old);\n-\t} else bad=1;\n-\n-\t/* Avoid the comparison if bad is set,\n-\t   to avoid trouble on the convex.  */\n-\tif (!bad && (a <= old)) bad=1;\n-\n-\tif (!bad) {\n-\t\tb=1.0;\n-\t\tif (setjmp(lab) == 0) { /* Yields nothing */\n-\t\t\tdo { old=b; b=b+b; }\n-\t\t\twhile ((base=((a+b)-a)) == 0.0 && b>old);\n-\t\t\tif (b <= old) bad=1;\n-\t\t} else bad=1;\n-\t}\n-\n-\tif (!bad) {\n-\t\teprec=0; d=1.0; dbase=base; one=1.0; zero=0.0;\n-\t\tif (setjmp(lab) == 0) { /* Yields nothing */\n-\t\t\tdo { eprec++; oldd=d; d=d*dbase; }\n-\t\t\twhile ((((d+one)-d)-one) == zero && d>oldd);\n-\t\t\tif (d <= oldd) bad=1;\n-\t\t} else bad=1;\n-\t}\n-\n-\tUnexpected(31);\n-\n-\tif (bad) {\n-\t  Vprintf(\"%sCan't determine precision for %s expressions:\\n%s%s\\n\",\n-\t\t co, thing, \"   check that you compiled without optimisation!\",\n-\t\t oc);\n-\t} else if (eprec==dprec) {\n-\t  Vprintf(\"%s%s expressions are evaluated in double precision%s\\n\",\n-\t\t  co, Thing, oc);\n-\t} else if (eprec==fprec) {\n-\t  Vprintf(\"%s%s expressions are evaluated in float precision%s\\n\",\n-\t\t  co, Thing, oc);\n-\t} else if (eprec==lprec) {\n-\t  Vprintf(\"%s%s expressions are evaluated in long double precision%s\\n\",\n-\t\t  co, Thing, oc);\n-\t} else {\n-\t\tVprintf(\"%s%s expressions are evaluated in a %s %s %d %s%s\\n\",\n-\t\t\tco, Thing, eprec>dprec ? \"higher\" : \"lower\",\n-\t\t\t\"precision than double,\\n   using\",\n-\t\t\teprec, \"base digits\",\n-\t\t        oc);\n-\t}\n-}\n-\n-#else /* not Number */\n-\n-#ifdef FPROP /* Then create dummy routines for long double */\n-/* ARGSUSED */\n-int FPROP(bits_per_byte) int bits_per_byte; { return 0; }\n-#endif\n-#ifdef EPROP\n-/* ARGSUSED */\n-Procedure EPROP(fprec, dprec, lprec) int fprec, dprec, lprec; {}\n-#endif\n-\n-#endif /* ifdef Number */\n-\n-/* Increment the pass number */\n-#undef PASS\n-\n-#ifdef PASS2\n-#undef PASS2\n-#define PASS 3\n-#define PASS3 1\n-#endif\n-\n-#ifdef PASS1\n-#undef PASS1\n-#define PASS 2\n-#define PASS2 1\n-#endif\n-\n-#ifdef PASS0\n-#undef PASS0\n-#endif\n-\n-#ifdef PASS /* then rescan this file */\n-#ifdef NO_FILE\n-#include \"enquire.c\"\n-#else\n-#include FILENAME  /* if this line fails to compile, define NO_FILE */\n-#endif\n-#endif /* PASS */\n-"}]}