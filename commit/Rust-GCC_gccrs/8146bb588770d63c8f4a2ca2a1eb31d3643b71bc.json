{"sha": "8146bb588770d63c8f4a2ca2a1eb31d3643b71bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE0NmJiNTg4NzcwZDYzYzhmNGEyY2EyYTFlYjMxZDM2NDNiNzFiYw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2009-11-30T20:35:41Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2009-11-30T20:35:41Z"}, "message": "re PR fortran/42131 (Weird translation of DO loops)\n\n2009-11-30  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/42131\n\t* trans-stmt.c (gfc_trans_do):  Calculate loop count\n\twithout if statements.\n\nFrom-SVN: r154839", "tree": {"sha": "ea16abae981c7c4263809c29e21806a43647b45a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea16abae981c7c4263809c29e21806a43647b45a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8146bb588770d63c8f4a2ca2a1eb31d3643b71bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8146bb588770d63c8f4a2ca2a1eb31d3643b71bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8146bb588770d63c8f4a2ca2a1eb31d3643b71bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8146bb588770d63c8f4a2ca2a1eb31d3643b71bc/comments", "author": null, "committer": null, "parents": [{"sha": "12d210d9f0ebb62f9b511e28f5718348ec95167b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12d210d9f0ebb62f9b511e28f5718348ec95167b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12d210d9f0ebb62f9b511e28f5718348ec95167b"}], "stats": {"total": 61, "additions": 42, "deletions": 19}, "files": [{"sha": "03c15484dc25aac4e12331ee178accd3b55d2b8a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8146bb588770d63c8f4a2ca2a1eb31d3643b71bc/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8146bb588770d63c8f4a2ca2a1eb31d3643b71bc/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8146bb588770d63c8f4a2ca2a1eb31d3643b71bc", "patch": "@@ -1,3 +1,9 @@\n+2009-11-30  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/42131\n+\t* trans-stmt.c (gfc_trans_do):  Calculate loop count\n+\twithout if statements.\n+\n 2009-11-28  Jakub Jelinek  <jakub@redhat.com>\n \n \t* trans-common.c (create_common): Remove unused offset variable."}, {"sha": "04115885773df3da590091a78bd6e8bab6b9fe66", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8146bb588770d63c8f4a2ca2a1eb31d3643b71bc/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8146bb588770d63c8f4a2ca2a1eb31d3643b71bc/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=8146bb588770d63c8f4a2ca2a1eb31d3643b71bc", "patch": "@@ -1009,44 +1009,61 @@ gfc_trans_do (gfc_code * code)\n \n   /* Initialize loop count and jump to exit label if the loop is empty.\n      This code is executed before we enter the loop body. We generate:\n+     step_sign = sign(1,step);\n      if (step > 0)\n        {\n-\t if (to < from) goto exit_label;\n-\t countm1 = (to - from) / step;\n+\t if (to < from)\n+\t   goto exit_label;\n        }\n      else\n        {\n-\t if (to > from) goto exit_label;\n-\t countm1 = (from - to) / -step;\n-       }  */\n+\t if (to > from)\n+\t   goto exit_label;\n+       }\n+       countm1 = (to*step_sign - from*step_sign) / (step*step_sign);\n+\n+  */\n+\n   if (TREE_CODE (type) == INTEGER_TYPE)\n     {\n-      tree pos, neg;\n+      tree pos, neg, step_sign, to2, from2, step2;\n+\n+      /* Calculate SIGN (1,step) */\n+\n+      tmp = fold_build2 (RSHIFT_EXPR, type, step,\n+\t\t\t build_int_cst (type,\n+\t\t\t\t\tTYPE_PRECISION (type) - 1));\n+\n+      tmp = fold_build2 (MULT_EXPR, type, tmp,\n+\t\t\t build_int_cst (type, 2));\n+\n+      step_sign = fold_build2 (PLUS_EXPR, type, tmp,\n+\t\t\t       fold_convert (type, integer_one_node));\n \n       tmp = fold_build2 (LT_EXPR, boolean_type_node, to, from);\n       pos = fold_build3 (COND_EXPR, void_type_node, tmp,\n \t\t\t build1_v (GOTO_EXPR, exit_label),\n \t\t\t build_empty_stmt (input_location));\n-      tmp = fold_build2 (MINUS_EXPR, type, to, from);\n-      tmp = fold_convert (utype, tmp);\n-      tmp = fold_build2 (TRUNC_DIV_EXPR, utype, tmp,\n-\t\t\t fold_convert (utype, step));\n-      tmp = fold_build2 (MODIFY_EXPR, void_type_node, countm1, tmp);\n-      pos = fold_build2 (COMPOUND_EXPR, void_type_node, pos, tmp);\n \n       tmp = fold_build2 (GT_EXPR, boolean_type_node, to, from);\n       neg = fold_build3 (COND_EXPR, void_type_node, tmp,\n \t\t\t build1_v (GOTO_EXPR, exit_label),\n \t\t\t build_empty_stmt (input_location));\n-      tmp = fold_build2 (MINUS_EXPR, type, from, to);\n+      tmp = fold_build3 (COND_EXPR, void_type_node, pos_step, pos, neg);\n+\n+      gfc_add_expr_to_block (&block, tmp);\n+\n+      /* Calculate the loop count.  to-from can overflow, so\n+\t we cast to unsigned.  */\n+\n+      to2 = fold_build2 (MULT_EXPR, type, step_sign, to);\n+      from2 = fold_build2 (MULT_EXPR, type, step_sign, from);\n+      step2 = fold_build2 (MULT_EXPR, type, step_sign, step);\n+      step2 = fold_convert (utype, step2);\n+      tmp = fold_build2 (MINUS_EXPR, type, to2, from2);\n       tmp = fold_convert (utype, tmp);\n-      tmp = fold_build2 (TRUNC_DIV_EXPR, utype, tmp,\n-\t\t\t fold_convert (utype, fold_build1 (NEGATE_EXPR,\n-\t\t\t\t\t\t\t   type, step)));\n+      tmp = fold_build2 (TRUNC_DIV_EXPR, utype, tmp, step2);\n       tmp = fold_build2 (MODIFY_EXPR, void_type_node, countm1, tmp);\n-      neg = fold_build2 (COMPOUND_EXPR, void_type_node, neg, tmp);\n-\n-      tmp = fold_build3 (COND_EXPR, void_type_node, pos_step, pos, neg);\n       gfc_add_expr_to_block (&block, tmp);\n     }\n   else"}]}