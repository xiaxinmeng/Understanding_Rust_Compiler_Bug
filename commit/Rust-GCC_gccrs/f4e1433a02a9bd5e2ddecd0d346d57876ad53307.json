{"sha": "f4e1433a02a9bd5e2ddecd0d346d57876ad53307", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRlMTQzM2EwMmE5YmQ1ZTJkZGVjZDBkMzQ2ZDU3ODc2YWQ1MzMwNw==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2005-11-17T20:38:40Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2005-11-17T20:38:40Z"}, "message": "[multiple changes]\n\n2005-11-17  Mark Wielaard  <mark@klomp.org>\n\n       * gnu/java/net/protocol/file/Handler.java: Removed, fully merged now.\n       * java/net/ServerSocket.java: Likewise.\n       * sources.am: Regenerated.\n       * Makefile.in: Regenerated.\n\n2005-11-17  Mark Wielaard  <mark@klomp.org>\n\n       Fixes bug #24006\n       * java/net/ServerSocket.java (implAccept): Set Socket.bound to true.\n\n2005-11-17  Tom Tromey  <tromey@redhat.com>\n\n       * java/net/ServerSocket.java (accept): Use correct security manager\n       call.\n\n2005-11-17  Jeroen Frijters  <jeroen@frijters.net>\n\n       * java/net/ServerSocket.java\n       (bound): Removed.\n       (local): New field.\n       (bind): Cache local socket address.\n       (getInetAddress, getLocalPort, getLocalSocketAddress, isBound):\n       Use cached local socket address.\n       (close): bound field was removed.\n\n2005-11-17  Tom Tromey  <tromey@redhat.com>\n\n       * java/net/URLConnection.java (setDoInput): Javadoc fix.\n       (setDoOutput): Likewise.\n       (setContentHandlerFactory): Likewise.\n       (setFileNameMap): Likewise.\n\n2005-11-17  Mark Wielaard  <mark@klomp.org>\n\n       * java/net/URLClassloader.java (addURLs): Add comment about jboss.\n\n2005-11-17  Mark Wielaard  <mark@klomp.org>\n\n       * java/net/URLClassLoader.java (addURLs): Don't call addURL(), but\n       call urls.add() and addURLImpl() directly on each URL.\n\n2005-11-17  Tom Tromey  <tromey@redhat.com>\n\n       * java/net/URLClassLoader.java (definePackage): Javadoc fixes.\n\n2005-11-17  Jeroen Frijters  <jeroen@frijters.net>\n\n       * java/net/URLClassLoader.java\n       (Resource.name): Removed field.\n       (JarURLResource.name): Added field.\n       (FileResource.getURL): Use File.toURL() instead of doing it in\n       a way that breaks on Windows.\n\n2005-11-17  Roman Kennke  <roman@kennke.org>\n\n       Reported by: Ingo Proetel  <proetel@aicas.com>\n       * java/net/URLClassLoader.java\n       (findClass): Added null check to avoid NullPointerException.\n\n2005-11-17  David Gilbert  <david.gilbert@object-refinery.com>\n\n       * java/net/URLClassLoader.java: reordered some API doc comments to\n       suppress Eclipse warnings, and fixed API doc link.\n\n2005-11-17  Tom Tromey  <tromey@redhat.com>\n\n       * java/net/URLClassLoader.java (URLClassLoader): Removed\n       unused constructor.\n\n2005-11-17  Jeroen Frijters  <jeroen@frijters.net>\n\n       * java/net/URLClassLoader (findClass): Close InputStream after we're\n       done with it.\n\nFrom-SVN: r107133", "tree": {"sha": "235cbb7c11fda8c95f6e2e1920237d047af0d32b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/235cbb7c11fda8c95f6e2e1920237d047af0d32b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4e1433a02a9bd5e2ddecd0d346d57876ad53307", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4e1433a02a9bd5e2ddecd0d346d57876ad53307", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4e1433a02a9bd5e2ddecd0d346d57876ad53307", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4e1433a02a9bd5e2ddecd0d346d57876ad53307/comments", "author": null, "committer": null, "parents": [{"sha": "11922361e4a39efa05cc2a807d656dc5bfb858b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11922361e4a39efa05cc2a807d656dc5bfb858b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11922361e4a39efa05cc2a807d656dc5bfb858b3"}], "stats": {"total": 955, "additions": 166, "deletions": 789}, "files": [{"sha": "512b4f1520f71bba751748b46dc150e420386b41", "filename": "libjava/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4e1433a02a9bd5e2ddecd0d346d57876ad53307/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4e1433a02a9bd5e2ddecd0d346d57876ad53307/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f4e1433a02a9bd5e2ddecd0d346d57876ad53307", "patch": "@@ -1,3 +1,79 @@\n+2005-11-17  Mark Wielaard  <mark@klomp.org>\n+\n+\t* gnu/java/net/protocol/file/Handler.java: Removed, fully merged now.\n+\t* java/net/ServerSocket.java: Likewise.\n+\t* sources.am: Regenerated.\n+\t* Makefile.in: Regenerated.\n+\n+2005-11-17  Mark Wielaard  <mark@klomp.org>\n+\n+\tFixes bug #24006\n+\t* java/net/ServerSocket.java (implAccept): Set Socket.bound to true.\n+\n+2005-11-17  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/net/ServerSocket.java (accept): Use correct security manager\n+\tcall.\n+\n+2005-11-17  Jeroen Frijters  <jeroen@frijters.net>\n+\n+\t* java/net/ServerSocket.java\n+\t(bound): Removed.\n+\t(local): New field.\n+\t(bind): Cache local socket address.\n+\t(getInetAddress, getLocalPort, getLocalSocketAddress, isBound):\n+\tUse cached local socket address.\n+\t(close): bound field was removed.\n+\n+2005-11-17  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/net/URLConnection.java (setDoInput): Javadoc fix.\n+\t(setDoOutput): Likewise.\n+\t(setContentHandlerFactory): Likewise.\n+\t(setFileNameMap): Likewise.\n+\n+2005-11-17  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/net/URLClassloader.java (addURLs): Add comment about jboss.\n+\n+2005-11-17  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/net/URLClassLoader.java (addURLs): Don't call addURL(), but\n+\tcall urls.add() and addURLImpl() directly on each URL.\n+\n+2005-11-17  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/net/URLClassLoader.java (definePackage): Javadoc fixes.\n+\n+2005-11-17  Jeroen Frijters  <jeroen@frijters.net>\n+\n+\t* java/net/URLClassLoader.java\n+\t(Resource.name): Removed field.\n+\t(JarURLResource.name): Added field.\n+\t(FileResource.getURL): Use File.toURL() instead of doing it in\n+\ta way that breaks on Windows.\n+\n+2005-11-17  Roman Kennke  <roman@kennke.org>\n+\n+\tReported by: Ingo Proetel  <proetel@aicas.com>\n+\t* java/net/URLClassLoader.java\n+\t(findClass): Added null check to avoid NullPointerException.\n+\n+2005-11-17  David Gilbert  <david.gilbert@object-refinery.com>\n+\n+\t* java/net/URLClassLoader.java: reordered some API doc comments to\n+\tsuppress Eclipse warnings, and fixed API doc link.\n+\n+2005-11-17  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/net/URLClassLoader.java (URLClassLoader): Removed\n+\tunused constructor.\n+\n+2005-11-17  Jeroen Frijters  <jeroen@frijters.net>\n+\n+\t* java/net/URLClassLoader (findClass): Close InputStream after we're\n+\tdone with it.\n+\n 2005-11-17  Bryce McKinlay  <mckinlay@redhat.com>\n \n \tImplement -Xss."}, {"sha": "ac07ecf8f69716374dc501da45ef6a56d8ba2691", "filename": "libjava/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4e1433a02a9bd5e2ddecd0d346d57876ad53307/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4e1433a02a9bd5e2ddecd0d346d57876ad53307/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=f4e1433a02a9bd5e2ddecd0d346d57876ad53307", "patch": "@@ -1426,9 +1426,9 @@ gnu/java/net/protocol/gcjlib/Handler.java\n gnu_java_net_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_java_net_source_files)))\n gnu_java_net_protocol_file_source_files = \\\n gnu/java/net/protocol/file/Connection.java \\\n-gnu/java/net/protocol/file/Handler.java\n+classpath/gnu/java/net/protocol/file/Handler.java\n \n-gnu_java_net_protocol_file_header_files = $(patsubst %.java,%.h,$(gnu_java_net_protocol_file_source_files))\n+gnu_java_net_protocol_file_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_java_net_protocol_file_source_files)))\n gnu_java_net_protocol_ftp_source_files = \\\n classpath/gnu/java/net/protocol/ftp/ActiveModeDTP.java \\\n classpath/gnu/java/net/protocol/ftp/BlockInputStream.java \\\n@@ -2801,7 +2801,7 @@ classpath/java/net/NoRouteToHostException.java \\\n classpath/java/net/PasswordAuthentication.java \\\n classpath/java/net/PortUnreachableException.java \\\n classpath/java/net/ProtocolException.java \\\n-java/net/ServerSocket.java \\\n+classpath/java/net/ServerSocket.java \\\n classpath/java/net/Socket.java \\\n classpath/java/net/SocketAddress.java \\\n classpath/java/net/SocketException.java \\"}, {"sha": "fc560491d19630853d2c8f8b965c62a292f22bb1", "filename": "libjava/gnu/java/net/protocol/file/Handler.java", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11922361e4a39efa05cc2a807d656dc5bfb858b3/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Ffile%2FHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11922361e4a39efa05cc2a807d656dc5bfb858b3/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Ffile%2FHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Ffile%2FHandler.java?ref=11922361e4a39efa05cc2a807d656dc5bfb858b3", "patch": "@@ -1,91 +0,0 @@\n-/* Handler.java -- \"file\" protocol handler for java.net\n-   Copyright (C) 1998, 1999, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-package gnu.java.net.protocol.file;\n-\n-import java.io.IOException;\n-import java.net.URL;\n-import java.net.URLConnection;\n-import java.net.URLStreamHandler;\n-\n-/**\n- * This is the protocol handler for the \"file\" protocol.\n- * It implements the abstract openConnection() method from\n- * URLStreamHandler by returning a new FileURLConnection object (from\n- * this package).  All other methods are inherited\n- *\n- * @author Aaron M. Renn (arenn@urbanophile.com)\n- * @author Warren Levy (warrenl@cygnus.com)\n- */\n-public class Handler extends URLStreamHandler\n-{\n-  /**\n-   * A do nothing constructor\n-   */\n-  public Handler()\n-  {\n-  }\n-\n-  /**\n-   * This method returs a new FileURLConnection for the specified URL\n-   *\n-   * @param url The URL to return a connection for\n-   *\n-   * @return The URLConnection\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  protected URLConnection openConnection(URL url) throws IOException\n-  {\n-    // If a hostname is set, then we need to switch protocols to ftp\n-    // in order to transfer this from the remote host.\n-    String host = url.getHost();\n-    if ((host != null) && (! host.equals(\"\")))\n-      {\n-\t// Reset the protocol (and implicitly the handler) for this URL.\n-\t// Then have the URL attempt the connection again, as it will\n-\t// get the changed handler the next time around.\n-\t// If the ftp protocol handler is not installed, an \n-\t// exception will be thrown from the new openConnection() call.\n-\tsetURL (url, \"ftp\", url.getHost(), url.getPort(), url.getFile(),\n-\t        url.getRef());\n-\treturn url.openConnection();\n-      }\n-\n-    return new Connection(url);\n-  }\n-} // class Handler"}, {"sha": "85604fee7ecdcad07aef525b5ae0c8b76d207a7f", "filename": "libjava/java/net/ServerSocket.java", "status": "removed", "additions": 0, "deletions": 609, "changes": 609, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11922361e4a39efa05cc2a807d656dc5bfb858b3/libjava%2Fjava%2Fnet%2FServerSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11922361e4a39efa05cc2a807d656dc5bfb858b3/libjava%2Fjava%2Fnet%2FServerSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FServerSocket.java?ref=11922361e4a39efa05cc2a807d656dc5bfb858b3", "patch": "@@ -1,609 +0,0 @@\n-/* ServerSocket.java -- Class for implementing server side sockets\n-   Copyright (C) 1998, 1999, 2000, 2002, 2003, 2004\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-package java.net;\n-\n-import gnu.java.net.PlainSocketImpl;\n-\n-import java.io.IOException;\n-import java.nio.channels.IllegalBlockingModeException;\n-import java.nio.channels.ServerSocketChannel;\n-\n-\n-/* Written using on-line Java Platform 1.2 API Specification.\n- * Status:  I believe all methods are implemented.\n- */\n-\n-/**\n- * This class models server side sockets.  The basic model is that the\n- * server socket is created and bound to some well known port.  It then\n- * listens for and accepts connections.  At that point the client and\n- * server sockets are ready to communicate with one another utilizing\n- * whatever application layer protocol they desire.\n- *\n- * As with the <code>Socket</code> class, most instance methods of this class\n- * simply redirect their calls to an implementation class.\n- *\n- * @author Aaron M. Renn (arenn@urbanophile.com)\n- * @author Per Bothner (bothner@cygnus.com)\n- */\n-public class ServerSocket\n-{\n-  /**\n-   * This is the user defined SocketImplFactory, if one is supplied\n-   */\n-  private static SocketImplFactory factory;\n-\n-  /**\n-   * This is the SocketImp object to which most instance methods in this\n-   * class are redirected\n-   */\n-  private SocketImpl impl;\n-\n-  /**\n-   * True if socket is bound.\n-   */\n-  private boolean bound;\n-\n-  /*\n-   * This constructor is only used by java.nio.\n-   */\n-\n-  // FIXME: Workaround a bug in gcj.\n-  //ServerSocket (PlainSocketImpl impl) throws IOException\n-  ServerSocket(SocketImpl impl) throws IOException\n-  {\n-    if (impl == null)\n-      throw new NullPointerException(\"impl may not be null\");\n-\n-    this.impl = impl;\n-    this.impl.create(true);\n-  }\n-\n-  /*\n-   * This method is only used by java.nio.\n-   */\n-\n-  // FIXME: Workaround a bug in gcj.\n-  //PlainSocketImpl getImpl()\n-  SocketImpl getImpl()\n-  {\n-    return impl;\n-  }\n-\n-  /**\n-   * Constructor that simply sets the implementation.\n-   *\n-   * @exception IOException If an error occurs\n-   *\n-   * @specnote This constructor is public since JDK 1.4\n-   */\n-  public ServerSocket() throws IOException\n-  {\n-    if (factory != null)\n-      impl = factory.createSocketImpl();\n-    else\n-      impl = new PlainSocketImpl();\n-\n-    impl.create(true);\n-  }\n-\n-  /**\n-   * Creates a server socket and binds it to the specified port.  If the\n-   * port number is 0, a random free port will be chosen.  The pending\n-   * connection queue on this socket will be set to 50.\n-   *\n-   * @param port The port number to bind to\n-   *\n-   * @exception IOException If an error occurs\n-   * @exception SecurityException If a security manager exists and its\n-   * checkListen method doesn't allow the operation\n-   */\n-  public ServerSocket(int port) throws IOException\n-  {\n-    this(port, 50);\n-  }\n-\n-  /**\n-   * Creates a server socket and binds it to the specified port.  If the\n-   * port number is 0, a random free port will be chosen.  The pending\n-   * connection queue on this socket will be set to the value passed as\n-   * arg2.\n-   *\n-   * @param port The port number to bind to\n-   * @param backlog The length of the pending connection queue\n-   *\n-   * @exception IOException If an error occurs\n-   * @exception SecurityException If a security manager exists and its\n-   * checkListen method doesn't allow the operation\n-   */\n-  public ServerSocket(int port, int backlog) throws IOException\n-  {\n-    this(port, backlog, null);\n-  }\n-\n-  /**\n-   * Creates a server socket and binds it to the specified port.  If the\n-   * port number is 0, a random free port will be chosen.  The pending\n-   * connection queue on this socket will be set to the value passed as\n-   * backlog.  The third argument specifies a particular local address to\n-   * bind t or null to bind to all local address.\n-   *\n-   * @param port The port number to bind to\n-   * @param backlog The length of the pending connection queue\n-   * @param bindAddr The address to bind to, or null to bind to all addresses\n-   *\n-   * @exception IOException If an error occurs\n-   * @exception SecurityException If a security manager exists and its\n-   * checkListen method doesn't allow the operation\n-   *\n-   * @since 1.1\n-   */\n-  public ServerSocket(int port, int backlog, InetAddress bindAddr)\n-    throws IOException\n-  {\n-    this();\n-\n-    // bind/listen socket\n-    bind(new InetSocketAddress(bindAddr, port), backlog);\n-  }\n-\n-  /**\n-   * Binds the server socket to a specified socket address\n-   *\n-   * @param endpoint The socket address to bind to\n-   *\n-   * @exception IOException If an error occurs\n-   * @exception IllegalArgumentException If address type is not supported\n-   * @exception SecurityException If a security manager exists and its\n-   * checkListen method doesn't allow the operation\n-   *\n-   * @since 1.4\n-   */\n-  public void bind(SocketAddress endpoint) throws IOException\n-  {\n-    bind(endpoint, 50);\n-  }\n-\n-  /**\n-   * Binds the server socket to a specified socket address\n-   *\n-   * @param endpoint The socket address to bind to\n-   * @param backlog The length of the pending connection queue\n-   *\n-   * @exception IOException If an error occurs\n-   * @exception IllegalArgumentException If address type is not supported\n-   * @exception SecurityException If a security manager exists and its\n-   * checkListen method doesn't allow the operation\n-   *\n-   * @since 1.4\n-   */\n-  public void bind(SocketAddress endpoint, int backlog)\n-    throws IOException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"ServerSocket is closed\");\n-\n-    if (! (endpoint instanceof InetSocketAddress))\n-      throw new IllegalArgumentException(\"Address type not supported\");\n-\n-    InetSocketAddress tmp = (InetSocketAddress) endpoint;\n-\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkListen(tmp.getPort());\n-\n-    InetAddress addr = tmp.getAddress();\n-\n-    // Initialize addr with 0.0.0.0.\n-    if (addr == null)\n-      addr = InetAddress.ANY_IF;\n-\n-    try\n-      {\n-\timpl.bind(addr, tmp.getPort());\n-\timpl.listen(backlog);\n-\tbound = true;\n-      }\n-    catch (IOException exception)\n-      {\n-\tclose();\n-\tthrow exception;\n-      }\n-    catch (RuntimeException exception)\n-      {\n-\tclose();\n-\tthrow exception;\n-      }\n-    catch (Error error)\n-      {\n-\tclose();\n-\tthrow error;\n-      }\n-  }\n-\n-  /**\n-   * This method returns the local address to which this socket is bound\n-   *\n-   * @return The socket's local address\n-   */\n-  public InetAddress getInetAddress()\n-  {\n-    if (! isBound())\n-      return null;\n-\n-    try\n-      {\n-\treturn (InetAddress) impl.getOption(SocketOptions.SO_BINDADDR);\n-      }\n-    catch (SocketException e)\n-      {\n-\t// This never happens as we are bound.\n-\treturn null;\n-      }\n-  }\n-\n-  /**\n-   * This method returns the local port number to which this socket is bound\n-   *\n-   * @return The socket's port number\n-   */\n-  public int getLocalPort()\n-  {\n-    if (! isBound())\n-      return -1;\n-\n-    return impl.getLocalPort();\n-  }\n-\n-  /**\n-   * Returns the local socket address\n-   *\n-   * @return the local socket address, null if not bound\n-   * \n-   * @since 1.4\n-   */\n-  public SocketAddress getLocalSocketAddress()\n-  {\n-    if (! isBound())\n-      return null;\n-\n-    return new InetSocketAddress(getInetAddress(), getLocalPort());\n-  }\n-\n-  /**\n-   * Accepts a new connection and returns a connected <code>Socket</code>\n-   * instance representing that connection.  This method will block until a\n-   * connection is available.\n-   *\n-   * @return socket object for the just accepted connection\n-   *\n-   * @exception IOException If an error occurs\n-   * @exception SecurityException If a security manager exists and its\n-   * checkListen method doesn't allow the operation\n-   * @exception IllegalBlockingModeException If this socket has an associated\n-   * channel, and the channel is in non-blocking mode\n-   * @exception SocketTimeoutException If a timeout was previously set with\n-   * setSoTimeout and the timeout has been reached\n-   */\n-  public Socket accept() throws IOException\n-  {\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm != null)\n-      sm.checkListen(impl.getLocalPort());\n-\n-    Socket socket = new Socket();\n-\n-    try\n-      {\n-\timplAccept(socket);\n-      }\n-    catch (IOException e)\n-      {\n-\ttry\n-\t  {\n-\t    socket.close();\n-\t  }\n-\tcatch (IOException e2)\n-\t  {\n-\t    // Ignore.\n-\t  }\n-\n-\tthrow e;\n-      }\n-\n-    return socket;\n-  }\n-\n-  /**\n-   * This protected method is used to help subclasses override\n-   * <code>ServerSocket.accept()</code>.  The passed in socket will be\n-   * connected when this method returns.\n-   *\n-   * @param socket The socket that is used for the accepted connection\n-   *\n-   * @exception IOException If an error occurs\n-   * @exception IllegalBlockingModeException If this socket has an associated\n-   * channel, and the channel is in non-blocking mode\n-   *\n-   * @since 1.1\n-   */\n-  protected final void implAccept(Socket socket) throws IOException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"ServerSocket is closed\");\n-\n-    // The Sun spec says that if we have an associated channel and\n-    // it is in non-blocking mode, we throw an IllegalBlockingModeException.\n-    // However, in our implementation if the channel itself initiated this\n-    // operation, then we must honor it regardless of its blocking mode.\n-    if (getChannel() != null && ! getChannel().isBlocking()\n-        && ! ((PlainSocketImpl) getImpl()).isInChannelOperation())\n-      throw new IllegalBlockingModeException();\n-\n-    impl.accept(socket.impl);\n-    socket.implCreated = true;\n-  }\n-\n-  /**\n-   * Closes this socket and stops listening for connections\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public void close() throws IOException\n-  {\n-    if (isClosed())\n-      return;\n-\n-    impl.close();\n-    impl = null;\n-    bound = false;\n-\n-    if (getChannel() != null)\n-      getChannel().close();\n-  }\n-\n-  /**\n-   * Returns the unique <code>ServerSocketChannel</code> object\n-   * associated with this socket, if any.\n-   *\n-   * <p>The socket only has a <code>ServerSocketChannel</code> if its created\n-   * by <code>ServerSocketChannel.open()</code>.</p>\n-   *\n-   * @return the associated socket channel, null if none exists\n-   * \n-   * @since 1.4\n-   */\n-  public ServerSocketChannel getChannel()\n-  {\n-    return null;\n-  }\n-\n-  /**\n-   * Returns true when the socket is bound, otherwise false\n-   *\n-   * @return true if socket is bound, false otherwise\n-   * \n-   * @since 1.4\n-   */\n-  public boolean isBound()\n-  {\n-    return bound;\n-  }\n-\n-  /**\n-   * Returns true if the socket is closed, otherwise false\n-   *\n-   * @return true if socket is closed, false otherwise\n-   * \n-   * @since 1.4\n-   */\n-  public boolean isClosed()\n-  {\n-    return impl == null;\n-  }\n-\n-  /**\n-   * Sets the value of SO_TIMEOUT.  A value of 0 implies that SO_TIMEOUT is\n-   * disabled (ie, operations never time out).  This is the number of\n-   * milliseconds a socket operation can block before an\n-   * InterruptedIOException is thrown.\n-   *\n-   * @param timeout The new SO_TIMEOUT value\n-   *\n-   * @exception SocketException If an error occurs\n-   *\n-   * @since 1.1\n-   */\n-  public void setSoTimeout(int timeout) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"ServerSocket is closed\");\n-\n-    if (timeout < 0)\n-      throw new IllegalArgumentException(\"SO_TIMEOUT value must be >= 0\");\n-\n-    impl.setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));\n-  }\n-\n-  /**\n-   * Retrieves the current value of the SO_TIMEOUT setting.  A value of 0\n-   * implies that SO_TIMEOUT is disabled (ie, operations never time out).\n-   * This is the number of milliseconds a socket operation can block before\n-   * an InterruptedIOException is thrown.\n-   *\n-   * @return The value of SO_TIMEOUT\n-   *\n-   * @exception IOException If an error occurs\n-   *\n-   * @since 1.1\n-   */\n-  public int getSoTimeout() throws IOException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"ServerSocket is closed\");\n-\n-    Object timeout = impl.getOption(SocketOptions.SO_TIMEOUT);\n-\n-    if (! (timeout instanceof Integer))\n-      throw new IOException(\"Internal Error\");\n-\n-    return ((Integer) timeout).intValue();\n-  }\n-\n-  /**\n-   * Enables/Disables the SO_REUSEADDR option\n-   *\n-   * @param on true if SO_REUSEADDR should be enabled, false otherwise\n-   * \n-   * @exception SocketException If an error occurs\n-   *\n-   * @since 1.4\n-   */\n-  public void setReuseAddress(boolean on) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"ServerSocket is closed\");\n-\n-    impl.setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));\n-  }\n-\n-  /**\n-   * Checks if the SO_REUSEADDR option is enabled\n-   *\n-   * @return true if SO_REUSEADDR is set, false otherwise\n-   *\n-   * @exception SocketException If an error occurs\n-   *\n-   * @since 1.4\n-   */\n-  public boolean getReuseAddress() throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"ServerSocket is closed\");\n-\n-    Object reuseaddr = impl.getOption(SocketOptions.SO_REUSEADDR);\n-\n-    if (! (reuseaddr instanceof Boolean))\n-      throw new SocketException(\"Internal Error\");\n-\n-    return ((Boolean) reuseaddr).booleanValue();\n-  }\n-\n-  /**\n-   * This method sets the value for the system level socket option\n-   * SO_RCVBUF to the specified value.  Note that valid values for this\n-   * option are specific to a given operating system.\n-   *\n-   * @param size The new receive buffer size.\n-   *\n-   * @exception SocketException If an error occurs or Socket is not connected\n-   * @exception IllegalArgumentException If size is 0 or negative\n-   *\n-   * @since 1.4\n-   */\n-  public void setReceiveBufferSize(int size) throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"ServerSocket is closed\");\n-\n-    if (size <= 0)\n-      throw new IllegalArgumentException(\"SO_RCVBUF value must be > 0\");\n-\n-    impl.setOption(SocketOptions.SO_RCVBUF, new Integer(size));\n-  }\n-\n-  /**\n-   * This method returns the value of the system level socket option\n-   * SO_RCVBUF, which is used by the operating system to tune buffer\n-   * sizes for data transfers.\n-   *\n-   * @return The receive buffer size.\n-   *\n-   * @exception SocketException If an error occurs or Socket is not connected\n-   *\n-   * @since 1.4\n-   */\n-  public int getReceiveBufferSize() throws SocketException\n-  {\n-    if (isClosed())\n-      throw new SocketException(\"ServerSocket is closed\");\n-\n-    Object buf = impl.getOption(SocketOptions.SO_RCVBUF);\n-\n-    if (! (buf instanceof Integer))\n-      throw new SocketException(\"Internal Error: Unexpected type\");\n-\n-    return ((Integer) buf).intValue();\n-  }\n-\n-  /**\n-   * Returns the value of this socket as a <code>String</code>.\n-   *\n-   * @return This socket represented as a <code>String</code>.\n-   */\n-  public String toString()\n-  {\n-    if (! isBound())\n-      return \"ServerSocket[unbound]\";\n-\n-    return (\"ServerSocket[addr=\" + getInetAddress() + \",port=\"\n-           + impl.getPort() + \",localport=\" + impl.getLocalPort() + \"]\");\n-  }\n-\n-  /**\n-   * Sets the <code>SocketImplFactory</code> for all\n-   * <code>ServerSocket</code>'s.  This may only be done\n-   * once per virtual machine.  Subsequent attempts will generate an\n-   * exception.  Note that a <code>SecurityManager</code> check is made prior\n-   * to setting the factory.  If insufficient privileges exist to set the\n-   * factory, an exception will be thrown\n-   *\n-   * @param fac the factory to set\n-   *\n-   * @exception SecurityException If this operation is not allowed by the\n-   * <code>SecurityManager</code>.\n-   * @exception SocketException If the factory object is already defined\n-   * @exception IOException If any other error occurs\n-   */\n-  public static synchronized void setSocketFactory(SocketImplFactory fac)\n-    throws IOException\n-  {\n-    factory = fac;\n-  }\n-}"}, {"sha": "5bb0337adcecdb8a6204da2fbdc32c4cd1bd803f", "filename": "libjava/java/net/URLClassLoader.java", "status": "modified", "additions": 80, "deletions": 79, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4e1433a02a9bd5e2ddecd0d346d57876ad53307/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4e1433a02a9bd5e2ddecd0d346d57876ad53307/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLClassLoader.java?ref=f4e1433a02a9bd5e2ddecd0d346d57876ad53307", "patch": "@@ -248,12 +248,10 @@ Vector getClassPath()\n   abstract static class Resource\n   {\n     final URLLoader loader;\n-    final String name;\n \n-    Resource(URLLoader loader, String name)\n+    Resource(URLLoader loader)\n     {\n       this.loader = loader;\n-      this.name = name;\n     }\n \n     /**\n@@ -404,11 +402,13 @@ Vector getClassPath()\n   static final class JarURLResource extends Resource\n   {\n     private final JarEntry entry;\n+    private final String name;\n \n     JarURLResource(JarURLLoader loader, String name, JarEntry entry)\n     {\n-      super(loader, name);\n+      super(loader);\n       this.entry = entry;\n+      this.name = name;\n     }\n \n     InputStream getInputStream() throws IOException\n@@ -509,7 +509,7 @@ static final class RemoteResource extends Resource\n     RemoteResource(RemoteURLLoader loader, String name, URL url,\n                    InputStream stream, int length)\n     {\n-      super(loader, name);\n+      super(loader);\n       this.url = url;\n       this.stream = stream;\n       this.length = length;\n@@ -561,15 +561,15 @@ Resource getResource(String name)\n       URL url = helper.findResource(name);\n       if (url == null)\n \treturn null;\n-      return new SoResource(this, name, url);\n+      return new SoResource(this, url);\n     }\n   }\n \n   final static class SoResource extends Resource\n   {\n-    SoResource(SoURLLoader loader, String name, URL url)\n+    SoResource(SoURLLoader loader, URL url)\n     {\n-      super(loader, name);\n+      super(loader);\n       this.url = url;\n     }\n \n@@ -614,7 +614,7 @@ Resource getResource(String name)\n  \t{\n  \t  File file = new File(dir, name).getCanonicalFile();\n  \t  if (file.exists() && !file.isDirectory())\n- \t    return new FileResource(this, file.getPath(), file);\n+ \t    return new FileResource(this, file);\n  \t}\n       catch (IOException e)\n  \t{\n@@ -628,9 +628,9 @@ static final class FileResource extends Resource\n   {\n     final File file;\n \n-    FileResource(FileURLLoader loader, String name, File file)\n+    FileResource(FileURLLoader loader, File file)\n     {\n-      super(loader, name);\n+      super(loader);\n       this.file = file;\n     }\n \n@@ -673,8 +673,7 @@ public URL getURL()\n     {\n       try\n         {\n-          return new URL(loader.baseURL, name,\n-                         loader.classloader.getURLStreamHandler(\"file\"));\n+          return file.toURL();\n         }\n       catch (MalformedURLException e)\n         {\n@@ -711,12 +710,14 @@ Resource getResource(String name)\n \n   static final class CoreResource extends Resource\n   {\n-    final Core core;\n+    private final Core core;\n+    private final String name;\n \n     CoreResource(CoreURLLoader loader, String name, Core core)\n     {\n-      super(loader, name);\n+      super(loader);\n       this.core = core;\n+      this.name = name;\n     }\n \n     InputStream getInputStream() throws IOException\n@@ -755,10 +756,10 @@ public URL getURL()\n    * in the order given to the URLClassLoader which uses these URLs to\n    * load classes and resources (after using the default parent ClassLoader).\n    *\n-   * @exception SecurityException if the SecurityManager disallows the\n-   * creation of a ClassLoader.\n    * @param urls Locations that should be searched by this ClassLoader when\n    * resolving Classes or Resources.\n+   * @exception SecurityException if the SecurityManager disallows the\n+   * creation of a ClassLoader.\n    * @see SecureClassLoader\n    */\n   public URLClassLoader(URL[] urls) throws SecurityException\n@@ -769,25 +770,6 @@ public URLClassLoader(URL[] urls) throws SecurityException\n     addURLs(urls);\n   }\n \n-  /**\n-   * Private constructor used by the static\n-   * <code>newInstance(URL[])</code> method.  Creates an\n-   * <code>URLClassLoader</code> without any <code>URL</code>s\n-   * yet. This is used to bypass the normal security check for\n-   * creating classloaders, but remembers the security context which\n-   * will be used when defining classes.  The <code>URL</code>s to\n-   * load from must be added by the <code>newInstance()</code> method\n-   * in the security context of the caller.\n-   *\n-   * @param securityContext the security context of the unprivileged code.\n-   */\n-  private URLClassLoader(AccessControlContext securityContext)\n-  {\n-    super();\n-    this.factory = null;\n-    this.securityContext = securityContext;\n-  }\n-\n   /**\n    * Creates a <code>URLClassLoader</code> that gets classes from the supplied\n    * <code>URL</code>s.\n@@ -796,13 +778,13 @@ private URLClassLoader(AccessControlContext securityContext)\n    * can throw a SecurityException. Then the supplied URLs are added\n    * in the order given to the URLClassLoader which uses these URLs to\n    * load classes and resources (after using the supplied parent ClassLoader).\n-   * @exception SecurityException if the SecurityManager disallows the\n-   * creation of a ClassLoader.\n-   * @exception SecurityException\n    * @param urls Locations that should be searched by this ClassLoader when\n    * resolving Classes or Resources.\n    * @param parent The parent class loader used before trying this class\n    * loader.\n+   * @exception SecurityException if the SecurityManager disallows the\n+   * creation of a ClassLoader.\n+   * @exception SecurityException\n    * @see SecureClassLoader\n    */\n   public URLClassLoader(URL[] urls, ClassLoader parent)\n@@ -844,14 +826,14 @@ public URLClassLoader(URL[] urls, ClassLoader parent)\n    * load classes and resources (after using the supplied parent ClassLoader).\n    * It will use the supplied <CODE>URLStreamHandlerFactory</CODE> to get the\n    * protocol handlers of the supplied URLs.\n-   * @exception SecurityException if the SecurityManager disallows the\n-   * creation of a ClassLoader.\n-   * @exception SecurityException\n    * @param urls Locations that should be searched by this ClassLoader when\n    * resolving Classes or Resources.\n    * @param parent The parent class loader used before trying this class\n    * loader.\n    * @param factory Used to get the protocol handler for the URLs.\n+   * @exception SecurityException if the SecurityManager disallows the\n+   * creation of a ClassLoader.\n+   * @exception SecurityException\n    * @see SecureClassLoader\n    */\n   public URLClassLoader(URL[] urls, ClassLoader parent,\n@@ -938,13 +920,21 @@ else if (\"core\".equals(protocol))\n   }\n \n   /**\n-   * Adds an array of new locations to the end of the internal URL store.\n+   * Adds an array of new locations to the end of the internal URL\n+   * store.  Called from the the constructors. Should not call to the\n+   * protected addURL() method since that can be overridden and\n+   * subclasses are not yet in a good state at this point.\n+   * jboss 4.0.3 for example depends on this.\n+   *\n    * @param newUrls the locations to add\n    */\n   private void addURLs(URL[] newUrls)\n   {\n     for (int i = 0; i < newUrls.length; i++)\n-      addURL(newUrls[i]);\n+      {\n+\turls.add(newUrls[i]);\n+\taddURLImpl(newUrls[i]);\n+      }\n   }\n \n   /**\n@@ -969,13 +959,13 @@ private String getAttributeValue(Attributes.Name name, Attributes first,\n    * package is sealed. If the Manifest indicates that the package is sealed\n    * then the Package will be sealed with respect to the supplied URL.\n    *\n-   * @exception IllegalArgumentException If this package name already exists\n-   * in this class loader\n    * @param name The name of the package\n    * @param manifest The manifest describing the specification,\n    * implementation and sealing details of the package\n    * @param url the code source url to seal the package\n    * @return the defined Package\n+   * @throws IllegalArgumentException If this package name already exists\n+   * in this class loader\n    */\n   protected Package definePackage(String name, Manifest manifest, URL url)\n     throws IllegalArgumentException\n@@ -1062,40 +1052,47 @@ protected Class findClass(final String className)\n     // construct the class (and watch out for those nasty IOExceptions)\n     try\n       {\n-        byte[] data;\n-        InputStream in = resource.getInputStream();\n-\tint length = resource.getLength();\n-\tif (length != -1)\n+\tbyte[] data;\n+\tInputStream in = resource.getInputStream();\n+\ttry\n \t  {\n-\t    // We know the length of the data.\n-\t    // Just try to read it in all at once\n-\t    data = new byte[length];\n-\t    int pos = 0;\n-\t    while (length - pos > 0)\n+\t    int length = resource.getLength();\n+\t    if (length != -1)\n \t      {\n-\t\tint len = in.read(data, pos, length - pos);\n-\t\tif (len == -1)\n-\t\t  throw new EOFException(\"Not enough data reading from: \"\n-\t\t\t\t\t + in);\n-\t\tpos += len;\n+\t\t// We know the length of the data.\n+\t\t// Just try to read it in all at once\n+\t\tdata = new byte[length];\n+\t\tint pos = 0;\n+\t\twhile (length - pos > 0)\n+\t\t  {\n+\t\t    int len = in.read(data, pos, length - pos);\n+\t\t    if (len == -1)\n+\t\t      throw new EOFException(\"Not enough data reading from: \"\n+\t\t\t\t\t     + in);\n+\t\t    pos += len;\n+\t\t  }\n \t      }\n-\t  }\n-\telse\n-\t  {\n-\t    // We don't know the data length.\n-\t    // Have to read it in chunks.\n-\t    ByteArrayOutputStream out = new ByteArrayOutputStream(4096);\n-\t    byte[] b = new byte[4096];\n-\t    int l = 0;\n-\t    while (l != -1)\n+\t    else\n \t      {\n-\t\tl = in.read(b);\n-\t\tif (l != -1)\n-\t\t  out.write(b, 0, l);\n+\t\t// We don't know the data length.\n+\t\t// Have to read it in chunks.\n+\t\tByteArrayOutputStream out = new ByteArrayOutputStream(4096);\n+\t\tbyte[] b = new byte[4096];\n+\t\tint l = 0;\n+\t\twhile (l != -1)\n+\t\t  {\n+\t\t    l = in.read(b);\n+\t\t    if (l != -1)\n+\t\t      out.write(b, 0, l);\n+\t\t  }\n+\t\tdata = out.toByteArray();\n \t      }\n-\t    data = out.toByteArray();\n-          }\n-        final byte[] classData = data;\n+\t  }\n+\tfinally\n+\t  {\n+\t    in.close();\n+\t  }\n+\tfinal byte[] classData = data;\n \n         // Now get the CodeSource\n         final CodeSource source = resource.getCodeSource();\n@@ -1136,7 +1133,11 @@ public Object run()\n         else\n           result = defineClass(className, classData, 0, classData.length, source);\n \n-        super.setSigners(result, resource.getCertificates());\n+        // Avoid NullPointerExceptions.\n+        Certificate[] resourceCertificates = resource.getCertificates();\n+        if(resourceCertificates != null)\n+          super.setSigners(result, resourceCertificates);\n+        \n         return result;\n       }\n     catch (IOException ioe)\n@@ -1252,11 +1253,11 @@ URLStreamHandler getURLStreamHandler(String protocol)\n   /**\n    * Finds all the resources with a particular name from all the locations.\n    *\n-   * @exception IOException when an error occurs accessing one of the\n-   * locations\n    * @param resourceName the name of the resource to lookup\n    * @return a (possible empty) enumeration of URLs where the resource can be\n    * found\n+   * @exception IOException when an error occurs accessing one of the\n+   * locations\n    */\n   public Enumeration findResources(String resourceName)\n     throws IOException\n@@ -1291,7 +1292,7 @@ public Enumeration findResources(String resourceName)\n    *\n    * @param source The codesource that needs the permissions to be accessed\n    * @return the collection of permissions needed to access the code resource\n-   * @see java.security.SecureClassLoader#getPermissions()\n+   * @see java.security.SecureClassLoader#getPermissions(CodeSource)\n    */\n   protected PermissionCollection getPermissions(CodeSource source)\n   {"}, {"sha": "b5e4cb0624149426de42b5caccc64be2966c82d3", "filename": "libjava/java/net/URLConnection.java", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4e1433a02a9bd5e2ddecd0d346d57876ad53307/libjava%2Fjava%2Fnet%2FURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4e1433a02a9bd5e2ddecd0d346d57876ad53307/libjava%2Fjava%2Fnet%2FURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLConnection.java?ref=f4e1433a02a9bd5e2ddecd0d346d57876ad53307", "patch": "@@ -539,7 +539,7 @@ public String toString()\n   }\n \n   /**\n-   * Returns the value of a flag indicating whether or not input is going\n+   * Sets the value of a flag indicating whether or not input is going\n    * to be done for this connection.  This default to true unless the\n    * doOutput flag is set to false, in which case this defaults to false.\n    *\n@@ -569,7 +569,7 @@ public boolean getDoInput()\n   }\n \n   /**\n-   * Returns a boolean flag indicating whether or not output will be done\n+   * Sets a boolean flag indicating whether or not output will be done\n    * on this connection.  The default value is false, so this method can\n    * be used to override the default\n    *\n@@ -860,7 +860,7 @@ public static String getDefaultRequestProperty(String key)\n   }\n \n   /**\n-   * Set's the ContentHandlerFactory for an application.  This can be called\n+   * Sets the ContentHandlerFactory for an application.  This can be called\n    * once and only once.  If it is called again, then an Error is thrown.\n    * Unlike for other set factory methods, this one does not do a security\n    * check prior to setting the factory.\n@@ -956,7 +956,7 @@ public static FileNameMap getFileNameMap()\n   }\n \n   /**\n-   * This method set the <code>FileNameMap</code> object being used\n+   * This method sets the <code>FileNameMap</code> object being used\n    * to decode MIME types by file extension.\n    *\n    * @param map The <code>FileNameMap</code>."}, {"sha": "ddf5c8da5af46eb4e11068bbc283cfa064bb9c0b", "filename": "libjava/sources.am", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4e1433a02a9bd5e2ddecd0d346d57876ad53307/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4e1433a02a9bd5e2ddecd0d346d57876ad53307/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=f4e1433a02a9bd5e2ddecd0d346d57876ad53307", "patch": "@@ -976,9 +976,9 @@ gnu/java/net.list: $(gnu_java_net_source_files)\n \n gnu_java_net_protocol_file_source_files = \\\n gnu/java/net/protocol/file/Connection.java \\\n-gnu/java/net/protocol/file/Handler.java\n+classpath/gnu/java/net/protocol/file/Handler.java\n \n-gnu_java_net_protocol_file_header_files = $(patsubst %.java,%.h,$(gnu_java_net_protocol_file_source_files))\n+gnu_java_net_protocol_file_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_java_net_protocol_file_source_files)))\n \n gnu/java/net/protocol/file.list: $(gnu_java_net_protocol_file_source_files)\n \t@$(mkinstalldirs) $(dir $@)\n@@ -3009,7 +3009,7 @@ classpath/java/net/NoRouteToHostException.java \\\n classpath/java/net/PasswordAuthentication.java \\\n classpath/java/net/PortUnreachableException.java \\\n classpath/java/net/ProtocolException.java \\\n-java/net/ServerSocket.java \\\n+classpath/java/net/ServerSocket.java \\\n classpath/java/net/Socket.java \\\n classpath/java/net/SocketAddress.java \\\n classpath/java/net/SocketException.java \\"}]}