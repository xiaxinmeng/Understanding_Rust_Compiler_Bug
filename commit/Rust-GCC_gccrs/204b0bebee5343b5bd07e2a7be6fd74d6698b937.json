{"sha": "204b0bebee5343b5bd07e2a7be6fd74d6698b937", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA0YjBiZWJlZTUzNDNiNWJkMDdlMmE3YmU2ZmQ3NGQ2Njk4YjkzNw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-11-22T18:17:04Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-11-22T18:17:04Z"}, "message": "re PR tree-optimization/92618 (error: type mismatch in binary expression in reassoc since r273490)\n\n\tPR tree-optimization/92618\n\t* tree-ssa-reassoc.c (v_info): Change from auto_vec to a struct\n\tcontaining the auto_vec and a tree.\n\t(undistribute_bitref_for_vector): Handle the case when element type\n\tof vec is not the same as type of the BIT_FIELD_REF.  Formatting\n\tfixes.\n\n\t* gcc.c-torture/compile/pr92618.c: New test.\n\t* gcc.c-torture/execute/pr92618.c: New test.\n\nFrom-SVN: r278626", "tree": {"sha": "052293e4a3a5094dff1140f32ce16b304bf224ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/052293e4a3a5094dff1140f32ce16b304bf224ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/204b0bebee5343b5bd07e2a7be6fd74d6698b937", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/204b0bebee5343b5bd07e2a7be6fd74d6698b937", "html_url": "https://github.com/Rust-GCC/gccrs/commit/204b0bebee5343b5bd07e2a7be6fd74d6698b937", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/204b0bebee5343b5bd07e2a7be6fd74d6698b937/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "54aa6b58fe2fe73bbe67e0485777e0c410a18673", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54aa6b58fe2fe73bbe67e0485777e0c410a18673", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54aa6b58fe2fe73bbe67e0485777e0c410a18673"}], "stats": {"total": 263, "additions": 242, "deletions": 21}, "files": [{"sha": "7f7dd0006f2d4663b16982d4cb57a8f59e08b43b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204b0bebee5343b5bd07e2a7be6fd74d6698b937/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204b0bebee5343b5bd07e2a7be6fd74d6698b937/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=204b0bebee5343b5bd07e2a7be6fd74d6698b937", "patch": "@@ -1,3 +1,12 @@\n+2019-11-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/92618\n+\t* tree-ssa-reassoc.c (v_info): Change from auto_vec to a struct\n+\tcontaining the auto_vec and a tree.\n+\t(undistribute_bitref_for_vector): Handle the case when element type\n+\tof vec is not the same as type of the BIT_FIELD_REF.  Formatting\n+\tfixes.\n+\n 2019-11-22  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/83859"}, {"sha": "b3ff86843ee6e1f7cd9a82f18959654a78da1dad", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204b0bebee5343b5bd07e2a7be6fd74d6698b937/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204b0bebee5343b5bd07e2a7be6fd74d6698b937/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=204b0bebee5343b5bd07e2a7be6fd74d6698b937", "patch": "@@ -1,3 +1,9 @@\n+2019-11-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/92618\n+\t* gcc.c-torture/compile/pr92618.c: New test.\n+\t* gcc.c-torture/execute/pr92618.c: New test.\n+\n 2019-11-22  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/83859"}, {"sha": "b2a2eeadab31b03b2f1a197251f176d5e2279b11", "filename": "gcc/testsuite/gcc.c-torture/compile/pr92618.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204b0bebee5343b5bd07e2a7be6fd74d6698b937/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr92618.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204b0bebee5343b5bd07e2a7be6fd74d6698b937/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr92618.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr92618.c?ref=204b0bebee5343b5bd07e2a7be6fd74d6698b937", "patch": "@@ -0,0 +1,67 @@\n+/* PR tree-optimization/92618 */\n+\n+typedef long long __m128i __attribute__((__may_alias__, __vector_size__(2 * sizeof (long long))));\n+typedef long long __m256i __attribute__((__may_alias__, __vector_size__(4 * sizeof (long long))));\n+typedef long long __m512i __attribute__((__may_alias__, __vector_size__(8 * sizeof (long long))));\n+\n+double a[32];\n+unsigned long long b[32];\n+__m128i bar (void);\n+__m256i qux (void);\n+__m512i corge (void);\n+\n+void\n+foo (unsigned long long *x)\n+{\n+  __m128i c = bar ();\n+  __m128i d = bar ();\n+  __m256i e = qux ();\n+  __m256i f = qux ();\n+  __m256i g = qux ();\n+  __m512i h = corge ();\n+  __m512i i = corge ();\n+  *(__m128i *) &b[0] = c;\n+  *(__m128i *) &b[2] = d;\n+  *(__m256i *) &b[4] = e;\n+  *(__m256i *) &b[8] = f;\n+  *(__m256i *) &b[12] = g;\n+  *(__m512i *) &b[16] = h;\n+  *(__m512i *) &b[24] = i;\n+  *x = b[0] + b[1] + b[2] + b[3]\n+     + b[4] + b[5] + b[6] + b[7]\n+     + b[8] + b[9] + b[10] + b[11]\n+     + b[12] + b[13] + b[14] + b[15]\n+     + b[16] + b[17] + b[18] + b[19]\n+     + b[20] + b[21] + b[22] + b[23]\n+     + b[24] + b[25] + b[26] + b[27]\n+     + b[28] + b[29] + b[30] + b[31];\n+}\n+\n+void\n+baz (double *x)\n+{\n+#if __SIZEOF_LONG_LONG__ == __SIZEOF_DOUBLE__\n+  __m128i c = bar ();\n+  __m128i d = bar ();\n+  __m256i e = qux ();\n+  __m256i f = qux ();\n+  __m256i g = qux ();\n+  __m512i h = corge ();\n+  __m512i i = corge ();\n+  *(__m128i *) &a[0] = c;\n+  *(__m128i *) &a[2] = d;\n+  *(__m256i *) &a[4] = e;\n+  *(__m256i *) &a[8] = f;\n+  *(__m256i *) &a[12] = g;\n+  *(__m512i *) &a[16] = h;\n+  *(__m512i *) &a[24] = i;\n+  *x = a[0] + a[1] + a[2] + a[3]\n+     + a[4] + a[5] + a[6] + a[7]\n+     + a[8] + a[9] + a[10] + a[11]\n+     + a[12] + a[13] + a[14] + a[15]\n+     + a[16] + a[17] + a[18] + a[19]\n+     + a[20] + a[21] + a[22] + a[23]\n+     + a[24] + a[25] + a[26] + a[27]\n+     + a[28] + a[29] + a[30] + a[31];\n+#endif\n+}"}, {"sha": "2a5e565559fbd4a0e966dd0f1b8b7895ab52dd67", "filename": "gcc/testsuite/gcc.c-torture/execute/pr92618.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204b0bebee5343b5bd07e2a7be6fd74d6698b937/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr92618.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204b0bebee5343b5bd07e2a7be6fd74d6698b937/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr92618.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr92618.c?ref=204b0bebee5343b5bd07e2a7be6fd74d6698b937", "patch": "@@ -0,0 +1,63 @@\n+/* PR tree-optimization/92618 */\n+\n+typedef long long __m128i __attribute__((__may_alias__, __vector_size__(2 * sizeof (long long))));\n+\n+double a[4];\n+unsigned long long b[4];\n+\n+__attribute__((noipa)) __m128i\n+bar (void)\n+{\n+  static int cnt;\n+  cnt += 2;\n+  return (__m128i) { cnt, cnt + 1 };\n+}\n+\n+#if __SIZEOF_LONG_LONG__ == __SIZEOF_DOUBLE__\n+typedef double __m128d __attribute__((__may_alias__, __vector_size__(2 * sizeof (double))));\n+\n+__attribute__((noipa)) __m128i\n+qux (void)\n+{\n+  static double cnt;\n+  cnt += 2.0;\n+  return (__m128i) (__m128d) { cnt, cnt + 1.0 };\n+}\n+#endif\n+\n+void\n+foo (unsigned long long *x)\n+{\n+  __m128i c = bar ();\n+  __m128i d = bar ();\n+  *(__m128i *) &b[0] = c;\n+  *(__m128i *) &b[2] = d;\n+  *x = b[0] + b[1] + b[2] + b[3];\n+}\n+\n+void\n+baz (double *x)\n+{\n+#if __SIZEOF_LONG_LONG__ == __SIZEOF_DOUBLE__\n+  __m128i c = qux ();\n+  __m128i d = qux ();\n+  *(__m128i *) &a[0] = c;\n+  *(__m128i *) &a[2] = d;\n+  *x = a[0] + a[1] + a[2] + a[3];\n+#endif\n+}\n+\n+int\n+main ()\n+{\n+  unsigned long long c = 0;\n+  foo (&c);\n+  if (c != 2 + 3 + 4 + 5)\n+    __builtin_abort ();\n+#if __SIZEOF_LONG_LONG__ == __SIZEOF_DOUBLE__\n+  double d = 0.0;\n+  baz (&d);\n+  if (d != 2.0 + 3.0 + 4.0 + 5.0)\n+    __builtin_abort ();\n+#endif\n+}"}, {"sha": "3479591366136b0cb3bd8bbbaf49864cf7124b74", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 97, "deletions": 21, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204b0bebee5343b5bd07e2a7be6fd74d6698b937/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204b0bebee5343b5bd07e2a7be6fd74d6698b937/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=204b0bebee5343b5bd07e2a7be6fd74d6698b937", "patch": "@@ -1775,7 +1775,10 @@ undistribute_ops_list (enum tree_code opcode,\n    first: element index for each relevant BIT_FIELD_REF.\n    second: the index of vec ops* for each relevant BIT_FIELD_REF.  */\n typedef std::pair<unsigned, unsigned> v_info_elem;\n-typedef auto_vec<v_info_elem, 32> v_info;\n+struct v_info {\n+  tree vec_type;\n+  auto_vec<v_info_elem, 32> vec;\n+};\n typedef v_info *v_info_ptr;\n \n /* Comparison function for qsort on VECTOR SSA_NAME trees by machine mode.  */\n@@ -1840,8 +1843,11 @@ undistribute_bitref_for_vector (enum tree_code opcode,\n   if (ops->length () <= 1)\n     return false;\n \n-  if (opcode != PLUS_EXPR && opcode != MULT_EXPR && opcode != BIT_XOR_EXPR\n-      && opcode != BIT_IOR_EXPR && opcode != BIT_AND_EXPR)\n+  if (opcode != PLUS_EXPR\n+      && opcode != MULT_EXPR\n+      && opcode != BIT_XOR_EXPR\n+      && opcode != BIT_IOR_EXPR\n+      && opcode != BIT_AND_EXPR)\n     return false;\n \n   hash_map<tree, v_info_ptr> v_info_map;\n@@ -1879,9 +1885,45 @@ undistribute_bitref_for_vector (enum tree_code opcode,\n       if (!TYPE_VECTOR_SUBPARTS (vec_type).is_constant ())\n \tcontinue;\n \n+      if (VECTOR_TYPE_P (TREE_TYPE (rhs))\n+\t  || !is_a <scalar_mode> (TYPE_MODE (TREE_TYPE (rhs))))\n+\tcontinue;\n+\n+      /* The type of BIT_FIELD_REF might not be equal to the element type of\n+\t the vector.  We want to use a vector type with element type the\n+\t same as the BIT_FIELD_REF and size the same as TREE_TYPE (vec).  */\n+      if (!useless_type_conversion_p (TREE_TYPE (rhs), TREE_TYPE (vec_type)))\n+\t{\n+\t  machine_mode simd_mode;\n+\t  unsigned HOST_WIDE_INT size, nunits;\n+\t  unsigned HOST_WIDE_INT elem_size\n+\t    = tree_to_uhwi (TYPE_SIZE (TREE_TYPE (rhs)));\n+\t  if (!GET_MODE_BITSIZE (TYPE_MODE (vec_type)).is_constant (&size))\n+\t    continue;\n+\t  if (size <= elem_size || (size % elem_size) != 0)\n+\t    continue;\n+\t  nunits = size / elem_size;\n+\t  if (!mode_for_vector (SCALAR_TYPE_MODE (TREE_TYPE (rhs)),\n+\t\t\t\tnunits).exists (&simd_mode))\n+\t    continue;\n+\t  vec_type = build_vector_type_for_mode (TREE_TYPE (rhs), simd_mode);\n+\n+\t  /* Ignore it if target machine can't support this VECTOR type.  */\n+\t  if (!VECTOR_MODE_P (TYPE_MODE (vec_type)))\n+\t    continue;\n+\n+\t  /* Check const vector type, constrain BIT_FIELD_REF offset and\n+\t     size.  */\n+\t  if (!TYPE_VECTOR_SUBPARTS (vec_type).is_constant ())\n+\t    continue;\n+\n+\t  if (maybe_ne (GET_MODE_SIZE (TYPE_MODE (vec_type)),\n+\t\t\tGET_MODE_SIZE (TYPE_MODE (TREE_TYPE (vec)))))\n+\t    continue;\n+\t}\n+\n       tree elem_type = TREE_TYPE (vec_type);\n-      unsigned HOST_WIDE_INT elem_size\n-\t= TREE_INT_CST_LOW (TYPE_SIZE (elem_type));\n+      unsigned HOST_WIDE_INT elem_size = tree_to_uhwi (TYPE_SIZE (elem_type));\n       if (maybe_ne (bit_field_size (rhs), elem_size))\n \tcontinue;\n \n@@ -1898,8 +1940,13 @@ undistribute_bitref_for_vector (enum tree_code opcode,\n       bool existed;\n       v_info_ptr &info = v_info_map.get_or_insert (vec, &existed);\n       if (!existed)\n-\tinfo = new v_info;\n-      info->safe_push (std::make_pair (idx, i));\n+\t{\n+\t  info = new v_info;\n+\t  info->vec_type = vec_type;\n+\t}\n+      else if (!types_compatible_p (vec_type, info->vec_type))\n+\tcontinue;\n+      info->vec.safe_push (std::make_pair (idx, i));\n     }\n \n   /* At least two VECTOR to combine.  */\n@@ -1919,14 +1966,15 @@ undistribute_bitref_for_vector (enum tree_code opcode,\n     {\n       tree cand_vec = (*it).first;\n       v_info_ptr cand_info = (*it).second;\n-      unsigned int num_elems = VECTOR_CST_NELTS (cand_vec).to_constant ();\n-      if (cand_info->length () != num_elems)\n+      unsigned int num_elems\n+\t= TYPE_VECTOR_SUBPARTS (cand_info->vec_type).to_constant ();\n+      if (cand_info->vec.length () != num_elems)\n \tcontinue;\n       sbitmap holes = sbitmap_alloc (num_elems);\n       bitmap_ones (holes);\n       bool valid = true;\n       v_info_elem *curr;\n-      FOR_EACH_VEC_ELT (*cand_info, i, curr)\n+      FOR_EACH_VEC_ELT (cand_info->vec, i, curr)\n \t{\n \t  if (!bitmap_bit_p (holes, curr->first))\n \t    {\n@@ -1962,25 +2010,53 @@ undistribute_bitref_for_vector (enum tree_code opcode,\n \n       unsigned int idx, j;\n       gimple *sum = NULL;\n-      v_info_ptr info_ptr;\n       tree sum_vec = tvec;\n+      v_info_ptr info_ptr = *(v_info_map.get (tvec));\n       v_info_elem *elem;\n+      tree vec_type = info_ptr->vec_type;\n \n       /* Build the sum for all candidates with same mode.  */\n       do\n \t{\n-\t  sum = build_and_add_sum (TREE_TYPE (sum_vec), sum_vec,\n+\t  sum = build_and_add_sum (vec_type, sum_vec,\n \t\t\t\t   valid_vecs[i + 1], opcode);\n+\t  if (!useless_type_conversion_p (vec_type,\n+\t\t\t\t\t  TREE_TYPE (valid_vecs[i + 1])))\n+\t    {\n+\t      /* Update the operands only after build_and_add_sum,\n+\t\t so that we don't have to repeat the placement algorithm\n+\t\t of build_and_add_sum.  */\n+\t      gimple_stmt_iterator gsi = gsi_for_stmt (sum);\n+\t      tree vce = build1 (VIEW_CONVERT_EXPR, vec_type,\n+\t\t\t\t valid_vecs[i + 1]);\n+\t      tree lhs = make_ssa_name (vec_type);\n+\t      gimple *g = gimple_build_assign (lhs, VIEW_CONVERT_EXPR, vce);\n+\t      gimple_set_uid (g, gimple_uid (sum));\n+\t      gsi_insert_before (&gsi, g, GSI_NEW_STMT);\n+\t      gimple_assign_set_rhs2 (sum, lhs);\n+\t      if (sum_vec == tvec)\n+\t\t{\n+\t\t  vce = build1 (VIEW_CONVERT_EXPR, vec_type, sum_vec);\n+\t\t  lhs = make_ssa_name (vec_type);\n+\t\t  g = gimple_build_assign (lhs, VIEW_CONVERT_EXPR, vce);\n+\t\t  gimple_set_uid (g, gimple_uid (sum));\n+\t\t  gsi_insert_before (&gsi, g, GSI_NEW_STMT);\n+\t\t  gimple_assign_set_rhs1 (sum, lhs);\n+\t\t}\n+\t      update_stmt (sum);\n+\t    }\n \t  sum_vec = gimple_get_lhs (sum);\n \t  info_ptr = *(v_info_map.get (valid_vecs[i + 1]));\n+\t  gcc_assert (types_compatible_p (vec_type, info_ptr->vec_type));\n \t  /* Update those related ops of current candidate VECTOR.  */\n-\t  FOR_EACH_VEC_ELT (*info_ptr, j, elem)\n+\t  FOR_EACH_VEC_ELT (info_ptr->vec, j, elem)\n \t    {\n \t      idx = elem->second;\n \t      gimple *def = SSA_NAME_DEF_STMT ((*ops)[idx]->op);\n \t      /* Set this then op definition will get DCEd later.  */\n \t      gimple_set_visited (def, true);\n-\t      if (opcode == PLUS_EXPR || opcode == BIT_XOR_EXPR\n+\t      if (opcode == PLUS_EXPR\n+\t\t  || opcode == BIT_XOR_EXPR\n \t\t  || opcode == BIT_IOR_EXPR)\n \t\t(*ops)[idx]->op = build_zero_cst (TREE_TYPE ((*ops)[idx]->op));\n \t      else if (opcode == MULT_EXPR)\n@@ -2007,16 +2083,16 @@ undistribute_bitref_for_vector (enum tree_code opcode,\n          BIT_FIELD_REF statements accordingly.  */\n       info_ptr = *(v_info_map.get (tvec));\n       gcc_assert (sum);\n-      tree elem_type = TREE_TYPE (TREE_TYPE (tvec));\n-      FOR_EACH_VEC_ELT (*info_ptr, j, elem)\n+      tree elem_type = TREE_TYPE (vec_type);\n+      FOR_EACH_VEC_ELT (info_ptr->vec, j, elem)\n \t{\n \t  idx = elem->second;\n \t  tree dst = make_ssa_name (elem_type);\n-\t  gimple *gs = gimple_build_assign (\n-\t    dst, BIT_FIELD_REF,\n-\t    build3 (BIT_FIELD_REF, elem_type, sum_vec, TYPE_SIZE (elem_type),\n-\t\t    bitsize_int (elem->first\n-\t\t\t\t * tree_to_uhwi (TYPE_SIZE (elem_type)))));\n+\t  tree pos = bitsize_int (elem->first\n+\t\t\t\t  * tree_to_uhwi (TYPE_SIZE (elem_type)));\n+\t  tree bfr = build3 (BIT_FIELD_REF, elem_type, sum_vec,\n+\t\t\t     TYPE_SIZE (elem_type), pos);\n+\t  gimple *gs = gimple_build_assign (dst, BIT_FIELD_REF, bfr);\n \t  insert_stmt_after (gs, sum);\n \t  gimple *def = SSA_NAME_DEF_STMT ((*ops)[idx]->op);\n \t  /* Set this then op definition will get DCEd later.  */"}]}