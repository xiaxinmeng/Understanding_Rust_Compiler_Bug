{"sha": "c0e3f87d491b3a0e99cfc95717753d130006dfd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBlM2Y4N2Q0OTFiM2EwZTk5Y2ZjOTU3MTc3NTNkMTMwMDA2ZGZkNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2000-11-10T00:07:52Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-11-10T00:07:52Z"}, "message": "recog.c (validate_replace_rtx_1): Consider subregs when replacing a register with a constant inside a...\n\n        * recog.c (validate_replace_rtx_1): Consider subregs when\n        replacing a register with a constant inside a sign/zero_extend.\n\nFrom-SVN: r37352", "tree": {"sha": "81000bdb8af0934c8ad62ab5fc920b9abf37512e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81000bdb8af0934c8ad62ab5fc920b9abf37512e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0e3f87d491b3a0e99cfc95717753d130006dfd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e3f87d491b3a0e99cfc95717753d130006dfd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0e3f87d491b3a0e99cfc95717753d130006dfd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e3f87d491b3a0e99cfc95717753d130006dfd7/comments", "author": null, "committer": null, "parents": [{"sha": "662f340b8118ce91205c91d73729a5f2f7684f80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/662f340b8118ce91205c91d73729a5f2f7684f80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/662f340b8118ce91205c91d73729a5f2f7684f80"}], "stats": {"total": 30, "additions": 24, "deletions": 6}, "files": [{"sha": "d8dde6af720a5b7dca50ebe922328296c07c1f02", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e3f87d491b3a0e99cfc95717753d130006dfd7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e3f87d491b3a0e99cfc95717753d130006dfd7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0e3f87d491b3a0e99cfc95717753d130006dfd7", "patch": "@@ -1,5 +1,8 @@\n 2000-11-09  Richard Henderson  <rth@redhat.com>\n \n+\t* recog.c (validate_replace_rtx_1): Consider subregs when\n+\treplacing a register with a constant inside a sign/zero_extend.\n+\n \t* config/alpha/linux.h (HANDLE_PRAGMA_PACK_PUSH_POP): Define.\n \n 2000-11-09  Geoffrey Keating  <geoffk@redhat.com>"}, {"sha": "c01f884ebb4fdb9d4c113cdee048f3a949a5e4d9", "filename": "gcc/recog.c", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e3f87d491b3a0e99cfc95717753d130006dfd7/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e3f87d491b3a0e99cfc95717753d130006dfd7/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=c0e3f87d491b3a0e99cfc95717753d130006dfd7", "patch": "@@ -480,14 +480,29 @@ validate_replace_rtx_1 (loc, from, to, object)\n       /* In these cases, the operation to be performed depends on the mode\n \t of the operand.  If we are replacing the operand with a VOIDmode\n \t constant, we lose the information.  So try to simplify the operation\n-\t in that case.  If it fails, substitute in something that we know\n-\t won't be recognized.  */\n+\t in that case.  */\n       if (GET_MODE (to) == VOIDmode\n-\t  && rtx_equal_p (XEXP (x, 0), from))\n+\t  && (rtx_equal_p (XEXP (x, 0), from)\n+\t      || (GET_CODE (XEXP (x, 0)) == SUBREG\n+\t\t  && rtx_equal_p (SUBREG_REG (XEXP (x, 0)), from))))\n \t{\n-\t  rtx new = simplify_unary_operation (code, GET_MODE (x), to,\n-\t\t\t\t\t      GET_MODE (from));\n-\t  if (new == 0)\n+\t  rtx new = NULL_RTX;\n+\n+\t  /* If there is a subreg involved, crop to the portion of the\n+\t     constant that we are interested in.  */\n+\t  if (GET_CODE (XEXP (x, 0)) == SUBREG)\n+\t    to = operand_subword (to, SUBREG_WORD (XEXP (x, 0)),\n+\t\t\t\t  0, GET_MODE (from));\n+\n+\t  /* If the above didn't fail, perform the extension from the\n+\t     mode of the operand (and not the mode of FROM).  */\n+\t  if (to)\n+\t    new = simplify_unary_operation (code, GET_MODE (x), to,\n+\t\t\t\t\t    GET_MODE (XEXP (x, 0)));\n+\n+\t  /* If any of the above failed, substitute in something that\n+\t     we know won't be recognized.  */\n+\t  if (!new)\n \t    new = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n \n \t  validate_change (object, loc, new, 1);"}]}