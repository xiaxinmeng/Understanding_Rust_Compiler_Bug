{"sha": "258bd1d63aec54899b12269325eca9712d61adfe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU4YmQxZDYzYWVjNTQ4OTliMTIyNjkzMjVlY2E5NzEyZDYxYWRmZQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-02-05T14:45:00Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-02-05T14:45:00Z"}, "message": "PR libstdc++/89130 restore support for non-MoveConstructible types\n\nThe changes to \"relocate\" std::vector elements can lead to new errors\noutside the immediate context, because moving the elements to new\nstorage no longer makes use of the move-if-noexcept utilities. This\nmeans that types with deleted moves no longer degenerate to copies, but\nare just ill-formed. The errors happen while instantiating the\nnoexcept-specifier for __relocate_object_a, when deciding whether to try\nto relocate.\n\nThis patch introduces indirections to avoid the ill-formed\ninstantiations of std::__relocate_object_a. In order to avoid using\nif-constexpr prior to C++17 this is done by tag dispatching. After this\npatch all uses of std::__relocate_a are guarded by checks that will\nsupport sensible code (i.e. code not using custom allocators that fool\nthe new checks).\n\n\tPR libstdc++/89130\n\t* include/bits/alloc_traits.h (__is_copy_insertable_impl): Rename to\n\t__is_alloc_insertable_impl. Replace single type member with two\n\tmembers, one for each of copy and move insertable.\n\t(__is_move_insertable): New trait for internal use.\n\t* include/bits/stl_vector.h (vector::_S_nothrow_relocate(true_type))\n\t(vector::_S_nothrow_relocate(true_type)): New functions to\n\tconditionally check if __relocate_a can throw.\n\t(vector::_S_use_relocate()): Dispatch to _S_nothrow_relocate based\n\ton __is_move_insertable.\n\t(vector::_S_do_relocate): New overloaded functions to conditionally\n\tcall __relocate_a.\n\t(vector::_S_relocate): New function that dispatches to _S_do_relocate\n\tbased on _S_use_relocate.\n\t* include/bits/vector.tcc (vector::reserve, vector::_M_realloc_insert)\n\t(vector::_M_default_append): Call _S_relocate instead of __relocate_a.\n\t* testsuite/23_containers/vector/modifiers/push_back/89130.cc: New.\n\nFrom-SVN: r268537", "tree": {"sha": "65711f6c5705ba57805df0b0ef11d57f6b05f11b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65711f6c5705ba57805df0b0ef11d57f6b05f11b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/258bd1d63aec54899b12269325eca9712d61adfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/258bd1d63aec54899b12269325eca9712d61adfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/258bd1d63aec54899b12269325eca9712d61adfe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/258bd1d63aec54899b12269325eca9712d61adfe/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2781287255a16b6f2db18c68d02c3f40004332a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2781287255a16b6f2db18c68d02c3f40004332a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2781287255a16b6f2db18c68d02c3f40004332a7"}], "stats": {"total": 169, "additions": 146, "deletions": 23}, "files": [{"sha": "5a94e8027de2bac2af22690571f3907a45a6c9f2", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258bd1d63aec54899b12269325eca9712d61adfe/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258bd1d63aec54899b12269325eca9712d61adfe/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=258bd1d63aec54899b12269325eca9712d61adfe", "patch": "@@ -1,5 +1,23 @@\n 2019-02-05  Jonathan Wakely  <jwakely@redhat.com>\n \n+\tPR libstdc++/89130\n+\t* include/bits/alloc_traits.h (__is_copy_insertable_impl): Rename to\n+\t__is_alloc_insertable_impl. Replace single type member with two\n+\tmembers, one for each of copy and move insertable.\n+\t(__is_move_insertable): New trait for internal use.\n+\t* include/bits/stl_vector.h (vector::_S_nothrow_relocate(true_type))\n+\t(vector::_S_nothrow_relocate(true_type)): New functions to\n+\tconditionally check if __relocate_a can throw.\n+\t(vector::_S_use_relocate()): Dispatch to _S_nothrow_relocate based\n+\ton __is_move_insertable.\n+\t(vector::_S_do_relocate): New overloaded functions to conditionally\n+\tcall __relocate_a.\n+\t(vector::_S_relocate): New function that dispatches to _S_do_relocate\n+\tbased on _S_use_relocate.\n+\t* include/bits/vector.tcc (vector::reserve, vector::_M_realloc_insert)\n+\t(vector::_M_default_append): Call _S_relocate instead of __relocate_a.\n+\t* testsuite/23_containers/vector/modifiers/push_back/89130.cc: New.\n+\n \tPR libstdc++/89090\n \t* include/bits/stl_uninitialized.h (__relocate_a_1): Make unused\n \tparameter unnamed. Add message to static assertion."}, {"sha": "3b0c16fbf64e5bca974484a84c94272bbcff8c24", "filename": "libstdc++-v3/include/bits/alloc_traits.h", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258bd1d63aec54899b12269325eca9712d61adfe/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258bd1d63aec54899b12269325eca9712d61adfe/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h?ref=258bd1d63aec54899b12269325eca9712d61adfe", "patch": "@@ -577,14 +577,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Alloc>\n-    class __is_copy_insertable_impl\n+    class __is_alloc_insertable_impl\n     {\n-      typedef allocator_traits<_Alloc> _Traits;\n+      using _Traits = allocator_traits<_Alloc>;\n+      using value_type = typename _Traits::value_type;\n \n-      template<typename _Up, typename\n+      template<typename _Up, typename _Tp = __remove_cvref_t<_Up>,\n+\t       typename\n \t       = decltype(_Traits::construct(std::declval<_Alloc&>(),\n-\t\t\t\t\t     std::declval<_Up*>(),\n-\t\t\t\t\t     std::declval<const _Up&>()))>\n+\t\t\t\t\t     std::declval<_Tp*>(),\n+\t\t\t\t\t     std::declval<_Up>()))>\n \tstatic true_type\n \t_M_select(int);\n \n@@ -593,13 +595,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_M_select(...);\n \n     public:\n-      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;\n+      using copy = decltype(_M_select<const value_type&>(0));\n+      using move = decltype(_M_select<value_type>(0));\n     };\n \n   // true if _Alloc::value_type is CopyInsertable into containers using _Alloc\n   template<typename _Alloc>\n     struct __is_copy_insertable\n-    : __is_copy_insertable_impl<_Alloc>::type\n+    : __is_alloc_insertable_impl<_Alloc>::copy\n     { };\n \n   // std::allocator<_Tp> just requires CopyConstructible\n@@ -608,6 +611,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : is_copy_constructible<_Tp>\n     { };\n \n+  // true if _Alloc::value_type is MoveInsertable into containers using _Alloc\n+  template<typename _Alloc>\n+    struct __is_move_insertable\n+    : __is_alloc_insertable_impl<_Alloc>::move\n+    { };\n+\n+  // std::allocator<_Tp> just requires MoveConstructible\n+  template<typename _Tp>\n+    struct __is_move_insertable<allocator<_Tp>>\n+    : is_move_constructible<_Tp>\n+    { };\n+\n   // Trait to detect Allocator-like types.\n   template<typename _Alloc, typename = void>\n     struct __is_allocator : false_type { };"}, {"sha": "10bf4fac62ed6e5c23fb9c2663f372082600bfe5", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258bd1d63aec54899b12269325eca9712d61adfe/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258bd1d63aec54899b12269325eca9712d61adfe/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=258bd1d63aec54899b12269325eca9712d61adfe", "patch": "@@ -425,14 +425,47 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     private:\n #if __cplusplus >= 201103L\n       static constexpr bool\n-      _S_use_relocate()\n+      _S_nothrow_relocate(true_type)\n       {\n \treturn noexcept(std::__relocate_a(std::declval<pointer>(),\n \t\t\t\t\t  std::declval<pointer>(),\n \t\t\t\t\t  std::declval<pointer>(),\n \t\t\t\t\t  std::declval<_Tp_alloc_type&>()));\n       }\n-#endif\n+\n+      static constexpr bool\n+      _S_nothrow_relocate(false_type)\n+      { return false; }\n+\n+      static constexpr bool\n+      _S_use_relocate()\n+      {\n+\t// Instantiating std::__relocate_a might cause an error outside the\n+\t// immediate context (in __relocate_object_a's noexcept-specifier),\n+\t// so only do it if we know the type can be move-inserted into *this.\n+\treturn _S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{});\n+      }\n+\n+      static pointer\n+      _S_do_relocate(pointer __first, pointer __last, pointer __result,\n+\t\t     _Tp_alloc_type& __alloc, true_type) noexcept\n+      {\n+\treturn std::__relocate_a(__first, __last, __result, __alloc);\n+      }\n+\n+      static pointer\n+      _S_do_relocate(pointer, pointer, pointer __result,\n+\t\t     _Tp_alloc_type&, false_type) noexcept\n+      { return __result; }\n+\n+      static pointer\n+      _S_relocate(pointer __first, pointer __last, pointer __result,\n+\t\t  _Tp_alloc_type& __alloc) noexcept\n+      {\n+\tusing __do_it = __bool_constant<_S_use_relocate()>;\n+\treturn _S_do_relocate(__first, __last, __result, __alloc, __do_it{});\n+      }\n+#endif // C++11\n \n     protected:\n       using _Base::_M_allocate;"}, {"sha": "497d9f72247e0257dd02a3b2e0582300ef9274cc", "filename": "libstdc++-v3/include/bits/vector.tcc", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258bd1d63aec54899b12269325eca9712d61adfe/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258bd1d63aec54899b12269325eca9712d61adfe/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc?ref=258bd1d63aec54899b12269325eca9712d61adfe", "patch": "@@ -76,9 +76,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  if _GLIBCXX17_CONSTEXPR (_S_use_relocate())\n \t    {\n \t      __tmp = this->_M_allocate(__n);\n-\t      std::__relocate_a(this->_M_impl._M_start,\n-\t\t\t\tthis->_M_impl._M_finish,\n-\t\t\t\t__tmp, _M_get_Tp_allocator());\n+\t      _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,\n+\t\t\t  __tmp, _M_get_Tp_allocator());\n \t    }\n \t  else\n #endif\n@@ -459,17 +458,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #if __cplusplus >= 201103L\n \t  if _GLIBCXX17_CONSTEXPR (_S_use_relocate())\n \t    {\n-\t      __new_finish\n-\t\t= std::__relocate_a\n-\t\t(__old_start, __position.base(),\n-\t\t __new_start, _M_get_Tp_allocator());\n+\t      __new_finish = _S_relocate(__old_start, __position.base(),\n+\t\t\t\t\t __new_start, _M_get_Tp_allocator());\n \n \t      ++__new_finish;\n \n-\t      __new_finish\n-\t\t= std::__relocate_a\n-\t\t(__position.base(), __old_finish,\n-\t\t __new_finish, _M_get_Tp_allocator());\n+\t      __new_finish = _S_relocate(__position.base(), __old_finish,\n+\t\t\t\t\t __new_finish, _M_get_Tp_allocator());\n \t    }\n \t  else\n #endif\n@@ -650,9 +645,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t      _M_deallocate(__new_start, __len);\n \t\t      __throw_exception_again;\n \t\t    }\n-\t\t  std::__relocate_a(this->_M_impl._M_start,\n-\t\t\t\t    this->_M_impl._M_finish,\n-\t\t\t\t    __new_start, _M_get_Tp_allocator());\n+\t\t  _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,\n+\t\t\t      __new_start, _M_get_Tp_allocator());\n \t\t}\n \t      else\n \t\t{"}, {"sha": "54b3f53069bcb654d15ac7e9b1e4530bb35d94a6", "filename": "libstdc++-v3/testsuite/23_containers/vector/modifiers/push_back/89130.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258bd1d63aec54899b12269325eca9712d61adfe/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fpush_back%2F89130.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258bd1d63aec54899b12269325eca9712d61adfe/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fpush_back%2F89130.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fpush_back%2F89130.cc?ref=258bd1d63aec54899b12269325eca9712d61adfe", "patch": "@@ -0,0 +1,63 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <vector>\n+\n+struct T\n+{\n+  T() { }\n+  T(const T&) { }\n+  T(T&&) = delete;  // this means T is not MoveInsertable into std::vector<T>\n+};\n+\n+void f()\n+{\n+  const T val;\n+  std::vector<T> x;\n+  // push_back(const T&) only requires T is CopyInsertable into std::vector<T>:\n+  x.push_back(val);\n+}\n+\n+template<typename U>\n+struct Alloc\n+{\n+  using value_type = U;\n+  Alloc() = default;\n+  Alloc(const Alloc&) = default;\n+  template<typename U2>\n+    Alloc(const Alloc<U2>&) { }\n+\n+  U* allocate(unsigned n) { return std::allocator<U>().allocate(n); }\n+  void deallocate(U* p, unsigned n) { std::allocator<U>().deallocate(p, n); }\n+\n+  void construct(Alloc*, U* p, U&& u)\n+  {\n+    // construct from const lvalue instead of rvalue:\n+    ::new(p) U(const_cast<const U&>(u));\n+  }\n+};\n+\n+void g()\n+{\n+  const T val;\n+  std::vector<T, Alloc<T>> x;\n+  // push_back(const T&) only requires T is CopyInsertable into std::vector<T>:\n+  x.push_back(val);\n+}"}]}