{"sha": "72332337e3d8acbb21398b8d123f1bfe77a8327e", "node_id": "C_kwDOANBUbNoAKDcyMzMyMzM3ZTNkOGFjYmIyMTM5OGI4ZDEyM2YxYmZlNzdhODMyN2U", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2022-01-14T18:13:08Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2022-01-14T18:13:08Z"}, "message": "Use enclosing object size if it's smaller than member [PR 101475].\n\nResolves:\nPR middle-end/101475 - missing -Wstringop-overflow storing a compound literal\n\ngcc/ChangeLog:\n\n\tPR middle-end/101475\n\t* pointer-query.cc (handle_component_ref): Use the size of\n\tthe enclosing object if it's smaller than the member.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/101475\n\t* gcc.dg/Wstringop-overflow-15.c: Remove xfails.\n\t* gcc.dg/Wstringop-overflow-68.c: Adjust, remove xfails.\n\t* gcc.dg/Wstringop-overflow-88.c: New test.", "tree": {"sha": "94b31c445e4d8804a4bd5e3abc3b2d63fec14e82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94b31c445e4d8804a4bd5e3abc3b2d63fec14e82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72332337e3d8acbb21398b8d123f1bfe77a8327e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72332337e3d8acbb21398b8d123f1bfe77a8327e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72332337e3d8acbb21398b8d123f1bfe77a8327e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72332337e3d8acbb21398b8d123f1bfe77a8327e/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e6294bb15d2169147c7838f89a9168980b94b47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e6294bb15d2169147c7838f89a9168980b94b47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e6294bb15d2169147c7838f89a9168980b94b47"}], "stats": {"total": 418, "additions": 383, "deletions": 35}, "files": [{"sha": "9f932e9e7630eb34fcdd05aef156830fc5ff3fc8", "filename": "gcc/pointer-query.cc", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72332337e3d8acbb21398b8d123f1bfe77a8327e/gcc%2Fpointer-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72332337e3d8acbb21398b8d123f1bfe77a8327e/gcc%2Fpointer-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.cc?ref=72332337e3d8acbb21398b8d123f1bfe77a8327e", "patch": "@@ -1914,36 +1914,41 @@ handle_component_ref (tree cref, gimple *stmt, bool addr, int ostype,\n   gcc_assert (TREE_CODE (cref) == COMPONENT_REF);\n \n   const tree base = TREE_OPERAND (cref, 0);\n+  const tree field = TREE_OPERAND (cref, 1);\n+  access_ref base_ref = *pref;\n+\n+  /* Unconditionally determine the size of the base object (it could\n+     be smaller than the referenced member when the object is stored\n+     in a buffer with an insufficient size).  */\n+  if (!compute_objsize_r (base, stmt, addr, 0, &base_ref, snlim, qry))\n+    return false;\n+\n+  /* Add the offset of the member to the offset into the object computed\n+     so far.  */\n+  tree offset = byte_position (field);\n+  if (TREE_CODE (offset) == INTEGER_CST)\n+    base_ref.add_offset (wi::to_offset (offset));\n+  else\n+    base_ref.add_max_offset ();\n+\n+  if (!base_ref.ref)\n+    /* PREF->REF may have been already set to an SSA_NAME earlier\n+       to provide better context for diagnostics.  In that case,\n+       leave it unchanged.  */\n+    base_ref.ref = base;\n+\n   const tree base_type = TREE_TYPE (base);\n   if (TREE_CODE (base_type) == UNION_TYPE)\n     /* In accesses through union types consider the entire unions\n        rather than just their members.  */\n     ostype = 0;\n \n-  tree field = TREE_OPERAND (cref, 1);\n-\n   if (ostype == 0)\n     {\n       /* In OSTYPE zero (for raw memory functions like memcpy), use\n \t the maximum size instead if the identity of the enclosing\n \t object cannot be determined.  */\n-      if (!compute_objsize_r (base, stmt, addr, ostype, pref, snlim, qry))\n-\treturn false;\n-\n-      /* Otherwise, use the size of the enclosing object and add\n-\t the offset of the member to the offset computed so far.  */\n-      tree offset = byte_position (field);\n-      if (TREE_CODE (offset) == INTEGER_CST)\n-\tpref->add_offset (wi::to_offset (offset));\n-      else\n-\tpref->add_max_offset ();\n-\n-      if (!pref->ref)\n-\t/* PREF->REF may have been already set to an SSA_NAME earlier\n-\t   to provide better context for diagnostics.  In that case,\n-\t   leave it unchanged.  */\n-\tpref->ref = base;\n-\n+      *pref = base_ref;\n       return true;\n     }\n \n@@ -1958,6 +1963,11 @@ handle_component_ref (tree cref, gimple *stmt, bool addr, int ostype,\n     }\n \n   set_component_ref_size (cref, pref);\n+\n+  if (base_ref.size_remaining () < pref->size_remaining ())\n+    /* Use the base object if it's smaller than the member.  */\n+    *pref = base_ref;\n+\n   return true;\n }\n "}, {"sha": "f7dcb94dc13180902d9cc3efe308e1a85dc9261d", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-15.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72332337e3d8acbb21398b8d123f1bfe77a8327e/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72332337e3d8acbb21398b8d123f1bfe77a8327e/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-15.c?ref=72332337e3d8acbb21398b8d123f1bfe77a8327e", "patch": "@@ -29,8 +29,13 @@ void vla_bounded (int n)\n \n   a[0] = 0;\n   a[1] = 1;\n+  a[31] = 31;\n+\n+  sink (&a);\n+\n   a[n] = n;         // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr82608\" { xfail *-*-* } }\n-  a[69] = n;        // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr82608\" }\n+  a[32] = 32;       // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr82608\" }\n+  a[69] = 69;       // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr82608\" }\n \n   sink (&a);\n }\n@@ -56,8 +61,13 @@ void member_vla_bounded (int n)\n \n   s.a[0] = 0;\n   s.a[1] = 1;\n+  s.a[31] = 31;\n+\n+  sink (&s);\n+\n   s.a[n] = n;       // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr82608\" { xfail *-*-* } }\n-  s.a[69] = n;      // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr82608\" { xfail *-*-* } }\n+  s.a[32] = 32;     // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr82608\" }\n+  s.a[69] = 69;     // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr82608\" }\n \n   sink (&s);\n }"}, {"sha": "4d132394f0fc7f411a59999fbf547c02997bdf73", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-68.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72332337e3d8acbb21398b8d123f1bfe77a8327e/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-68.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72332337e3d8acbb21398b8d123f1bfe77a8327e/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-68.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-68.c?ref=72332337e3d8acbb21398b8d123f1bfe77a8327e", "patch": "@@ -2,7 +2,7 @@\n    a larger scalar into a smaller array\n    Verify overflow by aggregate stores.\n    { dg-do compile }\n-   { dg-options \"-O2\" } */\n+   { dg-options \"-O2 -fno-tree-vectorize\" } */\n \n #define A(N) (A ## N)\n #define Ac1 (AC1){ 0 }\n@@ -57,19 +57,20 @@ void warn_comp_lit_zero (void)\n \n void warn_comp_lit (void)\n {\n-  *(AC2*)a1 = Ac2;      // { dg-warning \"writing 2 bytes into a region of size 1\" \"pr101475\" { target { vect_slp_v2qi_store_unalign } } }\n-  // After vectorization, below codes are optimized to\n-  // MEM <vector(4) char> [(char *)&a2] = { 0, 1, 2, 3 };\n-  // MEM <vector(4) char> [(char *)&a3] = { 0, 1, 2, 3 };\n-  // MEM <vector(8) char> [(char *)&a4] = { 0, 1, 2, 3, 4, 5, 6, 7 };\n-  // MEM <vector(8) char> [(char *)&a7] = { 0, 1, 2, 3, 4, 5, 6, 7 };\n-  // MEM <vector(16) char> [(char *)&a15] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n-  // and warning should be expected, refer to PR102722.\n-  *(AC4*)a2 = Ac4;      // { dg-warning \"writing 4 bytes into a region of size 2\" \"pr101475\" { xfail { ! { vect_slp_v4qi_store_unalign_1 } } } }\n-  *(AC4*)a3 = Ac4;      // { dg-warning \"writing 4 bytes into a region of size 3\" \"pr101475\" { xfail { ! { vect_slp_v4qi_store_unalign_1 } } } }\n-  *(AC8*)a4 = Ac8;      // { dg-warning \"writing 8 bytes into a region of size 4\" \"pr101475\" { xfail { ! { vect_slp_v8qi_store_unalign_1 } } } }\n-  *(AC8*)a7 = Ac8;      // { dg-warning \"writing 8 bytes into a region of size 7\" \"pr101475\" { xfail { ! { vect_slp_v8qi_store_unalign_1 } } } }\n-  *(AC16*)a15 = Ac16;   // { dg-warning \"writing 16 bytes into a region of size 15\" \"pr101475\" { xfail { ! { vect_slp_v16qi_store_unalign_1 } } } }\n+  /* Ideally only one warning would be issued for each of the stores\n+     mentioning the size of the rest of the source being assigned to\n+     the destination that doesn't fit.  But without vectorization\n+     the assignment is a series of one-character stores, except in\n+     the first instance multiple warnings end up being issued for\n+     each assignment, each saying \"writing 1 byte into a region of\n+     size 0\".  That's suboptimal and should be improved.  See also\n+     PR 92110.  */\n+  *(AC2*)a1 = Ac2;      // { dg-warning \"writing (2 bytes|1 byte) into a region of size (1|0)\" \"pr101475\" }\n+  *(AC4*)a2 = Ac4;      // { dg-warning \"writing (4 bytes|1 byte) into a region of size (2|0)\" \"pr101475\" }\n+  *(AC4*)a3 = Ac4;      // { dg-warning \"writing (4 bytes|1 byte) into a region of size (3|0)\" \"pr101475\" }\n+  *(AC8*)a4 = Ac8;      // { dg-warning \"writing (8 bytes|1 byte) into a region of size (4|0)\" \"pr101475\" }\n+  *(AC8*)a7 = Ac8;      // { dg-warning \"writing (8 bytes|1 byte) into a region of size (7|0)\" \"pr101475\" }\n+  *(AC16*)a15 = Ac16;   // { dg-warning \"writing (16 bytes|1 byte) into a region of size (15|0)\" \"pr101475\" }\n }\n \n void warn_aggr_decl (void)"}, {"sha": "c6b443e4d3db2785342690cd49abcd7c653247c5", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-88.c", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72332337e3d8acbb21398b8d123f1bfe77a8327e/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-88.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72332337e3d8acbb21398b8d123f1bfe77a8327e/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-88.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-88.c?ref=72332337e3d8acbb21398b8d123f1bfe77a8327e", "patch": "@@ -0,0 +1,327 @@\n+/* PR middle-end/101475 - missing -Wstringop-overflow storing a compound\n+   literal\n+   { dg-do compile }\n+   { dg-options \"-O2 -fno-tree-vectorize\" } */\n+\n+extern char ea1[1], ea2[2], ea3[3], ea4[4];\n+\n+/* The trailing A member of all of Sx, S0, and S1 is treated the same:\n+   as a flexible array member.  */\n+struct Sx { char n, a[]; };\n+struct S0 { char n, a[0]; };\n+struct S1 { char n, a[1]; };\n+/* The trailing A member in both S2 and S3 is treated as an ordinary\n+   array with exactly two elements and accesses to elements beyond\n+   the last are diagnosed regardless of whether they are within\n+   the bounds the enclosing object.  */\n+struct S2 { char n, a[2]; };\n+struct S3 { char n, a[3]; };\n+\n+\n+void fx_ea1 (void)\n+{\n+  struct Sx *p = (struct Sx*)ea1;\n+  p->n = 0;\n+  p->a[0] = 0;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f0_ea1 (void)\n+{\n+  struct S0 *p = (struct S0*)ea1;\n+  p->n = 0;\n+  p->a[0] = 0;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f1_ea1 (void)\n+{\n+  struct S1 *p = (struct S1*)ea1;\n+  p->n = 0;\n+  p->a[0] = 0;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f2_ea1 (void)\n+{\n+  struct S2 *p = (struct S2*)ea1;\n+  p->n = 0;\n+  p->a[0] = 0;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f3_ea1 (void)\n+{\n+  struct S3 *p = (struct S3*)ea1;\n+  p->n = 0;\n+  p->a[0] = 0;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+\n+void fx_ea1_p1 (void)\n+{\n+  struct Sx *p = (struct Sx*)(ea1 + 1);\n+  p->n = 0;         // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[0] = 0;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f0_ea1_p1 (void)\n+{\n+  struct S0 *p = (struct S0*)(ea1 + 1);\n+  p->n = 0;         // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[0] = 0;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f1_ea1_p1 (void)\n+{\n+  struct S1 *p = (struct S1*)(ea1 + 1);\n+  p->n = 0;         // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[0] = 0;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f2_ea1_p1 (void)\n+{\n+  struct S2 *p = (struct S2*)(ea1 + 1);\n+  p->n = 0;         // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[0] = 0;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f3_ea1_p1 (void)\n+{\n+  struct S3 *p = (struct S3*)(ea1 + 1);\n+  p->n = 0;         // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[0] = 0;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+\n+void fx_ea2 (void)\n+{\n+  struct Sx *p = (struct Sx*)ea2;\n+  p->n = 0;\n+  p->a[0] = 0;\n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f0_ea2 (void)\n+{\n+  struct S0 *p = (struct S0*)ea2;\n+  p->n = 0;\n+  p->a[0] = 0;\n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f1_ea2 (void)\n+{\n+  struct S1 *p = (struct S1*)ea2;\n+  p->n = 0;\n+  p->a[0] = 0;\n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f2_ea2 (void)\n+{\n+  struct S2 *p = (struct S2*)ea2;\n+  p->n = 0;\n+  p->a[0] = 0;\n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f3_ea2 (void)\n+{\n+  struct S3 *p = (struct S3*)ea2;\n+  p->n = 0;\n+  p->a[0] = 0;\n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+\n+void fx_ea2_p1 (void)\n+{\n+  struct Sx *p = (struct Sx*)(ea2 + 1);\n+  p->n = 0;\n+  p->a[0] = 0;      // { dg-warning \"-Wstringop-overflow\" } \n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f0_ea2_p1 (void)\n+{\n+  struct S0 *p = (struct S0*)(ea2 + 1);\n+  p->n = 0;\n+  p->a[0] = 0;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f1_ea2_p1 (void)\n+{\n+  struct S1 *p = (struct S1*)(ea2 + 1);\n+  p->n = 0;\n+  p->a[0] = 0;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f2_ea2_p1 (void)\n+{\n+  struct S2 *p = (struct S2*)(ea2 + 1);\n+  p->n = 0;\n+  p->a[0] = 0;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f3_ea2_p1 (void)\n+{\n+  struct S3 *p = (struct S3*)(ea2 + 1);\n+  p->n = 0;\n+  p->a[0] = 0;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[1] = 1;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+\n+void fx_ea3 (void)\n+{\n+  struct Sx *p = (struct Sx*)ea3;\n+  p->n = 0;\n+  p->a[0] = 0;\n+  p->a[1] = 1;\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f0_ea3 (void)\n+{\n+  struct S0 *p = (struct S0*)ea3;\n+  p->n = 0;\n+  p->a[0] = 0;\n+  p->a[1] = 1;\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f1_ea3 (void)\n+{\n+  struct S1 *p = (struct S1*)ea3;\n+  p->n = 0;\n+  p->a[0] = 0;\n+  p->a[1] = 1;\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f2_ea3 (void)\n+{\n+  struct S2 *p = (struct S2*)ea3;\n+  p->n = 0;\n+  p->a[0] = 0;\n+  p->a[1] = 1;\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f3_ea3 (void)\n+{\n+  struct S3 *p = (struct S3*)ea3;\n+  p->n = 0;\n+  p->a[0] = 0;\n+  p->a[1] = 1;\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+\n+void fx_ea4 (void)\n+{\n+  struct Sx *p = (struct Sx*)ea4;\n+  p->n = 0;\n+  p->a[0] = 0;\n+  p->a[1] = 1;\n+  p->a[2] = 2;\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f0_ea4 (void)\n+{\n+  struct S0 *p = (struct S0*)ea4;\n+  p->n = 0;\n+  p->a[0] = 0;\n+  p->a[1] = 1;\n+  p->a[2] = 2;\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f1_ea4 (void)\n+{\n+  struct S1 *p = (struct S1*)ea4;\n+  p->n = 0;\n+  p->a[0] = 0;\n+  p->a[1] = 1;\n+  p->a[2] = 2;\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f2_ea4 (void)\n+{\n+  struct S2 *p = (struct S2*)ea4;\n+  p->n = 0;\n+  p->a[0] = 0;\n+  p->a[1] = 1;\n+  /* Even though the offset of p->a[2] is within the bounds of EA4\n+     the warning triggers because it only considers trailing arrays\n+     of at mnost one element as \"poor man's flexible arrays.\"  */\n+  p->a[2] = 2;      // { dg-warning \"-Wstringop-overflow\" }\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}\n+\n+void f3_ea4 (void)\n+{\n+  struct S3 *p = (struct S3*)ea4;\n+  p->n = 0;\n+  p->a[0] = 0;\n+  p->a[1] = 1;\n+  p->a[2] = 2;\n+  p->a[3] = 3;      // { dg-warning \"-Wstringop-overflow\" }\n+}"}]}