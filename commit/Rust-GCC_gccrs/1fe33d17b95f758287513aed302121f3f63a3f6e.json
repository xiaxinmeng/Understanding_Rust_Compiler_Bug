{"sha": "1fe33d17b95f758287513aed302121f3f63a3f6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZlMzNkMTdiOTVmNzU4Mjg3NTEzYWVkMzAyMTIxZjNmNjNhM2Y2ZQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-10-08T21:51:09Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-10-08T21:51:09Z"}, "message": "(unroll_loops): Set local_regno only if set_dominates_use returns true.\n\n(unroll_loops): Set local_regno only if set_dominates_use\nreturns true.\n(set_dominates_use): New function.\n\nFrom-SVN: r12917", "tree": {"sha": "3879e73b6776263cefc85d42042936c7b1086920", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3879e73b6776263cefc85d42042936c7b1086920"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fe33d17b95f758287513aed302121f3f63a3f6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fe33d17b95f758287513aed302121f3f63a3f6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fe33d17b95f758287513aed302121f3f63a3f6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fe33d17b95f758287513aed302121f3f63a3f6e/comments", "author": null, "committer": null, "parents": [{"sha": "a7c1916aeada1e930a54990b6d71d1cb7fa8715f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7c1916aeada1e930a54990b6d71d1cb7fa8715f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7c1916aeada1e930a54990b6d71d1cb7fa8715f"}], "stats": {"total": 85, "additions": 84, "deletions": 1}, "files": [{"sha": "a282be3d99146eac5c52864031c9b893282939b3", "filename": "gcc/unroll.c", "status": "modified", "additions": 84, "deletions": 1, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fe33d17b95f758287513aed302121f3f63a3f6e/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fe33d17b95f758287513aed302121f3f63a3f6e/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=1fe33d17b95f758287513aed302121f3f63a3f6e", "patch": "@@ -743,12 +743,37 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n     if (copy_start == loop_start)\n       copy_start_luid++;\n \n+    /* If a pseudo's lifetime is entirely contained within this loop, then we\n+       can use a different pseudo in each unrolled copy of the loop.  This\n+       results in better code.  */\n     for (j = FIRST_PSEUDO_REGISTER; j < max_reg_before_loop; ++j)\n       if (regno_first_uid[j] > 0 && regno_first_uid[j] <= max_uid_for_loop\n \t  && uid_luid[regno_first_uid[j]] >= copy_start_luid\n \t  && regno_last_uid[j] > 0 && regno_last_uid[j] <= max_uid_for_loop\n \t  && uid_luid[regno_last_uid[j]] <= copy_end_luid)\n-\tlocal_regno[j] = 1;\n+\t{\n+\t  /* However, we must also check for loop-carried dependencies.\n+\t     If the value the pseudo has at the end of iteration X is\n+\t     used by iteration X+1, then we can not use a different pseudo\n+\t     for each unrolled copy of the loop.  */\n+\t  /* A pseudo is safe if regno_first_uid is a set, and this\n+\t     set dominates all instructions from regno_first_uid to\n+\t     regno_last_uid.  */\n+\t  /* ??? This check is simplistic.  We would get better code if\n+\t     this check was more sophisticated.  */\n+\t  if (set_dominates_use (j, regno_first_uid[j], regno_last_uid[j],\n+\t\t\t\t copy_start, copy_end))\n+\t    local_regno[j] = 1;\n+\n+\t  if (loop_dump_stream)\n+\t    {\n+\t      if (local_regno[j])\n+\t\tfprintf (loop_dump_stream, \"Marked reg %d as local\\n\", j);\n+\t      else\n+\t\tfprintf (loop_dump_stream, \"Did not mark reg %d as local\\n\",\n+\t\t\t j);\n+\t    }\n+\t}\n   }\n \n   /* If this loop requires exit tests when unrolled, check to see if we\n@@ -3510,3 +3535,61 @@ remap_split_bivs (x)\n     }\n   return x;\n }\n+\n+/* If FIRST_UID is a set of REGNO, and FIRST_UID dominates LAST_UID (e.g.\n+   FIST_UID is always executed if LAST_UID is), then return 1.  Otherwise\n+   return 0.  COPY_START is where we can start looking for the insns\n+   FIRST_UID and LAST_UID.  COPY_END is where we stop looking for these\n+   insns.\n+\n+   If there is no JUMP_INSN between LOOP_START and FIRST_UID, then FIRST_UID\n+   must dominate LAST_UID.\n+\n+   If there is a CODE_LABEL between FIRST_UID and LAST_UID, then FIRST_UID\n+   may not dominate LAST_UID.\n+\n+   If there is no CODE_LABEL between FIRST_UID and LAST_UID, then FIRST_UID\n+   must dominate LAST_UID.  */\n+\n+int\n+set_dominates_use (regno, first_uid, last_uid, copy_start, copy_end)\n+     int regno;\n+     int first_uid;\n+     int last_uid;\n+     rtx copy_start;\n+     rtx copy_end;\n+{\n+  int passed_jump = 0;\n+  rtx p = NEXT_INSN (copy_start);\n+\n+  while (INSN_UID (p) != first_uid)\n+    {\n+      if (GET_CODE (p) == JUMP_INSN)\n+\tpassed_jump= 1;\n+      /* Could not find FIRST_UID.  */\n+      if (p == copy_end)\n+\treturn 0;\n+      p = NEXT_INSN (p);\n+    }\n+\n+  /* Verify that FIRST_UID is an insn that entirely sets REGNO.  */\n+  if (GET_RTX_CLASS (GET_CODE (p)) != 'i'\n+      || ! dead_or_set_regno_p (p, regno))\n+    return 0;\n+\n+  /* FIRST_UID is always executed.  */\n+  if (passed_jump == 0)\n+    return 1;\n+\n+  while (INSN_UID (p) != last_uid)\n+    {\n+      /* If we see a CODE_LABEL between FIRST_UID and LAST_UID, then we\n+\t can not be sure that FIRST_UID dominates LAST_UID.  */\n+      if (GET_CODE (p) == CODE_LABEL)\n+\treturn 0;\n+      p = NEXT_INSN (p);\n+    }\n+\n+  /* FIRST_UID is always executed if LAST_UID is executed.  */\n+  return 1;\n+}"}]}