{"sha": "1d65c9d25199264bc8909018df1b0dca71c0b32d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ2NWM5ZDI1MTk5MjY0YmM4OTA5MDE4ZGYxYjBkY2E3MWMwYjMyZA==", "commit": {"author": {"name": "Jonathan Wright", "email": "jonathan.wright@arm.com", "date": "2021-07-19T13:01:52Z"}, "committer": {"name": "Jonathan Wright", "email": "jonathan.wright@arm.com", "date": "2021-08-04T15:57:38Z"}, "message": "aarch64: Don't include vec_select element in SIMD multiply cost\n\nThe Neon multiply/multiply-accumulate/multiply-subtract instructions\ncan take various forms - multiplying full vector registers of values\nor multiplying one vector by a single element of another. Regardless\nof the form used, these instructions have the same cost, and this\nshould be reflected by the RTL cost function.\n\nThis patch adds RTL tree traversal in the Neon multiply cost function\nto match the vec_select used by the lane-referencing forms of the\ninstructions already mentioned. This traversal prevents the cost of\nthe vec_select from being added into the cost of the multiply -\nmeaning that these instructions can now be emitted in the combine\npass as they are no longer deemed prohibitively expensive.\n\ngcc/ChangeLog:\n\n2021-07-19  Jonathan Wright  <jonathan.wright@arm.com>\n\n\t* config/aarch64/aarch64.c (aarch64_strip_duplicate_vec_elt):\n\tDefine.\n\t(aarch64_rtx_mult_cost): Traverse RTL tree to prevent\n\tvec_select cost from being added into Neon multiply cost.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/aarch64/vmul_element_cost.c: New test.", "tree": {"sha": "72de3f5f492a0ae906d20706ccfe02e3e7131c83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72de3f5f492a0ae906d20706ccfe02e3e7131c83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d65c9d25199264bc8909018df1b0dca71c0b32d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d65c9d25199264bc8909018df1b0dca71c0b32d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d65c9d25199264bc8909018df1b0dca71c0b32d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d65c9d25199264bc8909018df1b0dca71c0b32d/comments", "author": {"login": "jwright-arm", "id": 31624044, "node_id": "MDQ6VXNlcjMxNjI0MDQ0", "avatar_url": "https://avatars.githubusercontent.com/u/31624044?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwright-arm", "html_url": "https://github.com/jwright-arm", "followers_url": "https://api.github.com/users/jwright-arm/followers", "following_url": "https://api.github.com/users/jwright-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jwright-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwright-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwright-arm/subscriptions", "organizations_url": "https://api.github.com/users/jwright-arm/orgs", "repos_url": "https://api.github.com/users/jwright-arm/repos", "events_url": "https://api.github.com/users/jwright-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jwright-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwright-arm", "id": 31624044, "node_id": "MDQ6VXNlcjMxNjI0MDQ0", "avatar_url": "https://avatars.githubusercontent.com/u/31624044?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwright-arm", "html_url": "https://github.com/jwright-arm", "followers_url": "https://api.github.com/users/jwright-arm/followers", "following_url": "https://api.github.com/users/jwright-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jwright-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwright-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwright-arm/subscriptions", "organizations_url": "https://api.github.com/users/jwright-arm/orgs", "repos_url": "https://api.github.com/users/jwright-arm/repos", "events_url": "https://api.github.com/users/jwright-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jwright-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a1017dc305c49c59129d45536630d02dbc01c45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a1017dc305c49c59129d45536630d02dbc01c45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a1017dc305c49c59129d45536630d02dbc01c45"}], "stats": {"total": 128, "additions": 119, "deletions": 9}, "files": [{"sha": "23829bb691c2f07cc6f895dba3d2b95eb9344c29", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65c9d25199264bc8909018df1b0dca71c0b32d/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65c9d25199264bc8909018df1b0dca71c0b32d/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=1d65c9d25199264bc8909018df1b0dca71c0b32d", "patch": "@@ -12046,6 +12046,26 @@ aarch64_strip_extend (rtx x, bool strip_shift)\n   return x;\n }\n \n+\n+/* Helper function for rtx cost calculation. Strip VEC_DUPLICATE as well as\n+   any subsequent extend and VEC_SELECT from X. Returns the inner scalar\n+   operand if successful, or the original expression on failure.  */\n+static rtx\n+aarch64_strip_duplicate_vec_elt (rtx x)\n+{\n+  if (GET_CODE (x) == VEC_DUPLICATE\n+      && is_a<scalar_mode> (GET_MODE (XEXP (x, 0))))\n+    {\n+      x = XEXP (x, 0);\n+      if (GET_CODE (x) == VEC_SELECT)\n+\tx = XEXP (x, 0);\n+      else if ((GET_CODE (x) == ZERO_EXTEND || GET_CODE (x) == SIGN_EXTEND)\n+\t       && GET_CODE (XEXP (x, 0)) == VEC_SELECT)\n+\tx = XEXP (XEXP (x, 0), 0);\n+    }\n+  return x;\n+}\n+\n /* Return true iff CODE is a shift supported in combination\n    with arithmetic instructions.  */\n \n@@ -12114,15 +12134,11 @@ aarch64_rtx_mult_cost (rtx x, enum rtx_code code, int outer, bool speed)\n       if (vec_flags & VEC_ADVSIMD)\n \t{\n \t  /* The by-element versions of the instruction have the same costs as\n-\t     the normal 3-vector version.  So don't add the costs of the\n-\t     duplicate into the costs of the multiply.  We make an assumption\n-\t     that the input to the VEC_DUPLICATE is already on the FP & SIMD\n-\t     side.  This means costing of a MUL by element pre RA is a bit\n-\t     optimistic.  */\n-\t  if (GET_CODE (op0) == VEC_DUPLICATE)\n-\t    op0 = XEXP (op0, 0);\n-\t  else if (GET_CODE (op1) == VEC_DUPLICATE)\n-\t    op1 = XEXP (op1, 0);\n+\t     the normal 3-vector version.  We make an assumption that the input\n+\t     to the VEC_DUPLICATE is already on the FP & SIMD side.  This means\n+\t     costing of a MUL by element pre RA is a bit optimistic.  */\n+\t  op0 = aarch64_strip_duplicate_vec_elt (op0);\n+\t  op1 = aarch64_strip_duplicate_vec_elt (op1);\n \t}\n       cost += rtx_cost (op0, mode, MULT, 0, speed);\n       cost += rtx_cost (op1, mode, MULT, 1, speed);"}, {"sha": "c153775f0914072fb985b18516f110aded7dccd5", "filename": "gcc/testsuite/gcc.target/aarch64/vmul_element_cost.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65c9d25199264bc8909018df1b0dca71c0b32d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvmul_element_cost.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65c9d25199264bc8909018df1b0dca71c0b32d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvmul_element_cost.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvmul_element_cost.c?ref=1d65c9d25199264bc8909018df1b0dca71c0b32d", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3\" } */\n+\n+#include <arm_neon.h>\n+\n+#define TEST_MUL_UNIFORM(name, q, vectype, ts) \\\n+  vectype test_ ## name ## q ## _ ## ts (vectype a, vectype b, vectype c) \\\n+\t{ \\\n+\t\tvectype t0 = name ## q ## _n_ ## ts (a, c[1]); \\\n+\t\tvectype t1 = name ## q ## _n_ ## ts (b, c[1]); \\\n+\t\treturn vmul ## q ## _ ## ts (t0, t1); \\\n+\t}\n+\n+TEST_MUL_UNIFORM (vmul, , int16x4_t, s16)\n+TEST_MUL_UNIFORM (vmul, , uint16x4_t, u16)\n+TEST_MUL_UNIFORM (vmul, , int32x2_t, s32)\n+TEST_MUL_UNIFORM (vmul, , uint32x2_t, u32)\n+TEST_MUL_UNIFORM (vmul, , float32x2_t, f32)\n+TEST_MUL_UNIFORM (vmul, q, int16x8_t, s16)\n+TEST_MUL_UNIFORM (vmul, q, uint16x8_t, u16)\n+TEST_MUL_UNIFORM (vmul, q, int32x4_t, s32)\n+TEST_MUL_UNIFORM (vmul, q, uint32x4_t, u32)\n+TEST_MUL_UNIFORM (vmul, q, float32x4_t, f32)\n+TEST_MUL_UNIFORM (vmul, q, float64x2_t, f64)\n+\n+#define TEST_MLX_UNIFORM(name, q, vectype, ts) \\\n+  vectype test_ ## name ## q ## _ ## ts (vectype acc, vectype a, vectype b) \\\n+\t{ \\\n+\t\tacc = name ## q ## _n_ ## ts (acc, a, b[1]); \\\n+\t\treturn name ## q ## _n_ ## ts (acc, a, b[1]); \\\n+\t}\n+\n+TEST_MLX_UNIFORM (vmla, , int16x4_t, s16)\n+TEST_MLX_UNIFORM (vmla, , uint16x4_t, u16)\n+TEST_MLX_UNIFORM (vmla, , int32x2_t, s32)\n+TEST_MLX_UNIFORM (vmla, , uint32x2_t, u32)\n+TEST_MLX_UNIFORM (vmla, , float32x2_t, f32)\n+TEST_MLX_UNIFORM (vmla, q, int16x8_t, s16)\n+TEST_MLX_UNIFORM (vmla, q, uint16x8_t, u16)\n+TEST_MLX_UNIFORM (vmla, q, int32x4_t, s32)\n+TEST_MLX_UNIFORM (vmla, q, uint32x4_t, u32)\n+TEST_MLX_UNIFORM (vmla, q, float32x4_t, f32)\n+\n+TEST_MLX_UNIFORM (vmls, , int16x4_t, s16)\n+TEST_MLX_UNIFORM (vmls, , uint16x4_t, u16)\n+TEST_MLX_UNIFORM (vmls, , int32x2_t, s32)\n+TEST_MLX_UNIFORM (vmls, , uint32x2_t, u32)\n+TEST_MLX_UNIFORM (vmls, , float32x2_t, f32)\n+TEST_MLX_UNIFORM (vmls, q, int16x8_t, s16)\n+TEST_MLX_UNIFORM (vmls, q, uint16x8_t, u16)\n+TEST_MLX_UNIFORM (vmls, q, int32x4_t, s32)\n+TEST_MLX_UNIFORM (vmls, q, uint32x4_t, u32)\n+TEST_MLX_UNIFORM (vmls, q, float32x4_t, f32)\n+\n+#define TEST_MUL_LONG(name, rettype, intype, ts, rs) \\\n+  rettype test_ ## name ## ts (intype a, intype b, intype c) \\\n+\t{ \\\n+\t\trettype t0 = name ## ts (a, c[1]); \\\n+\t\trettype t1 = name ## ts (b, c[1]); \\\n+\t\treturn vqaddq ## _ ## rs (t0, t1); \\\n+\t}\n+\n+TEST_MUL_LONG (vmull_n_, int32x4_t, int16x4_t, s16, s32)\n+TEST_MUL_LONG (vmull_n_, uint32x4_t, uint16x4_t, u16, u32)\n+TEST_MUL_LONG (vmull_n_, int64x2_t, int32x2_t, s32, s64)\n+TEST_MUL_LONG (vmull_n_, uint64x2_t, uint32x2_t, u32, u64)\n+\n+TEST_MUL_LONG (vqdmull_n_, int32x4_t, int16x4_t, s16, s32)\n+TEST_MUL_LONG (vqdmull_n_, int64x2_t, int32x2_t, s32, s64)\n+\n+#define TEST_MLX_LONG(name, rettype, intype, ts, rs) \\\n+  rettype test_ ## name ## _ ## ts (rettype acc, intype a, intype b) \\\n+\t{ \\\n+\t\tacc = name ## ts (acc, a, b[1]); \\\n+\t\treturn name ## ts (acc, a, b[1]); \\\n+\t}\n+\n+TEST_MLX_LONG (vmlal_n_, int32x4_t, int16x4_t, s16, s32)\n+TEST_MLX_LONG (vmlal_n_, uint32x4_t, uint16x4_t, u16, u32)\n+TEST_MLX_LONG (vmlal_n_, int64x2_t, int32x2_t, s32, s64)\n+TEST_MLX_LONG (vmlal_n_, uint64x2_t, uint32x2_t, u32, u64)\n+\n+TEST_MLX_LONG (vmlsl_n_, int32x4_t, int16x4_t, s16, s32)\n+TEST_MLX_LONG (vmlsl_n_, uint32x4_t, uint16x4_t, u16, u32)\n+TEST_MLX_LONG (vmlsl_n_, int64x2_t, int32x2_t, s32, s64)\n+TEST_MLX_LONG (vmlsl_n_, uint64x2_t, uint32x2_t, u32, u64)\n+\n+TEST_MLX_LONG (vqdmlal_n_, int32x4_t, int16x4_t, s16, s32)\n+TEST_MLX_LONG (vqdmlal_n_, int64x2_t, int32x2_t, s32, s64)\n+\n+TEST_MLX_LONG (vqdmlsl_n_, int32x4_t, int16x4_t, s16, s32)\n+TEST_MLX_LONG (vqdmlsl_n_, int64x2_t, int32x2_t, s32, s64)\n+\n+/* { dg-final { scan-assembler-not \"dup\\\\t\" } } */"}]}