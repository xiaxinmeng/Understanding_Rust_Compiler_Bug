{"sha": "a686dbf86a80b697e84a8ea9a8fa94b281796557", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY4NmRiZjg2YTgwYjY5N2U4NGE4ZWE5YThmYTk0YjI4MTc5NjU1Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-02-24T02:32:33Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-02-24T02:32:33Z"}, "message": "flow.c (find_sub_basic_blocks): New function.\n\n\t* flow.c (find_sub_basic_blocks): New function.\n\t(split_block): Be ready for basic block introduced by CODE_LABEL.\n\t(commit_one_edge_insertion): Call find_sub_basic_block.\n\n\t* flow.c (make_edges): Add edge from entry for blocks starting with\n\tlabel having ALTERNATE_NAME\n\nFrom-SVN: r40021", "tree": {"sha": "9e10ae00416afe83fe1b5cd358dc5d59f585dc67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e10ae00416afe83fe1b5cd358dc5d59f585dc67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a686dbf86a80b697e84a8ea9a8fa94b281796557", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a686dbf86a80b697e84a8ea9a8fa94b281796557", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a686dbf86a80b697e84a8ea9a8fa94b281796557", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a686dbf86a80b697e84a8ea9a8fa94b281796557/comments", "author": null, "committer": null, "parents": [{"sha": "016030fea6d929c69ce92ec45b797da303c09ab6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/016030fea6d929c69ce92ec45b797da303c09ab6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/016030fea6d929c69ce92ec45b797da303c09ab6"}], "stats": {"total": 135, "additions": 130, "deletions": 5}, "files": [{"sha": "d3f1da5600ff2e8a3fcfe37e0e730196e2ea127f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a686dbf86a80b697e84a8ea9a8fa94b281796557/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a686dbf86a80b697e84a8ea9a8fa94b281796557/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a686dbf86a80b697e84a8ea9a8fa94b281796557", "patch": "@@ -1,3 +1,12 @@\n+Sat Feb 24 03:30:38 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* flow.c (find_sub_basic_blocks): New function.\n+\t(split_block): Be ready for basic block introduced by CODE_LABEL.\n+\t(commit_one_edge_insertion): Call find_sub_basic_block.\n+\n+\t* flow.c (make_edges): Add edge from entry for blocks starting with\n+\tlabel having ALTERNATE_NAME\n+\n Sat Feb 24 03:19:42 CET 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* function.c (epilogue_done): Be ready for first basic block not"}, {"sha": "82e90174063ae6d4ab8239e875e23e2411c8e208", "filename": "gcc/flow.c", "status": "modified", "additions": 121, "deletions": 5, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a686dbf86a80b697e84a8ea9a8fa94b281796557/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a686dbf86a80b697e84a8ea9a8fa94b281796557/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=a686dbf86a80b697e84a8ea9a8fa94b281796557", "patch": "@@ -473,6 +473,7 @@ static void flow_loops_tree_build\tPARAMS ((struct loops *));\n static int flow_loop_level_compute\tPARAMS ((struct loop *, int));\n static int flow_loops_level_compute\tPARAMS ((struct loops *));\n static void allocate_bb_life_data\tPARAMS ((void));\n+static void find_sub_basic_blocks\tPARAMS ((basic_block));\n \f\n /* Find basic blocks of the current function.\n    F is the first insn of the function and NREGS the number of register\n@@ -697,6 +698,106 @@ find_label_refs (f, lvl)\n   return lvl;\n }\n \n+/* Assume that someone emitted code with control flow instructions to the\n+   basic block.  Update the data structure.  */\n+static void\n+find_sub_basic_blocks (bb)\n+     basic_block bb;\n+{\n+  rtx first_insn = bb->head, insn;\n+  rtx end = bb->end;\n+  edge succ_list = bb->succ;\n+  rtx jump_insn = NULL_RTX;\n+  int created = 0;\n+  int barrier = 0;\n+  edge falltru = 0;\n+  basic_block first_bb = bb, last_bb;\n+  int i;\n+\n+  if (GET_CODE (first_insn) == LABEL_REF)\n+    first_insn = NEXT_INSN (first_insn);\n+  first_insn = NEXT_INSN (first_insn);\n+  bb->succ = NULL;\n+\n+  insn = first_insn;\n+  /* Scan insn chain and try to find new basic block boundaries.  */\n+  while (insn != end)\n+    {\n+      enum rtx_code code = GET_CODE (insn);\n+      switch (code)\n+\t{\n+\tcase JUMP_INSN:\n+\t  /* We need some special care for those expressions.  */\n+\t  if (GET_CODE (PATTERN (insn)) == ADDR_VEC\n+\t      || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n+\t    abort();\n+\t  jump_insn = insn;\n+\t  break;\n+\tcase BARRIER:\n+\t  if (!jump_insn)\n+\t    abort ();\n+\t  barrier = 1;\n+\t  break;\n+\t/* On code label, split current basic block.  */\n+\tcase CODE_LABEL:\n+\t  falltru = split_block (bb, PREV_INSN (insn));\n+\t  if (jump_insn)\n+\t    bb->end = jump_insn;\n+\t  bb = falltru->dest;\n+\t  if (barrier)\n+\t    remove_edge (falltru);\n+\t  barrier = 0;\n+\t  jump_insn = 0;\n+\t  created = 1;\n+\t  if (LABEL_ALTERNATE_NAME (insn))\n+\t    make_edge (NULL, ENTRY_BLOCK_PTR, bb, 0);\n+\t  break;\n+\tcase INSN:\n+\t  /* In case we've previously split insn on the JUMP_INSN, move the\n+\t     block header to proper place.  */\n+\t  if (jump_insn)\n+\t    {\n+\t      falltru = split_block (bb, PREV_INSN (insn));\n+\t      bb->end = jump_insn;\n+\t      bb = falltru->dest;\n+\t      if (barrier)\n+\t\tabort ();\n+\t      jump_insn = 0;\n+\t    }\n+\tdefault:\n+\t  break;\n+\t}\n+      insn = NEXT_INSN (insn);\n+    }\n+  /* Last basic block must end in the original BB end.  */\n+  if (jump_insn)\n+    abort ();\n+\n+  /* Wire in the original edges for last basic block.  */\n+  if (created)\n+    {\n+      bb->succ = succ_list;\n+      while (succ_list)\n+\tsucc_list->src = bb, succ_list = succ_list->succ_next;\n+    }\n+  else\n+    bb->succ = succ_list;\n+\n+  /* Now re-scan and wire in all edges.  This expect simple (conditional)\n+     jumps at the end of each new basic blocks.  */\n+  last_bb = bb;\n+  for (i = first_bb->index; i < last_bb->index; i++)\n+    {\n+      bb = BASIC_BLOCK (i);\n+      if (GET_CODE (bb->end) == JUMP_INSN)\n+\t{\n+\t  mark_jump_label (PATTERN (bb->end), bb->end, 0, 0);\n+\t  make_label_edge (NULL, bb, JUMP_LABEL (bb->end), 0);\n+\t}\n+      insn = NEXT_INSN (insn);\n+    }\n+}\n+\n /* Find all basic blocks of the function whose first insn is F.\n \n    Collect and return a list of labels whose addresses are taken.  This\n@@ -1121,6 +1222,10 @@ make_edges (label_value_list)\n       enum rtx_code code;\n       int force_fallthru = 0;\n \n+      if (GET_CODE (bb->head) == CODE_LABEL\n+\t  && LABEL_ALTERNATE_NAME (bb->head))\n+\tmake_edge (NULL, ENTRY_BLOCK_PTR, bb, 0);\n+\n       /* Examine the last instruction of the block, and discover the\n \t ways we can leave the block.  */\n \n@@ -1589,11 +1694,21 @@ split_block (bb, insn)\n   BASIC_BLOCK (i) = new_bb;\n   new_bb->index = i;\n \n-  /* Create the basic block note.  */\n-  bb_note = emit_note_before (NOTE_INSN_BASIC_BLOCK,\n-\t\t\t      new_bb->head);\n-  NOTE_BASIC_BLOCK (bb_note) = new_bb;\n-  new_bb->head = bb_note;\n+  if (GET_CODE (new_bb->head) == CODE_LABEL)\n+    {\n+      /* Create the basic block note.  */\n+      bb_note = emit_note_after (NOTE_INSN_BASIC_BLOCK,\n+\t\t\t\t new_bb->head);\n+      NOTE_BASIC_BLOCK (bb_note) = new_bb;\n+    }\n+  else\n+    {\n+      /* Create the basic block note.  */\n+      bb_note = emit_note_before (NOTE_INSN_BASIC_BLOCK,\n+\t\t\t\t  new_bb->head);\n+      NOTE_BASIC_BLOCK (bb_note) = new_bb;\n+      new_bb->head = bb_note;\n+    }\n \n   update_bb_for_insn (new_bb);\n \n@@ -1995,6 +2110,7 @@ commit_one_edge_insertion (e)\n     }\n   else if (GET_CODE (last) == JUMP_INSN)\n     abort ();\n+  find_sub_basic_blocks (bb);\n }\n \n /* Update the CFG for all queued instructions.  */"}]}