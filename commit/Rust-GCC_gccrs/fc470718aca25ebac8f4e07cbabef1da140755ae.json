{"sha": "fc470718aca25ebac8f4e07cbabef1da140755ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM0NzA3MThhY2EyNWViYWM4ZjRlMDdjYmFiZWYxZGExNDA3NTVhZQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-03-02T11:54:35Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-03-02T11:54:35Z"}, "message": "final.c (insn_last_address, [...]): New variables.\n\n\t* final.c (insn_last_address, insn_current_align, uid_align):\n\tNew variables.\n\t(in_align_chain, align_fuzz, align_shrink_fuzz): New functions.\n\t(insn_current_reference_address): Likewise.\n\t(shorten_branches, final_scan_insn): Implement LABEL_ALIGN,\n\tLABEL_ALIGN_AFTER_BARRIER and LOOP_ALIGN target macros.\n\t(label_to_alignment): New function.\n\t* genattrtab.c (write_test_expr): If one of LABEL_ALIGN,\n\tLABEL_ALIGN_AFTER_BARRIER or LOOP_ALIGN is defined, call\n\tinsn_current_reference_address instead of insn_current_address.\n\t(or_attr_value, write_length_unit_log): New functions.\n\t(main): Call write_length_unit_log.\n\t(write_const_num_delay_slots): Output extra '\\n'.\n\t* alpha.h (ASM_OUTPUT_LOOP_ALIGN, ASM_OUTPUT_ALIGN_CODE):\n\treplace with:\n\t(LOOP_ALIGN, ALIGN_LABEL_AFTER_BARRIER).\n\t* i386.h, i386/osfrose.h, i386/svr3dbx.h, m68k.h, sparc.h: Likewise.\n\t* arc.h, m32r.h (ASM_OUTPUT_LOOP_ALIGN): replace with:\n\t(LOOP_ALIGN).\n\t* i960.h, m88k.h: (ASM_OUTPUT_ALIGN_CODE): Replace with:\n\t(LABEL_ALIGN_AFTER_BARRIER).\n\t* ns32k/encore.h, ns32k/merlin.h, ns32k.h, ns32k/sequent.h: Likewise.\n\t* ns32k/tek6000.h: Likewise.\n\t* i386/gas.h (ASM_OUTPUT_LOOP_ALIGN, ASM_OUTPUT_ALIGN_CODE): Delete.\n\t* i386.md (casesi+1): Use ASM_OUTPUT_ALIGN instead of\n\tASM_OUTPUT_ALIGN_CODE.\n\nFrom-SVN: r18357", "tree": {"sha": "9ba9228d811fc5a7f85644b346c78cc487723653", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ba9228d811fc5a7f85644b346c78cc487723653"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc470718aca25ebac8f4e07cbabef1da140755ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc470718aca25ebac8f4e07cbabef1da140755ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc470718aca25ebac8f4e07cbabef1da140755ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc470718aca25ebac8f4e07cbabef1da140755ae/comments", "author": null, "committer": null, "parents": [{"sha": "948edfa70264176018542bf185e3ed1a68cf331c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/948edfa70264176018542bf185e3ed1a68cf331c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/948edfa70264176018542bf185e3ed1a68cf331c"}], "stats": {"total": 716, "additions": 574, "deletions": 142}, "files": [{"sha": "449a76a938ced9e6a4fd775417373573cf509229", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -1,3 +1,32 @@\n+Mon Mar  2 19:51:27 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* final.c (insn_last_address, insn_current_align, uid_align):\n+\tNew variables.\n+\t(in_align_chain, align_fuzz, align_shrink_fuzz): New functions.\n+\t(insn_current_reference_address): Likewise.\n+\t(shorten_branches, final_scan_insn): Implement LABEL_ALIGN,\n+\tLABEL_ALIGN_AFTER_BARRIER and LOOP_ALIGN target macros.\n+\t(label_to_alignment): New function.\n+\t* genattrtab.c (write_test_expr): If one of LABEL_ALIGN,\n+\tLABEL_ALIGN_AFTER_BARRIER or LOOP_ALIGN is defined, call\n+\tinsn_current_reference_address instead of insn_current_address.\n+\t(or_attr_value, write_length_unit_log): New functions.\n+\t(main): Call write_length_unit_log.\n+\t(write_const_num_delay_slots): Output extra '\\n'.\n+\t* alpha.h (ASM_OUTPUT_LOOP_ALIGN, ASM_OUTPUT_ALIGN_CODE):\n+\treplace with:\n+\t(LOOP_ALIGN, ALIGN_LABEL_AFTER_BARRIER).\n+\t* i386.h, i386/osfrose.h, i386/svr3dbx.h, m68k.h, sparc.h: Likewise.\n+\t* arc.h, m32r.h (ASM_OUTPUT_LOOP_ALIGN): replace with:\n+\t(LOOP_ALIGN).\n+\t* i960.h, m88k.h: (ASM_OUTPUT_ALIGN_CODE): Replace with:\n+\t(LABEL_ALIGN_AFTER_BARRIER).\n+\t* ns32k/encore.h, ns32k/merlin.h, ns32k.h, ns32k/sequent.h: Likewise.\n+\t* ns32k/tek6000.h: Likewise.\n+\t* i386/gas.h (ASM_OUTPUT_LOOP_ALIGN, ASM_OUTPUT_ALIGN_CODE): Delete.\n+\t* i386.md (casesi+1): Use ASM_OUTPUT_ALIGN instead of\n+\tASM_OUTPUT_ALIGN_CODE.\n+\n Mon Mar 2 01:05:50 PST 1998 Jeff Law  (law@cygnus.com)\n \n \t* version.c: Bump for snapshot."}, {"sha": "4386084416ea101b443791ca575a35c4278e06c6", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -387,19 +387,17 @@ extern void override_options ();\n /* Aligning past 2**3 wastes insn cache lines, and doesn't buy much \n    issue-wise on average anyway.  */\n \n-#define ASM_OUTPUT_LOOP_ALIGN(FILE) \\\n-  if (optimize > 0 && write_symbols != SDB_DEBUG)  \\\n-    ASM_OUTPUT_ALIGN (FILE, 3)\n+#define LOOP_ALIGN(LABEL) \\\n+  (optimize > 0 && write_symbols != SDB_DEBUG ? 3 : 0)\n \n /* This is how to align an instruction for optimal branching.\n    On Alpha we'll get better performance by aligning on a quadword\n    boundary.  */\n /* Aligning past 2**3 wastes insn cache lines, and doesn't buy much \n    issue-wise on average anyway.  */\n \n-#define ASM_OUTPUT_ALIGN_CODE(FILE)\t\\\n-  if (optimize > 0 && write_symbols != SDB_DEBUG) \\\n-    ASM_OUTPUT_ALIGN ((FILE), 3)\n+#define ALIGN_LABEL_AFTER_BARRIER(FILE)\t\\\n+  (optimize > 0 && write_symbols != SDB_DEBUG ? 3 : 0)\n \n /* No data type wants to be aligned rounder than this.  */\n #define BIGGEST_ALIGNMENT 64"}, {"sha": "98b39e20ff577b010d38d2697083a67f33ac813c", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -1504,12 +1504,11 @@ do {\t\t\t\t\t\t\t\\\n   fprintf (FILE, \")\\n\");\t\t\t\t\\\n } while (0)\n \n-/* A C expression to output text to align the location counter in the way\n-   that is desirable at the beginning of a loop.  */\n+/* The desired alignment for the location counter at the beginning\n+   of a loop.  */\n /* On the ARC, align loops to 32 byte boundaries (cache line size)\n    if -malign-loops.  */\n-#define ASM_OUTPUT_LOOP_ALIGN(FILE) \\\n-do { if (TARGET_ALIGN_LOOPS) ASM_OUTPUT_SKIP (FILE, 5); } while (0)\n+#define LOOP_ALIGN(LABEL) (TARGET_ALIGN_LOOPS ? 5 : 0)\n \n /* This is how to output an assembler line\n    that says to advance the location counter"}, {"sha": "50976cf8bec5cdb04b3c792cda6ae04f4cbd2453", "filename": "gcc/config/i386/gas.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fi386%2Fgas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fi386%2Fgas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fgas.h?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -85,20 +85,6 @@ Boston, MA 02111-1307, USA.  */\n #define ASM_OUTPUT_ALIGN(FILE,LOG) \\\n   if ((LOG)!=0) fprintf ((FILE), \"\\t.balign %d\\n\", 1<<(LOG))\n #endif\n-\n-/* Align labels, etc. at 4-byte boundaries.\n-   For the 486, align to 16-byte boundary for sake of cache.  */\n-\n-#undef ASM_OUTPUT_ALIGN_CODE\n-#define ASM_OUTPUT_ALIGN_CODE(FILE) \\\n-  fprintf ((FILE), \"\\t.align %d,0x90\\n\", i386_align_jumps)\n-\n-/* Align start of loop at 4-byte boundary.  */\n-\n-#undef ASM_OUTPUT_LOOP_ALIGN\n-#define ASM_OUTPUT_LOOP_ALIGN(FILE) \\\n-  fprintf ((FILE), \"\\t.align %d,0x90\\n\", i386_align_loops)\n-\n \f\n /* A C statement or statements which output an assembler instruction\n    opcode to the stdio stream STREAM.  The macro-operand PTR is a"}, {"sha": "1765ce1cd4cdd6ce95fc3116ed872bd0e2b73b7b", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -446,12 +446,12 @@ extern int ix86_arch;\n #define MAX_CODE_ALIGN\t6\t\t\t/* 64 byte alignment */\n \n /* Align loop starts for optimal branching.  */\n-#define ASM_OUTPUT_LOOP_ALIGN(FILE) ASM_OUTPUT_ALIGN (FILE, i386_align_loops)\n+#define LOOP_ALIGN(LABEL) (i386_align_loops)\n \n /* This is how to align an instruction for optimal branching.\n    On i486 we'll get better performance by aligning on a\n    cache line (i.e. 16 byte) boundary.  */\n-#define ASM_OUTPUT_ALIGN_CODE(FILE) ASM_OUTPUT_ALIGN ((FILE), i386_align_jumps)\n+#define LABEL_ALIGN_AFTER_BARRIER(LABEL) (i386_align_jumps)\n \n \f\n /* Standard register usage.  */"}, {"sha": "8db8acf4f6bf606edfd78c9f3e7cac2587f621d2", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -6193,7 +6193,7 @@ byte_xor_operation:\n   output_asm_insn (AS2 (mov%L2,%3,%2), xops);\n   output_asm_insn (\\\"sub%L2 %l1@GOTOFF(%3,%0,4),%2\\\", xops);\n   output_asm_insn (AS1 (jmp,%*%2), xops);\n-  ASM_OUTPUT_ALIGN_CODE (asm_out_file);\n+  ASM_OUTPUT_ALIGN (asm_out_file, i386_align_jumps);\n   RET;\n }\")\n "}, {"sha": "c0c0f3f1a29867c9f3927c80d87ca69f0b1efe38", "filename": "gcc/config/i386/osfrose.h", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fi386%2Fosfrose.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fi386%2Fosfrose.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosfrose.h?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -404,10 +404,9 @@ while (0)\n    alignment to be done at such a time.  Most machine descriptions do\n    not currently define the macro.  */\n \n-#undef\tASM_OUTPUT_ALIGN_CODE\n-#define ASM_OUTPUT_ALIGN_CODE(STREAM)\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\t.align\\t%d\\n\",\t\t\t\t\t\\\n-\t   (!TARGET_LARGE_ALIGN && i386_align_jumps > 2) ? 2 : i386_align_jumps)\n+#undef\tLABEL_ALIGN_AFTER_BARRIER\n+#define LABEL_ALIGN_AFTER_BARRIER(LABEL) \\\n+  ((!TARGET_LARGE_ALIGN && i386_align_jumps > 2) ? 2 : i386_align_jumps)\n \n /* A C expression to output text to align the location counter in the\n    way that is desirable at the beginning of a loop.\n@@ -416,9 +415,8 @@ while (0)\n    alignment to be done at such a time.  Most machine descriptions do\n    not currently define the macro.  */\n \n-#undef\tASM_OUTPUT_LOOP_ALIGN\n-#define ASM_OUTPUT_LOOP_ALIGN(STREAM) \\\n-  fprintf (STREAM, \"\\t.align\\t%d\\n\", i386_align_loops)\n+#undef\tLOOP_ALIGN\n+#define LOOP_ALIGN(LABEL) (i386_align_loops)\n \n /* A C statement to output to the stdio stream STREAM an assembler\n    command to advance the location counter to a multiple of 2 to the"}, {"sha": "36c01cc3c21a0c8a433136afbff154985aca4dce", "filename": "gcc/config/i386/svr3dbx.h", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fi386%2Fsvr3dbx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fi386%2Fsvr3dbx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsvr3dbx.h?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -46,16 +46,13 @@ Boston, MA 02111-1307, USA.  */\n /* Align labels, etc. at 4-byte boundaries.\n    For the 486, align to 16-byte boundary for sake of cache.  */\n \n-#undef ASM_OUTPUT_ALIGN_CODE\n-#define ASM_OUTPUT_ALIGN_CODE(FILE)\t\t\t\\\n-     fprintf ((FILE), \"\\t.align %d,0x90\\n\",\t\t\\\n-\t      1 << i386_align_jumps)\n+#undef LABEL_ALIGN_AFTER_BARRIER\n+#define LABEL_ALIGN_AFTER_BARRIER(LABEL) (i386_align_jumps)\n \n /* Align start of loop at 4-byte boundary.  */\n \n-#undef ASM_OUTPUT_LOOP_ALIGN\n-#define ASM_OUTPUT_LOOP_ALIGN(FILE) \\\n-     fprintf ((FILE), \"\\t.align %d,0x90\\n\", 1 << i386_align_loops);\n+#undef LOOP_ALIGN\n+#define LOOP_ALIGN(LABEL) (i386_align_loops)\n \n \n /* Additional overrides needed for dbx-in-coff gas, mostly taken from pbb.h */"}, {"sha": "caf2530e348451d59821cf49cac0dec2122f2862", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -1407,8 +1407,7 @@ extern struct rtx_def *gen_compare_reg ();\n \n /* Align code to 8 byte boundary if TARGET_CODE_ALIGN is true.  */\n \n-#define\tASM_OUTPUT_ALIGN_CODE(FILE)\t\t\\\n-{ if (TARGET_CODE_ALIGN) fputs(\"\\t.align 3\\n\",FILE); }\n+#define\tLABEL_ALIGN_AFTER_BARRIER(LABEL) (TARGET_CODE_ALIGN ? 3 : 0)\n \n /* Store in OUTPUT a string (made with alloca) containing\n    an assembler-name for a local static variable named NAME."}, {"sha": "510bac091fedfdd9e0c6a5ead9d830c62b51fb62", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -1673,12 +1673,11 @@ do {\t\t\t\t\t\t\t\\\n   fprintf (FILE, \")\\n\");\t\t\t\t\\\n } while (0)\n \n-/* A C expression to output text to align the location counter in the way\n-   that is desirable at the beginning of a loop.  */\n+/* The desired alignment for the location counter at the beginning\n+   of a loop.  */\n /* On the M32R, align loops to 32 byte boundaries (cache line size)\n    if -malign-loops.  */\n-#define ASM_OUTPUT_LOOP_ALIGN(FILE) \\\n-do { if (TARGET_ALIGN_LOOPS) ASM_OUTPUT_ALIGN (FILE, 5); } while (0)\n+#define LOOP_ALIGN(LABEL) (TARGET_ALIGN_LOOPS ? 5 : 0)\n \n /* This is how to output an assembler line\n    that says to advance the location counter"}, {"sha": "10284a320b680f79863dc443753b078fa2bfd6cb", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -294,10 +294,10 @@ extern int target_flags;\n #define MAX_CODE_ALIGN\t2\t\t\t/* 4 byte alignment */\n \n /* Align loop starts for optimal branching.  */\n-#define ASM_OUTPUT_LOOP_ALIGN(FILE) ASM_OUTPUT_ALIGN ((FILE), m68k_align_loops)\n+#define LOOP_ALIGN(LABEL) (m68k_align_loops)\n \n /* This is how to align an instruction for optimal branching. */\n-#define ASM_OUTPUT_ALIGN_CODE(FILE) ASM_OUTPUT_ALIGN ((FILE), m68k_align_jumps)\n+#define LABEL_ALIGN_AFTER_BARRIER(LABEL) (m68k_align_jumps)\n \n #define SELECT_RTX_SECTION(MODE, X)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\"}, {"sha": "b748a224069f2bab63c3c2e881c9ec0f6b8c6cf2", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -198,13 +198,13 @@ extern char * reg_names[];\n    Redefined in sysv4.h, and luna.h.  */\n #define VERSION_INFO1\t\"m88k, \"\n #ifndef VERSION_INFO2\n-#define VERSION_INFO2   \"$Revision: 1.3 $\"\n+#define VERSION_INFO2   \"$Revision: 1.4 $\"\n #endif\n \n #ifndef VERSION_STRING\n #define VERSION_STRING  version_string\n #ifdef __STDC__\n-#define TM_RCS_ID      \"@(#)\" __FILE__ \" $Revision: 1.3 $ \" __DATE__\n+#define TM_RCS_ID      \"@(#)\" __FILE__ \" $Revision: 1.4 $ \" __DATE__\n #else\n #define TM_RCS_ID      \"$What: <@(#) m88k.h,v\t1.1.1.2.2.2> $\"\n #endif  /* __STDC__ */\n@@ -2212,9 +2212,8 @@ do {\t\t\t\t\t\t\t\t\t \\\n /* On the m88100, align the text address to half a cache boundary when it\n    can only be reached by jumping.  Pack code tightly when compiling\n    crtstuff.c.  */\n-#define ASM_OUTPUT_ALIGN_CODE(FILE) \\\n-  ASM_OUTPUT_ALIGN (FILE, \\\n-\t\t    (TARGET_88100 && !flag_inhibit_size_directive ? 3 : 2))\n+#define LABEL_ALIGN_AFTER_BARRIER(LABEL) \\\n+  (TARGET_88100 && !flag_inhibit_size_directive ? 3 : 2)\n \n /* Override svr[34].h.  */\n #undef\tASM_OUTPUT_SKIP"}, {"sha": "f388453dc23b4126e144292a692312d9e4d934a1", "filename": "gcc/config/ns32k/encore.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fns32k%2Fencore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fns32k%2Fencore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fencore.h?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -79,8 +79,8 @@ output_file_directive ((FILE), main_input_filename)\n /* The Encore assembler doesn't seem to accept the usual second argument\n    and warns that .align may not work in the text section if optimization\n    is on.  */\n-#undef ASM_OUTPUT_ALIGN_CODE\n-#define ASM_OUTPUT_ALIGN_CODE(FILE)\n+#undef LABEL_ALIGN_AFTER_BARRIER\n+#define LABEL_ALIGN_AFTER_BARRIER(LABEL) 0\n \n /*\n  *  Internal labels are prefixed with a period."}, {"sha": "d385395a9cabc1f47a210a6c3c83a1e44f4e3e7f", "filename": "gcc/config/ns32k/merlin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fns32k%2Fmerlin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fns32k%2Fmerlin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fmerlin.h?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -53,7 +53,7 @@ Boston, MA 02111-1307, USA.  */\n /* This is how to align the code that follows an unconditional branch.\n    Don't define it, since it confuses the assembler (we hear).  */\n \n-#undef ASM_OUTPUT_ALIGN_CODE\n+#undef LABEL_ALIGN_AFTER_BARRIER\n \n /* Assembler pseudo-op for shared data segment. */\n #define SHARED_SECTION_ASM_OP \".shdata\""}, {"sha": "47a1d84f69b51345d1839d9f83ad18197704f0a0", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -1383,11 +1383,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n   sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n \n-/* This is how to align the code that follows an unconditional branch.\n-   Note that 0xa2 is a no-op.  */\n+/* This is how to align the code that follows an unconditional branch.  */\n \n-#define ASM_OUTPUT_ALIGN_CODE(FILE)\t\\\n-  fprintf (FILE, \"\\t.align 2,0xa2\\n\")\n+#define LABEL_ALIGN_AFTER_BARRIER(LABEL) (2)\n \n /* This is how to output an element of a case-vector that is absolute.\n    (The ns32k does not use such vectors,"}, {"sha": "1e8c3535ec700e9d8d88b4cbd93dcc80f00540c9", "filename": "gcc/config/ns32k/sequent.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fns32k%2Fsequent.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fns32k%2Fsequent.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fsequent.h?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -54,7 +54,7 @@ Boston, MA 02111-1307, USA.  */\n /* This is how to align the code that follows an unconditional branch.\n    Don't define it, since it confuses the assembler (we hear).  */\n \n-#undef ASM_OUTPUT_ALIGN_CODE\n+#undef LABEL_ALIGN_AFTER_BARRIER\n \n /* Assembler pseudo-op for shared data segment. */\n #define SHARED_SECTION_ASM_OP \".shdata\""}, {"sha": "01c88e39a2ede2bca2c3d0926e7f3a0f2880f3c9", "filename": "gcc/config/ns32k/tek6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fns32k%2Ftek6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fns32k%2Ftek6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Ftek6000.h?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -106,7 +106,7 @@ Boston, MA 02111-1307, USA.  */\n /* This is how to align the code that follows an unconditional branch.\n    Don't define it, since it confuses the assembler (we hear).  */\n \n-#undef ASM_OUTPUT_ALIGN_CODE\n+#undef LABEL_ALIGN_AFTER_BARRIER\n \n /* Assembler pseudo-op for shared data segment. */\n #define SHARED_SECTION_ASM_OP \".shdata\""}, {"sha": "44c0b2191e41789d490f6ed0ba38ec458d314194", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -2991,11 +2991,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n   if ((LOG) != 0)\t\t\t\\\n     fprintf (FILE, \"\\t.align %d\\n\", (1<<(LOG)))\n \n-#define ASM_OUTPUT_ALIGN_CODE(FILE) \\\n-  ASM_OUTPUT_ALIGN (FILE, sparc_align_jumps)\n+#define LABEL_ALIGN_AFTER_BARRIER(LABEL) (sparc_align_jumps)\n \n-#define ASM_OUTPUT_LOOP_ALIGN(FILE) \\\n-  ASM_OUTPUT_ALIGN (FILE, sparc_align_loops)\n+#define LOOP_ALIGN(LABEL) (sparc_align_loops)\n \n #define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n   fprintf (FILE, \"\\t.skip %u\\n\", (SIZE))"}, {"sha": "de66f9c4bc3d495ef048e72732d71b2b4e9ed6cc", "filename": "gcc/final.c", "status": "modified", "additions": 427, "deletions": 60, "changes": 487, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -153,6 +153,8 @@ static int count_basic_blocks;\n /* Number of instrumented arcs when profile_arc_flag is set.  */\n extern int count_instrumented_arcs;\n \n+extern int length_unit_log; /* This is defined in insn-attrtab.c.  */\n+\n /* Nonzero while outputting an `asm' with operands.\n    This means that inconsistencies are the user's fault, so don't abort.\n    The precise value is the insn being output, to pass to error_for_asm.  */\n@@ -628,6 +630,12 @@ int *insn_addresses;\n /* Address of insn being processed.  Used by `insn_current_length'.  */\n int insn_current_address;\n \n+/* Address of insn being processed in previous iteration.  */\n+int insn_last_address;\n+\n+/* konwn invariant alignment of insn being processed.  */\n+int insn_current_align;\n+\n /* Indicate that branch shortening hasn't yet been done.  */\n \n void\n@@ -666,16 +674,8 @@ get_attr_length (insn)\n \tbody = PATTERN (insn);\n         if (GET_CODE (body) == ADDR_VEC || GET_CODE (body) == ADDR_DIFF_VEC)\n \t  {\n-\t    /* This only takes room if jump tables go into the text section.  */\n-#if !defined(READONLY_DATA_SECTION) || defined(JUMP_TABLES_IN_TEXT_SECTION)\n-\t    length = (XVECLEN (body, GET_CODE (body) == ADDR_DIFF_VEC)\n-\t\t      * GET_MODE_SIZE (GET_MODE (body)));\n-\n-\t    /* Be pessimistic and assume worst-case alignment.  */\n-\t    length += (GET_MODE_SIZE (GET_MODE (body)) - 1);\n-#else\n-\t    return 0;\n-#endif\n+\t    /* Alignment is machine-dependent and should be handled by\n+\t       ADDR_VEC_ALIGN.  */\n \t  }\n \telse\n \t  length = insn_default_length (insn);\n@@ -708,6 +708,205 @@ get_attr_length (insn)\n #endif /* not HAVE_ATTR_length */\n }\n \f\n+/* Code to handle alignment inside shorten_branches.  */\n+\n+/* Here is an explanation how the algorithm in align_fuzz can give\n+   proper results:\n+\n+   Call a sequence of instructions beginning with alignment point X\n+   and continuing until the next alignment point `block X'.  When `X'\n+   is used in an expression, it means the alignment value of the \n+   alignment point.\n+   \n+   Call the distance between the start of the first insn of block X, and\n+   the end of the last insn of block X `IX', for the `inner size of X'.\n+   This is clearly the sum of the instruction lengths.\n+   \n+   Likewise with the next alignment-delimited block following X, which we\n+   shall call block Y.\n+   \n+   Call the distance between the start of the first insn of block X, and\n+   the start of the first insn of block Y `OX', for the `outer size of X'.\n+   \n+   The estimated padding is then OX - IX.\n+   \n+   OX can be safely estimated as\n+   \n+           if (X >= Y)\n+                   OX = round_up(IX, Y)\n+           else\n+                   OX = round_up(IX, X) + Y - X\n+   \n+   Clearly est(IX) >= real(IX), because that only depends on the\n+   instruction lengths, and those being overestimated is a given.\n+   \n+   Clearly round_up(foo, Z) >= round_up(bar, Z) if foo >= bar, so\n+   we needn't worry about that when thinking about OX.\n+   \n+   When X >= Y, the alignment provided by Y adds no uncertainty factor\n+   for branch ranges starting before X, so we can just round what we have.\n+   But when X < Y, we don't know anything about the, so to speak,\n+   `middle bits', so we have to assume the worst when aligning up from an\n+   address mod X to one mod Y, which is Y - X.  */\n+\n+#ifndef LABEL_ALIGN\n+#define LABEL_ALIGN(LABEL) 0\n+#endif\n+\n+#ifndef LOOP_ALIGN\n+#define LOOP_ALIGN(LABEL) 0\n+#endif\n+\n+#ifndef LABEL_ALIGN_AFTER_BARRIER\n+#define LABEL_ALIGN_AFTER_BARRIER(LABEL) 0\n+#endif\n+\n+#ifndef ADDR_VEC_ALIGN\n+int\n+final_addr_vec_align (addr_vec)\n+     rtx addr_vec;\n+{\n+  int align = exact_log2 (GET_MODE_SIZE (GET_MODE (PATTERN (addr_vec))));\n+\n+  if (align > BIGGEST_ALIGNMENT / BITS_PER_UNIT)\n+    align = BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n+  return align;\n+\n+}\n+#define ADDR_VEC_ALIGN(ADDR_VEC) final_addr_vec_align (ADDR_VEC)\n+#endif\n+\n+#ifndef INSN_LENGTH_ALIGNMENT\n+#define INSN_LENGTH_ALIGNMENT(INSN) length_unit_log\n+#endif\n+\n+/* For any insn, uid_align[INSN_UID (insn)] gives the next following\n+   alignment insn that increases the known alignment, or NULL_RTX if\n+   there is no such insn.\n+   For any alignment obtained this way, we can again index uid_align with\n+   its uid to obtain the next following align that in turn increases the\n+   alignment, till we reach NULL_RTX; the sequence obtained this way\n+   for each insn we'll call the alignment chain of this insn in the following\n+   comments.  */\n+\n+rtx *uid_align;\n+int *uid_shuid;\n+short *label_align; /* sh.c needs this to calculate constant tables.  */\n+\n+#define INSN_SHUID(INSN) (uid_shuid[INSN_UID (INSN)])\n+\n+static int min_labelno;\n+\n+#define LABEL_TO_ALIGNMENT(LABEL) \\\n+  (label_align[CODE_LABEL_NUMBER (LABEL) - min_labelno])\n+\n+/* For the benefit of port specific code do this also as a function.  */\n+int\n+label_to_alignment (label)\n+     rtx label;\n+{\n+  return LABEL_TO_ALIGNMENT (label);\n+}\n+\n+#ifdef HAVE_ATTR_length\n+/* The differences in addresses\n+   between a branch and its target might grow or shrink depending on\n+   the alignment the start insn of the range (the branch for a forward\n+   branch or the label for a backward branch) starts out on; if these\n+   differences are used naively, they can even oscillate infinitely.\n+   We therefore want to compute a 'worst case' address difference that\n+   is independent of the alignment the start insn of the range end\n+   up on, and that is at least as large as the actual difference.\n+   The function align_fuzz calculates the amount we have to add to the\n+   naively computed difference, by traversing the part of the alignment\n+   chain of the start insn of the range that is in front of the end insn\n+   of the range, and considering for each alignment the maximum amount\n+   that it might contribute to a size increase.\n+\n+   For casesi tables, we also want to know worst case minimum amounts of\n+   address difference, in case a machine description wants to introduce\n+   some common offset that is added to all offsets in a table.\n+   For this purpose, align_fuzz with a growth argument of 0 comuptes the\n+   appropriate adjustment.  */\n+\n+\n+/* Compute the maximum delta by which the difference of the addresses of\n+   START and END might grow / shrink due to a different address for start\n+   which changes the size of alignment insns between START and END.\n+   KNOWN_ALIGN_LOG is the alignment known for START.\n+   GROWTH should be ~0 if the objective is to compute potential code size\n+   increase, and 0 if the objective is to compute potential shrink.\n+   The return value is undefined for any other value of GROWTH.  */\n+int align_fuzz (start, end, known_align_log, growth)\n+     rtx start, end;\n+     int known_align_log;\n+     unsigned growth;\n+{\n+  int uid = INSN_UID (start);\n+  rtx align_label;\n+  int known_align = 1 << known_align_log;\n+  int end_shuid = INSN_SHUID (end);\n+  int fuzz = 0;\n+\n+  for (align_label = uid_align[uid]; align_label; align_label = uid_align[uid])\n+    {\n+      int align_addr, new_align;\n+\n+      uid = INSN_UID (align_label);\n+      align_addr = insn_addresses[uid] - insn_lengths[uid];\n+      if (uid_shuid[uid] > end_shuid)\n+\tbreak;\n+      known_align_log = LABEL_TO_ALIGNMENT (align_label);\n+      new_align = 1 << known_align_log;\n+      if (new_align < known_align)\n+\tcontinue;\n+      fuzz += (-align_addr ^ growth) & (new_align - known_align);\n+      known_align = new_align;\n+    }\n+  return fuzz;\n+}\n+\n+/* Compute a worst-case reference address of a branch so that it\n+   can be safely used in the presence of aligned labels.  Since the\n+   size of the branch itself is unknown, the size of the branch is\n+   not included in the range.  I.e. for a forward branch, the reference\n+   address is the end address of the branch as known from the previous\n+   branch shortening pass, minus a value to account for possible size\n+   increase due to alignment.  For a backward branch, it is the start\n+   address of the branch as known from the current pass, plus a value\n+   to account for possible size increase due to alignment.\n+   NB.: Therefore, the maximum offset allowed for backward branches needs\n+   to exclude the branch size.  */\n+int\n+insn_current_reference_address (branch)\n+     rtx branch;\n+{\n+  rtx dest;\n+  rtx seq = NEXT_INSN (PREV_INSN (branch));\n+  int seq_uid = INSN_UID (seq);\n+  if (GET_CODE (branch) != JUMP_INSN)\n+    /* This can happen for example on the PA; the objective is to know the\n+       offset to address something in front of the start of the function.\n+       Thus, we can treat it like a backward branch.\n+       We assume here that FUNCTION_BOUNDARY / BITS_PER_UNIT is larger than\n+       any alignment we'd encounter, so we skip the call to align_fuzz.  */\n+    return insn_current_address;\n+  dest = JUMP_LABEL (branch);\n+  if (INSN_SHUID (branch) < INSN_SHUID (dest))\n+    {\n+      /* Forward branch. */\n+      return (insn_last_address + insn_lengths[seq_uid]\n+\t      - align_fuzz (branch, dest, length_unit_log, ~0));\n+    }\n+  else\n+    {\n+      /* Backward branch. */\n+      return (insn_current_address\n+\t      + align_fuzz (dest, branch, length_unit_log, ~0));\n+    }\n+}\n+#endif /* HAVE_ATTR_length */\n+\f\n /* Make a pass over all insns and compute their actual lengths by shortening\n    any branches of variable length if possible.  */\n \n@@ -717,44 +916,211 @@ get_attr_length (insn)\n #define FIRST_INSN_ADDRESS 0\n #endif\n \n+/* shorten_branches might be called multiple times:  for example, the SH\n+   port splits out-of-range conditional branches in MACHINE_DEPENDENT_REORG.\n+   In order to do this, it needs proper length information, which it obtains\n+   by calling shorten_branches.  This cannot be collapsed with\n+   shorten_branches itself into a single pass unless we also want to intergate\n+   reorg.c, since the branch splitting exposes new instructions with delay\n+   slots.  */\n+\n void\n shorten_branches (first)\n      rtx first;\n {\n-#ifdef HAVE_ATTR_length\n   rtx insn;\n+  int max_uid;\n+  int i;\n+  int max_labelno;\n+  int max_log;\n+#ifdef HAVE_ATTR_length\n+#define MAX_CODE_ALIGN 16\n+  rtx seq;\n   int something_changed = 1;\n-  int max_uid = 0;\n   char *varying_length;\n   rtx body;\n   int uid;\n+  rtx align_tab[MAX_CODE_ALIGN];\n \n   /* In order to make sure that all instructions have valid length info,\n      we must split them before we compute the address/length info.  */\n \n   for (insn = NEXT_INSN (first); insn; insn = NEXT_INSN (insn))\n     if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-      insn = try_split (PATTERN (insn), insn, 1);\n+      {\n+\trtx old = insn;\n+\tinsn = try_split (PATTERN (old), old, 1);\n+\t/* When not optimizing, the old insn will be still left around\n+\t   with only the 'deleted' bit set.  Transform it into a note\n+\t   to avoid confusion of subsequent processing.  */\n+\tif (INSN_DELETED_P (old))\n+          {\n+            PUT_CODE (old , NOTE);\n+            NOTE_LINE_NUMBER (old) = NOTE_INSN_DELETED;\n+            NOTE_SOURCE_FILE (old) = 0;\n+          }\n+      }\n+#endif\n \n-  /* Compute maximum UID and allocate arrays.  */\n-  for (insn = first; insn; insn = NEXT_INSN (insn))\n-    if (INSN_UID (insn) > max_uid)\n-      max_uid = INSN_UID (insn);\n+  /* We must do some computations even when not actually shortening, in\n+     order to get the alignment information for the labels.  */\n+\n+  /* Compute maximum UID and allocate label_align / uid_shuid.  */\n+  max_uid = get_max_uid ();\n+\n+  max_labelno = max_label_num ();\n+  min_labelno = get_first_label_num ();\n+  if (label_align)\n+    free (label_align);\n+  label_align\n+    = (short*) xmalloc ((max_labelno - min_labelno + 1) * sizeof (short));\n+  bzero (label_align, (max_labelno - min_labelno + 1) * sizeof (short));\n+\n+  if (uid_shuid)\n+    free (uid_shuid);\n+  uid_shuid = (int *) xmalloc (max_uid * sizeof *uid_shuid);\n+\n+  /* Initialize label_align and set up uid_shuid to be strictly\n+     monotonically rising with insn order.  */\n+  for (max_log = 0, insn = get_insns (), i = 1; insn; insn = NEXT_INSN (insn))\n+    {\n+      int log;\n+\n+      INSN_SHUID (insn) = i++;\n+      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\tmax_log = 0;\n+      else if (GET_CODE (insn) == CODE_LABEL)\n+\t{\n+\t  rtx next;\n+\n+\t  log = LABEL_ALIGN (insn);\n+\t  if (max_log < log)\n+\t    max_log = log;\n+\t  next = NEXT_INSN (insn);\n+/* ADDR_VECs only take room if read-only data goes into the text section.  */\n+#if !defined(READONLY_DATA_SECTION) || defined(JUMP_TABLES_IN_TEXT_SECTION)\n+\t  if (next && GET_CODE (next) == JUMP_INSN)\n+\t    {\n+\t      rtx nextbody = PATTERN (next);\n+\t      if (GET_CODE (nextbody) == ADDR_VEC\n+\t\t  || GET_CODE (nextbody) == ADDR_DIFF_VEC)\n+\t\t{\n+\t\t  log = ADDR_VEC_ALIGN (next);\n+\t\t  if (max_log < log)\n+\t\t    max_log = log;\n+\t\t}\n+\t    }\n+#endif\n+\t  LABEL_TO_ALIGNMENT (insn) = max_log;\n+\t  max_log = 0;\n+\t}\n+      else if (GET_CODE (insn) == BARRIER)\n+\t{\n+\t  rtx label;\n+\n+\t  for (label = insn; label && GET_RTX_CLASS (GET_CODE (label)) != 'i';\n+\t       label = NEXT_INSN (label))\n+\t    if (GET_CODE (label) == CODE_LABEL)\n+\t      {\n+\t\tlog = LABEL_ALIGN_AFTER_BARRIER (insn);\n+\t\tif (max_log < log)\n+\t\t  max_log = log;\n+\t\tbreak;\n+\t      }\n+\t}\n+      else if (GET_CODE (insn) == NOTE\n+\t       && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+\t{\n+\t  rtx label;\n+\n+\t  for (label = insn; label && GET_RTX_CLASS (GET_CODE (label)) != 'i';\n+\t       label = NEXT_INSN (label))\n+\t    if (GET_CODE (label) == CODE_LABEL)\n+\t      {\n+\t\tlog = LOOP_ALIGN (insn);\n+\t\tif (max_log < log)\n+\t\t  max_log = log;\n+\t\tbreak;\n+\t      }\n+\t}\n+      else\n+\tcontinue;\n+    }\n+#ifdef HAVE_ATTR_length\n+\n+  /* Allocate the rest of the arrays.  */\n+  if (insn_lengths)\n+    free (insn_lengths);\n+  insn_lengths = (short *) xmalloc (max_uid * sizeof (short));\n+  if (insn_addresses)\n+    free (insn_addresses);\n+  insn_addresses = (int *) xmalloc (max_uid * sizeof (int));\n+  if (uid_align)\n+    free (uid_align);\n+  uid_align = (rtx *) xmalloc (max_uid * sizeof *uid_align);\n+\n+  varying_length = (char *) xmalloc (max_uid * sizeof (char));\n+\n+  bzero (varying_length, max_uid);\n+\n+  /* Initialize uid_align.  We scan instructions\n+     from end to start, and keep in align_tab[n] the last seen insn\n+     that does an alignment of at least n+1, i.e. the successor\n+     in the alignment chain for an insn that does / has a known\n+     alignment of n.  */\n+\n+  bzero ((char *) uid_align, max_uid * sizeof *uid_align);\n+\n+  for (i = MAX_CODE_ALIGN; --i >= 0; )\n+    align_tab[i] = NULL_RTX;\n+  seq = get_last_insn ();\n+  for (insn_current_address = 0; seq; seq = PREV_INSN (seq))\n+    {\n+      int uid = INSN_UID (seq);\n+      int log;\n+      int length_align;\n+      log = (GET_CODE (seq) == CODE_LABEL ? LABEL_TO_ALIGNMENT (seq) : 0);\n+      uid_align[uid] = align_tab[0];\n+      insn_addresses[uid] = --insn_current_address;\n+      if (log)\n+\t{\n+\t  /* Found an alignment label.  */\n+\t  uid_align[uid] = align_tab[log];\n+\t  for (i = log - 1; i >= 0; i--)\n+\t    align_tab[i] = seq;\n+\t}\n+      if (GET_CODE (seq) != INSN || GET_CODE (PATTERN (seq)) != SEQUENCE)\n+\tinsn = seq;\n+      else\n+\t{\n+\t  insn = XVECEXP (PATTERN (seq), 0, 0);\n+\t  uid = INSN_UID (insn);\n+\t}\n+    }\n \n-  max_uid++;\n-  insn_lengths = (short *) oballoc (max_uid * sizeof (short));\n-  insn_addresses = (int *) oballoc (max_uid * sizeof (int));\n-  varying_length = (char *) oballoc (max_uid * sizeof (char));\n \n   /* Compute initial lengths, addresses, and varying flags for each insn.  */\n   for (insn_current_address = FIRST_INSN_ADDRESS, insn = first;\n        insn != 0;\n        insn_current_address += insn_lengths[uid], insn = NEXT_INSN (insn))\n     {\n       uid = INSN_UID (insn);\n-      insn_addresses[uid] = insn_current_address;\n+\n       insn_lengths[uid] = 0;\n-      varying_length[uid] = 0;\n+\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\t{\n+\t  int log = LABEL_TO_ALIGNMENT (insn);\n+\t  if (log)\n+\t    {\n+\t      int align = 1 << log;\n+\t      int new_address = insn_current_address + align - 1 & -align;\n+\t      insn_lengths[uid] = new_address - insn_current_address;\n+\t      insn_current_address = new_address;\n+\t    }\n+\t}\n+\n+      insn_addresses[uid] = insn_current_address;\n       \n       if (GET_CODE (insn) == NOTE || GET_CODE (insn) == BARRIER\n \t  || GET_CODE (insn) == CODE_LABEL)\n@@ -764,25 +1130,7 @@ shorten_branches (first)\n \n       body = PATTERN (insn);\n       if (GET_CODE (body) == ADDR_VEC || GET_CODE (body) == ADDR_DIFF_VEC)\n-\t{\n-\t  /* This only takes room if read-only data goes into the text\n-\t     section.  */\n-#if !defined(READONLY_DATA_SECTION) || defined(JUMP_TABLES_IN_TEXT_SECTION)\n-\t  int unitsize = GET_MODE_SIZE (GET_MODE (body));\n-\n-\t  insn_lengths[uid] = (XVECLEN (body, GET_CODE (body) == ADDR_DIFF_VEC)\n-\t\t\t       * GET_MODE_SIZE (GET_MODE (body)));\n-\n-\t  /* We don't know what address the ADDR_VEC/ADDR_DIFF_VEC will end\n-\t     up at after branch shortening.  As a result, it is impossible\n-\t     to determine how much padding we need at this point.  Therefore,\n-\t     assume worst possible alignment.  */\n-\t  insn_lengths[uid] += unitsize - 1;\n-\n-#else\n-\t  ;\n-#endif\n-\t}\n+\t; /* This should be handled by LABEL_ALIGN.  */\n       else if (asm_noperands (body) >= 0)\n \tinsn_lengths[uid] = asm_insn_count (body) * insn_default_length (insn);\n       else if (GET_CODE (body) == SEQUENCE)\n@@ -842,6 +1190,7 @@ shorten_branches (first)\n   while (something_changed)\n     {\n       something_changed = 0;\n+      insn_current_align = MAX_CODE_ALIGN - 1;\n       for (insn_current_address = FIRST_INSN_ADDRESS, insn = first;\n \t   insn != 0;\n \t   insn = NEXT_INSN (insn))\n@@ -852,9 +1201,34 @@ shorten_branches (first)\n \t  int tmp_length;\n #endif\n #endif\n+\t  int length_align;\n \n \t  uid = INSN_UID (insn);\n+\n+\t  if (GET_CODE (insn) == CODE_LABEL)\n+\t    {\n+\t      int log = LABEL_TO_ALIGNMENT (insn);\n+\t      if (log > insn_current_align)\n+\t\t{\n+\t\t  int align = 1 << log;\n+\t\t  int new_address= insn_current_address + align - 1 & -align;\n+\t\t  insn_lengths[uid] = new_address - insn_current_address;\n+\t\t  insn_current_align = log;\n+\t\t  insn_current_address = new_address;\n+\t\t}\n+\t      else\n+\t\tinsn_lengths[uid] = 0;\n+\t      insn_addresses[uid] = insn_current_address;\n+\t      continue;\n+\t    }\n+\n+\t  length_align = INSN_LENGTH_ALIGNMENT (insn);\n+\t  if (length_align < insn_current_align)\n+\t    insn_current_align = length_align;\n+\n+\t  insn_last_address = insn_addresses[uid];\n \t  insn_addresses[uid] = insn_current_address;\n+\n \t  if (! varying_length[uid])\n \t    {\n \t      insn_current_address += insn_lengths[uid];\n@@ -915,6 +1289,9 @@ shorten_branches (first)\n       if (!optimize)\n \tbreak;\n     }\n+\n+  free (varying_length);\n+\n #endif /* HAVE_ATTR_length */\n }\n \n@@ -1413,17 +1790,8 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n       /* Align the beginning of a loop, for higher speed\n \t on certain machines.  */\n \n-      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG && optimize > 0)\n-\t{\n-#ifdef ASM_OUTPUT_LOOP_ALIGN\n-\t  rtx next = next_nonnote_insn (insn);\n-\t  if (next && GET_CODE (next) == CODE_LABEL)\n-\t    {\n-\t      ASM_OUTPUT_LOOP_ALIGN (asm_out_file);\n-\t    }\n-#endif\n-\t  break;\n-\t}\n+      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+\tbreak; /* This used to depend on optimize, but that was bogus.  */\n       if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n \tbreak;\n \n@@ -1633,13 +2001,6 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n       break;\n \n     case BARRIER:\n-#ifdef ASM_OUTPUT_ALIGN_CODE\n-      /* Don't litter the assembler output with needless alignments.  A\n-\t BARRIER will be placed at the end of every function if HAVE_epilogue\n-\t is true.  */\t \n-      if (NEXT_INSN (insn))\n-\tASM_OUTPUT_ALIGN_CODE (file);\n-#endif\n #if defined (DWARF2_UNWIND_INFO) && !defined (ACCUMULATE_OUTGOING_ARGS)\n \t/* If we push arguments, we need to check all insns for stack\n \t   adjustments.  */\n@@ -1649,6 +2010,12 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n       break;\n \n     case CODE_LABEL:\n+      {\n+\tint align = LABEL_TO_ALIGNMENT (insn);\n+\n+\tif (align && NEXT_INSN (insn))\n+\t  ASM_OUTPUT_ALIGN (file, align);\n+      }\n       CC_STATUS_INIT;\n       if (prescan > 0)\n \tbreak;"}, {"sha": "49a62445776c977dc0c8c87a50251f2b6a8176ce", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 66, "deletions": 6, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -448,6 +448,7 @@ static void gen_delay\t\tPROTO((rtx));\n static void gen_unit\t\tPROTO((rtx));\n static void write_test_expr\tPROTO((rtx, int));\n static int max_attr_value\tPROTO((rtx));\n+static int or_attr_value\tPROTO((rtx));\n static void walk_attr_value\tPROTO((rtx));\n static void write_attr_get\tPROTO((struct attr_desc *));\n static rtx eliminate_known_true PROTO((rtx, rtx, int, int));\n@@ -2500,6 +2501,26 @@ max_fn (exp)\n {\n   return make_numeric_value (max_attr_value (exp));\n }\n+\n+static void\n+write_length_unit_log ()\n+{\n+  struct attr_desc *length_attr = find_attr (\"length\", 0);\n+  struct attr_value *av;\n+  struct insn_ent *ie;\n+  unsigned int length_unit_log, length_or;\n+\n+  if (length_attr == 0)\n+    return;\n+  length_or = or_attr_value (length_attr->default_val->value);\n+    for (av = length_attr->first_value; av; av = av->next)\n+      for (ie = av->first_insn; ie; ie = ie->next)\n+\tlength_or |= or_attr_value (av->value);\n+  length_or = ~length_or;\n+  for (length_unit_log = 0; length_or & 1; length_or >>= 1)\n+    length_unit_log++;\n+  printf (\"int length_unit_log = %u;\\n\", length_unit_log);\n+}\n \f\n /* Take a COND expression and see if any of the conditions in it can be\n    simplified.  If any are known true or known false for the particular insn\n@@ -4639,12 +4660,13 @@ write_test_expr (exp, flags)\n \t      XINT (exp, 0), XINT (exp, 0), XINT (exp, 0));\n       break;\n \n-    /* The address of the current insn.  It would be more consistent with\n-       other usage to make this the address of the NEXT insn, but this gets\n-       too confusing because of the ambiguity regarding the length of the\n-       current insn.  */\n     case PC:\n-      printf (\"insn_current_address\");\n+      /* The address of the current insn.  We implement this actually as the\n+\t address of the current insn for backward branches, but the last\n+\t address of the next insn for forward branches, and both with\n+\t adjustments that account for the worst-case possible stretching of\n+\t intervening alignments between this insn and its destination.  */\n+      printf(\"insn_current_reference_address (insn)\");\n       break;\n \n     case CONST_STRING:\n@@ -4708,6 +4730,42 @@ max_attr_value (exp)\n \n   return current_max;\n }\n+\n+/* Given an attribute value, return the result of ORing together all\n+   CONST_STRING arguments encountered.  It is assumed that they are\n+   all numeric.  */\n+\n+static int\n+or_attr_value (exp)\n+     rtx exp;\n+{\n+  int current_or = 0;\n+  int i;\n+\n+  if (GET_CODE (exp) == CONST_STRING)\n+    return atoi (XSTR (exp, 0));\n+\n+  else if (GET_CODE (exp) == COND)\n+    {\n+      for (i = 0; i < XVECLEN (exp, 0); i += 2)\n+\t{\n+\t  current_or |= or_attr_value (XVECEXP (exp, 0, i + 1));\n+\t}\n+\n+      current_or |= or_attr_value (XEXP (exp, 1));\n+    }\n+\n+  else if (GET_CODE (exp) == IF_THEN_ELSE)\n+    {\n+      current_or = or_attr_value (XEXP (exp, 1));\n+      current_or |= or_attr_value (XEXP (exp, 2));\n+    }\n+\n+  else\n+    abort ();\n+\n+  return current_or;\n+}\n \f\n /* Scan an attribute value, possibly a conditional, and record what actions\n    will be required to do any conditional tests in it.\n@@ -5795,7 +5853,7 @@ write_const_num_delay_slots ()\n \n       printf (\"    default:\\n\");\n       printf (\"      return 1;\\n\");\n-      printf (\"    }\\n}\\n\");\n+      printf (\"    }\\n}\\n\\n\");\n     }\n }\n \n@@ -5982,6 +6040,8 @@ from the machine description file `md'.  */\\n\\n\");\n   /* Write out constant delay slot info */\n   write_const_num_delay_slots ();\n \n+  write_length_unit_log ();\n+\n   fflush (stdout);\n   exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n   /* NOTREACHED */"}, {"sha": "95ef9a6ca03cfc12b962c9a8b1a9d3227888d859", "filename": "gcc/tm.texi", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc470718aca25ebac8f4e07cbabef1da140755ae/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=fc470718aca25ebac8f4e07cbabef1da140755ae", "patch": "@@ -6154,25 +6154,30 @@ instead of inline unwinders and __unwind_function in the non-setjmp case.\n This describes commands for alignment.\n \n @table @code\n-@findex ASM_OUTPUT_ALIGN_CODE\n-@item ASM_OUTPUT_ALIGN_CODE (@var{file})\n-A C expression to output text to align the location counter in the way\n-that is desirable at a point in the code that is reached only by\n-jumping.\n+@findex LABEL_ALIGN_AFTER_BARRIER\n+@item LABEL_ALIGN_AFTER_BARRIER (@var{label})\n+The alignment (log base 2) to put in front of @var{label}, which follows\n+a BARRIER.\n \n This macro need not be defined if you don't want any special alignment\n to be done at such a time.  Most machine descriptions do not currently\n define the macro.\n \n-@findex ASM_OUTPUT_LOOP_ALIGN\n-@item ASM_OUTPUT_LOOP_ALIGN (@var{file})\n-A C expression to output text to align the location counter in the way\n-that is desirable at the beginning of a loop.\n+@findex LOOP_ALIGN\n+@item LOOP_ALIGN (@var{label})\n+The alignment (log base 2) to put in front of @var{label}, which follows\n+a NOTE_INSN_LOOP_BEG note.\n \n This macro need not be defined if you don't want any special alignment\n to be done at such a time.  Most machine descriptions do not currently\n define the macro.\n \n+@findex LABEL_ALIGN\n+@item LABEL_ALIGN (@var{label})\n+The alignment (log base 2) to put in front of @var{label}.\n+If LABEL_ALIGN_AFTER_BARRIER / LOOP_ALIGN specify a different alignment,\n+the maximum of the specified values is used.\n+\n @findex ASM_OUTPUT_SKIP\n @item ASM_OUTPUT_SKIP (@var{stream}, @var{nbytes})\n A C statement to output to the stdio stream @var{stream} an assembler"}]}