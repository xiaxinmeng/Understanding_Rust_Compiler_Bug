{"sha": "a96c67ec898a25a760997e6b51b4f5832f671fa1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk2YzY3ZWM4OThhMjVhNzYwOTk3ZTZiNTFiNGY1ODMyZjY3MWZhMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@casey.cygnus.com", "date": "1999-11-23T01:50:36Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-11-23T01:50:36Z"}, "message": "dwarf2out.c (die_struct): Remove die_attr_last and die_child_last.\n\n        * dwarf2out.c (die_struct): Remove die_attr_last and die_child_last.\n        (add_dwarf_attr, add_child_die): Just push onto the front.\n        (reverse_die_lists): New fn.\n        (add_sibling_attributes): Use it.\n        (push_decl_scope): Reorganize.\n        (gen_struct_or_union_type_die): Don't add a DW_AT_containing_type\n        that points to ourself.\n        (add_name_and_src_coords_attributes): Don't set file and line for\n        an artificial decl.\n        (gen_subprogram_die): An artificial function doesn't need to match\n        file and line.\n        (gen_compile_unit_die): Return the generated die.  Only add\n        AT_comp_dir if the filename is relative.\n        (remove_AT): Simplify loop.  Also free string values.\n        (output_die): A DIE ref can't be null.\n        (output_value_format, value_format): Take a dw_attr_ref.\n        (dwarf_last_decl, is_extern_subr_die, sibling_offset): Remove.\n        (AT_class, AT_flag, AT_int, AT_unsigned, AT_string, AT_ref, AT_loc,\n        AT_addr, AT_lbl): New fns.\n        (various): Use them.\n        (various): Constify.\n\nFrom-SVN: r30624", "tree": {"sha": "3b32c5b24f1b3eb143a51a0a4a9f083d9a3c4a8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b32c5b24f1b3eb143a51a0a4a9f083d9a3c4a8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a96c67ec898a25a760997e6b51b4f5832f671fa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a96c67ec898a25a760997e6b51b4f5832f671fa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a96c67ec898a25a760997e6b51b4f5832f671fa1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a96c67ec898a25a760997e6b51b4f5832f671fa1/comments", "author": null, "committer": null, "parents": [{"sha": "54f3b5c2f14c4041de7a05c245988a2a5e17fb14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54f3b5c2f14c4041de7a05c245988a2a5e17fb14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54f3b5c2f14c4041de7a05c245988a2a5e17fb14"}], "stats": {"total": 590, "additions": 306, "deletions": 284}, "files": [{"sha": "10f3f627373f043ca4c5cdf9013b43b05f8e1600", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96c67ec898a25a760997e6b51b4f5832f671fa1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96c67ec898a25a760997e6b51b4f5832f671fa1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a96c67ec898a25a760997e6b51b4f5832f671fa1", "patch": "@@ -1,3 +1,27 @@\n+1999-11-22  Jason Merrill  <jason@casey.cygnus.com>\n+\n+\t* dwarf2out.c (die_struct): Remove die_attr_last and die_child_last.\n+\t(add_dwarf_attr, add_child_die): Just push onto the front.\n+\t(reverse_die_lists): New fn.\n+\t(add_sibling_attributes): Use it.\n+\t(push_decl_scope): Reorganize.\n+\t(gen_struct_or_union_type_die): Don't add a DW_AT_containing_type \n+\tthat points to ourself.\n+\t(add_name_and_src_coords_attributes): Don't set file and line for\n+\tan artificial decl.\n+\t(gen_subprogram_die): An artificial function doesn't need to match\n+\tfile and line.\n+\t(gen_compile_unit_die): Return the generated die.  Only add \n+\tAT_comp_dir if the filename is relative.\n+\t(remove_AT): Simplify loop.  Also free string values.\n+\t(output_die): A DIE ref can't be null.\n+\t(output_value_format, value_format): Take a dw_attr_ref.\n+\t(dwarf_last_decl, is_extern_subr_die, sibling_offset): Remove.\n+\t(AT_class, AT_flag, AT_int, AT_unsigned, AT_string, AT_ref, AT_loc,\n+\tAT_addr, AT_lbl): New fns.\n+\t(various): Use them.\n+\t(various): Constify.\n+\n Mon Nov 22 23:53:50 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* combine.c (combine_simplify_rtx): When handling a SUBREG,"}, {"sha": "884a518dec2df72952bef05d9e6ea5afee8c0c2c", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 282, "deletions": 284, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a96c67ec898a25a760997e6b51b4f5832f671fa1/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a96c67ec898a25a760997e6b51b4f5832f671fa1/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=a96c67ec898a25a760997e6b51b4f5832f671fa1", "patch": "@@ -21,10 +21,7 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* TODO: Implement .debug_str handling.\n-\t Share .debug_str entries via comdat.\n-         Use compact DIE references; we don't always need a 4-byte reference.\n-\t   (maybe; would it be worth the larger abbrev section?)\n+/* TODO: Implement .debug_str handling, and share entries somehow.\n \t Eliminate duplicates by putting common info in a separate section\n \t   to be collected by the linker and referring to it with\n \t   DW_FORM_ref_addr.\n@@ -68,6 +65,10 @@ Boston, MA 02111-1307, USA.  */\n # define assert(e) do { if (! (e)) abort (); } while (0)\n #endif\n \n+#ifndef DIR_SEPARATOR\n+#define DIR_SEPARATOR '/'\n+#endif\n+\n /* Decide whether we want to emit frame unwind information for the current\n    translation unit.  */\n \n@@ -2073,10 +2074,8 @@ typedef struct die_struct\n {\n   enum dwarf_tag die_tag;\n   dw_attr_ref die_attr;\n-  dw_attr_ref die_attr_last;\n   dw_die_ref die_parent;\n   dw_die_ref die_child;\n-  dw_die_ref die_child_last;\n   dw_die_ref die_sib;\n   dw_offset die_offset;\n   unsigned long die_abbrev;\n@@ -2362,12 +2361,6 @@ static int current_function_has_inlines;\n static int comp_unit_has_inlines;\n #endif\n \n-/* A pointer to the ..._DECL node which we have most recently been working\n-   on.  We keep this around just in case something about it looks screwy and\n-   we want to tell the user what the source coordinates for the actual\n-   declaration are.  */\n-static tree dwarf_last_decl;\n-\n /* Forward declarations for functions defined in this file.  */\n \n static void addr_const_to_string\tPROTO((dyn_string_t, rtx));\n@@ -2418,12 +2411,11 @@ static void add_AT_lbl_id\t\tPROTO((dw_die_ref,\n \t\t\t\t\t       enum dwarf_attribute, char *));\n static void add_AT_lbl_offset\t\tPROTO((dw_die_ref,\n \t\t\t\t\t       enum dwarf_attribute, char *));\n-static int is_extern_subr_die\t\tPROTO((dw_die_ref));\n static dw_attr_ref get_AT\t\tPROTO((dw_die_ref,\n \t\t\t\t\t       enum dwarf_attribute));\n-static char *get_AT_low_pc\t\tPROTO((dw_die_ref));\n-static char *get_AT_hi_pc\t\tPROTO((dw_die_ref));\n-static char *get_AT_string\t\tPROTO((dw_die_ref,\n+static const char *get_AT_low_pc\tPROTO((dw_die_ref));\n+static const char *get_AT_hi_pc\t\tPROTO((dw_die_ref));\n+static const char *get_AT_string\tPROTO((dw_die_ref,\n \t\t\t\t\t       enum dwarf_attribute));\n static int get_AT_flag\t\t\tPROTO((dw_die_ref,\n \t\t\t\t\t       enum dwarf_attribute));\n@@ -2449,7 +2441,7 @@ static void print_die\t\t\tPROTO((dw_die_ref, FILE *));\n static void print_dwarf_line_table\tPROTO((FILE *));\n static void add_sibling_attributes\tPROTO((dw_die_ref));\n static void build_abbrev_table\t\tPROTO((dw_die_ref));\n-static unsigned long size_of_string\tPROTO((char *));\n+static unsigned long size_of_string\tPROTO((const char *));\n static unsigned long size_of_loc_descr\tPROTO((dw_loc_descr_ref));\n static unsigned long size_of_locs\tPROTO((dw_loc_descr_ref));\n static int constant_size\t\tPROTO((long unsigned));\n@@ -2458,11 +2450,10 @@ static void calc_die_sizes\t\tPROTO((dw_die_ref));\n static unsigned long size_of_line_prolog\tPROTO((void));\n static unsigned long size_of_pubnames\tPROTO((void));\n static unsigned long size_of_aranges\tPROTO((void));\n-static enum dwarf_form value_format\tPROTO((dw_val_ref));\n-static void output_value_format\t\tPROTO((dw_val_ref));\n+static enum dwarf_form value_format\tPROTO((dw_attr_ref));\n+static void output_value_format\t\tPROTO((dw_attr_ref));\n static void output_abbrev_section\tPROTO((void));\n static void output_loc_operands\t\tPROTO((dw_loc_descr_ref));\n-static unsigned long sibling_offset\tPROTO((dw_die_ref));\n static void output_die\t\t\tPROTO((dw_die_ref));\n static void output_compilation_unit_header PROTO((void));\n static const char *dwarf2_name\t\tPROTO((tree, int));\n@@ -2536,7 +2527,7 @@ static void gen_lexical_block_die\tPROTO((tree, dw_die_ref, int));\n static void gen_inlined_subroutine_die\tPROTO((tree, dw_die_ref, int));\n static void gen_field_die\t\tPROTO((tree, dw_die_ref));\n static void gen_ptr_to_mbr_type_die\tPROTO((tree, dw_die_ref));\n-static void gen_compile_unit_die\tPROTO((char *));\n+static dw_die_ref gen_compile_unit_die\tPROTO((const char *));\n static void gen_string_type_die\t\tPROTO((tree, dw_die_ref));\n static void gen_inheritance_die\t\tPROTO((tree, dw_die_ref));\n static void gen_member_die\t\tPROTO((tree, dw_die_ref));\n@@ -2672,11 +2663,11 @@ static char debug_line_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n /* We allow a language front-end to designate a function that is to be\n    called to \"demangle\" any name before it it put into a DIE.  */\n \n-static char *(*demangle_name_func) PROTO((char *));\n+static const char *(*demangle_name_func) PROTO((const char *));\n \n void\n dwarf2out_set_demangle_name_func (func)\n-     char *(*func) PROTO((char *));\n+     const char *(*func) PROTO((const char *));\n {\n   demangle_name_func = func;\n }\n@@ -3615,7 +3606,8 @@ decl_class_context (decl)\n   return context;\n }\n \f\n-/* Add an attribute/value pair to a DIE */\n+/* Add an attribute/value pair to a DIE.  We build the lists up in reverse\n+   addition order, and correct that in add_sibling_attributes.  */\n \n static inline void\n add_dwarf_attr (die, attr)\n@@ -3624,19 +3616,18 @@ add_dwarf_attr (die, attr)\n {\n   if (die != NULL && attr != NULL)\n     {\n-      if (die->die_attr == NULL)\n-\t{\n-\t  die->die_attr = attr;\n-\t  die->die_attr_last = attr;\n-\t}\n-      else\n-\t{\n-\t  die->die_attr_last->dw_attr_next = attr;\n-\t  die->die_attr_last = attr;\n-\t}\n+      attr->dw_attr_next = die->die_attr;\n+      die->die_attr = attr;\n     }\n }\n \n+static inline dw_val_class\n+AT_class (a)\n+     dw_attr_ref a;\n+{\n+  return a->dw_attr_val.val_class;\n+}\n+\n /* Add a flag value attribute to a DIE.  */\n \n static inline void\n@@ -3654,6 +3645,16 @@ add_AT_flag (die, attr_kind, flag)\n   add_dwarf_attr (die, attr);\n }\n \n+static inline unsigned\n+AT_flag (a)\n+     register dw_attr_ref a;\n+{\n+  if (a && AT_class (a) == dw_val_class_flag)\n+    return a->dw_attr_val.v.val_flag;\n+\n+  return 0;\n+}\n+\n /* Add a signed integer attribute value to a DIE.  */\n \n static inline void\n@@ -3671,6 +3672,16 @@ add_AT_int (die, attr_kind, int_val)\n   add_dwarf_attr (die, attr);\n }\n \n+static inline long int\n+AT_int (a)\n+     register dw_attr_ref a;\n+{\n+  if (a && AT_class (a) == dw_val_class_const)\n+    return a->dw_attr_val.v.val_int;\n+\n+  return 0;\n+}\n+\n /* Add an unsigned integer attribute value to a DIE.  */\n \n static inline void\n@@ -3688,6 +3699,16 @@ add_AT_unsigned (die, attr_kind, unsigned_val)\n   add_dwarf_attr (die, attr);\n }\n \n+static inline unsigned long\n+AT_unsigned (a)\n+     register dw_attr_ref a;\n+{\n+  if (a && AT_class (a) == dw_val_class_unsigned_const)\n+    return a->dw_attr_val.v.val_unsigned;\n+\n+  return 0;\n+}\n+\n /* Add an unsigned double integer attribute value to a DIE.  */\n \n static inline void\n@@ -3743,6 +3764,16 @@ add_AT_string (die, attr_kind, str)\n   add_dwarf_attr (die, attr);\n }\n \n+static inline const char *\n+AT_string (a)\n+     register dw_attr_ref a;\n+{\n+  if (a && AT_class (a) == dw_val_class_str)\n+    return a->dw_attr_val.v.val_str;\n+\n+  return NULL;\n+}\n+\n /* Add a DIE reference attribute value to a DIE.  */\n \n static inline void\n@@ -3760,6 +3791,16 @@ add_AT_die_ref (die, attr_kind, targ_die)\n   add_dwarf_attr (die, attr);\n }\n \n+static inline dw_die_ref\n+AT_ref (a)\n+     register dw_attr_ref a;\n+{\n+  if (a && AT_class (a) == dw_val_class_die_ref)\n+    return a->dw_attr_val.v.val_die_ref;\n+\n+  return NULL;\n+}\n+\n /* Add an FDE reference attribute value to a DIE.  */\n \n static inline void\n@@ -3794,6 +3835,16 @@ add_AT_loc (die, attr_kind, loc)\n   add_dwarf_attr (die, attr);\n }\n \n+static inline dw_loc_descr_ref\n+AT_loc (a)\n+     register dw_attr_ref a;\n+{\n+  if (a && AT_class (a) == dw_val_class_loc)\n+    return a->dw_attr_val.v.val_loc;\n+\n+  return NULL;\n+}\n+\n /* Add an address constant attribute value to a DIE.  */\n \n static inline void\n@@ -3811,6 +3862,16 @@ add_AT_addr (die, attr_kind, addr)\n   add_dwarf_attr (die, attr);\n }\n \n+static inline const char *\n+AT_addr (a)\n+     register dw_attr_ref a;\n+{\n+  if (a && AT_class (a) == dw_val_class_addr)\n+    return a->dw_attr_val.v.val_addr;\n+\n+  return NULL;\n+}\n+\n /* Add a label identifier attribute value to a DIE.  */\n \n static inline void\n@@ -3841,37 +3902,20 @@ add_AT_lbl_offset (die, attr_kind, label)\n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n   attr->dw_attr_val.val_class = dw_val_class_lbl_offset;\n-  attr->dw_attr_val.v.val_lbl_id = label;\n+  attr->dw_attr_val.v.val_lbl_id = xstrdup (label);\n   add_dwarf_attr (die, attr);\n   \n }\n \n-/* Test if die refers to an external subroutine.  */\n-\n-static inline int\n-is_extern_subr_die (die)\n-     register dw_die_ref die;\n+static inline const char *\n+AT_lbl (a)\n+     register dw_attr_ref a;\n {\n-  register dw_attr_ref a;\n-  register int is_subr = FALSE;\n-  register int is_extern = FALSE;\n-\n-  if (die != NULL && die->die_tag == DW_TAG_subprogram)\n-    {\n-      is_subr = TRUE;\n-      for (a = die->die_attr; a != NULL; a = a->dw_attr_next)\n-\t{\n-\t  if (a->dw_attr == DW_AT_external\n-\t      && a->dw_attr_val.val_class == dw_val_class_flag\n-\t      && a->dw_attr_val.v.val_flag != 0)\n-\t    {\n-\t      is_extern = TRUE;\n-\t      break;\n-\t    }\n-\t}\n-    }\n+  if (a && (AT_class (a) == dw_val_class_lbl_id\n+\t    || AT_class (a) == dw_val_class_lbl_offset))\n+    return a->dw_attr_val.v.val_lbl_id;\n \n-  return is_subr && is_extern;\n+  return NULL;\n }\n \n /* Get the attribute of type attr_kind.  */\n@@ -3893,7 +3937,7 @@ get_AT (die, attr_kind)\n \n \t  if (a->dw_attr == DW_AT_specification\n \t      || a->dw_attr == DW_AT_abstract_origin)\n-\t    spec = a->dw_attr_val.v.val_die_ref;\n+\t    spec = AT_ref (a);\n \t}\n \n       if (spec)\n@@ -3908,49 +3952,37 @@ get_AT (die, attr_kind)\n    either not prsent, or if it cannot be represented as an\n    assembler label identifier.  */\n \n-static inline char *\n+static inline const char *\n get_AT_low_pc (die)\n      register dw_die_ref die;\n {\n   register dw_attr_ref a = get_AT (die, DW_AT_low_pc);\n-\n-  if (a && a->dw_attr_val.val_class == dw_val_class_lbl_id)\n-    return a->dw_attr_val.v.val_lbl_id;\n-\n-  return NULL;\n+  return AT_lbl (a);\n }\n \n /* Return the \"high pc\" attribute value, typically associated with\n    a subprogram DIE.  Return null if the \"high pc\" attribute is\n    either not prsent, or if it cannot be represented as an\n    assembler label identifier.  */\n \n-static inline char *\n+static inline const char *\n get_AT_hi_pc (die)\n      register dw_die_ref die;\n {\n   register dw_attr_ref a = get_AT (die, DW_AT_high_pc);\n-\n-  if (a && a->dw_attr_val.val_class == dw_val_class_lbl_id)\n-    return a->dw_attr_val.v.val_lbl_id;\n-\n-  return NULL;\n+  return AT_lbl (a);\n }\n \n /* Return the value of the string attribute designated by ATTR_KIND, or\n    NULL if it is not present.  */\n \n-static inline char *\n+static inline const char *\n get_AT_string (die, attr_kind)\n      register dw_die_ref die;\n      register enum dwarf_attribute attr_kind;\n {\n   register dw_attr_ref a = get_AT (die, attr_kind);\n-\n-  if (a && a->dw_attr_val.val_class == dw_val_class_str)\n-    return a->dw_attr_val.v.val_str;\n-\n-  return NULL;\n+  return AT_string (a);\n }\n \n /* Return the value of the flag attribute designated by ATTR_KIND, or -1\n@@ -3962,11 +3994,7 @@ get_AT_flag (die, attr_kind)\n      register enum dwarf_attribute attr_kind;\n {\n   register dw_attr_ref a = get_AT (die, attr_kind);\n-\n-  if (a && a->dw_attr_val.val_class == dw_val_class_flag)\n-    return a->dw_attr_val.v.val_flag;\n-\n-  return -1;\n+  return AT_flag (a);\n }\n \n /* Return the value of the unsigned attribute designated by ATTR_KIND, or 0\n@@ -3978,11 +4006,16 @@ get_AT_unsigned (die, attr_kind)\n      register enum dwarf_attribute attr_kind;\n {\n   register dw_attr_ref a = get_AT (die, attr_kind);\n+  return AT_unsigned (a);\n+}\n \n-  if (a && a->dw_attr_val.val_class == dw_val_class_unsigned_const)\n-    return a->dw_attr_val.v.val_unsigned;\n-\n-  return 0;\n+static inline dw_die_ref\n+get_AT_ref (die, attr_kind)\n+     dw_die_ref die;\n+     register enum dwarf_attribute attr_kind;\n+{\n+  register dw_attr_ref a = get_AT (die, attr_kind);\n+  return AT_ref (a);\n }\n \n static inline int\n@@ -4009,35 +4042,36 @@ remove_AT (die, attr_kind)\n      register dw_die_ref die;\n      register enum dwarf_attribute attr_kind;\n {\n-  register dw_attr_ref a;\n+  register dw_attr_ref *p;\n   register dw_attr_ref removed = NULL;\n \n   if (die != NULL)\n     {\n-      if (die->die_attr->dw_attr == attr_kind)\n-\t{\n-\t  removed = die->die_attr;\n-\t  if (die->die_attr_last == die->die_attr)\n-\t    die->die_attr_last = NULL;\n-\n-\t  die->die_attr = die->die_attr->dw_attr_next;\n-\t}\n+      for (p = &(die->die_attr); *p; p = &((*p)->dw_attr_next))\n+\tif ((*p)->dw_attr == attr_kind)\n+\t  {\n+\t    removed = *p;\n+\t    *p = (*p)->dw_attr_next;\n+\t    break;\n+\t  }\n \n-      else\n-\tfor (a = die->die_attr; a->dw_attr_next != NULL;\n-\t     a = a->dw_attr_next)\n-\t  if (a->dw_attr_next->dw_attr == attr_kind)\n+      if (removed != 0)\n+\t{\n+\t  switch (AT_class (removed))\n \t    {\n-\t      removed = a->dw_attr_next;\n-\t      if (die->die_attr_last == a->dw_attr_next)\n-\t\tdie->die_attr_last = a;\n+\t    case dw_val_class_addr:\n+\t    case dw_val_class_str:\n+\t    case dw_val_class_lbl_id:\n+\t    case dw_val_class_lbl_offset:\n+\t      free (removed->dw_attr_val.v.val_str);\n+\t      break;\n \n-\t      a->dw_attr_next = a->dw_attr_next->dw_attr_next;\n+\t    default:\n \t      break;\n \t    }\n \n-      if (removed != 0)\n-\tfree (removed);\n+\t  free (removed);\n+\t}\n     }\n }\n \n@@ -4050,7 +4084,6 @@ remove_children (die)\n   register dw_die_ref child_die = die->die_child;\n \n   die->die_child = NULL;\n-  die->die_child_last = NULL;\n \n   while (child_die != NULL)\n     {\n@@ -4071,7 +4104,8 @@ remove_children (die)\n     }\n }\n \n-/* Add a child DIE below its parent.  */\n+/* Add a child DIE below its parent.  We build the lists up in reverse\n+   addition order, and correct that in add_sibling_attributes.  */\n \n static inline void\n add_child_die (die, child_die)\n@@ -4083,18 +4117,8 @@ add_child_die (die, child_die)\n       if (die == child_die)\n \tabort ();\n       child_die->die_parent = die;\n-      child_die->die_sib = NULL;\n-\n-      if (die->die_child == NULL)\n-\t{\n-\t  die->die_child = child_die;\n-\t  die->die_child_last = child_die;\n-\t}\n-      else\n-\t{\n-\t  die->die_child_last->die_sib = child_die;\n-\t  die->die_child_last = child_die;\n-\t}\n+      child_die->die_sib = die->die_child;\n+      die->die_child = child_die;\n     }\n }\n \n@@ -4113,9 +4137,7 @@ new_die (tag_value, parent_die)\n   die->die_child = NULL;\n   die->die_parent = NULL;\n   die->die_sib = NULL;\n-  die->die_child_last = NULL;\n   die->die_attr = NULL;\n-  die->die_attr_last = NULL;\n \n   if (parent_die != NULL)\n     add_child_die (parent_die, die);\n@@ -4271,7 +4293,7 @@ print_die (die, outfile)\n       print_spaces (outfile);\n       fprintf (outfile, \"  %s: \", dwarf_attr_name (a->dw_attr));\n \n-      switch (a->dw_attr_val.val_class)\n+      switch (AT_class (a))\n \t{\n \tcase dw_val_class_addr:\n \t  fprintf (outfile, \"address\");\n@@ -4280,10 +4302,10 @@ print_die (die, outfile)\n \t  fprintf (outfile, \"location descriptor\");\n \t  break;\n \tcase dw_val_class_const:\n-\t  fprintf (outfile, \"%ld\", a->dw_attr_val.v.val_int);\n+\t  fprintf (outfile, \"%ld\", AT_int (a));\n \t  break;\n \tcase dw_val_class_unsigned_const:\n-\t  fprintf (outfile, \"%lu\", a->dw_attr_val.v.val_unsigned);\n+\t  fprintf (outfile, \"%lu\", AT_unsigned (a));\n \t  break;\n \tcase dw_val_class_long_long:\n \t  fprintf (outfile, \"constant (%lu,%lu)\",\n@@ -4294,22 +4316,21 @@ print_die (die, outfile)\n \t  fprintf (outfile, \"floating-point constant\");\n \t  break;\n \tcase dw_val_class_flag:\n-\t  fprintf (outfile, \"%u\", a->dw_attr_val.v.val_flag);\n+\t  fprintf (outfile, \"%u\", AT_flag (a));\n \t  break;\n \tcase dw_val_class_die_ref:\n-\t  if (a->dw_attr_val.v.val_die_ref != NULL)\n-\t    fprintf (outfile, \"die -> %lu\",\n-\t\t     a->dw_attr_val.v.val_die_ref->die_offset);\n+\t  if (AT_ref (a) != NULL)\n+\t    fprintf (outfile, \"die -> %lu\", AT_ref (a)->die_offset);\n \t  else\n \t    fprintf (outfile, \"die -> <null>\");\n \t  break;\n \tcase dw_val_class_lbl_id:\n \tcase dw_val_class_lbl_offset:\n-\t  fprintf (outfile, \"label: %s\", a->dw_attr_val.v.val_lbl_id);\n+\t  fprintf (outfile, \"label: %s\", AT_lbl (a));\n \t  break;\n \tcase dw_val_class_str:\n-\t  if (a->dw_attr_val.v.val_str != NULL)\n-\t    fprintf (outfile, \"\\\"%s\\\"\", a->dw_attr_val.v.val_str);\n+\t  if (AT_string (a) != NULL)\n+\t    fprintf (outfile, \"\\\"%s\\\"\", AT_string (a));\n \t  else\n \t    fprintf (outfile, \"<null>\");\n \t  break;\n@@ -4374,31 +4395,50 @@ debug_dwarf ()\n     print_dwarf_line_table (stderr);\n }\n \f\n-/* Traverse the DIE, and add a sibling attribute if it may have the\n-   effect of speeding up access to siblings.  To save some space,\n-   avoid generating sibling attributes for DIE's without children.  */\n+/* We build up the lists of children and attributes by pushing new ones\n+   onto the beginning of the list.  Reverse the lists for DIE so that\n+   they are in order of addition.  */\n \n static void\n-add_sibling_attributes(die)\n+reverse_die_lists (die)\n      register dw_die_ref die;\n {\n-  register dw_die_ref c;\n-  register dw_attr_ref attr;\n-  if (die != comp_unit_die && die->die_child != NULL)\n-    {\n-      attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n-      attr->dw_attr_next = NULL;\n-      attr->dw_attr = DW_AT_sibling;\n-      attr->dw_attr_val.val_class = dw_val_class_die_ref;\n-      attr->dw_attr_val.v.val_die_ref = die->die_sib;\n+  register dw_die_ref c, cp, cn;\n+  register dw_attr_ref a, ap, an;\n \n-      /* Add the sibling link to the front of the attribute list.  */\n-      attr->dw_attr_next = die->die_attr;\n-      if (die->die_attr == NULL)\n-\tdie->die_attr_last = attr;\n+  for (a = die->die_attr, ap = 0; a; a = an)\n+    {\n+      an = a->dw_attr_next;\n+      a->dw_attr_next = ap;\n+      ap = a;\n+    }\n+  die->die_attr = ap;\n \n-      die->die_attr = attr;\n+  for (c = die->die_child, cp = 0; c; c = cn)\n+    {\n+      cn = c->die_sib;\n+      c->die_sib = cp;\n+      cp = c;\n     }\n+  die->die_child = cp;\n+}\n+\n+/* Traverse the DIE, reverse its lists of attributes and children, and\n+   add a sibling attribute if it may have the effect of speeding up\n+   access to siblings.  To save some space, avoid generating sibling\n+   attributes for DIE's without children.  */\n+\n+static void\n+add_sibling_attributes (die)\n+     register dw_die_ref die;\n+{\n+  register dw_die_ref c;\n+\n+  reverse_die_lists (die);\n+\n+  if (die != comp_unit_die && die->die_sib && die->die_child != NULL)\n+    /* Add the sibling link to the front of the attribute list.  */\n+    add_AT_die_ref (die, DW_AT_sibling, die->die_sib);\n \n   for (c = die->die_child; c != NULL; c = c->die_sib)\n     add_sibling_attributes (c);\n@@ -4432,8 +4472,7 @@ build_abbrev_table (die)\n \t      while (a_attr != NULL && d_attr != NULL)\n \t\t{\n \t\t  if ((a_attr->dw_attr != d_attr->dw_attr)\n-\t\t      || (value_format (&a_attr->dw_attr_val)\n-\t\t\t  != value_format (&d_attr->dw_attr_val)))\n+\t\t      || (value_format (a_attr) != value_format (d_attr)))\n \t\t    break;\n \n \t\t  a_attr = a_attr->dw_attr_next;\n@@ -4478,7 +4517,7 @@ build_abbrev_table (die)\n \n static unsigned long\n size_of_string (str)\n-     register char *str;\n+     register const char *str;\n {\n   return strlen (str) + 1;\n }\n@@ -4632,15 +4671,14 @@ size_of_die (die)\n   size += size_of_uleb128 (die->die_abbrev);\n   for (a = die->die_attr; a != NULL; a = a->dw_attr_next)\n     {\n-      switch (a->dw_attr_val.val_class)\n+      switch (AT_class (a))\n \t{\n \tcase dw_val_class_addr:\n \t  size += PTR_SIZE;\n \t  break;\n \tcase dw_val_class_loc:\n \t  {\n-\t    register unsigned long lsize\n-\t      = size_of_locs (a->dw_attr_val.v.val_loc);\n+\t    register unsigned long lsize = size_of_locs (AT_loc (a));\n \n \t    /* Block length.  */\n \t    size += constant_size (lsize);\n@@ -4651,7 +4689,7 @@ size_of_die (die)\n \t  size += 4;\n \t  break;\n \tcase dw_val_class_unsigned_const:\n-\t  size += constant_size (a->dw_attr_val.v.val_unsigned);\n+\t  size += constant_size (AT_unsigned (a));\n \t  break;\n \tcase dw_val_class_long_long:\n \t  size += 1 + 8; /* block */\n@@ -4675,7 +4713,7 @@ size_of_die (die)\n \t  size += DWARF_OFFSET_SIZE;\n \t  break;\n \tcase dw_val_class_str:\n-\t  size += size_of_string (a->dw_attr_val.v.val_str);\n+\t  size += size_of_string (AT_string (a));\n \t  break;\n \tdefault:\n \t  abort ();\n@@ -4787,15 +4825,15 @@ size_of_aranges ()\n /* Select the encoding of an attribute value.  */\n \n static enum dwarf_form\n-value_format (v)\n-     dw_val_ref v;\n+value_format (a)\n+     dw_attr_ref a;\n {\n-  switch (v->val_class)\n+  switch (a->dw_attr_val.val_class)\n     {\n     case dw_val_class_addr:\n       return DW_FORM_addr;\n     case dw_val_class_loc:\n-      switch (constant_size (size_of_locs (v->v.val_loc)))\n+      switch (constant_size (size_of_locs (AT_loc (a))))\n \t{\n \tcase 1:\n \t  return DW_FORM_block1;\n@@ -4807,7 +4845,7 @@ value_format (v)\n     case dw_val_class_const:\n       return DW_FORM_data4;\n     case dw_val_class_unsigned_const:\n-      switch (constant_size (v->v.val_unsigned))\n+      switch (constant_size (AT_unsigned (a)))\n \t{\n \tcase 1:\n \t  return DW_FORM_data1;\n@@ -4844,10 +4882,10 @@ value_format (v)\n /* Output the encoding of an attribute value.  */\n \n static void\n-output_value_format (v)\n-     dw_val_ref v;\n+output_value_format (a)\n+     dw_attr_ref a;\n {\n-  enum dwarf_form form = value_format (v);\n+  enum dwarf_form form = value_format (a);\n \n   output_uleb128 (form);\n   if (flag_debug_asm)\n@@ -4900,7 +4938,7 @@ output_abbrev_section ()\n \t\t     dwarf_attr_name (a_attr->dw_attr));\n \n \t  fputc ('\\n', asm_out_file);\n-\t  output_value_format (&a_attr->dw_attr_val);\n+\t  output_value_format (a_attr);\n \t}\n \n       fprintf (asm_out_file, \"\\t%s\\t0,0\\n\", ASM_BYTE_OP);\n@@ -5029,22 +5067,6 @@ output_loc_operands (loc)\n     }\n }\n \n-/* Compute the offset of a sibling.  */\n-\n-static unsigned long\n-sibling_offset (die)\n-     dw_die_ref die;\n-{\n-  unsigned long offset;\n-\n-  if (die->die_child_last == NULL)\n-    offset = die->die_offset + size_of_die (die);\n-  else\n-    offset = sibling_offset (die->die_child_last) + 1;\n-\n-  return offset;\n-}\n-\n /* Output the DIE and its attributes.  Called recursively to generate\n    the definitions of each child DIE.  */\n \n@@ -5054,7 +5076,6 @@ output_die (die)\n {\n   register dw_attr_ref a;\n   register dw_die_ref c;\n-  register unsigned long ref_offset;\n   register unsigned long size;\n   register dw_loc_descr_ref loc;\n \n@@ -5067,15 +5088,14 @@ output_die (die)\n \n   for (a = die->die_attr; a != NULL; a = a->dw_attr_next)\n     {\n-      switch (a->dw_attr_val.val_class)\n+      switch (AT_class (a))\n \t{\n \tcase dw_val_class_addr:\n-\t  ASM_OUTPUT_DWARF_ADDR_CONST (asm_out_file,\n-\t\t\t\t       a->dw_attr_val.v.val_addr);\n+\t  ASM_OUTPUT_DWARF_ADDR_CONST (asm_out_file, AT_addr (a));\n \t  break;\n \n \tcase dw_val_class_loc:\n-\t  size = size_of_locs (a->dw_attr_val.v.val_loc);\n+\t  size = size_of_locs (AT_loc (a));\n \n \t  /* Output the block length for this list of location operations.  */\n \t  switch (constant_size (size))\n@@ -5095,8 +5115,7 @@ output_die (die)\n \t\t     ASM_COMMENT_START, dwarf_attr_name (a->dw_attr));\n \n \t  fputc ('\\n', asm_out_file);\n-\t  for (loc = a->dw_attr_val.v.val_loc; loc != NULL;\n-\t       loc = loc->dw_loc_next)\n+\t  for (loc = AT_loc (a); loc != NULL; loc = loc->dw_loc_next)\n \t    {\n \t      /* Output the opcode.  */\n \t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, loc->dw_loc_opc);\n@@ -5112,23 +5131,20 @@ output_die (die)\n \t  break;\n \n \tcase dw_val_class_const:\n-\t  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, a->dw_attr_val.v.val_int);\n+\t  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, AT_int (a));\n \t  break;\n \n \tcase dw_val_class_unsigned_const:\n-\t  switch (constant_size (a->dw_attr_val.v.val_unsigned))\n+\t  switch (constant_size (AT_unsigned (a)))\n \t    {\n \t    case 1:\n-\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file,\n-\t\t\t\t      a->dw_attr_val.v.val_unsigned);\n+\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, AT_unsigned (a));\n \t      break;\n \t    case 2:\n-\t      ASM_OUTPUT_DWARF_DATA2 (asm_out_file,\n-\t\t\t\t      a->dw_attr_val.v.val_unsigned);\n+\t      ASM_OUTPUT_DWARF_DATA2 (asm_out_file, AT_unsigned (a));\n \t      break;\n \t    case 4:\n-\t      ASM_OUTPUT_DWARF_DATA4 (asm_out_file,\n-\t\t\t\t      a->dw_attr_val.v.val_unsigned);\n+\t      ASM_OUTPUT_DWARF_DATA4 (asm_out_file, AT_unsigned (a));\n \t      break;\n \t    case 8:\n \t      ASM_OUTPUT_DWARF_DATA8 (asm_out_file,\n@@ -5182,18 +5198,11 @@ output_die (die)\n \t  }\n \n \tcase dw_val_class_flag:\n-\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, a->dw_attr_val.v.val_flag);\n+\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, AT_flag (a));\n \t  break;\n \n \tcase dw_val_class_die_ref:\n-\t  if (a->dw_attr_val.v.val_die_ref != NULL)\n-\t    ref_offset = a->dw_attr_val.v.val_die_ref->die_offset;\n-\t  else if (a->dw_attr == DW_AT_sibling)\n-\t    ref_offset = sibling_offset(die);\n-\t  else\n-\t    abort ();\n-\n-\t  ASM_OUTPUT_DWARF_DATA (asm_out_file, ref_offset);\n+\t  ASM_OUTPUT_DWARF_DATA (asm_out_file, AT_ref (a)->die_offset);\n \t  break;\n \n \tcase dw_val_class_fde_ref:\n@@ -5207,29 +5216,28 @@ output_die (die)\n \t  break;\n \n \tcase dw_val_class_lbl_id:\n-\t  ASM_OUTPUT_DWARF_ADDR (asm_out_file, a->dw_attr_val.v.val_lbl_id);\n+\t  ASM_OUTPUT_DWARF_ADDR (asm_out_file, AT_lbl (a));\n \t  break;\n \n \tcase dw_val_class_lbl_offset:\n-\t  ASM_OUTPUT_DWARF_OFFSET (asm_out_file, a->dw_attr_val.v.val_lbl_id);\n+\t  ASM_OUTPUT_DWARF_OFFSET (asm_out_file, AT_lbl (a));\n \t  break;\n \n \tcase dw_val_class_str:\n \t  if (flag_debug_asm)\n-\t    ASM_OUTPUT_DWARF_STRING (asm_out_file, a->dw_attr_val.v.val_str);\n+\t    ASM_OUTPUT_DWARF_STRING (asm_out_file, AT_string (a));\n \t  else\n-\t    ASM_OUTPUT_ASCII (asm_out_file,\n-\t\t\t      a->dw_attr_val.v.val_str,\n-\t\t\t      (int) strlen (a->dw_attr_val.v.val_str) + 1);\n+\t    ASM_OUTPUT_ASCII (asm_out_file, AT_string (a),\n+\t\t\t      (int) strlen (AT_string (a)) + 1);\n \t  break;\n \n \tdefault:\n \t  abort ();\n \t}\n \n-      if (a->dw_attr_val.val_class != dw_val_class_loc\n-\t  && a->dw_attr_val.val_class != dw_val_class_long_long\n-\t  && a->dw_attr_val.val_class != dw_val_class_float)\n+      if (AT_class (a) != dw_val_class_loc\n+\t  && AT_class (a) != dw_val_class_long_long\n+\t  && AT_class (a) != dw_val_class_float)\n \t{\n \t  if (flag_debug_asm)\n \t    fprintf (asm_out_file, \"\\t%s %s\",\n@@ -5482,10 +5490,10 @@ output_aranges ()\n \n \t  dw_attr_ref a = get_AT (die, DW_AT_location);\n \t  dw_loc_descr_ref loc;\n-\t  if (! a || a->dw_attr_val.val_class != dw_val_class_loc)\n+\t  if (! a || AT_class (a) != dw_val_class_loc)\n \t    abort ();\n \n-\t  loc = a->dw_attr_val.v.val_loc;\n+\t  loc = AT_loc (a);\n \t  if (loc->dw_loc_opc != DW_OP_addr)\n \t    abort ();\n \n@@ -7505,7 +7513,8 @@ add_name_and_src_coords_attributes (die, decl)\n   if (decl_name != NULL && IDENTIFIER_POINTER (decl_name) != NULL)\n     {\n       add_name_attribute (die, dwarf2_name (decl, 0));\n-      add_src_coords_attributes (die, decl);\n+      if (! DECL_ARTIFICIAL (decl))\n+\tadd_src_coords_attributes (die, decl);\n \n       if ((TREE_CODE (decl) == FUNCTION_DECL || TREE_CODE (decl) == VAR_DECL)\n \t  && DECL_ASSEMBLER_NAME (decl) != DECL_NAME (decl))\n@@ -7520,9 +7529,6 @@ static void\n push_decl_scope (scope)\n      tree scope;\n {\n-  tree containing_scope;\n-  int i;\n-\n   /* Make room in the decl_scope_table, if necessary.  */\n   if (decl_scope_table_allocated == decl_scope_depth)\n     {\n@@ -7535,32 +7541,22 @@ push_decl_scope (scope)\n \n   decl_scope_table[decl_scope_depth].scope = scope;\n \n-  /* Sometimes, while recursively emitting subtypes within a class type,\n-     we end up recuring on a subtype at a higher level then the current\n-     subtype.  In such a case, we need to search the decl_scope_table to\n-     find the parent of this subtype.  */\n+  /* If we're starting to emit a global class while we're in the middle\n+     of emitting a function, we need to find the proper .previous.  */\n \n   if (AGGREGATE_TYPE_P (scope))\n-    containing_scope = TYPE_CONTEXT (scope);\n-  else\n-    containing_scope = NULL_TREE;\n-\n-  /* The normal case.  */\n-  if (decl_scope_depth == 0\n-      || containing_scope == NULL_TREE\n-      /* Ignore namespaces for the moment.  */\n-      || TREE_CODE (containing_scope) == NAMESPACE_DECL)\n-    decl_scope_table[decl_scope_depth].previous = decl_scope_depth - 1;\n-  else\n     {\n-      /* We need to search for the containing_scope.  If we don't find it,\n-         that's OK; we stick ourselves at global scope.  */\n+      tree containing_scope = TYPE_CONTEXT (scope);\n+      int i;\n+\n       for (i = decl_scope_depth - 1; i >= 0; --i)\n \tif (decl_scope_table[i].scope == containing_scope)\n \t  break;\n \n       decl_scope_table[decl_scope_depth].previous = i;\n     }\n+  else\n+    decl_scope_table[decl_scope_depth].previous = decl_scope_depth - 1;\n \n   decl_scope_depth++;\n }\n@@ -8256,12 +8252,13 @@ gen_subprogram_die (decl, context_die)\n \t debugger can find it.  For inlines, that is the concrete instance,\n \t so we can use the old DIE here.  For non-inline methods, we want a\n \t specification DIE at toplevel, so we need a new DIE.  For local\n-\t class methods, we just use the old DIE.  */\n+\t class methods, this doesn't apply; we just use the old DIE.  */\n       if ((DECL_ABSTRACT (decl) || old_die->die_parent == comp_unit_die\n \t   || context_die == NULL)\n-\t  && get_AT_unsigned (old_die, DW_AT_decl_file) == file_index\n-\t  && (get_AT_unsigned (old_die, DW_AT_decl_line)\n-\t      == (unsigned)DECL_SOURCE_LINE (decl)))\n+\t  && (DECL_ARTIFICIAL (decl)\n+\t      || (get_AT_unsigned (old_die, DW_AT_decl_file) == file_index\n+\t\t  && (get_AT_unsigned (old_die, DW_AT_decl_line)\n+\t\t      == (unsigned)DECL_SOURCE_LINE (decl)))))\n \t{\n \t  subr_die = old_die;\n \n@@ -8741,18 +8738,20 @@ gen_ptr_to_mbr_type_die (type, context_die)\n \n /* Generate the DIE for the compilation unit.  */\n \n-static void\n-gen_compile_unit_die (main_input_filename)\n-     register char *main_input_filename;\n+static dw_die_ref\n+gen_compile_unit_die (filename)\n+     register const char *filename;\n {\n+  register dw_die_ref die;\n   char producer[250];\n   char *wd = getpwd ();\n+  int language;\n \n-  comp_unit_die = new_die (DW_TAG_compile_unit, NULL);\n-  add_name_attribute (comp_unit_die, main_input_filename);\n+  die = new_die (DW_TAG_compile_unit, NULL);\n+  add_name_attribute (die, filename);\n \n-  if (wd != NULL)\n-    add_AT_string (comp_unit_die, DW_AT_comp_dir, wd);\n+  if (wd != NULL && filename[0] != DIR_SEPARATOR)\n+    add_AT_string (die, DW_AT_comp_dir, wd);\n \n   sprintf (producer, \"%s %s\", language_string, version_string);\n \n@@ -8767,30 +8766,24 @@ gen_compile_unit_die (main_input_filename)\n     strcat (producer, \" -g\");\n #endif\n \n-  add_AT_string (comp_unit_die, DW_AT_producer, producer);\n+  add_AT_string (die, DW_AT_producer, producer);\n \n   if (strcmp (language_string, \"GNU C++\") == 0)\n-    add_AT_unsigned (comp_unit_die, DW_AT_language, DW_LANG_C_plus_plus);\n-\n+    language = DW_LANG_C_plus_plus;\n   else if (strcmp (language_string, \"GNU Ada\") == 0)\n-    add_AT_unsigned (comp_unit_die, DW_AT_language, DW_LANG_Ada83);\n-\n+    language = DW_LANG_Ada83;\n   else if (strcmp (language_string, \"GNU F77\") == 0)\n-    add_AT_unsigned (comp_unit_die, DW_AT_language, DW_LANG_Fortran77);\n-\n+    language = DW_LANG_Fortran77;\n   else if (strcmp (language_string, \"GNU Pascal\") == 0)\n-    add_AT_unsigned (comp_unit_die, DW_AT_language, DW_LANG_Pascal83);\n-\n+    language = DW_LANG_Pascal83;\n   else if (flag_traditional)\n-    add_AT_unsigned (comp_unit_die, DW_AT_language, DW_LANG_C);\n-\n+    language = DW_LANG_C;\n   else\n-    add_AT_unsigned (comp_unit_die, DW_AT_language, DW_LANG_C89);\n+    language = DW_LANG_C89;\n \n-#if 0 /* unimplemented */\n-  if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n-    add_AT_unsigned (comp_unit_die, DW_AT_macro_info, 0);\n-#endif\n+  add_AT_unsigned (die, DW_AT_language, language);\n+\n+  return die;\n }\n \n /* Generate a DIE for a string type.  */\n@@ -8942,9 +8935,12 @@ gen_struct_or_union_type_die (type, context_die)\n \t{\n \t  tree vtype = DECL_FCONTEXT (TYPE_VFIELD (type));\n \n-\t  gen_type_die (vtype, context_die);\n-\t  add_AT_die_ref (type_die, DW_AT_containing_type,\n-\t\t\t  lookup_type_die (vtype));\n+\t  if (vtype != type)\n+\t    {\n+\t      gen_type_die (vtype, context_die);\n+\t      add_AT_die_ref (type_die, DW_AT_containing_type,\n+\t\t\t      lookup_type_die (vtype));\n+\t    }\n \t}\n     }\n   else\n@@ -9368,11 +9364,6 @@ gen_decl_die (decl, context_die)\n {\n   register tree origin;\n \n-  /* Make a note of the decl node we are going to be working on.  We may need \n-     to give the user the source coordinates of where it appeared in case we\n-     notice (later on) that something about it looks screwy.  */\n-  dwarf_last_decl = decl;\n-\n   if (TREE_CODE (decl) == ERROR_MARK)\n     return;\n \n@@ -9926,7 +9917,7 @@ dwarf2out_init (asm_out_file, main_input_filename)\n      will (typically) be a relative pathname and that this pathname should be \n      taken as being relative to the directory from which the compiler was\n      invoked when the given (base) source file was compiled.  */\n-  gen_compile_unit_die (main_input_filename);\n+  comp_unit_die = gen_compile_unit_die (main_input_filename);\n \n   ASM_GENERATE_INTERNAL_LABEL (text_end_label, TEXT_END_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (abbrev_section_label, ABBREV_SECTION_LABEL, 0);\n@@ -9941,9 +9932,11 @@ dwarf2out_init (asm_out_file, main_input_filename)\n \n   ASM_OUTPUT_SECTION (asm_out_file, ABBREV_SECTION);\n   ASM_OUTPUT_LABEL (asm_out_file, abbrev_section_label);\n-  ASM_OUTPUT_SECTION (asm_out_file, TEXT_SECTION);\n   if (DWARF2_GENERATE_TEXT_SECTION_LABEL)\n-    ASM_OUTPUT_LABEL (asm_out_file, text_section_label);\n+    {\n+      ASM_OUTPUT_SECTION (asm_out_file, TEXT_SECTION);\n+      ASM_OUTPUT_LABEL (asm_out_file, text_section_label);\n+    }\n   ASM_OUTPUT_SECTION (asm_out_file, DEBUG_INFO_SECTION);\n   ASM_OUTPUT_LABEL (asm_out_file, debug_info_section_label);\n   ASM_OUTPUT_SECTION (asm_out_file, DEBUG_LINE_SECTION);\n@@ -9958,7 +9951,6 @@ dwarf2out_finish ()\n {\n   limbo_die_node *node, *next_node;\n   dw_die_ref die;\n-  dw_attr_ref a;\n \n   /* Traverse the limbo die list, and add parent/child links.  The only\n      dies without parents that should be here are concrete instances of\n@@ -9972,23 +9964,24 @@ dwarf2out_finish ()\n \n       if (die->die_parent == NULL)\n \t{\n-\t  a = get_AT (die, DW_AT_abstract_origin);\n-\t  if (a)\n-\t    add_child_die (a->dw_attr_val.v.val_die_ref->die_parent, die);\n+\t  dw_die_ref origin = get_AT_ref (die, DW_AT_abstract_origin);\n+\t  if (origin)\n+\t    add_child_die (origin->die_parent, die);\n \t  else if (die == comp_unit_die)\n-\t      ;\n+\t    ;\n \t  else\n \t    abort ();\n \t}\n       free (node);\n     }\n+  limbo_die_list = NULL;\n \n   /* Walk through the list of incomplete types again, trying once more to\n      emit full debugging info for them.  */\n   retry_incomplete_types ();\n \n-  /* Traverse the DIE tree and add sibling attributes to those DIE's\n-     that have children.  */\n+  /* Traverse the DIE's, reverse their lists of attributes and children,\n+     and add add sibling attributes to those DIE's that have children.  */\n   add_sibling_attributes (comp_unit_die);\n \n   /* Output a terminator label for the .text section.  */\n@@ -10030,6 +10023,11 @@ dwarf2out_finish ()\n \t\t\t debug_line_section_label);\n     }\n \n+#if 0 /* unimplemented */\n+  if (debug_info_level >= DINFO_LEVEL_VERBOSE && primary)\n+    add_AT_unsigned (die, DW_AT_macro_info, 0);\n+#endif\n+\n   /* Output the abbreviation table.  */\n   fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_SECTION (asm_out_file, ABBREV_SECTION);"}]}