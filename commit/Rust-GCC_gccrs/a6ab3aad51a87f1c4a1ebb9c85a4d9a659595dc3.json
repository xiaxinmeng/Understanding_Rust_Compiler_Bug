{"sha": "a6ab3aad51a87f1c4a1ebb9c85a4d9a659595dc3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZhYjNhYWQ1MWE4N2YxYzRhMWViYjljODVhNGQ5YTY1OTU5NWRjMw==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1997-07-04T18:49:39Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1997-07-04T18:49:39Z"}, "message": "x\n\nFrom-SVN: r14390", "tree": {"sha": "b573fb651d2c7ca302ad62d72bfb8cb4bcd96682", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b573fb651d2c7ca302ad62d72bfb8cb4bcd96682"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6ab3aad51a87f1c4a1ebb9c85a4d9a659595dc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6ab3aad51a87f1c4a1ebb9c85a4d9a659595dc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6ab3aad51a87f1c4a1ebb9c85a4d9a659595dc3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6ab3aad51a87f1c4a1ebb9c85a4d9a659595dc3/comments", "author": null, "committer": null, "parents": [{"sha": "991d659956385d30316953daf9ad47b09c4dc21a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/991d659956385d30316953daf9ad47b09c4dc21a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/991d659956385d30316953daf9ad47b09c4dc21a"}], "stats": {"total": 348, "additions": 149, "deletions": 199}, "files": [{"sha": "8056af7e0e3a70c4564533a78ed844795037c217", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab3aad51a87f1c4a1ebb9c85a4d9a659595dc3/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab3aad51a87f1c4a1ebb9c85a4d9a659595dc3/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=a6ab3aad51a87f1c4a1ebb9c85a4d9a659595dc3", "patch": "@@ -2363,6 +2363,9 @@ number as al, and ax.\n /* PC is dbx register 8; let's use that column for RA. */\n #define DWARF_FRAME_RETURN_COLUMN \t8\n \n+/* Before the prologue, the top of the frame is at 4(%esp).  */\n+#define INCOMING_FRAME_SP_OFFSET 4\n+\n /* This is how to output the definition of a user-level label named NAME,\n    such as the label on a static function or variable NAME.  */\n "}, {"sha": "651133898d08e6ad887c69382568d10711d972a7", "filename": "gcc/defaults.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab3aad51a87f1c4a1ebb9c85a4d9a659595dc3/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab3aad51a87f1c4a1ebb9c85a4d9a659595dc3/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=a6ab3aad51a87f1c4a1ebb9c85a4d9a659595dc3", "patch": "@@ -133,3 +133,9 @@ do { fprintf (FILE, \"\\t%s\\t\", ASM_LONG);\t\t\t\t\\\n #define SUPPORTS_WEAK 0\n #endif\n #endif\n+\n+/* If we have a definition of INCOMING_RETURN_ADDR_RTX, assume that\n+   the rest of the DWARF 2 frame unwind support is also provided.  */\n+#ifdef INCOMING_RETURN_ADDR_RTX\n+#define DWARF2_UNWIND_INFO\n+#endif"}, {"sha": "b20683dda1785e338e9074ad8806404a979133c0", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 138, "deletions": 198, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab3aad51a87f1c4a1ebb9c85a4d9a659595dc3/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab3aad51a87f1c4a1ebb9c85a4d9a659595dc3/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=a6ab3aad51a87f1c4a1ebb9c85a4d9a659595dc3", "patch": "@@ -21,14 +21,15 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #include \"config.h\"\n+#include \"defaults.h\"\n \n /* The first part of this file deals with the DWARF 2 frame unwind\n    information, which is also used by the GCC efficient exception handling\n    mechanism.  The second part, controlled only by an #ifdef\n    DWARF2_DEBUGGING_INFO, deals with the other DWARF 2 debugging\n    information.  */\n \n-#if defined (DWARF2_DEBUGGING_INFO) || defined (INCOMING_RETURN_ADDR_RTX)\n+#if defined (DWARF2_DEBUGGING_INFO) || defined (DWARF2_UNWIND_INFO)\n \n #include <stdio.h>\n #include <setjmp.h>\n@@ -41,7 +42,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"insn-config.h\"\n #include \"reload.h\"\n #include \"output.h\"\n-#include \"defaults.h\"\n #include \"expr.h\"\n #include \"except.h\"\n \n@@ -91,7 +91,6 @@ dw_cfi_node;\n \n typedef struct dw_fde_struct\n {\n-  unsigned long dw_fde_offset;\n   char *dw_fde_begin;\n   char *dw_fde_current_label;\n   char *dw_fde_end;\n@@ -128,27 +127,13 @@ dw_fde_node;\n #define DWARF_ROUND(SIZE,BOUNDARY) \\\n   (((SIZE) + (BOUNDARY) - 1) & ~((BOUNDARY) - 1))\n \n-/* Fixed size portion of the CIE (including the length field).  */\n-#define DWARF_CIE_HEADER_SIZE (2 * DWARF_OFFSET_SIZE + 5)\n-\n-/* The un-padded size of the CIE.  Initialized in calc_fde_sizes, used\n-   in output_call_frame_info.  */\n-static unsigned cie_size;\n-\n /* Offsets recorded in opcodes are a multiple of this alignment factor.  */\n #ifdef STACK_GROWS_DOWNWARD\n #define DWARF_CIE_DATA_ALIGNMENT (-UNITS_PER_WORD)\n #else\n #define DWARF_CIE_DATA_ALIGNMENT UNITS_PER_WORD\n #endif\n \n-/* Fixed size portion of the FDE.  */\n-#define DWARF_FDE_HEADER_SIZE (2 * DWARF_OFFSET_SIZE + 2 * PTR_SIZE)\n-\n-/* This location is used by calc_fde_sizes() to keep track\n-   the offset of each FDE within the .debug_frame section.  */\n-static unsigned long next_fde_offset;\n-\n /* A pointer to the base of a table that contains frame description\n    information for each routine.  */\n static dw_fde_ref fde_table;\n@@ -197,9 +182,6 @@ static void lookup_cfa\t\t\tPROTO((unsigned long *, long *));\n static void reg_save\t\t\tPROTO((char *, unsigned, unsigned,\n \t\t\t\t\t       long));\n static void initial_return_save\t\tPROTO((rtx));\n-static unsigned long size_of_cfi\tPROTO((dw_cfi_ref));\n-static unsigned long size_of_fde\tPROTO((dw_fde_ref, unsigned long *));\n-static void calc_fde_sizes\t\tPROTO((void));\n static void output_cfi\t\t\tPROTO((dw_cfi_ref, dw_fde_ref));\n static void output_call_frame_info\tPROTO((int));\n static unsigned reg_number\t\tPROTO((rtx));\n@@ -266,6 +248,10 @@ static unsigned reg_number\t\tPROTO((rtx));\n #ifndef FUNC_END_LABEL\n #define FUNC_END_LABEL\t\t\"LFE\"\n #endif\n+#define CIE_AFTER_SIZE_LABEL\t\"LSCIE\"\n+#define CIE_END_LABEL\t\t\"LECIE\"\n+#define FDE_AFTER_SIZE_LABEL\t\"LSFDE\"\n+#define FDE_END_LABEL\t\t\"LEFDE\"\n \n /* Definitions of defaults for various types of primitive assembly language\n    output operations.  These may be overridden from within the tm.h file,\n@@ -374,6 +360,33 @@ static unsigned reg_number\t\tPROTO((rtx));\n   } while (0)\n #endif\n \n+/* This is similar to the default ASM_OUTPUT_ASCII, except that no trailing\n+   newline is produced.  When flag_verbose_asm is asserted, we add commnetary\n+   at the end of the line, so we must avoid output of a newline here.  */\n+#ifndef ASM_OUTPUT_DWARF_STRING\n+#define ASM_OUTPUT_DWARF_STRING(FILE,P) \\\n+  do {\t\t\t\t\t\t\t\t\t      \\\n+    register int slen = strlen(P);                                            \\\n+    register char *p = (P);  \t                                              \\\n+    register int i;\t\t\t\t\t                      \\\n+    fprintf (FILE, \"\\t.ascii \\\"\");\t\t\t\t              \\\n+    for (i = 0; i < slen; i++)\t\t\t\t\t              \\\n+      {\t\t\t\t\t\t\t\t              \\\n+\t  register int c = p[i];\t\t\t\t\t      \\\n+\t  if (c == '\\\"' || c == '\\\\')\t\t\t\t\t      \\\n+\t    putc ('\\\\', FILE);\t\t\t\t\t              \\\n+\t  if (c >= ' ' && c < 0177)\t\t\t\t\t      \\\n+\t    putc (c, FILE);\t\t\t\t\t              \\\n+\t  else\t\t\t\t\t\t\t\t      \\\n+\t    {\t\t\t\t\t\t\t\t      \\\n+\t      fprintf (FILE, \"\\\\%o\", c);\t\t\t              \\\n+\t    }\t\t\t\t\t\t\t \t      \\\n+      }\t\t\t\t\t\t\t\t              \\\n+    fprintf (FILE, \"\\\\0\\\"\");\t\t\t\t\t              \\\n+  }\t\t\t\t\t\t\t\t\t      \\\n+  while (0)\n+#endif\n+\n /* The DWARF 2 CFA column which tracks the return address.  Normally this\n    is the column for PC, or the first column after all of the hard\n    registers.  */\n@@ -391,6 +404,12 @@ static unsigned reg_number\t\tPROTO((rtx));\n #define DWARF_FRAME_REGNUM(REG) DBX_REGISTER_NUMBER (REG)\n #endif\n \n+/* The offset from the incoming value of %sp to the top of the stack frame\n+   for the current function.  */\n+#ifndef INCOMING_FRAME_SP_OFFSET\n+#define INCOMING_FRAME_SP_OFFSET 0\n+#endif\n+\n /* Return a pointer to a copy of the section string name S with all\n    attributes stripped off.  */\n \n@@ -611,7 +630,7 @@ lookup_cfa (regp, offsetp)\n }\n \n /* The current rule for calculating the DWARF2 canonical frame address.  */\n-static unsigned cfa_reg;\n+static unsigned long cfa_reg;\n static long cfa_offset;\n \n /* The register used for saving registers to the stack, and its offset\n@@ -806,7 +825,7 @@ initial_return_save (rtl)\n       abort ();\n     }\n \n-  reg_save (NULL, DWARF_FRAME_RETURN_COLUMN, reg, offset);\n+  reg_save (NULL, DWARF_FRAME_RETURN_COLUMN, reg, offset - cfa_offset);\n }\n \n /* Record call frame debugging information for INSN, which either\n@@ -828,10 +847,11 @@ dwarf2out_frame_debug (insn)\n   if (insn == NULL_RTX)\n     {\n       /* Set up state for generating call frame debug info.  */\n+      lookup_cfa (&cfa_reg, &cfa_offset);\n+      assert (cfa_reg == DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM));\n       cfa_reg = STACK_POINTER_REGNUM;\n-      cfa_offset = 0;\n-      cfa_store_reg = STACK_POINTER_REGNUM;\n-      cfa_store_offset = 0;\n+      cfa_store_reg = cfa_reg;\n+      cfa_store_offset = cfa_offset;\n       cfa_temp_reg = -1;\n       cfa_temp_value = 0;\n       return;\n@@ -1005,114 +1025,6 @@ size_of_sleb128 (value)\n   return size;\n }\n \n-/* Return the size of a Call Frame Instruction.  */\n-\n-static unsigned long\n-size_of_cfi (cfi)\n-     dw_cfi_ref cfi;\n-{\n-  register unsigned long size;\n-\n-  /* Count the 1-byte opcode */\n-  size = 1;\n-  switch (cfi->dw_cfi_opc)\n-    {\n-    case DW_CFA_offset:\n-      size += size_of_uleb128 (cfi->dw_cfi_oprnd2.dw_cfi_offset);\n-      break;\n-    case DW_CFA_set_loc:\n-      size += PTR_SIZE;\n-      break;\n-    case DW_CFA_advance_loc1:\n-      size += 1;\n-      break;\n-    case DW_CFA_advance_loc2:\n-      size += 2;\n-      break;\n-    case DW_CFA_advance_loc4:\n-      size += 4;\n-      break;\n-#ifdef MIPS_DEBUGGING_INFO\n-    case DW_CFA_MIPS_advance_loc8:\n-      size += 8;\n-      break;\n-#endif\n-    case DW_CFA_offset_extended:\n-    case DW_CFA_def_cfa:\n-      size += size_of_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n-      size += size_of_uleb128 (cfi->dw_cfi_oprnd2.dw_cfi_offset);\n-      break;\n-    case DW_CFA_restore_extended:\n-    case DW_CFA_undefined:\n-      size += size_of_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n-      break;\n-    case DW_CFA_same_value:\n-    case DW_CFA_def_cfa_register:\n-      size += size_of_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n-      break;\n-    case DW_CFA_register:\n-      size += size_of_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n-      size += size_of_uleb128 (cfi->dw_cfi_oprnd2.dw_cfi_reg_num);\n-      break;\n-    case DW_CFA_def_cfa_offset:\n-      size += size_of_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_offset);\n-      break;\n-    default:\n-      break;\n-    }\n-\n-    return size;\n-}\n-\n-/* Return the size of an FDE sans the length word.  */\n-\n-static inline unsigned long\n-size_of_fde (fde, npad)\n-    dw_fde_ref fde;\n-    unsigned long *npad;\n-{\n-  register dw_cfi_ref cfi;\n-  register unsigned long aligned_size;\n-  register unsigned long size;\n-\n-  size = DWARF_FDE_HEADER_SIZE;\n-  for (cfi = fde->dw_fde_cfi; cfi != NULL; cfi = cfi->dw_cfi_next)\n-    size += size_of_cfi(cfi);\n-\n-  /* Round the size up to a word boundary.  */\n-  aligned_size = DWARF_ROUND (size, PTR_SIZE);\n-  *npad = aligned_size - size;\n-  return aligned_size;\n-}\n-\n-/* Calculate the size of the FDE table, and establish the offset\n-   of each FDE in the .debug_frame section.  */\n-\n-static void\n-calc_fde_sizes ()\n-{\n-  register unsigned long i;\n-  register dw_fde_ref fde;\n-  register unsigned long fde_size;\n-  register dw_cfi_ref cfi;\n-  unsigned long fde_pad;\n-\n-  cie_size = DWARF_CIE_HEADER_SIZE;\n-  for (cfi = cie_cfi_head; cfi != NULL; cfi = cfi->dw_cfi_next)\n-    cie_size += size_of_cfi (cfi);\n-\n-  /* Initialize the beginning FDE offset.  */\n-  next_fde_offset = DWARF_ROUND (cie_size, PTR_SIZE);\n-\n-  for (i = 0; i < fde_table_in_use; ++i)\n-    {\n-      fde = &fde_table[i];\n-      fde->dw_fde_offset = next_fde_offset;\n-      fde_size = size_of_fde (fde, &fde_pad);\n-      next_fde_offset += fde_size;\n-    }\n-}\n-\n /* Output an unsigned LEB128 quantity.  */\n \n static void\n@@ -1299,6 +1211,10 @@ output_call_frame_info (for_eh)\n   register unsigned long fde_size;\n   register dw_cfi_ref cfi;\n   unsigned long fde_pad;\n+  char l1[20], l2[20];\n+\n+  /* Do we want to include a pointer to the exception table?  */\n+  int eh_ptr = for_eh && exception_table_p ();\n \n   /* Only output the info if it will be interesting.  */\n   for (i = 0; i < fde_table_in_use; ++i)\n@@ -1307,9 +1223,6 @@ output_call_frame_info (for_eh)\n   if (i == fde_table_in_use)\n     return;\n \n-  /* (re-)initialize the beginning FDE offset.  */\n-  next_fde_offset = DWARF_ROUND (cie_size, PTR_SIZE);\n-\n   fputc ('\\n', asm_out_file);\n   if (for_eh)\n     {\n@@ -1324,12 +1237,16 @@ output_call_frame_info (for_eh)\n     ASM_OUTPUT_SECTION (asm_out_file, FRAME_SECTION);\n \n   /* Output the CIE. */\n-  ASM_OUTPUT_DWARF_DATA (asm_out_file, next_fde_offset - DWARF_OFFSET_SIZE);\n+  ASM_GENERATE_INTERNAL_LABEL (l1, CIE_AFTER_SIZE_LABEL, for_eh);\n+  ASM_GENERATE_INTERNAL_LABEL (l2, CIE_END_LABEL, for_eh);\n+  ASM_OUTPUT_DWARF_DELTA (asm_out_file, l2, l1);\n   if (flag_verbose_asm)\n     fprintf (asm_out_file, \"\\t%s Length of Common Information Entry\",\n \t     ASM_COMMENT_START);\n \n   fputc ('\\n', asm_out_file);\n+  ASM_OUTPUT_LABEL (asm_out_file, l1);\n+\n   ASM_OUTPUT_DWARF_DATA4 (asm_out_file, DW_CIE_ID);\n   if (flag_verbose_asm)\n     fprintf (asm_out_file, \"\\t%s CIE Identifier Tag\", ASM_COMMENT_START);\n@@ -1346,9 +1263,21 @@ output_call_frame_info (for_eh)\n     fprintf (asm_out_file, \"\\t%s CIE Version\", ASM_COMMENT_START);\n \n   fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n-  if (flag_verbose_asm)\n-    fprintf (asm_out_file, \"\\t%s CIE Augmentation (none)\", ASM_COMMENT_START);\n+  if (eh_ptr)\n+    {\n+      /* The \"z\" augmentation was defined by SGI; the FDE contains a pointer\n+\t to the exception region info for the frame.  */\n+      ASM_OUTPUT_DWARF_STRING (asm_out_file, \"z\");\n+      if (flag_verbose_asm)\n+\tfprintf (asm_out_file, \"\\t%s CIE Augmentation\", ASM_COMMENT_START);\n+    }\n+  else\n+    {\n+      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n+      if (flag_verbose_asm)\n+\tfprintf (asm_out_file, \"\\t%s CIE Augmentation (none)\",\n+\t\t ASM_COMMENT_START);\n+    }\n \n   fputc ('\\n', asm_out_file);\n   output_uleb128 (1);\n@@ -1366,20 +1295,21 @@ output_call_frame_info (for_eh)\n     fprintf (asm_out_file, \"\\t%s CIE RA Column\", ASM_COMMENT_START);\n \n   fputc ('\\n', asm_out_file);\n+  if (eh_ptr)\n+    {\n+      output_uleb128 (0);\n+      if (flag_verbose_asm)\n+\tfprintf (asm_out_file, \"\\t%s CIE augmentation fields length\",\n+\t\t ASM_COMMENT_START);\n+      fputc ('\\n', asm_out_file);\n+    }\n \n   for (cfi = cie_cfi_head; cfi != NULL; cfi = cfi->dw_cfi_next)\n     output_cfi (cfi, NULL);\n \n   /* Pad the CIE out to an address sized boundary.  */\n-  for (i = next_fde_offset - cie_size; i; --i)\n-    {\n-      /* Pad out to a pointer size boundary */\n-      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_CFA_nop);\n-      if (flag_verbose_asm)\n-\tfprintf (asm_out_file, \"\\t%s CIE DW_CFA_nop (pad)\", ASM_COMMENT_START);\n-\n-      fputc ('\\n', asm_out_file);\n-    }\n+  ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (PTR_SIZE));\n+  ASM_OUTPUT_LABEL (asm_out_file, l2);\n \n   /* Loop through all of the FDE's.  */\n   for (i = 0; i < fde_table_in_use; ++i)\n@@ -1388,12 +1318,14 @@ output_call_frame_info (for_eh)\n       if (fde->dw_fde_cfi == NULL)\n \tcontinue;\n \n-      fde_size = size_of_fde (fde, &fde_pad);\n-      ASM_OUTPUT_DWARF_DATA (asm_out_file, fde_size - DWARF_OFFSET_SIZE);\n+      ASM_GENERATE_INTERNAL_LABEL (l1, FDE_AFTER_SIZE_LABEL, for_eh + i*2);\n+      ASM_GENERATE_INTERNAL_LABEL (l2, FDE_END_LABEL, for_eh + i*2);\n+      ASM_OUTPUT_DWARF_DELTA (asm_out_file, l2, l1);\n       if (flag_verbose_asm)\n \tfprintf (asm_out_file, \"\\t%s FDE Length\", ASM_COMMENT_START);\n-\n       fputc ('\\n', asm_out_file);\n+      ASM_OUTPUT_LABEL (asm_out_file, l1);\n+\n       if (for_eh)\n \tASM_OUTPUT_DWARF_ADDR (asm_out_file, \"__FRAME_BEGIN__\");\n       else\n@@ -1413,23 +1345,36 @@ output_call_frame_info (for_eh)\n \tfprintf (asm_out_file, \"\\t%s FDE address range\", ASM_COMMENT_START);\n \n       fputc ('\\n', asm_out_file);\n+      if (eh_ptr)\n+\t{\n+\t  output_uleb128 (PTR_SIZE);\n+\t  if (flag_verbose_asm)\n+\t    fprintf (asm_out_file, \"\\t%s FDE augmentation fields length\",\n+\t\t     ASM_COMMENT_START);\n+\t  fputc ('\\n', asm_out_file);\n+\n+\t  /* For now, a pointer to the translation unit's info will do.\n+\t     ??? Eventually this should point to the function's info.  */\n+\t  if (exception_table_p ())\n+\t    ASM_OUTPUT_DWARF_ADDR (asm_out_file, \"__EXCEPTION_TABLE__\");\n+\t  else\n+\t    ASM_OUTPUT_DWARF_ADDR_DATA (asm_out_file, 0);\n+\n+\t  if (flag_verbose_asm)\n+\t    fprintf (asm_out_file, \"\\t%s pointer to exception region info\",\n+\t\t     ASM_COMMENT_START);\n+\t  fputc ('\\n', asm_out_file);\n+\t}\n \n       /* Loop through the Call Frame Instructions associated with\n \t this FDE.  */\n       fde->dw_fde_current_label = fde->dw_fde_begin;\n       for (cfi = fde->dw_fde_cfi; cfi != NULL; cfi = cfi->dw_cfi_next)\n \toutput_cfi (cfi, fde);\n \n-      /* Pad to a double word boundary.  */\n-      for (j = 0; j < fde_pad; ++j)\n-\t{\n-\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_CFA_nop);\n-\t  if (flag_verbose_asm)\n-\t    fprintf (asm_out_file, \"\\t%s CIE DW_CFA_nop (pad)\",\n-\t\t     ASM_COMMENT_START);\n-\n-\t  fputc ('\\n', asm_out_file);\n-\t}\n+      /* Pad the FDE out to an address sized boundary.  */\n+      ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (PTR_SIZE));\n+      ASM_OUTPUT_LABEL (asm_out_file, l2);\n     }\n #ifndef EH_FRAME_SECTION\n   if (for_eh)\n@@ -1439,6 +1384,21 @@ output_call_frame_info (for_eh)\n       fputc ('\\n', asm_out_file);\n     }\n #endif\n+#ifdef MIPS_DEBUGGING_INFO\n+  /* Work around Irix 6 assembler bug whereby labels at the end of a section\n+     get a value of 0.  Putting .align 0 after the label fixes it.  */\n+  ASM_OUTPUT_ALIGN (asm_out_file, 0);\n+#endif\n+}\n+\n+/* Decide whether we want to emit frame unwind information for the current\n+   translation unit.  */\n+\n+int\n+dwarf2out_do_frame ()\n+{\n+  return (write_symbols == DWARF2_DEBUG\n+\t  || (flag_exceptions && ! exceptions_via_longjmp));\n }\n \n /* Output a marker (i.e. a label) for the beginning of a function, before\n@@ -1508,24 +1468,27 @@ dwarf2out_frame_init ()\n   /* Generate the CFA instructions common to all FDE's.  Do it now for the\n      sake of lookup_cfa.  */\n \n-#ifdef INCOMING_RETURN_ADDR_RTX\n-  /* On entry, the Canonical Frame Address is at SP+0.  */\n-  dwarf2out_def_cfa (NULL, STACK_POINTER_REGNUM, 0);\n+#ifdef DWARF2_UNWIND_INFO\n+  /* On entry, the Canonical Frame Address is at SP.  */\n+  dwarf2out_def_cfa (NULL, STACK_POINTER_REGNUM, INCOMING_FRAME_SP_OFFSET);\n   initial_return_save (INCOMING_RETURN_ADDR_RTX);\n #endif\n }\n \n void\n dwarf2out_frame_finish ()\n {\n-  /* calculate sizes/offsets for FDEs.  */\n-  calc_fde_sizes ();\n-\n   /* Output call frame information.  */\n+#ifdef MIPS_DEBUGGING_INFO\n   if (write_symbols == DWARF2_DEBUG)\n     output_call_frame_info (0);\n   if (flag_exceptions && ! exceptions_via_longjmp)\n     output_call_frame_info (1);\n+#else\n+  if (write_symbols == DWARF2_DEBUG\n+      || (flag_exceptions && ! exceptions_via_longjmp))\n+    output_call_frame_info (1);  \n+#endif\n }  \n \n #endif /* .debug_frame support */\n@@ -2191,33 +2154,6 @@ static char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n #define SEPARATE_LINE_CODE_LABEL\t\"LSM\"\n #endif\n \n-/* This is similar to the default ASM_OUTPUT_ASCII, except that no trailing\n-   newline is produced.  When flag_verbose_asm is asserted, we add commnetary\n-   at the end of the line, so we must avoid output of a newline here.  */\n-#ifndef ASM_OUTPUT_DWARF_STRING\n-#define ASM_OUTPUT_DWARF_STRING(FILE,P) \\\n-  do {\t\t\t\t\t\t\t\t\t      \\\n-    register int slen = strlen(P);                                            \\\n-    register char *p = (P);  \t                                              \\\n-    register int i;\t\t\t\t\t                      \\\n-    fprintf (FILE, \"\\t.ascii \\\"\");\t\t\t\t              \\\n-    for (i = 0; i < slen; i++)\t\t\t\t\t              \\\n-      {\t\t\t\t\t\t\t\t              \\\n-\t  register int c = p[i];\t\t\t\t\t      \\\n-\t  if (c == '\\\"' || c == '\\\\')\t\t\t\t\t      \\\n-\t    putc ('\\\\', FILE);\t\t\t\t\t              \\\n-\t  if (c >= ' ' && c < 0177)\t\t\t\t\t      \\\n-\t    putc (c, FILE);\t\t\t\t\t              \\\n-\t  else\t\t\t\t\t\t\t\t      \\\n-\t    {\t\t\t\t\t\t\t\t      \\\n-\t      fprintf (FILE, \"\\\\%o\", c);\t\t\t              \\\n-\t    }\t\t\t\t\t\t\t \t      \\\n-      }\t\t\t\t\t\t\t\t              \\\n-    fprintf (FILE, \"\\\\0\\\"\");\t\t\t\t\t              \\\n-  }\t\t\t\t\t\t\t\t\t      \\\n-  while (0)\n-#endif\n-\n /* Convert a reference to the assembler name of a C-level name.  This\n    macro has the same effect as ASM_OUTPUT_LABELREF, but copies to\n    a string rather than writing to a file.  */\n@@ -4922,9 +4858,13 @@ output_die (die)\n \t  break;\n \n \tcase dw_val_class_fde_ref:\n-\t  ref_offset = fde_table[a->dw_attr_val.v.val_fde_index].dw_fde_offset;\n-\t  fprintf (asm_out_file, \"\\t%s\\t%s+0x%x\", UNALIGNED_OFFSET_ASM_OP,\n-\t\t   stripattributes (FRAME_SECTION), ref_offset);\n+\t  {\n+\t    char l1[20];\n+\t    ASM_GENERATE_INTERNAL_LABEL\n+\t      (l1, FDE_AFTER_SIZE_LABEL, a->dw_attr_val.v.val_fde_index * 2);\n+\t    ASM_OUTPUT_DWARF_OFFSET (asm_out_file, l1);\n+\t    fprintf (asm_out_file, \" - %d\", DWARF_OFFSET_SIZE);\n+\t  }\n \t  break;\n \n \tcase dw_val_class_lbl_id:"}, {"sha": "d36e3d617eba64cd2e5b8d170c1858ca61b99ee9", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab3aad51a87f1c4a1ebb9c85a4d9a659595dc3/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab3aad51a87f1c4a1ebb9c85a4d9a659595dc3/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=a6ab3aad51a87f1c4a1ebb9c85a4d9a659595dc3", "patch": "@@ -1262,7 +1262,8 @@ final (first, file, optimize, prescan)\n   new_block = 1;\n \n #if defined (DWARF2_DEBUGGING_INFO) && defined (HAVE_prologue)\n-  dwarf2out_frame_debug (NULL_RTX);\n+  if (write_symbols == DWARF2_DEBUG)\n+    dwarf2out_frame_debug (NULL_RTX);\n #endif\n \n   check_exception_handler_labels ();"}]}