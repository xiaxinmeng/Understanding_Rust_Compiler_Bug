{"sha": "7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U0Y2U4MzRiMjg2N2Y0YzdiYjJiNDRlNDM0ZjVkMjc3OGUyM2NhMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-07-23T01:21:31Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-07-23T01:21:31Z"}, "message": "explow.c (trunc_int_for_mode): New function.\n\n        * explow.c (trunc_int_for_mode): New function.\n        (plus_constant_wide): Use it.\n        * combine.c (simplify_and_const_int): Likewise.\n        (merge_outer_ops): Likewise.\n        (simplify_shift_const): Likewise.\n        * cse.c (simplify_unary_operation): Likewise.\n        (simplify_binary_operation): Likewise.\n        * emit-rtl.c (operand_subword): Likewise.\n        * rtl.h: Declare it.\n\nFrom-SVN: r28222", "tree": {"sha": "dcae196cb9448ce862621b3d77db8a0bae222ce2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcae196cb9448ce862621b3d77db8a0bae222ce2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3/comments", "author": null, "committer": null, "parents": [{"sha": "27b8d0cd535f663df34c8264ee48e3034a663c38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27b8d0cd535f663df34c8264ee48e3034a663c38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27b8d0cd535f663df34c8264ee48e3034a663c38"}], "stats": {"total": 190, "additions": 65, "deletions": 125}, "files": [{"sha": "8f24efcf2a2dbeaa072a2f2e24ccee8582175c0c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3", "patch": "@@ -1,3 +1,15 @@\n+Thu Jul 22 18:21:04 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* explow.c (trunc_int_for_mode): New function.\n+\t(plus_constant_wide): Use it.\n+\t* combine.c (simplify_and_const_int): Likewise.\n+\t(merge_outer_ops): Likewise.\n+\t(simplify_shift_const): Likewise.\n+\t* cse.c (simplify_unary_operation): Likewise.\n+\t(simplify_binary_operation): Likewise.\n+\t* emit-rtl.c (operand_subword): Likewise.\n+\t* rtl.h: Declare it.\n+\n Thu Jul 22 14:34:59 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* config/arm/arm.c (arm_print_operand): Fix typo in 'M' case"}, {"sha": "c9736e5e56c4b42121386893ccfc69ce0b68ff3d", "filename": "gcc/combine.c", "status": "modified", "additions": 6, "deletions": 43, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3", "patch": "@@ -7336,19 +7336,7 @@ simplify_and_const_int (x, mode, varop, constop)\n      MODE.  */\n \n   nonzero = nonzero_bits (varop, mode) & GET_MODE_MASK (mode);\n-\n-  /* If this would be an entire word for the target, but is not for\n-     the host, then sign-extend on the host so that the number will look\n-     the same way on the host that it would on the target.\n-\n-     For example, when building a 64 bit alpha hosted 32 bit sparc\n-     targeted compiler, then we want the 32 bit unsigned value -1 to be\n-     represented as a 64 bit value -1, and not as 0x00000000ffffffff.\n-     The later confuses the sparc backend.  */\n-\n-  if (BITS_PER_WORD < HOST_BITS_PER_WIDE_INT && BITS_PER_WORD == width\n-      && (nonzero & ((HOST_WIDE_INT) 1 << (width - 1))))\n-    nonzero |= ((HOST_WIDE_INT) (-1) << width);\n+  nonzero = trunc_int_for_mode (nonzero, mode);\n \n   /* Turn off all bits in the constant that are known to already be zero.\n      Thus, if the AND isn't needed at all, we will have CONSTOP == NONZERO_BITS\n@@ -8327,18 +8315,10 @@ merge_outer_ops (pop0, pconst0, op1, const1, mode, pcomp_p)\n \t   && op0 == AND)\n     op0 = NIL;\n \n-  /* If this would be an entire word for the target, but is not for\n-     the host, then sign-extend on the host so that the number will look\n-     the same way on the host that it would on the target.\n-\n-     For example, when building a 64 bit alpha hosted 32 bit sparc\n-     targeted compiler, then we want the 32 bit unsigned value -1 to be\n-     represented as a 64 bit value -1, and not as 0x00000000ffffffff.\n-     The later confuses the sparc backend.  */\n-\n-  if (BITS_PER_WORD < HOST_BITS_PER_WIDE_INT && BITS_PER_WORD == width\n-      && (const0 & ((HOST_WIDE_INT) 1 << (width - 1))))\n-    const0 |= ((HOST_WIDE_INT) (-1) << width);\n+  /* ??? Slightly redundant with the above mask, but not entirely.\n+     Moving this above means we'd have to sign-extend the mode mask\n+     for the final test.  */\n+  const0 = trunc_int_for_mode (const0, mode);\n \n   *pop0 = op0;\n   *pconst0 = const0;\n@@ -9053,24 +9033,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n   if (outer_op != NIL)\n     {\n       if (GET_MODE_BITSIZE (result_mode) < HOST_BITS_PER_WIDE_INT)\n-\t{\n-\t  int width = GET_MODE_BITSIZE (result_mode);\n-\n-\t  outer_const &= GET_MODE_MASK (result_mode);\n-\n-\t  /* If this would be an entire word for the target, but is not for\n-\t     the host, then sign-extend on the host so that the number will\n-\t     look the same way on the host that it would on the target.\n-\n-\t     For example, when building a 64 bit alpha hosted 32 bit sparc\n-\t     targeted compiler, then we want the 32 bit unsigned value -1 to be\n-\t     represented as a 64 bit value -1, and not as 0x00000000ffffffff.\n-\t     The later confuses the sparc backend.  */\n-\n-\t  if (BITS_PER_WORD < HOST_BITS_PER_WIDE_INT && BITS_PER_WORD == width\n-\t      && (outer_const & ((HOST_WIDE_INT) 1 << (width - 1))))\n-\t    outer_const |= ((HOST_WIDE_INT) (-1) << width);\n-\t}\n+\touter_const = trunc_int_for_mode (outer_const, result_mode);\n \n       if (outer_op == AND)\n \tx = simplify_and_const_int (NULL_RTX, result_mode, x, outer_const);"}, {"sha": "edd434b5395d2b2e4b6eca1f4ad4a52d90f6ac77", "filename": "gcc/cse.c", "status": "modified", "additions": 3, "deletions": 62, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3", "patch": "@@ -3364,27 +3364,7 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t  abort ();\n \t}\n \n-      /* Clear the bits that don't belong in our mode,\n-\t unless they and our sign bit are all one.\n-\t So we get either a reasonable negative value or a reasonable\n-\t unsigned value for this mode.  */\n-      if (width < HOST_BITS_PER_WIDE_INT\n-\t  && ((val & ((HOST_WIDE_INT) (-1) << (width - 1)))\n-\t      != ((HOST_WIDE_INT) (-1) << (width - 1))))\n-\tval &= ((HOST_WIDE_INT) 1 << width) - 1;\n-\n-      /* If this would be an entire word for the target, but is not for\n-\t the host, then sign-extend on the host so that the number will look\n-\t the same way on the host that it would on the target.\n-\n-\t For example, when building a 64 bit alpha hosted 32 bit sparc\n-\t targeted compiler, then we want the 32 bit unsigned value -1 to be\n-\t represented as a 64 bit value -1, and not as 0x00000000ffffffff.\n-\t The later confuses the sparc backend.  */\n-\n-      if (BITS_PER_WORD < HOST_BITS_PER_WIDE_INT && BITS_PER_WORD == width\n-\t  && (val & ((HOST_WIDE_INT) 1 << (width - 1))))\n-\tval |= ((HOST_WIDE_INT) (-1) << width);\n+      val = trunc_int_for_mode (val, mode);\n \n       return GEN_INT (val);\n     }\n@@ -3556,27 +3536,7 @@ simplify_unary_operation (code, mode, op, op_mode)\n \n       set_float_handler (NULL_PTR);\n \n-      /* Clear the bits that don't belong in our mode,\n-\t unless they and our sign bit are all one.\n-\t So we get either a reasonable negative value or a reasonable\n-\t unsigned value for this mode.  */\n-      if (width < HOST_BITS_PER_WIDE_INT\n-\t  && ((val & ((HOST_WIDE_INT) (-1) << (width - 1)))\n-\t      != ((HOST_WIDE_INT) (-1) << (width - 1))))\n-\tval &= ((HOST_WIDE_INT) 1 << width) - 1;\n-\n-      /* If this would be an entire word for the target, but is not for\n-\t the host, then sign-extend on the host so that the number will look\n-\t the same way on the host that it would on the target.\n-\n-\t For example, when building a 64 bit alpha hosted 32 bit sparc\n-\t targeted compiler, then we want the 32 bit unsigned value -1 to be\n-\t represented as a 64 bit value -1, and not as 0x00000000ffffffff.\n-\t The later confuses the sparc backend.  */\n-\n-      if (BITS_PER_WORD < HOST_BITS_PER_WIDE_INT && BITS_PER_WORD == width\n-\t  && (val & ((HOST_WIDE_INT) 1 << (width - 1))))\n-\tval |= ((HOST_WIDE_INT) (-1) << width);\n+      val = trunc_int_for_mode (val, mode);\n \n       return GEN_INT (val);\n     }\n@@ -4458,26 +4418,7 @@ simplify_binary_operation (code, mode, op0, op1)\n       abort ();\n     }\n \n-  /* Clear the bits that don't belong in our mode, unless they and our sign\n-     bit are all one.  So we get either a reasonable negative value or a\n-     reasonable unsigned value for this mode.  */\n-  if (width < HOST_BITS_PER_WIDE_INT\n-      && ((val & ((HOST_WIDE_INT) (-1) << (width - 1)))\n-\t  != ((HOST_WIDE_INT) (-1) << (width - 1))))\n-    val &= ((HOST_WIDE_INT) 1 << width) - 1;\n-\n-  /* If this would be an entire word for the target, but is not for\n-     the host, then sign-extend on the host so that the number will look\n-     the same way on the host that it would on the target.\n-\n-     For example, when building a 64 bit alpha hosted 32 bit sparc\n-     targeted compiler, then we want the 32 bit unsigned value -1 to be\n-     represented as a 64 bit value -1, and not as 0x00000000ffffffff.\n-     The later confuses the sparc backend.  */\n-\n-  if (BITS_PER_WORD < HOST_BITS_PER_WIDE_INT && BITS_PER_WORD == width\n-      && (val & ((HOST_WIDE_INT) 1 << (width - 1))))\n-    val |= ((HOST_WIDE_INT) (-1) << width);\n+  val = trunc_int_for_mode (val, mode);\n \n   return GEN_INT (val);\n }"}, {"sha": "de0262c04bf07c82e4377b722556ad310078db21", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3", "patch": "@@ -1489,26 +1489,7 @@ operand_subword (op, i, validate_address, mode)\n   if (BITS_PER_WORD < HOST_BITS_PER_WIDE_INT)\n     val = ((val >> ((i % size_ratio) * BITS_PER_WORD)));\n \n-  /* Clear the bits that don't belong in our mode, unless they and our sign\n-     bit are all one.  So we get either a reasonable negative value or a\n-     reasonable unsigned value for this mode.  */\n-  if (BITS_PER_WORD < HOST_BITS_PER_WIDE_INT\n-      && ((val & ((HOST_WIDE_INT) (-1) << (bits_per_word - 1)))\n-          != ((HOST_WIDE_INT) (-1) << (bits_per_word - 1))))\n-    val &= ((HOST_WIDE_INT) 1 << bits_per_word) - 1;\n-\n-  /* If this would be an entire word for the target, but is not for\n-     the host, then sign-extend on the host so that the number will look\n-     the same way on the host that it would on the target.\n-\n-     For example, when building a 64 bit alpha hosted 32 bit sparc\n-     targeted compiler, then we want the 32 bit unsigned value -1 to be\n-     represented as a 64 bit value -1, and not as 0x00000000ffffffff.\n-     The later confuses the sparc backend.  */\n-\n-  if (BITS_PER_WORD < HOST_BITS_PER_WIDE_INT\n-      && (val & ((HOST_WIDE_INT) 1 << (bits_per_word - 1))))\n-    val |= ((HOST_WIDE_INT) (-1) << bits_per_word);\n+  val = trunc_int_for_mode (val, word_mode);\n \n   return GEN_INT (val);\n }"}, {"sha": "92f99ad65f27bbc7db2381edeb0041f7e9782401", "filename": "gcc/explow.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3", "patch": "@@ -38,6 +38,43 @@ Boston, MA 02111-1307, USA.  */\n \n static rtx break_out_memory_refs\tPROTO((rtx));\n static void emit_stack_probe\t\tPROTO((rtx));\n+\n+\n+/* Truncate and perhaps sign-extend C as appropriate for MODE.  */\n+\n+HOST_WIDE_INT\n+trunc_int_for_mode (c, mode)\n+     HOST_WIDE_INT c;\n+     enum machine_mode mode;\n+{\n+  int width = GET_MODE_BITSIZE (mode);\n+\n+  /* We clear out all bits that don't belong in MODE, unless they and our\n+     sign bit are all one.  So we get either a reasonable negative\n+     value or a reasonable unsigned value.  */\n+\n+  if (width < HOST_BITS_PER_WIDE_INT\n+      && ((c & ((HOST_WIDE_INT) (-1) << (width - 1)))\n+           != ((HOST_WIDE_INT) (-1) << (width - 1))))\n+    c &= ((HOST_WIDE_INT) 1 << width) - 1;\n+\n+  /* If this would be an entire word for the target, but is not for\n+     the host, then sign-extend on the host so that the number will look\n+     the same way on the host that it would on the target.\n+\n+     For example, when building a 64 bit alpha hosted 32 bit sparc\n+     targeted compiler, then we want the 32 bit unsigned value -1 to be\n+     represented as a 64 bit value -1, and not as 0x00000000ffffffff.\n+     The later confuses the sparc backend.  */\n+\n+  if (BITS_PER_WORD < HOST_BITS_PER_WIDE_INT\n+      && BITS_PER_WORD == width\n+      && (c & ((HOST_WIDE_INT) 1 << (width - 1))))\n+    c |= ((HOST_WIDE_INT) (-1) << width);\n+\n+  return c;\n+}\n+\n /* Return an rtx for the sum of X and the integer C.\n \n    This function should be used via the `plus_constant' macro.  */\n@@ -126,6 +163,10 @@ plus_constant_wide (x, c)\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n \t{\n \t  c += INTVAL (XEXP (x, 1));\n+\n+\t  if (GET_MODE (x) != VOIDmode)\n+\t    c = trunc_int_for_mode (c, GET_MODE (x));\n+\n \t  x = XEXP (x, 0);\n \t  goto restart;\n \t}"}, {"sha": "520fa820898d4568518f21b88f877dc44c969adb", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=7e4ce834b2867f4c7bb2b44e434f5d2778e23ca3", "patch": "@@ -909,6 +909,8 @@ extern int ceil_log2\t\t\tPROTO((unsigned HOST_WIDE_INT));\n   plus_constant_for_output_wide (X, (HOST_WIDE_INT) (C))\n \n /* In explow.c */\n+extern HOST_WIDE_INT trunc_int_for_mode\tPROTO((HOST_WIDE_INT,\n+\t\t\t\t\t       enum machine_mode));\n extern rtx plus_constant_wide\t\t PROTO((rtx, HOST_WIDE_INT));\n extern rtx plus_constant_for_output_wide PROTO((rtx, HOST_WIDE_INT));\n extern void optimize_save_area_alloca\tPROTO((rtx));"}]}