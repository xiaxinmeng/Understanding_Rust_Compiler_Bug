{"sha": "bf6d9fd730ee324567bc8aaf70e6effa557e0d25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY2ZDlmZDczMGVlMzI0NTY3YmM4YWFmNzBlNmVmZmE1NTdlMGQyNQ==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "2000-10-20T04:56:21Z"}, "committer": {"name": "John Wehle", "email": "wehle@gcc.gnu.org", "date": "2000-10-20T04:56:21Z"}, "message": "alias.c: (mark_constant_function): Don't check pure functions.\n\n\t* alias.c: (mark_constant_function): Don't check pure functions.\n\tInitialize and end alias analysis.\n\t(nonlocal_mentioned_p): Rename from nonlocal_reference_p.\n\tDon't make a special exception for recursion.  Handle\n\tUNSPEC_VOLATILE.  Don't assume ASM_OPERANDS is non-local\n\tunless it's volatile.\n\n\t* local-alloc.c (equivalence): New structure.\n\t(reg_equiv): Define.\n\t(contains_replace_regs): Remove array and use\n\tfield in reg_equiv.\n\t(memref_referenced_p): Likewise.\n\t(no_equiv): Likewise.\n\t(update_equiv_regs): Likewise.\n\n\t(equiv_init_varies_p,\n\tequiv_init_movable_p): New functions.\n\t(update_equiv_regs): Use them.  Use rtx_varies_p\n\tinstead of function_invariant_p.  Process insns\n\tfrom end to beginning.  Allow a REG_EQUIV insn\n\twithin the same loop as a use to be moved, also\n\tallow it to be moved out of a loop.  Update\n\tREG_DEAD notes when substituting into an insn.\n\nFrom-SVN: r36957", "tree": {"sha": "201554ac1d3485982312d26bdd55e6a11243e633", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/201554ac1d3485982312d26bdd55e6a11243e633"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf6d9fd730ee324567bc8aaf70e6effa557e0d25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf6d9fd730ee324567bc8aaf70e6effa557e0d25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf6d9fd730ee324567bc8aaf70e6effa557e0d25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf6d9fd730ee324567bc8aaf70e6effa557e0d25/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cab8e2bd65e10cbd59f4240056710c9653aa4418", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cab8e2bd65e10cbd59f4240056710c9653aa4418", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cab8e2bd65e10cbd59f4240056710c9653aa4418"}], "stats": {"total": 438, "additions": 325, "deletions": 113}, "files": [{"sha": "271f0a3ae1257d36ee0f4a0d99e71b8a6f16f941", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6d9fd730ee324567bc8aaf70e6effa557e0d25/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6d9fd730ee324567bc8aaf70e6effa557e0d25/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf6d9fd730ee324567bc8aaf70e6effa557e0d25", "patch": "@@ -1,3 +1,29 @@\n+Fri Oct 20 00:57:00 EDT 2000  John Wehle  (john@feith.com)\n+\n+\t* alias.c: (mark_constant_function): Don't check pure functions.\n+\tInitialize and end alias analysis.\n+\t(nonlocal_mentioned_p): Rename from nonlocal_reference_p.\n+\tDon't make a special exception for recursion.  Handle\n+\tUNSPEC_VOLATILE.  Don't assume ASM_OPERANDS is non-local\n+\tunless it's volatile.\n+\n+\t* local-alloc.c (equivalence): New structure.\n+\t(reg_equiv): Define.\n+\t(contains_replace_regs): Remove array and use\n+\tfield in reg_equiv.\n+\t(memref_referenced_p): Likewise.\n+\t(no_equiv): Likewise.\n+\t(update_equiv_regs): Likewise.\n+\n+\t(equiv_init_varies_p,\n+\tequiv_init_movable_p): New functions.\n+\t(update_equiv_regs): Use them.  Use rtx_varies_p\n+\tinstead of function_invariant_p.  Process insns\n+\tfrom end to beginning.  Allow a REG_EQUIV insn\n+\twithin the same loop as a use to be moved, also\n+\tallow it to be moved out of a loop.  Update\n+\tREG_DEAD notes when substituting into an insn.\n+\n 2000-10-19  Jim Wilson  <wilson@cygnus.com>\n \n \t* c-decl.c (start_decl): Check for error_mark_node type before using"}, {"sha": "09c4530398a4a271625c6436d8fd8cccf4f76082", "filename": "gcc/alias.c", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6d9fd730ee324567bc8aaf70e6effa557e0d25/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6d9fd730ee324567bc8aaf70e6effa557e0d25/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=bf6d9fd730ee324567bc8aaf70e6effa557e0d25", "patch": "@@ -103,7 +103,7 @@ static rtx fixed_scalar_and_varying_struct_p PARAMS ((rtx, rtx, rtx, rtx,\n \t\t\t\t\t\t      int (*) (rtx)));\n static int aliases_everything_p         PARAMS ((rtx));\n static int write_dependence_p           PARAMS ((rtx, rtx, int));\n-static int nonlocal_reference_p         PARAMS ((rtx));\n+static int nonlocal_mentioned_p         PARAMS ((rtx));\n \n /* Set up all info needed to perform alias analysis on memory references.  */\n \n@@ -1728,11 +1728,11 @@ output_dependence (mem, x)\n   return write_dependence_p (mem, x, /*writep=*/1);\n }\n \n-/* Returns non-zero if X might refer to something which is not\n+/* Returns non-zero if X mentions something which is not\n    local to the function and is not constant.  */\n \n static int\n-nonlocal_reference_p (x)\n+nonlocal_mentioned_p (x)\n      rtx x;\n {\n   rtx base;\n@@ -1792,13 +1792,7 @@ nonlocal_reference_p (x)\n       return 1;\n \n     case CALL:\n-      /* Recursion introduces no additional considerations.  */\n-      if (GET_CODE (XEXP (x, 0)) == MEM\n-\t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n-\t  && strcmp(XSTR (XEXP (XEXP (x, 0), 0), 0),\n-\t\t    IDENTIFIER_POINTER (\n-\t\t\t  DECL_ASSEMBLER_NAME (current_function_decl))) == 0)\n-\treturn 0;\n+      /* Non-constant calls and recursion are not local.  */\n       return 1;\n \n     case MEM:\n@@ -1829,10 +1823,16 @@ nonlocal_reference_p (x)\n \t}\n       return 1;\n \n+    case UNSPEC_VOLATILE:\n     case ASM_INPUT:\n-    case ASM_OPERANDS:\n       return 1;\n \n+    case ASM_OPERANDS:\n+      if (MEM_VOLATILE_P (x))\n+\treturn 1;\n+\n+    /* FALLTHROUGH */\n+\n     default:\n       break;\n     }\n@@ -1847,14 +1847,14 @@ nonlocal_reference_p (x)\n       {\n \tif (fmt[i] == 'e' && XEXP (x, i))\n \t  {\n-\t    if (nonlocal_reference_p (XEXP (x, i)))\n+\t    if (nonlocal_mentioned_p (XEXP (x, i)))\n \t      return 1;\n \t  }\n \telse if (fmt[i] == 'E')\n \t  {\n \t    register int j;\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n-\t      if (nonlocal_reference_p (XVECEXP (x, i, j)))\n+\t      if (nonlocal_mentioned_p (XVECEXP (x, i, j)))\n \t\treturn 1;\n \t  }\n       }\n@@ -1869,22 +1869,34 @@ void\n mark_constant_function ()\n {\n   rtx insn;\n+  int nonlocal_mentioned;\n \n   if (TREE_PUBLIC (current_function_decl)\n       || TREE_READONLY (current_function_decl)\n+      || DECL_IS_PURE (current_function_decl)\n       || TREE_THIS_VOLATILE (current_function_decl)\n       || TYPE_MODE (TREE_TYPE (current_function_decl)) == VOIDmode)\n     return;\n \n+  nonlocal_mentioned = 0;\n+\n+  init_alias_analysis ();\n+\n   /* Determine if this is a constant function.  */\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn) && nonlocal_reference_p (insn))\n-      return;\n+    if (INSN_P (insn) && nonlocal_mentioned_p (insn))\n+      {\n+\tnonlocal_mentioned = 1;\n+\tbreak;\n+      }\n+\n+  end_alias_analysis ();\n \n   /* Mark the function.  */\n \n-  TREE_READONLY (current_function_decl) = 1;\n+  if (! nonlocal_mentioned)\n+    TREE_READONLY (current_function_decl) = 1;\n }\n \n "}, {"sha": "d581d5c96be61a143f618e5efb5fc83f36846d44", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 271, "deletions": 97, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6d9fd730ee324567bc8aaf70e6effa557e0d25/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6d9fd730ee324567bc8aaf70e6effa557e0d25/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=bf6d9fd730ee324567bc8aaf70e6effa557e0d25", "patch": "@@ -236,23 +236,45 @@ static HARD_REG_SET *regs_live_at;\n static int this_insn_number;\n static rtx this_insn;\n \n-/* Used to communicate changes made by update_equiv_regs to\n-   memref_referenced_p.  reg_equiv_replacement is set for any REG_EQUIV note\n-   found or created, so that we can keep track of what memory accesses might\n-   be created later, e.g. by reload.  */\n+struct equivalence\n+{\n+  /* Set when an attempt should be made to replace a register\n+     with the associated src entry.  */\n+\n+  char replace;\n+\n+  /* Set when a REG_EQUIV note is found or created.  Use to\n+     keep track of what memory accesses might be created later,\n+     e.g. by reload.  */\n+\n+  rtx replacement;\n+\n+  rtx src;\n+\n+  /* Loop depth is used to recognize equivalences which appear\n+     to be present within the same loop (or in an inner loop).  */\n+\n+  int loop_depth;\n \n-static rtx *reg_equiv_replacement;\n+  /* The list of each instruction which initializes this register.  */\n \n-/* Used for communication between update_equiv_regs and no_equiv.  */\n-static rtx *reg_equiv_init_insns;\n+  rtx init_insns;\n+};\n+\n+/* reg_equiv[N] (where N is a pseudo reg number) is the equivalence\n+   structure for that register.  */\n+\n+static struct equivalence *reg_equiv;\n \n /* Nonzero if we recorded an equivalence for a LABEL_REF.  */\n static int recorded_label_ref;\n \n static void alloc_qty\t\tPARAMS ((int, enum machine_mode, int, int));\n static void validate_equiv_mem_from_store PARAMS ((rtx, rtx, void *));\n static int validate_equiv_mem\tPARAMS ((rtx, rtx, rtx));\n-static int contains_replace_regs PARAMS ((rtx, char *));\n+static int equiv_init_varies_p  PARAMS ((rtx));\n+static int equiv_init_movable_p PARAMS ((rtx, int));\n+static int contains_replace_regs PARAMS ((rtx));\n static int memref_referenced_p\tPARAMS ((rtx, rtx));\n static int memref_used_between_p PARAMS ((rtx, rtx, rtx));\n static void update_equiv_regs\tPARAMS ((void));\n@@ -415,9 +437,6 @@ local_alloc ()\n   return recorded_label_ref;\n }\n \f\n-/* Depth of loops we are in while in update_equiv_regs.  */\n-static int loop_depth;\n-\n /* Used for communication between the following two functions: contains\n    a MEM that we wish to ensure remains unchanged.  */\n static rtx equiv_mem;\n@@ -495,12 +514,133 @@ validate_equiv_mem (start, reg, memref)\n   return 0;\n }\n \n-/* TRUE if X uses any registers for which reg_equiv_replace is true.  */\n+/* Returns zero if X is known to be invariant.  */\n \n static int\n-contains_replace_regs (x, reg_equiv_replace)\n+equiv_init_varies_p (x)\n+     rtx x;\n+{\n+  register RTX_CODE code = GET_CODE (x);\n+  register int i;\n+  register const char *fmt;\n+\n+  switch (code)\n+    {\n+    case MEM:\n+      return ! RTX_UNCHANGING_P (x) || equiv_init_varies_p (XEXP (x, 0));\n+\n+    case QUEUED:\n+      return 1;\n+\n+    case CONST:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 0;\n+\n+    case REG:\n+      return reg_equiv[REGNO (x)].replace == 0 && rtx_varies_p (x);\n+\n+    case ASM_OPERANDS:\n+      if (MEM_VOLATILE_P (x))\n+\treturn 1;\n+\n+      /* FALLTHROUGH */\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    if (fmt[i] == 'e')\n+      {\n+\tif (equiv_init_varies_p (XEXP (x, i)))\n+\t  return 1;\n+      }\n+    else if (fmt[i] == 'E')\n+      {\n+\tint j;\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  if (equiv_init_varies_p (XVECEXP (x, i, j)))\n+\t    return 1;\n+      }\n+\n+  return 0;\n+}\n+\n+/* Returns non-zero if X (used to initialize register REGNO) is movable.\n+   X is only movable if the registers it uses have equivalent initializations\n+   which appear to be within the same loop (or in an inner loop) and movable\n+   or if they are not candidates for local_alloc and don't vary.  */\n+\n+static int\n+equiv_init_movable_p (x, regno)\n+     rtx x;\n+     int regno;\n+{\n+  int i, j;\n+  const char *fmt;\n+  enum rtx_code code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case SET:\n+      return equiv_init_movable_p (SET_SRC (x), regno);\n+\n+    case CLOBBER:\n+      return 0;\n+\n+    case PRE_INC:\n+    case PRE_DEC:\n+    case POST_INC:\n+    case POST_DEC:\n+    case PRE_MODIFY:\n+    case POST_MODIFY:\n+      return 0;\n+\n+    case REG:\n+      return (reg_equiv[REGNO (x)].loop_depth >= reg_equiv[regno].loop_depth\n+\t      && reg_equiv[REGNO (x)].replace)\n+\t     || (REG_BASIC_BLOCK (REGNO (x)) < 0 && ! rtx_varies_p (x));\n+\n+    case UNSPEC_VOLATILE:\n+      return 0;\n+\n+    case ASM_OPERANDS:\n+      if (MEM_VOLATILE_P (x))\n+\treturn 0;\n+\n+      /* FALLTHROUGH */\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    switch (fmt[i])\n+      {\n+      case 'e':\n+\tif (! equiv_init_movable_p (XEXP (x, i), regno))\n+\t  return 0;\n+\tbreak;\n+      case 'E':\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  if (! equiv_init_movable_p (XVECEXP (x, i, j), regno))\n+\t    return 0;\n+\tbreak;\n+      }\n+\n+  return 1;\n+}\n+\n+/* TRUE if X uses any registers for which reg_equiv[REGNO].replace is true.  */\n+\n+static int\n+contains_replace_regs (x)\n      rtx x;\n-     char *reg_equiv_replace;\n {\n   int i, j;\n   const char *fmt;\n@@ -520,7 +660,7 @@ contains_replace_regs (x, reg_equiv_replace)\n       return 0;\n \n     case REG:\n-      return reg_equiv_replace[REGNO (x)];\n+      return reg_equiv[REGNO (x)].replace;\n \n     default:\n       break;\n@@ -531,12 +671,12 @@ contains_replace_regs (x, reg_equiv_replace)\n     switch (fmt[i])\n       {\n       case 'e':\n-\tif (contains_replace_regs (XEXP (x, i), reg_equiv_replace))\n+\tif (contains_replace_regs (XEXP (x, i)))\n \t  return 1;\n \tbreak;\n       case 'E':\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  if (contains_replace_regs (XVECEXP (x, i, j), reg_equiv_replace))\n+\t  if (contains_replace_regs (XVECEXP (x, i, j)))\n \t    return 1;\n \tbreak;\n       }\n@@ -570,9 +710,9 @@ memref_referenced_p (memref, x)\n       return 0;\n \n     case REG:\n-      return (reg_equiv_replacement[REGNO (x)]\n+      return (reg_equiv[REGNO (x)].replacement\n \t      && memref_referenced_p (memref,\n-\t\t\t\t      reg_equiv_replacement[REGNO (x)]));\n+\t\t\t\t      reg_equiv[REGNO (x)].replacement));\n \n     case MEM:\n       if (true_dependence (memref, VOIDmode, x, rtx_varies_p))\n@@ -660,23 +800,18 @@ function_invariant_p (x)\n static void\n update_equiv_regs ()\n {\n-  /* Set when an attempt should be made to replace a register with the\n-     associated reg_equiv_replacement entry at the end of this function.  */\n-  char *reg_equiv_replace;\n   rtx insn;\n-  int block, depth;\n+  int block;\n+  int loop_depth;\n \n-  reg_equiv_replace = (char *) xcalloc (max_regno, sizeof *reg_equiv_replace);\n-  reg_equiv_init_insns = (rtx *) xcalloc (max_regno, sizeof (rtx));\n-  reg_equiv_replacement = (rtx *) xcalloc (max_regno, sizeof (rtx));\n+  reg_equiv = (struct equivalence *) xcalloc (max_regno, sizeof *reg_equiv);\n \n   init_alias_analysis ();\n \n-  loop_depth = 0;\n-\n   /* Scan the insns and find which registers have equivalences.  Do this\n      in a separate scan of the insns because (due to -fcse-follow-jumps)\n      a register can be set below its use.  */\n+  loop_depth = 0;\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       rtx note;\n@@ -687,9 +822,13 @@ update_equiv_regs ()\n       if (GET_CODE (insn) == NOTE)\n \t{\n \t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\t    loop_depth++;\n+\t    ++loop_depth;\n \t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n-\t    loop_depth--;\n+\t    {\n+\t      if (! loop_depth)\n+\t\tabort ();\n+\t      --loop_depth;\n+\t    }\n \t}\n \n       if (! INSN_P (insn))\n@@ -732,29 +871,29 @@ update_equiv_regs ()\n \t Don't add a REG_EQUIV note if the insn already has one.  The existing\n \t REG_EQUIV is likely more useful than the one we are adding.\n \n-\t If one of the regs in the address is marked as reg_equiv_replace,\n-\t then we can't add this REG_EQUIV note.  The reg_equiv_replace\n+\t If one of the regs in the address has reg_equiv[REGNO].replace set,\n+\t then we can't add this REG_EQUIV note.  The reg_equiv[REGNO].replace\n \t optimization may move the set of this register immediately before\n-\t insn, which puts it after reg_equiv_init_insns[regno], and hence\n+\t insn, which puts it after reg_equiv[REGNO].init_insns, and hence\n \t the mention in the REG_EQUIV note would be to an uninitialized\n \t pseudo.  */\n       /* ????? This test isn't good enough; we might see a MEM with a use of\n \t a pseudo register before we see its setting insn that will cause\n-\t reg_equiv_replace for that pseudo to be set.\n+\t reg_equiv[].replace for that pseudo to be set.\n \t Equivalences to MEMs should be made in another pass, after the\n-\t reg_equiv_replace information has been gathered.  */\n+\t reg_equiv[].replace information has been gathered.  */\n \n       if (GET_CODE (dest) == MEM && GET_CODE (src) == REG\n \t  && (regno = REGNO (src)) >= FIRST_PSEUDO_REGISTER\n \t  && REG_BASIC_BLOCK (regno) >= 0\n \t  && REG_N_SETS (regno) == 1\n-\t  && reg_equiv_init_insns[regno] != 0\n-\t  && reg_equiv_init_insns[regno] != const0_rtx\n-\t  && ! find_reg_note (XEXP (reg_equiv_init_insns[regno], 0),\n+\t  && reg_equiv[regno].init_insns != 0\n+\t  && reg_equiv[regno].init_insns != const0_rtx\n+\t  && ! find_reg_note (XEXP (reg_equiv[regno].init_insns, 0),\n \t\t\t      REG_EQUIV, NULL_RTX)\n-\t  && ! contains_replace_regs (XEXP (dest, 0), reg_equiv_replace))\n+\t  && ! contains_replace_regs (XEXP (dest, 0)))\n \t{\n-\t  rtx init_insn = XEXP (reg_equiv_init_insns[regno], 0);\n+\t  rtx init_insn = XEXP (reg_equiv[regno].init_insns, 0);\n \t  if (validate_equiv_mem (init_insn, src, dest)\n \t      && ! memref_used_between_p (dest, init_insn, insn))\n \t    REG_NOTES (init_insn)\n@@ -775,7 +914,7 @@ update_equiv_regs ()\n \n       if (GET_CODE (dest) != REG\n \t  || (regno = REGNO (dest)) < FIRST_PSEUDO_REGISTER\n-\t  || reg_equiv_init_insns[regno] == const0_rtx\n+\t  || reg_equiv[regno].init_insns == const0_rtx\n \t  || (CLASS_LIKELY_SPILLED_P (reg_preferred_class (regno))\n \t      && GET_CODE (src) == MEM))\n \t{\n@@ -790,27 +929,32 @@ update_equiv_regs ()\n       /* cse sometimes generates function invariants, but doesn't put a\n \t REG_EQUAL note on the insn.  Since this note would be redundant,\n          there's no point creating it earlier than here.  */\n-      if (! note && function_invariant_p (src))\n+      if (! note && ! rtx_varies_p (src))\n \tREG_NOTES (insn)\n \t  = note = gen_rtx_EXPR_LIST (REG_EQUAL, src, REG_NOTES (insn));\n \n+      /* Don't bother considering a REG_EQUAL note containing an EXPR_LIST\n+\t since it represents a function call */\n+      if (note && GET_CODE (XEXP (note, 0)) == EXPR_LIST)\n+\tnote = NULL_RTX;\n+\n       if (REG_N_SETS (regno) != 1\n \t  && (! note\n-\t      || ! function_invariant_p (XEXP (note, 0))\n-\t      || (reg_equiv_replacement[regno]\n+\t      || rtx_varies_p (XEXP (note, 0))\n+\t      || (reg_equiv[regno].replacement\n \t\t  && ! rtx_equal_p (XEXP (note, 0),\n-\t\t\t\t    reg_equiv_replacement[regno]))))\n+\t\t\t\t    reg_equiv[regno].replacement))))\n \t{\n \t  no_equiv (dest, set, NULL);\n \t  continue;\n \t}\n       /* Record this insn as initializing this register.  */\n-      reg_equiv_init_insns[regno]\n-\t= gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv_init_insns[regno]);\n+      reg_equiv[regno].init_insns\n+\t= gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv[regno].init_insns);\n \n       /* If this register is known to be equal to a constant, record that\n \t it is always equivalent to the constant.  */\n-      if (note && function_invariant_p (XEXP (note, 0)))\n+      if (note && ! rtx_varies_p (XEXP (note, 0)))\n \tPUT_MODE (note, (enum machine_mode) REG_EQUIV);\n \n       /* If this insn introduces a \"constant\" register, decrease the priority\n@@ -852,7 +996,9 @@ update_equiv_regs ()\n \t\t      == LABEL_REF)))\n \t    recorded_label_ref = 1;\n \n-\t  reg_equiv_replacement[regno] = XEXP (note, 0);\n+\t  reg_equiv[regno].replacement = XEXP (note, 0);\n+\t  reg_equiv[regno].src = src;\n+\t  reg_equiv[regno].loop_depth = loop_depth;\n \n \t  /* Don't mess with things live during setjmp.  */\n \t  if (REG_LIVE_LENGTH (regno) >= 0)\n@@ -864,9 +1010,11 @@ update_equiv_regs ()\n \n \t      /* If the register is referenced exactly twice, meaning it is\n \t\t set once and used once, indicate that the reference may be\n-\t\t replaced by the equivalence we computed above.  If the\n-\t\t register is only used in one basic block, this can't succeed\n-\t\t or combine would have done it.\n+\t\t replaced by the equivalence we computed above.  Do this\n+\t\t even if the register is only used in one block so that\n+\t\t dependencies can be handled where the last register is\n+\t\t used in a different block (i.e. HIGH / LO_SUM sequences)\n+\t\t and to reduce the number of registers alive across calls.\n \n \t\t It would be nice to use \"loop_depth * 2\" in the compare\n \t\t below.  Unfortunately, LOOP_DEPTH need not be constant within\n@@ -876,9 +1024,11 @@ update_equiv_regs ()\n \t\t memory and then used exactly once, not in a loop.  */\n \n \t\tif (REG_N_REFS (regno) == 2\n-\t\t    && REG_BASIC_BLOCK (regno) < 0\n-\t\t    && rtx_equal_p (XEXP (note, 0), SET_SRC (set)))\n-\t\t  reg_equiv_replace[regno] = 1;\n+\t\t    && (rtx_equal_p (XEXP (note, 0), src)\n+\t\t\t|| ! equiv_init_varies_p (src))\n+\t\t    && GET_CODE (insn) == INSN\n+\t\t    && equiv_init_movable_p (PATTERN (insn), regno))\n+\t\t  reg_equiv[regno].replace = 1;\n \t    }\n \t}\n     }\n@@ -887,32 +1037,34 @@ update_equiv_regs ()\n      registers only used that once.  If so, see if we can replace the\n      reference with the equivalent from.  If we can, delete the\n      initializing reference and this register will go away.  If we\n-     can't replace the reference, and the instruction is not in a\n-     loop, then move the register initialization just before the use,\n-     so that they are in the same basic block.  */\n-  block = -1;\n-  depth = 0;\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+     can't replace the reference, and the initialzing reference is\n+     within the same loop (or in an inner loop), then move the register\n+     initialization just before the use, so that they are in the same\n+     basic block.\n+\n+     Skip this optimization if loop_depth isn't initially zero since\n+     that indicates a mismatch between loop begin and loop end notes\n+     (i.e. gcc.dg/noncompile/920721-2.c).  */\n+  block = n_basic_blocks - 1;\n+  for (insn = (loop_depth == 0) ? get_last_insn () : NULL_RTX;\n+       insn; insn = PREV_INSN (insn))\n     {\n       rtx link;\n \n-      /* Keep track of which basic block we are in.  */\n-      if (block + 1 < n_basic_blocks\n-\t  && BLOCK_HEAD (block + 1) == insn)\n-\t++block;\n-\n       if (! INSN_P (insn))\n \t{\n \t  if (GET_CODE (insn) == NOTE)\n \t    {\n-\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\t\t++depth;\n-\t      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n+\t      if (NOTE_INSN_BASIC_BLOCK_P (insn))\n+\t\tblock = NOTE_BASIC_BLOCK (insn)->index - 1;\n+\t      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n \t\t{\n-\t\t  --depth;\n-\t\t  if (depth < 0)\n+\t\t  if (! loop_depth)\n \t\t    abort ();\n+\t\t  --loop_depth;\n \t\t}\n+\t      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n+\t\t++loop_depth;\n \t    }\n \n \t  continue;\n@@ -927,33 +1079,54 @@ update_equiv_regs ()\n \t      int regno = REGNO (XEXP (link, 0));\n \t      rtx equiv_insn;\n \n-\t      if (! reg_equiv_replace[regno])\n+\t      if (! reg_equiv[regno].replace\n+\t\t  || reg_equiv[regno].loop_depth < loop_depth)\n \t\tcontinue;\n \n-\t      /* reg_equiv_replace[REGNO] gets set only when\n+\t      /* reg_equiv[REGNO].replace gets set only when\n \t\t REG_N_REFS[REGNO] is 2, i.e. the register is set\n \t\t once and used once.  (If it were only set, but not used,\n \t\t flow would have deleted the setting insns.)  Hence\n-\t\t there can only be one insn in reg_equiv_init_insns.  */\n-\t      equiv_insn = XEXP (reg_equiv_init_insns[regno], 0);\n+\t\t there can only be one insn in reg_equiv[REGNO].init_insns.  */\n+\t      equiv_insn = XEXP (reg_equiv[regno].init_insns, 0);\n \n-\t      if (validate_replace_rtx (regno_reg_rtx[regno],\n-\t\t\t\t\treg_equiv_replacement[regno], insn))\n+\t      if (asm_noperands (PATTERN (equiv_insn)) < 0\n+\t\t  && validate_replace_rtx (regno_reg_rtx[regno],\n+\t\t\t\t\t   reg_equiv[regno].src, insn))\n \t\t{\n+\t\t  rtx equiv_link;\n+\t\t  rtx last_link;\n+\t\t  rtx note;\n+\n+\t\t  /* Find the last note.  */\n+\t\t  for (last_link = link; XEXP (last_link, 1);\n+\t\t       last_link = XEXP (last_link, 1))\n+\t\t    ;\n+\n+\t\t  /* Append the REG_DEAD notes from equiv_insn.  */\n+\t\t  equiv_link = REG_NOTES (equiv_insn);\n+\t\t  while (equiv_link)\n+\t\t    {\n+\t\t      note = equiv_link;\n+\t\t      equiv_link = XEXP (equiv_link, 1);\n+\t\t      if (REG_NOTE_KIND (note) == REG_DEAD)\n+\t\t\t{\n+\t\t\t  remove_note (equiv_insn, note);\n+\t\t\t  XEXP (last_link, 1) = note;\n+\t\t\t  XEXP (note, 1) = NULL_RTX;\n+\t\t\t  last_link = note;\n+\t\t\t}\n+\t\t    }\n+\n \t\t  remove_death (regno, insn);\n \t\t  REG_N_REFS (regno) = 0;\n \t\t  PUT_CODE (equiv_insn, NOTE);\n \t\t  NOTE_LINE_NUMBER (equiv_insn) = NOTE_INSN_DELETED;\n \t\t  NOTE_SOURCE_FILE (equiv_insn) = 0;\n \t\t}\n-\t      /* If we aren't in a loop, and there are no calls in\n-\t\t INSN or in the initialization of the register, then\n-\t\t move the initialization of the register to just\n-\t\t before INSN.  Update the flow information.  */\n-\t      else if (depth == 0\n-\t\t       && GET_CODE (equiv_insn) == INSN\n-\t\t       && GET_CODE (insn) == INSN\n-\t\t       && REG_BASIC_BLOCK (regno) < 0)\n+\t      /* Move the initialization of the register to just before\n+\t\t INSN.  Update the flow information.  */\n+\t      else if (PREV_INSN (insn) != equiv_insn)\n \t\t{\n \t\t  int l;\n \n@@ -965,29 +1138,30 @@ update_equiv_regs ()\n \t\t  NOTE_LINE_NUMBER (equiv_insn) = NOTE_INSN_DELETED;\n \t\t  NOTE_SOURCE_FILE (equiv_insn) = 0;\n \n-\t\t  if (block < 0)\n-\t\t    REG_BASIC_BLOCK (regno) = 0;\n-\t\t  else\n-\t\t    REG_BASIC_BLOCK (regno) = block;\n+\t\t  REG_BASIC_BLOCK (regno) = block >= 0 ? block : 0;\n \t\t  REG_N_CALLS_CROSSED (regno) = 0;\n \t\t  REG_LIVE_LENGTH (regno) = 2;\n \n \t\t  if (block >= 0 && insn == BLOCK_HEAD (block))\n \t\t    BLOCK_HEAD (block) = PREV_INSN (insn);\n \n \t\t  for (l = 0; l < n_basic_blocks; l++)\n-\t\t    CLEAR_REGNO_REG_SET (BASIC_BLOCK (l)->global_live_at_start,\n-\t\t\t\t\t regno);\n+\t\t    {\n+\t\t      CLEAR_REGNO_REG_SET (\n+\t\t\t\t\tBASIC_BLOCK (l)->global_live_at_start,\n+\t\t\t\t\t   regno);\n+\t\t      CLEAR_REGNO_REG_SET (\n+\t\t\t\t\tBASIC_BLOCK (l)->global_live_at_end,\n+\t\t\t\t\t   regno);\n+\t\t    }\n \t\t}\n \t    }\n \t}\n     }\n \n   /* Clean up.  */\n   end_alias_analysis ();\n-  free (reg_equiv_replace);\n-  free (reg_equiv_init_insns);\n-  free (reg_equiv_replacement);\n+  free (reg_equiv);\n }\n \n /* Mark REG as having no known equivalence.\n@@ -1008,16 +1182,16 @@ no_equiv (reg, store, data)\n   if (GET_CODE (reg) != REG)\n     return;\n   regno = REGNO (reg);\n-  list = reg_equiv_init_insns[regno];\n+  list = reg_equiv[regno].init_insns;\n   if (list == const0_rtx)\n     return;\n   for (; list; list =  XEXP (list, 1))\n     {\n       rtx insn = XEXP (list, 0);\n       remove_note (insn, find_reg_note (insn, REG_EQUIV, NULL_RTX));\n     }\n-  reg_equiv_init_insns[regno] = const0_rtx;\n-  reg_equiv_replacement[regno] = NULL_RTX;\n+  reg_equiv[regno].init_insns = const0_rtx;\n+  reg_equiv[regno].replacement = NULL_RTX;\n }\n \f\n /* Allocate hard regs to the pseudo regs used only within block number B."}]}