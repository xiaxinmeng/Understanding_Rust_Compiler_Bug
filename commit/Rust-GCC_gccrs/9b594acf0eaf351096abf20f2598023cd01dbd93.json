{"sha": "9b594acf0eaf351096abf20f2598023cd01dbd93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI1OTRhY2YwZWFmMzUxMDk2YWJmMjBmMjU5ODAyM2NkMDFkYmQ5Mw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-04-09T11:10:49Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-04-09T11:10:49Z"}, "message": "(substitute_in_expr): Don't return new expression if nothing changed.\n\n(substitute_in_type): Deleted, not used.\n\nFrom-SVN: r11683", "tree": {"sha": "9c61273f3e65f5eb5255308147c1a9ed0662bcba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c61273f3e65f5eb5255308147c1a9ed0662bcba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b594acf0eaf351096abf20f2598023cd01dbd93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b594acf0eaf351096abf20f2598023cd01dbd93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b594acf0eaf351096abf20f2598023cd01dbd93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b594acf0eaf351096abf20f2598023cd01dbd93/comments", "author": null, "committer": null, "parents": [{"sha": "b24884cd276925828c7e35e12b9e407ad32a1e70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b24884cd276925828c7e35e12b9e407ad32a1e70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b24884cd276925828c7e35e12b9e407ad32a1e70"}], "stats": {"total": 208, "additions": 44, "deletions": 164}, "files": [{"sha": "fcbcacd8e50eba1d6b2ff40def56f31df4180e74", "filename": "gcc/tree.c", "status": "modified", "additions": 44, "deletions": 164, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b594acf0eaf351096abf20f2598023cd01dbd93/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b594acf0eaf351096abf20f2598023cd01dbd93/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9b594acf0eaf351096abf20f2598023cd01dbd93", "patch": "@@ -2214,6 +2214,7 @@ substitute_in_expr (exp, f, r)\n      tree r;\n {\n   enum tree_code code = TREE_CODE (exp);\n+  tree op0, op1, op2;\n   tree new = 0;\n   tree inner;\n \n@@ -2235,9 +2236,11 @@ substitute_in_expr (exp, f, r)\n       switch (tree_code_length[(int) code])\n \t{\n \tcase 1:\n-\t  new = fold (build1 (code, TREE_TYPE (exp),\n-\t\t\t      substitute_in_expr (TREE_OPERAND (exp, 0),\n-\t\t\t\t\t\t  f, r)));\n+\t  op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n+\t  if (op0 == TREE_OPERAND (exp, 0))\n+\t    return exp;\n+\t  \n+\t  new = fold (build1 (code, TREE_TYPE (exp), op0));\n \t  break;\n \n \tcase 2:\n@@ -2248,10 +2251,12 @@ substitute_in_expr (exp, f, r)\n \t  else if (code == CONSTRUCTOR)\n \t    abort ();\n \n-\t  new = fold (build (code, TREE_TYPE (exp),\n-\t\t\t     substitute_in_expr (TREE_OPERAND (exp, 0), f, r),\n-\t\t\t     substitute_in_expr (TREE_OPERAND (exp, 1),\n-\t\t\t\t\t\t f, r)));\n+\t  op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n+\t  op1 = substitute_in_expr (TREE_OPERAND (exp, 1), f, r);\n+\t  if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))\n+\t    return exp;\n+\n+\t  new = fold (build (code, TREE_TYPE (exp), op0, op1));\n \t  break;\n \n \tcase 3:\n@@ -2263,11 +2268,14 @@ substitute_in_expr (exp, f, r)\n \t  if (code != COND_EXPR)\n \t    abort ();\n \n-\t  new = fold (build (code, TREE_TYPE (exp),\n-\t\t\t     substitute_in_expr (TREE_OPERAND (exp, 0), f, r),\n-\t\t\t     substitute_in_expr (TREE_OPERAND (exp, 1), f, r),\n-\t\t\t     substitute_in_expr (TREE_OPERAND (exp, 2),\n-\t\t\t\t\t\t f, r)));\n+\t  op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n+\t  op1 = substitute_in_expr (TREE_OPERAND (exp, 1), f, r);\n+\t  op2 = substitute_in_expr (TREE_OPERAND (exp, 2), f, r);\n+\t  if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)\n+\t      && op2 == TREE_OPERAND (exp, 2))\n+\t    return exp;\n+\n+\t  new = fold (build (code, TREE_TYPE (exp), op0, op1, op2));\n \t}\n \n       break;\n@@ -2292,29 +2300,41 @@ substitute_in_expr (exp, f, r)\n \t      && TREE_TYPE (inner) == 0)\n \t    return exp;\n \n-\t  new = fold (build (code, TREE_TYPE (exp),\n-\t\t\t     substitute_in_expr (TREE_OPERAND (exp, 0), f, r),\n+\t  op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n+\t  if (op0 == TREE_OPERAND (exp, 0))\n+\t    return exp;\n+\n+\t  new = fold (build (code, TREE_TYPE (exp), op0,\n \t\t\t     TREE_OPERAND (exp, 1)));\n \t  break;\n \n \tcase BIT_FIELD_REF:\n-\t  new = fold (build (code, TREE_TYPE (exp),\n-\t\t\t     substitute_in_expr (TREE_OPERAND (exp, 0), f, r),\n-\t\t\t     substitute_in_expr (TREE_OPERAND (exp, 1), f, r),\n-\t\t\t     substitute_in_expr (TREE_OPERAND (exp, 2), f, r)));\n+\t  op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n+\t  op1 = substitute_in_expr (TREE_OPERAND (exp, 1), f, r);\n+\t  op2 = substitute_in_expr (TREE_OPERAND (exp, 2), f, r);\n+\t  if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)\n+\t      && op2 == TREE_OPERAND (exp, 2))\n+\t    return exp;\n+\n+\t  new = fold (build (code, TREE_TYPE (exp), op0, op1, op2));\n \t  break;\n \n \tcase INDIRECT_REF:\n \tcase BUFFER_REF:\n-\t  new = fold (build1 (code, TREE_TYPE (exp),\n-\t\t\t      substitute_in_expr (TREE_OPERAND (exp, 0),\n-\t\t\t\t\t\t  f, r)));\n+\t  op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n+\t  if (op0 == TREE_OPERAND (exp, 0))\n+\t    return exp;\n+\n+\t  new = fold (build1 (code, TREE_TYPE (exp), op0));\n \t  break;\n \n \tcase OFFSET_REF:\n-\t  new = fold (build (code, TREE_TYPE (exp),\n-\t\t\t     substitute_in_expr (TREE_OPERAND (exp, 0), f, r),\n-\t\t\t     substitute_in_expr (TREE_OPERAND (exp, 1), f, r)));\n+\t  op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n+\t  op1 = substitute_in_expr (TREE_OPERAND (exp, 1), f, r);\n+\t  if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))\n+\t    return exp;\n+\n+\t  new = fold (build (code, TREE_TYPE (exp), op0, op1));\n \t  break;\n \t}\n     }\n@@ -2327,146 +2347,6 @@ substitute_in_expr (exp, f, r)\n   return new;\n }\n \f\n-/* Given a type T, a FIELD_DECL F, and a replacement value R,\n-   return a new type with all size expressions that contain F\n-   updated by replacing F with R.  */\n-\n-tree\n-substitute_in_type (t, f, r)\n-     tree t, f, r;\n-{\n-  switch (TREE_CODE (t))\n-    {\n-    case POINTER_TYPE:\n-    case VOID_TYPE:\n-      return t;\n-    case INTEGER_TYPE:\n-    case ENUMERAL_TYPE:\n-    case BOOLEAN_TYPE:\n-    case CHAR_TYPE:\n-      if ((TREE_CODE (TYPE_MIN_VALUE (t)) != INTEGER_CST\n-\t   && contains_placeholder_p (TYPE_MIN_VALUE (t)))\n-\t  || (TREE_CODE (TYPE_MAX_VALUE (t)) != INTEGER_CST\n-\t      && contains_placeholder_p (TYPE_MAX_VALUE (t))))\n-\treturn build_range_type (t,\n-\t\t\t\t substitute_in_expr (TYPE_MIN_VALUE (t), f, r),\n-\t\t\t\t substitute_in_expr (TYPE_MAX_VALUE (t), f, r));\n-      return t;\n-\n-    case REAL_TYPE:\n-      if ((TYPE_MIN_VALUE (t) != 0\n-\t   && TREE_CODE (TYPE_MIN_VALUE (t)) != REAL_CST\n-\t   && contains_placeholder_p (TYPE_MIN_VALUE (t)))\n-\t  || (TYPE_MAX_VALUE (t) != 0\n-\t      && TREE_CODE (TYPE_MAX_VALUE (t)) != REAL_CST\n-\t      && contains_placeholder_p (TYPE_MAX_VALUE (t))))\n-\t{\n-\t  t = build_type_copy (t);\n-\n-\t  if (TYPE_MIN_VALUE (t))\n-\t    TYPE_MIN_VALUE (t) = substitute_in_expr (TYPE_MIN_VALUE (t), f, r);\n-\t  if (TYPE_MAX_VALUE (t))\n-\t    TYPE_MAX_VALUE (t) = substitute_in_expr (TYPE_MAX_VALUE (t), f, r);\n-\t}\n-      return t;\n-\n-    case COMPLEX_TYPE:\n-      return build_complex_type (substitute_in_type (TREE_TYPE (t), f, r));\n-\n-    case OFFSET_TYPE:\n-    case METHOD_TYPE:\n-    case REFERENCE_TYPE:\n-    case FILE_TYPE:\n-    case SET_TYPE:\n-    case FUNCTION_TYPE:\n-    case LANG_TYPE:\n-      /* Don't know how to do these yet.  */\n-      abort ();\n-\n-    case ARRAY_TYPE:\n-      t = build_array_type (substitute_in_type (TREE_TYPE (t), f, r),\n-\t\t\t    substitute_in_type (TYPE_DOMAIN (t), f, r));\n-      TYPE_SIZE (t) = 0;\n-      layout_type (t);\n-      return t;\n-\n-    case RECORD_TYPE:\n-    case UNION_TYPE:\n-    case QUAL_UNION_TYPE:\n-      {\n-\ttree new = copy_node (t);\n-\ttree field;\n-\ttree last_field = 0;\n-\n-\t/* Start out with no fields, make new fields, and chain them\n-\t   in.  */\n-\n-\tTYPE_FIELDS (new) = 0;\n-\tTYPE_SIZE (new) = 0;\n-\n-\tfor (field = TYPE_FIELDS (t); field;\n-\t     field = TREE_CHAIN (field))\n-\t  {\n-\t    tree new_field = copy_node (field);\n-\n-\t    TREE_TYPE (new_field)\n-\t      = substitute_in_type (TREE_TYPE (new_field), f, r);\n-\n-\t    /* If this is an anonymous field and the type of this field is\n-\t       a UNION_TYPE or RECORD_TYPE with no elements, ignore it.  If\n-\t       the type just has one element, treat that as the field. \n-\t       But don't do this if we are processing a QUAL_UNION_TYPE.  */\n-\t    if (TREE_CODE (t) != QUAL_UNION_TYPE && DECL_NAME (new_field) == 0\n-\t\t&& (TREE_CODE (TREE_TYPE (new_field)) == UNION_TYPE\n-\t\t    || TREE_CODE (TREE_TYPE (new_field)) == RECORD_TYPE))\n-\t      {\n-\t\tif (TYPE_FIELDS (TREE_TYPE (new_field)) == 0)\n-\t\t  continue;\n-\n-\t\tif (TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (new_field))) == 0)\n-\t\t  new_field = TYPE_FIELDS (TREE_TYPE (new_field));\n-\t      }\n-\n-\t    DECL_CONTEXT (new_field) = new;\n-\t    DECL_SIZE (new_field) = 0;\n-\n-\t    if (TREE_CODE (t) == QUAL_UNION_TYPE)\n-\t      {\n-\t\t/* Do the substitution inside the qualifier and if we find\n-\t\t   that this field will not be present, omit it.  */\n-\t\tDECL_QUALIFIER (new_field)\n-\t\t  = substitute_in_expr (DECL_QUALIFIER (field), f, r);\n-\t\tif (integer_zerop (DECL_QUALIFIER (new_field)))\n-\t\t  continue;\n-\t      }\n-\n-\t    if (last_field == 0)\n-\t      TYPE_FIELDS (new) = new_field;\n-\t    else\n-\t      TREE_CHAIN (last_field) = new_field;\n-\n-\t    last_field = new_field;\n-\n-\t    /* If this is a qualified type and this field will always be\n-\t       present, we are done.  */\n-\t    if (TREE_CODE (t) == QUAL_UNION_TYPE\n-\t\t&& integer_onep (DECL_QUALIFIER (new_field)))\n-\t      break;\n-\t  }\n-\n-\t/* If this used to be a qualified union type, but we now know what\n-\t   field will be present, make this a normal union.  */\n-\tif (TREE_CODE (new) == QUAL_UNION_TYPE\n-\t    && (TYPE_FIELDS (new) == 0\n-\t\t|| integer_onep (DECL_QUALIFIER (TYPE_FIELDS (new)))))\n-\t  TREE_SET_CODE (new, UNION_TYPE);\n-\n-\tlayout_type (new);\n-\treturn new;\n-      }\n-    }\n-}\n-\f\n /* Stabilize a reference so that we can use it any number of times\n    without causing its operands to be evaluated more than once.\n    Returns the stabilized reference.  This works by means of save_expr,"}]}