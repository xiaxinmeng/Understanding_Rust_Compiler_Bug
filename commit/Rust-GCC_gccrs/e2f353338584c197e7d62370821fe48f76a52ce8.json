{"sha": "e2f353338584c197e7d62370821fe48f76a52ce8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJmMzUzMzM4NTg0YzE5N2U3ZDYyMzcwODIxZmU0OGY3NmE1MmNlOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-30T14:43:45Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-30T14:43:45Z"}, "message": "re PR c++/80913 (Infinite loop in cc1plus with stat hack patch)\n\n\tPR c++/80913\n\t* name-lookup.c (add_decl_to_level): Assert not making a circular\n\tchain.\n\t(update_binding): Don't prematurely slide artificial decl.\n\n\t* g++.dg/lookup/pr80913.C: New.\n\nFrom-SVN: r248687", "tree": {"sha": "23ae8979361b358e48c6a0849e632d9293aa33ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23ae8979361b358e48c6a0849e632d9293aa33ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2f353338584c197e7d62370821fe48f76a52ce8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2f353338584c197e7d62370821fe48f76a52ce8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2f353338584c197e7d62370821fe48f76a52ce8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2f353338584c197e7d62370821fe48f76a52ce8/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "064263c11dcac67efa859c8b1896f0a18f5c38dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/064263c11dcac67efa859c8b1896f0a18f5c38dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/064263c11dcac67efa859c8b1896f0a18f5c38dc"}], "stats": {"total": 102, "additions": 64, "deletions": 38}, "files": [{"sha": "1aa5df8f65db4be017417446bd4908d6648f888b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2f353338584c197e7d62370821fe48f76a52ce8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2f353338584c197e7d62370821fe48f76a52ce8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e2f353338584c197e7d62370821fe48f76a52ce8", "patch": "@@ -1,3 +1,10 @@\n+2017-05-30  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/80913\n+\t* name-lookup.c (add_decl_to_level): Assert not making a circular\n+\tchain.\n+\t(update_binding): Don't prematurely slide artificial decl.\n+\n 2017-05-29  Alexandre Oliva <aoliva@redhat.com>\n \n \t* cp-tree.h (lang_identifier): Drop oracle_looked_up, unused."}, {"sha": "3a11d507698dd0b4939bc8ccfbf13188e031f848", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2f353338584c197e7d62370821fe48f76a52ce8/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2f353338584c197e7d62370821fe48f76a52ce8/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=e2f353338584c197e7d62370821fe48f76a52ce8", "patch": "@@ -132,6 +132,11 @@ add_decl_to_level (cp_binding_level *b, tree decl)\n     }\n   else\n     {\n+      /* Make sure we don't create a circular list.  xref_tag can end\n+\t up pushing the same artificial decl more than once.  We\n+\t should have already detected that in update_binding.  */\n+      gcc_assert (b->names != decl);\n+\n       /* We build up the list in reverse order, and reverse it later if\n \t necessary.  */\n       TREE_CHAIN (decl) = b->names;\n@@ -1720,17 +1725,43 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \t\ttree old, tree decl, bool is_friend)\n {\n   tree to_val = decl;\n-  tree to_type = NULL_TREE;\n+  tree old_type = slot ? MAYBE_STAT_TYPE (*slot) : binding->type;\n+  tree to_type = old_type;\n \n   gcc_assert (level->kind == sk_namespace ? !binding\n \t      : level->kind != sk_class && !slot);\n   if (old == error_mark_node)\n     old = NULL_TREE;\n \n+  if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl))\n+    {\n+      tree other = to_type;\n+\n+      if (old && TREE_CODE (old) == TYPE_DECL && DECL_ARTIFICIAL (old))\n+\tother = old;\n+\n+      /* Pushing an artificial typedef.  See if this matches either\n+\t the type slot or the old value slot.  */\n+      if (!other)\n+\t;\n+      else if (same_type_p (TREE_TYPE (other), TREE_TYPE (decl)))\n+\t/* Two artificial decls to same type.  Do nothing.  */\n+\treturn other;\n+      else\n+\tgoto conflict;\n+\n+      if (old)\n+\t{\n+\t  /* Slide decl into the type slot, keep old unaltered  */\n+\t  to_type = decl;\n+\t  to_val = old;\n+\t  goto done;\n+\t}\n+    }\n+\n   if (old && TREE_CODE (old) == TYPE_DECL && DECL_ARTIFICIAL (old))\n     {\n-      /* Slide the tdef out of the way.  We'll undo this below, if\n-\t we're pushing a matching tdef.  */\n+      /* Slide old into the type slot.  */\n       to_type = old;\n       old = NULL_TREE;\n     }\n@@ -1767,39 +1798,14 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \n       to_val = ovl_insert (decl, old);\n     }\n-  else if (to_type && TREE_CODE (decl) == TYPE_DECL)\n-    {\n-      /* We thought we wanted to slide an artificial typedef out of\n-\t the way, to make way for another typedef.  That's not always\n-\t what we want to do.  */\n-      if (!DECL_ARTIFICIAL (decl))\n-\t; /* Slide.  */\n-      else if (same_type_p (TREE_TYPE (to_type), TREE_TYPE (decl)))\n-\t/* Two artificial decls to same type.  Do nothing.  */\n-\treturn to_type;\n-      else\n-\tgoto conflict;\n-    }\n   else if (!old)\n     ;\n-  else if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl))\n-    {\n-      /* Slide DECL into the type slot.  */\n-      to_type = decl;\n-      to_val = old;\n-    }\n   else if (TREE_CODE (old) != TREE_CODE (decl))\n     /* Different kinds of decls conflict.  */\n     goto conflict;\n   else if (TREE_CODE (old) == TYPE_DECL)\n     {\n-      if (DECL_ARTIFICIAL (decl))\n-\t{\n-\t  /* Slide DECL into the type slot instead.  */\n-\t  to_type = decl;\n-\t  to_val = old;\n-\t}\n-      else if (same_type_p (TREE_TYPE (old), TREE_TYPE (decl)))\n+      if (same_type_p (TREE_TYPE (old), TREE_TYPE (decl)))\n \t/* Two type decls to the same type.  Do nothing.  */\n \treturn old;\n       else\n@@ -1835,6 +1841,7 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n       to_val = NULL_TREE;\n     }\n \n+ done:\n   if (to_val)\n     {\n       if (level->kind != sk_namespace\n@@ -1854,12 +1861,10 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \t  add_decl_to_level (level, to_add);\n \t}\n \n-      if (to_type == (slot ? MAYBE_STAT_TYPE (*slot) : binding->type))\n-\tto_type = NULL_TREE;\n-\n-      if (to_type)\n+      if (to_type != old_type)\n \t{\n-\t  gcc_checking_assert (TREE_CODE (to_type) == TYPE_DECL\n+\t  gcc_checking_assert (!old_type\n+\t\t\t       && TREE_CODE (to_type) == TYPE_DECL\n \t\t\t       && DECL_ARTIFICIAL (to_type));\n \n \t  tree type = TREE_TYPE (to_type);\n@@ -1875,8 +1880,7 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \t{\n \t  if (STAT_HACK_P (*slot))\n \t    {\n-\t      if (to_type)\n-\t\tSTAT_TYPE (*slot) = to_type;\n+\t      STAT_TYPE (*slot) = to_type;\n \t      STAT_DECL (*slot) = to_val;\n \t    }\n \t  else if (to_type)\n@@ -1886,8 +1890,7 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \t}\n       else\n \t{\n-\t  if (to_type)\n-\t    binding->type = to_type;\n+\t  binding->type = to_type;\n \t  binding->value = to_val;\n \t}\n     }"}, {"sha": "97b5493e068a5e38480013f8858af1278be31b32", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2f353338584c197e7d62370821fe48f76a52ce8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2f353338584c197e7d62370821fe48f76a52ce8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e2f353338584c197e7d62370821fe48f76a52ce8", "patch": "@@ -1,3 +1,8 @@\n+2017-05-30  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/80913\n+\t* g++.dg/lookup/pr80913.C: New.\n+\n 2017-05-30  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/80901"}, {"sha": "a7866bcc8a35004a03591888e26f5483517d9fa2", "filename": "gcc/testsuite/g++.dg/lookup/pr80913.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2f353338584c197e7d62370821fe48f76a52ce8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fpr80913.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2f353338584c197e7d62370821fe48f76a52ce8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fpr80913.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fpr80913.C?ref=e2f353338584c197e7d62370821fe48f76a52ce8", "patch": "@@ -0,0 +1,11 @@\n+// PR 80913 infinite look on spelling corrector caused by incorrectly\n+// chained decl\n+\n+extern int meminfo ();\n+struct meminfo {};\n+\n+void frob ()\n+{\n+  meminf (); // { dg-error \"not declared\" }\n+  // { dg-message \"suggested alternative\" \"\" { target *-*-* } .-1 }\n+}"}]}