{"sha": "c0134358c5a8a9a92b10d08f2c43f5876d9a0d07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAxMzQzNThjNWE4YTlhOTJiMTBkMDhmMmM0M2Y1ODc2ZDlhMGQwNw==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2018-05-16T18:02:25Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2018-05-16T18:02:25Z"}, "message": "DWARF: Emit DWARF5 forms for indirect addresses and string offsets.\n\nWe already emit DWARF5 attributes and tables for indirect addresses\nand string offsets, but still use GNU forms. Add a new helper function\ndwarf_FORM () for emitting the right form.\n\nCurrently we only use the uleb128 forms. But DWARF5 also allows\n1, 2, 3 and 4 byte forms (DW_FORM_strx[1234] and DW_FORM_addrx[1234])\nwhich might be more space efficient.\n\ngcc/ChangeLog\n\n\t* dwarf2out.c (dwarf_FORM): New function.\n\t(set_indirect_string): Use dwarf_FORM.\n\t(reset_indirect_string): Likewise.\n\t(size_of_die): Likewise.\n\t(value_format): Likewise.\n\t(output_die): Likewise.\n\t(add_skeleton_AT_string): Likewise.\n\t(output_macinfo_op): Likewise.\n\t(index_string): Likewise.\n\t(output_index_string_offset): Likewise.\n\t(output_index_string): Likewise.\n\nFrom-SVN: r260297", "tree": {"sha": "1a1021e1b9e198e408a7336b329da85bb3c0a850", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a1021e1b9e198e408a7336b329da85bb3c0a850"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0134358c5a8a9a92b10d08f2c43f5876d9a0d07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0134358c5a8a9a92b10d08f2c43f5876d9a0d07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0134358c5a8a9a92b10d08f2c43f5876d9a0d07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0134358c5a8a9a92b10d08f2c43f5876d9a0d07/comments", "author": null, "committer": null, "parents": [{"sha": "b958e1c134344ea06aa53ba0ca0935363ed3a8e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b958e1c134344ea06aa53ba0ca0935363ed3a8e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b958e1c134344ea06aa53ba0ca0935363ed3a8e8"}], "stats": {"total": 67, "additions": 52, "deletions": 15}, "files": [{"sha": "b63bfc09195caec66557d7cc3513e9172ca644e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0134358c5a8a9a92b10d08f2c43f5876d9a0d07/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0134358c5a8a9a92b10d08f2c43f5876d9a0d07/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0134358c5a8a9a92b10d08f2c43f5876d9a0d07", "patch": "@@ -1,3 +1,18 @@\n+2018-05-16  Mark Wielaard  <mark@klomp.org>\n+\n+\t* dwarf2out.c (dwarf_FORM): New function.\n+\t(set_indirect_string): Use dwarf_FORM.\n+\t(reset_indirect_string): Likewise.\n+\t(size_of_die): Likewise.\n+\t(value_format): Likewise.\n+\t(output_die): Likewise.\n+\t(add_skeleton_AT_string): Likewise.\n+\t(output_macinfo_op): Likewise.\n+\t(index_string): Likewise.\n+\t(output_index_string_offset): Likewise.\n+\t(output_index_string): Likewise.\n+\t(count_index_strings): Likewise.\n+\n 2018-05-16  Carl Love  <cel@us.ibm.com>\n \n \t* config/rs6000/rs6000.md (prefetch): Generate ISA 2.06 instructions"}, {"sha": "1b159303b7ab49d17820a890fbf9981d9066a62b", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0134358c5a8a9a92b10d08f2c43f5876d9a0d07/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0134358c5a8a9a92b10d08f2c43f5876d9a0d07/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=c0134358c5a8a9a92b10d08f2c43f5876d9a0d07", "patch": "@@ -246,7 +246,7 @@ static GTY (()) hash_table<indirect_string_hasher> *debug_line_str_hash;\n    That is, the comp_dir and dwo_name will appear in both places.\n \n    2) Strings can use four forms: DW_FORM_string, DW_FORM_strp,\n-   DW_FORM_line_strp or DW_FORM_GNU_str_index.\n+   DW_FORM_line_strp or DW_FORM_strx/GNU_str_index.\n \n    3) GCC chooses the form to use late, depending on the size and\n    reference count.\n@@ -1767,6 +1767,28 @@ dwarf_TAG (enum dwarf_tag tag)\n   return tag;\n }\n \n+/* And similarly for forms.  */\n+static inline enum dwarf_form\n+dwarf_FORM (enum dwarf_form form)\n+{\n+  switch (form)\n+    {\n+    case DW_FORM_addrx:\n+      if (dwarf_version < 5)\n+\treturn DW_FORM_GNU_addr_index;\n+      break;\n+\n+    case DW_FORM_strx:\n+      if (dwarf_version < 5)\n+\treturn DW_FORM_GNU_str_index;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return form;\n+}\n+\n static unsigned long int get_base_type_offset (dw_die_ref);\n \n /* Return the size of a location descriptor.  */\n@@ -4403,8 +4425,8 @@ AT_class (dw_attr_node *a)\n }\n \n /* Return the index for any attribute that will be referenced with a\n-   DW_FORM_GNU_addr_index or DW_FORM_GNU_str_index.  String indices\n-   are stored in dw_attr_val.v.val_str for reference counting\n+   DW_FORM_addrx/GNU_addr_index or DW_FORM_strx/GNU_str_index.  String\n+   indices are stored in dw_attr_val.v.val_str for reference counting\n    pruning.  */\n \n static inline unsigned int\n@@ -4668,7 +4690,7 @@ set_indirect_string (struct indirect_string_node *node)\n   /* Already indirect is a no op.  */\n   if (node->form == DW_FORM_strp\n       || node->form == DW_FORM_line_strp\n-      || node->form == DW_FORM_GNU_str_index)\n+      || node->form == dwarf_FORM (DW_FORM_strx))\n     {\n       gcc_assert (node->label);\n       return;\n@@ -4684,7 +4706,7 @@ set_indirect_string (struct indirect_string_node *node)\n     }\n   else\n     {\n-      node->form = DW_FORM_GNU_str_index;\n+      node->form = dwarf_FORM (DW_FORM_strx);\n       node->index = NO_INDEX_ASSIGNED;\n     }\n }\n@@ -4697,7 +4719,7 @@ int\n reset_indirect_string (indirect_string_node **h, void *)\n {\n   struct indirect_string_node *node = *h;\n-  if (node->form == DW_FORM_strp || node->form == DW_FORM_GNU_str_index)\n+  if (node->form == DW_FORM_strp || node->form == dwarf_FORM (DW_FORM_strx))\n     {\n       free (node->label);\n       node->label = NULL;\n@@ -9435,7 +9457,7 @@ size_of_die (dw_die_ref die)\n           form = AT_string_form (a);\n \t  if (form == DW_FORM_strp || form == DW_FORM_line_strp)\n \t    size += DWARF_OFFSET_SIZE;\n-\t  else if (form == DW_FORM_GNU_str_index)\n+\t  else if (form == dwarf_FORM (DW_FORM_strx))\n \t    size += size_of_uleb128 (AT_index (a));\n \t  else\n \t    size += strlen (a->dw_attr_val.v.val_str->str) + 1;\n@@ -9682,7 +9704,7 @@ value_format (dw_attr_node *a)\n \tcase DW_AT_entry_pc:\n \tcase DW_AT_trampoline:\n           return (AT_index (a) == NOT_INDEXED\n-                  ? DW_FORM_addr : DW_FORM_GNU_addr_index);\n+                  ? DW_FORM_addr : dwarf_FORM (DW_FORM_addrx));\n \tdefault:\n \t  break;\n \t}\n@@ -9855,7 +9877,7 @@ value_format (dw_attr_node *a)\n       return DW_FORM_data;\n     case dw_val_class_lbl_id:\n       return (AT_index (a) == NOT_INDEXED\n-              ? DW_FORM_addr : DW_FORM_GNU_addr_index);\n+              ? DW_FORM_addr : dwarf_FORM (DW_FORM_addrx));\n     case dw_val_class_lineptr:\n     case dw_val_class_macptr:\n     case dw_val_class_loclistsptr:\n@@ -10823,7 +10845,7 @@ output_die (dw_die_ref die)\n \t\t\t\t   a->dw_attr_val.v.val_str->label,\n \t\t\t\t   debug_line_str_section,\n \t\t\t\t   \"%s: \\\"%s\\\"\", name, AT_string (a));\n-          else if (a->dw_attr_val.v.val_str->form == DW_FORM_GNU_str_index)\n+          else if (a->dw_attr_val.v.val_str->form == dwarf_FORM (DW_FORM_strx))\n             dw2_asm_output_data_uleb128 (AT_index (a),\n                                          \"%s: \\\"%s\\\"\", name, AT_string (a));\n           else\n@@ -11104,7 +11126,7 @@ add_skeleton_AT_string (dw_die_ref die, enum dwarf_attribute attr_kind,\n \n   node = find_AT_string_in_table (str, skeleton_debug_str_hash);\n   find_string_form (node);\n-  if (node->form == DW_FORM_GNU_str_index)\n+  if (node->form == dwarf_FORM (DW_FORM_strx))\n     node->form = DW_FORM_strp;\n \n   attr.dw_attr = attr_kind;\n@@ -28070,7 +28092,7 @@ output_macinfo_op (macinfo_entry *ref)\n       node = find_AT_string (ref->info);\n       gcc_assert (node\n \t\t  && (node->form == DW_FORM_strp\n-\t\t      || node->form == DW_FORM_GNU_str_index));\n+\t\t      || node->form == dwarf_form (DW_FORM_strx)));\n       dw2_asm_output_data (1, ref->code,\n \t\t\t   ref->code == DW_MACRO_define_strp\n \t\t\t   ? \"Define macro strp\"\n@@ -28701,7 +28723,7 @@ index_string (indirect_string_node **h, unsigned int *index)\n   indirect_string_node *node = *h;\n \n   find_string_form (node);\n-  if (node->form == DW_FORM_GNU_str_index && node->refcount > 0)\n+  if (node->form == dwarf_FORM (DW_FORM_strx) && node->refcount > 0)\n     {\n       gcc_assert (node->index == NO_INDEX_ASSIGNED);\n       node->index = *index;\n@@ -28719,7 +28741,7 @@ output_index_string_offset (indirect_string_node **h, unsigned int *offset)\n {\n   indirect_string_node *node = *h;\n \n-  if (node->form == DW_FORM_GNU_str_index && node->refcount > 0)\n+  if (node->form == dwarf_FORM (DW_FORM_strx) && node->refcount > 0)\n     {\n       /* Assert that this node has been assigned an index.  */\n       gcc_assert (node->index != NO_INDEX_ASSIGNED\n@@ -28739,7 +28761,7 @@ output_index_string (indirect_string_node **h, unsigned int *cur_idx)\n {\n   struct indirect_string_node *node = *h;\n \n-  if (node->form == DW_FORM_GNU_str_index && node->refcount > 0)\n+  if (node->form == dwarf_FORM (DW_FORM_strx) && node->refcount > 0)\n     {\n       /* Assert that the strings are output in the same order as their\n          indexes were assigned.  */"}]}