{"sha": "4ac62786d6fb3b28c157fe9e6292842aa201d904", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFjNjI3ODZkNmZiM2IyOGMxNTdmZTllNjI5Mjg0MmFhMjAxZDkwNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-08T10:02:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-08T10:02:50Z"}, "message": "[multiple changes]\n\n2017-09-08  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch6.ads (Make_Build_In_Place_Iface_Call_In_Allocator): New\n\tsubprogram.\n\t(Make_Build_In_Place_Iface_Call_In_Anonymous_Context): New subprogram.\n\t(Make_Build_In_Place_Iface_Call_In_Object_Declaration): New\n\tsubprogram.\n\t(Unqual_BIP_Iface_Function_Call): New subprogram.\n\t* exp_ch6.adb (Replace_Renaming_Declaration_Id): New\n\tsubprogram containing code that was previously inside\n\tMake_Build_In_Place_Call_In_Object_Declaration since it is also\n\trequired for one of the new subprograms.\n\t(Expand_Actuals):\n\tInvoke Make_Build_In_Place_Iface_Call_In_Anonymous_Context\n\t(Expand_N_Extended_Return_Statement): Extend the\n\tcases covered by an assertion on expected BIP object\n\tdeclarations.\n\t(Make_Build_In_Place_Call_In_Assignment):\n\tRemoving unused code; found working on this ticket.\n\t(Make_Build_In_Place_Call_In_Object_Declaration): Move the code\n\tthat replaces the internal name of the renaming declaration\n\tinto the new subprogram Replace_Renaming_Declaration_Id.\n\t(Make_Build_In_Place_Iface_Call_In_Allocator): New subprogram.\n\t(Make_Build_In_Place_Iface_Call_In_Anonymous_Context):\n\tNew subprogram.\n\t(Make_Build_In_Place_Iface_Call_In_Object_Declaration): New\n\tsubprogram.\n\t(Unqual_BIP_Iface_Function_Call): New subprogram.\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Invoke the new\n\tsubprogram Make_Build_In_Place_Iface_Call_In_Object_Declaration.\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Invoke the new\n\tsubprogram Make_Build_In_Place_Iface_Call_In_Anonymous_Context.\n\t* exp_ch4.adb (Expand_Allocator_Expression): Invoke the new\n\tsubprogram Make_Build_In_Place_Iface_Call_In_Allocator.\n\t(Expand_N_Indexed_Component): Invoke the new subprogram\n\tMake_Build_In_Place_Iface_Call_In_Anonymous_Context.\n\t(Expand_N_Selected_Component): Invoke the new subprogram\n\tMake_Build_In_Place_Iface_Call_In_Anonymous_Context.\n\t(Expand_N_Slice): Invoke the new subprogram\n\tMake_Build_In_Place_Iface_Call_In_Anonymous_Context.\n\t* exp_ch8.adb (Expand_N_Object_Renaming_Declaration):\n\tInvoke the new subprogram\n\tMake_Build_In_Place_Iface_Call_In_Anonymous_Context.\n\n2017-09-08  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_disp.adb (Expand_Interface_Conversion): Fix handling of\n\taccess to interface types.  Remove also the accessibility check.\n\n2017-09-08  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_ch6.adb (Freeze_Expr_Types): Really freeze\n\tall the types that are referenced by the expression.\n\t(Analyze_Expression_Function): Call Freeze_Expr_Types for\n\ta completion instead of manually freezing the type of the\n\texpression.\n\t(Analyze_Subprogram_Body_Helper): Do not call Freeze_Expr_Types here.\n\n2017-09-08  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_prag.adb (Replace_Discriminals_Of_Protected_Op):\n\tNew procedure, auxiliary to Expand_Pragma_Check, to handle\n\treferences to the discriminants of a protected type within a\n\tprecondition of a protected operation. This is needed because\n\tthe original precondition has been analyzed in the context of\n\tthe protected declaration, but in the body of the operation\n\treferences to the discriminants have been replaved by references\n\tto the discriminants of the target object, and these references\n\tare only created when expanding the protected body.\n\nFrom-SVN: r251879", "tree": {"sha": "3733c12ce8f40475b1dec7fe8b2ea3b42b7eb4cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3733c12ce8f40475b1dec7fe8b2ea3b42b7eb4cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ac62786d6fb3b28c157fe9e6292842aa201d904", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ac62786d6fb3b28c157fe9e6292842aa201d904", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ac62786d6fb3b28c157fe9e6292842aa201d904", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ac62786d6fb3b28c157fe9e6292842aa201d904/comments", "author": null, "committer": null, "parents": [{"sha": "c468e1fba8516aa0029733406c00074c752f0aee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c468e1fba8516aa0029733406c00074c752f0aee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c468e1fba8516aa0029733406c00074c752f0aee"}], "stats": {"total": 1204, "additions": 870, "deletions": 334}, "files": [{"sha": "c3c48a535e8036cc69ae7f8dacf8917811ddc128", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4ac62786d6fb3b28c157fe9e6292842aa201d904", "patch": "@@ -1,3 +1,73 @@\n+2017-09-08  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch6.ads (Make_Build_In_Place_Iface_Call_In_Allocator): New\n+\tsubprogram.\n+\t(Make_Build_In_Place_Iface_Call_In_Anonymous_Context): New subprogram.\n+\t(Make_Build_In_Place_Iface_Call_In_Object_Declaration): New\n+\tsubprogram.\n+\t(Unqual_BIP_Iface_Function_Call): New subprogram.\n+\t* exp_ch6.adb (Replace_Renaming_Declaration_Id): New\n+\tsubprogram containing code that was previously inside\n+\tMake_Build_In_Place_Call_In_Object_Declaration since it is also\n+\trequired for one of the new subprograms.\n+\t(Expand_Actuals):\n+\tInvoke Make_Build_In_Place_Iface_Call_In_Anonymous_Context\n+\t(Expand_N_Extended_Return_Statement): Extend the\n+\tcases covered by an assertion on expected BIP object\n+\tdeclarations.\n+\t(Make_Build_In_Place_Call_In_Assignment):\n+\tRemoving unused code; found working on this ticket.\n+\t(Make_Build_In_Place_Call_In_Object_Declaration): Move the code\n+\tthat replaces the internal name of the renaming declaration\n+\tinto the new subprogram Replace_Renaming_Declaration_Id.\n+\t(Make_Build_In_Place_Iface_Call_In_Allocator): New subprogram.\n+\t(Make_Build_In_Place_Iface_Call_In_Anonymous_Context):\n+\tNew subprogram.\n+\t(Make_Build_In_Place_Iface_Call_In_Object_Declaration): New\n+\tsubprogram.\n+\t(Unqual_BIP_Iface_Function_Call): New subprogram.\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Invoke the new\n+\tsubprogram Make_Build_In_Place_Iface_Call_In_Object_Declaration.\n+\t* exp_attr.adb (Expand_N_Attribute_Reference): Invoke the new\n+\tsubprogram Make_Build_In_Place_Iface_Call_In_Anonymous_Context.\n+\t* exp_ch4.adb (Expand_Allocator_Expression): Invoke the new\n+\tsubprogram Make_Build_In_Place_Iface_Call_In_Allocator.\n+\t(Expand_N_Indexed_Component): Invoke the new subprogram\n+\tMake_Build_In_Place_Iface_Call_In_Anonymous_Context.\n+\t(Expand_N_Selected_Component): Invoke the new subprogram\n+\tMake_Build_In_Place_Iface_Call_In_Anonymous_Context.\n+\t(Expand_N_Slice): Invoke the new subprogram\n+\tMake_Build_In_Place_Iface_Call_In_Anonymous_Context.\n+\t* exp_ch8.adb (Expand_N_Object_Renaming_Declaration):\n+\tInvoke the new subprogram\n+\tMake_Build_In_Place_Iface_Call_In_Anonymous_Context.\n+\n+2017-09-08  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_disp.adb (Expand_Interface_Conversion): Fix handling of\n+\taccess to interface types.  Remove also the accessibility check.\n+\n+2017-09-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_ch6.adb (Freeze_Expr_Types): Really freeze\n+\tall the types that are referenced by the expression.\n+\t(Analyze_Expression_Function): Call Freeze_Expr_Types for\n+\ta completion instead of manually freezing the type of the\n+\texpression.\n+\t(Analyze_Subprogram_Body_Helper): Do not call Freeze_Expr_Types here.\n+\n+2017-09-08  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_prag.adb (Replace_Discriminals_Of_Protected_Op):\n+\tNew procedure, auxiliary to Expand_Pragma_Check, to handle\n+\treferences to the discriminants of a protected type within a\n+\tprecondition of a protected operation. This is needed because\n+\tthe original precondition has been analyzed in the context of\n+\tthe protected declaration, but in the body of the operation\n+\treferences to the discriminants have been replaved by references\n+\tto the discriminants of the target object, and these references\n+\tare only created when expanding the protected body.\n+\n 2017-09-08  Yannick Moy  <moy@adacore.com>\n \n \t* sem_prag.adb (Analyze_Pragma): Issue more precise error messages on"}, {"sha": "435f8167245ba8968f351653e9f2c5005cdbdb9d", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=4ac62786d6fb3b28c157fe9e6292842aa201d904", "patch": "@@ -9293,15 +9293,15 @@ package body Einfo is\n \n    function Underlying_Type (Id : E) return E is\n    begin\n-      --  For record_with_private the underlying type is always the direct\n-      --  full view. Never try to take the full view of the parent it\n-      --  doesn't make sense.\n+      --  For record_with_private the underlying type is always the direct full\n+      --  view. Never try to take the full view of the parent it does not make\n+      --  sense.\n \n       if Ekind (Id) = E_Record_Type_With_Private then\n          return Full_View (Id);\n \n-      --  If we have a class-wide type that comes from the limited view then\n-      --  we return the Underlying_Type of its nonlimited view.\n+      --  If we have a class-wide type that comes from the limited view then we\n+      --  return the Underlying_Type of its nonlimited view.\n \n       elsif Ekind (Id) = E_Class_Wide_Type\n         and then From_Limited_With (Id)\n@@ -9311,8 +9311,8 @@ package body Einfo is\n \n       elsif Ekind (Id) in Incomplete_Or_Private_Kind then\n \n-         --  If we have an incomplete or private type with a full view,\n-         --  then we return the Underlying_Type of this full view.\n+         --  If we have an incomplete or private type with a full view, then we\n+         --  return the Underlying_Type of this full view.\n \n          if Present (Full_View (Id)) then\n             if Id = Full_View (Id) then\n@@ -9347,10 +9347,9 @@ package body Einfo is\n          elsif Etype (Id) /= Id then\n             return Underlying_Type (Etype (Id));\n \n-         --  Otherwise we have an incomplete or private type that has\n-         --  no full view, which means that we have not encountered the\n-         --  completion, so return Empty to indicate the underlying type\n-         --  is not yet known.\n+         --  Otherwise we have an incomplete or private type that has no full\n+         --  view, which means that we have not encountered the completion, so\n+         --  return Empty to indicate the underlying type is not yet known.\n \n          else\n             return Empty;"}, {"sha": "bd354d555f0fee63906da7906b50db2c61db4ed6", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=4ac62786d6fb3b28c157fe9e6292842aa201d904", "patch": "@@ -1761,6 +1761,15 @@ package body Exp_Attr is\n         and then Is_Build_In_Place_Function_Call (Pref)\n       then\n          Make_Build_In_Place_Call_In_Anonymous_Context (Pref);\n+\n+      --  Ada 2005 (AI-318-02): Specialization of the previous case for prefix\n+      --  containing build-in-place function calls whose returned object covers\n+      --  interface types.\n+\n+      elsif Ada_Version >= Ada_2005\n+        and then Present (Unqual_BIP_Iface_Function_Call (Pref))\n+      then\n+         Make_Build_In_Place_Iface_Call_In_Anonymous_Context (Pref);\n       end if;\n \n       --  If prefix is a protected type name, this is a reference to the"}, {"sha": "b41754b1e545ce67d161e4af5010e3ed35727af1", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=4ac62786d6fb3b28c157fe9e6292842aa201d904", "patch": "@@ -6243,6 +6243,24 @@ package body Exp_Ch3 is\n \n             return;\n \n+         --  Ada 2005 (AI-318-02): Specialization of the previous case for\n+         --  expressions containing a build-in-place function call whose\n+         --  returned object covers interface types, and Expr_Q has calls to\n+         --  Ada.Tags.Displace to displace the pointer to the returned build-\n+         --  in-place object to reference the secondary dispatch table of a\n+         --  covered interface type.\n+\n+         elsif Ada_Version >= Ada_2005\n+           and then Present (Unqual_BIP_Iface_Function_Call (Expr_Q))\n+         then\n+            Make_Build_In_Place_Iface_Call_In_Object_Declaration (N, Expr_Q);\n+\n+            --  The previous call expands the expression initializing the\n+            --  built-in-place object into further code that will be analyzed\n+            --  later. No further expansion needed here.\n+\n+            return;\n+\n          --  Ada 2005 (AI-251): Rewrite the expression that initializes a\n          --  class-wide interface object to ensure that we copy the full\n          --  object, unless we are targetting a VM where interfaces are handled"}, {"sha": "91050fe6950edc2873340d4e7da4009d63e42c8a", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=4ac62786d6fb3b28c157fe9e6292842aa201d904", "patch": "@@ -804,6 +804,20 @@ package body Exp_Ch4 is\n             Make_Build_In_Place_Call_In_Allocator (N, Exp);\n             Apply_Accessibility_Check (N, Built_In_Place => True);\n             return;\n+\n+         --  Ada 2005 (AI-318-02): Specialization of the previous case for\n+         --  expressions containing a build-in-place function call whose\n+         --  returned object covers interface types, and Expr has calls to\n+         --  Ada.Tags.Displace to displace the pointer to the returned build-\n+         --  in-place object to reference the secondary dispatch table of a\n+         --  covered interface type.\n+\n+         elsif Ada_Version >= Ada_2005\n+           and then Present (Unqual_BIP_Iface_Function_Call (Exp))\n+         then\n+            Make_Build_In_Place_Iface_Call_In_Allocator (N, Exp);\n+            Apply_Accessibility_Check (N, Built_In_Place => True);\n+            return;\n          end if;\n \n          --  Actions inserted before:\n@@ -6562,6 +6576,15 @@ package body Exp_Ch4 is\n         and then Is_Build_In_Place_Function_Call (P)\n       then\n          Make_Build_In_Place_Call_In_Anonymous_Context (P);\n+\n+      --  Ada 2005 (AI-318-02): Specialization of the previous case for prefix\n+      --  containing build-in-place function calls whose returned object covers\n+      --  interface types.\n+\n+      elsif Ada_Version >= Ada_2005\n+        and then Present (Unqual_BIP_Iface_Function_Call (P))\n+      then\n+         Make_Build_In_Place_Iface_Call_In_Anonymous_Context (P);\n       end if;\n \n       --  If the prefix is an access type, then we unconditionally rewrite if\n@@ -10201,6 +10224,15 @@ package body Exp_Ch4 is\n         and then Is_Build_In_Place_Function_Call (P)\n       then\n          Make_Build_In_Place_Call_In_Anonymous_Context (P);\n+\n+      --  Ada 2005 (AI-318-02): Specialization of the previous case for prefix\n+      --  containing build-in-place function calls whose returned object covers\n+      --  interface types.\n+\n+      elsif Ada_Version >= Ada_2005\n+        and then Present (Unqual_BIP_Iface_Function_Call (P))\n+      then\n+         Make_Build_In_Place_Iface_Call_In_Anonymous_Context (P);\n       end if;\n \n       --  Gigi cannot handle unchecked conversions that are the prefix of a\n@@ -10558,6 +10590,15 @@ package body Exp_Ch4 is\n         and then Is_Build_In_Place_Function_Call (Pref)\n       then\n          Make_Build_In_Place_Call_In_Anonymous_Context (Pref);\n+\n+      --  Ada 2005 (AI-318-02): Specialization of the previous case for prefix\n+      --  containing build-in-place function calls whose returned object covers\n+      --  interface types.\n+\n+      elsif Ada_Version >= Ada_2005\n+        and then Present (Unqual_BIP_Iface_Function_Call (Pref))\n+      then\n+         Make_Build_In_Place_Iface_Call_In_Anonymous_Context (Pref);\n       end if;\n \n       --  The remaining case to be handled is packed slices. We can leave"}, {"sha": "c3d00659fee5405b9390fad9cf7738c952b1aa3f", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=4ac62786d6fb3b28c157fe9e6292842aa201d904", "patch": "@@ -4829,8 +4829,7 @@ package body Exp_Ch5 is\n                end if;\n \n             else\n-\n-               --  Initial value is smallest value in predicate.\n+               --  Initial value is smallest value in predicate\n \n                if Is_Itype (Ltype) then\n                   D :=\n@@ -4891,14 +4890,14 @@ package body Exp_Ch5 is\n                end if;\n \n                S :=\n-                  Make_Assignment_Statement (Loc,\n-                    Name       => New_Occurrence_Of (Loop_Id, Loc),\n-                    Expression =>\n-                      Make_Attribute_Reference (Loc,\n-                        Prefix => New_Occurrence_Of (Ltype, Loc),\n-                        Attribute_Name => Name_Next,\n-                        Expressions    => New_List (\n-                          New_Occurrence_Of (Loop_Id, Loc))));\n+                 Make_Assignment_Statement (Loc,\n+                   Name       => New_Occurrence_Of (Loop_Id, Loc),\n+                   Expression =>\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix         => New_Occurrence_Of (Ltype, Loc),\n+                       Attribute_Name => Name_Next,\n+                       Expressions    => New_List (\n+                         New_Occurrence_Of (Loop_Id, Loc))));\n                Set_Suppress_Assignment_Checks (S);\n             end;\n "}, {"sha": "a36e51f77857a8cb0399226aab2e59592c9a551e", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 347, "deletions": 61, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=4ac62786d6fb3b28c157fe9e6292842aa201d904", "patch": "@@ -30,6 +30,7 @@ with Debug;     use Debug;\n with Einfo;     use Einfo;\n with Errout;    use Errout;\n with Elists;    use Elists;\n+with Expander;  use Expander;\n with Exp_Aggr;  use Exp_Aggr;\n with Exp_Atag;  use Exp_Atag;\n with Exp_Ch2;   use Exp_Ch2;\n@@ -45,6 +46,7 @@ with Exp_Tss;   use Exp_Tss;\n with Exp_Util;  use Exp_Util;\n with Freeze;    use Freeze;\n with Inline;    use Inline;\n+with Itypes;    use Itypes;\n with Lib;       use Lib;\n with Namet;     use Namet;\n with Nlists;    use Nlists;\n@@ -245,6 +247,19 @@ package body Exp_Ch6 is\n    --  Insert the Post_Call list previously produced by routine Expand_Actuals\n    --  or Expand_Call_Helper into the tree.\n \n+   procedure Replace_Renaming_Declaration_Id\n+      (New_Decl  : Node_Id;\n+       Orig_Decl : Node_Id);\n+   --  Replace the internal identifier of the new renaming declaration New_Decl\n+   --  with the identifier of its original declaration Orig_Decl exchanging the\n+   --  entities containing their defining identifiers to ensure the correct\n+   --  replacement of the object declaration by the object renaming declaration\n+   --  to avoid homograph conflicts (since the object declaration's defining\n+   --  identifier was already entered in the current scope). The Next_Entity\n+   --  links of the two entities are also swapped since the entities are part\n+   --  of the return scope's entity list and the list structure would otherwise\n+   --  be corrupted. The homonym chain is preserved as well.\n+\n    procedure Rewrite_Function_Call_For_C (N : Node_Id);\n    --  When generating C code, replace a call to a function that returns an\n    --  array into the generated procedure with an additional out parameter.\n@@ -1878,6 +1893,13 @@ package body Exp_Ch6 is\n \n             if Is_Build_In_Place_Function_Call (Actual) then\n                Make_Build_In_Place_Call_In_Anonymous_Context (Actual);\n+\n+            --  Ada 2005 (AI-318-02): Specialization of the previous case for\n+            --  actuals containing build-in-place function calls whose returned\n+            --  object covers interface types.\n+\n+            elsif Present (Unqual_BIP_Iface_Function_Call (Actual)) then\n+               Make_Build_In_Place_Iface_Call_In_Anonymous_Context (Actual);\n             end if;\n \n             Apply_Constraint_Check (Actual, E_Formal);\n@@ -4793,8 +4815,19 @@ package body Exp_Ch6 is\n          then\n             pragma Assert\n               (Nkind (Original_Node (Ret_Obj_Decl)) = N_Object_Declaration\n-                and then Is_Build_In_Place_Function_Call\n-                           (Expression (Original_Node (Ret_Obj_Decl))));\n+                and then\n+\n+                  --  It is a regular BIP object declaration\n+\n+                  (Is_Build_In_Place_Function_Call\n+                     (Expression (Original_Node (Ret_Obj_Decl)))\n+\n+                  --  It is a BIP object declaration that displaces the pointer\n+                  --  to the object to reference a convered interface type.\n+\n+                  or else\n+                    Present (Unqual_BIP_Iface_Function_Call\n+                              (Expression (Original_Node (Ret_Obj_Decl))))));\n \n             --  Return the build-in-place result by reference\n \n@@ -7952,7 +7985,6 @@ package body Exp_Ch6 is\n       Ptr_Typ_Decl : Node_Id;\n       New_Expr     : Node_Id;\n       Result_Subt  : Entity_Id;\n-      Target       : Node_Id;\n \n    begin\n       --  If the call has already been processed to add build-in-place actuals\n@@ -8038,26 +8070,6 @@ package body Exp_Ch6 is\n       Insert_After_And_Analyze (Ptr_Typ_Decl, Obj_Decl);\n \n       Rewrite (Assign, Make_Null_Statement (Loc));\n-\n-      --  Retrieve the target of the assignment\n-\n-      if Nkind (Lhs) = N_Selected_Component then\n-         Target := Selector_Name (Lhs);\n-      elsif Nkind (Lhs) = N_Type_Conversion then\n-         Target := Expression (Lhs);\n-      else\n-         Target := Lhs;\n-      end if;\n-\n-      --  If we are assigning to a return object or this is an expression of\n-      --  an extension aggregate, the target should either be an identifier\n-      --  or a simple expression. All other cases imply a different scenario.\n-\n-      if Nkind (Target) in N_Has_Entity then\n-         Target := Entity (Target);\n-      else\n-         return;\n-      end if;\n    end Make_Build_In_Place_Call_In_Assignment;\n \n    ----------------------------------------------------\n@@ -8406,44 +8418,8 @@ package body Exp_Ch6 is\n             end if;\n \n             Analyze (Obj_Decl);\n-\n-            --  Replace the internal identifier of the renaming declaration's\n-            --  entity with identifier of the original object entity. We also\n-            --  have to exchange the entities containing their defining\n-            --  identifiers to ensure the correct replacement of the object\n-            --  declaration by the object renaming declaration to avoid\n-            --  homograph conflicts (since the object declaration's defining\n-            --  identifier was already entered in current scope). The\n-            --  Next_Entity links of the two entities also have to be swapped\n-            --  since the entities are part of the return scope's entity list\n-            --  and the list structure would otherwise be corrupted. Finally,\n-            --  the homonym chain must be preserved as well.\n-\n-            declare\n-               Ren_Id  : constant Entity_Id := Defining_Entity (Obj_Decl);\n-               Next_Id : constant Entity_Id := Next_Entity (Ren_Id);\n-\n-            begin\n-               Set_Chars (Ren_Id, Chars (Obj_Def_Id));\n-\n-               --  Swap next entity links in preparation for exchanging\n-               --  entities.\n-\n-               Set_Next_Entity (Ren_Id, Next_Entity (Obj_Def_Id));\n-               Set_Next_Entity (Obj_Def_Id, Next_Id);\n-               Set_Homonym     (Ren_Id, Homonym (Obj_Def_Id));\n-\n-               Exchange_Entities (Ren_Id, Obj_Def_Id);\n-\n-               --  Preserve source indication of original declaration, so that\n-               --  xref information is properly generated for the right entity.\n-\n-               Preserve_Comes_From_Source (Obj_Decl, Original_Node (Obj_Decl));\n-               Preserve_Comes_From_Source\n-                 (Obj_Def_Id, Original_Node (Obj_Decl));\n-\n-               Set_Comes_From_Source (Ren_Id, False);\n-            end;\n+            Replace_Renaming_Declaration_Id\n+              (Obj_Decl, Original_Node (Obj_Decl));\n          end if;\n       end;\n \n@@ -8460,6 +8436,185 @@ package body Exp_Ch6 is\n       end if;\n    end Make_Build_In_Place_Call_In_Object_Declaration;\n \n+   -------------------------------------------------\n+   -- Make_Build_In_Place_Iface_Call_In_Allocator --\n+   -------------------------------------------------\n+\n+   procedure Make_Build_In_Place_Iface_Call_In_Allocator\n+     (Allocator     : Node_Id;\n+      Function_Call : Node_Id)\n+   is\n+      BIP_Func_Call : constant Node_Id :=\n+                        Unqual_BIP_Iface_Function_Call (Function_Call);\n+      Loc           : constant Source_Ptr := Sloc (Function_Call);\n+\n+      Anon_Type : Entity_Id;\n+      Tmp_Decl  : Node_Id;\n+      Tmp_Id    : Entity_Id;\n+\n+   begin\n+      --  No action of the call has already been processed\n+\n+      if Is_Expanded_Build_In_Place_Call (BIP_Func_Call) then\n+         return;\n+      end if;\n+\n+      Tmp_Id := Make_Temporary (Loc, 'D');\n+\n+      --  Insert a temporary before N initialized with the BIP function call\n+      --  without its enclosing type conversions and analyze it without its\n+      --  expansion. This temporary facilitates us reusing the BIP machinery,\n+      --  which takes care of adding the extra build-in-place actuals and\n+      --  transforms this object declaration into an object renaming\n+      --  declaration.\n+\n+      Anon_Type := Create_Itype (E_Anonymous_Access_Type, Function_Call);\n+      Set_Directly_Designated_Type (Anon_Type, Etype (BIP_Func_Call));\n+      Set_Etype (Anon_Type, Anon_Type);\n+\n+      Tmp_Decl :=\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Tmp_Id,\n+          Object_Definition   => New_Occurrence_Of (Anon_Type, Loc),\n+          Expression          =>\n+            Make_Allocator (Loc,\n+              Expression =>\n+                Make_Qualified_Expression (Loc,\n+                  Subtype_Mark =>\n+                    New_Occurrence_Of (Etype (BIP_Func_Call), Loc),\n+                  Expression   => New_Copy_Tree (BIP_Func_Call))));\n+\n+      Expander_Mode_Save_And_Set (False);\n+      Insert_Action (Allocator, Tmp_Decl);\n+      Expander_Mode_Restore;\n+\n+      Make_Build_In_Place_Call_In_Allocator\n+        (Allocator     => Expression (Tmp_Decl),\n+         Function_Call => Expression (Expression (Tmp_Decl)));\n+\n+      Rewrite (Allocator, New_Occurrence_Of (Tmp_Id, Loc));\n+   end Make_Build_In_Place_Iface_Call_In_Allocator;\n+\n+   ---------------------------------------------------------\n+   -- Make_Build_In_Place_Iface_Call_In_Anonymous_Context --\n+   ---------------------------------------------------------\n+\n+   procedure Make_Build_In_Place_Iface_Call_In_Anonymous_Context\n+     (Function_Call : Node_Id)\n+   is\n+      BIP_Func_Call : constant Node_Id :=\n+                        Unqual_BIP_Iface_Function_Call (Function_Call);\n+      Loc           : constant Source_Ptr := Sloc (Function_Call);\n+\n+      Tmp_Decl : Node_Id;\n+      Tmp_Id   : Entity_Id;\n+\n+   begin\n+      --  No action of the call has already been processed\n+\n+      if Is_Expanded_Build_In_Place_Call (BIP_Func_Call) then\n+         return;\n+      end if;\n+\n+      pragma Assert (Needs_Finalization (Etype (BIP_Func_Call)));\n+\n+      --  Insert a temporary before the call initialized with function call to\n+      --  reuse the BIP machinery which takes care of adding the extra build-in\n+      --  place actuals and transforms this object declaration into an object\n+      --  renaming declaration.\n+\n+      Tmp_Id := Make_Temporary (Loc, 'D');\n+\n+      Tmp_Decl :=\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Tmp_Id,\n+          Object_Definition   =>\n+            New_Occurrence_Of (Etype (Function_Call), Loc),\n+          Expression          => Relocate_Node (Function_Call));\n+\n+      Expander_Mode_Save_And_Set (False);\n+      Insert_Action (Function_Call, Tmp_Decl);\n+      Expander_Mode_Restore;\n+\n+      Make_Build_In_Place_Iface_Call_In_Object_Declaration\n+        (Obj_Decl      => Tmp_Decl,\n+         Function_Call => Expression (Tmp_Decl));\n+   end Make_Build_In_Place_Iface_Call_In_Anonymous_Context;\n+\n+   ----------------------------------------------------------\n+   -- Make_Build_In_Place_Iface_Call_In_Object_Declaration --\n+   ----------------------------------------------------------\n+\n+   procedure Make_Build_In_Place_Iface_Call_In_Object_Declaration\n+     (Obj_Decl      : Node_Id;\n+      Function_Call : Node_Id)\n+   is\n+      BIP_Func_Call : constant Node_Id :=\n+                        Unqual_BIP_Iface_Function_Call (Function_Call);\n+      Loc           : constant Source_Ptr := Sloc (Function_Call);\n+      Obj_Id        : constant Entity_Id := Defining_Entity (Obj_Decl);\n+\n+      Tmp_Decl : Node_Id;\n+      Tmp_Id   : Entity_Id;\n+\n+   begin\n+      --  No action of the call has already been processed\n+\n+      if Is_Expanded_Build_In_Place_Call (BIP_Func_Call) then\n+         return;\n+      end if;\n+\n+      Tmp_Id := Make_Temporary (Loc, 'D');\n+\n+      --  Insert a temporary before N initialized with the BIP function call\n+      --  without its enclosing type conversions and analyze it without its\n+      --  expansion. This temporary facilitates us reusing the BIP machinery,\n+      --  which takes care of adding the extra build-in-place actuals and\n+      --  transforms this object declaration into an object renaming\n+      --  declaration.\n+\n+      Tmp_Decl :=\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Tmp_Id,\n+          Object_Definition   =>\n+            New_Occurrence_Of (Etype (BIP_Func_Call), Loc),\n+          Expression          => New_Copy_Tree (BIP_Func_Call));\n+\n+      Expander_Mode_Save_And_Set (False);\n+      Insert_Action (Obj_Decl, Tmp_Decl);\n+      Expander_Mode_Restore;\n+\n+      Make_Build_In_Place_Call_In_Object_Declaration\n+        (Obj_Decl      => Tmp_Decl,\n+         Function_Call => Expression (Tmp_Decl));\n+\n+      pragma Assert (Nkind (Tmp_Decl) = N_Object_Renaming_Declaration);\n+\n+      --  Replace the original build-in-place function call by a reference to\n+      --  the resulting temporary object renaming declaration. In this way,\n+      --  all the interface conversions performed in the original Function_Call\n+      --  on the build-in-place object are preserved.\n+\n+      Rewrite (BIP_Func_Call, New_Occurrence_Of (Tmp_Id, Loc));\n+\n+      --  Replace the original object declaration by an internal object\n+      --  renaming declaration. This leaves the generated code more clean (the\n+      --  build-in-place function call in an object renaming declaration and\n+      --  displacements of the pointer to the build-in-place object in another\n+      --  renaming declaration) and allows us to invoke the routine that takes\n+      --  care of replacing the identifier of the renaming declaration (routine\n+      --  originally developed for the regular build-in-place management).\n+\n+      Rewrite (Obj_Decl,\n+        Make_Object_Renaming_Declaration (Loc,\n+          Defining_Identifier => Make_Temporary (Loc, 'D'),\n+          Subtype_Mark        => New_Occurrence_Of (Etype (Obj_Id), Loc),\n+          Name                => Function_Call));\n+      Analyze (Obj_Decl);\n+\n+      Replace_Renaming_Declaration_Id (Obj_Decl, Original_Node (Obj_Decl));\n+   end Make_Build_In_Place_Iface_Call_In_Object_Declaration;\n+\n    --------------------------------------------\n    -- Make_CPP_Constructor_Call_In_Allocator --\n    --------------------------------------------\n@@ -8713,6 +8868,41 @@ package body Exp_Ch6 is\n       end if;\n    end Needs_Result_Accessibility_Level;\n \n+   -------------------------------------\n+   -- Replace_Renaming_Declaration_Id --\n+   -------------------------------------\n+\n+   procedure Replace_Renaming_Declaration_Id\n+      (New_Decl  : Node_Id;\n+       Orig_Decl : Node_Id)\n+   is\n+      New_Id  : constant Entity_Id := Defining_Entity (New_Decl);\n+      Orig_Id : constant Entity_Id := Defining_Entity (Orig_Decl);\n+\n+   begin\n+      Set_Chars (New_Id, Chars (Orig_Id));\n+\n+      --  Swap next entity links in preparation for exchanging entities\n+\n+      declare\n+         Next_Id : constant Entity_Id := Next_Entity (New_Id);\n+      begin\n+         Set_Next_Entity (New_Id, Next_Entity (Orig_Id));\n+         Set_Next_Entity (Orig_Id, Next_Id);\n+      end;\n+\n+      Set_Homonym (New_Id, Homonym (Orig_Id));\n+      Exchange_Entities (New_Id, Orig_Id);\n+\n+      --  Preserve source indication of original declaration, so that xref\n+      --  information is properly generated for the right entity.\n+\n+      Preserve_Comes_From_Source (New_Decl, Orig_Decl);\n+      Preserve_Comes_From_Source (Orig_Id, Orig_Decl);\n+\n+      Set_Comes_From_Source (New_Id, False);\n+   end Replace_Renaming_Declaration_Id;\n+\n    ---------------------------------\n    -- Rewrite_Function_Call_For_C --\n    ---------------------------------\n@@ -8866,4 +9056,100 @@ package body Exp_Ch6 is\n       end loop;\n    end Set_Enclosing_Sec_Stack_Return;\n \n+   ------------------------------------\n+   -- Unqual_BIP_Iface_Function_Call --\n+   ------------------------------------\n+\n+   function Unqual_BIP_Iface_Function_Call (Expr : Node_Id) return Node_Id is\n+      Has_Pointer_Displacement : Boolean := False;\n+      On_Object_Declaration    : Boolean := False;\n+      --  Remember if processing the renaming expressions on recursion we have\n+      --  traversed an object declaration, since we can traverse many object\n+      --  declaration renamings but just one regular object declaration.\n+\n+      function Unqual_BIP_Function_Call (Expr : Node_Id) return Node_Id;\n+      --  Search for a build-in-place function call skipping any qualification\n+      --  including qualified expressions, type conversions, references, calls\n+      --  to displace the pointer to the object, and renamings. Return Empty if\n+      --  no build-in-place function call is found.\n+\n+      ------------------------------\n+      -- Unqual_BIP_Function_Call --\n+      ------------------------------\n+\n+      function Unqual_BIP_Function_Call (Expr : Node_Id) return Node_Id is\n+      begin\n+         --  Recurse to handle case of multiple levels of qualification and/or\n+         --  conversion.\n+\n+         if Nkind_In (Expr, N_Qualified_Expression,\n+                            N_Type_Conversion,\n+                            N_Unchecked_Type_Conversion)\n+         then\n+            return Unqual_BIP_Function_Call (Expression (Expr));\n+\n+         --  Recurse to handle case of multiple levels of references and\n+         --  explicit dereferences.\n+\n+         elsif Nkind_In (Expr, N_Attribute_Reference,\n+                               N_Explicit_Dereference,\n+                               N_Reference)\n+         then\n+            return Unqual_BIP_Function_Call (Prefix (Expr));\n+\n+         --  Recurse on object renamings\n+\n+         elsif Nkind (Expr) = N_Identifier\n+           and then Ekind_In (Entity (Expr), E_Constant, E_Variable)\n+           and then Nkind (Parent (Entity (Expr))) =\n+                      N_Object_Renaming_Declaration\n+           and then Present (Renamed_Object (Entity (Expr)))\n+         then\n+            return Unqual_BIP_Function_Call (Renamed_Object (Entity (Expr)));\n+\n+         --  Recurse on the initializing expression of the first reference of\n+         --  an object declaration.\n+\n+         elsif not On_Object_Declaration\n+           and then Nkind (Expr) = N_Identifier\n+           and then Ekind_In (Entity (Expr), E_Constant, E_Variable)\n+           and then Nkind (Parent (Entity (Expr))) = N_Object_Declaration\n+           and then Present (Expression (Parent (Entity (Expr))))\n+         then\n+            On_Object_Declaration := True;\n+            return\n+               Unqual_BIP_Function_Call (Expression (Parent (Entity (Expr))));\n+\n+         --  Recurse to handle calls to displace the pointer to the object to\n+         --  reference a secondary dispatch table.\n+\n+         elsif Nkind (Expr) = N_Function_Call\n+           and then Nkind (Name (Expr)) in N_Has_Entity\n+           and then RTU_Loaded (Ada_Tags)\n+           and then RTE_Available (RE_Displace)\n+           and then Is_RTE (Entity (Name (Expr)), RE_Displace)\n+         then\n+            Has_Pointer_Displacement := True;\n+            return\n+              Unqual_BIP_Function_Call (First (Parameter_Associations (Expr)));\n+\n+         --  Normal case: check if the inner expression is a BIP function call\n+         --  and the pointer to the object is displaced.\n+\n+         elsif Has_Pointer_Displacement\n+           and then Is_Build_In_Place_Function_Call (Expr)\n+         then\n+            return Expr;\n+\n+         else\n+            return Empty;\n+         end if;\n+      end Unqual_BIP_Function_Call;\n+\n+   --  Start of processing for Unqual_BIP_Iface_Function_Call\n+\n+   begin\n+      return Unqual_BIP_Function_Call (Expr);\n+   end Unqual_BIP_Iface_Function_Call;\n+\n end Exp_Ch6;"}, {"sha": "c4fc3bc8588e722d2e9a8a0012af3819467208e8", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=4ac62786d6fb3b28c157fe9e6292842aa201d904", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -185,6 +185,40 @@ package Exp_Ch6 is\n    --  for which Is_Build_In_Place_Call is True, or an N_Qualified_Expression\n    --  node applied to such a function call.\n \n+   procedure Make_Build_In_Place_Iface_Call_In_Allocator\n+     (Allocator     : Node_Id;\n+      Function_Call : Node_Id);\n+   --  Ada 2005 (AI-318-02): Handle a call to a build-in-place function that\n+   --  occurs as the expression initializing an allocator, by passing access\n+   --  to the allocated object as an additional parameter of the function call.\n+   --  Function_Call must denote an expression containing a BIP function call\n+   --  and an enclosing call to Ada.Tags.Displace to displace the pointer to\n+   --  the returned BIP object to reference the secondary dispatch table of\n+   --  an interface.\n+\n+   procedure Make_Build_In_Place_Iface_Call_In_Anonymous_Context\n+     (Function_Call : Node_Id);\n+   --  Ada 2005 (AI-318-02): Handle a call to a build-in-place function that\n+   --  occurs in a context that does not provide a separate object. A temporary\n+   --  object is created to act as the return object and an access to the\n+   --  temporary is passed as an additional parameter of the call. This occurs\n+   --  in contexts such as subprogram call actuals and object renamings.\n+   --  Function_Call must denote an expression containing a BIP function call\n+   --  and an enclosing call to Ada.Tags.Displace to displace the pointer to\n+   --  the returned BIP object to reference the secondary dispatch table of\n+   --  an interface.\n+\n+   procedure Make_Build_In_Place_Iface_Call_In_Object_Declaration\n+     (Obj_Decl      : Node_Id;\n+      Function_Call : Node_Id);\n+   --  Ada 2005 (AI-318-02): Handle a call to a build-in-place function that\n+   --  occurs as the expression initializing an object declaration by passsing\n+   --  access to the declared object as an additional parameter of the function\n+   --  call. Function_Call must denote an expression containing a BIP function\n+   --  call and an enclosing call to Ada.Tags.Displace to displace the pointer\n+   --  to the returned BIP object to reference the secondary dispatch table of\n+   --  an interface.\n+\n    procedure Make_CPP_Constructor_Call_In_Allocator\n      (Allocator     : Node_Id;\n       Function_Call : Node_Id);\n@@ -211,4 +245,12 @@ package Exp_Ch6 is\n    --  parameter to identify the accessibility level of the function result\n    --  \"determined by the point of call\".\n \n+   function Unqual_BIP_Iface_Function_Call (Expr : Node_Id) return Node_Id;\n+   --  Return the inner BIP function call removing any qualification from Expr\n+   --  including qualified expressions, type conversions, references, unchecked\n+   --  conversions and calls to displace the pointer to the object, if Expr is\n+   --  an expression containing a call displacing the pointer to the BIP object\n+   --  to reference the secondary dispatch table of an interface; otherwise\n+   --  return Empty.\n+\n end Exp_Ch6;"}, {"sha": "ba0f7c291c1fa6bfdce11ce5538904589fcb1bdb", "filename": "gcc/ada/exp_ch8.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch8.adb?ref=4ac62786d6fb3b28c157fe9e6292842aa201d904", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -185,6 +185,15 @@ package body Exp_Ch8 is\n         and then Is_Build_In_Place_Function_Call (Nam)\n       then\n          Make_Build_In_Place_Call_In_Anonymous_Context (Nam);\n+\n+      --  Ada 2005 (AI-318-02): Specialization of previous case for renaming\n+      --  containing build-in-place function calls whose returned object covers\n+      --  interface types.\n+\n+      elsif Ada_Version >= Ada_2005\n+        and then Present (Unqual_BIP_Iface_Function_Call (Nam))\n+      then\n+         Make_Build_In_Place_Iface_Call_In_Anonymous_Context (Nam);\n       end if;\n \n       --  Create renaming entry for debug information. Mark the entity as"}, {"sha": "d6d806941b59d7d93afa91b1121e9b9afefca207", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=4ac62786d6fb3b28c157fe9e6292842aa201d904", "patch": "@@ -1214,10 +1214,10 @@ package body Exp_Disp is\n          E : Entity_Id := Typ;\n \n       begin\n-         --  Handle access to class-wide interface types\n+         --  Handle access types\n \n          if Is_Access_Type (E) then\n-            E := Etype (Directly_Designated_Type (E));\n+            E := Directly_Designated_Type (E);\n          end if;\n \n          --  Handle class-wide types. This conversion can appear explicitly in\n@@ -1522,11 +1522,6 @@ package body Exp_Disp is\n \n             if Is_Access_Type (Etype (Expression (N))) then\n \n-               Apply_Accessibility_Check\n-                 (N           => Expression (N),\n-                  Typ         => Etype (N),\n-                  Insert_Node => N);\n-\n                --  Generate: Func (Address!(Expression))\n \n                Rewrite (N,"}, {"sha": "c60f75a71f9b36d09c2de2cf2d69c8af2578c89b", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=4ac62786d6fb3b28c157fe9e6292842aa201d904", "patch": "@@ -320,6 +320,84 @@ package body Exp_Prag is\n       --  Assert_Failure, so that coverage analysis tools can relate the\n       --  call to the failed check.\n \n+      procedure Replace_Discriminals_Of_Protected_Op (Expr : Node_Id);\n+      --  Discriminants of the enclosing protected object may be referenced\n+      --  in the expression of a precondition of a protected operation.\n+      --  In the body of the operation these references must be replaced by\n+      --  the discriminal created for them, which area renamings of the\n+      --  discriminants of the object that is the target of the operation.\n+      --  This replacement is done by visibility when the references appear\n+      --  in the subprogram body, but in the case of a condition which appears\n+      --  on the specification of the subprogram it has be done separately\n+      --  because the condition has been replaced by a Check pragma and\n+      --  analyzed earlier, before the creation of the discriminal renaming\n+      --  declarations that are added to the subprogram body.\n+\n+      ------------------------------------------\n+      -- Replace_Discriminals_Of_Protected_Op --\n+      ------------------------------------------\n+\n+      procedure Replace_Discriminals_Of_Protected_Op (Expr : Node_Id) is\n+         function Find_Corresponding_Discriminal (E : Entity_Id)\n+           return Entity_Id;\n+         --  Find the local entity that renames a discriminant of the\n+         --  enclosing protected type, and has a matching name.\n+\n+         ------------------------------------\n+         -- find_Corresponding_Discriminal --\n+         ------------------------------------\n+\n+         function Find_Corresponding_Discriminal (E : Entity_Id)\n+           return Entity_Id\n+         is\n+            R : Entity_Id;\n+\n+         begin\n+            R := First_Entity (Current_Scope);\n+\n+            while Present (R) loop\n+               if Nkind (Parent (R)) = N_Object_Renaming_Declaration\n+                 and then Present (Discriminal_Link (R))\n+                 and then Chars (Discriminal_Link (R)) = Chars (E)\n+               then\n+                  return R;\n+               end if;\n+\n+               Next_Entity (R);\n+            end loop;\n+\n+            return Empty;\n+         end Find_Corresponding_Discriminal;\n+\n+         function  Replace_Discr_Ref (N : Node_Id) return Traverse_Result;\n+         --  Replace a reference to a discriminant of the original protected\n+         --  type by the local renaming declaration of the discriminant of\n+         --  the target object.\n+\n+         -----------------------\n+         -- Replace_Discr_Ref --\n+         -----------------------\n+\n+         function  Replace_Discr_Ref (N : Node_Id) return Traverse_Result is\n+            R : Entity_Id;\n+\n+         begin\n+            if Is_Entity_Name (N)\n+               and then Present (Discriminal_Link (Entity (N)))\n+            then\n+               R := Find_Corresponding_Discriminal (Entity (N));\n+               Rewrite (N, New_Occurrence_Of (R, Sloc (N)));\n+            end if;\n+            return OK;\n+         end Replace_Discr_Ref;\n+\n+         procedure Replace_Discriminant_References is\n+           new Traverse_Proc (Replace_Discr_Ref);\n+\n+      begin\n+         Replace_Discriminant_References (Expr);\n+      end Replace_Discriminals_Of_Protected_Op;\n+\n    begin\n       --  Nothing to do if pragma is ignored\n \n@@ -456,6 +534,16 @@ package body Exp_Prag is\n             end;\n          end if;\n \n+         --  For a precondition, replace references to discriminants of a\n+         --  protected type with the local discriminals.\n+\n+         if Is_Protected_Type (Scope (Current_Scope))\n+           and then Has_Discriminants (Scope (Current_Scope))\n+           and then From_Aspect_Specification (N)\n+         then\n+            Replace_Discriminals_Of_Protected_Op (Cond);\n+         end if;\n+\n          --  Now rewrite as an if statement\n \n          Rewrite (N,"}, {"sha": "05e075917ab6519ebcda376323b75eeb2ede7d61", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=4ac62786d6fb3b28c157fe9e6292842aa201d904", "patch": "@@ -3406,14 +3406,15 @@ package body Exp_Util is\n       if Present (Priv_Typ) then\n          Typ_Decl := Declaration_Node (Priv_Typ);\n \n-      --  Derived types with the full view as parent do not have a partial\n-      --  view. Insert the invariant procedure after the derived type.\n       --  Anonymous arrays in object declarations have no explicit declaration\n       --  so use the related object declaration as the insertion point.\n \n       elsif Is_Itype (Work_Typ) and then Is_Array_Type (Work_Typ)  then\n          Typ_Decl := Associated_Node_For_Itype (Work_Typ);\n \n+      --  Derived types with the full view as parent do not have a partial\n+      --  view. Insert the invariant procedure after the derived type.\n+\n       else\n          Typ_Decl := Declaration_Node (Full_Typ);\n       end if;"}, {"sha": "aa99201ec9f822f14568282776e695d4205417a2", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=4ac62786d6fb3b28c157fe9e6292842aa201d904", "patch": "@@ -1179,29 +1179,29 @@ package body Inline is\n       --  types.\n \n       function Has_Some_Contract (Id : Entity_Id) return Boolean;\n-      --  Returns True if subprogram Id has any contract (Pre, Post,\n-      --  Global, Depends, etc.) The presence of Extensions_Visible\n-      --  or Volatile_Function is also considered as a contract here.\n+      --  Return True if subprogram Id has any contract. The presence of\n+      --  Extensions_Visible or Volatile_Function is also considered as a\n+      --  contract here.\n \n       function Is_Unit_Subprogram (Id : Entity_Id) return Boolean;\n-      --  Returns True if subprogram Id defines a compilation unit\n+      --  Return True if subprogram Id defines a compilation unit\n       --  Shouldn't this be in Sem_Aux???\n \n       function In_Package_Spec (Id : Node_Id) return Boolean;\n-      --  Returns True if subprogram Id is defined in the package\n-      --  specification, either its visible or private part.\n+      --  Return True if subprogram Id is defined in the package specification,\n+      --  either its visible or private part.\n \n       ---------------------------------------------------\n       -- Has_Formal_With_Discriminant_Dependent_Fields --\n       ---------------------------------------------------\n \n       function Has_Formal_With_Discriminant_Dependent_Fields\n-        (Id : Entity_Id) return Boolean is\n-\n+        (Id : Entity_Id) return Boolean\n+      is\n          function Has_Discriminant_Dependent_Component\n            (Typ : Entity_Id) return Boolean;\n-         --  Determine whether unconstrained record type Typ has at least\n-         --  one component that depends on a discriminant.\n+         --  Determine whether unconstrained record type Typ has at least one\n+         --  component that depends on a discriminant.\n \n          ------------------------------------------\n          -- Has_Discriminant_Dependent_Component --\n@@ -1213,8 +1213,8 @@ package body Inline is\n             Comp : Entity_Id;\n \n          begin\n-            --  Inspect all components of the record type looking for one\n-            --  that depends on a discriminant.\n+            --  Inspect all components of the record type looking for one that\n+            --  depends on a discriminant.\n \n             Comp := First_Component (Typ);\n             while Present (Comp) loop"}, {"sha": "4f7016d2690b73f174a11d605d98be2cc778641c", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=4ac62786d6fb3b28c157fe9e6292842aa201d904", "patch": "@@ -6284,7 +6284,6 @@ package body Sem_Ch4 is\n \n       procedure Try_One_Interp (T1 : Entity_Id) is\n       begin\n-\n          --  If the operator is an expanded name, then the type of the operand\n          --  must be defined in the corresponding scope. If the type is\n          --  universal, the context will impose the correct type. Note that we\n@@ -6480,8 +6479,8 @@ package body Sem_Ch4 is\n             --  Note that we avoid returning if we are currently within a\n             --  generic instance due to the fact that the generic package\n             --  declaration has already been successfully analyzed and\n-            --  Defined_In_Scope expects the base type to be defined within the\n-            --  instance which will never be the case.\n+            --  Defined_In_Scope expects the base type to be defined within\n+            --  the instance which will never be the case.\n \n             if Defined_In_Scope (T1, Scop)\n               or else In_Instance"}, {"sha": "54b02e4fa6c27f1116952e3d3c0e18574d44a17f", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 205, "deletions": 225, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=4ac62786d6fb3b28c157fe9e6292842aa201d904", "patch": "@@ -267,18 +267,214 @@ package body Sem_Ch6 is\n       LocX : constant Source_Ptr := Sloc (Expr);\n       Spec : constant Node_Id    := Specification (N);\n \n+      procedure Freeze_Expr_Types (Spec_Id : Entity_Id);\n+      --  N is an expression function that is a completion and Spec_Id its\n+      --  defining entity. Freeze before N all the types referenced by the\n+      --  expression of the function.\n+\n+      -----------------------\n+      -- Freeze_Expr_Types --\n+      -----------------------\n+\n+      procedure Freeze_Expr_Types (Spec_Id : Entity_Id) is\n+         function Cloned_Expression return Node_Id;\n+         --  Build a duplicate of the expression of the return statement that\n+         --  has no defining entities shared with the original expression.\n+\n+         function Freeze_Type_Refs (Node : Node_Id) return Traverse_Result;\n+         --  Freeze all types referenced in the subtree rooted at Node\n+\n+         -----------------------\n+         -- Cloned_Expression --\n+         -----------------------\n+\n+         function Cloned_Expression return Node_Id is\n+            function Clone_Id (Node : Node_Id) return Traverse_Result;\n+            --  Tree traversal routine that clones the defining identifier of\n+            --  iterator and loop parameter specification nodes.\n+\n+            ----------------\n+            -- Check_Node --\n+            ----------------\n+\n+            function Clone_Id (Node : Node_Id) return Traverse_Result is\n+            begin\n+               if Nkind_In (Node, N_Iterator_Specification,\n+                                  N_Loop_Parameter_Specification)\n+               then\n+                  Set_Defining_Identifier (Node,\n+                    New_Copy (Defining_Identifier (Node)));\n+               end if;\n+\n+               return OK;\n+            end Clone_Id;\n+\n+            procedure Clone_Def_Ids is new Traverse_Proc (Clone_Id);\n+\n+            --  Local variable\n+\n+            Dup_Expr : constant Node_Id := New_Copy_Tree (Expr);\n+\n+         --  Start of processing for Cloned_Expression\n+\n+         begin\n+            --  We must duplicate the expression with semantic information to\n+            --  inherit the decoration of global entities in generic instances.\n+            --  Set the parent of the new node to be the parent of the original\n+            --  to get the proper context, which is needed for complete error\n+            --  reporting and for semantic analysis.\n+\n+            Set_Parent (Dup_Expr, Parent (Expr));\n+\n+            --  Replace the defining identifier of iterators and loop param\n+            --  specifications by a clone to ensure that the cloned expression\n+            --  and the original expression don't have shared identifiers;\n+            --  otherwise, as part of the preanalysis of the expression, these\n+            --  shared identifiers may be left decorated with itypes which\n+            --  will not be available in the tree passed to the backend.\n+\n+            Clone_Def_Ids (Dup_Expr);\n+\n+            return Dup_Expr;\n+         end Cloned_Expression;\n+\n+         ----------------------\n+         -- Freeze_Type_Refs --\n+         ----------------------\n+\n+         function Freeze_Type_Refs (Node : Node_Id) return Traverse_Result is\n+\n+            procedure Check_And_Freeze_Type (Typ : Entity_Id);\n+            --  Check that Typ is fully declared and freeze it if so\n+\n+            ---------------------------\n+            -- Check_And_Freeze_Type --\n+            ---------------------------\n+\n+            procedure Check_And_Freeze_Type (Typ : Entity_Id) is\n+            begin\n+               --  Skip Itypes created by the preanalysis\n+\n+               if Is_Itype (Typ)\n+                 and then Scope_Within_Or_Same (Scope (Typ), Spec_Id)\n+               then\n+                  return;\n+               end if;\n+\n+               --  This provides a better error message than generating\n+               --  primitives whose compilation fails much later. Refine\n+               --  the error message if possible.\n+\n+               Check_Fully_Declared (Typ, Node);\n+\n+               if Error_Posted (Node) then\n+                  if Has_Private_Component (Typ)\n+                    and then not Is_Private_Type (Typ)\n+                  then\n+                     Error_Msg_NE\n+                       (\"\\type& has private component\", Node, Typ);\n+                  end if;\n+\n+               else\n+                  Freeze_Before (N, Typ);\n+               end if;\n+            end Check_And_Freeze_Type;\n+\n+         --  Start of processing for Freeze_Type_Refs\n+\n+         begin\n+            --  Check that a type referenced by an entity can be frozen\n+\n+            if Is_Entity_Name (Node) and then Present (Entity (Node)) then\n+               Check_And_Freeze_Type (Etype (Entity (Node)));\n+\n+               --  Check that the enclosing record type can be frozen\n+\n+               if Ekind_In (Entity (Node), E_Component, E_Discriminant) then\n+                  Check_And_Freeze_Type (Scope (Entity (Node)));\n+               end if;\n+\n+            --  Freezing an access type does not freeze the designated type,\n+            --  but freezing conversions between access to interfaces requires\n+            --  that the interface types themselves be frozen, so that dispatch\n+            --  table entities are properly created.\n+\n+            --  Unclear whether a more general rule is needed ???\n+\n+            elsif Nkind (Node) = N_Type_Conversion\n+              and then Is_Access_Type (Etype (Node))\n+              and then Is_Interface (Designated_Type (Etype (Node)))\n+            then\n+               Check_And_Freeze_Type (Designated_Type (Etype (Node)));\n+            end if;\n+\n+            --  No point in posting several errors on the same expression\n+\n+            if Serious_Errors_Detected > 0 then\n+               return Abandon;\n+            else\n+               return OK;\n+            end if;\n+         end Freeze_Type_Refs;\n+\n+         procedure Freeze_References is new Traverse_Proc (Freeze_Type_Refs);\n+\n+         --  Local variables\n+\n+         Saved_First_Entity : constant Entity_Id := First_Entity (Spec_Id);\n+         Saved_Last_Entity  : constant Entity_Id := Last_Entity  (Spec_Id);\n+         Dup_Expr           : constant Node_Id   := Cloned_Expression;\n+\n+      --  Start of processing for Freeze_Expr_Types\n+\n+      begin\n+         --  Preanalyze a duplicate of the expression to have available the\n+         --  minimum decoration needed to locate referenced unfrozen types\n+         --  without adding any decoration to the function expression. This\n+         --  preanalysis is performed with errors disabled to avoid reporting\n+         --  spurious errors on Ghost entities (since the expression is not\n+         --  fully analyzed).\n+\n+         Push_Scope (Spec_Id);\n+         Install_Formals (Spec_Id);\n+         Ignore_Errors_Enable := Ignore_Errors_Enable + 1;\n+\n+         Preanalyze_Spec_Expression (Dup_Expr, Etype (Spec_Id));\n+\n+         Ignore_Errors_Enable := Ignore_Errors_Enable - 1;\n+         End_Scope;\n+\n+         --  Restore certain attributes of Spec_Id since the preanalysis may\n+         --  have introduced itypes to this scope, thus modifying attributes\n+         --  First_Entity and Last_Entity.\n+\n+         Set_First_Entity (Spec_Id, Saved_First_Entity);\n+         Set_Last_Entity  (Spec_Id, Saved_Last_Entity);\n+\n+         if Present (Last_Entity (Spec_Id)) then\n+            Set_Next_Entity (Last_Entity (Spec_Id), Empty);\n+         end if;\n+\n+         --  Freeze all types referenced in the expression\n+\n+         Freeze_References (Dup_Expr);\n+      end Freeze_Expr_Types;\n+\n+      --  Local variables\n+\n       Asp      : Node_Id;\n-      Def_Id   : Entity_Id;\n       New_Body : Node_Id;\n       New_Spec : Node_Id;\n       Orig_N   : Node_Id;\n       Ret      : Node_Id;\n-      Ret_Type : Entity_Id;\n \n-      Prev : Entity_Id;\n+      Def_Id   : Entity_Id;\n+      Prev     : Entity_Id;\n       --  If the expression is a completion, Prev is the entity whose\n       --  declaration is completed. Def_Id is needed to analyze the spec.\n \n+   --  Start of processing for Analyze_Expression_Function\n+\n    begin\n       --  This is one of the occasions on which we transform the tree during\n       --  semantic analysis. If this is a completion, transform the expression\n@@ -319,7 +515,7 @@ package body Sem_Ch6 is\n          end if;\n       end if;\n \n-      Ret := Make_Simple_Return_Statement (LocX, Expression (N));\n+      Ret := Make_Simple_Return_Statement (LocX, Expr);\n \n       New_Body :=\n         Make_Subprogram_Body (Loc,\n@@ -361,47 +557,21 @@ package body Sem_Ch6 is\n       --  to be inlined.\n \n       elsif Present (Prev)\n-        and then Comes_From_Source (Parent (Prev))\n+        and then Is_Overloadable (Prev)\n         and then not Is_Formal_Subprogram (Prev)\n+        and then Comes_From_Source (Parent (Prev))\n       then\n          Set_Has_Completion (Prev, False);\n          Set_Is_Inlined (Prev);\n-         Ret_Type := Etype (Prev);\n \n-         --  An expression function which acts as a completion freezes the\n-         --  expression. This means freezing the return type, and if it is\n-         --  an access type, freezing its designated type as well.\n+         --  AI12-0103: Expression functions that are a completion freeze their\n+         --  expression but don't freeze anything else (unlike regular bodies).\n \n          --  Note that we cannot defer this freezing to the analysis of the\n          --  expression itself, because a freeze node might appear in a nested\n          --  scope, leading to an elaboration order issue in gigi.\n \n-         Freeze_Before (N, Ret_Type);\n-\n-         --  An entity can only be frozen if it is complete, so if the type\n-         --  is still unfrozen it must still be incomplete in some way, e.g.\n-         --  a private type without a full view, or a type derived from such\n-         --  in an enclosing scope. Except in a generic context (where the\n-         --  type may be a generic formal or derived from such), such use of\n-         --  an incomplete type is an error. On the other hand, if this is a\n-         --  limited view of a type, the type is declared in another unit and\n-         --  frozen there. We must be in a context seeing the nonlimited view\n-         --  of the type, which will be installed when the body is compiled.\n-\n-         if not Is_Frozen (Ret_Type)\n-           and then not Is_Generic_Type (Root_Type (Ret_Type))\n-           and then not Inside_A_Generic\n-         then\n-            if From_Limited_With (Ret_Type)\n-              and then Present (Non_Limited_View (Ret_Type))\n-            then\n-               null;\n-            else\n-               Error_Msg_NE\n-                 (\"premature use of private type&\",\n-                  Result_Definition (Specification (N)), Ret_Type);\n-            end if;\n-         end if;\n+         Freeze_Expr_Types (Def_Id);\n \n          --  For navigation purposes, indicate that the function is a body\n \n@@ -2273,11 +2443,6 @@ package body Sem_Ch6 is\n       --  limited views with the non-limited ones. Return the list of changes\n       --  to be used to undo the transformation.\n \n-      procedure Freeze_Expr_Types (Spec_Id : Entity_Id);\n-      --  AI12-0103: N is the body associated with an expression function that\n-      --  is a completion, and Spec_Id is its defining entity. Freeze before N\n-      --  all the types referenced by the expression of the function.\n-\n       function Is_Private_Concurrent_Primitive\n         (Subp_Id : Entity_Id) return Boolean;\n       --  Determine whether subprogram Subp_Id is a primitive of a concurrent\n@@ -3003,180 +3168,6 @@ package body Sem_Ch6 is\n          return Result;\n       end Exchange_Limited_Views;\n \n-      -----------------------\n-      -- Freeze_Expr_Types --\n-      -----------------------\n-\n-      procedure Freeze_Expr_Types (Spec_Id : Entity_Id) is\n-         function Cloned_Expression return Node_Id;\n-         --  Build a duplicate of the expression of the return statement that\n-         --  has no defining entities shared with the original expression.\n-\n-         function Freeze_Type_Refs (Node : Node_Id) return Traverse_Result;\n-         --  Freeze all types referenced in the subtree rooted at Node\n-\n-         -----------------------\n-         -- Cloned_Expression --\n-         -----------------------\n-\n-         function Cloned_Expression return Node_Id is\n-            function Clone_Id (Node : Node_Id) return Traverse_Result;\n-            --  Tree traversal routine that clones the defining identifier of\n-            --  iterator and loop parameter specification nodes.\n-\n-            ----------------\n-            -- Check_Node --\n-            ----------------\n-\n-            function Clone_Id (Node : Node_Id) return Traverse_Result is\n-            begin\n-               if Nkind_In (Node, N_Iterator_Specification,\n-                                  N_Loop_Parameter_Specification)\n-               then\n-                  Set_Defining_Identifier (Node,\n-                    New_Copy (Defining_Identifier (Node)));\n-               end if;\n-\n-               return OK;\n-            end Clone_Id;\n-\n-            -------------------\n-            -- Clone_Def_Ids --\n-            -------------------\n-\n-            procedure Clone_Def_Ids is new Traverse_Proc (Clone_Id);\n-\n-            --  Local variables\n-\n-            Return_Stmt : constant Node_Id :=\n-                            First\n-                              (Statements (Handled_Statement_Sequence (N)));\n-            Dup_Expr    : Node_Id;\n-\n-         --  Start of processing for Cloned_Expression\n-\n-         begin\n-            pragma Assert (Nkind (Return_Stmt) = N_Simple_Return_Statement);\n-\n-            --  We must duplicate the expression with semantic information to\n-            --  inherit the decoration of global entities in generic instances.\n-            --  Set the parent of the new node to be the parent of the original\n-            --  to get the proper context, which is needed for complete error\n-            --  reporting and for semantic analysis.\n-\n-            Dup_Expr := New_Copy_Tree (Expression (Return_Stmt));\n-            Set_Parent (Dup_Expr, Return_Stmt);\n-\n-            --  Replace the defining identifier of iterators and loop param\n-            --  specifications by a clone to ensure that the cloned expression\n-            --  and the original expression don't have shared identifiers;\n-            --  otherwise, as part of the preanalysis of the expression, these\n-            --  shared identifiers may be left decorated with itypes which\n-            --  will not be available in the tree passed to the backend.\n-\n-            Clone_Def_Ids (Dup_Expr);\n-\n-            return Dup_Expr;\n-         end Cloned_Expression;\n-\n-         ----------------------\n-         -- Freeze_Type_Refs --\n-         ----------------------\n-\n-         function Freeze_Type_Refs (Node : Node_Id) return Traverse_Result is\n-         begin\n-            if Nkind (Node) = N_Identifier\n-              and then Present (Entity (Node))\n-            then\n-               if Is_Type (Entity (Node)) then\n-                  Freeze_Before (N, Entity (Node));\n-\n-               elsif Ekind_In (Entity (Node), E_Component,\n-                                              E_Discriminant)\n-               then\n-                  declare\n-                     Rec : constant Entity_Id := Scope (Entity (Node));\n-                  begin\n-\n-                     --  Check that the enclosing record type can be frozen.\n-                     --  This provides a better error message than generating\n-                     --  primitives whose compilation fails much later. Refine\n-                     --  the error message if possible.\n-\n-                     Check_Fully_Declared (Rec, Node);\n-\n-                     if Error_Posted (Node) then\n-                        if Has_Private_Component (Rec) then\n-                           Error_Msg_NE\n-                             (\"\\type& has private component\", Node, Rec);\n-                        end if;\n-\n-                     else\n-                        Freeze_Before (N, Rec);\n-                     end if;\n-                  end;\n-               end if;\n-\n-            --  Freezing an access type does not freeze the designated type,\n-            --  but freezing conversions between access to interfaces requires\n-            --  that the interface types themselves be frozen, so that dispatch\n-            --  table entities are properly created.\n-\n-            --  Unclear whether a more general rule is needed ???\n-\n-            elsif Nkind (Node) = N_Type_Conversion\n-              and then Is_Access_Type (Etype (Node))\n-              and then Is_Interface (Designated_Type (Etype (Node)))\n-            then\n-               Freeze_Before (N, Designated_Type (Etype (Node)));\n-            end if;\n-\n-            return OK;\n-         end Freeze_Type_Refs;\n-\n-         procedure Freeze_References is new Traverse_Proc (Freeze_Type_Refs);\n-\n-         --  Local variables\n-\n-         Saved_First_Entity : constant Entity_Id := First_Entity (Spec_Id);\n-         Saved_Last_Entity  : constant Entity_Id := Last_Entity  (Spec_Id);\n-         Dup_Expr           : constant Node_Id   := Cloned_Expression;\n-\n-      --  Start of processing for Freeze_Expr_Types\n-\n-      begin\n-         --  Preanalyze a duplicate of the expression to have available the\n-         --  minimum decoration needed to locate referenced unfrozen types\n-         --  without adding any decoration to the function expression. This\n-         --  preanalysis is performed with errors disabled to avoid reporting\n-         --  spurious errors on Ghost entities (since the expression is not\n-         --  fully analyzed).\n-\n-         Push_Scope (Spec_Id);\n-         Install_Formals (Spec_Id);\n-         Ignore_Errors_Enable := Ignore_Errors_Enable + 1;\n-\n-         Preanalyze_Spec_Expression (Dup_Expr, Etype (Spec_Id));\n-\n-         Ignore_Errors_Enable := Ignore_Errors_Enable - 1;\n-         End_Scope;\n-\n-         --  Restore certain attributes of Spec_Id since the preanalysis may\n-         --  have introduced itypes to this scope, thus modifying attributes\n-         --  First_Entity and Last_Entity.\n-\n-         Set_First_Entity (Spec_Id, Saved_First_Entity);\n-         Set_Last_Entity  (Spec_Id, Saved_Last_Entity);\n-\n-         if Present (Last_Entity (Spec_Id)) then\n-            Set_Next_Entity (Last_Entity (Spec_Id), Empty);\n-         end if;\n-\n-         --  Freeze all types referenced in the expression\n-\n-         Freeze_References (Dup_Expr);\n-      end Freeze_Expr_Types;\n-\n       -------------------------------------\n       -- Is_Private_Concurrent_Primitive --\n       -------------------------------------\n@@ -3627,17 +3618,6 @@ package body Sem_Ch6 is\n          then\n             Set_Has_Delayed_Freeze (Spec_Id);\n             Freeze_Before (N, Spec_Id);\n-\n-            --  AI12-0103: At the occurrence of an expression function\n-            --  declaration that is a completion, its expression causes\n-            --  freezing.\n-\n-            if Has_Completion (Spec_Id)\n-              and then Nkind (N) = N_Subprogram_Body\n-              and then Was_Expression_Function (N)\n-            then\n-               Freeze_Expr_Types (Spec_Id);\n-            end if;\n          end if;\n       end if;\n "}, {"sha": "0dc5f08d88be5320e64d46e10888885e2ed35ce3", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac62786d6fb3b28c157fe9e6292842aa201d904/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=4ac62786d6fb3b28c157fe9e6292842aa201d904", "patch": "@@ -17924,7 +17924,7 @@ package body Sem_Prag is\n                then\n                   declare\n                      Name : constant String :=\n-                       Get_Name_String (Chars (Variant));\n+                              Get_Name_String (Chars (Variant));\n                   begin\n                      --  It is a common mistake to write \"Increasing\" for\n                      --  \"Increases\" or \"Decreasing\" for \"Decreases\". Recognize"}]}