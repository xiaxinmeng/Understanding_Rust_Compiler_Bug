{"sha": "0f32c94fc72313798b3a9033c92ceb34f7b7febc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYzMmM5NGZjNzIzMTM3OThiM2E5MDMzYzkyY2ViMzRmN2I3ZmViYw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-07-22T15:20:31Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-07-22T15:43:25Z"}, "message": "c++: More cleanups for modern C++\n\nHere are some more places where we can declare variables at the\nassignment point, rather than use C89.  Also, let's name our variables\nby what they contain -- the register allocator is perfectly able to\ntrack liveness for us.\n\n\tgcc/cp/\n\t* decl.c (decls_match): Move variables into scopes\n\tthey're needed in.\n\t(duplicate_decls): Use STRIP_TEMPLATE.\n\t(build_typename_type): Move var decls to their assignments.\n\t(begin_function_body): Likewise.\n\t* decl2.c (get_guard): Likewise.\n\t(mark_used): Use true for truthiness.\n\t* error.c (dump_aggr_type): Hold the decl in a var called\n\t'decl', not 'name'.", "tree": {"sha": "59649da06fa27294415cba4aaf3bcb560e7dc37d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59649da06fa27294415cba4aaf3bcb560e7dc37d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f32c94fc72313798b3a9033c92ceb34f7b7febc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f32c94fc72313798b3a9033c92ceb34f7b7febc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f32c94fc72313798b3a9033c92ceb34f7b7febc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f32c94fc72313798b3a9033c92ceb34f7b7febc/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63fa0927e8aba59b1a301f7d13f5cd0e6bb62a66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63fa0927e8aba59b1a301f7d13f5cd0e6bb62a66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63fa0927e8aba59b1a301f7d13f5cd0e6bb62a66"}], "stats": {"total": 97, "additions": 39, "deletions": 58}, "files": [{"sha": "de53a7b8b732070a13ac36368cfdb6e6eb8be9d2", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 23, "deletions": 38, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f32c94fc72313798b3a9033c92ceb34f7b7febc/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f32c94fc72313798b3a9033c92ceb34f7b7febc/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0f32c94fc72313798b3a9033c92ceb34f7b7febc", "patch": "@@ -974,12 +974,6 @@ decls_match (tree newdecl, tree olddecl, bool record_versions /* = true */)\n \n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n-      tree f1 = TREE_TYPE (newdecl);\n-      tree f2 = TREE_TYPE (olddecl);\n-      tree p1 = TYPE_ARG_TYPES (f1);\n-      tree p2 = TYPE_ARG_TYPES (f2);\n-      tree r2;\n-\n       /* Specializations of different templates are different functions\n \t even if they have the same type.  */\n       tree t1 = (DECL_USE_TEMPLATE (newdecl)\n@@ -1002,14 +996,20 @@ decls_match (tree newdecl, tree olddecl, bool record_versions /* = true */)\n \t  && DECL_EXTERN_C_P (olddecl) && !DECL_EXTERN_C_P (newdecl))\n \treturn 0;\n \n+      tree f1 = TREE_TYPE (newdecl);\n+      tree f2 = TREE_TYPE (olddecl);\n       if (TREE_CODE (f1) != TREE_CODE (f2))\n \treturn 0;\n \n       /* A declaration with deduced return type should use its pre-deduction\n \t type for declaration matching.  */\n-      r2 = fndecl_declared_return_type (olddecl);\n+      tree r2 = fndecl_declared_return_type (olddecl);\n+      tree r1 = fndecl_declared_return_type (newdecl);\n+\n+      tree p1 = TYPE_ARG_TYPES (f1);\n+      tree p2 = TYPE_ARG_TYPES (f2);\n \n-      if (same_type_p (TREE_TYPE (f1), r2))\n+      if (same_type_p (r1, r2))\n \t{\n \t  if (!prototype_p (f2) && DECL_EXTERN_C_P (olddecl)\n \t      && fndecl_built_in_p (olddecl))\n@@ -2457,14 +2457,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t      || (TREE_CODE (olddecl) == TEMPLATE_DECL\n \t\t  && (TREE_CODE (DECL_TEMPLATE_RESULT (olddecl))\n \t\t      == FUNCTION_DECL))))\n-\t{\n-\t  tree fn = olddecl;\n-\n-\t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\t    fn = DECL_TEMPLATE_RESULT (olddecl);\n-\n-\t  new_redefines_gnu_inline = GNU_INLINE_P (fn) && DECL_INITIAL (fn);\n-\t}\n+\tnew_redefines_gnu_inline = GNU_INLINE_P (STRIP_TEMPLATE (olddecl));\n \n       if (!new_redefines_gnu_inline)\n \t{\n@@ -3852,11 +3845,7 @@ tree\n build_typename_type (tree context, tree name, tree fullname,\n \t\t     enum tag_types tag_type)\n {\n-  tree t;\n-  tree d;\n   typename_info ti;\n-  tree *e;\n-  hashval_t hash;\n \n   if (typename_htab == NULL)\n     typename_htab = hash_table<typename_hasher>::create_ggc (61);\n@@ -3868,11 +3857,12 @@ build_typename_type (tree context, tree name, tree fullname,\n   ti.class_p = (tag_type == class_type\n \t\t|| tag_type == record_type\n \t\t|| tag_type == union_type);\n-  hash =  (htab_hash_pointer (ti.scope)\n-\t   ^ htab_hash_pointer (ti.name));\n+  hashval_t hash =  (htab_hash_pointer (ti.scope)\n+\t\t     ^ htab_hash_pointer (ti.name));\n \n   /* See if we already have this type.  */\n-  e = typename_htab->find_slot_with_hash (&ti, hash, INSERT);\n+  tree *e = typename_htab->find_slot_with_hash (&ti, hash, INSERT);\n+  tree t = *e;\n   if (*e)\n     t = *e;\n   else\n@@ -3885,10 +3875,10 @@ build_typename_type (tree context, tree name, tree fullname,\n       TYPENAME_IS_CLASS_P (t) = ti.class_p;\n \n       /* Build the corresponding TYPE_DECL.  */\n-      d = build_decl (input_location, TYPE_DECL, name, t);\n-      TYPE_NAME (TREE_TYPE (d)) = d;\n-      TYPE_STUB_DECL (TREE_TYPE (d)) = d;\n-      DECL_CONTEXT (d) = FROB_CONTEXT (context);\n+      tree d = build_decl (input_location, TYPE_DECL, name, t);\n+      TYPE_NAME (t) = d;\n+      TYPE_STUB_DECL (t) = d;\n+      DECL_CONTEXT (d) = ti.scope;\n       DECL_ARTIFICIAL (d) = 1;\n \n       /* Store it in the hash table.  */\n@@ -4061,9 +4051,6 @@ tree\n make_unbound_class_template (tree context, tree name, tree parm_list,\n \t\t\t     tsubst_flags_t complain)\n {\n-  tree t;\n-  tree d;\n-\n   if (TYPE_P (name))\n     name = TYPE_IDENTIFIER (name);\n   else if (DECL_P (name))\n@@ -4108,16 +4095,16 @@ make_unbound_class_template (tree context, tree name, tree parm_list,\n     }\n \n   /* Build the UNBOUND_CLASS_TEMPLATE.  */\n-  t = cxx_make_type (UNBOUND_CLASS_TEMPLATE);\n+  tree t = cxx_make_type (UNBOUND_CLASS_TEMPLATE);\n   TYPE_CONTEXT (t) = FROB_CONTEXT (context);\n   TREE_TYPE (t) = NULL_TREE;\n   SET_TYPE_STRUCTURAL_EQUALITY (t);\n \n   /* Build the corresponding TEMPLATE_DECL.  */\n-  d = build_decl (input_location, TEMPLATE_DECL, name, t);\n-  TYPE_NAME (TREE_TYPE (d)) = d;\n-  TYPE_STUB_DECL (TREE_TYPE (d)) = d;\n-  DECL_CONTEXT (d) = FROB_CONTEXT (context);\n+  tree d = build_decl (input_location, TEMPLATE_DECL, name, t);\n+  TYPE_NAME (t) = d;\n+  TYPE_STUB_DECL (t) = d;\n+  DECL_CONTEXT (d) = TYPE_CONTEXT (t);\n   DECL_ARTIFICIAL (d) = 1;\n   DECL_TEMPLATE_PARMS (d) = parm_list;\n \n@@ -16819,8 +16806,6 @@ finish_destructor_body (void)\n tree\n begin_function_body (void)\n {\n-  tree stmt;\n-\n   if (! FUNCTION_NEEDS_BODY_BLOCK (current_function_decl))\n     return NULL_TREE;\n \n@@ -16832,7 +16817,7 @@ begin_function_body (void)\n        operation of dwarfout.c.  */\n     keep_next_level (true);\n \n-  stmt = begin_compound_stmt (BCS_FN_BODY);\n+  tree stmt = begin_compound_stmt (BCS_FN_BODY);\n \n   if (processing_template_decl)\n     /* Do nothing now.  */;"}, {"sha": "33c83773d33a4e4dfd4182557c5f5ec65c580097", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f32c94fc72313798b3a9033c92ceb34f7b7febc/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f32c94fc72313798b3a9033c92ceb34f7b7febc/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0f32c94fc72313798b3a9033c92ceb34f7b7febc", "patch": "@@ -3294,11 +3294,8 @@ copy_linkage (tree guard, tree decl)\n tree\n get_guard (tree decl)\n {\n-  tree sname;\n-  tree guard;\n-\n-  sname = mangle_guard_variable (decl);\n-  guard = get_global_binding (sname);\n+  tree sname = mangle_guard_variable (decl);\n+  tree guard = get_global_binding (sname);\n   if (! guard)\n     {\n       tree guard_type;\n@@ -5536,10 +5533,11 @@ mark_used (tree decl, tsubst_flags_t complain)\n     return true;\n \n   /* Set TREE_USED for the benefit of -Wunused.  */\n-  TREE_USED (decl) = 1;\n+  TREE_USED (decl) = true;\n+\n   /* And for structured bindings also the underlying decl.  */\n   if (DECL_DECOMPOSITION_P (decl) && DECL_DECOMP_BASE (decl))\n-    TREE_USED (DECL_DECOMP_BASE (decl)) = 1;\n+    TREE_USED (DECL_DECOMP_BASE (decl)) = true;\n \n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n     return true;"}, {"sha": "ecb41e82d8cdab0d534ff0c30782c791fa1c457d", "filename": "gcc/cp/error.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f32c94fc72313798b3a9033c92ceb34f7b7febc/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f32c94fc72313798b3a9033c92ceb34f7b7febc/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=0f32c94fc72313798b3a9033c92ceb34f7b7febc", "patch": "@@ -701,7 +701,6 @@ class_key_or_enum_as_string (tree t)\n static void\n dump_aggr_type (cxx_pretty_printer *pp, tree t, int flags)\n {\n-  tree name;\n   const char *variety = class_key_or_enum_as_string (t);\n   int typdef = 0;\n   int tmplate = 0;\n@@ -711,23 +710,23 @@ dump_aggr_type (cxx_pretty_printer *pp, tree t, int flags)\n   if (flags & TFF_CLASS_KEY_OR_ENUM)\n     pp_cxx_ws_string (pp, variety);\n \n-  name = TYPE_NAME (t);\n+  tree decl = TYPE_NAME (t);\n \n-  if (name)\n+  if (decl)\n     {\n-      typdef = (!DECL_ARTIFICIAL (name)\n+      typdef = (!DECL_ARTIFICIAL (decl)\n \t\t/* An alias specialization is not considered to be a\n \t\t   typedef.  */\n \t\t&& !alias_template_specialization_p (t, nt_opaque));\n \n       if ((typdef\n \t   && ((flags & TFF_CHASE_TYPEDEF)\n-\t       || (!flag_pretty_templates && DECL_LANG_SPECIFIC (name)\n-\t\t   && DECL_TEMPLATE_INFO (name))))\n-\t  || DECL_SELF_REFERENCE_P (name))\n+\t       || (!flag_pretty_templates && DECL_LANG_SPECIFIC (decl)\n+\t\t   && DECL_TEMPLATE_INFO (decl))))\n+\t  || DECL_SELF_REFERENCE_P (decl))\n \t{\n \t  t = TYPE_MAIN_VARIANT (t);\n-\t  name = TYPE_NAME (t);\n+\t  decl = TYPE_NAME (t);\n \t  typdef = 0;\n \t}\n \n@@ -737,7 +736,7 @@ dump_aggr_type (cxx_pretty_printer *pp, tree t, int flags)\n \t\t    || PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (t)));\n       \n       if (! (flags & TFF_UNQUALIFIED_NAME))\n-\tdump_scope (pp, CP_DECL_CONTEXT (name), flags | TFF_SCOPE);\n+\tdump_scope (pp, CP_DECL_CONTEXT (decl), flags | TFF_SCOPE);\n       flags &= ~TFF_UNQUALIFIED_NAME;\n       if (tmplate)\n \t{\n@@ -747,9 +746,8 @@ dump_aggr_type (cxx_pretty_printer *pp, tree t, int flags)\n \n \t  while (DECL_TEMPLATE_INFO (tpl))\n \t    tpl = DECL_TI_TEMPLATE (tpl);\n-\t  name = tpl;\n+\t  decl = tpl;\n \t}\n-      name = DECL_NAME (name);\n     }\n \n   if (LAMBDA_TYPE_P (t))\n@@ -762,15 +760,15 @@ dump_aggr_type (cxx_pretty_printer *pp, tree t, int flags)\n \t\t\t flags);\n       pp_greater (pp);\n     }\n-  else if (!name || IDENTIFIER_ANON_P (name))\n+  else if (!decl || IDENTIFIER_ANON_P (DECL_NAME (decl)))\n     {\n       if (flags & TFF_CLASS_KEY_OR_ENUM)\n \tpp_string (pp, M_(\"<unnamed>\"));\n       else\n \tpp_printf (pp, M_(\"<unnamed %s>\"), variety);\n     }\n   else\n-    pp_cxx_tree_identifier (pp, name);\n+    pp_cxx_tree_identifier (pp, DECL_NAME (decl));\n \n   if (tmplate)\n     dump_template_parms (pp, TYPE_TEMPLATE_INFO (t),"}]}