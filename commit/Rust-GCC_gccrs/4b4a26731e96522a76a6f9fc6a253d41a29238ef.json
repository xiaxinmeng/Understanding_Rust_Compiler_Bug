{"sha": "4b4a26731e96522a76a6f9fc6a253d41a29238ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI0YTI2NzMxZTk2NTIyYTc2YTZmOWZjNmEyNTNkNDFhMjkyMzhlZg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-06-19T20:37:41Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-06-19T20:37:41Z"}, "message": "PR tree-optimization/90626 - fold strcmp(a, b) == 0 to zero when one string length is exact and the other is unequal\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/90626\n\t* tree-ssa-strlen.c (strxcmp_unequal): New function.\n\t(handle_builtin_string_cmp): Call it.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/90626\n\t* gcc.dg/strlenopt-65.c: New test.\n\t* gcc.dg/strlenopt-66.c: New test.\n\t* gcc.dg/strlenopt.h (strcmp, strncmp): Declare.\n\nFrom-SVN: r272485", "tree": {"sha": "ead7cea0bd370d8f021fe8e4df8a2ff9ed11b09b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ead7cea0bd370d8f021fe8e4df8a2ff9ed11b09b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b4a26731e96522a76a6f9fc6a253d41a29238ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b4a26731e96522a76a6f9fc6a253d41a29238ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b4a26731e96522a76a6f9fc6a253d41a29238ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b4a26731e96522a76a6f9fc6a253d41a29238ef/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "14fef000947916e55e5aa1bdd6d78a04ed78dde4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14fef000947916e55e5aa1bdd6d78a04ed78dde4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14fef000947916e55e5aa1bdd6d78a04ed78dde4"}], "stats": {"total": 328, "additions": 319, "deletions": 9}, "files": [{"sha": "bf5ae3e2dc2100d4b7e834ef05abea262d564fda", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4a26731e96522a76a6f9fc6a253d41a29238ef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4a26731e96522a76a6f9fc6a253d41a29238ef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b4a26731e96522a76a6f9fc6a253d41a29238ef", "patch": "@@ -1,3 +1,9 @@\n+2019-06-19  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/90626\n+\t* tree-ssa-strlen.c (strxcmp_unequal): New function.\n+\t(handle_builtin_string_cmp): Call it.\n+\n 2019-06-19  Iain Sandoe  <iain@sandoe.co.uk>\n \n \t* config/darwin.h (DRIVER_SELF_SPECS): Add RDYNAMIC, DARWIN_PIE_SPEC"}, {"sha": "76f06225d3c7784753b05ec9139e9a745fa7cac4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4a26731e96522a76a6f9fc6a253d41a29238ef/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4a26731e96522a76a6f9fc6a253d41a29238ef/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4b4a26731e96522a76a6f9fc6a253d41a29238ef", "patch": "@@ -1,3 +1,10 @@\n+2019-06-19  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/90626\n+\t* gcc.dg/strlenopt-65.c: New test.\n+\t* gcc.dg/strlenopt-66.c: New test.\n+\t* gcc.dg/strlenopt.h (strcmp, strncmp): Declare.\n+\n 2019-06-19  Martin Sebor  <msebor@redhat.com>\n \n \tPR translation/90156"}, {"sha": "a34d178faa112a896630b33d1383c81302d569d8", "filename": "gcc/testsuite/gcc.dg/strlenopt-65.c", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4a26731e96522a76a6f9fc6a253d41a29238ef/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-65.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4a26731e96522a76a6f9fc6a253d41a29238ef/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-65.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-65.c?ref=4b4a26731e96522a76a6f9fc6a253d41a29238ef", "patch": "@@ -0,0 +1,162 @@\n+/* PRE tree-optimization/90626 - fold strcmp(a, b) == 0 to zero when\n+   one string length is exact and the other is unequal\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n+\n+#include \"strlenopt.h\"\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void abort (void);\n+extern void* memcpy (void *, const void *, size_t);\n+extern int strcmp (const char *, const char *);\n+extern int strncmp (const char *, const char *, size_t);\n+\n+#define CAT(x, y) x ## y\n+#define CONCAT(x, y) CAT (x, y)\n+#define FAILNAME(name) CONCAT (call_ ## name ##_on_line_, __LINE__)\n+\n+#define FAIL(name) do {\t\t\t\t\\\n+    extern void FAILNAME (name) (void);\t\t\\\n+    FAILNAME (name)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macro to emit a call to function named\n+     call_in_true_branch_not_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define ELIM_IF_TRUE(expr)\t\t\t\t\t\t\\\n+  if (!(expr)) FAIL (in_true_branch_not_eliminated); else (void)0\n+\n+/* Macro to emit a call to a function named\n+     call_made_in_{true,false}_branch_on_line_NNN()\n+   for each call that's expected to be retained.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that the expected number of both kinds of calls appears in output\n+   (a pair for each line with the invocation of the KEEP() macro.  */\n+#define TEST_KEEP(expr)\t\t\t\t\\\n+  if (expr)\t\t\t\t\t\\\n+    FAIL (made_in_true_branch);\t\t\t\\\n+  else\t\t\t\t\t\t\\\n+    FAIL (made_in_false_branch)\n+\n+#define FOLD(init1, init2, arg1, arg2, bnd)\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    char a[8], b[8];\t\t\t\t\t\\\n+    sink (a, b);\t\t\t\t\t\\\n+    memcpy (a, init1, sizeof init1 - 1);\t\t\\\n+    memcpy (b, init2, sizeof init2 - 1);\t\t\\\n+    ELIM_IF_TRUE (0 != CMPFUNC (arg1, arg2, bnd));\t\\\n+  } while (0)\n+\n+#define KEEP(init1, init2, arg1, arg2, bnd)\t\\\n+  do {\t\t\t\t\t\t\\\n+    char a[8], b[8];\t\t\t\t\\\n+    sink (a, b);\t\t\t\t\\\n+    memcpy (a, init1, sizeof init1 - 1);\t\\\n+    memcpy (b, init2, sizeof init2 - 1);\t\\\n+    TEST_KEEP (0 == CMPFUNC (arg1, arg2, bnd));\t\\\n+  } while (0)\n+\n+const char s0[1] = \"\";\n+const char s00[2] = \"\\0\";\n+const char s10[2] = \"1\";\n+const char s20[2] = \"2\";\n+\n+void sink (void*, ...);\n+\n+void test_strcmp_elim (void)\n+{\n+#undef CMPFUNC\n+#define CMPFUNC(a, b, dummy) strcmp (a, b)\n+\n+  FOLD (s00, s10, \"\\0\", \"1\", -1);\n+  FOLD (s00, s10, \"\\0\", b, -1);\n+  FOLD (s00, s10, \"\\0\", s10, -1);\n+\n+  FOLD (s00, s10, s0, \"1\", -1);\n+  FOLD (s00, s10, s0, b, -1);\n+  FOLD (s00, s10, s0, s10, -1);\n+\n+  FOLD (\"\\0\", \"1\", s0, \"1\", -1);\n+  FOLD (\"\\0\", \"1\", s0, b, -1);\n+  FOLD (\"\\0\", \"1\", s0, s10, -1);\n+\n+  FOLD (\"2\",  \"\\0\", \"2\", \"\\0\", -1);\n+  FOLD (\"2\",  \"\\0\", s20, s0, -1);\n+\n+  FOLD (\"\\0\", \"1\", a, b, -1);\n+  FOLD (\"2\",  \"\\0\", a, b, -1);\n+\n+  FOLD (\"4\\0\", \"44\", a, b, -1);\n+  FOLD (\"55\", \"5\\0\", a, b, -1);\n+\n+  FOLD (\"666\\0\", \"6666\", a, \"6666\", -1);\n+  FOLD (\"666\\0\", \"6666\", a, b, -1);\n+  FOLD (\"7777\", \"777\\0\", a, b, -1);\n+\n+  /* Avoid testing substrings of equal length with different characters.\n+     The optimization doesn't have access to the contents of the strings\n+     so it can't determine whether they are equal.\n+\n+     FOLD (\"111\\0\", \"112\", a, b, -1);\n+     FOLD (\"112\", \"111\\0\", a, b, -1);  */\n+}\n+\n+const char s123[] = \"123\";\n+const char s1230[] = \"123\\0\";\n+\n+const char s1234[] = \"1234\";\n+const char s12340[] = \"1234\\0\";\n+\n+void test_strncmp_elim (void)\n+{\n+#undef CMPFUNC\n+#define CMPFUNC(a, b, n) strncmp (a, b, n)\n+\n+  FOLD (s1230, s1234, \"123\",  \"1234\", 4);\n+  FOLD (s1234, s1230, \"1234\", \"123\",  4);\n+\n+  FOLD (s1230, s1234, \"123\",  s1234, 4);\n+  FOLD (s1234, s1230, \"1234\", s123,  4);\n+\n+  FOLD (s1230, s1234, s123,  \"1234\", 4);\n+  FOLD (s1234, s1230, s1234, \"123\",  4);\n+\n+  FOLD (s1230, s1234, s123,  b, 4);\n+  FOLD (s1234, s1230, s1234, b, 4);\n+\n+  FOLD (s1230, s1234, a, b, 4);\n+  FOLD (s1234, s1230, a, b, 4);\n+\n+  FOLD (\"123\\0\", \"1234\",  a, b, 5);\n+  FOLD (\"1234\",  \"123\\0\", a, b, 5);\n+}\n+\n+\n+#line 1000\n+\n+void test_strcmp_keep (const char *s, const char *t)\n+{\n+#undef CMPFUNC\n+#define CMPFUNC(a, b, dummy) strcmp (a, b)\n+\n+  KEEP (\"1\", \"1\", a, b, -1);\n+\n+  KEEP (\"1\\0\", \"1\", a, b, -1);\n+  KEEP (\"1\",   \"1\\0\", a, b, -1);\n+\n+  KEEP (\"12\\0\", \"12\", a, b, -1);\n+  KEEP (\"12\",   \"12\\0\", a, b, -1);\n+\n+  KEEP (\"111\\0\", \"111\", a, b, -1);\n+  KEEP (\"112\", \"112\\0\", a, b, -1);\n+\n+  KEEP (s, t, a, b, -1);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"call_in_true_branch_not_eliminated_\" 0 \"optimized\" } }\n+\n+   { dg-final { scan-tree-dump-times \"call_made_in_true_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 8 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"call_made_in_false_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 8 \"optimized\" } } */"}, {"sha": "5dc10a07d3db68a3c2144a97d3543a079351e8f6", "filename": "gcc/testsuite/gcc.dg/strlenopt-66.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4a26731e96522a76a6f9fc6a253d41a29238ef/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-66.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4a26731e96522a76a6f9fc6a253d41a29238ef/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-66.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-66.c?ref=4b4a26731e96522a76a6f9fc6a253d41a29238ef", "patch": "@@ -0,0 +1,72 @@\n+/* PRE tree-optimization/90626 - fold strcmp(a, b) == 0 to zero when\n+   one string length is exact and the other is unequal\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define A(expr)                                                 \\\n+  ((expr)                                                       \\\n+   ? (void)0                                                    \\\n+   : (__builtin_printf (\"assertion failed on line %i: %s\\n\",    \\\n+                        __LINE__, #expr),                       \\\n+      __builtin_abort ()))\n+\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+clobber (void *p, int x, size_t n)\n+{\n+  for (volatile unsigned char *q = p; n--; )\n+    *q = x;\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+test_strcmp (void)\n+{\n+  char a[8], b[8];\n+  strcpy (a, \"1235\");\n+  strcpy (b, \"1234\");\n+\n+  A (strcmp (a, b));\n+\n+  clobber (a, 0, sizeof a);\n+  clobber (b, 0, sizeof b);\n+  clobber (b + 4, '5', 1);\n+\n+  memcpy (a, \"1234\", 4);\n+  memcpy (b, \"1234\", 4);\n+\n+  A (0 > strcmp (a, b));\n+  A (0 < strcmp (b, a));\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+test_strncmp (void)\n+{\n+  char a[8], b[8];\n+  strcpy (a, \"1235\");\n+  strcpy (b, \"1234\");\n+\n+  A (0 == strncmp (a, b, 1));\n+  A (0 == strncmp (a, b, 2));\n+  A (0 == strncmp (a, b, 3));\n+  A (0 <  strncmp (a, b, 4));\n+  A (0 >  strncmp (b, a, 4));\n+\n+  clobber (a, 0, sizeof a);\n+  clobber (b, 0, sizeof b);\n+  clobber (b + 4, '5', 1);\n+\n+  memcpy (a, \"1234\", 4);\n+  memcpy (b, \"1234\", 4);\n+\n+  A (0 == strncmp (a, b, 4));\n+  A (0 >  strncmp (a, b, 5));\n+  A (0 <  strncmp (b, a, 5));\n+}\n+\n+int main (void)\n+{\n+  test_strcmp ();\n+  test_strncmp ();\n+}"}, {"sha": "d25e08a8a42ea0eb96f78b8c254ecd8834e7f140", "filename": "gcc/testsuite/gcc.dg/strlenopt.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4a26731e96522a76a6f9fc6a253d41a29238ef/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4a26731e96522a76a6f9fc6a253d41a29238ef/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt.h?ref=4b4a26731e96522a76a6f9fc6a253d41a29238ef", "patch": "@@ -15,6 +15,8 @@ void *memmove (void *, const void *, size_t);\n char *strcpy (char *__restrict, const char *__restrict);\n char *strcat (char *__restrict, const char *__restrict);\n char *strchr (const char *, int);\n+int strcmp (const char *, const char *);\n+int strncmp (const char *, const char *, size_t);\n void *memset (void *, int, size_t);\n int memcmp (const void *, const void *, size_t);\n int strcmp (const char *, const char *);"}, {"sha": "80e7f9992d484fedb172a03663b7155ef313a382", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 70, "deletions": 9, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4a26731e96522a76a6f9fc6a253d41a29238ef/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4a26731e96522a76a6f9fc6a253d41a29238ef/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=4b4a26731e96522a76a6f9fc6a253d41a29238ef", "patch": "@@ -2947,6 +2947,73 @@ handle_builtin_memcmp (gimple_stmt_iterator *gsi)\n   return true;\n }\n \n+/* If IDX1 and IDX2 refer to strings A and B of unequal lengths, return\n+   the result of 0 == strncmp (A, B, N) (which is the same as strcmp for\n+   sufficiently large N).  Otherwise return false.  */\n+\n+static bool\n+strxcmp_unequal (int idx1, int idx2, unsigned HOST_WIDE_INT n)\n+{\n+  unsigned HOST_WIDE_INT len1;\n+  unsigned HOST_WIDE_INT len2;\n+\n+  bool nulterm1;\n+  bool nulterm2;\n+\n+  if (idx1 < 0)\n+    {\n+      len1 = ~idx1;\n+      nulterm1 = true;\n+    }\n+  else if (strinfo *si = get_strinfo (idx1))\n+    {\n+      if (tree_fits_uhwi_p (si->nonzero_chars))\n+\t{\n+\t  len1 = tree_to_uhwi (si->nonzero_chars);\n+\t  nulterm1 = si->full_string_p;\n+\t}\n+      else\n+\treturn false;\n+    }\n+  else\n+    return false;\n+\n+  if (idx2 < 0)\n+    {\n+      len2 = ~idx2;\n+      nulterm1 = true;\n+    }\n+  else if (strinfo *si = get_strinfo (idx2))\n+    {\n+      if (tree_fits_uhwi_p (si->nonzero_chars))\n+\t{\n+\t  len2 = tree_to_uhwi (si->nonzero_chars);\n+\t  nulterm2 = si->full_string_p;\n+\t}\n+      else\n+\treturn false;\n+    }\n+  else\n+    return false;\n+\n+  /* N is set to UHWI_MAX for strcmp and less to strncmp.  Adjust\n+     the length of each string to consider to be no more than N.  */\n+  if (len1 > n)\n+    len1 = n;\n+  if (len2 > n)\n+    len2 = n;\n+\n+  if (len1 != len2 && (nulterm1 || nulterm2))\n+    /* The string lengths are definitely unequal and the result can\n+       be folded to one (since it's used for comparison with zero).  */\n+    return true;\n+\n+  /* The string lengths may be equal or unequal.  Even when equal and\n+     both strings nul-terminated, without the string contents there's\n+     no way to determine whether they are equal.  */\n+  return false;\n+}\n+\n /* Given an index to the strinfo vector, compute the string length\n    for the corresponding string. Return -1 when unknown.  */\n \n@@ -3132,18 +3199,12 @@ handle_builtin_string_cmp (gimple_stmt_iterator *gsi)\n         return false;\n     }\n \n-  /* When the lengths of both arguments are known, and they are unequal,\n+  /* When the lengths of the arguments are known to be unequal\n      we can safely fold the call to a non-zero value for strcmp;\n-     othewise, do nothing now.  */\n+     otherwise, do nothing now.  */\n   if (idx1 != 0 && idx2 != 0)\n     {\n-      HOST_WIDE_INT const_string_leni1 = compute_string_length (idx1);\n-      HOST_WIDE_INT const_string_leni2 = compute_string_length (idx2);\n-\n-      if (!is_ncmp\n-\t  && const_string_leni1 != -1\n-\t  && const_string_leni2 != -1\n-\t  && const_string_leni1 != const_string_leni2)\n+      if (strxcmp_unequal (idx1, idx2, length))\n \t{\n \t  replace_call_with_value (gsi, integer_one_node);\n \t  return true;"}]}