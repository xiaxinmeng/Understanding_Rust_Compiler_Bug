{"sha": "c20118a81159621ad3f438d7b24146328929ccc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzIwMTE4YTgxMTU5NjIxYWQzZjQzOGQ3YjI0MTQ2MzI4OTI5Y2NjNw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-10-20T06:04:59Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-10-20T06:04:59Z"}, "message": "class.c (subobject_offset_fn): New type.\n\n\t* class.c (subobject_offset_fn): New type.\n\t(dfs_record_base_offsets): Remove.\n\t(record_base_offsets): Likewise.\n\t(dfs_search_base_offsets): Likewise.\n\t(record_subobject_offset): New function.\n\t(check_subobject_offset): Likewise.\n\t(walk_subobject_offsets): Likewise.\n\t(record_subobject_offsets): Likewise.\n\t(layout_conflict_p): Reimplement.\n\t(layout_nonempty_base_or_field): Correct handling of type\n\tconflicts during layout.\n\t(layout_empty_base): Likewise.\n\t(build_base_field): Adjust to handle new representation of empty\n\tbase offset table.\n\t(build_base_fields): Likewise.\n\t(layout_virtual_bases): Likewise.\n\t(splay_tree_compare_integer_csts): New function.\n\t(layout_class_type): Use a splay_tree, rather than a varray, to\n\trepresent the offsets of empty bases.\n\nFrom-SVN: r36958", "tree": {"sha": "4cf2e35223dabb921c4be6daf982b11141d8ffeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cf2e35223dabb921c4be6daf982b11141d8ffeb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c20118a81159621ad3f438d7b24146328929ccc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c20118a81159621ad3f438d7b24146328929ccc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c20118a81159621ad3f438d7b24146328929ccc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c20118a81159621ad3f438d7b24146328929ccc7/comments", "author": null, "committer": null, "parents": [{"sha": "bf6d9fd730ee324567bc8aaf70e6effa557e0d25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf6d9fd730ee324567bc8aaf70e6effa557e0d25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf6d9fd730ee324567bc8aaf70e6effa557e0d25"}], "stats": {"total": 402, "additions": 274, "deletions": 128}, "files": [{"sha": "344a859e6383d69adedb59425372e466bedbb793", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c20118a81159621ad3f438d7b24146328929ccc7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c20118a81159621ad3f438d7b24146328929ccc7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c20118a81159621ad3f438d7b24146328929ccc7", "patch": "@@ -1,5 +1,25 @@\n 2000-10-19  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* class.c (subobject_offset_fn): New type.\n+\t(dfs_record_base_offsets): Remove.\n+\t(record_base_offsets): Likewise.\n+\t(dfs_search_base_offsets): Likewise.\n+\t(record_subobject_offset): New function.\n+\t(check_subobject_offset): Likewise.\n+\t(walk_subobject_offsets): Likewise.\n+\t(record_subobject_offsets): Likewise.\n+\t(layout_conflict_p): Reimplement.\n+\t(layout_nonempty_base_or_field): Correct handling of type\n+\tconflicts during layout.\n+\t(layout_empty_base): Likewise.\n+\t(build_base_field): Adjust to handle new representation of empty\n+\tbase offset table.\n+\t(build_base_fields): Likewise.\n+\t(layout_virtual_bases): Likewise.\n+\t(splay_tree_compare_integer_csts): New function.\n+\t(layout_class_type): Use a splay_tree, rather than a varray, to\n+\trepresent the offsets of empty bases.\n+\t\n \t* cp-tree.h (DECL_ANTICIPATED): Don't require a FUNCTION_DECL.\n \t* decl.c (select_decl): Don't return declarations that are\n \tDECL_ANTICIPATED."}, {"sha": "e59a8867f3c66662fc044adbfeebda5b423db921", "filename": "gcc/cp/class.c", "status": "modified", "additions": 254, "deletions": 128, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c20118a81159621ad3f438d7b24146328929ccc7/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c20118a81159621ad3f438d7b24146328929ccc7/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c20118a81159621ad3f438d7b24146328929ccc7", "patch": "@@ -89,6 +89,9 @@ typedef struct vtbl_init_data_s\n   int ctor_vtbl_p;\n } vtbl_init_data;\n \n+/* The type of a function passed to walk_subobject_offsets.  */\n+typedef int (*subobject_offset_fn) PARAMS ((tree, tree, splay_tree));\n+\n /* The stack itself.  This is an dynamically resized array.  The\n    number of elements allocated is CURRENT_CLASS_STACK_SIZE.  */\n static int current_class_stack_size;\n@@ -142,8 +145,9 @@ static void check_field_decl PARAMS ((tree, tree, int *, int *, int *, int *));\n static void check_field_decls PARAMS ((tree, tree *, int *, int *, int *, \n \t\t\t\t     int *));\n static void build_base_field PARAMS ((record_layout_info, tree, int *,\n-\t\t\t\t      unsigned int *, varray_type *));\n-static varray_type build_base_fields PARAMS ((record_layout_info, int *));\n+\t\t\t\t      unsigned int *, splay_tree));\n+static void build_base_fields PARAMS ((record_layout_info, int *,\n+\t\t\t\t       splay_tree));\n static tree build_vbase_pointer_fields PARAMS ((record_layout_info, int *));\n static tree build_vtbl_or_vbase_field PARAMS ((tree, tree, tree, tree, tree,\n \t\t\t\t\t       int *));\n@@ -157,7 +161,7 @@ static void fixup_pending_inline PARAMS ((tree));\n static void fixup_inline_methods PARAMS ((tree));\n static void set_primary_base PARAMS ((tree, tree, int *));\n static void propagate_binfo_offsets PARAMS ((tree, tree));\n-static void layout_virtual_bases PARAMS ((tree, varray_type *));\n+static void layout_virtual_bases PARAMS ((tree, splay_tree));\n static tree dfs_set_offset_for_unshared_vbases PARAMS ((tree, void *));\n static void build_vbase_offset_vtbl_entries PARAMS ((tree, vtbl_init_data *));\n static void add_vcall_offset_vtbl_entries_r PARAMS ((tree, vtbl_init_data *));\n@@ -174,13 +178,9 @@ static void initialize_vtable PARAMS ((tree, tree));\n static void initialize_array PARAMS ((tree, tree));\n static void layout_nonempty_base_or_field PARAMS ((record_layout_info,\n \t\t\t\t\t\t   tree, tree,\n-\t\t\t\t\t\t   varray_type));\n-static tree dfs_record_base_offsets PARAMS ((tree, void *));\n-static void record_base_offsets PARAMS ((tree, varray_type *));\n-static tree dfs_search_base_offsets PARAMS ((tree, void *));\n-static int layout_conflict_p PARAMS ((tree, varray_type));\n+\t\t\t\t\t\t   splay_tree));\n static unsigned HOST_WIDE_INT end_of_class PARAMS ((tree, int));\n-static void layout_empty_base PARAMS ((tree, tree, varray_type));\n+static void layout_empty_base PARAMS ((tree, tree, splay_tree));\n static void accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree, tree));\n static void set_vindex PARAMS ((tree, tree, int *));\n static void build_rtti_vtbl_entries PARAMS ((tree, tree, vtbl_init_data *));\n@@ -199,6 +199,14 @@ static tree dfs_build_secondary_vptr_vtt_inits PARAMS ((tree, void *));\n static tree dfs_fixup_binfo_vtbls PARAMS ((tree, void *));\n static tree get_matching_base PARAMS ((tree, tree));\n static tree dfs_get_primary_binfo PARAMS ((tree, void*));\n+static int record_subobject_offset PARAMS ((tree, tree, splay_tree));\n+static int check_subobject_offset PARAMS ((tree, tree, splay_tree));\n+static int walk_subobject_offsets PARAMS ((tree, subobject_offset_fn,\n+\t\t\t\t\t   tree, splay_tree, int));\n+static void record_subobject_offsets PARAMS ((tree, tree, splay_tree, int));\n+static int layout_conflict_p PARAMS ((tree, tree, splay_tree, int));\n+static int splay_tree_compare_integer_csts PARAMS ((splay_tree_key k1,\n+\t\t\t\t\t\t    splay_tree_key k2));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -3694,116 +3702,208 @@ build_vtbl_or_vbase_field (name, assembler_name, type, class_type, fcontext,\n   return field;\n }\n \n-/* Record the type of BINFO in the slot in DATA (which is really a\n-   `varray_type *') corresponding to the BINFO_OFFSET.  */\n+/* If TYPE is an empty class type, records its OFFSET in the table of\n+   OFFSETS.  */\n \n-static tree\n-dfs_record_base_offsets (binfo, data)\n-     tree binfo;\n-     void *data;\n+static int\n+record_subobject_offset (type, offset, offsets)\n+     tree type;\n+     tree offset;\n+     splay_tree offsets;\n {\n-  varray_type *v;\n-  unsigned HOST_WIDE_INT offset = tree_low_cst (BINFO_OFFSET (binfo), 1);\n+  splay_tree_node n;\n \n-  v = (varray_type *) data;\n-  while (VARRAY_SIZE (*v) <= offset)\n-    VARRAY_GROW (*v, 2 * VARRAY_SIZE (*v));\n-  VARRAY_TREE (*v, offset) = tree_cons (NULL_TREE,\n-\t\t\t\t\tBINFO_TYPE (binfo),\n-\t\t\t\t\tVARRAY_TREE (*v, offset));\n+  if (!is_empty_class (type))\n+    return 0;\n \n-  return NULL_TREE;\n+  /* Record the location of this empty object in OFFSETS.  */\n+  n = splay_tree_lookup (offsets, (splay_tree_key) offset);\n+  if (!n)\n+    n = splay_tree_insert (offsets, \n+\t\t\t   (splay_tree_key) offset,\n+\t\t\t   (splay_tree_value) NULL_TREE);\n+  n->value = ((splay_tree_value) \n+\t      tree_cons (NULL_TREE,\n+\t\t\t type,\n+\t\t\t (tree) n->value));\n+\n+  return 0;\n }\n \n-/* Add the offset of BINFO and its bases to BASE_OFFSETS.  */\n+/* Returns non-zero if TYPE is an empty class type and there is\n+   already an entry in OFFSETS for the same TYPE as the same OFFSET.  */\n \n-static void\n-record_base_offsets (binfo, base_offsets)\n-     tree binfo;\n-     varray_type *base_offsets;\n+static int\n+check_subobject_offset (type, offset, offsets)\n+     tree type;\n+     tree offset;\n+     splay_tree offsets;\n {\n-  dfs_walk (binfo,\n-\t    dfs_record_base_offsets,\n-\t    dfs_skip_vbases,\n-\t    base_offsets);\n+  splay_tree_node n;\n+  tree t;\n+\n+  if (!is_empty_class (type))\n+    return 0;\n+\n+  /* Record the location of this empty object in OFFSETS.  */\n+  n = splay_tree_lookup (offsets, (splay_tree_key) offset);\n+  if (!n)\n+    return 0;\n+\n+  for (t = (tree) n->value; t; t = TREE_CHAIN (t))\n+    if (same_type_p (TREE_VALUE (t), type))\n+      return 1;\n+\n+  return 0;\n }\n \n-/* Returns non-NULL if there is already an entry in DATA (which is\n-   really a `varray_type') indicating that an object with the same\n-   type of BINFO is already at the BINFO_OFFSET for BINFO.  */\n+/* Walk through all the subobjects of TYPE (located at OFFSET).  Call\n+   F for every subobject, passing it the type, offset, and table of\n+   OFFSETS.  If VBASES_P is non-zero, then even non-virtual primary\n+   bases should be traversed; otherwise, they are ignored.  If F\n+   returns a non-zero value, the traversal ceases, and that value is\n+   returned.  Otherwise, returns zero.  */\n \n-static tree\n-dfs_search_base_offsets (binfo, data)\n-     tree binfo;\n-     void *data;\n+static int\n+walk_subobject_offsets (type, f, offset, offsets, vbases_p)\n+     tree type;\n+     subobject_offset_fn f;\n+     tree offset;\n+     splay_tree offsets;\n+     int vbases_p;\n {\n-  if (is_empty_class (BINFO_TYPE (binfo)))\n+  int r = 0;\n+\n+  if (CLASS_TYPE_P (type))\n     {\n-      varray_type v = (varray_type) data;\n-      /* Find the offset for this BINFO.  */\n-      unsigned HOST_WIDE_INT offset = tree_low_cst (BINFO_OFFSET (binfo), 1);\n-      tree t;\n+      tree field;\n+      int i;\n \n-      /* If we haven't yet encountered any objects at offsets that\n-\t big, then there's no conflict.  */\n-      if (VARRAY_SIZE (v) <= offset)\n-\treturn NULL_TREE;\n-      /* Otherwise, go through the objects already allocated at this\n-\t offset.  */\n-      for (t = VARRAY_TREE (v, offset); t; t = TREE_CHAIN (t))\n-\tif (same_type_p (TREE_VALUE (t), BINFO_TYPE (binfo)))\n-\t  return binfo;\n+      /* Record the location of TYPE.  */\n+      r = (*f) (type, offset, offsets);\n+      if (r)\n+\treturn r;\n+\n+      /* Iterate through the direct base classes of TYPE.  */\n+      for (i = 0; i < CLASSTYPE_N_BASECLASSES (type); ++i)\n+\t{\n+\t  tree binfo = BINFO_BASETYPE (TYPE_BINFO (type), i);\n+\n+\t  if (!vbases_p \n+\t      && TREE_VIA_VIRTUAL (binfo) \n+\t      && !BINFO_PRIMARY_MARKED_P (binfo))\n+\t    continue;\n+\n+\t  r = walk_subobject_offsets (BINFO_TYPE (binfo),\n+\t\t\t\t      f,\n+\t\t\t\t      size_binop (PLUS_EXPR,\n+\t\t\t\t\t\t  offset,\n+\t\t\t\t\t\t  BINFO_OFFSET (binfo)),\n+\t\t\t\t      offsets,\n+\t\t\t\t      vbases_p);\n+\t  if (r)\n+\t    return r;\n+\t}\n+\n+      /* Iterate through the fields of TYPE.  */\n+      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\tif (TREE_CODE (field) == FIELD_DECL)\n+\t  {\n+\t    r = walk_subobject_offsets (TREE_TYPE (field),\n+\t\t\t\t\tf,\n+\t\t\t\t\tsize_binop (PLUS_EXPR,\n+\t\t\t\t\t\t    offset,\n+\t\t\t\t\t\t    DECL_FIELD_OFFSET (field)),\n+\t\t\t\t\toffsets,\n+\t\t\t\t\t/*vbases_p=*/1);\n+\t    if (r)\n+\t      return r;\n+\t  }\n     }\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      tree domain = TYPE_DOMAIN (type);\n+      tree index;\n \n-  return NULL_TREE;\n+      /* Step through each of the elements in the array.  */\n+      for (index = size_zero_node; \n+\t   INT_CST_LT (index, TYPE_MAX_VALUE (domain));\n+\t   index = size_binop (PLUS_EXPR, index, size_one_node))\n+\t{\n+\t  r = walk_subobject_offsets (TREE_TYPE (type),\n+\t\t\t\t      f,\n+\t\t\t\t      offset,\n+\t\t\t\t      offsets,\n+\t\t\t\t      /*vbases_p=*/1);\n+\t  if (r)\n+\t    return r;\n+\t  offset = size_binop (PLUS_EXPR, offset, \n+\t\t\t       TYPE_SIZE_UNIT (TREE_TYPE (type)));\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Record all of the empty subobjects of TYPE (located at OFFSET) in\n+   OFFSETS.  If VBASES_P is non-zero, virtual bases of TYPE are\n+   examined.  */\n+\n+static void\n+record_subobject_offsets (type, offset, offsets, vbases_p)\n+     tree type;\n+     tree offset;\n+     splay_tree offsets;\n+     int vbases_p;\n+{\n+  walk_subobject_offsets (type, record_subobject_offset, offset,\n+\t\t\t  offsets, vbases_p);\n }\n \n-/* Returns non-zero if there's a conflict between BINFO and a base\n-   already mentioned in BASE_OFFSETS if BINFO is placed at its current\n-   BINFO_OFFSET.  */\n+/* Returns non-zero if any of the empty subobjects of TYPE (located at\n+   OFFSET) conflict with entries in OFFSETS.  If VBASES_P is non-zero,\n+   virtual bases of TYPE are examined.  */\n \n static int\n-layout_conflict_p (binfo, base_offsets)\n-     tree binfo;\n-     varray_type base_offsets;\n+layout_conflict_p (type, offset, offsets, vbases_p)\n+     tree type;\n+     tree offset;\n+     splay_tree offsets;\n+     int vbases_p;\n {\n-  return dfs_walk (binfo, dfs_search_base_offsets, dfs_skip_vbases,\n-\t\t   base_offsets) != NULL_TREE;\n+  return walk_subobject_offsets (type, check_subobject_offset, offset,\n+\t\t\t\t offsets, vbases_p);\n }\n \n /* DECL is a FIELD_DECL corresponding either to a base subobject of a\n    non-static data member of the type indicated by RLI.  BINFO is the\n-   binfo corresponding to the base subobject, or, if this is a\n-   non-static data-member, a dummy BINFO for the type of the data\n-   member.  BINFO may be NULL if checks to see if the field overlaps\n-   an existing field with the same type are not required.  V maps\n-   offsets to types already located at those offsets.  This function\n-   determines the position of the DECL.  */\n+   binfo corresponding to the base subobject, OFFSETS maps offsets to\n+   types already located at those offsets.  This function determines\n+   the position of the DECL.  */\n \n static void\n-layout_nonempty_base_or_field (rli, decl, binfo, v)\n+layout_nonempty_base_or_field (rli, decl, binfo, offsets)\n      record_layout_info rli;\n      tree decl;\n      tree binfo;\n-     varray_type v;\n+     splay_tree offsets;\n {\n+  tree offset = NULL_TREE;\n+  tree type = TREE_TYPE (decl);\n+  /* If we are laying out a base class, rather than a field, then\n+     DECL_ARTIFICIAL will be set on the FIELD_DECL.  */\n+  int field_p = !DECL_ARTIFICIAL (decl);\n+\n   /* Try to place the field.  It may take more than one try if we have\n      a hard time placing the field without putting two objects of the\n      same type at the same address.  */\n   while (1)\n     {\n-      tree offset;\n       struct record_layout_info_s old_rli = *rli;\n \n       /* Place this field.  */\n       place_field (rli, decl);\n-      \n-      /* Now that we know where it wil be placed, update its\n-\t BINFO_OFFSET.  */\n       offset = byte_position (decl);\n-      if (binfo && CLASS_TYPE_P (BINFO_TYPE (binfo)))\n-\tpropagate_binfo_offsets (binfo, \n-\t\t\t\t convert (ssizetype, offset));\n  \n       /* We have to check to see whether or not there is already\n \t something of the same type at the offset we're about to use.\n@@ -3820,40 +3920,46 @@ layout_nonempty_base_or_field (rli, decl, binfo, v)\n \t empty class, have non-zero size, any overlap can happen only\n \t with a direct or indirect base-class -- it can't happen with\n \t a data member.  */\n-      if (binfo && flag_new_abi && layout_conflict_p (binfo, v))\n+      if (flag_new_abi && layout_conflict_p (TREE_TYPE (decl),\n+\t\t\t\t\t     offset,\n+\t\t\t\t\t     offsets, \n+\t\t\t\t\t     field_p))\n \t{\n-\t  /* Undo the propagate_binfo_offsets call.  */\n-\t  offset = size_diffop (size_zero_node, offset);\n-\t  propagate_binfo_offsets (binfo, convert (ssizetype, offset));\n-\t \n \t  /* Strip off the size allocated to this field.  That puts us\n \t     at the first place we could have put the field with\n \t     proper alignment.  */\n \t  *rli = old_rli;\n \n-\t  /* Bump up by the alignment required for the type, without\n-\t     virtual base classes.  */\n+\t  /* Bump up by the alignment required for the type.  */\n \t  rli->bitpos\n-\t    = size_binop (PLUS_EXPR, rli->bitpos,\n-\t\t\t  bitsize_int (CLASSTYPE_ALIGN (BINFO_TYPE (binfo))));\n+\t    = size_binop (PLUS_EXPR, rli->bitpos, \n+\t\t\t  bitsize_int (binfo \n+\t\t\t\t       ? CLASSTYPE_ALIGN (type)\n+\t\t\t\t       : TYPE_ALIGN (type)));\n \t  normalize_rli (rli);\n \t}\n       else\n \t/* There was no conflict.  We're done laying out this field.  */\n \tbreak;\n     }\n+\n+  /* Now that we know where it wil be placed, update its\n+     BINFO_OFFSET.  */\n+  if (binfo && CLASS_TYPE_P (BINFO_TYPE (binfo)))\n+    propagate_binfo_offsets (binfo, \n+\t\t\t     convert (ssizetype, offset));\n }\n \n /* Layout the empty base BINFO.  EOC indicates the byte currently just\n    past the end of the class, and should be correctly aligned for a\n-   class of the type indicated by BINFO; BINFO_OFFSETS gives the\n-   offsets of the other bases allocated so far.  */\n+   class of the type indicated by BINFO; OFFSETS gives the offsets of\n+   the empty bases allocated so far.  */\n \n static void\n-layout_empty_base (binfo, eoc, binfo_offsets)\n+layout_empty_base (binfo, eoc, offsets)\n      tree binfo;\n      tree eoc;\n-     varray_type binfo_offsets;\n+     splay_tree offsets;\n {\n   tree alignment;\n   tree basetype = BINFO_TYPE (binfo);\n@@ -3864,14 +3970,20 @@ layout_empty_base (binfo, eoc, binfo_offsets)\n \n   /* This is an empty base class.  We first try to put it at offset\n      zero.  */\n-  if (layout_conflict_p (binfo, binfo_offsets))\n+  if (layout_conflict_p (BINFO_TYPE (binfo),\n+\t\t\t BINFO_OFFSET (binfo),\n+\t\t\t offsets, \n+\t\t\t /*vbases_p=*/0))\n     {\n       /* That didn't work.  Now, we move forward from the next\n \t available spot in the class.  */\n       propagate_binfo_offsets (binfo, convert (ssizetype, eoc));\n       while (1) \n \t{\n-\t  if (!layout_conflict_p (binfo, binfo_offsets))\n+\t  if (!layout_conflict_p (BINFO_TYPE (binfo),\n+\t\t\t\t  BINFO_OFFSET (binfo), \n+\t\t\t\t  offsets,\n+\t\t\t\t  /*vbases_p=*/0))\n \t    /* We finally found a spot where there's no overlap.  */\n \t    break;\n \n@@ -3884,15 +3996,15 @@ layout_empty_base (binfo, eoc, binfo_offsets)\n /* Build a FIELD_DECL for the base given by BINFO in the class\n    indicated by RLI.  If the new object is non-empty, clear *EMPTY_P.\n    *BASE_ALIGN is a running maximum of the alignments of any base\n-   class.  */\n+   class.  OFFSETS gives the location of empty base subobjects.  */\n \n static void\n-build_base_field (rli, binfo, empty_p, base_align, v)\n+build_base_field (rli, binfo, empty_p, base_align, offsets)\n      record_layout_info rli;\n      tree binfo;\n      int *empty_p;\n      unsigned int *base_align;\n-     varray_type *v;\n+     splay_tree offsets;\n {\n   tree basetype = BINFO_TYPE (binfo);\n   tree decl;\n@@ -3933,7 +4045,7 @@ build_base_field (rli, binfo, empty_p, base_align, v)\n       /* Try to place the field.  It may take more than one try if we\n \t have a hard time placing the field without putting two\n \t objects of the same type at the same address.  */\n-      layout_nonempty_base_or_field (rli, decl, binfo, *v);\n+      layout_nonempty_base_or_field (rli, decl, binfo, offsets);\n     }\n   else\n     {\n@@ -3942,8 +4054,8 @@ build_base_field (rli, binfo, empty_p, base_align, v)\n       /* On some platforms (ARM), even empty classes will not be\n \t byte-aligned.  */\n       eoc = tree_low_cst (rli_size_unit_so_far (rli), 0);\n-      eoc = CEIL (eoc, DECL_ALIGN (decl)) * DECL_ALIGN (decl);\n-      layout_empty_base (binfo, size_int (eoc), *v);\n+      eoc = CEIL (eoc, DECL_ALIGN_UNIT (decl)) * DECL_ALIGN_UNIT (decl);\n+      layout_empty_base (binfo, size_int (eoc), offsets);\n     }\n \n   /* Check for inaccessible base classes.  If the same base class\n@@ -3954,33 +4066,33 @@ build_base_field (rli, binfo, empty_p, base_align, v)\n \t\tbasetype, rli->t);\n   \n   /* Record the offsets of BINFO and its base subobjects.  */\n-  record_base_offsets (binfo, v);\n+  record_subobject_offsets (BINFO_TYPE (binfo), \n+\t\t\t    BINFO_OFFSET (binfo),\n+\t\t\t    offsets, \n+\t\t\t    /*vbases_p=*/0);\n }\n \n-/* Layout all of the non-virtual base classes.  Returns a map from\n-   offsets to types present at those offsets.  */\n+/* Layout all of the non-virtual base classes.  Record empty\n+   subobjects in OFFSETS.  */\n \n-static varray_type\n-build_base_fields (rli, empty_p)\n+static void\n+build_base_fields (rli, empty_p, offsets)\n      record_layout_info rli;\n      int *empty_p;\n+     splay_tree offsets;\n {\n   /* Chain to hold all the new FIELD_DECLs which stand in for base class\n      subobjects.  */\n   tree rec = rli->t;\n   int n_baseclasses = CLASSTYPE_N_BASECLASSES (rec);\n   int i;\n-  varray_type v;\n   unsigned int base_align = 0;\n \n-  /* Create the table mapping offsets to empty base classes.  */\n-  VARRAY_TREE_INIT (v, 32, \"v\");\n-\n   /* Under the new ABI, the primary base class is always allocated\n      first.  */\n   if (flag_new_abi && CLASSTYPE_HAS_PRIMARY_BASE_P (rec))\n     build_base_field (rli, CLASSTYPE_PRIMARY_BINFO (rec), \n-\t\t      empty_p, &base_align, &v);\n+\t\t      empty_p, &base_align, offsets);\n \n   /* Now allocate the rest of the bases.  */\n   for (i = 0; i < n_baseclasses; ++i)\n@@ -4001,10 +4113,8 @@ build_base_fields (rli, empty_p)\n \t  && !BINFO_PRIMARY_MARKED_P (base_binfo))\n \tcontinue;\n \n-      build_base_field (rli, base_binfo, empty_p, &base_align, &v);\n+      build_base_field (rli, base_binfo, empty_p, &base_align, offsets);\n     }\n-\n-  return v;\n }\n \n /* Go through the TYPE_METHODS of T issuing any appropriate\n@@ -4573,13 +4683,13 @@ dfs_set_offset_for_unshared_vbases (binfo, data)\n }\n \n /* Set BINFO_OFFSET for all of the virtual bases for T.  Update\n-   TYPE_ALIGN and TYPE_SIZE for T.  BASE_OFFSETS is a varray mapping\n-   offsets to the types at those offsets.  */\n+   TYPE_ALIGN and TYPE_SIZE for T.  OFFSETS gives the location of\n+   empty subobjects of T.  */\n \n static void\n-layout_virtual_bases (t, base_offsets)\n+layout_virtual_bases (t, offsets)\n      tree t;\n-     varray_type *base_offsets;\n+     splay_tree offsets;\n {\n   tree vbases;\n   unsigned HOST_WIDE_INT dsize;\n@@ -4649,7 +4759,7 @@ layout_virtual_bases (t, base_offsets)\n \t  if (flag_new_abi && is_empty_class (basetype))\n \t    layout_empty_base (vbase,\n \t\t\t       size_int (CEIL (dsize, BITS_PER_UNIT)),\n-\t\t\t       *base_offsets);\n+\t\t\t       offsets);\n \t  else\n \t    {\n \t      tree offset;\n@@ -4669,7 +4779,10 @@ layout_virtual_bases (t, base_offsets)\n \t    }\n \n \t  /* Keep track of the offsets assigned to this virtual base.  */\n-\t  record_base_offsets (vbase, base_offsets);\n+\t  record_subobject_offsets (BINFO_TYPE (vbase), \n+\t\t\t\t    BINFO_OFFSET (vbase),\n+\t\t\t\t    offsets,\n+\t\t\t\t    /*vbases_p=*/0);\n \t}\n     }\n \n@@ -4744,6 +4857,16 @@ end_of_class (t, include_virtuals_p)\n   return result;\n }\n \n+/* Compare two INTEGER_CSTs K1 and K2.  */\n+\n+static int\n+splay_tree_compare_integer_csts (k1, k2)\n+     splay_tree_key k1;\n+     splay_tree_key k2;\n+{\n+  return tree_int_cst_compare ((tree) k1, (tree) k2);\n+}\n+\n /* Calculate the TYPE_SIZE, TYPE_ALIGN, etc for T.  Calculate\n    BINFO_OFFSETs for all of the base-classes.  Position the vtable\n    pointer.  */\n@@ -4761,8 +4884,10 @@ layout_class_type (t, empty_p, vfuns_p,\n   tree field;\n   tree vptr;\n   record_layout_info rli;\n-  varray_type v;\n   unsigned HOST_WIDE_INT eoc;\n+  /* Maps offsets (represented as INTEGER_CSTs) to a TREE_LIST of\n+     types that appear at that offset.  */\n+  splay_tree empty_base_offsets;\n \n   /* Keep track of the first non-static data member.  */\n   non_static_data_members = TYPE_FIELDS (t);\n@@ -4787,7 +4912,9 @@ layout_class_type (t, empty_p, vfuns_p,\n     }\n \n   /* Build FIELD_DECLs for all of the non-virtual base-types.  */\n-  v = build_base_fields (rli, empty_p);\n+  empty_base_offsets = splay_tree_new (splay_tree_compare_integer_csts, \n+\t\t\t\t       NULL, NULL);\n+  build_base_fields (rli, empty_p, empty_base_offsets);\n   /* Add pointers to all of our virtual base-classes.  */\n   TYPE_FIELDS (t) = chainon (build_vbase_pointer_fields (rli, empty_p),\n \t\t\t     TYPE_FIELDS (t));\n@@ -4800,7 +4927,6 @@ layout_class_type (t, empty_p, vfuns_p,\n   /* Layout the non-static data members.  */\n   for (field = non_static_data_members; field; field = TREE_CHAIN (field))\n     {\n-      tree binfo;\n       tree type;\n       tree padding;\n \n@@ -4852,10 +4978,8 @@ layout_class_type (t, empty_p, vfuns_p,\n       else\n \tpadding = NULL_TREE;\n \n-      /* Create a dummy BINFO corresponding to this field.  */\n-      binfo = make_binfo (size_zero_node, type, NULL_TREE, NULL_TREE);\n-      unshare_base_binfos (binfo);\n-      layout_nonempty_base_or_field (rli, field, binfo, v);\n+      layout_nonempty_base_or_field (rli, field, NULL_TREE,\n+\t\t\t\t     empty_base_offsets);\n \n       /* If we needed additional padding after this field, add it\n \t now.  */\n@@ -4870,7 +4994,9 @@ layout_class_type (t, empty_p, vfuns_p,\n \t  DECL_SIZE (padding_field) = padding;\n \t  DECL_ALIGN (padding_field) = 1;\n \t  DECL_USER_ALIGN (padding_field) = 0;\n-\t  layout_nonempty_base_or_field (rli, padding_field, NULL_TREE, v);\n+\t  layout_nonempty_base_or_field (rli, padding_field,\n+\t\t\t\t\t NULL_TREE, \n+\t\t\t\t\t empty_base_offsets);\n \t}\n     }\n \n@@ -4956,10 +5082,10 @@ layout_class_type (t, empty_p, vfuns_p,\n      around.  We must get these done before we try to lay out the\n      virtual function table.  As a side-effect, this will remove the\n      base subobject fields.  */\n-  layout_virtual_bases (t, &v);\n+  layout_virtual_bases (t, empty_base_offsets);\n \n   /* Clean up.  */\n-  VARRAY_FREE (v);\n+  splay_tree_delete (empty_base_offsets);\n }\n \n /* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration"}]}