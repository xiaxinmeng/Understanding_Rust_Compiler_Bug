{"sha": "a7f1b24f810a5f3312fee91a63f507da952498f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdmMWIyNGY4MTBhNWYzMzEyZmVlOTFhNjNmNTA3ZGE5NTI0OThmMw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2012-11-06T11:11:15Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-11-06T11:11:15Z"}, "message": "checks.ads, [...]: Minor changes throughout for new overflow checking.\n\n2012-11-06  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.ads, checks.adb, exp_ch4.adb: Minor changes throughout for\n\tnew overflow checking.\n\t* exp_util.adb (Insert_Actions): Remove special casing of\n\tOverflow_Check.\n\t* gnat1drv.adb (Adjust_Global_Switches): Fixes for new handling\n\tof overflow checks.\n\t* sem.adb (Analyze): Remove special casing of Overflow_Check\n\t(Analyze_List): ditto.\n\t* sem_prag.adb (Analyze_Pragma, case Overflow_Checks): Remove\n\tSUPPRESSED and change CHECKED to STRICT.\n\t* sem_res.adb (Analyze_And_Resolve): No longer treat\n\tOverflow_Check specially.\n\t(Preanalyze_And_Resolve): ditto.\n\t(Resolve): ditto.\n\t* snames.ads-tmpl: Replace Name_Checked by Name_Strict.\n\t* switch-c.adb (Get_Overflow_Mode): Eliminate 0 setting,\n\tCHECKED => STRICT.\n\t* types.ads (Overflow_Check_Type): Remove Suppressed, change\n\tChecked to Strict (Suppress_Record): Overflow check controlled\n\tby Suppress array.\n\nFrom-SVN: r193233", "tree": {"sha": "bf5fc789888a9885070c8aefd76af66e8c2fcc68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf5fc789888a9885070c8aefd76af66e8c2fcc68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7f1b24f810a5f3312fee91a63f507da952498f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7f1b24f810a5f3312fee91a63f507da952498f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7f1b24f810a5f3312fee91a63f507da952498f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7f1b24f810a5f3312fee91a63f507da952498f3/comments", "author": null, "committer": null, "parents": [{"sha": "c4ae9877307939806b3f161f55ce635002227bad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ae9877307939806b3f161f55ce635002227bad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4ae9877307939806b3f161f55ce635002227bad"}], "stats": {"total": 779, "additions": 370, "deletions": 409}, "files": [{"sha": "d2c739f4fa19e842f37c507249703e7e2e5d1e56", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a7f1b24f810a5f3312fee91a63f507da952498f3", "patch": "@@ -1,3 +1,26 @@\n+2012-11-06  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.ads, checks.adb, exp_ch4.adb: Minor changes throughout for\n+\tnew overflow checking.\n+\t* exp_util.adb (Insert_Actions): Remove special casing of\n+\tOverflow_Check.\n+\t* gnat1drv.adb (Adjust_Global_Switches): Fixes for new handling\n+\tof overflow checks.\n+\t* sem.adb (Analyze): Remove special casing of Overflow_Check\n+\t(Analyze_List): ditto.\n+\t* sem_prag.adb (Analyze_Pragma, case Overflow_Checks): Remove\n+\tSUPPRESSED and change CHECKED to STRICT.\n+\t* sem_res.adb (Analyze_And_Resolve): No longer treat\n+\tOverflow_Check specially.\n+\t(Preanalyze_And_Resolve): ditto.\n+\t(Resolve): ditto.\n+\t* snames.ads-tmpl: Replace Name_Checked by Name_Strict.\n+\t* switch-c.adb (Get_Overflow_Mode): Eliminate 0 setting,\n+\tCHECKED => STRICT.\n+\t* types.ads (Overflow_Check_Type): Remove Suppressed, change\n+\tChecked to Strict (Suppress_Record): Overflow check controlled\n+\tby Suppress array.\n+\n 2012-11-06  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_res.adb (Preanalyze_And_Resolve): In Alfa mode do not"}, {"sha": "b0262dba815de0106df131f80c9ee831acf9ba82", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 176, "deletions": 139, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=a7f1b24f810a5f3312fee91a63f507da952498f3", "patch": "@@ -194,18 +194,19 @@ package body Checks is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Apply_Arithmetic_Overflow_Checked_Suppressed (N : Node_Id);\n+   procedure Apply_Arithmetic_Overflow_Strict (N : Node_Id);\n    --  Used to apply arithmetic overflow checks for all cases except operators\n    --  on signed arithmetic types in MINIMIZED/ELIMINATED case (for which we\n-   --  call Apply_Arithmetic_Overflow_Minimized_Eliminated below). N is always\n-   --  a signed integer arithmetic operator (if and case expressions are not\n-   --  included for this case).\n+   --  call Apply_Arithmetic_Overflow_Minimized_Eliminated below). N can be a\n+   --  signed integer arithmetic operator (but not an if or case expression).\n+   --  It is also called for types other than signed integers.\n \n    procedure Apply_Arithmetic_Overflow_Minimized_Eliminated (Op : Node_Id);\n    --  Used to apply arithmetic overflow checks for the case where the overflow\n-   --  checking mode is MINIMIZED or ELIMINATED (and the Do_Overflow_Check flag\n-   --  is known to be set) and we have a signed integer arithmetic op (which\n-   --  includes the case of if and case expressions).\n+   --  checking mode is MINIMIZED or ELIMINATED and we have a signed integer\n+   --  arithmetic op (which includes the case of if and case expressions). Note\n+   --  that Do_Overflow_Check may or may not be set for node Op. In these modes\n+   --  we have work to do even if overflow checking is suppressed.\n \n    procedure Apply_Division_Check\n      (N   : Node_Id;\n@@ -766,14 +767,12 @@ package body Checks is\n    begin\n       --  Use old routine in almost all cases (the only case we are treating\n       --  specially is the case of a signed integer arithmetic op with the\n-      --  Do_Overflow_Check flag set on the node, and the overflow checking\n-      --  mode is MINIMIZED or ELIMINATED).\n+      --  overflow checking mode set to MINIMIZED or ELIMINATED).\n \n-      if Overflow_Check_Mode (Etype (N)) not in Minimized_Or_Eliminated\n-        or else not Do_Overflow_Check (N)\n+      if Overflow_Check_Mode = Strict\n         or else not Is_Signed_Integer_Arithmetic_Op (N)\n       then\n-         Apply_Arithmetic_Overflow_Checked_Suppressed (N);\n+         Apply_Arithmetic_Overflow_Strict (N);\n \n       --  Otherwise use the new routine for the case of a signed integer\n       --  arithmetic op, with Do_Overflow_Check set to True, and the checking\n@@ -784,9 +783,9 @@ package body Checks is\n       end if;\n    end Apply_Arithmetic_Overflow_Check;\n \n-   --------------------------------------------------\n-   -- Apply_Arithmetic_Overflow_Checked_Suppressed --\n-   --------------------------------------------------\n+   --------------------------------------\n+   -- Apply_Arithmetic_Overflow_Strict --\n+   --------------------------------------\n \n    --  This routine is called only if the type is an integer type, and a\n    --  software arithmetic overflow check may be needed for op (add, subtract,\n@@ -795,21 +794,28 @@ package body Checks is\n    --  operation into a more complex sequence of tests that ensures that\n    --  overflow is properly caught.\n \n-   --  This is used in SUPPRESSED/CHECKED modes. It is identical to the\n-   --  code for these cases before the big overflow earthquake, thus ensuring\n-   --  that in these modes we have compatible behavior (and reliability) to\n-   --  what was there before. It is also called for types other than signed\n-   --  integers, and if the Do_Overflow_Check flag is off.\n+   --  This is used in CHECKED modes. It is identical to the code for this\n+   --  cases before the big overflow earthquake, thus ensuring that in this\n+   --  modes we have compatible behavior (and reliability) to what was there\n+   --  before. It is also called for types other than signed integers, and if\n+   --  the Do_Overflow_Check flag is off.\n \n    --  Note: we also call this routine if we decide in the MINIMIZED case\n    --  to give up and just generate an overflow check without any fuss.\n \n-   procedure Apply_Arithmetic_Overflow_Checked_Suppressed (N : Node_Id) is\n+   procedure Apply_Arithmetic_Overflow_Strict (N : Node_Id) is\n       Loc  : constant Source_Ptr := Sloc (N);\n       Typ  : constant Entity_Id  := Etype (N);\n       Rtyp : constant Entity_Id  := Root_Type (Typ);\n \n    begin\n+      --  Nothing to do if Do_Overflow_Check not set or overflow checks\n+      --  suppressed.\n+\n+      if not Do_Overflow_Check (N) then\n+         return;\n+      end if;\n+\n       --  An interesting special case. If the arithmetic operation appears as\n       --  the operand of a type conversion:\n \n@@ -1067,15 +1073,14 @@ package body Checks is\n          when RE_Not_Available =>\n             return;\n       end;\n-   end Apply_Arithmetic_Overflow_Checked_Suppressed;\n+   end Apply_Arithmetic_Overflow_Strict;\n \n    ----------------------------------------------------\n    -- Apply_Arithmetic_Overflow_Minimized_Eliminated --\n    ----------------------------------------------------\n \n    procedure Apply_Arithmetic_Overflow_Minimized_Eliminated (Op : Node_Id) is\n       pragma Assert (Is_Signed_Integer_Arithmetic_Op (Op));\n-      pragma Assert (Do_Overflow_Check (Op));\n \n       Loc : constant Source_Ptr := Sloc (Op);\n       P   : constant Node_Id    := Parent (Op);\n@@ -1086,8 +1091,7 @@ package body Checks is\n       Result_Type : constant Entity_Id := Etype (Op);\n       --  Original result type\n \n-      Check_Mode : constant Overflow_Check_Type :=\n-                     Overflow_Check_Mode (Etype (Op));\n+      Check_Mode : constant Overflow_Check_Type := Overflow_Check_Mode;\n       pragma Assert (Check_Mode in Minimized_Or_Eliminated);\n \n       Lo, Hi : Uint;\n@@ -1102,7 +1106,7 @@ package body Checks is\n \n       --  In all these cases, we will process at the higher level (and then\n       --  this node will be processed during the downwards recursion that\n-      --  is part of the processing in Minimize_Eliminate_Overflow_Checks).\n+      --  is part of the processing in Minimize_Eliminate_Overflows).\n \n       if Is_Signed_Integer_Arithmetic_Op (P)\n         or else Nkind (P) in N_Membership_Test\n@@ -1127,7 +1131,7 @@ package body Checks is\n       --  will still be in Bignum mode if either of its operands are of type\n       --  Bignum).\n \n-      Minimize_Eliminate_Overflow_Checks (Op, Lo, Hi, Top_Level => True);\n+      Minimize_Eliminate_Overflows (Op, Lo, Hi, Top_Level => True);\n \n       --  That call may but does not necessarily change the result type of Op.\n       --  It is the job of this routine to undo such changes, so that at the\n@@ -1213,7 +1217,7 @@ package body Checks is\n \n       --  Here we know the result is Long_Long_Integer'Base, of that it has\n       --  been rewritten because the parent operation is a conversion. See\n-      --  Apply_Arithmetic_Overflow_Checked_Suppressed.Conversion_Optimization.\n+      --  Apply_Arithmetic_Overflow_Strict.Conversion_Optimization.\n \n       else\n          pragma Assert\n@@ -1678,7 +1682,7 @@ package body Checks is\n       Left  : constant Node_Id    := Left_Opnd (N);\n       Right : constant Node_Id    := Right_Opnd (N);\n \n-      Mode : constant Overflow_Check_Type := Overflow_Check_Mode (Typ);\n+      Mode : constant Overflow_Check_Type := Overflow_Check_Mode;\n       --  Current overflow checking mode\n \n       LLB : Uint;\n@@ -1693,15 +1697,13 @@ package body Checks is\n       --  Don't actually use this value\n \n    begin\n-      --  If we are operating in MINIMIZED or ELIMINATED mode, and the\n-      --  Do_Overflow_Check flag is set and we are operating on signed\n-      --  integer types, then the only thing this routine does is to call\n-      --  Apply_Arithmetic_Overflow_Minimized_Eliminated. That procedure will\n-      --  (possibly later on during recursive downward calls), make sure that\n-      --  any needed overflow and division checks are properly applied.\n+      --  If we are operating in MINIMIZED or ELIMINATED mode, and we are\n+      --  operating on signed integer types, then the only thing this routine\n+      --  does is to call Apply_Arithmetic_Overflow_Minimized_Eliminated. That\n+      --  procedure will (possibly later on during recursive downward calls),\n+      --  ensure that any needed overflow/division checks are properly applied.\n \n       if Mode in Minimized_Or_Eliminated\n-        and then Do_Overflow_Check (N)\n         and then Is_Signed_Integer_Type (Typ)\n       then\n          Apply_Arithmetic_Overflow_Minimized_Eliminated (N);\n@@ -1726,7 +1728,9 @@ package body Checks is\n \n          --  Deal with overflow check\n \n-         if Do_Overflow_Check (N) and then Mode /= Suppressed then\n+         if Do_Overflow_Check (N)\n+           and then not Overflow_Checks_Suppressed (Etype (N))\n+         then\n \n             --  Test for extremely annoying case of xxx'First divided by -1\n             --  for division of signed integer types (only overflow case).\n@@ -3093,6 +3097,7 @@ package body Checks is\n \n          begin\n             if not Overflow_Checks_Suppressed (Target_Base)\n+              and then not Overflow_Checks_Suppressed (Target_Type)\n               and then not\n                 In_Subrange_Of (Expr_Type, Target_Base, Fixed_Int => Conv_OK)\n               and then not Float_To_Int\n@@ -4420,7 +4425,7 @@ package body Checks is\n \n    procedure Enable_Overflow_Check (N : Node_Id) is\n       Typ  : constant Entity_Id           := Base_Type (Etype (N));\n-      Mode : constant Overflow_Check_Type := Overflow_Check_Mode (Etype (N));\n+      Mode : constant Overflow_Check_Type := Overflow_Check_Mode;\n       Chk  : Nat;\n       OK   : Boolean;\n       Ent  : Entity_Id;\n@@ -4438,7 +4443,7 @@ package body Checks is\n \n       --  No check if overflow checks suppressed for type of node\n \n-      if Mode = Suppressed then\n+      if Overflow_Checks_Suppressed (Etype (N)) then\n          return;\n \n       --  Nothing to do for unsigned integer types, which do not overflow\n@@ -4447,23 +4452,28 @@ package body Checks is\n          return;\n       end if;\n \n-      --  This is the point at which processing for CHECKED mode diverges\n+      --  This is the point at which processing for STRICT mode diverges\n       --  from processing for MINIMIZED/ELIMINATED modes. This divergence is\n       --  probably more extreme that it needs to be, but what is going on here\n       --  is that when we introduced MINIMIZED/ELIMINATED modes, we wanted\n-      --  to leave the processing for CHECKED mode untouched. There were\n+      --  to leave the processing for STRICT mode untouched. There were\n       --  two reasons for this. First it avoided any incompatible change of\n-      --  behavior. Second, it guaranteed that CHECKED mode continued to be\n+      --  behavior. Second, it guaranteed that STRICT mode continued to be\n       --  legacy reliable.\n \n-      --  The big difference is that in CHECKED mode there is a fair amount of\n+      --  The big difference is that in STRICT mode there is a fair amount of\n       --  circuitry to try to avoid setting the Do_Overflow_Check flag if we\n       --  know that no check is needed. We skip all that in the two new modes,\n       --  since really overflow checking happens over a whole subtree, and we\n       --  do the corresponding optimizations later on when applying the checks.\n \n       if Mode in Minimized_Or_Eliminated then\n-         Activate_Overflow_Check (N);\n+         if not (Overflow_Checks_Suppressed (Etype (N)))\n+           and then not (Is_Entity_Name (N)\n+                          and then Overflow_Checks_Suppressed (Entity (N)))\n+         then\n+            Activate_Overflow_Check (N);\n+         end if;\n \n          if Debug_Flag_CC then\n             w (\"Minimized/Eliminated mode\");\n@@ -4472,7 +4482,7 @@ package body Checks is\n          return;\n       end if;\n \n-      --  Remainder of processing is for Checked case, and is unchanged from\n+      --  Remainder of processing is for STRICT case, and is unchanged from\n       --  earlier versions preceding the addition of MINIMIZED/ELIMINATED.\n \n       --  Nothing to do if the range of the result is known OK. We skip this\n@@ -6685,9 +6695,9 @@ package body Checks is\n                     New_Reference_To (M, Loc))))));\n    end Make_Bignum_Block;\n \n-   ----------------------------------------\n-   -- Minimize_Eliminate_Overflow_Checks --\n-   ----------------------------------------\n+   ----------------------------------\n+   -- Minimize_Eliminate_Overflows --\n+   ----------------------------------\n \n    --  This is a recursive routine that is called at the top of an expression\n    --  tree to properly process overflow checking for a whole subtree by making\n@@ -6697,14 +6707,13 @@ package body Checks is\n    --  it would interfere with semantic analysis).\n \n    --  What happens is that if MINIMIZED/ELIMINATED mode is in effect then\n-   --  the operator expansion routines, as well as the expansion routines\n-   --  for if/case expression test the Do_Overflow_Check flag and if it is\n-   --  set they (for the moment) do nothing except call the routine to apply\n-   --  the overflow check (Apply_Arithmetic_Overflow_Check). That routine\n-   --  does nothing for non top-level nodes, so at the point where the call\n-   --  is made for the top level node, the entire expression subtree has not\n-   --  been expanded, or processed for overflow. All that has to happen as a\n-   --  result of the top level call to this routine.\n+   --  the operator expansion routines, as well as the expansion routines for\n+   --  if/case expression, do nothing (for the moment) except call the routine\n+   --  to apply the overflow check (Apply_Arithmetic_Overflow_Check). That\n+   --  routine does nothing for non top-level nodes, so at the point where the\n+   --  call is made for the top level node, the entire expression subtree has\n+   --  not been expanded, or processed for overflow. All that has to happen as\n+   --  a result of the top level call to this routine.\n \n    --  As noted above, the overflow processing works by making recursive calls\n    --  for the operands, and figuring out what to do, based on the processing\n@@ -6716,11 +6725,10 @@ package body Checks is\n    --  the node (if it has been modified by the overflow check processing). The\n    --  Analyzed_Flag is set to False before the reexpand/reanalyze. To avoid\n    --  a recursive call into the whole overflow apparatus, an important rule\n-   --  for this call is that either Do_Overflow_Check must be False, or if\n-   --  it is set, then the overflow checking mode must be temporarily set\n-   --  to CHECKED/SUPPRESSED. Either step will avoid the unwanted recursion.\n+   --  for this call is that the overflow handling mode must be temporarily set\n+   --  to STRICT.\n \n-   procedure Minimize_Eliminate_Overflow_Checks\n+   procedure Minimize_Eliminate_Overflows\n      (N         : Node_Id;\n       Lo        : out Uint;\n       Hi        : out Uint;\n@@ -6730,7 +6738,7 @@ package body Checks is\n       pragma Assert (Is_Signed_Integer_Type (Rtyp));\n       --  Result type, must be a signed integer type\n \n-      Check_Mode : constant Overflow_Check_Type := Overflow_Check_Mode (Empty);\n+      Check_Mode : constant Overflow_Check_Type := Overflow_Check_Mode;\n       pragma Assert (Check_Mode in Minimized_Or_Eliminated);\n \n       Loc : constant Source_Ptr := Sloc (N);\n@@ -6764,18 +6772,24 @@ package body Checks is\n       --  Set True if one or more operands is already of type Long_Long_Integer\n       --  which means that if the result is known to be in the result type\n       --  range, then we must convert such operands back to the result type.\n-      --  This switch is properly set only when Bignum_Operands is False.\n-\n-      procedure Reexpand (C : Suppressed_Or_Checked);\n-      --  This is called when we have not modified the node, so we do not need\n-      --  to reanalyze it. But we do want to reexpand it in either SUPPRESSED\n-      --  or CHECKED mode (as indicated by the argument C) to get proper\n-      --  expansion. It is important that we reset the mode to SUPPRESSED or\n-      --  CHECKED, since if we leave it in MINIMIZED or ELIMINATED mode we\n-      --  would reenter this routine recursively which would not be good!\n-      --  Note that this is not just an optimization, testing has showed up\n-      --  several complex cases in which reanalyzing an already analyzed node\n-      --  causes incorrect behavior.\n+\n+      procedure Reanalyze (Typ : Entity_Id; Suppress : Boolean := False);\n+      --  This is called when we have modified the node and we therefore need\n+      --  to reanalyze it. It is important that we reset the mode to STRICT for\n+      --  this reanalysis, since if we leave it in MINIMIZED or ELIMINATED mode\n+      --  we would reenter this routine recursively which would not be good!\n+      --  The argument Suppress is set True if we also want to suppress\n+      --  overflow checking for the reexpansion (this is set when we know\n+      --  overflow is not possible). Typ is the type for the reanalysis.\n+\n+      procedure Reexpand (Suppress : Boolean := False);\n+      --  This is like Reanalyze, but does not do the Analyze step, it only\n+      --  does a reexpansion. We do this reexpansion in STRICT mode, so that\n+      --  instead of reentering the MINIMIZED/ELIMINATED mode processing, we\n+      --  follow the normal expansion path (e.g. converting A**4 to A**2**2).\n+      --  Note that skipping reanalysis is not just an optimization, testing\n+      --  has showed up several complex cases in which reanalyzing an already\n+      --  analyzed node causes incorrect behavior.\n \n       function In_Result_Range return Boolean;\n       --  Returns True iff Lo .. Hi are within range of the result type\n@@ -6829,25 +6843,62 @@ package body Checks is\n          end if;\n       end Min;\n \n+      ---------------\n+      -- Reanalyze --\n+      ---------------\n+\n+      procedure Reanalyze (Typ : Entity_Id; Suppress : Boolean := False) is\n+         Svg : constant Overflow_Check_Type :=\n+                 Scope_Suppress.Overflow_Checks_General;\n+         Sva : constant Overflow_Check_Type :=\n+                 Scope_Suppress.Overflow_Checks_Assertions;\n+         Svo : constant Boolean             :=\n+                 Scope_Suppress.Suppress (Overflow_Check);\n+\n+      begin\n+         Scope_Suppress.Overflow_Checks_General    := Strict;\n+         Scope_Suppress.Overflow_Checks_Assertions := Strict;\n+\n+         if Suppress then\n+            Scope_Suppress.Suppress (Overflow_Check) := True;\n+         end if;\n+\n+         Analyze_And_Resolve (N, Typ);\n+\n+         Scope_Suppress.Suppress (Overflow_Check)  := Svo;\n+         Scope_Suppress.Overflow_Checks_General    := Svg;\n+         Scope_Suppress.Overflow_Checks_Assertions := Sva;\n+      end Reanalyze;\n+\n       --------------\n       -- Reexpand --\n       --------------\n \n-      procedure Reexpand (C : Suppressed_Or_Checked) is\n+      procedure Reexpand (Suppress : Boolean := False) is\n          Svg : constant Overflow_Check_Type :=\n                  Scope_Suppress.Overflow_Checks_General;\n          Sva : constant Overflow_Check_Type :=\n                  Scope_Suppress.Overflow_Checks_Assertions;\n+         Svo : constant Boolean             :=\n+                 Scope_Suppress.Suppress (Overflow_Check);\n+\n       begin\n-         Scope_Suppress.Overflow_Checks_General    := C;\n-         Scope_Suppress.Overflow_Checks_Assertions := C;\n+         Scope_Suppress.Overflow_Checks_General    := Strict;\n+         Scope_Suppress.Overflow_Checks_Assertions := Strict;\n          Set_Analyzed (N, False);\n+\n+         if Suppress then\n+            Scope_Suppress.Suppress (Overflow_Check) := True;\n+         end if;\n+\n          Expand (N);\n+\n+         Scope_Suppress.Suppress (Overflow_Check)  := Svo;\n          Scope_Suppress.Overflow_Checks_General    := Svg;\n          Scope_Suppress.Overflow_Checks_Assertions := Sva;\n       end Reexpand;\n \n-   --  Start of processing for Minimize_Eliminate_Overflow_Checks\n+   --  Start of processing for Minimize_Eliminate_Overflows\n \n    begin\n       --  Case where we do not have a signed integer arithmetic operation\n@@ -6884,14 +6935,14 @@ package body Checks is\n          begin\n             Bignum_Operands := False;\n \n-            Minimize_Eliminate_Overflow_Checks\n+            Minimize_Eliminate_Overflows\n               (Then_DE, Lo, Hi, Top_Level => False);\n \n             if Lo = No_Uint then\n                Bignum_Operands := True;\n             end if;\n \n-            Minimize_Eliminate_Overflow_Checks\n+            Minimize_Eliminate_Overflows\n               (Else_DE, Rlo, Rhi, Top_Level => False);\n \n             if Rlo = No_Uint then\n@@ -6918,8 +6969,7 @@ package body Checks is\n                      Convert_To_Bignum (Else_DE)),\n                    Is_Elsif    => Is_Elsif (N)));\n \n-               Analyze_And_Resolve\n-                 (N, RTE (RE_Bignum), Suppress => Overflow_Check);\n+               Reanalyze (RTE (RE_Bignum), Suppress => True);\n \n             --  If we have no Long_Long_Integer operands, then we are in result\n             --  range, since it means that none of our operands felt the need\n@@ -6930,7 +6980,7 @@ package body Checks is\n \n             elsif not Long_Long_Integer_Operands then\n                Set_Do_Overflow_Check (N, False);\n-               Reexpand (Suppressed);\n+               Reexpand;\n \n             --  Otherwise convert us to long long integer mode. Note that we\n             --  don't need any further overflow checking at this level.\n@@ -6943,8 +6993,7 @@ package body Checks is\n                --  Now reanalyze with overflow checks off\n \n                Set_Do_Overflow_Check (N, False);\n-               Set_Analyzed (N, False);\n-               Analyze_And_Resolve (N, LLIB, Suppress => Overflow_Check);\n+               Reanalyze (LLIB, Suppress => True);\n             end if;\n          end;\n \n@@ -6968,7 +7017,7 @@ package body Checks is\n                   Aexp : constant Node_Id := Expression (Alt);\n \n                begin\n-                  Minimize_Eliminate_Overflow_Checks\n+                  Minimize_Eliminate_Overflows\n                     (Aexp, Lo, Hi, Top_Level => False);\n \n                   if Lo = No_Uint then\n@@ -6991,7 +7040,7 @@ package body Checks is\n \n             if not (Bignum_Operands or Long_Long_Integer_Operands) then\n                Set_Do_Overflow_Check (N, False);\n-               Reexpand (Suppressed);\n+               Reexpand (Suppress => True);\n \n             --  Otherwise we are going to rebuild the case expression using\n             --  either bignum or long long integer operands throughout.\n@@ -7028,7 +7077,7 @@ package body Checks is\n                       Expression   => Expression (N),\n                       Alternatives => New_Alts));\n \n-                  Analyze_And_Resolve (N, Rtype, Suppress => Overflow_Check);\n+                  Reanalyze (Rtype, Suppress => True);\n                end;\n             end if;\n          end;\n@@ -7040,11 +7089,11 @@ package body Checks is\n       --  operands to get the ranges (and to properly process the subtree\n       --  that lies below us!)\n \n-      Minimize_Eliminate_Overflow_Checks\n+      Minimize_Eliminate_Overflows\n         (Right_Opnd (N), Rlo, Rhi, Top_Level => False);\n \n       if Binary then\n-         Minimize_Eliminate_Overflow_Checks\n+         Minimize_Eliminate_Overflows\n            (Left_Opnd (N), Llo, Lhi, Top_Level => False);\n       end if;\n \n@@ -7356,7 +7405,7 @@ package body Checks is\n         and then In_Result_Range\n       then\n          Set_Do_Overflow_Check (N, False);\n-         Reexpand (Suppressed);\n+         Reexpand (Suppress => True);\n          return;\n \n       --  Here we know that we are not in the result range, and in the general\n@@ -7380,22 +7429,17 @@ package body Checks is\n \n         and then Nkind (Parent (N)) /= N_Type_Conversion\n       then\n-         --  Here we will keep the original types, but we do need an overflow\n-         --  check, so we will set Do_Overflow_Check to True (actually it is\n-         --  true already, or how would we have got here?).\n-\n-         pragma Assert (Do_Overflow_Check (N));\n-         Set_Analyzed (N, False);\n+         --  Here keep original types, but we need to complete analysis\n \n          --  One subtlety. We can't just go ahead and do an analyze operation\n          --  here because it will cause recursion into the whole MINIMIZED/\n          --  ELIMINATED overflow processing which is not what we want. Here\n          --  we are at the top level, and we need a check against the result\n-         --  mode (i.e. we want to use Checked mode). So do exactly that!\n+         --  mode (i.e. we want to use STRICT mode). So do exactly that!\n          --  Also, we have not modified the node, so this is a case where\n          --  we need to reexpand, but not reanalyze.\n \n-         Reexpand (Checked);\n+         Reexpand;\n          return;\n \n       --  Cases where we do the operation in Bignum mode. This happens either\n@@ -7421,17 +7465,18 @@ package body Checks is\n          --  set True). In this case, there is no point in moving into Bignum\n          --  mode to prevent overflow if the caller will immediately convert\n          --  the Bignum value back to LLI with an overflow check. It's more\n-         --  efficient to stay in LLI mode with an overflow check.\n+         --  efficient to stay in LLI mode with an overflow check (if needed)\n \n          if Check_Mode = Minimized\n            or else (Top_Level and not Bignum_Operands)\n          then\n-            Enable_Overflow_Check (N);\n+            if Do_Overflow_Check (N) then\n+               Enable_Overflow_Check (N);\n+            end if;\n \n-            --  Since we are doing an overflow check, the result has to be in\n-            --  Long_Long_Integer mode, so adjust the possible range to reflect\n-            --  this. Note these calls also change No_Uint values from the top\n-            --  level case to LLI bounds.\n+            --  The result now has to be in Long_Long_Integer mode, so adjust\n+            --  the possible range to reflect this. Note these calls also\n+            --  change No_Uint values from the top level case to LLI bounds.\n \n             Max (Lo, LLLo);\n             Min (Hi, LLHi);\n@@ -7500,7 +7545,7 @@ package body Checks is\n                  Make_Function_Call (Loc,\n                    Name                   => New_Occurrence_Of (Fent, Loc),\n                    Parameter_Associations => Args));\n-               Analyze_And_Resolve (N, RTE (RE_Bignum));\n+               Reanalyze (RTE (RE_Bignum), Suppress => True);\n \n                --  Indicate result is Bignum mode\n \n@@ -7557,48 +7602,36 @@ package body Checks is\n       --  we will complete any division checks (since we have not changed the\n       --  setting of the Do_Division_Check flag).\n \n-      --  If no overflow check, suppress overflow check to avoid an infinite\n-      --  recursion into this procedure.\n+      --  We do this reanalysis in STRICT mode to avoid recursion into the\n+      --  MINIMIZED/ELIMINATED handling, since we are now done with that!\n \n-      if not Do_Overflow_Check (N) then\n-         Analyze_And_Resolve (N, LLIB, Suppress => Overflow_Check);\n+      declare\n+         SG : constant Overflow_Check_Type :=\n+                Scope_Suppress.Overflow_Checks_General;\n+         SA : constant Overflow_Check_Type :=\n+                Scope_Suppress.Overflow_Checks_Assertions;\n \n-      --  If an overflow check is required, do it in normal CHECKED mode.\n-      --  That avoids an infinite recursion, making sure we get a normal\n-      --  overflow check.\n+      begin\n+         Scope_Suppress.Overflow_Checks_General    := Strict;\n+         Scope_Suppress.Overflow_Checks_Assertions := Strict;\n \n-      else\n-         declare\n-            SG : constant Overflow_Check_Type :=\n-                   Scope_Suppress.Overflow_Checks_General;\n-            SA : constant Overflow_Check_Type :=\n-                   Scope_Suppress.Overflow_Checks_Assertions;\n-         begin\n-            Scope_Suppress.Overflow_Checks_General    := Checked;\n-            Scope_Suppress.Overflow_Checks_Assertions := Checked;\n-            Analyze_And_Resolve (N, LLIB);\n-            Scope_Suppress.Overflow_Checks_General    := SG;\n-            Scope_Suppress.Overflow_Checks_Assertions := SA;\n-         end;\n-      end if;\n-   end Minimize_Eliminate_Overflow_Checks;\n+         if not Do_Overflow_Check (N) then\n+            Reanalyze (LLIB, Suppress => True);\n+         else\n+            Reanalyze (LLIB);\n+         end if;\n+\n+         Scope_Suppress.Overflow_Checks_General    := SG;\n+         Scope_Suppress.Overflow_Checks_Assertions := SA;\n+      end;\n+   end Minimize_Eliminate_Overflows;\n \n    -------------------------\n    -- Overflow_Check_Mode --\n    -------------------------\n \n-   function Overflow_Check_Mode (E : Entity_Id) return Overflow_Check_Type is\n+   function Overflow_Check_Mode return Overflow_Check_Type is\n    begin\n-      --  Check overflow suppressed on entity\n-\n-      if Present (E) and then Checks_May_Be_Suppressed (E) then\n-         if Is_Check_Suppressed (E, Overflow_Check) then\n-            return Suppressed;\n-         end if;\n-      end if;\n-\n-      --  Else return appropriate scope setting\n-\n       if In_Assertion_Expr = 0 then\n          return Scope_Suppress.Overflow_Checks_General;\n       else\n@@ -7612,7 +7645,11 @@ package body Checks is\n \n    function Overflow_Checks_Suppressed (E : Entity_Id) return Boolean is\n    begin\n-      return Overflow_Check_Mode (E) = Suppressed;\n+      if Present (E) and then Checks_May_Be_Suppressed (E) then\n+         return Is_Check_Suppressed (E, Overflow_Check);\n+      else\n+         return Scope_Suppress.Suppress (Overflow_Check);\n+      end if;\n    end Overflow_Checks_Suppressed;\n \n    -----------------------------"}, {"sha": "f2919e2ad6018529eda90367b369844f510c3a39", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=a7f1b24f810a5f3312fee91a63f507da952498f3", "patch": "@@ -72,12 +72,11 @@ package Checks is\n    --  determine whether check C is suppressed either on the entity E or\n    --  as the result of a scope suppress pragma. If Checks_May_Be_Suppressed\n    --  is False, then the status of the check can be determined simply by\n-   --  examining Scope_Checks (C), so this routine is not called in that case.\n+   --  examining Scope_Suppress, so this routine is not called in that case.\n \n-   function Overflow_Check_Mode (E : Entity_Id) return Overflow_Check_Type;\n+   function Overflow_Check_Mode return Overflow_Check_Type;\n    --  Returns current overflow checking mode, taking into account whether\n-   --  we are inside an assertion expression. Always returns Suppressed if\n-   --  overflow checks are suppressed for entity E.\n+   --  we are inside an assertion expression.\n \n    -------------------------------------------\n    -- Procedures to Activate Checking Flags --\n@@ -142,7 +141,10 @@ package Checks is\n    --  overflow checking for dependent expressions. This routine handles\n    --  front end vs back end overflow checks (in the front end case it expands\n    --  the necessary check). Note that divide is handled separately using\n-   --  Apply_Divide_Checks.\n+   --  Apply_Divide_Checks. Node N may or may not have Do_Overflow_Check.\n+   --  In STRICT mode, there is nothing to do if this flag is off, but in\n+   --  MINIMIZED/ELIMINATED mode we still have to deal with possible use\n+   --  of doing operations in Long_Long_Integer or Bignum mode.\n \n    procedure Apply_Constraint_Check\n      (N          : Node_Id;\n@@ -266,15 +268,16 @@ package Checks is\n    --  Insert_Action of the whole block (it is returned unanalyzed). The Loc\n    --  parameter is used to supply Sloc values for the constructed tree.\n \n-   procedure Minimize_Eliminate_Overflow_Checks\n+   procedure Minimize_Eliminate_Overflows\n      (N         : Node_Id;\n       Lo        : out Uint;\n       Hi        : out Uint;\n       Top_Level : Boolean);\n    --  This is the main routine for handling MINIMIZED and ELIMINATED overflow\n-   --  checks. On entry N is a node whose result is a signed integer subtype.\n-   --  If the node is an arithmetic operation, then a range analysis is carried\n-   --  out, and there are three possibilities:\n+   --  processing. On entry N is a node whose result is a signed integer\n+   --  subtype. The Do_Overflow_Check flag may or may not be set on N. If the\n+   --  node is an arithmetic operation, then a range analysis is carried out,\n+   --  and there are three possibilities:\n    --\n    --    The node is left unchanged (apart from expansion of an exponentiation\n    --    operation). This happens if the routine can determine that the result\n@@ -313,16 +316,16 @@ package Checks is\n    --  The routine is called in three situations if we are operating in either\n    --  MINIMIZED or ELIMINATED modes.\n    --\n-   --    Overflow checks applied to the top node of an expression tree when\n+   --    Overflow processing applied to the top node of an expression tree when\n    --    that node is an arithmetic operator. In this case the result is\n    --    converted to the appropriate result type (there is special processing\n    --    when the parent is a conversion, see body for details).\n    --\n-   --    Overflow checks are applied to the operands of a comparison operation.\n+   --    Overflow processing applied to the operands of a comparison operation.\n    --    In this case, the comparison is done on the result Long_Long_Integer\n    --    or Bignum values, without raising any exceptions.\n    --\n-   --    Overflow checks are applied to the left operand of a membership test.\n+   --    Overflow processing applied to the left operand of a membership test.\n    --    In this case no exception is raised if a Long_Long_Integer or Bignum\n    --    result is outside the range of the type of that left operand (it is\n    --    just that the result of IN is false in that case).\n@@ -332,13 +335,13 @@ package Checks is\n    --\n    --  Top_Level is used to avoid inefficient unnecessary transitions into the\n    --  Bignum domain. If Top_Level is True, it means that the caller will have\n-   --  to convert any Bignum value back to Long_Long_Integer, checking that the\n-   --  value is in range. This is the normal case for a top level operator in\n-   --  a subexpression. There is no point in going into Bignum mode to avoid an\n-   --  overflow just so we can check for overflow the next moment. For calls\n-   --  from comparisons and membership tests, and for all recursive calls, we\n-   --  do want to transition into the Bignum domain if necessary. Note that\n-   --  this setting is only relevant in ELIMINATED mode.\n+   --  to convert any Bignum value back to Long_Long_Integer, possibly checking\n+   --  that the value is in range. This is the normal case for a top level\n+   --  operator in a subexpression. There is no point in going into Bignum mode\n+   --  to avoid an overflow just so we can check for overflow the next moment.\n+   --  For calls from comparisons and membership tests, and for all recursive\n+   --  calls, we do want to transition into the Bignum domain if necessary.\n+   --  Note that this setting is only relevant in ELIMINATED mode.\n \n    -------------------------------------------------------\n    -- Control and Optimization of Range/Overflow Checks --\n@@ -370,9 +373,7 @@ package Checks is\n    --  has no effect. If a check is needed then this routine sets the flag\n    --  Do_Overflow_Check in node N to True, unless it can be determined that\n    --  the check is not needed. The only condition under which this is the\n-   --  case is if there was an identical check earlier on. These optimziations\n-   --  apply to CHECKED mode, but not to MINIMIZED/ELIMINATED modes. See the\n-   --  body for a full explanation.\n+   --  case is if there was an identical check earlier on.\n \n    procedure Enable_Range_Check (N : Node_Id);\n    --  Set Do_Range_Check flag in node N True, unless it can be determined"}, {"sha": "f62d70d1fca901c6198b07e626f21dc893794a09", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=a7f1b24f810a5f3312fee91a63f507da952498f3", "patch": "@@ -213,19 +213,19 @@ package body Exp_Ch4 is\n    --  Convert_To_Actual_Subtype if necessary).\n \n    function Minimized_Eliminated_Overflow_Check (N : Node_Id) return Boolean;\n-   --  For signed arithmetic operations with Do_Overflow_Check set when the\n-   --  current overflow mode is MINIMIZED or ELIMINATED, we need to make a\n-   --  call to Apply_Arithmetic_Overflow_Checks as the first thing we do. We\n-   --  then return. We count on the recursive apparatus for overflow checks\n-   --  to call us back with an equivalent operation that does not have the\n-   --  Do_Overflow_Check flag set, and that is when we will proceed with the\n-   --  expansion of the operator (e.g. converting X+0 to X, or X**2 to X*X).\n-   --  We cannot do these optimizations without first making this check, since\n-   --  there may be operands further down the tree that are relying on the\n-   --  recursive calls triggered by the top level nodes to properly process\n-   --  overflow checking and remaining expansion on these nodes. Note that\n-   --  this call back may be skipped if the operation is done in Bignum mode\n-   --  but that's fine, since the Bignum call takes care of everything.\n+   --  For signed arithmetic operations when the current overflow mode is\n+   --  MINIMIZED or ELIMINATED, we must call Apply_Arithmetic_Overflow_Checks\n+   --  as the first thing we do. We then return. We count on the recursive\n+   --  apparatus for overflow checks to call us back with an equivalent\n+   --  operation that is in CHECKED mode, avoiding a recursive entry into this\n+   --  routine, and that is when we will proceed with the expansion of the\n+   --  operator (e.g. converting X+0 to X, or X**2 to X*X). We cannot do\n+   --  these optimizations without first making this check, since there may be\n+   --  operands further down the tree that are relying on the recursive calls\n+   --  triggered by the top level nodes to properly process overflow checking\n+   --  and remaining expansion on these nodes. Note that this call back may be\n+   --  skipped if the operation is done in Bignum mode but that's fine, since\n+   --  the Bignum call takes care of everything.\n \n    procedure Optimize_Length_Comparison (N : Node_Id);\n    --  Given an expression, if it is of the form X'Length op N (or the other\n@@ -2274,8 +2274,8 @@ package body Exp_Ch4 is\n       LLIB : constant Entity_Id := Base_Type (Standard_Long_Long_Integer);\n       --  Entity for Long_Long_Integer'Base\n \n-      Check : constant Overflow_Check_Type := Overflow_Check_Mode (Empty);\n-      --  Current checking mode\n+      Check : constant Overflow_Check_Type := Overflow_Check_Mode;\n+      --  Current overflow checking mode\n \n       procedure Set_True;\n       procedure Set_False;\n@@ -2320,9 +2320,9 @@ package body Exp_Ch4 is\n       --  our operands using the Minimize_Eliminate circuitry which applies\n       --  this processing to the two operand subtrees.\n \n-      Minimize_Eliminate_Overflow_Checks\n+      Minimize_Eliminate_Overflows\n         (Left_Opnd (N),  Llo, Lhi, Top_Level => False);\n-      Minimize_Eliminate_Overflow_Checks\n+      Minimize_Eliminate_Overflows\n         (Right_Opnd (N), Rlo, Rhi, Top_Level => False);\n \n       --  See if the range information decides the result of the comparison.\n@@ -3721,7 +3721,7 @@ package body Exp_Ch4 is\n       --  Entity for Long_Long_Integer'Base (Standard should export this???)\n \n    begin\n-      Minimize_Eliminate_Overflow_Checks (Lop, Lo, Hi, Top_Level => False);\n+      Minimize_Eliminate_Overflows (Lop, Lo, Hi, Top_Level => False);\n \n       --  If right operand is a subtype name, and the subtype name has no\n       --  predicate, then we can just replace the right operand with an\n@@ -3751,9 +3751,9 @@ package body Exp_Ch4 is\n       --  have not been processed for minimized or eliminated checks.\n \n       if Nkind (Rop) = N_Range then\n-         Minimize_Eliminate_Overflow_Checks\n+         Minimize_Eliminate_Overflows\n            (Low_Bound (Rop), Lo, Hi, Top_Level => False);\n-         Minimize_Eliminate_Overflow_Checks\n+         Minimize_Eliminate_Overflows\n            (High_Bound (Rop), Lo, Hi, Top_Level => False);\n \n          --  We have A in B .. C, treated as  A >= B and then A <= C\n@@ -5498,7 +5498,7 @@ package body Exp_Ch4 is\n          --  in which case, this usage makes sense, and in any case, we have\n          --  actually eliminated the danger of optimization above.\n \n-         if Overflow_Check_Mode (Restyp) not in Minimized_Or_Eliminated then\n+         if Overflow_Check_Mode not in Minimized_Or_Eliminated then\n             Error_Msg_N (\"?explicit membership test may be optimized away\", N);\n             Error_Msg_N -- CODEFIX\n               (\"\\?use ''Valid attribute instead\", N);\n@@ -5526,7 +5526,7 @@ package body Exp_Ch4 is\n       --  type, then expand with a separate procedure. Note the use of the\n       --  flag No_Minimize_Eliminate to prevent infinite recursion.\n \n-      if Overflow_Check_Mode (Empty) in Minimized_Or_Eliminated\n+      if Overflow_Check_Mode in Minimized_Or_Eliminated\n         and then Is_Signed_Integer_Type (Ltyp)\n         and then not No_Minimize_Eliminate (N)\n       then\n@@ -11785,8 +11785,7 @@ package body Exp_Ch4 is\n    begin\n       return\n         Is_Signed_Integer_Type (Etype (N))\n-          and then Do_Overflow_Check (N)\n-          and then Overflow_Check_Mode (Empty) in Minimized_Or_Eliminated;\n+          and then Overflow_Check_Mode in Minimized_Or_Eliminated;\n    end Minimized_Eliminated_Overflow_Check;\n \n    --------------------------------"}, {"sha": "7c1ceeb8f7efd8289e6449a741df85c9636e1e63", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=a7f1b24f810a5f3312fee91a63f507da952498f3", "patch": "@@ -3840,11 +3840,11 @@ package body Exp_Util is\n    begin\n       if Suppress = All_Checks then\n          declare\n-            Svg : constant Suppress_Record := Scope_Suppress;\n+            Sva : constant Suppress_Array := Scope_Suppress.Suppress;\n          begin\n-            Scope_Suppress := Suppress_All;\n+            Scope_Suppress.Suppress := (others => True);\n             Insert_Actions (Assoc_Node, Ins_Actions);\n-            Scope_Suppress := Svg;\n+            Scope_Suppress.Suppress := Sva;\n          end;\n \n       else\n@@ -6727,7 +6727,7 @@ package body Exp_Util is\n \n       --  All this must not have any checks\n \n-      Scope_Suppress := Suppress_All;\n+      Scope_Suppress.Suppress := (others => True);\n \n       --  If it is a scalar type and we need to capture the value, just make\n       --  a copy. Likewise for a function call, an attribute reference, an"}, {"sha": "ee6ca097e78b8db5555c7d56810510f1f0daac18", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=a7f1b24f810a5f3312fee91a63f507da952498f3", "patch": "@@ -192,14 +192,12 @@ procedure Gnat1drv is\n \n          --  Enable all other language checks\n \n-         Suppress_Options :=\n-           (Suppress                   => (Access_Check      => True,\n-                                           Alignment_Check   => True,\n-                                           Division_Check    => True,\n-                                           Elaboration_Check => True,\n-                                           others            => False),\n-            Overflow_Checks_General    => Suppressed,\n-            Overflow_Checks_Assertions => Suppressed);\n+         Suppress_Options.Suppress :=\n+           (Access_Check      => True,\n+            Alignment_Check   => True,\n+            Division_Check    => True,\n+            Elaboration_Check => True,\n+            others            => False);\n \n          Dynamic_Elaboration_Checks := False;\n \n@@ -328,42 +326,50 @@ procedure Gnat1drv is\n          Exception_Mechanism := Back_End_Exceptions;\n       end if;\n \n-      --  Set proper status for overflow checks\n+      --  Set proper status for overflow check mechanism\n \n-      --  If already set (by - gnato or -gnatp) then we have nothing to do\n+      --  If already set (by -gnato) then we have nothing to do\n \n       if Opt.Suppress_Options.Overflow_Checks_General /= Not_Set then\n          null;\n \n-      --  Otherwise set appropriate default mode. Note: at present we set\n-      --  SUPPRESSED in all three of the following cases. They are separated\n-      --  because in the future we may make different choices.\n+      --  Otherwise set overflow mode defaults\n \n-      --  By default suppress overflow checks in -gnatg mode\n+      else\n+         --  Otherwise set overflow checks off by default\n \n-      elsif GNAT_Mode then\n-         Suppress_Options.Overflow_Checks_General    := Suppressed;\n-         Suppress_Options.Overflow_Checks_Assertions := Suppressed;\n+         Suppress_Options.Suppress (Overflow_Check) := True;\n \n-      --  If we have backend divide and overflow checks, then by default\n-      --  overflow checks are suppressed. Historically this code used to\n-      --  activate overflow checks, although no target currently has these\n-      --  flags set, so this was dead code anyway.\n+         --  Set appropriate default overflow handling mode. Note: at present\n+         --  we set STRICT in all three of the following cases. They are\n+         --  separated because in the future we may make different choices.\n \n-      elsif Targparm.Backend_Divide_Checks_On_Target\n-              and\n-            Targparm.Backend_Overflow_Checks_On_Target\n-      then\n-         Suppress_Options.Overflow_Checks_General    := Suppressed;\n-         Suppress_Options.Overflow_Checks_Assertions := Suppressed;\n+         --  By default set STRICT mode if -gnatg in effect\n \n-      --  Otherwise for now, default is checks are suppressed. This is subject\n-      --  to change in the future, but for now this is the compatible behavior\n-      --  with previous versions of GNAT.\n+         if GNAT_Mode then\n+            Suppress_Options.Overflow_Checks_General    := Strict;\n+            Suppress_Options.Overflow_Checks_Assertions := Strict;\n \n-      else\n-         Suppress_Options.Overflow_Checks_General    := Suppressed;\n-         Suppress_Options.Overflow_Checks_Assertions := Suppressed;\n+         --  If we have backend divide and overflow checks, then by default\n+         --  overflow checks are STRICT. Historically this code used to also\n+         --  activate overflow checks, although no target currently has these\n+         --  flags set, so this was dead code anyway.\n+\n+         elsif Targparm.Backend_Divide_Checks_On_Target\n+           and\n+             Targparm.Backend_Overflow_Checks_On_Target\n+         then\n+            Suppress_Options.Overflow_Checks_General    := Strict;\n+            Suppress_Options.Overflow_Checks_Assertions := Strict;\n+\n+         --  Otherwise for now, default is STRICT mode. This may change in the\n+         --  future, but for now this is the compatible behavior with previous\n+         --  versions of GNAT.\n+\n+         else\n+            Suppress_Options.Overflow_Checks_General    := Strict;\n+            Suppress_Options.Overflow_Checks_Assertions := Strict;\n+         end if;\n       end if;\n \n       --  Set default for atomic synchronization. As this synchronization"}, {"sha": "f3577790f4ccc7755405096b147ba544c2acc33b", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 18, "deletions": 46, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=a7f1b24f810a5f3312fee91a63f507da952498f3", "patch": "@@ -723,28 +723,14 @@ package body Sem is\n    begin\n       if Suppress = All_Checks then\n          declare\n-            Svg : constant Suppress_Record := Scope_Suppress;\n+            Svs : constant Suppress_Array := Scope_Suppress.Suppress;\n          begin\n-            Scope_Suppress := Suppress_All;\n+            Scope_Suppress.Suppress := (others => True);\n             Analyze (N);\n-            Scope_Suppress := Svg;\n+            Scope_Suppress.Suppress := Svs;\n          end;\n \n       elsif Suppress = Overflow_Check then\n-         declare\n-            Svg : constant Overflow_Check_Type :=\n-                    Scope_Suppress.Overflow_Checks_General;\n-            Sva : constant Overflow_Check_Type :=\n-                    Scope_Suppress.Overflow_Checks_Assertions;\n-         begin\n-            Scope_Suppress.Overflow_Checks_General    := Suppressed;\n-            Scope_Suppress.Overflow_Checks_Assertions := Suppressed;\n-            Analyze (N);\n-            Scope_Suppress.Overflow_Checks_General    := Svg;\n-            Scope_Suppress.Overflow_Checks_Assertions := Sva;\n-         end;\n-\n-      else\n          declare\n             Svg : constant Boolean := Scope_Suppress.Suppress (Suppress);\n          begin\n@@ -776,25 +762,11 @@ package body Sem is\n    begin\n       if Suppress = All_Checks then\n          declare\n-            Svg : constant Suppress_Record := Scope_Suppress;\n-         begin\n-            Scope_Suppress := Suppress_All;\n-            Analyze_List (L);\n-            Scope_Suppress := Svg;\n-         end;\n-\n-      elsif Suppress = Overflow_Check then\n-         declare\n-            Svg : constant Overflow_Check_Type :=\n-                    Scope_Suppress.Overflow_Checks_General;\n-            Sva : constant Overflow_Check_Type :=\n-                    Scope_Suppress.Overflow_Checks_Assertions;\n+            Svs : constant Suppress_Array := Scope_Suppress.Suppress;\n          begin\n-            Scope_Suppress.Overflow_Checks_General    := Suppressed;\n-            Scope_Suppress.Overflow_Checks_Assertions := Suppressed;\n+            Scope_Suppress.Suppress := (others => True);\n             Analyze_List (L);\n-            Scope_Suppress.Overflow_Checks_General    := Svg;\n-            Scope_Suppress.Overflow_Checks_Assertions := Sva;\n+            Scope_Suppress.Suppress := Svs;\n          end;\n \n       else\n@@ -1051,11 +1023,11 @@ package body Sem is\n    begin\n       if Suppress = All_Checks then\n          declare\n-            Svg : constant Suppress_Record := Scope_Suppress;\n+            Svs : constant Suppress_Array := Scope_Suppress.Suppress;\n          begin\n-            Scope_Suppress := Suppress_All;\n+            Scope_Suppress.Suppress := (others => True);\n             Insert_After_And_Analyze (N, M);\n-            Scope_Suppress := Svg;\n+            Scope_Suppress.Suppress := Svs;\n          end;\n \n       else\n@@ -1111,11 +1083,11 @@ package body Sem is\n    begin\n       if Suppress = All_Checks then\n          declare\n-            Svg : constant Suppress_Record := Scope_Suppress;\n+            Svs : constant Suppress_Array := Scope_Suppress.Suppress;\n          begin\n-            Scope_Suppress := Suppress_All;\n+            Scope_Suppress.Suppress := (others => True);\n             Insert_Before_And_Analyze (N, M);\n-            Scope_Suppress := Svg;\n+            Scope_Suppress.Suppress := Svs;\n          end;\n \n       else\n@@ -1170,11 +1142,11 @@ package body Sem is\n    begin\n       if Suppress = All_Checks then\n          declare\n-            Svg : constant Suppress_Record := Scope_Suppress;\n+            Svs : constant Suppress_Array := Scope_Suppress.Suppress;\n          begin\n-            Scope_Suppress := Suppress_All;\n+            Scope_Suppress.Suppress := (others => True);\n             Insert_List_After_And_Analyze (N, L);\n-            Scope_Suppress := Svg;\n+            Scope_Suppress.Suppress := Svs;\n          end;\n \n       else\n@@ -1228,11 +1200,11 @@ package body Sem is\n    begin\n       if Suppress = All_Checks then\n          declare\n-            Svg : constant Suppress_Record := Scope_Suppress;\n+            Svs : constant Suppress_Array := Scope_Suppress.Suppress;\n          begin\n-            Scope_Suppress := Suppress_All;\n+            Scope_Suppress.Suppress := (others => True);\n             Insert_List_Before_And_Analyze (N, L);\n-            Scope_Suppress := Svg;\n+            Scope_Suppress.Suppress := Svs;\n          end;\n \n       else"}, {"sha": "4ca5285d7ef3e447210ac32f5e59975ccc606f06", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 10, "deletions": 29, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=a7f1b24f810a5f3312fee91a63f507da952498f3", "patch": "@@ -2121,7 +2121,8 @@ package body Sem_Prag is\n               (Get_Pragma_Arg (Arg2), Standard_String);\n          end if;\n \n-         --  Record if pragma is disabled\n+         --  For a pragma in the extended main source unit, record enabled\n+         --  status in SCO (note: there is never any SCO for an instance).\n \n          if Check_Enabled (Pname) then\n             Set_SCO_Pragma_Enabled (Loc);\n@@ -5058,7 +5059,8 @@ package body Sem_Prag is\n \n                   --  If previous error, avoid cascaded errors\n \n-                  Applies := True;\n+                  Cascaded_Error;\n+                  Applies   := True;\n                   Effective := True;\n \n                else\n@@ -5703,18 +5705,6 @@ package body Sem_Prag is\n               (\"argument of pragma% is not valid check name\", Arg1);\n          end if;\n \n-         --  Special processing for overflow check case\n-\n-         if C = All_Checks or else C = Overflow_Check then\n-            if Suppress_Case then\n-               Scope_Suppress.Overflow_Checks_General    := Suppressed;\n-               Scope_Suppress.Overflow_Checks_Assertions := Suppressed;\n-            else\n-               Scope_Suppress.Overflow_Checks_General    := Checked;\n-               Scope_Suppress.Overflow_Checks_Assertions := Checked;\n-            end if;\n-         end if;\n-\n          if Arg_Count = 1 then\n \n             --  Make an entry in the local scope suppress table. This is the\n@@ -12007,10 +11997,11 @@ package body Sem_Prag is\n          --  pragma Overflow_Checks\n          --    ([General => ] MODE [, [Assertions => ] MODE]);\n \n-         --  MODE := SUPPRESSED | CHECKED | MINIMIZED | ELIMINATED\n+         --  MODE := STRICT | MINIMIZED | ELIMINATED\n \n          --  Note: ELIMINATED is allowed only if Long_Long_Integer'Size is 64\n-         --  since System.Bignums makes this assumption.\n+         --  since System.Bignums makes this assumption. This is true of nearly\n+         --  all (all?) targets.\n \n          when Pragma_Overflow_Checks => Overflow_Checks : declare\n             function Get_Check_Mode\n@@ -12034,19 +12025,8 @@ package body Sem_Prag is\n                Check_Optional_Identifier (Arg, Name);\n                Check_Arg_Is_Identifier (Argx);\n \n-               --  Do not suppress overflow checks for formal verification.\n-               --  Instead, require that a check is inserted so that formal\n-               --  verification can detect wraparound errors.\n-\n-               if Chars (Argx) = Name_Suppressed then\n-                  if Alfa_Mode then\n-                     return Checked;\n-                  else\n-                     return Suppressed;\n-                  end if;\n-\n-               elsif Chars (Argx) = Name_Checked then\n-                  return Checked;\n+               if Chars (Argx) = Name_Strict then\n+                  return Strict;\n \n                elsif Chars (Argx) = Name_Minimized then\n                   return Minimized;\n@@ -14545,6 +14525,7 @@ package body Sem_Prag is\n             --  Note: in previous versions of GNAT we used to check for limited\n             --  types and give an error, but in fact the standard does allow\n             --  Unchecked_Union on limited types, so this check was removed.\n+\n             --  Similarly, GNAT used to require that all discriminants have\n             --  default values, but this is not mandated by the RM.\n "}, {"sha": "64199fa2cf611a6d6a829a41bf3d375ddccebf44", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 22, "deletions": 66, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=a7f1b24f810a5f3312fee91a63f507da952498f3", "patch": "@@ -334,25 +334,11 @@ package body Sem_Res is\n    begin\n       if Suppress = All_Checks then\n          declare\n-            Svg : constant Suppress_Record := Scope_Suppress;\n+            Sva : constant Suppress_Array := Scope_Suppress.Suppress;\n          begin\n-            Scope_Suppress := Suppress_All;\n+            Scope_Suppress.Suppress := (others => True);\n             Analyze_And_Resolve (N, Typ);\n-            Scope_Suppress := Svg;\n-         end;\n-\n-      elsif Suppress = Overflow_Check then\n-         declare\n-            Svg : constant Overflow_Check_Type :=\n-                    Scope_Suppress.Overflow_Checks_General;\n-            Sva : constant Overflow_Check_Type :=\n-                    Scope_Suppress.Overflow_Checks_Assertions;\n-         begin\n-            Scope_Suppress.Overflow_Checks_General    := Suppressed;\n-            Scope_Suppress.Overflow_Checks_Assertions := Suppressed;\n-            Analyze_And_Resolve (N, Typ);\n-            Scope_Suppress.Overflow_Checks_General    := Svg;\n-            Scope_Suppress.Overflow_Checks_Assertions := Sva;\n+            Scope_Suppress.Suppress := Sva;\n          end;\n \n       else\n@@ -388,25 +374,11 @@ package body Sem_Res is\n    begin\n       if Suppress = All_Checks then\n          declare\n-            Svg : constant Suppress_Record := Scope_Suppress;\n-         begin\n-            Scope_Suppress := Suppress_All;\n-            Analyze_And_Resolve (N);\n-            Scope_Suppress := Svg;\n-         end;\n-\n-      elsif Suppress = Overflow_Check then\n-         declare\n-            Svg : constant Overflow_Check_Type :=\n-                    Scope_Suppress.Overflow_Checks_General;\n-            Sva : constant Overflow_Check_Type :=\n-                    Scope_Suppress.Overflow_Checks_Assertions;\n+            Sva : constant Suppress_Array := Scope_Suppress.Suppress;\n          begin\n-            Scope_Suppress.Overflow_Checks_General    := Suppressed;\n-            Scope_Suppress.Overflow_Checks_Assertions := Suppressed;\n+            Scope_Suppress.Suppress := (others => True);\n             Analyze_And_Resolve (N);\n-            Scope_Suppress.Overflow_Checks_General    := Svg;\n-            Scope_Suppress.Overflow_Checks_Assertions := Sva;\n+            Scope_Suppress.Suppress := Sva;\n          end;\n \n       else\n@@ -1690,19 +1662,23 @@ package body Sem_Res is\n       Full_Analysis := False;\n       Expander_Mode_Save_And_Set (False);\n \n-      --  We suppress all checks for this analysis, except in Alfa mode.\n-      --  Otherwise the checks are applied properly, and in the proper\n-      --  location, when the default expressions are reanalyzed and reexpanded\n-      --  later on.\n+      --  Normally, we suppress all checks for this preanalysis. There is no\n+      --  point in processing them now, since they will be applied properly\n+      --  and in the proper location when the default expressions reanalyzed\n+      --  and reexpanded later on. We will also have more information at that\n+      --  point for possible suppression of individual checks.\n \n-      --  Alfa mode suppresses all expansion but requires the setting of\n-      --  checking flags (DIvision_Check and others) in particular for Ada 2012\n-      --  constructs such as quantified expressions, that are expanded in two\n-      --  separate steps.\n+      --  However, in Alfa mode, most expansion is suppressed, and this\n+      --  later reanalysis and reexpansion may not occur. Alfa mode does\n+      --  require the setting of checking flags for proof purposes, so we\n+      --  do the Alfa preanalysis without suppressing checks.\n+\n+      --  This special handling for Alfa mode is required for example in the\n+      --  case of Ada 2012 constructs such as quantified expressions, which are\n+      --  expanded in two separate steps.\n \n       if Alfa_Mode then\n          Analyze_And_Resolve (N, T);\n-\n       else\n          Analyze_And_Resolve (N, T, Suppress => All_Checks);\n       end if;\n@@ -2946,11 +2922,11 @@ package body Sem_Res is\n    begin\n       if Suppress = All_Checks then\n          declare\n-            Svg : constant Suppress_Record := Scope_Suppress;\n+            Sva : constant Suppress_Array := Scope_Suppress.Suppress;\n          begin\n-            Scope_Suppress := Suppress_All;\n+            Scope_Suppress.Suppress := (others => True);\n             Resolve (N, Typ);\n-            Scope_Suppress := Svg;\n+            Scope_Suppress.Suppress := Sva;\n          end;\n \n       else\n@@ -5959,16 +5935,6 @@ package body Sem_Res is\n \n       Set_Etype (N, Typ);\n       Eval_Case_Expression (N);\n-\n-      --  If we still have a case expression, and overflow checks are enabled\n-      --  in MINIMIZED or ELIMINATED modes, then set Do_Overflow_Check to\n-      --  ensure that we handle overflow for dependent expressions.\n-\n-      if Nkind (N) = N_Case_Expression\n-        and then Overflow_Check_Mode (Typ) in Minimized_Or_Eliminated\n-      then\n-         Set_Do_Overflow_Check (N);\n-      end if;\n    end Resolve_Case_Expression;\n \n    -------------------------------\n@@ -7215,16 +7181,6 @@ package body Sem_Res is\n \n       Set_Etype (N, Typ);\n       Eval_If_Expression (N);\n-\n-      --  If we still have a if expression, and overflow checks are enabled in\n-      --  MINIMIZED or ELIMINATED modes, then set Do_Overflow_Check to ensure\n-      --  that we handle overflow for dependent expressions.\n-\n-      if Nkind (N) = N_If_Expression\n-        and then Overflow_Check_Mode (Typ) in Minimized_Or_Eliminated\n-      then\n-         Set_Do_Overflow_Check (N);\n-      end if;\n    end Resolve_If_Expression;\n \n    -------------------------------"}, {"sha": "efd340f01d62ca1c0d60298adc1bda10f690cd4b", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=a7f1b24f810a5f3312fee91a63f507da952498f3", "patch": "@@ -665,7 +665,6 @@ package Snames is\n    Name_By_Protected_Procedure         : constant Name_Id := N + $;\n    Name_Casing                         : constant Name_Id := N + $;\n    Name_Check_All                      : constant Name_Id := N + $;\n-   Name_Checked                        : constant Name_Id := N + $;\n    Name_Code                           : constant Name_Id := N + $;\n    Name_Component                      : constant Name_Id := N + $;\n    Name_Component_Size_4               : constant Name_Id := N + $;\n@@ -739,6 +738,7 @@ package Snames is\n    Name_State                          : constant Name_Id := N + $;\n    Name_Static                         : constant Name_Id := N + $;\n    Name_Stack_Size                     : constant Name_Id := N + $;\n+   Name_Strict                         : constant Name_Id := N + $;\n    Name_Subunit_File_Name              : constant Name_Id := N + $;\n    Name_Suppressed                     : constant Name_Id := N + $;\n    Name_Task_Stack_Size_Default        : constant Name_Id := N + $;"}, {"sha": "e7d517e794e8f637c6814da9e182e74aed2e597e", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=a7f1b24f810a5f3312fee91a63f507da952498f3", "patch": "@@ -97,11 +97,8 @@ package body Switch.C is\n    function Get_Overflow_Mode (C : Character) return Overflow_Check_Type is\n    begin\n       case C is\n-         when '0' =>\n-            return Suppressed;\n-\n          when '1' =>\n-            return Checked;\n+            return Strict;\n \n          when '2' =>\n             return Minimized;\n@@ -801,12 +798,13 @@ package body Switch.C is\n \n             when 'o' =>\n                Ptr := Ptr + 1;\n+               Suppress_Options.Suppress (Overflow_Check) := False;\n \n                --  Case of no digits after the -gnato\n \n-               if Ptr > Max or else Switch_Chars (Ptr) not in '0' .. '3' then\n-                  Suppress_Options.Overflow_Checks_General    := Checked;\n-                  Suppress_Options.Overflow_Checks_Assertions := Checked;\n+               if Ptr > Max or else Switch_Chars (Ptr) not in '1' .. '3' then\n+                  Suppress_Options.Overflow_Checks_General    := Strict;\n+                  Suppress_Options.Overflow_Checks_Assertions := Strict;\n \n                --  At least one digit after the -gnato\n \n@@ -821,7 +819,7 @@ package body Switch.C is\n                   --  be the same as general mode.\n \n                   if Ptr > Max\n-                    or else Switch_Chars (Ptr) not in '0' .. '3'\n+                    or else Switch_Chars (Ptr) not in '1' .. '3'\n                   then\n                      Suppress_Options.Overflow_Checks_Assertions :=\n                        Suppress_Options.Overflow_Checks_General;\n@@ -869,9 +867,6 @@ package body Switch.C is\n                      end if;\n                   end loop;\n \n-                  Suppress_Options.Overflow_Checks_General    := Suppressed;\n-                  Suppress_Options.Overflow_Checks_Assertions := Suppressed;\n-\n                   Validity_Checks_On  := False;\n                   Opt.Suppress_Checks := True;\n                end if;"}, {"sha": "861c0bcc1c8f2a45ec7109f3ae0deac0442135c8", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f1b24f810a5f3312fee91a63f507da952498f3/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=a7f1b24f810a5f3312fee91a63f507da952498f3", "patch": "@@ -703,68 +703,59 @@ package Types is\n    --    4.  Add a new Do_xxx_Check flag to Sinfo (if required)\n    --    5.  Add appropriate checks for the new test\n \n-   --  The following provides precise details on the mode used to check\n-   --  intermediate overflows in expressions for signed integer arithmetic.\n+   --  The following provides precise details on the mode used to generate\n+   --  code for intermediate overflows in expressions for signed integer\n+   --  arithmetic (and how to generate overflow checks if enabled). Note\n+   --  that this only affects handling of intermediate results. The final\n+   --  result must always fit within the target range, and if overflow\n+   --  checking is enabled, the check on the final result is against this\n+   --  target range.\n \n    type Overflow_Check_Type is (\n       Not_Set,\n       --  Dummy value used during initialization process to show that the\n       --  corresponding value has not yet been initialized.\n \n-      Suppressed,\n-      --  Overflow checking is suppressed. If an arithmetic operation creates\n-      --  an overflow, no exception is raised, and the program is erroneous.\n-\n-      Checked,\n-      --  All operations, including all intermediate operations are checked.\n-      --  If the result of any arithmetic operation gives a result outside the\n-      --  range of the base type, then a Constraint_Error exception is raised.\n+      Strict,\n+      --  Operations are done in the base type of the subexpression. If\n+      --  overflow checks are enabled, then the check is against the range\n+      --  of this base type.\n \n       Minimized,\n-      --  Where appropriate, arithmetic operations are performed with an\n-      --  extended range, using Long_Long_Integer if necessary. As long as the\n-      --  result fits in this extended range, then no exception is raised and\n-      --  computation continues with the extended result. The final value of an\n-      --  expression must fit in the base type of the whole expression. If an\n-      --  intermediate result is outside the range of Long_Long_Integer then a\n-      --  Constraint_Error exception is raised.\n+      --  Where appropriate, intermediate arithmetic operations are performed\n+      --  with an extended range, using Long_Long_Integer if necessary. If\n+      --  overflow checking is enabled, then the check is against the range\n+      --  of Long_Long_Integer.\n \n       Eliminated);\n       --  In this mode arbitrary precision arithmetic is used as needed to\n       --  ensure that it is impossible for intermediate arithmetic to cause an\n-      --  overflow. Again the final value of an expression must fit in the base\n-      --  type of the whole expression.\n+      --  overflow. In this mode, intermediate expressions are not affected by\n+      --  the overflow checking mode, since overflows are eliminated.\n \n    subtype Minimized_Or_Eliminated is\n      Overflow_Check_Type range Minimized .. Eliminated;\n-   subtype Suppressed_Or_Checked is\n-     Overflow_Check_Type range Suppressed .. Checked;\n-   --  Define subtypes so that clients don't need to know ordering. Note that\n+   --  Define subtype so that clients don't need to know ordering. Note that\n    --  Overflow_Check_Type is not marked as an ordered enumeration type.\n \n    --  The following structure captures the state of check suppression or\n    --  activation at a particular point in the program execution.\n \n    type Suppress_Record is record\n       Suppress : Suppress_Array;\n-      --  Indicates suppression status of each possible check. Note: there\n-      --  is an entry for Overflow_Check in this array, but it is never used.\n-      --  Instead we use the more detailed information in the two components\n-      --  that follow this one (Overflow_Checks_General/Assertions).\n+      --  Indicates suppression status of each possible check\n \n       Overflow_Checks_General : Overflow_Check_Type;\n-      --  This field indicates the mode of overflow checking to be applied to\n-      --  general expressions outside assertions.\n+      --  This field indicates the mode for handling code generation and\n+      --  overflow checking (if enabled) for intermediate expression values.\n+      --  This applies to general expressions outside assertions.\n \n       Overflow_Checks_Assertions : Overflow_Check_Type;\n-      --  This field indicates the mode of overflow checking to be applied to\n-      --  any expression occuring inside assertions.\n+      --  This field indicates the mode for handling code generation and\n+      --  overflow checking (if enabled) for intermediate expression values.\n+      --  This applies to any expression occuring inside assertions.\n    end record;\n \n-   Suppress_All : constant Suppress_Record :=\n-                    ((others => True), Suppressed, Suppressed);\n-   --  Constant used to initialize Suppress_Record value to all suppressed.\n-\n    -----------------------------------\n    -- Global Exception Declarations --\n    -----------------------------------"}]}