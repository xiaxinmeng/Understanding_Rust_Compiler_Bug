{"sha": "8733892f667ab4ae039caf7531bc5163c3042469", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODczMzg5MmY2NjdhYjRhZTAzOWNhZjc1MzFiYzUxNjNjMzA0MjQ2OQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2002-08-13T12:11:20Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2002-08-13T12:11:20Z"}, "message": "libgcc2.c (L_bb): Remove unneeded #includes.\n\n\t* libgcc2.c (L_bb): Remove unneeded #includes.\n\t(__global_counters, __gthreads_active): Remove unused globals.\n\t(__bb_exit_func): Merge counts into files rather than appending.\n\t* Makefile.in (INTERNAL_CFLAGS): Move COVERAGE_FLAGS from here ...\n\t(ALL_CFLAGS): ... to here.\n\nFrom-SVN: r56250", "tree": {"sha": "1883d992516950fbeedd9c9dfa1a95b1a3b1d0ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1883d992516950fbeedd9c9dfa1a95b1a3b1d0ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8733892f667ab4ae039caf7531bc5163c3042469", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8733892f667ab4ae039caf7531bc5163c3042469", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8733892f667ab4ae039caf7531bc5163c3042469", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8733892f667ab4ae039caf7531bc5163c3042469/comments", "author": null, "committer": null, "parents": [{"sha": "f4769721584220bb4ac82f54f77a0a94b3be42aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4769721584220bb4ac82f54f77a0a94b3be42aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4769721584220bb4ac82f54f77a0a94b3be42aa"}], "stats": {"total": 355, "additions": 220, "deletions": 135}, "files": [{"sha": "82dd85051d096ed6450d8500637649442442b3be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8733892f667ab4ae039caf7531bc5163c3042469/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8733892f667ab4ae039caf7531bc5163c3042469/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8733892f667ab4ae039caf7531bc5163c3042469", "patch": "@@ -1,3 +1,11 @@\n+2002-08-13  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* libgcc2.c (L_bb): Remove unneeded #includes.\n+\t(__global_counters, __gthreads_active): Remove unused globals.\n+\t(__bb_exit_func): Merge counts into files rather than appending.\n+\t* Makefile.in (INTERNAL_CFLAGS): Move COVERAGE_FLAGS from here ...\n+\t(ALL_CFLAGS): ... to here.\n+\n 2002-08-13  Denis Chertykov  <denisc@overta.ru>\n \n \t* config/ip2k/ip2k.c (commands_in_file): Variable removed."}, {"sha": "af83d1eafc0baccc7ba4ef98a6bd71d1866fc55d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8733892f667ab4ae039caf7531bc5163c3042469/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8733892f667ab4ae039caf7531bc5163c3042469/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8733892f667ab4ae039caf7531bc5163c3042469", "patch": "@@ -594,13 +594,13 @@ all.indirect: $(ALL)\n # IN_GCC distinguishes between code compiled into GCC itself and other\n # programs built during a bootstrap.\n # autoconf inserts -DCROSS_COMPILE if we are building a cross compiler.\n-INTERNAL_CFLAGS = -DIN_GCC @CROSS@ $(COVERAGE_FLAGS)\n+INTERNAL_CFLAGS = -DIN_GCC @CROSS@\n \n # This is the variable actually used when we compile.\n # If you change this line, you probably also need to change the definition\n # of HOST_CFLAGS in build-make to match.\n ALL_CFLAGS = $(X_CFLAGS) $(T_CFLAGS) \\\n-  $(CFLAGS) $(INTERNAL_CFLAGS) $(WARN_CFLAGS) $(XCFLAGS) @DEFS@\n+  $(CFLAGS) $(INTERNAL_CFLAGS) $(COVERAGE_FLAGS) $(WARN_CFLAGS) $(XCFLAGS) @DEFS@\n \n # Likewise.\n ALL_CPPFLAGS = $(CPPFLAGS) $(X_CPPFLAGS) $(T_CPPFLAGS)"}, {"sha": "f9d7f60bc2fd60241079d74125c51bcd55a445d1", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 210, "deletions": 133, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8733892f667ab4ae039caf7531bc5163c3042469/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8733892f667ab4ae039caf7531bc5163c3042469/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=8733892f667ab4ae039caf7531bc5163c3042469", "patch": "@@ -1,7 +1,7 @@\n /* More subroutines needed by GCC output code on some machines.  */\n /* Compile this one with gcc.  */\n /* Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001  Free Software Foundation, Inc.\n+   2000, 2001, 2002  Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1243,7 +1243,7 @@ struct bb_function_info {\n   const char *name;\n };\n \n-/* Structure emitted by -a  */\n+/* Structure emitted by --profile-arcs  */\n struct bb\n {\n   long zero_word;\n@@ -1259,204 +1259,280 @@ struct bb\n \n #ifndef inhibit_libc\n \n-/* Simple minded basic block profiling output dumper for\n-   systems that don't provide tcov support.  At present,\n-   it requires atexit and stdio.  */\n+/* Arc profile dumper. Requires atexit and stdio.  */\n \n #undef NULL /* Avoid errors if stdio.h and our stddef.h mismatch.  */\n #include <stdio.h>\n \n-#include \"gbl-ctors.h\"\n #include \"gcov-io.h\"\n #include <string.h>\n #ifdef TARGET_HAS_F_SETLKW\n #include <fcntl.h>\n #include <errno.h>\n #endif\n \n-#include <gthr.h>\n-\n+/* Chain of per-object file bb structures. */\n static struct bb *bb_head;\n \n-int __global_counters = 0, __gthreads_active = 0;\n+/* Dump the coverage counts. We merge with existing counts when\n+   possible, to avoid growing the .da files ad infinitum.  */\n \n void\n __bb_exit_func (void)\n {\n-  FILE *da_file;\n   struct bb *ptr;\n-  long n_counters_p = 0;\n-  gcov_type max_counter_p = 0;\n-  gcov_type sum_counters_p = 0;\n-\n-  if (bb_head == 0)\n-    return;\n+  int i;\n+  gcov_type program_sum = 0;\n+  gcov_type program_max = 0;\n+  long program_arcs = 0;\n+  gcov_type merged_sum = 0;\n+  gcov_type merged_max = 0;\n+  long merged_arcs = 0;\n+  \n+#if defined (TARGET_HAS_F_SETLKW)\n+  struct flock s_flock;\n \n-  /* Calculate overall \"statistics\".  */\n+  s_flock.l_type = F_WRLCK;\n+  s_flock.l_whence = SEEK_SET;\n+  s_flock.l_start = 0;\n+  s_flock.l_len = 0; /* Until EOF. */\n+  s_flock.l_pid = getpid ();\n+#endif\n \n-  for (ptr = bb_head; ptr != (struct bb *) 0; ptr = ptr->next)\n+  /* Non-merged stats for this program.  */\n+  for (ptr = bb_head; ptr; ptr = ptr->next)\n     {\n-      int i;\n-\n-      n_counters_p += ptr->ncounts;\n-\n       for (i = 0; i < ptr->ncounts; i++)\n \t{\n-\t  sum_counters_p += ptr->counts[i];\n+\t  program_sum += ptr->counts[i];\n \n-\t  if (ptr->counts[i] > max_counter_p)\n-\t    max_counter_p = ptr->counts[i];\n+\t  if (ptr->counts[i] > program_max)\n+\t    program_max = ptr->counts[i];\n \t}\n+      program_arcs += ptr->ncounts;\n     }\n-\n-  for (ptr = bb_head; ptr != (struct bb *) 0; ptr = ptr->next)\n+  \n+  for (ptr = bb_head; ptr; ptr = ptr->next)\n     {\n-      gcov_type max_counter_o = 0;\n-      gcov_type sum_counters_o = 0;\n-      int i;\n-\n-      /* Calculate the per-object statistics.  */\n-\n-      for (i = 0; i < ptr->ncounts; i++)\n+      FILE *da_file;\n+      gcov_type object_max = 0;\n+      gcov_type object_sum = 0;\n+      long object_functions = 0;\n+      int merging = 0;\n+      int error = 0;\n+      struct bb_function_info *fn_info;\n+      gcov_type *count_ptr;\n+      \n+      /* Open for modification */\n+      da_file = fopen (ptr->filename, \"r+b\");\n+      \n+      if (da_file)\n+\tmerging = 1;\n+      else\n \t{\n-\t  sum_counters_o += ptr->counts[i];\n-\n-\t  if (ptr->counts[i] > max_counter_o)\n-\t    max_counter_o = ptr->counts[i];\n+\t  /* Try for appending */\n+\t  da_file = fopen (ptr->filename, \"ab\");\n+\t  /* Some old systems might not allow the 'b' mode modifier.\n+             Therefore, try to open without it.  This can lead to a\n+             race condition so that when you delete and re-create the\n+             file, the file might be opened in text mode, but then,\n+             you shouldn't delete the file in the first place.  */\n+\t  if (!da_file)\n+\t    da_file = fopen (ptr->filename, \"a\");\n \t}\n-\n-      /* open the file for appending, creating it if necessary.  */\n-      da_file = fopen (ptr->filename, \"ab\");\n-      /* Some old systems might not allow the 'b' mode modifier.\n-         Therefore, try to open without it.  This can lead to a race\n-         condition so that when you delete and re-create the file, the\n-         file might be opened in text mode, but then, you shouldn't\n-         delete the file in the first place.  */\n-      if (da_file == 0)\n-\tda_file = fopen (ptr->filename, \"a\");\n-      if (da_file == 0)\n+      \n+      if (!da_file)\n \t{\n \t  fprintf (stderr, \"arc profiling: Can't open output file %s.\\n\",\n \t\t   ptr->filename);\n+\t  ptr->filename = 0;\n \t  continue;\n \t}\n \n+#if defined (TARGET_HAS_F_SETLKW)\n       /* After a fork, another process might try to read and/or write\n          the same file simultanously.  So if we can, lock the file to\n          avoid race conditions.  */\n-#if defined (TARGET_HAS_F_SETLKW)\n-      {\n-\tstruct flock s_flock;\n-\n-\ts_flock.l_type = F_WRLCK;\n-\ts_flock.l_whence = SEEK_SET;\n-\ts_flock.l_start = 0;\n-\ts_flock.l_len = 1;\n-\ts_flock.l_pid = getpid ();\n-\n-\twhile (fcntl (fileno (da_file), F_SETLKW, &s_flock)\n-\t       && errno == EINTR);\n-      }\n+      while (fcntl (fileno (da_file), F_SETLKW, &s_flock)\n+\t     && errno == EINTR)\n+\tcontinue;\n #endif\n+      for (fn_info = ptr->function_infos; fn_info->arc_count != -1; fn_info++)\n+\tobject_functions++;\n \n-      if (__write_long (-123, da_file, 4) != 0)\t/* magic */\n+      if (merging)\n \t{\n-\t  fprintf (stderr, \"arc profiling: Error writing output file %s.\\n\",\n-\t\t   ptr->filename);\n+\t  /* Merge data from file.  */\n+\t  long tmp_long;\n+\t  gcov_type tmp_gcov;\n+\t  \n+\t  if (/* magic */\n+\t      (__read_long (&tmp_long, da_file, 4) || tmp_long != -123l)\n+\t      /* functions in object file.  */\n+\t      || (__read_long (&tmp_long, da_file, 4)\n+\t\t  || tmp_long != object_functions)\n+\t      /* extension block, skipped */\n+\t      || (__read_long (&tmp_long, da_file, 4)\n+\t\t  || fseek (da_file, tmp_long, SEEK_CUR)))\n+\t    {\n+\t    read_error:;\n+\t      fprintf (stderr, \"arc profiling: Error merging output file %s.\\n\",\n+\t\t       ptr->filename);\n+\t      clearerr (da_file);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Merge execution counts for each function.  */\n+\t      count_ptr = ptr->counts;\n+\t      \n+\t      for (fn_info = ptr->function_infos; fn_info->arc_count != -1;\n+\t\t   fn_info++)\n+\t\t{\n+\t\t  if (/* function name delim */\n+\t\t      (__read_long (&tmp_long, da_file, 4)\n+\t\t       || tmp_long != -1)\n+\t\t      /* function name length */\n+\t\t      || (__read_long (&tmp_long, da_file, 4)\n+\t\t\t  || tmp_long != (long) strlen (fn_info->name))\n+\t\t      /* skip string */\n+\t\t      || fseek (da_file, ((tmp_long + 1) + 3) & ~3, SEEK_CUR)\n+\t\t      /* function name delim */\n+\t\t      || (__read_long (&tmp_long, da_file, 4)\n+\t\t\t  || tmp_long != -1))\n+\t\t    goto read_error;\n+\n+\t\t  if (/* function checksum */\n+\t\t      (__read_long (&tmp_long, da_file, 4)\n+\t\t       || tmp_long != fn_info->checksum)\n+\t\t      /* arc count */\n+\t\t      || (__read_long (&tmp_long, da_file, 4)\n+\t\t\t  || tmp_long != fn_info->arc_count))\n+\t\t    goto read_error;\n+\t\t  \n+\t\t  for (i = fn_info->arc_count; i > 0; i--, count_ptr++)\n+\t\t    if (__read_gcov_type (&tmp_gcov, da_file, 8))\n+\t\t      goto read_error;\n+\t\t    else\n+\t\t      *count_ptr += tmp_gcov;\n+\t\t}\n+\t    }\n+\t  fseek (da_file, 0, SEEK_SET);\n \t}\n-      else\n+      \n+      /* Calculate the per-object statistics.  */\n+      for (i = 0; i < ptr->ncounts; i++)\n \t{\n+\t  object_sum += ptr->counts[i];\n \n-\t  struct bb_function_info *fn_info;\n-\t  gcov_type *count_ptr = ptr->counts;\n-\t  int i;\n-\t  int count_functions = 0;\n-\n-\t  for (fn_info = ptr->function_infos; fn_info->arc_count != -1;\n-\t       fn_info++)\n-\t    count_functions++;\n-\n-\t  /* number of functions in this block.  */\n-\t  __write_long (count_functions, da_file, 4);\n-\n+\t  if (ptr->counts[i] > object_max)\n+\t    object_max = ptr->counts[i];\n+\t}\n+      merged_sum += object_sum;\n+      if (merged_max < object_max)\n+\tmerged_max = object_max;\n+      merged_arcs += ptr->ncounts;\n+      \n+      /* Write out the data. */\n+      if (/* magic */\n+\t  __write_long (-123, da_file, 4)\n+\t  /* number of functions in object file.  */\n+\t  || __write_long (object_functions, da_file, 4)\n \t  /* length of extra data in bytes.  */\n-\t  __write_long ((4 + 8 + 8) + (4 + 8 + 8), da_file, 4);\n+\t  || __write_long ((4 + 8 + 8) + (4 + 8 + 8), da_file, 4)\n \n-\t  /* overall statistics.  */\n-\t  /* number of counters.  */\n-\t  __write_long (n_counters_p, da_file, 4);\n+\t  /* whole program statistics. If merging write per-object\n+\t     now, rewrite later */\n+\t  /* number of instrumented arcs.  */\n+\t  || __write_long (merging ? ptr->ncounts : program_arcs, da_file, 4)\n \t  /* sum of counters.  */\n-\t  __write_gcov_type (sum_counters_p, da_file, 8);\n+\t  || __write_gcov_type (merging ? object_sum : program_sum, da_file, 8)\n \t  /* maximal counter.  */\n-\t  __write_gcov_type (max_counter_p, da_file, 8);\n+\t  || __write_gcov_type (merging ? object_max : program_max, da_file, 8)\n \n \t  /* per-object statistics.  */\n \t  /* number of counters.  */\n-\t  __write_long (ptr->ncounts, da_file, 4);\n+\t  || __write_long (ptr->ncounts, da_file, 4)\n \t  /* sum of counters.  */\n-\t  __write_gcov_type (sum_counters_o, da_file, 8);\n+\t  || __write_gcov_type (object_sum, da_file, 8)\n \t  /* maximal counter.  */\n-\t  __write_gcov_type (max_counter_o, da_file, 8);\n-\n-\t  /* write execution counts for each function.  */\n+\t  || __write_gcov_type (object_max, da_file, 8))\n+\t{\n+\twrite_error:;\n+\t  fprintf (stderr, \"arc profiling: Error writing output file %s.\\n\",\n+\t\t   ptr->filename);\n+\t  error = 1;\n+\t}\n+      else\n+\t{\n+\t  /* Write execution counts for each function.  */\n+\t  count_ptr = ptr->counts;\n \n \t  for (fn_info = ptr->function_infos; fn_info->arc_count != -1;\n \t       fn_info++)\n \t    {\n-\t      /* new function.  */\n-\t      if (__write_gcov_string\n-\t\t  (fn_info->name, strlen (fn_info->name), da_file, -1) != 0)\n-\t\t{\n-\t\t  fprintf (stderr,\n-\t\t\t   \"arc profiling: Error writing output file %s.\\n\",\n-\t\t\t   ptr->filename);\n-\t\t  break;\n-\t\t}\n-\n-\t      if (__write_long (fn_info->checksum, da_file, 4) != 0)\n-\t\t{\n-\t\t  fprintf (stderr,\n-\t\t\t   \"arc profiling: Error writing output file %s.\\n\",\n-\t\t\t   ptr->filename);\n-\t\t  break;\n-\t\t}\n-\n-\t      if (__write_long (fn_info->arc_count, da_file, 4) != 0)\n-\t\t{\n-\t\t  fprintf (stderr,\n-\t\t\t   \"arc profiling: Error writing output file %s.\\n\",\n-\t\t\t   ptr->filename);\n-\t\t  break;\n-\t\t}\n-\n+\t      if (__write_gcov_string (fn_info->name,\n+\t\t\t\t       strlen (fn_info->name), da_file, -1)\n+\t\t  || __write_long (fn_info->checksum, da_file, 4)\n+\t\t  || __write_long (fn_info->arc_count, da_file, 4))\n+\t\tgoto write_error;\n+\t      \n \t      for (i = fn_info->arc_count; i > 0; i--, count_ptr++)\n-\t\t{\n-\t\t  if (__write_gcov_type (*count_ptr, da_file, 8) != 0)\n-\t\t    break;\n-\t\t}\n-\n-\t      if (i)\t\t/* there was an error */\n-\t\t{\n-\t\t  fprintf (stderr,\n-\t\t\t   \"arc profiling: Error writing output file %s.\\n\",\n-\t\t\t   ptr->filename);\n-\t\t  break;\n-\t\t}\n+\t\tif (__write_gcov_type (*count_ptr, da_file, 8))\n+\t\t  goto write_error; /* RIP Edsger Dijkstra */\n \t    }\n \t}\n \n-      if (fclose (da_file) != 0)\n-\tfprintf (stderr, \"arc profiling: Error closing output file %s.\\n\",\n-\t\t ptr->filename);\n+      if (fclose (da_file))\n+\t{\n+\t  fprintf (stderr, \"arc profiling: Error closing output file %s.\\n\",\n+\t\t   ptr->filename);\n+\t  error = 1;\n+\t}\n+      if (error || !merging)\n+\tptr->filename = 0;\n     }\n+\n+  /* Upate whole program statistics.  */\n+  for (ptr = bb_head; ptr; ptr = ptr->next)\n+    if (ptr->filename)\n+      {\n+\tFILE *da_file;\n+\t\n+\tda_file = fopen (ptr->filename, \"r+b\");\n+\tif (!da_file)\n+\t  {\n+\t    fprintf (stderr, \"arc profiling: Cannot reopen %s.\\n\",\n+\t\t     ptr->filename);\n+\t    continue;\n+\t  }\n+\t\n+#if defined (TARGET_HAS_F_SETLKW)\n+\twhile (fcntl (fileno (da_file), F_SETLKW, &s_flock)\n+\t       && errno == EINTR)\n+\t  continue;\n+#endif\n+\t\n+\tif (fseek (da_file, 4 * 3, SEEK_SET)\n+\t    /* number of instrumented arcs.  */\n+\t    || __write_long (program_arcs, da_file, 4)\n+\t    /* sum of counters.  */\n+\t    || __write_gcov_type (program_sum, da_file, 8)\n+\t    /* maximal counter.  */\n+\t    || __write_gcov_type (program_max, da_file, 8))\n+\t  fprintf (stderr, \"arc profiling: Error updating program header %s.\\n\",\n+\t\t   ptr->filename);\n+\tif (fclose (da_file))\n+\t  fprintf (stderr, \"arc profiling: Error reclosing %s\\n\",\n+\t\t   ptr->filename);\n+      }\n }\n \n+/* Add a new object file onto the bb chain.  Invoked automatically\n+   when running an object file's global ctors.  */\n+\n void\n __bb_init_func (struct bb *blocks)\n {\n-  /* User is supposed to check whether the first word is non-0,\n-     but just in case....  */\n-\n   if (blocks->zero_word)\n     return;\n \n@@ -1473,6 +1549,7 @@ __bb_init_func (struct bb *blocks)\n /* Called before fork or exec - write out profile information gathered so\n    far and reset it to zero.  This avoids duplication or loss of the\n    profile information gathered so far.  */\n+\n void\n __bb_fork_func (void)\n {"}]}