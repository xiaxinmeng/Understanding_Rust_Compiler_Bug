{"sha": "ea22ec90df9649465b172269027fff8f0750047b", "node_id": "C_kwDOANBUbNoAKGVhMjJlYzkwZGY5NjQ5NDY1YjE3MjI2OTAyN2ZmZjhmMDc1MDA0N2I", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2022-01-20T21:36:16Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-10T08:19:26Z"}, "message": "[Ada] Cleanup unnecessary declare block in Check_Unreachable_Code\n\nCleanup related to static detection of references to uninitialized\nvariables. Semantics is unaffected.\n\ngcc/ada/\n\n\t* sem_ch5.adb (Check_Unreachable_Code): Remove inner declare\n\tblock; refill code and comments.", "tree": {"sha": "c90c89b546c18236308b896e487f16c33d403c33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c90c89b546c18236308b896e487f16c33d403c33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea22ec90df9649465b172269027fff8f0750047b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea22ec90df9649465b172269027fff8f0750047b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea22ec90df9649465b172269027fff8f0750047b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea22ec90df9649465b172269027fff8f0750047b/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d421523a42d50e1004d5bbe30e4c45b2b98f1a03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d421523a42d50e1004d5bbe30e4c45b2b98f1a03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d421523a42d50e1004d5bbe30e4c45b2b98f1a03"}], "stats": {"total": 200, "additions": 98, "deletions": 102}, "files": [{"sha": "81767d8c324dc751b815cf4f59552677a1eb71e1", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 98, "deletions": 102, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea22ec90df9649465b172269027fff8f0750047b/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea22ec90df9649465b172269027fff8f0750047b/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=ea22ec90df9649465b172269027fff8f0750047b", "patch": "@@ -4397,149 +4397,145 @@ package body Sem_Ch5 is\n \n    procedure Check_Unreachable_Code (N : Node_Id) is\n       Error_Node : Node_Id;\n+      Nxt        : Node_Id;\n       P          : Node_Id;\n \n    begin\n       if Is_List_Member (N) and then Comes_From_Source (N) then\n-         declare\n-            Nxt : Node_Id;\n+         Nxt := Original_Node (Next (N));\n \n-         begin\n-            Nxt := Original_Node (Next (N));\n+         --  Skip past pragmas\n \n-            --  Skip past pragmas\n+         while Nkind (Nxt) = N_Pragma loop\n+            Nxt := Original_Node (Next (Nxt));\n+         end loop;\n \n-            while Nkind (Nxt) = N_Pragma loop\n-               Nxt := Original_Node (Next (Nxt));\n-            end loop;\n+         --  If a label follows us, then we never have dead code, since someone\n+         --  could branch to the label, so we just ignore it.\n \n-            --  If a label follows us, then we never have dead code, since\n-            --  someone could branch to the label, so we just ignore it.\n+         if Nkind (Nxt) = N_Label then\n+            return;\n \n-            if Nkind (Nxt) = N_Label then\n-               return;\n+         --  Otherwise see if we have a real statement following us\n \n-            --  Otherwise see if we have a real statement following us\n+         elsif Present (Nxt)\n+           and then Comes_From_Source (Nxt)\n+           and then Is_Statement (Nxt)\n+         then\n+            --  Special very annoying exception. If we have a return that\n+            --  follows a raise, then we allow it without a warning, since\n+            --  the Ada RM annoyingly requires a useless return here.\n \n-            elsif Present (Nxt)\n-              and then Comes_From_Source (Nxt)\n-              and then Is_Statement (Nxt)\n+            if Nkind (Original_Node (N)) /= N_Raise_Statement\n+              or else Nkind (Nxt) /= N_Simple_Return_Statement\n             then\n-               --  Special very annoying exception. If we have a return that\n-               --  follows a raise, then we allow it without a warning, since\n-               --  the Ada RM annoyingly requires a useless return here.\n-\n-               if Nkind (Original_Node (N)) /= N_Raise_Statement\n-                 or else Nkind (Nxt) /= N_Simple_Return_Statement\n-               then\n-                  --  The rather strange shenanigans with the warning message\n-                  --  here reflects the fact that Kill_Dead_Code is very good\n-                  --  at removing warnings in deleted code, and this is one\n-                  --  warning we would prefer NOT to have removed.\n-\n-                  Error_Node := Nxt;\n+               --  The rather strange shenanigans with the warning message\n+               --  here reflects the fact that Kill_Dead_Code is very good at\n+               --  removing warnings in deleted code, and this is one warning\n+               --  we would prefer NOT to have removed.\n \n-                  --  If we have unreachable code, analyze and remove the\n-                  --  unreachable code, since it is useless and we don't\n-                  --  want to generate junk warnings.\n+               Error_Node := Nxt;\n \n-                  --  We skip this step if we are not in code generation mode\n-                  --  or CodePeer mode.\n+               --  If we have unreachable code, analyze and remove the\n+               --  unreachable code, since it is useless and we don't want\n+               --  to generate junk warnings.\n \n-                  --  This is the one case where we remove dead code in the\n-                  --  semantics as opposed to the expander, and we do not want\n-                  --  to remove code if we are not in code generation mode,\n-                  --  since this messes up the tree or loses useful information\n-                  --  for CodePeer.\n+               --  We skip this step if we are not in code generation mode\n+               --  or CodePeer mode.\n \n-                  --  Note that one might react by moving the whole circuit to\n-                  --  exp_ch5, but then we lose the warning in -gnatc mode.\n+               --  This is the one case where we remove dead code in the\n+               --  semantics as opposed to the expander, and we do not want\n+               --  to remove code if we are not in code generation mode, since\n+               --  this messes up the tree or loses useful information for\n+               --  CodePeer.\n \n-                  if Operating_Mode = Generate_Code\n-                    and then not CodePeer_Mode\n-                  then\n-                     loop\n-                        Nxt := Next (N);\n+               --  Note that one might react by moving the whole circuit to\n+               --  exp_ch5, but then we lose the warning in -gnatc mode.\n \n-                        --  Quit deleting when we have nothing more to delete\n-                        --  or if we hit a label (since someone could transfer\n-                        --  control to a label, so we should not delete it).\n+               if Operating_Mode = Generate_Code\n+                 and then not CodePeer_Mode\n+               then\n+                  loop\n+                     Nxt := Next (N);\n \n-                        exit when No (Nxt) or else Nkind (Nxt) = N_Label;\n+                     --  Quit deleting when we have nothing more to delete\n+                     --  or if we hit a label (since someone could transfer\n+                     --  control to a label, so we should not delete it).\n \n-                        --  Statement/declaration is to be deleted\n+                     exit when No (Nxt) or else Nkind (Nxt) = N_Label;\n \n-                        Analyze (Nxt);\n-                        Remove (Nxt);\n-                        Kill_Dead_Code (Nxt);\n-                     end loop;\n-                  end if;\n+                     --  Statement/declaration is to be deleted\n \n-                  Error_Msg\n-                    (\"??unreachable code!\", Sloc (Error_Node), Error_Node);\n+                     Analyze (Nxt);\n+                     Remove (Nxt);\n+                     Kill_Dead_Code (Nxt);\n+                  end loop;\n                end if;\n \n-            --  If the unconditional transfer of control instruction is the\n-            --  last statement of a sequence, then see if our parent is one of\n-            --  the constructs for which we count unblocked exits, and if so,\n-            --  adjust the count.\n-\n-            else\n-               P := Parent (N);\n+               Error_Msg\n+                 (\"??unreachable code!\", Sloc (Error_Node), Error_Node);\n+            end if;\n \n-               --  Statements in THEN part or ELSE part of IF statement\n+         --  If the unconditional transfer of control instruction is the\n+         --  last statement of a sequence, then see if our parent is one of\n+         --  the constructs for which we count unblocked exits, and if so,\n+         --  adjust the count.\n \n-               if Nkind (P) = N_If_Statement then\n-                  null;\n+         else\n+            P := Parent (N);\n \n-               --  Statements in ELSIF part of an IF statement\n+            --  Statements in THEN part or ELSE part of IF statement\n \n-               elsif Nkind (P) = N_Elsif_Part then\n-                  P := Parent (P);\n-                  pragma Assert (Nkind (P) = N_If_Statement);\n+            if Nkind (P) = N_If_Statement then\n+               null;\n \n-               --  Statements in CASE statement alternative\n+            --  Statements in ELSIF part of an IF statement\n \n-               elsif Nkind (P) = N_Case_Statement_Alternative then\n-                  P := Parent (P);\n-                  pragma Assert (Nkind (P) = N_Case_Statement);\n+            elsif Nkind (P) = N_Elsif_Part then\n+               P := Parent (P);\n+               pragma Assert (Nkind (P) = N_If_Statement);\n \n-               --  Statements in body of block\n+            --  Statements in CASE statement alternative\n \n-               elsif Nkind (P) = N_Handled_Sequence_Of_Statements\n-                 and then Nkind (Parent (P)) = N_Block_Statement\n-               then\n-                  --  The original loop is now placed inside a block statement\n-                  --  due to the expansion of attribute 'Loop_Entry. Return as\n-                  --  this is not a \"real\" block for the purposes of exit\n-                  --  counting.\n+            elsif Nkind (P) = N_Case_Statement_Alternative then\n+               P := Parent (P);\n+               pragma Assert (Nkind (P) = N_Case_Statement);\n \n-                  if Nkind (N) = N_Loop_Statement\n-                    and then Subject_To_Loop_Entry_Attributes (N)\n-                  then\n-                     return;\n-                  end if;\n+            --  Statements in body of block\n \n-               --  Statements in exception handler in a block\n+            elsif Nkind (P) = N_Handled_Sequence_Of_Statements\n+              and then Nkind (Parent (P)) = N_Block_Statement\n+            then\n+               --  The original loop is now placed inside a block statement\n+               --  due to the expansion of attribute 'Loop_Entry. Return as\n+               --  this is not a \"real\" block for the purposes of exit\n+               --  counting.\n \n-               elsif Nkind (P) = N_Exception_Handler\n-                 and then Nkind (Parent (P)) = N_Handled_Sequence_Of_Statements\n-                 and then Nkind (Parent (Parent (P))) = N_Block_Statement\n+               if Nkind (N) = N_Loop_Statement\n+                 and then Subject_To_Loop_Entry_Attributes (N)\n                then\n-                  null;\n-\n-               --  None of these cases, so return\n-\n-               else\n                   return;\n                end if;\n \n-               --  This was one of the cases we are looking for (i.e. the\n-               --  parent construct was IF, CASE or block) so decrement count.\n+            --  Statements in exception handler in a block\n \n-               Unblocked_Exit_Count := Unblocked_Exit_Count - 1;\n+            elsif Nkind (P) = N_Exception_Handler\n+              and then Nkind (Parent (P)) = N_Handled_Sequence_Of_Statements\n+              and then Nkind (Parent (Parent (P))) = N_Block_Statement\n+            then\n+               null;\n+\n+            --  None of these cases, so return\n+\n+            else\n+               return;\n             end if;\n-         end;\n+\n+            --  This was one of the cases we are looking for (i.e. the parent\n+            --  construct was IF, CASE or block) so decrement count.\n+\n+            Unblocked_Exit_Count := Unblocked_Exit_Count - 1;\n+         end if;\n       end if;\n    end Check_Unreachable_Code;\n "}]}