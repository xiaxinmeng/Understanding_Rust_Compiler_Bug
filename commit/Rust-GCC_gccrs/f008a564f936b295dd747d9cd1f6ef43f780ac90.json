{"sha": "f008a564f936b295dd747d9cd1f6ef43f780ac90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAwOGE1NjRmOTM2YjI5NWRkNzQ3ZDljZDFmNmVmNDNmNzgwYWM5MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-05-26T03:34:33Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-05-26T03:34:33Z"}, "message": "bb-reorder.c (reorder_block_def): Reorder elements for size.\n\n        * bb-reorder.c (reorder_block_def): Reorder elements for size.\n        Remove add_jump; add next; replace flags with visited.\n        (rbd_init): Remove.\n        (REORDER_BLOCK_HEAD, REORDER_BLOCK_VISITED): Remove.\n        (REORDER_BLOCK_FLAGS, REORDER_BLOCK_INDEX): Remove.\n        (REORDER_BLOCK_ADD_JUMP, REORDER_BLOCK_EFF_HEAD): Remove.\n        (REORDER_BLOCK_EFF_END, REORDER_BLOCK_SCOPE): Remove.\n        (RBI): New.\n        (reorder_index, reorder_last_visited): Remove.\n        (skip_insns_after_block): Rewrite to use a switch.\n        (get_common_dest): Remove.\n        (chain_reorder_blocks): Remove.\n        (record_effective_endpoints): Split out from reorder_basic_blocks.\n        (make_reorder_chain): Likewise.  Loop until all blocks are placed.\n        (make_reorder_chain_1): Renamed from old make_reorder_chain.\n        Only construct the reorder chain, do not move insns.  Try harder\n        to tail recurse.\n        (label_for_bb, emit_jump_to_block_after): New.\n        (fixup_reorder_chain): Use them.  Do bulk block movement.  Examine\n        and adjust the jump insns appropriately.  Fixup basic_block_info.\n        (verify_insn_chain): Always define.\n        (relate_bbs_with_scopes): Call xmalloc, not xcalloc.  Fix thinko\n        in allocation size.\n        (make_new_scope): Don't write zeros to calloc'd space.\n        (build_scope_forest): Rely on xrealloc to DTRT.\n        (reorder_basic_blocks): Don't build loop nest.  Don't fail if\n        profile_arc_flag.  Streamline EH test.\n\n\t* flow.c (redirect_edge_succ, redirect_edge_pred): New.\n\t* basic-block.h: Declare them.\n\nFrom-SVN: r34186", "tree": {"sha": "6f09bc3a30550e07ac1b44c5aa7edd9d40f1e562", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f09bc3a30550e07ac1b44c5aa7edd9d40f1e562"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f008a564f936b295dd747d9cd1f6ef43f780ac90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f008a564f936b295dd747d9cd1f6ef43f780ac90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f008a564f936b295dd747d9cd1f6ef43f780ac90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f008a564f936b295dd747d9cd1f6ef43f780ac90/comments", "author": null, "committer": null, "parents": [{"sha": "49080ead6d708777280760aeab58b8c626b589c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49080ead6d708777280760aeab58b8c626b589c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49080ead6d708777280760aeab58b8c626b589c1"}], "stats": {"total": 1135, "additions": 586, "deletions": 549}, "files": [{"sha": "f2f27275cf9bf1827ff69a52518583c811c1d6f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f008a564f936b295dd747d9cd1f6ef43f780ac90/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f008a564f936b295dd747d9cd1f6ef43f780ac90/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f008a564f936b295dd747d9cd1f6ef43f780ac90", "patch": "@@ -1,3 +1,36 @@\n+2000-05-25  Richard Henderson  <rth@cygnus.com>\n+\n+\t* bb-reorder.c (reorder_block_def): Reorder elements for size.\n+\tRemove add_jump; add next; replace flags with visited.\n+\t(rbd_init): Remove.\n+\t(REORDER_BLOCK_HEAD, REORDER_BLOCK_VISITED): Remove.\n+\t(REORDER_BLOCK_FLAGS, REORDER_BLOCK_INDEX): Remove.\n+\t(REORDER_BLOCK_ADD_JUMP, REORDER_BLOCK_EFF_HEAD): Remove.\n+\t(REORDER_BLOCK_EFF_END, REORDER_BLOCK_SCOPE): Remove.\n+\t(RBI): New.\n+\t(reorder_index, reorder_last_visited): Remove.\n+\t(skip_insns_after_block): Rewrite to use a switch.\n+\t(get_common_dest): Remove.\n+\t(chain_reorder_blocks): Remove.\n+\t(record_effective_endpoints): Split out from reorder_basic_blocks.\n+\t(make_reorder_chain): Likewise.  Loop until all blocks are placed.\n+\t(make_reorder_chain_1): Renamed from old make_reorder_chain.\n+\tOnly construct the reorder chain, do not move insns.  Try harder\n+\tto tail recurse.\n+\t(label_for_bb, emit_jump_to_block_after): New.\n+\t(fixup_reorder_chain): Use them.  Do bulk block movement.  Examine\n+\tand adjust the jump insns appropriately.  Fixup basic_block_info.\n+\t(verify_insn_chain): Always define.\n+\t(relate_bbs_with_scopes): Call xmalloc, not xcalloc.  Fix thinko\n+\tin allocation size.\n+\t(make_new_scope): Don't write zeros to calloc'd space.\n+\t(build_scope_forest): Rely on xrealloc to DTRT.\n+\t(reorder_basic_blocks): Don't build loop nest.  Don't fail if\n+\tprofile_arc_flag.  Streamline EH test.\n+\n+\t* flow.c (redirect_edge_succ, redirect_edge_pred): New.\n+\t* basic-block.h: Declare them.\n+\n 2000-05-25  Alexandre Oliva  <aoliva@cygnus.com>\n \n \t* emit-rtl.c (reset_used_decls): New function."}, {"sha": "5d6d2dfcc581b8d639a63931cf04cc0dd4436cf0", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f008a564f936b295dd747d9cd1f6ef43f780ac90/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f008a564f936b295dd747d9cd1f6ef43f780ac90/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=f008a564f936b295dd747d9cd1f6ef43f780ac90", "patch": "@@ -232,6 +232,8 @@ extern void flow_delete_insn_chain\tPARAMS ((rtx, rtx));\n extern void make_edge\t\t\tPARAMS ((sbitmap *, basic_block,\n \t\t\t\t\t\t basic_block, int));\n extern void remove_edge\t\t\tPARAMS ((edge));\n+extern void redirect_edge_succ\t\tPARAMS ((edge, basic_block));\n+extern void redirect_edge_pred\t\tPARAMS ((edge, basic_block));\n extern void create_basic_block\t\tPARAMS ((int, rtx, rtx, rtx));\n extern int flow_delete_block\t\tPARAMS ((basic_block));\n extern void merge_blocks_nomove\t\tPARAMS ((basic_block, basic_block));"}, {"sha": "e5c5efc80ab036ff70f65a7049a3d4a878848a46", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 511, "deletions": 549, "changes": 1060, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f008a564f936b295dd747d9cd1f6ef43f780ac90/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f008a564f936b295dd747d9cd1f6ef43f780ac90/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=f008a564f936b295dd747d9cd1f6ef43f780ac90", "patch": "@@ -22,6 +22,62 @@\n \n    \"Profile Guided Code Positioning\"\n    Pettis and Hanson; PLDI '90.\n+\n+   TODO:\n+\n+   (1) Consider:\n+\n+\t\tif (p) goto A;\t\t// predict taken\n+\t\tfoo ();\n+\t      A:\n+\t\tif (q) goto B;\t\t// predict taken\n+\t\tbar ();\n+\t      B:\n+\t\tbaz ();\n+\t\treturn;\n+\n+       We'll currently reorder this as\n+\n+\t\tif (!p) goto C;\n+\t      A:\n+\t\tif (!q) goto D;\n+\t      B:\n+\t\tbaz ();\n+\t\treturn;\n+\t      D:\n+\t\tbar ();\n+\t\tgoto B;\n+\t      C:\n+\t\tfoo ();\n+\t\tgoto A;\n+\n+       A better ordering is\n+\n+\t\tif (!p) goto C;\n+\t\tif (!q) goto D;\n+\t      B:\n+\t\tbaz ();\n+\t\treturn;\n+\t      C:\n+\t\tfoo ();\n+\t\tif (q) goto B;\n+\t      D:\n+\t\tbar ();\n+\t\tgoto B;\n+\n+       This requires that we be able to duplicate the jump at A, and\n+       adjust the graph traversal such that greedy placement doesn't\n+       fix D before C is considered.\n+\n+   (2) Coordinate with shorten_branches to minimize the number of\n+       long branches.\n+\n+   (3) Invent a method by which sufficiently non-predicted code can\n+       be moved to either the end of the section or another section\n+       entirely.  Some sort of NOTE_INSN note would work fine.\n+\n+       This completely scroggs all debugging formats, so the user\n+       would have to explicitly ask for it.\n */\n \n #include \"config.h\"\n@@ -44,6 +100,11 @@\n #include \"obstack.h\"\n \n \n+#ifndef HAVE_epilogue\n+#define HAVE_epilogue 0\n+#endif\n+\n+\n /* The contents of the current function definition are allocated\n    in this obstack, and all are freed at the end of the function.\n    For top-level functions, this is temporary_obstack.\n@@ -88,6 +149,7 @@ typedef struct scope_def\n   struct scope_def *next;\n } *scope;\n \n+\n /* Structure to hold information about the scope forest.  */\n typedef struct\n {\n@@ -98,62 +160,28 @@ typedef struct\n   scope *trees;\n } scope_forest_info;\n \n-\n-typedef struct reorder_block_def {\n-  int flags;\n-  int index;\n-  basic_block add_jump;\n+/* Structure to hold information about the blocks during reordering.  */\n+typedef struct reorder_block_def\n+{\n   rtx eff_head;\n   rtx eff_end;\n   scope scope;\n+  basic_block next;\n+  int index;\n+  int visited;\n } *reorder_block_def;\n \n-static struct reorder_block_def rbd_init\n-= {\n-    0,\t\t\t/* flags */\n-    0,\t\t\t/* index */\n-    NULL,\t\t/* add_jump */\n-    NULL_RTX,\t\t/* eff_head */\n-    NULL_RTX,\t\t/* eff_end */\n-    NULL\t\t/* scope */\n-};\n-\n-\n-#define REORDER_BLOCK_HEAD\t0x1\n-#define REORDER_BLOCK_VISITED\t0x2\n-  \n-#define REORDER_BLOCK_FLAGS(bb) \\\n-  ((reorder_block_def) (bb)->aux)->flags\n-\n-#define REORDER_BLOCK_INDEX(bb) \\\n-  ((reorder_block_def) (bb)->aux)->index\n-\n-#define REORDER_BLOCK_ADD_JUMP(bb) \\\n-  ((reorder_block_def) (bb)->aux)->add_jump\n-\n-#define REORDER_BLOCK_EFF_HEAD(bb) \\\n-  ((reorder_block_def) (bb)->aux)->eff_head\n-\n-#define REORDER_BLOCK_EFF_END(bb) \\\n-  ((reorder_block_def) (bb)->aux)->eff_end\n-\n-#define REORDER_BLOCK_SCOPE(bb) \\\n-  ((reorder_block_def) (bb)->aux)->scope\n-\n-\n-static int reorder_index;\n-static basic_block reorder_last_visited;\n+#define RBI(BB)\t((reorder_block_def) (BB)->aux)\n \n \n /* Local function prototypes.  */\n static rtx skip_insns_after_block\tPARAMS ((basic_block));\n-static basic_block get_common_dest\tPARAMS ((basic_block, basic_block));\n-static basic_block chain_reorder_blocks\tPARAMS ((edge, basic_block));\n-static void make_reorder_chain\t\tPARAMS ((basic_block));\n+static void record_effective_endpoints\tPARAMS ((void));\n+static void make_reorder_chain\t\tPARAMS ((void));\n+static basic_block make_reorder_chain_1\tPARAMS ((basic_block, basic_block));\n+static rtx label_for_bb\t\t\tPARAMS ((basic_block));\n+static rtx emit_jump_to_block_after\tPARAMS ((basic_block, rtx));\n static void fixup_reorder_chain\t\tPARAMS ((void));\n-#ifdef ENABLE_CHECKING\n-static void verify_insn_chain\t\tPARAMS ((void));\n-#endif\n static void relate_bbs_with_scopes\tPARAMS ((scope));\n static scope make_new_scope\t\tPARAMS ((int, rtx));\n static void build_scope_forest\t\tPARAMS ((scope_forest_info *));\n@@ -169,6 +197,8 @@ static void dump_scope_forest_1\t\tPARAMS ((scope, int));\n static rtx get_next_bb_note\t\tPARAMS ((rtx));\n static rtx get_prev_bb_note\t\tPARAMS ((rtx));\n \n+void verify_insn_chain\t\t\tPARAMS ((void));\n+\f\n /* Skip over inter-block insns occurring after BB which are typically\n    associated with BB (e.g., barriers). If there are any such insns,\n    we return the last one. Otherwise, we return the end of BB.  */\n@@ -177,42 +207,50 @@ static rtx\n skip_insns_after_block (bb)\n      basic_block bb;\n {\n-  rtx insn, last_insn;\n-\n-  last_insn = bb->end;\n+  rtx insn, last_insn, next_head;\n \n-  if (bb == EXIT_BLOCK_PTR)\n-    return 0;\n+  next_head = NULL_RTX;\n+  if (bb->index + 1 != n_basic_blocks)\n+    next_head = BASIC_BLOCK (bb->index + 1)->head;\n \n-  for (insn = NEXT_INSN (bb->end); \n-       insn;\n-       last_insn = insn, insn = NEXT_INSN (insn))\n+  for (last_insn = bb->end; (insn = NEXT_INSN (last_insn)); last_insn = insn)\n     {\n-      if (bb->index + 1 != n_basic_blocks\n-\t  && insn == BASIC_BLOCK (bb->index + 1)->head)\n+      if (insn == next_head)\n \tbreak;\n \n-      if (GET_CODE (insn) == BARRIER\n-\t  || GET_CODE (insn) == JUMP_INSN \n-\t  || (GET_CODE (insn) == NOTE\n-\t      && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END\n-\t\t  || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)))\n-\tcontinue;\n-\n-      if (GET_CODE (insn) == CODE_LABEL\n-\t  && GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n-\t  && (GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_VEC\n-\t      || GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_DIFF_VEC))\n+      switch (GET_CODE (insn))\n \t{\n-\t  insn = NEXT_INSN (insn);\n+\tcase BARRIER:\n \t  continue;\n-\t}\n \n-      /* Skip to next non-deleted insn.  */\n-      if (GET_CODE (insn) == NOTE\n-\t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED\n-\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED_LABEL))\n-\tcontinue; \n+\tcase NOTE:\n+\t  switch (NOTE_LINE_NUMBER (insn))\n+\t    {\n+\t    case NOTE_INSN_LOOP_END:\n+\t    case NOTE_INSN_BLOCK_END:\n+\t    case NOTE_INSN_DELETED:\n+\t    case NOTE_INSN_DELETED_LABEL:\n+\t      continue;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t  break;\n+\n+\tcase CODE_LABEL:\n+\t  if (NEXT_INSN (insn)\n+\t      && GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n+\t      && (GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_VEC\n+\t          || GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_DIFF_VEC))\n+\t    {\n+\t      insn = NEXT_INSN (insn);\n+\t      continue;\n+\t    }\n+          break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n \n       break;\n     }\n@@ -221,431 +259,447 @@ skip_insns_after_block (bb)\n }\n \n \n-/* Return common destination for blocks BB0 and BB1.  */\n+/* Locate the effective beginning and end of the insn chain for each\n+   block, as defined by skip_insns_after_block above.  */\n \n-static basic_block\n-get_common_dest (bb0, bb1)\n-     basic_block bb0, bb1;\n+static void\n+record_effective_endpoints ()\n {\n-  edge e0, e1;\n-\n-  for (e0 = bb0->succ; e0; e0 = e0->succ_next)\n+  rtx next_insn = get_insns ();\n+  int i;\n+  \n+  for (i = 0; i < n_basic_blocks; ++i)\n     {\n-      for (e1 = bb1->succ; e1; e1 = e1->succ_next)\n-\t{\n-\t  if (e0->dest == e1->dest)\n-\t    {\n-\t      return e0->dest;\n-\t    }\n-\t}\n+      basic_block bb = BASIC_BLOCK (i);\n+      rtx end;\n+\n+      RBI (bb)->eff_head = next_insn;\n+      end = skip_insns_after_block (bb);\n+      RBI (bb)->eff_end = end;\n+      next_insn = NEXT_INSN (end);\n     }\n-  return 0;\n }\n \n \n-/* Move the destination block for edge E after chain end block CEB\n-   Adding jumps and labels is deferred until fixup_reorder_chain.  */\n+/* Compute an ordering for a subgraph beginning with block BB.  Record the\n+   ordering in RBI()->index and chained through RBI()->next.  */\n \n-static basic_block\n-chain_reorder_blocks (e, ceb)\n-     edge e;\n-     basic_block ceb;\n+static void\n+make_reorder_chain ()\n {\n-  basic_block sb = e->src;\n-  basic_block db = e->dest;\n-  rtx cebe_insn, dbh_insn, dbe_insn;\n-  edge ee, last_edge;\n-  edge e_fallthru, e_jump;\n-\n-  enum cond_types {NO_COND, PREDICT_THEN_WITH_ELSE, PREDICT_ELSE,\n-\t\t   PREDICT_THEN_NO_ELSE, PREDICT_NOT_THEN_NO_ELSE};\n-  enum cond_types cond_type;\n-  enum cond_block_types {NO_COND_BLOCK, THEN_BLOCK, ELSE_BLOCK,\n-\t\t\t NO_ELSE_BLOCK};\n-  enum cond_block_types cond_block_type;\n-\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file,\n-\t     \"Edge from basic block %d to basic block %d last visited %d\\n\",\n-\t     sb->index, db->index, ceb->index);\n-  cebe_insn = REORDER_BLOCK_EFF_END (ceb);\n-\n-  /* Blocks are in original order.  */\n-  if (sb->index == ceb->index\n-      && ceb->index + 1 == db->index && NEXT_INSN (cebe_insn))\n-    return db;\n-\n-  e_fallthru = e_jump = e;\n-\n-  /* Get the type of block and type of condition.  */\n-  cond_type = NO_COND;\n-  cond_block_type = NO_COND_BLOCK;\n-  if (GET_CODE (sb->end) == JUMP_INSN && ! simplejump_p (sb->end)\n-      && condjump_p (sb->end))\n+  basic_block last_block = NULL;\n+  basic_block prev = NULL;\n+  int nbb_m1 = n_basic_blocks - 1;\n+\n+  /* If we've not got epilogue in RTL, we must fallthru to the exit.\n+     Force the last block to be at the end.  */\n+  /* ??? Some ABIs (e.g. MIPS) require the return insn to be at the\n+     end of the function for stack unwinding purposes.  */\n+  if (! HAVE_epilogue)\n     {\n-      if (e->flags & EDGE_FALLTHRU)\n-\t{\n-\t  if (e == sb->succ)\n-\t    e_jump = sb->succ->succ_next;\n-\t  else if (e == sb->succ->succ_next)\n-\t    e_jump = sb->succ;\n-\t  else\n-\t    abort ();\n-\t}\n-      else\n-\t{\n-\t  if (e == sb->succ)\n-\t    e_fallthru = sb->succ->succ_next;\n-\t  else if (e == sb->succ->succ_next)\n-\t    e_fallthru = sb->succ;\n-\t  else\n-\t    abort ();\n-\t}\n+      last_block = BASIC_BLOCK (nbb_m1);\n+      RBI (last_block)->visited = 1;\n+      nbb_m1 -= 1;\n+    }\n \n-      if (e->flags & EDGE_FALLTHRU)\n-\tcond_block_type = THEN_BLOCK;\n-      else if (get_common_dest (e_fallthru->dest, sb))\n-\tcond_block_type = NO_ELSE_BLOCK;\n-      else \n-\tcond_block_type = ELSE_BLOCK;\n+  /* Loop until we've placed every block.  */\n+  do\n+    {\n+      int i;\n+      basic_block next = NULL;\n \n-      if (get_common_dest (e_fallthru->dest, sb))\n-\t{\n-\t  if (cond_block_type == THEN_BLOCK)\n-\t    {\n-\t      if (! (REORDER_BLOCK_FLAGS (e->dest)\n-\t\t     & REORDER_BLOCK_VISITED))\n-\t\tcond_type = PREDICT_THEN_NO_ELSE;\n-\t      else\n-\t\tcond_type = PREDICT_NOT_THEN_NO_ELSE;\n-\t    }\n-\t  else if (cond_block_type == NO_ELSE_BLOCK)\n-\t    {\n-\t      if (! (REORDER_BLOCK_FLAGS (e->dest)\n-\t\t     & REORDER_BLOCK_VISITED))\n-\t\tcond_type = PREDICT_NOT_THEN_NO_ELSE;\n-\t      else\n-\t\tcond_type = PREDICT_THEN_NO_ELSE;\n-\t    }\n-\t}\n-      else\n+      /* Find the next unplaced block.  */\n+      /* ??? Get rid of this loop, and track which blocks are not yet\n+\t placed more directly, so as to avoid the O(N^2) worst case.\n+\t Perhaps keep a doubly-linked list of all to-be-placed blocks;\n+\t remove from the list as we place.  The head of that list is\n+\t what we're looking for here.  */\n+\n+      for (i = 0; i <= nbb_m1; ++i)\n \t{\n-\t  if (cond_block_type == THEN_BLOCK)\n-\t    {\n-\t      if (! (REORDER_BLOCK_FLAGS (e->dest)\n-\t\t     & REORDER_BLOCK_VISITED))\n-\t\tcond_type = PREDICT_THEN_WITH_ELSE;\n-\t      else\n-\t\tcond_type = PREDICT_ELSE;\n-\t    }\n-\t  else if (cond_block_type == ELSE_BLOCK\n-\t\t   && e_fallthru->dest != EXIT_BLOCK_PTR)\n+\t  basic_block bb = BASIC_BLOCK (i);\n+\t  if (! RBI (bb)->visited)\n \t    {\n-\t      if (! (REORDER_BLOCK_FLAGS (e->dest)\n-\t\t     & REORDER_BLOCK_VISITED))\n-\t\tcond_type = PREDICT_ELSE;\n-\t      else\n-\t\tcond_type = PREDICT_THEN_WITH_ELSE;\n+\t      next = bb;\n+\t      break;\n \t    }\n \t}\n+      if (! next)\n+\tabort ();\n+\n+      prev = make_reorder_chain_1 (next, prev);\n     }\n-  \n-  if (rtl_dump_file)\n+  while (RBI (prev)->index < nbb_m1);\n+\n+  /* Terminate the chain.  */\n+  if (! HAVE_epilogue)\n     {\n-      static const char * cond_type_str [] = {\"not cond jump\", \"predict then\",\n-\t\t\t\t\t      \"predict else\",\n-\t\t\t\t\t      \"predict then w/o else\",\n-\t\t\t\t\t      \"predict not then w/o else\"};\n-      static const char * cond_block_type_str [] = {\"not then or else block\",\n-\t\t\t\t\t\t    \"then block\",\n-\t\t\t\t\t\t    \"else block\",\n-\t\t\t\t\t\t    \"then w/o else block\"};\n-\n-      fprintf (rtl_dump_file, \"     %s (looking at %s)\\n\",\n-\t       cond_type_str[(int)cond_type],\n-\t       cond_block_type_str[(int)cond_block_type]);\n+      RBI (prev)->next = last_block;\n+      RBI (last_block)->index = RBI (prev)->index + 1;\n+      prev = last_block;\n     }\n+  RBI (prev)->next = NULL;\n+}\n \n-  /* Reflect that then block will move and we'll jump to it.  */\n-  if (cond_block_type != THEN_BLOCK\n-      && (cond_type == PREDICT_ELSE\n-\t  || cond_type == PREDICT_NOT_THEN_NO_ELSE))\n-    {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file,\n-\t\t \"    then jump from block %d to block %d\\n\",\n-\t\t sb->index, e_fallthru->dest->index);\n+/* A helper function for make_reorder_chain.\n \n-      /* Jump to reordered then block.  */\n-      REORDER_BLOCK_ADD_JUMP (sb) = e_fallthru->dest;\n-    }\n-  \n-  /* Reflect that then block will jump back when we have no else.  */\n-  if (cond_block_type != THEN_BLOCK\n-      && cond_type == PREDICT_NOT_THEN_NO_ELSE)\n-    {\n-      basic_block jbb = e_fallthru->dest;\n-      for (ee = jbb->succ;\n-\t   ee && ! (ee->flags & EDGE_FALLTHRU);\n-\t   ee = ee->succ_next)\n-\tcontinue;\n+   We do not follow EH edges, or non-fallthru edges to noreturn blocks.\n+   These are assumed to be the error condition and we wish to cluster\n+   all of them at the very end of the function for the benefit of cache\n+   locality for the rest of the function.\n \n-      if (ee && ! (GET_CODE (jbb->end) == JUMP_INSN\n-\t\t   && ! simplejump_p (jbb->end)))\n-\t{\n-\t  REORDER_BLOCK_ADD_JUMP (jbb) = ee->dest;\n-\t}\n-    }\n+   ??? We could do slightly better by noticing earlier that some subgraph\n+   has all paths leading to noreturn functions, but for there to be more\n+   than one block in such a subgraph is rare.  */\n \n-  /* Reflect that else block will jump back.  */\n-  if (cond_block_type == ELSE_BLOCK\n-      && (cond_type == PREDICT_THEN_WITH_ELSE || cond_type == PREDICT_ELSE))\n+static basic_block\n+make_reorder_chain_1 (bb, prev)\n+     basic_block bb;\n+     basic_block prev;\n+{\n+  edge e;\n+  basic_block next;\n+  rtx note;\n+\n+  /* Mark this block visited.  */\n+  if (prev)\n     {\n-      last_edge=db->succ;\n+      int new_index;\n \n-      if (last_edge\n-\t  && last_edge->dest != EXIT_BLOCK_PTR\n-\t  && GET_CODE (last_edge->dest->head) == CODE_LABEL\n-\t  && ! (GET_CODE (db->end) == JUMP_INSN))\n-\t{\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file,\n-\t\t     \"     else jump from block %d to block %d\\n\",\n-\t\t     db->index, last_edge->dest->index);\n+ restart:\n+      RBI (prev)->next = bb;\n+      new_index = RBI (prev)->index + 1;\n+      RBI (bb)->index = new_index;\n \n-\t  REORDER_BLOCK_ADD_JUMP (db) = last_edge->dest;\n-\t}\n+      if (rtl_dump_file && prev->index + 1 != bb->index)\n+\tfprintf (rtl_dump_file, \"Reordering block %d (%d) after %d (%d)\\n\",\n+\t\t bb->index, RBI (bb)->index, prev->index, RBI (prev)->index);\n     }\n+  else\n+    RBI (bb)->index = 0;\n+  RBI (bb)->visited = 1;\n+  prev = bb;\n \n-  /* This block's successor has already been reordered. This can happen\n-     when we reorder a chain starting at a then or else.  */\n-  for (last_edge = db->succ;\n-       last_edge && ! (last_edge->flags & EDGE_FALLTHRU);\n-       last_edge = last_edge->succ_next)\n-    continue;\n-\n-  if (last_edge\n-      && last_edge->dest != EXIT_BLOCK_PTR\n-      && (REORDER_BLOCK_FLAGS (last_edge->dest)\n-\t  & REORDER_BLOCK_VISITED))\n+  if (bb->succ == NULL)\n+    return prev;\n+\n+  /* Find the most probable block.  */\n+\n+  next = NULL;\n+  if (any_condjump_p (bb->end)\n+      && (note = find_reg_note (bb->end, REG_BR_PROB, 0)) != NULL)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file,\n-\t\t \"     end of chain jump from block %d to block %d\\n\",\n-\t\t db->index, last_edge->dest->index);\n+      int taken, probability;\n+      edge e_taken, e_fall;\n \n-      REORDER_BLOCK_ADD_JUMP (db) = last_edge->dest;\n+      probability = INTVAL (XEXP (note, 0));\n+      taken = probability > REG_BR_PROB_BASE / 2;\n+\n+      /* Find the normal taken edge and the normal fallthru edge.\n+         Note that there may in fact be other edges due to\n+\t asynchronous_exceptions.  */\n+\n+      e_taken = e_fall = NULL;\n+      for (e = bb->succ; e ; e = e->succ_next)\n+\tif (e->flags & EDGE_FALLTHRU)\n+\t  e_fall = e;\n+\telse if (! (e->flags & EDGE_EH))\n+\t  e_taken = e;\n+\n+      next = (taken ? e_taken : e_fall)->dest;\n     }\n \n-  dbh_insn = REORDER_BLOCK_EFF_HEAD (db);\n-  cebe_insn = REORDER_BLOCK_EFF_END (ceb);\n-  dbe_insn = REORDER_BLOCK_EFF_END (db);\n+  /* In the absence of a prediction, disturb things as little as possible\n+     by selecting the old \"next\" block from the list of successors.  If\n+     there had been a fallthru edge, that will be the one.  */\n+  if (! next)\n+    {\n+      for (e = bb->succ; e ; e = e->succ_next)\n+\tif (e->dest->index == bb->index + 1)\n+\t  {\n+\t    if ((e->flags & EDGE_FALLTHRU)\n+\t        || (e->dest->succ\n+\t            && ! (e->flags & (EDGE_ABNORMAL_CALL | EDGE_EH))))\n+\t      next = e->dest;\n+\t    break;\n+\t  }\n+    }\n \n-  /* Rechain predicted block.  */\n-  NEXT_INSN (cebe_insn) = dbh_insn;\n-  PREV_INSN (dbh_insn) = cebe_insn;\n+  /* Make sure we didn't select a silly next block.  */\n+  if (! next || next == EXIT_BLOCK_PTR || RBI (next)->visited)\n+    next = NULL;\n \n-  if (db->index != n_basic_blocks - 1)\n-    NEXT_INSN (dbe_insn) = 0;\n+  /* Recurse on the successors.  Unroll the last call, as the normal\n+     case is exactly one or two edges, and we can tail recurse.  */\n+  for (e = bb->succ; e; e = e->succ_next)\n+    if (e->dest != EXIT_BLOCK_PTR\n+\t&& ! RBI (e->dest)->visited\n+\t&& e->dest->succ\n+\t&& ! (e->flags & (EDGE_ABNORMAL_CALL | EDGE_EH)))\n+      {\n+\tif (next)\n+\t  {\n+\t    prev = make_reorder_chain_1 (next, prev);\n+\t    next = RBI (e->dest)->visited ? NULL : e->dest;\n+\t  }\n+\telse\n+\t  next = e->dest;\n+      }\n+  if (next)\n+    {\n+      bb = next;\n+      goto restart;\n+    }\n \n-  return db;\n+  return prev;\n }\n \n \n-/* Reorder blocks starting at block BB.  */\n+/* Locate or create a label for a given basic block.  */\n \n-static void\n-make_reorder_chain (bb)\n+static rtx\n+label_for_bb (bb)\n      basic_block bb;\n {\n-  edge e;\n-  basic_block visited_edge = NULL;\n-  rtx block_end;\n-  int probability;\n-\n-  if (bb == EXIT_BLOCK_PTR)\n-    return;\n+  rtx label = bb->head;\n \n-  /* Find the most probable block.  */\n-  e = bb->succ;\n-  block_end = bb->end;\n-  if (GET_CODE (block_end) == JUMP_INSN && condjump_p (block_end))\n+  if (GET_CODE (label) != CODE_LABEL)\n     {\n-      rtx note = find_reg_note (block_end, REG_BR_PROB, 0);\n-\n-      if (note) \n-\tprobability = INTVAL (XEXP (note, 0));\n-      else\n-\tprobability = 0;\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"Emitting label for block %d (%d)\\n\",\n+\t\t bb->index, RBI (bb)->index);\n \n-      if (probability > REG_BR_PROB_BASE / 2)\n-\te = bb->succ->succ_next;\n+      label = emit_label_before (gen_label_rtx (), label);\n+      if (bb->head == RBI (bb)->eff_head)\n+\tRBI (bb)->eff_head = label;\n+      bb->head = label;\n     }\n \n-  /* Add chosen successor to chain and recurse on it.  */\n-  if (e && e->dest != EXIT_BLOCK_PTR\n-      && e->dest != e->src\n-      && (! (REORDER_BLOCK_FLAGS (e->dest) & REORDER_BLOCK_VISITED)\n-\t  || (REORDER_BLOCK_FLAGS (e->dest) == REORDER_BLOCK_HEAD)))\n-    {\n-      if (! (REORDER_BLOCK_FLAGS (bb) & REORDER_BLOCK_VISITED))\n-\t{\n-\t  REORDER_BLOCK_FLAGS (bb) |= REORDER_BLOCK_HEAD;\n-\t  REORDER_BLOCK_INDEX (bb) = reorder_index++;\n-\t  REORDER_BLOCK_FLAGS (bb) |= REORDER_BLOCK_VISITED;\n-\t}\n+  return label;\n+}\n \n-      if (REORDER_BLOCK_FLAGS (e->dest) & REORDER_BLOCK_VISITED)\n-\tREORDER_BLOCK_FLAGS (e->dest) &= ~REORDER_BLOCK_HEAD;\n-\t\n-      visited_edge = e->dest;\n \n-      reorder_last_visited = chain_reorder_blocks (e, bb);\n+/* Emit a jump to BB after insn AFTER.  */\n \n-      if (e->dest\n-\t  && ! (REORDER_BLOCK_FLAGS (e->dest)\n-\t\t& REORDER_BLOCK_VISITED))\n-\tmake_reorder_chain (e->dest);\n-    }\n-  else\n+static rtx\n+emit_jump_to_block_after (bb, after)\n+     basic_block bb;\n+     rtx after;\n+{\n+  rtx jump;\n+\n+  if (bb != EXIT_BLOCK_PTR)\n     {\n-      if (! (REORDER_BLOCK_FLAGS (bb) & REORDER_BLOCK_VISITED))\n-\t{\n-\t  REORDER_BLOCK_INDEX (bb) = reorder_index++;\n-\t  REORDER_BLOCK_FLAGS (bb) |= REORDER_BLOCK_VISITED;\n-\t}\n-    }\n+      rtx label = label_for_bb (bb);\n+      jump = emit_jump_insn_after (gen_jump (label), after);\n+      JUMP_LABEL (jump) = label;\n+      LABEL_NUSES (label) += 1;\n \n-  /* Recurse on the successors.  */\n-  for (e = bb->succ; e; e = e->succ_next)\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"Emitting jump to block %d (%d)\\n\",\n+\t\t bb->index, RBI (bb)->index);\n+    }\n+  else\n     {\n-      if (e->dest && e->dest == EXIT_BLOCK_PTR)\n-\tcontinue;\n+      if (! HAVE_return)\n+\tabort ();\n+      jump = emit_jump_insn_after (gen_return (), after);\n \n-      if (e->dest\n-\t  && e->dest != e->src\n-\t  && e->dest != visited_edge\n-\t  && ! (REORDER_BLOCK_FLAGS (e->dest)\n-\t\t& REORDER_BLOCK_VISITED))\n-\t{\n-\t  reorder_last_visited\n-\t    = chain_reorder_blocks (e, reorder_last_visited);\n-\t  make_reorder_chain (e->dest);\n-\t}\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"Emitting return\\n\");\n     }\n+\n+  return jump;\n }\n \n \n-/* Fixup jumps and labels after reordering basic blocks.  */ \n+/* Given a reorder chain, rearrange the code to match.  */\n \n static void\n fixup_reorder_chain ()\n {\n-  int i, j;\n-  rtx insn;\n-  int orig_num_blocks = n_basic_blocks;\n-\n-  /* Set the new last insn.  */\n-  {\n-    int max_val = 0;\n-    int max_index = 0;\n-    for (j = 0; j < n_basic_blocks; j++) \n-      {\n-\tint val = REORDER_BLOCK_INDEX (BASIC_BLOCK (j));\n-\tif (val > max_val)\n-\t  {\n-\t    max_val = val;\n-\t    max_index = j;\n-\t  }\n-      }\n-    insn = REORDER_BLOCK_EFF_END (BASIC_BLOCK (max_index));\n-    NEXT_INSN (insn) = NULL_RTX;\n-    set_last_insn (insn);\n-  }\n+  basic_block bb, last_bb;\n \n-  /* Add jumps and labels to fixup blocks.  */\n-  for (i = 0; i < orig_num_blocks; i++)\n+  /* First do the bulk reordering -- rechain the blocks without regard to\n+     the needed changes to jumps and labels.  */\n+\n+  last_bb = BASIC_BLOCK (0);\n+  bb = RBI (last_bb)->next;\n+  while (bb)\n     {\n-      int need_block = 0;\n-      basic_block bbi = BASIC_BLOCK (i);\n-      if (REORDER_BLOCK_ADD_JUMP (bbi))\n-\t{\n-\t  rtx label_insn, jump_insn, barrier_insn;\n+      rtx last_e = RBI (last_bb)->eff_end;\n+      rtx curr_h = RBI (bb)->eff_head;\n \n-\t  if (GET_CODE (REORDER_BLOCK_ADD_JUMP (bbi)->head) == CODE_LABEL)\n-\t    label_insn  = REORDER_BLOCK_ADD_JUMP (bbi)->head;\n-\t  else\n-\t    {\n-\t      rtx new_label = gen_label_rtx ();\n-\t      label_insn = emit_label_before (new_label,\n-\t\t\t      REORDER_BLOCK_ADD_JUMP (bbi)->head);\n-\t      REORDER_BLOCK_ADD_JUMP (bbi)->head = label_insn;\t \n-\t    }\n+      NEXT_INSN (last_e) = curr_h;\n+      PREV_INSN (curr_h) = last_e;\n \n-\t  if (GET_CODE (bbi->end) != JUMP_INSN)\n+      last_bb = bb;\n+      bb = RBI (bb)->next;\n+    }\n+  NEXT_INSN (RBI (last_bb)->eff_end) = NULL_RTX;\n+  set_last_insn (RBI (last_bb)->eff_end);\n+\n+  /* Now add jumps and labels as needed to match the blocks new\n+     outgoing edges.  */\n+\n+  for (bb = BASIC_BLOCK (0); bb ; bb = RBI (bb)->next)\n+    {\n+      edge e_fall, e_taken, e;\n+      rtx jump_insn, barrier_insn;\n+      basic_block nb;\n+\n+      if (bb->succ == NULL)\n+\tcontinue;\n+\n+      /* Find the old fallthru edge, and another non-EH edge for\n+\t a taken jump.  */\n+      e_taken = e_fall = NULL;\n+      for (e = bb->succ; e ; e = e->succ_next)\n+\tif (e->flags & EDGE_FALLTHRU)\n+\t  e_fall = e;\n+\telse if (! (e->flags & EDGE_EH))\n+\t  e_taken = e;\n+\n+      if (GET_CODE (bb->end) == JUMP_INSN)\n+\t{\n+\t  if (any_uncondjump_p (bb->end))\n \t    {\n-\t      jump_insn = emit_jump_insn_after (gen_jump (label_insn),\n-\t\t\t\t\t\tbbi->end);\n-\t      bbi->end = jump_insn;\n-\t      need_block = 0;\n+\t      /* If the destination is still not next, nothing to do.  */\n+\t      if (RBI (bb)->index + 1 != RBI (e_taken->dest)->index)\n+\t\tcontinue;\n+\n+\t      /* Otherwise, we can remove the jump and cleanup the edge.  */\n+\t      tidy_fallthru_edge (e_taken, bb, e_taken->dest);\n+\t      RBI (bb)->eff_end = skip_insns_after_block (bb);\n+\t      RBI (e_taken->dest)->eff_head = NEXT_INSN (RBI (bb)->eff_end);\n+\n+\t      if (rtl_dump_file)\n+\t\tfprintf (rtl_dump_file, \"Removing jump in block %d (%d)\\n\",\n+\t\t\t bb->index, RBI (bb)->index);\n+\t      continue;\n \t    }\n-\t  else\n+\t  else if (any_condjump_p (bb->end))\n \t    {\n-\t      jump_insn = emit_jump_insn_after (gen_jump (label_insn),\n-\t\t\t\t\t\tREORDER_BLOCK_EFF_END (bbi));\n-\t      need_block = 1;\n-\t    }\n-\n-\t  JUMP_LABEL (jump_insn) = label_insn;\n-\t  ++LABEL_NUSES (label_insn);\n-\t  barrier_insn = emit_barrier_after (jump_insn);\n+\t      /* If the old fallthru is still next, nothing to do.  */\n+\t      if (RBI (bb)->index + 1 == RBI (e_fall->dest)->index\n+\t          || (RBI (bb)->index == n_basic_blocks - 1\n+\t\t      && e_fall->dest == EXIT_BLOCK_PTR))\n+\t\tcontinue;\n+\n+\t      /* There is one special case: if *neither* block is next,\n+\t\t such as happens at the very end of a function, then we'll\n+\t\t need to add a new unconditional jump.  Choose the taken\n+\t\t edge based on known or assumed probability.  */\n+\t      if (RBI (bb)->index + 1 != RBI (e_taken->dest)->index)\n+\t\t{\n+\t\t  rtx note = find_reg_note (bb->end, REG_BR_PROB, 0);\n+\t\t  if (note\n+\t\t      && INTVAL (XEXP (note, 0)) < REG_BR_PROB_BASE / 2\n+\t\t      && invert_jump (bb->end, label_for_bb (e_fall->dest), 0))\n+\t\t    {\n+\t\t      e_fall->flags &= ~EDGE_FALLTHRU;\n+\t\t      e_taken->flags |= EDGE_FALLTHRU;\n+\t\t      e = e_fall, e_fall = e_taken, e_taken = e;\n+\t\t    }\n+\t\t}\n \n-\t  /* Add block for jump.  Typically this is when a then is not\n-\t     predicted and we are jumping to the moved then block.  */\n-\t  if (need_block)\n-\t    {\n-\t      basic_block nb;\n-\n-\t      VARRAY_GROW (basic_block_info, ++n_basic_blocks);\n-\t      create_basic_block (n_basic_blocks - 1, jump_insn,\n-\t\t\t\t  jump_insn, NULL);\n-\t      nb = BASIC_BLOCK (n_basic_blocks - 1);\n-\t      nb->global_live_at_start\n-\t\t= OBSTACK_ALLOC_REG_SET (function_obstack);\n-\t      nb->global_live_at_end\n-\t\t= OBSTACK_ALLOC_REG_SET (function_obstack);\n-\n-\t      COPY_REG_SET (nb->global_live_at_start,\n-\t\t\t    bbi->global_live_at_start);\n-\t      COPY_REG_SET (nb->global_live_at_end,\n-\t\t\t    bbi->global_live_at_start);\n-\t      BASIC_BLOCK (nb->index)->local_set = 0;\n-\n-\t      nb->aux = xcalloc (1, sizeof (struct reorder_block_def));\n-\t      REORDER_BLOCK_INDEX (nb) = REORDER_BLOCK_INDEX (bbi) + 1;\n-\t      /* Relink to new block.  */\n-\t      nb->succ = bbi->succ;\n-\t      nb->succ->src = nb;\n-\n-\t      make_edge (NULL, bbi, nb, 0);\n-\t      bbi->succ->succ_next\n-\t\t= bbi->succ->succ_next->succ_next;\n-\t      nb->succ->succ_next = 0;\n-\t      /* Fix reorder block index to reflect new block.  */\n-\t      for (j = 0; j < n_basic_blocks - 1; j++)\n+\t      /* Otherwise we can try to invert the jump.  This will \n+\t\t basically never fail, however, keep up the pretense.  */\n+\t      else if (invert_jump (bb->end, label_for_bb (e_fall->dest), 0))\n \t\t{\n-\t\t  basic_block bbj = BASIC_BLOCK (j);\n-\t\t  if (REORDER_BLOCK_INDEX (bbj)\n-\t\t      >= REORDER_BLOCK_INDEX (bbi) + 1)\n-\t\t    REORDER_BLOCK_INDEX (bbj)++;\n+\t\t  e_fall->flags &= ~EDGE_FALLTHRU;\n+\t\t  e_taken->flags |= EDGE_FALLTHRU;\n+\t\t  continue;\n \t\t}\n-\t      REORDER_BLOCK_SCOPE (nb) = REORDER_BLOCK_SCOPE (bbi);\n-\t      REORDER_BLOCK_EFF_HEAD (nb) = nb->head;\n-\t      REORDER_BLOCK_EFF_END (nb) = barrier_insn;\n \t    }\n+\t  else if (returnjump_p (bb->end))\n+\t    continue;\n \t  else\n-\t    REORDER_BLOCK_EFF_END (bbi) = barrier_insn;\n+\t    {\n+\t      /* Otherwise we have some switch or computed jump.  In the\n+\t\t 99% case, there should not have been a fallthru edge.  */\n+\t      if (! e_fall)\n+\t\tcontinue;\n+#ifdef CASE_DROPS_THROUGH\n+\t      /* Except for VAX.  Since we didn't have predication for the\n+\t\t tablejump, the fallthru block should not have moved.  */\n+\t      if (RBI (bb)->index + 1 == RBI (e_fall->dest)->index)\n+\t\tcontinue;\n+#endif\n+\t      abort ();\n+\t    }\n \t}\n+      else\n+\t{\n+\t  /* No fallthru implies a noreturn function with EH edges, or\n+\t     something similarly bizarre.  In any case, we don't need to\n+\t     do anything.  */\n+\t  if (! e_fall)\n+\t    continue;\n+\n+\t  /* If the fallthru block is still next, nothing to do.  */\n+\t  if (RBI (bb)->index + 1 == RBI (e_fall->dest)->index\n+\t      || (RBI (bb)->index == n_basic_blocks - 1\n+\t\t  && e_fall->dest == EXIT_BLOCK_PTR))\n+\t    continue;\n+\n+\t  /* We need a new jump insn.  If the block has only one outgoing\n+\t     edge, then we can stuff the new jump insn in directly.  */\n+\t  if (bb->succ->succ_next == NULL)\n+\t    {\n+\t      e_fall->flags &= ~EDGE_FALLTHRU;\n+\n+\t      jump_insn = emit_jump_to_block_after (e_fall->dest, bb->end);\n+\t      bb->end = jump_insn;\n+\t      barrier_insn = emit_barrier_after (jump_insn);\n+\t      RBI (bb)->eff_end = barrier_insn;\n+\t      continue;\n+\t    }\n+\t}\n+\n+      /* We got here if we need to add a new jump insn in a new block\n+\t across the edge e_fall.  */\n+\n+      jump_insn = emit_jump_to_block_after (e_fall->dest, bb->end);\n+      barrier_insn = emit_barrier_after (jump_insn);\n+\n+      VARRAY_GROW (basic_block_info, ++n_basic_blocks);\n+      create_basic_block (n_basic_blocks - 1, jump_insn, jump_insn, NULL);\n+\n+      nb = BASIC_BLOCK (n_basic_blocks - 1);\n+      nb->global_live_at_start = OBSTACK_ALLOC_REG_SET (function_obstack);\n+      nb->global_live_at_end = OBSTACK_ALLOC_REG_SET (function_obstack);\n+      nb->local_set = 0;\n+\n+      COPY_REG_SET (nb->global_live_at_start, bb->global_live_at_start);\n+      COPY_REG_SET (nb->global_live_at_end, bb->global_live_at_start);\n+\n+      nb->aux = xmalloc (sizeof (struct reorder_block_def));\n+      RBI (nb)->eff_head = nb->head;\n+      RBI (nb)->eff_end = barrier_insn;\n+      RBI (nb)->scope = RBI (bb)->scope;\n+      RBI (nb)->index = RBI (bb)->index + 1;\n+      RBI (nb)->visited = 1;\n+      RBI (nb)->next = RBI (bb)->next;\n+      RBI (bb)->next = nb;\n+\n+      /* Link to new block.  */\n+      make_edge (NULL, nb, e_fall->dest, 0);\n+      redirect_edge_succ (e_fall, nb);\n+\n+      /* Don't process this new block.  */\n+      bb = nb;\n+\n+      /* Fix subsequent reorder block indices to reflect new block.  */\n+      while ((nb = RBI (nb)->next) != NULL)\n+\tRBI (nb)->index += 1;\n+    }\n+\n+  /* Put basic_block_info in the new order.  */\n+  for (bb = BASIC_BLOCK (0); bb ; bb = RBI (bb)->next)\n+    {\n+      bb->index = RBI (bb)->index;\n+      BASIC_BLOCK (bb->index) = bb;\n     }\n }\n \n@@ -655,8 +709,8 @@ fixup_reorder_chain ()\n       reverse direction.\n    2. Count insns in chain, going both directions, and check if equal.\n    3. Check that get_last_insn () returns the actual end of chain.  */\n-#ifdef ENABLE_CHECKING\n-static void\n+\n+void\n verify_insn_chain ()\n {\n   rtx x,\n@@ -712,7 +766,6 @@ verify_insn_chain ()\n       abort ();\n     }\n }\n-#endif\n \n static rtx\n get_next_bb_note (x)\n@@ -853,7 +906,6 @@ relate_bbs_with_scopes (s)\n \t}\n     }\n \n-\n   /* If the scope spans one or more basic blocks, we record them. We\n      only record the bbs that are immediately contained within this\n      scope. Note that if a scope is contained within a bb, we can tell\n@@ -864,17 +916,17 @@ relate_bbs_with_scopes (s)\n \n       s->num_bbs = 0;\n       for (i = bbi1; i <= bbi2; i++)\n-\tif (! REORDER_BLOCK_SCOPE (BASIC_BLOCK (i)))\n+\tif (! RBI (BASIC_BLOCK (i))->scope)\n \t  s->num_bbs++;\n \n-      s->bbs = xcalloc (s->num_bbs, sizeof (struct basic_block_def));\n+      s->bbs = xmalloc (s->num_bbs * sizeof (basic_block));\n       for (i = bbi1; i <= bbi2; i++)\n \t{\n \t  basic_block curr_bb = BASIC_BLOCK (i);\n-\t  if (! REORDER_BLOCK_SCOPE (curr_bb))\n+\t  if (! RBI (curr_bb)->scope)\n \t    {\n \t      s->bbs[j++] = curr_bb;\n-\t      REORDER_BLOCK_SCOPE (curr_bb) = s;\n+\t      RBI (curr_bb)->scope = s;\n \t    }\n \t}\n     }\n@@ -894,15 +946,6 @@ make_new_scope (level, note)\n   scope new_scope = xcalloc (1, sizeof (struct scope_def));\n   new_scope->level = level;\n   new_scope->note_beg = note;\n-  new_scope->note_end = NULL;\n-  new_scope->bb_beg = NULL;\n-  new_scope->bb_end = NULL;\n-  new_scope->inner = NULL;\n-  new_scope->inner_last = NULL;\n-  new_scope->outer = NULL;\n-  new_scope->next = NULL;\n-  new_scope->num_bbs = 0;\n-  new_scope->bbs = NULL;\n   return new_scope;\n }\n \n@@ -961,11 +1004,8 @@ build_scope_forest (forest)\n \t\t  level++;\n \t          curr_scope = make_new_scope (level, x);\n \t\t  root = curr_scope;\n-\t\t  if (ntrees == 0)\n-\t\t    forest->trees = xcalloc (1, sizeof (scope));\n-\t\t  else\n-\t\t    forest->trees = xrealloc (forest->trees,\n-\t\t\t\t\t      sizeof (scope) * (ntrees + 1));\n+\t\t  forest->trees = xrealloc (forest->trees,\n+\t\t\t\t\t    sizeof (scope) * (ntrees + 1));\n \t\t  forest->trees[forest->num_trees++] = root;\n \t\t}\n \t      curr_scope->bb_beg = curr_bb;\n@@ -1036,6 +1076,7 @@ remove_scope_notes ()\n \n \n /* Insert scope note pairs for a contained scope tree S after insn IP.  */\n+\n static void\n insert_intra_1 (s, ip)\n      scope s;\n@@ -1067,7 +1108,7 @@ static void\n insert_intra_bb_scope_notes (bb)\n      basic_block bb;\n {\n-  scope s = REORDER_BLOCK_SCOPE (bb);\n+  scope s = RBI (bb)->scope;\n   scope p;\n   rtx ip;\n \n@@ -1104,8 +1145,8 @@ insert_inter_bb_scope_notes (bb1, bb2)\n      In that case, we either open or close a scope but not both.  */\n   if (bb1 && bb2)\n     {\n-      scope s1 = REORDER_BLOCK_SCOPE (bb1);\n-      scope s2 = REORDER_BLOCK_SCOPE (bb2);\n+      scope s1 = RBI (bb1)->scope;\n+      scope s2 = RBI (bb2)->scope;\n       if (! s1 && ! s2)\n \treturn;\n       if (! s1)\n@@ -1117,8 +1158,8 @@ insert_inter_bb_scope_notes (bb1, bb2)\n   /* Find common ancestor scope.  */\n   if (bb1 && bb2)\n     {\n-      scope s1 = REORDER_BLOCK_SCOPE (bb1);\n-      scope s2 = REORDER_BLOCK_SCOPE (bb2);\n+      scope s1 = RBI (bb1)->scope;\n+      scope s2 = RBI (bb2)->scope;\n       while (s1 != s2)\n \t{\n           if (! (s1 && s2))\n@@ -1141,8 +1182,8 @@ insert_inter_bb_scope_notes (bb1, bb2)\n   /* Close scopes.  */\n   if (bb1)\n     {\n-      scope s = REORDER_BLOCK_SCOPE (bb1);\n-      ip = REORDER_BLOCK_EFF_END (bb1);\n+      scope s = RBI (bb1)->scope;\n+      ip = RBI (bb1)->eff_end;\n       while (s != com)\n \t{\n \t  if (NOTE_BLOCK (s->note_beg))\n@@ -1157,7 +1198,7 @@ insert_inter_bb_scope_notes (bb1, bb2)\n   /* Open scopes.  */\n   if (bb2)\n     {\n-      scope s = REORDER_BLOCK_SCOPE (bb2);\n+      scope s = RBI (bb2)->scope;\n       ip = bb2->head;\n       while (s != com)\n \t{\n@@ -1192,7 +1233,7 @@ rebuild_scope_notes (forest)\n     {\n       basic_block bb1 = BASIC_BLOCK (i);\n       basic_block bb2 = BASIC_BLOCK (i + 1);\n-      if (REORDER_BLOCK_SCOPE (bb1) != REORDER_BLOCK_SCOPE (bb2))\n+      if (RBI (bb1)->scope != RBI (bb2)->scope)\n \tinsert_inter_bb_scope_notes (bb1, bb2);\n       insert_intra_bb_scope_notes (bb1);\n     }\n@@ -1264,8 +1305,8 @@ dump_scope_forest_1 (s, indent)\n   int i;\n \n   if (s->bb_beg != NULL && s->bb_beg == s->bb_end\n-      && REORDER_BLOCK_SCOPE (s->bb_beg)\n-      && REORDER_BLOCK_SCOPE (s->bb_beg)->level + 1 == s->level)\n+      && RBI (s->bb_beg)->scope\n+      && RBI (s->bb_beg)->scope->level + 1 == s->level)\n     {\n       fprintf (stderr, \"%*s\", indent, \"\");\n       fprintf (stderr, \"BB%d:\\n\", s->bb_beg->index);\n@@ -1288,127 +1329,48 @@ dump_scope_forest_1 (s, indent)\n }\n \n \n-/* Reorder basic blocks.  */\n+/* Reorder basic blocks.  The main entry point to this file.  */\n \n void\n reorder_basic_blocks ()\n {\n-  int i, j;\n-  struct loops loops_info;\n-  int num_loops;\n   scope_forest_info forest;\n-\n-  if (profile_arc_flag)\n-    return;\n+  int i;\n \n   if (n_basic_blocks <= 1)\n     return;\n \n-  /* Exception edges are not currently handled.  */\n+  /* We do not currently handle correct re-placement of EH notes.  */\n   for (i = 0; i < n_basic_blocks; i++)\n     {\n       edge e;\n-\n-      for (e = BASIC_BLOCK (i)->succ; e && ! (e->flags & EDGE_EH);\n-\t   e = e->succ_next)\n-\tcontinue;\n-\n-      if (e && (e->flags & EDGE_EH))\n-\treturn;\n+      for (e = BASIC_BLOCK (i)->succ; e ; e = e->succ_next)\n+        if (e->flags & EDGE_EH)\n+\t  return;\n     }\n \n-  reorder_index = 0;\n-\n-  /* Find natural loops using the CFG.  */\n-  num_loops = flow_loops_find (&loops_info);\n-\n-  /* Dump loop information.  */\n-  flow_loops_dump (&loops_info, rtl_dump_file, 0);\n-\n-  reorder_last_visited = BASIC_BLOCK (0);\n-\n   for (i = 0; i < n_basic_blocks; i++)\n-    {\n-      basic_block bbi = BASIC_BLOCK (i);\n-      bbi->aux = xcalloc (1, sizeof (struct reorder_block_def));\n-      *((struct reorder_block_def *)bbi->aux) = rbd_init;\n-    }\n+    BASIC_BLOCK (i)->aux = xcalloc (1, sizeof (struct reorder_block_def));\n \n   build_scope_forest (&forest);\n   remove_scope_notes ();\n \n-  for (i = 0; i < n_basic_blocks; i++)\n-    {\n-      basic_block bbi = BASIC_BLOCK (i);\n-      REORDER_BLOCK_EFF_END (bbi) = skip_insns_after_block (bbi);\n-      if (i == 0)\n-\tREORDER_BLOCK_EFF_HEAD (bbi) = get_insns ();\n-      else \n-\t{\n-\t  rtx prev_eff_end = REORDER_BLOCK_EFF_END (BASIC_BLOCK (i - 1));\n-\t  REORDER_BLOCK_EFF_HEAD (bbi) = NEXT_INSN (prev_eff_end);\n-\t}\n-    }\n-\n-  /* If we've not got epilogue in RTL, we must fallthru to the exit.\n-     Force the last block to be at the end.  */\n-  /* ??? Some ABIs (e.g. MIPS) require the return insn to be at the\n-     end of the function for stack unwinding purposes.  */\n-\n-#ifndef HAVE_epilogue\n-#define HAVE_epilogue 0\n-#endif\n-\n-  if (! HAVE_epilogue)\n-    {\n-      basic_block last = BASIC_BLOCK (n_basic_blocks - 1);\n-      REORDER_BLOCK_INDEX (last) = n_basic_blocks - 1;\n-      REORDER_BLOCK_FLAGS (last) |= REORDER_BLOCK_VISITED;\n-    }\n-      \n-  make_reorder_chain (BASIC_BLOCK (0));\n-\n+  record_effective_endpoints ();\n+  make_reorder_chain ();\n   fixup_reorder_chain ();\n \n #ifdef ENABLE_CHECKING\n   verify_insn_chain ();\n #endif\n \n-  /* Put basic_block_info in new order.  */\n-  for (i = 0; i < n_basic_blocks - 1; i++)\n-    {\n-      for (j = i; i != REORDER_BLOCK_INDEX (BASIC_BLOCK (j)); j++)\n-\tcontinue;\n-\n-      if (REORDER_BLOCK_INDEX (BASIC_BLOCK (j)) == i\n-\t  && i != j)\n-\t{\n-\t  basic_block tempbb;\n-\t  int temprbi;\n-\t  int rbi = REORDER_BLOCK_INDEX (BASIC_BLOCK (j));\n-\n-\t  temprbi = BASIC_BLOCK (rbi)->index;\n-\t  BASIC_BLOCK (rbi)->index = BASIC_BLOCK (j)->index;\n-\t  BASIC_BLOCK (j)->index = temprbi;\n-\t  tempbb = BASIC_BLOCK (rbi);\n-\t  BASIC_BLOCK (rbi) = BASIC_BLOCK (j);\n-\t  BASIC_BLOCK (j) = tempbb;\n-\t}\n-    }\n-\n   rebuild_scope_notes (&forest);\n   free_scope_forest (&forest);\n   reorder_blocks ();\n \n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n-\n   for (i = 0; i < n_basic_blocks; i++)\n     free (BASIC_BLOCK (i)->aux);\n \n-  /* Free loop information.  */\n-  flow_loops_free (&loops_info);\n-\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n }\n-"}, {"sha": "9a904939ce8020bf949b640c9a490d7ac80b9cef", "filename": "gcc/flow.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f008a564f936b295dd747d9cd1f6ef43f780ac90/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f008a564f936b295dd747d9cd1f6ef43f780ac90/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=f008a564f936b295dd747d9cd1f6ef43f780ac90", "patch": "@@ -6789,6 +6789,46 @@ add_noreturn_fake_exit_edges ()\n     if (BASIC_BLOCK (x)->succ == NULL)\n       make_edge (NULL, BASIC_BLOCK (x), EXIT_BLOCK_PTR, EDGE_FAKE);\n }\n+\n+/* Redirect an edge's successor from one block to another.  */\n+\n+void\n+redirect_edge_succ (e, new_succ)\n+     edge e;\n+     basic_block new_succ;\n+{\n+  edge *pe;\n+\n+  /* Disconnect the edge from the old successor block.  */\n+  for (pe = &e->dest->pred; *pe != e ; pe = &(*pe)->pred_next)\n+    continue;\n+  *pe = (*pe)->pred_next;\n+\n+  /* Reconnect the edge to the new successor block.  */\n+  e->pred_next = new_succ->pred;\n+  new_succ->pred = e;\n+  e->dest = new_succ;\n+}\n+\n+/* Redirect an edge's predecessor from one block to another.  */\n+\n+void\n+redirect_edge_pred (e, new_pred)\n+     edge e;\n+     basic_block new_pred;\n+{\n+  edge *pe;\n+\n+  /* Disconnect the edge from the old predecessor block.  */\n+  for (pe = &e->src->succ; *pe != e ; pe = &(*pe)->succ_next)\n+    continue;\n+  *pe = (*pe)->succ_next;\n+\n+  /* Reconnect the edge to the new predecessor block.  */\n+  e->succ_next = new_pred->succ;\n+  new_pred->succ = e;\n+  e->src = new_pred;\n+}\n \f\n /* Dump the list of basic blocks in the bitmap NODES.  */\n static void "}]}