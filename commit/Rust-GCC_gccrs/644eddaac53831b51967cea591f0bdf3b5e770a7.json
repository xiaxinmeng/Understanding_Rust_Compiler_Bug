{"sha": "644eddaac53831b51967cea591f0bdf3b5e770a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ0ZWRkYWFjNTM4MzFiNTE5NjdjZWE1OTFmMGJkZjNiNWU3NzBhNw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-10-02T12:57:24Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-10-02T12:57:24Z"}, "message": "cpphash.h: Update comments.\n\n\t* cpphash.h: Update comments.\n\t(cpp_context): Update.\n\t(spec_nodes): Remove n__Pragma.\n\t* cppinit.c (cpp_create_reader): Update.\n\t(builtin_array): Add _Pragma.\n\t* cpplib.h: Update comments.\n\t(NODE_DISABLED, BT_PRAGMA): New.\n\t(cpp_start_lookahead, cpp_stop_lookahead): Remove prototypes.\n\t* cppmacro.c (struct cpp_macro): Remove disabled.\n\t(builtin_macro): Return int, handle _Pragma, push the new token\n\ton the context stack.\n\t(funlike_invocation_p): Unconstify, update.\n\t(enter_macro_context): Handle builtins here.\n\t(replace_args, push_token_context, push_ptoken_context):\n\tUpdate for prototype changes.\n\t(_cpp_pop_context): Update.\n\t(cpp_get_token): Don't handle buitins, nor _Pragma here.\n\t(cpp_sys_macro_p): Update.\n\t(_cpp_free_definition): Clear disabled flag.\n\t(_cpp_create_definition): Upate.\n\t* cppmain.c: Update comments.\n\nFrom-SVN: r45948", "tree": {"sha": "255137e6966135d2fff952402170da9491a088d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/255137e6966135d2fff952402170da9491a088d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/644eddaac53831b51967cea591f0bdf3b5e770a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/644eddaac53831b51967cea591f0bdf3b5e770a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/644eddaac53831b51967cea591f0bdf3b5e770a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/644eddaac53831b51967cea591f0bdf3b5e770a7/comments", "author": null, "committer": null, "parents": [{"sha": "9d19cb9582b17accc88c77131b11095ce14199bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d19cb9582b17accc88c77131b11095ce14199bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d19cb9582b17accc88c77131b11095ce14199bd"}], "stats": {"total": 202, "additions": 125, "deletions": 77}, "files": [{"sha": "cf0426e437ada87ba4be97939296c5f921e35946", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644eddaac53831b51967cea591f0bdf3b5e770a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644eddaac53831b51967cea591f0bdf3b5e770a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=644eddaac53831b51967cea591f0bdf3b5e770a7", "patch": "@@ -1,3 +1,27 @@\n+2001-10-02  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpphash.h: Update comments.\n+\t(cpp_context): Update.\n+\t(spec_nodes): Remove n__Pragma.\n+\t* cppinit.c (cpp_create_reader): Update.\n+\t(builtin_array): Add _Pragma.\n+\t* cpplib.h: Update comments.\n+\t(NODE_DISABLED, BT_PRAGMA): New.\n+\t(cpp_start_lookahead, cpp_stop_lookahead): Remove prototypes.\n+\t* cppmacro.c (struct cpp_macro): Remove disabled.\n+\t(builtin_macro): Return int, handle _Pragma, push the new token\n+\ton the context stack.\n+\t(funlike_invocation_p): Unconstify, update.\n+\t(enter_macro_context): Handle builtins here.\n+\t(replace_args, push_token_context, push_ptoken_context):\n+\tUpdate for prototype changes.\n+\t(_cpp_pop_context): Update.\n+\t(cpp_get_token): Don't handle buitins, nor _Pragma here.\n+\t(cpp_sys_macro_p): Update.\n+\t(_cpp_free_definition): Clear disabled flag.\n+\t(_cpp_create_definition): Upate.\n+\t* cppmain.c: Update comments.\n+\n Tue Oct  2 12:46:01 CEST 2001  Bo Thorsen     <bo@suse.co.uk>,\n \t\t\t       Andreas Jaeger <aj@suse.de>,\n \t\t\t       Jan Hubicka    <jh@suse.cz>"}, {"sha": "8a435a051831cd4e3e33173d0453047466843e5d", "filename": "gcc/cpphash.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644eddaac53831b51967cea591f0bdf3b5e770a7/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644eddaac53831b51967cea591f0bdf3b5e770a7/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=644eddaac53831b51967cea591f0bdf3b5e770a7", "patch": "@@ -42,7 +42,7 @@ struct directive;\t\t/* Deliberately incomplete.  */\n    efficiency, and partly to limit runaway recursion.  */\n #define CPP_STACK_MAX 200\n \n-/* A generic memory buffer.  */\n+/* A generic memory buffer, and operations on it.  */\n \n typedef struct _cpp_buff _cpp_buff;\n struct _cpp_buff\n@@ -59,6 +59,7 @@ extern _cpp_buff *_cpp_append_extend_buff PARAMS ((cpp_reader *, _cpp_buff *,\n extern void _cpp_free_buff PARAMS ((_cpp_buff *));\n extern unsigned char *_cpp_aligned_alloc PARAMS ((cpp_reader *, size_t));\n extern unsigned char *_cpp_unaligned_alloc PARAMS ((cpp_reader *, size_t));\n+\n #define BUFF_ROOM(BUFF) (size_t) ((BUFF)->limit - (BUFF)->cur)\n #define BUFF_FRONT(BUFF) ((BUFF)->cur)\n #define BUFF_LIMIT(BUFF) ((BUFF)->limit)\n@@ -114,8 +115,8 @@ struct cpp_context\n      When the context is popped, the buffer is released.  */\n   _cpp_buff *buff;\n \n-  /* For a macro context, these are the macro and its arguments.  */\n-  cpp_macro *macro;\n+  /* For a macro context, the macro node, otherwise NULL.  */\n+  cpp_hashnode *macro;\n \n   /* True if utoken element is token, else ptoken.  */\n   bool direct_p;\n@@ -162,7 +163,6 @@ struct spec_nodes\n   cpp_hashnode *n_defined;\t\t/* defined operator */\n   cpp_hashnode *n_true;\t\t\t/* C++ keyword true */\n   cpp_hashnode *n_false;\t\t/* C++ keyword false */\n-  cpp_hashnode *n__Pragma;\t\t/* _Pragma operator */\n   cpp_hashnode *n__STRICT_ANSI__;\t/* STDC_0_IN_SYSTEM_HEADERS */\n   cpp_hashnode *n__CHAR_UNSIGNED__;\t/* plain char is unsigned */\n   cpp_hashnode *n__VA_ARGS__;\t\t/* C99 vararg macros */\n@@ -178,7 +178,7 @@ struct cpp_buffer\n \n   struct cpp_buffer *prev;\n \n-  const unsigned char *buf;\t /* Entire buffer.  */\n+  const unsigned char *buf;\t /* Entire character buffer.  */\n \n   /* Pointer into the include table; non-NULL if this is a file\n      buffer.  Used for include_next and to record control macros.  */"}, {"sha": "d17dcac01c1ff974d198f503068cad268f9a4e80", "filename": "gcc/cppinit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644eddaac53831b51967cea591f0bdf3b5e770a7/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644eddaac53831b51967cea591f0bdf3b5e770a7/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=644eddaac53831b51967cea591f0bdf3b5e770a7", "patch": "@@ -547,7 +547,6 @@ cpp_create_reader (table, lang)\n   s->n_defined\t\t= cpp_lookup (pfile, DSC(\"defined\"));\n   s->n_true\t\t= cpp_lookup (pfile, DSC(\"true\"));\n   s->n_false\t\t= cpp_lookup (pfile, DSC(\"false\"));\n-  s->n__Pragma\t\t= cpp_lookup (pfile, DSC(\"_Pragma\"));\n   s->n__STRICT_ANSI__   = cpp_lookup (pfile, DSC(\"__STRICT_ANSI__\"));\n   s->n__CHAR_UNSIGNED__ = cpp_lookup (pfile, DSC(\"__CHAR_UNSIGNED__\"));\n   s->n__VA_ARGS__       = cpp_lookup (pfile, DSC(\"__VA_ARGS__\"));\n@@ -658,6 +657,7 @@ static const struct builtin builtin_array[] =\n   B(\"__BASE_FILE__\",\t BT_BASE_FILE),\n   B(\"__LINE__\",\t\t BT_SPECLINE),\n   B(\"__INCLUDE_LEVEL__\", BT_INCLUDE_LEVEL),\n+  B(\"_Pragma\",\t\t BT_PRAGMA),\n \n   X(\"__VERSION__\",\t\tVERS),\n   X(\"__USER_LABEL_PREFIX__\",\tULP),"}, {"sha": "507126e6ad5700795fb6888b62fc8295e909ccee", "filename": "gcc/cpplib.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644eddaac53831b51967cea591f0bdf3b5e770a7/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644eddaac53831b51967cea591f0bdf3b5e770a7/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=644eddaac53831b51967cea591f0bdf3b5e770a7", "patch": "@@ -168,7 +168,7 @@ struct cpp_string\n #define BOL\t\t(1 << 6) /* Token at beginning of line.  */\n \n /* A preprocessing token.  This has been carefully packed and should\n-   occupy 12 bytes on 32-bit hosts and 16 bytes on 64-bit hosts.  */\n+   occupy 16 bytes on 32-bit hosts and 24 bytes on 64-bit hosts.  */\n struct cpp_token\n {\n   unsigned int line;\t\t/* Logical line of first char of token.  */\n@@ -353,7 +353,7 @@ struct cpp_options\n   /* Print column number in error messages.  */\n   unsigned char show_column;\n \n-  /* Treat C++ alternate operator names special.  */\n+  /* Nonzero means handle C++ alternate operator names.  */\n   unsigned char operator_names;\n \n   /* True if --help, --version or --target-help appeared in the\n@@ -400,6 +400,7 @@ extern const char *progname;\n #define NODE_BUILTIN\t(1 << 2)\t/* Builtin macro.  */\n #define NODE_DIAGNOSTIC (1 << 3)\t/* Possible diagnostic when lexed.  */\n #define NODE_WARN\t(1 << 4)\t/* Warn if redefined or undefined.  */\n+#define NODE_DISABLED\t(1 << 5)\t/* A disabled macro.  */\n \n /* Different flavors of hash node.  */\n enum node_type\n@@ -409,7 +410,8 @@ enum node_type\n   NT_ASSERTION\t   /* Predicate for #assert.  */\n };\n \n-/* Different flavors of builtin macro.  */\n+/* Different flavors of builtin macro.  _Pragma is an operator, but we\n+   handle it with the builtin code for efficiency reasons.  */\n enum builtin_type\n {\n   BT_SPECLINE = 0,\t\t/* `__LINE__' */\n@@ -418,7 +420,8 @@ enum builtin_type\n   BT_BASE_FILE,\t\t\t/* `__BASE_FILE__' */\n   BT_INCLUDE_LEVEL,\t\t/* `__INCLUDE_LEVEL__' */\n   BT_TIME,\t\t\t/* `__TIME__' */\n-  BT_STDC\t\t\t/* `__STDC__' */\n+  BT_STDC,\t\t\t/* `__STDC__' */\n+  BT_PRAGMA\t\t\t/* `_Pragma' operator */\n };\n \n #define CPP_HASHNODE(HNODE)\t((cpp_hashnode *) (HNODE))\n@@ -568,8 +571,6 @@ extern void cpp_forall_identifiers\tPARAMS ((cpp_reader *,\n \n /* In cppmacro.c */\n extern void cpp_scan_nooutput\t\tPARAMS ((cpp_reader *));\n-extern void cpp_start_lookahead\t\tPARAMS ((cpp_reader *));\n-extern void cpp_stop_lookahead\t\tPARAMS ((cpp_reader *, int));\n extern int  cpp_sys_macro_p\t\tPARAMS ((cpp_reader *));\n \n /* In cppfiles.c */"}, {"sha": "f9fb0e1ffa008e8b36f3848d596394f7537f87be", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 85, "deletions": 62, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644eddaac53831b51967cea591f0bdf3b5e770a7/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644eddaac53831b51967cea591f0bdf3b5e770a7/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=644eddaac53831b51967cea591f0bdf3b5e770a7", "patch": "@@ -38,7 +38,6 @@ struct cpp_macro\n   unsigned short paramc;\t/* Number of parameters.  */\n   unsigned int fun_like : 1;\t/* If a function-like macro.  */\n   unsigned int variadic : 1;\t/* If a variadic macro.  */\n-  unsigned int disabled : 1;\t/* If macro is disabled.  */\n   unsigned int syshdr   : 1;\t/* If macro defined in system header.  */\n };\n \n@@ -55,11 +54,11 @@ struct macro_arg\n /* Macro expansion.  */\n \n static int enter_macro_context PARAMS ((cpp_reader *, cpp_hashnode *));\n-static const cpp_token *builtin_macro PARAMS ((cpp_reader *, cpp_hashnode *));\n+static int builtin_macro PARAMS ((cpp_reader *, cpp_hashnode *));\n static void push_token_context\n-  PARAMS ((cpp_reader *, cpp_macro *, const cpp_token *, unsigned int));\n+  PARAMS ((cpp_reader *, cpp_hashnode *, const cpp_token *, unsigned int));\n static void push_ptoken_context\n-  PARAMS ((cpp_reader *, cpp_macro *, _cpp_buff *,\n+  PARAMS ((cpp_reader *, cpp_hashnode *, _cpp_buff *,\n \t   const cpp_token **, unsigned int));\n static _cpp_buff *collect_args PARAMS ((cpp_reader *, const cpp_hashnode *));\n static cpp_context *next_context PARAMS ((cpp_reader *));\n@@ -76,8 +75,8 @@ static const cpp_token *stringify_arg PARAMS ((cpp_reader *, macro_arg *));\n static void paste_all_tokens PARAMS ((cpp_reader *, const cpp_token *));\n static bool paste_tokens PARAMS ((cpp_reader *, const cpp_token **,\n \t\t\t\t  const cpp_token *));\n-static int funlike_invocation_p PARAMS ((cpp_reader *, const cpp_hashnode *));\n-static void replace_args PARAMS ((cpp_reader *, cpp_macro *, macro_arg *));\n+static int funlike_invocation_p PARAMS ((cpp_reader *, cpp_hashnode *));\n+static void replace_args PARAMS ((cpp_reader *, cpp_hashnode *, macro_arg *));\n \n /* #define directive parsing and handling.  */\n \n@@ -132,17 +131,22 @@ static const char * const monthnames[] =\n   \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n };\n \n-/* Handle builtin macros like __FILE__.  */\n-static const cpp_token *\n+/* Handle builtin macros like __FILE__, and push the resulting token\n+   on the context stack.  Also handles _Pragma, for which no new token\n+   is created.  Returns 1 on success, 0 to return the token to the\n+   caller.  */\n+static int\n builtin_macro (pfile, node)\n      cpp_reader *pfile;\n      cpp_hashnode *node;\n {\n+  const cpp_token *result;\n+\n   switch (node->value.builtin)\n     {\n     default:\n       cpp_ice (pfile, \"invalid builtin macro \\\"%s\\\"\", NODE_NAME (node));\n-      return new_number_token (pfile, 1);\n+      return 0;\n \n     case BT_FILE:\n     case BT_BASE_FILE:\n@@ -161,28 +165,33 @@ builtin_macro (pfile, node)\n \tbuf = _cpp_unaligned_alloc (pfile, len * 4 + 1);\n \tlen = quote_string (buf, (const unsigned char *) name, len) - buf;\n \n-\treturn new_string_token (pfile, buf, len);\n+\tresult = new_string_token (pfile, buf, len);\n       }\n-\t\n+      break;\n+\n     case BT_INCLUDE_LEVEL:\n       /* The line map depth counts the primary source as level 1, but\n \t historically __INCLUDE_DEPTH__ has called the primary source\n \t level 0.  */\n-      return new_number_token (pfile, pfile->line_maps.depth - 1);\n+      result = new_number_token (pfile, pfile->line_maps.depth - 1);\n+      break;\n \n     case BT_SPECLINE:\n       /* If __LINE__ is embedded in a macro, it must expand to the\n \t line of the macro's invocation, not its definition.\n \t Otherwise things like assert() will not work properly.  */\n-      return new_number_token (pfile, SOURCE_LINE (pfile->map,\n-\t\t\t\t\t\t   pfile->cur_token[-1].line));\n+      result = new_number_token (pfile,\n+\t\t\t\t SOURCE_LINE (pfile->map,\n+\t\t\t\t\t      pfile->cur_token[-1].line));\n+      break;\n \n     case BT_STDC:\n       {\n \tint stdc = (!CPP_IN_SYSTEM_HEADER (pfile)\n \t\t    || pfile->spec_nodes.n__STRICT_ANSI__->type != NT_VOID);\n-\treturn new_number_token (pfile, stdc);\n+\tresult = new_number_token (pfile, stdc);\n       }\n+      break;\n \n     case BT_DATE:\n     case BT_TIME:\n@@ -212,8 +221,24 @@ builtin_macro (pfile, node)\n \t\t   tb->tm_hour, tb->tm_min, tb->tm_sec);\n \t}\n \n-      return node->value.builtin == BT_DATE ? &pfile->date: &pfile->time;\n+      if (node->value.builtin == BT_DATE)\n+\tresult = &pfile->date;\n+      else\n+\tresult = &pfile->time;\n+      break;\n+\n+    case BT_PRAGMA:\n+      /* Don't interpret _Pragma within directives.  The standard is\n+         not clear on this, but to me this makes most sense.  */\n+      if (pfile->state.in_directive)\n+\treturn 0;\n+\n+      _cpp_do__Pragma (pfile);\n+      return 1;\n     }\n+\n+  push_token_context (pfile, NULL, result, 1);\n+  return 1;\n }\n \n /* Adds backslashes before all backslashes and double quotes appearing\n@@ -594,7 +619,7 @@ collect_args (pfile, node)\n static int\n funlike_invocation_p (pfile, node)\n      cpp_reader *pfile;\n-     const cpp_hashnode *node;\n+     cpp_hashnode *node;\n {\n   const cpp_token *maybe_paren;\n   _cpp_buff *buff = NULL;\n@@ -626,7 +651,7 @@ funlike_invocation_p (pfile, node)\n   if (buff)\n     {\n       if (node->value.macro->paramc > 0)\n-\treplace_args (pfile, node->value.macro, (macro_arg *) buff->base);\n+\treplace_args (pfile, node, (macro_arg *) buff->base);\n       _cpp_release_buff (pfile, buff);\n     }\n \n@@ -642,44 +667,50 @@ enter_macro_context (pfile, node)\n      cpp_reader *pfile;\n      cpp_hashnode *node;\n {\n-  if (node->flags & NODE_BUILTIN)\n-    push_token_context (pfile, NULL, builtin_macro (pfile, node), 1);\n-  else\n+  /* Macros invalidate controlling macros.  */\n+  pfile->mi_valid = false;\n+\n+  /* Handle macros and the _Pragma operator.  */\n+  if (! (node->flags & NODE_BUILTIN))\n     {\n       cpp_macro *macro = node->value.macro;\n \n       if (macro->fun_like && !funlike_invocation_p (pfile, node))\n \treturn 0;\n \n       /* Disable the macro within its expansion.  */\n-      macro->disabled = 1;\n+      node->flags |= NODE_DISABLED;\n \n       if (macro->paramc == 0)\n-\tpush_token_context (pfile, macro, macro->expansion, macro->count);\n+\tpush_token_context (pfile, node, macro->expansion, macro->count);\n+\n+      return 1;\n     }\n- \n-  return 1;\n+\n+  return builtin_macro (pfile, node);\n }\n \n /* Take the expansion of a function-like MACRO, replacing parameters\n    with the actual arguments.  Each argument is macro-expanded before\n    replacement, unless operated upon by the # or ## operators.  */\n static void\n-replace_args (pfile, macro, args)\n+replace_args (pfile, node, args)\n      cpp_reader *pfile;\n-     cpp_macro *macro;\n+     cpp_hashnode *node;\n      macro_arg *args;\n {\n   unsigned int i, total;\n   const cpp_token *src, *limit;\n   const cpp_token **dest, **first;\n   macro_arg *arg;\n   _cpp_buff *buff;\n+  cpp_macro *macro;\n \n   /* First, fully macro-expand arguments, calculating the number of\n      tokens in the final expansion as we go.  The ordering of the if\n      statements below is subtle; we must handle stringification before\n      pasting.  */\n+  macro = node->value.macro;\n   total = macro->count;\n   limit = macro->expansion + macro->count;\n \n@@ -797,7 +828,7 @@ replace_args (pfile, macro, args)\n     if (args[i].expanded)\n       free (args[i].expanded);\n \n-  push_ptoken_context (pfile, macro, buff, first, dest - first);\n+  push_ptoken_context (pfile, node, buff, first, dest - first);\n }\n \n /* Return a special padding token, with padding inherited from SOURCE.  */\n@@ -837,7 +868,7 @@ next_context (pfile)\n static void\n push_ptoken_context (pfile, macro, buff, first, count)\n      cpp_reader *pfile;\n-     cpp_macro *macro;\n+     cpp_hashnode *macro;\n      _cpp_buff *buff;\n      const cpp_token **first;\n      unsigned int count;\n@@ -855,7 +886,7 @@ push_ptoken_context (pfile, macro, buff, first, count)\n static void\n push_token_context (pfile, macro, first, count)\n      cpp_reader *pfile;\n-     cpp_macro *macro;\n+     cpp_hashnode *macro;\n      const cpp_token *first;\n      unsigned int count;\n {\n@@ -914,7 +945,7 @@ _cpp_pop_context (pfile)\n \n   /* Re-enable a macro when leaving its expansion.  */\n   if (context->macro)\n-    context->macro->disabled = 0;\n+    context->macro->flags &= ~NODE_DISABLED;\n \n   if (context->buff)\n     _cpp_release_buff (pfile, context->buff);\n@@ -975,39 +1006,30 @@ cpp_get_token (pfile)\n \n       node = result->val.node;\n \n-      /* Handle macros and the _Pragma operator.  */\n-      if (node->type == NT_MACRO && !(result->flags & NO_EXPAND))\n+      if (node->type != NT_MACRO || (result->flags & NO_EXPAND))\n+\tbreak;\n+      \n+      if (!(node->flags & NODE_DISABLED))\n \t{\n-\t  /* Macros invalidate controlling macros.  */\n-\t  pfile->mi_valid = false;\n-\n-\t  if (!(node->flags & NODE_BUILTIN) && node->value.macro->disabled)\n-\t    {\n-\t      /* Flag this token as always unexpandable.  */\n-\t      cpp_token *t = _cpp_temp_token (pfile);\n-\t      t->type = result->type;\n-\t      t->flags = result->flags | NO_EXPAND;\n-\t      t->val.str = result->val.str;\n-\t      result = t;\n-\t    }\n-\t  else if (!pfile->state.prevent_expansion\n-\t\t   && enter_macro_context (pfile, node))\n+\t  if (!pfile->state.prevent_expansion\n+\t      && enter_macro_context (pfile, node))\n \t    {\n \t      if (pfile->state.in_directive)\n \t\tcontinue;\n \t      return padding_token (pfile, result);\n \t    }\n \t}\n+      else\n+\t{\n+\t  /* Flag this token as always unexpandable.  */\n+\t  cpp_token *t = _cpp_temp_token (pfile);\n+\t  t->type = result->type;\n+\t  t->flags = result->flags | NO_EXPAND;\n+\t  t->val.str = result->val.str;\n+\t  result = t;\n+\t}\n \n-      /* Don't interpret _Pragma within directives.  The standard is\n-         not clear on this, but to me this makes most sense.  */\n-      if (node != pfile->spec_nodes.n__Pragma\n-\t  || pfile->state.in_directive)\n-\tbreak;\n-\n-      /* Handle it, and loop back for another token.  MI is cleared\n-         since this token came from either the lexer or a macro.  */\n-      _cpp_do__Pragma (pfile);\n+      break;\n     }\n \n   return result;\n@@ -1020,9 +1042,9 @@ int\n cpp_sys_macro_p (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_macro *macro = pfile->context->macro;\n+  cpp_hashnode *node = pfile->context->macro;\n \n-  return macro && macro->syshdr;\n+  return node && node->value.macro && node->value.macro->syshdr;\n }\n \n /* Read each token in, until EOF.  Directives are transparently\n@@ -1118,7 +1140,7 @@ _cpp_free_definition (h)\n   /* Macros and assertions no longer have anything to free.  */\n   h->type = NT_VOID;\n   /* Clear builtin flag in case of redefinition.  */\n-  h->flags &= ~NODE_BUILTIN;\n+  h->flags &= ~(NODE_BUILTIN | NODE_DISABLED);\n }\n \n /* Save parameter NODE to the parameter list of macro MACRO.  Returns\n@@ -1360,9 +1382,10 @@ _cpp_create_definition (pfile, node)\n   BUFF_FRONT (pfile->a_buff) = (U_CHAR *) &macro->expansion[macro->count];\n \n   /* Implement the macro-defined-to-itself optimisation.  */\n-  macro->disabled = (macro->count == 1 && !macro->fun_like\n-\t\t     && macro->expansion[0].type == CPP_NAME\n-\t\t     && macro->expansion[0].val.node == node);\n+  if (macro->count == 1 && !macro->fun_like\n+      && macro->expansion[0].type == CPP_NAME\n+      && macro->expansion[0].val.node == node)\n+    node->flags |= NODE_DISABLED;\n \n   /* To suppress some diagnostics.  */\n   macro->syshdr = pfile->map->sysp != 0;"}, {"sha": "6d41af73f24909ca803e1776e4579454bb4cffd9", "filename": "gcc/cppmain.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644eddaac53831b51967cea591f0bdf3b5e770a7/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644eddaac53831b51967cea591f0bdf3b5e770a7/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=644eddaac53831b51967cea591f0bdf3b5e770a7", "patch": "@@ -215,8 +215,8 @@ setup_callbacks ()\n     }\n }\n \n-/* Writes out the preprocessed file.  Alternates between two tokens,\n-   so that we can avoid accidental token pasting.  */\n+/* Writes out the preprocessed file, handling spacing and paste\n+   avoidance issues.  */\n static void\n scan_translation_unit (pfile)\n      cpp_reader *pfile;\n@@ -334,7 +334,7 @@ print_line (map, line, special_flags)\n }\n \n /* Called when a line of output is started.  TOKEN is the first token\n-   of the line, and maybe be CPP_EOF.  */\n+   of the line, and may be CPP_EOF.  */\n \n static void\n cb_line_change (pfile, token, parsing_args)"}]}