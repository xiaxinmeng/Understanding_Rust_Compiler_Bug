{"sha": "7e5487a214d591ab394310fa2f8840c42b745ee7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U1NDg3YTIxNGQ1OTFhYjM5NDMxMGZhMmY4ODQwYzQyYjc0NWVlNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2009-05-16T06:54:11Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2009-05-16T06:54:11Z"}, "message": "alias.c (struct alias_set_entry_d): Rename from struct alias_set_entry.\n\ngcc/ChangeLog:\n\t* alias.c (struct alias_set_entry_d): Rename from struct\n\talias_set_entry.  Change all uses.\n\t* except.c (struct call_site_record_d): Rename from struct\n\tcall_site_record.  Change all uses.\n\t* except.h (struct eh_region_d): Rename from struct eh_region.\n\tChange all uses.\n\t* gcse.c (struct hash_table_d): Rename from struct hash_table.\n\tChange all uses.\n\t* graphite.c (struct ivtype_map_elt_d): Rename fromstruct\n\tivtype_map_elt.  Change all uses.\n\t(struct rename_map_elt_d): Rename fromstruct rename_map_elt.\n\tChange all uses.\n\t(struct ifsese_d): Rename fromstruct ifsese.  Change all uses.\n\t* graphite.h (struct name_tree_d): Rename from struct name_tree.\n\tChange all uses.\n\t(struct sese_d): Rename from struct sese.  Change all uses.\n\t* omega.h (struct eqn_d): Rename from struct eqn.  Change all\n\tuses.\n\t(struct omega_pb_d): Rename from struct omega_pb.  Change all\n\tuses.\n\t* optabs.h (struct optab_d): Rename from struct optab.  Change all\n\tuses.\n\t(struct convert_optab_d): Rename from struct convert_optab.\n\tChange all uses.\n\t* tree-pass.h (struct ipa_opt_pass_d): Rename fromstruct\n\tipa_opt_pass.  Change all uses.\n\t* tree-predcom.c (struct dref_d): Rename from struct dref.  Change\n\tall uses.\n\n\t* c-decl.c (pushtag): If -Wc++-compat, warn if the tag is already\n\tdefined as a typedef.\n\t(grokdeclarator): If -Wc++-compat, warn if a typedef is already\n\tdefined as a tag.\ngcc/cp/ChangeLog:\n\t* cp-tree.h (enum cp_lvalue_kind_flags): Rename from\n\tcp_lvalue_kind.  Change all uses.\n\t(enum base_access_flags): Rename from enum base_access.  Change\n\tall uses.\n\t* parser.c (enum cp_parser_flags): Remove enum tag.\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/Wcxx-compat-10.c: New testcase.\nlibcpp/ChangeLog:\n\t* include/cpplib.h (enum cpp_builtin_type): Rename from enum\n\tbuiltin_type.  Change all uses.\n\nFrom-SVN: r147605", "tree": {"sha": "76d192436d10f2e90d4474a52e7b7f2156c2a5e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76d192436d10f2e90d4474a52e7b7f2156c2a5e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e5487a214d591ab394310fa2f8840c42b745ee7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e5487a214d591ab394310fa2f8840c42b745ee7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e5487a214d591ab394310fa2f8840c42b745ee7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e5487a214d591ab394310fa2f8840c42b745ee7/comments", "author": null, "committer": null, "parents": [{"sha": "7d47ae1d6491907d3f6c5c870bb83dceac1551c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d47ae1d6491907d3f6c5c870bb83dceac1551c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d47ae1d6491907d3f6c5c870bb83dceac1551c4"}], "stats": {"total": 737, "additions": 458, "deletions": 279}, "files": [{"sha": "c4177e61f5fb41dfc5a9f7100a3f69b11b0cd4de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -1,3 +1,39 @@\n+2009-05-15  Ian Lance Taylor  <iant@google.com>\n+\n+\t* alias.c (struct alias_set_entry_d): Rename from struct\n+\talias_set_entry.  Change all uses.\n+\t* except.c (struct call_site_record_d): Rename from struct\n+\tcall_site_record.  Change all uses.\n+\t* except.h (struct eh_region_d): Rename from struct eh_region.\n+\tChange all uses.\n+\t* gcse.c (struct hash_table_d): Rename from struct hash_table.\n+\tChange all uses.\n+\t* graphite.c (struct ivtype_map_elt_d): Rename fromstruct\n+\tivtype_map_elt.  Change all uses.\n+\t(struct rename_map_elt_d): Rename fromstruct rename_map_elt.\n+\tChange all uses.\n+\t(struct ifsese_d): Rename fromstruct ifsese.  Change all uses.\n+\t* graphite.h (struct name_tree_d): Rename from struct name_tree.\n+\tChange all uses.\n+\t(struct sese_d): Rename from struct sese.  Change all uses.\n+\t* omega.h (struct eqn_d): Rename from struct eqn.  Change all\n+\tuses.\n+\t(struct omega_pb_d): Rename from struct omega_pb.  Change all\n+\tuses.\n+\t* optabs.h (struct optab_d): Rename from struct optab.  Change all\n+\tuses.\n+\t(struct convert_optab_d): Rename from struct convert_optab.\n+\tChange all uses.\n+\t* tree-pass.h (struct ipa_opt_pass_d): Rename fromstruct\n+\tipa_opt_pass.  Change all uses.\n+\t* tree-predcom.c (struct dref_d): Rename from struct dref.  Change\n+\tall uses.\n+\n+\t* c-decl.c (pushtag): If -Wc++-compat, warn if the tag is already\n+\tdefined as a typedef.\n+\t(grokdeclarator): If -Wc++-compat, warn if a typedef is already\n+\tdefined as a tag.\n+\n 2009-05-15  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR 16302"}, {"sha": "18d5b747cb02c5450f7621f0e0b45f87384d7ce8", "filename": "gcc/alias.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -128,7 +128,7 @@ along with GCC; see the file COPYING3.  If not see\n    However, this is no actual entry for alias set zero.  It is an\n    error to attempt to explicitly construct a subset of zero.  */\n \n-struct GTY(()) alias_set_entry {\n+struct GTY(()) alias_set_entry_d {\n   /* The alias set number, as stored in MEM_ALIAS_SET.  */\n   alias_set_type alias_set;\n \n@@ -145,7 +145,7 @@ struct GTY(()) alias_set_entry {\n      `int', `double', `float', and `struct S'.  */\n   splay_tree GTY((param1_is (int), param2_is (int))) children;\n };\n-typedef struct alias_set_entry *alias_set_entry;\n+typedef struct alias_set_entry_d *alias_set_entry;\n \n static int rtx_equal_for_memref_p (const_rtx, const_rtx);\n static int memrefs_conflict_p (int, rtx, int, rtx, HOST_WIDE_INT);\n@@ -791,7 +791,7 @@ record_alias_subset (alias_set_type superset, alias_set_type subset)\n     {\n       /* Create an entry for the SUPERSET, so that we have a place to\n \t attach the SUBSET.  */\n-      superset_entry = GGC_NEW (struct alias_set_entry);\n+      superset_entry = GGC_NEW (struct alias_set_entry_d);\n       superset_entry->alias_set = superset;\n       superset_entry->children\n \t= splay_tree_new_ggc (splay_tree_compare_ints);"}, {"sha": "0c05b2438b91a64758e31d2455ddd3c895451cf4", "filename": "gcc/c-decl.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -1114,6 +1114,27 @@ pushtag (tree name, tree type, location_t loc)\n   /* An approximation for now, so we can tell this is a function-scope tag.\n      This will be updated in pop_scope.  */\n   TYPE_CONTEXT (type) = DECL_CONTEXT (TYPE_STUB_DECL (type));\n+\n+  if (warn_cxx_compat && name != NULL_TREE)\n+    {\n+      struct c_binding *b = I_SYMBOL_BINDING (name);\n+\n+      if (b != NULL\n+\t  && b->decl != NULL_TREE\n+\t  && TREE_CODE (b->decl) == TYPE_DECL\n+\t  && (B_IN_CURRENT_SCOPE (b)\n+\t      || (current_scope == file_scope && B_IN_EXTERNAL_SCOPE (b)))\n+\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (b->decl))\n+\t      != TYPE_MAIN_VARIANT (type)))\n+\t{\n+\t  warning_at (loc, OPT_Wc___compat,\n+\t\t      (\"using %qD as both a typedef and a tag is \"\n+\t\t       \"invalid in C++\"),\n+\t\t      b->decl);\n+\t  if (b->locus != UNKNOWN_LOCATION)\n+\t    inform (b->locus, \"originally defined here\");\n+\t}\n+    }\n }\n \f\n /* Subroutine of compare_decls.  Allow harmless mismatches in return\n@@ -4961,6 +4982,26 @@ grokdeclarator (const struct c_declarator *declarator,\n \tC_TYPEDEF_EXPLICITLY_SIGNED (decl) = 1;\n       if (declspecs->inline_p)\n \tpedwarn (input_location, 0,\"typedef %q+D declared %<inline%>\", decl);\n+\n+      if (warn_cxx_compat && declarator->u.id != NULL_TREE)\n+\t{\n+\t  struct c_binding *b = I_TAG_BINDING (declarator->u.id);\n+\n+\t  if (b != NULL\n+\t      && b->decl != NULL_TREE\n+\t      && (B_IN_CURRENT_SCOPE (b)\n+\t\t  || (current_scope == file_scope && B_IN_EXTERNAL_SCOPE (b)))\n+\t      && TYPE_MAIN_VARIANT (b->decl) != TYPE_MAIN_VARIANT (type))\n+\t    {\n+\t      warning_at (declarator->id_loc, OPT_Wc___compat,\n+\t\t\t  (\"using %qD as both a typedef and a tag is \"\n+\t\t\t   \"invalid in C++\"),\n+\t\t\t  decl);\n+\t      if (b->locus != UNKNOWN_LOCATION)\n+\t\tinform (b->locus, \"originally defined here\");\n+\t    }\n+\t}\n+\n       return decl;\n     }\n "}, {"sha": "7bd5f9348123ec478c0a48b236d4d86f8747f50d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -1,3 +1,11 @@\n+2009-05-15  Ian Lance Taylor  <iant@google.com>\n+\n+\t* cp-tree.h (enum cp_lvalue_kind_flags): Rename from\n+\tcp_lvalue_kind.  Change all uses.\n+\t(enum base_access_flags): Rename from enum base_access.  Change\n+\tall uses.\n+\t* parser.c (enum cp_parser_flags): Remove enum tag.\n+\n 2009-05-15  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR 16302"}, {"sha": "e6545f650f0f09917c6ac7b0ba673455b59bc2ba", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -3466,7 +3466,7 @@ enum tag_types {\n };\n \n /* The various kinds of lvalues we distinguish.  */\n-enum cp_lvalue_kind {\n+enum cp_lvalue_kind_flags {\n   clk_none = 0,     /* Things that are not an lvalue.  */\n   clk_ordinary = 1, /* An ordinary lvalue.  */\n   clk_class = 2,    /* An rvalue of class-type.  */\n@@ -3475,7 +3475,7 @@ enum cp_lvalue_kind {\n };\n \n /* This type is used for parameters and variables which hold\n-   combinations of the flags in enum cp_lvalue_kind.  */\n+   combinations of the flags in enum cp_lvalue_kind_flags.  */\n typedef int cp_lvalue_kind;\n \n /* Various kinds of template specialization, instantiation, etc.  */\n@@ -3575,7 +3575,7 @@ enum tsubst_flags {\n typedef int tsubst_flags_t;\n \n /* The kind of checking we can do looking in a class hierarchy.  */\n-enum base_access {\n+enum base_access_flags {\n   ba_any = 0,  /* Do not check access, allow an ambiguous base,\n \t\t      prefer a non-virtual base */\n   ba_unique = 1 << 0,  /* Must be a unique base.  */\n@@ -3586,7 +3586,7 @@ enum base_access {\n };\n \n /* This type is used for parameters and variables which hold\n-   combinations of the flags in enum base_access.  */\n+   combinations of the flags in enum base_access_flags.  */\n typedef int base_access;\n \n /* The various kinds of access check during parsing.  */"}, {"sha": "6954ef0b35e3d5dd5c3874914c9d970ec469553a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -1183,7 +1183,7 @@ function_declarator_p (const cp_declarator *declarator)\n /* Flags that are passed to some parsing functions.  These values can\n    be bitwise-ored together.  */\n \n-enum cp_parser_flags\n+enum\n {\n   /* No flags.  */\n   CP_PARSER_FLAGS_NONE = 0x0,\n@@ -1195,7 +1195,7 @@ enum cp_parser_flags\n };\n \n /* This type is used for parameters and variables which hold\n-   combinations of the flags in enum cp_parser_flags.  */\n+   combinations of the above flags.  */\n typedef int cp_parser_flags;\n \n /* The different kinds of declarators we want to parse.  */"}, {"sha": "a698e8f1c5ba69d2d4933fda6b4b4529f8025e9a", "filename": "gcc/except.c", "status": "modified", "additions": 130, "deletions": 121, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -99,7 +99,7 @@ tree (*lang_eh_runtime_type) (tree);\n \n struct GTY(()) ehl_map_entry {\n   rtx label;\n-  struct eh_region *region;\n+  struct eh_region_d *region;\n };\n \n static GTY(()) int call_site_base;\n@@ -115,7 +115,7 @@ static int sjlj_fc_lsda_ofs;\n static int sjlj_fc_jbuf_ofs;\n \f\n \n-struct GTY(()) call_site_record\n+struct GTY(()) call_site_record_d\n {\n   rtx landing_pad;\n   int action;\n@@ -144,9 +144,9 @@ static void sjlj_emit_function_exit (void);\n static void sjlj_emit_dispatch_table (rtx, struct sjlj_lp_info *);\n static void sjlj_build_landing_pads (void);\n \n-static void remove_eh_handler (struct eh_region *);\n-static void remove_eh_handler_and_replace (struct eh_region *,\n-\t\t\t\t\t   struct eh_region *, bool);\n+static void remove_eh_handler (struct eh_region_d *);\n+static void remove_eh_handler_and_replace (struct eh_region_d *,\n+\t\t\t\t\t   struct eh_region_d *, bool);\n \n /* The return value of reachable_next_level.  */\n enum reachable_code\n@@ -162,13 +162,13 @@ enum reachable_code\n };\n \n struct reachable_info;\n-static enum reachable_code reachable_next_level (struct eh_region *, tree,\n+static enum reachable_code reachable_next_level (struct eh_region_d *, tree,\n \t\t\t\t\t\t struct reachable_info *, bool);\n \n static int action_record_eq (const void *, const void *);\n static hashval_t action_record_hash (const void *);\n static int add_action_record (htab_t, int, int);\n-static int collect_one_action_chain (htab_t, struct eh_region *);\n+static int collect_one_action_chain (htab_t, struct eh_region_d *);\n static int add_call_site (rtx, int);\n \n static void push_uleb128 (varray_type *, unsigned int);\n@@ -308,17 +308,17 @@ init_eh_for_function (void)\n    These are used from tree-eh.c when processing exception related\n    nodes during tree optimization.  */\n \n-static struct eh_region *\n-gen_eh_region (enum eh_region_type type, struct eh_region *outer)\n+static struct eh_region_d *\n+gen_eh_region (enum eh_region_type type, struct eh_region_d *outer)\n {\n-  struct eh_region *new_eh;\n+  struct eh_region_d *new_eh;\n \n #ifdef ENABLE_CHECKING\n   gcc_assert (doing_eh (0));\n #endif\n \n   /* Insert a new blank region as a leaf in the tree.  */\n-  new_eh = GGC_CNEW (struct eh_region);\n+  new_eh = GGC_CNEW (struct eh_region_d);\n   new_eh->type = type;\n   new_eh->outer = outer;\n   if (outer)\n@@ -337,23 +337,23 @@ gen_eh_region (enum eh_region_type type, struct eh_region *outer)\n   return new_eh;\n }\n \n-struct eh_region *\n-gen_eh_region_cleanup (struct eh_region *outer)\n+struct eh_region_d *\n+gen_eh_region_cleanup (struct eh_region_d *outer)\n {\n-  struct eh_region *cleanup = gen_eh_region (ERT_CLEANUP, outer);\n+  struct eh_region_d *cleanup = gen_eh_region (ERT_CLEANUP, outer);\n   return cleanup;\n }\n \n-struct eh_region *\n-gen_eh_region_try (struct eh_region *outer)\n+struct eh_region_d *\n+gen_eh_region_try (struct eh_region_d *outer)\n {\n   return gen_eh_region (ERT_TRY, outer);\n }\n \n-struct eh_region *\n-gen_eh_region_catch (struct eh_region *t, tree type_or_list)\n+struct eh_region_d *\n+gen_eh_region_catch (struct eh_region_d *t, tree type_or_list)\n {\n-  struct eh_region *c, *l;\n+  struct eh_region_d *c, *l;\n   tree type_list, type_node;\n \n   /* Ensure to always end up with a type list to normalize further\n@@ -382,10 +382,10 @@ gen_eh_region_catch (struct eh_region *t, tree type_or_list)\n   return c;\n }\n \n-struct eh_region *\n-gen_eh_region_allowed (struct eh_region *outer, tree allowed)\n+struct eh_region_d *\n+gen_eh_region_allowed (struct eh_region_d *outer, tree allowed)\n {\n-  struct eh_region *region = gen_eh_region (ERT_ALLOWED_EXCEPTIONS, outer);\n+  struct eh_region_d *region = gen_eh_region (ERT_ALLOWED_EXCEPTIONS, outer);\n   region->u.allowed.type_list = allowed;\n \n   for (; allowed ; allowed = TREE_CHAIN (allowed))\n@@ -394,26 +394,26 @@ gen_eh_region_allowed (struct eh_region *outer, tree allowed)\n   return region;\n }\n \n-struct eh_region *\n-gen_eh_region_must_not_throw (struct eh_region *outer)\n+struct eh_region_d *\n+gen_eh_region_must_not_throw (struct eh_region_d *outer)\n {\n   return gen_eh_region (ERT_MUST_NOT_THROW, outer);\n }\n \n int\n-get_eh_region_number (struct eh_region *region)\n+get_eh_region_number (struct eh_region_d *region)\n {\n   return region->region_number;\n }\n \n bool\n-get_eh_region_may_contain_throw (struct eh_region *region)\n+get_eh_region_may_contain_throw (struct eh_region_d *region)\n {\n   return region->may_contain_throw;\n }\n \n tree\n-get_eh_region_tree_label (struct eh_region *region)\n+get_eh_region_tree_label (struct eh_region_d *region)\n {\n   return region->tree_label;\n }\n@@ -425,7 +425,7 @@ get_eh_region_no_tree_label (int region)\n }\n \n void\n-set_eh_region_tree_label (struct eh_region *region, tree lab)\n+set_eh_region_tree_label (struct eh_region_d *region, tree lab)\n {\n   region->tree_label = lab;\n }\n@@ -434,8 +434,8 @@ void\n expand_resx_expr (tree exp)\n {\n   int region_nr = TREE_INT_CST_LOW (TREE_OPERAND (exp, 0));\n-  struct eh_region *reg = VEC_index (eh_region,\n-\t\t\t\t     cfun->eh->region_array, region_nr);\n+  struct eh_region_d *reg = VEC_index (eh_region,\n+\t\t\t\t       cfun->eh->region_array, region_nr);\n \n   gcc_assert (!reg->resume);\n   do_pending_stack_adjust ();\n@@ -447,7 +447,7 @@ expand_resx_expr (tree exp)\n    call to a function which itself may contain a throw.  */\n \n void\n-note_eh_region_may_contain_throw (struct eh_region *region)\n+note_eh_region_may_contain_throw (struct eh_region_d *region)\n {\n   while (region && !region->may_contain_throw)\n     {\n@@ -486,7 +486,7 @@ get_exception_filter (void)\n void\n collect_eh_region_array (void)\n {\n-  struct eh_region *i;\n+  struct eh_region_d *i;\n \n   i = cfun->eh->region_tree;\n   if (! i)\n@@ -538,9 +538,9 @@ collect_eh_region_array (void)\n    a problem.  */\n \n static bool\n-can_be_reached_by_runtime (sbitmap contains_stmt, struct eh_region *r)\n+can_be_reached_by_runtime (sbitmap contains_stmt, struct eh_region_d *r)\n {\n-  struct eh_region *i = r->inner;\n+  struct eh_region_d *i = r->inner;\n   unsigned n;\n   bitmap_iterator bi;\n \n@@ -574,7 +574,7 @@ can_be_reached_by_runtime (sbitmap contains_stmt, struct eh_region *r)\n \t     firest place.  */\n \t  if (found)\n \t    {\n-\t      struct eh_region *i1 = i;\n+\t      struct eh_region_d *i1 = i;\n \t      tree type_thrown = NULL_TREE;\n \n \t      if (i1->type == ERT_THROW)\n@@ -614,10 +614,10 @@ can_be_reached_by_runtime (sbitmap contains_stmt, struct eh_region *r)\n /* Bring region R to the root of tree.  */\n \n static void\n-bring_to_root (struct eh_region *r)\n+bring_to_root (struct eh_region_d *r)\n {\n-  struct eh_region **pp;\n-  struct eh_region *outer = r->outer;\n+  struct eh_region_d **pp;\n+  struct eh_region_d *outer = r->outer;\n   if (!r->outer)\n     return;\n   for (pp = &outer->inner; *pp != r; pp = &(*pp)->next_peer)\n@@ -631,8 +631,8 @@ bring_to_root (struct eh_region *r)\n /* Return true if region R2 can be replaced by R1.  */\n \n static bool\n-eh_region_replaceable_by_p (const struct eh_region *r1,\n-\t\t\t    const struct eh_region *r2)\n+eh_region_replaceable_by_p (const struct eh_region_d *r1,\n+\t\t\t    const struct eh_region_d *r2)\n {\n   /* Regions are semantically same if they are of same type,\n      have same label and type.  */\n@@ -649,7 +649,7 @@ eh_region_replaceable_by_p (const struct eh_region *r1,\n \tbreak;\n       case ERT_TRY:\n \t{\n-\t  struct eh_region *c1, *c2;\n+\t  struct eh_region_d *c1, *c2;\n \t  for (c1 = r1->u.eh_try.eh_catch,\n \t       c2 = r2->u.eh_try.eh_catch;\n \t       c1 && c2;\n@@ -690,10 +690,10 @@ eh_region_replaceable_by_p (const struct eh_region *r1,\n /* Replace region R2 by R1.  */\n \n static void\n-replace_region (struct eh_region *r1, struct eh_region *r2)\n+replace_region (struct eh_region_d *r1, struct eh_region_d *r2)\n {\n-  struct eh_region *next1 = r1->u.eh_try.eh_catch;\n-  struct eh_region *next2 = r2->u.eh_try.eh_catch;\n+  struct eh_region_d *next1 = r1->u.eh_try.eh_catch;\n+  struct eh_region_d *next2 = r2->u.eh_try.eh_catch;\n   bool is_try = r1->type == ERT_TRY;\n \n   gcc_assert (r1->type != ERT_CATCH);\n@@ -729,7 +729,7 @@ hash_type_list (tree t)\n static hashval_t\n hash_eh_region (const void *r)\n {\n-  const struct eh_region *region = (const struct eh_region *)r;\n+  const struct eh_region_d *region = (const struct eh_region_d *) r;\n   hashval_t val = region->type;\n \n   if (region->tree_label)\n@@ -741,7 +741,7 @@ hash_eh_region (const void *r)\n \tbreak;\n       case ERT_TRY:\n \t{\n-\t  struct eh_region *c;\n+\t  struct eh_region_d *c;\n \t  for (c = region->u.eh_try.eh_catch;\n \t       c; c = c->u.eh_catch.next_catch)\n \t    val = iterative_hash_hashval_t (hash_eh_region (c), val);\n@@ -770,18 +770,18 @@ hash_eh_region (const void *r)\n static int\n eh_regions_equal_p (const void *r1, const void *r2)\n {\n-  return eh_region_replaceable_by_p ((const struct eh_region *)r1,\n-\t\t\t\t     (const struct eh_region *)r2);\n+  return eh_region_replaceable_by_p ((const struct eh_region_d *) r1,\n+\t\t\t\t     (const struct eh_region_d *) r2);\n }\n \n /* Walk all peers of REGION and try to merge those regions\n    that are semantically equivalent.  Look into subregions\n    recursively too.  */\n \n static bool\n-merge_peers (struct eh_region *region)\n+merge_peers (struct eh_region_d *region)\n {\n-  struct eh_region *r1, *r2, *outer = NULL, *next;\n+  struct eh_region_d *r1, *r2, *outer = NULL, *next;\n   bool merged = false;\n   int num_regions = 0;\n   if (region)\n@@ -851,7 +851,7 @@ merge_peers (struct eh_region *region)\n \t  if (!*slot)\n \t    *slot = r1;\n \t  else\n-\t    replace_region ((struct eh_region *)*slot, r1);\n+\t    replace_region ((struct eh_region_d *) *slot, r1);\n \t}\n       htab_delete (hash);\n     }\n@@ -868,10 +868,10 @@ void\n remove_unreachable_regions (sbitmap reachable, sbitmap contains_stmt)\n {\n   int i;\n-  struct eh_region *r;\n+  struct eh_region_d *r;\n   VEC(eh_region,heap) *must_not_throws = VEC_alloc (eh_region, heap, 16);\n-  struct eh_region *local_must_not_throw = NULL;\n-  struct eh_region *first_must_not_throw = NULL;\n+  struct eh_region_d *local_must_not_throw = NULL;\n+  struct eh_region_d *first_must_not_throw = NULL;\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n@@ -907,7 +907,7 @@ remove_unreachable_regions (sbitmap reachable, sbitmap contains_stmt)\n \t      {\n \t\t/* TRY regions are reachable if any of its CATCH regions\n \t\t   are reachable.  */\n-\t\tstruct eh_region *c;\n+\t\tstruct eh_region_d *c;\n \t\tfor (c = r->u.eh_try.eh_catch; c;\n \t\t     c = c->u.eh_catch.next_catch)\n \t\t  if (TEST_BIT (reachable, c->region_number))\n@@ -1001,7 +1001,7 @@ label_to_region_map (void)\n \t\t\t cfun->cfg->last_label_uid + 1);\n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n-      struct eh_region *r = VEC_index (eh_region, cfun->eh->region_array, i);\n+      struct eh_region_d *r = VEC_index (eh_region, cfun->eh->region_array, i);\n       if (r && r->region_number == i\n \t  && r->tree_label && LABEL_DECL_UID (r->tree_label) >= 0)\n \t{\n@@ -1030,7 +1030,7 @@ num_eh_regions (void)\n int\n get_next_region_sharing_label (int region)\n {\n-  struct eh_region *r;\n+  struct eh_region_d *r;\n   if (!region)\n     return 0;\n   r = VEC_index (eh_region, cfun->eh->region_array, region);\n@@ -1052,7 +1052,7 @@ convert_from_eh_region_ranges (void)\n      we allocated earlier.  */\n   for (i = 1; i <= n; ++i)\n     {\n-      struct eh_region *region;\n+      struct eh_region_d *region;\n \n       region = VEC_index (eh_region, cfun->eh->region_array, i);\n       if (region && region->tree_label)\n@@ -1070,7 +1070,7 @@ find_exception_handler_labels (void)\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n-      struct eh_region *region;\n+      struct eh_region_d *region;\n       rtx lab;\n \n       region = VEC_index (eh_region, cfun->eh->region_array, i);\n@@ -1092,7 +1092,7 @@ current_function_has_exception_handlers (void)\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n-      struct eh_region *region;\n+      struct eh_region_d *region;\n \n       region = VEC_index (eh_region, cfun->eh->region_array, i);\n       if (region\n@@ -1147,7 +1147,7 @@ duplicate_eh_regions_1 (eh_region old, eh_region outer, int eh_offset)\n {\n   eh_region ret, n;\n \n-  ret = n = GGC_NEW (struct eh_region);\n+  ret = n = GGC_NEW (struct eh_region_d);\n \n   *n = *old;\n   n->outer = outer;\n@@ -1185,8 +1185,8 @@ duplicate_eh_regions_1 (eh_region old, eh_region outer, int eh_offset)\n /* Look for first outer region of R (or R itself) that is\n    TRY region. Return NULL if none.  */\n \n-static struct eh_region *\n-find_prev_try (struct eh_region * r)\n+static struct eh_region_d *\n+find_prev_try (struct eh_region_d * r)\n {\n   for (; r && r->type != ERT_TRY; r = r->outer)\n     if (r->type == ERT_MUST_NOT_THROW\n@@ -1361,10 +1361,10 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n /* Return new copy of eh region OLD inside region NEW_OUTER.\n    Do not care about updating the tree otherwise.  */\n \n-static struct eh_region *\n-copy_eh_region_1 (struct eh_region *old, struct eh_region *new_outer)\n+static struct eh_region_d *\n+copy_eh_region_1 (struct eh_region_d *old, struct eh_region_d *new_outer)\n {\n-  struct eh_region *new_eh = gen_eh_region (old->type, new_outer);\n+  struct eh_region_d *new_eh = gen_eh_region (old->type, new_outer);\n   new_eh->u = old->u;\n   new_eh->tree_label = old->tree_label;\n   new_eh->may_contain_throw = old->may_contain_throw;\n@@ -1380,10 +1380,10 @@ copy_eh_region_1 (struct eh_region *old, struct eh_region *new_outer)\n   \n    Copy whole catch-try chain if neccesary.  */\n \n-static struct eh_region *\n-copy_eh_region (struct eh_region *old, struct eh_region *new_outer)\n+static struct eh_region_d *\n+copy_eh_region (struct eh_region_d *old, struct eh_region_d *new_outer)\n {\n-  struct eh_region *r, *n, *old_try, *new_try, *ret = NULL;\n+  struct eh_region_d *r, *n, *old_try, *new_try, *ret = NULL;\n   VEC(eh_region,heap) *catch_list = NULL;\n \n   if (old->type != ERT_CATCH)\n@@ -1438,7 +1438,7 @@ copy_eh_region (struct eh_region *old, struct eh_region *new_outer)\n /* Callback for forach_reachable_handler that push REGION into single VECtor DATA.  */\n \n static void\n-push_reachable_handler (struct eh_region *region, void *data)\n+push_reachable_handler (struct eh_region_d *region, void *data)\n {\n   VEC(eh_region,heap) **trace = (VEC(eh_region,heap) **) data;\n   VEC_safe_push (eh_region, heap, *trace, region);\n@@ -1448,17 +1448,17 @@ push_reachable_handler (struct eh_region *region, void *data)\n    IS_RESX, INLINABLE_CALL and REGION_NMUBER match the parameter of\n    foreach_reachable_handler.  */\n \n-struct eh_region *\n+struct eh_region_d *\n redirect_eh_edge_to_label (edge e, tree new_dest_label, bool is_resx,\n \t\t\t   bool inlinable_call, int region_number)\n {\n-  struct eh_region *outer;\n-  struct eh_region *region;\n+  struct eh_region_d *outer;\n+  struct eh_region_d *region;\n   VEC (eh_region, heap) * trace = NULL;\n   int i;\n   int start_here = -1;\n   basic_block old_bb = e->dest;\n-  struct eh_region *old, *r = NULL;\n+  struct eh_region_d *old, *r = NULL;\n   bool update_inplace = true;\n   edge_iterator ei;\n   edge e2;\n@@ -1584,7 +1584,7 @@ redirect_eh_edge_to_label (edge e, tree new_dest_label, bool is_resx,\n int\n eh_region_outermost (struct function *ifun, int region_a, int region_b)\n {\n-  struct eh_region *rp_a, *rp_b;\n+  struct eh_region_d *rp_a, *rp_b;\n   sbitmap b_outer;\n \n   gcc_assert (ifun->eh->last_region_number > 0);\n@@ -1810,7 +1810,7 @@ assign_filter_values (void)\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n-      struct eh_region *r;\n+      struct eh_region_d *r;\n \n       r = VEC_index (eh_region, cfun->eh->region_array, i);\n \n@@ -1905,7 +1905,7 @@ build_post_landing_pads (void)\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n-      struct eh_region *region;\n+      struct eh_region_d *region;\n       rtx seq;\n \n       region = VEC_index (eh_region, cfun->eh->region_array, i);\n@@ -1938,7 +1938,7 @@ build_post_landing_pads (void)\n \t     switch statement generation code in expand_end_case.\n \t     Rapid prototyping sez a sequence of ifs.  */\n \t  {\n-\t    struct eh_region *c;\n+\t    struct eh_region_d *c;\n \t    for (c = region->u.eh_try.eh_catch; c ; c = c->u.eh_catch.next_catch)\n \t      {\n \t\tif (c->u.eh_catch.type_list == NULL)\n@@ -2033,8 +2033,8 @@ connect_post_landing_pads (void)\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n-      struct eh_region *region;\n-      struct eh_region *outer;\n+      struct eh_region_d *region;\n+      struct eh_region_d *outer;\n       rtx seq;\n       rtx barrier;\n \n@@ -2110,7 +2110,7 @@ dw2_build_landing_pads (void)\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n-      struct eh_region *region;\n+      struct eh_region_d *region;\n       rtx seq;\n       basic_block bb;\n       edge e;\n@@ -2178,7 +2178,7 @@ sjlj_find_directly_reachable_regions (struct sjlj_lp_info *lp_info)\n \n   for (insn = get_insns (); insn ; insn = NEXT_INSN (insn))\n     {\n-      struct eh_region *region;\n+      struct eh_region_d *region;\n       enum reachable_code rc;\n       tree type_thrown;\n       rtx note;\n@@ -2234,7 +2234,8 @@ sjlj_assign_call_site_values (rtx dispatch_label, struct sjlj_lp_info *lp_info)\n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     if (lp_info[i].directly_reachable)\n       {\n-\tstruct eh_region *r = VEC_index (eh_region, cfun->eh->region_array, i);\n+\tstruct eh_region_d *r =\n+\t  VEC_index (eh_region, cfun->eh->region_array, i);\n \n \tr->landing_pad = dispatch_label;\n \tlp_info[i].action_index = collect_one_action_chain (ar_hash, r);\n@@ -2291,7 +2292,7 @@ sjlj_mark_call_sites (struct sjlj_lp_info *lp_info)\n \n   for (insn = get_insns (); insn ; insn = NEXT_INSN (insn))\n     {\n-      struct eh_region *region;\n+      struct eh_region_d *region;\n       int this_call_site;\n       rtx note, before, p;\n \n@@ -2518,14 +2519,17 @@ sjlj_emit_dispatch_table (rtx dispatch_label, struct sjlj_lp_info *lp_info)\n \n       emit_cmp_and_jump_insns (dispatch, GEN_INT (lp_info[i].dispatch_index),\n \t\t\t       EQ, NULL_RTX, TYPE_MODE (integer_type_node), 0,\n-\t                       ((struct eh_region *)VEC_index (eh_region, cfun->eh->region_array, i))\n-\t\t\t\t->post_landing_pad);\n+\t                       (((struct eh_region_d *)\n+\t\t\t\t VEC_index (eh_region,\n+\t\t\t\t\t    cfun->eh->region_array, i))\n+\t\t\t\t->post_landing_pad));\n     }\n \n   seq = get_insns ();\n   end_sequence ();\n \n-  before = (((struct eh_region *)VEC_index (eh_region, cfun->eh->region_array, first_reachable))\n+  before = (((struct eh_region_d *)\n+\t     VEC_index (eh_region, cfun->eh->region_array, first_reachable))\n \t    ->post_landing_pad);\n \n   bb = emit_to_new_bb_before (seq, before);\n@@ -2636,11 +2640,11 @@ finish_eh_generation (void)\n    region.*/\n \n static void\n-remove_eh_handler_and_replace (struct eh_region *region,\n-\t\t\t       struct eh_region *replace,\n+remove_eh_handler_and_replace (struct eh_region_d *region,\n+\t\t\t       struct eh_region_d *replace,\n \t\t\t       bool update_catch_try)\n {\n-  struct eh_region **pp, **pp_start, *p, *outer, *inner;\n+  struct eh_region_d **pp, **pp_start, *p, *outer, *inner;\n   rtx lab;\n \n   outer = region->outer;\n@@ -2703,7 +2707,7 @@ remove_eh_handler_and_replace (struct eh_region *region,\n   if (region->type == ERT_CATCH\n       && update_catch_try)\n     {\n-      struct eh_region *eh_try, *next, *prev;\n+      struct eh_region_d *eh_try, *next, *prev;\n \n       for (eh_try = region->next_peer;\n \t   eh_try->type == ERT_CATCH;\n@@ -2733,7 +2737,7 @@ remove_eh_handler_and_replace (struct eh_region *region,\n    etc.  */\n \n static void\n-remove_eh_handler (struct eh_region *region)\n+remove_eh_handler (struct eh_region_d *region)\n {\n   remove_eh_handler_and_replace (region, region->outer, true);\n }\n@@ -2743,7 +2747,7 @@ remove_eh_handler (struct eh_region *region)\n void\n remove_eh_region (int r)\n {\n-  struct eh_region *region;\n+  struct eh_region_d *region;\n \n   region = VEC_index (eh_region, cfun->eh->region_array, r);\n   remove_eh_handler (region);\n@@ -2755,7 +2759,7 @@ remove_eh_region (int r)\n void\n remove_eh_region_and_replace_by_outer_of (int r, int r2)\n {\n-  struct eh_region *region, *region2;\n+  struct eh_region_d *region, *region2;\n \n   region = VEC_index (eh_region, cfun->eh->region_array, r);\n   region2 = VEC_index (eh_region, cfun->eh->region_array, r2);\n@@ -2771,7 +2775,7 @@ for_each_eh_label (void (*callback) (rtx))\n   int i;\n   for (i = 0; i < cfun->eh->last_region_number; i++)\n     {\n-      struct eh_region *r = VEC_index (eh_region, cfun->eh->region_array, i);\n+      struct eh_region_d *r = VEC_index (eh_region, cfun->eh->region_array, i);\n       if (r && r->region_number == i && r->label\n           && GET_CODE (r->label) == CODE_LABEL)\n \t(*callback) (r->label);\n@@ -2781,12 +2785,12 @@ for_each_eh_label (void (*callback) (rtx))\n /* Invoke CALLBACK for every exception region in the current function.  */\n \n void\n-for_each_eh_region (void (*callback) (struct eh_region *))\n+for_each_eh_region (void (*callback) (struct eh_region_d *))\n {\n   int i, n = cfun->eh->last_region_number;\n   for (i = 1; i <= n; ++i)\n     {\n-      struct eh_region *region;\n+      struct eh_region_d *region;\n \n       region = VEC_index (eh_region, cfun->eh->region_array, i);\n       if (region)\n@@ -2801,7 +2805,7 @@ struct reachable_info\n {\n   tree types_caught;\n   tree types_allowed;\n-  void (*callback) (struct eh_region *, void *);\n+  void (*callback) (struct eh_region_d *, void *);\n   void *callback_data;\n };\n \n@@ -2840,7 +2844,8 @@ check_handled (tree handled, tree type)\n \n static void\n add_reachable_handler (struct reachable_info *info,\n-\t\t       struct eh_region *lp_region, struct eh_region *region)\n+\t\t       struct eh_region_d *lp_region,\n+\t\t       struct eh_region_d *region)\n {\n   if (! info)\n     return;\n@@ -2857,7 +2862,7 @@ add_reachable_handler (struct reachable_info *info,\n    and caught/allowed type information between invocations.  */\n \n static enum reachable_code\n-reachable_next_level (struct eh_region *region, tree type_thrown,\n+reachable_next_level (struct eh_region_d *region, tree type_thrown,\n \t\t      struct reachable_info *info,\n \t\t      bool maybe_resx)\n {\n@@ -2872,7 +2877,7 @@ reachable_next_level (struct eh_region *region, tree type_thrown,\n \n     case ERT_TRY:\n       {\n-\tstruct eh_region *c;\n+\tstruct eh_region_d *c;\n \tenum reachable_code ret = RNL_NOT_CAUGHT;\n \n \tfor (c = region->u.eh_try.eh_catch; c ; c = c->u.eh_catch.next_catch)\n@@ -3026,11 +3031,11 @@ reachable_next_level (struct eh_region *region, tree type_thrown,\n \n void\n foreach_reachable_handler (int region_number, bool is_resx, bool inlinable_call,\n-\t\t\t   void (*callback) (struct eh_region *, void *),\n+\t\t\t   void (*callback) (struct eh_region_d *, void *),\n \t\t\t   void *callback_data)\n {\n   struct reachable_info info;\n-  struct eh_region *region;\n+  struct eh_region_d *region;\n   tree type_thrown;\n \n   memset (&info, 0, sizeof (info));\n@@ -3088,15 +3093,15 @@ foreach_reachable_handler (int region_number, bool is_resx, bool inlinable_call,\n    reached by a given insn.  */\n \n static void\n-arh_to_landing_pad (struct eh_region *region, void *data)\n+arh_to_landing_pad (struct eh_region_d *region, void *data)\n {\n   rtx *p_handlers = (rtx *) data;\n   if (! *p_handlers)\n     *p_handlers = alloc_INSN_LIST (region->landing_pad, NULL_RTX);\n }\n \n static void\n-arh_to_label (struct eh_region *region, void *data)\n+arh_to_label (struct eh_region_d *region, void *data)\n {\n   rtx *p_handlers = (rtx *) data;\n   *p_handlers = alloc_INSN_LIST (region->label, *p_handlers);\n@@ -3138,7 +3143,7 @@ reachable_handlers (rtx insn)\n bool\n can_throw_internal_1 (int region_number, bool is_resx, bool inlinable_call)\n {\n-  struct eh_region *region;\n+  struct eh_region_d *region;\n   tree type_thrown;\n \n   region = VEC_index (eh_region, cfun->eh->region_array, region_number);\n@@ -3201,7 +3206,7 @@ can_throw_internal (const_rtx insn)\n bool\n can_throw_external_1 (int region_number, bool is_resx, bool inlinable_call)\n {\n-  struct eh_region *region;\n+  struct eh_region_d *region;\n   tree type_thrown;\n \n   region = VEC_index (eh_region, cfun->eh->region_array, region_number);\n@@ -3609,9 +3614,9 @@ add_action_record (htab_t ar_hash, int filter, int next)\n }\n \n static int\n-collect_one_action_chain (htab_t ar_hash, struct eh_region *region)\n+collect_one_action_chain (htab_t ar_hash, struct eh_region_d *region)\n {\n-  struct eh_region *c;\n+  struct eh_region_d *c;\n   int next;\n \n   /* If we've reached the top of the region chain, then we have\n@@ -3724,7 +3729,7 @@ add_call_site (rtx landing_pad, int action)\n {\n   call_site_record record;\n   \n-  record = GGC_NEW (struct call_site_record);\n+  record = GGC_NEW (struct call_site_record_d);\n   record->landing_pad = landing_pad;\n   record->action = action;\n \n@@ -3758,7 +3763,7 @@ convert_to_eh_region_ranges (void)\n   for (iter = get_insns (); iter ; iter = NEXT_INSN (iter))\n     if (INSN_P (iter))\n       {\n-\tstruct eh_region *region;\n+\tstruct eh_region_d *region;\n \tint this_action;\n \trtx this_landing_pad;\n \n@@ -3802,7 +3807,7 @@ convert_to_eh_region_ranges (void)\n \t   landing pads.  Collect the landing pad for this region.  */\n \tif (this_action >= 0)\n \t  {\n-\t    struct eh_region *o;\n+\t    struct eh_region_d *o;\n \t    for (o = region; ! o->landing_pad ; o = o->outer)\n \t      continue;\n \t    this_landing_pad = o->landing_pad;\n@@ -3925,7 +3930,8 @@ dw2_size_of_call_site_table (void)\n \n   for (i = 0; i < n; ++i)\n     {\n-      struct call_site_record *cs = VEC_index (call_site_record, crtl->eh.call_site_record, i);\n+      struct call_site_record_d *cs =\n+\tVEC_index (call_site_record, crtl->eh.call_site_record, i);\n       size += size_of_uleb128 (cs->action);\n     }\n \n@@ -3941,7 +3947,8 @@ sjlj_size_of_call_site_table (void)\n \n   for (i = 0; i < n; ++i)\n     {\n-      struct call_site_record *cs = VEC_index (call_site_record, crtl->eh.call_site_record, i);\n+      struct call_site_record_d *cs =\n+\tVEC_index (call_site_record, crtl->eh.call_site_record, i);\n       size += size_of_uleb128 (INTVAL (cs->landing_pad));\n       size += size_of_uleb128 (cs->action);\n     }\n@@ -3958,7 +3965,8 @@ dw2_output_call_site_table (void)\n \n   for (i = 0; i < n; ++i)\n     {\n-      struct call_site_record *cs = VEC_index (call_site_record, crtl->eh.call_site_record, i);\n+      struct call_site_record_d *cs =\n+\tVEC_index (call_site_record, crtl->eh.call_site_record, i);\n       char reg_start_lab[32];\n       char reg_end_lab[32];\n       char landing_pad_lab[32];\n@@ -4012,7 +4020,8 @@ sjlj_output_call_site_table (void)\n \n   for (i = 0; i < n; ++i)\n     {\n-      struct call_site_record *cs = VEC_index (call_site_record, crtl->eh.call_site_record, i);\n+      struct call_site_record_d *cs =\n+\tVEC_index (call_site_record, crtl->eh.call_site_record, i);\n \n       dw2_asm_output_data_uleb128 (INTVAL (cs->landing_pad),\n \t\t\t\t   \"region %d landing pad\", i);\n@@ -4330,7 +4339,7 @@ get_eh_throw_stmt_table (struct function *fun)\n void\n dump_eh_tree (FILE * out, struct function *fun)\n {\n-  struct eh_region *i;\n+  struct eh_region_d *i;\n   int depth = 0;\n   static const char *const type_name[] = { \"unknown\", \"cleanup\", \"try\", \"catch\",\n     \t\t\t\t\t   \"allowed_exceptions\", \"must_not_throw\",\n@@ -4380,7 +4389,7 @@ dump_eh_tree (FILE * out, struct function *fun)\n \n \tcase ERT_TRY:\n \t  {\n-\t    struct eh_region *c;\n+\t    struct eh_region_d *c;\n \t    fprintf (out, \" catch regions:\");\n \t    for (c = i->u.eh_try.eh_catch; c; c = c->u.eh_catch.next_catch)\n \t      fprintf (out, \" %i\", c->region_number);\n@@ -4455,7 +4464,7 @@ debug_eh_tree (struct function *fn)\n /* Verify EH region invariants.  */\n \n static bool\n-verify_eh_region (struct eh_region *region)\n+verify_eh_region (struct eh_region_d *region)\n {\n   bool found = false;\n   if (!region)\n@@ -4464,7 +4473,7 @@ verify_eh_region (struct eh_region *region)\n     {\n     case ERT_TRY:\n       {\n-\tstruct eh_region *c, *prev = NULL;\n+\tstruct eh_region_d *c, *prev = NULL;\n \tif (region->u.eh_try.eh_catch->u.eh_catch.prev_catch)\n \t  {\n \t    error (\"Try region %i has wrong rh_catch pointer to %i\",\n@@ -4526,7 +4535,7 @@ verify_eh_region (struct eh_region *region)\n void\n verify_eh_tree (struct function *fun)\n {\n-  struct eh_region *i, *outer = NULL;\n+  struct eh_region_d *i, *outer = NULL;\n   bool err = false;\n   int nvisited = 0;\n   int count = 0;"}, {"sha": "6906601ceb79476b564b29d801ed017b354d7d32", "filename": "gcc/except.h", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -37,17 +37,17 @@ enum eh_region_type\n };\n \n /* Describes one exception region.  */\n-struct GTY(()) eh_region\n+struct GTY(()) eh_region_d\n {\n   /* The immediately surrounding region.  */\n-  struct eh_region *outer;\n+  struct eh_region_d *outer;\n \n   /* The list of immediately contained regions.  */\n-  struct eh_region *inner;\n-  struct eh_region *next_peer;\n+  struct eh_region_d *inner;\n+  struct eh_region_d *next_peer;\n \n   /* List of regions sharing label.  */\n-  struct eh_region *next_region_sharing_label;\n+  struct eh_region_d *next_region_sharing_label;\n \n   /* An identifier for this region.  */\n   int region_number;\n@@ -64,15 +64,15 @@ struct GTY(()) eh_region\n     /* A list of catch blocks, a surrounding try block,\n        and the label for continuing after a catch.  */\n     struct eh_region_u_try {\n-      struct eh_region *eh_catch;\n-      struct eh_region *last_catch;\n+      struct eh_region_d *eh_catch;\n+      struct eh_region_d *last_catch;\n     } GTY ((tag (\"ERT_TRY\"))) eh_try;\n \n     /* The list through the catch handlers, the list of type objects\n        matched, and the list of associated filters.  */\n     struct eh_region_u_catch {\n-      struct eh_region *next_catch;\n-      struct eh_region *prev_catch;\n+      struct eh_region_d *next_catch;\n+      struct eh_region_d *prev_catch;\n       tree type_list;\n       tree filter_list;\n     } GTY ((tag (\"ERT_CATCH\"))) eh_catch;\n@@ -108,7 +108,7 @@ struct GTY(()) eh_region\n   unsigned may_contain_throw : 1;\n };\n \n-typedef struct eh_region *eh_region;\n+typedef struct eh_region_d *eh_region;\n DEF_VEC_P(eh_region);\n DEF_VEC_ALLOC_P(eh_region, gc);\n DEF_VEC_ALLOC_P(eh_region, heap);\n@@ -118,7 +118,7 @@ DEF_VEC_ALLOC_P(eh_region, heap);\n struct GTY(()) eh_status\n {\n   /* The tree of all regions for this function.  */\n-  struct eh_region *region_tree;\n+  struct eh_region_d *region_tree;\n \n   /* The same information as an indexable array.  */\n   VEC(eh_region,gc) *region_array;\n@@ -133,14 +133,14 @@ extern int doing_eh (int);\n \n /* Note that the current EH region (if any) may contain a throw, or a\n    call to a function which itself may contain a throw.  */\n-extern void note_eh_region_may_contain_throw (struct eh_region *);\n+extern void note_eh_region_may_contain_throw (struct eh_region_d *);\n \n /* Invokes CALLBACK for every exception handler label.  Only used by old\n    loop hackery; should not be used by new code.  */\n extern void for_each_eh_label (void (*) (rtx));\n \n /* Invokes CALLBACK for every exception region in the current function.  */\n-extern void for_each_eh_region (void (*) (struct eh_region *));\n+extern void for_each_eh_region (void (*) (struct eh_region_d *));\n \n /* Determine if the given INSN can throw an exception.  */\n extern bool can_throw_internal_1 (int, bool, bool);\n@@ -182,19 +182,19 @@ extern int duplicate_eh_regions (struct function *, duplicate_eh_regions_map,\n extern void sjlj_emit_function_exit_after (rtx);\n extern void default_init_unwind_resume_libfunc (void);\n \n-extern struct eh_region *gen_eh_region_cleanup (struct eh_region *);\n-extern struct eh_region *gen_eh_region_try (struct eh_region *);\n-extern struct eh_region *gen_eh_region_catch (struct eh_region *, tree);\n-extern struct eh_region *gen_eh_region_allowed (struct eh_region *, tree);\n-extern struct eh_region *gen_eh_region_must_not_throw (struct eh_region *);\n-extern int get_eh_region_number (struct eh_region *);\n-extern bool get_eh_region_may_contain_throw (struct eh_region *);\n+extern struct eh_region_d *gen_eh_region_cleanup (struct eh_region_d *);\n+extern struct eh_region_d *gen_eh_region_try (struct eh_region_d *);\n+extern struct eh_region_d *gen_eh_region_catch (struct eh_region_d *, tree);\n+extern struct eh_region_d *gen_eh_region_allowed (struct eh_region_d *, tree);\n+extern struct eh_region_d *gen_eh_region_must_not_throw (struct eh_region_d *);\n+extern int get_eh_region_number (struct eh_region_d *);\n+extern bool get_eh_region_may_contain_throw (struct eh_region_d *);\n extern tree get_eh_region_no_tree_label (int);\n-extern tree get_eh_region_tree_label (struct eh_region *);\n-extern void set_eh_region_tree_label (struct eh_region *, tree);\n+extern tree get_eh_region_tree_label (struct eh_region_d *);\n+extern void set_eh_region_tree_label (struct eh_region_d *, tree);\n \n extern void foreach_reachable_handler (int, bool, bool,\n-\t\t\t\t       void (*) (struct eh_region *, void *),\n+\t\t\t\t       void (*) (struct eh_region_d *, void *),\n \t\t\t\t       void *);\n \n extern void collect_eh_region_array (void);\n@@ -274,5 +274,6 @@ extern void set_eh_throw_stmt_table (struct function *, struct htab *);\n extern void remove_unreachable_regions (sbitmap, sbitmap);\n extern VEC(int,heap) * label_to_region_map (void);\n extern int num_eh_regions (void);\n-extern struct eh_region *redirect_eh_edge_to_label (struct edge_def *, tree, bool, bool, int);\n+extern struct eh_region_d *redirect_eh_edge_to_label (struct edge_def *, tree,\n+\t\t\t\t\t\t      bool, bool, int);\n extern int get_next_region_sharing_label (int);"}, {"sha": "de3a46acc52944a1d7a52a1c3370afd02c32a6d3", "filename": "gcc/function.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -134,7 +134,7 @@ struct GTY(()) expr_status {\n   rtx x_forced_labels;\n };\n \n-typedef struct call_site_record *call_site_record;\n+typedef struct call_site_record_d *call_site_record;\n DEF_VEC_P(call_site_record);\n DEF_VEC_ALLOC_P(call_site_record, gc);\n \n@@ -169,12 +169,12 @@ struct GTY(()) rtl_eh {\n struct gimple_df;\n struct temp_slot;\n typedef struct temp_slot *temp_slot_p;\n-struct call_site_record;\n+struct call_site_record_d;\n \n DEF_VEC_P(temp_slot_p);\n DEF_VEC_ALLOC_P(temp_slot_p,gc);\n-struct ipa_opt_pass;\n-typedef struct ipa_opt_pass *ipa_opt_pass;\n+struct ipa_opt_pass_d;\n+typedef struct ipa_opt_pass_d *ipa_opt_pass;\n \n DEF_VEC_P(ipa_opt_pass);\n DEF_VEC_ALLOC_P(ipa_opt_pass,heap);"}, {"sha": "bfd8c6822baee4ce6a366035fcd492610b14ebf6", "filename": "gcc/gcse.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -343,7 +343,7 @@ struct occr\n    [one could build a mapping table without holes afterwards though].\n    Someday I'll perform the computation and figure it out.  */\n \n-struct hash_table\n+struct hash_table_d\n {\n   /* The table itself.\n      This is an array of `expr_hash_table_size' elements.  */\n@@ -360,10 +360,10 @@ struct hash_table\n };\n \n /* Expression hash table.  */\n-static struct hash_table expr_hash_table;\n+static struct hash_table_d expr_hash_table;\n \n /* Copy propagation hash table.  */\n-static struct hash_table set_hash_table;\n+static struct hash_table_d set_hash_table;\n \n /* This is a list of expressions which are MEMs and will be used by load\n    or store motion.\n@@ -445,30 +445,30 @@ static void *gcalloc (size_t, size_t) ATTRIBUTE_MALLOC;\n static void *gcse_alloc (unsigned long);\n static void alloc_gcse_mem (void);\n static void free_gcse_mem (void);\n-static void hash_scan_insn (rtx, struct hash_table *);\n-static void hash_scan_set (rtx, rtx, struct hash_table *);\n-static void hash_scan_clobber (rtx, rtx, struct hash_table *);\n-static void hash_scan_call (rtx, rtx, struct hash_table *);\n+static void hash_scan_insn (rtx, struct hash_table_d *);\n+static void hash_scan_set (rtx, rtx, struct hash_table_d *);\n+static void hash_scan_clobber (rtx, rtx, struct hash_table_d *);\n+static void hash_scan_call (rtx, rtx, struct hash_table_d *);\n static int want_to_gcse_p (rtx);\n static bool gcse_constant_p (const_rtx);\n static int oprs_unchanged_p (const_rtx, const_rtx, int);\n static int oprs_anticipatable_p (const_rtx, const_rtx);\n static int oprs_available_p (const_rtx, const_rtx);\n static void insert_expr_in_table (rtx, enum machine_mode, rtx, int, int,\n-\t\t\t\t  struct hash_table *);\n-static void insert_set_in_table (rtx, rtx, struct hash_table *);\n+\t\t\t\t  struct hash_table_d *);\n+static void insert_set_in_table (rtx, rtx, struct hash_table_d *);\n static unsigned int hash_expr (const_rtx, enum machine_mode, int *, int);\n static unsigned int hash_set (int, int);\n static int expr_equiv_p (const_rtx, const_rtx);\n static void record_last_reg_set_info (rtx, int);\n static void record_last_mem_set_info (rtx);\n static void record_last_set_info (rtx, const_rtx, void *);\n-static void compute_hash_table (struct hash_table *);\n-static void alloc_hash_table (int, struct hash_table *, int);\n-static void free_hash_table (struct hash_table *);\n-static void compute_hash_table_work (struct hash_table *);\n-static void dump_hash_table (FILE *, const char *, struct hash_table *);\n-static struct expr *lookup_set (unsigned int, struct hash_table *);\n+static void compute_hash_table (struct hash_table_d *);\n+static void alloc_hash_table (int, struct hash_table_d *, int);\n+static void free_hash_table (struct hash_table_d *);\n+static void compute_hash_table_work (struct hash_table_d *);\n+static void dump_hash_table (FILE *, const char *, struct hash_table_d *);\n+static struct expr *lookup_set (unsigned int, struct hash_table_d *);\n static struct expr *next_set (unsigned int, struct expr *);\n static void reset_opr_set_tables (void);\n static int oprs_not_set_p (const_rtx, const_rtx);\n@@ -481,7 +481,7 @@ static void free_cprop_mem (void);\n static void compute_transp (const_rtx, int, sbitmap *, int);\n static void compute_transpout (void);\n static void compute_local_properties (sbitmap *, sbitmap *, sbitmap *,\n-\t\t\t\t      struct hash_table *);\n+\t\t\t\t      struct hash_table_d *);\n static void compute_cprop_data (void);\n static void find_used_regs (rtx *, void *);\n static int try_replace_reg (rtx, rtx, rtx);\n@@ -691,7 +691,7 @@ free_gcse_mem (void)\n \n static void\n compute_local_properties (sbitmap *transp, sbitmap *comp, sbitmap *antloc,\n-\t\t\t  struct hash_table *table)\n+\t\t\t  struct hash_table_d *table)\n {\n   unsigned int i;\n \n@@ -1096,7 +1096,7 @@ expr_equiv_p (const_rtx x, const_rtx y)\n \n static void\n insert_expr_in_table (rtx x, enum machine_mode mode, rtx insn, int antic_p,\n-\t\t      int avail_p, struct hash_table *table)\n+\t\t      int avail_p, struct hash_table_d *table)\n {\n   int found, do_not_record_p;\n   unsigned int hash;\n@@ -1197,7 +1197,7 @@ insert_expr_in_table (rtx x, enum machine_mode mode, rtx insn, int antic_p,\n    basic block.  */\n \n static void\n-insert_set_in_table (rtx x, rtx insn, struct hash_table *table)\n+insert_set_in_table (rtx x, rtx insn, struct hash_table_d *table)\n {\n   int found;\n   unsigned int hash;\n@@ -1293,7 +1293,7 @@ gcse_constant_p (const_rtx x)\n    expression one).  */\n \n static void\n-hash_scan_set (rtx pat, rtx insn, struct hash_table *table)\n+hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n {\n   rtx src = SET_SRC (pat);\n   rtx dest = SET_DEST (pat);\n@@ -1432,14 +1432,14 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table *table)\n \n static void\n hash_scan_clobber (rtx x ATTRIBUTE_UNUSED, rtx insn ATTRIBUTE_UNUSED,\n-\t\t   struct hash_table *table ATTRIBUTE_UNUSED)\n+\t\t   struct hash_table_d *table ATTRIBUTE_UNUSED)\n {\n   /* Currently nothing to do.  */\n }\n \n static void\n hash_scan_call (rtx x ATTRIBUTE_UNUSED, rtx insn ATTRIBUTE_UNUSED,\n-\t\tstruct hash_table *table ATTRIBUTE_UNUSED)\n+\t\tstruct hash_table_d *table ATTRIBUTE_UNUSED)\n {\n   /* Currently nothing to do.  */\n }\n@@ -1456,7 +1456,7 @@ hash_scan_call (rtx x ATTRIBUTE_UNUSED, rtx insn ATTRIBUTE_UNUSED,\n    otherwise it is for the expression hash table.  */\n \n static void\n-hash_scan_insn (rtx insn, struct hash_table *table)\n+hash_scan_insn (rtx insn, struct hash_table_d *table)\n {\n   rtx pat = PATTERN (insn);\n   int i;\n@@ -1486,7 +1486,7 @@ hash_scan_insn (rtx insn, struct hash_table *table)\n }\n \n static void\n-dump_hash_table (FILE *file, const char *name, struct hash_table *table)\n+dump_hash_table (FILE *file, const char *name, struct hash_table_d *table)\n {\n   int i;\n   /* Flattened out table, so it's printed in proper order.  */\n@@ -1647,7 +1647,7 @@ record_last_set_info (rtx dest, const_rtx setter ATTRIBUTE_UNUSED, void *data)\n    TABLE is the table computed.  */\n \n static void\n-compute_hash_table_work (struct hash_table *table)\n+compute_hash_table_work (struct hash_table_d *table)\n {\n   int i;\n \n@@ -1706,7 +1706,7 @@ compute_hash_table_work (struct hash_table *table)\n    be created.  */\n \n static void\n-alloc_hash_table (int n_insns, struct hash_table *table, int set_p)\n+alloc_hash_table (int n_insns, struct hash_table_d *table, int set_p)\n {\n   int n;\n \n@@ -1726,7 +1726,7 @@ alloc_hash_table (int n_insns, struct hash_table *table, int set_p)\n /* Free things allocated by alloc_hash_table.  */\n \n static void\n-free_hash_table (struct hash_table *table)\n+free_hash_table (struct hash_table_d *table)\n {\n   free (table->table);\n }\n@@ -1735,7 +1735,7 @@ free_hash_table (struct hash_table *table)\n    expression hash table.  */\n \n static void\n-compute_hash_table (struct hash_table *table)\n+compute_hash_table (struct hash_table_d *table)\n {\n   /* Initialize count of number of entries in hash table.  */\n   table->n_elems = 0;\n@@ -1750,7 +1750,7 @@ compute_hash_table (struct hash_table *table)\n    table entry, or NULL if not found.  */\n \n static struct expr *\n-lookup_set (unsigned int regno, struct hash_table *table)\n+lookup_set (unsigned int regno, struct hash_table_d *table)\n {\n   unsigned int hash = hash_set (regno, table->size);\n   struct expr *expr;"}, {"sha": "4e6919736cec431f70e2d89ddc9d3dd524de9a94", "filename": "gcc/graphite.c", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -181,7 +181,7 @@ register_bb_in_sese (basic_block entry_bb, basic_block exit_bb, sese region)\n sese\n new_sese (edge entry, edge exit)\n {\n-  sese res = XNEW (struct sese);\n+  sese res = XNEW (struct sese_d);\n \n   SESE_ENTRY (res) = entry;\n   SESE_EXIT (res) = exit;\n@@ -274,7 +274,7 @@ static void\n loop_iv_stack_push_iv (loop_iv_stack stack, tree iv, const char *name)\n {\n   iv_stack_entry *entry = XNEW (iv_stack_entry);\n-  name_tree named_iv = XNEW (struct name_tree);\n+  name_tree named_iv = XNEW (struct name_tree_d);\n \n   named_iv->t = iv;\n   named_iv->name = name;\n@@ -396,7 +396,7 @@ free_loop_iv_stack (loop_iv_stack stack)\n \n /* Structure containing the mapping between the CLooG's induction\n    variable and the type of the old induction variable.  */\n-typedef struct ivtype_map_elt\n+typedef struct ivtype_map_elt_d\n {\n   tree type;\n   const char *cloog_iv;\n@@ -417,7 +417,7 @@ debug_ivtype_elt (ivtype_map_elt elt)\n static int\n debug_ivtype_map_1 (void **slot, void *s ATTRIBUTE_UNUSED)\n {\n-  struct ivtype_map_elt *entry = (struct ivtype_map_elt *) *slot;\n+  struct ivtype_map_elt_d *entry = (struct ivtype_map_elt_d *) *slot;\n   debug_ivtype_elt (entry);\n   return 1;\n }\n@@ -437,7 +437,7 @@ new_ivtype_map_elt (const char *cloog_iv, tree type)\n {\n   ivtype_map_elt res;\n   \n-  res = XNEW (struct ivtype_map_elt);\n+  res = XNEW (struct ivtype_map_elt_d);\n   res->cloog_iv = cloog_iv;\n   res->type = type;\n \n@@ -449,16 +449,16 @@ new_ivtype_map_elt (const char *cloog_iv, tree type)\n static hashval_t\n ivtype_map_elt_info (const void *elt)\n {\n-  return htab_hash_pointer (((const struct ivtype_map_elt *) elt)->cloog_iv);\n+  return htab_hash_pointer (((const struct ivtype_map_elt_d *) elt)->cloog_iv);\n }\n \n /* Compares database elements E1 and E2.  */\n \n static int\n eq_ivtype_map_elts (const void *e1, const void *e2)\n {\n-  const struct ivtype_map_elt *elt1 = (const struct ivtype_map_elt *) e1;\n-  const struct ivtype_map_elt *elt2 = (const struct ivtype_map_elt *) e2;\n+  const struct ivtype_map_elt_d *elt1 = (const struct ivtype_map_elt_d *) e1;\n+  const struct ivtype_map_elt_d *elt2 = (const struct ivtype_map_elt_d *) e2;\n \n   return (elt1->cloog_iv == elt2->cloog_iv);\n }\n@@ -472,7 +472,7 @@ eq_ivtype_map_elts (const void *e1, const void *e2)\n static tree\n gcc_type_for_cloog_iv (const char *cloog_iv, graphite_bb_p gbb)\n {\n-  struct ivtype_map_elt tmp;\n+  struct ivtype_map_elt_d tmp;\n   PTR *slot;\n \n   tmp.cloog_iv = cloog_iv;\n@@ -1339,7 +1339,7 @@ free_graphite_bb (struct graphite_bb *gbb)\n \n /* Structure containing the mapping between the old names and the new\n    names used after block copy in the new loop context.  */\n-typedef struct rename_map_elt\n+typedef struct rename_map_elt_d\n {\n   tree old_name, new_name;\n } *rename_map_elt;\n@@ -1362,7 +1362,7 @@ debug_rename_elt (rename_map_elt elt)\n static int\n debug_rename_map_1 (void **slot, void *s ATTRIBUTE_UNUSED)\n {\n-  struct rename_map_elt *entry = (struct rename_map_elt *) *slot;\n+  struct rename_map_elt_d *entry = (struct rename_map_elt_d *) *slot;\n   debug_rename_elt (entry);\n   return 1;\n }\n@@ -1382,7 +1382,7 @@ new_rename_map_elt (tree old_name, tree new_name)\n {\n   rename_map_elt res;\n   \n-  res = XNEW (struct rename_map_elt);\n+  res = XNEW (struct rename_map_elt_d);\n   res->old_name = old_name;\n   res->new_name = new_name;\n \n@@ -1394,16 +1394,16 @@ new_rename_map_elt (tree old_name, tree new_name)\n static hashval_t\n rename_map_elt_info (const void *elt)\n {\n-  return htab_hash_pointer (((const struct rename_map_elt *) elt)->old_name);\n+  return htab_hash_pointer (((const struct rename_map_elt_d *) elt)->old_name);\n }\n \n /* Compares database elements E1 and E2.  */\n \n static int\n eq_rename_map_elts (const void *e1, const void *e2)\n {\n-  const struct rename_map_elt *elt1 = (const struct rename_map_elt *) e1;\n-  const struct rename_map_elt *elt2 = (const struct rename_map_elt *) e2;\n+  const struct rename_map_elt_d *elt1 = (const struct rename_map_elt_d *) e1;\n+  const struct rename_map_elt_d *elt2 = (const struct rename_map_elt_d *) e2;\n \n   return (elt1->old_name == elt2->old_name);\n }\n@@ -1413,7 +1413,7 @@ eq_rename_map_elts (const void *e1, const void *e2)\n static tree\n get_new_name_from_old_name (htab_t map, tree old_name)\n {\n-  struct rename_map_elt tmp;\n+  struct rename_map_elt_d tmp;\n   PTR *slot;\n \n   tmp.old_name = old_name;\n@@ -2419,7 +2419,7 @@ scop_record_loop (scop_p scop, loop_p loop)\n   if (!induction_var)\n     return false;\n \n-  oldiv = XNEW (struct name_tree);\n+  oldiv = XNEW (struct name_tree_d);\n   oldiv->t = induction_var;\n   oldiv->name = get_name (SSA_NAME_VAR (oldiv->t));\n   oldiv->loop = loop;\n@@ -2664,7 +2664,7 @@ param_index (tree var, scop_p scop)\n \n   gcc_assert (SCOP_ADD_PARAMS (scop));\n \n-  nvar = XNEW (struct name_tree);\n+  nvar = XNEW (struct name_tree_d);\n   nvar->t = var;\n   nvar->name = NULL;\n   VEC_safe_push (name_tree, heap, SCOP_PARAMS (scop), nvar);\n@@ -4428,7 +4428,7 @@ build_iv_mapping (loop_iv_stack ivstack, htab_t map, gbb_p gbb, scop_p scop)\n \n   for (i = 0; VEC_iterate (name_tree, SCOP_OLDIVS (scop), i, iv); i++)\n     {\n-      struct rename_map_elt tmp;\n+      struct rename_map_elt_d tmp;\n \n       if (!flow_bb_inside_loop_p (iv->loop, GBB_BB (gbb)))\n \tcontinue;\n@@ -4450,7 +4450,7 @@ build_iv_mapping (loop_iv_stack ivstack, htab_t map, gbb_p gbb, scop_p scop)\n static void\n register_old_and_new_names (htab_t map, tree old_name, tree new_name)\n {\n-  struct rename_map_elt tmp;\n+  struct rename_map_elt_d tmp;\n   PTR *slot;\n \n   tmp.old_name = old_name;\n@@ -4549,7 +4549,7 @@ copy_bb_and_scalar_dependences (basic_block bb, scop_p scop,\n static int\n add_loop_exit_phis (void **slot, void *s)\n {\n-  struct rename_map_elt *entry = (struct rename_map_elt *) *slot;\n+  struct rename_map_elt_d *entry = (struct rename_map_elt_d *) *slot;\n   tree new_name = entry->new_name;\n   basic_block bb = (basic_block) s;\n   gimple phi = create_phi_node (new_name, bb);\n@@ -4606,7 +4606,7 @@ default_liveout_before_guard (htab_t liveout_before_guard, tree old_name)\n static int\n add_guard_exit_phis (void **slot, void *s)\n {\n-  struct rename_map_elt *entry = (struct rename_map_elt *) *slot;\n+  struct rename_map_elt_d *entry = (struct rename_map_elt_d *) *slot;\n   struct igp *i = (struct igp *) s;\n   basic_block bb = i->bb;\n   edge true_edge = i->true_edge;\n@@ -4661,11 +4661,11 @@ insert_guard_phis (scop_p scop, basic_block bb, edge true_edge,\n static int\n copy_renames (void **slot, void *s)\n {\n-  struct rename_map_elt *entry = (struct rename_map_elt *) *slot;\n+  struct rename_map_elt_d *entry = (struct rename_map_elt_d *) *slot;\n   htab_t res = (htab_t) s;\n   tree old_name = entry->old_name;\n   tree new_name = entry->new_name;\n-  struct rename_map_elt tmp;\n+  struct rename_map_elt_d tmp;\n   PTR *x;\n \n   tmp.old_name = old_name;\n@@ -5009,7 +5009,8 @@ remove_sese_region (sese region)\n   VEC_free (basic_block, heap, bbs);\n }\n \n-typedef struct ifsese {\n+typedef struct ifsese_d\n+{\n   sese region;\n   sese true_region;\n   sese false_region;\n@@ -5083,10 +5084,10 @@ create_if_region_on_edge (edge entry, tree condition)\n {\n   edge e;\n   edge_iterator ei;\n-  sese sese_region = GGC_NEW (struct sese);\n-  sese true_region = GGC_NEW (struct sese);\n-  sese false_region = GGC_NEW (struct sese);\n-  ifsese if_region = GGC_NEW (struct ifsese);\n+  sese sese_region = GGC_NEW (struct sese_d);\n+  sese true_region = GGC_NEW (struct sese_d);\n+  sese false_region = GGC_NEW (struct sese_d);\n+  ifsese if_region = GGC_NEW (struct ifsese_d);\n   edge exit = create_empty_if_region_on_edge (entry, condition);\n \n   if_region->region = sese_region;\n@@ -5369,7 +5370,7 @@ compute_cloog_iv_types_1 (graphite_bb_p gbb,\n   for (t = user_stmt->substitutions; t; t = t->next, index++)\n     {\n       PTR *slot;\n-      struct ivtype_map_elt tmp;\n+      struct ivtype_map_elt_d tmp;\n       struct clast_expr *expr = (struct clast_expr *) \n \t((struct clast_assignment *)t)->RHS;\n "}, {"sha": "e663c2d0fe54f40cd07f5d7ff90fbba9368d4826", "filename": "gcc/graphite.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fgraphite.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fgraphite.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.h?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -265,7 +265,7 @@ struct loop_to_cloog_loop_str\n   CloogLoop *cloog_loop;\n };\n \n-typedef struct name_tree\n+typedef struct name_tree_d\n {\n   tree t;\n   const char *name;\n@@ -277,7 +277,7 @@ DEF_VEC_ALLOC_P (name_tree, heap);\n \n /* A Single Entry, Single Exit region is a part of the CFG delimited\n    by two edges.  */\n-typedef struct sese\n+typedef struct sese_d\n {\n   /* Single ENTRY and single EXIT from the SESE region.  */\n   edge entry, exit;"}, {"sha": "2b63806172b524116c4f37caad272c0f143c633e", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -1,5 +1,5 @@\n /* Interprocedural constant propagation\n-   Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n    Contributed by Razya Ladelsky <RAZYA@il.ibm.com>\n    \n This file is part of GCC.\n@@ -1201,7 +1201,7 @@ cgraph_gate_cp (void)\n   return flag_ipa_cp;\n }\n \n-struct ipa_opt_pass pass_ipa_cp = \n+struct ipa_opt_pass_d pass_ipa_cp =\n {\n  {\n   IPA_PASS,"}, {"sha": "18eed571aaedab17461a0c0555ddf32ff5802b7f", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -1773,7 +1773,7 @@ inline_transform (struct cgraph_node *node)\n   return todo | execute_fixup_cfg ();\n }\n \n-struct ipa_opt_pass pass_ipa_inline = \n+struct ipa_opt_pass_d pass_ipa_inline =\n {\n  {\n   IPA_PASS,"}, {"sha": "35d27a33696c9d70d23f1db2f3b56a6f9cf94de9", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -1,5 +1,5 @@\n /* Callgraph based analysis of static variables.\n-   Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2007, 2008, 2009 Free Software Foundation, Inc.\n    Contributed by Kenneth Zadeck <zadeck@naturalbridge.com>\n \n This file is part of GCC.\n@@ -876,7 +876,7 @@ gate_pure_const (void)\n \t  && !(errorcount || sorrycount));\n }\n \n-struct ipa_opt_pass pass_ipa_pure_const =\n+struct ipa_opt_pass_d pass_ipa_pure_const =\n {\n  {\n   IPA_PASS,"}, {"sha": "db63d02554fc7c0f41ada776ce3c540ee33afb06", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -1,5 +1,5 @@\n /* Callgraph based analysis of static variables.\n-   Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2007, 2008, 2009 Free Software Foundation, Inc.\n    Contributed by Kenneth Zadeck <zadeck@naturalbridge.com>\n \n This file is part of GCC.\n@@ -1250,7 +1250,7 @@ gate_reference (void)\n \t  && !(errorcount || sorrycount));\n }\n \n-struct ipa_opt_pass pass_ipa_reference =\n+struct ipa_opt_pass_d pass_ipa_reference =\n {\n  {\n   IPA_PASS,"}, {"sha": "e307ba290576e78a93bd0dab5dc42d586570a680", "filename": "gcc/omega.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fomega.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fomega.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomega.c?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -1305,7 +1305,7 @@ verify_omega_pb (omega_pb pb)\n   enum omega_result result;\n   int e;\n   bool any_color = false;\n-  omega_pb tmp_problem = XNEW (struct omega_pb);\n+  omega_pb tmp_problem = XNEW (struct omega_pb_d);\n \n   omega_copy_problem (tmp_problem, pb);\n   tmp_problem->safe_vars = 0;\n@@ -2286,7 +2286,7 @@ omega_eliminate_redundant (omega_pb pb, bool expensive)\n   if (!expensive)\n     goto eliminate_redundant_done;\n \n-  tmp_problem = XNEW (struct omega_pb);\n+  tmp_problem = XNEW (struct omega_pb_d);\n   conservative++;\n \n   for (e = pb->num_geqs - 1; e >= 0; e--)\n@@ -2648,7 +2648,7 @@ omega_eliminate_red (omega_pb pb, bool eliminate_all)\n     return;\n \n   conservative++;\n-  tmp_problem = XNEW (struct omega_pb);\n+  tmp_problem = XNEW (struct omega_pb_d);\n \n   for (e = pb->num_geqs - 1; e >= 0; e--)\n     if (pb->geqs[e].color == omega_red)\n@@ -3491,7 +3491,7 @@ parallel_splinter (omega_pb pb, int e, int diff,\n       omega_print_problem (dump_file, pb);\n     }\n \n-  tmp_problem = XNEW (struct omega_pb);\n+  tmp_problem = XNEW (struct omega_pb_d);\n   omega_copy_eqn (&pb->eqs[0], &pb->geqs[e], pb->num_vars);\n   pb->num_eqs = 1;\n \n@@ -5499,7 +5499,7 @@ omega_alloc_problem (int nvars, int nprot)\n   omega_initialize ();\n \n   /* Allocate and initialize PB.  */\n-  pb = XCNEW (struct omega_pb);\n+  pb = XCNEW (struct omega_pb_d);\n   pb->var = XCNEWVEC (int, OMEGA_MAX_VARS + 2);\n   pb->forwarding_address = XCNEWVEC (int, OMEGA_MAX_VARS + 2);\n   pb->geqs = omega_alloc_eqns (0, OMEGA_MAX_GEQS);"}, {"sha": "02c17987dee1134583987316709c29d7bebc58b9", "filename": "gcc/omega.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fomega.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fomega.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomega.h?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -5,7 +5,7 @@\n    This code has no license restrictions, and is considered public\n    domain.\n \n-   Changes copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Changes copyright (C) 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n    Contributed by Sebastian Pop <sebastian.pop@inria.fr>\n \n This file is part of GCC.\n@@ -58,7 +58,7 @@ enum omega_eqn_color {\n };\n \n /* Structure for equations.  */\n-typedef struct eqn\n+typedef struct eqn_d\n {\n   int key;\n   int touched;\n@@ -72,7 +72,7 @@ typedef struct eqn\n   int *coef;\n } *eqn;\n \n-typedef struct omega_pb\n+typedef struct omega_pb_d\n {\n   /* The number of variables in the system of equations.  */\n   int num_vars;\n@@ -215,7 +215,7 @@ static inline eqn\n omega_alloc_eqns (int s, int n)\n {\n   int i;\n-  eqn res = (eqn) (xcalloc (n, sizeof (struct eqn)));\n+  eqn res = (eqn) (xcalloc (n, sizeof (struct eqn_d)));\n \n   for (i = n - 1; i >= 0; i--)\n     {"}, {"sha": "2b9da2cdb29f50ccdfaf4c13fffa7e6ed2206ca9", "filename": "gcc/optabs.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -55,25 +55,25 @@ along with GCC; see the file COPYING3.  If not see\n    See expr.h for documentation of these optabs.  */\n \n #if GCC_VERSION >= 4000\n-__extension__ struct optab optab_table[OTI_MAX]\n+__extension__ struct optab_d optab_table[OTI_MAX]\n   = { [0 ... OTI_MAX - 1].handlers[0 ... NUM_MACHINE_MODES - 1].insn_code\n       = CODE_FOR_nothing };\n #else\n /* init_insn_codes will do runtime initialization otherwise.  */\n-struct optab optab_table[OTI_MAX];\n+struct optab_d optab_table[OTI_MAX];\n #endif\n \n rtx libfunc_table[LTI_MAX];\n \n /* Tables of patterns for converting one mode to another.  */\n #if GCC_VERSION >= 4000\n-__extension__ struct convert_optab convert_optab_table[COI_MAX]\n+__extension__ struct convert_optab_d convert_optab_table[COI_MAX]\n   = { [0 ... COI_MAX - 1].handlers[0 ... NUM_MACHINE_MODES - 1]\n \t[0 ... NUM_MACHINE_MODES - 1].insn_code\n       = CODE_FOR_nothing };\n #else\n /* init_convert_optab will do runtime initialization otherwise.  */\n-struct convert_optab convert_optab_table[COI_MAX];\n+struct convert_optab_d convert_optab_table[COI_MAX];\n #endif\n \n /* Contains the optab used for each rtx code.  */\n@@ -2248,7 +2248,7 @@ sign_expand_binop (enum machine_mode mode, optab uoptab, optab soptab,\n {\n   rtx temp;\n   optab direct_optab = unsignedp ? uoptab : soptab;\n-  struct optab wide_soptab;\n+  struct optab_d wide_soptab;\n \n   /* Do it without widening, if possible.  */\n   temp = expand_binop (mode, direct_optab, op0, op1, target,"}, {"sha": "096feda7df2b5df4ec32fd0294d7b9a5f7eeb5cb", "filename": "gcc/optabs.h", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for code generation pass of GNU compiler.\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -43,29 +43,30 @@ struct optab_handlers\n   enum insn_code insn_code;\n };\n \n-struct optab\n+struct optab_d\n {\n   enum rtx_code code;\n   const char *libcall_basename;\n   char libcall_suffix;\n-  void (*libcall_gen)(struct optab *, const char *name, char suffix, enum machine_mode);\n+  void (*libcall_gen)(struct optab_d *, const char *name, char suffix,\n+\t\t      enum machine_mode);\n   struct optab_handlers handlers[NUM_MACHINE_MODES];\n };\n-typedef struct optab * optab;\n+typedef struct optab_d * optab;\n \n /* A convert_optab is for some sort of conversion operation between\n    modes.  The first array index is the destination mode, the second\n    is the source mode.  */\n-struct convert_optab\n+struct convert_optab_d\n {\n   enum rtx_code code;\n   const char *libcall_basename;\n-  void (*libcall_gen)(struct convert_optab *, const char *name,\n+  void (*libcall_gen)(struct convert_optab_d *, const char *name,\n \t\t      enum machine_mode,\n \t\t      enum machine_mode);\n   struct optab_handlers handlers[NUM_MACHINE_MODES][NUM_MACHINE_MODES];\n };\n-typedef struct convert_optab *convert_optab;\n+typedef struct convert_optab_d *convert_optab;\n \n /* Given an enum insn_code, access the function to construct\n    the body of that kind of insn.  */\n@@ -369,7 +370,7 @@ enum optab_index\n   OTI_MAX\n };\n \n-extern struct optab optab_table[OTI_MAX];\n+extern struct optab_d optab_table[OTI_MAX];\n \n #define ssadd_optab (&optab_table[OTI_ssadd])\n #define usadd_optab (&optab_table[OTI_usadd])\n@@ -571,7 +572,7 @@ enum convert_optab_index\n   COI_MAX\n };\n \n-extern struct convert_optab convert_optab_table[COI_MAX];\n+extern struct convert_optab_d convert_optab_table[COI_MAX];\n \n #define sext_optab (&convert_optab_table[COI_sext])\n #define zext_optab (&convert_optab_table[COI_zext])"}, {"sha": "a050df3516ee2adec47717dd3548d093caec34d7", "filename": "gcc/passes.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -1152,14 +1152,14 @@ update_properties_after_pass (void *data)\n static void\n add_ipa_transform_pass (void *data)\n {\n-  struct ipa_opt_pass *ipa_pass = (struct ipa_opt_pass *) data;\n+  struct ipa_opt_pass_d *ipa_pass = (struct ipa_opt_pass_d *) data;\n   VEC_safe_push (ipa_opt_pass, heap, cfun->ipa_transforms_to_apply, ipa_pass);\n }\n \n /* Execute summary generation for all of the passes in IPA_PASS.  */\n \n static void\n-execute_ipa_summary_passes (struct ipa_opt_pass *ipa_pass)\n+execute_ipa_summary_passes (struct ipa_opt_pass_d *ipa_pass)\n {\n   while (ipa_pass)\n     {\n@@ -1173,15 +1173,15 @@ execute_ipa_summary_passes (struct ipa_opt_pass *ipa_pass)\n \t  ipa_pass->generate_summary ();\n \t  pass_fini_dump_file (pass);\n \t}\n-      ipa_pass = (struct ipa_opt_pass *)ipa_pass->pass.next;\n+      ipa_pass = (struct ipa_opt_pass_d *)ipa_pass->pass.next;\n     }\n }\n \n /* Execute IPA_PASS function transform on NODE.  */\n \n static void\n execute_one_ipa_transform_pass (struct cgraph_node *node,\n-\t\t\t\tstruct ipa_opt_pass *ipa_pass)\n+\t\t\t\tstruct ipa_opt_pass_d *ipa_pass)\n {\n   struct opt_pass *pass = &ipa_pass->pass;\n   unsigned int todo_after = 0;\n@@ -1353,7 +1353,7 @@ execute_ipa_pass_list (struct opt_pass *pass)\n \t    {\n \t      if (!quiet_flag && !cfun)\n \t\tfprintf (stderr, \" <summary generate>\");\n-\t      execute_ipa_summary_passes ((struct ipa_opt_pass *) pass);\n+\t      execute_ipa_summary_passes ((struct ipa_opt_pass_d *) pass);\n \t    }\n \t  summaries_generated = true;\n \t}"}, {"sha": "b82f4721256d9e7b7de371554eafc13f7fc9f1e4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -1,3 +1,7 @@\n+2009-05-15  Ian Lance Taylor  <iant@google.com>\n+\n+\t* gcc.dg/Wcxx-compat-10.c: New testcase.\n+\n 2009-05-15  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR 16302"}, {"sha": "0f1d037bfeac7f868dd88e2e780ecab8351ba127", "filename": "gcc/testsuite/gcc.dg/Wcxx-compat-10.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-10.c?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -0,0 +1,73 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wc++-compat\" } */\n+\n+struct s1 { int f; };\n+typedef int s2;\n+void\n+f1 ()\n+{\n+  typedef int s1;\n+  struct s2 { int f; };\n+}\n+\n+struct s3 { int f; };\n+typedef struct s3 s3;\n+\n+typedef struct s4 s4;\n+struct s4 { int f; };\n+\n+struct s5 { int f; };\t/* { dg-message \"note: originally defined here\" } */\n+typedef int s5;\t\t/* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+\n+typedef int s6;\t\t/* { dg-message \"note: originally defined here\" } */\n+struct s6 { int f; };\t/* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+\n+void\n+f2 ()\n+{\n+  struct s7 { int f; };\t/* { dg-message \"note: originally defined here\" } */\n+  typedef int s7;\t/* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+\n+  typedef int s8;\t/* { dg-message \"note: originally defined here\" } */\n+  struct s8 { int f; };\t/* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+\n+  struct s9 { int f; };\n+  { typedef int s9; }\n+\n+  typedef int s10;\n+  { struct s10 { int f; }; }\n+}\n+\n+enum e1 { A };\n+typedef int e2;\n+void\n+f3 ()\n+{\n+  typedef int e1;\n+  enum e2 { B };\n+}\n+\n+enum e3 { C };\n+typedef enum e3 e3;\n+\n+enum e5 { E };\t\t/* { dg-message \"note: originally defined here\" } */\n+typedef int e5;\t\t/* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+\n+typedef int e6;\t\t/* { dg-message \"note: originally defined here\" } */\n+enum e6 { F };\t\t/* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+\n+void\n+f4 ()\n+{\n+  enum e7 { G };\t/* { dg-message \"note: originally defined here\" } */\n+  typedef int e7;\t/* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+\n+  typedef int e8;\t/* { dg-message \"note: originally defined here\" } */\n+  enum e8 { H };\t/* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+\n+  enum e9 { I };\n+  { typedef int e9; }\n+\n+  typedef int e10;\n+  { enum e10 { J }; }\n+}"}, {"sha": "68d6f5b1c1334802b84b7f019bb4832691f2cdc8", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -917,7 +917,7 @@ static struct label_record\n \n /* Callback for for_each_eh_region.  Helper for cleanup_dead_labels.  */\n static void\n-update_eh_label (struct eh_region *region)\n+update_eh_label (struct eh_region_d *region)\n {\n   tree old_label = get_eh_region_tree_label (region);\n   if (old_label)"}, {"sha": "6a19bd52930ad3559c6bcf6a82785ea171e67805", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -87,7 +87,7 @@ struct_ptr_hash (const void *a)\n    of space by only allocating memory for those that can throw.  */\n \n static void\n-record_stmt_eh_region (struct eh_region *region, gimple t)\n+record_stmt_eh_region (struct eh_region_d *region, gimple t)\n {\n   if (!region)\n     return;\n@@ -371,7 +371,7 @@ struct leh_state\n   /* What's \"current\" while constructing the eh region tree.  These\n      correspond to variables of the same name in cfun->eh, which we\n      don't have easy access to.  */\n-  struct eh_region *cur_region;\n+  struct eh_region_d *cur_region;\n \n   /* Processing of TRY_FINALLY requires a bit more state.  This is\n      split out into a separate structure so that we don't have to\n@@ -395,7 +395,7 @@ struct leh_tf_state\n   struct leh_state *outer;\n \n   /* The exception region created for it.  */\n-  struct eh_region *region;\n+  struct eh_region_d *region;\n \n   /* The goto queue.  */\n   struct goto_queue_node *goto_queue;\n@@ -1646,7 +1646,7 @@ lower_try_finally (struct leh_state *state, gimple tp)\n static gimple_seq\n lower_catch (struct leh_state *state, gimple tp)\n {\n-  struct eh_region *try_region;\n+  struct eh_region_d *try_region;\n   struct leh_state this_state;\n   gimple_stmt_iterator gsi;\n   tree out_label;\n@@ -1665,7 +1665,7 @@ lower_catch (struct leh_state *state, gimple tp)\n   out_label = NULL;\n   for (gsi = gsi_start (gimple_try_cleanup (tp)); !gsi_end_p (gsi); )\n     {\n-      struct eh_region *catch_region;\n+      struct eh_region_d *catch_region;\n       tree eh_label;\n       gimple x, gcatch;\n \n@@ -1707,7 +1707,7 @@ static gimple_seq\n lower_eh_filter (struct leh_state *state, gimple tp)\n {\n   struct leh_state this_state;\n-  struct eh_region *this_region;\n+  struct eh_region_d *this_region;\n   gimple inner;\n   tree eh_label;\n \n@@ -1744,7 +1744,7 @@ static gimple_seq\n lower_cleanup (struct leh_state *state, gimple tp)\n {\n   struct leh_state this_state;\n-  struct eh_region *this_region;\n+  struct eh_region_d *this_region;\n   struct leh_tf_state fake_tf;\n   gimple_seq result;\n \n@@ -1947,7 +1947,7 @@ struct gimple_opt_pass pass_lower_eh =\n /* Construct EH edges for STMT.  */\n \n static void\n-make_eh_edge (struct eh_region *region, void *data)\n+make_eh_edge (struct eh_region_d *region, void *data)\n {\n   gimple stmt;\n   tree lab;\n@@ -2026,7 +2026,7 @@ redirect_eh_edge (edge e, basic_block new_bb)\n   bool is_resx;\n   bool inlinable = false;\n   tree label = gimple_block_label (new_bb);\n-  struct eh_region *r;\n+  struct eh_region_d *r;\n \n   if (gimple_code (stmt) == GIMPLE_RESX)\n     {\n@@ -2066,7 +2066,7 @@ static bool mark_eh_edge_found_error;\n    field, output error if something goes wrong.  */\n \n static void\n-mark_eh_edge (struct eh_region *region, void *data)\n+mark_eh_edge (struct eh_region_d *region, void *data)\n {\n   gimple stmt;\n   tree lab;\n@@ -2958,7 +2958,7 @@ struct update_info\n    operands from DATA->bb_to_remove.  */\n \n static void\n-make_eh_edge_and_update_phi (struct eh_region *region, void *data)\n+make_eh_edge_and_update_phi (struct eh_region_d *region, void *data)\n {\n   struct update_info *info = (struct update_info *) data;\n   edge e, e2;"}, {"sha": "a123341920e54927f3a601c3be38526c596bc736", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -164,7 +164,7 @@ struct cgraph_node_set_def;\n \n /* Description of IPA pass with generate summary, write, execute, read and\n    transform stages.  */\n-struct ipa_opt_pass\n+struct ipa_opt_pass_d\n {\n   struct opt_pass pass;\n \n@@ -401,10 +401,10 @@ extern struct gimple_opt_pass pass_local_pure_const;\n extern struct gimple_opt_pass pass_tracer;\n \n /* IPA Passes */\n-extern struct ipa_opt_pass pass_ipa_inline;\n-extern struct ipa_opt_pass pass_ipa_cp;\n-extern struct ipa_opt_pass pass_ipa_reference;\n-extern struct ipa_opt_pass pass_ipa_pure_const;\n+extern struct ipa_opt_pass_d pass_ipa_inline;\n+extern struct ipa_opt_pass_d pass_ipa_cp;\n+extern struct ipa_opt_pass_d pass_ipa_reference;\n+extern struct ipa_opt_pass_d pass_ipa_pure_const;\n \n extern struct simple_ipa_opt_pass pass_ipa_matrix_reorg;\n extern struct simple_ipa_opt_pass pass_ipa_early_inline;"}, {"sha": "7ebd6c082ad11070dcfccd145b01251e72807103", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -1,5 +1,5 @@\n /* Predictive commoning.\n-   Copyright (C) 2005, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2007, 2008, 2009 Free Software Foundation, Inc.\n    \n This file is part of GCC.\n    \n@@ -210,7 +210,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Data references (or phi nodes that carry data reference values across\n    loop iterations).  */\n \n-typedef struct dref\n+typedef struct dref_d\n {\n   /* The reference itself.  */\n   struct data_reference *ref;\n@@ -775,7 +775,7 @@ split_data_refs_to_components (struct loop *loop,\n \t  comps[ca] = comp;\n \t}\n \n-      dataref = XCNEW (struct dref);\n+      dataref = XCNEW (struct dref_d);\n       dataref->ref = dr;\n       dataref->stmt = DR_STMT (dr);\n       dataref->offset = double_int_zero;\n@@ -1126,7 +1126,7 @@ find_looparound_phi (struct loop *loop, dref ref, dref root)\n static void\n insert_looparound_copy (chain_p chain, dref ref, gimple phi)\n {\n-  dref nw = XCNEW (struct dref), aref;\n+  dref nw = XCNEW (struct dref_d), aref;\n   unsigned i;\n \n   nw->stmt = phi;\n@@ -2339,7 +2339,7 @@ combine_chains (chain_p ch1, chain_p ch2)\n   for (i = 0; (VEC_iterate (dref, ch1->refs, i, r1)\n \t       && VEC_iterate (dref, ch2->refs, i, r2)); i++)\n     {\n-      nw = XCNEW (struct dref);\n+      nw = XCNEW (struct dref_d);\n       nw->stmt = stmt_combining_refs (r1, r2);\n       nw->distance = r1->distance;\n "}, {"sha": "f604c48d1d6eaedf1a5bbb0a6e04164761cb15b5", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -1,3 +1,8 @@\n+2009-05-15  Ian Lance Taylor  <iant@google.com>\n+\n+\t* include/cpplib.h (enum cpp_builtin_type): Rename from enum\n+\tbuiltin_type.  Change all uses.\n+\n 2009-05-14  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR cpp/36674"}, {"sha": "effe9a04b1f0a83f7f07d1d0f612e503b062e0c6", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -578,7 +578,7 @@ enum node_type\n \n /* Different flavors of builtin macro.  _Pragma is an operator, but we\n    handle it with the builtin code for efficiency reasons.  */\n-enum builtin_type\n+enum cpp_builtin_type\n {\n   BT_SPECLINE = 0,\t\t/* `__LINE__' */\n   BT_DATE,\t\t\t/* `__DATE__' */\n@@ -624,7 +624,7 @@ union GTY(()) _cpp_hashnode_value {\n   /* Answers to an assertion.  */\n   struct answer * GTY ((tag (\"NTV_ANSWER\"))) answers;\n   /* Code for a builtin macro.  */\n-  enum builtin_type GTY ((tag (\"NTV_BUILTIN\"))) builtin;\n+  enum cpp_builtin_type GTY ((tag (\"NTV_BUILTIN\"))) builtin;\n   /* Macro argument index.  */\n   unsigned short GTY ((tag (\"NTV_ARGUMENT\"))) arg_index;\n };"}, {"sha": "0f6f49f41da6e1b376e1904165ee01767047c4c1", "filename": "libcpp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5487a214d591ab394310fa2f8840c42b745ee7/libcpp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5487a214d591ab394310fa2f8840c42b745ee7/libcpp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finit.c?ref=7e5487a214d591ab394310fa2f8840c42b745ee7", "patch": "@@ -419,7 +419,7 @@ cpp_init_special_builtins (cpp_reader *pfile)\n       if (b->always_warn_if_redefined\n           || CPP_OPTION (pfile, warn_builtin_macro_redefined))\n \thp->flags |= NODE_WARN;\n-      hp->value.builtin = (enum builtin_type) b->value;\n+      hp->value.builtin = (enum cpp_builtin_type) b->value;\n     }\n }\n "}]}