{"sha": "5b69c5e55df08ca91989f746ed2b459e0658d6dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI2OWM1ZTU1ZGYwOGNhOTE5ODlmNzQ2ZWQyYjQ1OWUwNjU4ZDZkZA==", "commit": {"author": {"name": "Kugan Vivekanandarajah", "email": "kuganv@linaro.org", "date": "2016-10-10T23:48:47Z"}, "committer": {"name": "Kugan Vivekanandarajah", "email": "kugan@gcc.gnu.org", "date": "2016-10-10T23:48:47Z"}, "message": "Infer and push new value ranges for x in y < x.\n\ngcc/ChangeLog:\n\n2016-10-11  Kugan Vivekanandarajah  <kuganv@linaro.org>\n\n\t* tree-vrp.c (evrp_dom_walker::try_add_new_range): New.\n\t(evrp_dom_walker::before_dom_children): Infer and push new value\n\tranges for x in y < x.\n\nFrom-SVN: r240957", "tree": {"sha": "d5d23315a1712cf33115acd45ca496c9174b2e31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5d23315a1712cf33115acd45ca496c9174b2e31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b69c5e55df08ca91989f746ed2b459e0658d6dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b69c5e55df08ca91989f746ed2b459e0658d6dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b69c5e55df08ca91989f746ed2b459e0658d6dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b69c5e55df08ca91989f746ed2b459e0658d6dd/comments", "author": null, "committer": null, "parents": [{"sha": "65180edc5661b1324a53ac9ebbe03f44cda524e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65180edc5661b1324a53ac9ebbe03f44cda524e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65180edc5661b1324a53ac9ebbe03f44cda524e4"}], "stats": {"total": 59, "additions": 45, "deletions": 14}, "files": [{"sha": "8e1ee8acfea645de78bd50c612582b054f2a4b4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b69c5e55df08ca91989f746ed2b459e0658d6dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b69c5e55df08ca91989f746ed2b459e0658d6dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b69c5e55df08ca91989f746ed2b459e0658d6dd", "patch": "@@ -1,3 +1,9 @@\n+2016-10-11  Kugan Vivekanandarajah  <kuganv@linaro.org>\n+\n+\t* tree-vrp.c (evrp_dom_walker::try_add_new_range): New.\n+\t(evrp_dom_walker::before_dom_children): Infer and push new value\n+\tranges for x in y < x.\n+\n 2016-10-10  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR target/77586"}, {"sha": "8a129c6d704fbfd8fbcb17a834b2ff4133a7b5fb", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b69c5e55df08ca91989f746ed2b459e0658d6dd/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b69c5e55df08ca91989f746ed2b459e0658d6dd/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=5b69c5e55df08ca91989f746ed2b459e0658d6dd", "patch": "@@ -10650,27 +10650,50 @@ class evrp_dom_walker : public dom_walker\n   virtual void after_dom_children (basic_block);\n   void push_value_range (const_tree var, value_range *vr);\n   value_range *pop_value_range (const_tree var);\n+  void try_add_new_range (tree op, tree_code code, tree limit);\n \n   /* Cond_stack holds the old VR.  */\n   auto_vec<std::pair <const_tree, value_range*> > stack;\n   bitmap need_eh_cleanup;\n   vec<gimple *> stmts_to_fixup;\n };\n \n+\n+/*  Add new range to OP such that (OP CODE LIMIT) is true.  */\n+\n+void\n+evrp_dom_walker::try_add_new_range (tree op, tree_code code, tree limit)\n+{\n+  value_range vr = VR_INITIALIZER;\n+  value_range *old_vr = get_value_range (op);\n+\n+  /* Discover VR when condition is true.  */\n+  extract_range_for_var_from_comparison_expr (op, code, op,\n+\t\t\t\t\t      limit, &vr);\n+  if (old_vr->type == VR_RANGE || old_vr->type == VR_ANTI_RANGE)\n+    vrp_intersect_ranges (&vr, old_vr);\n+  /* If we found any usable VR, set the VR to ssa_name and create a\n+     PUSH old value in the stack with the old VR.  */\n+  if (vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE)\n+    {\n+      value_range *new_vr = vrp_value_range_pool.allocate ();\n+      *new_vr = vr;\n+      push_value_range (op, new_vr);\n+    }\n+}\n+\n /* See if there is any new scope is entered with new VR and set that VR to\n    ssa_name before visiting the statements in the scope.  */\n \n edge\n evrp_dom_walker::before_dom_children (basic_block bb)\n {\n-  value_range *new_vr = NULL;\n   tree op0 = NULL_TREE;\n \n   push_value_range (NULL_TREE, NULL);\n   if (single_pred_p (bb))\n     {\n       edge e = single_pred_edge (bb);\n-      value_range vr = VR_INITIALIZER;\n       gimple *stmt = last_stmt (e->src);\n       if (stmt\n \t  && gimple_code (stmt) == GIMPLE_COND\n@@ -10683,7 +10706,6 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t     here.  */\n \t  tree op1 = gimple_cond_rhs (stmt);\n \t  tree_code code = gimple_cond_code (stmt);\n-\t  value_range *old_vr = get_value_range (op0);\n \n \t  if (TREE_OVERFLOW_P (op1))\n \t    op1 = drop_tree_overflow (op1);\n@@ -10692,18 +10714,21 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t  if (e->flags & EDGE_FALSE_VALUE)\n \t    code = invert_tree_comparison (gimple_cond_code (stmt),\n \t\t\t\t\t   HONOR_NANS (op0));\n-\t  /* Discover VR when condition is true.  */\n-\t  extract_range_for_var_from_comparison_expr (op0, code, op0, op1, &vr);\n-\t  if (old_vr->type == VR_RANGE || old_vr->type == VR_ANTI_RANGE)\n-\t    vrp_intersect_ranges (&vr, old_vr);\n-\n-\t  /* If we found any usable VR, set the VR to ssa_name and create a\n-\t     PUSH old value in the stack with the old VR.  */\n-\t  if (vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE)\n+\t  /* Add VR when (OP0 CODE OP1) condition is true.  */\n+\t  try_add_new_range (op0, code, op1);\n+\n+\t  /* Register ranges for y in x < y where\n+\t     y might have ranges that are useful.  */\n+\t  tree limit;\n+\t  tree_code new_code;\n+\t  if (TREE_CODE (op1) == SSA_NAME\n+\t      && extract_code_and_val_from_cond_with_ops (op1, code,\n+\t\t\t\t\t\t\t  op0, op1,\n+\t\t\t\t\t\t\t  false,\n+\t\t\t\t\t\t\t  &new_code, &limit))\n \t    {\n-\t      new_vr = vrp_value_range_pool.allocate ();\n-\t      *new_vr = vr;\n-\t      push_value_range (op0, new_vr);\n+\t      /* Add VR when (OP1 NEW_CODE LIMIT) condition is true.  */\n+\t      try_add_new_range (op1, new_code, limit);\n \t    }\n \t}\n     }"}]}