{"sha": "5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY0MGIzY2JlMmU0MTY0ZTgwMjUyY2M0ZjIyMzRjZGI1ZWE2ZGEzOQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "ook@ucw.cz", "date": "2007-09-15T21:53:45Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-09-15T21:53:45Z"}, "message": "tree-parloops.c: New file.\n\n\t* tree-parloops.c: New file.\n\t* tree-ssa-operands.h (free_stmt_operands): Declare.\n\t* tree-ssa-loop-manip.c (split_loop_exit_edge): Return the new basic\n\tblock.\n\t* tree-pass.h (pass_parallelize_loops): Declare.\n\t* omp-low.c (expand_omp_parallel, expand_omp_for): Update SSA form for\n\tvirtual operands.\n\t(build_omp_regions_1): Allow analysing just a single OMP region and\n\tits subregions.\n\t( build_omp_regions_root, omp_expand_local): New functions.\n\t(build_omp_regions): Add argument to build_omp_regions_1 call.\n\t* builtins.def (DEF_GOMP_BUILTIN): Initialize OMP builtins when\n\tautoparallelization is run.\n\t* timevar.def (TV_TREE_PARALLELIZE_LOOPS): New.\n\t* tree-ssa-loop.c (gate_tree_parallelize_loops, tree_parallelize_loops,\n\tpass_parallelize_loops): New.\n\t* common.opt (ftree-parallelize-loops): New.\n\t* tree-flow.h (omp_expand_local, tree_duplicate_sese_tail,\n\tparallelize_loops): Declare.\n\t(add_phi_args_after_copy, split_loop_exit_edge): Declaration changed.\n\t* Makefile.in (tree-parloops.o): Added.\n\t* tree-cfg.c (add_phi_args_after_copy_edge, tree_duplicate_sese_tail):\n\tNew functions.\n\t(add_phi_args_after_copy_bb): Use add_phi_args_after_copy_edge.\n\t(add_phi_args_after_copy): Call add_phi_args_after_copy_edge for\n\tone extra edge as well.\n\t(tree_duplicate_sese_region): Add argument to add_phi_args_after_copy.\n\tUse VEC_free to free doms vector.\n\t(move_block_to_fn): Update loop info. Remove phi nodes for virtual\n\toperands.  Recompute operand caches in the new function.\n\t(move_sese_region_to_fn): Update loop info.\n\t* passes.c (init_optimization_passes): Add pass_parallelize_loops.\n\t* tree-ssa-operands.c (free_stmt_operands): New function.\n\n\t* doc/passes.texi: Document autoparallelization.\n\t* doc/invoke.texi (-ftree-parallelize-loops): New option.\n\n\t* gcc.dg/tree-ssa/parallelization-1.c: New test.\n\nFrom-SVN: r128517", "tree": {"sha": "b06c39b94a477f65f57a3ea35196956c8f6f74b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b06c39b94a477f65f57a3ea35196956c8f6f74b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/comments", "author": {"login": "rakdver", "id": 20416833, "node_id": "MDQ6VXNlcjIwNDE2ODMz", "avatar_url": "https://avatars.githubusercontent.com/u/20416833?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rakdver", "html_url": "https://github.com/rakdver", "followers_url": "https://api.github.com/users/rakdver/followers", "following_url": "https://api.github.com/users/rakdver/following{/other_user}", "gists_url": "https://api.github.com/users/rakdver/gists{/gist_id}", "starred_url": "https://api.github.com/users/rakdver/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rakdver/subscriptions", "organizations_url": "https://api.github.com/users/rakdver/orgs", "repos_url": "https://api.github.com/users/rakdver/repos", "events_url": "https://api.github.com/users/rakdver/events{/privacy}", "received_events_url": "https://api.github.com/users/rakdver/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2ae88ecd925ebe2d24884b474a1f19c89948a6f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ae88ecd925ebe2d24884b474a1f19c89948a6f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ae88ecd925ebe2d24884b474a1f19c89948a6f7"}], "stats": {"total": 1689, "additions": 1635, "deletions": 54}, "files": [{"sha": "207318240101d7950f96dbbebe23a83f7c5b70d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -1,3 +1,42 @@\n+2007-09-15  Zdenek Dvorak  <ook@ucw.cz>\n+\n+\t* tree-parloops.c: New file.\n+\t* tree-ssa-operands.h (free_stmt_operands): Declare.\n+\t* tree-ssa-loop-manip.c (split_loop_exit_edge): Return the new basic\n+\tblock.\n+\t* tree-pass.h (pass_parallelize_loops): Declare.\n+\t* omp-low.c (expand_omp_parallel, expand_omp_for): Update SSA form for\n+\tvirtual operands.\n+\t(build_omp_regions_1): Allow analysing just a single OMP region and\n+\tits subregions.\n+\t( build_omp_regions_root, omp_expand_local): New functions.\n+\t(build_omp_regions): Add argument to build_omp_regions_1 call.\n+\t* builtins.def (DEF_GOMP_BUILTIN): Initialize OMP builtins when\n+\tautoparallelization is run.\n+\t* timevar.def (TV_TREE_PARALLELIZE_LOOPS): New.\n+\t* tree-ssa-loop.c (gate_tree_parallelize_loops, tree_parallelize_loops,\n+\tpass_parallelize_loops): New.\n+\t* common.opt (ftree-parallelize-loops): New.\n+\t* tree-flow.h (omp_expand_local, tree_duplicate_sese_tail,\n+\tparallelize_loops): Declare.\n+\t(add_phi_args_after_copy, split_loop_exit_edge): Declaration changed.\n+\t* Makefile.in (tree-parloops.o): Added.\n+\t* tree-cfg.c (add_phi_args_after_copy_edge, tree_duplicate_sese_tail):\n+\tNew functions.\n+\t(add_phi_args_after_copy_bb): Use add_phi_args_after_copy_edge.\n+\t(add_phi_args_after_copy): Call add_phi_args_after_copy_edge for\n+\tone extra edge as well.\n+\t(tree_duplicate_sese_region): Add argument to add_phi_args_after_copy.\n+\tUse VEC_free to free doms vector.\n+\t(move_block_to_fn): Update loop info. Remove phi nodes for virtual\n+\toperands.  Recompute operand caches in the new function.\n+\t(move_sese_region_to_fn): Update loop info.\n+\t* passes.c (init_optimization_passes): Add pass_parallelize_loops.\n+\t* tree-ssa-operands.c (free_stmt_operands): New function.\n+\n+\t* doc/passes.texi: Document autoparallelization.\n+\t* doc/invoke.texi (-ftree-parallelize-loops): New option.\n+\n 2007-09-15  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR target/33062"}, {"sha": "2e522d59931fb4f7d85a01d09e327468b0f69c7d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -1153,6 +1153,7 @@ OBJS-common = \\\n \ttree-object-size.o \\\n \ttree-optimize.o \\\n \ttree-outof-ssa.o \\\n+\ttree-parloops.o \\\n \ttree-phinodes.o \\\n \ttree-predcom.o \\\n \ttree-pretty-print.o \\\n@@ -2270,6 +2271,9 @@ tree-loop-linear.o: tree-loop-linear.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n    tree-pass.h $(TREE_DATA_REF_H) $(SCEV_H) $(EXPR_H) $(LAMBDA_H) \\\n    $(TARGET_H) tree-chrec.h $(OBSTACK_H)\n+tree-parloops.o: tree-parloops.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(TREE_FLOW_H) $(TREE_H) $(RTL_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) $(GGC_H) \\\n+   $(DIAGNOSTIC_H) tree-pass.h $(SCEV_H) langhooks.h gt-tree-parloops.h\n tree-stdarg.o: tree-stdarg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(FUNCTION_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) tree-pass.h \\\n    tree-stdarg.h $(TARGET_H) langhooks.h\n@@ -3091,7 +3095,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/tree-ssa-operands.h \\\n   $(srcdir)/tree-profile.c $(srcdir)/tree-nested.c \\\n   $(srcdir)/ipa-reference.c $(srcdir)/tree-ssa-structalias.h \\\n-  $(srcdir)/tree-ssa-structalias.c \\\n+  $(srcdir)/tree-ssa-structalias.c $(srcdir)/tree-parloops.c \\\n   $(srcdir)/omp-low.c $(srcdir)/varpool.c \\\n   $(srcdir)/targhooks.c $(out_file) $(srcdir)/passes.c $(srcdir)/cgraphunit.c \\\n   @all_gtfiles@"}, {"sha": "c3c8b2fa35100aea12076c9a6cc11f4a8d757661", "filename": "gcc/builtins.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -139,7 +139,8 @@ along with GCC; see the file COPYING3.  If not see\n #undef DEF_GOMP_BUILTIN\n #define DEF_GOMP_BUILTIN(ENUM, NAME, TYPE, ATTRS) \\\n   DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n-               false, true, true, ATTRS, false, flag_openmp)\n+               false, true, true, ATTRS, false, \\\n+\t       (flag_openmp || flag_tree_parallelize_loops))\n \n /* Define an attribute list for math functions that are normally\n    \"impure\" because some of them may write into global memory for"}, {"sha": "4d9f9b85e4dc5474bdfba22f6a3a934e61fd3266", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -1088,6 +1088,10 @@ ftree-loop-optimize\n Common Report Var(flag_tree_loop_optimize) Init(1) Optimization\n Enable loop optimizations on tree level\n \n+ftree-parallelize-loops=\n+Common Report Joined UInteger Var(flag_tree_parallelize_loops) Init(1)\n+Enable automatic parallelization of loops\n+\n ftree-pre\n Common Report Var(flag_tree_pre) Optimization\n Enable SSA-PRE optimization on trees"}, {"sha": "228be52950537eb43f5ed063ec093a35fd400738", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -358,7 +358,7 @@ Objective-C and Objective-C++ Dialects}.\n -fvariable-expansion-in-unroller -ftree-reassoc @gol\n -ftree-pre  -ftree-ccp  -ftree-dce -ftree-loop-optimize @gol\n -ftree-loop-linear -ftree-loop-im -ftree-loop-ivcanon -fivopts @gol\n--fcheck-data-deps @gol\n+-fcheck-data-deps -ftree-parallelize-loops @gol\n -ftree-dominator-opts -ftree-dse -ftree-copyrename -ftree-sink @gol\n -ftree-ch -ftree-sra -ftree-ter -ftree-fre -ftree-vectorize @gol\n -ftree-vect-loop-version -fvect-cost-model -ftree-salias -fipa-pta -fweb @gol\n@@ -5744,6 +5744,14 @@ in connection with unrolling.\n Perform induction variable optimizations (strength reduction, induction\n variable merging and induction variable elimination) on trees.\n \n+@item -ftree-parallelize-loops=n\n+@opindex ftree-parallelize-loops=n\n+Parallelize loops, i.e., split their iteration space to run in n threads.\n+This is only possible for loops whose iterations are independent\n+and can be arbitrarily reordered.  The optimization is only\n+profitable on multiprocessor machines, for loops that are CPU-intensive,\n+rather than constrained e.g. by memory bandwidth.\n+\n @item -ftree-sra\n Perform scalar replacement of aggregates.  This pass replaces structure\n references with scalars to prevent committing structures to memory too"}, {"sha": "2f354394e99d9651f09912822deaea3778faa013", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -438,6 +438,9 @@ The pass is implemented in @file{tree-vectorizer.c} (the main driver and general\n utilities), @file{tree-vect-analyze.c} and @file{tree-vect-transform.c}.\n Analysis of data references is in @file{tree-data-ref.c}.\n \n+Autoparallelization.  This pass splits the loop iteration space to run\n+into several threads.  The pass is implemented in @file{tree-parloops.c}.\n+\n @item Tree level if-conversion for vectorizer\n \n This pass applies if-conversion to simple loops to help vectorizer."}, {"sha": "421b5c62863b709e2ece9ac1d4fa00bde16644a0", "filename": "gcc/omp-low.c", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -2600,6 +2600,7 @@ expand_omp_parallel (struct omp_region *region)\n \n   /* Emit a library call to launch the children threads.  */\n   expand_parallel_call (region, new_bb, entry_stmt, ws_args);\n+  update_ssa (TODO_update_ssa_only_virtuals);\n }\n \n \n@@ -3282,6 +3283,8 @@ expand_omp_for (struct omp_region *region)\n       int next_ix = BUILT_IN_GOMP_LOOP_STATIC_NEXT + fn_index;\n       expand_omp_for_generic (region, &fd, start_ix, next_ix);\n     }\n+\n+  update_ssa (TODO_update_ssa_only_virtuals);\n }\n \n \n@@ -3591,10 +3594,13 @@ expand_omp (struct omp_region *region)\n \n \n /* Helper for build_omp_regions.  Scan the dominator tree starting at\n-   block BB.  PARENT is the region that contains BB.  */\n+   block BB.  PARENT is the region that contains BB.  If SINGLE_TREE is\n+   true, the function ends once a single tree is built (otherwise, whole\n+   forest of OMP constructs may be built).  */\n \n static void\n-build_omp_regions_1 (basic_block bb, struct omp_region *parent)\n+build_omp_regions_1 (basic_block bb, struct omp_region *parent,\n+\t\t     bool single_tree)\n {\n   block_stmt_iterator si;\n   tree stmt;\n@@ -3643,12 +3649,44 @@ build_omp_regions_1 (basic_block bb, struct omp_region *parent)\n \t}\n     }\n \n+  if (single_tree && !parent)\n+    return;\n+\n   for (son = first_dom_son (CDI_DOMINATORS, bb);\n        son;\n        son = next_dom_son (CDI_DOMINATORS, son))\n-    build_omp_regions_1 (son, parent);\n+    build_omp_regions_1 (son, parent, single_tree);\n+}\n+\n+/* Builds the tree of OMP regions rooted at ROOT, storing it to\n+   root_omp_region.  */\n+\n+static void\n+build_omp_regions_root (basic_block root)\n+{\n+  gcc_assert (root_omp_region == NULL);\n+  build_omp_regions_1 (root, NULL, true);\n+  gcc_assert (root_omp_region != NULL);\n }\n \n+/* Expands omp construct (and its subconstructs) starting in HEAD.  */\n+\n+void\n+omp_expand_local (basic_block head)\n+{\n+  build_omp_regions_root (head);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\nOMP region tree\\n\\n\");\n+      dump_omp_region (dump_file, root_omp_region, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  remove_exit_barriers (root_omp_region);\n+  expand_omp (root_omp_region);\n+\n+  free_omp_regions ();\n+}\n \n /* Scan the CFG and build a tree of OMP regions.  Return the root of\n    the OMP region tree.  */\n@@ -3658,7 +3696,7 @@ build_omp_regions (void)\n {\n   gcc_assert (root_omp_region == NULL);\n   calculate_dominance_info (CDI_DOMINATORS);\n-  build_omp_regions_1 (ENTRY_BLOCK_PTR, NULL);\n+  build_omp_regions_1 (ENTRY_BLOCK_PTR, NULL, false);\n }\n \n "}, {"sha": "74f48a83401afef0ea0a45fea8be58487b1aa04b", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -629,6 +629,7 @@ init_optimization_passes (void)\n \t      NEXT_PASS (pass_dce_loop);\n \t    }\n \t  NEXT_PASS (pass_complete_unroll);\n+\t  NEXT_PASS (pass_parallelize_loops);\n \t  NEXT_PASS (pass_loop_prefetch);\n \t  NEXT_PASS (pass_iv_optimize);\n \t  NEXT_PASS (pass_tree_loop_done);"}, {"sha": "a46d3355eb1298f28019af194433cdc3459bbd1e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -1,3 +1,7 @@\n+2007-09-15  Zdenek Dvorak  <ook@ucw.cz>\n+\n+\t* gcc.dg/tree-ssa/parallelization-1.c: New test.\n+\n 2007-09-15  Dorit Nuzman  <dorit@il.ibm.com>\n \n \t* gcc.dg/vect/pr33373b.c: New test."}, {"sha": "ee62ff666b8b03bc8998e7532fea2da231fbc9d3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/parallelization-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fparallelization-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fparallelization-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fparallelization-1.c?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-final_cleanup\" } */\n+\n+void abort (void);\n+\n+void parloop (int N)\n+{\n+  int i;\n+  int x[10000000];\n+\n+  for (i = 0; i < N; i++)\n+    x[i] = i + 3;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      if (x[i] != i + 3)\n+\tabort ();\n+    }\n+}\n+\n+int main(void)\n+{\n+  parloop(10000000);\n+\n+  return 0;\n+}\n+\n+/* Check that the first loop in parloop got parallelized.  */\n+\n+/* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops\" } } */\n+/* { dg-final { scan-tree-dump-times \"loopfn\" 5 \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"parloops\" } } */\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */"}, {"sha": "e503894677b211d5e8ed03bdfe4661e34b6d523f", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -120,6 +120,7 @@ DEFTIMEVAR (TV_TREE_LOOP_IVCANON     , \"tree canonical iv\")\n DEFTIMEVAR (TV_SCEV_CONST            , \"scev constant prop\")\n DEFTIMEVAR (TV_TREE_LOOP_UNSWITCH    , \"tree loop unswitching\")\n DEFTIMEVAR (TV_COMPLETE_UNROLL       , \"complete unrolling\")\n+DEFTIMEVAR (TV_TREE_PARALLELIZE_LOOPS, \"tree parallelize loops\")\n DEFTIMEVAR (TV_TREE_VECTORIZATION    , \"tree vectorization\")\n DEFTIMEVAR (TV_TREE_LINEAR_TRANSFORM , \"tree loop linear\")\n DEFTIMEVAR (TV_CHECK_DATA_DEPS       , \"tree check data dependences\")"}, {"sha": "e82238201fe14e2d0f561c275234a088656eeabd", "filename": "gcc/tracer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -310,7 +310,7 @@ tail_duplicate (void)\n \t      copy = duplicate_block (bb2, e, bb);\n \t      flush_pending_stmts (e);\n \n-\t      add_phi_args_after_copy (&copy, 1);\n+\t      add_phi_args_after_copy (&copy, 1, NULL);\n \n \t      /* Reconsider the original copy of block we've duplicated.\n \t         Removing the most common predecessor may make it to be"}, {"sha": "3de20cc57e6cf115a3dd87f9cfd581e02343bbf6", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 245, "deletions": 42, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -5009,6 +5009,52 @@ tree_duplicate_bb (basic_block bb)\n   return new_bb;\n }\n \n+/* Adds phi node arguments for edge E_COPY after basic block duplication.  */\n+\n+static void\n+add_phi_args_after_copy_edge (edge e_copy)\n+{\n+  basic_block bb, bb_copy = e_copy->src, dest;\n+  edge e;\n+  edge_iterator ei;\n+  tree phi, phi_copy, phi_next, def;\n+\n+  if (!phi_nodes (e_copy->dest))\n+    return;\n+\n+  bb = bb_copy->flags & BB_DUPLICATED ? get_bb_original (bb_copy) : bb_copy;\n+\n+  if (e_copy->dest->flags & BB_DUPLICATED)\n+    dest = get_bb_original (e_copy->dest);\n+  else\n+    dest = e_copy->dest;\n+\n+  e = find_edge (bb, dest);\n+  if (!e)\n+    {\n+      /* During loop unrolling the target of the latch edge is copied.\n+\t In this case we are not looking for edge to dest, but to\n+\t duplicated block whose original was dest.  */\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  if ((e->dest->flags & BB_DUPLICATED)\n+\t      && get_bb_original (e->dest) == dest)\n+\t    break;\n+\t}\n+\n+      gcc_assert (e != NULL);\n+    }\n+\n+  for (phi = phi_nodes (e->dest), phi_copy = phi_nodes (e_copy->dest);\n+       phi;\n+       phi = phi_next, phi_copy = PHI_CHAIN (phi_copy))\n+    {\n+      phi_next = PHI_CHAIN (phi);\n+      def = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+      add_phi_arg (phi_copy, def, e_copy);\n+    }\n+}\n+\n \n /* Basic block BB_COPY was created by code duplication.  Add phi node\n    arguments for edges going out of BB_COPY.  The blocks that were\n@@ -5017,54 +5063,23 @@ tree_duplicate_bb (basic_block bb)\n void\n add_phi_args_after_copy_bb (basic_block bb_copy)\n {\n-  basic_block bb, dest;\n-  edge e, e_copy;\n   edge_iterator ei;\n-  tree phi, phi_copy, phi_next, def;\n-\n-  bb = get_bb_original (bb_copy);\n+  edge e_copy;\n \n   FOR_EACH_EDGE (e_copy, ei, bb_copy->succs)\n     {\n-      if (!phi_nodes (e_copy->dest))\n-\tcontinue;\n-\n-      if (e_copy->dest->flags & BB_DUPLICATED)\n-\tdest = get_bb_original (e_copy->dest);\n-      else\n-\tdest = e_copy->dest;\n-\n-      e = find_edge (bb, dest);\n-      if (!e)\n-\t{\n-\t  /* During loop unrolling the target of the latch edge is copied.\n-\t     In this case we are not looking for edge to dest, but to\n-\t     duplicated block whose original was dest.  */\n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    if ((e->dest->flags & BB_DUPLICATED)\n-\t\t&& get_bb_original (e->dest) == dest)\n-\t      break;\n-\n-\t  gcc_assert (e != NULL);\n-\t}\n-\n-      for (phi = phi_nodes (e->dest), phi_copy = phi_nodes (e_copy->dest);\n-\t   phi;\n-\t   phi = phi_next, phi_copy = PHI_CHAIN (phi_copy))\n-\t{\n-\t  phi_next = PHI_CHAIN (phi);\n-\t  def = PHI_ARG_DEF_FROM_EDGE (phi, e);\n-\t  add_phi_arg (phi_copy, def, e_copy);\n-\t}\n+      add_phi_args_after_copy_edge (e_copy);\n     }\n }\n \n /* Blocks in REGION_COPY array of length N_REGION were created by\n    duplication of basic blocks.  Add phi node arguments for edges\n-   going from these blocks.  */\n+   going from these blocks.  If E_COPY is not NULL, also add\n+   phi node arguments for its destination.*/\n \n void\n-add_phi_args_after_copy (basic_block *region_copy, unsigned n_region)\n+add_phi_args_after_copy (basic_block *region_copy, unsigned n_region,\n+\t\t\t edge e_copy)\n {\n   unsigned i;\n \n@@ -5073,6 +5088,8 @@ add_phi_args_after_copy (basic_block *region_copy, unsigned n_region)\n \n   for (i = 0; i < n_region; i++)\n     add_phi_args_after_copy_bb (region_copy[i]);\n+  if (e_copy)\n+    add_phi_args_after_copy_edge (e_copy);\n \n   for (i = 0; i < n_region; i++)\n     region_copy[i]->flags &= ~BB_DUPLICATED;\n@@ -5210,10 +5227,180 @@ tree_duplicate_sese_region (edge entry, edge exit,\n   set_immediate_dominator (CDI_DOMINATORS, entry->dest, entry->src);\n   VEC_safe_push (basic_block, heap, doms, get_bb_original (entry->dest));\n   iterate_fix_dominators (CDI_DOMINATORS, doms, false);\n-  free (doms);\n+  VEC_free (basic_block, heap, doms);\n \n   /* Add the other PHI node arguments.  */\n-  add_phi_args_after_copy (region_copy, n_region);\n+  add_phi_args_after_copy (region_copy, n_region, NULL);\n+\n+  /* Update the SSA web.  */\n+  update_ssa (TODO_update_ssa);\n+\n+  if (free_region_copy)\n+    free (region_copy);\n+\n+  free_original_copy_tables ();\n+  return true;\n+}\n+\n+/* Duplicates REGION consisting of N_REGION blocks.  The new blocks\n+   are stored to REGION_COPY in the same order in that they appear\n+   in REGION, if REGION_COPY is not NULL.  ENTRY is the entry to\n+   the region, EXIT an exit from it.  The condition guarding EXIT\n+   is moved to ENTRY.  Returns true if duplication succeeds, false\n+   otherwise.\n+\n+   For example, \n+ \n+   some_code;\n+   if (cond)\n+     A;\n+   else\n+     B;\n+\n+   is transformed to\n+\n+   if (cond)\n+     {\n+       some_code;\n+       A;\n+     }\n+   else\n+     {\n+       some_code;\n+       B;\n+     }\n+*/\n+\n+bool\n+tree_duplicate_sese_tail (edge entry, edge exit,\n+\t\t\t  basic_block *region, unsigned n_region,\n+\t\t\t  basic_block *region_copy)\n+{\n+  unsigned i;\n+  bool free_region_copy = false;\n+  struct loop *loop = exit->dest->loop_father;\n+  struct loop *orig_loop = entry->dest->loop_father;\n+  basic_block switch_bb, entry_bb, nentry_bb;\n+  VEC (basic_block, heap) *doms;\n+  int total_freq = 0, exit_freq = 0;\n+  gcov_type total_count = 0, exit_count = 0;\n+  edge exits[2], nexits[2], e;\n+  block_stmt_iterator bsi;\n+  tree cond;\n+  edge sorig, snew;\n+\n+  gcc_assert (EDGE_COUNT (exit->src->succs) == 2);\n+  exits[0] = exit;\n+  exits[1] = EDGE_SUCC (exit->src, EDGE_SUCC (exit->src, 0) == exit);\n+\n+  if (!can_copy_bbs_p (region, n_region))\n+    return false;\n+\n+  /* Some sanity checking.  Note that we do not check for all possible\n+     missuses of the functions.  I.e. if you ask to copy something weird\n+     (e.g., in the example, if there is a jump from inside to the middle\n+     of some_code, or come_code defines some of the values used in cond)\n+     it will work, but the resulting code will not be correct.  */\n+  for (i = 0; i < n_region; i++)\n+    {\n+      /* We do not handle subloops, i.e. all the blocks must belong to the\n+\t same loop.  */\n+      if (region[i]->loop_father != orig_loop)\n+\treturn false;\n+\n+      if (region[i] == orig_loop->latch)\n+\treturn false;\n+    }\n+\n+  initialize_original_copy_tables ();\n+  set_loop_copy (orig_loop, loop);\n+\n+  if (!region_copy)\n+    {\n+      region_copy = XNEWVEC (basic_block, n_region);\n+      free_region_copy = true;\n+    }\n+\n+  gcc_assert (!need_ssa_update_p ());\n+\n+  /* Record blocks outside the region that are dominated by something\n+     inside.  */\n+  doms = get_dominated_by_region (CDI_DOMINATORS, region, n_region);\n+\n+  if (exit->src->count)\n+    {\n+      total_count = exit->src->count;\n+      exit_count = exit->count;\n+      /* Fix up corner cases, to avoid division by zero or creation of negative\n+\t frequencies.  */\n+      if (exit_count > total_count)\n+\texit_count = total_count;\n+    }\n+  else\n+    {\n+      total_freq = exit->src->frequency;\n+      exit_freq = EDGE_FREQUENCY (exit);\n+      /* Fix up corner cases, to avoid division by zero or creation of negative\n+\t frequencies.  */\n+      if (total_freq == 0)\n+\ttotal_freq = 1;\n+      if (exit_freq > total_freq)\n+\texit_freq = total_freq;\n+    }\n+\n+  copy_bbs (region, n_region, region_copy, exits, 2, nexits, orig_loop,\n+\t    split_edge_bb_loc (exit));\n+  if (total_count)\n+    {\n+      scale_bbs_frequencies_gcov_type (region, n_region,\n+\t\t\t\t       total_count - exit_count,\n+\t\t\t\t       total_count);\n+      scale_bbs_frequencies_gcov_type (region_copy, n_region, exit_count,\n+\t\t\t\t       total_count);\n+    }\n+  else\n+    {\n+      scale_bbs_frequencies_int (region, n_region, total_freq - exit_freq,\n+\t\t\t\t total_freq);\n+      scale_bbs_frequencies_int (region_copy, n_region, exit_freq, total_freq);\n+    }\n+\n+  /* Create the switch block, and put the exit condition to it.  */\n+  entry_bb = entry->dest;\n+  nentry_bb = get_bb_copy (entry_bb);\n+  if (!last_stmt (entry->src)\n+      || !stmt_ends_bb_p (last_stmt (entry->src)))\n+    switch_bb = entry->src;\n+  else\n+    switch_bb = split_edge (entry);\n+  set_immediate_dominator (CDI_DOMINATORS, nentry_bb, switch_bb);\n+\n+  bsi = bsi_last (switch_bb);\n+  cond = last_stmt (exit->src);\n+  gcc_assert (TREE_CODE (cond) == COND_EXPR);\n+  bsi_insert_after (&bsi, unshare_expr (cond), BSI_NEW_STMT);\n+\n+  sorig = single_succ_edge (switch_bb);\n+  sorig->flags = exits[1]->flags;\n+  snew = make_edge (switch_bb, nentry_bb, exits[0]->flags);\n+\n+  /* Register the new edge from SWITCH_BB in loop exit lists.  */\n+  rescan_loop_exit (snew, true, false);\n+\n+  /* Add the PHI node arguments.  */\n+  add_phi_args_after_copy (region_copy, n_region, snew);\n+\n+  /* Get rid of now superfluous conditions and associated edges (and phi node\n+     arguments).  */\n+  e = redirect_edge_and_branch (exits[0], exits[1]->dest);\n+  PENDING_STMT (e) = NULL_TREE;\n+  e = redirect_edge_and_branch (nexits[1], nexits[0]->dest);\n+  PENDING_STMT (e) = NULL_TREE;\n+\n+  /* Anything that is outside of the region, but was dominated by something\n+     inside needs to update dominance info.  */\n+  iterate_fix_dominators (CDI_DOMINATORS, doms, false);\n+  VEC_free (basic_block, heap, doms);\n \n   /* Update the SSA web.  */\n   update_ssa (TODO_update_ssa);\n@@ -5456,10 +5643,12 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n   block_stmt_iterator si;\n   struct move_stmt_d d;\n   unsigned old_len, new_len;\n-  tree phi;\n+  tree phi, next_phi;\n \n   /* Remove BB from dominance structures.  */\n   delete_from_dominance_info (CDI_DOMINATORS, bb);\n+  if (current_loops)\n+    remove_bb_from_loops (bb);\n \n   /* Link BB to the new linked list.  */\n   move_block_after (bb, after);\n@@ -5494,14 +5683,20 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n                bb->index, bb);\n \n   /* Remap the variables in phi nodes.  */\n-  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+  for (phi = phi_nodes (bb); phi; phi = next_phi)\n     {\n       use_operand_p use;\n       tree op = PHI_RESULT (phi);\n       ssa_op_iter oi;\n \n+      next_phi = PHI_CHAIN (phi);\n       if (!is_gimple_reg (op))\n-\tcontinue;\n+\t{\n+\t  /* Remove the phi nodes for virtual operands (alias analysis will be\n+\t     run for the new function, anyway).  */\n+          remove_phi_node (phi, NULL, true);\n+\t  continue;\n+\t}\n \n       SET_PHI_RESULT (phi, replace_ssa_name (op, vars_map, dest_cfun->decl));\n       FOR_EACH_PHI_ARG (use, phi, oi, SSA_OP_USE)\n@@ -5569,7 +5764,12 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n           gimple_remove_stmt_histograms (cfun, stmt);\n \t}\n \n+      /* We cannot leave any operands allocated from the operand caches of\n+\t the current function.  */\n+      free_stmt_operands (stmt);\n+      push_cfun (dest_cfun);\n       update_stmt (stmt);\n+      pop_cfun ();\n     }\n }\n \n@@ -5658,6 +5858,7 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n   edge_iterator ei;\n   htab_t new_label_map;\n   struct pointer_map_t *vars_map;\n+  struct loop *loop = entry_bb->loop_father;\n \n   /* If ENTRY does not strictly dominate EXIT, this cannot be an SESE\n      region.  */\n@@ -5786,6 +5987,8 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n   /* Back in the original function, the SESE region has disappeared,\n      create a new basic block in its place.  */\n   bb = create_empty_bb (entry_pred[0]);\n+  if (current_loops)\n+    add_bb_to_loop (bb, loop);\n   for (i = 0; i < num_entry_edges; i++)\n     {\n       e = make_edge (entry_pred[i], bb, entry_flag[i]);"}, {"sha": "518e4f2236ef09b13fe130b2289c8e052a70171a", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -704,6 +704,7 @@ extern struct omp_region *root_omp_region;\n extern struct omp_region *new_omp_region (basic_block, enum tree_code,\n \t\t\t\t\t  struct omp_region *);\n extern void free_omp_regions (void);\n+void omp_expand_local (basic_block);\n extern tree find_omp_clause (tree, enum tree_code);\n tree copy_var_decl (tree, tree, tree);\n \n@@ -753,8 +754,10 @@ extern tree tree_block_label (basic_block);\n extern void extract_true_false_edges_from_block (basic_block, edge *, edge *);\n extern bool tree_duplicate_sese_region (edge, edge, basic_block *, unsigned,\n \t\t\t\t\tbasic_block *);\n+extern bool tree_duplicate_sese_tail (edge, edge, basic_block *, unsigned,\n+\t\t\t\t      basic_block *);\n extern void add_phi_args_after_copy_bb (basic_block);\n-extern void add_phi_args_after_copy (basic_block *, unsigned);\n+extern void add_phi_args_after_copy (basic_block *, unsigned, edge);\n extern bool tree_purge_dead_abnormal_call_edges (basic_block);\n extern bool tree_purge_dead_eh_edges (basic_block);\n extern bool tree_purge_all_dead_eh_edges (const_bitmap);\n@@ -971,6 +974,7 @@ unsigned int tree_ssa_prefetch_arrays (void);\n unsigned int remove_empty_loops (void);\n void tree_ssa_iv_optimize (void);\n unsigned tree_predictive_commoning (void);\n+bool parallelize_loops (void);\n \n bool number_of_iterations_exit (struct loop *, edge,\n \t\t\t\tstruct tree_niter_desc *niter, bool);\n@@ -992,7 +996,7 @@ void verify_loop_closed_ssa (void);\n bool for_each_index (tree *, bool (*) (tree, tree *, void *), void *);\n void create_iv (tree, tree, tree, struct loop *, block_stmt_iterator *, bool,\n \t\ttree *, tree *);\n-void split_loop_exit_edge (edge);\n+basic_block split_loop_exit_edge (edge);\n unsigned force_expr_to_var_cost (tree);\n void standard_iv_increment_position (struct loop *, block_stmt_iterator *,\n \t\t\t\t     bool *);"}, {"sha": "aca2b74c31a0d43307b1e149506f6aab23e0716c", "filename": "gcc/tree-parloops.c", "status": "added", "additions": 1148, "deletions": 0, "changes": 1148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -0,0 +1,1148 @@\n+/* Loop autoparallelization.\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <pop@cri.ensmp.fr> and\n+   Zdenek Dvorak <dvorakz@suse.cz>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"tree-flow.h\"\n+#include \"cfgloop.h\"\n+#include \"ggc.h\"\n+#include \"tree-data-ref.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"hashtab.h\"\n+#include \"langhooks.h\"\n+\n+/* This pass tries to distribute iterations of loops into several threads.\n+   The implementation is straightforward -- for each loop we test whether its\n+   iterations are independent, and if it is the case (and some additional\n+   conditions regarding profitability and correctness are satisfied), we\n+   add OMP_PARALLEL and OMP_FOR codes and let omp expansion machinery do\n+   its job.\n+   \n+   The most of the complexity is in bringing the code into shape expected\n+   by the omp expanders:\n+   -- for OMP_FOR, ensuring that the loop has only one induction variable\n+      and that the exit test is at the start of the loop body\n+   -- for OMP_PARALLEL, replacing the references to local addressable\n+      variables by accesses through pointers, and breaking up ssa chains\n+      by storing the values incoming to the parallelized loop to a structure\n+      passed to the new function as an argument (something similar is done\n+      in omp gimplification, unfortunately only a small part of the code\n+      can be shared).\n+\n+   TODO:\n+   -- if there are several parallelizable loops in a function, it may be\n+      possible to generate the threads just once (using synchronization to\n+      ensure that cross-loop dependences are obeyed).\n+   -- handling of common scalar dependence patterns (accumulation, ...)\n+   -- handling of non-innermost loops  */\n+\n+/* Minimal number of iterations of a loop that should be executed in each\n+   thread.  */\n+#define MIN_PER_THREAD 100\n+\n+/* Element of hashtable of names to copy.  */\n+\n+struct name_to_copy_elt\n+{\n+  unsigned version;\t/* The version of the name to copy.  */\n+  tree new_name;\t/* The new name used in the copy.  */\n+  tree field;\t\t/* The field of the structure used to pass the\n+\t\t\t   value.  */\n+};\n+\n+/* Equality and hash functions for hashtab code.  */\n+\n+static int\n+name_to_copy_elt_eq (const void *aa, const void *bb)\n+{\n+  struct name_to_copy_elt *a = (struct name_to_copy_elt *) aa;\n+  struct name_to_copy_elt *b = (struct name_to_copy_elt *) bb;\n+\n+  return a->version == b->version;\n+}\n+\n+static hashval_t\n+name_to_copy_elt_hash (const void *aa)\n+{\n+  struct name_to_copy_elt *a = (struct name_to_copy_elt *) aa;\n+\n+  return (hashval_t) a->version;\n+}\n+\n+/* Returns true if the iterations of LOOP are independent on each other (that\n+   is, if we can execute them in parallel), and if LOOP satisfies other\n+   conditions that we need to be able to parallelize it.  Description of number\n+   of iterations is stored to NITER.  */\n+\n+static bool\n+loop_parallel_p (struct loop *loop, struct tree_niter_desc *niter)\n+{\n+  edge exit = single_dom_exit (loop);\n+  VEC (ddr_p, heap) *dependence_relations;\n+  VEC (data_reference_p, heap) *datarefs;\n+  lambda_trans_matrix trans;\n+  bool ret = false;\n+  tree phi;\n+\n+  /* Only consider innermost loops with just one exit.  The innermost-loop\n+     restriction is not necessary, but it makes things simpler.  */\n+  if (loop->inner || !exit)\n+    return false;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\nConsidering loop %d\\n\", loop->num);\n+\n+  /* We need to know # of iterations, and there should be no uses of values\n+     defined inside loop outside of it, unless the values are invariants of\n+     the loop.  */\n+  if (!number_of_iterations_exit (loop, exit, niter, false))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  FAILED: number of iterations not known\\n\");\n+      return false;\n+    }\n+\n+  for (phi = phi_nodes (exit->dest); phi; phi = PHI_CHAIN (phi))\n+    {\n+      tree val = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n+\n+      if (is_gimple_reg (val))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"  FAILED: value used outside loop\\n\");\n+\t  return false;\n+\t}\n+    }\n+\n+  /* The iterations of the loop may communicate only through bivs whose\n+     iteration space can be distributed efficiently.  */\n+  for (phi = phi_nodes (loop->header); phi; phi = PHI_CHAIN (phi))\n+    {\n+      tree def = PHI_RESULT (phi);\n+      affine_iv iv;\n+\n+      if (is_gimple_reg (def)\n+\t  && !simple_iv (loop, phi, def, &iv, true))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"  FAILED: scalar dependency between iterations\\n\");\n+\t  return false;\n+\t}\n+    }\n+\n+  /* We need to version the loop to verify assumptions in runtime.  */\n+  if (!can_duplicate_loop_p (loop))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  FAILED: cannot be duplicated\\n\");\n+      return false;\n+    }\n+\n+  /* Check for problems with dependences.  If the loop can be reversed,\n+     the iterations are independent.  */\n+  datarefs = VEC_alloc (data_reference_p, heap, 10);\n+  dependence_relations = VEC_alloc (ddr_p, heap, 10 * 10);\n+  compute_data_dependences_for_loop (loop, true, &datarefs,\n+\t\t\t\t     &dependence_relations);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    dump_data_dependence_relations (dump_file, dependence_relations);\n+\n+  trans = lambda_trans_matrix_new (1, 1);\n+  LTM_MATRIX (trans)[0][0] = -1;\n+\n+  if (lambda_transform_legal_p (trans, 1, dependence_relations))\n+    {\n+      ret = true;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  SUCCESS: may be parallelized\\n\");\n+    }\n+  else if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"  FAILED: data dependencies exist across iterations\\n\");\n+\n+  free_dependence_relations (dependence_relations);\n+  free_data_refs (datarefs);\n+\n+  return ret;\n+}\n+\n+/* Assigns the address of VAR in TYPE to an ssa name, and returns this name.\n+   The assignment statement is placed before LOOP.  DECL_ADDRESS maps decls\n+   to their addresses that can be reused.  */\n+\n+static tree\n+take_address_of (tree var, tree type, struct loop *loop, htab_t decl_address)\n+{\n+  int uid = DECL_UID (var);\n+  void **dslot;\n+  struct int_tree_map ielt, *nielt;\n+  tree name, bvar, stmt;\n+  edge entry = loop_preheader_edge (loop);\n+\n+  ielt.uid = uid;\n+  dslot = htab_find_slot_with_hash (decl_address, &ielt, uid, INSERT);\n+  if (!*dslot)\n+    {\n+      bvar = create_tmp_var (type, get_name (var));\n+      add_referenced_var (bvar);\n+      stmt = build_gimple_modify_stmt (bvar,\n+\t\t     fold_convert (type,\n+\t\t\t\t   build_addr (var, current_function_decl)));\n+      name = make_ssa_name (bvar, stmt);\n+      GIMPLE_STMT_OPERAND (stmt, 0) = name;\n+      bsi_insert_on_edge_immediate (entry, stmt);\n+\n+      nielt = XNEW (struct int_tree_map);\n+      nielt->uid = uid;\n+      nielt->to = name;\n+      *dslot = nielt;\n+\n+      return name;\n+    }\n+\n+  name = ((struct int_tree_map *) *dslot)->to;\n+  if (TREE_TYPE (name) == type)\n+    return name;\n+\n+  bvar = SSA_NAME_VAR (name);\n+  stmt = build_gimple_modify_stmt (bvar,\n+\t\t fold_convert (type, name));\n+  name = make_ssa_name (bvar, stmt);\n+  GIMPLE_STMT_OPERAND (stmt, 0) = name;\n+  bsi_insert_on_edge_immediate (entry, stmt);\n+\n+  return name;\n+}\n+\n+/* Eliminates references to local variables in *TP out of LOOP.  DECL_ADDRESS\n+   contains addresses of the references that had their address taken already.\n+   If the expression is changed, CHANGED is set to true.  Callback for\n+   walk_tree.  */\n+\n+struct elv_data\n+{\n+  struct loop *loop;\n+  htab_t decl_address;\n+  bool changed;\n+};\n+\n+static tree\n+eliminate_local_variables_1 (tree *tp, int *walk_subtrees, void *data)\n+{\n+  struct elv_data *dta = data;\n+  tree t = *tp, var, addr, addr_type, type;\n+\n+  if (DECL_P (t))\n+    {\n+      *walk_subtrees = 0;\n+\n+      if (!SSA_VAR_P (t) || DECL_EXTERNAL (t))\n+\treturn NULL_TREE;\n+\n+      type = TREE_TYPE (t);\n+      addr_type = build_pointer_type (type);\n+      addr = take_address_of (t, addr_type, dta->loop, dta->decl_address);\n+      *tp = build1 (INDIRECT_REF, TREE_TYPE (*tp), addr);\n+\n+      dta->changed = true;\n+      return NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (t) == ADDR_EXPR)\n+    {\n+      var = TREE_OPERAND (t, 0);\n+      if (!DECL_P (var))\n+\treturn NULL_TREE;\n+\n+      *walk_subtrees = 0;\n+      if (!SSA_VAR_P (var) || DECL_EXTERNAL (var))\n+\treturn NULL_TREE;\n+\n+      addr_type = TREE_TYPE (t);\n+      addr = take_address_of (var, addr_type, dta->loop, dta->decl_address);\n+      *tp = addr;\n+\n+      dta->changed = true;\n+      return NULL_TREE;\n+    }\n+\n+  if (!EXPR_P (t)\n+      && !GIMPLE_STMT_P (t))\n+    *walk_subtrees = 0;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Moves the references to local variables in STMT from LOOP.  DECL_ADDRESS\n+   contains addresses for the references for that we have already taken\n+   them.  */\n+\n+static void\n+eliminate_local_variables_stmt (struct loop *loop, tree stmt,\n+\t\t\t\thtab_t decl_address)\n+{\n+  struct elv_data dta;\n+\n+  dta.loop = loop;\n+  dta.decl_address = decl_address;\n+  dta.changed = false;\n+\n+  walk_tree (&stmt, eliminate_local_variables_1, &dta, NULL);\n+\n+  if (dta.changed)\n+    update_stmt (stmt);\n+}\n+\n+/* Eliminates the references to local variables from LOOP.  This includes:\n+\n+   1) Taking address of a local variable -- these are moved out of the loop\n+      (and temporary variable is created to hold the address if necessary).\n+   2) Dereferencing a local variable -- these are replaced with indirect\n+      references.  */\n+\n+static void\n+eliminate_local_variables (struct loop *loop)\n+{\n+  basic_block bb, *body = get_loop_body (loop);\n+  unsigned i;\n+  block_stmt_iterator bsi;\n+  htab_t decl_address = htab_create (10, int_tree_map_hash, int_tree_map_eq,\n+\t\t\t\t     free);\n+\n+  /* Find and rename the ssa names defined outside of loop.  */\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      bb = body[i];\n+\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\teliminate_local_variables_stmt (loop, bsi_stmt (bsi), decl_address);\n+    }\n+\n+  htab_delete (decl_address);\n+}\n+\n+/* If COPY_NAME_P is true, creates and returns a duplicate of NAME.\n+   The copies are stored to NAME_COPIES, if NAME was already duplicated,\n+   its duplicate stored in NAME_COPIES is returned.\n+   \n+   Regardless of COPY_NAME_P, the decl used as a base of the ssa name is also\n+   duplicated, storing the copies in DECL_COPIES.  */\n+\n+static tree\n+separate_decls_in_loop_name (tree name,\n+\t\t\t     htab_t name_copies, htab_t decl_copies,\n+\t\t\t     bool copy_name_p)\n+{\n+  tree copy, var, var_copy;\n+  unsigned idx, uid, nuid;\n+  struct int_tree_map ielt, *nielt;\n+  struct name_to_copy_elt elt, *nelt;\n+  void **slot, **dslot;\n+\n+  if (TREE_CODE (name) != SSA_NAME)\n+    return name;\n+\n+  idx = SSA_NAME_VERSION (name);\n+  elt.version = idx;\n+  slot = htab_find_slot_with_hash (name_copies, &elt, idx,\n+\t\t\t\t   copy_name_p ? INSERT : NO_INSERT);\n+  if (slot && *slot)\n+    return ((struct name_to_copy_elt *) *slot)->new_name;\n+\n+  var = SSA_NAME_VAR (name);\n+  uid = DECL_UID (var);\n+  ielt.uid = uid;\n+  dslot = htab_find_slot_with_hash (decl_copies, &ielt, uid, INSERT);\n+  if (!*dslot)\n+    {\n+      var_copy = create_tmp_var (TREE_TYPE (var), get_name (var));\n+      add_referenced_var (var_copy);\n+      nielt = XNEW (struct int_tree_map);\n+      nielt->uid = uid;\n+      nielt->to = var_copy;\n+      *dslot = nielt;\n+\n+      /* Ensure that when we meet this decl next time, we won't duplicate\n+\t it again.  */\n+      nuid = DECL_UID (var_copy);\n+      ielt.uid = nuid;\n+      dslot = htab_find_slot_with_hash (decl_copies, &ielt, nuid, INSERT);\n+      gcc_assert (!*dslot);\n+      nielt = XNEW (struct int_tree_map);\n+      nielt->uid = nuid;\n+      nielt->to = var_copy;\n+      *dslot = nielt;\n+    }\n+  else\n+    var_copy = ((struct int_tree_map *) *dslot)->to;\n+\n+  if (copy_name_p)\n+    {\n+      copy = duplicate_ssa_name (name, NULL_TREE);\n+      nelt = XNEW (struct name_to_copy_elt);\n+      nelt->version = idx;\n+      nelt->new_name = copy;\n+      nelt->field = NULL_TREE;\n+      *slot = nelt;\n+    }\n+  else\n+    {\n+      gcc_assert (!slot);\n+      copy = name;\n+    }\n+\n+  SSA_NAME_VAR (copy) = var_copy;\n+  return copy;\n+}\n+\n+/* Finds the ssa names used in STMT that are defined outside of LOOP and\n+   replaces such ssa names with their duplicates.  The duplicates are stored to\n+   NAME_COPIES.  Base decls of all ssa names used in STMT\n+   (including those defined in LOOP) are replaced with the new temporary\n+   variables; the replacement decls are stored in DECL_COPIES.  */\n+\n+static void\n+separate_decls_in_loop_stmt (struct loop *loop, tree stmt,\n+\t\t\t     htab_t name_copies, htab_t decl_copies)\n+{\n+  use_operand_p use;\n+  def_operand_p def;\n+  ssa_op_iter oi;\n+  tree name, copy;\n+  bool copy_name_p;\n+\n+  mark_virtual_ops_for_renaming (stmt);\n+\n+  FOR_EACH_PHI_OR_STMT_DEF (def, stmt, oi, SSA_OP_DEF)\n+    {\n+      name = DEF_FROM_PTR (def);\n+      gcc_assert (TREE_CODE (name) == SSA_NAME);\n+      copy = separate_decls_in_loop_name (name, name_copies, decl_copies,\n+\t\t\t\t\t  false);\n+      gcc_assert (copy == name);\n+    }\n+\n+  FOR_EACH_PHI_OR_STMT_USE (use, stmt, oi, SSA_OP_USE)\n+    {\n+      name = USE_FROM_PTR (use);\n+      if (TREE_CODE (name) != SSA_NAME)\n+\tcontinue;\n+\n+      copy_name_p = expr_invariant_in_loop_p (loop, name);\n+      copy = separate_decls_in_loop_name (name, name_copies, decl_copies,\n+\t\t\t\t\t  copy_name_p);\n+      SET_USE (use, copy);\n+    }\n+}\n+\n+/* Callback for htab_traverse.  Adds a field corresponding to a ssa name\n+   described in SLOT to the type passed in DATA.  */\n+\n+static int\n+add_field_for_name (void **slot, void *data)\n+{\n+  struct name_to_copy_elt *elt = *slot;\n+  tree type = data;\n+  tree name = ssa_name (elt->version);\n+  tree var = SSA_NAME_VAR (name);\n+  tree field = build_decl (FIELD_DECL, DECL_NAME (var), TREE_TYPE (var));\n+\n+  insert_field_into_struct (type, field);\n+  elt->field = field;\n+  return 1;\n+}\n+\n+/* Callback for htab_traverse.  Creates loads to a field of LOAD in LOAD_BB and\n+   store to a field of STORE in STORE_BB for the ssa name and its duplicate\n+   specified in SLOT.  */\n+\n+struct clsn_data\n+{\n+  tree store;\n+  tree load;\n+\n+  basic_block store_bb;\n+  basic_block load_bb;\n+};\n+\n+static int\n+create_loads_and_stores_for_name (void **slot, void *data)\n+{\n+  struct name_to_copy_elt *elt = *slot;\n+  struct clsn_data *clsn_data = data;\n+  tree stmt;\n+  block_stmt_iterator bsi;\n+  tree type = TREE_TYPE (elt->new_name);\n+  tree struct_type = TREE_TYPE (TREE_TYPE (clsn_data->load));\n+  tree load_struct;\n+\n+  bsi = bsi_last (clsn_data->store_bb);\n+  stmt = build_gimple_modify_stmt (\n+\t\t build3 (COMPONENT_REF, type, clsn_data->store, elt->field,\n+\t\t\t NULL_TREE),\n+\t\t ssa_name (elt->version));\n+  mark_virtual_ops_for_renaming (stmt);\n+  bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n+\n+  bsi = bsi_last (clsn_data->load_bb);\n+  load_struct = fold_build1 (INDIRECT_REF, struct_type, clsn_data->load);\n+  stmt = build_gimple_modify_stmt (\n+\t\t elt->new_name,\n+\t\t build3 (COMPONENT_REF, type, load_struct, elt->field,\n+\t\t\t NULL_TREE));\n+  SSA_NAME_DEF_STMT (elt->new_name) = stmt;\n+  bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n+\n+  return 1;\n+}\n+\n+/* Moves all the variables used in LOOP and defined outside of it (including\n+   the initial values of loop phi nodes, and *PER_THREAD if it is a ssa\n+   name) to a structure created for this purpose.  The code\n+ \n+   while (1)\n+     {\n+       use (a);\n+       use (b);\n+     }\n+\n+   is transformed this way:\n+\n+   bb0:\n+   old.a = a;\n+   old.b = b;\n+\n+   bb1:\n+   a' = new->a;\n+   b' = new->b;\n+   while (1)\n+     {\n+       use (a');\n+       use (b');\n+     }\n+\n+   `old' is stored to *ARG_STRUCT and `new' is stored to NEW_ARG_STRUCT.  The\n+   pointer `new' is intentionally not initialized (the loop will be split to a\n+   separate function later, and `new' will be initialized from its arguments).\n+   */\n+\n+static void\n+separate_decls_in_loop (struct loop *loop, tree *arg_struct,\n+\t\t\ttree *new_arg_struct)\n+{\n+  basic_block bb1 = split_edge (loop_preheader_edge (loop));\n+  basic_block bb0 = single_pred (bb1);\n+  htab_t name_copies = htab_create (10, name_to_copy_elt_hash,\n+\t\t\t\t    name_to_copy_elt_eq, free);\n+  htab_t decl_copies = htab_create (10, int_tree_map_hash, int_tree_map_eq,\n+\t\t\t\t    free);\n+  basic_block bb, *body = get_loop_body (loop);\n+  unsigned i;\n+  tree phi, type, type_name, nvar;\n+  block_stmt_iterator bsi;\n+  struct clsn_data clsn_data;\n+\n+  /* Find and rename the ssa names defined outside of loop.  */\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      bb = body[i];\n+\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\tseparate_decls_in_loop_stmt (loop, phi, name_copies, decl_copies);\n+\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\tseparate_decls_in_loop_stmt (loop, bsi_stmt (bsi), name_copies,\n+\t\t\t\t     decl_copies);\n+    }\n+  free (body);\n+\n+  if (htab_elements (name_copies) == 0)\n+    {\n+      /* It may happen that there is nothing to copy (if there are only\n+\t loop carried and external variables in the loop).  */\n+      *arg_struct = NULL;\n+      *new_arg_struct = NULL;\n+    }\n+  else\n+    {\n+      /* Create the type for the structure to store the ssa names to.  */\n+      type = lang_hooks.types.make_type (RECORD_TYPE);\n+      type_name = build_decl (TYPE_DECL, create_tmp_var_name (\".paral_data\"),\n+\t\t\t      type);\n+      TYPE_NAME (type) = type_name;\n+\n+      htab_traverse (name_copies, add_field_for_name, type);\n+      layout_type (type);\n+\n+      /* Create the loads and stores.  */\n+      *arg_struct = create_tmp_var (type, \".paral_data_store\");\n+      add_referenced_var (*arg_struct);\n+      nvar = create_tmp_var (build_pointer_type (type), \".paral_data_load\");\n+      add_referenced_var (nvar);\n+      *new_arg_struct = make_ssa_name (nvar, NULL_TREE);\n+\n+      clsn_data.store = *arg_struct;\n+      clsn_data.load = *new_arg_struct;\n+      clsn_data.store_bb = bb0;\n+      clsn_data.load_bb = bb1;\n+      htab_traverse (name_copies, create_loads_and_stores_for_name,\n+\t\t     &clsn_data);\n+    }\n+\n+  htab_delete (decl_copies);\n+  htab_delete (name_copies);\n+}\n+\n+/* Bitmap containing uids of functions created by parallelization.  We cannot\n+   allocate it from the default obstack, as it must live across compilation\n+   of several functions; we make it gc allocated instead.  */\n+\n+static GTY(()) bitmap parallelized_functions;\n+\n+/* Returns true if FN was created by create_loop_fn.  */\n+\n+static bool\n+parallelized_function_p (tree fn)\n+{\n+  if (!parallelized_functions || !DECL_ARTIFICIAL (fn))\n+    return false;\n+\n+  return bitmap_bit_p (parallelized_functions, DECL_UID (fn));\n+}\n+\n+/* Creates and returns an empty function that will receive the body of\n+   a parallelized loop.  */\n+\n+static tree\n+create_loop_fn (void)\n+{\n+  char buf[100];\n+  char *tname;\n+  tree decl, type, name, t;\n+  struct function *act_cfun = cfun;\n+  static unsigned loopfn_num;\n+\n+  snprintf (buf, 100, \"%s.$loopfn\", current_function_name ());\n+  ASM_FORMAT_PRIVATE_NAME (tname, buf, loopfn_num++);\n+  clean_symbol_name (tname);\n+  name = get_identifier (tname);\n+  type = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n+\n+  decl = build_decl (FUNCTION_DECL, name, type);\n+  if (!parallelized_functions)\n+    parallelized_functions = BITMAP_GGC_ALLOC ();\n+  bitmap_set_bit (parallelized_functions, DECL_UID (decl));\n+\n+  TREE_STATIC (decl) = 1;\n+  TREE_USED (decl) = 1;\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_IGNORED_P (decl) = 0;\n+  TREE_PUBLIC (decl) = 0;\n+  DECL_UNINLINABLE (decl) = 1;\n+  DECL_EXTERNAL (decl) = 0;\n+  DECL_CONTEXT (decl) = NULL_TREE;\n+  DECL_INITIAL (decl) = make_node (BLOCK);\n+\n+  t = build_decl (RESULT_DECL, NULL_TREE, void_type_node);\n+  DECL_ARTIFICIAL (t) = 1;\n+  DECL_IGNORED_P (t) = 1;\n+  DECL_RESULT (decl) = t;\n+\n+  t = build_decl (PARM_DECL, get_identifier (\".paral_data_param\"),\n+\t\t  ptr_type_node);\n+  DECL_ARTIFICIAL (t) = 1;\n+  DECL_ARG_TYPE (t) = ptr_type_node;\n+  DECL_CONTEXT (t) = decl;\n+  TREE_USED (t) = 1;\n+  DECL_ARGUMENTS (decl) = t;\n+\n+  allocate_struct_function (decl);\n+\n+  /* The call to allocate_struct_function clobbers CFUN, so we need to restore\n+     it.  */\n+  cfun = act_cfun;\n+\n+  return decl;\n+}\n+\n+/* Bases all the induction variables in LOOP on a single induction variable\n+   (unsigned with base 0 and step 1), whose final value is compared with\n+   NIT.  The induction variable is incremented in the loop latch.  */\n+\n+static void\n+canonicalize_loop_ivs (struct loop *loop, tree nit)\n+{\n+  unsigned precision = TYPE_PRECISION (TREE_TYPE (nit));\n+  tree phi, prev, res, type, var_before, val, atype, t, next;\n+  block_stmt_iterator bsi;\n+  bool ok;\n+  affine_iv iv;\n+  edge exit = single_dom_exit (loop);\n+\n+  for (phi = phi_nodes (loop->header); phi; phi = PHI_CHAIN (phi))\n+    {\n+      res = PHI_RESULT (phi);\n+\n+      if (is_gimple_reg (res)\n+\t  && TYPE_PRECISION (TREE_TYPE (res)) > precision)\n+\tprecision = TYPE_PRECISION (TREE_TYPE (res));\n+    }\n+\n+  type = lang_hooks.types.type_for_size (precision, 1);\n+\n+  bsi = bsi_last (loop->latch);\n+  create_iv (build_int_cst_type (type, 0), build_int_cst (type, 1), NULL_TREE,\n+\t     loop, &bsi, true, &var_before, NULL);\n+\n+  bsi = bsi_after_labels (loop->header);\n+  prev = NULL;\n+  for (phi = phi_nodes (loop->header); phi; phi = next)\n+    {\n+      next = PHI_CHAIN (phi);\n+      res = PHI_RESULT (phi);\n+\n+      if (!is_gimple_reg (res)\n+\t  || res == var_before)\n+\t{\n+\t  prev = phi;\n+\t  continue;\n+\t}\n+      \n+      ok = simple_iv (loop, phi, res, &iv, true);\n+      gcc_assert (ok);\n+\n+      remove_phi_node (phi, prev, false);\n+\n+      atype = TREE_TYPE (res);\n+      val = fold_build2 (PLUS_EXPR, atype,\n+\t\t\t unshare_expr (iv.base),\n+\t\t\t fold_build2 (MULT_EXPR, atype,\n+\t\t\t\t      unshare_expr (iv.step),\n+\t\t\t\t      fold_convert (atype, var_before)));\n+      val = force_gimple_operand_bsi (&bsi, val, false, NULL_TREE, true,\n+\t\t\t\t      BSI_SAME_STMT);\n+      t = build_gimple_modify_stmt (res, val);\n+      bsi_insert_before (&bsi, t, BSI_SAME_STMT);\n+      SSA_NAME_DEF_STMT (res) = t;\n+    }\n+\n+  t = last_stmt (exit->src);\n+  /* Make the loop exit if the control condition is not satisfied.  */\n+  if (exit->flags & EDGE_TRUE_VALUE)\n+    {\n+      edge te, fe;\n+\n+      extract_true_false_edges_from_block (exit->src, &te, &fe);\n+      te->flags = EDGE_FALSE_VALUE;\n+      fe->flags = EDGE_TRUE_VALUE;\n+    }\n+  COND_EXPR_COND (t) = build2 (LT_EXPR, boolean_type_node, var_before, nit);\n+}\n+\n+/* Moves the exit condition of LOOP to the beginning of its header, and\n+   duplicates the part of the last iteration that gets disabled to the\n+   exit of the loop.  NIT is the number of iterations of the loop\n+   (used to initialize the variables in the duplicated part).\n+ \n+   TODO: the common case is that latch of the loop is empty and immediatelly\n+   follows the loop exit.  In this case, it would be better not to copy the\n+   body of the loop, but only move the entry of the loop directly before the\n+   exit check and increase the number of iterations of the loop by one.\n+   This may need some additional preconditioning in case NIT = ~0.  */\n+\n+static void\n+transform_to_exit_first_loop (struct loop *loop, tree nit)\n+{\n+  basic_block *bbs, *nbbs, ex_bb, orig_header;\n+  unsigned n;\n+  bool ok;\n+  edge exit = single_dom_exit (loop), hpred;\n+  tree phi, nphi, cond, control, control_name, res, t, cond_stmt;\n+  block_stmt_iterator bsi;\n+\n+  split_block_after_labels (loop->header);\n+  orig_header = single_succ (loop->header);\n+  hpred = single_succ_edge (loop->header);\n+\n+  cond_stmt = last_stmt (exit->src);\n+  cond = COND_EXPR_COND (cond_stmt);\n+  control = TREE_OPERAND (cond, 0);\n+  gcc_assert (TREE_OPERAND (cond, 1) == nit);\n+\n+  /* Make sure that we have phi nodes on exit for all loop header phis\n+     (create_parallel_loop requires that).  */\n+  for (phi = phi_nodes (loop->header); phi; phi = PHI_CHAIN (phi))\n+    {\n+      res = PHI_RESULT (phi);\n+      t = make_ssa_name (SSA_NAME_VAR (res), phi);\n+      SET_PHI_RESULT (phi, t);\n+\n+      nphi = create_phi_node (res, orig_header);\n+      SSA_NAME_DEF_STMT (res) = nphi;\n+      add_phi_arg (nphi, t, hpred);\n+\n+      if (res == control)\n+\t{\n+\t  TREE_OPERAND (cond, 0) = t;\n+\t  update_stmt (cond_stmt);\n+\t  control = t;\n+\t}\n+    }\n+\n+  bbs = get_loop_body_in_dom_order (loop);\n+  for (n = 0; bbs[n] != exit->src; n++)\n+    continue;\n+  nbbs = XNEWVEC (basic_block, n);\n+  ok = tree_duplicate_sese_tail (single_succ_edge (loop->header), exit,\n+\t\t\t\t bbs + 1, n, nbbs);\n+  gcc_assert (ok);\n+  free (bbs);\n+  ex_bb = nbbs[0];\n+  free (nbbs);\n+\n+  /* The only gimple reg that should be copied out of the loop is the\n+     control variable.  */\n+  control_name = NULL_TREE;\n+  for (phi = phi_nodes (ex_bb); phi; phi = PHI_CHAIN (phi))\n+    {\n+      res = PHI_RESULT (phi);\n+      if (!is_gimple_reg (res))\n+\tcontinue;\n+\n+      gcc_assert (control_name == NULL_TREE\n+\t\t  && SSA_NAME_VAR (res) == SSA_NAME_VAR (control));\n+      control_name = res;\n+    }\n+  gcc_assert (control_name != NULL_TREE);\n+  phi = SSA_NAME_DEF_STMT (control_name);\n+  remove_phi_node (phi, NULL_TREE, false);\n+\n+  /* Initialize the control variable to NIT.  */\n+  bsi = bsi_after_labels (ex_bb);\n+  t = build_gimple_modify_stmt (control_name, nit);\n+  bsi_insert_before (&bsi, t, BSI_NEW_STMT);\n+  SSA_NAME_DEF_STMT (control_name) = t;\n+}\n+\n+/* Create the parallel constructs for LOOP as described in gen_parallel_loop.\n+   LOOP_FN and DATA are the arguments of OMP_PARALLEL.\n+   NEW_DATA is the variable that should be initialized from the argument\n+   of LOOP_FN.  N_THREADS is the requested number of threads.  Returns the\n+   basic block containing OMP_PARALLEL tree.  */\n+\n+static basic_block\n+create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n+\t\t      tree new_data, unsigned n_threads)\n+{\n+  block_stmt_iterator bsi;\n+  basic_block bb, paral_bb, for_bb, ex_bb;\n+  tree t, param, res, for_stmt;\n+  tree cvar, cvar_init, initvar, cvar_next, cvar_base, cond, phi, type;\n+  edge exit, nexit, guard, end, e;\n+\n+  /* Prepare the OMP_PARALLEL statement.  */\n+  bb = loop_preheader_edge (loop)->src;\n+  paral_bb = single_pred (bb);\n+  bsi = bsi_last (paral_bb);\n+\n+  t = build_omp_clause (OMP_CLAUSE_NUM_THREADS);\n+  OMP_CLAUSE_NUM_THREADS_EXPR (t)\n+\t  = build_int_cst (integer_type_node, n_threads);\n+  t = build4 (OMP_PARALLEL, void_type_node, NULL_TREE, t,\n+\t      loop_fn, data);\n+\n+  bsi_insert_after (&bsi, t, BSI_NEW_STMT);\n+\n+  /* Initialize NEW_DATA.  */\n+  if (data)\n+    {\n+      bsi = bsi_after_labels (bb);\n+\n+      param = make_ssa_name (DECL_ARGUMENTS (loop_fn), NULL_TREE);\n+      t = build_gimple_modify_stmt (param, build_fold_addr_expr (data));\n+      bsi_insert_before (&bsi, t, BSI_SAME_STMT);\n+      SSA_NAME_DEF_STMT (param) = t;\n+\n+      t = build_gimple_modify_stmt (new_data,\n+\t\t  fold_convert (TREE_TYPE (new_data), param));\n+      bsi_insert_before (&bsi, t, BSI_SAME_STMT);\n+      SSA_NAME_DEF_STMT (new_data) = t;\n+    }\n+\n+  /* Emit OMP_RETURN for OMP_PARALLEL.  */\n+  bb = split_loop_exit_edge (single_dom_exit (loop));\n+  bsi = bsi_last (bb);\n+  bsi_insert_after (&bsi, make_node (OMP_RETURN), BSI_NEW_STMT);\n+\n+  /* Extract data for OMP_FOR.  */\n+  gcc_assert (loop->header == single_dom_exit (loop)->src);\n+  cond = COND_EXPR_COND (last_stmt (loop->header));\n+\n+  cvar = TREE_OPERAND (cond, 0);\n+  cvar_base = SSA_NAME_VAR (cvar);\n+  phi = SSA_NAME_DEF_STMT (cvar);\n+  cvar_init = PHI_ARG_DEF_FROM_EDGE (phi, loop_preheader_edge (loop));\n+  initvar = make_ssa_name (cvar_base, NULL_TREE);\n+  SET_USE (PHI_ARG_DEF_PTR_FROM_EDGE (phi, loop_preheader_edge (loop)),\n+\t   initvar);\n+  cvar_next = PHI_ARG_DEF_FROM_EDGE (phi, loop_latch_edge (loop));\n+\n+  bsi = bsi_last (loop->latch);\n+  gcc_assert (bsi_stmt (bsi) == SSA_NAME_DEF_STMT (cvar_next));\n+  bsi_remove (&bsi, true);\n+\n+  /* Prepare cfg.  */\n+  for_bb = split_edge (loop_preheader_edge (loop));\n+  ex_bb = split_loop_exit_edge (single_dom_exit (loop));\n+  extract_true_false_edges_from_block (loop->header, &nexit, &exit);\n+  gcc_assert (exit == single_dom_exit (loop));\n+\n+  guard = make_edge (for_bb, ex_bb, 0);\n+  single_succ_edge (loop->latch)->flags = 0;\n+  end = make_edge (loop->latch, ex_bb, EDGE_FALLTHRU);\n+  for (phi = phi_nodes (ex_bb); phi; phi = PHI_CHAIN (phi))\n+    {\n+      res = PHI_RESULT (phi);\n+      gcc_assert (!is_gimple_reg (phi));\n+      t = SSA_NAME_DEF_STMT (PHI_ARG_DEF_FROM_EDGE (phi, exit));\n+      add_phi_arg (phi, PHI_ARG_DEF_FROM_EDGE (t, loop_preheader_edge (loop)),\n+\t\t   guard);\n+      add_phi_arg (phi, PHI_ARG_DEF_FROM_EDGE (t, loop_latch_edge (loop)),\n+\t\t   end);\n+    }\n+  e = redirect_edge_and_branch (exit, nexit->dest);\n+  PENDING_STMT (e) = NULL;\n+\n+  /* Emit OMP_FOR.  */\n+  TREE_OPERAND (cond, 0) = cvar_base;\n+  type = TREE_TYPE (cvar);\n+  t = build_omp_clause (OMP_CLAUSE_SCHEDULE);\n+  OMP_CLAUSE_SCHEDULE_KIND (t) = OMP_CLAUSE_SCHEDULE_STATIC;\n+\n+  for_stmt = make_node (OMP_FOR);\n+  TREE_TYPE (for_stmt) = void_type_node;\n+  OMP_FOR_CLAUSES (for_stmt) = t;\n+  OMP_FOR_INIT (for_stmt) = build_gimple_modify_stmt (initvar, cvar_init);\n+  OMP_FOR_COND (for_stmt) = cond;\n+  OMP_FOR_INCR (for_stmt) = build_gimple_modify_stmt (\n+\t\t\t\tcvar_base,\n+\t\t\t\tbuild2 (PLUS_EXPR, type,\n+\t\t\t\t\tcvar_base,\n+\t\t\t\t\tbuild_int_cst (type, 1)));\n+  OMP_FOR_BODY (for_stmt) = NULL_TREE;\n+  OMP_FOR_PRE_BODY (for_stmt) = NULL_TREE;\n+\n+  bsi = bsi_last (for_bb);\n+  bsi_insert_after (&bsi, for_stmt, BSI_NEW_STMT);\n+  SSA_NAME_DEF_STMT (initvar) = for_stmt;\n+\n+  /* Emit OMP_CONTINUE.  */\n+  bsi = bsi_last (loop->latch);\n+  t = build2 (OMP_CONTINUE, void_type_node, cvar_next, cvar);\n+  bsi_insert_after (&bsi, t, BSI_NEW_STMT);\n+  SSA_NAME_DEF_STMT (cvar_next) = t;\n+\n+  /* Emit OMP_RETURN for OMP_FOR.  */\n+  bsi = bsi_last (ex_bb);\n+  bsi_insert_after (&bsi, make_node (OMP_RETURN), BSI_NEW_STMT);\n+\n+  return paral_bb;\n+}\n+\n+/* Generates code to execute the iterations of LOOP in N_THREADS threads in\n+   parallel.  NITER describes number of iterations of LOOP.  */\n+\n+static void\n+gen_parallel_loop (struct loop *loop, unsigned n_threads,\n+\t\t   struct tree_niter_desc *niter)\n+{\n+  struct loop *nloop;\n+  tree many_iterations_cond, type, nit;\n+  tree stmts, arg_struct, new_arg_struct;\n+  basic_block parallel_head;\n+  unsigned prob;\n+\n+  /* From\n+\n+     ---------------------------------------------------------------------\n+     loop\n+       {\n+\t IV = phi (INIT, IV + STEP)\n+\t BODY1;\n+\t if (COND)\n+\t   break;\n+\t BODY2;\n+       }\n+     ---------------------------------------------------------------------\n+\n+     with # of iterations NITER (possibly with MAY_BE_ZERO assumption),\n+     we generate the following code:\n+\n+     ---------------------------------------------------------------------\n+\n+     if (MAY_BE_ZERO\n+\t || NITER < MIN_PER_THREAD * N_THREADS)\n+       goto original;\n+\n+     BODY1;\n+     store all local loop-invariant variables used in body of the loop to DATA.\n+     OMP_PARALLEL (OMP_CLAUSE_NUM_THREADS (N_THREADS), LOOPFN, DATA);\n+     load the variables from DATA.\n+     OMP_FOR (IV = INIT; COND; IV += STEP) (OMP_CLAUSE_SCHEDULE (static))\n+     BODY2;\n+     BODY1;\n+     OMP_CONTINUE;\n+     OMP_RETURN\t\t-- OMP_FOR\n+     OMP_RETURN\t\t-- OMP_PARALLEL\n+     goto end;\n+\n+     original:\n+     loop\n+       {\n+\t IV = phi (INIT, IV + STEP)\n+\t BODY1;\n+\t if (COND)\n+\t   break;\n+\t BODY2;\n+       }\n+\n+     end:\n+\n+   */\n+\n+  /* Create two versions of the loop -- in the old one, we know that the\n+     number of iterations is large enough, and we will transform it into the\n+     loop that will be split to loop_fn, the new one will be used for the\n+     remaining iterations.  */\n+  \n+  type = TREE_TYPE (niter->niter);\n+  nit = force_gimple_operand (unshare_expr (niter->niter), &stmts, true,\n+\t\t\t      NULL_TREE);\n+  if (stmts)\n+    bsi_insert_on_edge_immediate (loop_preheader_edge (loop), stmts);\n+\n+  many_iterations_cond =\n+\t  fold_build2 (GE_EXPR, boolean_type_node,\n+\t\t       nit, build_int_cst (type, MIN_PER_THREAD * n_threads));\n+  many_iterations_cond\n+\t  = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t invert_truthvalue (unshare_expr (niter->may_be_zero)),\n+\t\t\t many_iterations_cond);\n+  many_iterations_cond\n+\t  = force_gimple_operand (many_iterations_cond, &stmts,\n+\t\t\t\t  false, NULL_TREE);\n+  if (stmts)\n+    bsi_insert_on_edge_immediate (loop_preheader_edge (loop), stmts);\n+  if (!is_gimple_condexpr (many_iterations_cond))\n+    {\n+      many_iterations_cond\n+\t      = force_gimple_operand (many_iterations_cond, &stmts,\n+\t\t\t\t      true, NULL_TREE);\n+      if (stmts)\n+\tbsi_insert_on_edge_immediate (loop_preheader_edge (loop), stmts);\n+    }\n+\n+  initialize_original_copy_tables ();\n+\n+  /* We assume that the loop usually iterates a lot.  */\n+  prob = 4 * REG_BR_PROB_BASE / 5;\n+  nloop = loop_version (loop, many_iterations_cond, NULL,\n+\t\t\tprob, prob, REG_BR_PROB_BASE - prob, true);\n+  update_ssa (TODO_update_ssa);\n+  free_original_copy_tables ();\n+\n+  /* Base all the induction variables in LOOP on a single control one.  */\n+  canonicalize_loop_ivs (loop, nit);\n+\n+  /* Ensure that the exit condition is the first statement in the loop.  */\n+  transform_to_exit_first_loop (loop, nit);\n+\n+  /* Eliminate the references to local variables from the loop.  */\n+  eliminate_local_variables (loop);\n+\n+  /* In the old loop, move all variables non-local to the loop to a structure\n+     and back, and create separate decls for the variables used in loop.  */\n+  separate_decls_in_loop (loop, &arg_struct, &new_arg_struct);\n+\n+  /* Create the parallel constructs.  */\n+  parallel_head = create_parallel_loop (loop, create_loop_fn (), arg_struct,\n+\t\t\t\t\tnew_arg_struct, n_threads);\n+\n+  scev_reset ();\n+\n+  /* Cancel the loop (it is simpler to do it here rather than to teach the\n+     expander to do it).  */\n+  cancel_loop_tree (loop);\n+\n+  /* Expand the parallel constructs.  We do it directly here instead of running\n+     a separate expand_omp pass, since it is more efficient, and less likely to\n+     cause troubles with further analyses not being able to deal with the\n+     OMP trees.  */\n+  omp_expand_local (parallel_head);\n+}\n+\n+/* Detect parallel loops and generate parallel code using libgomp\n+   primitives.  Returns true if some loop was parallelized, false\n+   otherwise.  */\n+\n+bool\n+parallelize_loops (void)\n+{\n+  unsigned n_threads = flag_tree_parallelize_loops;\n+  bool changed = false;\n+  struct loop *loop;\n+  struct tree_niter_desc niter_desc;\n+  loop_iterator li;\n+\n+  /* Do not parallelize loops in the functions created by parallelization.  */\n+  if (parallelized_function_p (cfun->decl))\n+    return false;\n+\n+  FOR_EACH_LOOP (li, loop, 0)\n+    {\n+      if (/* Do not bother with loops in cold areas.  */\n+\t  !maybe_hot_bb_p (loop->header)\n+\t  /* Or loops that roll too little.  */\n+\t  || expected_loop_iterations (loop) <= n_threads\n+\t  /* And of course, the loop must be parallelizable.  */\n+\t  || !can_duplicate_loop_p (loop)\n+\t  || !loop_parallel_p (loop, &niter_desc))\n+\tcontinue;\n+\n+      changed = true;\n+      gen_parallel_loop (loop, n_threads, &niter_desc);\n+      verify_flow_info ();\n+      verify_dominators (CDI_DOMINATORS);\n+      verify_loop_structure ();\n+      verify_loop_closed_ssa ();\n+    }\n+\n+  return changed;\n+}\n+\n+#include \"gt-tree-parloops.h\""}, {"sha": "b19d3d059317843434bdc4a19edd39b4f9d1dd7a", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -268,6 +268,7 @@ extern struct tree_opt_pass pass_record_bounds;\n extern struct tree_opt_pass pass_if_conversion;\n extern struct tree_opt_pass pass_vectorize;\n extern struct tree_opt_pass pass_complete_unroll;\n+extern struct tree_opt_pass pass_parallelize_loops;\n extern struct tree_opt_pass pass_loop_prefetch;\n extern struct tree_opt_pass pass_iv_optimize;\n extern struct tree_opt_pass pass_tree_loop_done;"}, {"sha": "91aac3eb354410985e1e61f701031cf28e3e49ad", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -454,9 +454,9 @@ verify_loop_closed_ssa (void)\n }\n \n /* Split loop exit edge EXIT.  The things are a bit complicated by a need to\n-   preserve the loop closed ssa form.  */\n+   preserve the loop closed ssa form.  The newly created block is returned.  */\n \n-void\n+basic_block\n split_loop_exit_edge (edge exit)\n {\n   basic_block dest = exit->dest;\n@@ -483,6 +483,8 @@ split_loop_exit_edge (edge exit)\n       add_phi_arg (new_phi, name, exit);\n       SET_USE (op_p, new_name);\n     }\n+\n+  return bb;\n }\n \n /* Returns the basic block in that statements should be emitted for induction"}, {"sha": "240058a739ed9b1e95f6aeef9e9dc99995d5df44", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -468,6 +468,42 @@ struct tree_opt_pass pass_complete_unroll =\n   0\t\t\t\t\t/* letter */\n };\n \n+/* Parallelization.  */\n+\n+static bool\n+gate_tree_parallelize_loops (void)\n+{\n+  return flag_tree_parallelize_loops != 1;\n+}\n+\n+static unsigned\n+tree_parallelize_loops (void)\n+{\n+  if (number_of_loops () <= 1)\n+    return 0;\n+\n+  if (parallelize_loops ())\n+    return TODO_cleanup_cfg | TODO_rebuild_alias;\n+  return 0;\n+}\n+\n+struct tree_opt_pass pass_parallelize_loops =\n+{\n+  \"parloops\",\t\t\t\t/* name */\n+  gate_tree_parallelize_loops,\t\t/* gate */\n+  tree_parallelize_loops,      \t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_TREE_PARALLELIZE_LOOPS,  \t\t/* tv_id */\n+  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_verify_loops,\t/* todo_flags_finish */\n+  0\t\t\t\t        /* letter */\t\n+};\n+\n /* Prefetching.  */\n \n static unsigned int"}, {"sha": "3a944efa0b364f886d7fbfa920acc507e413070d", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -2450,6 +2450,56 @@ build_ssa_operands (tree stmt)\n     ann->references_memory = true;\n }\n \n+/* Releases the operands of STMT back to their freelists, and clears\n+   the stmt operand lists.  */\n+\n+void\n+free_stmt_operands (tree stmt)\n+{\n+  def_optype_p defs = DEF_OPS (stmt), last_def;\n+  use_optype_p uses = USE_OPS (stmt), last_use;\n+  voptype_p vuses = VUSE_OPS (stmt);\n+  voptype_p vdefs = VDEF_OPS (stmt), vdef, next_vdef;\n+  unsigned i;\n+\n+  if (defs)\n+    {\n+      for (last_def = defs; last_def->next; last_def = last_def->next)\n+\tcontinue;\n+      last_def->next = gimple_ssa_operands (cfun)->free_defs;\n+      gimple_ssa_operands (cfun)->free_defs = defs;\n+      DEF_OPS (stmt) = NULL;\n+    }\n+\n+  if (uses)\n+    {\n+      for (last_use = uses; last_use->next; last_use = last_use->next)\n+\tdelink_imm_use (USE_OP_PTR (last_use));\n+      delink_imm_use (USE_OP_PTR (last_use));\n+      last_use->next = gimple_ssa_operands (cfun)->free_uses;\n+      gimple_ssa_operands (cfun)->free_uses = uses;\n+      USE_OPS (stmt) = NULL;\n+    }\n+\n+  if (vuses)\n+    {\n+      for (i = 0; i < VUSE_NUM (vuses); i++)\n+\tdelink_imm_use (VUSE_OP_PTR (vuses, i));\n+      add_vop_to_freelist (vuses);\n+      VUSE_OPS (stmt) = NULL;\n+    }\n+\n+  if (vdefs)\n+    {\n+      for (vdef = vdefs; vdef; vdef = next_vdef)\n+\t{\n+\t  next_vdef = vdef->next;\n+\t  delink_imm_use (VDEF_OP_PTR (vdef, 0));\n+\t  add_vop_to_freelist (vdef);\n+\t}\n+      VDEF_OPS (stmt) = NULL;\n+    }\n+}\n \n /* Free any operands vectors in OPS.  */\n "}, {"sha": "4dc344e93072f9d7218fbdd444b5361bbda69c63", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=5f40b3cbe2e4164e80252cc4f2234cdb5ea6da39", "patch": "@@ -206,6 +206,7 @@ extern void init_ssa_operands (void);\n extern void fini_ssa_operands (void);\n extern void free_ssa_operands (stmt_operands_p);\n extern void update_stmt_operands (tree);\n+extern void free_stmt_operands (tree);\n extern bool verify_imm_links (FILE *f, tree var);\n \n extern void copy_virtual_operands (tree, tree);"}]}