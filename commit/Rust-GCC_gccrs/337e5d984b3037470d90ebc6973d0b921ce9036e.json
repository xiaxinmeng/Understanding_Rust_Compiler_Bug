{"sha": "337e5d984b3037470d90ebc6973d0b921ce9036e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM3ZTVkOTg0YjMwMzc0NzBkOTBlYmM2OTczZDBiOTIxY2U5MDM2ZQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-06-28T16:53:18Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-06-28T16:53:18Z"}, "message": "builtins.c (expand_errno_check): Use do_compare_rtx_and_jump.\n\n2009-06-28  Paolo Bonzini  <bonzini@gnu.org>\n\n        * builtins.c (expand_errno_check): Use do_compare_rtx_and_jump.\n        * dojump.c (do_jump): Change handling of floating-point\n        ops to use just do_compare_and_jump.\n        (split_comparison): New.\n        (do_compare_rtx_and_jump): Add here logic coming previously\n        in do_jump, using split_comparison.\n\nFrom-SVN: r149031", "tree": {"sha": "abc948e110699df37c14ad5f3cb1c3013f065f80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abc948e110699df37c14ad5f3cb1c3013f065f80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/337e5d984b3037470d90ebc6973d0b921ce9036e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/337e5d984b3037470d90ebc6973d0b921ce9036e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/337e5d984b3037470d90ebc6973d0b921ce9036e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/337e5d984b3037470d90ebc6973d0b921ce9036e/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7991661bc05bbe0df39745fbcc90bea0da728152", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7991661bc05bbe0df39745fbcc90bea0da728152", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7991661bc05bbe0df39745fbcc90bea0da728152"}], "stats": {"total": 293, "additions": 194, "deletions": 99}, "files": [{"sha": "3a0cae3839341191e8d33823b3367cbd83ce948f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/337e5d984b3037470d90ebc6973d0b921ce9036e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/337e5d984b3037470d90ebc6973d0b921ce9036e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=337e5d984b3037470d90ebc6973d0b921ce9036e", "patch": "@@ -1,3 +1,12 @@\n+2009-06-28  Paolo Bonzini  <bonzini@gnu.org>\n+\n+        * builtins.c (expand_errno_check): Use do_compare_rtx_and_jump.\n+        * dojump.c (do_jump): Change handling of floating-point\n+        ops to use just do_compare_and_jump.\n+        (split_comparison): New.\n+        (do_compare_rtx_and_jump): Add here logic coming previously\n+        in do_jump, using split_comparison.\n+\n 2009-06-27  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/40489"}, {"sha": "de1984e5ab5a5aa465d39184cb40baca53074f1c", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/337e5d984b3037470d90ebc6973d0b921ce9036e/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/337e5d984b3037470d90ebc6973d0b921ce9036e/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=337e5d984b3037470d90ebc6973d0b921ce9036e", "patch": "@@ -1876,8 +1876,8 @@ expand_errno_check (tree exp, rtx target)\n \n   /* Test the result; if it is NaN, set errno=EDOM because\n      the argument was not in the domain.  */\n-  emit_cmp_and_jump_insns (target, target, EQ, 0, GET_MODE (target),\n-\t\t\t   0, lab);\n+  do_compare_rtx_and_jump (target, target, EQ, 0, GET_MODE (target),\n+                           NULL_RTX, NULL_RTX, lab);\n \n #ifdef TARGET_EDOM\n   /* If this built-in doesn't throw an exception, set errno directly.  */"}, {"sha": "131aaed977ff77939f0c67a77ef8068d6059ea3e", "filename": "gcc/dojump.c", "status": "modified", "additions": 181, "deletions": 97, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/337e5d984b3037470d90ebc6973d0b921ce9036e/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/337e5d984b3037470d90ebc6973d0b921ce9036e/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=337e5d984b3037470d90ebc6973d0b921ce9036e", "patch": "@@ -346,93 +346,39 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n         do_compare_and_jump (exp, GE, GEU, if_false_label, if_true_label);\n       break;\n \n-    case UNORDERED_EXPR:\n     case ORDERED_EXPR:\n-      {\n-        enum rtx_code cmp, rcmp;\n-        int do_rev;\n+      do_compare_and_jump (exp, ORDERED, ORDERED,\n+\t\t\t   if_false_label, if_true_label);\n+      break;\n \n-        if (code == UNORDERED_EXPR)\n-          cmp = UNORDERED, rcmp = ORDERED;\n-        else\n-          cmp = ORDERED, rcmp = UNORDERED;\n-        mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n-\n-        do_rev = 0;\n-        if (! can_compare_p (cmp, mode, ccp_jump)\n-            && (can_compare_p (rcmp, mode, ccp_jump)\n-          /* If the target doesn't provide either UNORDERED or ORDERED\n-             comparisons, canonicalize on UNORDERED for the library.  */\n-          || rcmp == UNORDERED))\n-          do_rev = 1;\n-\n-        if (! do_rev)\n-          do_compare_and_jump (exp, cmp, cmp, if_false_label, if_true_label);\n-        else\n-          do_compare_and_jump (exp, rcmp, rcmp, if_true_label, if_false_label);\n-      }\n+    case UNORDERED_EXPR:\n+      do_compare_and_jump (exp, UNORDERED, UNORDERED,\n+\t\t\t   if_false_label, if_true_label);\n       break;\n \n-    {\n-      enum rtx_code rcode1;\n-      enum tree_code tcode1, tcode2;\n-\n-      case UNLT_EXPR:\n-        rcode1 = UNLT;\n-        tcode1 = UNORDERED_EXPR;\n-        tcode2 = LT_EXPR;\n-        goto unordered_bcc;\n-      case UNLE_EXPR:\n-        rcode1 = UNLE;\n-        tcode1 = UNORDERED_EXPR;\n-        tcode2 = LE_EXPR;\n-        goto unordered_bcc;\n-      case UNGT_EXPR:\n-        rcode1 = UNGT;\n-        tcode1 = UNORDERED_EXPR;\n-        tcode2 = GT_EXPR;\n-        goto unordered_bcc;\n-      case UNGE_EXPR:\n-        rcode1 = UNGE;\n-        tcode1 = UNORDERED_EXPR;\n-        tcode2 = GE_EXPR;\n-        goto unordered_bcc;\n-      case UNEQ_EXPR:\n-        rcode1 = UNEQ;\n-        tcode1 = UNORDERED_EXPR;\n-        tcode2 = EQ_EXPR;\n-        goto unordered_bcc;\n-      case LTGT_EXPR:\n-\t/* It is ok for LTGT_EXPR to trap when the result is unordered,\n-\t   so expand to (a < b) || (a > b).  */\n-        rcode1 = LTGT;\n-        tcode1 = LT_EXPR;\n-        tcode2 = GT_EXPR;\n-        goto unordered_bcc;\n-\n-      unordered_bcc:\n-        mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n-        if (can_compare_p (rcode1, mode, ccp_jump))\n-          do_compare_and_jump (exp, rcode1, rcode1, if_false_label,\n-                               if_true_label);\n-        else\n-          {\n-            tree op0 = save_expr (TREE_OPERAND (exp, 0));\n-            tree op1 = save_expr (TREE_OPERAND (exp, 1));\n-            tree cmp0, cmp1;\n-\n-            /* If the target doesn't support combined unordered\n-               compares, decompose into two comparisons.  */\n-\t    if (if_true_label == 0)\n-\t      drop_through_label = if_true_label = gen_label_rtx ();\n-\t      \n-            cmp0 = fold_build2 (tcode1, TREE_TYPE (exp), op0, op1);\n-            cmp1 = fold_build2 (tcode2, TREE_TYPE (exp), op0, op1);\n-\t    do_jump (cmp0, 0, if_true_label);\n-\t    do_jump (cmp1, if_false_label, if_true_label);\n-          }\n+    case UNLT_EXPR:\n+      do_compare_and_jump (exp, UNLT, UNLT, if_false_label, if_true_label);\n+      break;\n+\n+    case UNLE_EXPR:\n+      do_compare_and_jump (exp, UNLE, UNLE, if_false_label, if_true_label);\n+      break;\n+\n+    case UNGT_EXPR:\n+      do_compare_and_jump (exp, UNGT, UNGT, if_false_label, if_true_label);\n+      break;\n+\n+    case UNGE_EXPR:\n+      do_compare_and_jump (exp, UNGE, UNGE, if_false_label, if_true_label);\n+      break;\n+\n+    case UNEQ_EXPR:\n+      do_compare_and_jump (exp, UNEQ, UNEQ, if_false_label, if_true_label);\n+      break;\n+\n+    case LTGT_EXPR:\n+      do_compare_and_jump (exp, LTGT, LTGT, if_false_label, if_true_label);\n       break;\n-    }\n \n     case BIT_AND_EXPR:\n       /* fold_single_bit_test() converts (X & (1 << C)) into (X >> C) & 1.\n@@ -756,6 +702,84 @@ do_jump_by_parts_equality (tree exp, rtx if_false_label, rtx if_true_label)\n \t\t\t\t if_true_label);\n }\n \f\n+/* Split a comparison into two others, the second of which has the other\n+   \"orderedness\".  The first is always ORDERED or UNORDERED if MODE\n+   does not honor NaNs (which means that it can be skipped in that case;\n+   see do_compare_rtx_and_jump).\n+\n+   The two conditions are written in *CODE1 and *CODE2.  Return true if\n+   the conditions must be ANDed, false if they must be ORed.  */\n+\n+bool\n+split_comparison (enum rtx_code code, enum machine_mode mode,\n+\t\t  enum rtx_code *code1, enum rtx_code *code2)\n+{\n+  switch (code)\n+    {\n+    case LT:\n+      *code1 = ORDERED;\n+      *code2 = UNLT;\n+      return true;\n+    case LE:\n+      *code1 = ORDERED;\n+      *code2 = UNLE;\n+      return true;\n+    case GT:\n+      *code1 = ORDERED;\n+      *code2 = UNGT;\n+      return true;\n+    case GE:\n+      *code1 = ORDERED;\n+      *code2 = UNGE;\n+      return true;\n+    case EQ:\n+      *code1 = ORDERED;\n+      *code2 = UNEQ;\n+      return true;\n+    case NE:\n+      *code1 = UNORDERED;\n+      *code2 = LTGT;\n+      return false;\n+    case UNLT:\n+      *code1 = UNORDERED;\n+      *code2 = LT;\n+      return false;\n+    case UNLE:\n+      *code1 = UNORDERED;\n+      *code2 = LE;\n+      return false;\n+    case UNGT:\n+      *code1 = UNORDERED;\n+      *code2 = GT;\n+      return false;\n+    case UNGE:\n+      *code1 = UNORDERED;\n+      *code2 = GE;\n+      return false;\n+    case UNEQ:\n+      *code1 = UNORDERED;\n+      *code2 = EQ;\n+      return false;\n+    case LTGT:\n+      /* Do not turn a trapping comparison into a non-trapping one.  */\n+      if (HONOR_SNANS (mode))\n+\t{\n+          *code1 = LT;\n+          *code2 = GT;\n+          return false;\n+\t}\n+      else\n+\t{\n+\t  *code1 = ORDERED;\n+\t  *code2 = NE;\n+\t  return true;\n+\t}\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+\n /* Like do_compare_and_jump but expects the values to compare as two rtx's.\n    The decision as to signed or unsigned comparison must be made by the caller.\n \n@@ -768,15 +792,33 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \t\t\t rtx if_true_label)\n {\n   rtx tem;\n-  int dummy_true_label = 0;\n+  rtx dummy_label = NULL_RTX;\n \n   /* Reverse the comparison if that is safe and we want to jump if it is\n-     false.  */\n-  if (! if_true_label && ! FLOAT_MODE_P (mode))\n+     false.  Also convert to the reverse comparison if the target can\n+     implement it.  */\n+  if ((! if_true_label\n+       || ! can_compare_p (code, mode, ccp_jump))\n+      && (! FLOAT_MODE_P (mode)\n+\t  || code == ORDERED || code == UNORDERED\n+\t  || (! HONOR_NANS (mode) && (code == LTGT || code == UNEQ))\n+\t  || (! HONOR_SNANS (mode) && (code == EQ || code == NE))))\n     {\n-      if_true_label = if_false_label;\n-      if_false_label = 0;\n-      code = reverse_condition (code);\n+      enum rtx_code rcode;\n+      if (FLOAT_MODE_P (mode))\n+        rcode = reverse_condition_maybe_unordered (code);\n+      else\n+        rcode = reverse_condition (code);\n+\n+      /* Canonicalize to UNORDERED for the libcall.  */\n+      if (can_compare_p (rcode, mode, ccp_jump)\n+\t  || (code == ORDERED && ! can_compare_p (ORDERED, mode, ccp_jump)))\n+\t{\n+          tem = if_true_label;\n+          if_true_label = if_false_label;\n+          if_false_label = tem;\n+\t  code = rcode;\n+\t}\n     }\n \n   /* If one operand is constant, make it the second one.  Only do this\n@@ -812,12 +854,8 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n       unsignedp = (code == GTU || code == LTU || code == GEU || code == LEU);\n     }\n \n-\n   if (! if_true_label)\n-    {\n-      dummy_true_label = 1;\n-      if_true_label = gen_label_rtx ();\n-    }\n+    dummy_label = if_true_label = gen_label_rtx ();\n \n   if (GET_MODE_CLASS (mode) == MODE_INT\n       && ! can_compare_p (code, mode, ccp_jump))\n@@ -879,13 +917,59 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \t}\n     }\n   else\n-    emit_cmp_and_jump_insns (op0, op1, code, size, mode, unsignedp,\n-\t\t\t     if_true_label);\n+    {\n+      if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t  && ! can_compare_p (code, mode, ccp_jump)\n+\n+\t  /* Never split ORDERED and UNORDERED.  These must be implemented.  */\n+\t  && (code != ORDERED && code != UNORDERED)\n+\n+          /* Split a floating-point comparison if we can jump on other\n+\t     conditions...  */\n+\t  && (have_insn_for (COMPARE, mode)\n+\n+\t      /* ... or if there is no libcall for it.  */\n+\t      || code_to_optab[code] == NULL))\n+        {\n+\t  enum rtx_code first_code;\n+\t  bool and_them = split_comparison (code, mode, &first_code, &code);\n+\n+\t  /* If there are no NaNs, the first comparison should always fall\n+\t     through.  */\n+\t  if (!HONOR_NANS (mode))\n+\t    gcc_assert (first_code == (and_them ? ORDERED : UNORDERED));\n+\n+\t  else\n+\t    {\n+\t      if (and_them)\n+\t\t{\n+\t\t  rtx dest_label;\n+\t\t  /* If we only jump if true, just bypass the second jump.  */\n+\t\t  if (! if_false_label)\n+\t\t    {\n+\t\t      if (! dummy_label)\n+\t\t        dummy_label = gen_label_rtx ();\n+\t\t      dest_label = dummy_label;\n+\t\t    }\n+\t\t  else\n+\t\t    dest_label = if_false_label;\n+                  do_compare_rtx_and_jump (op0, op1, first_code, unsignedp, mode,\n+\t\t\t\t\t   size, dest_label, NULL_RTX);\n+\t\t}\n+              else\n+                do_compare_rtx_and_jump (op0, op1, first_code, unsignedp, mode,\n+\t\t\t\t\t size, NULL_RTX, if_true_label);\n+\t    }\n+\t}\n+\n+      emit_cmp_and_jump_insns (op0, op1, code, size, mode, unsignedp,\n+\t\t\t       if_true_label);\n+    }\n \n   if (if_false_label)\n     emit_jump (if_false_label);\n-  if (dummy_true_label)\n-    emit_label (if_true_label);\n+  if (dummy_label)\n+    emit_label (dummy_label);\n }\n \n /* Generate code for a comparison expression EXP (including code to compute"}, {"sha": "caf965e941272a9dfc719402f3a74960a5182aff", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/337e5d984b3037470d90ebc6973d0b921ce9036e/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/337e5d984b3037470d90ebc6973d0b921ce9036e/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=337e5d984b3037470d90ebc6973d0b921ce9036e", "patch": "@@ -774,6 +774,8 @@ extern rtx expand_mult_highpart_adjust (enum machine_mode, rtx, rtx, rtx, rtx, i\n \n extern rtx assemble_static_space (unsigned HOST_WIDE_INT);\n extern int safe_from_p (const_rtx, tree, int);\n+extern bool split_comparison (enum rtx_code, enum machine_mode,\n+\t\t\t      enum rtx_code *, enum rtx_code *);\n \n /* Call this once to initialize the contents of the optabs\n    appropriately for the current target machine.  */"}]}