{"sha": "7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M2MTY1N2Y2OGNjNDViZGJiZmNmZDc2MmRiZmQ3MDIxZjNhY2IzZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:11:32Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:11:32Z"}, "message": "[25/77] Use is_a <scalar_int_mode> for bitmask optimisations\n\nExplicitly check for scalar_int_mode in code that maps arithmetic\nto full-mode bit operations.  These operations wouldn't work correctly\nfor vector modes, for example.  In many cases this is enforced also by\nchecking whether an operand is CONST_INT_P, but there were other cases\nwhere the condition is more indirect.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* combine.c (combine_simplify_rtx): Add checks for\n\tis_a <scalar_int_mode>.\n\t(simplify_if_then_else): Likewise.\n\t(make_field_assignment): Likewise.\n\t(simplify_comparison): Likewise.\n\t* ifcvt.c (noce_try_bitop): Likewise.\n\t* loop-invariant.c (canonicalize_address_mult): Likewise.\n\t* simplify-rtx.c (simplify_unary_operation_1): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251477", "tree": {"sha": "983ecb0098267a20b4cb1756c1fd29aebe17c9bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/983ecb0098267a20b4cb1756c1fd29aebe17c9bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f/comments", "author": null, "committer": null, "parents": [{"sha": "64ab8765d7e45ed19d4a571b2aaba0abf7f834c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64ab8765d7e45ed19d4a571b2aaba0abf7f834c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64ab8765d7e45ed19d4a571b2aaba0abf7f834c3"}], "stats": {"total": 183, "additions": 114, "deletions": 69}, "files": [{"sha": "841fe4b726c6aed8e65b8b9ae1546b473c5ea8bb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f", "patch": "@@ -1,3 +1,16 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* combine.c (combine_simplify_rtx): Add checks for\n+\tis_a <scalar_int_mode>.\n+\t(simplify_if_then_else): Likewise.\n+\t(make_field_assignment): Likewise.\n+\t(simplify_comparison): Likewise.\n+\t* ifcvt.c (noce_try_bitop): Likewise.\n+\t* loop-invariant.c (canonicalize_address_mult): Likewise.\n+\t* simplify-rtx.c (simplify_unary_operation_1): Likewise.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "65877e9daf7eb150f692dae0b801f2826296fa69", "filename": "gcc/combine.c", "status": "modified", "additions": 77, "deletions": 54, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f", "patch": "@@ -5850,13 +5850,14 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,\n       if (!REG_P (temp)\n \t  && ! (GET_CODE (temp) == SUBREG\n \t\t&& REG_P (SUBREG_REG (temp)))\n-\t  && (i = exact_log2 (nonzero_bits (temp, mode))) >= 0)\n+\t  && is_a <scalar_int_mode> (mode, &int_mode)\n+\t  && (i = exact_log2 (nonzero_bits (temp, int_mode))) >= 0)\n \t{\n \t  rtx temp1 = simplify_shift_const\n-\t    (NULL_RTX, ASHIFTRT, mode,\n-\t     simplify_shift_const (NULL_RTX, ASHIFT, mode, temp,\n-\t\t\t\t   GET_MODE_PRECISION (mode) - 1 - i),\n-\t     GET_MODE_PRECISION (mode) - 1 - i);\n+\t    (NULL_RTX, ASHIFTRT, int_mode,\n+\t     simplify_shift_const (NULL_RTX, ASHIFT, int_mode, temp,\n+\t\t\t\t   GET_MODE_PRECISION (int_mode) - 1 - i),\n+\t     GET_MODE_PRECISION (int_mode) - 1 - i);\n \n \t  /* If all we did was surround TEMP with the two shifts, we\n \t     haven't improved anything, so don't use it.  Otherwise,\n@@ -5947,12 +5948,15 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,\n \t  && !REG_P (XEXP (x, 0))\n \t  && ! (GET_CODE (XEXP (x, 0)) == SUBREG\n \t\t&& REG_P (SUBREG_REG (XEXP (x, 0))))\n-\t  && nonzero_bits (XEXP (x, 0), mode) == 1)\n-\treturn simplify_shift_const (NULL_RTX, ASHIFTRT, mode,\n-\t   simplify_shift_const (NULL_RTX, ASHIFT, mode,\n-\t\t\t\t gen_rtx_XOR (mode, XEXP (x, 0), const1_rtx),\n-\t\t\t\t GET_MODE_PRECISION (mode) - 1),\n-\t   GET_MODE_PRECISION (mode) - 1);\n+\t  && is_a <scalar_int_mode> (mode, &int_mode)\n+\t  && nonzero_bits (XEXP (x, 0), int_mode) == 1)\n+\treturn simplify_shift_const\n+\t  (NULL_RTX, ASHIFTRT, int_mode,\n+\t   simplify_shift_const (NULL_RTX, ASHIFT, int_mode,\n+\t\t\t\t gen_rtx_XOR (int_mode, XEXP (x, 0),\n+\t\t\t\t\t      const1_rtx),\n+\t\t\t\t GET_MODE_PRECISION (int_mode) - 1),\n+\t   GET_MODE_PRECISION (int_mode) - 1);\n \n       /* If we are adding two things that have no bits in common, convert\n \t the addition into an IOR.  This will often be further simplified,\n@@ -5990,11 +5994,12 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,\n     case MINUS:\n       /* (minus <foo> (and <foo> (const_int -pow2))) becomes\n \t (and <foo> (const_int pow2-1))  */\n-      if (GET_CODE (XEXP (x, 1)) == AND\n+      if (is_a <scalar_int_mode> (mode, &int_mode)\n+\t  && GET_CODE (XEXP (x, 1)) == AND\n \t  && CONST_INT_P (XEXP (XEXP (x, 1), 1))\n \t  && pow2p_hwi (-UINTVAL (XEXP (XEXP (x, 1), 1)))\n \t  && rtx_equal_p (XEXP (XEXP (x, 1), 0), XEXP (x, 0)))\n-\treturn simplify_and_const_int (NULL_RTX, mode, XEXP (x, 0),\n+\treturn simplify_and_const_int (NULL_RTX, int_mode, XEXP (x, 0),\n \t\t\t\t       -INTVAL (XEXP (XEXP (x, 1), 1)) - 1);\n       break;\n \n@@ -6025,14 +6030,16 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,\n     case UDIV:\n       /* If this is a divide by a power of two, treat it as a shift if\n \t its first operand is a shift.  */\n-      if (CONST_INT_P (XEXP (x, 1))\n+      if (is_a <scalar_int_mode> (mode, &int_mode)\n+\t  && CONST_INT_P (XEXP (x, 1))\n \t  && (i = exact_log2 (UINTVAL (XEXP (x, 1)))) >= 0\n \t  && (GET_CODE (XEXP (x, 0)) == ASHIFT\n \t      || GET_CODE (XEXP (x, 0)) == LSHIFTRT\n \t      || GET_CODE (XEXP (x, 0)) == ASHIFTRT\n \t      || GET_CODE (XEXP (x, 0)) == ROTATE\n \t      || GET_CODE (XEXP (x, 0)) == ROTATERT))\n-\treturn simplify_shift_const (NULL_RTX, LSHIFTRT, mode, XEXP (x, 0), i);\n+\treturn simplify_shift_const (NULL_RTX, LSHIFTRT, int_mode,\n+\t\t\t\t     XEXP (x, 0), i);\n       break;\n \n     case EQ:  case NE:\n@@ -6316,22 +6323,28 @@ simplify_if_then_else (rtx x)\n \t  std::swap (true_rtx, false_rtx);\n \t}\n \n-      /* If we are comparing against zero and the expression being tested has\n-\t only a single bit that might be nonzero, that is its value when it is\n-\t not equal to zero.  Similarly if it is known to be -1 or 0.  */\n-\n-      if (true_code == EQ && true_val == const0_rtx\n-\t  && pow2p_hwi (nzb = nonzero_bits (from, GET_MODE (from))))\n+      scalar_int_mode from_mode;\n+      if (is_a <scalar_int_mode> (GET_MODE (from), &from_mode))\n \t{\n-\t  false_code = EQ;\n-\t  false_val = gen_int_mode (nzb, GET_MODE (from));\n-\t}\n-      else if (true_code == EQ && true_val == const0_rtx\n-\t       && (num_sign_bit_copies (from, GET_MODE (from))\n-\t\t   == GET_MODE_PRECISION (GET_MODE (from))))\n-\t{\n-\t  false_code = EQ;\n-\t  false_val = constm1_rtx;\n+\t  /* If we are comparing against zero and the expression being\n+\t     tested has only a single bit that might be nonzero, that is\n+\t     its value when it is not equal to zero.  Similarly if it is\n+\t     known to be -1 or 0.  */\n+\t  if (true_code == EQ\n+\t      && true_val == const0_rtx\n+\t      && pow2p_hwi (nzb = nonzero_bits (from, from_mode)))\n+\t    {\n+\t      false_code = EQ;\n+\t      false_val = gen_int_mode (nzb, from_mode);\n+\t    }\n+\t  else if (true_code == EQ\n+\t\t   && true_val == const0_rtx\n+\t\t   && (num_sign_bit_copies (from, from_mode)\n+\t\t       == GET_MODE_PRECISION (from_mode)))\n+\t    {\n+\t      false_code = EQ;\n+\t      false_val = constm1_rtx;\n+\t    }\n \t}\n \n       /* Now simplify an arm if we know the value of the register in the\n@@ -6581,16 +6594,19 @@ simplify_if_then_else (rtx x)\n      negation of a single bit, we can convert this operation to a shift.  We\n      can actually do this more generally, but it doesn't seem worth it.  */\n \n-  if (true_code == NE && XEXP (cond, 1) == const0_rtx\n-      && false_rtx == const0_rtx && CONST_INT_P (true_rtx)\n-      && ((1 == nonzero_bits (XEXP (cond, 0), mode)\n+  if (true_code == NE\n+      && is_a <scalar_int_mode> (mode, &int_mode)\n+      && XEXP (cond, 1) == const0_rtx\n+      && false_rtx == const0_rtx\n+      && CONST_INT_P (true_rtx)\n+      && ((1 == nonzero_bits (XEXP (cond, 0), int_mode)\n \t   && (i = exact_log2 (UINTVAL (true_rtx))) >= 0)\n-\t  || ((num_sign_bit_copies (XEXP (cond, 0), mode)\n-\t       == GET_MODE_PRECISION (mode))\n+\t  || ((num_sign_bit_copies (XEXP (cond, 0), int_mode)\n+\t       == GET_MODE_PRECISION (int_mode))\n \t      && (i = exact_log2 (-UINTVAL (true_rtx))) >= 0)))\n     return\n-      simplify_shift_const (NULL_RTX, ASHIFT, mode,\n-\t\t\t    gen_lowpart (mode, XEXP (cond, 0)), i);\n+      simplify_shift_const (NULL_RTX, ASHIFT, int_mode,\n+\t\t\t    gen_lowpart (int_mode, XEXP (cond, 0)), i);\n \n   /* (IF_THEN_ELSE (NE A 0) C1 0) is A or a zero-extend of A if the only\n      non-zero bit in A is C1.  */\n@@ -9461,7 +9477,11 @@ make_field_assignment (rtx x)\n   HOST_WIDE_INT pos;\n   unsigned HOST_WIDE_INT len;\n   rtx other;\n-  machine_mode mode;\n+\n+  /* All the rules in this function are specific to scalar integers.  */\n+  scalar_int_mode mode;\n+  if (!is_a <scalar_int_mode> (GET_MODE (dest), &mode))\n+    return x;\n \n   /* If SRC was (and (not (ashift (const_int 1) POS)) DEST), this is\n      a clear of a one-bit field.  We will have changed it to\n@@ -9534,7 +9554,6 @@ make_field_assignment (rtx x)\n       /* Partial overlap.  We can reduce the source AND.  */\n       if ((and_mask & ze_mask) != and_mask)\n \t{\n-\t  mode = GET_MODE (src);\n \t  src = gen_rtx_AND (mode, XEXP (src, 0),\n \t\t\t     gen_int_mode (and_mask & ze_mask, mode));\n \t  return gen_rtx_SET (dest, src);\n@@ -9553,7 +9572,10 @@ make_field_assignment (rtx x)\n      assignment.  The first one we are likely to encounter is an outer\n      narrowing SUBREG, which we can just strip for the purposes of\n      identifying the constant-field assignment.  */\n-  if (GET_CODE (src) == SUBREG && subreg_lowpart_p (src))\n+  scalar_int_mode src_mode = mode;\n+  if (GET_CODE (src) == SUBREG\n+      && subreg_lowpart_p (src)\n+      && is_a <scalar_int_mode> (GET_MODE (SUBREG_REG (src)), &src_mode))\n     src = SUBREG_REG (src);\n \n   if (GET_CODE (src) != IOR && GET_CODE (src) != XOR)\n@@ -9599,10 +9621,11 @@ make_field_assignment (rtx x)\n   else\n     return x;\n \n-  pos = get_pos_from_mask ((~c1) & GET_MODE_MASK (GET_MODE (dest)), &len);\n-  if (pos < 0 || pos + len > GET_MODE_PRECISION (GET_MODE (dest))\n-      || GET_MODE_PRECISION (GET_MODE (dest)) > HOST_BITS_PER_WIDE_INT\n-      || (c1 & nonzero_bits (other, GET_MODE (dest))) != 0)\n+  pos = get_pos_from_mask ((~c1) & GET_MODE_MASK (mode), &len);\n+  if (pos < 0\n+      || pos + len > GET_MODE_PRECISION (mode)\n+      || GET_MODE_PRECISION (mode) > HOST_BITS_PER_WIDE_INT\n+      || (c1 & nonzero_bits (other, mode)) != 0)\n     return x;\n \n   assign = make_extraction (VOIDmode, dest, pos, NULL_RTX, len, 1, 1, 0);\n@@ -9611,17 +9634,16 @@ make_field_assignment (rtx x)\n \n   /* The mode to use for the source is the mode of the assignment, or of\n      what is inside a possible STRICT_LOW_PART.  */\n-  mode = (GET_CODE (assign) == STRICT_LOW_PART\n-\t  ? GET_MODE (XEXP (assign, 0)) : GET_MODE (assign));\n+  machine_mode new_mode = (GET_CODE (assign) == STRICT_LOW_PART\n+\t\t\t   ? GET_MODE (XEXP (assign, 0)) : GET_MODE (assign));\n \n   /* Shift OTHER right POS places and make it the source, restricting it\n      to the proper length and mode.  */\n \n   src = canon_reg_for_combine (simplify_shift_const (NULL_RTX, LSHIFTRT,\n-\t\t\t\t\t\t     GET_MODE (src),\n-\t\t\t\t\t\t     other, pos),\n+\t\t\t\t\t\t     src_mode, other, pos),\n \t\t\t       dest);\n-  src = force_to_mode (src, mode,\n+  src = force_to_mode (src, new_mode,\n \t\t       len >= HOST_BITS_PER_WIDE_INT\n \t\t       ? HOST_WIDE_INT_M1U\n \t\t       : (HOST_WIDE_INT_1U << len) - 1,\n@@ -11745,16 +11767,17 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  && GET_CODE (XEXP (op1, 0)) == ASHIFT\n \t  && GET_CODE (XEXP (XEXP (op0, 0), 0)) == SUBREG\n \t  && GET_CODE (XEXP (XEXP (op1, 0), 0)) == SUBREG\n-\t  && (GET_MODE (SUBREG_REG (XEXP (XEXP (op0, 0), 0)))\n-\t      == GET_MODE (SUBREG_REG (XEXP (XEXP (op1, 0), 0))))\n+\t  && is_a <scalar_int_mode> (GET_MODE (op0), &mode)\n+\t  && (is_a <scalar_int_mode>\n+\t      (GET_MODE (SUBREG_REG (XEXP (XEXP (op0, 0), 0))), &inner_mode))\n+\t  && inner_mode == GET_MODE (SUBREG_REG (XEXP (XEXP (op1, 0), 0)))\n \t  && CONST_INT_P (XEXP (op0, 1))\n \t  && XEXP (op0, 1) == XEXP (op1, 1)\n \t  && XEXP (op0, 1) == XEXP (XEXP (op0, 0), 1)\n \t  && XEXP (op0, 1) == XEXP (XEXP (op1, 0), 1)\n \t  && (INTVAL (XEXP (op0, 1))\n-\t      == (GET_MODE_PRECISION (GET_MODE (op0))\n-\t\t  - (GET_MODE_PRECISION\n-\t\t     (GET_MODE (SUBREG_REG (XEXP (XEXP (op0, 0), 0))))))))\n+\t      == (GET_MODE_PRECISION (mode)\n+\t\t  - GET_MODE_PRECISION (inner_mode))))\n \t{\n \t  op0 = SUBREG_REG (XEXP (XEXP (op0, 0), 0));\n \t  op1 = SUBREG_REG (XEXP (XEXP (op1, 0), 0));"}, {"sha": "9a646a692987a9d1eabb433b455ed5bfc626823e", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f", "patch": "@@ -2808,14 +2808,18 @@ noce_try_bitop (struct noce_if_info *if_info)\n {\n   rtx cond, x, a, result;\n   rtx_insn *seq;\n-  machine_mode mode;\n+  scalar_int_mode mode;\n   enum rtx_code code;\n   int bitnum;\n \n   x = if_info->x;\n   cond = if_info->cond;\n   code = GET_CODE (cond);\n \n+  /* Check for an integer operation.  */\n+  if (!is_a <scalar_int_mode> (GET_MODE (x), &mode))\n+    return FALSE;\n+\n   if (!noce_simple_bbs (if_info))\n     return FALSE;\n \n@@ -2838,7 +2842,6 @@ noce_try_bitop (struct noce_if_info *if_info)\n \t  || ! rtx_equal_p (x, XEXP (cond, 0)))\n \treturn FALSE;\n       bitnum = INTVAL (XEXP (cond, 2));\n-      mode = GET_MODE (x);\n       if (BITS_BIG_ENDIAN)\n \tbitnum = GET_MODE_BITSIZE (mode) - 1 - bitnum;\n       if (bitnum < 0 || bitnum >= HOST_BITS_PER_WIDE_INT)"}, {"sha": "1cdb5cbf5854ea738d2f50e4c1d128fc39df2b55", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f", "patch": "@@ -774,16 +774,16 @@ canonicalize_address_mult (rtx x)\n   FOR_EACH_SUBRTX_VAR (iter, array, x, NONCONST)\n     {\n       rtx sub = *iter;\n-\n-      if (GET_CODE (sub) == ASHIFT\n+      scalar_int_mode sub_mode;\n+      if (is_a <scalar_int_mode> (GET_MODE (sub), &sub_mode)\n+\t  && GET_CODE (sub) == ASHIFT\n \t  && CONST_INT_P (XEXP (sub, 1))\n-\t  && INTVAL (XEXP (sub, 1)) < GET_MODE_BITSIZE (GET_MODE (sub))\n+\t  && INTVAL (XEXP (sub, 1)) < GET_MODE_BITSIZE (sub_mode)\n \t  && INTVAL (XEXP (sub, 1)) >= 0)\n \t{\n \t  HOST_WIDE_INT shift = INTVAL (XEXP (sub, 1));\n \t  PUT_CODE (sub, MULT);\n-\t  XEXP (sub, 1) = gen_int_mode (HOST_WIDE_INT_1 << shift,\n-\t\t\t\t\tGET_MODE (sub));\n+\t  XEXP (sub, 1) = gen_int_mode (HOST_WIDE_INT_1 << shift, sub_mode);\n \t  iter.skip_subrtxes ();\n \t}\n     }"}, {"sha": "c3c6a80a1892de157ebe4673226b69b81d066528", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f", "patch": "@@ -925,7 +925,7 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n {\n   enum rtx_code reversed;\n   rtx temp;\n-  scalar_int_mode inner;\n+  scalar_int_mode inner, int_mode;\n \n   switch (code)\n     {\n@@ -986,10 +986,11 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n \t minus 1 is (ge foo (const_int 0)) if STORE_FLAG_VALUE is -1,\n \t so we can perform the above simplification.  */\n       if (STORE_FLAG_VALUE == -1\n+\t  && is_a <scalar_int_mode> (mode, &int_mode)\n \t  && GET_CODE (op) == ASHIFTRT\n \t  && CONST_INT_P (XEXP (op, 1))\n-\t  && INTVAL (XEXP (op, 1)) == GET_MODE_PRECISION (mode) - 1)\n-\treturn simplify_gen_relational (GE, mode, VOIDmode,\n+\t  && INTVAL (XEXP (op, 1)) == GET_MODE_PRECISION (int_mode) - 1)\n+\treturn simplify_gen_relational (GE, int_mode, VOIDmode,\n \t\t\t\t\tXEXP (op, 0), const0_rtx);\n \n \n@@ -1339,8 +1340,10 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n \treturn op;\n \n       /* If operand is known to be only -1 or 0, convert ABS to NEG.  */\n-      if (num_sign_bit_copies (op, mode) == GET_MODE_PRECISION (mode))\n-\treturn gen_rtx_NEG (mode, op);\n+      if (is_a <scalar_int_mode> (mode, &int_mode)\n+\t  && (num_sign_bit_copies (op, int_mode)\n+\t      == GET_MODE_PRECISION (int_mode)))\n+\treturn gen_rtx_NEG (int_mode, op);\n \n       break;\n \n@@ -1494,12 +1497,13 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n \t is similarly (zero_extend:M (subreg:O <X>)).  */\n       if ((GET_CODE (op) == ASHIFTRT || GET_CODE (op) == LSHIFTRT)\n \t  && GET_CODE (XEXP (op, 0)) == ASHIFT\n+\t  && is_a <scalar_int_mode> (mode, &int_mode)\n \t  && CONST_INT_P (XEXP (op, 1))\n \t  && XEXP (XEXP (op, 0), 1) == XEXP (op, 1)\n \t  && GET_MODE_BITSIZE (GET_MODE (op)) > INTVAL (XEXP (op, 1)))\n \t{\n \t  scalar_int_mode tmode;\n-\t  gcc_assert (GET_MODE_BITSIZE (mode)\n+\t  gcc_assert (GET_MODE_BITSIZE (int_mode)\n \t\t      > GET_MODE_BITSIZE (GET_MODE (op)));\n \t  if (int_mode_for_size (GET_MODE_BITSIZE (GET_MODE (op))\n \t\t\t\t - INTVAL (XEXP (op, 1)), 1).exists (&tmode))\n@@ -1509,7 +1513,7 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n \t      if (inner)\n \t\treturn simplify_gen_unary (GET_CODE (op) == ASHIFTRT\n \t\t\t\t\t   ? SIGN_EXTEND : ZERO_EXTEND,\n-\t\t\t\t\t   mode, inner, tmode);\n+\t\t\t\t\t   int_mode, inner, tmode);\n \t    }\n \t}\n \n@@ -1610,6 +1614,7 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n \t GET_MODE_PRECISION (N) - I bits.  */\n       if (GET_CODE (op) == LSHIFTRT\n \t  && GET_CODE (XEXP (op, 0)) == ASHIFT\n+\t  && is_a <scalar_int_mode> (mode, &int_mode)\n \t  && CONST_INT_P (XEXP (op, 1))\n \t  && XEXP (XEXP (op, 0), 1) == XEXP (op, 1)\n \t  && GET_MODE_PRECISION (GET_MODE (op)) > INTVAL (XEXP (op, 1)))\n@@ -1621,7 +1626,8 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n \t      rtx inner =\n \t\trtl_hooks.gen_lowpart_no_emit (tmode, XEXP (XEXP (op, 0), 0));\n \t      if (inner)\n-\t\treturn simplify_gen_unary (ZERO_EXTEND, mode, inner, tmode);\n+\t\treturn simplify_gen_unary (ZERO_EXTEND, int_mode,\n+\t\t\t\t\t   inner, tmode);\n \t    }\n \t}\n "}]}