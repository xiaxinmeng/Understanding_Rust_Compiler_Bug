{"sha": "036c8f37959ccdafc6ea055ec109eb7cc3051697", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM2YzhmMzc5NTljY2RhZmM2ZWEwNTVlYzEwOWViN2NjMzA1MTY5Nw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-01-19T16:55:24Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-01-19T16:55:24Z"}, "message": "Improve check for const initializer loop.\n\nFrom-SVN: r169003", "tree": {"sha": "a3d01365a21c680726d67cd1372f87eec38232d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3d01365a21c680726d67cd1372f87eec38232d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/036c8f37959ccdafc6ea055ec109eb7cc3051697", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/036c8f37959ccdafc6ea055ec109eb7cc3051697", "html_url": "https://github.com/Rust-GCC/gccrs/commit/036c8f37959ccdafc6ea055ec109eb7cc3051697", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/036c8f37959ccdafc6ea055ec109eb7cc3051697/comments", "author": null, "committer": null, "parents": [{"sha": "e3e190507a1abb4a7b1933421d669652e9179dcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3e190507a1abb4a7b1933421d669652e9179dcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3e190507a1abb4a7b1933421d669652e9179dcb"}], "stats": {"total": 54, "additions": 47, "deletions": 7}, "files": [{"sha": "21715641a42f172464e6c501ae1a64ead20d63a2", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036c8f37959ccdafc6ea055ec109eb7cc3051697/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036c8f37959ccdafc6ea055ec109eb7cc3051697/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=036c8f37959ccdafc6ea055ec109eb7cc3051697", "patch": "@@ -2348,6 +2348,10 @@ class Const_expression : public Expression\n   name() const\n   { return this->constant_->name(); }\n \n+  // Check that the initializer does not refer to the constant itself.\n+  void\n+  check_for_init_loop();\n+\n  protected:\n   Expression*\n   do_lower(Gogo*, Named_object*, int);\n@@ -2610,23 +2614,49 @@ Const_expression::do_determine_type(const Type_context* context)\n     }\n }\n \n-// Check types of a const reference.\n+// Check for a loop in which the initializer of a constant refers to\n+// the constant itself.\n \n void\n-Const_expression::do_check_types(Gogo*)\n+Const_expression::check_for_init_loop()\n {\n   if (this->type_ != NULL && this->type_->is_error_type())\n     return;\n \n+  if (this->seen_)\n+    {\n+      this->report_error(_(\"constant refers to itself\"));\n+      this->type_ = Type::make_error_type();\n+      return;\n+    }\n+\n   Expression* init = this->constant_->const_value()->expr();\n   Find_named_object find_named_object(this->constant_);\n+\n+  this->seen_ = true;\n   Expression::traverse(&init, &find_named_object);\n+  this->seen_ = false;\n+\n   if (find_named_object.found())\n     {\n-      this->report_error(_(\"constant refers to itself\"));\n-      this->type_ = Type::make_error_type();\n+      if (this->type_ == NULL || !this->type_->is_error_type())\n+\t{\n+\t  this->report_error(_(\"constant refers to itself\"));\n+\t  this->type_ = Type::make_error_type();\n+\t}\n       return;\n     }\n+}\n+\n+// Check types of a const reference.\n+\n+void\n+Const_expression::do_check_types(Gogo*)\n+{\n+  if (this->type_ != NULL && this->type_->is_error_type())\n+    return;\n+\n+  this->check_for_init_loop();\n \n   if (this->type_ == NULL || this->type_->is_abstract())\n     return;\n@@ -2754,9 +2784,19 @@ Find_named_object::expression(Expression** pexpr)\n   switch ((*pexpr)->classification())\n     {\n     case Expression::EXPRESSION_CONST_REFERENCE:\n-      if (static_cast<Const_expression*>(*pexpr)->named_object() == this->no_)\n-\tbreak;\n-      return TRAVERSE_CONTINUE;\n+      {\n+\tConst_expression* ce = static_cast<Const_expression*>(*pexpr);\n+\tif (ce->named_object() == this->no_)\n+\t  break;\n+\n+\t// We need to check a constant initializer explicitly, as\n+\t// loops here will not be caught by the loop checking for\n+\t// variable initializers.\n+\tce->check_for_init_loop();\n+\n+\treturn TRAVERSE_CONTINUE;\n+      }\n+\n     case Expression::EXPRESSION_VAR_REFERENCE:\n       if ((*pexpr)->var_expression()->named_object() == this->no_)\n \tbreak;"}]}