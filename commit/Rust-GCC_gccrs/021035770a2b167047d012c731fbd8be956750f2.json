{"sha": "021035770a2b167047d012c731fbd8be956750f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIxMDM1NzcwYTJiMTY3MDQ3ZDAxMmM3MzFmYmQ4YmU5NTY3NTBmMg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-03-01T11:48:17Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-03-01T11:48:17Z"}, "message": "(decode_field_reference): Don't check TREE_CODE of EXP; let get_inner_reference decide if have reference.\n\n(decode_field_reference): Don't check TREE_CODE of EXP; let\nget_inner_reference decide if have reference.\nAllow no bit reference if have AND_MASK.\n(all_ones_mask_p): Use tree_int_cst_equal, not operand_equal_p.\n(unextend): New function.\n(fold_truthop): For constant cases, use new function, rework\nconversion, and warn if comparison can never be true.\n\nFrom-SVN: r9099", "tree": {"sha": "3441c499b9b20609e22da13a3bf999007ecbe418", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3441c499b9b20609e22da13a3bf999007ecbe418"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/021035770a2b167047d012c731fbd8be956750f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/021035770a2b167047d012c731fbd8be956750f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/021035770a2b167047d012c731fbd8be956750f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/021035770a2b167047d012c731fbd8be956750f2/comments", "author": null, "committer": null, "parents": [{"sha": "f635a84d96e160cf99e6e310e9caf6de0b889986", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f635a84d96e160cf99e6e310e9caf6de0b889986", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f635a84d96e160cf99e6e310e9caf6de0b889986"}], "stats": {"total": 86, "additions": 67, "deletions": 19}, "files": [{"sha": "f0f3e698434219cbcc31ddf96dc4a8ecfd1ccdda", "filename": "gcc/fold-const.c", "status": "modified", "additions": 67, "deletions": 19, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/021035770a2b167047d012c731fbd8be956750f2/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/021035770a2b167047d012c731fbd8be956750f2/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=021035770a2b167047d012c731fbd8be956750f2", "patch": "@@ -75,6 +75,7 @@ static int all_ones_mask_p PROTO((tree, int));\n static int simple_operand_p PROTO((tree));\n static tree range_test\tPROTO((enum tree_code, tree, enum tree_code,\n \t\t\t       enum tree_code, tree, tree, tree));\n+static tree unextend\tPROTO((tree, int, int));\n static tree fold_truthop PROTO((enum tree_code, tree, tree, tree));\n static tree strip_compound_expr PROTO((tree, tree));\n \n@@ -2435,13 +2436,11 @@ decode_field_reference (exp, pbitsize, pbitpos, pmode, punsignedp,\n \treturn 0;\n     }\n \n-  if (TREE_CODE (exp) != COMPONENT_REF && TREE_CODE (exp) != ARRAY_REF\n-      && TREE_CODE (exp) != BIT_FIELD_REF)\n-    return 0;\n \n   inner = get_inner_reference (exp, pbitsize, pbitpos, &offset, pmode,\n \t\t\t       punsignedp, pvolatilep);\n-  if (inner == exp || *pbitsize < 0 || offset != 0)\n+  if ((inner == exp && and_mask == 0)\n+      || *pbitsize < 0 || offset != 0)\n     return 0;\n   \n   /* Compute the mask to access the bitfield.  */\n@@ -2479,12 +2478,12 @@ all_ones_mask_p (mask, size)\n   TREE_TYPE (tmask) = signed_type (type);\n   force_fit_type (tmask, 0);\n   return\n-    operand_equal_p (mask, \n-\t\t     const_binop (RSHIFT_EXPR,\n-\t\t\t\t  const_binop (LSHIFT_EXPR, tmask,\n-\t\t\t\t\t       size_int (precision - size), 0),\n-\t\t\t\t  size_int (precision - size), 0),\n-\t\t     0);\n+    tree_int_cst_equal (mask, \n+\t\t\tconst_binop (RSHIFT_EXPR,\n+\t\t\t\t     const_binop (LSHIFT_EXPR, tmask,\n+\t\t\t\t\t\t  size_int (precision - size),\n+\t\t\t\t\t\t  0),\n+\t\t\t\t     size_int (precision - size), 0));\n }\n \n /* Subroutine for fold_truthop: determine if an operand is simple enough\n@@ -2640,6 +2639,36 @@ range_test (jcode, type, lo_code, hi_code, var, lo_cst, hi_cst)\n \t\t\t       const_binop (MINUS_EXPR, hi_cst, lo_cst, 0))));\n }\n \f\n+/* Subroutine for fold_truthop: C is an INTEGER_CST interpreted as a P\n+   bit value.  Arrange things so the extra bits will be set to zero if and]\n+   only if C is signed-extended to its full width.  */\n+\n+static tree\n+unextend (c, p, unsignedp)\n+     tree c;\n+     int p;\n+     int unsignedp;\n+{\n+  tree type = TREE_TYPE (c);\n+  int modesize = GET_MODE_BITSIZE (TYPE_MODE (type));\n+  tree temp;\n+\n+  if (p == modesize || unsignedp)\n+    return c;\n+\n+  if (TREE_UNSIGNED (type))\n+    c = convert (signed_type (type), c);\n+\n+  /* We work by getting just the sign bit into the low-order bit, then\n+     into the high-order bit, then sign-extened.  We then XOR that value\n+     with C.  */\n+  temp = const_binop (RSHIFT_EXPR, c, size_int (p - 1), 0);\n+  temp = const_binop (BIT_AND_EXPR, temp, size_int (1), 0);\n+  temp = const_binop (LSHIFT_EXPR, temp, size_int (modesize - 1), 0);\n+  temp = const_binop (RSHIFT_EXPR, temp, size_int (modesize - p - 1), 0);\n+  return convert (type, const_binop (BIT_XOR_EXPR, c, temp, 0));\n+}\n+\f\n /* Find ways of folding logical expressions of LHS and RHS:\n    Try to merge two comparisons to the same innermost item.\n    Look for range tests like \"ch >= '0' && ch <= '9'\".\n@@ -2855,20 +2884,39 @@ fold_truthop (code, truth_type, lhs, rhs)\n   rl_mask = const_binop (LSHIFT_EXPR, convert (type, rl_mask),\n \t\t\t size_int (xrl_bitpos), 0);\n \n-  /* Make sure the constants are interpreted as unsigned, so we\n-     don't have sign bits outside the range of their type.  */\n-\n   if (l_const)\n     {\n-      l_const = convert (unsigned_type (TREE_TYPE (l_const)), l_const);\n-      l_const = const_binop (LSHIFT_EXPR, convert (type, l_const),\n-\t\t\t     size_int (xll_bitpos), 0);\n+      l_const = convert (type, unextend (l_const, ll_bitsize, ll_unsignedp));\n+      l_const = const_binop (LSHIFT_EXPR, l_const, size_int (xll_bitpos), 0);\n+      if (! integer_zerop (const_binop (BIT_AND_EXPR, l_const,\n+\t\t\t\t\tfold (build1 (BIT_NOT_EXPR,\n+\t\t\t\t\t\t      type, ll_mask)),\n+\t\t\t\t\t0)))\n+\t{\n+\t  warning (\"comparison is always %s\",\n+\t\t   wanted_code == NE_EXPR ? \"one\" : \"zero\");\n+\t  \n+\t  return convert (truth_type,\n+\t\t\t  wanted_code == NE_EXPR\n+\t\t\t  ? integer_one_node : integer_zero_node);\n+\t}\n     }\n   if (r_const)\n     {\n-      r_const = convert (unsigned_type (TREE_TYPE (r_const)), r_const);\n-      r_const = const_binop (LSHIFT_EXPR, convert (type, r_const),\n-\t\t\t     size_int (xrl_bitpos), 0);\n+      r_const = convert (type, unextend (r_const, rl_bitsize, rl_unsignedp));\n+      r_const = const_binop (LSHIFT_EXPR, r_const, size_int (xrl_bitpos), 0);\n+      if (! integer_zerop (const_binop (BIT_AND_EXPR, r_const,\n+\t\t\t\t\tfold (build1 (BIT_NOT_EXPR,\n+\t\t\t\t\t\t      type, rl_mask)),\n+\t\t\t\t\t0)))\n+\t{\n+\t  warning (\"comparison is always %s\",\n+\t\t   wanted_code == NE_EXPR ? \"one\" : \"zero\");\n+\t  \n+\t  return convert (truth_type,\n+\t\t\t  wanted_code == NE_EXPR\n+\t\t\t  ? integer_one_node : integer_zero_node);\n+\t}\n     }\n \n   /* If the right sides are not constant, do the same for it.  Also,"}]}