{"sha": "289f860fe62423a66e43989688e1d24bcdb25b5e", "node_id": "C_kwDOANBUbNoAKDI4OWY4NjBmZTYyNDIzYTY2ZTQzOTg5Njg4ZTFkMjRiY2RiMjViNWU", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-06-01T11:52:21Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-06-01T14:43:59Z"}, "message": "c++: Static init guard generation\n\nThe guard generation for a static var init was overly verbose.  We can\nuse a bit of RAII and avoid some rechecking.  Also in the !cxa_atexit\ncase, the only difference is whether can become whether to use\npost-inc or pre-dec.\n\n\tgcc/cp/\n\t* decl2.cc (fix_temporary_vars_context_r): Use data argument\n\tfor new context.\n\t(one_static_initialization_or_destruction): Adjust tree walk\n\tcall.  Refactor guard generation.", "tree": {"sha": "ee71bc733bf385e7a159681baff6e45bb6fb0f8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee71bc733bf385e7a159681baff6e45bb6fb0f8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/289f860fe62423a66e43989688e1d24bcdb25b5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/289f860fe62423a66e43989688e1d24bcdb25b5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/289f860fe62423a66e43989688e1d24bcdb25b5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/289f860fe62423a66e43989688e1d24bcdb25b5e/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4d702fb3c1e2f6e1bc8711da81bff59543b1b19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4d702fb3c1e2f6e1bc8711da81bff59543b1b19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4d702fb3c1e2f6e1bc8711da81bff59543b1b19"}], "stats": {"total": 111, "additions": 42, "deletions": 69}, "files": [{"sha": "974afe798b6599895306ae448a5f82cd47633162", "filename": "gcc/cp/decl2.cc", "status": "modified", "additions": 42, "deletions": 69, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/289f860fe62423a66e43989688e1d24bcdb25b5e/gcc%2Fcp%2Fdecl2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/289f860fe62423a66e43989688e1d24bcdb25b5e/gcc%2Fcp%2Fdecl2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.cc?ref=289f860fe62423a66e43989688e1d24bcdb25b5e", "patch": "@@ -4085,34 +4085,25 @@ get_priority_info (int priority)\n \t\t\t\t\t\t    || DECL_ONE_ONLY (decl) \\\n \t\t\t\t\t\t    || DECL_WEAK (decl)))\n \n-/* Called from one_static_initialization_or_destruction(),\n-   via walk_tree.\n-   Walks the initializer list of a global variable and looks for\n+/* Walks the initializer list of a global variable and looks for\n    temporary variables (DECL_NAME() == NULL and DECL_ARTIFICIAL != 0)\n-   and that have their DECL_CONTEXT() == NULL.\n-   For each such temporary variable, set their DECL_CONTEXT() to\n-   the current function. This is necessary because otherwise\n-   some optimizers (enabled by -O2 -fprofile-arcs) might crash\n-   when trying to refer to a temporary variable that does not have\n-   it's DECL_CONTECT() properly set.  */\n+   and that have their DECL_CONTEXT() == NULL.  For each such\n+   temporary variable, set their DECL_CONTEXT() to CTX -- the\n+   initializing function. This is necessary because otherwise some\n+   optimizers (enabled by -O2 -fprofile-arcs) might crash when trying\n+   to refer to a temporary variable that does not have its\n+   DECL_CONTEXT() properly set.  */\n+\n static tree \n fix_temporary_vars_context_r (tree *node,\n \t\t\t      int  * /*unused*/,\n-\t\t\t      void * /*unused1*/)\n+\t\t\t      void *ctx)\n {\n-  gcc_assert (current_function_decl);\n-\n   if (TREE_CODE (*node) == BIND_EXPR)\n-    {\n-      tree var;\n-\n-      for (var = BIND_EXPR_VARS (*node); var; var = DECL_CHAIN (var))\n-\tif (VAR_P (var)\n-\t  && !DECL_NAME (var)\n-\t  && DECL_ARTIFICIAL (var)\n-\t  && !DECL_CONTEXT (var))\n-\t  DECL_CONTEXT (var) = current_function_decl;\n-    }\n+    for (tree var = BIND_EXPR_VARS (*node); var; var = DECL_CHAIN (var))\n+      if (VAR_P (var) && !DECL_NAME (var)\n+\t  && DECL_ARTIFICIAL (var) && !DECL_CONTEXT (var))\n+\tDECL_CONTEXT (var) = tree (ctx);\n \n   return NULL_TREE;\n }\n@@ -4124,9 +4115,6 @@ fix_temporary_vars_context_r (tree *node,\n static void\n one_static_initialization_or_destruction (bool initp, tree decl, tree init)\n {\n-  tree guard_if_stmt = NULL_TREE;\n-  tree guard;\n-\n   /* If we are supposed to destruct and there's a trivial destructor,\n      nothing has to be done.  */\n   if (!initp\n@@ -4150,7 +4138,7 @@ one_static_initialization_or_destruction (bool initp, tree decl, tree init)\n      of the temporaries are set to the current function decl.  */\n   cp_walk_tree_without_duplicates (&init,\n \t\t\t\t   fix_temporary_vars_context_r,\n-\t\t\t\t   NULL);\n+\t\t\t\t   current_function_decl);\n \n   /* Because of:\n \n@@ -4171,62 +4159,50 @@ one_static_initialization_or_destruction (bool initp, tree decl, tree init)\n     }\n \n   /* Assume we don't need a guard.  */\n-  guard = NULL_TREE;\n+  tree guard_if_stmt = NULL_TREE;\n+\n   /* We need a guard if this is an object with external linkage that\n      might be initialized in more than one place.  (For example, a\n      static data member of a template, when the data member requires\n      construction.)  */\n   if (NEEDS_GUARD_P (decl))\n     {\n+      tree guard = get_guard (decl);\n       tree guard_cond;\n \n-      guard = get_guard (decl);\n-\n-      /* When using __cxa_atexit, we just check the GUARD as we would\n-\t for a local static.  */\n       if (flag_use_cxa_atexit)\n \t{\n-\t  /* When using __cxa_atexit, we never try to destroy\n+\t  /* When using __cxa_atexit, we just check the GUARD as we\n+\t     would for a local static.  We never try to destroy\n \t     anything from a static destructor.  */\n \t  gcc_assert (initp);\n \t  guard_cond = get_guard_cond (guard, false);\n \t}\n-      /* If we don't have __cxa_atexit, then we will be running\n-\t destructors from .fini sections, or their equivalents.  So,\n-\t we need to know how many times we've tried to initialize this\n-\t object.  We do initializations only if the GUARD is zero,\n-\t i.e., if we are the first to initialize the variable.  We do\n-\t destructions only if the GUARD is one, i.e., if we are the\n-\t last to destroy the variable.  */\n-      else if (initp)\n-\tguard_cond\n-\t  = cp_build_binary_op (input_location,\n-\t\t\t\tEQ_EXPR,\n-\t\t\t\tcp_build_unary_op (PREINCREMENT_EXPR,\n-\t\t\t\t\t\t   guard,\n-\t\t\t\t\t\t   /*noconvert=*/true,\n-\t\t\t\t\t\t   tf_warning_or_error),\n-\t\t\t\tinteger_one_node,\n-\t\t\t\ttf_warning_or_error);\n       else\n-\tguard_cond\n-\t  = cp_build_binary_op (input_location,\n-\t\t\t\tEQ_EXPR,\n-\t\t\t\tcp_build_unary_op (PREDECREMENT_EXPR,\n-\t\t\t\t\t\t   guard,\n-\t\t\t\t\t\t   /*noconvert=*/true,\n-\t\t\t\t\t\t   tf_warning_or_error),\n-\t\t\t\tinteger_zero_node,\n-\t\t\t\ttf_warning_or_error);\n+\t{\n+\t  /* If we don't have __cxa_atexit, then we will be running\n+\t     destructors from .fini sections, or their equivalents.\n+\t     So, we need to know how many times we've tried to\n+\t     initialize this object.  We do initializations only if\n+\t     the GUARD was or becomes zero (initp vs !initp\n+\t     respectively).  */\n+\t  guard_cond = cp_build_unary_op (initp ? POSTINCREMENT_EXPR\n+\t\t\t\t\t  : PREDECREMENT_EXPR,\n+\t\t\t\t\t  guard,\n+\t\t\t\t\t  /*noconvert=*/true,\n+\t\t\t\t\t  tf_warning_or_error);\n+\t  guard_cond = cp_build_binary_op (input_location, EQ_EXPR, guard_cond, \n+\t\t\t\t\t   integer_zero_node,\n+\t\t\t\t\t   tf_warning_or_error);\n+\t}\n \n       guard_if_stmt = begin_if_stmt ();\n       finish_if_stmt_cond (guard_cond, guard_if_stmt);\n-    }\n \n-  /* If we're using __cxa_atexit, we have not already set the GUARD,\n-     so we must do so now.  */\n-  if (guard && initp && flag_use_cxa_atexit)\n-    finish_expr_stmt (set_guard (guard));\n+      if (flag_use_cxa_atexit)\n+\t/* Set the GUARD now.  */\n+\tfinish_expr_stmt (set_guard (guard));\n+    }\n \n   /* Perform the initialization or destruction.  */\n   if (initp)\n@@ -4235,11 +4211,8 @@ one_static_initialization_or_destruction (bool initp, tree decl, tree init)\n \t{\n \t  finish_expr_stmt (init);\n \t  if (sanitize_flags_p (SANITIZE_ADDRESS, decl))\n-\t    {\n-\t      varpool_node *vnode = varpool_node::get (decl);\n-\t      if (vnode)\n-\t\tvnode->dynamically_initialized = 1;\n-\t    }\n+\t    if (varpool_node *vnode = varpool_node::get (decl))\n+\t      vnode->dynamically_initialized = 1;\n \t}\n \n       /* If we're using __cxa_atexit, register a function that calls the\n@@ -4251,7 +4224,7 @@ one_static_initialization_or_destruction (bool initp, tree decl, tree init)\n     finish_expr_stmt (build_cleanup (decl));\n \n   /* Finish the guard if-stmt, if necessary.  */\n-  if (guard)\n+  if (guard_if_stmt)\n     {\n       finish_then_clause (guard_if_stmt);\n       finish_if_stmt (guard_if_stmt);"}]}