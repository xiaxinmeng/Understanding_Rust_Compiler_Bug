{"sha": "d055668e809b15b17f53124efd6a093c3b97ec2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA1NTY2OGU4MDliMTViMTdmNTMxMjRlZmQ2YTA5M2MzYjk3ZWMyZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-04-16T19:34:02Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-04-16T19:34:02Z"}, "message": "alpha.c (SYMBOL_FLAG_NEAR, [...]): New.\n\n        * config/alpha/alpha.c (SYMBOL_FLAG_NEAR, SYMBOL_FLAG_SAMEGP): New.\n        (samegp_function_operand): Use SYMBOL_FLAG_SAMEGP.\n        (direct_call_operand): Use SYMBOL_FLAG_NEAR.\n        (local_symbolic_operand): Use SYMBOL_REF_LOCAL_P.\n        (small_symbolic_operand): Use SYMBOL_REF_SMALL_P.\n        (global_symbolic_operand): Similarly.\n        (tls_symbolic_operand_1): Use SYMBOL_REF_TLS_MODEL.\n        (tls_symbolic_operand_type): Likewise.\n        (alpha_encode_section_info): Use default_encode_section_info.\n        (alpha_strip_name_encoding): Remove.\n        (get_tls_get_addr): Split out from ...\n        (alpha_legitimize_address): ... here.\n        (alpha_emit_xfloating_libcall): Use init_one_libfunc.\n        (get_some_local_dynamic_name_1): Use SYMBOL_REF_TLS_MODEL.\n        (alpha_initialize_trampoline): Use init_one_libfunc.\n        (alpha_setup_incoming_varargs): Mark unused parameters.\n        (alpha_initial_elimination_offset): Likewise.\n        (alpha_end_function): Use SYMBOL_FLAG_NEAR, SYMBOL_FLAG_SAMEGP.\n        (unicosmk_unique_section): Use default_strip_name_encoding.\n        (unicosmk_ssib_name, unicosmk_output_externs): Likewise.\n\nFrom-SVN: r65696", "tree": {"sha": "3954fbc5870aad5faa3af4971dc2d9c5574c14c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3954fbc5870aad5faa3af4971dc2d9c5574c14c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d055668e809b15b17f53124efd6a093c3b97ec2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d055668e809b15b17f53124efd6a093c3b97ec2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d055668e809b15b17f53124efd6a093c3b97ec2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d055668e809b15b17f53124efd6a093c3b97ec2e/comments", "author": null, "committer": null, "parents": [{"sha": "ffd25996cbbbfa8abd26b02ff4c093dbc1242241", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffd25996cbbbfa8abd26b02ff4c093dbc1242241", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffd25996cbbbfa8abd26b02ff4c093dbc1242241"}], "stats": {"total": 307, "additions": 103, "deletions": 204}, "files": [{"sha": "7812d844a234f18b4a5b8395795d8a787d3c8287", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d055668e809b15b17f53124efd6a093c3b97ec2e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d055668e809b15b17f53124efd6a093c3b97ec2e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d055668e809b15b17f53124efd6a093c3b97ec2e", "patch": "@@ -1,3 +1,26 @@\n+2003-04-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (SYMBOL_FLAG_NEAR, SYMBOL_FLAG_SAMEGP): New.\n+\t(samegp_function_operand): Use SYMBOL_FLAG_SAMEGP.\n+\t(direct_call_operand): Use SYMBOL_FLAG_NEAR.\n+\t(local_symbolic_operand): Use SYMBOL_REF_LOCAL_P.\n+\t(small_symbolic_operand): Use SYMBOL_REF_SMALL_P.\n+\t(global_symbolic_operand): Similarly.\n+\t(tls_symbolic_operand_1): Use SYMBOL_REF_TLS_MODEL.\n+\t(tls_symbolic_operand_type): Likewise.\n+\t(alpha_encode_section_info): Use default_encode_section_info.\n+\t(alpha_strip_name_encoding): Remove.\n+\t(get_tls_get_addr): Split out from ...\n+\t(alpha_legitimize_address): ... here.\n+\t(alpha_emit_xfloating_libcall): Use init_one_libfunc.\n+\t(get_some_local_dynamic_name_1): Use SYMBOL_REF_TLS_MODEL.\n+\t(alpha_initialize_trampoline): Use init_one_libfunc.\n+\t(alpha_setup_incoming_varargs): Mark unused parameters.\n+\t(alpha_initial_elimination_offset): Likewise.\n+\t(alpha_end_function): Use SYMBOL_FLAG_NEAR, SYMBOL_FLAG_SAMEGP.\n+\t(unicosmk_unique_section): Use default_strip_name_encoding.\n+\t(unicosmk_ssib_name, unicosmk_output_externs): Likewise.\n+\n 2003-04-16  Aldy Hernandez  <aldyh@redhat.com>\n \n         * config.gcc: Add t-spe for eabispe."}, {"sha": "4d5be29a8d942c5e726b55b9cc767c8d05118506", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 80, "deletions": 204, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d055668e809b15b17f53124efd6a093c3b97ec2e/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d055668e809b15b17f53124efd6a093c3b97ec2e/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=d055668e809b15b17f53124efd6a093c3b97ec2e", "patch": "@@ -171,6 +171,10 @@ static struct alpha_rtx_cost_data const alpha_rtx_cost_data[PROCESSOR_MAX] =\n   },\n };\n \n+/* Machine-specific symbol_ref flags.  */\n+#define SYMBOL_FLAG_NEAR\t(SYMBOL_FLAG_MACH_DEP << 0)\n+#define SYMBOL_FLAG_SAMEGP\t(SYMBOL_FLAG_MACH_DEP << 1)\n+\n /* Declarations of static functions.  */\n static bool alpha_function_ok_for_sibcall\n   PARAMS ((tree, tree));\n@@ -186,8 +190,8 @@ static bool alpha_in_small_data_p\n   PARAMS ((tree));\n static void alpha_encode_section_info\n   PARAMS ((tree, int));\n-static const char *alpha_strip_name_encoding\n-  PARAMS ((const char *));\n+static rtx get_tls_get_addr\n+  PARAMS ((void));\n static int some_small_symbolic_operand_1\n   PARAMS ((rtx *, void *));\n static int split_small_symbolic_operand_1\n@@ -299,8 +303,6 @@ static void vms_asm_out_destructor PARAMS ((rtx, int));\n #define TARGET_IN_SMALL_DATA_P alpha_in_small_data_p\n #undef TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO alpha_encode_section_info\n-#undef TARGET_STRIP_NAME_ENCODING\n-#define TARGET_STRIP_NAME_ENCODING alpha_strip_name_encoding\n \n #if TARGET_ABI_UNICOSMK\n static void unicosmk_asm_named_section PARAMS ((const char *, unsigned int));\n@@ -1051,7 +1053,7 @@ samegp_function_operand (op, mode)\n \n   /* Otherwise, encode_section_info recorded whether we are to treat\n      this symbol as having the same GP.  */\n-  return SYMBOL_REF_FLAG (op);\n+  return (SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_SAMEGP) != 0;\n }\n \n /* Return 1 if OP is a SYMBOL_REF for which we can make a call via bsr.  */\n@@ -1061,6 +1063,8 @@ direct_call_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n+  bool is_near;\n+\n   /* Must share the same GP.  */\n   if (!samegp_function_operand (op, mode))\n     return 0;\n@@ -1075,14 +1079,16 @@ direct_call_operand (op, mode)\n   if (!TARGET_PROFILING_NEEDS_GP && profile_flag)\n     return 0;\n \n+  is_near = (SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_NEAR) != 0;\n+\n   /* Must be \"near\" so that the branch is assumed to reach.  With\n      -msmall-text, this is true of all local symbols.  */\n   if (TARGET_SMALL_TEXT)\n-    return op->jump;\n+    return is_near;\n \n   /* Otherwise, a decl is \"near\" if it is defined in the same section.\n      See alpha_encode_section_info for commentary.  */\n-  return op->jump && decl_in_text_section (cfun->decl);\n+  return is_near && decl_in_text_section (cfun->decl);\n }\n \n /* Return true if OP is a LABEL_REF, or SYMBOL_REF or CONST referencing\n@@ -1093,8 +1099,6 @@ local_symbolic_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  const char *str;\n-\n   if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n     return 0;\n \n@@ -1109,26 +1113,7 @@ local_symbolic_operand (op, mode)\n   if (GET_CODE (op) != SYMBOL_REF)\n     return 0;\n \n-  /* Easy pickings.  */\n-  if (CONSTANT_POOL_ADDRESS_P (op) || STRING_POOL_ADDRESS_P (op))\n-    return 1;\n-\n-  /* ??? SYMBOL_REF_FLAG is set for local function symbols, but we\n-     run into problems with the rtl inliner in that the symbol was\n-     once external, but is local after inlining, which results in\n-     unrecognizable insns.  */\n-\n-  str = XSTR (op, 0);\n-\n-  /* If @[LS], then alpha_encode_section_info sez it's local.  */\n-  if (str[0] == '@' && (str[1] == 'L' || str[1] == 'S'))\n-    return 1;\n-\n-  /* If *$, then ASM_GENERATE_INTERNAL_LABEL sez it's local.  */\n-  if (str[0] == '*' && str[1] == '$')\n-    return 1;\n-\n-  return 0;\n+  return SYMBOL_REF_LOCAL_P (op) && !SYMBOL_REF_TLS_MODEL (op);\n }\n \n /* Return true if OP is a SYMBOL_REF or CONST referencing a variable\n@@ -1139,8 +1124,6 @@ small_symbolic_operand (op, mode)\n      rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  const char *str;\n-\n   if (! TARGET_SMALL_DATA)\n     return 0;\n \n@@ -1155,13 +1138,14 @@ small_symbolic_operand (op, mode)\n   if (GET_CODE (op) != SYMBOL_REF)\n     return 0;\n \n+  /* ??? There's no encode_section_info equivalent for the rtl\n+     constant pool, so SYMBOL_FLAG_SMALL never gets set.  */\n   if (CONSTANT_POOL_ADDRESS_P (op))\n     return GET_MODE_SIZE (get_pool_mode (op)) <= (unsigned) g_switch_value;\n-  else\n-    {\n-      str = XSTR (op, 0);\n-      return str[0] == '@' && str[1] == 'S';\n-    }\n+\n+  return (SYMBOL_REF_LOCAL_P (op)\n+\t  && SYMBOL_REF_SMALL_P (op)\n+\t  && SYMBOL_REF_TLS_MODEL (op) == 0);\n }\n \n /* Return true if OP is a SYMBOL_REF or CONST referencing a variable\n@@ -1172,8 +1156,6 @@ global_symbolic_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  const char *str;\n-\n   if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n     return 0;\n \n@@ -1185,12 +1167,7 @@ global_symbolic_operand (op, mode)\n   if (GET_CODE (op) != SYMBOL_REF)\n     return 0;\n \n-  if (local_symbolic_operand (op, mode))\n-    return 0;\n-\n-  /* Also verify that it's not a TLS symbol.  */\n-  str = XSTR (op, 0);\n-  return str[0] != '%' && str[0] != '@';\n+  return !SYMBOL_REF_LOCAL_P (op) && !SYMBOL_REF_TLS_MODEL (op);\n }\n \n /* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */\n@@ -1251,8 +1228,6 @@ tls_symbolic_operand_1 (op, mode, size, unspec)\n      enum machine_mode mode;\n      int size, unspec;\n {\n-  const char *str;\n-\n   if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n     return 0;\n \n@@ -1266,29 +1241,26 @@ tls_symbolic_operand_1 (op, mode, size, unspec)\n \n   if (GET_CODE (op) != SYMBOL_REF)\n     return 0;\n-  str = XSTR (op, 0);\n \n-  if (str[0] == '%')\n+  if (SYMBOL_REF_LOCAL_P (op))\n     {\n-      if (size != 64)\n+      if (alpha_tls_size > size)\n \treturn 0;\n     }\n-  else if (str[0] == '@')\n+  else\n     {\n-      if (alpha_tls_size > size)\n+      if (size != 64)\n \treturn 0;\n     }\n-  else\n-    return 0;\n \n-  switch (str[1])\n+  switch (SYMBOL_REF_TLS_MODEL (op))\n     {\n-    case 'D':\n+    case TLS_MODEL_LOCAL_DYNAMIC:\n       return unspec == UNSPEC_DTPREL;\n-    case 'T':\n+    case TLS_MODEL_INITIAL_EXEC:\n       return unspec == UNSPEC_TPREL && size == 64;\n-    case 't':\n-      return unspec == UNSPEC_TPREL && size < 64;\n+    case TLS_MODEL_LOCAL_EXEC:\n+      return unspec == UNSPEC_TPREL;\n     default:\n       abort ();\n     }\n@@ -1833,42 +1805,18 @@ static enum tls_model\n tls_symbolic_operand_type (symbol)\n      rtx symbol;\n {\n-  const char *str;\n+  enum tls_model model;\n \n   if (GET_CODE (symbol) != SYMBOL_REF)\n     return 0;\n-  str = XSTR (symbol, 0);\n+  model = SYMBOL_REF_TLS_MODEL (symbol);\n \n-  if (str[0] == '%')\n-    {\n-      /* ??? Be prepared for -ftls-model=local-dynamic.  Perhaps we shouldn't\n-\t have separately encoded local-ness.  On well, maybe the user will use\n-\t attribute visibility next time.  At least we don't crash...  */\n-      if (str[1] == 'G' || str[1] == 'D')\n-\treturn TLS_MODEL_GLOBAL_DYNAMIC;\n-      if (str[1] == 'T')\n-\treturn TLS_MODEL_INITIAL_EXEC;\n-    }\n-  else if (str[0] == '@')\n-    {\n-      if (str[1] == 'D')\n-\t{\n-\t  /* Local dynamic is a waste if we're not going to combine\n-\t     the __tls_get_addr calls.  So avoid it if not optimizing.  */\n-\t  if (optimize)\n-\t    return TLS_MODEL_LOCAL_DYNAMIC;\n-\t  else\n-\t    return TLS_MODEL_GLOBAL_DYNAMIC;\n-\t}\n-      if (str[1] == 'T')\n-\treturn TLS_MODEL_INITIAL_EXEC;\n-      if (str[1] == 't')\n-\treturn TLS_MODEL_LOCAL_EXEC;\n-    }\n+  /* Local-exec with a 64-bit size is the same code as initial-exec.  */\n+  if (model == TLS_MODEL_LOCAL_EXEC && alpha_tls_size == 64)\n+    model = TLS_MODEL_INITIAL_EXEC;\n \n-  return 0;\n+  return model;\n }\n-\n \f\n /* Return true if the function DECL will be placed in the default text\n    section.  */\n@@ -1952,33 +1900,21 @@ alpha_in_small_data_p (exp)\n static void\n alpha_encode_section_info (decl, first)\n      tree decl;\n-     int first ATTRIBUTE_UNUSED;\n+     int first;\n {\n-  const char *symbol_str;\n-  bool is_local;\n-  char encoding = 0;\n-  rtx rtl, symbol;\n-\n-  rtl = DECL_P (decl) ? DECL_RTL (decl) : TREE_CST_RTL (decl);\n-\n-  /* Careful not to prod global register variables.  */\n-  if (GET_CODE (rtl) != MEM)\n-    return;\n-  symbol = XEXP (rtl, 0);\n-  if (GET_CODE (symbol) != SYMBOL_REF)\n-    return;\n-\n-  /* A variable is considered \"local\" if it is defined in this module.  */\n-  is_local = (*targetm.binds_local_p) (decl);\n-    \n+  default_encode_section_info (decl, first);\n+ \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n+      rtx symbol = XEXP (DECL_RTL (decl), 0);\n+      int flags = SYMBOL_REF_FLAGS (symbol);\n+\n       /* Mark whether the decl is \"near\" in distance.  If -msmall-text is\n \t in effect, this is trivially true of all local symbols.  */\n       if (TARGET_SMALL_TEXT)\n \t{\n-\t  if (is_local)\n-\t    symbol->jump = 1;\n+\t  if (flags & SYMBOL_FLAG_LOCAL)\n+\t    flags |= SYMBOL_FLAG_NEAR;\n \t}\n       else\n \t{\n@@ -1991,92 +1927,20 @@ alpha_encode_section_info (decl, first)\n \n \t     Delay marking public functions until they are emitted; otherwise\n \t     we don't know that they exist in this unit of translation.  */\n+\t  /* Now we *DO* have access to SYMBOL_REF_DECL.  Fixme.  */\n \t  if (!TREE_PUBLIC (decl) && decl_in_text_section (decl))\n-            symbol->jump = 1;\n+            flags |= SYMBOL_FLAG_NEAR;\n \t}\n \n       /* Indicate whether the target function shares the same GP as any\n \t function emitted in this unit of translation.  */\n       if (decl_has_samegp (decl))\n-\tSYMBOL_REF_FLAG (symbol) = 1;\n-      return;\n-    }\n-\n-  /* Early out if we're not going to do anything with this data.  */\n-  if (! TARGET_EXPLICIT_RELOCS)\n-    return;\n+\tflags |= SYMBOL_FLAG_SAMEGP;\n \n-  symbol_str = XSTR (symbol, 0);\n-\n-  /* Care for TLS variables.  */\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL (decl))\n-    {\n-      switch (decl_tls_model (decl))\n-\t{\n-\tcase TLS_MODEL_GLOBAL_DYNAMIC:\n-\t  encoding = 'G';\n-\t  break;\n-\tcase TLS_MODEL_LOCAL_DYNAMIC:\n-\t  encoding = 'D';\n-\t  break;\n-\tcase TLS_MODEL_INITIAL_EXEC:\n-\t  encoding = 'T';\n-\t  break;\n-\tcase TLS_MODEL_LOCAL_EXEC:\n-\t  encoding = (alpha_tls_size == 64 ? 'T' : 't');\n-\t  break;\n-\t}\n-    }\n-  else if (is_local)\n-    {\n-      /* Determine if DECL will wind up in .sdata/.sbss.  */\n-      if (alpha_in_small_data_p (decl))\n-\tencoding = 'S';\n-      else\n-\tencoding = 'L';\n-    }\n-\n-  /* Finally, encode this into the symbol string.  */\n-  if (encoding)\n-    {\n-      char *newstr;\n-      size_t len;\n-      char want_prefix = (is_local ? '@' : '%');\n-      char other_prefix = (is_local ? '%' : '@');\n-\n-      if (symbol_str[0] == want_prefix)\n-\t{\n-\t  if (symbol_str[1] == encoding)\n-\t    return;\n-\t  symbol_str += 2;\n-\t}\n-      else if (symbol_str[0] == other_prefix)\n-\tsymbol_str += 2;\n-\n-      len = strlen (symbol_str) + 1;\n-      newstr = alloca (len + 2);\n-\n-      newstr[0] = want_prefix;\n-      newstr[1] = encoding;\n-      memcpy (newstr + 2, symbol_str, len);\n-\t  \n-      XSTR (symbol, 0) = ggc_alloc_string (newstr, len + 2 - 1);\n+      SYMBOL_REF_FLAGS (symbol) = flags;\n     }\n }\n \n-/* Undo the effects of the above.  */\n-\n-static const char *\n-alpha_strip_name_encoding (str)\n-     const char *str;\n-{\n-  if (str[0] == '@' || str[0] == '%')\n-    str += 2;\n-  if (str[0] == '*')\n-    str++;\n-  return str;\n-}\n-\n #if TARGET_ABI_OPEN_VMS\n static bool\n alpha_linkage_symbol_p (symname)\n@@ -2208,6 +2072,18 @@ alpha_legitimate_address_p (mode, x, strict)\n   return false;\n }\n \n+/* Build the SYMBOL_REF for __tls_get_addr.  */\n+\n+static GTY(()) rtx tls_get_addr_libfunc;\n+\n+static rtx\n+get_tls_get_addr ()\n+{\n+  if (!tls_get_addr_libfunc)\n+    tls_get_addr_libfunc = init_one_libfunc (\"__tls_get_addr\");\n+  return tls_get_addr_libfunc;\n+}\n+\n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.  */\n \n@@ -2275,7 +2151,7 @@ alpha_legitimize_address (x, scratch, mode)\n \n \t  r0 = gen_rtx_REG (Pmode, 0);\n \t  r16 = gen_rtx_REG (Pmode, 16);\n-\t  tga = gen_rtx_SYMBOL_REF (Pmode, \"__tls_get_addr\");\n+\t  tga = get_tls_get_addr ();\n \t  dest = gen_reg_rtx (Pmode);\n \t  seq = GEN_INT (alpha_next_sequence_number++);\n \t  \n@@ -2296,7 +2172,7 @@ alpha_legitimize_address (x, scratch, mode)\n \n \t  r0 = gen_rtx_REG (Pmode, 0);\n \t  r16 = gen_rtx_REG (Pmode, 16);\n-\t  tga = gen_rtx_SYMBOL_REF (Pmode, \"__tls_get_addr\");\n+\t  tga = get_tls_get_addr ();\n \t  scratch = gen_reg_rtx (Pmode);\n \t  seq = GEN_INT (alpha_next_sequence_number++);\n \n@@ -4233,7 +4109,7 @@ alpha_emit_xfloating_libcall (func, target, operands, noperands, equiv)\n       abort ();\n     }\n \n-  tmp = gen_rtx_MEM (QImode, gen_rtx_SYMBOL_REF (Pmode, (char *) func));\n+  tmp = gen_rtx_MEM (QImode, init_one_libfunc (func));\n   tmp = emit_call_insn (GEN_CALL_VALUE (reg, tmp, const0_rtx,\n \t\t\t\t\tconst0_rtx, const0_rtx));\n   CALL_INSN_FUNCTION_USAGE (tmp) = usage;\n@@ -5861,14 +5737,11 @@ get_some_local_dynamic_name_1 (px, data)\n {\n   rtx x = *px;\n \n-  if (GET_CODE (x) == SYMBOL_REF)\n+  if (GET_CODE (x) == SYMBOL_REF\n+      && SYMBOL_REF_TLS_MODEL (x) == TLS_MODEL_LOCAL_DYNAMIC)\n     {\n-      const char *str = XSTR (x, 0);\n-      if (str[0] == '@' && str[1] == 'D')\n-\t{\n-          cfun->machine->some_ld_name = str;\n-          return 1;\n-\t}\n+      cfun->machine->some_ld_name = XSTR (x, 0);\n+      return 1;\n     }\n \n   return 0;\n@@ -6389,7 +6262,7 @@ alpha_initialize_trampoline (tramp, fnaddr, cxt, fnofs, cxtofs, jmpofs)\n     }\n \n #ifdef TRANSFER_FROM_TRAMPOLINE\n-  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__enable_execute_stack\"),\n+  emit_library_call (init_one_libfunc (\"__enable_execute_stack\"),\n \t\t     0, VOIDmode, 1, tramp, Pmode);\n #endif\n \n@@ -6576,8 +6449,8 @@ alpha_build_va_list ()\n void   \n alpha_setup_incoming_varargs(cum, mode, type, pretend_size, no_rtl)\n      CUMULATIVE_ARGS cum;\n-     enum machine_mode mode;\n-     tree type;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     tree type ATTRIBUTE_UNUSED;\n      int *pretend_size;\n      int no_rtl;\n {\n@@ -7254,8 +7127,8 @@ alpha_sa_size ()\n    and the other its replacement, at the start of a routine.  */\n \n HOST_WIDE_INT\n-alpha_initial_elimination_offset(from, to)\n-     unsigned int from, to;\n+alpha_initial_elimination_offset (from, to)\n+     unsigned int from, to ATTRIBUTE_UNUSED;\n {\n   HOST_WIDE_INT ret;\n \n@@ -8217,16 +8090,19 @@ alpha_end_function (file, fnname, decl)\n   if ((*targetm.binds_local_p) (decl))\n     {\n       rtx symbol = XEXP (DECL_RTL (decl), 0);\n+      int flags = SYMBOL_REF_FLAGS (symbol);\n \n       /* Mark whether the decl is \"near\".  See the commentary in \n \t alpha_encode_section_info wrt the .text section.  */\n       if (decl_in_text_section (decl))\n-\tsymbol->jump = 1;\n+\tflags |= SYMBOL_FLAG_NEAR;\n \n       /* Mark whether the decl shares a GP with other functions\n \t in this unit of translation.  This is trivially true of\n \t local symbols.  */\n-      SYMBOL_REF_FLAG (symbol) = 1;\n+      flags |= SYMBOL_FLAG_SAMEGP;\n+\n+      SYMBOL_REF_FLAGS (symbol) = flags;\n     }\n \n   /* Output jump tables and the static subroutine information block.  */\n@@ -9940,7 +9816,7 @@ unicosmk_unique_section (decl, reloc)\n     abort ();\n \n   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-  name = alpha_strip_name_encoding (name);\n+  name = default_strip_name_encoding (name);\n   len = strlen (name);\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n@@ -10171,7 +10047,7 @@ unicosmk_ssib_name ()\n   x = XEXP (x, 0);\n   if (GET_CODE (x) != SYMBOL_REF)\n     abort ();\n-  fnname = alpha_strip_name_encoding (XSTR (x, 0));\n+  fnname = default_name_encoding (XSTR (x, 0));\n \n   len = strlen (fnname);\n   if (len + SSIB_PREFIX_LEN > 255)\n@@ -10347,7 +10223,7 @@ unicosmk_output_externs (file)\n       /* We have to strip the encoding and possibly remove user_label_prefix \n \t from the identifier in order to handle -fleading-underscore and\n \t explicit asm names correctly (cf. gcc.dg/asm-names-1.c).  */\n-      real_name = alpha_strip_name_encoding (p->name);\n+      real_name = default_strip_name_encoding (p->name);\n       if (len && p->name[0] == '*'\n \t  && !memcmp (real_name, user_label_prefix, len))\n \treal_name += len;"}]}