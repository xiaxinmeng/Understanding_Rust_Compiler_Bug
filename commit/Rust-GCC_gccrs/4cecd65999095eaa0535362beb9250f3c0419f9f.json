{"sha": "4cecd65999095eaa0535362beb9250f3c0419f9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNlY2Q2NTk5OTA5NWVhYTA1MzUzNjJiZWI5MjUwZjNjMDQxOWY5Zg==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-10-31T09:30:47Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-10-31T09:30:47Z"}, "message": "tree-vect-slp.c (vect_get_and_check_slp_defs): New parameter SWAP.\n\n\t* tree-vect-slp.c (vect_get_and_check_slp_defs): New parameter SWAP.\n\tCheck slp defs for COND_EXPR by swapping/inverting operands if the\n\tnew parameter SWAP indicates so.\n\t(vect_build_slp_tree_1): New parameter SWAP.  Check COND_EXPR stmt\n\tis isomorphic to the first stmt via swapping/inverting.  Store swap\n\tinformation in the new parameter SWAP.\n\t(vect_build_slp_tree): New local array SWAP and pass it to function\n\tvect_build_slp_tree_1.  Cleanup result handling code for function\n\tcall to vect_get_and_check_slp_defs.  Skip operand swapping if the\n\torder of operands has been fixed as indicated by SWAP[i].\n\nFrom-SVN: r241697", "tree": {"sha": "e2dfec9e68a00954582016008f3b79b31ce5804a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2dfec9e68a00954582016008f3b79b31ce5804a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cecd65999095eaa0535362beb9250f3c0419f9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cecd65999095eaa0535362beb9250f3c0419f9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cecd65999095eaa0535362beb9250f3c0419f9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cecd65999095eaa0535362beb9250f3c0419f9f/comments", "author": null, "committer": null, "parents": [{"sha": "2c6a05b15083a92a3813783be0e86f0224ec2ba3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c6a05b15083a92a3813783be0e86f0224ec2ba3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c6a05b15083a92a3813783be0e86f0224ec2ba3"}], "stats": {"total": 149, "additions": 106, "deletions": 43}, "files": [{"sha": "ddd004900b8c2830a13fd4f9dcff2116485a1f2d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cecd65999095eaa0535362beb9250f3c0419f9f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cecd65999095eaa0535362beb9250f3c0419f9f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4cecd65999095eaa0535362beb9250f3c0419f9f", "patch": "@@ -1,3 +1,16 @@\n+2016-10-31  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): New parameter SWAP.\n+\tCheck slp defs for COND_EXPR by swapping/inverting operands if the\n+\tnew parameter SWAP indicates so.\n+\t(vect_build_slp_tree_1): New parameter SWAP.  Check COND_EXPR stmt\n+\tis isomorphic to the first stmt via swapping/inverting.  Store swap\n+\tinformation in the new parameter SWAP.\n+\t(vect_build_slp_tree): New local array SWAP and pass it to function\n+\tvect_build_slp_tree_1.  Cleanup result handling code for function\n+\tcall to vect_get_and_check_slp_defs.  Skip operand swapping if the\n+\torder of operands has been fixed as indicated by SWAP[i].\n+\n 2016-10-31  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-vect-data-refs.c (vect_slp_analyze_node_dependences): Skip"}, {"sha": "62f060c2c81fcef57324b6c02b5d352c7ba4c97c", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 93, "deletions": 43, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cecd65999095eaa0535362beb9250f3c0419f9f/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cecd65999095eaa0535362beb9250f3c0419f9f/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=4cecd65999095eaa0535362beb9250f3c0419f9f", "patch": "@@ -207,14 +207,20 @@ vect_get_place_in_interleaving_chain (gimple *stmt, gimple *first_stmt)\n \n /* Get the defs for the rhs of STMT (collect them in OPRNDS_INFO), check that\n    they are of a valid type and that they match the defs of the first stmt of\n-   the SLP group (stored in OPRNDS_INFO).  If there was a fatal error\n-   return -1, if the error could be corrected by swapping operands of the\n-   operation return 1, if everything is ok return 0.  */\n+   the SLP group (stored in OPRNDS_INFO).  This function tries to match stmts\n+   by swapping operands of STMT when possible.  Non-zero *SWAP indicates swap\n+   is required for cond_expr stmts.  Specifically, *SWAP is 1 if STMT is cond\n+   and operands of comparison need to be swapped; *SWAP is 2 if STMT is cond\n+   and code of comparison needs to be inverted.  If there is any operand swap\n+   in this function, *SWAP is set to non-zero value.\n+   If there was a fatal error return -1; if the error could be corrected by\n+   swapping operands of father node of this one, return 1; if everything is\n+   ok return 0.  */\n \n-static int \n-vect_get_and_check_slp_defs (vec_info *vinfo,\n+static int\n+vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \t\t\t     gimple *stmt, unsigned stmt_num,\n-                             vec<slp_oprnd_info> *oprnds_info)\n+\t\t\t     vec<slp_oprnd_info> *oprnds_info)\n {\n   tree oprnd;\n   unsigned int i, number_of_oprnds;\n@@ -237,11 +243,12 @@ vect_get_and_check_slp_defs (vec_info *vinfo,\n     {\n       enum tree_code code = gimple_assign_rhs_code (stmt);\n       number_of_oprnds = gimple_num_ops (stmt) - 1;\n+      /* Swap can only be done for cond_expr if asked to, otherwise we\n+\t could result in different comparison code to the first stmt.  */\n       if (gimple_assign_rhs_code (stmt) == COND_EXPR\n \t  && COMPARISON_CLASS_P (gimple_assign_rhs1 (stmt)))\n \t{\n \t  first_op_cond = true;\n-\t  commutative = true;\n \t  number_of_oprnds++;\n \t}\n       else\n@@ -250,20 +257,24 @@ vect_get_and_check_slp_defs (vec_info *vinfo,\n   else\n     return -1;\n \n-  bool swapped = false;\n+  bool swapped = (*swap != 0);\n+  gcc_assert (!swapped || first_op_cond);\n   for (i = 0; i < number_of_oprnds; i++)\n     {\n again:\n       if (first_op_cond)\n \t{\n-\t  if (i == 0 || i == 1)\n-\t    oprnd = TREE_OPERAND (gimple_op (stmt, first_op_idx),\n-\t\t\t\t  swapped ? !i : i);\n+\t  /* Map indicating how operands of cond_expr should be swapped.  */\n+\t  int maps[3][4] = {{0, 1, 2, 3}, {1, 0, 2, 3}, {0, 1, 3, 2}};\n+\t  int *map = maps[*swap];\n+\n+\t  if (i < 2)\n+\t    oprnd = TREE_OPERAND (gimple_op (stmt, first_op_idx), map[i]);\n \t  else\n-\t    oprnd = gimple_op (stmt, first_op_idx + i - 1);\n+\t    oprnd = gimple_op (stmt, map[i]);\n \t}\n       else\n-        oprnd = gimple_op (stmt, first_op_idx + (swapped ? !i : i));\n+\toprnd = gimple_op (stmt, first_op_idx + (swapped ? !i : i));\n \n       oprnd_info = (*oprnds_info)[i];\n \n@@ -431,9 +442,25 @@ vect_get_and_check_slp_defs (vec_info *vinfo,\n       if (first_op_cond)\n \t{\n \t  tree cond = gimple_assign_rhs1 (stmt);\n-\t  swap_ssa_operands (stmt, &TREE_OPERAND (cond, 0),\n-\t\t\t     &TREE_OPERAND (cond, 1));\n-\t  TREE_SET_CODE (cond, swap_tree_comparison (TREE_CODE (cond)));\n+\t  enum tree_code code = TREE_CODE (cond);\n+\n+\t  /* Swap.  */\n+\t  if (*swap == 1)\n+\t    {\n+\t      swap_ssa_operands (stmt, &TREE_OPERAND (cond, 0),\n+\t\t\t\t &TREE_OPERAND (cond, 1));\n+\t      TREE_SET_CODE (cond, swap_tree_comparison (code));\n+\t    }\n+\t  /* Invert.  */\n+\t  else\n+\t    {\n+\t      swap_ssa_operands (stmt, gimple_assign_rhs2_ptr (stmt),\n+\t\t\t\t gimple_assign_rhs3_ptr (stmt));\n+\t      bool honor_nans = HONOR_NANS (TREE_OPERAND (cond, 0));\n+\t      code = invert_tree_comparison (TREE_CODE (cond), honor_nans);\n+\t      gcc_assert (code != ERROR_MARK);\n+\t      TREE_SET_CODE (cond, code);\n+\t    }\n \t}\n       else\n \tswap_ssa_operands (stmt, gimple_assign_rhs1_ptr (stmt),\n@@ -446,6 +473,7 @@ vect_get_and_check_slp_defs (vec_info *vinfo,\n \t}\n     }\n \n+  *swap = swapped;\n   return 0;\n }\n \n@@ -455,10 +483,17 @@ vect_get_and_check_slp_defs (vec_info *vinfo,\n    true if they are, otherwise return false and indicate in *MATCHES\n    which stmts are not isomorphic to the first one.  If MATCHES[0]\n    is false then this indicates the comparison could not be\n-   carried out or the stmts will never be vectorized by SLP.  */\n+   carried out or the stmts will never be vectorized by SLP.\n+\n+   Note COND_EXPR is possibly ismorphic to another one after swapping its\n+   operands.  Set SWAP[i] to 1 if stmt I is COND_EXPR and isomorphic to\n+   the first stmt by swapping the two operands of comparison; set SWAP[i]\n+   to 2 if stmt I is isormorphic to the first stmt by inverting the code\n+   of comparison.  Take A1 >= B1 ? X1 : Y1 as an exmple, it can be swapped\n+   to (B1 <= A1 ? X1 : Y1); or be inverted to (A1 < B1) ? Y1 : X1.  */\n \n static bool\n-vect_build_slp_tree_1 (vec_info *vinfo,\n+vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t\t       vec<gimple *> stmts, unsigned int group_size,\n \t\t       unsigned nops, unsigned int *max_nunits,\n \t\t       bool *matches, bool *two_operators)\n@@ -482,6 +517,7 @@ vect_build_slp_tree_1 (vec_info *vinfo,\n   /* For every stmt in NODE find its def stmt/s.  */\n   FOR_EACH_VEC_ELT (stmts, i, stmt)\n     {\n+      swap[i] = 0;\n       matches[i] = false;\n \n       if (dump_enabled_p ())\n@@ -782,26 +818,44 @@ vect_build_slp_tree_1 (vec_info *vinfo,\n \t      return false;\n \t    }\n \n-          if (rhs_code == COND_EXPR)\n-            {\n-              tree cond_expr = gimple_assign_rhs1 (stmt);\n+\t  if (rhs_code == COND_EXPR)\n+\t    {\n+\t      tree cond_expr = gimple_assign_rhs1 (stmt);\n+\t      enum tree_code cond_code = TREE_CODE (cond_expr);\n+\t      enum tree_code swap_code = ERROR_MARK;\n+\t      enum tree_code invert_code = ERROR_MARK;\n \n \t      if (i == 0)\n \t\tfirst_cond_code = TREE_CODE (cond_expr);\n-              else if (first_cond_code != TREE_CODE (cond_expr))\n-                {\n-                  if (dump_enabled_p ())\n-                    {\n-                      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t      else if (TREE_CODE_CLASS (cond_code) == tcc_comparison)\n+\t\t{\n+\t\t  bool honor_nans = HONOR_NANS (TREE_OPERAND (cond_expr, 0));\n+\t\t  swap_code = swap_tree_comparison (cond_code);\n+\t\t  invert_code = invert_tree_comparison (cond_code, honor_nans);\n+\t\t}\n+\n+\t      if (first_cond_code == cond_code)\n+\t\t;\n+\t      /* Isomorphic can be achieved by swapping.  */\n+\t      else if (first_cond_code == swap_code)\n+\t\tswap[i] = 1;\n+\t      /* Isomorphic can be achieved by inverting.  */\n+\t      else if (first_cond_code == invert_code)\n+\t\tswap[i] = 2;\n+\t      else\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    {\n+\t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t       \"Build SLP failed: different\"\n \t\t\t\t       \" operation\");\n-                      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t\t\tstmt, 0);\n-                    }\n+\t\t    }\n \t\t  /* Mismatch.  */\n \t\t  continue;\n \t\t}\n-            }\n+\t    }\n \t}\n \n       matches[i] = true;\n@@ -885,7 +939,8 @@ vect_build_slp_tree (vec_info *vinfo,\n     return NULL;\n \n   bool two_operators = false;\n-  if (!vect_build_slp_tree_1 (vinfo,\n+  unsigned char *swap = XALLOCAVEC (unsigned char, group_size);\n+  if (!vect_build_slp_tree_1 (vinfo, swap,\n \t\t\t      stmts, group_size, nops,\n \t\t\t      &this_max_nunits, matches, &two_operators))\n     return NULL;\n@@ -905,18 +960,12 @@ vect_build_slp_tree (vec_info *vinfo,\n   slp_oprnd_info oprnd_info;\n   FOR_EACH_VEC_ELT (stmts, i, stmt)\n     {\n-      switch (vect_get_and_check_slp_defs (vinfo, stmt, i, &oprnds_info))\n-\t{\n-\tcase 0:\n-\t  break;\n-\tcase -1:\n-\t  matches[0] = false;\n-\t  vect_free_oprnd_info (oprnds_info);\n-\t  return NULL;\n-\tcase 1:\n-\t  matches[i] = false;\n-\t  break;\n-\t}\n+      int res = vect_get_and_check_slp_defs (vinfo, &swap[i],\n+\t\t\t\t\t     stmt, i, &oprnds_info);\n+      if (res != 0)\n+\tmatches[(res == -1) ? 0 : i] = false;\n+      if (!matches[0])\n+\tbreak;\n     }\n   for (i = 0; i < group_size; ++i)\n     if (!matches[i])\n@@ -1040,7 +1089,8 @@ vect_build_slp_tree (vec_info *vinfo,\n \t     operand order already.  */\n \t  for (j = 0; j < group_size; ++j)\n \t    if (!matches[j]\n-\t\t&& STMT_VINFO_NUM_SLP_USES (vinfo_for_stmt (stmts[j])) != 0)\n+\t\t&& (swap[j] != 0\n+\t\t    || STMT_VINFO_NUM_SLP_USES (vinfo_for_stmt (stmts[j]))))\n \t      {\n \t\tif (dump_enabled_p ())\n \t\t  {"}]}