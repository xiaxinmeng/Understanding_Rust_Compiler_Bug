{"sha": "f57fc9606845a446659826a512aa78c70fb4c842", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU3ZmM5NjA2ODQ1YTQ0NjY1OTgyNmE1MTJhYTc4YzcwZmI0Yzg0Mg==", "commit": {"author": {"name": "Torvald Riegel", "email": "triegel@redhat.com", "date": "2016-01-19T19:49:14Z"}, "committer": {"name": "Torvald Riegel", "email": "torvald@gcc.gnu.org", "date": "2016-01-19T19:49:14Z"}, "message": "libitm: Remove dead code.\n\n\t* local_type_traits: Remove file.\n\t* libitm_i.h: Don't include it anymore.\n\t(sized_integral): Remove.\n\nFrom-SVN: r232581", "tree": {"sha": "b8e4a672877d16db06c57a1337c606d36e7ee240", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8e4a672877d16db06c57a1337c606d36e7ee240"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f57fc9606845a446659826a512aa78c70fb4c842", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f57fc9606845a446659826a512aa78c70fb4c842", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f57fc9606845a446659826a512aa78c70fb4c842", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f57fc9606845a446659826a512aa78c70fb4c842/comments", "author": {"login": "triegelrh", "id": 62400967, "node_id": "MDQ6VXNlcjYyNDAwOTY3", "avatar_url": "https://avatars.githubusercontent.com/u/62400967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/triegelrh", "html_url": "https://github.com/triegelrh", "followers_url": "https://api.github.com/users/triegelrh/followers", "following_url": "https://api.github.com/users/triegelrh/following{/other_user}", "gists_url": "https://api.github.com/users/triegelrh/gists{/gist_id}", "starred_url": "https://api.github.com/users/triegelrh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/triegelrh/subscriptions", "organizations_url": "https://api.github.com/users/triegelrh/orgs", "repos_url": "https://api.github.com/users/triegelrh/repos", "events_url": "https://api.github.com/users/triegelrh/events{/privacy}", "received_events_url": "https://api.github.com/users/triegelrh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "33f488425964a50f8bcd847980c02beea8b25956", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33f488425964a50f8bcd847980c02beea8b25956", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33f488425964a50f8bcd847980c02beea8b25956"}], "stats": {"total": 1915, "additions": 6, "deletions": 1909}, "files": [{"sha": "d0f37b1ed645d707b9597e7b929c616d5a871015", "filename": "libitm/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57fc9606845a446659826a512aa78c70fb4c842/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57fc9606845a446659826a512aa78c70fb4c842/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=f57fc9606845a446659826a512aa78c70fb4c842", "patch": "@@ -1,3 +1,9 @@\n+2016-01-19  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* local_type_traits: Remove file.\n+\t* libitm_i.h: Don't include it anymore.\n+\t(sized_integral): Remove.\n+\n 2016-01-16  Torvald Riegel  <triegel@redhat.com>\n \n \t* method-gl.cc (gl_wt_dispatch::trycommit): Ensure proxy privatization"}, {"sha": "ae88ff0ecccd08256a0ea82e4f1a4ee514ecfac5", "filename": "libitm/libitm_i.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57fc9606845a446659826a512aa78c70fb4c842/libitm%2Flibitm_i.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57fc9606845a446659826a512aa78c70fb4c842/libitm%2Flibitm_i.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm_i.h?ref=f57fc9606845a446659826a512aa78c70fb4c842", "patch": "@@ -36,7 +36,6 @@\n #include <stdlib.h>\n #include <string.h>\n #include <unwind.h>\n-#include \"local_type_traits\"\n #include \"local_atomic\"\n \n /* Don't require libgcc_s.so for exceptions.  */\n@@ -49,13 +48,6 @@ namespace GTM HIDDEN {\n \n using namespace std;\n \n-// A helper template for accessing an unsigned integral of SIZE bytes.\n-template<size_t SIZE> struct sized_integral { };\n-template<> struct sized_integral<1> { typedef uint8_t type; };\n-template<> struct sized_integral<2> { typedef uint16_t type; };\n-template<> struct sized_integral<4> { typedef uint32_t type; };\n-template<> struct sized_integral<8> { typedef uint64_t type; };\n-\n typedef unsigned int gtm_word __attribute__((mode (word)));\n \n // These values are given to GTM_restart_transaction and indicate the"}, {"sha": "131e8d2199feed8b0bdbcaf139db1b97e8c2789c", "filename": "libitm/local_type_traits", "status": "removed", "additions": 0, "deletions": 1901, "changes": 1901, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f488425964a50f8bcd847980c02beea8b25956/libitm%2Flocal_type_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f488425964a50f8bcd847980c02beea8b25956/libitm%2Flocal_type_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flocal_type_traits?ref=33f488425964a50f8bcd847980c02beea8b25956", "patch": "@@ -1,1901 +0,0 @@\n-// C++0x type_traits -*- C++ -*-\n-\n-// Copyright (C) 2007-2016 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-// ????????????????????????????????????????????????????????????????????\n-//\n-// This is a copy of the libstdc++ header, with the trivial modification\n-// of ignoring the c++config.h include.  If and when the top-level build is\n-// fixed so that target libraries can be built using the newly built, we can\n-// delete this file.\n-//\n-// ????????????????????????????????????????????????????????????????????\n-\n-/** @file include/type_traits\n- *  This is a Standard C++ Library header.\n- */\n-\n-#ifndef _GLIBCXX_TYPE_TRAITS\n-#define _GLIBCXX_TYPE_TRAITS 1\n-\n-// #pragma GCC system_header\n-\n-// #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-// # include <bits/c++0x_warning.h>\n-// #else\n-// #include <bits/c++config.h>\n-\n-namespace std // _GLIBCXX_VISIBILITY(default)\n-{\n-// _GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n-  /**\n-   * @addtogroup metaprogramming\n-   * @{\n-   */\n-\n-  /// integral_constant\n-  template<typename _Tp, _Tp __v>\n-    struct integral_constant\n-    {\n-      static constexpr _Tp                  value = __v;\n-      typedef _Tp                           value_type;\n-      typedef integral_constant<_Tp, __v>   type;\n-      constexpr operator value_type() { return value; }\n-    };\n-  \n-  /// typedef for true_type\n-  typedef integral_constant<bool, true>     true_type;\n-\n-  /// typedef for false_type\n-  typedef integral_constant<bool, false>    false_type;\n-\n-  template<typename _Tp, _Tp __v>\n-    constexpr _Tp integral_constant<_Tp, __v>::value;\n-\n-  // Meta programming helper types.\n-\n-  template<bool, typename, typename>\n-    struct conditional;\n-\n-  template<typename...>\n-    struct __or_;\n-\n-  template<>\n-    struct __or_<>\n-    : public false_type\n-    { };\n-\n-  template<typename _B1>\n-    struct __or_<_B1>\n-    : public _B1\n-    { };\n-\n-  template<typename _B1, typename _B2>\n-    struct __or_<_B1, _B2>\n-    : public conditional<_B1::value, _B1, _B2>::type\n-    { };\n-\n-  template<typename _B1, typename _B2, typename _B3, typename... _Bn>\n-    struct __or_<_B1, _B2, _B3, _Bn...>\n-    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type\n-    { };\n-\n-  template<typename...>\n-    struct __and_;\n-\n-  template<>\n-    struct __and_<>\n-    : public true_type\n-    { };\n-\n-  template<typename _B1>\n-    struct __and_<_B1>\n-    : public _B1\n-    { };\n-\n-  template<typename _B1, typename _B2>\n-    struct __and_<_B1, _B2>\n-    : public conditional<_B1::value, _B2, _B1>::type\n-    { };\n-\n-  template<typename _B1, typename _B2, typename _B3, typename... _Bn>\n-    struct __and_<_B1, _B2, _B3, _Bn...>\n-    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type\n-    { };\n-\n-  template<typename _Pp>\n-    struct __not_\n-    : public integral_constant<bool, !_Pp::value>\n-    { };\n-\n-  struct __sfinae_types\n-  {\n-    typedef char __one;\n-    typedef struct { char __arr[2]; } __two;\n-  };\n-\n-  // primary type categories.\n-\n-  template<typename>\n-    struct remove_cv;\n-\n-  template<typename>\n-    struct __is_void_helper\n-    : public false_type { };\n-\n-  template<>\n-    struct __is_void_helper<void>\n-    : public true_type { };\n-\n-  /// is_void\n-  template<typename _Tp>\n-    struct is_void\n-    : public integral_constant<bool, (__is_void_helper<typename\n-\t\t\t\t      remove_cv<_Tp>::type>::value)>\n-    { };\n-\n-  template<typename>\n-    struct __is_integral_helper\n-    : public false_type { };\n-\n-  template<>\n-    struct __is_integral_helper<bool>\n-    : public true_type { };\n-  \n-  template<>\n-    struct __is_integral_helper<char>\n-    : public true_type { };\n-\n-  template<>\n-    struct __is_integral_helper<signed char>\n-    : public true_type { };\n-\n-  template<>\n-    struct __is_integral_helper<unsigned char>\n-    : public true_type { };\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  template<>\n-    struct __is_integral_helper<wchar_t>\n-    : public true_type { };\n-#endif\n-\n-  template<>\n-    struct __is_integral_helper<char16_t>\n-    : public true_type { };\n-\n-  template<>\n-    struct __is_integral_helper<char32_t>\n-    : public true_type { };\n-\n-  template<>\n-    struct __is_integral_helper<short>\n-    : public true_type { };\n-\n-  template<>\n-    struct __is_integral_helper<unsigned short>\n-    : public true_type { };\n-\n-  template<>\n-    struct __is_integral_helper<int>\n-    : public true_type { };\n-\n-  template<>\n-    struct __is_integral_helper<unsigned int>\n-    : public true_type { };\n-\n-  template<>\n-    struct __is_integral_helper<long>\n-    : public true_type { };\n-\n-  template<>\n-    struct __is_integral_helper<unsigned long>\n-    : public true_type { };\n-\n-  template<>\n-    struct __is_integral_helper<long long>\n-    : public true_type { };\n-\n-  template<>\n-    struct __is_integral_helper<unsigned long long>\n-    : public true_type { };\n-\n-#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_INT128)\n-  template<>\n-    struct __is_integral_helper<__int128>\n-    : public true_type { };\n-\n-  template<>\n-    struct __is_integral_helper<unsigned __int128>\n-    : public true_type { };\n-#endif\n-\n-  /// is_integral\n-  template<typename _Tp>\n-    struct is_integral\n-    : public integral_constant<bool, (__is_integral_helper<typename\n-\t\t\t\t      remove_cv<_Tp>::type>::value)>\n-    { };\n-\n-  template<typename>\n-    struct __is_floating_point_helper\n-    : public false_type { };\n-\n-  template<>\n-    struct __is_floating_point_helper<float>\n-    : public true_type { };\n-\n-  template<>\n-    struct __is_floating_point_helper<double>\n-    : public true_type { };\n-\n-  template<>\n-    struct __is_floating_point_helper<long double>\n-    : public true_type { };\n-\n-#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_FLOAT128)\n-  template<>\n-    struct __is_floating_point_helper<__float128>\n-    : public true_type { };\n-#endif\n-\n-  /// is_floating_point\n-  template<typename _Tp>\n-    struct is_floating_point\n-    : public integral_constant<bool, (__is_floating_point_helper<typename\n-\t\t\t\t      remove_cv<_Tp>::type>::value)>\n-    { };\n-\n-  /// is_array\n-  template<typename>\n-    struct is_array\n-    : public false_type { };\n-\n-  template<typename _Tp, size_t _Size>\n-    struct is_array<_Tp[_Size]>\n-    : public true_type { };\n-\n-  template<typename _Tp>\n-    struct is_array<_Tp[]>\n-    : public true_type { };\n-\n-  template<typename>\n-    struct __is_pointer_helper\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_pointer_helper<_Tp*>\n-    : public true_type { };\n-\n-  /// is_pointer\n-  template<typename _Tp>\n-    struct is_pointer\n-    : public integral_constant<bool, (__is_pointer_helper<typename\n-\t\t\t\t      remove_cv<_Tp>::type>::value)>\n-    { };\n-\n-  /// is_lvalue_reference\n-  template<typename>\n-    struct is_lvalue_reference\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct is_lvalue_reference<_Tp&>\n-    : public true_type { };\n-\n-  /// is_rvalue_reference\n-  template<typename>\n-    struct is_rvalue_reference\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct is_rvalue_reference<_Tp&&>\n-    : public true_type { };\n-\n-  template<typename>\n-    struct is_function;\n-\n-  template<typename>\n-    struct __is_member_object_pointer_helper\n-    : public false_type { };\n-\n-  template<typename _Tp, typename _Cp>\n-    struct __is_member_object_pointer_helper<_Tp _Cp::*>\n-    : public integral_constant<bool, !is_function<_Tp>::value> { };\n-\n-  /// is_member_object_pointer\n-  template<typename _Tp>\n-    struct is_member_object_pointer\n-    : public integral_constant<bool, (__is_member_object_pointer_helper<\n-\t\t\t\t      typename remove_cv<_Tp>::type>::value)>\n-    { };\n-\n-  template<typename>\n-    struct __is_member_function_pointer_helper\n-    : public false_type { };\n-\n-  template<typename _Tp, typename _Cp>\n-    struct __is_member_function_pointer_helper<_Tp _Cp::*>\n-    : public integral_constant<bool, is_function<_Tp>::value> { };\n-\n-  /// is_member_function_pointer\n-  template<typename _Tp>\n-    struct is_member_function_pointer\n-    : public integral_constant<bool, (__is_member_function_pointer_helper<\n-\t\t\t\t      typename remove_cv<_Tp>::type>::value)>\n-    { };\n-\n-  /// is_enum\n-  template<typename _Tp>\n-    struct is_enum\n-    : public integral_constant<bool, __is_enum(_Tp)>\n-    { };\n-\n-  /// is_union\n-  template<typename _Tp>\n-    struct is_union\n-    : public integral_constant<bool, __is_union(_Tp)>\n-    { };\n-\n-  /// is_class\n-  template<typename _Tp>\n-    struct is_class\n-    : public integral_constant<bool, __is_class(_Tp)>\n-    { };\n-\n-  /// is_function\n-  template<typename>\n-    struct is_function\n-    : public false_type { };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...)>\n-    : public true_type { };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......)>\n-    : public true_type { };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...) const>\n-    : public true_type { };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......) const>\n-    : public true_type { };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...) volatile>\n-    : public true_type { };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......) volatile>\n-    : public true_type { };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...) const volatile>\n-    : public true_type { };\n-\n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......) const volatile>\n-    : public true_type { };\n-\n-  template<typename>\n-    struct __is_nullptr_t_helper\n-    : public false_type { };\n-\n-#if 0\n-  template<>\n-    struct __is_nullptr_t_helper<nullptr_t>\n-    : public true_type { };\n-#endif\n-\n-  // __is_nullptr_t (extension).\n-  template<typename _Tp>\n-    struct __is_nullptr_t\n-    : public integral_constant<bool, (__is_nullptr_t_helper<typename\n-\t\t\t\t      remove_cv<_Tp>::type>::value)>\n-    { };\n-\n-  // composite type categories.\n-\n-  /// is_reference\n-  template<typename _Tp>\n-    struct is_reference\n-    : public __or_<is_lvalue_reference<_Tp>,\n-                   is_rvalue_reference<_Tp>>::type\n-    { };\n-\n-  /// is_arithmetic\n-  template<typename _Tp>\n-    struct is_arithmetic\n-    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type\n-    { };\n-\n-  /// is_fundamental\n-  template<typename _Tp>\n-    struct is_fundamental\n-    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>>::type\n-    { };\n-\n-  /// is_object\n-  template<typename _Tp>\n-    struct is_object\n-    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,\n-                          is_void<_Tp>>>::type\n-    { };\n-\n-  template<typename>\n-    struct is_member_pointer;\n-\n-  /// is_scalar\n-  template<typename _Tp>\n-    struct is_scalar\n-    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,\n-                   is_member_pointer<_Tp>, __is_nullptr_t<_Tp>>::type\n-    { };\n-\n-  /// is_compound\n-  template<typename _Tp>\n-    struct is_compound\n-    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };\n-\n-  /// is_member_pointer\n-  template<typename _Tp>\n-    struct __is_member_pointer_helper\n-    : public false_type { };\n-\n-  template<typename _Tp, typename _Cp>\n-    struct __is_member_pointer_helper<_Tp _Cp::*>\n-    : public true_type { };\n-\n-  template<typename _Tp>\n-    struct is_member_pointer\n-    : public integral_constant<bool, (__is_member_pointer_helper<\n-\t\t\t\t      typename remove_cv<_Tp>::type>::value)>\n-    { };\n-\n-  // type properties.\n-\n-  /// is_const\n-  template<typename>\n-    struct is_const\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct is_const<_Tp const>\n-    : public true_type { };\n-  \n-  /// is_volatile\n-  template<typename>\n-    struct is_volatile\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct is_volatile<_Tp volatile>\n-    : public true_type { };\n-\n-  /// is_trivial\n-  template<typename _Tp>\n-    struct is_trivial\n-    : public integral_constant<bool, __is_trivial(_Tp)>\n-    { };\n-\n-  /// is_trivially_copyable (still unimplemented)\n-\n-  /// is_standard_layout\n-  template<typename _Tp>\n-    struct is_standard_layout\n-    : public integral_constant<bool, __is_standard_layout(_Tp)>\n-    { };\n-\n-  /// is_pod\n-  // Could use is_standard_layout && is_trivial instead of the builtin.\n-  template<typename _Tp>\n-    struct is_pod\n-    : public integral_constant<bool, __is_pod(_Tp)>\n-    { };\n-\n-  /// is_literal_type\n-  template<typename _Tp>\n-    struct is_literal_type\n-    : public integral_constant<bool, __is_literal_type(_Tp)>\n-    { };\n-\n-  /// is_empty\n-  template<typename _Tp>\n-    struct is_empty\n-    : public integral_constant<bool, __is_empty(_Tp)>\n-    { };\n-\n-  /// is_polymorphic\n-  template<typename _Tp>\n-    struct is_polymorphic\n-    : public integral_constant<bool, __is_polymorphic(_Tp)>\n-    { };\n-\n-  /// is_abstract\n-  template<typename _Tp>\n-    struct is_abstract\n-    : public integral_constant<bool, __is_abstract(_Tp)>\n-    { };\n-\n-  template<typename _Tp,\n-\t   bool = is_integral<_Tp>::value,\n-\t   bool = is_floating_point<_Tp>::value>\n-    struct __is_signed_helper\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_signed_helper<_Tp, false, true>\n-    : public true_type { };\n-\n-  template<typename _Tp>\n-    struct __is_signed_helper<_Tp, true, false>\n-    : public integral_constant<bool, static_cast<bool>(_Tp(-1) < _Tp(0))>\n-    { };\n-\n-  /// is_signed\n-  template<typename _Tp>\n-    struct is_signed\n-    : public integral_constant<bool, __is_signed_helper<_Tp>::value>\n-    { };\n-\n-  /// is_unsigned\n-  template<typename _Tp>\n-    struct is_unsigned\n-    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type\n-    { };\n-\n-\n-  // destructible and constructible type properties\n-\n-  template<typename>\n-    struct add_rvalue_reference;\n-\n-  template<typename _Tp>\n-    typename add_rvalue_reference<_Tp>::type declval() noexcept;\n-\n-  template<typename, unsigned = 0>\n-    struct extent;\n-\n-  template<typename>\n-    struct remove_all_extents;\n-\n-  template<typename _Tp>\n-    struct __is_array_known_bounds\n-    : public integral_constant<bool, (extent<_Tp>::value > 0)>\n-    { };\n-\n-  template<typename _Tp>\n-    struct __is_array_unknown_bounds\n-    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>::type\n-    { };\n-    \n-  // In N3290 is_destructible does not say anything about function \n-  // types and abstract types, see LWG 2049. This implementation\n-  // describes function types as trivially nothrow destructible and\n-  // abstract types as destructible, iff the  explicit destructor\n-  // call expression is wellformed.\n-  struct __do_is_destructible_impl_1\n-  {\n-    template<typename _Up>\n-      struct __w { _Up __u; };\n-\n-    template<typename _Tp, typename\n-             = decltype(declval<__w<_Tp>&>().~__w<_Tp>())>\n-      static true_type __test(int);\n-\n-    template<typename>\n-      static false_type __test(...);\n-  };\n-\n-  template<typename _Tp>\n-    struct __is_destructible_impl_1\n-    : public __do_is_destructible_impl_1\n-    {\n-      typedef decltype(__test<_Tp>(0)) type;\n-    };\n-\n-  // Special implementation for abstract types\n-  struct __do_is_destructible_impl_2\n-  {\n-    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>\n-      static true_type __test(int);\n-\n-    template<typename>\n-      static false_type __test(...);\n-  };\n-\n-  template<typename _Tp>\n-    struct __is_destructible_impl_2\n-    : public __do_is_destructible_impl_2\n-    {\n-      typedef decltype(__test<_Tp>(0)) type;\n-    };\n-\n-  template<typename _Tp,\n-           bool = __or_<is_void<_Tp>,\n-                        __is_array_unknown_bounds<_Tp>>::value,\n-           bool = __or_<is_reference<_Tp>, is_function<_Tp>>::value>\n-    struct __is_destructible_safe;\n-\n-  template<typename _Tp>\n-    struct __is_destructible_safe<_Tp, false, false>\n-    : public conditional<is_abstract<_Tp>::value,\n-\t\t\t __is_destructible_impl_2<_Tp>,\n-                         __is_destructible_impl_1<_Tp>>::type::type\n-    { };\n-\n-  template<typename _Tp>\n-    struct __is_destructible_safe<_Tp, true, false>\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_destructible_safe<_Tp, false, true>\n-    : public true_type { };\n-\n-  /// is_destructible\n-  template<typename _Tp>\n-    struct is_destructible\n-    : public integral_constant<bool, (__is_destructible_safe<_Tp>::value)>\n-    { };\n-\n-  struct __do_is_default_constructible_impl\n-  {\n-    template<typename _Tp, typename = decltype(_Tp())>\n-      static true_type __test(int);\n-\n-    template<typename>\n-      static false_type __test(...);\n-  };\n-\n-  template<typename _Tp>\n-    struct __is_default_constructible_impl\n-    : public __do_is_default_constructible_impl\n-    {\n-      typedef decltype(__test<_Tp>(0)) type;\n-    };\n-\n-  template<typename _Tp>\n-    struct __is_default_constructible_atom\n-    : public __and_<__not_<is_void<_Tp>>,\n-                    __is_default_constructible_impl<_Tp>>::type\n-    { };\n-\n-  template<typename _Tp, bool = is_array<_Tp>::value>\n-    struct __is_default_constructible_safe;\n-\n-  // The following technique is a workaround for a current core language\n-  // restriction, which does not allow for array types to occur in \n-  // functional casts of the form T().  Complete arrays can be default-\n-  // constructed, if the element type is default-constructible, but \n-  // arrays with unknown bounds are not.\n-  template<typename _Tp>\n-    struct __is_default_constructible_safe<_Tp, true>\n-    : public __and_<__is_array_known_bounds<_Tp>,\n-\t\t    __is_default_constructible_atom<typename\n-                      remove_all_extents<_Tp>::type>>::type\n-    { };\n-\n-  template<typename _Tp>\n-    struct __is_default_constructible_safe<_Tp, false>\n-    : public __is_default_constructible_atom<_Tp>::type\n-    { };\n-\n-  /// is_default_constructible\n-  template<typename _Tp>\n-    struct is_default_constructible\n-    : public integral_constant<bool, (__is_default_constructible_safe<\n-\t\t\t\t      _Tp>::value)>\n-    { };\n-\n-\n-  // Implementation of is_constructible.\n-\n-  // The hardest part of this trait is the binary direct-initialization\n-  // case, because we hit into a functional cast of the form T(arg).\n-  // This implementation uses different strategies depending on the\n-  // target type to reduce the test overhead as much as possible:\n-  //\n-  // a) For a reference target type, we use a static_cast expression \n-  //    modulo its extra cases.\n-  //\n-  // b) For a non-reference target type we use a ::new expression.\n-  struct __do_is_static_castable_impl\n-  {\n-    template<typename _From, typename _To, typename\n-             = decltype(static_cast<_To>(declval<_From>()))>\n-      static true_type __test(int);\n-\n-    template<typename, typename>\n-      static false_type __test(...);\n-  };\n-\n-  template<typename _From, typename _To>\n-    struct __is_static_castable_impl\n-    : public __do_is_static_castable_impl\n-    {\n-      typedef decltype(__test<_From, _To>(0)) type;\n-    };\n-\n-  template<typename _From, typename _To>\n-    struct __is_static_castable_safe\n-    : public __is_static_castable_impl<_From, _To>::type\n-    { };\n-\n-  // __is_static_castable\n-  template<typename _From, typename _To>\n-    struct __is_static_castable\n-    : public integral_constant<bool, (__is_static_castable_safe<\n-\t\t\t\t      _From, _To>::value)>\n-    { };\n-\n-  // Implementation for non-reference types. To meet the proper\n-  // variable definition semantics, we also need to test for\n-  // is_destructible in this case.\n-  struct __do_is_direct_constructible_impl\n-  {\n-    template<typename _Tp, typename _Arg, typename\n-\t     = decltype(::new _Tp(declval<_Arg>()))>\n-      static true_type __test(int);\n-\n-    template<typename, typename>\n-      static false_type __test(...);\n-  };\n-\n-  template<typename _Tp, typename _Arg>\n-    struct __is_direct_constructible_impl\n-    : public __do_is_direct_constructible_impl\n-    {\n-      typedef decltype(__test<_Tp, _Arg>(0)) type;\n-    };\n-\n-  template<typename _Tp, typename _Arg>\n-    struct __is_direct_constructible_new_safe\n-    : public __and_<is_destructible<_Tp>,\n-                    __is_direct_constructible_impl<_Tp, _Arg>>::type\n-    { };\n-\n-  template<typename, typename>\n-    struct is_same;\n-\n-  template<typename, typename>\n-    struct is_base_of;\n-\n-  template<typename>\n-    struct remove_reference;\n-\n-  template<typename _From, typename _To, bool\n-           = is_reference<_From>::value>\n-    struct __is_base_to_derived_ref;\n-\n-  template<typename _From, typename _To>\n-    struct __is_base_to_derived_ref<_From, _To, true>\n-    {\n-      typedef typename remove_cv<typename remove_reference<_From\n-        >::type>::type __src_t;\n-      typedef typename remove_cv<typename remove_reference<_To\n-        >::type>::type __dst_t;\n-      typedef __and_<__not_<is_same<__src_t, __dst_t>>,\n-\t\t     is_base_of<__src_t, __dst_t>> type;\n-      static constexpr bool value = type::value;\n-    };\n-\n-  template<typename _From, typename _To>\n-    struct __is_base_to_derived_ref<_From, _To, false>\n-    : public false_type\n-    { };\n-\n-  template<typename _From, typename _To, bool\n-           = __and_<is_lvalue_reference<_From>,\n-                    is_rvalue_reference<_To>>::value>\n-    struct __is_lvalue_to_rvalue_ref;\n-\n-  template<typename _From, typename _To>\n-    struct __is_lvalue_to_rvalue_ref<_From, _To, true>\n-    {\n-      typedef typename remove_cv<typename remove_reference<\n-        _From>::type>::type __src_t;\n-      typedef typename remove_cv<typename remove_reference<\n-        _To>::type>::type __dst_t;\n-      typedef __or_<is_same<__src_t, __dst_t>,\n-\t\t    is_base_of<__dst_t, __src_t>> type;\n-      static constexpr bool value = type::value;\n-    };\n-\n-  template<typename _From, typename _To>\n-    struct __is_lvalue_to_rvalue_ref<_From, _To, false>\n-    : public false_type\n-    { };\n-\n-  // Here we handle direct-initialization to a reference type as \n-  // equivalent to a static_cast modulo overshooting conversions.\n-  // These are restricted to the following conversions:\n-  //    a) A glvalue of a base class to a derived class reference\n-  //    b) An lvalue to an rvalue-reference of reference-compatible \n-  //       types\n-  template<typename _Tp, typename _Arg>\n-    struct __is_direct_constructible_ref_cast\n-    : public __and_<__is_static_castable<_Arg, _Tp>,\n-                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,\n-                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>\n-                   >>>::type\n-    { };\n-\n-  template<typename _Tp, typename _Arg>\n-    struct __is_direct_constructible_new\n-    : public conditional<is_reference<_Tp>::value,\n-\t\t\t __is_direct_constructible_ref_cast<_Tp, _Arg>,\n-\t\t\t __is_direct_constructible_new_safe<_Tp, _Arg>\n-\t\t\t >::type\n-    { };\n-\n-  template<typename _Tp, typename _Arg>\n-    struct __is_direct_constructible\n-    : public integral_constant<bool, (__is_direct_constructible_new<\n-\t\t\t\t      _Tp, _Arg>::value)>\n-    { };\n-\n-  // Since default-construction and binary direct-initialization have\n-  // been handled separately, the implementation of the remaining\n-  // n-ary construction cases is rather straightforward.\n-  struct __do_is_nary_constructible_impl\n-  {\n-    template<typename _Tp, typename... _Args, typename\n-             = decltype(_Tp(declval<_Args>()...))>\n-      static true_type __test(int);\n-\n-    template<typename, typename...>\n-      static false_type __test(...);\n-  };\n-\n-  template<typename _Tp, typename... _Args>\n-    struct __is_nary_constructible_impl\n-    : public __do_is_nary_constructible_impl\n-    {\n-      typedef decltype(__test<_Tp, _Args...>(0)) type;\n-    };\n-\n-  template<typename _Tp, typename... _Args>\n-    struct __is_nary_constructible\n-    : public __is_nary_constructible_impl<_Tp, _Args...>::type\n-    {\n-      static_assert(sizeof...(_Args) > 1,\n-                    \"Only useful for > 1 arguments\");\n-    };\n-\n-  template<typename _Tp, typename... _Args>\n-    struct __is_constructible_impl\n-    : public __is_nary_constructible<_Tp, _Args...>\n-    { };\n-\n-  template<typename _Tp, typename _Arg>\n-    struct __is_constructible_impl<_Tp, _Arg>\n-    : public __is_direct_constructible<_Tp, _Arg>\n-    { };\n-\n-  template<typename _Tp>\n-    struct __is_constructible_impl<_Tp>\n-    : public is_default_constructible<_Tp>\n-    { };\n-\n-  /// is_constructible\n-  template<typename _Tp, typename... _Args>\n-    struct is_constructible\n-    : public integral_constant<bool, (__is_constructible_impl<_Tp,\n-\t\t\t\t      _Args...>::value)>\n-    { };\n-\n-  template<typename _Tp, bool = is_void<_Tp>::value>\n-    struct __is_copy_constructible_impl;\n-\n-  template<typename _Tp>\n-    struct __is_copy_constructible_impl<_Tp, true>\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_copy_constructible_impl<_Tp, false>\n-    : public is_constructible<_Tp, const _Tp&>\n-    { };\n-\n-  /// is_copy_constructible\n-  template<typename _Tp>\n-    struct is_copy_constructible\n-    : public __is_copy_constructible_impl<_Tp>\n-    { };\n-\n-  template<typename _Tp, bool = is_void<_Tp>::value>\n-    struct __is_move_constructible_impl;\n-\n-  template<typename _Tp>\n-    struct __is_move_constructible_impl<_Tp, true>\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_move_constructible_impl<_Tp, false>\n-    : public is_constructible<_Tp, _Tp&&>\n-    { };\n-\n-  /// is_move_constructible\n-  template<typename _Tp>\n-    struct is_move_constructible\n-    : public __is_move_constructible_impl<_Tp>\n-    { };\n-\n-  template<typename _Tp>\n-    struct __is_nt_default_constructible_atom\n-    : public integral_constant<bool, noexcept(_Tp())>\n-    { };\n-\n-  template<typename _Tp, bool = is_array<_Tp>::value>\n-    struct __is_nt_default_constructible_impl;\n-\n-  template<typename _Tp>\n-    struct __is_nt_default_constructible_impl<_Tp, true>\n-    : public __and_<__is_array_known_bounds<_Tp>,\n-\t\t    __is_nt_default_constructible_atom<typename\n-                      remove_all_extents<_Tp>::type>>::type\n-    { };\n-\n-  template<typename _Tp>\n-    struct __is_nt_default_constructible_impl<_Tp, false>\n-    : public __is_nt_default_constructible_atom<_Tp>\n-    { };\n-\n-  /// is_nothrow_default_constructible\n-  template<typename _Tp>\n-    struct is_nothrow_default_constructible\n-    : public __and_<is_default_constructible<_Tp>,\n-                    __is_nt_default_constructible_impl<_Tp>>::type\n-    { };\n-\n-  template<typename _Tp, typename... _Args>\n-    struct __is_nt_constructible_impl\n-    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n-    { };\n-\n-  template<typename _Tp, typename _Arg>\n-    struct __is_nt_constructible_impl<_Tp, _Arg>\n-    : public integral_constant<bool,\n-                               noexcept(static_cast<_Tp>(declval<_Arg>()))>\n-    { };\n-\n-  template<typename _Tp>\n-    struct __is_nt_constructible_impl<_Tp>\n-    : public is_nothrow_default_constructible<_Tp>\n-    { };\n-\n-  /// is_nothrow_constructible\n-  template<typename _Tp, typename... _Args>\n-    struct is_nothrow_constructible\n-    : public __and_<is_constructible<_Tp, _Args...>,\n-\t\t    __is_nt_constructible_impl<_Tp, _Args...>>::type\n-    { };\n-\n-  template<typename _Tp, bool = is_void<_Tp>::value>\n-    struct __is_nothrow_copy_constructible_impl;\n-\n-  template<typename _Tp>\n-    struct __is_nothrow_copy_constructible_impl<_Tp, true>\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_nothrow_copy_constructible_impl<_Tp, false>\n-    : public is_nothrow_constructible<_Tp, const _Tp&>\n-    { };\n-\n-  /// is_nothrow_copy_constructible\n-  template<typename _Tp>\n-    struct is_nothrow_copy_constructible\n-    : public __is_nothrow_copy_constructible_impl<_Tp>\n-    { };\n-\n-  template<typename _Tp, bool = is_void<_Tp>::value>\n-    struct __is_nothrow_move_constructible_impl;\n-\n-  template<typename _Tp>\n-    struct __is_nothrow_move_constructible_impl<_Tp, true>\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_nothrow_move_constructible_impl<_Tp, false>\n-    : public is_nothrow_constructible<_Tp, _Tp&&>\n-    { };\n-\n-  /// is_nothrow_move_constructible\n-  template<typename _Tp>\n-    struct is_nothrow_move_constructible\n-    : public __is_nothrow_move_constructible_impl<_Tp>\n-    { };\n-\n-  template<typename _Tp, typename _Up>\n-    class __is_assignable_helper\n-    : public __sfinae_types\n-    {\n-      template<typename _Tp1, typename _Up1>\n-        static decltype(declval<_Tp1>() = declval<_Up1>(), __one())\n-\t__test(int);\n-\n-      template<typename, typename>\n-        static __two __test(...);\n-\n-    public:\n-      static constexpr bool value = sizeof(__test<_Tp, _Up>(0)) == 1;\n-    };\n-\n-  /// is_assignable\n-  template<typename _Tp, typename _Up>\n-    struct is_assignable\n-    : public integral_constant<bool,\n-                               __is_assignable_helper<_Tp, _Up>::value>\n-    { };\n-\n-  template<typename _Tp, bool = is_void<_Tp>::value>\n-    struct __is_copy_assignable_impl;\n-\n-  template<typename _Tp>\n-    struct __is_copy_assignable_impl<_Tp, true>\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_copy_assignable_impl<_Tp, false>\n-    : public is_assignable<_Tp&, const _Tp&>\n-    { };\n-\n-  /// is_copy_assignable\n-  template<typename _Tp>\n-    struct is_copy_assignable\n-    : public __is_copy_assignable_impl<_Tp>\n-    { };\n-\n-  template<typename _Tp, bool = is_void<_Tp>::value>\n-    struct __is_move_assignable_impl;\n-\n-  template<typename _Tp>\n-    struct __is_move_assignable_impl<_Tp, true>\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_move_assignable_impl<_Tp, false>\n-    : public is_assignable<_Tp&, _Tp&&>\n-    { };\n-\n-  /// is_move_assignable\n-  template<typename _Tp>\n-    struct is_move_assignable\n-    : public __is_move_assignable_impl<_Tp>\n-    { };\n-\n-  template<typename _Tp, typename _Up>\n-    struct __is_nt_assignable_impl\n-    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>\n-    { };\n-\n-  /// is_nothrow_assignable\n-  template<typename _Tp, typename _Up>\n-    struct is_nothrow_assignable\n-    : public __and_<is_assignable<_Tp, _Up>,\n-\t\t    __is_nt_assignable_impl<_Tp, _Up>>::type\n-    { };\n-\n-  template<typename _Tp, bool = is_void<_Tp>::value>\n-    struct __is_nt_copy_assignable_impl;\n-\n-  template<typename _Tp>\n-    struct __is_nt_copy_assignable_impl<_Tp, true>\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_nt_copy_assignable_impl<_Tp, false>\n-    : public is_nothrow_assignable<_Tp&, const _Tp&>\n-    { };\n-\n-  /// is_nothrow_copy_assignable\n-  template<typename _Tp>\n-    struct is_nothrow_copy_assignable\n-    : public __is_nt_copy_assignable_impl<_Tp>\n-    { };\n-\n-  template<typename _Tp, bool = is_void<_Tp>::value>\n-    struct __is_nt_move_assignable_impl;\n-\n-  template<typename _Tp>\n-    struct __is_nt_move_assignable_impl<_Tp, true>\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct __is_nt_move_assignable_impl<_Tp, false>\n-    : public is_nothrow_assignable<_Tp&, _Tp&&>\n-    { };\n-\n-  /// is_nothrow_move_assignable\n-  template<typename _Tp>\n-    struct is_nothrow_move_assignable\n-    : public __is_nt_move_assignable_impl<_Tp>\n-    { };\n-\n-  /// has_trivial_default_constructor\n-  template<typename _Tp>\n-    struct has_trivial_default_constructor\n-    : public integral_constant<bool, __has_trivial_constructor(_Tp)>\n-    { };\n-\n-  /// has_trivial_copy_constructor\n-  template<typename _Tp>\n-    struct has_trivial_copy_constructor\n-    : public integral_constant<bool, __has_trivial_copy(_Tp)>\n-    { };\n-\n-  /// has_trivial_copy_assign\n-  template<typename _Tp>\n-    struct has_trivial_copy_assign\n-    : public integral_constant<bool, __has_trivial_assign(_Tp)>\n-    { };\n-\n-  /// has_trivial_destructor\n-  template<typename _Tp>\n-    struct has_trivial_destructor\n-    : public integral_constant<bool, __has_trivial_destructor(_Tp)>\n-    { };\n-\n-  /// has_virtual_destructor\n-  template<typename _Tp>\n-    struct has_virtual_destructor\n-    : public integral_constant<bool, __has_virtual_destructor(_Tp)>\n-    { };\n-\n-  \n-  // type property queries.\n-\n-  /// alignment_of\n-  template<typename _Tp>\n-    struct alignment_of\n-    : public integral_constant<size_t, __alignof__(_Tp)> { };\n-  \n-  /// rank\n-  template<typename>\n-    struct rank\n-    : public integral_constant<size_t, 0> { };\n-   \n-  template<typename _Tp, size_t _Size>\n-    struct rank<_Tp[_Size]>\n-    : public integral_constant<size_t, 1 + rank<_Tp>::value> { };\n-\n-  template<typename _Tp>\n-    struct rank<_Tp[]>\n-    : public integral_constant<size_t, 1 + rank<_Tp>::value> { };\n-\n-  /// extent\n-  template<typename, unsigned _Uint>\n-    struct extent\n-    : public integral_constant<size_t, 0> { };\n-  \n-  template<typename _Tp, unsigned _Uint, size_t _Size>\n-    struct extent<_Tp[_Size], _Uint>\n-    : public integral_constant<size_t,\n-\t\t\t       _Uint == 0 ? _Size : extent<_Tp,\n-\t\t\t\t\t\t\t   _Uint - 1>::value>\n-    { };\n-\n-  template<typename _Tp, unsigned _Uint>\n-    struct extent<_Tp[], _Uint>\n-    : public integral_constant<size_t,\n-\t\t\t       _Uint == 0 ? 0 : extent<_Tp,\n-\t\t\t\t\t\t       _Uint - 1>::value>\n-    { };\n-\n-\n-  // type relations.\n-\n-  /// is_same\n-  template<typename, typename>\n-    struct is_same\n-    : public false_type { };\n-\n-  template<typename _Tp>\n-    struct is_same<_Tp, _Tp>\n-    : public true_type { };\n-\n-  /// is_base_of\n-  template<typename _Base, typename _Derived>\n-    struct is_base_of\n-    : public integral_constant<bool, __is_base_of(_Base, _Derived)>\n-    { };\n-\n-  template<typename _From, typename _To,\n-           bool = __or_<is_void<_From>, is_function<_To>,\n-                        is_array<_To>>::value>\n-    struct __is_convertible_helper\n-    { static constexpr bool value = is_void<_To>::value; };\n-\n-  template<typename _From, typename _To>\n-    class __is_convertible_helper<_From, _To, false>\n-    : public __sfinae_types\n-    {\n-      template<typename _To1>\n-        static void __test_aux(_To1);\n-\n-      template<typename _From1, typename _To1>\n-        static decltype(__test_aux<_To1>(declval<_From1>()), __one())\n-\t__test(int);\n-\n-      template<typename, typename>\n-        static __two __test(...);\n-\n-    public:\n-      static constexpr bool value = sizeof(__test<_From, _To>(0)) == 1;\n-    };\n-\n-  /// is_convertible\n-  template<typename _From, typename _To>\n-    struct is_convertible\n-    : public integral_constant<bool,\n-\t\t\t       __is_convertible_helper<_From, _To>::value>\n-    { };\n-\n-  /// is_explicitly_convertible\n-  template<typename _From, typename _To>\n-    struct is_explicitly_convertible\n-    : public is_constructible<_To, _From>\n-    { };\n-\n-\n-  // const-volatile modifications.\n-\n-  /// remove_const\n-  template<typename _Tp>\n-    struct remove_const\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp>\n-    struct remove_const<_Tp const>\n-    { typedef _Tp     type; };\n-  \n-  /// remove_volatile\n-  template<typename _Tp>\n-    struct remove_volatile\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp>\n-    struct remove_volatile<_Tp volatile>\n-    { typedef _Tp     type; };\n-  \n-  /// remove_cv\n-  template<typename _Tp>\n-    struct remove_cv\n-    {\n-      typedef typename\n-      remove_const<typename remove_volatile<_Tp>::type>::type     type;\n-    };\n-  \n-  /// add_const\n-  template<typename _Tp>\n-    struct add_const\n-    { typedef _Tp const     type; };\n-   \n-  /// add_volatile\n-  template<typename _Tp>\n-    struct add_volatile\n-    { typedef _Tp volatile     type; };\n-  \n-  /// add_cv\n-  template<typename _Tp>\n-    struct add_cv\n-    {\n-      typedef typename\n-      add_const<typename add_volatile<_Tp>::type>::type     type;\n-    };\n-\n-\n-  // Reference transformations.\n-\n-  /// remove_reference\n-  template<typename _Tp>\n-    struct remove_reference\n-    { typedef _Tp   type; };\n-\n-  template<typename _Tp>\n-    struct remove_reference<_Tp&>\n-    { typedef _Tp   type; };\n-\n-  template<typename _Tp>\n-    struct remove_reference<_Tp&&>\n-    { typedef _Tp   type; };\n-\n-  template<typename _Tp,\n-\t   bool = __and_<__not_<is_reference<_Tp>>,\n-                         __not_<is_void<_Tp>>>::value,\n-\t   bool = is_rvalue_reference<_Tp>::value>\n-    struct __add_lvalue_reference_helper\n-    { typedef _Tp   type; };\n-\n-  template<typename _Tp>\n-    struct __add_lvalue_reference_helper<_Tp, true, false>\n-    { typedef _Tp&   type; };\n-\n-  template<typename _Tp>\n-    struct __add_lvalue_reference_helper<_Tp, false, true>\n-    { typedef typename remove_reference<_Tp>::type&   type; };\n-\n-  /// add_lvalue_reference\n-  template<typename _Tp>\n-    struct add_lvalue_reference\n-    : public __add_lvalue_reference_helper<_Tp>\n-    { };\n-\n-  template<typename _Tp,\n-           bool = __and_<__not_<is_reference<_Tp>>,\n-                         __not_<is_void<_Tp>>>::value>\n-    struct __add_rvalue_reference_helper\n-    { typedef _Tp   type; };\n-\n-  template<typename _Tp>\n-    struct __add_rvalue_reference_helper<_Tp, true>\n-    { typedef _Tp&&   type; };\n-\n-  /// add_rvalue_reference\n-  template<typename _Tp>\n-    struct add_rvalue_reference\n-    : public __add_rvalue_reference_helper<_Tp>\n-    { };\n-\n-\n-  // sign modifications.\n-\n-  // Utility for constructing identically cv-qualified types.\n-  template<typename _Unqualified, bool _IsConst, bool _IsVol>\n-    struct __cv_selector;\n-\n-  template<typename _Unqualified>\n-    struct __cv_selector<_Unqualified, false, false>\n-    { typedef _Unqualified __type; };\n-\n-  template<typename _Unqualified>\n-    struct __cv_selector<_Unqualified, false, true>\n-    { typedef volatile _Unqualified __type; };\n-\n-  template<typename _Unqualified>\n-    struct __cv_selector<_Unqualified, true, false>\n-    { typedef const _Unqualified __type; };\n-\n-  template<typename _Unqualified>\n-    struct __cv_selector<_Unqualified, true, true>\n-    { typedef const volatile _Unqualified __type; };\n-\n-  template<typename _Qualified, typename _Unqualified,\n-\t   bool _IsConst = is_const<_Qualified>::value,\n-\t   bool _IsVol = is_volatile<_Qualified>::value>\n-    class __match_cv_qualifiers\n-    {\n-      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;\n-\n-    public:\n-      typedef typename __match::__type __type; \n-    };\n-\n-  // Utility for finding the unsigned versions of signed integral types.\n-  template<typename _Tp>\n-    struct __make_unsigned\n-    { typedef _Tp __type; };\n-\n-  template<>\n-    struct __make_unsigned<char>\n-    { typedef unsigned char __type; };\n-\n-  template<>\n-    struct __make_unsigned<signed char>\n-    { typedef unsigned char __type; };\n-\n-  template<>\n-    struct __make_unsigned<short>\n-    { typedef unsigned short __type; };\n-\n-  template<>\n-    struct __make_unsigned<int>\n-    { typedef unsigned int __type; };\n-\n-  template<>\n-    struct __make_unsigned<long>\n-    { typedef unsigned long __type; };\n-\n-  template<>\n-    struct __make_unsigned<long long>\n-    { typedef unsigned long long __type; };\n-\n-#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_INT128)\n-  template<>\n-    struct __make_unsigned<__int128>\n-    { typedef unsigned __int128 __type; };\n-#endif\n-\n-  // Select between integral and enum: not possible to be both.\n-  template<typename _Tp, \n-\t   bool _IsInt = is_integral<_Tp>::value,\n-\t   bool _IsEnum = is_enum<_Tp>::value>\n-    class __make_unsigned_selector;\n-\n-  template<typename _Tp>\n-    class __make_unsigned_selector<_Tp, true, false>\n-    {\n-      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;\n-      typedef typename __unsignedt::__type __unsigned_type;\n-      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;\n-\n-    public:\n-      typedef typename __cv_unsigned::__type __type;\n-    };\n-\n-  template<typename _Tp>\n-    class __make_unsigned_selector<_Tp, false, true>\n-    {\n-      // With -fshort-enums, an enum may be as small as a char.\n-      typedef unsigned char __smallest;\n-      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);\n-      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);\n-      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);\n-      typedef conditional<__b2, unsigned int, unsigned long> __cond2;\n-      typedef typename __cond2::type __cond2_type;\n-      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;\n-      typedef typename __cond1::type __cond1_type;\n-\n-    public:\n-      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;\n-    };\n-\n-  // Given an integral/enum type, return the corresponding unsigned\n-  // integer type.\n-  // Primary template.\n-  /// make_unsigned\n-  template<typename _Tp>\n-    struct make_unsigned \n-    { typedef typename __make_unsigned_selector<_Tp>::__type type; };\n-\n-  // Integral, but don't define.\n-  template<>\n-    struct make_unsigned<bool>;\n-\n-\n-  // Utility for finding the signed versions of unsigned integral types.\n-  template<typename _Tp>\n-    struct __make_signed\n-    { typedef _Tp __type; };\n-\n-  template<>\n-    struct __make_signed<char>\n-    { typedef signed char __type; };\n-\n-  template<>\n-    struct __make_signed<unsigned char>\n-    { typedef signed char __type; };\n-\n-  template<>\n-    struct __make_signed<unsigned short>\n-    { typedef signed short __type; };\n-\n-  template<>\n-    struct __make_signed<unsigned int>\n-    { typedef signed int __type; };\n-\n-  template<>\n-    struct __make_signed<unsigned long>\n-    { typedef signed long __type; };\n-\n-  template<>\n-    struct __make_signed<unsigned long long>\n-    { typedef signed long long __type; };\n-\n-#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_INT128)\n-  template<>\n-    struct __make_signed<unsigned __int128>\n-    { typedef __int128 __type; };\n-#endif\n-\n-  // Select between integral and enum: not possible to be both.\n-  template<typename _Tp, \n-\t   bool _IsInt = is_integral<_Tp>::value,\n-\t   bool _IsEnum = is_enum<_Tp>::value>\n-    class __make_signed_selector;\n-\n-  template<typename _Tp>\n-    class __make_signed_selector<_Tp, true, false>\n-    {\n-      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;\n-      typedef typename __signedt::__type __signed_type;\n-      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;\n-\n-    public:\n-      typedef typename __cv_signed::__type __type;\n-    };\n-\n-  template<typename _Tp>\n-    class __make_signed_selector<_Tp, false, true>\n-    {\n-      // With -fshort-enums, an enum may be as small as a char.\n-      typedef signed char __smallest;\n-      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);\n-      static const bool __b1 = sizeof(_Tp) <= sizeof(signed short);\n-      static const bool __b2 = sizeof(_Tp) <= sizeof(signed int);\n-      typedef conditional<__b2, signed int, signed long> __cond2;\n-      typedef typename __cond2::type __cond2_type;\n-      typedef conditional<__b1, signed short, __cond2_type> __cond1;\n-      typedef typename __cond1::type __cond1_type;\n-\n-    public:\n-      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;\n-    };\n-\n-  // Given an integral/enum type, return the corresponding signed\n-  // integer type.\n-  // Primary template.\n-  /// make_signed\n-  template<typename _Tp>\n-    struct make_signed \n-    { typedef typename __make_signed_selector<_Tp>::__type type; };\n-\n-  // Integral, but don't define.\n-  template<>\n-    struct make_signed<bool>;\n-\n-\n-  // array modifications.\n-\n-  /// remove_extent\n-  template<typename _Tp>\n-    struct remove_extent\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp, size_t _Size>\n-    struct remove_extent<_Tp[_Size]>\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp>\n-    struct remove_extent<_Tp[]>\n-    { typedef _Tp     type; };\n-\n-  /// remove_all_extents\n-  template<typename _Tp>\n-    struct remove_all_extents\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp, size_t _Size>\n-    struct remove_all_extents<_Tp[_Size]>\n-    { typedef typename remove_all_extents<_Tp>::type     type; };\n-\n-  template<typename _Tp>\n-    struct remove_all_extents<_Tp[]>\n-    { typedef typename remove_all_extents<_Tp>::type     type; };\n-\n-\n-  // pointer modifications.\n-\n-  template<typename _Tp, typename>\n-    struct __remove_pointer_helper\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp, typename _Up>\n-    struct __remove_pointer_helper<_Tp, _Up*>\n-    { typedef _Up     type; };\n-\n-  /// remove_pointer\n-  template<typename _Tp>\n-    struct remove_pointer\n-    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>\n-    { };\n-\n-  /// add_pointer\n-  template<typename _Tp>\n-    struct add_pointer\n-    { typedef typename remove_reference<_Tp>::type*     type; };\n-\n-\n-  template<size_t _Len>\n-    struct __aligned_storage_msa\n-    { \n-      union __type\n-      {\n-\tunsigned char __data[_Len];\n-\tstruct __attribute__((__aligned__)) { } __align; \n-      };\n-    };\n-\n-  /**\n-   *  @brief Alignment type.\n-   *\n-   *  The value of _Align is a default-alignment which shall be the\n-   *  most stringent alignment requirement for any C++ object type\n-   *  whose size is no greater than _Len (3.9). The member typedef\n-   *  type shall be a POD type suitable for use as uninitialized\n-   *  storage for any object whose size is at most _Len and whose\n-   *  alignment is a divisor of _Align.\n-  */\n-  template<size_t _Len, size_t _Align =\n-\t   __alignof__(typename __aligned_storage_msa<_Len>::__type)>\n-    struct aligned_storage\n-    { \n-      union type\n-      {\n-\tunsigned char __data[_Len];\n-\tstruct __attribute__((__aligned__((_Align)))) { } __align; \n-      };\n-    };\n-\n-\n-  // Decay trait for arrays and functions, used for perfect forwarding\n-  // in make_pair, make_tuple, etc.\n-  template<typename _Up, \n-\t   bool _IsArray = is_array<_Up>::value,\n-\t   bool _IsFunction = is_function<_Up>::value> \n-    struct __decay_selector;\n-\n-  // NB: DR 705.\n-  template<typename _Up> \n-    struct __decay_selector<_Up, false, false>\n-    { typedef typename remove_cv<_Up>::type __type; };\n-\n-  template<typename _Up> \n-    struct __decay_selector<_Up, true, false>\n-    { typedef typename remove_extent<_Up>::type* __type; };\n-\n-  template<typename _Up> \n-    struct __decay_selector<_Up, false, true>\n-    { typedef typename add_pointer<_Up>::type __type; };\n-\n-  /// decay\n-  template<typename _Tp> \n-    class decay \n-    { \n-      typedef typename remove_reference<_Tp>::type __remove_type;\n-\n-    public:\n-      typedef typename __decay_selector<__remove_type>::__type type;\n-    };\n-\n-  template<typename _Tp>\n-    class reference_wrapper;\n-\n-  // Helper which adds a reference to a type when given a reference_wrapper\n-  template<typename _Tp>\n-    struct __strip_reference_wrapper\n-    {\n-      typedef _Tp __type;\n-    };\n-\n-  template<typename _Tp>\n-    struct __strip_reference_wrapper<reference_wrapper<_Tp> >\n-    {\n-      typedef _Tp& __type;\n-    };\n-\n-  template<typename _Tp>\n-    struct __strip_reference_wrapper<const reference_wrapper<_Tp> >\n-    {\n-      typedef _Tp& __type;\n-    };\n-\n-  template<typename _Tp>\n-    struct __decay_and_strip\n-    {\n-      typedef typename __strip_reference_wrapper<\n-\ttypename decay<_Tp>::type>::__type __type;\n-    };\n-\n-\n-  // Define a nested type if some predicate holds.\n-  // Primary template.\n-  /// enable_if\n-  template<bool, typename _Tp = void>\n-    struct enable_if \n-    { };\n-\n-  // Partial specialization for true.\n-  template<typename _Tp>\n-    struct enable_if<true, _Tp>\n-    { typedef _Tp type; };\n-\n-\n-  // A conditional expression, but for types. If true, first, if false, second.\n-  // Primary template.\n-  /// conditional\n-  template<bool _Cond, typename _Iftrue, typename _Iffalse>\n-    struct conditional\n-    { typedef _Iftrue type; };\n-\n-  // Partial specialization for false.\n-  template<typename _Iftrue, typename _Iffalse>\n-    struct conditional<false, _Iftrue, _Iffalse>\n-    { typedef _Iffalse type; };\n-\n-\n-  /// common_type\n-  template<typename... _Tp>\n-    struct common_type;\n-\n-  template<typename _Tp>\n-    struct common_type<_Tp>\n-    { typedef _Tp type; };\n-\n-  template<typename _Tp, typename _Up>\n-    struct common_type<_Tp, _Up>\n-    { typedef decltype(true ? declval<_Tp>() : declval<_Up>()) type; };\n-\n-  template<typename _Tp, typename _Up, typename... _Vp>\n-    struct common_type<_Tp, _Up, _Vp...>\n-    {\n-      typedef typename\n-        common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;\n-    };\n-\n-  /// underlying_type\n-  template<typename _Tp>\n-    struct underlying_type\n-    {\n-      typedef __underlying_type(_Tp) type;\n-    };\n-\n-  /// declval\n-  template<typename _Tp>\n-    struct __declval_protector\n-    {\n-      static const bool __stop = false;\n-      static typename add_rvalue_reference<_Tp>::type __delegate();\n-    };\n-\n-  template<typename _Tp>\n-    inline typename add_rvalue_reference<_Tp>::type\n-    declval() noexcept\n-    {\n-      static_assert(__declval_protector<_Tp>::__stop,\n-\t\t    \"declval() must not be used!\");\n-      return __declval_protector<_Tp>::__delegate();\n-    }\n-\n-  /// result_of\n-  template<typename _Signature>\n-    class result_of;\n-\n-  template<typename _MemPtr, typename _Arg>\n-    struct _Result_of_memobj;\n-\n-  template<typename _Res, typename _Class, typename _Arg>\n-    struct _Result_of_memobj<_Res _Class::*, _Arg>\n-    {\n-    private:\n-      typedef _Res _Class::* _Func;\n-\n-      template<typename _Tp>\n-\tstatic _Tp _S_get(const _Class&);\n-      template<typename _Tp>\n-\tstatic decltype(*declval<_Tp>()) _S_get(...);\n-        \n-    public:\n-      typedef\n-        decltype(_S_get<_Arg>(declval<_Arg>()).*declval<_Func>())\n-        __type;\n-    };\n-\n-  template<typename _MemPtr, typename _Arg, typename... _ArgTypes>\n-    struct _Result_of_memfun;\n-\n-  template<typename _Res, typename _Class, typename _Arg, typename... _Args>\n-    struct _Result_of_memfun<_Res _Class::*, _Arg, _Args...>\n-    {\n-    private:\n-      typedef _Res _Class::* _Func;\n-\n-      template<typename _Tp>\n-\tstatic _Tp _S_get(const _Class&);\n-      template<typename _Tp>\n-\tstatic decltype(*declval<_Tp>()) _S_get(...);\n-        \n-    public:\n-      typedef\n-        decltype((_S_get<_Arg>(declval<_Arg>()).*declval<_Func>())\n-            (declval<_Args>()...) )\n-        __type;\n-    };\n-\n-  template<bool, bool, typename _Functor, typename... _ArgTypes>\n-    struct _Result_of_impl;\n-\n-  template<typename _Functor, typename... _ArgTypes>\n-    struct _Result_of_impl<false, false, _Functor, _ArgTypes...>\n-    {\n-      typedef\n-        decltype( declval<_Functor>()(declval<_ArgTypes>()...) )\n-        __type;\n-    };\n-\n-  template<typename _MemPtr, typename _Arg>\n-    struct _Result_of_impl<true, false, _MemPtr, _Arg>\n-    : _Result_of_memobj<typename remove_reference<_MemPtr>::type, _Arg>\n-    {\n-      typedef typename _Result_of_memobj<\n-\ttypename remove_reference<_MemPtr>::type, _Arg>::__type\n-\t__type;\n-    };\n-\n-  template<typename _MemPtr, typename _Arg, typename... _ArgTypes>\n-    struct _Result_of_impl<false, true, _MemPtr, _Arg, _ArgTypes...>\n-    : _Result_of_memfun<typename remove_reference<_MemPtr>::type, _Arg,\n-                        _ArgTypes...>\n-    {\n-      typedef typename _Result_of_memfun<\n-\ttypename remove_reference<_MemPtr>::type, _Arg, _ArgTypes...>::__type\n-\t__type;\n-    };\n-\n-  template<typename _Functor, typename... _ArgTypes>\n-    struct result_of<_Functor(_ArgTypes...)>\n-    : _Result_of_impl<is_member_object_pointer<\n-                        typename remove_reference<_Functor>::type >::value,\n-                      is_member_function_pointer<\n-\t\t\ttypename remove_reference<_Functor>::type >::value,\n-\t\t      _Functor, _ArgTypes...>\n-    {\n-      typedef typename _Result_of_impl<\n-\tis_member_object_pointer<\n-\t  typename remove_reference<_Functor>::type >::value,\n-        is_member_function_pointer<\n-\t  typename remove_reference<_Functor>::type >::value,\n-       \t_Functor, _ArgTypes...>::__type\n-\ttype;\n-    };\n-\n-  /**\n-   *  Use SFINAE to determine if the type _Tp has a publicly-accessible\n-   *  member type _NTYPE.\n-   */\n-#define _GLIBCXX_HAS_NESTED_TYPE(_NTYPE)                         \\\n-  template<typename _Tp>                                         \\\n-    class __has_##_NTYPE##_helper                                \\\n-    : __sfinae_types                                             \\\n-    {                                                            \\\n-      template<typename _Up>                                     \\\n-        struct _Wrap_type                                        \\\n-\t{ };                                                     \\\n-                                                                 \\\n-      template<typename _Up>                                     \\\n-        static __one __test(_Wrap_type<typename _Up::_NTYPE>*);  \\\n-                                                                 \\\n-      template<typename _Up>                                     \\\n-        static __two __test(...);                                \\\n-                                                                 \\\n-    public:                                                      \\\n-      static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; \\\n-    };                                                           \\\n-                                                                 \\\n-  template<typename _Tp>                                         \\\n-    struct __has_##_NTYPE                                        \\\n-    : integral_constant<bool, __has_##_NTYPE##_helper            \\\n-\t\t\t<typename remove_cv<_Tp>::type>::value>  \\\n-    { };\n-\n-  // @} group metaprogramming\n-// _GLIBCXX_END_NAMESPACE_VERSION\n-} // namespace\n-\n-// #endif  // __GXX_EXPERIMENTAL_CXX0X__\n-\n-#endif  // _GLIBCXX_TYPE_TRAITS"}]}