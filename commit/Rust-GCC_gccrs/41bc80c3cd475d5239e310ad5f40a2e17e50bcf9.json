{"sha": "41bc80c3cd475d5239e310ad5f40a2e17e50bcf9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFiYzgwYzNjZDQ3NWQ1MjM5ZTMxMGFkNWY0MGEyZTE3ZTUwYmNmOQ==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2019-10-08T10:20:31Z"}, "committer": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2019-10-08T10:20:31Z"}, "message": "Revise 'libgfortran/runtime/minimal.c' to better conform to the original sources\n\n\tlibgfortran/\n\t* runtime/minimal.c: Revise.\n\nFrom-SVN: r276690", "tree": {"sha": "76f4abd139d7b9ecfd5d3b06a543239049f70542", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76f4abd139d7b9ecfd5d3b06a543239049f70542"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41bc80c3cd475d5239e310ad5f40a2e17e50bcf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41bc80c3cd475d5239e310ad5f40a2e17e50bcf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41bc80c3cd475d5239e310ad5f40a2e17e50bcf9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41bc80c3cd475d5239e310ad5f40a2e17e50bcf9/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5cfa327dc009e429da3711680ab10122763417a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cfa327dc009e429da3711680ab10122763417a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cfa327dc009e429da3711680ab10122763417a3"}], "stats": {"total": 241, "additions": 169, "deletions": 72}, "files": [{"sha": "9e3b1f8bad8bc3878262d18bf631fb9535963ef4", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41bc80c3cd475d5239e310ad5f40a2e17e50bcf9/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41bc80c3cd475d5239e310ad5f40a2e17e50bcf9/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=41bc80c3cd475d5239e310ad5f40a2e17e50bcf9", "patch": "@@ -1,3 +1,7 @@\n+2019-10-08  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* runtime/minimal.c: Revise.\n+\n 2019-10-05  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/91926"}, {"sha": "a633bc1ce0fcbcde585c56dca3ddbef6edc8f184", "filename": "libgfortran/runtime/minimal.c", "status": "modified", "additions": 165, "deletions": 72, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41bc80c3cd475d5239e310ad5f40a2e17e50bcf9/libgfortran%2Fruntime%2Fminimal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41bc80c3cd475d5239e310ad5f40a2e17e50bcf9/libgfortran%2Fruntime%2Fminimal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fminimal.c?ref=41bc80c3cd475d5239e310ad5f40a2e17e50bcf9", "patch": "@@ -23,13 +23,38 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgfortran.h\"\n-#include <string.h>\n \n+#include <string.h>\n \n #ifdef HAVE_UNISTD_H\n #include <unistd.h>\n #endif\n \n+\n+#if __nvptx__\n+/* Map \"exit\" to \"abort\"; see PR85463 '[nvptx] \"exit\" in offloaded region\n+   doesn't terminate process'.  */\n+# undef exit\n+# define exit(status) do { (void) (status); abort (); } while (0)\n+#endif\n+\n+\n+#if __nvptx__\n+/* 'printf' is all we have.  */\n+# undef estr_vprintf\n+# define estr_vprintf vprintf\n+#else\n+# error TODO\n+#endif\n+\n+\n+/* runtime/environ.c */\n+\n+options_t options;\n+\n+\n+/* runtime/main.c */\n+\n /* Stupid function to be sure the constructor is always linked in, even\n    in the case of static linking.  See PR libfortran/22298 for details.  */\n void\n@@ -38,11 +63,126 @@ stupid_function_name_for_static_linking (void)\n   return;\n }\n \n-options_t options;\n \n static int argc_save;\n static char **argv_save;\n \n+\n+/* Set the saved values of the command line arguments.  */\n+\n+void\n+set_args (int argc, char **argv)\n+{\n+  argc_save = argc;\n+  argv_save = argv;\n+}\n+iexport(set_args);\n+\n+\n+/* Retrieve the saved values of the command line arguments.  */\n+\n+void\n+get_args (int *argc, char ***argv)\n+{\n+  *argc = argc_save;\n+  *argv = argv_save;\n+}\n+\n+\n+/* runtime/error.c */\n+\n+/* Write a null-terminated C string to standard error. This function\n+   is async-signal-safe.  */\n+\n+ssize_t\n+estr_write (const char *str)\n+{\n+  return write (STDERR_FILENO, str, strlen (str));\n+}\n+\n+\n+/* printf() like function for for printing to stderr.  Uses a stack\n+   allocated buffer and doesn't lock stderr, so it should be safe to\n+   use from within a signal handler.  */\n+\n+int\n+st_printf (const char * format, ...)\n+{\n+  int written;\n+  va_list ap;\n+  va_start (ap, format);\n+  written = estr_vprintf (format, ap);\n+  va_end (ap);\n+  return written;\n+}\n+\n+\n+/* sys_abort()-- Terminate the program showing backtrace and dumping\n+   core.  */\n+\n+void\n+sys_abort (void)\n+{\n+  /* If backtracing is enabled, print backtrace and disable signal\n+     handler for ABRT.  */\n+  if (options.backtrace == 1\n+      || (options.backtrace == -1 && compile_options.backtrace == 1))\n+    {\n+      estr_write (\"\\nProgram aborted.\\n\");\n+    }\n+\n+  abort();\n+}\n+\n+\n+/* Exit in case of error termination. If backtracing is enabled, print\n+   backtrace, then exit.  */\n+\n+void\n+exit_error (int status)\n+{\n+  if (options.backtrace == 1\n+      || (options.backtrace == -1 && compile_options.backtrace == 1))\n+    {\n+      estr_write (\"\\nError termination.\\n\");\n+    }\n+  exit (status);\n+}\n+\n+\n+/* show_locus()-- Print a line number and filename describing where\n+ * something went wrong */\n+\n+void\n+show_locus (st_parameter_common *cmp)\n+{\n+  char *filename;\n+\n+  if (!options.locus || cmp == NULL || cmp->filename == NULL)\n+    return;\n+  \n+  if (cmp->unit > 0)\n+    {\n+      filename = /* TODO filename_from_unit (cmp->unit) */ NULL;\n+\n+      if (filename != NULL)\n+\t{\n+\t  st_printf (\"At line %d of file %s (unit = %d, file = '%s')\\n\",\n+\t\t   (int) cmp->line, cmp->filename, (int) cmp->unit, filename);\n+\t  free (filename);\n+\t}\n+      else\n+\t{\n+\t  st_printf (\"At line %d of file %s (unit = %d)\\n\",\n+\t\t   (int) cmp->line, cmp->filename, (int) cmp->unit);\n+\t}\n+      return;\n+    }\n+\n+  st_printf (\"At line %d of file %s\\n\", (int) cmp->line, cmp->filename);\n+}\n+\n+\n /* recursion_check()-- It's possible for additional errors to occur\n  * during fatal error processing.  We detect this condition here and\n  * exit with code 4 immediately. */\n@@ -70,9 +210,10 @@ void\n os_error (const char *message)\n {\n   recursion_check ();\n-  printf (\"Operating system error: \");\n-  printf (\"%s\\n\", message);\n-  exit (1);\n+  estr_write (\"Operating system error: \");\n+  estr_write (message);\n+  estr_write (\"\\n\");\n+  exit_error (1);\n }\n iexport(os_error);\n \n@@ -86,12 +227,12 @@ runtime_error (const char *message, ...)\n   va_list ap;\n \n   recursion_check ();\n-  printf (\"Fortran runtime error: \");\n+  estr_write (\"Fortran runtime error: \");\n   va_start (ap, message);\n-  vprintf (message, ap);\n+  estr_vprintf (message, ap);\n   va_end (ap);\n-  printf (\"\\n\");\n-  exit (2);\n+  estr_write (\"\\n\");\n+  exit_error (2);\n }\n iexport(runtime_error);\n \n@@ -104,13 +245,13 @@ runtime_error_at (const char *where, const char *message, ...)\n   va_list ap;\n \n   recursion_check ();\n-  printf (\"%s\", where);\n-  printf (\"\\nFortran runtime error: \");\n+  estr_write (where);\n+  estr_write (\"\\nFortran runtime error: \");\n   va_start (ap, message);\n-  vprintf (message, ap);\n+  estr_vprintf (message, ap);\n   va_end (ap);\n-  printf (\"\\n\");\n-  exit (2);\n+  estr_write (\"\\n\");\n+  exit_error (2);\n }\n iexport(runtime_error_at);\n \n@@ -120,12 +261,12 @@ runtime_warning_at (const char *where, const char *message, ...)\n {\n   va_list ap;\n \n-  printf (\"%s\", where);\n-  printf (\"\\nFortran runtime warning: \");\n+  estr_write (where);\n+  estr_write (\"\\nFortran runtime warning: \");\n   va_start (ap, message);\n-  vprintf (message, ap);\n+  estr_vprintf (message, ap);\n   va_end (ap);\n-  printf (\"\\n\");\n+  estr_write (\"\\n\");\n }\n iexport(runtime_warning_at);\n \n@@ -137,74 +278,26 @@ void\n internal_error (st_parameter_common *cmp, const char *message)\n {\n   recursion_check ();\n-  printf (\"Internal Error: \");\n-  printf (\"%s\", message);\n-  printf (\"\\n\");\n+  show_locus (cmp);\n+  estr_write (\"Internal Error: \");\n+  estr_write (message);\n+  estr_write (\"\\n\");\n \n   /* This function call is here to get the main.o object file included\n      when linking statically. This works because error.o is supposed to\n      be always linked in (and the function call is in internal_error\n      because hopefully it doesn't happen too often).  */\n   stupid_function_name_for_static_linking();\n \n-  exit (3);\n-}\n-\n-\n-/* Set the saved values of the command line arguments.  */\n-\n-void\n-set_args (int argc, char **argv)\n-{\n-  argc_save = argc;\n-  argv_save = argv;\n-}\n-iexport(set_args);\n-\n-\n-/* Retrieve the saved values of the command line arguments.  */\n-\n-void\n-get_args (int *argc, char ***argv)\n-{\n-  *argc = argc_save;\n-  *argv = argv_save;\n-}\n-\n-/* sys_abort()-- Terminate the program showing backtrace and dumping\n-   core.  */\n-\n-void\n-sys_abort (void)\n-{\n-  /* If backtracing is enabled, print backtrace and disable signal\n-     handler for ABRT.  */\n-  if (options.backtrace == 1\n-      || (options.backtrace == -1 && compile_options.backtrace == 1))\n-    {\n-      printf (\"\\nProgram aborted.\\n\");\n-    }\n-\n-  abort();\n+  exit_error (3);\n }\n \n \n /* runtime/stop.c */\n \n #undef report_exception\n #define report_exception() do {} while (0)\n-#undef st_printf\n-#define st_printf printf\n-#undef estr_write\n-#define estr_write(X) write(STDERR_FILENO, (X), strlen (X))\n-#if __nvptx__\n-/* Map \"exit\" to \"abort\"; see PR85463 '[nvptx] \"exit\" in offloaded region\n-   doesn't terminate process'.  */\n-#undef exit\n-#define exit(...) do { abort (); } while (0)\n-#endif\n-#undef exit_error\n-#define exit_error(...) do { abort (); } while (0)\n+\n \n /* A numeric STOP statement.  */\n "}]}