{"sha": "84320b0be2e9182ceeb110cebb98cd7006c484ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQzMjBiMGJlMmU5MTgyY2VlYjExMGNlYmI5OGNkNzAwNmM0ODRhYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2008-09-05T05:36:31Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2008-09-05T05:36:31Z"}, "message": "varasm.c (narrowing_initializer_constant_valid_p): New static function.\n\n./:\t* varasm.c (narrowing_initializer_constant_valid_p): New\n\tstatic function.\n\t(initializer_constant_valid_p): Call it.\ntestsuite/:\n\t* g++.dg/init/const7.C: New test.\n\nFrom-SVN: r140025", "tree": {"sha": "196539a8298c9ee8421168b02df43b8032809556", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/196539a8298c9ee8421168b02df43b8032809556"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84320b0be2e9182ceeb110cebb98cd7006c484ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84320b0be2e9182ceeb110cebb98cd7006c484ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84320b0be2e9182ceeb110cebb98cd7006c484ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84320b0be2e9182ceeb110cebb98cd7006c484ab/comments", "author": null, "committer": null, "parents": [{"sha": "54193313580e8f4ced394e41cd8aa8f43597b09e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54193313580e8f4ced394e41cd8aa8f43597b09e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54193313580e8f4ced394e41cd8aa8f43597b09e"}], "stats": {"total": 158, "additions": 103, "deletions": 55}, "files": [{"sha": "036e97bd92cc03609ba23324c23e6e4131fad342", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84320b0be2e9182ceeb110cebb98cd7006c484ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84320b0be2e9182ceeb110cebb98cd7006c484ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84320b0be2e9182ceeb110cebb98cd7006c484ab", "patch": "@@ -1,3 +1,9 @@\n+2008-09-04  Ian Lance Taylor  <iant@google.com>\n+\n+\t* varasm.c (narrowing_initializer_constant_valid_p): New\n+\tstatic function.\n+\t(initializer_constant_valid_p): Call it.\n+\n 2008-09-04  Jeff Law  <law@redhat.com>\n \n \t* fold-const.c (native_encode_real): Fix computation of WORDS."}, {"sha": "35c2f992e5164d03cd05871006f50a7062e7ace6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84320b0be2e9182ceeb110cebb98cd7006c484ab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84320b0be2e9182ceeb110cebb98cd7006c484ab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=84320b0be2e9182ceeb110cebb98cd7006c484ab", "patch": "@@ -1,3 +1,7 @@\n+2008-09-04  Ian Lance Taylor  <iant@google.com>\n+\n+\t* g++.dg/init/const7.C: New test.\n+\n 2008-09-04  Adam Nemet  <anemet@caviumnetworks.com>\n \n \t* gcc.target/mips/seq-1.c: New test."}, {"sha": "18d04625db2da1178c806ee1f0a5cf287e65b66a", "filename": "gcc/testsuite/g++.dg/init/const7.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84320b0be2e9182ceeb110cebb98cd7006c484ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fconst7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84320b0be2e9182ceeb110cebb98cd7006c484ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fconst7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fconst7.C?ref=84320b0be2e9182ceeb110cebb98cd7006c484ab", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile }\n+// { dg-options \"-fdump-tree-gimple\" }\n+\n+struct s { int x, y; };\n+short offsets[1] = {\n+  ((char*) &(((struct s*)16)->y) - (char *)16),\n+};\n+\n+// This ensures that we get a dump whether or not the bug is present.\n+void fn() { }\n+\n+// { dg-final { scan-tree-dump-not \"initialization\"  \"gimple\" } }\n+// { dg-final { cleanup-tree-dump \"gimple\" } }"}, {"sha": "5728d195e095e018067440670c13a664a4c8cb75", "filename": "gcc/varasm.c", "status": "modified", "additions": 80, "deletions": 55, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84320b0be2e9182ceeb110cebb98cd7006c484ab/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84320b0be2e9182ceeb110cebb98cd7006c484ab/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=84320b0be2e9182ceeb110cebb98cd7006c484ab", "patch": "@@ -4063,6 +4063,73 @@ constructor_static_from_elts_p (const_tree ctor)\n \t  && !VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (ctor)));\n }\n \n+/* A subroutine of initializer_constant_valid_p.  VALUE is either a\n+   MINUS_EXPR or a POINTER_PLUS_EXPR, and ENDTYPE is a narrowing\n+   conversion to something smaller than a pointer.  This returns\n+   null_pointer_node if the resulting value is an absolute constant\n+   which can be used to initialize a static variable.  Otherwise it\n+   returns NULL.  */\n+\n+static tree\n+narrowing_initializer_constant_valid_p (tree value, tree endtype)\n+{\n+  tree op0, op1;\n+\n+  op0 = TREE_OPERAND (value, 0);\n+  op1 = TREE_OPERAND (value, 1);\n+\n+  /* Like STRIP_NOPS except allow the operand mode to widen.  This\n+     works around a feature of fold that simplifies (int)(p1 - p2) to\n+     ((int)p1 - (int)p2) under the theory that the narrower operation\n+     is cheaper.  */\n+\n+  while (CONVERT_EXPR_P (op0)\n+\t || TREE_CODE (op0) == NON_LVALUE_EXPR)\n+    {\n+      tree inner = TREE_OPERAND (op0, 0);\n+      if (inner == error_mark_node\n+\t  || ! INTEGRAL_MODE_P (TYPE_MODE (TREE_TYPE (inner)))\n+\t  || (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (op0)))\n+\t      > GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (inner)))))\n+\tbreak;\n+      op0 = inner;\n+    }\n+\n+  while (CONVERT_EXPR_P (op1)\n+\t || TREE_CODE (op1) == NON_LVALUE_EXPR)\n+    {\n+      tree inner = TREE_OPERAND (op1, 0);\n+      if (inner == error_mark_node\n+\t  || ! INTEGRAL_MODE_P (TYPE_MODE (TREE_TYPE (inner)))\n+\t  || (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (op1)))\n+\t      > GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (inner)))))\n+\tbreak;\n+      op1 = inner;\n+    }\n+\n+  op0 = initializer_constant_valid_p (op0, endtype);\n+  op1 = initializer_constant_valid_p (op1, endtype);\n+\n+  /* Both initializers must be known.  */\n+  if (op0 && op1)\n+    {\n+      if (op0 == op1)\n+\treturn null_pointer_node;\n+\n+      /* Support differences between labels.  */\n+      if (TREE_CODE (op0) == LABEL_DECL\n+\t  && TREE_CODE (op1) == LABEL_DECL)\n+\treturn null_pointer_node;\n+\n+      if (TREE_CODE (op0) == STRING_CST\n+\t  && TREE_CODE (op1) == STRING_CST\n+\t  && operand_equal_p (op0, op1, 1))\n+\treturn null_pointer_node;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Return nonzero if VALUE is a valid constant-valued expression\n    for use in initializing a static variable; one that can be an\n    element of a \"constant\" initializer.\n@@ -4076,6 +4143,8 @@ constructor_static_from_elts_p (const_tree ctor)\n tree\n initializer_constant_valid_p (tree value, tree endtype)\n {\n+  tree ret;\n+\n   switch (TREE_CODE (value))\n     {\n     case CONSTRUCTOR:\n@@ -4216,6 +4285,14 @@ initializer_constant_valid_p (tree value, tree endtype)\n \t  if (valid1 == null_pointer_node)\n \t    return valid0;\n \t}\n+\n+      /* Support narrowing pointer differences.  */\n+      if (TREE_CODE (value) == POINTER_PLUS_EXPR)\n+\t{\n+\t  ret = narrowing_initializer_constant_valid_p (value, endtype);\n+\t  if (ret != NULL_TREE)\n+\t    return ret;\n+\t}\n       break;\n \n     case MINUS_EXPR:\n@@ -4244,62 +4321,10 @@ initializer_constant_valid_p (tree value, tree endtype)\n \t}\n \n       /* Support narrowing differences.  */\n-      if (INTEGRAL_TYPE_P (endtype))\n-\t{\n-\t  tree op0, op1;\n+      ret = narrowing_initializer_constant_valid_p (value, endtype);\n+      if (ret != NULL_TREE)\n+\treturn ret;\n \n-\t  op0 = TREE_OPERAND (value, 0);\n-\t  op1 = TREE_OPERAND (value, 1);\n-\n-\t  /* Like STRIP_NOPS except allow the operand mode to widen.\n-\t     This works around a feature of fold that simplifies\n-\t     (int)(p1 - p2) to ((int)p1 - (int)p2) under the theory\n-\t     that the narrower operation is cheaper.  */\n-\n-\t  while (CONVERT_EXPR_P (op0)\n-\t\t || TREE_CODE (op0) == NON_LVALUE_EXPR)\n-\t    {\n-\t      tree inner = TREE_OPERAND (op0, 0);\n-\t      if (inner == error_mark_node\n-\t          || ! INTEGRAL_MODE_P (TYPE_MODE (TREE_TYPE (inner)))\n-\t\t  || (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (op0)))\n-\t\t      > GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (inner)))))\n-\t\tbreak;\n-\t      op0 = inner;\n-\t    }\n-\n-\t  while (CONVERT_EXPR_P (op1)\n-\t\t || TREE_CODE (op1) == NON_LVALUE_EXPR)\n-\t    {\n-\t      tree inner = TREE_OPERAND (op1, 0);\n-\t      if (inner == error_mark_node\n-\t          || ! INTEGRAL_MODE_P (TYPE_MODE (TREE_TYPE (inner)))\n-\t\t  || (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (op1)))\n-\t\t      > GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (inner)))))\n-\t\tbreak;\n-\t      op1 = inner;\n-\t    }\n-\n-\t  op0 = initializer_constant_valid_p (op0, endtype);\n-\t  op1 = initializer_constant_valid_p (op1, endtype);\n-\n-\t  /* Both initializers must be known.  */\n-\t  if (op0 && op1)\n-\t    {\n-\t      if (op0 == op1)\n-\t\treturn null_pointer_node;\n-\n-\t      /* Support differences between labels.  */\n-\t      if (TREE_CODE (op0) == LABEL_DECL\n-\t\t  && TREE_CODE (op1) == LABEL_DECL)\n-\t\treturn null_pointer_node;\n-\n-\t      if (TREE_CODE (op0) == STRING_CST\n-\t\t  && TREE_CODE (op1) == STRING_CST\n-\t\t  && operand_equal_p (op0, op1, 1))\n-\t\treturn null_pointer_node;\n-\t    }\n-\t}\n       break;\n \n     default:"}]}