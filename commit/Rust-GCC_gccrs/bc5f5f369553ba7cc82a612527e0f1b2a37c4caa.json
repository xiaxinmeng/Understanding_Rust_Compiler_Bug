{"sha": "bc5f5f369553ba7cc82a612527e0f1b2a37c4caa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM1ZjVmMzY5NTUzYmE3Y2M4MmE2MTI1MjdlMGYxYjJhMzdjNGNhYQ==", "commit": {"author": {"name": "Jiong Wang", "email": "jiong.wang@arm.com", "date": "2014-07-23T16:11:50Z"}, "committer": {"name": "Marcus Shawcroft", "email": "mshawcroft@gcc.gnu.org", "date": "2014-07-23T16:11:50Z"}, "message": "[AArch64] Hoist calculation of register rtx.\n\nFrom-SVN: r212951", "tree": {"sha": "08e7cc153402e5b03b2fc345e2f9f650cab6ce0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08e7cc153402e5b03b2fc345e2f9f650cab6ce0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc5f5f369553ba7cc82a612527e0f1b2a37c4caa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc5f5f369553ba7cc82a612527e0f1b2a37c4caa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc5f5f369553ba7cc82a612527e0f1b2a37c4caa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc5f5f369553ba7cc82a612527e0f1b2a37c4caa/comments", "author": null, "committer": null, "parents": [{"sha": "55185278aba98ee8219ed8b73ba6336be5f7aeb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55185278aba98ee8219ed8b73ba6336be5f7aeb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55185278aba98ee8219ed8b73ba6336be5f7aeb6"}], "stats": {"total": 60, "additions": 24, "deletions": 36}, "files": [{"sha": "323b2eaeb152e44e74bcd7cc029c80557559ef5c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5f5f369553ba7cc82a612527e0f1b2a37c4caa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5f5f369553ba7cc82a612527e0f1b2a37c4caa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc5f5f369553ba7cc82a612527e0f1b2a37c4caa", "patch": "@@ -1,3 +1,9 @@\n+2014-07-23  Jiong Wang  <jiong.wang@arm.com>\n+\n+\t* config/aarch64/aarch64.c\n+\t(aarch64_save_or_restore_callee_save_registers)\n+\t(aarch64_save_or_restore_fprs): Hoist calculation of register rtx.\n+\n 2014-07-23  Jiong Wang  <jiong.wang@arm.com>\n \n \t* config/aarch64/aarch64.c"}, {"sha": "ac2dc79626fb05b374012e0b4f69a1a9ec38fa6a", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 18, "deletions": 36, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5f5f369553ba7cc82a612527e0f1b2a37c4caa/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5f5f369553ba7cc82a612527e0f1b2a37c4caa/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=bc5f5f369553ba7cc82a612527e0f1b2a37c4caa", "patch": "@@ -1922,6 +1922,7 @@ aarch64_save_or_restore_fprs (HOST_WIDE_INT start_offset, bool restore)\n     {\n       if (aarch64_register_saved_on_entry (regno))\n \t{\n+\t  rtx reg = gen_rtx_REG (DFmode, regno);\n \t  rtx mem;\n \n \t  HOST_WIDE_INT offset = start_offset\n@@ -1940,29 +1941,20 @@ aarch64_save_or_restore_fprs (HOST_WIDE_INT start_offset, bool restore)\n \t  if (regno2 <= V31_REGNUM\n \t      && aarch64_register_saved_on_entry (regno2))\n \t    {\n+\t      rtx reg2 = gen_rtx_REG (DFmode, regno2);\n \t      rtx mem2;\n \n \t      offset = start_offset + cfun->machine->frame.reg_offset[regno2];\n \t      mem2 = gen_mem_ref (DFmode,\n \t\t\t\t  plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t offset));\n \t      if (restore == false)\n-\t\t{\n-\t\t  insn = emit_insn\n-\t\t    (gen_store_pairdf (mem, gen_rtx_REG (DFmode, regno),\n-\t\t\t\t       mem2, gen_rtx_REG (DFmode, regno2)));\n-\n-\t\t}\n+\t\tinsn = emit_insn (gen_store_pairdf (mem, reg, mem2, reg2));\n \t      else\n \t\t{\n-\t\t  insn = emit_insn\n-\t\t    (gen_load_pairdf (gen_rtx_REG (DFmode, regno), mem,\n-\t\t\t\t      gen_rtx_REG (DFmode, regno2), mem2));\n-\n-\t\t  add_reg_note (insn, REG_CFA_RESTORE,\n-\t\t\t\tgen_rtx_REG (DFmode, regno));\n-\t\t  add_reg_note (insn, REG_CFA_RESTORE,\n-\t\t\t\tgen_rtx_REG (DFmode, regno2));\n+\t\t  insn = emit_insn (gen_load_pairdf (reg, mem, reg2, mem2));\n+\t\t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n+\t\t  add_reg_note (insn, REG_CFA_RESTORE, reg2);\n \t\t}\n \n \t      /* The first part of a frame-related parallel insn is\n@@ -1975,12 +1967,11 @@ aarch64_save_or_restore_fprs (HOST_WIDE_INT start_offset, bool restore)\n \t  else\n \t    {\n \t      if (restore == false)\n-\t\tinsn = emit_move_insn (mem, gen_rtx_REG (DFmode, regno));\n+\t\tinsn = emit_move_insn (mem, reg);\n \t      else\n \t\t{\n-\t\t  insn = emit_move_insn (gen_rtx_REG (DFmode, regno), mem);\n-\t\t  add_reg_note (insn, REG_CFA_RESTORE,\n-\t\t\t\tgen_rtx_REG (DFmode, regno));\n+\t\t  insn = emit_move_insn (reg, mem);\n+\t\t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n \t\t}\n \t    }\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n@@ -2006,6 +1997,7 @@ aarch64_save_or_restore_callee_save_registers (HOST_WIDE_INT start_offset,\n     {\n       if (aarch64_register_saved_on_entry (regno))\n \t{\n+\t  rtx reg = gen_rtx_REG (DImode, regno);\n \t  rtx mem;\n \n \t  HOST_WIDE_INT offset = start_offset\n@@ -2026,29 +2018,20 @@ aarch64_save_or_restore_callee_save_registers (HOST_WIDE_INT start_offset,\n \t      && ((cfun->machine->frame.reg_offset[regno] + UNITS_PER_WORD)\n \t\t  == cfun->machine->frame.reg_offset[regno2]))\n \t    {\n+\t      rtx reg2 = gen_rtx_REG (DImode, regno2);\n \t      rtx mem2;\n \n \t      offset = start_offset + cfun->machine->frame.reg_offset[regno2];\n \t      mem2 = gen_mem_ref (Pmode,\n \t\t\t\t  plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t offset));\n \t      if (restore == false)\n-\t\t{\n-\t\t  insn = emit_insn\n-\t\t    (gen_store_pairdi (mem, gen_rtx_REG (DImode, regno),\n-\t\t\t\t       mem2, gen_rtx_REG (DImode, regno2)));\n-\n-\t\t}\n+\t\t  insn = emit_insn (gen_store_pairdi (mem, reg, mem2, reg2));\n \t      else\n \t\t{\n-\t\t  insn = emit_insn\n-\t\t    (gen_load_pairdi (gen_rtx_REG (DImode, regno), mem,\n-\t\t\t\t      gen_rtx_REG (DImode, regno2), mem2));\n-\n-\t\t  add_reg_note (insn, REG_CFA_RESTORE,\n-\t\t\t\tgen_rtx_REG (DImode, regno));\n-\t\t  add_reg_note (insn, REG_CFA_RESTORE,\n-\t\t\t\tgen_rtx_REG (DImode, regno2));\n+\t\t  insn = emit_insn (gen_load_pairdi (reg, mem, reg2, mem2));\n+\t\t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n+\t\t  add_reg_note (insn, REG_CFA_RESTORE, reg2);\n \t\t}\n \n \t      /* The first part of a frame-related parallel insn is\n@@ -2061,12 +2044,11 @@ aarch64_save_or_restore_callee_save_registers (HOST_WIDE_INT start_offset,\n \t  else\n \t    {\n \t      if (restore == false)\n-\t\tinsn = emit_move_insn (mem, gen_rtx_REG (DImode, regno));\n+\t\tinsn = emit_move_insn (mem, reg);\n \t      else\n \t\t{\n-\t\t  insn = emit_move_insn (gen_rtx_REG (DImode, regno), mem);\n-\t\t  add_reg_note (insn, REG_CFA_RESTORE,\n-\t\t\t\tgen_rtx_REG (DImode, regno));\n+\t\t  insn = emit_move_insn (reg, mem);\n+\t\t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n \t\t}\n \t    }\n \t  RTX_FRAME_RELATED_P (insn) = 1;"}]}