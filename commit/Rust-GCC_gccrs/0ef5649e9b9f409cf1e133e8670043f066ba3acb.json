{"sha": "0ef5649e9b9f409cf1e133e8670043f066ba3acb", "node_id": "C_kwDOANBUbNoAKDBlZjU2NDllOWI5ZjQwOWNmMWUxMzNlODY3MDA0M2YwNjZiYTNhY2I", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-11-08T22:49:04Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-11-09T06:58:05Z"}, "message": "[range-op-float] Abstract out binary operator code out of PLUS_EXPR entry.\n\nThe PLUS_EXPR was always meant to be a template for further\ndevelopment, since most of the binary operators will share a similar\nstructure.  This patch abstracts out the common bits into the default\ndefinition for range_operator_float::fold_range() and provides an\nrv_fold() to be implemented by the individual entries wishing to use\nthe generic folder.  This is akin to what we do with fold_range() and\nwi_fold() in the integer version of range-ops.\n\ngcc/ChangeLog:\n\n\t* range-op-float.cc (range_operator_float::fold_range): Abstract\n\tout from foperator_plus.\n\t(range_operator_float::rv_fold): New.\n\t(foperator_plus::fold_range): Remove.\n\t(foperator_plus::rv_fold): New.\n\t(propagate_nans): Remove.\n\t* range-op.h (class range_operator_float): Add rv_fold.", "tree": {"sha": "dd71c5ac232c4ca23424a52d0c2c771eb36af623", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd71c5ac232c4ca23424a52d0c2c771eb36af623"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ef5649e9b9f409cf1e133e8670043f066ba3acb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ef5649e9b9f409cf1e133e8670043f066ba3acb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ef5649e9b9f409cf1e133e8670043f066ba3acb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ef5649e9b9f409cf1e133e8670043f066ba3acb/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68b0615be2aaff3a8ce91ba7cd0f69ebbd93702c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68b0615be2aaff3a8ce91ba7cd0f69ebbd93702c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68b0615be2aaff3a8ce91ba7cd0f69ebbd93702c"}], "stats": {"total": 163, "additions": 84, "deletions": 79}, "files": [{"sha": "7075c25442a09feccb82f505b81f882100823241", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 77, "deletions": 79, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef5649e9b9f409cf1e133e8670043f066ba3acb/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef5649e9b9f409cf1e133e8670043f066ba3acb/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=0ef5649e9b9f409cf1e133e8670043f066ba3acb", "patch": "@@ -49,13 +49,66 @@ along with GCC; see the file COPYING3.  If not see\n // Default definitions for floating point operators.\n \n bool\n-range_operator_float::fold_range (frange &r ATTRIBUTE_UNUSED,\n-\t\t\t\t  tree type ATTRIBUTE_UNUSED,\n-\t\t\t\t  const frange &lh ATTRIBUTE_UNUSED,\n-\t\t\t\t  const frange &rh ATTRIBUTE_UNUSED,\n+range_operator_float::fold_range (frange &r, tree type,\n+\t\t\t\t  const frange &op1, const frange &op2,\n \t\t\t\t  relation_trio) const\n {\n-  return false;\n+  if (empty_range_varying (r, type, op1, op2))\n+    return true;\n+  if (op1.known_isnan () || op2.known_isnan ())\n+    {\n+      r.set_nan (op1.type ());\n+      return true;\n+    }\n+\n+  REAL_VALUE_TYPE lb, ub;\n+  bool maybe_nan;\n+  rv_fold (lb, ub, maybe_nan, type,\n+\t   op1.lower_bound (), op1.upper_bound (),\n+\t   op2.lower_bound (), op2.upper_bound ());\n+\n+  // Handle possible NANs by saturating to the appropriate INF if only\n+  // one end is a NAN.  If both ends are a NAN, just return a NAN.\n+  bool lb_nan = real_isnan (&lb);\n+  bool ub_nan = real_isnan (&ub);\n+  if (lb_nan && ub_nan)\n+    {\n+      r.set_nan (type);\n+      return true;\n+    }\n+  if (lb_nan)\n+    lb = dconstninf;\n+  else if (ub_nan)\n+    ub = dconstinf;\n+\n+  r.set (type, lb, ub);\n+\n+  if (lb_nan || ub_nan || maybe_nan)\n+    // Keep the default NAN (with a varying sign) set by the setter.\n+    ;\n+  else if (!op1.maybe_isnan () && !op2.maybe_isnan ())\n+    r.clear_nan ();\n+\n+  return true;\n+}\n+\n+// For a given operation, fold two sets of ranges into [lb, ub].\n+// MAYBE_NAN is set to TRUE if, in addition to any result in LB or\n+// UB, the final range has the possiblity of a NAN.\n+void\n+range_operator_float::rv_fold (REAL_VALUE_TYPE &lb,\n+\t\t\t       REAL_VALUE_TYPE &ub,\n+\t\t\t       bool &maybe_nan,\n+\t\t\t       tree type ATTRIBUTE_UNUSED,\n+\t\t\t       const REAL_VALUE_TYPE &lh_lb ATTRIBUTE_UNUSED,\n+\t\t\t       const REAL_VALUE_TYPE &lh_ub ATTRIBUTE_UNUSED,\n+\t\t\t       const REAL_VALUE_TYPE &rh_lb ATTRIBUTE_UNUSED,\n+\t\t\t       const REAL_VALUE_TYPE &rh_ub ATTRIBUTE_UNUSED)\n+  const\n+{\n+  lb = dconstninf;\n+  ub = dconstinf;\n+  maybe_nan = true;\n }\n \n bool\n@@ -192,19 +245,6 @@ frelop_early_resolve (irange &r, tree type,\n \t  && relop_early_resolve (r, type, op1, op2, rel, my_rel));\n }\n \n-// If either operand is a NAN, set R to NAN and return TRUE.\n-\n-inline bool\n-propagate_nans (frange &r, const frange &op1, const frange &op2)\n-{\n-  if (op1.known_isnan () || op2.known_isnan ())\n-    {\n-      r.set_nan (op1.type ());\n-      return true;\n-    }\n-  return false;\n-}\n-\n // Set VALUE to its next real value, or INF if the operation overflows.\n \n inline void\n@@ -1822,69 +1862,27 @@ foperator_unordered_equal::op1_range (frange &r, tree type,\n \n class foperator_plus : public range_operator_float\n {\n-  using range_operator_float::fold_range;\n-\n-public:\n-  bool fold_range (frange &r, tree type,\n-\t\t   const frange &lh,\n-\t\t   const frange &rh,\n-\t\t   relation_trio = TRIO_VARYING) const final override;\n+  void rv_fold (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub, bool &maybe_nan,\n+\t\ttree type,\n+\t\tconst REAL_VALUE_TYPE &lh_lb,\n+\t\tconst REAL_VALUE_TYPE &lh_ub,\n+\t\tconst REAL_VALUE_TYPE &rh_lb,\n+\t\tconst REAL_VALUE_TYPE &rh_ub) const final override\n+  {\n+    frange_arithmetic (PLUS_EXPR, type, lb, lh_lb, rh_lb, dconstninf);\n+    frange_arithmetic (PLUS_EXPR, type, ub, lh_ub, rh_ub, dconstinf);\n+\n+    // [-INF] + [+INF] = NAN\n+    if (real_isinf (&lh_lb, true) && real_isinf (&rh_ub, false))\n+      maybe_nan = true;\n+    // [+INF] + [-INF] = NAN\n+    else if (real_isinf (&lh_ub, false) && real_isinf (&rh_lb, true))\n+      maybe_nan = true;\n+    else\n+      maybe_nan = false;\n+  }\n } fop_plus;\n \n-bool\n-foperator_plus::fold_range (frange &r, tree type,\n-\t\t\t    const frange &op1, const frange &op2,\n-\t\t\t    relation_trio) const\n-{\n-  if (empty_range_varying (r, type, op1, op2))\n-    return true;\n-  if (propagate_nans (r, op1, op2))\n-    return true;\n-\n-  REAL_VALUE_TYPE lb, ub;\n-  frange_arithmetic (PLUS_EXPR, type, lb,\n-\t\t     op1.lower_bound (), op2.lower_bound (), dconstninf);\n-  frange_arithmetic (PLUS_EXPR, type, ub,\n-\t\t     op1.upper_bound (), op2.upper_bound (), dconstinf);\n-\n-  // Handle possible NANs by saturating to the appropriate INF if only\n-  // one end is a NAN.  If both ends are a NAN, just return a NAN.\n-  bool lb_nan = real_isnan (&lb);\n-  bool ub_nan = real_isnan (&ub);\n-  if (lb_nan && ub_nan)\n-    {\n-      r.set_nan (type);\n-      return true;\n-    }\n-  if (lb_nan)\n-    lb = dconstninf;\n-  else if (ub_nan)\n-    ub = dconstinf;\n-\n-  r.set (type, lb, ub);\n-\n-  // Some combinations can yield a NAN even if no operands have the\n-  // possibility of a NAN.\n-  bool maybe_nan;\n-  // [-INF] + [+INF] = NAN\n-  if (real_isinf (&op1.lower_bound (), true)\n-      && real_isinf (&op2.upper_bound (), false))\n-    maybe_nan = true;\n-  // [+INF] + [-INF] = NAN\n-  else if (real_isinf (&op1.upper_bound (), false)\n-\t   && real_isinf (&op2.lower_bound (), true))\n-    maybe_nan = true;\n-  else\n-    maybe_nan = false;\n-\n-  if (lb_nan || ub_nan || maybe_nan)\n-    // Keep the default NAN (with a varying sign) set by the setter.\n-    ;\n-  else if (!op1.maybe_isnan () && !op2.maybe_isnan ())\n-    r.clear_nan ();\n-\n-  return true;\n-}\n \n // Instantiate a range_op_table for floating point operations.\n static floating_op_table global_floating_table;"}, {"sha": "442a6e1d2994185acdcabcd19d6754881343731e", "filename": "gcc/range-op.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef5649e9b9f409cf1e133e8670043f066ba3acb/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef5649e9b9f409cf1e133e8670043f066ba3acb/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=0ef5649e9b9f409cf1e133e8670043f066ba3acb", "patch": "@@ -117,6 +117,13 @@ class range_operator_float\n \t\t\t   const frange &lh,\n \t\t\t   const frange &rh,\n \t\t\t   relation_trio = TRIO_VARYING) const;\n+  virtual void rv_fold (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub,\n+\t\t\tbool &maybe_nan,\n+\t\t\ttree type,\n+\t\t\tconst REAL_VALUE_TYPE &lh_lb,\n+\t\t\tconst REAL_VALUE_TYPE &lh_ub,\n+\t\t\tconst REAL_VALUE_TYPE &rh_lb,\n+\t\t\tconst REAL_VALUE_TYPE &rh_ub) const;\n   // Unary operations have the range of the LHS as op2.\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const frange &lh,"}]}