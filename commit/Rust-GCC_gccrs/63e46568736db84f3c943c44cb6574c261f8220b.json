{"sha": "63e46568736db84f3c943c44cb6574c261f8220b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNlNDY1Njg3MzZkYjg0ZjNjOTQzYzQ0Y2I2NTc0YzI2MWY4MjIwYg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dan@cgsoftware.com", "date": "2001-05-18T15:39:11Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2001-05-18T15:39:11Z"}, "message": "dwarf2out.c: Add dw_loc_list_ref, a reference to a location list.\n\n2001-05-18  Daniel Berlin  <dan@cgsoftware.com>\n\n\t* dwarf2out.c: Add dw_loc_list_ref, a reference to a location\n\tlist.\n\tAdd have_location_lists, a variable to determine whether we need a\n\t.debug_loc section or not.\n\t(enum dw_val_class): Add dw_val_class_loc_list.\n\t(dw_val_struct): Add val_loc_list.\n\t(dw_loc_list_struct): New structure, represents location lists.\n\t(new_loc_list): New function, return a new location list, given\n\tthe range and location expression.\n\t(add_loc_descr_to_loc_list): New function, add a location\n\texpression to a location list, given the expression and range.\n\t(output_loc_list): New function, output a location list.\n\t(gen_internal_sym): Modified to take symbol prefix, so we can\n\treuse it for location list symbols.\n\t(add_AT_loc_list): New function, add a location list to a DIE at\n\tthe named attribute.\n\t(AT_loc_list): New function, return the location list reference\n\tfor a given attribute, if it's a location list.\n\t(print_die): Handle dw_val_class_loc_list.\n\t(size_of_die): Ditto.\n\t(value_format): Ditto.\n\t(output_die): Ditto.\n\t(output_location_lists): New function, output all of the location\n\tlists for a DIE and it's children.\n\t(dwarf2out_finish): Call output_location_lists if we have location\n\tlists.\n\nFrom-SVN: r42266", "tree": {"sha": "7acb797a40880eff3929b301f68a0fe8e69c0b80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7acb797a40880eff3929b301f68a0fe8e69c0b80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63e46568736db84f3c943c44cb6574c261f8220b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63e46568736db84f3c943c44cb6574c261f8220b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63e46568736db84f3c943c44cb6574c261f8220b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63e46568736db84f3c943c44cb6574c261f8220b/comments", "author": null, "committer": null, "parents": [{"sha": "2b0cbc5d554671be494017c349cb50ceadac407a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b0cbc5d554671be494017c349cb50ceadac407a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b0cbc5d554671be494017c349cb50ceadac407a"}], "stats": {"total": 225, "additions": 217, "deletions": 8}, "files": [{"sha": "4cf5da22e539c32d61a388e184cab001cf083b84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63e46568736db84f3c943c44cb6574c261f8220b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63e46568736db84f3c943c44cb6574c261f8220b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=63e46568736db84f3c943c44cb6574c261f8220b", "patch": "@@ -1,3 +1,33 @@\n+2001-05-18  Daniel Berlin  <dan@cgsoftware.com>\n+\n+\t* dwarf2out.c: Add dw_loc_list_ref, a reference to a location\n+\tlist.\n+\tAdd have_location_lists, a variable to determine whether we need a\n+\t.debug_loc section or not.\n+\t(enum dw_val_class): Add dw_val_class_loc_list.\n+\t(dw_val_struct): Add val_loc_list.\n+\t(dw_loc_list_struct): New structure, represents location lists.\n+\t(new_loc_list): New function, return a new location list, given\n+\tthe range and location expression.\n+\t(add_loc_descr_to_loc_list): New function, add a location\n+\texpression to a location list, given the expression and range.\n+\t(output_loc_list): New function, output a location list.\n+\t(gen_internal_sym): Modified to take symbol prefix, so we can\n+\treuse it for location list symbols.\n+\t(add_AT_loc_list): New function, add a location list to a DIE at\n+\tthe named attribute.\n+\t(AT_loc_list): New function, return the location list reference\n+\tfor a given attribute, if it's a location list.\n+\t(print_die): Handle dw_val_class_loc_list.\n+\t(size_of_die): Ditto.\n+\t(value_format): Ditto.\n+\t(output_die): Ditto.\n+\t(output_location_lists): New function, output all of the location\n+\tlists for a DIE and it's children.\n+\t(dwarf2out_finish): Call output_location_lists if we have location\n+\tlists.\n+\n+\n Fri May 18 15:39:16 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* gcse.c (try_replace_reg): First try global replace, later try to"}, {"sha": "7cc71fb953d3b7f19c6149868e1d72954c0f4f99", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 187, "deletions": 8, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63e46568736db84f3c943c44cb6574c261f8220b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63e46568736db84f3c943c44cb6574c261f8220b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=63e46568736db84f3c943c44cb6574c261f8220b", "patch": "@@ -2076,6 +2076,7 @@ dwarf2out_frame_finish ()\n typedef struct dw_val_struct *dw_val_ref;\n typedef struct die_struct *dw_die_ref;\n typedef struct dw_loc_descr_struct *dw_loc_descr_ref;\n+typedef struct dw_loc_list_struct *dw_loc_list_ref;\n \n /* Each DIE may have a series of attribute/value pairs.  Values\n    can take on several forms.  The forms that are used in this\n@@ -2085,6 +2086,7 @@ typedef enum\n {\n   dw_val_class_addr,\n   dw_val_class_loc,\n+  dw_val_class_loc_list,\n   dw_val_class_const,\n   dw_val_class_unsigned_const,\n   dw_val_class_long_long,\n@@ -2126,6 +2128,7 @@ typedef struct dw_val_struct\n   union\n     {\n       rtx val_addr;\n+      dw_loc_list_ref  val_loc_list;\n       dw_loc_descr_ref val_loc;\n       long int val_int;\n       long unsigned val_unsigned;\n@@ -2157,6 +2160,19 @@ typedef struct dw_loc_descr_struct\n }\n dw_loc_descr_node;\n \n+/* Location lists are ranges + location descriptions for that range,\n+   so you can track variables that are in different places over\n+   their entire life. */\n+typedef struct dw_loc_list_struct\n+{\n+  dw_loc_list_ref dw_loc_next;\n+  const char *begin; /* Label for begin address of range */\n+  const char *end;  /* Label for end address of range */\n+  char *ll_symbol; /* Label for beginning of location list. Only on head of list */\n+  const char *section; /* Section this loclist is relative to */\n+  dw_loc_descr_ref expr;\n+} dw_loc_list_node;\n+\n static const char *dwarf_stack_op_name\tPARAMS ((unsigned));\n static dw_loc_descr_ref new_loc_descr\tPARAMS ((enum dwarf_location_atom,\n \t\t\t\t\t\t unsigned long,\n@@ -2168,6 +2184,14 @@ static unsigned long size_of_locs\tPARAMS ((dw_loc_descr_ref));\n static void output_loc_operands\t\tPARAMS ((dw_loc_descr_ref));\n static void output_loc_sequence\t\tPARAMS ((dw_loc_descr_ref));\n \n+static dw_loc_list_ref new_loc_list     PARAMS ((dw_loc_descr_ref, \n+\t\t\t\t\t\t const char *, const char *,\n+\t\t\t\t\t\t const char *, unsigned));\n+static void add_loc_descr_to_loc_list   PARAMS ((dw_loc_list_ref *,\n+\t\t\t\t\t\t dw_loc_descr_ref,\n+\t\t\t\t\t\t const char *, const char *, const char *));\n+static void output_loc_list\t\tPARAMS ((dw_loc_list_ref));\n+static char *gen_internal_sym \t\tPARAMS ((const char *));\n /* Convert a DWARF stack opcode into its string name.  */\n \n static const char *\n@@ -2495,6 +2519,29 @@ new_loc_descr (op, oprnd1, oprnd2)\n   return descr;\n }\n \n+/* Return a new location list, given the begin and end range, and the\n+   expression. gensym tells us whether to generate a new internal\n+   symbol for this location list node, which is done for the head of\n+   the list only. */ \n+static inline dw_loc_list_ref\n+new_loc_list (expr, begin, end, section, gensym)\n+     register dw_loc_descr_ref expr;\n+     register const char *begin;\n+     register const char *end;\n+     register const char *section;\n+     register unsigned gensym;\n+{\n+  register dw_loc_list_ref retlist\n+    = (dw_loc_list_ref) xcalloc (1, sizeof (dw_loc_list_node));\n+  retlist->begin = begin;\n+  retlist->end = end;\n+  retlist->expr = expr;\n+  retlist->section = section;\n+  if (gensym) \n+    retlist->ll_symbol = gen_internal_sym (\"LLST\");\n+  return retlist;\n+}\n+\n /* Add a location description term to a location description expression.  */\n \n static inline void\n@@ -2511,6 +2558,24 @@ add_loc_descr (list_head, descr)\n   *d = descr;\n }\n \n+/* Add a location description expression to a location list */\n+static inline void\n+add_loc_descr_to_loc_list (list_head, descr, begin, end, section)\n+     register dw_loc_list_ref *list_head;\n+     register dw_loc_descr_ref descr;\n+     register const char *begin;\n+     register const char *end;\n+     register const char *section;\n+{\n+  register dw_loc_list_ref *d;\n+  \n+  /* Find the end of the chain. */\n+  for (d = list_head; (*d) != NULL; d = &(*d)->dw_loc_next)\n+    ;\n+  /* Add a new location list node to the list */\n+  *d = new_loc_list (descr, begin, end, section, 0);\n+}\n+\n /* Return the size of a location descriptor.  */\n \n static unsigned long\n@@ -3249,6 +3314,9 @@ static unsigned arange_table_in_use;\n    arange_table.  */\n #define ARANGE_TABLE_INCREMENT 64\n \n+/* Whether we have location lists that need outputting */\n+static unsigned have_location_lists;\n+\n /* A pointer to the base of a list of incomplete types which might be\n    completed at some later time.  */\n \n@@ -3319,6 +3387,9 @@ static void add_AT_fde_ref\t\tPARAMS ((dw_die_ref,\n static void add_AT_loc\t\t\tPARAMS ((dw_die_ref,\n \t\t\t\t\t\t enum dwarf_attribute,\n \t\t\t\t\t\t dw_loc_descr_ref));\n+static void add_AT_loc_list\t\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute,\n+\t\t\t\t\t\t dw_loc_list_ref));\n static void add_AT_addr\t\t\tPARAMS ((dw_die_ref,\n \t\t\t\t\t\t enum dwarf_attribute,\n \t\t\t\t\t\t rtx));\n@@ -3366,11 +3437,11 @@ static void compute_section_prefix\tPARAMS ((dw_die_ref));\n static int is_type_die\t\t\tPARAMS ((dw_die_ref));\n static int is_comdat_die \t\tPARAMS ((dw_die_ref));\n static int is_symbol_die \t\tPARAMS ((dw_die_ref));\n-static char *gen_internal_sym \t\tPARAMS ((void));\n static void assign_symbol_names\t\tPARAMS ((dw_die_ref));\n static void break_out_includes\t\tPARAMS ((dw_die_ref));\n static void add_sibling_attributes\tPARAMS ((dw_die_ref));\n static void build_abbrev_table\t\tPARAMS ((dw_die_ref));\n+static void output_location_lists   \tPARAMS ((dw_die_ref));\n static unsigned long size_of_string\tPARAMS ((const char *));\n static int constant_size\t\tPARAMS ((long unsigned));\n static unsigned long size_of_die\tPARAMS ((dw_die_ref));\n@@ -3535,6 +3606,9 @@ static int file_info_cmp\t\tPARAMS ((const void *, const void *));\n #ifndef ABBREV_SECTION_LABEL\n #define ABBREV_SECTION_LABEL     \"Ldebug_abbrev\"\n #endif\n+#ifndef LOC_SECTION_LABEL\n+#define LOC_SECTION_LABEL\t \"Ldebug_loc\"\n+#endif\n \n /* Definitions of defaults for formats and names of various special\n    (artificial) labels which may be generated within this file (when the -g\n@@ -3547,7 +3621,7 @@ static char text_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char abbrev_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char debug_info_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char debug_line_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n-\n+static char loc_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n #ifndef TEXT_END_LABEL\n #define TEXT_END_LABEL\t\t\"Letext\"\n #endif\n@@ -4381,6 +4455,34 @@ AT_loc (a)\n   abort ();\n }\n \n+static inline void\n+add_AT_loc_list (die, attr_kind, loc_list)\n+     register dw_die_ref die;\n+     register enum dwarf_attribute attr_kind;\n+     register dw_loc_list_ref loc_list;\n+{\n+  register dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+\n+  attr->dw_attr_next = NULL;\n+  attr->dw_attr = attr_kind;\n+  attr->dw_attr_val.val_class = dw_val_class_loc_list;\n+  attr->dw_attr_val.v.val_loc_list = loc_list;\n+  add_dwarf_attr (die, attr);\n+  have_location_lists = 1;\n+}\n+\n+static inline dw_loc_list_ref AT_loc_list PARAMS ((dw_attr_ref));\n+\n+static inline dw_loc_list_ref\n+AT_loc_list (a)\n+     register dw_attr_ref a;\n+{\n+  if (a && AT_class (a) == dw_val_class_loc_list)\n+    return a->dw_attr_val.v.val_loc_list;\n+\n+  abort ();\n+}\n+\n /* Add an address constant attribute value to a DIE.  */\n \n static inline void\n@@ -4858,6 +4960,9 @@ print_die (die, outfile)\n \tcase dw_val_class_loc:\n \t  fprintf (outfile, \"location descriptor\");\n \t  break;\n+\tcase dw_val_class_loc_list:\n+\t  fprintf (outfile, \"location list -> label:%s\", AT_loc_list (a)->ll_symbol);\n+\t  break;\n \tcase dw_val_class_const:\n \t  fprintf (outfile, \"%ld\", AT_int (a));\n \t  break;\n@@ -5252,18 +5357,19 @@ is_symbol_die (c)\n {\n   if (is_type_die (c))\n     return 1;\n-  if (get_AT (c, DW_AT_declaration)\n+  if (get_AT (c, DW_AT_declaration) \n       && ! get_AT (c, DW_AT_specification))\n     return 1;\n   return 0;\n }\n \n static char *\n-gen_internal_sym ()\n+gen_internal_sym (prefix)\n+\tconst char *prefix;\n {\n   char buf[256];\n   static int label_num;\n-  ASM_GENERATE_INTERNAL_LABEL (buf, \"LDIE\", label_num++);\n+  ASM_GENERATE_INTERNAL_LABEL (buf, prefix, label_num++);\n   return xstrdup (buf);\n }\n \n@@ -5285,7 +5391,7 @@ assign_symbol_names (die)\n \t  die->die_symbol = xstrdup (p);\n \t}\n       else\n-\tdie->die_symbol = gen_internal_sym ();\n+\tdie->die_symbol = gen_internal_sym (\"LDIE\");\n     }\n \n   for (c = die->die_child; c != NULL; c = c->die_sib)\n@@ -5370,6 +5476,24 @@ add_sibling_attributes (die)\n     add_sibling_attributes (c);\n }\n \n+/* Output all location lists for the DIE and it's children */\n+static void\n+output_location_lists (die)\n+     register dw_die_ref die;\n+{\n+  dw_die_ref c;\n+  dw_attr_ref d_attr;\n+  for (d_attr = die->die_attr; d_attr; d_attr = d_attr->dw_attr_next)\n+    {\n+      if (AT_class (d_attr) == dw_val_class_loc_list)\n+\t{\n+\t  output_loc_list (AT_loc_list (d_attr));\n+\t}\n+    }\n+  for (c = die->die_child; c != NULL; c = c->die_sib)\n+    output_location_lists (c);\n+\n+}\n /* The format of each DIE (and its attribute value pairs)\n    is encoded in an abbreviation table.  This routine builds the\n    abbreviation table and assigns a unique abbreviation id for\n@@ -5508,6 +5632,9 @@ size_of_die (die)\n \t    size += lsize;\n \t  }\n \t  break;\n+\tcase dw_val_class_loc_list:\n+\t  size += DWARF_OFFSET_SIZE;\n+\t  break;\n \tcase dw_val_class_const:\n \t  size += size_of_sleb128 (AT_int (a));\n \t  break;\n@@ -5643,6 +5770,8 @@ value_format (a)\n     {\n     case dw_val_class_addr:\n       return DW_FORM_addr;\n+    case dw_val_class_loc_list:\n+\treturn DW_FORM_data4; /* FIXME: Could be DW_FORM_data8, with a > 32 bit size .debug_loc section */\n     case dw_val_class_loc:\n       switch (constant_size (size_of_locs (AT_loc (a))))\n \t{\n@@ -5761,6 +5890,38 @@ output_die_symbol (die)\n   ASM_OUTPUT_LABEL (asm_out_file, sym);\n }\n \n+/* Output the location list given to us */\n+static void\n+output_loc_list (list_head)\n+     register dw_loc_list_ref list_head;\n+{\n+  register dw_loc_list_ref curr;\n+  ASM_OUTPUT_LABEL (asm_out_file, list_head->ll_symbol);\n+  if (strcmp (curr->section, \".text\") == 0)\n+    {\n+      if (DWARF2_ADDR_SIZE == 4)\n+        dw2_asm_output_data (DWARF2_ADDR_SIZE, 0xffffffff, \"Location list base address specifier fake entry\");\n+      else if (DWARF2_ADDR_SIZE == 8)\n+\tdw2_asm_output_data (DWARF2_ADDR_SIZE, 0xffffffffffffffffLL, \"Location list base address specifier fake entry\");\n+      else\n+        abort();\n+      dw2_asm_output_offset (DWARF2_ADDR_SIZE, curr->section, \"Location list base address specifier base\");\n+    }\n+  for (curr = list_head; curr != NULL; curr=curr->dw_loc_next)\n+    {\n+      int size;\n+      dw2_asm_output_delta (DWARF2_ADDR_SIZE, curr->begin, curr->section, \"Location list begin address (%s)\", list_head->ll_symbol);\n+      dw2_asm_output_delta (DWARF2_ADDR_SIZE, curr->end, curr->section, \"Location list end address (%s)\", list_head->ll_symbol);\n+      size = size_of_locs (curr->expr);\n+      \n+      /* Output the block length for this list of location operations.  */\n+      dw2_asm_output_data (constant_size (size), size, \"%s\", \"Location expression size\");\n+      \n+      output_loc_sequence (curr->expr);\n+    }\n+  dw2_asm_output_data (DWARF_OFFSET_SIZE, 0, \"Location list terminator begin (%s)\", list_head->ll_symbol);\n+  dw2_asm_output_data (DWARF_OFFSET_SIZE, 0, \"Location list terminator end (%s)\", list_head->ll_symbol);\n+}\n /* Output the DIE and its attributes.  Called recursively to generate\n    the definitions of each child DIE.  */\n \n@@ -5851,7 +6012,14 @@ output_die (die)\n \tcase dw_val_class_flag:\n \t  dw2_asm_output_data (1, AT_flag (a), \"%s\", name);\n \t  break;\n-\n+        case dw_val_class_loc_list:\n+\t  {\n+\t    char *sym = AT_loc_list (a)->ll_symbol;\n+\t    if (sym == 0)\n+\t      abort();\n+\t    dw2_asm_output_delta (DWARF_OFFSET_SIZE, sym, loc_section_label, name);\n+\t  }\n+\t  break;\n \tcase dw_val_class_die_ref:\n \t  if (AT_ref_external (a))\n \t    {\n@@ -11173,7 +11341,9 @@ dwarf2out_init (asm_out_file, main_input_filename)\n \t\t\t       DEBUG_INFO_SECTION_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (debug_line_section_label,\n \t\t\t       DEBUG_LINE_SECTION_LABEL, 0);\n-\n+  ASM_GENERATE_INTERNAL_LABEL (loc_section_label, LOC_SECTION_LABEL, 0);\n+  ASM_OUTPUT_SECTION (asm_out_file, LOC_SECTION);\n+  ASM_OUTPUT_LABEL (asm_out_file, loc_section_label);\n   ASM_OUTPUT_SECTION (asm_out_file, ABBREV_SECTION);\n   ASM_OUTPUT_LABEL (asm_out_file, abbrev_section_label);\n   if (DWARF2_GENERATE_TEXT_SECTION_LABEL)\n@@ -11305,5 +11475,14 @@ dwarf2out_finish ()\n       ASM_OUTPUT_SECTION (asm_out_file, ARANGES_SECTION);\n       output_aranges ();\n     }\n+  /* Output location list section if necessary */\n+  if (have_location_lists)\n+    {\n+      /* Output the location lists info. */\n+      ASM_OUTPUT_SECTION (asm_out_file, LOC_SECTION);\n+      output_location_lists (die);\n+      have_location_lists = 0;\n+    }\n+  \n }\n #endif /* DWARF2_DEBUGGING_INFO */"}]}