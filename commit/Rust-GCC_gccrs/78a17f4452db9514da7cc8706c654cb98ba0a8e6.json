{"sha": "78a17f4452db9514da7cc8706c654cb98ba0a8e6", "node_id": "C_kwDOANBUbNoAKDc4YTE3ZjQ0NTJkYjk1MTRkYTdjYzg3MDZjNjU0Y2I5OGJhMGE4ZTY", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-30T00:56:27Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-30T00:56:27Z"}, "message": "analyzer work on issues with flex-generated lexers [PR103546]\n\nPR analyzer/103546 tracks various false positives seen on\nflex-generated lexers.\n\nWhilst investigating them, I noticed an ICE with\n-fanalyzer-call-summaries due to attempting to store sm-state\nfor an UNKNOWN svalue, which this patch fixes.\n\nThis patch also provides known_function implementations of all of the\nexternal functions called by the lexer, reducing the number of false\npositives.\n\nThe patch doesn't eliminate all false positives, but adds integration\ntests to try to establish a baseline from which the remaining false\npositives can be fixed.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/103546\n\t* analyzer.h (register_known_file_functions): New decl.\n\t* program-state.cc (sm_state_map::replay_call_summary): Rejct\n\tattempts to store sm-state for caller_sval that can't have\n\tassociated state.\n\t* region-model-impl-calls.cc (register_known_functions): Call\n\tregister_known_file_functions.\n\t* sm-fd.cc (class kf_isatty): New.\n\t(register_known_fd_functions): Register it.\n\t* sm-file.cc (class kf_ferror): New.\n\t(class kf_fileno): New.\n\t(class kf_getc): New.\n\t(register_known_file_functions): New.\n\ngcc/ChangeLog:\n\tPR analyzer/103546\n\t* doc/invoke.texi (Static Analyzer Options): Add isatty, ferror,\n\tfileno, and getc to the list of functions known to the analyzer.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/103546\n\t* gcc.dg/analyzer/ferror-1.c: New test.\n\t* gcc.dg/analyzer/fileno-1.c: New test.\n\t* gcc.dg/analyzer/flex-with-call-summaries.c: New test.\n\t* gcc.dg/analyzer/flex-without-call-summaries.c: New test.\n\t* gcc.dg/analyzer/getc-1.c: New test.\n\t* gcc.dg/analyzer/isatty-1.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "0acd6c93c966982c457ec3c02391901d8fa1aaf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0acd6c93c966982c457ec3c02391901d8fa1aaf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78a17f4452db9514da7cc8706c654cb98ba0a8e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78a17f4452db9514da7cc8706c654cb98ba0a8e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78a17f4452db9514da7cc8706c654cb98ba0a8e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78a17f4452db9514da7cc8706c654cb98ba0a8e6/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a32fb2eaa761aac13ffe5424748d5839038ef66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a32fb2eaa761aac13ffe5424748d5839038ef66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a32fb2eaa761aac13ffe5424748d5839038ef66"}], "stats": {"total": 3577, "additions": 3577, "deletions": 0}, "files": [{"sha": "35c71f3d69c33505b5de721941c9149a8b06c529", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=78a17f4452db9514da7cc8706c654cb98ba0a8e6", "patch": "@@ -259,6 +259,7 @@ class internal_known_function : public known_function\n \n extern void register_known_functions (known_function_manager &mgr);\n extern void register_known_fd_functions (known_function_manager &kfm);\n+extern void register_known_file_functions (known_function_manager &kfm);\n extern void register_varargs_builtins (known_function_manager &kfm);\n \n /* Passed by pointer to PLUGIN_ANALYZER_INIT callbacks.  */"}, {"sha": "3942b5fdc18fe429c1313f9d675323714173d228", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=78a17f4452db9514da7cc8706c654cb98ba0a8e6", "patch": "@@ -821,6 +821,8 @@ sm_state_map::replay_call_summary (call_summary_replay &r,\n       const svalue *caller_sval = r.convert_svalue_from_summary (summary_sval);\n       if (!caller_sval)\n \tcontinue;\n+      if (!caller_sval->can_have_associated_state_p ())\n+\tcontinue;\n       const svalue *summary_origin = kv.second.m_origin;\n       const svalue *caller_origin\n \t= (summary_origin"}, {"sha": "6d8c9f9413898c508d91ff91d1fadfdf20262d1a", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=78a17f4452db9514da7cc8706c654cb98ba0a8e6", "patch": "@@ -1662,6 +1662,7 @@ register_known_functions (known_function_manager &kfm)\n     kfm.add (\"putenv\", make_unique<kf_putenv> ());\n \n     register_known_fd_functions (kfm);\n+    register_known_file_functions (kfm);\n   }\n \n   /* glibc functions.  */"}, {"sha": "794733e55ca228ca895bf61dde914bd3d1109e75", "filename": "gcc/analyzer/sm-fd.cc", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Fanalyzer%2Fsm-fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Fanalyzer%2Fsm-fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-fd.cc?ref=78a17f4452db9514da7cc8706c654cb98ba0a8e6", "patch": "@@ -2487,6 +2487,84 @@ class kf_connect : public known_function\n   }\n };\n \n+/* Handler for \"isatty\"\".\n+   See e.g. https://man7.org/linux/man-pages/man3/isatty.3.html  */\n+\n+class kf_isatty : public known_function\n+{\n+  class outcome_of_isatty : public succeed_or_fail_call_info\n+  {\n+  public:\n+    outcome_of_isatty (const call_details &cd, bool success)\n+    : succeed_or_fail_call_info (cd, success)\n+    {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      const call_details cd (get_call_details (model, ctxt));\n+\n+      if (m_success)\n+\t{\n+\t  /* Return 1.  */\n+\t  model->update_for_int_cst_return (cd, 1, true);\n+\t}\n+      else\n+\t{\n+\t  /* Return 0; set errno.  */\n+\t  model->update_for_int_cst_return (cd, 0, true);\n+\t  model->set_errno (cd);\n+\t}\n+\n+      return feasible_p (cd, ctxt);\n+    }\n+\n+  private:\n+    bool feasible_p (const call_details &cd,\n+\t\t     region_model_context *ctxt) const\n+    {\n+      if (m_success)\n+\t{\n+\t  /* Can't be \"success\" on a closed/invalid fd.  */\n+\t  sm_state_map *smap;\n+\t  const fd_state_machine *fd_sm;\n+\t  std::unique_ptr<sm_context> sm_ctxt;\n+\t  if (!get_fd_state (ctxt, &smap, &fd_sm, NULL, &sm_ctxt))\n+\t    return true;\n+\t  const extrinsic_state *ext_state = ctxt->get_ext_state ();\n+\t  if (!ext_state)\n+\t    return true;\n+\n+\t  const svalue *fd_sval = cd.get_arg_svalue (0);\n+\t  state_machine::state_t old_state\n+\t    = sm_ctxt->get_state (cd.get_call_stmt (), fd_sval);\n+\n+\t  if (fd_sm->is_closed_fd_p (old_state)\n+\t      || old_state == fd_sm->m_invalid)\n+\t    return false;\n+\t}\n+      return true;\n+    }\n+  }; // class outcome_of_isatty\n+\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 1;\n+  }\n+\n+  void impl_call_post (const call_details &cd) const final override\n+  {\n+    if (cd.get_ctxt ())\n+      {\n+\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_isatty> (cd, false));\n+\tcd.get_ctxt ()->bifurcate (make_unique<outcome_of_isatty> (cd, true));\n+\tcd.get_ctxt ()->terminate_path ();\n+      }\n+  }\n+};\n+\n /* Handler for calls to \"pipe\" and \"pipe2\".\n    See e.g. https://www.man7.org/linux/man-pages/man2/pipe.2.html  */\n \n@@ -2582,6 +2660,7 @@ register_known_fd_functions (known_function_manager &kfm)\n   kfm.add (\"accept\", make_unique<kf_accept> ());\n   kfm.add (\"bind\", make_unique<kf_bind> ());\n   kfm.add (\"connect\", make_unique<kf_connect> ());\n+  kfm.add (\"isatty\", make_unique<kf_isatty> ());\n   kfm.add (\"listen\", make_unique<kf_listen> ());\n   kfm.add (\"pipe\", make_unique<kf_pipe> (1));\n   kfm.add (\"pipe2\", make_unique<kf_pipe> (2));"}, {"sha": "083c0ecbe41f234ef5d13a97a475853735ac2eba", "filename": "gcc/analyzer/sm-file.cc", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Fanalyzer%2Fsm-file.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Fanalyzer%2Fsm-file.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-file.cc?ref=78a17f4452db9514da7cc8706c654cb98ba0a8e6", "patch": "@@ -489,6 +489,59 @@ make_fileptr_state_machine (logger *logger)\n   return new fileptr_state_machine (logger);\n }\n \n+/* Handler for \"ferror\"\".  */\n+\n+class kf_ferror : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 1\n+\t    && cd.arg_is_pointer_p (0));\n+  }\n+\n+  /* No side effects.  */\n+};\n+\n+/* Handler for \"fileno\"\".  */\n+\n+class kf_fileno : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 1\n+\t    && cd.arg_is_pointer_p (0));\n+  }\n+\n+  /* No side effects.  */\n+};\n+\n+/* Handler for \"getc\"\".  */\n+\n+class kf_getc : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 1\n+\t    && cd.arg_is_pointer_p (0));\n+  }\n+\n+  /* No side effects.  */\n+};\n+\n+/* Populate KFM with instances of known functions relating to\n+   stdio streams.  */\n+\n+void\n+register_known_file_functions (known_function_manager &kfm)\n+{\n+  kfm.add (\"ferror\", make_unique<kf_ferror> ());\n+  kfm.add (\"fileno\", make_unique<kf_fileno> ());\n+  kfm.add (\"getc\", make_unique<kf_getc> ());\n+}\n+\n #if CHECKING_P\n \n namespace selftest {"}, {"sha": "56e5e875e86110523d55e2a9fd938bc41d8136fd", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=78a17f4452db9514da7cc8706c654cb98ba0a8e6", "patch": "@@ -10774,6 +10774,7 @@ of the following functions for working with file descriptors:\n @item @code{close}\n @item @code{creat}\n @item @code{dup}, @code{dup2} and @code{dup3}\n+@item @code{isatty}\n @item @code{pipe}, and @code{pipe2}\n @item @code{read}\n @item @code{write}\n@@ -10794,9 +10795,12 @@ of the following functions for working with @code{<stdio.h>} streams:\n @code{__builtin_vprintf}\n @item @code{fopen}\n @item @code{fclose}\n+@item @code{ferror}\n @item @code{fgets}\n @item @code{fgets_unlocked}\n+@item @code{fileno}\n @item @code{fread}\n+@item @code{getc}\n @item @code{getchar}\n @item @code{fprintf}\n @item @code{printf}"}, {"sha": "2570f081913e068c7f1ae693b1071e1585a96b92", "filename": "gcc/testsuite/gcc.dg/analyzer/ferror-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fferror-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fferror-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fferror-1.c?ref=78a17f4452db9514da7cc8706c654cb98ba0a8e6", "patch": "@@ -0,0 +1,6 @@\n+#include <stdio.h>\n+\n+int test_pass_through (FILE *stream)\n+{\n+  return ferror (stream);\n+}"}, {"sha": "d34e51a5022372f7c01538717b8da346fb3ec291", "filename": "gcc/testsuite/gcc.dg/analyzer/fileno-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffileno-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffileno-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffileno-1.c?ref=78a17f4452db9514da7cc8706c654cb98ba0a8e6", "patch": "@@ -0,0 +1,6 @@\n+#include <stdio.h>\n+\n+int test_pass_through (FILE *stream)\n+{\n+  return fileno (stream);\n+}"}, {"sha": "5e8580916ab77fb3648d3bdc729e07798449c0c7", "filename": "gcc/testsuite/gcc.dg/analyzer/flex-with-call-summaries.c", "status": "added", "additions": 1683, "deletions": 0, "changes": 1683, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fflex-with-call-summaries.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fflex-with-call-summaries.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fflex-with-call-summaries.c?ref=78a17f4452db9514da7cc8706c654cb98ba0a8e6", "patch": "@@ -0,0 +1,1683 @@\n+/* Integration test for compiling the output of a minimal \"flex\"\n+   script.  */\n+\n+/* { dg-additional-options \"-fanalyzer-call-summaries\" } */\n+\n+/* { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+\n+/* A lexical scanner generated by flex */\n+\n+#define  YY_INT_ALIGNED short int\n+\n+/* First, we deal with  platform-specific or compiler-specific issues. */\n+\n+/* begin standard C headers. */\n+#include <stdio.h>\n+#include <string.h>\n+#include <errno.h>\n+#include <stdlib.h>\n+\n+/* end standard C headers. */\n+\n+/* flex integer type definitions */\n+\n+#ifndef FLEXINT_H\n+#define FLEXINT_H\n+\n+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */\n+\n+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L\n+\n+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,\n+ * if you want the limit (max/min) macros for int types. \n+ */\n+#ifndef __STDC_LIMIT_MACROS\n+#define __STDC_LIMIT_MACROS 1\n+#endif\n+\n+#include <inttypes.h>\n+typedef int8_t flex_int8_t;\n+typedef uint8_t flex_uint8_t;\n+typedef int16_t flex_int16_t;\n+typedef uint16_t flex_uint16_t;\n+typedef int32_t flex_int32_t;\n+typedef uint32_t flex_uint32_t;\n+#else\n+typedef signed char flex_int8_t;\n+typedef short int flex_int16_t;\n+typedef int flex_int32_t;\n+typedef unsigned char flex_uint8_t; \n+typedef unsigned short int flex_uint16_t;\n+typedef unsigned int flex_uint32_t;\n+\n+#endif /* ! C99 */\n+\n+#endif /* ! FLEXINT_H */\n+\n+/* begin standard C++ headers. */\n+\n+/* TODO: this is always defined, so inline it */\n+#define yyconst const\n+\n+#define yynoreturn __attribute__((__noreturn__))\n+\n+/* Returned upon end-of-file. */\n+#define YY_NULL 0\n+\n+/* Promotes a possibly negative, possibly signed char to an\n+ *   integer in range [0..255] for use as an array index.\n+ */\n+#define YY_SC_TO_UI(c) ((YY_CHAR) (c))\n+\n+/* Enter a start condition.  This macro really ought to take a parameter,\n+ * but we do it the disgusting crufty way forced on us by the ()-less\n+ * definition of BEGIN.\n+ */\n+#define BEGIN (yy_start) = 1 + 2 *\n+/* Translate the current start state into a value that can be later handed\n+ * to BEGIN to return to the state.  The YYSTATE alias is for lex\n+ * compatibility.\n+ */\n+#define YY_START (((yy_start) - 1) / 2)\n+#define YYSTATE YY_START\n+/* Action number for EOF rule of a given start state. */\n+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)\n+/* Special action meaning \"start processing a new file\". */\n+#define YY_NEW_FILE yyrestart( yyin  )\n+#define YY_END_OF_BUFFER_CHAR 0\n+\n+/* Size of default input buffer. */\n+#ifndef YY_BUF_SIZE\n+#ifdef __ia64__\n+/* On IA-64, the buffer size is 16k, not 8k.\n+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.\n+ * Ditto for the __ia64__ case accordingly.\n+ */\n+#define YY_BUF_SIZE 32768\n+#else\n+#define YY_BUF_SIZE 16384\n+#endif /* __ia64__ */\n+#endif\n+\n+/* The state buf must be large enough to hold one state per character in the main buffer.\n+ */\n+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))\n+\n+#ifndef YY_TYPEDEF_YY_BUFFER_STATE\n+#define YY_TYPEDEF_YY_BUFFER_STATE\n+typedef struct yy_buffer_state *YY_BUFFER_STATE;\n+#endif\n+\n+#ifndef YY_TYPEDEF_YY_SIZE_T\n+#define YY_TYPEDEF_YY_SIZE_T\n+typedef size_t yy_size_t;\n+#endif\n+\n+extern int yyleng;\n+\n+extern FILE *yyin, *yyout;\n+\n+#define EOB_ACT_CONTINUE_SCAN 0\n+#define EOB_ACT_END_OF_FILE 1\n+#define EOB_ACT_LAST_MATCH 2\n+    \n+    #define YY_LESS_LINENO(n)\n+    #define YY_LINENO_REWIND_TO(ptr)\n+    \n+/* Return all but the first \"n\" matched characters back to the input stream. */\n+#define yyless(n) \\\n+\tdo \\\n+\t\t{ \\\n+\t\t/* Undo effects of setting up yytext. */ \\\n+        int yyless_macro_arg = (n); \\\n+        YY_LESS_LINENO(yyless_macro_arg);\\\n+\t\t*yy_cp = (yy_hold_char); \\\n+\t\tYY_RESTORE_YY_MORE_OFFSET \\\n+\t\t(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \\\n+\t\tYY_DO_BEFORE_ACTION; /* set up yytext again */ \\\n+\t\t} \\\n+\twhile ( 0 )\n+#define unput(c) yyunput( c, (yytext_ptr)  )\n+\n+#ifndef YY_STRUCT_YY_BUFFER_STATE\n+#define YY_STRUCT_YY_BUFFER_STATE\n+struct yy_buffer_state\n+\t{\n+\tFILE *yy_input_file;\n+\n+\tchar *yy_ch_buf;\t\t/* input buffer */\n+\tchar *yy_buf_pos;\t\t/* current position in input buffer */\n+\n+\t/* Size of input buffer in bytes, not including room for EOB\n+\t * characters.\n+\t */\n+\tint yy_buf_size;\n+\n+\t/* Number of characters read into yy_ch_buf, not including EOB\n+\t * characters.\n+\t */\n+\tint yy_n_chars;\n+\n+\t/* Whether we \"own\" the buffer - i.e., we know we created it,\n+\t * and can realloc() it to grow it, and should free() it to\n+\t * delete it.\n+\t */\n+\tint yy_is_our_buffer;\n+\n+\t/* Whether this is an \"interactive\" input source; if so, and\n+\t * if we're using stdio for input, then we want to use getc()\n+\t * instead of fread(), to make sure we stop fetching input after\n+\t * each newline.\n+\t */\n+\tint yy_is_interactive;\n+\n+\t/* Whether we're considered to be at the beginning of a line.\n+\t * If so, '^' rules will be active on the next match, otherwise\n+\t * not.\n+\t */\n+\tint yy_at_bol;\n+\n+    int yy_bs_lineno; /**< The line count. */\n+    int yy_bs_column; /**< The column count. */\n+\n+\t/* Whether to try to fill the input buffer when we reach the\n+\t * end of it.\n+\t */\n+\tint yy_fill_buffer;\n+\n+\tint yy_buffer_status;\n+\n+#define YY_BUFFER_NEW 0\n+#define YY_BUFFER_NORMAL 1\n+\t/* When an EOF's been seen but there's still some text to process\n+\t * then we mark the buffer as YY_EOF_PENDING, to indicate that we\n+\t * shouldn't try reading from the input source any more.  We might\n+\t * still have a bunch of tokens to match, though, because of\n+\t * possible backing-up.\n+\t *\n+\t * When we actually see the EOF, we change the status to \"new\"\n+\t * (via yyrestart()), so that the user can continue scanning by\n+\t * just pointing yyin at a new input file.\n+\t */\n+#define YY_BUFFER_EOF_PENDING 2\n+\n+\t};\n+#endif /* !YY_STRUCT_YY_BUFFER_STATE */\n+\n+/* Stack of input buffers. */\n+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */\n+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */\n+static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */\n+\n+/* We provide macros for accessing buffer states in case in the\n+ * future we want to put the buffer states in a more general\n+ * \"scanner state\".\n+ *\n+ * Returns the top of the stack, or NULL.\n+ */\n+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \\\n+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \\\n+                          : NULL)\n+/* Same as previous macro, but useful when we know that the buffer stack is not\n+ * NULL or when we need an lvalue. For internal use only.\n+ */\n+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]\n+\n+/* yy_hold_char holds the character lost when yytext is formed. */\n+static char yy_hold_char;\n+static int yy_n_chars;\t\t/* number of characters read into yy_ch_buf */\n+int yyleng;\n+\n+/* Points to current character in buffer. */\n+static char *yy_c_buf_p = NULL;\n+static int yy_init = 0;\t\t/* whether we need to initialize */\n+static int yy_start = 0;\t/* start state number */\n+\n+/* Flag which is used to allow yywrap()'s to do buffer switches\n+ * instead of setting up a fresh yyin.  A bit of a hack ...\n+ */\n+static int yy_did_buffer_switch_on_eof;\n+\n+void yyrestart ( FILE *input_file  );\n+void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );\n+YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );\n+void yy_delete_buffer ( YY_BUFFER_STATE b  );\n+void yy_flush_buffer ( YY_BUFFER_STATE b  );\n+void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );\n+void yypop_buffer_state ( void );\n+\n+static void yyensure_buffer_stack ( void );\n+static void yy_load_buffer_state ( void );\n+static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );\n+#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )\n+\n+YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );\n+YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );\n+YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );\n+\n+void *yyalloc ( yy_size_t  );\n+void *yyrealloc ( void *, yy_size_t  );\n+void yyfree ( void *  );\n+\n+#define yy_new_buffer yy_create_buffer\n+#define yy_set_interactive(is_interactive) \\\n+\t{ \\\n+\tif ( ! YY_CURRENT_BUFFER ){ \\\n+        yyensure_buffer_stack (); \\\n+\t\tYY_CURRENT_BUFFER_LVALUE =    \\\n+            yy_create_buffer( yyin, YY_BUF_SIZE ); \\\n+\t} \\\n+\tYY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \\\n+\t}\n+#define yy_set_bol(at_bol) \\\n+\t{ \\\n+\tif ( ! YY_CURRENT_BUFFER ){\\\n+        yyensure_buffer_stack (); \\\n+\t\tYY_CURRENT_BUFFER_LVALUE =    \\\n+            yy_create_buffer( yyin, YY_BUF_SIZE ); \\\n+\t} \\\n+\tYY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \\\n+\t}\n+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)\n+\n+typedef flex_uint8_t YY_CHAR;\n+\n+FILE *yyin = NULL, *yyout = NULL;\n+\n+typedef int yy_state_type;\n+\n+extern int yylineno;\n+int yylineno = 1;\n+\n+extern char *yytext;\n+#ifdef yytext_ptr\n+#undef yytext_ptr\n+#endif\n+#define yytext_ptr yytext\n+\n+static yy_state_type yy_get_previous_state ( void );\n+static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );\n+static int yy_get_next_buffer ( void );\n+static void yynoreturn yy_fatal_error ( const char* msg  );\n+\n+/* Done after the current pattern has been matched and before the\n+ * corresponding action - sets up yytext.\n+ */\n+#define YY_DO_BEFORE_ACTION \\\n+\t(yytext_ptr) = yy_bp; \\\n+\tyyleng = (int) (yy_cp - yy_bp); \\\n+\t(yy_hold_char) = *yy_cp; \\\n+\t*yy_cp = '\\0'; \\\n+\t(yy_c_buf_p) = yy_cp;\n+#define YY_NUM_RULES 1\n+#define YY_END_OF_BUFFER 2\n+/* This struct is not used in this scanner,\n+   but its presence is necessary. */\n+struct yy_trans_info\n+\t{\n+\tflex_int32_t yy_verify;\n+\tflex_int32_t yy_nxt;\n+\t};\n+static const flex_int16_t yy_accept[6] =\n+    {   0,\n+        0,    0,    2,    1,    0\n+    } ;\n+\n+static const YY_CHAR yy_ec[256] =\n+    {   0,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1\n+    } ;\n+\n+static const YY_CHAR yy_meta[2] =\n+    {   0,\n+        1\n+    } ;\n+\n+static const flex_int16_t yy_base[7] =\n+    {   0,\n+        0,    0,    2,    3,    3,    0\n+    } ;\n+\n+static const flex_int16_t yy_def[7] =\n+    {   0,\n+        6,    6,    5,    5,    0,    5\n+    } ;\n+\n+static const flex_int16_t yy_nxt[5] =\n+    {   0,\n+        4,    5,    3,    5\n+    } ;\n+\n+static const flex_int16_t yy_chk[5] =\n+    {   0,\n+        6,    3,    5,    5\n+    } ;\n+\n+static yy_state_type yy_last_accepting_state;\n+static char *yy_last_accepting_cpos;\n+\n+extern int yy_flex_debug;\n+int yy_flex_debug = 0;\n+\n+/* The intent behind this definition is that it'll catch\n+ * any uses of REJECT which flex missed.\n+ */\n+#define REJECT reject_used_but_not_detected\n+#define yymore() yymore_used_but_not_detected\n+#define YY_MORE_ADJ 0\n+#define YY_RESTORE_YY_MORE_OFFSET\n+char *yytext;\n+\n+#define INITIAL 0\n+\n+#ifndef YY_NO_UNISTD_H\n+/* Special case for \"unistd.h\", since it is non-ANSI. We include it way\n+ * down here because we want the user's section 1 to have been scanned first.\n+ * The user has a chance to override it with an option.\n+ */\n+#include <unistd.h>\n+#endif\n+\n+#ifndef YY_EXTRA_TYPE\n+#define YY_EXTRA_TYPE void *\n+#endif\n+\n+static int yy_init_globals ( void );\n+\n+/* Accessor methods to globals.\n+   These are made visible to non-reentrant scanners for convenience. */\n+\n+int yylex_destroy ( void );\n+\n+int yyget_debug ( void );\n+\n+void yyset_debug ( int debug_flag  );\n+\n+YY_EXTRA_TYPE yyget_extra ( void );\n+\n+void yyset_extra ( YY_EXTRA_TYPE user_defined  );\n+\n+FILE *yyget_in ( void );\n+\n+void yyset_in  ( FILE * _in_str  );\n+\n+FILE *yyget_out ( void );\n+\n+void yyset_out  ( FILE * _out_str  );\n+\n+\t\t\tint yyget_leng ( void );\n+\n+char *yyget_text ( void );\n+\n+int yyget_lineno ( void );\n+\n+void yyset_lineno ( int _line_number  );\n+\n+/* Macros after this point can all be overridden by user definitions in\n+ * section 1.\n+ */\n+\n+#ifndef YY_SKIP_YYWRAP\n+#ifdef __cplusplus\n+extern \"C\" int yywrap ( void );\n+#else\n+extern int yywrap ( void );\n+#endif\n+#endif\n+\n+#ifndef YY_NO_UNPUT\n+    \n+    static void yyunput ( int c, char *buf_ptr  );\n+    \n+#endif\n+\n+#ifndef yytext_ptr\n+static void yy_flex_strncpy ( char *, const char *, int );\n+#endif\n+\n+#ifdef YY_NEED_STRLEN\n+static int yy_flex_strlen ( const char * );\n+#endif\n+\n+#ifndef YY_NO_INPUT\n+#ifdef __cplusplus\n+static int yyinput ( void );\n+#else\n+static int input ( void );\n+#endif\n+\n+#endif\n+\n+/* Amount of stuff to slurp up with each read. */\n+#ifndef YY_READ_BUF_SIZE\n+#ifdef __ia64__\n+/* On IA-64, the buffer size is 16k, not 8k */\n+#define YY_READ_BUF_SIZE 16384\n+#else\n+#define YY_READ_BUF_SIZE 8192\n+#endif /* __ia64__ */\n+#endif\n+\n+/* Copy whatever the last rule matched to the standard output. */\n+#ifndef ECHO\n+/* This used to be an fputs(), but since the string might contain NUL's,\n+ * we now use fwrite().\n+ */\n+#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)\n+#endif\n+\n+/* Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,\n+ * is returned in \"result\".\n+ */\n+#ifndef YY_INPUT\n+#define YY_INPUT(buf,result,max_size) \\\n+\tif ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\\n+\t\t{ \\\n+\t\tint c = '*'; \\\n+\t\tint n; \\\n+\t\tfor ( n = 0; n < max_size && \\\n+\t\t\t     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\\n+\t\t\tbuf[n] = (char) c; \\\n+\t\tif ( c == '\\n' ) \\\n+\t\t\tbuf[n++] = (char) c; \\\n+\t\tif ( c == EOF && ferror( yyin ) ) \\\n+\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\\n+\t\tresult = n; \\\n+\t\t} \\\n+\telse \\\n+\t\t{ \\\n+\t\terrno=0; \\\n+\t\twhile ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \\\n+\t\t\t{ \\\n+\t\t\tif( errno != EINTR) \\\n+\t\t\t\t{ \\\n+\t\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\\n+\t\t\t\tbreak; \\\n+\t\t\t\t} \\\n+\t\t\terrno=0; \\\n+\t\t\tclearerr(yyin); \\\n+\t\t\t} \\\n+\t\t}\\\n+\\\n+\n+#endif\n+\n+/* No semi-colon after return; correct usage is to write \"yyterminate();\" -\n+ * we don't want an extra ';' after the \"return\" because that will cause\n+ * some compilers to complain about unreachable statements.\n+ */\n+#ifndef yyterminate\n+#define yyterminate() return YY_NULL\n+#endif\n+\n+/* Number of entries by which start-condition stack grows. */\n+#ifndef YY_START_STACK_INCR\n+#define YY_START_STACK_INCR 25\n+#endif\n+\n+/* Report a fatal error. */\n+#ifndef YY_FATAL_ERROR\n+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )\n+#endif\n+\n+/* end tables serialization structures and prototypes */\n+\n+/* Default declaration of generated scanner - a define so the user can\n+ * easily add parameters.\n+ */\n+#ifndef YY_DECL\n+#define YY_DECL_IS_OURS 1\n+\n+extern int yylex (void);\n+\n+#define YY_DECL int yylex (void)\n+#endif /* !YY_DECL */\n+\n+/* Code executed at the beginning of each rule, after yytext and yyleng\n+ * have been set up.\n+ */\n+#ifndef YY_USER_ACTION\n+#define YY_USER_ACTION\n+#endif\n+\n+/* Code executed at the end of each rule. */\n+#ifndef YY_BREAK\n+#define YY_BREAK /*LINTED*/break;\n+#endif\n+\n+#define YY_RULE_SETUP \\\n+\tYY_USER_ACTION\n+\n+/** The main scanner function which does all the work.\n+ */\n+YY_DECL\n+{\n+\tyy_state_type yy_current_state;\n+\tchar *yy_cp, *yy_bp;\n+\tint yy_act;\n+    \n+\tif ( !(yy_init) )\n+\t\t{\n+\t\t(yy_init) = 1;\n+\n+#ifdef YY_USER_INIT\n+\t\tYY_USER_INIT;\n+#endif\n+\n+\t\tif ( ! (yy_start) )\n+\t\t\t(yy_start) = 1;\t/* first start state */\n+\n+\t\tif ( ! yyin )\n+\t\t\tyyin = stdin;\n+\n+\t\tif ( ! yyout )\n+\t\t\tyyout = stdout;\n+\n+\t\tif ( ! YY_CURRENT_BUFFER ) {\n+\t\t\tyyensure_buffer_stack ();\n+\t\t\tYY_CURRENT_BUFFER_LVALUE =\n+\t\t\t\tyy_create_buffer( yyin, YY_BUF_SIZE );\n+\t\t}\n+\n+\t\tyy_load_buffer_state(  );\n+\t\t}\n+\n+\t{\n+\n+\twhile ( /*CONSTCOND*/1 )\t\t/* loops until end-of-file is reached */\n+\t\t{\n+\t\tyy_cp = (yy_c_buf_p);\n+\n+\t\t/* Support of yytext. */\n+\t\t*yy_cp = (yy_hold_char);\n+\n+\t\t/* yy_bp points to the position in yy_ch_buf of the start of\n+\t\t * the current run.\n+\t\t */\n+\t\tyy_bp = yy_cp;\n+\n+\t\tyy_current_state = (yy_start);\n+yy_match:\n+\t\tdo\n+\t\t\t{\n+\t\t\tYY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;\n+\t\t\tif ( yy_accept[yy_current_state] )\n+\t\t\t\t{\n+\t\t\t\t(yy_last_accepting_state) = yy_current_state;\n+\t\t\t\t(yy_last_accepting_cpos) = yy_cp;\n+\t\t\t\t}\n+\t\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n+\t\t\t\t{\n+\t\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n+\t\t\t\tif ( yy_current_state >= 6 )\n+\t\t\t\t\tyy_c = yy_meta[yy_c];\n+\t\t\t\t}\n+\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];\n+\t\t\t++yy_cp;\n+\t\t\t}\n+\t\twhile ( yy_base[yy_current_state] != 3 );\n+\n+yy_find_action:\n+\t\tyy_act = yy_accept[yy_current_state];\n+\t\tif ( yy_act == 0 )\n+\t\t\t{ /* have to back up */\n+\t\t\tyy_cp = (yy_last_accepting_cpos);\n+\t\t\tyy_current_state = (yy_last_accepting_state);\n+\t\t\tyy_act = yy_accept[yy_current_state];\n+\t\t\t}\n+\n+\t\tYY_DO_BEFORE_ACTION;\n+\n+do_action:\t/* This label is used only to access EOF actions. */\n+\n+\t\tswitch ( yy_act )\n+\t{ /* beginning of action switch */\n+\t\t\tcase 0: /* must back up */\n+\t\t\t/* undo the effects of YY_DO_BEFORE_ACTION */\n+\t\t\t*yy_cp = (yy_hold_char);\n+\t\t\tyy_cp = (yy_last_accepting_cpos);\n+\t\t\tyy_current_state = (yy_last_accepting_state);\n+\t\t\tgoto yy_find_action;\n+\n+case 1:\n+YY_RULE_SETUP\n+ECHO;\n+\tYY_BREAK\n+case YY_STATE_EOF(INITIAL):\n+\tyyterminate();\n+\n+\tcase YY_END_OF_BUFFER:\n+\t\t{\n+\t\t/* Amount of text matched not including the EOB char. */\n+\t\tint yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;\n+\n+\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */\n+\t\t*yy_cp = (yy_hold_char);\n+\t\tYY_RESTORE_YY_MORE_OFFSET\n+\n+\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )\n+\t\t\t{\n+\t\t\t/* We're scanning a new file or input source.  It's\n+\t\t\t * possible that this happened because the user\n+\t\t\t * just pointed yyin at a new source and called\n+\t\t\t * yylex().  If so, then we have to assure\n+\t\t\t * consistency between YY_CURRENT_BUFFER and our\n+\t\t\t * globals.  Here is the right place to do so, because\n+\t\t\t * this is the first action (other than possibly a\n+\t\t\t * back-up) that will match for the new input source.\n+\t\t\t */\n+\t\t\t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n+\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;\n+\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;\n+\t\t\t}\n+\n+\t\t/* Note that here we test for yy_c_buf_p \"<=\" to the position\n+\t\t * of the first EOB in the buffer, since yy_c_buf_p will\n+\t\t * already have been incremented past the NUL character\n+\t\t * (since all states make transitions on EOB to the\n+\t\t * end-of-buffer state).  Contrast this with the test\n+\t\t * in input().\n+\t\t */\n+\t\tif ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )\n+\t\t\t{ /* This was really a NUL. */\n+\t\t\tyy_state_type yy_next_state;\n+\n+\t\t\t(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;\n+\n+\t\t\tyy_current_state = yy_get_previous_state(  );\n+\n+\t\t\t/* Okay, we're now positioned to make the NUL\n+\t\t\t * transition.  We couldn't have\n+\t\t\t * yy_get_previous_state() go ahead and do it\n+\t\t\t * for us because it doesn't know how to deal\n+\t\t\t * with the possibility of jamming (and we don't\n+\t\t\t * want to build jamming into it because then it\n+\t\t\t * will run more slowly).\n+\t\t\t */\n+\n+\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state );\n+\n+\t\t\tyy_bp = (yytext_ptr) + YY_MORE_ADJ;\n+\n+\t\t\tif ( yy_next_state )\n+\t\t\t\t{\n+\t\t\t\t/* Consume the NUL. */\n+\t\t\t\tyy_cp = ++(yy_c_buf_p);\n+\t\t\t\tyy_current_state = yy_next_state;\n+\t\t\t\tgoto yy_match;\n+\t\t\t\t}\n+\n+\t\t\telse\n+\t\t\t\t{\n+\t\t\t\tyy_cp = (yy_c_buf_p);\n+\t\t\t\tgoto yy_find_action;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\telse switch ( yy_get_next_buffer(  ) )\n+\t\t\t{\n+\t\t\tcase EOB_ACT_END_OF_FILE:\n+\t\t\t\t{\n+\t\t\t\t(yy_did_buffer_switch_on_eof) = 0;\n+\n+\t\t\t\tif ( yywrap(  ) )\n+\t\t\t\t\t{\n+\t\t\t\t\t/* Note: because we've taken care in\n+\t\t\t\t\t * yy_get_next_buffer() to have set up\n+\t\t\t\t\t * yytext, we can now set up\n+\t\t\t\t\t * yy_c_buf_p so that if some total\n+\t\t\t\t\t * hoser (like flex itself) wants to\n+\t\t\t\t\t * call the scanner after we return the\n+\t\t\t\t\t * YY_NULL, it'll still work - another\n+\t\t\t\t\t * YY_NULL will get returned.\n+\t\t\t\t\t */\n+\t\t\t\t\t(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;\n+\n+\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);\n+\t\t\t\t\tgoto do_action;\n+\t\t\t\t\t}\n+\n+\t\t\t\telse\n+\t\t\t\t\t{\n+\t\t\t\t\tif ( ! (yy_did_buffer_switch_on_eof) )\n+\t\t\t\t\t\tYY_NEW_FILE;\n+\t\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n+\t\t\t\t(yy_c_buf_p) =\n+\t\t\t\t\t(yytext_ptr) + yy_amount_of_matched_text;\n+\n+\t\t\t\tyy_current_state = yy_get_previous_state(  );\n+\n+\t\t\t\tyy_cp = (yy_c_buf_p);\n+\t\t\t\tyy_bp = (yytext_ptr) + YY_MORE_ADJ;\n+\t\t\t\tgoto yy_match;\n+\n+\t\t\tcase EOB_ACT_LAST_MATCH:\n+\t\t\t\t(yy_c_buf_p) =\n+\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];\n+\n+\t\t\t\tyy_current_state = yy_get_previous_state(  );\n+\n+\t\t\t\tyy_cp = (yy_c_buf_p);\n+\t\t\t\tyy_bp = (yytext_ptr) + YY_MORE_ADJ;\n+\t\t\t\tgoto yy_find_action;\n+\t\t\t}\n+\t\tbreak;\n+\t\t}\n+\n+\tdefault:\n+\t\tYY_FATAL_ERROR(\n+\t\t\t\"fatal flex scanner internal error--no action found\" );\n+\t} /* end of action switch */\n+\t\t} /* end of scanning one token */\n+\t} /* end of user's declarations */\n+} /* end of yylex */\n+\n+/* yy_get_next_buffer - try to read in a new buffer\n+ *\n+ * Returns a code representing an action:\n+ *\tEOB_ACT_LAST_MATCH -\n+ *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n+ *\tEOB_ACT_END_OF_FILE - end of file\n+ */\n+static int yy_get_next_buffer (void)\n+{\n+    \tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n+\tchar *source = (yytext_ptr);\n+\tint number_to_move, i;\n+\tint ret_val;\n+\n+\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n+\t\tYY_FATAL_ERROR(\n+\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n+\n+\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n+\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n+\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n+\t\t\t{\n+\t\t\t/* We matched a single character, the EOB, so\n+\t\t\t * treat this as a final EOF.\n+\t\t\t */\n+\t\t\treturn EOB_ACT_END_OF_FILE;\n+\t\t\t}\n+\n+\t\telse\n+\t\t\t{\n+\t\t\t/* We matched some text prior to the EOB, first\n+\t\t\t * process it.\n+\t\t\t */\n+\t\t\treturn EOB_ACT_LAST_MATCH;\n+\t\t\t}\n+\t\t}\n+\n+\t/* Try to read more data. */\n+\n+\t/* First move last chars to start of buffer. */\n+\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);\n+\n+\tfor ( i = 0; i < number_to_move; ++i )\n+\t\t*(dest++) = *(source++);\n+\n+\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n+\t\t/* don't do the read, it's not guaranteed to return an EOF,\n+\t\t * just force an EOF\n+\t\t */\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n+\n+\telse\n+\t\t{\n+\t\t\tint num_to_read =\n+\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n+\n+\t\twhile ( num_to_read <= 0 )\n+\t\t\t{ /* Not enough room in the buffer - grow it. */\n+\n+\t\t\t/* just a shorter name for the current buffer */\n+\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;\n+\n+\t\t\tint yy_c_buf_p_offset =\n+\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n+\n+\t\t\tif ( b->yy_is_our_buffer )\n+\t\t\t\t{\n+\t\t\t\tint new_size = b->yy_buf_size * 2;\n+\n+\t\t\t\tif ( new_size <= 0 )\n+\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n+\t\t\t\telse\n+\t\t\t\t\tb->yy_buf_size *= 2;\n+\n+\t\t\t\tb->yy_ch_buf = (char *)  /* { dg-warning \"leak\" } */\n+\t\t\t\t\t/* Include room in for 2 EOB chars. */\n+\t\t\t\t\tyyrealloc( (void *) b->yy_ch_buf,\n+\t\t\t\t\t\t\t (yy_size_t) (b->yy_buf_size + 2)  );\n+\t\t\t\t}\n+\t\t\telse\n+\t\t\t\t/* Can't grow it, we don't own it. */\n+\t\t\t\tb->yy_ch_buf = NULL;  /* { dg-bogus \"leak\" \"\" { xfail *-*-* } } */\n+\t\t\t\t/* TODO: leak false positive: PR analyzer/103546.  */\n+\n+\t\t\tif ( ! b->yy_ch_buf )\n+\t\t\t\tYY_FATAL_ERROR(\n+\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n+\n+\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n+\n+\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n+\t\t\t\t\t\tnumber_to_move - 1;\n+\n+\t\t\t}\n+\n+\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n+\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n+\n+\t\t/* Read in more data. */\n+\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n+\t\t\t(yy_n_chars), num_to_read );\n+\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n+\t\t}\n+\n+\tif ( (yy_n_chars) == 0 )\n+\t\t{\n+\t\tif ( number_to_move == YY_MORE_ADJ )\n+\t\t\t{\n+\t\t\tret_val = EOB_ACT_END_OF_FILE;\n+\t\t\tyyrestart( yyin  );/* { dg-bogus \"leak\" \"\" { xfail *-*-* } } */\n+\t\t\t/* TODO: leak false positive: PR analyzer/103546.  */\n+\t\t\t}\n+\n+\t\telse\n+\t\t\t{\n+\t\t\tret_val = EOB_ACT_LAST_MATCH;\n+\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n+\t\t\t\tYY_BUFFER_EOF_PENDING;\n+\t\t\t}\n+\t\t}\n+\n+\telse\n+\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n+\n+\tif (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n+\t\t/* Extend the array by 50%, plus the number we really need. */\n+\t\tint new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(\n+\t\t\t(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );\n+\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n+\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n+\t\t/* \"- 2\" to take care of EOB's */\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);\n+\t}\n+\n+\t(yy_n_chars) += number_to_move;\n+\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n+\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n+\n+\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n+\n+\treturn ret_val;\n+}\n+\n+/* yy_get_previous_state - get the state just before the EOB char was reached */\n+\n+    static yy_state_type yy_get_previous_state (void)\n+{\n+\tyy_state_type yy_current_state;\n+\tchar *yy_cp;\n+    \n+\tyy_current_state = (yy_start);\n+\n+\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n+\t\t{\n+\t\tYY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n+\t\tif ( yy_accept[yy_current_state] )\n+\t\t\t{\n+\t\t\t(yy_last_accepting_state) = yy_current_state;\n+\t\t\t(yy_last_accepting_cpos) = yy_cp;\n+\t\t\t}\n+\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n+\t\t\t{\n+\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n+\t\t\tif ( yy_current_state >= 6 )\n+\t\t\t\tyy_c = yy_meta[yy_c];\n+\t\t\t}\n+\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];\n+\t\t}\n+\n+\treturn yy_current_state;\n+}\n+\n+/* yy_try_NUL_trans - try to make a transition on the NUL character\n+ *\n+ * synopsis\n+ *\tnext_state = yy_try_NUL_trans( current_state );\n+ */\n+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )\n+{\n+\tint yy_is_jam;\n+    \tchar *yy_cp = (yy_c_buf_p);\n+\n+\tYY_CHAR yy_c = 1;\n+\tif ( yy_accept[yy_current_state] )\n+\t\t{\n+\t\t(yy_last_accepting_state) = yy_current_state;\n+\t\t(yy_last_accepting_cpos) = yy_cp;\n+\t\t}\n+\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n+\t\t{\n+\t\tyy_current_state = (int) yy_def[yy_current_state];\n+\t\tif ( yy_current_state >= 6 )\n+\t\t\tyy_c = yy_meta[yy_c];\n+\t\t}\n+\tyy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];\n+\tyy_is_jam = (yy_current_state == 5);\n+\n+\t\treturn yy_is_jam ? 0 : yy_current_state;\n+}\n+\n+#ifndef YY_NO_UNPUT\n+\n+    static void yyunput (int c, char * yy_bp )\n+{\n+\tchar *yy_cp;\n+    \n+    yy_cp = (yy_c_buf_p);\n+\n+\t/* undo effects of setting up yytext */\n+\t*yy_cp = (yy_hold_char);\n+\n+\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n+\t\t{ /* need to shift things up to make room */\n+\t\t/* +2 for EOB chars. */\n+\t\tint number_to_move = (yy_n_chars) + 2;\n+\t\tchar *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[\n+\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];\n+\t\tchar *source =\n+\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];\n+\n+\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n+\t\t\t*--dest = *--source;\n+\n+\t\tyy_cp += (int) (dest - source);\n+\t\tyy_bp += (int) (dest - source);\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars =\n+\t\t\t(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;\n+\n+\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n+\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n+\t\t}\n+\n+\t*--yy_cp = (char) c;\n+\n+\t(yytext_ptr) = yy_bp;\n+\t(yy_hold_char) = *yy_cp;\n+\t(yy_c_buf_p) = yy_cp;\n+}\n+\n+#endif\n+\n+#ifndef YY_NO_INPUT\n+#ifdef __cplusplus\n+    static int yyinput (void)\n+#else\n+    static int input  (void)\n+#endif\n+\n+{\n+\tint c;\n+    \n+\t*(yy_c_buf_p) = (yy_hold_char);\n+\n+\tif ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )\n+\t\t{\n+\t\t/* yy_c_buf_p now points to the character we want to return.\n+\t\t * If this occurs *before* the EOB characters, then it's a\n+\t\t * valid NUL; if not, then we've hit the end of the buffer.\n+\t\t */\n+\t\tif ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )\n+\t\t\t/* This was really a NUL. */\n+\t\t\t*(yy_c_buf_p) = '\\0';\n+\n+\t\telse\n+\t\t\t{ /* need more input */\n+\t\t\tint offset = (int) ((yy_c_buf_p) - (yytext_ptr));\n+\t\t\t++(yy_c_buf_p);\n+\n+\t\t\tswitch ( yy_get_next_buffer(  ) )\n+\t\t\t\t{\n+\t\t\t\tcase EOB_ACT_LAST_MATCH:\n+\t\t\t\t\t/* This happens because yy_g_n_b()\n+\t\t\t\t\t * sees that we've accumulated a\n+\t\t\t\t\t * token and flags that we need to\n+\t\t\t\t\t * try matching the token before\n+\t\t\t\t\t * proceeding.  But for input(),\n+\t\t\t\t\t * there's no matching to consider.\n+\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n+\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n+\t\t\t\t\t */\n+\n+\t\t\t\t\t/* Reset buffer status. */\n+\t\t\t\t\tyyrestart( yyin );\n+\n+\t\t\t\t\t/*FALLTHROUGH*/\n+\n+\t\t\t\tcase EOB_ACT_END_OF_FILE:\n+\t\t\t\t\t{\n+\t\t\t\t\tif ( yywrap(  ) )\n+\t\t\t\t\t\treturn 0;\n+\n+\t\t\t\t\tif ( ! (yy_did_buffer_switch_on_eof) )\n+\t\t\t\t\t\tYY_NEW_FILE;\n+#ifdef __cplusplus\n+\t\t\t\t\treturn yyinput();\n+#else\n+\t\t\t\t\treturn input();  /* { dg-bogus \"infinite recursion\" \"\" { xfail *-*-* } } */\n+\t\t\t\t\t/* TODO: infinite recursion positive: PR analyzer/103546.  */\n+#endif\n+\t\t\t\t\t}\n+\n+\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n+\t\t\t\t\t(yy_c_buf_p) = (yytext_ptr) + offset;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\tc = *(unsigned char *) (yy_c_buf_p);\t/* cast for 8-bit char's */\n+\t*(yy_c_buf_p) = '\\0';\t/* preserve yytext */\n+\t(yy_hold_char) = *++(yy_c_buf_p);\n+\n+\treturn c;\n+}\n+#endif\t/* ifndef YY_NO_INPUT */\n+\n+/** Immediately switch to a different input stream.\n+ * @param input_file A readable stream.\n+ * \n+ * @note This function does not reset the start condition to @c INITIAL .\n+ */\n+\n+void yyrestart  (FILE * input_file )\n+{\n+    \n+\tif ( ! YY_CURRENT_BUFFER ){\n+\t        yyensure_buffer_stack ();\n+\t\tYY_CURRENT_BUFFER_LVALUE = yy_create_buffer( yyin, YY_BUF_SIZE );\n+\t}\n+\n+\tyy_init_buffer( YY_CURRENT_BUFFER, input_file );\n+\tyy_load_buffer_state(  );\n+}\n+\n+/** Switch to a different input buffer.\n+ * @param new_buffer The new input buffer.\n+ * \n+ */\n+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n+{\n+    \n+\t/* TODO. We should be able to replace this entire function body\n+\t * with\n+\t *\t\tyypop_buffer_state();\n+\t *\t\tyypush_buffer_state(new_buffer);\n+     */\n+\tyyensure_buffer_stack ();\n+\tif ( YY_CURRENT_BUFFER == new_buffer )\n+\t\treturn;\n+\n+\tif ( YY_CURRENT_BUFFER )\n+\t\t{\n+\t\t/* Flush out information for old buffer. */\n+\t\t*(yy_c_buf_p) = (yy_hold_char);\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n+\t\t}\n+\n+\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n+\tyy_load_buffer_state(  );\n+\n+\t/* We don't actually know whether we did this switch during\n+\t * EOF (yywrap()) processing, but the only time this flag\n+\t * is looked at is after yywrap() is called, so it's safe\n+\t * to go ahead and always set it.\n+\t */\n+\t(yy_did_buffer_switch_on_eof) = 1;\n+}\n+\n+static void yy_load_buffer_state  (void)\n+{\n+    \t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n+\t(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n+\tyyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n+\t(yy_hold_char) = *(yy_c_buf_p);\n+}\n+\n+/** Allocate and initialize an input buffer state.\n+ * @param file A readable stream.\n+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.\n+ * \n+ * @return the allocated buffer state.\n+ */\n+\n+YY_BUFFER_STATE\n+yy_create_buffer (FILE * file, int  size )\n+{\n+\tYY_BUFFER_STATE b;\n+    \n+\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );\n+\tif ( ! b )\n+\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n+\n+\tb->yy_buf_size = size;\n+\n+\t/* yy_ch_buf has to be 2 characters longer than the size given because\n+\t * we need to put in 2 end-of-buffer characters.\n+\t */\n+\tb->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );\n+\tif ( ! b->yy_ch_buf )\n+\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n+\n+\tb->yy_is_our_buffer = 1;\n+\n+\tyy_init_buffer( b, file );  /* { dg-bogus \"leak\" \"\" { xfail *-*-* } } */\n+\t/* TODO: leak false positive: PR analyzer/103546.  */\n+\n+\treturn b;\n+}\n+\n+/** Destroy the buffer.\n+ * @param b a buffer created with yy_create_buffer()\n+ * \n+ */\n+\n+void yy_delete_buffer (YY_BUFFER_STATE  b )\n+{\n+    \n+\tif ( ! b )\n+\t\treturn;\n+\n+\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n+\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n+\n+\tif ( b->yy_is_our_buffer )\n+\t\tyyfree( (void *) b->yy_ch_buf  );\n+\n+\tyyfree( (void *) b  );\n+}\n+\n+/* Initializes or reinitializes a buffer.\n+ * This function is sometimes called more than once on the same buffer,\n+ * such as during a yyrestart() or at EOF.\n+ */\n+\n+static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n+{\n+\tint oerrno = errno;\n+    \n+\tyy_flush_buffer( b );\n+\n+\tb->yy_input_file = file;\n+\tb->yy_fill_buffer = 1;\n+\n+    /* If b is the current buffer, then yy_init_buffer was _probably_\n+     * called from yyrestart() or through yy_get_next_buffer.\n+     * In that case, we don't want to reset the lineno or column.\n+     */\n+    if (b != YY_CURRENT_BUFFER){\n+        b->yy_bs_lineno = 1;\n+        b->yy_bs_column = 0;\n+    }\n+\n+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n+    \n+\terrno = oerrno;\n+}\n+\n+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.\n+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.\n+ * \n+ */\n+void yy_flush_buffer (YY_BUFFER_STATE  b )\n+{\n+    \tif ( ! b )\n+\t\treturn;\n+\n+\tb->yy_n_chars = 0;\n+\n+\t/* We always need two end-of-buffer characters.  The first causes\n+\t * a transition to the end-of-buffer state.  The second causes\n+\t * a jam in that state.\n+\t */\n+\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n+\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n+\n+\tb->yy_buf_pos = &b->yy_ch_buf[0];\n+\n+\tb->yy_at_bol = 1;\n+\tb->yy_buffer_status = YY_BUFFER_NEW;\n+\n+\tif ( b == YY_CURRENT_BUFFER )\n+\t\tyy_load_buffer_state(  );\n+}\n+\n+/** Pushes the new state onto the stack. The new state becomes\n+ *  the current state. This function will allocate the stack\n+ *  if necessary.\n+ *  @param new_buffer The new state.\n+ *  \n+ */\n+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )\n+{\n+    \tif (new_buffer == NULL)\n+\t\treturn;\n+\n+\tyyensure_buffer_stack();\n+\n+\t/* This block is copied from yy_switch_to_buffer. */\n+\tif ( YY_CURRENT_BUFFER )\n+\t\t{\n+\t\t/* Flush out information for old buffer. */\n+\t\t*(yy_c_buf_p) = (yy_hold_char);\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n+\t\t}\n+\n+\t/* Only push if top exists. Otherwise, replace top. */\n+\tif (YY_CURRENT_BUFFER)\n+\t\t(yy_buffer_stack_top)++;\n+\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n+\n+\t/* copied from yy_switch_to_buffer. */\n+\tyy_load_buffer_state(  );\n+\t(yy_did_buffer_switch_on_eof) = 1;\n+}\n+\n+/** Removes and deletes the top of the stack, if present.\n+ *  The next element becomes the new top.\n+ *  \n+ */\n+void yypop_buffer_state (void)\n+{\n+    \tif (!YY_CURRENT_BUFFER)\n+\t\treturn;\n+\n+\tyy_delete_buffer(YY_CURRENT_BUFFER );\n+\tYY_CURRENT_BUFFER_LVALUE = NULL;\n+\tif ((yy_buffer_stack_top) > 0)\n+\t\t--(yy_buffer_stack_top);\n+\n+\tif (YY_CURRENT_BUFFER) {\n+\t\tyy_load_buffer_state(  );\n+\t\t(yy_did_buffer_switch_on_eof) = 1;\n+\t}\n+}\n+\n+/* Allocates the stack if it does not exist.\n+ *  Guarantees space for at least one push.\n+ */\n+static void yyensure_buffer_stack (void)\n+{\n+\tyy_size_t num_to_alloc;\n+    \n+\tif (!(yy_buffer_stack)) {\n+\n+\t\t/* First allocation is just for 2 elements, since we don't know if this\n+\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n+\t\t * immediate realloc on the next call.\n+         */\n+      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */\n+\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc\n+\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n+\t\t\t\t\t\t\t\t);\n+\t\tif ( ! (yy_buffer_stack) )\n+\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n+\n+\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n+\n+\t\t(yy_buffer_stack_max) = num_to_alloc;\n+\t\t(yy_buffer_stack_top) = 0;\n+\t\treturn;\n+\t}\n+\n+\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n+\n+\t\t/* Increase the buffer to prepare for a possible push. */\n+\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;\n+\n+\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n+\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc\n+\t\t\t\t\t\t\t\t((yy_buffer_stack),\n+\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n+\t\t\t\t\t\t\t\t);\n+\t\tif ( ! (yy_buffer_stack) )\n+\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n+\n+\t\t/* zero only the new slots.*/\n+\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n+\t\t(yy_buffer_stack_max) = num_to_alloc;\n+\t}\n+}\n+\n+/** Setup the input buffer state to scan directly from a user-specified character buffer.\n+ * @param base the character buffer\n+ * @param size the size in bytes of the character buffer\n+ * \n+ * @return the newly allocated buffer state object.\n+ */\n+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )\n+{\n+\tYY_BUFFER_STATE b;\n+    \n+\tif ( size < 2 ||\n+\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n+\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n+\t\t/* They forgot to leave room for the EOB's. */\n+\t\treturn NULL;\n+\n+\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );\n+\tif ( ! b )\n+\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n+\n+\tb->yy_buf_size = (int) (size - 2);\t/* \"- 2\" to take care of EOB's */\n+\tb->yy_buf_pos = b->yy_ch_buf = base;\n+\tb->yy_is_our_buffer = 0;\n+\tb->yy_input_file = NULL;\n+\tb->yy_n_chars = b->yy_buf_size;\n+\tb->yy_is_interactive = 0;\n+\tb->yy_at_bol = 1;\n+\tb->yy_fill_buffer = 0;\n+\tb->yy_buffer_status = YY_BUFFER_NEW;\n+\n+\tyy_switch_to_buffer( b  );\n+\n+\treturn b;\n+}\n+\n+/** Setup the input buffer state to scan a string. The next call to yylex() will\n+ * scan from a @e copy of @a str.\n+ * @param yystr a NUL-terminated string to scan\n+ * \n+ * @return the newly allocated buffer state object.\n+ * @note If you want to scan bytes that may contain NUL values, then use\n+ *       yy_scan_bytes() instead.\n+ */\n+YY_BUFFER_STATE yy_scan_string (const char * yystr )\n+{\n+    \n+\treturn yy_scan_bytes( yystr, (int) strlen(yystr) );\n+}\n+\n+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will\n+ * scan from a @e copy of @a bytes.\n+ * @param yybytes the byte buffer to scan\n+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.\n+ * \n+ * @return the newly allocated buffer state object.\n+ */\n+YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )\n+{\n+\tYY_BUFFER_STATE b;\n+\tchar *buf;\n+\tyy_size_t n;\n+\tint i;\n+    \n+\t/* Get memory for full buffer, including space for trailing EOB's. */\n+\tn = (yy_size_t) (_yybytes_len + 2);\n+\tbuf = (char *) yyalloc( n  );\n+\tif ( ! buf )\n+\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n+\n+\tfor ( i = 0; i < _yybytes_len; ++i )\n+\t\tbuf[i] = yybytes[i];\n+\n+\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n+\n+\tb = yy_scan_buffer( buf, n );\n+\tif ( ! b )\n+\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n+\n+\t/* It's okay to grow etc. this buffer, and we should throw it\n+\t * away when we're done.\n+\t */\n+\tb->yy_is_our_buffer = 1;\n+\n+\treturn b;  /* { dg-bogus \"leak\" \"\" { xfail *-*-* } } */\n+\t/* TODO: leak false positive: PR analyzer/103546.  */\n+}\n+\n+#ifndef YY_EXIT_FAILURE\n+#define YY_EXIT_FAILURE 2\n+#endif\n+\n+static void yynoreturn yy_fatal_error (const char* msg )\n+{\n+\t\t\tfprintf( stderr, \"%s\\n\", msg );\n+\texit( YY_EXIT_FAILURE );\n+}\n+\n+/* Redefine yyless() so it works in section 3 code. */\n+\n+#undef yyless\n+#define yyless(n) \\\n+\tdo \\\n+\t\t{ \\\n+\t\t/* Undo effects of setting up yytext. */ \\\n+        int yyless_macro_arg = (n); \\\n+        YY_LESS_LINENO(yyless_macro_arg);\\\n+\t\tyytext[yyleng] = (yy_hold_char); \\\n+\t\t(yy_c_buf_p) = yytext + yyless_macro_arg; \\\n+\t\t(yy_hold_char) = *(yy_c_buf_p); \\\n+\t\t*(yy_c_buf_p) = '\\0'; \\\n+\t\tyyleng = yyless_macro_arg; \\\n+\t\t} \\\n+\twhile ( 0 )\n+\n+/* Accessor  methods (get/set functions) to struct members. */\n+\n+/** Get the current line number.\n+ * \n+ */\n+int yyget_lineno  (void)\n+{\n+    \n+    return yylineno;\n+}\n+\n+/** Get the input stream.\n+ * \n+ */\n+FILE *yyget_in  (void)\n+{\n+        return yyin;\n+}\n+\n+/** Get the output stream.\n+ * \n+ */\n+FILE *yyget_out  (void)\n+{\n+        return yyout;\n+}\n+\n+/** Get the length of the current token.\n+ * \n+ */\n+int yyget_leng  (void)\n+{\n+        return yyleng;\n+}\n+\n+/** Get the current token.\n+ * \n+ */\n+\n+char *yyget_text  (void)\n+{\n+        return yytext;\n+}\n+\n+/** Set the current line number.\n+ * @param _line_number line number\n+ * \n+ */\n+void yyset_lineno (int  _line_number )\n+{\n+    \n+    yylineno = _line_number;\n+}\n+\n+/** Set the input stream. This does not discard the current\n+ * input buffer.\n+ * @param _in_str A readable stream.\n+ * \n+ * @see yy_switch_to_buffer\n+ */\n+void yyset_in (FILE *  _in_str )\n+{\n+        yyin = _in_str ;\n+}\n+\n+void yyset_out (FILE *  _out_str )\n+{\n+        yyout = _out_str ;\n+}\n+\n+int yyget_debug  (void)\n+{\n+        return yy_flex_debug;\n+}\n+\n+void yyset_debug (int  _bdebug )\n+{\n+        yy_flex_debug = _bdebug ;\n+}\n+\n+static int yy_init_globals (void)\n+{\n+        /* Initialization is the same as for the non-reentrant scanner.\n+     * This function is called from yylex_destroy(), so don't allocate here.\n+     */\n+\n+    (yy_buffer_stack) = NULL;\n+    (yy_buffer_stack_top) = 0;\n+    (yy_buffer_stack_max) = 0;\n+    (yy_c_buf_p) = NULL;\n+    (yy_init) = 0;\n+    (yy_start) = 0;\n+\n+/* Defined in main.c */\n+#ifdef YY_STDINIT\n+    yyin = stdin;\n+    yyout = stdout;\n+#else\n+    yyin = NULL;\n+    yyout = NULL;\n+#endif\n+\n+    /* For future reference: Set errno on error, since we are called by\n+     * yylex_init()\n+     */\n+    return 0;\n+}\n+\n+/* yylex_destroy is for both reentrant and non-reentrant scanners. */\n+int yylex_destroy  (void)\n+{\n+    \n+    /* Pop the buffer stack, destroying each element. */\n+\twhile(YY_CURRENT_BUFFER){\n+\t\tyy_delete_buffer( YY_CURRENT_BUFFER  );\n+\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n+\t\tyypop_buffer_state();\n+\t}\n+\n+\t/* Destroy the stack itself. */\n+\tyyfree((yy_buffer_stack) );\n+\t(yy_buffer_stack) = NULL;\n+\n+    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n+     * yylex() is called, initialization will occur. */\n+    yy_init_globals( );\n+\n+    return 0;\n+}\n+\n+/*\n+ * Internal utility routines.\n+ */\n+\n+#ifndef yytext_ptr\n+static void yy_flex_strncpy (char* s1, const char * s2, int n )\n+{\n+\t\t\n+\tint i;\n+\tfor ( i = 0; i < n; ++i )\n+\t\ts1[i] = s2[i];\n+}\n+#endif\n+\n+#ifdef YY_NEED_STRLEN\n+static int yy_flex_strlen (const char * s )\n+{\n+\tint n;\n+\tfor ( n = 0; s[n]; ++n )\n+\t\t;\n+\n+\treturn n;\n+}\n+#endif\n+\n+void *yyalloc (yy_size_t  size )\n+{\n+\t\t\treturn malloc(size);\n+}\n+\n+void *yyrealloc  (void * ptr, yy_size_t  size )\n+{\n+\t\t\n+\t/* The cast to (char *) in the following accommodates both\n+\t * implementations that use char* generic pointers, and those\n+\t * that use void* generic pointers.  It works with the latter\n+\t * because both ANSI C and C++ allow castless assignment from\n+\t * any pointer type to void*, and deal with argument conversions\n+\t * as though doing an assignment.\n+\t */\n+\treturn realloc(ptr, size);\n+}\n+\n+void yyfree (void * ptr )\n+{\n+\t\t\tfree( (char *) ptr );\t/* see yyrealloc() for (char *) cast */\n+}\n+\n+#define YYTABLES_NAME \"yytables\""}, {"sha": "5b4a9868c2f29bea9ea17d6ad42aa5d900ca23aa", "filename": "gcc/testsuite/gcc.dg/analyzer/flex-without-call-summaries.c", "status": "added", "additions": 1680, "deletions": 0, "changes": 1680, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fflex-without-call-summaries.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fflex-without-call-summaries.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fflex-without-call-summaries.c?ref=78a17f4452db9514da7cc8706c654cb98ba0a8e6", "patch": "@@ -0,0 +1,1680 @@\n+/* Integration test for compiling the output of a minimal \"flex\"\n+   script.  */\n+\n+/* { dg-additional-options \"-fno-analyzer-call-summaries\" } */\n+\n+/* { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+\n+\n+/* A lexical scanner generated by flex */\n+\n+#define  YY_INT_ALIGNED short int\n+\n+/* First, we deal with  platform-specific or compiler-specific issues. */\n+\n+/* begin standard C headers. */\n+#include <stdio.h>\n+#include <string.h>\n+#include <errno.h>\n+#include <stdlib.h>\n+\n+/* end standard C headers. */\n+\n+/* flex integer type definitions */\n+\n+#ifndef FLEXINT_H\n+#define FLEXINT_H\n+\n+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */\n+\n+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L\n+\n+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,\n+ * if you want the limit (max/min) macros for int types. \n+ */\n+#ifndef __STDC_LIMIT_MACROS\n+#define __STDC_LIMIT_MACROS 1\n+#endif\n+\n+#include <inttypes.h>\n+typedef int8_t flex_int8_t;\n+typedef uint8_t flex_uint8_t;\n+typedef int16_t flex_int16_t;\n+typedef uint16_t flex_uint16_t;\n+typedef int32_t flex_int32_t;\n+typedef uint32_t flex_uint32_t;\n+#else\n+typedef signed char flex_int8_t;\n+typedef short int flex_int16_t;\n+typedef int flex_int32_t;\n+typedef unsigned char flex_uint8_t; \n+typedef unsigned short int flex_uint16_t;\n+typedef unsigned int flex_uint32_t;\n+\n+#endif /* ! C99 */\n+\n+#endif /* ! FLEXINT_H */\n+\n+/* begin standard C++ headers. */\n+\n+/* TODO: this is always defined, so inline it */\n+#define yyconst const\n+\n+#define yynoreturn __attribute__((__noreturn__))\n+\n+/* Returned upon end-of-file. */\n+#define YY_NULL 0\n+\n+/* Promotes a possibly negative, possibly signed char to an\n+ *   integer in range [0..255] for use as an array index.\n+ */\n+#define YY_SC_TO_UI(c) ((YY_CHAR) (c))\n+\n+/* Enter a start condition.  This macro really ought to take a parameter,\n+ * but we do it the disgusting crufty way forced on us by the ()-less\n+ * definition of BEGIN.\n+ */\n+#define BEGIN (yy_start) = 1 + 2 *\n+/* Translate the current start state into a value that can be later handed\n+ * to BEGIN to return to the state.  The YYSTATE alias is for lex\n+ * compatibility.\n+ */\n+#define YY_START (((yy_start) - 1) / 2)\n+#define YYSTATE YY_START\n+/* Action number for EOF rule of a given start state. */\n+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)\n+/* Special action meaning \"start processing a new file\". */\n+#define YY_NEW_FILE yyrestart( yyin  )\n+#define YY_END_OF_BUFFER_CHAR 0\n+\n+/* Size of default input buffer. */\n+#ifndef YY_BUF_SIZE\n+#ifdef __ia64__\n+/* On IA-64, the buffer size is 16k, not 8k.\n+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.\n+ * Ditto for the __ia64__ case accordingly.\n+ */\n+#define YY_BUF_SIZE 32768\n+#else\n+#define YY_BUF_SIZE 16384\n+#endif /* __ia64__ */\n+#endif\n+\n+/* The state buf must be large enough to hold one state per character in the main buffer.\n+ */\n+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))\n+\n+#ifndef YY_TYPEDEF_YY_BUFFER_STATE\n+#define YY_TYPEDEF_YY_BUFFER_STATE\n+typedef struct yy_buffer_state *YY_BUFFER_STATE;\n+#endif\n+\n+#ifndef YY_TYPEDEF_YY_SIZE_T\n+#define YY_TYPEDEF_YY_SIZE_T\n+typedef size_t yy_size_t;\n+#endif\n+\n+extern int yyleng;\n+\n+extern FILE *yyin, *yyout;\n+\n+#define EOB_ACT_CONTINUE_SCAN 0\n+#define EOB_ACT_END_OF_FILE 1\n+#define EOB_ACT_LAST_MATCH 2\n+    \n+    #define YY_LESS_LINENO(n)\n+    #define YY_LINENO_REWIND_TO(ptr)\n+    \n+/* Return all but the first \"n\" matched characters back to the input stream. */\n+#define yyless(n) \\\n+\tdo \\\n+\t\t{ \\\n+\t\t/* Undo effects of setting up yytext. */ \\\n+        int yyless_macro_arg = (n); \\\n+        YY_LESS_LINENO(yyless_macro_arg);\\\n+\t\t*yy_cp = (yy_hold_char); \\\n+\t\tYY_RESTORE_YY_MORE_OFFSET \\\n+\t\t(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \\\n+\t\tYY_DO_BEFORE_ACTION; /* set up yytext again */ \\\n+\t\t} \\\n+\twhile ( 0 )\n+#define unput(c) yyunput( c, (yytext_ptr)  )\n+\n+#ifndef YY_STRUCT_YY_BUFFER_STATE\n+#define YY_STRUCT_YY_BUFFER_STATE\n+struct yy_buffer_state\n+\t{\n+\tFILE *yy_input_file;\n+\n+\tchar *yy_ch_buf;\t\t/* input buffer */\n+\tchar *yy_buf_pos;\t\t/* current position in input buffer */\n+\n+\t/* Size of input buffer in bytes, not including room for EOB\n+\t * characters.\n+\t */\n+\tint yy_buf_size;\n+\n+\t/* Number of characters read into yy_ch_buf, not including EOB\n+\t * characters.\n+\t */\n+\tint yy_n_chars;\n+\n+\t/* Whether we \"own\" the buffer - i.e., we know we created it,\n+\t * and can realloc() it to grow it, and should free() it to\n+\t * delete it.\n+\t */\n+\tint yy_is_our_buffer;\n+\n+\t/* Whether this is an \"interactive\" input source; if so, and\n+\t * if we're using stdio for input, then we want to use getc()\n+\t * instead of fread(), to make sure we stop fetching input after\n+\t * each newline.\n+\t */\n+\tint yy_is_interactive;\n+\n+\t/* Whether we're considered to be at the beginning of a line.\n+\t * If so, '^' rules will be active on the next match, otherwise\n+\t * not.\n+\t */\n+\tint yy_at_bol;\n+\n+    int yy_bs_lineno; /**< The line count. */\n+    int yy_bs_column; /**< The column count. */\n+\n+\t/* Whether to try to fill the input buffer when we reach the\n+\t * end of it.\n+\t */\n+\tint yy_fill_buffer;\n+\n+\tint yy_buffer_status;\n+\n+#define YY_BUFFER_NEW 0\n+#define YY_BUFFER_NORMAL 1\n+\t/* When an EOF's been seen but there's still some text to process\n+\t * then we mark the buffer as YY_EOF_PENDING, to indicate that we\n+\t * shouldn't try reading from the input source any more.  We might\n+\t * still have a bunch of tokens to match, though, because of\n+\t * possible backing-up.\n+\t *\n+\t * When we actually see the EOF, we change the status to \"new\"\n+\t * (via yyrestart()), so that the user can continue scanning by\n+\t * just pointing yyin at a new input file.\n+\t */\n+#define YY_BUFFER_EOF_PENDING 2\n+\n+\t};\n+#endif /* !YY_STRUCT_YY_BUFFER_STATE */\n+\n+/* Stack of input buffers. */\n+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */\n+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */\n+static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */\n+\n+/* We provide macros for accessing buffer states in case in the\n+ * future we want to put the buffer states in a more general\n+ * \"scanner state\".\n+ *\n+ * Returns the top of the stack, or NULL.\n+ */\n+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \\\n+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \\\n+                          : NULL)\n+/* Same as previous macro, but useful when we know that the buffer stack is not\n+ * NULL or when we need an lvalue. For internal use only.\n+ */\n+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]\n+\n+/* yy_hold_char holds the character lost when yytext is formed. */\n+static char yy_hold_char;\n+static int yy_n_chars;\t\t/* number of characters read into yy_ch_buf */\n+int yyleng;\n+\n+/* Points to current character in buffer. */\n+static char *yy_c_buf_p = NULL;\n+static int yy_init = 0;\t\t/* whether we need to initialize */\n+static int yy_start = 0;\t/* start state number */\n+\n+/* Flag which is used to allow yywrap()'s to do buffer switches\n+ * instead of setting up a fresh yyin.  A bit of a hack ...\n+ */\n+static int yy_did_buffer_switch_on_eof;\n+\n+void yyrestart ( FILE *input_file  );\n+void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );\n+YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );\n+void yy_delete_buffer ( YY_BUFFER_STATE b  );\n+void yy_flush_buffer ( YY_BUFFER_STATE b  );\n+void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );\n+void yypop_buffer_state ( void );\n+\n+static void yyensure_buffer_stack ( void );\n+static void yy_load_buffer_state ( void );\n+static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );\n+#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )\n+\n+YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );\n+YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );\n+YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );\n+\n+void *yyalloc ( yy_size_t  );\n+void *yyrealloc ( void *, yy_size_t  );\n+void yyfree ( void *  );\n+\n+#define yy_new_buffer yy_create_buffer\n+#define yy_set_interactive(is_interactive) \\\n+\t{ \\\n+\tif ( ! YY_CURRENT_BUFFER ){ \\\n+        yyensure_buffer_stack (); \\\n+\t\tYY_CURRENT_BUFFER_LVALUE =    \\\n+            yy_create_buffer( yyin, YY_BUF_SIZE ); \\\n+\t} \\\n+\tYY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \\\n+\t}\n+#define yy_set_bol(at_bol) \\\n+\t{ \\\n+\tif ( ! YY_CURRENT_BUFFER ){\\\n+        yyensure_buffer_stack (); \\\n+\t\tYY_CURRENT_BUFFER_LVALUE =    \\\n+            yy_create_buffer( yyin, YY_BUF_SIZE ); \\\n+\t} \\\n+\tYY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \\\n+\t}\n+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)\n+\n+typedef flex_uint8_t YY_CHAR;\n+\n+FILE *yyin = NULL, *yyout = NULL;\n+\n+typedef int yy_state_type;\n+\n+extern int yylineno;\n+int yylineno = 1;\n+\n+extern char *yytext;\n+#ifdef yytext_ptr\n+#undef yytext_ptr\n+#endif\n+#define yytext_ptr yytext\n+\n+static yy_state_type yy_get_previous_state ( void );\n+static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );\n+static int yy_get_next_buffer ( void );\n+static void yynoreturn yy_fatal_error ( const char* msg  );\n+\n+/* Done after the current pattern has been matched and before the\n+ * corresponding action - sets up yytext.\n+ */\n+#define YY_DO_BEFORE_ACTION \\\n+\t(yytext_ptr) = yy_bp; \\\n+\tyyleng = (int) (yy_cp - yy_bp); \\\n+\t(yy_hold_char) = *yy_cp; \\\n+\t*yy_cp = '\\0'; \\\n+\t(yy_c_buf_p) = yy_cp;\n+#define YY_NUM_RULES 1\n+#define YY_END_OF_BUFFER 2\n+/* This struct is not used in this scanner,\n+   but its presence is necessary. */\n+struct yy_trans_info\n+\t{\n+\tflex_int32_t yy_verify;\n+\tflex_int32_t yy_nxt;\n+\t};\n+static const flex_int16_t yy_accept[6] =\n+    {   0,\n+        0,    0,    2,    1,    0\n+    } ;\n+\n+static const YY_CHAR yy_ec[256] =\n+    {   0,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+        1,    1,    1,    1,    1\n+    } ;\n+\n+static const YY_CHAR yy_meta[2] =\n+    {   0,\n+        1\n+    } ;\n+\n+static const flex_int16_t yy_base[7] =\n+    {   0,\n+        0,    0,    2,    3,    3,    0\n+    } ;\n+\n+static const flex_int16_t yy_def[7] =\n+    {   0,\n+        6,    6,    5,    5,    0,    5\n+    } ;\n+\n+static const flex_int16_t yy_nxt[5] =\n+    {   0,\n+        4,    5,    3,    5\n+    } ;\n+\n+static const flex_int16_t yy_chk[5] =\n+    {   0,\n+        6,    3,    5,    5\n+    } ;\n+\n+static yy_state_type yy_last_accepting_state;\n+static char *yy_last_accepting_cpos;\n+\n+extern int yy_flex_debug;\n+int yy_flex_debug = 0;\n+\n+/* The intent behind this definition is that it'll catch\n+ * any uses of REJECT which flex missed.\n+ */\n+#define REJECT reject_used_but_not_detected\n+#define yymore() yymore_used_but_not_detected\n+#define YY_MORE_ADJ 0\n+#define YY_RESTORE_YY_MORE_OFFSET\n+char *yytext;\n+\n+#define INITIAL 0\n+\n+#ifndef YY_NO_UNISTD_H\n+/* Special case for \"unistd.h\", since it is non-ANSI. We include it way\n+ * down here because we want the user's section 1 to have been scanned first.\n+ * The user has a chance to override it with an option.\n+ */\n+#include <unistd.h>\n+#endif\n+\n+#ifndef YY_EXTRA_TYPE\n+#define YY_EXTRA_TYPE void *\n+#endif\n+\n+static int yy_init_globals ( void );\n+\n+/* Accessor methods to globals.\n+   These are made visible to non-reentrant scanners for convenience. */\n+\n+int yylex_destroy ( void );\n+\n+int yyget_debug ( void );\n+\n+void yyset_debug ( int debug_flag  );\n+\n+YY_EXTRA_TYPE yyget_extra ( void );\n+\n+void yyset_extra ( YY_EXTRA_TYPE user_defined  );\n+\n+FILE *yyget_in ( void );\n+\n+void yyset_in  ( FILE * _in_str  );\n+\n+FILE *yyget_out ( void );\n+\n+void yyset_out  ( FILE * _out_str  );\n+\n+\t\t\tint yyget_leng ( void );\n+\n+char *yyget_text ( void );\n+\n+int yyget_lineno ( void );\n+\n+void yyset_lineno ( int _line_number  );\n+\n+/* Macros after this point can all be overridden by user definitions in\n+ * section 1.\n+ */\n+\n+#ifndef YY_SKIP_YYWRAP\n+#ifdef __cplusplus\n+extern \"C\" int yywrap ( void );\n+#else\n+extern int yywrap ( void );\n+#endif\n+#endif\n+\n+#ifndef YY_NO_UNPUT\n+    \n+    static void yyunput ( int c, char *buf_ptr  );\n+    \n+#endif\n+\n+#ifndef yytext_ptr\n+static void yy_flex_strncpy ( char *, const char *, int );\n+#endif\n+\n+#ifdef YY_NEED_STRLEN\n+static int yy_flex_strlen ( const char * );\n+#endif\n+\n+#ifndef YY_NO_INPUT\n+#ifdef __cplusplus\n+static int yyinput ( void );\n+#else\n+static int input ( void );\n+#endif\n+\n+#endif\n+\n+/* Amount of stuff to slurp up with each read. */\n+#ifndef YY_READ_BUF_SIZE\n+#ifdef __ia64__\n+/* On IA-64, the buffer size is 16k, not 8k */\n+#define YY_READ_BUF_SIZE 16384\n+#else\n+#define YY_READ_BUF_SIZE 8192\n+#endif /* __ia64__ */\n+#endif\n+\n+/* Copy whatever the last rule matched to the standard output. */\n+#ifndef ECHO\n+/* This used to be an fputs(), but since the string might contain NUL's,\n+ * we now use fwrite().\n+ */\n+#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)\n+#endif\n+\n+/* Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,\n+ * is returned in \"result\".\n+ */\n+#ifndef YY_INPUT\n+#define YY_INPUT(buf,result,max_size) \\\n+\tif ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\\n+\t\t{ \\\n+\t\tint c = '*'; \\\n+\t\tint n; \\\n+\t\tfor ( n = 0; n < max_size && \\\n+\t\t\t     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\\n+\t\t\tbuf[n] = (char) c; \\\n+\t\tif ( c == '\\n' ) \\\n+\t\t\tbuf[n++] = (char) c; \\\n+\t\tif ( c == EOF && ferror( yyin ) ) \\\n+\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\\n+\t\tresult = n; \\\n+\t\t} \\\n+\telse \\\n+\t\t{ \\\n+\t\terrno=0; \\\n+\t\twhile ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \\\n+\t\t\t{ \\\n+\t\t\tif( errno != EINTR) \\\n+\t\t\t\t{ \\\n+\t\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\\n+\t\t\t\tbreak; \\\n+\t\t\t\t} \\\n+\t\t\terrno=0; \\\n+\t\t\tclearerr(yyin); \\\n+\t\t\t} \\\n+\t\t}\\\n+\\\n+\n+#endif\n+\n+/* No semi-colon after return; correct usage is to write \"yyterminate();\" -\n+ * we don't want an extra ';' after the \"return\" because that will cause\n+ * some compilers to complain about unreachable statements.\n+ */\n+#ifndef yyterminate\n+#define yyterminate() return YY_NULL\n+#endif\n+\n+/* Number of entries by which start-condition stack grows. */\n+#ifndef YY_START_STACK_INCR\n+#define YY_START_STACK_INCR 25\n+#endif\n+\n+/* Report a fatal error. */\n+#ifndef YY_FATAL_ERROR\n+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )\n+#endif\n+\n+/* end tables serialization structures and prototypes */\n+\n+/* Default declaration of generated scanner - a define so the user can\n+ * easily add parameters.\n+ */\n+#ifndef YY_DECL\n+#define YY_DECL_IS_OURS 1\n+\n+extern int yylex (void);\n+\n+#define YY_DECL int yylex (void)\n+#endif /* !YY_DECL */\n+\n+/* Code executed at the beginning of each rule, after yytext and yyleng\n+ * have been set up.\n+ */\n+#ifndef YY_USER_ACTION\n+#define YY_USER_ACTION\n+#endif\n+\n+/* Code executed at the end of each rule. */\n+#ifndef YY_BREAK\n+#define YY_BREAK /*LINTED*/break;\n+#endif\n+\n+#define YY_RULE_SETUP \\\n+\tYY_USER_ACTION\n+\n+/** The main scanner function which does all the work.\n+ */\n+YY_DECL\n+{\n+\tyy_state_type yy_current_state;\n+\tchar *yy_cp, *yy_bp;\n+\tint yy_act;\n+    \n+\tif ( !(yy_init) )\n+\t\t{\n+\t\t(yy_init) = 1;\n+\n+#ifdef YY_USER_INIT\n+\t\tYY_USER_INIT;\n+#endif\n+\n+\t\tif ( ! (yy_start) )\n+\t\t\t(yy_start) = 1;\t/* first start state */\n+\n+\t\tif ( ! yyin )\n+\t\t\tyyin = stdin;\n+\n+\t\tif ( ! yyout )\n+\t\t\tyyout = stdout;\n+\n+\t\tif ( ! YY_CURRENT_BUFFER ) {\n+\t\t\tyyensure_buffer_stack ();\n+\t\t\tYY_CURRENT_BUFFER_LVALUE =\n+\t\t\t\tyy_create_buffer( yyin, YY_BUF_SIZE );\n+\t\t}\n+\n+\t\tyy_load_buffer_state(  );\n+\t\t}\n+\n+\t{\n+\n+\twhile ( /*CONSTCOND*/1 )\t\t/* loops until end-of-file is reached */\n+\t\t{\n+\t\tyy_cp = (yy_c_buf_p);\n+\n+\t\t/* Support of yytext. */\n+\t\t*yy_cp = (yy_hold_char);\n+\n+\t\t/* yy_bp points to the position in yy_ch_buf of the start of\n+\t\t * the current run.\n+\t\t */\n+\t\tyy_bp = yy_cp;\n+\n+\t\tyy_current_state = (yy_start);\n+yy_match:\n+\t\tdo\n+\t\t\t{\n+\t\t\tYY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;\n+\t\t\tif ( yy_accept[yy_current_state] )\n+\t\t\t\t{\n+\t\t\t\t(yy_last_accepting_state) = yy_current_state;\n+\t\t\t\t(yy_last_accepting_cpos) = yy_cp;\n+\t\t\t\t}\n+\t\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n+\t\t\t\t{\n+\t\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n+\t\t\t\tif ( yy_current_state >= 6 )\n+\t\t\t\t\tyy_c = yy_meta[yy_c];\n+\t\t\t\t}\n+\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];\n+\t\t\t++yy_cp;\n+\t\t\t}\n+\t\twhile ( yy_base[yy_current_state] != 3 );\n+\n+yy_find_action:\n+\t\tyy_act = yy_accept[yy_current_state];\n+\t\tif ( yy_act == 0 )\n+\t\t\t{ /* have to back up */\n+\t\t\tyy_cp = (yy_last_accepting_cpos);\n+\t\t\tyy_current_state = (yy_last_accepting_state);\n+\t\t\tyy_act = yy_accept[yy_current_state];\n+\t\t\t}\n+\n+\t\tYY_DO_BEFORE_ACTION;\n+\n+do_action:\t/* This label is used only to access EOF actions. */\n+\n+\t\tswitch ( yy_act )\n+\t{ /* beginning of action switch */\n+\t\t\tcase 0: /* must back up */\n+\t\t\t/* undo the effects of YY_DO_BEFORE_ACTION */\n+\t\t\t*yy_cp = (yy_hold_char);\n+\t\t\tyy_cp = (yy_last_accepting_cpos);\n+\t\t\tyy_current_state = (yy_last_accepting_state);\n+\t\t\tgoto yy_find_action;\n+\n+case 1:\n+YY_RULE_SETUP\n+ECHO;\n+\tYY_BREAK\n+case YY_STATE_EOF(INITIAL):\n+\tyyterminate();\n+\n+\tcase YY_END_OF_BUFFER:\n+\t\t{\n+\t\t/* Amount of text matched not including the EOB char. */\n+\t\tint yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;\n+\n+\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */\n+\t\t*yy_cp = (yy_hold_char);\n+\t\tYY_RESTORE_YY_MORE_OFFSET\n+\n+\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )\n+\t\t\t{\n+\t\t\t/* We're scanning a new file or input source.  It's\n+\t\t\t * possible that this happened because the user\n+\t\t\t * just pointed yyin at a new source and called\n+\t\t\t * yylex().  If so, then we have to assure\n+\t\t\t * consistency between YY_CURRENT_BUFFER and our\n+\t\t\t * globals.  Here is the right place to do so, because\n+\t\t\t * this is the first action (other than possibly a\n+\t\t\t * back-up) that will match for the new input source.\n+\t\t\t */\n+\t\t\t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n+\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;\n+\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;\n+\t\t\t}\n+\n+\t\t/* Note that here we test for yy_c_buf_p \"<=\" to the position\n+\t\t * of the first EOB in the buffer, since yy_c_buf_p will\n+\t\t * already have been incremented past the NUL character\n+\t\t * (since all states make transitions on EOB to the\n+\t\t * end-of-buffer state).  Contrast this with the test\n+\t\t * in input().\n+\t\t */\n+\t\tif ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )\n+\t\t\t{ /* This was really a NUL. */\n+\t\t\tyy_state_type yy_next_state;\n+\n+\t\t\t(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;\n+\n+\t\t\tyy_current_state = yy_get_previous_state(  );\n+\n+\t\t\t/* Okay, we're now positioned to make the NUL\n+\t\t\t * transition.  We couldn't have\n+\t\t\t * yy_get_previous_state() go ahead and do it\n+\t\t\t * for us because it doesn't know how to deal\n+\t\t\t * with the possibility of jamming (and we don't\n+\t\t\t * want to build jamming into it because then it\n+\t\t\t * will run more slowly).\n+\t\t\t */\n+\n+\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state );\n+\n+\t\t\tyy_bp = (yytext_ptr) + YY_MORE_ADJ;\n+\n+\t\t\tif ( yy_next_state )\n+\t\t\t\t{\n+\t\t\t\t/* Consume the NUL. */\n+\t\t\t\tyy_cp = ++(yy_c_buf_p);\n+\t\t\t\tyy_current_state = yy_next_state;\n+\t\t\t\tgoto yy_match;\n+\t\t\t\t}\n+\n+\t\t\telse\n+\t\t\t\t{\n+\t\t\t\tyy_cp = (yy_c_buf_p);\n+\t\t\t\tgoto yy_find_action;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\telse switch ( yy_get_next_buffer(  ) )\n+\t\t\t{\n+\t\t\tcase EOB_ACT_END_OF_FILE:\n+\t\t\t\t{\n+\t\t\t\t(yy_did_buffer_switch_on_eof) = 0;\n+\n+\t\t\t\tif ( yywrap(  ) )\n+\t\t\t\t\t{\n+\t\t\t\t\t/* Note: because we've taken care in\n+\t\t\t\t\t * yy_get_next_buffer() to have set up\n+\t\t\t\t\t * yytext, we can now set up\n+\t\t\t\t\t * yy_c_buf_p so that if some total\n+\t\t\t\t\t * hoser (like flex itself) wants to\n+\t\t\t\t\t * call the scanner after we return the\n+\t\t\t\t\t * YY_NULL, it'll still work - another\n+\t\t\t\t\t * YY_NULL will get returned.\n+\t\t\t\t\t */\n+\t\t\t\t\t(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;\n+\n+\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);\n+\t\t\t\t\tgoto do_action;\n+\t\t\t\t\t}\n+\n+\t\t\t\telse\n+\t\t\t\t\t{\n+\t\t\t\t\tif ( ! (yy_did_buffer_switch_on_eof) )\n+\t\t\t\t\t\tYY_NEW_FILE;\n+\t\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n+\t\t\t\t(yy_c_buf_p) =\n+\t\t\t\t\t(yytext_ptr) + yy_amount_of_matched_text;\n+\n+\t\t\t\tyy_current_state = yy_get_previous_state(  );\n+\n+\t\t\t\tyy_cp = (yy_c_buf_p);\n+\t\t\t\tyy_bp = (yytext_ptr) + YY_MORE_ADJ;\n+\t\t\t\tgoto yy_match;\n+\n+\t\t\tcase EOB_ACT_LAST_MATCH:\n+\t\t\t\t(yy_c_buf_p) =\n+\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];\n+\n+\t\t\t\tyy_current_state = yy_get_previous_state(  );\n+\n+\t\t\t\tyy_cp = (yy_c_buf_p);\n+\t\t\t\tyy_bp = (yytext_ptr) + YY_MORE_ADJ;\n+\t\t\t\tgoto yy_find_action;\n+\t\t\t}\n+\t\tbreak;\n+\t\t}\n+\n+\tdefault:\n+\t\tYY_FATAL_ERROR(\n+\t\t\t\"fatal flex scanner internal error--no action found\" );\n+\t} /* end of action switch */\n+\t\t} /* end of scanning one token */\n+\t} /* end of user's declarations */\n+} /* end of yylex */\n+\n+/* yy_get_next_buffer - try to read in a new buffer\n+ *\n+ * Returns a code representing an action:\n+ *\tEOB_ACT_LAST_MATCH -\n+ *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n+ *\tEOB_ACT_END_OF_FILE - end of file\n+ */\n+static int yy_get_next_buffer (void)\n+{\n+    \tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n+\tchar *source = (yytext_ptr);\n+\tint number_to_move, i;\n+\tint ret_val;\n+\n+\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n+\t\tYY_FATAL_ERROR(\n+\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n+\n+\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n+\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n+\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n+\t\t\t{\n+\t\t\t/* We matched a single character, the EOB, so\n+\t\t\t * treat this as a final EOF.\n+\t\t\t */\n+\t\t\treturn EOB_ACT_END_OF_FILE;\n+\t\t\t}\n+\n+\t\telse\n+\t\t\t{\n+\t\t\t/* We matched some text prior to the EOB, first\n+\t\t\t * process it.\n+\t\t\t */\n+\t\t\treturn EOB_ACT_LAST_MATCH;\n+\t\t\t}\n+\t\t}\n+\n+\t/* Try to read more data. */\n+\n+\t/* First move last chars to start of buffer. */\n+\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);\n+\n+\tfor ( i = 0; i < number_to_move; ++i )\n+\t\t*(dest++) = *(source++);\n+\n+\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n+\t\t/* don't do the read, it's not guaranteed to return an EOF,\n+\t\t * just force an EOF\n+\t\t */\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n+\n+\telse\n+\t\t{\n+\t\t\tint num_to_read =\n+\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n+\n+\t\twhile ( num_to_read <= 0 )\n+\t\t\t{ /* Not enough room in the buffer - grow it. */\n+\n+\t\t\t/* just a shorter name for the current buffer */\n+\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;\n+\n+\t\t\tint yy_c_buf_p_offset =\n+\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n+\n+\t\t\tif ( b->yy_is_our_buffer )\n+\t\t\t\t{\n+\t\t\t\tint new_size = b->yy_buf_size * 2;\n+\n+\t\t\t\tif ( new_size <= 0 )\n+\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n+\t\t\t\telse\n+\t\t\t\t\tb->yy_buf_size *= 2;\n+\n+\t\t\t\tb->yy_ch_buf = (char *)  /* { dg-warning \"leak of '\\\\*b.yy_ch_buf'\" } */\n+\t\t\t\t\t/* Include room in for 2 EOB chars. */\n+\t\t\t\t\tyyrealloc( (void *) b->yy_ch_buf,\n+\t\t\t\t\t\t\t (yy_size_t) (b->yy_buf_size + 2)  );\n+\t\t\t\t}\n+\t\t\telse\n+\t\t\t\t/* Can't grow it, we don't own it. */\n+\t\t\t\tb->yy_ch_buf = NULL;  /* { dg-bogus \"leak\" \"\" { xfail *-*-* } } */\n+\t\t\t\t/* TODO: leak false positive: PR analyzer/103546.  */\n+\n+\t\t\tif ( ! b->yy_ch_buf )\n+\t\t\t\tYY_FATAL_ERROR(\n+\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n+\n+\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n+\n+\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n+\t\t\t\t\t\tnumber_to_move - 1;\n+\n+\t\t\t}\n+\n+\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n+\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n+\n+\t\t/* Read in more data. */\n+\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n+\t\t\t(yy_n_chars), num_to_read );\n+\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n+\t\t}\n+\n+\tif ( (yy_n_chars) == 0 )\n+\t\t{\n+\t\tif ( number_to_move == YY_MORE_ADJ )\n+\t\t\t{\n+\t\t\tret_val = EOB_ACT_END_OF_FILE;\n+\t\t\tyyrestart( yyin  );\n+\t\t\t}\n+\n+\t\telse\n+\t\t\t{\n+\t\t\tret_val = EOB_ACT_LAST_MATCH;\n+\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n+\t\t\t\tYY_BUFFER_EOF_PENDING;\n+\t\t\t}\n+\t\t}\n+\n+\telse\n+\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n+\n+\tif (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n+\t\t/* Extend the array by 50%, plus the number we really need. */\n+\t\tint new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(\n+\t\t\t(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );\n+\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n+\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n+\t\t/* \"- 2\" to take care of EOB's */\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);\n+\t}\n+\n+\t(yy_n_chars) += number_to_move;\n+\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n+\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n+\n+\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n+\n+\treturn ret_val;\n+}\n+\n+/* yy_get_previous_state - get the state just before the EOB char was reached */\n+\n+    static yy_state_type yy_get_previous_state (void)\n+{\n+\tyy_state_type yy_current_state;\n+\tchar *yy_cp;\n+    \n+\tyy_current_state = (yy_start);\n+\n+\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n+\t\t{\n+\t\tYY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n+\t\tif ( yy_accept[yy_current_state] )\n+\t\t\t{\n+\t\t\t(yy_last_accepting_state) = yy_current_state;\n+\t\t\t(yy_last_accepting_cpos) = yy_cp;\n+\t\t\t}\n+\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n+\t\t\t{\n+\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n+\t\t\tif ( yy_current_state >= 6 )\n+\t\t\t\tyy_c = yy_meta[yy_c];\n+\t\t\t}\n+\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];\n+\t\t}\n+\n+\treturn yy_current_state;\n+}\n+\n+/* yy_try_NUL_trans - try to make a transition on the NUL character\n+ *\n+ * synopsis\n+ *\tnext_state = yy_try_NUL_trans( current_state );\n+ */\n+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )\n+{\n+\tint yy_is_jam;\n+    \tchar *yy_cp = (yy_c_buf_p);\n+\n+\tYY_CHAR yy_c = 1;\n+\tif ( yy_accept[yy_current_state] )\n+\t\t{\n+\t\t(yy_last_accepting_state) = yy_current_state;\n+\t\t(yy_last_accepting_cpos) = yy_cp;\n+\t\t}\n+\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n+\t\t{\n+\t\tyy_current_state = (int) yy_def[yy_current_state];\n+\t\tif ( yy_current_state >= 6 )\n+\t\t\tyy_c = yy_meta[yy_c];\n+\t\t}\n+\tyy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];\n+\tyy_is_jam = (yy_current_state == 5);\n+\n+\t\treturn yy_is_jam ? 0 : yy_current_state;\n+}\n+\n+#ifndef YY_NO_UNPUT\n+\n+    static void yyunput (int c, char * yy_bp )\n+{\n+\tchar *yy_cp;\n+    \n+    yy_cp = (yy_c_buf_p);\n+\n+\t/* undo effects of setting up yytext */\n+\t*yy_cp = (yy_hold_char);\n+\n+\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n+\t\t{ /* need to shift things up to make room */\n+\t\t/* +2 for EOB chars. */\n+\t\tint number_to_move = (yy_n_chars) + 2;\n+\t\tchar *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[\n+\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];\n+\t\tchar *source =\n+\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];\n+\n+\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n+\t\t\t*--dest = *--source;\n+\n+\t\tyy_cp += (int) (dest - source);\n+\t\tyy_bp += (int) (dest - source);\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars =\n+\t\t\t(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;\n+\n+\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n+\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n+\t\t}\n+\n+\t*--yy_cp = (char) c;\n+\n+\t(yytext_ptr) = yy_bp;\n+\t(yy_hold_char) = *yy_cp;\n+\t(yy_c_buf_p) = yy_cp;\n+}\n+\n+#endif\n+\n+#ifndef YY_NO_INPUT\n+#ifdef __cplusplus\n+    static int yyinput (void)\n+#else\n+    static int input  (void)\n+#endif\n+\n+{\n+\tint c;\n+    \n+\t*(yy_c_buf_p) = (yy_hold_char);\n+\n+\tif ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )\n+\t\t{\n+\t\t/* yy_c_buf_p now points to the character we want to return.\n+\t\t * If this occurs *before* the EOB characters, then it's a\n+\t\t * valid NUL; if not, then we've hit the end of the buffer.\n+\t\t */\n+\t\tif ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )\n+\t\t\t/* This was really a NUL. */\n+\t\t\t*(yy_c_buf_p) = '\\0';\n+\n+\t\telse\n+\t\t\t{ /* need more input */\n+\t\t\tint offset = (int) ((yy_c_buf_p) - (yytext_ptr));\n+\t\t\t++(yy_c_buf_p);\n+\n+\t\t\tswitch ( yy_get_next_buffer(  ) )\n+\t\t\t\t{\n+\t\t\t\tcase EOB_ACT_LAST_MATCH:\n+\t\t\t\t\t/* This happens because yy_g_n_b()\n+\t\t\t\t\t * sees that we've accumulated a\n+\t\t\t\t\t * token and flags that we need to\n+\t\t\t\t\t * try matching the token before\n+\t\t\t\t\t * proceeding.  But for input(),\n+\t\t\t\t\t * there's no matching to consider.\n+\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n+\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n+\t\t\t\t\t */\n+\n+\t\t\t\t\t/* Reset buffer status. */\n+\t\t\t\t\tyyrestart( yyin );\n+\n+\t\t\t\t\t/*FALLTHROUGH*/\n+\n+\t\t\t\tcase EOB_ACT_END_OF_FILE:\n+\t\t\t\t\t{\n+\t\t\t\t\tif ( yywrap(  ) )\n+\t\t\t\t\t\treturn 0;\n+\n+\t\t\t\t\tif ( ! (yy_did_buffer_switch_on_eof) )\n+\t\t\t\t\t\tYY_NEW_FILE;\n+#ifdef __cplusplus\n+\t\t\t\t\treturn yyinput();\n+#else\n+\t\t\t\t\treturn input();\n+#endif\n+\t\t\t\t\t}\n+\n+\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n+\t\t\t\t\t(yy_c_buf_p) = (yytext_ptr) + offset;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\tc = *(unsigned char *) (yy_c_buf_p);\t/* cast for 8-bit char's */\n+\t*(yy_c_buf_p) = '\\0';\t/* preserve yytext */\n+\t(yy_hold_char) = *++(yy_c_buf_p);\n+\n+\treturn c;\n+}\n+#endif\t/* ifndef YY_NO_INPUT */\n+\n+/** Immediately switch to a different input stream.\n+ * @param input_file A readable stream.\n+ * \n+ * @note This function does not reset the start condition to @c INITIAL .\n+ */\n+\n+void yyrestart  (FILE * input_file )\n+{\n+    \n+\tif ( ! YY_CURRENT_BUFFER ){\n+\t        yyensure_buffer_stack ();\n+\t\tYY_CURRENT_BUFFER_LVALUE = yy_create_buffer( yyin, YY_BUF_SIZE );\n+\t}\n+\n+\tyy_init_buffer( YY_CURRENT_BUFFER, input_file );\n+\tyy_load_buffer_state(  );\n+}\n+\n+/** Switch to a different input buffer.\n+ * @param new_buffer The new input buffer.\n+ * \n+ */\n+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n+{\n+    \n+\t/* TODO. We should be able to replace this entire function body\n+\t * with\n+\t *\t\tyypop_buffer_state();\n+\t *\t\tyypush_buffer_state(new_buffer);\n+     */\n+\tyyensure_buffer_stack ();\n+\tif ( YY_CURRENT_BUFFER == new_buffer )\n+\t\treturn;\n+\n+\tif ( YY_CURRENT_BUFFER )\n+\t\t{\n+\t\t/* Flush out information for old buffer. */\n+\t\t*(yy_c_buf_p) = (yy_hold_char);\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n+\t\t}\n+\n+\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n+\tyy_load_buffer_state(  );\n+\n+\t/* We don't actually know whether we did this switch during\n+\t * EOF (yywrap()) processing, but the only time this flag\n+\t * is looked at is after yywrap() is called, so it's safe\n+\t * to go ahead and always set it.\n+\t */\n+\t(yy_did_buffer_switch_on_eof) = 1;\n+}\n+\n+static void yy_load_buffer_state  (void)\n+{\n+    \t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n+\t(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n+\tyyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n+\t(yy_hold_char) = *(yy_c_buf_p);\n+}\n+\n+/** Allocate and initialize an input buffer state.\n+ * @param file A readable stream.\n+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.\n+ * \n+ * @return the allocated buffer state.\n+ */\n+\n+YY_BUFFER_STATE\n+yy_create_buffer (FILE * file, int  size )\n+{\n+\tYY_BUFFER_STATE b;\n+    \n+\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );\n+\tif ( ! b )\n+\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n+\n+\tb->yy_buf_size = size;\n+\n+\t/* yy_ch_buf has to be 2 characters longer than the size given because\n+\t * we need to put in 2 end-of-buffer characters.\n+\t */\n+\tb->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );\n+\tif ( ! b->yy_ch_buf )\n+\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n+\n+\tb->yy_is_our_buffer = 1;\n+\n+\tyy_init_buffer( b, file );\n+\n+\treturn b;\n+}\n+\n+/** Destroy the buffer.\n+ * @param b a buffer created with yy_create_buffer()\n+ * \n+ */\n+\n+void yy_delete_buffer (YY_BUFFER_STATE  b )\n+{\n+    \n+\tif ( ! b )\n+\t\treturn;\n+\n+\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n+\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n+\n+\tif ( b->yy_is_our_buffer )\n+\t\tyyfree( (void *) b->yy_ch_buf  );\n+\n+\tyyfree( (void *) b  );\n+}\n+\n+/* Initializes or reinitializes a buffer.\n+ * This function is sometimes called more than once on the same buffer,\n+ * such as during a yyrestart() or at EOF.\n+ */\n+\n+static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n+{\n+\tint oerrno = errno;\n+    \n+\tyy_flush_buffer( b );\n+\n+\tb->yy_input_file = file;\n+\tb->yy_fill_buffer = 1;\n+\n+    /* If b is the current buffer, then yy_init_buffer was _probably_\n+     * called from yyrestart() or through yy_get_next_buffer.\n+     * In that case, we don't want to reset the lineno or column.\n+     */\n+    if (b != YY_CURRENT_BUFFER){\n+        b->yy_bs_lineno = 1;\n+        b->yy_bs_column = 0;\n+    }\n+\n+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n+    \n+\terrno = oerrno;\n+}\n+\n+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.\n+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.\n+ * \n+ */\n+void yy_flush_buffer (YY_BUFFER_STATE  b )\n+{\n+    \tif ( ! b )\n+\t\treturn;\n+\n+\tb->yy_n_chars = 0;\n+\n+\t/* We always need two end-of-buffer characters.  The first causes\n+\t * a transition to the end-of-buffer state.  The second causes\n+\t * a jam in that state.\n+\t */\n+\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n+\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n+\n+\tb->yy_buf_pos = &b->yy_ch_buf[0];\n+\n+\tb->yy_at_bol = 1;\n+\tb->yy_buffer_status = YY_BUFFER_NEW;\n+\n+\tif ( b == YY_CURRENT_BUFFER )\n+\t\tyy_load_buffer_state(  );\n+}\n+\n+/** Pushes the new state onto the stack. The new state becomes\n+ *  the current state. This function will allocate the stack\n+ *  if necessary.\n+ *  @param new_buffer The new state.\n+ *  \n+ */\n+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )\n+{\n+    \tif (new_buffer == NULL)\n+\t\treturn;\n+\n+\tyyensure_buffer_stack();\n+\n+\t/* This block is copied from yy_switch_to_buffer. */\n+\tif ( YY_CURRENT_BUFFER )\n+\t\t{\n+\t\t/* Flush out information for old buffer. */\n+\t\t*(yy_c_buf_p) = (yy_hold_char);\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n+\t\t}\n+\n+\t/* Only push if top exists. Otherwise, replace top. */\n+\tif (YY_CURRENT_BUFFER)\n+\t\t(yy_buffer_stack_top)++;\n+\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n+\n+\t/* copied from yy_switch_to_buffer. */\n+\tyy_load_buffer_state(  );\n+\t(yy_did_buffer_switch_on_eof) = 1;\n+}\n+\n+/** Removes and deletes the top of the stack, if present.\n+ *  The next element becomes the new top.\n+ *  \n+ */\n+void yypop_buffer_state (void)\n+{\n+    \tif (!YY_CURRENT_BUFFER)\n+\t\treturn;\n+\n+\tyy_delete_buffer(YY_CURRENT_BUFFER );\n+\tYY_CURRENT_BUFFER_LVALUE = NULL;\n+\tif ((yy_buffer_stack_top) > 0)\n+\t\t--(yy_buffer_stack_top);\n+\n+\tif (YY_CURRENT_BUFFER) {\n+\t\tyy_load_buffer_state(  );\n+\t\t(yy_did_buffer_switch_on_eof) = 1;\n+\t}\n+}\n+\n+/* Allocates the stack if it does not exist.\n+ *  Guarantees space for at least one push.\n+ */\n+static void yyensure_buffer_stack (void)\n+{\n+\tyy_size_t num_to_alloc;\n+    \n+\tif (!(yy_buffer_stack)) {\n+\n+\t\t/* First allocation is just for 2 elements, since we don't know if this\n+\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n+\t\t * immediate realloc on the next call.\n+         */\n+      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */\n+\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc\n+\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n+\t\t\t\t\t\t\t\t);\n+\t\tif ( ! (yy_buffer_stack) )\n+\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n+\n+\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n+\n+\t\t(yy_buffer_stack_max) = num_to_alloc;\n+\t\t(yy_buffer_stack_top) = 0;\n+\t\treturn;\n+\t}\n+\n+\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n+\n+\t\t/* Increase the buffer to prepare for a possible push. */\n+\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;\n+\n+\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n+\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc\n+\t\t\t\t\t\t\t\t((yy_buffer_stack),\n+\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n+\t\t\t\t\t\t\t\t);\n+\t\tif ( ! (yy_buffer_stack) )\n+\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n+\n+\t\t/* zero only the new slots.*/\n+\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n+\t\t(yy_buffer_stack_max) = num_to_alloc;\n+\t}\n+}\n+\n+/** Setup the input buffer state to scan directly from a user-specified character buffer.\n+ * @param base the character buffer\n+ * @param size the size in bytes of the character buffer\n+ * \n+ * @return the newly allocated buffer state object.\n+ */\n+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )\n+{\n+\tYY_BUFFER_STATE b;\n+    \n+\tif ( size < 2 ||\n+\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n+\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n+\t\t/* They forgot to leave room for the EOB's. */\n+\t\treturn NULL;\n+\n+\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );\n+\tif ( ! b )\n+\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n+\n+\tb->yy_buf_size = (int) (size - 2);\t/* \"- 2\" to take care of EOB's */\n+\tb->yy_buf_pos = b->yy_ch_buf = base;\n+\tb->yy_is_our_buffer = 0;\n+\tb->yy_input_file = NULL;\n+\tb->yy_n_chars = b->yy_buf_size;\n+\tb->yy_is_interactive = 0;\n+\tb->yy_at_bol = 1;\n+\tb->yy_fill_buffer = 0;\n+\tb->yy_buffer_status = YY_BUFFER_NEW;\n+\n+\tyy_switch_to_buffer( b  );\n+\n+\treturn b;\n+}\n+\n+/** Setup the input buffer state to scan a string. The next call to yylex() will\n+ * scan from a @e copy of @a str.\n+ * @param yystr a NUL-terminated string to scan\n+ * \n+ * @return the newly allocated buffer state object.\n+ * @note If you want to scan bytes that may contain NUL values, then use\n+ *       yy_scan_bytes() instead.\n+ */\n+YY_BUFFER_STATE yy_scan_string (const char * yystr )\n+{\n+    \n+\treturn yy_scan_bytes( yystr, (int) strlen(yystr) );\n+}\n+\n+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will\n+ * scan from a @e copy of @a bytes.\n+ * @param yybytes the byte buffer to scan\n+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.\n+ * \n+ * @return the newly allocated buffer state object.\n+ */\n+YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )\n+{\n+\tYY_BUFFER_STATE b;\n+\tchar *buf;\n+\tyy_size_t n;\n+\tint i;\n+    \n+\t/* Get memory for full buffer, including space for trailing EOB's. */\n+\tn = (yy_size_t) (_yybytes_len + 2);\n+\tbuf = (char *) yyalloc( n  );\n+\tif ( ! buf )\n+\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n+\n+\tfor ( i = 0; i < _yybytes_len; ++i )\n+\t\tbuf[i] = yybytes[i];\n+\n+\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n+\n+\tb = yy_scan_buffer( buf, n );\n+\tif ( ! b )\n+\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n+\n+\t/* It's okay to grow etc. this buffer, and we should throw it\n+\t * away when we're done.\n+\t */\n+\tb->yy_is_our_buffer = 1;\n+\n+\treturn b;\n+}\n+\n+#ifndef YY_EXIT_FAILURE\n+#define YY_EXIT_FAILURE 2\n+#endif\n+\n+static void yynoreturn yy_fatal_error (const char* msg )\n+{\n+\t\t\tfprintf( stderr, \"%s\\n\", msg );\n+\texit( YY_EXIT_FAILURE );\n+}\n+\n+/* Redefine yyless() so it works in section 3 code. */\n+\n+#undef yyless\n+#define yyless(n) \\\n+\tdo \\\n+\t\t{ \\\n+\t\t/* Undo effects of setting up yytext. */ \\\n+        int yyless_macro_arg = (n); \\\n+        YY_LESS_LINENO(yyless_macro_arg);\\\n+\t\tyytext[yyleng] = (yy_hold_char); \\\n+\t\t(yy_c_buf_p) = yytext + yyless_macro_arg; \\\n+\t\t(yy_hold_char) = *(yy_c_buf_p); \\\n+\t\t*(yy_c_buf_p) = '\\0'; \\\n+\t\tyyleng = yyless_macro_arg; \\\n+\t\t} \\\n+\twhile ( 0 )\n+\n+/* Accessor  methods (get/set functions) to struct members. */\n+\n+/** Get the current line number.\n+ * \n+ */\n+int yyget_lineno  (void)\n+{\n+    \n+    return yylineno;\n+}\n+\n+/** Get the input stream.\n+ * \n+ */\n+FILE *yyget_in  (void)\n+{\n+        return yyin;\n+}\n+\n+/** Get the output stream.\n+ * \n+ */\n+FILE *yyget_out  (void)\n+{\n+        return yyout;\n+}\n+\n+/** Get the length of the current token.\n+ * \n+ */\n+int yyget_leng  (void)\n+{\n+        return yyleng;\n+}\n+\n+/** Get the current token.\n+ * \n+ */\n+\n+char *yyget_text  (void)\n+{\n+        return yytext;\n+}\n+\n+/** Set the current line number.\n+ * @param _line_number line number\n+ * \n+ */\n+void yyset_lineno (int  _line_number )\n+{\n+    \n+    yylineno = _line_number;\n+}\n+\n+/** Set the input stream. This does not discard the current\n+ * input buffer.\n+ * @param _in_str A readable stream.\n+ * \n+ * @see yy_switch_to_buffer\n+ */\n+void yyset_in (FILE *  _in_str )\n+{\n+        yyin = _in_str ;\n+}\n+\n+void yyset_out (FILE *  _out_str )\n+{\n+        yyout = _out_str ;\n+}\n+\n+int yyget_debug  (void)\n+{\n+        return yy_flex_debug;\n+}\n+\n+void yyset_debug (int  _bdebug )\n+{\n+        yy_flex_debug = _bdebug ;\n+}\n+\n+static int yy_init_globals (void)\n+{\n+        /* Initialization is the same as for the non-reentrant scanner.\n+     * This function is called from yylex_destroy(), so don't allocate here.\n+     */\n+\n+    (yy_buffer_stack) = NULL;\n+    (yy_buffer_stack_top) = 0;\n+    (yy_buffer_stack_max) = 0;\n+    (yy_c_buf_p) = NULL;\n+    (yy_init) = 0;\n+    (yy_start) = 0;\n+\n+/* Defined in main.c */\n+#ifdef YY_STDINIT\n+    yyin = stdin;\n+    yyout = stdout;\n+#else\n+    yyin = NULL;\n+    yyout = NULL;\n+#endif\n+\n+    /* For future reference: Set errno on error, since we are called by\n+     * yylex_init()\n+     */\n+    return 0;\n+}\n+\n+/* yylex_destroy is for both reentrant and non-reentrant scanners. */\n+int yylex_destroy  (void)\n+{\n+    \n+    /* Pop the buffer stack, destroying each element. */\n+\twhile(YY_CURRENT_BUFFER){\n+\t\tyy_delete_buffer( YY_CURRENT_BUFFER  );\n+\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n+\t\tyypop_buffer_state();\n+\t}\n+\n+\t/* Destroy the stack itself. */\n+\tyyfree((yy_buffer_stack) );\n+\t(yy_buffer_stack) = NULL;\n+\n+    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n+     * yylex() is called, initialization will occur. */\n+    yy_init_globals( );\n+\n+    return 0;\n+}\n+\n+/*\n+ * Internal utility routines.\n+ */\n+\n+#ifndef yytext_ptr\n+static void yy_flex_strncpy (char* s1, const char * s2, int n )\n+{\n+\t\t\n+\tint i;\n+\tfor ( i = 0; i < n; ++i )\n+\t\ts1[i] = s2[i];\n+}\n+#endif\n+\n+#ifdef YY_NEED_STRLEN\n+static int yy_flex_strlen (const char * s )\n+{\n+\tint n;\n+\tfor ( n = 0; s[n]; ++n )\n+\t\t;\n+\n+\treturn n;\n+}\n+#endif\n+\n+void *yyalloc (yy_size_t  size )\n+{\n+\t\t\treturn malloc(size);\n+}\n+\n+void *yyrealloc  (void * ptr, yy_size_t  size )\n+{\n+\t\t\n+\t/* The cast to (char *) in the following accommodates both\n+\t * implementations that use char* generic pointers, and those\n+\t * that use void* generic pointers.  It works with the latter\n+\t * because both ANSI C and C++ allow castless assignment from\n+\t * any pointer type to void*, and deal with argument conversions\n+\t * as though doing an assignment.\n+\t */\n+\treturn realloc(ptr, size);\n+}\n+\n+void yyfree (void * ptr )\n+{\n+\t\t\tfree( (char *) ptr );\t/* see yyrealloc() for (char *) cast */\n+}\n+\n+#define YYTABLES_NAME \"yytables\""}, {"sha": "04896ce2cec80a6ddbae5f0d1e5802bfb12c1ecd", "filename": "gcc/testsuite/gcc.dg/analyzer/getc-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fgetc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fgetc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fgetc-1.c?ref=78a17f4452db9514da7cc8706c654cb98ba0a8e6", "patch": "@@ -0,0 +1,6 @@\n+#include <stdio.h>\n+\n+int test_pass_through (FILE *stream)\n+{\n+  return getc (stream);\n+}"}, {"sha": "bea97fd4f4a459e3fd256f082d944b7f059bd986", "filename": "gcc/testsuite/gcc.dg/analyzer/isatty-1.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fisatty-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a17f4452db9514da7cc8706c654cb98ba0a8e6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fisatty-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fisatty-1.c?ref=78a17f4452db9514da7cc8706c654cb98ba0a8e6", "patch": "@@ -0,0 +1,56 @@\n+#include <errno.h>\n+#include \"analyzer-decls.h\"\n+\n+extern int isatty(int fd);\n+extern int close(int fd);\n+\n+int test_pass_through (int fd)\n+{\n+  return isatty (fd);\n+}\n+\n+void test_merging (int fd)\n+{\n+  isatty (fd);\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}\n+\n+int test_outcomes (int fd)\n+{\n+  errno = 0;\n+  int result = isatty (fd);\n+  switch (result)\n+    {\n+    default:\n+      __analyzer_dump_path (); /* { dg-bogus \"path\" } */\n+      break;\n+    case 0:\n+      __analyzer_dump_path (); /* { dg-message \"path\" } */\n+      __analyzer_eval (errno > 0); /* { dg-warning \"TRUE\" } */\n+      break;\n+    case 1:\n+      __analyzer_dump_path (); /* { dg-message \"path\" } */\n+      __analyzer_eval (errno == 0); /* { dg-warning \"TRUE\" } */\n+      break;\n+    }\n+  return result;\n+}\n+\n+int test_isatty_on_invalid_fd (void)\n+{\n+  errno = 0;\n+  int result = isatty (-1);\n+  __analyzer_eval (result == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (errno > 0); /* { dg-warning \"TRUE\" } */\n+  return result;\n+}\n+\n+int test_isatty_on_closed_fd (int fd)\n+{\n+  close (fd);\n+  errno = 0;\n+  int result = isatty (fd);\n+  __analyzer_eval (result == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (errno > 0); /* { dg-warning \"TRUE\" } */\n+  return result;\n+}"}]}