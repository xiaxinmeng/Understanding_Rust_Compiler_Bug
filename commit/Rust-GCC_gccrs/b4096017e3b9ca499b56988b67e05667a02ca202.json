{"sha": "b4096017e3b9ca499b56988b67e05667a02ca202", "node_id": "C_kwDOANBUbNoAKGI0MDk2MDE3ZTNiOWNhNDk5YjU2OTg4YjY3ZTA1NjY3YTAyY2EyMDI", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-10-06T13:07:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-06T13:07:50Z"}, "message": "Merge #1562\n\n1562: Support looking up super trait items during path resolution r=philberty a=philberty\n\nWhen we lookup names in paths such as Foo::bar, foo is a type we resolve\r\nand then we lookup 'bar' based on what type Foo is which includes probing\r\nrelevant bounds of this type. We currently return a vector of possible\r\ncandidates and this patch changes it so that we return a vector of unique\r\nitems based on DefId. Ideally we should use move to a std::set for this.\r\n    \r\nThe final patch actually updates the trait reference lookup functions to revert\r\nto looking up relevant super traits when required.\r\n\r\nFixes #1555 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "cf7011c7659af1416f4a109f81bc264f4686ecef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf7011c7659af1416f4a109f81bc264f4686ecef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4096017e3b9ca499b56988b67e05667a02ca202", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjPtMmCRBK7hj4Ov3rIwAAyMIIAH2oFtlxZbvzbkALSNqibKPu\nXzSAYOLRUHL5s0cU6gZ9H04B2qfUIDRlg20u+uYerHdpwoT5dfNWsVGpGm3DTihd\naXWsg2hxGaf0k6yBG/kq3GW9kKcpjRBp04IesN/cd6Rlw8Xr3t65Rs6mwojjH5S7\n+r+z11InHx7InCUSSa040lNcS/bf4sd1EWbX6o3AiuBr28MD6anDBnL0qxDpuysl\ngsQesenwYYrKcVCAu0pgtZPFV0DkpqUnJPzfnbIiR+1SCcAhIw51d4FrMONK2lIC\nb48r2OlVRdRxqMU75xWl/0eaH71uDQWksZyxpmXb2X7fw/O7QF4isx8P+8VHqpk=\n=OzRo\n-----END PGP SIGNATURE-----\n", "payload": "tree cf7011c7659af1416f4a109f81bc264f4686ecef\nparent adaf4561d63f08714f8c289bef0f4c5649fb6829\nparent a7d2643d9b09af9f5c5c670626becaa0c0fc1481\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1665061670 +0000\ncommitter GitHub <noreply@github.com> 1665061670 +0000\n\nMerge #1562\n\n1562: Support looking up super trait items during path resolution r=philberty a=philberty\n\nWhen we lookup names in paths such as Foo::bar, foo is a type we resolve\r\nand then we lookup 'bar' based on what type Foo is which includes probing\r\nrelevant bounds of this type. We currently return a vector of possible\r\ncandidates and this patch changes it so that we return a vector of unique\r\nitems based on DefId. Ideally we should use move to a std::set for this.\r\n    \r\nThe final patch actually updates the trait reference lookup functions to revert\r\nto looking up relevant super traits when required.\r\n\r\nFixes #1555 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4096017e3b9ca499b56988b67e05667a02ca202", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4096017e3b9ca499b56988b67e05667a02ca202", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4096017e3b9ca499b56988b67e05667a02ca202/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adaf4561d63f08714f8c289bef0f4c5649fb6829", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adaf4561d63f08714f8c289bef0f4c5649fb6829", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adaf4561d63f08714f8c289bef0f4c5649fb6829"}, {"sha": "a7d2643d9b09af9f5c5c670626becaa0c0fc1481", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7d2643d9b09af9f5c5c670626becaa0c0fc1481", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7d2643d9b09af9f5c5c670626becaa0c0fc1481"}], "stats": {"total": 226, "additions": 147, "deletions": 79}, "files": [{"sha": "9ff2be648459f83588bef59aa9bc590606bdbccb", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=b4096017e3b9ca499b56988b67e05667a02ca202", "patch": "@@ -1982,7 +1982,7 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n   // trait-impl-item's definition\n \n   auto root = receiver->get_root ();\n-  std::vector<Resolver::PathProbeCandidate> candidates\n+  auto candidates\n     = Resolver::PathProbeType::Probe (root, segment, true /* probe_impls */,\n \t\t\t\t      false /* probe_bounds */,\n \t\t\t\t      true /* ignore_mandatory_trait_items */);\n@@ -2011,7 +2011,7 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n       // implementation and we should just return error_mark_node\n \n       rust_assert (candidates.size () == 1);\n-      auto &candidate = candidates.at (0);\n+      auto &candidate = *candidates.begin ();\n       rust_assert (candidate.is_impl_candidate ());\n       rust_assert (candidate.ty->get_kind () == TyTy::TypeKind::FNDEF);\n       TyTy::FnType *candidate_call = static_cast<TyTy::FnType *> (candidate.ty);"}, {"sha": "f89da2bdcd55dc456981fb6b2a0a4a00efa8895a", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=b4096017e3b9ca499b56988b67e05667a02ca202", "patch": "@@ -251,7 +251,7 @@ HIRCompileBase::query_compile (HirId ref, TyTy::BaseType *lookup,\n \t  // item so its up to us to figure out if this path should resolve\n \t  // to an trait-impl-block-item or if it can be defaulted to the\n \t  // trait-impl-item's definition\n-\t  std::vector<Resolver::PathProbeCandidate> candidates\n+\t  auto candidates\n \t    = Resolver::PathProbeImplTrait::Probe (receiver, final_segment,\n \t\t\t\t\t\t   trait_ref);\n \t  if (candidates.size () == 0)\n@@ -270,7 +270,9 @@ HIRCompileBase::query_compile (HirId ref, TyTy::BaseType *lookup,\n \t    }\n \t  else\n \t    {\n-\t      Resolver::PathProbeCandidate &candidate = candidates.at (0);\n+\t      rust_assert (candidates.size () == 1);\n+\n+\t      auto candidate = *candidates.begin ();\n \t      rust_assert (candidate.is_impl_candidate ());\n \n \t      HIR::ImplBlock *impl = candidate.item.impl.parent;\n@@ -288,8 +290,6 @@ HIRCompileBase::query_compile (HirId ref, TyTy::BaseType *lookup,\n \t      else\n \t\treturn CompileInherentImplItem::Compile (impl_item, ctx, lookup,\n \t\t\t\t\t\t\t true, expr_locus);\n-\n-\t      lookup->set_ty_ref (impl_item->get_impl_mappings ().get_hirid ());\n \t    }\n \t}\n     }"}, {"sha": "c8f207cf008820284b3d9be1d7a8a8f25f42431e", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 50, "deletions": 58, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=b4096017e3b9ca499b56988b67e05667a02ca202", "patch": "@@ -80,17 +80,17 @@ struct PathProbeCandidate\n \n   PathProbeCandidate (CandidateType type, TyTy::BaseType *ty, Location locus,\n \t\t      EnumItemCandidate enum_field)\n-    : type (type), ty (ty), item (enum_field)\n+    : type (type), ty (ty), locus (locus), item (enum_field)\n   {}\n \n   PathProbeCandidate (CandidateType type, TyTy::BaseType *ty, Location locus,\n \t\t      ImplItemCandidate impl)\n-    : type (type), ty (ty), item (impl)\n+    : type (type), ty (ty), locus (locus), item (impl)\n   {}\n \n   PathProbeCandidate (CandidateType type, TyTy::BaseType *ty, Location locus,\n \t\t      TraitItemCandidate trait)\n-    : type (type), ty (ty), item (trait)\n+    : type (type), ty (ty), locus (locus), item (trait)\n   {}\n \n   std::string as_string () const\n@@ -123,12 +123,45 @@ struct PathProbeCandidate\n   }\n \n   bool is_error () const { return type == ERROR; }\n+\n+  DefId get_defid () const\n+  {\n+    switch (type)\n+      {\n+      case ENUM_VARIANT:\n+\treturn item.enum_field.variant->get_defid ();\n+\tbreak;\n+\n+      case IMPL_CONST:\n+      case IMPL_TYPE_ALIAS:\n+      case IMPL_FUNC:\n+\treturn item.impl.impl_item->get_impl_mappings ().get_defid ();\n+\tbreak;\n+\n+      case TRAIT_ITEM_CONST:\n+      case TRAIT_TYPE_ALIAS:\n+      case TRAIT_FUNC:\n+\treturn item.trait.item_ref->get_mappings ().get_defid ();\n+\tbreak;\n+\n+      case ERROR:\n+      default:\n+\treturn UNKNOWN_DEFID;\n+      }\n+\n+    return UNKNOWN_DEFID;\n+  }\n+\n+  bool operator< (const PathProbeCandidate &c) const\n+  {\n+    return get_defid () < c.get_defid ();\n+  }\n };\n \n class PathProbeType : public TypeCheckBase, public HIR::HIRImplVisitor\n {\n public:\n-  static std::vector<PathProbeCandidate>\n+  static std::set<PathProbeCandidate>\n   Probe (const TyTy::BaseType *receiver,\n \t const HIR::PathIdentSegment &segment_name, bool probe_impls,\n \t bool probe_bounds, bool ignore_mandatory_trait_items,\n@@ -203,7 +236,7 @@ class PathProbeType : public TypeCheckBase, public HIR::HIRImplVisitor\n \tPathProbeCandidate candidate{\n \t  PathProbeCandidate::CandidateType::IMPL_TYPE_ALIAS, ty,\n \t  alias.get_locus (), impl_item_candidate};\n-\tcandidates.push_back (std::move (candidate));\n+\tcandidates.insert (std::move (candidate));\n       }\n   }\n \n@@ -222,7 +255,7 @@ class PathProbeType : public TypeCheckBase, public HIR::HIRImplVisitor\n \tPathProbeCandidate candidate{\n \t  PathProbeCandidate::CandidateType::IMPL_CONST, ty,\n \t  constant.get_locus (), impl_item_candidate};\n-\tcandidates.push_back (std::move (candidate));\n+\tcandidates.insert (std::move (candidate));\n       }\n   }\n \n@@ -241,7 +274,7 @@ class PathProbeType : public TypeCheckBase, public HIR::HIRImplVisitor\n \tPathProbeCandidate candidate{\n \t  PathProbeCandidate::CandidateType::IMPL_FUNC, ty,\n \t  function.get_locus (), impl_item_candidate};\n-\tcandidates.push_back (std::move (candidate));\n+\tcandidates.insert (std::move (candidate));\n       }\n   }\n \n@@ -259,7 +292,7 @@ class PathProbeType : public TypeCheckBase, public HIR::HIRImplVisitor\n     PathProbeCandidate candidate{\n       PathProbeCandidate::CandidateType::ENUM_VARIANT, receiver->clone (),\n       mappings->lookup_location (adt->get_ty_ref ()), enum_item_candidate};\n-    candidates.push_back (std::move (candidate));\n+    candidates.insert (std::move (candidate));\n   }\n \n   void process_impl_items_for_candidates ()\n@@ -338,8 +371,9 @@ class PathProbeType : public TypeCheckBase, public HIR::HIRImplVisitor\n \t\t\t\t\t\t\t\timpl};\n \n     PathProbeCandidate candidate{candidate_type, trait_item_tyty,\n-\t\t\t\t trait_ref->get_locus (), trait_item_candidate};\n-    candidates.push_back (std::move (candidate));\n+\t\t\t\t trait_item_ref->get_locus (),\n+\t\t\t\t trait_item_candidate};\n+    candidates.insert (std::move (candidate));\n   }\n \n   void\n@@ -383,7 +417,7 @@ class PathProbeType : public TypeCheckBase, public HIR::HIRImplVisitor\n     PathProbeCandidate candidate{candidate_type, trait_item_tyty,\n \t\t\t\t trait_item_ref->get_locus (),\n \t\t\t\t trait_item_candidate};\n-    candidates.push_back (std::move (candidate));\n+    candidates.insert (std::move (candidate));\n   }\n \n protected:\n@@ -428,72 +462,30 @@ class PathProbeType : public TypeCheckBase, public HIR::HIRImplVisitor\n \n   const TyTy::BaseType *receiver;\n   const HIR::PathIdentSegment &search;\n-  std::vector<PathProbeCandidate> candidates;\n+  std::set<PathProbeCandidate> candidates;\n   HIR::ImplBlock *current_impl;\n   DefId specific_trait_id;\n };\n \n-class ReportMultipleCandidateError : private TypeCheckBase,\n-\t\t\t\t     private HIR::HIRImplVisitor\n+class ReportMultipleCandidateError : private TypeCheckBase\n {\n public:\n-  static void Report (std::vector<PathProbeCandidate> &candidates,\n+  static void Report (std::set<PathProbeCandidate> &candidates,\n \t\t      const HIR::PathIdentSegment &query, Location query_locus)\n   {\n     RichLocation r (query_locus);\n-    ReportMultipleCandidateError visitor (r);\n     for (auto &c : candidates)\n-      {\n-\tswitch (c.type)\n-\t  {\n-\t  case PathProbeCandidate::CandidateType::ERROR:\n-\t  case PathProbeCandidate::CandidateType::ENUM_VARIANT:\n-\t    gcc_unreachable ();\n-\t    break;\n-\n-\t  case PathProbeCandidate::CandidateType::IMPL_CONST:\n-\t  case PathProbeCandidate::CandidateType::IMPL_TYPE_ALIAS:\n-\t  case PathProbeCandidate::CandidateType::IMPL_FUNC:\n-\t    c.item.impl.impl_item->accept_vis (visitor);\n-\t    break;\n-\n-\t  case PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST:\n-\t  case PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS:\n-\t  case PathProbeCandidate::CandidateType::TRAIT_FUNC:\n-\t    r.add_range (c.item.trait.item_ref->get_locus ());\n-\t    break;\n-\t  }\n-      }\n+      r.add_range (c.locus);\n \n     rust_error_at (r, \"multiple applicable items in scope for: %s\",\n \t\t   query.as_string ().c_str ());\n   }\n-\n-  void visit (HIR::TypeAlias &alias) override\n-  {\n-    r.add_range (alias.get_locus ());\n-  }\n-\n-  void visit (HIR::ConstantItem &constant) override\n-  {\n-    r.add_range (constant.get_locus ());\n-  }\n-\n-  void visit (HIR::Function &function) override\n-  {\n-    r.add_range (function.get_locus ());\n-  }\n-\n-private:\n-  ReportMultipleCandidateError (RichLocation &r) : TypeCheckBase (), r (r) {}\n-\n-  RichLocation &r;\n };\n \n class PathProbeImplTrait : public PathProbeType\n {\n public:\n-  static std::vector<PathProbeCandidate>\n+  static std::set<PathProbeCandidate>\n   Probe (const TyTy::BaseType *receiver,\n \t const HIR::PathIdentSegment &segment_name,\n \t const TraitReference *trait_reference)"}, {"sha": "0f4883d6ba3bc2fae38f94f5375179d53aa15351", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=b4096017e3b9ca499b56988b67e05667a02ca202", "patch": "@@ -336,6 +336,15 @@ class TraitReference\n \t    return true;\n \t  }\n       }\n+\n+    // lookup super traits\n+    for (const auto &super_trait : super_traits)\n+      {\n+\tbool found = super_trait->lookup_trait_item (ident, ref);\n+\tif (found)\n+\t  return true;\n+      }\n+\n     return false;\n   }\n \n@@ -351,6 +360,16 @@ class TraitReference\n \tif (ident.compare (item.get_identifier ()) == 0)\n \t  return &item;\n       }\n+\n+    // lookup super traits\n+    for (const auto &super_trait : super_traits)\n+      {\n+\tconst TraitItemReference *res\n+\t  = super_trait->lookup_trait_item (ident, type);\n+\tif (!res->is_error ())\n+\t  return res;\n+      }\n+\n     return &TraitItemReference::error_node ();\n   }\n "}, {"sha": "b695ced34f1650eb719c6d6e1f732fc2189b9f5f", "filename": "gcc/rust/typecheck/rust-hir-type-check-enumitem.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.cc?ref=b4096017e3b9ca499b56988b67e05667a02ca202", "patch": "@@ -82,6 +82,7 @@ TypeCheckEnumItem::visit (HIR::EnumItem &item)\n \n   RustIdent ident{*canonical_path, item.get_locus ()};\n   variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n+\t\t\t\t  item.get_mappings ().get_defid (),\n \t\t\t\t  item.get_identifier (), ident, discim_expr);\n }\n \n@@ -111,6 +112,7 @@ TypeCheckEnumItem::visit (HIR::EnumItemDiscriminant &item)\n \n   RustIdent ident{*canonical_path, item.get_locus ()};\n   variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n+\t\t\t\t  item.get_mappings ().get_defid (),\n \t\t\t\t  item.get_identifier (), ident,\n \t\t\t\t  item.get_discriminant_expression ().get ());\n }\n@@ -159,6 +161,7 @@ TypeCheckEnumItem::visit (HIR::EnumItemTuple &item)\n \n   RustIdent ident{*canonical_path, item.get_locus ()};\n   variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n+\t\t\t\t  item.get_mappings ().get_defid (),\n \t\t\t\t  item.get_identifier (), ident,\n \t\t\t\t  TyTy::VariantDef::VariantType::TUPLE,\n \t\t\t\t  discim_expr, fields);\n@@ -206,6 +209,7 @@ TypeCheckEnumItem::visit (HIR::EnumItemStruct &item)\n \n   RustIdent ident{*canonical_path, item.get_locus ()};\n   variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n+\t\t\t\t  item.get_mappings ().get_defid (),\n \t\t\t\t  item.get_identifier (), ident,\n \t\t\t\t  TyTy::VariantDef::VariantType::STRUCT,\n \t\t\t\t  discrim_expr, fields);"}, {"sha": "de994e60dd460123adab12224f4cae1d3695be74", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.cc", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc?ref=b4096017e3b9ca499b56988b67e05667a02ca202", "patch": "@@ -125,7 +125,8 @@ TypeCheckItem::visit (HIR::TupleStruct &struct_decl)\n   // its a single variant ADT\n   std::vector<TyTy::VariantDef *> variants;\n   variants.push_back (new TyTy::VariantDef (\n-    struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n+    struct_decl.get_mappings ().get_hirid (),\n+    struct_decl.get_mappings ().get_defid (), struct_decl.get_identifier (),\n     ident, TyTy::VariantDef::VariantType::TUPLE, nullptr, std::move (fields)));\n \n   // Process #[repr(X)] attribute, if any\n@@ -179,7 +180,8 @@ TypeCheckItem::visit (HIR::StructStruct &struct_decl)\n   // its a single variant ADT\n   std::vector<TyTy::VariantDef *> variants;\n   variants.push_back (new TyTy::VariantDef (\n-    struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n+    struct_decl.get_mappings ().get_hirid (),\n+    struct_decl.get_mappings ().get_defid (), struct_decl.get_identifier (),\n     ident, TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n \n   // Process #[repr(X)] attribute, if any\n@@ -273,7 +275,8 @@ TypeCheckItem::visit (HIR::Union &union_decl)\n   // there is only a single variant\n   std::vector<TyTy::VariantDef *> variants;\n   variants.push_back (new TyTy::VariantDef (\n-    union_decl.get_mappings ().get_hirid (), union_decl.get_identifier (),\n+    union_decl.get_mappings ().get_hirid (),\n+    union_decl.get_mappings ().get_defid (), union_decl.get_identifier (),\n     ident, TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n \n   TyTy::BaseType *type"}, {"sha": "4e765ad1380ae48af1e9b3c5a7c9701944e5c60d", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=b4096017e3b9ca499b56988b67e05667a02ca202", "patch": "@@ -337,7 +337,7 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n \t  return;\n \t}\n \n-      auto &candidate = candidates.at (0);\n+      auto &candidate = *candidates.begin ();\n       prev_segment = tyseg;\n       tyseg = candidate.ty;\n "}, {"sha": "67e6cb0e7395ba22762c7cffeb78b2434020bbe2", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=b4096017e3b9ca499b56988b67e05667a02ca202", "patch": "@@ -462,7 +462,7 @@ TypeCheckType::resolve_segments (\n \t  return new TyTy::ErrorType (expr_id);\n \t}\n \n-      auto &candidate = candidates.at (0);\n+      auto &candidate = *candidates.begin ();\n       prev_segment = tyseg;\n       tyseg = candidate.ty;\n "}, {"sha": "acbeb9c441b6d3f7c947611e3bb4ec89390a9e1f", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=b4096017e3b9ca499b56988b67e05667a02ca202", "patch": "@@ -1063,30 +1063,30 @@ class VariantDef\n     return \"\";\n   }\n \n-  VariantDef (HirId id, std::string identifier, RustIdent ident,\n+  VariantDef (HirId id, DefId defid, std::string identifier, RustIdent ident,\n \t      HIR::Expr *discriminant)\n-    : id (id), identifier (identifier), ident (ident),\n+    : id (id), defid (defid), identifier (identifier), ident (ident),\n       discriminant (discriminant)\n \n   {\n     type = VariantType::NUM;\n     fields = {};\n   }\n \n-  VariantDef (HirId id, std::string identifier, RustIdent ident,\n+  VariantDef (HirId id, DefId defid, std::string identifier, RustIdent ident,\n \t      VariantType type, HIR::Expr *discriminant,\n \t      std::vector<StructFieldType *> fields)\n-    : id (id), identifier (identifier), ident (ident), type (type),\n-      discriminant (discriminant), fields (fields)\n+    : id (id), defid (defid), identifier (identifier), ident (ident),\n+      type (type), discriminant (discriminant), fields (fields)\n   {\n     rust_assert (\n       (type == VariantType::NUM && fields.empty ())\n       || (type == VariantType::TUPLE || type == VariantType::STRUCT));\n   }\n \n   VariantDef (const VariantDef &other)\n-    : id (other.id), identifier (other.identifier), ident (other.ident),\n-      type (other.type), discriminant (other.discriminant),\n+    : id (other.id), defid (other.defid), identifier (other.identifier),\n+      ident (other.ident), type (other.type), discriminant (other.discriminant),\n       fields (other.fields)\n   {}\n \n@@ -1105,7 +1105,7 @@ class VariantDef\n   static VariantDef &get_error_node ()\n   {\n     static VariantDef node\n-      = VariantDef (UNKNOWN_HIRID, \"\",\n+      = VariantDef (UNKNOWN_HIRID, UNKNOWN_DEFID, \"\",\n \t\t    {Resolver::CanonicalPath::create_empty (),\n \t\t     Linemap::unknown_location ()},\n \t\t    nullptr);\n@@ -1116,6 +1116,7 @@ class VariantDef\n   bool is_error () const { return get_id () == UNKNOWN_HIRID; }\n \n   HirId get_id () const { return id; }\n+  DefId get_defid () const { return defid; }\n \n   VariantType get_variant_type () const { return type; }\n   bool is_data_variant () const { return type != VariantType::NUM; }\n@@ -1211,7 +1212,7 @@ class VariantDef\n     for (auto &f : fields)\n       cloned_fields.push_back ((StructFieldType *) f->clone ());\n \n-    return new VariantDef (id, identifier, ident, type, discriminant,\n+    return new VariantDef (id, defid, identifier, ident, type, discriminant,\n \t\t\t   cloned_fields);\n   }\n \n@@ -1221,14 +1222,15 @@ class VariantDef\n     for (auto &f : fields)\n       cloned_fields.push_back ((StructFieldType *) f->monomorphized_clone ());\n \n-    return new VariantDef (id, identifier, ident, type, discriminant,\n+    return new VariantDef (id, defid, identifier, ident, type, discriminant,\n \t\t\t   cloned_fields);\n   }\n \n   const RustIdent &get_ident () const { return ident; }\n \n private:\n   HirId id;\n+  DefId defid;\n   std::string identifier;\n   RustIdent ident;\n   VariantType type;"}, {"sha": "adb489116488130ed259e515d7eb47d74e469077", "filename": "gcc/testsuite/rust/compile/torture/issue-1555.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-1555.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4096017e3b9ca499b56988b67e05667a02ca202/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-1555.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-1555.rs?ref=b4096017e3b9ca499b56988b67e05667a02ca202", "patch": "@@ -0,0 +1,48 @@\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+struct Foo(i32);\n+trait Bar {\n+    fn baz(&self);\n+}\n+\n+trait Baz: Bar {\n+    fn qux(&self);\n+}\n+\n+impl Bar for Foo {\n+    fn baz(&self) {\n+        unsafe {\n+            let a = \"baz %i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, self.0);\n+        }\n+    }\n+}\n+\n+impl Baz for Foo {\n+    fn qux(&self) {\n+        unsafe {\n+            let a = \"qux %i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, self.0);\n+        }\n+    }\n+}\n+\n+fn static_dispatch<T: Baz>(t: &T) {\n+    t.baz();\n+    t.qux();\n+}\n+\n+pub fn main() {\n+    let a;\n+    a = &Foo(123);\n+\n+    static_dispatch(a);\n+}"}]}