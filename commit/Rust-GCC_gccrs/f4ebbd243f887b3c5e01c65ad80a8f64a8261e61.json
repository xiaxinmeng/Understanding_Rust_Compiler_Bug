{"sha": "f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRlYmJkMjQzZjg4N2IzYzVlMDFjNjVhZDgwYThmNjRhODI2MWU2MQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-10-04T17:50:52Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-10-04T17:50:52Z"}, "message": "Report vectorization problems via a new opt_problem class\n\nThis is v3 of the patch; previous versions were:\n  v2: https://gcc.gnu.org/ml/gcc-patches/2018-07/msg00446.html\n  v1: https://gcc.gnu.org/ml/gcc-patches/2018-06/msg01462.html\n\nThis patch introduces a class opt_problem, along with wrapper\nclasses for bool (opt_result) and for pointers (e.g. opt_loop_vec_info\nfor loop_vec_info).\n\nopt_problem instances are created when an optimization problem\nis encountered, but only if dump_enabled_p.  They are manually\npropagated up the callstack, and are manually reported at the\n\"top level\" of an optimization if dumping is enabled, to give the user\na concise summary of the problem *after* the failure is reported.\nIn particular, the location of the problematic statement is\ncaptured and emitted, rather than just the loop's location.\n\nFor example:\n\nno-vfa-vect-102.c:24:3: missed: couldn't vectorize loop\nno-vfa-vect-102.c:27:7: missed: statement clobbers memory: __asm__ __volatile__(\"\" :  :  : \"memory\");\n\nChanged in v3:\n* This version bootstraps and passes regression testing (on\n  x86_64-pc-linux-gnu).\n* added selftests, to exercise the opt_problem machinery\n* removed the \"bool to opt_result\" ctor, so that attempts to\n  use e.g. return a bool from an opt_result-returning function\n  will fail at compile time\n* use formatted printing within opt_problem ctor to replace the\n  various dump_printf_loc calls\n* dropped i18n\n* changed the sense of vect_analyze_data_ref_dependence's return\n  value (see the ChangeLog)\n* add MSG_PRIORITY_REEMITTED, so that -fopt-info can show the\n  messages, without them messing up the counts in scan-tree-dump-times\n  in DejaGnu tests\n\ngcc/ChangeLog:\n\t* Makefile.in (OBJS): Add opt-problem.o.\n\t* dump-context.h: Include \"selftest.h.\n\t(selftest::temp_dump_context): New forward decl.\n\t(class dump_context): Make friend of class\n\tselftest::temp_dump_context.\n\t(dump_context::dump_loc_immediate): New decl.\n\t(class dump_pretty_printer): Move here from dumpfile.c.\n\t(class temp_dump_context): Move to namespace selftest.\n\t(temp_dump_context::temp_dump_context): Add param\n\t\"forcibly_enable_dumping\".\n\t(selftest::verify_dumped_text):\n\t(ASSERT_DUMPED_TEXT_EQ): Move here from dumpfile.c.\n\t(selftest::verify_item):\n\t(ASSERT_IS_TEXT): Move here from dumpfile.c.\n\t(ASSERT_IS_TREE): Likewise.\n\t(ASSERT_IS_GIMPLE): Likewise.\n\t* dumpfile.c (dump_context::dump_loc): Move immediate dumping\n\tto...\n\t(dump_context::dump_loc_immediate): ...this new function.\n\t(class dump_pretty_printer): Move to dump-context.h.\n\t(dump_switch_p_1): Don't enable MSG_PRIORITY_REEMITTED.\n\t(opt_info_switch_p_1): Enable MSG_PRIORITY_REEMITTED.\n\t(temp_dump_context::temp_dump_context): Move to \"selftest\"\n\tnamespace.  Add param \"forcibly_enable_dumping\", and use it to\n\tconditionalize the use of m_pp;\n\t(selftest::verify_dumped_text): Make non-static.\n\t(ASSERT_DUMPED_TEXT_EQ): Move to dump-context.h.\n\t(selftest::verify_item): Make non-static.\n\t(ASSERT_IS_TEXT): Move to dump-context.h.\n\t(ASSERT_IS_TREE): Likewise.\n\t(ASSERT_IS_GIMPLE): Likewise.\n\t(selftest::test_capture_of_dump_calls): Pass \"true\" for new\n\tparam of temp_dump_context.\n\t* dumpfile.h (enum dump_flag): Add MSG_PRIORITY_REEMITTED, adding\n\tit to MSG_ALL_PRIORITIES.  Update values of TDF_COMPARE_DEBUG and\n\tTDF_COMPARE_DEBUG.\n\t* opt-problem.cc: New file.\n\t* opt-problem.h: New file.\n\t* optinfo-emit-json.cc\n\t(selftest::test_building_json_from_dump_calls): Pass \"true\" for\n\tnew param of temp_dump_context.\n\t* optinfo.cc (optinfo_kind_to_dump_flag): New function.\n\t(optinfo::emit_for_opt_problem): New function.\n\t(optinfo::emit): Clarity which emit_item is used.\n\t* optinfo.h (optinfo::get_dump_location): New accessor.\n\t(optinfo::emit_for_opt_problem): New decl.\n\t(optinfo::emit): Make const.\n\t* selftest-run-tests.c (selftest::run_tests): Call\n\tselftest::opt_problem_cc_tests.\n\t* selftest.h (selftest::opt_problem_cc_tests): New decl.\n\t* tree-data-ref.c (dr_analyze_innermost): Convert return type from\n\tbool to opt_result, converting fprintf messages to\n\topt_result::failure_at calls.  Add \"stmt\" param for use by the\n\tfailure_at calls.\n\t(create_data_ref): Pass \"stmt\" to the dr_analyze_innermost call.\n\t(runtime_alias_check_p): Convert return type from bool to\n\topt_result, converting dump_printf calls to\n\topt_result::failure_at, using the statement DDR_A for their\n\tlocation.\n\t(find_data_references_in_stmt): Convert return type from bool to\n\topt_result, converting \"return false\" to opt_result::failure_at\n\twith a new message.\n\t* tree-data-ref.h: Include \"opt-problem.h\".\n\t(dr_analyze_innermost): Convert return type from bool to opt_result,\n\tand add a const gimple * param.\n\t(find_data_references_in_stmt): Convert return type from bool to\n\topt_result.\n\t(runtime_alias_check_p): Likewise.\n\t* tree-predcom.c (find_looparound_phi): Pass \"init_stmt\" to\n\tdr_analyze_innermost.\n\t* tree-vect-data-refs.c (vect_mark_for_runtime_alias_test):\n\tConvert return type from bool to opt_result, adding a message for\n\tthe PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS zero case.\n\t(vect_analyze_data_ref_dependence): Convert return type from bool\n\tto opt_result.  Change sense of return type from \"false\"\n\teffectively meaning \"no problems\" to \"false\" meaning a problem,\n\tso that \"return false\" becomes \"return opt_result::success\".\n\tConvert \"return true\" calls to opt_result::failure_at, using\n\tthe location of statement A rather than vect_location.\n\t(vect_analyze_data_ref_dependences): Convert return type from bool\n\tto opt_result.\n\t(verify_data_ref_alignment): Likewise, converting dump_printf_loc\n\tcalls to opt_result::failure_at, using the stmt location rather\n\tthan vect_location.\n\t(vect_verify_datarefs_alignment): Convert return type from bool\n\tto opt_result.\n\t(vect_enhance_data_refs_alignment): Likewise.  Split local \"stat\"\n\tinto multiple more-tightly-scoped copies.\n\t(vect_analyze_data_refs_alignment): Convert return type from bool\n\tto opt_result.\n\t(vect_analyze_data_ref_accesses): Likewise, converting a\n\t\"return false\" to a \"return opt_result::failure_at\", adding a\n\tnew message.\n\t(vect_prune_runtime_alias_test_list): Convert return type from\n\tbool to opt_result, converting dump_printf_loc to\n\topt_result::failure_at.  Add a %G to show the pertinent statement,\n\tand use the stmt's location rather than vect_location.\n\t(vect_find_stmt_data_reference): Convert return type from\n\tbool to opt_result, converting dump_printf_loc to\n\topt_result::failure_at, using stmt's location.\n\t(vect_analyze_data_refs):  Convert return type from bool to\n\topt_result.  Convert \"return false\" to \"return\n\topt_result::failure_at\", adding messages as needed.\n\t* tree-vect-loop.c (vect_determine_vf_for_stmt_1): Convert return\n\ttype from bool to opt_result.\n\t(vect_determine_vf_for_stmt): Likewise.\n\t(vect_determine_vectorization_factor): Likewise, converting\n\tdump_printf_loc to opt_result::failure_at, using location of phi\n\trather than vect_location.\n\t(vect_analyze_loop_form_1): Convert return type from bool to\n\topt_result, converting dump_printf_loc calls, retaining the use of\n\tvect_location.\n\t(vect_analyze_loop_form): Convert return type from loop_vec_info\n\tto opt_loop_vec_info.\n\t(vect_analyze_loop_operations): Convert return type from bool to\n\topt_result, converting dump_printf_loc calls, using the location\n\tof phi/stmt rather than vect_location where available.  Convert\n\tvarious \"return false\" to \"return opt_result::failure_at\" with\n\t\"unsupported phi\" messages.\n\t(vect_get_datarefs_in_loop): Convert return type from bool to\n\topt_result.  Add a message for the\n\tPARAM_LOOP_MAX_DATAREFS_FOR_DATADEPS failure.\n\t(vect_analyze_loop_2): Convert return type from bool to\n\topt_result.  Ensure \"ok\" is set to a opt_result::failure_at before\n\teach \"goto again;\", adding new messages where needed.\n\tAdd \"unsupported grouped {store|load}\" messages.\n\t(vect_analyze_loop): Convert return type from loop_vec_info to\n\topt_loop_vec_info.\n\t* tree-vect-slp.c (vect_analyze_slp): Convert return type from\n\tbool to opt_result.\n\t* tree-vect-stmts.c (process_use): Likewise, converting\n\tdump_printf_loc call and using stmt location, rather than\n\tvect_location.\n\t(vect_mark_stmts_to_be_vectorized): Likeise.\n\t(vect_analyze_stmt): Likewise, adding a %G.\n\t(vect_get_vector_types_for_stmt): Convert return type from bool to\n\topt_result, converting dump_printf_loc calls and using stmt\n\tlocation, rather than vect_location.\n\t(vect_get_mask_type_for_stmt): Convert return type from tree to\n\topt_tree, converting dump_printf_loc calls and using stmt location.\n\t* tree-vectorizer.c: Include \"opt-problem.h.\n\t(try_vectorize_loop_1): Flag \"Analyzing loop at\" dump message as\n\tMSG_PRIORITY_INTERNALS.  Convert local \"loop_vinfo\" from\n\tloop_vec_info to opt_loop_vec_info.  If if fails, and dumping is\n\tenabled, use it to report at the top level \"couldn't vectorize\n\tloop\" followed by the problem.\n\t* tree-vectorizer.h (opt_loop_vec_info): New typedef.\n\t(vect_mark_stmts_to_be_vectorized): Convert return type from bool\n\tto opt_result.\n\t(vect_analyze_stmt): Likewise.\n\t(vect_get_vector_types_for_stmt): Likewise.\n\t(tree vect_get_mask_type_for_stmt): Likewise.\n\t(vect_analyze_data_ref_dependences): Likewise.\n\t(vect_enhance_data_refs_alignment): Likewise.\n\t(vect_analyze_data_refs_alignment): Likewise.\n\t(vect_verify_datarefs_alignment): Likewise.\n\t(vect_analyze_data_ref_accesses): Likewise.\n\t(vect_prune_runtime_alias_test_list): Likewise.\n\t(vect_find_stmt_data_reference): Likewise.\n\t(vect_analyze_data_refs): Likewise.\n\t(vect_analyze_loop): Convert return type from loop_vec_info to\n\topt_loop_vec_info.\n\t(vect_analyze_loop_form): Likewise.\n\t(vect_analyze_slp): Convert return type from bool to opt_result.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/vect/nodump-vect-opt-info-2.c: New test.\n\t* gcc.dg/vect/vect-alias-check-4.c: Add \"-fopt-info-vec-all\" to\n\tdg-additional-options.  Add dg-message and dg-missed directives\n\tto verify that -fopt-info messages are written at the correct\n\tlocations.\n\nFrom-SVN: r264852", "tree": {"sha": "f76bbe59cb30638b7432efe17c3ddd67c6378b9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f76bbe59cb30638b7432efe17c3ddd67c6378b9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7db960c5b6adad2fd11789870aa514985ea0da04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7db960c5b6adad2fd11789870aa514985ea0da04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7db960c5b6adad2fd11789870aa514985ea0da04"}], "stats": {"total": 2375, "additions": 1583, "deletions": 792}, "files": [{"sha": "683190161352c6b24315b2d6dcf6a7cb599b5189", "filename": "gcc/ChangeLog", "status": "modified", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -1,3 +1,170 @@\n+2018-10-04  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (OBJS): Add opt-problem.o.\n+\t* dump-context.h: Include \"selftest.h.\n+\t(selftest::temp_dump_context): New forward decl.\n+\t(class dump_context): Make friend of class\n+\tselftest::temp_dump_context.\n+\t(dump_context::dump_loc_immediate): New decl.\n+\t(class dump_pretty_printer): Move here from dumpfile.c.\n+\t(class temp_dump_context): Move to namespace selftest.\n+\t(temp_dump_context::temp_dump_context): Add param\n+\t\"forcibly_enable_dumping\".\n+\t(selftest::verify_dumped_text):\n+\t(ASSERT_DUMPED_TEXT_EQ): Move here from dumpfile.c.\n+\t(selftest::verify_item):\n+\t(ASSERT_IS_TEXT): Move here from dumpfile.c.\n+\t(ASSERT_IS_TREE): Likewise.\n+\t(ASSERT_IS_GIMPLE): Likewise.\n+\t* dumpfile.c (dump_context::dump_loc): Move immediate dumping\n+\tto...\n+\t(dump_context::dump_loc_immediate): ...this new function.\n+\t(class dump_pretty_printer): Move to dump-context.h.\n+\t(dump_switch_p_1): Don't enable MSG_PRIORITY_REEMITTED.\n+\t(opt_info_switch_p_1): Enable MSG_PRIORITY_REEMITTED.\n+\t(temp_dump_context::temp_dump_context): Move to \"selftest\"\n+\tnamespace.  Add param \"forcibly_enable_dumping\", and use it to\n+\tconditionalize the use of m_pp;\n+\t(selftest::verify_dumped_text): Make non-static.\n+\t(ASSERT_DUMPED_TEXT_EQ): Move to dump-context.h.\n+\t(selftest::verify_item): Make non-static.\n+\t(ASSERT_IS_TEXT): Move to dump-context.h.\n+\t(ASSERT_IS_TREE): Likewise.\n+\t(ASSERT_IS_GIMPLE): Likewise.\n+\t(selftest::test_capture_of_dump_calls): Pass \"true\" for new\n+\tparam of temp_dump_context.\n+\t* dumpfile.h (enum dump_flag): Add MSG_PRIORITY_REEMITTED, adding\n+\tit to MSG_ALL_PRIORITIES.  Update values of TDF_COMPARE_DEBUG and\n+\tTDF_COMPARE_DEBUG.\n+\t* opt-problem.cc: New file.\n+\t* opt-problem.h: New file.\n+\t* optinfo-emit-json.cc\n+\t(selftest::test_building_json_from_dump_calls): Pass \"true\" for\n+\tnew param of temp_dump_context.\n+\t* optinfo.cc (optinfo_kind_to_dump_flag): New function.\n+\t(optinfo::emit_for_opt_problem): New function.\n+\t(optinfo::emit): Clarity which emit_item is used.\n+\t* optinfo.h (optinfo::get_dump_location): New accessor.\n+\t(optinfo::emit_for_opt_problem): New decl.\n+\t(optinfo::emit): Make const.\n+\t* selftest-run-tests.c (selftest::run_tests): Call\n+\tselftest::opt_problem_cc_tests.\n+\t* selftest.h (selftest::opt_problem_cc_tests): New decl.\n+\t* tree-data-ref.c (dr_analyze_innermost): Convert return type from\n+\tbool to opt_result, converting fprintf messages to\n+\topt_result::failure_at calls.  Add \"stmt\" param for use by the\n+\tfailure_at calls.\n+\t(create_data_ref): Pass \"stmt\" to the dr_analyze_innermost call.\n+\t(runtime_alias_check_p): Convert return type from bool to\n+\topt_result, converting dump_printf calls to\n+\topt_result::failure_at, using the statement DDR_A for their\n+\tlocation.\n+\t(find_data_references_in_stmt): Convert return type from bool to\n+\topt_result, converting \"return false\" to opt_result::failure_at\n+\twith a new message.\n+\t* tree-data-ref.h: Include \"opt-problem.h\".\n+\t(dr_analyze_innermost): Convert return type from bool to opt_result,\n+\tand add a const gimple * param.\n+\t(find_data_references_in_stmt): Convert return type from bool to\n+\topt_result.\n+\t(runtime_alias_check_p): Likewise.\n+\t* tree-predcom.c (find_looparound_phi): Pass \"init_stmt\" to\n+\tdr_analyze_innermost.\n+\t* tree-vect-data-refs.c (vect_mark_for_runtime_alias_test):\n+\tConvert return type from bool to opt_result, adding a message for\n+\tthe PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS zero case.\n+\t(vect_analyze_data_ref_dependence): Convert return type from bool\n+\tto opt_result.  Change sense of return type from \"false\"\n+\teffectively meaning \"no problems\" to \"false\" meaning a problem,\n+\tso that \"return false\" becomes \"return opt_result::success\".\n+\tConvert \"return true\" calls to opt_result::failure_at, using\n+\tthe location of statement A rather than vect_location.\n+\t(vect_analyze_data_ref_dependences): Convert return type from bool\n+\tto opt_result.\n+\t(verify_data_ref_alignment): Likewise, converting dump_printf_loc\n+\tcalls to opt_result::failure_at, using the stmt location rather\n+\tthan vect_location.\n+\t(vect_verify_datarefs_alignment): Convert return type from bool\n+\tto opt_result.\n+\t(vect_enhance_data_refs_alignment): Likewise.  Split local \"stat\"\n+\tinto multiple more-tightly-scoped copies.\n+\t(vect_analyze_data_refs_alignment): Convert return type from bool\n+\tto opt_result.\n+\t(vect_analyze_data_ref_accesses): Likewise, converting a\n+\t\"return false\" to a \"return opt_result::failure_at\", adding a\n+\tnew message.\n+\t(vect_prune_runtime_alias_test_list): Convert return type from\n+\tbool to opt_result, converting dump_printf_loc to\n+\topt_result::failure_at.  Add a %G to show the pertinent statement,\n+\tand use the stmt's location rather than vect_location.\n+\t(vect_find_stmt_data_reference): Convert return type from\n+\tbool to opt_result, converting dump_printf_loc to\n+\topt_result::failure_at, using stmt's location.\n+\t(vect_analyze_data_refs):  Convert return type from bool to\n+\topt_result.  Convert \"return false\" to \"return\n+\topt_result::failure_at\", adding messages as needed.\n+\t* tree-vect-loop.c (vect_determine_vf_for_stmt_1): Convert return\n+\ttype from bool to opt_result.\n+\t(vect_determine_vf_for_stmt): Likewise.\n+\t(vect_determine_vectorization_factor): Likewise, converting\n+\tdump_printf_loc to opt_result::failure_at, using location of phi\n+\trather than vect_location.\n+\t(vect_analyze_loop_form_1): Convert return type from bool to\n+\topt_result, converting dump_printf_loc calls, retaining the use of\n+\tvect_location.\n+\t(vect_analyze_loop_form): Convert return type from loop_vec_info\n+\tto opt_loop_vec_info.\n+\t(vect_analyze_loop_operations): Convert return type from bool to\n+\topt_result, converting dump_printf_loc calls, using the location\n+\tof phi/stmt rather than vect_location where available.  Convert\n+\tvarious \"return false\" to \"return opt_result::failure_at\" with\n+\t\"unsupported phi\" messages.\n+\t(vect_get_datarefs_in_loop): Convert return type from bool to\n+\topt_result.  Add a message for the\n+\tPARAM_LOOP_MAX_DATAREFS_FOR_DATADEPS failure.\n+\t(vect_analyze_loop_2): Convert return type from bool to\n+\topt_result.  Ensure \"ok\" is set to a opt_result::failure_at before\n+\teach \"goto again;\", adding new messages where needed.\n+\tAdd \"unsupported grouped {store|load}\" messages.\n+\t(vect_analyze_loop): Convert return type from loop_vec_info to\n+\topt_loop_vec_info.\n+\t* tree-vect-slp.c (vect_analyze_slp): Convert return type from\n+\tbool to opt_result.\n+\t* tree-vect-stmts.c (process_use): Likewise, converting\n+\tdump_printf_loc call and using stmt location, rather than\n+\tvect_location.\n+\t(vect_mark_stmts_to_be_vectorized): Likeise.\n+\t(vect_analyze_stmt): Likewise, adding a %G.\n+\t(vect_get_vector_types_for_stmt): Convert return type from bool to\n+\topt_result, converting dump_printf_loc calls and using stmt\n+\tlocation, rather than vect_location.\n+\t(vect_get_mask_type_for_stmt): Convert return type from tree to\n+\topt_tree, converting dump_printf_loc calls and using stmt location.\n+\t* tree-vectorizer.c: Include \"opt-problem.h.\n+\t(try_vectorize_loop_1): Flag \"Analyzing loop at\" dump message as\n+\tMSG_PRIORITY_INTERNALS.  Convert local \"loop_vinfo\" from\n+\tloop_vec_info to opt_loop_vec_info.  If if fails, and dumping is\n+\tenabled, use it to report at the top level \"couldn't vectorize\n+\tloop\" followed by the problem.\n+\t* tree-vectorizer.h (opt_loop_vec_info): New typedef.\n+\t(vect_mark_stmts_to_be_vectorized): Convert return type from bool\n+\tto opt_result.\n+\t(vect_analyze_stmt): Likewise.\n+\t(vect_get_vector_types_for_stmt): Likewise.\n+\t(tree vect_get_mask_type_for_stmt): Likewise.\n+\t(vect_analyze_data_ref_dependences): Likewise.\n+\t(vect_enhance_data_refs_alignment): Likewise.\n+\t(vect_analyze_data_refs_alignment): Likewise.\n+\t(vect_verify_datarefs_alignment): Likewise.\n+\t(vect_analyze_data_ref_accesses): Likewise.\n+\t(vect_prune_runtime_alias_test_list): Likewise.\n+\t(vect_find_stmt_data_reference): Likewise.\n+\t(vect_analyze_data_refs): Likewise.\n+\t(vect_analyze_loop): Convert return type from loop_vec_info to\n+\topt_loop_vec_info.\n+\t(vect_analyze_loop_form): Likewise.\n+\t(vect_analyze_slp): Convert return type from bool to opt_result.\n+\n 2018-10-04  David Malcolm  <dmalcolm@redhat.com>\n \n \t* doc/invoke.texi (-fopt-info): Document new \"internals\""}, {"sha": "116ed6ea8a54884fe5c25cce5691857e41c120d1", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -1423,6 +1423,7 @@ OBJS = \\\n \tomp-grid.o \\\n \tomp-low.o \\\n \tomp-simd-clone.o \\\n+\topt-problem.o \\\n \toptabs.o \\\n \toptabs-libfuncs.o \\\n \toptabs-query.o \\"}, {"sha": "3a45f230105317307e6bc103ac0eb03441de79f7", "filename": "gcc/dump-context.h", "status": "modified", "additions": 103, "deletions": 1, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Fdump-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Fdump-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdump-context.h?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -24,6 +24,9 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"dumpfile.h\"\n #include \"pretty-print.h\"\n+#include \"selftest.h\"\n+\n+namespace selftest { class temp_dump_context; }\n \n /* A class for handling the various dump_* calls.\n \n@@ -36,7 +39,8 @@ along with GCC; see the file COPYING3.  If not see\n \n class dump_context\n {\n-  friend class temp_dump_context;\n+  friend class selftest::temp_dump_context;\n+\n  public:\n   static dump_context &get () { return *s_current; }\n \n@@ -45,6 +49,7 @@ class dump_context\n   void refresh_dumps_are_enabled ();\n \n   void dump_loc (dump_flags_t dump_kind, const dump_location_t &loc);\n+  void dump_loc_immediate (dump_flags_t dump_kind, const dump_location_t &loc);\n \n   void dump_gimple_stmt (dump_flags_t dump_kind, dump_flags_t extra_dump_flags,\n \t\t\t gimple *gs, int spc);\n@@ -129,15 +134,61 @@ class dump_context\n   static dump_context s_default;\n };\n \n+/* A subclass of pretty_printer for implementing dump_context::dump_printf_va.\n+   In particular, the formatted chunks are captured as optinfo_item instances,\n+   thus retaining metadata about the entities being dumped (e.g. source\n+   locations), rather than just as plain text.  */\n+\n+class dump_pretty_printer : public pretty_printer\n+{\n+public:\n+  dump_pretty_printer (dump_context *context, dump_flags_t dump_kind);\n+\n+  void emit_items (optinfo *dest);\n+\n+private:\n+  /* Information on an optinfo_item that was generated during phase 2 of\n+     formatting.  */\n+  struct stashed_item\n+  {\n+    stashed_item (const char **buffer_ptr_, optinfo_item *item_)\n+      : buffer_ptr (buffer_ptr_), item (item_) {}\n+    const char **buffer_ptr;\n+    optinfo_item *item;\n+  };\n+\n+  static bool format_decoder_cb (pretty_printer *pp, text_info *text,\n+\t\t\t\t const char *spec, int /*precision*/,\n+\t\t\t\t bool /*wide*/, bool /*set_locus*/,\n+\t\t\t\t bool /*verbose*/, bool */*quoted*/,\n+\t\t\t\t const char **buffer_ptr);\n+\n+  bool decode_format (text_info *text, const char *spec,\n+\t\t      const char **buffer_ptr);\n+\n+  void stash_item (const char **buffer_ptr, optinfo_item *item);\n+\n+  void emit_any_pending_textual_chunks (optinfo *dest);\n+\n+  void emit_item (optinfo_item *item, optinfo *dest);\n+\n+  dump_context *m_context;\n+  dump_flags_t m_dump_kind;\n+  auto_vec<stashed_item> m_stashed_items;\n+};\n+\n #if CHECKING_P\n \n+namespace selftest {\n+\n /* An RAII-style class for use in selftests for temporarily using a different\n    dump_context.  */\n \n class temp_dump_context\n {\n  public:\n   temp_dump_context (bool forcibly_enable_optinfo,\n+\t\t     bool forcibly_enable_dumping,\n \t\t     dump_flags_t test_pp_flags);\n   ~temp_dump_context ();\n \n@@ -151,6 +202,57 @@ class temp_dump_context\n   dump_context *m_saved;\n };\n \n+/* Implementation detail of ASSERT_DUMPED_TEXT_EQ.  */\n+\n+extern void verify_dumped_text (const location &loc,\n+\t\t\t\ttemp_dump_context *context,\n+\t\t\t\tconst char *expected_text);\n+\n+/* Verify that the text dumped so far in CONTEXT equals\n+   EXPECTED_TEXT.\n+   As a side-effect, the internal buffer is 0-terminated.  */\n+\n+#define ASSERT_DUMPED_TEXT_EQ(CONTEXT, EXPECTED_TEXT)\t\t\t\\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n+    verify_dumped_text (SELFTEST_LOCATION, &(CONTEXT), (EXPECTED_TEXT)); \\\n+  SELFTEST_END_STMT\n+\n+\n+/* Verify that ITEM has the expected values.  */\n+\n+void\n+verify_item (const location &loc,\n+\t     const optinfo_item *item,\n+\t     enum optinfo_item_kind expected_kind,\n+\t     location_t expected_location,\n+\t     const char *expected_text);\n+\n+/* Verify that ITEM is a text item, with EXPECTED_TEXT.  */\n+\n+#define ASSERT_IS_TEXT(ITEM, EXPECTED_TEXT) \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t    \\\n+    verify_item (SELFTEST_LOCATION, (ITEM), OPTINFO_ITEM_KIND_TEXT, \\\n+\t\t UNKNOWN_LOCATION, (EXPECTED_TEXT));\t\t    \\\n+  SELFTEST_END_STMT\n+\n+/* Verify that ITEM is a tree item, with the expected values.  */\n+\n+#define ASSERT_IS_TREE(ITEM, EXPECTED_LOCATION, EXPECTED_TEXT) \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t    \\\n+    verify_item (SELFTEST_LOCATION, (ITEM), OPTINFO_ITEM_KIND_TREE, \\\n+\t\t (EXPECTED_LOCATION), (EXPECTED_TEXT));\t    \\\n+  SELFTEST_END_STMT\n+\n+/* Verify that ITEM is a gimple item, with the expected values.  */\n+\n+#define ASSERT_IS_GIMPLE(ITEM, EXPECTED_LOCATION, EXPECTED_TEXT) \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t    \\\n+    verify_item (SELFTEST_LOCATION, (ITEM), OPTINFO_ITEM_KIND_GIMPLE, \\\n+\t\t (EXPECTED_LOCATION), (EXPECTED_TEXT));\t    \\\n+  SELFTEST_END_STMT\n+\n+} // namespace selftest\n+\n #endif /* CHECKING_P */\n \n #endif /* GCC_DUMP_CONTEXT_H */"}, {"sha": "0b140ffb8beca65d8d612d480e798bf1741cb493", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 52, "deletions": 108, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -562,6 +562,21 @@ dump_context::dump_loc (dump_flags_t dump_kind, const dump_location_t &loc)\n {\n   end_any_optinfo ();\n \n+  dump_loc_immediate (dump_kind, loc);\n+\n+  if (optinfo_enabled_p ())\n+    {\n+      optinfo &info = begin_next_optinfo (loc);\n+      info.handle_dump_file_kind (dump_kind);\n+    }\n+}\n+\n+/* As dump_loc above, but without starting a new optinfo. */\n+\n+void\n+dump_context::dump_loc_immediate (dump_flags_t dump_kind,\n+\t\t\t\t  const dump_location_t &loc)\n+{\n   location_t srcloc = loc.get_location_t ();\n \n   if (dump_file && apply_dump_filter_p (dump_kind, pflags))\n@@ -573,12 +588,6 @@ dump_context::dump_loc (dump_flags_t dump_kind, const dump_location_t &loc)\n   /* Support for temp_dump_context in selftests.  */\n   if (m_test_pp && apply_dump_filter_p (dump_kind, m_test_pp_flags))\n     ::dump_loc (dump_kind, m_test_pp, srcloc);\n-\n-  if (optinfo_enabled_p ())\n-    {\n-      optinfo &info = begin_next_optinfo (loc);\n-      info.handle_dump_file_kind (dump_kind);\n-    }\n }\n \n /* Make an item for the given dump call, equivalent to print_gimple_stmt.  */\n@@ -739,49 +748,6 @@ dump_context::dump_generic_expr_loc (dump_flags_t dump_kind,\n   dump_generic_expr (dump_kind, extra_dump_flags, t);\n }\n \n-/* A subclass of pretty_printer for implementing dump_context::dump_printf_va.\n-   In particular, the formatted chunks are captured as optinfo_item instances,\n-   thus retaining metadata about the entities being dumped (e.g. source\n-   locations), rather than just as plain text.  */\n-\n-class dump_pretty_printer : public pretty_printer\n-{\n-public:\n-  dump_pretty_printer (dump_context *context, dump_flags_t dump_kind);\n-\n-  void emit_items (optinfo *dest);\n-\n-private:\n-  /* Information on an optinfo_item that was generated during phase 2 of\n-     formatting.  */\n-  struct stashed_item\n-  {\n-    stashed_item (const char **buffer_ptr_, optinfo_item *item_)\n-      : buffer_ptr (buffer_ptr_), item (item_) {}\n-    const char **buffer_ptr;\n-    optinfo_item *item;\n-  };\n-\n-  static bool format_decoder_cb (pretty_printer *pp, text_info *text,\n-\t\t\t\t const char *spec, int /*precision*/,\n-\t\t\t\t bool /*wide*/, bool /*set_locus*/,\n-\t\t\t\t bool /*verbose*/, bool */*quoted*/,\n-\t\t\t\t const char **buffer_ptr);\n-\n-  bool decode_format (text_info *text, const char *spec,\n-\t\t      const char **buffer_ptr);\n-\n-  void stash_item (const char **buffer_ptr, optinfo_item *item);\n-\n-  void emit_any_pending_textual_chunks (optinfo *dest);\n-\n-  void emit_item (optinfo_item *item, optinfo *dest);\n-\n-  dump_context *m_context;\n-  dump_flags_t m_dump_kind;\n-  auto_vec<stashed_item> m_stashed_items;\n-};\n-\n /* dump_pretty_printer's ctor.  */\n \n dump_pretty_printer::dump_pretty_printer (dump_context *context,\n@@ -1732,7 +1698,12 @@ dump_switch_p_1 (const char *arg, struct dump_file_info *dfi, bool doglob)\n     return 0;\n \n   ptr = option_value;\n-  flags = MSG_ALL_PRIORITIES;\n+\n+  /* Retain \"user-facing\" and \"internals\" messages, but filter out\n+     those from an opt_problem being re-emitted at the top level\n+     (MSG_PRIORITY_REEMITTED), so as to avoid duplicate messages\n+     messing up scan-tree-dump-times\" in DejaGnu tests.  */\n+  flags = MSG_PRIORITY_USER_FACING | MSG_PRIORITY_INTERNALS;\n \n   while (*ptr)\n     {\n@@ -1830,8 +1801,9 @@ opt_info_switch_p_1 (const char *arg, dump_flags_t *flags,\n   *filename = NULL;\n \n   /* Default to filtering out \"internals\" messages, and retaining\n-     \"user-facing\" messages.  */\n-  *flags = MSG_PRIORITY_USER_FACING;\n+     \"user-facing\" messages, and those from an opt_problem being\n+     re-emitted at the top level.  */\n+  *flags = MSG_PRIORITY_USER_FACING | MSG_PRIORITY_REEMITTED;\n \n   *optgroup_flags = OPTGROUP_NONE;\n \n@@ -1981,19 +1953,26 @@ enable_rtl_dump_file (void)\n \n #if CHECKING_P\n \n+namespace selftest {\n+\n /* temp_dump_context's ctor.  Temporarily override the dump_context\n    (to forcibly enable optinfo-generation).  */\n \n temp_dump_context::temp_dump_context (bool forcibly_enable_optinfo,\n+\t\t\t\t      bool forcibly_enable_dumping,\n \t\t\t\t      dump_flags_t test_pp_flags)\n-\n : m_context (),\n   m_saved (&dump_context ().get ())\n {\n   dump_context::s_current = &m_context;\n   m_context.m_forcibly_enable_optinfo = forcibly_enable_optinfo;\n-  m_context.m_test_pp = &m_pp;\n-  m_context.m_test_pp_flags = test_pp_flags;\n+  /* Conditionally enable the test dump, so that we can verify both the\n+     dump_enabled_p and the !dump_enabled_p cases in selftests.  */\n+  if (forcibly_enable_dumping)\n+    {\n+      m_context.m_test_pp = &m_pp;\n+      m_context.m_test_pp_flags = test_pp_flags;\n+    }\n \n   dump_context::get ().refresh_dumps_are_enabled ();\n }\n@@ -2015,8 +1994,6 @@ temp_dump_context::get_dumped_text ()\n   return pp_formatted_text (&m_pp);\n }\n \n-namespace selftest {\n-\n /* Verify that the dump_location_t constructors capture the source location\n    at which they were called (provided that the build compiler is sufficiently\n    recent).  */\n@@ -2055,7 +2032,7 @@ test_impl_location ()\n    EXPECTED_TEXT, using LOC for the location of any failure.\n    As a side-effect, the internal buffer is 0-terminated.  */\n \n-static void\n+void\n verify_dumped_text (const location &loc,\n \t\t    temp_dump_context *context,\n \t\t    const char *expected_text)\n@@ -2065,18 +2042,9 @@ verify_dumped_text (const location &loc,\n \t\t   expected_text);\n }\n \n-/* Verify that the text dumped so far in CONTEXT equals\n-   EXPECTED_TEXT.\n-   As a side-effect, the internal buffer is 0-terminated.  */\n-\n-#define ASSERT_DUMPED_TEXT_EQ(CONTEXT, EXPECTED_TEXT)\t\t\t\\\n-  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n-    verify_dumped_text (SELFTEST_LOCATION, &(CONTEXT), (EXPECTED_TEXT)); \\\n-  SELFTEST_END_STMT\n-\n /* Verify that ITEM has the expected values.  */\n \n-static void\n+void\n verify_item (const location &loc,\n \t     const optinfo_item *item,\n \t     enum optinfo_item_kind expected_kind,\n@@ -2088,30 +2056,6 @@ verify_item (const location &loc,\n   ASSERT_STREQ_AT (loc, item->get_text (), expected_text);\n }\n \n-/* Verify that ITEM is a text item, with EXPECTED_TEXT.  */\n-\n-#define ASSERT_IS_TEXT(ITEM, EXPECTED_TEXT) \\\n-  SELFTEST_BEGIN_STMT\t\t\t\t\t\t    \\\n-    verify_item (SELFTEST_LOCATION, (ITEM), OPTINFO_ITEM_KIND_TEXT, \\\n-\t\t UNKNOWN_LOCATION, (EXPECTED_TEXT));\t\t    \\\n-  SELFTEST_END_STMT\n-\n-/* Verify that ITEM is a tree item, with the expected values.  */\n-\n-#define ASSERT_IS_TREE(ITEM, EXPECTED_LOCATION, EXPECTED_TEXT) \\\n-  SELFTEST_BEGIN_STMT\t\t\t\t\t\t    \\\n-    verify_item (SELFTEST_LOCATION, (ITEM), OPTINFO_ITEM_KIND_TREE, \\\n-\t\t (EXPECTED_LOCATION), (EXPECTED_TEXT));\t    \\\n-  SELFTEST_END_STMT\n-\n-/* Verify that ITEM is a gimple item, with the expected values.  */\n-\n-#define ASSERT_IS_GIMPLE(ITEM, EXPECTED_LOCATION, EXPECTED_TEXT) \\\n-  SELFTEST_BEGIN_STMT\t\t\t\t\t\t    \\\n-    verify_item (SELFTEST_LOCATION, (ITEM), OPTINFO_ITEM_KIND_GIMPLE, \\\n-\t\t (EXPECTED_LOCATION), (EXPECTED_TEXT));\t    \\\n-  SELFTEST_END_STMT\n-\n /* Verify that calls to the dump_* API are captured and consolidated into\n    optimization records. */\n \n@@ -2144,7 +2088,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \n       /* Test of dump_printf.  */\n       {\n-\ttemp_dump_context tmp (with_optinfo,\n+\ttemp_dump_context tmp (with_optinfo, true,\n \t\t\t       MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \tdump_printf (MSG_NOTE, \"int: %i str: %s\", 42, \"foo\");\n \n@@ -2161,7 +2105,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \n       /* Test of dump_printf with %T.  */\n       {\n-\ttemp_dump_context tmp (with_optinfo,\n+\ttemp_dump_context tmp (with_optinfo, true,\n \t\t\t       MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \tdump_printf (MSG_NOTE, \"tree: %T\", integer_zero_node);\n \n@@ -2179,7 +2123,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \n       /* Test of dump_printf with %E.  */\n       {\n-\ttemp_dump_context tmp (with_optinfo,\n+\ttemp_dump_context tmp (with_optinfo, true,\n \t\t\t       MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \tdump_printf (MSG_NOTE, \"gimple: %E\", stmt);\n \n@@ -2197,7 +2141,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \n       /* Test of dump_printf with %G.  */\n       {\n-\ttemp_dump_context tmp (with_optinfo,\n+\ttemp_dump_context tmp (with_optinfo, true,\n \t\t\t       MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \tdump_printf (MSG_NOTE, \"gimple: %G\", stmt);\n \n@@ -2220,7 +2164,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t - multiple dump-specific format codes: some consecutive, others\n \t separated by text, trailing text after the final one.  */\n       {\n-\ttemp_dump_context tmp (with_optinfo,\n+\ttemp_dump_context tmp (with_optinfo, true,\n \t\t\t       MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \tdump_printf_loc (MSG_NOTE, loc, \"before %T and %T\"\n \t\t\t \" %i consecutive %E%E after\\n\",\n@@ -2248,7 +2192,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \n       /* Tree, via dump_generic_expr.  */\n       {\n-\ttemp_dump_context tmp (with_optinfo,\n+\ttemp_dump_context tmp (with_optinfo, true,\n \t\t\t       MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \tdump_printf_loc (MSG_NOTE, loc, \"test of tree: \");\n \tdump_generic_expr (MSG_NOTE, TDF_SLIM, integer_zero_node);\n@@ -2268,7 +2212,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \n       /* Tree, via dump_generic_expr_loc.  */\n       {\n-\ttemp_dump_context tmp (with_optinfo,\n+\ttemp_dump_context tmp (with_optinfo, true,\n \t\t\t       MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \tdump_generic_expr_loc (MSG_NOTE, loc, TDF_SLIM, integer_one_node);\n \n@@ -2288,7 +2232,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n       {\n \t/* dump_gimple_stmt_loc.  */\n \t{\n-\t  temp_dump_context tmp (with_optinfo,\n+\t  temp_dump_context tmp (with_optinfo, true,\n \t\t\t\t MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \t  dump_gimple_stmt_loc (MSG_NOTE, loc, TDF_SLIM, stmt, 2);\n \n@@ -2304,7 +2248,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \n \t/* dump_gimple_stmt.  */\n \t{\n-\t  temp_dump_context tmp (with_optinfo,\n+\t  temp_dump_context tmp (with_optinfo, true,\n \t\t\t\t MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 2);\n \n@@ -2320,7 +2264,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \n \t/* dump_gimple_expr_loc.  */\n \t{\n-\t  temp_dump_context tmp (with_optinfo,\n+\t  temp_dump_context tmp (with_optinfo, true,\n \t\t\t\t MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \t  dump_gimple_expr_loc (MSG_NOTE, loc, TDF_SLIM, stmt, 2);\n \n@@ -2336,7 +2280,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \n \t/* dump_gimple_expr.  */\n \t{\n-\t  temp_dump_context tmp (with_optinfo,\n+\t  temp_dump_context tmp (with_optinfo, true,\n \t\t\t\t MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \t  dump_gimple_expr (MSG_NOTE, TDF_SLIM, stmt, 2);\n \n@@ -2353,7 +2297,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \n       /* poly_int.  */\n       {\n-\ttemp_dump_context tmp (with_optinfo,\n+\ttemp_dump_context tmp (with_optinfo, true,\n \t\t\t       MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \tdump_dec (MSG_NOTE, poly_int64 (42));\n \n@@ -2378,7 +2322,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t  if (j / 2)\n \t    dump_filter |= MSG_PRIORITY_INTERNALS;\n \n-\t  temp_dump_context tmp (with_optinfo, dump_filter);\n+\t  temp_dump_context tmp (with_optinfo, true, dump_filter);\n \t  /* Emit various messages, mostly with implicit priority.  */\n \t  dump_printf_loc (MSG_NOTE, stmt, \"msg 1\\n\");\n \t  dump_printf_loc (MSG_NOTE | MSG_PRIORITY_INTERNALS, stmt,\n@@ -2460,15 +2404,15 @@ test_capture_of_dump_calls (const line_table_case &case_)\n   {\n     /* MSG_OPTIMIZED_LOCATIONS.  */\n     {\n-      temp_dump_context tmp (true, MSG_ALL_KINDS);\n+      temp_dump_context tmp (true, true, MSG_ALL_KINDS);\n       dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc, \"test\");\n       ASSERT_EQ (tmp.get_pending_optinfo ()->get_kind (),\n \t\t OPTINFO_KIND_SUCCESS);\n     }\n \n     /* MSG_MISSED_OPTIMIZATION.  */\n     {\n-      temp_dump_context tmp (true, MSG_ALL_KINDS);\n+      temp_dump_context tmp (true, true, MSG_ALL_KINDS);\n       dump_printf_loc (MSG_MISSED_OPTIMIZATION, loc, \"test\");\n       ASSERT_EQ (tmp.get_pending_optinfo ()->get_kind (),\n \t\t OPTINFO_KIND_FAILURE);\n@@ -2477,7 +2421,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \n   /* Verify that MSG_* affect AUTO_DUMP_SCOPE and the dump calls.  */\n   {\n-    temp_dump_context tmp (false,\n+    temp_dump_context tmp (false, true,\n \t\t\t   MSG_OPTIMIZED_LOCATIONS | MSG_ALL_PRIORITIES);\n     dump_printf_loc (MSG_NOTE, stmt, \"msg 1\\n\");\n     {"}, {"sha": "c82157d295c2f088893ca8cc033d877351b4f337", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -179,15 +179,22 @@ enum dump_flag\n   /* Implicitly supplied for messages within nested dump scopes.  */\n   MSG_PRIORITY_INTERNALS = (1 << 26),\n \n+  /* Supplied when an opt_problem generated in a nested scope is re-emitted\n+     at the top-level.   We want to default to showing these in -fopt-info\n+     output, but to *not* show them in dump files, as the message would be\n+     shown twice, messing up \"scan-tree-dump-times\" in DejaGnu tests.  */\n+  MSG_PRIORITY_REEMITTED = (1 << 27),\n+\n   /* Mask for selecting MSG_PRIORITY_* flags.  */\n   MSG_ALL_PRIORITIES = (MSG_PRIORITY_USER_FACING\n-\t\t\t| MSG_PRIORITY_INTERNALS),\n+\t\t\t| MSG_PRIORITY_INTERNALS\n+\t\t\t| MSG_PRIORITY_REEMITTED),\n \n   /* Dumping for -fcompare-debug.  */\n-  TDF_COMPARE_DEBUG = (1 << 27),\n+  TDF_COMPARE_DEBUG = (1 << 28),\n \n   /* All values.  */\n-  TDF_ALL_VALUES = (1 << 28) - 1\n+  TDF_ALL_VALUES = (1 << 29) - 1\n };\n \n /* Dump flags type.  */"}, {"sha": "dad3a8c008b3f7dc2fa3365193e272695bc6b60d", "filename": "gcc/opt-problem.cc", "status": "added", "additions": 335, "deletions": 0, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Fopt-problem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Fopt-problem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopt-problem.cc?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -0,0 +1,335 @@\n+/* Rich optional information on why an optimization wasn't possible.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"pretty-print.h\"\n+#include \"opt-problem.h\"\n+#include \"dump-context.h\"\n+#include \"tree-pass.h\"\n+#include \"selftest.h\"\n+\n+/* opt_problem's ctor.\n+\n+   Use FMT and AP to emit a message to the \"immediate\" dump destinations\n+   as if via:\n+     dump_printf_loc (MSG_MISSED_OPTIMIZATION, loc, ...)\n+\n+   The optinfo_item instances are not emitted yet.  Instead, they\n+   are retained internally so that the message can be replayed and\n+   emitted when this problem is handled, higher up the call stack.  */\n+\n+opt_problem::opt_problem (const dump_location_t &loc,\n+\t\t\t  const char *fmt, va_list *ap)\n+: m_optinfo (loc, OPTINFO_KIND_FAILURE, current_pass)\n+{\n+  /* We shouldn't be bothering to construct these objects if\n+     dumping isn't enabled.  */\n+  gcc_assert (dump_enabled_p ());\n+\n+  /* Update the singleton.  */\n+  delete s_the_problem;\n+  s_the_problem = this;\n+\n+  /* Print the location to the \"immediate\" dump destinations.  */\n+  dump_context &dc = dump_context::get ();\n+  dc.dump_loc (MSG_MISSED_OPTIMIZATION, loc);\n+\n+  /* Print the formatted string to this opt_problem's optinfo, dumping\n+     the items to the \"immediate\" dump destinations, and storing items\n+     for later retrieval.  */\n+  {\n+    dump_pretty_printer pp (&dump_context::get (), MSG_MISSED_OPTIMIZATION);\n+\n+    text_info text;\n+    text.err_no = errno;\n+    text.args_ptr = ap;\n+    text.format_spec = fmt; /* No i18n is performed.  */\n+\n+    /* Phases 1 and 2, using pp_format.  */\n+    pp_format (&pp, &text);\n+\n+    /* Phase 3: dump the items to the \"immediate\" dump destinations,\n+       and storing them into m_optinfo for later retrieval.  */\n+    pp.emit_items (&m_optinfo);\n+  }\n+}\n+\n+/* Emit this problem and delete it, clearing the current opt_problem.  */\n+\n+void\n+opt_problem::emit_and_clear ()\n+{\n+  gcc_assert (this == s_the_problem);\n+\n+  m_optinfo.emit_for_opt_problem ();\n+\n+  delete this;\n+  s_the_problem = NULL;\n+}\n+\n+/* The singleton opt_problem *.  */\n+\n+opt_problem *opt_problem::s_the_problem;\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+static opt_result\n+function_that_succeeds ()\n+{\n+  return opt_result::success ();\n+}\n+\n+/* Verify that opt_result::success works.  */\n+\n+static void\n+test_opt_result_success ()\n+{\n+  /* Run all tests twice, with and then without dumping enabled.  */\n+  for (int i = 0 ; i < 2; i++)\n+    {\n+      bool with_dumping = (i == 0);\n+\n+      temp_dump_context tmp (with_dumping, with_dumping,\n+\t\t\t     MSG_ALL_KINDS | MSG_ALL_PRIORITIES);\n+\n+      if (with_dumping)\n+\tgcc_assert (dump_enabled_p ());\n+      else\n+\tgcc_assert (!dump_enabled_p ());\n+\n+      opt_result res = function_that_succeeds ();\n+\n+      /* Verify that \"success\" can be used as a \"true\" boolean.  */\n+      ASSERT_TRUE (res);\n+\n+      /* Verify the underlying opt_wrapper<bool>.  */\n+      ASSERT_TRUE (res.get_result ());\n+      ASSERT_EQ (res.get_problem (), NULL);\n+\n+      /* Nothing should have been dumped.  */\n+      ASSERT_DUMPED_TEXT_EQ (tmp, \"\");\n+      optinfo *info = tmp.get_pending_optinfo ();\n+      ASSERT_EQ (info, NULL);\n+    }\n+}\n+\n+/* Example of a function that fails, with a non-trivial\n+   pre-canned error message.  */\n+\n+static opt_result\n+function_that_fails (const greturn *stmt)\n+{\n+  gcc_assert (stmt);\n+  gcc_assert (gimple_return_retval (stmt));\n+\n+  AUTO_DUMP_SCOPE (\"function_that_fails\", stmt);\n+\n+  return opt_result::failure_at (stmt,\n+\t\t\t\t \"can't handle return type: %T for stmt: %G\",\n+\t\t\t\t TREE_TYPE (gimple_return_retval (stmt)),\n+\t\t\t\t static_cast <const gimple *> (stmt));\n+}\n+\n+/* Example of a function that indirectly fails.  */\n+\n+static opt_result\n+function_that_indirectly_fails (const greturn *stmt)\n+{\n+  AUTO_DUMP_SCOPE (\"function_that_indirectly_fails\", stmt);\n+\n+  opt_result res = function_that_fails (stmt);\n+  if (!res)\n+    return res;\n+  return opt_result::success ();\n+}\n+\n+/* Verify that opt_result::failure_at works.\n+   Simulate a failure handling a stmt at one location whilst considering\n+   an optimization that's notionally at another location (as a microcosm\n+   of e.g. a problematic statement within a loop that prevents loop\n+   vectorization).  */\n+\n+static void\n+test_opt_result_failure_at (const line_table_case &case_)\n+{\n+  /* Generate a location_t for testing.  */\n+  line_table_test ltt (case_);\n+  const line_map_ordinary *ord_map\n+    = linemap_check_ordinary (linemap_add (line_table, LC_ENTER, false,\n+\t\t\t\t\t   \"test.c\", 0));\n+  linemap_line_start (line_table, 5, 100);\n+\n+  /* A test location: \"test.c:5:10\".  */\n+  const location_t line_5 = linemap_position_for_column (line_table, 10);\n+\n+  /* Another test location: \"test.c:6:12\".  */\n+  const location_t line_6\n+    = linemap_position_for_line_and_column (line_table, ord_map, 6, 12);\n+\n+  if (line_6 > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n+  /* Generate statements using \"line_5\" and \"line_6\" for testing.  */\n+  greturn *stmt_at_5 = gimple_build_return (integer_one_node);\n+  gimple_set_location (stmt_at_5, line_5);\n+\n+  greturn *stmt_at_6 = gimple_build_return (integer_zero_node);\n+  gimple_set_location (stmt_at_6, line_6);\n+\n+  /* Run with and then without dumping enabled.  */\n+  for (int i = 0; i < 2; i++)\n+    {\n+      bool with_dumping = (i == 0);\n+\n+      /* Run with all 4 combinations of\n+\t with and without MSG_PRIORITY_INTERNALS and\n+\t with and without MSG_PRIORITY_REEMITTED.  */\n+      for (int j = 0; j < 4; j++)\n+\t{\n+\t  dump_flags_t filter = MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING;\n+\t  if (j / 2)\n+\t    filter |= MSG_PRIORITY_INTERNALS;\n+\t  if (j % 2)\n+\t    filter |= MSG_PRIORITY_REEMITTED;\n+\n+\t  temp_dump_context tmp (with_dumping, with_dumping, filter);\n+\n+\t  if (with_dumping)\n+\t    gcc_assert (dump_enabled_p ());\n+\t  else\n+\t    gcc_assert (!dump_enabled_p ());\n+\n+\t  /* Simulate attempting to optimize \"stmt_at_6\".  */\n+\t  opt_result res = function_that_indirectly_fails (stmt_at_6);\n+\n+\t  /* Verify that \"failure\" can be used as a \"false\" boolean.  */\n+\t  ASSERT_FALSE (res);\n+\n+\t  /* Verify the underlying opt_wrapper<bool>.  */\n+\t  ASSERT_FALSE (res.get_result ());\n+\t  opt_problem *problem = res.get_problem ();\n+\n+\t  if (with_dumping)\n+\t    {\n+\t      ASSERT_NE (problem, NULL);\n+\t      ASSERT_EQ (problem->get_dump_location ().get_location_t (),\n+\t\t\t line_6);\n+#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n+\t      /* Verify that the problem captures the implementation location\n+\t\t it was emitted from.  */\n+\t      const dump_impl_location_t &impl_location\n+\t\t= problem->get_dump_location ().get_impl_location ();\n+\t      ASSERT_STR_CONTAINS (impl_location.m_function,\n+\t\t\t\t   \"function_that_fails\");\n+#endif\n+\n+\t      /* Verify that the underlying dump items are retained in the\n+\t\t opt_problem.  */\n+\t      const optinfo &info = problem->get_optinfo ();\n+\t      ASSERT_EQ (info.get_dump_location ().get_location_t (), line_6);\n+\t      ASSERT_EQ (info.num_items (), 4);\n+\t      ASSERT_IS_TEXT (info.get_item (0), \"can't handle return type: \");\n+\t      ASSERT_IS_TREE (info.get_item (1), UNKNOWN_LOCATION, \"int\");\n+\t      ASSERT_IS_TEXT (info.get_item (2), \" for stmt: \");\n+\t      ASSERT_IS_GIMPLE (info.get_item (3), line_6, \"return 0;\\n\");\n+\n+\t      /* ...but not in the dump_context's pending_optinfo.  */\n+\t      ASSERT_EQ (tmp.get_pending_optinfo (), NULL);\n+\n+\t      /* Simulate emitting a high-level summary message, followed\n+\t\t by the problem.  */\n+\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, stmt_at_5,\n+\t\t\t       \"can't optimize loop\\n\");\n+\t      problem->emit_and_clear ();\n+\t      ASSERT_EQ (res.get_problem (), NULL);\n+\n+\t      /* Verify that the error message was dumped (when the failure\n+\t\t occurred).  We can't use a switch here as not all of the\n+\t\t values are const expressions (using C++98).  */\n+\t      dump_flags_t effective_filter\n+\t\t= filter & (MSG_PRIORITY_INTERNALS | MSG_PRIORITY_REEMITTED);\n+\t      if (effective_filter\n+\t\t  == (MSG_PRIORITY_INTERNALS | MSG_PRIORITY_REEMITTED))\n+\t\t/* The -fopt-info-internals case.  */\n+\t\tASSERT_DUMPED_TEXT_EQ\n+\t\t  (tmp,\n+\t\t   \"test.c:6:12: note:  === function_that_indirectly_fails\"\n+\t\t   \" ===\\n\"\n+\t\t   \"test.c:6:12: note:   === function_that_fails ===\\n\"\n+\t\t   \"test.c:6:12: missed:   can't handle return type: int\"\n+\t\t   \" for stmt: return 0;\\n\"\n+\t\t   \"test.c:5:10: missed: can't optimize loop\\n\"\n+\t\t   \"test.c:6:12: missed: can't handle return type: int\"\n+\t\t   \" for stmt: return 0;\\n\");\n+\t      else if (effective_filter == MSG_PRIORITY_INTERNALS)\n+\t\t/* The default for dump files.  */\n+\t\tASSERT_DUMPED_TEXT_EQ\n+\t\t  (tmp,\n+\t\t   \"test.c:6:12: note:  === function_that_indirectly_fails\"\n+\t\t   \" ===\\n\"\n+\t\t   \"test.c:6:12: note:   === function_that_fails ===\\n\"\n+\t\t   \"test.c:6:12: missed:   can't handle return type: int\"\n+\t\t     \" for stmt: return 0;\\n\"\n+\t\t   \"test.c:5:10: missed: can't optimize loop\\n\");\n+\t      else if (effective_filter == MSG_PRIORITY_REEMITTED)\n+\t\t/* The default when -fopt-info is enabled.  */\n+\t\tASSERT_DUMPED_TEXT_EQ\n+\t\t  (tmp,\n+\t\t   \"test.c:5:10: missed: can't optimize loop\\n\"\n+\t\t   \"test.c:6:12: missed: can't handle return type: int\"\n+\t\t   \" for stmt: return 0;\\n\");\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (effective_filter == 0);\n+\t\t  ASSERT_DUMPED_TEXT_EQ\n+\t\t    (tmp,\n+\t\t     \"test.c:5:10: missed: can't optimize loop\\n\");\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* If dumping was disabled, then no problem should have been\n+\t\t created, and nothing should have been dumped.  */\n+\t      ASSERT_EQ (problem, NULL);\n+\t      ASSERT_DUMPED_TEXT_EQ (tmp, \"\");\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+opt_problem_cc_tests ()\n+{\n+  test_opt_result_success ();\n+  for_each_line_table_case (test_opt_result_failure_at);\n+}\n+\n+} // namespace selftest\n+\n+#endif /* CHECKING_P */"}, {"sha": "68d7e4a5f7b5a8ed9e62bc082255d476595dcff8", "filename": "gcc/opt-problem.h", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Fopt-problem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Fopt-problem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopt-problem.h?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -0,0 +1,289 @@\n+/* Rich information on why an optimization wasn't possible.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_OPT_PROBLEM_H\n+#define GCC_OPT_PROBLEM_H\n+\n+#include \"diagnostic-core.h\" /* for ATTRIBUTE_GCC_DIAG.  */\n+#include \"optinfo.h\" /* for optinfo.  */\n+\n+/* This header declares a family of wrapper classes for tracking a\n+   success/failure value, while optionally supporting propagating an\n+   opt_problem * describing any failure back up the call stack.\n+\n+   For instance, at the deepest point of the callstack where the failure\n+   happens, rather than:\n+\n+     if (!check_something ())\n+       {\n+         if (dump_enabled_p ())\n+           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                            \"foo is unsupported.\\n\");\n+         return false;\n+       }\n+     // [...more checks...]\n+\n+     // All checks passed:\n+     return true;\n+\n+   we can capture the cause of the failure via:\n+\n+     if (!check_something ())\n+       return opt_result::failure_at (stmt, \"foo is unsupported\");\n+     // [...more checks...]\n+\n+     // All checks passed:\n+     return opt_result::success ();\n+\n+   which effectively returns true or false, whilst recording any problem.\n+\n+   opt_result::success and opt_result::failure return opt_result values\n+   which \"looks like\" true/false respectively, via operator bool().\n+   If dump_enabled_p, then opt_result::failure also creates an opt_problem *,\n+   capturing the pertinent data (here, \"foo is unsupported \" and \"stmt\").\n+   If dumps are disabled, then opt_problem instances aren't\n+   created, and it's equivalent to just returning a bool.\n+\n+   The opt_problem can be propagated via opt_result values back up\n+   the call stack to where it makes most sense to the user.\n+   For instance, rather than:\n+\n+     bool ok = try_something_that_might_fail ();\n+     if (!ok)\n+       {\n+         if (dump_enabled_p ())\n+           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                            \"some message.\\n\");\n+         return false;\n+       }\n+\n+   we can replace the bool with an opt_result, so if dump_enabled_p, we\n+   assume that if try_something_that_might_fail, an opt_problem * will be\n+   created, and we can propagate it up the call chain:\n+\n+     opt_result ok = try_something_that_might_fail ();\n+     if (!ok)\n+       {\n+         if (dump_enabled_p ())\n+           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                            \"some message.\\n\");\n+         return ok; // propagating the opt_result\n+       }\n+\n+   opt_result is an opt_wrapper<bool>, where opt_wrapper<T> is a base\n+   class for wrapping a T, optionally propagating an opt_problem in\n+   case of failure_at (when dumps are enabled).  Similarly,\n+   opt_pointer_wrapper<T> can be used to wrap pointer types (where non-NULL\n+   signifies success, NULL signifies failure).\n+\n+   In all cases, opt_wrapper<T> acts as if the opt_problem were one of its\n+   fields, but the opt_problem is actually stored in a global, so that when\n+   compiled, an opt_wrapper<T> is effectively just a T, so that we're\n+   still just passing e.g. a bool around; the opt_wrapper<T> classes\n+   simply provide type-checking and an API to ensure that we provide\n+   error-messages deep in the callstack at the places where problems\n+   occur, and that we propagate them.  This also avoids having\n+   to manage the ownership of the opt_problem instances.\n+\n+   Using opt_result and opt_wrapper<T> documents the intent of the code\n+   for the places where we represent success values, and allows the C++ type\n+   system to track where the deepest points in the callstack are where we\n+   need to emit the failure messages from.  */\n+\n+/* A bundle of information about why an optimization failed (e.g.\n+   vectorization), and the location in both the user's code and\n+   in GCC itself where the problem occurred.\n+\n+   Instances are created by static member functions in opt_wrapper\n+   subclasses, such as opt_result::failure.\n+\n+   Instances are only created when dump_enabled_p ().  */\n+\n+class opt_problem\n+{\n+ public:\n+  static opt_problem *get_singleton () { return s_the_problem; }\n+\n+  opt_problem (const dump_location_t &loc,\n+\t       const char *fmt, va_list *ap)\n+    ATTRIBUTE_GCC_DUMP_PRINTF (3, 0);\n+\n+  const dump_location_t &\n+  get_dump_location () const { return m_optinfo.get_dump_location (); }\n+\n+  const optinfo & get_optinfo () const { return m_optinfo; }\n+\n+  void emit_and_clear ();\n+\n+ private:\n+  optinfo m_optinfo;\n+\n+  static opt_problem *s_the_problem;\n+};\n+\n+/* A base class for wrapper classes that track a success/failure value, while\n+   optionally supporting propagating an opt_problem * describing any\n+   failure back up the call stack.  */\n+\n+template <typename T>\n+class opt_wrapper\n+{\n+ public:\n+  typedef T wrapped_t;\n+\n+  /* Be accessible as the wrapped type.  */\n+  operator wrapped_t () const { return m_result; }\n+\n+  /* No public ctor.  */\n+\n+  wrapped_t get_result () const { return m_result; }\n+  opt_problem *get_problem () const { return opt_problem::get_singleton (); }\n+\n+ protected:\n+  opt_wrapper (wrapped_t result, opt_problem */*problem*/)\n+  : m_result (result)\n+  {\n+    /* \"problem\" is ignored: although it looks like a field, we\n+       actually just use the opt_problem singleton, so that\n+       opt_wrapper<T> in memory is just a T.  */\n+  }\n+\n+ private:\n+  wrapped_t m_result;\n+};\n+\n+/* Subclass of opt_wrapper<T> for bool, where\n+   - true signifies \"success\", and\n+   - false signifies \"failure\"\n+   whilst effectively propagating an opt_problem * describing any failure\n+   back up the call stack.  */\n+\n+class opt_result : public opt_wrapper <bool>\n+{\n+ public:\n+  /* Generate a \"success\" value: a wrapper around \"true\".  */\n+\n+  static opt_result success () { return opt_result (true, NULL); }\n+\n+  /* Generate a \"failure\" value: a wrapper around \"false\", and,\n+     if dump_enabled_p, an opt_problem.  */\n+\n+  static opt_result failure_at (const dump_location_t &loc,\n+\t\t\t\tconst char *fmt, ...)\n+\t  ATTRIBUTE_GCC_DUMP_PRINTF (2, 3)\n+  {\n+    opt_problem *problem = NULL;\n+    if (dump_enabled_p ())\n+      {\n+\tva_list ap;\n+\tva_start (ap, fmt);\n+\tproblem = new opt_problem (loc, fmt, &ap);\n+\tva_end (ap);\n+      }\n+    return opt_result (false, problem);\n+  }\n+\n+  /* Given a failure wrapper of some other kind, make an opt_result failure\n+     object, for propagating the opt_problem up the call stack.  */\n+\n+  template <typename S>\n+  static opt_result\n+  propagate_failure (opt_wrapper <S> other)\n+  {\n+    return opt_result (false, other.get_problem ());\n+  }\n+\n+ private:\n+  /* Private ctor.  Instances should be created by the success and failure\n+     static member functions.  */\n+  opt_result (wrapped_t result, opt_problem *problem)\n+  : opt_wrapper (result, problem)\n+  {}\n+};\n+\n+/* Subclass of opt_wrapper<T> where T is a pointer type, for tracking\n+   success/failure, where:\n+   - a non-NULL value signifies \"success\", and\n+   - a NULL value signifies \"failure\",\n+   whilst effectively propagating an opt_problem * describing any failure\n+   back up the call stack.  */\n+\n+template <typename PtrType_t>\n+class opt_pointer_wrapper : public opt_wrapper <PtrType_t>\n+{\n+ public:\n+  typedef PtrType_t wrapped_pointer_t;\n+\n+  /* Given a non-NULL pointer, make a success object wrapping it.  */\n+\n+  static opt_pointer_wrapper <wrapped_pointer_t>\n+  success (wrapped_pointer_t ptr)\n+  {\n+    return opt_pointer_wrapper <wrapped_pointer_t> (ptr, NULL);\n+  }\n+\n+  /* Make a NULL pointer failure object, with the given message\n+     (if dump_enabled_p).  */\n+\n+  static opt_pointer_wrapper <wrapped_pointer_t>\n+  failure_at (const dump_location_t &loc,\n+\t      const char *fmt, ...)\n+    ATTRIBUTE_GCC_DUMP_PRINTF (2, 3)\n+  {\n+    opt_problem *problem = NULL;\n+    if (dump_enabled_p ())\n+      {\n+\tva_list ap;\n+\tva_start (ap, fmt);\n+\tproblem = new opt_problem (loc, fmt, &ap);\n+\tva_end (ap);\n+      }\n+    return opt_pointer_wrapper <wrapped_pointer_t> (NULL, problem);\n+  }\n+\n+  /* Given a failure wrapper of some other kind, make a NULL pointer\n+     failure object, propagating the problem.  */\n+\n+  template <typename S>\n+  static opt_pointer_wrapper <wrapped_pointer_t>\n+  propagate_failure (opt_wrapper <S> other)\n+  {\n+    return opt_pointer_wrapper <wrapped_pointer_t> (NULL,\n+\t\t\t\t\t\t    other.get_problem ());\n+  }\n+\n+  /* Support accessing the underlying pointer via ->.  */\n+\n+  wrapped_pointer_t operator-> () const { return this->get_result (); }\n+\n+ private:\n+  /* Private ctor.  Instances should be built using the static member\n+     functions \"success\" and \"failure\".  */\n+  opt_pointer_wrapper (wrapped_pointer_t result, opt_problem *problem)\n+  : opt_wrapper<PtrType_t> (result, problem)\n+  {}\n+};\n+\n+/* A typedef for wrapping \"tree\" so that NULL_TREE can carry an\n+   opt_problem describing the failure (if dump_enabled_p).  */\n+\n+typedef opt_pointer_wrapper<tree> opt_tree;\n+\n+#endif /* #ifndef GCC_OPT_PROBLEM_H */"}, {"sha": "31029ad8479f96142fabc2db5c5d63b05b653a1b", "filename": "gcc/optinfo-emit-json.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Foptinfo-emit-json.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Foptinfo-emit-json.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo-emit-json.cc?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -531,7 +531,7 @@ namespace selftest {\n static void\n test_building_json_from_dump_calls ()\n {\n-  temp_dump_context tmp (true, MSG_NOTE);\n+  temp_dump_context tmp (true, true, MSG_NOTE);\n   dump_location_t loc;\n   dump_printf_loc (MSG_NOTE, loc, \"test of tree: \");\n   dump_generic_expr (MSG_NOTE, TDF_SLIM, integer_zero_node);"}, {"sha": "de781a52125f59dead2fb43ef94b4f1b2b109ea0", "filename": "gcc/optinfo.cc", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Foptinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Foptinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo.cc?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -89,11 +89,51 @@ optinfo::add_item (optinfo_item *item)\n   m_items.safe_push (item);\n }\n \n+/* Get MSG_* flags corresponding to KIND.  */\n+\n+static dump_flags_t\n+optinfo_kind_to_dump_flag (enum optinfo_kind kind)\n+{\n+  switch (kind)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case OPTINFO_KIND_SUCCESS:\n+      return MSG_OPTIMIZED_LOCATIONS;\n+    case OPTINFO_KIND_FAILURE:\n+      return MSG_MISSED_OPTIMIZATION;\n+    case OPTINFO_KIND_NOTE:\n+    case OPTINFO_KIND_SCOPE:\n+      return MSG_NOTE;\n+    }\n+}\n+\n+/* Re-emit this optinfo, both to the \"non-immediate\" destinations,\n+   *and* to the \"immediate\" destinations.  */\n+\n+void\n+optinfo::emit_for_opt_problem () const\n+{\n+  dump_flags_t dump_kind = optinfo_kind_to_dump_flag (get_kind ());\n+  dump_kind |= MSG_PRIORITY_REEMITTED;\n+\n+  /* Re-emit to \"immediate\" destinations, without creating a new optinfo.  */\n+  dump_context::get ().dump_loc_immediate (dump_kind, get_dump_location ());\n+  unsigned i;\n+  optinfo_item *item;\n+  FOR_EACH_VEC_ELT (m_items, i, item)\n+    dump_context::get ().emit_item (item, dump_kind);\n+\n+  /* Re-emit to \"non-immediate\" destinations.  */\n+  emit ();\n+}\n+\n /* Emit the optinfo to all of the \"non-immediate\" destinations\n-   (emission to \"immediate\" destinations is done by emit_item).  */\n+   (emission to \"immediate\" destinations is done by\n+   dump_context::emit_item).  */\n \n void\n-optinfo::emit ()\n+optinfo::emit () const\n {\n   /* -fsave-optimization-record.  */\n   optimization_records_maybe_record_optinfo (this);"}, {"sha": "99bd22c7538cc10b8fedce31b55359c43a8fe943", "filename": "gcc/optinfo.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Foptinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Foptinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo.h?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -108,6 +108,9 @@ class optinfo\n   {}\n   ~optinfo ();\n \n+  const dump_location_t &\n+  get_dump_location () const { return m_loc; }\n+\n   const dump_user_location_t &\n   get_user_location () const { return m_loc.get_user_location (); }\n \n@@ -124,8 +127,10 @@ class optinfo\n \n   void add_item (optinfo_item *item);\n \n+  void emit_for_opt_problem () const;\n+\n  private:\n-  void emit ();\n+  void emit () const;\n \n   /* Pre-canned ways of manipulating the optinfo, for use by friend class\n      dump_context.  */"}, {"sha": "562ada74a5f50d6ec6b11904017957a0281cffac", "filename": "gcc/selftest-run-tests.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -74,6 +74,7 @@ selftest::run_tests ()\n   opt_proposer_c_tests ();\n   json_cc_tests ();\n   optinfo_emit_json_cc_tests ();\n+  opt_problem_cc_tests ();\n \n   /* Mid-level data structures.  */\n   input_c_tests ();"}, {"sha": "8da7c4ae1c0f3f897ca2c97951957e9ac39744e9", "filename": "gcc/selftest.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -229,6 +229,7 @@ extern void hash_map_tests_c_tests ();\n extern void hash_set_tests_c_tests ();\n extern void input_c_tests ();\n extern void json_cc_tests ();\n+extern void opt_problem_cc_tests ();\n extern void optinfo_emit_json_cc_tests ();\n extern void predict_c_tests ();\n extern void pretty_print_c_tests ();"}, {"sha": "d3eb299132d58657a78a041e990c4e614fcef376", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -1,3 +1,11 @@\n+2018-10-04  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/vect/nodump-vect-opt-info-2.c: New test.\n+\t* gcc.dg/vect/vect-alias-check-4.c: Add \"-fopt-info-vec-all\" to\n+\tdg-additional-options.  Add dg-message and dg-missed directives\n+\tto verify that -fopt-info messages are written at the correct\n+\tlocations.\n+\n 2018-10-04  David Malcolm  <dmalcolm@redhat.com>\n \n \t* gcc.dg/plugin/dump-1.c: Update expected output for test_scopes"}, {"sha": "94c55a92bb4fdec09d74aa92d978474d5284a71f", "filename": "gcc/testsuite/gcc.dg/vect/nodump-vect-opt-info-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fnodump-vect-opt-info-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fnodump-vect-opt-info-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fnodump-vect-opt-info-2.c?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile { target vect_int } } */\n+/* { dg-additional-options \"-fopt-info-vec-all -O3\" } */\n+\n+extern void accumulate (int x, int *a);\n+\n+int test_missing_function_defn (int *arr, int n) /* { dg-message \"vectorized 0 loops in function\" } */\n+{\n+  int sum = 0;\n+  for (int i = 0; i < n; ++i) /* { dg-missed \"couldn't vectorize loop\" } */\n+    accumulate (arr[i], &sum); /* { dg-missed \"statement clobbers memory: accumulate \\\\(.*\\\\);\" } */\n+  return sum;\n+}"}, {"sha": "750193e3cd43b178df28c97eb385af88fd1f9e1d", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-4.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-4.c?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target vect_int } */\n-/* { dg-additional-options \"--param vect-max-version-for-alias-checks=0\" } */\n+/* { dg-additional-options \"--param vect-max-version-for-alias-checks=0 -fopt-info-vec-all\" } */\n \n #define N 16\n \n@@ -12,24 +12,26 @@ union u { struct s2 f; struct s3 g; };\n /* We allow a and b to overlap arbitrarily.  */\n \n void\n-f1 (int a[][N], int b[][N])\n+f1 (int a[][N], int b[][N]) /* { dg-message \"vectorized 0 loops in function\" } */\n {\n-  for (int i = 0; i < N; ++i)\n+  for (int i = 0; i < N; ++i) /* { dg-missed \"couldn't vectorize loop\" } */\n     a[0][i] += b[0][i];\n+  /* { dg-message \"will not create alias checks, as --param vect-max-version-for-alias-checks == 0\" \"\" { target *-*-* } .-2 } */\n }\n \n void\n-f2 (union u *a, union u *b)\n+f2 (union u *a, union u *b) /* { dg-message \"vectorized 0 loops in function\" } */\n {\n-  for (int i = 0; i < N; ++i)\n+  for (int i = 0; i < N; ++i) /* { dg-missed \"couldn't vectorize loop\" } */\n     a->f.b.a[i] += b->g.e.a[i];\n+  /* { dg-message \"will not create alias checks, as --param vect-max-version-for-alias-checks == 0\" \"\" { target *-*-* } .-2 } */\n }\n \n void\n-f3 (struct s1 *a, struct s1 *b)\n+f3 (struct s1 *a, struct s1 *b) /* { dg-message \"vectorized 0 loops in function\" } */\n {\n-  for (int i = 0; i < N - 1; ++i)\n-    a->a[i + 1] += b->a[i];\n+  for (int i = 0; i < N - 1; ++i) /* { dg-missed \"couldn't vectorize loop\" } */\n+    a->a[i + 1] += b->a[i]; /* { dg-missed \"possible dependence between data-refs\" } */\n }\n \n /* { dg-final { scan-tree-dump-not \"LOOP VECTORIZED\" \"vect\" } } */"}, {"sha": "69c5f7b28ae22be67864927cc8f1e179b7c89113", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 26, "deletions": 44, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -807,7 +807,8 @@ canonicalize_base_object_address (tree addr)\n   return build_fold_addr_expr (TREE_OPERAND (addr, 0));\n }\n \n-/* Analyze the behavior of memory reference REF.  There are two modes:\n+/* Analyze the behavior of memory reference REF within STMT.\n+   There are two modes:\n \n    - BB analysis.  In this case we simply split the address into base,\n      init and offset components, without reference to any containing loop.\n@@ -827,9 +828,9 @@ canonicalize_base_object_address (tree addr)\n    Return true if the analysis succeeded and store the results in DRB if so.\n    BB analysis can only fail for bitfield or reversed-storage accesses.  */\n \n-bool\n+opt_result\n dr_analyze_innermost (innermost_loop_behavior *drb, tree ref,\n-\t\t      struct loop *loop)\n+\t\t      struct loop *loop, const gimple *stmt)\n {\n   poly_int64 pbitsize, pbitpos;\n   tree base, poffset;\n@@ -848,18 +849,12 @@ dr_analyze_innermost (innermost_loop_behavior *drb, tree ref,\n \n   poly_int64 pbytepos;\n   if (!multiple_p (pbitpos, BITS_PER_UNIT, &pbytepos))\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"failed: bit offset alignment.\\n\");\n-      return false;\n-    }\n+    return opt_result::failure_at (stmt,\n+\t\t\t\t   \"failed: bit offset alignment.\\n\");\n \n   if (preversep)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"failed: reverse storage order.\\n\");\n-      return false;\n-    }\n+    return opt_result::failure_at (stmt,\n+\t\t\t\t   \"failed: reverse storage order.\\n\");\n \n   /* Calculate the alignment and misalignment for the inner reference.  */\n   unsigned int HOST_WIDE_INT bit_base_misalignment;\n@@ -895,11 +890,8 @@ dr_analyze_innermost (innermost_loop_behavior *drb, tree ref,\n   if (in_loop)\n     {\n       if (!simple_iv (loop, loop, base, &base_iv, true))\n-        {\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"failed: evolution of base is not affine.\\n\");\n-\t  return false;\n-        }\n+\treturn opt_result::failure_at\n+\t  (stmt, \"failed: evolution of base is not affine.\\n\");\n     }\n   else\n     {\n@@ -921,11 +913,8 @@ dr_analyze_innermost (innermost_loop_behavior *drb, tree ref,\n           offset_iv.step = ssize_int (0);\n         }\n       else if (!simple_iv (loop, loop, poffset, &offset_iv, true))\n-        {\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"failed: evolution of offset is not affine.\\n\");\n-\t  return false;\n-        }\n+\treturn opt_result::failure_at\n+\t  (stmt, \"failed: evolution of offset is not affine.\\n\");\n     }\n \n   init = ssize_int (pbytepos);\n@@ -981,7 +970,7 @@ dr_analyze_innermost (innermost_loop_behavior *drb, tree ref,\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"success.\\n\");\n \n-  return true;\n+  return opt_result::success ();\n }\n \n /* Return true if OP is a valid component reference for a DR access\n@@ -1205,7 +1194,7 @@ create_data_ref (edge nest, loop_p loop, tree memref, gimple *stmt,\n   DR_IS_CONDITIONAL_IN_STMT (dr) = is_conditional_in_stmt;\n \n   dr_analyze_innermost (&DR_INNERMOST (dr), memref,\n-\t\t\tnest != NULL ? loop : NULL);\n+\t\t\tnest != NULL ? loop : NULL, stmt);\n   dr_analyze_indices (dr, nest, loop);\n   dr_analyze_alias (dr);\n \n@@ -1318,7 +1307,7 @@ data_ref_compare_tree (tree t1, tree t2)\n /* Return TRUE it's possible to resolve data dependence DDR by runtime alias\n    check.  */\n \n-bool\n+opt_result\n runtime_alias_check_p (ddr_p ddr, struct loop *loop, bool speed_p)\n {\n   if (dump_enabled_p ())\n@@ -1327,25 +1316,18 @@ runtime_alias_check_p (ddr_p ddr, struct loop *loop, bool speed_p)\n \t\t DR_REF (DDR_A (ddr)), DR_REF (DDR_B (ddr)));\n \n   if (!speed_p)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf (MSG_MISSED_OPTIMIZATION,\n-\t\t     \"runtime alias check not supported when optimizing \"\n-\t\t     \"for size.\\n\");\n-      return false;\n-    }\n+    return opt_result::failure_at (DR_STMT (DDR_A (ddr)),\n+\t\t\t\t   \"runtime alias check not supported when\"\n+\t\t\t\t   \" optimizing for size.\\n\");\n \n   /* FORNOW: We don't support versioning with outer-loop in either\n      vectorization or loop distribution.  */\n   if (loop != NULL && loop->inner != NULL)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf (MSG_MISSED_OPTIMIZATION,\n-\t\t     \"runtime alias check not supported for outer loop.\\n\");\n-      return false;\n-    }\n+    return opt_result::failure_at (DR_STMT (DDR_A (ddr)),\n+\t\t\t\t   \"runtime alias check not supported for\"\n+\t\t\t\t   \" outer loop.\\n\");\n \n-  return true;\n+  return opt_result::success ();\n }\n \n /* Operator == between two dr_with_seg_len objects.\n@@ -5043,18 +5025,18 @@ loop_nest_has_data_refs (loop_p loop)\n    reference, returns false, otherwise returns true.  NEST is the outermost\n    loop of the loop nest in which the references should be analyzed.  */\n \n-bool\n+opt_result\n find_data_references_in_stmt (struct loop *nest, gimple *stmt,\n \t\t\t      vec<data_reference_p> *datarefs)\n {\n   unsigned i;\n   auto_vec<data_ref_loc, 2> references;\n   data_ref_loc *ref;\n-  bool ret = true;\n   data_reference_p dr;\n \n   if (get_references_in_stmt (stmt, &references))\n-    return false;\n+    return opt_result::failure_at (stmt, \"statement clobbers memory: %G\",\n+\t\t\t\t   stmt);\n \n   FOR_EACH_VEC_ELT (references, i, ref)\n     {\n@@ -5065,7 +5047,7 @@ find_data_references_in_stmt (struct loop *nest, gimple *stmt,\n       datarefs->safe_push (dr);\n     }\n \n-  return ret;\n+  return opt_result::success ();\n }\n \n /* Stores the data references in STMT to DATAREFS.  If there is an"}, {"sha": "525d27f04b96eb84910ac281a2474dcdcd7f4820", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"graphds.h\"\n #include \"tree-chrec.h\"\n+#include \"opt-problem.h\"\n \n /*\n   innermost_loop_behavior describes the evolution of the address of the memory\n@@ -421,7 +422,8 @@ typedef struct data_dependence_relation *ddr_p;\n #define DDR_COULD_BE_INDEPENDENT_P(DDR) (DDR)->could_be_independent_p\n \n \f\n-bool dr_analyze_innermost (innermost_loop_behavior *, tree, struct loop *);\n+opt_result dr_analyze_innermost (innermost_loop_behavior *, tree,\n+\t\t\t\t struct loop *, const gimple *);\n extern bool compute_data_dependences_for_loop (struct loop *, bool,\n \t\t\t\t\t       vec<loop_p> *,\n \t\t\t\t\t       vec<data_reference_p> *,\n@@ -443,8 +445,8 @@ extern void free_dependence_relation (struct data_dependence_relation *);\n extern void free_dependence_relations (vec<ddr_p> );\n extern void free_data_ref (data_reference_p);\n extern void free_data_refs (vec<data_reference_p> );\n-extern bool find_data_references_in_stmt (struct loop *, gimple *,\n-\t\t\t\t\t  vec<data_reference_p> *);\n+extern opt_result find_data_references_in_stmt (struct loop *, gimple *,\n+\t\t\t\t\t\tvec<data_reference_p> *);\n extern bool graphite_find_data_references_in_stmt (edge, loop_p, gimple *,\n \t\t\t\t\t\t   vec<data_reference_p> *);\n tree find_data_references_in_loop (struct loop *, vec<data_reference_p> *);\n@@ -479,7 +481,7 @@ extern bool dr_may_alias_p (const struct data_reference *,\n extern bool dr_equal_offsets_p (struct data_reference *,\n                                 struct data_reference *);\n \n-extern bool runtime_alias_check_p (ddr_p, struct loop *, bool);\n+extern opt_result runtime_alias_check_p (ddr_p, struct loop *, bool);\n extern int data_ref_compare_tree (tree, tree);\n extern void prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *,\n \t\t\t\t\t   poly_uint64);"}, {"sha": "1711027bdf709613f18151574053d399ff139c4e", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -1280,7 +1280,8 @@ find_looparound_phi (struct loop *loop, dref ref, dref root)\n   memset (&init_dr, 0, sizeof (struct data_reference));\n   DR_REF (&init_dr) = init_ref;\n   DR_STMT (&init_dr) = phi;\n-  if (!dr_analyze_innermost (&DR_INNERMOST (&init_dr), init_ref, loop))\n+  if (!dr_analyze_innermost (&DR_INNERMOST (&init_dr), init_ref, loop,\n+\t\t\t     init_stmt))\n     return NULL;\n \n   if (!valid_initializer_p (&init_dr, ref->distance + 1, root->ref))"}, {"sha": "c4805e724474f5870420f0ea43b552bacf30027b", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 155, "deletions": 192, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -156,20 +156,25 @@ vect_get_smallest_scalar_type (stmt_vec_info stmt_info,\n    tested at run-time.  Return TRUE if DDR was successfully inserted.\n    Return false if versioning is not supported.  */\n \n-static bool\n+static opt_result\n vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   if ((unsigned) PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS) == 0)\n-    return false;\n+    return opt_result::failure_at (vect_location,\n+\t\t\t\t   \"will not create alias checks, as\"\n+\t\t\t\t   \" --param vect-max-version-for-alias-checks\"\n+\t\t\t\t   \" == 0\\n\");\n \n-  if (!runtime_alias_check_p (ddr, loop,\n-\t\t\t      optimize_loop_nest_for_speed_p (loop)))\n-    return false;\n+  opt_result res\n+    = runtime_alias_check_p (ddr, loop,\n+\t\t\t     optimize_loop_nest_for_speed_p (loop));\n+  if (!res)\n+    return res;\n \n   LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo).safe_push (ddr);\n-  return true;\n+  return opt_result::success ();\n }\n \n /* Record that loop LOOP_VINFO needs to check that VALUE is nonzero.  */\n@@ -277,12 +282,14 @@ vect_analyze_possibly_independent_ddr (data_dependence_relation *ddr,\n \n /* Function vect_analyze_data_ref_dependence.\n \n-   Return TRUE if there (might) exist a dependence between a memory-reference\n+   FIXME: I needed to change the sense of the returned flag.\n+\n+   Return FALSE if there (might) exist a dependence between a memory-reference\n    DRA and a memory-reference DRB.  When versioning for alias may check a\n-   dependence at run-time, return FALSE.  Adjust *MAX_VF according to\n+   dependence at run-time, return TRUE.  Adjust *MAX_VF according to\n    the data dependence.  */\n \n-static bool\n+static opt_result\n vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t\t\t\t  loop_vec_info loop_vinfo,\n \t\t\t\t  unsigned int *max_vf)\n@@ -305,11 +312,11 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \n   /* Independent data accesses.  */\n   if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n-    return false;\n+    return opt_result::success ();\n \n   if (dra == drb\n       || (DR_IS_READ (dra) && DR_IS_READ (drb)))\n-    return false;\n+    return opt_result::success ();\n \n   /* We do not have to consider dependences between accesses that belong\n      to the same group, unless the stride could be smaller than the\n@@ -318,7 +325,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n       && (DR_GROUP_FIRST_ELEMENT (stmtinfo_a)\n \t  == DR_GROUP_FIRST_ELEMENT (stmtinfo_b))\n       && !STMT_VINFO_STRIDED_P (stmtinfo_a))\n-    return false;\n+    return opt_result::success ();\n \n   /* Even if we have an anti-dependence then, as the vectorized loop covers at\n      least two scalar iterations, there is always also a true dependence.\n@@ -330,7 +337,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n        || (DR_IS_WRITE (dra) && DR_IS_READ (drb)))\n       && !alias_sets_conflict_p (get_alias_set (DR_REF (dra)),\n \t\t\t\t get_alias_set (DR_REF (drb))))\n-    return false;\n+    return opt_result::success ();\n \n   /* Unknown data dependence.  */\n   if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n@@ -342,28 +349,25 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t  if ((unsigned int) loop->safelen < *max_vf)\n \t    *max_vf = loop->safelen;\n \t  LOOP_VINFO_NO_DATA_DEPENDENCIES (loop_vinfo) = false;\n-\t  return false;\n+\t  return opt_result::success ();\n \t}\n \n       if (STMT_VINFO_GATHER_SCATTER_P (stmtinfo_a)\n \t  || STMT_VINFO_GATHER_SCATTER_P (stmtinfo_b))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"versioning for alias not supported for: \"\n-\t\t\t     \"can't determine dependence between %T and %T\\n\",\n-\t\t\t     DR_REF (dra), DR_REF (drb));\n-\t  return true;\n-\t}\n+\treturn opt_result::failure_at\n+\t  (stmtinfo_a->stmt,\n+\t   \"versioning for alias not supported for: \"\n+\t   \"can't determine dependence between %T and %T\\n\",\n+\t   DR_REF (dra), DR_REF (drb));\n \n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, stmtinfo_a->stmt,\n \t\t\t \"versioning for alias required: \"\n \t\t\t \"can't determine dependence between %T and %T\\n\",\n \t\t\t DR_REF (dra), DR_REF (drb));\n \n       /* Add to list of ddrs that need to be tested at run-time.  */\n-      return !vect_mark_for_runtime_alias_test (ddr, loop_vinfo);\n+      return vect_mark_for_runtime_alias_test (ddr, loop_vinfo);\n     }\n \n   /* Known data dependence.  */\n@@ -376,35 +380,32 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t  if ((unsigned int) loop->safelen < *max_vf)\n \t    *max_vf = loop->safelen;\n \t  LOOP_VINFO_NO_DATA_DEPENDENCIES (loop_vinfo) = false;\n-\t  return false;\n+\t  return opt_result::success ();\n \t}\n \n       if (STMT_VINFO_GATHER_SCATTER_P (stmtinfo_a)\n \t  || STMT_VINFO_GATHER_SCATTER_P (stmtinfo_b))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"versioning for alias not supported for: \"\n-\t\t\t     \"bad dist vector for %T and %T\\n\",\n-\t\t\t     DR_REF (dra), DR_REF (drb));\n-\t  return true;\n-\t}\n+\treturn opt_result::failure_at\n+\t  (stmtinfo_a->stmt,\n+\t   \"versioning for alias not supported for: \"\n+\t   \"bad dist vector for %T and %T\\n\",\n+\t   DR_REF (dra), DR_REF (drb));\n \n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, stmtinfo_a->stmt,\n \t\t\t \"versioning for alias required: \"\n \t\t\t \"bad dist vector for %T and %T\\n\",\n \t\t\t DR_REF (dra), DR_REF (drb));\n       /* Add to list of ddrs that need to be tested at run-time.  */\n-      return !vect_mark_for_runtime_alias_test (ddr, loop_vinfo);\n+      return vect_mark_for_runtime_alias_test (ddr, loop_vinfo);\n     }\n \n   loop_depth = index_in_loop_nest (loop->num, DDR_LOOP_NEST (ddr));\n \n   if (DDR_COULD_BE_INDEPENDENT_P (ddr)\n       && vect_analyze_possibly_independent_ddr (ddr, loop_vinfo,\n \t\t\t\t\t\tloop_depth, max_vf))\n-    return false;\n+    return opt_result::success ();\n \n   FOR_EACH_VEC_ELT (DDR_DIST_VECTS (ddr), i, dist_v)\n     {\n@@ -440,23 +441,16 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t\ta[i+1] = ...;\n \t     where loads from the group interleave with the store.  */\n \t  if (!vect_preserves_scalar_order_p (dr_info_a, dr_info_b))\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"READ_WRITE dependence in interleaving.\\n\");\n-\t      return true;\n-\t    }\n+\t    return opt_result::failure_at (stmtinfo_a->stmt,\n+\t\t\t\t\t   \"READ_WRITE dependence\"\n+\t\t\t\t\t   \" in interleaving.\\n\");\n \n \t  if (loop->safelen < 2)\n \t    {\n \t      tree indicator = dr_zero_step_indicator (dra);\n \t      if (!indicator || integer_zerop (indicator))\n-\t\t{\n-\t\t  if (dump_enabled_p ())\n-\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"access also has a zero step\\n\");\n-\t\t  return true;\n-\t\t}\n+\t\treturn opt_result::failure_at (stmtinfo_a->stmt,\n+\t\t\t\t\t       \"access also has a zero step\\n\");\n \t      else if (TREE_CODE (indicator) != INTEGER_CST)\n \t\tvect_check_nonzero_value (loop_vinfo, indicator);\n \t    }\n@@ -503,16 +497,13 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t  continue;\n \t}\n \n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized, possible dependence \"\n-\t\t\t \"between data-refs %T and %T\\n\",\n-\t\t\t DR_REF (dra), DR_REF (drb));\n-\n-      return true;\n+      return opt_result::failure_at (stmtinfo_a->stmt,\n+\t\t\t\t     \"not vectorized, possible dependence \"\n+\t\t\t\t     \"between data-refs %T and %T\\n\",\n+\t\t\t\t     DR_REF (dra), DR_REF (drb));\n     }\n \n-  return false;\n+  return opt_result::success ();\n }\n \n /* Function vect_analyze_data_ref_dependences.\n@@ -521,7 +512,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n    exist any data dependences between them.  Set *MAX_VF according to\n    the maximum vectorization factor the data dependences allow.  */\n \n-bool\n+opt_result\n vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo,\n \t\t\t\t   unsigned int *max_vf)\n {\n@@ -553,10 +544,14 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo,\n     *max_vf = LOOP_VINFO_ORIG_MAX_VECT_FACTOR (loop_vinfo);\n   else\n     FOR_EACH_VEC_ELT (LOOP_VINFO_DDRS (loop_vinfo), i, ddr)\n-      if (vect_analyze_data_ref_dependence (ddr, loop_vinfo, max_vf))\n-\treturn false;\n+      {\n+\topt_result res\n+\t  = vect_analyze_data_ref_dependence (ddr, loop_vinfo, max_vf);\n+\tif (!res)\n+\t  return res;\n+      }\n \n-  return true;\n+  return opt_result::success ();\n }\n \n \n@@ -1055,41 +1050,32 @@ vect_update_misalignment_for_peel (dr_vec_info *dr_info,\n \n    Return TRUE if DR_INFO can be handled with respect to alignment.  */\n \n-static bool\n+static opt_result\n verify_data_ref_alignment (dr_vec_info *dr_info)\n {\n   enum dr_alignment_support supportable_dr_alignment\n     = vect_supportable_dr_alignment (dr_info, false);\n   if (!supportable_dr_alignment)\n-    {\n-      if (dump_enabled_p ())\n-\t{\n-\t  if (DR_IS_READ (dr_info->dr))\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: unsupported unaligned load.\");\n-\t  else\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: unsupported unaligned \"\n-\t\t\t     \"store.\");\n-\n-\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"%T\\n\", DR_REF (dr_info->dr));\n-\t}\n-      return false;\n-    }\n+    return opt_result::failure_at\n+      (dr_info->stmt->stmt,\n+       DR_IS_READ (dr_info->dr)\n+\t? \"not vectorized: unsupported unaligned load: %T\\n\"\n+\t: \"not vectorized: unsupported unaligned store: %T\\n\",\n+       DR_REF (dr_info->dr));\n \n   if (supportable_dr_alignment != dr_aligned && dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"Vectorizing an unaligned access.\\n\");\n \n-  return true;\n+  return opt_result::success ();\n }\n \n /* Function vect_verify_datarefs_alignment\n \n    Return TRUE if all data references in the loop can be\n    handled with respect to alignment.  */\n \n-bool\n+opt_result\n vect_verify_datarefs_alignment (loop_vec_info vinfo)\n {\n   vec<data_reference_p> datarefs = vinfo->shared->datarefs;\n@@ -1115,11 +1101,12 @@ vect_verify_datarefs_alignment (loop_vec_info vinfo)\n \t  && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n \tcontinue;\n \n-      if (! verify_data_ref_alignment (dr_info))\n-\treturn false;\n+      opt_result res = verify_data_ref_alignment (dr_info);\n+      if (!res)\n+\treturn res;\n     }\n \n-  return true;\n+  return opt_result::success ();\n }\n \n /* Given an memory reference EXP return whether its alignment is less\n@@ -1593,7 +1580,7 @@ vect_peeling_supportable (loop_vec_info loop_vinfo, dr_vec_info *dr0_info,\n      (whether to generate regular loads/stores, or with special handling for\n      misalignment).  */\n \n-bool\n+opt_result\n vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n   vec<data_reference_p> datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n@@ -1605,7 +1592,6 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   unsigned int i, j;\n   bool do_peeling = false;\n   bool do_versioning = false;\n-  bool stat;\n   unsigned int npeel = 0;\n   bool one_misalignment_known = false;\n   bool one_misalignment_unknown = false;\n@@ -1992,7 +1978,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       /* Check if all datarefs are supportable and log.  */\n       if (do_peeling && known_alignment_for_access_p (dr0_info) && npeel == 0)\n         {\n-          stat = vect_verify_datarefs_alignment (loop_vinfo);\n+          opt_result stat = vect_verify_datarefs_alignment (loop_vinfo);\n           if (!stat)\n             do_peeling = false;\n           else\n@@ -2078,7 +2064,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  /* The inside-loop cost will be accounted for in vectorizable_load\n \t     and vectorizable_store correctly with adjusted alignments.\n \t     Drop the body_cst_vec on the floor here.  */\n-\t  stat = vect_verify_datarefs_alignment (loop_vinfo);\n+\t  opt_result stat = vect_verify_datarefs_alignment (loop_vinfo);\n \t  gcc_assert (stat);\n           return stat;\n         }\n@@ -2201,15 +2187,15 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       /* Peeling and versioning can't be done together at this time.  */\n       gcc_assert (! (do_peeling && do_versioning));\n \n-      stat = vect_verify_datarefs_alignment (loop_vinfo);\n+      opt_result stat = vect_verify_datarefs_alignment (loop_vinfo);\n       gcc_assert (stat);\n       return stat;\n     }\n \n   /* This point is reached if neither peeling nor versioning is being done.  */\n   gcc_assert (! (do_peeling || do_versioning));\n \n-  stat = vect_verify_datarefs_alignment (loop_vinfo);\n+  opt_result stat = vect_verify_datarefs_alignment (loop_vinfo);\n   return stat;\n }\n \n@@ -2275,7 +2261,7 @@ vect_find_same_alignment_drs (vec_info *vinfo, data_dependence_relation *ddr)\n    Analyze the alignment of the data-references in the loop.\n    Return FALSE if a data reference is found that cannot be vectorized.  */\n \n-bool\n+opt_result\n vect_analyze_data_refs_alignment (loop_vec_info vinfo)\n {\n   DUMP_VECT_SCOPE (\"vect_analyze_data_refs_alignment\");\n@@ -2300,7 +2286,7 @@ vect_analyze_data_refs_alignment (loop_vec_info vinfo)\n \tvect_compute_data_ref_alignment (dr_info);\n     }\n \n-  return true;\n+  return opt_result::success ();\n }\n \n \n@@ -2825,7 +2811,7 @@ can_group_stmts_p (stmt_vec_info stmt1_info, stmt_vec_info stmt2_info)\n \n    FORNOW: handle only arrays and pointer accesses.  */\n \n-bool\n+opt_result\n vect_analyze_data_ref_accesses (vec_info *vinfo)\n {\n   unsigned int i;\n@@ -2835,7 +2821,7 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n   DUMP_VECT_SCOPE (\"vect_analyze_data_ref_accesses\");\n \n   if (datarefs.is_empty ())\n-    return true;\n+    return opt_result::success ();\n \n   /* Sort the array of datarefs to make building the interleaving chains\n      linear.  Don't modify the original vector's order, it is needed for\n@@ -2994,13 +2980,15 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \t  else\n \t    {\n \t      datarefs_copy.release ();\n-\t      return false;\n+\t      return opt_result::failure_at (dr_info->stmt->stmt,\n+\t\t\t\t\t     \"not vectorized:\"\n+\t\t\t\t\t     \" complicated access pattern.\\n\");\n \t    }\n \t}\n     }\n \n   datarefs_copy.release ();\n-  return true;\n+  return opt_result::success ();\n }\n \n /* Function vect_vfa_segment_size.\n@@ -3258,7 +3246,7 @@ vectorizable_with_step_bound_p (dr_vec_info *dr_info_a, dr_vec_info *dr_info_b,\n    Return FALSE if resulting list of ddrs is longer then allowed by\n    PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS, otherwise return TRUE.  */\n \n-bool\n+opt_result\n vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n {\n   typedef pair_hash <tree_operand_hash, tree_operand_hash> tree_pair_hash;\n@@ -3292,7 +3280,7 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n     }\n \n   if (may_alias_ddrs.is_empty ())\n-    return true;\n+    return opt_result::success ();\n \n   comp_alias_ddrs.create (may_alias_ddrs.length ());\n \n@@ -3452,12 +3440,11 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t    continue;\n \n \t  if (res == 1)\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t \"not vectorized: compilation time alias.\\n\");\n-\t      return false;\n-\t    }\n+\t    return opt_result::failure_at (stmt_info_b->stmt,\n+\t\t\t\t\t   \"not vectorized:\"\n+\t\t\t\t\t   \" compilation time alias: %G%G\",\n+\t\t\t\t\t   stmt_info_a->stmt,\n+\t\t\t\t\t   stmt_info_b->stmt);\n \t}\n \n       dr_with_seg_len_pair_t dr_with_seg_len_pair\n@@ -3482,17 +3469,14 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t\t   \"improved number of alias checks from %d to %d\\n\",\n \t\t   may_alias_ddrs.length (), count);\n   if ((int) count > PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"number of versioning for alias \"\n-\t\t\t \"run-time tests exceeds %d \"\n-\t\t\t \"(--param vect-max-version-for-alias-checks)\\n\",\n-\t\t\t PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS));\n-      return false;\n-    }\n-\n-  return true;\n+    return opt_result::failure_at\n+      (vect_location,\n+       \"number of versioning for alias \"\n+       \"run-time tests exceeds %d \"\n+       \"(--param vect-max-version-for-alias-checks)\\n\",\n+       PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS));\n+\n+  return opt_result::success ();\n }\n \n /* Check whether we can use an internal function for a gather load\n@@ -3846,80 +3830,58 @@ vect_check_gather_scatter (stmt_vec_info stmt_info, loop_vec_info loop_vinfo,\n    append them to DATAREFS.  Return false if datarefs in this stmt cannot\n    be handled.  */\n \n-bool\n+opt_result\n vect_find_stmt_data_reference (loop_p loop, gimple *stmt,\n \t\t\t       vec<data_reference_p> *datarefs)\n {\n   /* We can ignore clobbers for dataref analysis - they are removed during\n      loop vectorization and BB vectorization checks dependences with a\n      stmt walk.  */\n   if (gimple_clobber_p (stmt))\n-    return true;\n+    return opt_result::success ();\n \n   if (gimple_has_volatile_ops (stmt))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: volatile type %G\", stmt);\n-      return false;\n-    }\n+    return opt_result::failure_at (stmt, \"not vectorized: volatile type: %G\",\n+\t\t\t\t   stmt);\n \n   if (stmt_can_throw_internal (stmt))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: statement can throw an exception %G\",\n-\t\t\t stmt);\n-      return false;\n-    }\n+    return opt_result::failure_at (stmt,\n+\t\t\t\t   \"not vectorized:\"\n+\t\t\t\t   \" statement can throw an exception: %G\",\n+\t\t\t\t   stmt);\n \n   auto_vec<data_reference_p, 2> refs;\n-  if (!find_data_references_in_stmt (loop, stmt, &refs))\n-    return false;\n+  opt_result res = find_data_references_in_stmt (loop, stmt, &refs);\n+  if (!res)\n+    return res;\n \n   if (refs.is_empty ())\n-    return true;\n+    return opt_result::success ();\n \n   if (refs.length () > 1)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: more than one data ref \"\n-\t\t\t \"in stmt: %G\", stmt);\n-      return false;\n-    }\n+    return opt_result::failure_at (stmt,\n+\t\t\t\t   \"not vectorized:\"\n+\t\t\t\t   \" more than one data ref in stmt: %G\", stmt);\n \n   if (gcall *call = dyn_cast <gcall *> (stmt))\n     if (!gimple_call_internal_p (call)\n \t|| (gimple_call_internal_fn (call) != IFN_MASK_LOAD\n \t    && gimple_call_internal_fn (call) != IFN_MASK_STORE))\n-      {\n-\tif (dump_enabled_p ())\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION,  vect_location,\n-\t\t\t   \"not vectorized: dr in a call %G\", stmt);\n-\treturn false;\n-      }\n+      return opt_result::failure_at (stmt,\n+\t\t\t\t     \"not vectorized: dr in a call %G\", stmt);\n \n   data_reference_p dr = refs.pop ();\n   if (TREE_CODE (DR_REF (dr)) == COMPONENT_REF\n       && DECL_BIT_FIELD (TREE_OPERAND (DR_REF (dr), 1)))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: statement is bitfield \"\n-\t\t\t \"access %G\", stmt);\n-      return false;\n-    }\n+    return opt_result::failure_at (stmt,\n+\t\t\t\t   \"not vectorized:\"\n+\t\t\t\t   \" statement is bitfield access %G\", stmt);\n \n   if (DR_BASE_ADDRESS (dr)\n       && TREE_CODE (DR_BASE_ADDRESS (dr)) == INTEGER_CST)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: base addr of dr is a \"\n-\t\t\t \"constant\\n\");\n-      return false;\n-    }\n+    return opt_result::failure_at (stmt,\n+\t\t\t\t   \"not vectorized:\"\n+\t\t\t\t   \" base addr of dr is a constant\\n\");\n \n   /* Check whether this may be a SIMD lane access and adjust the\n      DR to make it easier for us to handle it.  */\n@@ -3976,7 +3938,7 @@ vect_find_stmt_data_reference (loop_p loop, gimple *stmt,\n \t\t\t  newdr->aux = (void *)-1;\n \t\t\t  free_data_ref (dr);\n \t\t\t  datarefs->safe_push (newdr);\n-\t\t\t  return true;\n+\t\t\t  return opt_result::success ();\n \t\t\t}\n \t\t    }\n \t\t}\n@@ -3986,7 +3948,7 @@ vect_find_stmt_data_reference (loop_p loop, gimple *stmt,\n     }\n \n   datarefs->safe_push (dr);\n-  return true;\n+  return opt_result::success ();\n }\n \n /* Function vect_analyze_data_refs.\n@@ -4004,7 +3966,7 @@ vect_find_stmt_data_reference (loop_p loop, gimple *stmt,\n \n */\n \n-bool\n+opt_result\n vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n {\n   struct loop *loop = NULL;\n@@ -4074,21 +4036,21 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t\t  STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n \t\t  continue;\n \t\t}\n-\t      return false;\n+\t      return opt_result::failure_at (stmt_info->stmt,\n+\t\t\t\t\t     \"not vectorized:\"\n+\t\t\t\t\t     \" data ref analysis failed: %G\",\n+\t\t\t\t\t     stmt_info->stmt);\n \t    }\n         }\n \n       /* See if this was detected as SIMD lane access.  */\n       if (dr->aux == (void *)-1)\n \t{\n \t  if (nested_in_vect_loop_p (loop, stmt_info))\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"not vectorized: data ref analysis \"\n-\t\t\t\t \"failed %G\", stmt_info->stmt);\n-\t      return false;\n-\t    }\n+\t    return opt_result::failure_at (stmt_info->stmt,\n+\t\t\t\t\t   \"not vectorized:\"\n+\t\t\t\t\t   \" data ref analysis failed: %G\",\n+\t\t\t\t\t   stmt_info->stmt);\n \t  STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) = true;\n \t}\n \n@@ -4106,21 +4068,21 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t      STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n \t      continue;\n \t    }\n-\t  return false;\n+\t  return opt_result::failure_at (stmt_info->stmt,\n+\t\t\t\t\t \"not vectorized: base object not\"\n+\t\t\t\t\t \" addressable for stmt: %G\",\n+\t\t\t\t\t stmt_info->stmt);\n \t}\n \n       if (is_a <loop_vec_info> (vinfo)\n \t  && DR_STEP (dr)\n \t  && TREE_CODE (DR_STEP (dr)) != INTEGER_CST)\n \t{\n \t  if (nested_in_vect_loop_p (loop, stmt_info))\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"not vectorized: not suitable for strided \"\n-\t\t\t\t \"load %G\", stmt_info->stmt);\n-\t      return false;\n-\t    }\n+\t    return opt_result::failure_at (stmt_info->stmt,\n+\t\t\t\t\t   \"not vectorized:\"\n+\t\t\t\t\t   \"not suitable for strided load %G\",\n+\t\t\t\t\t   stmt_info->stmt);\n \t  STMT_VINFO_STRIDED_P (stmt_info) = true;\n \t}\n \n@@ -4150,10 +4112,12 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"analyze in outer loop: %T\\n\", init_ref);\n \n-\t  if (!dr_analyze_innermost (&STMT_VINFO_DR_WRT_VEC_LOOP (stmt_info),\n-\t\t\t\t     init_ref, loop))\n+\t  opt_result res\n+\t    = dr_analyze_innermost (&STMT_VINFO_DR_WRT_VEC_LOOP (stmt_info),\n+\t\t\t\t    init_ref, loop, stmt_info->stmt);\n+\t  if (!res)\n \t    /* dr_analyze_innermost already explained the failure.  */\n-\t    return false;\n+\t    return res;\n \n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n@@ -4199,7 +4163,11 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t      STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n \t      continue;\n \t    }\n-\t  return false;\n+\t  return opt_result::failure_at (stmt_info->stmt,\n+\t\t\t\t\t \"not vectorized:\"\n+\t\t\t\t\t \" no vectype for stmt: %G\"\n+\t\t\t\t\t \" scalar_type: %T\\n\",\n+\t\t\t\t\t stmt_info->stmt, scalar_type);\n         }\n       else\n \t{\n@@ -4221,17 +4189,12 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t\t\t\t\t  as_a <loop_vec_info> (vinfo),\n \t\t\t\t\t  &gs_info)\n \t      || !get_vectype_for_scalar_type (TREE_TYPE (gs_info.offset)))\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t (gatherscatter == GATHER) ?\n-\t\t\t\t \"not vectorized: not suitable for gather \"\n-\t\t\t\t \"load %G\" :\n-\t\t\t\t \"not vectorized: not suitable for scatter \"\n-\t\t\t\t \"store %G\",\n-\t\t\t\t stmt_info->stmt);\n-\t      return false;\n-\t    }\n+\t    return opt_result::failure_at\n+\t      (stmt_info->stmt,\n+\t       (gatherscatter == GATHER) ?\n+\t       \"not vectorized: not suitable for gather load %G\" :\n+\t       \"not vectorized: not suitable for scatter store %G\",\n+\t       stmt_info->stmt);\n \t  STMT_VINFO_GATHER_SCATTER_P (stmt_info) = gatherscatter;\n \t}\n     }\n@@ -4240,7 +4203,7 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n      longer need to.  */\n   gcc_assert (i == datarefs.length ());\n \n-  return true;\n+  return opt_result::success ();\n }\n \n "}, {"sha": "6ea1e77d4baaf4c1190b1a4a935623c1035880e7", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 195, "deletions": 247, "changes": 442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -159,7 +159,7 @@ static void vect_estimate_min_profitable_iters (loop_vec_info, int *, int *);\n    statement.  VECTYPE_MAYBE_SET_P is true if STMT_VINFO_VECTYPE\n    may already be set for general statements (not just data refs).  */\n \n-static bool\n+static opt_result\n vect_determine_vf_for_stmt_1 (stmt_vec_info stmt_info,\n \t\t\t      bool vectype_maybe_set_p,\n \t\t\t      poly_uint64 *vf,\n@@ -173,13 +173,14 @@ vect_determine_vf_for_stmt_1 (stmt_vec_info stmt_info,\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location, \"skip.\\n\");\n-      return true;\n+      return opt_result::success ();\n     }\n \n   tree stmt_vectype, nunits_vectype;\n-  if (!vect_get_vector_types_for_stmt (stmt_info, &stmt_vectype,\n-\t\t\t\t       &nunits_vectype))\n-    return false;\n+  opt_result res = vect_get_vector_types_for_stmt (stmt_info, &stmt_vectype,\n+\t\t\t\t\t\t   &nunits_vectype);\n+  if (!res)\n+    return res;\n \n   if (stmt_vectype)\n     {\n@@ -199,7 +200,7 @@ vect_determine_vf_for_stmt_1 (stmt_vec_info stmt_info,\n   if (nunits_vectype)\n     vect_update_max_nunits (vf, nunits_vectype);\n \n-  return true;\n+  return opt_result::success ();\n }\n \n /* Subroutine of vect_determine_vectorization_factor.  Set the vector\n@@ -209,16 +210,18 @@ vect_determine_vf_for_stmt_1 (stmt_vec_info stmt_info,\n    add them to MASK_PRODUCERS.  Return true on success or false if\n    something prevented vectorization.  */\n \n-static bool\n+static opt_result\n vect_determine_vf_for_stmt (stmt_vec_info stmt_info, poly_uint64 *vf,\n \t\t\t    vec<stmt_vec_info > *mask_producers)\n {\n   vec_info *vinfo = stmt_info->vinfo;\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"==> examining statement: %G\",\n \t\t     stmt_info->stmt);\n-  if (!vect_determine_vf_for_stmt_1 (stmt_info, false, vf, mask_producers))\n-    return false;\n+  opt_result res\n+    = vect_determine_vf_for_stmt_1 (stmt_info, false, vf, mask_producers);\n+  if (!res)\n+    return res;\n \n   if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n       && STMT_VINFO_RELATED_STMT (stmt_info))\n@@ -237,18 +240,22 @@ vect_determine_vf_for_stmt (stmt_vec_info stmt_info, poly_uint64 *vf,\n \t\t\t     def_stmt_info->stmt);\n \t  if (!vect_determine_vf_for_stmt_1 (def_stmt_info, true,\n \t\t\t\t\t     vf, mask_producers))\n-\t    return false;\n+\t  res = vect_determine_vf_for_stmt_1 (def_stmt_info, true,\n+\t\t\t\t\t      vf, mask_producers);\n+\t  if (!res)\n+\t    return res;\n \t}\n \n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"==> examining pattern statement: %G\",\n \t\t\t stmt_info->stmt);\n-      if (!vect_determine_vf_for_stmt_1 (stmt_info, true, vf, mask_producers))\n-\treturn false;\n+      res = vect_determine_vf_for_stmt_1 (stmt_info, true, vf, mask_producers);\n+      if (!res)\n+\treturn res;\n     }\n \n-  return true;\n+  return opt_result::success ();\n }\n \n /* Function vect_determine_vectorization_factor\n@@ -276,7 +283,7 @@ vect_determine_vf_for_stmt (stmt_vec_info stmt_info, poly_uint64 *vf,\n         }\n */\n \n-static bool\n+static opt_result\n vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -320,14 +327,10 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n \t      vectype = get_vectype_for_scalar_type (scalar_type);\n \t      if (!vectype)\n-\t\t{\n-\t\t  if (dump_enabled_p ())\n-\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t     \"not vectorized: unsupported \"\n-\t\t\t\t     \"data-type %T\\n\",\n-\t\t\t\t     scalar_type);\n-\t\t  return false;\n-\t\t}\n+\t\treturn opt_result::failure_at (phi,\n+\t\t\t\t\t       \"not vectorized: unsupported \"\n+\t\t\t\t\t       \"data-type %T\\n\",\n+\t\t\t\t\t       scalar_type);\n \t      STMT_VINFO_VECTYPE (stmt_info) = vectype;\n \n \t      if (dump_enabled_p ())\n@@ -349,9 +352,11 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t   gsi_next (&si))\n \t{\n \t  stmt_info = loop_vinfo->lookup_stmt (gsi_stmt (si));\n-\t  if (!vect_determine_vf_for_stmt (stmt_info, &vectorization_factor,\n-\t\t\t\t\t   &mask_producers))\n-\t    return false;\n+\t  opt_result res\n+\t    = vect_determine_vf_for_stmt (stmt_info, &vectorization_factor,\n+\t\t\t\t\t  &mask_producers);\n+\t  if (!res)\n+\t    return res;\n         }\n     }\n \n@@ -364,24 +369,20 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n     }\n \n   if (known_le (vectorization_factor, 1U))\n-    {\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"not vectorized: unsupported data-type\\n\");\n-      return false;\n-    }\n+    return opt_result::failure_at (vect_location,\n+\t\t\t\t   \"not vectorized: unsupported data-type\\n\");\n   LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n \n   for (i = 0; i < mask_producers.length (); i++)\n     {\n       stmt_info = mask_producers[i];\n-      tree mask_type = vect_get_mask_type_for_stmt (stmt_info);\n+      opt_tree mask_type = vect_get_mask_type_for_stmt (stmt_info);\n       if (!mask_type)\n-\treturn false;\n+\treturn opt_result::propagate_failure (mask_type);\n       STMT_VINFO_VECTYPE (stmt_info) = mask_type;\n     }\n \n-  return true;\n+  return opt_result::success ();\n }\n \n \n@@ -1145,7 +1146,7 @@ vect_compute_single_scalar_iteration_cost (loop_vec_info loop_vinfo)\n    - the number of iterations can be analyzed, i.e, a countable loop.  The\n      niter could be analyzed under some assumptions.  */\n \n-bool\n+opt_result\n vect_analyze_loop_form_1 (struct loop *loop, gcond **loop_cond,\n \t\t\t  tree *assumptions, tree *number_of_iterationsm1,\n \t\t\t  tree *number_of_iterations, gcond **inner_loop_cond)\n@@ -1171,20 +1172,13 @@ vect_analyze_loop_form_1 (struct loop *loop, gcond **loop_cond,\n                         (exit-bb)  */\n \n       if (loop->num_nodes != 2)\n-        {\n-          if (dump_enabled_p ())\n-            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: control flow in loop.\\n\");\n-          return false;\n-        }\n+\treturn opt_result::failure_at (vect_location,\n+\t\t\t\t       \"not vectorized:\"\n+\t\t\t\t       \" control flow in loop.\\n\");\n \n       if (empty_block_p (loop->header))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: empty loop.\\n\");\n-\t  return false;\n-\t}\n+\treturn opt_result::failure_at (vect_location,\n+\t\t\t\t       \"not vectorized: empty loop.\\n\");\n     }\n   else\n     {\n@@ -1209,143 +1203,113 @@ vect_analyze_loop_form_1 (struct loop *loop, gcond **loop_cond,\n \t as described above.  */\n \n       if ((loop->inner)->inner || (loop->inner)->next)\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: multiple nested loops.\\n\");\n-\t  return false;\n-\t}\n+\treturn opt_result::failure_at (vect_location,\n+\t\t\t\t       \"not vectorized:\"\n+\t\t\t\t       \" multiple nested loops.\\n\");\n \n       if (loop->num_nodes != 5)\n-        {\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: control flow in loop.\\n\");\n-\t  return false;\n-        }\n+\treturn opt_result::failure_at (vect_location,\n+\t\t\t\t       \"not vectorized:\"\n+\t\t\t\t       \" control flow in loop.\\n\");\n \n       entryedge = loop_preheader_edge (innerloop);\n       if (entryedge->src != loop->header\n \t  || !single_exit (innerloop)\n \t  || single_exit (innerloop)->dest != EDGE_PRED (loop->latch, 0)->src)\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: unsupported outerloop form.\\n\");\n-\t  return false;\n-\t}\n+\treturn opt_result::failure_at (vect_location,\n+\t\t\t\t       \"not vectorized:\"\n+\t\t\t\t       \" unsupported outerloop form.\\n\");\n \n       /* Analyze the inner-loop.  */\n       tree inner_niterm1, inner_niter, inner_assumptions;\n-      if (! vect_analyze_loop_form_1 (loop->inner, inner_loop_cond,\n-\t\t\t\t      &inner_assumptions, &inner_niterm1,\n-\t\t\t\t      &inner_niter, NULL)\n-\t  /* Don't support analyzing niter under assumptions for inner\n-\t     loop.  */\n-\t  || !integer_onep (inner_assumptions))\n+      opt_result res\n+\t= vect_analyze_loop_form_1 (loop->inner, inner_loop_cond,\n+\t\t\t\t    &inner_assumptions, &inner_niterm1,\n+\t\t\t\t    &inner_niter, NULL);\n+      if (!res)\n \t{\n \t  if (dump_enabled_p ())\n-            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"not vectorized: Bad inner loop.\\n\");\n-\t  return false;\n+\t  return res;\n \t}\n \n+      /* Don't support analyzing niter under assumptions for inner\n+\t loop.  */\n+      if (!integer_onep (inner_assumptions))\n+\treturn opt_result::failure_at (vect_location,\n+\t\t\t\t       \"not vectorized: Bad inner loop.\\n\");\n+\n       if (!expr_invariant_in_loop_p (loop, inner_niter))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: inner-loop count not\"\n-                             \" invariant.\\n\");\n-\t  return false;\n-\t}\n+\treturn opt_result::failure_at (vect_location,\n+\t\t\t\t       \"not vectorized: inner-loop count not\"\n+\t\t\t\t       \" invariant.\\n\");\n \n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"Considering outer-loop vectorization.\\n\");\n     }\n \n-  if (!single_exit (loop)\n-      || EDGE_COUNT (loop->header->preds) != 2)\n-    {\n-      if (dump_enabled_p ())\n-        {\n-          if (!single_exit (loop))\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: multiple exits.\\n\");\n-          else if (EDGE_COUNT (loop->header->preds) != 2)\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: too many incoming edges.\\n\");\n-        }\n-      return false;\n-    }\n+  if (!single_exit (loop))\n+    return opt_result::failure_at (vect_location,\n+\t\t\t\t   \"not vectorized: multiple exits.\\n\");\n+  if (EDGE_COUNT (loop->header->preds) != 2)\n+    return opt_result::failure_at (vect_location,\n+\t\t\t\t   \"not vectorized:\"\n+\t\t\t\t   \" too many incoming edges.\\n\");\n \n   /* We assume that the loop exit condition is at the end of the loop. i.e,\n      that the loop is represented as a do-while (with a proper if-guard\n      before the loop if needed), where the loop header contains all the\n      executable statements, and the latch is empty.  */\n   if (!empty_block_p (loop->latch)\n       || !gimple_seq_empty_p (phi_nodes (loop->latch)))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: latch block not empty.\\n\");\n-      return false;\n-    }\n+    return opt_result::failure_at (vect_location,\n+\t\t\t\t   \"not vectorized: latch block not empty.\\n\");\n \n   /* Make sure the exit is not abnormal.  */\n   edge e = single_exit (loop);\n   if (e->flags & EDGE_ABNORMAL)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: abnormal loop exit edge.\\n\");\n-      return false;\n-    }\n+    return opt_result::failure_at (vect_location,\n+\t\t\t\t   \"not vectorized:\"\n+\t\t\t\t   \" abnormal loop exit edge.\\n\");\n \n   *loop_cond = vect_get_loop_niters (loop, assumptions, number_of_iterations,\n \t\t\t\t     number_of_iterationsm1);\n   if (!*loop_cond)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: complicated exit condition.\\n\");\n-      return false;\n-    }\n+    return opt_result::failure_at\n+      (vect_location,\n+       \"not vectorized: complicated exit condition.\\n\");\n \n   if (integer_zerop (*assumptions)\n       || !*number_of_iterations\n       || chrec_contains_undetermined (*number_of_iterations))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: number of iterations cannot be \"\n-\t\t\t \"computed.\\n\");\n-      return false;\n-    }\n+    return opt_result::failure_at\n+      (*loop_cond,\n+       \"not vectorized: number of iterations cannot be computed.\\n\");\n \n   if (integer_zerop (*number_of_iterations))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: number of iterations = 0.\\n\");\n-      return false;\n-    }\n+    return opt_result::failure_at\n+      (*loop_cond,\n+       \"not vectorized: number of iterations = 0.\\n\");\n \n-  return true;\n+  return opt_result::success ();\n }\n \n /* Analyze LOOP form and return a loop_vec_info if it is of suitable form.  */\n \n-loop_vec_info\n+opt_loop_vec_info\n vect_analyze_loop_form (struct loop *loop, vec_info_shared *shared)\n {\n   tree assumptions, number_of_iterations, number_of_iterationsm1;\n   gcond *loop_cond, *inner_loop_cond = NULL;\n \n-  if (! vect_analyze_loop_form_1 (loop, &loop_cond,\n-\t\t\t\t  &assumptions, &number_of_iterationsm1,\n-\t\t\t\t  &number_of_iterations, &inner_loop_cond))\n-    return NULL;\n+  opt_result res\n+    = vect_analyze_loop_form_1 (loop, &loop_cond,\n+\t\t\t\t&assumptions, &number_of_iterationsm1,\n+\t\t\t\t&number_of_iterations, &inner_loop_cond);\n+  if (!res)\n+    return opt_loop_vec_info::propagate_failure (res);\n \n   loop_vec_info loop_vinfo = new _loop_vec_info (loop, shared);\n   LOOP_VINFO_NITERSM1 (loop_vinfo) = number_of_iterationsm1;\n@@ -1387,7 +1351,7 @@ vect_analyze_loop_form (struct loop *loop, vec_info_shared *shared)\n \n   gcc_assert (!loop->aux);\n   loop->aux = loop_vinfo;\n-  return loop_vinfo;\n+  return opt_loop_vec_info::success (loop_vinfo);\n }\n \n \n@@ -1489,7 +1453,7 @@ vect_active_double_reduction_p (stmt_vec_info stmt_info)\n \n    Scan the loop stmts and make sure they are all vectorizable.  */\n \n-static bool\n+static opt_result\n vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -1531,13 +1495,9 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n                  requires to actually do something here.  */\n               if (STMT_VINFO_LIVE_P (stmt_info)\n \t\t  && !vect_active_double_reduction_p (stmt_info))\n-                {\n-                  if (dump_enabled_p ())\n-\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t     \"Unsupported loop-closed phi in \"\n-\t\t\t\t     \"outer-loop.\\n\");\n-                  return false;\n-                }\n+\t\treturn opt_result::failure_at (phi,\n+\t\t\t\t\t       \"Unsupported loop-closed phi\"\n+\t\t\t\t\t       \" in outer-loop.\\n\");\n \n               /* If PHI is used in the outer loop, we check that its operand\n                  is defined in the inner loop.  */\n@@ -1546,17 +1506,17 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n                   tree phi_op;\n \n                   if (gimple_phi_num_args (phi) != 1)\n-                    return false;\n+                    return opt_result::failure_at (phi, \"unsupported phi\");\n \n                   phi_op = PHI_ARG_DEF (phi, 0);\n \t\t  stmt_vec_info op_def_info = loop_vinfo->lookup_def (phi_op);\n \t\t  if (!op_def_info)\n-                    return false;\n+\t\t    return opt_result::failure_at (phi, \"unsupported phi\");\n \n \t\t  if (STMT_VINFO_RELEVANT (op_def_info) != vect_used_in_outer\n \t\t      && (STMT_VINFO_RELEVANT (op_def_info)\n \t\t\t  != vect_used_in_outer_by_reduction))\n-\t\t    return false;\n+\t\t    return opt_result::failure_at (phi, \"unsupported phi\");\n                 }\n \n               continue;\n@@ -1567,13 +1527,10 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n           if ((STMT_VINFO_RELEVANT (stmt_info) == vect_used_in_scope\n                || STMT_VINFO_LIVE_P (stmt_info))\n               && STMT_VINFO_DEF_TYPE (stmt_info) != vect_induction_def)\n-            {\n-              /* A scalar-dependence cycle that we don't support.  */\n-              if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"not vectorized: scalar dependence cycle.\\n\");\n-              return false;\n-            }\n+\t    /* A scalar-dependence cycle that we don't support.  */\n+\t    return opt_result::failure_at (phi,\n+\t\t\t\t\t   \"not vectorized:\"\n+\t\t\t\t\t   \" scalar dependence cycle.\\n\");\n \n           if (STMT_VINFO_RELEVANT_P (stmt_info))\n             {\n@@ -1597,24 +1554,25 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n \t\t\t\t\t      &cost_vec);\n \n           if (!ok)\n-            {\n-              if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"not vectorized: relevant phi not \"\n-\t\t\t\t \"supported: %G\", phi);\n-\t      return false;\n-            }\n+\t    return opt_result::failure_at (phi,\n+\t\t\t\t\t   \"not vectorized: relevant phi not \"\n+\t\t\t\t\t   \"supported: %G\",\n+\t\t\t\t\t   static_cast <gimple *> (phi));\n         }\n \n       for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n \t   gsi_next (&si))\n         {\n \t  gimple *stmt = gsi_stmt (si);\n-\t  if (!gimple_clobber_p (stmt)\n-\t      && !vect_analyze_stmt (loop_vinfo->lookup_stmt (stmt),\n+\t  if (!gimple_clobber_p (stmt))\n+\t    {\n+\t      opt_result res\n+\t\t= vect_analyze_stmt (loop_vinfo->lookup_stmt (stmt),\n \t\t\t\t     &need_to_vectorize,\n-\t\t\t\t     NULL, NULL, &cost_vec))\n-\t    return false;\n+\t\t\t\t     NULL, NULL, &cost_vec);\n+\t      if (!res)\n+\t\treturn res;\n+\t    }\n         }\n     } /* bbs */\n \n@@ -1631,14 +1589,12 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"All the computation can be taken out of the loop.\\n\");\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: redundant loop. no profit to \"\n-\t\t\t \"vectorize.\\n\");\n-      return false;\n+      return opt_result::failure_at\n+\t(vect_location,\n+\t \"not vectorized: redundant loop. no profit to vectorize.\\n\");\n     }\n \n-  return true;\n+  return opt_result::success ();\n }\n \n /* Analyze the cost of the loop described by LOOP_VINFO.  Decide if it\n@@ -1736,7 +1692,7 @@ vect_analyze_loop_costing (loop_vec_info loop_vinfo)\n   return 1;\n }\n \n-static bool\n+static opt_result\n vect_get_datarefs_in_loop (loop_p loop, basic_block *bbs,\n \t\t\t   vec<data_reference_p> *datarefs,\n \t\t\t   unsigned int *n_stmts)\n@@ -1750,7 +1706,8 @@ vect_get_datarefs_in_loop (loop_p loop, basic_block *bbs,\n \tif (is_gimple_debug (stmt))\n \t  continue;\n \t++(*n_stmts);\n-\tif (!vect_find_stmt_data_reference (loop, stmt, datarefs))\n+\topt_result res = vect_find_stmt_data_reference (loop, stmt, datarefs);\n+\tif (!res)\n \t  {\n \t    if (is_gimple_call (stmt) && loop->safelen)\n \t      {\n@@ -1782,26 +1739,27 @@ vect_get_datarefs_in_loop (loop_p loop, basic_block *bbs,\n \t\t      }\n \t\t  }\n \t      }\n-\t    return false;\n+\t    return res;\n \t  }\n \t/* If dependence analysis will give up due to the limit on the\n \t   number of datarefs stop here and fail fatally.  */\n \tif (datarefs->length ()\n \t    > (unsigned)PARAM_VALUE (PARAM_LOOP_MAX_DATAREFS_FOR_DATADEPS))\n-\t  return false;\n+\t  return opt_result::failure_at (stmt, \"exceeded param \"\n+\t\t\t\t\t \"loop-max-datarefs-for-datadeps\\n\");\n       }\n-  return true;\n+  return opt_result::success ();\n }\n \n /* Function vect_analyze_loop_2.\n \n    Apply a set of analyses on LOOP, and create a loop_vec_info struct\n    for it.  The different analyses will record information in the\n    loop_vec_info struct.  */\n-static bool\n+static opt_result\n vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n {\n-  bool ok;\n+  opt_result ok = opt_result::success ();\n   int res;\n   unsigned int max_vf = MAX_VECTORIZATION_FACTOR;\n   poly_uint64 min_vf = 2;\n@@ -1817,16 +1775,18 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n   /* Gather the data references and count stmts in the loop.  */\n   if (!LOOP_VINFO_DATAREFS (loop_vinfo).exists ())\n     {\n-      if (!vect_get_datarefs_in_loop (loop, LOOP_VINFO_BBS (loop_vinfo),\n-\t\t\t\t      &LOOP_VINFO_DATAREFS (loop_vinfo),\n-\t\t\t\t      n_stmts))\n+      opt_result res\n+\t= vect_get_datarefs_in_loop (loop, LOOP_VINFO_BBS (loop_vinfo),\n+\t\t\t\t     &LOOP_VINFO_DATAREFS (loop_vinfo),\n+\t\t\t\t     n_stmts);\n+      if (!res)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"not vectorized: loop contains function \"\n \t\t\t     \"calls or data references that cannot \"\n \t\t\t     \"be analyzed\\n\");\n-\t  return false;\n+\t  return res;\n \t}\n       loop_vinfo->shared->save_datarefs ();\n     }\n@@ -1842,7 +1802,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"bad data references.\\n\");\n-      return false;\n+      return ok;\n     }\n \n   /* Classify all cross-iteration scalar data-flow cycles.\n@@ -1862,7 +1822,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"bad data access.\\n\");\n-      return false;\n+      return ok;\n     }\n \n   /* Data-flow analysis to detect stmts that do not need to be vectorized.  */\n@@ -1873,7 +1833,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"unexpected pattern.\\n\");\n-      return false;\n+      return ok;\n     }\n \n   /* While the rest of the analysis below depends on it in some way.  */\n@@ -1885,15 +1845,16 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n      FORNOW: fail at the first data dependence that we encounter.  */\n \n   ok = vect_analyze_data_ref_dependences (loop_vinfo, &max_vf);\n-  if (!ok\n-      || (max_vf != MAX_VECTORIZATION_FACTOR\n-\t  && maybe_lt (max_vf, min_vf)))\n+  if (!ok)\n     {\n       if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"bad data dependence.\\n\");\n-      return false;\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"bad data dependence.\\n\");\n+      return ok;\n     }\n+  if (max_vf != MAX_VECTORIZATION_FACTOR\n+      && maybe_lt (max_vf, min_vf))\n+    return opt_result::failure_at (vect_location, \"bad data dependence.\\n\");\n   LOOP_VINFO_MAX_VECT_FACTOR (loop_vinfo) = max_vf;\n \n   ok = vect_determine_vectorization_factor (loop_vinfo);\n@@ -1902,16 +1863,11 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"can't determine vectorization factor.\\n\");\n-      return false;\n+      return ok;\n     }\n   if (max_vf != MAX_VECTORIZATION_FACTOR\n       && maybe_lt (max_vf, LOOP_VINFO_VECT_FACTOR (loop_vinfo)))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"bad data dependence.\\n\");\n-      return false;\n-    }\n+    return opt_result::failure_at (vect_location, \"bad data dependence.\\n\");\n \n   /* Compute the scalar iteration cost.  */\n   vect_compute_single_scalar_iteration_cost (loop_vinfo);\n@@ -1922,7 +1878,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n   /* Check the SLP opportunities in the loop, analyze and build SLP trees.  */\n   ok = vect_analyze_slp (loop_vinfo, *n_stmts);\n   if (!ok)\n-    return false;\n+    return ok;\n \n   /* If there are any SLP instances mark them as pure_slp.  */\n   bool slp = vect_make_slp_decision (loop_vinfo);\n@@ -1969,15 +1925,15 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"bad data alignment.\\n\");\n-      return false;\n+      return ok;\n     }\n \n   /* Prune the list of ddrs to be tested at run-time by versioning for alias.\n      It is important to call pruning after vect_analyze_data_ref_accesses,\n      since we use grouping information gathered by interleaving analysis.  */\n   ok = vect_prune_runtime_alias_test_list (loop_vinfo);\n   if (!ok)\n-    return false;\n+    return ok;\n \n   /* Do not invoke vect_enhance_data_refs_alignment for epilogue\n      vectorization, since we do not want to add extra peeling or\n@@ -1989,12 +1945,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n   else\n     ok = vect_verify_datarefs_alignment (loop_vinfo);\n   if (!ok)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"bad data alignment.\\n\");\n-      return false;\n-    }\n+    return ok;\n \n   if (slp)\n     {\n@@ -2004,7 +1955,11 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n       unsigned old_size = LOOP_VINFO_SLP_INSTANCES (loop_vinfo).length ();\n       vect_slp_analyze_operations (loop_vinfo);\n       if (LOOP_VINFO_SLP_INSTANCES (loop_vinfo).length () != old_size)\n-\tgoto again;\n+\t{\n+\t  ok = opt_result::failure_at (vect_location,\n+\t\t\t\t       \"unsupported SLP instances\\n\");\n+\t  goto again;\n+\t}\n     }\n \n   /* Scan all the remaining operations in the loop that are not subject\n@@ -2015,7 +1970,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"bad operation or unsupported loop bound.\\n\");\n-      return false;\n+      return ok;\n     }\n \n   /* Decide whether to use a fully-masked loop for this vectorization\n@@ -2044,26 +1999,22 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n       tree scalar_niters = LOOP_VINFO_NITERSM1 (loop_vinfo);\n \n       if (known_lt (wi::to_widest (scalar_niters), vf))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"loop has no enough iterations to support\"\n-\t\t\t     \" peeling for gaps.\\n\");\n-\t  return false;\n-\t}\n+\treturn opt_result::failure_at (vect_location,\n+\t\t\t\t       \"loop has no enough iterations to\"\n+\t\t\t\t       \" support peeling for gaps.\\n\");\n     }\n \n   /* Check the costings of the loop make vectorizing worthwhile.  */\n   res = vect_analyze_loop_costing (loop_vinfo);\n   if (res < 0)\n-    goto again;\n-  if (!res)\n     {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"Loop costings not worthwhile.\\n\");\n-      return false;\n+      ok = opt_result::failure_at (vect_location,\n+\t\t\t\t   \"Loop costings may not be worthwhile.\\n\");\n+      goto again;\n     }\n+  if (!res)\n+    return opt_result::failure_at (vect_location,\n+\t\t\t\t   \"Loop costings not worthwhile.\\n\");\n \n   /* Decide whether we need to create an epilogue loop to handle\n      remaining scalar iterations.  */\n@@ -2112,10 +2063,9 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n \t\t\t\t\t   single_exit (LOOP_VINFO_LOOP\n \t\t\t\t\t\t\t (loop_vinfo))))\n         {\n-          if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: can't create required \"\n-\t\t\t     \"epilog loop\\n\");\n+\t  ok = opt_result::failure_at (vect_location,\n+\t\t\t\t       \"not vectorized: can't create required \"\n+\t\t\t\t       \"epilog loop\\n\");\n           goto again;\n         }\n     }\n@@ -2154,17 +2104,20 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n \t\t\tLOOP_VINFO_VECT_FACTOR (loop_vinfo)));\n \n   /* Ok to vectorize!  */\n-  return true;\n+  return opt_result::success ();\n \n again:\n+  /* Ensure that \"ok\" is false (with an opt_problem if dumping is enabled).  */\n+  gcc_assert (!ok);\n+\n   /* Try again with SLP forced off but if we didn't do any SLP there is\n      no point in re-trying.  */\n   if (!slp)\n-    return false;\n+    return ok;\n \n   /* If there are reduction chains re-trying will fail anyway.  */\n   if (! LOOP_VINFO_REDUCTION_CHAINS (loop_vinfo).is_empty ())\n-    return false;\n+    return ok;\n \n   /* Likewise if the grouped loads or stores in the SLP cannot be handled\n      via interleaving or lane instructions.  */\n@@ -2183,7 +2136,8 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n       if (! vect_store_lanes_supported (vectype, size, false)\n \t && ! known_eq (TYPE_VECTOR_SUBPARTS (vectype), 1U)\n \t && ! vect_grouped_store_supported (vectype, size))\n-       return false;\n+\treturn opt_result::failure_at (vinfo->stmt,\n+\t\t\t\t       \"unsupported grouped store\\n\");\n       FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (instance), j, node)\n \t{\n \t  vinfo = SLP_TREE_SCALAR_STMTS (node)[0];\n@@ -2194,7 +2148,8 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n \t  if (! vect_load_lanes_supported (vectype, size, false)\n \t      && ! vect_grouped_load_supported (vectype, single_element_p,\n \t\t\t\t\t\tsize))\n-\t    return false;\n+\t    return opt_result::failure_at (vinfo->stmt,\n+\t\t\t\t\t   \"unsupported grouped load\\n\");\n \t}\n     }\n \n@@ -2263,11 +2218,10 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n    for it.  The different analyses will record information in the\n    loop_vec_info struct.  If ORIG_LOOP_VINFO is not NULL epilogue must\n    be vectorized.  */\n-loop_vec_info\n+opt_loop_vec_info\n vect_analyze_loop (struct loop *loop, loop_vec_info orig_loop_vinfo,\n \t\t   vec_info_shared *shared)\n {\n-  loop_vec_info loop_vinfo;\n   auto_vector_sizes vector_sizes;\n \n   /* Autodetect first vector size we try.  */\n@@ -2280,43 +2234,37 @@ vect_analyze_loop (struct loop *loop, loop_vec_info orig_loop_vinfo,\n   if (loop_outer (loop)\n       && loop_vec_info_for_loop (loop_outer (loop))\n       && LOOP_VINFO_VECTORIZABLE_P (loop_vec_info_for_loop (loop_outer (loop))))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"outer-loop already vectorized.\\n\");\n-      return NULL;\n-    }\n+    return opt_loop_vec_info::failure_at (vect_location,\n+\t\t\t\t\t  \"outer-loop already vectorized.\\n\");\n \n   if (!find_loop_nest (loop, &shared->loop_nest))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: loop nest containing two \"\n-\t\t\t \"or more consecutive inner loops cannot be \"\n-\t\t\t \"vectorized\\n\");\n-      return NULL;\n-    }\n+    return opt_loop_vec_info::failure_at\n+      (vect_location,\n+       \"not vectorized: loop nest containing two or more consecutive inner\"\n+       \" loops cannot be vectorized\\n\");\n \n   unsigned n_stmts = 0;\n   poly_uint64 autodetected_vector_size = 0;\n   while (1)\n     {\n       /* Check the CFG characteristics of the loop (nesting, entry/exit).  */\n-      loop_vinfo = vect_analyze_loop_form (loop, shared);\n+      opt_loop_vec_info loop_vinfo\n+\t= vect_analyze_loop_form (loop, shared);\n       if (!loop_vinfo)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"bad loop form.\\n\");\n-\t  return NULL;\n+\t  return loop_vinfo;\n \t}\n \n       bool fatal = false;\n \n       if (orig_loop_vinfo)\n \tLOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo) = orig_loop_vinfo;\n \n-      if (vect_analyze_loop_2 (loop_vinfo, fatal, &n_stmts))\n+      opt_result res = vect_analyze_loop_2 (loop_vinfo, fatal, &n_stmts);\n+      if (res)\n \t{\n \t  LOOP_VINFO_VECTORIZABLE_P (loop_vinfo) = 1;\n \n@@ -2335,7 +2283,7 @@ vect_analyze_loop (struct loop *loop, loop_vec_info orig_loop_vinfo,\n       if (fatal\n \t  || next_size == vector_sizes.length ()\n \t  || known_eq (current_vector_size, 0U))\n-\treturn NULL;\n+\treturn opt_loop_vec_info::propagate_failure (res);\n \n       /* Try the next biggest vector size.  */\n       current_vector_size = vector_sizes[next_size++];"}, {"sha": "f60fea0a581e40c8b099a3ae0f3f740c5dc57158", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -2071,7 +2071,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n /* Check if there are stmts in the loop can be vectorized using SLP.  Build SLP\n    trees of packed scalar stmts if SLP is possible.  */\n \n-bool\n+opt_result\n vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n {\n   unsigned int i;\n@@ -2111,7 +2111,7 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n \t\t\t\t   max_tree_size);\n     }\n \n-  return true;\n+  return opt_result::success ();\n }\n \n "}, {"sha": "8108d52a3cb97bcbb4174a5b6b7b61947030b5ae", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 117, "deletions": 158, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -448,7 +448,7 @@ exist_non_indexing_operands_for_use_p (tree use, stmt_vec_info stmt_info)\n \n    Return true if everything is as expected. Return false otherwise.  */\n \n-static bool\n+static opt_result\n process_use (stmt_vec_info stmt_vinfo, tree use, loop_vec_info loop_vinfo,\n \t     enum vect_relevant relevant, vec<stmt_vec_info> *worklist,\n \t     bool force)\n@@ -460,18 +460,15 @@ process_use (stmt_vec_info stmt_vinfo, tree use, loop_vec_info loop_vinfo,\n   /* case 1: we are only interested in uses that need to be vectorized.  Uses\n      that are used for address computation are not considered relevant.  */\n   if (!force && !exist_non_indexing_operands_for_use_p (use, stmt_vinfo))\n-     return true;\n+    return opt_result::success ();\n \n   if (!vect_is_simple_use (use, loop_vinfo, &dt, &dstmt_vinfo))\n-    {\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"not vectorized: unsupported use in stmt.\\n\");\n-      return false;\n-    }\n+    return opt_result::failure_at (stmt_vinfo->stmt,\n+\t\t\t\t   \"not vectorized:\"\n+\t\t\t\t   \" unsupported use in stmt.\\n\");\n \n   if (!dstmt_vinfo)\n-    return true;\n+    return opt_result::success ();\n \n   def_bb = gimple_bb (dstmt_vinfo->stmt);\n \n@@ -493,7 +490,7 @@ process_use (stmt_vec_info stmt_vinfo, tree use, loop_vec_info loop_vinfo,\n       gcc_assert (STMT_VINFO_RELEVANT (dstmt_vinfo) < vect_used_by_reduction);\n       gcc_assert (STMT_VINFO_LIVE_P (dstmt_vinfo)\n \t\t  || STMT_VINFO_RELEVANT (dstmt_vinfo) > vect_unused_in_scope);\n-      return true;\n+      return opt_result::success ();\n     }\n \n   /* case 3a: outer-loop stmt defining an inner-loop stmt:\n@@ -582,12 +579,12 @@ process_use (stmt_vec_info stmt_vinfo, tree use, loop_vec_info loop_vinfo,\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n                          \"induction value on backedge.\\n\");\n-      return true;\n+      return opt_result::success ();\n     }\n \n \n   vect_mark_relevant (worklist, dstmt_vinfo, relevant, false);\n-  return true;\n+  return opt_result::success ();\n }\n \n \n@@ -607,7 +604,7 @@ process_use (stmt_vec_info stmt_vinfo, tree use, loop_vec_info loop_vinfo,\n \n    This pass detects such stmts.  */\n \n-bool\n+opt_result\n vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -684,38 +681,24 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t\t&& relevant != vect_used_in_scope\n \t\t&& relevant != vect_used_by_reduction\n \t\t&& relevant != vect_used_only_live)\n-\t      {\n-\t\tif (dump_enabled_p ())\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t   \"unsupported use of reduction.\\n\");\n-\t\treturn false;\n-\t      }\n+\t      return opt_result::failure_at\n+\t\t(stmt_vinfo->stmt, \"unsupported use of reduction.\\n\");\n \t    break;\n \n           case vect_nested_cycle:\n \t    if (relevant != vect_unused_in_scope\n \t\t&& relevant != vect_used_in_outer_by_reduction\n \t\t&& relevant != vect_used_in_outer)\n-              {\n-                if (dump_enabled_p ())\n-                  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                   \"unsupported use of nested cycle.\\n\");\n-\n-                return false;\n-              }\n+\t      return opt_result::failure_at\n+\t\t(stmt_vinfo->stmt, \"unsupported use of nested cycle.\\n\");\n             break;\n \n           case vect_double_reduction_def:\n \t    if (relevant != vect_unused_in_scope\n \t\t&& relevant != vect_used_by_reduction\n \t\t&& relevant != vect_used_only_live)\n-              {\n-                if (dump_enabled_p ())\n-                  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                   \"unsupported use of double reduction.\\n\");\n-\n-                return false;\n-              }\n+\t      return opt_result::failure_at\n+\t\t(stmt_vinfo->stmt, \"unsupported use of double reduction.\\n\");\n             break;\n \n           default:\n@@ -735,54 +718,68 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t      i = 1;\n \t      if (rhs_code == COND_EXPR && COMPARISON_CLASS_P (op))\n \t\t{\n-\t\t  if (!process_use (stmt_vinfo, TREE_OPERAND (op, 0),\n-\t\t\t\t    loop_vinfo, relevant, &worklist, false)\n-\t\t      || !process_use (stmt_vinfo, TREE_OPERAND (op, 1),\n-\t\t\t\t       loop_vinfo, relevant, &worklist, false))\n-\t\t    return false;\n+\t\t  opt_result res\n+\t\t    = process_use (stmt_vinfo, TREE_OPERAND (op, 0),\n+\t\t\t\t   loop_vinfo, relevant, &worklist, false);\n+\t\t  if (!res)\n+\t\t    return res;\n+\t\t  res = process_use (stmt_vinfo, TREE_OPERAND (op, 1),\n+\t\t\t\t     loop_vinfo, relevant, &worklist, false);\n+\t\t  if (!res)\n+\t\t    return res;\n \t\t  i = 2;\n \t\t}\n \t      for (; i < gimple_num_ops (assign); i++)\n \t\t{\n \t\t  op = gimple_op (assign, i);\n-                  if (TREE_CODE (op) == SSA_NAME\n-\t\t      && !process_use (stmt_vinfo, op, loop_vinfo, relevant,\n-\t\t\t\t       &worklist, false))\n-                    return false;\n+                  if (TREE_CODE (op) == SSA_NAME)\n+\t\t    {\n+\t\t      opt_result res\n+\t\t\t= process_use (stmt_vinfo, op, loop_vinfo, relevant,\n+\t\t\t\t       &worklist, false);\n+\t\t      if (!res)\n+\t\t\treturn res;\n+\t\t    }\n                  }\n             }\n \t  else if (gcall *call = dyn_cast <gcall *> (stmt_vinfo->stmt))\n \t    {\n \t      for (i = 0; i < gimple_call_num_args (call); i++)\n \t\t{\n \t\t  tree arg = gimple_call_arg (call, i);\n-\t\t  if (!process_use (stmt_vinfo, arg, loop_vinfo, relevant,\n-\t\t\t\t    &worklist, false))\n-                    return false;\n+\t\t  opt_result res\n+\t\t    = process_use (stmt_vinfo, arg, loop_vinfo, relevant,\n+\t\t\t\t   &worklist, false);\n+\t\t  if (!res)\n+\t\t    return res;\n \t\t}\n \t    }\n         }\n       else\n \tFOR_EACH_PHI_OR_STMT_USE (use_p, stmt_vinfo->stmt, iter, SSA_OP_USE)\n           {\n             tree op = USE_FROM_PTR (use_p);\n-\t    if (!process_use (stmt_vinfo, op, loop_vinfo, relevant,\n-\t\t\t      &worklist, false))\n-              return false;\n+\t    opt_result res\n+\t      = process_use (stmt_vinfo, op, loop_vinfo, relevant,\n+\t\t\t     &worklist, false);\n+\t    if (!res)\n+\t      return res;\n           }\n \n       if (STMT_VINFO_GATHER_SCATTER_P (stmt_vinfo))\n \t{\n \t  gather_scatter_info gs_info;\n \t  if (!vect_check_gather_scatter (stmt_vinfo, loop_vinfo, &gs_info))\n \t    gcc_unreachable ();\n-\t  if (!process_use (stmt_vinfo, gs_info.offset, loop_vinfo, relevant,\n-\t\t\t    &worklist, true))\n-\t    return false;\n+\t  opt_result res\n+\t    = process_use (stmt_vinfo, gs_info.offset, loop_vinfo, relevant,\n+\t\t\t   &worklist, true);\n+\t  if (!res)\n+\t    return res;\n \t}\n     } /* while worklist */\n \n-  return true;\n+  return opt_result::success ();\n }\n \n /* Compute the prologue cost for invariant or constant operands.  */\n@@ -9382,7 +9379,7 @@ can_vectorize_live_stmts (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \n /* Make sure the statement is vectorizable.  */\n \n-bool\n+opt_result\n vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n \t\t   slp_tree node, slp_instance node_instance,\n \t\t   stmt_vector_for_cost *cost_vec)\n@@ -9398,13 +9395,10 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n \t\t     stmt_info->stmt);\n \n   if (gimple_has_volatile_ops (stmt_info->stmt))\n-    {\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"not vectorized: stmt has volatile operands\\n\");\n-\n-      return false;\n-    }\n+    return opt_result::failure_at (stmt_info->stmt,\n+\t\t\t\t   \"not vectorized:\"\n+\t\t\t\t   \" stmt has volatile operands: %G\\n\",\n+\t\t\t\t   stmt_info->stmt);\n \n   if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n       && node == NULL\n@@ -9425,10 +9419,12 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n \t\t\t\t \"==> examining pattern def statement: %G\",\n \t\t\t\t pattern_def_stmt_info->stmt);\n \n-\t      if (!vect_analyze_stmt (pattern_def_stmt_info,\n-\t\t\t\t      need_to_vectorize, node, node_instance,\n-\t\t\t\t      cost_vec))\n-\t\treturn false;\n+\t      opt_result res\n+\t\t= vect_analyze_stmt (pattern_def_stmt_info,\n+\t\t\t\t     need_to_vectorize, node, node_instance,\n+\t\t\t\t     cost_vec);\n+\t      if (!res)\n+\t\treturn res;\n \t    }\n \t}\n     }\n@@ -9468,7 +9464,7 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n           if (dump_enabled_p ())\n             dump_printf_loc (MSG_NOTE, vect_location, \"irrelevant.\\n\");\n \n-          return true;\n+          return opt_result::success ();\n         }\n     }\n   else if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n@@ -9483,9 +9479,11 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n \t\t\t \"==> examining pattern statement: %G\",\n \t\t\t pattern_stmt_info->stmt);\n \n-      if (!vect_analyze_stmt (pattern_stmt_info, need_to_vectorize, node,\n-\t\t\t      node_instance, cost_vec))\n-        return false;\n+      opt_result res\n+\t= vect_analyze_stmt (pattern_stmt_info, need_to_vectorize, node,\n+\t\t\t     node_instance, cost_vec);\n+      if (!res)\n+\treturn res;\n    }\n \n   switch (STMT_VINFO_DEF_TYPE (stmt_info))\n@@ -9528,7 +9526,7 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n     {\n       dump_printf_loc (MSG_NOTE, vect_location,\n \t\t       \"handled only by SLP analysis\\n\");\n-      return true;\n+      return opt_result::success ();\n     }\n \n   ok = true;\n@@ -9573,30 +9571,22 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n     }\n \n   if (!ok)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: relevant stmt not supported: %G\",\n-\t\t\t stmt_info->stmt);\n-\n-      return false;\n-    }\n+    return opt_result::failure_at (stmt_info->stmt,\n+\t\t\t\t   \"not vectorized:\"\n+\t\t\t\t   \" relevant stmt not supported: %G\",\n+\t\t\t\t   stmt_info->stmt);\n \n   /* Stmts that are (also) \"live\" (i.e. - that are used out of the loop)\n       need extra handling, except for vectorizable reductions.  */\n   if (!bb_vinfo\n       && STMT_VINFO_TYPE (stmt_info) != reduc_vec_info_type\n       && !can_vectorize_live_stmts (stmt_info, NULL, node, NULL, cost_vec))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: live stmt not supported: %G\",\n-\t\t\t stmt_info->stmt);\n+    return opt_result::failure_at (stmt_info->stmt,\n+\t\t\t\t   \"not vectorized:\"\n+\t\t\t\t   \" live stmt not supported: %G\",\n+\t\t\t\t   stmt_info->stmt);\n \n-       return false;\n-    }\n-\n-  return true;\n+  return opt_result::success ();\n }\n \n \n@@ -10537,7 +10527,7 @@ vect_gen_while_not (gimple_seq *seq, tree mask_type, tree start_index,\n      number of units needed to vectorize STMT_INFO, or NULL_TREE if the\n      statement does not help to determine the overall number of units.  */\n \n-bool\n+opt_result\n vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n \t\t\t\ttree *stmt_vectype_out,\n \t\t\t\ttree *nunits_vectype_out)\n@@ -10560,22 +10550,17 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"defer to SIMD clone analysis.\\n\");\n-\t  return true;\n+\t  return opt_result::success ();\n \t}\n \n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: irregular stmt.%G\", stmt);\n-      return false;\n+      return opt_result::failure_at (stmt,\n+\t\t\t\t     \"not vectorized: irregular stmt.%G\", stmt);\n     }\n \n   if (VECTOR_MODE_P (TYPE_MODE (gimple_expr_type (stmt))))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: vector stmt in loop:%G\", stmt);\n-      return false;\n-    }\n+    return opt_result::failure_at (stmt,\n+\t\t\t\t   \"not vectorized: vector stmt in loop:%G\",\n+\t\t\t\t   stmt);\n \n   tree vectype;\n   tree scalar_type = NULL_TREE;\n@@ -10606,7 +10591,7 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t\t \"pure bool operation.\\n\");\n-\t      return true;\n+\t      return opt_result::success ();\n \t    }\n \t}\n \n@@ -10615,13 +10600,10 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n \t\t\t \"get vectype for scalar type:  %T\\n\", scalar_type);\n       vectype = get_vectype_for_scalar_type (scalar_type);\n       if (!vectype)\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: unsupported data-type %T\\n\",\n-\t\t\t     scalar_type);\n-\t  return false;\n-\t}\n+\treturn opt_result::failure_at (stmt,\n+\t\t\t\t       \"not vectorized:\"\n+\t\t\t\t       \" unsupported data-type %T\\n\",\n+\t\t\t\t       scalar_type);\n \n       if (!*stmt_vectype_out)\n \t*stmt_vectype_out = vectype;\n@@ -10652,24 +10634,16 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n       nunits_vectype = get_vectype_for_scalar_type (scalar_type);\n     }\n   if (!nunits_vectype)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: unsupported data-type %T\\n\",\n-\t\t\t scalar_type);\n-      return false;\n-    }\n+    return opt_result::failure_at (stmt,\n+\t\t\t\t   \"not vectorized: unsupported data-type %T\\n\",\n+\t\t\t\t   scalar_type);\n \n   if (maybe_ne (GET_MODE_SIZE (TYPE_MODE (vectype)),\n \t\tGET_MODE_SIZE (TYPE_MODE (nunits_vectype))))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: different sized vector \"\n-\t\t\t \"types in statement, %T and %T\\n\",\n-\t\t\t vectype, nunits_vectype);\n-      return false;\n-    }\n+    return opt_result::failure_at (stmt,\n+\t\t\t\t   \"not vectorized: different sized vector \"\n+\t\t\t\t   \"types in statement, %T and %T\\n\",\n+\t\t\t\t   vectype, nunits_vectype);\n \n   if (dump_enabled_p ())\n     {\n@@ -10682,14 +10656,14 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n     }\n \n   *nunits_vectype_out = nunits_vectype;\n-  return true;\n+  return opt_result::success ();\n }\n \n /* Try to determine the correct vector type for STMT_INFO, which is a\n    statement that produces a scalar boolean result.  Return the vector\n    type on success, otherwise return NULL_TREE.  */\n \n-tree\n+opt_tree\n vect_get_mask_type_for_stmt (stmt_vec_info stmt_info)\n {\n   gimple *stmt = stmt_info->stmt;\n@@ -10704,12 +10678,8 @@ vect_get_mask_type_for_stmt (stmt_vec_info stmt_info)\n       mask_type = get_mask_type_for_scalar_type (scalar_type);\n \n       if (!mask_type)\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: unsupported mask\\n\");\n-\t  return NULL_TREE;\n-\t}\n+\treturn opt_tree::failure_at (stmt,\n+\t\t\t\t     \"not vectorized: unsupported mask\\n\");\n     }\n   else\n     {\n@@ -10720,13 +10690,9 @@ vect_get_mask_type_for_stmt (stmt_vec_info stmt_info)\n       FOR_EACH_SSA_TREE_OPERAND (rhs, stmt, iter, SSA_OP_USE)\n \t{\n \t  if (!vect_is_simple_use (rhs, stmt_info->vinfo, &dt, &vectype))\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"not vectorized: can't compute mask type \"\n-\t\t\t\t \"for statement, %G\", stmt);\n-\t      return NULL_TREE;\n-\t    }\n+\t    return opt_tree::failure_at (stmt,\n+\t\t\t\t\t \"not vectorized:can't compute mask\"\n+\t\t\t\t\t \" type for statement, %G\", stmt);\n \n \t  /* No vectype probably means external definition.\n \t     Allow it in case there is another operand which\n@@ -10738,25 +10704,17 @@ vect_get_mask_type_for_stmt (stmt_vec_info stmt_info)\n \t    mask_type = vectype;\n \t  else if (maybe_ne (TYPE_VECTOR_SUBPARTS (mask_type),\n \t\t\t     TYPE_VECTOR_SUBPARTS (vectype)))\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"not vectorized: different sized masks \"\n-\t\t\t\t \"types in statement, %T and %T\\n\",\n-\t\t\t\t mask_type, vectype);\n-\t      return NULL_TREE;\n-\t    }\n+\t    return opt_tree::failure_at (stmt,\n+\t\t\t\t\t \"not vectorized: different sized mask\"\n+\t\t\t\t\t \" types in statement, %T and %T\\n\",\n+\t\t\t\t\t mask_type, vectype);\n \t  else if (VECTOR_BOOLEAN_TYPE_P (mask_type)\n \t\t   != VECTOR_BOOLEAN_TYPE_P (vectype))\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"not vectorized: mixed mask and \"\n-\t\t\t\t \"nonmask vector types in statement, \"\n-\t\t\t\t \"%T and %T\\n\",\n-\t\t\t\t mask_type, vectype);\n-\t      return NULL_TREE;\n-\t    }\n+\t    return opt_tree::failure_at (stmt,\n+\t\t\t\t\t \"not vectorized: mixed mask and \"\n+\t\t\t\t\t \"nonmask vector types in statement, \"\n+\t\t\t\t\t \"%T and %T\\n\",\n+\t\t\t\t\t mask_type, vectype);\n \t}\n \n       /* We may compare boolean value loaded as vector of integers.\n@@ -10770,9 +10728,10 @@ vect_get_mask_type_for_stmt (stmt_vec_info stmt_info)\n \n   /* No mask_type should mean loop invariant predicate.\n      This is probably a subject for optimization in if-conversion.  */\n-  if (!mask_type && dump_enabled_p ())\n-    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t     \"not vectorized: can't compute mask type \"\n-\t\t     \"for statement, %G\", stmt);\n-  return mask_type;\n+  if (!mask_type)\n+    return opt_tree::failure_at (stmt,\n+\t\t\t\t \"not vectorized: can't compute mask type \"\n+\t\t\t\t \"for statement: %G\", stmt);\n+\n+  return opt_tree::success (mask_type);\n }"}, {"sha": "747fb67ba13e80309377e66945a40f5e48f186c5", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -79,6 +79,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"gimple-pretty-print.h\"\n+#include \"opt-problem.h\"\n \n \n /* Loop or bb location, with hotness information.  */\n@@ -860,13 +861,25 @@ try_vectorize_loop_1 (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n   vect_location = find_loop_location (loop);\n   if (LOCATION_LOCUS (vect_location.get_location_t ()) != UNKNOWN_LOCATION\n       && dump_enabled_p ())\n-    dump_printf (MSG_NOTE, \"\\nAnalyzing loop at %s:%d\\n\",\n+    dump_printf (MSG_NOTE | MSG_PRIORITY_INTERNALS,\n+\t\t \"\\nAnalyzing loop at %s:%d\\n\",\n \t\t LOCATION_FILE (vect_location.get_location_t ()),\n \t\t LOCATION_LINE (vect_location.get_location_t ()));\n \n-  loop_vec_info loop_vinfo = vect_analyze_loop (loop, orig_loop_vinfo, &shared);\n+  /* Try to analyze the loop, retaining an opt_problem if dump_enabled_p.  */\n+  opt_loop_vec_info loop_vinfo\n+    = vect_analyze_loop (loop, orig_loop_vinfo, &shared);\n   loop->aux = loop_vinfo;\n \n+  if (!loop_vinfo)\n+    if (dump_enabled_p ())\n+      if (opt_problem *problem = loop_vinfo.get_problem ())\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"couldn't vectorize loop\\n\");\n+\t  problem->emit_and_clear ();\n+\t}\n+\n   if (!loop_vinfo || !LOOP_VINFO_VECTORIZABLE_P (loop_vinfo))\n     {\n       /* Free existing information if loop is analyzed with some"}, {"sha": "63cff797dd8016890c81c149a0eb971758a67197", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ebbd243f887b3c5e01c65ad80a8f64a8261e61/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=f4ebbd243f887b3c5e01c65ad80a8f64a8261e61", "patch": "@@ -612,6 +612,12 @@ typedef struct _loop_vec_info : public vec_info {\n #define LOOP_VINFO_ORIG_MAX_VECT_FACTOR(L) \\\n   (LOOP_VINFO_MAX_VECT_FACTOR (LOOP_VINFO_ORIG_LOOP_INFO (L)))\n \n+/* Wrapper for loop_vec_info, for tracking success/failure, where a non-NULL\n+   value signifies success, and a NULL value signifies failure, supporting\n+   propagating an opt_problem * describing the failure back up the call\n+   stack.  */\n+typedef opt_pointer_wrapper <loop_vec_info> opt_loop_vec_info;\n+\n static inline loop_vec_info\n loop_vec_info_for_loop (struct loop *loop)\n {\n@@ -1473,7 +1479,7 @@ extern unsigned record_stmt_cost (stmt_vector_for_cost *, int,\n extern stmt_vec_info vect_finish_replace_stmt (stmt_vec_info, gimple *);\n extern stmt_vec_info vect_finish_stmt_generation (stmt_vec_info, gimple *,\n \t\t\t\t\t\t  gimple_stmt_iterator *);\n-extern bool vect_mark_stmts_to_be_vectorized (loop_vec_info);\n+extern opt_result vect_mark_stmts_to_be_vectorized (loop_vec_info);\n extern tree vect_get_store_rhs (stmt_vec_info);\n extern tree vect_get_vec_def_for_operand_1 (stmt_vec_info, enum vect_def_type);\n extern tree vect_get_vec_def_for_operand (tree, stmt_vec_info, tree = NULL);\n@@ -1487,8 +1493,8 @@ extern tree vect_get_vec_def_for_stmt_copy (vec_info *, tree);\n extern bool vect_transform_stmt (stmt_vec_info, gimple_stmt_iterator *,\n \t\t\t\t slp_tree, slp_instance);\n extern void vect_remove_stores (stmt_vec_info);\n-extern bool vect_analyze_stmt (stmt_vec_info, bool *, slp_tree, slp_instance,\n-\t\t\t       stmt_vector_for_cost *);\n+extern opt_result vect_analyze_stmt (stmt_vec_info, bool *, slp_tree,\n+\t\t\t\t     slp_instance, stmt_vector_for_cost *);\n extern bool vectorizable_condition (stmt_vec_info, gimple_stmt_iterator *,\n \t\t\t\t    stmt_vec_info *, tree, int, slp_tree,\n \t\t\t\t    stmt_vector_for_cost *);\n@@ -1504,30 +1510,31 @@ extern tree vect_gen_perm_mask_checked (tree, const vec_perm_indices &);\n extern void optimize_mask_stores (struct loop*);\n extern gcall *vect_gen_while (tree, tree, tree);\n extern tree vect_gen_while_not (gimple_seq *, tree, tree, tree);\n-extern bool vect_get_vector_types_for_stmt (stmt_vec_info, tree *, tree *);\n-extern tree vect_get_mask_type_for_stmt (stmt_vec_info);\n+extern opt_result vect_get_vector_types_for_stmt (stmt_vec_info, tree *,\n+\t\t\t\t\t\t  tree *);\n+extern opt_tree vect_get_mask_type_for_stmt (stmt_vec_info);\n \n /* In tree-vect-data-refs.c.  */\n extern bool vect_can_force_dr_alignment_p (const_tree, unsigned int);\n extern enum dr_alignment_support vect_supportable_dr_alignment\n                                            (dr_vec_info *, bool);\n extern tree vect_get_smallest_scalar_type (stmt_vec_info, HOST_WIDE_INT *,\n                                            HOST_WIDE_INT *);\n-extern bool vect_analyze_data_ref_dependences (loop_vec_info, unsigned int *);\n+extern opt_result vect_analyze_data_ref_dependences (loop_vec_info, unsigned int *);\n extern bool vect_slp_analyze_instance_dependence (slp_instance);\n-extern bool vect_enhance_data_refs_alignment (loop_vec_info);\n-extern bool vect_analyze_data_refs_alignment (loop_vec_info);\n-extern bool vect_verify_datarefs_alignment (loop_vec_info);\n+extern opt_result vect_enhance_data_refs_alignment (loop_vec_info);\n+extern opt_result vect_analyze_data_refs_alignment (loop_vec_info);\n+extern opt_result vect_verify_datarefs_alignment (loop_vec_info);\n extern bool vect_slp_analyze_and_verify_instance_alignment (slp_instance);\n-extern bool vect_analyze_data_ref_accesses (vec_info *);\n-extern bool vect_prune_runtime_alias_test_list (loop_vec_info);\n+extern opt_result vect_analyze_data_ref_accesses (vec_info *);\n+extern opt_result vect_prune_runtime_alias_test_list (loop_vec_info);\n extern bool vect_gather_scatter_fn_p (bool, bool, tree, tree, unsigned int,\n \t\t\t\t      signop, int, internal_fn *, tree *);\n extern bool vect_check_gather_scatter (stmt_vec_info, loop_vec_info,\n \t\t\t\t       gather_scatter_info *);\n-extern bool vect_find_stmt_data_reference (loop_p, gimple *,\n-\t\t\t\t\t   vec<data_reference_p> *);\n-extern bool vect_analyze_data_refs (vec_info *, poly_uint64 *);\n+extern opt_result vect_find_stmt_data_reference (loop_p, gimple *,\n+\t\t\t\t\t\t vec<data_reference_p> *);\n+extern opt_result vect_analyze_data_refs (vec_info *, poly_uint64 *);\n extern void vect_record_base_alignments (vec_info *);\n extern tree vect_create_data_ref_ptr (stmt_vec_info, tree, struct loop *, tree,\n \t\t\t\t      tree *, gimple_stmt_iterator *,\n@@ -1563,8 +1570,9 @@ extern stmt_vec_info vect_force_simple_reduction (loop_vec_info, stmt_vec_info,\n extern bool check_reduction_path (dump_user_location_t, loop_p, gphi *, tree,\n \t\t\t\t  enum tree_code);\n /* Drive for loop analysis stage.  */\n-extern loop_vec_info vect_analyze_loop (struct loop *, loop_vec_info,\n-\t\t\t\t\tvec_info_shared *);\n+extern opt_loop_vec_info vect_analyze_loop (struct loop *,\n+\t\t\t\t\t    loop_vec_info,\n+\t\t\t\t\t    vec_info_shared *);\n extern tree vect_build_loop_niters (loop_vec_info, bool * = NULL);\n extern void vect_gen_vector_loop_niters (loop_vec_info, tree, tree *,\n \t\t\t\t\t tree *, bool);\n@@ -1577,7 +1585,8 @@ extern tree vect_get_loop_mask (gimple_stmt_iterator *, vec_loop_masks *,\n \n /* Drive for loop transformation stage.  */\n extern struct loop *vect_transform_loop (loop_vec_info);\n-extern loop_vec_info vect_analyze_loop_form (struct loop *, vec_info_shared *);\n+extern opt_loop_vec_info vect_analyze_loop_form (struct loop *,\n+\t\t\t\t\t\t vec_info_shared *);\n extern bool vectorizable_live_operation (stmt_vec_info, gimple_stmt_iterator *,\n \t\t\t\t\t slp_tree, int, stmt_vec_info *,\n \t\t\t\t\t stmt_vector_for_cost *);\n@@ -1602,7 +1611,7 @@ extern bool vect_transform_slp_perm_load (slp_tree, vec<tree> ,\n \t\t\t\t\t  slp_instance, bool, unsigned *);\n extern bool vect_slp_analyze_operations (vec_info *);\n extern void vect_schedule_slp (vec_info *);\n-extern bool vect_analyze_slp (vec_info *, unsigned);\n+extern opt_result vect_analyze_slp (vec_info *, unsigned);\n extern bool vect_make_slp_decision (loop_vec_info);\n extern void vect_detect_hybrid_slp (loop_vec_info);\n extern void vect_get_slp_defs (vec<tree> , slp_tree, vec<vec<tree> > *);"}]}