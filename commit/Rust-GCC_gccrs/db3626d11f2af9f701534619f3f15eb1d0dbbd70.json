{"sha": "db3626d11f2af9f701534619f3f15eb1d0dbbd70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIzNjI2ZDExZjJhZjlmNzAxNTM0NjE5ZjNmMTVlYjFkMGRiYmQ3MA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-05-31T00:25:56Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-05-31T00:25:56Z"}, "message": "tree.c (cp_build_qualified_type_real): Rework ARRAY_TYPE allocation to match practice throughout the rest of the compiler.\n\n\t* tree.c (cp_build_qualified_type_real): Rework ARRAY_TYPE\n\tallocation to match practice throughout the rest of the\n\tcompiler.\n\nFrom-SVN: r27264", "tree": {"sha": "0a4d4b9d88b5537fc82b58e3698ec958e35af69a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a4d4b9d88b5537fc82b58e3698ec958e35af69a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db3626d11f2af9f701534619f3f15eb1d0dbbd70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db3626d11f2af9f701534619f3f15eb1d0dbbd70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db3626d11f2af9f701534619f3f15eb1d0dbbd70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db3626d11f2af9f701534619f3f15eb1d0dbbd70/comments", "author": null, "committer": null, "parents": [{"sha": "3c567fae5dd5c0d44cc6161ba6be51fea07e55e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c567fae5dd5c0d44cc6161ba6be51fea07e55e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c567fae5dd5c0d44cc6161ba6be51fea07e55e5"}], "stats": {"total": 94, "additions": 66, "deletions": 28}, "files": [{"sha": "deafd0ef7bedd607ea9e500d2753c6507ca5d5a5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3626d11f2af9f701534619f3f15eb1d0dbbd70/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3626d11f2af9f701534619f3f15eb1d0dbbd70/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=db3626d11f2af9f701534619f3f15eb1d0dbbd70", "patch": "@@ -1,3 +1,9 @@\n+1999-05-31  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* tree.c (cp_build_qualified_type_real): Rework ARRAY_TYPE\n+\tallocation to match practice throughout the rest of the \n+\tcompiler.\n+\n 1999-05-30  Mark Mitchell  <mark@codesourcery.com>\n \n \t* lex.c (make_lang_type): Create TYPE_BINFO for"}, {"sha": "2795c676355370e5e4e0d7a6593e578b5bf41b7c", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 39, "deletions": 28, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3626d11f2af9f701534619f3f15eb1d0dbbd70/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3626d11f2af9f701534619f3f15eb1d0dbbd70/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=db3626d11f2af9f701534619f3f15eb1d0dbbd70", "patch": "@@ -403,21 +403,18 @@ build_cplus_array_type_1 (elt_type, index_type)\n      tree elt_type;\n      tree index_type;\n {\n-  register struct obstack *ambient_obstack = current_obstack;\n-  register struct obstack *ambient_saveable_obstack = saveable_obstack;\n   tree t;\n \n   if (elt_type == error_mark_node || index_type == error_mark_node)\n     return error_mark_node;\n \n+  push_obstacks_nochange ();\n+\n   /* We need a new one.  If both ELT_TYPE and INDEX_TYPE are permanent,\n      make this permanent too.  */\n   if (TREE_PERMANENT (elt_type)\n       && (index_type == 0 || TREE_PERMANENT (index_type)))\n-    {\n-      current_obstack = &permanent_obstack;\n-      saveable_obstack = &permanent_obstack;\n-    }\n+    end_temporary_allocation ();\n \n   if (processing_template_decl \n       || uses_template_parms (elt_type) \n@@ -432,10 +429,11 @@ build_cplus_array_type_1 (elt_type, index_type)\n \n   /* Push these needs up so that initialization takes place\n      more easily.  */\n-  TYPE_NEEDS_CONSTRUCTING (t) = TYPE_NEEDS_CONSTRUCTING (TYPE_MAIN_VARIANT (elt_type));\n-  TYPE_NEEDS_DESTRUCTOR (t) = TYPE_NEEDS_DESTRUCTOR (TYPE_MAIN_VARIANT (elt_type));\n-  current_obstack = ambient_obstack;\n-  saveable_obstack = ambient_saveable_obstack;\n+  TYPE_NEEDS_CONSTRUCTING (t) \n+    = TYPE_NEEDS_CONSTRUCTING (TYPE_MAIN_VARIANT (elt_type));\n+  TYPE_NEEDS_DESTRUCTOR (t) \n+    = TYPE_NEEDS_DESTRUCTOR (TYPE_MAIN_VARIANT (elt_type));\n+  pop_obstacks ();\n   return t;\n }\n \n@@ -500,30 +498,43 @@ cp_build_qualified_type_real (type, type_quals, complain)\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n-      tree real_main_variant = TYPE_MAIN_VARIANT (type);\n-      tree element_type = cp_build_qualified_type_real (TREE_TYPE (type),\n-\t\t\t\t\t\t\ttype_quals,\n-\t\t\t\t\t\t\tcomplain);\n-      push_obstacks (TYPE_OBSTACK (real_main_variant),\n-\t\t     TYPE_OBSTACK (real_main_variant));\n-      type = build_cplus_array_type_1 (element_type,\n-\t\t\t\t       TYPE_DOMAIN (type));\n-      if (type == error_mark_node)\n+      /* In C++, the qualification really applies to the array element\n+\t type.  Obtain the appropriately qualified element type.  */\n+      tree t;\n+      tree element_type \n+\t= cp_build_qualified_type_real (TREE_TYPE (type), \n+\t\t\t\t\ttype_quals,\n+\t\t\t\t\tcomplain);\n+\n+      if (element_type == error_mark_node)\n \treturn error_mark_node;\n \n-      /* TYPE must be on same obstack as REAL_MAIN_VARIANT.  If not,\n-\t make a copy.  (TYPE might have come from the hash table and\n-\t REAL_MAIN_VARIANT might be in some function's obstack.)  */\n+      /* See if we already have an identically qualified type.  */\n+      for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n+\tif (CP_TYPE_QUALS (t) == type_quals)\n+\t  break;\n \n-      if (TYPE_OBSTACK (type) != TYPE_OBSTACK (real_main_variant))\n+      /* If we didn't already have it, create it now.  */\n+      if (!t)\n \t{\n-\t  type = copy_node (type);\n-\t  TYPE_POINTER_TO (type) = TYPE_REFERENCE_TO (type) = 0;\n+\t  /* Make a new array type, just like the old one, but with the\n+\t     appropriately qualified element type.  */\n+\t  t = build_type_copy (type);\n+\t  TREE_TYPE (t) = element_type;\n \t}\n \n-      TYPE_MAIN_VARIANT (type) = real_main_variant;\n-      pop_obstacks ();\n-      return type;\n+      /* Even if we already had this variant, we update\n+\t TYPE_NEEDS_CONSTRUCTING and TYPE_NEEDS_DESTRUCTOR in case\n+\t they changed since the variant was originally created.  \n+\t \n+\t This seems hokey; if there is some way to use a previous\n+\t variant *without* coming through here,\n+\t TYPE_NEEDS_CONSTRUCTING will never be updated.  */\n+      TYPE_NEEDS_CONSTRUCTING (t) \n+\t= TYPE_NEEDS_CONSTRUCTING (TYPE_MAIN_VARIANT (element_type));\n+      TYPE_NEEDS_DESTRUCTOR (t) \n+\t= TYPE_NEEDS_DESTRUCTOR (TYPE_MAIN_VARIANT (element_type));\n+      return t;\n     }\n   return build_qualified_type (type, type_quals);\n }"}, {"sha": "cda2ecb35e830951dd7d5445329eb8a5fa290870", "filename": "gcc/testsuite/g++.old-deja/g++.pt/array5.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3626d11f2af9f701534619f3f15eb1d0dbbd70/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Farray5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3626d11f2af9f701534619f3f15eb1d0dbbd70/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Farray5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Farray5.C?ref=db3626d11f2af9f701534619f3f15eb1d0dbbd70", "patch": "@@ -0,0 +1,21 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+template <class T>\n+void h(T&);\n+\n+template <class T>\n+void g () \n+{\n+  h (\"abcdefghi\");\n+}\n+\n+template void g<int>();\n+\n+template <class T>\n+void h(T&)\n+{\n+  T t = {};\n+}\n+\n+"}]}