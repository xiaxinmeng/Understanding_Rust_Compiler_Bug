{"sha": "4f88ccda2d6bba5651d3203aa88f88651b6e7ed2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY4OGNjZGEyZDZiYmE1NjUxZDMyMDNhYTg4Zjg4NjUxYjZlN2VkMg==", "commit": {"author": {"name": "Per Bothner", "email": "per@bothner.com", "date": "2001-12-04T19:30:13Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2001-12-04T19:30:13Z"}, "message": "check-init.c: Handle definite unassignment to finals in addition to definite assignment.\n\n\n\t* check-init.c:   Handle definite unassignment to finals in addition\n\tto definite assignment.\t\t[see ChangeLog]\n\nFrom-SVN: r47619", "tree": {"sha": "82756fc6205d2820616c3ac0ac02c08fdafcd100", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82756fc6205d2820616c3ac0ac02c08fdafcd100"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f88ccda2d6bba5651d3203aa88f88651b6e7ed2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f88ccda2d6bba5651d3203aa88f88651b6e7ed2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f88ccda2d6bba5651d3203aa88f88651b6e7ed2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f88ccda2d6bba5651d3203aa88f88651b6e7ed2/comments", "author": {"login": "PerBothner", "id": 10293361, "node_id": "MDQ6VXNlcjEwMjkzMzYx", "avatar_url": "https://avatars.githubusercontent.com/u/10293361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PerBothner", "html_url": "https://github.com/PerBothner", "followers_url": "https://api.github.com/users/PerBothner/followers", "following_url": "https://api.github.com/users/PerBothner/following{/other_user}", "gists_url": "https://api.github.com/users/PerBothner/gists{/gist_id}", "starred_url": "https://api.github.com/users/PerBothner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PerBothner/subscriptions", "organizations_url": "https://api.github.com/users/PerBothner/orgs", "repos_url": "https://api.github.com/users/PerBothner/repos", "events_url": "https://api.github.com/users/PerBothner/events{/privacy}", "received_events_url": "https://api.github.com/users/PerBothner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ff524991302f07788509c6d81b505bf45f94260e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff524991302f07788509c6d81b505bf45f94260e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff524991302f07788509c6d81b505bf45f94260e"}], "stats": {"total": 925, "additions": 446, "deletions": 479}, "files": [{"sha": "5b06ddeb093834201cd2f1d2c87f4db331590c2b", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f88ccda2d6bba5651d3203aa88f88651b6e7ed2/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f88ccda2d6bba5651d3203aa88f88651b6e7ed2/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=4f88ccda2d6bba5651d3203aa88f88651b6e7ed2", "patch": "@@ -1,3 +1,56 @@\n+2001-12-04  Per Bothner  <per@bothner.com>\n+\n+\t* check-init.c:   Handle definite unassignment to finals in addition\n+\tto definite assignment.\n+\t(loop_current_locals):  New field.\n+\t(num_current_locals, int start_current_locals, num_current_words):\n+\tMake static.\n+\t(SET_P, CLEAR_P, SET_BIT):  Add needed but missing parentheses.\n+\t(ASSIGNED_P, UNASSIGNED_P, SET_ASSIGNED, SET_UNASSIGNED,\n+\tCLEAR_ASSIGNED, CLEAR_UNASSIGNED):  New macros.\n+\t(get_variable_decl, check_final_reassigned):  New functions.\n+\t(check_init, check_bool_init):  Modify as needed for checking finals.\n+\t(check_for_initialization):  Take extra parameter and return void.\n+\tDo extra start-up logic to check final fields for assignment.\n+\t* parse.y (check_static_final_variable_assignment_flag,\n+\treset_static_final_variable_assignment_flag, check_final_assignment,\n+\tcheck_final_variable_local_assignment_flag,\n+\treset_final_variable_indirect_assignment_flag,\n+\treset_final_variable_global_assignment_flag):  Remove functions.\n+\t(java_complete_expand_methods, outer_field_access_fix,\n+\tpatch_assignment): Remove no-longer used logic.\n+\t* java-tree.h (DECL_FIELD_FINAL_IUD):  Change usage and comments.\n+\t* parse.y (register_fields, java_complete_tree):  Update accordingly.\n+\n+\t* check-init.c (ALLOC_WORDS/FREE_WORDS):  Use xmalloc/free, not alloca.\n+\t(DECLARE_BUFFERS, RELEASE_BUFFERS, ALLOC_BUFFER, FREE_BUFFER):  New.\n+\t(check_cond_init, check_bool2_init):  Use DECLARE_BUFFERS.\n+\n+\t* java-tree.h (STATIC_CLASS_INIT_OPT_P):  Temporarily turn off.\n+\n+\t* java-tree.h (DECL FINAL):  New bit-field.\n+\t(METHOD_FINAL, FIELD_FINAL, CLASS_FINAL):  Define as DECL_FINAL.\n+\t(LOCAL_FINAL_P):  Use DECL_FINAL rather than old LOCAL_FINAL.\n+\t(DECL_INIT_CALLS_THIS):  New macro.\n+\t(struct lang_decl):  New bit-field init_calls_this.\n+\t(DECL_FUNCTION_ALL_FINAL_INITIALIZED, DECL_FIELD_FINAL_LIIC,\n+\tDECL_FIELD_FINAL_IERR, LOCAL_FINAL, TYPE_HAS_FINAL_VARIABLE\n+\t(DECL_BIT_INDEX):  Change to use pointer_alias_set since we now\n+\tuse it for both local variables and final fields.\n+\t(struct lang_decl_var):  Remove bit-fields final_liic, final_ierr,\n+\tand local_final.\n+\t(struct lang_type):  Remove hfv bit-field.\n+\t(check_for_initialization):  Change to return void.\n+\n+\t* java-tree.h (IS_ARRAY_LENGTH_ACCESS):  New macros.\n+\t* expr.c (build_java_array_length_access):  Set IS_ARRAY_LENGTH_ACCESS.\n+\t* check-init.c (final_assign_error):  New helper function.\n+\t(check_final_reassigned, check_init):  Use it.\n+\t(check_init):  Also check IS_ARRAY_LENGTH_ACCESS for ARRAY.length.\n+\t\n+\t* java-tree.h (struct lang_decl, struct lang_decl_var):  Change all\n+\tbit-fields to unsigned.\n+\n 2001-12-03  Per Bothner  <per@bothner.com>\n \n \t* parse.y (patch_binop):  Minor constant folding."}, {"sha": "e8329c96ed37ff622efe0cf10a8f9942c50b2cf7", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 334, "deletions": 82, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f88ccda2d6bba5651d3203aa88f88651b6e7ed2/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f88ccda2d6bba5651d3203aa88f88651b6e7ed2/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=4f88ccda2d6bba5651d3203aa88f88651b6e7ed2", "patch": "@@ -1,4 +1,4 @@\n-/* Code to test for \"definitive assignment\".\n+/* Code to test for \"definitive [un]assignment\".\n    Copyright (C) 1999, 2000, 2001  Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify\n@@ -30,8 +30,10 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"toplev.h\" /* Needed for fatal. */\n \n /* The basic idea is that we assign each local variable declaration\n-   an index, and then we pass around bitstrings, where the i'th bit\n-   is set if decl whose DECL_BIT_INDEX is i is definitely assigned. */\n+   and each blank final field an index, and then we pass around\n+   bitstrings, where the (2*i)'th bit is set if decl whose DECL_BIT_INDEX\n+   is i is definitely assigned, and the the (2*i=1)'th bit is set if \n+   decl whose DECL_BIT_INDEX is i is definitely unassigned */\n \n /* One segment of a bitstring. */\n typedef unsigned int word;\n@@ -40,7 +42,11 @@ typedef unsigned int word;\n typedef word *words;\n \n /* Number of locals variables currently active. */\n-int num_current_locals = 0;\n+static int num_current_locals = 0;\n+\n+/* The value of num_current_locals when we entered the closest\n+   enclosing LOOP_EXPR. */\n+static int loop_current_locals;\n \n /* The index of the first local variable in the current block.\n \n@@ -62,9 +68,9 @@ int num_current_locals = 0;\n    even for methods with thousands of local variables, as\n    long as most of them are initialized immediately after or in\n    their declaration. */\n-int start_current_locals = 0;\n+static int start_current_locals = 0;\n \n-int num_current_words = 1;\n+static int num_current_words;\n \n static tree wfl;\n \n@@ -98,28 +104,120 @@ static void check_cond_init PARAMS ((tree, tree, tree, words, words, words));\n static void check_bool2_init PARAMS ((enum tree_code, tree, tree, words, words, words));\n struct alternatives;\n static void done_alternative PARAMS ((words, struct alternatives *));\n+static tree get_variable_decl PARAMS ((tree));\n+static void final_assign_error PARAMS ((tree));\n+static void check_final_reassigned PARAMS ((tree, words));\n \n-#if 0\n #define ALLOC_WORDS(NUM) ((word*) xmalloc ((NUM) * sizeof (word)))\n #define FREE_WORDS(PTR) (free (PTR))\n-#else\n-#define ALLOC_WORDS(NUM) ((word*)alloca ((NUM) * sizeof (word)))\n-#define FREE_WORDS(PTR) ((void)0)\n-#endif\n+\n+/* DECLARE_BUFFERS is used to allocate NUMBUFFER bit sets, each of\n+   which is an array of length num_current_words number of words.\n+   Declares a new local variable BUFFER to hold the result (or rather\n+   a pointer to the first of the bit sets).  In almost all cases\n+   num_current_words will be 1 or at most 2, so we try to stack\n+   allocate the arrays in that case, using a stack array\n+   named BUFFER##_short.  Each DECLARE_BUFFERS must be matched by\n+   a corresponding RELEASE_BUFFERS to avoid memory leaks.  */\n+\n+#define DECLARE_BUFFERS(BUFFER, NUMBUFFERS) \\\n+  word BUFFER##_short[2 * NUMBUFFERS]; \\\n+  words BUFFER = ALLOC_BUFFER(BUFFER##_short, NUMBUFFERS * num_current_words)\n+\n+#define RELEASE_BUFFERS(BUFFER) \\\n+  FREE_BUFFER(BUFFER, BUFFER##_short)\n+\n+#define ALLOC_BUFFER(SHORTBUFFER, NUMWORDS) \\\n+  ((NUMWORDS) * sizeof(word) <= sizeof(SHORTBUFFER) ? SHORTBUFFER \\\n+   : ALLOC_WORDS(NUMWORDS))\n+\n+#define FREE_BUFFER(BUFFER, SHORTBUFFER) \\\n+  if (BUFFER != SHORTBUFFER) FREE_WORDS(BUFFER)\n \n #define SET_P(WORDS, BIT) \\\n-  (WORDS[BIT / WORD_SIZE] & (1 << (BIT % WORD_SIZE)))\n+  (WORDS[(BIT) / WORD_SIZE] & (1 << ((BIT) % WORD_SIZE)))\n \n #define CLEAR_BIT(WORDS, BIT) \\\n-  (WORDS[BIT / WORD_SIZE] &= ~ (1 << (BIT % WORD_SIZE)))\n+  (WORDS[(BIT) / WORD_SIZE] &= ~ (1 << ((BIT) % WORD_SIZE)))\n \n #define SET_BIT(WORDS, BIT) \\\n-  (WORDS[BIT / WORD_SIZE] |= (1 << (BIT % WORD_SIZE)))\n+  (WORDS[(BIT) / WORD_SIZE] |= (1 << ((BIT) % WORD_SIZE)))\n \n #define WORDS_NEEDED(BITS) (((BITS)+(WORD_SIZE-1))/(WORD_SIZE))\n \n+#define ASSIGNED_P(WORDS, BIT)  SET_P(WORDS, 2 * (BIT))\n+#define UNASSIGNED_P(WORDS, BIT)  SET_P(WORDS, 2 * (BIT) + 1)\n+\n+#define SET_ASSIGNED(WORDS, INDEX) SET_BIT (WORDS, 2 * (INDEX))\n+#define SET_UNASSIGNED(WORDS, INDEX) SET_BIT (WORDS, 2 * (INDEX) + 1)\n+\n+#define CLEAR_ASSIGNED(WORDS, INDEX) CLEAR_BIT (WORDS, 2 * (INDEX))\n+#define CLEAR_UNASSIGNED(WORDS, INDEX) CLEAR_BIT (WORDS, 2 * (INDEX) + 1)\n+\n+/* Get the \"interesting\" declaration from a MODIFY_EXPR or COMPONENT_REF.\n+   Return the declaration or NULL_TREE if no interesting declaration.  */\n+\n+static tree\n+get_variable_decl (exp)\n+     tree exp;\n+{\n+  if (TREE_CODE (exp) == VAR_DECL)\n+    {\n+      if (! TREE_STATIC (exp) ||  FIELD_FINAL (exp))\n+\treturn exp;\n+    }\n+  /* We only care about final parameters. */\n+  else if (TREE_CODE (exp) == PARM_DECL)\n+    {\n+      if (DECL_FINAL (exp))\n+\treturn exp;\n+    }\n+  /* See if exp is this.field. */\n+  else if (TREE_CODE (exp) == COMPONENT_REF)\n+    {\n+      tree op0 = TREE_OPERAND (exp, 0);\n+      tree op1 = TREE_OPERAND (exp, 1);\n+      tree mdecl = current_function_decl;\n+      if (TREE_CODE (op0) == INDIRECT_REF\n+\t  && TREE_CODE (op1) == FIELD_DECL\n+\t  && ! METHOD_STATIC (mdecl)\n+\t  && FIELD_FINAL (op1))\n+\t{\n+\t  op0 = TREE_OPERAND (op0, 0);\n+\t  if (op0 == BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (mdecl)))\n+\t    return op1;\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+static void\n+final_assign_error (name)\n+     tree name;\n+{\n+  static const char format[]\n+    = \"can't re-assign here a value to the final variable '%s'\";\n+  parse_error_context (wfl, format, IDENTIFIER_POINTER (name));\n+}\n+\n+static void\n+check_final_reassigned (decl, before)\n+     tree decl;\n+     words before;\n+{\n+  int index = DECL_BIT_INDEX (decl);\n+  /* A final local already assigned or a final parameter\n+     assigned must be reported as errors */\n+  if (DECL_FINAL (decl) && index != -2\n+      && (index < loop_current_locals /* I.e. -1, or outside current loop. */\n+\t  || ! UNASSIGNED_P (before, index)))\n+    {\n+      final_assign_error (DECL_NAME (decl));\n+    }\n+}\n+\n /* Check a conditional form (TEST_EXP ? THEN_EXP : ELSE_EXP) for\n-   definite assignment.\n+   definite [un]assignment.\n    BEFORE, WHEN_FALSE, and WHEN_TRUE are as in check_bool_init. */\n \n static void\n@@ -128,19 +226,22 @@ check_cond_init (test_exp, then_exp, else_exp,\n      tree test_exp, then_exp, else_exp;\n      words before, when_false, when_true;\n {\n-  words tmp = ALLOC_WORDS (6 * num_current_words);\n-  words test_false = tmp;\n-  words test_true = tmp + num_current_words;\n-  words then_false = tmp + 2 * num_current_words;\n-  words then_true = tmp + 3 * num_current_words;\n-  words else_false = tmp + 4 * num_current_words;\n-  words else_true = tmp + 5 * num_current_words;\n+  int save_start_current_locals = start_current_locals;\n+  DECLARE_BUFFERS(test_false, 6);\n+  words test_true = test_false + num_current_words;\n+  words then_false = test_true + num_current_words;\n+  words then_true = then_false + num_current_words;\n+  words else_false = then_true + num_current_words;\n+  words else_true = else_false + num_current_words;\n+  start_current_locals = num_current_locals;\n+\n   check_bool_init (test_exp, before, test_false, test_true);\n   check_bool_init (then_exp, test_true, then_false, then_true);\n   check_bool_init (else_exp, test_false, else_false, else_true);\n   INTERSECT (when_false, then_false, else_false);\n   INTERSECT (when_true, then_true, else_true);\n-  FREE_WORDS (tmp);\n+  RELEASE_BUFFERS(test_false);\n+  start_current_locals = save_start_current_locals;\n }\n \n /* Check a boolean binary form CODE (EXP0, EXP1),\n@@ -152,8 +253,8 @@ check_bool2_init (code, exp0, exp1, before, when_false, when_true)\n      enum tree_code code;  tree exp0, exp1;\n      words before, when_false, when_true;\n {\n-  word buf[4];\n-  words tmp = num_current_words <= 1 ? buf\n+  word buf[2*4];\n+  words tmp = num_current_words <= 2 ? buf\n     : ALLOC_WORDS (4 * num_current_words);\n   words when_false_0 = tmp;\n   words when_false_1 = tmp+num_current_words;\n@@ -204,12 +305,12 @@ check_bool2_init (code, exp0, exp1, before, when_false, when_true)\n     FREE_WORDS (tmp);\n }\n \n-/* Check a boolean expression EXP for definite assignment.\n-   BEFORE is the set of variables definitely assigned before the conditional.\n-   (This bitstring may be modified arbitrarily in this function.)\n-   On output, WHEN_FALSE is the set of variables definitely assigned after\n+/* Check a boolean expression EXP for definite [un]assignment.\n+   BEFORE is the set of variables definitely [un]assigned before the\n+   conditional.  (This bitstring may be modified arbitrarily in this function.)\n+   On output, WHEN_FALSE is the set of variables [un]definitely assigned after\n    the conditional when the conditional is false.\n-   On output, WHEN_TRUE is the set of variables definitely assigned after\n+   On output, WHEN_TRUE is the set of variables definitely [un]assigned after\n    the conditional when the conditional is true.\n    (WHEN_FALSE and WHEN_TRUE are overwritten with initial values ignored.)\n    (None of BEFORE, WHEN_FALSE, or WHEN_TRUE can overlap, as they may\n@@ -244,16 +345,19 @@ check_bool_init (exp, before, when_false, when_true)\n     case MODIFY_EXPR:\n       {\n \ttree tmp = TREE_OPERAND (exp, 0);\n-\tif (TREE_CODE (tmp) == VAR_DECL && ! FIELD_STATIC (tmp))\n+\tif ((tmp = get_variable_decl (tmp)) != NULL_TREE)\n \t  {\n \t    int index;\n \t    check_bool_init (TREE_OPERAND (exp, 1), before,\n \t\t\t     when_false, when_true);\n+\t    check_final_reassigned (tmp, before);\n \t    index = DECL_BIT_INDEX (tmp);\n \t    if (index >= 0)\n \t      {\n-\t\tSET_BIT (when_false, index);\n-\t\tSET_BIT (when_true, index);\n+\t\tSET_ASSIGNED (when_false, index);\n+\t\tSET_ASSIGNED (when_true, index);\n+\t\tCLEAR_UNASSIGNED (when_false, index);\n+\t\tCLEAR_UNASSIGNED (when_true, index);\n \t      }\n \t    break;\n \t  }\n@@ -325,6 +429,10 @@ struct alternatives\n \n struct alternatives * alternatives = NULL;\n \n+/* Begin handling a control flow branch.\n+   BEFORE is the state of [un]assigned variables on entry.\n+   CURRENT is a struct alt to manage the branch alternatives. */\n+\n #define BEGIN_ALTERNATIVES(before, current) \\\n { \\\n   current.saved = NULL; \\\n@@ -338,15 +446,23 @@ struct alternatives * alternatives = NULL;\n   start_current_locals = num_current_locals; \\\n }\n \n+/* We have finished with one branch of branching control flow.\n+   Store the [un]assigned state, merging (intersecting) it with the state\n+   of previous alternative branches. */\n+\n static void\n done_alternative (after, current)\n      words after;\n      struct alternatives *current; \n {\n   INTERSECTN (current->combined, current->combined, after,\n-\t      WORDS_NEEDED (current->num_locals));\n+\t      WORDS_NEEDED (2 * current->num_locals));\n }\n \n+/* Used when we done with a control flow branch and are all merged again.\n+ * AFTER is the merged state of [un]assigned variables,\n+   CURRENT is a struct alt that was passed to BEGIN_ALTERNATIVES. */\n+\n #define END_ALTERNATIVES(after, current) \\\n { \\\n   alternatives = current.outer; \\\n@@ -368,48 +484,62 @@ check_init (exp, before)\n   switch (TREE_CODE (exp))\n     {\n     case VAR_DECL:\n-      if (! FIELD_STATIC (exp) && DECL_NAME (exp) != NULL_TREE)\n+    case PARM_DECL:\n+      if (! FIELD_STATIC (exp) && DECL_NAME (exp) != NULL_TREE\n+\t  && DECL_NAME (exp) != this_identifier_node)\n \t{\n \t  int index = DECL_BIT_INDEX (exp);\n-\t  /* We don't want to report and mark as non initialized flags\n-\t     the are, they will be marked initialized later on when\n-\t     assigned to `true.' */\n-\t  if ((STATIC_CLASS_INIT_OPT_P ()\n-\t       && ! LOCAL_CLASS_INITIALIZATION_FLAG_P (exp))\n-\t      && index >= 0 && ! SET_P (before, index))\n+\t  /* We don't want to report and mark as non initialized class\n+\t     initialization flags. */\n+\t  if (! LOCAL_CLASS_INITIALIZATION_FLAG_P (exp)\n+\t      && index >= 0 && ! ASSIGNED_P (before, index))\n \t    {\n \t      parse_error_context \n \t\t(wfl, \"Variable `%s' may not have been initialized\",\n \t\t IDENTIFIER_POINTER (DECL_NAME (exp)));\n \t      /* Suppress further errors. */\n-\t      DECL_BIT_INDEX (exp) = -1;\n+\t      DECL_BIT_INDEX (exp) = -2;\n \t    }\n \t}\n       break;\n+\n+    case COMPONENT_REF:\n+      check_init (TREE_OPERAND (exp, 0), before);\n+      if ((tmp = get_variable_decl (exp)) != NULL_TREE)\n+\t{\n+\t  int index = DECL_BIT_INDEX (tmp);\n+\t  if (index >= 0 && ! ASSIGNED_P (before, index))\n+\t    {\n+\t      parse_error_context \n+\t\t(wfl, \"variable '%s' may not have been initialized\",\n+\t\t IDENTIFIER_POINTER (DECL_NAME (tmp)));\n+\t      /* Suppress further errors. */\n+\t      DECL_BIT_INDEX (tmp) = -2;\n+\t    }\n+\t}\n+      break;\n+      \n     case MODIFY_EXPR:\n       tmp = TREE_OPERAND (exp, 0);\n       /* We're interested in variable declaration and parameter\n          declaration when they're declared with the `final' modifier. */\n-      if ((TREE_CODE (tmp) == VAR_DECL && ! FIELD_STATIC (tmp))\n-\t  || (TREE_CODE (tmp) == PARM_DECL && LOCAL_FINAL_P (tmp)))\n+      if ((tmp = get_variable_decl (tmp)) != NULL_TREE)\n \t{\n \t  int index;\n \t  check_init (TREE_OPERAND (exp, 1), before);\n+\t  check_final_reassigned (tmp, before);\n \t  index = DECL_BIT_INDEX (tmp);\n-\t  /* A final local already assigned or a final parameter\n-             assigned must be reported as errors */\n-\t  if (LOCAL_FINAL_P (tmp)\n-\t      && (index == -1 || TREE_CODE (tmp) == PARM_DECL))\n-\t    parse_error_context (wfl, \"Can't assign here a value to the `final' variable `%s'\", IDENTIFIER_POINTER (DECL_NAME (tmp)));\n-\n \t  if (index >= 0)\n-\t    SET_BIT (before, index);\n+\t    {\n+\t      SET_ASSIGNED (before, index);\n+\t      CLEAR_UNASSIGNED (before, index);\n+\t    }\n \t  /* Minor optimization.  See comment for start_current_locals.\n \t     If we're optimizing for class initialization, we keep\n \t     this information to check whether the variable is\n \t     definitely assigned when once we checked the whole\n \t     function. */\n-\t  if (! STATIC_CLASS_INIT_OPT_P ()\n+\t  if (! STATIC_CLASS_INIT_OPT_P () /* FIXME */\n \t      && index >= start_current_locals\n \t      && index == num_current_locals - 1)\n \t    {\n@@ -418,6 +548,22 @@ check_init (exp, before)\n \t    }\n \t break;\n        }\n+      else if (TREE_CODE (tmp = TREE_OPERAND (exp, 0)) == COMPONENT_REF)\n+\t{\n+\t  tree decl;\n+\t  check_init (tmp, before);\n+\t  check_init (TREE_OPERAND (exp, 1), before);\n+\t  decl = TREE_OPERAND (tmp, 1);\n+\t  if (DECL_FINAL (decl))\n+\t    final_assign_error (DECL_NAME (decl));\n+\t  break;\n+\t}\n+      else if (TREE_CODE (tmp) == INDIRECT_REF && IS_ARRAY_LENGTH_ACCESS (tmp))\n+\t{\n+\t  /* We can't emit a more specific message here, because when\n+\t     compiling to bytecodes we don't get here. */\n+\t  final_assign_error (length_identifier_node);\n+\t}\n      else\n        goto binop;\n     case BLOCK:\n@@ -434,7 +580,7 @@ check_init (exp, before)\n \t    {\n \t      DECL_BIT_INDEX (decl) = num_current_locals++;\n \t    }\n-\t  words_needed = WORDS_NEEDED (num_current_locals);\n+\t  words_needed = WORDS_NEEDED (2 * num_current_locals);\n \t  if (words_needed > num_current_words)\n \t    {\n \t      tmp = ALLOC_WORDS (words_needed);\n@@ -444,7 +590,10 @@ check_init (exp, before)\n \t  else\n \t    tmp = before;\n \t  for (i = start_current_locals;  i < num_current_locals;  i++)\n-\t    CLEAR_BIT (tmp, i);\n+\t    {\n+\t      CLEAR_ASSIGNED (tmp, i);\n+\t      SET_UNASSIGNED (tmp, i);\n+\t    }\n \t  check_init (BLOCK_EXPR_BODY (exp), tmp);\n \t  num_current_locals = start_current_locals;\n \t  start_current_locals = save_start_current_locals;\n@@ -454,31 +603,52 @@ check_init (exp, before)\n \t      COPY (before, tmp);\n \t      FREE_WORDS (tmp);\n \t    }\n+\n+\t  /* Re-set DECL_BIT_INDEX since it is also DECL_POINTER_ALIAS_SET. */\n+\t  for (decl = BLOCK_EXPR_DECLS (exp);\n+\t       decl != NULL_TREE;  decl = TREE_CHAIN (decl))\n+\t    {\n+\t      DECL_BIT_INDEX (decl) = -1;\n+\t    }\n \t}\n       break;\n     case LOOP_EXPR:\n       {\n+\t/* The JLS 2nd edition discusses a complication determining\n+\t   definite unassignment of loop statements.  They define a\n+\t   \"hypothetical\" analysis model.  We do something much\n+\t   simpler: We just disallow assignments inside loops to final\n+\t   variables declared outside the loop.  This means we may\n+\t   disallow some contrived assignments that the JLS, but I\n+\t   can't see how anything except a very contrived testcase (a\n+\t   do-while whose condition is false?) would care. */\n+\n \tstruct alternatives alt;\n+\tint save_loop_current_locals = loop_current_locals;\n+\tint save_start_current_locals = start_current_locals;\n+\tloop_current_locals = num_current_locals;\n+\tstart_current_locals = num_current_locals;\n \tBEGIN_ALTERNATIVES (before, alt);\n \talt.block = exp;\n \tcheck_init (TREE_OPERAND (exp, 0), before);\n \tEND_ALTERNATIVES (before, alt);\n+\tloop_current_locals = save_loop_current_locals;\n+\tstart_current_locals = save_start_current_locals;\n \treturn;\n       }\n     case EXIT_EXPR:\n       {\n \tstruct alternatives *alt = alternatives;\n-\twords tmp = ALLOC_WORDS (2 * num_current_words);\n-\twords when_true = tmp;\n-\twords when_false = tmp + num_current_words;\n+\tDECLARE_BUFFERS(when_true, 2);\n+\twords when_false = when_true + num_current_words;\n #ifdef ENABLE_JC1_CHECKING\n \tif (TREE_CODE (alt->block) != LOOP_EXPR)\n \t  abort ();\n #endif\n \tcheck_bool_init (TREE_OPERAND (exp, 0), before, when_false, when_true);\n \tdone_alternative (when_true, alt);\n \tCOPY (before, when_false);\n-\tFREE_WORDS (tmp);\n+\tRELEASE_BUFFERS(when_true);\n \treturn;\n       }\n     case LABELED_BLOCK_EXPR:\n@@ -505,14 +675,17 @@ check_init (exp, before)\n     case SWITCH_EXPR:\n       {\n \tstruct alternatives alt;\n+\tword buf[2];\n \tcheck_init (TREE_OPERAND (exp, 0), before);\n \tBEGIN_ALTERNATIVES (before, alt);\n-\talt.saved = ALLOC_WORDS (num_current_words);\n+\talt.saved = ALLOC_BUFFER(buf, num_current_words);\n \tCOPY (alt.saved, before);\n \talt.block = exp;\n \tcheck_init (TREE_OPERAND (exp, 1), before);\n \tdone_alternative (before, &alt);\n-\tFREE_WORDS (alt.saved);\n+\tFREE_BUFFER(alt.saved, buf);\n+\tif (alt.saved != buf)\n+\t  FREE_WORDS (alt.saved);\n \tEND_ALTERNATIVES (before, alt);\n \treturn;\n       }\n@@ -523,18 +696,20 @@ check_init (exp, before)\n \tstruct alternatives *alt = alternatives;\n \twhile (TREE_CODE (alt->block) != SWITCH_EXPR)\n \t  alt = alt->outer;\n-\tCOPYN (before, alt->saved, WORDS_NEEDED (alt->num_locals));\n+\tCOPYN (before, alt->saved, WORDS_NEEDED (2 * alt->num_locals));\n \tfor (i = alt->num_locals;  i < num_current_locals;  i++)\n-\t  CLEAR_BIT (before, i);\n+\t  CLEAR_ASSIGNED (before, i);\n \tbreak;\n       }\n \n     case TRY_EXPR:\n       {\n \ttree try_clause = TREE_OPERAND (exp, 0);\n \ttree clause = TREE_OPERAND (exp, 1);\n-\twords save = ALLOC_WORDS (num_current_words);\n-\twords tmp = ALLOC_WORDS (num_current_words);\n+\tword buf[2*2];\n+\twords tmp = (num_current_words <= 2 ? buf\n+\t\t    : ALLOC_WORDS (2 * num_current_words));\n+\twords save = tmp + num_current_words;\n \tstruct alternatives alt;\n \tBEGIN_ALTERNATIVES (before, alt);\n \tCOPY (save, before);\n@@ -548,20 +723,22 @@ check_init (exp, before)\n \t    check_init (catch_clause, tmp);\n \t    done_alternative (tmp, &alt);\n \t  }\n-\tFREE_WORDS (tmp);\n-\tFREE_WORDS (save);\n+\tif (tmp != buf)\n+\t  {\n+\t    FREE_WORDS (tmp);\n+\t  }\n \tEND_ALTERNATIVES (before, alt);\n       }\n     return;\n \n     case TRY_FINALLY_EXPR:\n       {\n-\twords tmp = ALLOC_WORDS (num_current_words);\n+\tDECLARE_BUFFERS(tmp, 1);\n \tCOPY (tmp, before);\n \tcheck_init (TREE_OPERAND (exp, 0), before);\n \tcheck_init (TREE_OPERAND (exp, 1), tmp);\n \tUNION (before, before, tmp);\n-\tFREE_WORDS (tmp);\n+\tRELEASE_BUFFERS(tmp);\n       }\n       return;\n \n@@ -580,14 +757,18 @@ check_init (exp, before)\n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_ORIF_EXPR:\n       {\n-\twords tmp = ALLOC_WORDS (2 * num_current_words);\n-\twords when_true = tmp;\n-\twords when_false = tmp + num_current_words;\n+\tDECLARE_BUFFERS(when_true, 2);\n+\twords when_false = when_true + num_current_words;\n \tcheck_bool_init (exp, before, when_false, when_true);\n \tINTERSECT (before, when_false, when_true);\n-\tFREE_WORDS (tmp);\n+\tRELEASE_BUFFERS(when_true);\n       }\n       break;\n+\n+    case NOP_EXPR:\n+      if (exp == empty_stmt_node)\n+\tbreak;\n+      /* ... else fall through ... */\n     case UNARY_PLUS_EXPR:\n     case NEGATE_EXPR:\n     case TRUTH_AND_EXPR:\n@@ -596,9 +777,7 @@ check_init (exp, before)\n     case TRUTH_NOT_EXPR:\n     case BIT_NOT_EXPR:\n     case CONVERT_EXPR:\n-    case COMPONENT_REF:\n     case BIT_FIELD_REF:\n-    case NOP_EXPR:\n     case FLOAT_EXPR:\n     case FIX_TRUNC_EXPR:\n     case INDIRECT_REF:\n@@ -662,7 +841,6 @@ check_init (exp, before)\n       exp = TREE_OPERAND (exp, 1);\n       goto again;\n \n-    case PARM_DECL:\n     case RESULT_DECL:\n     case FUNCTION_DECL:\n     case INTEGER_CST:\n@@ -720,13 +898,87 @@ check_init (exp, before)\n     }\n }\n \n-unsigned int\n-check_for_initialization (body)\n-     tree body;\n+void\n+check_for_initialization (body, mdecl)\n+     tree body, mdecl;\n {\n-  word before = 0;\n-  check_init (body, &before);\n-  return before;\n+  tree decl;\n+  word buf[2];\n+  words before = buf;\n+  tree owner = DECL_CONTEXT (mdecl);\n+  int is_static_method = METHOD_STATIC (mdecl);\n+  /* We don't need to check final fields of <init> it it calls this(). */\n+  int is_finit_method = DECL_FINIT_P (mdecl) || DECL_INSTINIT_P (mdecl);\n+  int is_init_method\n+    = (is_finit_method || DECL_CLINIT_P (mdecl)\n+       || (DECL_INIT_P (mdecl) && ! DECL_INIT_CALLS_THIS (mdecl)));\n+\n+  start_current_locals = num_current_locals = 0;\n+  num_current_words = 2;\n+\n+  if (is_init_method)\n+    {\n+      int words_needed, i;\n+      for (decl = TYPE_FIELDS (owner);\n+\t   decl != NULL_TREE;  decl = TREE_CHAIN (decl))\n+\t{\n+\t  if (DECL_FINAL (decl) && FIELD_STATIC (decl) == is_static_method)\n+\t    {\n+\t      if (DECL_FIELD_FINAL_IUD (decl))\n+\t\tDECL_BIT_INDEX (decl) = -1;\n+\t      else\n+\t\tDECL_BIT_INDEX (decl) = num_current_locals++;\n+\t    }\n+\t}\n+      words_needed = WORDS_NEEDED (2 * num_current_locals);\n+      if (words_needed > 2)\n+\t{\n+\t  num_current_words = words_needed;\n+\t  before = ALLOC_WORDS(words_needed);\n+\t}\n+      i = 0;\n+      for (decl = TYPE_FIELDS (owner);\n+\t   decl != NULL_TREE;  decl = TREE_CHAIN (decl))\n+\t{\n+\t  if (FIELD_FINAL (decl) && FIELD_STATIC (decl) == is_static_method)\n+\t    {\n+\t      if (! DECL_FIELD_FINAL_IUD (decl))\n+\t\t{\n+\t\t  CLEAR_ASSIGNED (before, i);\n+\t\t  SET_UNASSIGNED (before, i);\n+\t\t  i++;\n+\t\t}\n+\t    }\n+\t}\n+\n+    }\n+\n+  check_init (body, before);\n+\n+  if (is_init_method)\n+    {\n+      for (decl = TYPE_FIELDS (owner);\n+\t   decl != NULL_TREE;  decl = TREE_CHAIN (decl))\n+\t{\n+\t  if (FIELD_FINAL (decl) && FIELD_STATIC (decl) == is_static_method)\n+\t    {\n+\t      int index = DECL_BIT_INDEX (decl);\n+\t      if (index >= 0 && ! ASSIGNED_P (before, index))\n+\t\t{\n+\t\t  if (! is_finit_method)\n+\t\t    error_with_decl (decl, \"final field '%s' may not have been initialized\");\n+\t\t}\n+\t      else if (is_finit_method)\n+\t\tDECL_FIELD_FINAL_IUD (decl) = 1;\n+\n+\t      /* Re-set to initial state, since we later may use the\n+\t\t same bit for DECL_POINTER_ALIAS_SET. */\n+\t      DECL_BIT_INDEX (decl) = -1;\n+\t    }\n+\t}\n+    }\n+\n+  start_current_locals = num_current_locals = 0;\n }\n \n /* Call for every element in DECL_FUNCTION_INITIALIZED_CLASS_TABLE of\n@@ -747,7 +999,7 @@ attach_initialized_static_class (entry, ptr)\n      already added but escaped analysis.) */\n   if (fndecl && METHOD_STATIC (fndecl)\n       && (DECL_INITIAL (ite->init_test_decl) == boolean_true_node\n-\t  || (index >= 0 && SET_P (((word *) ptr), index))))\n+\t  || (index >= 0 && ASSIGNED_P (((word *) ptr), index))))\n     hash_lookup (&DECL_FUNCTION_INITIALIZED_CLASS_TABLE (fndecl),\n \t\t entry->key, TRUE, NULL);\n   return true;"}, {"sha": "78ca16562fdc31cbc202f99e9a85af9a300a7df5", "filename": "gcc/java/expr.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f88ccda2d6bba5651d3203aa88f88651b6e7ed2/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f88ccda2d6bba5651d3203aa88f88651b6e7ed2/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=4f88ccda2d6bba5651d3203aa88f88651b6e7ed2", "patch": "@@ -706,10 +706,12 @@ build_java_array_length_access (node)\n   length = java_array_type_length (type);\n   if (length >= 0)\n     return build_int_2 (length, 0);\n-  return fold (build1 (INDIRECT_REF, int_type_node,\n-\t\t       fold (build (PLUS_EXPR, ptr_type_node,\n-\t\t\t\t    java_check_reference (node, 1), \n-\t\t\t\t    JAVA_ARRAY_LENGTH_OFFSET(node)))));\n+  node = build1 (INDIRECT_REF, int_type_node,\n+\t\t fold (build (PLUS_EXPR, ptr_type_node,\n+\t\t\t      java_check_reference (node, 1), \n+\t\t\t      JAVA_ARRAY_LENGTH_OFFSET(node))));\n+  IS_ARRAY_LENGTH_ACCESS (node) = 1;\n+  return fold (node);\n }\n \n /* Optionally checks a reference against the NULL pointer.  ARG1: the"}, {"sha": "0ca0e3fa15f643dfed8e6062ffb9ccf6fbe76ee9", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 34, "deletions": 39, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f88ccda2d6bba5651d3203aa88f88651b6e7ed2/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f88ccda2d6bba5651d3203aa88f88651b6e7ed2/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=4f88ccda2d6bba5651d3203aa88f88651b6e7ed2", "patch": "@@ -63,6 +63,7 @@ struct JCF;\n    4: IS_A_COMMAND_LINE_FILENAME_P (in IDENTIFIER_NODE)\n       RESOLVE_TYPE_NAME_P (in EXPR_WITH_FILE_LOCATION)\n       CALL_USING_SUPER (in CALL_EXPR)\n+      IS_ARRAY_LENGTH_ACCESS (in INDIRECT_REF)\n    5: HAS_BEEN_ALREADY_PARSED_P (in IDENTIFIER_NODE)\n       IS_BREAK_STMT_P (in EXPR_WITH_FILE_LOCATION)\n       IS_CRAFTED_STRING_BUFFER_P (in CALL_EXPR)\n@@ -92,6 +93,7 @@ struct JCF;\n    3: METHOD_FINAL (in FUNCTION_DECL)\n       FIELD_FINAL (in FIELD_DECL)\n       CLASS_FINAL (in TYPE_DECL)\n+      DECL_FINAL (in any decl)\n    4: METHOD_SYNCHRONIZED (in FUNCTION_DECL).\n       LABEL_IN_SUBR (in LABEL_DECL)\n       CLASS_INTERFACE (in TYPE_DECL)\n@@ -476,6 +478,7 @@ extern tree java_global_trees[JTI_MAX];\n   java_global_trees[JTI_FINIT_IDENTIFIER_NODE]      /* \"finit$\" */\n #define finit_leg_identifier_node \\\n   java_global_trees[JTI_FINIT_LEG_IDENTIFIER_NODE]  /* \"$finit$\" */\n+/* FIXME \"instinit$\" and \"finit$\" should be merged  */\n #define instinit_identifier_node \\\n   java_global_trees[JTI_INSTINIT_IDENTIFIER_NODE]  /* \"instinit$\" */\n #define void_signature_node \\\n@@ -740,11 +743,11 @@ struct lang_identifier\n /* True if DECL is a synthetic ctor.  */\n #define DECL_FUNCTION_SYNTHETIC_CTOR(DECL) \\\n   (DECL_LANG_SPECIFIC(DECL)->synthetic_ctor)\n-/* True if DECL initializes all its finals */\n-#define DECL_FUNCTION_ALL_FINAL_INITIALIZED(DECL) \\\n-  (DECL_LANG_SPECIFIC(DECL)->init_final)\n #define DECL_FIXED_CONSTRUCTOR_P(DECL) (DECL_LANG_SPECIFIC(DECL)->fixed_ctor)\n \n+/* A constructor that calls this. */\n+#define DECL_INIT_CALLS_THIS(DECL) (DECL_LANG_SPECIFIC(DECL)->init_calls_this)\n+\n /* True when DECL aliases an outer context local variable.  */\n #define FIELD_LOCAL_ALIAS(DECL) DECL_LANG_FLAG_6 (DECL)\n \n@@ -824,29 +827,18 @@ struct lang_identifier\n /* Safely tests whether FIELD_INNER_ACCESS exists or not. */\n #define FIELD_INNER_ACCESS_P(DECL) \\\n   DECL_LANG_SPECIFIC (DECL) && FIELD_INNER_ACCESS (DECL)\n-/* True if a final variable was initialized upon its declaration. */\n+/* True if a final variable was initialized upon its declaration,\n+   or (if a field) in an initializer.  Set after definite assignment. */\n #define DECL_FIELD_FINAL_IUD(NODE) \\\n   (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->final_iud)\n-/* Set to true if a final variable is seen locally initialized on a\n-   ctor. */\n-#define DECL_FIELD_FINAL_LIIC(NODE) \\\n-  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->final_liic)\n-/* Set to true if an initialization error was already found with this\n-   final variable. */\n-#define DECL_FIELD_FINAL_IERR(NODE) \\\n-  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->final_ierr)\n /* The original WFL of a final variable. */\n #define DECL_FIELD_FINAL_WFL(NODE) \\\n   (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->wfl)\n-/* True if NODE is a local final (as opposed to a final variable.)\n-   This macro accesses the flag to read or set it. */\n-#define LOCAL_FINAL(NODE) \\\n-  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->local_final)\n-/* True if NODE is a local final. */\n-#define LOCAL_FINAL_P(NODE) (DECL_LANG_SPECIFIC (NODE) && LOCAL_FINAL (NODE))\n-/* True if NODE is a final variable. */\n+/* True if NODE is a local variable final. */\n+#define LOCAL_FINAL_P(NODE) (DECL_LANG_SPECIFIC (NODE) && DECL_FINAL (NODE))\n+/* True if NODE is a final field. */\n #define FINAL_VARIABLE_P(NODE) (FIELD_FINAL (NODE) && !FIELD_STATIC (NODE))\n-/* True if NODE is a class final variable. */\n+/* True if NODE is a class final field. */\n #define CLASS_FINAL_VARIABLE_P(NODE) \\\n   (FIELD_FINAL (NODE) && FIELD_STATIC (NODE))\n /* True if NODE is a class initialization flag. This macro accesses\n@@ -874,8 +866,9 @@ struct lang_identifier\n \n /* For a local VAR_DECL, holds the index into a words bitstring that\n    specifies if this decl is definitively assigned.\n-   A DECL_BIT_INDEX of -1 means we no longer care. */\n-#define DECL_BIT_INDEX(DECL) (DECL_CHECK (DECL)->decl.u2.i)\n+   The value -1 means the variable has been definitely assigned (and not\n+   definitely unassigned).  The value -2 means we already reported an error. */\n+#define DECL_BIT_INDEX(DECL) (DECL_CHECK (DECL)->decl.pointer_alias_set)\n \n /* DECL_LANG_SPECIFIC for FUNCTION_DECLs. */\n struct lang_decl\n@@ -899,10 +892,11 @@ struct lang_decl\n   tree inner_access;\t\t/* The identifier of the access method\n \t\t\t\t   used for invocation from inner classes */\n   int nap;\t\t\t/* Number of artificial parameters */\n-  int native : 1;\t\t/* Nonzero if this is a native method  */\n-  int synthetic_ctor : 1;\t/* Nonzero if this is a synthetic ctor */\n-  int init_final : 1;\t\t/* Nonzero all finals are initialized */\n-  int fixed_ctor : 1;\n+  unsigned int native : 1;\t/* Nonzero if this is a native method  */\n+  unsigned int synthetic_ctor : 1; /* Nonzero if this is a synthetic ctor */\n+  unsigned int init_final : 1;\t/* Nonzero all finals are initialized */\n+  unsigned int fixed_ctor : 1;\n+  unsigned int init_calls_this : 1;\n };\n \n /* init_test_table hash table entry structure.  */\n@@ -922,11 +916,8 @@ struct lang_decl_var\n   tree slot_chain;\n   tree am;\t\t\t/* Access method for this field (1.1) */\n   tree wfl;\t\t\t/* Original wfl */\n-  int final_iud : 1;\t\t/* Final initialized upon declaration */\n-  int final_liic : 1;\t\t/* Final locally initialized in ctors */\n-  int final_ierr : 1;\t\t/* Initialization error already detected */\n-  int local_final : 1;\t\t/* True if the decl is a local final */\n-  int cif : 1;\t\t\t/* True: decl is a class initialization flag */\n+  unsigned int final_iud : 1;\t/* Final initialized upon declaration */\n+  unsigned int cif : 1;\t\t/* True: decl is a class initialization flag */\n };\n \n /* Macro to access fields in `struct lang_type'.  */\n@@ -954,7 +945,6 @@ struct lang_decl_var\n #define TYPE_IMPORT_DEMAND_LIST(T) (TYPE_LANG_SPECIFIC(T)->import_demand_list)\n #define TYPE_PRIVATE_INNER_CLASS(T) (TYPE_LANG_SPECIFIC(T)->pic)\n #define TYPE_PROTECTED_INNER_CLASS(T) (TYPE_LANG_SPECIFIC(T)->poic)\n-#define TYPE_HAS_FINAL_VARIABLE(T) (TYPE_LANG_SPECIFIC(T)->hfv)\n \n struct lang_type\n {\n@@ -974,7 +964,6 @@ struct lang_type\n   tree import_demand_list;\t/* Imported types, in the CU of this class */\n   unsigned pic:1;\t\t/* Private Inner Class. */\n   unsigned poic:1;\t\t/* Protected Inner Class. */\n-  unsigned hfv:1;\t\t/* Has final variables */\n };\n \n #ifdef JAVA_USE_HANDLES\n@@ -1106,7 +1095,7 @@ extern void parse_error_context PARAMS ((tree cl, const char *, ...))\n   ATTRIBUTE_PRINTF_2;\n extern void finish_class PARAMS ((void));\n extern void java_layout_seen_class_methods PARAMS ((void));\n-extern unsigned int check_for_initialization PARAMS ((tree));\n+extern void check_for_initialization PARAMS ((tree, tree));\n \n extern tree pushdecl_top_level PARAMS ((tree));\n extern int alloc_class_constant PARAMS ((tree));\n@@ -1195,13 +1184,15 @@ struct rtx_def * java_lang_expand_expr PARAMS ((tree, rtx, enum machine_mode,\n \t\t\t\t\t       enum expand_modifier)); \n #endif /* TREE_CODE && RTX_CODE && HAVE_MACHINE_MODES && ARGS_SIZE_RTX */\n \n+#define DECL_FINAL(DECL) DECL_LANG_FLAG_3 (DECL)\n+\n /* Access flags etc for a method (a FUNCTION_DECL): */\n \n #define METHOD_PUBLIC(DECL) DECL_LANG_FLAG_1 (DECL)\n #define METHOD_PRIVATE(DECL) TREE_PRIVATE (DECL)\n #define METHOD_PROTECTED(DECL) TREE_PROTECTED (DECL)\n #define METHOD_STATIC(DECL) DECL_LANG_FLAG_2 (DECL)\n-#define METHOD_FINAL(DECL) DECL_LANG_FLAG_3 (DECL)\n+#define METHOD_FINAL(DECL) DECL_FINAL (DECL)\n #define METHOD_SYNCHRONIZED(DECL) DECL_LANG_FLAG_4 (DECL)\n #define METHOD_NATIVE(DECL) (DECL_LANG_SPECIFIC(DECL)->native)\n #define METHOD_ABSTRACT(DECL) DECL_LANG_FLAG_5 (DECL)\n@@ -1239,14 +1230,14 @@ struct rtx_def * java_lang_expand_expr PARAMS ((tree, rtx, enum machine_mode,\n #define FIELD_PROTECTED(DECL) TREE_PROTECTED (DECL)\n #define FIELD_PUBLIC(DECL) DECL_LANG_FLAG_1 (DECL)\n #define FIELD_STATIC(DECL) TREE_STATIC (DECL)\n-#define FIELD_FINAL(DECL) DECL_LANG_FLAG_3 (DECL)\n+#define FIELD_FINAL(DECL) DECL_FINAL (DECL)\n #define FIELD_VOLATILE(DECL) DECL_LANG_FLAG_4 (DECL)\n #define FIELD_TRANSIENT(DECL) DECL_LANG_FLAG_5 (DECL)\n \n /* Access flags etc for a class (a TYPE_DECL): */\n \n #define CLASS_PUBLIC(DECL) DECL_LANG_FLAG_1 (DECL)\n-#define CLASS_FINAL(DECL) DECL_LANG_FLAG_3 (DECL)\n+#define CLASS_FINAL(DECL) DECL_FINAL (DECL)\n #define CLASS_INTERFACE(DECL) DECL_LANG_FLAG_4 (DECL)\n #define CLASS_ABSTRACT(DECL) DECL_LANG_FLAG_5 (DECL)\n #define CLASS_SUPER(DECL) DECL_LANG_FLAG_6 (DECL)\n@@ -1350,6 +1341,9 @@ extern tree *type_map;\n /* True iff TYPE is a Java array type. */\n #define TYPE_ARRAY_P(TYPE) TYPE_LANG_FLAG_1 (TYPE)\n \n+/* True for an INDIRECT_REF created from a 'ARRAY.length' operation. */\n+#define IS_ARRAY_LENGTH_ACCESS(NODE) TREE_LANG_FLAG_4 (NODE)\n+\n /* If FUNCTION_TYPE or METHOD_TYPE: cache for build_java_argument_signature. */\n #define TYPE_ARGUMENT_SIGNATURE(TYPE) TYPE_VFIELD(TYPE)\n \n@@ -1610,9 +1604,10 @@ extern tree *type_map;\n \n /* True when we can perform static class initialization optimization */\n #define STATIC_CLASS_INIT_OPT_P() \\\n-  (flag_optimize_sci && (optimize >= 2) && ! flag_emit_class_files)\n+  0 /* ??? Temporarily turn off this optimization -PB */\n+/*  (flag_optimize_sci && (optimize >= 2) && ! flag_emit_class_files)*/\n \n-extern int java_error_count;\t\t\t\t\t\\\n+extern int java_error_count;\n \n /* Make the current function where this macro is invoked report error\n    messages and and return, if any */"}, {"sha": "11318be0218fa8f2897722a4518dbf6d4ece36d6", "filename": "gcc/java/parse.y", "status": "modified", "additions": 19, "deletions": 354, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f88ccda2d6bba5651d3203aa88f88651b6e7ed2/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f88ccda2d6bba5651d3203aa88f88651b6e7ed2/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=4f88ccda2d6bba5651d3203aa88f88651b6e7ed2", "patch": "@@ -101,12 +101,6 @@ static int process_imports PARAMS ((void));\n static void read_import_dir PARAMS ((tree));\n static int find_in_imports_on_demand PARAMS ((tree, tree));\n static void find_in_imports PARAMS ((tree, tree));\n-static void check_static_final_variable_assignment_flag PARAMS ((tree));\n-static void reset_static_final_variable_assignment_flag PARAMS ((tree));\n-static void check_final_variable_local_assignment_flag PARAMS ((tree, tree));\n-static void reset_final_variable_local_assignment_flag PARAMS ((tree));\n-static int  check_final_variable_indirect_assignment PARAMS ((tree));\n-static void check_final_variable_global_assignment_flag PARAMS ((tree));\n static void check_inner_class_access PARAMS ((tree, tree, tree));\n static int check_pkg_class_access PARAMS ((tree, tree, bool));\n static void register_package PARAMS ((tree));\n@@ -163,7 +157,6 @@ static tree build_method_invocation PARAMS ((tree, tree));\n static tree build_new_invocation PARAMS ((tree, tree));\n static tree build_assignment PARAMS ((int, int, tree, tree));\n static tree build_binop PARAMS ((enum tree_code, int, tree, tree));\n-static int check_final_assignment PARAMS ((tree ,tree));\n static tree patch_assignment PARAMS ((tree, tree));\n static tree patch_binop PARAMS ((tree, tree, tree));\n static tree build_unaryop PARAMS ((int, int, tree));\n@@ -415,7 +408,7 @@ static tree wpv_id;\n /* The list of all packages we've seen so far */\n static tree package_list = NULL_TREE;\n  \n-/* Hold THIS for the scope of the current public method decl.  */\n+/* Hold THIS for the scope of the current method decl.  */\n static tree current_this;\n \n /* Hold a list of catch clauses list. The first element of this list is\n@@ -4351,14 +4344,12 @@ register_fields (flags, type, variable_list)\n       /* If the field denotes a final instance variable, then we\n \t allocate a LANG_DECL_SPECIFIC part to keep track of its\n \t initialization. We also mark whether the field was\n-\t initialized upon it's declaration. We don't do that if the\n+\t initialized upon its declaration. We don't do that if the\n \t created field is an alias to a final local. */\n       if (!ARG_FINAL_P (current) && (flags & ACC_FINAL))\n \t{\n \t  MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (field_decl);\n \t  DECL_FIELD_FINAL_WFL (field_decl) = cl;\n-\t  if ((flags & ACC_STATIC) && init)\n-\t    DECL_FIELD_FINAL_IUD (field_decl) = 1;\n \t}\n \n       /* If the couple initializer/initialized is marked ARG_FINAL_P,\n@@ -7273,7 +7264,7 @@ declare_local_variables (modifier, type, vlist)\n \t will be entered */\n       decl = build_decl (VAR_DECL, name, real_type);\n       MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\n-      LOCAL_FINAL (decl) = final_p;\n+      DECL_FINAL (decl) = final_p;\n       BLOCK_CHAIN_DECL (decl);\n       \n       /* If doing xreferencing, replace the line number with the WFL\n@@ -7348,11 +7339,11 @@ source_start_java_method (fndecl)\n \tparm_decl = build_decl (PARM_DECL, name, type);\n \n       /* Remember if a local variable was declared final (via its\n-         TREE_LIST of type/name.) Set LOCAL_FINAL accordingly. */\n+         TREE_LIST of type/name.) Set DECL_FINAL accordingly. */\n       if (ARG_FINAL_P (tem))\n \t{\n \t  MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (parm_decl);\n-\t  LOCAL_FINAL (parm_decl) = 1;\n+\t  DECL_FINAL (parm_decl) = 1;\n \t}\n \n       BLOCK_CHAIN_DECL (parm_decl);\n@@ -7658,14 +7649,6 @@ java_complete_expand_methods (class_decl)\n \n   current_class = TREE_TYPE (class_decl);\n \n-  /* Find whether the class has final variables */\n-  for (decl = TYPE_FIELDS (current_class); decl; decl = TREE_CHAIN (decl))\n-    if (FIELD_FINAL (decl))\n-      {\n-\tTYPE_HAS_FINAL_VARIABLE (current_class) = 1;\n-\tbreak;\n-      }\n-\n   /* Initialize a new constant pool */\n   init_outgoing_cpool ();\n \n@@ -7700,16 +7683,8 @@ java_complete_expand_methods (class_decl)\n       if (no_body)\n \trestore_line_number_status (1);\n \n-      /* Reset the final local variable assignment flags */\n-      if (TYPE_HAS_FINAL_VARIABLE (current_class))\n-\treset_final_variable_local_assignment_flag (current_class);\n-\n       java_complete_expand_method (decl);\n \n-      /* Check for missed out final variable assignment */\n-      if (TYPE_HAS_FINAL_VARIABLE (current_class))\n-\tcheck_final_variable_local_assignment_flag (current_class, decl);\n-      \n       if (no_body)\n \trestore_line_number_status (0);\n     }\n@@ -7741,17 +7716,10 @@ java_complete_expand_methods (class_decl)\n   /* If there is indeed a <clinit>, fully expand it now */\n   if (clinit)\n     {\n-      /* Reset the final local variable assignment flags */\n-      if (TYPE_HAS_FINAL_VARIABLE (current_class))\n-\treset_static_final_variable_assignment_flag (current_class);\n       /* Prevent the use of `this' inside <clinit> */\n       ctxp->explicit_constructor_p = 1;\n       java_complete_expand_method (clinit);\n       ctxp->explicit_constructor_p = 0;\n-      /* Check for missed out static final variable assignment */\n-      if (TYPE_HAS_FINAL_VARIABLE (current_class)\n-\t  && !CLASS_INTERFACE (class_decl))\n-\tcheck_static_final_variable_assignment_flag (current_class);\n     }\n   \n   /* We might have generated a class$ that we now want to expand */\n@@ -7766,15 +7734,6 @@ java_complete_expand_methods (class_decl)\n \t  && verify_constructor_circularity (decl, decl))\n \tbreak;\n \n-  /* Final check on the initialization of final variables. */\n-  if (TYPE_HAS_FINAL_VARIABLE (current_class))\n-    {\n-      check_final_variable_global_assignment_flag (current_class);\n-      /* If we have an interface, check for uninitialized fields. */\n-      if (CLASS_INTERFACE (class_decl))\n-\tcheck_static_final_variable_assignment_flag (current_class);\n-    }\n-\n   /* Save the constant pool. We'll need to restore it later. */\n   TYPE_CPOOL (current_class) = outgoing_cpool;\n }\n@@ -8052,25 +8011,27 @@ java_complete_expand_method (mdecl)\n       \n       if (! flag_emit_xref && ! METHOD_NATIVE (mdecl))\n \t{\n-\t  unsigned int state = check_for_initialization (block_body);\n+\t  check_for_initialization (block_body, mdecl);\n \t  \n \t  /* Go through all the flags marking the initialization of\n \t     static variables and see whether they're definitively\n \t     assigned, in which case the type is remembered as\n \t     definitively initialized in MDECL. */\n+\t  /* FIXME this doesn't work state is too short.\n \t  if (STATIC_CLASS_INIT_OPT_P ())\n \t    {\n \t      hash_traverse (&DECL_FUNCTION_INIT_TEST_TABLE (mdecl),\n \t\t\t     attach_initialized_static_class, (PTR)&state);\n \n-\t      /* Always register the context as properly initialized in\n+\t      / * Always register the context as properly initialized in\n \t\t MDECL. This used with caution helps removing extra\n-\t\t initialization of self. */\n+\t\t initialization of self. * /\n \t      if (METHOD_STATIC (mdecl))\n \t\thash_lookup (&DECL_FUNCTION_INITIALIZED_CLASS_TABLE (mdecl),\n \t\t\t     (hash_table_key) DECL_CONTEXT (mdecl),\n \t\t\t     TRUE, NULL);\n \t    }\n+\t  */\n \t}\n       ctxp->explicit_constructor_p = 0;\n     }\n@@ -8292,14 +8253,6 @@ outer_field_access_fix (wfl, node, rhs)\n   \n   if (outer_field_expanded_access_p (node, &name, &arg_type, &arg))\n     {\n-      /* At any rate, check whether we're trying to assign a value to\n-\t a final. */\n-      tree accessed = (JDECL_P (node) ? node : \n-\t\t       (TREE_CODE (node) == COMPONENT_REF ? \n-\t\t\tTREE_OPERAND (node, 1) : node));\n-      if (check_final_assignment (accessed, wfl))\n-\treturn error_mark_node;\n-  \n       node = build_outer_field_access_expr (EXPR_WFL_LINECOL (wfl), \n \t\t\t\t\t    arg_type, name, arg, rhs);\n       return java_complete_tree (node);\n@@ -8886,6 +8839,8 @@ fix_constructors (mdecl)\n \t  TREE_OPERAND (found_call, 0) = empty_stmt_node;\n \t}\n       \n+      DECL_INIT_CALLS_THIS (mdecl) = invokes_this;\n+\n       /* Insert the instance initializer block right after. */\n       if (!invokes_this && (iii = build_instinit_invocation (class_type)))\n \tcompound = add_stmt_to_compound (compound, NULL_TREE, iii);\n@@ -11457,8 +11412,8 @@ java_complete_tree (node)\n       DECL_INITIAL (node) = value;\n       if (value != NULL_TREE)\n \t{\n-\t  /* fold_constant_for_init sometimes widen the original type\n-             of the constant (i.e. byte to int.) It's not desirable,\n+\t  /* fold_constant_for_init sometimes widens the original type\n+             of the constant (i.e. byte to int). It's not desirable,\n              especially if NODE is a function argument. */\n \t  if ((TREE_CODE (value) == INTEGER_CST\n \t       || TREE_CODE (value) == REAL_CST)\n@@ -11467,8 +11422,6 @@ java_complete_tree (node)\n \t  else\n \t    return value;\n \t}\n-      else\n-        DECL_FIELD_FINAL_IUD (node) = 0;\n     }\n   return node;\n }\n@@ -11662,7 +11615,7 @@ java_complete_lhs (node)\n \t\t\t\t       TREE_OPERAND (cn, 1));\n \t}\n       /* Accept final locals too. */\n-      else if (TREE_CODE (cn) == VAR_DECL && LOCAL_FINAL (cn))\n+      else if (TREE_CODE (cn) == VAR_DECL && DECL_FINAL (cn))\n \tcn = fold_constant_for_init (DECL_INITIAL (cn), cn);\n \n       if (!TREE_CONSTANT (cn) && !flag_emit_xref)\n@@ -11972,13 +11925,12 @@ java_complete_lhs (node)\n \t\t    DECL_INITIAL (nn) = patched;\n \t\t  else\n \t\t    DECL_INITIAL (nn) = TREE_OPERAND (node, 1);\n+\t\t  DECL_FIELD_FINAL_IUD (nn) = 1;\n \t\t  return empty_stmt_node;\n \t\t}\n \t    }\n \t  if (! flag_emit_class_files)\n \t    DECL_INITIAL (nn) = NULL_TREE;\n-\t  if (CLASS_FINAL_VARIABLE_P (nn))\n-\t    DECL_FIELD_FINAL_IUD (nn) = 0;\n \t}\n       wfl_op2 = TREE_OPERAND (node, 1);\n \n@@ -12056,9 +12008,6 @@ java_complete_lhs (node)\n \t}\n       else\n \t{\n-\t  /* Can't assign to a (blank) final. */\n-\t  if (check_final_assignment (TREE_OPERAND (node, 0), wfl_op1))\n-\t    return error_mark_node;\n \t  node = patch_assignment (node, wfl_op1);\n \t  /* Reorganize the tree if necessary. */\n \t  if (flag && (!JREFERENCE_TYPE_P (TREE_TYPE (node)) \n@@ -12541,271 +12490,9 @@ print_int_node (node)\n }\n \n \f\n-\n-/* This section of the code handle assignment check with FINAL\n-   variables.  */\n-\n-static void\n-reset_static_final_variable_assignment_flag (class)\n-     tree class;\n-{\n-  tree field;\n-  for (field = TYPE_FIELDS (class); field; field = TREE_CHAIN (field))\n-    if (CLASS_FINAL_VARIABLE_P (field))\n-      DECL_FIELD_FINAL_LIIC (field) = 0;\n-}\n-\n-/* Figure whether all final static variable have been initialized.  */\n-\n-static void\n-check_static_final_variable_assignment_flag (class)\n-     tree class;\n-{\n-  tree field;\n-\n-  for (field = TYPE_FIELDS (class); field; field = TREE_CHAIN (field))\n-    if (CLASS_FINAL_VARIABLE_P (field)\n-\t&& !DECL_FIELD_FINAL_IUD (field) && !DECL_FIELD_FINAL_LIIC (field))\n-      parse_error_context\n-\t(DECL_FIELD_FINAL_WFL (field),\n-\t \"Blank static final variable `%s' may not have been initialized\",\n-\t IDENTIFIER_POINTER (DECL_NAME (field)));\n-}\n-\n-/* This function marks all final variable locally unassigned.  */\n-\n-static void\n-reset_final_variable_local_assignment_flag (class)\n-     tree class;\n-{\n-  tree field;\n-  for (field = TYPE_FIELDS (class); field; field = TREE_CHAIN (field))\n-    if (FINAL_VARIABLE_P (field))\n-      DECL_FIELD_FINAL_LIIC (field) = 0;\n-}\n-\n-/* Figure whether all final variables have beem initialized in MDECL\n-   and mark MDECL accordingly.  */\n-\n-static void\n-check_final_variable_local_assignment_flag (class, mdecl)\n-     tree class;\n-     tree mdecl;\n-{\n-  tree field;\n-  int initialized = 0;\n-  int non_initialized = 0; \n-\n-  if (DECL_FUNCTION_SYNTHETIC_CTOR (mdecl))\n-    return;\n-\n-  /* First find out whether all final variables or no final variable\n-     are initialized in this ctor. We don't take into account final\n-     variable that have been initialized upon declaration.  */\n-  for (field = TYPE_FIELDS (class); field; field = TREE_CHAIN (field))\n-    if (FINAL_VARIABLE_P (field) && !DECL_FIELD_FINAL_IUD (field))\n-      {\n-\tif (DECL_FIELD_FINAL_LIIC (field))\n-\t  initialized++;\n-\telse\n-\t  non_initialized++;\n-      }\n-\n-  /* There were no non initialized variable and no initialized variable.\n-     This ctor is fine. */\n-  if (!non_initialized && !initialized)\n-    DECL_FUNCTION_ALL_FINAL_INITIALIZED (mdecl) = 1;\n-  /* If no variables have been initialized, that fine. We'll check\n-     later whether this ctor calls a constructor which initializes\n-     them. We mark the ctor as not initializing all its finals. */\n-  else if (initialized == 0)\n-    DECL_FUNCTION_ALL_FINAL_INITIALIZED (mdecl) = 0;\n-  /* If we have a mixed bag, then we have a problem. We need to report\n-     all the variables we're not initializing.  */\n-  else if (initialized && non_initialized)\n-    {\n-      DECL_FUNCTION_ALL_FINAL_INITIALIZED (mdecl) = 0;\n-      for (field = TYPE_FIELDS (class); field; field = TREE_CHAIN (field))\n-\tif (FIELD_FINAL (field)\n-\t    && !DECL_FIELD_FINAL_IUD (field) && !DECL_FIELD_FINAL_LIIC (field))\n-\t  {\n-\t    parse_error_context \n-\t      (lookup_cl (mdecl),\n-\t       \"Blank final variable `%s' may not have been initialized in this constructor\",\n-\t       IDENTIFIER_POINTER (DECL_NAME (field)));\n-\t    DECL_FIELD_FINAL_IERR (field) = 1;\n-\t  }\n-    }\n-  /* Otherwise we know this ctor is initializing all its final\n-     variable. We mark it so. */\n-  else\n-    DECL_FUNCTION_ALL_FINAL_INITIALIZED (mdecl) = 1;\n-}\n-\n-/* This function recurses in a simple what through STMT and stops when\n-   it finds a constructor call. It then verifies that the called\n-   constructor initialized its final properly. Return 1 upon success,\n-   0 or -1 otherwise.  */\n-\n-static int\n-check_final_variable_indirect_assignment (stmt)\n-     tree stmt;\n-{\n-  int res;\n-  switch (TREE_CODE (stmt))\n-    {\n-    case EXPR_WITH_FILE_LOCATION:\n-      return check_final_variable_indirect_assignment (EXPR_WFL_NODE (stmt));\n-    case COMPOUND_EXPR:\n-      res = check_final_variable_indirect_assignment (TREE_OPERAND (stmt, 0));\n-      if (res > 0)\n-\treturn res;\n-      return check_final_variable_indirect_assignment (TREE_OPERAND (stmt, 1));\n-    case SAVE_EXPR:\n-      return check_final_variable_indirect_assignment (TREE_OPERAND (stmt, 0));\n-    case CALL_EXPR:\n-      {\n-\ttree decl = TREE_OPERAND (stmt, 0);\n-\ttree fbody;\n-\n-\tif (TREE_CODE (decl) != FUNCTION_DECL)\n-\t  decl = TREE_OPERAND (TREE_OPERAND (decl, 0), 0);\n-\tif (TREE_CODE (decl) != FUNCTION_DECL)\n-\t  abort ();\n-\tif (DECL_FUNCTION_ALL_FINAL_INITIALIZED (decl))\n-\t  return 1;\n-\tif (DECL_FINIT_P (decl) || DECL_CONTEXT (decl) != current_class)\n-\t  return -1;\n-\tfbody = BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (decl));\n-\tif (fbody == error_mark_node)\n-\t  return -1;\n-\tfbody = BLOCK_EXPR_BODY (fbody);\n-\treturn check_final_variable_indirect_assignment (fbody);\n-      }\n-    default:\n-      break;\n-    }\n-  return 0;\n-}\n-\n-/* This is the last chance to catch a final variable initialization\n-   problem. This routine will report an error if a final variable was\n-   never (globally) initialized and never reported as not having been\n-   initialized properly. */\n-\n-static void\n-check_final_variable_global_assignment_flag (class)\n-     tree class;\n-{\n-  tree field, mdecl;\n-  int nnctor = 0;\n-  int error_found = 0;\n-\n-  /* We go through all natural ctors and see whether they're\n-     initializing all their final variables or not. */\n-  current_function_decl = NULL_TREE; /* For the error report. */\n-  for (mdecl = TYPE_METHODS (class); mdecl; mdecl = TREE_CHAIN (mdecl))\n-    if (DECL_CONSTRUCTOR_P (mdecl) && ! DECL_FUNCTION_SYNTHETIC_CTOR (mdecl))\n-      {\n-\tif (!DECL_FUNCTION_ALL_FINAL_INITIALIZED (mdecl))\n-\t  {\n-\t    /* It doesn't. Maybe it calls a constructor that initializes\n-\t       them.  find out. */\n-\t    tree fbody = BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl));\n-\t    if (fbody == error_mark_node)\n-\t      continue;\n-\t    fbody = BLOCK_EXPR_BODY (fbody);\n-\t    if (check_final_variable_indirect_assignment (fbody) == 1)\n-\t      {\n-\t\tDECL_FUNCTION_ALL_FINAL_INITIALIZED (mdecl) = 1;\n-\t\tnnctor++;\n-\t      }\n-\t    else\n-\t      {\n-\t\tparse_error_context\n-\t\t  (lookup_cl (mdecl),\n-\t\t   \"Final variable initialization error in this constructor\");\n-\t\terror_found = 1;\n-\t      }\n-\t  }\n-\telse\n-\t  nnctor++;\n-      }\n-\n-  /* Finally we catch final variables that never were initialized */\n-  for (field = TYPE_FIELDS (class); field; field = TREE_CHAIN (field))\n-    if (FINAL_VARIABLE_P (field)\n-\t/* If the field wasn't initialized upon declaration */\n-\t&& !DECL_FIELD_FINAL_IUD (field)\n-\t/* There wasn't a natural ctor in which the field could have been\n-\t   initialized or we found an error looking for one. */\n-\t&& (error_found || !nnctor)\n-\t/* If we never reported a problem with this field */\n-\t&& !DECL_FIELD_FINAL_IERR (field))\n-      {\n-\tcurrent_function_decl = NULL;\n-\tparse_error_context\n-\t  (DECL_FIELD_FINAL_WFL (field),\n-\t   \"Final variable `%s' hasn't been initialized upon its declaration\",\n-\t   IDENTIFIER_POINTER (DECL_NAME (field)));\n-      }\n-}\n-\n /* Return 1 if an assignment to a FINAL is attempted in a non suitable\n    context.  */\n \n-static int\n-check_final_assignment (lvalue, wfl)\n-     tree lvalue, wfl;\n-{\n-  if (TREE_CODE (lvalue) != COMPONENT_REF && !JDECL_P (lvalue))\n-    return 0;\n-\n-  if (TREE_CODE (lvalue) == COMPONENT_REF\n-      && JDECL_P (TREE_OPERAND (lvalue, 1)))\n-    lvalue = TREE_OPERAND (lvalue, 1);\n-\n-  if (!FIELD_FINAL (lvalue))\n-    return 0;\n-\n-  /* Now the logic. We can modify a final VARIABLE:\n-     1) in finit$, (its declaration was followed by an initialization,)\n-     2) consistently in each natural ctor, if it wasn't initialized in\n-        finit$ or once in <clinit>.  In any other cases, an error should be\n-\treported. */\n-  if (DECL_FINIT_P (current_function_decl))\n-    {\n-      DECL_FIELD_FINAL_IUD (lvalue) = 1;\n-      return 0;\n-    }\n-\n-  if (!DECL_FUNCTION_SYNTHETIC_CTOR (current_function_decl)\n-      /* Only if it wasn't given a value upon initialization */\n-      && DECL_LANG_SPECIFIC (lvalue) && !DECL_FIELD_FINAL_IUD (lvalue)\n-      /* If it was never assigned a value in this constructor */\n-      && !DECL_FIELD_FINAL_LIIC (lvalue))\n-    {\n-      /* Turn the locally assigned flag on, it will be checked later\n-\t on to point out at discrepancies. */\n-      DECL_FIELD_FINAL_LIIC (lvalue) = 1;\n-      if (DECL_CLINIT_P (current_function_decl))\n-\tDECL_FIELD_FINAL_IUD (lvalue) = 1;\n-      return 0;\n-    }\n-\n-  /* Other problems should be reported right away. */\n-  parse_error_context \n-    (wfl, \"Can't %sassign a value to the final variable `%s'\",\n-     (FIELD_STATIC (lvalue) ? \"re\" : \"\"),\n-     IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl)));\n-\n-  /* Note that static field can be initialized once and only once. */\n-  if (FIELD_STATIC (lvalue))\n-    DECL_FIELD_FINAL_IERR (lvalue) = 1;\n-\n-  return 1;\n-}\n-\n /* 15.25 Assignment operators. */\n \n static tree\n@@ -12844,15 +12531,7 @@ patch_assignment (node, wfl_op1)\n   else if (TREE_CODE (wfl_op1) == EXPR_WITH_FILE_LOCATION\n \t   && resolve_expression_name (wfl_op1, &llvalue))\n     {\n-      if (!error_found && check_final_assignment (llvalue, wfl_op1))\n-\t{\n-\t  /* What we should do instead is resetting the all the flags\n-\t     previously set, exchange lvalue for llvalue and continue. */\n-\t  error_found = 1;\n-\t  return error_mark_node;\n-\t}\n-      else \n-\tlhs_type = TREE_TYPE (lvalue);\n+      lhs_type = TREE_TYPE (lvalue);\n     }\n   else \n     {\n@@ -13003,7 +12682,7 @@ patch_assignment (node, wfl_op1)\n   /* Final locals can be used as case values in switch\n      statement. Prepare them for this eventuality. */\n   if (TREE_CODE (lvalue) == VAR_DECL \n-      && LOCAL_FINAL_P (lvalue)\n+      && DECL_FINAL (lvalue)\n       && TREE_CONSTANT (new_rhs)\n       && IDENTIFIER_LOCAL_VALUE (DECL_NAME (lvalue))\n       && JINTEGRAL_TYPE_P (TREE_TYPE (lvalue))\n@@ -14267,26 +13946,14 @@ patch_unaryop (node, wfl_op)\n \t       && TREE_OPERAND (decl, 1)\n \t       && (TREE_CODE (TREE_OPERAND (decl, 1)) == INDIRECT_REF)))\n \t{\n-\t  tree lvalue;\n-\t  /* Before screaming, check that we're not in fact trying to\n-\t     increment a optimized static final access, in which case\n-\t     we issue an different error message. */\n-\t  if (!(TREE_CODE (wfl_op) == EXPR_WITH_FILE_LOCATION\n-\t\t&& resolve_expression_name (wfl_op, &lvalue)\n-\t\t&& check_final_assignment (lvalue, wfl_op)))\n-\t    parse_error_context (wfl_operator, \"Invalid argument to `%s'\",\n-\t\t\t\t operator_string (node));\n \t  TREE_TYPE (node) = error_mark_node;\n \t  error_found = 1;\n \t}\n       \n-      if (check_final_assignment (op, wfl_op))\n-\terror_found = 1;\n-\n       /* From now on, we know that op if a variable and that it has a\n          valid wfl. We use wfl_op to locate errors related to the\n          ++/-- operand. */\n-      else if (!JNUMERIC_TYPE_P (op_type))\n+      if (!JNUMERIC_TYPE_P (op_type))\n \t{\n \t  parse_error_context\n \t    (wfl_op, \"Invalid argument type `%s' to `%s'\",\n@@ -16171,8 +15838,6 @@ fold_constant_for_init (node, context)\n       DECL_INITIAL (node) = NULL_TREE;\n       val = fold_constant_for_init (val, node);\n       DECL_INITIAL (node) = val;\n-      if (!val && CLASS_FINAL_VARIABLE_P (node))\n-\tDECL_FIELD_FINAL_IUD (node) = 0;\n       return val;\n \n     case EXPR_WITH_FILE_LOCATION:"}]}