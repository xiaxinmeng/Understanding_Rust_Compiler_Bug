{"sha": "2b907f5c4554c076038913e7c721ea8d6a8dcb31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI5MDdmNWM0NTU0YzA3NjAzODkxM2U3YzcyMWVhOGQ2YThkY2IzMQ==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2003-07-13T15:20:58Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2003-07-13T15:20:58Z"}, "message": "pt.c (push_access_scope_real): Remove.\n\n\t* pt.c (push_access_scope_real): Remove.\n\t(push_access_scope): Move code from push_access_scope_real.\n\t(pop_access_scope): Don't check for TEMPLATE_DECL.\n\t(instantiate_template): Defer access checking during template\n\tsubstitution.\n\t(regenerate_decl_from_template): Tidy.\n\nFrom-SVN: r69291", "tree": {"sha": "ce13981dd99c4ce196867c3b0624174f3860282e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce13981dd99c4ce196867c3b0624174f3860282e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b907f5c4554c076038913e7c721ea8d6a8dcb31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b907f5c4554c076038913e7c721ea8d6a8dcb31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b907f5c4554c076038913e7c721ea8d6a8dcb31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b907f5c4554c076038913e7c721ea8d6a8dcb31/comments", "author": null, "committer": null, "parents": [{"sha": "5245ad0cf75d72adfcc1f6796b3c7d33c2d42d56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5245ad0cf75d72adfcc1f6796b3c7d33c2d42d56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5245ad0cf75d72adfcc1f6796b3c7d33c2d42d56"}], "stats": {"total": 89, "additions": 35, "deletions": 54}, "files": [{"sha": "b275e8090d0330157a597be0a7ab9c45b4533353", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b907f5c4554c076038913e7c721ea8d6a8dcb31/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b907f5c4554c076038913e7c721ea8d6a8dcb31/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2b907f5c4554c076038913e7c721ea8d6a8dcb31", "patch": "@@ -1,3 +1,12 @@\n+2003-07-13  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\t* pt.c (push_access_scope_real): Remove.\n+\t(push_access_scope): Move code from push_access_scope_real.\n+\t(pop_access_scope): Don't check for TEMPLATE_DECL.\n+\t(instantiate_template): Defer access checking during template\n+\tsubstitution.\n+\t(regenerate_decl_from_template): Tidy.\n+\n 2003-07-11  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \tPR c++/11437"}, {"sha": "d7c56a2d557ae88c3f926a22589928b813a911ed", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 26, "deletions": 54, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b907f5c4554c076038913e7c721ea8d6a8dcb31/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b907f5c4554c076038913e7c721ea8d6a8dcb31/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2b907f5c4554c076038913e7c721ea8d6a8dcb31", "patch": "@@ -88,7 +88,6 @@ static htab_t local_specializations;\n #define GTB_IGNORE_TYPE 2 /* We don't need to try to unify the current\n \t\t\t     type with the desired type.  */\n \n-static void push_access_scope_real (tree, tree, tree);\n static void push_access_scope (tree);\n static void pop_access_scope (tree);\n static int resolve_overloaded_unification (tree, tree, tree, tree,\n@@ -173,71 +172,36 @@ static tree tsubst_copy\t(tree, tree, tsubst_flags_t, tree);\n \n /* Make the current scope suitable for access checking when we are\n    processing T.  T can be FUNCTION_DECL for instantiated function\n-   template, TEMPLATE_DECL for uninstantiated one, or VAR_DECL for\n-   static member variable (need by instantiate_decl).  ARGS is the \n-   template argument for TEMPLATE_DECL.  If CONTEXT is not NULL_TREE, \n-   this is used instead of the context of T.  */\n+   template, or VAR_DECL for static member variable (need by\n+   instantiate_decl).  */\n \n static void\n-push_access_scope_real (tree t, tree args, tree context)\n+push_access_scope (tree t)\n {\n-  if (TREE_CODE (t) == FUNCTION_DECL || DECL_FUNCTION_TEMPLATE_P (t))\n-    {\n-      /* When we are processing specialization `foo<Outer>' for code like\n-\n-\t   template <class U> typename U::Inner foo ();\n-\t   class Outer {\n-\t     struct Inner {};\n-\t     friend Outer::Inner foo<Outer> ();\n-\t   };\n-\n-\t `T' is a TEMPLATE_DECL, but `Outer' is only a friend of one of\n-\t its specialization.  We can get the FUNCTION_DECL with the right\n-\t information because this specialization has already been\n-\t registered by the friend declaration above.  */\n-\n-      if (DECL_FUNCTION_TEMPLATE_P (t) && args)\n-\t{\n-\t  tree full_args = tsubst_template_arg_vector\n-\t    (DECL_TI_ARGS (DECL_TEMPLATE_RESULT (t)), args, tf_none);\n-\t  tree spec = NULL_TREE;\n-\t  if (full_args != error_mark_node)\n-\t    spec = retrieve_specialization (t, full_args);\n-\t  if (spec)\n-\t    t = spec;\n-\t}\n-    }\n+  my_friendly_assert (TREE_CODE (t) == FUNCTION_DECL\n+\t\t      || TREE_CODE (t) == VAR_DECL,\n+\t\t      0);\n \n-  if (!context)\n-    context = DECL_CONTEXT (t);\n-  if (context && TYPE_P (context))\n-    push_nested_class (context);\n+  if (DECL_CLASS_SCOPE_P (t))\n+    push_nested_class (DECL_CONTEXT (t));\n   else\n     push_to_top_level ();\n     \n-  if (TREE_CODE (t) == FUNCTION_DECL || DECL_FUNCTION_TEMPLATE_P (t))\n+  if (TREE_CODE (t) == FUNCTION_DECL)\n     {\n       saved_access_scope = tree_cons\n \t(NULL_TREE, current_function_decl, saved_access_scope);\n       current_function_decl = t;\n     }\n }\n \n-/* Like push_access_scope_real, but always uses DECL_CONTEXT.  */\n-\n-static void\n-push_access_scope (tree t)\n-{\n-  push_access_scope_real (t, NULL_TREE, NULL_TREE);\n-}\n-\n /* Restore the scope set up by push_access_scope.  T is the node we\n    are processing.  */\n \n static void\n pop_access_scope (tree t)\n {\n-  if (TREE_CODE (t) == FUNCTION_DECL || DECL_FUNCTION_TEMPLATE_P (t))\n+  if (TREE_CODE (t) == FUNCTION_DECL)\n     {\n       current_function_decl = TREE_VALUE (saved_access_scope);\n       saved_access_scope = TREE_CHAIN (saved_access_scope);\n@@ -8509,18 +8473,23 @@ instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n \t\t\t       complain))\n     return error_mark_node;\n   \n-  /* Make sure that we can see identifiers, and compute access\n-     correctly.  The desired FUNCTION_DECL for FNDECL may or may not be\n-     created earlier.  Let push_access_scope_real figure that out.  */\n-  push_access_scope_real\n-    (gen_tmpl, targ_ptr, tsubst (DECL_CONTEXT (gen_tmpl), targ_ptr, \n-\t\t\t\t complain, gen_tmpl));\n+  /* We are building a FUNCTION_DECL, during which the access of its\n+     parameters and return types have to be checked.  However this\n+     FUNCTION_DECL which is the desired context for access checking\n+     is not built yet.  We solve this chicken-and-egg problem by\n+     deferring all checks until we have the FUNCTION_DECL.  */\n+  push_deferring_access_checks (dk_deferred);\n \n   /* substitute template parameters */\n   fndecl = tsubst (DECL_TEMPLATE_RESULT (gen_tmpl),\n \t\t   targ_ptr, complain, gen_tmpl);\n \n-  pop_access_scope (gen_tmpl);\n+  /* Now we know the specialization, compute access previously\n+     deferred.  */\n+  push_access_scope (fndecl);\n+  perform_deferred_access_checks ();\n+  pop_access_scope (fndecl);\n+  pop_deferring_access_checks ();\n \n   /* The DECL_TI_TEMPLATE should always be the immediate parent\n      template, not the most general template.  */\n@@ -10618,14 +10587,17 @@ regenerate_decl_from_template (tree decl, tree tmpl)\n      instantiation of a specialization, which it isn't: it's a full\n      instantiation.  */\n   gen_tmpl = most_general_template (tmpl);\n-  push_access_scope_real (gen_tmpl, args, DECL_CONTEXT (decl));\n   unregistered = unregister_specialization (decl, gen_tmpl);\n \n   /* If the DECL was not unregistered then something peculiar is\n      happening: we created a specialization but did not call\n      register_specialization for it.  */\n   my_friendly_assert (unregistered, 0);\n \n+  /* Make sure that we can see identifiers, and compute access\n+     correctly.  */\n+  push_access_scope (decl);\n+\n   /* Do the substitution to get the new declaration.  */\n   new_decl = tsubst (code_pattern, args, tf_error, NULL_TREE);\n "}]}