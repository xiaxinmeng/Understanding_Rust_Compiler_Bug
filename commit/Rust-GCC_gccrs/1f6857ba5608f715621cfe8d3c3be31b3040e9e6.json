{"sha": "1f6857ba5608f715621cfe8d3c3be31b3040e9e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY2ODU3YmE1NjA4ZjcxNTYyMWNmZThkM2MzYmUzMWIzMDQwZTllNg==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2019-02-17T16:52:40Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2019-02-17T16:52:40Z"}, "message": "PR c++/89217 - ICE with list-initialization in range-based for loop.\n\n\t* constexpr.c (unshare_constructor): No longer static.\n\t* cp-tree.h (unshare_constructor): Declare.\n\t* semantics.c (finish_compound_literal): When dealing with a\n\tnon-dependent expression in a template, return the original\n\texpression.  Pass LOOKUP_NO_NARROWING to digest_init_flags.\n\n\t* g++.dg/cpp0x/range-for37.C: New test.\n\nFrom-SVN: r268969", "tree": {"sha": "9dee916ca3c34d2ac5f7cf385af30f3daf880f59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9dee916ca3c34d2ac5f7cf385af30f3daf880f59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f6857ba5608f715621cfe8d3c3be31b3040e9e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6857ba5608f715621cfe8d3c3be31b3040e9e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f6857ba5608f715621cfe8d3c3be31b3040e9e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6857ba5608f715621cfe8d3c3be31b3040e9e6/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b43e6340c80f3ae0ddf70950a8f979f4791c3252", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b43e6340c80f3ae0ddf70950a8f979f4791c3252", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b43e6340c80f3ae0ddf70950a8f979f4791c3252"}], "stats": {"total": 81, "additions": 72, "deletions": 9}, "files": [{"sha": "d4e062539aff4995cb6183d55a4caf7e8d6ae758", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6857ba5608f715621cfe8d3c3be31b3040e9e6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6857ba5608f715621cfe8d3c3be31b3040e9e6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1f6857ba5608f715621cfe8d3c3be31b3040e9e6", "patch": "@@ -1,3 +1,12 @@\n+2019-02-17  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/89217 - ICE with list-initialization in range-based for loop.\n+\t* constexpr.c (unshare_constructor): No longer static.\n+\t* cp-tree.h (unshare_constructor): Declare.\n+\t* semantics.c (finish_compound_literal): When dealing with a\n+\tnon-dependent expression in a template, return the original\n+\texpression.  Pass LOOKUP_NO_NARROWING to digest_init_flags.\n+\n 2019-02-13  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/89297 - ICE with OVERLOAD in template."}, {"sha": "d946a797999b7df31934a2aca962e4e32ce2c3e0", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6857ba5608f715621cfe8d3c3be31b3040e9e6/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6857ba5608f715621cfe8d3c3be31b3040e9e6/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=1f6857ba5608f715621cfe8d3c3be31b3040e9e6", "patch": "@@ -1318,7 +1318,7 @@ find_constructor (tree *tp, int *walk_subtrees, void *)\n /* If T is a CONSTRUCTOR or an expression that has a CONSTRUCTOR node as a\n    subexpression, return an unshared copy of T.  Otherwise return T.  */\n \n-static tree\n+tree\n unshare_constructor (tree t)\n {\n   tree ctor = walk_tree (&t, find_constructor, NULL, NULL);"}, {"sha": "60ca1366cf63cf442112f3884a106a1bd200eb50", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6857ba5608f715621cfe8d3c3be31b3040e9e6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6857ba5608f715621cfe8d3c3be31b3040e9e6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1f6857ba5608f715621cfe8d3c3be31b3040e9e6", "patch": "@@ -7710,6 +7710,7 @@ extern void explain_invalid_constexpr_fn        (tree);\n extern vec<tree> cx_error_context               (void);\n extern tree fold_sizeof_expr\t\t\t(tree);\n extern void clear_cv_and_fold_caches\t\t(void);\n+extern tree unshare_constructor\t\t\t(tree);\n \n /* In cp-ubsan.c */\n extern void cp_ubsan_maybe_instrument_member_call (tree);"}, {"sha": "3ecd192bced7b8667f2092dca4b6471aa62895e8", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6857ba5608f715621cfe8d3c3be31b3040e9e6/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6857ba5608f715621cfe8d3c3be31b3040e9e6/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=1f6857ba5608f715621cfe8d3c3be31b3040e9e6", "patch": "@@ -2796,17 +2796,31 @@ finish_compound_literal (tree type, tree compound_literal,\n \t  return error_mark_node;\n       }\n \n-  if (instantiation_dependent_expression_p (compound_literal)\n-      || dependent_type_p (type))\n+  /* Used to hold a copy of the compound literal in a template.  */\n+  tree orig_cl = NULL_TREE;\n+\n+  if (processing_template_decl)\n     {\n-      TREE_TYPE (compound_literal) = type;\n+      const bool dependent_p\n+\t= (instantiation_dependent_expression_p (compound_literal)\n+\t   || dependent_type_p (type));\n+      if (dependent_p)\n+\t/* We're about to return, no need to copy.  */\n+\torig_cl = compound_literal;\n+      else\n+\t/* We're going to need a copy.  */\n+\torig_cl = unshare_constructor (compound_literal);\n+      TREE_TYPE (orig_cl) = type;\n       /* Mark the expression as a compound literal.  */\n-      TREE_HAS_CONSTRUCTOR (compound_literal) = 1;\n+      TREE_HAS_CONSTRUCTOR (orig_cl) = 1;\n       /* And as instantiation-dependent.  */\n-      CONSTRUCTOR_IS_DEPENDENT (compound_literal) = true;\n+      CONSTRUCTOR_IS_DEPENDENT (orig_cl) = dependent_p;\n       if (fcl_context == fcl_c99)\n-\tCONSTRUCTOR_C99_COMPOUND_LITERAL (compound_literal) = 1;\n-      return compound_literal;\n+\tCONSTRUCTOR_C99_COMPOUND_LITERAL (orig_cl) = 1;\n+      /* If the compound literal is dependent, we're done for now.  */\n+      if (dependent_p)\n+\treturn orig_cl;\n+      /* Otherwise, do go on to e.g. check narrowing.  */\n     }\n \n   type = complete_type (type);\n@@ -2842,8 +2856,18 @@ finish_compound_literal (tree type, tree compound_literal,\n       if (type == error_mark_node)\n \treturn error_mark_node;\n     }\n-  compound_literal = digest_init_flags (type, compound_literal, LOOKUP_NORMAL,\n+  compound_literal = digest_init_flags (type, compound_literal,\n+\t\t\t\t\tLOOKUP_NORMAL | LOOKUP_NO_NARROWING,\n \t\t\t\t\tcomplain);\n+  /* If we're in a template, return the original compound literal.  */\n+  if (orig_cl)\n+    {\n+      if (!VECTOR_TYPE_P (type))\n+\treturn get_target_expr_sfinae (orig_cl, complain);\n+      else\n+\treturn orig_cl;\n+    }\n+\n   if (TREE_CODE (compound_literal) == CONSTRUCTOR)\n     {\n       TREE_HAS_CONSTRUCTOR (compound_literal) = true;"}, {"sha": "38959b3248d1a954261f785b3ad277bac7c34e88", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6857ba5608f715621cfe8d3c3be31b3040e9e6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6857ba5608f715621cfe8d3c3be31b3040e9e6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1f6857ba5608f715621cfe8d3c3be31b3040e9e6", "patch": "@@ -1,3 +1,8 @@\n+2019-02-17  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/89217 - ICE with list-initialization in range-based for loop.\n+\t* g++.dg/cpp0x/range-for37.C: New test.\n+\n 2019-02-16  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c++/88680"}, {"sha": "d5c7c091d96afc3ecd4a9f1d3ccdc12098d56dfc", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for37.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6857ba5608f715621cfe8d3c3be31b3040e9e6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for37.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6857ba5608f715621cfe8d3c3be31b3040e9e6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for37.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for37.C?ref=1f6857ba5608f715621cfe8d3c3be31b3040e9e6", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/89217\n+// { dg-do compile { target c++11 } }\n+\n+struct R {};\n+\n+struct C\n+{\n+    R* begin() const { return &r; }\n+    R* end() const { return &r; }\n+\n+    R& r;\n+};\n+\n+struct S\n+{\n+    void f1() { f2<true>(); }\n+    R& r;\n+\n+    template<bool>\n+    void f2()\n+    {\n+        for (auto i : C{r}) {}\n+    }\n+};"}]}