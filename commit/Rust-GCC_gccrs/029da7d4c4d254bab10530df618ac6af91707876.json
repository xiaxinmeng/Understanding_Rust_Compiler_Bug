{"sha": "029da7d4c4d254bab10530df618ac6af91707876", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI5ZGE3ZDRjNGQyNTRiYWIxMDUzMGRmNjE4YWM2YWY5MTcwNzg3Ng==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-06-24T23:27:58Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-06-24T23:27:58Z"}, "message": "ira-int.h (ira_parent_allocno, [...]): Declare.\n\n\t* ira-int.h (ira_parent_allocno, ira_parent_or_cap_allocno): Declare.\n\t* ira-build.c (ira_parent_allocno, ira_parent_or_cap_allocno): New\n\tfunctions.\n\t(ira_flattening): Use ira_parent_allocno.\n\t* ira-conflicts.c (process_regs_for_copy, propagate_copies)\n\tbuild_allocno_conflicts): Use ira_parent_or_cap_allocno.\n\nFrom-SVN: r161347", "tree": {"sha": "01e336c2a7447c11643f8c1e81a8184f232b64dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01e336c2a7447c11643f8c1e81a8184f232b64dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/029da7d4c4d254bab10530df618ac6af91707876", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/029da7d4c4d254bab10530df618ac6af91707876", "html_url": "https://github.com/Rust-GCC/gccrs/commit/029da7d4c4d254bab10530df618ac6af91707876", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/029da7d4c4d254bab10530df618ac6af91707876/comments", "author": null, "committer": null, "parents": [{"sha": "3c55880a94aeb7595b6e109c406749f48791901e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c55880a94aeb7595b6e109c406749f48791901e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c55880a94aeb7595b6e109c406749f48791901e"}], "stats": {"total": 84, "additions": 51, "deletions": 33}, "files": [{"sha": "e807957ff8ad3ea62326e208f7b74519f932de8e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029da7d4c4d254bab10530df618ac6af91707876/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029da7d4c4d254bab10530df618ac6af91707876/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=029da7d4c4d254bab10530df618ac6af91707876", "patch": "@@ -26,6 +26,13 @@\n \t(make_regno_born, make_regno_dead, mark_reg_live, mark_reg_dead,\n \tset_allocno_live, clear_allocno_live): Delete functions.\n \n+\t* ira-int.h (ira_parent_allocno, ira_parent_or_cap_allocno): Declare.\n+\t* ira-build.c (ira_parent_allocno, ira_parent_or_cap_allocno): New\n+\tfunctions.\n+\t(ira_flattening): Use ira_parent_allocno.\n+\t* ira-conflicts.c (process_regs_for_copy, propagate_copies)\n+\tbuild_allocno_conflicts): Use ira_parent_or_cap_allocno.\n+\n 2010-06-24  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* thumb2.md (thumb2_tlobits_cbranch): Delete."}, {"sha": "3fa9dbaa773b8855e24117ebe387a157bd7b6814", "filename": "gcc/ira-build.c", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029da7d4c4d254bab10530df618ac6af91707876/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029da7d4c4d254bab10530df618ac6af91707876/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=029da7d4c4d254bab10530df618ac6af91707876", "patch": "@@ -2416,6 +2416,34 @@ create_caps (void)\n    IR with one region.  */\n static ira_allocno_t *regno_top_level_allocno_map;\n \n+/* Find the allocno that corresponds to A at a level one higher up in the\n+   loop tree.  Returns NULL if A is a cap, or if it has no parent.  */\n+ira_allocno_t\n+ira_parent_allocno (ira_allocno_t a)\n+{\n+  ira_loop_tree_node_t parent;\n+\n+  if (ALLOCNO_CAP (a) != NULL)\n+    return NULL;\n+\n+  parent = ALLOCNO_LOOP_TREE_NODE (a)->parent;\n+  if (parent == NULL)\n+    return NULL;\n+\n+  return parent->regno_allocno_map[ALLOCNO_REGNO (a)];\n+}\n+\n+/* Find the allocno that corresponds to A at a level one higher up in the\n+   loop tree.  If ALLOCNO_CAP is set for A, return that.  */\n+ira_allocno_t\n+ira_parent_or_cap_allocno (ira_allocno_t a)\n+{\n+  if (ALLOCNO_CAP (a) != NULL)\n+    return ALLOCNO_CAP (a);\n+\n+  return ira_parent_allocno (a);\n+}\n+\n /* Process all allocnos originated from pseudo REGNO and copy live\n    ranges, hard reg conflicts, and allocno stack reg attributes from\n    low level allocnos to final allocnos which are destinations of\n@@ -2478,7 +2506,7 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n   enum reg_class cover_class;\n   ira_allocno_t a, parent_a, first, second, node_first, node_second;\n   ira_copy_t cp;\n-  ira_loop_tree_node_t parent, node;\n+  ira_loop_tree_node_t node;\n   allocno_live_range_t r;\n   ira_allocno_iterator ai;\n   ira_copy_iterator ci;\n@@ -2513,10 +2541,8 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t  ira_assert (ALLOCNO_CAP_MEMBER (a) == NULL);\n \t  if (ALLOCNO_SOMEWHERE_RENAMED_P (a))\n \t    new_pseudos_p = true;\n-\t  if (ALLOCNO_CAP (a) != NULL\n-\t      || (parent = ALLOCNO_LOOP_TREE_NODE (a)->parent) == NULL\n-\t      || ((parent_a = parent->regno_allocno_map[ALLOCNO_REGNO (a)])\n-\t\t  == NULL))\n+\t  parent_a = ira_parent_allocno (a);\n+\t  if (parent_a == NULL)\n \t    {\n \t      ALLOCNO_COPIES (a) = NULL;\n \t      regno_top_level_allocno_map[REGNO (ALLOCNO_REG (a))] = a;\n@@ -2564,11 +2590,8 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t      ALLOCNO_COVER_CLASS_COST (parent_a)\n \t\t-= ALLOCNO_COVER_CLASS_COST (a);\n \t      ALLOCNO_MEMORY_COST (parent_a) -= ALLOCNO_MEMORY_COST (a);\n-\t      if (ALLOCNO_CAP (parent_a) != NULL\n-\t\t  || (parent\n-\t\t      = ALLOCNO_LOOP_TREE_NODE (parent_a)->parent) == NULL\n-\t\t  || (parent_a = (parent->regno_allocno_map\n-\t\t\t\t  [ALLOCNO_REGNO (parent_a)])) == NULL)\n+\t      parent_a = ira_parent_allocno (parent_a);\n+\t      if (parent_a == NULL)\n \t\tbreak;\n \t    }\n \t  ALLOCNO_COPIES (a) = NULL;"}, {"sha": "9b6615051d593cba20b32c0bd37b6420f0678b7f", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029da7d4c4d254bab10530df618ac6af91707876/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029da7d4c4d254bab10530df618ac6af91707876/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=029da7d4c4d254bab10530df618ac6af91707876", "patch": "@@ -346,7 +346,6 @@ process_regs_for_copy (rtx reg1, rtx reg2, bool constraint_p,\n   enum reg_class rclass, cover_class;\n   enum machine_mode mode;\n   ira_copy_t cp;\n-  ira_loop_tree_node_t parent;\n \n   gcc_assert (REG_SUBREG_P (reg1) && REG_SUBREG_P (reg2));\n   only_regs_p = REG_P (reg1) && REG_P (reg2);\n@@ -397,7 +396,7 @@ process_regs_for_copy (rtx reg1, rtx reg2, bool constraint_p,\n     cost = ira_get_register_move_cost (mode, cover_class, rclass) * freq;\n   else\n     cost = ira_get_register_move_cost (mode, rclass, cover_class) * freq;\n-  for (;;)\n+  do\n     {\n       ira_allocate_and_set_costs\n \t(&ALLOCNO_HARD_REG_COSTS (a), cover_class,\n@@ -408,12 +407,9 @@ process_regs_for_copy (rtx reg1, rtx reg2, bool constraint_p,\n       ALLOCNO_CONFLICT_HARD_REG_COSTS (a)[index] -= cost;\n       if (ALLOCNO_HARD_REG_COSTS (a)[index] < ALLOCNO_COVER_CLASS_COST (a))\n \tALLOCNO_COVER_CLASS_COST (a) = ALLOCNO_HARD_REG_COSTS (a)[index];\n-      if (ALLOCNO_CAP (a) != NULL)\n-\ta = ALLOCNO_CAP (a);\n-      else if ((parent = ALLOCNO_LOOP_TREE_NODE (a)->parent) == NULL\n-\t       || (a = parent->regno_allocno_map[ALLOCNO_REGNO (a)]) == NULL)\n-\tbreak;\n+      a = ira_parent_or_cap_allocno (a);\n     }\n+  while (a != NULL);\n   return true;\n }\n \n@@ -533,7 +529,6 @@ propagate_copies (void)\n   ira_copy_t cp;\n   ira_copy_iterator ci;\n   ira_allocno_t a1, a2, parent_a1, parent_a2;\n-  ira_loop_tree_node_t parent;\n \n   FOR_EACH_COPY (cp, ci)\n     {\n@@ -542,11 +537,8 @@ propagate_copies (void)\n       if (ALLOCNO_LOOP_TREE_NODE (a1) == ira_loop_tree_root)\n \tcontinue;\n       ira_assert ((ALLOCNO_LOOP_TREE_NODE (a2) != ira_loop_tree_root));\n-      parent = ALLOCNO_LOOP_TREE_NODE (a1)->parent;\n-      if ((parent_a1 = ALLOCNO_CAP (a1)) == NULL)\n-\tparent_a1 = parent->regno_allocno_map[ALLOCNO_REGNO (a1)];\n-      if ((parent_a2 = ALLOCNO_CAP (a2)) == NULL)\n-\tparent_a2 = parent->regno_allocno_map[ALLOCNO_REGNO (a2)];\n+      parent_a1 = ira_parent_or_cap_allocno (a1);\n+      parent_a2 = ira_parent_or_cap_allocno (a2);\n       ira_assert (parent_a1 != NULL && parent_a2 != NULL);\n       if (! CONFLICT_ALLOCNO_P (parent_a1, parent_a2))\n \tira_add_allocno_copy (parent_a1, parent_a2, cp->freq,\n@@ -565,7 +557,6 @@ build_allocno_conflicts (ira_allocno_t a)\n {\n   int i, px, parent_num;\n   int conflict_bit_vec_words_num;\n-  ira_loop_tree_node_t parent;\n   ira_allocno_t parent_a, another_a, another_parent_a;\n   ira_allocno_t *vec;\n   IRA_INT_TYPE *allocno_conflicts;\n@@ -601,13 +592,9 @@ build_allocno_conflicts (ira_allocno_t a)\n       ALLOCNO_CONFLICT_ALLOCNO_ARRAY_SIZE (a)\n \t= conflict_bit_vec_words_num * sizeof (IRA_INT_TYPE);\n     }\n-  parent = ALLOCNO_LOOP_TREE_NODE (a)->parent;\n-  if ((parent_a = ALLOCNO_CAP (a)) == NULL\n-      && (parent == NULL\n-\t  || (parent_a = parent->regno_allocno_map[ALLOCNO_REGNO (a)])\n-\t  == NULL))\n+  parent_a = ira_parent_or_cap_allocno (a);\n+  if (parent_a == NULL)\n     return;\n-  ira_assert (parent != NULL);\n   ira_assert (ALLOCNO_COVER_CLASS (a) == ALLOCNO_COVER_CLASS (parent_a));\n   parent_num = ALLOCNO_NUM (parent_a);\n   FOR_EACH_ALLOCNO_IN_SET (allocno_conflicts,\n@@ -616,9 +603,8 @@ build_allocno_conflicts (ira_allocno_t a)\n       another_a = ira_conflict_id_allocno_map[i];\n       ira_assert (ira_reg_classes_intersect_p\n \t\t  [ALLOCNO_COVER_CLASS (a)][ALLOCNO_COVER_CLASS (another_a)]);\n-      if ((another_parent_a = ALLOCNO_CAP (another_a)) == NULL\n-\t  && (another_parent_a = (parent->regno_allocno_map\n-\t\t\t\t  [ALLOCNO_REGNO (another_a)])) == NULL)\n+      another_parent_a = ira_parent_or_cap_allocno (another_a);\n+      if (another_parent_a == NULL)\n \tcontinue;\n       ira_assert (ALLOCNO_NUM (another_parent_a) >= 0);\n       ira_assert (ALLOCNO_COVER_CLASS (another_a)"}, {"sha": "b873b939cca343c2f42a44e83f4ab8f191cb2307", "filename": "gcc/ira-int.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029da7d4c4d254bab10530df618ac6af91707876/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029da7d4c4d254bab10530df618ac6af91707876/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=029da7d4c4d254bab10530df618ac6af91707876", "patch": "@@ -838,6 +838,8 @@ extern void ira_debug_allocno_copies (ira_allocno_t);\n extern void ira_traverse_loop_tree (bool, ira_loop_tree_node_t,\n \t\t\t\t    void (*) (ira_loop_tree_node_t),\n \t\t\t\t    void (*) (ira_loop_tree_node_t));\n+extern ira_allocno_t ira_parent_allocno (ira_allocno_t);\n+extern ira_allocno_t ira_parent_or_cap_allocno (ira_allocno_t);\n extern ira_allocno_t ira_create_allocno (int, bool, ira_loop_tree_node_t);\n extern void ira_set_allocno_cover_class (ira_allocno_t, enum reg_class);\n extern bool ira_conflict_vector_profitable_p (ira_allocno_t, int);"}]}