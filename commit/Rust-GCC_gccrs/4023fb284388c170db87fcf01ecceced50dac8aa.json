{"sha": "4023fb284388c170db87fcf01ecceced50dac8aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAyM2ZiMjg0Mzg4YzE3MGRiODdmY2YwMWVjY2VjZWQ1MGRhYzhhYQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2001-12-16T01:48:16Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2001-12-16T01:48:16Z"}, "message": "s390.md (prologue, [...]): New.\n\n\t* s390.md (prologue, epilogue, *return_si, *return_di): New.\n\ts390.c (find_unused_clobbered_reg, s390_frame_info,\n\tsave_fpr, restore_fpr, s390_emit_prologue, s390_emit_epilogue): New.\n\ts390-protos.h (s390_emit_prologue, s390_emit_epilogue): Declare.\n\ts390.c (s390_arg_frame_offset): Use s390_frame_info.\n\t(leaf_function_flag, cur_is_leaf_function,\n\tsave_fprs, restore_fprs, force_const_mem_late): Remove.\n\t(s390_function_prologue, s390_function_epilogue): Mostly remove.\n\ts390.md (lit): New.  Uses ...\n\ts390.c (s390_output_constant_pool): ... this, so adapt and make global.\n\ts390-protos.h (s390_output_constant_pool): Declare.\n\ts390.md (load_multiple, store_multiple): Allow use after reload.\n\ts390.c (load_multiple_operation, store_multiple_operation): Likewise.\n\ts390.h (INCOMING_FRAME_SP_OFFSET): Define.\n\ts390.h (CALL_REALLY_USED_REGISTERS): Define.\n\tconfig/s390/linux64.h (CALL_USED_REGISTERS): Remove, now handled ...\n\ts390.h (CONDITIONAL_REGISTER_USAGE): ... here.\n\ts390.c (s390_sr_alias_set): New global variable, initialized ...\n\t(override_options): ... here.  New.\n\ts390-protos.h (override_options): Declare.\n\ts390.h (OVERRIDE_OPTIONS): Call it.\n\ts390.c (s390_function_profiler): New.\n\ts390-protos.h (s390_function_profiler): Declare.\n\ts390.h (FUNCTION_PROFILER): Call it.\n\ts390.c (s390_profile): Remove.\n\n\t* s390.c (reg_used_in_mem_p): PC reload counts as memory access.\n\t(addr_generation_dependency_p): Consider literal pool register loads.\n\t(s390_adjust_priority): Do not schedule load_multiple.\n\ts390.md (attribute \"type\"): Define some additional types.\n\t(function_unit \"integer\"): Adapt.\n\t(many insns): Adapt \"type\" attribute setting.\n\n\t* s390.c (general_s_operand, s_imm_operand): New.\n\t(s_operand): Remove old definition, call general_s_operand instead.\n\ts390-protos.h (s_imm_operand): Declare.\n\ts390.c (base_n_index_p, r_or_s_operand, r_or_s_or_im8_operand,\n\tr_or_x_or_im16_operand, r_or_im8_operand): Remove.\n\ts390-protos.h (r_or_s_operand, r_or_s_or_im8_operand,\n\tr_or_x_or_im16_operand, r_or_im8_operand): Likewise.\n\ts390.h (PREDICATE_CODES): Add s_imm_operand, remove r_or_s*_operand.\n\ts390.md (many insns): Rework insn predicates.\n\n\t* s390.c (legitimate_pic_operand_p, legitimate_constant_p): Accept all\n\tnon-symbolic constants.  Reload will force them because of ...\n\t(s390_preferred_reload_class): ... this.  New.\n\ts390-protos.h (s390_preferred_reload_class): Declare.\n\ts390.h (PREFERRED_RELOAD_CLASS): Call it.\n\ts390.md (movdi, movsi, movdf, movsf, *reload_la_64 splitters,\n\t*reload_la_31 splitters): Handle constants after reload.\n\t(many insns): no longer force all constants immediately.\n\ts390.c (legitimate_reload_constant_p): New helper routine.\n\ts390-protos.h (legitimate_reload_constant_p): Declare.\n\ts390.c (print_operand): Clean up CONST_INT case, add CONST_DOUBLE case.\n\n\t* s390.h (FIRST_PSEUDO_REGISTER, FRAME_POINTER_REGNUM,\n\tHARD_FRAME_POINTER_REGNUM, REGISTER_NAMES): Add virtual frame pointer.\n\t(CALL_USED_REGISTERS, CALL_REALLY_USED_REGISTERS): Update.\n\t(ELIMINABLE_REGS, INITIAL_ELIMINATION_OFFSET): Likewise.\n\t(REGNO_OK_FOR_INDEX_P, REG_OK_FOR_INDEX_NONSTRICT_P): Likewise.\n\t(DWARF_FRAME_REGISTERS): Define.\n\ts390.c (regclass_map): Add virtual frame pointer.\n\t(legitimate_la_operand_p): Allow use of virtual frame pointer.\n\ts390.md (*la_ccclobber, *addaddr_ccclobber): New.\n\t(addaddr, addsi_64): Delete.\n\n\t* s390.h (HARD_REGNO_MODE_OK): Allow SImode and DImode values in\n\tfloating point registers.\n\t(CLASS_CANNOT_CHANGE_MODE, CLASS_CANNOT_CHANGE_MODE_P): Define.\n\t(ADDR_FP_REGS, GENERAL_FP_REGS): New register classes.\n\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Update.\n\n\t* s390.md (movti): Replace multi-insn output with splitters.\n\t(movdi_31, movdf_31): Likewise.\n\t(movti_ss, movdi_ss, movsi_ss, movdf_ss, movsf_ss): New.\n\t(movdi_lhi, movdi_lli, movdi_larl, movsi_lhi, movsi_lli): New.\n\t(movdi_64, movdi_31, movsi, movdf_64, movdf_31): Adapt.\n\t(movdf_soft_64, movdf_soft_31, movsf_soft): Remove.\n\t(movsf_64, movsf_31): Remove, replace by ...\n\t(movsf): ... this.\n\t(movqi_64): Use lhi instead of llill.\n\t(*movstrictqi, *movstricthi): Don't use (strict_low_part (mem)).\n\n\t* s390.md (extendsidi2, *extendsidi2, extendhidi2, *extendhidi2,\n\textendqidi2, extendhisi2, *extendhisi2, extendqisi2,\n\textendqihi2 and associated splitters): Reworked.\n\t(zero_extendsidi2, zero_extendsidi2, *zero_extendsidi2,\n\tzero_extendhidi2, *zero_extendhidi2, zero_extendqidi2,\n\tzero_extendqidi2, *zero_extendqidi2, zero_extendhisi2,\n\t*zero_extendhisi2_64, zero_extendhisi2_31, zero_extendqisi2,\n\t*zero_extendqisi2_64, *zero_extendqisi2_mem_31,\n\tzero_extendqisi2_reg_31, zero_extendqihi2, *zero_extendqisi2_64,\n\tzero_extendqihi2, zero_extendqihi2_64, zero_extendqihi2_31,\n\tand associated splitters): Likewise.\n\t(*sethighqisi, *sethighhisi, *sethighqidi_64, *sethighqidi_31\n\tand associated splitters): New.\n\t(truncdisi2, truncdihi2, truncdiqi2, truncsihi2, do_truncsihi2,\n\t*truncsihi2_64, truncsiqi2, trunchiqi2): Remove.\n\t(ashlhi3, ashrhi3, lshrhi3, abshi3): Remove.\n\ts390.h (PROMOTE_PROTOTYPES): Remove.\n\tconfig/s390/linux64.h (PROMOTE_PROTOTYPES): Likewise.\n\n\t* s390.md (muldi3): Delete, use instead ...\n\t(mulsidi3): ... this.\n\t(*muldi3_64): Rename to muldi3.\n\t(mulsi_6432): Fix template.\n\t(divdi3, moddi3): Delete, replace by ...\n\t(divmoddi4): ... this.\n\t(divmodtidi3): Fix template.\n\t(divmodtisi3): New.\n\t(udivdi3, umoddi3): Delete, replace by ...\n\t(udivmoddi4): ... this.\n\t(udivmodtidi3): Fix template.\n\t(divsi3, modsi3): Delete, replace by ...\n\t(divmodsi4): ... this.\n\t(divmoddisi3): Fix template.\n\t(udivsi3, umodsi3): Adapt.\n\n\t* s390.md (anddi3): Remove SS alternative, use instead ...\n\t(anddi3_ss, anddi3_ss_inv): ... these.\n\t(anddi3_ni): New.\n\t(andsi3*, andhi3*, andqi3*): Likewise.\n\t(iordi3): Remove SS alternative, use instead ...\n\t(iordi3_ss, iordi3_ss_inv): ... these.\n\t(iordi3_oi): New.\n\t(iorsi3*, iorhi3*, iorqi3*): Likewise.\n\t(iordi3_cc, iordi3_cconly, iorsi3_cc, iorsi3_cconly): New.\n\t(xordi3): Remove SS alternative, use instead ...\n\t(xordi3_ss, xordi3_ss_inv): ... these.\n\t(xordi3_oi): New.\n\t(xorsi3*, xorhi3*, xorqi3*): Likewise.\n\t(xordi3_cc, xordi3_cconly, xorsi3_cc, xorsi3_cconly): New.\n\t(one_cmpldi2, one_cmplsi2, one_cmplhi2, one_cmplqi2):\n\tExpand to XOR with -1.\n\t(*one_cmpldi2, *one_cmplsi2, *one_cmplhi2): Remove.\n\t(cmpdi_tm): Delete, replace by ...\n\t(cmpdi_tm_reg, cmpdi_tm_mem): ... these.\n\t(cmpsi_cct): Delete, replace by ...\n\t(cmpsi_tm_reg, cmpsi_tm_mem): ... these.\n\t(cmpdi_tm2, cmpsi_tm2): Improve.\n\t(cmphi_tm_sub, cmpqi_tm_sub, cmpqi_tm2, cmpqi_tm): New.\n\ts390.c (s390_single_hi, s390_extract_hi,\n\ts390_single_qi, s390_extract_qi): New helper routines.\n\ts390-protos.h (s390_single_hi, s390_extract_hi,\n\ts390_single_qi, s390_extract_qi): Declare.\n\ts390.c (tmxx_operand, const1_operand): Remove.\n\ts390-protos.h (tmxx_operand, const1_operand): Likewise.\n\ts390.h (PREDICATE_CODES): Likewise.\n\n\t* s390.md (sqrtdf2, sqrtsf2): New.\n\n\t* s390.h (CRT_CALL_STATIC_FUNCTION): Define.\n\t(check_and_change_labels): Remove section-change special case.\n\n\t* s390.h (RETURN_ADDR_RTX): Fix use of __builtin_return_address\n\tin leaf functions.  Needs ...\n\t(DYNAMIC_CHAIN_RTX):  ... this.  New.\n\n\t* s390.c (emit_pic_move): Don't generate pseudos if no_new_pseudos.\n\n\t* s390.md (movstrdix_64, movstrsix_31, movstrdi_64, movstrsi_31,\n\tclrstrsi_64, clrstrsi_31, cmpstr_64, cmpstr_31): Do not clobber\n\tinput operands using a match_dup clause.\n\t(movstrdi, movstrsi, clrstrdi, clrstrsi, cmpstrdi, cmpstrsi): Adapt.\n\n\t* s390.md (floatdidf2, floatdisf2, floatsidf2, floatsidf2_ieee,\n\tfloatsisf2, floatsisf2_ieee): Add missing CC clobber.\n\n\t* s390.md (floatsidf2_ibm): Use correct operand.\n\n\t* s390.md (fixuns_truncdfdi2, fixuns_truncdfsi2, fix_truncdfsi2,\n\tfixuns_truncsfdi2, fixuns_truncsfsi2, floatsidf2): Remove use of\n\tnon-portable constants.\n\ts390.c (s390_gen_rtx_const_DI): New helper routine.\n\ts390-protos.h (s390_gen_rtx_const_DI): Declare.\n\n\t* s390.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY): Fix alignment.\n\n\t* config/s390/linux.h (ASM_OUTPUT_SHORT, ASM_OUTPUT_CHAR,\n\tASM_OUTPUT_BYTE): Clean up assembly output.\n\t(ASM_OUTPUT_SKIP, ASM_OUTPUT_ALIGN): Remove duplicate definitions.\n\t(ASM_OUTPUT_ASCII): Remove.\n\n\t* config/s390/t-linux (CRTSTUFF_T_CFLAGS_S): Define.\n\nFrom-SVN: r48058", "tree": {"sha": "a990011a0a6401a859693c6844ba3219957d92c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a990011a0a6401a859693c6844ba3219957d92c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4023fb284388c170db87fcf01ecceced50dac8aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4023fb284388c170db87fcf01ecceced50dac8aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4023fb284388c170db87fcf01ecceced50dac8aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4023fb284388c170db87fcf01ecceced50dac8aa/comments", "author": null, "committer": null, "parents": [{"sha": "8aab0f2b5a84767f0a18246d278f51647ea477fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aab0f2b5a84767f0a18246d278f51647ea477fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aab0f2b5a84767f0a18246d278f51647ea477fe"}], "stats": {"total": 5865, "additions": 3547, "deletions": 2318}, "files": [{"sha": "7eba0097c9d6c5a2bd02d3b12457b9927e630a74", "filename": "gcc/ChangeLog", "status": "modified", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4023fb284388c170db87fcf01ecceced50dac8aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4023fb284388c170db87fcf01ecceced50dac8aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4023fb284388c170db87fcf01ecceced50dac8aa", "patch": "@@ -1,3 +1,190 @@\n+2001-12-15  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* s390.md (prologue, epilogue, *return_si, *return_di): New.\n+\ts390.c (find_unused_clobbered_reg, s390_frame_info, \n+\tsave_fpr, restore_fpr, s390_emit_prologue, s390_emit_epilogue): New.\n+\ts390-protos.h (s390_emit_prologue, s390_emit_epilogue): Declare.\n+\ts390.c (s390_arg_frame_offset): Use s390_frame_info.\n+\t(leaf_function_flag, cur_is_leaf_function,\n+\tsave_fprs, restore_fprs, force_const_mem_late): Remove.\n+\t(s390_function_prologue, s390_function_epilogue): Mostly remove.\n+\ts390.md (lit): New.  Uses ...\n+\ts390.c (s390_output_constant_pool): ... this, so adapt and make global.\n+\ts390-protos.h (s390_output_constant_pool): Declare.\n+\ts390.md (load_multiple, store_multiple): Allow use after reload.\n+\ts390.c (load_multiple_operation, store_multiple_operation): Likewise.\n+\ts390.h (INCOMING_FRAME_SP_OFFSET): Define.\n+\ts390.h (CALL_REALLY_USED_REGISTERS): Define.\n+\tconfig/s390/linux64.h (CALL_USED_REGISTERS): Remove, now handled ...\n+\ts390.h (CONDITIONAL_REGISTER_USAGE): ... here.\n+\ts390.c (s390_sr_alias_set): New global variable, initialized ...\n+\t(override_options): ... here.  New.\n+\ts390-protos.h (override_options): Declare.\n+\ts390.h (OVERRIDE_OPTIONS): Call it.\n+\ts390.c (s390_function_profiler): New.\n+\ts390-protos.h (s390_function_profiler): Declare.\n+\ts390.h (FUNCTION_PROFILER): Call it.\n+\ts390.c (s390_profile): Remove.\n+\n+\t* s390.c (reg_used_in_mem_p): PC reload counts as memory access.\n+\t(addr_generation_dependency_p): Consider literal pool register loads.\n+\t(s390_adjust_priority): Do not schedule load_multiple.\n+\ts390.md (attribute \"type\"): Define some additional types.\n+\t(function_unit \"integer\"): Adapt.\n+\t(many insns): Adapt \"type\" attribute setting.\n+\n+\t* s390.c (general_s_operand, s_imm_operand): New.\n+\t(s_operand): Remove old definition, call general_s_operand instead.\n+\ts390-protos.h (s_imm_operand): Declare.\n+\ts390.c (base_n_index_p, r_or_s_operand, r_or_s_or_im8_operand, \n+\tr_or_x_or_im16_operand, r_or_im8_operand): Remove.\n+\ts390-protos.h (r_or_s_operand, r_or_s_or_im8_operand,\n+\tr_or_x_or_im16_operand, r_or_im8_operand): Likewise.\n+\ts390.h (PREDICATE_CODES): Add s_imm_operand, remove r_or_s*_operand.\n+\ts390.md (many insns): Rework insn predicates.\n+\n+\t* s390.c (legitimate_pic_operand_p, legitimate_constant_p): Accept all\n+\tnon-symbolic constants.  Reload will force them because of ...\n+\t(s390_preferred_reload_class): ... this.  New.\n+\ts390-protos.h (s390_preferred_reload_class): Declare.\n+\ts390.h (PREFERRED_RELOAD_CLASS): Call it.\n+\ts390.md (movdi, movsi, movdf, movsf, *reload_la_64 splitters,\n+\t*reload_la_31 splitters): Handle constants after reload.\n+\t(many insns): no longer force all constants immediately.\n+\ts390.c (legitimate_reload_constant_p): New helper routine.\n+\ts390-protos.h (legitimate_reload_constant_p): Declare.\n+\ts390.c (print_operand): Clean up CONST_INT case, add CONST_DOUBLE case.\n+\n+\t* s390.h (FIRST_PSEUDO_REGISTER, FRAME_POINTER_REGNUM, \n+\tHARD_FRAME_POINTER_REGNUM, REGISTER_NAMES): Add virtual frame pointer.\n+\t(CALL_USED_REGISTERS, CALL_REALLY_USED_REGISTERS): Update.\n+\t(ELIMINABLE_REGS, INITIAL_ELIMINATION_OFFSET): Likewise.\n+\t(REGNO_OK_FOR_INDEX_P, REG_OK_FOR_INDEX_NONSTRICT_P): Likewise.\n+\t(DWARF_FRAME_REGISTERS): Define.\n+\ts390.c (regclass_map): Add virtual frame pointer.\n+\t(legitimate_la_operand_p): Allow use of virtual frame pointer.\n+\ts390.md (*la_ccclobber, *addaddr_ccclobber): New.\n+\t(addaddr, addsi_64): Delete.\n+\n+\t* s390.h (HARD_REGNO_MODE_OK): Allow SImode and DImode values in \n+\tfloating point registers.\n+\t(CLASS_CANNOT_CHANGE_MODE, CLASS_CANNOT_CHANGE_MODE_P): Define.\n+\t(ADDR_FP_REGS, GENERAL_FP_REGS): New register classes.\n+\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Update.\n+\n+\t* s390.md (movti): Replace multi-insn output with splitters.\n+\t(movdi_31, movdf_31): Likewise.\n+\t(movti_ss, movdi_ss, movsi_ss, movdf_ss, movsf_ss): New.\n+\t(movdi_lhi, movdi_lli, movdi_larl, movsi_lhi, movsi_lli): New.\n+\t(movdi_64, movdi_31, movsi, movdf_64, movdf_31): Adapt.\n+\t(movdf_soft_64, movdf_soft_31, movsf_soft): Remove.\n+\t(movsf_64, movsf_31): Remove, replace by ...\n+\t(movsf): ... this.\n+\t(movqi_64): Use lhi instead of llill.\n+\t(*movstrictqi, *movstricthi): Don't use (strict_low_part (mem)).\n+\n+\t* s390.md (extendsidi2, *extendsidi2, extendhidi2, *extendhidi2,\n+\textendqidi2, extendhisi2, *extendhisi2, extendqisi2,\n+\textendqihi2 and associated splitters): Reworked.\n+\t(zero_extendsidi2, zero_extendsidi2, *zero_extendsidi2,\n+\tzero_extendhidi2, *zero_extendhidi2, zero_extendqidi2,\n+\tzero_extendqidi2, *zero_extendqidi2, zero_extendhisi2,\n+\t*zero_extendhisi2_64, zero_extendhisi2_31, zero_extendqisi2,\n+\t*zero_extendqisi2_64, *zero_extendqisi2_mem_31,\n+\tzero_extendqisi2_reg_31, zero_extendqihi2, *zero_extendqisi2_64,\n+\tzero_extendqihi2, zero_extendqihi2_64, zero_extendqihi2_31,\n+\tand associated splitters): Likewise.\n+\t(*sethighqisi, *sethighhisi, *sethighqidi_64, *sethighqidi_31 \n+\tand associated splitters): New.\n+\t(truncdisi2, truncdihi2, truncdiqi2, truncsihi2, do_truncsihi2, \n+\t*truncsihi2_64, truncsiqi2, trunchiqi2): Remove.\n+\t(ashlhi3, ashrhi3, lshrhi3, abshi3): Remove.\n+\ts390.h (PROMOTE_PROTOTYPES): Remove.\n+\tconfig/s390/linux64.h (PROMOTE_PROTOTYPES): Likewise.\n+\n+\t* s390.md (muldi3): Delete, use instead ...\n+\t(mulsidi3): ... this.\n+\t(*muldi3_64): Rename to muldi3.\n+\t(mulsi_6432): Fix template.\n+\t(divdi3, moddi3): Delete, replace by ...\n+\t(divmoddi4): ... this.\n+\t(divmodtidi3): Fix template.\n+\t(divmodtisi3): New.\n+\t(udivdi3, umoddi3): Delete, replace by ...\n+\t(udivmoddi4): ... this.\n+\t(udivmodtidi3): Fix template.\n+\t(divsi3, modsi3): Delete, replace by ...\n+\t(divmodsi4): ... this.\n+\t(divmoddisi3): Fix template.\n+\t(udivsi3, umodsi3): Adapt.\n+\n+\t* s390.md (anddi3): Remove SS alternative, use instead ...\n+\t(anddi3_ss, anddi3_ss_inv): ... these.\n+\t(anddi3_ni): New.\n+\t(andsi3*, andhi3*, andqi3*): Likewise.\n+\t(iordi3): Remove SS alternative, use instead ...\n+\t(iordi3_ss, iordi3_ss_inv): ... these.\n+\t(iordi3_oi): New.\n+\t(iorsi3*, iorhi3*, iorqi3*): Likewise.\n+\t(iordi3_cc, iordi3_cconly, iorsi3_cc, iorsi3_cconly): New.\n+\t(xordi3): Remove SS alternative, use instead ...\n+\t(xordi3_ss, xordi3_ss_inv): ... these.\n+\t(xordi3_oi): New.\n+\t(xorsi3*, xorhi3*, xorqi3*): Likewise.\n+\t(xordi3_cc, xordi3_cconly, xorsi3_cc, xorsi3_cconly): New.\n+\t(one_cmpldi2, one_cmplsi2, one_cmplhi2, one_cmplqi2):\n+\tExpand to XOR with -1.\n+\t(*one_cmpldi2, *one_cmplsi2, *one_cmplhi2): Remove.\n+\t(cmpdi_tm): Delete, replace by ...\n+\t(cmpdi_tm_reg, cmpdi_tm_mem): ... these.\n+\t(cmpsi_cct): Delete, replace by ...\n+\t(cmpsi_tm_reg, cmpsi_tm_mem): ... these.\n+\t(cmpdi_tm2, cmpsi_tm2): Improve.\n+\t(cmphi_tm_sub, cmpqi_tm_sub, cmpqi_tm2, cmpqi_tm): New.\n+\ts390.c (s390_single_hi, s390_extract_hi, \n+\ts390_single_qi, s390_extract_qi): New helper routines.\n+\ts390-protos.h (s390_single_hi, s390_extract_hi, \n+\ts390_single_qi, s390_extract_qi): Declare.\n+\ts390.c (tmxx_operand, const1_operand): Remove.\n+\ts390-protos.h (tmxx_operand, const1_operand): Likewise.\n+\ts390.h (PREDICATE_CODES): Likewise.\n+\n+\t* s390.md (sqrtdf2, sqrtsf2): New.\n+\n+\t* s390.h (CRT_CALL_STATIC_FUNCTION): Define.\n+\t(check_and_change_labels): Remove section-change special case.\n+\n+\t* s390.h (RETURN_ADDR_RTX): Fix use of __builtin_return_address \n+\tin leaf functions.  Needs ...\n+\t(DYNAMIC_CHAIN_RTX):  ... this.  New.\n+\n+\t* s390.c (emit_pic_move): Don't generate pseudos if no_new_pseudos.\n+\n+\t* s390.md (movstrdix_64, movstrsix_31, movstrdi_64, movstrsi_31,\n+\tclrstrsi_64, clrstrsi_31, cmpstr_64, cmpstr_31): Do not clobber \n+\tinput operands using a match_dup clause.\n+\t(movstrdi, movstrsi, clrstrdi, clrstrsi, cmpstrdi, cmpstrsi): Adapt.\n+\n+\t* s390.md (floatdidf2, floatdisf2, floatsidf2, floatsidf2_ieee,\n+\tfloatsisf2, floatsisf2_ieee): Add missing CC clobber.\n+\n+\t* s390.md (floatsidf2_ibm): Use correct operand.\n+\n+\t* s390.md (fixuns_truncdfdi2, fixuns_truncdfsi2, fix_truncdfsi2,\n+\tfixuns_truncsfdi2, fixuns_truncsfsi2, floatsidf2): Remove use of\n+\tnon-portable constants.\n+\ts390.c (s390_gen_rtx_const_DI): New helper routine.\n+\ts390-protos.h (s390_gen_rtx_const_DI): Declare.\n+\n+\t* s390.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY): Fix alignment.\n+\n+\t* config/s390/linux.h (ASM_OUTPUT_SHORT, ASM_OUTPUT_CHAR,\n+\tASM_OUTPUT_BYTE): Clean up assembly output.\n+\t(ASM_OUTPUT_SKIP, ASM_OUTPUT_ALIGN): Remove duplicate definitions.\n+\t(ASM_OUTPUT_ASCII): Remove.\n+\n+\t* config/s390/t-linux (CRTSTUFF_T_CFLAGS_S): Define.\n+\n 2001-12-15  Zack Weinberg  <zack@codesourcery.com>\n \n \t* unwind-dw2-fde-glibc.c: #define _Unwind_Find_FDE to itself"}, {"sha": "ce1477e1944bdea651caf8e790307fb01d661f99", "filename": "gcc/config/s390/linux.h", "status": "modified", "additions": 7, "deletions": 66, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4023fb284388c170db87fcf01ecceced50dac8aa/gcc%2Fconfig%2Fs390%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4023fb284388c170db87fcf01ecceced50dac8aa/gcc%2Fconfig%2Fs390%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Flinux.h?ref=4023fb284388c170db87fcf01ecceced50dac8aa", "patch": "@@ -154,19 +154,19 @@ do { fprintf (FILE, \"%s\\t\", ASM_LONG);          \\\n    is this supposed to do align too?? */\n \n #define ASM_OUTPUT_SHORT(FILE, VALUE)           \\\n-( fprintf (FILE, \"%s \", ASM_SHORT),             \\\n+( fprintf (FILE, \"%s\\t\", ASM_SHORT),            \\\n   output_addr_const (FILE, (VALUE)),            \\\n   putc ('\\n',FILE))\n \n #define ASM_OUTPUT_CHAR(FILE, VALUE)            \\\n-( fprintf (FILE, \"%s \", ASM_BYTE_OP),           \\\n+( fprintf (FILE, \"\\t%s\\t\", ASM_BYTE_OP),        \\\n   output_addr_const (FILE, (VALUE)),            \\\n   putc ('\\n', FILE))\n \n /* This is how to output an assembler line for a numeric constant byte.  */\n \n #define ASM_OUTPUT_BYTE(FILE, VALUE)  \\\n-  fprintf ((FILE), \"%s 0x%x\\n\", ASM_BYTE_OP, (int)(VALUE))\n+  fprintf ((FILE), \"\\t%s\\t0x%x\\n\", ASM_BYTE_OP, (int)(VALUE))\n \n      /* internal macro to output long */\n #define _ASM_OUTPUT_LONG(FILE, VALUE)                                   \\\n@@ -191,75 +191,16 @@ do { fprintf (FILE, \"%s\\t\", ASM_LONG);          \\\n    that says to advance the location counter\n    to a multiple of 2**LOG bytes.  */\n \n-#define ASM_OUTPUT_ALIGN(FILE, LOG)      \\\n-    if ((LOG)!=0) fprintf ((FILE), \"\\t.align %d\\n\", 1<<(LOG))\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter by SIZE bytes.  */\n-\n-#undef ASM_OUTPUT_SKIP \n-#define ASM_OUTPUT_SKIP(FILE, SIZE)  \\\n-  fprintf ((FILE), \"\\t.set .,.+%u\\n\", (SIZE))\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes.  */\n-\n+#undef ASM_OUTPUT_ALIGN\n #define ASM_OUTPUT_ALIGN(FILE, LOG)\t\\\n-    if ((LOG)!=0) fprintf ((FILE), \"\\t.align %d\\n\", 1<<(LOG))\n+    if ((LOG)!=0) fprintf ((FILE), \"\\t.align\\t%d\\n\", 1<<(LOG))\n \n /* This is how to output an assembler line\n    that says to advance the location counter by SIZE bytes.  */\n \n+#undef ASM_OUTPUT_SKIP\n #define ASM_OUTPUT_SKIP(FILE, SIZE)  \\\n-  fprintf ((FILE), \"\\t.set .,.+%u\\n\", (SIZE))\n-\n-/* The routine used to output sequences of byte values.  We use a special\n-   version of this for most svr4 targets because doing so makes the\n-   generated assembly code more compact (and thus faster to assemble)\n-   as well as more readable.  Note that if we find subparts of the\n-   character sequence which end with NUL (and which are shorter than\n-   STRING_LIMIT) we output those using ASM_OUTPUT_LIMITED_STRING.  */\n-\n-#undef ASM_OUTPUT_ASCII\n-#define ASM_OUTPUT_ASCII(FILE, STR, LENGTH)                             \\\n-do {                                                                    \\\n-      register const unsigned char *_ascii_bytes = (const unsigned char *) (STR);   \\\n-      register const unsigned char *limit = _ascii_bytes + (LENGTH);          \\\n-      register unsigned bytes_in_chunk = 0;                             \\\n-      for (; _ascii_bytes < limit; _ascii_bytes++)                      \\\n-        {                                                               \\\n-          register const unsigned char *p;                                    \\\n-          if (bytes_in_chunk >= 64)                                     \\\n-            {                                                           \\\n-              fputc ('\\n', (FILE));                                     \\\n-              bytes_in_chunk = 0;                                       \\\n-            }                                                           \\\n-          for (p = _ascii_bytes; p < limit && *p != '\\0'; p++)          \\\n-            continue;                                                   \\\n-          if (p < limit && (p - _ascii_bytes) <= (long)STRING_LIMIT)    \\\n-            {                                                           \\\n-              if (bytes_in_chunk > 0)                                   \\\n-                {                                                       \\\n-                  fputc ('\\n', (FILE));                                 \\\n-                  bytes_in_chunk = 0;                                   \\\n-                }                                                       \\\n-              ASM_OUTPUT_LIMITED_STRING ((FILE), _ascii_bytes);         \\\n-              _ascii_bytes = p;                                         \\\n-            }                                                           \\\n-          else                                                          \\\n-            {                                                           \\\n-              if (bytes_in_chunk == 0)                                  \\\n-                fprintf ((FILE), \"%s\\t\", ASM_BYTE_OP);                  \\\n-              else                                                      \\\n-                fputc (',', (FILE));                                    \\\n-              fprintf ((FILE), \"0x%02x\", *_ascii_bytes);                \\\n-              bytes_in_chunk += 5;                                      \\\n-            }                                                           \\\n-        }                                                               \\\n-      if (bytes_in_chunk > 0)                                           \\\n-        fprintf ((FILE), \"\\n\");                                         \\\n-} while (0)\n+  fprintf ((FILE), \"\\t.set\\t.,.+%u\\n\", (SIZE))\n \n /* Output before read-only data.  */\n "}, {"sha": "a65cf90f7d38d5ba0f73d1a782eac2aa045f44e7", "filename": "gcc/config/s390/linux64.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4023fb284388c170db87fcf01ecceced50dac8aa/gcc%2Fconfig%2Fs390%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4023fb284388c170db87fcf01ecceced50dac8aa/gcc%2Fconfig%2Fs390%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Flinux64.h?ref=4023fb284388c170db87fcf01ecceced50dac8aa", "patch": "@@ -59,21 +59,7 @@ Boston, MA 02111-1307, USA.  */\n \t%{static:-static}}}\"\n #endif\n \n-#undef PROMOTE_PROTOTYPES \n #undef MASK_RETURN_ADDR \n #undef SELECT_SECTION\n \n-/* With 64 bit new linkage for floating point registers.  */\n-#undef CALL_USED_REGISTERS\t\t\t\n-#define CALL_USED_REGISTERS\t\t\t\\\n-{ 1, 1, 1, 1, \t\t\t\t\t\\\n-  1, 1, 0, 0, \t\t\t\t\t\\\n-  0, 0, 0, 0, \t\t\t\t\t\\\n-  0, 1, 1, 1,\t\t\t\t\t\\\n-  1, 1, 1, 1, \t\t\t\t\t\\\n-  1, 1, 1, 1, \t\t\t\t\t\\\n-  0, 0, 0, 0, \t\t\t\t\t\\\n-  0, 0, 0, 0, \t\t\t\t\t\\\n-  1, 1 }\n-\n #endif"}, {"sha": "b426daca275a60098119b60af9e68893ffb9281d", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4023fb284388c170db87fcf01ecceced50dac8aa/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4023fb284388c170db87fcf01ecceced50dac8aa/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=4023fb284388c170db87fcf01ecceced50dac8aa", "patch": "@@ -22,43 +22,50 @@ Boston, MA 02111-1307, USA.  */\n /* Declare functions in s390.c.  */\n \n extern void optimization_options PARAMS ((int, int));\n+extern void override_options PARAMS ((void));\n extern int s390_arg_frame_offset PARAMS ((void));\n extern void s390_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n extern void s390_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n+extern void s390_emit_prologue PARAMS ((void));\n+extern void s390_emit_epilogue PARAMS ((void));\n+extern void s390_function_profiler PARAMS ((FILE *, int));\n \n #ifdef RTX_CODE\n extern int const0_operand PARAMS ((rtx, enum machine_mode));\n-extern int const1_operand PARAMS ((rtx, enum machine_mode));\n extern int larl_operand PARAMS ((rtx, enum machine_mode));\n extern int fp_operand PARAMS ((rtx, enum machine_mode));\n extern int s_operand PARAMS ((rtx, enum machine_mode));\n-extern int r_or_s_operand PARAMS ((rtx, enum machine_mode));\n-extern int r_or_s_or_im8_operand PARAMS ((rtx, enum machine_mode));\n-extern int r_or_x_or_im16_operand PARAMS ((rtx, enum machine_mode));\n-extern int r_or_im8_operand PARAMS ((rtx, enum machine_mode));\n-extern int tmxx_operand PARAMS ((rtx, enum machine_mode));\n+extern int s_imm_operand PARAMS ((rtx, enum machine_mode));\n extern int bras_sym_operand PARAMS ((rtx, enum machine_mode));\n extern int load_multiple_operation PARAMS ((rtx, enum machine_mode));\n extern int store_multiple_operation PARAMS ((rtx, enum machine_mode));\n+extern int s390_single_hi PARAMS ((rtx, enum machine_mode, int));\n+extern int s390_extract_hi PARAMS ((rtx, enum machine_mode, int));\n+extern int s390_single_qi PARAMS ((rtx, enum machine_mode, int));\n+extern int s390_extract_qi PARAMS ((rtx, enum machine_mode, int));\n \n extern int s390_match_ccmode PARAMS ((rtx, enum machine_mode));\n extern enum machine_mode s390_select_ccmode PARAMS ((enum rtx_code, rtx, rtx));\n extern int symbolic_reference_mentioned_p PARAMS ((rtx));\n extern int legitimate_la_operand_p PARAMS ((rtx));\n extern int legitimate_pic_operand_p PARAMS ((rtx));\n extern int legitimate_constant_p PARAMS ((rtx));\n+extern int legitimate_reload_constant_p PARAMS ((rtx));\n extern int legitimate_address_p PARAMS ((enum machine_mode, rtx, int));\n extern rtx legitimize_pic_address PARAMS ((rtx, rtx));\n extern rtx legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n+extern enum reg_class s390_preferred_reload_class PARAMS ((rtx, enum reg_class));\n extern void emit_pic_move PARAMS ((rtx *, enum machine_mode));\n \n extern void s390_output_symbolic_const PARAMS ((FILE *, rtx));\n extern void print_operand_address PARAMS ((FILE *, rtx));\n extern void print_operand PARAMS ((FILE *, rtx, int));\n+extern void s390_output_constant_pool PARAMS ((FILE *));\n extern int s390_stop_dump_lit_p PARAMS ((rtx));\n extern void s390_dump_literal_pool PARAMS ((rtx, rtx));\n extern void s390_trampoline_template PARAMS ((FILE *));\n extern void s390_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n+extern rtx s390_gen_rtx_const_DI PARAMS ((int, int));\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE"}, {"sha": "743276c4da25a2b10b4121d9829c95f79a8a228b", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1011, "deletions": 659, "changes": 1670, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4023fb284388c170db87fcf01ecceced50dac8aa/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4023fb284388c170db87fcf01ecceced50dac8aa/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=4023fb284388c170db87fcf01ecceced50dac8aa", "patch": "@@ -39,6 +39,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"toplev.h\"\n #include \"basic-block.h\"\n+#include \"integrate.h\"\n #include \"ggc.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n@@ -70,6 +71,9 @@ struct gcc_target targetm = TARGET_INITIALIZER;\n \n extern int reload_completed;\n \n+/* The alias set for prologue/epilogue register save/restore.  */\n+static int s390_sr_alias_set = 0;\n+\n /* Function count for creating unique internal labels in a compile unit.  */\n int  s390_function_count = 0;\n \n@@ -93,11 +97,26 @@ struct s390_address\n   rtx disp;\n };\n \n+/* Structure containing information for prologue and epilogue.  */ \n+\n+struct s390_frame\n+{\n+  int frame_pointer_p;\n+  int return_reg_saved_p;\n+  int save_fprs_p;\n+  int first_save_gpr;\n+  int first_restore_gpr;\n+  int last_save_gpr;\n+  int arg_frame_offset;\n+\n+  HOST_WIDE_INT frame_size;\n+};\n+\n static int s390_match_ccmode_set PARAMS ((rtx, enum machine_mode));\n static int s390_branch_condition_mask PARAMS ((rtx));\n static const char *s390_branch_condition_mnemonic PARAMS ((rtx, int));\n-static int base_n_index_p PARAMS ((rtx));\n static int check_mode PARAMS ((rtx, enum machine_mode *));\n+static int general_s_operand PARAMS ((rtx, enum machine_mode, int));\n static int s390_decompose_address PARAMS ((rtx, struct s390_address *, int));\n static int reg_used_in_mem_p PARAMS ((int, rtx));\n static int addr_generation_dependency_p PARAMS ((rtx, rtx));\n@@ -106,12 +125,10 @@ static int far_away PARAMS ((int, int));\n static rtx check_and_change_labels PARAMS ((rtx, int *));\n static void s390_final_chunkify PARAMS ((int));\n static int save_fprs_p PARAMS ((void));\n-static int cur_is_leaf_function PARAMS ((void));\n-static int save_fprs PARAMS ((FILE *, long, int));\n-static int restore_fprs PARAMS ((FILE *, long, int));\n-static void s390_output_constant_pool PARAMS ((FILE *));\n-static rtx s390_force_const_mem_late PARAMS ((rtx));\n-static rtx s390_force_const_mem_symbol PARAMS ((const char *, int, int));\n+static int find_unused_clobbered_reg PARAMS ((void));\n+static void s390_frame_info PARAMS ((struct s390_frame *));\n+static rtx save_fpr PARAMS ((rtx, int, int));\n+static rtx restore_fpr PARAMS ((rtx, int, int));\n static int s390_function_arg_size PARAMS ((enum machine_mode, tree));\n \n  \n@@ -339,6 +356,212 @@ s390_branch_condition_mnemonic (code, inv)\n   return mnemonic[mask];\n }\n \n+/* If OP is an integer constant of mode MODE with exactly one\n+   HImode subpart unequal to DEF, return the number of that \n+   subpart.  As a special case, all HImode subparts of OP are\n+   equal to DEF, return zero.  Otherwise, return -1.  */\n+\n+int\n+s390_single_hi (op, mode, def)\n+     rtx op;\n+     enum machine_mode mode;\n+     int def;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      unsigned HOST_WIDE_INT value;\n+      int n_parts = GET_MODE_SIZE (mode) / 2;\n+      int i, part = -1;\n+\n+      for (i = 0; i < n_parts; i++)\n+        {\n+          if (i == 0)\n+            value = (unsigned HOST_WIDE_INT) INTVAL (op);\n+          else\n+            value >>= 16;\n+\n+          if ((value & 0xffff) != (unsigned)(def & 0xffff))\n+            {\n+              if (part != -1)\n+                return -1;\n+              else\n+                part = i;\n+            }\n+        }\n+\n+      return part == -1 ? 0 : (n_parts - 1 - part);\n+    }\n+\n+  else if (GET_CODE (op) == CONST_DOUBLE\n+           && GET_MODE (op) == VOIDmode)\n+    {\n+      unsigned HOST_WIDE_INT value;\n+      int n_parts = GET_MODE_SIZE (mode) / 2;\n+      int i, part = -1;\n+\n+      for (i = 0; i < n_parts; i++)\n+        {\n+          if (i == 0)\n+            value = (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (op);\n+          else if (i == HOST_BITS_PER_WIDE_INT / 16)\n+            value = (unsigned HOST_WIDE_INT) CONST_DOUBLE_HIGH (op);\n+          else\n+            value >>= 16;\n+\n+          if ((value & 0xffff) != (unsigned)(def & 0xffff))\n+            {\n+              if (part != -1)\n+                return -1;\n+              else\n+                part = i;\n+            }\n+        }\n+\n+      return part == -1 ? 0 : (n_parts - 1 - part);\n+    }\n+\n+  return -1;      \n+}\n+\n+/* Extract the HImode part number PART from integer \n+   constant OP of mode MODE.  */\n+\n+int\n+s390_extract_hi (op, mode, part)\n+    rtx op;\n+    enum machine_mode mode;\n+    int part;\n+{\n+  int n_parts = GET_MODE_SIZE (mode) / 2;\n+  if (part < 0 || part >= n_parts)\n+    abort();\n+  else\n+    part = n_parts - 1 - part;\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      unsigned HOST_WIDE_INT value = (unsigned HOST_WIDE_INT) INTVAL (op);\n+      return ((value >> (16 * part)) & 0xffff);\n+    }\n+  else if (GET_CODE (op) == CONST_DOUBLE\n+           && GET_MODE (op) == VOIDmode)\n+    {\n+      unsigned HOST_WIDE_INT value;\n+      if (part < HOST_BITS_PER_WIDE_INT / 16)\n+        value = (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (op);\n+      else\n+        value = (unsigned HOST_WIDE_INT) CONST_DOUBLE_HIGH (op),\n+        part -= HOST_BITS_PER_WIDE_INT / 16;\n+\n+      return ((value >> (16 * part)) & 0xffff); \n+    }\n+\n+  abort ();\n+}\n+\n+/* If OP is an integer constant of mode MODE with exactly one\n+   QImode subpart unequal to DEF, return the number of that \n+   subpart.  As a special case, all QImode subparts of OP are\n+   equal to DEF, return zero.  Otherwise, return -1.  */\n+\n+int\n+s390_single_qi (op, mode, def)\n+     rtx op;\n+     enum machine_mode mode;\n+     int def;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      unsigned HOST_WIDE_INT value;\n+      int n_parts = GET_MODE_SIZE (mode);\n+      int i, part = -1;\n+\n+      for (i = 0; i < n_parts; i++)\n+        {\n+          if (i == 0)\n+            value = (unsigned HOST_WIDE_INT) INTVAL (op);\n+          else\n+            value >>= 8;\n+\n+          if ((value & 0xff) != (unsigned)(def & 0xff))\n+            {\n+              if (part != -1)\n+                return -1;\n+              else\n+                part = i;\n+            }\n+        }\n+\n+      return part == -1 ? 0 : (n_parts - 1 - part);\n+    }\n+\n+  else if (GET_CODE (op) == CONST_DOUBLE\n+           && GET_MODE (op) == VOIDmode)\n+    {\n+      unsigned HOST_WIDE_INT value;\n+      int n_parts = GET_MODE_SIZE (mode);\n+      int i, part = -1;\n+\n+      for (i = 0; i < n_parts; i++)\n+        {\n+          if (i == 0)\n+            value = (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (op);\n+          else if (i == HOST_BITS_PER_WIDE_INT / 8)\n+            value = (unsigned HOST_WIDE_INT) CONST_DOUBLE_HIGH (op);\n+          else\n+            value >>= 8;\n+\n+          if ((value & 0xff) != (unsigned)(def & 0xff))\n+            {\n+              if (part != -1)\n+                return -1;\n+              else\n+                part = i;\n+            }\n+        }\n+\n+      return part == -1 ? 0 : (n_parts - 1 - part);\n+    }\n+\n+  return -1;      \n+}\n+\n+/* Extract the QImode part number PART from integer \n+   constant OP of mode MODE.  */\n+\n+int\n+s390_extract_qi (op, mode, part)\n+    rtx op;\n+    enum machine_mode mode;\n+    int part;\n+{\n+  int n_parts = GET_MODE_SIZE (mode);\n+  if (part < 0 || part >= n_parts)\n+    abort();\n+  else\n+    part = n_parts - 1 - part;\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      unsigned HOST_WIDE_INT value = (unsigned HOST_WIDE_INT) INTVAL (op);\n+      return ((value >> (8 * part)) & 0xff);\n+    }\n+  else if (GET_CODE (op) == CONST_DOUBLE\n+           && GET_MODE (op) == VOIDmode)\n+    {\n+      unsigned HOST_WIDE_INT value;\n+      if (part < HOST_BITS_PER_WIDE_INT / 8)\n+        value = (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (op);\n+      else\n+        value = (unsigned HOST_WIDE_INT) CONST_DOUBLE_HIGH (op),\n+        part -= HOST_BITS_PER_WIDE_INT / 8;\n+\n+      return ((value >> (8 * part)) & 0xff); \n+    }\n+\n+  abort ();\n+}\n+\n \n /* Change optimizations to be performed, depending on the \n    optimization level.\n@@ -360,6 +583,13 @@ optimization_options (level, size)\n #endif\n }\n \n+void\n+override_options ()\n+{\n+  /* Acquire a unique set number for our register saves and restores.  */\n+  s390_sr_alias_set = new_alias_set ();\n+}\n+\n \n /* Map for smallest class containing reg regno.  */\n \n@@ -372,7 +602,7 @@ enum reg_class regclass_map[FIRST_PSEUDO_REGISTER] =\n   FP_REGS,      FP_REGS,   FP_REGS,   FP_REGS,\n   FP_REGS,      FP_REGS,   FP_REGS,   FP_REGS,\n   FP_REGS,      FP_REGS,   FP_REGS,   FP_REGS,\n-  ADDR_REGS,    NO_REGS \n+  ADDR_REGS,    NO_REGS,   ADDR_REGS \n };\n \n \n@@ -388,32 +618,6 @@ const0_operand (op, mode)\n   return op == CONST0_RTX (mode);\n }\n \n-/* Return true if OP a (const_int 1) operand.\n-   OP is the current operation.\n-   MODE is the current operation mode.  */\n- \n-int\n-const1_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n-{\n-  return op == CONST1_RTX (mode);\n-}\n-\n-/* Return true if OP needs base and index register.  */\n-\n-static int \n-base_n_index_p (op)\n-     register rtx op;\n-{\n-  if ((GET_CODE (op) == PLUS) &&\n-      (GET_CODE (XEXP (op, 0)) == PLUS ||\n-       GET_CODE (XEXP (op, 1)) == PLUS ||\n-       GET_CODE (XEXP (op, 1)) == REG ))\n-    return 1;\n-  return 0;\n-}\n-\n /* Return true if the mode of operand OP matches MODE.\n    If MODE is set to VOIDmode, set it to the mode of OP.  */ \n \n@@ -503,146 +707,90 @@ fp_operand (op, mode)\n     return 0;\n }\n \n-/* Return true if OP is a valid S operand for an RS, SI or SS type instruction.\n-   OP is the current operation.\n-   MODE is the current operation mode.  */\n-\n-int\n-s_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n-{\n-  register enum rtx_code code = GET_CODE (op);\n-\n-  if (! check_mode (op,&mode))\n-    return 0;\n-\n-  if (code == MEM) {\n-    if (base_n_index_p (XEXP (op, 0)))\n-      return 0;\n-  }\n-\n-  return memory_operand (op, mode);\n-}\n-\n-/* Return 1 if OP is a valid R or S operand for an RS, SI or SS type\n-   instruction.\n+/* Helper routine to implement s_operand and s_imm_operand.\n    OP is the current operation.\n-   MODE is the current operation mode.  */\n+   MODE is the current operation mode.\n+   ALLOW_IMMEDIATE specifies whether immediate operands should\n+   be accepted or not.  */\n \n-int\n-r_or_s_operand (op, mode)\n+static int\n+general_s_operand (op, mode, allow_immediate)\n      register rtx op;\n      enum machine_mode mode;\n+     int allow_immediate;\n {\n-  register enum rtx_code code = GET_CODE (op);\n+  struct s390_address addr;\n \n+  /* Call general_operand first, so that we don't have to\n+     check for many special cases.  */\n   if (!general_operand (op, mode))\n     return 0;\n \n-  if (code == MEM) {\n-    if (base_n_index_p (XEXP (op, 0)))\n-      return 0;\n-    else\n-      return memory_operand (op, mode);\n-  }\n-  return register_operand (op, mode);\n-}\n+  /* Just like memory_operand, allow (subreg (mem ...))\n+     after reload.  */\n+  if (reload_completed \n+      && GET_CODE (op) == SUBREG \n+      && GET_CODE (SUBREG_REG (op)) == MEM)\n+    op = SUBREG_REG (op);\n \n-/* Return true if OP is a valid R or S or immediate operand for \n-   RS, SI or SS type instruction.\n-   OP is the current operation.\n-   MODE is the current operation mode.  */\n-\n-int\n-r_or_s_or_im8_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n-{\n-  register enum rtx_code code = GET_CODE (op);\n+  switch (GET_CODE (op))\n+    {\n+      /* Constants that we are sure will be forced to the\n+         literal pool in reload are OK as s-operand.  Note\n+\t that we cannot call s390_preferred_reload_class here\n+\t because it might not be known yet at this point \n+\t whether the current function is a leaf or not.  */\n+      case CONST_INT:\n+      case CONST_DOUBLE:\n+\tif (!allow_immediate || reload_completed)\n+\t  break;\n+\tif (!legitimate_reload_constant_p (op))\n+\t  return 1;\n+\tif (!TARGET_64BIT)\n+\t  return 1;\n+\tbreak;\n+\n+      /* Memory operands are OK unless they already use an\n+\t index register.  */\n+      case MEM:\n+\tif (GET_CODE (XEXP (op, 0)) == ADDRESSOF)\n+\t  return 1;\n+\tif (s390_decompose_address (XEXP (op, 0), &addr, FALSE) \n+\t    && !addr.indx)\n+\t  return 1;\n+\tbreak;\n \n-  if (!general_operand (op, mode))\n-    return 0;\n+      default:\n+\tbreak;\n+    }\n \n-  if (code == MEM) {\n-    if (base_n_index_p (XEXP (op, 0)))\n-      return 0;\n-    else\n-      return memory_operand (op, mode);\n-  }\n-  return register_operand (op, mode) || immediate_operand (op, mode);\n+  return 0;\n }\n \n-/* Return true if OP is a valid R or X or 16 bit immediate operand for \n-   RX, RR or RI type instruction.\n+/* Return true if OP is a valid S-type operand.\n    OP is the current operation.\n    MODE is the current operation mode.  */\n \n int\n-r_or_x_or_im16_operand (op, mode)\n+s_operand (op, mode)\n      register rtx op;\n      enum machine_mode mode;\n {\n-\n-  if (! general_operand (op, mode))\n-    return 0;\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    return (CONST_OK_FOR_LETTER_P (INTVAL (op), 'K'));\n-  return register_operand (op, mode) || memory_operand (op, mode);\n+  return general_s_operand (op, mode, 0);\n }\n \n-/* Return true if OP is a valid R or 8 bit immediate operand.\n+/* Return true if OP is a valid S-type operand or an immediate \n+   operand that can be addressed as S-type operand by forcing \n+   it into the literal pool.\n    OP is the current operation.\n    MODE is the current operation mode.  */\n \n int\n-r_or_im8_operand (op, mode)\n+s_imm_operand (op, mode)\n      register rtx op;\n      enum machine_mode mode;\n {\n-\n-  if (!general_operand (op, mode))\n-    return 0;\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    return (CONST_OK_FOR_LETTER_P (INTVAL (op), 'J'));\n-  return register_operand (op, mode) || memory_operand (op, mode);\n-}\n-\n-/* Return true if OP is a valid operand for the 'test under mask'\n-   instruction with 16 bit immediate.  \n-   The value should only have set bits in one halfword.\n-   OP is the current operation.\n-   MODE is the current operation mode.  */\n-\n-int\n-tmxx_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  rtx con;\n-  if (GET_CODE (op) == CONST_INT)\n-    return (CONST_OK_FOR_LETTER_P (INTVAL (op), 'L'));\n-  if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == SYMBOL_REF &&\n-      CONSTANT_POOL_ADDRESS_P (XEXP (op, 0))) \n-    {\n-      con = get_pool_constant (XEXP (op, 0));\n-\n-      if (GET_CODE (con) == CONST_INT)\n-\t{\n-\t  unsigned HOST_WIDEST_INT c;\n-\t  \n-\t  c = (unsigned HOST_WIDEST_INT) INTVAL (con);\n-\t  \n-\t  return ((c & 0xffff) ? ((c & 0xffffffffffff0000ULL)==0) : \n-\t\t  (c & 0xffff0000U) ? ((c & 0xffffffff0000ffffULL)==0) :\n-\t\t  (c & 0xffff00000000ULL) ? ((c & 0xffff0000ffffffffULL)==0) :\n-\t\t  (c & 0xffff000000000000ULL) ? ((c & 0xffffffffffffULL)==0) : 1);\n-\t\t  \n-\t}\n-    }\n-  return 0;\n+  return general_s_operand (op, mode, 1);\n }\n \n /* Return true if OP is a valid operand for the BRAS instruction.\n@@ -682,7 +830,7 @@ load_multiple_operation (op, mode)\n   int count = XVECLEN (op, 0);\n   unsigned int dest_regno;\n   rtx src_addr;\n-  int i;\n+  int i, off;\n \n \n   /* Perform a quick check so we don't blow up below.  */\n@@ -695,6 +843,23 @@ load_multiple_operation (op, mode)\n   dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n   src_addr = XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0);\n \n+  /* Check, is base, or base + displacement.  */\n+\n+  if (GET_CODE (src_addr) == REG)\n+    off = 0;\n+  else if (GET_CODE (src_addr) == PLUS\n+\t   && GET_CODE (XEXP (src_addr, 0)) == REG \n+\t   && GET_CODE (XEXP (src_addr, 1)) == CONST_INT)\n+    {\n+      off = INTVAL (XEXP (src_addr, 1));\n+      src_addr = XEXP (src_addr, 0);\n+    }\n+  else\n+    return 0;\n+\n+  if (src_addr == frame_pointer_rtx || src_addr == arg_pointer_rtx)\n+    return 0;\n+\n   for (i = 1; i < count; i++)\n     {\n       rtx elt = XVECEXP (op, 0, i);\n@@ -708,7 +873,8 @@ load_multiple_operation (op, mode)\n \t  || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n \t  || ! rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n \t  || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n-\t  || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != i * 4)\n+\t  || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1))\n+\t     != off + i * UNITS_PER_WORD)\n \treturn 0;\n     }\n \n@@ -725,10 +891,10 @@ store_multiple_operation (op, mode)\n      rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  int count = XVECLEN (op, 0) - 1;\n+  int count = XVECLEN (op, 0);\n   unsigned int src_regno;\n   rtx dest_addr;\n-  int i;\n+  int i, off;\n \n   /* Perform a quick check so we don't blow up below.  */\n   if (count <= 1\n@@ -740,6 +906,23 @@ store_multiple_operation (op, mode)\n   src_regno = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n   dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, 0)), 0);\n \n+  /* Check, is base, or base + displacement.  */\n+\n+  if (GET_CODE (dest_addr) == REG)\n+    off = 0;\n+  else if (GET_CODE (dest_addr) == PLUS\n+\t   && GET_CODE (XEXP (dest_addr, 0)) == REG \n+\t   && GET_CODE (XEXP (dest_addr, 1)) == CONST_INT)\n+    {\n+      off = INTVAL (XEXP (dest_addr, 1));\n+      dest_addr = XEXP (dest_addr, 0);\n+    }\n+  else\n+    return 0;\n+\n+  if (dest_addr == frame_pointer_rtx || dest_addr == arg_pointer_rtx)\n+    return 0;\n+\n   for (i = 1; i < count; i++)\n     {\n       rtx elt = XVECEXP (op, 0, i);\n@@ -753,7 +936,8 @@ store_multiple_operation (op, mode)\n \t  || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n \t  || ! rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n \t  || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n-\t  || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != i * 4)\n+\t  || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1))\n+\t     != off + i * UNITS_PER_WORD)\n \treturn 0;\n     }\n   return 1;\n@@ -800,8 +984,7 @@ int\n legitimate_pic_operand_p (op)\n      register rtx op;\n {\n-  /* All non-symbolic constants that made it \n-     up to here are fine.  */\n+  /* Accept all non-symbolic constants.  */\n   if (!SYMBOLIC_CONST (op))\n     return 1;\n \n@@ -821,13 +1004,7 @@ int\n legitimate_constant_p (op)\n      register rtx op;\n {\n-  /* Reject doubles and integers out of range.  */\n-  if (GET_CODE (op) == CONST_DOUBLE ||\n-      (GET_CODE (op) == CONST_INT &&\n-       (INTVAL (op) < -32768 || INTVAL (op) > 32767)))\n-    return 0;\n-\n-  /* Accept all other non-symbolic constants.  */\n+  /* Accept all non-symbolic constants.  */\n   if (!SYMBOLIC_CONST (op))\n     return 1;\n \n@@ -847,6 +1024,93 @@ legitimate_constant_p (op)\n   return 0;\n }\n \n+/* Returns true if the constant value OP is a legitimate general\n+   operand during and after reload.  The difference to \n+   legitimate_constant_p is that this function will not accept\n+   a constant that would need to be forced to the literal pool\n+   before it can be used as operand.  */\n+\n+int\n+legitimate_reload_constant_p (op)\n+     register rtx op;\n+{\n+  /* Accept l(g)hi operands.  */\n+  if (GET_CODE (op) == CONST_INT\n+      && CONST_OK_FOR_LETTER_P (INTVAL (op), 'K'))\n+    return 1;\n+\n+  /* Accept lliXX operands.  */\n+  if (TARGET_64BIT\n+      && s390_single_hi (op, DImode, 0) >= 0)\n+  return 1;\n+\n+  /* Accept larl operands.  */\n+  if (TARGET_64BIT\n+      && larl_operand (op, VOIDmode))\n+    return 1;\n+\n+  /* If reload is completed, and we do not already have a\n+     literal pool, and OP must be forced to the literal \n+     pool, then something must have gone wrong earlier.\n+     We *cannot* force the constant any more, because the\n+     prolog generation already decided we don't need to \n+     set up the base register.  */\n+  if (reload_completed && !regs_ever_live[BASE_REGISTER])\n+    abort ();\n+\n+  /* Everything else cannot be handled without reload.  */\n+  return 0;\n+}\n+\n+/* Given an rtx OP being reloaded into a reg required to be in class CLASS,\n+   return the class of reg to actually use.  */\n+\n+enum reg_class\n+s390_preferred_reload_class (op, class)\n+     rtx op;\n+     enum reg_class class;\n+{\n+  /* This can happen if a floating point constant is being\n+     reloaded into an integer register.  Leave well alone.  */\n+  if (GET_MODE_CLASS (GET_MODE (op)) == MODE_FLOAT\n+      && class != FP_REGS)\n+    return class;\n+\n+  switch (GET_CODE (op))\n+    {\n+      /* Constants we cannot reload must be forced into the\n+\t literal pool.  For constants we *could* handle directly,\n+\t it might still be preferable to put them in the pool and\n+\t use a memory-to-memory instruction.\n+\n+\t However, try to avoid needlessly allocating a literal\n+\t pool in a routine that wouldn't otherwise need any.\n+\t Heuristically, we assume that 64-bit leaf functions\n+\t typically don't need a literal pool, all others do.  */\n+      case CONST_DOUBLE:\n+      case CONST_INT:\n+\tif (!legitimate_reload_constant_p (op))\n+\t  return NO_REGS;\n+\n+\tif (TARGET_64BIT && current_function_is_leaf)\n+\t  return class;\n+\n+\treturn NO_REGS;\n+\n+      /* If a symbolic constant or a PLUS is reloaded,\n+\t it is most likely being used as an address.  */\n+      case PLUS:\n+      case LABEL_REF:\n+      case SYMBOL_REF:\n+      case CONST:\n+        return ADDR_REGS;\n+\n+      default:\n+\tbreak;\n+    }\n+\n+  return class;\n+}\n \n /* Decompose a RTL expression ADDR for a memory address into\n    its components, returned in OUT.  The boolean STRICT \n@@ -1063,14 +1327,16 @@ legitimate_la_operand_p (op)\n   if (addr.base && GET_CODE (addr.base) == REG)\n     {\n       if (REGNO (addr.base) == BASE_REGISTER\n-          || REGNO (addr.base) == STACK_POINTER_REGNUM)\n+\t  || REGNO (addr.base) == STACK_POINTER_REGNUM\n+\t  || REGNO (addr.base) == FRAME_POINTER_REGNUM)\n         return TRUE;\n     }\n \n   if (addr.indx && GET_CODE (addr.indx) == REG)\n     {\n       if (REGNO (addr.indx) == BASE_REGISTER\n-          || REGNO (addr.indx) == STACK_POINTER_REGNUM)\n+          || REGNO (addr.indx) == STACK_POINTER_REGNUM\n+\t  || REGNO (addr.base) == FRAME_POINTER_REGNUM)\n         return TRUE;\n     }\n \n@@ -1364,7 +1630,7 @@ emit_pic_move (operands, mode)\n      rtx *operands;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  rtx temp = reload_in_progress ? operands[0] : gen_reg_rtx (Pmode);\n+  rtx temp = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n \n   if (GET_CODE (operands[0]) == MEM && SYMBOLIC_CONST (operands[1]))\n     operands[1] = force_reg (Pmode, operands[1]);\n@@ -1532,7 +1798,7 @@ print_operand_address (file, addr)\n   struct s390_address ad;\n \n   if (!s390_decompose_address (addr, &ad, TRUE))\n-    output_operand_lossage (\"cannot decompose address.\\n\");\n+    output_operand_lossage (\"Cannot decompose address.\");\n  \n   if (ad.disp)\n     s390_output_symbolic_const (file, ad.disp);\n@@ -1657,15 +1923,26 @@ print_operand (file, x, code)\n \n     case CONST_INT:\n       if (code == 'b')\n-        fprintf (file, \"%d\", (int)(INTVAL (x) & 0xff));\n-      else if (code == 'X')\n-        fprintf (file, \"%d\", (int)(INTVAL (x) & 0xff));\n+        fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x) & 0xff);\n+      else if (code == 'x')\n+        fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x) & 0xffff);\n+      else if (code == 'h')\n+        fprintf (file, HOST_WIDE_INT_PRINT_DEC, ((INTVAL (x) & 0xffff) ^ 0x8000) - 0x8000);\n+      else\n+        fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x));\n+      break;\n+\n+    case CONST_DOUBLE:\n+      if (GET_MODE (x) != VOIDmode)\n+        abort ();\n+      if (code == 'b')\n+        fprintf (file, HOST_WIDE_INT_PRINT_DEC, CONST_DOUBLE_LOW (x) & 0xff);\n       else if (code == 'x')\n-        fprintf (file, \"0x%x\", (int)(INTVAL (x) & 0xffff));\n+        fprintf (file, HOST_WIDE_INT_PRINT_DEC, CONST_DOUBLE_LOW (x) & 0xffff);\n       else if (code == 'h')\n-        fprintf (file, \"%d\", (int)(INTVAL (x) << 16) >> 16);\n+        fprintf (file, HOST_WIDE_INT_PRINT_DEC, ((CONST_DOUBLE_LOW (x) & 0xffff) ^ 0x8000) - 0x8000);\n       else\n-        fprintf (file, \"%d\", (int)INTVAL (x));\n+        abort ();\n       break;\n \n     default:\n@@ -1694,6 +1971,13 @@ reg_used_in_mem_p (regno, x)\n \t\t\t     XEXP (x, 0), 0))\n \treturn 1;\n     }\n+  else if (code == SET \n+\t   && GET_CODE (SET_DEST (x)) == PC)\n+    {\n+      if (refers_to_regno_p (regno, regno+1,\n+\t\t\t     SET_SRC (x), 0))\n+\treturn 1;\n+    }\n \n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n@@ -1718,7 +2002,7 @@ addr_generation_dependency_p (dep_rtx, insn)\n      rtx dep_rtx; \n      rtx insn;\n {\n-  rtx target;\n+  rtx target, pat;\n \n   if (GET_CODE (dep_rtx) == SET)\n     {\n@@ -1729,11 +2013,22 @@ addr_generation_dependency_p (dep_rtx, insn)\n \t  int regno = REGNO (target);\n \n \t  if (get_attr_type (insn) == TYPE_LA)\n-\t    return refers_to_regno_p (regno, regno+1,\n-\t\t\t\t      SET_SRC (PATTERN (insn)), 0);\n-\t  else if (get_attr_atype (insn) == ATYPE_MEM)\n-\t    return reg_used_in_mem_p (regno, PATTERN (insn));\n-\t}\n+\t    {\n+\t      pat = PATTERN (insn);\n+\t      if (GET_CODE (pat) == PARALLEL)\n+\t\t{\n+\t\t  if (XVECLEN (pat, 0) != 2)\n+\t\t    abort();\n+\t\t  pat = XVECEXP (pat, 0, 0);\n+\t\t}\n+\t      if (GET_CODE (pat) == SET)\n+\t\treturn refers_to_regno_p (regno, regno+1, SET_SRC (pat), 0);\n+\t      else\n+\t\tabort();\n+\t    }\n+\t  else if (get_attr_atype (insn) == ATYPE_MEM)\n+\t    return reg_used_in_mem_p (regno, PATTERN (insn));\n+\t}\n     }\n   return 0;\n }\n@@ -1839,6 +2134,14 @@ s390_adjust_priority (insn, priority)\n       if (priority >= 0 && priority < 0x01000000)\n \tpriority <<= 3;\n       break;\n+    case TYPE_LM:\n+      /* LM in epilogue should never be scheduled. This\n+\t is due to literal access done in function body.\n+\t The usage of register 13 is not mentioned explicitly,\n+\t leading to scheduling 'LM' accross this instructions.  \n+      */ \n+      priority = 0x7fffffff;\n+      break;\n     }\n   \n   return priority;\n@@ -2114,8 +2417,6 @@ s390_final_chunkify (chunkify)\n   int addr, naddr = 0, uids;\n   int chunk_max = 0;\n \n-  const char *asms;\n-\n   int size = insn_current_address;\n \n   int *ltorg_uids;\n@@ -2171,19 +2472,6 @@ s390_final_chunkify (chunkify)\n \t      warning (\"no code label found\");\n \t    }\n \t} \n-      else if (GET_CODE (PATTERN (insn)) == ASM_INPUT && !TARGET_64BIT) \n-\t{\n-\t  asms = XSTR (PATTERN (insn),0);\n-\t  \n-\t  if ((memcmp (asms,\".section\",8) == 0) ||\n-\t      (memcmp (asms,\".text\",5) == 0)    ||\n-\t      (memcmp (asms,\"\\t.section\",9) == 0) ||\n-\t      (memcmp (asms,\"\\t.text\",6) == 0))  {\n-\t    ltorg_uids[max_ltorg++] = INSN_UID (insn);\n-\t    INSN_ADDRESSES_NEW (emit_insn_before (gen_rtx_ASM_INPUT (VOIDmode,\n-\t\t\t\t\t   \".align 4\"), insn), -1);\n-\t  }\n-\t}\n     }\n   ltorg_uids[max_ltorg] = 0;\n   for (insn=get_insns (),uids=0; insn;insn = next_real_insn (insn)) \n@@ -2253,19 +2541,6 @@ s390_dump_literal_pool (act_insn, stop)\n   function_section (current_function_decl);\n }\n \n-\n-#ifdef DWARF2_DEBUGGING_INFO\n-extern char *dwarf2out_cfi_label PARAMS ((void));\n-#endif\n-\n-/* Flag set in prologue, used in epilog to know\n-   if stack is allocated or not.  */\n-static int leaf_function_flag;\n-\n-/* Symbol references needed by the profile code;\n-   set up by the function prologue routine if necessary.  */\n-rtx s390_profile[10];\n-\n /* Number of elements of current constant pool.  */\n int s390_nr_constants;\n \n@@ -2285,111 +2560,14 @@ save_fprs_p ()\n   return 0;\n }\n \n-/* Return true if urrent function is a leaf function, \n-   without automatics, alloca or vararg stuff.  */\n-\n-static int\n-cur_is_leaf_function ()\n-{\n-  int lsize =  get_frame_size () + current_function_outgoing_args_size\n-    + save_fprs_p () * 64;\n-\n-  if (leaf_function_p () && ((lsize) == 0) &&\n-      ! (current_function_calls_alloca) &&\n-      ! (current_function_stdarg) && ! (current_function_varargs))\n-    return 1;\n-  return 0;\n-}\n-\n-/* Return offset between argument pointer and frame pointer \n-   initially after prologue.  */\n-\n-int \n-s390_arg_frame_offset ()\n-{\n-  int lsize =  get_frame_size () + current_function_outgoing_args_size\n-    + save_fprs_p () * 64;\n-\n-  if (cur_is_leaf_function ())\n-    return STACK_POINTER_OFFSET;\n-  else\n-    return 2*STACK_POINTER_OFFSET + lsize;\n-}\n-\n-/* Output code to stdio stream FILE to save floating point \n-   registers on current stack, at offset OFFSET to the frame\n-   pointer register FP.  */\n-\n-static int \n-save_fprs (file, offset, fp)\n-     FILE *file;\n-     long offset;\n-     int fp;\n-{\n-  int i;\n-\n-  if (!TARGET_64BIT)\n-    return 0;\n-\n-  for (i=24; i<=31; i++) \n-    {\n-      if (regs_ever_live[i] == 1)\n-\t{\n-\t  fprintf (file, \"\\tstd\\t%s,%ld(%s)\\n\", reg_names[i], \n-\t\t   (i-24) * 8 + offset, reg_names[fp]); \n-\t}\n-    }\n-\n-  return 1;\n-}\n-\n-/* Output code to stdio stream FILE to restore floating point \n-   registers from current stack, at offset OFFSET to the frame\n-   pointer register FP.  */\n-\n-static int \n-restore_fprs (file, offset, fp)\n-     FILE *file;\n-     long offset;\n-     int fp;\n-{\n-  int i;\n-\n-  if (!TARGET_64BIT)\n-    return 0;\n-\n-  if (!save_fprs_p ())\n-    return 0;\n-\n-  if (offset < 0) \n-    {\n-      fp = 1;\n-      offset = 0;\n-      fprintf (file, \"\\tlgr\\t%s,%s\\n\", reg_names[fp], \n-\t       reg_names[STACK_POINTER_REGNUM]); \n-      fprintf (file, \"\\taghi\\t%s,-64\\n\", reg_names[fp]); \n-    }\n-\n-  for (i=24; i<=31; i++) \n-    {\n-      if (regs_ever_live[i] == 1)\n-\t{\n-\t  fprintf (file, \"\\tld\\t%s,%ld(%s)\\n\", reg_names[i], \n-\t\t   (i-24) * 8 + offset, reg_names[fp]); \n-\t}\n-    }\n-\n-  return 1;\n-}\n-\n /* Output main constant pool to stdio stream FILE.  */ \n \n-static void\n+void\n s390_output_constant_pool (file)\n      FILE *file;\n {\n   /* Output constant pool.  */\n-  if (s390_nr_constants || regs_ever_live[BASE_REGISTER])\n+  if (s390_nr_constants)\n     {\n       s390_pool_count = 0;\n       if (TARGET_64BIT)\n@@ -2410,66 +2588,150 @@ s390_output_constant_pool (file)\n \t       s390_pool_count);\n       if (TARGET_64BIT)\n \tfunction_section (current_function_decl);\n-      \n-      regs_ever_live[BASE_REGISTER] = 1;\n     }\n }\n \n-/* Add constant CTX to the constant pool at a late time \n-   (after the initial pass to count the number of constants\n-   was already done).  Returns the resulting constant \n-   pool reference.  */\n+/* Find first call clobbered register unsused in a function.\n+   This could be used as base register in a leaf function\n+   or for holding the return address before epilogue.  */\n \n-static rtx\n-s390_force_const_mem_late (cst)\n-     rtx cst;\n+static int\n+find_unused_clobbered_reg ()\n+{\n+  int i;\n+  for (i = 0; i < 6; i++)\n+    if (!regs_ever_live[i])\n+      return i;\n+  return 0;\n+}\n+\n+/* Fill FRAME with info about frame of current function.  */\n+\n+static void\n+s390_frame_info (frame)\n+     struct s390_frame *frame;\n+{\n+  int i, j;\n+  HOST_WIDE_INT fsize = get_frame_size ();\n+\n+  if (fsize > 0x7fff0000)\n+    fatal_error (\"Total size of local variables exceeds architecture limit.\");\n+\n+  /* fprs 8 - 15 are caller saved for 64 Bit ABI.  */\n+  frame->save_fprs_p = save_fprs_p ();\n+\n+  frame->frame_size = fsize + frame->save_fprs_p * 64;\n+\n+  /* Does function need to setup frame and save area.  */\n+  \n+  if (! current_function_is_leaf\n+      || frame->frame_size > 0\n+      || current_function_calls_alloca \n+      || current_function_stdarg\n+      || current_function_varargs)\n+    frame->frame_size += STARTING_FRAME_OFFSET;\n+\n+  /* If we need to allocate a frame, the stack pointer is changed.  */ \n+\n+  if (frame->frame_size > 0)\n+    regs_ever_live[STACK_POINTER_REGNUM] = 1;\n+\n+  /* If there is (possibly) any pool entry, we need to \n+     load base register.  */\n+\n+  if (get_pool_size () \n+      || !CONST_OK_FOR_LETTER_P (frame->frame_size, 'K')\n+      || (!TARGET_64BIT && current_function_uses_pic_offset_table))\n+    regs_ever_live[BASE_REGISTER] = 1; \n+\n+  /* If we need the GOT pointer, remember to save/restore it.  */\n+\n+  if (current_function_uses_pic_offset_table)\n+    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\n+  /* Frame pointer needed.   */\n+    \n+  frame->frame_pointer_p = frame_pointer_needed;\n+\n+  /* Find first and last gpr to be saved.  */\n+  \n+  for (i = 6; i < 16; i++)\n+    if (regs_ever_live[i])\n+      break;\n+\n+  for (j = 15; j > i; j--)\n+    if (regs_ever_live[j])\n+      break;\n+  \n+  if (i == 16)\n+    {\n+      /* Nothing to save / restore.  */ \n+      frame->first_save_gpr = -1;\n+      frame->first_restore_gpr = -1;\n+      frame->last_save_gpr = -1;\n+      frame->return_reg_saved_p = 0;\n+    }\n+  else\n+    {\n+      /* Save / Restore from gpr i to j.  */\n+      frame->first_save_gpr = i;\n+      frame->first_restore_gpr = i;\n+      frame->last_save_gpr  = j;\n+      frame->return_reg_saved_p = (j >= RETURN_REGNUM && i <= RETURN_REGNUM);\n+    }\n+\n+  if (current_function_stdarg || current_function_varargs)\n+    {\n+      /* Varargs function need to save from gpr 2 to gpr 15.  */\n+      frame->first_save_gpr = 2;\n+    }\n+}\n+\n+/* Return offset between argument pointer and frame pointer \n+   initially after prologue.  */\n+\n+int \n+s390_arg_frame_offset ()\n {\n-  cst = force_const_mem (Pmode, cst);\n+  struct s390_frame frame;\n \n-  s390_nr_constants++;\n-  regs_ever_live[BASE_REGISTER] = 1;\n+  /* Compute frame_info.  */\n \n-  emit_insn_before (gen_rtx (USE, Pmode, cst), get_insns ());\n+  s390_frame_info (&frame);\n \n-  return cst;\n+  return frame.frame_size + STACK_POINTER_OFFSET;\n }\n \n-/* Add a reference to the symbol NAME to the constant pool.\n-   FUNC specifies whether NAME refers to a function, while\n-   GLOBAL specifies whether NAME is a global symbol.  Depending\n-   on these flags, the appopriate PLT or GOT references are\n-   generated.  Returns the constant pool reference.  */\n+/* Emit insn to save fpr REGNUM at offset OFFSET relative\n+   to register BASE.  Return generated insn.  */ \n \n static rtx\n-s390_force_const_mem_symbol (name, func, global)\n-     const char *name;\n-     int func;\n-     int global;\n+save_fpr (base, offset, regnum)\n+     rtx base;\n+     int offset;\n+     int regnum;     \n {\n-  rtx symbol;\n+  rtx addr;\n+  addr = gen_rtx_MEM (DFmode, plus_constant (base, offset));\n+  set_mem_alias_set (addr, s390_sr_alias_set);\n \n-  if (TARGET_64BIT)\n-    abort ();\n+  return emit_move_insn (addr, gen_rtx_REG (DFmode, regnum));\n+}\n \n-  symbol = gen_rtx (SYMBOL_REF, Pmode, name);\n-  SYMBOL_REF_FLAG (symbol) = !global;\n+/* Emit insn to restore fpr REGNUM from offset OFFSET relative\n+   to register BASE.  Return generated insn.  */ \n \n-  if (flag_pic)\n-    {\n-      if (global)\n-        {\n-          current_function_uses_pic_offset_table = 1;\n-          symbol = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, symbol), func? 114 : 112);\n-          symbol = gen_rtx_CONST (VOIDmode, symbol);\n-        }\n-      else\n-        {\n-          symbol = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, symbol), 100);\n-          symbol = gen_rtx_CONST (VOIDmode, symbol);\n-        }\n-    }\n+static rtx\n+restore_fpr (base, offset, regnum)\n+     rtx base;\n+     int offset;\n+     int regnum;\n+{\n+  rtx addr;\n+  addr = gen_rtx_MEM (DFmode, plus_constant (base, offset));\n+  set_mem_alias_set (addr, s390_sr_alias_set);\n \n-  return s390_force_const_mem_late (symbol);\n+  return emit_move_insn (gen_rtx_REG (DFmode, regnum), addr);\n }\n \n /* Output the function prologue assembly code to the \n@@ -2478,401 +2740,396 @@ s390_force_const_mem_symbol (name, func, global)\n \n void\n s390_function_prologue (file, lsize)\n-     FILE *file;\n-     HOST_WIDE_INT lsize;\n+     FILE *file ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT lsize ATTRIBUTE_UNUSED;\n {\n-  extern int profile_label_no;\n-  int i, j;\n-  long frame_size;\n-  rtx stack_label = 0, got_label = 0;\n-  char *l;\n-  const char *const b64 = TARGET_64BIT ? \"g\" : \"\";\n+  if (get_pool_size () > S390_POOL_MAX)\n+    s390_final_chunkify (1);\n+  else\n+    s390_final_chunkify (0);\n+}\n \n-  /* Check for too large size of local variables */\n+/* Output the function epilogue assembly code to the \n+   stdio stream FILE.  The local frame size is passed\n+   in LSIZE.  */\n \n-  if (lsize > 0x7fff0000)\n-    fatal_error (\"total size of local variables exceeds architecture limit\");\n+void\n+s390_function_epilogue (file, lsize)\n+     FILE *file ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT lsize ATTRIBUTE_UNUSED;\n+{\n+  current_function_uses_pic_offset_table = 0;\n+  s390_pool_start_insn = NULL_RTX;\n+  s390_pool_count = -1;\n+  s390_function_count++;\n+}\n \n-  /* Profile code (-p, -a, -ax needs some literals).  */\n+/* Expand the prologue into a bunch of separate insns.  */\n \n-  if (profile_flag && !TARGET_64BIT)\n-    {\n-      static char label[128];\n-      sprintf (label, \"%sP%d\", LPREFIX, profile_label_no);\n+void\n+s390_emit_prologue ()\n+{\n+  struct s390_frame frame;\n+  rtx insn, addr;\n+  rtx temp_reg;\n+  int i, limit;\n \n-      s390_profile[4] = s390_force_const_mem_symbol (\"_mcount\", 1, 1);\n-      s390_profile[9] = s390_force_const_mem_symbol (label, 0, 0);\n-    }\n+  /* Compute frame_info.  */\n \n-  if (get_pool_size () > S390_POOL_MAX)\n-    s390_final_chunkify (1);\n+  s390_frame_info (&frame);\n+\n+  /* Choose best register to use for temp use within prologue.  */\n+  \n+  if (frame.return_reg_saved_p\n+      && !has_hard_reg_initial_val (Pmode, RETURN_REGNUM))\n+    temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n   else\n-    s390_final_chunkify (0);\n+    temp_reg = gen_rtx_REG (Pmode, 1);\n \n-  if (current_function_uses_pic_offset_table)\n-    regs_ever_live[12] = 1;\n+  /* Save call saved gprs.  */\n \n-  if (!TARGET_64BIT && current_function_uses_pic_offset_table)\n+  if (frame.first_save_gpr != -1)\n     {\n-      got_label = s390_force_const_mem_symbol (\"_GLOBAL_OFFSET_TABLE_\", 0, 0);\n-    }\n+      addr = plus_constant (stack_pointer_rtx, \n+\t\t\t    frame.first_save_gpr * UNITS_PER_WORD);\n+      addr = gen_rtx_MEM (Pmode, addr);\n+      set_mem_alias_set (addr, s390_sr_alias_set);\n \n-  if ((frame_size = \n-       STARTING_FRAME_OFFSET + lsize + save_fprs_p () * 64) > 0x7fff)\n-    {\n-      stack_label = s390_force_const_mem_late (GEN_INT (frame_size));\n-    }\n+      if (frame.first_save_gpr != frame.last_save_gpr )\n+\t{\n+\t  insn = emit_insn (gen_store_multiple (addr,\n+\t\t\t      gen_rtx_REG (Pmode, frame.first_save_gpr),\n+\t\t\t      GEN_INT (frame.last_save_gpr \n+\t\t\t\t       - frame.first_save_gpr + 1)));\n \n-  if (!optimize)\n-    {\n-      /* Stupid register allocation is stupid ...\n-         It does not always recognize the base register is used.  */\n-      \n-      regs_ever_live[BASE_REGISTER] = 1;\n-    }\n-\n- if (cur_is_leaf_function ())\n-   {\n-      leaf_function_flag = 1;\n-      fprintf (file, \"%s\\tleaf function\\n\", ASM_COMMENT_START);\n-      fprintf (file, \"%s\\thas varargs             %d\\n\", ASM_COMMENT_START,\n-\t       current_function_stdarg);\n-      fprintf (file, \"%s\\tincoming args (stack)   %d\\n\", ASM_COMMENT_START,\n-\t       current_function_args_size);\n-      fprintf (file, \"%s\\tfunction length         %d\\n\", ASM_COMMENT_START,\n-\t       insn_current_address);\n-      fprintf (file, \"%s\\tregister live           \", ASM_COMMENT_START);\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tfprintf (file, \"%d\", regs_ever_live[i]);\n-      fputc   ('\\n',file);\n-      \n-      /* Save gprs 6 - 15 and fprs 4 and 6.  */\n-      for (i = 6; i < 13 && (regs_ever_live[i] == 0); i++);\n+\t  /* Set RTX_FRAME_RELATED_P for all sets within store multiple.  */\n \n-      if (s390_nr_constants || regs_ever_live[13] || i != 13)\n-\t{\n-\t  fprintf (file, \"\\tstm%s\\t%s,%s,%d(%s)\\n\", \n-                         b64, reg_names[i], reg_names[13],\n-                         i * UNITS_PER_WORD,\n-\t\t         reg_names[STACK_POINTER_REGNUM]);\n-#ifdef INCOMING_RETURN_ADDR_RTX\n-\t  if (dwarf2out_do_frame ())\n+\t  limit = XVECLEN (PATTERN (insn), 0);\n+\t  \n+\t  for (i = 0; i < limit; i++)\n \t    {\n-\t      l = dwarf2out_cfi_label ();\n-\t      dwarf2out_def_cfa (l, STACK_POINTER_REGNUM, \n-\t\t\t\t STACK_POINTER_OFFSET);\n-\t      for (j = i; j <= 14; j++)\n-\t\tdwarf2out_reg_save (l, j, (TARGET_64BIT ? (j-20) : (j-24))\n-\t\t\t\t    * UNITS_PER_WORD);\n-\t      if (regs_ever_live[18])\n-\t\tdwarf2out_reg_save (l, 18, -16);\n-\t      if (regs_ever_live[19])\n-\t\tdwarf2out_reg_save (l, 19, -8);\n+\t      rtx x = XVECEXP (PATTERN (insn), 0, i);\n+\t      \n+\t      if (GET_CODE (x) == SET)\n+\t\tRTX_FRAME_RELATED_P (x) = 1;\n \t    }\n-#endif\n \t}\n-\n-      s390_output_constant_pool (file);\n-\n-      /* Save fprs.  */\n-\n-      if (!TARGET_64BIT)\n+      else\n \t{\n-\t  if (regs_ever_live[18])\n-\t    fprintf (file, \"\\tstd\\t4,80(%s)\\n\", reg_names[STACK_POINTER_REGNUM]);\n-\t  if (regs_ever_live[19])\n-\t    fprintf (file, \"\\tstd\\t6,88(%s)\\n\", reg_names[STACK_POINTER_REGNUM]);\n+\t  insn = emit_move_insn (addr, \n+\t\t\t\t gen_rtx_REG (Pmode, frame.first_save_gpr));\n \t}\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n-  else\n-    {\t\t\t\t/* No leaf function.  */\n-      fprintf (file, \"%s\\tleaf function           %d\\n\", ASM_COMMENT_START,\n-\t       leaf_function_p ());\n-      fprintf (file, \"%s\\tautomatics              %d\\n\", ASM_COMMENT_START,\n-\t       (int)lsize);\n-      fprintf (file, \"%s\\toutgoing args           %d\\n\", ASM_COMMENT_START,\n-\t       current_function_outgoing_args_size);\n-      fprintf (file, \"%s\\tneed frame pointer      %d\\n\", ASM_COMMENT_START,\n-\t       frame_pointer_needed);\n-      fprintf (file, \"%s\\tcall alloca             %d\\n\", ASM_COMMENT_START,\n-\t       current_function_calls_alloca);\n-      fprintf (file, \"%s\\thas varargs             %d\\n\", ASM_COMMENT_START,\n-\t       current_function_stdarg || current_function_varargs);\n-      fprintf (file, \"%s\\tincoming args (stack)   %d\\n\", ASM_COMMENT_START,\n-\t       current_function_args_size);\n-      fprintf (file, \"%s\\tfunction length         %d\\n\", ASM_COMMENT_START,\n-\t       insn_current_address);\n-      fprintf (file, \"%s\\tregister live           \", ASM_COMMENT_START);\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tfprintf (file, \"%d\", regs_ever_live[i]);\n-      fputc   ('\\n',file);\n-\n-      /* Save gprs 6 - 15 and fprs 4 and 6.  */\n+\n+  /* Dump constant pool and set constant pool register (13).  */\n+ \n+  insn = emit_insn (gen_lit ());\n+  \n+  /* Save fprs for variable args.  */\n+\n+  if (current_function_stdarg || current_function_varargs)\n+    {\n+      /* Save fpr 0 and 2.  */ \n+\n+      save_fpr (stack_pointer_rtx, STACK_POINTER_OFFSET - 32, 16); \n+      save_fpr (stack_pointer_rtx, STACK_POINTER_OFFSET - 24, 17); \n       \n-      if (current_function_stdarg || current_function_varargs)\n-\t{\n-\t  i = 2;\n-\t}\n-      else\n+      if (TARGET_64BIT)\n \t{\n-\t  for (i = 6; i < 13 && (regs_ever_live[i] == 0); i++);\n+\t  /* Save fpr 4 and 6.  */\n+ \n+\t  save_fpr (stack_pointer_rtx, STACK_POINTER_OFFSET - 16, 18); \n+\t  save_fpr (stack_pointer_rtx, STACK_POINTER_OFFSET - 8, 19); \n \t}\n+    }\n \n-      fprintf (file, \"\\tstm%s\\t%s,%s,%d(%s)\\n\", \n-                     b64, reg_names[i], reg_names[15], i * UNITS_PER_WORD,\n-\t             reg_names[STACK_POINTER_REGNUM]);\n+  /* Save fprs 4 and 6 if used (31 bit ABI).  */\n \n-#ifdef INCOMING_RETURN_ADDR_RTX\n-      if (dwarf2out_do_frame ())\n+  if (!TARGET_64BIT)\n+    {\n+      /* Save fpr 4 and 6.  */\n+      if (regs_ever_live[18])\n \t{\n-\t  l = dwarf2out_cfi_label ();\n-\t  dwarf2out_def_cfa (l, STACK_POINTER_REGNUM, STACK_POINTER_OFFSET);\n-\t  for (j = i; j <= 15; j++)\n-\t    dwarf2out_reg_save (l, j, (TARGET_64BIT ? (j-20) : (j-24)) *\n-\t\t\t\tUNITS_PER_WORD);\n-\t  if (regs_ever_live[18])\n-\t    dwarf2out_reg_save (l, 18, -16);\n-\t  if (regs_ever_live[19])\n-\t    dwarf2out_reg_save (l, 19, -8);\n+\t  insn = save_fpr (stack_pointer_rtx, STACK_POINTER_OFFSET - 16, 18);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n-#endif\n+      if (regs_ever_live[19]) \n+\t{\n+\t  insn = save_fpr (stack_pointer_rtx, STACK_POINTER_OFFSET - 8, 19); \n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+    }\n \n-      s390_output_constant_pool (file);\n+  /* Decrement stack pointer.  */\n \n-      /* Save fprs.  */\n+  if (frame.frame_size > 0)\n+    {\n+      rtx frame_off = GEN_INT (-frame.frame_size);\n \n-      if (current_function_stdarg || current_function_varargs)\n-\t{\n-\t  fprintf (file, \"\\tstd\\t%s,%d(%s)\\n\", \n-\t\t   reg_names[16],\n-\t\t   STACK_POINTER_OFFSET-32,\n-\t\t   reg_names[STACK_POINTER_REGNUM]);\n-\t  fprintf (file, \"\\tstd\\t%s,%d(%s)\\n\",\n-\t\t   reg_names[17],\n-\t\t   STACK_POINTER_OFFSET-24,\n-\t\t   reg_names[STACK_POINTER_REGNUM]);\n-\t  if (TARGET_64BIT)\n-\t    {\n-\t      fprintf (file, \"\\tstd\\t%s,%d(%s)\\n\", \n-\t\t       reg_names[18],\n-\t\t       STACK_POINTER_OFFSET-16,\n-\t\t       reg_names[STACK_POINTER_REGNUM]);\n-\t      fprintf (file, \"\\tstd\\t%s,%d(%s)\\n\", \n-\t\t       reg_names[19],\n-\t\t       STACK_POINTER_OFFSET-8,\n-\t\t       reg_names[STACK_POINTER_REGNUM]);\n-\t    }\n-\t}\n-      if (!TARGET_64BIT)\n+      /* Save incoming stack pointer into temp reg.  */\n+      \n+      if (TARGET_BACKCHAIN || frame.save_fprs_p)\n \t{\n-\t  if (regs_ever_live[18])\n-\t    fprintf (file, \"\\tstd\\t%s,%d(%s)\\n\", \n-\t\t     reg_names[18],\n-\t\t     STACK_POINTER_OFFSET-16,\n-\t\t     reg_names[STACK_POINTER_REGNUM]);\n-\t  if (regs_ever_live[19])\n-\t    fprintf (file, \"\\tstd\\t%s,%d(%s)\\n\",\n-\t\t     reg_names[19],\n-\t\t     STACK_POINTER_OFFSET-8,\n-\t\t     reg_names[STACK_POINTER_REGNUM]);\n+\t  insn = emit_insn (gen_move_insn (temp_reg, stack_pointer_rtx));\n \t}\n-\n       \n-      if (save_fprs_p () && frame_size > 4095) \n+      /* Substract frame size from stack pointer.  */\n+\n+      frame_off = GEN_INT (-frame.frame_size);\n+      if (!CONST_OK_FOR_LETTER_P (-frame.frame_size, 'K'))\n+\tframe_off = force_const_mem (Pmode, frame_off);\n+\n+      insn = emit_insn (gen_add2_insn (stack_pointer_rtx, frame_off));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      REG_NOTES (insn) = \n+\tgen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\t\t   gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t\t   gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t           GEN_INT (-frame.frame_size))),\n+\t\t\t   REG_NOTES (insn));\n+\n+      /* Set backchain.  */\n+      \n+      if (TARGET_BACKCHAIN)\n \t{\n-\t  int fp = 1;\n-\t  fprintf (file, \"\\tlgr\\t%s,%s\\n\", reg_names[fp], \n-\t\t   reg_names[STACK_POINTER_REGNUM]); \n-\t  fprintf (file, \"\\taghi\\t%s,-64\\n\", reg_names[fp]);\n-\t  save_fprs (file, 0, fp);\n+\t  addr = gen_rtx_MEM (Pmode, stack_pointer_rtx);\n+\t  set_mem_alias_set (addr, s390_sr_alias_set);\n+\t  insn = emit_insn (gen_move_insn (addr, temp_reg));\n \t}\n+    }\n \n-      /* Decrement stack.  */\n+  /* Save fprs 8 - 15 (64 bit ABI).  */\n+  \n+  if (frame.save_fprs_p)\n+    {\n+      insn = emit_insn (gen_add2_insn (temp_reg, GEN_INT(-64)));\n \n-      if (TARGET_BACKCHAIN || (frame_size + STACK_POINTER_OFFSET > 4095\n-\t\t\t       || frame_pointer_needed\n-\t\t\t       || current_function_calls_alloca))\n-\t{\n+      for (i = 24; i < 32; i++)\n+\tif (regs_ever_live[i])\n+\t  {\n+\t    rtx addr = plus_constant (stack_pointer_rtx, \n+\t\t\t\t      frame.frame_size - 64 + (i-24)*8);\n+\n+\t    insn = save_fpr (temp_reg, (i-24)*8, i);\n+\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t    REG_NOTES (insn) = \n+\t      gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\tgen_rtx_SET (VOIDmode, \n+\t\t\t     gen_rtx_MEM (DFmode, addr),\n+\t\t\t     gen_rtx_REG (DFmode, i)),\n+\t\tREG_NOTES (insn));\n+\t  }\n+    }\n+\t    \n+  /* Set frame pointer, if needed.  */\n+  \n+  if (frame.frame_pointer_p)\n+    {\n+      insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n \n-\t  fprintf (file, \"\\tl%sr\\t%s,%s\\n\", b64, \n-\t\t\t reg_names[1], reg_names[STACK_POINTER_REGNUM]);\n-\t}\n+  /* Set up got pointer, if needed.  */\n+  \n+  if (current_function_uses_pic_offset_table)\n+    {\n+      rtx got_symbol = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n+      SYMBOL_REF_FLAG (got_symbol) = 1;\n \n-      if (stack_label)\n+      if (TARGET_64BIT)\n \t{\n-\t  rtx operands[2];\n+\t  insn = emit_insn (gen_movdi (pic_offset_table_rtx,\n+\t\t\t\t       got_symbol));\t\t \n \n-\t  operands[0] = stack_pointer_rtx;\n-\t  operands[1] = stack_label;\n-\t  if (TARGET_64BIT)\n-\t    output_asm_insn (\"sg\\t%0,%1\", operands);\n-\t  else\n-\t    output_asm_insn (\"s\\t%0,%1\", operands);\n+          /* It can happen that the GOT pointer isn't really needed ...  */\n+          REG_NOTES(insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, NULL_RTX,\n+                                               REG_NOTES (insn));\n \t}\n       else\n \t{\n-\t  fprintf (file, \"\\ta%shi\\t%s,-%ld\\n\",b64, \n-\t\t   reg_names[STACK_POINTER_REGNUM], frame_size);\n-\t}\n-#ifdef INCOMING_RETURN_ADDR_RTX\n-      if (dwarf2out_do_frame ())\n-\t{\n-\t  if (frame_pointer_needed)\n-\t    dwarf2out_def_cfa (\"\", HARD_FRAME_POINTER_REGNUM,\n-\t\t\t       STACK_POINTER_OFFSET+frame_size);\n-\t  else\n-\t    dwarf2out_def_cfa (\"\", STACK_POINTER_REGNUM,\n-\t\t\t       STACK_POINTER_OFFSET+frame_size);\n+          got_symbol = gen_rtx_UNSPEC (VOIDmode, \n+\t\t\t\t       gen_rtvec (1, got_symbol), 100);\n+          got_symbol = gen_rtx_CONST (VOIDmode, got_symbol);\n+\t  got_symbol = force_const_mem (Pmode, got_symbol);\n+\t  insn = emit_move_insn (pic_offset_table_rtx,\n+\t\t\t\t got_symbol);\t\t \n+\t  insn = emit_insn (gen_add2_insn (pic_offset_table_rtx,\n+\t\t\t\t\t   gen_rtx_REG (Pmode, BASE_REGISTER)));\n+\n+\t  /* We need the GOT pointer even if we don't know it ...  */\n+\t  emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));\n \t}\n-#endif\n+    }      \n+}\n \n+/* Expand the epilogue into a bunch of separate insns. */\n \n-      /* Generate backchain.  */\n+void\n+s390_emit_epilogue ()\n+{\n+  struct s390_frame frame;\n+  rtx frame_pointer, return_reg;\n+  int area_bottom, area_top, offset;\n+  rtvec p;\n \n-      if (TARGET_BACKCHAIN || (frame_size + STACK_POINTER_OFFSET > 4095\n-\t\t\t       || frame_pointer_needed\n-\t\t\t       || current_function_calls_alloca))\n-\t{\n-\t  fprintf (file, \"\\tst%s\\t%s,0(%s)\\n\", \n-                         b64, reg_names[1], reg_names[STACK_POINTER_REGNUM]);\n-\t}\n-    }\n+  /* Compute frame_info.  */\n+ \n+  s390_frame_info (&frame);\n+\n+  /* Check whether to use frame or stack pointer for restore.  */\n \n-  if (frame_pointer_needed)\n+  frame_pointer = frame.frame_pointer_p ? \n+    hard_frame_pointer_rtx : stack_pointer_rtx;\n+\n+  /* Compute which parts of the save area we need to access.  */\n+\n+  if (frame.first_restore_gpr != -1)\n     {\n-      fprintf (file, \"\\tl%sr\\t%s,%s\\n\", b64, \n-                     reg_names[FRAME_POINTER_REGNUM], \n-                     reg_names[STACK_POINTER_REGNUM]);\n+      area_bottom = frame.first_restore_gpr * UNITS_PER_WORD;\n+      area_top = (frame.last_save_gpr + 1) * UNITS_PER_WORD;\n+    }\n+  else\n+    {\n+      area_bottom = INT_MAX;\n+      area_top = INT_MIN;\n     }\n \n-  /* Load GOT if used and emit use insn that optimizer does not\n-     erase literal pool entry.  */\n-\n-  if (current_function_uses_pic_offset_table)\n+  if (TARGET_64BIT)\n     {\n-      rtx operands[3];\n-      if (TARGET_64BIT)\n+      if (frame.save_fprs_p)\n \t{\n-\t  fprintf (file, \"\\tlarl\\t%s,_GLOBAL_OFFSET_TABLE_\\n\",\n-\t\t\t reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+\t  if (area_bottom > -64)\n+\t    area_bottom = -64;\n+\t  if (area_top < 0)\n+\t    area_top = 0;\n \t}\n-      else\n+    }\n+  else\n+    {\n+      if (regs_ever_live[18])\n \t{\n-\t  operands[0] = gen_rtx (REG, Pmode, PIC_OFFSET_TABLE_REGNUM);\n-\t  operands[1] = got_label;\n-\t  operands[2] = gen_rtx (REG, Pmode, BASE_REGISTER);\n-\t  output_asm_insn (\"l\\t%0,%1\\n\\tar\\t%0,%2\", operands);\n+\t  if (area_bottom > STACK_POINTER_OFFSET - 16)\n+\t    area_bottom = STACK_POINTER_OFFSET - 16;\n+\t  if (area_top < STACK_POINTER_OFFSET - 8)\n+\t    area_top = STACK_POINTER_OFFSET - 8;\n+\t}\n+      if (regs_ever_live[19])\n+\t{\n+\t  if (area_bottom > STACK_POINTER_OFFSET - 8)\n+\t    area_bottom = STACK_POINTER_OFFSET - 8;\n+\t  if (area_top < STACK_POINTER_OFFSET)\n+\t    area_top = STACK_POINTER_OFFSET;\n \t}\n     }\n-  /* Save FPRs below save area.  */\n \n-  if (frame_size <= 4095)\n-    save_fprs (file, frame_size - 64, STACK_POINTER_REGNUM);\n+  /* Check whether we can access the register save area.  \n+     If not, increment the frame pointer as required.  */\n \n-  return;\n-}\n+  if (area_top <= area_bottom)\n+    {\n+      /* Nothing to restore.  */\n+    }\n+  else if (frame.frame_size + area_bottom >= 0\n+           && frame.frame_size + area_top <= 4096)\n+    {\n+      /* Area is in range.  */\n+      offset = frame.frame_size;\n+    }\n+  else\n+    {\n+      rtx insn, frame_off;\n \n-/* Output the function epilogue assembly code to the \n-   stdio stream FILE.  The local frame size is passed\n-   in LSIZE.  */\n+      offset = area_bottom < 0 ? -area_bottom : 0; \n+      frame_off = GEN_INT (frame.frame_size - offset);\n \n-void\n-s390_function_epilogue (file, lsize)\n-     FILE *file;\n-     HOST_WIDE_INT lsize;\n-{\n-/* Register is call clobbered and not used for eh or return.  */\n-#define FREE_REG 4\n+      if (!CONST_OK_FOR_LETTER_P (INTVAL (frame_off), 'K'))\n+\tframe_off = force_const_mem (Pmode, frame_off);\n \n-  int i;\n-  long frame_size;\n-  int return_reg = RETURN_REGNUM;\n-  int fp, offset;\n-  const char *const b64 = TARGET_64BIT ? \"g\" : \"\";\n+      insn = emit_insn (gen_add2_insn (frame_pointer, frame_off));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n \n-  frame_size = STARTING_FRAME_OFFSET + lsize + save_fprs_p () * 64;\n-  \n-  if (current_function_uses_pic_offset_table)\n-    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n-  \n-  if (leaf_function_flag)\n+  /* Restore call saved fprs.  */\n+\n+  if (TARGET_64BIT)\n     {\n-      for (i = 6; i < 13 && (regs_ever_live[i] == 0); i++);\n+      int i;\n \n-      if (s390_nr_constants || regs_ever_live[13] || i != 13)\n-\t{\n-\t    fprintf (file, \"\\tlm%s\\t%s,%s,%d(%s)\\n\", b64, \n-                     reg_names[i], reg_names[13],\n-\t\t     UNITS_PER_WORD * i,\n-\t\t     reg_names[STACK_POINTER_REGNUM]);\n-\t}\n-      if (!TARGET_64BIT)\n-\t{\n-\t  if (regs_ever_live[18])\n-\t    fprintf (file, \"\\tld\\t%s,%d(%s)\\n\", \n-\t\t     reg_names[18],\n-\t\t     STACK_POINTER_OFFSET-16,\n-\t\t     reg_names[STACK_POINTER_REGNUM]);\n-\t  if (regs_ever_live[19])\n-\t    fprintf (file, \"\\tld\\t%s,%d(%s)\\n\",\n-\t\t     reg_names[19],\n-\t\t     STACK_POINTER_OFFSET-8,\n-\t\t     reg_names[STACK_POINTER_REGNUM]);\n-\t}\n+      if (frame.save_fprs_p)\n+\tfor (i = 24; i < 32; i++)\n+\t  if (regs_ever_live[i])\n+\t    restore_fpr (frame_pointer, \n+\t\t\t offset - 64 + (i-24) * 8, i);\n     }\n   else\n     {\n-      for (i = 6; i < 13 && (regs_ever_live[i] == 0); i++);\n+      if (regs_ever_live[18])\n+\trestore_fpr (frame_pointer, offset + STACK_POINTER_OFFSET - 16, 18);\n+      if (regs_ever_live[19]) \n+\trestore_fpr (frame_pointer, offset + STACK_POINTER_OFFSET - 8, 19);\n+    }\n \n-      if (frame_size + STACK_POINTER_OFFSET > 4095)    \n+  /* Return register.  */\n+\n+  return_reg = gen_rtx_REG (Pmode, RETURN_REGNUM); \n+\n+  /* Restore call saved gprs.  */\n+\n+  if (frame.first_restore_gpr != -1)\n+    {\n+      rtx addr;\n+\n+      /* Fetch return address from stack before load multiple,\n+\t this will do good for scheduling.  */\n+\n+      if (frame.last_save_gpr >= RETURN_REGNUM \n+\t  && frame.first_restore_gpr < RETURN_REGNUM)\n \t{\n-\t  offset = 0;\n-\t  fp = STACK_POINTER_REGNUM;\n+\t  int return_regnum = find_unused_clobbered_reg();\n+\t  if (!return_regnum)\n+\t    return_regnum = 4;\n+\t  return_reg = gen_rtx_REG (Pmode, return_regnum);\n+\t\n+\t  addr = plus_constant (frame_pointer, \n+\t\t\t\toffset + RETURN_REGNUM * UNITS_PER_WORD); \n+\t  addr = gen_rtx_MEM (Pmode, addr);\n+\t  set_mem_alias_set (addr, s390_sr_alias_set);\n+\t  emit_move_insn (return_reg, addr);\n \t}\n-      else if (frame_pointer_needed || current_function_calls_alloca)\n+\n+      /* ??? As references to the base register are not made\n+\t explicit in insn RTX code, we have to add a barrier here\n+\t to prevent incorrect scheduling.  */\n+\n+      emit_insn (gen_blockage());      \n+\n+      addr = plus_constant (frame_pointer, \n+\t\t\t    offset + frame.first_restore_gpr * UNITS_PER_WORD);\n+      addr = gen_rtx_MEM (Pmode, addr);\n+      set_mem_alias_set (addr, s390_sr_alias_set);\n+\n+      if (frame.first_restore_gpr != frame.last_save_gpr)\n \t{\n-\t  offset = frame_size;\n-\t  fp = FRAME_POINTER_REGNUM;\n+\t  emit_insn (gen_load_multiple (\n+\t\t       gen_rtx_REG (Pmode, frame.first_restore_gpr),\n+                       addr,\n+\t\t       GEN_INT (frame.last_save_gpr - frame.first_restore_gpr + 1)));\n \t}\n       else\n \t{\n-\t  offset = frame_size;\n-\t  fp = STACK_POINTER_REGNUM;\n+\t  emit_move_insn (gen_rtx_REG (Pmode, frame.first_restore_gpr),\n+\t\t \t  addr); \n \t}\n+    }\n \n-      /* Restore from offset below save area.  */\n+  /* Return to caller.  */\n \n-      if (offset == 0)\n-\tfprintf (file, \"\\tl%s\\t%s,0(%s)\\n\", b64, \n-\t\t       reg_names[fp], reg_names[fp]);\n-      restore_fprs (file, offset-64, fp);\n-      return_reg = FREE_REG;\n-      fprintf (file, \"\\tl%s\\t%s,%d(%s)\\n\", b64, reg_names[return_reg], \n-\t       UNITS_PER_WORD*RETURN_REGNUM+offset, reg_names[fp]);\n-      if (!TARGET_64BIT)\n-\t{\n-\t  if (regs_ever_live[18])\n-\t    fprintf (file, \"\\tld\\t%s,%d(%s)\\n\", \n-\t\t     reg_names[18],\n-\t\t     offset+STACK_POINTER_OFFSET-16, reg_names[fp]);\n-\t  if (regs_ever_live[19])\n-\t    fprintf (file, \"\\tld\\t%s,%d(%s)\\n\",\n-\t\t     reg_names[19],\n-\t\t     offset+STACK_POINTER_OFFSET-8, reg_names[fp]);\n-\t}\n-      fprintf (file, \"\\tlm%s\\t%s,%s,%d(%s)\\n\", b64, \n-\t\t     reg_names[i], reg_names[15],\n-\t             (UNITS_PER_WORD * i) + offset, reg_names[fp]);\n-    }\n+  p = rtvec_alloc (2);\n   \n-  fprintf (file, \"\\tbr\\t%s\\n\", reg_names[return_reg]);\n-\n-  current_function_uses_pic_offset_table = 0;\n-  leaf_function_flag = 0;\n-  s390_pool_start_insn = NULL_RTX;\n-  s390_pool_count = -1;\n-  s390_function_count++;\n-  return;\n+  RTVEC_ELT (p, 0) = gen_rtx_RETURN (VOIDmode);\n+  RTVEC_ELT (p, 1) = gen_rtx_USE (VOIDmode, return_reg);\n+  emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, p));\n }\n \n \n@@ -3369,3 +3626,98 @@ s390_initialize_trampoline (addr, fnaddr, cxt)\n \t\t   memory_address (Pmode, \n \t\t   plus_constant (addr, (TARGET_64BIT ? 28 : 16) ))), fnaddr);\n }\n+\n+/* Return rtx for 64-bit constant formed from the 32-bit subwords\n+   LOW and HIGH, independent of the host word size.  */\n+\n+rtx\n+s390_gen_rtx_const_DI (high, low)\n+     int high;\n+     int low;\n+{\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+  HOST_WIDE_INT val;\n+  val = (HOST_WIDE_INT)high;\n+  val <<= 32;\n+  val |= (HOST_WIDE_INT)low;\n+  \n+  return GEN_INT (val);\n+#else\n+#if HOST_BITS_PER_WIDE_INT >= 32\n+  return immed_double_const ((HOST_WIDE_INT)low, (HOST_WIDE_INT)high, DImode);\n+#else\n+  abort ();\n+#endif\n+#endif\n+} \n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+void\n+s390_function_profiler (file, labelno)\n+     FILE *file;\n+     int labelno;\n+{\n+  rtx op[7];\n+\n+  char label[128];\n+  sprintf (label, \"%sP%d\", LPREFIX, labelno);\n+\n+  fprintf (file, \"# function profiler \\n\");\n+\n+  op[0] = gen_rtx_REG (Pmode, RETURN_REGNUM);\n+  op[1] = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n+  op[1] = gen_rtx_MEM (Pmode, plus_constant (op[1], UNITS_PER_WORD));\n+\n+  op[2] = gen_rtx_REG (Pmode, 1);\n+  op[3] = gen_rtx_SYMBOL_REF (Pmode, label);\n+  SYMBOL_REF_FLAG (op[3]) = 1;\n+\n+  op[4] = gen_rtx_SYMBOL_REF (Pmode, \"_mcount\");\n+  if (flag_pic)\n+    {\n+      op[4] = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op[4]), 113);\n+      op[4] = gen_rtx_CONST (Pmode, op[4]);\n+    }\n+\n+  if (TARGET_64BIT)\n+    {\n+      output_asm_insn (\"stg\\t%0,%1\", op);\n+      output_asm_insn (\"larl\\t%2,%3\", op);\n+      output_asm_insn (\"brasl\\t%0,%4\", op);\n+      output_asm_insn (\"lg\\t%0,%1\", op);\n+    }\n+  else if (!flag_pic)\n+    {\n+      op[6] = gen_label_rtx ();\n+\n+      output_asm_insn (\"st\\t%0,%1\", op);\n+      output_asm_insn (\"bras\\t%2,%l6\", op);\n+      output_asm_insn (\".long\\t%3\", op);\n+      output_asm_insn (\".long\\t%4\", op);\n+      ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (op[6]));\n+      output_asm_insn (\"l\\t%0,0(%2)\", op);\n+      output_asm_insn (\"l\\t%2,4(%2)\", op);\n+      output_asm_insn (\"basr\\t%0,%0\", op);\n+      output_asm_insn (\"l\\t%0,%1\", op);\n+    }\n+  else\n+    {\n+      op[5] = gen_label_rtx ();\n+      op[6] = gen_label_rtx ();\n+\n+      output_asm_insn (\"st\\t%0,%1\", op);\n+      output_asm_insn (\"bras\\t%2,%l6\", op);\n+      ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (op[5]));\n+      output_asm_insn (\".long\\t%3-%l5\", op);\n+      output_asm_insn (\".long\\t%4-%l5\", op);\n+      ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (op[6]));\n+      output_asm_insn (\"lr\\t%0,%2\", op);\n+      output_asm_insn (\"a\\t%0,0(%2)\", op);\n+      output_asm_insn (\"a\\t%2,4(%2)\", op);\n+      output_asm_insn (\"basr\\t%0,%0\", op);\n+      output_asm_insn (\"l\\t%0,%1\", op);\n+    }\n+}\n+"}, {"sha": "988d7e26563820b93d87065e389f9a860b7d0837", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 133, "deletions": 108, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4023fb284388c170db87fcf01ecceced50dac8aa/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4023fb284388c170db87fcf01ecceced50dac8aa/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=4023fb284388c170db87fcf01ecceced50dac8aa", "patch": "@@ -65,6 +65,14 @@ extern int target_flags;\n /* Define this to change the optimizations performed by default.  */\n #define OPTIMIZATION_OPTIONS(LEVEL, SIZE) optimization_options(LEVEL, SIZE)\n \n+/* Sometimes certain combinations of command options do not make sense\n+   on a particular target machine.  You can define a macro\n+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n+   defined, is executed once just after all the command options have\n+   been parsed.  */\n+#define OVERRIDE_OPTIONS override_options ()\n+\n+\n /* Defines for REAL_ARITHMETIC.  */\n #define IEEE_FLOAT 1\n #define TARGET_IBM_FLOAT           0\n@@ -236,7 +244,12 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n    G5 and following have 16 IEEE floating point register,\n    which get numbers 16-31.  */\n \n-#define FIRST_PSEUDO_REGISTER 34\n+#define FIRST_PSEUDO_REGISTER 35\n+\n+/* Number of hardware registers that go into the DWARF-2 unwind info.\n+   If not defined, equals FIRST_PSEUDO_REGISTER.  */\n+\n+#define DWARF_FRAME_REGISTERS 34\n \n /* The following register have a fix usage\n    GPR 12: GOT register points to the GOT, setup in prologue,\n@@ -260,7 +273,7 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n   0, 0, 0, 0, \t\t\t\t\t\\\n   0, 0, 0, 0, \t\t\t\t\t\\\n   0, 0, 0, 0, \t\t\t\t\t\\\n-  1, 1 }\n+  1, 1, 1 }\n \n /* 1 for registers not available across function calls.  These must include\n    the FIXED_REGISTERS and also any registers that can be used without being\n@@ -273,22 +286,49 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n   1, 1, 0, 0, \t\t\t\t\t\\\n   0, 0, 0, 0, \t\t\t\t\t\\\n   0, 1, 1, 1,\t\t\t\t\t\\\n+  1, 1, 1, 1, \t\t\t\t\t\\\n+  1, 1, 1, 1, \t\t\t\t\t\\\n+  1, 1, 1, 1, \t\t\t\t\t\\\n+  1, 1, 1, 1, \t\t\t\t\t\\\n+  1, 1, 1 }\n+\n+/* Like `CALL_USED_REGISTERS' except this macro doesn't require that\n+   the entire set of `FIXED_REGISTERS' be included.\n+   (`CALL_USED_REGISTERS' must be a superset of `FIXED_REGISTERS').  */\n+\n+#define CALL_REALLY_USED_REGISTERS\t\t\\\n+{ 1, 1, 1, 1, \t\t\t\t\t\\\n   1, 1, 0, 0, \t\t\t\t\t\\\n+  0, 0, 0, 0, \t\t\t\t\t\\\n+  0, 0, 0, 0,\t\t\t\t\t\\\n   1, 1, 1, 1, \t\t\t\t\t\\\n   1, 1, 1, 1, \t\t\t\t\t\\\n   1, 1, 1, 1, \t\t\t\t\t\\\n-  1, 1 }\n+  1, 1, 1, 1, \t\t\t\t\t\\\n+  1, 1, 1 }\n \n-/* If not pic code, gpr 12 can be used.  */\n+/* Macro to conditionally modify fixed_regs/call_used_regs.  */\n \n #define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n+    int i;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n     if (flag_pic)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \tfixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n \tcall_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n+    if (TARGET_64BIT)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        for (i = 24; i < 32; i++)\t\t\t\t\\\n+\t    call_used_regs[i] = call_really_used_regs[i] = 0;\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        for (i = 18; i < 20; i++)\t\t\t\t\\\n+\t    call_used_regs[i] = call_really_used_regs[i] = 0;\t\\\n+      }\t\t\t\t\t\t\t\t\\\n  } while (0)\n \n /* The following register have a special usage\n@@ -298,7 +338,8 @@ do\t\t\t\t\t\t\t\t\\\n \t   with stack- or frame-pointer. \n    GPR 33: Condition code 'register' */\n \n-#define FRAME_POINTER_REGNUM 11\n+#define HARD_FRAME_POINTER_REGNUM 11\n+#define FRAME_POINTER_REGNUM 34\n \n #define ARG_POINTER_REGNUM 32\n \n@@ -333,7 +374,8 @@ do\t\t\t\t\t\t\t\t\\\n #define HARD_REGNO_MODE_OK(REGNO, MODE)                             \\\n   (FLOAT_REGNO_P(REGNO)?                                            \\\n    (GET_MODE_CLASS(MODE) == MODE_FLOAT ||                           \\\n-    GET_MODE_CLASS(MODE) == MODE_COMPLEX_FLOAT) :                   \\\n+    GET_MODE_CLASS(MODE) == MODE_COMPLEX_FLOAT ||                   \\\n+    (MODE) == SImode || (MODE) == DImode) :                         \\\n    INT_REGNO_P(REGNO)?                                              \\\n     (HARD_REGNO_NREGS(REGNO, MODE) == 1 || !((REGNO) & 1)) :        \\\n    CC_REGNO_P(REGNO)?                                               \\\n@@ -349,6 +391,15 @@ do\t\t\t\t\t\t\t\t\\\n    (((MODE1) == SFmode || (MODE1) == DFmode)\t\\\n    == ((MODE2) == SFmode || (MODE2) == DFmode))\n \n+/* If defined, gives a class of registers that cannot be used as the\n+   operand of a SUBREG that changes the mode of the object illegally.  */\n+\n+#define CLASS_CANNOT_CHANGE_MODE FP_REGS\n+\n+/* Defines illegal mode changes for CLASS_CANNOT_CHANGE_MODE.  */\n+\n+#define CLASS_CANNOT_CHANGE_MODE_P(FROM,TO) \\\n+  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO))\n \n /* Define this macro if references to a symbol must be treated\n    differently depending on something about the variable or\n@@ -383,15 +434,20 @@ while (0)\n \n #define ELIMINABLE_REGS\t\t\t\t        \\\n {{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t        \\\n+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},    \\\n  { ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t        \\\n- { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM}}  \n+ { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}  \n \n #define CAN_ELIMINATE(FROM, TO) (1)\n \n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \t\t\t  \\\n { if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM) \t  \\\n   { (OFFSET) = 0; }     \t\t\t\t\t\t  \\\n-  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM)  \\\n+  else  if ((FROM) == FRAME_POINTER_REGNUM                                \\\n+\t    && (TO) == HARD_FRAME_POINTER_REGNUM)                \t  \\\n+  { (OFFSET) = 0; }     \t\t\t\t\t\t  \\\n+  else if ((FROM) == ARG_POINTER_REGNUM                                   \\\n+            && (TO) == HARD_FRAME_POINTER_REGNUM)                         \\\n   { (OFFSET) = s390_arg_frame_offset (); }     \t\t\t\t  \\\n   else if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)  \\\n   { (OFFSET) = s390_arg_frame_offset (); }     \t\t\t\t  \\\n@@ -433,15 +489,17 @@ while (0)\n enum reg_class\n {\n   NO_REGS, ADDR_REGS, GENERAL_REGS,\n-  FP_REGS, ALL_REGS, LIM_REG_CLASSES\n+  FP_REGS, ADDR_FP_REGS, GENERAL_FP_REGS,\n+  ALL_REGS, LIM_REG_CLASSES\n };\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n /* Give names of register classes as strings for dump file.  */\n \n #define REG_CLASS_NAMES                                                 \\\n-{ \"NO_REGS\",\"ADDR_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"ALL_REGS\" }\n+{ \"NO_REGS\", \"ADDR_REGS\", \"GENERAL_REGS\", \t\t\t\t\\\n+  \"FP_REGS\", \"ADDR_FP_REGS\", \"GENERAL_FP_REGS\", \"ALL_REGS\" }\n \n /* Define which registers fit in which classes.  This is an initializer for\n    a vector of HARD_REG_SET of length N_REG_CLASSES.\n@@ -450,10 +508,12 @@ enum reg_class\n #define REG_CLASS_CONTENTS \\\n {\t\t\t\t       \t\t\t\\\n   { 0x00000000, 0x00000000 },\t/* NO_REGS */\t\t\\\n-  { 0x0000fffe, 0x00000001 },\t/* ADDR_REGS */\t\t\\\n-  { 0x0000ffff, 0x00000001 },\t/* GENERAL_REGS */\t\\\n+  { 0x0000fffe, 0x00000005 },\t/* ADDR_REGS */\t\t\\\n+  { 0x0000ffff, 0x00000005 },\t/* GENERAL_REGS */\t\\\n   { 0xffff0000, 0x00000000 },\t/* FP_REGS */\t\t\\\n-  { 0xffffffff, 0x00000003 },\t/* ALL_REGS */\t\t\\\n+  { 0xfffffffe, 0x00000005 },\t/* ADDR_FP_REGS */\t\\\n+  { 0xffffffff, 0x00000005 },\t/* GENERAL_FP_REGS */\t\\\n+  { 0xffffffff, 0x00000007 },\t/* ALL_REGS */\t\t\\\n }\n \n \n@@ -506,15 +566,8 @@ extern enum reg_class regclass_map[];\t/* smalled class containing REGNO   */\n    but on some machines in some cases it is preferable to use a more\n    restrictive class.  */\n \n-#define PREFERRED_RELOAD_CLASS(X, CLASS)                                 \\\n-    (GET_CODE (X) == CONST_DOUBLE ?                                      \\\n-     (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT ? FP_REGS : ADDR_REGS) :\\\n-     (GET_CODE (X) == CONST_INT ?                                        \\\n-     (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT ? FP_REGS : ADDR_REGS) :\\\n-     GET_CODE (X) == PLUS ||                                            \\\n-     GET_CODE (X) == LABEL_REF ||                                        \\\n-     GET_CODE (X) == SYMBOL_REF ||                                       \\\n-     GET_CODE (X) == CONST ? ADDR_REGS : (CLASS)))\n+#define PREFERRED_RELOAD_CLASS(X, CLASS)\t\\\n+\ts390_preferred_reload_class ((X), (CLASS))\n \n /* Return the maximum number of consecutive registers needed to represent\n    mode MODE in a register of class CLASS.  */\n@@ -557,26 +610,21 @@ extern enum reg_class regclass_map[];\t/* smalled class containing REGNO   */\n \n /* Stack layout; function entry, exit and calling.  */\n \n-/* The current return address is on Offset 56 of the current frame\n-   if we are in an leaf_function. Otherwise we have to go one stack\n-   back.\n-   The return address of anything farther back is accessed normally\n-   at an offset of 56 from the frame pointer.\n-\n-   FIXME: builtin_return_addr does not work correctly in a leaf\n-          function, we need to find way to find out, if we\n-          are in a leaf function\n-  */\n-\n-#define _RETURN_ADDR_OFFSET (TARGET_64BIT ? 112 : 56)\n-\n-#define RETURN_ADDR_RTX(count, frame)                                   \\\n-   gen_rtx (MEM, Pmode,                                                 \\\n-            memory_address (Pmode,                                      \\\n-                              plus_constant (                           \\\n-                              copy_to_reg (gen_rtx (MEM, Pmode,         \\\n-                              memory_address (Pmode, frame))),          \\\n-                              _RETURN_ADDR_OFFSET)));\n+/* The return address of the current frame is retrieved \n+   from the initial value of register RETURN_REGNUM.\n+   For frames farther back, we use the stack slot where\n+   the corresponding RETURN_REGNUM register was saved.  */\n+\n+#define DYNAMIC_CHAIN_ADDRESS(FRAME)\t\t\t\t\t\t\\\n+  ((FRAME) != hard_frame_pointer_rtx ? (FRAME) :\t\t\t\t\\\n+   plus_constant (arg_pointer_rtx, -STACK_POINTER_OFFSET))\n+     \n+#define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t\t\\\n+  ((COUNT) == 0 ? get_hard_reg_initial_val (Pmode, RETURN_REGNUM) :\t\t\\\n+   gen_rtx_MEM (Pmode,\t\t\t\t\t\t\t\t\\\n+                memory_address (Pmode, \t\t\t\t\t\t\\\n+                                plus_constant (DYNAMIC_CHAIN_ADDRESS ((FRAME)),\t\\\n+                                               RETURN_REGNUM * UNITS_PER_WORD))))\n \n /* The following macros will turn on dwarf2 exception hndling\n    Other code location for this exception handling are \n@@ -588,6 +636,11 @@ extern enum reg_class regclass_map[];\t/* smalled class containing REGNO   */\n \n #define MASK_RETURN_ADDR (GEN_INT (0x7fffffff))\n \n+/* The offset from the incoming value of %sp to the top of the stack frame\n+   for the current function.  */\n+\n+#define INCOMING_FRAME_SP_OFFSET STACK_POINTER_OFFSET\n+\n /* Location, from where return address to load.  */\n \n #define DWARF_FRAME_RETURN_COLUMN  14\n@@ -813,47 +866,7 @@ CUMULATIVE_ARGS;\n    for profiling a function entry.  */\n \n #define FUNCTION_PROFILER(FILE, LABELNO) \t\t\t\\\n-do {                                     \t\t\t\\\n-  extern rtx s390_profile[];  \t\t\t\t\t\\\n-  extern int s390_pool_count;     \t\t\t\t\\\n-  static char label[128];                     \t\t\t\\\n-  fprintf (FILE, \"# function profiler \\n\");   \t\t\t\\\n-  if (TARGET_64BIT) \t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      rtx tmp[1];\t\t\t\t\t\t\\\n-      output_asm_insn (\"stg\\t14,8(15)\", tmp);\t\t\t\\\n-      sprintf (label, \"%sP%d\", LPREFIX, LABELNO);       \t\\\n-      tmp[0] = gen_rtx_SYMBOL_REF (Pmode, label);\t\t\\\n-      SYMBOL_REF_FLAG (tmp[0]) = 1;\t\t\t\t\\\n-      output_asm_insn (\"larl\\t1,%0\", tmp);      \t\t\\\n-      tmp[0] = gen_rtx_SYMBOL_REF (Pmode, \"_mcount\");\t        \\\n-      if (flag_pic)\t\t\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\\\n-          tmp[0] = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, tmp[0]), 113); \\\n-          tmp[0] = gen_rtx_CONST (Pmode, tmp[0]);\t\t\\\n-        }\t\t\t\t\t\t\t\\\n-      output_asm_insn (\"brasl\\t14,%0\", tmp);\t\t\t\\\n-      output_asm_insn (\"lg\\t14,8(15)\", tmp);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    {  \t\t\t\t\t\t\t\t\\\n-      output_asm_insn (\"l     14,4(15)\", s390_profile);\t\t\\\n-      s390_pool_count = 0;                             \t\t\\\n-      output_asm_insn (\"st    14,4(15)\", s390_profile);\t\t\\\n-      output_asm_insn (\"l     14,%4\", s390_profile);\t\t\\\n-      output_asm_insn (\"l     1,%9\", s390_profile);\t\t\\\n-      if (flag_pic) \t\t\t\t\t\t\\\n-\t{   \t\t\t\t\t\t\t\\\n-\t  output_asm_insn (\"ar    1,13\", s390_profile);   \t\\\n-\t  output_asm_insn (\"bas   14,0(14,13)\", s390_profile); \t\\\n-\t} \t\t\t\t\t\t\t\\\n-      else \t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  output_asm_insn (\"basr  14,14\", s390_profile);\t\\\n-\t}                  \t\t\t\t\t\\\n-      output_asm_insn (\"l     14,4(15)\", s390_profile);\t\t\\\n-    }                     \t\t\t\t\t\\\n-} while (0)\n+\ts390_function_profiler ((FILE), ((LABELNO)))\n \n /* #define PROFILE_BEFORE_PROLOGUE */\n \n@@ -875,9 +888,9 @@ do {                                     \t\t\t\\\n    reg currently allocated to a suitable hard reg.\n    These definitions are NOT overridden anywhere.  */\n \n-#define REGNO_OK_FOR_INDEX_P(REGNO)                                     \\\n-  (((REGNO) > 0 && (REGNO) < 16) || (REGNO) == ARG_POINTER_REGNUM       \\\n-   /* || (REGNO) == FRAME_POINTER_REGNUM */                                 \\\n+#define REGNO_OK_FOR_INDEX_P(REGNO)\t\t\t\t\t\\\n+    (((REGNO) < FIRST_PSEUDO_REGISTER \t\t\t\t\t\\\n+     && REGNO_REG_CLASS ((REGNO)) == ADDR_REGS) \t\t\t\\\n     || (reg_renumber[REGNO] > 0 && reg_renumber[REGNO] < 16))\n \n #define REGNO_OK_FOR_BASE_P(REGNO) REGNO_OK_FOR_INDEX_P (REGNO)\n@@ -947,11 +960,10 @@ do {                                     \t\t\t\\\n  * a pseudo reg.  \n  */\n \n-#define REG_OK_FOR_INDEX_NONSTRICT_P(X)               \t\t\t\\\n-((GET_MODE (X) == Pmode) &&\t\t\t\t\t\t\\\n- ((REGNO (X) > 0 && REGNO (X) < 16) ||\t\t\t\t\t\\\n-  (REGNO (X) == ARG_POINTER_REGNUM) ||\t\t\t\t\t\\\n-  (REGNO (X) >= FIRST_PSEUDO_REGISTER)))\n+#define REG_OK_FOR_INDEX_NONSTRICT_P(X)   \t\\\n+((GET_MODE (X) == Pmode) &&\t\t\t\\\n+ ((REGNO (X) >= FIRST_PSEUDO_REGISTER) \t\t\\\n+  || REGNO_REG_CLASS (REGNO (X)) == ADDR_REGS))  \n \n /* Nonzero if X is a hard reg that can be used as a base reg or if it is\n    a pseudo reg.  */\n@@ -1080,10 +1092,6 @@ do {                                     \t\t\t\\\n \n /* #define STORE_FLAG_VALUE -1 */\n \n-/* When a prototype says `char' or `short', really pass an `int'.  */\n-\n-#define PROMOTE_PROTOTYPES 1\n-\n /* Don't perform CSE on function addresses.  */\n \n #define NO_FUNCTION_CSE\n@@ -1269,13 +1277,14 @@ extern struct rtx_def *s390_compare_op0, *s390_compare_op1;\n   \"%r8\",  \"%r9\", \"%r10\", \"%r11\", \"%r12\", \"%r13\", \"%r14\", \"%r15\",\t\\\n   \"%f0\",  \"%f2\",  \"%f4\",  \"%f6\",  \"%f1\",  \"%f3\",  \"%f5\",  \"%f7\",\t\\\n   \"%f8\",  \"%f10\", \"%f12\", \"%f14\", \"%f9\", \"%f11\", \"%f13\", \"%f15\",\t\\\n-  \"%ap\", \"%cc\"\t\t\t\t\t\t\t\t\\\n+  \"%ap\",  \"%cc\",  \"%fp\"\t\t\t\t\t\t\t\\\n }\n \n /* implicit call of memcpy, not bcopy   */\n \n #define TARGET_MEM_FUNCTIONS\n \n+\n /* Print operand X (an rtx) in assembler syntax to file FILE.\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n    For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n@@ -1287,17 +1296,29 @@ extern struct rtx_def *s390_compare_op0, *s390_compare_op1;\n \n /* Define the codes that are matched by predicates in aux-output.c.  */\n \n-#define PREDICATE_CODES                                                 \\\n-  {\"s_operand\",       { MEM }},                                          \\\n-  {\"bras_sym_operand\",{ SYMBOL_REF, CONST }},                            \\\n-  {\"r_or_s_operand\",  { MEM, SUBREG, REG }},                             \\\n-  {\"r_or_im8_operand\",  { CONST_INT, SUBREG, REG }},                     \\\n-  {\"r_or_s_or_im8_operand\",  { MEM, SUBREG, REG, CONST_INT }},           \\\n-  {\"r_or_x_or_im16_operand\", { MEM, SUBREG, REG, CONST_INT }},           \\\n-  {\"const0_operand\", { CONST_INT, CONST_DOUBLE }},\t                 \\\n-  {\"const1_operand\", { CONST_INT, CONST_DOUBLE }},\t                 \\\n-  {\"tmxx_operand\", { CONST_INT, MEM }},\n-\n+#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n+  {\"s_operand\",       { SUBREG, MEM }},\t\t\t\t\t\\\n+  {\"s_imm_operand\",   { CONST_INT, CONST_DOUBLE, SUBREG, MEM }},\t\\\n+  {\"bras_sym_operand\",{ SYMBOL_REF, CONST }},\t\t\t\t\\\n+  {\"larl_operand\",    { SYMBOL_REF, CONST, CONST_INT, CONST_DOUBLE }},\t\\\n+  {\"load_multiple_operation\", {PARALLEL}},\t\t\t        \\\n+  {\"store_multiple_operation\", {PARALLEL}},\t\t\t        \\\n+  {\"const0_operand\",  { CONST_INT, CONST_DOUBLE }},\n+\n+\n+/* S/390 constant pool breaks the devices in crtstuff.c to control section\n+   in where code resides.  We have to write it as asm code.  */\n+#ifndef __s390x__\n+#define CRT_CALL_STATIC_FUNCTION(func) \\\n+  if (0) \\\n+     func (); /* ... to avoid warnings.  */ \\\n+  else \\\n+    asm \\\n+      (\"bras\\t%%r2,1f\\n\\\n+0:\t.long\\t\" #func \" - 0b\\n\\\n+1:\tl\\t%%r3,0(%%r2)\\n\\\n+\tbas\\t%%r14,0(%%r3,%%r2)\" : : : \"2\", \"3\", \"cc\", \"memory\");\n+#endif\n \n /* Constant Pool for all symbols operands which are changed with\n    force_const_mem during insn generation (expand_insn).  */\n@@ -1397,7 +1418,11 @@ extern int s390_nr_constants;\n           fputc ('\\n', (FILE));\t\t\t\t\t\t    \\\n \t}\t\t\t\t\t\t\t\t    \\\n       else\t\t\t\t\t\t\t\t    \\\n-        assemble_integer (EXP, GET_MODE_SIZE (MODE), ALIGN, 1);\t\t    \\\n+\t{\t\t\t\t\t\t\t\t    \\\n+\t  assemble_integer (EXP, GET_MODE_SIZE (MODE), ALIGN, 1);\t    \\\n+\t  if (GET_MODE_SIZE (MODE) == 1)\t\t\t\t    \\\n+\t    ASM_OUTPUT_SKIP ((FILE), 1);\t\t\t\t    \\\n+\t}\t\t\t\t\t\t\t\t    \\\n       break;\t\t\t\t\t\t\t\t    \\\n \t\t\t\t\t\t\t\t\t    \\\n     default:\t\t\t\t\t\t\t\t    \\"}, {"sha": "a056110378acd8baec8d5356a4a1a70ae5aedff7", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 2195, "deletions": 1465, "changes": 3660, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4023fb284388c170db87fcf01ecceced50dac8aa/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4023fb284388c170db87fcf01ecceced50dac8aa/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=4023fb284388c170db87fcf01ecceced50dac8aa"}, {"sha": "bc8d519b2d12625987098af5a2e18c146ec7314b", "filename": "gcc/config/s390/t-linux", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4023fb284388c170db87fcf01ecceced50dac8aa/gcc%2Fconfig%2Fs390%2Ft-linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4023fb284388c170db87fcf01ecceced50dac8aa/gcc%2Fconfig%2Fs390%2Ft-linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Ft-linux?ref=4023fb284388c170db87fcf01ecceced50dac8aa", "patch": "@@ -1,5 +1,6 @@\n # The crtbegin and crtend must not depend on a small GOT\n CRTSTUFF_T_CFLAGS = -O2 -fPIC\n+CRTSTUFF_T_CFLAGS_S = -O2 -fPIC\n \n # Compile libgcc2.a with pic.\n TARGET_LIBGCC2_CFLAGS = -fPIC -include $(srcdir)/config/s390/fixdfdi.h"}]}