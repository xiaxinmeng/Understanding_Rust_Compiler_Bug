{"sha": "bbeffd6b40a97a661e78e10556a5b5f3edc4d78f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJlZmZkNmI0MGE5N2E2NjFlNzhlMTA1NTZhNWI1ZjNlZGM0ZDc4Zg==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-08-14T16:45:55Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-08-14T16:45:55Z"}, "message": "re PR fortran/47586 ([F03] allocatable components: deep copy missing)\n\nfortran/\n\tPR fortran/47586\n\t* trans-expr.c (expr_is_variable): Handle regular, procedure pointer,\n\tand typebound functions returning a data pointer.\n\ntestsuite/\n\tPR fortran/47586\n\t* gfortran.dg/typebound_proc_20.f90: Enable runtime test.\n\t* gfortran.dg/typebound_proc_27.f03: New test.\n\nFrom-SVN: r190394", "tree": {"sha": "5c06ec0e03bb0ba229ec6bc79ac71362f4c78f3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c06ec0e03bb0ba229ec6bc79ac71362f4c78f3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbeffd6b40a97a661e78e10556a5b5f3edc4d78f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbeffd6b40a97a661e78e10556a5b5f3edc4d78f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbeffd6b40a97a661e78e10556a5b5f3edc4d78f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbeffd6b40a97a661e78e10556a5b5f3edc4d78f/comments", "author": null, "committer": null, "parents": [{"sha": "d7fee03dfcf056a7c77052327a2e5f9284ea271d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7fee03dfcf056a7c77052327a2e5f9284ea271d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7fee03dfcf056a7c77052327a2e5f9284ea271d"}], "stats": {"total": 150, "additions": 148, "deletions": 2}, "files": [{"sha": "7161b62e09e378268d094591d3dee11e162a90a5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeffd6b40a97a661e78e10556a5b5f3edc4d78f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeffd6b40a97a661e78e10556a5b5f3edc4d78f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=bbeffd6b40a97a661e78e10556a5b5f3edc4d78f", "patch": "@@ -1,3 +1,9 @@\n+2012-08-14  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/47586\n+\t* trans-expr.c (expr_is_variable): Handle regular, procedure pointer,\n+\tand typebound functions returning a data pointer.\n+\n 2012-08-14  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* decl.c (match_ppc_decl): Copy the procedure interface's symbol"}, {"sha": "4f7d02620ad177de1aef3d66ff12ff2067fb2a79", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeffd6b40a97a661e78e10556a5b5f3edc4d78f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeffd6b40a97a661e78e10556a5b5f3edc4d78f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=bbeffd6b40a97a661e78e10556a5b5f3edc4d78f", "patch": "@@ -6961,6 +6961,8 @@ static bool\n expr_is_variable (gfc_expr *expr)\n {\n   gfc_expr *arg;\n+  gfc_component *comp;\n+  gfc_symbol *func_ifc;\n \n   if (expr->expr_type == EXPR_VARIABLE)\n     return true;\n@@ -6972,7 +6974,50 @@ expr_is_variable (gfc_expr *expr)\n       return expr_is_variable (arg);\n     }\n \n+  /* A data-pointer-returning function should be considered as a variable\n+     too.  */\n+  if (expr->expr_type == EXPR_FUNCTION\n+      && expr->ref == NULL)\n+    {\n+      if (expr->value.function.isym != NULL)\n+\treturn false;\n+\n+      if (expr->value.function.esym != NULL)\n+\t{\n+\t  func_ifc = expr->value.function.esym;\n+\t  goto found_ifc;\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (expr->symtree);\n+\t  func_ifc = expr->symtree->n.sym;\n+\t  goto found_ifc;\n+\t}\n+\n+      gcc_unreachable ();\n+    }\n+\n+  comp = gfc_get_proc_ptr_comp (expr);\n+  if ((expr->expr_type == EXPR_PPC || expr->expr_type == EXPR_FUNCTION)\n+      && comp)\n+    {\n+      func_ifc = comp->ts.interface;\n+      goto found_ifc;\n+    }\n+\n+  if (expr->expr_type == EXPR_COMPCALL)\n+    {\n+      gcc_assert (!expr->value.compcall.tbp->is_generic);\n+      func_ifc = expr->value.compcall.tbp->u.specific->n.sym;\n+      goto found_ifc;\n+    }\n+\n   return false;\n+\n+found_ifc:\n+  gcc_assert (func_ifc->attr.function\n+\t      && func_ifc->result != NULL);\n+  return func_ifc->result->attr.pointer;\n }\n \n "}, {"sha": "8d1fea7dd359514e150c8baa68cbb9c6514d24dd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeffd6b40a97a661e78e10556a5b5f3edc4d78f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeffd6b40a97a661e78e10556a5b5f3edc4d78f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bbeffd6b40a97a661e78e10556a5b5f3edc4d78f", "patch": "@@ -1,3 +1,9 @@\n+2012-08-14  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/47586\n+\t* gfortran.dg/typebound_proc_20.f90: Enable runtime test.\n+\t* gfortran.dg/typebound_proc_27.f03: New test.\n+\n 2012-08-14  Sterling Augustine  <saugustine@google.com>\n \n \t* g++.dg/debug/dwarf2/pubnames-2.C: Adjust."}, {"sha": "47c131c5f2091098e02240d989bc9588a2b26ad4", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_20.f90", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeffd6b40a97a661e78e10556a5b5f3edc4d78f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_20.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeffd6b40a97a661e78e10556a5b5f3edc4d78f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_20.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_20.f90?ref=bbeffd6b40a97a661e78e10556a5b5f3edc4d78f", "patch": "@@ -1,5 +1,4 @@\n-! { dg-do compile }\n-! TODO: make runtime testcase once bug is fixed\n+! { dg-do run }\n !\n ! PR fortran/47455\n !"}, {"sha": "28c44dff120d065423db5bf8cca28e91f8ebc3a1", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_27.f03", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeffd6b40a97a661e78e10556a5b5f3edc4d78f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_27.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeffd6b40a97a661e78e10556a5b5f3edc4d78f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_27.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_27.f03?ref=bbeffd6b40a97a661e78e10556a5b5f3edc4d78f", "patch": "@@ -0,0 +1,90 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+! \n+! PR fortran/47586\n+! Missing deep copy for data pointer returning functions when the type\n+! has allocatable components\n+!\n+! Original testcase by Thomas Henlich  <thenlich@users.sourceforge.net>\n+! Reduced by Tobias Burnus  <burnus@net-b.de>\n+!\n+\n+module m\n+  type :: tx\n+    integer, dimension(:), allocatable :: i\n+  end type tx\n+  type proc_t\n+    procedure(find_x), nopass, pointer :: ppc => null()\n+   contains\n+    procedure, nopass :: tbp => find_x\n+  end type proc_t\n+\n+contains\n+\n+  function find_x(that)\n+    type(tx), target  :: that\n+    type(tx), pointer :: find_x\n+    find_x => that\n+  end function find_x\n+\n+end module m\n+\n+program prog\n+\n+  use m\n+\n+  type(tx) :: this\n+  type(tx), target :: that\n+  type(tx), pointer :: p\n+\n+  type(proc_t) :: tab\n+\n+  allocate(that%i(2))\n+  that%i = [3, 7]\n+  p => that\n+  this = that  ! (1) direct assignment: works (deep copy)\n+  that%i = [2, -5]\n+  !print *,this%i\n+  if(any (this%i /= [3, 7])) call abort()\n+  this = p     ! (2) using a pointer works as well\n+  that%i = [10, 1]\n+  !print *,this%i\n+  if(any (this%i /= [2, -5])) call abort()\n+  this = find_x(that)  ! (3) pointer function: used to fail (deep copy missing)\n+  that%i = [4, 6]\n+  !print *,this%i\n+  if(any (this%i /= [10, 1])) call abort()\n+  this = tab%tbp(that)  ! other case: typebound procedure\n+  that%i = [8, 9]\n+  !print *,this%i\n+  if(any (this%i /= [4, 6])) call abort()\n+  tab%ppc => find_x\n+  this = tab%ppc(that)  ! other case: procedure pointer component\n+  that%i = [-1, 2]\n+  !print *,this%i\n+  if(any (this%i /= [8, 9])) call abort()\n+\n+end program prog\n+\n+!\n+! We add another check for deep copy by looking at the dump.\n+! We use realloc on assignment here: if we do a deep copy  for the assignment\n+! to `this', we have a reallocation of `this%i'.\n+! Thus, the total number of malloc calls should be the number of assignment to\n+! `that%i' + the number of assignments to `this' + the number of allocate\n+! statements.\n+! It is assumed that if the number of allocate is right, the number of\n+! deep copies is right too.\n+! { dg-final { scan-tree-dump-times \"__builtin_malloc\" 12 \"original\" } }\n+\n+!\n+! Realloc are only used for assignments to `that%i'.  Don't know why.\n+! { dg-final { scan-tree-dump-times \"__builtin_realloc\" 6 \"original\" } }\n+! \n+\n+! No leak: Only assignments to `this' use malloc.  Assignments to `that%i'\n+! take the realloc path after the first assignment, so don't count as a malloc.\n+! { dg-final { scan-tree-dump-times \"__builtin_free\" 7 \"original\" } }\n+!\n+! { dg-final { cleanup-tree-dump \"original\" } }\n+"}]}