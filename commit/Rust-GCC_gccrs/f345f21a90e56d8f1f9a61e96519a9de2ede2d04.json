{"sha": "f345f21a90e56d8f1f9a61e96519a9de2ede2d04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM0NWYyMWE5MGU1NmQ4ZjFmOWE2MWU5NjUxOWE5ZGUyZWRlMmQwNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-03-04T21:31:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-03-04T21:31:43Z"}, "message": "reload.c (find_reloads): Reorganize if seqeunce to switch.\n\n\n\t* reload.c (find_reloads): Reorganize if seqeunce to switch.\n\n\t* cfgrtl.c (rtl_redirect_edge_and_branch):  Set the source BB as dirty.\n\t(cfglayout_redirect_edge_and_branch):  Set the source BB as dirty.\n\nFrom-SVN: r78936", "tree": {"sha": "c75dac8af5f667f1bb5695a19d09e79c5e0d96a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c75dac8af5f667f1bb5695a19d09e79c5e0d96a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f345f21a90e56d8f1f9a61e96519a9de2ede2d04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f345f21a90e56d8f1f9a61e96519a9de2ede2d04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f345f21a90e56d8f1f9a61e96519a9de2ede2d04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f345f21a90e56d8f1f9a61e96519a9de2ede2d04/comments", "author": null, "committer": null, "parents": [{"sha": "aa42f99db9e8d53813493550e4237db403cbedd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa42f99db9e8d53813493550e4237db403cbedd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa42f99db9e8d53813493550e4237db403cbedd2"}], "stats": {"total": 136, "additions": 82, "deletions": 54}, "files": [{"sha": "f126b1c591b94eeac0d273a9113fc0824f7ef774", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f345f21a90e56d8f1f9a61e96519a9de2ede2d04/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f345f21a90e56d8f1f9a61e96519a9de2ede2d04/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f345f21a90e56d8f1f9a61e96519a9de2ede2d04", "patch": "@@ -1,3 +1,10 @@\n+2004-03-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* reload.c (find_reloads): Reorganize if seqeunce to switch.\n+\n+\t* cfgrtl.c (rtl_redirect_edge_and_branch):  Set the source BB as dirty.\n+\t(cfglayout_redirect_edge_and_branch):  Set the source BB as dirty.\n+\n 2004-03-04  Steve Ellcey  <sje@cup.hp.com>\n \n \t* config/ia64/ia64.md (divdf3_internal_thr): Fix algorithm."}, {"sha": "3363a2d9720453400dde629bdbf05ff11bcbc9c1", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f345f21a90e56d8f1f9a61e96519a9de2ede2d04/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f345f21a90e56d8f1f9a61e96519a9de2ede2d04/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=f345f21a90e56d8f1f9a61e96519a9de2ede2d04", "patch": "@@ -933,18 +933,24 @@ redirect_branch_edge (edge e, basic_block target)\n static bool\n rtl_redirect_edge_and_branch (edge e, basic_block target)\n {\n+  basic_block src = e->src;\n+\n   if (e->flags & (EDGE_ABNORMAL_CALL | EDGE_EH))\n     return false;\n \n   if (e->dest == target)\n     return true;\n \n   if (try_redirect_by_replacing_jump (e, target, false))\n-    return true;\n+    {\n+      src->flags |= BB_DIRTY;\n+      return true;\n+    }\n \n   if (!redirect_branch_edge (e, target))\n     return false;\n \n+  src->flags |= BB_DIRTY;\n   return true;\n }\n \n@@ -2379,7 +2385,10 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n \n   if (e->src != ENTRY_BLOCK_PTR\n       && try_redirect_by_replacing_jump (e, dest, true))\n-    return true;\n+    {\n+      src->flags |= BB_DIRTY;\n+      return true;\n+    }\n \n   if (e->src == ENTRY_BLOCK_PTR\n       && (e->flags & EDGE_FALLTHRU) && !(e->flags & EDGE_COMPLEX))\n@@ -2388,6 +2397,7 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n \tfprintf (dump_file, \"Redirecting entry edge from bb %i to %i\\n\",\n \t\t e->src->index, dest->index);\n \n+      e->src->flags |= BB_DIRTY;\n       redirect_edge_succ (e, dest);\n       return true;\n     }\n@@ -2411,6 +2421,7 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n \t  if (!redirect_branch_edge (e, dest))\n \t    abort ();\n \t  e->flags |= EDGE_FALLTHRU;\n+          e->src->flags |= BB_DIRTY;\n \t  return true;\n \t}\n       /* In case we are redirecting fallthru edge to the branch edge\n@@ -2438,6 +2449,7 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n   if (simplejump_p (BB_END (src)))\n     abort ();\n \n+  src->flags |= BB_DIRTY;\n   return ret;\n }\n "}, {"sha": "f1682f73aee4536454134e2542cb95bca3909fbe", "filename": "gcc/reload.c", "status": "modified", "additions": 61, "deletions": 52, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f345f21a90e56d8f1f9a61e96519a9de2ede2d04/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f345f21a90e56d8f1f9a61e96519a9de2ede2d04/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=f345f21a90e56d8f1f9a61e96519a9de2ede2d04", "patch": "@@ -2610,62 +2610,71 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n       while ((c = *p))\n \t{\n \t  p += CONSTRAINT_LEN (c, p);\n-\t  if (c == '=')\n-\t    modified[i] = RELOAD_WRITE;\n-\t  else if (c == '+')\n-\t    modified[i] = RELOAD_READ_WRITE;\n-\t  else if (c == '%')\n+\t  switch (c)\n \t    {\n-\t      /* The last operand should not be marked commutative.  */\n-\t      if (i == noperands - 1)\n-\t\tabort ();\n-\n-\t      /* We currently only support one commutative pair of\n-\t\t operands.  Some existing asm code currently uses more\n-\t\t than one pair.  Previously, that would usually work,\n-\t\t but sometimes it would crash the compiler.  We\n-\t\t continue supporting that case as well as we can by\n-\t\t silently ignoring all but the first pair.  In the\n-\t\t future we may handle it correctly.  */\n-\t      if (commutative < 0)\n-\t\tcommutative = i;\n-\t      else if (!this_insn_is_asm)\n-\t\tabort ();\n-\t    }\n-\t  else if (ISDIGIT (c))\n-\t    {\n-\t      c = strtoul (p - 1, &p, 10);\n+\t    case '=':\n+\t      modified[i] = RELOAD_WRITE;\n+\t      break;\n+\t    case '+':\n+\t      modified[i] = RELOAD_READ_WRITE;\n+\t      break;\n+\t    case '%':\n+\t      {\n+\t\t/* The last operand should not be marked commutative.  */\n+\t\tif (i == noperands - 1)\n+\t\t  abort ();\n \n-\t      operands_match[c][i]\n-\t\t= operands_match_p (recog_data.operand[c],\n-\t\t\t\t    recog_data.operand[i]);\n+\t\t/* We currently only support one commutative pair of\n+\t\t   operands.  Some existing asm code currently uses more\n+\t\t   than one pair.  Previously, that would usually work,\n+\t\t   but sometimes it would crash the compiler.  We\n+\t\t   continue supporting that case as well as we can by\n+\t\t   silently ignoring all but the first pair.  In the\n+\t\t   future we may handle it correctly.  */\n+\t\tif (commutative < 0)\n+\t\t  commutative = i;\n+\t\telse if (!this_insn_is_asm)\n+\t\t  abort ();\n+\t      }\n+\t      break;\n+\t    /* Use of ISDIGIT is tempting here, but it may get expensive because\n+\t       of locale support we don't want.  */\n+\t    case '0': case '1': case '2': case '3': case '4':\n+\t    case '5': case '6': case '7': case '8': case '9':\n+\t      {\n+\t\tc = strtoul (p - 1, &p, 10);\n \n-\t      /* An operand may not match itself.  */\n-\t      if (c == i)\n-\t\tabort ();\n+\t\toperands_match[c][i]\n+\t\t  = operands_match_p (recog_data.operand[c],\n+\t\t\t\t      recog_data.operand[i]);\n \n-\t      /* If C can be commuted with C+1, and C might need to match I,\n-\t\t then C+1 might also need to match I.  */\n-\t      if (commutative >= 0)\n-\t\t{\n-\t\t  if (c == commutative || c == commutative + 1)\n-\t\t    {\n-\t\t      int other = c + (c == commutative ? 1 : -1);\n-\t\t      operands_match[other][i]\n-\t\t\t= operands_match_p (recog_data.operand[other],\n-\t\t\t\t\t    recog_data.operand[i]);\n-\t\t    }\n-\t\t  if (i == commutative || i == commutative + 1)\n-\t\t    {\n-\t\t      int other = i + (i == commutative ? 1 : -1);\n-\t\t      operands_match[c][other]\n-\t\t\t= operands_match_p (recog_data.operand[c],\n-\t\t\t\t\t    recog_data.operand[other]);\n-\t\t    }\n-\t\t  /* Note that C is supposed to be less than I.\n-\t\t     No need to consider altering both C and I because in\n-\t\t     that case we would alter one into the other.  */\n-\t\t}\n+\t\t/* An operand may not match itself.  */\n+\t\tif (c == i)\n+\t\t  abort ();\n+\n+\t\t/* If C can be commuted with C+1, and C might need to match I,\n+\t\t   then C+1 might also need to match I.  */\n+\t\tif (commutative >= 0)\n+\t\t  {\n+\t\t    if (c == commutative || c == commutative + 1)\n+\t\t      {\n+\t\t\tint other = c + (c == commutative ? 1 : -1);\n+\t\t\toperands_match[other][i]\n+\t\t\t  = operands_match_p (recog_data.operand[other],\n+\t\t\t\t\t      recog_data.operand[i]);\n+\t\t      }\n+\t\t    if (i == commutative || i == commutative + 1)\n+\t\t      {\n+\t\t\tint other = i + (i == commutative ? 1 : -1);\n+\t\t\toperands_match[c][other]\n+\t\t\t  = operands_match_p (recog_data.operand[c],\n+\t\t\t\t\t      recog_data.operand[other]);\n+\t\t      }\n+\t\t    /* Note that C is supposed to be less than I.\n+\t\t       No need to consider altering both C and I because in\n+\t\t       that case we would alter one into the other.  */\n+\t\t  }\n+\t      }\n \t    }\n \t}\n     }"}]}