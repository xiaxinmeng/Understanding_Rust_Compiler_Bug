{"sha": "c89366b12ff4f36253bae125b794cbe687f7e40b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg5MzY2YjEyZmY0ZjM2MjUzYmFlMTI1Yjc5NGNiZTY4N2Y3ZTQwYg==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-07-31T12:49:39Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-07-31T13:16:42Z"}, "message": "vect: Don't consider branch costs if no peeled iterations\n\nCurrently vectorizer cost modeling counts branch taken costs for\nprologue and epilogue if the number of iterations is unknown.\nBut it isn't sensible if there are no peeled iterations.\n\nThis patch is to guard them under peel_iters_prologue > 0 or\npeel_iters_epilogue > 0.\n\nBootstrapped/regtested on powerpc64le-linux-gnu and aarch64-linux-gnu.\n\ngcc/ChangeLog:\n\n\t* tree-vect-loop.c (vect_get_known_peeling_cost): Don't consider branch\n\ttaken costs for prologue and epilogue if they don't exist.\n\t(vect_estimate_min_profitable_iters): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/aarch64/sve/cost_model_2.c: Adjust due to cost model\n\tchange.", "tree": {"sha": "82ed9ae4b4046b9d619dcd0b006d13b78bace89a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82ed9ae4b4046b9d619dcd0b006d13b78bace89a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c89366b12ff4f36253bae125b794cbe687f7e40b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c89366b12ff4f36253bae125b794cbe687f7e40b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c89366b12ff4f36253bae125b794cbe687f7e40b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c89366b12ff4f36253bae125b794cbe687f7e40b/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89db36b05ea7df12926d198ec4b1be69af1b6555", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89db36b05ea7df12926d198ec4b1be69af1b6555", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89db36b05ea7df12926d198ec4b1be69af1b6555"}], "stats": {"total": 18, "additions": 10, "deletions": 8}, "files": [{"sha": "a7d748397d6cb702aa724228f83d99cf92ccc828", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cost_model_2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c89366b12ff4f36253bae125b794cbe687f7e40b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcost_model_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c89366b12ff4f36253bae125b794cbe687f7e40b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcost_model_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcost_model_2.c?ref=c89366b12ff4f36253bae125b794cbe687f7e40b", "patch": "@@ -9,4 +9,4 @@ vset (int *restrict dst, int *restrict src, int count)\n       *dst++ = 1;\n }\n \n-/* { dg-final { scan-assembler-times {\\tst1w\\tz} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tstr\\tq} 1 } } */"}, {"sha": "43ec4fb04d5637dc8dbb89f326bc8704edf3654a", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c89366b12ff4f36253bae125b794cbe687f7e40b/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c89366b12ff4f36253bae125b794cbe687f7e40b/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=c89366b12ff4f36253bae125b794cbe687f7e40b", "patch": "@@ -3520,10 +3520,12 @@ vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,\n     {\n       /* If peeled iterations are known but number of scalar loop\n \t iterations are unknown, count a taken branch per peeled loop.  */\n-      retval = record_stmt_cost (prologue_cost_vec, 1, cond_branch_taken, NULL,\n-\t\t\t\t NULL_TREE, 0, vect_prologue);\n-      retval += record_stmt_cost (epilogue_cost_vec, 1, cond_branch_taken, NULL,\n-\t\t\t\t  NULL_TREE, 0, vect_epilogue);\n+      if (peel_iters_prologue > 0)\n+\tretval = record_stmt_cost (prologue_cost_vec, 1, cond_branch_taken,\n+\t\t\t\t   NULL, NULL_TREE, 0, vect_prologue);\n+      if (*peel_iters_epilogue > 0)\n+\tretval += record_stmt_cost (epilogue_cost_vec, 1, cond_branch_taken,\n+\t\t\t\t    NULL, NULL_TREE, 0, vect_epilogue);\n     }\n \n   stmt_info_for_cost *si;\n@@ -3670,7 +3672,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   bool prologue_need_br_not_taken_cost = false;\n \n   /* Calculate peel_iters_prologue.  */\n-  if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+  if (vect_use_loop_mask_for_alignment_p (loop_vinfo))\n     peel_iters_prologue = 0;\n   else if (npeel < 0)\n     {\n@@ -3689,7 +3691,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   else\n     {\n       peel_iters_prologue = npeel;\n-      if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+      if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo) && peel_iters_prologue > 0)\n \t/* If peeled iterations are known but number of scalar loop\n \t   iterations are unknown, count a taken branch per peeled loop.  */\n \tprologue_need_br_taken_cost = true;\n@@ -3719,7 +3721,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   else\n     {\n       peel_iters_epilogue = vect_get_peel_iters_epilogue (loop_vinfo, npeel);\n-      if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+      if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo) && peel_iters_epilogue > 0)\n \t/* If peeled iterations are known but number of scalar loop\n \t   iterations are unknown, count a taken branch per peeled loop.  */\n \tepilogue_need_br_taken_cost = true;"}]}