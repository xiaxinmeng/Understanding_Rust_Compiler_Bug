{"sha": "278a83b26fd04613865adbeb4bdd6d25bf639299", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc4YTgzYjI2ZmQwNDYxMzg2NWFkYmViNGJkZDZkMjViZjYzOTI5OQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-08-04T06:55:10Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-04T06:55:10Z"}, "message": "* cse.c: Fix a comment typo. Fix formatting.\n\nFrom-SVN: r35472", "tree": {"sha": "ddcee07db19cd5855258e5d42816c2f89d6ad03b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddcee07db19cd5855258e5d42816c2f89d6ad03b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/278a83b26fd04613865adbeb4bdd6d25bf639299", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/278a83b26fd04613865adbeb4bdd6d25bf639299", "html_url": "https://github.com/Rust-GCC/gccrs/commit/278a83b26fd04613865adbeb4bdd6d25bf639299", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/278a83b26fd04613865adbeb4bdd6d25bf639299/comments", "author": null, "committer": null, "parents": [{"sha": "1183777788eafb694ad7857ccd31bcff0f37616b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1183777788eafb694ad7857ccd31bcff0f37616b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1183777788eafb694ad7857ccd31bcff0f37616b"}], "stats": {"total": 331, "additions": 169, "deletions": 162}, "files": [{"sha": "0fe18bda777ba805fc6e431595fc6022ff7acb08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/278a83b26fd04613865adbeb4bdd6d25bf639299/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/278a83b26fd04613865adbeb4bdd6d25bf639299/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=278a83b26fd04613865adbeb4bdd6d25bf639299", "patch": "@@ -1,3 +1,7 @@\n+2000-08-04  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* cse.c: Fix a comment typo. Fix formatting.\n+\n 2000-08-03  Richard Henderson  <rth@cygnus.com>\n \n         * config/i386/i386.md (return_indirect_internal): New."}, {"sha": "f7f5bd4ce815b423df8433b804c5231830714def", "filename": "gcc/cse.c", "status": "modified", "additions": 165, "deletions": 162, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/278a83b26fd04613865adbeb4bdd6d25bf639299/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/278a83b26fd04613865adbeb4bdd6d25bf639299/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=278a83b26fd04613865adbeb4bdd6d25bf639299", "patch": "@@ -19,7 +19,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n #include \"config.h\"\n /* stdio.h must precede rtl.h for FFS.  */\n #include \"system.h\"\n@@ -68,7 +67,7 @@ Boston, MA 02111-1307, USA.  */\n    is to keep it in a hash table.\n \n Registers and \"quantity numbers\":\n-   \n+\n    At the start of each basic block, all of the (hardware and pseudo)\n    registers used in the function are given distinct quantity\n    numbers to indicate their contents.  During scan, when the code\n@@ -100,7 +99,7 @@ Registers and \"quantity numbers\":\n    any mode, two REG expressions might be equivalent in the hash table\n    but not have the same quantity number if the quantity number of one\n    of the registers is not the same mode as those expressions.\n-   \n+\n Constants and quantity numbers\n \n    When a quantity has a known constant value, that value is stored\n@@ -195,7 +194,7 @@ Related expressions:\n    is also entered.  These are made to point at each other\n    so that it is possible to find out if there exists any\n    register equivalent to an expression related to a given expression.  */\n-   \n+\n /* One plus largest register number used in this function.  */\n \n static int max_reg;\n@@ -339,7 +338,7 @@ static struct cse_reg_info *reg_hash[REGHASH_SIZE];\n static unsigned int cached_regno;\n static struct cse_reg_info *cached_cse_reg_info;\n \n-/* A HARD_REG_SET containing all the hard registers for which there is \n+/* A HARD_REG_SET containing all the hard registers for which there is\n    currently a REG expression in the hash table.  Note the difference\n    from the above variables, which indicate if the REG is mentioned in some\n    expression in the table.  */\n@@ -446,7 +445,6 @@ static int hash_arg_in_memory;\n    field is the mode it was being used as.  Each constant is\n    recorded separately for each mode it is used with.  */\n \n-\n struct table_elt\n {\n   rtx exp;\n@@ -553,7 +551,7 @@ static int n_elements_made;\n \n static int max_elements_made;\n \n-/* Surviving equivalence class when two equivalence classes are merged \n+/* Surviving equivalence class when two equivalence classes are merged\n    by recording the effects of a jump in the last insn.  Zero if the\n    last insn was not a conditional jump.  */\n \n@@ -598,7 +596,7 @@ struct cse_basic_block_data\n \n /* Nonzero if X has the form (PLUS frame-pointer integer).  We check for\n    virtual regs here because the simplify_*_operation routines are called\n-   by integrate.c, which is called before virtual register instantiation. \n+   by integrate.c, which is called before virtual register instantiation.\n \n    ?!? FIXED_BASE_PLUS_P and NONZERO_BASE_PLUS_P need to move into\n    a header file so that their definitions can be shared with the\n@@ -710,7 +708,7 @@ dump_class (classp)\n   fprintf (stderr, \"Equivalence chain for \");\n   print_rtl (stderr, classp->exp);\n   fprintf (stderr, \": \\n\");\n-  \n+\n   for (elt = classp->first_same_value; elt; elt = elt->next_same_value)\n     {\n       print_rtl (stderr, elt->exp);\n@@ -813,14 +811,14 @@ rtx_cost (x, outer_code)\n       return 2;\n #ifdef RTX_COSTS\n       RTX_COSTS (x, code, outer_code);\n-#endif \n+#endif\n #ifdef CONST_COSTS\n       CONST_COSTS (x, code, outer_code);\n #endif\n \n     default:\n #ifdef DEFAULT_RTX_COSTS\n-      DEFAULT_RTX_COSTS(x, code, outer_code);\n+      DEFAULT_RTX_COSTS (x, code, outer_code);\n #endif\n       break;\n     }\n@@ -839,8 +837,9 @@ rtx_cost (x, outer_code)\n   return total;\n }\n \f\n-/* Return cost of address expression X.  Expect that X is propertly formed address\n-   reference.  */\n+/* Return cost of address expression X.\n+   Expect that X is propertly formed address reference.  */\n+\n int\n address_cost (x, mode)\n      rtx x;\n@@ -855,7 +854,7 @@ address_cost (x, mode)\n     return -1;\n \n   /* We may be asked for cost of various unusual addresses, such as operands\n-     of push instruction.  It is not worthwhile to complicate writting\n+     of push instruction.  It is not worthwhile to complicate writing\n      of ADDRESS_COST macro by such cases.  */\n \n   if (!memory_address_p (mode, x))\n@@ -874,7 +873,7 @@ get_cse_reg_info (regno)\n   struct cse_reg_info **hash_head = &reg_hash[REGHASH_FN (regno)];\n   struct cse_reg_info *p;\n \n-  for (p = *hash_head ; p != NULL; p = p->hash_next)\n+  for (p = *hash_head; p != NULL; p = p->hash_next)\n     if (p->regno == regno)\n       break;\n \n@@ -1299,12 +1298,13 @@ remove_from_table (elt, hash)\n   elt->first_same_value = 0;\n \n   /* Remove the table element from its equivalence class.  */\n-     \n+\n   {\n     register struct table_elt *prev = elt->prev_same_value;\n     register struct table_elt *next = elt->next_same_value;\n \n-    if (next) next->prev_same_value = prev;\n+    if (next)\n+      next->prev_same_value = prev;\n \n     if (prev)\n       prev->next_same_value = next;\n@@ -1325,7 +1325,8 @@ remove_from_table (elt, hash)\n     register struct table_elt *prev = elt->prev_same_hash;\n     register struct table_elt *next = elt->next_same_hash;\n \n-    if (next) next->prev_same_hash = prev;\n+    if (next)\n+      next->prev_same_hash = prev;\n \n     if (prev)\n       prev->next_same_hash = next;\n@@ -1448,7 +1449,7 @@ lookup_as_function (x, code)\n \t/* Make sure this is a valid entry in the table.  */\n \t&& exp_equiv_p (p->exp, p->exp, 1, 0))\n       return p->exp;\n-  \n+\n   return 0;\n }\n \n@@ -1702,10 +1703,10 @@ merge_equiv_classes (class1, class2)\n \t{\n \t  hash_arg_in_memory = 0;\n \t  hash = HASH (exp, mode);\n-\t      \n+\n \t  if (GET_CODE (exp) == REG)\n \t    delete_reg_equiv (REGNO (exp));\n-\t      \n+\n \t  remove_from_table (elt, hash);\n \n \t  if (insert_regs (exp, class1, 0))\n@@ -1719,7 +1720,6 @@ merge_equiv_classes (class1, class2)\n     }\n }\n \f\n-\n /* Flush the entire hash table.  */\n \n static void\n@@ -1835,10 +1835,10 @@ invalidate (x, full_mode)\n \t\t  {\n \t\t    next = p->next_same_hash;\n \n-\t\t  if (GET_CODE (p->exp) != REG\n-\t\t      || REGNO (p->exp) >= FIRST_PSEUDO_REGISTER)\n-\t\t    continue;\n-\t\t  \n+\t\t    if (GET_CODE (p->exp) != REG\n+\t\t\t|| REGNO (p->exp) >= FIRST_PSEUDO_REGISTER)\n+\t\t      continue;\n+\n \t\t    tregno = REGNO (p->exp);\n \t\t    tendregno\n \t\t      = tregno + HARD_REGNO_NREGS (tregno, GET_MODE (p->exp));\n@@ -1854,7 +1854,7 @@ invalidate (x, full_mode)\n       return;\n \n     case PARALLEL:\n-      for (i = XVECLEN (x, 0) - 1; i >= 0 ; --i)\n+      for (i = XVECLEN (x, 0) - 1; i >= 0; --i)\n \tinvalidate (XVECEXP (x, 0, i), VOIDmode);\n       return;\n \n@@ -1943,7 +1943,7 @@ remove_invalid_subreg_refs (regno, word, mode)\n       {\n \trtx exp;\n \tnext = p->next_same_hash;\n-\t\n+\n \texp = p->exp;\n \tif (GET_CODE (p->exp) != REG\n \t    && (GET_CODE (exp) != SUBREG\n@@ -2176,7 +2176,7 @@ canon_hash (x, mode)\n \n \t/* On some machines, we can't record any non-fixed hard register,\n \t   because extending its life will cause reload problems.  We\n-\t   consider ap, fp, and sp to be fixed for this purpose. \n+\t   consider ap, fp, and sp to be fixed for this purpose.\n \n \t   We also consider CCmode registers to be fixed for this purpose;\n \t   failure to do so leads to failure to simplify 0<100 type of\n@@ -2287,7 +2287,7 @@ canon_hash (x, mode)\n \t  return 0;\n \t}\n       break;\n-      \n+\n     default:\n       break;\n     }\n@@ -2474,7 +2474,7 @@ exp_equiv_p (x, y, validate, equal_values)\n \t\t\t       validate, equal_values)\n \t\t  && exp_equiv_p (XEXP (x, 1), XEXP (y, 0),\n \t\t\t\t  validate, equal_values)));\n-      \n+\n     default:\n       break;\n     }\n@@ -2514,7 +2514,7 @@ exp_equiv_p (x, y, validate, equal_values)\n \tcase 'w':\n \t  if (XWINT (x, i) != XWINT (y, i))\n \t    return 0;\n-\tbreak;\n+\t  break;\n \n \tcase '0':\n \tcase 't':\n@@ -2523,7 +2523,7 @@ exp_equiv_p (x, y, validate, equal_values)\n \tdefault:\n \t  abort ();\n \t}\n-      }\n+    }\n \n   return 1;\n }\n@@ -2642,14 +2642,14 @@ canon_reg (x, insn)\n \t    || ! REGNO_QTY_VALID_P (REGNO (x)))\n \t  return x;\n \n-\tq = REG_QTY (REGNO(x));\n+\tq = REG_QTY (REGNO (x));\n \tent = &qty_table[q];\n \tfirst = ent->first_reg;\n \treturn (first >= FIRST_PSEUDO_REGISTER ? regno_reg_rtx[first]\n \t\t: REGNO_REG_CLASS (first) == NO_REGS ? x\n \t\t: gen_rtx_REG (ent->mode, first));\n       }\n-      \n+\n     default:\n       break;\n     }\n@@ -2760,7 +2760,7 @@ find_best_addr (insn, loc, mode)\n \t  && validate_change (insn, loc, folded, 0))\n \taddr = folded;\n     }\n-\t\n+\n   /* If this address is not in the hash table, we can't look for equivalences\n      of the whole address.  Also, ignore if volatile.  */\n \n@@ -2806,7 +2806,7 @@ find_best_addr (insn, loc, mode)\n \t  int best_addr_cost = address_cost (*loc, mode);\n \t  int best_rtx_cost = (elt->cost + 1) >> 1;\n \t  int exp_cost;\n-\t  struct table_elt *best_elt = elt; \n+\t  struct table_elt *best_elt = elt;\n \n \t  found_better = 0;\n \t  for (p = elt->first_same_value; p; p = p->next_same_value)\n@@ -2875,7 +2875,7 @@ find_best_addr (insn, loc, mode)\n \t{\n \t  int best_addr_cost = address_cost (*loc, mode);\n \t  int best_rtx_cost = (COST (*loc) + 1) >> 1;\n-\t  struct table_elt *best_elt = elt; \n+\t  struct table_elt *best_elt = elt;\n \t  rtx best_rtx = *loc;\n \t  int count;\n \n@@ -3001,7 +3001,8 @@ find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n \t   that lets us see what is being compared.  */\n \tp = lookup (arg1, safe_hash (arg1, GET_MODE (arg1)) & HASH_MASK,\n \t\t    GET_MODE (arg1));\n-      if (p) p = p->first_same_value;\n+      if (p)\n+\tp = p->first_same_value;\n \n       for (; p; p = p->next_same_value)\n \t{\n@@ -3075,7 +3076,7 @@ find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n       if (x == 0)\n \tbreak;\n \n-      arg1 = XEXP (x, 0),  arg2 = XEXP (x, 1);\n+      arg1 = XEXP (x, 0), arg2 = XEXP (x, 1);\n       if (GET_RTX_CLASS (GET_CODE (x)) == '<')\n \tcode = GET_CODE (x);\n \n@@ -3107,7 +3108,7 @@ find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n static rtx\n fold_rtx (x, insn)\n      rtx x;\n-     rtx insn;    \n+     rtx insn;\n {\n   register enum rtx_code code;\n   register enum machine_mode mode;\n@@ -3247,7 +3248,7 @@ fold_rtx (x, insn)\n \t extra bits will be.  But we can find an equivalence for this SUBREG\n \t by folding that operation is the narrow mode.  This allows us to\n \t fold arithmetic in narrow modes when the machine only supports\n-\t word-sized arithmetic.  \n+\t word-sized arithmetic.\n \n \t Also look for a case where we have a SUBREG whose operand is the\n \t same as our result.  If both modes are smaller than a word, we\n@@ -3320,7 +3321,7 @@ fold_rtx (x, insn)\n \t\t  if (op1)\n \t\t    op1 = equiv_constant (op1);\n \n-\t\t  /* If we are looking for the low SImode part of \n+\t\t  /* If we are looking for the low SImode part of\n \t\t     (ashift:DI c (const_int 32)), it doesn't work\n \t\t     to compute that in SImode, because a 32-bit shift\n \t\t     in SImode is unpredictable.  We know the value is 0.  */\n@@ -3330,7 +3331,7 @@ fold_rtx (x, insn)\n \t\t      && INTVAL (op1) >= GET_MODE_BITSIZE (mode))\n \t\t    {\n \t\t      if (INTVAL (op1) < GET_MODE_BITSIZE (GET_MODE (elt->exp)))\n-\t\t\t\n+\n \t\t\t/* If the count fits in the inner mode's width,\n \t\t\t   but exceeds the outer mode's width,\n \t\t\t   the value will get truncated to 0\n@@ -3454,7 +3455,7 @@ fold_rtx (x, insn)\n \t  {\n \t    rtx label = XEXP (base, 0);\n \t    rtx table_insn = NEXT_INSN (label);\n-\t    \n+\n \t    if (table_insn && GET_CODE (table_insn) == JUMP_INSN\n \t\t&& GET_CODE (PATTERN (table_insn)) == ADDR_VEC)\n \t      {\n@@ -3482,7 +3483,7 @@ fold_rtx (x, insn)\n \t\t    if (GET_MODE (table) != Pmode)\n \t\t      new = gen_rtx_TRUNCATE (GET_MODE (table), new);\n \n-\t\t    /* Indicate this is a constant.  This isn't a \n+\t\t    /* Indicate this is a constant.  This isn't a\n \t\t       valid form of CONST, but it will only be used\n \t\t       to fold the next insns and then discarded, so\n \t\t       it should be safe.\n@@ -3503,7 +3504,7 @@ fold_rtx (x, insn)\n \tvalidate_change (insn, &XVECEXP (x, 3, i),\n \t\t\t fold_rtx (XVECEXP (x, 3, i), insn), 0);\n       break;\n-      \n+\n     default:\n       break;\n     }\n@@ -3643,7 +3644,7 @@ fold_rtx (x, insn)\n \tif (fmt[i] == 'E')\n \t  /* Don't try to fold inside of a vector of expressions.\n \t     Doing nothing is harmless.  */\n-\t  {;}\t\n+\t  ;\n       }\n \n   /* If a commutative operation, place a constant integer as the second\n@@ -3701,7 +3702,7 @@ fold_rtx (x, insn)\n \t  new = gen_rtx_CONST (mode, new);\n       }\n       break;\n-      \n+\n     case '<':\n       /* See what items are actually being compared and set FOLDED_ARG[01]\n \t to those values and CODE to the actual comparison code.  If any are\n@@ -4146,7 +4147,7 @@ equiv_constant (x)\n /* Assuming that X is an rtx (e.g., MEM, REG or SUBREG) for a fixed-point\n    number, return an rtx (MEM, SUBREG, or CONST_INT) that refers to the\n    least-significant part of X.\n-   MODE specifies how big a part of X to return.  \n+   MODE specifies how big a part of X to return.\n \n    If the requested operation cannot be done, 0 is returned.\n \n@@ -4189,7 +4190,7 @@ gen_lowpart_if_possible (mode, x)\n    branch.  It will be zero if not.\n \n    In certain cases, this can cause us to add an equivalence.  For example,\n-   if we are following the taken case of \n+   if we are following the taken case of\n    \tif (i == 2)\n    we can add the fact that `i' and '2' are now equivalent.\n \n@@ -4291,7 +4292,7 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \t\t\treversed_nonequality);\n     }\n \n-  /* Similarly, if this is an NE comparison, and either is a SUBREG \n+  /* Similarly, if this is an NE comparison, and either is a SUBREG\n      making a smaller mode, we know the whole thing is also NE.  */\n \n   /* Note that GET_MODE (op0) may not equal MODE;\n@@ -4338,7 +4339,7 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n   hash_arg_in_memory = 0;\n   op1_hash = HASH (op1, mode);\n   op1_in_memory = hash_arg_in_memory;\n-  \n+\n   if (do_not_record)\n     return;\n \n@@ -4464,7 +4465,7 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n    First simplify sources and addresses of all assignments\n    in the instruction, using previously-computed equivalents values.\n    Then install the new sources and destinations in the table\n-   of available values. \n+   of available values.\n \n    If LIBCALL_INSN is nonzero, don't record any equivalence made in\n    the insn.  It means that INSN is inside libcall block.  In this\n@@ -4486,7 +4487,7 @@ struct set\n   unsigned dest_hash;\n   /* The SET_DEST, with SUBREG, etc., stripped.  */\n   rtx inner_dest;\n-  /* Nonzero if the SET_SRC is in memory.  */ \n+  /* Nonzero if the SET_SRC is in memory.  */\n   char src_in_memory;\n   /* Nonzero if the SET_SRC contains something\n      whose value cannot be predicted and understood.  */\n@@ -4538,7 +4539,7 @@ cse_insn (insn, libcall_insn)\n     {\n       for (tem = CALL_INSN_FUNCTION_USAGE (insn); tem; tem = XEXP (tem, 1))\n \tif (GET_CODE (XEXP (tem, 0)) == CLOBBER)\n-          invalidate (SET_DEST (XEXP (tem, 0)), VOIDmode);\n+\t  invalidate (SET_DEST (XEXP (tem, 0)), VOIDmode);\n     }\n \n   if (GET_CODE (x) == SET)\n@@ -4606,7 +4607,7 @@ cse_insn (insn, libcall_insn)\n \t\tinvalidate (XEXP (clobbered, 0), GET_MODE (clobbered));\n \t    }\n \t}\n-\t    \n+\n       for (i = 0; i < lim; i++)\n \t{\n \t  register rtx y = XVECEXP (x, 0, i);\n@@ -4726,7 +4727,7 @@ cse_insn (insn, libcall_insn)\n      group and see if they all work.  Note that this will cause some\n      canonicalizations that would have worked individually not to be applied\n      because some other canonicalization didn't work, but this should not\n-     occur often. \n+     occur often.\n \n      The result of apply_change_group can be ignored; see canon_reg.  */\n \n@@ -4882,8 +4883,8 @@ cse_insn (insn, libcall_insn)\n       sets[i].src_elt = elt;\n \n       if (elt && src_eqv_here && src_eqv_elt)\n-        {\n-          if (elt->first_same_value != src_eqv_elt->first_same_value)\n+\t{\n+\t  if (elt->first_same_value != src_eqv_elt->first_same_value)\n \t    {\n \t      /* The REG_EQUAL is indicating that two formerly distinct\n \t\t classes are now equivalent.  So merge them.  */\n@@ -4892,18 +4893,18 @@ cse_insn (insn, libcall_insn)\n \t      src_eqv_elt = lookup (src_eqv, src_eqv_hash, elt->mode);\n \t    }\n \n-          src_eqv_here = 0;\n-        }\n+\t  src_eqv_here = 0;\n+\t}\n \n       else if (src_eqv_elt)\n-        elt = src_eqv_elt;\n+\telt = src_eqv_elt;\n \n       /* Try to find a constant somewhere and record it in `src_const'.\n \t Record its table element, if any, in `src_const_elt'.  Look in\n \t any known equivalences first.  (If the constant is not in the\n \t table, also set `sets[i].src_const_hash').  */\n       if (elt)\n-        for (p = elt->first_same_value; p; p = p->next_same_value)\n+\tfor (p = elt->first_same_value; p; p = p->next_same_value)\n \t  if (p->is_const)\n \t    {\n \t      src_const = p->exp;\n@@ -4913,7 +4914,7 @@ cse_insn (insn, libcall_insn)\n \n       if (src_const == 0\n \t  && (CONSTANT_P (src_folded)\n-\t      /* Consider (minus (label_ref L1) (label_ref L2)) as \n+\t      /* Consider (minus (label_ref L1) (label_ref L2)) as\n \t\t \"constant\" here so we will record it. This allows us\n \t\t to fold switch statements when an ADDR_DIFF_VEC is used.  */\n \t      || (GET_CODE (src_folded) == MINUS\n@@ -4948,28 +4949,28 @@ cse_insn (insn, libcall_insn)\n       if (src_const\n \t  && (GET_CODE (src_const) == CONST\n \t      || (src_const_elt && src_const_elt->related_value != 0)))\n-        {\n-          src_related = use_related_value (src_const, src_const_elt);\n-          if (src_related)\n-            {\n+\t{\n+\t  src_related = use_related_value (src_const, src_const_elt);\n+\t  if (src_related)\n+\t    {\n \t      struct table_elt *src_related_elt\n-\t\t    = lookup (src_related, HASH (src_related, mode), mode);\n+\t\t= lookup (src_related, HASH (src_related, mode), mode);\n \t      if (src_related_elt && elt)\n-\t        {\n+\t\t{\n \t\t  if (elt->first_same_value\n \t\t      != src_related_elt->first_same_value)\n-\t\t    /* This can occur when we previously saw a CONST \n+\t\t    /* This can occur when we previously saw a CONST\n \t\t       involving a SYMBOL_REF and then see the SYMBOL_REF\n \t\t       twice.  Merge the involved classes.  */\n \t\t    merge_equiv_classes (elt, src_related_elt);\n \n-\t          src_related = 0;\n+\t\t  src_related = 0;\n \t\t  src_related_elt = 0;\n-\t        }\n-              else if (src_related_elt && elt == 0)\n-\t        elt = src_related_elt;\n+\t\t}\n+\t      else if (src_related_elt && elt == 0)\n+\t\telt = src_related_elt;\n \t    }\n-        }\n+\t}\n \n       /* See if we have a CONST_INT that is already in a register in a\n \t wider mode.  */\n@@ -5050,49 +5051,49 @@ cse_insn (insn, libcall_insn)\n \t if it has, we can use a subreg of that.  Many CISC machines\n \t also have such operations, but this is only likely to be\n \t beneficial these machines.  */\n-      \n+\n       if (flag_expensive_optimizations &&  src_related == 0\n \t  && (GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n \t  && GET_MODE_CLASS (mode) == MODE_INT\n \t  && GET_CODE (src) == MEM && ! do_not_record\n \t  && LOAD_EXTEND_OP (mode) != NIL)\n \t{\n \t  enum machine_mode tmode;\n-\t  \n+\n \t  /* Set what we are trying to extend and the operation it might\n \t     have been extended with.  */\n \t  PUT_CODE (memory_extend_rtx, LOAD_EXTEND_OP (mode));\n \t  XEXP (memory_extend_rtx, 0) = src;\n-\t  \n+\n \t  for (tmode = GET_MODE_WIDER_MODE (mode);\n \t       GET_MODE_SIZE (tmode) <= UNITS_PER_WORD;\n \t       tmode = GET_MODE_WIDER_MODE (tmode))\n \t    {\n \t      struct table_elt *larger_elt;\n-\t      \n+\n \t      PUT_MODE (memory_extend_rtx, tmode);\n-\t      larger_elt = lookup (memory_extend_rtx, \n+\t      larger_elt = lookup (memory_extend_rtx,\n \t\t\t\t   HASH (memory_extend_rtx, tmode), tmode);\n \t      if (larger_elt == 0)\n \t\tcontinue;\n-\t      \n+\n \t      for (larger_elt = larger_elt->first_same_value;\n \t\t   larger_elt; larger_elt = larger_elt->next_same_value)\n \t\tif (GET_CODE (larger_elt->exp) == REG)\n \t\t  {\n-\t\t    src_related = gen_lowpart_if_possible (mode, \n+\t\t    src_related = gen_lowpart_if_possible (mode,\n \t\t\t\t\t\t\t   larger_elt->exp);\n \t\t    break;\n \t\t  }\n-\t      \n+\n \t      if (src_related)\n \t\tbreak;\n \t    }\n \t}\n #endif /* LOAD_EXTEND_OP */\n- \n+\n       if (src == src_folded)\n-        src_folded = 0;\n+\tsrc_folded = 0;\n \n       /* At this point, ELT, if non-zero, points to a class of expressions\n          equivalent to the source of this SET and SRC, SRC_EQV, SRC_FOLDED,\n@@ -5105,9 +5106,10 @@ cse_insn (insn, libcall_insn)\n \t elimination of the insn.  Indicate this by placing it in\n \t `src_related'.  */\n \n-      if (elt) elt = elt->first_same_value;\n+      if (elt)\n+\telt = elt->first_same_value;\n       for (p = elt; p; p = p->next_same_value)\n-        {\n+\t{\n \t  enum rtx_code code = GET_CODE (p->exp);\n \n \t  /* If the expression is not valid, ignore it.  Then we do not\n@@ -5128,15 +5130,15 @@ cse_insn (insn, libcall_insn)\n \t\t\t< GET_MODE_SIZE (GET_MODE (SUBREG_REG (p->exp))))))\n \t    continue;\n \n-          if (src && GET_CODE (src) == code && rtx_equal_p (src, p->exp))\n+\t  if (src && GET_CODE (src) == code && rtx_equal_p (src, p->exp))\n \t    src = 0;\n-          else if (src_folded && GET_CODE (src_folded) == code\n+\t  else if (src_folded && GET_CODE (src_folded) == code\n \t\t   && rtx_equal_p (src_folded, p->exp))\n \t    src_folded = 0;\n-          else if (src_eqv_here && GET_CODE (src_eqv_here) == code\n+\t  else if (src_eqv_here && GET_CODE (src_eqv_here) == code\n \t\t   && rtx_equal_p (src_eqv_here, p->exp))\n \t    src_eqv_here = 0;\n-          else if (src_related && GET_CODE (src_related) == code\n+\t  else if (src_related && GET_CODE (src_related) == code\n \t\t   && rtx_equal_p (src_related, p->exp))\n \t    src_related = 0;\n \n@@ -5145,8 +5147,7 @@ cse_insn (insn, libcall_insn)\n \t     then give it a negative cost.  */\n \t  if (GET_CODE (dest) == code && rtx_equal_p (p->exp, dest))\n \t    src_related = dest;\n-\n-        }\n+\t}\n \n       /* Find the cheapest valid equivalent, trying all the available\n          possibilities.  Prefer items not in the hash table to ones\n@@ -5190,17 +5191,17 @@ cse_insn (insn, libcall_insn)\n \t cheaper even though it looks more expensive.  */\n       if (dest == pc_rtx && src_const && GET_CODE (src_const) == LABEL_REF)\n \tsrc_folded = src_const, src_folded_cost = -1;\n-\t  \n+\n       /* Terminate loop when replacement made.  This must terminate since\n          the current contents will be tested and will always be valid.  */\n       while (1)\n-        {\n-          rtx trial;\n+\t{\n+\t  rtx trial;\n \n-          /* Skip invalid entries.  */\n-          while (elt && GET_CODE (elt->exp) != REG\n-\t         && ! exp_equiv_p (elt->exp, elt->exp, 1, 0))\n-\t    elt = elt->next_same_value;\t     \n+\t  /* Skip invalid entries.  */\n+\t  while (elt && GET_CODE (elt->exp) != REG\n+\t\t && ! exp_equiv_p (elt->exp, elt->exp, 1, 0))\n+\t    elt = elt->next_same_value;\n \n \t  /* A paradoxical subreg would be bad here: it'll be the right\n \t     size, but later may be adjusted so that the upper bits aren't\n@@ -5220,13 +5221,14 @@ cse_insn (insn, libcall_insn)\n \t      elt = elt->next_same_value;\n \t      continue;\n \t    }\n-\t      \n-          if (elt) src_elt_cost = elt->cost;\n+\n+\t  if (elt)\n+\t    src_elt_cost = elt->cost;\n \n           /* Find cheapest and skip it for the next time.   For items\n \t     of equal cost, use this order:\n \t     src_folded, src, src_eqv, src_related and hash table entry.  */\n-          if (src_folded_cost <= src_cost\n+\t  if (src_folded_cost <= src_cost\n \t      && src_folded_cost <= src_eqv_cost\n \t      && src_folded_cost <= src_related_cost\n \t      && src_folded_cost <= src_elt_cost)\n@@ -5235,16 +5237,16 @@ cse_insn (insn, libcall_insn)\n \t      if (src_folded_force_flag)\n \t\ttrial = force_const_mem (mode, trial);\n \t    }\n-          else if (src_cost <= src_eqv_cost\n-\t           && src_cost <= src_related_cost\n-\t           && src_cost <= src_elt_cost)\n+\t  else if (src_cost <= src_eqv_cost\n+\t\t   && src_cost <= src_related_cost\n+\t\t   && src_cost <= src_elt_cost)\n \t    trial = src, src_cost = 10000;\n-          else if (src_eqv_cost <= src_related_cost\n-\t           && src_eqv_cost <= src_elt_cost)\n+\t  else if (src_eqv_cost <= src_related_cost\n+\t\t   && src_eqv_cost <= src_elt_cost)\n \t    trial = copy_rtx (src_eqv_here), src_eqv_cost = 10000;\n-          else if (src_related_cost <= src_elt_cost)\n+\t  else if (src_related_cost <= src_elt_cost)\n \t    trial = copy_rtx (src_related), src_related_cost = 10000;\n-          else\n+\t  else\n \t    {\n \t      trial = copy_rtx (elt->exp);\n \t      elt = elt->next_same_value;\n@@ -5283,7 +5285,7 @@ cse_insn (insn, libcall_insn)\n \t      cse_jumps_altered = 1;\n \t      break;\n \t    }\n-\t   \n+\n \t  /* Look for a substitution that makes a valid insn.  */\n           else if (validate_change (insn, &SET_SRC (sets[i].rtl), trial, 0))\n \t    {\n@@ -5293,8 +5295,8 @@ cse_insn (insn, libcall_insn)\n \t      if (libcall_insn\n \t\t  && (GET_CODE (sets[i].orig_src) == REG\n \t\t      || GET_CODE (sets[i].orig_src) == SUBREG\n-\t\t      ||  GET_CODE (sets[i].orig_src) == MEM))\n-\t\treplace_rtx (REG_NOTES (libcall_insn), sets[i].orig_src, \n+\t\t      || GET_CODE (sets[i].orig_src) == MEM))\n+\t\treplace_rtx (REG_NOTES (libcall_insn), sets[i].orig_src,\n \t\t\t     canon_reg (SET_SRC (sets[i].rtl), insn));\n \n \t      /* The result of apply_change_group can be ignored; see\n@@ -5307,7 +5309,7 @@ cse_insn (insn, libcall_insn)\n \t      break;\n \t    }\n \n-\t  /* If we previously found constant pool entries for \n+\t  /* If we previously found constant pool entries for\n \t     constants and this is a constant, try making a\n \t     pool entry.  Put it in src_folded unless we already have done\n \t     this since that is where it likely came from.  */\n@@ -5326,7 +5328,7 @@ cse_insn (insn, libcall_insn)\n \t      src_folded = trial;\n \t      src_folded_cost = constant_pool_entries_cost;\n \t    }\n-        }\n+\t}\n \n       src = SET_SRC (sets[i].rtl);\n \n@@ -5370,31 +5372,31 @@ cse_insn (insn, libcall_insn)\n \t\t     setting SRC to, use that constant.  We ignored it when we\n \t\t     thought we could make this into a no-op.  */\n \t\t  if (src_const && COST (src_const) < COST (src)\n-\t\t      && validate_change (insn, &SET_SRC (sets[i].rtl), src_const,\n-\t\t\t\t\t  0))\n+\t\t      && validate_change (insn, &SET_SRC (sets[i].rtl),\n+\t\t\t\t\t  src_const, 0))\n \t\t    src = src_const;\n \t\t}\n \t    }\n \t}\n \n       /* If we made a change, recompute SRC values.  */\n       if (src != sets[i].src)\n-        {\n+\t{\n \t  cse_altered = 1;\n-          do_not_record = 0;\n-          hash_arg_in_memory = 0;\n+\t  do_not_record = 0;\n+\t  hash_arg_in_memory = 0;\n \t  sets[i].src = src;\n-          sets[i].src_hash = HASH (src, mode);\n-          sets[i].src_volatile = do_not_record;\n-          sets[i].src_in_memory = hash_arg_in_memory;\n-          sets[i].src_elt = lookup (src, sets[i].src_hash, mode);\n-        }\n+\t  sets[i].src_hash = HASH (src, mode);\n+\t  sets[i].src_volatile = do_not_record;\n+\t  sets[i].src_in_memory = hash_arg_in_memory;\n+\t  sets[i].src_elt = lookup (src, sets[i].src_hash, mode);\n+\t}\n \n       /* If this is a single SET, we are setting a register, and we have an\n \t equivalent constant, we want to add a REG_NOTE.   We don't want\n \t to write a REG_EQUAL note for a constant pseudo since verifying that\n \t that pseudo hasn't been eliminated is a pain.  Such a note also\n-\t won't help anything. \n+\t won't help anything.\n \n \t Avoid a REG_EQUAL note for (CONST (MINUS (LABEL_REF) (LABEL_REF)))\n \t which can be created for a reference to a compile time computable\n@@ -5408,7 +5410,7 @@ cse_insn (insn, libcall_insn)\n \t\t&& GET_CODE (XEXP (XEXP (src_const, 0), 1)) == LABEL_REF))\n \t{\n \t  tem = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n-\t  \n+\n \t  /* Make sure that the rtx is not shared with any other insn.  */\n \t  src_const = copy_rtx (src_const);\n \n@@ -5704,7 +5706,7 @@ cse_insn (insn, libcall_insn)\n \n   invalidate_from_clobbers (x);\n \n-  /* Some registers are invalidated by subroutine calls.  Memory is \n+  /* Some registers are invalidated by subroutine calls.  Memory is\n      invalidated by non-constant calls.  */\n \n   if (GET_CODE (insn) == CALL_INSN)\n@@ -5871,7 +5873,7 @@ cse_insn (insn, libcall_insn)\n \tif (GET_CODE (inner_dest) == MEM\n \t    && GET_CODE (XEXP (inner_dest, 0)) == ADDRESSOF)\n \t  /* Given (SET (MEM (ADDRESSOF (X))) Y) we don't want to say\n-\t     that (MEM (ADDRESSOF (X))) is equivalent to Y. \n+\t     that (MEM (ADDRESSOF (X))) is equivalent to Y.\n \t     Consider the case in which the address of the MEM is\n \t     passed to a function, which alters the MEM.  Then, if we\n \t     later use Y instead of the MEM we'll miss the update.  */\n@@ -5893,7 +5895,7 @@ cse_insn (insn, libcall_insn)\n \t   However, BAR may have equivalences for which gen_lowpart_if_possible\n \t   will produce a simpler value than gen_lowpart_if_possible applied to\n \t   BAR (e.g., if BAR was ZERO_EXTENDed from M2), so we will scan all\n-\t   BAR's equivalences.  If we don't get a simplified form, make \n+\t   BAR's equivalences.  If we don't get a simplified form, make\n \t   the SUBREG.  It will not be used in an equivalence, but will\n \t   cause two similar assignments to be detected.\n \n@@ -5903,7 +5905,7 @@ cse_insn (insn, libcall_insn)\n \tif (GET_CODE (dest) == SUBREG\n \t    && (((GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest))) - 1)\n \t\t / UNITS_PER_WORD)\n-\t\t== (GET_MODE_SIZE (GET_MODE (dest)) - 1)/ UNITS_PER_WORD)\n+\t\t== (GET_MODE_SIZE (GET_MODE (dest)) - 1) / UNITS_PER_WORD)\n \t    && (GET_MODE_SIZE (GET_MODE (dest))\n \t\t>= GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest))))\n \t    && sets[i].src_elt != 0)\n@@ -5943,7 +5945,7 @@ cse_insn (insn, libcall_insn)\n \t\t    src_elt->in_memory = elt->in_memory;\n \t\t  }\n \t\telse if (classp && classp != src_elt->first_same_value)\n-\t\t  /* Show that two things that we've seen before are \n+\t\t  /* Show that two things that we've seen before are\n \t\t     actually the same.  */\n \t\t  merge_equiv_classes (src_elt, classp);\n \n@@ -5996,9 +5998,9 @@ cse_insn (insn, libcall_insn)\n \t      rtx src = SET_SRC (sets[0].rtl);\n \t      rtx note = find_reg_note (prev, REG_EQUIV, NULL_RTX);\n \n-\t      validate_change (prev, & SET_DEST (PATTERN (prev)), dest, 1);\n-\t      validate_change (insn, & SET_DEST (sets[0].rtl), src, 1);\n-\t      validate_change (insn, & SET_SRC (sets[0].rtl), dest, 1);\n+\t      validate_change (prev, &SET_DEST (PATTERN (prev)), dest, 1);\n+\t      validate_change (insn, &SET_DEST (sets[0].rtl), src, 1);\n+\t      validate_change (insn, &SET_SRC (sets[0].rtl), dest, 1);\n \t      apply_change_group ();\n \n \t      /* If REG1 was equivalent to a constant, REG0 is not.  */\n@@ -6221,7 +6223,7 @@ cse_process_notes (x, object)\n \n       /* Otherwise, canonicalize this register.  */\n       return canon_reg (x, NULL_RTX);\n-      \n+\n     default:\n       break;\n     }\n@@ -6276,12 +6278,12 @@ cse_around_loop (loop_start)\n     for (p = last_jump_equiv_class->first_same_value; p;\n \t p = p->next_same_value)\n       {\n-        if (GET_CODE (p->exp) == MEM || GET_CODE (p->exp) == REG\n+\tif (GET_CODE (p->exp) == MEM || GET_CODE (p->exp) == REG\n \t    || (GET_CODE (p->exp) == SUBREG\n-\t        && GET_CODE (SUBREG_REG (p->exp)) == REG))\n+\t\t&& GET_CODE (SUBREG_REG (p->exp)) == REG))\n \t  invalidate (p->exp, VOIDmode);\n-        else if (GET_CODE (p->exp) == STRICT_LOW_PART\n-\t         || GET_CODE (p->exp) == ZERO_EXTRACT)\n+\telse if (GET_CODE (p->exp) == STRICT_LOW_PART\n+\t\t || GET_CODE (p->exp) == ZERO_EXTRACT)\n \t  invalidate (XEXP (p->exp, 0), GET_MODE (p->exp));\n       }\n \n@@ -6541,7 +6543,8 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop, skip_blocks)\n   rtx p = insn, q;\n   int nsets = 0;\n   int low_cuid = INSN_CUID (insn), high_cuid = INSN_CUID (insn);\n-  rtx next = GET_RTX_CLASS (GET_CODE (insn)) == 'i' ? insn : next_real_insn (insn);\n+  rtx next =\n+    GET_RTX_CLASS (GET_CODE (insn)) == 'i' ? insn : next_real_insn (insn);\n   int path_size = data->path_size;\n   int path_entry = 0;\n   int i;\n@@ -6604,7 +6607,7 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop, skip_blocks)\n \tnsets += XVECLEN (PATTERN (p), 0);\n       else if (GET_CODE (p) != NOTE)\n \tnsets += 1;\n-\t\n+\n       /* Ignore insns made by CSE; they cannot affect the boundaries of\n \t the basic block.  */\n \n@@ -6619,7 +6622,7 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop, skip_blocks)\n \t{\n \t  if (data->path[path_entry].status != NOT_TAKEN)\n \t    p = JUMP_LABEL (p);\n-\t  \n+\n \t  /* Point to next entry in path, if any.  */\n \t  path_entry++;\n \t}\n@@ -6636,17 +6639,17 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop, skip_blocks)\n \n       else if ((follow_jumps || skip_blocks) && path_size < PATHLENGTH - 1\n \t       && GET_CODE (p) == JUMP_INSN\n-      \t       && GET_CODE (PATTERN (p)) == SET\n+\t       && GET_CODE (PATTERN (p)) == SET\n \t       && GET_CODE (SET_SRC (PATTERN (p))) == IF_THEN_ELSE\n \t       && JUMP_LABEL (p) != 0\n \t       && LABEL_NUSES (JUMP_LABEL (p)) == 1\n \t       && NEXT_INSN (JUMP_LABEL (p)) != 0)\n \t{\n \t  for (q = PREV_INSN (JUMP_LABEL (p)); q; q = PREV_INSN (q))\n \t    if ((GET_CODE (q) != NOTE\n-\t         || NOTE_LINE_NUMBER (q) == NOTE_INSN_LOOP_END\n-\t         || NOTE_LINE_NUMBER (q) == NOTE_INSN_SETJMP)\n-\t        && (GET_CODE (q) != CODE_LABEL || LABEL_NUSES (q) != 0))\n+\t\t || NOTE_LINE_NUMBER (q) == NOTE_INSN_LOOP_END\n+\t\t || NOTE_LINE_NUMBER (q) == NOTE_INSN_SETJMP)\n+\t\t&& (GET_CODE (q) != CODE_LABEL || LABEL_NUSES (q) != 0))\n \t      break;\n \n \t  /* If we ran into a BARRIER, this code is an extension of the\n@@ -6705,7 +6708,7 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop, skip_blocks)\n \t      for (tmp = NEXT_INSN (p); tmp && tmp != q; tmp = NEXT_INSN (tmp))\n \t\tif (GET_CODE (tmp) == CODE_LABEL)\n \t\t  break;\n-\t      \n+\n \t      if (tmp == q)\n \t\t{\n \t\t  data->path[path_entry].branch = p;\n@@ -6868,7 +6871,7 @@ cse_main (f, nregs, after_loop, file)\n       cse_basic_block_start = val.low_cuid;\n       cse_basic_block_end = val.high_cuid;\n       max_qty = val.nsets * 2;\n-      \n+\n       if (file)\n \tfnotice (file, \";; Processing block from %d to %d, %d sets.\\n\",\n \t\t INSN_UID (insn), val.last ? INSN_UID (val.last) : 0,\n@@ -6885,7 +6888,7 @@ cse_main (f, nregs, after_loop, file)\n          (see `cse_end_of_basic_block'), we reprocess the code from the start.\n          Otherwise, we start after this basic block.  */\n       if (val.path_size > 0)\n-        cse_basic_block (insn, val.last, val.path, 0);\n+\tcse_basic_block (insn, val.last, val.path, 0);\n       else\n \t{\n \t  int old_cse_jumps_altered = cse_jumps_altered;\n@@ -6949,7 +6952,7 @@ cse_basic_block (from, to, next_branch, around_loop)\n \n   qty_table\n     = (struct qty_table_elem *) xmalloc ((max_qty - max_reg)\n-\t\t\t\t\t  * sizeof (struct qty_table_elem));\n+\t\t\t\t\t * sizeof (struct qty_table_elem));\n   qty_table -= max_reg;\n \n   new_basic_block ();\n@@ -6999,7 +7002,7 @@ cse_basic_block (from, to, next_branch, around_loop)\n \t      continue;\n \t    }\n \t}\n-        \n+\n       if (GET_MODE (insn) == QImode)\n \tPUT_MODE (insn, VOIDmode);\n \n@@ -7049,7 +7052,7 @@ cse_basic_block (from, to, next_branch, around_loop)\n \t  /* Maybe TO was deleted because the jump is unconditional.\n \t     If so, there is nothing left in this basic block.  */\n \t  /* ??? Perhaps it would be smarter to set TO\n-\t     to whatever follows this insn, \n+\t     to whatever follows this insn,\n \t     and pretend the basic block had always ended here.  */\n \t  if (INSN_DELETED_P (to))\n \t    break;\n@@ -7137,9 +7140,9 @@ cse_basic_block (from, to, next_branch, around_loop)\n \f\n /* Count the number of times registers are used (not set) in X.\n    COUNTS is an array in which we accumulate the count, INCR is how much\n-   we count each register usage.  \n+   we count each register usage.\n \n-   Don't count a usage of DEST, which is the SET_DEST of a SET which \n+   Don't count a usage of DEST, which is the SET_DEST of a SET which\n    contains X in its SET_SRC.  This is because such a SET does not\n    modify the liveness of DEST.  */\n \n@@ -7173,7 +7176,7 @@ count_reg_usage (x, counts, dest, incr)\n     case LABEL_REF:\n       return;\n \n-    case CLOBBER:                                                        \n+    case CLOBBER:\n       /* If we are clobbering a MEM, mark any registers inside the address\n          as being used.  */\n       if (GET_CODE (XEXP (x, 0)) == MEM)\n@@ -7217,7 +7220,7 @@ count_reg_usage (x, counts, dest, incr)\n \tcount_reg_usage (XEXP (x, 0), counts, NULL_RTX, incr);\n       count_reg_usage (XEXP (x, 1), counts, NULL_RTX, incr);\n       return;\n-      \n+\n     default:\n       break;\n     }\n@@ -7261,7 +7264,7 @@ delete_trivially_dead_insns (insns, nreg)\n \n   /* Go from the last insn to the first and delete insns that only set unused\n      registers or copy a register to itself.  As we delete an insn, remove\n-     usage counts for registers it uses. \n+     usage counts for registers it uses.\n \n      The first jump optimization pass may leave a real insn as the last\n      insn in the function.   We must not skip that insn or we may end\n@@ -7270,7 +7273,7 @@ delete_trivially_dead_insns (insns, nreg)\n   if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n     insn = prev_real_insn (insn);\n \n-  for ( ; insn; insn = prev)\n+  for (; insn; insn = prev)\n     {\n       int live_insn = 0;\n       rtx note;\n@@ -7290,7 +7293,7 @@ delete_trivially_dead_insns (insns, nreg)\n \n \t  /* See if there's a REG_EQUAL note on this insn and try to\n \t     replace the source with the REG_EQUAL expression.\n-\t\n+\n \t     We assume that insns with REG_RETVALs can only be reg->reg\n \t     copies at this point.  */\n \t  note = find_reg_note (insn, REG_EQUAL, NULL_RTX);"}]}