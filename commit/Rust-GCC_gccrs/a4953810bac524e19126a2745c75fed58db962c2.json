{"sha": "a4953810bac524e19126a2745c75fed58db962c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ5NTM4MTBiYWM1MjRlMTkxMjZhMjc0NWM3NWZlZDU4ZGI5NjJjMg==", "commit": {"author": {"name": "Jim Wilson", "email": "jimw@sifive.com", "date": "2021-02-13T20:13:08Z"}, "committer": {"name": "Jim Wilson", "email": "jimw@sifive.com", "date": "2021-02-13T20:13:08Z"}, "message": "RISC-V: Shorten memrefs improvement, partial fix 97417.\n\nWe already have a check for riscv_shorten_memrefs in riscv_address_cost.\nThis adds the same check to riscv_rtx_costs.  Making this work also\nrequires a change to riscv_compressed_lw_address_p to work before reload\nby checking the offset and assuming any pseudo reg is OK.  Testing shows\nthat this consistently gives small code size reductions.\n\n\tgcc/\n\tPR target/97417\n\t* config/riscv/riscv.c (riscv_compressed_lw_address_p): Drop early\n\texit when !reload_completed.  Only perform check for compressed reg\n\tif reload_completed.\n\t(riscv_rtx_costs): In MEM case, when optimizing\tfor size and\n\tshorten memrefs, if not compressible, then increase cost.", "tree": {"sha": "3e20f457a714b6bf09c330ee55f46fe24260dac3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e20f457a714b6bf09c330ee55f46fe24260dac3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4953810bac524e19126a2745c75fed58db962c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4953810bac524e19126a2745c75fed58db962c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4953810bac524e19126a2745c75fed58db962c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4953810bac524e19126a2745c75fed58db962c2/comments", "author": null, "committer": null, "parents": [{"sha": "05402ca65a6696a8f20a3dbcb18f47ba3bdfa268", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05402ca65a6696a8f20a3dbcb18f47ba3bdfa268", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05402ca65a6696a8f20a3dbcb18f47ba3bdfa268"}], "stats": {"total": 19, "additions": 11, "deletions": 8}, "files": [{"sha": "7d274596ba3e72c3815bc4e054d435784c6dca7f", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4953810bac524e19126a2745c75fed58db962c2/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4953810bac524e19126a2745c75fed58db962c2/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=a4953810bac524e19126a2745c75fed58db962c2", "patch": "@@ -891,17 +891,13 @@ riscv_compressed_lw_address_p (rtx x)\n   bool result = riscv_classify_address (&addr, x, GET_MODE (x),\n \t\t\t\t\treload_completed);\n \n-  /* Before reload, assuming all load/stores of valid addresses get compressed\n-     gives better code size than checking if the address is reg + small_offset\n-     early on.  */\n-  if (result && !reload_completed)\n-    return true;\n-\n   /* Return false if address is not compressed_reg + small_offset.  */\n   if (!result\n       || addr.type != ADDRESS_REG\n-      || (!riscv_compressed_reg_p (REGNO (addr.reg))\n-\t    && addr.reg != stack_pointer_rtx)\n+      /* Before reload, assume all registers are OK.  */\n+      || (reload_completed\n+\t  && !riscv_compressed_reg_p (REGNO (addr.reg))\n+\t  && addr.reg != stack_pointer_rtx)\n       || !riscv_compressed_lw_offset_p (addr.offset))\n     return false;\n \n@@ -1708,6 +1704,13 @@ riscv_rtx_costs (rtx x, machine_mode mode, int outer_code, int opno ATTRIBUTE_UN\n \t instructions it needs.  */\n       if ((cost = riscv_address_insns (XEXP (x, 0), mode, true)) > 0)\n \t{\n+\t  /* When optimizing for size, make uncompressible 32-bit addresses\n+\t     more expensive so that compressible 32-bit addresses are\n+\t     preferred.  */\n+\t  if (TARGET_RVC && !speed && riscv_mshorten_memrefs && mode == SImode\n+\t      && !riscv_compressed_lw_address_p (XEXP (x, 0)))\n+\t    cost++;\n+\n \t  *total = COSTS_N_INSNS (cost + tune_param->memory_cost);\n \t  return true;\n \t}"}]}