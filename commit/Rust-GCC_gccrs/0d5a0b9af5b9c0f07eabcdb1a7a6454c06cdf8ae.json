{"sha": "0d5a0b9af5b9c0f07eabcdb1a7a6454c06cdf8ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ1YTBiOWFmNWI5YzBmMDdlYWJjZGIxYTdhNjQ1NGMwNmNkZjhhZQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tom@tromey.com", "date": "2021-05-04T21:26:58Z"}, "committer": {"name": "Tom Tromey", "email": "tom@tromey.com", "date": "2021-05-05T06:06:17Z"}, "message": "libcc1: add deleter objects\n\nThis adds deleter objects for various kinds of protocol pointers to\nlibcc1.  Existing specializations of argument_wrapper are then\nreplaced with a single specialization that handles all pointer types\nvia the appropriate deleter.  The result here is a bit nicer because\nthe argument_wrapper boilerplate code is completely shared, leaving\njust the memory-management detail to the particular specializations.\n\nlibcc1\n\n\t* rpc.hh (struct deleter): New template class and\n\tspecializations.\n\t(argument_wrapper): Remove specializations.  Add specialization\n\tfor any pointer type.", "tree": {"sha": "d808982bd5641a7b977e5b69c33b36edd3aa08e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d808982bd5641a7b977e5b69c33b36edd3aa08e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d5a0b9af5b9c0f07eabcdb1a7a6454c06cdf8ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d5a0b9af5b9c0f07eabcdb1a7a6454c06cdf8ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d5a0b9af5b9c0f07eabcdb1a7a6454c06cdf8ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d5a0b9af5b9c0f07eabcdb1a7a6454c06cdf8ae/comments", "author": {"login": "tromey", "id": 1557670, "node_id": "MDQ6VXNlcjE1NTc2NzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tromey", "html_url": "https://github.com/tromey", "followers_url": "https://api.github.com/users/tromey/followers", "following_url": "https://api.github.com/users/tromey/following{/other_user}", "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}", "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tromey/subscriptions", "organizations_url": "https://api.github.com/users/tromey/orgs", "repos_url": "https://api.github.com/users/tromey/repos", "events_url": "https://api.github.com/users/tromey/events{/privacy}", "received_events_url": "https://api.github.com/users/tromey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tromey", "id": 1557670, "node_id": "MDQ6VXNlcjE1NTc2NzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tromey", "html_url": "https://github.com/tromey", "followers_url": "https://api.github.com/users/tromey/followers", "following_url": "https://api.github.com/users/tromey/following{/other_user}", "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}", "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tromey/subscriptions", "organizations_url": "https://api.github.com/users/tromey/orgs", "repos_url": "https://api.github.com/users/tromey/repos", "events_url": "https://api.github.com/users/tromey/events{/privacy}", "received_events_url": "https://api.github.com/users/tromey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e702c60e65cf9c13587d571cdd158bca74f4c2e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e702c60e65cf9c13587d571cdd158bca74f4c2e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e702c60e65cf9c13587d571cdd158bca74f4c2e2"}], "stats": {"total": 176, "additions": 45, "deletions": 131}, "files": [{"sha": "4e00d61ee98daad8e445f97592d9dd895c54903a", "filename": "libcc1/rpc.hh", "status": "modified", "additions": 45, "deletions": 131, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d5a0b9af5b9c0f07eabcdb1a7a6454c06cdf8ae/libcc1%2Frpc.hh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d5a0b9af5b9c0f07eabcdb1a7a6454c06cdf8ae/libcc1%2Frpc.hh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Frpc.hh?ref=0d5a0b9af5b9c0f07eabcdb1a7a6454c06cdf8ae", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"status.hh\"\n #include \"connection.hh\"\n+#include <memory>\n \n namespace cc1_plugin\n {\n@@ -54,182 +55,95 @@ namespace cc1_plugin\n     T m_object;\n   };\n \n-  // Specialization for any kind of pointer.  This is declared but not\n-  // defined to avoid bugs if a new pointer type is introduced into\n-  // the API.  Instead you will just get a compilation error.\n-  template<typename T>\n-  class argument_wrapper<const T *>;\n+  // Any pointer type requires a deleter object that knows how to\n+  // clean up.  These are used in multiple places.\n+  template<typename T> struct deleter;\n \n-  // Specialization for string types.\n   template<>\n-  class argument_wrapper<const char *>\n+  struct deleter<char>\n   {\n-  public:\n-    argument_wrapper () : m_object (NULL) { }\n-    ~argument_wrapper ()\n+    void operator() (char *s)\n     {\n-      delete[] m_object;\n+      delete[] s;\n     }\n-\n-    argument_wrapper (const argument_wrapper &) = delete;\n-    argument_wrapper &operator= (const argument_wrapper &) = delete;\n-\n-    operator const char * () const\n-    {\n-      return m_object;\n-    }\n-\n-    status unmarshall (connection *conn)\n-    {\n-      return ::cc1_plugin::unmarshall (conn, &m_object);\n-    }\n-\n-  private:\n-\n-    char *m_object;\n   };\n \n-  // Specialization for gcc_type_array.\n   template<>\n-  class argument_wrapper<const gcc_type_array *>\n+  struct deleter<gcc_type_array>\n   {\n-  public:\n-    argument_wrapper () : m_object (NULL) { }\n-    ~argument_wrapper ()\n+    void operator() (gcc_type_array *p)\n     {\n-      // It would be nicer if gcc_type_array could have a destructor.\n-      // But, it is in code shared with gdb and cannot.\n-      if (m_object != NULL)\n-\tdelete[] m_object->elements;\n-      delete m_object;\n+      delete[] p->elements;\n+      delete p;\n     }\n-\n-    argument_wrapper (const argument_wrapper &) = delete;\n-    argument_wrapper &operator= (const argument_wrapper &) = delete;\n-\n-    operator const gcc_type_array * () const\n-    {\n-      return m_object;\n-    }\n-\n-    status unmarshall (connection *conn)\n-    {\n-      return ::cc1_plugin::unmarshall (conn, &m_object);\n-    }\n-\n-  private:\n-\n-    gcc_type_array *m_object;\n   };\n \n #ifdef GCC_CP_INTERFACE_H\n-  // Specialization for gcc_vbase_array.\n   template<>\n-  class argument_wrapper<const gcc_vbase_array *>\n+  struct deleter<gcc_vbase_array>\n   {\n-  public:\n-    argument_wrapper () : m_object (NULL) { }\n-    ~argument_wrapper ()\n-    {\n-      // It would be nicer if gcc_type_array could have a destructor.\n-      // But, it is in code shared with gdb and cannot.\n-      if (m_object != NULL)\n-\t{\n-\t  delete[] m_object->flags;\n-\t  delete[] m_object->elements;\n-\t}\n-      delete m_object;\n-    }\n-\n-    argument_wrapper (const argument_wrapper &) = delete;\n-    argument_wrapper &operator= (const argument_wrapper &) = delete;\n-\n-    operator const gcc_vbase_array * () const\n+    void operator() (gcc_vbase_array *p)\n     {\n-      return m_object;\n-    }\n-\n-    status unmarshall (connection *conn)\n-    {\n-      return ::cc1_plugin::unmarshall (conn, &m_object);\n+      delete[] p->flags;\n+      delete[] p->elements;\n+      delete p;\n     }\n-\n-  private:\n-\n-    gcc_vbase_array *m_object;\n   };\n \n-  // Specialization for gcc_cp_template_args.\n   template<>\n-  class argument_wrapper<const gcc_cp_template_args *>\n+  struct deleter<gcc_cp_template_args>\n   {\n-  public:\n-    argument_wrapper () : m_object (NULL) { }\n-    ~argument_wrapper ()\n-    {\n-      // It would be nicer if gcc_type_array could have a destructor.\n-      // But, it is in code shared with gdb and cannot.\n-      if (m_object != NULL)\n-\t{\n-\t  delete[] m_object->elements;\n-\t  delete[] m_object->kinds;\n-\t}\n-      delete m_object;\n-    }\n-\n-    argument_wrapper (const argument_wrapper &) = delete;\n-    argument_wrapper &operator= (const argument_wrapper &) = delete;\n-\n-    operator const gcc_cp_template_args * () const\n+    void operator() (gcc_cp_template_args *p)\n     {\n-      return m_object;\n+      delete[] p->elements;\n+      delete[] p->kinds;\n+      delete p;\n     }\n+  };\n \n-    status unmarshall (connection *conn)\n+  template<>\n+  struct deleter<gcc_cp_function_args>\n+  {\n+    void operator() (gcc_cp_function_args *p)\n     {\n-      return ::cc1_plugin::unmarshall (conn, &m_object);\n+      delete[] p->elements;\n+      delete p;\n     }\n-\n-  private:\n-\n-    gcc_cp_template_args *m_object;\n   };\n \n-  // Specialization for gcc_cp_function_args.\n-  template<>\n-  class argument_wrapper<const gcc_cp_function_args *>\n+#endif // GCC_CP_INTERFACE_H\n+\n+  // Specialization for any kind of pointer.\n+  template<typename T>\n+  class argument_wrapper<T *>\n   {\n   public:\n-    argument_wrapper () : m_object (NULL) { }\n-    ~argument_wrapper ()\n-    {\n-      // It would be nicer if gcc_type_array could have a destructor.\n-      // But, it is in code shared with gdb and cannot.\n-      if (m_object != NULL)\n-\t{\n-\t  delete[] m_object->elements;\n-\t}\n-      delete m_object;\n-    }\n+    argument_wrapper () = default;\n+    ~argument_wrapper () = default;\n \n     argument_wrapper (const argument_wrapper &) = delete;\n     argument_wrapper &operator= (const argument_wrapper &) = delete;\n \n-    operator const gcc_cp_function_args * () const\n+    typedef typename std::remove_const<T>::type type;\n+\n+    operator const type * () const\n     {\n-      return m_object;\n+      return m_object.get ();\n     }\n \n     status unmarshall (connection *conn)\n     {\n-      return ::cc1_plugin::unmarshall (conn, &m_object);\n+      type *ptr;\n+      if (!::cc1_plugin::unmarshall (conn, &ptr))\n+\treturn FAIL;\n+      m_object.reset (ptr);\n+      return OK;\n     }\n \n   private:\n \n-    gcc_cp_function_args *m_object;\n+    std::unique_ptr<type, deleter<type>> m_object;\n   };\n-#endif /* GCC_CP_INTERFACE_H */\n \n   // There are two kinds of template functions here: \"call\" and\n   // \"callback\".  \"call\" is implemented with variadic templates, but"}]}