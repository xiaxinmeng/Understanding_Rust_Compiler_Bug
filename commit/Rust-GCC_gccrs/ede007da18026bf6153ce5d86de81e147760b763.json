{"sha": "ede007da18026bf6153ce5d86de81e147760b763", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRlMDA3ZGExODAyNmJmNjE1M2NlNWQ4NmRlODFlMTQ3NzYwYjc2Mw==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2007-08-14T08:39:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:39:33Z"}, "message": "prj.ads, prj.adb: Update Project Manager to new attribute names for gprbuild.\n\n2007-08-14  Vincent Celier  <celier@adacore.com>\n\n\t* prj.ads, prj.adb: Update Project Manager to new attribute names for\n\tgprbuild.\n\tAllow all valid declarations in configuration project files\n\t(Reset): Initialize all tables and hash tables in the project tree data\n\tMajor update of the Project Manager and of the project aware tools,\n\tincluding gprmake, so that the same sources in the GNAT repository\n\tcan be used by gprbuild.\n\t(Slash_Id): Change type to be Path_Name_Type\n\t(Slash): Return a Path_Name_Type instead of a File_Name_Type\n\n\t* prj-attr.ads, prj-attr.adb: Remove attributes no longer used by\n\tgprbuild.\n\tUpdate Project Manager to new attribute names for ghprbuild\n\tAllow all valid declarations in configuration project files\n\tMajor update of the Project Manager and of the project aware tools,\n\tincluding gprmake, so that the same sources in the GNAT repository\n\tcan be used by gprbuild.\n\n\t* prj-com.ads: \n\tMajor update of the Project Manager and of the project aware tools,\n\tincluding gprmake, so that the same sources in the GNAT repository\n\tcan be used by gprbuild.\n\n\t* prj-dect.adb (Prj.Strt.Attribute_Reference): Set correctly the case\n\tinsensitive flag for attributes with optional index.\n\t(Prj.Dect.Parse_Attribute_Declaration): For case insensitive associative\n\tarray attribute, put the index in lower case.\n\tUpdate Project Manager to new attribute names for ghprbuild\n\tAllow all valid declarations in configuration project files\n\tMajor update of the Project Manager and of the project aware tools,\n\tincluding gprmake, so that the same sources in the GNAT repository\n\tcan be used by gprbuild.\n\n\t* prj-env.ads, prj-env.adb: \n\tMajor update of the Project Manager and of the project aware tools,\n\tincluding gprmake, so that the same sources in the GNAT repository\n\tcan be used by gprbuild.\n\t(Get_Reference): Change type of parameter Path to Path_Name_Type\n\n\t* prj-ext.ads, prj-ext.adb (Initialize_Project_Path): Make sure, after\n\tremoving '-' from the path to start with the first character of the\n\tnext directory.\n\tMajor update of the Project Manager and of the project aware tools,\n\tincluding gprmake, so that the same sources in the GNAT repository\n\tcan be used by gprbuild.\n\tMajor update of the Project Manager and of the project aware tools,\n\tincluding gprmake, so that the same sources in the GNAT repository\n\tcan be used by gprbuild.\n\n\t* prj-nmsc.ads, prj-nmsc.adb: \n\tUpdate Project Manager to new attribute names for ghprbuild\n\tAllow all valid declarations in configuration project files\n\t(Search_Directories): Detect subunits that are specified with an\n\tattribute Body in package Naming. Do not replace a source/unit in the\n\tsame project when the order of the source dirs are known. Detect\n\tduplicate sources/units in the same project when the order of the\n\tsource dirs are not known.\n\t(Check_Ada_Name): Allow all identifiers that are not reserved words\n\tin Ada 95.\n\tMajor update of the Project Manager and of the project aware tools,\n\tincluding gprmake, so that the same sources in the GNAT repository\n\tcan be used by gprbuild.\n\t(Look_For_Sources): If the list of sources is empty, set the object\n\tdirectory of non extending project to nil.\n\tChange type of path name variables to be Path_Name_Type\n\t(Locate_Directory): Make sure that on Windows '/' is converted to '\\',\n\totherwise creating missing directories will fail.\n\n\t* prj-attr-pm.adb, prj-tree.ads, prj-proc.ads, prj-proc.adb, \n\tprj-part.ads, prj-part.adb:\n\tMajor update of the Project Manager and of the project aware tools,\n\tincluding gprmake, so that the same sources in the GNAT repository\n\tcan be used by gprbuild.\n\n\t* prj-strt.adb (Prj.Strt.Attribute_Reference): Set correctly the case\n\tinsensitive flag for attributes with optional index.\n\t(Prj.Dect.Parse_Attribute_Declaration): For case insensitive associative\n\tarray attribute, put the index in lower case.\n\t(Parse_Variable_Reference): Allow the current project name to be used in\n\tthe prefix of an attribute reference.\n\n\t* prj-util.ads, prj-util.adb\n\t(Value_Of (for arrays)): New Boolean parameter Force_Lower_Case_Index,\n\tdefaulted to False. When True, always check against indexes in lower\n\tcase.\n\n\t* snames.ads, snames.h, snames.adb: \n\tUpdate Project Manager to new attribute names for gprbuild\n\tAllow all valid declarations in configuration project files\n\nFrom-SVN: r127420", "tree": {"sha": "42154a73ebb6b14dd56ca33611abdbb14e1ac2ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42154a73ebb6b14dd56ca33611abdbb14e1ac2ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ede007da18026bf6153ce5d86de81e147760b763", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ede007da18026bf6153ce5d86de81e147760b763", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ede007da18026bf6153ce5d86de81e147760b763", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ede007da18026bf6153ce5d86de81e147760b763/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "86cde7b14709c9ac4e599dfd16402d4145e80a05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86cde7b14709c9ac4e599dfd16402d4145e80a05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86cde7b14709c9ac4e599dfd16402d4145e80a05"}], "stats": {"total": 10340, "additions": 7551, "deletions": 2789}, "files": [{"sha": "b9743333f85a5b01fc9df5a21f6eeb877db9c1d2", "filename": "gcc/ada/prj-attr-pm.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-attr-pm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-attr-pm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr-pm.adb?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -45,6 +45,7 @@ package body Prj.Attr.PM is\n             Var_Kind          => Undefined,\n             Optional_Index    => False,\n             Attr_Kind         => Unknown,\n+            Read_Only         => False,\n             Next              =>\n               Package_Attributes.Table (To_Package.Value).First_Attribute);\n          Package_Attributes.Table (To_Package.Value).First_Attribute :=\n@@ -62,7 +63,9 @@ package body Prj.Attr.PM is\n       Package_Attributes.Increment_Last;\n       Id := (Value => Package_Attributes.Last);\n       Package_Attributes.Table (Id.Value) :=\n-        (Name => Name, Known => False, First_Attribute => Empty_Attr);\n+        (Name             => Name,\n+         Known            => False,\n+         First_Attribute  => Empty_Attr);\n    end Add_Unknown_Package;\n \n end Prj.Attr.PM;"}, {"sha": "ca207fffb916c011ea591336ef3afa836055cf9f", "filename": "gcc/ada/prj-attr.adb", "status": "modified", "additions": 220, "deletions": 113, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.adb?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -32,11 +32,11 @@ package body Prj.Attr is\n \n    --  Data for predefined attributes and packages\n \n-   --  Names end with '#'\n+   --  Names are in lower case and end with '#'\n \n    --  Package names are preceded by 'P'\n \n-   --  Attribute names are preceded by two letters:\n+   --  Attribute names are preceded by two or three letters:\n \n    --  The first letter is one of\n    --    'S' for Single\n@@ -52,161 +52,242 @@ package body Prj.Attr is\n    --        insensitive\n    --    'c' same as 'b', with optional index\n \n+   --  The third optional letter is\n+   --     'R' to indicate that the attribute is read-only\n+\n    --  End is indicated by two consecutive '#'\n \n    Initialization_Data : constant String :=\n \n-   --  project attributes\n-\n-     \"SVobject_dir#\" &\n-     \"SVexec_dir#\" &\n-     \"LVsource_dirs#\" &\n-     \"LVsource_files#\" &\n-     \"LVlocally_removed_files#\" &\n-     \"SVsource_list_file#\" &\n-     \"SVlibrary_dir#\" &\n-     \"SVlibrary_name#\" &\n-     \"SVlibrary_kind#\" &\n-     \"SVlibrary_version#\" &\n-     \"LVlibrary_interface#\" &\n-     \"SVlibrary_auto_init#\" &\n-     \"LVlibrary_options#\" &\n-     \"SVlibrary_src_dir#\" &\n-     \"SVlibrary_ali_dir#\" &\n-     \"SVlibrary_gcc#\" &\n-     \"SVlibrary_symbol_file#\" &\n-     \"SVlibrary_symbol_policy#\" &\n-     \"SVlibrary_reference_symbol_file#\" &\n-     \"lVmain#\" &\n-     \"LVlanguages#\" &\n-     \"SVmain_language#\" &\n-     \"LVada_roots#\" &\n-     \"SVexternally_built#\" &\n+   --  project level attributes\n+\n+   --  General\n+\n+   \"SVRname#\" &\n+   \"lVmain#\" &\n+   \"LVlanguages#\" &\n+   \"SVmain_language#\" &\n+   \"Laroots#\" &\n+   \"SVexternally_built#\" &\n+\n+   --  Directories\n+\n+   \"SVobject_dir#\" &\n+   \"SVexec_dir#\" &\n+   \"LVsource_dirs#\" &\n+\n+   --  Source files\n+\n+   \"LVsource_files#\" &\n+   \"LVlocally_removed_files#\" &\n+   \"SVsource_list_file#\" &\n+\n+   --  Libraries\n+\n+   \"SVlibrary_dir#\" &\n+   \"SVlibrary_name#\" &\n+   \"SVlibrary_kind#\" &\n+   \"SVlibrary_version#\" &\n+   \"LVlibrary_interface#\" &\n+   \"SVlibrary_auto_init#\" &\n+   \"LVlibrary_options#\" &\n+   \"SVlibrary_src_dir#\" &\n+   \"SVlibrary_ali_dir#\" &\n+   \"SVlibrary_gcc#\" &\n+   \"SVlibrary_symbol_file#\" &\n+   \"SVlibrary_symbol_policy#\" &\n+   \"SVlibrary_reference_symbol_file#\" &\n+\n+   --  Configuration - General\n+\n+   \"SVdefault_language#\" &\n+   \"LVrun_path_option#\" &\n+   \"Satoolchain_version#\" &\n+   \"Satoolchain_description#\" &\n+\n+   --  Configuration - Libraries\n+\n+   \"SVlibrary_builder#\" &\n+   \"SVlibrary_support#\" &\n+\n+   --  Configuration - Archives\n+\n+   \"LVarchive_builder#\" &\n+   \"LVarchive_indexer#\" &\n+   \"SVarchive_suffix#\" &\n+   \"LVlibrary_partial_linker#\" &\n+\n+   --  Configuration - Shared libraries\n+\n+   \"SVshared_library_prefix#\" &\n+   \"SVshared_library_suffix#\" &\n+   \"SVsymbolic_link_supported#\" &\n+   \"SVlibrary_major_minor_id_supported#\" &\n+   \"SVlibrary_auto_init_supported#\" &\n+   \"LVshared_library_minimum_switches#\" &\n+   \"LVlibrary_version_switches#\" &\n \n    --  package Naming\n \n-     \"Pnaming#\" &\n-     \"Saspecification_suffix#\" &\n-     \"Saspec_suffix#\" &\n-     \"Saimplementation_suffix#\" &\n-     \"Sabody_suffix#\" &\n-     \"SVseparate_suffix#\" &\n-     \"SVcasing#\" &\n-     \"SVdot_replacement#\" &\n-     \"sAspecification#\" &\n-     \"sAspec#\" &\n-     \"sAimplementation#\" &\n-     \"sAbody#\" &\n-     \"Laspecification_exceptions#\" &\n-     \"Laimplementation_exceptions#\" &\n+   \"Pnaming#\" &\n+   \"Saspecification_suffix#\" &\n+   \"Saspec_suffix#\" &\n+   \"Saimplementation_suffix#\" &\n+   \"Sabody_suffix#\" &\n+   \"SVseparate_suffix#\" &\n+   \"SVcasing#\" &\n+   \"SVdot_replacement#\" &\n+   \"sAspecification#\" &\n+   \"sAspec#\" &\n+   \"sAimplementation#\" &\n+   \"sAbody#\" &\n+   \"Laspecification_exceptions#\" &\n+   \"Laimplementation_exceptions#\" &\n \n    --  package Compiler\n \n-     \"Pcompiler#\" &\n-     \"Ladefault_switches#\" &\n-     \"Lcswitches#\" &\n-     \"SVlocal_configuration_pragmas#\" &\n+   \"Pcompiler#\" &\n+   \"Ladefault_switches#\" &\n+   \"Lcswitches#\" &\n+   \"SVlocal_configuration_pragmas#\" &\n+   \"Salocal_config_file#\" &\n+\n+   --  Configuration - Compiling\n+\n+   \"Sadriver#\" &\n+   \"Lapic_option#\" &\n+\n+   --  Configuration - Mapping files\n+\n+   \"Lamapping_file_switches#\" &\n+   \"Samapping_spec_suffix#\" &\n+   \"Samapping_body_suffix#\" &\n+\n+   --  Configuration - Config files\n+\n+   \"Laconfig_file_switches#\" &\n+   \"Saconfig_body_file_name#\" &\n+   \"Saconfig_spec_file_name#\" &\n+   \"Saconfig_body_file_name_pattern#\" &\n+   \"Saconfig_spec_file_name_pattern#\" &\n+   \"Saconfig_file_unique#\" &\n+\n+   --  Configuration - Dependencies\n+\n+   \"Ladependency_switches#\" &\n+   \"Lacompute_dependency#\" &\n+\n+   --  Configuration - Search paths\n+\n+   \"Lainclude_switches#\" &\n+   \"Sainclude_path#\" &\n+   \"Sainclude_path_file#\" &\n \n    --  package Builder\n \n-     \"Pbuilder#\" &\n-     \"Ladefault_switches#\" &\n-     \"Lcswitches#\" &\n-     \"Scexecutable#\" &\n-     \"SVexecutable_suffix#\" &\n-     \"SVglobal_configuration_pragmas#\" &\n+   \"Pbuilder#\" &\n+   \"Ladefault_switches#\" &\n+   \"Lcswitches#\" &\n+   \"Scexecutable#\" &\n+   \"SVexecutable_suffix#\" &\n+   \"SVglobal_configuration_pragmas#\" &\n+   \"Saglobal_config_file#\" &\n \n    --  package gnatls\n \n-     \"Pgnatls#\" &\n-     \"LVswitches#\" &\n+   \"Pgnatls#\" &\n+   \"LVswitches#\" &\n \n    --  package Binder\n \n-     \"Pbinder#\" &\n-     \"Ladefault_switches#\" &\n-     \"Lcswitches#\" &\n+   \"Pbinder#\" &\n+   \"Ladefault_switches#\" &\n+   \"Lcswitches#\" &\n+\n+   --  Configuration - Binding\n+\n+   \"Sadriver#\" &\n+   \"Saprefix#\" &\n+   \"Saobjects_path#\" &\n+   \"Saobjects_path_file#\" &\n \n    --  package Linker\n \n-     \"Plinker#\" &\n-     \"Ladefault_switches#\" &\n-     \"Lcswitches#\" &\n-     \"LVlinker_options#\" &\n+   \"Plinker#\" &\n+   \"LVrequired_switches#\" &\n+   \"Ladefault_switches#\" &\n+   \"Lcswitches#\" &\n+   \"LVlinker_options#\" &\n+\n+   --  Configuration - Linking\n+\n+   \"SVdriver#\" &\n+   \"LVexecutable_switch#\" &\n+   \"SVlib_dir_switch#\" &\n+   \"SVlib_name_switch#\" &\n \n    --  package Cross_Reference\n \n-     \"Pcross_reference#\" &\n-     \"Ladefault_switches#\" &\n-     \"Lbswitches#\" &\n+   \"Pcross_reference#\" &\n+   \"Ladefault_switches#\" &\n+   \"Lbswitches#\" &\n \n    --  package Finder\n \n-     \"Pfinder#\" &\n-     \"Ladefault_switches#\" &\n-     \"Lbswitches#\" &\n+   \"Pfinder#\" &\n+   \"Ladefault_switches#\" &\n+   \"Lbswitches#\" &\n \n    --  package Pretty_Printer\n \n-     \"Ppretty_printer#\" &\n-     \"Ladefault_switches#\" &\n-     \"Lbswitches#\" &\n+   \"Ppretty_printer#\" &\n+   \"Ladefault_switches#\" &\n+   \"Lbswitches#\" &\n \n    --  package gnatstub\n \n-     \"Pgnatstub#\" &\n-     \"Ladefault_switches#\" &\n-     \"Lbswitches#\" &\n+   \"Pgnatstub#\" &\n+   \"Ladefault_switches#\" &\n+   \"Lbswitches#\" &\n \n    --  package Check\n \n-     \"Pcheck#\" &\n-     \"Ladefault_switches#\" &\n-     \"Lbswitches#\" &\n+   \"Pcheck#\" &\n+   \"Ladefault_switches#\" &\n+   \"Lbswitches#\" &\n \n    --  package Eliminate\n \n-     \"Peliminate#\" &\n-     \"Ladefault_switches#\" &\n-     \"Lbswitches#\" &\n+   \"Peliminate#\" &\n+   \"Ladefault_switches#\" &\n+   \"Lbswitches#\" &\n \n    --  package Metrics\n \n-     \"Pmetrics#\" &\n-     \"Ladefault_switches#\" &\n-     \"Lbswitches#\" &\n+   \"Pmetrics#\" &\n+   \"Ladefault_switches#\" &\n+   \"Lbswitches#\" &\n \n    --  package Ide\n \n-     \"Pide#\" &\n-     \"Ladefault_switches#\" &\n-     \"SVremote_host#\" &\n-     \"SVprogram_host#\" &\n-     \"SVcommunication_protocol#\" &\n-     \"Sacompiler_command#\" &\n-     \"SVdebugger_command#\" &\n-     \"SVgnatlist#\" &\n-     \"SVvcs_kind#\" &\n-     \"SVvcs_file_check#\" &\n-     \"SVvcs_log_check#\" &\n+   \"Pide#\" &\n+   \"Ladefault_switches#\" &\n+   \"SVremote_host#\" &\n+   \"SVprogram_host#\" &\n+   \"SVcommunication_protocol#\" &\n+   \"Sacompiler_command#\" &\n+   \"SVdebugger_command#\" &\n+   \"SVgnatlist#\" &\n+   \"SVvcs_kind#\" &\n+   \"SVvcs_file_check#\" &\n+   \"SVvcs_log_check#\" &\n \n    --  package Stack\n \n-     \"Pstack#\" &\n-     \"LVswitches#\" &\n-\n-   --  package Language_Processing\n+   \"Pstack#\" &\n+   \"LVswitches#\" &\n \n-     \"Planguage_processing#\" &\n-     \"Lacompiler_driver#\" &\n-     \"Sacompiler_kind#\" &\n-     \"Ladependency_option#\" &\n-     \"Lacompute_dependency#\" &\n-     \"Lainclude_option#\" &\n-     \"Sabinder_driver#\" &\n-     \"SVdefault_linker#\" &\n-\n-     \"#\";\n+   \"#\";\n \n    Initialized : Boolean := False;\n    --  A flag to avoid multiple initialization\n@@ -274,10 +355,11 @@ package body Prj.Attr is\n       Is_An_Attribute   : Boolean           := False;\n       Var_Kind          : Variable_Kind     := Undefined;\n       Optional_Index    : Boolean           := False;\n-      Attr_Kind            : Attribute_Kind := Single;\n+      Attr_Kind         : Attribute_Kind    := Single;\n       Package_Name      : Name_Id           := No_Name;\n       Attribute_Name    : Name_Id           := No_Name;\n       First_Attribute   : Attr_Node_Id      := Attr.First_Attribute;\n+      Read_Only         : Boolean;\n \n       function Attribute_Location return String;\n       --  Returns a string depending if we are in the project level attributes\n@@ -342,9 +424,9 @@ package body Prj.Attr is\n                Package_Attributes.Increment_Last;\n                Current_Package := Package_Attributes.Last;\n                Package_Attributes.Table (Current_Package) :=\n-                 (Name            => Package_Name,\n-                  Known           => True,\n-                  First_Attribute => Empty_Attr);\n+                 (Name             => Package_Name,\n+                  Known            => True,\n+                  First_Attribute  => Empty_Attr);\n                Start := Finish + 1;\n \n             when 'S' =>\n@@ -402,6 +484,15 @@ package body Prj.Attr is\n             end case;\n \n             Start := Start + 1;\n+\n+            if Initialization_Data (Start) = 'R' then\n+               Read_Only := True;\n+               Start := Start + 1;\n+\n+            else\n+               Read_Only := False;\n+            end if;\n+\n             Finish := Start;\n \n             while Initialization_Data (Finish) /= '#' loop\n@@ -441,6 +532,7 @@ package body Prj.Attr is\n                Var_Kind       => Var_Kind,\n                Optional_Index => Optional_Index,\n                Attr_Kind      => Attr_Kind,\n+               Read_Only      => Read_Only,\n                Next           => Empty_Attr);\n             Start := Finish + 1;\n          end if;\n@@ -449,6 +541,15 @@ package body Prj.Attr is\n       Initialized := True;\n    end Initialize;\n \n+   ------------------\n+   -- Is_Read_Only --\n+   ------------------\n+\n+   function Is_Read_Only (Attribute : Attribute_Node_Id) return Boolean is\n+   begin\n+      return Attrs.Table (Attribute.Value).Read_Only;\n+   end Is_Read_Only;\n+\n    ----------------\n    -- Name_Id_Of --\n    ----------------\n@@ -582,6 +683,7 @@ package body Prj.Attr is\n          Var_Kind       => Var_Kind,\n          Optional_Index => Opt_Index,\n          Attr_Kind      => Real_Attr_Kind,\n+         Read_Only      => False,\n          Next           => First_Attr);\n       Package_Attributes.Table (In_Package.Value).First_Attribute :=\n         Attrs.Last;\n@@ -615,7 +717,9 @@ package body Prj.Attr is\n       Package_Attributes.Increment_Last;\n       Id := (Value => Package_Attributes.Last);\n       Package_Attributes.Table (Package_Attributes.Last) :=\n-        (Name => Pkg_Name, Known => True, First_Attribute => Empty_Attr);\n+        (Name             => Pkg_Name,\n+         Known            => True,\n+         First_Attribute  => Empty_Attr);\n    end Register_New_Package;\n \n    procedure Register_New_Package\n@@ -682,13 +786,16 @@ package body Prj.Attr is\n             Var_Kind       => Attributes (Index).Var_Kind,\n             Optional_Index => Attributes (Index).Opt_Index,\n             Attr_Kind      => Attr_Kind,\n+            Read_Only      => False,\n             Next           => First_Attr);\n          First_Attr := Attrs.Last;\n       end loop;\n \n       Package_Attributes.Increment_Last;\n       Package_Attributes.Table (Package_Attributes.Last) :=\n-        (Name => Pkg_Name, Known => True, First_Attribute => First_Attr);\n+        (Name             => Pkg_Name,\n+         Known            => True,\n+         First_Attribute  => First_Attr);\n    end Register_New_Package;\n \n    ---------------------------"}, {"sha": "ce4ff4c0091cd7af93a483d4e816e8a7245b8188", "filename": "gcc/ada/prj-attr.ads", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.ads?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -153,6 +153,8 @@ package Prj.Attr is\n    --  Returns True if Attribute is a known attribute and may have an\n    --  optional index. Returns False otherwise.\n \n+   function Is_Read_Only (Attribute : Attribute_Node_Id) return Boolean;\n+\n    function Next_Attribute\n      (After : Attribute_Node_Id) return Attribute_Node_Id;\n    --  Returns the attribute that follow After in the list of project level\n@@ -269,39 +271,38 @@ private\n       Var_Kind       : Variable_Kind;\n       Optional_Index : Boolean;\n       Attr_Kind      : Attribute_Kind;\n+      Read_Only      : Boolean;\n       Next           : Attr_Node_Id;\n    end record;\n    --  Data for an attribute\n \n    package Attrs is\n-     new Table.Table\n-       (Table_Component_Type => Attribute_Record,\n-        Table_Index_Type     => Attr_Node_Id,\n-        Table_Low_Bound      => First_Attribute,\n-        Table_Initial        => Attributes_Initial,\n-        Table_Increment      => Attributes_Increment,\n-        Table_Name           => \"Prj.Attr.Attrs\");\n+      new Table.Table (Table_Component_Type => Attribute_Record,\n+                       Table_Index_Type     => Attr_Node_Id,\n+                       Table_Low_Bound      => First_Attribute,\n+                       Table_Initial        => Attributes_Initial,\n+                       Table_Increment      => Attributes_Increment,\n+                       Table_Name           => \"Prj.Attr.Attrs\");\n    --  The table of the attributes\n \n    --------------\n    -- Packages --\n    --------------\n \n    type Package_Record is record\n-      Name            : Name_Id;\n-      Known           : Boolean := True;\n-      First_Attribute : Attr_Node_Id;\n+      Name             : Name_Id;\n+      Known            : Boolean := True;\n+      First_Attribute  : Attr_Node_Id;\n    end record;\n    --  Data for a package\n \n    package Package_Attributes is\n-     new Table.Table\n-       (Table_Component_Type => Package_Record,\n-        Table_Index_Type     => Pkg_Node_Id,\n-        Table_Low_Bound      => First_Package,\n-        Table_Initial        => Packages_Initial,\n-        Table_Increment      => Packages_Increment,\n-        Table_Name           => \"Prj.Attr.Packages\");\n+      new Table.Table (Table_Component_Type => Package_Record,\n+                       Table_Index_Type     => Pkg_Node_Id,\n+                       Table_Low_Bound      => First_Package,\n+                       Table_Initial        => Packages_Initial,\n+                       Table_Increment      => Packages_Increment,\n+                       Table_Name           => \"Prj.Attr.Packages\");\n    --  The table of the packages\n \n end Prj.Attr;"}, {"sha": "3dcdfb4a13dd3ae24a910a5d8d2a759d1d28a19c", "filename": "gcc/ada/prj-com.ads", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-com.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-com.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-com.ads?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2000-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -24,10 +24,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  The following package declares data types for GNAT project.\n---  These data types are used in the bodies of the Prj hierarchy.\n-\n---  Above comment seems *far* too general ???\n+--  The following package declares a Fail procedure that is used in the\n+--  Project Manager.\n \n with Osint;\n "}, {"sha": "139175c859b0a7f7cd1c53d39670977d6082bed5", "filename": "gcc/ada/prj-dect.adb", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-dect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-dect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-dect.adb?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -24,14 +24,17 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Err_Vars;    use Err_Vars;\n+with Err_Vars; use Err_Vars;\n+\n+with GNAT.Case_Util; use GNAT.Case_Util;\n+\n with Opt;         use Opt;\n+with Prj.Attr;    use Prj.Attr;\n+with Prj.Attr.PM; use Prj.Attr.PM;\n with Prj.Err;     use Prj.Err;\n with Prj.Strt;    use Prj.Strt;\n with Prj.Tree;    use Prj.Tree;\n with Snames;\n-with Prj.Attr;    use Prj.Attr;\n-with Prj.Attr.PM; use Prj.Attr.PM;\n with Uintp;       use Uintp;\n \n package body Prj.Dect is\n@@ -214,11 +217,19 @@ package body Prj.Dect is\n \n          --  Set, if appropriate the index case insensitivity flag\n \n-         elsif Attribute_Kind_Of (Current_Attribute) in\n+         else\n+            if Is_Read_Only (Current_Attribute) then\n+               Error_Msg\n+                 (\"read-only attribute cannot be given a value\",\n+                  Token_Ptr);\n+            end if;\n+\n+            if Attribute_Kind_Of (Current_Attribute) in\n                  Case_Insensitive_Associative_Array ..\n                  Optional_Index_Case_Insensitive_Associative_Array\n-         then\n-            Set_Case_Insensitive (Attribute, In_Tree, To => True);\n+            then\n+               Set_Case_Insensitive (Attribute, In_Tree, To => True);\n+            end if;\n          end if;\n \n          Scan (In_Tree); --  past the attribute name\n@@ -272,7 +283,13 @@ package body Prj.Dect is\n          Expect (Tok_String_Literal, \"literal string\");\n \n          if Token = Tok_String_Literal then\n-            Set_Associative_Array_Index_Of (Attribute, In_Tree, Token_Name);\n+            Get_Name_String (Token_Name);\n+\n+            if Case_Insensitive (Attribute, In_Tree) then\n+               To_Lower (Name_Buffer (1 .. Name_Len));\n+            end if;\n+\n+            Set_Associative_Array_Index_Of (Attribute, In_Tree, Name_Find);\n             Scan (In_Tree); --  past the literal string index\n \n             if Token = Tok_At then\n@@ -996,6 +1013,10 @@ package body Prj.Dect is\n       end if;\n \n       if Token = Tok_Renames then\n+         if In_Configuration then\n+            Error_Msg\n+              (\"no package renames in configuration projects\", Token_Ptr);\n+         end if;\n \n          --  Scan past \"renames\"\n \n@@ -1130,7 +1151,7 @@ package body Prj.Dect is\n            and then Token_Name /= Name_Of (Package_Declaration, In_Tree)\n          then\n             Error_Msg_Name_1 := Name_Of (Package_Declaration, In_Tree);\n-            Error_Msg (\"expected %\", Token_Ptr);\n+            Error_Msg (\"expected %%\", Token_Ptr);\n          end if;\n \n          if Token /= Tok_Semicolon then\n@@ -1251,13 +1272,13 @@ package body Prj.Dect is\n       Current_Package : Project_Node_Id)\n    is\n       Expression_Location      : Source_Ptr;\n-      String_Type_Name         : Name_Id          := No_Name;\n-      Project_String_Type_Name : Name_Id          := No_Name;\n-      Type_Location            : Source_Ptr       := No_Location;\n-      Project_Location         : Source_Ptr       := No_Location;\n-      Expression               : Project_Node_Id  := Empty_Node;\n+      String_Type_Name         : Name_Id := No_Name;\n+      Project_String_Type_Name : Name_Id := No_Name;\n+      Type_Location            : Source_Ptr := No_Location;\n+      Project_Location         : Source_Ptr := No_Location;\n+      Expression               : Project_Node_Id := Empty_Node;\n       Variable_Name            : constant Name_Id := Token_Name;\n-      OK                       : Boolean          := True;\n+      OK                       : Boolean := True;\n \n    begin\n       Variable :="}, {"sha": "80d1b9f80c591c0dee41034854709fcaddcb18d5", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 294, "deletions": 134, "changes": 428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -35,15 +35,16 @@ with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n package body Prj.Env is\n \n    Current_Source_Path_File : Path_Name_Type := No_Path;\n-   --  Current value of project source path file env var. Used to avoid setting\n-   --  the env var to the same value.\n+   --  Current value of project source path file env var.\n+   --  Used to avoid setting the env var to the same value.\n \n    Current_Object_Path_File : Path_Name_Type := No_Path;\n-   --  Current value of project object path file env var. Used to avoid setting\n-   --  the env var to the same value.\n+   --  Current value of project object path file env var.\n+   --  Used to avoid setting the env var to the same value.\n \n    Ada_Path_Buffer : String_Access := new String (1 .. 1024);\n-   --  buffer where values for ADA_INCLUDE_PATH and ADA_OBJECTS_PATH are stored\n+   --  A buffer where values for ADA_INCLUDE_PATH\n+   --  and ADA_OBJECTS_PATH are stored.\n \n    Ada_Path_Length : Natural := 0;\n    --  Index of the last valid character in Ada_Path_Buffer\n@@ -69,13 +70,13 @@ package body Prj.Env is\n    -----------------------\n \n    function Body_Path_Name_Of\n-     (Unit    : Unit_Id;\n+     (Unit    : Unit_Index;\n       In_Tree : Project_Tree_Ref) return String;\n    --  Returns the path name of the body of a unit.\n    --  Compute it first, if necessary.\n \n    function Spec_Path_Name_Of\n-     (Unit    : Unit_Id;\n+     (Unit    : Unit_Index;\n       In_Tree : Project_Tree_Ref) return String;\n    --  Returns the path name of the spec of a unit.\n    --  Compute it first, if necessary.\n@@ -88,13 +89,14 @@ package body Prj.Env is\n \n    procedure Add_To_Path (Dir : String);\n    --  If Dir is not already in the global variable Ada_Path_Buffer, add it.\n-   --  Increment Ada_Path_Length. If Ada_Path_Length /= 0, prepend a\n-   --  Path_Separator character to Path.\n+   --  Increment Ada_Path_Length.\n+   --  If Ada_Path_Length /= 0, prepend a Path_Separator character to\n+   --  Path.\n \n    procedure Add_To_Source_Path\n      (Source_Dirs : String_List_Id; In_Tree : Project_Tree_Ref);\n-   --  Add to Ada_Path_B all the source directories in string list Source_Dirs,\n-   --  if any. Increment Ada_Path_Length.\n+   --  Add to Ada_Path_B all the source directories in string list\n+   --  Source_Dirs, if any. Increment Ada_Path_Length.\n \n    procedure Add_To_Object_Path\n      (Object_Dir : Path_Name_Type;\n@@ -105,13 +107,6 @@ package body Prj.Env is\n    function Contains_ALI_Files (Dir : Path_Name_Type) return Boolean;\n    --  Return True if there is at least one ALI file in the directory Dir\n \n-   procedure Create_New_Path_File\n-     (In_Tree   : Project_Tree_Ref;\n-      Path_FD   : out File_Descriptor;\n-      Path_Name : out Path_Name_Type);\n-   --  Create a new temporary path file. Get the file name in Path_Name. The\n-   --  name is normally obtained by increasing Temp_Path_File_Name by 1.\n-\n    procedure Set_Path_File_Var (Name : String; Value : String);\n    --  Call Setenv, after calling To_Host_File_Spec\n \n@@ -329,8 +324,7 @@ package body Prj.Env is\n    ------------------------\n \n    procedure Add_To_Object_Path\n-     (Object_Dir : Path_Name_Type;\n-      In_Tree    : Project_Tree_Ref)\n+     (Object_Dir : Path_Name_Type; In_Tree : Project_Tree_Ref)\n    is\n    begin\n       --  Check if the directory is already in the table\n@@ -491,7 +485,7 @@ package body Prj.Env is\n             --  If it is already, no need to add it\n \n             if In_Tree.Private_Part.Source_Paths.Table (Index) =\n-                        File_Name_Type (Source_Dir.Value)\n+                        Source_Dir.Value\n             then\n                Add_It := False;\n                exit;\n@@ -503,7 +497,7 @@ package body Prj.Env is\n               (In_Tree.Private_Part.Source_Paths);\n             In_Tree.Private_Part.Source_Paths.Table\n               (Source_Path_Table.Last (In_Tree.Private_Part.Source_Paths)) :=\n-                 File_Name_Type (Source_Dir.Value);\n+              Source_Dir.Value;\n          end if;\n \n          --  Next source directory\n@@ -517,26 +511,27 @@ package body Prj.Env is\n    -----------------------\n \n    function Body_Path_Name_Of\n-     (Unit : Unit_Id; In_Tree : Project_Tree_Ref) return String\n+     (Unit    : Unit_Index;\n+      In_Tree : Project_Tree_Ref) return String\n    is\n       Data : Unit_Data := In_Tree.Units.Table (Unit);\n \n    begin\n       --  If we don't know the path name of the body of this unit,\n       --  we compute it, and we store it.\n \n-      if Data.File_Names (Body_Part).Path = No_File then\n+      if Data.File_Names (Body_Part).Path = No_Path then\n          declare\n             Current_Source : String_List_Id :=\n               In_Tree.Projects.Table\n-                (Data.File_Names (Body_Part).Project).Sources;\n+                (Data.File_Names (Body_Part).Project).Ada_Sources;\n             Path : GNAT.OS_Lib.String_Access;\n \n          begin\n             --  By default, put the file name\n \n             Data.File_Names (Body_Part).Path :=\n-              Data.File_Names (Body_Part).Name;\n+              Path_Name_Type (Data.File_Names (Body_Part).Name);\n \n             --  For each source directory\n \n@@ -581,7 +576,7 @@ package body Prj.Env is\n    function Contains_ALI_Files (Dir : Path_Name_Type) return Boolean is\n       Dir_Name : constant String := Get_Name_String (Dir);\n       Direct : Dir_Type;\n-      Name   : String (1 .. 1_000); -- what is this magic constant 1000 ???\n+      Name   : String (1 .. 1_000);\n       Last   : Natural;\n       Result : Boolean := False;\n \n@@ -629,7 +624,7 @@ package body Prj.Env is\n       File_Name : Path_Name_Type  := No_Path;\n       File      : File_Descriptor := Invalid_FD;\n \n-      Current_Unit : Unit_Id := Unit_Table.First;\n+      Current_Unit : Unit_Index := Unit_Table.First;\n \n       First_Project : Project_List := Empty_Project_List;\n \n@@ -731,7 +726,7 @@ package body Prj.Env is\n                  (File, \"pragma Source_File_Name_Project\");\n                Put_Line\n                  (File, \"  (Spec_File_Name  => \"\"*\" &\n-                  Namet.Get_Name_String (Data.Naming.Ada_Spec_Suffix) &\n+                  Spec_Suffix_Of (In_Tree, \"ada\", Data.Naming) &\n                   \"\"\",\");\n                Put_Line\n                  (File, \"   Casing          => \" &\n@@ -747,7 +742,7 @@ package body Prj.Env is\n                  (File, \"pragma Source_File_Name_Project\");\n                Put_Line\n                  (File, \"  (Body_File_Name  => \"\"*\" &\n-                  Namet.Get_Name_String (Data.Naming.Ada_Body_Suffix) &\n+                  Body_Suffix_Of (In_Tree, \"ada\", Data.Naming) &\n                   \"\"\",\");\n                Put_Line\n                  (File, \"   Casing          => \" &\n@@ -759,8 +754,8 @@ package body Prj.Env is\n \n                --  and maybe separate\n \n-               if\n-                 Data.Naming.Ada_Body_Suffix /= Data.Naming.Separate_Suffix\n+               if Body_Suffix_Of (In_Tree, \"ada\", Data.Naming) /=\n+                  Get_Name_String (Data.Naming.Separate_Suffix)\n                then\n                   Put_Line\n                     (File, \"pragma Source_File_Name_Project\");\n@@ -810,10 +805,15 @@ package body Prj.Env is\n             if File = Invalid_FD then\n                Prj.Com.Fail\n                  (\"unable to create temporary configuration pragmas file\");\n-            elsif Opt.Verbose_Mode then\n-               Write_Str (\"Creating temp file \"\"\");\n-               Write_Str (Get_Name_String (File_Name));\n-               Write_Line (\"\"\"\");\n+\n+            else\n+               Record_Temp_File (File_Name);\n+\n+               if Opt.Verbose_Mode then\n+                  Write_Str (\"Creating temp file \"\"\");\n+                  Write_Str (Get_Name_String (File_Name));\n+                  Write_Line (\"\"\"\");\n+               end if;\n             end if;\n          end if;\n       end Check_Temp_File;\n@@ -1117,10 +1117,14 @@ package body Prj.Env is\n       if File = Invalid_FD then\n          Prj.Com.Fail (\"unable to create temporary mapping file\");\n \n-      elsif Opt.Verbose_Mode then\n-         Write_Str (\"Creating temp mapping file \"\"\");\n-         Write_Str (Get_Name_String (Name));\n-         Write_Line (\"\"\"\");\n+      else\n+         Record_Temp_File (Name);\n+\n+         if Opt.Verbose_Mode then\n+            Write_Str (\"Creating temp mapping file \"\"\");\n+            Write_Str (Get_Name_String (Name));\n+            Write_Line (\"\"\"\");\n+         end if;\n       end if;\n \n       if Fill_Mapping_File then\n@@ -1162,6 +1166,164 @@ package body Prj.Env is\n       end if;\n    end Create_Mapping_File;\n \n+   procedure Create_Mapping_File\n+     (Project  : Project_Id;\n+      Language : Name_Id;\n+      Runtime  : Project_Id;\n+      In_Tree  : Project_Tree_Ref;\n+      Name     : out Path_Name_Type)\n+   is\n+      File : File_Descriptor := Invalid_FD;\n+\n+      Status : Boolean;\n+      --  For call to Close\n+\n+      Present : Project_Flags\n+                 (No_Project .. Project_Table.Last (In_Tree.Projects)) :=\n+                   (others => False);\n+      --  For each project in the closure of Project, the corresponding flag\n+      --  will be set to True.\n+\n+      Source   : Source_Id;\n+      Src_Data : Source_Data;\n+      Suffix   : File_Name_Type;\n+\n+      procedure Put_Name_Buffer;\n+      --  Put the line contained in the Name_Buffer in the mapping file\n+\n+      procedure Recursive_Flag (Prj : Project_Id);\n+      --  Set the flags corresponding to Prj, the projects it imports\n+      --  (directly or indirectly) or extends to True. Call itself recursively.\n+\n+      ---------\n+      -- Put --\n+      ---------\n+\n+      procedure Put_Name_Buffer is\n+         Last : Natural;\n+\n+      begin\n+         Name_Len := Name_Len + 1;\n+         Name_Buffer (Name_Len) := ASCII.LF;\n+         Last := Write (File, Name_Buffer (1)'Address, Name_Len);\n+\n+         if Last /= Name_Len then\n+            Prj.Com.Fail (\"Disk full\");\n+         end if;\n+      end Put_Name_Buffer;\n+\n+      --------------------\n+      -- Recursive_Flag --\n+      --------------------\n+\n+      procedure Recursive_Flag (Prj : Project_Id) is\n+         Imported : Project_List;\n+         Proj     : Project_Id;\n+\n+      begin\n+         --  Nothing to do for non existent or runtime project or project\n+         --  that has already been flagged.\n+\n+         if Prj = No_Project or else Prj = Runtime or else Present (Prj) then\n+            return;\n+         end if;\n+\n+         --  Flag the current project\n+\n+         Present (Prj) := True;\n+         Imported :=\n+           In_Tree.Projects.Table (Prj).Imported_Projects;\n+\n+         --  Call itself for each project directly imported\n+\n+         while Imported /= Empty_Project_List loop\n+            Proj :=\n+              In_Tree.Project_Lists.Table (Imported).Project;\n+            Imported :=\n+              In_Tree.Project_Lists.Table (Imported).Next;\n+            Recursive_Flag (Proj);\n+         end loop;\n+\n+         --  Call itself for an eventual project being extended\n+\n+         Recursive_Flag (In_Tree.Projects.Table (Prj).Extends);\n+      end Recursive_Flag;\n+\n+   --  Start of processing for Create_Mapping_File\n+\n+   begin\n+      --  Flag the necessary projects\n+\n+      Recursive_Flag (Project);\n+\n+      --  Create the temporary file\n+\n+      Tempdir.Create_Temp_File (File, Name => Name);\n+\n+      if File = Invalid_FD then\n+         Prj.Com.Fail (\"unable to create temporary mapping file\");\n+\n+      else\n+         Record_Temp_File (Name);\n+\n+         if Opt.Verbose_Mode then\n+            Write_Str (\"Creating temp mapping file \"\"\");\n+            Write_Str (Get_Name_String (Name));\n+            Write_Line (\"\"\"\");\n+         end if;\n+      end if;\n+\n+      --  For all source of the Language of all projects in the closure\n+\n+      for Proj in Present'Range loop\n+         if Present (Proj) then\n+            Source := In_Tree.Projects.Table (Proj).First_Source;\n+\n+            while Source /= No_Source loop\n+               Src_Data := In_Tree.Sources.Table (Source);\n+\n+               if Src_Data.Language_Name = Language and then\n+                 (not Src_Data.Locally_Removed) and then\n+                 Src_Data.Replaced_By = No_Source\n+               then\n+                  if Src_Data.Unit /= No_Name then\n+                     Get_Name_String (Src_Data.Unit);\n+\n+                     if Src_Data.Kind = Spec then\n+                        Suffix := In_Tree.Languages_Data.Table\n+                          (Src_Data.Language).Config.Mapping_Spec_Suffix;\n+\n+                     else\n+                        Suffix := In_Tree.Languages_Data.Table\n+                          (Src_Data.Language).Config.Mapping_Body_Suffix;\n+                     end if;\n+\n+                     if Suffix /= No_File then\n+                        Add_Str_To_Name_Buffer (Get_Name_String (Suffix));\n+                     end if;\n+\n+                     Put_Name_Buffer;\n+                  end if;\n+\n+                  Get_Name_String (Src_Data.File);\n+                  Put_Name_Buffer;\n+\n+                  Get_Name_String (Src_Data.Path);\n+                  Put_Name_Buffer;\n+               end if;\n+\n+               Source := Src_Data.Next_In_Project;\n+            end loop;\n+         end if;\n+      end loop;\n+\n+      GNAT.OS_Lib.Close (File, Status);\n+\n+      if not Status then\n+         Prj.Com.Fail (\"disk full\");\n+      end if;\n+   end Create_Mapping_File;\n+\n    --------------------------\n    -- Create_New_Path_File --\n    --------------------------\n@@ -1175,9 +1337,10 @@ package body Prj.Env is\n       Tempdir.Create_Temp_File (Path_FD, Path_Name);\n \n       if Path_Name /= No_Path then\n+         Record_Temp_File (Path_Name);\n \n-         --  Record the name, so that the temp path file will be deleted\n-         --  at the end of the program.\n+         --  Record the name, so that the temp path file will be deleted at the\n+         --  end of the program.\n \n          Path_File_Table.Increment_Last (In_Tree.Private_Part.Path_Files);\n          In_Tree.Private_Part.Path_Files.Table\n@@ -1238,17 +1401,17 @@ package body Prj.Env is\n       Original_Name : String := Name;\n \n       Extended_Spec_Name : String :=\n-                             Name & Namet.Get_Name_String\n-                                      (Data.Naming.Ada_Spec_Suffix);\n+                             Name &\n+                             Spec_Suffix_Of (In_Tree, \"ada\", Data.Naming);\n       Extended_Body_Name : String :=\n-                             Name & Namet.Get_Name_String\n-                                      (Data.Naming.Ada_Body_Suffix);\n+                             Name &\n+                             Body_Suffix_Of (In_Tree, \"ada\", Data.Naming);\n \n       Unit : Unit_Data;\n \n-      The_Original_Name : File_Name_Type;\n-      The_Spec_Name     : File_Name_Type;\n-      The_Body_Name     : File_Name_Type;\n+      The_Original_Name : Name_Id;\n+      The_Spec_Name     : Name_Id;\n+      The_Body_Name     : Name_Id;\n \n    begin\n       Canonical_Case_File_Name (Original_Name);\n@@ -1281,9 +1444,9 @@ package body Prj.Env is\n          Write_Eol;\n       end if;\n \n-      --  For extending project, search in the extended project\n-      --  if the source is not found. For non extending projects,\n-      --  this loop will be run only once.\n+      --  For extending project, search in the extended project if the source\n+      --  is not found. For non extending projects, this loop will be run only\n+      --  once.\n \n       loop\n          --  Loop through units\n@@ -1317,9 +1480,9 @@ package body Prj.Env is\n                      --  If it has the name of the original name, return the\n                      --  original name.\n \n-                     if Name_Id (Unit.Name) = Name_Id (The_Original_Name)\n-                        --  Type confusion in above comparison ???\n-                       or else Current_Name = The_Original_Name\n+                     if Unit.Name = The_Original_Name\n+                       or else\n+                         Current_Name = File_Name_Type (The_Original_Name)\n                      then\n                         if Current_Verbosity = High then\n                            Write_Line (\"   OK\");\n@@ -1336,7 +1499,7 @@ package body Prj.Env is\n                         --  If it has the name of the extended body name,\n                         --  return the extended body name\n \n-                     elsif Current_Name = The_Body_Name then\n+                     elsif Current_Name = File_Name_Type (The_Body_Name) then\n                         if Current_Verbosity = High then\n                            Write_Line (\"   OK\");\n                         end if;\n@@ -1380,9 +1543,9 @@ package body Prj.Env is\n \n                      --  If name same as original name, return original name\n \n-                     if Name_Id (Unit.Name) = Name_Id (The_Original_Name)\n-                        --  Type confusion in the above comparison ???\n-                       or else Current_Name = The_Original_Name\n+                     if Unit.Name = The_Original_Name\n+                       or else\n+                         Current_Name = File_Name_Type (The_Original_Name)\n                      then\n                         if Current_Verbosity = High then\n                            Write_Line (\"   OK\");\n@@ -1398,7 +1561,7 @@ package body Prj.Env is\n                         --  If it has the same name as the extended spec name,\n                         --  return the extended spec name.\n \n-                     elsif Current_Name = The_Spec_Name then\n+                     elsif Current_Name = File_Name_Type (The_Spec_Name) then\n                         if Current_Verbosity = High then\n                            Write_Line (\"   OK\");\n                         end if;\n@@ -1446,9 +1609,9 @@ package body Prj.Env is\n       Seen : Project_List := Empty_Project_List;\n \n       procedure Add (Project : Project_Id);\n-      --  Process a project. Remember the processes visited to avoid\n-      --  processing a project twice. Recursively process an eventual\n-      --  extended project, and all imported projects.\n+      --  Process a project. Remember the processes visited to avoid processing\n+      --  a project twice. Recursively process an eventual extended project,\n+      --  and all imported projects.\n \n       ---------\n       -- Add --\n@@ -1464,10 +1627,8 @@ package body Prj.Env is\n          --  for sure we never visited this project.\n \n          if Seen = Empty_Project_List then\n-            Project_List_Table.Increment_Last\n-              (In_Tree.Project_Lists);\n-            Seen :=\n-              Project_List_Table.Last (In_Tree.Project_Lists);\n+            Project_List_Table.Increment_Last (In_Tree.Project_Lists);\n+            Seen := Project_List_Table.Last (In_Tree.Project_Lists);\n             In_Tree.Project_Lists.Table (Seen) :=\n               (Project => Project, Next => Empty_Project_List);\n \n@@ -1497,7 +1658,8 @@ package body Prj.Env is\n                --  This project has never been visited, add it\n                --  to the list.\n \n-               Project_List_Table.Increment_Last (In_Tree.Project_Lists);\n+               Project_List_Table.Increment_Last\n+                 (In_Tree.Project_Lists);\n                In_Tree.Project_Lists.Table (Current).Next :=\n                  Project_List_Table.Last (In_Tree.Project_Lists);\n                In_Tree.Project_Lists.Table\n@@ -1507,8 +1669,7 @@ package body Prj.Env is\n             end;\n          end if;\n \n-         --  If there is an object directory, call Action\n-         --  with its name\n+         --  If there is an object directory, call Action with its name\n \n          if Data.Object_Directory /= No_Path then\n             Get_Name_String (Data.Display_Object_Dir);\n@@ -1532,8 +1693,7 @@ package body Prj.Env is\n    --  Start of processing for For_All_Object_Dirs\n \n    begin\n-      --  Visit this project, and its imported projects,\n-      --  recursively\n+      --  Visit this project, and its imported projects, recursively\n \n       Add (Project);\n    end For_All_Object_Dirs;\n@@ -1549,25 +1709,28 @@ package body Prj.Env is\n       Seen : Project_List := Empty_Project_List;\n \n       procedure Add (Project : Project_Id);\n-      --  Process a project. Remember the processes visited to avoid\n-      --  processing a project twice. Recursively process an eventual\n-      --  extended project, and all imported projects.\n+      --  Process a project. Remember the processes visited to avoid processing\n+      --  a project twice. Recursively process an eventual extended project,\n+      --  and all imported projects.\n \n       ---------\n       -- Add --\n       ---------\n \n       procedure Add (Project : Project_Id) is\n-         Data : constant Project_Data := In_Tree.Projects.Table (Project);\n+         Data : constant Project_Data :=\n+                  In_Tree.Projects.Table (Project);\n          List : Project_List := Data.Imported_Projects;\n \n       begin\n-         --  If the list of visited project is empty, then\n-         --  for sure we never visited this project.\n+         --  If the list of visited project is empty, then for sure we never\n+         --  visited this project.\n \n          if Seen = Empty_Project_List then\n-            Project_List_Table.Increment_Last (In_Tree.Project_Lists);\n-            Seen := Project_List_Table.Last (In_Tree.Project_Lists);\n+            Project_List_Table.Increment_Last\n+              (In_Tree.Project_Lists);\n+            Seen := Project_List_Table.Last\n+                                         (In_Tree.Project_Lists);\n             In_Tree.Project_Lists.Table (Seen) :=\n               (Project => Project, Next => Empty_Project_List);\n \n@@ -1590,18 +1753,19 @@ package body Prj.Env is\n                   exit when\n                     In_Tree.Project_Lists.Table (Current).Next =\n                       Empty_Project_List;\n-\n-                  Current := In_Tree.Project_Lists.Table (Current).Next;\n+                  Current :=\n+                    In_Tree.Project_Lists.Table (Current).Next;\n                end loop;\n \n-               --  This project has never been visited, add it\n-               --  to the list.\n+               --  This project has never been visited, add it to the list\n \n-               Project_List_Table.Increment_Last (In_Tree.Project_Lists);\n+               Project_List_Table.Increment_Last\n+                 (In_Tree.Project_Lists);\n                In_Tree.Project_Lists.Table (Current).Next :=\n                  Project_List_Table.Last (In_Tree.Project_Lists);\n                In_Tree.Project_Lists.Table\n-                 (Project_List_Table.Last (In_Tree.Project_Lists)) :=\n+                 (Project_List_Table.Last\n+                    (In_Tree.Project_Lists)) :=\n                  (Project => Project, Next => Empty_Project_List);\n             end;\n          end if;\n@@ -1614,9 +1778,12 @@ package body Prj.Env is\n             --  If there are Ada sources, call action with the name of every\n             --  source directory.\n \n-            if In_Tree.Projects.Table (Project).Ada_Sources_Present then\n+            if\n+              In_Tree.Projects.Table (Project).Ada_Sources /= Nil_String\n+            then\n                while Current /= Nil_String loop\n-                  The_String := In_Tree.String_Elements.Table (Current);\n+                  The_String :=\n+                    In_Tree.String_Elements.Table (Current);\n                   Action (Get_Name_String (The_String.Display_Value));\n                   Current := The_String.Next;\n                end loop;\n@@ -1653,7 +1820,7 @@ package body Prj.Env is\n      (Source_File_Name : String;\n       In_Tree          : Project_Tree_Ref;\n       Project          : out Project_Id;\n-      Path             : out File_Name_Type)\n+      Path             : out Path_Name_Type)\n    is\n    begin\n       --  Body below could use some comments ???\n@@ -1680,10 +1847,10 @@ package body Prj.Env is\n                  and then\n                    Namet.Get_Name_String\n                      (Unit.File_Names (Specification).Name) = Original_Name)\n-              or else (Unit.File_Names (Specification).Path /= No_File\n+              or else (Unit.File_Names (Specification).Path /= No_Path\n                          and then\n                            Namet.Get_Name_String\n-                             (Unit.File_Names (Specification).Path) =\n+                           (Unit.File_Names (Specification).Path) =\n                                                               Original_Name)\n             then\n                Project := Ultimate_Extension_Of\n@@ -1702,7 +1869,7 @@ package body Prj.Env is\n                     and then\n                       Namet.Get_Name_String\n                         (Unit.File_Names (Body_Part).Name) = Original_Name)\n-              or else (Unit.File_Names (Body_Part).Path /= No_File\n+              or else (Unit.File_Names (Body_Part).Path /= No_Path\n                          and then Namet.Get_Name_String\n                                     (Unit.File_Names (Body_Part).Path) =\n                                                              Original_Name)\n@@ -1723,7 +1890,7 @@ package body Prj.Env is\n       end;\n \n       Project := No_Project;\n-      Path    := No_File;\n+      Path    := No_Path;\n \n       if Current_Verbosity > Default then\n          Write_Str (\"Cannot be found.\");\n@@ -1756,14 +1923,14 @@ package body Prj.Env is\n       Original_Name : String := Name;\n \n       Extended_Spec_Name : String :=\n-                             Name & Namet.Get_Name_String\n-                                     (Data.Naming.Ada_Spec_Suffix);\n+                             Name &\n+                             Spec_Suffix_Of (In_Tree, \"ada\", Data.Naming);\n       Extended_Body_Name : String :=\n-                             Name & Namet.Get_Name_String\n-                                     (Data.Naming.Ada_Body_Suffix);\n+                             Name &\n+                             Body_Suffix_Of (In_Tree, \"ada\", Data.Naming);\n \n-      First   : Unit_Id;\n-      Current : Unit_Id;\n+      First   : Unit_Index := Unit_Table.First;\n+      Current : Unit_Index;\n       Unit    : Unit_Data;\n \n    begin\n@@ -1786,7 +1953,6 @@ package body Prj.Env is\n          Write_Eol;\n       end if;\n \n-      First := Unit_Table.First;\n       while First <= Unit_Table.Last (In_Tree.Units)\n         and then In_Tree.Units.Table\n                    (First).File_Names (Body_Part).Project /= Project\n@@ -1947,14 +2113,14 @@ package body Prj.Env is\n       Original_Name : String := Name;\n \n       Data   : constant Project_Data :=\n-                 In_Tree.Projects.Table (Main_Project);\n+        In_Tree.Projects.Table (Main_Project);\n \n       Extended_Spec_Name : String :=\n-                             Name & Namet.Get_Name_String\n-                                      (Data.Naming.Ada_Spec_Suffix);\n+                             Name &\n+                             Spec_Suffix_Of (In_Tree, \"ada\", Data.Naming);\n       Extended_Body_Name : String :=\n-                             Name & Namet.Get_Name_String\n-                                      (Data.Naming.Ada_Body_Suffix);\n+                             Name &\n+                             Body_Suffix_Of (In_Tree, \"ada\", Data.Naming);\n \n       Unit : Unit_Data;\n \n@@ -1963,8 +2129,6 @@ package body Prj.Env is\n       The_Spec_Name     : File_Name_Type;\n       The_Body_Name     : File_Name_Type;\n \n-      --  Confusion here between unit names/file names, See ??? comments below\n-\n    begin\n       Canonical_Case_File_Name (Original_Name);\n       Name_Len := Original_Name'Length;\n@@ -1997,7 +2161,7 @@ package body Prj.Env is\n             --  If it has the name of the original name or the body name,\n             --  we have found the project.\n \n-            if Name_Id (Unit.Name) = Name_Id (The_Original_Name) -- ???\n+            if Unit.Name = Name_Id (The_Original_Name)\n               or else Current_Name = The_Original_Name\n               or else Current_Name = The_Body_Name\n             then\n@@ -2015,7 +2179,7 @@ package body Prj.Env is\n             --  If name same as the original name, or the spec name, we have\n             --  found the project.\n \n-            if Name_Id (Unit.Name) = Name_Id (The_Original_Name) -- ???\n+            if Unit.Name = Name_Id (The_Original_Name)\n               or else Current_Name = The_Original_Name\n               or else Current_Name = The_Spec_Name\n             then\n@@ -2092,11 +2256,11 @@ package body Prj.Env is\n                begin\n                   if Process_Source_Dirs then\n \n-                     --  Add to path all source directories of this project\n-                     --  if there are Ada sources.\n+                     --  Add to path all source directories of this project if\n+                     --  there are Ada sources.\n \n-                     if In_Tree.Projects.Table\n-                          (Project).Ada_Sources_Present\n+                     if In_Tree.Projects.Table (Project).Ada_Sources /=\n+                        Nil_String\n                      then\n                         Add_To_Source_Path (Data.Source_Dirs, In_Tree);\n                      end if;\n@@ -2105,19 +2269,19 @@ package body Prj.Env is\n                   if Process_Object_Dirs then\n \n                      --  Add to path the object directory of this project\n-                     --  except if we don't include library project and\n-                     --  this is a library project.\n+                     --  except if we don't include library project and this\n+                     --  is a library project.\n \n                      if (Data.Library and then Including_Libraries)\n                        or else\n                          (Data.Object_Directory /= No_Path\n                           and then\n                             (not Including_Libraries or else not Data.Library))\n                      then\n-                        --  For a library project, add library ALI directory if\n-                        --  there is no object directory or if the library ALI\n-                        --  directory contains ALI files, otherwise add the\n-                        --  object directory.\n+                        --  For a library project, add the library ALI\n+                        --  directory if there is no object directory or\n+                        --  if the library ALI directory contains ALI files;\n+                        --  otherwise add the object directory.\n \n                         if Data.Library then\n                            if Data.Object_Directory = No_Path\n@@ -2131,21 +2295,17 @@ package body Prj.Env is\n                            end if;\n \n                         --  For a non-library project, add the object\n-                        --  directory, if it is not a virtual project, and\n-                        --  if there are Ada sources or if the project is an\n+                        --  directory, if it is not a virtual project, and if\n+                        --  there are Ada sources or if the project is an\n                         --  extending project. if There Are No Ada sources,\n-                        --  adding the object directory could disrupt\n-                        --  the order of the object dirs in the path.\n+                        --  adding the object directory could disrupt the order\n+                        --  of the object dirs in the path.\n \n                         elsif not Data.Virtual\n-                          and then (In_Tree.Projects.Table\n-                                      (Project).Ada_Sources_Present\n-                                    or else\n-                                      (Data.Extends /= No_Project\n-                                       and then\n-                                       Data.Object_Directory /= No_Path))\n+                          and then There_Are_Ada_Sources (In_Tree, Project)\n                         then\n-                           Add_To_Object_Path (Data.Object_Directory, In_Tree);\n+                           Add_To_Object_Path\n+                             (Data.Object_Directory, In_Tree);\n                         end if;\n                      end if;\n                   end if;\n@@ -2347,21 +2507,21 @@ package body Prj.Env is\n    -----------------------\n \n    function Spec_Path_Name_Of\n-     (Unit : Unit_Id; In_Tree : Project_Tree_Ref) return String\n+     (Unit : Unit_Index; In_Tree : Project_Tree_Ref) return String\n    is\n       Data : Unit_Data := In_Tree.Units.Table (Unit);\n \n    begin\n-      if Data.File_Names (Specification).Path = No_File then\n+      if Data.File_Names (Specification).Path = No_Path then\n          declare\n             Current_Source : String_List_Id :=\n               In_Tree.Projects.Table\n-                (Data.File_Names (Specification).Project).Sources;\n+                (Data.File_Names (Specification).Project).Ada_Sources;\n             Path : GNAT.OS_Lib.String_Access;\n \n          begin\n             Data.File_Names (Specification).Path :=\n-              Data.File_Names (Specification).Name;\n+              Path_Name_Type (Data.File_Names (Specification).Name);\n \n             while Current_Source /= Nil_String loop\n                Path := Locate_Regular_File"}, {"sha": "74bb9fcbc75d33b2ba1ee09b2b6f9201c0561ec4", "filename": "gcc/ada/prj-env.ads", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-env.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-env.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.ads?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -44,6 +44,16 @@ package Prj.Env is\n    --  in the closure of immediate sources of Project, put the mapping of\n    --  its spec and or body to its file name and path name in this file.\n \n+   procedure Create_Mapping_File\n+     (Project  : Project_Id;\n+      Language : Name_Id;\n+      Runtime  : Project_Id;\n+      In_Tree  : Project_Tree_Ref;\n+      Name     : out Path_Name_Type);\n+   --  Create a temporary mapping file for project Project. For each source or\n+   --  template of Language in the of Project, put the mapping of its file\n+   --  name and path name in this file.\n+\n    procedure Set_Mapping_File_Initial_State_To_Empty;\n    --  When creating a mapping file, create an empty map. This case occurs\n    --  when run time source files are found in the project files.\n@@ -61,6 +71,14 @@ package Prj.Env is\n    --  a temporary file that contains all configuration pragmas, and specify\n    --  the configuration pragmas file in the project data.\n \n+   procedure Create_New_Path_File\n+     (In_Tree   : Project_Tree_Ref;\n+      Path_FD   : out File_Descriptor;\n+      Path_Name : out Path_Name_Type);\n+   --  Create a new temporary path file. Get the file name in Path_Name.\n+   --  The name is normally obtained by increasing the number in\n+   --  Temp_Path_File_Name by 1.\n+\n    function Ada_Include_Path\n      (Project : Project_Id;\n       In_Tree : Project_Tree_Ref) return String_Access;\n@@ -135,7 +153,7 @@ package Prj.Env is\n      (Source_File_Name : String;\n       In_Tree          : Project_Tree_Ref;\n       Project          : out Project_Id;\n-      Path             : out File_Name_Type);\n+      Path             : out Path_Name_Type);\n    --  Returns the project of a source and its path in displayable form\n \n    generic"}, {"sha": "557f11c808755aac0ac21d7dbfec7fc9fcdee96c", "filename": "gcc/ada/prj-ext.adb", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-ext.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-ext.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-ext.adb?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -29,14 +29,14 @@ with Makeutl;  use Makeutl;\n with Output;   use Output;\n with Osint;    use Osint;\n with Sdefault;\n+with Table;\n \n with GNAT.HTable;\n \n package body Prj.Ext is\n \n-   Gpr_Project_Path : constant String := \"GPR_PROJECT_PATH\";\n    Ada_Project_Path : constant String := \"ADA_PROJECT_PATH\";\n-   --  Name of the env. variables that contain path name(s) of directories\n+   --  Name of alternate env. variable that contain path name(s) of directories\n    --  where project files may reside. GPR_PROJECT_PATH has precedence over\n    --  ADA_PROJECT_PATH.\n \n@@ -67,6 +67,7 @@ package body Prj.Ext is\n    --  first for external reference in this table, before checking the\n    --  environment. Htable is emptied (reset) by procedure Reset.\n \n+   ---------\n    package Search_Directories is new Table.Table\n      (Table_Component_Type => Name_Id,\n       Table_Index_Type     => Natural,\n@@ -76,7 +77,6 @@ package body Prj.Ext is\n       Table_Name           => \"Prj.Ext.Search_Directories\");\n    --  The table for the directories specified with -aP switches\n \n-   ---------\n    -- Add --\n    ---------\n \n@@ -97,6 +97,7 @@ package body Prj.Ext is\n       Htable.Set (The_Key, The_Value);\n    end Add;\n \n+   -----------\n    ----------------------------------\n    -- Add_Search_Project_Directory --\n    ----------------------------------\n@@ -108,7 +109,6 @@ package body Prj.Ext is\n       Search_Directories.Append (Name_Find);\n    end Add_Search_Project_Directory;\n \n-   -----------\n    -- Check --\n    -----------\n \n@@ -140,28 +140,22 @@ package body Prj.Ext is\n       Last            : Positive;\n       New_Len         : Positive;\n       New_Last        : Positive;\n-      Prj_Path        : String_Access := null;\n+      Prj_Path        : String_Access := Gpr_Prj_Path;\n \n    begin\n-      if Gpr_Prj_Path.all /= \"\" then\n-         if Hostparm.OpenVMS then\n-            Prj_Path := To_Canonical_Path_Spec (\"GPR_PROJECT_PATH:\");\n-         else\n-            Prj_Path := To_Canonical_Path_Spec (Gpr_Prj_Path.all);\n-         end if;\n+      if Get_Mode = Ada_Only then\n+         if Gpr_Prj_Path.all /= \"\" then\n \n-         --  Warn if both environment variables are defined\n+            --  Warn if both environment variables are defined\n \n-         if Ada_Prj_Path.all /= \"\" then\n-            Write_Line (\"Warning: ADA_PROJECT_PATH is not taken into account\");\n-            Write_Line (\"         when GPR_PROJECT_PATH is defined\");\n-         end if;\n+            if Ada_Prj_Path.all /= \"\" then\n+               Write_Line\n+                 (\"Warning: ADA_PROJECT_PATH is not taken into account\");\n+               Write_Line (\"         when GPR_PROJECT_PATH is defined\");\n+            end if;\n \n-      elsif Ada_Prj_Path.all /= \"\" then\n-         if Hostparm.OpenVMS then\n-            Prj_Path := To_Canonical_Path_Spec (\"ADA_PROJECT_PATH:\");\n          else\n-            Prj_Path := To_Canonical_Path_Spec (Ada_Prj_Path.all);\n+            Prj_Path := Ada_Prj_Path;\n          end if;\n       end if;\n \n@@ -179,9 +173,9 @@ package body Prj.Ext is\n            (Get_Name_String (Search_Directories.Table (J)));\n       end loop;\n \n-      --  If environment variable is defined, add its content\n+      --  If environment variable is defined and not empty, add its content\n \n-      if Prj_Path /= null then\n+      if Prj_Path.all /= \"\" then\n          Name_Len := Name_Len + 1;\n          Name_Buffer (Name_Len) := Path_Separator;\n \n@@ -223,6 +217,11 @@ package body Prj.Ext is\n \n             Name_Len := Name_Len - No_Project_Default_Dir'Length - 1;\n \n+            --  After removing the '-', go back one character to get the next\n+            --  directory corectly.\n+\n+            Last := Last - 1;\n+\n          elsif not Hostparm.OpenVMS\n            or else not Is_Absolute_Path (Name_Buffer (First .. Last))\n          then\n@@ -264,9 +263,19 @@ package body Prj.Ext is\n                Prefix := new String'(Executable_Prefix_Path);\n \n                if Prefix.all /= \"\" then\n-                  Current_Project_Path :=\n-                    new String'(Name_Buffer (1 .. Name_Len) & Path_Separator &\n-                                Prefix.all & Directory_Separator & \"gnat\");\n+                  if Get_Mode = Ada_Only then\n+                     Current_Project_Path :=\n+                       new String'(Name_Buffer (1 .. Name_Len) &\n+                                   Path_Separator &\n+                                   Prefix.all & Directory_Separator & \"gnat\");\n+\n+                  else\n+                     Current_Project_Path :=\n+                       new String'(Name_Buffer (1 .. Name_Len) &\n+                                   Path_Separator &\n+                                   Prefix.all & Directory_Separator &\n+                                   \"share\" & Directory_Separator & \"gpr\");\n+                  end if;\n                end if;\n \n             else\n@@ -278,7 +287,9 @@ package body Prj.Ext is\n                              \"..\" & Directory_Separator & \"gnat\");\n             end if;\n          end;\n-      else\n+      end if;\n+\n+      if Current_Project_Path = null then\n          Current_Project_Path := new String'(Name_Buffer (1 .. Name_Len));\n       end if;\n    end Initialize_Project_Path;"}, {"sha": "551984be4d1c7466ea5c70892f638a1ef61080d7", "filename": "gcc/ada/prj-ext.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-ext.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-ext.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-ext.ads?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -29,6 +29,10 @@\n \n package Prj.Ext is\n \n+   Gpr_Project_Path : constant String := \"GPR_PROJECT_PATH\";\n+   --  Name of primary env. variable that contain path name(s) of directories\n+   --  where project files may reside.\n+\n    procedure Add_Search_Project_Directory (Path : String);\n    --  Add a directory to the project path. Directories added with this\n    --  procedure are added in order after the current directory and before"}, {"sha": "b742c01b331b95bb003a078daded942c4f08264a", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 3355, "deletions": 678, "changes": 4033, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=ede007da18026bf6153ce5d86de81e147760b763"}, {"sha": "59ba9c8b7797d6c8a3d73a264b49062b3e962738", "filename": "gcc/ada/prj-nmsc.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-nmsc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-nmsc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.ads?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2000-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -59,7 +59,7 @@ private package Prj.Nmsc is\n    --  still valid if they point to a file which is outside of the project),\n    --  and that no directory has a name which is a valid source name.\n    --\n-   --  When_No_Ada_Sources indicates what should be done when no Ada sources\n-   --  are found in a project where Ada is a language.\n+   --  When_No_Sources indicates what should be done when no sources of a\n+   --  language are found in a project where this language is declared.\n \n end Prj.Nmsc;"}, {"sha": "e09ffc83b890eb620bd690e0b8a3286fe6489881", "filename": "gcc/ada/prj-pars.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-pars.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-pars.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pars.adb?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,6 +32,7 @@ with Prj.Err;  use Prj.Err;\n with Prj.Part;\n with Prj.Proc;\n with Prj.Tree; use Prj.Tree;\n+with Sinput.P;\n \n package body Prj.Pars is\n \n@@ -44,7 +45,8 @@ package body Prj.Pars is\n       Project           : out Project_Id;\n       Project_File_Name : String;\n       Packages_To_Check : String_List_Access := All_Packages;\n-      When_No_Sources   : Error_Warning := Error)\n+      When_No_Sources   : Error_Warning := Error;\n+      Reset_Tree        : Boolean := True)\n    is\n       Project_Node_Tree : constant Project_Node_Tree_Ref :=\n                             new Project_Node_Tree_Data;\n@@ -57,6 +59,7 @@ package body Prj.Pars is\n \n       --  Parse the main project file into a tree\n \n+      Sinput.P.Reset_First;\n       Prj.Part.Parse\n         (In_Tree                => Project_Node_Tree,\n          Project                => Project_Node,\n@@ -75,7 +78,8 @@ package body Prj.Pars is\n             From_Project_Node_Tree => Project_Node_Tree,\n             Report_Error           => null,\n             Follow_Links           => Opt.Follow_Links,\n-            When_No_Sources        => When_No_Sources);\n+            When_No_Sources        => When_No_Sources,\n+            Reset_Tree             => Reset_Tree);\n          Prj.Err.Finalize;\n \n          if not Success then"}, {"sha": "840b121057fae0dad8459db18e75b1e6710da9b8", "filename": "gcc/ada/prj-pars.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-pars.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-pars.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pars.ads?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2000-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,7 +36,8 @@ package Prj.Pars is\n       Project           : out Project_Id;\n       Project_File_Name : String;\n       Packages_To_Check : String_List_Access := All_Packages;\n-      When_No_Sources   : Error_Warning := Error);\n+      When_No_Sources   : Error_Warning := Error;\n+      Reset_Tree        : Boolean := True);\n    --  Parse a project files and all its imported project files, in the\n    --  project tree In_Tree.\n    --\n@@ -50,5 +51,8 @@ package Prj.Pars is\n    --\n    --  When_No_Sources indicates what should be done when no sources\n    --  are found in a project for a specified or implied language.\n+   --\n+   --  When Reset_Tree is True, all the project data are removed from the\n+   --  project table before processing.\n \n end Prj.Pars;"}, {"sha": "19e41b7ed37244543ee3e508d941c6d686e3f0d8", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 115, "deletions": 94, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -37,24 +37,19 @@ with Sinput.P; use Sinput.P;\n with Snames;\n with Table;\n \n-with Ada.Characters.Handling;   use Ada.Characters.Handling;\n-with Ada.Exceptions;            use Ada.Exceptions;\n+with Ada.Characters.Handling;    use Ada.Characters.Handling;\n+with Ada.Exceptions;             use Ada.Exceptions;\n \n-with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n+with GNAT.Directory_Operations;  use GNAT.Directory_Operations;\n \n-with System.HTable;             use System.HTable;\n+with System.HTable;              use System.HTable;\n \n package body Prj.Part is\n \n    Buffer      : String_Access;\n    Buffer_Last : Natural := 0;\n \n-   Dir_Sep : Character renames GNAT.OS_Lib.Directory_Separator;\n-\n-   type Extension_Origin is (None, Extending_Simple, Extending_All);\n-   --  Type of parameter From_Extended for procedures Parse_Single_Project and\n-   --  Post_Parse_Context_Clause. Extending_All means that we are parsing the\n-   --  tree rooted at an extending all project.\n+   Dir_Sep  : Character renames GNAT.OS_Lib.Directory_Separator;\n \n    ------------------------------------\n    -- Local Packages and Subprograms --\n@@ -64,7 +59,7 @@ package body Prj.Part is\n    No_With : constant With_Id := 0;\n \n    type With_Record is record\n-      Path         : File_Name_Type;\n+      Path         : Path_Name_Type;\n       Location     : Source_Ptr;\n       Limited_With : Boolean;\n       Node         : Project_Node_Id;\n@@ -88,7 +83,6 @@ package body Prj.Part is\n       Canonical_Path_Name : Path_Name_Type;\n       Id                  : Project_Node_Id;\n    end record;\n-   --  Needs a comment ???\n \n    package Project_Stack is new Table.Table\n      (Table_Component_Type => Names_And_Id,\n@@ -159,28 +153,13 @@ package body Prj.Part is\n       Project_Directory : Path_Name_Type;\n       From_Extended     : Extension_Origin;\n       In_Limited        : Boolean;\n-      Packages_To_Check : String_List_Access);\n+      Packages_To_Check : String_List_Access;\n+      Depth             : Natural);\n    --  Parse the imported projects that have been stored in table Withs,\n    --  if any. From_Extended is used for the call to Parse_Single_Project\n    --  below. When In_Limited is True, the importing path includes at least\n    --  one \"limited with\".\n \n-   procedure Parse_Single_Project\n-     (In_Tree           : Project_Node_Tree_Ref;\n-      Project           : out Project_Node_Id;\n-      Extends_All       : out Boolean;\n-      Path_Name         : String;\n-      Extended          : Boolean;\n-      From_Extended     : Extension_Origin;\n-      In_Limited        : Boolean;\n-      Packages_To_Check : String_List_Access);\n-   --  Parse a project file.\n-   --  Recursive procedure: it calls itself for imported and extended\n-   --  projects. When From_Extended is not None, if the project has already\n-   --  been parsed and is an extended project A, return the ultimate\n-   --  (not extended) project that extends A. When In_Limited is True,\n-   --  the importing path includes at least one \"limited with\".\n-\n    function Project_Path_Name_Of\n      (Project_File_Name : String;\n       Directory         : String) return String;\n@@ -193,7 +172,7 @@ package body Prj.Part is\n    --  This includes the directory separator as the last character.\n    --  Returns \"./\" if Path_Name contains no directory separator.\n \n-   function Project_Name_From (Path_Name : String) return File_Name_Type;\n+   function Project_Name_From (Path_Name : String) return Name_Id;\n    --  Returns the name of the project that corresponds to its path name.\n    --  Returns No_Name if the path name is invalid, because the corresponding\n    --  project name does not have the syntax of an ada identifier.\n@@ -349,7 +328,8 @@ package body Prj.Part is\n    ----------------------------\n \n    function Immediate_Directory_Of\n-     (Path_Name : Path_Name_Type) return Path_Name_Type\n+     (Path_Name : Path_Name_Type)\n+      return Path_Name_Type\n    is\n    begin\n       Get_Name_String (Path_Name);\n@@ -474,7 +454,7 @@ package body Prj.Part is\n       Project := Empty_Node;\n \n       if Current_Verbosity >= Medium then\n-         Write_Str (\"ADA_PROJECT_PATH=\"\"\");\n+         Write_Str (\"GPR_PROJECT_PATH=\"\"\");\n          Write_Str (Project_Path);\n          Write_Line (\"\"\"\");\n       end if;\n@@ -508,7 +488,8 @@ package body Prj.Part is\n             Extended          => False,\n             From_Extended     => None,\n             In_Limited        => False,\n-            Packages_To_Check => Packages_To_Check);\n+            Packages_To_Check => Packages_To_Check,\n+            Depth             => 0);\n \n          --  If Project is an extending-all project, create the eventual\n          --  virtual extending projects and check that there are no illegally\n@@ -640,6 +621,13 @@ package body Prj.Part is\n            Default_Project_Node (Of_Kind => N_With_Clause, In_Tree => In_Tree);\n          Limited_With := Token = Tok_Limited;\n \n+         if In_Configuration then\n+            Error_Msg\n+              (\"configuration project cannot import \" &\n+               \"other configuration projects\",\n+               Token_Ptr);\n+         end if;\n+\n          if Limited_With then\n             Scan (In_Tree);  --  scan past LIMITED\n             Expect (Tok_With, \"WITH\");\n@@ -659,7 +647,7 @@ package body Prj.Part is\n             --  Store path and location in table Withs\n \n             Current_With :=\n-              (Path         => File_Name_Type (Token_Name),\n+              (Path         => Path_Name_Type (Token_Name),\n                Location     => Token_Ptr,\n                Limited_With => Limited_With,\n                Node         => Current_With_Node,\n@@ -714,9 +702,10 @@ package body Prj.Part is\n       Project_Directory : Path_Name_Type;\n       From_Extended     : Extension_Origin;\n       In_Limited        : Boolean;\n-      Packages_To_Check : String_List_Access)\n+      Packages_To_Check : String_List_Access;\n+      Depth             : Natural)\n    is\n-      Current_With_Clause : With_Id;\n+      Current_With_Clause : With_Id := Context_Clause;\n \n       Current_Project  : Project_Node_Id := Empty_Node;\n       Previous_Project : Project_Node_Id := Empty_Node;\n@@ -732,7 +721,6 @@ package body Prj.Part is\n    begin\n       Imported_Projects := Empty_Node;\n \n-      Current_With_Clause := Context_Clause;\n       while Current_With_Clause /= No_With loop\n          Current_With := Withs.Table (Current_With_Clause);\n          Current_With_Clause := Current_With.Next;\n@@ -760,7 +748,8 @@ package body Prj.Part is\n \n                --  The project file cannot be found\n \n-               Error_Msg_File_1 := Current_With.Path;\n+               Error_Msg_File_1 := File_Name_Type (Current_With.Path);\n+\n                Error_Msg (\"unknown project file: {\", Current_With.Location);\n \n                --  If this is not imported by the main project file,\n@@ -837,7 +826,8 @@ package body Prj.Part is\n                      Extended          => False,\n                      From_Extended     => From_Extended,\n                      In_Limited        => Limited_With,\n-                     Packages_To_Check => Packages_To_Check);\n+                     Packages_To_Check => Packages_To_Check,\n+                     Depth             => Depth);\n \n                else\n                   Extends_All := Is_Extending_All (Withed_Project, In_Tree);\n@@ -895,7 +885,8 @@ package body Prj.Part is\n       Extended          : Boolean;\n       From_Extended     : Extension_Origin;\n       In_Limited        : Boolean;\n-      Packages_To_Check : String_List_Access)\n+      Packages_To_Check : String_List_Access;\n+      Depth             : Natural)\n    is\n       Normed_Path_Name    : Path_Name_Type;\n       Canonical_Path_Name : Path_Name_Type;\n@@ -905,14 +896,13 @@ package body Prj.Part is\n \n       Extending : Boolean := False;\n \n-      Extended_Project : Project_Node_Id := Empty_Node;\n+      Extended_Project    : Project_Node_Id := Empty_Node;\n \n       A_Project_Name_And_Node : Tree_Private_Part.Project_Name_And_Node :=\n                                   Tree_Private_Part.Projects_Htable.Get_First\n                                     (In_Tree.Projects_HT);\n \n-      Name_From_Path : constant File_Name_Type :=\n-                         Project_Name_From (Path_Name);\n+      Name_From_Path      : constant Name_Id := Project_Name_From (Path_Name);\n \n       Name_Of_Project : Name_Id := No_Name;\n \n@@ -949,21 +939,21 @@ package body Prj.Part is\n               Project_Stack.Table (Index).Canonical_Path_Name\n          then\n             Error_Msg (\"circular dependency detected\", Token_Ptr);\n-            Error_Msg_File_1 := File_Name_Type (Normed_Path_Name);\n-            Error_Msg (\"\\\\  { is imported by\", Token_Ptr);\n+            Error_Msg_Name_1 := Name_Id (Normed_Path_Name);\n+            Error_Msg (\"\\  %% is imported by\", Token_Ptr);\n \n             for Current in reverse 1 .. Project_Stack.Last loop\n-               Error_Msg_File_1 :=\n-                 File_Name_Type (Project_Stack.Table (Current).Path_Name);\n+               Error_Msg_Name_1 :=\n+                 Name_Id (Project_Stack.Table (Current).Path_Name);\n \n                if Project_Stack.Table (Current).Canonical_Path_Name /=\n                     Canonical_Path_Name\n                then\n                   Error_Msg\n-                    (\"\\\\  { which itself is imported by\", Token_Ptr);\n+                    (\"\\  %% which itself is imported by\", Token_Ptr);\n \n                else\n-                  Error_Msg (\"\\\\  {\", Token_Ptr);\n+                  Error_Msg (\"\\  %%\", Token_Ptr);\n                   exit;\n                end if;\n             end loop;\n@@ -1060,14 +1050,22 @@ package body Prj.Part is\n       Tree.Reset_State;\n       Scan (In_Tree);\n \n-      if Name_From_Path = No_File then\n+      if (not In_Configuration) and then (Name_From_Path = No_Name) then\n \n          --  The project file name is not correct (no or bad extension,\n          --  or not following Ada identifier's syntax).\n \n          Error_Msg_File_1 := File_Name_Type (Canonical_Path_Name);\n-         Error_Msg (\"?{ is not a valid path name for a project file\",\n-                    Token_Ptr);\n+\n+         if In_Configuration then\n+            Error_Msg (\"{ is not a valid path name for a configuration \" &\n+                       \"project file\",\n+                       Token_Ptr);\n+\n+         else\n+            Error_Msg (\"?{ is not a valid path name for a project file\",\n+                       Token_Ptr);\n+         end if;\n       end if;\n \n       if Current_Verbosity >= Medium then\n@@ -1121,7 +1119,7 @@ package body Prj.Part is\n \n          Scan (In_Tree);\n \n-         --  If we have a dot, add a dot the the Buffer and look for the next\n+         --  If we have a dot, add a dot to the Buffer and look for the next\n          --  identifier.\n \n          exit when Token /= Tok_Dot;\n@@ -1136,6 +1134,11 @@ package body Prj.Part is\n \n       if Token = Tok_Extends then\n \n+         if In_Configuration then\n+            Error_Msg\n+              (\"extending configuration project not allowed\", Token_Ptr);\n+         end if;\n+\n          --  Make sure that gnatmake will use mapping files\n \n          Create_Mapping_File := True;\n@@ -1178,17 +1181,27 @@ package body Prj.Part is\n          Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n \n          declare\n-            Expected_Name : constant File_Name_Type := Name_Find;\n+            Expected_Name : constant Name_Id := Name_Find;\n+            Extension     : String_Access;\n \n          begin\n             --  Output a warning if the actual name is not the expected name\n \n-            if Name_From_Path /= No_File\n+            if (not In_Configuration)\n+              and then (Name_From_Path /= No_Name)\n               and then Expected_Name /= Name_From_Path\n             then\n-               Error_Msg_File_1 := Expected_Name;\n-               Error_Msg (\"?file name does not match unit name, \" &\n-                          \"should be `{\" & Project_File_Extension & \"`\",\n+               Error_Msg_Name_1 := Expected_Name;\n+\n+               if In_Configuration then\n+                  Extension := new String'(Config_Project_File_Extension);\n+\n+               else\n+                  Extension := new String'(Project_File_Extension);\n+               end if;\n+\n+               Error_Msg (\"?file name does not match project name, \" &\n+                          \"should be `%%\" & Extension.all & \"`\",\n                           Token_Ptr);\n             end if;\n          end;\n@@ -1217,15 +1230,15 @@ package body Prj.Part is\n                Project_Directory => Project_Directory,\n                From_Extended     => From_Ext,\n                In_Limited        => In_Limited,\n-               Packages_To_Check => Packages_To_Check);\n+               Packages_To_Check => Packages_To_Check,\n+               Depth             => Depth + 1);\n             Set_First_With_Clause_Of (Project, In_Tree, Imported_Projects);\n          end;\n \n          declare\n             Name_And_Node : Tree_Private_Part.Project_Name_And_Node :=\n-                              Tree_Private_Part.Projects_Htable.Get_First\n-                                (In_Tree.Projects_HT);\n-\n+              Tree_Private_Part.Projects_Htable.Get_First\n+                (In_Tree.Projects_HT);\n             Project_Name : Name_Id := Name_And_Node.Name;\n \n          begin\n@@ -1246,10 +1259,10 @@ package body Prj.Part is\n                Error_Msg_Name_1 := Project_Name;\n                Error_Msg\n                  (\"duplicate project name %%\", Location_Of (Project, In_Tree));\n-               Error_Msg_File_1 :=\n-                 File_Name_Type (Path_Name_Of (Name_And_Node.Node, In_Tree));\n+               Error_Msg_Name_1 :=\n+                 Name_Id (Path_Name_Of (Name_And_Node.Node, In_Tree));\n                Error_Msg\n-                 (\"\\already in {\", Location_Of (Project, In_Tree));\n+                 (\"\\already in %%\", Location_Of (Project, In_Tree));\n \n             else\n                --  Otherwise, add the name of the project to the hash table, so\n@@ -1273,7 +1286,9 @@ package body Prj.Part is\n \n          if Token = Tok_String_Literal then\n             Set_Extended_Project_Path_Of\n-              (Project, In_Tree, Path_Name_Type (Token_Name));\n+              (Project,\n+               In_Tree,\n+               Path_Name_Type (Token_Name));\n \n             declare\n                Original_Path_Name : constant String :=\n@@ -1290,23 +1305,24 @@ package body Prj.Part is\n \n                   --  We could not find the project file to extend\n \n-                  Error_Msg_File_1 := File_Name_Type (Token_Name);\n-                  Error_Msg (\"unknown project file: {\", Token_Ptr);\n+                  Error_Msg_Name_1 := Token_Name;\n+\n+                  Error_Msg (\"unknown project file: %%\", Token_Ptr);\n \n                   --  If we are not in the main project file, display the\n                   --  import path.\n \n                   if Project_Stack.Last > 1 then\n-                     Error_Msg_File_1 :=\n-                       File_Name_Type\n+                     Error_Msg_Name_1 :=\n+                       Name_Id\n                          (Project_Stack.Table (Project_Stack.Last).Path_Name);\n-                     Error_Msg (\"\\extended by {\", Token_Ptr);\n+                     Error_Msg (\"\\extended by %%\", Token_Ptr);\n \n                      for Index in reverse 1 .. Project_Stack.Last - 1 loop\n-                        Error_Msg_File_1 :=\n-                          File_Name_Type\n+                        Error_Msg_Name_1 :=\n+                          Name_Id\n                             (Project_Stack.Table (Index).Path_Name);\n-                        Error_Msg (\"\\imported by {\", Token_Ptr);\n+                        Error_Msg (\"\\imported by %%\", Token_Ptr);\n                      end loop;\n                   end if;\n \n@@ -1327,7 +1343,8 @@ package body Prj.Part is\n                         Extended          => True,\n                         From_Extended     => From_Ext,\n                         In_Limited        => In_Limited,\n-                        Packages_To_Check => Packages_To_Check);\n+                        Packages_To_Check => Packages_To_Check,\n+                        Depth             => Depth + 1);\n                   end;\n \n                   --  A project that extends an extending-all project is also\n@@ -1360,9 +1377,8 @@ package body Prj.Part is\n                Imported := Project_Node_Of (With_Clause, In_Tree);\n \n                if Is_Extending_All (With_Clause, In_Tree) then\n-                  Error_Msg_File_1 :=\n-                    File_Name_Type (Name_Of (Imported, In_Tree));\n-                  Error_Msg (\"cannot import extending-all project {\",\n+                  Error_Msg_Name_1 := Name_Of (Imported, In_Tree);\n+                  Error_Msg (\"cannot import extending-all project %%\",\n                              Token_Ptr);\n                   exit With_Clause_Loop;\n                end if;\n@@ -1395,7 +1411,7 @@ package body Prj.Part is\n          Name_Len := Name_Len - 1;\n \n          declare\n-            Parent_Name  : constant File_Name_Type := Name_Find;\n+            Parent_Name  : constant Name_Id := Name_Find;\n             Parent_Found : Boolean := False;\n             With_Clause  : Project_Node_Id :=\n                              First_With_Clause_Of (Project, In_Tree);\n@@ -1405,7 +1421,7 @@ package body Prj.Part is\n \n             if Extended_Project /= Empty_Node then\n                Parent_Found :=\n-                 Name_Of (Extended_Project, In_Tree) = Name_Id (Parent_Name);\n+                 Name_Of (Extended_Project, In_Tree) = Parent_Name;\n             end if;\n \n             --  If the parent project is not the extended project,\n@@ -1414,16 +1430,16 @@ package body Prj.Part is\n             while not Parent_Found and then With_Clause /= Empty_Node loop\n                Parent_Found :=\n                  Name_Of (Project_Node_Of (With_Clause, In_Tree), In_Tree) =\n-                    Name_Id (Parent_Name);\n+                    Parent_Name;\n                With_Clause := Next_With_Clause_Of (With_Clause, In_Tree);\n             end loop;\n \n             --  If the parent project was not found, report an error\n \n             if not Parent_Found then\n                Error_Msg_Name_1 := Name_Of_Project;\n-               Error_Msg_File_1 := Parent_Name;\n-               Error_Msg (\"project %% does not import or extend project {\",\n+               Error_Msg_Name_2 := Parent_Name;\n+               Error_Msg (\"project %% does not import or extend project %%\",\n                           Location_Of (Project, In_Tree));\n             end if;\n          end;\n@@ -1547,7 +1563,7 @@ package body Prj.Part is\n    -- Project_Name_From --\n    -----------------------\n \n-   function Project_Name_From (Path_Name : String) return File_Name_Type is\n+   function Project_Name_From (Path_Name : String) return Name_Id is\n       Canonical : String (1 .. Path_Name'Length) := Path_Name;\n       First : Natural := Canonical'Last;\n       Last  : Natural := First;\n@@ -1563,7 +1579,7 @@ package body Prj.Part is\n       --  If the path name is empty, return No_Name to indicate failure\n \n       if First = 0 then\n-         return No_File;\n+         return No_Name;\n       end if;\n \n       Canonical_Case_File_Name (Canonical);\n@@ -1580,8 +1596,13 @@ package body Prj.Part is\n       --  If we have a dot, check that it is followed by the correct extension\n \n       if First > 0 and then Canonical (First) = '.' then\n-         if Canonical (First .. Last) = Project_File_Extension\n-           and then First /= 1\n+         if ((not In_Configuration) and then\n+             Canonical (First .. Last) = Project_File_Extension and then\n+             First /= 1)\n+            or else\n+            (In_Configuration and then\n+             Canonical (First .. Last) = Config_Project_File_Extension and then\n+             First /= 1)\n          then\n             --  Look for the last directory separator, if any\n \n@@ -1598,21 +1619,21 @@ package body Prj.Part is\n          else\n             --  Not the correct extension, return No_Name to indicate failure\n \n-            return No_File;\n+            return No_Name;\n          end if;\n \n       --  If no dot in the path name, return No_Name to indicate failure\n \n       else\n-         return No_File;\n+         return No_Name;\n       end if;\n \n       First := First + 1;\n \n       --  If the extension is the file name, return No_Name to indicate failure\n \n       if First > Last then\n-         return No_File;\n+         return No_Name;\n       end if;\n \n       --  Put the name in lower case into Name_Buffer\n@@ -1627,7 +1648,7 @@ package body Prj.Part is\n \n       loop\n          if not Is_Letter (Name_Buffer (Index)) then\n-            return No_File;\n+            return No_Name;\n \n          else\n             loop\n@@ -1637,7 +1658,7 @@ package body Prj.Part is\n \n                if Name_Buffer (Index) = '_' then\n                   if Name_Buffer (Index + 1) = '_' then\n-                     return No_File;\n+                     return No_Name;\n                   end if;\n                end if;\n \n@@ -1646,7 +1667,7 @@ package body Prj.Part is\n                if Name_Buffer (Index) /= '_'\n                  and then not Is_Alphanumeric (Name_Buffer (Index))\n                then\n-                  return No_File;\n+                  return No_Name;\n                end if;\n \n             end loop;\n@@ -1660,7 +1681,7 @@ package body Prj.Part is\n                return Name_Find;\n \n             else\n-               return No_File;\n+               return No_Name;\n             end if;\n \n          elsif Name_Buffer (Index) = '-' then"}, {"sha": "10d03904fa4c64f624508b3e73f4087c12bfc48d", "filename": "gcc/ada/prj-part.ads", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-part.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-part.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.ads?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2000-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -46,4 +46,27 @@ package Prj.Part is\n    --  unknown attribute produces a warning. When Store_Comments is True,\n    --  comments are stored in the parse tree.\n \n+   type Extension_Origin is (None, Extending_Simple, Extending_All);\n+   --  Type of parameter From_Extended for procedures Parse_Single_Project and\n+   --  Post_Parse_Context_Clause. Extending_All means that we are parsing the\n+   --  tree rooted at an extending all project.\n+\n+   procedure Parse_Single_Project\n+     (In_Tree           : Project_Node_Tree_Ref;\n+      Project           : out Project_Node_Id;\n+      Extends_All       : out Boolean;\n+      Path_Name         : String;\n+      Extended          : Boolean;\n+      From_Extended     : Extension_Origin;\n+      In_Limited        : Boolean;\n+      Packages_To_Check : String_List_Access;\n+      Depth             : Natural);\n+   --  Parse a project file.\n+   --  Recursive procedure: it calls itself for imported and extended\n+   --  projects. When From_Extended is not None, if the project has already\n+   --  been parsed and is an extended project A, return the ultimate\n+   --  (not extended) project that extends A. When In_Limited is True,\n+   --  the importing path includes at least one \"limited with\".\n+   --  When parsing configuration projects, do not allow a depth > 1.\n+\n end Prj.Part;"}, {"sha": "78870d60b4f031608cfa5e07473e70cf266f3401", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 515, "deletions": 129, "changes": 644, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -32,6 +32,7 @@ with Prj.Attr; use Prj.Attr;\n with Prj.Err;  use Prj.Err;\n with Prj.Ext;  use Prj.Ext;\n with Prj.Nmsc; use Prj.Nmsc;\n+with Prj.Util; use Prj.Util;\n with Sinput;   use Sinput;\n with Snames;\n \n@@ -51,21 +52,32 @@ package body Prj.Proc is\n       Equal      => \"=\");\n    --  This hash table contains all processed projects\n \n+   package Unit_Htable is new GNAT.HTable.Simple_HTable\n+     (Header_Num => Header_Num,\n+      Element    => Source_Id,\n+      No_Element => No_Source,\n+      Key        => Name_Id,\n+      Hash       => Hash,\n+      Equal      => \"=\");\n+   --  This hash table contains all processed projects\n+\n    procedure Add (To_Exp : in out Name_Id; Str : Name_Id);\n    --  Concatenate two strings and returns another string if both\n    --  arguments are not null string.\n \n    procedure Add_Attributes\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref;\n-      Decl    : in out Declarations;\n-      First   : Attribute_Node_Id);\n+     (Project       : Project_Id;\n+      Project_Name  : Name_Id;\n+      In_Tree       : Project_Tree_Ref;\n+      Decl          : in out Declarations;\n+      First         : Attribute_Node_Id;\n+      Project_Level : Boolean);\n    --  Add all attributes, starting with First, with their default\n    --  values to the package or project with declarations Decl.\n \n    procedure Check\n      (In_Tree         : Project_Tree_Ref;\n-      Project         : in out Project_Id;\n+      Project         : Project_Id;\n       Follow_Links    : Boolean;\n       When_No_Sources : Error_Warning);\n    --  Set all projects to not checked, then call Recursive_Check for the\n@@ -166,10 +178,12 @@ package body Prj.Proc is\n    --------------------\n \n    procedure Add_Attributes\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref;\n-      Decl    : in out Declarations;\n-      First   : Attribute_Node_Id)\n+     (Project       : Project_Id;\n+      Project_Name  : Name_Id;\n+      In_Tree       : Project_Tree_Ref;\n+      Decl          : in out Declarations;\n+      First         : Attribute_Node_Id;\n+      Project_Level : Boolean)\n    is\n       The_Attribute  : Attribute_Node_Id := First;\n \n@@ -200,6 +214,15 @@ package body Prj.Proc is\n                         Value    => Empty_String,\n                         Index    => 0);\n \n+                     --  Special case of <project>'Name\n+\n+                     if Project_Level\n+                       and then Attribute_Name_Of (The_Attribute) =\n+                                  Snames.Name_Name\n+                     then\n+                        New_Attribute.Value := Project_Name;\n+                     end if;\n+\n                   --  List attributes have a default value of nil list\n \n                   when List =>\n@@ -235,7 +258,7 @@ package body Prj.Proc is\n \n    procedure Check\n      (In_Tree         : Project_Tree_Ref;\n-      Project         : in out Project_Id;\n+      Project         : Project_Id;\n       Follow_Links    : Boolean;\n       When_No_Sources : Error_Warning)\n    is\n@@ -248,7 +271,39 @@ package body Prj.Proc is\n          In_Tree.Projects.Table (Index).Checked := False;\n       end loop;\n \n-      Recursive_Check (Project, In_Tree, Follow_Links, When_No_Sources);\n+      Recursive_Check\n+        (Project, In_Tree, Follow_Links, When_No_Sources);\n+\n+      --  Set the Other_Part field for the units\n+\n+      declare\n+         Source1 : Source_Id;\n+         Name    : Name_Id;\n+         Source2 : Source_Id;\n+\n+      begin\n+         Unit_Htable.Reset;\n+\n+         Source1 := In_Tree.First_Source;\n+         while Source1 /= No_Source loop\n+            Name := In_Tree.Sources.Table (Source1).Unit;\n+\n+            if Name /= No_Name then\n+               Source2 := Unit_Htable.Get (Name);\n+\n+               if Source2 = No_Source then\n+                  Unit_Htable.Set (K => Name, E => Source1);\n+\n+               else\n+                  Unit_Htable.Remove (Name);\n+                  In_Tree.Sources.Table (Source1).Other_Part := Source2;\n+                  In_Tree.Sources.Table (Source2).Other_Part := Source1;\n+               end if;\n+            end if;\n+\n+            Source1 := In_Tree.Sources.Table (Source1).Next_In_Sources;\n+         end loop;\n+      end;\n    end Check;\n \n    -------------------------------\n@@ -567,10 +622,10 @@ package body Prj.Proc is\n             when N_Variable_Reference | N_Attribute_Reference =>\n \n                declare\n-                  The_Project     : Project_Id     := Project;\n-                  The_Package     : Package_Id     := Pkg;\n-                  The_Name        : Name_Id        := No_Name;\n-                  The_Variable_Id : Variable_Id    := No_Variable;\n+                  The_Project     : Project_Id  := Project;\n+                  The_Package     : Package_Id  := Pkg;\n+                  The_Name        : Name_Id     := No_Name;\n+                  The_Variable_Id : Variable_Id := No_Variable;\n                   The_Variable    : Variable_Value;\n                   Term_Project    : constant Project_Node_Id :=\n                                       Project_Node_Of\n@@ -580,7 +635,7 @@ package body Prj.Proc is\n                                       Package_Node_Of\n                                         (The_Current_Term,\n                                          From_Project_Node_Tree);\n-                  Index           : Name_Id   := No_Name;\n+                  Index           : Name_Id := No_Name;\n \n                begin\n                   if Term_Project /= Empty_Node and then\n@@ -590,7 +645,6 @@ package body Prj.Proc is\n \n                      The_Name :=\n                        Name_Of (Term_Project, From_Project_Node_Tree);\n-\n                      The_Project := Imported_Or_Extended_Project_From\n                                       (Project   => Project,\n                                        In_Tree   => In_Tree,\n@@ -603,7 +657,6 @@ package body Prj.Proc is\n \n                      The_Name :=\n                        Name_Of (Term_Package, From_Project_Node_Tree);\n-\n                      The_Package := In_Tree.Projects.Table\n                                       (The_Project).Decl.Packages;\n \n@@ -1140,23 +1193,307 @@ package body Prj.Proc is\n       From_Project_Node_Tree : Project_Node_Tree_Ref;\n       Report_Error           : Put_Line_Access;\n       Follow_Links           : Boolean := True;\n-      When_No_Sources        : Error_Warning := Error)\n+      When_No_Sources        : Error_Warning := Error;\n+      Reset_Tree             : Boolean := True)\n    is\n       Obj_Dir    : Path_Name_Type;\n       Extending  : Project_Id;\n       Extending2 : Project_Id;\n+      Packages   : Package_Id;\n+      Element    : Package_Element;\n+\n+      procedure Process_Attributes (Attrs : Variable_Id);\n+\n+      ------------------------\n+      -- Process_Attributes --\n+      ------------------------\n+\n+      procedure Process_Attributes (Attrs : Variable_Id) is\n+         Attribute_Id : Variable_Id;\n+         Attribute    : Variable;\n+         List         : String_List_Id;\n+\n+      begin\n+         --  Loop through attributes\n+\n+         Attribute_Id := Attrs;\n+         while Attribute_Id /= No_Variable loop\n+            Attribute :=\n+              In_Tree.Variable_Elements.Table (Attribute_Id);\n+\n+            if not Attribute.Value.Default then\n+               case Attribute.Name is\n+                  when Snames.Name_Driver =>\n+\n+                     --  Attribute Linker'Driver: the default linker to use\n+\n+                     In_Tree.Config.Linker :=\n+                       Path_Name_Type (Attribute.Value.Value);\n+\n+                  when Snames.Name_Required_Switches =>\n+\n+                     --  Attribute Linker'Required_Switches: the minimum\n+                     --  options to use when invoking the linker\n+\n+                     Put (Into_List =>\n+                          In_Tree.Config.Minimum_Linker_Options,\n+                          From_List => Attribute.Value.Values,\n+                          In_Tree   => In_Tree);\n+\n+                  when Snames.Name_Executable_Suffix =>\n+\n+                     --  Attribute Executable_Suffix: the suffix of the\n+                     --  executables.\n+\n+                     In_Tree.Config.Executable_Suffix :=\n+                       Attribute.Value.Value;\n+\n+                  when Snames.Name_Library_Builder =>\n+\n+                     --  Attribute Library_Builder: the application to invoke\n+                     --  to build libraries.\n+\n+                     In_Tree.Config.Library_Builder :=\n+                       Path_Name_Type (Attribute.Value.Value);\n+\n+                  when Snames.Name_Archive_Builder =>\n+\n+                     --  Attribute Archive_Builder: the archive builder\n+                     --  (usually \"ar\") and its minimum options (usually \"cr\").\n+\n+                     List := Attribute.Value.Values;\n+\n+                     if List = Nil_String then\n+                        Error_Msg\n+                          (\"archive builder cannot be null\",\n+                           Attribute.Value.Location);\n+                     end if;\n+\n+                     Put (Into_List => In_Tree.Config.Archive_Builder,\n+                          From_List => List,\n+                          In_Tree   => In_Tree);\n+\n+                  when Snames.Name_Archive_Indexer =>\n+\n+                     --  Attribute Archive_Indexer: the optional archive\n+                     --  indexer (usually \"ranlib\") with its minimum options\n+                     --  (usually none).\n+\n+                     List := Attribute.Value.Values;\n+\n+                     if List = Nil_String then\n+                        Error_Msg\n+                          (\"archive indexer cannot be null\",\n+                           Attribute.Value.Location);\n+                     end if;\n+\n+                     Put (Into_List => In_Tree.Config.Archive_Indexer,\n+                          From_List => List,\n+                          In_Tree   => In_Tree);\n+\n+                  when Snames.Name_Library_Partial_Linker =>\n+\n+                     --  Attribute Library_Partial_Linker: the optional linker\n+                     --  driver with its minimum options, to partially link\n+                     --  archives.\n+\n+                     List := Attribute.Value.Values;\n+\n+                     if List = Nil_String then\n+                        Error_Msg\n+                          (\"partial linker cannot be null\",\n+                           Attribute.Value.Location);\n+                     end if;\n+\n+                     Put (Into_List => In_Tree.Config.Lib_Partial_Linker,\n+                          From_List => List,\n+                          In_Tree   => In_Tree);\n+\n+                  when Snames.Name_Archive_Suffix =>\n+                     In_Tree.Config.Archive_Suffix :=\n+                       File_Name_Type (Attribute.Value.Value);\n+\n+                  when Snames.Name_Linker_Executable_Option =>\n+\n+                     --  Attribute Linker_Executable_Option: optional options\n+                     --  to specify an executable name. Defaults to \"-o\".\n+\n+                     List := Attribute.Value.Values;\n+\n+                     if List = Nil_String then\n+                        Error_Msg\n+                          (\"linker executable option cannot be null\",\n+                           Attribute.Value.Location);\n+                     end if;\n+\n+                     Put (Into_List =>\n+                          In_Tree.Config.Linker_Executable_Option,\n+                          From_List => List,\n+                          In_Tree   => In_Tree);\n+\n+                  when Snames.Name_Linker_Lib_Dir_Option =>\n+\n+                     --  Attribute Linker_Lib_Dir_Option: optional options\n+                     --  to specify a library search directory. Defaults to\n+                     --  \"-L\".\n+\n+                     Get_Name_String (Attribute.Value.Value);\n+\n+                     if Name_Len = 0 then\n+                        Error_Msg\n+                          (\"linker library directory option cannot be empty\",\n+                           Attribute.Value.Location);\n+                     end if;\n+\n+                     In_Tree.Config.Linker_Lib_Dir_Option :=\n+                       Attribute.Value.Value;\n+\n+                  when Snames.Name_Linker_Lib_Name_Option =>\n+\n+                     --  Attribute Linker_Lib_Name_Option: optional options\n+                     --  to specify the name of a library to be linked in.\n+                     --  Defaults to \"-l\".\n+\n+                     Get_Name_String (Attribute.Value.Value);\n+\n+                     if Name_Len = 0 then\n+                        Error_Msg\n+                          (\"linker library name option cannot be empty\",\n+                           Attribute.Value.Location);\n+                     end if;\n+\n+                     In_Tree.Config.Linker_Lib_Name_Option :=\n+                       Attribute.Value.Value;\n+\n+                  when Snames.Name_Run_Path_Option =>\n+\n+                     --  Attribute Run_Path_Option: optional options to\n+                     --  specify a path for libraries.\n+\n+                     List := Attribute.Value.Values;\n+\n+                     if List /= Nil_String then\n+                        Put (Into_List => In_Tree.Config.Run_Path_Option,\n+                             From_List => List,\n+                             In_Tree   => In_Tree);\n+                     end if;\n+\n+                  when Snames.Name_Library_Support =>\n+                     declare\n+                        pragma Unsuppress (All_Checks);\n+                     begin\n+                        In_Tree.Config.Lib_Support :=\n+                          Library_Support'Value (Get_Name_String\n+                                                 (Attribute.Value.Value));\n+                     exception\n+                        when Constraint_Error =>\n+                           Error_Msg\n+                             (\"invalid value \"\"\" &\n+                              Get_Name_String (Attribute.Value.Value) &\n+                              \"\"\" for Library_Support\",\n+                              Attribute.Value.Location);\n+                     end;\n+\n+                  when Snames.Name_Shared_Library_Prefix =>\n+                     In_Tree.Config.Shared_Lib_Prefix :=\n+                       File_Name_Type (Attribute.Value.Value);\n+\n+                  when Snames.Name_Shared_Library_Suffix =>\n+                     In_Tree.Config.Shared_Lib_Suffix :=\n+                       File_Name_Type (Attribute.Value.Value);\n+\n+                  when Snames.Name_Symbolic_Link_Supported =>\n+                     declare\n+                        pragma Unsuppress (All_Checks);\n+                     begin\n+                        In_Tree.Config.Symbolic_Link_Supported :=\n+                          Boolean'Value (Get_Name_String\n+                                         (Attribute.Value.Value));\n+                     exception\n+                        when Constraint_Error =>\n+                           Error_Msg\n+                             (\"invalid value \"\"\" &\n+                              Get_Name_String (Attribute.Value.Value) &\n+                              \"\"\" for Symbolic_Link_Supported\",\n+                              Attribute.Value.Location);\n+                     end;\n+\n+                  when Snames.Name_Library_Major_Minor_Id_Supported =>\n+                     declare\n+                        pragma Unsuppress (All_Checks);\n+                     begin\n+                        In_Tree.Config.Lib_Maj_Min_Id_Supported :=\n+                          Boolean'Value (Get_Name_String\n+                                         (Attribute.Value.Value));\n+                     exception\n+                        when Constraint_Error =>\n+                           Error_Msg\n+                             (\"invalid value \"\"\" &\n+                              Get_Name_String (Attribute.Value.Value) &\n+                              \"\"\" for Library_Major_Minor_Id_Supported\",\n+                              Attribute.Value.Location);\n+                     end;\n+\n+                  when Snames.Name_Library_Auto_Init_Supported =>\n+                     declare\n+                        pragma Unsuppress (All_Checks);\n+                     begin\n+                        In_Tree.Config.Auto_Init_Supported :=\n+                          Boolean'Value (Get_Name_String\n+                                         (Attribute.Value.Value));\n+                     exception\n+                        when Constraint_Error =>\n+                           Error_Msg\n+                             (\"invalid value \"\"\" &\n+                              Get_Name_String (Attribute.Value.Value) &\n+                              \"\"\" for Library_Auto_Init_Supported\",\n+                              Attribute.Value.Location);\n+                     end;\n+\n+                  when Snames.Name_Shared_Library_Minimum_Switches =>\n+                     List := Attribute.Value.Values;\n+\n+                     if List /= Nil_String then\n+                        Put (Into_List =>\n+                               In_Tree.Config.Shared_Lib_Min_Options,\n+                             From_List => List,\n+                             In_Tree   => In_Tree);\n+                     end if;\n+\n+                  when Snames.Name_Library_Version_Switches =>\n+                     List := Attribute.Value.Values;\n+\n+                     if List /= Nil_String then\n+                        Put (Into_List =>\n+                               In_Tree.Config.Lib_Version_Options,\n+                             From_List => List,\n+                             In_Tree   => In_Tree);\n+                     end if;\n+\n+                  when others =>\n+                     null;\n+               end case;\n+            end if;\n+\n+            Attribute_Id := Attribute.Next;\n+         end loop;\n+      end Process_Attributes;\n \n    begin\n       Error_Report := Report_Error;\n       Success := True;\n \n-      --  Make sure there is no projects in the data structure\n+      if Reset_Tree then\n+\n+         --  Make sure there are no projects in the data structure\n+\n+         Project_Table.Set_Last (In_Tree.Projects, No_Project);\n+      end if;\n \n-      Project_Table.Set_Last (In_Tree.Projects, No_Project);\n       Processed_Projects.Reset;\n \n       --  And process the main project and all of the projects it depends on,\n-      --  recursively\n+      --  recursively.\n \n       Recursive_Process\n         (Project                => Project,\n@@ -1165,110 +1502,152 @@ package body Prj.Proc is\n          From_Project_Node_Tree => From_Project_Node_Tree,\n          Extended_By            => No_Project);\n \n-      if Project /= No_Project then\n-         Check (In_Tree, Project, Follow_Links, When_No_Sources);\n-      end if;\n+      if not In_Configuration then\n \n-      --  If main project is an extending all project, set the object\n-      --  directory of all virtual extending projects to the object directory\n-      --  of the main project.\n+         if Project /= No_Project then\n+            Check\n+              (In_Tree, Project, Follow_Links, When_No_Sources);\n+         end if;\n \n-      if Project /= No_Project\n-        and then Is_Extending_All (From_Project_Node, From_Project_Node_Tree)\n-      then\n-         declare\n-            Object_Dir : constant Path_Name_Type :=\n-                           In_Tree.Projects.Table (Project).Object_Directory;\n-         begin\n-            for Index in\n+         --  If main project is an extending all project, set the object\n+         --  directory of all virtual extending projects to the object\n+         --  directory of the main project.\n+\n+         if Project /= No_Project\n+           and then\n+             Is_Extending_All (From_Project_Node, From_Project_Node_Tree)\n+         then\n+            declare\n+               Object_Dir : constant Path_Name_Type :=\n+                              In_Tree.Projects.Table\n+                                (Project).Object_Directory;\n+            begin\n+               for Index in\n+                 Project_Table.First .. Project_Table.Last (In_Tree.Projects)\n+               loop\n+                  if In_Tree.Projects.Table (Index).Virtual then\n+                     In_Tree.Projects.Table (Index).Object_Directory :=\n+                       Object_Dir;\n+                  end if;\n+               end loop;\n+            end;\n+         end if;\n+\n+         --  Check that no extending project shares its object directory with\n+         --  the project(s) it extends.\n+\n+         if Project /= No_Project then\n+            for Proj in\n               Project_Table.First .. Project_Table.Last (In_Tree.Projects)\n             loop\n-               if In_Tree.Projects.Table (Index).Virtual then\n-                  In_Tree.Projects.Table (Index).Object_Directory :=\n-                    Object_Dir;\n+               Extending := In_Tree.Projects.Table (Proj).Extended_By;\n+\n+               if Extending /= No_Project then\n+                  Obj_Dir := In_Tree.Projects.Table (Proj).Object_Directory;\n+\n+                  --  Check that a project being extended does not share its\n+                  --  object directory with any project that extends it,\n+                  --  directly or indirectly, including a virtual extending\n+                  --  project.\n+\n+                  --  Start with the project directly extending it\n+\n+                  Extending2 := Extending;\n+                  while Extending2 /= No_Project loop\n+                     if In_Tree.Projects.Table (Extending2).Ada_Sources /=\n+                       Nil_String\n+                       and then\n+                         In_Tree.Projects.Table (Extending2).Object_Directory =\n+                         Obj_Dir\n+                     then\n+                        if In_Tree.Projects.Table (Extending2).Virtual then\n+                           Error_Msg_Name_1 :=\n+                             In_Tree.Projects.Table (Proj).Display_Name;\n+\n+                           if Error_Report = null then\n+                              Error_Msg\n+                                (\"project %% cannot be extended by a virtual\" &\n+                                 \" project with the same object directory\",\n+                                 In_Tree.Projects.Table (Proj).Location);\n+                           else\n+                              Error_Report\n+                                (\"project \"\"\" &\n+                                 Get_Name_String (Error_Msg_Name_1) &\n+                                 \"\"\" cannot be extended by a virtual \" &\n+                                 \"project with the same object directory\",\n+                                 Project, In_Tree);\n+                           end if;\n+\n+                        else\n+                           Error_Msg_Name_1 :=\n+                             In_Tree.Projects.Table (Extending2).Display_Name;\n+                           Error_Msg_Name_2 :=\n+                             In_Tree.Projects.Table (Proj).Display_Name;\n+\n+                           if Error_Report = null then\n+                              Error_Msg\n+                                (\"project %% cannot extend project %%\",\n+                                 In_Tree.Projects.Table (Extending2).Location);\n+                              Error_Msg\n+                                (\"\\they share the same object directory\",\n+                                 In_Tree.Projects.Table (Extending2).Location);\n+\n+                           else\n+                              Error_Report\n+                                (\"project \"\"\" &\n+                                 Get_Name_String (Error_Msg_Name_1) &\n+                                 \"\"\" cannot extend project \"\"\" &\n+                                 Get_Name_String (Error_Msg_Name_2) & \"\"\"\",\n+                                 Project, In_Tree);\n+                              Error_Report\n+                                (\"they share the same object directory\",\n+                                 Project, In_Tree);\n+                           end if;\n+                        end if;\n+                     end if;\n+\n+                     --  Continue with the next extending project, if any\n+\n+                     Extending2 :=\n+                       In_Tree.Projects.Table (Extending2).Extended_By;\n+                  end loop;\n                end if;\n             end loop;\n-         end;\n-      end if;\n+         end if;\n \n-      --  Check that no extending project shares its object directory with\n-      --  the project(s) it extends.\n+         --  Get the global configuration\n \n-      if Project /= No_Project then\n-         for Proj in\n-           Project_Table.First .. Project_Table.Last (In_Tree.Projects)\n-         loop\n-            Extending := In_Tree.Projects.Table (Proj).Extended_By;\n+         if Project /= No_Project then\n \n-            if Extending /= No_Project then\n-               Obj_Dir := In_Tree.Projects.Table (Proj).Object_Directory;\n+            Process_Attributes\n+              (In_Tree.Projects.Table (Project).Decl.Attributes);\n \n-               --  Check that a project being extended does not share its\n-               --  object directory with any project that extends it, directly\n-               --  or indirectly, including a virtual extending project.\n+            --  Loop through packages ???\n \n-               --  Start with the project directly extending it\n+            Packages := In_Tree.Projects.Table (Project).Decl.Packages;\n+            while Packages /= No_Package loop\n+               Element := In_Tree.Packages.Table (Packages);\n \n-               Extending2 := Extending;\n-               while Extending2 /= No_Project loop\n-                  if In_Tree.Projects.Table (Extending2).Ada_Sources_Present\n-                    and then\n-                      In_Tree.Projects.Table (Extending2).Object_Directory =\n-                                                                      Obj_Dir\n-                  then\n-                     if In_Tree.Projects.Table (Extending2).Virtual then\n-                        Error_Msg_Name_1 :=\n-                          In_Tree.Projects.Table (Proj).Display_Name;\n+               case Element.Name is\n+                  when Snames.Name_Builder =>\n \n-                        if Error_Report = null then\n-                           Error_Msg\n-                             (\"project % cannot be extended by a virtual \" &\n-                              \"project with the same object directory\",\n-                              In_Tree.Projects.Table (Proj).Location);\n-                        else\n-                           Error_Report\n-                             (\"project \"\"\" &\n-                              Get_Name_String (Error_Msg_Name_1) &\n-                              \"\"\" cannot be extended by a virtual \" &\n-                              \"project with the same object directory\",\n-                              Project, In_Tree);\n-                        end if;\n+                     --  Process attributes of package Builder\n \n-                     else\n-                        Error_Msg_Name_1 :=\n-                          In_Tree.Projects.Table (Extending2).Display_Name;\n-                        Error_Msg_Name_2 :=\n-                          In_Tree.Projects.Table (Proj).Display_Name;\n+                     Process_Attributes (Element.Decl.Attributes);\n \n-                        if Error_Report = null then\n-                           Error_Msg\n-                             (\"project %% cannot extend project %%\",\n-                              In_Tree.Projects.Table (Extending2).Location);\n-                           Error_Msg\n-                             (\"\\they share the same object directory\",\n-                              In_Tree.Projects.Table (Extending2).Location);\n+                  when Snames.Name_Linker =>\n \n-                        else\n-                           Error_Report\n-                             (\"project \"\"\" &\n-                              Get_Name_String (Error_Msg_Name_1) &\n-                              \"\"\" cannot extend project \"\"\" &\n-                              Get_Name_String (Error_Msg_Name_2) & \"\"\"\",\n-                              Project, In_Tree);\n-                           Error_Report\n-                             (\"they share the same object directory\",\n-                              Project, In_Tree);\n-                        end if;\n-                     end if;\n-                  end if;\n+                     --  Process attributes of package Linker\n \n-                  --  Continue with the next extending project, if any\n+                     Process_Attributes (Element.Decl.Attributes);\n \n-                  Extending2 :=\n-                    In_Tree.Projects.Table (Extending2).Extended_By;\n-               end loop;\n-            end if;\n-         end loop;\n+                  when others =>\n+                     null;\n+               end case;\n+\n+               Packages := Element.Next;\n+            end loop;\n+         end if;\n       end if;\n \n       Success :=\n@@ -1289,12 +1668,15 @@ package body Prj.Proc is\n       Pkg                    : Package_Id;\n       Item                   : Project_Node_Id)\n    is\n-      Current_Declarative_Item : Project_Node_Id := Item;\n-      Current_Item             : Project_Node_Id := Empty_Node;\n+      Current_Declarative_Item : Project_Node_Id;\n+      Current_Item             : Project_Node_Id;\n \n    begin\n-      --  For each declarative item\n+      --  Loop through declarative items\n+\n+      Current_Item := Empty_Node;\n \n+      Current_Declarative_Item := Item;\n       while Current_Declarative_Item /= Empty_Node loop\n \n          --  Get its data\n@@ -1313,6 +1695,7 @@ package body Prj.Proc is\n          case Kind_Of (Current_Item, From_Project_Node_Tree) is\n \n             when N_Package_Declaration =>\n+\n                --  Do not process a package declaration that should be ignored\n \n                if Expression_Kind_Of\n@@ -1400,11 +1783,14 @@ package body Prj.Proc is\n                         --  Set the default values of the attributes\n \n                         Add_Attributes\n-                          (Project, In_Tree,\n+                          (Project,\n+                           In_Tree.Projects.Table (Project).Name,\n+                           In_Tree,\n                            In_Tree.Packages.Table (New_Pkg).Decl,\n                            First_Attribute_Of\n                              (Package_Id_Of\n-                                (Current_Item, From_Project_Node_Tree)));\n+                                (Current_Item, From_Project_Node_Tree)),\n+                           Project_Level => False);\n \n                         --  And process declarative items of the new package\n \n@@ -1444,7 +1830,7 @@ package body Prj.Proc is\n                                               From_Project_Node_Tree);\n                      --  The name of the attribute\n \n-                     New_Array  : Array_Id;\n+                     New_Array : Array_Id;\n                      --  The new associative array created\n \n                      Orig_Array : Array_Id;\n@@ -1534,10 +1920,10 @@ package body Prj.Proc is\n                      --  Find the project where the value is declared\n \n                      Orig_Project_Name :=\n-                         Name_Of\n-                          (Associative_Project_Of\n-                             (Current_Item, From_Project_Node_Tree),\n-                              From_Project_Node_Tree);\n+                       Name_Of\n+                         (Associative_Project_Of\n+                              (Current_Item, From_Project_Node_Tree),\n+                          From_Project_Node_Tree);\n \n                      for Index in Project_Table.First ..\n                                   Project_Table.Last\n@@ -1745,7 +2131,7 @@ package body Prj.Proc is\n \n                            if Error_Report = null then\n                               Error_Msg\n-                                (\"no value defined for %\",\n+                                (\"no value defined for %%\",\n                                  Location_Of\n                                    (Current_Item, From_Project_Node_Tree));\n \n@@ -1791,8 +2177,8 @@ package body Prj.Proc is\n \n                                  if Error_Report = null then\n                                     Error_Msg\n-                                      (\"value %% is illegal for \"\n-                                       & \"typed string %\",\n+                                      (\"value %% is illegal \" &\n+                                       \"for typed string %%\",\n                                        Location_Of\n                                          (Current_Item,\n                                           From_Project_Node_Tree));\n@@ -1805,10 +2191,6 @@ package body Prj.Proc is\n                                        Get_Name_String (Error_Msg_Name_2) &\n                                        \"\"\"\",\n                                        Project, In_Tree);\n-                                    --  Calls like this to Error_Report are\n-                                    --  wrong, since they don't properly case\n-                                    --  and decode names corresponding to the\n-                                    --  ordinary case of % insertion ???\n                                  end if;\n                               end if;\n                            end;\n@@ -2414,19 +2796,23 @@ package body Prj.Proc is\n               Location_Of (From_Project_Node, From_Project_Node_Tree);\n \n             Processed_Data.Display_Directory :=\n-              Path_Name_Type\n-                (Directory_Of (From_Project_Node, From_Project_Node_Tree));\n+              Directory_Of (From_Project_Node, From_Project_Node_Tree);\n             Get_Name_String (Processed_Data.Display_Directory);\n             Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n             Processed_Data.Directory := Name_Find;\n \n             Processed_Data.Extended_By := Extended_By;\n \n             Add_Attributes\n-              (Project, In_Tree, Processed_Data.Decl, Attribute_First);\n+              (Project,\n+               Name,\n+               In_Tree,\n+               Processed_Data.Decl,\n+               Prj.Attr.Attribute_First,\n+               Project_Level => True);\n+\n             With_Clause :=\n               First_With_Clause_Of (From_Project_Node, From_Project_Node_Tree);\n-\n             while With_Clause /= Empty_Node loop\n                declare\n                   New_Project : Project_Id;"}, {"sha": "99560f570c5e3db2401c44d6c0d43d3ee0a31fa1", "filename": "gcc/ada/prj-proc.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-proc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-proc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.ads?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2001-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,7 +40,8 @@ package Prj.Proc is\n       From_Project_Node_Tree : Project_Node_Tree_Ref;\n       Report_Error           : Put_Line_Access;\n       Follow_Links           : Boolean := True;\n-      When_No_Sources        : Error_Warning := Error);\n+      When_No_Sources        : Error_Warning := Error;\n+      Reset_Tree             : Boolean := True);\n    --  Process a project file tree into project file data structures. If\n    --  Report_Error is null, use the error reporting mechanism. Otherwise,\n    --  report errors using Report_Error.\n@@ -53,6 +54,9 @@ package Prj.Proc is\n    --  When_No_Sources indicates what should be done when no sources\n    --  are found in a project for a specified or implied language.\n    --\n+   --  When Reset_Tree is True, all the project data are removed from the\n+   --  project table before processing.\n+   --\n    --  Process is a bit of a junk name, how about Process_Project_Tree???\n \n end Prj.Proc;"}, {"sha": "c90e00877cc3711a72f87375c1cbe485b109c432", "filename": "gcc/ada/prj-strt.adb", "status": "modified", "additions": 68, "deletions": 50, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-strt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-strt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-strt.adb?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -45,6 +45,7 @@ package body Prj.Strt is\n \n    Choices_Initial   : constant := 10;\n    Choices_Increment : constant := 100;\n+   --  These should be in alloc.ads\n \n    Choice_Node_Low_Bound  : constant := 0;\n    Choice_Node_High_Bound : constant := 099_999_999;\n@@ -211,8 +212,9 @@ package body Prj.Strt is\n               (Reference, In_Tree, To => Variable_Kind_Of (Current_Attribute));\n             Set_Case_Insensitive\n               (Reference, In_Tree,\n-               To => Attribute_Kind_Of (Current_Attribute) =\n-                       Case_Insensitive_Associative_Array);\n+               To => Attribute_Kind_Of (Current_Attribute) in\n+                      Case_Insensitive_Associative_Array ..\n+                        Optional_Index_Case_Insensitive_Associative_Array);\n \n             --  Scan past the attribute name\n \n@@ -321,7 +323,8 @@ package body Prj.Strt is\n          Choice_First := 0;\n \n       elsif Choice_Lasts.Last = 2 then\n-         --  This is the second case onstruction, set the tables to the first\n+\n+         --  This is the second case construction, set the tables to the first\n \n          Choice_Lasts.Set_Last (1);\n          Choices.Set_Last (Choice_Lasts.Table (1));\n@@ -390,15 +393,10 @@ package body Prj.Strt is\n          case Token is\n \n             when Tok_Right_Paren =>\n-\n-               --  Scan past the right parenthesis\n-               Scan (In_Tree);\n+               Scan (In_Tree); -- scan past right paren\n \n             when Tok_Comma =>\n-\n-               --  Scan past the comma\n-\n-               Scan (In_Tree);\n+               Scan (In_Tree); -- scan past comma\n \n                --  Get the string expression for the default\n \n@@ -423,10 +421,8 @@ package body Prj.Strt is\n \n                Expect (Tok_Right_Paren, \"`)`\");\n \n-               --  Scan past the right parenthesis\n-\n                if Token = Tok_Right_Paren then\n-                  Scan (In_Tree);\n+                  Scan (In_Tree); -- scan past right paren\n                end if;\n \n             when others =>\n@@ -477,16 +473,19 @@ package body Prj.Strt is\n          Found := False;\n          for Choice in Choice_First .. Choices.Last loop\n             if Choices.Table (Choice).The_String = Choice_String then\n+\n                --  This label is part of the string type\n \n                Found := True;\n \n                if Choices.Table (Choice).Already_Used then\n+\n                   --  But it has already appeared in a choice list for this\n-                  --  case construction; report an error.\n+                  --  case construction so report an error.\n \n                   Error_Msg_Name_1 := Choice_String;\n                   Error_Msg (\"duplicate case label %%\", Token_Ptr);\n+\n                else\n                   Choices.Table (Choice).Already_Used := True;\n                end if;\n@@ -509,6 +508,7 @@ package body Prj.Strt is\n          --  If there is no '|', we are done\n \n          if Token = Tok_Vertical_Bar then\n+\n             --  Otherwise, declare the node of the next choice, link it to\n             --  Current_Choice and set Current_Choice to this new node.\n \n@@ -606,6 +606,7 @@ package body Prj.Strt is\n          begin\n             while Current /= Last_String loop\n                if String_Value_Of (Current, In_Tree) = String_Value then\n+\n                   --  This is a repetition, report an error\n \n                   Error_Msg_Name_1 := String_Value;\n@@ -705,12 +706,21 @@ package body Prj.Strt is\n \n                   --  Now, look if it can be a project name\n \n-                  The_Project := Imported_Or_Extended_Project_Of\n-                    (Current_Project, In_Tree, Names.Table (1).Name);\n+                  if Names.Table (1).Name =\n+                       Name_Of (Current_Project, In_Tree)\n+                  then\n+                     The_Project := Current_Project;\n+\n+                  else\n+                     The_Project :=\n+                       Imported_Or_Extended_Project_Of\n+                         (Current_Project, In_Tree, Names.Table (1).Name);\n+                  end if;\n \n                   if The_Project = Empty_Node then\n+\n                      --  If it is neither a project name nor a package name,\n-                     --  report an error\n+                     --  report an error.\n \n                      if First_Attribute = Empty_Attribute then\n                         Error_Msg_Name_1 := Names.Table (1).Name;\n@@ -719,15 +729,15 @@ package body Prj.Strt is\n                         First_Attribute := Attribute_First;\n \n                      else\n-                        --  If it is a package name, check if the package\n-                        --  has already been declared in the current project.\n+                        --  If it is a package name, check if the package has\n+                        --  already been declared in the current project.\n \n                         The_Package :=\n                           First_Package_Of (Current_Project, In_Tree);\n \n                         while The_Package /= Empty_Node\n                           and then Name_Of (The_Package, In_Tree) /=\n-                          Names.Table (1).Name\n+                                                      Names.Table (1).Name\n                         loop\n                            The_Package :=\n                              Next_Package_In_Project (The_Package, In_Tree);\n@@ -797,8 +807,16 @@ package body Prj.Strt is\n \n                      --  Check if the long project is imported or extended\n \n-                     The_Project := Imported_Or_Extended_Project_Of\n-                                      (Current_Project, In_Tree, Long_Project);\n+                     if Long_Project = Name_Of (Current_Project, In_Tree) then\n+                        The_Project := Current_Project;\n+\n+                     else\n+                        The_Project :=\n+                          Imported_Or_Extended_Project_Of\n+                            (Current_Project,\n+                             In_Tree,\n+                             Long_Project);\n+                     end if;\n \n                      --  If the long project exists, then this is the prefix\n                      --  of the attribute.\n@@ -811,12 +829,18 @@ package body Prj.Strt is\n                         --  Otherwise, check if the short project is imported\n                         --  or extended.\n \n-                        The_Project := Imported_Or_Extended_Project_Of\n-                                         (Current_Project, In_Tree,\n-                                          Short_Project);\n+                        if Short_Project =\n+                             Name_Of (Current_Project, In_Tree)\n+                        then\n+                           The_Project := Current_Project;\n \n-                        --  If the short project does not exist, we report an\n-                        --  error.\n+                        else\n+                           The_Project := Imported_Or_Extended_Project_Of\n+                                            (Current_Project, In_Tree,\n+                                             Short_Project);\n+                        end if;\n+\n+                        --  If short project does not exist, report an error\n \n                         if The_Project = Empty_Node then\n                            Error_Msg_Name_1 := Long_Project;\n@@ -881,7 +905,7 @@ package body Prj.Strt is\n          case Names.Last is\n             when 0 =>\n \n-               --  Cannot happen\n+               --  Cannot happen (so why null instead of raise PE???)\n \n                null;\n \n@@ -990,16 +1014,18 @@ package body Prj.Strt is\n \n                      --  First check for a possible project name\n \n-                     The_Project := Imported_Or_Extended_Project_Of\n-                                   (Current_Project, In_Tree, Short_Project);\n+                     The_Project :=\n+                       Imported_Or_Extended_Project_Of\n+                         (Current_Project, In_Tree, Short_Project);\n \n                      if The_Project = Empty_Node then\n                         --  Unknown prefix, report an error\n \n                         Error_Msg_Name_1 := Long_Project;\n                         Error_Msg_Name_2 := Short_Project;\n-                        Error_Msg (\"unknown projects % or %\",\n-                                   Names.Table (1).Location);\n+                        Error_Msg\n+                          (\"unknown projects % or %\",\n+                           Names.Table (1).Location);\n                         Look_For_Variable := False;\n \n                      else\n@@ -1018,7 +1044,8 @@ package body Prj.Strt is\n                         end loop;\n \n                         if The_Package = Empty_Node then\n-                           --  The package does not vexist, report an error\n+\n+                           --  The package does not exist, report an error\n \n                            Error_Msg_Name_1 := Names.Table (2).Name;\n                            Error_Msg (\"unknown package %\",\n@@ -1041,7 +1068,6 @@ package body Prj.Strt is\n \n          if Specified_Project /= Empty_Node then\n             The_Project := Specified_Project;\n-\n          else\n             The_Project := Current_Project;\n          end if;\n@@ -1056,7 +1082,6 @@ package body Prj.Strt is\n          if Specified_Package /= Empty_Node then\n             Current_Variable :=\n               First_Variable_Of (Specified_Package, In_Tree);\n-\n             while Current_Variable /= Empty_Node\n               and then\n               Name_Of (Current_Variable, In_Tree) /= Variable_Name\n@@ -1074,7 +1099,6 @@ package body Prj.Strt is\n             then\n                Current_Variable :=\n                  First_Variable_Of (Current_Package, In_Tree);\n-\n                while Current_Variable /= Empty_Node\n                  and then Name_Of (Current_Variable, In_Tree) /= Variable_Name\n                loop\n@@ -1088,7 +1112,6 @@ package body Prj.Strt is\n \n             if Current_Variable = Empty_Node then\n                Current_Variable := First_Variable_Of (The_Project, In_Tree);\n-\n                while Current_Variable /= Empty_Node\n                  and then Name_Of (Current_Variable, In_Tree) /= Variable_Name\n                loop\n@@ -1112,8 +1135,8 @@ package body Prj.Strt is\n            (Variable, In_Tree,\n             To => Expression_Kind_Of (Current_Variable, In_Tree));\n \n-         if\n-           Kind_Of (Current_Variable, In_Tree) = N_Typed_Variable_Declaration\n+         if Kind_Of (Current_Variable, In_Tree) =\n+                                      N_Typed_Variable_Declaration\n          then\n             Set_String_Type_Of\n               (Variable, In_Tree,\n@@ -1151,7 +1174,7 @@ package body Prj.Strt is\n       Current_String : Project_Node_Id;\n \n    begin\n-      --  Set Choice_First, depending on whether is the first case\n+      --  Set Choice_First, depending on whether this is the first case\n       --  construction or not.\n \n       if Choice_First = 0 then\n@@ -1161,11 +1184,10 @@ package body Prj.Strt is\n          Choice_First := Choices.Last + 1;\n       end if;\n \n-      --  Add to table Choices the literal of the string type\n+      --  Add the literal of the string type to the Choices table\n \n       if String_Type /= Empty_Node then\n          Current_String := First_Literal_String (String_Type, In_Tree);\n-\n          while Current_String /= Empty_Node loop\n             Add (This_String => String_Value_Of (Current_String, In_Tree));\n             Current_String := Next_Literal_String (Current_String, In_Tree);\n@@ -1176,7 +1198,6 @@ package body Prj.Strt is\n \n       Choice_Lasts.Increment_Last;\n       Choice_Lasts.Table (Choice_Lasts.Last) := Choices.Last;\n-\n    end Start_New_Case_Construction;\n \n    -----------\n@@ -1249,8 +1270,7 @@ package body Prj.Strt is\n                Scan (In_Tree);\n \n             else\n-               --  Otherwise, we parse the expression(s) in the literal string\n-               --  list.\n+               --  Otherwise parse the expression(s) in the literal string list\n \n                loop\n                   Current_Location := Token_Ptr;\n@@ -1387,7 +1407,7 @@ package body Prj.Strt is\n \n          when Tok_Project =>\n \n-            --  project can appear in an expression as the prefix of an\n+            --  Project can appear in an expression as the prefix of an\n             --  attribute reference of the current project.\n \n             Current_Location := Token_Ptr;\n@@ -1420,6 +1440,7 @@ package body Prj.Strt is\n             end if;\n \n          when Tok_External =>\n+\n             --  An external reference is always a single string\n \n             if Expr_Kind = Undefined then\n@@ -1442,10 +1463,7 @@ package body Prj.Strt is\n       --  If there is an '&', call Terms recursively\n \n       if Token = Tok_Ampersand then\n-\n-         --  Scan past the '&'\n-\n-         Scan (In_Tree);\n+         Scan (In_Tree); -- scan past ampersand\n \n          Terms\n            (In_Tree         => In_Tree,"}, {"sha": "b0a9bd61366f622ec311b2ea9be5272a949d82c0", "filename": "gcc/ada/prj-tree.ads", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-tree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-tree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.ads?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -29,6 +29,8 @@\n with GNAT.Dynamic_HTables;\n with GNAT.Dynamic_Tables;\n \n+with Table;\n+\n with Prj.Attr; use Prj.Attr;\n \n package Prj.Tree is\n@@ -196,8 +198,11 @@ package Prj.Tree is\n    --  The following query functions are part of the abstract interface\n    --  of the Project File tree. They provide access to fields of a project.\n \n-   --  In the following, there are \"valid if\" comments, but no indication\n-   --  of what happens if they are called with invalid arguments ???\n+   --  The access functions should be called only with valid arguments.\n+   --  For each function the condition of validity is specified. If an access\n+   --  function is called with invalid arguments, then exception\n+   --  Assertion_Error is raised if assertions are enabled, otherwise the\n+   --  behaviour is not defined and may result in a crash.\n \n    function Name_Of\n      (Node    : Project_Node_Id;\n@@ -1206,7 +1211,8 @@ package Prj.Tree is\n          --  Node of the project in table Project_Nodes\n \n          Canonical_Path : Path_Name_Type;\n-         --  Resolved and canonical path of the project file\n+         --  Resolved and canonical path of a real project file.\n+         --  No_Name in case of virtual projects.\n \n          Extended : Boolean;\n          --  True when the project is being extended by another project"}, {"sha": "a49e9a8c845a7129e119c692dee67106101dd728", "filename": "gcc/ada/prj-util.adb", "status": "modified", "additions": 164, "deletions": 59, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.adb?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -26,7 +26,7 @@\n \n with Ada.Unchecked_Deallocation;\n \n-with System.Case_Util; use System.Case_Util;\n+with GNAT.Case_Util; use GNAT.Case_Util;\n \n with Osint;    use Osint;\n with Output;   use Output;\n@@ -56,6 +56,38 @@ package body Prj.Util is\n       Free (File);\n    end Close;\n \n+   ---------------\n+   -- Duplicate --\n+   ---------------\n+\n+   procedure Duplicate\n+     (This    : in out Name_List_Index;\n+      In_Tree : Project_Tree_Ref)\n+   is\n+      Old_Current : Name_List_Index;\n+      New_Current : Name_List_Index;\n+\n+   begin\n+      if This /= No_Name_List then\n+         Old_Current := This;\n+         Name_List_Table.Increment_Last (In_Tree.Name_Lists);\n+         New_Current := Name_List_Table.Last (In_Tree.Name_Lists);\n+         This := New_Current;\n+         In_Tree.Name_Lists.Table (New_Current) :=\n+           (In_Tree.Name_Lists.Table (Old_Current).Name, No_Name_List);\n+\n+         loop\n+            Old_Current := In_Tree.Name_Lists.Table (Old_Current).Next;\n+            exit when Old_Current = No_Name_List;\n+            In_Tree.Name_Lists.Table (New_Current).Next := New_Current + 1;\n+            Name_List_Table.Increment_Last (In_Tree.Name_Lists);\n+            New_Current := New_Current + 1;\n+            In_Tree.Name_Lists.Table (New_Current) :=\n+              (In_Tree.Name_Lists.Table (Old_Current).Name, No_Name_List);\n+         end loop;\n+      end if;\n+   end Duplicate;\n+\n    -----------------\n    -- End_Of_File --\n    -----------------\n@@ -101,23 +133,34 @@ package body Prj.Util is\n \n       Executable_Suffix : Variable_Value := Nil_Variable_Value;\n \n-      Body_Append : constant String := Get_Name_String\n-                                          (In_Tree.Projects.Table\n-                                            (Project).\n-                                              Naming.Ada_Body_Suffix);\n+      Executable_Suffix_Name : Name_Id := No_Name;\n \n-      Spec_Append : constant String := Get_Name_String\n-                                          (In_Tree.Projects.Table\n-                                            (Project).\n-                                               Naming.Ada_Spec_Suffix);\n+      Naming : constant Naming_Data := In_Tree.Projects.Table (Project).Naming;\n+\n+      Body_Suffix : constant String :=\n+                      Body_Suffix_Of (In_Tree, \"ada\", Naming);\n+\n+      Spec_Suffix : constant String :=\n+                      Spec_Suffix_Of (In_Tree, \"ada\", Naming);\n \n    begin\n       if Builder_Package /= No_Package then\n-         Executable_Suffix := Prj.Util.Value_Of\n-           (Variable_Name => Name_Executable_Suffix,\n-            In_Variables  => In_Tree.Packages.Table\n-              (Builder_Package).Decl.Attributes,\n-            In_Tree       => In_Tree);\n+         if Get_Mode = Multi_Language then\n+            Executable_Suffix_Name := In_Tree.Config.Executable_Suffix;\n+\n+         else\n+            Executable_Suffix := Prj.Util.Value_Of\n+              (Variable_Name => Name_Executable_Suffix,\n+               In_Variables  => In_Tree.Packages.Table\n+                 (Builder_Package).Decl.Attributes,\n+               In_Tree       => In_Tree);\n+\n+            if Executable_Suffix /= Nil_Variable_Value\n+              and then not Executable_Suffix.Default\n+            then\n+               Executable_Suffix_Name := Executable_Suffix.Value;\n+            end if;\n+         end if;\n \n          if Executable = Nil_Variable_Value and Ada_Main then\n             Get_Name_String (Main);\n@@ -130,14 +173,6 @@ package body Prj.Util is\n                         Name_Buffer (1 .. Name_Len);\n                Last : Positive := Name_Len;\n \n-               Naming : constant Naming_Data :=\n-                          In_Tree.Projects.Table (Project).Naming;\n-\n-               Spec_Suffix : constant String :=\n-                               Get_Name_String (Naming.Ada_Spec_Suffix);\n-               Body_Suffix : constant String :=\n-                               Get_Name_String (Naming.Ada_Body_Suffix);\n-\n                Truncated : Boolean := False;\n \n             begin\n@@ -186,13 +221,11 @@ package body Prj.Util is\n                Result     : File_Name_Type;\n \n             begin\n-               if Executable_Suffix /= Nil_Variable_Value\n-                 and then not Executable_Suffix.Default\n-               then\n-                  Executable_Extension_On_Target := Executable_Suffix.Value;\n+               if Executable_Suffix_Name /= No_Name then\n+                  Executable_Extension_On_Target := Executable_Suffix_Name;\n                end if;\n \n-               Result := Executable_Name (File_Name_Type (Executable.Value));\n+               Result :=  Executable_Name (File_Name_Type (Executable.Value));\n                Executable_Extension_On_Target := Saved_EEOT;\n                return Result;\n             end;\n@@ -205,21 +238,21 @@ package body Prj.Util is\n       --  otherwise remove any suffix ('.' followed by other characters), if\n       --  there is one.\n \n-      if Ada_Main and then Name_Len > Body_Append'Length\n-         and then Name_Buffer (Name_Len - Body_Append'Length + 1 .. Name_Len) =\n-                    Body_Append\n+      if Ada_Main and then Name_Len > Body_Suffix'Length\n+         and then Name_Buffer (Name_Len - Body_Suffix'Length + 1 .. Name_Len) =\n+                    Body_Suffix\n       then\n          --  Found the body termination, remove it\n \n-         Name_Len := Name_Len - Body_Append'Length;\n+         Name_Len := Name_Len - Body_Suffix'Length;\n \n-      elsif Ada_Main and then Name_Len > Spec_Append'Length\n-         and then Name_Buffer (Name_Len - Spec_Append'Length + 1 .. Name_Len) =\n-                    Spec_Append\n+      elsif Ada_Main and then Name_Len > Spec_Suffix'Length\n+         and then Name_Buffer (Name_Len - Spec_Suffix'Length + 1 .. Name_Len) =\n+                    Spec_Suffix\n       then\n          --  Found the spec termination, remove it\n \n-         Name_Len := Name_Len - Spec_Append'Length;\n+         Name_Len := Name_Len - Spec_Suffix'Length;\n \n       else\n          --  Remove any suffix, if there is one\n@@ -242,9 +275,20 @@ package body Prj.Util is\n          end;\n \n       else\n-         --  Otherwise, add the standard suffix for the platform, if any\n+         --  Get the executable name. If Executable_Suffix is defined in the\n+         --  configuration, make sure that it will be the extension of the\n+         --  executable.\n \n-         return Executable_Name (Name_Find);\n+         declare\n+            Saved_EEOT : constant Name_Id := Executable_Extension_On_Target;\n+            Result     : File_Name_Type;\n+\n+         begin\n+            Executable_Extension_On_Target := In_Tree.Config.Executable_Suffix;\n+            Result := Executable_Name (Name_Find);\n+            Executable_Extension_On_Target := Saved_EEOT;\n+            return Result;\n+         end;\n       end if;\n    end Executable_Of;\n \n@@ -348,8 +392,10 @@ package body Prj.Util is\n       File_Name (File_Name'Last) := ASCII.NUL;\n       FD := Open_Read (Name => File_Name'Address,\n                        Fmode => GNAT.OS_Lib.Text);\n+\n       if FD = Invalid_FD then\n          File := null;\n+\n       else\n          File := new Text_File_Data;\n          File.FD := FD;\n@@ -366,6 +412,52 @@ package body Prj.Util is\n       end if;\n    end Open;\n \n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put\n+     (Into_List : in out Name_List_Index;\n+      From_List : String_List_Id;\n+      In_Tree   : Project_Tree_Ref)\n+   is\n+      Current_Name : Name_List_Index;\n+      List         : String_List_Id;\n+      Element      : String_Element;\n+      Last         : Name_List_Index :=\n+                       Name_List_Table.Last (In_Tree.Name_Lists);\n+\n+   begin\n+      Current_Name := Into_List;\n+      while Current_Name /= No_Name_List and then\n+            In_Tree.Name_Lists.Table (Current_Name).Next /= No_Name_List\n+      loop\n+         Current_Name := In_Tree.Name_Lists.Table (Current_Name).Next;\n+      end loop;\n+\n+      List := From_List;\n+      while List /= Nil_String loop\n+         Element := In_Tree.String_Elements.Table (List);\n+\n+         Name_List_Table.Append\n+           (In_Tree.Name_Lists,\n+            (Name => Element.Value, Next => No_Name_List));\n+\n+         Last := Last + 1;\n+\n+         if Current_Name = No_Name_List then\n+            Into_List := Last;\n+\n+         else\n+            In_Tree.Name_Lists.Table (Current_Name).Next := Last;\n+         end if;\n+\n+         Current_Name := Last;\n+\n+         List := Element.Next;\n+      end loop;\n+   end Put;\n+\n    --------------\n    -- Value_Of --\n    --------------\n@@ -386,15 +478,17 @@ package body Prj.Util is\n    end Value_Of;\n \n    function Value_Of\n-     (Index     : Name_Id;\n-      In_Array  : Array_Element_Id;\n-      In_Tree   : Project_Tree_Ref) return Name_Id\n+     (Index    : Name_Id;\n+      In_Array : Array_Element_Id;\n+      In_Tree  : Project_Tree_Ref) return Name_Id\n    is\n-      Current    : Array_Element_Id := In_Array;\n+      Current    : Array_Element_Id;\n       Element    : Array_Element;\n       Real_Index : Name_Id := Index;\n \n    begin\n+      Current := In_Array;\n+\n       if Current = No_Array_Element then\n          return No_Name;\n       end if;\n@@ -423,23 +517,28 @@ package body Prj.Util is\n    end Value_Of;\n \n    function Value_Of\n-     (Index     : Name_Id;\n-      Src_Index : Int := 0;\n-      In_Array  : Array_Element_Id;\n-      In_Tree   : Project_Tree_Ref) return Variable_Value\n+     (Index                  : Name_Id;\n+      Src_Index              : Int := 0;\n+      In_Array               : Array_Element_Id;\n+      In_Tree                : Project_Tree_Ref;\n+      Force_Lower_Case_Index : Boolean := False) return Variable_Value\n    is\n-      Current : Array_Element_Id := In_Array;\n-      Element : Array_Element;\n-      Real_Index : Name_Id := Index;\n+      Current    : Array_Element_Id;\n+      Element    : Array_Element;\n+      Real_Index : Name_Id;\n \n    begin\n+      Current := In_Array;\n+\n       if Current = No_Array_Element then\n          return Nil_Variable_Value;\n       end if;\n \n       Element := In_Tree.Array_Elements.Table (Current);\n \n-      if not Element.Index_Case_Sensitive then\n+      Real_Index := Index;\n+\n+      if not Element.Index_Case_Sensitive or Force_Lower_Case_Index then\n          Get_Name_String (Index);\n          To_Lower (Name_Buffer (1 .. Name_Len));\n          Real_Index := Name_Find;\n@@ -465,7 +564,8 @@ package body Prj.Util is\n       Index                   : Int := 0;\n       Attribute_Or_Array_Name : Name_Id;\n       In_Package              : Package_Id;\n-      In_Tree                 : Project_Tree_Ref) return Variable_Value\n+      In_Tree                 : Project_Tree_Ref;\n+      Force_Lower_Case_Index  : Boolean := False) return Variable_Value\n    is\n       The_Array     : Array_Element_Id;\n       The_Attribute : Variable_Value := Nil_Variable_Value;\n@@ -482,10 +582,11 @@ package body Prj.Util is\n               In_Tree   => In_Tree);\n          The_Attribute :=\n            Value_Of\n-             (Index     => Name,\n-              Src_Index => Index,\n-              In_Array  => The_Array,\n-              In_Tree   => In_Tree);\n+             (Index                  => Name,\n+              Src_Index              => Index,\n+              In_Array               => The_Array,\n+              In_Tree                => In_Tree,\n+              Force_Lower_Case_Index => Force_Lower_Case_Index);\n \n          --  If there is no array element, look for a variable\n \n@@ -508,10 +609,11 @@ package body Prj.Util is\n       In_Arrays : Array_Id;\n       In_Tree   : Project_Tree_Ref) return Name_Id\n    is\n-      Current : Array_Id := In_Arrays;\n+      Current   : Array_Id;\n       The_Array : Array_Data;\n \n    begin\n+      Current := In_Arrays;\n       while Current /= No_Array loop\n          The_Array := In_Tree.Arrays.Table (Current);\n          if The_Array.Name = In_Array then\n@@ -530,10 +632,11 @@ package body Prj.Util is\n       In_Arrays : Array_Id;\n       In_Tree   : Project_Tree_Ref) return Array_Element_Id\n    is\n-      Current    : Array_Id := In_Arrays;\n-      The_Array  : Array_Data;\n+      Current   : Array_Id;\n+      The_Array : Array_Data;\n \n    begin\n+      Current := In_Arrays;\n       while Current /= No_Array loop\n          The_Array := In_Tree.Arrays.Table (Current);\n \n@@ -552,10 +655,11 @@ package body Prj.Util is\n       In_Packages : Package_Id;\n       In_Tree     : Project_Tree_Ref) return Package_Id\n    is\n-      Current : Package_Id := In_Packages;\n+      Current     : Package_Id;\n       The_Package : Package_Element;\n \n    begin\n+      Current := In_Packages;\n       while Current /= No_Package loop\n          The_Package := In_Tree.Packages.Table (Current);\n          exit when The_Package.Name /= No_Name\n@@ -571,10 +675,11 @@ package body Prj.Util is\n       In_Variables  : Variable_Id;\n       In_Tree       : Project_Tree_Ref) return Variable_Value\n    is\n-      Current      : Variable_Id := In_Variables;\n+      Current      : Variable_Id;\n       The_Variable : Variable;\n \n    begin\n+      Current := In_Variables;\n       while Current /= No_Variable loop\n          The_Variable :=\n            In_Tree.Variable_Elements.Table (Current);"}, {"sha": "ffb606ed5aed1b2b40e3e8da5e7abf436169e67e", "filename": "gcc/ada/prj-util.ads", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj-util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.ads?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -40,6 +40,17 @@ package Prj.Util is\n    --  Executable_Suffix is specified, add this suffix, otherwise add the\n    --  standard executable suffix for the platform.\n \n+   procedure Put\n+     (Into_List : in out Name_List_Index;\n+      From_List : String_List_Id;\n+      In_Tree   : Project_Tree_Ref);\n+   --  Append a name list to a string list\n+\n+   procedure Duplicate\n+     (This    : in out Name_List_Index;\n+      In_Tree : Project_Tree_Ref);\n+   --  Duplicate a name list\n+\n    function Value_Of\n      (Variable : Variable_Value;\n       Default  : String) return String;\n@@ -58,10 +69,11 @@ package Prj.Util is\n    --  associative array.\n \n    function Value_Of\n-     (Index     : Name_Id;\n-      Src_Index : Int := 0;\n-      In_Array  : Array_Element_Id;\n-      In_Tree   : Project_Tree_Ref) return Variable_Value;\n+     (Index                  : Name_Id;\n+      Src_Index              : Int := 0;\n+      In_Array               : Array_Element_Id;\n+      In_Tree                : Project_Tree_Ref;\n+      Force_Lower_Case_Index : Boolean := False) return Variable_Value;\n    --  Get a string array component (single String or String list). Returns\n    --  Nil_Variable_Value if no component Index or if In_Array is null.\n    --\n@@ -75,7 +87,8 @@ package Prj.Util is\n       Index                   : Int := 0;\n       Attribute_Or_Array_Name : Name_Id;\n       In_Package              : Package_Id;\n-      In_Tree                 : Project_Tree_Ref) return Variable_Value;\n+      In_Tree                 : Project_Tree_Ref;\n+      Force_Lower_Case_Index  : Boolean := False) return Variable_Value;\n    --  In a specific package,\n    --   - if there exists an array Attribute_Or_Array_Name with an index Name,\n    --     returns the corresponding component (depending on the attribute, the"}, {"sha": "2d0866c3b4d23c8e4daaf903756f9ed3c2e8b6e6", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 745, "deletions": 81, "changes": 826, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -26,6 +26,7 @@\n \n with Ada.Characters.Handling; use Ada.Characters.Handling;\n \n+with Debug;\n with Output;   use Output;\n with Osint;    use Osint;\n with Prj.Attr;\n@@ -34,21 +35,28 @@ with Prj.Err;  use Prj.Err;\n with Snames;   use Snames;\n with Uintp;    use Uintp;\n \n-with GNAT.Case_Util; use GNAT.Case_Util;\n+with System.Case_Util; use System.Case_Util;\n \n package body Prj is\n \n+   Object_Suffix : constant String := Get_Target_Object_Suffix.all;\n+   --  File suffix for object files\n+\n    Initial_Buffer_Size : constant := 100;\n    --  Initial size for extensible buffer used in Add_To_Buffer\n \n+   Current_Mode : Mode := Ada_Only;\n+\n+   Configuration_Mode : Boolean := False;\n+\n    The_Empty_String : Name_Id;\n \n    Name_C_Plus_Plus : Name_Id;\n \n    Default_Ada_Spec_Suffix_Id : File_Name_Type;\n    Default_Ada_Body_Suffix_Id : File_Name_Type;\n-   Slash_Id                   : File_Name_Type;\n-   --  Initialized in Prj.Initialized, then never modified\n+   Slash_Id                   : Path_Name_Type;\n+   --  Initialized in Prj.Initialize, then never modified\n \n    subtype Known_Casing is Casing_Type range All_Upper_Case .. Mixed_Case;\n \n@@ -63,29 +71,27 @@ package body Prj is\n                                 File_Name_Type\n                                   (First_Name_Id + Character'Pos ('-'));\n \n-   Std_Naming_Data : Naming_Data :=\n-     (Dot_Replacement           => Standard_Dot_Replacement,\n-      Dot_Repl_Loc              => No_Location,\n-      Casing                    => All_Lower_Case,\n-      Spec_Suffix               => No_Array_Element,\n-      Ada_Spec_Suffix           => No_File,\n-      Spec_Suffix_Loc           => No_Location,\n-      Impl_Suffixes             => No_Impl_Suffixes,\n-      Supp_Suffixes             => No_Supp_Language_Index,\n-      Body_Suffix               => No_Array_Element,\n-      Ada_Body_Suffix           => No_File,\n-      Body_Suffix_Loc           => No_Location,\n-      Separate_Suffix           => No_File,\n-      Sep_Suffix_Loc            => No_Location,\n-      Specs                     => No_Array_Element,\n-      Bodies                    => No_Array_Element,\n-      Specification_Exceptions  => No_Array_Element,\n-      Implementation_Exceptions => No_Array_Element);\n-\n-   Project_Empty : Project_Data :=\n+   Std_Naming_Data : constant Naming_Data :=\n+                       (Dot_Replacement           => Standard_Dot_Replacement,\n+                        Dot_Repl_Loc              => No_Location,\n+                        Casing                    => All_Lower_Case,\n+                        Spec_Suffix               => No_Array_Element,\n+                        Ada_Spec_Suffix_Loc       => No_Location,\n+                        Body_Suffix               => No_Array_Element,\n+                        Ada_Body_Suffix_Loc       => No_Location,\n+                        Separate_Suffix           => No_File,\n+                        Sep_Suffix_Loc            => No_Location,\n+                        Specs                     => No_Array_Element,\n+                        Bodies                    => No_Array_Element,\n+                        Specification_Exceptions  => No_Array_Element,\n+                        Implementation_Exceptions => No_Array_Element,\n+                        Impl_Suffixes             => No_Impl_Suffixes,\n+                        Supp_Suffixes             => No_Supp_Language_Index);\n+\n+   Project_Empty : constant Project_Data :=\n      (Externally_Built               => False,\n-      Languages                      => No_Languages,\n-      Supp_Languages                 => No_Supp_Language_Index,\n+      Config                         => Default_Project_Config,\n+      Languages                      => No_Name_List,\n       First_Referred_By              => No_Project,\n       Name                           => No_Name,\n       Display_Name                   => No_Name,\n@@ -104,22 +110,24 @@ package body Prj is\n       Display_Library_Src_Dir        => No_Path,\n       Library_ALI_Dir                => No_Path,\n       Display_Library_ALI_Dir        => No_Path,\n-      Library_Name                   => No_File,\n+      Library_Name                   => No_Name,\n       Library_Kind                   => Static,\n-      Lib_Internal_Name              => No_File,\n+      Lib_Internal_Name              => No_Name,\n       Standalone_Library             => False,\n       Lib_Interface_ALIs             => Nil_String,\n       Lib_Auto_Init                  => False,\n       Libgnarl_Needed                => Unknown,\n       Symbol_Data                    => No_Symbols,\n-      Ada_Sources_Present            => True,\n-      Other_Sources_Present          => True,\n+      Ada_Sources                    => Nil_String,\n       Sources                        => Nil_String,\n-      First_Other_Source             => No_Other_Source,\n-      Last_Other_Source              => No_Other_Source,\n+      First_Source                   => No_Source,\n+      Last_Source                    => No_Source,\n+      Unit_Based_Language_Name       => No_Name,\n+      Unit_Based_Language_Index      => No_Language_Index,\n       Imported_Directories_Switches  => null,\n       Include_Path                   => null,\n       Include_Data_Set               => False,\n+      Include_Language               => No_Language_Index,\n       Source_Dirs                    => Nil_String,\n       Known_Order_Of_Source_Dirs     => True,\n       Object_Directory               => No_Path,\n@@ -130,27 +138,45 @@ package body Prj is\n       Extends                        => No_Project,\n       Extended_By                    => No_Project,\n       Naming                         => Std_Naming_Data,\n-      First_Language_Processing      => Default_First_Language_Processing_Data,\n-      Supp_Language_Processing       => No_Supp_Language_Index,\n-      Default_Linker                 => No_File,\n-      Default_Linker_Path            => No_Path,\n+      First_Language_Processing      => No_Language_Index,\n       Decl                           => No_Declarations,\n       Imported_Projects              => Empty_Project_List,\n       All_Imported_Projects          => Empty_Project_List,\n       Ada_Include_Path               => null,\n       Ada_Objects_Path               => null,\n+      Objects_Path                   => null,\n       Include_Path_File              => No_Path,\n       Objects_Path_File_With_Libs    => No_Path,\n       Objects_Path_File_Without_Libs => No_Path,\n       Config_File_Name               => No_Path,\n       Config_File_Temp               => False,\n+      Linker_Name                    => No_File,\n+      Linker_Path                    => No_Path,\n+      Minimum_Linker_Options         => No_Name_List,\n       Config_Checked                 => False,\n-      Language_Independent_Checked   => False,\n       Checked                        => False,\n       Seen                           => False,\n       Need_To_Build_Lib              => False,\n       Depth                          => 0,\n-      Unkept_Comments                => False);\n+      Unkept_Comments                => False,\n+      Langs                          => No_Languages,\n+      Supp_Languages                 => No_Supp_Language_Index,\n+      Ada_Sources_Present            => True,\n+      Other_Sources_Present          => True,\n+      First_Other_Source             => No_Other_Source,\n+      Last_Other_Source              => No_Other_Source,\n+      First_Lang_Processing          => Default_First_Language_Processing_Data,\n+      Supp_Language_Processing       => No_Supp_Language_Index);\n+\n+   package Temp_Files is new Table.Table\n+     (Table_Component_Type => Path_Name_Type,\n+      Table_Index_Type     => Integer,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 20,\n+      Table_Increment      => 100,\n+      Table_Name           => \"Makegpr.Temp_Files\");\n+   --  Table to store the path name of all the created temporary files, so that\n+   --  they can be deleted at the end, or when the program is interrupted.\n \n    -----------------------\n    -- Add_Language_Name --\n@@ -183,7 +209,8 @@ package body Prj is\n \n       while Last + S'Length > To'Last loop\n          declare\n-            New_Buffer : constant  String_Access := new String (1 .. 2 * Last);\n+            New_Buffer : constant  String_Access :=\n+                           new String (1 .. 2 * Last);\n \n          begin\n             New_Buffer (1 .. Last) := To (1 .. Last);\n@@ -196,6 +223,124 @@ package body Prj is\n       Last := Last + S'Length;\n    end Add_To_Buffer;\n \n+   -----------------------\n+   -- Body_Suffix_Id_Of --\n+   -----------------------\n+\n+   function Body_Suffix_Id_Of\n+     (In_Tree  : Project_Tree_Ref;\n+      Language : String;\n+      Naming   : Naming_Data) return File_Name_Type\n+   is\n+      Language_Id : Name_Id;\n+      Element_Id  : Array_Element_Id;\n+      Element     : Array_Element;\n+      Suffix      : File_Name_Type := No_File;\n+      Lang        : Language_Index;\n+\n+   begin\n+      Name_Len := 0;\n+      Add_Str_To_Name_Buffer (Language);\n+      To_Lower (Name_Buffer (1 .. Name_Len));\n+      Language_Id := Name_Find;\n+\n+      Element_Id := Naming.Body_Suffix;\n+      while Element_Id /= No_Array_Element loop\n+         Element := In_Tree.Array_Elements.Table (Element_Id);\n+\n+         if Element.Index = Language_Id then\n+            return File_Name_Type (Element.Value.Value);\n+         end if;\n+\n+         Element_Id := Element.Next;\n+      end loop;\n+\n+      if Current_Mode = Multi_Language then\n+         Lang := In_Tree.First_Language;\n+         while Lang /= No_Language_Index loop\n+            if In_Tree.Languages_Data.Table (Lang).Name = Language_Id then\n+               Suffix :=\n+                 In_Tree.Languages_Data.Table\n+                   (Lang).Config.Naming_Data.Body_Suffix;\n+               exit;\n+            end if;\n+\n+            Lang := In_Tree.Languages_Data.Table (Lang).Next;\n+         end loop;\n+      end if;\n+\n+      return Suffix;\n+   end Body_Suffix_Id_Of;\n+\n+   --------------------\n+   -- Body_Suffix_Of --\n+   --------------------\n+\n+   function Body_Suffix_Of\n+     (In_Tree  : Project_Tree_Ref;\n+      Language : String;\n+      Naming   : Naming_Data) return String\n+   is\n+      Language_Id : Name_Id;\n+      Element_Id  : Array_Element_Id;\n+      Element     : Array_Element;\n+      Suffix      : File_Name_Type := No_File;\n+      Lang        : Language_Index;\n+\n+   begin\n+      Name_Len := 0;\n+      Add_Str_To_Name_Buffer (Language);\n+      To_Lower (Name_Buffer (1 .. Name_Len));\n+      Language_Id := Name_Find;\n+\n+      Element_Id := Naming.Body_Suffix;\n+      while Element_Id /= No_Array_Element loop\n+         Element := In_Tree.Array_Elements.Table (Element_Id);\n+\n+         if Element.Index = Language_Id then\n+            return Get_Name_String (Element.Value.Value);\n+         end if;\n+\n+         Element_Id := Element.Next;\n+      end loop;\n+\n+      if Current_Mode = Multi_Language then\n+         Lang := In_Tree.First_Language;\n+         while Lang /= No_Language_Index loop\n+            if In_Tree.Languages_Data.Table (Lang).Name = Language_Id then\n+               Suffix :=\n+                 File_Name_Type\n+                   (In_Tree.Languages_Data.Table\n+                        (Lang).Config.Naming_Data.Body_Suffix);\n+               exit;\n+            end if;\n+\n+            Lang := In_Tree.Languages_Data.Table (Lang).Next;\n+         end loop;\n+\n+         if Suffix /= No_File then\n+            return Get_Name_String (Suffix);\n+         end if;\n+      end if;\n+\n+      return \"\";\n+   end Body_Suffix_Of;\n+\n+   function Body_Suffix_Of\n+     (Language   : Language_Index;\n+      In_Project : Project_Data;\n+      In_Tree    : Project_Tree_Ref) return String\n+   is\n+      Suffix_Id : constant File_Name_Type :=\n+                    Suffix_Of (Language, In_Project, In_Tree);\n+   begin\n+      if Suffix_Id /= No_File then\n+         return Get_Name_String (Suffix_Id);\n+      else\n+         return \".\" & Get_Name_String (Language_Names.Table (Language));\n+      end if;\n+   end Body_Suffix_Of;\n+\n    -----------------------------\n    -- Default_Ada_Body_Suffix --\n    -----------------------------\n@@ -214,6 +359,70 @@ package body Prj is\n       return Default_Ada_Spec_Suffix_Id;\n    end Default_Ada_Spec_Suffix;\n \n+   ----------------------\n+   -- Default_Language --\n+   ----------------------\n+\n+   function Default_Language (In_Tree : Project_Tree_Ref) return Name_Id is\n+   begin\n+      return In_Tree.Default_Language;\n+   end Default_Language;\n+\n+   ---------------------------\n+   -- Delete_All_Temp_Files --\n+   ---------------------------\n+\n+   procedure Delete_All_Temp_Files is\n+      Dont_Care : Boolean;\n+   begin\n+      if not Debug.Debug_Flag_N then\n+         for Index in 1 .. Temp_Files.Last loop\n+            Delete_File\n+              (Get_Name_String (Temp_Files.Table (Index)), Dont_Care);\n+         end loop;\n+      end if;\n+   end Delete_All_Temp_Files;\n+\n+   ---------------------\n+   -- Dependency_Name --\n+   ---------------------\n+\n+   function Dependency_Name\n+     (Source_File_Name : File_Name_Type;\n+      Dependency       : Dependency_File_Kind) return File_Name_Type\n+   is\n+   begin\n+      case Dependency is\n+         when None =>\n+            return No_File;\n+\n+         when Makefile =>\n+            return\n+              File_Name_Type\n+                (Extend_Name\n+                   (Source_File_Name, Makefile_Dependency_Suffix));\n+\n+         when ALI_File =>\n+            return\n+              File_Name_Type\n+                (Extend_Name\n+                   (Source_File_Name, ALI_Dependency_Suffix));\n+      end case;\n+   end Dependency_Name;\n+\n+   ---------------------------\n+   -- Display_Language_Name --\n+   ---------------------------\n+\n+   procedure Display_Language_Name\n+     (In_Tree  : Project_Tree_Ref;\n+      Language : Language_Index)\n+   is\n+   begin\n+      Get_Name_String (In_Tree.Languages_Data.Table (Language).Display_Name);\n+      Write_Str (Name_Buffer (1 .. Name_Len));\n+   end Display_Language_Name;\n+\n    ---------------------------\n    -- Display_Language_Name --\n    ---------------------------\n@@ -225,16 +434,31 @@ package body Prj is\n       Write_Str (Name_Buffer (1 .. Name_Len));\n    end Display_Language_Name;\n \n+   ----------------\n+   -- Empty_File --\n+   ----------------\n+\n+   function Empty_File return File_Name_Type is\n+   begin\n+      return File_Name_Type (The_Empty_String);\n+   end Empty_File;\n+\n    -------------------\n    -- Empty_Project --\n    -------------------\n \n-   function Empty_Project (Tree : Project_Tree_Ref)  return Project_Data is\n+   function Empty_Project (Tree : Project_Tree_Ref) return Project_Data is\n       Value : Project_Data;\n+\n    begin\n       Prj.Initialize (Tree => No_Project_Tree);\n       Value := Project_Empty;\n       Value.Naming := Tree.Private_Part.Default_Naming;\n+\n+      if Current_Mode = Multi_Language then\n+         Value.Config := Tree.Config;\n+      end if;\n+\n       return Value;\n    end Empty_Project;\n \n@@ -258,6 +482,38 @@ package body Prj is\n       end if;\n    end Expect;\n \n+   -----------------\n+   -- Extend_Name --\n+   -----------------\n+\n+   function Extend_Name\n+     (File        : File_Name_Type;\n+      With_Suffix : String) return File_Name_Type\n+   is\n+      Last : Positive;\n+\n+   begin\n+      Get_Name_String (File);\n+      Last := Name_Len + 1;\n+\n+      while Name_Len /= 0 and then Name_Buffer (Name_Len) /= '.' loop\n+         Name_Len := Name_Len - 1;\n+      end loop;\n+\n+      if Name_Len <= 1 then\n+         Name_Len := Last;\n+      end if;\n+\n+      for J in With_Suffix'Range loop\n+         Name_Buffer (Name_Len) := With_Suffix (J);\n+         Name_Len := Name_Len + 1;\n+      end loop;\n+\n+      Name_Len := Name_Len - 1;\n+      return Name_Find;\n+\n+   end Extend_Name;\n+\n    --------------------------------\n    -- For_Every_Project_Imported --\n    --------------------------------\n@@ -278,7 +534,6 @@ package body Prj is\n \n       procedure Recursive_Check (Project : Project_Id) is\n          List : Project_List;\n-\n       begin\n          if not In_Tree.Projects.Table (Project).Seen then\n             In_Tree.Projects.Table (Project).Seen := True;\n@@ -305,16 +560,30 @@ package body Prj is\n       Recursive_Check (Project => By);\n    end For_Every_Project_Imported;\n \n+   --------------\n+   -- Get_Mode --\n+   --------------\n+\n+   function Get_Mode return Mode is\n+   begin\n+      return Current_Mode;\n+   end Get_Mode;\n+\n    ----------\n    -- Hash --\n    ----------\n \n+   function Hash (Name : File_Name_Type) return Header_Num is\n+   begin\n+      return Hash (Get_Name_String (Name));\n+   end Hash;\n+\n    function Hash (Name : Name_Id) return Header_Num is\n    begin\n       return Hash (Get_Name_String (Name));\n    end Hash;\n \n-   function Hash (Name : File_Name_Type) return Header_Num is\n+   function Hash (Name : Path_Name_Type) return Header_Num is\n    begin\n       return Hash (Get_Name_String (Name));\n    end Hash;\n@@ -328,6 +597,15 @@ package body Prj is\n       return The_Casing_Images (Casing).all;\n    end Image;\n \n+   ----------------------\n+   -- In_Configuration --\n+   ----------------------\n+\n+   function In_Configuration return Boolean is\n+   begin\n+      return Configuration_Mode;\n+   end In_Configuration;\n+\n    ----------------\n    -- Initialize --\n    ----------------\n@@ -353,10 +631,6 @@ package body Prj is\n          Name_Buffer (1 .. 3) := \"c++\";\n          Name_C_Plus_Plus := Name_Find;\n \n-         Std_Naming_Data.Ada_Spec_Suffix := Default_Ada_Spec_Suffix;\n-         Std_Naming_Data.Ada_Body_Suffix := Default_Ada_Body_Suffix;\n-         Std_Naming_Data.Separate_Suffix := Default_Ada_Body_Suffix;\n-         Project_Empty.Naming := Std_Naming_Data;\n          Prj.Env.Initialize;\n          Prj.Attr.Initialize;\n          Set_Name_Table_Byte (Name_Project,  Token_Type'Pos (Tok_Project));\n@@ -376,6 +650,84 @@ package body Prj is\n       end if;\n    end Initialize;\n \n+   -------------------\n+   -- Is_A_Language --\n+   -------------------\n+\n+   function Is_A_Language\n+     (Tree          : Project_Tree_Ref;\n+      Data          : Project_Data;\n+      Language_Name : String) return Boolean\n+   is\n+      Lang_Id : Name_Id;\n+\n+   begin\n+      Name_Len := 0;\n+      Add_Str_To_Name_Buffer (Language_Name);\n+      To_Lower (Name_Buffer (1 .. Name_Len));\n+      Lang_Id := Name_Find;\n+\n+      if Get_Mode = Ada_Only then\n+         declare\n+            List : Name_List_Index := Data.Languages;\n+\n+         begin\n+            while List /= No_Name_List loop\n+               if Tree.Name_Lists.Table (List).Name = Lang_Id then\n+                  return True;\n+\n+               else\n+                  List := Tree.Name_Lists.Table (List).Next;\n+               end if;\n+            end loop;\n+         end;\n+\n+      else\n+         declare\n+            Lang_Ind  : Language_Index;\n+            Lang_Data : Language_Data;\n+\n+         begin\n+            Lang_Ind := Data.First_Language_Processing;\n+            while Lang_Ind /= No_Language_Index loop\n+               Lang_Data := Tree.Languages_Data.Table (Lang_Ind);\n+\n+               if Lang_Data.Name = Lang_Id then\n+                  return True;\n+               end if;\n+\n+               Lang_Ind := Lang_Data.Next;\n+            end loop;\n+         end;\n+      end if;\n+\n+      return False;\n+   end Is_A_Language;\n+\n+   ------------------\n+   -- Is_Extending --\n+   ------------------\n+\n+   function Is_Extending\n+     (Extending : Project_Id;\n+      Extended  : Project_Id;\n+      In_Tree   : Project_Tree_Ref) return Boolean\n+   is\n+      Proj : Project_Id;\n+\n+   begin\n+      Proj := Extending;\n+      while Proj /= No_Project loop\n+         if Proj = Extended then\n+            return True;\n+         end if;\n+\n+         Proj := In_Tree.Projects.Table (Proj).Extends;\n+      end loop;\n+\n+      return False;\n+   end Is_Extending;\n+\n    ----------------\n    -- Is_Present --\n    ----------------\n@@ -391,7 +743,7 @@ package body Prj is\n             return False;\n \n          when First_Language_Indexes =>\n-            return In_Project.Languages (Language);\n+            return In_Project.Langs (Language);\n \n          when others =>\n             declare\n@@ -429,7 +781,7 @@ package body Prj is\n             return Default_Language_Processing_Data;\n \n          when First_Language_Indexes =>\n-            return In_Project.First_Language_Processing (Language);\n+            return In_Project.First_Lang_Processing (Language);\n \n          when others =>\n             declare\n@@ -453,6 +805,62 @@ package body Prj is\n       end case;\n    end Language_Processing_Data_Of;\n \n+   -----------------------\n+   -- Objects_Exist_For --\n+   -----------------------\n+\n+   function Objects_Exist_For\n+     (Language : String;\n+      In_Tree  : Project_Tree_Ref) return Boolean\n+   is\n+      Language_Id : Name_Id;\n+      Lang        : Language_Index;\n+\n+   begin\n+      if Current_Mode = Multi_Language then\n+         Name_Len := 0;\n+         Add_Str_To_Name_Buffer (Language);\n+         To_Lower (Name_Buffer (1 .. Name_Len));\n+         Language_Id := Name_Find;\n+\n+         Lang := In_Tree.First_Language;\n+\n+         while Lang /= No_Language_Index loop\n+            if In_Tree.Languages_Data.Table (Lang).Name = Language_Id then\n+               return\n+                 In_Tree.Languages_Data.Table\n+                   (Lang).Config.Objects_Generated;\n+            end if;\n+\n+            Lang := In_Tree.Languages_Data.Table (Lang).Next;\n+         end loop;\n+      end if;\n+\n+      return True;\n+   end Objects_Exist_For;\n+\n+   -----------------\n+   -- Object_Name --\n+   -----------------\n+\n+   function Object_Name\n+     (Source_File_Name : File_Name_Type)\n+      return File_Name_Type\n+   is\n+   begin\n+      return Extend_Name (Source_File_Name, Object_Suffix);\n+   end Object_Name;\n+\n+   ----------------------\n+   -- Record_Temp_File --\n+   ----------------------\n+\n+   procedure Record_Temp_File (Path : Path_Name_Type) is\n+   begin\n+      Temp_Files.Increment_Last;\n+      Temp_Files.Table (Temp_Files.Last) := Path;\n+   end Record_Temp_File;\n+\n    ------------------------------------\n    -- Register_Default_Naming_Scheme --\n    ------------------------------------\n@@ -463,9 +871,9 @@ package body Prj is\n       Default_Body_Suffix : File_Name_Type;\n       In_Tree             : Project_Tree_Ref)\n    is\n-      Lang    : Name_Id;\n-      Suffix  : Array_Element_Id;\n-      Found   : Boolean := False;\n+      Lang : Name_Id;\n+      Suffix : Array_Element_Id;\n+      Found : Boolean := False;\n       Element : Array_Element;\n \n    begin\n@@ -508,12 +916,10 @@ package body Prj is\n                       Value    => Name_Id (Default_Spec_Suffix),\n                       Index    => 0),\n             Next  => In_Tree.Private_Part.Default_Naming.Spec_Suffix);\n-\n          Array_Element_Table.Increment_Last (In_Tree.Array_Elements);\n-\n          In_Tree.Array_Elements.Table\n-           (Array_Element_Table.Last (In_Tree.Array_Elements)) := Element;\n-\n+           (Array_Element_Table.Last (In_Tree.Array_Elements)) :=\n+            Element;\n          In_Tree.Private_Part.Default_Naming.Spec_Suffix :=\n            Array_Element_Table.Last (In_Tree.Array_Elements);\n       end if;\n@@ -566,36 +972,60 @@ package body Prj is\n    -----------\n \n    procedure Reset (Tree : Project_Tree_Ref) is\n+\n+      --  Def_Lang : constant Name_Node :=\n+      --             (Name => Name_Ada,\n+      --              Next => No_Name_List);\n+      --  Why is the above commented out ???\n+\n    begin\n       Prj.Env.Initialize;\n+\n+      --  gprmake tables\n+\n       Present_Language_Table.Init (Tree.Present_Languages);\n       Supp_Suffix_Table.Init      (Tree.Supp_Suffixes);\n-      Name_List_Table.Init        (Tree.Name_Lists);\n       Supp_Language_Table.Init    (Tree.Supp_Languages);\n       Other_Source_Table.Init     (Tree.Other_Sources);\n-      String_Element_Table.Init   (Tree.String_Elements);\n-      Variable_Element_Table.Init (Tree.Variable_Elements);\n-      Array_Element_Table.Init    (Tree.Array_Elements);\n-      Array_Table.Init            (Tree.Arrays);\n-      Package_Table.Init          (Tree.Packages);\n-      Project_List_Table.Init     (Tree.Project_Lists);\n-      Project_Table.Init          (Tree.Projects);\n-      Unit_Table.Init             (Tree.Units);\n-      Units_Htable.Reset          (Tree.Units_HT);\n-      Files_Htable.Reset          (Tree.Files_HT);\n-      Naming_Table.Init           (Tree.Private_Part.Namings);\n-      Naming_Table.Increment_Last (Tree.Private_Part.Namings);\n+\n+      --  Visible tables\n+\n+      Language_Data_Table.Init      (Tree.Languages_Data);\n+      Name_List_Table.Init          (Tree.Name_Lists);\n+      String_Element_Table.Init     (Tree.String_Elements);\n+      Variable_Element_Table.Init   (Tree.Variable_Elements);\n+      Array_Element_Table.Init      (Tree.Array_Elements);\n+      Array_Table.Init              (Tree.Arrays);\n+      Package_Table.Init            (Tree.Packages);\n+      Project_List_Table.Init       (Tree.Project_Lists);\n+      Project_Table.Init            (Tree.Projects);\n+      Source_Data_Table.Init        (Tree.Sources);\n+      Alternate_Language_Table.Init (Tree.Alt_Langs);\n+      Unit_Table.Init               (Tree.Units);\n+      Units_Htable.Reset            (Tree.Units_HT);\n+      Files_Htable.Reset            (Tree.Files_HT);\n+      Source_Paths_Htable.Reset     (Tree.Source_Paths_HT);\n+\n+      --  Private part table\n+\n+      Naming_Table.Init             (Tree.Private_Part.Namings);\n+      Naming_Table.Increment_Last   (Tree.Private_Part.Namings);\n       Tree.Private_Part.Namings.Table\n         (Naming_Table.Last (Tree.Private_Part.Namings)) := Std_Naming_Data;\n       Path_File_Table.Init        (Tree.Private_Part.Path_Files);\n       Source_Path_Table.Init      (Tree.Private_Part.Source_Paths);\n       Object_Path_Table.Init      (Tree.Private_Part.Object_Paths);\n       Tree.Private_Part.Default_Naming := Std_Naming_Data;\n-      Register_Default_Naming_Scheme\n-        (Language            => Name_Ada,\n-         Default_Spec_Suffix => Default_Ada_Spec_Suffix,\n-         Default_Body_Suffix => Default_Ada_Body_Suffix,\n-         In_Tree             => Tree);\n+\n+      if Current_Mode = Ada_Only then\n+         Register_Default_Naming_Scheme\n+           (Language            => Name_Ada,\n+            Default_Spec_Suffix => Default_Ada_Spec_Suffix,\n+            Default_Body_Suffix => Default_Ada_Body_Suffix,\n+            In_Tree             => Tree);\n+         Tree.Private_Part.Default_Naming.Separate_Suffix :=\n+           Default_Ada_Body_Suffix;\n+      end if;\n    end Reset;\n \n    ------------------------\n@@ -608,8 +1038,6 @@ package body Prj is\n    begin\n       return Left.Dot_Replacement = Right.Dot_Replacement\n         and then Left.Casing = Right.Casing\n-        and then Left.Ada_Spec_Suffix = Right.Ada_Spec_Suffix\n-        and then Left.Ada_Body_Suffix = Right.Ada_Body_Suffix\n         and then Left.Separate_Suffix = Right.Separate_Suffix;\n    end Same_Naming_Scheme;\n \n@@ -629,7 +1057,7 @@ package body Prj is\n             null;\n \n          when First_Language_Indexes =>\n-            In_Project.Languages (Language) := Present;\n+            In_Project.Langs (Language) := Present;\n \n          when others =>\n             declare\n@@ -675,16 +1103,16 @@ package body Prj is\n             null;\n \n          when First_Language_Indexes =>\n-            In_Project.First_Language_Processing (For_Language) :=\n+            In_Project.First_Lang_Processing (For_Language) :=\n               Language_Processing;\n \n          when others =>\n             declare\n                Supp : Supp_Language_Data;\n-               Supp_Index : Supp_Language_Index :=\n-                 In_Project.Supp_Language_Processing;\n+               Supp_Index : Supp_Language_Index;\n \n             begin\n+               Supp_Index := In_Project.Supp_Language_Processing;\n                while Supp_Index /= No_Supp_Language_Index loop\n                   Supp := In_Tree.Supp_Languages.Table (Supp_Index);\n \n@@ -755,15 +1183,216 @@ package body Prj is\n       end case;\n    end Set;\n \n+   ---------------------\n+   -- Set_Body_Suffix --\n+   ---------------------\n+\n+   procedure Set_Body_Suffix\n+     (In_Tree  : Project_Tree_Ref;\n+      Language : String;\n+      Naming   : in out Naming_Data;\n+      Suffix   : File_Name_Type)\n+   is\n+      Language_Id : Name_Id;\n+      Element     : Array_Element;\n+\n+   begin\n+      Name_Len := 0;\n+      Add_Str_To_Name_Buffer (Language);\n+      To_Lower (Name_Buffer (1 .. Name_Len));\n+      Language_Id := Name_Find;\n+\n+      Element :=\n+        (Index                => Language_Id,\n+         Src_Index            => 0,\n+         Index_Case_Sensitive => False,\n+         Value                =>\n+           (Kind     => Single,\n+            Project  => No_Project,\n+            Location => No_Location,\n+            Default  => False,\n+            Value    => Name_Id (Suffix),\n+            Index    => 0),\n+         Next                 => Naming.Body_Suffix);\n+\n+      Array_Element_Table.Increment_Last (In_Tree.Array_Elements);\n+      Naming.Body_Suffix :=\n+         Array_Element_Table.Last (In_Tree.Array_Elements);\n+      In_Tree.Array_Elements.Table (Naming.Body_Suffix) := Element;\n+   end Set_Body_Suffix;\n+\n+   --------------------------\n+   -- Set_In_Configuration --\n+   --------------------------\n+\n+   procedure Set_In_Configuration (Value : Boolean) is\n+   begin\n+      Configuration_Mode := Value;\n+   end Set_In_Configuration;\n+\n+   --------------\n+   -- Set_Mode --\n+   --------------\n+\n+   procedure Set_Mode (New_Mode : Mode) is\n+   begin\n+      Current_Mode := New_Mode;\n+   end Set_Mode;\n+\n+   ---------------------\n+   -- Set_Spec_Suffix --\n+   ---------------------\n+\n+   procedure Set_Spec_Suffix\n+     (In_Tree  : Project_Tree_Ref;\n+      Language : String;\n+      Naming   : in out Naming_Data;\n+      Suffix   : File_Name_Type)\n+   is\n+      Language_Id : Name_Id;\n+      Element     : Array_Element;\n+\n+   begin\n+      Name_Len := 0;\n+      Add_Str_To_Name_Buffer (Language);\n+      To_Lower (Name_Buffer (1 .. Name_Len));\n+      Language_Id := Name_Find;\n+\n+      Element :=\n+        (Index                => Language_Id,\n+         Src_Index            => 0,\n+         Index_Case_Sensitive => False,\n+         Value                =>\n+           (Kind     => Single,\n+            Project  => No_Project,\n+            Location => No_Location,\n+            Default  => False,\n+            Value    => Name_Id (Suffix),\n+            Index    => 0),\n+         Next                 => Naming.Spec_Suffix);\n+\n+      Array_Element_Table.Increment_Last (In_Tree.Array_Elements);\n+      Naming.Spec_Suffix :=\n+        Array_Element_Table.Last (In_Tree.Array_Elements);\n+      In_Tree.Array_Elements.Table (Naming.Spec_Suffix) := Element;\n+   end Set_Spec_Suffix;\n+\n    -----------\n    -- Slash --\n    -----------\n \n-   function Slash return File_Name_Type is\n+   function Slash return Path_Name_Type is\n    begin\n       return Slash_Id;\n    end Slash;\n \n+   -----------------------\n+   -- Spec_Suffix_Id_Of --\n+   -----------------------\n+\n+   function Spec_Suffix_Id_Of\n+     (In_Tree  : Project_Tree_Ref;\n+      Language : String;\n+      Naming   : Naming_Data) return File_Name_Type\n+   is\n+      Language_Id : Name_Id;\n+      Element_Id  : Array_Element_Id;\n+      Element     : Array_Element;\n+      Suffix      : File_Name_Type := No_File;\n+      Lang        : Language_Index;\n+\n+   begin\n+      Name_Len := 0;\n+      Add_Str_To_Name_Buffer (Language);\n+      To_Lower (Name_Buffer (1 .. Name_Len));\n+      Language_Id := Name_Find;\n+\n+      Element_Id := Naming.Spec_Suffix;\n+\n+      while Element_Id /= No_Array_Element loop\n+         Element := In_Tree.Array_Elements.Table (Element_Id);\n+\n+         if Element.Index = Language_Id then\n+            return File_Name_Type (Element.Value.Value);\n+         end if;\n+\n+         Element_Id := Element.Next;\n+      end loop;\n+\n+      if Current_Mode = Multi_Language then\n+         Lang := In_Tree.First_Language;\n+\n+         while Lang /= No_Language_Index loop\n+            if In_Tree.Languages_Data.Table (Lang).Name = Language_Id then\n+               Suffix :=\n+                 In_Tree.Languages_Data.Table\n+                   (Lang).Config.Naming_Data.Spec_Suffix;\n+               exit;\n+            end if;\n+\n+            Lang := In_Tree.Languages_Data.Table (Lang).Next;\n+         end loop;\n+      end if;\n+\n+      return Suffix;\n+   end Spec_Suffix_Id_Of;\n+\n+   --------------------\n+   -- Spec_Suffix_Of --\n+   --------------------\n+\n+   function Spec_Suffix_Of\n+     (In_Tree  : Project_Tree_Ref;\n+      Language : String;\n+      Naming   : Naming_Data) return String\n+   is\n+      Language_Id : Name_Id;\n+      Element_Id  : Array_Element_Id;\n+      Element     : Array_Element;\n+      Suffix      : File_Name_Type := No_File;\n+      Lang        : Language_Index;\n+\n+   begin\n+      Name_Len := 0;\n+      Add_Str_To_Name_Buffer (Language);\n+      To_Lower (Name_Buffer (1 .. Name_Len));\n+      Language_Id := Name_Find;\n+\n+      Element_Id := Naming.Spec_Suffix;\n+\n+      while Element_Id /= No_Array_Element loop\n+         Element := In_Tree.Array_Elements.Table (Element_Id);\n+\n+         if Element.Index = Language_Id then\n+            return Get_Name_String (Element.Value.Value);\n+         end if;\n+\n+         Element_Id := Element.Next;\n+      end loop;\n+\n+      if Current_Mode = Multi_Language then\n+         Lang := In_Tree.First_Language;\n+\n+         while Lang /= No_Language_Index loop\n+            if In_Tree.Languages_Data.Table (Lang).Name = Language_Id then\n+               Suffix :=\n+                 File_Name_Type\n+                   (In_Tree.Languages_Data.Table\n+                      (Lang).Config.Naming_Data.Spec_Suffix);\n+               exit;\n+            end if;\n+\n+            Lang := In_Tree.Languages_Data.Table (Lang).Next;\n+         end loop;\n+\n+         if Suffix /= No_File then\n+            return Get_Name_String (Suffix);\n+         end if;\n+      end if;\n+\n+      return \"\";\n+   end Spec_Suffix_Of;\n+\n    --------------------------\n    -- Standard_Naming_Data --\n    --------------------------\n@@ -820,6 +1449,40 @@ package body Prj is\n       end case;\n    end  Suffix_Of;\n \n+   -------------------\n+   -- Switches_Name --\n+   -------------------\n+\n+   function Switches_Name\n+     (Source_File_Name : File_Name_Type) return File_Name_Type\n+   is\n+   begin\n+      return Extend_Name (Source_File_Name, Switches_Dependency_Suffix);\n+   end Switches_Name;\n+\n+   ---------------------------\n+   -- There_Are_Ada_Sources --\n+   ---------------------------\n+\n+   function There_Are_Ada_Sources\n+     (In_Tree : Project_Tree_Ref;\n+      Project : Project_Id) return Boolean\n+   is\n+      Prj : Project_Id;\n+\n+   begin\n+      Prj := Project;\n+      while Prj /= No_Project loop\n+         if In_Tree.Projects.Table (Prj).Ada_Sources /= Nil_String then\n+            return True;\n+         end if;\n+\n+         Prj := In_Tree.Projects.Table (Prj).Extends;\n+      end loop;\n+\n+      return False;\n+   end There_Are_Ada_Sources;\n+\n    -----------\n    -- Value --\n    -----------\n@@ -836,8 +1499,9 @@ package body Prj is\n    end Value;\n \n begin\n-   --  Make sure that the standard project file extension is compatible\n-   --  with canonical case file naming.\n+   --  Make sure that the standard config and user project file extensions are\n+   --  compatible with canonical case file naming.\n \n+   Canonical_Case_File_Name (Config_Project_File_Extension);\n    Canonical_Case_File_Name (Project_File_Extension);\n end Prj;"}, {"sha": "47bc052cb5d3f46391e0f8b8a62a029c20c77afa", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 975, "deletions": 432, "changes": 1407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -44,6 +44,31 @@ with System.HTable;\n \n package Prj is\n \n+   type Library_Support is (None, Static_Only, Full);\n+   --  Support for Library Project File.\n+   --  - None: Library Project Files are not supported at all\n+   --  - Static_Only: Library Project Files are only supported for static\n+   --    libraries.\n+   --  - Full: Library Project Files are supported for static and dynamic\n+   --    (shared) libraries.\n+\n+   type Yes_No_Unknown is (Yes, No, Unknown);\n+   --  Tri-state to decide if -lgnarl is needed when linking\n+\n+   type Mode is (Multi_Language, Ada_Only);\n+\n+   function Get_Mode return Mode;\n+   pragma Inline (Get_Mode);\n+\n+   procedure Set_Mode (New_Mode : Mode);\n+   pragma Inline (Set_Mode);\n+\n+   function In_Configuration return Boolean;\n+   pragma Inline (In_Configuration);\n+\n+   procedure Set_In_Configuration (Value : Boolean);\n+   pragma Inline (Set_In_Configuration);\n+\n    All_Packages : constant String_List_Access;\n    --  Default value of parameter Packages of procedures Parse, in Prj.Pars and\n    --  Prj.Part, indicating that all packages should be checked.\n@@ -57,21 +82,23 @@ package Prj is\n \n    function Default_Ada_Spec_Suffix return File_Name_Type;\n    pragma Inline (Default_Ada_Spec_Suffix);\n-   --  The Name_Id for the standard GNAT suffix for Ada spec source file\n-   --  name \".ads\". Initialized by Prj.Initialize.\n+   --  The name for the standard GNAT suffix for Ada spec source file name\n+   --  \".ads\". Initialized by Prj.Initialize.\n \n    function Default_Ada_Body_Suffix return File_Name_Type;\n    pragma Inline (Default_Ada_Body_Suffix);\n-   --  The Name_Id for the standard GNAT suffix for Ada body source file\n-   --  name \".adb\". Initialized by Prj.Initialize.\n+   --  The name for the standard GNAT suffix for Ada body source file name\n+   --  \".adb\". Initialized by Prj.Initialize.\n \n-   function Slash return File_Name_Type;\n+   function Slash return Path_Name_Type;\n    pragma Inline (Slash);\n    --  \"/\", used as the path of locally removed files\n \n+   Config_Project_File_Extension : String := \".cgpr\";\n    Project_File_Extension : String := \".gpr\";\n-   --  The standard project file name extension. It is not a constant, because\n-   --  Canonical_Case_File_Name is called on this variable in the body of Prj.\n+   --  The standard config and user project file name extensions. They are not\n+   --  constants, because Canonical_Case_File_Name is called on these variables\n+   --  in the body of Prj.\n \n    type Error_Warning is (Silent, Warning, Error);\n    --  Severity of some situations, such as: no Ada sources in a project where\n@@ -83,109 +110,186 @@ package Prj is\n    --    - Warning: issue a warning, does not cause the tool to fail\n    --    - Error:   issue an error, causes the tool to fail\n \n-   type Yes_No_Unknown is (Yes, No, Unknown);\n-   --  Tri-state to decide if -lgnarl is needed when linking\n+   function Empty_File   return File_Name_Type;\n+   function Empty_String return Name_Id;\n+   --  Return the id for an empty string \"\"\n \n-   -----------------------------------------------------\n-   -- Multi-language Stuff That Will be Modified Soon --\n-   -----------------------------------------------------\n+   type Project_Id is new Nat;\n+   No_Project : constant Project_Id := 0;\n+   --  Id of a Project File\n \n-   --  Still should be properly commented ???\n+   type String_List_Id is new Nat;\n+   Nil_String : constant String_List_Id := 0;\n+   type String_Element is record\n+      Value         : Name_Id        := No_Name;\n+      Index         : Int            := 0;\n+      Display_Value : Name_Id        := No_Name;\n+      Location      : Source_Ptr     := No_Location;\n+      Flag          : Boolean        := False;\n+      Next          : String_List_Id := Nil_String;\n+   end record;\n+   --  To hold values for string list variables and array elements.\n+   --  Component Flag may be used for various purposes. For source\n+   --  directories, it indicates if the directory contains Ada source(s).\n \n-   type Language_Index is new Nat;\n+   package String_Element_Table is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => String_Element,\n+      Table_Index_Type     => String_List_Id,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 200,\n+      Table_Increment      => 100);\n+   --  The table for string elements in string lists\n \n-   No_Language_Index           : constant Language_Index := 0;\n-   First_Language_Index        : constant Language_Index := 1;\n-   First_Language_Indexes_Last : constant Language_Index := 5;\n+   type Variable_Kind is (Undefined, List, Single);\n+   --  Different kinds of variables\n \n-   Ada_Language_Index         : constant Language_Index :=\n-                                  First_Language_Index;\n-   C_Language_Index           : constant Language_Index :=\n-                                  Ada_Language_Index + 1;\n-   C_Plus_Plus_Language_Index : constant Language_Index :=\n-                                  C_Language_Index + 1;\n+   subtype Defined_Variable_Kind is Variable_Kind range List .. Single;\n+   --  The defined kinds of variables\n \n-   Last_Language_Index : Language_Index := No_Language_Index;\n+   Ignored : constant Variable_Kind;\n+   --  Used to indicate that a package declaration must be ignored\n+   --  while processing the project tree (unknown package name).\n \n-   subtype First_Language_Indexes is Language_Index\n-      range First_Language_Index .. First_Language_Indexes_Last;\n+   type Variable_Value (Kind : Variable_Kind := Undefined) is record\n+      Project  : Project_Id := No_Project;\n+      Location : Source_Ptr := No_Location;\n+      Default  : Boolean    := False;\n+      case Kind is\n+         when Undefined =>\n+            null;\n+         when List =>\n+            Values : String_List_Id := Nil_String;\n+         when Single =>\n+            Value : Name_Id := No_Name;\n+            Index : Int     := 0;\n+      end case;\n+   end record;\n+   --  Values for variables and array elements. Default is True if the\n+   --  current value is the default one for the variable\n \n-   type Header_Num is range 0 .. 2047;\n+   Nil_Variable_Value : constant Variable_Value;\n+   --  Value of a non existing variable or array element\n \n-   function Hash is new System.HTable.Hash (Header_Num => Header_Num);\n+   type Variable_Id is new Nat;\n+   No_Variable : constant Variable_Id := 0;\n+   type Variable is record\n+      Next  : Variable_Id := No_Variable;\n+      Name  : Name_Id;\n+      Value : Variable_Value;\n+   end record;\n+   --  To hold the list of variables in a project file and in packages\n \n-   function Hash (Name : Name_Id)        return Header_Num;\n-   function Hash (Name : File_Name_Type) return Header_Num;\n+   package Variable_Element_Table is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Variable,\n+      Table_Index_Type     => Variable_Id,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 200,\n+      Table_Increment      => 100);\n+   --  The table of variable in list of variables\n \n-   package Language_Indexes is new System.HTable.Simple_HTable\n-     (Header_Num => Header_Num,\n-      Element    => Language_Index,\n-      No_Element => No_Language_Index,\n-      Key        => Name_Id,\n-      Hash       => Hash,\n-      Equal      => \"=\");\n-   --  Mapping of language names to language indexes\n+   type Array_Element_Id is new Nat;\n+   No_Array_Element : constant Array_Element_Id := 0;\n+   type Array_Element is record\n+      Index                : Name_Id;\n+      Src_Index            : Int := 0;\n+      Index_Case_Sensitive : Boolean := True;\n+      Value                : Variable_Value;\n+      Next                 : Array_Element_Id := No_Array_Element;\n+   end record;\n+   --  Each Array_Element represents an array element and is linked (Next)\n+   --  to the next array element, if any, in the array.\n \n-   package Language_Names is new Table.Table\n-     (Table_Component_Type => Name_Id,\n-      Table_Index_Type     => Language_Index,\n+   package Array_Element_Table is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Array_Element,\n+      Table_Index_Type     => Array_Element_Id,\n       Table_Low_Bound      => 1,\n-      Table_Initial        => 4,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Prj.Language_Names\");\n-   --  The table for the name of programming languages\n-\n-   procedure Add_Language_Name (Name : Name_Id);\n+      Table_Initial        => 200,\n+      Table_Increment      => 100);\n+   --  The table that contains all array elements\n \n-   procedure Display_Language_Name (Language : Language_Index);\n+   type Array_Id is new Nat;\n+   No_Array : constant Array_Id := 0;\n+   type Array_Data is record\n+      Name  : Name_Id          := No_Name;\n+      Value : Array_Element_Id := No_Array_Element;\n+      Next  : Array_Id         := No_Array;\n+   end record;\n+   --  Each Array_Data value represents an array.\n+   --  Value is the id of the first element.\n+   --  Next is the id of the next array in the project file or package.\n \n-   type Languages_In_Project is array (First_Language_Indexes) of Boolean;\n-   --  Set of supported languages used in a project\n+   package Array_Table is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Array_Data,\n+      Table_Index_Type     => Array_Id,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 200,\n+      Table_Increment      => 100);\n+   --  The table that contains all arrays\n \n-   No_Languages : constant Languages_In_Project := (others => False);\n-   --  No supported languages are used\n+   type Package_Id is new Nat;\n+   No_Package : constant Package_Id := 0;\n+   type Declarations is record\n+      Variables  : Variable_Id := No_Variable;\n+      Attributes : Variable_Id := No_Variable;\n+      Arrays     : Array_Id    := No_Array;\n+      Packages   : Package_Id  := No_Package;\n+   end record;\n+   --  Contains the declarations (variables, single and array attributes,\n+   --  packages) for a project or a package in a project.\n \n-   type Supp_Language_Index is new Nat;\n-   No_Supp_Language_Index  : constant Supp_Language_Index := 0;\n+   No_Declarations : constant Declarations :=\n+     (Variables  => No_Variable,\n+      Attributes => No_Variable,\n+      Arrays     => No_Array,\n+      Packages   => No_Package);\n+   --  Default value of Declarations: indicates that there is no declarations\n \n-   type Supp_Language is record\n-      Index   : Language_Index := No_Language_Index;\n-      Present : Boolean := False;\n-      Next    : Supp_Language_Index := No_Supp_Language_Index;\n+   type Package_Element is record\n+      Name   : Name_Id      := No_Name;\n+      Decl   : Declarations := No_Declarations;\n+      Parent : Package_Id   := No_Package;\n+      Next   : Package_Id   := No_Package;\n    end record;\n+   --  A package (includes declarations that may include other packages)\n \n-   package Present_Language_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Supp_Language,\n-      Table_Index_Type     => Supp_Language_Index,\n+   package Package_Table is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Package_Element,\n+      Table_Index_Type     => Package_Id,\n       Table_Low_Bound      => 1,\n-      Table_Initial        => 4,\n+      Table_Initial        => 100,\n       Table_Increment      => 100);\n-   --  The table for the presence of languages with an index that is outside\n-   --  of First_Language_Indexes.\n+   --  The table that contains all packages\n \n-   type Impl_Suffix_Array is array (First_Language_Indexes) of File_Name_Type;\n-   --  Suffixes for the non spec sources of the different supported languages\n-   --  in a project.\n+   type Language_Index is new Nat;\n \n-   No_Impl_Suffixes : constant Impl_Suffix_Array := (others => No_File);\n-   --  A default value for the non spec source suffixes\n+   No_Language_Index : constant Language_Index := 0;\n \n-   type Supp_Suffix is record\n-      Index   : Language_Index      := No_Language_Index;\n-      Suffix  : File_Name_Type      := No_File;\n-      Next    : Supp_Language_Index := No_Supp_Language_Index;\n-   end record;\n+   procedure Display_Language_Name\n+     (In_Tree  : Project_Tree_Ref;\n+      Language : Language_Index);\n \n-   package Supp_Suffix_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Supp_Suffix,\n-      Table_Index_Type     => Supp_Language_Index,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 4,\n-      Table_Increment      => 100);\n-   --  The table for the presence of languages with an index that is outside\n-   --  of First_Language_Indexes.\n+   type Header_Num is range 0 .. 2047;\n \n-   type Language_Kind is (GNU, other);\n+   function Hash is new System.HTable.Hash (Header_Num => Header_Num);\n+\n+   function Hash (Name : Name_Id)        return Header_Num;\n+   function Hash (Name : File_Name_Type) return Header_Num;\n+   function Hash (Name : Path_Name_Type) return Header_Num;\n+\n+   type Language_Kind is (File_Based, Unit_Based);\n+\n+   type Dependency_File_Kind is (None, Makefile, ALI_File);\n+\n+   Makefile_Dependency_Suffix : constant String := \".d\";\n+   ALI_Dependency_Suffix      : constant String := \".ali\";\n+\n+   Switches_Dependency_Suffix : constant String := \".cswi\";\n+\n+   Binder_Exchange_Suffix     : constant String := \".bexch\";\n+   --  Suffix for binder exchange files\n+\n+   Library_Exchange_Suffix     : constant String := \".lexch\";\n+   --  Suffix for library exchange files\n \n    type Name_List_Index is new Nat;\n    No_Name_List            : constant Name_List_Index := 0;\n@@ -195,6 +299,8 @@ package Prj is\n       Next : Name_List_Index := No_Name_List;\n    end record;\n \n+   function Default_Language (In_Tree : Project_Tree_Ref) return Name_Id;\n+\n    package Name_List_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => Name_Node,\n       Table_Index_Type     => Name_List_Index,\n@@ -203,80 +309,293 @@ package Prj is\n       Table_Increment      => 100);\n    --  The table for lists of names used in package Language_Processing\n \n-   type Language_Processing_Data is record\n-      Compiler_Drivers     : Name_List_Index := No_Name_List;\n-      Compiler_Paths       : Name_Id         := No_Name;\n-      Compiler_Kinds       : Language_Kind   := GNU;\n-      Dependency_Options   : Name_List_Index := No_Name_List;\n-      Compute_Dependencies : Name_List_Index := No_Name_List;\n-      Include_Options      : Name_List_Index := No_Name_List;\n-      Binder_Drivers       : Name_Id         := No_Name;\n-      Binder_Driver_Paths  : Name_Id         := No_Name;\n-   end record;\n+   package Mapping_Files_Htable is new Simple_HTable\n+     (Header_Num => Header_Num,\n+      Element    => Path_Name_Type,\n+      No_Element => No_Path,\n+      Key        => Path_Name_Type,\n+      Hash       => Hash,\n+      Equal      => \"=\");\n+   --  A hash table to store the mapping files that are not used\n \n-   Default_Language_Processing_Data :\n-     constant Language_Processing_Data :=\n-       (Compiler_Drivers     => No_Name_List,\n-        Compiler_Paths       => No_Name,\n-        Compiler_Kinds       => GNU,\n-        Dependency_Options   => No_Name_List,\n-        Compute_Dependencies => No_Name_List,\n-        Include_Options      => No_Name_List,\n-        Binder_Drivers       => No_Name,\n-        Binder_Driver_Paths  => No_Name);\n+   type Lang_Naming_Data is record\n+      Dot_Replacement : File_Name_Type := No_File;\n+      --  The string to replace '.' in the source file name (for Ada)\n \n-   type First_Language_Processing_Data is\n-     array (First_Language_Indexes) of Language_Processing_Data;\n+      Casing : Casing_Type := All_Lower_Case;\n+      --  The casing of the source file name (for Ada)\n \n-   Default_First_Language_Processing_Data :\n-      constant First_Language_Processing_Data :=\n-                 (others => Default_Language_Processing_Data);\n+      Separate_Suffix : File_Name_Type := No_File;\n+      --  String to append to unit name for source file name of an Ada subunit\n \n-   type Supp_Language_Data is record\n-      Index : Language_Index := No_Language_Index;\n-      Data  : Language_Processing_Data := Default_Language_Processing_Data;\n-      Next  : Supp_Language_Index := No_Supp_Language_Index;\n+      Spec_Suffix : File_Name_Type := No_File;\n+      --  The string to append to the unit name for the\n+      --  source file name of a spec.\n+\n+      Body_Suffix : File_Name_Type := No_File;\n+      --  The string to append to the unit name for the\n+      --  source file name of a body.\n    end record;\n \n-   package Supp_Language_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Supp_Language_Data,\n-      Table_Index_Type     => Supp_Language_Index,\n+   No_Lang_Naming_Data : constant Lang_Naming_Data :=\n+                           (Dot_Replacement => No_File,\n+                            Casing          => All_Lower_Case,\n+                            Separate_Suffix => No_File,\n+                            Spec_Suffix     => No_File,\n+                            Body_Suffix     => No_File);\n+\n+   type Source_Id is new Nat;\n+\n+   No_Source : constant Source_Id := 0;\n+\n+   --  All the fields in the below record should be commented ???\n+\n+   type Language_Config is record\n+      Kind : Language_Kind := File_Based;\n+      --  Kind of language. All languages are file based, except Ada which is\n+      --  unit based.\n+\n+      Naming_Data : Lang_Naming_Data;\n+      --  The naming data for the languages (prefixs, etc)\n+\n+      Compiler_Driver : File_Name_Type := No_File;\n+      --  The name of the executable for the compiler of the language\n+\n+      Compiler_Driver_Path : String_Access := null;\n+      --  The path name of the executable for the compiler of the language\n+\n+      Compiler_Min_Options : Name_List_Index := No_Name_List;\n+      --  The minimum options for the compiler of the language. Specified\n+      --  in the configuration as Compiler'Switches (<language>).\n+\n+      Min_Compiler_Options : String_List_Access := null;\n+      --  The minimum options as an argument list\n+\n+      Compilation_PIC_Option : Name_List_Index := No_Name_List;\n+      --  The option(s) to compile a source in Position Independent Code for\n+      --  shared libraries. Specified in the configuration. When not specified,\n+      --  there is no need for such switch.\n+\n+      Mapping_File_Switches  : Name_List_Index := No_Name_List;\n+      --  The option(s) to provide a mapping file to the compiler. Specified in\n+      --  the configuration. When not ???\n+\n+      Mapping_Spec_Suffix  : File_Name_Type       := No_File;\n+      Mapping_Body_Suffix  : File_Name_Type       := No_File;\n+      Config_File_Switches : Name_List_Index      := No_Name_List;\n+      Dependency_Kind      : Dependency_File_Kind := None;\n+      Dependency_Option    : Name_List_Index      := No_Name_List;\n+      Compute_Dependency   : Name_List_Index      := No_Name_List;\n+      Include_Option       : Name_List_Index      := No_Name_List;\n+\n+      Include_Path : Name_Id := No_Name;\n+      --  Name of an environment variable\n+\n+      Include_Path_File : Name_Id := No_Name;\n+      --  Name of an environment variable\n+\n+      Objects_Path : Name_Id := No_Name;\n+      --  Name of an environment variable\n+\n+      Objects_Path_File : Name_Id := No_Name;\n+      --  Name of an environment variable\n+\n+      Config_Body           : Name_Id         := No_Name;\n+      Config_Spec           : Name_Id         := No_Name;\n+      Config_Body_Pattern   : Name_Id         := No_Name;\n+      Config_Spec_Pattern   : Name_Id         := No_Name;\n+      Config_File_Unique    : Boolean         := False;\n+      Runtime_Project       : Path_Name_Type  := No_Path;\n+      Binder_Driver         : File_Name_Type  := No_File;\n+      Binder_Driver_Path    : Path_Name_Type  := No_Path;\n+      Binder_Min_Options    : Name_List_Index := No_Name_List;\n+      Binder_Prefix         : Name_Id         := No_Name;\n+      Toolchain_Version     : Name_Id         := No_Name;\n+      Toolchain_Description : Name_Id         := No_Name;\n+      PIC_Option            : Name_Id         := No_Name;\n+      Objects_Generated     : Boolean         := True;\n+   end record;\n+\n+   No_Language_Config : constant Language_Config :=\n+                          (Kind                    => File_Based,\n+                           Naming_Data             => No_Lang_Naming_Data,\n+                           Compiler_Driver         => No_File,\n+                           Compiler_Driver_Path    => null,\n+                           Compiler_Min_Options    => No_Name_List,\n+                           Min_Compiler_Options    => null,\n+                           Compilation_PIC_Option  => No_Name_List,\n+                           Mapping_File_Switches   => No_Name_List,\n+                           Mapping_Spec_Suffix     => No_File,\n+                           Mapping_Body_Suffix     => No_File,\n+                           Config_File_Switches    => No_Name_List,\n+                           Dependency_Kind         => Makefile,\n+                           Dependency_Option       => No_Name_List,\n+                           Compute_Dependency      => No_Name_List,\n+                           Include_Option          => No_Name_List,\n+                           Include_Path            => No_Name,\n+                           Include_Path_File       => No_Name,\n+                           Objects_Path            => No_Name,\n+                           Objects_Path_File       => No_Name,\n+                           Config_Body             => No_Name,\n+                           Config_Spec             => No_Name,\n+                           Config_Body_Pattern     => No_Name,\n+                           Config_Spec_Pattern     => No_Name,\n+                           Config_File_Unique      => False,\n+                           Runtime_Project         => No_Path,\n+                           Binder_Driver           => No_File,\n+                           Binder_Driver_Path      => No_Path,\n+                           Binder_Min_Options      => No_Name_List,\n+                           Binder_Prefix           => No_Name,\n+                           Toolchain_Version       => No_Name,\n+                           Toolchain_Description   => No_Name,\n+                           PIC_Option              => No_Name,\n+                           Objects_Generated       => True);\n+\n+   type Language_Data is record\n+      Name          : Name_Id         := No_Name;\n+      Display_Name  : Name_Id         := No_Name;\n+      Config        : Language_Config := No_Language_Config;\n+      First_Source  : Source_Id       := No_Source;\n+      Mapping_Files : Mapping_Files_Htable.Instance :=\n+                        Mapping_Files_Htable.Nil;\n+      Next          : Language_Index  := No_Language_Index;\n+   end record;\n+\n+   No_Language_Data : constant Language_Data :=\n+                        (Name          => No_Name,\n+                         Display_Name  => No_Name,\n+                         Config        => No_Language_Config,\n+                         First_Source  => No_Source,\n+                         Mapping_Files => Mapping_Files_Htable.Nil,\n+                         Next          => No_Language_Index);\n+\n+   package Language_Data_Table is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Language_Data,\n+      Table_Index_Type     => Language_Index,\n       Table_Low_Bound      => 1,\n-      Table_Initial        => 4,\n+      Table_Initial        => 10,\n       Table_Increment      => 100);\n-   --  The table for language data when there are more languages than\n-   --  in First_Language_Indexes.\n+   --  The table for lists of names used in package Language_Processing\n \n-   type Other_Source_Id is new Nat;\n-   No_Other_Source : constant Other_Source_Id := 0;\n+   type Alternate_Language_Id is new Nat;\n \n-   type Other_Source is record\n-      Language         : Language_Index;       --  language of the source\n-      File_Name        : File_Name_Type;       --  source file simple name\n-      Path_Name        : Path_Name_Type;       --  source full path name\n-      Source_TS        : Time_Stamp_Type;      --  source file time stamp\n-      Object_Name      : File_Name_Type;       --  object file simple name\n-      Object_Path      : Path_Name_Type;       --  object full path name\n-      Object_TS        : Time_Stamp_Type;      --  object file time stamp\n-      Dep_Name         : File_Name_Type;       --  dependency file simple name\n-      Dep_Path         : Path_Name_Type;       --  dependency full path name\n-      Dep_TS           : Time_Stamp_Type;      --  dependency file time stamp\n-      Naming_Exception : Boolean := False;     --  True if a naming exception\n-      Next             : Other_Source_Id := No_Other_Source;\n+   No_Alternate_Language : constant Alternate_Language_Id := 0;\n+\n+   type Alternate_Language_Data is record\n+      Language : Language_Index := No_Language_Index;\n+      Next     : Alternate_Language_Id := No_Alternate_Language;\n    end record;\n-   --  Data for a source in a language other than Ada\n \n-   package Other_Source_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Other_Source,\n-      Table_Index_Type     => Other_Source_Id,\n+   package Alternate_Language_Table is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Alternate_Language_Data,\n+      Table_Index_Type     => Alternate_Language_Id,\n       Table_Low_Bound      => 1,\n-      Table_Initial        => 200,\n+      Table_Initial        => 10,\n       Table_Increment      => 100);\n-   --  The table for sources of languages other than Ada\n+   --  The table for storing the alternate languages of a header file that\n+   --  is used for several languages.\n+\n+   type Source_Kind is (Spec, Impl, Sep);\n+\n+   --  Following record needs full comments on every field ???\n+\n+   type Source_Data is record\n+      Project             : Project_Id            := No_Project;\n+      Language_Name       : Name_Id               := No_Name;\n+      Language            : Language_Index        := No_Language_Index;\n+      Alternate_Languages : Alternate_Language_Id := No_Alternate_Language;\n+      Kind                : Source_Kind           := Spec;\n+      Dependency          : Dependency_File_Kind  := Makefile;\n+      Other_Part          : Source_Id             := No_Source;\n+      Unit                : Name_Id               := No_Name;\n+      Index               : Int                   := 0;\n+      Locally_Removed     : Boolean               := False;\n+      Replaced_By         : Source_Id             := No_Source;\n+      File                : File_Name_Type        := No_File;\n+      Display_File        : File_Name_Type        := No_File;\n+      Path                : Path_Name_Type        := No_Path;\n+      Display_Path        : Path_Name_Type        := No_Path;\n+      Source_TS           : Time_Stamp_Type       := Empty_Time_Stamp;\n+      Object_Project      : Project_Id            := No_Project;\n+      Object_Exists       : Boolean               := True;\n+      Object              : File_Name_Type        := No_File;\n+      Current_Object_Path : Path_Name_Type        := No_Path;\n+      Object_Path         : Path_Name_Type        := No_Path;\n+\n+      Object_TS : Time_Stamp_Type := Empty_Time_Stamp;\n+      --  Object file time stamp\n+\n+      Dep_Name : File_Name_Type := No_File;\n+      --  Dependency file simple name\n+\n+      Current_Dep_Path : Path_Name_Type := No_Path;\n+\n+      Dep_Path : Path_Name_Type := No_Path;\n+      --  Dependency full path name\n+\n+      Dep_TS : Time_Stamp_Type := Empty_Time_Stamp;\n+      --  Dependency file time stamp\n+\n+      Switches         : File_Name_Type  := No_File;\n+      Switches_Path    : Path_Name_Type  := No_Path;\n+      Switches_TS      : Time_Stamp_Type := Empty_Time_Stamp;\n+      Naming_Exception : Boolean         := False;\n+      Next_In_Sources  : Source_Id       := No_Source;\n+      Next_In_Project  : Source_Id       := No_Source;\n+      Next_In_Lang     : Source_Id       := No_Source;\n+   end record;\n \n-   ----------------------------------\n-   --  End of multi-language stuff --\n-   ----------------------------------\n+   No_Source_Data : constant Source_Data :=\n+                      (Project             => No_Project,\n+                       Language_Name       => No_Name,\n+                       Language            => No_Language_Index,\n+                       Alternate_Languages => No_Alternate_Language,\n+                       Kind                => Spec,\n+                       Dependency          => Makefile,\n+                       Other_Part          => No_Source,\n+                       Unit                => No_Name,\n+                       Index               => 0,\n+                       Locally_Removed     => False,\n+                       Replaced_By         => No_Source,\n+                       File                => No_File,\n+                       Display_File        => No_File,\n+                       Path                => No_Path,\n+                       Display_Path        => No_Path,\n+                       Source_TS           => Empty_Time_Stamp,\n+                       Object_Project      => No_Project,\n+                       Object_Exists       => True,\n+                       Object              => No_File,\n+                       Current_Object_Path => No_Path,\n+                       Object_Path         => No_Path,\n+                       Object_TS           => Empty_Time_Stamp,\n+                       Dep_Name            => No_File,\n+                       Current_Dep_Path    => No_Path,\n+                       Dep_Path            => No_Path,\n+                       Dep_TS              => Empty_Time_Stamp,\n+                       Switches            => No_File,\n+                       Switches_Path       => No_Path,\n+                       Switches_TS         => Empty_Time_Stamp,\n+                       Naming_Exception    => False,\n+                       Next_In_Sources     => No_Source,\n+                       Next_In_Project     => No_Source,\n+                       Next_In_Lang        => No_Source);\n+\n+   package Source_Data_Table is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Source_Data,\n+      Table_Index_Type     => Source_Id,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 1000,\n+      Table_Increment      => 100);\n+   --  The table for the sources\n+\n+   package Source_Paths_Htable is new Simple_HTable\n+     (Header_Num => Header_Num,\n+      Element    => Source_Id,\n+      No_Element => No_Source,\n+      Key        => Path_Name_Type,\n+      Hash       => Hash,\n+      Equal      => \"=\");\n+   --  Mapping of source paths to source ids\n \n    type Verbosity is (Default, Medium, High);\n    --  Verbosity when parsing GNAT Project Files\n@@ -288,6 +607,7 @@ package Prj is\n    --  The current value of the verbosity the project files are parsed with\n \n    type Lib_Kind is (Static, Dynamic, Relocatable);\n+\n    type Policy is (Autonomous, Compliant, Controlled, Restricted, Direct);\n    --  Type to specify the symbol policy, when symbol control is supported.\n    --  See full explanation about this type in package Symbols.\n@@ -298,173 +618,182 @@ package Prj is\n    --    Direct:     The symbol file is used as is\n \n    type Symbol_Record is record\n-      Symbol_File   : Name_Id := No_Name;\n-      Reference     : Name_Id := No_Name;\n+      Symbol_File   : Path_Name_Type := No_Path;\n+      Reference     : Path_Name_Type := No_Path;\n       Symbol_Policy : Policy  := Autonomous;\n    end record;\n    --  Type to keep the symbol data to be used when building a shared library\n \n    No_Symbols : constant Symbol_Record :=\n-     (Symbol_File   => No_Name,\n-      Reference     => No_Name,\n+     (Symbol_File   => No_Path,\n+      Reference     => No_Path,\n       Symbol_Policy => Autonomous);\n    --  The default value of the symbol data\n \n-   function Empty_String return Name_Id;\n-   --  Return the Name_Id for an empty string \"\"\n+   function Image (Casing : Casing_Type) return String;\n+   --  Similar to 'Image (but avoid use of this attribute in compiler)\n \n-   type Project_Id is new Nat;\n-   No_Project : constant Project_Id := 0;\n-   --  Id of a Project File\n+   function Value (Image : String) return Casing_Type;\n+   --  Similar to 'Value (but avoid use of this attribute in compiler)\n+   --  Raises Constraint_Error if not a Casing_Type image.\n \n-   type String_List_Id is new Nat;\n-   Nil_String : constant String_List_Id := 0;\n-   type String_Element is record\n-      Value         : Name_Id        := No_Name;\n-      Index         : Int            := 0;\n-      Display_Value : Name_Id        := No_Name;\n-      Location      : Source_Ptr     := No_Location;\n-      Flag          : Boolean        := False;\n-      Next          : String_List_Id := Nil_String;\n-   end record;\n-   --  To hold values for string list variables and array elements.\n-   --  The component Flag may be used for various purposes. For source\n-   --  directories, it indicates if the directory contains Ada source(s).\n+   --  Declarations for gprmake:\n \n-   package String_Element_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => String_Element,\n-      Table_Index_Type     => String_List_Id,\n+   First_Language_Index        : constant Language_Index := 1;\n+   First_Language_Indexes_Last : constant Language_Index := 5;\n+\n+   Ada_Language_Index         : constant Language_Index :=\n+                                  First_Language_Index;\n+   C_Language_Index           : constant Language_Index :=\n+                                  Ada_Language_Index + 1;\n+   C_Plus_Plus_Language_Index : constant Language_Index :=\n+                                  C_Language_Index + 1;\n+\n+   Last_Language_Index : Language_Index := No_Language_Index;\n+\n+   subtype First_Language_Indexes is Language_Index\n+      range First_Language_Index .. First_Language_Indexes_Last;\n+\n+   package Language_Indexes is new System.HTable.Simple_HTable\n+     (Header_Num => Header_Num,\n+      Element    => Language_Index,\n+      No_Element => No_Language_Index,\n+      Key        => Name_Id,\n+      Hash       => Hash,\n+      Equal      => \"=\");\n+   --  Mapping of language names to language indexes\n+\n+   package Language_Names is new Table.Table\n+     (Table_Component_Type => Name_Id,\n+      Table_Index_Type     => Language_Index,\n       Table_Low_Bound      => 1,\n-      Table_Initial        => 200,\n-      Table_Increment      => 100);\n-   --  The table for string elements in string lists\n+      Table_Initial        => 4,\n+      Table_Increment      => 100,\n+      Table_Name           => \"Prj.Language_Names\");\n+   --  The table for the name of programming languages\n \n-   type Variable_Kind is (Undefined, List, Single);\n-   --  Different kinds of variables\n+   procedure Add_Language_Name (Name : Name_Id);\n \n-   subtype Defined_Variable_Kind is Variable_Kind range List .. Single;\n-   --  The defined kinds of variables\n+   procedure Display_Language_Name (Language : Language_Index);\n \n-   Ignored : constant Variable_Kind;\n-   --  Used to indicate that a package declaration must be ignored\n-   --  while processing the project tree (unknown package name).\n+   type Languages_In_Project is array (First_Language_Indexes) of Boolean;\n+   --  Set of supported languages used in a project\n \n-   type Variable_Value (Kind : Variable_Kind := Undefined) is record\n-      Project  : Project_Id := No_Project;\n-      Location : Source_Ptr := No_Location;\n-      Default  : Boolean    := False;\n-      case Kind is\n-         when Undefined =>\n-            null;\n-         when List =>\n-            Values : String_List_Id := Nil_String;\n-         when Single =>\n-            Value : Name_Id := No_Name;\n-            Index : Int     := 0;\n-      end case;\n-   end record;\n-   --  Values for variables and array elements. Default is True if the\n-   --  current value is the default one for the variable\n+   No_Languages : constant Languages_In_Project := (others => False);\n+   --  No supported languages are used\n \n-   Nil_Variable_Value : constant Variable_Value;\n-   --  Value of a non existing variable or array element\n+   type Supp_Language_Index is new Nat;\n+   No_Supp_Language_Index  : constant Supp_Language_Index := 0;\n \n-   type Variable_Id is new Nat;\n-   No_Variable : constant Variable_Id := 0;\n-   type Variable is record\n-      Next  : Variable_Id := No_Variable;\n-      Name  : Name_Id;\n-      Value : Variable_Value;\n+   type Supp_Language is record\n+      Index   : Language_Index := No_Language_Index;\n+      Present : Boolean := False;\n+      Next    : Supp_Language_Index := No_Supp_Language_Index;\n    end record;\n-   --  To hold the list of variables in a project file and in packages\n \n-   package Variable_Element_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Variable,\n-      Table_Index_Type     => Variable_Id,\n+   package Present_Language_Table is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Supp_Language,\n+      Table_Index_Type     => Supp_Language_Index,\n       Table_Low_Bound      => 1,\n-      Table_Initial        => 200,\n+      Table_Initial        => 4,\n       Table_Increment      => 100);\n-   --  The table of variable in list of variables\n+   --  The table for the presence of languages with an index that is outside\n+   --  of First_Language_Indexes.\n \n-   type Array_Element_Id is new Nat;\n-   No_Array_Element : constant Array_Element_Id := 0;\n-   type Array_Element is record\n-      Index                : Name_Id;\n-      Src_Index            : Int := 0;\n-      Index_Case_Sensitive : Boolean := True;\n-      Value                : Variable_Value;\n-      Next                 : Array_Element_Id := No_Array_Element;\n-   end record;\n-   --  Each Array_Element represents an array element and is linked (Next)\n-   --  to the next array element, if any, in the array.\n+   type Impl_Suffix_Array is array (First_Language_Indexes) of File_Name_Type;\n+   --  Suffixes for the non spec sources of the different supported languages\n+   --  in a project.\n \n-   package Array_Element_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Array_Element,\n-      Table_Index_Type     => Array_Element_Id,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 200,\n-      Table_Increment      => 100);\n-   --  The table that contains all array elements\n+   No_Impl_Suffixes : constant Impl_Suffix_Array := (others => No_File);\n+   --  A default value for the non spec source suffixes\n \n-   type Array_Id is new Nat;\n-   No_Array : constant Array_Id := 0;\n-   type Array_Data is record\n-      Name  : Name_Id          := No_Name;\n-      Value : Array_Element_Id := No_Array_Element;\n-      Next  : Array_Id         := No_Array;\n+   type Supp_Suffix is record\n+      Index   : Language_Index      := No_Language_Index;\n+      Suffix  : File_Name_Type      := No_File;\n+      Next    : Supp_Language_Index := No_Supp_Language_Index;\n    end record;\n-   --  Each Array_Data value represents an array.\n-   --  Value is the id of the first element.\n-   --  Next is the id of the next array in the project file or package.\n \n-   package Array_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Array_Data,\n-      Table_Index_Type     => Array_Id,\n+   package Supp_Suffix_Table is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Supp_Suffix,\n+      Table_Index_Type     => Supp_Language_Index,\n       Table_Low_Bound      => 1,\n-      Table_Initial        => 200,\n+      Table_Initial        => 4,\n       Table_Increment      => 100);\n-   --  The table that contains all arrays\n+   --  The table for the presence of languages with an index that is outside\n+   --  of First_Language_Indexes.\n \n-   type Package_Id is new Nat;\n-   No_Package : constant Package_Id := 0;\n-   type Declarations is record\n-      Variables  : Variable_Id := No_Variable;\n-      Attributes : Variable_Id := No_Variable;\n-      Arrays     : Array_Id    := No_Array;\n-      Packages   : Package_Id  := No_Package;\n+   type Lang_Kind is (GNU, Other);\n+\n+   type Language_Processing_Data is record\n+      Compiler_Drivers     : Name_List_Index := No_Name_List;\n+      Compiler_Paths       : Name_Id         := No_Name;\n+      Compiler_Kinds       : Lang_Kind       := GNU;\n+      Dependency_Options   : Name_List_Index := No_Name_List;\n+      Compute_Dependencies : Name_List_Index := No_Name_List;\n+      Include_Options      : Name_List_Index := No_Name_List;\n+      Binder_Drivers       : Name_Id         := No_Name;\n+      Binder_Driver_Paths  : Name_Id         := No_Name;\n    end record;\n-   --  Contains the declarations (variables, single and array attributes,\n-   --  packages) for a project or a package in a project.\n \n-   No_Declarations : constant Declarations :=\n-     (Variables  => No_Variable,\n-      Attributes => No_Variable,\n-      Arrays     => No_Array,\n-      Packages   => No_Package);\n-   --  Default value of Declarations: indicates that there is no declarations\n+   Default_Language_Processing_Data :\n+     constant Language_Processing_Data :=\n+       (Compiler_Drivers     => No_Name_List,\n+        Compiler_Paths       => No_Name,\n+        Compiler_Kinds       => GNU,\n+        Dependency_Options   => No_Name_List,\n+        Compute_Dependencies => No_Name_List,\n+        Include_Options      => No_Name_List,\n+        Binder_Drivers       => No_Name,\n+        Binder_Driver_Paths  => No_Name);\n \n-   type Package_Element is record\n-      Name   : Name_Id      := No_Name;\n-      Decl   : Declarations := No_Declarations;\n-      Parent : Package_Id   := No_Package;\n-      Next   : Package_Id   := No_Package;\n+   type First_Language_Processing_Data is\n+     array (First_Language_Indexes) of Language_Processing_Data;\n+\n+   Default_First_Language_Processing_Data :\n+      constant First_Language_Processing_Data :=\n+                 (others => Default_Language_Processing_Data);\n+\n+   type Supp_Language_Data is record\n+      Index : Language_Index := No_Language_Index;\n+      Data  : Language_Processing_Data := Default_Language_Processing_Data;\n+      Next  : Supp_Language_Index := No_Supp_Language_Index;\n    end record;\n-   --  A package (includes declarations that may include other packages)\n \n-   package Package_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Package_Element,\n-      Table_Index_Type     => Package_Id,\n+   package Supp_Language_Table is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Supp_Language_Data,\n+      Table_Index_Type     => Supp_Language_Index,\n       Table_Low_Bound      => 1,\n-      Table_Initial        => 100,\n+      Table_Initial        => 4,\n       Table_Increment      => 100);\n-   --  The table that contains all packages\n+   --  The table for language data when there are more languages than\n+   --  in First_Language_Indexes.\n \n-   function Image (Casing : Casing_Type) return String;\n-   --  Similar to 'Image (but avoid use of this attribute in compiler)\n+   type Other_Source_Id is new Nat;\n+   No_Other_Source : constant Other_Source_Id := 0;\n \n-   function Value (Image : String) return Casing_Type;\n-   --  Similar to 'Value (but avoid use of this attribute in compiler)\n-   --  Raises Constraint_Error if not a Casing_Type image.\n+   type Other_Source is record\n+      Language         : Language_Index;       --  language of the source\n+      File_Name        : File_Name_Type;       --  source file simple name\n+      Path_Name        : Path_Name_Type;       --  source full path name\n+      Source_TS        : Time_Stamp_Type;      --  source file time stamp\n+      Object_Name      : File_Name_Type;       --  object file simple name\n+      Object_Path      : Path_Name_Type;       --  object full path name\n+      Object_TS        : Time_Stamp_Type;      --  object file time stamp\n+      Dep_Name         : File_Name_Type;       --  dependency file simple name\n+      Dep_Path         : Path_Name_Type;       --  dependency full path name\n+      Dep_TS           : Time_Stamp_Type;      --  dependency file time stamp\n+      Naming_Exception : Boolean := False;     --  True if a naming exception\n+      Next             : Other_Source_Id := No_Other_Source;\n+   end record;\n+   --  Data for a source in a language other than Ada\n+\n+   package Other_Source_Table is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Other_Source,\n+      Table_Index_Type     => Other_Source_Id,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 200,\n+      Table_Increment      => 100);\n+   --  The table for sources of languages other than Ada\n \n    --  The following record contains data for a naming scheme\n \n@@ -474,8 +803,6 @@ package Prj is\n       --  The string to replace '.' in the source file name (for Ada)\n \n       Dot_Repl_Loc : Source_Ptr := No_Location;\n-      --  The position in the project file source where Dot_Replacement is\n-      --  defined.\n \n       Casing : Casing_Type := All_Lower_Case;\n       --  The casing of the source file name (for Ada)\n@@ -485,28 +812,14 @@ package Prj is\n       --  source file name of a spec.\n       --  Indexed by the programming language.\n \n-      Ada_Spec_Suffix : File_Name_Type := No_File;\n-      --  The suffix of the Ada spec sources\n-\n-      Spec_Suffix_Loc : Source_Ptr := No_Location;\n-      --  The position in the project file source where\n-      --  Ada_Spec_Suffix is defined.\n-\n-      Impl_Suffixes : Impl_Suffix_Array   := No_Impl_Suffixes;\n-      Supp_Suffixes : Supp_Language_Index := No_Supp_Language_Index;\n-      --  The source suffixes of the different languages\n+      Ada_Spec_Suffix_Loc : Source_Ptr := No_Location;\n \n       Body_Suffix : Array_Element_Id := No_Array_Element;\n       --  The string to append to the unit name for the\n       --  source file name of a body.\n       --  Indexed by the programming language.\n \n-      Ada_Body_Suffix : File_Name_Type := No_File;\n-      --  The suffix of the Ada body sources\n-\n-      Body_Suffix_Loc : Source_Ptr := No_Location;\n-      --  The position in the project file source where\n-      --  Ada_Body_Suffix is defined.\n+      Ada_Body_Suffix_Loc : Source_Ptr := No_Location;\n \n       Separate_Suffix : File_Name_Type := No_File;\n       --  String to append to unit name for source file name of an Ada subunit\n@@ -530,8 +843,48 @@ package Prj is\n       --  An associative array listing body file names that do not have the\n       --  body suffix. Not used by Ada. Indexed by programming language name.\n \n+      --  For gprmake:\n+\n+      Impl_Suffixes : Impl_Suffix_Array   := No_Impl_Suffixes;\n+      Supp_Suffixes : Supp_Language_Index := No_Supp_Language_Index;\n    end record;\n \n+   function Spec_Suffix_Of\n+     (In_Tree  : Project_Tree_Ref;\n+      Language : String;\n+      Naming   : Naming_Data) return String;\n+\n+   function Spec_Suffix_Id_Of\n+     (In_Tree  : Project_Tree_Ref;\n+      Language : String;\n+      Naming   : Naming_Data) return File_Name_Type;\n+\n+   procedure Set_Spec_Suffix\n+     (In_Tree  : Project_Tree_Ref;\n+      Language : String;\n+      Naming   : in out Naming_Data;\n+      Suffix   : File_Name_Type);\n+\n+   function Body_Suffix_Id_Of\n+     (In_Tree  : Project_Tree_Ref;\n+      Language : String;\n+      Naming   : Naming_Data) return File_Name_Type;\n+\n+   function Body_Suffix_Of\n+     (In_Tree  : Project_Tree_Ref;\n+      Language : String;\n+      Naming   : Naming_Data) return String;\n+\n+   procedure Set_Body_Suffix\n+     (In_Tree  : Project_Tree_Ref;\n+      Language : String;\n+      Naming   : in out Naming_Data;\n+      Suffix   : File_Name_Type);\n+\n+   function Objects_Exist_For\n+     (Language : String;\n+      In_Tree  : Project_Tree_Ref) return Boolean;\n+\n    function Standard_Naming_Data\n      (Tree : Project_Tree_Ref := No_Project_Tree) return Naming_Data;\n    pragma Inline (Standard_Naming_Data);\n@@ -563,28 +916,141 @@ package Prj is\n       Table_Increment      => 100);\n    --  The table that contains the lists of project files\n \n+   type Project_Configuration is record\n+         Run_Path_Option          : Name_List_Index := No_Name_List;\n+         --  The option to use when linking to specify the path where to look\n+         --  for libraries.\n+\n+         Executable_Suffix        : Name_Id         := No_Name;\n+         --  The suffix of executables, when specified in the configuration or\n+         --  in package Builder of the main project. When this is not\n+         --  specified, the executable suffix is the default for the platform.\n+\n+         --  Linking\n+\n+         Linker                   : Path_Name_Type  := No_Path;\n+         --  Path name of the linker driver; specified in the configuration\n+         --  or in the package Builder of the main project.\n+\n+         Minimum_Linker_Options   : Name_List_Index := No_Name_List;\n+         --  The minimum options for the linker driver; specified in the\n+         --  configuration.\n+\n+         Linker_Executable_Option : Name_List_Index := No_Name_List;\n+         --  The option(s) to indicate the name of the executable in the\n+         --  linker command. Specified in the configuration. When not\n+         --  specified, default to -o <executable name>.\n+\n+         Linker_Lib_Dir_Option    : Name_Id         := No_Name;\n+         --  The option to specify where to find a library for linking.\n+         --  Specified in the configuration. When not specified, defaults to\n+         --  \"-L\".\n+\n+         Linker_Lib_Name_Option   : Name_Id         := No_Name;\n+         --  The option to specify the name of a library for linking.\n+         --  Specified in the configuration. When not specified, defaults to\n+         --  \"-l\".\n+\n+         --  Libraries\n+\n+         Library_Builder          : Path_Name_Type  := No_Path;\n+         --  The executable to build library. Specified in the configuration.\n+\n+         Lib_Support              : Library_Support := None;\n+         --  The level of library support. Specified in the configuration.\n+         --  Support is none, static libraries only or both static and shared\n+         --  libraries.\n+\n+         --  Archives\n+\n+         Archive_Builder          : Name_List_Index := No_Name_List;\n+         --  The name of the executable to build archives, with the minimum\n+         --  switches. Specified in the configuration.\n+\n+         Archive_Indexer          : Name_List_Index := No_Name_List;\n+         --  The name of the executable to index archives, with the minimum\n+         --  switches. Specified in the configuration.\n+\n+         Archive_Suffix           : File_Name_Type  := No_File;\n+         --  The suffix of archives. Specified in the configuration. When not\n+         --  specified, defaults to \".a\".\n+\n+         Lib_Partial_Linker       : Name_List_Index := No_Name_List;\n+\n+         --  Shared libraries\n+\n+         Shared_Lib_Prefix        : File_Name_Type  := No_File;\n+         --  Part of a shared library file name that precedes the name of the\n+         --  library. Specified in the configuration. When not specified,\n+         --  defaults to \"lib\".\n+\n+         Shared_Lib_Suffix        : File_Name_Type  := No_File;\n+         --  Suffix of shared libraries, after the library name in the shared\n+         --  library name. Specified in the configuration. When not specified,\n+         --  default to \".so\".\n+\n+         Shared_Lib_Min_Options   : Name_List_Index := No_Name_List;\n+         --\n+\n+         Lib_Version_Options      : Name_List_Index := No_Name_List;\n+         --\n+\n+         Symbolic_Link_Supported  : Boolean         := False;\n+         --\n+\n+         Lib_Maj_Min_Id_Supported : Boolean         := False;\n+         --\n+\n+         Auto_Init_Supported      : Boolean         := False;\n+         --\n+   end record;\n+\n+   Default_Project_Config : constant Project_Configuration :=\n+       (Run_Path_Option          => No_Name_List,\n+        Executable_Suffix        => No_Name,\n+        Linker                   => No_Path,\n+        Minimum_Linker_Options   => No_Name_List,\n+        Linker_Executable_Option => No_Name_List,\n+        Linker_Lib_Dir_Option    => No_Name,\n+        Linker_Lib_Name_Option   => No_Name,\n+        Library_Builder          => No_Path,\n+        Lib_Support              => None,\n+        Archive_Builder          => No_Name_List,\n+        Archive_Indexer          => No_Name_List,\n+        Archive_Suffix           => No_File,\n+        Lib_Partial_Linker       => No_Name_List,\n+        Shared_Lib_Prefix        => No_File,\n+        Shared_Lib_Suffix        => No_File,\n+        Shared_Lib_Min_Options   => No_Name_List,\n+        Lib_Version_Options      => No_Name_List,\n+        Symbolic_Link_Supported  => False,\n+        Lib_Maj_Min_Id_Supported => False,\n+        Auto_Init_Supported      => False);\n+\n    --  The following record describes a project file representation\n \n    type Project_Data is record\n       Externally_Built : Boolean := False;\n+      --  True if the project is externally built. In such case, the Project\n+      --  Manager will not modify anything in this project.\n \n-      Languages      : Languages_In_Project := No_Languages;\n-      Supp_Languages : Supp_Language_Index  := No_Supp_Language_Index;\n-      --  Indicate the different languages of the source of this project\n+      Languages        : Name_List_Index := No_Name_List;\n+      --  The list of languages of the sources of this project\n+\n+      Config           : Project_Configuration;\n \n       First_Referred_By : Project_Id := No_Project;\n       --  The project, if any, that was the first to be known as importing or\n-      --  extending this project. Set by Prj.Proc.Process.\n+      --  extending this project\n \n       Name : Name_Id := No_Name;\n-      --  The name of the project. Set by Prj.Proc.Process\n+      --  The name of the project\n \n       Display_Name : Name_Id := No_Name;\n-      --  The name of the project with the spelling of its declaration.\n-      --  Set by Prj.Proc.Process.\n+      --  The name of the project with the spelling of its declaration\n \n       Path_Name : Path_Name_Type := No_Path;\n-      --  The path name of the project file. Set by Prj.Proc.Process\n+      --  The path name of the project file\n \n       Display_Path_Name : Path_Name_Type := No_Path;\n       --  The path name used for display purposes. May be different from\n@@ -594,83 +1060,76 @@ package Prj is\n       --  True for virtual extending projects\n \n       Location : Source_Ptr := No_Location;\n-      --  The location in the project file source of the reserved word\n-      --  project. Set by Prj.Proc.Process.\n+      --  The location in the project file source of the reserved word project\n \n       Mains : String_List_Id := Nil_String;\n-      --  List of mains specified by attribute Main. Set by Prj.Nmsc.Check\n+      --  List of mains specified by attribute Main\n \n       Directory : Path_Name_Type := No_Path;\n-      --  Directory where the project file resides. Set by Prj.Proc.Process\n+      --  Path name of the directory where the project file resides\n \n       Display_Directory : Path_Name_Type := No_Path;\n-      --  Project directory path name for display purposes. May be different\n-      --  from Directory for platforms where file names are case-insensitive.\n+      --  The path name of the project directory, for display purposes. May be\n+      --  different from Directory for platforms where the file names are\n+      --  case-insensitive.\n \n       Dir_Path : String_Access;\n-      --  Same as Directory, but as an access to String. Set by\n-      --  Make.Compile_Sources.Collect_Arguments_And_Compile.\n+      --  Same as Directory, but as an access to String\n \n       Library : Boolean := False;\n-      --  True if this is a library project. Set by\n-      --  Prj.Nmsc.Language_Independent_Check.\n+      --  True if this is a library project\n \n       Library_Dir : Path_Name_Type := No_Path;\n-      --  If a library project, directory where the library Set by\n-      --  Prj.Nmsc.Language_Independent_Check.\n+      --  If a library project, path name of the directory where the library\n+      --  resides.\n \n       Display_Library_Dir : Path_Name_Type := No_Path;\n-      --  The name of the library directory, for display purposes. May be\n+      --  The path name of the library directory, for display purposes. May be\n       --  different from Library_Dir for platforms where the file names are\n       --  case-insensitive.\n \n       Library_TS : Time_Stamp_Type := Empty_Time_Stamp;\n-      --  The timestamp of a library file in a library project.\n-      --  Set by MLib.Prj.Check_Library.\n+      --  The timestamp of a library file in a library project\n \n       Library_Src_Dir : Path_Name_Type := No_Path;\n-      --  If a Stand-Alone Library project, directory where the sources\n-      --  of the interfaces of the library are copied. By default, if\n-      --  attribute Library_Src_Dir is not specified, sources of the interfaces\n-      --  are not copied anywhere. Set by Prj.Nmsc.Check_Stand_Alone_Library.\n+      --  If a Stand-Alone Library project, path name of the directory where\n+      --  the sources of the interfaces of the library are copied. By default,\n+      --  if attribute Library_Src_Dir is not specified, sources of the\n+      --  interfaces are not copied anywhere.\n \n       Display_Library_Src_Dir : Path_Name_Type := No_Path;\n-      --  The name of the library source directory, for display purposes.\n+      --  The path name of the library source directory, for display purposes.\n       --  May be different from Library_Src_Dir for platforms where the file\n       --  names are case-insensitive.\n \n       Library_ALI_Dir : Path_Name_Type := No_Path;\n-      --  In a library project, directory where the ALI files are copied.\n-      --  If attribute Library_ALI_Dir is not specified, ALI files are\n-      --  copied in the Library_Dir. Set by Prj.Nmsc.Check_Library_Attributes.\n+      --  In a library project, path name of the directory where the ALI files\n+      --  are copied. If attribute Library_ALI_Dir is not specified, ALI files\n+      --  are copied in the Library_Dir.\n \n       Display_Library_ALI_Dir : Path_Name_Type := No_Path;\n-      --  The name of the library ALI directory, for display purposes. May be\n-      --  different from Library_ALI_Dir for platforms where the file names are\n-      --  case-insensitive.\n+      --  The path name of the library ALI directory, for display purposes. May\n+      --  be different from Library_ALI_Dir for platforms where the file names\n+      --  are case-insensitive.\n \n-      Library_Name : File_Name_Type := No_File;\n+      Library_Name : Name_Id := No_Name;\n       --  If a library project, name of the library\n-      --  Set by Prj.Nmsc.Language_Independent_Check.\n \n       Library_Kind : Lib_Kind := Static;\n       --  If a library project, kind of library\n-      --  Set by Prj.Nmsc.Language_Independent_Check.\n \n-      Lib_Internal_Name : File_Name_Type := No_File;\n-      --  If a library project, internal name store inside the library Set by\n-      --  Prj.Nmsc.Language_Independent_Check.\n+      Lib_Internal_Name : Name_Id := No_Name;\n+      --  If a library project, internal name store inside the library\n \n       Standalone_Library : Boolean := False;\n-      --  Indicate that this is a Standalone Library Project File. Set by\n-      --  Prj.Nmsc.Check.\n+      --  Indicate that this is a Standalone Library Project File\n \n       Lib_Interface_ALIs : String_List_Id := Nil_String;\n       --  For Standalone Library Project Files, indicate the list of Interface\n-      --  ALI files. Set by Prj.Nmsc.Check.\n+      --  ALI files.\n \n       Lib_Auto_Init : Boolean := False;\n-      --  For non static Standalone Library Project Files, indicate if\n+      --  For non static Stand-Alone Library Project Files, indicate if\n       --  the library initialisation should be automatic.\n \n       Libgnarl_Needed : Yes_No_Unknown := Unknown;\n@@ -679,139 +1138,131 @@ package Prj is\n       Symbol_Data : Symbol_Record := No_Symbols;\n       --  Symbol file name, reference symbol file name, symbol policy\n \n-      Ada_Sources_Present : Boolean := True;\n-      --  A flag that indicates if there are Ada sources in this project file.\n-      --  There are no sources if any of the following is true:\n-      --    1) Source_Dirs is specified as an empty list\n-      --    2) Source_Files is specified as an empty list\n-      --    3) Ada is not in the list of the specified Languages\n+      Ada_Sources : String_List_Id := Nil_String;\n+      --  The list of all the Ada source file names (gnatmake only).\n \n-      Other_Sources_Present : Boolean := True;\n-      --  A flag that indicates that there are non-Ada sources in this project\n+      Sources                 : String_List_Id := Nil_String;\n+      --  Identical to Ada_Sources. For upward compatibility of GPS.\n \n-      Sources : String_List_Id := Nil_String;\n-      --  The list of all the source file names.\n-      --  Set by Prj.Nmsc.Check_Ada_Naming_Scheme.\n+      First_Source : Source_Id := No_Source;\n+      Last_Source  : Source_Id := No_Source;\n+      --  Head and tail of the list of sources\n \n-      First_Other_Source : Other_Source_Id := No_Other_Source;\n-      Last_Other_Source  : Other_Source_Id := No_Other_Source;\n-      --  Head and tail of the list of sources of languages other than Ada\n+      Unit_Based_Language_Name  : Name_Id := No_Name;\n+      Unit_Based_Language_Index : Language_Index := No_Language_Index;\n+      --  The name and index, if any, of the unit-based language of some\n+      --  sources of the project. There may be only one unit-based language\n+      --  in one project.\n \n       Imported_Directories_Switches : Argument_List_Access := null;\n-      --  List of the -I switches to be used when compiling sources of\n-      --  languages other than Ada.\n+      --  List of the source search switches (-I<source dir>) to be used when\n+      --  compiling.\n \n       Include_Path : String_Access := null;\n-      --  Value to be used as CPATH, when using a GCC, instead of a list of\n-      --  -I switches.\n+      --  Value of the environment variable to indicate the source search path,\n+      --  instead of a list of switches (Imported_Directories_Switches).\n+\n+      Include_Path_File : Path_Name_Type := No_Path;\n+      --  The path name of the of the source search directory file\n \n       Include_Data_Set : Boolean := False;\n       --  Set True when Imported_Directories_Switches or Include_Path are set\n \n+      Include_Language : Language_Index := No_Language_Index;\n+\n       Source_Dirs : String_List_Id := Nil_String;\n-      --  The list of all the source directories.\n-      --  Set by Prj.Nmsc.Language_Independent_Check.\n+      --  The list of all the source directories\n \n       Known_Order_Of_Source_Dirs : Boolean := True;\n       --  False, if there is any /** in the Source_Dirs, because in this case\n       --  the ordering of the source subdirs depend on the OS. If True,\n       --  duplicate file names in the same project file are allowed.\n \n       Object_Directory : Path_Name_Type := No_Path;\n-      --  The object directory of this project file.\n-      --  Set by Prj.Nmsc.Language_Independent_Check.\n+      --  The path name of the object directory of this project file\n \n       Display_Object_Dir : Path_Name_Type := No_Path;\n-      --  The name of the object directory, for display purposes.\n-      --  May be different from Object_Directory for platforms where the file\n-      --  names are case-insensitive.\n+      --  The path name of the object directory, for display purposes. May be\n+      --  different from Object_Directory for platforms where the file names\n+      --  are case-insensitive.\n \n       Exec_Directory : Path_Name_Type := No_Path;\n-      --  The exec directory of this project file. Default is equal to\n-      --  Object_Directory. Set by Prj.Nmsc.Language_Independent_Check.\n+      --  The path name of the exec directory of this project file. Default is\n+      --  equal to Object_Directory.\n \n       Display_Exec_Dir : Path_Name_Type := No_Path;\n-      --  The name of the exec directory, for display purposes. May be\n+      --  The path name of the exec directory, for display purposes. May be\n       --  different from Exec_Directory for platforms where the file names are\n       --  case-insensitive.\n \n       Extends : Project_Id := No_Project;\n       --  The reference of the project file, if any, that this project file\n-      --  extends. Set by Prj.Proc.Process.\n+      --  extends.\n \n       Extended_By : Project_Id := No_Project;\n       --  The reference of the project file, if any, that extends this project\n-      --  file. Set by Prj.Proc.Process.\n+      --  file.\n \n       Naming : Naming_Data := Standard_Naming_Data;\n-      --  The naming scheme of this project file.\n-      --  Set by Prj.Nmsc.Check_Naming_Scheme.\n+      --  The naming scheme of this project file\n \n-      First_Language_Processing : First_Language_Processing_Data :=\n-                                    Default_First_Language_Processing_Data;\n+      First_Language_Processing : Language_Index := No_Language_Index;\n       --  Comment needed ???\n \n-      Supp_Language_Processing : Supp_Language_Index := No_Supp_Language_Index;\n-      --  Comment needed\n-\n-      Default_Linker      : File_Name_Type := No_File;\n-      Default_Linker_Path : Path_Name_Type := No_Path;\n-\n       Decl : Declarations := No_Declarations;\n-      --  The declarations (variables, attributes and packages) of this\n-      --  project file. Set by Prj.Proc.Process.\n+      --  The declarations (variables, attributes and packages) of this project\n+      --  file.\n \n       Imported_Projects : Project_List := Empty_Project_List;\n-      --  The list of all directly imported projects, if any. Set by\n-      --  Prj.Proc.Process.\n+      --  The list of all directly imported projects, if any\n \n       All_Imported_Projects : Project_List := Empty_Project_List;\n-      --  The list of all projects imported directly or indirectly, if any.\n-      --  Set by Make.Initialize.\n+      --  The list of all projects imported directly or indirectly, if any\n \n       Ada_Include_Path : String_Access := null;\n       --  The cached value of ADA_INCLUDE_PATH for this project file. Do not\n       --  use this field directly outside of the compiler, use\n-      --  Prj.Env.Ada_Include_Path instead. Set by Prj.Env.Ada_Include_Path.\n+      --  Prj.Env.Ada_Include_Path instead.\n \n       Ada_Objects_Path : String_Access := null;\n       --  The cached value of ADA_OBJECTS_PATH for this project file. Do not\n       --  use this field directly outside of the compiler, use\n-      --  Prj.Env.Ada_Objects_Path instead. Set by Prj.Env.Ada_Objects_Path\n+      --  Prj.Env.Ada_Objects_Path instead.\n \n-      Include_Path_File : Path_Name_Type := No_Path;\n-      --  The cached value of the source path temp file for this project file.\n-      --  Set by gnatmake (Prj.Env.Set_Ada_Paths).\n+      Objects_Path                  : String_Access := null;\n+      --  ???\n \n       Objects_Path_File_With_Libs : Path_Name_Type := No_Path;\n       --  The cached value of the object path temp file (including library\n-      --  dirs) for this project file. Set by gnatmake (Prj.Env.Set_Ada_Paths).\n+      --  dirs) for this project file.\n \n       Objects_Path_File_Without_Libs : Path_Name_Type := No_Path;\n       --  The cached value of the object path temp file (excluding library\n-      --  dirs) for this project file. Set by gnatmake (Prj.Env.Set_Ada_Paths).\n+      --  dirs) for this project file.\n \n       Config_File_Name : Path_Name_Type := No_Path;\n-      --  The name of the configuration pragmas file, if any.\n-      --  Set by gnatmake (Prj.Env.Create_Config_Pragmas_File).\n+      --  The path name of the configuration pragmas file, if any\n \n       Config_File_Temp : Boolean := False;\n-      --  An indication that the configuration pragmas file is\n-      --  a temporary file that must be deleted at the end.\n-      --  Set by gnatmake (Prj.Env.Create_Config_Pragmas_File).\n+      --  An indication that the configuration pragmas file is a temporary file\n+      --  that must be deleted at the end.\n \n-      Config_Checked : Boolean := False;\n-      --  A flag to avoid checking repetitively the configuration pragmas file.\n-      --  Set by gnatmake (Prj.Env.Create_Config_Pragmas_File).\n+      Linker_Name                    : File_Name_Type  := No_File;\n+      --  Value of attribute Language_Processing'Linker in the project file\n+\n+      Linker_Path                    : Path_Name_Type  := No_Path;\n+      --  Path of linker when attribute Language_Processing'Linker is specified\n+\n+      Minimum_Linker_Options         : Name_List_Index := No_Name_List;\n+      --  List of options specified in attribute\n+      --  Language_Processing'Minimum_Linker_Options.\n \n-      Language_Independent_Checked : Boolean := False;\n-      --  A flag that indicates that the project file has been checked\n-      --  for language independent features: Object_Directory,\n-      --  Source_Directories, Library, non empty Naming Suffixes.\n+      Config_Checked : Boolean := False;\n+      --  A flag to avoid checking repetitively the configuration pragmas file\n \n       Checked : Boolean := False;\n-      --  A flag to avoid checking repetitively the naming scheme of\n-      --  this project file. Set by Prj.Nmsc.Check_Ada_Naming_Scheme.\n+      --  A flag to avoid checking repetitively the naming scheme of this\n+      --  project file.\n \n       Seen : Boolean := False;\n       --  A flag to mark a project as \"visited\" to avoid processing the same\n@@ -822,18 +1273,46 @@ package Prj is\n       --  rebuilt.\n \n       Depth : Natural := 0;\n-      --  The maximum depth of a project in the project graph.\n-      --  Depth of main project is 0.\n+      --  The maximum depth of a project in the project graph. Depth of main\n+      --  project is 0.\n \n       Unkept_Comments : Boolean := False;\n-      --  True if there are comments in the project sources that cannot\n-      --  be kept in the project tree.\n+      --  True if there are comments in the project sources that cannot be kept\n+      --  in the project tree.\n+\n+      --  For gprmake\n+\n+      Langs          : Languages_In_Project := No_Languages;\n+      Supp_Languages : Supp_Language_Index  := No_Supp_Language_Index;\n+      --  Indicate the different languages of the source of this project\n+\n+      Ada_Sources_Present   : Boolean := True;\n+      Other_Sources_Present : Boolean := True;\n+      First_Other_Source    : Other_Source_Id := No_Other_Source;\n+      Last_Other_Source     : Other_Source_Id := No_Other_Source;\n+      First_Lang_Processing : First_Language_Processing_Data :=\n+                                    Default_First_Language_Processing_Data;\n+      Supp_Language_Processing : Supp_Language_Index := No_Supp_Language_Index;\n    end record;\n \n    function Empty_Project (Tree : Project_Tree_Ref) return Project_Data;\n    --  Return the representation of an empty project in project Tree tree.\n    --  The project tree Tree must have been Initialized and/or Reset.\n \n+   function Is_Extending\n+     (Extending : Project_Id;\n+      Extended  : Project_Id;\n+      In_Tree   : Project_Tree_Ref) return Boolean;\n+\n+   function Is_A_Language\n+     (Tree          : Project_Tree_Ref;\n+      Data          : Project_Data;\n+      Language_Name : String) return Boolean;\n+\n+   function There_Are_Ada_Sources\n+     (In_Tree : Project_Tree_Ref;\n+      Project : Project_Id) return Boolean;\n+\n    Project_Error : exception;\n    --  Raised by some subprograms in Prj.Attr\n \n@@ -850,19 +1329,19 @@ package Prj is\n \n    type File_Name_Data is record\n       Name         : File_Name_Type := No_File;\n-      Index        : Int            := 0;\n+      Index        : Int        := 0;\n       Display_Name : File_Name_Type := No_File;\n-      Path         : File_Name_Type := No_File;\n-      Display_Path : File_Name_Type := No_File;\n-      Project      : Project_Id     := No_Project;\n-      Needs_Pragma : Boolean        := False;\n+      Path         : Path_Name_Type := No_Path;\n+      Display_Path : Path_Name_Type := No_Path;\n+      Project      : Project_Id := No_Project;\n+      Needs_Pragma : Boolean    := False;\n    end record;\n    --  File and Path name of a spec or body\n \n    type File_Names_Data is array (Spec_Or_Body) of File_Name_Data;\n \n-   type Unit_Id is new Nat;\n-   No_Unit : constant Unit_Id := 0;\n+   type Unit_Index is new Nat;\n+   No_Unit_Index : constant Unit_Index := 0;\n    type Unit_Data is record\n       Name       : Name_Id    := No_Name;\n       File_Names : File_Names_Data;\n@@ -872,27 +1351,27 @@ package Prj is\n \n    package Unit_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => Unit_Data,\n-      Table_Index_Type     => Unit_Id,\n+      Table_Index_Type     => Unit_Index,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 100,\n       Table_Increment      => 100);\n    --  Table of all units in a project tree\n \n    package Units_Htable is new Simple_HTable\n      (Header_Num => Header_Num,\n-      Element    => Unit_Id,\n-      No_Element => No_Unit,\n+      Element    => Unit_Index,\n+      No_Element => No_Unit_Index,\n       Key        => Name_Id,\n       Hash       => Hash,\n       Equal      => \"=\");\n    --  Mapping of unit names to indexes in the Units table\n \n    type Unit_Project is record\n-      Unit    : Unit_Id    := No_Unit;\n+      Unit    : Unit_Index := No_Unit_Index;\n       Project : Project_Id := No_Project;\n    end record;\n \n-   No_Unit_Project : constant Unit_Project := (No_Unit, No_Project);\n+   No_Unit_Project : constant Unit_Project := (No_Unit_Index, No_Project);\n \n    package Files_Htable is new Simple_HTable\n      (Header_Num => Header_Num,\n@@ -908,22 +1387,50 @@ package Prj is\n \n    type Project_Tree_Data is\n       record\n+         --  General\n+\n+         Default_Language         : Name_Id         := No_Name;\n+         --  The name of the language of the sources of a project, when\n+         --  attribute Languages is not specified.\n+\n+         Config                   : Project_Configuration;\n+\n+         --  Languages and sources of the project\n+\n+         First_Language           : Language_Index  := No_Language_Index;\n+         --\n+\n+         First_Source             : Source_Id := No_Source;\n+         --\n+\n+         --  Tables\n+\n+         Languages_Data           : Language_Data_Table.Instance;\n+         Name_Lists               : Name_List_Table.Instance;\n+         String_Elements          : String_Element_Table.Instance;\n+         Variable_Elements        : Variable_Element_Table.Instance;\n+         Array_Elements           : Array_Element_Table.Instance;\n+         Arrays                   : Array_Table.Instance;\n+         Packages                 : Package_Table.Instance;\n+         Project_Lists            : Project_List_Table.Instance;\n+         Projects                 : Project_Table.Instance;\n+         Sources                  : Source_Data_Table.Instance;\n+         Alt_Langs                : Alternate_Language_Table.Instance;\n+         Units                    : Unit_Table.Instance;\n+         Units_HT                 : Units_Htable.Instance;\n+         Files_HT                 : Files_Htable.Instance;\n+         Source_Paths_HT          : Source_Paths_Htable.Instance;\n+\n+         --  For gprmake:\n+\n          Present_Languages : Present_Language_Table.Instance;\n          Supp_Suffixes     : Supp_Suffix_Table.Instance;\n-         Name_Lists        : Name_List_Table.Instance;\n          Supp_Languages    : Supp_Language_Table.Instance;\n          Other_Sources     : Other_Source_Table.Instance;\n-         String_Elements   : String_Element_Table.Instance;\n-         Variable_Elements : Variable_Element_Table.Instance;\n-         Array_Elements    : Array_Element_Table.Instance;\n-         Arrays            : Array_Table.Instance;\n-         Packages          : Package_Table.Instance;\n-         Project_Lists     : Project_List_Table.Instance;\n-         Projects          : Project_Table.Instance;\n-         Units             : Unit_Table.Instance;\n-         Units_HT          : Units_Htable.Instance;\n-         Files_HT          : Files_Htable.Instance;\n-         Private_Part      : Private_Project_Tree_Data;\n+\n+         --  Private part\n+\n+         Private_Part             : Private_Project_Tree_Data;\n       end record;\n    --  Data for a project tree\n \n@@ -975,9 +1482,32 @@ package Prj is\n    --  that are extended by other projects are not considered. With_State may\n    --  be used by Action to choose a behavior or to report some global result.\n \n-   ----------------------------------------------------------\n-   -- Other multi-language stuff that may be modified soon --\n-   ----------------------------------------------------------\n+   function Extend_Name\n+     (File        : File_Name_Type;\n+      With_Suffix : String) return File_Name_Type;\n+   --  Replace the extension of File with With_Suffix\n+\n+   function Object_Name\n+     (Source_File_Name : File_Name_Type) return File_Name_Type;\n+   --  Returns the object file name corresponding to a source file name\n+\n+   function Dependency_Name\n+     (Source_File_Name : File_Name_Type;\n+      Dependency       : Dependency_File_Kind) return File_Name_Type;\n+   --  Returns the dependency file name corresponding to a source file name\n+\n+   function Switches_Name\n+     (Source_File_Name : File_Name_Type) return File_Name_Type;\n+   --  Returns the switches file name corresponding to a source file name\n+\n+   --  For gprmake\n+\n+   function Body_Suffix_Of\n+     (Language   : Language_Index;\n+      In_Project : Project_Data;\n+      In_Tree    : Project_Tree_Ref) return String;\n+   --  Returns the suffix of sources of language Language in project In_Project\n+   --  in project tree In_Tree.\n \n    function Is_Present\n      (Language   : Language_Index;\n@@ -1023,6 +1553,17 @@ package Prj is\n       In_Tree      : Project_Tree_Ref);\n    --  Set the suffix for language Language in project In_Project\n \n+   ----------------\n+   -- Temp Files --\n+   ----------------\n+\n+   procedure Record_Temp_File (Path : Path_Name_Type);\n+   --  Record the path of a newly created temporary file, so that it can be\n+   --  deleted later.\n+\n+   procedure Delete_All_Temp_Files;\n+   --  Delete all recorded temporary files\n+\n private\n \n    All_Packages : constant String_List_Access := null;\n@@ -1071,7 +1612,7 @@ private\n    --  Used by Delete_All_Path_Files.\n \n    package Source_Path_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => File_Name_Type,\n+     (Table_Component_Type => Name_Id,\n       Table_Index_Type     => Natural,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 50,\n@@ -1093,5 +1634,7 @@ private\n       Object_Paths   : Object_Path_Table.Instance;\n       Default_Naming : Naming_Data;\n    end record;\n-   --  Comment ???\n+   --  Type to represent the part of a project tree which is private to the\n+   --  Project Manager.\n+\n end Prj;"}, {"sha": "a6803a006f6bf18835a98e8196f26bab1a967ff8", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 12, "deletions": 33, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -33,6 +33,7 @@\n \n with Opt;   use Opt;\n with Table;\n+with Types; use Types;\n \n package body Snames is\n \n@@ -179,6 +180,7 @@ package body Snames is\n      \"ada_2005#\" &\n      \"assertion_policy#\" &\n      \"c_pass_by_copy#\" &\n+     \"check_name#\" &\n      \"compile_time_error#\" &\n      \"compile_time_warning#\" &\n      \"component_alignment#\" &\n@@ -192,6 +194,7 @@ package body Snames is\n      \"extensions_allowed#\" &\n      \"external_name_casing#\" &\n      \"float_representation#\" &\n+     \"implicit_packing#\" &\n      \"initialize_scalars#\" &\n      \"interrupt_state#\" &\n      \"license#\" &\n@@ -447,6 +450,7 @@ package body Snames is\n      \"digits#\" &\n      \"elaborated#\" &\n      \"emax#\" &\n+     \"enabled#\" &\n      \"enum_rep#\" &\n      \"epsilon#\" &\n      \"exponent#\" &\n@@ -672,38 +676,31 @@ package body Snames is\n      \"archive_indexer#\" &\n      \"archive_suffix#\" &\n      \"binder#\" &\n-     \"binder_driver#\" &\n      \"binder_prefix#\" &\n      \"body_suffix#\" &\n      \"builder#\" &\n      \"builder_switches#\" &\n      \"compiler#\" &\n-     \"compiler_driver#\" &\n      \"compiler_kind#\" &\n-     \"compiler_pic_option#\" &\n-     \"compute_dependency#\" &\n      \"config_body_file_name#\" &\n      \"config_body_file_name_pattern#\" &\n      \"config_file_switches#\" &\n      \"config_file_unique#\" &\n      \"config_spec_file_name#\" &\n      \"config_spec_file_name_pattern#\" &\n      \"cross_reference#\" &\n-     \"default_builder_switches#\" &\n-     \"default_global_compiler_switches#\" &\n      \"default_language#\" &\n-     \"default_linker#\" &\n-     \"default_minimum_linker_options#\" &\n      \"default_switches#\" &\n+     \"dependency_driver#\" &\n      \"dependency_file_kind#\" &\n-     \"dependency_option#\" &\n+     \"dependency_switches#\" &\n+     \"driver#\" &\n      \"exec_dir#\" &\n      \"executable#\" &\n      \"executable_suffix#\" &\n      \"extends#\" &\n      \"externally_built#\" &\n      \"finder#\" &\n-     \"global_compiler_switches#\" &\n      \"global_configuration_pragmas#\" &\n      \"global_config_file#\" &\n      \"gnatls#\" &\n@@ -735,7 +732,7 @@ package body Snames is\n      \"library_symbol_file#\" &\n      \"library_symbol_policy#\" &\n      \"library_version#\" &\n-     \"library_version_options#\" &\n+     \"library_version_switches#\" &\n      \"linker#\" &\n      \"linker_executable_option#\" &\n      \"linker_lib_dir_option#\" &\n@@ -747,19 +744,19 @@ package body Snames is\n      \"mapping_spec_suffix#\" &\n      \"mapping_body_suffix#\" &\n      \"metrics#\" &\n-     \"minimum_binder_options#\" &\n-     \"minimum_compiler_options#\" &\n-     \"minimum_linker_options#\" &\n      \"naming#\" &\n      \"objects_path#\" &\n      \"objects_path_file#\" &\n      \"object_dir#\" &\n+     \"pic_option#\" &\n      \"pretty_printer#\" &\n+     \"prefix#\" &\n      \"project#\" &\n      \"roots#\" &\n+     \"required_switches#\" &\n      \"run_path_option#\" &\n      \"runtime_project#\" &\n-     \"shared_library_minimum_options#\" &\n+     \"shared_library_minimum_switches#\" &\n      \"shared_library_prefix#\" &\n      \"shared_library_suffix#\" &\n      \"separate_suffix#\" &\n@@ -853,15 +850,6 @@ package body Snames is\n       return Attribute_Id'Val (N - First_Attribute_Name);\n    end Get_Attribute_Id;\n \n-   ------------------\n-   -- Get_Check_Id --\n-   ------------------\n-\n-   function Get_Check_Id (N : Name_Id) return Check_Id is\n-   begin\n-      return Check_Id'Val (N - First_Check_Name);\n-   end Get_Check_Id;\n-\n    -----------------------\n    -- Get_Convention_Id --\n    -----------------------\n@@ -1032,15 +1020,6 @@ package body Snames is\n       return N in First_Attribute_Name .. Last_Attribute_Name;\n    end Is_Attribute_Name;\n \n-   -------------------\n-   -- Is_Check_Name --\n-   -------------------\n-\n-   function Is_Check_Name (N : Name_Id) return Boolean is\n-   begin\n-      return N in First_Check_Name .. Last_Check_Name;\n-   end Is_Check_Name;\n-\n    ------------------------\n    -- Is_Convention_Name --\n    ------------------------"}, {"sha": "5fe569f5e7e666748510f144f0c65fdd30ec3aa0", "filename": "gcc/ada/snames.ads", "status": "modified", "additions": 629, "deletions": 640, "changes": 1269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fsnames.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fsnames.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -32,7 +32,6 @@\n ------------------------------------------------------------------------------\n \n with Namet; use Namet;\n-with Types; use Types;\n \n package Snames is\n \n@@ -342,148 +341,150 @@ package Snames is\n    Name_Ada_2005                       : constant Name_Id := N + 119; -- GNAT\n    Name_Assertion_Policy               : constant Name_Id := N + 120; -- Ada 05\n    Name_C_Pass_By_Copy                 : constant Name_Id := N + 121; -- GNAT\n-   Name_Compile_Time_Error             : constant Name_Id := N + 122; -- GNAT\n-   Name_Compile_Time_Warning           : constant Name_Id := N + 123; -- GNAT\n-   Name_Component_Alignment            : constant Name_Id := N + 124; -- GNAT\n-   Name_Convention_Identifier          : constant Name_Id := N + 125; -- GNAT\n-   Name_Debug_Policy                   : constant Name_Id := N + 126; -- GNAT\n-   Name_Detect_Blocking                : constant Name_Id := N + 127; -- Ada 05\n-   Name_Discard_Names                  : constant Name_Id := N + 128;\n-   Name_Elaboration_Checks             : constant Name_Id := N + 129; -- GNAT\n-   Name_Eliminate                      : constant Name_Id := N + 130; -- GNAT\n-   Name_Extend_System                  : constant Name_Id := N + 131; -- GNAT\n-   Name_Extensions_Allowed             : constant Name_Id := N + 132; -- GNAT\n-   Name_External_Name_Casing           : constant Name_Id := N + 133; -- GNAT\n-   Name_Float_Representation           : constant Name_Id := N + 134; -- GNAT\n-   Name_Initialize_Scalars             : constant Name_Id := N + 135; -- GNAT\n-   Name_Interrupt_State                : constant Name_Id := N + 136; -- GNAT\n-   Name_License                        : constant Name_Id := N + 137; -- GNAT\n-   Name_Locking_Policy                 : constant Name_Id := N + 138;\n-   Name_Long_Float                     : constant Name_Id := N + 139; -- VMS\n-   Name_No_Run_Time                    : constant Name_Id := N + 140; -- GNAT\n-   Name_No_Strict_Aliasing             : constant Name_Id := N + 141; -- GNAT\n-   Name_Normalize_Scalars              : constant Name_Id := N + 142;\n-   Name_Polling                        : constant Name_Id := N + 143; -- GNAT\n-   Name_Persistent_BSS                 : constant Name_Id := N + 144; -- GNAT\n-   Name_Priority_Specific_Dispatching  : constant Name_Id := N + 145; -- Ada 05\n-   Name_Profile                        : constant Name_Id := N + 146; -- Ada 05\n-   Name_Profile_Warnings               : constant Name_Id := N + 147; -- GNAT\n-   Name_Propagate_Exceptions           : constant Name_Id := N + 148; -- GNAT\n-   Name_Queuing_Policy                 : constant Name_Id := N + 149;\n-   Name_Ravenscar                      : constant Name_Id := N + 150; -- GNAT\n-   Name_Restricted_Run_Time            : constant Name_Id := N + 151; -- GNAT\n-   Name_Restrictions                   : constant Name_Id := N + 152;\n-   Name_Restriction_Warnings           : constant Name_Id := N + 153; -- GNAT\n-   Name_Reviewable                     : constant Name_Id := N + 154;\n-   Name_Source_File_Name               : constant Name_Id := N + 155; -- GNAT\n-   Name_Source_File_Name_Project       : constant Name_Id := N + 156; -- GNAT\n-   Name_Style_Checks                   : constant Name_Id := N + 157; -- GNAT\n-   Name_Suppress                       : constant Name_Id := N + 158;\n-   Name_Suppress_Exception_Locations   : constant Name_Id := N + 159; -- GNAT\n-   Name_Task_Dispatching_Policy        : constant Name_Id := N + 160;\n-   Name_Universal_Data                 : constant Name_Id := N + 161; -- AAMP\n-   Name_Unsuppress                     : constant Name_Id := N + 162; -- GNAT\n-   Name_Use_VADS_Size                  : constant Name_Id := N + 163; -- GNAT\n-   Name_Validity_Checks                : constant Name_Id := N + 164; -- GNAT\n-   Name_Warnings                       : constant Name_Id := N + 165; -- GNAT\n-   Name_Wide_Character_Encoding        : constant Name_Id := N + 166; -- GNAT\n-   Last_Configuration_Pragma_Name      : constant Name_Id := N + 166;\n+   Name_Check_Name                     : constant Name_Id := N + 122; -- GNAT\n+   Name_Compile_Time_Error             : constant Name_Id := N + 123; -- GNAT\n+   Name_Compile_Time_Warning           : constant Name_Id := N + 124; -- GNAT\n+   Name_Component_Alignment            : constant Name_Id := N + 125; -- GNAT\n+   Name_Convention_Identifier          : constant Name_Id := N + 126; -- GNAT\n+   Name_Debug_Policy                   : constant Name_Id := N + 127; -- GNAT\n+   Name_Detect_Blocking                : constant Name_Id := N + 128; -- Ada 05\n+   Name_Discard_Names                  : constant Name_Id := N + 129;\n+   Name_Elaboration_Checks             : constant Name_Id := N + 130; -- GNAT\n+   Name_Eliminate                      : constant Name_Id := N + 131; -- GNAT\n+   Name_Extend_System                  : constant Name_Id := N + 132; -- GNAT\n+   Name_Extensions_Allowed             : constant Name_Id := N + 133; -- GNAT\n+   Name_External_Name_Casing           : constant Name_Id := N + 134; -- GNAT\n+   Name_Float_Representation           : constant Name_Id := N + 135; -- GNAT\n+   Name_Implicit_Packing               : constant Name_Id := N + 136; -- GNAT\n+   Name_Initialize_Scalars             : constant Name_Id := N + 137; -- GNAT\n+   Name_Interrupt_State                : constant Name_Id := N + 138; -- GNAT\n+   Name_License                        : constant Name_Id := N + 139; -- GNAT\n+   Name_Locking_Policy                 : constant Name_Id := N + 140;\n+   Name_Long_Float                     : constant Name_Id := N + 141; -- VMS\n+   Name_No_Run_Time                    : constant Name_Id := N + 142; -- GNAT\n+   Name_No_Strict_Aliasing             : constant Name_Id := N + 143; -- GNAT\n+   Name_Normalize_Scalars              : constant Name_Id := N + 144;\n+   Name_Polling                        : constant Name_Id := N + 145; -- GNAT\n+   Name_Persistent_BSS                 : constant Name_Id := N + 146; -- GNAT\n+   Name_Priority_Specific_Dispatching  : constant Name_Id := N + 147; -- Ada 05\n+   Name_Profile                        : constant Name_Id := N + 148; -- Ada 05\n+   Name_Profile_Warnings               : constant Name_Id := N + 149; -- GNAT\n+   Name_Propagate_Exceptions           : constant Name_Id := N + 150; -- GNAT\n+   Name_Queuing_Policy                 : constant Name_Id := N + 151;\n+   Name_Ravenscar                      : constant Name_Id := N + 152; -- GNAT\n+   Name_Restricted_Run_Time            : constant Name_Id := N + 153; -- GNAT\n+   Name_Restrictions                   : constant Name_Id := N + 154;\n+   Name_Restriction_Warnings           : constant Name_Id := N + 155; -- GNAT\n+   Name_Reviewable                     : constant Name_Id := N + 156;\n+   Name_Source_File_Name               : constant Name_Id := N + 157; -- GNAT\n+   Name_Source_File_Name_Project       : constant Name_Id := N + 158; -- GNAT\n+   Name_Style_Checks                   : constant Name_Id := N + 159; -- GNAT\n+   Name_Suppress                       : constant Name_Id := N + 160;\n+   Name_Suppress_Exception_Locations   : constant Name_Id := N + 161; -- GNAT\n+   Name_Task_Dispatching_Policy        : constant Name_Id := N + 162;\n+   Name_Universal_Data                 : constant Name_Id := N + 163; -- AAMP\n+   Name_Unsuppress                     : constant Name_Id := N + 164; -- GNAT\n+   Name_Use_VADS_Size                  : constant Name_Id := N + 165; -- GNAT\n+   Name_Validity_Checks                : constant Name_Id := N + 166; -- GNAT\n+   Name_Warnings                       : constant Name_Id := N + 167; -- GNAT\n+   Name_Wide_Character_Encoding        : constant Name_Id := N + 168; -- GNAT\n+   Last_Configuration_Pragma_Name      : constant Name_Id := N + 168;\n \n    --  Remaining pragma names\n \n-   Name_Abort_Defer                    : constant Name_Id := N + 167; -- GNAT\n-   Name_All_Calls_Remote               : constant Name_Id := N + 168;\n-   Name_Annotate                       : constant Name_Id := N + 169; -- GNAT\n+   Name_Abort_Defer                    : constant Name_Id := N + 169; -- GNAT\n+   Name_All_Calls_Remote               : constant Name_Id := N + 170;\n+   Name_Annotate                       : constant Name_Id := N + 171; -- GNAT\n \n    --  Note: AST_Entry is not in this list because its name matches the\n    --  name of the corresponding attribute. However, it is included in the\n    --  definition of the type Pragma_Id, and the functions Get_Pragma_Id\n    --  and Check_Pragma_Id correctly recognize and process Name_AST_Entry.\n    --  AST_Entry is a VMS specific pragma.\n \n-   Name_Assert                         : constant Name_Id := N + 170; -- Ada 05\n-   Name_Asynchronous                   : constant Name_Id := N + 171;\n-   Name_Atomic                         : constant Name_Id := N + 172;\n-   Name_Atomic_Components              : constant Name_Id := N + 173;\n-   Name_Attach_Handler                 : constant Name_Id := N + 174;\n-   Name_CIL_Constructor                : constant Name_Id := N + 175; -- GNAT\n-   Name_Comment                        : constant Name_Id := N + 176; -- GNAT\n-   Name_Common_Object                  : constant Name_Id := N + 177; -- GNAT\n-   Name_Complete_Representation        : constant Name_Id := N + 178; -- GNAT\n-   Name_Complex_Representation         : constant Name_Id := N + 179; -- GNAT\n-   Name_Controlled                     : constant Name_Id := N + 180;\n-   Name_Convention                     : constant Name_Id := N + 181;\n-   Name_CPP_Class                      : constant Name_Id := N + 182; -- GNAT\n-   Name_CPP_Constructor                : constant Name_Id := N + 183; -- GNAT\n-   Name_CPP_Virtual                    : constant Name_Id := N + 184; -- GNAT\n-   Name_CPP_Vtable                     : constant Name_Id := N + 185; -- GNAT\n-   Name_Debug                          : constant Name_Id := N + 186; -- GNAT\n-   Name_Elaborate                      : constant Name_Id := N + 187; -- Ada 83\n-   Name_Elaborate_All                  : constant Name_Id := N + 188;\n-   Name_Elaborate_Body                 : constant Name_Id := N + 189;\n-   Name_Export                         : constant Name_Id := N + 190;\n-   Name_Export_Exception               : constant Name_Id := N + 191; -- VMS\n-   Name_Export_Function                : constant Name_Id := N + 192; -- GNAT\n-   Name_Export_Object                  : constant Name_Id := N + 193; -- GNAT\n-   Name_Export_Procedure               : constant Name_Id := N + 194; -- GNAT\n-   Name_Export_Value                   : constant Name_Id := N + 195; -- GNAT\n-   Name_Export_Valued_Procedure        : constant Name_Id := N + 196; -- GNAT\n-   Name_External                       : constant Name_Id := N + 197; -- GNAT\n-   Name_Finalize_Storage_Only          : constant Name_Id := N + 198; -- GNAT\n-   Name_Ident                          : constant Name_Id := N + 199; -- VMS\n-   Name_Import                         : constant Name_Id := N + 200;\n-   Name_Import_Exception               : constant Name_Id := N + 201; -- VMS\n-   Name_Import_Function                : constant Name_Id := N + 202; -- GNAT\n-   Name_Import_Object                  : constant Name_Id := N + 203; -- GNAT\n-   Name_Import_Procedure               : constant Name_Id := N + 204; -- GNAT\n-   Name_Import_Valued_Procedure        : constant Name_Id := N + 205; -- GNAT\n-   Name_Inline                         : constant Name_Id := N + 206;\n-   Name_Inline_Always                  : constant Name_Id := N + 207; -- GNAT\n-   Name_Inline_Generic                 : constant Name_Id := N + 208; -- GNAT\n-   Name_Inspection_Point               : constant Name_Id := N + 209;\n-   Name_Interface_Name                 : constant Name_Id := N + 210; -- GNAT\n-   Name_Interrupt_Handler              : constant Name_Id := N + 211;\n-   Name_Interrupt_Priority             : constant Name_Id := N + 212;\n-   Name_Java_Constructor               : constant Name_Id := N + 213; -- GNAT\n-   Name_Java_Interface                 : constant Name_Id := N + 214; -- GNAT\n-   Name_Keep_Names                     : constant Name_Id := N + 215; -- GNAT\n-   Name_Link_With                      : constant Name_Id := N + 216; -- GNAT\n-   Name_Linker_Alias                   : constant Name_Id := N + 217; -- GNAT\n-   Name_Linker_Constructor             : constant Name_Id := N + 218; -- GNAT\n-   Name_Linker_Destructor              : constant Name_Id := N + 219; -- GNAT\n-   Name_Linker_Options                 : constant Name_Id := N + 220;\n-   Name_Linker_Section                 : constant Name_Id := N + 221; -- GNAT\n-   Name_List                           : constant Name_Id := N + 222;\n-   Name_Machine_Attribute              : constant Name_Id := N + 223; -- GNAT\n-   Name_Main                           : constant Name_Id := N + 224; -- GNAT\n-   Name_Main_Storage                   : constant Name_Id := N + 225; -- GNAT\n-   Name_Memory_Size                    : constant Name_Id := N + 226; -- Ada 83\n-   Name_No_Body                        : constant Name_Id := N + 227; -- GNAT\n-   Name_No_Return                      : constant Name_Id := N + 228; -- GNAT\n-   Name_Obsolescent                    : constant Name_Id := N + 229; -- GNAT\n-   Name_Optimize                       : constant Name_Id := N + 230;\n-   Name_Pack                           : constant Name_Id := N + 231;\n-   Name_Page                           : constant Name_Id := N + 232;\n-   Name_Passive                        : constant Name_Id := N + 233; -- GNAT\n-   Name_Preelaborable_Initialization   : constant Name_Id := N + 234; -- Ada 05\n-   Name_Preelaborate                   : constant Name_Id := N + 235;\n-   Name_Preelaborate_05                : constant Name_Id := N + 236; -- GNAT\n+   Name_Assert                         : constant Name_Id := N + 172; -- Ada 05\n+   Name_Asynchronous                   : constant Name_Id := N + 173;\n+   Name_Atomic                         : constant Name_Id := N + 174;\n+   Name_Atomic_Components              : constant Name_Id := N + 175;\n+   Name_Attach_Handler                 : constant Name_Id := N + 176;\n+   Name_CIL_Constructor                : constant Name_Id := N + 177; -- GNAT\n+   Name_Comment                        : constant Name_Id := N + 178; -- GNAT\n+   Name_Common_Object                  : constant Name_Id := N + 179; -- GNAT\n+   Name_Complete_Representation        : constant Name_Id := N + 180; -- GNAT\n+   Name_Complex_Representation         : constant Name_Id := N + 181; -- GNAT\n+   Name_Controlled                     : constant Name_Id := N + 182;\n+   Name_Convention                     : constant Name_Id := N + 183;\n+   Name_CPP_Class                      : constant Name_Id := N + 184; -- GNAT\n+   Name_CPP_Constructor                : constant Name_Id := N + 185; -- GNAT\n+   Name_CPP_Virtual                    : constant Name_Id := N + 186; -- GNAT\n+   Name_CPP_Vtable                     : constant Name_Id := N + 187; -- GNAT\n+   Name_Debug                          : constant Name_Id := N + 188; -- GNAT\n+   Name_Elaborate                      : constant Name_Id := N + 189; -- Ada 83\n+   Name_Elaborate_All                  : constant Name_Id := N + 190;\n+   Name_Elaborate_Body                 : constant Name_Id := N + 191;\n+   Name_Export                         : constant Name_Id := N + 192;\n+   Name_Export_Exception               : constant Name_Id := N + 193; -- VMS\n+   Name_Export_Function                : constant Name_Id := N + 194; -- GNAT\n+   Name_Export_Object                  : constant Name_Id := N + 195; -- GNAT\n+   Name_Export_Procedure               : constant Name_Id := N + 196; -- GNAT\n+   Name_Export_Value                   : constant Name_Id := N + 197; -- GNAT\n+   Name_Export_Valued_Procedure        : constant Name_Id := N + 198; -- GNAT\n+   Name_External                       : constant Name_Id := N + 199; -- GNAT\n+   Name_Finalize_Storage_Only          : constant Name_Id := N + 200; -- GNAT\n+   Name_Ident                          : constant Name_Id := N + 201; -- VMS\n+   Name_Import                         : constant Name_Id := N + 202;\n+   Name_Import_Exception               : constant Name_Id := N + 203; -- VMS\n+   Name_Import_Function                : constant Name_Id := N + 204; -- GNAT\n+   Name_Import_Object                  : constant Name_Id := N + 205; -- GNAT\n+   Name_Import_Procedure               : constant Name_Id := N + 206; -- GNAT\n+   Name_Import_Valued_Procedure        : constant Name_Id := N + 207; -- GNAT\n+   Name_Inline                         : constant Name_Id := N + 208;\n+   Name_Inline_Always                  : constant Name_Id := N + 209; -- GNAT\n+   Name_Inline_Generic                 : constant Name_Id := N + 210; -- GNAT\n+   Name_Inspection_Point               : constant Name_Id := N + 211;\n+   Name_Interface_Name                 : constant Name_Id := N + 212; -- GNAT\n+   Name_Interrupt_Handler              : constant Name_Id := N + 213;\n+   Name_Interrupt_Priority             : constant Name_Id := N + 214;\n+   Name_Java_Constructor               : constant Name_Id := N + 215; -- GNAT\n+   Name_Java_Interface                 : constant Name_Id := N + 216; -- GNAT\n+   Name_Keep_Names                     : constant Name_Id := N + 217; -- GNAT\n+   Name_Link_With                      : constant Name_Id := N + 218; -- GNAT\n+   Name_Linker_Alias                   : constant Name_Id := N + 219; -- GNAT\n+   Name_Linker_Constructor             : constant Name_Id := N + 220; -- GNAT\n+   Name_Linker_Destructor              : constant Name_Id := N + 221; -- GNAT\n+   Name_Linker_Options                 : constant Name_Id := N + 222;\n+   Name_Linker_Section                 : constant Name_Id := N + 223; -- GNAT\n+   Name_List                           : constant Name_Id := N + 224;\n+   Name_Machine_Attribute              : constant Name_Id := N + 225; -- GNAT\n+   Name_Main                           : constant Name_Id := N + 226; -- GNAT\n+   Name_Main_Storage                   : constant Name_Id := N + 227; -- GNAT\n+   Name_Memory_Size                    : constant Name_Id := N + 228; -- Ada 83\n+   Name_No_Body                        : constant Name_Id := N + 229; -- GNAT\n+   Name_No_Return                      : constant Name_Id := N + 230; -- GNAT\n+   Name_Obsolescent                    : constant Name_Id := N + 231; -- GNAT\n+   Name_Optimize                       : constant Name_Id := N + 232;\n+   Name_Pack                           : constant Name_Id := N + 233;\n+   Name_Page                           : constant Name_Id := N + 234;\n+   Name_Passive                        : constant Name_Id := N + 235; -- GNAT\n+   Name_Preelaborable_Initialization   : constant Name_Id := N + 236; -- Ada 05\n+   Name_Preelaborate                   : constant Name_Id := N + 237;\n+   Name_Preelaborate_05                : constant Name_Id := N + 238; -- GNAT\n \n    --  Note: Priority is not in this list because its name matches the\n    --  name of the corresponding attribute. However, it is included in the\n    --  definition of the type Pragma_Id, and the functions Get_Pragma_Id\n    --  and Check_Pragma_Id correctly recognize and process Priority.\n    --  Priority is a standard Ada 95 pragma.\n \n-   Name_Psect_Object                   : constant Name_Id := N + 237; -- VMS\n-   Name_Pure                           : constant Name_Id := N + 238;\n-   Name_Pure_05                        : constant Name_Id := N + 239; -- GNAT\n-   Name_Pure_Function                  : constant Name_Id := N + 240; -- GNAT\n-   Name_Remote_Call_Interface          : constant Name_Id := N + 241;\n-   Name_Remote_Types                   : constant Name_Id := N + 242;\n-   Name_Share_Generic                  : constant Name_Id := N + 243; -- GNAT\n-   Name_Shared                         : constant Name_Id := N + 244; -- Ada 83\n-   Name_Shared_Passive                 : constant Name_Id := N + 245;\n+   Name_Psect_Object                   : constant Name_Id := N + 239; -- VMS\n+   Name_Pure                           : constant Name_Id := N + 240;\n+   Name_Pure_05                        : constant Name_Id := N + 241; -- GNAT\n+   Name_Pure_Function                  : constant Name_Id := N + 242; -- GNAT\n+   Name_Remote_Call_Interface          : constant Name_Id := N + 243;\n+   Name_Remote_Types                   : constant Name_Id := N + 244;\n+   Name_Share_Generic                  : constant Name_Id := N + 245; -- GNAT\n+   Name_Shared                         : constant Name_Id := N + 246; -- Ada 83\n+   Name_Shared_Passive                 : constant Name_Id := N + 247;\n \n    --  Note: Storage_Size is not in this list because its name matches the\n    --  name of the corresponding attribute. However, it is included in the\n@@ -493,29 +494,29 @@ package Snames is\n    --  Note: Storage_Unit is also omitted from the list because of a clash\n    --  with an attribute name, and is treated similarly.\n \n-   Name_Source_Reference               : constant Name_Id := N + 246; -- GNAT\n-   Name_Static_Elaboration_Desired     : constant Name_Id := N + 247; -- GNAT\n-   Name_Stream_Convert                 : constant Name_Id := N + 248; -- GNAT\n-   Name_Subtitle                       : constant Name_Id := N + 249; -- GNAT\n-   Name_Suppress_All                   : constant Name_Id := N + 250; -- GNAT\n-   Name_Suppress_Debug_Info            : constant Name_Id := N + 251; -- GNAT\n-   Name_Suppress_Initialization        : constant Name_Id := N + 252; -- GNAT\n-   Name_System_Name                    : constant Name_Id := N + 253; -- Ada 83\n-   Name_Task_Info                      : constant Name_Id := N + 254; -- GNAT\n-   Name_Task_Name                      : constant Name_Id := N + 255; -- GNAT\n-   Name_Task_Storage                   : constant Name_Id := N + 256; -- VMS\n-   Name_Time_Slice                     : constant Name_Id := N + 257; -- GNAT\n-   Name_Title                          : constant Name_Id := N + 258; -- GNAT\n-   Name_Unchecked_Union                : constant Name_Id := N + 259; -- GNAT\n-   Name_Unimplemented_Unit             : constant Name_Id := N + 260; -- GNAT\n-   Name_Universal_Aliasing             : constant Name_Id := N + 261; -- GNAT\n-   Name_Unreferenced                   : constant Name_Id := N + 262; -- GNAT\n-   Name_Unreferenced_Objects           : constant Name_Id := N + 263; -- GNAT\n-   Name_Unreserve_All_Interrupts       : constant Name_Id := N + 264; -- GNAT\n-   Name_Volatile                       : constant Name_Id := N + 265;\n-   Name_Volatile_Components            : constant Name_Id := N + 266;\n-   Name_Weak_External                  : constant Name_Id := N + 267; -- GNAT\n-   Last_Pragma_Name                    : constant Name_Id := N + 267;\n+   Name_Source_Reference               : constant Name_Id := N + 248; -- GNAT\n+   Name_Static_Elaboration_Desired     : constant Name_Id := N + 249; -- GNAT\n+   Name_Stream_Convert                 : constant Name_Id := N + 250; -- GNAT\n+   Name_Subtitle                       : constant Name_Id := N + 251; -- GNAT\n+   Name_Suppress_All                   : constant Name_Id := N + 252; -- GNAT\n+   Name_Suppress_Debug_Info            : constant Name_Id := N + 253; -- GNAT\n+   Name_Suppress_Initialization        : constant Name_Id := N + 254; -- GNAT\n+   Name_System_Name                    : constant Name_Id := N + 255; -- Ada 83\n+   Name_Task_Info                      : constant Name_Id := N + 256; -- GNAT\n+   Name_Task_Name                      : constant Name_Id := N + 257; -- GNAT\n+   Name_Task_Storage                   : constant Name_Id := N + 258; -- VMS\n+   Name_Time_Slice                     : constant Name_Id := N + 259; -- GNAT\n+   Name_Title                          : constant Name_Id := N + 260; -- GNAT\n+   Name_Unchecked_Union                : constant Name_Id := N + 261; -- GNAT\n+   Name_Unimplemented_Unit             : constant Name_Id := N + 262; -- GNAT\n+   Name_Universal_Aliasing             : constant Name_Id := N + 263; -- GNAT\n+   Name_Unreferenced                   : constant Name_Id := N + 264; -- GNAT\n+   Name_Unreferenced_Objects           : constant Name_Id := N + 265; -- GNAT\n+   Name_Unreserve_All_Interrupts       : constant Name_Id := N + 266; -- GNAT\n+   Name_Volatile                       : constant Name_Id := N + 267;\n+   Name_Volatile_Components            : constant Name_Id := N + 268;\n+   Name_Weak_External                  : constant Name_Id := N + 269; -- GNAT\n+   Last_Pragma_Name                    : constant Name_Id := N + 269;\n \n    --  Language convention names for pragma Convention/Export/Import/Interface\n    --  Note that Name_C is not included in this list, since it was already\n@@ -526,119 +527,119 @@ package Snames is\n    --  Entry and Protected, this is because these conventions cannot be\n    --  specified by a pragma.\n \n-   First_Convention_Name               : constant Name_Id := N + 268;\n-   Name_Ada                            : constant Name_Id := N + 268;\n-   Name_Assembler                      : constant Name_Id := N + 269;\n-   Name_CIL                            : constant Name_Id := N + 270;\n-   Name_COBOL                          : constant Name_Id := N + 271;\n-   Name_CPP                            : constant Name_Id := N + 272;\n-   Name_Fortran                        : constant Name_Id := N + 273;\n-   Name_Intrinsic                      : constant Name_Id := N + 274;\n-   Name_Java                           : constant Name_Id := N + 275;\n-   Name_Stdcall                        : constant Name_Id := N + 276;\n-   Name_Stubbed                        : constant Name_Id := N + 277;\n-   Last_Convention_Name                : constant Name_Id := N + 277;\n+   First_Convention_Name               : constant Name_Id := N + 270;\n+   Name_Ada                            : constant Name_Id := N + 270;\n+   Name_Assembler                      : constant Name_Id := N + 271;\n+   Name_CIL                            : constant Name_Id := N + 272;\n+   Name_COBOL                          : constant Name_Id := N + 273;\n+   Name_CPP                            : constant Name_Id := N + 274;\n+   Name_Fortran                        : constant Name_Id := N + 275;\n+   Name_Intrinsic                      : constant Name_Id := N + 276;\n+   Name_Java                           : constant Name_Id := N + 277;\n+   Name_Stdcall                        : constant Name_Id := N + 278;\n+   Name_Stubbed                        : constant Name_Id := N + 279;\n+   Last_Convention_Name                : constant Name_Id := N + 279;\n \n    --  The following names are preset as synonyms for Assembler\n \n-   Name_Asm                            : constant Name_Id := N + 278;\n-   Name_Assembly                       : constant Name_Id := N + 279;\n+   Name_Asm                            : constant Name_Id := N + 280;\n+   Name_Assembly                       : constant Name_Id := N + 281;\n \n    --  The following names are preset as synonyms for C\n \n-   Name_Default                        : constant Name_Id := N + 280;\n+   Name_Default                        : constant Name_Id := N + 282;\n    --  Name_Exernal (previously defined as pragma)\n \n    --  The following names are preset as synonyms for CPP\n \n-   Name_C_Plus_Plus                    : constant Name_Id := N + 281;\n+   Name_C_Plus_Plus                    : constant Name_Id := N + 283;\n \n    --  The following names are present as synonyms for Stdcall\n \n-   Name_DLL                            : constant Name_Id := N + 282;\n-   Name_Win32                          : constant Name_Id := N + 283;\n+   Name_DLL                            : constant Name_Id := N + 284;\n+   Name_Win32                          : constant Name_Id := N + 285;\n \n    --  Other special names used in processing pragmas\n \n-   Name_As_Is                          : constant Name_Id := N + 284;\n-   Name_Attribute_Name                 : constant Name_Id := N + 285;\n-   Name_Body_File_Name                 : constant Name_Id := N + 286;\n-   Name_Boolean_Entry_Barriers         : constant Name_Id := N + 287;\n-   Name_Check                          : constant Name_Id := N + 288;\n-   Name_Casing                         : constant Name_Id := N + 289;\n-   Name_Code                           : constant Name_Id := N + 290;\n-   Name_Component                      : constant Name_Id := N + 291;\n-   Name_Component_Size_4               : constant Name_Id := N + 292;\n-   Name_Copy                           : constant Name_Id := N + 293;\n-   Name_D_Float                        : constant Name_Id := N + 294;\n-   Name_Descriptor                     : constant Name_Id := N + 295;\n-   Name_Dot_Replacement                : constant Name_Id := N + 296;\n-   Name_Dynamic                        : constant Name_Id := N + 297;\n-   Name_Entity                         : constant Name_Id := N + 298;\n-   Name_Entry_Count                    : constant Name_Id := N + 299;\n-   Name_External_Name                  : constant Name_Id := N + 300;\n-   Name_First_Optional_Parameter       : constant Name_Id := N + 301;\n-   Name_Form                           : constant Name_Id := N + 302;\n-   Name_G_Float                        : constant Name_Id := N + 303;\n-   Name_Gcc                            : constant Name_Id := N + 304;\n-   Name_Gnat                           : constant Name_Id := N + 305;\n-   Name_GPL                            : constant Name_Id := N + 306;\n-   Name_IEEE_Float                     : constant Name_Id := N + 307;\n-   Name_Ignore                         : constant Name_Id := N + 308;\n-   Name_Info                           : constant Name_Id := N + 309;\n-   Name_Internal                       : constant Name_Id := N + 310;\n-   Name_Link_Name                      : constant Name_Id := N + 311;\n-   Name_Lowercase                      : constant Name_Id := N + 312;\n-   Name_Max_Entry_Queue_Depth          : constant Name_Id := N + 313;\n-   Name_Max_Entry_Queue_Length         : constant Name_Id := N + 314;\n-   Name_Max_Size                       : constant Name_Id := N + 315;\n-   Name_Mechanism                      : constant Name_Id := N + 316;\n-   Name_Message                        : constant Name_Id := N + 317;\n-   Name_Mixedcase                      : constant Name_Id := N + 318;\n-   Name_Modified_GPL                   : constant Name_Id := N + 319;\n-   Name_Name                           : constant Name_Id := N + 320;\n-   Name_NCA                            : constant Name_Id := N + 321;\n-   Name_No                             : constant Name_Id := N + 322;\n-   Name_No_Dependence                  : constant Name_Id := N + 323;\n-   Name_No_Dynamic_Attachment          : constant Name_Id := N + 324;\n-   Name_No_Dynamic_Interrupts          : constant Name_Id := N + 325;\n-   Name_No_Requeue                     : constant Name_Id := N + 326;\n-   Name_No_Requeue_Statements          : constant Name_Id := N + 327;\n-   Name_No_Task_Attributes             : constant Name_Id := N + 328;\n-   Name_No_Task_Attributes_Package     : constant Name_Id := N + 329;\n-   Name_On                             : constant Name_Id := N + 330;\n-   Name_Parameter_Types                : constant Name_Id := N + 331;\n-   Name_Reference                      : constant Name_Id := N + 332;\n-   Name_Restricted                     : constant Name_Id := N + 333;\n-   Name_Result_Mechanism               : constant Name_Id := N + 334;\n-   Name_Result_Type                    : constant Name_Id := N + 335;\n-   Name_Runtime                        : constant Name_Id := N + 336;\n-   Name_SB                             : constant Name_Id := N + 337;\n-   Name_Secondary_Stack_Size           : constant Name_Id := N + 338;\n-   Name_Section                        : constant Name_Id := N + 339;\n-   Name_Semaphore                      : constant Name_Id := N + 340;\n-   Name_Simple_Barriers                : constant Name_Id := N + 341;\n-   Name_Spec_File_Name                 : constant Name_Id := N + 342;\n-   Name_State                          : constant Name_Id := N + 343;\n-   Name_Static                         : constant Name_Id := N + 344;\n-   Name_Stack_Size                     : constant Name_Id := N + 345;\n-   Name_Subunit_File_Name              : constant Name_Id := N + 346;\n-   Name_Task_Stack_Size_Default        : constant Name_Id := N + 347;\n-   Name_Task_Type                      : constant Name_Id := N + 348;\n-   Name_Time_Slicing_Enabled           : constant Name_Id := N + 349;\n-   Name_Top_Guard                      : constant Name_Id := N + 350;\n-   Name_UBA                            : constant Name_Id := N + 351;\n-   Name_UBS                            : constant Name_Id := N + 352;\n-   Name_UBSB                           : constant Name_Id := N + 353;\n-   Name_Unit_Name                      : constant Name_Id := N + 354;\n-   Name_Unknown                        : constant Name_Id := N + 355;\n-   Name_Unrestricted                   : constant Name_Id := N + 356;\n-   Name_Uppercase                      : constant Name_Id := N + 357;\n-   Name_User                           : constant Name_Id := N + 358;\n-   Name_VAX_Float                      : constant Name_Id := N + 359;\n-   Name_VMS                            : constant Name_Id := N + 360;\n-   Name_Vtable_Ptr                     : constant Name_Id := N + 361;\n-   Name_Working_Storage                : constant Name_Id := N + 362;\n+   Name_As_Is                          : constant Name_Id := N + 286;\n+   Name_Attribute_Name                 : constant Name_Id := N + 287;\n+   Name_Body_File_Name                 : constant Name_Id := N + 288;\n+   Name_Boolean_Entry_Barriers         : constant Name_Id := N + 289;\n+   Name_Check                          : constant Name_Id := N + 290;\n+   Name_Casing                         : constant Name_Id := N + 291;\n+   Name_Code                           : constant Name_Id := N + 292;\n+   Name_Component                      : constant Name_Id := N + 293;\n+   Name_Component_Size_4               : constant Name_Id := N + 294;\n+   Name_Copy                           : constant Name_Id := N + 295;\n+   Name_D_Float                        : constant Name_Id := N + 296;\n+   Name_Descriptor                     : constant Name_Id := N + 297;\n+   Name_Dot_Replacement                : constant Name_Id := N + 298;\n+   Name_Dynamic                        : constant Name_Id := N + 299;\n+   Name_Entity                         : constant Name_Id := N + 300;\n+   Name_Entry_Count                    : constant Name_Id := N + 301;\n+   Name_External_Name                  : constant Name_Id := N + 302;\n+   Name_First_Optional_Parameter       : constant Name_Id := N + 303;\n+   Name_Form                           : constant Name_Id := N + 304;\n+   Name_G_Float                        : constant Name_Id := N + 305;\n+   Name_Gcc                            : constant Name_Id := N + 306;\n+   Name_Gnat                           : constant Name_Id := N + 307;\n+   Name_GPL                            : constant Name_Id := N + 308;\n+   Name_IEEE_Float                     : constant Name_Id := N + 309;\n+   Name_Ignore                         : constant Name_Id := N + 310;\n+   Name_Info                           : constant Name_Id := N + 311;\n+   Name_Internal                       : constant Name_Id := N + 312;\n+   Name_Link_Name                      : constant Name_Id := N + 313;\n+   Name_Lowercase                      : constant Name_Id := N + 314;\n+   Name_Max_Entry_Queue_Depth          : constant Name_Id := N + 315;\n+   Name_Max_Entry_Queue_Length         : constant Name_Id := N + 316;\n+   Name_Max_Size                       : constant Name_Id := N + 317;\n+   Name_Mechanism                      : constant Name_Id := N + 318;\n+   Name_Message                        : constant Name_Id := N + 319;\n+   Name_Mixedcase                      : constant Name_Id := N + 320;\n+   Name_Modified_GPL                   : constant Name_Id := N + 321;\n+   Name_Name                           : constant Name_Id := N + 322;\n+   Name_NCA                            : constant Name_Id := N + 323;\n+   Name_No                             : constant Name_Id := N + 324;\n+   Name_No_Dependence                  : constant Name_Id := N + 325;\n+   Name_No_Dynamic_Attachment          : constant Name_Id := N + 326;\n+   Name_No_Dynamic_Interrupts          : constant Name_Id := N + 327;\n+   Name_No_Requeue                     : constant Name_Id := N + 328;\n+   Name_No_Requeue_Statements          : constant Name_Id := N + 329;\n+   Name_No_Task_Attributes             : constant Name_Id := N + 330;\n+   Name_No_Task_Attributes_Package     : constant Name_Id := N + 331;\n+   Name_On                             : constant Name_Id := N + 332;\n+   Name_Parameter_Types                : constant Name_Id := N + 333;\n+   Name_Reference                      : constant Name_Id := N + 334;\n+   Name_Restricted                     : constant Name_Id := N + 335;\n+   Name_Result_Mechanism               : constant Name_Id := N + 336;\n+   Name_Result_Type                    : constant Name_Id := N + 337;\n+   Name_Runtime                        : constant Name_Id := N + 338;\n+   Name_SB                             : constant Name_Id := N + 339;\n+   Name_Secondary_Stack_Size           : constant Name_Id := N + 340;\n+   Name_Section                        : constant Name_Id := N + 341;\n+   Name_Semaphore                      : constant Name_Id := N + 342;\n+   Name_Simple_Barriers                : constant Name_Id := N + 343;\n+   Name_Spec_File_Name                 : constant Name_Id := N + 344;\n+   Name_State                          : constant Name_Id := N + 345;\n+   Name_Static                         : constant Name_Id := N + 346;\n+   Name_Stack_Size                     : constant Name_Id := N + 347;\n+   Name_Subunit_File_Name              : constant Name_Id := N + 348;\n+   Name_Task_Stack_Size_Default        : constant Name_Id := N + 349;\n+   Name_Task_Type                      : constant Name_Id := N + 350;\n+   Name_Time_Slicing_Enabled           : constant Name_Id := N + 351;\n+   Name_Top_Guard                      : constant Name_Id := N + 352;\n+   Name_UBA                            : constant Name_Id := N + 353;\n+   Name_UBS                            : constant Name_Id := N + 354;\n+   Name_UBSB                           : constant Name_Id := N + 355;\n+   Name_Unit_Name                      : constant Name_Id := N + 356;\n+   Name_Unknown                        : constant Name_Id := N + 357;\n+   Name_Unrestricted                   : constant Name_Id := N + 358;\n+   Name_Uppercase                      : constant Name_Id := N + 359;\n+   Name_User                           : constant Name_Id := N + 360;\n+   Name_VAX_Float                      : constant Name_Id := N + 361;\n+   Name_VMS                            : constant Name_Id := N + 362;\n+   Name_Vtable_Ptr                     : constant Name_Id := N + 363;\n+   Name_Working_Storage                : constant Name_Id := N + 364;\n \n    --  Names of recognized attributes. The entries with the comment \"Ada 83\"\n    --  are attributes that are defined in Ada 83, but not in Ada 95. These\n@@ -652,467 +653,461 @@ package Snames is\n    --  The entries marked VMS are recognized only in OpenVMS implementations\n    --  of GNAT, and are treated as illegal in all other contexts.\n \n-   First_Attribute_Name                : constant Name_Id := N + 363;\n-   Name_Abort_Signal                   : constant Name_Id := N + 363; -- GNAT\n-   Name_Access                         : constant Name_Id := N + 364;\n-   Name_Address                        : constant Name_Id := N + 365;\n-   Name_Address_Size                   : constant Name_Id := N + 366; -- GNAT\n-   Name_Aft                            : constant Name_Id := N + 367;\n-   Name_Alignment                      : constant Name_Id := N + 368;\n-   Name_Asm_Input                      : constant Name_Id := N + 369; -- GNAT\n-   Name_Asm_Output                     : constant Name_Id := N + 370; -- GNAT\n-   Name_AST_Entry                      : constant Name_Id := N + 371; -- VMS\n-   Name_Bit                            : constant Name_Id := N + 372; -- GNAT\n-   Name_Bit_Order                      : constant Name_Id := N + 373;\n-   Name_Bit_Position                   : constant Name_Id := N + 374; -- GNAT\n-   Name_Body_Version                   : constant Name_Id := N + 375;\n-   Name_Callable                       : constant Name_Id := N + 376;\n-   Name_Caller                         : constant Name_Id := N + 377;\n-   Name_Code_Address                   : constant Name_Id := N + 378; -- GNAT\n-   Name_Component_Size                 : constant Name_Id := N + 379;\n-   Name_Compose                        : constant Name_Id := N + 380;\n-   Name_Constrained                    : constant Name_Id := N + 381;\n-   Name_Count                          : constant Name_Id := N + 382;\n-   Name_Default_Bit_Order              : constant Name_Id := N + 383; -- GNAT\n-   Name_Definite                       : constant Name_Id := N + 384;\n-   Name_Delta                          : constant Name_Id := N + 385;\n-   Name_Denorm                         : constant Name_Id := N + 386;\n-   Name_Digits                         : constant Name_Id := N + 387;\n-   Name_Elaborated                     : constant Name_Id := N + 388; -- GNAT\n-   Name_Emax                           : constant Name_Id := N + 389; -- Ada 83\n-   Name_Enum_Rep                       : constant Name_Id := N + 390; -- GNAT\n-   Name_Epsilon                        : constant Name_Id := N + 391; -- Ada 83\n-   Name_Exponent                       : constant Name_Id := N + 392;\n-   Name_External_Tag                   : constant Name_Id := N + 393;\n-   Name_First                          : constant Name_Id := N + 394;\n-   Name_First_Bit                      : constant Name_Id := N + 395;\n-   Name_Fixed_Value                    : constant Name_Id := N + 396; -- GNAT\n-   Name_Fore                           : constant Name_Id := N + 397;\n-   Name_Has_Access_Values              : constant Name_Id := N + 398; -- GNAT\n-   Name_Has_Discriminants              : constant Name_Id := N + 399; -- GNAT\n-   Name_Identity                       : constant Name_Id := N + 400;\n-   Name_Img                            : constant Name_Id := N + 401; -- GNAT\n-   Name_Integer_Value                  : constant Name_Id := N + 402; -- GNAT\n-   Name_Large                          : constant Name_Id := N + 403; -- Ada 83\n-   Name_Last                           : constant Name_Id := N + 404;\n-   Name_Last_Bit                       : constant Name_Id := N + 405;\n-   Name_Leading_Part                   : constant Name_Id := N + 406;\n-   Name_Length                         : constant Name_Id := N + 407;\n-   Name_Machine_Emax                   : constant Name_Id := N + 408;\n-   Name_Machine_Emin                   : constant Name_Id := N + 409;\n-   Name_Machine_Mantissa               : constant Name_Id := N + 410;\n-   Name_Machine_Overflows              : constant Name_Id := N + 411;\n-   Name_Machine_Radix                  : constant Name_Id := N + 412;\n-   Name_Machine_Rounding               : constant Name_Id := N + 413; -- Ada 05\n-   Name_Machine_Rounds                 : constant Name_Id := N + 414;\n-   Name_Machine_Size                   : constant Name_Id := N + 415; -- GNAT\n-   Name_Mantissa                       : constant Name_Id := N + 416; -- Ada 83\n-   Name_Max_Size_In_Storage_Elements   : constant Name_Id := N + 417;\n-   Name_Maximum_Alignment              : constant Name_Id := N + 418; -- GNAT\n-   Name_Mechanism_Code                 : constant Name_Id := N + 419; -- GNAT\n-   Name_Mod                            : constant Name_Id := N + 420;\n-   Name_Model_Emin                     : constant Name_Id := N + 421;\n-   Name_Model_Epsilon                  : constant Name_Id := N + 422;\n-   Name_Model_Mantissa                 : constant Name_Id := N + 423;\n-   Name_Model_Small                    : constant Name_Id := N + 424;\n-   Name_Modulus                        : constant Name_Id := N + 425;\n-   Name_Null_Parameter                 : constant Name_Id := N + 426; -- GNAT\n-   Name_Object_Size                    : constant Name_Id := N + 427; -- GNAT\n-   Name_Partition_ID                   : constant Name_Id := N + 428;\n-   Name_Passed_By_Reference            : constant Name_Id := N + 429; -- GNAT\n-   Name_Pool_Address                   : constant Name_Id := N + 430;\n-   Name_Pos                            : constant Name_Id := N + 431;\n-   Name_Position                       : constant Name_Id := N + 432;\n-   Name_Priority                       : constant Name_Id := N + 433; -- Ada 05\n-   Name_Range                          : constant Name_Id := N + 434;\n-   Name_Range_Length                   : constant Name_Id := N + 435; -- GNAT\n-   Name_Round                          : constant Name_Id := N + 436;\n-   Name_Safe_Emax                      : constant Name_Id := N + 437; -- Ada 83\n-   Name_Safe_First                     : constant Name_Id := N + 438;\n-   Name_Safe_Large                     : constant Name_Id := N + 439; -- Ada 83\n-   Name_Safe_Last                      : constant Name_Id := N + 440;\n-   Name_Safe_Small                     : constant Name_Id := N + 441; -- Ada 83\n-   Name_Scale                          : constant Name_Id := N + 442;\n-   Name_Scaling                        : constant Name_Id := N + 443;\n-   Name_Signed_Zeros                   : constant Name_Id := N + 444;\n-   Name_Size                           : constant Name_Id := N + 445;\n-   Name_Small                          : constant Name_Id := N + 446;\n-   Name_Storage_Size                   : constant Name_Id := N + 447;\n-   Name_Storage_Unit                   : constant Name_Id := N + 448; -- GNAT\n-   Name_Stream_Size                    : constant Name_Id := N + 449; -- Ada 05\n-   Name_Tag                            : constant Name_Id := N + 450;\n-   Name_Target_Name                    : constant Name_Id := N + 451; -- GNAT\n-   Name_Terminated                     : constant Name_Id := N + 452;\n-   Name_To_Address                     : constant Name_Id := N + 453; -- GNAT\n-   Name_Type_Class                     : constant Name_Id := N + 454; -- GNAT\n-   Name_UET_Address                    : constant Name_Id := N + 455; -- GNAT\n-   Name_Unbiased_Rounding              : constant Name_Id := N + 456;\n-   Name_Unchecked_Access               : constant Name_Id := N + 457;\n-   Name_Unconstrained_Array            : constant Name_Id := N + 458;\n-   Name_Universal_Literal_String       : constant Name_Id := N + 459; -- GNAT\n-   Name_Unrestricted_Access            : constant Name_Id := N + 460; -- GNAT\n-   Name_VADS_Size                      : constant Name_Id := N + 461; -- GNAT\n-   Name_Val                            : constant Name_Id := N + 462;\n-   Name_Valid                          : constant Name_Id := N + 463;\n-   Name_Value_Size                     : constant Name_Id := N + 464; -- GNAT\n-   Name_Version                        : constant Name_Id := N + 465;\n-   Name_Wchar_T_Size                   : constant Name_Id := N + 466; -- GNAT\n-   Name_Wide_Wide_Width                : constant Name_Id := N + 467; -- Ada 05\n-   Name_Wide_Width                     : constant Name_Id := N + 468;\n-   Name_Width                          : constant Name_Id := N + 469;\n-   Name_Word_Size                      : constant Name_Id := N + 470; -- GNAT\n+   First_Attribute_Name                : constant Name_Id := N + 365;\n+   Name_Abort_Signal                   : constant Name_Id := N + 365; -- GNAT\n+   Name_Access                         : constant Name_Id := N + 366;\n+   Name_Address                        : constant Name_Id := N + 367;\n+   Name_Address_Size                   : constant Name_Id := N + 368; -- GNAT\n+   Name_Aft                            : constant Name_Id := N + 369;\n+   Name_Alignment                      : constant Name_Id := N + 370;\n+   Name_Asm_Input                      : constant Name_Id := N + 371; -- GNAT\n+   Name_Asm_Output                     : constant Name_Id := N + 372; -- GNAT\n+   Name_AST_Entry                      : constant Name_Id := N + 373; -- VMS\n+   Name_Bit                            : constant Name_Id := N + 374; -- GNAT\n+   Name_Bit_Order                      : constant Name_Id := N + 375;\n+   Name_Bit_Position                   : constant Name_Id := N + 376; -- GNAT\n+   Name_Body_Version                   : constant Name_Id := N + 377;\n+   Name_Callable                       : constant Name_Id := N + 378;\n+   Name_Caller                         : constant Name_Id := N + 379;\n+   Name_Code_Address                   : constant Name_Id := N + 380; -- GNAT\n+   Name_Component_Size                 : constant Name_Id := N + 381;\n+   Name_Compose                        : constant Name_Id := N + 382;\n+   Name_Constrained                    : constant Name_Id := N + 383;\n+   Name_Count                          : constant Name_Id := N + 384;\n+   Name_Default_Bit_Order              : constant Name_Id := N + 385; -- GNAT\n+   Name_Definite                       : constant Name_Id := N + 386;\n+   Name_Delta                          : constant Name_Id := N + 387;\n+   Name_Denorm                         : constant Name_Id := N + 388;\n+   Name_Digits                         : constant Name_Id := N + 389;\n+   Name_Elaborated                     : constant Name_Id := N + 390; -- GNAT\n+   Name_Emax                           : constant Name_Id := N + 391; -- Ada 83\n+   Name_Enabled                        : constant Name_Id := N + 392; -- GNAT\n+   Name_Enum_Rep                       : constant Name_Id := N + 393; -- GNAT\n+   Name_Epsilon                        : constant Name_Id := N + 394; -- Ada 83\n+   Name_Exponent                       : constant Name_Id := N + 395;\n+   Name_External_Tag                   : constant Name_Id := N + 396;\n+   Name_First                          : constant Name_Id := N + 397;\n+   Name_First_Bit                      : constant Name_Id := N + 398;\n+   Name_Fixed_Value                    : constant Name_Id := N + 399; -- GNAT\n+   Name_Fore                           : constant Name_Id := N + 400;\n+   Name_Has_Access_Values              : constant Name_Id := N + 401; -- GNAT\n+   Name_Has_Discriminants              : constant Name_Id := N + 402; -- GNAT\n+   Name_Identity                       : constant Name_Id := N + 403;\n+   Name_Img                            : constant Name_Id := N + 404; -- GNAT\n+   Name_Integer_Value                  : constant Name_Id := N + 405; -- GNAT\n+   Name_Large                          : constant Name_Id := N + 406; -- Ada 83\n+   Name_Last                           : constant Name_Id := N + 407;\n+   Name_Last_Bit                       : constant Name_Id := N + 408;\n+   Name_Leading_Part                   : constant Name_Id := N + 409;\n+   Name_Length                         : constant Name_Id := N + 410;\n+   Name_Machine_Emax                   : constant Name_Id := N + 411;\n+   Name_Machine_Emin                   : constant Name_Id := N + 412;\n+   Name_Machine_Mantissa               : constant Name_Id := N + 413;\n+   Name_Machine_Overflows              : constant Name_Id := N + 414;\n+   Name_Machine_Radix                  : constant Name_Id := N + 415;\n+   Name_Machine_Rounding               : constant Name_Id := N + 416; -- Ada 05\n+   Name_Machine_Rounds                 : constant Name_Id := N + 417;\n+   Name_Machine_Size                   : constant Name_Id := N + 418; -- GNAT\n+   Name_Mantissa                       : constant Name_Id := N + 419; -- Ada 83\n+   Name_Max_Size_In_Storage_Elements   : constant Name_Id := N + 420;\n+   Name_Maximum_Alignment              : constant Name_Id := N + 421; -- GNAT\n+   Name_Mechanism_Code                 : constant Name_Id := N + 422; -- GNAT\n+   Name_Mod                            : constant Name_Id := N + 423; -- Ada 05\n+   Name_Model_Emin                     : constant Name_Id := N + 424;\n+   Name_Model_Epsilon                  : constant Name_Id := N + 425;\n+   Name_Model_Mantissa                 : constant Name_Id := N + 426;\n+   Name_Model_Small                    : constant Name_Id := N + 427;\n+   Name_Modulus                        : constant Name_Id := N + 428;\n+   Name_Null_Parameter                 : constant Name_Id := N + 429; -- GNAT\n+   Name_Object_Size                    : constant Name_Id := N + 430; -- GNAT\n+   Name_Partition_ID                   : constant Name_Id := N + 431;\n+   Name_Passed_By_Reference            : constant Name_Id := N + 432; -- GNAT\n+   Name_Pool_Address                   : constant Name_Id := N + 433;\n+   Name_Pos                            : constant Name_Id := N + 434;\n+   Name_Position                       : constant Name_Id := N + 435;\n+   Name_Priority                       : constant Name_Id := N + 436; -- Ada 05\n+   Name_Range                          : constant Name_Id := N + 437;\n+   Name_Range_Length                   : constant Name_Id := N + 438; -- GNAT\n+   Name_Round                          : constant Name_Id := N + 439;\n+   Name_Safe_Emax                      : constant Name_Id := N + 440; -- Ada 83\n+   Name_Safe_First                     : constant Name_Id := N + 441;\n+   Name_Safe_Large                     : constant Name_Id := N + 442; -- Ada 83\n+   Name_Safe_Last                      : constant Name_Id := N + 443;\n+   Name_Safe_Small                     : constant Name_Id := N + 444; -- Ada 83\n+   Name_Scale                          : constant Name_Id := N + 445;\n+   Name_Scaling                        : constant Name_Id := N + 446;\n+   Name_Signed_Zeros                   : constant Name_Id := N + 447;\n+   Name_Size                           : constant Name_Id := N + 448;\n+   Name_Small                          : constant Name_Id := N + 449;\n+   Name_Storage_Size                   : constant Name_Id := N + 450;\n+   Name_Storage_Unit                   : constant Name_Id := N + 451; -- GNAT\n+   Name_Stream_Size                    : constant Name_Id := N + 452; -- Ada 05\n+   Name_Tag                            : constant Name_Id := N + 453;\n+   Name_Target_Name                    : constant Name_Id := N + 454; -- GNAT\n+   Name_Terminated                     : constant Name_Id := N + 455;\n+   Name_To_Address                     : constant Name_Id := N + 456; -- GNAT\n+   Name_Type_Class                     : constant Name_Id := N + 457; -- GNAT\n+   Name_UET_Address                    : constant Name_Id := N + 458; -- GNAT\n+   Name_Unbiased_Rounding              : constant Name_Id := N + 459;\n+   Name_Unchecked_Access               : constant Name_Id := N + 460;\n+   Name_Unconstrained_Array            : constant Name_Id := N + 461;\n+   Name_Universal_Literal_String       : constant Name_Id := N + 462; -- GNAT\n+   Name_Unrestricted_Access            : constant Name_Id := N + 463; -- GNAT\n+   Name_VADS_Size                      : constant Name_Id := N + 464; -- GNAT\n+   Name_Val                            : constant Name_Id := N + 465;\n+   Name_Valid                          : constant Name_Id := N + 466;\n+   Name_Value_Size                     : constant Name_Id := N + 467; -- GNAT\n+   Name_Version                        : constant Name_Id := N + 468;\n+   Name_Wchar_T_Size                   : constant Name_Id := N + 469; -- GNAT\n+   Name_Wide_Wide_Width                : constant Name_Id := N + 470; -- Ada 05\n+   Name_Wide_Width                     : constant Name_Id := N + 471;\n+   Name_Width                          : constant Name_Id := N + 472;\n+   Name_Word_Size                      : constant Name_Id := N + 473; -- GNAT\n \n    --  Attributes that designate attributes returning renamable functions,\n    --  i.e. functions that return other than a universal value and that\n    --  have non-universal arguments.\n \n-   First_Renamable_Function_Attribute  : constant Name_Id := N + 471;\n-   Name_Adjacent                       : constant Name_Id := N + 471;\n-   Name_Ceiling                        : constant Name_Id := N + 472;\n-   Name_Copy_Sign                      : constant Name_Id := N + 473;\n-   Name_Floor                          : constant Name_Id := N + 474;\n-   Name_Fraction                       : constant Name_Id := N + 475;\n-   Name_Image                          : constant Name_Id := N + 476;\n-   Name_Input                          : constant Name_Id := N + 477;\n-   Name_Machine                        : constant Name_Id := N + 478;\n-   Name_Max                            : constant Name_Id := N + 479;\n-   Name_Min                            : constant Name_Id := N + 480;\n-   Name_Model                          : constant Name_Id := N + 481;\n-   Name_Pred                           : constant Name_Id := N + 482;\n-   Name_Remainder                      : constant Name_Id := N + 483;\n-   Name_Rounding                       : constant Name_Id := N + 484;\n-   Name_Succ                           : constant Name_Id := N + 485;\n-   Name_Truncation                     : constant Name_Id := N + 486;\n-   Name_Value                          : constant Name_Id := N + 487;\n-   Name_Wide_Image                     : constant Name_Id := N + 488;\n-   Name_Wide_Wide_Image                : constant Name_Id := N + 489;\n-   Name_Wide_Value                     : constant Name_Id := N + 490;\n-   Name_Wide_Wide_Value                : constant Name_Id := N + 491;\n-   Last_Renamable_Function_Attribute   : constant Name_Id := N + 491;\n+   First_Renamable_Function_Attribute  : constant Name_Id := N + 474;\n+   Name_Adjacent                       : constant Name_Id := N + 474;\n+   Name_Ceiling                        : constant Name_Id := N + 475;\n+   Name_Copy_Sign                      : constant Name_Id := N + 476;\n+   Name_Floor                          : constant Name_Id := N + 477;\n+   Name_Fraction                       : constant Name_Id := N + 478;\n+   Name_Image                          : constant Name_Id := N + 479;\n+   Name_Input                          : constant Name_Id := N + 480;\n+   Name_Machine                        : constant Name_Id := N + 481;\n+   Name_Max                            : constant Name_Id := N + 482;\n+   Name_Min                            : constant Name_Id := N + 483;\n+   Name_Model                          : constant Name_Id := N + 484;\n+   Name_Pred                           : constant Name_Id := N + 485;\n+   Name_Remainder                      : constant Name_Id := N + 486;\n+   Name_Rounding                       : constant Name_Id := N + 487;\n+   Name_Succ                           : constant Name_Id := N + 488;\n+   Name_Truncation                     : constant Name_Id := N + 489;\n+   Name_Value                          : constant Name_Id := N + 490;\n+   Name_Wide_Image                     : constant Name_Id := N + 491;\n+   Name_Wide_Wide_Image                : constant Name_Id := N + 492;\n+   Name_Wide_Value                     : constant Name_Id := N + 493;\n+   Name_Wide_Wide_Value                : constant Name_Id := N + 494;\n+   Last_Renamable_Function_Attribute   : constant Name_Id := N + 494;\n \n    --  Attributes that designate procedures\n \n-   First_Procedure_Attribute           : constant Name_Id := N + 492;\n-   Name_Output                         : constant Name_Id := N + 492;\n-   Name_Read                           : constant Name_Id := N + 493;\n-   Name_Write                          : constant Name_Id := N + 494;\n-   Last_Procedure_Attribute            : constant Name_Id := N + 494;\n+   First_Procedure_Attribute           : constant Name_Id := N + 495;\n+   Name_Output                         : constant Name_Id := N + 495;\n+   Name_Read                           : constant Name_Id := N + 496;\n+   Name_Write                          : constant Name_Id := N + 497;\n+   Last_Procedure_Attribute            : constant Name_Id := N + 497;\n \n    --  Remaining attributes are ones that return entities\n \n-   First_Entity_Attribute_Name         : constant Name_Id := N + 495;\n-   Name_Elab_Body                      : constant Name_Id := N + 495; -- GNAT\n-   Name_Elab_Spec                      : constant Name_Id := N + 496; -- GNAT\n-   Name_Storage_Pool                   : constant Name_Id := N + 497;\n+   First_Entity_Attribute_Name         : constant Name_Id := N + 498;\n+   Name_Elab_Body                      : constant Name_Id := N + 498; -- GNAT\n+   Name_Elab_Spec                      : constant Name_Id := N + 499; -- GNAT\n+   Name_Storage_Pool                   : constant Name_Id := N + 500;\n \n    --  These attributes are the ones that return types\n \n-   First_Type_Attribute_Name           : constant Name_Id := N + 498;\n-   Name_Base                           : constant Name_Id := N + 498;\n-   Name_Class                          : constant Name_Id := N + 499;\n-   Name_Stub_Type                      : constant Name_Id := N + 500;\n-   Last_Type_Attribute_Name            : constant Name_Id := N + 500;\n-   Last_Entity_Attribute_Name          : constant Name_Id := N + 500;\n-   Last_Attribute_Name                 : constant Name_Id := N + 500;\n+   First_Type_Attribute_Name           : constant Name_Id := N + 501;\n+   Name_Base                           : constant Name_Id := N + 501;\n+   Name_Class                          : constant Name_Id := N + 502;\n+   Name_Stub_Type                      : constant Name_Id := N + 503;\n+   Last_Type_Attribute_Name            : constant Name_Id := N + 503;\n+   Last_Entity_Attribute_Name          : constant Name_Id := N + 503;\n+   Last_Attribute_Name                 : constant Name_Id := N + 503;\n \n    --  Names of recognized locking policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. C for Ceiling_Locking). If new policy names are added,\n    --  the first character must be distinct.\n \n-   First_Locking_Policy_Name           : constant Name_Id := N + 501;\n-   Name_Ceiling_Locking                : constant Name_Id := N + 501;\n-   Name_Inheritance_Locking            : constant Name_Id := N + 502;\n-   Last_Locking_Policy_Name            : constant Name_Id := N + 502;\n+   First_Locking_Policy_Name           : constant Name_Id := N + 504;\n+   Name_Ceiling_Locking                : constant Name_Id := N + 504;\n+   Name_Inheritance_Locking            : constant Name_Id := N + 505;\n+   Last_Locking_Policy_Name            : constant Name_Id := N + 505;\n \n    --  Names of recognized queuing policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. F for FIFO_Queuing). If new policy names are added,\n    --  the first character must be distinct.\n \n-   First_Queuing_Policy_Name           : constant Name_Id := N + 503;\n-   Name_FIFO_Queuing                   : constant Name_Id := N + 503;\n-   Name_Priority_Queuing               : constant Name_Id := N + 504;\n-   Last_Queuing_Policy_Name            : constant Name_Id := N + 504;\n+   First_Queuing_Policy_Name           : constant Name_Id := N + 506;\n+   Name_FIFO_Queuing                   : constant Name_Id := N + 506;\n+   Name_Priority_Queuing               : constant Name_Id := N + 507;\n+   Last_Queuing_Policy_Name            : constant Name_Id := N + 507;\n \n    --  Names of recognized task dispatching policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. F for FIFO_Within_Priorities). If new policy names\n    --  are added, the first character must be distinct.\n \n-   First_Task_Dispatching_Policy_Name  : constant Name_Id := N + 505;\n-   Name_EDF_Across_Priorities          : constant Name_Id := N + 505;\n-   Name_FIFO_Within_Priorities         : constant Name_Id := N + 506;\n-   Name_Non_Preemptive_Within_Priorities : constant Name_Id := N + 507;\n-   Name_Round_Robin_Within_Priorities  : constant Name_Id := N + 508;\n-   Last_Task_Dispatching_Policy_Name   : constant Name_Id := N + 508;\n+   First_Task_Dispatching_Policy_Name  : constant Name_Id := N + 508;\n+   Name_EDF_Across_Priorities          : constant Name_Id := N + 508;\n+   Name_FIFO_Within_Priorities         : constant Name_Id := N + 509;\n+   Name_Non_Preemptive_Within_Priorities : constant Name_Id := N + 510;\n+   Name_Round_Robin_Within_Priorities  : constant Name_Id := N + 511;\n+   Last_Task_Dispatching_Policy_Name   : constant Name_Id := N + 511;\n \n    --  Names of recognized checks for pragma Suppress\n \n-   First_Check_Name                    : constant Name_Id := N + 509;\n-   Name_Access_Check                   : constant Name_Id := N + 509;\n-   Name_Accessibility_Check            : constant Name_Id := N + 510;\n-   Name_Alignment_Check                : constant Name_Id := N + 511;\n-   Name_Discriminant_Check             : constant Name_Id := N + 512;\n-   Name_Division_Check                 : constant Name_Id := N + 513;\n-   Name_Elaboration_Check              : constant Name_Id := N + 514;\n-   Name_Index_Check                    : constant Name_Id := N + 515;\n-   Name_Length_Check                   : constant Name_Id := N + 516;\n-   Name_Overflow_Check                 : constant Name_Id := N + 517;\n-   Name_Range_Check                    : constant Name_Id := N + 518;\n-   Name_Storage_Check                  : constant Name_Id := N + 519;\n-   Name_Tag_Check                      : constant Name_Id := N + 520;\n-   Name_Validity_Check                 : constant Name_Id := N + 521;\n-   Name_All_Checks                     : constant Name_Id := N + 522;\n-   Last_Check_Name                     : constant Name_Id := N + 522;\n+   First_Check_Name                    : constant Name_Id := N + 512;\n+   Name_Access_Check                   : constant Name_Id := N + 512;\n+   Name_Accessibility_Check            : constant Name_Id := N + 513;\n+   Name_Alignment_Check                : constant Name_Id := N + 514; -- GNAT\n+   Name_Discriminant_Check             : constant Name_Id := N + 515;\n+   Name_Division_Check                 : constant Name_Id := N + 516;\n+   Name_Elaboration_Check              : constant Name_Id := N + 517;\n+   Name_Index_Check                    : constant Name_Id := N + 518;\n+   Name_Length_Check                   : constant Name_Id := N + 519;\n+   Name_Overflow_Check                 : constant Name_Id := N + 520;\n+   Name_Range_Check                    : constant Name_Id := N + 521;\n+   Name_Storage_Check                  : constant Name_Id := N + 522;\n+   Name_Tag_Check                      : constant Name_Id := N + 523;\n+   Name_Validity_Check                 : constant Name_Id := N + 524; -- GNAT\n+   Name_All_Checks                     : constant Name_Id := N + 525;\n+   Last_Check_Name                     : constant Name_Id := N + 525;\n \n    --  Names corresponding to reserved keywords, excluding those already\n    --  declared in the attribute list (Access, Delta, Digits, Mod, Range).\n \n-   Name_Abort                          : constant Name_Id := N + 523;\n-   Name_Abs                            : constant Name_Id := N + 524;\n-   Name_Accept                         : constant Name_Id := N + 525;\n-   Name_And                            : constant Name_Id := N + 526;\n-   Name_All                            : constant Name_Id := N + 527;\n-   Name_Array                          : constant Name_Id := N + 528;\n-   Name_At                             : constant Name_Id := N + 529;\n-   Name_Begin                          : constant Name_Id := N + 530;\n-   Name_Body                           : constant Name_Id := N + 531;\n-   Name_Case                           : constant Name_Id := N + 532;\n-   Name_Constant                       : constant Name_Id := N + 533;\n-   Name_Declare                        : constant Name_Id := N + 534;\n-   Name_Delay                          : constant Name_Id := N + 535;\n-   Name_Do                             : constant Name_Id := N + 536;\n-   Name_Else                           : constant Name_Id := N + 537;\n-   Name_Elsif                          : constant Name_Id := N + 538;\n-   Name_End                            : constant Name_Id := N + 539;\n-   Name_Entry                          : constant Name_Id := N + 540;\n-   Name_Exception                      : constant Name_Id := N + 541;\n-   Name_Exit                           : constant Name_Id := N + 542;\n-   Name_For                            : constant Name_Id := N + 543;\n-   Name_Function                       : constant Name_Id := N + 544;\n-   Name_Generic                        : constant Name_Id := N + 545;\n-   Name_Goto                           : constant Name_Id := N + 546;\n-   Name_If                             : constant Name_Id := N + 547;\n-   Name_In                             : constant Name_Id := N + 548;\n-   Name_Is                             : constant Name_Id := N + 549;\n-   Name_Limited                        : constant Name_Id := N + 550;\n-   Name_Loop                           : constant Name_Id := N + 551;\n-   Name_New                            : constant Name_Id := N + 552;\n-   Name_Not                            : constant Name_Id := N + 553;\n-   Name_Null                           : constant Name_Id := N + 554;\n-   Name_Of                             : constant Name_Id := N + 555;\n-   Name_Or                             : constant Name_Id := N + 556;\n-   Name_Others                         : constant Name_Id := N + 557;\n-   Name_Out                            : constant Name_Id := N + 558;\n-   Name_Package                        : constant Name_Id := N + 559;\n-   Name_Pragma                         : constant Name_Id := N + 560;\n-   Name_Private                        : constant Name_Id := N + 561;\n-   Name_Procedure                      : constant Name_Id := N + 562;\n-   Name_Raise                          : constant Name_Id := N + 563;\n-   Name_Record                         : constant Name_Id := N + 564;\n-   Name_Rem                            : constant Name_Id := N + 565;\n-   Name_Renames                        : constant Name_Id := N + 566;\n-   Name_Return                         : constant Name_Id := N + 567;\n-   Name_Reverse                        : constant Name_Id := N + 568;\n-   Name_Select                         : constant Name_Id := N + 569;\n-   Name_Separate                       : constant Name_Id := N + 570;\n-   Name_Subtype                        : constant Name_Id := N + 571;\n-   Name_Task                           : constant Name_Id := N + 572;\n-   Name_Terminate                      : constant Name_Id := N + 573;\n-   Name_Then                           : constant Name_Id := N + 574;\n-   Name_Type                           : constant Name_Id := N + 575;\n-   Name_Use                            : constant Name_Id := N + 576;\n-   Name_When                           : constant Name_Id := N + 577;\n-   Name_While                          : constant Name_Id := N + 578;\n-   Name_With                           : constant Name_Id := N + 579;\n-   Name_Xor                            : constant Name_Id := N + 580;\n+   Name_Abort                          : constant Name_Id := N + 526;\n+   Name_Abs                            : constant Name_Id := N + 527;\n+   Name_Accept                         : constant Name_Id := N + 528;\n+   Name_And                            : constant Name_Id := N + 529;\n+   Name_All                            : constant Name_Id := N + 530;\n+   Name_Array                          : constant Name_Id := N + 531;\n+   Name_At                             : constant Name_Id := N + 532;\n+   Name_Begin                          : constant Name_Id := N + 533;\n+   Name_Body                           : constant Name_Id := N + 534;\n+   Name_Case                           : constant Name_Id := N + 535;\n+   Name_Constant                       : constant Name_Id := N + 536;\n+   Name_Declare                        : constant Name_Id := N + 537;\n+   Name_Delay                          : constant Name_Id := N + 538;\n+   Name_Do                             : constant Name_Id := N + 539;\n+   Name_Else                           : constant Name_Id := N + 540;\n+   Name_Elsif                          : constant Name_Id := N + 541;\n+   Name_End                            : constant Name_Id := N + 542;\n+   Name_Entry                          : constant Name_Id := N + 543;\n+   Name_Exception                      : constant Name_Id := N + 544;\n+   Name_Exit                           : constant Name_Id := N + 545;\n+   Name_For                            : constant Name_Id := N + 546;\n+   Name_Function                       : constant Name_Id := N + 547;\n+   Name_Generic                        : constant Name_Id := N + 548;\n+   Name_Goto                           : constant Name_Id := N + 549;\n+   Name_If                             : constant Name_Id := N + 550;\n+   Name_In                             : constant Name_Id := N + 551;\n+   Name_Is                             : constant Name_Id := N + 552;\n+   Name_Limited                        : constant Name_Id := N + 553;\n+   Name_Loop                           : constant Name_Id := N + 554;\n+   Name_New                            : constant Name_Id := N + 555;\n+   Name_Not                            : constant Name_Id := N + 556;\n+   Name_Null                           : constant Name_Id := N + 557;\n+   Name_Of                             : constant Name_Id := N + 558;\n+   Name_Or                             : constant Name_Id := N + 559;\n+   Name_Others                         : constant Name_Id := N + 560;\n+   Name_Out                            : constant Name_Id := N + 561;\n+   Name_Package                        : constant Name_Id := N + 562;\n+   Name_Pragma                         : constant Name_Id := N + 563;\n+   Name_Private                        : constant Name_Id := N + 564;\n+   Name_Procedure                      : constant Name_Id := N + 565;\n+   Name_Raise                          : constant Name_Id := N + 566;\n+   Name_Record                         : constant Name_Id := N + 567;\n+   Name_Rem                            : constant Name_Id := N + 568;\n+   Name_Renames                        : constant Name_Id := N + 569;\n+   Name_Return                         : constant Name_Id := N + 570;\n+   Name_Reverse                        : constant Name_Id := N + 571;\n+   Name_Select                         : constant Name_Id := N + 572;\n+   Name_Separate                       : constant Name_Id := N + 573;\n+   Name_Subtype                        : constant Name_Id := N + 574;\n+   Name_Task                           : constant Name_Id := N + 575;\n+   Name_Terminate                      : constant Name_Id := N + 576;\n+   Name_Then                           : constant Name_Id := N + 577;\n+   Name_Type                           : constant Name_Id := N + 578;\n+   Name_Use                            : constant Name_Id := N + 579;\n+   Name_When                           : constant Name_Id := N + 580;\n+   Name_While                          : constant Name_Id := N + 581;\n+   Name_With                           : constant Name_Id := N + 582;\n+   Name_Xor                            : constant Name_Id := N + 583;\n \n    --  Names of intrinsic subprograms\n \n    --  Note: Asm is missing from this list, since Asm is a legitimate\n    --  convention name. So is To_Adress, which is a GNAT attribute.\n \n-   First_Intrinsic_Name                 : constant Name_Id := N + 581;\n-   Name_Divide                          : constant Name_Id := N + 581;\n-   Name_Enclosing_Entity                : constant Name_Id := N + 582;\n-   Name_Exception_Information           : constant Name_Id := N + 583;\n-   Name_Exception_Message               : constant Name_Id := N + 584;\n-   Name_Exception_Name                  : constant Name_Id := N + 585;\n-   Name_File                            : constant Name_Id := N + 586;\n-   Name_Generic_Dispatching_Constructor : constant Name_Id := N + 587;\n-   Name_Import_Address                  : constant Name_Id := N + 588;\n-   Name_Import_Largest_Value            : constant Name_Id := N + 589;\n-   Name_Import_Value                    : constant Name_Id := N + 590;\n-   Name_Is_Negative                     : constant Name_Id := N + 591;\n-   Name_Line                            : constant Name_Id := N + 592;\n-   Name_Rotate_Left                     : constant Name_Id := N + 593;\n-   Name_Rotate_Right                    : constant Name_Id := N + 594;\n-   Name_Shift_Left                      : constant Name_Id := N + 595;\n-   Name_Shift_Right                     : constant Name_Id := N + 596;\n-   Name_Shift_Right_Arithmetic          : constant Name_Id := N + 597;\n-   Name_Source_Location                 : constant Name_Id := N + 598;\n-   Name_Unchecked_Conversion            : constant Name_Id := N + 599;\n-   Name_Unchecked_Deallocation          : constant Name_Id := N + 600;\n-   Name_To_Pointer                      : constant Name_Id := N + 601;\n-   Last_Intrinsic_Name                  : constant Name_Id := N + 601;\n+   First_Intrinsic_Name                 : constant Name_Id := N + 584;\n+   Name_Divide                          : constant Name_Id := N + 584;\n+   Name_Enclosing_Entity                : constant Name_Id := N + 585;\n+   Name_Exception_Information           : constant Name_Id := N + 586;\n+   Name_Exception_Message               : constant Name_Id := N + 587;\n+   Name_Exception_Name                  : constant Name_Id := N + 588;\n+   Name_File                            : constant Name_Id := N + 589;\n+   Name_Generic_Dispatching_Constructor : constant Name_Id := N + 590;\n+   Name_Import_Address                  : constant Name_Id := N + 591;\n+   Name_Import_Largest_Value            : constant Name_Id := N + 592;\n+   Name_Import_Value                    : constant Name_Id := N + 593;\n+   Name_Is_Negative                     : constant Name_Id := N + 594;\n+   Name_Line                            : constant Name_Id := N + 595;\n+   Name_Rotate_Left                     : constant Name_Id := N + 596;\n+   Name_Rotate_Right                    : constant Name_Id := N + 597;\n+   Name_Shift_Left                      : constant Name_Id := N + 598;\n+   Name_Shift_Right                     : constant Name_Id := N + 599;\n+   Name_Shift_Right_Arithmetic          : constant Name_Id := N + 600;\n+   Name_Source_Location                 : constant Name_Id := N + 601;\n+   Name_Unchecked_Conversion            : constant Name_Id := N + 602;\n+   Name_Unchecked_Deallocation          : constant Name_Id := N + 603;\n+   Name_To_Pointer                      : constant Name_Id := N + 604;\n+   Last_Intrinsic_Name                  : constant Name_Id := N + 604;\n \n    --  Names used in processing intrinsic calls\n \n-   Name_Free                           : constant Name_Id := N + 602;\n+   Name_Free                           : constant Name_Id := N + 605;\n \n    --  Reserved words used only in Ada 95\n \n-   First_95_Reserved_Word              : constant Name_Id := N + 603;\n-   Name_Abstract                       : constant Name_Id := N + 603;\n-   Name_Aliased                        : constant Name_Id := N + 604;\n-   Name_Protected                      : constant Name_Id := N + 605;\n-   Name_Until                          : constant Name_Id := N + 606;\n-   Name_Requeue                        : constant Name_Id := N + 607;\n-   Name_Tagged                         : constant Name_Id := N + 608;\n-   Last_95_Reserved_Word               : constant Name_Id := N + 608;\n+   First_95_Reserved_Word              : constant Name_Id := N + 606;\n+   Name_Abstract                       : constant Name_Id := N + 606;\n+   Name_Aliased                        : constant Name_Id := N + 607;\n+   Name_Protected                      : constant Name_Id := N + 608;\n+   Name_Until                          : constant Name_Id := N + 609;\n+   Name_Requeue                        : constant Name_Id := N + 610;\n+   Name_Tagged                         : constant Name_Id := N + 611;\n+   Last_95_Reserved_Word               : constant Name_Id := N + 611;\n \n    subtype Ada_95_Reserved_Words is\n      Name_Id range First_95_Reserved_Word .. Last_95_Reserved_Word;\n \n    --  Miscellaneous names used in semantic checking\n \n-   Name_Raise_Exception                : constant Name_Id := N + 609;\n+   Name_Raise_Exception                : constant Name_Id := N + 612;\n \n    --  Additional reserved words and identifiers used in GNAT Project Files\n    --  Note that Name_External is already previously declared\n \n-   Name_Ada_Roots                      : constant Name_Id := N + 610;\n-   Name_Archive_Builder                : constant Name_Id := N + 611;\n-   Name_Archive_Indexer                : constant Name_Id := N + 612;\n-   Name_Archive_Suffix                 : constant Name_Id := N + 613;\n-   Name_Binder                         : constant Name_Id := N + 614;\n-   Name_Binder_Driver                  : constant Name_Id := N + 615;\n-   Name_Binder_Prefix                  : constant Name_Id := N + 616;\n-   Name_Body_Suffix                    : constant Name_Id := N + 617;\n-   Name_Builder                        : constant Name_Id := N + 618;\n-   Name_Builder_Switches               : constant Name_Id := N + 619;\n-   Name_Compiler                       : constant Name_Id := N + 620;\n-   Name_Compiler_Driver                : constant Name_Id := N + 621;\n-   Name_Compiler_Kind                  : constant Name_Id := N + 622;\n-   Name_Compiler_Pic_Option            : constant Name_Id := N + 623;\n-   Name_Compute_Dependency             : constant Name_Id := N + 624;\n-   Name_Config_Body_File_Name          : constant Name_Id := N + 625;\n-   Name_Config_Body_File_Name_Pattern  : constant Name_Id := N + 626;\n-   Name_Config_File_Switches           : constant Name_Id := N + 627;\n-   Name_Config_File_Unique             : constant Name_Id := N + 628;\n-   Name_Config_Spec_File_Name          : constant Name_Id := N + 629;\n-   Name_Config_Spec_File_Name_Pattern  : constant Name_Id := N + 630;\n-   Name_Cross_Reference                : constant Name_Id := N + 631;\n-   Name_Default_Builder_Switches       : constant Name_Id := N + 632;\n-   Name_Default_Global_Compiler_Switches : constant Name_Id := N + 633;\n-   Name_Default_Language               : constant Name_Id := N + 634;\n-   Name_Default_Linker                 : constant Name_Id := N + 635;\n-   Name_Default_Minimum_Linker_Options : constant Name_Id := N + 636;\n-   Name_Default_Switches               : constant Name_Id := N + 637;\n-   Name_Dependency_File_Kind           : constant Name_Id := N + 638;\n-   Name_Dependency_Option              : constant Name_Id := N + 639;\n-   Name_Exec_Dir                       : constant Name_Id := N + 640;\n-   Name_Executable                     : constant Name_Id := N + 641;\n-   Name_Executable_Suffix              : constant Name_Id := N + 642;\n-   Name_Extends                        : constant Name_Id := N + 643;\n-   Name_Externally_Built               : constant Name_Id := N + 644;\n-   Name_Finder                         : constant Name_Id := N + 645;\n-   Name_Global_Compiler_Switches       : constant Name_Id := N + 646;\n-   Name_Global_Configuration_Pragmas   : constant Name_Id := N + 647;\n-   Name_Global_Config_File             : constant Name_Id := N + 648;\n-   Name_Gnatls                         : constant Name_Id := N + 649;\n-   Name_Gnatstub                       : constant Name_Id := N + 650;\n-   Name_Implementation                 : constant Name_Id := N + 651;\n-   Name_Implementation_Exceptions      : constant Name_Id := N + 652;\n-   Name_Implementation_Suffix          : constant Name_Id := N + 653;\n-   Name_Include_Option                 : constant Name_Id := N + 654;\n-   Name_Include_Path                   : constant Name_Id := N + 655;\n-   Name_Include_Path_File              : constant Name_Id := N + 656;\n-   Name_Language_Kind                  : constant Name_Id := N + 657;\n-   Name_Language_Processing            : constant Name_Id := N + 658;\n-   Name_Languages                      : constant Name_Id := N + 659;\n-   Name_Library_Ali_Dir                : constant Name_Id := N + 660;\n-   Name_Library_Auto_Init              : constant Name_Id := N + 661;\n-   Name_Library_Auto_Init_Supported    : constant Name_Id := N + 662;\n-   Name_Library_Builder                : constant Name_Id := N + 663;\n-   Name_Library_Dir                    : constant Name_Id := N + 664;\n-   Name_Library_GCC                    : constant Name_Id := N + 665;\n-   Name_Library_Interface              : constant Name_Id := N + 666;\n-   Name_Library_Kind                   : constant Name_Id := N + 667;\n-   Name_Library_Name                   : constant Name_Id := N + 668;\n-   Name_Library_Major_Minor_Id_Supported : constant Name_Id := N + 669;\n-   Name_Library_Options                : constant Name_Id := N + 670;\n-   Name_Library_Partial_Linker         : constant Name_Id := N + 671;\n-   Name_Library_Reference_Symbol_File  : constant Name_Id := N + 672;\n-   Name_Library_Src_Dir                : constant Name_Id := N + 673;\n-   Name_Library_Support                : constant Name_Id := N + 674;\n-   Name_Library_Symbol_File            : constant Name_Id := N + 675;\n-   Name_Library_Symbol_Policy          : constant Name_Id := N + 676;\n-   Name_Library_Version                : constant Name_Id := N + 677;\n-   Name_Library_Version_Options        : constant Name_Id := N + 678;\n-   Name_Linker                         : constant Name_Id := N + 679;\n-   Name_Linker_Executable_Option       : constant Name_Id := N + 680;\n-   Name_Linker_Lib_Dir_Option          : constant Name_Id := N + 681;\n-   Name_Linker_Lib_Name_Option         : constant Name_Id := N + 682;\n-   Name_Local_Config_File              : constant Name_Id := N + 683;\n-   Name_Local_Configuration_Pragmas    : constant Name_Id := N + 684;\n-   Name_Locally_Removed_Files          : constant Name_Id := N + 685;\n-   Name_Mapping_File_Switches          : constant Name_Id := N + 686;\n-   Name_Mapping_Spec_Suffix            : constant Name_Id := N + 687;\n-   Name_Mapping_Body_Suffix            : constant Name_Id := N + 688;\n-   Name_Metrics                        : constant Name_Id := N + 689;\n-   Name_Minimum_Binder_Options         : constant Name_Id := N + 690;\n-   Name_Minimum_Compiler_Options       : constant Name_Id := N + 691;\n-   Name_Minimum_Linker_Options         : constant Name_Id := N + 692;\n-   Name_Naming                         : constant Name_Id := N + 693;\n-   Name_Objects_Path                   : constant Name_Id := N + 694;\n-   Name_Objects_Path_File              : constant Name_Id := N + 695;\n-   Name_Object_Dir                     : constant Name_Id := N + 696;\n-   Name_Pretty_Printer                 : constant Name_Id := N + 697;\n-   Name_Project                        : constant Name_Id := N + 698;\n-   Name_Roots                          : constant Name_Id := N + 699;\n-   Name_Run_Path_Option                : constant Name_Id := N + 700;\n-   Name_Runtime_Project                : constant Name_Id := N + 701;\n-   Name_Shared_Library_Minimum_Options : constant Name_Id := N + 702;\n-   Name_Shared_Library_Prefix          : constant Name_Id := N + 703;\n-   Name_Shared_Library_Suffix          : constant Name_Id := N + 704;\n-   Name_Separate_Suffix                : constant Name_Id := N + 705;\n-   Name_Source_Dirs                    : constant Name_Id := N + 706;\n-   Name_Source_Files                   : constant Name_Id := N + 707;\n-   Name_Source_List_File               : constant Name_Id := N + 708;\n-   Name_Spec                           : constant Name_Id := N + 709;\n-   Name_Spec_Suffix                    : constant Name_Id := N + 710;\n-   Name_Specification                  : constant Name_Id := N + 711;\n-   Name_Specification_Exceptions       : constant Name_Id := N + 712;\n-   Name_Specification_Suffix           : constant Name_Id := N + 713;\n-   Name_Stack                          : constant Name_Id := N + 714;\n-   Name_Switches                       : constant Name_Id := N + 715;\n-   Name_Symbolic_Link_Supported        : constant Name_Id := N + 716;\n-   Name_Toolchain_Description          : constant Name_Id := N + 717;\n-   Name_Toolchain_Version              : constant Name_Id := N + 718;\n+   Name_Ada_Roots                      : constant Name_Id := N + 613;\n+   Name_Archive_Builder                : constant Name_Id := N + 614;\n+   Name_Archive_Indexer                : constant Name_Id := N + 615;\n+   Name_Archive_Suffix                 : constant Name_Id := N + 616;\n+   Name_Binder                         : constant Name_Id := N + 617;\n+   Name_Binder_Prefix                  : constant Name_Id := N + 618;\n+   Name_Body_Suffix                    : constant Name_Id := N + 619;\n+   Name_Builder                        : constant Name_Id := N + 620;\n+   Name_Builder_Switches               : constant Name_Id := N + 621;\n+   Name_Compiler                       : constant Name_Id := N + 622;\n+   Name_Compiler_Kind                  : constant Name_Id := N + 623;\n+   Name_Config_Body_File_Name          : constant Name_Id := N + 624;\n+   Name_Config_Body_File_Name_Pattern  : constant Name_Id := N + 625;\n+   Name_Config_File_Switches           : constant Name_Id := N + 626;\n+   Name_Config_File_Unique             : constant Name_Id := N + 627;\n+   Name_Config_Spec_File_Name          : constant Name_Id := N + 628;\n+   Name_Config_Spec_File_Name_Pattern  : constant Name_Id := N + 629;\n+   Name_Cross_Reference                : constant Name_Id := N + 630;\n+   Name_Default_Language               : constant Name_Id := N + 631;\n+   Name_Default_Switches               : constant Name_Id := N + 632;\n+   Name_Dependency_Driver              : constant Name_Id := N + 633;\n+   Name_Dependency_File_Kind           : constant Name_Id := N + 634;\n+   Name_Dependency_Switches            : constant Name_Id := N + 635;\n+   Name_Driver                         : constant Name_Id := N + 636;\n+   Name_Exec_Dir                       : constant Name_Id := N + 637;\n+   Name_Executable                     : constant Name_Id := N + 638;\n+   Name_Executable_Suffix              : constant Name_Id := N + 639;\n+   Name_Extends                        : constant Name_Id := N + 640;\n+   Name_Externally_Built               : constant Name_Id := N + 641;\n+   Name_Finder                         : constant Name_Id := N + 642;\n+   Name_Global_Configuration_Pragmas   : constant Name_Id := N + 643;\n+   Name_Global_Config_File             : constant Name_Id := N + 644;\n+   Name_Gnatls                         : constant Name_Id := N + 645;\n+   Name_Gnatstub                       : constant Name_Id := N + 646;\n+   Name_Implementation                 : constant Name_Id := N + 647;\n+   Name_Implementation_Exceptions      : constant Name_Id := N + 648;\n+   Name_Implementation_Suffix          : constant Name_Id := N + 649;\n+   Name_Include_Option                 : constant Name_Id := N + 650;\n+   Name_Include_Path                   : constant Name_Id := N + 651;\n+   Name_Include_Path_File              : constant Name_Id := N + 652;\n+   Name_Language_Kind                  : constant Name_Id := N + 653;\n+   Name_Language_Processing            : constant Name_Id := N + 654;\n+   Name_Languages                      : constant Name_Id := N + 655;\n+   Name_Library_Ali_Dir                : constant Name_Id := N + 656;\n+   Name_Library_Auto_Init              : constant Name_Id := N + 657;\n+   Name_Library_Auto_Init_Supported    : constant Name_Id := N + 658;\n+   Name_Library_Builder                : constant Name_Id := N + 659;\n+   Name_Library_Dir                    : constant Name_Id := N + 660;\n+   Name_Library_GCC                    : constant Name_Id := N + 661;\n+   Name_Library_Interface              : constant Name_Id := N + 662;\n+   Name_Library_Kind                   : constant Name_Id := N + 663;\n+   Name_Library_Name                   : constant Name_Id := N + 664;\n+   Name_Library_Major_Minor_Id_Supported : constant Name_Id := N + 665;\n+   Name_Library_Options                : constant Name_Id := N + 666;\n+   Name_Library_Partial_Linker         : constant Name_Id := N + 667;\n+   Name_Library_Reference_Symbol_File  : constant Name_Id := N + 668;\n+   Name_Library_Src_Dir                : constant Name_Id := N + 669;\n+   Name_Library_Support                : constant Name_Id := N + 670;\n+   Name_Library_Symbol_File            : constant Name_Id := N + 671;\n+   Name_Library_Symbol_Policy          : constant Name_Id := N + 672;\n+   Name_Library_Version                : constant Name_Id := N + 673;\n+   Name_Library_Version_Switches       : constant Name_Id := N + 674;\n+   Name_Linker                         : constant Name_Id := N + 675;\n+   Name_Linker_Executable_Option       : constant Name_Id := N + 676;\n+   Name_Linker_Lib_Dir_Option          : constant Name_Id := N + 677;\n+   Name_Linker_Lib_Name_Option         : constant Name_Id := N + 678;\n+   Name_Local_Config_File              : constant Name_Id := N + 679;\n+   Name_Local_Configuration_Pragmas    : constant Name_Id := N + 680;\n+   Name_Locally_Removed_Files          : constant Name_Id := N + 681;\n+   Name_Mapping_File_Switches          : constant Name_Id := N + 682;\n+   Name_Mapping_Spec_Suffix            : constant Name_Id := N + 683;\n+   Name_Mapping_Body_Suffix            : constant Name_Id := N + 684;\n+   Name_Metrics                        : constant Name_Id := N + 685;\n+   Name_Naming                         : constant Name_Id := N + 686;\n+   Name_Objects_Path                   : constant Name_Id := N + 687;\n+   Name_Objects_Path_File              : constant Name_Id := N + 688;\n+   Name_Object_Dir                     : constant Name_Id := N + 689;\n+   Name_Pic_Option                     : constant Name_Id := N + 690;\n+   Name_Pretty_Printer                 : constant Name_Id := N + 691;\n+   Name_Prefix                         : constant Name_Id := N + 692;\n+   Name_Project                        : constant Name_Id := N + 693;\n+   Name_Roots                          : constant Name_Id := N + 694;\n+   Name_Required_Switches              : constant Name_Id := N + 695;\n+   Name_Run_Path_Option                : constant Name_Id := N + 696;\n+   Name_Runtime_Project                : constant Name_Id := N + 697;\n+   Name_Shared_Library_Minimum_Switches : constant Name_Id := N + 698;\n+   Name_Shared_Library_Prefix          : constant Name_Id := N + 699;\n+   Name_Shared_Library_Suffix          : constant Name_Id := N + 700;\n+   Name_Separate_Suffix                : constant Name_Id := N + 701;\n+   Name_Source_Dirs                    : constant Name_Id := N + 702;\n+   Name_Source_Files                   : constant Name_Id := N + 703;\n+   Name_Source_List_File               : constant Name_Id := N + 704;\n+   Name_Spec                           : constant Name_Id := N + 705;\n+   Name_Spec_Suffix                    : constant Name_Id := N + 706;\n+   Name_Specification                  : constant Name_Id := N + 707;\n+   Name_Specification_Exceptions       : constant Name_Id := N + 708;\n+   Name_Specification_Suffix           : constant Name_Id := N + 709;\n+   Name_Stack                          : constant Name_Id := N + 710;\n+   Name_Switches                       : constant Name_Id := N + 711;\n+   Name_Symbolic_Link_Supported        : constant Name_Id := N + 712;\n+   Name_Toolchain_Description          : constant Name_Id := N + 713;\n+   Name_Toolchain_Version              : constant Name_Id := N + 714;\n \n    --  Other miscellaneous names used in front end\n \n-   Name_Unaligned_Valid                : constant Name_Id := N + 719;\n+   Name_Unaligned_Valid                : constant Name_Id := N + 715;\n \n    --  Ada 2005 reserved words\n \n-   First_2005_Reserved_Word            : constant Name_Id := N + 720;\n-   Name_Interface                      : constant Name_Id := N + 720;\n-   Name_Overriding                     : constant Name_Id := N + 721;\n-   Name_Synchronized                   : constant Name_Id := N + 722;\n-   Last_2005_Reserved_Word             : constant Name_Id := N + 722;\n+   First_2005_Reserved_Word            : constant Name_Id := N + 716;\n+   Name_Interface                      : constant Name_Id := N + 716;\n+   Name_Overriding                     : constant Name_Id := N + 717;\n+   Name_Synchronized                   : constant Name_Id := N + 718;\n+   Last_2005_Reserved_Word             : constant Name_Id := N + 718;\n \n    subtype Ada_2005_Reserved_Words is\n      Name_Id range First_2005_Reserved_Word .. Last_2005_Reserved_Word;\n \n    --  Mark last defined name for consistency check in Snames body\n \n-   Last_Predefined_Name                : constant Name_Id := N + 722;\n+   Last_Predefined_Name                : constant Name_Id := N + 718;\n \n    ---------------------------------------\n    -- Subtypes Defining Name Categories --\n@@ -1156,6 +1151,7 @@ package Snames is\n       Attribute_Digits,\n       Attribute_Elaborated,\n       Attribute_Emax,\n+      Attribute_Enabled,\n       Attribute_Enum_Rep,\n       Attribute_Epsilon,\n       Attribute_Exponent,\n@@ -1338,6 +1334,7 @@ package Snames is\n       Pragma_Ada_2005,\n       Pragma_Assertion_Policy,\n       Pragma_C_Pass_By_Copy,\n+      Pragma_Check_Name,\n       Pragma_Compile_Time_Error,\n       Pragma_Compile_Time_Warning,\n       Pragma_Component_Alignment,\n@@ -1351,6 +1348,7 @@ package Snames is\n       Pragma_Extensions_Allowed,\n       Pragma_External_Name_Casing,\n       Pragma_Float_Representation,\n+      Pragma_Implicit_Packing,\n       Pragma_Initialize_Scalars,\n       Pragma_Interrupt_State,\n       Pragma_License,\n@@ -1547,10 +1545,6 @@ package Snames is\n    --  Test to see if the name N is the name of a recognized type attribute,\n    --  i.e. an attribute reference that returns a type\n \n-   function Is_Check_Name (N : Name_Id) return Boolean;\n-   --  Test to see if the name N is the name of a recognized suppress check\n-   --  as required by pragma Suppress.\n-\n    function Is_Convention_Name (N : Name_Id) return Boolean;\n    --  Test to see if the name N is the name of one of the recognized\n    --  language conventions, as required by pragma Convention, Import,\n@@ -1597,10 +1591,6 @@ package Snames is\n    --  Returns the name of language convention correspoding to given\n    --  convention id.\n \n-   function Get_Check_Id (N : Name_Id) return Check_Id;\n-   --  Returns Id of suppress check corresponding to given name. It is an error\n-   --  to call this function with a name that is not the name of a check.\n-\n    function Get_Locking_Policy_Id (N : Name_Id) return Locking_Policy_Id;\n    --  Returns Id of locking policy corresponding to given name. It is an error\n    --  to call this function with a name that is not the name of a check.\n@@ -1635,7 +1625,6 @@ private\n    pragma Inline (Is_Attribute_Name);\n    pragma Inline (Is_Entity_Attribute_Name);\n    pragma Inline (Is_Type_Attribute_Name);\n-   pragma Inline (Is_Check_Name);\n    pragma Inline (Is_Locking_Policy_Name);\n    pragma Inline (Is_Operator_Symbol_Name);\n    pragma Inline (Is_Queuing_Policy_Name);"}, {"sha": "e431a81f8ba4ac7853e537a41fead0a637d6a742", "filename": "gcc/ada/snames.h", "status": "modified", "additions": 265, "deletions": 262, "changes": 527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fsnames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede007da18026bf6153ce5d86de81e147760b763/gcc%2Fada%2Fsnames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.h?ref=ede007da18026bf6153ce5d86de81e147760b763", "patch": "@@ -72,117 +72,118 @@ extern unsigned char Get_Attribute_Id (int);\n #define  Attr_Digits                        24\n #define  Attr_Elaborated                    25\n #define  Attr_Emax                          26\n-#define  Attr_Enum_Rep                      27\n-#define  Attr_Epsilon                       28\n-#define  Attr_Exponent                      29\n-#define  Attr_External_Tag                  30\n-#define  Attr_First                         31\n-#define  Attr_First_Bit                     32\n-#define  Attr_Fixed_Value                   33\n-#define  Attr_Fore                          34\n-#define  Attr_Has_Access_Values             35\n-#define  Attr_Has_Discriminants             36\n-#define  Attr_Identity                      37\n-#define  Attr_Img                           38\n-#define  Attr_Integer_Value                 39\n-#define  Attr_Large                         40\n-#define  Attr_Last                          41\n-#define  Attr_Last_Bit                      42\n-#define  Attr_Leading_Part                  43\n-#define  Attr_Length                        44\n-#define  Attr_Machine_Emax                  45\n-#define  Attr_Machine_Emin                  46\n-#define  Attr_Machine_Mantissa              47\n-#define  Attr_Machine_Overflows             48\n-#define  Attr_Machine_Radix                 49\n-#define  Attr_Machine_Rounding              50\n-#define  Attr_Machine_Rounds                51\n-#define  Attr_Machine_Size                  52\n-#define  Attr_Mantissa                      53\n-#define  Attr_Max_Size_In_Storage_Elements  54\n-#define  Attr_Maximum_Alignment             55\n-#define  Attr_Mechanism_Code                56\n-#define  Attr_Mod                           57\n-#define  Attr_Model_Emin                    58\n-#define  Attr_Model_Epsilon                 59\n-#define  Attr_Model_Mantissa                60\n-#define  Attr_Model_Small                   61\n-#define  Attr_Modulus                       62\n-#define  Attr_Null_Parameter                63\n-#define  Attr_Object_Size                   64\n-#define  Attr_Partition_ID                  65\n-#define  Attr_Passed_By_Reference           66\n-#define  Attr_Pool_Address                  67\n-#define  Attr_Pos                           68\n-#define  Attr_Position                      69\n-#define  Attr_Priority                      70\n-#define  Attr_Range                         71\n-#define  Attr_Range_Length                  72\n-#define  Attr_Round                         73\n-#define  Attr_Safe_Emax                     74\n-#define  Attr_Safe_First                    75\n-#define  Attr_Safe_Large                    76\n-#define  Attr_Safe_Last                     77\n-#define  Attr_Safe_Small                    78\n-#define  Attr_Scale                         79\n-#define  Attr_Scaling                       80\n-#define  Attr_Signed_Zeros                  81\n-#define  Attr_Size                          82\n-#define  Attr_Small                         83\n-#define  Attr_Storage_Size                  84\n-#define  Attr_Storage_Unit                  85\n-#define  Attr_Stream_Size                   86\n-#define  Attr_Tag                           87\n-#define  Attr_Target_Name                   88\n-#define  Attr_Terminated                    89\n-#define  Attr_To_Address                    90\n-#define  Attr_Type_Class                    91\n-#define  Attr_UET_Address                   92\n-#define  Attr_Unbiased_Rounding             93\n-#define  Attr_Unchecked_Access              94\n-#define  Attr_Unconstrained_Array           95\n-#define  Attr_Universal_Literal_String      96\n-#define  Attr_Unrestricted_Access           97\n-#define  Attr_VADS_Size                     98\n-#define  Attr_Val                           99\n-#define  Attr_Valid                         100\n-#define  Attr_Value_Size                    101\n-#define  Attr_Version                       102\n-#define  Attr_Wchar_T_Size                  103\n-#define  Attr_Wide_Wide_Width               104\n-#define  Attr_Wide_Width                    105\n-#define  Attr_Width                         106\n-#define  Attr_Word_Size                     107\n-#define  Attr_Adjacent                      108\n-#define  Attr_Ceiling                       109\n-#define  Attr_Copy_Sign                     110\n-#define  Attr_Floor                         111\n-#define  Attr_Fraction                      112\n-#define  Attr_Image                         113\n-#define  Attr_Input                         114\n-#define  Attr_Machine                       115\n-#define  Attr_Max                           116\n-#define  Attr_Min                           117\n-#define  Attr_Model                         118\n-#define  Attr_Pred                          119\n-#define  Attr_Remainder                     120\n-#define  Attr_Rounding                      121\n-#define  Attr_Succ                          122\n-#define  Attr_Truncation                    123\n-#define  Attr_Value                         124\n-#define  Attr_Wide_Image                    125\n-#define  Attr_Wide_Wide_Image               126\n-#define  Attr_Wide_Value                    127\n-#define  Attr_Wide_Wide_Value               128\n-#define  Attr_Output                        129\n-#define  Attr_Read                          130\n-#define  Attr_Write                         131\n-#define  Attr_Elab_Body                     132\n-#define  Attr_Elab_Spec                     133\n-#define  Attr_Storage_Pool                  134\n-#define  Attr_Base                          135\n-#define  Attr_Class                         136\n-#define  Attr_Stub_Type                     137\n+#define  Attr_Enabled                       27\n+#define  Attr_Enum_Rep                      28\n+#define  Attr_Epsilon                       29\n+#define  Attr_Exponent                      30\n+#define  Attr_External_Tag                  31\n+#define  Attr_First                         32\n+#define  Attr_First_Bit                     33\n+#define  Attr_Fixed_Value                   34\n+#define  Attr_Fore                          35\n+#define  Attr_Has_Access_Values             36\n+#define  Attr_Has_Discriminants             37\n+#define  Attr_Identity                      38\n+#define  Attr_Img                           39\n+#define  Attr_Integer_Value                 40\n+#define  Attr_Large                         41\n+#define  Attr_Last                          42\n+#define  Attr_Last_Bit                      43\n+#define  Attr_Leading_Part                  44\n+#define  Attr_Length                        45\n+#define  Attr_Machine_Emax                  46\n+#define  Attr_Machine_Emin                  47\n+#define  Attr_Machine_Mantissa              48\n+#define  Attr_Machine_Overflows             49\n+#define  Attr_Machine_Radix                 50\n+#define  Attr_Machine_Rounding              51\n+#define  Attr_Machine_Rounds                52\n+#define  Attr_Machine_Size                  53\n+#define  Attr_Mantissa                      54\n+#define  Attr_Max_Size_In_Storage_Elements  55\n+#define  Attr_Maximum_Alignment             56\n+#define  Attr_Mechanism_Code                57\n+#define  Attr_Mod                           58\n+#define  Attr_Model_Emin                    59\n+#define  Attr_Model_Epsilon                 60\n+#define  Attr_Model_Mantissa                61\n+#define  Attr_Model_Small                   62\n+#define  Attr_Modulus                       63\n+#define  Attr_Null_Parameter                64\n+#define  Attr_Object_Size                   65\n+#define  Attr_Partition_ID                  66\n+#define  Attr_Passed_By_Reference           67\n+#define  Attr_Pool_Address                  68\n+#define  Attr_Pos                           69\n+#define  Attr_Position                      70\n+#define  Attr_Priority                      71\n+#define  Attr_Range                         72\n+#define  Attr_Range_Length                  73\n+#define  Attr_Round                         74\n+#define  Attr_Safe_Emax                     75\n+#define  Attr_Safe_First                    76\n+#define  Attr_Safe_Large                    77\n+#define  Attr_Safe_Last                     78\n+#define  Attr_Safe_Small                    79\n+#define  Attr_Scale                         80\n+#define  Attr_Scaling                       81\n+#define  Attr_Signed_Zeros                  82\n+#define  Attr_Size                          83\n+#define  Attr_Small                         84\n+#define  Attr_Storage_Size                  85\n+#define  Attr_Storage_Unit                  86\n+#define  Attr_Stream_Size                   87\n+#define  Attr_Tag                           88\n+#define  Attr_Target_Name                   89\n+#define  Attr_Terminated                    90\n+#define  Attr_To_Address                    91\n+#define  Attr_Type_Class                    92\n+#define  Attr_UET_Address                   93\n+#define  Attr_Unbiased_Rounding             94\n+#define  Attr_Unchecked_Access              95\n+#define  Attr_Unconstrained_Array           96\n+#define  Attr_Universal_Literal_String      97\n+#define  Attr_Unrestricted_Access           98\n+#define  Attr_VADS_Size                     99\n+#define  Attr_Val                           100\n+#define  Attr_Valid                         101\n+#define  Attr_Value_Size                    102\n+#define  Attr_Version                       103\n+#define  Attr_Wchar_T_Size                  104\n+#define  Attr_Wide_Wide_Width               105\n+#define  Attr_Wide_Width                    106\n+#define  Attr_Width                         107\n+#define  Attr_Word_Size                     108\n+#define  Attr_Adjacent                      109\n+#define  Attr_Ceiling                       110\n+#define  Attr_Copy_Sign                     111\n+#define  Attr_Floor                         112\n+#define  Attr_Fraction                      113\n+#define  Attr_Image                         114\n+#define  Attr_Input                         115\n+#define  Attr_Machine                       116\n+#define  Attr_Max                           117\n+#define  Attr_Min                           118\n+#define  Attr_Model                         119\n+#define  Attr_Pred                          120\n+#define  Attr_Remainder                     121\n+#define  Attr_Rounding                      122\n+#define  Attr_Succ                          123\n+#define  Attr_Truncation                    124\n+#define  Attr_Value                         125\n+#define  Attr_Wide_Image                    126\n+#define  Attr_Wide_Wide_Image               127\n+#define  Attr_Wide_Value                    128\n+#define  Attr_Wide_Wide_Value               129\n+#define  Attr_Output                        130\n+#define  Attr_Read                          131\n+#define  Attr_Write                         132\n+#define  Attr_Elab_Body                     133\n+#define  Attr_Elab_Spec                     134\n+#define  Attr_Storage_Pool                  135\n+#define  Attr_Base                          136\n+#define  Attr_Class                         137\n+#define  Attr_Stub_Type                     138\n \n /* Define the numeric values for the conventions.  */\n \n@@ -221,156 +222,158 @@ extern unsigned char Get_Pragma_Id (int);\n #define  Pragma_Ada_2005                      3\n #define  Pragma_Assertion_Policy              4\n #define  Pragma_C_Pass_By_Copy                5\n-#define  Pragma_Compile_Time_Error            6\n-#define  Pragma_Compile_Time_Warning          7\n-#define  Pragma_Component_Alignment           8\n-#define  Pragma_Convention_Identifier         9\n-#define  Pragma_Debug_Policy                  10\n-#define  Pragma_Detect_Blocking               11\n-#define  Pragma_Discard_Names                 12\n-#define  Pragma_Elaboration_Checks            13\n-#define  Pragma_Eliminate                     14\n-#define  Pragma_Extend_System                 15\n-#define  Pragma_Extensions_Allowed            16\n-#define  Pragma_External_Name_Casing          17\n-#define  Pragma_Float_Representation          18\n-#define  Pragma_Initialize_Scalars            19\n-#define  Pragma_Interrupt_State               20\n-#define  Pragma_License                       21\n-#define  Pragma_Locking_Policy                22\n-#define  Pragma_Long_Float                    23\n-#define  Pragma_No_Run_Time                   24\n-#define  Pragma_No_Strict_Aliasing            25\n-#define  Pragma_Normalize_Scalars             26\n-#define  Pragma_Polling                       27\n-#define  Pragma_Persistent_BSS                28\n-#define  Pragma_Priority_Specific_Dispatching 29\n-#define  Pragma_Profile                       30\n-#define  Pragma_Profile_Warnings              31\n-#define  Pragma_Propagate_Exceptions          32\n-#define  Pragma_Queuing_Policy                33\n-#define  Pragma_Ravenscar                     34\n-#define  Pragma_Restricted_Run_Time           35\n-#define  Pragma_Restrictions                  36\n-#define  Pragma_Restriction_Warnings          37\n-#define  Pragma_Reviewable                    38\n-#define  Pragma_Source_File_Name              39\n-#define  Pragma_Source_File_Name_Project      40\n-#define  Pragma_Style_Checks                  41\n-#define  Pragma_Suppress                      42\n-#define  Pragma_Suppress_Exception_Locations  43\n-#define  Pragma_Task_Dispatching_Policy       44\n-#define  Pragma_Universal_Data                45\n-#define  Pragma_Unsuppress                    46\n-#define  Pragma_Use_VADS_Size                 47\n-#define  Pragma_Validity_Checks               48\n-#define  Pragma_Warnings                      49\n-#define  Pragma_Wide_Character_Encoding       50\n-#define  Pragma_Abort_Defer                   51\n-#define  Pragma_All_Calls_Remote              52\n-#define  Pragma_Annotate                      53\n-#define  Pragma_Assert                        54\n-#define  Pragma_Asynchronous                  55\n-#define  Pragma_Atomic                        56\n-#define  Pragma_Atomic_Components             57\n-#define  Pragma_Attach_Handler                58\n-#define  Pragma_CIL_Constructor               59\n-#define  Pragma_Comment                       60\n-#define  Pragma_Common_Object                 61\n-#define  Pragma_Complete_Representation       62\n-#define  Pragma_Complex_Representation        63\n-#define  Pragma_Controlled                    64\n-#define  Pragma_Convention                    65\n-#define  Pragma_CPP_Class                     66\n-#define  Pragma_CPP_Constructor               67\n-#define  Pragma_CPP_Virtual                   68\n-#define  Pragma_CPP_Vtable                    69\n-#define  Pragma_Debug                         70\n-#define  Pragma_Elaborate                     71\n-#define  Pragma_Elaborate_All                 72\n-#define  Pragma_Elaborate_Body                73\n-#define  Pragma_Export                        74\n-#define  Pragma_Export_Exception              75\n-#define  Pragma_Export_Function               76\n-#define  Pragma_Export_Object                 77\n-#define  Pragma_Export_Procedure              78\n-#define  Pragma_Export_Value                  79\n-#define  Pragma_Export_Valued_Procedure       80\n-#define  Pragma_External                      81\n-#define  Pragma_Finalize_Storage_Only         82\n-#define  Pragma_Ident                         83\n-#define  Pragma_Import                        84\n-#define  Pragma_Import_Exception              85\n-#define  Pragma_Import_Function               86\n-#define  Pragma_Import_Object                 87\n-#define  Pragma_Import_Procedure              88\n-#define  Pragma_Import_Valued_Procedure       89\n-#define  Pragma_Inline                        90\n-#define  Pragma_Inline_Always                 91\n-#define  Pragma_Inline_Generic                92\n-#define  Pragma_Inspection_Point              93\n-#define  Pragma_Interface_Name                94\n-#define  Pragma_Interrupt_Handler             95\n-#define  Pragma_Interrupt_Priority            96\n-#define  Pragma_Java_Constructor              97\n-#define  Pragma_Java_Interface                98\n-#define  Pragma_Keep_Names                    99\n-#define  Pragma_Link_With                     100\n-#define  Pragma_Linker_Alias                  101\n-#define  Pragma_Linker_Constructor            102\n-#define  Pragma_Linker_Destructor             103\n-#define  Pragma_Linker_Options                104\n-#define  Pragma_Linker_Section                105\n-#define  Pragma_List                          106\n-#define  Pragma_Machine_Attribute             107\n-#define  Pragma_Main                          108\n-#define  Pragma_Main_Storage                  109\n-#define  Pragma_Memory_Size                   110\n-#define  Pragma_No_Body                       111\n-#define  Pragma_No_Return                     112\n-#define  Pragma_Obsolescent                   113\n-#define  Pragma_Optimize                      114\n-#define  Pragma_Pack                          115\n-#define  Pragma_Page                          116\n-#define  Pragma_Passive                       117\n-#define  Pragma_Preelaborable_Initialization  118\n-#define  Pragma_Preelaborate                  119\n-#define  Pragma_Preelaborate_05               120\n-#define  Pragma_Psect_Object                  121\n-#define  Pragma_Pure                          122\n-#define  Pragma_Pure_05                       123\n-#define  Pragma_Pure_Function                 124\n-#define  Pragma_Remote_Call_Interface         125\n-#define  Pragma_Remote_Types                  126\n-#define  Pragma_Share_Generic                 127\n-#define  Pragma_Shared                        128\n-#define  Pragma_Shared_Passive                129\n-#define  Pragma_Source_Reference              130\n-#define  Pragma_Static_Elaboration_Desired    131\n-#define  Pragma_Stream_Convert                132\n-#define  Pragma_Subtitle                      133\n-#define  Pragma_Suppress_All                  134\n-#define  Pragma_Suppress_Debug_Info           135\n-#define  Pragma_Suppress_Initialization       136\n-#define  Pragma_System_Name                   137\n-#define  Pragma_Task_Info                     138\n-#define  Pragma_Task_Name                     139\n-#define  Pragma_Task_Storage                  140\n-#define  Pragma_Time_Slice                    141\n-#define  Pragma_Title                         142\n-#define  Pragma_Unchecked_Union               143\n-#define  Pragma_Unimplemented_Unit            144\n-#define  Pragma_Universal_Aliasing            145\n-#define  Pragma_Unreferenced                  146\n-#define  Pragma_Unreferenced_Objects          147\n-#define  Pragma_Unreserve_All_Interrupts      148\n-#define  Pragma_Volatile                      149\n-#define  Pragma_Volatile_Components           150\n-#define  Pragma_Weak_External                 151\n-#define  Pragma_AST_Entry                     152\n-#define  Pragma_Interface                     153\n-#define  Pragma_Priority                      154\n-#define  Pragma_Storage_Size                  155\n-#define  Pragma_Storage_Unit                  156\n+#define  Pragma_Check_Name                    6\n+#define  Pragma_Compile_Time_Error            7\n+#define  Pragma_Compile_Time_Warning          8\n+#define  Pragma_Component_Alignment           9\n+#define  Pragma_Convention_Identifier         10\n+#define  Pragma_Debug_Policy                  11\n+#define  Pragma_Detect_Blocking               12\n+#define  Pragma_Discard_Names                 13\n+#define  Pragma_Elaboration_Checks            14\n+#define  Pragma_Eliminate                     15\n+#define  Pragma_Extend_System                 16\n+#define  Pragma_Extensions_Allowed            17\n+#define  Pragma_External_Name_Casing          18\n+#define  Pragma_Float_Representation          19\n+#define  Pragma_Implicit_Packing              20\n+#define  Pragma_Initialize_Scalars            21\n+#define  Pragma_Interrupt_State               22\n+#define  Pragma_License                       23\n+#define  Pragma_Locking_Policy                24\n+#define  Pragma_Long_Float                    25\n+#define  Pragma_No_Run_Time                   26\n+#define  Pragma_No_Strict_Aliasing            27\n+#define  Pragma_Normalize_Scalars             28\n+#define  Pragma_Polling                       29\n+#define  Pragma_Persistent_BSS                30\n+#define  Pragma_Priority_Specific_Dispatching 31\n+#define  Pragma_Profile                       32\n+#define  Pragma_Profile_Warnings              33\n+#define  Pragma_Propagate_Exceptions          34\n+#define  Pragma_Queuing_Policy                35\n+#define  Pragma_Ravenscar                     36\n+#define  Pragma_Restricted_Run_Time           37\n+#define  Pragma_Restrictions                  38\n+#define  Pragma_Restriction_Warnings          39\n+#define  Pragma_Reviewable                    40\n+#define  Pragma_Source_File_Name              41\n+#define  Pragma_Source_File_Name_Project      42\n+#define  Pragma_Style_Checks                  43\n+#define  Pragma_Suppress                      44\n+#define  Pragma_Suppress_Exception_Locations  45\n+#define  Pragma_Task_Dispatching_Policy       46\n+#define  Pragma_Universal_Data                47\n+#define  Pragma_Unsuppress                    48\n+#define  Pragma_Use_VADS_Size                 49\n+#define  Pragma_Validity_Checks               50\n+#define  Pragma_Warnings                      51\n+#define  Pragma_Wide_Character_Encoding       52\n+#define  Pragma_Abort_Defer                   53\n+#define  Pragma_All_Calls_Remote              54\n+#define  Pragma_Annotate                      55\n+#define  Pragma_Assert                        56\n+#define  Pragma_Asynchronous                  57\n+#define  Pragma_Atomic                        58\n+#define  Pragma_Atomic_Components             59\n+#define  Pragma_Attach_Handler                60\n+#define  Pragma_CIL_Constructor               61\n+#define  Pragma_Comment                       62\n+#define  Pragma_Common_Object                 63\n+#define  Pragma_Complete_Representation       64\n+#define  Pragma_Complex_Representation        65\n+#define  Pragma_Controlled                    66\n+#define  Pragma_Convention                    67\n+#define  Pragma_CPP_Class                     68\n+#define  Pragma_CPP_Constructor               69\n+#define  Pragma_CPP_Virtual                   70\n+#define  Pragma_CPP_Vtable                    71\n+#define  Pragma_Debug                         72\n+#define  Pragma_Elaborate                     73\n+#define  Pragma_Elaborate_All                 74\n+#define  Pragma_Elaborate_Body                75\n+#define  Pragma_Export                        76\n+#define  Pragma_Export_Exception              77\n+#define  Pragma_Export_Function               78\n+#define  Pragma_Export_Object                 79\n+#define  Pragma_Export_Procedure              80\n+#define  Pragma_Export_Value                  81\n+#define  Pragma_Export_Valued_Procedure       82\n+#define  Pragma_External                      83\n+#define  Pragma_Finalize_Storage_Only         84\n+#define  Pragma_Ident                         85\n+#define  Pragma_Import                        86\n+#define  Pragma_Import_Exception              87\n+#define  Pragma_Import_Function               88\n+#define  Pragma_Import_Object                 89\n+#define  Pragma_Import_Procedure              90\n+#define  Pragma_Import_Valued_Procedure       91\n+#define  Pragma_Inline                        92\n+#define  Pragma_Inline_Always                 93\n+#define  Pragma_Inline_Generic                94\n+#define  Pragma_Inspection_Point              95\n+#define  Pragma_Interface_Name                96\n+#define  Pragma_Interrupt_Handler             97\n+#define  Pragma_Interrupt_Priority            98\n+#define  Pragma_Java_Constructor              99\n+#define  Pragma_Java_Interface                100\n+#define  Pragma_Keep_Names                    101\n+#define  Pragma_Link_With                     102\n+#define  Pragma_Linker_Alias                  103\n+#define  Pragma_Linker_Constructor            104\n+#define  Pragma_Linker_Destructor             105\n+#define  Pragma_Linker_Options                106\n+#define  Pragma_Linker_Section                107\n+#define  Pragma_List                          108\n+#define  Pragma_Machine_Attribute             109\n+#define  Pragma_Main                          110\n+#define  Pragma_Main_Storage                  111\n+#define  Pragma_Memory_Size                   112\n+#define  Pragma_No_Body                       113\n+#define  Pragma_No_Return                     114\n+#define  Pragma_Obsolescent                   115\n+#define  Pragma_Optimize                      116\n+#define  Pragma_Pack                          117\n+#define  Pragma_Page                          118\n+#define  Pragma_Passive                       119\n+#define  Pragma_Preelaborable_Initialization  120\n+#define  Pragma_Preelaborate                  121\n+#define  Pragma_Preelaborate_05               122\n+#define  Pragma_Psect_Object                  123\n+#define  Pragma_Pure                          124\n+#define  Pragma_Pure_05                       125\n+#define  Pragma_Pure_Function                 126\n+#define  Pragma_Remote_Call_Interface         127\n+#define  Pragma_Remote_Types                  128\n+#define  Pragma_Share_Generic                 129\n+#define  Pragma_Shared                        130\n+#define  Pragma_Shared_Passive                131\n+#define  Pragma_Source_Reference              132\n+#define  Pragma_Static_Elaboration_Desired    133\n+#define  Pragma_Stream_Convert                134\n+#define  Pragma_Subtitle                      135\n+#define  Pragma_Suppress_All                  136\n+#define  Pragma_Suppress_Debug_Info           137\n+#define  Pragma_Suppress_Initialization       138\n+#define  Pragma_System_Name                   139\n+#define  Pragma_Task_Info                     140\n+#define  Pragma_Task_Name                     141\n+#define  Pragma_Task_Storage                  142\n+#define  Pragma_Time_Slice                    143\n+#define  Pragma_Title                         144\n+#define  Pragma_Unchecked_Union               145\n+#define  Pragma_Unimplemented_Unit            146\n+#define  Pragma_Universal_Aliasing            147\n+#define  Pragma_Unreferenced                  148\n+#define  Pragma_Unreferenced_Objects          149\n+#define  Pragma_Unreserve_All_Interrupts      150\n+#define  Pragma_Volatile                      151\n+#define  Pragma_Volatile_Components           152\n+#define  Pragma_Weak_External                 153\n+#define  Pragma_AST_Entry                     154\n+#define  Pragma_Interface                     155\n+#define  Pragma_Priority                      156\n+#define  Pragma_Storage_Size                  157\n+#define  Pragma_Storage_Unit                  158\n \n /* End of snames.h (C version of Snames package spec) */"}]}