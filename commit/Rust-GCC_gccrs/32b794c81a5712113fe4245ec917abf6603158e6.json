{"sha": "32b794c81a5712113fe4245ec917abf6603158e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJiNzk0YzgxYTU3MTIxMTNmZTQyNDVlYzkxN2FiZjY2MDMxNThlNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-05-02T10:05:03Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-05-02T10:05:03Z"}, "message": "[multiple changes]\n\n2016-05-02  Tristan Gingold  <gingold@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Object_Declaration): Use Has_Protected\n\tto check for the no local protected objects restriction.\n\n2016-05-02  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb Anonymous_Master now uses Node35.\n\t(Anonymous_Master): Update the assertion and node reference.\n\t(Set_Anonymous_Master): Update the assertion and node reference.\n\t(Write_Field35_Name): Add output for Anonymous_Master.\n\t(Write_Field36_Name): The output is now undefined.\n\t* einfo.ads Update the node and description of attribute\n\tAnonymous_Master. Remove prior occurrences in entities as this\n\tis now a type attribute.\n\t* exp_ch3.adb (Expand_Freeze_Array_Type): Remove local variable\n\tIns_Node. Anonymous access- to-controlled component types no\n\tlonger need finalization masters. The master is now built when\n\ta related allocator is expanded.\n\t(Expand_Freeze_Record_Type): Remove local variable Has_AACC. Do not\n\tdetect whether the record type has at least one component of anonymous\n\taccess-to- controlled type. These types no longer need finalization\n\tmasters. The master is now built when a related allocator is expanded.\n\t* exp_ch4.adb Remove with and use clauses for Lib and Sem_Ch8.\n\t(Current_Anonymous_Master): Removed.\n\t(Expand_N_Allocator): Call Build_Anonymous_Master to create a\n\tfinalization master for an anonymous access-to-controlled type.\n\t* exp_ch6.adb (Add_Finalization_Master_Actual_To_Build_In_Place_Call):\n\tCall routine Build_Anonymous_Master to create a finalization master\n\tfor an anonymous access-to-controlled type.\n\t* exp_ch7.adb (Allows_Finalization_Master): New routine.\n\t(Build_Anonymous_Master): New routine.\n\t(Build_Finalization_Master): Remove formal parameter\n\tFor_Anonymous. Use Allows_Finalization_Master to determine whether\n\tcircumstances warrant a finalization master. This routine no\n\tlonger creates masters for anonymous access-to-controlled types.\n\t(In_Deallocation_Instance): Removed.\n\t* exp_ch7.ads (Build_Anonymous_Master): New routine.\n\t(Build_Finalization_Master): Remove formal parameter For_Anonymous\n\tand update the comment on usage.\n\t* sem_util.adb (Get_Qualified_Name): New routines.\n\t(Output_Name): Reimplemented.\n\t(Output_Scope): Removed.\n\t* sem_util.ads (Get_Qualified_Name): New routines.\n\n2016-05-02  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* debug.adb: Document the use of switch -gnatd.H.\n\t* gnat1drv.adb (Adjust_Global_Switches): Set ASIS_GNSA mode when\n\t-gnatd.H is present.\n\t(Gnat1drv): Suppress the call to gigi when ASIS_GNSA mode is active.\n\t* opt.ads: Add new option ASIS_GNSA_Mode.\n\t* sem_ch13.adb (Alignment_Error): New routine.\n\t(Analyze_Attribute_Definition_Clause): Suppress certain errors in\n\tASIS mode for attribute clause Alignment, Machine_Radix, Size, and\n\tStream_Size.\n\t(Check_Size): Use routine Size_Too_Small_Error to\n\tsuppress certain errors in ASIS mode.\n\t(Get_Alignment_Value): Use routine Alignment_Error to suppress certain\n\terrors in ASIS mode.\n\t(Size_Too_Small_Error): New routine.\n\nFrom-SVN: r235732", "tree": {"sha": "946af8cebd6c6a51d7c357762295cdf4ebbeeba0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/946af8cebd6c6a51d7c357762295cdf4ebbeeba0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32b794c81a5712113fe4245ec917abf6603158e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32b794c81a5712113fe4245ec917abf6603158e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32b794c81a5712113fe4245ec917abf6603158e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32b794c81a5712113fe4245ec917abf6603158e6/comments", "author": null, "committer": null, "parents": [{"sha": "4871a41df95577e9c43dcf118d46e7faf733ef94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4871a41df95577e9c43dcf118d46e7faf733ef94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4871a41df95577e9c43dcf118d46e7faf733ef94"}], "stats": {"total": 1312, "additions": 697, "deletions": 615}, "files": [{"sha": "7627ad335a93fbf38afdb253429b7e5481fe094a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=32b794c81a5712113fe4245ec917abf6603158e6", "patch": "@@ -1,3 +1,65 @@\n+2016-05-02  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Object_Declaration): Use Has_Protected\n+\tto check for the no local protected objects restriction.\n+\n+2016-05-02  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.adb Anonymous_Master now uses Node35.\n+\t(Anonymous_Master): Update the assertion and node reference.\n+\t(Set_Anonymous_Master): Update the assertion and node reference.\n+\t(Write_Field35_Name): Add output for Anonymous_Master.\n+\t(Write_Field36_Name): The output is now undefined.\n+\t* einfo.ads Update the node and description of attribute\n+\tAnonymous_Master. Remove prior occurrences in entities as this\n+\tis now a type attribute.\n+\t* exp_ch3.adb (Expand_Freeze_Array_Type): Remove local variable\n+\tIns_Node. Anonymous access- to-controlled component types no\n+\tlonger need finalization masters. The master is now built when\n+\ta related allocator is expanded.\n+\t(Expand_Freeze_Record_Type): Remove local variable Has_AACC. Do not\n+\tdetect whether the record type has at least one component of anonymous\n+\taccess-to- controlled type. These types no longer need finalization\n+\tmasters. The master is now built when a related allocator is expanded.\n+\t* exp_ch4.adb Remove with and use clauses for Lib and Sem_Ch8.\n+\t(Current_Anonymous_Master): Removed.\n+\t(Expand_N_Allocator): Call Build_Anonymous_Master to create a\n+\tfinalization master for an anonymous access-to-controlled type.\n+\t* exp_ch6.adb (Add_Finalization_Master_Actual_To_Build_In_Place_Call):\n+\tCall routine Build_Anonymous_Master to create a finalization master\n+\tfor an anonymous access-to-controlled type.\n+\t* exp_ch7.adb (Allows_Finalization_Master): New routine.\n+\t(Build_Anonymous_Master): New routine.\n+\t(Build_Finalization_Master): Remove formal parameter\n+\tFor_Anonymous. Use Allows_Finalization_Master to determine whether\n+\tcircumstances warrant a finalization master. This routine no\n+\tlonger creates masters for anonymous access-to-controlled types.\n+\t(In_Deallocation_Instance): Removed.\n+\t* exp_ch7.ads (Build_Anonymous_Master): New routine.\n+\t(Build_Finalization_Master): Remove formal parameter For_Anonymous\n+\tand update the comment on usage.\n+\t* sem_util.adb (Get_Qualified_Name): New routines.\n+\t(Output_Name): Reimplemented.\n+\t(Output_Scope): Removed.\n+\t* sem_util.ads (Get_Qualified_Name): New routines.\n+\n+2016-05-02  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* debug.adb: Document the use of switch -gnatd.H.\n+\t* gnat1drv.adb (Adjust_Global_Switches): Set ASIS_GNSA mode when\n+\t-gnatd.H is present.\n+\t(Gnat1drv): Suppress the call to gigi when ASIS_GNSA mode is active.\n+\t* opt.ads: Add new option ASIS_GNSA_Mode.\n+\t* sem_ch13.adb (Alignment_Error): New routine.\n+\t(Analyze_Attribute_Definition_Clause): Suppress certain errors in\n+\tASIS mode for attribute clause Alignment, Machine_Radix, Size, and\n+\tStream_Size.\n+\t(Check_Size): Use routine Size_Too_Small_Error to\n+\tsuppress certain errors in ASIS mode.\n+\t(Get_Alignment_Value): Use routine Alignment_Error to suppress certain\n+\terrors in ASIS mode.\n+\t(Size_Too_Small_Error): New routine.\n+\n 2016-05-02  Arnaud Charlet  <charlet@adacore.com>\n \n \t* spark_xrefs.ads Description of the spark cross-references"}, {"sha": "f39691304af7e45f8df20468ce131a9bea6d2daa", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=32b794c81a5712113fe4245ec917abf6603158e6", "patch": "@@ -125,7 +125,7 @@ package body Debug is\n    --  d.E  Turn selected errors into warnings\n    --  d.F  Debug mode for GNATprove\n    --  d.G  Ignore calls through generic formal parameters for elaboration\n-   --  d.H\n+   --  d.H  GNSA mode for ASIS\n    --  d.I  Do not ignore enum representation clauses in CodePeer mode\n    --  d.J  Disable parallel SCIL generation mode\n    --  d.K\n@@ -630,6 +630,9 @@ package body Debug is\n    --       now fixed, but we provide this debug flag to revert to the previous\n    --       situation of ignoring such calls to aid in transition.\n \n+   --  d.H  Sets ASIS_GNSA_Mode to True. This signals the front end to suppress\n+   --       the call to gigi in ASIS_Mode.\n+\n    --  d.I  Do not ignore enum representation clauses in CodePeer mode.\n    --       The default of ignoring representation clauses for enumeration\n    --       types in CodePeer is good for the majority of Ada code, but in some"}, {"sha": "378b75711ec5fcb3ccbf69fd085a44afc61ce6bf", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 10, "deletions": 26, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=32b794c81a5712113fe4245ec917abf6603158e6", "patch": "@@ -265,10 +265,9 @@ package body Einfo is\n \n    --    Contract                        Node34\n \n+   --    Anonymous_Master                Node35\n    --    Import_Pragma                   Node35\n \n-   --    Anonymous_Master                Node36\n-\n    --    Class_Wide_Preconds             List38\n \n    --    Class_Wide_Postconds            List39\n@@ -757,12 +756,8 @@ package body Einfo is\n \n    function Anonymous_Master (Id : E) return E is\n    begin\n-      pragma Assert (Ekind_In (Id, E_Function,\n-                                   E_Package,\n-                                   E_Package_Body,\n-                                   E_Procedure,\n-                                   E_Subprogram_Body));\n-      return Node36 (Id);\n+      pragma Assert (Is_Type (Id));\n+      return Node35 (Id);\n    end Anonymous_Master;\n \n    function Anonymous_Object (Id : E) return E is\n@@ -3682,12 +3677,8 @@ package body Einfo is\n \n    procedure Set_Anonymous_Master (Id : E; V : E) is\n    begin\n-      pragma Assert (Ekind_In (Id, E_Function,\n-                                   E_Package,\n-                                   E_Package_Body,\n-                                   E_Procedure,\n-                                   E_Subprogram_Body));\n-      Set_Node36 (Id, V);\n+      pragma Assert (Is_Type (Id));\n+      Set_Node35 (Id, V);\n    end Set_Anonymous_Master;\n \n    procedure Set_Anonymous_Object (Id : E; V : E) is\n@@ -10385,6 +10376,9 @@ package body Einfo is\n    procedure Write_Field35_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when Type_Kind                                    =>\n+            Write_Str (\"Anonymous_Master\");\n+\n          when Subprogram_Kind                              =>\n             Write_Str (\"Import_Pragma\");\n \n@@ -10398,19 +10392,9 @@ package body Einfo is\n    ------------------------\n \n    procedure Write_Field36_Name (Id : Entity_Id) is\n+      pragma Unreferenced (Id);\n    begin\n-      case Ekind (Id) is\n-         when E_Function                                   |\n-              E_Operator                                   |\n-              E_Package                                    |\n-              E_Package_Body                               |\n-              E_Procedure                                  |\n-              E_Subprogram_Body                            =>\n-            Write_Str (\"Anonymous_Master\");\n-\n-         when others                                       =>\n-            Write_Str (\"Field36??\");\n-      end case;\n+      Write_Str (\"Field36??\");\n    end Write_Field36_Name;\n \n    ------------------------"}, {"sha": "9e2895924487c4460dc789f4cff8dfe191795c50", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=32b794c81a5712113fe4245ec917abf6603158e6", "patch": "@@ -438,11 +438,11 @@ package Einfo is\n --       definition clause with an (obsolescent) mod clause is converted\n --       into an attribute definition clause for this purpose.\n \n---    Anonymous_Master (Node36)\n---       Defined in the entities of non-generic packages, subprograms and their\n---       corresponding bodies. Contains the entity of a special heterogeneous\n---       finalization master that services most anonymous access-to-controlled\n---       allocations that occur within the unit.\n+--    Anonymous_Master (Node35)\n+--       Defined in all types. Contains the entity of an anonymous finalization\n+--       master which services all anonymous access types associated with the\n+--       same designated type within the current semantic unit. The attribute\n+--       is set reactively during the expansion of allocators.\n \n --    Anonymous_Object (Node30)\n --       Present in protected and task type entities. Contains the entity of\n@@ -5468,6 +5468,7 @@ package Einfo is\n    --    Derived_Type_Link                   (Node31)\n    --    No_Tagged_Streams_Pragma            (Node32)\n    --    Linker_Section_Pragma               (Node33)\n+   --    Anonymous_Master                    (Node35)\n \n    --    Depends_On_Private                  (Flag14)\n    --    Disable_Controlled                  (Flag253)\n@@ -5668,8 +5669,8 @@ package Einfo is\n    --    Cloned_Subtype                      (Node16)   (subtype case only)\n    --    First_Entity                        (Node17)\n    --    Equivalent_Type                     (Node18)   (always Empty for type)\n-   --    Last_Entity                         (Node20)\n    --    Non_Limited_View                    (Node19)\n+   --    Last_Entity                         (Node20)\n    --    SSO_Set_High_By_Default             (Flag273)  (base type only)\n    --    SSO_Set_Low_By_Default              (Flag272)  (base type only)\n    --    First_Component                     (synth)\n@@ -5919,7 +5920,6 @@ package Einfo is\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n    --    Import_Pragma                       (Node35)   (non-generic case only)\n-   --    Anonymous_Master                    (Node36)   (non-generic case only)\n    --    Class_Wide_Preconds                 (List38)\n    --    Class_Wide_Postconds                (List39)\n    --    SPARK_Pragma                        (Node40)\n@@ -6141,7 +6141,6 @@ package Einfo is\n    --    Current_Use_Clause                  (Node27)\n    --    Finalizer                           (Node28)   (non-generic case only)\n    --    Contract                            (Node34)\n-   --    Anonymous_Master                    (Node36)   (non-generic case only)\n    --    SPARK_Pragma                        (Node40)\n    --    SPARK_Aux_Pragma                    (Node41)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n@@ -6179,7 +6178,6 @@ package Einfo is\n    --    Scope_Depth_Value                   (Uint22)\n    --    Finalizer                           (Node28)   (non-generic case only)\n    --    Contract                            (Node34)\n-   --    Anonymous_Master                    (Node36)\n    --    SPARK_Pragma                        (Node40)\n    --    SPARK_Aux_Pragma                    (Node41)\n    --    Contains_Ignored_Ghost_Code         (Flag279)\n@@ -6233,7 +6231,6 @@ package Einfo is\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n    --    Import_Pragma                       (Node35)   (non-generic case only)\n-   --    Anonymous_Master                    (Node36)   (non-generic case only)\n    --    Class_Wide_Preconds                 (List38)\n    --    Class_Wide_Postconds                (List39)\n    --    SPARK_Pragma                        (Node40)\n@@ -6419,7 +6416,6 @@ package Einfo is\n    --    Scope_Depth_Value                   (Uint22)\n    --    Extra_Formals                       (Node28)\n    --    Contract                            (Node34)\n-   --    Anonymous_Master                    (Node36)\n    --    SPARK_Pragma                        (Node40)\n    --    Contains_Ignored_Ghost_Code         (Flag279)\n    --    SPARK_Pragma_Inherited              (Flag265)"}, {"sha": "74d3902f529042b9ca0d68700b26ff5b5a46cbf4", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 12, "deletions": 145, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=32b794c81a5712113fe4245ec917abf6603158e6", "patch": "@@ -4600,8 +4600,6 @@ package body Exp_Ch3 is\n \n       Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n \n-      Ins_Node : Node_Id;\n-\n    begin\n       --  Ensure that all freezing activities are properly flagged as Ghost\n \n@@ -4654,39 +4652,13 @@ package body Exp_Ch3 is\n             end if;\n          end if;\n \n-         if Typ = Base then\n-            if Has_Controlled_Component (Base) then\n-               Build_Controlling_Procs (Base);\n-\n-               if not Is_Limited_Type (Comp_Typ)\n-                 and then Number_Dimensions (Typ) = 1\n-               then\n-                  Build_Slice_Assignment (Typ);\n-               end if;\n-            end if;\n-\n-            --  Create a finalization master to service the anonymous access\n-            --  components of the array.\n+         if Typ = Base and then Has_Controlled_Component (Base) then\n+            Build_Controlling_Procs (Base);\n \n-            if Ekind (Comp_Typ) = E_Anonymous_Access_Type\n-              and then Needs_Finalization (Designated_Type (Comp_Typ))\n+            if not Is_Limited_Type (Comp_Typ)\n+              and then Number_Dimensions (Typ) = 1\n             then\n-               --  The finalization master is inserted before the declaration\n-               --  of the array type. The only exception to this is when the\n-               --  array type is an itype, in which case the master appears\n-               --  before the related context.\n-\n-               if Is_Itype (Typ) then\n-                  Ins_Node := Associated_Node_For_Itype (Typ);\n-               else\n-                  Ins_Node := Parent (Typ);\n-               end if;\n-\n-               Build_Finalization_Master\n-                 (Typ            => Comp_Typ,\n-                  For_Anonymous  => True,\n-                  Context_Scope  => Scope (Typ),\n-                  Insertion_Node => Ins_Node);\n+               Build_Slice_Assignment (Typ);\n             end if;\n          end if;\n \n@@ -5044,13 +5016,12 @@ package body Exp_Ch3 is\n          Append_To (Lst,\n            Make_Case_Statement_Alternative (Loc,\n              Discrete_Choices => New_List (Make_Others_Choice (Loc)),\n-             Statements => New_List (\n+             Statements       => New_List (\n                Make_Raise_Constraint_Error (Loc,\n                  Condition => Make_Identifier (Loc, Name_uF),\n                  Reason    => CE_Invalid_Data),\n                Make_Simple_Return_Statement (Loc,\n-                 Expression =>\n-                   Make_Integer_Literal (Loc, -1)))));\n+                 Expression => Make_Integer_Literal (Loc, -1)))));\n \n       --  If either of the restrictions No_Exceptions_Handlers/Propagation is\n       --  active then return -1 (we cannot usefully raise Constraint_Error in\n@@ -5060,10 +5031,9 @@ package body Exp_Ch3 is\n          Append_To (Lst,\n            Make_Case_Statement_Alternative (Loc,\n              Discrete_Choices => New_List (Make_Others_Choice (Loc)),\n-             Statements => New_List (\n+             Statements       => New_List (\n                Make_Simple_Return_Statement (Loc,\n-                 Expression =>\n-                   Make_Integer_Literal (Loc, -1)))));\n+                 Expression => Make_Integer_Literal (Loc, -1)))));\n       end if;\n \n       --  Now we can build the function body\n@@ -5137,19 +5107,18 @@ package body Exp_Ch3 is\n \n       Comp        : Entity_Id;\n       Comp_Typ    : Entity_Id;\n-      Has_AACC    : Boolean;\n       Predef_List : List_Id;\n \n+      Wrapper_Decl_List : List_Id := No_List;\n+      Wrapper_Body_List : List_Id := No_List;\n+\n       Renamed_Eq : Node_Id := Empty;\n       --  Defining unit name for the predefined equality function in the case\n       --  where the type has a primitive operation that is a renaming of\n       --  predefined equality (but only if there is also an overriding\n       --  user-defined equality function). Used to pass this entity from\n       --  Make_Predefined_Primitive_Specs to Predefined_Primitive_Bodies.\n \n-      Wrapper_Decl_List : List_Id := No_List;\n-      Wrapper_Body_List : List_Id := No_List;\n-\n    --  Start of processing for Expand_Freeze_Record_Type\n \n    begin\n@@ -5212,8 +5181,6 @@ package body Exp_Ch3 is\n       --  of the component types may have been private at the point of the\n       --  record declaration. Detect anonymous access-to-controlled components.\n \n-      Has_AACC := False;\n-\n       Comp := First_Component (Typ);\n       while Present (Comp) loop\n          Comp_Typ := Etype (Comp);\n@@ -5238,15 +5205,6 @@ package body Exp_Ch3 is\n             Set_Has_Controlled_Component (Typ);\n          end if;\n \n-         --  Non-self-referential anonymous access-to-controlled component\n-\n-         if Ekind (Comp_Typ) = E_Anonymous_Access_Type\n-           and then Needs_Finalization (Designated_Type (Comp_Typ))\n-           and then Designated_Type (Comp_Typ) /= Typ\n-         then\n-            Has_AACC := True;\n-         end if;\n-\n          Next_Component (Comp);\n       end loop;\n \n@@ -5595,97 +5553,6 @@ package body Exp_Ch3 is\n          end;\n       end if;\n \n-      --  Create a heterogeneous finalization master to service the anonymous\n-      --  access-to-controlled components of the record type.\n-\n-      if Has_AACC then\n-         declare\n-            Encl_Scope : constant Entity_Id  := Scope (Typ);\n-            Ins_Node   : constant Node_Id    := Parent (Typ);\n-            Loc        : constant Source_Ptr := Sloc (Typ);\n-            Fin_Mas_Id : Entity_Id;\n-\n-            Attributes_Set : Boolean := False;\n-            Master_Built   : Boolean := False;\n-            --  Two flags which control the creation and initialization of a\n-            --  common heterogeneous master.\n-\n-         begin\n-            Comp := First_Component (Typ);\n-            while Present (Comp) loop\n-               Comp_Typ := Etype (Comp);\n-\n-               --  A non-self-referential anonymous access-to-controlled\n-               --  component.\n-\n-               if Ekind (Comp_Typ) = E_Anonymous_Access_Type\n-                 and then Needs_Finalization (Designated_Type (Comp_Typ))\n-                 and then Designated_Type (Comp_Typ) /= Typ\n-               then\n-                  --  Build a homogeneous master for the first anonymous\n-                  --  access-to-controlled component. This master may be\n-                  --  converted into a heterogeneous collection if more\n-                  --  components are to follow.\n-\n-                  if not Master_Built then\n-                     Master_Built := True;\n-\n-                     --  All anonymous access-to-controlled types allocate\n-                     --  on the global pool. Note that the finalization\n-                     --  master and the associated storage pool must be set\n-                     --  on the root type (both are \"root type only\").\n-\n-                     Set_Associated_Storage_Pool\n-                       (Root_Type (Comp_Typ), RTE (RE_Global_Pool_Object));\n-\n-                     Build_Finalization_Master\n-                       (Typ            => Root_Type (Comp_Typ),\n-                        For_Anonymous  => True,\n-                        Context_Scope  => Encl_Scope,\n-                        Insertion_Node => Ins_Node);\n-\n-                     Fin_Mas_Id := Finalization_Master (Comp_Typ);\n-\n-                  --  Subsequent anonymous access-to-controlled components\n-                  --  reuse the available master.\n-\n-                  else\n-                     --  All anonymous access-to-controlled types allocate\n-                     --  on the global pool. Note that both the finalization\n-                     --  master and the associated storage pool must be set\n-                     --  on the root type (both are \"root type only\").\n-\n-                     Set_Associated_Storage_Pool\n-                       (Root_Type (Comp_Typ), RTE (RE_Global_Pool_Object));\n-\n-                     --  Shared the master among multiple components\n-\n-                     Set_Finalization_Master\n-                       (Root_Type (Comp_Typ), Fin_Mas_Id);\n-\n-                     --  Convert the master into a heterogeneous collection.\n-                     --  Generate:\n-                     --    Set_Is_Heterogeneous (<Fin_Mas_Id>);\n-\n-                     if not Attributes_Set then\n-                        Attributes_Set := True;\n-\n-                        Insert_Action (Ins_Node,\n-                          Make_Procedure_Call_Statement (Loc,\n-                            Name                   =>\n-                              New_Occurrence_Of\n-                                (RTE (RE_Set_Is_Heterogeneous), Loc),\n-                            Parameter_Associations => New_List (\n-                              New_Occurrence_Of (Fin_Mas_Id, Loc))));\n-                     end if;\n-                  end if;\n-               end if;\n-\n-               Next_Component (Comp);\n-            end loop;\n-         end;\n-      end if;\n-\n       --  Check whether individual components have a defined invariant, and add\n       --  the corresponding component invariant checks.\n "}, {"sha": "ea59e6e73b49bc100316a97a472d837392fb415f", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 1, "deletions": 206, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=32b794c81a5712113fe4245ec917abf6603158e6", "patch": "@@ -44,7 +44,6 @@ with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n with Inline;   use Inline;\n-with Lib;      use Lib;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -57,7 +56,6 @@ with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch3;  use Sem_Ch3;\n-with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n@@ -92,12 +90,6 @@ package body Exp_Ch4 is\n    --  If a boolean array assignment can be done in place, build call to\n    --  corresponding library procedure.\n \n-   function Current_Anonymous_Master return Entity_Id;\n-   --  Return the entity of the heterogeneous finalization master belonging to\n-   --  the current unit (either function, package or procedure). This master\n-   --  services all anonymous access-to-controlled types. If the current unit\n-   --  does not have such master, create one.\n-\n    procedure Displace_Allocator_Pointer (N : Node_Id);\n    --  Ada 2005 (AI-251): Subsidiary procedure to Expand_N_Allocator and\n    --  Expand_Allocator_Expression. Allocating class-wide interface objects\n@@ -410,202 +402,6 @@ package body Exp_Ch4 is\n          return;\n    end Build_Boolean_Array_Proc_Call;\n \n-   ------------------------------\n-   -- Current_Anonymous_Master --\n-   ------------------------------\n-\n-   function Current_Anonymous_Master return Entity_Id is\n-      function Create_Anonymous_Master\n-        (Unit_Id   : Entity_Id;\n-         Unit_Decl : Node_Id) return Entity_Id;\n-      --  Create a new anonymous master for a compilation unit denoted by its\n-      --  entity Unit_Id and declaration Unit_Decl. The declaration of the new\n-      --  master along with any specialized initialization is inserted at the\n-      --  top of the unit's declarations (see body for special cases). Return\n-      --  the entity of the anonymous master.\n-\n-      -----------------------------\n-      -- Create_Anonymous_Master --\n-      -----------------------------\n-\n-      function Create_Anonymous_Master\n-        (Unit_Id   : Entity_Id;\n-         Unit_Decl : Node_Id) return Entity_Id\n-      is\n-         Insert_Nod : Node_Id := Empty;\n-         --  The point of insertion into the declarative list of the unit. All\n-         --  nodes are inserted before Insert_Nod.\n-\n-         procedure Insert_And_Analyze (Decls : List_Id; N : Node_Id);\n-         --  Insert arbitrary node N in declarative list Decls and analyze it\n-\n-         ------------------------\n-         -- Insert_And_Analyze --\n-         ------------------------\n-\n-         procedure Insert_And_Analyze (Decls : List_Id; N : Node_Id) is\n-         begin\n-            --  The declarative list is already populated, the nodes are\n-            --  inserted at the top of the list, preserving their order.\n-\n-            if Present (Insert_Nod) then\n-               Insert_Before (Insert_Nod, N);\n-\n-            --  Otherwise append to the declarations to preserve order\n-\n-            else\n-               Append_To (Decls, N);\n-            end if;\n-\n-            Analyze (N);\n-         end Insert_And_Analyze;\n-\n-         --  Local variables\n-\n-         Loc       : constant Source_Ptr := Sloc (Unit_Id);\n-         Spec_Id   : constant Entity_Id  := Unique_Defining_Entity (Unit_Decl);\n-         Decls     : List_Id;\n-         FM_Id     : Entity_Id;\n-         Pref      : Character;\n-         Unit_Spec : Node_Id;\n-\n-      --  Start of processing for Create_Anonymous_Master\n-\n-      begin\n-         --  Find the declarative list of the unit\n-\n-         if Nkind (Unit_Decl) = N_Package_Declaration then\n-            Unit_Spec := Specification (Unit_Decl);\n-            Decls := Visible_Declarations (Unit_Spec);\n-\n-            if No (Decls) then\n-               Decls := New_List (Make_Null_Statement (Loc));\n-               Set_Visible_Declarations (Unit_Spec, Decls);\n-            end if;\n-\n-         --  Package or subprogram body\n-\n-         --  ??? A subprogram declaration that acts as a compilation unit may\n-         --  contain a formal parameter of an anonymous access-to-controlled\n-         --  type initialized by an allocator.\n-\n-         --    procedure Comp_Unit_Proc (Param : access Ctrl := new Ctrl);\n-\n-         --  There is no suitable place to create the anonymous master as the\n-         --  subprogram is not in a declarative list.\n-\n-         else\n-            Decls := Declarations (Unit_Decl);\n-\n-            if No (Decls) then\n-               Decls := New_List (Make_Null_Statement (Loc));\n-               Set_Declarations (Unit_Decl, Decls);\n-            end if;\n-         end if;\n-\n-         --  The anonymous master and all initialization actions are inserted\n-         --  before the first declaration (if any).\n-\n-         Insert_Nod := First (Decls);\n-\n-         --  Since the anonymous master and all its initialization actions are\n-         --  inserted at top level, use the scope of the unit when analyzing.\n-\n-         Push_Scope (Spec_Id);\n-\n-         --  Step 1: Anonymous master creation\n-\n-         --  Use a unique prefix in case the same unit requires two anonymous\n-         --  masters, one for the spec (S) and one for the body (B).\n-\n-         if Ekind_In (Unit_Id, E_Function, E_Package, E_Procedure) then\n-            Pref := 'S';\n-         else\n-            Pref := 'B';\n-         end if;\n-\n-         FM_Id :=\n-           Make_Defining_Identifier (Loc,\n-             New_External_Name\n-               (Related_Id => Chars (Unit_Id),\n-                Suffix     => \"AM\",\n-                Prefix     => Pref));\n-\n-         Set_Anonymous_Master (Unit_Id, FM_Id);\n-\n-         --  Generate:\n-         --    <FM_Id> : Finalization_Master;\n-\n-         Insert_And_Analyze (Decls,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => FM_Id,\n-             Object_Definition   =>\n-               New_Occurrence_Of (RTE (RE_Finalization_Master), Loc)));\n-\n-         --  Step 2: Initialization actions\n-\n-         --  Generate:\n-         --    Set_Base_Pool\n-         --      (<FM_Id>, Global_Pool_Object'Unrestricted_Access);\n-\n-         Insert_And_Analyze (Decls,\n-           Make_Procedure_Call_Statement (Loc,\n-             Name                   =>\n-               New_Occurrence_Of (RTE (RE_Set_Base_Pool), Loc),\n-             Parameter_Associations => New_List (\n-               New_Occurrence_Of (FM_Id, Loc),\n-               Make_Attribute_Reference (Loc,\n-                 Prefix         =>\n-                   New_Occurrence_Of (RTE (RE_Global_Pool_Object), Loc),\n-                 Attribute_Name => Name_Unrestricted_Access))));\n-\n-         --  Generate:\n-         --    Set_Is_Heterogeneous (<FM_Id>);\n-\n-         Insert_And_Analyze (Decls,\n-           Make_Procedure_Call_Statement (Loc,\n-             Name                   =>\n-               New_Occurrence_Of (RTE (RE_Set_Is_Heterogeneous), Loc),\n-             Parameter_Associations => New_List (\n-               New_Occurrence_Of (FM_Id, Loc))));\n-\n-         Pop_Scope;\n-         return FM_Id;\n-      end Create_Anonymous_Master;\n-\n-      --  Local declarations\n-\n-      Unit_Decl : Node_Id;\n-      Unit_Id   : Entity_Id;\n-\n-   --  Start of processing for Current_Anonymous_Master\n-\n-   begin\n-      Unit_Decl := Unit (Cunit (Current_Sem_Unit));\n-      Unit_Id   := Defining_Entity (Unit_Decl);\n-\n-      --  The compilation unit is a package instantiation. In this case the\n-      --  anonymous master is associated with the package spec as both the\n-      --  spec and body appear at the same level.\n-\n-      if Nkind (Unit_Decl) = N_Package_Body\n-        and then Nkind (Original_Node (Unit_Decl)) = N_Package_Instantiation\n-      then\n-         Unit_Id   := Corresponding_Spec (Unit_Decl);\n-         Unit_Decl := Unit_Declaration_Node (Unit_Id);\n-      end if;\n-\n-      if Present (Anonymous_Master (Unit_Id)) then\n-         return Anonymous_Master (Unit_Id);\n-\n-      --  Create a new anonymous master when allocating an object of anonymous\n-      --  access-to-controlled type for the first time.\n-\n-      else\n-         return Create_Anonymous_Master (Unit_Id, Unit_Decl);\n-      end if;\n-   end Current_Anonymous_Master;\n-\n    --------------------------------\n    -- Displace_Allocator_Pointer --\n    --------------------------------\n@@ -4296,8 +4092,7 @@ package body Exp_Ch4 is\n             Set_Finalization_Master\n               (Root_Type (PtrT), Finalization_Master (Rel_Typ));\n          else\n-            Set_Finalization_Master\n-              (Root_Type (PtrT), Current_Anonymous_Master);\n+            Build_Anonymous_Master (Root_Type (PtrT));\n          end if;\n       end if;\n "}, {"sha": "ad68f898f6c8ef577d7c6dc94a8eebeb773d9e12", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=32b794c81a5712113fe4245ec917abf6603158e6", "patch": "@@ -422,11 +422,7 @@ package body Exp_Ch6 is\n                if Ekind (Ptr_Typ) = E_Anonymous_Access_Type\n                  and then No (Finalization_Master (Ptr_Typ))\n                then\n-                  Build_Finalization_Master\n-                    (Typ            => Ptr_Typ,\n-                     For_Anonymous  => True,\n-                     Context_Scope  => Scope (Ptr_Typ),\n-                     Insertion_Node => Associated_Node_For_Itype (Ptr_Typ));\n+                  Build_Anonymous_Master (Ptr_Typ);\n                end if;\n \n                --  Access-to-controlled types should always have a master"}, {"sha": "8f498accf7956fca90ede9e34380894ec0d2cd12", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 346, "deletions": 97, "changes": 443, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=32b794c81a5712113fe4245ec917abf6603158e6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -301,6 +301,9 @@ package body Exp_Ch7 is\n                      Finalize_Case   => TSS_Deep_Finalize,\n                      Address_Case    => TSS_Finalize_Address);\n \n+   function Allows_Finalization_Master (Typ : Entity_Id) return Boolean;\n+   --  Determine whether access type Typ may have a finalization master\n+\n    procedure Build_Array_Deep_Procs (Typ : Entity_Id);\n    --  Build the deep Initialize/Adjust/Finalize for a record Typ with\n    --  Has_Controlled_Component set and store them using the TSS mechanism.\n@@ -427,6 +430,332 @@ package body Exp_Ch7 is\n    --       [Deep_]Finalize (Acc_Typ (V).all);\n    --    end;\n \n+   --------------------------------\n+   -- Allows_Finalization_Master --\n+   --------------------------------\n+\n+   function Allows_Finalization_Master (Typ : Entity_Id) return Boolean is\n+      function In_Deallocation_Instance (E : Entity_Id) return Boolean;\n+      --  Determine whether entity E is inside a wrapper package created for\n+      --  an instance of Ada.Unchecked_Deallocation.\n+\n+      ------------------------------\n+      -- In_Deallocation_Instance --\n+      ------------------------------\n+\n+      function In_Deallocation_Instance (E : Entity_Id) return Boolean is\n+         Pkg : constant Entity_Id := Scope (E);\n+         Par : Node_Id := Empty;\n+\n+      begin\n+         if Ekind (Pkg) = E_Package\n+           and then Present (Related_Instance (Pkg))\n+           and then Ekind (Related_Instance (Pkg)) = E_Procedure\n+         then\n+            Par := Generic_Parent (Parent (Related_Instance (Pkg)));\n+\n+            return\n+              Present (Par)\n+                and then Chars (Par) = Name_Unchecked_Deallocation\n+                and then Chars (Scope (Par)) = Name_Ada\n+                and then Scope (Scope (Par)) = Standard_Standard;\n+         end if;\n+\n+         return False;\n+      end In_Deallocation_Instance;\n+\n+      --  Local variables\n+\n+      Desig_Typ : constant Entity_Id := Designated_Type (Typ);\n+      Ptr_Typ   : constant Entity_Id :=\n+                    Root_Type_Of_Full_View (Base_Type (Typ));\n+\n+   --  Start of processing for Allows_Finalization_Master\n+\n+   begin\n+      --  Certain run-time configurations and targets do not provide support\n+      --  for controlled types and therefore do not need masters.\n+\n+      if Restriction_Active (No_Finalization) then\n+         return False;\n+\n+      --  Do not consider C and C++ types since it is assumed that the non-Ada\n+      --  side will handle their clean up.\n+\n+      elsif Convention (Desig_Typ) = Convention_C\n+        or else Convention (Desig_Typ) = Convention_CPP\n+      then\n+         return False;\n+\n+      --  Do not consider types that return on the secondary stack\n+\n+      elsif Present (Associated_Storage_Pool (Ptr_Typ))\n+        and then Is_RTE (Associated_Storage_Pool (Ptr_Typ), RE_SS_Pool)\n+      then\n+         return False;\n+\n+      --  Do not consider types which may never allocate an object\n+\n+      elsif No_Pool_Assigned (Ptr_Typ) then\n+         return False;\n+\n+      --  Do not consider access types coming from Ada.Unchecked_Deallocation\n+      --  instances. Even though the designated type may be controlled, the\n+      --  access type will never participate in allocation.\n+\n+      elsif In_Deallocation_Instance (Ptr_Typ) then\n+         return False;\n+\n+      --  Do not consider non-library access types when restriction\n+      --  No_Nested_Finalization is in effect since masters are controlled\n+      --  objects.\n+\n+      elsif Restriction_Active (No_Nested_Finalization)\n+        and then not Is_Library_Level_Entity (Ptr_Typ)\n+      then\n+         return False;\n+\n+      --  Do not create finalization masters in GNATprove mode because this\n+      --  causes unwanted extra expansion. A compilation in this mode must\n+      --  keep the tree as close as possible to the original sources.\n+\n+      elsif GNATprove_Mode then\n+         return False;\n+\n+      --  Otherwise the access type may use a finalization master\n+\n+      else\n+         return True;\n+      end if;\n+   end Allows_Finalization_Master;\n+\n+   ----------------------------\n+   -- Build_Anonymous_Master --\n+   ----------------------------\n+\n+   procedure Build_Anonymous_Master (Ptr_Typ : Entity_Id) is\n+      function Create_Anonymous_Master\n+        (Desig_Typ : Entity_Id;\n+         Unit_Id   : Entity_Id;\n+         Unit_Decl : Node_Id) return Entity_Id;\n+      --  Create a new anonymous finalization master for access type Ptr_Typ\n+      --  with designated type Desig_Typ. The declaration of the master along\n+      --  with its specialized initialization is inserted in the declarative\n+      --  part of unit Unit_Decl. Unit_Id denotes the entity of Unit_Decl.\n+\n+      function In_Subtree (N : Node_Id; Root : Node_Id) return Boolean;\n+      --  Determine whether arbitrary node N appears within the subtree rooted\n+      --  at node Root.\n+\n+      -----------------------------\n+      -- Create_Anonymous_Master --\n+      -----------------------------\n+\n+      function Create_Anonymous_Master\n+        (Desig_Typ : Entity_Id;\n+         Unit_Id   : Entity_Id;\n+         Unit_Decl : Node_Id) return Entity_Id\n+      is\n+         Loc       : constant Source_Ptr := Sloc (Unit_Id);\n+         Spec_Id   : constant Entity_Id  := Unique_Defining_Entity (Unit_Decl);\n+         Decls     : List_Id;\n+         FM_Decl   : Node_Id;\n+         FM_Id     : Entity_Id;\n+         FM_Init   : Node_Id;\n+         Pref      : Character;\n+         Unit_Spec : Node_Id;\n+\n+      begin\n+         --  Find the declarative list of the unit\n+\n+         if Nkind (Unit_Decl) = N_Package_Declaration then\n+            Unit_Spec := Specification (Unit_Decl);\n+            Decls     := Visible_Declarations (Unit_Spec);\n+\n+            if No (Decls) then\n+               Decls := New_List;\n+               Set_Visible_Declarations (Unit_Spec, Decls);\n+            end if;\n+\n+         --  Package body or subprogram case\n+\n+         --  ??? A subprogram spec or body that acts as a compilation unit may\n+         --  contain a formal parameter of an anonymous access-to-controlled\n+         --  type initialized by an allocator.\n+\n+         --    procedure Comp_Unit_Proc (Param : access Ctrl := new Ctrl);\n+\n+         --  There is no suitable place to create the anonymous master as the\n+         --  subprogram is not in a declarative list.\n+\n+         else\n+            Decls := Declarations (Unit_Decl);\n+\n+            if No (Decls) then\n+               Decls := New_List;\n+               Set_Declarations (Unit_Decl, Decls);\n+            end if;\n+         end if;\n+\n+         --  Step 1: Anonymous master creation\n+\n+         --  Use a unique prefix in case the same unit requires two anonymous\n+         --  masters, one for the spec (S) and one for the body (B).\n+\n+         if Ekind_In (Unit_Id, E_Function, E_Package, E_Procedure) then\n+            Pref := 'S';\n+         else\n+            Pref := 'B';\n+         end if;\n+\n+         --  The name of the anonymous master has the following format:\n+\n+         --    [BS]scopN__scop1__chars_of_desig_typAM\n+\n+         --  The name utilizes the fully qualified name of the designated type\n+         --  in case two controlled types with the same name are declared in\n+         --  different scopes and both have anonymous access types.\n+\n+         FM_Id :=\n+           Make_Defining_Identifier (Loc,\n+             New_External_Name\n+               (Related_Id => Get_Qualified_Name (Desig_Typ),\n+                Suffix     => \"AM\",\n+                Prefix     => Pref));\n+\n+         --  Associate the anonymous master with the designated type. This\n+         --  ensures that any additional anonymous access types with the same\n+         --  designated type will share the same anonymous paster within the\n+         --  same unit.\n+\n+         Set_Anonymous_Master (Desig_Typ, FM_Id);\n+\n+         --  Generate:\n+         --    <FM_Id> : Finalization_Master;\n+\n+         FM_Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => FM_Id,\n+             Object_Definition   =>\n+               New_Occurrence_Of (RTE (RE_Finalization_Master), Loc));\n+\n+         --  Step 2: Initialization actions\n+\n+         --  Generate:\n+         --    Set_Base_Pool\n+         --      (<FM_Id>, Global_Pool_Object'Unrestricted_Access);\n+\n+         FM_Init :=\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   =>\n+               New_Occurrence_Of (RTE (RE_Set_Base_Pool), Loc),\n+             Parameter_Associations => New_List (\n+               New_Occurrence_Of (FM_Id, Loc),\n+               Make_Attribute_Reference (Loc,\n+                 Prefix         =>\n+                   New_Occurrence_Of (RTE (RE_Global_Pool_Object), Loc),\n+                 Attribute_Name => Name_Unrestricted_Access)));\n+\n+         Prepend_To (Decls, FM_Init);\n+         Prepend_To (Decls, FM_Decl);\n+\n+         --  Since the anonymous master and all its initialization actions are\n+         --  inserted at top level, use the scope of the unit when analyzing.\n+\n+         Push_Scope (Spec_Id);\n+         Analyze (FM_Decl);\n+         Analyze (FM_Init);\n+         Pop_Scope;\n+\n+         return FM_Id;\n+      end Create_Anonymous_Master;\n+\n+      ----------------\n+      -- In_Subtree --\n+      ----------------\n+\n+      function In_Subtree (N : Node_Id; Root : Node_Id) return Boolean is\n+         Par : Node_Id;\n+\n+      begin\n+         --  Traverse the parent chain until reaching the same root\n+\n+         Par := N;\n+         while Present (Par) loop\n+            if Par = Root then\n+               return True;\n+            end if;\n+\n+            Par := Parent (Par);\n+         end loop;\n+\n+         return False;\n+      end In_Subtree;\n+\n+      --  Local variables\n+\n+      Desig_Typ : Entity_Id;\n+      FM_Id     : Entity_Id;\n+      Priv_View : Entity_Id;\n+      Unit_Decl : Node_Id;\n+      Unit_Id   : Entity_Id;\n+\n+   --  Start of processing for Build_Anonymous_Master\n+\n+   begin\n+      --  Nothing to do if the circumstances do not allow for a finalization\n+      --  master.\n+\n+      if not Allows_Finalization_Master (Ptr_Typ) then\n+         return;\n+      end if;\n+\n+      Unit_Decl := Unit (Cunit (Current_Sem_Unit));\n+      Unit_Id   := Defining_Entity (Unit_Decl);\n+\n+      --  The compilation unit is a package instantiation. In this case the\n+      --  anonymous master is associated with the package spec as both the\n+      --  spec and body appear at the same level.\n+\n+      if Nkind (Unit_Decl) = N_Package_Body\n+        and then Nkind (Original_Node (Unit_Decl)) = N_Package_Instantiation\n+      then\n+         Unit_Id   := Corresponding_Spec (Unit_Decl);\n+         Unit_Decl := Unit_Declaration_Node (Unit_Id);\n+      end if;\n+\n+      --  Use the initial declaration of the designated type when it denotes\n+      --  the full view of an incomplete or private type. This ensures that\n+      --  types with one and two views are treated the same.\n+\n+      Desig_Typ := Directly_Designated_Type (Ptr_Typ);\n+      Priv_View := Incomplete_Or_Partial_View (Desig_Typ);\n+\n+      if Present (Priv_View) then\n+         Desig_Typ := Priv_View;\n+      end if;\n+\n+      FM_Id := Anonymous_Master (Desig_Typ);\n+\n+      --  The designated type already has at least one anonymous access type\n+      --  pointing to it within the current unit. Reuse the anonymous master\n+      --  because the designated type is the same.\n+\n+      if Present (FM_Id)\n+        and then In_Subtree (Declaration_Node (FM_Id), Root => Unit_Decl)\n+      then\n+         null;\n+\n+      --  Otherwise the designated type lacks an anonymous master or it is\n+      --  declared in a different unit. Create a brand new master.\n+\n+      else\n+         FM_Id := Create_Anonymous_Master (Desig_Typ, Unit_Id, Unit_Decl);\n+      end if;\n+\n+      Set_Finalization_Master (Ptr_Typ, FM_Id);\n+   end Build_Anonymous_Master;\n+\n    ----------------------------\n    -- Build_Array_Deep_Procs --\n    ----------------------------\n@@ -762,7 +1091,6 @@ package body Exp_Ch7 is\n \n    procedure Build_Finalization_Master\n      (Typ            : Entity_Id;\n-      For_Anonymous  : Boolean   := False;\n       For_Lib_Level  : Boolean   := False;\n       For_Private    : Boolean   := False;\n       Context_Scope  : Entity_Id := Empty;\n@@ -773,10 +1101,6 @@ package body Exp_Ch7 is\n          Ptr_Typ : Entity_Id);\n       --  Add access type Ptr_Typ to the pending access type list for type Typ\n \n-      function In_Deallocation_Instance (E : Entity_Id) return Boolean;\n-      --  Determine whether entity E is inside a wrapper package created for\n-      --  an instance of Ada.Unchecked_Deallocation.\n-\n       -----------------------------\n       -- Add_Pending_Access_Type --\n       -----------------------------\n@@ -798,31 +1122,6 @@ package body Exp_Ch7 is\n          Prepend_Elmt (Ptr_Typ, List);\n       end Add_Pending_Access_Type;\n \n-      ------------------------------\n-      -- In_Deallocation_Instance --\n-      ------------------------------\n-\n-      function In_Deallocation_Instance (E : Entity_Id) return Boolean is\n-         Pkg : constant Entity_Id := Scope (E);\n-         Par : Node_Id := Empty;\n-\n-      begin\n-         if Ekind (Pkg) = E_Package\n-           and then Present (Related_Instance (Pkg))\n-           and then Ekind (Related_Instance (Pkg)) = E_Procedure\n-         then\n-            Par := Generic_Parent (Parent (Related_Instance (Pkg)));\n-\n-            return\n-              Present (Par)\n-                and then Chars (Par) = Name_Unchecked_Deallocation\n-                and then Chars (Scope (Par)) = Name_Ada\n-                and then Scope (Scope (Par)) = Standard_Standard;\n-         end if;\n-\n-         return False;\n-      end In_Deallocation_Instance;\n-\n       --  Local variables\n \n       Desig_Typ : constant Entity_Id := Designated_Type (Typ);\n@@ -836,67 +1135,17 @@ package body Exp_Ch7 is\n    --  Start of processing for Build_Finalization_Master\n \n    begin\n-      --  Certain run-time configurations and targets do not provide support\n-      --  for controlled types.\n-\n-      if Restriction_Active (No_Finalization) then\n-         return;\n+      --  Nothing to do if the circumstances do not allow for a finalization\n+      --  master.\n \n-      --  Do not process C, C++ types since it is assumed that the non-Ada side\n-      --  will handle their clean up.\n-\n-      elsif Convention (Desig_Typ) = Convention_C\n-        or else Convention (Desig_Typ) = Convention_CPP\n-      then\n+      if not Allows_Finalization_Master (Typ) then\n          return;\n \n       --  Various machinery such as freezing may have already created a\n       --  finalization master.\n \n       elsif Present (Finalization_Master (Ptr_Typ)) then\n          return;\n-\n-      --  Do not process types that return on the secondary stack\n-\n-      elsif Present (Associated_Storage_Pool (Ptr_Typ))\n-        and then Is_RTE (Associated_Storage_Pool (Ptr_Typ), RE_SS_Pool)\n-      then\n-         return;\n-\n-      --  Do not process types which may never allocate an object\n-\n-      elsif No_Pool_Assigned (Ptr_Typ) then\n-         return;\n-\n-      --  Do not process access types coming from Ada.Unchecked_Deallocation\n-      --  instances. Even though the designated type may be controlled, the\n-      --  access type will never participate in allocation.\n-\n-      elsif In_Deallocation_Instance (Ptr_Typ) then\n-         return;\n-\n-      --  Ignore the general use of anonymous access types unless the context\n-      --  requires a finalization master.\n-\n-      elsif Ekind (Ptr_Typ) = E_Anonymous_Access_Type\n-        and then not For_Anonymous\n-      then\n-         return;\n-\n-      --  Do not process non-library access types when restriction No_Nested_\n-      --  Finalization is in effect since masters are controlled objects.\n-\n-      elsif Restriction_Active (No_Nested_Finalization)\n-        and then not Is_Library_Level_Entity (Ptr_Typ)\n-      then\n-         return;\n-\n-      --  Do not create finalization masters in GNATprove mode because this\n-      --  unwanted extra expansion. A compilation in this mode keeps the tree\n-      --  as close as possible to the original sources.\n-\n-      elsif GNATprove_Mode then\n-         return;\n       end if;\n \n       declare\n@@ -1013,11 +1262,11 @@ package body Exp_Ch7 is\n             Add_Pending_Access_Type (Desig_Typ, Ptr_Typ);\n          end if;\n \n-         --  A finalization master created for an anonymous access type or an\n-         --  access designating a type with private components must be inserted\n-         --  before a context-dependent node.\n+         --  A finalization master created for an access designating a type\n+         --  with private components is inserted before a context-dependent\n+         --  node.\n \n-         if For_Anonymous or For_Private then\n+         if For_Private then\n \n             --  At this point both the scope of the context and the insertion\n             --  mode must be known.\n@@ -3693,15 +3942,6 @@ package body Exp_Ch7 is\n       end if;\n    end Check_Visibly_Controlled;\n \n-   -------------------------------\n-   -- CW_Or_Has_Controlled_Part --\n-   -------------------------------\n-\n-   function CW_Or_Has_Controlled_Part (T : Entity_Id) return Boolean is\n-   begin\n-      return Is_Class_Wide_Type (T) or else Needs_Finalization (T);\n-   end CW_Or_Has_Controlled_Part;\n-\n    ------------------\n    -- Convert_View --\n    ------------------\n@@ -3764,6 +4004,15 @@ package body Exp_Ch7 is\n       end if;\n    end Convert_View;\n \n+   -------------------------------\n+   -- CW_Or_Has_Controlled_Part --\n+   -------------------------------\n+\n+   function CW_Or_Has_Controlled_Part (T : Entity_Id) return Boolean is\n+   begin\n+      return Is_Class_Wide_Type (T) or else Needs_Finalization (T);\n+   end CW_Or_Has_Controlled_Part;\n+\n    ------------------------\n    -- Enclosing_Function --\n    ------------------------"}, {"sha": "3136934378115671abdf2c8b3b959b07fcaefcd8", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=32b794c81a5712113fe4245ec917abf6603158e6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,6 +35,11 @@ package Exp_Ch7 is\n    -- Finalization Management --\n    -----------------------------\n \n+   procedure Build_Anonymous_Master (Ptr_Typ : Entity_Id);\n+   --  Build a finalization master for an anonymous access-to-controlled type\n+   --  denoted by Ptr_Typ. The master is inserted in the declarations of the\n+   --  current unit.\n+\n    procedure Build_Controlling_Procs (Typ : Entity_Id);\n    --  Typ is a record, and array type having controlled components.\n    --  Create the procedures Deep_Initialize, Deep_Adjust and Deep_Finalize\n@@ -99,22 +104,19 @@ package Exp_Ch7 is\n \n    procedure Build_Finalization_Master\n      (Typ            : Entity_Id;\n-      For_Anonymous  : Boolean   := False;\n       For_Lib_Level  : Boolean   := False;\n       For_Private    : Boolean   := False;\n       Context_Scope  : Entity_Id := Empty;\n       Insertion_Node : Node_Id   := Empty);\n    --  Build a finalization master for an access type. The designated type may\n    --  not necessarely be controlled or need finalization actions depending on\n-   --  the context. Flag For_Anonymous must be set when creating a master for\n-   --  an anonymous access type. Flag For_Lib_Level must be set when creating\n-   --  a master for a build-in-place function call access result type. Flag\n-   --  For_Private must be set when the designated type contains a private\n-   --  component. Parameters Context_Scope and Insertion_Node must be used in\n-   --  conjunction with flags For_Anonymous and For_Private. Context_Scope is\n-   --  the scope of the context where the finalization master must be analyzed.\n-   --  Insertion_Node is the insertion point before which the master is to be\n-   --  inserted.\n+   --  the context. Flag For_Lib_Level must be set when creating a master for a\n+   --  build-in-place function call access result type. Flag For_Private must\n+   --  be set when the designated type contains a private component. Parameters\n+   --  Context_Scope and Insertion_Node must be used in conjunction with flag\n+   --  For_Private. Context_Scope is the scope of the context where the\n+   --  finalization master must be analyzed. Insertion_Node is the insertion\n+   --  point before which the master is to be inserted.\n \n    procedure Build_Late_Proc (Typ : Entity_Id; Nam : Name_Id);\n    --  Build one controlling procedure when a late body overrides one of"}, {"sha": "fdf8c8a086ab51ee283f3f723cb0317d2765a739", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=32b794c81a5712113fe4245ec917abf6603158e6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -180,6 +180,12 @@ procedure Gnat1drv is\n       if Operating_Mode = Check_Semantics and then Tree_Output then\n          ASIS_Mode := True;\n \n+         --  Set ASIS GNSA mode if -gnatd.H is set\n+\n+         if Debug_Flag_Dot_HH then\n+            ASIS_GNSA_Mode := True;\n+         end if;\n+\n          --  Turn off inlining in ASIS mode, since ASIS cannot handle the extra\n          --  information in the trees caused by inlining being active.\n \n@@ -1054,7 +1060,7 @@ begin\n       if GNATprove_Mode then\n          declare\n             Unused_E : constant Entity_Id :=\n-              Rtsfind.RTE (Rtsfind.RE_Interrupt_Priority);\n+                         Rtsfind.RTE (Rtsfind.RE_Interrupt_Priority);\n          begin\n             null;\n          end;\n@@ -1176,13 +1182,11 @@ begin\n       --  We can generate code for a package declaration or a subprogram\n       --  declaration only if it does not required a body.\n \n-      elsif Nkind_In (Main_Kind,\n-              N_Package_Declaration,\n-              N_Subprogram_Declaration)\n+      elsif Nkind_In (Main_Kind, N_Package_Declaration,\n+                                 N_Subprogram_Declaration)\n         and then\n           (not Body_Required (Main_Unit_Node)\n-             or else\n-           Distribution_Stub_Mode = Generate_Caller_Stub_Body)\n+             or else Distribution_Stub_Mode = Generate_Caller_Stub_Body)\n       then\n          Back_End_Mode := Generate_Object;\n \n@@ -1247,8 +1251,7 @@ begin\n \n       if Back_End_Mode = Skip then\n          Set_Standard_Error;\n-         Write_Str (\"cannot generate code for \");\n-         Write_Str (\"file \");\n+         Write_Str (\"cannot generate code for file \");\n          Write_Name (Unit_File_Name (Main_Unit));\n \n          if Subunits_Missing then\n@@ -1320,11 +1323,16 @@ begin\n       --  Annotation is suppressed for targets where front-end layout is\n       --  enabled, because the front end determines representations.\n \n+      --  The back-end is not invoked in ASIS mode with GNSA because all type\n+      --  representation information will be provided by the GNSA back-end, not\n+      --  gigi.\n+\n       if Back_End_Mode = Declarations_Only\n         and then\n           (not (Back_Annotate_Rep_Info or Generate_SCIL or GNATprove_Mode)\n             or else Main_Kind = N_Subunit\n-            or else Frontend_Layout_On_Target)\n+            or else Frontend_Layout_On_Target\n+            or else ASIS_GNSA_Mode)\n       then\n          Post_Compilation_Validation_Checks;\n          Errout.Finalize (Last_Call => True);"}, {"sha": "402a9e50e5e1425cde19f0f4dcd24b533229fe4a", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=32b794c81a5712113fe4245ec917abf6603158e6", "patch": "@@ -208,6 +208,11 @@ package Opt is\n    --  Set to non-null when Bind_Alternate_Main_Name is True. This value\n    --  is modified as needed by Gnatbind.Scan_Bind_Arg.\n \n+   ASIS_GNSA_Mode : Boolean := False;\n+   --  GNAT\n+   --  Enable GNSA back-end processing assuming ASIS_Mode is already set to\n+   --  True. ASIS_GNSA mode suppresses the call to gigi.\n+\n    ASIS_Mode : Boolean := False;\n    --  GNAT\n    --  Enable semantic checks and tree transformations that are important"}, {"sha": "8f078fd561ab813a1fa9b4f0900d5fbf9d0fb487", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 126, "deletions": 67, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=32b794c81a5712113fe4245ec917abf6603158e6", "patch": "@@ -4758,9 +4758,8 @@ package body Sem_Ch13 is\n             elsif Is_Subprogram (U_Ent) then\n                if Has_Homonym (U_Ent) then\n                   Error_Msg_N\n-                    (\"address clause cannot be given \" &\n-                     \"for overloaded subprogram\",\n-                     Nam);\n+                    (\"address clause cannot be given for overloaded \"\n+                     & \"subprogram\", Nam);\n                   return;\n                end if;\n \n@@ -4802,8 +4801,8 @@ package body Sem_Ch13 is\n \n                if Warn_On_Obsolescent_Feature then\n                   Error_Msg_N\n-                    (\"?j?attaching interrupt to task entry is an \" &\n-                     \"obsolescent feature (RM J.7.1)\", N);\n+                    (\"?j?attaching interrupt to task entry is an obsolescent \"\n+                     & \"feature (RM J.7.1)\", N);\n                   Error_Msg_N\n                     (\"\\?j?use interrupt procedure instead\", N);\n                end if;\n@@ -5022,12 +5021,17 @@ package body Sem_Ch13 is\n                Set_Has_Alignment_Clause (U_Ent);\n \n                --  Tagged type case, check for attempt to set alignment to a\n-               --  value greater than Max_Align, and reset if so.\n+               --  value greater than Max_Align, and reset if so. This error\n+               --  is suppressed in ASIS mode to allow for different ASIS\n+               --  back-ends or ASIS-based tools to query the illegal clause.\n \n-               if Is_Tagged_Type (U_Ent) and then Align > Max_Align then\n+               if Is_Tagged_Type (U_Ent)\n+                 and then Align > Max_Align\n+                 and then not ASIS_Mode\n+               then\n                   Error_Msg_N\n                     (\"alignment for & set to Maximum_Aligment??\", Nam);\n-                     Set_Alignment (U_Ent, Max_Align);\n+                  Set_Alignment (U_Ent, Max_Align);\n \n                --  All other cases\n \n@@ -5100,7 +5104,7 @@ package body Sem_Ch13 is\n             end if;\n \n             Btype := Base_Type (U_Ent);\n-            Ctyp := Component_Type (Btype);\n+            Ctyp  := Component_Type (Btype);\n \n             if Duplicate_Clause then\n                null;\n@@ -5324,8 +5328,8 @@ package body Sem_Ch13 is\n                   Error_Msg_NE\n                     (\"??non-unique external tag supplied for &\", N, U_Ent);\n                   Error_Msg_N\n-                       (\"\\??same external tag applies to all \"\n-                        & \"subprogram calls\", N);\n+                    (\"\\??same external tag applies to all subprogram calls\",\n+                     N);\n                   Error_Msg_N\n                     (\"\\??corresponding internal tag cannot be obtained\", N);\n                end if;\n@@ -5363,8 +5367,8 @@ package body Sem_Ch13 is\n             if From_Aspect_Specification (N) then\n                if not Is_Concurrent_Type (U_Ent) then\n                   Error_Msg_N\n-                    (\"Interrupt_Priority can only be defined for task \"\n-                     & \"and protected object\", Nam);\n+                    (\"Interrupt_Priority can only be defined for task and \"\n+                     & \"protected object\", Nam);\n \n                elsif Duplicate_Clause then\n                   null;\n@@ -5456,9 +5460,15 @@ package body Sem_Ch13 is\n \n                if Radix = 2 then\n                   null;\n+\n                elsif Radix = 10 then\n                   Set_Machine_Radix_10 (U_Ent);\n-               else\n+\n+               --  The following error is suppressed in ASIS mode to allow for\n+               --  different ASIS back-ends or ASIS-based tools to query the\n+               --  illegal clause.\n+\n+               elsif not ASIS_Mode then\n                   Error_Msg_N (\"machine radix value must be 2 or 10\", Expr);\n                end if;\n             end if;\n@@ -5486,7 +5496,14 @@ package body Sem_Ch13 is\n             else\n                Check_Size (Expr, U_Ent, Size, Biased);\n \n-               if Is_Scalar_Type (U_Ent) then\n+               --  The following errors are suppressed in ASIS mode to allow\n+               --  for different ASIS back-ends or ASIS-based tools to query\n+               --  the illegal clause.\n+\n+               if ASIS_Mode then\n+                  null;\n+\n+               elsif Is_Scalar_Type (U_Ent) then\n                   if Size /= 8 and then Size /= 16 and then Size /= 32\n                     and then UI_Mod (Size, 64) /= 0\n                   then\n@@ -5573,8 +5590,8 @@ package body Sem_Ch13 is\n          begin\n             if not (Is_Record_Type (U_Ent) or else Is_Array_Type (U_Ent)) then\n                Error_Msg_N\n-                 (\"Scalar_Storage_Order can only be defined for \"\n-                  & \"record or array type\", Nam);\n+                 (\"Scalar_Storage_Order can only be defined for record or \"\n+                  & \"array type\", Nam);\n \n             elsif Duplicate_Clause then\n                null;\n@@ -5598,8 +5615,8 @@ package body Sem_Ch13 is\n                      Set_Reverse_Storage_Order (Base_Type (U_Ent), True);\n                   else\n                      Error_Msg_N\n-                       (\"non-default Scalar_Storage_Order \"\n-                        & \"not supported on target\", Expr);\n+                       (\"non-default Scalar_Storage_Order not supported on \"\n+                        & \"target\", Expr);\n                   end if;\n                end if;\n \n@@ -5696,21 +5713,22 @@ package body Sem_Ch13 is\n                --  For objects, set Esize only\n \n                else\n-                  if Is_Elementary_Type (Etyp) then\n-                     if Size /= System_Storage_Unit\n-                          and then\n-                        Size /= System_Storage_Unit * 2\n-                          and then\n-                        Size /= System_Storage_Unit * 4\n-                           and then\n-                        Size /= System_Storage_Unit * 8\n-                     then\n-                        Error_Msg_Uint_1 := UI_From_Int (System_Storage_Unit);\n-                        Error_Msg_Uint_2 := Error_Msg_Uint_1 * 8;\n-                        Error_Msg_N\n-                          (\"size for primitive object must be a power of 2\"\n-                            & \" in the range ^-^\", N);\n-                     end if;\n+                  --  The following error is suppressed in ASIS mode to allow\n+                  --  for different ASIS back-ends or ASIS-based tools to query\n+                  --  the illegal clause.\n+\n+                  if Is_Elementary_Type (Etyp)\n+                    and then Size /= System_Storage_Unit\n+                    and then Size /= System_Storage_Unit * 2\n+                    and then Size /= System_Storage_Unit * 4\n+                    and then Size /= System_Storage_Unit * 8\n+                    and then not ASIS_Mode\n+                  then\n+                     Error_Msg_Uint_1 := UI_From_Int (System_Storage_Unit);\n+                     Error_Msg_Uint_2 := Error_Msg_Uint_1 * 8;\n+                     Error_Msg_N\n+                       (\"size for primitive object must be a power of 2 in \"\n+                        & \"the range ^-^\", N);\n                   end if;\n \n                   Set_Esize (U_Ent, Size);\n@@ -5955,8 +5973,8 @@ package body Sem_Ch13 is\n \n                   if Warn_On_Obsolescent_Feature then\n                      Error_Msg_N\n-                       (\"?j?storage size clause for task is an \" &\n-                        \"obsolescent feature (RM J.9)\", N);\n+                       (\"?j?storage size clause for task is an obsolescent \"\n+                        & \"feature (RM J.9)\", N);\n                      Error_Msg_N (\"\\?j?use Storage_Size pragma instead\", N);\n                   end if;\n                end if;\n@@ -6024,24 +6042,29 @@ package body Sem_Ch13 is\n                null;\n \n             elsif Is_Elementary_Type (U_Ent) then\n-               if Size /= System_Storage_Unit\n-                    and then\n-                  Size /= System_Storage_Unit * 2\n-                    and then\n-                  Size /= System_Storage_Unit * 4\n-                     and then\n-                  Size /= System_Storage_Unit * 8\n+\n+               --  The following errors are suppressed in ASIS mode to allow\n+               --  for different ASIS back-ends or ASIS-based tools to query\n+               --  the illegal clause.\n+\n+               if ASIS_Mode then\n+                  null;\n+\n+               elsif Size /= System_Storage_Unit\n+                 and then Size /= System_Storage_Unit * 2\n+                 and then Size /= System_Storage_Unit * 4\n+                 and then Size /= System_Storage_Unit * 8\n                then\n                   Error_Msg_Uint_1 := UI_From_Int (System_Storage_Unit);\n                   Error_Msg_N\n-                    (\"stream size for elementary type must be a\"\n-                       & \" power of 2 and at least ^\", N);\n+                    (\"stream size for elementary type must be a power of 2 \"\n+                     & \"and at least ^\", N);\n \n                elsif RM_Size (U_Ent) > Size then\n                   Error_Msg_Uint_1 := RM_Size (U_Ent);\n                   Error_Msg_N\n-                    (\"stream size for elementary type must be a\"\n-                       & \" power of 2 and at least ^\", N);\n+                    (\"stream size for elementary type must be a power of 2 \"\n+                     & \"and at least ^\", N);\n                end if;\n \n                Set_Has_Stream_Size_Clause (U_Ent);\n@@ -6787,12 +6810,10 @@ package body Sem_Ch13 is\n               and then Lbit /= No_Uint\n             then\n                if Posit < 0 then\n-                  Error_Msg_N\n-                    (\"position cannot be negative\", Position (CC));\n+                  Error_Msg_N (\"position cannot be negative\", Position (CC));\n \n                elsif Fbit < 0 then\n-                  Error_Msg_N\n-                    (\"first bit cannot be negative\", First_Bit (CC));\n+                  Error_Msg_N (\"first bit cannot be negative\", First_Bit (CC));\n \n                --  The Last_Bit specified in a component clause must not be\n                --  less than the First_Bit minus one (RM-13.5.1(10)).\n@@ -6885,8 +6906,8 @@ package body Sem_Ch13 is\n                                                    Intval (Last_Bit (CC))\n                            then\n                               Error_Msg_N\n-                                (\"component clause inconsistent \"\n-                                 & \"with representation of ancestor\", CC);\n+                                (\"component clause inconsistent with \"\n+                                 & \"representation of ancestor\", CC);\n \n                            elsif Warn_On_Redundant_Constructs then\n                               Error_Msg_N\n@@ -10870,13 +10891,36 @@ package body Sem_Ch13 is\n       Siz    : Uint;\n       Biased : out Boolean)\n    is\n+      procedure Size_Too_Small_Error (Min_Siz : Uint);\n+      --  Emit an error concerning illegal size Siz. Min_Siz denotes the\n+      --  minimum size.\n+\n+      --------------------------\n+      -- Size_Too_Small_Error --\n+      --------------------------\n+\n+      procedure Size_Too_Small_Error (Min_Siz : Uint) is\n+      begin\n+         --  This error is suppressed in ASIS mode to allow for different ASIS\n+         --  back-ends or ASIS-based tools to query the illegal clause.\n+\n+         if not ASIS_Mode then\n+            Error_Msg_Uint_1 := Min_Siz;\n+            Error_Msg_NE (\"size for & too small, minimum allowed is ^\", N, T);\n+         end if;\n+      end Size_Too_Small_Error;\n+\n+      --  Local variables\n+\n       UT : constant Entity_Id := Underlying_Type (T);\n       M  : Uint;\n \n+   --  Start of processing for Check_Size\n+\n    begin\n       Biased := False;\n \n-      --  Reject patently improper size values.\n+      --  Reject patently improper size values\n \n       if Is_Elementary_Type (T)\n         and then Siz > UI_From_Int (Int'Last)\n@@ -10945,9 +10989,7 @@ package body Sem_Ch13 is\n                return;\n \n             else\n-               Error_Msg_Uint_1 := Asiz;\n-               Error_Msg_NE\n-                 (\"size for& too small, minimum allowed is ^\", N, T);\n+               Size_Too_Small_Error (Asiz);\n                Set_Esize   (T, Asiz);\n                Set_RM_Size (T, Asiz);\n             end if;\n@@ -10962,9 +11004,7 @@ package body Sem_Ch13 is\n       --  since we don't know all the characteristics of the type that can\n       --  affect the size (e.g. a specified small) till freeze time.\n \n-      elsif Is_Fixed_Point_Type (UT)\n-        and then not Is_Frozen (UT)\n-      then\n+      elsif Is_Fixed_Point_Type (UT) and then not Is_Frozen (UT) then\n          null;\n \n       --  Cases for which a minimum check is required\n@@ -10988,10 +11028,8 @@ package body Sem_Ch13 is\n             M := UI_From_Int (Minimum_Size (UT, Biased => True));\n \n             if Siz < M then\n-               Error_Msg_Uint_1 := M;\n-               Error_Msg_NE\n-                 (\"size for& too small, minimum allowed is ^\", N, T);\n-               Set_Esize (T, M);\n+               Size_Too_Small_Error (M);\n+               Set_Esize   (T, M);\n                Set_RM_Size (T, M);\n             else\n                Biased := True;\n@@ -11513,14 +11551,36 @@ package body Sem_Ch13 is\n    -------------------------\n \n    function Get_Alignment_Value (Expr : Node_Id) return Uint is\n+      procedure Alignment_Error;\n+      --  Issue an error concerning a negatize or zero alignment represented by\n+      --  expression Expr.\n+\n+      ---------------------\n+      -- Alignment_Error --\n+      ---------------------\n+\n+      procedure Alignment_Error is\n+      begin\n+         --  This error is suppressed in ASIS mode to allow for different ASIS\n+         --  back-ends or ASIS-based tools to query the illegal clause.\n+\n+         if not ASIS_Mode then\n+            Error_Msg_N (\"alignment value must be positive\", Expr);\n+         end if;\n+      end Alignment_Error;\n+\n+      --  Local variables\n+\n       Align : constant Uint := Static_Integer (Expr);\n \n+   --  Start of processing for Get_Alignment_Value\n+\n    begin\n       if Align = No_Uint then\n          return No_Uint;\n \n       elsif Align <= 0 then\n-         Error_Msg_N (\"alignment value must be positive\", Expr);\n+         Alignment_Error;\n          return No_Uint;\n \n       else\n@@ -11532,8 +11592,7 @@ package body Sem_Ch13 is\n                exit when M = Align;\n \n                if M > Align then\n-                  Error_Msg_N\n-                    (\"alignment value must be power of 2\", Expr);\n+                  Alignment_Error;\n                   return No_Uint;\n                end if;\n             end;"}, {"sha": "46079c5f6e9a282a63b5f89b7aca4fc72842556f", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=32b794c81a5712113fe4245ec917abf6603158e6", "patch": "@@ -3560,9 +3560,7 @@ package body Sem_Ch3 is\n \n       --  Special checks for protected objects not at library level\n \n-      if Is_Protected_Type (T)\n-        and then not Is_Library_Level_Entity (Id)\n-      then\n+      if Has_Protected (T) and then not Is_Library_Level_Entity (Id) then\n          Check_Restriction (No_Local_Protected_Objects, Id);\n \n          --  Protected objects with interrupt handlers must be at library level\n@@ -3574,7 +3572,10 @@ package body Sem_Ch3 is\n          --  AI05-0303: The AI is in fact a binding interpretation, and thus\n          --  applies to the '95 version of the language as well.\n \n-         if Has_Interrupt_Handler (T) and then Ada_Version < Ada_95 then\n+         if Is_Protected_Type (T)\n+           and then Has_Interrupt_Handler (T)\n+           and then Ada_Version < Ada_95\n+         then\n             Error_Msg_N\n               (\"interrupt object can only be declared at library level\", Id);\n          end if;"}, {"sha": "371c14733c53de343516edf7f55044e62ba2d8d1", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 73, "deletions": 32, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=32b794c81a5712113fe4245ec917abf6603158e6", "patch": "@@ -8322,6 +8322,73 @@ package body Sem_Util is\n       return Get_Pragma_Id (Pragma_Name (N));\n    end Get_Pragma_Id;\n \n+   ------------------------\n+   -- Get_Qualified_Name --\n+   ------------------------\n+\n+   function Get_Qualified_Name\n+     (Id     : Entity_Id;\n+      Suffix : Entity_Id := Empty) return Name_Id\n+   is\n+      Suffix_Nam : Name_Id := No_Name;\n+\n+   begin\n+      if Present (Suffix) then\n+         Suffix_Nam := Chars (Suffix);\n+      end if;\n+\n+      return Get_Qualified_Name (Chars (Id), Suffix_Nam, Scope (Id));\n+   end Get_Qualified_Name;\n+\n+   function Get_Qualified_Name\n+     (Nam    : Name_Id;\n+      Suffix : Name_Id   := No_Name;\n+      Scop   : Entity_Id := Current_Scope) return Name_Id\n+   is\n+      procedure Add_Scope (S : Entity_Id);\n+      --  Add the fully qualified form of scope S to the name buffer. The\n+      --  format is:\n+      --    s-1__s__\n+\n+      ---------------\n+      -- Add_Scope --\n+      ---------------\n+\n+      procedure Add_Scope (S : Entity_Id) is\n+      begin\n+         if S = Empty then\n+            null;\n+\n+         elsif S = Standard_Standard then\n+            null;\n+\n+         else\n+            Add_Scope (Scope (S));\n+            Get_Name_String_And_Append (Chars (S));\n+            Add_Str_To_Name_Buffer (\"__\");\n+         end if;\n+      end Add_Scope;\n+\n+   --  Start of processing for Get_Qualified_Name\n+\n+   begin\n+      Name_Len := 0;\n+      Add_Scope (Scop);\n+\n+      --  Append the base name after all scopes have been chained\n+\n+      Get_Name_String_And_Append (Nam);\n+\n+      --  Append the suffix (if present)\n+\n+      if Suffix /= No_Name then\n+         Add_Str_To_Name_Buffer (\"__\");\n+         Get_Name_String_And_Append (Suffix);\n+      end if;\n+\n+      return Name_Find;\n+   end Get_Qualified_Name;\n+\n    -----------------------\n    -- Get_Reason_String --\n    -----------------------\n@@ -17762,39 +17829,13 @@ package body Sem_Util is\n    -----------------\n \n    procedure Output_Name (Nam : Name_Id; Scop : Entity_Id := Current_Scope) is\n-      procedure Output_Scope (S : Entity_Id);\n-      --  Add the fully qualified form of scope S to the name buffer. The\n-      --  qualification format is:\n-      --    scope1__scopeN__\n-\n-      ------------------\n-      -- Output_Scope --\n-      ------------------\n-\n-      procedure Output_Scope (S : Entity_Id) is\n-      begin\n-         if S = Empty then\n-            null;\n-\n-         elsif S = Standard_Standard then\n-            null;\n-\n-         else\n-            Output_Scope (Scope (S));\n-            Add_Str_To_Name_Buffer (Get_Name_String (Chars (S)));\n-            Add_Str_To_Name_Buffer (\"__\");\n-         end if;\n-      end Output_Scope;\n-\n-   --  Start of processing for Output_Name\n-\n    begin\n-      Name_Len := 0;\n-      Output_Scope (Scop);\n-\n-      Add_Str_To_Name_Buffer (Get_Name_String (Nam));\n-\n-      Write_Str (Name_Buffer (1 .. Name_Len));\n+      Write_Str\n+        (Get_Name_String\n+          (Get_Qualified_Name\n+            (Nam    => Nam,\n+             Suffix => No_Name,\n+             Scop   => Scop)));\n       Write_Eol;\n    end Output_Name;\n "}, {"sha": "c7fdc8181d50e1d904e1734ed8dbabf7dfde337b", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b794c81a5712113fe4245ec917abf6603158e6/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=32b794c81a5712113fe4245ec917abf6603158e6", "patch": "@@ -950,6 +950,20 @@ package Sem_Util is\n    pragma Inline (Get_Pragma_Id);\n    --  Obtains the Pragma_Id from the Chars field of Pragma_Identifier (N)\n \n+   function Get_Qualified_Name\n+     (Id     : Entity_Id;\n+      Suffix : Entity_Id := Empty) return Name_Id;\n+   --  Obtain the fully qualified form of entity Id. The format is:\n+   --    scope_of_id-1__scope_of_id__chars_of_id__chars_of_suffix\n+\n+   function Get_Qualified_Name\n+     (Nam    : Name_Id;\n+      Suffix : Name_Id   := No_Name;\n+      Scop   : Entity_Id := Current_Scope) return Name_Id;\n+   --  Obtain the fully qualified form of name Nam assuming it appears in scope\n+   --  Scop. The format is:\n+   --    scop-1__scop__nam__suffix\n+\n    procedure Get_Reason_String (N : Node_Id);\n    --  Recursive routine to analyze reason argument for pragma Warnings. The\n    --  value of the reason argument is appended to the current string using"}]}