{"sha": "5eb63cfd035391ed4a1552e41fa613c341fd7465", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWViNjNjZmQwMzUzOTFlZDRhMTU1MmU0MWZhNjEzYzM0MWZkNzQ2NQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2017-12-12T22:09:42Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2017-12-12T22:09:42Z"}, "message": "PR c++/82115 - ICE with variable initialized with its own address.\n\n\t* cp-tree.h (struct lang_decl_base): Add dependent_init_p.\n\t(DECL_DEPENDENT_INIT_P, SET_DECL_DEPENDENT_INIT_P): New.\n\t* decl.c (cp_finish_decl): Set it.\n\t(duplicate_decls): Copy it.\n\t* pt.c (tsubst_decl): Clear it.\n\t(value_dependent_expression_p): Revert earlier change.  Check it.\n\nFrom-SVN: r255590", "tree": {"sha": "44205f36b1f1947b1b0fc6f3b95189112f62988b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44205f36b1f1947b1b0fc6f3b95189112f62988b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5eb63cfd035391ed4a1552e41fa613c341fd7465", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5eb63cfd035391ed4a1552e41fa613c341fd7465", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5eb63cfd035391ed4a1552e41fa613c341fd7465", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5eb63cfd035391ed4a1552e41fa613c341fd7465/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "331e2db3b82592c7644186aa950acc29f54df29e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/331e2db3b82592c7644186aa950acc29f54df29e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/331e2db3b82592c7644186aa950acc29f54df29e"}], "stats": {"total": 74, "additions": 50, "deletions": 24}, "files": [{"sha": "010f3f4b4432db8e389fc19764d4ef388d834c00", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eb63cfd035391ed4a1552e41fa613c341fd7465/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eb63cfd035391ed4a1552e41fa613c341fd7465/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5eb63cfd035391ed4a1552e41fa613c341fd7465", "patch": "@@ -1,3 +1,13 @@\n+2017-12-12  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/82115 - ICE with variable initialized with its own address.\n+\t* cp-tree.h (struct lang_decl_base): Add dependent_init_p.\n+\t(DECL_DEPENDENT_INIT_P, SET_DECL_DEPENDENT_INIT_P): New.\n+\t* decl.c (cp_finish_decl): Set it.\n+\t(duplicate_decls): Copy it.\n+\t* pt.c (tsubst_decl): Clear it.\n+\t(value_dependent_expression_p): Revert earlier change.  Check it.\n+\n 2017-12-12  Alexandre Oliva <aoliva@redhat.com>\n \n \t* constexpr.c (check_constexpr_ctor_body_1): Skip begin stmt"}, {"sha": "05551dfdf29d4e5284af6c5b00e9958d937ceaf8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eb63cfd035391ed4a1552e41fa613c341fd7465/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eb63cfd035391ed4a1552e41fa613c341fd7465/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5eb63cfd035391ed4a1552e41fa613c341fd7465", "patch": "@@ -2449,7 +2449,8 @@ struct GTY(()) lang_decl_base {\n   unsigned u2sel : 1;\n   unsigned concept_p : 1;                  /* applies to vars and functions */\n   unsigned var_declared_inline_p : 1;\t   /* var */\n-  /* 2 spare bits */\n+  unsigned dependent_init_p : 1;\t   /* var */\n+  /* 1 spare bit */\n };\n \n /* True for DECL codes which have template info and access.  */\n@@ -3879,6 +3880,13 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n   (DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE))->u.base.var_declared_inline_p \\\n    = true)\n \n+/* True if NODE is a constant variable with a value-dependent initializer.  */\n+#define DECL_DEPENDENT_INIT_P(NODE)\t\t\t\t\\\n+  (DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE))\t\t\t\\\n+   && DECL_LANG_SPECIFIC (NODE)->u.base.dependent_init_p)\n+#define SET_DECL_DEPENDENT_INIT_P(NODE, X) \\\n+  (DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE))->u.base.dependent_init_p = (X))\n+\n /* Nonzero if NODE is an artificial VAR_DECL for a C++17 structured binding\n    declaration or one of VAR_DECLs for the user identifiers in it.  */\n #define DECL_DECOMPOSITION_P(NODE) \\\n@@ -6542,7 +6550,7 @@ extern bool type_dependent_object_expression_p\t(tree);\n extern bool any_type_dependent_arguments_p      (const vec<tree, va_gc> *);\n extern bool any_type_dependent_elements_p       (const_tree);\n extern bool type_dependent_expression_p_push\t(tree);\n-extern bool value_dependent_expression_p\t(tree, bool = false);\n+extern bool value_dependent_expression_p\t(tree);\n extern bool instantiation_dependent_expression_p (tree);\n extern bool instantiation_dependent_uneval_expression_p (tree);\n extern bool any_value_dependent_elements_p      (const_tree);"}, {"sha": "3601fa117c71795470b0b8358c0efeaeb86116a7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eb63cfd035391ed4a1552e41fa613c341fd7465/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eb63cfd035391ed4a1552e41fa613c341fd7465/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5eb63cfd035391ed4a1552e41fa613c341fd7465", "patch": "@@ -2120,6 +2120,8 @@ next_arg:;\n \t  DECL_INITIALIZED_P (newdecl) |= DECL_INITIALIZED_P (olddecl);\n \t  DECL_NONTRIVIALLY_INITIALIZED_P (newdecl)\n \t    |= DECL_NONTRIVIALLY_INITIALIZED_P (olddecl);\n+\t  if (DECL_DEPENDENT_INIT_P (olddecl))\n+\t    SET_DECL_DEPENDENT_INIT_P (newdecl, true);\n \t  DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (newdecl)\n \t    |= DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (olddecl);\n           if (DECL_CLASS_SCOPE_P (olddecl))\n@@ -6910,14 +6912,18 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t then it can be used in future constant expressions, so its value\n \t must be available. */\n \n+      bool dep_init = false;\n+\n       if (!VAR_P (decl) || type_dependent_p)\n \t/* We can't do anything if the decl has dependent type.  */;\n+      else if (!init && is_concept_var (decl))\n+        error (\"variable concept has no initializer\");\n       else if (init\n \t       && init_const_expr_p\n \t       && TREE_CODE (type) != REFERENCE_TYPE\n \t       && decl_maybe_constant_var_p (decl)\n-\t       && !type_dependent_init_p (init)\n-\t       && !value_dependent_init_p (init))\n+\t       && !(dep_init = (type_dependent_init_p (init)\n+\t\t\t\t|| value_dependent_init_p (init))))\n \t{\n \t  /* This variable seems to be a non-dependent constant, so process\n \t     its initializer.  If check_initializer returns non-null the\n@@ -6929,8 +6935,6 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t    init = NULL_TREE;\n \t  release_tree_vector (cleanups);\n \t}\n-      else if (!init && is_concept_var (decl))\n-        error (\"variable concept has no initializer\");\n       else if (!DECL_PRETTY_FUNCTION_P (decl))\n \t{\n \t  /* Deduce array size even if the initializer is dependent.  */\n@@ -6944,6 +6948,11 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \n       if (init)\n \tDECL_INITIAL (decl) = init;\n+      if (dep_init)\n+\t{\n+\t  retrofit_lang_decl (decl);\n+\t  SET_DECL_DEPENDENT_INIT_P (decl, true);\n+\t}\n       return;\n     }\n "}, {"sha": "b5be9807ea969eed6f82b4a1b93e763313b0798c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eb63cfd035391ed4a1552e41fa613c341fd7465/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eb63cfd035391ed4a1552e41fa613c341fd7465/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5eb63cfd035391ed4a1552e41fa613c341fd7465", "patch": "@@ -13135,6 +13135,9 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \tDECL_SIZE (r) = DECL_SIZE_UNIT (r) = 0;\n \tif (VAR_P (r))\n \t  {\n+\t    if (DECL_LANG_SPECIFIC (r))\n+\t      SET_DECL_DEPENDENT_INIT_P (r, false);\n+\n \t    SET_DECL_MODE (r, VOIDmode);\n \n \t    /* Possibly limit visibility based on template args.  */\n@@ -23922,7 +23925,7 @@ instantiation_dependent_scope_ref_p (tree t)\n    can be tested for value dependence.  */\n \n bool\n-value_dependent_expression_p (tree expression, bool lval /* = false */)\n+value_dependent_expression_p (tree expression)\n {\n   if (!processing_template_decl || expression == NULL_TREE)\n     return false;\n@@ -23956,28 +23959,19 @@ value_dependent_expression_p (tree expression, bool lval /* = false */)\n       /* A non-type template parm.  */\n       if (DECL_TEMPLATE_PARM_P (expression))\n \treturn true;\n-      gcc_checking_assert (!lval);\n       return value_dependent_expression_p (DECL_INITIAL (expression));\n \n     case VAR_DECL:\n        /* A constant with literal type and is initialized\n-\t  with an expression that is value-dependent.\n-\n-          Note that a non-dependent parenthesized initializer will have\n-          already been replaced with its constant value, so if we see\n-          a TREE_LIST it must be dependent.  */\n-      if (!lval\n-\t  && DECL_INITIAL (expression)\n-\t  && decl_constant_var_p (expression)\n-\t  && (TREE_CODE (DECL_INITIAL (expression)) == TREE_LIST\n-\t      /* cp_finish_decl doesn't fold reference initializers.  */\n-\t      || TREE_CODE (TREE_TYPE (expression)) == REFERENCE_TYPE\n-\t      || value_dependent_expression_p (DECL_INITIAL (expression))))\n+\t  with an expression that is value-dependent.  */\n+      if (DECL_DEPENDENT_INIT_P (expression)\n+\t  /* FIXME cp_finish_decl doesn't fold reference initializers.  */\n+\t  || TREE_CODE (TREE_TYPE (expression)) == REFERENCE_TYPE)\n \treturn true;\n       if (DECL_HAS_VALUE_EXPR_P (expression))\n \t{\n \t  tree value_expr = DECL_VALUE_EXPR (expression);\n-\t  if (value_dependent_expression_p (value_expr, lval))\n+\t  if (value_dependent_expression_p (value_expr))\n \t    return true;\n \t}\n       return false;\n@@ -24013,7 +24007,7 @@ value_dependent_expression_p (tree expression, bool lval /* = false */)\n \tif (TREE_CODE (expression) == TREE_LIST)\n \t  return any_value_dependent_elements_p (expression);\n \n-\treturn value_dependent_expression_p (expression, lval);\n+\treturn value_dependent_expression_p (expression);\n       }\n \n     case SIZEOF_EXPR:\n@@ -24047,7 +24041,7 @@ value_dependent_expression_p (tree expression, bool lval /* = false */)\n       return instantiation_dependent_scope_ref_p (expression);\n \n     case COMPONENT_REF:\n-      return (value_dependent_expression_p (TREE_OPERAND (expression, 0), lval)\n+      return (value_dependent_expression_p (TREE_OPERAND (expression, 0))\n \t      || value_dependent_expression_p (TREE_OPERAND (expression, 1)));\n \n     case NONTYPE_ARGUMENT_PACK:\n@@ -24095,7 +24089,7 @@ value_dependent_expression_p (tree expression, bool lval /* = false */)\n     case ADDR_EXPR:\n       {\n \ttree op = TREE_OPERAND (expression, 0);\n-\treturn (value_dependent_expression_p (op, true)\n+\treturn (value_dependent_expression_p (op)\n \t\t|| has_value_dependent_address (op));\n       }\n "}, {"sha": "32a10af49a6ea8e494e8adf0cd857b8eb4386ffa", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-self1.C", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eb63cfd035391ed4a1552e41fa613c341fd7465/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-self1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eb63cfd035391ed4a1552e41fa613c341fd7465/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-self1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-self1.C?ref=5eb63cfd035391ed4a1552e41fa613c341fd7465", "patch": "@@ -12,3 +12,8 @@ struct B : A\n constexpr B b (&b.u);\n \n template < typename > void foo () { b; }\n+\n+template < typename T> void foo2 () {\n+  constexpr B b2 = &b2.u;\n+  b2;\n+}"}]}