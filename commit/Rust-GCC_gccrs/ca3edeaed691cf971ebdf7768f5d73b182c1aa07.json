{"sha": "ca3edeaed691cf971ebdf7768f5d73b182c1aa07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EzZWRlYWVkNjkxY2Y5NzFlYmRmNzc2OGY1ZDczYjE4MmMxYWEwNw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2019-05-31T13:25:46Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2019-05-31T13:25:46Z"}, "message": "[C++PATCH] Lambda names are anonymous\n\nhttps://gcc.gnu.org/ml/gcc-patches/2019-05/msg02126.html\n\t* cp-tree.h (IDENTIFIER_LAMBDA_P): New.\n\t(TYPE_ANON_P): New.\n\t(LAMBDA_TYPE_P, TYPE_UNNAMED_P):  Likewise.\n\t(LAMBDANAME_PREFIX, LAMBDANAME_FORMAT): Delete.\n\t(make_lambda_name): Don't declare.\n\t* error.c (dump_aggr_type): Check for lambdas before other\n\tanonymous names.\n\t* lambda.c (begin_lambda_type): Use make_anon_name.\n\t* cp-lang.c (cxx_dwarf_name): Lambda names smell anonymous.\n\t* mangle.c (write_local_name): Likewise.\n\t* name-lookup.c (lambda_cnt, make_lambda_name): Delete.\n\nFrom-SVN: r271811", "tree": {"sha": "70d2c9af2fdf1addd53538a38013476747599eca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70d2c9af2fdf1addd53538a38013476747599eca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca3edeaed691cf971ebdf7768f5d73b182c1aa07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca3edeaed691cf971ebdf7768f5d73b182c1aa07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca3edeaed691cf971ebdf7768f5d73b182c1aa07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca3edeaed691cf971ebdf7768f5d73b182c1aa07/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "929c046d575c273e80000310b88c24af94cc4cf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/929c046d575c273e80000310b88c24af94cc4cf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/929c046d575c273e80000310b88c24af94cc4cf8"}], "stats": {"total": 103, "additions": 51, "deletions": 52}, "files": [{"sha": "d05719b9bbebaed6a9c1d60d851a02e176bedafe", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3edeaed691cf971ebdf7768f5d73b182c1aa07/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3edeaed691cf971ebdf7768f5d73b182c1aa07/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ca3edeaed691cf971ebdf7768f5d73b182c1aa07", "patch": "@@ -1,3 +1,17 @@\n+2019-05-31  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* cp-tree.h (IDENTIFIER_LAMBDA_P): New.\n+\t(TYPE_ANON_P): New.\n+\t(LAMBDA_TYPE_P, TYPE_UNNAMED_P):  Likewise.\n+\t(LAMBDANAME_PREFIX, LAMBDANAME_FORMAT): Delete.\n+\t(make_lambda_name): Don't declare.\n+\t* error.c (dump_aggr_type): Check for lambdas before other\n+\tanonymous names.\n+\t* lambda.c (begin_lambda_type): Use make_anon_name.\n+\t* cp-lang.c (cxx_dwarf_name): Lambda names smell anonymous.\n+\t* mangle.c (write_local_name): Likewise.\n+\t* name-lookup.c (lambda_cnt, make_lambda_name): Delete.\n+\n 2019-05-30  Marek Polacek  <polacek@redhat.com>\n \n \t* cp-tree.h (TYPE_HAS_NONTRIVIAL_DESTRUCTOR): Fix a typo."}, {"sha": "be34871dd08d346250d8c254a3827788161ef93c", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3edeaed691cf971ebdf7768f5d73b182c1aa07/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3edeaed691cf971ebdf7768f5d73b182c1aa07/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=ca3edeaed691cf971ebdf7768f5d73b182c1aa07", "patch": "@@ -109,8 +109,7 @@ cxx_dwarf_name (tree t, int verbosity)\n {\n   gcc_assert (DECL_P (t));\n \n-  if (DECL_NAME (t)\n-      && (IDENTIFIER_ANON_P (DECL_NAME (t)) || LAMBDA_TYPE_P (t)))\n+  if (DECL_NAME (t) && IDENTIFIER_ANON_P (DECL_NAME (t)))\n     return NULL;\n   if (verbosity >= 2)\n     return decl_as_dwarf_string (t,"}, {"sha": "4d79c43c5af26c7ba1f2ca47c9f20115daa1c3c6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3edeaed691cf971ebdf7768f5d73b182c1aa07/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3edeaed691cf971ebdf7768f5d73b182c1aa07/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ca3edeaed691cf971ebdf7768f5d73b182c1aa07", "patch": "@@ -1297,9 +1297,16 @@ struct GTY (()) tree_trait_expr {\n   enum cp_trait_kind kind;\n };\n \n+/* Identifiers used for lambda types are almost anonymous.  Use this\n+   spare flag to distinguish them (they also have the anonymous flag).  */\n+#define IDENTIFIER_LAMBDA_P(NODE) \\\n+  (IDENTIFIER_NODE_CHECK(NODE)->base.protected_flag)\n+\n /* Based off of TYPE_UNNAMED_P.  */\n-#define LAMBDA_TYPE_P(NODE) \\\n-  (CLASS_TYPE_P (NODE) && CLASSTYPE_LAMBDA_EXPR (NODE))\n+#define LAMBDA_TYPE_P(NODE)\t\t\t\\\n+  (TREE_CODE (NODE) == RECORD_TYPE\t\t\\\n+   && TYPE_LINKAGE_IDENTIFIER (NODE)\t\t\t\t\\\n+   && IDENTIFIER_LAMBDA_P (TYPE_LINKAGE_IDENTIFIER (NODE)))\n \n /* Test if FUNCTION_DECL is a lambda function.  */\n #define LAMBDA_FUNCTION_P(FNDECL)\t\t\t\t\\\n@@ -1935,9 +1942,15 @@ enum languages { lang_c, lang_cplusplus };\n #define TYPE_NAME_STRING(NODE) (IDENTIFIER_POINTER (TYPE_IDENTIFIER (NODE)))\n #define TYPE_NAME_LENGTH(NODE) (IDENTIFIER_LENGTH (TYPE_IDENTIFIER (NODE)))\n \n-/* Nonzero if NODE has no name for linkage purposes.  */\n-#define TYPE_UNNAMED_P(NODE) \\\n-  (OVERLOAD_TYPE_P (NODE) && IDENTIFIER_ANON_P (TYPE_LINKAGE_IDENTIFIER (NODE)))\n+/* Any kind of anonymous type.  */\n+#define TYPE_ANON_P(NODE)\t\t\t\t\t\\\n+  (TYPE_LINKAGE_IDENTIFIER (NODE)\t\t\t\t\\\n+   && IDENTIFIER_ANON_P (TYPE_LINKAGE_IDENTIFIER (NODE)))\n+\n+/* Nonzero if NODE, a TYPE, has no name for linkage purposes.  */\n+#define TYPE_UNNAMED_P(NODE)\t\t\t\t\t\\\n+  (TYPE_ANON_P (NODE)\t\t\t\t\t\t\\\n+   && !IDENTIFIER_LAMBDA_P (TYPE_LINKAGE_IDENTIFIER (NODE)))\n \n /* The _DECL for this _TYPE.  */\n #define TYPE_MAIN_DECL(NODE) (TYPE_STUB_DECL (TYPE_MAIN_VARIANT (NODE)))\n@@ -5357,9 +5370,6 @@ extern GTY(()) vec<tree, va_gc> *keyed_classes;\n #endif\t/* NO_DOLLAR_IN_LABEL */\n #endif\t/* NO_DOT_IN_LABEL */\n \n-#define LAMBDANAME_PREFIX \"__lambda\"\n-#define LAMBDANAME_FORMAT LAMBDANAME_PREFIX \"%d\"\n-\n #define UDLIT_OP_ANSI_PREFIX \"operator\\\"\\\"\"\n #define UDLIT_OP_ANSI_FORMAT UDLIT_OP_ANSI_PREFIX \"%s\"\n #define UDLIT_OP_MANGLED_PREFIX \"li\"\n@@ -6365,7 +6375,6 @@ extern void note_break_stmt\t\t\t(void);\n extern bool note_iteration_stmt_body_start\t(void);\n extern void note_iteration_stmt_body_end\t(bool);\n extern void determine_local_discriminator\t(tree);\n-extern tree make_lambda_name\t\t\t(void);\n extern int decls_match\t\t\t\t(tree, tree, bool = true);\n extern bool maybe_version_functions\t\t(tree, tree, bool);\n extern tree duplicate_decls\t\t\t(tree, tree, bool);"}, {"sha": "d94f5a3b6673be2e254eca233071bfb88e096b19", "filename": "gcc/cp/error.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3edeaed691cf971ebdf7768f5d73b182c1aa07/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3edeaed691cf971ebdf7768f5d73b182c1aa07/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=ca3edeaed691cf971ebdf7768f5d73b182c1aa07", "patch": "@@ -738,14 +738,7 @@ dump_aggr_type (cxx_pretty_printer *pp, tree t, int flags)\n       name = DECL_NAME (name);\n     }\n \n-  if (!name || IDENTIFIER_ANON_P (name))\n-    {\n-      if (flags & TFF_CLASS_KEY_OR_ENUM)\n-\tpp_string (pp, M_(\"<unnamed>\"));\n-      else\n-\tpp_printf (pp, M_(\"<unnamed %s>\"), variety);\n-    }\n-  else if (LAMBDA_TYPE_P (t))\n+  if (LAMBDA_TYPE_P (t))\n     {\n       /* A lambda's \"type\" is essentially its signature.  */\n       pp_string (pp, M_(\"<lambda\"));\n@@ -755,8 +748,16 @@ dump_aggr_type (cxx_pretty_printer *pp, tree t, int flags)\n \t\t\t flags);\n       pp_greater (pp);\n     }\n+  else if (!name || IDENTIFIER_ANON_P (name))\n+    {\n+      if (flags & TFF_CLASS_KEY_OR_ENUM)\n+\tpp_string (pp, M_(\"<unnamed>\"));\n+      else\n+\tpp_printf (pp, M_(\"<unnamed %s>\"), variety);\n+    }\n   else\n     pp_cxx_tree_identifier (pp, name);\n+\n   if (tmplate)\n     dump_template_parms (pp, TYPE_TEMPLATE_INFO (t),\n \t\t\t !CLASSTYPE_USE_TEMPLATE (t),"}, {"sha": "758773b8a85f22fb8cda864d3b53523ea3809583", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3edeaed691cf971ebdf7768f5d73b182c1aa07/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3edeaed691cf971ebdf7768f5d73b182c1aa07/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=ca3edeaed691cf971ebdf7768f5d73b182c1aa07", "patch": "@@ -128,22 +128,15 @@ build_lambda_object (tree lambda_expr)\n tree\n begin_lambda_type (tree lambda)\n {\n-  tree type;\n+  /* Lambda names are nearly but not quite anonymous.  */\n+  tree name = make_anon_name ();\n+  IDENTIFIER_LAMBDA_P (name) = true;\n \n-  {\n-    /* Unique name.  This is just like an unnamed class, but we cannot use\n-       make_anon_name because of certain checks against TYPE_UNNAMED_P.  */\n-    tree name;\n-    name = make_lambda_name ();\n-\n-    /* Create the new RECORD_TYPE for this lambda.  */\n-    type = xref_tag (/*tag_code=*/record_type,\n-                     name,\n-                     /*scope=*/ts_lambda,\n-                     /*template_header_p=*/false);\n-    if (type == error_mark_node)\n-      return error_mark_node;\n-  }\n+  /* Create the new RECORD_TYPE for this lambda.  */\n+  tree type = xref_tag (/*tag_code=*/record_type, name,\n+\t\t\t/*scope=*/ts_lambda, /*template_header_p=*/false);\n+  if (type == error_mark_node)\n+    return error_mark_node;\n \n   /* Designate it as a struct so that we can use aggregate initialization.  */\n   CLASSTYPE_DECLARED_CLASS (type) = false;"}, {"sha": "4d6f58093c1e7d177ee597d351fb78e55ecc6ac6", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3edeaed691cf971ebdf7768f5d73b182c1aa07/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3edeaed691cf971ebdf7768f5d73b182c1aa07/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=ca3edeaed691cf971ebdf7768f5d73b182c1aa07", "patch": "@@ -2004,8 +2004,7 @@ write_local_name (tree function, const tree local_entity,\n       write_name (entity, /*ignore_local_scope=*/1);\n       if (DECL_DISCRIMINATOR_P (local_entity)\n \t  && !(TREE_CODE (local_entity) == TYPE_DECL\n-\t       && (LAMBDA_TYPE_P (TREE_TYPE (local_entity))\n-\t\t   || TYPE_UNNAMED_P (TREE_TYPE (local_entity)))))\n+\t       && TYPE_ANON_P (TREE_TYPE (local_entity))))\n \twrite_discriminator (discriminator_for_local_entity (local_entity));\n     }\n }"}, {"sha": "0bea41ffb91bf8f039e6760d64fcca43f1aaf4d7", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3edeaed691cf971ebdf7768f5d73b182c1aa07/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3edeaed691cf971ebdf7768f5d73b182c1aa07/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=ca3edeaed691cf971ebdf7768f5d73b182c1aa07", "patch": "@@ -3797,22 +3797,6 @@ constructor_name_p (tree name, tree type)\n   return false;\n }\n \n-/* This code is practically identical to that for creating anonymous\n-   names, but is just used for lambdas instead.  This isn't really\n-   necessary, but it's convenient to avoid mistaking lambdas for other\n-   unnamed types.  */\n-\n-static GTY(()) int lambda_cnt = 0;\n-\n-tree\n-make_lambda_name (void)\n-{\n-  char buf[32];\n-\n-  sprintf (buf, LAMBDANAME_FORMAT, lambda_cnt++);\n-  return get_identifier (buf);\n-}\n-\n /* Same as pushdecl, but define X in binding-level LEVEL.  We rely on the\n    caller to set DECL_CONTEXT properly.\n "}]}