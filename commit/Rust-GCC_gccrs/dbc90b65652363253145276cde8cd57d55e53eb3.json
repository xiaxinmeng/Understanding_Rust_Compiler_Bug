{"sha": "dbc90b65652363253145276cde8cd57d55e53eb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJjOTBiNjU2NTIzNjMyNTMxNDUyNzZjZGU4Y2Q1N2Q1NWU1M2ViMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2008-01-26T10:22:14Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2008-01-26T10:22:14Z"}, "message": "re PR target/34981 (Lazily-bound function called twice)\n\ngcc/\n\tPR target/34981\n\t* config/mips/mips-protos.h (mips_expand_call): Return an rtx.\n\t* config/mips/mips.h (FIRST_PSEUDO_REGISTER): Rename FAKE_CALL_REGNO\n\tto GOT_VERSION_REGNUM.\n\t(CALL_REALLY_USED_REGISTERS): Set the GOT_VERSION_REGNUM entry to 0.\n\t(EPILOGUE_USES): Include GOT_VERSION_REGNUM if TARGET_USE_GOT.\n\t* config/mips/mips.c (mips_emit_call_insn): New function.\n\t(mips_call_tls_get_addr): Call mips_expand_call directly.\n\t(mips16_copy_fpr_return_value): Use mips_emit_call_insn rather than\n\temit_call_insn.\n\t(mips16_build_call_stub): Likewise.  Return the call insn or null.\n\t(mips_expand_call): Update the call to mips16_build_call_stub\n\taccordingly and a remove redundant condition.  Assert that MIPS16\n\tstubs do not use lazy binding.  Use mips_emit_call_insn and return\n\tthe call insn.\n\t(mips_extra_live_on_entry): Include GOT_VERSION_REGNUM if\n\tTARGET_USE_GOT.\n\t(mips_hard_regno_mode_ok_p): Allow SImode for GOT_VERSION_REGNUM.\n\t(mips_avoid_hazard): Remove hazard_set handling.\n\t* config/mips/mips.md (UNSPEC_EH_RECEIVER): Rename to...\n\t(UNSPEC_RESTORE_GP): ...this.\n\t(UNSPEC_SET_GOT_VERSION, UNSPEC_UPDATE_GOT_VERSION): New constants.\n\t(FAKE_CALL_REGNO): Rename to...\n\t(GOT_VERSION_REGNUM): ...this.\n\t(type): Add \"ghost\" value.  Add an associated insn reservation.\n\t(hazard_set): Remove.\n\t(exception_receiver): Rename to...\n\t(restore_gp): ...this and update the unspec identifier accordingly.\n\t(exception_receiver, nonlocal_got_receiver): New expanders.\n\t(load_call<mode>): Use GOT_VERSION_REGNUM.  Don't set\n\tFAKE_CALL_REGNO.  Remove hazard_set attribute.\n\t(set_got_version, update_got_version): New patterns.\n\ngcc/testsuite/\n\tPR target/34981\n\t* gcc.target/mips/lazy-binding-1.c: New test.\n\t* gcc.target/mips/mips.exp (setup_mips_tests): Set\n\tmips_forced_no_abicalls and mips_forced_no_shared.\n\t(dg-mips-options): Avoid using -mabicalls with an implicit -mabi=eabi.\n\tAvoid using small data with -mabicalls.  Don't make -G0 force\n\t-mn-abicalls.  Skip -mabicalls and -mshared tests if the multilib\n\tforces the opposite option.\n\nFrom-SVN: r131860", "tree": {"sha": "4d749e3cf6bc1456deeac94dc4f8c312f6080ba4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d749e3cf6bc1456deeac94dc4f8c312f6080ba4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbc90b65652363253145276cde8cd57d55e53eb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbc90b65652363253145276cde8cd57d55e53eb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbc90b65652363253145276cde8cd57d55e53eb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbc90b65652363253145276cde8cd57d55e53eb3/comments", "author": null, "committer": null, "parents": [{"sha": "763a27ee730f23883d6ab6feacb9b22992a8d16c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/763a27ee730f23883d6ab6feacb9b22992a8d16c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/763a27ee730f23883d6ab6feacb9b22992a8d16c"}], "stats": {"total": 347, "additions": 270, "deletions": 77}, "files": [{"sha": "f6b8fe561d48a5c1ea4a429be3ce192eb01bb56e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc90b65652363253145276cde8cd57d55e53eb3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc90b65652363253145276cde8cd57d55e53eb3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dbc90b65652363253145276cde8cd57d55e53eb3", "patch": "@@ -1,3 +1,38 @@\n+2008-01-26  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\tPR target/34981\n+\t* config/mips/mips-protos.h (mips_expand_call): Return an rtx.\n+\t* config/mips/mips.h (FIRST_PSEUDO_REGISTER): Rename FAKE_CALL_REGNO\n+\tto GOT_VERSION_REGNUM.\n+\t(CALL_REALLY_USED_REGISTERS): Set the GOT_VERSION_REGNUM entry to 0.\n+\t(EPILOGUE_USES): Include GOT_VERSION_REGNUM if TARGET_USE_GOT.\n+\t* config/mips/mips.c (mips_emit_call_insn): New function.\n+\t(mips_call_tls_get_addr): Call mips_expand_call directly.\n+\t(mips16_copy_fpr_return_value): Use mips_emit_call_insn rather than\n+\temit_call_insn.\n+\t(mips16_build_call_stub): Likewise.  Return the call insn or null.\n+\t(mips_expand_call): Update the call to mips16_build_call_stub\n+\taccordingly and a remove redundant condition.  Assert that MIPS16\n+\tstubs do not use lazy binding.  Use mips_emit_call_insn and return\n+\tthe call insn.\n+\t(mips_extra_live_on_entry): Include GOT_VERSION_REGNUM if\n+\tTARGET_USE_GOT.\n+\t(mips_hard_regno_mode_ok_p): Allow SImode for GOT_VERSION_REGNUM.\n+\t(mips_avoid_hazard): Remove hazard_set handling.\n+\t* config/mips/mips.md (UNSPEC_EH_RECEIVER): Rename to...\n+\t(UNSPEC_RESTORE_GP): ...this.\n+\t(UNSPEC_SET_GOT_VERSION, UNSPEC_UPDATE_GOT_VERSION): New constants.\n+\t(FAKE_CALL_REGNO): Rename to...\n+\t(GOT_VERSION_REGNUM): ...this.\n+\t(type): Add \"ghost\" value.  Add an associated insn reservation.\n+\t(hazard_set): Remove.\n+\t(exception_receiver): Rename to...\n+\t(restore_gp): ...this and update the unspec identifier accordingly.\n+\t(exception_receiver, nonlocal_got_receiver): New expanders.\n+\t(load_call<mode>): Use GOT_VERSION_REGNUM.  Don't set\n+\tFAKE_CALL_REGNO.  Remove hazard_set attribute.\n+\t(set_got_version, update_got_version): New patterns.\n+\n 2008-01-26  Danny Smith  <dannysmith@users.sourceforge.net>\n \n \tPR target/34970"}, {"sha": "deb99a0886706338d5b19ced8d17e0c1b7f2e1d3", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc90b65652363253145276cde8cd57d55e53eb3/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc90b65652363253145276cde8cd57d55e53eb3/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=dbc90b65652363253145276cde8cd57d55e53eb3", "patch": "@@ -209,7 +209,7 @@ extern void mips_expand_vcondv2sf (rtx, rtx, rtx, enum rtx_code, rtx, rtx);\n extern void mips_expand_conditional_move (rtx *);\n extern void mips_expand_conditional_trap (enum rtx_code);\n #endif\n-extern void mips_expand_call (rtx, rtx, rtx, rtx, bool);\n+extern rtx mips_expand_call (rtx, rtx, rtx, rtx, bool);\n extern void mips_expand_fcc_reload (rtx, rtx, rtx);\n extern void mips_set_return_address (rtx, rtx);\n extern bool mips_expand_block_move (rtx, rtx, rtx);"}, {"sha": "c2d4765efb6a377c644849caf34ba18b62ed10b3", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 65, "deletions": 46, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc90b65652363253145276cde8cd57d55e53eb3/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc90b65652363253145276cde8cd57d55e53eb3/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=dbc90b65652363253145276cde8cd57d55e53eb3", "patch": "@@ -2135,6 +2135,31 @@ mips_force_temporary (rtx dest, rtx value)\n       return dest;\n     }\n }\n+\n+/* Emit a call sequence with call pattern PATTERN and return the call\n+   instruction itself (which is not necessarily the last instruction\n+   emitted).  LAZY_P is true if the call address is lazily-bound.  */\n+\n+static rtx\n+mips_emit_call_insn (rtx pattern, bool lazy_p)\n+{\n+  rtx insn;\n+\n+  insn = emit_call_insn (pattern);\n+\n+  /* Lazy-binding stubs require $gp to be valid on entry.  */\n+  if (lazy_p)\n+    use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n+\n+  if (TARGET_USE_GOT)\n+    {\n+      /* See the comment above load_call<mode> for details.  */\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (insn),\n+\t       gen_rtx_REG (Pmode, GOT_VERSION_REGNUM));\n+      emit_insn (gen_update_got_version ());\n+    }\n+  return insn;\n+}\n \f\n /* Return a pseudo register that contains the value of $gp throughout\n    the current function.  Such registers are needed by MIPS16 functions,\n@@ -2309,7 +2334,7 @@ static GTY(()) rtx mips_tls_symbol;\n static rtx\n mips_call_tls_get_addr (rtx sym, enum mips_symbol_type type, rtx v0)\n {\n-  rtx insn, loc, tga, a0;\n+  rtx insn, loc, a0;\n \n   a0 = gen_rtx_REG (Pmode, GP_ARG_FIRST);\n \n@@ -2322,8 +2347,7 @@ mips_call_tls_get_addr (rtx sym, enum mips_symbol_type type, rtx v0)\n \n   emit_insn (gen_rtx_SET (Pmode, a0,\n \t\t\t  gen_rtx_LO_SUM (Pmode, pic_offset_table_rtx, loc)));\n-  tga = gen_const_mem (Pmode, mips_tls_symbol);\n-  insn = emit_call_insn (gen_call_value (v0, tga, const0_rtx, const0_rtx));\n+  insn = mips_expand_call (v0, mips_tls_symbol, const0_rtx, const0_rtx, false);\n   CONST_OR_PURE_CALL_P (insn) = 1;\n   use_reg (&CALL_INSN_FUNCTION_USAGE (insn), a0);\n   insn = get_insns ();\n@@ -5198,7 +5222,7 @@ mips16_copy_fpr_return_value (void)\n   fn = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (id));\n   arg = gen_rtx_REG (return_mode, GP_RETURN);\n   call = gen_call_value_internal (arg, fn, const0_rtx);\n-  insn = emit_call_insn (call);\n+  insn = mips_emit_call_insn (call, false);\n   use_reg (&CALL_INSN_FUNCTION_USAGE (insn), arg);\n }\n \n@@ -5208,7 +5232,8 @@ mips16_copy_fpr_return_value (void)\n    arguments and FP_CODE is the code built by mips_function_arg;\n    see the comment above CUMULATIVE_ARGS for details.\n \n-   Return true if a stub was needed, and emit the call if so.\n+   If a stub was needed, emit the call and return the call insn itself.\n+   Return null otherwise.\n \n    A stub is needed for calls to functions that, in normal mode,\n    receive arguments in FPRs or return values in FPRs.  The stub\n@@ -5221,7 +5246,7 @@ mips16_copy_fpr_return_value (void)\n    to be to a non-MIPS16 function, the linker automatically redirects\n    the JAL to the stub, otherwise the JAL continues to call FN directly.  */\n \n-static bool\n+static rtx\n mips16_build_call_stub (rtx retval, rtx fn, rtx args_size, int fp_code)\n {\n   const char *fnname;\n@@ -5232,7 +5257,7 @@ mips16_build_call_stub (rtx retval, rtx fn, rtx args_size, int fp_code)\n   /* We don't need to do anything if we aren't in MIPS16 mode, or if\n      we were invoked with the -msoft-float option.  */\n   if (!TARGET_MIPS16 || TARGET_SOFT_FLOAT_ABI)\n-    return false;\n+    return NULL_RTX;\n \n   /* Figure out whether the value might come back in a floating-point\n      register.  */\n@@ -5242,13 +5267,13 @@ mips16_build_call_stub (rtx retval, rtx fn, rtx args_size, int fp_code)\n      arguments and the value will not be returned in a floating-point\n      register.  */\n   if (fp_code == 0 && !fp_ret_p)\n-    return false;\n+    return NULL_RTX;\n \n   /* We don't need to do anything if this is a call to a special\n      MIPS16 support function.  */\n   if (GET_CODE (fn) == SYMBOL_REF\n       && strncmp (XSTR (fn, 0), \"__mips16_\", 9) == 0)\n-    return false;\n+    return NULL_RTX;\n \n   /* This code will only work for o32 and o64 abis.  The other ABI's\n      require more sophisticated support.  */\n@@ -5281,7 +5306,7 @@ mips16_build_call_stub (rtx retval, rtx fn, rtx args_size, int fp_code)\n \tinsn = gen_call_internal (stub_fn, args_size);\n       else\n \tinsn = gen_call_value_internal (retval, stub_fn, args_size);\n-      insn = emit_call_insn (insn);\n+      insn = mips_emit_call_insn (insn, false);\n \n       /* Tell GCC that this call does indeed use the value of $2.  */\n       CALL_INSN_FUNCTION_USAGE (insn) =\n@@ -5301,7 +5326,7 @@ mips16_build_call_stub (rtx retval, rtx fn, rtx args_size, int fp_code)\n \t\t\t\t\t  gen_rtx_REG (word_mode, 18)),\n \t\t\t     CALL_INSN_FUNCTION_USAGE (insn));\n \n-      return true;\n+      return insn;\n     }\n \n   /* We know the function we are going to call.  If we have already\n@@ -5468,7 +5493,7 @@ mips16_build_call_stub (rtx retval, rtx fn, rtx args_size, int fp_code)\n     insn = gen_call_internal_direct (fn, args_size);\n   else\n     insn = gen_call_value_internal_direct (retval, fn, args_size);\n-  insn = emit_call_insn (insn);\n+  insn = mips_emit_call_insn (insn, false);\n \n   /* If we are calling a stub which handles a floating-point return\n      value, we need to arrange to save $18 in the prologue.  We do this\n@@ -5480,7 +5505,7 @@ mips16_build_call_stub (rtx retval, rtx fn, rtx args_size, int fp_code)\n \t\t\t gen_rtx_USE (VOIDmode, gen_rtx_REG (word_mode, 18)),\n \t\t\t CALL_INSN_FUNCTION_USAGE (insn));\n \n-  return true;\n+  return insn;\n }\n \f\n /* Return true if calls to X can use R_MIPS_CALL* relocations.  */\n@@ -5531,9 +5556,11 @@ mips_load_call_address (rtx dest, rtx addr, bool sibcall_p)\n    ADDR is the address of the function, ARGS_SIZE is the size of the\n    arguments and AUX is the value passed to us by mips_function_arg.\n    SIBCALL_P is true if we are expanding a sibling call, false if we're\n-   expanding a normal call.  */\n+   expanding a normal call.\n \n-void\n+   Return the call itself.  */\n+\n+rtx\n mips_expand_call (rtx result, rtx addr, rtx args_size, rtx aux, bool sibcall_p)\n {\n   rtx orig_addr, pattern, insn;\n@@ -5547,13 +5574,12 @@ mips_expand_call (rtx result, rtx addr, rtx args_size, rtx aux, bool sibcall_p)\n       lazy_p = mips_load_call_address (addr, orig_addr, sibcall_p);\n     }\n \n-  if (TARGET_MIPS16\n-      && TARGET_HARD_FLOAT_ABI\n-      && mips16_build_call_stub (result, addr, args_size,\n-\t\t\t\t aux == 0 ? 0 : (int) GET_MODE (aux)))\n+  insn = mips16_build_call_stub (result, addr, args_size,\n+\t\t\t\t aux == 0 ? 0 : (int) GET_MODE (aux));\n+  if (insn)\n     {\n-      gcc_assert (!sibcall_p);\n-      return;\n+      gcc_assert (!sibcall_p && !lazy_p);\n+      return insn;\n     }\n \n   if (result == 0)\n@@ -5582,17 +5608,7 @@ mips_expand_call (rtx result, rtx addr, rtx args_size, rtx aux, bool sibcall_p)\n \t\t : gen_call_value_internal (result, addr, args_size));\n     }\n \n-  insn = emit_call_insn (pattern);\n-\n-  /* Lazy-binding stubs require $gp to be valid on entry.  We also pretend\n-     that they use FAKE_CALL_REGNO; see the load_call<mode> patterns for\n-     details.  */\n-  if (lazy_p)\n-    {\n-      use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n-      use_reg (&CALL_INSN_FUNCTION_USAGE (insn),\n-\t       gen_rtx_REG (Pmode, FAKE_CALL_REGNO));\n-    }\n+  return mips_emit_call_insn (pattern, lazy_p);\n }\n \n /* Implement TARGET_FUNCTION_OK_FOR_SIBCALL.  */\n@@ -7977,14 +7993,21 @@ mips_initial_elimination_offset (int from, int to)\n   return offset;\n }\n \f\n-/* Implement TARGET_EXTRA_LIVE_ON_ENTRY.  Some code models use the incoming\n-   value of PIC_FUNCTION_ADDR_REGNUM to set up the global pointer.  */\n+/* Implement TARGET_EXTRA_LIVE_ON_ENTRY.  */\n \n static void\n mips_extra_live_on_entry (bitmap regs)\n {\n-  if (TARGET_USE_GOT && !TARGET_ABSOLUTE_ABICALLS)\n-    bitmap_set_bit (regs, PIC_FUNCTION_ADDR_REGNUM);\n+  if (TARGET_USE_GOT)\n+    {\n+      /* PIC_FUNCTION_ADDR_REGNUM is live if we need it to set up\n+\t the global pointer.   */\n+      if (!TARGET_ABSOLUTE_ABICALLS)\n+\tbitmap_set_bit (regs, PIC_FUNCTION_ADDR_REGNUM);\n+\n+      /* See the comment above load_call<mode> for details.  */\n+      bitmap_set_bit (regs, GOT_VERSION_REGNUM);\n+    }\n }\n \n /* Implement RETURN_ADDR_RTX.  We do not support moving back to a\n@@ -8720,6 +8743,9 @@ mips_hard_regno_mode_ok_p (unsigned int regno, enum machine_mode mode)\n   if (ALL_COP_REG_P (regno))\n     return class == MODE_INT && size <= UNITS_PER_WORD;\n \n+  if (regno == GOT_VERSION_REGNUM)\n+    return mode == SImode;\n+\n   return false;\n }\n \n@@ -11360,7 +11386,7 @@ mips_avoid_hazard (rtx after, rtx insn, int *hilo_delay,\n \t\t   rtx *delayed_reg, rtx lo_reg)\n {\n   rtx pattern, set;\n-  int nops, ninsns, hazard_set;\n+  int nops, ninsns;\n \n   pattern = PATTERN (insn);\n \n@@ -11406,15 +11432,8 @@ mips_avoid_hazard (rtx after, rtx insn, int *hilo_delay,\n \tbreak;\n \n       case HAZARD_DELAY:\n-\thazard_set = (int) get_attr_hazard_set (insn);\n-\tif (hazard_set == 0)\n-\t  set = single_set (insn);\n-\telse\n-\t  {\n-\t    gcc_assert (GET_CODE (PATTERN (insn)) == PARALLEL);\n-\t    set = XVECEXP (PATTERN (insn), 0, hazard_set - 1);\n-\t  }\n-\tgcc_assert (set && GET_CODE (set) == SET);\n+\tset = single_set (insn);\n+\tgcc_assert (set);\n \t*delayed_reg = SET_DEST (set);\n \tbreak;\n       }"}, {"sha": "7d94ebddd56fb08a803aea8655ecf74d2149693a", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc90b65652363253145276cde8cd57d55e53eb3/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc90b65652363253145276cde8cd57d55e53eb3/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=dbc90b65652363253145276cde8cd57d55e53eb3", "patch": "@@ -1372,7 +1372,7 @@ enum mips_code_readable_setting {\n    - 3 fake registers:\n \t- ARG_POINTER_REGNUM\n \t- FRAME_POINTER_REGNUM\n-\t- FAKE_CALL_REGNO (see the comment above load_callsi for details)\n+\t- GOT_VERSION_REGNUM (see the comment above load_call<mode> for details)\n    - 3 dummy entries that were used at various times in the past.\n    - 6 DSP accumulator registers (3 hi-lo pairs) for MIPS DSP ASE\n    - 6 DSP control registers  */\n@@ -1452,7 +1452,7 @@ enum mips_code_readable_setting {\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n   1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n   /* Others.  */                                                        \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,\t\t\t\\\n   /* COP0 registers */\t\t\t\t\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n@@ -2089,8 +2089,12 @@ typedef struct mips_args {\n \f\n /* Say that the epilogue uses the return address register.  Note that\n    in the case of sibcalls, the values \"used by the epilogue\" are\n-   considered live at the start of the called function.  */\n-#define EPILOGUE_USES(REGNO) ((REGNO) == 31)\n+   considered live at the start of the called function.\n+\n+   If using a GOT, say that the epilogue also uses GOT_VERSION_REGNUM.\n+   See the comment above load_call<mode> for details.  */\n+#define EPILOGUE_USES(REGNO) \\\n+  ((REGNO) == 31 || (TARGET_USE_GOT && (REGNO) == GOT_VERSION_REGNUM))\n \n /* Treat LOC as a byte offset from the stack pointer and round it up\n    to the next fully-aligned offset.  */"}, {"sha": "8b7e612f386d71f0ae285076b6c8b6bf11f1d4ab", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 89, "deletions": 25, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc90b65652363253145276cde8cd57d55e53eb3/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc90b65652363253145276cde8cd57d55e53eb3/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=dbc90b65652363253145276cde8cd57d55e53eb3", "patch": "@@ -30,7 +30,7 @@\n    (UNSPEC_GET_FNADDR\t\t 3)\n    (UNSPEC_BLOCKAGE\t\t 4)\n    (UNSPEC_CPRESTORE\t\t 5)\n-   (UNSPEC_EH_RECEIVER\t\t 6)\n+   (UNSPEC_RESTORE_GP\t\t 6)\n    (UNSPEC_EH_RETURN\t\t 7)\n    (UNSPEC_CONSTTABLE_INT\t 8)\n    (UNSPEC_CONSTTABLE_FLOAT\t 9)\n@@ -58,10 +58,12 @@\n    (UNSPEC_SYNC_NEW_OP\t\t39)\n    (UNSPEC_SYNC_EXCHANGE\t40)\n    (UNSPEC_MEMORY_BARRIER\t41)\n+   (UNSPEC_SET_GOT_VERSION\t42)\n+   (UNSPEC_UPDATE_GOT_VERSION\t43)\n    \n    (UNSPEC_ADDRESS_FIRST\t100)\n \n-   (FAKE_CALL_REGNO\t\t79)\n+   (GOT_VERSION_REGNUM\t\t79)\n \n    ;; For MIPS Paired-Singled Floating Point Instructions.\n \n@@ -290,8 +292,9 @@\n ;; frsqrt2      floating point reciprocal square root step2\n ;; multi\tmultiword sequence (or user asm statements)\n ;; nop\t\tno operation\n+;; ghost\tan instruction that produces no real code\n (define_attr \"type\"\n-  \"unknown,branch,jump,call,load,fpload,fpidxload,store,fpstore,fpidxstore,prefetch,prefetchx,condmove,mfc,mtc,mthilo,mfhilo,const,arith,logical,shift,slt,signext,clz,trap,imul,imul3,imadd,idiv,move,fmove,fadd,fmul,fmadd,fdiv,frdiv,frdiv1,frdiv2,fabs,fneg,fcmp,fcvt,fsqrt,frsqrt,frsqrt1,frsqrt2,multi,nop\"\n+  \"unknown,branch,jump,call,load,fpload,fpidxload,store,fpstore,fpidxstore,prefetch,prefetchx,condmove,mfc,mtc,mthilo,mfhilo,const,arith,logical,shift,slt,signext,clz,trap,imul,imul3,imadd,idiv,move,fmove,fadd,fmul,fmadd,fdiv,frdiv,frdiv1,frdiv2,fabs,fneg,fcmp,fcvt,fsqrt,frsqrt,frsqrt1,frsqrt2,multi,nop,ghost\"\n   (cond [(eq_attr \"jal\" \"!unset\") (const_string \"call\")\n \t (eq_attr \"got\" \"load\") (const_string \"load\")]\n \t(const_string \"unknown\")))\n@@ -438,17 +441,6 @@\n \t (const_string \"hilo\")]\n \t(const_string \"none\")))\n \n-;; Indicates which SET in an instruction pattern induces a hazard.\n-;; Only meaningful when \"hazard\" is not \"none\".  SINGLE means that\n-;; the pattern has only one set while the other values are indexes\n-;; into a PARALLEL vector.\n-;;\n-;; Hazardous instructions with multiple sets should generally put the\n-;; hazardous set first.  The only purpose of this attribute is to force\n-;; each multi-set pattern to explicitly assert that this condition holds.\n-(define_attr \"hazard_set\" \"single,0\"\n-  (const_string \"single\"))\n-\n ;; Is it a single instruction?\n (define_attr \"single_insn\" \"no,yes\"\n   (symbol_ref \"get_attr_length (insn) == (TARGET_MIPS16 ? 2 : 4)\"))\n@@ -703,6 +695,12 @@\n (define_cpu_unit \"alu\" \"alu\")\n (define_cpu_unit \"imuldiv\" \"imuldiv\")\n \n+;; Ghost instructions produce no real code and introduce no hazards.\n+;; They exist purely to express an effect on dataflow.\n+(define_insn_reservation \"ghost\" 0\n+  (eq_attr \"type\" \"ghost\")\n+  \"nothing\")\n+\n (include \"4k.md\")\n (include \"5k.md\")\n (include \"20kc.md\")\n@@ -5598,9 +5596,33 @@\n   DONE;\n })\n \n-(define_insn_and_split \"exception_receiver\"\n+(define_expand \"exception_receiver\"\n+  [(const_int 0)]\n+  \"TARGET_USE_GOT\"\n+{\n+  /* See the comment above load_call<mode> for details.  */\n+  emit_insn (gen_set_got_version ());\n+\n+  /* If we have a call-clobbered $gp, restore it from its save slot.  */\n+  if (HAVE_restore_gp)\n+    emit_insn (gen_restore_gp ());\n+  DONE;\n+})\n+\n+(define_expand \"nonlocal_goto_receiver\"\n+  [(const_int 0)]\n+  \"TARGET_USE_GOT\"\n+{\n+  /* See the comment above load_call<mode> for details.  */\n+  emit_insn (gen_set_got_version ());\n+  DONE;\n+})\n+\n+;; Restore $gp from its .cprestore stack slot.  The instruction remains\n+;; volatile until all uses of $28 are exposed.\n+(define_insn_and_split \"restore_gp\"\n   [(set (reg:SI 28)\n-\t(unspec_volatile:SI [(const_int 0)] UNSPEC_EH_RECEIVER))]\n+\t(unspec_volatile:SI [(const_int 0)] UNSPEC_RESTORE_GP))]\n   \"TARGET_CALL_CLOBBERED_GP\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -5629,24 +5651,66 @@\n ;; potentially modify the GOT entry.  And once a stub has been called,\n ;; we must not call it again.\n ;;\n-;; We represent this restriction using an imaginary fixed register that\n-;; is set by the GOT load and used by the call.  By making this register\n-;; call-clobbered, and by making the GOT load the only way of setting\n-;; the register, we ensure that the load cannot be moved past a call.\n+;; We represent this restriction using an imaginary, fixed, call-saved\n+;; register called GOT_VERSION_REGNUM.  The idea is to make the register\n+;; live throughout the function and to change its value after every\n+;; potential call site.  This stops any rtx value that uses the register\n+;; from being computed before an earlier call.  To do this, we:\n+;;\n+;;    - Ensure that the register is live on entry to the function,\n+;;\tso that it is never thought to be used uninitalized.\n+;;\n+;;    - Ensure that the register is live on exit from the function,\n+;;\tso that it is live throughout.\n+;;\n+;;    - Make each call (lazily-bound or not) use the current value\n+;;\tof GOT_VERSION_REGNUM, so that updates of the register are\n+;;\tnot moved across call boundaries.\n+;;\n+;;    - Add \"ghost\" definitions of the register to the beginning of\n+;;\tblocks reached by EH and ABNORMAL_CALL edges, because those\n+;;\tedges may involve calls that normal paths don't.  (E.g. the\n+;;\tunwinding code that handles a non-call exception may change\n+;;\tlazily-bound GOT entries.)  We do this by making the\n+;;\texception_receiver and nonlocal_goto_receiver expanders emit\n+;;\ta set_got_version instruction.\n+;;\n+;;    - After each call (lazily-bound or not), use a \"ghost\"\n+;;\tupdate_got_version instruction to change the register's value.\n+;;\tThis instruction mimics the _possible_ effect of the dynamic\n+;;\tresolver during the call and it remains live even if the call\n+;;\titself becomes dead.\n+;;\n+;;    - Leave GOT_VERSION_REGNUM out of all register classes.\n+;;\tThe register is therefore not a valid register_operand\n+;;\tand cannot be moved to or from other registers.\n (define_insn \"load_call<mode>\"\n   [(set (match_operand:P 0 \"register_operand\" \"=d\")\n \t(unspec:P [(match_operand:P 1 \"register_operand\" \"r\")\n-\t\t   (match_operand:P 2 \"immediate_operand\" \"\")]\n-\t\t  UNSPEC_LOAD_CALL))\n-   (set (reg:P FAKE_CALL_REGNO)\n-\t(unspec:P [(match_dup 2)] UNSPEC_LOAD_CALL))]\n+\t\t   (match_operand:P 2 \"immediate_operand\" \"\")\n+\t\t   (reg:SI GOT_VERSION_REGNUM)] UNSPEC_LOAD_CALL))]\n   \"TARGET_USE_GOT\"\n   \"<load>\\t%0,%R2(%1)\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"mode\" \"<MODE>\")\n-   (set_attr \"hazard_set\" \"0\")\n    (set_attr \"length\" \"4\")])\n \n+(define_insn \"set_got_version\"\n+  [(set (reg:SI GOT_VERSION_REGNUM)\n+\t(unspec_volatile:SI [(const_int 0)] UNSPEC_SET_GOT_VERSION))]\n+  \"TARGET_USE_GOT\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")\n+   (set_attr \"type\" \"ghost\")])\n+\n+(define_insn \"update_got_version\"\n+  [(set (reg:SI GOT_VERSION_REGNUM)\n+\t(unspec:SI [(reg:SI GOT_VERSION_REGNUM)] UNSPEC_UPDATE_GOT_VERSION))]\n+  \"TARGET_USE_GOT\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")\n+   (set_attr \"type\" \"ghost\")])\n+\n ;; Sibling calls.  All these patterns use jump instructions.\n \n ;; If TARGET_SIBCALLS, call_insn_operand will only accept constant"}, {"sha": "cf1f1daab58a8dc8b5d78dce9fce92b976f6cad9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc90b65652363253145276cde8cd57d55e53eb3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc90b65652363253145276cde8cd57d55e53eb3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dbc90b65652363253145276cde8cd57d55e53eb3", "patch": "@@ -1,3 +1,14 @@\n+2008-01-26  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\tPR target/34981\n+\t* gcc.target/mips/lazy-binding-1.c: New test.\n+\t* gcc.target/mips/mips.exp (setup_mips_tests): Set\n+\tmips_forced_no_abicalls and mips_forced_no_shared.\n+\t(dg-mips-options): Avoid using -mabicalls with an implicit -mabi=eabi.\n+\tAvoid using small data with -mabicalls.  Don't make -G0 force\n+\t-mn-abicalls.  Skip -mabicalls and -mshared tests if the multilib\n+\tforces the opposite option.\n+\n 2008-01-26  Danny Smith  <dannysmith@users.sourceforge.net>\n \n \tPR target/34970"}, {"sha": "eb4f808f7787f31b98c694ede8939a2f122d50c2", "filename": "gcc/testsuite/gcc.target/mips/lazy-binding-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc90b65652363253145276cde8cd57d55e53eb3/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Flazy-binding-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc90b65652363253145276cde8cd57d55e53eb3/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Flazy-binding-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Flazy-binding-1.c?ref=dbc90b65652363253145276cde8cd57d55e53eb3", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-mips-options \"-mabicalls -mshared -mexplicit-relocs -O2 -fno-delayed-branch\" } */\n+\n+void bar (void);\n+\n+void\n+foo (int n)\n+{\n+  while (n--)\n+    {\n+      bar ();\n+      bar ();\n+    }\n+}\n+\n+/* There should be exactly five uses of $25: one to set up $gp, two to\n+   load the address of bar (), and two to call it.  */\n+/* { dg-final { scan-assembler-times \"\\tl.\\t\\\\\\$25,%call16\\\\\\(bar\\\\\\)\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\tjalr\\t\\\\\\$25\" 2 } } */\n+/* { dg-final { scan-assembler \"(\\\\\\$28,|\\t.cpload\\t)\\\\\\$25\" } } */\n+/* { dg-final { scan-assembler-times \"\\\\\\$25\" 5 } } */"}, {"sha": "bd8b5fa78d6068df19c5b940924d411961f47b12", "filename": "gcc/testsuite/gcc.target/mips/mips.exp", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc90b65652363253145276cde8cd57d55e53eb3/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc90b65652363253145276cde8cd57d55e53eb3/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp?ref=dbc90b65652363253145276cde8cd57d55e53eb3", "patch": "@@ -44,6 +44,10 @@ load_lib gcc-dg.exp\n #    $mips_forced_be\t true if the command line uses -EB or -meb\n #    $mips_forced_le\t true if the command line uses -EL or -mel\n #    $mips_forced_gp\t true if the command line forces a particular GP mode\n+#    $mips_forced_no_abicalls\n+#\t\t\t true if the command line contains -mno-abicalls\n+#    $mips_forced_no_shared\n+#\t\t\t true if the command line contains -mno-shared\n #    $mips_forced_no_er  true if the command line contains -mno-explicit-relocs\n proc setup_mips_tests {} {\n     global mips_isa\n@@ -61,6 +65,8 @@ proc setup_mips_tests {} {\n     global mips_forced_be\n     global mips_forced_le\n     global mips_forced_gp\n+    global mips_forced_no_abicalls\n+    global mips_forced_no_shared\n     global mips_forced_no_er\n     global mips_forced_regs\n \n@@ -123,6 +129,8 @@ proc setup_mips_tests {} {\n     set mips_forced_be [regexp -- {-(EB|meb)[[:>:]]} $compiler_flags]\n     set mips_forced_le [regexp -- {-(EL|mel)[[:>:]]} $compiler_flags]\n     set mips_forced_gp [regexp -- {-(G|m(|no-)((extern|local)-sdata|gpopt)|mabicalls|mrtp)} $compiler_flags]\n+    set mips_forced_no_abicalls [regexp -- {-mno-abicalls} $compiler_flags]\n+    set mips_forced_no_shared [regexp -- {-mno-shared} $compiler_flags]\n     set mips_forced_no_er [regexp -- {-mno-explicit-relocs} $compiler_flags]\n \n     if {$mips_forced_regs && $mips_gp == 32 && $mips_fp == 64} {\n@@ -178,6 +186,11 @@ proc setup_mips_tests {} {\n #\tthe multilib flags already contain such an option, or specify\n #\tsomething that might be incompatible with them.\n #\n+#    -mabicalls\n+#    -mshared\n+#\tSelect the form of SVR4 PIC.  Skip the test if the multilib flags\n+#\tconflict with the required setting.\n+#\n #    -mexplicit-relocs\n #\tSelect explicit relocations.  Skip the test if the multilib flags\n #\tforce -mno-explicit-relocs.\n@@ -204,6 +217,8 @@ proc dg-mips-options {args} {\n     global mips_forced_be\n     global mips_forced_le\n     global mips_forced_gp\n+    global mips_forced_no_abicalls\n+    global mips_forced_no_shared\n     global mips_forced_no_er\n \n     set flags [lindex $args 1]\n@@ -281,6 +296,21 @@ proc dg-mips-options {args} {\n \t}\n     }\n \n+    foreach flag $flags {\n+\tif {[string match -mabicalls $flag]} {\n+\t    # EABI has no SVR4-style PIC mode, so try to force another ABI.\n+\t    if {$mips_abi == \"eabi\" && [lsearch $flags \"-mabi=*\"] < 0} {\n+\t\tif {$mips_new_gp == 32} {\n+\t\t    append flags \" -mabi=32\"\n+\t\t} else {\n+\t\t    append flags \" -mabi=n32\"\n+\t\t}\n+\t    }\n+\t    # Turn off small data, if on by default.\n+\t    append flags \" -G0\"\n+\t}\n+    }\n+\n     # Handle the other options.\n     foreach flag $flags {\n \tif {[regexp -- {^-mabi=(.*)} $flag dummy abi]} {\n@@ -313,10 +343,20 @@ proc dg-mips-options {args} {\n \t\tset matches 0\n \t    }\n \t} elseif {[regexp -- {^-(G|m(|no-)((extern|local)-sdata|gpopt))} $flag]} {\n-\t    append flags \" -mno-abicalls\"\n+\t    if {$flag != \"-G0\"} {\n+\t\tappend flags \" -mno-abicalls\"\n+\t    }\n \t    if {$mips_forced_gp} {\n \t\tset matches 0\n \t    }\n+\t} elseif {[regexp -- {^-mabicalls$} $flag]} {\n+\t    if {$mips_forced_no_abicalls} {\n+\t\tset matches 0\n+\t    }\n+\t} elseif {[regexp -- {^-mshared$} $flag]} {\n+\t    if {$mips_forced_no_shared} {\n+\t\tset matches 0\n+\t    }\n \t} elseif {[regexp -- {^-mexplicit-relocs$} $flag]} {\n \t    if {$mips_forced_no_er} {\n \t\tset matches 0"}]}