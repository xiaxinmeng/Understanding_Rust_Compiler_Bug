{"sha": "cbf560d708abe7f95490626d44f29d7c93650594", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JmNTYwZDcwOGFiZTdmOTU0OTA2MjZkNDRmMjlkN2M5MzY1MDU5NA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@netcologne.de", "date": "2015-06-06T16:12:39Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2015-06-06T16:12:39Z"}, "message": "re PR fortran/47359 (Recursive functions of intrinsic names generates invalid assembler)\n\n2015-06-06  Thomas Koenig  <tkoenig@netcologne.de>\n\n\tPR fortran/47359\n\t* arith.c (eval_intrinsic_op): Set warn flag for\n\tgfc_type_convert_binary if -Wconversion or -Wconversion-extra\n\tare set.\n\t(wprecision_real_real): New function.\n\t(wprecision_int_real): New function.\n\t(gfc_int2int): If -fno-range-check and -Wconversion are specified\n\tand it is a narrowing conversion, warn.\n\t(gfc_int2real): If there is a change in value for the conversion,\n\twarn.\n\t(gfc_int2complex):  Likewise.\n\t(gfc_real2int): If there is a fractional part to the real number,\n\twarn with -Wconversion, otherwise warn with -Wconversion-extra.\n\t(gfc_real2real): Emit warning if the constant was changed by\n\tconversion with either -Wconversion or -Wconversion-extra.  With\n\t-Wconversion-extra, warn if no warning was issued earlier.\n\t(gfc_real2complex):  Likewise.\n\t(gfc_complex2int): For -Wconversion or -Wconversion-extra, if\n\tthere was an imaginary part, warn; otherwise, warn for change in\n\tvalue.  Warn with -Wconversion-extra if no other warning was\n\tissued.\n\t(gfc_complex2real): For -Wconversion or -Wconversion-extra, if\n\tthere was an imaginary part, warn; otherwise, warn for change in\n\tvalue. Warn with -Wconversion-extra if no other warning was\n\tissued.\n\t(gfc_complex2complex):  For -Wconversion, warn if the value of\n\teither the real or the imaginary part was changed.  Warn for\n\t-Wconversion-extra if no prior warning was issued.\n\t* expr.c (gfc_check_assign):  Remove check for change in value.\n\t* primary.c (match_real_constant): For -Wconversion-extra, check\n\tagainst a number in which the last non-zero digit has been\n\treplaced with a zero.  If the number compares equal, warn.\n\t* intrinsic.c (gfc_convert_type_warn):  Do not warn about constant\n\tconversions.\n\n2015-06-06  Thomas Koenig  <tkoenig@netcologne.de>\n\n\tPR fortran/47359\n\t* gfortran.dg/array_constructor_type_17.f03: Adjust error message.\n\t* gfortran.dg/warn_conversion.f90: Add warning for change in value\n\tfor assignment.\n\t* gfortran.dg/warn_conversion_3.f90: Add warnings.\n\t* gfortran.dg/warn_conversion_5.f90: New test.\n\t* gfortran.dg/warn_conversion_6.f90: New test.\n\t* gfortran.dg/warn_conversion_7.f90: New test.\n\nFrom-SVN: r224190", "tree": {"sha": "795f1293f203f94163c691716e122d7f76b5c07b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/795f1293f203f94163c691716e122d7f76b5c07b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbf560d708abe7f95490626d44f29d7c93650594", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbf560d708abe7f95490626d44f29d7c93650594", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbf560d708abe7f95490626d44f29d7c93650594", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbf560d708abe7f95490626d44f29d7c93650594/comments", "author": {"login": "tkoenig1", "id": 12239367, "node_id": "MDQ6VXNlcjEyMjM5MzY3", "avatar_url": "https://avatars.githubusercontent.com/u/12239367?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tkoenig1", "html_url": "https://github.com/tkoenig1", "followers_url": "https://api.github.com/users/tkoenig1/followers", "following_url": "https://api.github.com/users/tkoenig1/following{/other_user}", "gists_url": "https://api.github.com/users/tkoenig1/gists{/gist_id}", "starred_url": "https://api.github.com/users/tkoenig1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tkoenig1/subscriptions", "organizations_url": "https://api.github.com/users/tkoenig1/orgs", "repos_url": "https://api.github.com/users/tkoenig1/repos", "events_url": "https://api.github.com/users/tkoenig1/events{/privacy}", "received_events_url": "https://api.github.com/users/tkoenig1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a7929c86043933f5190154abc038dac4dbc122d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a7929c86043933f5190154abc038dac4dbc122d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a7929c86043933f5190154abc038dac4dbc122d"}], "stats": {"total": 473, "additions": 408, "deletions": 65}, "files": [{"sha": "e32595b66cbcada1941b1e5a1b05e597ef8f3e63", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=cbf560d708abe7f95490626d44f29d7c93650594", "patch": "@@ -1,3 +1,40 @@\n+2015-06-06  Thomas Koenig  <tkoenig@netcologne.de>\n+\n+\tPR fortran/47359\n+\t* arith.c (eval_intrinsic_op): Set warn flag for\n+\tgfc_type_convert_binary if -Wconversion or -Wconversion-extra\n+\tare set.\n+\t(wprecision_real_real): New function.\n+\t(wprecision_int_real): New function.\n+\t(gfc_int2int): If -fno-range-check and -Wconversion are specified\n+\tand it is a narrowing conversion, warn.\n+\t(gfc_int2real): If there is a change in value for the conversion,\n+\twarn.\n+\t(gfc_int2complex):  Likewise.\n+\t(gfc_real2int): If there is a fractional part to the real number,\n+\twarn with -Wconversion, otherwise warn with -Wconversion-extra.\n+\t(gfc_real2real): Emit warning if the constant was changed by\n+\tconversion with either -Wconversion or -Wconversion-extra.  With\n+\t-Wconversion-extra, warn if no warning was issued earlier.\n+\t(gfc_real2complex):  Likewise.\n+\t(gfc_complex2int): For -Wconversion or -Wconversion-extra, if\n+\tthere was an imaginary part, warn; otherwise, warn for change in\n+\tvalue.  Warn with -Wconversion-extra if no other warning was\n+\tissued.\n+\t(gfc_complex2real): For -Wconversion or -Wconversion-extra, if\n+\tthere was an imaginary part, warn; otherwise, warn for change in\n+\tvalue. Warn with -Wconversion-extra if no other warning was\n+\tissued.\n+\t(gfc_complex2complex):  For -Wconversion, warn if the value of\n+\teither the real or the imaginary part was changed.  Warn for\n+\t-Wconversion-extra if no prior warning was issued.\n+\t* expr.c (gfc_check_assign):  Remove check for change in value.\n+\t* primary.c (match_real_constant): For -Wconversion-extra, check\n+\tagainst a number in which the last non-zero digit has been\n+\treplaced with a zero.  If the number compares equal, warn.\n+\t* intrinsic.c (gfc_convert_type_warn):  Do not warn about constant\n+\tconversions.\n+\n 2015-06-05  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/66347"}, {"sha": "d51fbc26be48fe75051df422c2fc9fba700ebca8", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 226, "deletions": 2, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=cbf560d708abe7f95490626d44f29d7c93650594", "patch": "@@ -1521,7 +1521,7 @@ eval_intrinsic (gfc_intrinsic_op op,\n       temp.value.op.op1 = op1;\n       temp.value.op.op2 = op2;\n \n-      gfc_type_convert_binary (&temp, 0);\n+      gfc_type_convert_binary (&temp, warn_conversion || warn_conversion_extra);\n \n       if (op == INTRINSIC_EQ || op == INTRINSIC_NE\n \t  || op == INTRINSIC_GE || op == INTRINSIC_GT\n@@ -1949,6 +1949,42 @@ arith_error (arith rc, gfc_typespec *from, gfc_typespec *to, locus *where)\n      NaN, etc.  */\n }\n \n+/* Returns true if significant bits were lost when converting real\n+   constant r from from_kind to to_kind.  */\n+\n+static bool\n+wprecision_real_real (mpfr_t r, int from_kind, int to_kind)\n+{\n+  mpfr_t rv, diff;\n+  bool ret;\n+\n+  gfc_set_model_kind (to_kind);\n+  mpfr_init (rv);\n+  gfc_set_model_kind (from_kind);\n+  mpfr_init (diff);\n+\n+  mpfr_set (rv, r, GFC_RND_MODE);\n+  mpfr_sub (diff, rv, r, GFC_RND_MODE);\n+\n+  ret = ! mpfr_zero_p (diff);\n+  mpfr_clear (rv);\n+  mpfr_clear (diff);\n+  return ret;\n+}\n+\n+/* Return true if conversion from an integer to a real loses precision.  */\n+\n+static bool\n+wprecision_int_real (mpz_t n, mpfr_t r)\n+{\n+  mpz_t i;\n+  mpz_init (i);\n+  mpfr_get_z (i, r, GFC_RND_MODE);\n+  mpz_sub (i, i, n);\n+  return mpz_cmp_si (i, 0) != 0;\n+  mpz_clear (i);\n+\n+}\n \n /* Convert integers to integers.  */\n \n@@ -1985,8 +2021,12 @@ gfc_int2int (gfc_expr *src, int kind)\n       k = gfc_validate_kind (BT_INTEGER, kind, false);\n       gfc_convert_mpz_to_signed (result->value.integer,\n \t\t\t\t gfc_integer_kinds[k].bit_size);\n-    }\n \n+      if (warn_conversion && kind < src->ts.kind)\n+\tgfc_warning_now (OPT_Wconversion, \"Conversion from %qs to %qs at %L\",\n+\t\t\t gfc_typename (&src->ts), gfc_typename (&result->ts),\n+\t\t\t &src->where);\n+    }\n   return result;\n }\n \n@@ -2010,6 +2050,14 @@ gfc_int2real (gfc_expr *src, int kind)\n       return NULL;\n     }\n \n+  if (warn_conversion\n+      && wprecision_int_real (src->value.integer, result->value.real))\n+    gfc_warning_now (OPT_Wconversion, \"Change of value in conversion \"\n+\t\t     \"from %qs to %qs at %L\",\n+\t\t     gfc_typename (&src->ts),\n+\t\t     gfc_typename (&result->ts),\n+\t\t     &src->where);\n+\n   return result;\n }\n \n@@ -2034,6 +2082,15 @@ gfc_int2complex (gfc_expr *src, int kind)\n       return NULL;\n     }\n \n+  if (warn_conversion\n+      && wprecision_int_real (src->value.integer,\n+\t\t\t      mpc_realref (result->value.complex)))\n+      gfc_warning_now (OPT_Wconversion, \"Change of value in conversion \"\n+\t\t       \"from %qs to %qs at %L\",\n+\t\t       gfc_typename (&src->ts),\n+\t\t       gfc_typename (&result->ts),\n+\t\t       &src->where);\n+\n   return result;\n }\n \n@@ -2045,6 +2102,7 @@ gfc_real2int (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n   arith rc;\n+  bool did_warn = false;\n \n   result = gfc_get_constant_expr (BT_INTEGER, kind, &src->where);\n \n@@ -2057,6 +2115,28 @@ gfc_real2int (gfc_expr *src, int kind)\n       return NULL;\n     }\n \n+  /* If there was a fractional part, warn about this.  */\n+\n+  if (warn_conversion)\n+    {\n+      mpfr_t f;\n+      mpfr_init (f);\n+      mpfr_frac (f, src->value.real, GFC_RND_MODE);\n+      if (mpfr_cmp_si (f, 0) != 0)\n+\t{\n+\t  gfc_warning_now (OPT_Wconversion, \"Change of value in conversion \"\n+\t\t\t   \"from %qs to %qs at %L\", gfc_typename (&src->ts),\n+\t\t\t   gfc_typename (&result->ts), &src->where);\n+\t  did_warn = true;\n+\t}\n+    }\n+  if (!did_warn && warn_conversion_extra)\n+    {\n+      gfc_warning_now (OPT_Wconversion_extra, \"Conversion from %qs to %qs \"\n+\t\t       \"at %L\", gfc_typename (&src->ts),\n+\t\t       gfc_typename (&result->ts), &src->where);\n+    }\n+\n   return result;\n }\n \n@@ -2068,6 +2148,7 @@ gfc_real2real (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n   arith rc;\n+  bool did_warn = false;\n \n   result = gfc_get_constant_expr (BT_REAL, kind, &src->where);\n \n@@ -2088,6 +2169,33 @@ gfc_real2real (gfc_expr *src, int kind)\n       return NULL;\n     }\n \n+  /* As a special bonus, don't warn about REAL values which are not changed by\n+     the conversion if -Wconversion is specified and -Wconversion-extra is\n+     not.  */\n+\n+  if ((warn_conversion || warn_conversion_extra) && src->ts.kind > kind)\n+    {\n+      int w = warn_conversion ? OPT_Wconversion : OPT_Wconversion_extra;\n+      \n+      /* Calculate the difference between the constant and the rounded\n+\t value and check it against zero.  */\n+\n+      if (wprecision_real_real (src->value.real, src->ts.kind, kind))\n+\t{\n+\t  gfc_warning_now (w, \"Change of value in conversion from \"\n+\t\t\t   \"%qs to %qs at %L\",\n+\t\t\t   gfc_typename (&src->ts), gfc_typename (&result->ts),\n+\t\t\t   &src->where);\n+\t  /* Make sure the conversion warning is not emitted again.  */\n+\t  did_warn = true;\n+\t}\n+    }\n+\n+    if (!did_warn && warn_conversion_extra)\n+      gfc_warning_now (OPT_Wconversion_extra, \"Conversion from %qs to %qs \"\n+\t\t       \"at %L\", gfc_typename(&src->ts),\n+\t\t       gfc_typename(&result->ts), &src->where);\n+\n   return result;\n }\n \n@@ -2099,6 +2207,7 @@ gfc_real2complex (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n   arith rc;\n+  bool did_warn = false;\n \n   result = gfc_get_constant_expr (BT_COMPLEX, kind, &src->where);\n \n@@ -2119,6 +2228,26 @@ gfc_real2complex (gfc_expr *src, int kind)\n       return NULL;\n     }\n \n+  if ((warn_conversion || warn_conversion_extra) && src->ts.kind > kind)\n+    {\n+      int w = warn_conversion ? OPT_Wconversion : OPT_Wconversion_extra;\n+\n+      if (wprecision_real_real (src->value.real, src->ts.kind, kind))\n+\t{\n+\t  gfc_warning_now (w, \"Change of value in conversion from \"\n+\t\t\t   \"%qs to %qs at %L\",\n+\t\t\t   gfc_typename (&src->ts), gfc_typename (&result->ts),\n+\t\t\t   &src->where);\n+\t  /* Make sure the conversion warning is not emitted again.  */\n+\t  did_warn = true;\n+\t}\n+    }\n+\n+  if (!did_warn && warn_conversion_extra)\n+    gfc_warning_now (OPT_Wconversion_extra, \"Conversion from %qs to %qs \"\n+\t\t     \"at %L\", gfc_typename(&src->ts),\n+\t\t     gfc_typename(&result->ts), &src->where);\n+\n   return result;\n }\n \n@@ -2130,6 +2259,7 @@ gfc_complex2int (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n   arith rc;\n+  bool did_warn = false;\n \n   result = gfc_get_constant_expr (BT_INTEGER, kind, &src->where);\n \n@@ -2143,6 +2273,43 @@ gfc_complex2int (gfc_expr *src, int kind)\n       return NULL;\n     }\n \n+  if (warn_conversion || warn_conversion_extra)\n+    {\n+      int w = warn_conversion ? OPT_Wconversion : OPT_Wconversion_extra;\n+\n+      /* See if we discarded an imaginary part.  */\n+      if (mpfr_cmp_si (mpc_imagref (src->value.complex), 0) != 0)\n+\t{\n+\t  gfc_warning_now (w, \"Non-zero imaginary part discarded \"\n+\t\t\t   \"in conversion from %qs to %qs at %L\",\n+\t\t\t   gfc_typename(&src->ts), gfc_typename (&result->ts),\n+\t\t\t   &src->where);\n+\t  did_warn = true;\n+\t}\n+\n+      else {\n+\tmpfr_t f;\n+\n+\tmpfr_init (f);\n+\tmpfr_frac (f, src->value.real, GFC_RND_MODE);\n+\tif (mpfr_cmp_si (f, 0) != 0)\n+\t  {\n+\t    gfc_warning_now (w, \"Change of value in conversion from \"\n+\t\t\t     \"%qs to %qs at %L\", gfc_typename (&src->ts),\n+\t\t\t     gfc_typename (&result->ts), &src->where);\n+\t    did_warn = true;\n+\t  }\n+\tmpfr_clear (f);\n+      }\n+\n+      if (!did_warn && warn_conversion_extra)\n+\t{\n+\t  gfc_warning_now (OPT_Wconversion_extra, \"Conversion from %qs to %qs \"\n+\t\t\t   \"at %L\", gfc_typename (&src->ts),\n+\t\t\t   gfc_typename (&result->ts), &src->where);\n+\t}\n+    }\n+\n   return result;\n }\n \n@@ -2154,6 +2321,7 @@ gfc_complex2real (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n   arith rc;\n+  bool did_warn = false;\n \n   result = gfc_get_constant_expr (BT_REAL, kind, &src->where);\n \n@@ -2174,6 +2342,41 @@ gfc_complex2real (gfc_expr *src, int kind)\n       return NULL;\n     }\n \n+  if (warn_conversion || warn_conversion_extra)\n+    {\n+      int w = warn_conversion ? OPT_Wconversion : OPT_Wconversion_extra;\n+\n+      /* See if we discarded an imaginary part.  */\n+      if (mpfr_cmp_si (mpc_imagref (src->value.complex), 0) != 0)\n+\t{\n+\t  gfc_warning_now (w, \"Non-zero imaginary part discarded \"\n+\t\t\t   \"in conversion from %qs to %qs at %L\",\n+\t\t\t   gfc_typename(&src->ts), gfc_typename (&result->ts),\n+\t\t\t   &src->where);\n+\t  did_warn = true;\n+\t}\n+\n+      /* Calculate the difference between the real constant and the rounded\n+\t value and check it against zero.  */\n+      \n+      if (kind > src->ts.kind\n+\t  && wprecision_real_real (mpc_realref (src->value.complex),\n+\t\t\t\t   src->ts.kind, kind))\n+\t{\n+\t  gfc_warning_now (w, \"Change of value in conversion from \"\n+\t\t\t   \"%qs to %qs at %L\",\n+\t\t\t   gfc_typename (&src->ts), gfc_typename (&result->ts),\n+\t\t\t   &src->where);\n+\t  /* Make sure the conversion warning is not emitted again.  */\n+\t  did_warn = true;\n+\t}\n+    }\n+\n+  if (!did_warn && warn_conversion_extra)\n+    gfc_warning_now (OPT_Wconversion, \"Conversion from %qs to %qs at %L\",\n+\t\t     gfc_typename(&src->ts), gfc_typename (&result->ts),\n+\t\t     &src->where);\n+\n   return result;\n }\n \n@@ -2185,6 +2388,7 @@ gfc_complex2complex (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n   arith rc;\n+  bool did_warn = false;\n \n   result = gfc_get_constant_expr (BT_COMPLEX, kind, &src->where);\n \n@@ -2220,6 +2424,26 @@ gfc_complex2complex (gfc_expr *src, int kind)\n       return NULL;\n     }\n \n+  if ((warn_conversion || warn_conversion_extra) && src->ts.kind > kind\n+      && (wprecision_real_real (mpc_realref (src->value.complex),\n+\t\t\t\tsrc->ts.kind, kind)\n+\t  || wprecision_real_real (mpc_imagref (src->value.complex),\n+\t\t\t\t   src->ts.kind, kind)))\n+    {\n+      int w = warn_conversion ? OPT_Wconversion : OPT_Wconversion_extra;\n+\n+      gfc_warning_now (w, \"Change of value in conversion from \"\n+\t\t       \" %qs to %qs at %L\",\n+\t\t       gfc_typename (&src->ts), gfc_typename (&result->ts),\n+\t\t       &src->where);\n+      did_warn = true;\n+    }\n+\n+  if (!did_warn && warn_conversion_extra && src->ts.kind != kind)\n+    gfc_warning_now (OPT_Wconversion_extra, \"Conversion from %qs to %qs \"\n+\t\t     \"at %L\", gfc_typename(&src->ts),\n+\t\t     gfc_typename (&result->ts), &src->where);\n+\n   return result;\n }\n "}, {"sha": "d7a90c442444b0ad5443bf77ce734bf8caec14cc", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=cbf560d708abe7f95490626d44f29d7c93650594", "patch": "@@ -3247,55 +3247,6 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n \t}\n     }\n \n-  /*  Warn about type-changing conversions for REAL or COMPLEX constants.\n-      If lvalue and rvalue are mixed REAL and complex, gfc_compare_types\n-      will warn anyway, so there is no need to to so here.  */\n-\n-  if (rvalue->expr_type == EXPR_CONSTANT && lvalue->ts.type == rvalue->ts.type\n-      && (lvalue->ts.type == BT_REAL || lvalue->ts.type == BT_COMPLEX))\n-    {\n-      if (lvalue->ts.kind < rvalue->ts.kind && warn_conversion)\n-\t{\n-\t  /* As a special bonus, don't warn about REAL rvalues which are not\n-\t     changed by the conversion if -Wconversion is specified.  */\n-\t  if (rvalue->ts.type == BT_REAL && mpfr_number_p (rvalue->value.real))\n-\t    {\n-\t      /* Calculate the difference between the constant and the rounded\n-\t\t value and check it against zero.  */\n-\t      mpfr_t rv, diff;\n-\t      gfc_set_model_kind (lvalue->ts.kind);\n-\t      mpfr_init (rv);\n-\t      gfc_set_model_kind (rvalue->ts.kind);\n-\t      mpfr_init (diff);\n-\n-\t      mpfr_set (rv, rvalue->value.real, GFC_RND_MODE);\n-\t      mpfr_sub (diff, rv, rvalue->value.real, GFC_RND_MODE);\n-\n-\t      if (!mpfr_zero_p (diff))\n-\t\tgfc_warning (OPT_Wconversion, \n-\t\t\t     \"Change of value in conversion from \"\n-\t\t\t     \" %qs to %qs at %L\", gfc_typename (&rvalue->ts),\n-\t\t\t     gfc_typename (&lvalue->ts), &rvalue->where);\n-\n-\t      mpfr_clear (rv);\n-\t      mpfr_clear (diff);\n-\t    }\n-\t  else\n-\t    gfc_warning (OPT_Wconversion,\n-\t\t\t \"Possible change of value in conversion from %qs \"\n-\t\t\t \"to %qs at %L\", gfc_typename (&rvalue->ts),\n-\t\t\t gfc_typename (&lvalue->ts), &rvalue->where);\n-\n-\t}\n-      else if (warn_conversion_extra && lvalue->ts.kind > rvalue->ts.kind)\n-\t{\n-\t  gfc_warning (OPT_Wconversion_extra,\n-\t\t       \"Conversion from %qs to %qs at %L\",\n-\t\t       gfc_typename (&rvalue->ts),\n-\t\t       gfc_typename (&lvalue->ts), &rvalue->where);\n-\t}\n-    }\n-\n   if (gfc_compare_types (&lvalue->ts, &rvalue->ts))\n     return true;\n "}, {"sha": "5666bfff9a26e063fb2701e6c10eeeee86ec78ca", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=cbf560d708abe7f95490626d44f29d7c93650594", "patch": "@@ -4695,23 +4695,26 @@ gfc_convert_type_warn (gfc_expr *expr, gfc_typespec *ts, int eflag, int wflag)\n \t  /* Larger kinds can hold values of smaller kinds without problems.\n \t     Hence, only warn if target kind is smaller than the source\n \t     kind - or if -Wconversion-extra is specified.  */\n-\t  if (warn_conversion && from_ts.kind > ts->kind)\n-\t    gfc_warning_now (OPT_Wconversion, \"Possible change of value in \"\n-\t\t\t     \"conversion from %s to %s at %L\",\n-\t\t\t     gfc_typename (&from_ts), gfc_typename (ts),\n-\t\t\t     &expr->where);\n-\t  else if (warn_conversion_extra)\n-\t    gfc_warning_now (OPT_Wconversion_extra, \"Conversion from %s to %s \"\n-\t\t\t     \"at %L\", gfc_typename (&from_ts),\n-\t\t\t     gfc_typename (ts), &expr->where);\n+\t  if (expr->expr_type != EXPR_CONSTANT)\n+\t    {\n+\t      if (warn_conversion && from_ts.kind > ts->kind)\n+\t\tgfc_warning_now (OPT_Wconversion, \"Possible change of value in \"\n+\t\t\t\t \"conversion from %s to %s at %L\",\n+\t\t\t\t gfc_typename (&from_ts), gfc_typename (ts),\n+\t\t\t\t &expr->where);\n+\t      else if (warn_conversion_extra)\n+\t\tgfc_warning_now (OPT_Wconversion_extra, \"Conversion from %s to %s \"\n+\t\t\t\t \"at %L\", gfc_typename (&from_ts),\n+\t\t\t\t gfc_typename (ts), &expr->where);\n+\t    }\n \t}\n       else if ((from_ts.type == BT_REAL && ts->type == BT_INTEGER)\n \t       || (from_ts.type == BT_COMPLEX && ts->type == BT_INTEGER)\n \t       || (from_ts.type == BT_COMPLEX && ts->type == BT_REAL))\n \t{\n \t  /* Conversion from REAL/COMPLEX to INTEGER or COMPLEX to REAL\n \t     usually comes with a loss of information, regardless of kinds.  */\n-\t  if (warn_conversion)\n+\t  if (warn_conversion && expr->expr_type != EXPR_CONSTANT)\n \t    gfc_warning_now (OPT_Wconversion, \"Possible change of value in \"\n \t\t\t     \"conversion from %s to %s at %L\",\n \t\t\t     gfc_typename (&from_ts), gfc_typename (ts),"}, {"sha": "e467e0b3ff0f1ae050bfa008a4ac5bf811ead248", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=cbf560d708abe7f95490626d44f29d7c93650594", "patch": "@@ -736,6 +736,58 @@ match_real_constant (gfc_expr **result, int signflag)\n       gfc_internal_error (\"gfc_range_check() returned bad value\");\n     }\n \n+  /* Warn about trailing digits which suggest the user added too many\n+     trailing digits, which may cause the appearance of higher pecision\n+     than the kind kan support.\n+\n+     This is done by replacing the rightmost non-zero digit with zero\n+     and comparing with the original value.  If these are equal, we\n+     assume the user supplied more digits than intended (or forgot to\n+     convert to the correct kind).\n+  */\n+\n+  if (warn_conversion_extra)\n+    {\n+      mpfr_t r;\n+      char *c, *p;\n+      bool did_break;\n+\n+      c = strchr (buffer, 'e');\n+      if (c == NULL)\n+\tc = buffer + strlen(buffer);\n+\n+      did_break = false;\n+      for (p = c - 1; p >= buffer; p--)\n+\t{\n+\t  if (*p == '.')\n+\t    continue;\n+\t  \n+\t  if (*p != '0')\n+\t    {\n+\t      *p = '0';\n+\t      did_break = true;\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (did_break)\n+\t{\n+\t  mpfr_init (r);\n+\t  mpfr_set_str (r, buffer, 10, GFC_RND_MODE);\n+\t  if (negate)\n+\t    mpfr_neg (r, r, GFC_RND_MODE);\n+\n+\t  mpfr_sub (r, r, e->value.real, GFC_RND_MODE);\n+\n+\t  if (mpfr_cmp_ui (r, 0) == 0)\n+\t    gfc_warning (OPT_Wconversion_extra, \"Non-significant digits \"\n+\t\t\t \"in %qs number at %C, maybe incorrect KIND\",\n+\t\t\t gfc_typename (&e->ts));\n+\n+\t  mpfr_clear (r);\n+\t}\n+    }\n+\n   *result = e;\n   return MATCH_YES;\n "}, {"sha": "057ddb9aa70acd0768b4b8252d4a9b11b829d7a3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cbf560d708abe7f95490626d44f29d7c93650594", "patch": "@@ -1,3 +1,14 @@\n+2015-06-06  Thomas Koenig  <tkoenig@netcologne.de>\n+\n+\tPR fortran/47359\n+\t* gfortran.dg/array_constructor_type_17.f03: Adjust error message.\n+\t* gfortran.dg/warn_conversion.f90: Add warning for change in value\n+\tfor assignment.\n+\t* gfortran.dg/warn_conversion_3.f90: Add warnings.\n+\t* gfortran.dg/warn_conversion_5.f90: New test.\n+\t* gfortran.dg/warn_conversion_6.f90: New test.\n+\t* gfortran.dg/warn_conversion_7.f90: New test.\n+\n 2015-06-05  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/66347"}, {"sha": "6e009e12547b6e1de2f3e16ce0c49b1838c2e1fc", "filename": "gcc/testsuite/gfortran.dg/array_constructor_type_17.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_type_17.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_type_17.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_type_17.f03?ref=cbf560d708abe7f95490626d44f29d7c93650594", "patch": "@@ -8,5 +8,5 @@ PROGRAM test\n   IMPLICIT NONE\n \n   INTEGER(KIND=4) :: arr(1)\n-  arr = (/ INTEGER(KIND=4) :: HUGE(0_8) /) ! { dg-warning \"conversion from\" }\n+  arr = (/ INTEGER(KIND=4) :: HUGE(0_8) /) ! { dg-warning \"Conversion\" }\n END PROGRAM test"}, {"sha": "5bc96cc69d294511f7605d1acdc2f0563fe5a7da", "filename": "gcc/testsuite/gfortran.dg/warn_conversion.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarn_conversion.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarn_conversion.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarn_conversion.f90?ref=cbf560d708abe7f95490626d44f29d7c93650594", "patch": "@@ -18,7 +18,7 @@ SUBROUTINE pr27866c4\n   integer(kind=4) :: i4\n   i4 = 2.3              ! { dg-warning \"conversion\" }\n   i1 = 500              ! { dg-error \"overflow\" }\n-  a = 2**26-1           ! assignment INTEGER(4) to REAL(4) - no warning\n+  a = 2**26-1           ! { dg-warning \"Change of value in conversion\" }\n   b = 1d999             ! { dg-error \"overflow\" }\n \n   a = i4                ! assignment INTEGER(4) to REAL(4) - no warning"}, {"sha": "c50c03291664fde586be73128bf14069e0587bb0", "filename": "gcc/testsuite/gfortran.dg/warn_conversion_3.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarn_conversion_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarn_conversion_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarn_conversion_3.f90?ref=cbf560d708abe7f95490626d44f29d7c93650594", "patch": "@@ -7,8 +7,8 @@ program main\n   complex(8), parameter :: z = cmplx (0.5, 0.5)  ! { dg-warning \"Conversion\" }\n   real :: r1, r2\n   r1 = 2.3d0 ! { dg-warning \"Change of value in conversion\" }\n-  r2 = 2.5d0 ! No warning because the value does not change\n+  r2 = 2.5d0 ! { dg-warning \"Conversion\" }\n   d1 = .13 ! { dg-warning \"Conversion\" }\n   d2 = .13d0\n-  d1 = z     ! { dg-warning \"change of value in conversion\" }\n+  d1 = z     ! { dg-warning \"Non-zero imaginary part\" }\n end program main"}, {"sha": "f5e7c4e564b37f09f552d48752d217d2912f49c5", "filename": "gcc/testsuite/gfortran.dg/warn_conversion_5.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarn_conversion_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarn_conversion_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarn_conversion_5.f90?ref=cbf560d708abe7f95490626d44f29d7c93650594", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile }\n+! { dg-options \"-Wconversion\" }\n+! PR 47359 - additional warnings for conversions.\n+program main\n+  implicit none\n+  complex(kind=4) :: c4\n+  complex(kind=8) :: c8\n+  real(kind=4) :: r4\n+  real(kind=8) :: r8\n+  complex(kind=4), parameter :: c4p = (1.0, -4.)\n+  complex, parameter :: c8w = (1.0_8, -4.2_8) ! { dg-warning \"Change of value in conversion\" }\n+  complex (kind=8), parameter :: c8p = (1.0_8, -4.2_8)\n+  integer :: i\n+\n+  c4 = c8p ! { dg-warning \"Change of value in conversion\" }\n+  c4 = 2**26 + 1 ! { dg-warning \"Change of value in conversion\" }\n+  c4 = 1.3d0     ! { dg-warning \"Change of value in conversion\" }\n+  c4 = c8p       ! { dg-warning \"Change of value in conversion\" }\n+  c4 = (1.2, 1000000001) ! { dg-warning \"Change of value in conversion\" }\n+  r4 = (2**26 + 1) * 2.3 ! { dg-warning \"Change of value in conversion\" }\n+  r4 = 2.4d0 ! { dg-warning \"Change of value\" }\n+  r4 = c4p ! { dg-warning \"Non-zero imaginary part\" }\n+  r4 = r4 + 2.3d0 ! { dg-warning \"Possible change of value in conversion\" }\n+  r8 = 2_8**62 - 1_8 ! { dg-warning \"Change of value in conversion\" }\n+  i = c4p ! { dg-warning \"Non-zero imaginary part\" }\n+  i = 42 + 1.3 ! { dg-warning \"Change of value in conversion\" }\n+  i = (1.2, 0.) ! { dg-warning \"Change of value in conversion\" }\n+  c4 = 1.2       ! no warning\n+  c4 = -3.25d0   ! no warning\n+  c4 = -42       ! no warning\n+  c8 = 2**26 + 1 ! no warning\n+  i = 22.        ! no warning\n+  i = (35., 0.)  ! no warning\n+  r4 = 2.5d0     ! no warning\n+  r4 = 235       ! no warning\n+  r8 = 2.3       ! no warning\n+end program main"}, {"sha": "e16a62e7f8cfb97417637bc5223dce53a5e795f8", "filename": "gcc/testsuite/gfortran.dg/warn_conversion_6.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarn_conversion_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarn_conversion_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarn_conversion_6.f90?ref=cbf560d708abe7f95490626d44f29d7c93650594", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+! { dg-options \"-Wconversion -Wconversion-extra\" }\n+! PR 47359 - additional warnings for conversions.\n+program main\n+  implicit none\n+  real(kind=8) :: a,b\n+  complex(kind=8) :: c\n+  integer :: i\n+  real(kind=4) :: r\n+  a = 0.13              ! { dg-warning \"Conversion\" }\n+  print *,0.1_8 ** 0.2  ! { dg-warning \"Conversion\" }\n+  b = a/0.13            ! { dg-warning \"Conversion\" }\n+  i = 12345.            ! { dg-warning \"Conversion\" }\n+  i = (1., 23.)         ! { dg-warning \"Non-zero imaginary part\" }\n+  r = (1., 23.)         ! { dg-warning \"Non-zero imaginary part\" }\n+  b = 0.&                 ! { dg-warning \"Possible change of value\" }\n+       &5_8*c             ! { dg-warning \"Conversion\" }\n+  c = 0.3               ! { dg-warning \"Conversion\" }\n+  a = 0.5               ! { dg-warning \"Conversion\" }\n+end program main\n+  "}, {"sha": "88f5bf1c67c993b83aeb016fc02ce25d77c8f5a8", "filename": "gcc/testsuite/gfortran.dg/warn_conversion_7.f90", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarn_conversion_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf560d708abe7f95490626d44f29d7c93650594/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarn_conversion_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarn_conversion_7.f90?ref=cbf560d708abe7f95490626d44f29d7c93650594", "patch": "@@ -0,0 +1,7 @@\n+! { dg-do compile }\n+! { dg-options \"-Wconversion-extra -Wconversion\" }\n+program main\n+  implicit none\n+  double precision, parameter :: pi = &  ! { dg-warning \"Conversion\" }\n+       & 3.1415829535897932     ! { dg-warning \"Non-significant digits\" }\n+end program main"}]}