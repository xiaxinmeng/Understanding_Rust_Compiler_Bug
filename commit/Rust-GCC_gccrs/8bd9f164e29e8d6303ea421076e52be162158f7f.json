{"sha": "8bd9f164e29e8d6303ea421076e52be162158f7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJkOWYxNjRlMjllOGQ2MzAzZWE0MjEwNzZlNTJiZTE2MjE1OGY3Zg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2016-12-08T23:50:40Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-12-08T23:50:40Z"}, "message": "PR c/77531 - __attribute__((alloc_size(1,2))) could also warn on multiplication overflow\n\nPR c/77531 - __attribute__((alloc_size(1,2))) could also warn on multiplication overflow\nPR c/78284 - warn on malloc with very large arguments\n\ngcc/c-family/ChangeLog:\n\n\tPR c/78284\n\t* c.opt (-Walloc-zero, -Walloc-size-larger-than): New options.\n\ngcc/ChangeLog:\n\n\tPR c/78284\n\t* builtin-attrs.def (ATTR_ALLOC_SIZE, ATTR_RETURNS_NONNULL): New\n\tidentifier tree nodes.\n\t(ATTR_ALLOCA_SIZE_1_NOTHROW_LEAF_LIST): New attribute list.\n\t(ATTR_MALLOC_SIZE_1_NOTHROW_LIST): Same.\n\t(ATTR_MALLOC_SIZE_1_NOTHROW_LEAF_LIST): Same.\n\t(ATTR_MALLOC_SIZE_1_2_NOTHROW_LEAF_LIST): Same.\n\t(ATTR_ALLOC_SIZE_2_NOTHROW_LEAF_LIST): Same.\n\t* builtins.c (expand_builtin_alloca): Call\n\tmaybe_warn_alloc_args_overflow.\n\t* builtins.def (aligned_alloc, calloc, malloc, realloc):\n\tAdd attribute alloc_size.\n\t(alloca): Add attribute alloc_size and returns_nonnull.\n\t* calls.h (maybe_warn_alloc_args_overflow): Declare.\n\t* calls.c (alloc_max_size, operand_signed_p): New functions.\n\t(maybe_warn_alloc_args_overflow): Define.\n\t(initialize_argument_information): Diagnose overflow in functions\n\tdeclared with attaribute alloc_size.\n\t* doc/invoke.texi (Warning Options): Document -Walloc-zero and\n\t-Walloc-size-larger-than.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c/78284\n\t* gcc.dg/attr-alloc_size-3.c: New test.\n\t* gcc.dg/attr-alloc_size-4.c: New test.\n\t* gcc.dg/attr-alloc_size-5.c: New test.\n\t* gcc.dg/attr-alloc_size-6.c: New test.\n\t* gcc.dg/attr-alloc_size-7.c: New test.\n\t* gcc.dg/attr-alloc_size-8.c: New test.\n\t* gcc.dg/attr-alloc_size-9.c: New test.\n\t* gcc/testsuite/gcc.dg/errno-1.c: Adjust.\n\nFrom-SVN: r243470", "tree": {"sha": "1265e2a8ec25f7020ef6c9eb300baef80c2e2afa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1265e2a8ec25f7020ef6c9eb300baef80c2e2afa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8bd9f164e29e8d6303ea421076e52be162158f7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bd9f164e29e8d6303ea421076e52be162158f7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bd9f164e29e8d6303ea421076e52be162158f7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bd9f164e29e8d6303ea421076e52be162158f7f/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "410aa8982fcea63dc2e823aa48e554a33f1fc1d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/410aa8982fcea63dc2e823aa48e554a33f1fc1d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/410aa8982fcea63dc2e823aa48e554a33f1fc1d3"}], "stats": {"total": 1569, "additions": 1563, "deletions": 6}, "files": [{"sha": "f8455c5977979155bcdd8f5605c31b2504235561", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8bd9f164e29e8d6303ea421076e52be162158f7f", "patch": "@@ -1,3 +1,26 @@\n+2016-12-08  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/78284\n+\t* builtin-attrs.def (ATTR_ALLOC_SIZE, ATTR_RETURNS_NONNULL): New\n+\tidentifier tree nodes.\n+\t(ATTR_ALLOCA_SIZE_1_NOTHROW_LEAF_LIST): New attribute list.\n+\t(ATTR_MALLOC_SIZE_1_NOTHROW_LIST): Same.\n+\t(ATTR_MALLOC_SIZE_1_NOTHROW_LEAF_LIST): Same.\n+\t(ATTR_MALLOC_SIZE_1_2_NOTHROW_LEAF_LIST): Same.\n+\t(ATTR_ALLOC_SIZE_2_NOTHROW_LEAF_LIST): Same.\n+\t* builtins.c (expand_builtin_alloca): Call\n+\tmaybe_warn_alloc_args_overflow.\n+\t* builtins.def (aligned_alloc, calloc, malloc, realloc):\n+\tAdd attribute alloc_size.\n+\t(alloca): Add attribute alloc_size and returns_nonnull.\n+\t* calls.h (maybe_warn_alloc_args_overflow): Declare.\n+\t* calls.c (alloc_max_size, operand_signed_p): New functions.\n+\t(maybe_warn_alloc_args_overflow): Define.\n+\t(initialize_argument_information): Diagnose overflow in functions\n+\tdeclared with attaribute alloc_size.\n+\t* doc/invoke.texi (Warning Options): Document -Walloc-zero and\n+\t-Walloc-size-larger-than.\n+\n 2016-12-08  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/78671"}, {"sha": "20515e74235f3fc9f78ec78fbf20265ce649589f", "filename": "gcc/builtins.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=8bd9f164e29e8d6303ea421076e52be162158f7f", "patch": "@@ -4797,19 +4797,31 @@ expand_builtin_alloca (tree exp, bool cannot_accumulate)\n {\n   rtx op0;\n   rtx result;\n-  bool valid_arglist;\n   unsigned int align;\n-  bool alloca_with_align = (DECL_FUNCTION_CODE (get_callee_fndecl (exp))\n+  tree fndecl = get_callee_fndecl (exp);\n+  bool alloca_with_align = (DECL_FUNCTION_CODE (fndecl)\n \t\t\t    == BUILT_IN_ALLOCA_WITH_ALIGN);\n \n-  valid_arglist\n+  bool valid_arglist\n     = (alloca_with_align\n        ? validate_arglist (exp, INTEGER_TYPE, INTEGER_TYPE, VOID_TYPE)\n        : validate_arglist (exp, INTEGER_TYPE, VOID_TYPE));\n \n   if (!valid_arglist)\n     return NULL_RTX;\n \n+  if ((alloca_with_align && !warn_vla_limit)\n+      || (!alloca_with_align && !warn_alloca_limit))\n+    {\n+      /* -Walloca-larger-than and -Wvla-larger-than settings override\n+\t the more general -Walloc-size-larger-than so unless either of\n+\t the former options is specified check the alloca arguments for\n+\t overflow.  */\n+      tree args[] = { CALL_EXPR_ARG (exp, 0), NULL_TREE };\n+      int idx[] = { 0, -1 };\n+      maybe_warn_alloc_args_overflow (fndecl, exp, args, idx);\n+    }\n+\n   /* Compute the argument.  */\n   op0 = expand_normal (CALL_EXPR_ARG (exp, 0));\n "}, {"sha": "d6e1b8b15b04735e013bdc3e6ce9ef39a5062721", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=8bd9f164e29e8d6303ea421076e52be162158f7f", "patch": "@@ -1,3 +1,8 @@\n+2016-12-08  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/78284\n+\t* c.opt (-Walloc-zero, -Walloc-size-larger-than): New options.\n+\n 2016-12-08  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/78165"}, {"sha": "33c5def759296d22438560c65c7fc215a5e6ea71", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=8bd9f164e29e8d6303ea421076e52be162158f7f", "patch": "@@ -303,6 +303,15 @@ Walloca\n C ObjC C++ ObjC++ Var(warn_alloca) Warning\n Warn on any use of alloca.\n \n+Walloc-size-larger-than=\n+C ObjC C++ ObjC++ Var(warn_alloc_size_limit) Warning Joined\n+-Walloc-size-larger-than=<bytes> Warn for calls to allocation functions that\n+attempt to allocate objects larger than the specified number of bytes.\n+\n+Walloc-zero\n+C ObjC C++ ObjC++ Var(warn_alloc_zero) Warning\n+-Walloc-zero Warn for calls to allocation functions that specify zero bytes.\n+\n Walloca-larger-than=\n C ObjC C++ ObjC++ Var(warn_alloca_limit) Warning Joined RejectNegative UInteger\n -Walloca-larger-than=<number> Warn on unbounded uses of"}, {"sha": "bc3cbd599fc321a5422a2a7b214952eb14aded71", "filename": "gcc/calls.c", "status": "modified", "additions": 340, "deletions": 1, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=8bd9f164e29e8d6303ea421076e52be162158f7f", "patch": "@@ -48,8 +48,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"rtl-iter.h\"\n #include \"tree-chkp.h\"\n+#include \"tree-vrp.h\"\n+#include \"tree-ssanames.h\"\n #include \"rtl-chkp.h\"\n-\n+#include \"intl.h\"\n \n /* Like PREFERRED_STACK_BOUNDARY but in units of bytes, not bits.  */\n #define STACK_BYTES (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)\n@@ -1181,6 +1183,311 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n       }\n }\n \n+/* The limit set by -Walloc-larger-than=.  */\n+static GTY(()) tree alloc_object_size_limit;\n+\n+/* Initialize ALLOC_OBJECT_SIZE_LIMIT based on the -Walloc-size-larger-than=\n+   setting if the option is specified, or to the maximum object size if it\n+   is not.  Return the initialized value.  */\n+\n+static tree\n+alloc_max_size (void)\n+{\n+  if (!alloc_object_size_limit)\n+    {\n+      alloc_object_size_limit = TYPE_MAX_VALUE (ssizetype);\n+\n+      unsigned HOST_WIDE_INT unit = 1;\n+\n+      char *end;\n+      errno = 0;\n+      unsigned HOST_WIDE_INT limit\n+\t= warn_alloc_size_limit ? strtoull (warn_alloc_size_limit, &end, 10) : 0;\n+\n+      if (limit && !errno)\n+\t{\n+\t  if (end && *end)\n+\t    {\n+\t      /* Numeric option arguments are at most INT_MAX.  Make it\n+\t\t possible to specify a larger value by accepting common\n+\t\t suffixes.  */\n+\t      if (!strcmp (end, \"kB\"))\n+\t\tunit = 1000;\n+\t      else if (!strcasecmp (end, \"KiB\") || strcmp (end, \"KB\"))\n+\t\tunit = 1024;\n+\t      else if (!strcmp (end, \"MB\"))\n+\t\tunit = 1000LU * 1000;\n+\t      else if (!strcasecmp (end, \"MiB\"))\n+\t\tunit = 1024LU * 1024;\n+\t      else if (!strcasecmp (end, \"GB\"))\n+\t\tunit = 1000LU * 1000 * 1000;\n+\t      else if (!strcasecmp (end, \"GiB\"))\n+\t\tunit = 1024LU * 1024 * 1024;\n+\t      else if (!strcasecmp (end, \"TB\"))\n+\t\tunit = 1000LU * 1000 * 1000 * 1000;\n+\t      else if (!strcasecmp (end, \"TiB\"))\n+\t\tunit = 1024LU * 1024 * 1024 * 1024;\n+\t      else if (!strcasecmp (end, \"PB\"))\n+\t\tunit = 1000LU * 1000 * 1000 * 1000 * 1000;\n+\t      else if (!strcasecmp (end, \"PiB\"))\n+\t\tunit = 1024LU * 1024 * 1024 * 1024 * 1024;\n+\t      else if (!strcasecmp (end, \"EB\"))\n+\t\tunit = 1000LU * 1000 * 1000 * 1000 * 1000 * 1000;\n+\t      else if (!strcasecmp (end, \"EiB\"))\n+\t\tunit = 1024LU * 1024 * 1024 * 1024 * 1024 * 1024;\n+\t      else\n+\t\tunit = 0;\n+\t    }\n+\n+\t  if (unit)\n+\t    alloc_object_size_limit = build_int_cst (ssizetype, limit * unit);\n+\t}\n+    }\n+  return alloc_object_size_limit;\n+}\n+\n+/* Return true if the type of OP is signed, looking through any casts\n+   to an unsigned type.  */\n+\n+static bool\n+operand_signed_p (tree op)\n+{\n+  if (TREE_CODE (op) == SSA_NAME)\n+    {\n+      gimple *def = SSA_NAME_DEF_STMT (op);\n+      if (is_gimple_assign (def))\n+\t{\n+\t  /* In an assignment involving a cast, ignore the type\n+\t     of the cast and consider the type of its  operand.  */\n+\t  tree_code code = gimple_assign_rhs_code (def);\n+\t  if (code == NOP_EXPR)\n+\t    op = gimple_assign_rhs1 (def);\n+\t}\n+      else if (gimple_code (def) == GIMPLE_PHI)\n+\t{\n+\t  /* In a phi, a constant argument may be unsigned even\n+\t     if in the source it's signed and negative.  Ignore\n+\t     those and consider the result of a phi signed if\n+\t     all its non-constant operands are.  */\n+\t  unsigned nargs = gimple_phi_num_args (def);\n+\t  for (unsigned i = 0; i != nargs; ++i)\n+\t    {\n+\t      tree op = gimple_phi_arg_def (def, i);\n+\t      if (TREE_CODE (op) != INTEGER_CST\n+\t\t  && !operand_signed_p (op))\n+\t\treturn false;\n+\t    }\n+\n+\t  return true;\n+\t}\n+    }\n+\n+  return !TYPE_UNSIGNED (TREE_TYPE (op));\n+}\n+\n+/* Diagnose a call EXP to function FN decorated with attribute alloc_size\n+   whose argument numbers given by IDX with values given by ARGS exceed\n+   the maximum object size or cause an unsigned oveflow (wrapping) when\n+   multiplied.  When ARGS[0] is null the function does nothing.  ARGS[1]\n+   may be null for functions like malloc, and non-null for those like\n+   calloc that are decorated with a two-argument attribute alloc_size.  */\n+\n+void\n+maybe_warn_alloc_args_overflow (tree fn, tree exp, tree args[2], int idx[2])\n+{\n+  /* The range each of the (up to) two arguments is known to be in.  */\n+  tree argrange[2][2] = { { NULL_TREE, NULL_TREE }, { NULL_TREE, NULL_TREE } };\n+\n+  /* Maximum object size set by -Walloc-size-larger-than= or SIZE_MAX / 2.  */\n+  tree maxobjsize = alloc_max_size ();\n+\n+  location_t loc = EXPR_LOCATION (exp);\n+\n+  bool warned = false;\n+\n+  /* Validate each argument individually.  */\n+  for (unsigned i = 0; i != 2 && args[i]; ++i)\n+    {\n+      if (TREE_CODE (args[i]) == INTEGER_CST)\n+\t{\n+\t  argrange[i][0] = args[i];\n+\t  argrange[i][1] = args[i];\n+\n+\t  if (tree_int_cst_lt (args[i], integer_zero_node))\n+\t    {\n+\t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n+\t\t\t\t   \"argument %i value %qE is negative\",\n+\t\t\t\t   idx[i] + 1, args[i]);\n+\t    }\n+\t  else if (integer_zerop (args[i]))\n+\t    {\n+\t      /* Avoid issuing -Walloc-zero for allocation functions other\n+\t\t than __builtin_alloca that are declared with attribute\n+\t\t returns_nonnull because there's no portability risk.  This\n+\t\t avoids warning for such calls to libiberty's xmalloc and\n+\t\t friends.\n+\t\t Also avoid issuing the warning for calls to function named\n+\t\t \"alloca\".  */\n+\t      if ((DECL_FUNCTION_CODE (fn) == BUILT_IN_ALLOCA\n+\t\t   && IDENTIFIER_LENGTH (DECL_NAME (fn)) != 6)\n+\t\t  || (DECL_FUNCTION_CODE (fn) != BUILT_IN_ALLOCA\n+\t\t      && !lookup_attribute (\"returns_nonnull\",\n+\t\t\t\t\t    TYPE_ATTRIBUTES (TREE_TYPE (fn)))))\n+\t\twarned = warning_at (loc, OPT_Walloc_zero,\n+\t\t\t\t     \"argument %i value is zero\",\n+\t\t\t\t     idx[i] + 1);\n+\t    }\n+\t  else if (tree_int_cst_lt (maxobjsize, args[i]))\n+\t    {\n+\t      /* G++ emits calls to ::operator new[](SIZE_MAX) in C++98\n+\t\t mode and with -fno-exceptions as a way to indicate array\n+\t\t size overflow.  There's no good way to detect C++98 here\n+\t\t so avoid diagnosing these calls for all C++ modes.  */\n+\t      if (i == 0\n+\t\t  && !args[1]\n+\t\t  && lang_GNU_CXX ()\n+\t\t  && DECL_IS_OPERATOR_NEW (fn)\n+\t\t  && integer_all_onesp (args[i]))\n+\t\tcontinue;\n+\n+\t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n+\t\t\t\t   \"argument %i value %qE exceeds \"\n+\t\t\t\t   \"maximum object size %E\",\n+\t\t\t\t   idx[i] + 1, args[i], maxobjsize);\n+\t    }\n+\t}\n+      else if (TREE_CODE (args[i]) == SSA_NAME)\n+\t{\n+\t  tree type = TREE_TYPE (args[i]);\n+\n+\t  wide_int min, max;\n+\t  value_range_type range_type = get_range_info (args[i], &min, &max);\n+\t  if (range_type == VR_RANGE)\n+\t    {\n+\t      argrange[i][0] = wide_int_to_tree (type, min);\n+\t      argrange[i][1] = wide_int_to_tree (type, max);\n+\t    }\n+\t  else if (range_type == VR_ANTI_RANGE)\n+\t    {\n+\t      /* For an anti-range, if the type of the formal argument\n+\t\t is unsigned and the bounds of the range are of opposite\n+\t\t signs when interpreted as signed, check to see if the\n+\t\t type of the actual argument is signed.  If so, the lower\n+\t\t bound must be taken to be zero (rather than a large\n+\t\t positive value corresonding to the actual lower bound\n+\t\t interpreted as unsigned) and there is nothing else that\n+\t\t can be inferred from it.  */\n+\t      --min;\n+\t      ++max;\n+\t      wide_int zero = wi::uhwi (0, TYPE_PRECISION (type));\n+\t      if (TYPE_UNSIGNED (type)\n+\t\t  && wi::lts_p (zero, min) && wi::lts_p (max, zero)\n+\t\t  && operand_signed_p (args[i]))\n+\t\tcontinue;\n+\n+\t      argrange[i][0] = wide_int_to_tree (type, max);\n+\t      argrange[i][1] = wide_int_to_tree (type, min);\n+\n+\t      /* Verify that the anti-range doesn't make all arguments\n+\t\t invalid (treat the anti-range ~[0, 0] as invalid).  */\n+\t      if (tree_int_cst_lt (maxobjsize, argrange[i][0])\n+\t\t  && tree_int_cst_le (argrange[i][1], integer_zero_node))\n+\t\t{\n+\t\t  warned\n+\t\t    = warning_at (loc, OPT_Walloc_size_larger_than_,\n+\t\t\t\t  (TYPE_UNSIGNED (type)\n+\t\t\t\t   ? G_(\"argument %i range [%E, %E] exceeds \"\n+\t\t\t\t\t\"maximum object size %E\")\n+\t\t\t\t   : G_(\"argument %i range [%E, %E] is both \"\n+\t\t\t\t\t\"negative and exceeds maximum object \"\n+\t\t\t\t\t\"size %E\")),\n+\t\t\t\t  idx[i] + 1, argrange[i][0],\n+\t\t\t\t  argrange[i][1], maxobjsize);\n+\t\t}\n+\t      continue;\n+\t    }\n+\t  else\n+\t    continue;\n+\n+\t  /* Verify that the argument's range is not negative (including\n+\t     upper bound of zero).  */\n+\t  if (tree_int_cst_lt (argrange[i][0], integer_zero_node)\n+\t      && tree_int_cst_le (argrange[i][1], integer_zero_node))\n+\t    {\n+\t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n+\t\t\t\t   \"argument %i range [%E, %E] is negative\",\n+\t\t\t\t   idx[i] + 1, argrange[i][0], argrange[i][1]);\n+\t    }\n+\t  else if (tree_int_cst_lt (maxobjsize, argrange[i][0]))\n+\t    {\n+\t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n+\t\t\t\t   \"argument %i range [%E, %E] exceeds \"\n+\t\t\t\t   \"maximum object size %E\",\n+\t\t\t\t   idx[i] + 1, argrange[i][0], argrange[i][1],\n+\t\t\t\t   maxobjsize);\n+\t    }\n+\t}\n+    }\n+\n+  if (!argrange[0])\n+    return;\n+\n+  /* For a two-argument alloc_size, validate the product of the two\n+     arguments if both of their values or ranges are known.  */\n+  if (!warned && tree_fits_uhwi_p (argrange[0][0])\n+      && argrange[1][0] && tree_fits_uhwi_p (argrange[1][0])\n+      && !integer_onep (argrange[0][0])\n+      && !integer_onep (argrange[1][0]))\n+    {\n+      /* Check for overflow in the product of a function decorated with\n+\t attribute alloc_size (X, Y).  */\n+      unsigned szprec = TYPE_PRECISION (size_type_node);\n+      wide_int x = wi::to_wide (argrange[0][0], szprec);\n+      wide_int y = wi::to_wide (argrange[1][0], szprec);\n+\n+      bool vflow;\n+      wide_int prod = wi::umul (x, y, &vflow);\n+\n+      if (vflow)\n+\twarned = warning_at (loc, OPT_Walloc_size_larger_than_,\n+\t\t\t     \"product %<%E * %E%> of arguments %i and %i \"\n+\t\t\t     \"exceeds %<SIZE_MAX%>\",\n+\t\t\t     argrange[0][0], argrange[1][0],\n+\t\t\t     idx[0] + 1, idx[1] + 1);\n+      else if (wi::ltu_p (wi::to_wide (maxobjsize, szprec), prod))\n+\twarned = warning_at (loc, OPT_Walloc_size_larger_than_,\n+\t\t\t     \"product %<%E * %E%> of arguments %i and %i \"\n+\t\t\t     \"exceeds maximum object size %E\",\n+\t\t\t     argrange[0][0], argrange[1][0],\n+\t\t\t     idx[0] + 1, idx[1] + 1,\n+\t\t\t     maxobjsize);\n+\n+      if (warned)\n+\t{\n+\t  /* Print the full range of each of the two arguments to make\n+\t     it clear when it is, in fact, in a range and not constant.  */\n+\t  if (argrange[0][0] != argrange [0][1])\n+\t    inform (loc, \"argument %i in the range [%E, %E]\",\n+\t\t    idx[0] + 1, argrange[0][0], argrange[0][1]);\n+\t  if (argrange[1][0] != argrange [1][1])\n+\t    inform (loc, \"argument %i in the range [%E, %E]\",\n+\t\t    idx[1] + 1, argrange[1][0], argrange[1][1]);\n+\t}\n+    }\n+\n+  if (warned)\n+    {\n+      location_t fnloc = DECL_SOURCE_LOCATION (fn);\n+\n+      if (DECL_IS_BUILTIN (fn))\n+\tinform (loc,\n+\t\t\"in a call to built-in allocation function %qD\", fn);\n+      else\n+\tinform (fnloc,\n+\t\t\"in a call to allocation function %qD declared here\", fn);\n+    }\n+}\n+\n /* Issue an error if CALL_EXPR was flagged as requiring\n    tall-call optimization.  */\n \n@@ -1359,6 +1666,24 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \n   bitmap_obstack_release (NULL);\n \n+  /* Extract attribute alloc_size and if set, store the indices of\n+     the corresponding arguments in ALLOC_IDX, and then the actual\n+     argument(s) at those indices in ALLOC_ARGS.  */\n+  int alloc_idx[2] = { -1, -1 };\n+  if (tree alloc_size\n+      = (fndecl ? lookup_attribute (\"alloc_size\",\n+\t\t\t\t    TYPE_ATTRIBUTES (TREE_TYPE (fndecl)))\n+\t : NULL_TREE))\n+    {\n+      tree args = TREE_VALUE (alloc_size);\n+      alloc_idx[0] = TREE_INT_CST_LOW (TREE_VALUE (args)) - 1;\n+      if (TREE_CHAIN (args))\n+\talloc_idx[1] = TREE_INT_CST_LOW (TREE_VALUE (TREE_CHAIN (args))) - 1;\n+    }\n+\n+  /* Array for up to the two attribute alloc_size arguments.  */\n+  tree alloc_args[] = { NULL_TREE, NULL_TREE };\n+\n   /* I counts args in order (to be) pushed; ARGPOS counts in order written.  */\n   for (argpos = 0; argpos < num_actuals; i--, argpos++)\n     {\n@@ -1595,6 +1920,20 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \n       targetm.calls.function_arg_advance (args_so_far, TYPE_MODE (type),\n \t\t\t\t\t  type, argpos < n_named_args);\n+\n+      /* Store argument values for functions decorated with attribute\n+\t alloc_size.  */\n+      if (argpos == alloc_idx[0])\n+\talloc_args[0] = args[i].tree_value;\n+      else if (argpos == alloc_idx[1])\n+\talloc_args[1] = args[i].tree_value;\n+    }\n+\n+  if (alloc_args[0])\n+    {\n+      /* Check the arguments of functions decorated with attribute\n+\t alloc_size.  */\n+      maybe_warn_alloc_args_overflow (fndecl, exp, alloc_args, alloc_idx);\n     }\n }\n "}, {"sha": "3b0726345afb98430d380531b1c8bb757c67f61d", "filename": "gcc/calls.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Fcalls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Fcalls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.h?ref=8bd9f164e29e8d6303ea421076e52be162158f7f", "patch": "@@ -37,7 +37,6 @@ extern bool pass_by_reference (CUMULATIVE_ARGS *, machine_mode,\n \t\t\t       tree, bool);\n extern bool reference_callee_copied (CUMULATIVE_ARGS *, machine_mode,\n \t\t\t\t     tree, bool);\n-\n-\n+extern void maybe_warn_alloc_args_overflow (tree, tree, tree[2], int[2]);\n \n #endif // GCC_CALLS_H"}, {"sha": "0c6123269a33250b4e6424017acdab9520a315e7", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=8bd9f164e29e8d6303ea421076e52be162158f7f", "patch": "@@ -257,6 +257,7 @@ Objective-C and Objective-C++ Dialects}.\n @gccoptlist{-fsyntax-only  -fmax-errors=@var{n}  -Wpedantic @gol\n -pedantic-errors @gol\n -w  -Wextra  -Wall  -Waddress  -Waggregate-return  @gol\n+-Walloc-zero -Walloc-size-larger-than=@var{n}\n -Walloca -Walloca-larger-than=@var{n} @gol\n -Wno-aggressive-loop-optimizations -Warray-bounds -Warray-bounds=@var{n} @gol\n -Wno-attributes -Wbool-compare -Wbool-operation @gol\n@@ -5099,6 +5100,27 @@ annotations.\n Warn about overriding virtual functions that are not marked with the override\n keyword.\n \n+@item -Walloc-zero\n+@opindex Wno-alloc-zero\n+@opindex Walloc-zero\n+Warn about calls to allocation functions decorated with attribute\n+@code{alloc_size} that specify zero bytes, including those to the built-in\n+forms of the functions @code{aligned_alloc}, @code{alloca}, @code{calloc},\n+@code{malloc}, and @code{realloc}.  Because the behavior of these functions\n+when called with a zero size differs among implementations (and in the case\n+of @code{realloc} has been deprecated) relying on it may result in subtle\n+portability bugs and should be avoided.\n+\n+@item -Walloc-size-larger-than=@var{n}\n+Warn about calls to functions decorated with attribute @code{alloc_size}\n+that attempt to allocate objects larger than the specified number of bytes,\n+or where the result of the size computation in an integer type with infinite\n+precision would exceed @code{SIZE_MAX / 2}.  The option argument @var{n}\n+may end in one of the standard suffixes designating a multiple of bytes\n+such as @code{kB} and @code{KiB} for kilobyte and kibibyte, respectively,\n+@code{MB} and @code{MiB} for magabyte and mebibyte, and so on.\n+@xref{Function Attributes}.\n+\n @item -Walloca\n @opindex Wno-alloca\n @opindex Walloca"}, {"sha": "80166f282a7c684d142041aa9b1465d621d81277", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8bd9f164e29e8d6303ea421076e52be162158f7f", "patch": "@@ -1,3 +1,15 @@\n+2016-12-08  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/78284\n+\t* gcc.dg/attr-alloc_size-3.c: New test.\n+\t* gcc.dg/attr-alloc_size-4.c: New test.\n+\t* gcc.dg/attr-alloc_size-5.c: New test.\n+\t* gcc.dg/attr-alloc_size-6.c: New test.\n+\t* gcc.dg/attr-alloc_size-7.c: New test.\n+\t* gcc.dg/attr-alloc_size-8.c: New test.\n+\t* gcc.dg/attr-alloc_size-9.c: New test.\n+\t* gcc/testsuite/gcc.dg/errno-1.c: Adjust.\n+\n 2016-12-08  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/65173"}, {"sha": "284127f133869851d42d09f10ef28de8a344ddc5", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size-3.c", "status": "added", "additions": 473, "deletions": 0, "changes": 473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-3.c?ref=8bd9f164e29e8d6303ea421076e52be162158f7f", "patch": "@@ -0,0 +1,473 @@\n+/* PR c/77531 - __attribute__((alloc_size(1,2))) could also warn on\n+   multiplication overflow\n+   PR c/78284 - warn on malloc with very large arguments\n+   Test exercising the ability to detect and diagnose calls to allocation\n+   functions decorated with attribute alloc_size that either overflow or\n+   exceed the default maximum object size (with -Walloc-size-larger-than\n+   not explicitly specified).  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wall\" } */\n+\n+#define SCHAR_MAX  __SCHAR_MAX__\n+#define SCHAR_MIN  (-SCHAR_MAX - 1)\n+#define UCHAR_MAX  (SCHAR_MAX * 2 + 1)\n+\n+#define SHRT_MAX   __SHRT_MAX__\n+#define SHRT_MIN   (-SHRT_MAX - 1)\n+#define USHRT_MAX  (SHRT_MAX * 2 + 1)\n+\n+#define INT_MAX    __INT_MAX__\n+#define INT_MIN    (-INT_MAX - 1)\n+#define UINT_MAX   (INT_MAX * 2U + 1)\n+\n+#define LONG_MAX   __LONG_MAX__\n+#define LONG_MIN   (-LONG_MAX - 1L)\n+#define ULONG_MAX  (LONG_MAX * 2LU + 1)\n+\n+#define LLONG_MAX  __LLONG_MAX__\n+#define LLONG_MIN  (-LLONG_MAX - 1LL)\n+#define ULLONG_MAX (ULLONG_MAX * 2LLU + 1)\n+\n+#define PTRDIFF_MAX __PTRDIFF_MAX__\n+#define PTRDIFF_MIN (-PTRDIFF_MAX - 1)\n+#define SIZE_MAX    __SIZE_MAX__\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+typedef __SIZE_TYPE__    size_t;\n+\n+#define ALLOC_SIZE(...) __attribute__ ((alloc_size (__VA_ARGS__)))\n+\n+void* f_uchar_1 (unsigned char) ALLOC_SIZE (1);\n+void* f_uchar_2 (unsigned char, unsigned char) ALLOC_SIZE (1, 2);\n+void* f_schar_1 (signed char) ALLOC_SIZE (1);\n+void* f_schar_2 (signed char, signed char) ALLOC_SIZE (1, 2);\n+\n+void* f_ushrt_1 (unsigned short) ALLOC_SIZE (1);\n+void* f_ushrt_2 (unsigned short, unsigned short) ALLOC_SIZE (1, 2);\n+void* f_shrt_1 (signed short) ALLOC_SIZE (1);\n+void* f_shrt_2 (signed short, signed short) ALLOC_SIZE (1, 2);\n+\n+void* f_uint_1 (unsigned) ALLOC_SIZE (1);\n+void* f_uint_2 (unsigned, unsigned) ALLOC_SIZE (1, 2);\n+void* f_int_1 (int) ALLOC_SIZE (1);\n+void* f_int_2 (int, int) ALLOC_SIZE (1, 2);\n+\n+void* f_ulong_1 (unsigned long) ALLOC_SIZE (1);\n+void* f_ulong_2 (unsigned long, unsigned long) ALLOC_SIZE (1, 2);\n+void* f_long_1 (long) ALLOC_SIZE (1);\n+void* f_long_2 (long, long) ALLOC_SIZE (1, 2);\n+\n+void* f_ullong_1 (unsigned long long) ALLOC_SIZE (1);\n+void* f_ullong_2 (unsigned long long, unsigned long long) ALLOC_SIZE (1, 2);\n+void* f_llong_1 (long long) ALLOC_SIZE (1);\n+void* f_llong_2 (long long, long long) ALLOC_SIZE (1, 2);\n+\n+void* f_size_1 (size_t) ALLOC_SIZE (1);\n+void* f_size_2 (size_t, size_t) ALLOC_SIZE (1, 2);\n+\n+unsigned long long\n+unsigned_range (unsigned long long min, unsigned long long max)\n+{\n+  extern unsigned long long random_unsigned_value (void);\n+  unsigned long long val = random_unsigned_value ();\n+  if (val < min || max < val) val = min;\n+  return val;\n+}\n+\n+long long\n+signed_range (long long min, long long max)\n+{\n+  extern long long random_signed_value (void);\n+  long long val = random_signed_value ();\n+  if (val < min || max < val) val = min;\n+  return val;\n+}\n+\n+unsigned long long\n+unsigned_anti_range (unsigned long long min, unsigned long long max)\n+{\n+  extern unsigned long long random_unsigned_value (void);\n+  unsigned long long val = random_unsigned_value ();\n+  if (min <= val && val <= max)\n+    val = min - 1;\n+  return val;\n+}\n+\n+long long\n+signed_anti_range (long long min, long long max)\n+{\n+  extern long long random_signed_value (void);\n+  long long val = random_signed_value ();\n+  if (min <= val && val <= max)\n+    val = min - 1;\n+  return val;\n+}\n+\n+#define UR(min, max) unsigned_range (min, max)\n+#define SR(min, max) signed_range (min, max)\n+\n+#define UAR(min, max) unsigned_anti_range (min, max)\n+#define SAR(min, max) signed_anti_range (min, max)\n+\n+\n+void sink (void*);\n+\n+void\n+test_uchar_cst (void)\n+{\n+  const unsigned char max = UCHAR_MAX;\n+\n+  sink (f_uchar_1 (0));\n+  sink (f_uchar_1 (1));\n+  sink (f_uchar_1 (max));\n+\n+  sink (f_uchar_2 (0, 0));\n+  sink (f_uchar_2 (0, 1));\n+  sink (f_uchar_2 (1, 0));\n+  sink (f_uchar_2 (1, 1));\n+  sink (f_uchar_2 (0, max));\n+  sink (f_uchar_2 (max, 0));\n+  sink (f_uchar_2 (max, max));\n+}\n+\n+void\n+test_uchar_range (unsigned char n, int i)\n+{\n+  const unsigned char max = UCHAR_MAX;\n+\n+  sink (f_uchar_1 (n));\n+\n+  sink (f_uchar_1 (UR (0, 1)));\n+  sink (f_uchar_1 (UR (1, max)));\n+  sink (f_uchar_1 (UR (0, max - 1)));\n+\n+  sink (f_uchar_1 (UAR (1, 1)));\n+  sink (f_uchar_1 (UAR (1, max - 1)));\n+  sink (f_uchar_1 (UAR (max - 2, max - 1)));\n+\n+  sink (f_uchar_2 (0, n));\n+  sink (f_uchar_2 (0, i));\n+  sink (f_uchar_2 (n, 0));\n+  sink (f_uchar_2 (i, 0));\n+  sink (f_uchar_2 (1, n));\n+  sink (f_uchar_2 (1, i));\n+  sink (f_uchar_2 (n, 1));\n+  sink (f_uchar_2 (i, 1));\n+  sink (f_uchar_2 (max, n));\n+  sink (f_uchar_2 (max, i));\n+  sink (f_uchar_2 (n, max));\n+  sink (f_uchar_2 (i, max));\n+  sink (f_uchar_2 (n, n));\n+  sink (f_uchar_2 (i, i));\n+\n+  sink (f_uchar_2 (UR (0, 1), UR (0, 1)));\n+  sink (f_uchar_2 (UR (1, 2), UR (1, 2)));\n+  sink (f_uchar_2 (UR (1, max), UR (0, 1)));\n+  sink (f_uchar_2 (UR (0, 1), UR (1, max)));\n+}\n+\n+void\n+test_schar_cst (void)\n+{\n+  const signed char min = SCHAR_MIN;\n+  const signed char max = SCHAR_MAX;\n+\n+  sink (f_schar_1 (min));     /* { dg-warning \"argument 1 value .-\\[0-9\\]+. is negative\" } */\n+  sink (f_schar_1 (-1));      /* { dg-warning \"argument 1 value .-1. is negative\" } */\n+  sink (f_schar_1 (0));\n+  sink (f_schar_1 (1));\n+  sink (f_schar_1 (max));\n+\n+  sink (f_schar_2 (0, min));     /* { dg-warning \"argument 2 value .-\\[0-9\\]+. is negative\" } */\n+  sink (f_schar_2 (min, 0));     /* { dg-warning \"argument 1 value .-\\[0-9\\]+. is negative\" } */\n+  sink (f_schar_2 (0, -1));      /* { dg-warning \"argument 2 value .-1. is negative\" } */\n+  sink (f_schar_2 (-1, 0));      /* { dg-warning \"argument 1 value .-1. is negative\" } */\n+\n+}\n+\n+void\n+test_schar_range (signed char n)\n+{\n+  const signed char min = SCHAR_MIN;\n+  const signed char max = SCHAR_MAX;\n+\n+  sink (f_schar_1 (n));\n+\n+  sink (f_schar_1 (SR (min, min + 1)));   /* { dg-warning \"argument 1 range \\\\\\[-\\[0-9\\]+, -\\[0-9\\]+\\\\\\] is negative\" } */\n+  sink (f_schar_1 (SR (min, 0)));   /* { dg-warning \"argument 1 range \\\\\\[-\\[0-9\\]+, 0\\\\\\] is negative\" } */\n+  sink (f_schar_1 (SR (-1, 0)));   /* { dg-warning \"argument 1 range \\\\\\[-1, 0\\\\\\] is negative\" } */\n+  sink (f_schar_1 (SR (-1, 1)));\n+  sink (f_schar_1 (SR (0, 1)));\n+  sink (f_schar_1 (SR (0, max - 1)));\n+  sink (f_schar_1 (SR (1, max)));\n+  sink (f_schar_1 (SR (max - 1, max)));\n+\n+  sink (f_schar_2 (n, n));\n+\n+  sink (f_schar_2 (SR (min, min + 1), n));   /* { dg-warning \"argument 1 range \\\\\\[-\\[0-9\\]+, -\\[0-9\\]+\\\\\\] is negative\" } */\n+  sink (f_schar_2 (n, SR (min, min + 1)));   /* { dg-warning \"argument 2 range \\\\\\[-\\[0-9\\]+, -\\[0-9\\]+\\\\\\] is negative\" } */\n+  sink (f_schar_2 (SR (min, min + 1), 0));   /* { dg-warning \"argument 1 range \\\\\\[-\\[0-9\\]+, -\\[0-9\\]+\\\\\\] is negative\" } */\n+  sink (f_schar_2 (0, SR (min, min + 1)));   /* { dg-warning \"argument 2 range \\\\\\[-\\[0-9\\]+, -\\[0-9\\]+\\\\\\] is negative\" } */\n+  sink (f_schar_2 (SR (min, min + 1), min));   /* { dg-warning \"argument 1 range \\\\\\[-\\[0-9\\]+, -\\[0-9\\]+\\\\\\] is negative\" } */\n+  /* { dg-warning \"argument 2 value .-\\[0-9\\]+. is negative\" \"argument 2\" { target *-*-* } .-1 } */\n+  sink (f_schar_2 (min, SR (min, min + 1)));   /* { dg-warning \"argument 2 range \\\\\\[-\\[0-9\\]+, -\\[0-9\\]+\\\\\\] is negative\" } */\n+  /* { dg-warning \"argument 1 value .-\\[0-9\\]+. is negative\" \"argument 1\" { target *-*-* } .-1 } */\n+\n+  sink (f_schar_2 (SR (-1, 0), 0));   /* { dg-warning \"argument 1 range \\\\\\[-\\[0-9\\]+, 0\\\\\\] is negative\" } */\n+  sink (f_schar_2 (0, SR (-1, 0)));   /* { dg-warning \"argument 2 range \\\\\\[-\\[0-9\\]+, 0\\\\\\] is negative\" } */\n+  sink (f_schar_2 (SR (-1, 0), 1));   /* { dg-warning \"argument 1 range \\\\\\[-\\[0-9\\]+, 0\\\\\\] is negative\" } */\n+  sink (f_schar_2 (1, SR (-1, 0)));   /* { dg-warning \"argument 2 range \\\\\\[-\\[0-9\\]+, 0\\\\\\] is negative\" } */\n+  sink (f_schar_2 (SR (-1, 0), n));   /* { dg-warning \"argument 1 range \\\\\\[-\\[0-9\\]+, 0\\\\\\] is negative\" } */\n+  sink (f_schar_2 (n, SR (-1, 0)));   /* { dg-warning \"argument 2 range \\\\\\[-\\[0-9\\]+, 0\\\\\\] is negative\" } */\n+\n+  sink (f_schar_2 (max, SR (1, max)));\n+  sink (f_schar_2 (SR (1, max), max));\n+}\n+\n+void\n+test_ushrt_cst (void)\n+{\n+  const unsigned short max = USHRT_MAX;\n+\n+  sink (f_ushrt_1 (0));\n+  sink (f_ushrt_1 (1));\n+  sink (f_ushrt_1 (max));\n+\n+  sink (f_ushrt_2 (0, 0));\n+  sink (f_ushrt_2 (0, 1));\n+  sink (f_ushrt_2 (1, 0));\n+  sink (f_ushrt_2 (1, 1));\n+  sink (f_ushrt_2 (0, max));\n+  sink (f_ushrt_2 (max, 0));\n+\n+#if USHRT_MAX < SIZE_MAX\n+  sink (f_ushrt_2 (max, max));\n+#endif\n+}\n+\n+void\n+test_ushrt_range (unsigned short n)\n+{\n+  const unsigned short max = USHRT_MAX;\n+\n+  sink (f_ushrt_1 (n));\n+  sink (f_ushrt_1 (UR (0, 1)));\n+  sink (f_ushrt_1 (UR (1, max - 1)));\n+  sink (f_ushrt_1 (UR (1, max)));\n+  sink (f_ushrt_1 (UR (0, max - 1)));\n+}\n+\n+void\n+test_shrt_cst (void)\n+{\n+  const short min = SHRT_MIN;\n+  const short max = SHRT_MAX;\n+\n+  sink (f_shrt_1 (min));   /* { dg-warning \"argument 1 value .-\\[0-9\\]+. is negative\" } */\n+  sink (f_shrt_1 (-1));         /* { dg-warning \"argument 1 value .-1. is negative\" } */\n+  sink (f_shrt_1 (0));\n+  sink (f_shrt_1 (1));\n+  sink (f_shrt_1 (max));\n+}\n+\n+void\n+test_shrt_range (short n)\n+{\n+  const short min = SHRT_MIN;\n+  const short max = SHRT_MAX;\n+\n+  sink (f_shrt_1 (n));\n+\n+  sink (f_shrt_1 (SR (min, min + 1)));   /* { dg-warning \"argument 1 range \\\\\\[-\\[0-9\\]+, -\\[0-9\\]+\\\\\\] is negative\" } */\n+  sink (f_shrt_1 (SR (min, 0)));   /* { dg-warning \"argument 1 range \\\\\\[-\\[0-9\\]+, 0\\\\\\] is negative\" } */\n+  sink (f_shrt_1 (SR (-1, 0)));   /* { dg-warning \"argument 1 range \\\\\\[-1, 0\\\\\\] is negative\" } */\n+  sink (f_shrt_1 (SR (-1, 1)));\n+  sink (f_shrt_1 (SR (0, 1)));\n+  sink (f_shrt_1 (SR (0, max - 1)));\n+  sink (f_shrt_1 (SR (1, max)));\n+  sink (f_shrt_1 (SR (max - 1, max)));\n+}\n+\n+void\n+test_uint_cst (void)\n+{\n+  const unsigned max = UINT_MAX;\n+\n+  sink (f_uint_1 (0));\n+  sink (f_uint_1 (1));\n+  sink (f_uint_1 (max - 1));\n+  sink (f_uint_1 (max));\n+}\n+\n+void\n+test_uint_range (unsigned n)\n+{\n+  const unsigned max = UINT_MAX;\n+\n+  sink (f_uint_1 (n));\n+  sink (f_uint_1 (UR (0, 1)));\n+  sink (f_uint_1 (UR (0, max - 1)));\n+  sink (f_uint_1 (UR (1, max - 1)));\n+  sink (f_uint_1 (UR (1, max)));\n+}\n+\n+void\n+test_int_cst (void)\n+{\n+  const int min = INT_MIN;\n+  const int max = INT_MAX;\n+\n+  sink (f_int_1 (min));   /* { dg-warning \"argument 1 value .-\\[0-9\\]+. is negative\" } */\n+  sink (f_int_1 (-1));         /* { dg-warning \"argument 1 value .-1. is negative\" } */\n+  sink (f_int_1 (0));\n+  sink (f_int_1 (1));\n+  sink (f_int_1 (max));\n+}\n+\n+void\n+test_int_range (int n)\n+{\n+  const int min = INT_MIN;\n+  const int max = INT_MAX;\n+\n+  sink (f_int_1 (n));\n+\n+  sink (f_int_1 (SR (min, min + 1)));   /* { dg-warning \"argument 1 range \\\\\\[-\\[0-9\\]+, -\\[0-9\\]+\\\\\\] is negative\" } */\n+  sink (f_int_1 (SR (min, 0)));   /* { dg-warning \"argument 1 range \\\\\\[-\\[0-9\\]+, 0\\\\\\] is negative\" } */\n+  sink (f_int_1 (SR (-1, 0)));   /* { dg-warning \"argument 1 range \\\\\\[-1, 0\\\\\\] is negative\" } */\n+  sink (f_int_1 (SR (-1, 1)));\n+  sink (f_int_1 (SR (0, 1)));\n+  sink (f_int_1 (SR (0, max - 1)));\n+  sink (f_int_1 (SR (1, max)));\n+  sink (f_int_1 (SR (max - 1, max)));\n+}\n+\n+void\n+test_ulong_cst (void)\n+{\n+  const unsigned long max = ULONG_MAX;\n+\n+  sink (f_ulong_1 (0));\n+  sink (f_ulong_1 (1));\n+#if ULONG_MAX < SIZE_MAX\n+  sink (f_ulong_1 (max - 1));\n+  sink (f_ulong_1 (max));\n+#else\n+  (void)&max;\n+#endif\n+}\n+\n+void\n+test_ulong_range (unsigned long n)\n+{\n+  const unsigned long max = ULONG_MAX;\n+\n+  sink (f_ulong_1 (n));\n+  sink (f_ulong_1 (UR (0, 1)));\n+  sink (f_ulong_1 (UR (0, max - 1)));\n+  sink (f_ulong_1 (UR (1, max - 1)));\n+  sink (f_ulong_1 (UR (1, max)));\n+}\n+\n+void\n+test_long_cst (void)\n+{\n+  const long min = LONG_MIN;\n+  const long max = LONG_MAX;\n+\n+  sink (f_long_1 (min));   /* { dg-warning \"argument 1 value .-\\[0-9\\]+l*. is negative\" } */\n+  sink (f_long_1 (-1));         /* { dg-warning \"argument 1 value .-1l*. is negative\" } */\n+  sink (f_long_1 (0));\n+  sink (f_long_1 (1));\n+  sink (f_long_1 (max));\n+}\n+\n+void\n+test_long_range (long n)\n+{\n+  const long min = LONG_MIN;\n+  const long max = LONG_MAX;\n+\n+  sink (f_long_1 (n));\n+\n+  sink (f_long_1 (SR (min, min + 1)));   /* { dg-warning \"argument 1 range \\\\\\[-\\[0-9\\]+l*, -\\[0-9\\]+l*\\\\\\] is negative\" } */\n+  sink (f_long_1 (SR (min, 0)));   /* { dg-warning \"argument 1 range \\\\\\[-\\[0-9\\]+l*, 0l*\\\\\\] is negative\" } */\n+  sink (f_long_1 (SR (-1, 0)));   /* { dg-warning \"argument 1 range \\\\\\[-1l*, 0l*\\\\\\] is negative\" } */\n+  sink (f_long_1 (SR (-1, 1)));\n+  sink (f_long_1 (SR (0, 1)));\n+  sink (f_long_1 (SR (0, max - 1)));\n+  sink (f_long_1 (SR (1, max)));\n+  sink (f_long_1 (SR (max - 1, max)));\n+}\n+\n+void\n+test_size_cst (void)\n+{\n+  const size_t max = __SIZE_MAX__;\n+\n+  sink (f_size_1 (0));\n+  sink (f_size_1 (1));\n+  sink (f_size_1 (max - 1));  /* { dg-warning \"argument 1 value .\\[0-9\\]+\\[lu\\]*. exceeds maximum object size \\[0-9\\]+\" } */\n+  sink (f_size_1 (max));      /* { dg-warning \"argument 1 value .\\[0-9\\]+\\[lu\\]*. exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  sink (f_size_2 (0, max - 1));  /* { dg-warning \"argument 2 value .\\[0-9\\]+\\[lu\\]*. exceeds maximum object size \\[0-9\\]+\" } */\n+  sink (f_size_2 (max - 1, 0));  /* { dg-warning \"argument 1 value .\\[0-9\\]+\\[lu\\]*. exceeds maximum object size \\[0-9\\]+\" } */\n+  sink (f_size_2 (1, max - 1));  /* { dg-warning \"argument 2 value .\\[0-9\\]+\\[lu\\]*. exceeds maximum object size \\[0-9\\]+\" } */\n+  sink (f_size_2 (max - 1, 1));  /* { dg-warning \"argument 1 value .\\[0-9\\]+\\[lu\\]*. exceeds maximum object size \\[0-9\\]+\" } */\n+  sink (f_size_2 (max - 1, max - 1));  /* { dg-warning \"argument 1 value .\\[0-9\\]+\\[lu\\]*. exceeds maximum object size \\[0-9\\]+\" } */\n+  /* { dg-warning \"argument 2 value .\\[0-9\\]+\\[lu\\]*. exceeds maximum object size \\[0-9\\]+\" \"argument 2\" { target *-*-* } .-1 } */\n+\n+  sink (f_size_2 (0, max));      /* { dg-warning \"argument 2 value .\\[0-9\\]+\\[lu\\]*. exceeds maximum object size \\[0-9\\]+\" } */\n+  sink (f_size_2 (max, 0));      /* { dg-warning \"argument 1 value .\\[0-9\\]+\\[lu\\]*. exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  sink (f_size_2 (max / 2, 2));      /* { dg-warning \"product .\\[0-9\\]+\\[lu\\]* \\\\* \\[0-9\\]+\\[lu\\]*. of arguments 1 and 2 exceeds maximum object size \\[0-9\\]+\" } */\n+  sink (f_size_2 (max / 2, 3));      /* { dg-warning \"product .\\[0-9\\]+\\[lu\\]* \\\\* \\[0-9\\]+\\[lu\\]*. of arguments 1 and 2 exceeds .SIZE_MAX.\" } */\n+}\n+\n+void\n+test_size_range (size_t ui, ptrdiff_t si)\n+{\n+  const ptrdiff_t smin = PTRDIFF_MIN;\n+  const ptrdiff_t smax = PTRDIFF_MAX;\n+  const size_t umax = SIZE_MAX;\n+\n+  sink (f_size_1 (ui));\n+  sink (f_size_1 (si));\n+\n+  sink (f_size_1 (UR (0, 1)));\n+  sink (f_size_1 (UR (0, umax - 1)));\n+  sink (f_size_1 (UR (1, umax - 1)));\n+  sink (f_size_1 (UR (1, umax)));\n+\n+  sink (f_size_1 (UAR (1, 1)));\n+  /* Since the only valid argument in the anti-range below is zero\n+     a warning is expected even though -Walloc-zero is not specified.  */\n+  sink (f_size_1 (UAR (1, umax / 2)));   /* { dg-warning \"argument 1 range \\\\\\[\\[0-9\\]+\\[lu\\]*, \\[0-9\\]+\\[lu\\]*\\\\\\] exceeds maximum object size \" } */\n+  /* The only valid argument in this range is 1.  */\n+  sink (f_size_1 (UAR (2, umax / 2)));\n+\n+  sink (f_size_2 (ui, ui));\n+  sink (f_size_2 (si, si));\n+  sink (f_size_2 (ui, umax / 2));\n+  sink (f_size_2 (si, umax / 2));\n+  sink (f_size_2 (umax / 2, ui));\n+  sink (f_size_2 (umax / 2, si));\n+\n+  sink (f_size_2 (UR (0, 1), umax));   /* { dg-warning \"argument 2 value .\\[0-9\\]+\\[lu\\]*. exceeds maximum object size \" } */\n+  sink (f_size_2 (UR (0, 1), umax / 2));\n+  sink (f_size_2 (UR (0, umax / 2), umax / 2));\n+\n+  sink (f_size_2 (UR (umax / 2 + 1, umax / 2 + 2), ui));  /* { dg-warning \"argument 1 range \\\\\\[\\[0-9\\]+\\[lu\\]*, \\[0-9\\]+\\[lu\\]*\\\\\\] exceeds maximum object size \" } */\n+  sink (f_size_2 (ui, UR (umax / 2 + 1, umax / 2 + 2)));  /* { dg-warning \"argument 2 range \\\\\\[\\[0-9\\]+\\[lu\\]*, \\[0-9\\]+\\[lu\\]*\\\\\\] exceeds maximum object size \" } */\n+  sink (f_size_2 (UR (umax / 2 + 1, umax), UR (umax / 2 + 1, umax)));  /* { dg-warning \"argument 1 range \\\\\\[\\[0-9\\]+\\[lu\\]*, \\[0-9\\]+\\[lu\\]*\\\\\\] exceeds maximum object size \" } */\n+/* { dg-warning \"argument 2 range \\\\\\[\\[0-9\\]+\\[lu\\]*, \\[0-9\\]+\\[lu\\]*\\\\\\] exceeds maximum object size \" \"argument 2\" { target *-*-* } .-1 } */\n+\n+  sink (f_size_2 (SR (smin, 1), 1));\n+  sink (f_size_2 (SR (smin, 1), umax / 2));\n+  sink (f_size_2 (SR (-1, smax), 1));\n+  sink (f_size_2 (SR (-1, smax), umax / 2));\n+  sink (f_size_2 (SR (-1, 1), 1));\n+  sink (f_size_2 (SR (-1, 1), umax / 2));\n+  sink (f_size_2 (SR (-9, 9), 1));\n+  sink (f_size_2 (SR (-9, 9), umax / 2));\n+}"}, {"sha": "0a07d6e39e8828de7399e0e2574cbdc2a090ec4e", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size-4.c", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-4.c?ref=8bd9f164e29e8d6303ea421076e52be162158f7f", "patch": "@@ -0,0 +1,191 @@\n+/* PR c/77531 - __attribute__((alloc_size(1,2))) could also warn on\n+   multiplication overflow\n+   PR c/78284 - warn on malloc with very large arguments\n+   Test exercising the ability to detect and diagnose calls to allocation\n+   functions decorated with attribute alloc_size that either overflow or\n+   exceed the maximum object size specified by -Walloc-size-larger-than.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wall -Walloc-size-larger-than=1234\" } */\n+\n+#define INT_MAX    __INT_MAX__\n+#define INT_MIN    (-INT_MAX - 1)\n+#define UINT_MAX   (INT_MAX * 2U + 1)\n+\n+#define SIZE_MAX   __SIZE_MAX__\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#define ALLOC_SIZE(...) __attribute__ ((alloc_size (__VA_ARGS__)))\n+\n+void* f_uint_1 (unsigned) ALLOC_SIZE (1);\n+void* f_uint_2 (unsigned, unsigned) ALLOC_SIZE (1, 2);\n+void* f_int_1 (int) ALLOC_SIZE (1);\n+void* f_int_2 (int, int) ALLOC_SIZE (1, 2);\n+\n+void* f_size_1 (size_t) ALLOC_SIZE (1);\n+void* f_size_2 (size_t, size_t) ALLOC_SIZE (1, 2);\n+\n+size_t\n+unsigned_range (size_t min, size_t max)\n+{\n+  extern size_t random_unsigned_value (void);\n+  size_t val = random_unsigned_value ();\n+  if (val < min || max < val) val = min;\n+  return val;\n+}\n+\n+int\n+signed_range (int min, int max)\n+{\n+  extern int random_signed_value (void);\n+  int val = random_signed_value ();\n+  if (val < min || max < val) val = min;\n+  return val;\n+}\n+\n+size_t\n+unsigned_anti_range (size_t min, size_t max)\n+{\n+  extern size_t random_unsigned_value (void);\n+  size_t val = random_unsigned_value ();\n+  if (min <= val && val <= max)\n+    val = min - 1;\n+  return val;\n+}\n+\n+int\n+signed_anti_range (int min, int max)\n+{\n+  extern int random_signed_value (void);\n+  int val = random_signed_value ();\n+  if (min <= val && val <= max)\n+    val = min - 1;\n+  return val;\n+}\n+\n+#define UR(min, max) unsigned_range (min, max)\n+#define SR(min, max) signed_range (min, max)\n+\n+#define UAR(min, max) unsigned_anti_range (min, max)\n+#define SAR(min, max) signed_anti_range (min, max)\n+\n+\n+void sink (void*);\n+\n+void\n+test_uint_cst (void)\n+{\n+  const unsigned max = UINT_MAX;\n+\n+  sink (f_uint_1 (0));\n+  sink (f_uint_1 (1));\n+  sink (f_uint_1 (1233));\n+  sink (f_uint_1 (1234));\n+  sink (f_uint_1 (1235));       /* { dg-warning \"argument 1 value .1235u?. exceeds maximum object size 1234\" } */\n+  sink (f_uint_1 (max - 1));    /* { dg-warning \"argument 1 value .\\[0-9\\]+u?. exceeds maximum object size 1234\" } */\n+  sink (f_uint_1 (max));        /* { dg-warning \"argument 1 value .\\[0-9\\]+u?. exceeds maximum object size 1234\" } */\n+}\n+\n+void\n+test_uint_range (unsigned n)\n+{\n+  const unsigned max = UINT_MAX;\n+\n+  sink (f_uint_1 (n));\n+  sink (f_uint_1 (UR (0, 1)));\n+  sink (f_uint_1 (UR (0, 1233)));\n+  sink (f_uint_1 (UR (0, 1234)));\n+  sink (f_uint_1 (UR (0, 1235)));\n+  sink (f_uint_1 (UR (1, 1235)));\n+  sink (f_uint_1 (UR (1234, 1235)));\n+  sink (f_uint_1 (UR (1235, 1236)));   /* { dg-warning \"argument 1 range \\\\\\[\\[0-9\\]+u?, \\[0-9\\]+u?\\\\\\] exceeds maximum object size 1234\" } */\n+  sink (f_uint_1 (UR (1, max - 1)));\n+  sink (f_uint_1 (UR (1, max)));\n+}\n+\n+void\n+test_int_cst (void)\n+{\n+  const int min = INT_MIN;\n+  const int max = INT_MAX;\n+\n+  sink (f_int_1 (min));   /* { dg-warning \"argument 1 value .-\\[0-9\\]+. is negative\" } */\n+  sink (f_int_1 (-1));    /* { dg-warning \"argument 1 value .-1. is negative\" } */\n+  sink (f_int_1 (0));\n+  sink (f_int_1 (1));\n+  sink (f_int_1 (1233));\n+  sink (f_int_1 (1234));\n+  sink (f_int_1 (max));   /* { dg-warning \"argument 1 value .\\[0-9\\]+u?. exceeds maximum object size 1234\" } */\n+}\n+\n+void\n+test_int_range (int n)\n+{\n+  const int min = INT_MIN;\n+  const int max = INT_MAX;\n+\n+  sink (f_int_1 (n));\n+\n+  sink (f_int_1 (SR (min, 1234)));\n+  sink (f_int_1 (SR (-2, -1)));   /* { dg-warning \"argument 1 range \\\\\\[-2, -1\\\\\\] is negative\" } */\n+  sink (f_int_1 (SR (1235, 2345)));  /* { dg-warning \"argument 1 range \\\\\\[1235, 2345\\\\\\] exceeds maximum object size 1234\" } */\n+  sink (f_int_1 (SR (max - 1, max)));   /* { dg-warning \"argument 1 range \\\\\\[\\[0-9\\]+\\[lu\\]*, \\[0-9\\]+\\[lu\\]*\\\\\\] exceeds maximum object size 1234\" } */\n+\n+  sink (f_int_1 (SAR (-1, 1)));\n+  sink (f_int_1 (SAR (-2, 12)));\n+  sink (f_int_1 (SAR (-3, 123)));\n+  sink (f_int_1 (SAR (-4, 1234)));   /* { dg-warning \"argument 1 range \\\\\\[1235, -5\\\\\\] is both negative and exceeds maximum object size 1234\" } */\n+  sink (f_int_1 (SAR (min + 1, 1233)));\n+  sink (f_int_1 (SAR (min + 2, 1235)));   /* { dg-warning \"argument 1 range \\\\\\[1236, -\\[0-9\\]+\\\\\\] is both negative and exceeds maximum object size 1234\" } */\n+}\n+\n+void\n+test_size_cst (void)\n+{\n+  const size_t max = __SIZE_MAX__;\n+\n+  sink (f_size_1 (0));\n+  sink (f_size_1 (1));\n+\n+  sink (f_size_2 (   0, 1234));\n+  sink (f_size_2 (   1, 1234));\n+  sink (f_size_2 (   2, 1234));  /* { dg-warning \"product .2\\[lu\\]* \\\\* 1234\\[lu\\]*. of arguments 1 and 2 exceeds maximum object size \\[0-9\\]+\" } */\n+  sink (f_size_2 (1234, 1234));  /* { dg-warning \"product .1234\\[lu\\]* \\\\* 1234\\[lu\\]*. of arguments 1 and 2 exceeds maximum object size 1234\" } */\n+  sink (f_size_2 (1235, 1234));  /* { dg-warning \"argument 1 value .1235\\[lu\\]*. exceeds maximum object size 1234\" } */\n+  sink (f_size_2 (1234, 1235));  /* { dg-warning \"argument 2 value .1235\\[lu\\]*. exceeds maximum object size 1234\" } */\n+  sink (f_size_2 (1234, max));  /* { dg-warning \"argument 2 value .\\[0-9\\]+\\[lu\\]*. exceeds maximum object size 1234\" } */\n+  sink (f_size_2 (max, 1234));  /* { dg-warning \"argument 1 value .\\[0-9\\]+\\[lu\\]*. exceeds maximum object size 1234\" } */\n+}\n+\n+void\n+test_size_range (size_t n)\n+{\n+  const size_t max = __SIZE_MAX__;\n+\n+  sink (f_size_1 (n));\n+\n+  sink (f_size_1 (UR (0, 1)));\n+  sink (f_size_1 (UR (0, max - 1)));\n+  sink (f_size_1 (UR (1, max - 1)));\n+  sink (f_size_1 (UR (1, max)));\n+\n+  sink (f_size_1 (UAR (1, 1)));\n+  /* Since the only valid argument in the anti-range below is zero\n+     a warning is expected even though -Walloc-zero is not specified.  */\n+  sink (f_size_1 (UAR (1, 1234)));   /* { dg-warning \"argument 1 range \\\\\\[\\[0-9\\]+\\[lu\\]*, \\[0-9\\]+\\[lu\\]*\\\\\\] exceeds maximum object size \" } */\n+  /* The only valid argument in this range is 1.  */\n+  sink (f_size_1 (UAR (2, max / 2)));\n+\n+  sink (f_size_2 (n, n));\n+  sink (f_size_2 (n, 1234));\n+  sink (f_size_2 (1234, n));\n+\n+  sink (f_size_2 (UR (0, 1), 1234));\n+  sink (f_size_2 (UR (0, 1), 1235));   /* { dg-warning \"argument 2 value .1235\\[lu\\]*. exceeds maximum object size 1234\" } */\n+\n+  sink (f_size_2 (UR (1235, 1236), n));  /* { dg-warning \"argument 1 range \\\\\\[1235\\[lu\\]*, 1236\\[lu\\]*\\\\\\] exceeds maximum object size 1234\" } */\n+\n+  sink (f_size_2 (UR (1235, 1236), UR (max / 2, max)));  /* { dg-warning \"argument 1 range \\\\\\[\\[0-9\\]+\\[lu\\]*, \\[0-9\\]+\\[lu\\]*\\\\\\] exceeds maximum object size \" } */\n+/* { dg-warning \"argument 2 range \\\\\\[\\[0-9\\]+\\[lu\\]*, \\[0-9\\]+\\[lu\\]*\\\\\\] exceeds maximum object size \" \"argument 2\" { target *-*-* } .-1 } */\n+\n+}"}, {"sha": "f9884ed72f7a6ee6d9eaf21fc4fa351785555a55", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size-5.c", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-5.c?ref=8bd9f164e29e8d6303ea421076e52be162158f7f", "patch": "@@ -0,0 +1,234 @@\n+/* PR c/78284 - warn on malloc with very large arguments\n+   Test exercising the ability to detect and diagnose calls to allocation\n+   functions decorated with attribute alloc_size that attempt to allocate\n+   zero bytes.  For standard allocation functions the return value is\n+   implementation-defined and so relying on it may be a source of bugs.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wall -Walloc-zero\" } */\n+\n+#define SCHAR_MAX  __SCHAR_MAX__\n+#define SCHAR_MIN  (-SCHAR_MAX - 1)\n+#define UCHAR_MAX  (SCHAR_MAX * 2 + 1)\n+\n+#define SHRT_MAX   __SHRT_MAX__\n+#define SHRT_MIN   (-SHRT_MAX - 1)\n+#define USHRT_MAX  (SHRT_MAX * 2 + 1)\n+\n+#define INT_MAX    __INT_MAX__\n+#define INT_MIN    (-INT_MAX - 1)\n+#define UINT_MAX   (INT_MAX * 2U + 1)\n+\n+#define LONG_MAX   __LONG_MAX__\n+#define LONG_MIN   (-LONG_MAX - 1L)\n+#define ULONG_MAX  (LONG_MAX * 2LU + 1)\n+\n+#define LLONG_MAX  __LLONG_MAX__\n+#define LLONG_MIN  (-LLONG_MAX - 1LL)\n+#define ULLONG_MAX (ULLONG_MAX * 2LLU + 1)\n+\n+#define SIZE_MAX   __SIZE_MAX__\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+\n+#define ALLOC_SIZE(...) __attribute__ ((alloc_size (__VA_ARGS__)))\n+\n+void* f_uchar_1 (unsigned char) ALLOC_SIZE (1);\n+void* f_uchar_2 (unsigned char, unsigned char) ALLOC_SIZE (1, 2);\n+void* f_schar_1 (signed char) ALLOC_SIZE (1);\n+void* f_schar_2 (signed char, signed char) ALLOC_SIZE (1, 2);\n+\n+void* f_ushrt_1 (unsigned short) ALLOC_SIZE (1);\n+void* f_ushrt_2 (unsigned short, unsigned short) ALLOC_SIZE (1, 2);\n+void* f_shrt_1 (signed short) ALLOC_SIZE (1);\n+void* f_shrt_2 (signed short, signed short) ALLOC_SIZE (1, 2);\n+\n+void* f_uint_1 (unsigned) ALLOC_SIZE (1);\n+void* f_uint_2 (unsigned, unsigned) ALLOC_SIZE (1, 2);\n+void* f_int_1 (int) ALLOC_SIZE (1);\n+void* f_int_2 (int, int) ALLOC_SIZE (1, 2);\n+\n+void* f_ulong_1 (unsigned long) ALLOC_SIZE (1);\n+void* f_ulong_2 (unsigned long, unsigned long) ALLOC_SIZE (1, 2);\n+void* f_long_1 (long) ALLOC_SIZE (1);\n+void* f_long_2 (long, long) ALLOC_SIZE (1, 2);\n+\n+void* f_ullong_1 (unsigned long long) ALLOC_SIZE (1);\n+void* f_ullong_2 (unsigned long long, unsigned long long) ALLOC_SIZE (1, 2);\n+void* f_llong_1 (long long) ALLOC_SIZE (1);\n+void* f_llong_2 (long long, long long) ALLOC_SIZE (1, 2);\n+\n+void* f_size_1 (size_t) ALLOC_SIZE (1);\n+void* f_size_2 (size_t, size_t) ALLOC_SIZE (1, 2);\n+\n+void* f_size_1_nonnull (size_t)\n+     ALLOC_SIZE (1)  __attribute__ ((returns_nonnull));\n+void* f_size_2_nonnull (size_t, size_t)\n+     ALLOC_SIZE (1, 2) __attribute__ ((returns_nonnull));\n+\n+void sink (void*);\n+\n+void\n+test_uchar (unsigned char n)\n+{\n+  sink (f_uchar_1 (0));     /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_uchar_2 (0, 1));  /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_uchar_2 (1, 0));  /* { dg-warning \"argument 2 value is zero\" } */\n+  sink (f_uchar_2 (n, 0));  /* { dg-warning \"argument 2 value is zero\" } */\n+  sink (f_uchar_2 (0, n));  /* { dg-warning \"argument 1 value is zero\" } */\n+\n+  sink (f_uchar_1 (n));\n+  n = 0;\n+  sink (f_uchar_1 (n));     /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_uchar_2 (1, n));  /* { dg-warning \"argument 2 value is zero\" } */\n+}\n+\n+void\n+test_schar (signed char n)\n+{\n+  sink (f_schar_1 (0));     /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_schar_2 (0, 1));  /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_schar_2 (1, 0));  /* { dg-warning \"argument 2 value is zero\" } */\n+  sink (f_schar_2 (n, 0));  /* { dg-warning \"argument 2 value is zero\" } */\n+  sink (f_schar_2 (0, n));  /* { dg-warning \"argument 1 value is zero\" } */\n+\n+  sink (f_schar_1 (n));\n+  n = 0;\n+  sink (f_schar_1 (n));     /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_schar_2 (1, n));  /* { dg-warning \"argument 2 value is zero\" } */\n+}\n+\n+void\n+test_ushrt (unsigned short n)\n+{\n+  sink (f_ushrt_1 (0));     /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_ushrt_2 (0, 1));  /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_ushrt_2 (1, 0));  /* { dg-warning \"argument 2 value is zero\" } */\n+  sink (f_ushrt_2 (n, 0));  /* { dg-warning \"argument 2 value is zero\" } */\n+  sink (f_ushrt_2 (0, n));  /* { dg-warning \"argument 1 value is zero\" } */\n+\n+  sink (f_ushrt_1 (n));\n+  n = 0;\n+  sink (f_ushrt_1 (n));     /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_ushrt_2 (1, n));  /* { dg-warning \"argument 2 value is zero\" } */\n+}\n+\n+void\n+test_shrt (short n)\n+{\n+  sink (f_shrt_1 (0));      /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_shrt_2 (0, 1));   /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_shrt_2 (1, 0));   /* { dg-warning \"argument 2 value is zero\" } */\n+  sink (f_shrt_2 (n, 0));   /* { dg-warning \"argument 2 value is zero\" } */\n+  sink (f_shrt_2 (0, n));   /* { dg-warning \"argument 1 value is zero\" } */\n+\n+  sink (f_shrt_1 (n));\n+  n = 0;\n+  sink (f_shrt_1 (n));      /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_shrt_2 (1, n));   /* { dg-warning \"argument 2 value is zero\" } */\n+}\n+\n+void\n+test_uint (unsigned n)\n+{\n+  sink (f_uint_1 (0));      /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_uint_2 (0, 1));   /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_uint_2 (1, 0));   /* { dg-warning \"argument 2 value is zero\" } */\n+  sink (f_uint_2 (n, 0));   /* { dg-warning \"argument 2 value is zero\" } */\n+  sink (f_uint_2 (0, n));   /* { dg-warning \"argument 1 value is zero\" } */\n+\n+  sink (f_uint_1 (n));\n+  n = 0;\n+  sink (f_uint_1 (n));      /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_uint_2 (1, n));   /* { dg-warning \"argument 2 value is zero\" } */\n+}\n+\n+void\n+test_int (int n)\n+{\n+  sink (f_int_1 (0));       /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_int_2 (0, 1));    /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_int_2 (1, 0));    /* { dg-warning \"argument 2 value is zero\" } */\n+  sink (f_int_2 (n, 0));    /* { dg-warning \"argument 2 value is zero\" } */\n+  sink (f_int_2 (0, n));    /* { dg-warning \"argument 1 value is zero\" } */\n+\n+  sink (f_int_1 (n));\n+  n = 0;\n+  sink (f_int_1 (n));       /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_int_2 (1, n));    /* { dg-warning \"argument 2 value is zero\" } */\n+}\n+\n+void\n+test_ulong (unsigned long n)\n+{\n+  sink (f_ulong_1 (0));     /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_ulong_2 (0, 1));  /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_ulong_2 (1, 0));  /* { dg-warning \"argument 2 value is zero\" } */\n+  sink (f_ulong_2 (n, 0));  /* { dg-warning \"argument 2 value is zero\" } */\n+  sink (f_ulong_2 (0, n));  /* { dg-warning \"argument 1 value is zero\" } */\n+\n+  sink (f_ulong_1 (n));\n+  n = 0;\n+  sink (f_ulong_1 (n));     /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_ulong_2 (1, n));  /* { dg-warning \"argument 2 value is zero\" } */\n+}\n+\n+void\n+test_long (long n)\n+{\n+  sink (f_long_1 (0));      /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_long_2 (0, 1));   /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_long_2 (1, 0));   /* { dg-warning \"argument 2 value is zero\" } */\n+  sink (f_long_2 (n, 0));   /* { dg-warning \"argument 2 value is zero\" } */\n+  sink (f_long_2 (0, n));   /* { dg-warning \"argument 1 value is zero\" } */\n+\n+  sink (f_long_1 (n));\n+  n = 0;\n+  sink (f_long_1 (n));      /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_long_2 (1, n));   /* { dg-warning \"argument 2 value is zero\" } */\n+}\n+\n+void\n+test_size (size_t n)\n+{\n+  sink (f_size_1 (0));      /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_size_2 (0, 1));   /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_size_2 (1, 0));   /* { dg-warning \"argument 2 value is zero\" } */\n+  sink (f_size_2 (n, 0));   /* { dg-warning \"argument 2 value is zero\" } */\n+  sink (f_size_2 (0, n));   /* { dg-warning \"argument 1 value is zero\" } */\n+\n+  sink (f_size_1 (n));\n+  n = 0;\n+  sink (f_size_1 (n));      /* { dg-warning \"argument 1 value is zero\" } */\n+  sink (f_size_2 (1, n));   /* { dg-warning \"argument 2 value is zero\" } */\n+}\n+\n+/* Verify that calls to allocation function decorated with attribute\n+   returns_nonnull don't cause warnings (unlike functions like malloc\n+   that can return null in this case there's nothing to warn about\n+   because a returns_nonnull function guarantees success).  */\n+\n+void\n+test_size_nonnull (size_t n)\n+{\n+  sink (f_size_1_nonnull (0));\n+  sink (f_size_2_nonnull (0, 1));\n+  sink (f_size_2_nonnull (1, 0));\n+  sink (f_size_2_nonnull (n, 0));\n+  sink (f_size_2_nonnull (0, n));\n+\n+  sink (f_size_1_nonnull (n));\n+  n = 0;\n+  sink (f_size_1_nonnull (n));\n+  sink (f_size_2_nonnull (1, n));\n+}\n+\n+/* Verify that call to plain alloca(0) is not diagnosed.  */\n+\n+void\n+test_alloca (size_t n)\n+{\n+  extern void* alloca (size_t);\n+\n+  alloca (0);\n+}"}, {"sha": "38890b69147339a7fa6ac07cd068660d81288f1c", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size-6.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-6.c?ref=8bd9f164e29e8d6303ea421076e52be162158f7f", "patch": "@@ -0,0 +1,73 @@\n+/* PR c/78284 - warn on malloc with very large arguments\n+   Test exercising the ability of the built-in allocation functions\n+   to detect and diagnose, without optimization, calls that attemnpt\n+   to allocate objects in excess of the number of bytes specified by\n+   -Walloc-larger-than=maximum.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -Wall -Walloc-size-larger-than=12345\" } */\n+\n+#define MAXOBJSZ  12345\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void sink (void*);\n+\n+\n+void test_lit (char *p, char *q)\n+{\n+  sink (__builtin_aligned_alloc (MAXOBJSZ, 1));\n+  sink (__builtin_aligned_alloc (MAXOBJSZ + 1, 1));   /* { dg-warning \"argument 1 value .12346\\[lu\\]*. exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_alloca (MAXOBJSZ));\n+  sink (__builtin_alloca (MAXOBJSZ + 2));   /* { dg-warning \"argument 1 value .12347\\[lu\\]*. exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_calloc (MAXOBJSZ, 1));\n+  sink (__builtin_calloc (1, MAXOBJSZ));\n+\n+  /* Verify that the signed to unsigned conversion below doesn't cause\n+     a warning.  */\n+  sink (__builtin_calloc (p - q, 1));\n+  sink (__builtin_calloc (1, q - p));\n+  sink (__builtin_calloc (p - q, MAXOBJSZ));\n+  sink (__builtin_calloc (MAXOBJSZ, q - p));\n+\n+  sink (__builtin_calloc (MAXOBJSZ / 2, 3));   /* { dg-warning \"product .6172\\[lu\\]* \\\\* 3\\[lu\\]*. of arguments 1 and 2 exceeds maximum object size 12345\" } */\n+  sink (__builtin_calloc (4, MAXOBJSZ / 3));   /* { dg-warning \"product .4\\[lu\\]* \\\\* 4115\\[lu\\]*. of arguments 1 and 2 exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_malloc (MAXOBJSZ));\n+  sink (__builtin_malloc (MAXOBJSZ + 3));   /* { dg-warning \"argument 1 value .12348\\[lu\\]*. exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_realloc (p, MAXOBJSZ));\n+  sink (__builtin_realloc (p, MAXOBJSZ + 4));  /* { dg-warning \"argument 2 value .12349\\[lu\\]*. exceeds maximum object size 12345\" } */\n+}\n+\n+\n+enum { max = MAXOBJSZ };\n+\n+void test_cst (char *p, char *q)\n+{\n+  sink (__builtin_aligned_alloc (max, 1));\n+  sink (__builtin_aligned_alloc (max + 1, 1));   /* { dg-warning \"argument 1 value .12346\\[lu\\]*. exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_alloca (max));\n+  sink (__builtin_alloca (max + 2));   /* { dg-warning \"argument 1 value .12347\\[lu\\]*. exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_calloc (max, 1));\n+  sink (__builtin_calloc (1, max));\n+\n+  /* Verify that the signed to unsigned conversion below doesn't cause\n+     a warning.  */\n+  sink (__builtin_calloc (p - q, 1));\n+  sink (__builtin_calloc (1, q - p));\n+  sink (__builtin_calloc (p - q, max));\n+  sink (__builtin_calloc (max, q - p));\n+\n+  sink (__builtin_calloc (max / 2, 3));   /* { dg-warning \"product .6172\\[lu\\]* \\\\* 3\\[lu\\]*. of arguments 1 and 2 exceeds maximum object size 12345\" } */\n+  sink (__builtin_calloc (4, max / 3));   /* { dg-warning \"product .4\\[lu\\]* \\\\* 4115\\[lu\\]*. of arguments 1 and 2 exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_malloc (max));\n+  sink (__builtin_malloc (max + 3));   /* { dg-warning \"argument 1 value .12348\\[lu\\]*. exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_realloc (p, max));\n+  sink (__builtin_realloc (p, max + 4));  /* { dg-warning \"argument 2 value .12349\\[lu\\]*. exceeds maximum object size 12345\" } */\n+}"}, {"sha": "d6e618d27683484ea71f596480a2c953f4ad54c7", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size-7.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-7.c?ref=8bd9f164e29e8d6303ea421076e52be162158f7f", "patch": "@@ -0,0 +1,72 @@\n+/* PR c/78284 - warn on malloc with very large arguments\n+   Test exercising the ability of the built-in allocation functions to\n+   detect and diagnose calls that attemnpt to allocate objects in excess\n+   of the maximum specified by -Walloc-size-larger-than=maximum.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wall -Walloc-size-larger-than=12345\" } */\n+\n+#define SIZE_MAX   __SIZE_MAX__\n+#define MAXOBJSZ   12345\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void sink (void*);\n+\n+size_t maxobjsize (void)\n+{\n+  return MAXOBJSZ;\n+}\n+\n+\n+void test_var (void *p)\n+{\n+  size_t max = maxobjsize ();\n+\n+  sink (__builtin_aligned_alloc (max, 1));\n+  sink (__builtin_aligned_alloc (max + 1, 1));   /* { dg-warning \"argument 1 value .12346\\[lu\\]*. exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_alloca (max));\n+  sink (__builtin_alloca (max + 2));   /* { dg-warning \"argument 1 value .12347\\[lu\\]*. exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_calloc (1, max));\n+  sink (__builtin_calloc (max, 1));\n+\n+  sink (__builtin_calloc (max / 2, 3));   /* { dg-warning \"product .6172\\[lu\\]* \\\\* 3\\[lu\\]*. of arguments 1 and 2 exceeds maximum object size 12345\" } */\n+  sink (__builtin_calloc (4, max / 3));   /* { dg-warning \"product .4\\[lu\\]* \\\\* 4115\\[lu\\]*. of arguments 1 and 2 exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_malloc (max));\n+  sink (__builtin_malloc (max + 3));   /* { dg-warning \"argument 1 value .12348\\[lu\\]*. exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_realloc (p, max));\n+  sink (__builtin_realloc (p, max + 4));  /* { dg-warning \"argument 2 value .12349\\[lu\\]*. exceeds maximum object size 12345\" } */\n+}\n+\n+\n+void test_range (void *p, size_t range)\n+{\n+  /* Make sure the variable is at least as large as the maximum object\n+     size but also make sure that it's guaranteed not to be too big to\n+     increment (and wrap around).  */\n+  size_t max = maxobjsize ();\n+\n+  if (range < max || 2 * max <= range)\n+    range = maxobjsize ();\n+\n+  sink (__builtin_aligned_alloc (range, 1));\n+  sink (__builtin_aligned_alloc (range + 1, 1));   /* { dg-warning \"argument 1 range \\\\\\[12346\\[lu\\]*, \\[0-9\\]+\\[lu\\]*\\\\\\] exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_alloca (range));\n+  sink (__builtin_alloca (range + 2));   /* { dg-warning \"argument 1 range \\\\\\[12347\\[lu\\]*, \\[0-9\\]+\\[lu\\]*\\\\\\] exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_calloc (range, 1));\n+  sink (__builtin_calloc (1, range));\n+\n+  sink (__builtin_calloc (range / 2, 3));   /* { dg-warning \"product .6172\\[lu\\]* \\\\* 3\\[lu\\]*. of arguments 1 and 2 exceeds maximum object size 12345\" } */\n+  sink (__builtin_calloc (4, range / 3));   /* { dg-warning \"product .4\\[lu\\]* \\\\* 4115\\[lu\\]*. of arguments 1 and 2 exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_malloc (range));\n+  sink (__builtin_malloc (range + 3));   /* { dg-warning \"argument 1 range \\\\\\[12348\\[lu\\]*, 24692\\[lu\\]*\\\\\\] exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_realloc (p, range));\n+  sink (__builtin_realloc (p, range + 4));  /* { dg-warning \"argument 2 range \\\\\\[12349\\[lu\\]*, 24693\\[lu\\]*\\\\\\] exceeds maximum object size 12345\" } */\n+}"}, {"sha": "6282a46e6df0fda01d4822a6648e5f685db398b2", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size-8.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-8.c?ref=8bd9f164e29e8d6303ea421076e52be162158f7f", "patch": "@@ -0,0 +1,61 @@\n+/* PR c/78284 - warn on malloc with very large arguments\n+   Test to exercise the interaction of the -Walloca-larger-than,\n+   -Wvla-larger-than, and -Walloc-size-larger-than options.  The former\n+   two more specific options override the more general latter option.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Walloc-size-larger-than=123 -Walloca-larger-than=234 -Wvla-larger-than=345\" } */\n+\n+#define SIZE_MAX   __SIZE_MAX__\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void sink (void*);\n+\n+size_t alloc_size_limit (void)\n+{\n+  return 123;\n+}\n+\n+size_t alloca_limit (void)\n+{\n+  return 234;\n+}\n+\n+size_t vla_limit (void)\n+{\n+  return 345;\n+}\n+\n+void test_alloca (void)\n+{\n+  void *p;\n+\n+  /* No warning should be issued for the following call because the more\n+     permissive alloca limit overrides the stricter alloc_size limit.  */\n+  p = __builtin_alloca (alloca_limit ());\n+  sink (p);\n+\n+  p = __builtin_alloca (alloca_limit () + 1);   /* { dg-warning \"argument to .alloca. is too large\" } */\n+  sink (p);\n+}\n+\n+void test_vla (void)\n+{\n+  /* Same as above, no warning should be issued here because the more\n+     permissive VLA limit overrides the stricter alloc_size limit.  */\n+  char vla1 [vla_limit ()];\n+  sink (vla1);\n+\n+  char vla2 [vla_limit () + 1];   /* { dg-warning \"argument to variable-length array is too large\" } */\n+  sink (vla2);\n+}\n+\n+void test_malloc (void)\n+{\n+  void *p;\n+  p = __builtin_malloc (alloc_size_limit ());\n+  sink (p);\n+\n+  p = __builtin_malloc (alloc_size_limit () + 1);   /* { dg-warning \"argument 1 value .124\\[lu\\]*. exceeds maximum object size 123\" } */\n+  sink (p);\n+}"}, {"sha": "66765fd4836a7e9f7a321a7b70643b606b607ef6", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size-9.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-9.c?ref=8bd9f164e29e8d6303ea421076e52be162158f7f", "patch": "@@ -0,0 +1,30 @@\n+/* PR c/78284 - warn on malloc with very large arguments\n+   Test verifying that the built-in allocation functions are declared\n+   with attribute malloc.  This means that the pointer they return\n+   can be assumed not to alias any other valid pointer.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+void sink (void*);\n+\n+extern int x;\n+\n+#define TEST(call)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    p = call;\t\t\t\t\t\\\n+    x = 123;\t\t\t\t\t\\\n+    *(int*)p = 456;\t\t\t\t\\\n+    (x == 123) ? (void)0 : __builtin_abort ();\t\\\n+    sink (p);\t\t\t\t\t\\\n+  } while (0)\n+\n+void test (void *p, unsigned n)\n+{\n+  TEST (__builtin_aligned_alloc (n, 8));\n+  TEST (__builtin_alloca (n));\n+  TEST (__builtin_calloc (4, n));\n+  TEST (__builtin_malloc (n));\n+  TEST (__builtin_realloc (p, n + 1));\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"abort\" \"optimized\" } } */"}, {"sha": "0dfb00087dee04cd5ff1e916149c0c13c9b87b20", "filename": "gcc/testsuite/gcc.dg/errno-1.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Ftestsuite%2Fgcc.dg%2Ferrno-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd9f164e29e8d6303ea421076e52be162158f7f/gcc%2Ftestsuite%2Fgcc.dg%2Ferrno-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ferrno-1.c?ref=8bd9f164e29e8d6303ea421076e52be162158f7f", "patch": "@@ -10,10 +10,12 @@ int main()\n {\n   void * volatile p;\n   errno = 0;\n+  /* The malloc call below may cause a -Walloc-size-larger-than warning.  */\n   p = malloc (-1);\n   if (errno != 0)\n     do_not_optimize_away ();\n   return 0;\n }\n \n /* { dg-final { scan-assembler \"do_not_optimize_away\" } } */\n+/* { dg-prune-output \"exceeds maximum object size\" } */"}]}