{"sha": "3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y0MzNiYzA3ZWJjOTgyMWE0ZWRlZWE5ZWNmYTNlYTk0YjBiMDBkMQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2014-07-18T09:27:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-18T09:27:00Z"}, "message": "sem_aggr.adb (Aggregate_Constraint_Checks): Moved to sem_util.\n\n2014-07-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_aggr.adb (Aggregate_Constraint_Checks): Moved to sem_util.\n\t* sem_util.ads, sem_util.adb (Aggregate_Constraint_Checks):\n\tMoved here, so it can be shared with the resolution of 'Update,\n\twhose argument shares some features with aggregates.\n\t* sem_attr.adb (Resolve_Attribute, case 'Update): Apply\n\tAggregate_Constraint_Checks with the expression of each\n\tassociation, so that the Do_Range_Check flag is set when needed.\n\n2014-07-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Try_Container_Indexing):  If the container\n\ttype is a derived type, the value of the inherited  aspect is\n\tthe Reference operation declared for the parent type. However,\n\tReference is also a primitive operation of the new type, and\n\tthe inherited operation has a different signature. We retrieve\n\tthe right one from the list of primitive operations of the\n\tderived type.\n\nFrom-SVN: r212786", "tree": {"sha": "bfb8a8c98a7574e7d1663ee14b60c500f350884d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfb8a8c98a7574e7d1663ee14b60c500f350884d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0439c912c329d87c22917b07a65487253e47433d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0439c912c329d87c22917b07a65487253e47433d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0439c912c329d87c22917b07a65487253e47433d"}], "stats": {"total": 289, "additions": 164, "deletions": 125}, "files": [{"sha": "cb343c818a52d5148735896305fe46807dbc2d1a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1", "patch": "@@ -1,3 +1,23 @@\n+2014-07-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_aggr.adb (Aggregate_Constraint_Checks): Moved to sem_util.\n+\t* sem_util.ads, sem_util.adb (Aggregate_Constraint_Checks):\n+\tMoved here, so it can be shared with the resolution of 'Update,\n+\twhose argument shares some features with aggregates.\n+\t* sem_attr.adb (Resolve_Attribute, case 'Update): Apply\n+\tAggregate_Constraint_Checks with the expression of each\n+\tassociation, so that the Do_Range_Check flag is set when needed.\n+\n+2014-07-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Try_Container_Indexing):  If the container\n+\ttype is a derived type, the value of the inherited  aspect is\n+\tthe Reference operation declared for the parent type. However,\n+\tReference is also a primitive operation of the new type, and\n+\tthe inherited operation has a different signature. We retrieve\n+\tthe right one from the list of primitive operations of the\n+\tderived type.\n+\n 2014-07-18  Vincent Celier  <celier@adacore.com>\n \n \t* debug.adb: Update comment."}, {"sha": "0a272391d166913c25fcb527f26b32355eef0964", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1", "patch": "@@ -408,134 +408,11 @@ package body Sem_Aggr is\n    --  The bounds of the aggregate itype are cooked up to look reasonable\n    --  (in this particular case the bounds will be 1 .. 2).\n \n-   procedure Aggregate_Constraint_Checks\n-     (Exp       : Node_Id;\n-      Check_Typ : Entity_Id);\n-   --  Checks expression Exp against subtype Check_Typ. If Exp is an\n-   --  aggregate and Check_Typ a constrained record type with discriminants,\n-   --  we generate the appropriate discriminant checks. If Exp is an array\n-   --  aggregate then emit the appropriate length checks. If Exp is a scalar\n-   --  type, or a string literal, Exp is changed into Check_Typ'(Exp) to\n-   --  ensure that range checks are performed at run time.\n-\n    procedure Make_String_Into_Aggregate (N : Node_Id);\n    --  A string literal can appear in  a context in  which a one dimensional\n    --  array of characters is expected. This procedure simply rewrites the\n    --  string as an aggregate, prior to resolution.\n \n-   ---------------------------------\n-   -- Aggregate_Constraint_Checks --\n-   ---------------------------------\n-\n-   procedure Aggregate_Constraint_Checks\n-     (Exp       : Node_Id;\n-      Check_Typ : Entity_Id)\n-   is\n-      Exp_Typ : constant Entity_Id  := Etype (Exp);\n-\n-   begin\n-      if Raises_Constraint_Error (Exp) then\n-         return;\n-      end if;\n-\n-      --  Ada 2005 (AI-230): Generate a conversion to an anonymous access\n-      --  component's type to force the appropriate accessibility checks.\n-\n-      --  Ada 2005 (AI-231): Generate conversion to the null-excluding\n-      --  type to force the corresponding run-time check\n-\n-      if Is_Access_Type (Check_Typ)\n-        and then ((Is_Local_Anonymous_Access (Check_Typ))\n-                    or else (Can_Never_Be_Null (Check_Typ)\n-                               and then not Can_Never_Be_Null (Exp_Typ)))\n-      then\n-         Rewrite (Exp, Convert_To (Check_Typ, Relocate_Node (Exp)));\n-         Analyze_And_Resolve (Exp, Check_Typ);\n-         Check_Unset_Reference (Exp);\n-      end if;\n-\n-      --  This is really expansion activity, so make sure that expansion is\n-      --  on and is allowed. In GNATprove mode, we also want check flags to\n-      --  be added in the tree, so that the formal verification can rely on\n-      --  those to be present. In GNATprove mode for formal verification, some\n-      --  treatment typically only done during expansion needs to be performed\n-      --  on the tree, but it should not be applied inside generics. Otherwise,\n-      --  this breaks the name resolution mechanism for generic instances.\n-\n-      if not Expander_Active\n-        and (Inside_A_Generic or not Full_Analysis or not GNATprove_Mode)\n-      then\n-         return;\n-      end if;\n-\n-      --  First check if we have to insert discriminant checks\n-\n-      if Has_Discriminants (Exp_Typ) then\n-         Apply_Discriminant_Check (Exp, Check_Typ);\n-\n-      --  Next emit length checks for array aggregates\n-\n-      elsif Is_Array_Type (Exp_Typ) then\n-         Apply_Length_Check (Exp, Check_Typ);\n-\n-      --  Finally emit scalar and string checks. If we are dealing with a\n-      --  scalar literal we need to check by hand because the Etype of\n-      --  literals is not necessarily correct.\n-\n-      elsif Is_Scalar_Type (Exp_Typ)\n-        and then Compile_Time_Known_Value (Exp)\n-      then\n-         if Is_Out_Of_Range (Exp, Base_Type (Check_Typ)) then\n-            Apply_Compile_Time_Constraint_Error\n-              (Exp, \"value not in range of}??\", CE_Range_Check_Failed,\n-               Ent => Base_Type (Check_Typ),\n-               Typ => Base_Type (Check_Typ));\n-\n-         elsif Is_Out_Of_Range (Exp, Check_Typ) then\n-            Apply_Compile_Time_Constraint_Error\n-              (Exp, \"value not in range of}??\", CE_Range_Check_Failed,\n-               Ent => Check_Typ,\n-               Typ => Check_Typ);\n-\n-         elsif not Range_Checks_Suppressed (Check_Typ) then\n-            Apply_Scalar_Range_Check (Exp, Check_Typ);\n-         end if;\n-\n-      --  Verify that target type is also scalar, to prevent view anomalies\n-      --  in instantiations.\n-\n-      elsif (Is_Scalar_Type (Exp_Typ)\n-              or else Nkind (Exp) = N_String_Literal)\n-        and then Is_Scalar_Type (Check_Typ)\n-        and then Exp_Typ /= Check_Typ\n-      then\n-         if Is_Entity_Name (Exp)\n-           and then Ekind (Entity (Exp)) = E_Constant\n-         then\n-            --  If expression is a constant, it is worthwhile checking whether\n-            --  it is a bound of the type.\n-\n-            if (Is_Entity_Name (Type_Low_Bound (Check_Typ))\n-                 and then Entity (Exp) = Entity (Type_Low_Bound (Check_Typ)))\n-              or else (Is_Entity_Name (Type_High_Bound (Check_Typ))\n-                and then Entity (Exp) = Entity (Type_High_Bound (Check_Typ)))\n-            then\n-               return;\n-\n-            else\n-               Rewrite (Exp, Convert_To (Check_Typ, Relocate_Node (Exp)));\n-               Analyze_And_Resolve (Exp, Check_Typ);\n-               Check_Unset_Reference (Exp);\n-            end if;\n-         else\n-            Rewrite (Exp, Convert_To (Check_Typ, Relocate_Node (Exp)));\n-            Analyze_And_Resolve (Exp, Check_Typ);\n-            Check_Unset_Reference (Exp);\n-         end if;\n-\n-      end if;\n-   end Aggregate_Constraint_Checks;\n-\n    ------------------------\n    -- Array_Aggr_Subtype --\n    ------------------------"}, {"sha": "5326490da6c992591cc75d8042230018cb0f8f91", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1", "patch": "@@ -10802,6 +10802,7 @@ package body Sem_Attr is\n                Typ   : constant Entity_Id := Etype (Prefix (N));\n                Assoc : Node_Id;\n                Comp  : Node_Id;\n+               Expr  : Node_Id;\n \n             begin\n                --  Set the Etype of the aggregate to that of the prefix, even\n@@ -10814,12 +10815,14 @@ package body Sem_Attr is\n                Resolve (Prefix (N), Typ);\n \n                --  For an array type, resolve expressions with the component\n-               --  type of the array.\n+               --  type of the array, and apply constraint checks when needed.\n \n                if Is_Array_Type (Typ) then\n                   Assoc := First (Component_Associations (Aggr));\n                   while Present (Assoc) loop\n-                     Resolve (Expression (Assoc), Component_Type (Typ));\n+                     Expr  := Expression (Assoc);\n+                     Resolve (Expr, Component_Type (Typ));\n+                     Aggregate_Constraint_Checks (Expr, Component_Type (Typ));\n \n                      --  The choices in the association are static constants,\n                      --  or static aggregates each of whose components belongs"}, {"sha": "6d0db7d63f7bd3921e65aad8f461eb68f975e20d", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1", "patch": "@@ -7020,6 +7020,16 @@ package body Sem_Ch4 is\n          else\n             return False;\n          end if;\n+\n+      --  If the container type is a derived type, the value of the inherited\n+      --  aspect is the Reference operation declared for the parent type.\n+      --  However, Reference is also a primitive operation of the type, and\n+      --  the inherited operation has a different signature. We retrieve the\n+      --  right one from the list of primitive operations of the derived type.\n+\n+      elsif Is_Derived_Type (Etype (Prefix)) then\n+         Func := Find_Prim_Op (Etype (Prefix), Chars (Func_Name));\n+         Func_Name := New_Occurrence_Of (Func, Loc);\n       end if;\n \n       Assoc := New_List (Relocate_Node (Prefix));"}, {"sha": "2c53b51b32d3a262939fc989cbc47b0588f716f6", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1", "patch": "@@ -52,6 +52,7 @@ with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n with Sem_Prag; use Sem_Prag;\n with Sem_Res;  use Sem_Res;\n+with Sem_Warn; use Sem_Warn;\n with Sem_Type; use Sem_Type;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n@@ -474,6 +475,123 @@ package body Sem_Util is\n              V = 64;\n    end Addressable;\n \n+   ---------------------------------\n+   -- Aggregate_Constraint_Checks --\n+   ---------------------------------\n+\n+   procedure Aggregate_Constraint_Checks\n+     (Exp       : Node_Id;\n+      Check_Typ : Entity_Id)\n+   is\n+      Exp_Typ : constant Entity_Id  := Etype (Exp);\n+\n+   begin\n+      if Raises_Constraint_Error (Exp) then\n+         return;\n+      end if;\n+\n+      --  Ada 2005 (AI-230): Generate a conversion to an anonymous access\n+      --  component's type to force the appropriate accessibility checks.\n+\n+      --  Ada 2005 (AI-231): Generate conversion to the null-excluding\n+      --  type to force the corresponding run-time check\n+\n+      if Is_Access_Type (Check_Typ)\n+        and then ((Is_Local_Anonymous_Access (Check_Typ))\n+                    or else (Can_Never_Be_Null (Check_Typ)\n+                              and then not Can_Never_Be_Null (Exp_Typ)))\n+      then\n+         Rewrite (Exp, Convert_To (Check_Typ, Relocate_Node (Exp)));\n+         Analyze_And_Resolve (Exp, Check_Typ);\n+         Check_Unset_Reference (Exp);\n+      end if;\n+\n+      --  This is really expansion activity, so make sure that expansion is\n+      --  on and is allowed. In GNATprove mode, we also want check flags to\n+      --  be added in the tree, so that the formal verification can rely on\n+      --  those to be present. In GNATprove mode for formal verification, some\n+      --  treatment typically only done during expansion needs to be performed\n+      --  on the tree, but it should not be applied inside generics. Otherwise,\n+      --  this breaks the name resolution mechanism for generic instances.\n+\n+      if not Expander_Active\n+        and (Inside_A_Generic or not Full_Analysis or not GNATprove_Mode)\n+      then\n+         return;\n+      end if;\n+\n+      --  First check if we have to insert discriminant checks\n+\n+      if Has_Discriminants (Exp_Typ) then\n+         Apply_Discriminant_Check (Exp, Check_Typ);\n+\n+      --  Next emit length checks for array aggregates\n+\n+      elsif Is_Array_Type (Exp_Typ) then\n+         Apply_Length_Check (Exp, Check_Typ);\n+\n+      --  Finally emit scalar and string checks. If we are dealing with a\n+      --  scalar literal we need to check by hand because the Etype of\n+      --  literals is not necessarily correct.\n+\n+      elsif Is_Scalar_Type (Exp_Typ)\n+        and then Compile_Time_Known_Value (Exp)\n+      then\n+         if Is_Out_Of_Range (Exp, Base_Type (Check_Typ)) then\n+            Apply_Compile_Time_Constraint_Error\n+              (Exp, \"value not in range of}??\", CE_Range_Check_Failed,\n+               Ent => Base_Type (Check_Typ),\n+               Typ => Base_Type (Check_Typ));\n+\n+         elsif Is_Out_Of_Range (Exp, Check_Typ) then\n+            Apply_Compile_Time_Constraint_Error\n+              (Exp, \"value not in range of}??\", CE_Range_Check_Failed,\n+               Ent => Check_Typ,\n+               Typ => Check_Typ);\n+\n+         elsif not Range_Checks_Suppressed (Check_Typ) then\n+            Apply_Scalar_Range_Check (Exp, Check_Typ);\n+         end if;\n+\n+      --  Verify that target type is also scalar, to prevent view anomalies\n+      --  in instantiations.\n+\n+      elsif (Is_Scalar_Type (Exp_Typ)\n+              or else Nkind (Exp) = N_String_Literal)\n+        and then Is_Scalar_Type (Check_Typ)\n+        and then Exp_Typ /= Check_Typ\n+      then\n+         if Is_Entity_Name (Exp)\n+           and then Ekind (Entity (Exp)) = E_Constant\n+         then\n+            --  If expression is a constant, it is worthwhile checking whether\n+            --  it is a bound of the type.\n+\n+            if (Is_Entity_Name (Type_Low_Bound (Check_Typ))\n+                 and then Entity (Exp) = Entity (Type_Low_Bound (Check_Typ)))\n+              or else\n+               (Is_Entity_Name (Type_High_Bound (Check_Typ))\n+                 and then Entity (Exp) = Entity (Type_High_Bound (Check_Typ)))\n+            then\n+               return;\n+\n+            else\n+               Rewrite (Exp, Convert_To (Check_Typ, Relocate_Node (Exp)));\n+               Analyze_And_Resolve (Exp, Check_Typ);\n+               Check_Unset_Reference (Exp);\n+            end if;\n+\n+         --  Could use a comment on this case ???\n+\n+         else\n+            Rewrite (Exp, Convert_To (Check_Typ, Relocate_Node (Exp)));\n+            Analyze_And_Resolve (Exp, Check_Typ);\n+            Check_Unset_Reference (Exp);\n+         end if;\n+\n+      end if;\n+   end Aggregate_Constraint_Checks;\n+\n    -----------------------\n    -- Alignment_In_Bits --\n    -----------------------"}, {"sha": "0dbd73a221ade6062eca5b2c0c14096fd5325185", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=3f433bc07ebc9821a4edeea9ecfa3ea94b0b00d1", "patch": "@@ -91,6 +91,17 @@ package Sem_Util is\n    --  Returns True if the value of V is the word size of an addressable\n    --  factor of the word size (typically 8, 16, 32 or 64).\n \n+   procedure Aggregate_Constraint_Checks\n+     (Exp       : Node_Id;\n+      Check_Typ : Entity_Id);\n+   --  Checks expression Exp against subtype Check_Typ. If Exp is an aggregate\n+   --  and Check_Typ a constrained record type with discriminants, we generate\n+   --  the appropriate discriminant checks. If Exp is an array aggregate then\n+   --  emit the appropriate length checks. If Exp is a scalar type, or a string\n+   --  literal, Exp is changed into Check_Typ'(Exp) to ensure that range checks\n+   --  are performed at run time. Also used for expressions in the argument of\n+   --  'Update, which shares some of the features of an aggregate.\n+\n    function Alignment_In_Bits (E : Entity_Id) return Uint;\n    --  If the alignment of the type or object E is currently known to the\n    --  compiler, then this function returns the alignment value in bits."}]}