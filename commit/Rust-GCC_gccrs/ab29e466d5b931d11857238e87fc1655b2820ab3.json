{"sha": "ab29e466d5b931d11857238e87fc1655b2820ab3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIyOWU0NjZkNWI5MzFkMTE4NTcyMzhlODdmYzE2NTViMjgyMGFiMw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-01-20T08:57:27Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-01-20T08:57:27Z"}, "message": "More bytecode stuff going away.\n\nFrom-SVN: r17433", "tree": {"sha": "661036970e3ab1f1cb940df973c47e3f1b3831c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/661036970e3ab1f1cb940df973c47e3f1b3831c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab29e466d5b931d11857238e87fc1655b2820ab3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab29e466d5b931d11857238e87fc1655b2820ab3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab29e466d5b931d11857238e87fc1655b2820ab3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab29e466d5b931d11857238e87fc1655b2820ab3/comments", "author": null, "committer": null, "parents": [{"sha": "b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66"}], "stats": {"total": 439, "additions": 0, "deletions": 439}, "files": [{"sha": "5b24df70ed672c5f287ed89efd61331e893e0dc9", "filename": "gcc/bytecode.def", "status": "removed", "additions": 0, "deletions": 322, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Fbytecode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Fbytecode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbytecode.def?ref=b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "patch": "@@ -1,322 +0,0 @@\n-# -*- C -*-\n-# bytecode.def - definitions of bytecodes for the stack machine.\n-\n-# The production of the bytecode interpreter and compiler is\n-# heavily automated by using this file creatively.\n-\n-# Various elementary data types are understood by the bytecode interpreter.\n-# Q[IU] - quarter word (byte) signed and unsigned integers (char).\n-# H[IU] - half word signed and unsigned integers (short int, maybe int).\n-# S[IU] - single word signed and unsigned integers (maybe int, long int).\n-# D[IU] - double word signed and unsigned integers (long long int).\n-# SF - single precision floating point (float).\n-# DF - double precision floating point (double).\n-# XF - extended precision floating point (long double).\n-# P - pointer type for address arithmetic and other purposes.\n-\n-# The bytecode specification consists of a series of define_operator\n-# forms, that are parsed by preprocessors to automatically build\n-# various switch statements.\n-#\tdefine_operator(name,\n-#\t\t\t<C prototype code for implementing the operator>,\n-#\t\t\t<list of variations>)\n-# The <C prototype> is self explanatory.\n-# The <list of variations> consists of a (parenthesized list) of\n-# variation items, each of which is in itself a list.  A variation\n-# item consists of a name suffix, the types of the input arguments\n-# expected on the stack (shallowest item first) and (optionally) the\n-# types of the output arguments (similarly ordered).  Finally, the\n-# types of the literal arguments (if any) may appear.\n-\n-# Substitution in the C prototype code is as follows:\n-# Substitution happens only after a dollar sign.  To get a literal\n-# dollar sign (why would you ever want one anyway?) use $$.\n-# $R1 means \"result 1\" $TR1 means \"type name of result one\"\n-# $S1 means \"source 1\" and similarly with $TS1.\n-# $L1 means \"literal (inline) argument 1\" and $TL1 means type thereof.\n-#\n-\n-# Notice that the number following $R doesn't affect the push order;\n-# it's used only for clarity and orthogonality, although it's checked\n-# to make sure it doesn't exceed the number of outputs. A $R reference\n-# results in a push, and represents the result lvalue. E.g.\n-\n-#\t$R1 = 2\\, $R2 = 17\n-# will expand to:\n-#\tINTERP_PUSH($TR1) = 2, INTERP_PUSH($TR2) = 17\n-#\n-\n-# Opcode 0 should never happen.\n-define_operator(neverneverland, abort\\(\\), (()))\n-\n-# Stack manipulations.\n-define_operator(drop, 0, ((, (SI))))\n-define_operator(duplicate, 0, ((, (SI), (SI, SI))))\n-define_operator(over, 0, ((, (SI), (SI, SI))))\n-\n-# Adjust stack pointer\n-\n-define_operator(setstack, 0, ((SI,,,(SI))))\n-define_operator(adjstack, 0, ((SI,,,(SI))))\n-\n-# Constants, loads, and stores.\n-define_operator(const,\n-\t\t$R1 = $L1,\n-\t\t((QI,, (QI), (QI)), (HI,, (HI), (HI)),\n-\t\t (SI,, (SI), (SI)), (DI,, (DI), (DI)),\n-\t\t (SF,, (SF), (SF)), (DF,, (DF), (DF)),\n-\t\t (XF,, (XF), (XF)), (P,, (P), (P))))\n-define_operator(load,\n-\t\t$R1 = *\\($TR1 *\\) $S1,\n-\t\t((QI, (P), (QI)), (HI, (P), (HI)),\n-\t\t (SI, (P), (SI)), (DI, (P), (DI)),\n-\t\t (SF, (P), (SF)), (DF, (P), (DF)),\n-\t\t (XF, (P), (XF)), (P, (P), (P))))\n-define_operator(store,\n-\t\t*\\($TS2 *\\) $S1 = $S2,\n-\t\t((QI, (P, QI)), (HI, (P, HI)),\n-\t\t (SI, (P, SI)), (DI, (P, DI)),\n-\t\t (SF, (P, SF)), (DF, (P, DF)),\n-\t\t (XF, (P, XF)), (P, (P, P)),\n-\t\t (BLK, (SI, BLK, BLK))))\n-\n-# Clear memory block\n-\n-define_operator(clear, $S1 + $S2, ((BLK, (SI, BLK))))\n-\n-\n-# Advance pointer by SI constant\n-\n-define_operator(addconst, $R1 = $S1, ((PSI, (P), (P), (SI))))\n-\n-\n-# newlocalSI is used for creating variable-sized storage during function\n-# initialization.\n-\n-# Create local space, return pointer to block\n-\n-define_operator(newlocal, $R1 = $S1, ((SI, (SI), (P))))\n-\n-\n-# Push the address of a local variable.\n-define_operator(local, $R1 = locals + $L1, ((P,, (P), (SI))))\n-\n-# Push the address of an argument variable.\n-define_operator(arg, $R1 = args + $L1, ((P,, (P), (SI))))\n-\n-# Arithmetic conversions.\n-define_operator(convert,\n-\t\t$R1 = \\($TR1\\) $S1,\n-\t\t(# Signed integral promotions (sign extensions).\n-\t\t (QIHI, (QI), (HI)), (HISI, (HI), (SI)), (SIDI, (SI), (DI)),\n-\t\t (QISI, (QI), (SI)),\n-\t\t # Unsigned integral promotions (zero extensions).\n-\t\t (QUHU, (QU), (HU)), (HUSU, (HU), (SU)), (SUDU, (SU), (DU)),\n-\t\t (QUSU, (QU), (SU)),\n-\t\t # Floating promotions.\n-\t\t (SFDF, (SF), (DF)), (DFXF, (DF), (XF)),\n-\t\t # Integral truncation.\n-\t\t (HIQI, (HI), (QI)), (SIHI, (SI), (HI)), (DISI, (DI), (SI)),\n-\t\t (SIQI, (SI), (QI)),\n-                 # Unsigned truncation.\n-\t\t (SUQU, (SU), (QU)),\n-\t\t # Floating truncation.\n-\t\t (DFSF, (DF), (SF)), (XFDF, (XF), (DF)),\n-\t\t # Integral conversions to floating types.\n-\t\t (SISF, (SI), (SF)), (SIDF, (SI), (DF)), (SIXF, (SI), (XF)),\n-\t\t (SUSF, (SU), (SF)), (SUDF, (SU), (DF)), (SUXF, (SU), (XF)),\n-\t\t (DISF, (DI), (SF)), (DIDF, (DI), (DF)), (DIXF, (DI), (XF)),\n-\t\t (DUSF, (DU), (SF)), (DUDF, (DU), (DF)), (DUXF, (DU), (XF)),\n-\t\t # Floating conversions to integral types.\n-\t\t (SFSI, (SF), (SI)), (DFSI, (DF), (SI)), (XFSI, (XF), (SI)),\n-\t\t (SFSU, (SF), (SU)), (DFSU, (DF), (SU)), (XFSU, (XF), (SU)),\n-\t\t (SFDI, (SF), (DI)), (DFDI, (DF), (DI)), (XFDI, (XF), (DI)),\n-\t\t (SFDU, (SF), (DU)), (DFDU, (DF), (DU)), (XFDU, (XF), (DU)),\n-\t\t # Pointer/integer conversions.\n-\t\t (PSI, (P), (SI)), (SIP, (SI), (P))))\n-\n-# Truth value conversion.  These are necessary because conversions of, e.g.,\n-# floating types to integers may not function correctly for large values.\n-define_operator(convert,\n-\t\t$R1 = !!$S1,\n-\t\t((SIT, (SI), (T)), (DIT, (DI), (T)),\n-\t\t (SFT, (SF), (T)), (DFT, (DF), (T)),\n-\t\t (XFT, (XF), (T)), (PT, (P), (T))))\n-\n-# Bit field load/store.\n-\n-# Load and zero-extend bitfield\n-\n-define_operator(zxload, $R1 = $S1, ((BI, (SU, SU, P), (SU))))\n-\n-# Load and sign-extend bitfield\n-\n-define_operator(sxload, $R1 = $S1, ((BI, (SU, SU, P), (SI))))\n-\n-# Store integer in bitfield\n-\n-define_operator(sstore, $R1 = $S1, ((BI, (SU, SU, P, SI))))\n-\n-\n-# Binary operations.\n-define_operator(add,\n-\t\t$R1 = $S1 + $S2,\n-\t\t((SI, (SI, SI), (SI)), (DI, (DI, DI), (DI)),\n-\t\t (SF, (SF, SF), (SF)), (DF, (DF, DF), (DF)),\n-\t\t (XF, (XF, XF), (XF)),\n-\t\t (PSI, (P, SI), (P))))\n-define_operator(sub,\n-\t\t$R1 = $S1 - $S2,\n-\t\t((SI, (SI, SI), (SI)), (DI, (DI, DI), (DI)),\n-\t\t (SF, (SF, SF), (SF)), (DF, (DF, DF), (DF)),\n-\t\t (XF, (XF, XF), (XF)),\n-\t\t (PP, (P, P), (SI))))\n-define_operator(mul,\n-\t\t$R1 = $S1 * $S2,\n-\t\t((SI, (SI, SI), (SI)), (DI, (DI, DI), (DI)),\n-\t\t (SU, (SU, SU), (SU)), (DU, (DU, DU), (DU)),\n-\t\t (SF, (SF, SF), (SF)), (DF, (DF, DF), (DF)),\n-\t\t (XF, (XF, XF), (XF))))\n-define_operator(div,\n-\t\t$R1 = $S1 / $S2,\n-\t\t((SI, (SI, SI), (SI)), (DI, (DI, DI), (DI)),\n-\t\t (SU, (SU, SU), (SU)), (DU, (DU, DU), (DU)),\n-\t\t (SF, (SF, SF), (SF)), (DF, (DF, DF), (DF)),\n-\t\t (XF, (XF, XF), (XF))))\n-define_operator(mod,\n-\t\t$R1 = $S1 % $S2,\n-\t\t((SI, (SI, SI), (SI)), (DI, (DI, DI), (DI)),\n-\t\t (SU, (SU, SU), (SU)), (DU, (DU, DU), (DU))))\n-define_operator(and,\n-\t\t$R1 = $S1 & $S2,\n-\t\t((SI, (SI, SI), (SI)), (DI, (DI, DI), (DI))))\n-define_operator(ior,\n-\t\t$R1 = $S1 | $S2,\n-\t\t((SI, (SI, SI), (SI)), (DI, (DI, DI), (DI))))\n-define_operator(xor,\n-\t\t$R1 = $S1 ^ $S2,\n-\t\t((SI, (SI, SI), (SI)), (DI, (DI, DI), (DI))))\n-define_operator(lshift,\n-\t\t$R1 = $S1 << $S2,\n-\t\t((SI, (SI, SI), (SI)), (SU, (SU, SI), (SU)),\n-\t\t (DI, (DI, SI), (DI)), (DU, (DU, SI), (DU))))\n-define_operator(rshift,\n-\t\t$R1 = $S1 >> $S2,\n-\t\t((SI, (SI, SI), (SI)), (SU, (SU, SI), (SU)),\n-\t\t (DI, (DI, SI), (DI)), (DU, (DU, SI), (DU))))\n-define_operator(lt,\n-\t\t$R1 = $S1 < $S2,\n-\t\t((SI, (SI, SI), (T)), (SU, (SU, SU), (T)),\n-\t\t (DI, (DI, DI), (T)), (DU, (DU, DU), (T)),\n-\t\t (SF, (SF, SF), (T)), (DF, (DF, DF), (T)),\n-\t\t (XF, (XF, XF), (T)), (P, (P, P), (T))))\n-define_operator(le,\n-\t\t$R1 = $S1 <= $S2,\n-\t\t((SI, (SI, SI), (T)), (SU, (SU, SU), (T)),\n-\t\t (DI, (DI, DI), (T)), (DU, (DU, DU), (T)),\n-\t\t (SF, (SF, SF), (T)), (DF, (DF, DF), (T)),\n-\t\t (XF, (XF, XF), (T)), (P, (P, P), (T))))\n-define_operator(ge,\n-\t\t$R1 = $S1 >= $S2,\n-\t\t((SI, (SI, SI), (T)), (SU, (SU, SU), (T)),\n-\t\t (DI, (DI, DI), (T)), (DU, (DU, DU), (T)),\n-\t\t (SF, (SF, SF), (T)), (DF, (DF, DF), (T)),\n-\t\t (XF, (XF, XF), (T)), (P, (P, P), (T))))\n-define_operator(gt,\n-\t\t$R1 = $S1 > $S2,\n-\t\t((SI, (SI, SI), (T)), (SU, (SU, SU), (T)),\n-\t\t (DI, (DI, DI), (T)), (DU, (DU, DU), (T)),\n-\t\t (SF, (SF, SF), (T)), (DF, (DF, DF), (T)),\n-\t\t (XF, (XF, XF), (T)), (P, (P, P), (T))))\n-define_operator(eq,\n-\t\t$R1 = $S1 == $S2,\n-\t\t((SI, (SI, SI), (T)), (DI, (DI, DI), (T)),\n-\t\t (SF, (SF, SF), (T)), (DF, (DF, DF), (T)),\n-\t\t (XF, (XF, XF), (T)), (P, (P, P), (T))))\n-define_operator(ne,\n-\t\t$R1 = $S1 != $S2,\n-\t\t((SI, (SI, SI), (T)), (DI, (DI, DI), (T)),\n-\t\t (SF, (SF, SF), (T)), (DF, (DF, DF), (T)),\n-\t\t (XF, (XF, XF), (T)), (P, (P, P), (T))))\n-\n-# Unary operations.\n-define_operator(neg,\n-\t\t$R1 = -$S1,\n-\t\t((SI, (SI), (SI)), (DI, (DI), (DI)),\n-\t\t (SF, (SF), (SF)), (DF, (DF), (DF)),\n-\t\t (XF, (XF), (XF))))\n-define_operator(not,\n-\t\t$R1 = ~$S1,\n-\t\t((SI, (SI), (SI)), (DI, (DI), (DI))))\n-define_operator(not,\n-\t\t$R1 = !$S1,\n-\t\t((T, (SI), (SI))))\n-\n-# Increment operations.\n-define_operator(predec,\n-\t\t$R1 = *\\($TR1 *\\) $S1 -= $S2,\n-\t\t((QI, (P, QI), (QI)), (HI, (P, HI), (HI)),\n-\t\t (SI, (P, SI), (SI)), (DI, (P, DI), (DI)),\n-\t\t (P, (P, SI), (P)), (SF, (P, SF), (SF)),\n-\t\t (DF, (P, DF), (DF)), (XF, (P, XF), (XF)),\n-\t\t (BI, (SU, SU, P, SI), (SI))))\n-\n-define_operator(preinc,\n-\t\t$R1 = *\\($TR1 *\\) $S1 += $S2,\n-\t\t((QI, (P, QI), (QI)), (HI, (P, HI), (HI)),\n-\t\t (SI, (P, SI), (SI)), (DI, (P, DI), (DI)),\n-\t\t (P, (P, SI), (P)), (SF, (P, SF), (SF)),\n-\t\t (DF, (P, DF), (DF)), (XF, (P, XF), (XF)),\n-\t\t (BI, (SU, SU, P, SI), (SI))))\n-\n-define_operator(postdec,\n-\t\t$R1 = *\\($TR1 *\\) $S1\\, *\\($TR1 *\\) $S1 -= $S2,\n-\t\t((QI, (P, QI), (QI)), (HI, (P, HI), (HI)),\n-\t\t (SI, (P, SI), (SI)), (DI, (P, DI), (DI)),\n-\t\t (P, (P, SI), (P)), (SF, (P, SF), (SF)),\n-\t\t (DF, (P, DF), (DF)), (XF, (P, XF), (XF)),\n-\t\t (BI, (SU, SU, P, SI), (SI))))\n-\n-define_operator(postinc,\n-\t\t$R1 = *\\($TR1 *\\) $S1\\, *\\($TR1 *\\) $S1 += $S2,\n-\t\t((QI, (P, QI), (QI)), (HI, (P, HI), (HI)),\n-\t\t (SI, (P, SI), (SI)), (DI, (P, DI), (DI)),\n-\t\t (P, (P, SI), (P)), (SF, (P, SF), (SF)),\n-\t\t (DF, (P, DF), (DF)), (XF, (P, XF), (XF)),\n-\t\t (BI, (SU, SU, P, SI), (SI))))\n-\n-# Jumps.\n-define_operator(xjumpif, if \\($S1\\) pc = code->pc0 + $L1, ((, (T),, (SI))))\n-define_operator(xjumpifnot, if \\(! $S1\\) pc = code->pc0 + $L1, ((, (T),, (SI))))\n-define_operator(jump, pc = code->pc0 + $L1, ((,,,(SI))))\n-\n-# This is for GCC2. It jumps to the address on the stack.\n-define_operator(jump, pc = \\(void *\\) $S1, ((P,,)))\n-\n-# Switches.  In order to (eventually) support ranges we provide four different\n-# varieties of switches.  Arguments are the switch index from the stack, the\n-# bytecode offset of the switch table, the size of the switch table, and \n-# the default label.\n-define_operator(caseSI, CASESI\\($S1\\, $L1\\, $L2\\, $L3\\), ((, (SI),, (SI, SI, SI))))\n-define_operator(caseSU, CASESU\\($S1\\, $L1\\, $L2\\, $L3\\), ((, (SU),, (SI, SI, SI))))\n-define_operator(caseDI, CASEDI\\($S1\\, $L1\\, $L2\\, $L3\\), ((, (DI),, (SI, SI, SI))))\n-define_operator(caseDU, CASEDU\\($S1\\, $L1\\, $L2\\, $L3\\), ((, (DU),, (SI, SI, SI))))\n-\n-# Procedure call.\n-# Stack arguments are (deepest first):\n-#\tprocedure arguments in reverse order.\n-#\tpointer to the place to hold the return value.\n-#\taddress of the call description vector.\n-#\tpointer to the procedure to be called.\n-define_operator(call, CALL\\($S1\\, $S2\\, $S3\\, sp\\), ((, (P, P, P))))\n-\n-# Procedure return.\n-# Pushes on interpreter stack:\n-#       value of retptr (pointer to return value storage slot)\n-define_operator(return, $R1 = retptr, ((P,,(P))))\n-\n-# Really return.\n-define_operator(ret, return, (()))\n-\n-# Print an obnoxious line number.\n-define_operator(linenote, fprintf\\(stderr\\, \"%d\\\\n\"\\, $L1\\), ((,,,(SI))))"}, {"sha": "a029f93f60284a946a4f6ccec13d1861b6e5d5a0", "filename": "gcc/bytecode.h", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Fbytecode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Fbytecode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbytecode.h?ref=b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "patch": "@@ -1,82 +0,0 @@\n-/* Bytecode definitions for GNU C-compiler.\n-   Copyright (C) 1993, 1994, 1996 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-extern int output_bytecode;\n-extern int stack_depth;\n-extern int max_stack_depth;\n-\n-/* Emit DI constant according to target machine word ordering */\n-\n-#define bc_emit_bytecode_DI_const(CST) \t\t\t\t\\\n-{ int opcode;\t\t\t\t\t\t\t\\\n-  opcode = (WORDS_BIG_ENDIAN\t\t\t\t\t\\\n-\t    ? TREE_INT_CST_HIGH (CST) \t\t\t\t\\\n-\t    : TREE_INT_CST_LOW (CST));\t\t\t\t\\\n-  bc_emit_bytecode_const ((char *) &opcode, sizeof opcode); \t\\\n-  opcode = (WORDS_BIG_ENDIAN\t\t\t\t\t\\\n-\t    ? TREE_INT_CST_LOW (CST) \t\t\t\t\\\n-\t    : TREE_INT_CST_HIGH (CST));\t\t\t\t\\\n-  bc_emit_bytecode_const ((char *) &opcode, sizeof opcode);\t\\\n-}\n-\n-extern void bc_expand_expr ();\n-extern void bc_output_data_constructor ();\n-extern void bc_store_field ();\n-extern void bc_load_bit_field ();\n-extern void bc_store_bit_field ();\n-extern void bc_push_offset_and_size ();\n-extern void bc_init_mode_to_code_map ();\n-\n-/* These are just stubs, so the compiler will compile for targets\n-   that aren't yet supported by the bytecode generator. */\n-\n-#ifndef TARGET_SUPPORTS_BYTECODE\n-\n-#define MACHINE_SEG_ALIGN 1\n-#define INT_ALIGN 1\n-#define PTR_ALIGN 1\n-#define NAMES_HAVE_UNDERSCORES\n-#define BC_NOP   (0)\n-#define BC_GLOBALIZE_LABEL(FP, NAME) BC_NOP\n-#define BC_OUTPUT_COMMON(FP, NAME, SIZE, ROUNDED) BC_NOP\n-#define BC_OUTPUT_BSS(FP, NAME, SIZE, ROUNDED)    BC_NOP\n-#define BC_OUTPUT_LOCAL(FP, NAME, SIZE, ROUNDED)  BC_NOP\n-#define BC_OUTPUT_ALIGN(FP, ALIGN)   BC_NOP\n-#define BC_OUTPUT_LABEL(FP, NAME)    BC_NOP\n-#define BC_OUTPUT_SKIP(FP, SIZE)     BC_NOP\n-#define BC_OUTPUT_LABELREF(FP, NAME) BC_NOP\n-#define BC_OUTPUT_FLOAT(FP, VAL)     BC_NOP\n-#define BC_OUTPUT_DOUBLE(FP, VAL)    BC_NOP\n-#define BC_OUTPUT_BYTE(FP, VAL)      BC_NOP\n-#define BC_OUTPUT_FILE ASM_OUTPUT_FILE\n-#define BC_OUTPUT_ASCII ASM_OUTPUT_ASCII\n-#define BC_OUTPUT_IDENT ASM_OUTPUT_IDENT\n-#define BCXSTR(RTX)  ((RTX)->bc_label)\n-#define BC_WRITE_FILE(FP)            BC_NOP\n-#define BC_WRITE_SEGSYM(SEGSYM, FP)  BC_NOP\n-#define BC_WRITE_RELOC_ENTRY(SEGRELOC, FP, OFFSET) BC_NOP\n-#define BC_START_BYTECODE_LINE(FP)   BC_NOP\n-#define BC_WRITE_BYTECODE(SEP, VAL, FP) BC_NOP\n-#define BC_WRITE_RTL(R, FP)          BC_NOP\n-#define BC_EMIT_TRAMPOLINE(TRAMPSEG, CALLINFO) BC_NOP\n-#define VALIDATE_STACK               BC_NOP\n-\n-#endif /* !TARGET_SUPPORTS_BYTECODE */"}, {"sha": "f91566900c66335cc399afec004e86c8b1d78013", "filename": "gcc/bytetypes.h", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Fbytetypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Fbytetypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbytetypes.h?ref=b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "patch": "@@ -1,35 +0,0 @@\n-/* These should come from genemit */\n-\n-/* Use __signed__ in case compiling with -traditional.  */\n-\n-typedef __signed__ char QItype;\n-typedef unsigned char QUtype;\n-typedef __signed__ short int HItype;\n-typedef unsigned short int HUtype;\n-typedef __signed__ long int SItype;\n-typedef unsigned long int SUtype;\n-typedef __signed__ long long int DItype;\n-typedef unsigned long long int DUtype;\n-typedef float SFtype;\n-typedef double DFtype;\n-typedef long double XFtype;\n-typedef char *Ptype;\n-typedef int Ttype;\n-\n-\n-typedef union stacktype\n-{\n-  QItype QIval;\n-  QUtype QUval;\n-  HItype HIval;\n-  HUtype HUval;\n-  SItype SIval;\n-  SUtype SUval;\n-  DItype DIval;\n-  DUtype DUval;\n-  SFtype SFval;\n-  DFtype DFval;\n-  XFtype XFval;\n-  Ptype Pval;\n-  Ttype Tval;\n-} stacktype;"}]}