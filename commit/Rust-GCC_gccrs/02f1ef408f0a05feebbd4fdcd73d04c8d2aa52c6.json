{"sha": "02f1ef408f0a05feebbd4fdcd73d04c8d2aa52c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJmMWVmNDA4ZjBhMDVmZWViYmQ0ZmRjZDczZDA0YzhkMmFhNTJjNg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-01-24T01:10:10Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-01-24T01:10:10Z"}, "message": "PR middle-end/78703 - -fprintf-return-value floating point handling incorrect...\n\nPR middle-end/78703 - -fprintf-return-value floating point handling incorrect in locales with a mulltibyte decimal point\n\t* gimple-ssa-sprintf.c (warn_level): New global.\n\t(format_integer): Use it here and throughout the rest of the file.\n\tUse the same switch to compute sign as base.\n\t(maybe_warn): New function.\n\t(format_directive): Factor out warnings into maybe_warn.\n\tAdd debugging output.  Use warn_level.\n\t(add_bytes): Use warn_level.\n\t(pass_sprintf_length::compute_format_length): Add debugging output.\n\t(try_substitute_return_value): Same.\n\t(pass_sprintf_length::handle_gimple_call): Set and use warn_level.\n\nFrom-SVN: r244847", "tree": {"sha": "eb81e3ea32b3ff7a8b62c08962a6784417771f39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb81e3ea32b3ff7a8b62c08962a6784417771f39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02f1ef408f0a05feebbd4fdcd73d04c8d2aa52c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02f1ef408f0a05feebbd4fdcd73d04c8d2aa52c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02f1ef408f0a05feebbd4fdcd73d04c8d2aa52c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02f1ef408f0a05feebbd4fdcd73d04c8d2aa52c6/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a151e93b2bf042c44d37044e887ebfaf038c2a73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a151e93b2bf042c44d37044e887ebfaf038c2a73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a151e93b2bf042c44d37044e887ebfaf038c2a73"}], "stats": {"total": 413, "additions": 246, "deletions": 167}, "files": [{"sha": "1b0f2087d054753d9d628a7d1b025fcb3ac34e64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f1ef408f0a05feebbd4fdcd73d04c8d2aa52c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f1ef408f0a05feebbd4fdcd73d04c8d2aa52c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02f1ef408f0a05feebbd4fdcd73d04c8d2aa52c6", "patch": "@@ -1,5 +1,17 @@\n 2017-01-23  Martin Sebor  <msebor@redhat.com>\n \n+\tPR middle-end/78703\n+\t* gimple-ssa-sprintf.c (warn_level): New global.\n+\t(format_integer): Use it here and throughout the rest of the file.\n+\tUse the same switch to compute sign as base.\n+\t(maybe_warn): New function.\n+\t(format_directive): Factor out warnings into maybe_warn.\n+\tAdd debugging output.  Use warn_level.\n+\t(add_bytes): Use warn_level.\n+\t(pass_sprintf_length::compute_format_length): Add debugging output.\n+\t(try_substitute_return_value): Same.\n+\t(pass_sprintf_length::handle_gimple_call): Set and use warn_level.\n+\n \tPR middle-end/78703\n \t* gimple-ssa-sprintf.c (struct format_result): Remove constant member.\n \t(struct fmtresult, format_integer, format_floating): Adjust."}, {"sha": "66edc3ec1cc935881e4e2bd8107de85aeb902c03", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 234, "deletions": 167, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f1ef408f0a05feebbd4fdcd73d04c8d2aa52c6/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f1ef408f0a05feebbd4fdcd73d04c8d2aa52c6/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=02f1ef408f0a05feebbd4fdcd73d04c8d2aa52c6", "patch": "@@ -104,6 +104,12 @@ const pass_data pass_data_sprintf_length = {\n   0,\t                   // properties_finish\n };\n \n+/* Set to the warning level for the current function which is equal\n+   either to warn_format_trunc for bounded functions or to\n+   warn_format_overflow otherwise.  */\n+\n+static int warn_level;\n+\n struct format_result;\n \n class pass_sprintf_length : public gimple_opt_pass\n@@ -137,10 +143,10 @@ class pass_sprintf_length : public gimple_opt_pass\n bool\n pass_sprintf_length::gate (function *)\n {\n-  /* Run the pass iff -Warn-format-length is specified and either\n-     not optimizing and the pass is being invoked early, or when\n-     optimizing and the pass is being invoked during optimization\n-     (i.e., \"late\").  */\n+  /* Run the pass iff -Warn-format-overflow or -Warn-format-truncation\n+     is specified and either not optimizing and the pass is being invoked\n+     early, or when optimizing and the pass is being invoked during\n+     optimization (i.e., \"late\").  */\n   return ((warn_format_overflow > 0\n \t   || warn_format_trunc > 0\n \t   || flag_printf_return_value)\n@@ -937,7 +943,37 @@ format_integer (const directive &dir, tree arg)\n   HOST_WIDE_INT width = dir.width;\n   HOST_WIDE_INT prec = dir.prec;\n \n-  bool sign = dir.specifier == 'd' || dir.specifier == 'i';\n+  /* Base to format the number in.  */\n+  int base;\n+\n+  /* True when a signed conversion is preceded by a sign or space.  */\n+  bool maybesign = false;\n+\n+  /* True for signed conversions (i.e., 'd' and 'i').  */\n+  bool sign = false;\n+\n+  switch (dir.specifier)\n+    {\n+    case 'd':\n+    case 'i':\n+      /* Space and '+' are  only meaningful for signed conversions.  */\n+      maybesign = dir.get_flag (' ') | dir.get_flag ('+');\n+      sign = true;\n+      base = 10;\n+      break;\n+    case 'u':\n+      base = 10;\n+      break;\n+    case 'o':\n+      base = 8;\n+      break;\n+    case 'X':\n+    case 'x':\n+      base = 16;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   /* The type of the \"formal\" argument expected by the directive.  */\n   tree dirtype = NULL_TREE;\n@@ -1008,34 +1044,6 @@ format_integer (const directive &dir, tree arg)\n       /* When a constant argument has been provided use its value\n \t rather than type to determine the length of the output.  */\n \n-      /* Base to format the number in.  */\n-      int base;\n-\n-      /* True when a signed conversion is preceded by a sign or space.  */\n-      bool maybesign = false;\n-\n-      switch (dir.specifier)\n-\t{\n-\tcase 'd':\n-\tcase 'i':\n-\t  /* Space and '+' are  only meaningful for signed conversions.  */\n-\t  maybesign = dir.get_flag (' ') | dir.get_flag ('+');\n-\t  base = 10;\n-\t  break;\n-\tcase 'u':\n-\t  base = 10;\n-\t  break;\n-\tcase 'o':\n-\t  base = 8;\n-\t  break;\n-\tcase 'X':\n-\tcase 'x':\n-\t  base = 16;\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n       HOST_WIDE_INT len;\n \n       if ((prec == HOST_WIDE_INT_MIN || prec == 0) && integer_zerop (arg))\n@@ -1665,11 +1673,11 @@ format_character (const directive &dir, tree arg)\n      to a \"%lc\" directive adjusted for precision but not field width.\n      6 is the longest UTF-8 sequence for a single wide character.  */\n   const unsigned HOST_WIDE_INT max_bytes_for_unknown_wc\n-    = (0 <= dir.prec ? dir.prec : warn_format_overflow > 1 ? 6 : 1);\n+    = (0 <= dir.prec ? dir.prec : warn_level > 1 ? 6 : 1);\n \n     if (dir.modifier == FMT_LEN_l)\n     {\n-      /* Positive if the argument is a wide NUL character?  */\n+      /* Positive if the argument is a wide NUL character.  */\n       int nul = (arg && TREE_CODE (arg) == INTEGER_CST\n \t\t ? integer_zerop (arg) : -1);\n \n@@ -1679,7 +1687,7 @@ format_character (const directive &dir, tree arg)\n \t is the smaller of either 0 (at level 1) or 1 (at level 2)\n \t and WIDTH, and the maximum is MB_CUR_MAX in the selected\n \t locale, which is unfortunately, unknown.  */\n-      res.range.min = warn_format_overflow == 1 ? !nul : nul < 1;\n+      res.range.min = warn_level == 1 ? !nul : nul < 1;\n       res.range.max = max_bytes_for_unknown_wc;\n       /* The range above is good enough to issue warnings but not\n \t for value range propagation, so clear BOUNDED.  */\n@@ -1756,7 +1764,7 @@ format_string (const directive &dir, tree arg)\n \t{\n \t  bounded = false;\n \n-\t  if (warn_format_overflow > 1)\n+\t  if (warn_level > 1)\n \t    {\n \t      /* Leave the minimum number of bytes the wide string\n \t\t converts to equal to its length and set the maximum\n@@ -1870,6 +1878,145 @@ format_string (const directive &dir, tree arg)\n   return res;\n }\n \n+/* At format string location describe by DIRLOC in a call described\n+   by INFO, issue a warning for a directive DIR whose output may be\n+   in excess of the available space AVAIL_RANGE in the destination\n+   given the formatting result FMTRES.  This function does nothing\n+   except decide whether to issue a warning for a possible write\n+   past the end or truncation and, if so, format the warning.\n+   Return true if a warning has been issued.  */\n+\n+static bool\n+maybe_warn (substring_loc &dirloc, source_range *pargrange,\n+\t    const pass_sprintf_length::call_info &info,\n+\t    unsigned HOST_WIDE_INT navail, const result_range &res,\n+\t    const directive &dir)\n+{\n+  bool warned = false;\n+\n+  if (res.min < res.max)\n+    {\n+      /* The result is a range (i.e., it's inexact).  */\n+      if (!warned)\n+\t{\n+\t  if (navail < res.min)\n+\t    {\n+\t      /* The minimum directive output is longer than there is\n+\t\t room in the destination.  */\n+\t      if (res.min == res.max)\n+\t\t{\n+\t\t  const char* fmtstr\n+\t\t    = (info.bounded\n+\t\t       ? G_(\"%<%.*s%> directive output truncated writing \"\n+\t\t\t    \"%wu bytes into a region of size %wu\")\n+\t\t       : G_(\"%<%.*s%> directive writing %wu bytes \"\n+\t\t\t    \"into a region of size %wu\"));\n+\t\t  warned = fmtwarn (dirloc, pargrange, NULL, info.warnopt (),\n+\t\t\t\t    fmtstr,\n+\t\t\t\t    (int)dir.len, dir.beg, res.min,\n+\t\t\t\t    navail);\n+\t\t}\n+\t      else if (res.max < HOST_WIDE_INT_MAX)\n+\t\t{\n+\t\t  const char* fmtstr\n+\t\t    = (info.bounded\n+\t\t       ? G_(\"%<%.*s%> directive output truncated writing \"\n+\t\t\t    \"between %wu and %wu bytes into a region of \"\n+\t\t\t    \"size %wu\")\n+\t\t       : G_(\"%<%.*s%> directive writing between %wu and \"\n+\t\t\t    \"%wu bytes into a region of size %wu\"));\n+\t\t  warned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t\t    info.warnopt (), fmtstr,\n+\t\t\t\t    (int)dir.len, dir.beg,\n+\t\t\t\t    res.min, res.max, navail);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  const char* fmtstr\n+\t\t    = (info.bounded\n+\t\t       ? G_(\"%<%.*s%> directive output truncated writing \"\n+\t\t\t    \"%wu or more bytes into a region of size %wu\")\n+\t\t       : G_(\"%<%.*s%> directive writing %wu or more bytes \"\n+\t\t\t    \"into a region of size %wu\"));\n+\t\t  warned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t\t    info.warnopt (), fmtstr,\n+\t\t\t\t    (int)dir.len, dir.beg,\n+\t\t\t\t    res.min, navail);\n+\t\t}\n+\t    }\n+\t  else if (navail < res.max\n+\t\t   && (dir.specifier != 's'\n+\t\t       || res.max < HOST_WIDE_INT_MAX)\n+\t\t   && ((info.bounded\n+\t\t\t&& (!info.retval_used ()\n+\t\t\t    || warn_level > 1))\n+\t\t       || (!info.bounded\n+\t\t\t   && (dir.specifier == 's'\n+\t\t\t       || warn_level > 1))))\n+\t    {\n+\t      /* The maximum directive output is longer than there is\n+\t\t room in the destination and the output length is either\n+\t\t explicitly constrained by the precision (for strings)\n+\t\t or the warning level is greater than 1.  */\n+\t      if (res.max >= HOST_WIDE_INT_MAX)\n+\t\t{\n+\t\t  const char* fmtstr\n+\t\t    = (info.bounded\n+\t\t       ? G_(\"%<%.*s%> directive output may be truncated \"\n+\t\t\t    \"writing %wu or more bytes into a region \"\n+\t\t\t    \"of size %wu\")\n+\t\t       : G_(\"%<%.*s%> directive writing %wu or more bytes \"\n+\t\t\t    \"into a region of size %wu\"));\n+\t\t  warned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t\t    info.warnopt (), fmtstr,\n+\t\t\t\t    (int)dir.len, dir.beg,\n+\t\t\t\t    res.min, navail);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  const char* fmtstr\n+\t\t    = (info.bounded\n+\t\t       ? G_(\"%<%.*s%> directive output may be truncated \"\n+\t\t\t    \"writing between %wu and %wu bytes into a region \"\n+\t\t\t    \"of size %wu\")\n+\t\t       : G_(\"%<%.*s%> directive writing between %wu and %wu \"\n+\t\t\t    \"bytes into a region of size %wu\"));\n+\t\t  warned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t\t    info.warnopt (), fmtstr,\n+\t\t\t\t    (int)dir.len, dir.beg,\n+\t\t\t\t    res.min, res.max,\n+\t\t\t\t    navail);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      if (!warned && res.min > 0 && navail < res.min)\n+\t{\n+\t  const char* fmtstr\n+\t    = (info.bounded\n+\t       ? (1 < res.min\n+\t\t  ? G_(\"%<%.*s%> directive output truncated while writing \"\n+\t\t       \"%wu bytes into a region of size %wu\")\n+\t\t  : G_(\"%<%.*s%> directive output truncated while writing \"\n+\t\t       \"%wu byte into a region of size %wu\"))\n+\t       : (1 < res.min\n+\t\t  ? G_(\"%<%.*s%> directive writing %wu bytes \"\n+\t\t       \"into a region of size %wu\")\n+\t\t  : G_(\"%<%.*s%> directive writing %wu byte \"\n+\t\t       \"into a region of size %wu\")));\n+\n+\t  warned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t    info.warnopt (), fmtstr,\n+\t\t\t    (int)dir.len, dir.beg, res.min,\n+\t\t\t    navail);\n+\t}\n+    }\n+\n+  return warned;\n+}\n+\n /* Compute the length of the output resulting from the conversion\n    specification DIR with the argument ARG in a call described by INFO\n    and update the overall result of the call in *RES.  The format directive\n@@ -1970,109 +2117,19 @@ format_directive (const pass_sprintf_length::call_info &info,\n       return false;\n     }\n \n-  bool warned = res->warned;\n-\n   /* Compute the number of available bytes in the destination.  There\n      must always be at least one byte of space for the terminating\n      NUL that's appended after the format string has been processed.  */\n   unsigned HOST_WIDE_INT navail = min_bytes_remaining (info.objsize, *res);\n \n+  bool warned = res->warned;\n+\n+  if (!warned)\n+    warned = maybe_warn (dirloc, pargrange, info, navail,\n+\t\t\t fmtres.range, dir);\n+\n   if (fmtres.range.min < fmtres.range.max)\n     {\n-      /* The result is a range (i.e., it's inexact).  */\n-      if (!warned)\n-\t{\n-\t  if (navail < fmtres.range.min)\n-\t    {\n-\t      /* The minimum directive output is longer than there is\n-\t\t room in the destination.  */\n-\t      if (fmtres.range.min == fmtres.range.max)\n-\t\t{\n-\t\t  const char* fmtstr\n-\t\t    = (info.bounded\n-\t\t       ? G_(\"%<%.*s%> directive output truncated writing \"\n-\t\t\t    \"%wu bytes into a region of size %wu\")\n-\t\t       : G_(\"%<%.*s%> directive writing %wu bytes \"\n-\t\t\t    \"into a region of size %wu\"));\n-\t\t  warned = fmtwarn (dirloc, pargrange, NULL, info.warnopt (),\n-\t\t\t\t    fmtstr,\n-\t\t\t\t    (int)cvtlen, cvtbeg, fmtres.range.min,\n-\t\t\t\t    navail);\n-\t\t}\n-\t      else if (fmtres.range.max < HOST_WIDE_INT_MAX)\n-\t\t{\n-\t\t  const char* fmtstr\n-\t\t    = (info.bounded\n-\t\t       ? G_(\"%<%.*s%> directive output truncated writing \"\n-\t\t\t    \"between %wu and %wu bytes into a region of \"\n-\t\t\t    \"size %wu\")\n-\t\t       : G_(\"%<%.*s%> directive writing between %wu and \"\n-\t\t\t    \"%wu bytes into a region of size %wu\"));\n-\t\t  warned = fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t\t    info.warnopt (), fmtstr,\n-\t\t\t\t    (int)cvtlen, cvtbeg,\n-\t\t\t\t    fmtres.range.min, fmtres.range.max, navail);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  const char* fmtstr\n-\t\t    = (info.bounded\n-\t\t       ? G_(\"%<%.*s%> directive output truncated writing \"\n-\t\t\t    \"%wu or more bytes into a region of size %wu\")\n-\t\t       : G_(\"%<%.*s%> directive writing %wu or more bytes \"\n-\t\t\t    \"into a region of size %wu\"));\n-\t\t  warned = fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t\t    info.warnopt (), fmtstr,\n-\t\t\t\t    (int)cvtlen, cvtbeg,\n-\t\t\t\t    fmtres.range.min, navail);\n-\t\t}\n-\t    }\n-\t  else if (navail < fmtres.range.max\n-\t\t   && (dir.specifier != 's'\n-\t\t       || fmtres.range.max < HOST_WIDE_INT_MAX)\n-\t\t   && ((info.bounded\n-\t\t\t&& (!info.retval_used ()\n-\t\t\t    || warn_format_trunc > 1))\n-\t\t       || (!info.bounded\n-\t\t\t   && (dir.specifier == 's'\n-\t\t\t       || warn_format_overflow > 1))))\n-\t    {\n-\t      /* The maximum directive output is longer than there is\n-\t\t room in the destination and the output length is either\n-\t\t explicitly constrained by the precision (for strings)\n- \t\t or the warning level is greater than 1.  */\n-\t      if (fmtres.range.max >= HOST_WIDE_INT_MAX)\n-\t\t{\n-\t\t  const char* fmtstr\n-\t\t    = (info.bounded\n-\t\t       ? G_(\"%<%.*s%> directive output may be truncated \"\n-\t\t\t    \"writing %wu or more bytes into a region \"\n-\t\t\t    \"of size %wu\")\n-\t\t       : G_(\"%<%.*s%> directive writing %wu or more bytes \"\n-\t\t\t    \"into a region of size %wu\"));\n-\t\t  warned = fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t\t    info.warnopt (), fmtstr,\n-\t\t\t\t    (int)cvtlen, cvtbeg,\n-\t\t\t\t    fmtres.range.min, navail);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  const char* fmtstr\n-\t\t    = (info.bounded\n-\t\t       ? G_(\"%<%.*s%> directive output may be truncated \"\n-\t\t\t    \"writing between %wu and %wu bytes into a region \"\n-\t\t\t    \"of size %wu\")\n-\t\t       : G_(\"%<%.*s%> directive writing between %wu and %wu \"\n-\t\t\t    \"bytes into a region of size %wu\"));\n-\t\t  warned = fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t\t    info.warnopt (), fmtstr,\n-\t\t\t\t    (int)cvtlen, cvtbeg,\n-\t\t\t\t    fmtres.range.min, fmtres.range.max,\n-\t\t\t\t    navail);\n-\t\t}\n-\t    }\n-\t}\n-\n       /* Disable exact length checking but adjust the minimum and maximum.  */\n       res->number_chars = HOST_WIDE_INT_M1U;\n       if (res->number_chars_max < HOST_WIDE_INT_MAX\n@@ -2082,37 +2139,15 @@ format_directive (const pass_sprintf_length::call_info &info,\n       res->number_chars_min += fmtres.range.min;\n     }\n   else\n-    {\n-      if (!warned && fmtres.range.min > 0 && navail < fmtres.range.min)\n-\t{\n-\t  const char* fmtstr\n-\t    = (info.bounded\n-\t       ? (1 < fmtres.range.min\n-\t\t  ? G_(\"%<%.*s%> directive output truncated while writing \"\n-\t\t       \"%wu bytes into a region of size %wu\")\n-\t\t  : G_(\"%<%.*s%> directive output truncated while writing \"\n-\t\t       \"%wu byte into a region of size %wu\"))\n-\t       : (1 < fmtres.range.min\n-\t\t  ? G_(\"%<%.*s%> directive writing %wu bytes \"\n-\t\t       \"into a region of size %wu\")\n-\t\t  : G_(\"%<%.*s%> directive writing %wu byte \"\n-\t\t       \"into a region of size %wu\")));\n-\n-\t  warned = fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t    info.warnopt (), fmtstr,\n-\t\t\t    (int)cvtlen, cvtbeg, fmtres.range.min,\n-\t\t\t    navail);\n-\t}\n       *res += fmtres.range.min;\n-    }\n \n   /* Has the minimum directive output length exceeded the maximum\n      of 4095 bytes required to be supported?  */\n   bool minunder4k = fmtres.range.min < 4096;\n   if (!minunder4k || fmtres.range.max > 4095)\n     res->under4k = false;\n \n-  if (!warned && warn_format_overflow > 1\n+  if (!warned && warn_level > 1\n       && (!minunder4k || fmtres.range.max > 4095))\n     {\n       /* The directive output may be longer than the maximum required\n@@ -2149,7 +2184,7 @@ format_directive (const pass_sprintf_length::call_info &info,\n \n   if (!warned\n       && (exceedmin\n-\t  || (warn_format_overflow > 1\n+\t  || (warn_level > 1\n \t      && res->number_chars_max > target_int_max ())))\n     {\n       /* The directive output causes the total length of output\n@@ -2189,6 +2224,18 @@ format_directive (const pass_sprintf_length::call_info &info,\n     }\n \n   res->warned |= warned;\n+\n+  if (dump_file && *dir.beg)\n+    {\n+      fprintf (dump_file, \"    Result: %lli, %lli \"\n+\t       \"(%lli, %lli, %lli)\\n\",\n+\t       (long long)fmtres.range.min,\n+\t       (long long)fmtres.range.max,\n+\t       (long long)res->number_chars,\n+\t       (long long)res->number_chars_min,\n+\t       (long long)res->number_chars_max);\n+    }\n+\n   return true;\n }\n \n@@ -2228,15 +2275,15 @@ add_bytes (const pass_sprintf_length::call_info &info,\n      are bounded by the arrays they are known to refer to.  */\n   if (!res->warned\n       && (avail_range.max < nbytes\n-\t  || ((res->knownrange || warn_format_overflow > 1)\n+\t  || ((res->knownrange || warn_level > 1)\n \t      && avail_range.min < nbytes)))\n     {\n       /* Set NAVAIL to the number of available bytes used to decide\n \t whether or not to issue a warning below.  The exact kind of\n \t warning will depend on AVAIL_RANGE.  */\n       unsigned HOST_WIDE_INT navail = avail_range.max;\n       if (nbytes <= navail && avail_range.min < HOST_WIDE_INT_MAX\n-\t  && (res->knownrange || warn_format_overflow > 1))\n+\t  && (res->knownrange || warn_level > 1))\n \tnavail = avail_range.min;\n \n       /* Compute the offset of the first format character that is beyond\n@@ -2281,7 +2328,7 @@ add_bytes (const pass_sprintf_length::call_info &info,\n \t  if (!info.bounded\n \t      || !boundrange\n \t      || !info.retval_used ()\n-\t      || warn_format_trunc > 1)\n+\t      || warn_level > 1)\n \t    res->warned = fmtwarn (loc, NULL, NULL, info.warnopt (), text);\n \t}\n       else\n@@ -2303,7 +2350,7 @@ add_bytes (const pass_sprintf_length::call_info &info,\n \t  if (!info.bounded\n \t      || !boundrange\n \t      || !info.retval_used ()\n-\t      || warn_format_trunc > 1)\n+\t      || warn_level > 1)\n \t    res->warned = fmtwarn (loc, NULL, NULL, info.warnopt (),\n \t\t\t\t   text, info.fmtstr[off], off);\n \t}\n@@ -2345,7 +2392,7 @@ add_bytes (const pass_sprintf_length::call_info &info,\n \n   if (!res->warned\n       && (exceedmin\n-\t  || (warn_format_overflow > 1\n+\t  || (warn_level > 1\n \t      && (res->number_chars_max - !end) > target_int_max ())))\n     {\n       /* The function's output exceeds INT_MAX bytes.  */\n@@ -2355,7 +2402,7 @@ add_bytes (const pass_sprintf_length::call_info &info,\n \t warning will depend on AVAIL_RANGE.  */\n       unsigned HOST_WIDE_INT navail = avail_range.max;\n       if (nbytes <= navail && avail_range.min < HOST_WIDE_INT_MAX\n-\t  && (res->bounded || warn_format_overflow > 1))\n+\t  && (res->bounded || warn_level > 1))\n \tnavail = avail_range.min;\n \n       /* Compute the offset of the first format character that is beyond\n@@ -2763,6 +2810,17 @@ bool\n pass_sprintf_length::compute_format_length (call_info &info,\n \t\t\t\t\t    format_result *res)\n {\n+  if (dump_file)\n+    {\n+      location_t callloc = gimple_location (info.callstmt);\n+      fprintf (dump_file, \"%s:%i: \",\n+\t       LOCATION_FILE (callloc), LOCATION_LINE (callloc));\n+      print_generic_expr (dump_file, info.func, dump_flags);\n+\n+      fprintf (dump_file, \": objsize = %llu, fmtstr = \\\"%s\\\"\\n\",\n+\t       (unsigned long long)info.objsize, info.fmtstr);\n+    }\n+\n   /* Reset exact, minimum, and maximum character counters.  */\n   res->number_chars = res->number_chars_min = res->number_chars_max = 0;\n \n@@ -2822,14 +2880,15 @@ pass_sprintf_length::compute_format_length (call_info &info,\n static unsigned HOST_WIDE_INT\n get_destination_size (tree dest)\n {\n+  /* Initialize object size info before trying to compute it.  */\n+  init_object_sizes ();\n+\n   /* Use __builtin_object_size to determine the size of the destination\n      object.  When optimizing, determine the smallest object (such as\n      a member array as opposed to the whole enclosing object), otherwise\n      use type-zero object size to determine the size of the enclosing\n      object (the function fails without optimization in this type).  */\n \n-  init_object_sizes ();\n-\n   int ost = optimize > 0;\n   unsigned HOST_WIDE_INT size;\n   if (compute_builtin_object_size (dest, ost, &size))\n@@ -2977,7 +3036,10 @@ try_substitute_return_value (gimple_stmt_iterator *gsi,\n \t}\n     }\n \n-  return false;\n+  if (dump_file)\n+    fputc ('\\n', dump_file);\n+\n+  return removed;\n }\n \n /* Determine if a GIMPLE CALL is to one of the sprintf-like built-in\n@@ -3085,6 +3147,9 @@ pass_sprintf_length::handle_gimple_call (gimple_stmt_iterator *gsi)\n       return false;\n     }\n \n+  /* Set the global warning level for this function.  */\n+  warn_level = info.bounded ? warn_format_trunc : warn_format_overflow;\n+\n   /* The first argument is a pointer to the destination.  */\n   tree dstptr = gimple_call_arg (info.callstmt, 0);\n \n@@ -3138,7 +3203,7 @@ pass_sprintf_length::handle_gimple_call (gimple_stmt_iterator *gsi)\n \t  if (range_type == VR_RANGE)\n \t    {\n \t      dstsize\n-\t\t= (warn_format_overflow < 2\n+\t\t= (warn_level < 2\n \t\t   ? wi::fits_uhwi_p (max) ? max.to_uhwi () : max.to_shwi ()\n \t\t   : wi::fits_uhwi_p (min) ? min.to_uhwi () : min.to_shwi ());\n \t    }\n@@ -3224,6 +3289,7 @@ pass_sprintf_length::handle_gimple_call (gimple_stmt_iterator *gsi)\n       && flag_printf_return_value\n       && (!flag_rounding_math || !res.floating))\n     return try_substitute_return_value (gsi, info, res);\n+\n   return false;\n }\n \n@@ -3249,6 +3315,7 @@ pass_sprintf_length::execute (function *fun)\n \t}\n     }\n \n+  /* Clean up object size info.  */\n   fini_object_sizes ();\n \n   return 0;"}]}