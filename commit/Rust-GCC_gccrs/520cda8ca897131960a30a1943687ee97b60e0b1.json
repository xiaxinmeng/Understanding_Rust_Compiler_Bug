{"sha": "520cda8ca897131960a30a1943687ee97b60e0b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTIwY2RhOGNhODk3MTMxOTYwYTMwYTE5NDM2ODdlZTk3YjYwZTBiMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-07-22T20:06:09Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-07-22T20:06:09Z"}, "message": "dwarf2.h (DW_AT_GNU_macros): New.\n\n\t* dwarf2.h (DW_AT_GNU_macros): New.\n\t(enum dwarf_macro_record_type): New enum.  Add DW_MACRO_GNU_*.\n\n\t* dwarf2out.c (struct macinfo_struct): Change code to unsigned char.\n\t(DEBUG_MACRO_SECTION, DEBUG_MACRO_SECTION_LABEL): Define.\n\t(dwarf_attr_name): Handle DW_AT_GNU_macros.\n\t(dwarf2out_define): If the vector is empty and\n\tlineno is 0, emit a dummy entry first.\n\t(dwarf2out_undef): Likewise.  Remove redundant semicolon.\n\t(htab_macinfo_hash, htab_macinfo_eq, output_macinfo_op,\n\toptimize_macinfo_range): New functions.\n\t(output_macinfo): Use them.  If !dwarf_strict and .debug_str is\n\tmergeable, optimize longer strings using\n\tDW_MACRO_GNU_{define,undef}_indirect and if HAVE_COMDAT_GROUP,\n\toptimize longer sequences of define/undef ops from headers\n\tusing DW_MACRO_GNU_transparent_include.  For !dwarf_strict\n\temit a section headers.\n\t(dwarf2out_init): For !dwarf_strict set debug_macinfo_section\n\tand macinfo_section_label to DEBUG_MACRO_SECTION\n\tresp. DEBUG_MACRO_SECTION_LABEL.\n\t(dwarf2out_finish): For !dwarf_strict emit DW_AT_GNU_macros\n\tinstead of DW_AT_macro_info.\n\nFrom-SVN: r176653", "tree": {"sha": "b0723af67f5e999cd947b5a925fe1443da94821d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0723af67f5e999cd947b5a925fe1443da94821d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/520cda8ca897131960a30a1943687ee97b60e0b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/520cda8ca897131960a30a1943687ee97b60e0b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/520cda8ca897131960a30a1943687ee97b60e0b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/520cda8ca897131960a30a1943687ee97b60e0b1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e967adf4e25eb7497495886aa4c3b9460219cd2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e967adf4e25eb7497495886aa4c3b9460219cd2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e967adf4e25eb7497495886aa4c3b9460219cd2d"}], "stats": {"total": 452, "additions": 421, "deletions": 31}, "files": [{"sha": "ea9b48bfe4f829178bfc5b8efc3e53cb2b7fa7f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520cda8ca897131960a30a1943687ee97b60e0b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520cda8ca897131960a30a1943687ee97b60e0b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=520cda8ca897131960a30a1943687ee97b60e0b1", "patch": "@@ -1,5 +1,25 @@\n 2011-07-22  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* dwarf2out.c (struct macinfo_struct): Change code to unsigned char.\n+\t(DEBUG_MACRO_SECTION, DEBUG_MACRO_SECTION_LABEL): Define.\n+\t(dwarf_attr_name): Handle DW_AT_GNU_macros.\n+\t(dwarf2out_define): If the vector is empty and\n+\tlineno is 0, emit a dummy entry first.\n+\t(dwarf2out_undef): Likewise.  Remove redundant semicolon.\n+\t(htab_macinfo_hash, htab_macinfo_eq, output_macinfo_op,\n+\toptimize_macinfo_range): New functions.\n+\t(output_macinfo): Use them.  If !dwarf_strict and .debug_str is\n+\tmergeable, optimize longer strings using\n+\tDW_MACRO_GNU_{define,undef}_indirect and if HAVE_COMDAT_GROUP,\n+\toptimize longer sequences of define/undef ops from headers\n+\tusing DW_MACRO_GNU_transparent_include.  For !dwarf_strict\n+\temit a section headers.\n+\t(dwarf2out_init): For !dwarf_strict set debug_macinfo_section\n+\tand macinfo_section_label to DEBUG_MACRO_SECTION\n+\tresp. DEBUG_MACRO_SECTION_LABEL.\n+\t(dwarf2out_finish): For !dwarf_strict emit DW_AT_GNU_macros\n+\tinstead of DW_AT_macro_info.\n+\n \tPR other/32998\n \t* common.opt (grecord-gcc-switches, gno-record-gcc-switches): New\n \toptions."}, {"sha": "639a383d84898e63a015064f0e947a40de2be86a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 382, "deletions": 31, "changes": 413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520cda8ca897131960a30a1943687ee97b60e0b1/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520cda8ca897131960a30a1943687ee97b60e0b1/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=520cda8ca897131960a30a1943687ee97b60e0b1", "patch": "@@ -2771,7 +2771,7 @@ struct GTY(()) dw_ranges_struct {\n /* A structure to hold a macinfo entry.  */\n \n typedef struct GTY(()) macinfo_struct {\n-  unsigned HOST_WIDE_INT code;\n+  unsigned char code;\n   unsigned HOST_WIDE_INT lineno;\n   const char *info;\n }\n@@ -3418,6 +3418,9 @@ static void gen_scheduled_generic_parms_dies (void);\n #ifndef DEBUG_MACINFO_SECTION\n #define DEBUG_MACINFO_SECTION\t\".debug_macinfo\"\n #endif\n+#ifndef DEBUG_MACRO_SECTION\n+#define DEBUG_MACRO_SECTION\t\".debug_macro\"\n+#endif\n #ifndef DEBUG_LINE_SECTION\n #define DEBUG_LINE_SECTION\t\".debug_line\"\n #endif\n@@ -3475,6 +3478,9 @@ static void gen_scheduled_generic_parms_dies (void);\n #ifndef DEBUG_MACINFO_SECTION_LABEL\n #define DEBUG_MACINFO_SECTION_LABEL     \"Ldebug_macinfo\"\n #endif\n+#ifndef DEBUG_MACRO_SECTION_LABEL\n+#define DEBUG_MACRO_SECTION_LABEL\t\"Ldebug_macro\"\n+#endif\n \n \n /* Definitions of defaults for formats and names of various special\n@@ -4016,6 +4022,8 @@ dwarf_attr_name (unsigned int attr)\n       return \"DW_AT_GNU_all_call_sites\";\n     case DW_AT_GNU_all_source_call_sites:\n       return \"DW_AT_GNU_all_source_call_sites\";\n+    case DW_AT_GNU_macros:\n+      return \"DW_AT_GNU_macros\";\n \n     case DW_AT_GNAT_descriptive_type:\n       return \"DW_AT_GNAT_descriptive_type\";\n@@ -20391,6 +20399,15 @@ dwarf2out_define (unsigned int lineno ATTRIBUTE_UNUSED,\n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n     {\n       macinfo_entry e;\n+      /* Insert a dummy first entry to be able to optimize the whole\n+\t predefined macro block using DW_MACRO_GNU_transparent_include.  */\n+      if (VEC_empty (macinfo_entry, macinfo_table) && lineno == 0)\n+\t{\n+\t  e.code = 0;\n+\t  e.lineno = 0;\n+\t  e.info = NULL;\n+\t  VEC_safe_push (macinfo_entry, gc, macinfo_table, &e);\n+\t}\n       e.code = DW_MACINFO_define;\n       e.lineno = lineno;\n       e.info = xstrdup (buffer);;\n@@ -20409,58 +20426,386 @@ dwarf2out_undef (unsigned int lineno ATTRIBUTE_UNUSED,\n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n     {\n       macinfo_entry e;\n+      /* Insert a dummy first entry to be able to optimize the whole\n+\t predefined macro block using DW_MACRO_GNU_transparent_include.  */\n+      if (VEC_empty (macinfo_entry, macinfo_table) && lineno == 0)\n+\t{\n+\t  e.code = 0;\n+\t  e.lineno = 0;\n+\t  e.info = NULL;\n+\t  VEC_safe_push (macinfo_entry, gc, macinfo_table, &e);\n+\t}\n       e.code = DW_MACINFO_undef;\n       e.lineno = lineno;\n-      e.info = xstrdup (buffer);;\n+      e.info = xstrdup (buffer);\n       VEC_safe_push (macinfo_entry, gc, macinfo_table, &e);\n     }\n }\n \n+/* Routines to manipulate hash table of CUs.  */\n+\n+static hashval_t\n+htab_macinfo_hash (const void *of)\n+{\n+  const macinfo_entry *const entry =\n+    (const macinfo_entry *) of;\n+\n+  return htab_hash_string (entry->info);\n+}\n+\n+static int\n+htab_macinfo_eq (const void *of1, const void *of2)\n+{\n+  const macinfo_entry *const entry1 = (const macinfo_entry *) of1;\n+  const macinfo_entry *const entry2 = (const macinfo_entry *) of2;\n+\n+  return !strcmp (entry1->info, entry2->info);\n+}\n+\n+/* Output a single .debug_macinfo entry.  */\n+\n+static void\n+output_macinfo_op (macinfo_entry *ref)\n+{\n+  int file_num;\n+  size_t len;\n+  struct indirect_string_node *node;\n+  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+  switch (ref->code)\n+    {\n+    case DW_MACINFO_start_file:\n+      file_num = maybe_emit_file (lookup_filename (ref->info));\n+      dw2_asm_output_data (1, DW_MACINFO_start_file, \"Start new file\");\n+      dw2_asm_output_data_uleb128 (ref->lineno,\n+\t\t\t\t   \"Included from line number %lu\", \n+\t\t\t\t   (unsigned long) ref->lineno);\n+      dw2_asm_output_data_uleb128 (file_num, \"file %s\", ref->info);\n+      break;\n+    case DW_MACINFO_end_file:\n+      dw2_asm_output_data (1, DW_MACINFO_end_file, \"End file\");\n+      break;\n+    case DW_MACINFO_define:\n+    case DW_MACINFO_undef:\n+      len = strlen (ref->info) + 1;\n+      if (!dwarf_strict\n+\t  && len > DWARF_OFFSET_SIZE\n+\t  && !DWARF2_INDIRECT_STRING_SUPPORT_MISSING_ON_TARGET\n+\t  && (debug_str_section->common.flags & SECTION_MERGE) != 0)\n+\t{\n+\t  ref->code = ref->code == DW_MACINFO_define\n+\t\t      ? DW_MACRO_GNU_define_indirect\n+\t\t      : DW_MACRO_GNU_undef_indirect;\n+\t  output_macinfo_op (ref);\n+\t  return;\n+\t}\n+      dw2_asm_output_data (1, ref->code,\n+\t\t\t   ref->code == DW_MACINFO_define\n+\t\t\t   ? \"Define macro\" : \"Undefine macro\");\n+      dw2_asm_output_data_uleb128 (ref->lineno, \"At line number %lu\", \n+\t\t\t\t   (unsigned long) ref->lineno);\n+      dw2_asm_output_nstring (ref->info, -1, \"The macro\");\n+      break;\n+    case DW_MACRO_GNU_define_indirect:\n+    case DW_MACRO_GNU_undef_indirect:\n+      node = find_AT_string (ref->info);\n+      if (node->form != DW_FORM_strp)\n+\t{\n+\t  char label[32];\n+\t  ASM_GENERATE_INTERNAL_LABEL (label, \"LASF\", dw2_string_counter);\n+\t  ++dw2_string_counter;\n+\t  node->label = xstrdup (label);\n+\t  node->form = DW_FORM_strp;\n+\t}\n+      dw2_asm_output_data (1, ref->code,\n+\t\t\t   ref->code == DW_MACRO_GNU_define_indirect\n+\t\t\t   ? \"Define macro indirect\"\n+\t\t\t   : \"Undefine macro indirect\");\n+      dw2_asm_output_data_uleb128 (ref->lineno, \"At line number %lu\",\n+\t\t\t\t   (unsigned long) ref->lineno);\n+      dw2_asm_output_offset (DWARF_OFFSET_SIZE, node->label,\n+\t\t\t     debug_str_section, \"The macro: \\\"%s\\\"\",\n+\t\t\t     ref->info);\n+      break;\n+    case DW_MACRO_GNU_transparent_include:\n+      dw2_asm_output_data (1, ref->code, \"Transparent include\");\n+      ASM_GENERATE_INTERNAL_LABEL (label,\n+\t\t\t\t   DEBUG_MACRO_SECTION_LABEL, ref->lineno);\n+      dw2_asm_output_offset (DWARF_OFFSET_SIZE, label, NULL, NULL);\n+      break;\n+    default:\n+      fprintf (asm_out_file, \"%s unrecognized macinfo code %lu\\n\",\n+\t       ASM_COMMENT_START, (unsigned long) ref->code);\n+      break;\n+    }\n+}\n+\n+/* Attempt to make a sequence of define/undef macinfo ops shareable with\n+   other compilation unit .debug_macinfo sections.  IDX is the first\n+   index of a define/undef, return the number of ops that should be\n+   emitted in a comdat .debug_macinfo section and emit\n+   a DW_MACRO_GNU_transparent_include entry referencing it.\n+   If the define/undef entry should be emitted normally, return 0.  */\n+\n+static unsigned\n+optimize_macinfo_range (unsigned int idx, VEC (macinfo_entry, gc) *files,\n+\t\t\thtab_t *macinfo_htab)\n+{\n+  macinfo_entry *first, *second, *cur, *inc;\n+  char linebuf[sizeof (HOST_WIDE_INT) * 3 + 1];\n+  unsigned char checksum[16];\n+  struct md5_ctx ctx;\n+  char *grp_name, *tail;\n+  const char *base;\n+  unsigned int i, count, encoded_filename_len, linebuf_len;\n+  void **slot;\n+\n+  first = VEC_index (macinfo_entry, macinfo_table, idx);\n+  second = VEC_index (macinfo_entry, macinfo_table, idx + 1);\n+\n+  /* Optimize only if there are at least two consecutive define/undef ops,\n+     and either all of them are before first DW_MACINFO_start_file\n+     with lineno 0 (i.e. predefined macro block), or all of them are\n+     in some included header file.  */\n+  if (second->code != DW_MACINFO_define && second->code != DW_MACINFO_undef)\n+    return 0;\n+  if (VEC_empty (macinfo_entry, files))\n+    {\n+      if (first->lineno != 0 || second->lineno != 0)\n+\treturn 0;\n+    }\n+  else if (first->lineno == 0)\n+    return 0;\n+\n+  /* Find the last define/undef entry that can be grouped together\n+     with first and at the same time compute md5 checksum of their\n+     codes, linenumbers and strings.  */\n+  md5_init_ctx (&ctx);\n+  for (i = idx; VEC_iterate (macinfo_entry, macinfo_table, i, cur); i++)\n+    if (cur->code != DW_MACINFO_define && cur->code != DW_MACINFO_undef)\n+      break;\n+    else if (first->lineno == 0 && cur->lineno != 0)\n+      break;\n+    else\n+      {\n+\tunsigned char code = cur->code;\n+\tmd5_process_bytes (&code, 1, &ctx);\n+\tchecksum_uleb128 (cur->lineno, &ctx);\n+\tmd5_process_bytes (cur->info, strlen (cur->info) + 1, &ctx);\n+      }\n+  md5_finish_ctx (&ctx, checksum);\n+  count = i - idx;\n+\n+  /* From the containing include filename (if any) pick up just\n+     usable characters from its basename.  */\n+  if (first->lineno == 0)\n+    base = \"\";\n+  else\n+    base = lbasename (VEC_last (macinfo_entry, files)->info);\n+  for (encoded_filename_len = 0, i = 0; base[i]; i++)\n+    if (ISIDNUM (base[i]) || base[i] == '.')\n+      encoded_filename_len++;\n+  /* Count . at the end.  */\n+  if (encoded_filename_len)\n+    encoded_filename_len++;\n+\n+  sprintf (linebuf, HOST_WIDE_INT_PRINT_UNSIGNED, first->lineno);\n+  linebuf_len = strlen (linebuf);\n+\n+  /* The group name format is: wmN.[<encoded filename>.]<lineno>.<md5sum>  */\n+  grp_name = XNEWVEC (char, 4 + encoded_filename_len + linebuf_len + 1\n+\t\t      + 16 * 2 + 1);\n+  memcpy (grp_name, DWARF_OFFSET_SIZE == 4 ? \"wm4.\" : \"wm8.\", 4);\n+  tail = grp_name + 4;\n+  if (encoded_filename_len)\n+    {\n+      for (i = 0; base[i]; i++)\n+\tif (ISIDNUM (base[i]) || base[i] == '.')\n+\t  *tail++ = base[i];\n+      *tail++ = '.';\n+    }\n+  memcpy (tail, linebuf, linebuf_len);\n+  tail += linebuf_len;\n+  *tail++ = '.';\n+  for (i = 0; i < 16; i++)\n+    sprintf (tail + i * 2, \"%02x\", checksum[i] & 0xff);\n+\n+  /* Construct a macinfo_entry for DW_MACRO_GNU_transparent_include\n+     in the empty vector entry before the first define/undef.  */\n+  inc = VEC_index (macinfo_entry, macinfo_table, idx - 1);\n+  inc->code = DW_MACRO_GNU_transparent_include;\n+  inc->lineno = 0;\n+  inc->info = grp_name;\n+  if (*macinfo_htab == NULL)\n+    *macinfo_htab = htab_create (10, htab_macinfo_hash, htab_macinfo_eq, NULL);\n+  /* Avoid emitting duplicates.  */\n+  slot = htab_find_slot (*macinfo_htab, inc, INSERT);\n+  if (*slot != NULL)\n+    {\n+      free (CONST_CAST (char *, inc->info));\n+      inc->code = 0;\n+      inc->info = NULL;\n+      /* If such an entry has been used before, just emit\n+\t a DW_MACRO_GNU_transparent_include op.  */\n+      inc = (macinfo_entry *) *slot;\n+      output_macinfo_op (inc);\n+      /* And clear all macinfo_entry in the range to avoid emitting them\n+\t in the second pass.  */\n+      for (i = idx;\n+\t   VEC_iterate (macinfo_entry, macinfo_table, i, cur)\n+\t   && i < idx + count;\n+\t   i++)\n+\t{\n+\t  cur->code = 0;\n+\t  free (CONST_CAST (char *, cur->info));\n+\t  cur->info = NULL;\n+\t}\n+    }\n+  else\n+    {\n+      *slot = inc;\n+      inc->lineno = htab_elements (*macinfo_htab);\n+      output_macinfo_op (inc);\n+    }\n+  return count;\n+}\n+\n+/* Output macinfo section(s).  */\n+\n static void\n output_macinfo (void)\n {\n   unsigned i;\n   unsigned long length = VEC_length (macinfo_entry, macinfo_table);\n   macinfo_entry *ref;\n+  VEC (macinfo_entry, gc) *files = NULL;\n+  htab_t macinfo_htab = NULL;\n \n   if (! length)\n     return;\n \n+  /* output_macinfo* uses these interchangeably.  */\n+  gcc_assert ((int) DW_MACINFO_define == (int) DW_MACRO_GNU_define\n+\t      && (int) DW_MACINFO_undef == (int) DW_MACRO_GNU_undef\n+\t      && (int) DW_MACINFO_start_file == (int) DW_MACRO_GNU_start_file\n+\t      && (int) DW_MACINFO_end_file == (int) DW_MACRO_GNU_end_file);\n+\n+  /* For .debug_macro emit the section header.  */\n+  if (!dwarf_strict)\n+    {\n+      dw2_asm_output_data (2, 4, \"DWARF macro version number\");\n+      if (DWARF_OFFSET_SIZE == 8)\n+\tdw2_asm_output_data (1, 3, \"Flags: 64-bit, lineptr present\");\n+      else\n+\tdw2_asm_output_data (1, 2, \"Flags: 32-bit, lineptr present\");\n+      dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_line_section_label,\n+\t\t\t     debug_line_section, NULL);\n+    }\n+\n+  /* In the first loop, it emits the primary .debug_macinfo section\n+     and after each emitted op the macinfo_entry is cleared.\n+     If a longer range of define/undef ops can be optimized using\n+     DW_MACRO_GNU_transparent_include, the\n+     DW_MACRO_GNU_transparent_include op is emitted and kept in\n+     the vector before the first define/undef in the range and the\n+     whole range of define/undef ops is not emitted and kept.  */\n   for (i = 0; VEC_iterate (macinfo_entry, macinfo_table, i, ref); i++)\n     {\n       switch (ref->code)\n \t{\n-\t  case DW_MACINFO_start_file:\n+\tcase DW_MACINFO_start_file:\n+\t  VEC_safe_push (macinfo_entry, gc, files, ref);\n+\t  break;\n+\tcase DW_MACINFO_end_file:\n+\t  if (!VEC_empty (macinfo_entry, files))\n \t    {\n-\t      int file_num = maybe_emit_file (lookup_filename (ref->info));\n-\t      dw2_asm_output_data (1, DW_MACINFO_start_file, \"Start new file\");\n-\t      dw2_asm_output_data_uleb128 \n-\t\t\t(ref->lineno, \"Included from line number %lu\", \n-\t\t\t \t\t\t(unsigned long)ref->lineno);\n-\t      dw2_asm_output_data_uleb128 (file_num, \"file %s\", ref->info);\n+\t      macinfo_entry *file = VEC_last (macinfo_entry, files);\n+\t      free (CONST_CAST (char *, file->info));\n+\t      VEC_pop (macinfo_entry, files);\n+\t    }\n+\t  break;\n+\tcase DW_MACINFO_define:\n+\tcase DW_MACINFO_undef:\n+\t  if (!dwarf_strict\n+\t      && HAVE_COMDAT_GROUP\n+\t      && VEC_length (macinfo_entry, files) != 1\n+\t      && i > 0\n+\t      && i + 1 < length\n+\t      && VEC_index (macinfo_entry, macinfo_table, i - 1)->code == 0)\n+\t    {\n+\t      unsigned count = optimize_macinfo_range (i, files, &macinfo_htab);\n+\t      if (count)\n+\t\t{\n+\t\t  i += count - 1;\n+\t\t  continue;\n+\t\t}\n \t    }\n-\t    break;\n-\t  case DW_MACINFO_end_file:\n-\t    dw2_asm_output_data (1, DW_MACINFO_end_file, \"End file\");\n-\t    break;\n-\t  case DW_MACINFO_define:\n-\t    dw2_asm_output_data (1, DW_MACINFO_define, \"Define macro\");\n-\t    dw2_asm_output_data_uleb128 (ref->lineno, \"At line number %lu\", \n-\t\t\t \t\t\t(unsigned long)ref->lineno);\n-\t    dw2_asm_output_nstring (ref->info, -1, \"The macro\");\n-\t    break;\n-\t  case DW_MACINFO_undef:\n-\t    dw2_asm_output_data (1, DW_MACINFO_undef, \"Undefine macro\");\n-\t    dw2_asm_output_data_uleb128 (ref->lineno, \"At line number %lu\",\n-\t\t\t \t\t\t(unsigned long)ref->lineno);\n-\t    dw2_asm_output_nstring (ref->info, -1, \"The macro\");\n-\t    break;\n-\t  default:\n-\t   fprintf (asm_out_file, \"%s unrecognized macinfo code %lu\\n\",\n-\t     ASM_COMMENT_START, (unsigned long)ref->code);\n+\t  break;\n+\tcase 0:\n+\t  /* A dummy entry may be inserted at the beginning to be able\n+\t     to optimize the whole block of predefined macros.  */\n+\t  if (i == 0)\n+\t    continue;\n+\tdefault:\n \t  break;\n \t}\n+      output_macinfo_op (ref);\n+      /* For DW_MACINFO_start_file ref->info has been copied into files\n+\t vector.  */\n+      if (ref->code != DW_MACINFO_start_file)\n+\tfree (CONST_CAST (char *, ref->info));\n+      ref->info = NULL;\n+      ref->code = 0;\n     }\n+\n+  if (macinfo_htab == NULL)\n+    return;\n+\n+  htab_delete (macinfo_htab);\n+\n+  /* If any DW_MACRO_GNU_transparent_include were used, on those\n+     DW_MACRO_GNU_transparent_include entries terminate the\n+     current chain and switch to a new comdat .debug_macinfo\n+     section and emit the define/undef entries within it.  */\n+  for (i = 0; VEC_iterate (macinfo_entry, macinfo_table, i, ref); i++)\n+    switch (ref->code)\n+      {\n+      case 0:\n+\tcontinue;\n+      case DW_MACRO_GNU_transparent_include:\n+\t{\n+\t  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\t  tree comdat_key = get_identifier (ref->info);\n+\t  /* Terminate the previous .debug_macinfo section.  */\n+\t  dw2_asm_output_data (1, 0, \"End compilation unit\");\n+\t  targetm.asm_out.named_section (DEBUG_MACRO_SECTION,\n+\t\t\t\t\t SECTION_DEBUG\n+\t\t\t\t\t | SECTION_LINKONCE,\n+\t\t\t\t\t comdat_key);\n+\t  ASM_GENERATE_INTERNAL_LABEL (label,\n+\t\t\t\t       DEBUG_MACRO_SECTION_LABEL,\n+\t\t\t\t       ref->lineno);\n+\t  ASM_OUTPUT_LABEL (asm_out_file, label);\n+\t  ref->code = 0;\n+\t  free (CONST_CAST (char *, ref->info));\n+\t  ref->info = NULL;\n+\t  dw2_asm_output_data (2, 4, \"DWARF macro version number\");\n+\t  if (DWARF_OFFSET_SIZE == 8)\n+\t    dw2_asm_output_data (1, 1, \"Flags: 64-bit\");\n+\t  else\n+\t    dw2_asm_output_data (1, 0, \"Flags: 32-bit\");\n+\t}\n+\tbreak;\n+      case DW_MACINFO_define:\n+      case DW_MACINFO_undef:\n+\toutput_macinfo_op (ref);\n+\tref->code = 0;\n+\tfree (CONST_CAST (char *, ref->info));\n+\tref->info = NULL;\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+      }\n }\n \n /* Set up for Dwarf output at the start of compilation.  */\n@@ -20509,7 +20854,9 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n \t\t\t\t      SECTION_DEBUG, NULL);\n   debug_aranges_section = get_section (DEBUG_ARANGES_SECTION,\n \t\t\t\t       SECTION_DEBUG, NULL);\n-  debug_macinfo_section = get_section (DEBUG_MACINFO_SECTION,\n+  debug_macinfo_section = get_section (dwarf_strict\n+\t\t\t\t       ? DEBUG_MACINFO_SECTION\n+\t\t\t\t       : DEBUG_MACRO_SECTION,\n \t\t\t\t       SECTION_DEBUG, NULL);\n   debug_line_section = get_section (DEBUG_LINE_SECTION,\n \t\t\t\t    SECTION_DEBUG, NULL);\n@@ -20541,7 +20888,9 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n   ASM_GENERATE_INTERNAL_LABEL (ranges_section_label,\n \t\t\t       DEBUG_RANGES_SECTION_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (macinfo_section_label,\n-\t\t\t       DEBUG_MACINFO_SECTION_LABEL, 0);\n+\t\t\t       dwarf_strict\n+\t\t\t       ? DEBUG_MACINFO_SECTION_LABEL\n+\t\t\t       : DEBUG_MACRO_SECTION_LABEL, 0);\n \n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n     macinfo_table = VEC_alloc (macinfo_entry, gc, 64);\n@@ -22093,7 +22442,9 @@ dwarf2out_finish (const char *filename)\n \t\t    debug_line_section_label);\n \n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n-    add_AT_macptr (comp_unit_die (), DW_AT_macro_info, macinfo_section_label);\n+    add_AT_macptr (comp_unit_die (),\n+\t\t   dwarf_strict ? DW_AT_macro_info : DW_AT_GNU_macros,\n+\t\t   macinfo_section_label);\n \n   if (have_location_lists)\n     optimize_location_lists (comp_unit_die ());"}, {"sha": "29106d0479fea931bbd80b91645592d93011f017", "filename": "include/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520cda8ca897131960a30a1943687ee97b60e0b1/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520cda8ca897131960a30a1943687ee97b60e0b1/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=520cda8ca897131960a30a1943687ee97b60e0b1", "patch": "@@ -1,5 +1,8 @@\n 2011-07-22  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* dwarf2.h (DW_AT_GNU_macros): New.\n+\t(enum dwarf_macro_record_type): New enum.  Add DW_MACRO_GNU_*.\n+\n \tPR c++/49756\n \t* libiberty.h (stack_limit_increase): New prototype.\n "}, {"sha": "37cb83f4b23d0121a1eac6c14a1aea046989ce73", "filename": "include/dwarf2.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520cda8ca897131960a30a1943687ee97b60e0b1/include%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520cda8ca897131960a30a1943687ee97b60e0b1/include%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdwarf2.h?ref=520cda8ca897131960a30a1943687ee97b60e0b1", "patch": "@@ -366,6 +366,8 @@ enum dwarf_attribute\n     DW_AT_GNU_all_tail_call_sites = 0x2116,\n     DW_AT_GNU_all_call_sites = 0x2117,\n     DW_AT_GNU_all_source_call_sites = 0x2118,\n+    /* Section offset into .debug_macro section.  */\n+    DW_AT_GNU_macros = 0x2119,\n     /* VMS extensions.  */\n     DW_AT_VMS_rtnbeg_pd_address = 0x2201,\n     /* GNAT extensions.  */\n@@ -879,6 +881,20 @@ enum dwarf_macinfo_record_type\n     DW_MACINFO_end_file = 4,\n     DW_MACINFO_vendor_ext = 255\n   };\n+\n+/* Names and codes for new style macro information.  */\n+enum dwarf_macro_record_type\n+  {\n+    DW_MACRO_GNU_define = 1,\n+    DW_MACRO_GNU_undef = 2,\n+    DW_MACRO_GNU_start_file = 3,\n+    DW_MACRO_GNU_end_file = 4,\n+    DW_MACRO_GNU_define_indirect = 5,\n+    DW_MACRO_GNU_undef_indirect = 6,\n+    DW_MACRO_GNU_transparent_include = 7,\n+    DW_MACRO_GNU_lo_user = 0xe0,\n+    DW_MACRO_GNU_hi_user = 0xff\n+  };\n \f\n /* @@@ For use with GNU frame unwind information.  */\n "}]}