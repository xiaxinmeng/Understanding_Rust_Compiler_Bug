{"sha": "235d6e4f73ea401b7e34269463ec0bed125dc421", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM1ZDZlNGY3M2VhNDAxYjdlMzQyNjk0NjNlYzBiZWQxMjVkYzQyMQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-23T19:10:18Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-23T19:10:18Z"}, "message": "Initial revision\n\nFrom-SVN: r233", "tree": {"sha": "1aad515bf7e381e36c58a523014f8ea5c876be4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1aad515bf7e381e36c58a523014f8ea5c876be4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/235d6e4f73ea401b7e34269463ec0bed125dc421", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/235d6e4f73ea401b7e34269463ec0bed125dc421", "html_url": "https://github.com/Rust-GCC/gccrs/commit/235d6e4f73ea401b7e34269463ec0bed125dc421", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/235d6e4f73ea401b7e34269463ec0bed125dc421/comments", "author": null, "committer": null, "parents": [{"sha": "09da0d1cf88436495f5f0101a2381ca4ab27e905", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09da0d1cf88436495f5f0101a2381ca4ab27e905", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09da0d1cf88436495f5f0101a2381ca4ab27e905"}], "stats": {"total": 2106, "additions": 2106, "deletions": 0}, "files": [{"sha": "2b1828dd9bae9124e09495ba261a833a4a16eee5", "filename": "gcc/config/i860/i860.c", "status": "added", "additions": 2106, "deletions": 0, "changes": 2106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d6e4f73ea401b7e34269463ec0bed125dc421/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d6e4f73ea401b7e34269463ec0bed125dc421/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=235d6e4f73ea401b7e34269463ec0bed125dc421", "patch": "@@ -0,0 +1,2106 @@\n+/* Subroutines for insn-output.c for Intel 860\n+   Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n+   Derived from sparc.c.\n+\n+   Written by Richard Stallman (rms@ai.mit.edu).\n+\n+   Hacked substantially by Ron Guilmette (rfg@ncd.com) to cater\n+   to the whims of the System V Release 4 assembler.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"flags.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"recog.h\"\n+#include \"insn-attr.h\"\n+\n+#include <stdio.h>\n+\n+static rtx find_addr_reg ();\n+\n+#ifndef I860_REG_PREFIX\n+#define I860_REG_PREFIX \"\"\n+#endif\n+\n+char *i860_reg_prefix = I860_REG_PREFIX;\n+\n+/* Save information from a \"cmpxx\" operation until the branch is emitted.  */\n+\n+rtx i860_compare_op0, i860_compare_op1;\n+\f\n+/* Return non-zero if this pattern, can be evaluated safely, even if it\n+   was not asked for.  */\n+int\n+safe_insn_src_p (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  /* Just experimenting.  */\n+\n+  /* No floating point src is safe if it contains an arithmetic\n+     operation, since that operation may trap.  */\n+  switch (GET_CODE (op))\n+    {\n+    case CONST_INT:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST:\n+      return 1;\n+\n+    case REG:\n+      return 1;\n+\n+    case MEM:\n+      return CONSTANT_ADDRESS_P (XEXP (op, 0));\n+\n+      /* We never need to negate or complement constants.  */\n+    case NEG:\n+      return (mode != SFmode && mode != DFmode);\n+    case NOT:\n+    case ZERO_EXTEND:\n+      return 1;\n+\n+    case EQ:\n+    case NE:\n+    case LT:\n+    case GT:\n+    case LE:\n+    case GE:\n+    case LTU:\n+    case GTU:\n+    case LEU:\n+    case GEU:\n+    case MINUS:\n+    case PLUS:\n+      return (mode != SFmode && mode != DFmode);\n+    case AND:\n+    case IOR:\n+    case XOR:\n+    case LSHIFT:\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      if ((GET_CODE (XEXP (op, 0)) == CONST_INT && ! SMALL_INT (XEXP (op, 0)))\n+\t  || (GET_CODE (XEXP (op, 1)) == CONST_INT && ! SMALL_INT (XEXP (op, 1))))\n+\treturn 0;\n+      return 1;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return 1 if REG is clobbered in IN.\n+   Return 2 if REG is used in IN. \n+   Return 3 if REG is both used and clobbered in IN.\n+   Return 0 if neither.  */\n+\n+static int\n+reg_clobbered_p (reg, in)\n+     rtx reg;\n+     rtx in;\n+{\n+  register enum rtx_code code;\n+\n+  if (in == 0)\n+    return 0;\n+\n+  code = GET_CODE (in);\n+\n+  if (code == SET || code == CLOBBER)\n+    {\n+      rtx dest = SET_DEST (in);\n+      int set = 0;\n+      int used = 0;\n+\n+      while (GET_CODE (dest) == STRICT_LOW_PART\n+\t     || GET_CODE (dest) == SUBREG\n+\t     || GET_CODE (dest) == SIGN_EXTRACT\n+\t     || GET_CODE (dest) == ZERO_EXTRACT)\n+\tdest = XEXP (dest, 0);\n+\n+      if (dest == reg)\n+\tset = 1;\n+      else if (GET_CODE (dest) == REG\n+\t       && refers_to_regno_p (REGNO (reg),\n+\t\t\t\t     REGNO (reg) + HARD_REGNO_NREGS (reg, GET_MODE (reg)),\n+\t\t\t\t     SET_DEST (in), 0))\n+\t{\n+\t  set = 1;\n+\t  /* Anything that sets just part of the register\n+\t     is considered using as well as setting it.\n+\t     But note that a straight SUBREG of a single-word value\n+\t     clobbers the entire value.   */\n+\t  if (dest != SET_DEST (in)\n+\t      && ! (GET_CODE (SET_DEST (in)) == SUBREG\n+\t\t    || UNITS_PER_WORD >= GET_MODE_SIZE (GET_MODE (dest))))\n+\t    used = 1;\n+\t}\n+\n+      if (code == SET)\n+\t{\n+\t  if (set)\n+\t    used = refers_to_regno_p (REGNO (reg),\n+\t\t\t\t      REGNO (reg) + HARD_REGNO_NREGS (reg, GET_MODE (reg)),\n+\t\t\t\t      SET_SRC (in), 0);\n+\t  else\n+\t    used = refers_to_regno_p (REGNO (reg),\n+\t\t\t\t      REGNO (reg) + HARD_REGNO_NREGS (reg, GET_MODE (reg)),\n+\t\t\t\t      in, 0);\n+\t}\n+\n+      return set + used * 2;\n+    }\n+\n+  if (refers_to_regno_p (REGNO (reg),\n+\t\t\t REGNO (reg) + HARD_REGNO_NREGS (reg, GET_MODE (reg)),\n+\t\t\t in, 0))\n+    return 2;\n+  return 0;\n+}\n+\n+/* Return non-zero if OP can be written to without screwing up\n+   GCC's model of what's going on.  It is assumed that this operand\n+   appears in the dest position of a SET insn in a conditional\n+   branch's delay slot.  AFTER is the label to start looking from.  */\n+int\n+operand_clobbered_before_used_after (op, after)\n+     rtx op;\n+     rtx after;\n+{\n+  /* Just experimenting.  */\n+  if (GET_CODE (op) == CC0)\n+    return 1;\n+  if (GET_CODE (op) == REG)\n+    {\n+      rtx insn;\n+\n+      if (op == stack_pointer_rtx)\n+\treturn 0;\n+\n+      /* Scan forward from the label, to see if the value of OP\n+\t is clobbered before the first use.  */\n+\n+      for (insn = NEXT_INSN (after); insn; insn = NEXT_INSN (insn))\n+\t{\n+\t  if (GET_CODE (insn) == NOTE)\n+\t    continue;\n+\t  if (GET_CODE (insn) == INSN\n+\t      || GET_CODE (insn) == JUMP_INSN\n+\t      || GET_CODE (insn) == CALL_INSN)\n+\t    {\n+\t      switch (reg_clobbered_p (op, PATTERN (insn)))\n+\t\t{\n+\t\tdefault:\n+\t\t  return 0;\n+\t\tcase 1:\n+\t\t  return 1;\n+\t\tcase 0:\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  /* If we reach another label without clobbering OP,\n+\t     then we cannot safely write it here.  */\n+\t  else if (GET_CODE (insn) == CODE_LABEL)\n+\t    return 0;\n+\t  if (GET_CODE (insn) == JUMP_INSN)\n+\t    {\n+\t      if (condjump_p (insn))\n+\t\treturn 0;\n+\t      /* This is a jump insn which has already\n+\t\t been mangled.  We can't tell what it does.  */\n+\t      if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+\t\treturn 0;\n+\t      if (! JUMP_LABEL (insn))\n+\t\treturn 0;\n+\t      /* Keep following jumps.  */\n+\t      insn = JUMP_LABEL (insn);\n+\t    }\n+\t}\n+      return 1;\n+    }\n+\n+  /* In both of these cases, the first insn executed\n+     for this op will be a orh whatever%h,%?r0,%?r31,\n+     which is tolerable.  */\n+  if (GET_CODE (op) == MEM)\n+    return (CONSTANT_ADDRESS_P (XEXP (op, 0)));\n+\n+  return 0;\n+}\n+\n+/* Return non-zero if this pattern, as a source to a \"SET\",\n+   is known to yield an instruction of unit size.  */\n+int\n+single_insn_src_p (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case CONST_INT:\n+      /* This is not always a single insn src, technically,\n+\t but output_delayed_branch knows how to deal with it.  */\n+      return 1;\n+\n+    case SYMBOL_REF:\n+    case CONST:\n+      /* This is not a single insn src, technically,\n+\t but output_delayed_branch knows how to deal with it.  */\n+      return 1;\n+\n+    case REG:\n+      return 1;\n+\n+    case MEM:\n+      return 1;\n+\n+      /* We never need to negate or complement constants.  */\n+    case NEG:\n+      return (mode != DFmode);\n+    case NOT:\n+    case ZERO_EXTEND:\n+      return 1;\n+\n+    case PLUS:\n+    case MINUS:\n+      /* Detect cases that require multiple instructions.  */\n+      if (CONSTANT_P (XEXP (op, 1))\n+\t  && !(GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t       && SMALL_INT (XEXP (op, 1))))\n+\treturn 0;\n+    case EQ:\n+    case NE:\n+    case LT:\n+    case GT:\n+    case LE:\n+    case GE:\n+    case LTU:\n+    case GTU:\n+    case LEU:\n+    case GEU:\n+      /* Not doing floating point, since they probably\n+\t take longer than the branch slot they might fill.  */\n+      return (mode != SFmode && mode != DFmode);\n+\n+    case AND:\n+      if (GET_CODE (XEXP (op, 1)) == NOT)\n+\t{\n+\t  rtx arg = XEXP (XEXP (op, 1), 0);\n+\t  if (CONSTANT_P (arg)\n+\t      && !(GET_CODE (arg) == CONST_INT\n+\t\t   && (SMALL_INT (arg)\n+\t\t       || INTVAL (arg) & 0xffff == 0)))\n+\t    return 0;\n+\t}\n+    case IOR:\n+    case XOR:\n+      /* Both small and round numbers take one instruction;\n+\t others take two.  */\n+      if (CONSTANT_P (XEXP (op, 1))\n+\t  && !(GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t       && (SMALL_INT (XEXP (op, 1))\n+\t\t   || INTVAL (XEXP (op, 1)) & 0xffff == 0)))\n+\treturn 0;\n+\n+    case LSHIFT:\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      return 1;\n+\n+    case SUBREG:\n+      if (SUBREG_WORD (op) != 0)\n+\treturn 0;\n+      return single_insn_src_p (SUBREG_REG (op), mode);\n+\n+      /* Not doing floating point, since they probably\n+\t take longer than the branch slot they might fill.  */\n+    case FLOAT_EXTEND:\n+    case FLOAT_TRUNCATE:\n+    case FLOAT:\n+    case FIX:\n+    case UNSIGNED_FLOAT:\n+    case UNSIGNED_FIX:\n+      return 0;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Nonzero only if this *really* is a single insn operand.  */\n+int\n+strict_single_insn_op_p (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op);\n+\n+  switch (GET_CODE (op))\n+    {\n+    case CC0:\n+      return 1;\n+\n+    case CONST_INT:\n+      if (SMALL_INT (op))\n+\treturn 1;\n+      /* We can put this set insn into delay slot, because this is one\n+\t insn; `orh'.  */\n+      if ((INTVAL (op) & 0xffff) == 0)\n+\treturn 1;\n+      return 0;\n+\n+    case SYMBOL_REF:\n+      return 0;\n+\n+    case REG:\n+#if 0\n+      /* This loses when moving an freg to a general reg.  */\n+      return HARD_REGNO_NREGS (REGNO (op), mode) == 1;\n+#endif\n+      return (mode != DFmode && mode != DImode);\n+\n+    case MEM:\n+      if (! CONSTANT_ADDRESS_P (XEXP (op, 0)))\n+\treturn (mode != DFmode && mode != DImode);\n+      return 0;\n+\n+      /* We never need to negate or complement constants.  */\n+    case NEG:\n+      return (mode != DFmode);\n+    case NOT:\n+    case ZERO_EXTEND:\n+      return 1;\n+\n+    case PLUS:\n+    case MINUS:\n+      /* Detect cases that require multiple instructions.  */\n+      if (CONSTANT_P (XEXP (op, 1))\n+\t  && !(GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t       && SMALL_INT (XEXP (op, 1))))\n+\treturn 0;\n+    case EQ:\n+    case NE:\n+    case LT:\n+    case GT:\n+    case LE:\n+    case GE:\n+    case LTU:\n+    case GTU:\n+    case LEU:\n+    case GEU:\n+      return 1;\n+\n+    case AND:\n+      if (GET_CODE (XEXP (op, 1)) == NOT)\n+\t{\n+\t  rtx arg = XEXP (XEXP (op, 1), 0);\n+\t  if (CONSTANT_P (arg)\n+\t      && !(GET_CODE (arg) == CONST_INT\n+\t\t   && (SMALL_INT (arg)\n+\t\t       || INTVAL (arg) & 0xffff == 0)))\n+\t    return 0;\n+\t}\n+    case IOR:\n+    case XOR:\n+      /* Both small and round numbers take one instruction;\n+\t others take two.  */\n+      if (CONSTANT_P (XEXP (op, 1))\n+\t  && !(GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t       && (SMALL_INT (XEXP (op, 1))\n+\t\t   || INTVAL (XEXP (op, 1)) & 0xffff == 0)))\n+\treturn 0;\n+\n+    case LSHIFT:\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      return 1;\n+\n+    case SUBREG:\n+      if (SUBREG_WORD (op) != 0)\n+\treturn 0;\n+      return strict_single_insn_op_p (SUBREG_REG (op), mode);\n+\n+    case SIGN_EXTEND:\n+      if (GET_CODE (XEXP (op, 0)) == MEM\n+\t  && ! CONSTANT_ADDRESS_P (XEXP (XEXP (op, 0), 0)))\n+\treturn 1;\n+      return 0;\n+\n+      /* Not doing floating point, since they probably\n+\t take longer than the branch slot they might fill.  */\n+    case FLOAT_EXTEND:\n+    case FLOAT_TRUNCATE:\n+    case FLOAT:\n+    case FIX:\n+    case UNSIGNED_FLOAT:\n+    case UNSIGNED_FIX:\n+      return 0;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\f\n+/* Return truth value of whether OP is a relational operator.  */\n+int\n+relop (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case EQ:\n+    case NE:\n+    case GT:\n+    case GE:\n+    case LT:\n+    case LE:\n+    case GTU:\n+    case GEU:\n+    case LTU:\n+    case LEU:\n+      return 1;\n+    }\n+  return 0;\n+}\n+\f\n+/* Return non-zero only if OP is a register of mode MODE,\n+   or const0_rtx.  */\n+int\n+reg_or_0_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (op == const0_rtx || register_operand (op, mode)\n+\t  || op == CONST0_RTX (mode));\n+}\n+\n+/* Return truth value of whether OP can be used as an operands in a three\n+   address add/subtract insn (such as add %o1,7,%l2) of mode MODE.  */\n+\n+int\n+arith_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && SMALL_INT (op)));\n+}\n+\n+/* Return 1 if OP is a valid first operand for a logical insn of mode MODE.  */\n+\n+int\n+logic_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && LOGIC_INT (op)));\n+}\n+\n+/* Return 1 if OP is a valid first operand for a shift insn of mode MODE.  */\n+\n+int\n+shift_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+          || (GET_CODE (op) == CONST_INT));\n+}\n+\n+/* Return 1 if OP is a valid first operand for either a logical insn\n+   or an add insn of mode MODE.  */\n+\n+int\n+compare_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && SMALL_INT (op) && LOGIC_INT (op)));\n+}\n+\n+/* Return truth value of whether OP can be used as the 5-bit immediate\n+   operand of a bte or btne insn.  */\n+\n+int\n+bte_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT\n+\t      && (unsigned) INTVAL (op) < 0x20));\n+}\n+\n+/* Return 1 if OP is an indexed memory reference of mode MODE.  */\n+\n+int\n+indexed_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == MEM && GET_MODE (op) == mode\n+\t  && GET_CODE (XEXP (op, 0)) == PLUS\n+\t  && GET_MODE (XEXP (op, 0)) == SImode\n+\t  && register_operand (XEXP (XEXP (op, 0), 0), SImode)\n+\t  && register_operand (XEXP (XEXP (op, 0), 1), SImode));\n+}\n+\n+/* Return 1 if OP is a suitable source operand for a load insn\n+   with mode MODE.  */\n+\n+int\n+load_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (memory_operand (op, mode) || indexed_operand (op, mode));\n+}\n+\n+/* Return truth value of whether OP is a integer which fits the\n+   range constraining immediate operands in add/subtract insns.  */\n+\n+int\n+small_int (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == CONST_INT && SMALL_INT (op));\n+}\n+\n+/* Return truth value of whether OP is a integer which fits the\n+   range constraining immediate operands in logic insns.  */\n+\n+int\n+logic_int (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == CONST_INT && LOGIC_INT (op));\n+}\n+\f\n+/* Return the best assembler insn template\n+   for moving operands[1] into operands[0] as a fullword.  */\n+\n+static char *\n+singlemove_string (operands)\n+     rtx *operands;\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (GET_CODE (operands[1]) != MEM)\n+\tif (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+\t  {\n+\t    if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t\t   && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t\t   && cc_prev_status.mdep == XEXP (operands[0], 0)))\n+\t      {\n+\t\tCC_STATUS_INIT;\n+\t        output_asm_insn (\"orh %h0,%?r0,%?r31\", operands);\n+\t      }\n+\t    cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+\t    cc_status.mdep = XEXP (operands[0], 0);\n+\t    return \"st.l %r1,%L0(%?r31)\";\n+\t  }\n+\telse\n+\t  return \"st.l %r1,%0\";\n+      else\n+\tabort ();\n+#if 0\n+\t{\n+\t  rtx xoperands[2];\n+\n+\t  cc_status.flags &= ~CC_F0_IS_0;\n+\t  xoperands[0] = gen_rtx (REG, SFmode, 32);\n+\t  xoperands[1] = operands[1];\n+\t  output_asm_insn (singlemove_string (xoperands), xoperands);\n+\t  xoperands[1] = xoperands[0];\n+\t  xoperands[0] = operands[0];\n+\t  output_asm_insn (singlemove_string (xoperands), xoperands);\n+\t  return \"\";\n+\t}\n+#endif\n+    }\n+  if (GET_CODE (operands[1]) == MEM)\n+    {\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+\t{\n+\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t\t && cc_prev_status.mdep == XEXP (operands[1], 0)))\n+\t    {\n+\t      CC_STATUS_INIT;\n+\t      output_asm_insn (\"orh %h1,%?r0,%?r31\", operands);\n+\t    }\n+\t  cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+\t  cc_status.mdep = XEXP (operands[1], 0);\n+\t  return \"ld.l %L1(%?r31),%0\";\n+\t}\n+      return \"ld.l %m1,%0\";\n+    }\n+ if (GET_CODE (operands[1]) == CONST_INT)\n+   {\n+     if((INTVAL (operands[1]) & 0xffff0000) == 0)\n+      return \"or %L1,%?r0,%0\";\n+     if((INTVAL (operands[1]) & 0x0000ffff) == 0)\n+      return \"orh %H1,%?r0,%0\";\n+     if (operands[1] == const0_rtx)\n+      return \"mov %?r0,%0\";\n+   }\n+  return \"mov %1,%0\";\n+}\n+\f\n+/* Output assembler code to perform a doubleword move insn\n+   with operands OPERANDS.  */\n+\n+char *\n+output_move_double (operands)\n+     rtx *operands;\n+{\n+  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;\n+  rtx latehalf[2];\n+  rtx addreg0 = 0, addreg1 = 0;\n+\n+  /* First classify both operands.  */\n+\n+  if (REG_P (operands[0]))\n+    optype0 = REGOP;\n+  else if (offsettable_memref_p (operands[0]))\n+    optype0 = OFFSOP;\n+  else if (GET_CODE (operands[0]) == MEM)\n+    optype0 = MEMOP;\n+  else\n+    optype0 = RNDOP;\n+\n+  if (REG_P (operands[1]))\n+    optype1 = REGOP;\n+  else if (CONSTANT_P (operands[1]))\n+    optype1 = CNSTOP;\n+  else if (offsettable_memref_p (operands[1]))\n+    optype1 = OFFSOP;\n+  else if (GET_CODE (operands[1]) == MEM)\n+    optype1 = MEMOP;\n+  else\n+    optype1 = RNDOP;\n+\n+  /* Check for the cases that the operand constraints are not\n+     supposed to allow to happen.  Abort if we get one,\n+     because generating code for these cases is painful.  */\n+\n+  if (optype0 == RNDOP || optype1 == RNDOP)\n+    abort ();\n+\n+  /* If an operand is an unoffsettable memory ref, find a register\n+     we can increment temporarily to make it refer to the second word.  */\n+\n+  if (optype0 == MEMOP)\n+    addreg0 = find_addr_reg (XEXP (operands[0], 0));\n+\n+  if (optype1 == MEMOP)\n+    addreg1 = find_addr_reg (XEXP (operands[1], 0));\n+\n+/* ??? Perhaps in some cases move double words\n+   if there is a spare pair of floating regs.  */\n+\n+  /* Ok, we can do one word at a time.\n+     Normally we do the low-numbered word first,\n+     but if either operand is autodecrementing then we\n+     do the high-numbered word first.\n+\n+     In either case, set up in LATEHALF the operands to use\n+     for the high-numbered word and in some cases alter the\n+     operands in OPERANDS to be suitable for the low-numbered word.  */\n+\n+  if (optype0 == REGOP)\n+    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else if (optype0 == OFFSOP)\n+    latehalf[0] = adj_offsettable_operand (operands[0], 4);\n+  else\n+    latehalf[0] = operands[0];\n+\n+  if (optype1 == REGOP)\n+    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  else if (optype1 == OFFSOP)\n+    latehalf[1] = adj_offsettable_operand (operands[1], 4);\n+  else if (optype1 == CNSTOP)\n+    {\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\tsplit_double (operands[1], &operands[1], &latehalf[1]);\n+      else if (CONSTANT_P (operands[1]))\n+\tlatehalf[1] = const0_rtx;\n+    }\n+  else\n+    latehalf[1] = operands[1];\n+\n+  /* If the first move would clobber the source of the second one,\n+     do them in the other order.\n+\n+     RMS says \"This happens only for registers;\n+     such overlap can't happen in memory unless the user explicitly\n+     sets it up, and that is an undefined circumstance.\"\n+\n+     but it happens on the sparc when loading parameter registers,\n+     so I am going to define that circumstance, and make it work\n+     as expected.  */\n+\n+  if (optype0 == REGOP && optype1 == REGOP\n+      && REGNO (operands[0]) == REGNO (latehalf[1]))\n+    {\n+      CC_STATUS_PARTIAL_INIT;\n+      /* Make any unoffsettable addresses point at high-numbered word.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"adds 0x4,%0,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"adds 0x4,%0,%0\", &addreg1);\n+\n+      /* Do that word.  */\n+      output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+      /* Undo the adds we just did.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"adds -0x4,%0,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"adds -0x4,%0,%0\", &addreg1);\n+\n+      /* Do low-numbered word.  */\n+      return singlemove_string (operands);\n+    }\n+  else if (optype0 == REGOP && optype1 != REGOP\n+\t   && reg_overlap_mentioned_p (operands[0], operands[1]))\n+    {\n+      /* Do the late half first.  */\n+      output_asm_insn (singlemove_string (latehalf), latehalf);\n+      /* Then clobber.  */\n+      return singlemove_string (operands);\n+    }\n+\n+  /* Normal case: do the two words, low-numbered first.  */\n+\n+  output_asm_insn (singlemove_string (operands), operands);\n+\n+  CC_STATUS_PARTIAL_INIT;\n+  /* Make any unoffsettable addresses point at high-numbered word.  */\n+  if (addreg0)\n+    output_asm_insn (\"adds 0x4,%0,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"adds 0x4,%0,%0\", &addreg1);\n+\n+  /* Do that word.  */\n+  output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+  /* Undo the adds we just did.  */\n+  if (addreg0)\n+    output_asm_insn (\"adds -0x4,%0,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"adds -0x4,%0,%0\", &addreg1);\n+\n+  return \"\";\n+}\n+\f\n+char *\n+output_fp_move_double (operands)\n+     rtx *operands;\n+{\n+  /* If the source operand is any sort of zero, use f0 instead.  */\n+\n+  if (operands[1] == CONST0_RTX (GET_MODE (operands[1])))\n+    operands[1] = gen_rtx (REG, DFmode, F0_REGNUM);\n+\n+  if (FP_REG_P (operands[0]))\n+    {\n+      if (FP_REG_P (operands[1]))\n+\treturn \"fmov.dd %1,%0\";\n+      if (GET_CODE (operands[1]) == REG)\n+\t{\n+\t  output_asm_insn (\"ixfr %1,%0\", operands);\n+\t  operands[0] = gen_rtx (REG, VOIDmode, REGNO (operands[0]) + 1);\n+\t  operands[1] = gen_rtx (REG, VOIDmode, REGNO (operands[1]) + 1);\n+\t  return \"ixfr %1,%0\";\n+\t}\n+      if (operands[1] == CONST0_RTX (DFmode))\n+\treturn \"fmov.dd f0,%0\";\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+\t{\n+\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t\t && cc_prev_status.mdep == XEXP (operands[1], 0)))\n+\t    {\n+\t      CC_STATUS_INIT;\n+\t      output_asm_insn (\"orh %h1,%?r0,%?r31\", operands);\n+\t    }\n+\t  cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+\t  cc_status.mdep = XEXP (operands[1], 0);\n+\t  return \"fld.d %L1(%?r31),%0\";\n+\t}\n+      return \"fld.d %1,%0\";\n+    }\n+  else if (FP_REG_P (operands[1]))\n+    {\n+      if (GET_CODE (operands[0]) == REG)\n+\t{\n+\t  output_asm_insn (\"fxfr %1,%0\", operands);\n+\t  operands[0] = gen_rtx (REG, VOIDmode, REGNO (operands[0]) + 1);\n+\t  operands[1] = gen_rtx (REG, VOIDmode, REGNO (operands[1]) + 1);\n+\t  return \"fxfr %1,%0\";\n+\t}\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+\t{\n+\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t\t && cc_prev_status.mdep == XEXP (operands[0], 0)))\n+\t    {\n+\t      CC_STATUS_INIT;\n+\t      output_asm_insn (\"orh %h0,%?r0,%?r31\", operands);\n+\t    }\n+\t  cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+\t  cc_status.mdep = XEXP (operands[0], 0);\n+\t  return \"fst.d %1,%L0(%?r31)\";\n+\t}\n+      return \"fst.d %1,%0\";\n+    }\n+  else\n+    abort ();\n+  /* NOTREACHED */\n+  return NULL;\n+}\n+\f\n+/* Return a REG that occurs in ADDR with coefficient 1.\n+   ADDR can be effectively incremented by incrementing REG.  */\n+\n+static rtx\n+find_addr_reg (addr)\n+     rtx addr;\n+{\n+  while (GET_CODE (addr) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (addr, 0)) == REG)\n+\taddr = XEXP (addr, 0);\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\n+\taddr = XEXP (addr, 1);\n+      else if (CONSTANT_P (XEXP (addr, 0)))\n+\taddr = XEXP (addr, 1);\n+      else if (CONSTANT_P (XEXP (addr, 1)))\n+\taddr = XEXP (addr, 0);\n+      else\n+\tabort ();\n+    }\n+  if (GET_CODE (addr) == REG)\n+    return addr;\n+  abort ();\n+  /* NOTREACHED */\n+  return NULL;\n+}\n+\n+/* Return a template for a load instruction with mode MODE and\n+   arguments from the string ARGS.\n+\n+   This string is in static storage.   */\n+\n+static char *\n+load_opcode (mode, args, reg)\n+     enum machine_mode mode;\n+     char *args;\n+     rtx reg;\n+{\n+  static char buf[30];\n+  char *opcode;\n+\n+  switch (mode)\n+    {\n+    case QImode:\n+      opcode = \"ld.b\";\n+      break;\n+\n+    case HImode:\n+      opcode = \"ld.s\";\n+      break;\n+\n+    case SImode:\n+    case SFmode:\n+      if (FP_REG_P (reg))\n+\topcode = \"fld.l\";\n+      else\n+\topcode = \"ld.l\";\n+      break;\n+\n+    case DImode:\n+      if (!FP_REG_P (reg))\n+\tabort ();\n+    case DFmode:\n+      opcode = \"fld.d\";\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  sprintf (buf, \"%s %s\", opcode, args);\n+  return buf;\n+}\n+\n+/* Return a template for a store instruction with mode MODE and\n+   arguments from the string ARGS.\n+\n+   This string is in static storage.   */\n+\n+static char *\n+store_opcode (mode, args, reg)\n+     enum machine_mode mode;\n+     char *args;\n+     rtx reg;\n+{\n+  static char buf[30];\n+  char *opcode;\n+\n+  switch (mode)\n+    {\n+    case QImode:\n+      opcode = \"st.b\";\n+      break;\n+\n+    case HImode:\n+      opcode = \"st.s\";\n+      break;\n+\n+    case SImode:\n+    case SFmode:\n+      if (FP_REG_P (reg))\n+\topcode = \"fst.l\";\n+      else\n+\topcode = \"st.l\";\n+      break;\n+\n+    case DImode:\n+      if (!FP_REG_P (reg))\n+\tabort ();\n+    case DFmode:\n+      opcode = \"fst.d\";\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  sprintf (buf, \"%s %s\", opcode, args);\n+  return buf;\n+}\n+\f\n+/* Output a store-in-memory whose operands are OPERANDS[0,1].\n+   OPERANDS[0] is a MEM, and OPERANDS[1] is a reg or zero.\n+\n+   This function returns a template for an insn.\n+   This is in static storage.\n+\n+   It may also output some insns directly.\n+   It may alter the values of operands[0] and operands[1].  */\n+\n+char *\n+output_store (operands)\n+     rtx *operands;\n+{\n+  enum machine_mode mode = GET_MODE (operands[0]);\n+  rtx address = XEXP (operands[0], 0);\n+  char *string;\n+\n+  cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+  cc_status.mdep = address;\n+\n+  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t && address == cc_prev_status.mdep))\n+    {\n+      CC_STATUS_INIT;\n+      output_asm_insn (\"orh %h0,%?r0,%?r31\", operands);\n+      cc_prev_status.mdep = address;\n+    }\n+\n+  /* Store zero in two parts when appropriate.  */\n+  if (mode == DFmode && operands[1] == CONST0_RTX (DFmode))\n+    return store_opcode (DFmode, \"%r1,%L0(%?r31)\", operands[1]);\n+\n+  /* Code below isn't smart enough to move a doubleword in two parts,\n+     so use output_move_double to do that in the cases that require it.  */\n+  if ((mode == DImode || mode == DFmode)\n+      && ! FP_REG_P (operands[1]))\n+    return output_move_double (operands);\n+\n+  return store_opcode (mode, \"%r1,%L0(%?r31)\", operands[1]);\n+}\n+\n+/* Output a load-from-memory whose operands are OPERANDS[0,1].\n+   OPERANDS[0] is a reg, and OPERANDS[1] is a mem.\n+\n+   This function returns a template for an insn.\n+   This is in static storage.\n+\n+   It may also output some insns directly.\n+   It may alter the values of operands[0] and operands[1].  */\n+\n+char *\n+output_load (operands)\n+     rtx *operands;\n+{\n+  enum machine_mode mode = GET_MODE (operands[0]);\n+  rtx address = XEXP (operands[1], 0);\n+\n+  /* We don't bother trying to see if we know %hi(address).\n+     This is because we are doing a load, and if we know the\n+     %hi value, we probably also know that value in memory.  */\n+  cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+  cc_status.mdep = address;\n+\n+  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t && address == cc_prev_status.mdep\n+\t && cc_prev_status.mdep == cc_status.mdep))\n+    {\n+      CC_STATUS_INIT;\n+      output_asm_insn (\"orh %h1,%?r0,%?r31\", operands);\n+      cc_prev_status.mdep = address;\n+    }\n+\n+  /* Code below isn't smart enough to move a doubleword in two parts,\n+     so use output_move_double to do that in the cases that require it.  */\n+  if ((mode == DImode || mode == DFmode)\n+      && ! FP_REG_P (operands[0]))\n+    return output_move_double (operands);\n+\n+  return load_opcode (mode, \"%L1(%?r31),%0\", operands[0]);\n+}\n+\f\n+#if 0\n+/* Load the address specified by OPERANDS[3] into the register\n+   specified by OPERANDS[0].\n+\n+   OPERANDS[3] may be the result of a sum, hence it could either be:\n+\n+   (1) CONST\n+   (2) REG\n+   (2) REG + CONST_INT\n+   (3) REG + REG + CONST_INT\n+   (4) REG + REG  (special case of 3).\n+\n+   Note that (3) is not a legitimate address.\n+   All cases are handled here.  */\n+\n+void\n+output_load_address (operands)\n+     rtx *operands;\n+{\n+  rtx base, offset;\n+\n+  if (CONSTANT_P (operands[3]))\n+    {\n+      output_asm_insn (\"mov %3,%0\", operands);\n+      return;\n+    }\n+\n+  if (REG_P (operands[3]))\n+    {\n+      if (REGNO (operands[0]) != REGNO (operands[3]))\n+\toutput_asm_insn (\"shl %?r0,%3,%0\", operands);\n+      return;\n+    }\n+\n+  if (GET_CODE (operands[3]) != PLUS)\n+    abort ();\n+\n+  base = XEXP (operands[3], 0);\n+  offset = XEXP (operands[3], 1);\n+\n+  if (GET_CODE (base) == CONST_INT)\n+    {\n+      rtx tmp = base;\n+      base = offset;\n+      offset = tmp;\n+    }\n+\n+  if (GET_CODE (offset) != CONST_INT)\n+    {\n+      /* Operand is (PLUS (REG) (REG)).  */\n+      base = operands[3];\n+      offset = const0_rtx;\n+    }\n+\n+  if (REG_P (base))\n+    {\n+      operands[6] = base;\n+      operands[7] = offset;\n+      CC_STATUS_PARTIAL_INIT;\n+      if (SMALL_INT (offset))\n+\toutput_asm_insn (\"adds %7,%6,%0\", operands);\n+      else\n+\toutput_asm_insn (\"mov %7,%0\\n\\tadds %0,%6,%0\", operands);\n+    }\n+  else if (GET_CODE (base) == PLUS)\n+    {\n+      operands[6] = XEXP (base, 0);\n+      operands[7] = XEXP (base, 1);\n+      operands[8] = offset;\n+\n+      CC_STATUS_PARTIAL_INIT;\n+      if (SMALL_INT (offset))\n+\toutput_asm_insn (\"adds %6,%7,%0\\n\\tadds %8,%0,%0\", operands);\n+      else\n+\toutput_asm_insn (\"mov %8,%0\\n\\tadds %0,%6,%0\\n\\tadds %0,%7,%0\", operands);\n+    }\n+  else\n+    abort ();\n+}\n+#endif\n+\n+/* Output code to place a size count SIZE in register REG.\n+   Because block moves are pipelined, we don't include the\n+   first element in the transfer of SIZE to REG.\n+   For this, we subtract ALIGN.  (Actually, I think it is not\n+   right to subtract on this machine, so right now we don't.)  */\n+\n+static void\n+output_size_for_block_move (size, reg, align)\n+     rtx size, reg, align;\n+{\n+  rtx xoperands[3];\n+\n+  xoperands[0] = reg;\n+  xoperands[1] = size;\n+  xoperands[2] = align;\n+\n+#if 1\n+  cc_status.flags &= ~ CC_KNOW_HI_R31;\n+  output_asm_insn (\"mov %1,%0\", xoperands);\n+#else\n+  if (GET_CODE (size) == REG)\n+    output_asm_insn (\"sub %2,%1,%0\", xoperands);\n+  else\n+    {\n+      xoperands[1]\n+\t= gen_rtx (CONST_INT, VOIDmode, INTVAL (size) - INTVAL (align));\n+      cc_status.flags &= ~ CC_KNOW_HI_R31;\n+      output_asm_insn (\"mov %1,%0\", xoperands);\n+    }\n+#endif\n+}\n+\n+/* Emit code to perform a block move.\n+\n+   OPERANDS[0] is the destination.\n+   OPERANDS[1] is the source.\n+   OPERANDS[2] is the size.\n+   OPERANDS[3] is the known safe alignment.\n+   OPERANDS[4..6] are pseudos we can safely clobber as temps.  */\n+\n+char *\n+output_block_move (operands)\n+     rtx *operands;\n+{\n+  /* A vector for our computed operands.  Note that load_output_address\n+     makes use of (and can clobber) up to the 8th element of this vector.  */\n+  rtx xoperands[10];\n+  rtx zoperands[10];\n+  static int movstrsi_label = 0;\n+  int i, j;\n+  rtx temp1 = operands[4];\n+  rtx alignrtx = operands[3];\n+  int align = INTVAL (alignrtx);\n+  int chunk_size;\n+\n+  xoperands[0] = operands[0];\n+  xoperands[1] = operands[1];\n+  xoperands[2] = temp1;\n+\n+  /* We can't move more than four bytes at a time\n+     because we have only one register to move them through.  */\n+  if (align > 4)\n+    {\n+      align = 4;\n+      alignrtx = gen_rtx (CONST_INT, VOIDmode, 4);\n+    }\n+\n+  /* Recognize special cases of block moves.  These occur\n+     when GNU C++ is forced to treat something as BLKmode\n+     to keep it in memory, when its mode could be represented\n+     with something smaller.\n+\n+     We cannot do this for global variables, since we don't know\n+     what pages they don't cross.  Sigh.  */\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && ! CONSTANT_ADDRESS_P (operands[0])\n+      && ! CONSTANT_ADDRESS_P (operands[1]))\n+    {\n+      int size = INTVAL (operands[2]);\n+      rtx op0 = xoperands[0];\n+      rtx op1 = xoperands[1];\n+\n+      if ((align & 3) == 0 && (size & 3) == 0 && (size >> 2) <= 16)\n+\t{\n+\t  if (memory_address_p (SImode, plus_constant (op0, size))\n+\t      && memory_address_p (SImode, plus_constant (op1, size)))\n+\t    {\n+\t      cc_status.flags &= ~CC_KNOW_HI_R31;\n+\t      for (i = (size>>2)-1; i >= 0; i--)\n+\t\t{\n+\t\t  xoperands[0] = plus_constant (op0, i * 4);\n+\t\t  xoperands[1] = plus_constant (op1, i * 4);\n+\t\t  output_asm_insn (\"ld.l %a1,%?r31\\n\\tst.l %?r31,%a0\",\n+\t\t\t\t   xoperands);\n+\t\t}\n+\t      return \"\";\n+\t    }\n+\t}\n+      else if ((align & 1) == 0 && (size & 1) == 0 && (size >> 1) <= 16)\n+\t{\n+\t  if (memory_address_p (HImode, plus_constant (op0, size))\n+\t      && memory_address_p (HImode, plus_constant (op1, size)))\n+\t    {\n+\t      cc_status.flags &= ~CC_KNOW_HI_R31;\n+\t      for (i = (size>>1)-1; i >= 0; i--)\n+\t\t{\n+\t\t  xoperands[0] = plus_constant (op0, i * 2);\n+\t\t  xoperands[1] = plus_constant (op1, i * 2);\n+\t\t  output_asm_insn (\"ld.s %a1,%?r31\\n\\tst.s %?r31,%a0\",\n+\t\t\t\t   xoperands);\n+\t\t}\n+\t      return \"\";\n+\t    }\n+\t}\n+      else if (size <= 16)\n+\t{\n+\t  if (memory_address_p (QImode, plus_constant (op0, size))\n+\t      && memory_address_p (QImode, plus_constant (op1, size)))\n+\t    {\n+\t      cc_status.flags &= ~CC_KNOW_HI_R31;\n+\t      for (i = size-1; i >= 0; i--)\n+\t\t{\n+\t\t  xoperands[0] = plus_constant (op0, i);\n+\t\t  xoperands[1] = plus_constant (op1, i);\n+\t\t  output_asm_insn (\"ld.b %a1,%?r31\\n\\tst.b %?r31,%a0\",\n+\t\t\t\t   xoperands);\n+\t\t}\n+\t      return \"\";\n+\t    }\n+\t}\n+    }\n+\n+  /* Since we clobber untold things, nix the condition codes.  */\n+  CC_STATUS_INIT;\n+\n+  /* This is the size of the transfer.\n+     Either use the register which already contains the size,\n+     or use a free register (used by no operands).  */\n+  output_size_for_block_move (operands[2], operands[4], alignrtx);\n+\n+#if 0\n+  /* Also emit code to decrement the size value by ALIGN.  */\n+  zoperands[0] = operands[0];\n+  zoperands[3] = plus_constant (operands[0], align);\n+  output_load_address (zoperands);\n+#endif\n+\n+  /* Generate number for unique label.  */\n+\n+  xoperands[3] = gen_rtx (CONST_INT, VOIDmode, movstrsi_label++);\n+\n+  /* Calculate the size of the chunks we will be trying to move first.  */\n+\n+#if 0\n+  if ((align & 3) == 0)\n+    chunk_size = 4;\n+  else if ((align & 1) == 0)\n+    chunk_size = 2;\n+  else\n+#endif\n+    chunk_size = 1;\n+\n+  /* Copy the increment (negative) to a register for bla insn.  */\n+\n+  xoperands[4] = gen_rtx (CONST_INT, VOIDmode, - chunk_size);\n+  xoperands[5] = operands[5];\n+  output_asm_insn (\"adds %4,%?r0,%5\", xoperands);\n+\n+  /* Predecrement the loop counter.  This happens again also in the `bla'\n+     instruction which precceds the loop, but we need to have it done\n+     two times before we enter the loop because of the bizzare semantics\n+     of the bla instruction.  */\n+\n+  output_asm_insn (\"adds %5,%2,%2\", xoperands);\n+\n+  /* Check for the case where the original count was less than or equal to\n+     zero.  Avoid going through the loop at all if the original count was\n+     indeed less than or equal to zero.  Note that we treat the count as\n+     if it were a signed 32-bit quantity here, rather than an unsigned one,\n+     even though we really shouldn't.  We have to do this because of the\n+     semantics of the `ble' instruction, which assume that the count is\n+     a signed 32-bit value.  Anyway, in practice it won't matter because\n+     nobody is going to try to do a memcpy() of more than half of the\n+     entire address space (i.e. 2 gigabytes) anyway.  */\n+\n+  output_asm_insn (\"bc .Le%3\", xoperands);\n+\n+  /* Make available a register which is a temporary.  */\n+\n+  xoperands[6] = operands[6];\n+\n+  /* Now the actual loop.\n+     In xoperands, elements 1 and 0 are the input and output vectors.\n+     Element 2 is the loop index.  Element 5 is the increment.  */\n+\n+  output_asm_insn (\"subs %1,%5,%1\", xoperands);\n+  output_asm_insn (\"bla %5,%2,.Lm%3\", xoperands);\n+  output_asm_insn (\"adds %0,%2,%6\", xoperands);\n+  output_asm_insn (\"\\n.Lm%3:\", xoperands);\t    /* Label for bla above.  */\n+  output_asm_insn (\"\\n.Ls%3:\",  xoperands);\t    /* Loop start label. */\n+  output_asm_insn (\"adds %5,%6,%6\", xoperands);\n+\n+  /* NOTE:  The code here which is supposed to handle the cases where the\n+     sources and destinations are known to start on a 4 or 2 byte boundary\n+     are currently broken.  They fail to do anything about the overflow\n+     bytes which might still need to be copied even after we have copied\n+     some number of words or halfwords.  Thus, for now we use the lowest\n+     common denominator, i.e. the code which just copies some number of\n+     totally unaligned individual bytes.  (See the calculation of\n+     chunk_size above.  */\n+\n+  if (chunk_size == 4)\n+    {\n+      output_asm_insn (\"ld.l %2(%1),%?r31\", xoperands);\n+      output_asm_insn (\"bla %5,%2,.Ls%3\", xoperands);\n+      output_asm_insn (\"st.l %?r31,8(%6)\", xoperands);\n+    }\n+  else if (chunk_size == 2)\n+    {\n+      output_asm_insn (\"ld.s %2(%1),%?r31\", xoperands);\n+      output_asm_insn (\"bla %5,%2,.Ls%3\", xoperands);\n+      output_asm_insn (\"st.s %?r31,4(%6)\", xoperands);\n+    }\n+  else /* chunk_size == 1 */\n+    {\n+      output_asm_insn (\"ld.b %2(%1),%?r31\", xoperands);\n+      output_asm_insn (\"bla %5,%2,.Ls%3\", xoperands);\n+      output_asm_insn (\"st.b %?r31,2(%6)\", xoperands);\n+    }\n+  output_asm_insn (\"\\n.Le%3:\", xoperands);\t    /* Here if count <= 0.  */\n+\n+  return \"\";\n+}\n+\f\n+/* Output a delayed branch insn with the delay insn in its\n+   branch slot.  The delayed branch insn template is in TEMPLATE,\n+   with operands OPERANDS.  The insn in its delay slot is INSN.\n+\n+   As a special case, since we know that all memory transfers are via\n+   ld/st insns, if we see a (MEM (SYMBOL_REF ...)) we divide the memory\n+   reference around the branch as\n+\n+\torh ha%x,%?r0,%?r31\n+\tb ...\n+\tld/st l%x(%?r31),...\n+\n+   As another special case, we handle loading (SYMBOL_REF ...) and\n+   other large constants around branches as well:\n+\n+\torh h%x,%?r0,%0\n+\tb ...\n+\tor l%x,%0,%1\n+\n+   */\n+\n+char *\n+output_delayed_branch (template, operands, insn)\n+     char *template;\n+     rtx *operands;\n+     rtx insn;\n+{\n+  rtx src = XVECEXP (PATTERN (insn), 0, 1);\n+  rtx dest = XVECEXP (PATTERN (insn), 0, 0);\n+\n+  /* See if we are doing some branch together with setting some register\n+     to some 32-bit value which does (or may) have some of the high-order\n+     16 bits set.  If so, we need to set the register in two stages.  One\n+     stage must be done before the branch, and the other one can be done\n+     in the delay slot.  */\n+\n+  if ( (GET_CODE (src) == CONST_INT\n+\t&& ((unsigned) INTVAL (src) & (unsigned) 0xffff0000) != (unsigned) 0)\n+      || (GET_CODE (src) == SYMBOL_REF)\n+      || (GET_CODE (src) == LABEL_REF)\n+      || (GET_CODE (src) == CONST))\n+    {\n+      rtx xoperands[2];\n+      xoperands[0] = dest;\n+      xoperands[1] = src;\n+\n+      CC_STATUS_PARTIAL_INIT;\n+      /* Output the `orh' insn.  */\n+      output_asm_insn (\"orh %H1,%?r0,%0\", xoperands);\n+\n+      /* Output the branch instruction next.  */\n+      output_asm_insn (template, operands);\n+\n+      /* Now output the `or' insn.  */\n+      output_asm_insn (\"or %L1,%0,%0\", xoperands);\n+    }\n+  else if ((GET_CODE (src) == MEM\n+\t    && CONSTANT_ADDRESS_P (XEXP (src, 0)))\n+\t   || (GET_CODE (dest) == MEM\n+\t       && CONSTANT_ADDRESS_P (XEXP (dest, 0))))\n+    {\n+      rtx xoperands[2];\n+      char *split_template;\n+      xoperands[0] = dest;\n+      xoperands[1] = src;\n+\n+      /* Output the `orh' insn.  */\n+      if (GET_CODE (src) == MEM)\n+\t{\n+\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t\t && cc_prev_status.mdep == XEXP (operands[1], 0)))\n+\t    {\n+\t      CC_STATUS_INIT;\n+\t      output_asm_insn (\"orh %h1,%?r0,%?r31\", xoperands);\n+\t    }\n+\t  split_template = load_opcode (GET_MODE (dest),\n+\t\t\t\t\t\"%L1(%?r31),%0\", dest);\n+\t}\n+      else\n+\t{\n+\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t\t && cc_prev_status.mdep == XEXP (operands[0], 0)))\n+\t    {\n+\t      CC_STATUS_INIT;\n+\t      output_asm_insn (\"orh %h0,%?r0,%?r31\", xoperands);\n+\t    }\n+\t  split_template = store_opcode (GET_MODE (dest),\n+\t\t\t\t\t \"%r1,%L0(%?r31)\", src);\n+\t}\n+\n+      /* Output the branch instruction next.  */\n+      output_asm_insn (template, operands);\n+\n+      /* Now output the load or store.\n+\t No need to do a CC_STATUS_INIT, because we are branching anyway.  */\n+      output_asm_insn (split_template, xoperands);\n+    }\n+  else\n+    {\n+      int insn_code_number;\n+      rtx pat = gen_rtx (SET, VOIDmode, dest, src);\n+      rtx delay_insn = gen_rtx (INSN, VOIDmode, 0, 0, 0, pat, -1, 0, 0);\n+      int i;\n+\n+      /* Output the branch instruction first.  */\n+      output_asm_insn (template, operands);\n+\n+      /* Now recognize the insn which we put in its delay slot.\n+\t We must do this after outputing the branch insn,\n+\t since operands may just be a pointer to `recog_operand'.  */\n+      INSN_CODE (delay_insn) = insn_code_number = recog (pat, delay_insn);\n+      if (insn_code_number == -1)\n+\tabort ();\n+\n+      for (i = 0; i < insn_n_operands[insn_code_number]; i++)\n+\t{\n+\t  if (GET_CODE (recog_operand[i]) == SUBREG)\n+\t    recog_operand[i] = alter_subreg (recog_operand[i]);\n+\t}\n+\n+      insn_extract (delay_insn);\n+      if (! constrain_operands (insn_code_number, 1))\n+\tfatal_insn_not_found (delay_insn);\n+\n+      template = insn_template[insn_code_number];\n+      if (template == 0)\n+\ttemplate = (*insn_outfun[insn_code_number]) (recog_operand, delay_insn);\n+      output_asm_insn (template, recog_operand);\n+    }\n+  CC_STATUS_INIT;\n+  return \"\";\n+}\n+\n+/* Output a newly constructed insn DELAY_INSN.  */\n+char *\n+output_delay_insn (delay_insn)\n+     rtx delay_insn;\n+{\n+  char *template;\n+  int insn_code_number;\n+  int i;\n+\n+  /* Now recognize the insn which we put in its delay slot.\n+     We must do this after outputing the branch insn,\n+     since operands may just be a pointer to `recog_operand'.  */\n+  insn_code_number = recog_memoized (delay_insn);\n+  if (insn_code_number == -1)\n+    abort ();\n+\n+  /* Extract the operands of this delay insn.  */\n+  INSN_CODE (delay_insn) = insn_code_number;\n+  insn_extract (delay_insn);\n+\n+  /* It is possible that this insn has not been properly scaned by final\n+     yet.  If this insn's operands don't appear in the peephole's\n+     actual operands, then they won't be fixed up by final, so we\n+     make sure they get fixed up here.  -- This is a kludge.  */\n+  for (i = 0; i < insn_n_operands[insn_code_number]; i++)\n+    {\n+      if (GET_CODE (recog_operand[i]) == SUBREG)\n+\trecog_operand[i] = alter_subreg (recog_operand[i]);\n+    }\n+\n+#ifdef REGISTER_CONSTRAINTS\n+  if (! constrain_operands (insn_code_number))\n+    abort ();\n+#endif\n+\n+  cc_prev_status = cc_status;\n+\n+  /* Update `cc_status' for this instruction.\n+     The instruction's output routine may change it further.\n+     If the output routine for a jump insn needs to depend\n+     on the cc status, it should look at cc_prev_status.  */\n+\n+  NOTICE_UPDATE_CC (PATTERN (delay_insn), delay_insn);\n+\n+  /* Now get the template for what this insn would\n+     have been, without the branch.  */\n+\n+  template = insn_template[insn_code_number];\n+  if (template == 0)\n+    template = (*insn_outfun[insn_code_number]) (recog_operand, delay_insn);\n+  output_asm_insn (template, recog_operand);\n+  return \"\";\n+}\n+\f\n+/* Special routine to convert an SFmode value represented as a\n+   CONST_DOUBLE into its equivalent unsigned long bit pattern.\n+   We convert the value from a double precision floating-point\n+   value to single precision first, and thence to a bit-wise\n+   equivalent unsigned long value.  This routine is used when\n+   generating an immediate move of an SFmode value directly\n+   into a general register because the svr4 assembler doesn't\n+   grok floating literals in instruction operand contexts.  */\n+\n+unsigned long\n+sfmode_constant_to_ulong (x)\n+     rtx x;\n+{\n+  union { double d; unsigned long i[2]; } u;\n+  union { float f; unsigned long i; } u2;\n+\n+  if (GET_CODE (x) != CONST_DOUBLE || GET_MODE (x) != SFmode)\n+    abort ();\n+\n+#ifndef HOST_WORDS_BIG_ENDIAN\n+  u.i[0] = CONST_DOUBLE_LOW (x);\n+  u.i[1] = CONST_DOUBLE_HIGH (x);\n+#else\n+  u.i[0] = CONST_DOUBLE_HIGH (x);\n+  u.i[1] = CONST_DOUBLE_LOW (x);\n+#endif\n+\n+  u2.f = u.d;\n+  return u2.i;\n+}\n+\f\n+/* This function generates the assembly code for function entry.\n+   The macro FUNCTION_PROLOGUE in i860.h is defined to call this function.\n+\n+   ASM_FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.\n+\n+   NOTE: `frame_lower_bytes' is the count of bytes which will lie\n+   between the new `fp' value and the new `sp' value after the\n+   prologue is done.  `frame_upper_bytes' is the count of bytes\n+   that will lie between the new `fp' and the *old* `sp' value\n+   after the new `fp' is setup (in the prologue).  The upper\n+   part of each frame always includes at least 2 words (8 bytes)\n+   to hold the saved frame pointer and the saved return address.\n+\n+   The svr4 ABI for the i860 now requires that the values of the\n+   stack pointer and frame pointer registers be kept aligned to\n+   16-byte boundaries at all times.  We obey that restriction here.\n+\n+   The svr4 ABI for the i860 is entirely vague when it comes to specifying\n+   exactly where the \"preserved\" registers should be saved.  The native\n+   svr4 C compiler I now have doesn't help to clarify the requirements\n+   very much because it is plainly out-of-date and non-ABI-compliant\n+   (in at least one important way, i.e. how it generates function\n+   epilogues).\n+\n+   The native svr4 C compiler saves the \"preserved\" registers (i.e.\n+   r4-r15 and f2-f7) in the lower part of a frame (i.e. at negative\n+   offsets from the frame pointer).\n+\n+   Previous versions of GCC also saved the \"preserved\" registers in the\n+   \"nagative\" part of the frame, but they saved them using positive\n+   offsets from the (adjusted) stack pointer (after it had been adjusted\n+   to allocate space for the new frame).  That's just plain wrong\n+   because if the current function calls alloca(), the stack pointer\n+   will get moved, and it will be impossible to restore the registers\n+   properly again after that.\n+\n+   Both compilers handled parameter registers (i.e. r16-r27 and f8-f15)\n+   by copying their values either into various \"preserved\" registers or\n+   into stack slots in the lower part of the current frame (as seemed\n+   appropriate, depending upon subsequent usage of these values).\n+\n+   Here we want to save the preserved registers at some offset from the\n+   frame pointer register so as to avoid any possible problems arising\n+   from calls to alloca().  We can either save them at small positive\n+   offsets from the frame pointer, or at small negative offsets from\n+   the frame pointer.  If we save them at small negative offsets from\n+   the frame pointer (i.e. in the lower part of the frame) then we\n+   must tell the rest of GCC (via STARTING_FRAME_OFFSET) exactly how\n+   many bytes of space we plan to use in the lower part of the frame\n+   for this purpose.  Since other parts of the compiler reference the\n+   value of STARTING_FRAME_OFFSET long before final() calls this function,\n+   we would have to go ahead and assume the worst-case storage requirements\n+   for saving all of the \"preserved\" registers (and use that number, i.e.\n+   `80', to define STARTING_FRAME_OFFSET) if we wanted to save them in\n+   the lower part of the frame.  That could potentially be very wasteful,\n+   and that wastefulness could really hamper people compiling for embedded\n+   i860 targets with very tight limits on stack space.  Thus, we choose\n+   here to save the preserved registers in the upper part of the\n+   frame, so that we can decide at the very last minute how much (or how\n+   little) space we must allocate for this purpose.\n+\n+   To satisfy the needs of the svr4 ABI \"tdesc\" scheme, preserved\n+   registers must always be saved so that the saved values of registers\n+   with higher numbers are at higher addresses.  We obey that restriction\n+   here.\n+\n+   There are two somewhat different ways that you can generate prologues\n+   here... i.e. pedantically ABI-compliant, and the \"other\" way.  The\n+   \"other\" way is more consistant with what is currently generated by the\n+   \"native\" svr4 C compiler for the i860.  That's important if you want\n+   to use the current (as of 8/91) incarnation of svr4 SDB for the i860.\n+   The SVR4 SDB for the i860 insists on having function prologues be\n+   non-ABI-compliant!\n+\n+   To get fully ABI-compliant prologues, define I860_STRICT_ABI_PROLOGUES\n+   in the i860svr4.h file.  (By default this is *not* defined).\n+\n+   The differences between the ABI-compliant and non-ABI-compliant prologues\n+   are that (a) the ABI version seems to require the use of *signed*\n+   (rather than unsigned) adds and subtracts, and (b) the ordering of\n+   the various steps (e.g. saving preserved registers, saving the\n+   return address, setting up the new frame pointer value) is different.\n+\n+   For strict ABI compliance, it seems to be the case that the very last\n+   thing that is supposed to happen in the prologue is getting the frame\n+   pointer set to its new value (but only after everything else has\n+   already been properly setup).  We do that here, but only if the symbol\n+   I860_STRICT_ABI_PROLOGUES is defined.\n+*/\n+\n+#ifndef STACK_ALIGNMENT\n+#define STACK_ALIGNMENT\t16\n+#endif\n+\n+extern char call_used_regs[];\n+extern int leaf_function_p ();\n+\n+char *current_function_original_name;\n+\n+static int must_preserve_r1;\n+static unsigned must_preserve_bytes;\n+\n+void\n+function_prologue (asm_file, local_bytes)\n+     register FILE *asm_file;\n+     register unsigned local_bytes;\n+{\n+  register unsigned frame_lower_bytes;\n+  register unsigned frame_upper_bytes;\n+  register unsigned total_fsize;\n+  register unsigned preserved_reg_bytes = 0;\n+  register unsigned i;\n+  register unsigned preserved_so_far = 0;\n+\n+  must_preserve_r1 = (optimize < 2 || ! leaf_function_p ());\n+  must_preserve_bytes = 4 + (must_preserve_r1 ? 4 : 0);\n+\n+  /* Count registers that need preserving.  Ignore r0.  It never needs\n+     preserving.  */\n+\n+  for (i = 1; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (regs_ever_live[i] && ! call_used_regs[i])\n+        preserved_reg_bytes += 4;\n+    }\n+\n+  /* Round-up the frame_lower_bytes so that it's a multiple of 16. */\n+\n+  frame_lower_bytes = (local_bytes + STACK_ALIGNMENT - 1) & -STACK_ALIGNMENT;\n+\n+  /* The upper part of each frame will contain the saved fp,\n+     the saved r1, and stack slots for all of the other \"preserved\"\n+     registers that we find we will need to save & restore. */\n+\n+  frame_upper_bytes = must_preserve_bytes + preserved_reg_bytes;\n+\n+  /* Round-up the frame_upper_bytes so that it's a multiple of 16. */\n+\n+  frame_upper_bytes\n+    = (frame_upper_bytes + STACK_ALIGNMENT - 1) & -STACK_ALIGNMENT;\n+\n+  total_fsize = frame_upper_bytes + frame_lower_bytes;\n+\n+#ifndef I860_STRICT_ABI_PROLOGUES\n+\n+  /* There are two kinds of function prologues.\n+     You use the \"small\" version if the total frame size is\n+     small enough so that it can fit into an immediate 16-bit\n+     value in one instruction.  Otherwise, you use the \"large\"\n+     version of the function prologue.  */\n+\n+  if (total_fsize > 0x7fff)\n+    {\n+      /* Adjust the stack pointer.  The ABI sez to do this using `adds',\n+\t but the native C compiler on svr4 uses `addu'.  */\n+\n+      fprintf (asm_file, \"\\taddu -%d,%ssp,%ssp\\n\",\n+\tframe_upper_bytes, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Save the old frame pointer.  */\n+\n+      fprintf (asm_file, \"\\tst.l %sfp,0(%ssp)\\n\",\n+\ti860_reg_prefix, i860_reg_prefix);\n+\n+      /* Setup the new frame pointer.  The ABI sez to do this after\n+\t preserving registers (using adds), but that's not what the\n+\t native C compiler on svr4 does.  */\n+\n+      fprintf (asm_file, \"\\taddu 0,%ssp,%sfp\\n\",\n+\ti860_reg_prefix, i860_reg_prefix);\n+\n+      /* Get the value of frame_lower_bytes into r31.  */\n+\n+      fprintf (asm_file, \"\\torh %d,%sr0,%sr31\\n\",\n+\tframe_lower_bytes >> 16, i860_reg_prefix, i860_reg_prefix);\n+      fprintf (asm_file, \"\\tor %d,%sr31,%sr31\\n\",\n+\tframe_lower_bytes & 0xffff, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Now re-adjust the stack pointer using the value in r31.\n+\t The ABI sez to do this with `subs' but SDB may prefer `subu'.  */\n+\n+      fprintf (asm_file, \"\\tsubu %ssp,%sr31,%ssp\\n\",\n+\ti860_reg_prefix, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Preserve registers.  The ABI sez to do this before setting\n+\t up the new frame pointer, but that's not what the native\n+\t C compiler on svr4 does.  */\n+\n+      for (i = 1; i < 32; i++)\n+        if (regs_ever_live[i] && ! call_used_regs[i])\n+          fprintf (asm_file, \"\\tst.l %s%s,%d(%sfp)\\n\",\n+\t    i860_reg_prefix, reg_names[i],\n+\t    must_preserve_bytes  + (4 * preserved_so_far++),\n+\t    i860_reg_prefix);\n+\n+      for (i = 32; i < 64; i++)\n+        if (regs_ever_live[i] && ! call_used_regs[i])\n+          fprintf (asm_file, \"\\tfst.l %s%s,%d(%sfp)\\n\",\n+\t    i860_reg_prefix, reg_names[i],\n+\t    must_preserve_bytes + (4 * preserved_so_far++),\n+\t    i860_reg_prefix);\n+\n+      /* Save the return address.  */\n+\n+      if (must_preserve_r1)\n+        fprintf (asm_file, \"\\tst.l %sr1,4(%sfp)\\n\",\n+\t  i860_reg_prefix, i860_reg_prefix);\n+    }\n+  else\n+    {\n+      /* Adjust the stack pointer.  The ABI sez to do this using `adds',\n+\t but the native C compiler on svr4 uses `addu'.  */\n+\n+      fprintf (asm_file, \"\\taddu -%d,%ssp,%ssp\\n\",\n+\ttotal_fsize, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Save the old frame pointer.  */\n+\n+      fprintf (asm_file, \"\\tst.l %sfp,%d(%ssp)\\n\",\n+\ti860_reg_prefix, frame_lower_bytes, i860_reg_prefix);\n+\n+      /* Setup the new frame pointer.  The ABI sez to do this after\n+\t preserving registers and after saving the return address,\n+\t(and its saz to do this using adds), but that's not what the\n+\t native C compiler on svr4 does.  */\n+\n+      fprintf (asm_file, \"\\taddu %d,%ssp,%sfp\\n\",\n+\tframe_lower_bytes, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Preserve registers.  The ABI sez to do this before setting\n+\t up the new frame pointer, but that's not what the native\n+\t compiler on svr4 does.  */\n+\n+      for (i = 1; i < 32; i++)\n+        if (regs_ever_live[i] && ! call_used_regs[i])\n+          fprintf (asm_file, \"\\tst.l %s%s,%d(%sfp)\\n\",\n+\t    i860_reg_prefix, reg_names[i],\n+\t    must_preserve_bytes + (4 * preserved_so_far++),\n+\t    i860_reg_prefix);\n+\n+      for (i = 32; i < 64; i++)\n+        if (regs_ever_live[i] && ! call_used_regs[i])\n+          fprintf (asm_file, \"\\tfst.l %s%s,%d(%sfp)\\n\",\n+\t    i860_reg_prefix, reg_names[i],\n+\t    must_preserve_bytes + (4 * preserved_so_far++),\n+\t    i860_reg_prefix);\n+\n+      /* Save the return address.  The ABI sez to do this earlier,\n+\t and also via an offset from %sp, but the native C compiler\n+\t on svr4 does it later (i.e. now) and uses an offset from\n+\t %fp.  */\n+\n+      if (must_preserve_r1)\n+        fprintf (asm_file, \"\\tst.l %sr1,4(%sfp)\\n\",\n+\t  i860_reg_prefix, i860_reg_prefix);\n+    }\n+\n+#else /* defined(I860_STRICT_ABI_PROLOGUES) */\n+\n+  /* There are two kinds of function prologues.\n+     You use the \"small\" version if the total frame size is\n+     small enough so that it can fit into an immediate 16-bit\n+     value in one instruction.  Otherwise, you use the \"large\"\n+     version of the function prologue.  */\n+\n+  if (total_fsize > 0x7fff)\n+    {\n+      /* Adjust the stack pointer (thereby allocating a new frame).  */\n+\n+      fprintf (asm_file, \"\\tadds -%d,%ssp,%ssp\\n\",\n+\tframe_upper_bytes, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Save the caller's frame pointer.  */\n+\n+      fprintf (asm_file, \"\\tst.l %sfp,0(%ssp)\\n\",\n+\ti860_reg_prefix, i860_reg_prefix);\n+\n+      /* Save return address.  */\n+\n+      if (must_preserve_r1)\n+        fprintf (asm_file, \"\\tst.l %sr1,4(%ssp)\\n\",\n+\t  i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Get the value of frame_lower_bytes into r31 for later use.  */\n+\n+      fprintf (asm_file, \"\\torh %d,%sr0,%sr31\\n\",\n+\tframe_lower_bytes >> 16, i860_reg_prefix, i860_reg_prefix);\n+      fprintf (asm_file, \"\\tor %d,%sr31,%sr31\\n\",\n+\tframe_lower_bytes & 0xffff, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Now re-adjust the stack pointer using the value in r31.  */\n+\n+      fprintf (asm_file, \"\\tsubs %ssp,%sr31,%ssp\\n\",\n+\ti860_reg_prefix, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Pre-compute value to be used as the new frame pointer.  */\n+\n+      fprintf (asm_file, \"\\tadds %ssp,%sr31,%sr31\\n\",\n+\ti860_reg_prefix, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Preserve registers.  */\n+\n+      for (i = 1; i < 32; i++)\n+        if (regs_ever_live[i] && ! call_used_regs[i])\n+          fprintf (asm_file, \"\\tst.l %s%s,%d(%sr31)\\n\",\n+\t    i860_reg_prefix, reg_names[i],\n+\t    must_preserve_bytes + (4 * preserved_so_far++),\n+\t    i860_reg_prefix);\n+\n+      for (i = 32; i < 64; i++)\n+        if (regs_ever_live[i] && ! call_used_regs[i])\n+          fprintf (asm_file, \"\\tfst.l %s%s,%d(%sr31)\\n\",\n+\t    i860_reg_prefix, reg_names[i],\n+\t    must_preserve_bytes + (4 * preserved_so_far++),\n+\t    i860_reg_prefix);\n+\n+      /* Actually set the new value of the frame pointer.  */\n+\n+      fprintf (asm_file, \"\\tmov %sr31,%sfp\\n\",\n+\ti860_reg_prefix, i860_reg_prefix);\n+    }\n+  else\n+    {\n+      /* Adjust the stack pointer.  */\n+\n+      fprintf (asm_file, \"\\tadds -%d,%ssp,%ssp\\n\",\n+\ttotal_fsize, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Save the caller's frame pointer.  */\n+\n+      fprintf (asm_file, \"\\tst.l %sfp,%d(%ssp)\\n\",\n+\ti860_reg_prefix, frame_lower_bytes, i860_reg_prefix);\n+\n+      /* Save the return address.  */\n+\n+      if (must_preserve_r1)\n+        fprintf (asm_file, \"\\tst.l %sr1,%d(%ssp)\\n\",\n+\t  i860_reg_prefix, frame_lower_bytes + 4, i860_reg_prefix);\n+\n+      /* Preserve registers.  */\n+\n+      for (i = 1; i < 32; i++)\n+        if (regs_ever_live[i] && ! call_used_regs[i])\n+          fprintf (asm_file, \"\\tst.l %s%s,%d(%ssp)\\n\",\n+\t    i860_reg_prefix, reg_names[i],\n+\t    frame_lower_bytes + must_preserve_bytes + (4 * preserved_so_far++),\n+\t    i860_reg_prefix);\n+\n+      for (i = 32; i < 64; i++)\n+        if (regs_ever_live[i] && ! call_used_regs[i])\n+          fprintf (asm_file, \"\\tfst.l %s%s,%d(%ssp)\\n\",\n+\t    i860_reg_prefix, reg_names[i],\n+\t    frame_lower_bytes + must_preserve_bytes + (4 * preserved_so_far++),\n+\t    i860_reg_prefix);\n+\n+      /* Setup the new frame pointer.  */\n+\n+      fprintf (asm_file, \"\\tadds %d,%ssp,%sfp\\n\",\n+\tframe_lower_bytes, i860_reg_prefix, i860_reg_prefix);\n+    }\n+#endif /* defined(I860_STRICT_ABI_PROLOGUES) */\n+\n+#ifdef ASM_OUTPUT_PROLOGUE_SUFFIX\n+  ASM_OUTPUT_PROLOGUE_SUFFIX (asm_file);\n+#endif /* defined(ASM_OUTPUT_PROLOGUE_SUFFIX) */\n+}\n+\f\n+/* This function generates the assembly code for function exit.\n+   The macro FUNCTION_EPILOGUE in i860.h is defined to call this function.\n+\n+   ASM_FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.\n+\n+   Note that when we go to restore the preserved register values we must\n+   not try to address their slots by using offsets from the stack pointer.\n+   That's because the stack pointer may have been moved during the function\n+   execution due to a call to alloca().  Rather, we must restore all\n+   preserved registers via offsets from the frame pointer value.\n+\n+   Note also that when the current frame is being \"popped\" (by adjusting\n+   the value of the stack pointer) on function exit, we must (for the\n+   sake of alloca) set the new value of the stack pointer based upon\n+   the current value of the frame pointer.  We can't just add what we\n+   believe to be the (static) frame size to the stack pointer because\n+   if we did that, and alloca() had been called during this function,\n+   we would end up returning *without* having fully deallocated all of\n+   the space grabbed by alloca.  If that happened, and a function\n+   containing one or more alloca() calls was called over and over again,\n+   then the stack would grow without limit!\n+\n+   Finally note that the epilogues generated here are completely ABI\n+   compliant.  They go out of their way to insure that the value in\n+   the frame pointer register is never less than the value in the stack\n+   pointer register.  It's not clear why this relationship needs to be\n+   maintained at all times, but maintaining it only costs one extra\n+   instruction, so what the hell.\n+*/\n+\n+void\n+function_epilogue (asm_file, local_bytes)\n+     register FILE *asm_file;\n+     register unsigned local_bytes;\n+{\n+  register unsigned frame_upper_bytes;\n+  register unsigned preserved_reg_bytes = 0;\n+  register unsigned i;\n+  register unsigned restored_so_far = 0;\n+\n+  /* Count the number of registers that were preserved in the prologue.\n+     Ignore r0.  It is never preserved.  */\n+\n+  for (i = 1; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (regs_ever_live[i] && ! call_used_regs[i])\n+        preserved_reg_bytes += 4;\n+    }\n+\n+  /* The upper part of each frame will contain only saved fp,\n+     the saved r1, and stack slots for all of the other \"preserved\"\n+     registers that we find we will need to save & restore. */\n+\n+  frame_upper_bytes = must_preserve_bytes + preserved_reg_bytes;\n+\n+  /* Round-up frame_upper_bytes so that t is a multiple of 16. */\n+\n+  frame_upper_bytes\n+    = (frame_upper_bytes + STACK_ALIGNMENT - 1) & -STACK_ALIGNMENT;\n+\n+  /* Restore all of the \"preserved\" registers that need restoring.  */\n+\n+  for (i = 1; i < 32; i++)\n+    if (regs_ever_live[i] && ! call_used_regs[i])\n+      fprintf (asm_file, \"\\tld.l %d(%sfp),%s%s\\n\",\n+\tmust_preserve_bytes + (4 * restored_so_far++),\n+\ti860_reg_prefix, i860_reg_prefix, reg_names[i]);\n+\n+  for (i = 32; i < 64; i++)\n+    if (regs_ever_live[i] && ! call_used_regs[i])\n+      fprintf (asm_file, \"\\tfld.l %d(%sfp),%s%s\\n\",\n+\tmust_preserve_bytes + (4 * restored_so_far++),\n+\ti860_reg_prefix, i860_reg_prefix, reg_names[i]);\n+\n+  /* Get the value we plan to use to restore the stack pointer into r31.  */\n+\n+  fprintf (asm_file, \"\\tadds %d,%sfp,%sr31\\n\",\n+    frame_upper_bytes, i860_reg_prefix, i860_reg_prefix);\n+\n+  /* Restore the return address and the old frame pointer.  */\n+\n+  if (must_preserve_r1)\n+    fprintf (asm_file, \"\\tld.l 4(%sfp),%sr1\\n\",\n+      i860_reg_prefix, i860_reg_prefix);\n+\n+  fprintf (asm_file, \"\\tld.l 0(%sfp),%sfp\\n\",\n+    i860_reg_prefix, i860_reg_prefix);\n+\n+  /* Return and restore the old stack pointer value.  */\n+\n+  fprintf (asm_file, \"\\tbri %sr1\\n\\tmov %sr31,%ssp\\n\",\n+    i860_reg_prefix, i860_reg_prefix, i860_reg_prefix);\n+}"}]}