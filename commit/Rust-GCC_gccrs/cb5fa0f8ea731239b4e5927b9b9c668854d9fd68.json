{"sha": "cb5fa0f8ea731239b4e5927b9b9c668854d9fd68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I1ZmEwZjhlYTczMTIzOWI0ZTU5MjdiOWI5YzY2ODg1NGQ5ZmQ2OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-05-20T21:36:35Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-05-20T21:36:35Z"}, "message": "expr.c (expand_expr, [...]): Don't fold constant access if EXPAND_CONST_ADDRESS or EXPAND_INITIALIZER.\n\n\t* expr.c (expand_expr, case ARRAY_REF): Don't fold constant\n\taccess if EXPAND_CONST_ADDRESS or EXPAND_INITIALIZER.\n\t(expand_expr, case COMPONENT_REF): Do copy if misaligned even\n\tif EXPAND_CONST_ADDRESS or EXPAND_INITIALIZER.\n\nFrom-SVN: r42361", "tree": {"sha": "42b3a9f5c9abcdac10d9e5260b82f98b6774d984", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42b3a9f5c9abcdac10d9e5260b82f98b6774d984"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb5fa0f8ea731239b4e5927b9b9c668854d9fd68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb5fa0f8ea731239b4e5927b9b9c668854d9fd68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb5fa0f8ea731239b4e5927b9b9c668854d9fd68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb5fa0f8ea731239b4e5927b9b9c668854d9fd68/comments", "author": null, "committer": null, "parents": [{"sha": "eabb9ed02da2738eb1fa31cc0d1d99a84cb0b713", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eabb9ed02da2738eb1fa31cc0d1d99a84cb0b713", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eabb9ed02da2738eb1fa31cc0d1d99a84cb0b713"}], "stats": {"total": 59, "additions": 31, "deletions": 28}, "files": [{"sha": "03a594ccb5c1db5d74ae77f3e9dd8c80d137159f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb5fa0f8ea731239b4e5927b9b9c668854d9fd68/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb5fa0f8ea731239b4e5927b9b9c668854d9fd68/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb5fa0f8ea731239b4e5927b9b9c668854d9fd68", "patch": "@@ -1,5 +1,10 @@\n Sun May 20 16:39:24 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* expr.c (expand_expr, case ARRAY_REF): Don't fold constant\n+\taccess if EXPAND_CONST_ADDRESS or EXPAND_INITIALIZER.\n+\t(expand_expr, case COMPONENT_REF): Do copy if misaligned even\n+\tif EXPAND_CONST_ADDRESS or EXPAND_INITIALIZER.\n+\n \t* stmt.c (expand_decl): Set mode, alignment, and sizes for CONST_DECL.\n \n 2001-05-20  Richard Henderson  <rth@redhat.com>"}, {"sha": "b654b460d3252e321fa59628ee6b23ee3d2c5e3c", "filename": "gcc/expr.c", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb5fa0f8ea731239b4e5927b9b9c668854d9fd68/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb5fa0f8ea731239b4e5927b9b9c668854d9fd68/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=cb5fa0f8ea731239b4e5927b9b9c668854d9fd68", "patch": "@@ -6828,7 +6828,8 @@ expand_expr (exp, target, tmode, modifier)\n \t   Don't fold if this is for wide characters since it's too\n \t   difficult to do correctly and this is a very rare case.  */\n \n-\tif (TREE_CODE (array) == STRING_CST\n+\tif (modifier != EXPAND_CONST_ADDRESS && modifier != EXPAND_INITIALIZER\n+\t    && TREE_CODE (array) == STRING_CST\n \t    && TREE_CODE (index) == INTEGER_CST\n \t    && compare_tree_int (index, TREE_STRING_LENGTH (array)) < 0\n \t    && GET_MODE_CLASS (mode) == MODE_INT\n@@ -6841,7 +6842,8 @@ expand_expr (exp, target, tmode, modifier)\n \t   we have an explicit constructor and when our operand is a variable\n \t   that was declared const.  */\n \n-\tif (TREE_CODE (array) == CONSTRUCTOR && ! TREE_SIDE_EFFECTS (array)\n+\tif (modifier != EXPAND_CONST_ADDRESS && modifier != EXPAND_INITIALIZER\n+\t    && TREE_CODE (array) == CONSTRUCTOR && ! TREE_SIDE_EFFECTS (array)\n \t    && TREE_CODE (index) == INTEGER_CST\n \t    && 0 > compare_tree_int (index,\n \t\t\t\t     list_length (CONSTRUCTOR_ELTS\n@@ -6860,6 +6862,8 @@ expand_expr (exp, target, tmode, modifier)\n \t  }\n \n \telse if (optimize >= 1\n+\t\t && modifier != EXPAND_CONST_ADDRESS\n+\t\t && modifier != EXPAND_INITIALIZER\n \t\t && TREE_READONLY (array) && ! TREE_SIDE_EFFECTS (array)\n \t\t && TREE_CODE (array) == VAR_DECL && DECL_INITIAL (array)\n \t\t && TREE_CODE (DECL_INITIAL (array)) != ERROR_MARK)\n@@ -7102,34 +7106,28 @@ expand_expr (exp, target, tmode, modifier)\n \t   an integer-mode (e.g., SImode) object.  Handle this case\n \t   by doing the extract into an object as wide as the field\n \t   (which we know to be the width of a basic mode), then\n-\t   storing into memory, and changing the mode to BLKmode.\n-\t   If we ultimately want the address (EXPAND_CONST_ADDRESS or\n-\t   EXPAND_INITIALIZER), then we must not copy to a temporary.  */\n+\t   storing into memory, and changing the mode to BLKmode.  */\n \tif (mode1 == VOIDmode\n \t    || GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG\n-\t    || (modifier != EXPAND_CONST_ADDRESS\n-\t\t&& modifier != EXPAND_INITIALIZER\n-\t\t&& ((mode1 != BLKmode && ! direct_load[(int) mode1]\n-\t\t     && GET_MODE_CLASS (mode) != MODE_COMPLEX_INT\n-\t\t     && GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)\n-\t\t    /* If the field isn't aligned enough to fetch as a memref,\n-\t\t       fetch it as a bit field.  */\n-\t\t    || (mode1 != BLKmode\n-\t\t\t&& SLOW_UNALIGNED_ACCESS (mode1, alignment)\n-\t\t\t&& ((TYPE_ALIGN (TREE_TYPE (tem))\n-\t\t\t     < GET_MODE_ALIGNMENT (mode))\n-\t\t\t    || (bitpos % GET_MODE_ALIGNMENT (mode) != 0)))\n-\t\t    /* If the type and the field are a constant size and the\n-\t\t       size of the type isn't the same size as the bitfield,\n-\t\t       we must use bitfield operations.  */\n-\t\t    || ((bitsize >= 0\n-\t\t\t && (TREE_CODE (TYPE_SIZE (TREE_TYPE (exp)))\n-\t\t\t     == INTEGER_CST)\n-\t\t\t && 0 != compare_tree_int (TYPE_SIZE (TREE_TYPE (exp)),\n-\t\t\t\t\t\t   bitsize)))))\n-\t    || (modifier != EXPAND_CONST_ADDRESS\n-\t\t&& modifier != EXPAND_INITIALIZER\n-\t\t&& mode == BLKmode\n+\t    || (mode1 != BLKmode && ! direct_load[(int) mode1]\n+\t\t&& GET_MODE_CLASS (mode) != MODE_COMPLEX_INT\n+\t\t&& GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)\n+\t    /* If the field isn't aligned enough to fetch as a memref,\n+\t       fetch it as a bit field.  */\n+\t    || (mode1 != BLKmode\n+\t\t&& SLOW_UNALIGNED_ACCESS (mode1, alignment)\n+\t\t&& ((TYPE_ALIGN (TREE_TYPE (tem))\n+\t\t     < GET_MODE_ALIGNMENT (mode))\n+\t\t    || (bitpos % GET_MODE_ALIGNMENT (mode) != 0)))\n+\t    /* If the type and the field are a constant size and the\n+\t       size of the type isn't the same size as the bitfield,\n+\t       we must use bitfield operations.  */\n+\t    || (bitsize >= 0\n+\t\t&& (TREE_CODE (TYPE_SIZE (TREE_TYPE (exp)))\n+\t\t    == INTEGER_CST)\n+\t\t&& 0 != compare_tree_int (TYPE_SIZE (TREE_TYPE (exp)),\n+\t\t\t\t\t  bitsize))\n+\t    || (mode == BLKmode\n \t\t&& SLOW_UNALIGNED_ACCESS (mode, alignment)\n \t\t&& (TYPE_ALIGN (type) > alignment\n \t\t    || bitpos % TYPE_ALIGN (type) != 0)))"}]}