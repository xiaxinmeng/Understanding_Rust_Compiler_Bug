{"sha": "48cf395bdb30be10a283c3ac4d6217c322f39070", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhjZjM5NWJkYjMwYmUxMGEyODNjM2FjNGQ2MjE3YzMyMmYzOTA3MA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-05-07T15:52:01Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-05-07T15:52:01Z"}, "message": "lto-wrapper.c (DUMPBASE_SUFFIX): Define.\n\n2010-05-07  Richard Guenther  <rguenther@suse.de>\n\n\t* lto-wrapper.c (DUMPBASE_SUFFIX): Define.\n\t(run_gcc): Handle LTRANS phase invocation.\n\t* collect2.c (maybe_run_lto_and_relink): Do not set\n\tWPA_SAVE_LTRANS.\n\n\tlto/\n\t* lto.c (DUMPBASE_SUFFIX): Remove.\n\t(lto_execute_ltrans): Move functionality to lto-wrapper.c.\n\tRename to ...\n\t(lto_write_ltrans_list): ... only output the list of ltrans files.\n\t(lto_maybe_unlink): Remove.\n\t(do_whole_program_analysis): Do not execute LTRANS phase\n\tfrom here.\n\nFrom-SVN: r159157", "tree": {"sha": "eb23163d0cf15d449c5e89de6d77e5bc1dec73b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb23163d0cf15d449c5e89de6d77e5bc1dec73b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48cf395bdb30be10a283c3ac4d6217c322f39070", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48cf395bdb30be10a283c3ac4d6217c322f39070", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48cf395bdb30be10a283c3ac4d6217c322f39070", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48cf395bdb30be10a283c3ac4d6217c322f39070/comments", "author": null, "committer": null, "parents": [{"sha": "86b2c5b637642a064406be4c02bf107ce338b8c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86b2c5b637642a064406be4c02bf107ce338b8c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86b2c5b637642a064406be4c02bf107ce338b8c5"}], "stats": {"total": 383, "additions": 189, "deletions": 194}, "files": [{"sha": "d334f639f51c601fdc870a7b7ced2e2b4f142d88", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48cf395bdb30be10a283c3ac4d6217c322f39070/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48cf395bdb30be10a283c3ac4d6217c322f39070/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48cf395bdb30be10a283c3ac4d6217c322f39070", "patch": "@@ -1,3 +1,10 @@\n+2010-05-07  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto-wrapper.c (DUMPBASE_SUFFIX): Define.\n+\t(run_gcc): Handle LTRANS phase invocation.\n+\t* collect2.c (maybe_run_lto_and_relink): Do not set\n+\tWPA_SAVE_LTRANS.\n+\n 2010-05-07  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree.h (TREE_ADDRESSABLE): Adjust comment to say that"}, {"sha": "99d9be46dee97b584ed78cfb845250a0badb3a2b", "filename": "gcc/collect2.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48cf395bdb30be10a283c3ac4d6217c322f39070/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48cf395bdb30be10a283c3ac4d6217c322f39070/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=48cf395bdb30be10a283c3ac4d6217c322f39070", "patch": "@@ -1007,10 +1007,6 @@ maybe_run_lto_and_relink (char **lto_ld_argv, char **object_lst,\n \n       *lto_c_ptr = NULL;\n \n-      /* Save intermediate WPA files in lto1 if debug.  */\n-      if (debug)\n-\tputenv (xstrdup (\"WPA_SAVE_LTRANS=1\"));\n-\n       /* Run the LTO back end.  */\n       pex = collect_execute (prog, lto_c_argv, NULL, NULL, PEX_SEARCH);\n       {"}, {"sha": "c9a37d947dac364f0bae773ed95e8b74db285ad6", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 155, "deletions": 3, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48cf395bdb30be10a283c3ac4d6217c322f39070/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48cf395bdb30be10a283c3ac4d6217c322f39070/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=48cf395bdb30be10a283c3ac4d6217c322f39070", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"intl.h\"\n #include \"libiberty.h\"\n+#include \"obstack.h\"\n \n int debug;\t\t\t\t/* true if -debug */\n \n@@ -246,6 +247,8 @@ fork_execute (char **argv)\n   free (at_args);\n }\n \n+/* Template of LTRANS dumpbase suffix.  */\n+#define DUMPBASE_SUFFIX \".ltrans18446744073709551615\"\n \n /* Execute gcc. ARGC is the number of arguments. ARGV contains the arguments. */\n \n@@ -350,6 +353,7 @@ run_gcc (unsigned argc, char *argv[])\n   *argv_ptr = NULL;\n \n   fork_execute (CONST_CAST (char **, new_argv));\n+\n   free (new_argv);\n   new_argv = NULL;\n \n@@ -362,16 +366,164 @@ run_gcc (unsigned argc, char *argv[])\n   else if (lto_mode == LTO_MODE_WHOPR)\n     {\n       FILE *stream = fopen (ltrans_output_file, \"r\");\n-      int c;\n+      const char *collect_gcc_options, *collect_gcc;\n+      struct obstack env_obstack;\n+      bool seen_dumpbase = false;\n+      char *dumpbase_suffix = NULL;\n+      unsigned j;\n \n       if (!stream)\n \tfatal_perror (\"fopen: %s\", ltrans_output_file);\n \n-      while ((c = getc (stream)) != EOF)\n-\tputc (c, stdout);\n+      /* Get the driver and options.  */\n+      collect_gcc = getenv (\"COLLECT_GCC\");\n+      if (!collect_gcc)\n+\tfatal (\"environment variable COLLECT_GCC must be set\");\n+\n+      /* Set the CFLAGS environment variable.  */\n+      collect_gcc_options = getenv (\"COLLECT_GCC_OPTIONS\");\n+      if (!collect_gcc_options)\n+\tfatal (\"environment variable COLLECT_GCC_OPTIONS must be set\");\n+\n+      /* Count arguments.  */\n+      i = 0;\n+      for (j = 0; collect_gcc_options[j] != '\\0'; ++j)\n+\tif (collect_gcc_options[j] == '\\'')\n+\t  ++i;\n+\n+      if (i % 2 != 0)\n+\tfatal (\"malformed COLLECT_GCC_OPTIONS\");\n+\n+      /* Initalize the arguments for the LTRANS driver.  */\n+      new_argv = (const char **) xmalloc ((8 + i / 2) * sizeof (char *));\n+      argv_ptr = new_argv;\n+      *argv_ptr++ = collect_gcc;\n+      *argv_ptr++ = \"-xlto\";\n+      *argv_ptr++ = \"-c\";\n+      for (j = 0; collect_gcc_options[j] != '\\0'; ++j)\n+\tif (collect_gcc_options[j] == '\\'')\n+\t  {\n+\t    char *option;\n+\n+\t    ++j;\n+\t    i = j;\n+\t    while (collect_gcc_options[j] != '\\'')\n+\t      ++j;\n+\t    obstack_init (&env_obstack);\n+\t    obstack_grow (&env_obstack, &collect_gcc_options[i], j - i);\n+\t    if (seen_dumpbase)\n+\t      obstack_grow (&env_obstack, DUMPBASE_SUFFIX,\n+\t\t\t    sizeof (DUMPBASE_SUFFIX));\n+\t    else\n+\t      obstack_1grow (&env_obstack, 0);\n+\t    option = XOBFINISH (&env_obstack, char *);\n+\t    if (seen_dumpbase)\n+\t      {\n+\t\tdumpbase_suffix = option + 7 + j - i;\n+\t\tseen_dumpbase = false;\n+\t      }\n+\n+\t    /* LTRANS does not need -fwhopr.  */\n+\t    if (strncmp (option, \"-fwhopr\", 7) != 0)\n+\t      {\n+\t\tif (strncmp (option, \"-dumpbase\", 9) == 0)\n+\t\t  seen_dumpbase = true;\n+\t\t*argv_ptr++ = option;\n+\t      }\n+\t  }\n+      *argv_ptr++ = \"-fltrans\";\n+\n+      for (;;)\n+\t{\n+\t  const unsigned piece = 32;\n+\t  char *output_name;\n+\t  char *buf, *input_name = (char *)xmalloc (piece);\n+\t  size_t len;\n+\n+\t  buf = input_name;\n+cont:\n+\t  if (!fgets (buf, piece, stream))\n+\t    break;\n+\t  len = strlen (input_name);\n+\t  if (input_name[len - 1] != '\\n')\n+\t    {\n+\t      input_name = (char *)xrealloc (input_name, len + piece);\n+\t      buf = input_name + len;\n+\t      goto cont;\n+\t    }\n+\t  input_name[len - 1] = '\\0';\n+\n+\t  if (input_name[0] == '*')\n+\t    {\n+\t      continue;\n+\t      output_name = &input_name[1];\n+\t    }\n+\t  else\n+\t    {\n+\t      struct pex_obj *pex;\n+\t      const char *errmsg;\n+\t      int err;\n+\t      int status;\n+\n+\t      /* Otherwise, add FILES[I] to lto_execute_ltrans command line\n+\t\t and add the resulting file to LTRANS output list.  */\n+\n+\t      /* Replace the .o suffix with a .ltrans.o suffix and write\n+\t\t the resulting name to the LTRANS output list.  */\n+\t      obstack_init (&env_obstack);\n+\t      obstack_grow (&env_obstack, input_name, strlen (input_name) - 2);\n+\t      obstack_grow (&env_obstack, \".ltrans.o\", sizeof (\".ltrans.o\"));\n+\t      output_name = XOBFINISH (&env_obstack, char *);\n+\n+\t      argv_ptr[0] = \"-o\";\n+\t      argv_ptr[1] = output_name;\n+\t      argv_ptr[2] = input_name;\n+\t      argv_ptr[3] = NULL;\n+\n+\t      /* Append a sequence number to -dumpbase for LTRANS.  */\n+\t      if (dumpbase_suffix)\n+\t\tsnprintf (dumpbase_suffix, sizeof (DUMPBASE_SUFFIX) - 7,\n+\t\t\t  \"%lu\", (unsigned long) i);\n+\n+\t      /* Execute the driver.  */\n+\t      pex = pex_init (0, \"lto1\", NULL);\n+\t      if (pex == NULL)\n+\t\tfatal (\"pex_init failed: %s\", xstrerror (errno));\n+\n+\t      errmsg = pex_run (pex, PEX_LAST | PEX_SEARCH, new_argv[0],\n+\t\t\t\tCONST_CAST (char **, new_argv),\n+\t\t\t\tNULL, NULL, &err);\n+\t      if (errmsg)\n+\t\tfatal (\"%s: %s\", errmsg, xstrerror (err));\n+\n+\t      if (!pex_get_status (pex, 1, &status))\n+\t\tfatal (\"can't get program status: %s\", xstrerror (errno));\n+\n+\t      if (status)\n+\t\t{\n+\t\t  if (WIFSIGNALED (status))\n+\t\t    {\n+\t\t      int sig = WTERMSIG (status);\n+\t\t      fatal (\"%s terminated with signal %d [%s]%s\",\n+\t\t\t     new_argv[0], sig, strsignal (sig),\n+\t\t\t     WCOREDUMP (status) ? \", core dumped\" : \"\");\n+\t\t    }\n+\t\t  else\n+\t\t    fatal (\"%s terminated with status %d\", new_argv[0], status);\n+\t\t}\n+\n+\t      pex_free (pex);\n+\n+\t      maybe_unlink_file (input_name);\n+\t    }\n+\n+\t  fputs (output_name, stdout);\n+\t  putc ('\\n', stdout);\n+\t}\n       fclose (stream);\n       maybe_unlink_file (ltrans_output_file);\n       free (list_option_full);\n+      obstack_free (&env_obstack, NULL);\n     }\n   else\n     fatal (\"invalid LTO mode\");"}, {"sha": "5bbb2e31780c5be24c4b4ca92b8c5e860998ab4b", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48cf395bdb30be10a283c3ac4d6217c322f39070/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48cf395bdb30be10a283c3ac4d6217c322f39070/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=48cf395bdb30be10a283c3ac4d6217c322f39070", "patch": "@@ -1,10 +1,21 @@\n+2010-05-07  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto.c (DUMPBASE_SUFFIX): Remove.\n+\t(lto_execute_ltrans): Move functionality to lto-wrapper.c.\n+\tRename to ...\n+\t(lto_write_ltrans_list): ... only output the list of ltrans files.\n+\t(lto_maybe_unlink): Remove.\n+\t(do_whole_program_analysis): Do not execute LTRANS phase\n+\tfrom here.\n+\n 2010-05-06  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* lto-lang.c (lto_handle_option): Add argument kind.\n \n 2010-05-05  Jan Hubicka  <jh@suse.cz>\n \n-\t* lto.c (lto_promote_cross_file_statics): Compute boundary based on refs.\n+\t* lto.c (lto_promote_cross_file_statics): Compute boundary based on\n+\trefs.\n \n 2010-05-05  Jan Hubicka  <jh@suse.cz>\n "}, {"sha": "c83bfb0d41e97f2d0f422567419731b5be82ba52", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 15, "deletions": 186, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48cf395bdb30be10a283c3ac4d6217c322f39070/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48cf395bdb30be10a283c3ac4d6217c322f39070/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=48cf395bdb30be10a283c3ac4d6217c322f39070", "patch": "@@ -973,187 +973,39 @@ lto_wpa_write_files (void)\n   return output_files;\n }\n \n-/* Template of LTRANS dumpbase suffix.  */\n-#define DUMPBASE_SUFFIX\t\".ltrans18446744073709551615\"\n-\n /* Perform local transformations (LTRANS) on the files in the NULL-terminated\n    FILES array.  These should have been written previously by\n    lto_wpa_write_files ().  Transformations are performed via executing\n    COLLECT_GCC for reach file.  */\n \n static void\n-lto_execute_ltrans (char *const *files)\n+lto_write_ltrans_list (char *const *files)\n {\n-  struct pex_obj *pex;\n-  const char *collect_gcc_options, *collect_gcc;\n-  struct obstack env_obstack;\n-  const char **argv;\n-  const char **argv_ptr;\n-  const char *errmsg;\n-  size_t i, j;\n-  int err;\n-  int status;\n   FILE *ltrans_output_list_stream = NULL;\n-  bool seen_dumpbase = false;\n-  char *dumpbase_suffix = NULL;\n-\n-  timevar_push (TV_WHOPR_WPA_LTRANS_EXEC);\n-\n-  /* Get the driver and options.  */\n-  collect_gcc = getenv (\"COLLECT_GCC\");\n-  if (!collect_gcc)\n-    fatal_error (\"environment variable COLLECT_GCC must be set\");\n-\n-  /* Set the CFLAGS environment variable.  */\n-  collect_gcc_options = getenv (\"COLLECT_GCC_OPTIONS\");\n-  if (!collect_gcc_options)\n-    fatal_error (\"environment variable COLLECT_GCC_OPTIONS must be set\");\n-\n-  /* Count arguments.  */\n-  i = 0;\n-  for (j = 0; collect_gcc_options[j] != '\\0'; ++j)\n-    if (collect_gcc_options[j] == '\\'')\n-      ++i;\n-\n-  if (i % 2 != 0)\n-    fatal_error (\"malformed COLLECT_GCC_OPTIONS\");\n-\n-  /* Initalize the arguments for the LTRANS driver.  */\n-  argv = XNEWVEC (const char *, 8 + i / 2);\n-  argv_ptr = argv;\n-  *argv_ptr++ = collect_gcc;\n-  *argv_ptr++ = \"-xlto\";\n-  for (j = 0; collect_gcc_options[j] != '\\0'; ++j)\n-    if (collect_gcc_options[j] == '\\'')\n-      {\n-\tchar *option;\n-\n-\t++j;\n-\ti = j;\n-\twhile (collect_gcc_options[j] != '\\'')\n-\t  ++j;\n-\tobstack_init (&env_obstack);\n-\tobstack_grow (&env_obstack, &collect_gcc_options[i], j - i);\n-\tif (seen_dumpbase)\n-\t  obstack_grow (&env_obstack, DUMPBASE_SUFFIX,\n-\t\t\tsizeof (DUMPBASE_SUFFIX));\n-\telse\n-\t  obstack_1grow (&env_obstack, 0);\n-\toption = XOBFINISH (&env_obstack, char *);\n-\tif (seen_dumpbase)\n-\t  {\n-\t    dumpbase_suffix = option + 7 + j - i;\n-\t    seen_dumpbase = false;\n-\t  }\n-\n-\t/* LTRANS does not need -fwpa nor -fltrans-*.  */\n-\tif (strncmp (option, \"-fwpa\", 5) != 0\n-\t    && strncmp (option, \"-fltrans-\", 9) != 0)\n-\t  {\n-\t    if (strncmp (option, \"-dumpbase\", 9) == 0)\n-\t      seen_dumpbase = true;\n-\t    *argv_ptr++ = option;\n-\t  }\n-      }\n-  *argv_ptr++ = \"-fltrans\";\n+  unsigned i;\n \n   /* Open the LTRANS output list.  */\n-  if (ltrans_output_list)\n-    {\n-      ltrans_output_list_stream = fopen (ltrans_output_list, \"w\");\n-      if (ltrans_output_list_stream == NULL)\n-\terror (\"opening LTRANS output list %s: %m\", ltrans_output_list);\n-    }\n+  if (!ltrans_output_list)\n+    error (\"no LTRANS output filename provided\");\n+\n+  ltrans_output_list_stream = fopen (ltrans_output_list, \"w\");\n+  if (ltrans_output_list_stream == NULL)\n+    error (\"opening LTRANS output list %s: %m\", ltrans_output_list);\n \n   for (i = 0; files[i]; ++i)\n     {\n       size_t len;\n \n-      /* If the file is prefixed with a '*', it means that we do not\n-\t need to re-compile it with LTRANS because it has not been\n-\t modified by WPA.  Skip it from the command line to\n-\t lto_execute_ltrans, but add it to ltrans_output_list_stream\n-\t so it is linked after we are done.  */\n-      if (files[i][0] == '*')\n-\t{\n-\t  size_t len = strlen (files[i]) - 1;\n-\t  if (ltrans_output_list_stream)\n-\t    if (fwrite (&files[i][1], 1, len, ltrans_output_list_stream) < len\n-\t\t|| fwrite (\"\\n\", 1, 1, ltrans_output_list_stream) < 1)\n-\t      error (\"writing to LTRANS output list %s: %m\",\n-\t\t     ltrans_output_list);\n-\t}\n-      else\n-\t{\n-\t  char *output_name;\n-\n-\t  /* Otherwise, add FILES[I] to lto_execute_ltrans command line\n-\t     and add the resulting file to LTRANS output list.  */\n-\n-\t  /* Replace the .o suffix with a .ltrans.o suffix and write\n-\t     the resulting name to the LTRANS output list.  */\n-\t  obstack_init (&env_obstack);\n-\t  obstack_grow (&env_obstack, files[i], strlen (files[i]) - 2);\n-\t  obstack_grow (&env_obstack, \".ltrans.o\", sizeof (\".ltrans.o\"));\n-\t  output_name = XOBFINISH (&env_obstack, char *);\n-\t  if (ltrans_output_list_stream)\n-\t    {\n-\t      len = strlen (output_name);\n-\n-\t      if (fwrite (output_name, 1, len, ltrans_output_list_stream) < len\n-\t\t  || fwrite (\"\\n\", 1, 1, ltrans_output_list_stream) < 1)\n-\t\terror (\"writing to LTRANS output list %s: %m\",\n-\t\t       ltrans_output_list);\n-\t    }\n-\n-\t  argv_ptr[0] = \"-o\";\n-\t  argv_ptr[1] = output_name;\n-\t  argv_ptr[2] = files[i];\n-\t  argv_ptr[3] = NULL;\n-\n-\t  /* Append a sequence number to -dumpbase for LTRANS.  */\n-\t  if (dumpbase_suffix)\n-\t    snprintf (dumpbase_suffix, sizeof (DUMPBASE_SUFFIX) - 7,\n-\t\t      \"%lu\", (unsigned long) i);\n-\n-\t  /* Execute the driver.  */\n-\t  pex = pex_init (0, \"lto1\", NULL);\n-\t  if (pex == NULL)\n-\t    fatal_error (\"pex_init failed: %s\", xstrerror (errno));\n-\n-\t  errmsg = pex_run (pex, PEX_LAST | PEX_SEARCH, argv[0],\n-\t\t\t    CONST_CAST (char **, argv), NULL, NULL, &err);\n-\t  if (errmsg)\n-\t    fatal_error (\"%s: %s\", errmsg, xstrerror (err));\n-\n-\t  if (!pex_get_status (pex, 1, &status))\n-\t    fatal_error (\"can't get program status: %s\", xstrerror (errno));\n-\n-\t  if (status)\n-\t    {\n-\t      if (WIFSIGNALED (status))\n-\t\t{\n-\t\t  int sig = WTERMSIG (status);\n-\t\t  fatal_error (\"%s terminated with signal %d [%s]%s\",\n-\t\t\t       argv[0], sig, strsignal (sig),\n-\t\t\t       WCOREDUMP (status) ? \", core dumped\" : \"\");\n-\t\t}\n-\t      else\n-\t\tfatal_error (\"%s terminated with status %d\", argv[0], status);\n-\t    }\n-\n-\t  pex_free (pex);\n-\t}\n+      len = strlen (files[i]);\n+      if (fwrite (files[i], 1, len, ltrans_output_list_stream) < len\n+\t  || fwrite (\"\\n\", 1, 1, ltrans_output_list_stream) < 1)\n+\terror (\"writing to LTRANS output list %s: %m\",\n+\t       ltrans_output_list);\n     }\n \n   /* Close the LTRANS output list.  */\n-  if (ltrans_output_list_stream && fclose (ltrans_output_list_stream))\n+  if (fclose (ltrans_output_list_stream))\n     error (\"closing LTRANS output list %s: %m\", ltrans_output_list);\n-\n-  obstack_free (&env_obstack, NULL);\n-  free (argv);\n-\n-  timevar_pop (TV_WHOPR_WPA_LTRANS_EXEC);\n }\n \n \n@@ -1616,20 +1468,6 @@ lto_fixup_decls (struct lto_file_decl_data **files)\n   pointer_set_destroy (seen);\n }\n \n-/* Unlink a temporary LTRANS file unless requested otherwise.  */\n-\n-static void\n-lto_maybe_unlink (const char *file)\n-{\n-  if (!getenv (\"WPA_SAVE_LTRANS\"))\n-    {\n-      if (unlink_if_ordinary (file))\n-        error (\"deleting LTRANS input file %s: %m\", file);\n-    }\n-  else\n-    fprintf (stderr, \"[Leaving LTRANS input file %s]\\n\", file);\n-}\n-\n /* Read the options saved from each file in the command line.  Called\n    from lang_hooks.post_options which is called by process_options\n    right before all the options are used to initialize the compiler.\n@@ -1893,7 +1731,6 @@ static void\n do_whole_program_analysis (void)\n {\n   char **output_files;\n-  size_t i;\n \n   /* Note that since we are in WPA mode, materialize_cgraph will not\n      actually read in all the function bodies.  It only materializes\n@@ -1944,15 +1781,7 @@ do_whole_program_analysis (void)\n   if (flag_lto_report)\n     print_lto_report ();\n \n-  lto_execute_ltrans (output_files);\n-\n-  for (i = 0; output_files[i]; ++i)\n-    {\n-      if (output_files[i][0] != '*')\n-\tlto_maybe_unlink (output_files[i]);\n-\n-      free (output_files[i]);\n-    }\n+  lto_write_ltrans_list (output_files);\n \n   XDELETEVEC (output_files);\n }"}]}