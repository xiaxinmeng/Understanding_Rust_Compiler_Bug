{"sha": "ba228239d22c745ed7e152fa211c065dc1c56918", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmEyMjgyMzlkMjJjNzQ1ZWQ3ZTE1MmZhMjExYzA2NWRjMWM1NjkxOA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-12-13T04:11:23Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-12-13T04:11:23Z"}, "message": "c-typeck.c: Fix comment typos.\n\n\t* c-typeck.c: Fix comment typos.\n\t* calls.c: Likewise.\n\t* cfgcleanup.c: Likewise.\n\t* cgraph.h: Likewise.\n\t* dwarfout.c: Likewise.\n\t* emit-rtl.c: Likewise.\n\t* explow.c: Likewise.\n\t* expr.c: Likewise.\n\t* flow.c: Likewise.\n\t* function.c: Likewise.\n\t* gcc.c: Likewise.\n\t* ggc-zone.c: Likewise.\n\t* ifcvt.c: Likewise.\n\t* local-alloc.c: Likewise.\n\t* predict.c: Likewise.\n\t* pretty-print.c: Likewise.\n\t* profile.c: Likewise.\n\t* ra-colorize.c: Likewise.\n\t* sched-vis.c: Likewise.\n\t* stor-layout.c: Likewise.\n\nFrom-SVN: r74594", "tree": {"sha": "3ace7d8aa6d41f25c3ff3840fe7c4e81987b2a1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ace7d8aa6d41f25c3ff3840fe7c4e81987b2a1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba228239d22c745ed7e152fa211c065dc1c56918", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba228239d22c745ed7e152fa211c065dc1c56918", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba228239d22c745ed7e152fa211c065dc1c56918", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba228239d22c745ed7e152fa211c065dc1c56918/comments", "author": null, "committer": null, "parents": [{"sha": "7ecd45764f643c7c99b3100b50879ac69ec80113", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ecd45764f643c7c99b3100b50879ac69ec80113", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ecd45764f643c7c99b3100b50879ac69ec80113"}], "stats": {"total": 54, "additions": 27, "deletions": 27}, "files": [{"sha": "9747a8c064d7b76092aabe18736219bec26d21a6", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -5642,7 +5642,7 @@ output_pending_init_elements (int all)\n \n  retry:\n \n-  /* Look thru the whole pending tree.\n+  /* Look through the whole pending tree.\n      If we find an element that should be output now,\n      output it.  Otherwise, set NEXT to the element\n      that comes first among those still pending.  */"}, {"sha": "6da115c5594944ab0359fd43fe9eb5ef622516eb", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -290,7 +290,7 @@ prepare_call_address (rtx funexp, tree fndecl, rtx *call_fusage,\n     /* Get possible static chain value for nested function in C.  */\n     static_chain_value = lookup_static_chain (fndecl);\n \n-  /* Make a valid memory address and copy constants thru pseudo-regs,\n+  /* Make a valid memory address and copy constants through pseudo-regs,\n      but not for a constant address if -fno-function-cse.  */\n   if (GET_CODE (funexp) != SYMBOL_REF)\n     /* If we are using registers for parameters, force the"}, {"sha": "056a32f4faa51671b66309951232e82f2a2de575", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -174,7 +174,7 @@ try_simplify_condjump (basic_block cbranch_block)\n \n   end = BB_END (jump_block);\n   /* Deleting a block may produce unreachable code warning even when we are\n-     not deleting anything live.  Supress it by moving all the line number\n+     not deleting anything live.  Suppress it by moving all the line number\n      notes out of the block.  */\n   for (insn = BB_HEAD (jump_block); insn != NEXT_INSN (BB_END (jump_block));\n        insn = next)"}, {"sha": "9540eccd937e99ebf195cc96ef6478feb486e5c5", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -75,7 +75,7 @@ struct cgraph_rtl_info GTY(())\n };\n \n \n-/* The cgraph data strutcture.\n+/* The cgraph data structure.\n    Each function decl has assigned cgraph_node listing callees and callers.  */\n \n struct cgraph_node GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\")))\n@@ -122,7 +122,7 @@ struct cgraph_edge GTY(())\n   bool inline_call;\n };\n \n-/* The cgraph_varpool data strutcture.\n+/* The cgraph_varpool data structure.\n    Each static variable decl has assigned cgraph_varpool_node.  */\n \n struct cgraph_varpool_node GTY(())"}, {"sha": "cdc46b7065ffda380334124c697418cdb2f3b9ef", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -2074,7 +2074,7 @@ output_mem_loc_descriptor (rtx rtl)\n \t   which contains the given subreg.  */\n \n \trtl = SUBREG_REG (rtl);\n-\t/* Drop thru.  */\n+\t/* Drop through.  */\n \n       case REG:\n \n@@ -2157,7 +2157,7 @@ output_loc_descriptor (rtx rtl)\n \t   which contains the given subreg.  */\n \n \trtl = SUBREG_REG (rtl);\n-\t/* Drop thru.  */\n+\t/* Drop through.  */\n \n     case REG:\n \tASM_OUTPUT_DWARF_STACK_OP (asm_out_file, OP_REG);"}, {"sha": "f0c2feffb06fa77741ad326be58c21d7c9085b34", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -2596,7 +2596,7 @@ verify_rtx_sharing (rtx orig, rtx insn)\n   return;\n }\n \n-/* Go through all the RTL insn bodies and chec that there is no inexpected\n+/* Go through all the RTL insn bodies and check that there is no unexpected\n    sharing in between the subexpressions.  */\n \n void"}, {"sha": "9e04bd896f971442cbde4bf5bfe2bd10b19afec5", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -444,7 +444,7 @@ memory_address (enum machine_mode mode, rtx x)\n \n   x = convert_memory_address (Pmode, x);\n \n-  /* By passing constant addresses thru registers\n+  /* By passing constant addresses through registers\n      we get a chance to cse them.  */\n   if (! cse_not_expected && CONSTANT_P (x) && CONSTANT_ADDRESS_P (x))\n     x = force_reg (Pmode, x);"}, {"sha": "cdae28c0dfaadb4aa133d14481accb877d9c407f", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -9793,7 +9793,7 @@ do_tablejump (rtx index, enum machine_mode mode, rtx range, rtx table_label,\n   if (mode != Pmode)\n     index = convert_to_mode (Pmode, index, 1);\n \n-  /* Don't let a MEM slip thru, because then INDEX that comes\n+  /* Don't let a MEM slip through, because then INDEX that comes\n      out of PIC_CASE_VECTOR_ADDRESS won't be a valid address,\n      and break_out_memory_refs will go to work on it and mess it up.  */\n #ifdef PIC_CASE_VECTOR_ADDRESS"}, {"sha": "965e9fe630277f66107aeff2843d8e82ed54a908", "filename": "gcc/flow.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -2462,7 +2462,7 @@ mark_set_regs (struct propagate_block_info *pbi, rtx x, rtx insn)\n     case SET:\n       if (GET_CODE (XEXP (x, 1)) == ASM_OPERANDS)\n \tflags |= PROP_ASM_SCAN;\n-      /* Fall thru */\n+      /* Fall through */\n     case CLOBBER:\n       mark_set_1 (pbi, code, SET_DEST (x), cond, insn, flags);\n       return;\n@@ -2497,7 +2497,7 @@ mark_set_regs (struct propagate_block_info *pbi, rtx x, rtx insn)\n \t      mark_set:\n \t\tif (GET_CODE (XEXP (sub, 1)) == ASM_OPERANDS)\n \t\t  flags |= PROP_ASM_SCAN;\n-\t\t/* Fall thru */\n+\t\t/* Fall through */\n \t      case CLOBBER:\n \t      mark_clob:\n \t\tmark_set_1 (pbi, code, SET_DEST (sub), cond, insn, flags);"}, {"sha": "f3c07d2e9ef007a1d7cd986f0cf92b58e94ebbd2", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -6733,7 +6733,7 @@ expand_function_start (tree subr, int parms_have_cleanups)\n \t  tem = decl_function_context (tem);\n \t  if (tem == 0)\n \t    break;\n-\t  /* Chain thru stack frames, assuming pointer to next lexical frame\n+\t  /* Chain through stack frames, assuming pointer to next lexical frame\n \t     is found at the place we always store it.  */\n #ifdef FRAME_GROWS_DOWNWARD\n \t  last_ptr = plus_constant (last_ptr,"}, {"sha": "5832c4852363ad04eb595bdddf4ac4c358731b52", "filename": "gcc/gcc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -2687,7 +2687,7 @@ execute (void)\n         {\n \t  /* verbose_only_flag should act as if the spec was\n \t     executed, so increment execution_count before\n-\t     returning.  Theis prevent spurious warnings about\n+\t     returning.  This prevents spurious warnings about\n \t     unused linker input files, etc.  */\n \t  execution_count++;\n \t  return 0;"}, {"sha": "a709edf5931fc2c7e72f011116feae0b773f6ebb", "filename": "gcc/ggc-zone.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -89,7 +89,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    If we track inter-zone pointers, we can mark single zones at a\n    time.\n    If we have a zone where we guarantee no inter-zone pointers, we\n-   could mark that zone seperately.\n+   could mark that zone separately.\n    The garbage zone should not be marked, and we should return 1 in\n    ggc_set_mark for any object in the garbage zone, which cuts off\n    marking quickly.  */"}, {"sha": "4a13ba2a45b9b701ab29e093f8926670ced49503", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -2962,8 +2962,8 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n   if (HAVE_conditional_execution)\n     {\n       /* In the conditional execution case, we have things easy.  We know\n-\t the condition is reversible.  We don't have to check life info,\n-\t becase we're going to conditionally execute the code anyway.\n+\t the condition is reversible.  We don't have to check life info\n+\t because we're going to conditionally execute the code anyway.\n \t All that's left is making sure the insns involved can actually\n \t be predicated.  */\n "}, {"sha": "09c99a5e8d7e6a479579c8266296b3aacc93a139", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -108,7 +108,7 @@ struct qty\n \n   /* Number of words needed to hold the data in given quantity.\n      This depends on its machine mode.  It is used for these purposes:\n-     1. It is used in computing the relative importances of qtys,\n+     1. It is used in computing the relative importance of qtys,\n \twhich determines the order in which we look for regs for them.\n      2. It is used in rules that prevent tying several registers of\n \tdifferent sizes in a way that is geometrically impossible"}, {"sha": "2f907027fb9fa5543456e0bb5e7deaa3981d333e", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -878,7 +878,7 @@ typedef struct block_info_def\n   /* To keep queue of basic blocks to process.  */\n   basic_block next;\n \n-  /* True if block needs to be visited in prop_freqency.  */\n+  /* True if block needs to be visited in propagate_freq.  */\n   int tovisit:1;\n \n   /* Number of predecessors we need to visit first.  */"}, {"sha": "27a77ea569eaa6be22d6626c811b09493d5b91c0", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -472,7 +472,7 @@ pp_base_last_position_in_text (const pretty_printer *pp)\n }\n \n /* Return the amount of characters PRETTY-PRINTER can accept to\n-   make a full line.  Meaningfull only in line-wrapping mode.  */\n+   make a full line.  Meaningful only in line-wrapping mode.  */\n int\n pp_base_remaining_character_count_for_line (pretty_printer *pp)\n {"}, {"sha": "b7b39a2f5a89be3c9928156b475e449e2dff2035", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -502,7 +502,7 @@ compute_branch_probabilities (void)\n \t}\n       for (e = bb->succ; e; e = e->succ_next)\n \t{\n-\t  /* Function may return twice in the cased the called fucntion is\n+\t  /* Function may return twice in the cased the called function is\n \t     setjmp or calls fork, but we can't represent this by extra\n \t     edge from the entry, since extra edge from the exit is\n \t     already present.  We get negative frequency from the entry"}, {"sha": "fd4660ab9e0a2493d60ccd275e13e35923f9583c", "filename": "gcc/ra-colorize.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fra-colorize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fra-colorize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-colorize.c?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -618,7 +618,7 @@ ok (struct web *target, struct web *source)\n \t{\n \t  /* The main webs do _not_ conflict, only some parts of both.  This\n \t     means, that 4 is possibly true, so we need to check this too.\n-\t     For this we go thru all sub conflicts between T and C, and see if\n+\t     For this we go through all sub conflicts between T and C, and see if\n \t     the target part of C already conflicts with S.  When this is not\n \t     the case we disallow coalescing.  */\n \t  struct sub_conflict *sl;\n@@ -1214,7 +1214,7 @@ calculate_dont_begin (struct web *web, HARD_REG_SET *result)\n \t\t}\n \t    }\n \t  /* The next if() only gets true, if there was no wl->sub at all, in\n-\t     which case we are only making one go thru this loop with W being\n+\t     which case we are only making one go through this loop with W being\n \t     a whole web.  */\n \t  if (!sl)\n \t    break;\n@@ -1433,7 +1433,7 @@ colorize_one_web (struct web *web, int hard)\n \t even if we spill this one here, the situation won't become better\n \t in the next iteration.  It probably will have the same conflicts,\n \t those will have the same colors, and we would come here again, for\n-\t all parts, in which this one gets splitted by the spill.  This\n+\t all parts, in which this one gets split by the spill.  This\n \t can result in endless iteration spilling the same register again and\n \t again.  That's why we try to find a neighbor, which spans more\n \t instructions that ourself, and got a color, and try to spill _that_.\n@@ -1826,7 +1826,7 @@ try_recolor_web (struct web *web)\n \t\t  else if (web2->type == SELECT)\n \t\t    /* This means, that WEB2 once was a part of a coalesced\n \t\t       web, which got spilled in the above colorize_one_web()\n-\t\t       call, and whose parts then got splitted and put back\n+\t\t       call, and whose parts then got split and put back\n \t\t       onto the SELECT stack.  As the cause for that splitting\n \t\t       (the coloring of WEB) was worthless, we should again\n \t\t       coalesce the parts, as they were before.  For now we"}, {"sha": "9174c8bf2ff5100822beb8ed9867f478e3728bd0", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -80,7 +80,7 @@ insn_print_units (rtx insn)\n }\n \n /* MAX_VISUAL_LINES is the maximum number of lines in visualization table\n-   of a basic block.  If more lines are needed, table is splitted to two.\n+   of a basic block.  If more lines are needed, table is split to two.\n    n_visual_lines is the number of lines printed so far for a block.\n    visual_tbl contains the block visualization info.\n    vis_no_unit holds insns in a cycle that are not mapped to any unit.  */"}, {"sha": "e8c7ba4dc9abe2d3bc31c14710668791f6bc1771", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba228239d22c745ed7e152fa211c065dc1c56918/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=ba228239d22c745ed7e152fa211c065dc1c56918", "patch": "@@ -453,7 +453,7 @@ layout_decl (tree decl, unsigned int known_align)\n       else if (DECL_PACKED (decl) && DECL_USER_ALIGN (decl))\n \t/* Don't touch DECL_ALIGN.  For other packed fields, go ahead and\n \t   round up; we'll reduce it again below.  We want packing to\n-\t   supercede USER_ALIGN inherited from the type, but defer to\n+\t   supersede USER_ALIGN inherited from the type, but defer to\n \t   alignment explicitly specified on the field decl.  */;\n       else\n \tdo_type_align (type, decl);"}]}