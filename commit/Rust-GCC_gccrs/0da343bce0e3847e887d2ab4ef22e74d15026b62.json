{"sha": "0da343bce0e3847e887d2ab4ef22e74d15026b62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRhMzQzYmNlMGUzODQ3ZTg4N2QyYWI0ZWYyMmU3NGQxNTAyNmI2Mg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-06-14T12:17:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-06-14T12:17:48Z"}, "message": "[multiple changes]\n\n2016-06-14  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* lib.adb: Minor reformatting.\n\t* sem_util.adb (Is_OK_Volatile_Context): Do\n\tinclude Address in the supported attributes.\n\n2016-06-14  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Case_Expression):\n\tCode cleanup. Finalize any transient controlled\n\tobjects on exit from a case expression alternative.\n\t(Expand_N_If_Expression): Code cleanup.\n\t(Process_Actions): Removed.\n\t(Process_If_Case_Statements): New routine.\n\t(Process_Transient_Object): Change the name of formal Rel_Node to\n\tN and update all occurrences. Update the comment on usage. When\n\tthe type of the context is Boolean, the proper insertion point\n\tfor the finalization call is after the last declaration.\n\n2016-06-14  Ed Schonberg  <schonberg@adacore.com>\n\n\t* lib-xref.ads, lib-xref.adb (Has_Deferred_Reference): new\n\tpredicate to determine whether an entity appears in a context\n\tfor which a Deferred_Reference was created, because it is not\n\tpossible to determine when reference is analyzed whether it\n\tappears in a context in which the entity is modified.\n\t* sem_ch5.adb (Analyze_Statement): Do not emit a useless warning\n\ton assignment for an entity that has a deferred_reference.\n\n2016-06-14  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_res.adb (Resolve_Actuals): Generate a reference to actuals that\n\tcome from source. Previously the reference was generated only if the\n\tcall comes from source but the call may be rewritten by the expander\n\tthus causing the notification of spurious warnings.\n\n2016-06-14  Arnaud Charlet  <charlet@adacore.com>\n\n\t* gnat1drv.adb: Remove further references to AAMP.\n\t* checks.adb (Apply_Scalar_Range_Check): Take\n\tCheck_Float_Overflow info account.\n\t* live.ads, live.adb Added subprogram headers and\n\tstart-of-processing-for comments.\n\t* sem_ch12.adb (Instantiate_Package_Body): Do not suppress\n\tchecks when instantiating runtime units in CodePeer mode.\n\nFrom-SVN: r237432", "tree": {"sha": "f5f86e698416e487e7780f983d356ef6f4c866b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5f86e698416e487e7780f983d356ef6f4c866b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0da343bce0e3847e887d2ab4ef22e74d15026b62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0da343bce0e3847e887d2ab4ef22e74d15026b62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0da343bce0e3847e887d2ab4ef22e74d15026b62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0da343bce0e3847e887d2ab4ef22e74d15026b62/comments", "author": null, "committer": null, "parents": [{"sha": "a5150cb18f6ba057d1c3ab144e12822421fff434", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5150cb18f6ba057d1c3ab144e12822421fff434", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5150cb18f6ba057d1c3ab144e12822421fff434"}], "stats": {"total": 478, "additions": 297, "deletions": 181}, "files": [{"sha": "d2d8fa4df46fa5be7a50264cb3bd8476fba9d515", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0da343bce0e3847e887d2ab4ef22e74d15026b62", "patch": "@@ -1,3 +1,49 @@\n+2016-06-14  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* lib.adb: Minor reformatting.\n+\t* sem_util.adb (Is_OK_Volatile_Context): Do\n+\tinclude Address in the supported attributes.\n+\n+2016-06-14  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Case_Expression):\n+\tCode cleanup. Finalize any transient controlled\n+\tobjects on exit from a case expression alternative.\n+\t(Expand_N_If_Expression): Code cleanup.\n+\t(Process_Actions): Removed.\n+\t(Process_If_Case_Statements): New routine.\n+\t(Process_Transient_Object): Change the name of formal Rel_Node to\n+\tN and update all occurrences. Update the comment on usage. When\n+\tthe type of the context is Boolean, the proper insertion point\n+\tfor the finalization call is after the last declaration.\n+\n+2016-06-14  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* lib-xref.ads, lib-xref.adb (Has_Deferred_Reference): new\n+\tpredicate to determine whether an entity appears in a context\n+\tfor which a Deferred_Reference was created, because it is not\n+\tpossible to determine when reference is analyzed whether it\n+\tappears in a context in which the entity is modified.\n+\t* sem_ch5.adb (Analyze_Statement): Do not emit a useless warning\n+\ton assignment for an entity that has a deferred_reference.\n+\n+2016-06-14  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Actuals): Generate a reference to actuals that\n+\tcome from source. Previously the reference was generated only if the\n+\tcall comes from source but the call may be rewritten by the expander\n+\tthus causing the notification of spurious warnings.\n+\n+2016-06-14  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gnat1drv.adb: Remove further references to AAMP.\n+\t* checks.adb (Apply_Scalar_Range_Check): Take\n+\tCheck_Float_Overflow info account.\n+\t* live.ads, live.adb Added subprogram headers and\n+\tstart-of-processing-for comments.\n+\t* sem_ch12.adb (Instantiate_Package_Body): Do not suppress\n+\tchecks when instantiating runtime units in CodePeer mode.\n+\n 2016-06-14  Arnaud Charlet  <charlet@adacore.com>\n \n \t* exp_ch3.adb (Expand_N_Object_Declaration): Only consider"}, {"sha": "cd8d144f1b8cb188950bcfdddbd0d7f7b2b63356", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=0da343bce0e3847e887d2ab4ef22e74d15026b62", "patch": "@@ -3077,15 +3077,11 @@ package body Checks is\n       --  Floating-point case\n       --  In the floating-point case, we only do range checks if the type is\n       --  constrained. We definitely do NOT want range checks for unconstrained\n-      --  types, since we want to have infinities\n+      --  types, since we want to have infinities, except when\n+      --  Check_Float_Overflow is set.\n \n       elsif Is_Floating_Point_Type (S_Typ) then\n-\n-      --  Normally, we only do range checks if the type is constrained. We do\n-      --  NOT want range checks for unconstrained types, since we want to have\n-      --  infinities.\n-\n-         if Is_Constrained (S_Typ) then\n+         if Is_Constrained (S_Typ) or else Check_Float_Overflow then\n             Enable_Range_Check (Expr);\n          end if;\n "}, {"sha": "a48cdab695dc50b2f196712f83a7ee0348087ad5", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 152, "deletions": 132, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=0da343bce0e3847e887d2ab4ef22e74d15026b62", "patch": "@@ -224,15 +224,19 @@ package body Exp_Ch4 is\n    --  simple entity, and op is a comparison operator, optimizes it into a\n    --  comparison of First and Last.\n \n-   procedure Process_Transient_Object\n-     (Decl     : Node_Id;\n-      Rel_Node : Node_Id);\n-   --  Subsidiary routine to the expansion of expression_with_actions and if\n-   --  expressions. Generate all the necessary code to finalize a transient\n+   procedure Process_If_Case_Statements (N : Node_Id; Stmts : List_Id);\n+   --  Inspect and process statement list Stmt of if or case expression N for\n+   --  transient controlled objects. If such objects are found, the routine\n+   --  generates code to clean them up when the context of the expression is\n+   --  evaluated or elaborated.\n+\n+   procedure Process_Transient_Object (Decl : Node_Id; N : Node_Id);\n+   --  Subsidiary routine to the expansion of expression_with_actions, if and\n+   --  case expressions. Generate all necessary code to finalize a transient\n    --  controlled object when the enclosing context is elaborated or evaluated.\n    --  Decl denotes the declaration of the transient controlled object which is\n-   --  usually the result of a controlled function call. Rel_Node denotes the\n-   --  context, either an expression_with_actions or an if expression.\n+   --  usually the result of a controlled function call. N denotes the related\n+   --  expression_with_actions, if expression, or case expression.\n \n    procedure Rewrite_Comparison (N : Node_Id);\n    --  If N is the node for a comparison whose outcome can be determined at\n@@ -4658,19 +4662,23 @@ package body Exp_Ch4 is\n    ------------------------------\n \n    procedure Expand_N_Case_Expression (N : Node_Id) is\n-      Loc                  : constant Source_Ptr := Sloc (N);\n-      Typ                  : constant Entity_Id  := Etype (N);\n-      Acts                 : List_Id;\n-      Alt                  : Node_Id;\n-      Case_Stmt            : Node_Id;\n-      Decl                 : Node_Id;\n-      Expr                 : Node_Id;\n-      In_Predicate         : Boolean := False;\n+      Loc        : constant Source_Ptr := Sloc (N);\n+      Par        : constant Node_Id    := Parent (N);\n+      Typ        : constant Entity_Id  := Etype (N);\n+      Acts       : List_Id;\n+      Alt        : Node_Id;\n+      Case_Stmt  : Node_Id;\n+      Decl       : Node_Id;\n+      Expr       : Node_Id;\n+      Target     : Entity_Id;\n+      Target_Typ : Entity_Id;\n+\n+      In_Predicate : Boolean := False;\n+      --  Flag set when the case expression appears within a predicate\n+\n       Optimize_Return_Stmt : Boolean := False;\n-      Par                  : Node_Id;\n-      Ptr_Typ              : Entity_Id;\n-      Target               : Entity_Id;\n-      Target_Typ           : Entity_Id;\n+      --  Flag set when the case expression can be optimized in the context of\n+      --  a simple return statement.\n \n    begin\n       --  Check for MINIMIZED/ELIMINATED overflow mode\n@@ -4695,14 +4703,14 @@ package body Exp_Ch4 is\n          end if;\n       end if;\n \n-      --  We expand\n+      --  When the type of the case expression is elementary, expand\n \n-      --    case X is when A => AX, when B => BX ...\n+      --    (case X is when A => AX, when B => BX ...)\n \n-      --  to\n+      --  into\n \n       --    do\n-      --       Target : typ;\n+      --       Target : Typ;\n       --       case X is\n       --          when A =>\n       --             Target := AX;\n@@ -4712,33 +4720,10 @@ package body Exp_Ch4 is\n       --       end case;\n       --    in Target end;\n \n-      --  Except when the case expression appears as part of a simple return\n-      --  statement, returning an elementary type, where we expand\n-\n-      --    return (case X is when A => AX, when B => BX ...)\n-\n-      --  to\n-\n-      --    case X is\n-      --       when A =>\n-      --          return AX;\n-      --       when B =>\n-      --          return BX;\n-      --       ...\n-      --    end case;\n-\n-      --    Note that this expansion is also triggered for expression functions\n-      --    containing a single case expression since these functions are\n-      --    expanded as above.\n-\n-      --  However, this expansion is wrong for limited types, and also wrong\n-      --  for unconstrained types (since the bounds may not be the same in all\n-      --  branches). Furthermore it involves an extra copy for large objects.\n-      --  So we take care of this by using the following modified expansion for\n-      --  non-elementary types:\n+      --  In all other cases expand into\n \n       --    do\n-      --       type Ptr_Typ is access all typ;\n+      --       type Ptr_Typ is access all Typ;\n       --       Target : Ptr_Typ;\n       --       case X is\n       --          when A =>\n@@ -4749,6 +4734,20 @@ package body Exp_Ch4 is\n       --       end case;\n       --    in Target.all end;\n \n+      --  This approach avoids extra copies of potentially large objects. It\n+      --  also allows handling of values of limited or unconstrained types.\n+\n+      --  Small optimization: when the case expression appears in the context\n+      --  of a simple return statement, expand into\n+\n+      --    case X is\n+      --       when A =>\n+      --          return AX;\n+      --       when B =>\n+      --          return BX;\n+      --       ...\n+      --    end case;\n+\n       Case_Stmt :=\n         Make_Case_Statement (Loc,\n           Expression   => Expression (N),\n@@ -4768,43 +4767,50 @@ package body Exp_Ch4 is\n          Target_Typ := Typ;\n \n          --  ??? Do not perform the optimization when the return statement is\n-         --  within a predicate function as this causes supurious errors. A\n-         --  possible mismatch in handling this case somewhere else in semantic\n-         --  analysis?\n+         --  within a predicate function as this causes supurious errors. Could\n+         --  this be a possible mismatch in handling this case somewhere else\n+         --  in semantic analysis?\n \n-         if not In_Predicate\n-           and then Nkind (Parent (N)) = N_Simple_Return_Statement\n-         then\n-            Optimize_Return_Stmt := True;\n-         end if;\n+         Optimize_Return_Stmt :=\n+           Nkind (Par) = N_Simple_Return_Statement and then not In_Predicate;\n+\n+      --  Otherwise create an access type to handle the general case using\n+      --  'Unrestricted_Access.\n+\n+      --  Generate:\n+      --    type Ptr_Typ is access all Typ;\n \n       else\n-         Ptr_Typ := Make_Temporary (Loc, 'P');\n+         Target_Typ := Make_Temporary (Loc, 'P');\n+\n          Append_To (Acts,\n            Make_Full_Type_Declaration (Loc,\n-             Defining_Identifier => Ptr_Typ,\n+             Defining_Identifier => Target_Typ,\n              Type_Definition     =>\n                Make_Access_To_Object_Definition (Loc,\n                  All_Present        => True,\n                  Subtype_Indication => New_Occurrence_Of (Typ, Loc))));\n-         Target_Typ := Ptr_Typ;\n       end if;\n \n+      --  Create the declaration of the target which captures the value of the\n+      --  expression.\n+\n+      --  Generate:\n+      --    Target : [Ptr_]Typ;\n+\n       if not Optimize_Return_Stmt then\n          Target := Make_Temporary (Loc, 'T');\n \n-         --  Create declaration for target of expression, and indicate that it\n-         --  does not require initialization.\n-\n          Decl :=\n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Target,\n              Object_Definition   => New_Occurrence_Of (Target_Typ, Loc));\n          Set_No_Initialization (Decl);\n+\n          Append_To (Acts, Decl);\n       end if;\n \n-      --  Now process the alternatives\n+      --  Process the alternatives\n \n       Alt := First (Alternatives (N));\n       while Present (Alt) loop\n@@ -4814,8 +4820,12 @@ package body Exp_Ch4 is\n             Stmts    : List_Id;\n \n          begin\n-            --  As described above, take Unrestricted_Access for case of non-\n-            --  scalar types, to avoid big copies, and special cases.\n+            --  Take the unrestricted access of the expression value for non-\n+            --  scalar types. This approach avoids big copies and covers the\n+            --  limited and unconstrained cases.\n+\n+            --  Generate:\n+            --    AX'Unrestricted_Access\n \n             if not Is_Elementary_Type (Typ) then\n                Alt_Expr :=\n@@ -4824,10 +4834,17 @@ package body Exp_Ch4 is\n                    Attribute_Name => Name_Unrestricted_Access);\n             end if;\n \n+            --  Generate:\n+            --    return AX['Unrestricted_Access];\n+\n             if Optimize_Return_Stmt then\n                Stmts := New_List (\n                  Make_Simple_Return_Statement (Alt_Loc,\n                    Expression => Alt_Expr));\n+\n+            --  Generate:\n+            --    Target := AX['Unrestricted_Access];\n+\n             else\n                Stmts := New_List (\n                  Make_Assignment_Statement (Alt_Loc,\n@@ -4844,6 +4861,16 @@ package body Exp_Ch4 is\n                Prepend_List (Actions (Alt), Stmts);\n             end if;\n \n+            --  Finalize any transient controlled objects on exit from the\n+            --  alternative. This is done only in the return optimization case\n+            --  because otherwise the case expression is converted into an\n+            --  expression with actions which already contains this form of\n+            --  processing.\n+\n+            if Optimize_Return_Stmt then\n+               Process_If_Case_Statements (N, Stmts);\n+            end if;\n+\n             Append_To\n               (Alternatives (Case_Stmt),\n                Make_Case_Statement_Alternative (Sloc (Alt),\n@@ -4854,33 +4881,38 @@ package body Exp_Ch4 is\n          Next (Alt);\n       end loop;\n \n-      --  Rewrite parent return statement as a case statement if possible\n+      --  Rewrite the parent return statement as a case statement\n \n       if Optimize_Return_Stmt then\n-         Par := Parent (N);\n          Rewrite (Par, Case_Stmt);\n          Analyze (Par);\n-         return;\n-      end if;\n-\n-      Append_To (Acts, Case_Stmt);\n \n-      --  Construct and return final expression with actions\n+      --  Otherwise convert the case expression into an expression with actions\n \n-      if Is_Elementary_Type (Typ) then\n-         Expr := New_Occurrence_Of (Target, Loc);\n       else\n-         Expr :=\n-           Make_Explicit_Dereference (Loc,\n-             Prefix => New_Occurrence_Of (Target, Loc));\n-      end if;\n+         Append_To (Acts, Case_Stmt);\n \n-      Rewrite (N,\n-        Make_Expression_With_Actions (Loc,\n-          Expression => Expr,\n-          Actions    => Acts));\n+         if Is_Elementary_Type (Typ) then\n+            Expr := New_Occurrence_Of (Target, Loc);\n \n-      Analyze_And_Resolve (N, Typ);\n+         else\n+            Expr :=\n+              Make_Explicit_Dereference (Loc,\n+                Prefix => New_Occurrence_Of (Target, Loc));\n+         end if;\n+\n+         --  Generate:\n+         --    do\n+         --       ...\n+         --    in Target[.all] end;\n+\n+         Rewrite (N,\n+           Make_Expression_With_Actions (Loc,\n+             Expression => Expr,\n+             Actions    => Acts));\n+\n+         Analyze_And_Resolve (N, Typ);\n+      end if;\n    end Expand_N_Case_Expression;\n \n    -----------------------------------\n@@ -5070,39 +5102,11 @@ package body Exp_Ch4 is\n    --  Deal with limited types and condition actions\n \n    procedure Expand_N_If_Expression (N : Node_Id) is\n-      procedure Process_Actions (Actions : List_Id);\n-      --  Inspect and process a single action list of an if expression for\n-      --  transient controlled objects. If such objects are found, the routine\n-      --  generates code to clean them up when the context of the expression is\n-      --  evaluated or elaborated.\n-\n-      ---------------------\n-      -- Process_Actions --\n-      ---------------------\n-\n-      procedure Process_Actions (Actions : List_Id) is\n-         Act : Node_Id;\n-\n-      begin\n-         Act := First (Actions);\n-         while Present (Act) loop\n-            if Nkind (Act) = N_Object_Declaration\n-              and then Is_Finalizable_Transient (Act, N)\n-            then\n-               Process_Transient_Object (Act, N);\n-            end if;\n-\n-            Next (Act);\n-         end loop;\n-      end Process_Actions;\n-\n-      --  Local variables\n-\n-      Loc    : constant Source_Ptr := Sloc (N);\n-      Cond   : constant Node_Id    := First (Expressions (N));\n-      Thenx  : constant Node_Id    := Next (Cond);\n-      Elsex  : constant Node_Id    := Next (Thenx);\n-      Typ    : constant Entity_Id  := Etype (N);\n+      Cond  : constant Node_Id    := First (Expressions (N));\n+      Loc   : constant Source_Ptr := Sloc (N);\n+      Thenx : constant Node_Id    := Next (Cond);\n+      Elsex : constant Node_Id    := Next (Thenx);\n+      Typ   : constant Entity_Id  := Etype (N);\n \n       Actions : List_Id;\n       Cnn     : Entity_Id;\n@@ -5112,8 +5116,6 @@ package body Exp_Ch4 is\n       New_N   : Node_Id;\n       Ptr_Typ : Entity_Id;\n \n-   --  Start of processing for Expand_N_If_Expression\n-\n    begin\n       --  Check for MINIMIZED/ELIMINATED overflow mode\n \n@@ -5134,8 +5136,8 @@ package body Exp_Ch4 is\n       if Compile_Time_Known_Value (Cond) then\n          declare\n             function Fold_Known_Value (Cond : Node_Id) return Boolean;\n-            --  Fold at compile time. Assumes condition known.\n-            --  Return True if folding occurred, meaning we're done.\n+            --  Fold at compile time. Assumes condition known. Return True if\n+            --  folding occurred, meaning we're done.\n \n             ----------------------\n             -- Fold_Known_Value --\n@@ -5213,8 +5215,8 @@ package body Exp_Ch4 is\n          --  of actions. These temporaries need to be finalized after the if\n          --  expression is evaluated.\n \n-         Process_Actions (Then_Actions (N));\n-         Process_Actions (Else_Actions (N));\n+         Process_If_Case_Statements (N, Then_Actions (N));\n+         Process_If_Case_Statements (N, Else_Actions (N));\n \n          --  Generate:\n          --    type Ann is access all Typ;\n@@ -12894,24 +12896,42 @@ package body Exp_Ch4 is\n       return;\n    end Optimize_Length_Comparison;\n \n+   --------------------------------\n+   -- Process_If_Case_Statements --\n+   --------------------------------\n+\n+   procedure Process_If_Case_Statements (N : Node_Id; Stmts : List_Id) is\n+      Decl : Node_Id;\n+\n+   begin\n+      Decl := First (Stmts);\n+      while Present (Decl) loop\n+         if Nkind (Decl) = N_Object_Declaration\n+           and then Is_Finalizable_Transient (Decl, N)\n+         then\n+            Process_Transient_Object (Decl, N);\n+         end if;\n+\n+         Next (Decl);\n+      end loop;\n+   end Process_If_Case_Statements;\n+\n    ------------------------------\n    -- Process_Transient_Object --\n    ------------------------------\n \n-   procedure Process_Transient_Object\n-     (Decl     : Node_Id;\n-      Rel_Node : Node_Id)\n-   is\n-      Loc         : constant Source_Ptr := Sloc (Decl);\n-      Obj_Id      : constant Entity_Id  := Defining_Identifier (Decl);\n-      Obj_Typ     : constant Node_Id    := Etype (Obj_Id);\n+   procedure Process_Transient_Object (Decl : Node_Id; N : Node_Id) is\n+      Loc     : constant Source_Ptr := Sloc (Decl);\n+      Obj_Id  : constant Entity_Id  := Defining_Identifier (Decl);\n+      Obj_Typ : constant Node_Id    := Etype (Obj_Id);\n+\n       Desig_Typ   : Entity_Id;\n       Expr        : Node_Id;\n       Hook_Id     : Entity_Id;\n       Hook_Insert : Node_Id;\n       Ptr_Id      : Entity_Id;\n \n-      Hook_Context : constant Node_Id := Find_Hook_Context (Rel_Node);\n+      Hook_Context : constant Node_Id := Find_Hook_Context (N);\n       --  The node on which to insert the hook as an action. This is usually\n       --  the innermost enclosing non-transient construct.\n \n@@ -12920,8 +12940,8 @@ package body Exp_Ch4 is\n       --  transient controlled object.\n \n    begin\n-      if Is_Boolean_Type (Etype (Rel_Node)) then\n-         Fin_Context := Last (Actions (Rel_Node));\n+      if Is_Boolean_Type (Etype (N)) then\n+         Fin_Context := Last (List_Containing (Decl));\n       else\n          Fin_Context := Hook_Context;\n       end if;"}, {"sha": "7089c8bc088be430fa9875a9b938828729ca0273", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=0da343bce0e3847e887d2ab4ef22e74d15026b62", "patch": "@@ -634,11 +634,9 @@ procedure Gnat1drv is\n       if Debug_Flag_Dot_LL then\n          Back_End_Handles_Limited_Types := True;\n \n-      --  If no debug flag, usage off for AAMP, SCIL cases\n+      --  If no debug flag, usage off for SCIL cases\n \n-      elsif AAMP_On_Target\n-        or else Generate_SCIL\n-      then\n+      elsif Generate_SCIL then\n          Back_End_Handles_Limited_Types := False;\n \n       --  Otherwise normal gcc back end, for now still turn flag off by\n@@ -667,20 +665,16 @@ procedure Gnat1drv is\n          --  back end some day, it would not be true for this test, but it\n          --  would be non-GCC, so this is a bit troublesome ???\n \n-         Front_End_Inlining := AAMP_On_Target or Generate_C_Code;\n+         Front_End_Inlining := Generate_C_Code;\n       end if;\n \n       --  Set back-end inlining indication\n \n       Back_End_Inlining :=\n \n-        --  No back-end inlining available on AAMP\n-\n-        not AAMP_On_Target\n-\n         --  No back-end inlining available on C generation\n \n-        and then not Generate_C_Code\n+        not Generate_C_Code\n \n         --  No back-end inlining in GNATprove mode, since it just confuses\n         --  the formal verification process."}, {"sha": "bff6d25b7c80a97751c41dbfa3ea45436c61b8d9", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=0da343bce0e3847e887d2ab4ef22e74d15026b62", "patch": "@@ -1218,6 +1218,21 @@ package body Lib.Xref is\n       return E;\n    end Get_Key;\n \n+   ----------------------------\n+   -- Has_Deferred_Reference --\n+   ----------------------------\n+\n+   function Has_Deferred_Reference (Ent : Entity_Id) return Boolean is\n+   begin\n+      for J in Deferred_References.First .. Deferred_References.Last loop\n+         if Deferred_References.Table (J).E = Ent then\n+            return True;\n+         end if;\n+      end loop;\n+\n+      return False;\n+   end Has_Deferred_Reference;\n+\n    ----------\n    -- Hash --\n    ----------"}, {"sha": "40950085a6c89635d3e00fcc2923325c5c782fe9", "filename": "gcc/ada/lib-xref.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Flib-xref.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Flib-xref.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.ads?ref=0da343bce0e3847e887d2ab4ef22e74d15026b62", "patch": "@@ -613,6 +613,11 @@ package Lib.Xref is\n    procedure Process_Deferred_References;\n    --  This procedure is called from Frontend to process these table entries\n \n+   function Has_Deferred_Reference (Ent : Entity_Id) return Boolean;\n+   --  This function determines whether an entity has a pending reference, in\n+   --  order to suppress premature warnings about useless assignments. See\n+   --  comments in Analyze_Assignment in sem-ch5.adb.\n+\n    -----------------------------\n    -- SPARK Xrefs Information --\n    -----------------------------"}, {"sha": "b711c21f59236202f1e48169ad54b00253880cbd", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=0da343bce0e3847e887d2ab4ef22e74d15026b62", "patch": "@@ -70,10 +70,12 @@ package body Lib is\n      (S                : Source_Ptr;\n       Unwind_Instances : Boolean;\n       Unwind_Subunits  : Boolean) return Unit_Number_Type;\n-   --  Common code for Get_Code_Unit (get unit of instantiation for\n-   --  location) Get_Source_Unit (get unit of template for location) and\n-   --  Get_Top_Level_Code_Unit (same as Get_Code_Unit but not stopping at\n-   --  subunits).\n+   --  Common processing for routines Get_Code_Unit, Get_Source_Unit, and\n+   --  Get_Top_Level_Code_Unit. Unwind_Instances is True when the unit for the\n+   --  top-level instantiation should be returned instead of the unit for the\n+   --  template, in the case of an instantiation. Unwind_Subunits is True when\n+   --  the corresponding top-level unit should be returned instead of a\n+   --  subunit, in the case of a subunit.\n \n    --------------------------------------------\n    -- Access Functions for Unit Table Fields --\n@@ -635,8 +637,11 @@ package body Lib is\n \n    function Get_Code_Unit (S : Source_Ptr) return Unit_Number_Type is\n    begin\n-      return Get_Code_Or_Source_Unit (Top_Level_Location (S),\n-        Unwind_Instances => False, Unwind_Subunits => False);\n+      return\n+        Get_Code_Or_Source_Unit\n+          (Top_Level_Location (S),\n+           Unwind_Instances => False,\n+           Unwind_Subunits  => False);\n    end Get_Code_Unit;\n \n    function Get_Code_Unit (N : Node_Or_Entity_Id) return Unit_Number_Type is\n@@ -652,7 +657,6 @@ package body Lib is\n    begin\n       if N <= Compilation_Switches.Last then\n          return Compilation_Switches.Table (N);\n-\n       else\n          return null;\n       end if;\n@@ -711,8 +715,9 @@ package body Lib is\n \n    function Get_Source_Unit (S : Source_Ptr) return Unit_Number_Type is\n    begin\n-      return Get_Code_Or_Source_Unit (S,\n-        Unwind_Instances => True, Unwind_Subunits => False);\n+      return\n+        Get_Code_Or_Source_Unit\n+          (S, Unwind_Instances => True, Unwind_Subunits => False);\n    end Get_Source_Unit;\n \n    function Get_Source_Unit (N : Node_Or_Entity_Id) return Unit_Number_Type is\n@@ -726,8 +731,11 @@ package body Lib is\n \n    function Get_Top_Level_Code_Unit (S : Source_Ptr) return Unit_Number_Type is\n    begin\n-      return Get_Code_Or_Source_Unit (Top_Level_Location (S),\n-        Unwind_Instances => False, Unwind_Subunits => True);\n+      return\n+        Get_Code_Or_Source_Unit\n+          (Top_Level_Location (S),\n+           Unwind_Instances => False,\n+           Unwind_Subunits  => True);\n    end Get_Top_Level_Code_Unit;\n \n    function Get_Top_Level_Code_Unit"}, {"sha": "4a75b9884c6b7cf14d22c9dc95fcb2bb446f1e07", "filename": "gcc/ada/live.adb", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Flive.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Flive.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flive.adb?ref=0da343bce0e3847e887d2ab4ef22e74d15026b62", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2000-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2000-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,10 +36,10 @@ package body Live is\n \n    --  Name_Set\n \n-   --  The Name_Set type is used to store the temporary mark bits\n-   --  used by the garbage collection of entities. Using a separate\n-   --  array prevents using up any valuable per-node space and possibly\n-   --  results in better locality and cache usage.\n+   --  The Name_Set type is used to store the temporary mark bits used by the\n+   --  garbage collection of entities. Using a separate array prevents using up\n+   --  any valuable per-node space and possibly results in better locality and\n+   --  cache usage.\n \n    type Name_Set is array (Node_Id range <>) of Boolean;\n    pragma Pack (Name_Set);\n@@ -66,14 +66,13 @@ package body Live is\n    --  The Mark phase is split into two phases:\n \n    procedure Init_Marked (Root : Node_Id; Marks : out Name_Set);\n-   --  For all subprograms, reset Is_Public flag if a pragma Eliminate\n-   --  applies to the entity, and set the Marked flag to Is_Public\n+   --  For all subprograms, reset Is_Public flag if a pragma Eliminate applies\n+   --  to the entity, and set the Marked flag to Is_Public.\n \n    procedure Trace_Marked (Root : Node_Id; Marks : in out Name_Set);\n-   --  Traverse the tree skipping any unmarked subprogram bodies.\n-   --  All visited entities are marked, as well as entities denoted\n-   --  by a visited identifier or operator. When an entity is first\n-   --  marked it is traced as well.\n+   --  Traverse the tree skipping any unmarked subprogram bodies. All visited\n+   --  entities are marked, as well as entities denoted by a visited identifier\n+   --  or operator. When an entity is first marked it is traced as well.\n \n    --  Local functions\n \n@@ -137,6 +136,10 @@ package body Live is\n       function Process (N : Node_Id) return Traverse_Result;\n       procedure Traverse is new Traverse_Proc (Process);\n \n+      -------------\n+      -- Process --\n+      -------------\n+\n       function Process (N : Node_Id) return Traverse_Result is\n       begin\n          case Nkind (N) is\n@@ -233,6 +236,10 @@ package body Live is\n       function Process (N : Node_Id) return Traverse_Result;\n       procedure Traverse is new Traverse_Proc (Process);\n \n+      -------------\n+      -- Process --\n+      -------------\n+\n       function Process (N : Node_Id) return Traverse_Result is\n       begin\n          case Nkind (N) is\n@@ -263,6 +270,8 @@ package body Live is\n          return OK;\n       end Process;\n \n+   --  Start of processing for Sweep\n+\n    begin\n       Traverse (Root);\n    end Sweep;\n@@ -277,6 +286,10 @@ package body Live is\n       procedure Process (N : Node_Id);\n       procedure Traverse is new Traverse_Proc (Process);\n \n+      -------------\n+      -- Process --\n+      -------------\n+\n       procedure Process (N : Node_Id) is\n          Result : Traverse_Result;\n          pragma Warnings (Off, Result);"}, {"sha": "535d0e4c561b966a6ff07a4c4655a837a8c2e09c", "filename": "gcc/ada/live.ads", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Flive.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Flive.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flive.ads?ref=0da343bce0e3847e887d2ab4ef22e74d15026b62", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2000-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -23,14 +23,14 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package implements a compiler phase that determines the set\n---  of live entities. For now entities are considered live when they\n---  have at least one execution time reference.\n+--  This package implements a compiler phase that determines the set of live\n+--  entities. For now entities are considered live when they have at least one\n+--  execution time reference.\n \n package Live is\n \n    procedure Collect_Garbage_Entities;\n-   --  Eliminate unreachable entities using a mark-and-sweep from\n-   --  the set of root entities, i.e. those having Is_Public set.\n+   --  Eliminate unreachable entities using a mark-and-sweep from the set of\n+   --  root entities, i.e. those having Is_Public set.\n \n end Live;"}, {"sha": "ac0ba4d86d95190de830efcdea3e1ec6f3890183", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=0da343bce0e3847e887d2ab4ef22e74d15026b62", "patch": "@@ -11001,8 +11001,12 @@ package body Sem_Ch12 is\n             --  Note that we do NOT apply this criterion to children of GNAT\n             --  The latter units must suppress checks explicitly if needed.\n \n-            if Is_Predefined_File_Name\n-                 (Unit_File_Name (Get_Source_Unit (Gen_Decl)))\n+            --  We also do not suppress checks in CodePeer mode where we are\n+            --  interested in finding possible runtime errors.\n+\n+            if not CodePeer_Mode\n+              and then Is_Predefined_File_Name\n+                         (Unit_File_Name (Get_Source_Unit (Gen_Decl)))\n             then\n                Analyze (Act_Body, Suppress => All_Checks);\n             else"}, {"sha": "8e9e2b6d4bf818c45e04fe7de6bfe073ca8d95e4", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=0da343bce0e3847e887d2ab4ef22e74d15026b62", "patch": "@@ -830,10 +830,24 @@ package body Sem_Ch5 is\n                --  warnings when an assignment is rewritten as another\n                --  assignment, and gets tied up with itself.\n \n+               --  There may have been a previous reference to a component of\n+               --  the variable, which in general removes the Last_Assignment\n+               --  field of the variable to indicate a relevant use of the\n+               --  previous assignment. However, if the assignment is to a\n+               --  subcomponent the reference may not have registered, because\n+               --  it is not possible to determine whether the context is an\n+               --  assignment. In those cases we generate a Deferred_Reference,\n+               --  to be used at the end of compilation to generate the right\n+               --  kind of reference, and we suppress a potential warning for\n+               --  a useless assignment, which might be premature. This may\n+               --  lose a warning in rare cases, but seems preferable to a\n+               --  misleading warning.\n+\n                if Warn_On_Modified_Unread\n                  and then Is_Assignable (Ent)\n                  and then Comes_From_Source (N)\n                  and then In_Extended_Main_Source_Unit (Ent)\n+                 and then not Has_Deferred_Reference (Ent)\n                then\n                   Warn_On_Useless_Assignment (Ent, N);\n                end if;"}, {"sha": "aadf594114f4f0c9de0891bcffefb9dc6cc98038", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=0da343bce0e3847e887d2ab4ef22e74d15026b62", "patch": "@@ -3704,7 +3704,7 @@ package body Sem_Res is\n \n          if Present (A)\n            and then Is_Entity_Name (A)\n-           and then Comes_From_Source (N)\n+           and then Comes_From_Source (A)\n          then\n             Orig_A := Entity (A);\n "}, {"sha": "5dbaccd522b0581870e76fc5d4ec7f4b7535ea2b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da343bce0e3847e887d2ab4ef22e74d15026b62/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=0da343bce0e3847e887d2ab4ef22e74d15026b62", "patch": "@@ -13643,7 +13643,8 @@ package body Sem_Util is\n \n       elsif Nkind (Context) = N_Attribute_Reference\n         and then Prefix (Context) = Obj_Ref\n-        and then Nam_In (Attribute_Name (Context), Name_Alignment,\n+        and then Nam_In (Attribute_Name (Context), Name_Address,\n+                                                   Name_Alignment,\n                                                    Name_Component_Size,\n                                                    Name_First_Bit,\n                                                    Name_Last_Bit,"}]}