{"sha": "a185856a06e7b26a06229563b2b01b92e6a4589b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE4NTg1NmEwNmU3YjI2YTA2MjI5NTYzYjJiMDFiOTJlNmE0NTg5Yg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2014-06-26T09:16:11Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2014-06-26T09:16:11Z"}, "message": "Make a collect-utils library for use by tools like collect2 and lto-wrapper.\n\n\t* Makefile.in (ALL_HOST_BACKEND_OBJS): Add collect-utils.o.\n\t(lto-wrapper$(exeext)): Link with collect-utils.o.\n\t* collect-utils.c: New file.\n\t* collect-utils.h: New file.\n\t* lto-wrapper.c: Include \"collect-utils.h\".\n\t(args_name): Delete variable.\n\t(tool_name): New variable.\n\t(tool_cleanup): New function.\n\t(maybe_unlink): Renamed from maybe_unlink_file.  All callers changed.\n\t(lto_wrapper_cleanup, fatal_signal, collect_execute, collect_wait,\n\tfork_execute): Remove functions.\n\nFrom-SVN: r212018", "tree": {"sha": "7149ab9414fb61c620960a84164a685ca78e72d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7149ab9414fb61c620960a84164a685ca78e72d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a185856a06e7b26a06229563b2b01b92e6a4589b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a185856a06e7b26a06229563b2b01b92e6a4589b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a185856a06e7b26a06229563b2b01b92e6a4589b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a185856a06e7b26a06229563b2b01b92e6a4589b/comments", "author": null, "committer": null, "parents": [{"sha": "53d51ddb7dde27cd60328b795321d04ee9ab51fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53d51ddb7dde27cd60328b795321d04ee9ab51fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53d51ddb7dde27cd60328b795321d04ee9ab51fb"}], "stats": {"total": 454, "additions": 298, "deletions": 156}, "files": [{"sha": "2e1ff3fa71d9f51fb0edf4f370fbea143451f7d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a185856a06e7b26a06229563b2b01b92e6a4589b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a185856a06e7b26a06229563b2b01b92e6a4589b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a185856a06e7b26a06229563b2b01b92e6a4589b", "patch": "@@ -1,3 +1,17 @@\n+2014-06-26  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+        * Makefile.in (ALL_HOST_BACKEND_OBJS): Add collect-utils.o.\n+        (lto-wrapper$(exeext)): Link with collect-utils.o.\n+        * collect-utils.c: New file.\n+        * collect-utils.h: New file.\n+        * lto-wrapper.c: Include \"collect-utils.h\".\n+        (args_name): Delete variable.\n+        (tool_name): New variable.\n+        (tool_cleanup): New function.\n+        (maybe_unlink): Renamed from maybe_unlink_file.  All callers changed.\n+        (lto_wrapper_cleanup, fatal_signal, collect_execute, collect_wait,\n+        fork_execute): Remove functions.\n+\n 2014-06-26  Nick Clifton  <nickc@redhat.com>\n \n \t* config/frv/frv.c (frv_in_small_data_p): Remove redundant assert."}, {"sha": "51b4c292bb896d4211e14a68998c4269ee472169", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a185856a06e7b26a06229563b2b01b92e6a4589b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a185856a06e7b26a06229563b2b01b92e6a4589b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=a185856a06e7b26a06229563b2b01b92e6a4589b", "patch": "@@ -1491,7 +1491,7 @@ ALL_HOST_FRONTEND_OBJS = $(foreach v,$(CONFIG_LANGUAGES),$($(v)_OBJS))\n ALL_HOST_BACKEND_OBJS = $(GCC_OBJS) $(OBJS) $(OBJS-libcommon) \\\n   $(OBJS-libcommon-target) @TREEBROWSER@ main.o c-family/cppspec.o \\\n   $(COLLECT2_OBJS) $(EXTRA_GCC_OBJS) $(GCOV_OBJS) $(GCOV_DUMP_OBJS) \\\n-  lto-wrapper.o\n+  lto-wrapper.o collect-utils.o\n \n # This lists all host object files, whether they are included in this\n # compilation or not.\n@@ -1910,9 +1910,10 @@ collect2$(exeext): $(COLLECT2_OBJS) $(LIBDEPS)\n CFLAGS-collect2.o += -DTARGET_MACHINE=\\\"$(target_noncanonical)\\\" \\\n \t@TARGET_SYSTEM_ROOT_DEFINE@\n \n-lto-wrapper$(exeext): lto-wrapper.o ggc-none.o libcommon-target.a $(LIBDEPS)\n+LTO_WRAPPER_OBJS = lto-wrapper.o collect-utils.o ggc-none.o\n+lto-wrapper$(exeext): $(LTO_WRAPPER_OBJS) libcommon-target.a $(LIBDEPS)\n \t+$(LINKER) $(ALL_COMPILERFLAGS) $(LDFLAGS) -o T$@ \\\n-\t    lto-wrapper.o ggc-none.o libcommon-target.a $(LIBS)\n+\t   $(LTO_WRAPPER_OBJS) libcommon-target.a $(LIBS)\n \tmv -f T$@ $@\n \n # Files used by all variants of C or by the stand-alone pre-processor."}, {"sha": "004569c99574333bfdc0041954430bcf0129d445", "filename": "gcc/collect-utils.c", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a185856a06e7b26a06229563b2b01b92e6a4589b/gcc%2Fcollect-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a185856a06e7b26a06229563b2b01b92e6a4589b/gcc%2Fcollect-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect-utils.c?ref=a185856a06e7b26a06229563b2b01b92e6a4589b", "patch": "@@ -0,0 +1,222 @@\n+/* Utility functions used by tools like collect2 and lto-wrapper.\n+   Copyright (C) 2009-2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"intl.h\"\n+#include \"diagnostic.h\"\n+#include \"obstack.h\"\n+#include \"opts.h\"\n+#include \"options.h\"\n+#include \"simple-object.h\"\n+#include \"lto-section-names.h\"\n+#include \"collect-utils.h\"\n+\n+static char *response_file;\n+\n+bool debug;\n+bool verbose;\n+\n+/* Delete tempfiles.  */\n+\n+void\n+utils_cleanup (void)\n+{\n+  static bool cleanup_done = false;\n+\n+  if (cleanup_done)\n+    return;\n+\n+  /* Setting cleanup_done prevents an infinite loop if one of the\n+     calls to maybe_unlink fails. */\n+  cleanup_done = true;\n+\n+  if (response_file)\n+    maybe_unlink (response_file);\n+  tool_cleanup ();\n+}\n+\n+/* Notify user of a non-error.  */\n+void\n+notice (const char *cmsgid, ...)\n+{\n+  va_list ap;\n+\n+  va_start (ap, cmsgid);\n+  vfprintf (stderr, _(cmsgid), ap);\n+  va_end (ap);\n+}\n+\n+void\n+fatal_signal (int signum)\n+{\n+  signal (signum, SIG_DFL);\n+  utils_cleanup ();\n+  /* Get the same signal again, this time not handled,\n+     so its normal effect occurs.  */\n+  kill (getpid (), signum);\n+}\n+\n+/* Execute a program, and wait for the reply. ARGV are the arguments. The\n+   last one must be NULL. */\n+\n+struct pex_obj *\n+collect_execute (char **argv)\n+{\n+  struct pex_obj *pex;\n+  const char *errmsg;\n+  int err;\n+\n+  if (verbose)\n+    {\n+      char **p_argv;\n+      const char *str;\n+\n+      for (p_argv = argv; (str = *p_argv) != (char *) 0; p_argv++)\n+\tfprintf (stderr, \" %s\", str);\n+\n+      fprintf (stderr, \"\\n\");\n+    }\n+\n+  fflush (stdout);\n+  fflush (stderr);\n+\n+  pex = pex_init (0, tool_name, NULL);\n+  if (pex == NULL)\n+    fatal_error (\"pex_init failed: %m\");\n+\n+  /* Do not use PEX_LAST here, we use our stdout for communicating with\n+     collect2 or the linker-plugin.  Any output from the sub-process\n+     will confuse that.  */\n+  errmsg = pex_run (pex, PEX_SEARCH, argv[0], argv, NULL,\n+\t\t    NULL, &err);\n+  if (errmsg != NULL)\n+    {\n+      if (err != 0)\n+\t{\n+\t  errno = err;\n+\t  fatal_error (\"%s: %m\", _(errmsg));\n+\t}\n+      else\n+\tfatal_error (errmsg);\n+    }\n+\n+  return pex;\n+}\n+\n+\n+/* Wait for a process to finish, and exit if a nonzero status is found.\n+   PROG is the program name. PEX is the process we should wait for. */\n+\n+int\n+collect_wait (const char *prog, struct pex_obj *pex)\n+{\n+  int status;\n+\n+  if (!pex_get_status (pex, 1, &status))\n+    fatal_error (\"can't get program status: %m\");\n+  pex_free (pex);\n+\n+  if (status)\n+    {\n+      if (WIFSIGNALED (status))\n+\t{\n+\t  int sig = WTERMSIG (status);\n+\t  if (WCOREDUMP (status))\n+\t    fatal_error (\"%s terminated with signal %d [%s], core dumped\",\n+\t\t\t prog, sig, strsignal (sig));\n+\t  else\n+\t    fatal_error (\"%s terminated with signal %d [%s]\",\n+\t\t\t prog, sig, strsignal (sig));\n+\t}\n+\n+      if (WIFEXITED (status))\n+\tfatal_error (\"%s returned %d exit status\", prog, WEXITSTATUS (status));\n+    }\n+\n+  return 0;\n+}\n+\n+void\n+do_wait (const char *prog, struct pex_obj *pex)\n+{\n+  int ret = collect_wait (prog, pex);\n+  if (ret != 0)\n+    {\n+      error (\"%s returned %d exit status\", prog, ret);\n+      exit (ret);\n+    }\n+\n+  if (response_file && !debug)\n+    {\n+      unlink (response_file);\n+      response_file = NULL;\n+    }\n+}\n+\n+/* Unlink a temporary LTRANS file unless requested otherwise.  */\n+\n+void\n+maybe_unlink_file (const char *file)\n+{\n+  if (!debug)\n+    {\n+      if (unlink_if_ordinary (file)\n+\t  && errno != ENOENT)\n+\tfatal_error (\"deleting file %s: %m\", file);\n+    }\n+  else\n+    fprintf (stderr, \"[Leaving %s]\\n\", file);\n+}\n+\n+\n+/* Execute program ARGV[0] with arguments ARGV. Wait for it to finish.  */\n+\n+void\n+fork_execute (char **argv)\n+{\n+  struct pex_obj *pex;\n+  char *new_argv[3];\n+  char *at_args;\n+  FILE *args;\n+  int status;\n+\n+  response_file = make_temp_file (\".args\");\n+  at_args = concat (\"@\", response_file, NULL);\n+  args = fopen (response_file, \"w\");\n+  if (args == NULL)\n+    fatal_error (\"failed to open %s\", response_file);\n+\n+  status = writeargv (&argv[1], args);\n+\n+  if (status)\n+    fatal_error (\"could not write to temporary file %s\",  response_file);\n+\n+  fclose (args);\n+\n+  new_argv[0] = argv[0];\n+  new_argv[1] = at_args;\n+  new_argv[2] = NULL;\n+\n+  pex = collect_execute (new_argv);\n+  do_wait (new_argv[0], pex);\n+\n+  free (at_args);\n+}"}, {"sha": "e47ab294c165dbca0a20ce690018ed167820b3d1", "filename": "gcc/collect-utils.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a185856a06e7b26a06229563b2b01b92e6a4589b/gcc%2Fcollect-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a185856a06e7b26a06229563b2b01b92e6a4589b/gcc%2Fcollect-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect-utils.h?ref=a185856a06e7b26a06229563b2b01b92e6a4589b", "patch": "@@ -0,0 +1,40 @@\n+/* Utility functions used by tools like collect2 and lto-wrapper.\n+   Copyright (C) 2009-2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Provided in collect-utils.c.  */\n+extern void notice (const char *, ...)\n+  __attribute__ ((format (printf, 1, 2)));\n+extern void fatal_signal (int);\n+\n+extern struct pex_obj *collect_execute (char **);\n+extern int collect_wait (const char *, struct pex_obj *);\n+extern void do_wait (const char *, struct pex_obj *);\n+extern void fork_execute (char **);\n+extern void utils_cleanup (void);\n+\n+extern bool debug;\n+extern bool verbose;\n+\n+/* Provided by the tool itself.  */\n+\n+/* The name of the tool, printed in error messages.  */\n+extern const char tool_name[];\n+/* Called by utils_cleanup.  */\n+extern void tool_cleanup (void);\n+extern void maybe_unlink (const char *);"}, {"sha": "45ce32157c84382c044d1ff187cefe5ebb867ea8", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 18, "deletions": 153, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a185856a06e7b26a06229563b2b01b92e6a4589b/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a185856a06e7b26a06229563b2b01b92e6a4589b/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=a185856a06e7b26a06229563b2b01b92e6a4589b", "patch": "@@ -47,9 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"options.h\"\n #include \"simple-object.h\"\n #include \"lto-section-names.h\"\n-\n-int debug;\t\t\t\t/* true if -save-temps.  */\n-int verbose;\t\t\t\t/* true if -v.  */\n+#include \"collect-utils.h\"\n \n enum lto_mode_d {\n   LTO_MODE_NONE,\t\t\t/* Not doing LTO.  */\n@@ -62,140 +60,44 @@ static enum lto_mode_d lto_mode = LTO_MODE_NONE;\n \n static char *ltrans_output_file;\n static char *flto_out;\n-static char *args_name;\n static unsigned int nr;\n static char **input_names;\n static char **output_names;\n static char *makefile;\n \n-static void maybe_unlink_file (const char *);\n+const char tool_name[] = \"lto-wrapper\";\n \n- /* Delete tempfiles.  */\n+/* Delete tempfiles.  Called from utils_cleanup.  */\n \n-static void\n-lto_wrapper_cleanup (void)\n+void\n+tool_cleanup (void)\n {\n-  static bool cleanup_done = false;\n   unsigned int i;\n \n-  if (cleanup_done)\n-    return;\n-\n-  /* Setting cleanup_done prevents an infinite loop if one of the\n-     calls to maybe_unlink_file fails. */\n-  cleanup_done = true;\n-\n   if (ltrans_output_file)\n-    maybe_unlink_file (ltrans_output_file);\n+    maybe_unlink (ltrans_output_file);\n   if (flto_out)\n-    maybe_unlink_file (flto_out);\n-  if (args_name)\n-    maybe_unlink_file (args_name);\n+    maybe_unlink (flto_out);\n   if (makefile)\n-    maybe_unlink_file (makefile);\n+    maybe_unlink (makefile);\n   for (i = 0; i < nr; ++i)\n     {\n-      maybe_unlink_file (input_names[i]);\n+      maybe_unlink (input_names[i]);\n       if (output_names[i])\n-\tmaybe_unlink_file (output_names[i]);\n+\tmaybe_unlink (output_names[i]);\n     }\n }\n \n static void\n-fatal_signal (int signum)\n-{\n-  signal (signum, SIG_DFL);\n-  lto_wrapper_cleanup ();\n-  /* Get the same signal again, this time not handled,\n-     so its normal effect occurs.  */\n-  kill (getpid (), signum);\n-}\n-\n-/* Execute a program, and wait for the reply. ARGV are the arguments. The\n-   last one must be NULL. */\n-\n-static struct pex_obj *\n-collect_execute (char **argv)\n-{\n-  struct pex_obj *pex;\n-  const char *errmsg;\n-  int err;\n-\n-  if (verbose)\n-    {\n-      char **p_argv;\n-      const char *str;\n-\n-      for (p_argv = argv; (str = *p_argv) != (char *) 0; p_argv++)\n-\tfprintf (stderr, \" %s\", str);\n-\n-      fprintf (stderr, \"\\n\");\n-    }\n-\n-  fflush (stdout);\n-  fflush (stderr);\n-\n-  pex = pex_init (0, \"lto-wrapper\", NULL);\n-  if (pex == NULL)\n-    fatal_error (\"pex_init failed: %m\");\n-\n-  /* Do not use PEX_LAST here, we use our stdout for communicating with\n-     collect2 or the linker-plugin.  Any output from the sub-process\n-     will confuse that.  */\n-  errmsg = pex_run (pex, PEX_SEARCH, argv[0], argv, NULL,\n-\t\t    NULL, &err);\n-  if (errmsg != NULL)\n-    {\n-      if (err != 0)\n-\t{\n-\t  errno = err;\n-\t  fatal_error (\"%s: %m\", _(errmsg));\n-\t}\n-      else\n-\tfatal_error (errmsg);\n-    }\n-\n-  return pex;\n-}\n-\n-\n-/* Wait for a process to finish, and exit if a nonzero status is found.\n-   PROG is the program name. PEX is the process we should wait for. */\n-\n-static int\n-collect_wait (const char *prog, struct pex_obj *pex)\n+lto_wrapper_cleanup (void)\n {\n-  int status;\n-\n-  if (!pex_get_status (pex, 1, &status))\n-    fatal_error (\"can't get program status: %m\");\n-  pex_free (pex);\n-\n-  if (status)\n-    {\n-      if (WIFSIGNALED (status))\n-\t{\n-\t  int sig = WTERMSIG (status);\n-\t  if (WCOREDUMP (status))\n-\t    fatal_error (\"%s terminated with signal %d [%s], core dumped\",\n-\t\t   prog, sig, strsignal (sig));\n-\t  else\n-\t    fatal_error (\"%s terminated with signal %d [%s]\",\n-\t\t   prog, sig, strsignal (sig));\n-\t}\n-\n-      if (WIFEXITED (status))\n-\tfatal_error (\"%s returned %d exit status\", prog, WEXITSTATUS (status));\n-    }\n-\n-  return 0;\n+  utils_cleanup ();\n }\n \n-\n /* Unlink a temporary LTRANS file unless requested otherwise.  */\n \n-static void\n-maybe_unlink_file (const char *file)\n+void\n+maybe_unlink (const char *file)\n {\n   if (! debug)\n     {\n@@ -207,43 +109,6 @@ maybe_unlink_file (const char *file)\n     fprintf (stderr, \"[Leaving LTRANS %s]\\n\", file);\n }\n \n-\n-/* Execute program ARGV[0] with arguments ARGV. Wait for it to finish.  */\n-\n-static void\n-fork_execute (char **argv)\n-{\n-  struct pex_obj *pex;\n-  char *new_argv[3];\n-  char *at_args;\n-  FILE *args;\n-  int status;\n-\n-  args_name = make_temp_file (\".args\");\n-  at_args = concat (\"@\", args_name, NULL);\n-  args = fopen (args_name, \"w\");\n-  if (args == NULL)\n-    fatal_error (\"failed to open %s\", args_name);\n-\n-  status = writeargv (&argv[1], args);\n-\n-  if (status)\n-    fatal_error (\"could not write to temporary file %s\",  args_name);\n-\n-  fclose (args);\n-\n-  new_argv[0] = argv[0];\n-  new_argv[1] = at_args;\n-  new_argv[2] = NULL;\n-\n-  pex = collect_execute (new_argv);\n-  collect_wait (new_argv[0], pex);\n-\n-  maybe_unlink_file (args_name);\n-  args_name = NULL;\n-  free (at_args);\n-}\n-\n /* Template of LTRANS dumpbase suffix.  */\n #define DUMPBASE_SUFFIX \".ltrans18446744073709551615\"\n \n@@ -869,7 +734,7 @@ run_gcc (unsigned argc, char *argv[])\n \t  output_names[nr-1] = output_name;\n \t}\n       fclose (stream);\n-      maybe_unlink_file (ltrans_output_file);\n+      maybe_unlink (ltrans_output_file);\n       ltrans_output_file = NULL;\n \n       if (parallel)\n@@ -928,7 +793,7 @@ run_gcc (unsigned argc, char *argv[])\n \t  else\n \t    {\n \t      fork_execute (CONST_CAST (char **, new_argv));\n-\t      maybe_unlink_file (input_name);\n+\t      maybe_unlink (input_name);\n \t    }\n \n \t  output_names[i] = output_name;\n@@ -965,10 +830,10 @@ run_gcc (unsigned argc, char *argv[])\n \t  new_argv[i++] = NULL;\n \t  pex = collect_execute (CONST_CAST (char **, new_argv));\n \t  collect_wait (new_argv[0], pex);\n-\t  maybe_unlink_file (makefile);\n+\t  maybe_unlink (makefile);\n \t  makefile = NULL;\n \t  for (i = 0; i < nr; ++i)\n-\t    maybe_unlink_file (input_names[i]);\n+\t    maybe_unlink (input_names[i]);\n \t}\n       for (i = 0; i < nr; ++i)\n \t{"}]}