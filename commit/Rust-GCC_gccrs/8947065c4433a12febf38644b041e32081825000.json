{"sha": "8947065c4433a12febf38644b041e32081825000", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk0NzA2NWM0NDMzYTEyZmViZjM4NjQ0YjA0MWUzMjA4MTgyNTAwMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-01-07T03:18:28Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-01-07T03:18:28Z"}, "message": "sparc.h (PREFERRED_RELOAD_CLASS): Select GENERAL_REGS for integer data not destined for fp regs.\n\n        * sparc.h (PREFERRED_RELOAD_CLASS): Select GENERAL_REGS for\n        integer data not destined for fp regs.\n        (LEGITIMIZE_RELOAD_ADDRESS): New.\nThu Jan  7 03:03:42 1999  Stan Cox  <scox@cygnus.com>\n                          Richard Henderson  <rth@cygnus.com>\n        Support for Hypersparc and Sparclite86x:\n        * sparc.h (TARGET_CPU_hypersparc, TARGET_CPU_sparclite86x): New.\n        (CPP_CPU32_DEFAULT_SPEC): Fix up for the new targets.\n        (ASM_CPU32_DEFAULT_SPEC): Likewise.\n        (TARGET_CPU_DEFAULT): Likewise.\n        (enum processor_type): Likewise.\n        (CPP_ENDIAN_SPEC): Handle little endian data.\n        (LIBGCC2_WORDS_BIG_ENDIAN): Likewise.\n        (ADJUST_COST): Call sparc_adjust_cost.\n        * sparc.c (sparc_override_options): Fix up for the new targets.\n        (supersparc_adjust_cost): Make static.\n        (hypersparc_adjust_cost): New.\n        (ultrasparc_adjust_cost): Make static.\n        (sparc_adjust_cost): New.\n        * sparc.md (attr cpu): Add hypersparc and sparclite86x.\n        (function_unit): Add hypersparc scheduling rules.\n        * configure.in (with_cpu handler): Recognize hypersparc.\n\nFrom-SVN: r24556", "tree": {"sha": "c4682cc19df3771080fc19efa4aad62918b35228", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4682cc19df3771080fc19efa4aad62918b35228"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8947065c4433a12febf38644b041e32081825000", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8947065c4433a12febf38644b041e32081825000", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8947065c4433a12febf38644b041e32081825000", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8947065c4433a12febf38644b041e32081825000/comments", "author": null, "committer": null, "parents": [{"sha": "4ddb3ea6f72010459858f5ec470578481d2f7274", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ddb3ea6f72010459858f5ec470578481d2f7274", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ddb3ea6f72010459858f5ec470578481d2f7274"}], "stats": {"total": 594, "additions": 421, "deletions": 173}, "files": [{"sha": "5493f51623a602bacffeb42b5b90725dc6f2cc2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8947065c4433a12febf38644b041e32081825000/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8947065c4433a12febf38644b041e32081825000/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8947065c4433a12febf38644b041e32081825000", "patch": "@@ -1,3 +1,31 @@\n+Thu Jan  7 03:08:17 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* sparc.h (PREFERRED_RELOAD_CLASS): Select GENERAL_REGS for \n+\tinteger data not destined for fp regs.\n+\t(LEGITIMIZE_RELOAD_ADDRESS): New.\n+\n+Thu Jan  7 03:03:42 1999  Stan Cox  <scox@cygnus.com>\n+\t\t\t  Richard Henderson  <rth@cygnus.com>\n+\n+\tSupport for Hypersparc and Sparclite86x:\n+\t* sparc.h (TARGET_CPU_hypersparc, TARGET_CPU_sparclite86x): New.\n+\t(CPP_CPU32_DEFAULT_SPEC): Fix up for the new targets.\n+\t(ASM_CPU32_DEFAULT_SPEC): Likewise.\n+\t(TARGET_CPU_DEFAULT): Likewise.\n+\t(enum processor_type): Likewise.\n+\t(CPP_ENDIAN_SPEC): Handle little endian data.\n+\t(LIBGCC2_WORDS_BIG_ENDIAN): Likewise.\n+\t(ADJUST_COST): Call sparc_adjust_cost.\n+\t* sparc.c (sparc_override_options): Fix up for the new targets.\n+\t(supersparc_adjust_cost): Make static.\n+\t(hypersparc_adjust_cost): New.\n+\t(ultrasparc_adjust_cost): Make static.\n+\t(sparc_adjust_cost): New.\n+\t* sparc.md (attr cpu): Add hypersparc and sparclite86x.\n+\t(function_unit): Add hypersparc scheduling rules.\n+\n+\t* configure.in (with_cpu handler): Recognize hypersparc.\n+\n Thu Jan  7 23:54:05 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.c: Added space after negation operator."}, {"sha": "a538070b2c6af37baaf77f9ada0b1b6bbc81325a", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 265, "deletions": 150, "changes": 415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8947065c4433a12febf38644b041e32081825000/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8947065c4433a12febf38644b041e32081825000/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=8947065c4433a12febf38644b041e32081825000", "patch": "@@ -110,6 +110,11 @@ static void build_big_number\tPROTO((FILE *, int, char *));\n static int function_arg_slotno\tPROTO((const CUMULATIVE_ARGS *,\n \t\t\t\t       enum machine_mode, tree, int, int,\n \t\t\t\t       int *, int *));\n+\n+static int supersparc_adjust_cost PROTO((rtx, rtx, rtx, int));\n+static int hypersparc_adjust_cost PROTO((rtx, rtx, rtx, int));\n+static int ultrasparc_adjust_cost PROTO((rtx, rtx, rtx, int));\n+\n static void sparc_output_addr_vec PROTO((rtx));\n static void sparc_output_addr_diff_vec PROTO((rtx));\n static void sparc_output_deferred_case_vectors PROTO((void));\n@@ -176,6 +181,8 @@ sparc_override_options ()\n     { TARGET_CPU_sparclet, \"tsc701\" },\n     { TARGET_CPU_sparclite, \"f930\" },\n     { TARGET_CPU_v8, \"v8\" },\n+    { TARGET_CPU_hypersparc, \"hypersparc\" },\n+    { TARGET_CPU_sparclite86x, \"sparclite86x\" },\n     { TARGET_CPU_supersparc, \"supersparc\" },\n     { TARGET_CPU_v9, \"v9\" },\n     { TARGET_CPU_ultrasparc, \"ultrasparc\" },\n@@ -199,6 +206,8 @@ sparc_override_options ()\n        The Fujitsu MB86934 is the recent sparclite chip, with an fpu.  */\n     { \"f930\",       PROCESSOR_F930, MASK_ISA|MASK_FPU, MASK_SPARCLITE },\n     { \"f934\",       PROCESSOR_F934, MASK_ISA, MASK_SPARCLITE|MASK_FPU },\n+    { \"hypersparc\", PROCESSOR_HYPERSPARC, MASK_ISA, MASK_V8|MASK_FPU },\n+    { \"sparclite86x\",  PROCESSOR_SPARCLITE86X, MASK_ISA|MASK_FPU, MASK_V8 },\n     { \"sparclet\",   PROCESSOR_SPARCLET, MASK_ISA, MASK_SPARCLET },\n     /* TEMIC sparclet */\n     { \"tsc701\",     PROCESSOR_TSC701, MASK_ISA, MASK_SPARCLET },\n@@ -6194,7 +6203,7 @@ sparc_flat_eligible_for_epilogue_delay (trial, slot)\n /* Adjust the cost of a scheduling dependency.  Return the new cost of\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n \n-int\n+static int\n supersparc_adjust_cost (insn, link, dep_insn, cost)\n      rtx insn;\n      rtx link;\n@@ -6259,6 +6268,261 @@ supersparc_adjust_cost (insn, link, dep_insn, cost)\n   return cost;\n }\n \n+static int\n+hypersparc_adjust_cost (insn, link, dep_insn, cost)\n+     rtx insn;\n+     rtx link;\n+     rtx dep_insn;\n+     int cost;\n+{\n+  enum attr_type insn_type, dep_type;\n+  rtx pat = PATTERN(insn);\n+  rtx dep_pat = PATTERN (dep_insn);\n+\n+  if (recog_memoized (insn) < 0 || recog_memoized (dep_insn) < 0)\n+    return cost;\n+\n+  insn_type = get_attr_type (insn);\n+  dep_type = get_attr_type (dep_insn);\n+\n+  switch (REG_NOTE_KIND (link))\n+    {\n+    case 0:\n+      /* Data dependency; DEP_INSN writes a register that INSN reads some\n+\t cycles later.  */\n+\n+      switch (insn_type)\n+\t{\n+\tcase TYPE_STORE:\n+\tcase TYPE_FPSTORE:\n+\t  /* Get the delay iff the address of the store is the dependence. */\n+\t  if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET)\n+\t    return cost;\n+\n+\t  if (rtx_equal_p (SET_DEST (dep_pat), SET_SRC (pat)))\n+\t    return cost;\n+\t  return cost + 3;\n+\n+\tcase TYPE_LOAD:\n+\tcase TYPE_SLOAD:\n+\tcase TYPE_FPLOAD:\n+\t  /* If a load, then the dependence must be on the memory address.  If\n+\t     the addresses aren't equal, then it might be a false dependency */\n+\t  if (dep_type == TYPE_STORE || dep_type == TYPE_FPSTORE)\n+\t    {\n+\t      if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET\n+\t\t  || GET_CODE (SET_DEST (dep_pat)) != MEM        \n+\t\t  || GET_CODE (SET_SRC (pat)) != MEM\n+\t\t  || ! rtx_equal_p (XEXP (SET_DEST (dep_pat), 0),\n+\t\t\t\t    XEXP (SET_SRC (pat), 0)))\n+\t\treturn cost + 2;\n+\n+\t      return cost + 8;        \n+\t    }\n+\t  break;\n+\n+\tcase TYPE_BRANCH:\n+\t  /* Compare to branch latency is 0.  There is no benefit from\n+\t     separating compare and branch.  */\n+\t  if (dep_type == TYPE_COMPARE)\n+\t    return 0;\n+\t  /* Floating point compare to branch latency is less than\n+\t     compare to conditional move.  */\n+\t  if (dep_type == TYPE_FPCMP)\n+\t    return cost - 1;\n+\t  break;\n+\t}\n+\tbreak;\n+\n+    case REG_DEP_ANTI:\n+      /* Anti-dependencies only penalize the fpu unit. */\n+      if (insn_type == TYPE_IALU || insn_type == TYPE_SHIFT)\n+        return 0;\n+      break;\n+\n+    default:\n+      break;\n+    }    \n+\n+  return cost;\n+}\n+\n+static int\n+ultrasparc_adjust_cost (insn, link, dep_insn, cost)\n+     rtx insn;\n+     rtx link;\n+     rtx dep_insn;\n+     int cost;\n+{\n+  enum attr_type insn_type, dep_type;\n+  rtx pat = PATTERN(insn);\n+  rtx dep_pat = PATTERN (dep_insn);\n+\n+  if (recog_memoized (insn) < 0 || recog_memoized (dep_insn) < 0)\n+    return cost;\n+\n+  insn_type = get_attr_type (insn);\n+  dep_type = get_attr_type (dep_insn);\n+\n+  /* Nothing issues in parallel with integer multiplies, so\n+     mark as zero cost since the scheduler can not do anything\n+     about it.  */\n+  if (insn_type == TYPE_IMUL)\n+    return 0;\n+\n+#define SLOW_FP(dep_type) \\\n+(dep_type == TYPE_FPSQRT || dep_type == TYPE_FPDIVS || dep_type == TYPE_FPDIVD)\n+\n+  switch (REG_NOTE_KIND (link))\n+    {\n+    case 0:\n+      /* Data dependency; DEP_INSN writes a register that INSN reads some\n+\t cycles later.  */\n+\n+      if (dep_type == TYPE_CMOVE)\n+\t{\n+\t  /* Instructions that read the result of conditional moves cannot\n+\t     be in the same group or the following group.  */\n+\t  return cost + 1;\n+\t}\n+\n+      switch (insn_type)\n+\t{\n+\t  /* UltraSPARC can dual issue a store and an instruction setting\n+\t     the value stored, except for divide and square root.  */\n+\tcase TYPE_FPSTORE:\n+\t  if (! SLOW_FP (dep_type))\n+\t    return 0;\n+\t  return cost;\n+\n+\tcase TYPE_STORE:\n+\t  if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET)\n+\t    return cost;\n+\n+\t  if (rtx_equal_p (SET_DEST (dep_pat), SET_SRC (pat)))\n+\t    /* The dependency between the two instructions is on the data\n+\t       that is being stored.  Assume that the address of the store\n+\t       is not also dependent.  */\n+\t    return 0;\n+\t  return cost;\n+\n+\tcase TYPE_LOAD:\n+\tcase TYPE_SLOAD:\n+\tcase TYPE_FPLOAD:\n+\t  /* A load does not return data until at least 11 cycles after\n+\t     a store to the same location.  3 cycles are accounted for\n+\t     in the load latency; add the other 8 here.  */\n+\t  if (dep_type == TYPE_STORE || dep_type == TYPE_FPSTORE)\n+\t    {\n+\t      /* If the addresses are not equal this may be a false\n+\t\t dependency because pointer aliasing could not be\n+\t\t determined.  Add only 2 cycles in that case.  2 is\n+\t\t an arbitrary compromise between 8, which would cause\n+\t\t the scheduler to generate worse code elsewhere to\n+\t\t compensate for a dependency which might not really\n+\t\t exist, and 0.  */\n+\t      if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET\n+\t\t  || GET_CODE (SET_SRC (pat)) != MEM\n+\t\t  || GET_CODE (SET_DEST (dep_pat)) != MEM\n+\t\t  || ! rtx_equal_p (XEXP (SET_SRC (pat), 0),\n+\t\t\t\t    XEXP (SET_DEST (dep_pat), 0)))\n+\t\treturn cost + 2;\n+\n+\t      return cost + 8;\n+\t    }\n+\t  return cost;\n+\n+\tcase TYPE_BRANCH:\n+\t  /* Compare to branch latency is 0.  There is no benefit from\n+\t     separating compare and branch.  */\n+\t  if (dep_type == TYPE_COMPARE)\n+\t    return 0;\n+\t  /* Floating point compare to branch latency is less than\n+\t     compare to conditional move.  */\n+\t  if (dep_type == TYPE_FPCMP)\n+\t    return cost - 1;\n+\t  return cost;\n+\n+\tcase TYPE_FPCMOVE:\n+\t  /* FMOVR class instructions can not issue in the same cycle\n+\t     or the cycle after an instruction which writes any\n+\t     integer register.  Model this as cost 2 for dependent\n+\t     instructions.  */\n+\t  if ((dep_type == TYPE_IALU || dep_type == TYPE_UNARY\n+\t       || dep_type == TYPE_BINARY)\n+\t      && cost < 2)\n+\t    return 2;\n+\t  /* Otherwise check as for integer conditional moves. */\n+\n+\tcase TYPE_CMOVE:\n+\t  /* Conditional moves involving integer registers wait until\n+\t     3 cycles after loads return data.  The interlock applies\n+\t     to all loads, not just dependent loads, but that is hard\n+\t     to model.  */\n+\t  if (dep_type == TYPE_LOAD || dep_type == TYPE_SLOAD)\n+\t    return cost + 3;\n+\t  return cost;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+      break;\n+\n+    case REG_DEP_ANTI:\n+      /* Divide and square root lock destination registers for full latency. */\n+      if (! SLOW_FP (dep_type))\n+\treturn 0;\n+      break;\n+\n+    case REG_DEP_OUTPUT:\n+      /* IEU and FPU instruction that have the same destination\n+\t register cannot be grouped together.  */\n+      return cost + 1;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Other costs not accounted for:\n+     - Single precision floating point loads lock the other half of\n+       the even/odd register pair.\n+     - Several hazards associated with ldd/std are ignored because these\n+       instructions are rarely generated for V9.\n+     - The floating point pipeline can not have both a single and double\n+       precision operation active at the same time.  Format conversions\n+       and graphics instructions are given honorary double precision status.\n+     - call and jmpl are always the first instruction in a group.  */\n+\n+  return cost;\n+\n+#undef SLOW_FP\n+}\n+\n+int\n+sparc_adjust_cost(insn, link, dep, cost)\n+     rtx insn;\n+     rtx link;\n+     rtx dep;\n+     int cost;\n+{\n+  switch (sparc_cpu)\n+    {\n+    case PROCESSOR_SUPERSPARC:\n+      cost = supersparc_adjust_cost (insn, link, dep, cost);\n+      break;\n+    case PROCESSOR_HYPERSPARC:\n+    case PROCESSOR_SPARCLITE86X:\n+      cost = hypersparc_adjust_cost (insn, link, dep, cost);\n+      break;\n+    case PROCESSOR_ULTRASPARC:\n+      cost = ultrasparc_adjust_cost (insn, link, dep, cost);\n+      break;\n+    default:\n+      break;\n+    }\n+  return cost;\n+}\n+\n /* This describes the state of the UltraSPARC pipeline during\n    instruction scheduling.  */\n \n@@ -6990,155 +7254,6 @@ ultrasparc_sched_reorder (dump, sched_verbose, ready, n_ready)\n     }\n }\n \n-int\n-ultrasparc_adjust_cost (insn, link, dep_insn, cost)\n-     rtx insn;\n-     rtx link;\n-     rtx dep_insn;\n-     int cost;\n-{\n-  enum attr_type insn_type, dep_type;\n-  rtx pat = PATTERN(insn);\n-  rtx dep_pat = PATTERN (dep_insn);\n-\n-  if (recog_memoized (insn) < 0 || recog_memoized (dep_insn) < 0)\n-    return cost;\n-\n-  insn_type = get_attr_type (insn);\n-  dep_type = get_attr_type (dep_insn);\n-\n-  /* Nothing issues in parallel with integer multiplies, so\n-     mark as zero cost since the scheduler can not do anything\n-     about it.  */\n-  if (insn_type == TYPE_IMUL)\n-    return 0;\n-\n-#define SLOW_FP(dep_type) \\\n-(dep_type == TYPE_FPSQRT || dep_type == TYPE_FPDIVS || dep_type == TYPE_FPDIVD)\n-\n-  switch (REG_NOTE_KIND (link))\n-    {\n-    case 0:\n-      /* Data dependency; DEP_INSN writes a register that INSN reads some\n-\t cycles later.  */\n-\n-      if (dep_type == TYPE_CMOVE)\n-\t{\n-\t  /* Instructions that read the result of conditional moves cannot\n-\t     be in the same group or the following group.  */\n-\t  return cost + 1;\n-\t}\n-\n-      switch (insn_type)\n-\t{\n-\t  /* UltraSPARC can dual issue a store and an instruction setting\n-\t     the value stored, except for divide and square root.  */\n-\tcase TYPE_FPSTORE:\n-\t  if (! SLOW_FP (dep_type))\n-\t    return 0;\n-\t  return cost;\n-\n-\tcase TYPE_STORE:\n-\t  if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET)\n-\t    return cost;\n-\n-\t  if (rtx_equal_p (SET_DEST (dep_pat), SET_SRC (pat)))\n-\t    /* The dependency between the two instructions is on the data\n-\t       that is being stored.  Assume that the address of the store\n-\t       is not also dependent.  */\n-\t    return 0;\n-\t  return cost;\n-\n-\tcase TYPE_LOAD:\n-\tcase TYPE_SLOAD:\n-\tcase TYPE_FPLOAD:\n-\t  /* A load does not return data until at least 11 cycles after\n-\t     a store to the same location.  3 cycles are accounted for\n-\t     in the load latency; add the other 8 here.  */\n-\t  if (dep_type == TYPE_STORE || dep_type == TYPE_FPSTORE)\n-\t    {\n-\t      /* If the addresses are not equal this may be a false\n-\t\t dependency because pointer aliasing could not be\n-\t\t determined.  Add only 2 cycles in that case.  2 is\n-\t\t an arbitrary compromise between 8, which would cause\n-\t\t the scheduler to generate worse code elsewhere to\n-\t\t compensate for a dependency which might not really\n-\t\t exist, and 0.  */\n-\t      if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET\n-\t\t  || GET_CODE (SET_SRC (pat)) != MEM\n-\t\t  || GET_CODE (SET_DEST (dep_pat)) != MEM\n-\t\t  || ! rtx_equal_p (XEXP (SET_SRC (pat), 0),\n-\t\t\t\t    XEXP (SET_DEST (dep_pat), 0)))\n-\t\treturn cost + 2;\n-\n-\t      return cost + 8;\n-\t    }\n-\t  return cost;\n-\n-\tcase TYPE_BRANCH:\n-\t  /* Compare to branch latency is 0.  There is no benefit from\n-\t     separating compare and branch.  */\n-\t  if (dep_type == TYPE_COMPARE)\n-\t    return 0;\n-\t  /* Floating point compare to branch latency is less than\n-\t     compare to conditional move.  */\n-\t  if (dep_type == TYPE_FPCMP)\n-\t    return cost - 1;\n-\t  return cost;\n-\n-\tcase TYPE_FPCMOVE:\n-\t  /* FMOVR class instructions can not issue in the same cycle\n-\t     or the cycle after an instruction which writes any\n-\t     integer register.  Model this as cost 2 for dependent\n-\t     instructions.  */\n-\t  if ((dep_type == TYPE_IALU || dep_type == TYPE_UNARY\n-\t       || dep_type == TYPE_BINARY)\n-\t      && cost < 2)\n-\t    return 2;\n-\t  /* Otherwise check as for integer conditional moves. */\n-\n-\tcase TYPE_CMOVE:\n-\t  /* Conditional moves involving integer registers wait until\n-\t     3 cycles after loads return data.  The interlock applies\n-\t     to all loads, not just dependent loads, but that is hard\n-\t     to model.  */\n-\t  if (dep_type == TYPE_LOAD || dep_type == TYPE_SLOAD)\n-\t    return cost + 3;\n-\t  return cost;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-      break;\n-\n-    case REG_DEP_ANTI:\n-      /* Divide and square root lock destination registers for full latency. */\n-      if (! SLOW_FP (dep_type))\n-\treturn 0;\n-      break;\n-\n-    case REG_DEP_OUTPUT:\n-      /* IEU and FPU instruction that have the same destination\n-\t register cannot be grouped together.  */\n-      return cost + 1;\n-\n-    default:\n-      break;\n-    }\n-\n-  /* Other costs not accounted for:\n-     - Single precision floating point loads lock the other half of\n-       the even/odd register pair.\n-     - Several hazards associated with ldd/std are ignored because these\n-       instructions are rarely generated for V9.\n-     - The floating point pipeline can not have both a single and double\n-       precision operation active at the same time.  Format conversions\n-       and graphics instructions are given honorary double precision status.\n-     - call and jmpl are always the first instruction in a group.  */\n-\n-  return cost;\n-}\n-\n int                                                           \n sparc_issue_rate ()\n {"}, {"sha": "a71ca1b3b626b48ad13bb2023f3f3c0082f19047", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 78, "deletions": 20, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8947065c4433a12febf38644b041e32081825000/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8947065c4433a12febf38644b041e32081825000/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=8947065c4433a12febf38644b041e32081825000", "patch": "@@ -106,18 +106,23 @@ extern enum cmodel sparc_cmodel;\n /* Values of TARGET_CPU_DEFAULT, set via -D in the Makefile,\n    and specified by the user via --with-cpu=foo.\n    This specifies the cpu implementation, not the architecture size.  */\n+/* Note that TARGET_CPU_v9 is assumed to start the list of 64-bit \n+   capable cpu's.  */\n #define TARGET_CPU_sparc\t0\n #define TARGET_CPU_v7\t\t0\t/* alias for previous */\n #define TARGET_CPU_sparclet\t1\n #define TARGET_CPU_sparclite\t2\n #define TARGET_CPU_v8\t\t3\t/* generic v8 implementation */\n #define TARGET_CPU_supersparc\t4\n-#define TARGET_CPU_v9\t\t5\t/* generic v9 implementation */\n-#define TARGET_CPU_sparcv9\t5\t/* alias */\n-#define TARGET_CPU_sparc64\t5\t/* alias */\n-#define TARGET_CPU_ultrasparc\t6\n+#define TARGET_CPU_hypersparc   5\n+#define TARGET_CPU_sparclite86x\t6\n+#define TARGET_CPU_v9\t\t7\t/* generic v9 implementation */\n+#define TARGET_CPU_sparcv9\t7\t/* alias */\n+#define TARGET_CPU_sparc64\t7\t/* alias */\n+#define TARGET_CPU_ultrasparc\t8\n \n-#if TARGET_CPU_DEFAULT == TARGET_CPU_v9 || TARGET_CPU_DEFAULT == TARGET_CPU_ultrasparc\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_v9 \\\n+ || TARGET_CPU_DEFAULT == TARGET_CPU_ultrasparc\n \n #define CPP_CPU32_DEFAULT_SPEC \"\"\n #define ASM_CPU32_DEFAULT_SPEC \"\"\n@@ -140,19 +145,37 @@ extern enum cmodel sparc_cmodel;\n #define CPP_CPU64_DEFAULT_SPEC \"\"\n #define ASM_CPU64_DEFAULT_SPEC \"\"\n \n-#if TARGET_CPU_DEFAULT == TARGET_CPU_sparc || TARGET_CPU_DEFAULT == TARGET_CPU_v8 || TARGET_CPU_DEFAULT == TARGET_CPU_supersparc\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_sparc \\\n+ || TARGET_CPU_DEFAULT == TARGET_CPU_v8\n #define CPP_CPU32_DEFAULT_SPEC \"\"\n #define ASM_CPU32_DEFAULT_SPEC \"\"\n #endif\n+\n #if TARGET_CPU_DEFAULT == TARGET_CPU_sparclet\n #define CPP_CPU32_DEFAULT_SPEC \"-D__sparclet__\"\n #define ASM_CPU32_DEFAULT_SPEC \"-Asparclet\"\n #endif\n+\n #if TARGET_CPU_DEFAULT == TARGET_CPU_sparclite\n #define CPP_CPU32_DEFAULT_SPEC \"-D__sparclite__\"\n #define ASM_CPU32_DEFAULT_SPEC \"-Asparclite\"\n #endif\n \n+#if TARGET_CPU_DEFAULT == TARGET_CPU_supersparc\n+#define CPP_CPU32_DEFAULT_SPEC \"-D__supersparc__ -D__sparc_v8__\"\n+#define ASM_CPU32_DEFAULT_SPEC \"\"\n+#endif\n+\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_hypersparc\n+#define CPP_CPU32_DEFAULT_SPEC \"-D__hypersparc__ -D__sparc_v8__\"\n+#define ASM_CPU32_DEFAULT_SPEC \"\"\n+#endif\n+\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_sparclite86x\n+#define CPP_CPU32_DEFAULT_SPEC \"-D__sparclite86x__ -D__sparc_v8__\"\n+#define ASM_CPU32_DEFAULT_SPEC \"-Av8\"\n+#endif\n+\n #endif\n \n #if !defined(CPP_CPU32_DEFAULT_SPEC) || !defined(CPP_CPU64_DEFAULT_SPEC)\n@@ -208,6 +231,8 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n %{mcpu=f930:-D__sparclite__} %{mcpu=f934:-D__sparclite__} \\\n %{mcpu=v8:-D__sparc_v8__} \\\n %{mcpu=supersparc:-D__supersparc__ -D__sparc_v8__} \\\n+%{mcpu=hypersparc:-D__hypersparc__ -D__sparc_v8__} \\\n+%{mcpu=sparclite86x:-D__sparclite86x__ -D__sparc_v8__} \\\n %{mcpu=v9:-D__sparc_v9__} \\\n %{mcpu=ultrasparc:-D__sparc_v9__} \\\n %{!mcpu*:%{!mcypress:%{!msparclite:%{!mf930:%{!mf934:%{!mv8:%{!msupersparc:%(cpp_cpu_default)}}}}}}} \\\n@@ -243,7 +268,9 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n \"\n \n /* Macros to distinguish endianness.  */\n-#define CPP_ENDIAN_SPEC \"%{mlittle-endian:-D__LITTLE_ENDIAN__}\"\n+#define CPP_ENDIAN_SPEC \"\\\n+%{mlittle-endian:-D__LITTLE_ENDIAN__} \\\n+%{mlittle-endian-data:-D__LITTLE_ENDIAN_DATA__}\"\n \n /* Macros to distinguish the particular subtarget.  */\n #define CPP_SUBTARGET_SPEC \"\"\n@@ -598,6 +625,8 @@ enum processor_type {\n   PROCESSOR_SPARCLITE,\n   PROCESSOR_F930,\n   PROCESSOR_F934,\n+  PROCESSOR_HYPERSPARC,\n+  PROCESSOR_SPARCLITE86X,\n   PROCESSOR_SPARCLET,\n   PROCESSOR_TSC701,\n   PROCESSOR_V9,\n@@ -684,7 +713,7 @@ extern int sparc_align_funcs;\n \n /* Define this to set the endianness to use in libgcc2.c, which can\n    not depend on target_flags.  */\n-#if defined (__LITTLE_ENDIAN__)\n+#if defined (__LITTLE_ENDIAN__) || defined(__LITTLE_ENDIAN_DATA__)\n #define LIBGCC2_WORDS_BIG_ENDIAN 0\n #else\n #define LIBGCC2_WORDS_BIG_ENDIAN 1\n@@ -1410,15 +1439,23 @@ extern char leaf_reg_remap[];\n    in class CLASS, return the class of reg to actually use.\n    In general this is just CLASS; but on some machines\n    in some cases it is preferable to use a more restrictive class.  */\n-/* We can't load constants into FP registers.  We can't load any FP constant\n-   if an 'E' constraint fails to match it.  */\n+/* - We can't load constants into FP registers.  We can't load any FP\n+     constant if an 'E' constraint fails to match it.\n+   - Try and reload integer constants (symbolic or otherwise) back into\n+     registers directly, rather than having them dumped to memory.  */\n+\n #define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\\\n   (CONSTANT_P (X)\t\t\t\t\t\\\n-   && (FP_REG_CLASS_P (CLASS)\t\t\t\t\\\n+   ? ((FP_REG_CLASS_P (CLASS)\t\t\t\t\\\n        || (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\\\n \t   && (HOST_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\t\\\n \t       || HOST_BITS_PER_INT != BITS_PER_WORD)))\t\\\n-   ? NO_REGS : (CLASS))\n+      ? NO_REGS\t\t\t\t\t\t\\\n+      : (!FP_REG_CLASS_P (CLASS)\t\t\t\\\n+         && GET_MODE_CLASS (GET_MODE (X)) == MODE_INT)\t\\\n+      ? GENERAL_REGS\t\t\t\t\t\\\n+      : (CLASS))\t\t\t\t\t\\\n+   : (CLASS))\n \n /* Return the register class of a scratch register needed to load IN into\n    a register of class CLASS in MODE.\n@@ -2515,6 +2552,32 @@ extern struct rtx_def *legitimize_pic_address ();\n   if (memory_address_p (MODE, X))\t\t\t\t\\\n     goto WIN; }\n \n+/* Try a machine-dependent way of reloading an illegitimate address\n+   operand.  If we find one, push the reload and jump to WIN.  This\n+   macro is used in only one place: `find_reloads_address' in reload.c.\n+\n+   For Sparc 32, we wish to handle addresses by splitting them into\n+   HIGH+LO_SUM pairs, retaining the LO_SUM in the memory reference. \n+   This cuts the number of extra insns by one.  */\n+   \n+#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)     \\\n+do {                                                                    \\\n+  /* Decompose SImode constants into hi+lo_sum.  We do have to \t\t\\\n+     rerecognize what we produce, so be careful.  */\t\t\t\\\n+  if (CONSTANT_P (X)\t\t\t\t\t\t\t\\\n+      && GET_MODE (X) == SImode\t\t\t\t\t\t\\\n+      && GET_CODE (X) != LO_SUM && GET_CODE (X) != HIGH)\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      X = gen_rtx_LO_SUM (GET_MODE (X),\t\t\t\t\t\\\n+\t\t\t  gen_rtx_HIGH (GET_MODE (X), X), X);\t\t\\\n+      push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL_PTR,\t\\\n+                   BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,\t\\\n+                   OPNUM, TYPE);\t\t\t\t\t\\\n+      goto WIN;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  /* ??? 64-bit reloads.  */\t\t\t\t\t\t\\\n+} while (0)\n+\n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.\n    On the SPARC this is never true.  */\n@@ -2803,12 +2866,8 @@ extern struct rtx_def *legitimize_pic_address ();\n #define ISSUE_RATE  sparc_issue_rate()\n \n /* Adjust the cost of dependencies.  */\n-#define ADJUST_COST(INSN,LINK,DEP,COST)\t\t\t\t\\\n-  if (sparc_cpu == PROCESSOR_SUPERSPARC)\t\t\t\\\n-    (COST) = supersparc_adjust_cost (INSN, LINK, DEP, COST);\t\\\n-  else if (sparc_cpu == PROCESSOR_ULTRASPARC)\t\t\t\\\n-    (COST) = ultrasparc_adjust_cost (INSN, LINK, DEP, COST);\t\\\n-  else\n+#define ADJUST_COST(INSN,LINK,DEP,COST) \\\n+  sparc_adjust_cost(INSN, LINK, DEP, COST)\n \n extern void ultrasparc_sched_reorder ();\n extern void ultrasparc_sched_init ();\n@@ -3394,11 +3453,10 @@ extern int sparc_flat_epilogue_delay_slots ();\n extern int sparc_issue_rate ();\n extern int splittable_immediate_memory_operand ();\n extern int splittable_symbolic_memory_operand ();\n-extern int supersparc_adjust_cost ();\n+extern int sparc_adjust_cost ();\n extern int symbolic_memory_operand ();\n extern int symbolic_operand ();\n extern int text_segment_operand ();\n-extern int ultrasparc_adjust_cost ();\n extern int uns_small_int ();\n extern int v9_regcmp_op ();\n extern int v9_regcmp_p ();"}, {"sha": "2b1e518de92fb8608450248ce3e7fba7acce3371", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8947065c4433a12febf38644b041e32081825000/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8947065c4433a12febf38644b041e32081825000/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=8947065c4433a12febf38644b041e32081825000", "patch": "@@ -65,7 +65,7 @@\n \n ;; Attribute for cpu type.\n ;; These must match the values for enum processor_type in sparc.h.\n-(define_attr \"cpu\" \"v7,cypress,v8,supersparc,sparclite,f930,f934,sparclet,tsc701,v9,ultrasparc\"\n+(define_attr \"cpu\" \"v7,cypress,v8,supersparc,sparclite,f930,f934,hypersparc,sparclite86x,sparclet,tsc701,v9,ultrasparc\"\n   (const (symbol_ref \"sparc_cpu_attr\")))\n \n ;; Attribute for the instruction set.\n@@ -345,6 +345,53 @@\n     (eq_attr \"type\" \"imul\"))\n   4 4)\n \n+;; ----- hypersparc/sparclite86x scheduling\n+;; The Hypersparc can issue 1 - 2 insns per cycle.  The dual issue cases are:\n+;; L-Ld/St I-Int F-Float B-Branch LI/LF/LB/II/IF/IB/FF/FB\n+;; II/FF case is only when loading a 32 bit hi/lo constant\n+;; Single issue insns include call, jmpl, u/smul, u/sdiv, lda, sta, fcmp\n+;; Memory delivers its result in one cycle to IU\n+\n+(define_function_unit \"memory\" 1 0\n+  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n+    (eq_attr \"type\" \"load,sload,fpload\"))\n+  1 1)\n+\n+(define_function_unit \"memory\" 1 0\n+  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n+    (eq_attr \"type\" \"store,fpstore\"))\n+  2 1)\n+\n+(define_function_unit \"fp_alu\" 1 0\n+  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n+    (eq_attr \"type\" \"fp,fpmove,fpcmp\"))\n+  1 1)\n+\n+(define_function_unit \"fp_mds\" 1 0\n+  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n+    (eq_attr \"type\" \"fpmul\"))\n+  1 1)\n+\n+(define_function_unit \"fp_mds\" 1 0\n+  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n+    (eq_attr \"type\" \"fpdivs\"))\n+  8 6)\n+\n+(define_function_unit \"fp_mds\" 1 0\n+  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n+    (eq_attr \"type\" \"fpdivd\"))\n+  12 10)\n+\n+(define_function_unit \"fp_mds\" 1 0\n+  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n+    (eq_attr \"type\" \"fpsqrt\"))\n+  17 15)\n+\n+(define_function_unit \"fp_mds\" 1 0\n+  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n+    (eq_attr \"type\" \"imul\"))\n+  17 15)\n+\n ;; ----- sparclet tsc701 scheduling\n ;; The tsc701 issues 1 insn per cycle.\n ;; Results may be written back out of order."}, {"sha": "9e0748eed54ab5ecc0d960a2568d53d14b65a7ac", "filename": "gcc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8947065c4433a12febf38644b041e32081825000/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8947065c4433a12febf38644b041e32081825000/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=8947065c4433a12febf38644b041e32081825000", "patch": "@@ -5518,7 +5518,7 @@ for machine in $build $host $target; do\n \t\t\t.)\n \t\t\t\ttarget_cpu_default2=TARGET_CPU_\"`echo $machine | sed 's/-.*$//'`\"\n \t\t\t\t;;\n-\t\t\t.supersparc | .ultrasparc | .v7 | .v8 | .v9)\n+\t\t\t.supersparc | .hypersparc | .ultrasparc | .v7 | .v8 | .v9)\n \t\t\t\ttarget_cpu_default2=\"TARGET_CPU_$with_cpu\"\n \t\t\t\t;;\n \t\t\t*)"}, {"sha": "92675afb5968d6049a6d81662999fa1878f48df3", "filename": "gcc/configure.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8947065c4433a12febf38644b041e32081825000/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8947065c4433a12febf38644b041e32081825000/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=8947065c4433a12febf38644b041e32081825000", "patch": "@@ -3347,7 +3347,7 @@ changequote([,])dnl\n \t\t\t.)\n \t\t\t\ttarget_cpu_default2=TARGET_CPU_\"`echo $machine | sed 's/-.*$//'`\"\n \t\t\t\t;;\n-\t\t\t.supersparc | .ultrasparc | .v7 | .v8 | .v9)\n+\t\t\t.supersparc | .hypersparc | .ultrasparc | .v7 | .v8 | .v9)\n \t\t\t\ttarget_cpu_default2=\"TARGET_CPU_$with_cpu\"\n \t\t\t\t;;\n \t\t\t*)"}]}