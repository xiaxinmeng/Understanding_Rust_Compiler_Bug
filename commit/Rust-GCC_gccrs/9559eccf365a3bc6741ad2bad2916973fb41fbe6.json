{"sha": "9559eccf365a3bc6741ad2bad2916973fb41fbe6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU1OWVjY2YzNjVhM2JjNjc0MWFkMmJhZDI5MTY5NzNmYjQxZmJlNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-20T15:50:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-20T15:50:09Z"}, "message": "[multiple changes]\n\n2014-01-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Check_Mode): Reimplement the routine.\n\t(Find_Mode): New routine.\n\n2014-01-20  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch4.adb (Operator_Check): Handle additional\n\tAllow_Integer_Address cases.\n\nFrom-SVN: r206835", "tree": {"sha": "e58a1094a1e0599789d195dc148d2c338c8c3879", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e58a1094a1e0599789d195dc148d2c338c8c3879"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9559eccf365a3bc6741ad2bad2916973fb41fbe6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9559eccf365a3bc6741ad2bad2916973fb41fbe6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9559eccf365a3bc6741ad2bad2916973fb41fbe6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9559eccf365a3bc6741ad2bad2916973fb41fbe6/comments", "author": null, "committer": null, "parents": [{"sha": "92e162285046e62d0662648edd11223d3fbad43d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92e162285046e62d0662648edd11223d3fbad43d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92e162285046e62d0662648edd11223d3fbad43d"}], "stats": {"total": 237, "additions": 165, "deletions": 72}, "files": [{"sha": "05db4c0be5a4fd74e8cd525938aa3f502d1609f7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9559eccf365a3bc6741ad2bad2916973fb41fbe6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9559eccf365a3bc6741ad2bad2916973fb41fbe6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9559eccf365a3bc6741ad2bad2916973fb41fbe6", "patch": "@@ -1,3 +1,13 @@\n+2014-01-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Check_Mode): Reimplement the routine.\n+\t(Find_Mode): New routine.\n+\n+2014-01-20  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch4.adb (Operator_Check): Handle additional\n+\tAllow_Integer_Address cases.\n+\n 2014-01-20  Robert Dewar  <dewar@adacore.com>\n \n \t* gnat_rm.texi (Allow_Integer_Address): Remove note about not"}, {"sha": "c63d423718452d14d7f2af941e5840315a4674ed", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9559eccf365a3bc6741ad2bad2916973fb41fbe6/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9559eccf365a3bc6741ad2bad2916973fb41fbe6/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=9559eccf365a3bc6741ad2bad2916973fb41fbe6", "patch": "@@ -6331,7 +6331,8 @@ package body Sem_Ch4 is\n             --  binary operator case.\n \n             elsif Junk_Operand (R)\n-              or (Nkind (N) in N_Binary_Op and then Junk_Operand (L))\n+              or  -- really mean OR here and not OR ELSE, see above\n+                (Nkind (N) in N_Binary_Op and then Junk_Operand (L))\n             then\n                return;\n \n@@ -6390,11 +6391,42 @@ package body Sem_Ch4 is\n                      Rewrite (L,\n                        Unchecked_Convert_To (Etype (R), Relocate_Node (L)));\n                      Analyze_Arithmetic_Op (N);\n+                     return;\n \n                   else\n                      Resolve (L, Etype (R));\n                   end if;\n+\n                   return;\n+\n+               elsif Allow_Integer_Address\n+                 and then Is_Descendent_Of_Address (Etype (L))\n+                 and then Is_Descendent_Of_Address (Etype (R))\n+                 and then not Error_Posted (N)\n+               then\n+                  declare\n+                     Addr_Type : constant Entity_Id := Etype (L);\n+\n+                  begin\n+                     Rewrite (L,\n+                       Unchecked_Convert_To (\n+                         Standard_Integer, Relocate_Node (L)));\n+                     Rewrite (R,\n+                       Unchecked_Convert_To (\n+                         Standard_Integer, Relocate_Node (R)));\n+                     Analyze_Arithmetic_Op (N);\n+\n+                     --  If this is an operand in an enclosing arithmetic\n+                     --  operation, Convert the result as an address so that\n+                     --  arithmetic folding of address can continue.\n+\n+                     if Nkind (Parent (N)) in N_Op then\n+                        Rewrite (N,\n+                          Unchecked_Convert_To (Addr_Type, Relocate_Node (N)));\n+                     end if;\n+\n+                     return;\n+                  end;\n                end if;\n \n             --  Comparisons on A'Access are common enough to deserve a"}, {"sha": "3da7e002dc26611ce719e03c8be1016589f20133", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 122, "deletions": 71, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9559eccf365a3bc6741ad2bad2916973fb41fbe6/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9559eccf365a3bc6741ad2bad2916973fb41fbe6/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=9559eccf365a3bc6741ad2bad2916973fb41fbe6", "patch": "@@ -953,98 +953,149 @@ package body Sem_Prag is\n          Is_Input : Boolean;\n          Self_Ref : Boolean)\n       is\n-      begin\n-         --  Input\n+         procedure Find_Mode\n+           (Is_Input  : out Boolean;\n+            Is_Output : out Boolean);\n+         --  Find the mode of Item_Id. Flags Is_Input and Is_Output are set\n+         --  depending on the mode.\n \n-         if Is_Input then\n+         ---------------\n+         -- Find_Mode --\n+         ---------------\n \n-            --  IN and IN OUT parameters already have the proper mode to act\n-            --  as input. OUT parameters are valid inputs only when their type\n-            --  is unconstrained or tagged as their discriminants, array bouns\n-            --  or tags can be read. In general, states and variables are\n-            --  considered to have mode IN OUT unless they are classified by\n-            --  pragma [Refined_]Global. In that case, the item must appear in\n-            --  an input global list. OUT parameters of enclosing subprograms\n-            --  behave as read-write variables in which case do not emit an\n-            --  error.\n-\n-            if (Ekind (Item_Id) = E_Out_Parameter\n-                 and then Scope (Item_Id) = Spec_Id\n-                 and then not Is_Unconstrained_Or_Tagged_Item (Item_Id))\n-              or else\n-                (Global_Seen and then not Appears_In (Subp_Inputs, Item_Id))\n-            then\n-               Error_Msg_NE\n-                 (\"item & must have mode IN or `IN OUT`\", Item, Item_Id);\n-            end if;\n+         procedure Find_Mode\n+           (Is_Input  : out Boolean;\n+            Is_Output : out Boolean)\n+         is\n+         begin\n+            Is_Input  := False;\n+            Is_Output := False;\n \n-         --  Self-referential output\n+            --  Abstract state cases\n \n-         elsif Self_Ref then\n+            if Ekind (Item_Id) = E_Abstract_State then\n \n-            --  In general, states and variables are considered to have mode\n-            --  IN OUT unless they are explicitly moded by pragma [Refined_]\n-            --  Global. If this is the case, then the item must appear in both\n-            --  an input and output global list.\n+               --  When pragma Global is present, the mode of the state may be\n+               --  further constrained by setting a more restrictive mode.\n \n-            if Ekind_In (Item_Id, E_Abstract_State, E_Variable) then\n-               if Global_Seen\n-                 and then not\n-                   (Appears_In (Subp_Inputs, Item_Id)\n-                      and then\n-                    Appears_In (Subp_Outputs, Item_Id))\n+               if Global_Seen then\n+                  if Appears_In (Subp_Inputs, Item_Id) then\n+                     Is_Input := True;\n+                  end if;\n+\n+                  if Appears_In (Subp_Outputs, Item_Id) then\n+                     Is_Output := True;\n+                  end if;\n+\n+               --  Otherwise the mode of the state is the one defined in pragma\n+               --  Abstract_State. An In_Out state lacks both Input_Only and\n+               --  Output_Only modes.\n+\n+               elsif not Is_Input_Only_State (Item_Id)\n+                 and then not Is_Output_Only_State (Item_Id)\n                then\n-                  Error_Msg_NE\n-                    (\"item & must have mode `IN OUT`\", Item, Item_Id);\n+                  Is_Input  := True;\n+                  Is_Output := True;\n+\n+               elsif Is_Input_Only_State (Item_Id) then\n+                  Is_Input := True;\n+\n+               elsif Is_Output_Only_State (Item_Id) then\n+                  Is_Output := True;\n                end if;\n \n-            --  A self-referential OUT parameter of an unconstrained or tagged\n-            --  type acts as an input because the discriminants, array bounds\n-            --  or the tag may be read. Note that the presence of [Refined_]\n-            --  Global is not significant here because the item is a parameter.\n-            --  This rule applies only to the formals of the related subprogram\n-            --  as OUT parameters of enclosing subprograms behave as read-write\n-            --  variables and their types do not matter.\n+            --  Parameter cases\n \n-            elsif Ekind (Item_Id) = E_Out_Parameter\n-              and then Scope (Item_Id) = Spec_Id\n-              and then Is_Unconstrained_Or_Tagged_Item (Item_Id)\n-            then\n-               null;\n+            elsif Ekind (Item_Id) = E_In_Parameter then\n+               Is_Input := True;\n \n-            --  The remaining cases are IN, IN OUT, and OUT parameters. To\n-            --  qualify as self-referential item, the parameter must be of\n-            --  mode IN OUT or be an IN OUT or OUT parameter of an enclosing\n-            --  subprogram.\n+            elsif Ekind (Item_Id) = E_In_Out_Parameter then\n+               Is_Input  := True;\n+               Is_Output := True;\n \n-            elsif Scope (Item_Id) = Spec_Id then\n-               if Ekind (Item_Id) /= E_In_Out_Parameter then\n-                  Error_Msg_NE\n-                    (\"item & must have mode `IN OUT`\", Item, Item_Id);\n+            elsif Ekind (Item_Id) = E_Out_Parameter then\n+               if Scope (Item_Id) = Spec_Id then\n+\n+                  --  An OUT parameter of the related subprogram has mode IN\n+                  --  if its type is unconstrained or tagged because array\n+                  --  bounds, discriminants or tags can be read.\n+\n+                  if Is_Unconstrained_Or_Tagged_Item (Item_Id) then\n+                     Is_Input := True;\n+                  end if;\n+\n+                  Is_Output := True;\n+\n+               --  An OUT parameter of an enclosing subprogram behaves as a\n+               --  read-write variable in which case the mode is IN OUT.\n+\n+               else\n+                  Is_Input  := True;\n+                  Is_Output := True;\n                end if;\n \n-            --  Enclosing subprogram parameter\n+            --  Variable cases\n \n-            elsif not Ekind_In (Item_Id, E_In_Out_Parameter,\n-                                         E_Out_Parameter)\n-            then\n+            else pragma Assert (Ekind (Item_Id) = E_Variable);\n+\n+               --  When pragma Global is present, the mode of the variable may\n+               --  be further constrained by setting a more restrictive mode.\n+\n+               if Global_Seen then\n+\n+                  --  A variable has mode IN when its type is unconstrained or\n+                  --  tagged because array bounds, discriminants or tags can be\n+                  --  read.\n+\n+                  if Appears_In (Subp_Inputs, Item_Id)\n+                    or else Is_Unconstrained_Or_Tagged_Item (Item_Id)\n+                  then\n+                     Is_Input := True;\n+                  end if;\n+\n+                  if Appears_In (Subp_Outputs, Item_Id) then\n+                     Is_Output := True;\n+                  end if;\n+\n+               --  Otherwise the variable has a default IN OUT mode\n+\n+               else\n+                  Is_Input  := True;\n+                  Is_Output := True;\n+               end if;\n+            end if;\n+         end Find_Mode;\n+\n+         --  Local variables\n+\n+         Item_Is_Input  : Boolean;\n+         Item_Is_Output : Boolean;\n+\n+      --  Start of processing for Check_Mode\n+\n+      begin\n+         Find_Mode (Item_Is_Input, Item_Is_Output);\n+\n+         --  Input item\n+\n+         if Is_Input then\n+            if not Item_Is_Input then\n                Error_Msg_NE\n-                 (\"item & must have mode `IN OUT` or `OUT`\", Item, Item_Id);\n+                 (\"item & must have mode `IN` or `IN OUT`\", Item, Item_Id);\n             end if;\n \n-         --  Output\n+         --  Self-referential item\n \n-         --  IN OUT and OUT parameters already have the proper mode to act as\n-         --  output. In general, states and variables are considered to have\n-         --  mode IN OUT unless they are moded by pragma [Refined_]Global. In\n-         --  that case, the item must appear in an output global list.\n+         elsif Self_Ref then\n+            if not Item_Is_Input or else not Item_Is_Output then\n+               Error_Msg_NE (\"item & must have mode `IN OUT`\", Item, Item_Id);\n+            end if;\n \n-         elsif Ekind (Item_Id) = E_In_Parameter\n-           or else\n-             (Global_Seen and then not Appears_In (Subp_Outputs, Item_Id))\n-         then\n+         --  Output item\n+\n+         elsif not Item_Is_Output then\n             Error_Msg_NE\n-              (\"item & must have mode OUT or `IN OUT`\", Item, Item_Id);\n+              (\"item & must have mode `OUT` or `IN OUT`\", Item, Item_Id);\n          end if;\n       end Check_Mode;\n "}]}