{"sha": "8b634749abb593dd61bbb3b4c0c8eb6861b92c65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI2MzQ3NDlhYmI1OTNkZDYxYmJiM2I0YzBjOGViNjg2MWI5MmM2NQ==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@redhat.com", "date": "2001-01-01T00:37:09Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2001-01-01T00:37:09Z"}, "message": "loop.h (REG_IV_CLASS): New accessor macro.\n\n\t* loop.h (REG_IV_CLASS): New accessor macro.\n\t* loop.c (REG_IV_CLASS): Use it instead of reg_iv_class array.\n\t* unroll.c (REG_IV_CLASS): Likewise.\n\nFrom-SVN: r38580", "tree": {"sha": "3b42886d723fcd6825f532d5914608cc58485318", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b42886d723fcd6825f532d5914608cc58485318"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b634749abb593dd61bbb3b4c0c8eb6861b92c65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b634749abb593dd61bbb3b4c0c8eb6861b92c65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b634749abb593dd61bbb3b4c0c8eb6861b92c65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b634749abb593dd61bbb3b4c0c8eb6861b92c65/comments", "author": null, "committer": null, "parents": [{"sha": "b4ae520152976c22948e7c90360dcd93aacf2f88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4ae520152976c22948e7c90360dcd93aacf2f88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4ae520152976c22948e7c90360dcd93aacf2f88"}], "stats": {"total": 37, "additions": 22, "deletions": 15}, "files": [{"sha": "fa865355a189ae01c6c5cd91673cf2153bd46461", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b634749abb593dd61bbb3b4c0c8eb6861b92c65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b634749abb593dd61bbb3b4c0c8eb6861b92c65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b634749abb593dd61bbb3b4c0c8eb6861b92c65", "patch": "@@ -1,3 +1,9 @@\n+2001-01-01  Michael Hayes  <mhayes@redhat.com>\n+\n+\t* loop.h (REG_IV_CLASS): New accessor macro.\n+\t* loop.c (REG_IV_CLASS): Use it instead of reg_iv_class array.\n+\t* unroll.c (REG_IV_CLASS): Likewise.\n+\t\n Sun Dec 31 19:20:51 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* dwarf2out.c (loc_descriptor_from_tree, case WITH_RECORD_EXPR): New.\n@@ -33,7 +39,6 @@ Sun Dec 31 19:20:51 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(loop_movables_add, loop_movables_free): New functions.\n \t(scan_loop): Use xmalloc instead of alloca for movables.\n \tCall loop_movables_free.\n-\t\n \n \t* loop.c (debug_loops): New.\n "}, {"sha": "b5da95ed2465308db33a511a16e242d7be041003", "filename": "gcc/loop.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b634749abb593dd61bbb3b4c0c8eb6861b92c65/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b634749abb593dd61bbb3b4c0c8eb6861b92c65/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=8b634749abb593dd61bbb3b4c0c8eb6861b92c65", "patch": "@@ -3741,7 +3741,7 @@ loop_bivs_init_find (loop)\n \t  && (test = get_condition_for_loop (loop, p)) != 0\n \t  && GET_CODE (XEXP (test, 0)) == REG\n \t  && REGNO (XEXP (test, 0)) < max_reg_before_loop\n-\t  && (bl = ivs->reg_biv_class[REGNO (XEXP (test, 0))]) != 0\n+\t  && (bl = REG_IV_CLASS (ivs, REGNO (XEXP (test, 0)))) != 0\n \t  && valid_initial_value_p (XEXP (test, 1), p, call_seen, loop->start)\n \t  && bl->init_insn == 0)\n \t{\n@@ -4915,7 +4915,7 @@ record_biv (loop, v, insn, dest_reg, inc_val, mult_val, location,\n   /* Add this to the reg's iv_class, creating a class\n      if this is the first incrementation of the reg.  */\n \n-  bl = ivs->reg_biv_class[REGNO (dest_reg)];\n+  bl = REG_IV_CLASS (ivs, REGNO (dest_reg));\n   if (bl == 0)\n     {\n       /* Create and initialize new iv_class.  */\n@@ -4946,7 +4946,7 @@ record_biv (loop, v, insn, dest_reg, inc_val, mult_val, location,\n       ivs->loop_iv_list = bl;\n \n       /* Put it in the array of biv register classes.  */\n-      ivs->reg_biv_class[REGNO (dest_reg)] = bl;\n+      REG_IV_CLASS (ivs, REGNO (dest_reg)) = bl;\n     }\n \n   /* Update IV_CLASS entry for this biv.  */\n@@ -5075,7 +5075,7 @@ record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, ext_val,\n \n   /* Add the giv to the class of givs computed from one biv.  */\n \n-  bl = ivs->reg_biv_class[REGNO (src_reg)];\n+  bl = REG_IV_CLASS (ivs, REGNO (src_reg));\n   if (bl)\n     {\n       v->next_iv = bl->giv;\n@@ -5267,7 +5267,7 @@ check_final_value (loop, v)\n   struct iv_class *bl;\n   rtx final_value = 0;\n \n-  bl = ivs->reg_biv_class[REGNO (v->src_reg)];\n+  bl = REG_IV_CLASS (ivs, REGNO (v->src_reg));\n \n   /* DEST_ADDR givs will never reach here, because they are always marked\n      replaceable above in record_giv.  */\n@@ -8225,7 +8225,8 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where)\n \t      if (v->ignore || v->maybe_dead || v->mode != mode)\n \t\tcontinue;\n \n-\t      for (tv = ivs->reg_biv_class[REGNO (arg)]->giv; tv; tv = tv->next_iv)\n+\t      for (tv = REG_IV_CLASS (ivs, REGNO (arg))->giv; tv; \n+\t\t   tv = tv->next_iv)\n \t\tif (! tv->ignore && ! tv->maybe_dead\n \t\t    && rtx_equal_p (tv->mult_val, v->mult_val)\n \t\t    && rtx_equal_p (tv->add_val, v->add_val)\n@@ -8323,7 +8324,7 @@ record_initial (dest, set, data)\n       || REG_IV_TYPE (ivs, REGNO (dest)) != BASIC_INDUCT)\n     return;\n \n-  bl = ivs->reg_biv_class[REGNO (dest)];\n+  bl = REG_IV_CLASS (ivs, REGNO (dest));\n \n   /* If this is the first set found, record it.  */\n   if (bl->init_insn == 0)"}, {"sha": "7ca9b06a0ff82b1cee34cc559c12384ae5792f7a", "filename": "gcc/loop.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b634749abb593dd61bbb3b4c0c8eb6861b92c65/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b634749abb593dd61bbb3b4c0c8eb6861b92c65/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=8b634749abb593dd61bbb3b4c0c8eb6861b92c65", "patch": "@@ -363,6 +363,7 @@ extern FILE *loop_dump_stream;\n   (*(enum iv_mode *) &VARRAY_INT(ivs->reg_iv_type, (n)))\n #define REG_IV_INFO(ivs, n) \\\n   (*(struct induction **) &VARRAY_GENERIC_PTR(ivs->reg_iv_info, (n)))\n+#define REG_IV_CLASS(ivs, n) ivs->reg_biv_class[n]\n \n /* Forward declarations for non-static functions declared in loop.c and\n    unroll.c.  */"}, {"sha": "1c66b1ff8291d6c067b44051892e3a99feb88903", "filename": "gcc/unroll.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b634749abb593dd61bbb3b4c0c8eb6861b92c65/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b634749abb593dd61bbb3b4c0c8eb6861b92c65/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=8b634749abb593dd61bbb3b4c0c8eb6861b92c65", "patch": "@@ -1770,7 +1770,7 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n \t      unsigned int regno = REGNO (SET_DEST (set));\n \n \t      v = addr_combined_regs[REGNO (SET_DEST (set))];\n-\t      bl = ivs->reg_biv_class[REGNO (v->src_reg)];\n+\t      bl = REG_IV_CLASS (ivs, REGNO (v->src_reg));\n \n \t      /* Although the giv_inc amount is not needed here, we must call\n \t\t calculate_giv_inc here since it might try to delete the\n@@ -1915,7 +1915,7 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n \t\t  if (regno < max_reg_before_loop\n \t\t      && REG_IV_TYPE (ivs, regno) == BASIC_INDUCT)\n \t\t    {\n-\t\t      giv_src_reg = ivs->reg_biv_class[regno]->biv->src_reg;\n+\t\t      giv_src_reg = REG_IV_CLASS (ivs, regno)->biv->src_reg;\n \t\t      giv_dest_reg = giv_src_reg;\n \t\t    }\n \n@@ -3030,7 +3030,7 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t{\n \t  int count = 1;\n \t  if (! v->ignore)\n-\t    count = ivs->reg_biv_class[REGNO (v->src_reg)]->biv_count;\n+\t    count = REG_IV_CLASS (ivs, REGNO (v->src_reg))->biv_count;\n \n \t  splittable_regs_updates[REGNO (v->new_reg)] = count;\n \t}\n@@ -3226,7 +3226,7 @@ final_giv_value (loop, v)\n   rtx loop_end = loop->end;\n   unsigned HOST_WIDE_INT n_iterations = LOOP_INFO (loop)->n_iterations;\n \n-  bl = ivs->reg_biv_class[REGNO (v->src_reg)];\n+  bl = REG_IV_CLASS (ivs, REGNO (v->src_reg));\n \n   /* The final value for givs which depend on reversed bivs must be calculated\n      differently than for ordinary givs.  In this case, there is already an\n@@ -3598,7 +3598,7 @@ loop_iterations (loop)\n \tabort ();\n \n       /* Grab initial value, only useful if it is a constant.  */\n-      bl = ivs->reg_biv_class[REGNO (iteration_var)];\n+      bl = REG_IV_CLASS (ivs, REGNO (iteration_var));\n       initial_value = bl->initial_value;\n \n       increment = biv_total_increment (bl);\n@@ -3612,7 +3612,7 @@ loop_iterations (loop)\n       if (REGNO (v->src_reg) >= max_reg_before_loop)\n \tabort ();\n \n-      bl = ivs->reg_biv_class[REGNO (v->src_reg)];\n+      bl = REG_IV_CLASS (ivs, REGNO (v->src_reg));\n \n       /* Increment value is mult_val times the increment value of the biv.  */\n \n@@ -4014,7 +4014,7 @@ remap_split_bivs (loop, x)\n #endif\n       if (REGNO (x) < max_reg_before_loop\n \t  && REG_IV_TYPE (ivs, REGNO (x)) == BASIC_INDUCT)\n-\treturn ivs->reg_biv_class[REGNO (x)]->biv->src_reg;\n+\treturn REG_IV_CLASS (ivs, REGNO (x))->biv->src_reg;\n       break;\n \n     default:"}]}