{"sha": "92582b753e34fd574b6a5672b2f82979c966187a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI1ODJiNzUzZTM0ZmQ1NzRiNmE1NjcyYjJmODI5NzljOTY2MTg3YQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2011-10-17T09:59:12Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2011-10-17T09:59:12Z"}, "message": "Generate virtual locations for tokens\n\nThis second instalment uses the infrastructure of the previous patch\nto allocate a macro map for each macro expansion and assign a virtual\nlocation to each token resulting from the expansion.\n\nTo date when cpp_get_token comes across a token that happens to be a\nmacro, the macro expander kicks in, expands the macro, pushes the\nresulting tokens onto a \"token context\" and returns a dummy padding\ntoken. The next call to cpp_get_token goes look into the token context\nfor the next token [which is going to result from the previous macro\nexpansion] and returns it.  If the token is a macro, the macro expander\nkicks in and you know the story.\n\nThis patch piggy-backs on that macro expansion process, so to speak.\nFirst it modifies the macro expander to make it create a macro map for\neach macro expansion. It then allocates a virtual location for each\nresulting token.  Virtual locations of tokens resulting from macro\nexpansions are then stored on a special kind of context called an\n\"expanded tokens context\".  In other words, in an expanded tokens\ncontext, there are tokens resulting from macro expansion and their\nassociated virtual locations.  cpp_get_token_with_location is modified\nto return the virtual location of tokens resulting from macro\nexpansion.  Note that once all tokens from an expanded token context have\nbeen consumed and the context and is freed, the memory used to store the\nvirtual locations of the tokens held in that context is freed as well.\nThis helps reducing the overall peak memory consumption.\n\nThe client code that was getting macro expansion point location from\ncpp_get_token_with_location now gets virtual location from it. Those\nvirtual locations can in turn be resolved into the different\ninteresting physical locations thanks to the linemap API exposed by\nthe previous patch.\n\nExpensive progress. Possibly. So this whole virtual location\nallocation business is switched off by default. So by default no\nextended token is created. No extended token context is created\neither. One has to use -ftrack-macro-expansion to switch this on. This\ncomplicates the code but I believe it can be useful as some of our\nfriends found out at http://llvm.org/bugs/show_bug.cgi?id=5610\n\nThe patch tries to reduce the memory consumption by freeing some token\ncontext memory that was being reused before. I didn't notice any\ncompilation slow down due to this immediate freeing on my GNU/Linux\nsystem.\n\nAs no client code tries to resolve virtual locations to anything but\nwhat was being done before, no new test case has been added.\n\nCo-Authored-By: Dodji Seketeli <dodji@redhat.com>\n\nFrom-SVN: r180082", "tree": {"sha": "372dab78d59e4e58eead8df4f751726cec9b98b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/372dab78d59e4e58eead8df4f751726cec9b98b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92582b753e34fd574b6a5672b2f82979c966187a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92582b753e34fd574b6a5672b2f82979c966187a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92582b753e34fd574b6a5672b2f82979c966187a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92582b753e34fd574b6a5672b2f82979c966187a/comments", "author": null, "committer": null, "parents": [{"sha": "46427374e1ffdcb2781d99abc63ebd3ab7af6110", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46427374e1ffdcb2781d99abc63ebd3ab7af6110", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46427374e1ffdcb2781d99abc63ebd3ab7af6110"}], "stats": {"total": 1587, "additions": 1434, "deletions": 153}, "files": [{"sha": "4c3b76d4fcc89d5da09495a17a9b21ed1a4289ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92582b753e34fd574b6a5672b2f82979c966187a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92582b753e34fd574b6a5672b2f82979c966187a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92582b753e34fd574b6a5672b2f82979c966187a", "patch": "@@ -1,3 +1,10 @@\n+2011-10-15  Tom Tromey  <tromey@redhat.com>\n+\t    Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* doc/cppopts.texi (-ftrack-macro-expansion): Document new option.\n+\t* doc/invoke.texi (-ftrack-macro-expansion): Add this to the list of\n+\tpreprocessor related options.\n+\n 2011-10-15  Tom Tromey  <tromey@redhat>\n \t    Dodji Seketeli  <dodji@redhat.com>\n "}, {"sha": "789e44856229a68c67f87d71f50ba4c17adcb2d4", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92582b753e34fd574b6a5672b2f82979c966187a/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92582b753e34fd574b6a5672b2f82979c966187a/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=92582b753e34fd574b6a5672b2f82979c966187a", "patch": "@@ -1,3 +1,12 @@\n+2011-10-15  Tom Tromey  <tromey@redhat.com>\n+\t    Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* c.opt (ftrack-macro-expansion): New option. Handle it with and\n+\twithout argument.\n+\t* c-opts.c (c_common_handle_option)<case\n+\tOPT_ftrack_macro_expansion_, case OPT_ftrack_macro_expansion>: New\n+\tcases. Handle -ftrack-macro-expansion with and without argument.\n+\n 2011-10-15  Tom Tromey  <tromey@redhat.com>\n \t    Dodji Seketeli  <dodji@redhat.com>\n "}, {"sha": "3184539adca983dac4697dac5b3940dcbdf08ed2", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92582b753e34fd574b6a5672b2f82979c966187a/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92582b753e34fd574b6a5672b2f82979c966187a/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=92582b753e34fd574b6a5672b2f82979c966187a", "patch": "@@ -628,6 +628,18 @@ c_common_handle_option (size_t scode, const char *arg, int value,\n       cpp_opts->preprocessed = value;\n       break;\n \n+    case OPT_ftrack_macro_expansion:\n+      if (value)\n+\tvalue = 2;\n+      /* Fall Through.  */\n+\n+    case OPT_ftrack_macro_expansion_:\n+      if (arg && *arg != '\\0')\n+\tcpp_opts->track_macro_expansion = value;\n+      else\n+\tcpp_opts->track_macro_expansion = 2;\n+      break;\n+\n     case OPT_frepo:\n       flag_use_repository = value;\n       if (value)"}, {"sha": "d977115b7af611cc22a67fdcb181cd45eaa8f355", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92582b753e34fd574b6a5672b2f82979c966187a/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92582b753e34fd574b6a5672b2f82979c966187a/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=92582b753e34fd574b6a5672b2f82979c966187a", "patch": "@@ -945,6 +945,14 @@ fpreprocessed\n C ObjC C++ ObjC++\n Treat the input file as already preprocessed\n \n+ftrack-macro-expansion\n+C ObjC C++ ObjC++ JoinedOrMissing RejectNegative UInteger\n+; converted into ftrack-macro-expansion=\n+\n+ftrack-macro-expansion=\n+C ObjC C++ ObjC++ JoinedOrMissing RejectNegative UInteger\n+-ftrack-macro-expansion=<0|1|2>  Track locations of tokens coming from macro expansion and display them in error messages\n+\n fpretty-templates\n C++ ObjC++ Var(flag_pretty_templates) Init(1)\n -fno-pretty-templates Do not pretty-print template specializations as the template signature followed by the arguments"}, {"sha": "b2252367ef5301ab6aacd31e667931a531b49ccb", "filename": "gcc/doc/cppopts.texi", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92582b753e34fd574b6a5672b2f82979c966187a/gcc%2Fdoc%2Fcppopts.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92582b753e34fd574b6a5672b2f82979c966187a/gcc%2Fdoc%2Fcppopts.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcppopts.texi?ref=92582b753e34fd574b6a5672b2f82979c966187a", "patch": "@@ -583,6 +583,24 @@ correct column numbers in warnings or errors, even if tabs appear on the\n line.  If the value is less than 1 or greater than 100, the option is\n ignored.  The default is 8.\n \n+@item -ftrack-macro-expansion@r{[}=@var{level}@r{]}\n+@opindex ftrack-macro-expansion\n+Track locations of tokens across macro expansions. This allows the\n+compiler to emit diagnostic about the current macro expansion stack\n+when a compilation error occurs in a macro expansion. Using this\n+option makes the preprocessor and the compiler consume more\n+memory. The @var{level} parameter can be used to choose the level of\n+precision of token location tracking thus decreasing the memory\n+consumption if necessary. Value @samp{0} of @var{level} de-activates\n+this option just as if no @option{-ftrack-macro-expansion} was present\n+on the command line. Value @samp{1} tracks tokens locations in a\n+degraded mode for the sake of minimal memory overhead. In this mode\n+all tokens resulting from the expansion of an argument of a\n+function-like macro have the same location. Value @samp{2} tracks\n+tokens locations completely. This value is the most memory hungry.\n+When this option is given no argument, the default parameter value is\n+@samp{2}.\n+\n @item -fexec-charset=@var{charset}\n @opindex fexec-charset\n @cindex character set, execution"}, {"sha": "b2c26edeadec81720c5bd66953e623a286e839cb", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92582b753e34fd574b6a5672b2f82979c966187a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92582b753e34fd574b6a5672b2f82979c966187a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=92582b753e34fd574b6a5672b2f82979c966187a", "patch": "@@ -429,9 +429,9 @@ Objective-C and Objective-C++ Dialects}.\n -iwithprefixbefore @var{dir}  -isystem @var{dir} @gol\n -imultilib @var{dir} -isysroot @var{dir} @gol\n -M  -MM  -MF  -MG  -MP  -MQ  -MT  -nostdinc  @gol\n--P  -fworking-directory  -remap @gol\n--trigraphs  -undef  -U@var{macro}  -Wp,@var{option} @gol\n--Xpreprocessor @var{option}}\n+-P -ftrack-macro-expansion -fworking-directory @gol\n+-remap -trigraphs  -undef  -U@var{macro}  @gol\n+-Wp,@var{option} -Xpreprocessor @var{option}}\n \n @item Assembler Option\n @xref{Assembler Options,,Passing Options to the Assembler}."}, {"sha": "89af274d2da6c978bf75cc7221ad7e728c7ed7a2", "filename": "gcc/input.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92582b753e34fd574b6a5672b2f82979c966187a/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92582b753e34fd574b6a5672b2f82979c966187a/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=92582b753e34fd574b6a5672b2f82979c966187a", "patch": "@@ -1,5 +1,5 @@\n /* Data and functions related to line maps and input files.\n-   Copyright (C) 2004, 2007, 2008, 2009, 2010\n+   Copyright (C) 2004, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n \n This file is part of GCC."}, {"sha": "5eab7b027bbe0349b25ea4bab254531cd7905d99", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=92582b753e34fd574b6a5672b2f82979c966187a", "patch": "@@ -1,3 +1,82 @@\n+2011-10-15  Tom Tromey  <tromey@redhat.com>\n+\t    Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* include/cpplib.h (struct cpp_options)<track_macro_expansion>:\n+\tNew option.\n+\t* internal.h (struct macro_context): New struct.\n+\t(enum context_tokens_kind): New enum.\n+\t(struct cpp_context)<tokens_kind>: New member of type enum\n+\tcontext_tokens_kind.\n+\t(struct cpp_context)<macro>: Remove this.  Replace it with an enum\n+\tof macro and  macro_context.\n+\t(struct cpp_context)<direct_p>: Remove.\n+\t(_cpp_remaining_tokens_num_in_context): Declare new function.\n+\t* directives.c (destringize_and_run): Adjust.\n+\t* lex.c (_cpp_remaining_tokens_num_in_context)\n+\t(_cpp_token_from_context_at): Define new functions\n+\t(cpp_peek_token): Use them.\n+\t* init.c (cpp_create_reader): Initialize the base context to zero.\n+\t(_cpp_token_from_context_at): Define new static function.\n+\t(cpp_peek_token): Use new _cpp_remaining_tokens_num_in_context and\n+\t_cpp_token_from_context_at.\n+\t* macro.c (struct macro_arg)<virt_locs, expanded_virt_locs>: New\n+\tmembers.\n+\t(enum macro_arg_token_kind): New enum.\n+\t(struct macro_arg_token_iter): New struct.\n+\t(maybe_adjust_loc_for_trad_cpp, push_extended_tokens_context)\n+\t(alloc_expanded_arg_mem, ensure_expanded_arg_room)\n+\t(delete_macro_args, set_arg_token, get_arg_token_location)\n+\t(arg_token_ptr_at, macro_arg_token_iter_init)\n+\t(macro_arg_token_iter_get_token)\n+\t(macro_arg_token_iter_get_location, macro_arg_token_iter_forward)\n+\t(expanded_token_index, tokens_buff_new, tokens_buff_count)\n+\t(tokens_buff_last_token_ptr, tokens_buff_put_token_to)\n+\t(tokens_buff_add_token, tokens_buff_remove_last_token)\n+\t(reached_end_of_context, consume_next_token_from_context): New\n+\tstatic functions.\n+\t(cpp_get_token_1): New static function. Split and extended from\n+\tcpp_get_token.  Use reached_end_of_context and\n+\tconsume_next_token_from_context.  Unify its return point.  Move\n+\tthe location tweaking from cpp_get_token_with_location in here.\n+\t(cpp_get_token): Use cpp_get_token_1\n+\t(stringify_arg): Use the new arg_token_at.\n+\t(paste_all_tokens): Support tokens coming from extended tokens\n+\tcontexts.\n+\t(collect_args): Return the number of collected arguments, by\n+\tparameter.  Store virtual locations of tokens that constitute the\n+\tcollected args.\n+\t(funlike_invocation_p): Return the number of collected arguments,\n+\tby parameter.\n+\t(enter_macro_context): Add a parameter for macro expansion point.\n+\tPass it to replace_args and to the \"used\" cpp callback.  Get the\n+\tnumber of function-like macro arguments from funlike_invocation_p,\n+\tpass it to the new delete_macro_args to free the memory used by\n+\tmacro args.  When -ftrack-macro-expansion is in effect, for macros\n+\tthat have no arguments, create a macro map for the macro expansion\n+\tand use it to allocate proper virtual locations for tokens\n+\tresulting from the expansion.  Push an extended tokens context\n+\tcontaining the tokens resulting from macro expansion and their\n+\tvirtual locations.\n+\t(replace_args): Rename the different variables named 'count' into\n+\tvariables with more meaningful names.  Create a macro map;\n+\tallocate virtual locations of tokens resulting from this\n+\texpansion.  Use macro_arg_token_iter to iterate over tokens of a\n+\tgiven macro.  Handle the case of the argument of\n+\t-ftrack-macro-expansion being < 2.  Don't free macro arguments\n+\tmemory resulting from expand_arg here, as these are freed by the\n+\tcaller of replace_arg using delete_macro_args now.  Push extended\n+\ttoken context.\n+\t(next_context, push_ptoken_context, _cpp_push_token_context)\n+\t(_cpp_push_text_context): Properly initialize the context.\n+\t(expand_arg): Use the new alloc_expanded_arg_mem,\n+\tpush_extended_tokens_context, cpp_get_token_1, and set_arg_token.\n+\t(_cpp_pop_context): Really free the memory held by the context.\n+\tHandle freeing memory used by extended tokens contexts.\n+\t(cpp_get_token_with_location): Use cpp_get_token_1.\n+\t(cpp_sys_macro_p): Adjust.\n+\t(_cpp_backup_tokens): Support the new kinds of token contexts.\n+\t* traditional.c (recursive_macro): Adjust.\n+\n 2011-10-15  Tom Tromey  <tromey@redhat>\n \t    Dodji Seketeli  <dodji@redhat.com>\n "}, {"sha": "0510c6e3a8ef1480b03c5e51f8b4d4fe7f8e9a09", "filename": "libcpp/directives.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=92582b753e34fd574b6a5672b2f82979c966187a", "patch": "@@ -1,7 +1,7 @@\n /* CPP Library. (Directive handling.)\n    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n    1999, 2000, 2001, 2002, 2003, 2004, 2005,\n-   2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+   2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n    Contributed by Per Bothner, 1994-95.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n@@ -1742,7 +1742,7 @@ destringize_and_run (cpp_reader *pfile, const cpp_string *in)\n   saved_cur_run = pfile->cur_run;\n \n   pfile->context = XNEW (cpp_context);\n-  pfile->context->macro = 0;\n+  pfile->context->c.macro = 0;\n   pfile->context->prev = 0;\n   pfile->context->next = 0;\n "}, {"sha": "3e01c1121408d8a8816e0947c0755cdbbc398614", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=92582b753e34fd574b6a5672b2f82979c966187a", "patch": "@@ -393,6 +393,14 @@ struct cpp_options\n      bother trying to do macro expansion and whatnot.  */\n   unsigned char preprocessed;\n \n+  /* Nonzero means we are tracking locations of tokens involved in\n+     macro expansion. 1 Means we track the location in degraded mode\n+     where we do not track locations of tokens resulting from the\n+     expansion of arguments of function-like macro.  2 Means we do\n+     track all macro expansions. This last option is the one that\n+     consumes the highest amount of memory.  */\n+  unsigned char track_macro_expansion;\n+\n   /* Nonzero means handle C++ alternate operator names.  */\n   unsigned char operator_names;\n "}, {"sha": "724f3f0f8b0e61af8c7ab376c8650091438e4d3d", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=92582b753e34fd574b6a5672b2f82979c966187a", "patch": "@@ -1,5 +1,5 @@\n /* Map logical line numbers to (source file, line number) pairs.\n-   Copyright (C) 2001, 2003, 2004, 2007, 2008, 2009, 2010\n+   Copyright (C) 2001, 2003, 2004, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it"}, {"sha": "6771e638970036d1cdc0db2611e38e8f9c0bf325", "filename": "libcpp/init.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finit.c?ref=92582b753e34fd574b6a5672b2f82979c966187a", "patch": "@@ -154,6 +154,7 @@ cpp_create_reader (enum c_lang lang, hash_table *table,\n   init_library ();\n \n   pfile = XCNEW (cpp_reader);\n+  memset (&pfile->base_context, 0, sizeof (pfile->base_context));\n \n   cpp_set_lang (pfile, lang);\n   CPP_OPTION (pfile, warn_multichar) = 1;\n@@ -213,7 +214,7 @@ cpp_create_reader (enum c_lang lang, hash_table *table,\n \n   /* Initialize the base context.  */\n   pfile->context = &pfile->base_context;\n-  pfile->base_context.macro = 0;\n+  pfile->base_context.c.macro = 0;\n   pfile->base_context.prev = pfile->base_context.next = 0;\n \n   /* Aligned and unaligned storage.  */"}, {"sha": "6fb2606c9b8f57b0c8cf78d884f71a42d77f75fc", "filename": "libcpp/internal.h", "status": "modified", "additions": 53, "deletions": 5, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=92582b753e34fd574b6a5672b2f82979c966187a", "patch": "@@ -1,6 +1,6 @@\n /* Part of CPP library.\n    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007,\n-   2008, 2009, 2010 Free Software Foundation, Inc.\n+   2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -139,6 +139,40 @@ struct tokenrun\n #define CUR(c) ((c)->u.trad.cur)\n #define RLIMIT(c) ((c)->u.trad.rlimit)\n \n+/* This describes some additional data that is added to the macro\n+   token context of type cpp_context, when -ftrack-macro-expansion is\n+   on.  */\n+typedef struct\n+{\n+  /* The node of the macro we are referring to.  */\n+  cpp_hashnode *macro_node;\n+  /* This buffer contains an array of virtual locations.  The virtual\n+     location at index 0 is the virtual location of the token at index\n+     0 in the current instance of cpp_context; similarly for all the\n+     other virtual locations.  */\n+  source_location *virt_locs;\n+  /* This is a pointer to the current virtual location.  This is used\n+     to iterate over the virtual locations while we iterate over the\n+     tokens they belong to.  */\n+  source_location *cur_virt_loc;\n+} macro_context;\n+\n+/* The kind of tokens carried by a cpp_context.  */\n+enum context_tokens_kind {\n+  /* This is the value of cpp_context::tokens_kind if u.iso.first\n+     contains an instance of cpp_token **.  */\n+  TOKENS_KIND_INDIRECT,\n+  /* This is the value of cpp_context::tokens_kind if u.iso.first\n+     contains an instance of cpp_token *.  */\n+  TOKENS_KIND_DIRECT,\n+  /* This is the value of cpp_context::tokens_kind when the token\n+     context contains tokens resulting from macro expansion.  In that\n+     case struct cpp_context::macro points to an instance of struct\n+     macro_context.  This is used only when the\n+     -ftrack-macro-expansion flag is on.  */\n+  TOKENS_KIND_EXTENDED\n+};\n+\n typedef struct cpp_context cpp_context;\n struct cpp_context\n {\n@@ -168,11 +202,24 @@ struct cpp_context\n      When the context is popped, the buffer is released.  */\n   _cpp_buff *buff;\n \n-  /* For a macro context, the macro node, otherwise NULL.  */\n-  cpp_hashnode *macro;\n+  /* If tokens_kind is TOKEN_KIND_EXTENDED, then (as we thus are in a\n+     macro context) this is a pointer to an instance of macro_context.\n+     Otherwise if tokens_kind is *not* TOKEN_KIND_EXTENDED, then, if\n+     we are in a macro context, this is a pointer to an instance of\n+     cpp_hashnode, representing the name of the macro this context is\n+     for.  If we are not in a macro context, then this is just NULL.\n+     Note that when tokens_kind is TOKEN_KIND_EXTENDED, the memory\n+     used by the instance of macro_context pointed to by this member\n+     is de-allocated upon de-allocation of the instance of struct\n+     cpp_context.  */\n+  union\n+  {\n+    macro_context *mc;\n+    cpp_hashnode *macro;\n+  } c;\n \n-  /* True if utoken element is token, else ptoken.  */\n-  bool direct_p;\n+  /* This determines the type of tokens held by this context.  */\n+  enum context_tokens_kind tokens_kind;\n };\n \n struct lexer_state\n@@ -605,6 +652,7 @@ extern cpp_token *_cpp_lex_direct (cpp_reader *);\n extern int _cpp_equiv_tokens (const cpp_token *, const cpp_token *);\n extern void _cpp_init_tokenrun (tokenrun *, unsigned int);\n extern cpp_hashnode *_cpp_lex_identifier (cpp_reader *, const char *);\n+extern int _cpp_remaining_tokens_num_in_context (cpp_reader *);\n \n /* In init.c.  */\n extern void _cpp_maybe_push_include_file (cpp_reader *);"}, {"sha": "cd6ae9f67ddd049422e6866973df8032077c6a64", "filename": "libcpp/lex.c", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=92582b753e34fd574b6a5672b2f82979c966187a", "patch": "@@ -1703,6 +1703,38 @@ next_tokenrun (tokenrun *run)\n   return run->next;\n }\n \n+/* Return the number of not yet processed token in the the current\n+   context.  */\n+int\n+_cpp_remaining_tokens_num_in_context (cpp_reader *pfile)\n+{\n+  cpp_context *context = pfile->context;\n+  if (context->tokens_kind == TOKENS_KIND_DIRECT)\n+    return ((LAST (context).token - FIRST (context).token)\n+\t    / sizeof (cpp_token));\n+  else if (context->tokens_kind == TOKENS_KIND_INDIRECT\n+\t   || context->tokens_kind == TOKENS_KIND_EXTENDED)\n+    return ((LAST (context).ptoken - FIRST (context).ptoken)\n+\t    / sizeof (cpp_token *));\n+  else\n+      abort ();\n+}\n+\n+/* Returns the token present at index INDEX in the current context.\n+   If INDEX is zero, the next token to be processed is returned.  */\n+static const cpp_token*\n+_cpp_token_from_context_at (cpp_reader *pfile, int index)\n+{\n+  cpp_context *context = pfile->context;\n+  if (context->tokens_kind == TOKENS_KIND_DIRECT)\n+    return &(FIRST (context).token[index]);\n+  else if (context->tokens_kind == TOKENS_KIND_INDIRECT\n+\t   || context->tokens_kind == TOKENS_KIND_EXTENDED)\n+    return FIRST (context).ptoken[index];\n+ else\n+   abort ();\n+}\n+\n /* Look ahead in the input stream.  */\n const cpp_token *\n cpp_peek_token (cpp_reader *pfile, int index)\n@@ -1714,15 +1746,10 @@ cpp_peek_token (cpp_reader *pfile, int index)\n   /* First, scan through any pending cpp_context objects.  */\n   while (context->prev)\n     {\n-      ptrdiff_t sz = (context->direct_p\n-                      ? LAST (context).token - FIRST (context).token\n-                      : LAST (context).ptoken - FIRST (context).ptoken);\n+      ptrdiff_t sz = _cpp_remaining_tokens_num_in_context (pfile);\n \n       if (index < (int) sz)\n-        return (context->direct_p\n-                ? FIRST (context).token + index\n-                : *(FIRST (context).ptoken + index));\n-\n+        return _cpp_token_from_context_at (pfile, index);\n       index -= (int) sz;\n       context = context->prev;\n     }"}, {"sha": "fe07c16c37d76dce5d98c9eaaab0e00621133086", "filename": "libcpp/line-map.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=92582b753e34fd574b6a5672b2f82979c966187a", "patch": "@@ -1,5 +1,5 @@\n /* Map logical line numbers to (source file, line number) pairs.\n-   Copyright (C) 2001, 2003, 2004, 2007, 2008, 2009\n+   Copyright (C) 2001, 2003, 2004, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it"}, {"sha": "d760383b548692c05061d2d3d610986644ce24f3", "filename": "libcpp/macro.c", "status": "modified", "additions": 1195, "deletions": 131, "changes": 1326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=92582b753e34fd574b6a5672b2f82979c966187a", "patch": "@@ -1,7 +1,7 @@\n /* Part of CPP library.  (Macro and #define handling.)\n    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1998,\n    1999, 2000, 2001, 2002, 2003, 2004, 2005,\n-   2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+   2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n    Written by Per Bothner, 1994.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n@@ -30,35 +30,124 @@ along with this program; see the file COPYING3.  If not see\n #include \"internal.h\"\n \n typedef struct macro_arg macro_arg;\n+/* This structure represents the tokens of a macro argument.  These\n+   tokens can be macro themselves, in which case they can be either\n+   expanded or unexpanded.  When they are expanded, this data\n+   structure keeps both the expanded and unexpanded forms.  */\n struct macro_arg\n {\n   const cpp_token **first;\t/* First token in unexpanded argument.  */\n   const cpp_token **expanded;\t/* Macro-expanded argument.  */\n   const cpp_token *stringified;\t/* Stringified argument.  */\n   unsigned int count;\t\t/* # of tokens in argument.  */\n   unsigned int expanded_count;\t/* # of tokens in expanded argument.  */\n+  source_location *virt_locs;\t/* Where virtual locations for\n+\t\t\t\t   unexpanded tokens are stored.  */\n+  source_location *expanded_virt_locs; /* Where virtual locations for\n+\t\t\t\t\t  expanded tokens are\n+\t\t\t\t\t  stored.  */\n+};\n+\n+/* The kind of macro tokens which the instance of\n+   macro_arg_token_iter is supposed to iterate over.  */\n+enum macro_arg_token_kind {\n+  MACRO_ARG_TOKEN_NORMAL,\n+  /* This is a macro argument token that got transformed into a string\n+     litteral, e.g. #foo.  */\n+  MACRO_ARG_TOKEN_STRINGIFIED,\n+  /* This is a token resulting from the expansion of a macro\n+     argument that was itself a macro.  */\n+  MACRO_ARG_TOKEN_EXPANDED\n+};\n+\n+/* An iterator over tokens coming from a function-like macro\n+   argument.  */\n+typedef struct macro_arg_token_iter macro_arg_token_iter;\n+struct macro_arg_token_iter\n+{\n+  /* Whether or not -ftrack-macro-expansion is used.  */\n+  bool track_macro_exp_p;\n+  /* The kind of token over which we are supposed to iterate.  */\n+  enum macro_arg_token_kind kind;\n+  /* A pointer to the current token pointed to by the iterator.  */\n+  const cpp_token **token_ptr;\n+  /* A pointer to the \"full\" location of the current token.  If\n+     -ftrack-macro-expansion is used this location tracks loci accross\n+     macro expansion.  */\n+  const source_location *location_ptr;\n+#ifdef ENABLE_CHECKING\n+  /* The number of times the iterator went forward. This useful only\n+     when checking is enabled.  */\n+  size_t num_forwards;\n+#endif\n };\n \n /* Macro expansion.  */\n \n static int enter_macro_context (cpp_reader *, cpp_hashnode *,\n-\t\t\t\tconst cpp_token *);\n+\t\t\t\tconst cpp_token *, source_location);\n static int builtin_macro (cpp_reader *, cpp_hashnode *);\n static void push_ptoken_context (cpp_reader *, cpp_hashnode *, _cpp_buff *,\n \t\t\t\t const cpp_token **, unsigned int);\n+static void push_extended_tokens_context (cpp_reader *, cpp_hashnode *,\n+\t\t\t\t\t  _cpp_buff *, source_location *,\n+\t\t\t\t\t  const cpp_token **, unsigned int);\n static _cpp_buff *collect_args (cpp_reader *, const cpp_hashnode *,\n-\t\t\t\t_cpp_buff **);\n+\t\t\t\t_cpp_buff **, unsigned *);\n static cpp_context *next_context (cpp_reader *);\n static const cpp_token *padding_token (cpp_reader *, const cpp_token *);\n static void expand_arg (cpp_reader *, macro_arg *);\n static const cpp_token *new_string_token (cpp_reader *, uchar *, unsigned int);\n static const cpp_token *stringify_arg (cpp_reader *, macro_arg *);\n static void paste_all_tokens (cpp_reader *, const cpp_token *);\n static bool paste_tokens (cpp_reader *, const cpp_token **, const cpp_token *);\n+static void alloc_expanded_arg_mem (cpp_reader *, macro_arg *, size_t);\n+static void ensure_expanded_arg_room (cpp_reader *, macro_arg *, size_t, size_t *);\n+static void delete_macro_args (_cpp_buff*, unsigned num_args);\n+static void set_arg_token (macro_arg *, const cpp_token *,\n+\t\t\t   source_location, size_t,\n+\t\t\t   enum macro_arg_token_kind,\n+\t\t\t   bool);\n+static const source_location *get_arg_token_location (const macro_arg *,\n+\t\t\t\t\t\t      enum macro_arg_token_kind);\n+static const cpp_token **arg_token_ptr_at (const macro_arg *,\n+\t\t\t\t\t   size_t,\n+\t\t\t\t\t   enum macro_arg_token_kind,\n+\t\t\t\t\t   source_location **virt_location);\n+\n+static void macro_arg_token_iter_init (macro_arg_token_iter *, bool,\n+\t\t\t\t       enum macro_arg_token_kind,\n+\t\t\t\t       const macro_arg *,\n+\t\t\t\t       const cpp_token **);\n+static const cpp_token *macro_arg_token_iter_get_token\n+(const macro_arg_token_iter *it);\n+static source_location macro_arg_token_iter_get_location\n+(const macro_arg_token_iter *);\n+static void macro_arg_token_iter_forward (macro_arg_token_iter *);\n+static _cpp_buff *tokens_buff_new (cpp_reader *, size_t,\n+\t\t\t\t   source_location **);\n+static size_t tokens_buff_count (_cpp_buff *);\n+static const cpp_token **tokens_buff_last_token_ptr (_cpp_buff *);\n+static const cpp_token **tokens_buff_put_token_to (const cpp_token **,\n+\t\t\t\t\t\t   source_location *, \n+\t\t\t\t\t\t   const cpp_token *,\n+\t\t\t\t\t\t   source_location,\n+\t\t\t\t\t\t   source_location,\n+\t\t\t\t\t\t   const struct line_map *,\n+\t\t\t\t\t\t   unsigned int);\n+\n+static const cpp_token **tokens_buff_add_token (_cpp_buff *,\n+\t\t\t\t\t\tsource_location *,\n+\t\t\t\t\t\tconst cpp_token *,\n+\t\t\t\t\t\tsource_location,\n+\t\t\t\t\t\tsource_location,\n+\t\t\t\t\t\tconst struct line_map *,\n+\t\t\t\t\t\tunsigned int);\n+static void tokens_buff_remove_last_token (_cpp_buff *);\n static void replace_args (cpp_reader *, cpp_hashnode *, cpp_macro *,\n-\t\t\t  macro_arg *);\n+\t\t\t  macro_arg *, source_location);\n static _cpp_buff *funlike_invocation_p (cpp_reader *, cpp_hashnode *,\n-\t\t\t\t\t_cpp_buff **);\n+\t\t\t\t\t_cpp_buff **, unsigned *);\n static bool create_iso_definition (cpp_reader *, cpp_macro *);\n \n /* #define directive parsing and handling.  */\n@@ -70,6 +159,11 @@ static bool warn_of_redefinition (cpp_reader *, cpp_hashnode *,\n static bool parse_params (cpp_reader *, cpp_macro *);\n static void check_trad_stringification (cpp_reader *, const cpp_macro *,\n \t\t\t\t\tconst cpp_string *);\n+static bool reached_end_of_context (cpp_context *);\n+static void consume_next_token_from_context (cpp_reader *pfile,\n+\t\t\t\t\t     const cpp_token **,\n+\t\t\t\t\t     source_location *);\n+static const cpp_token* cpp_get_token_1 (cpp_reader *, source_location *);\n \n /* Emits a warning if NODE is a macro defined in the main file that\n    has not been used.  */\n@@ -511,7 +605,7 @@ paste_tokens (cpp_reader *pfile, const cpp_token **plhs, const cpp_token *rhs)\n static void\n paste_all_tokens (cpp_reader *pfile, const cpp_token *lhs)\n {\n-  const cpp_token *rhs;\n+  const cpp_token *rhs = NULL;\n   cpp_context *context = pfile->context;\n \n   do\n@@ -521,10 +615,25 @@ paste_all_tokens (cpp_reader *pfile, const cpp_token *lhs)\n \t object-like macro, or a function-like macro with arguments\n \t inserted.  In either case, the constraints to #define\n \t guarantee we have at least one more token.  */\n-      if (context->direct_p)\n+      if (context->tokens_kind == TOKENS_KIND_DIRECT)\n \trhs = FIRST (context).token++;\n-      else\n+      else if (context->tokens_kind == TOKENS_KIND_INDIRECT)\n \trhs = *FIRST (context).ptoken++;\n+      else if (context->tokens_kind == TOKENS_KIND_EXTENDED)\n+\t{\n+\t  /* So we are in presence of an extended token context, which\n+\t     means that each token in this context has a virtual\n+\t     location attached to it.  So let's not forget to update\n+\t     the pointer to the current virtual location of the\n+\t     current token when we update the pointer to the current\n+\t     token */\n+\n+\t  rhs = *FIRST (context).ptoken++;\n+\t  /* context->c.mc must be non-null, as if we were not in a\n+\t     macro context, context->tokens_kind could not be equal to\n+\t     TOKENS_KIND_EXTENDED.  */\n+\t  context->c.mc->cur_virt_loc++;\n+\t}\n \n       if (rhs->type == CPP_PADDING)\n \t{\n@@ -588,23 +697,37 @@ _cpp_arguments_ok (cpp_reader *pfile, cpp_macro *macro, const cpp_hashnode *node\n    NULL.  Each argument is terminated by a CPP_EOF token, for the\n    future benefit of expand_arg().  If there are any deferred\n    #pragma directives among macro arguments, store pointers to the\n-   CPP_PRAGMA ... CPP_PRAGMA_EOL tokens into *PRAGMA_BUFF buffer.  */\n+   CPP_PRAGMA ... CPP_PRAGMA_EOL tokens into *PRAGMA_BUFF buffer.\n+\n+   What is returned is the buffer that contains the memory allocated\n+   to hold the macro arguments.  NODE is the name of the macro this\n+   function is dealing with.  If NUM_ARGS is non-NULL, *NUM_ARGS is\n+   set to the actual number of macro arguments allocated in the\n+   returned buffer.  */\n static _cpp_buff *\n collect_args (cpp_reader *pfile, const cpp_hashnode *node,\n-\t      _cpp_buff **pragma_buff)\n+\t      _cpp_buff **pragma_buff, unsigned *num_args)\n {\n   _cpp_buff *buff, *base_buff;\n   cpp_macro *macro;\n   macro_arg *args, *arg;\n   const cpp_token *token;\n   unsigned int argc;\n+  source_location virt_loc;\n+  bool track_macro_expansion_p = CPP_OPTION (pfile, track_macro_expansion);\n+  unsigned num_args_alloced = 0;\n \n   macro = node->value.macro;\n   if (macro->paramc)\n     argc = macro->paramc;\n   else\n     argc = 1;\n-  buff = _cpp_get_buff (pfile, argc * (50 * sizeof (cpp_token *)\n+\n+#define DEFAULT_NUM_TOKENS_PER_MACRO_ARG 50\n+#define ARG_TOKENS_EXTENT 1000\n+\n+  buff = _cpp_get_buff (pfile, argc * (DEFAULT_NUM_TOKENS_PER_MACRO_ARG\n+\t\t\t\t       * sizeof (cpp_token *)\n \t\t\t\t       + sizeof (macro_arg)));\n   base_buff = buff;\n   args = (macro_arg *) buff->base;\n@@ -619,21 +742,38 @@ collect_args (cpp_reader *pfile, const cpp_hashnode *node,\n     {\n       unsigned int paren_depth = 0;\n       unsigned int ntokens = 0;\n+      unsigned virt_locs_capacity = DEFAULT_NUM_TOKENS_PER_MACRO_ARG;\n+      num_args_alloced++;\n \n       argc++;\n       arg->first = (const cpp_token **) buff->cur;\n+      if (track_macro_expansion_p)\n+\t{\n+\t  virt_locs_capacity = DEFAULT_NUM_TOKENS_PER_MACRO_ARG;\n+\t  arg->virt_locs = XNEWVEC (source_location,\n+\t\t\t\t    virt_locs_capacity);\n+\t}\n \n       for (;;)\n \t{\n \t  /* Require space for 2 new tokens (including a CPP_EOF).  */\n \t  if ((unsigned char *) &arg->first[ntokens + 2] > buff->limit)\n \t    {\n \t      buff = _cpp_append_extend_buff (pfile, buff,\n-\t\t\t\t\t      1000 * sizeof (cpp_token *));\n+\t\t\t\t\t      ARG_TOKENS_EXTENT\n+\t\t\t\t\t      * sizeof (cpp_token *));\n \t      arg->first = (const cpp_token **) buff->cur;\n \t    }\n+\t  if (track_macro_expansion_p\n+\t      && (ntokens + 2 > virt_locs_capacity))\n+\t    {\n+\t      virt_locs_capacity += ARG_TOKENS_EXTENT;\n+\t      arg->virt_locs = XRESIZEVEC (source_location,\n+\t\t\t\t\t   arg->virt_locs,\n+\t\t\t\t\t   virt_locs_capacity);\n+\t    }\n \n-\t  token = cpp_get_token (pfile);\n+\t  token = cpp_get_token_1 (pfile, &virt_loc);\n \n \t  if (token->type == CPP_PADDING)\n \t    {\n@@ -690,7 +830,7 @@ collect_args (cpp_reader *pfile, const cpp_hashnode *node,\n \t\t  BUFF_FRONT (*pragma_buff) += sizeof (cpp_token *);\n \t\t  if (token->type == CPP_PRAGMA_EOL)\n \t\t    break;\n-\t\t  token = cpp_get_token (pfile);\n+\t\t  token = cpp_get_token_1 (pfile, &virt_loc);\n \t\t}\n \t      while (token->type != CPP_EOF);\n \n@@ -704,16 +844,20 @@ collect_args (cpp_reader *pfile, const cpp_hashnode *node,\n \t      else\n \t\tcontinue;\n \t    }\n-\n-\t  arg->first[ntokens++] = token;\n+\t  set_arg_token (arg, token, virt_loc,\n+\t\t\t ntokens, MACRO_ARG_TOKEN_NORMAL,\n+\t\t\t CPP_OPTION (pfile, track_macro_expansion));\n+\t  ntokens++;\n \t}\n \n       /* Drop trailing padding.  */\n       while (ntokens > 0 && arg->first[ntokens - 1]->type == CPP_PADDING)\n \tntokens--;\n \n       arg->count = ntokens;\n-      arg->first[ntokens] = &pfile->eof;\n+      set_arg_token (arg, &pfile->eof, pfile->eof.src_loc,\n+\t\t     ntokens, MACRO_ARG_TOKEN_NORMAL,\n+\t\t     CPP_OPTION (pfile, track_macro_expansion));\n \n       /* Terminate the argument.  Excess arguments loop back and\n \t overwrite the final legitimate argument, before failing.  */\n@@ -756,6 +900,8 @@ collect_args (cpp_reader *pfile, const cpp_hashnode *node,\n \t\t\t\t  || (argc == 1 && args[0].count == 0\n \t\t\t\t      && !CPP_OPTION (pfile, std))))\n \t    args[macro->paramc - 1].first = NULL;\n+\t  if (num_args)\n+\t    *num_args = num_args_alloced;\n \t  return base_buff;\n \t}\n     }\n@@ -769,10 +915,12 @@ collect_args (cpp_reader *pfile, const cpp_hashnode *node,\n    way that, if none is found, we don't lose the information in any\n    intervening padding tokens.  If we find the parenthesis, collect\n    the arguments and return the buffer containing them.  PRAGMA_BUFF\n-   argument is the same as in collect_args.  */\n+   argument is the same as in collect_args.  If NUM_ARGS is non-NULL,\n+   *NUM_ARGS is set to the number of arguments contained in the\n+   returned buffer.  */\n static _cpp_buff *\n funlike_invocation_p (cpp_reader *pfile, cpp_hashnode *node,\n-\t\t      _cpp_buff **pragma_buff)\n+\t\t      _cpp_buff **pragma_buff, unsigned *num_args)\n {\n   const cpp_token *token, *padding = NULL;\n \n@@ -789,7 +937,7 @@ funlike_invocation_p (cpp_reader *pfile, cpp_hashnode *node,\n   if (token->type == CPP_OPEN_PAREN)\n     {\n       pfile->state.parsing_args = 2;\n-      return collect_args (pfile, node, pragma_buff);\n+      return collect_args (pfile, node, pragma_buff, num_args);\n     }\n \n   /* CPP_EOF can be the end of macro arguments, or the end of the\n@@ -823,13 +971,15 @@ macro_real_token_count (const cpp_macro *macro)\n /* Push the context of a macro with hash entry NODE onto the context\n    stack.  If we can successfully expand the macro, we push a context\n    containing its yet-to-be-rescanned replacement list and return one.\n-   If there were additionally any unexpanded deferred #pragma directives\n-   among macro arguments, push another context containing the\n-   pragma tokens before the yet-to-be-rescanned replacement list\n-   and return two.  Otherwise, we don't push a context and return zero.  */\n+   If there were additionally any unexpanded deferred #pragma\n+   directives among macro arguments, push another context containing\n+   the pragma tokens before the yet-to-be-rescanned replacement list\n+   and return two.  Otherwise, we don't push a context and return\n+   zero. LOCATION is the location of the expansion point of the\n+   macro.  */\n static int\n enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,\n-\t\t     const cpp_token *result)\n+\t\t     const cpp_token *result, source_location location)\n {\n   /* The presence of a macro invalidates a file's controlling macro.  */\n   pfile->mi_valid = false;\n@@ -854,11 +1004,13 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,\n       if (macro->fun_like)\n \t{\n \t  _cpp_buff *buff;\n+\t  unsigned num_args = 0;\n \n \t  pfile->state.prevent_expansion++;\n \t  pfile->keep_tokens++;\n \t  pfile->state.parsing_args = 1;\n-\t  buff = funlike_invocation_p (pfile, node, &pragma_buff);\n+\t  buff = funlike_invocation_p (pfile, node, &pragma_buff,\n+\t\t\t\t       &num_args);\n \t  pfile->state.parsing_args = 0;\n \t  pfile->keep_tokens--;\n \t  pfile->state.prevent_expansion--;\n@@ -877,8 +1029,13 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,\n \t    }\n \n \t  if (macro->paramc > 0)\n-\t    replace_args (pfile, node, macro, (macro_arg *) buff->base);\n-\t  _cpp_release_buff (pfile, buff);\n+\t    replace_args (pfile, node, macro,\n+\t\t\t  (macro_arg *) buff->base,\n+\t\t\t  location);\n+\t  /* Free the memory used by the arguments of this\n+\t     function-like macro.  This memory has been allocated by\n+\t     funlike_invocation_p and by replace_args.  */\n+\t  delete_macro_args (buff, num_args);\n \t}\n \n       /* Disable the macro within its expansion.  */\n@@ -892,13 +1049,44 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,\n \t}\n \n       if (pfile->cb.used)\n-\tpfile->cb.used (pfile, result->src_loc, node);\n+\tpfile->cb.used (pfile, location, node);\n \n       macro->used = 1;\n \n       if (macro->paramc == 0)\n-\t_cpp_push_token_context (pfile, node, macro->exp.tokens,\n-\t\t\t\t macro_real_token_count (macro));\n+\t{\n+\t  if (CPP_OPTION (pfile, track_macro_expansion))\n+\t    {\n+\t      unsigned int i, count = macro->count;\n+\t      const cpp_token *src = macro->exp.tokens;\n+\t      const struct line_map *map;\n+\t      source_location *virt_locs = NULL;\n+\t      _cpp_buff *macro_tokens =\n+\t\ttokens_buff_new (pfile, count, &virt_locs);\n+\n+\t      /* Create a macro map to record the locations of the\n+\t\t tokens that are involved in the expansion. LOCATION\n+\t\t is the location of the macro expansion point.  */\n+\t      map  = linemap_enter_macro (pfile->line_table,\n+\t\t\t\t\t  node, location, count);\n+\t      for (i = 0; i < count; ++i)\n+\t\t{\n+\t\t  tokens_buff_add_token (macro_tokens, virt_locs,\n+\t\t\t\t\t src, src->src_loc,\n+\t\t\t\t\t src->src_loc, map, i);\n+\t\t  ++src;\n+\t\t}\n+\t      push_extended_tokens_context (pfile, node,\n+\t\t\t\t\t    macro_tokens,\n+\t\t\t\t\t    virt_locs,\n+\t\t\t\t\t    (const cpp_token **)\n+\t\t\t\t\t    macro_tokens->base,\n+\t\t\t\t\t    count);\n+\t    }\n+\t  else\n+\t    _cpp_push_token_context (pfile, node, macro->exp.tokens,\n+\t\t\t\t     macro_real_token_count (macro));\n+\t}\n \n       if (pragma_buff)\n \t{\n@@ -926,33 +1114,314 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,\n   return builtin_macro (pfile, node);\n }\n \n+/* De-allocate the memory used by BUFF which is an array of instances\n+   of macro_arg.  NUM_ARGS is the number of instances of macro_arg\n+   present in BUFF.  */\n+static void\n+delete_macro_args (_cpp_buff *buff, unsigned num_args)\n+{\n+  macro_arg *macro_args;\n+  unsigned i;\n+\n+  if (buff == NULL)\n+    return;\n+\n+  macro_args = (macro_arg *) buff->base;\n+\n+  /* Walk instances of macro_arg to free their expanded tokens as well\n+     as their macro_arg::virt_locs members.  */\n+  for (i = 0; i < num_args; ++i)\n+    {\n+      if (macro_args[i].expanded)\n+\t{\n+\t  free (macro_args[i].expanded);\n+\t  macro_args[i].expanded = NULL;\n+\t}\n+      if (macro_args[i].virt_locs)\n+\t{\n+\t  free (macro_args[i].virt_locs);\n+\t  macro_args[i].virt_locs = NULL;\n+\t}\n+      if (macro_args[i].expanded_virt_locs)\n+\t{\n+\t  free (macro_args[i].expanded_virt_locs);\n+\t  macro_args[i].expanded_virt_locs = NULL;\n+\t}\n+    }\n+  _cpp_free_buff (buff);\n+}\n+\n+/* Set the INDEXth token of the macro argument ARG. TOKEN is the token\n+   to set, LOCATION is its virtual location.  \"Virtual\" location means\n+   the location that encodes loci accross macro expansion. Otherwise\n+   it has to be TOKEN->SRC_LOC.  KIND is the kind of tokens the\n+   argument ARG is supposed to contain.  Note that ARG must be\n+   tailored so that it has enough room to contain INDEX + 1 numbers of\n+   tokens, at least.  */\n+static void\n+set_arg_token (macro_arg *arg, const cpp_token *token,\n+\t       source_location location, size_t index,\n+\t       enum macro_arg_token_kind kind,\n+\t       bool track_macro_exp_p)\n+{\n+  const cpp_token **token_ptr;\n+  source_location *loc = NULL;\n+\n+  token_ptr =\n+    arg_token_ptr_at (arg, index, kind,\n+\t\t      track_macro_exp_p ? &loc : NULL);\n+  *token_ptr = token;\n+\n+  if (loc != NULL)\n+    {\n+#ifdef ENABLE_CHECKING\n+      if (kind == MACRO_ARG_TOKEN_STRINGIFIED\n+\t  || !track_macro_exp_p)\n+\t/* We can't set the location of a stringified argument\n+\t   token and we can't set any location if we aren't tracking\n+\t   macro expansion locations.   */\n+\tabort ();\n+#endif\n+      *loc = location;\n+    }\n+}\n+\n+/* Get the pointer to the location of the argument token of the\n+   function-like macro argument ARG.  This function must be called\n+   only when we -ftrack-macro-expansion is on.  */\n+static const source_location *\n+get_arg_token_location (const macro_arg *arg,\n+\t\t\tenum macro_arg_token_kind kind)\n+{\n+  const source_location *loc = NULL;\n+  const cpp_token **token_ptr =\n+    arg_token_ptr_at (arg, 0, kind, (source_location **) &loc);\n+\n+  if (token_ptr == NULL)\n+    return NULL;\n+\n+  return loc;\n+}\n+\n+/* Return the pointer to the INDEXth token of the macro argument ARG.\n+   KIND specifies the kind of token the macro argument ARG contains.\n+   If VIRT_LOCATION is non NULL, *VIRT_LOCATION is set to the address\n+   of the virtual location of the returned token if the\n+   -ftrack-macro-expansion flag is on; otherwise, it's set to the\n+   spelling location of the returned token.  */\n+static const cpp_token **\n+arg_token_ptr_at (const macro_arg *arg, size_t index,\n+\t\t  enum macro_arg_token_kind kind,\n+\t\t  source_location **virt_location)\n+{\n+  const cpp_token **tokens_ptr = NULL;\n+\n+  switch (kind)\n+    {\n+    case MACRO_ARG_TOKEN_NORMAL:\n+      tokens_ptr = arg->first;\n+      break;\n+    case MACRO_ARG_TOKEN_STRINGIFIED:      \n+      tokens_ptr = (const cpp_token **) &arg->stringified;\n+      break;\n+    case MACRO_ARG_TOKEN_EXPANDED:\n+\ttokens_ptr = arg->expanded;\n+      break;\n+    }\n+\n+  if (tokens_ptr == NULL)\n+    /* This can happen for e.g, an empty token argument to a\n+       funtion-like macro.  */\n+    return tokens_ptr;\n+\n+  if (virt_location)\n+    {\n+      if (kind == MACRO_ARG_TOKEN_NORMAL)\n+\t*virt_location = &arg->virt_locs[index];\n+      else if (kind == MACRO_ARG_TOKEN_EXPANDED)\n+\t*virt_location = &arg->expanded_virt_locs[index];\n+      else if (kind == MACRO_ARG_TOKEN_STRINGIFIED)\n+\t*virt_location =\n+\t  (source_location *) &tokens_ptr[index]->src_loc;\n+    }\n+  return &tokens_ptr[index];\n+}\n+\n+/* Initialize an iterator so that it iterates over the tokens of a\n+   function-like macro argument.  KIND is the kind of tokens we want\n+   ITER to iterate over. TOKEN_PTR points the first token ITER will\n+   iterate over.  */\n+static void\n+macro_arg_token_iter_init (macro_arg_token_iter *iter,\n+\t\t\t   bool track_macro_exp_p,\n+\t\t\t   enum macro_arg_token_kind kind,\n+\t\t\t   const macro_arg *arg,\n+\t\t\t   const cpp_token **token_ptr)\n+{\n+  iter->track_macro_exp_p = track_macro_exp_p;\n+  iter->kind = kind;\n+  iter->token_ptr = token_ptr;\n+  if (track_macro_exp_p)\n+    iter->location_ptr = get_arg_token_location (arg, kind);\n+#ifdef ENABLE_CHECKING\n+  iter->num_forwards = 0;\n+  if (track_macro_exp_p\n+      && token_ptr != NULL\n+      && iter->location_ptr == NULL)\n+    abort ();\n+#endif\n+}\n+\n+/* Move the iterator one token forward. Note that if IT was\n+   initialized on an argument that has a stringified token, moving it\n+   foward doesn't make sense as a stringified token is essentially one\n+   string.  */\n+static void\n+macro_arg_token_iter_forward (macro_arg_token_iter *it)\n+{\n+  switch (it->kind)\n+    {\n+    case MACRO_ARG_TOKEN_NORMAL:\n+    case MACRO_ARG_TOKEN_EXPANDED:\n+      it->token_ptr++;\n+      if (it->track_macro_exp_p)\n+\tit->location_ptr++;\n+      break;\n+    case MACRO_ARG_TOKEN_STRINGIFIED:\n+#ifdef ENABLE_CHECKING\n+      if (it->num_forwards > 0)\n+\tabort ();\n+#endif\n+      break;\n+    }\n+\n+#ifdef ENABLE_CHECKING\n+  it->num_forwards++;\n+#endif\n+}\n+\n+/* Return the token pointed to by the iterator.  */\n+static const cpp_token *\n+macro_arg_token_iter_get_token (const macro_arg_token_iter *it)\n+{\n+#ifdef ENABLE_CHECKING\n+  if (it->kind == MACRO_ARG_TOKEN_STRINGIFIED\n+      && it->num_forwards > 0)\n+    abort ();\n+#endif\n+  if (it->token_ptr == NULL)\n+    return NULL;\n+  return *it->token_ptr;\n+}\n+\n+/* Return the location of the token pointed to by the iterator.*/\n+static source_location\n+macro_arg_token_iter_get_location (const macro_arg_token_iter *it)\n+{\n+#ifdef ENABLE_CHECKING\n+  if (it->kind == MACRO_ARG_TOKEN_STRINGIFIED\n+      && it->num_forwards > 0)\n+    abort ();\n+#endif\n+  if (it->track_macro_exp_p)\n+    return *it->location_ptr;\n+  else\n+    return (*it->token_ptr)->src_loc;\n+}\n+\n+/* Return the index of a token [resulting from macro expansion] inside\n+   the total list of tokens resulting from a given macro\n+   expansion. The index can be different depending on whether if we\n+   want each tokens resulting from function-like macro arguments\n+   expansion to have a different location or not.\n+\n+   E.g, consider this function-like macro: \n+\n+        #define M(x) x - 3\n+\n+   Then consider us \"calling\" it (and thus expanding it) like:\n+   \n+       M(1+4)\n+\n+   It will be expanded into:\n+\n+       1+4-3\n+\n+   Let's consider the case of the token '4'.\n+\n+   Its index can be 2 (it's the third token of the set of tokens\n+   resulting from the expansion) or it can be 0 if we consider that\n+   all tokens resulting from the expansion of the argument \"1+2\" have\n+   the same index, which is 0. In this later case, the index of token\n+   '-' would then be 1 and the index of token '3' would be 2.\n+\n+   The later case is useful to use less memory e.g, for the case of\n+   the user using the option -ftrack-macro-expansion=1.\n+\n+   ABSOLUTE_TOKEN_INDEX is the index of the macro argument token we\n+   are interested in.  CUR_REPLACEMENT_TOKEN is the token of the macro\n+   parameter (inside the macro replacement list) that corresponds to\n+   the macro argument for which ABSOLUTE_TOKEN_INDEX is a token index\n+   of.\n+\n+   If we refer to the example above, for the '4' argument token,\n+   ABSOLUTE_TOKEN_INDEX would be set to 2, and CUR_REPLACEMENT_TOKEN\n+   would be set to the token 'x', in the replacement list \"x - 3\" of\n+   macro M.\n+\n+   This is a subroutine of replace_args.  */\n+inline static unsigned\n+expanded_token_index (cpp_reader *pfile, cpp_macro *macro,\n+\t\t      const cpp_token *cur_replacement_token,\n+\t\t      unsigned absolute_token_index)\n+{\n+  if (CPP_OPTION (pfile, track_macro_expansion) > 1)\n+    return absolute_token_index;\n+  return cur_replacement_token - macro->exp.tokens;\n+}\n+\n /* Replace the parameters in a function-like macro of NODE with the\n    actual ARGS, and place the result in a newly pushed token context.\n    Expand each argument before replacing, unless it is operated upon\n-   by the # or ## operators.  */\n+   by the # or ## operators. EXPANSION_POINT_LOC is the location of\n+   the expansion point of the macro. E.g, the location of the\n+   function-like macro invocation.  */\n static void\n-replace_args (cpp_reader *pfile, cpp_hashnode *node, cpp_macro *macro, macro_arg *args)\n+replace_args (cpp_reader *pfile, cpp_hashnode *node, cpp_macro *macro,\n+\t      macro_arg *args, source_location expansion_point_loc)\n {\n   unsigned int i, total;\n   const cpp_token *src, *limit;\n-  const cpp_token **dest, **first;\n+  const cpp_token **first = NULL;\n   macro_arg *arg;\n-  _cpp_buff *buff;\n-  unsigned int count;\n+  _cpp_buff *buff = NULL;\n+  source_location *virt_locs = NULL;\n+  unsigned int exp_count;\n+  const struct line_map *map = NULL;\n+  int track_macro_exp;\n \n   /* First, fully macro-expand arguments, calculating the number of\n      tokens in the final expansion as we go.  The ordering of the if\n      statements below is subtle; we must handle stringification before\n      pasting.  */\n-  count = macro_real_token_count (macro);\n-  total = count;\n-  limit = macro->exp.tokens + count;\n+\n+  /* EXP_COUNT is the number of tokens in the macro replacement\n+     list.  TOTAL is the number of tokens /after/ macro parameters\n+     have been replaced by their arguments.   */\n+  exp_count = macro_real_token_count (macro);\n+  total = exp_count;\n+  limit = macro->exp.tokens + exp_count;\n \n   for (src = macro->exp.tokens; src < limit; src++)\n     if (src->type == CPP_MACRO_ARG)\n       {\n \t/* Leading and trailing padding tokens.  */\n \ttotal += 2;\n+\t/* Account for leading and padding tokens in exp_count too.\n+\t   This is going to be important later down this function,\n+\t   when we want to handle the case of (track_macro_exp <\n+\t   2).  */\n+\texp_count += 2;\n \n \t/* We have an argument.  If it is not being stringified or\n \t   pasted it is macro-replaced before insertion.  */\n@@ -974,67 +1443,230 @@ replace_args (cpp_reader *pfile, cpp_hashnode *node, cpp_macro *macro, macro_arg\n \t  }\n       }\n \n-  /* Now allocate space for the expansion, copy the tokens and replace\n-     the arguments.  */\n-  buff = _cpp_get_buff (pfile, total * sizeof (cpp_token *));\n+  /* When the compiler is called with the -ftrack-macro-expansion\n+     flag, we need to keep track of the location of each token that\n+     results from macro expansion.\n+\n+     A token resulting from macro expansion is not a new token. It is\n+     simply the same token as the token coming from the macro\n+     definition.  The new things that are allocated are the buffer\n+     that holds the tokens resulting from macro expansion and a new\n+     location that records many things like the locus of the expansion\n+     point as well as the original locus inside the definition of the\n+     macro.  This location is called a virtual location.\n+     \n+     So the buffer BUFF holds a set of cpp_token*, and the buffer\n+     VIRT_LOCS holds the virtual locations of the tokens held by BUFF.\n+\n+     Both of these two buffers are going to be hung off of the macro\n+     context, when the latter is pushed.  The memory allocated to\n+     store the tokens and their locations is going to be freed once\n+     the context of macro expansion is popped.\n+     \n+     As far as tokens are concerned, the memory overhead of\n+     -ftrack-macro-expansion is proportional to the number of\n+     macros that get expanded multiplied by sizeof (source_location).\n+     The good news is that extra memory gets freed when the macro\n+     context is freed, i.e shortly after the macro got expanded.  */\n+\n+  /* Is the -ftrack-macro-expansion flag in effect?  */\n+  track_macro_exp = CPP_OPTION (pfile, track_macro_expansion);\n+\n+  /* Now allocate memory space for tokens and locations resulting from\n+     the macro expansion, copy the tokens and replace the arguments.\n+     This memory must be freed when the context of the macro MACRO is\n+     popped.  */\n+  buff = tokens_buff_new (pfile, total, track_macro_exp ? &virt_locs : NULL);\n+\n   first = (const cpp_token **) buff->base;\n-  dest = first;\n \n+  /* Create a macro map to record the locations of the tokens that are\n+     involved in the expansion.  Note that the expansion point is set\n+     to the location of the closing parenthesis.  Otherwise, the\n+     subsequent map created for the first token that comes after the\n+     macro map might have a wrong line number.  That would lead to\n+     tokens with wrong line numbers after the macro expansion.  This\n+     adds up to the memory overhead of the -ftrack-macro-expansion\n+     flag; for every macro that is expanded, a \"macro map\" is\n+     created.  */\n+  if (track_macro_exp)\n+    {\n+      int num_macro_tokens = total;\n+      if (track_macro_exp < 2)\n+\t/* Then the number of macro tokens won't take in account the\n+\t   fact that function-like macro arguments can expand to\n+\t   multiple tokens. This is to save memory at the expense of\n+\t   accuracy.\n+\n+\t   Suppose we have #define SQARE(A) A * A\n+\n+\t   And then we do SQARE(2+3)\n+\n+\t   Then the tokens 2, +, 3, will have the same location,\n+\t   saying they come from the expansion of the argument A.  */\n+\tnum_macro_tokens = exp_count;\n+      map = linemap_enter_macro (pfile->line_table, node,\n+\t\t\t\t expansion_point_loc,\n+\t\t\t\t num_macro_tokens);\n+    }\n+  i = 0;\n   for (src = macro->exp.tokens; src < limit; src++)\n     {\n-      unsigned int count;\n-      const cpp_token **from, **paste_flag;\n+      unsigned int arg_tokens_count;\n+      macro_arg_token_iter from;\n+      const cpp_token **paste_flag = NULL;\n+      const cpp_token **tmp_token_ptr;\n \n       if (src->type != CPP_MACRO_ARG)\n \t{\n-\t  *dest++ = src;\n+\t  /* Allocate a virtual location for token SRC, and add that\n+\t     token and its virtual location into the buffers BUFF and\n+\t     VIRT_LOCS.  */\n+\t  unsigned index = expanded_token_index (pfile, macro, src, i);\n+\t  tokens_buff_add_token (buff, virt_locs, src,\n+\t\t\t\t src->src_loc, src->src_loc,\n+\t\t\t\t map, index);\n+\t  i += 1;\n \t  continue;\n \t}\n \n       paste_flag = 0;\n       arg = &args[src->val.macro_arg.arg_no - 1];\n+      /* SRC is a macro parameter that we need to replace with its\n+\t corresponding argument.  So at some point we'll need to\n+\t iterate over the tokens of the macro argument and copy them\n+\t into the \"place\" now holding the correspondig macro\n+\t parameter.  We are going to use the iterator type\n+\t macro_argo_token_iter to handle that iterating.  The 'if'\n+\t below is to initialize the iterator depending on the type of\n+\t tokens the macro argument has.  It also does some adjustment\n+\t related to padding tokens and some pasting corner cases.  */\n       if (src->flags & STRINGIFY_ARG)\n-\tcount = 1, from = &arg->stringified;\n+\t{\n+\t  arg_tokens_count = 1;\n+\t  macro_arg_token_iter_init (&from,\n+\t\t\t\t     CPP_OPTION (pfile,\n+\t\t\t\t\t\t track_macro_expansion),\n+\t\t\t\t     MACRO_ARG_TOKEN_STRINGIFIED,\n+\t\t\t\t     arg, &arg->stringified);\n+\t}\n       else if (src->flags & PASTE_LEFT)\n-\tcount = arg->count, from = arg->first;\n+\t{\n+\t  arg_tokens_count = arg->count;\n+\t  macro_arg_token_iter_init (&from,\n+\t\t\t\t     CPP_OPTION (pfile,\n+\t\t\t\t\t\t track_macro_expansion),\n+\t\t\t\t     MACRO_ARG_TOKEN_NORMAL,\n+\t\t\t\t     arg, arg->first);\n+\t}\n       else if (src != macro->exp.tokens && (src[-1].flags & PASTE_LEFT))\n \t{\n-\t  count = arg->count, from = arg->first;\n-\t  if (dest != first)\n+\t  int num_toks;\n+\t  arg_tokens_count = arg->count;\n+\t  macro_arg_token_iter_init (&from,\n+\t\t\t\t     CPP_OPTION (pfile,\n+\t\t\t\t\t\t track_macro_expansion),\n+\t\t\t\t     MACRO_ARG_TOKEN_NORMAL,\n+\t\t\t\t     arg, arg->first);\n+\n+\t  num_toks = tokens_buff_count (buff);\n+\n+\t  if (num_toks != 0)\n \t    {\n-\t      if (dest[-1]->type == CPP_COMMA\n+\t      /* So the current parameter token is pasted to the previous\n+\t\t token in the replacement list.  Let's look at what\n+\t\t we have as previous and current arguments.  */\n+\n+\t      /* This is the previous argument's token ...  */\n+\t      tmp_token_ptr = tokens_buff_last_token_ptr (buff);\n+\n+\t      if ((*tmp_token_ptr)->type == CPP_COMMA\n \t\t  && macro->variadic\n \t\t  && src->val.macro_arg.arg_no == macro->paramc)\n \t\t{\n-\t\t  /* Swallow a pasted comma if from == NULL, otherwise\n-\t\t     drop the paste flag.  */\n-\t\t  if (from == NULL)\n-\t\t    dest--;\n+\t\t  /* ... which is a comma; and the current parameter\n+\t\t     is the last parameter of a variadic function-like\n+\t\t     macro.  If the argument to the current last\n+\t\t     parameter is NULL, then swallow the comma,\n+\t\t     otherwise drop the paste flag.  */\n+\t\t  if (macro_arg_token_iter_get_token (&from) == NULL)\n+\t\t    tokens_buff_remove_last_token (buff);\n \t\t  else\n-\t\t    paste_flag = dest - 1;\n+\t\t    paste_flag = tmp_token_ptr;\n \t\t}\n \t      /* Remove the paste flag if the RHS is a placemarker.  */\n-\t      else if (count == 0)\n-\t\tpaste_flag = dest - 1;\n+\t      else if (arg_tokens_count == 0)\n+\t\tpaste_flag = tmp_token_ptr;\n \t    }\n \t}\n       else\n-\tcount = arg->expanded_count, from = arg->expanded;\n+\t{\n+\t  arg_tokens_count = arg->expanded_count;\n+\t  macro_arg_token_iter_init (&from,\n+\t\t\t\t     CPP_OPTION (pfile,\n+\t\t\t\t\t\t track_macro_expansion),\n+\t\t\t\t     MACRO_ARG_TOKEN_EXPANDED,\n+\t\t\t\t     arg, arg->expanded);\n+\t}\n \n       /* Padding on the left of an argument (unless RHS of ##).  */\n       if ((!pfile->state.in_directive || pfile->state.directive_wants_padding)\n \t  && src != macro->exp.tokens && !(src[-1].flags & PASTE_LEFT))\n-\t*dest++ = padding_token (pfile, src);\n+\t{\n+\t  const cpp_token *t = padding_token (pfile, src);\n+\t  unsigned index = expanded_token_index (pfile, macro, src, i);\n+\t  /* Allocate a virtual location for the padding token and\n+\t     append the token and its location to BUFF and\n+\t     VIRT_LOCS.   */\n+\t  tokens_buff_add_token (buff, virt_locs, t,\n+\t\t\t\t t->src_loc, t->src_loc,\n+\t\t\t\t map, index);\n+\t}\n \n-      if (count)\n+      if (arg_tokens_count)\n \t{\n-\t  memcpy (dest, from, count * sizeof (cpp_token *));\n-\t  dest += count;\n+\t  /* So now we've got the number of tokens that make up the\n+\t     argument that is going to replace the current parameter\n+\t     in the macro's replacement list.  */\n+\t  unsigned int j;\n+\t  for (j = 0; j < arg_tokens_count; ++j)\n+\t    {\n+\t      /* So if track_macro_exp is < 2, the user wants to\n+\t\t save extra memory while tracking macro expansion\n+\t\t locations.  So in that case here is what we do:\n+\n+\t\t Suppose we have #define SQARE(A) A * A\n+\n+\t\t And then we do SQARE(2+3)\n+\n+\t\t Then the tokens 2, +, 3, will have the same location,\n+\t\t saying they come from the expansion of the argument\n+\t\t A.\n+\n+\t      So that means we are going to ignore the COUNT tokens\n+\t      resulting from the expansion of the current macro\n+\t      arugment. In other words all the ARG_TOKENS_COUNT tokens\n+\t      resulting from the expansion of the macro argument will\n+\t      have the index I. Normally, each of those token should\n+\t      have index I+J.  */\n+\t      unsigned token_index = i;\n+\t      unsigned index;\n+\t      if (track_macro_exp > 1)\n+\t\ttoken_index += j;\n+\n+\t      index = expanded_token_index (pfile, macro, src, token_index);\n+\t      tokens_buff_add_token (buff, virt_locs,\n+\t\t\t\t     macro_arg_token_iter_get_token (&from),\n+\t\t\t\t     macro_arg_token_iter_get_location (&from),\n+\t\t\t\t     src->src_loc, map, index);\n+\t      macro_arg_token_iter_forward (&from);\n+\t    }\n \n \t  /* With a non-empty argument on the LHS of ##, the last\n \t     token should be flagged PASTE_LEFT.  */\n \t  if (src->flags & PASTE_LEFT)\n-\t    paste_flag = dest - 1;\n+\t    paste_flag =\n+\t      (const cpp_token **) tokens_buff_last_token_ptr (buff);\n \t}\n       else if (CPP_PEDANTIC (pfile) && ! macro->syshdr\n \t       && ! CPP_OPTION (pfile, c99)\n@@ -1050,7 +1682,12 @@ replace_args (cpp_reader *pfile, cpp_hashnode *node, cpp_macro *macro, macro_arg\n \n       /* Avoid paste on RHS (even case count == 0).  */\n       if (!pfile->state.in_directive && !(src->flags & PASTE_LEFT))\n-\t*dest++ = &pfile->avoid_paste;\n+\t{\n+\t  const cpp_token *t = &pfile->avoid_paste;\n+\t  tokens_buff_add_token (buff, virt_locs,\n+\t\t\t\t t, t->src_loc, t->src_loc,\n+\t\t\t\t NULL, 0);\n+\t}\n \n       /* Add a new paste flag, or remove an unwanted one.  */\n       if (paste_flag)\n@@ -1064,13 +1701,16 @@ replace_args (cpp_reader *pfile, cpp_hashnode *node, cpp_macro *macro, macro_arg\n \t    token->flags = (*paste_flag)->flags & ~PASTE_LEFT;\n \t  *paste_flag = token;\n \t}\n-    }\n \n-  /* Free the expanded arguments.  */\n-  for (i = 0; i < macro->paramc; i++)\n-    free (args[i].expanded);\n+      i += arg_tokens_count;\n+    }\n \n-  push_ptoken_context (pfile, node, buff, first, dest - first);\n+  if (track_macro_exp)\n+    push_extended_tokens_context (pfile, node, buff, virt_locs, first,\n+\t\t\t\t  tokens_buff_count (buff));\n+  else\n+    push_ptoken_context (pfile, node, buff, first,\n+\t\t\t tokens_buff_count (buff));\n }\n \n /* Return a special padding token, with padding inherited from SOURCE.  */\n@@ -1098,6 +1738,7 @@ next_context (cpp_reader *pfile)\n   if (result == 0)\n     {\n       result = XNEW (cpp_context);\n+      memset (result, 0, sizeof (cpp_context));\n       result->prev = pfile->context;\n       result->next = 0;\n       pfile->context->next = result;\n@@ -1114,8 +1755,8 @@ push_ptoken_context (cpp_reader *pfile, cpp_hashnode *macro, _cpp_buff *buff,\n {\n   cpp_context *context = next_context (pfile);\n \n-  context->direct_p = false;\n-  context->macro = macro;\n+  context->tokens_kind = TOKENS_KIND_INDIRECT;\n+  context->c.macro = macro;\n   context->buff = buff;\n   FIRST (context).ptoken = first;\n   LAST (context).ptoken = first + count;\n@@ -1126,30 +1767,245 @@ void\n _cpp_push_token_context (cpp_reader *pfile, cpp_hashnode *macro,\n \t\t\t const cpp_token *first, unsigned int count)\n {\n-  cpp_context *context = next_context (pfile);\n-\n-  context->direct_p = true;\n-  context->macro = macro;\n-  context->buff = NULL;\n+   cpp_context *context = next_context (pfile);\n+ \n+   context->tokens_kind = TOKENS_KIND_DIRECT;\n+   context->c.macro = macro;\n+   context->buff = NULL;\n   FIRST (context).token = first;\n   LAST (context).token = first + count;\n }\n \n+/* Build a context containing a list of tokens as well as their\n+   virtual locations and push it.  TOKENS_BUFF is the buffer that\n+   contains the tokens pointed to by FIRST.  If TOKENS_BUFF is\n+   non-NULL, it means that the context owns it, meaning that\n+   _cpp_pop_context will free it as well as VIRT_LOCS_BUFF that\n+   contains the virtual locations.  */\n+static void\n+push_extended_tokens_context (cpp_reader *pfile,\n+\t\t\t      cpp_hashnode *macro,\n+\t\t\t      _cpp_buff *token_buff,\n+\t\t\t      source_location *virt_locs,\n+\t\t\t      const cpp_token **first,\n+\t\t\t      unsigned int count)\n+{\n+  cpp_context *context = next_context (pfile);\n+  macro_context *m;\n+\n+  context->tokens_kind = TOKENS_KIND_EXTENDED;\n+  context->buff = token_buff;\n+\n+  m = XNEW (macro_context);\n+  m->macro_node = macro;\n+  m->virt_locs = virt_locs;\n+  m->cur_virt_loc = virt_locs;\n+  context->c.mc = m;\n+  FIRST (context).ptoken = first;\n+  LAST (context).ptoken = first + count;\n+}\n+\n /* Push a traditional macro's replacement text.  */\n void\n _cpp_push_text_context (cpp_reader *pfile, cpp_hashnode *macro,\n \t\t\tconst uchar *start, size_t len)\n {\n   cpp_context *context = next_context (pfile);\n \n-  context->direct_p = true;\n-  context->macro = macro;\n+  context->tokens_kind = TOKENS_KIND_DIRECT;\n+  context->c.macro = macro;\n   context->buff = NULL;\n   CUR (context) = start;\n   RLIMIT (context) = start + len;\n   macro->flags |= NODE_DISABLED;\n }\n \n+/* Creates a buffer that holds tokens a.k.a \"token buffer\", usually\n+   for the purpose of storing them on a cpp_context. If VIRT_LOCS is\n+   non-null (which means that -ftrack-macro-expansion is on),\n+   *VIRT_LOCS is set to a newly allocated buffer that is supposed to\n+   hold the virtual locations of the tokens resulting from macro\n+   expansion.  */\n+static _cpp_buff*\n+tokens_buff_new (cpp_reader *pfile, size_t len,\n+\t\t source_location **virt_locs)\n+{\n+  size_t tokens_size = len * sizeof (cpp_token *);\n+  size_t locs_size = len * sizeof (source_location);\n+\n+  if (virt_locs != NULL)\n+    *virt_locs = XNEWVEC (source_location, locs_size);\n+  return _cpp_get_buff (pfile, tokens_size);\n+}\n+\n+/* Returns the number of tokens contained in a token buffer.  The\n+   buffer holds a set of cpp_token*.  */\n+static size_t\n+tokens_buff_count (_cpp_buff *buff)\n+{\n+  return (BUFF_FRONT (buff) - buff->base) / sizeof (cpp_token *);\n+}\n+\n+/* Return a pointer to the last token contained in the token buffer\n+   BUFF.  */\n+static const cpp_token **\n+tokens_buff_last_token_ptr (_cpp_buff *buff)\n+{\n+  return &((const cpp_token **) BUFF_FRONT (buff))[-1];\n+}\n+\n+/* Remove the last token contained in the token buffer TOKENS_BUFF.\n+   If VIRT_LOCS_BUFF is non-NULL,  it should point at the buffer\n+   containing the virtual locations of the tokens in TOKENS_BUFF; in\n+   which case the function updates that buffer as well.   */\n+static inline void\n+tokens_buff_remove_last_token (_cpp_buff *tokens_buff)\n+\n+{\n+  if (BUFF_FRONT (tokens_buff) > tokens_buff->base)\n+    BUFF_FRONT (tokens_buff) =\n+      (unsigned char *) &((cpp_token **) BUFF_FRONT (tokens_buff))[-1];\n+}\n+\n+/* Insert a token into the token buffer at the position pointed to by\n+   DEST.  Note that the buffer is not enlarged so the previous token\n+   that was at *DEST is overwritten.  VIRT_LOC_DEST, if non-null,\n+   means -ftrack-macro-expansion is effect; it then points to where to\n+   insert the virtual location of TOKEN.  TOKEN is the token to\n+   insert.  VIRT_LOC is the virtual location of the token, i.e, the\n+   location possibly encoding its locus accross macro expansion.  If\n+   TOKEN is an argument of a function-like macro (inside a macro\n+   replacement list), PARM_DEF_LOC is the spelling location of the\n+   macro parameter that TOKEN is replacing, in the replacement list of\n+   the macro.  If TOKEN is not an argument of a function-like macro or\n+   if it doesn't come from a macro expansion, then VIRT_LOC can just\n+   be set to the same value as PARM_DEF_LOC.  If MAP is non null, it\n+   means TOKEN comes from a macro expansion and MAP is the macro map\n+   associated to the macro.  MACRO_TOKEN_INDEX points to the index of\n+   the token in the macro map; it is not considered if MAP is NULL.\n+\n+   Upon successful completion this function returns the a pointer to\n+   the position of the token coming right after the insertion\n+   point.  */\n+static inline const cpp_token **\n+tokens_buff_put_token_to (const cpp_token **dest,\n+\t\t\t  source_location *virt_loc_dest,\n+\t\t\t  const cpp_token *token,\n+\t\t\t  source_location virt_loc,\n+\t\t\t  source_location parm_def_loc,\t\t\t  \n+\t\t\t  const struct line_map *map,\n+\t\t\t  unsigned int macro_token_index)\n+{\n+  source_location macro_loc = virt_loc;\n+  const cpp_token **result;\n+\n+  if (virt_loc_dest)\n+    {\n+      /* -ftrack-macro-expansion is on.  */\n+      if (map)\n+\tmacro_loc = linemap_add_macro_token (map, macro_token_index,\n+\t\t\t\t\t     virt_loc, parm_def_loc);\n+      *virt_loc_dest = macro_loc;\n+    }\n+  *dest = token;\n+  result = &dest[1];\n+\n+  return result;\n+}\n+\n+/* Adds a token at the end of the tokens contained in BUFFER.  Note\n+   that this function doesn't enlarge BUFFER when the number of tokens\n+   reaches BUFFER's size; it aborts in that situation.\n+\n+   TOKEN is the token to append. VIRT_LOC is the virtual location of\n+   the token, i.e, the location possibly encoding its locus accross\n+   macro expansion. If TOKEN is an argument of a function-like macro\n+   (inside a macro replacement list), PARM_DEF_LOC is the location of\n+   the macro parameter that TOKEN is replacing.  If TOKEN doesn't come\n+   from a macro expansion, then VIRT_LOC can just be set to the same\n+   value as PARM_DEF_LOC.  If MAP is non null, it means TOKEN comes\n+   from a macro expansion and MAP is the macro map associated to the\n+   macro.  MACRO_TOKEN_INDEX points to the index of the token in the\n+   macro map; It is not considered if MAP is NULL.  If VIRT_LOCS is\n+   non-null, it means -ftrack-macro-expansion is on; in which case\n+   this function adds the virtual location DEF_LOC to the VIRT_LOCS\n+   array, at the same index as the one of TOKEN in BUFFER.  Upon\n+   successful completion this function returns the a pointer to the\n+   position of the token coming right after the insertion point.  */\n+static const cpp_token **\n+tokens_buff_add_token (_cpp_buff *buffer,\n+\t\t       source_location *virt_locs,\n+\t\t       const cpp_token *token,\n+\t\t       source_location virt_loc,\n+\t\t       source_location parm_def_loc,\n+\t\t       const struct line_map *map,\n+\t\t       unsigned int macro_token_index)\n+{\n+  const cpp_token **result;\n+  source_location *virt_loc_dest = NULL;\n+  unsigned token_index = \n+    (BUFF_FRONT (buffer) - buffer->base) / sizeof (cpp_token *);\n+\n+  /* Abort if we pass the end the buffer.  */\n+  if (BUFF_FRONT (buffer) > BUFF_LIMIT (buffer))\n+    abort ();\n+\n+  if (virt_locs != NULL)\n+    virt_loc_dest = &virt_locs[token_index];\n+\n+  result =\n+    tokens_buff_put_token_to ((const cpp_token **) BUFF_FRONT (buffer),\n+\t\t\t      virt_loc_dest, token, virt_loc, parm_def_loc,\n+\t\t\t      map, macro_token_index);\n+\n+  BUFF_FRONT (buffer) = (unsigned char *) result;\n+  return result;\n+}\n+\n+/* Allocate space for the function-like macro argument ARG to store\n+   the tokens resulting from the macro-expansion of the tokens that\n+   make up ARG itself. That space is allocated in ARG->expanded and\n+   needs to be freed using free.  */\n+static void\n+alloc_expanded_arg_mem (cpp_reader *pfile, macro_arg *arg, size_t capacity)\n+{\n+#ifdef ENABLE_CHECKING\n+  if (arg->expanded != NULL\n+      || arg->expanded_virt_locs != NULL)\n+    abort ();\n+#endif\n+  arg->expanded = XNEWVEC (const cpp_token *, capacity);\n+  if (CPP_OPTION (pfile, track_macro_expansion))\n+    arg->expanded_virt_locs = XNEWVEC (source_location, capacity);\n+\n+}\n+\n+/* If necessary, enlarge ARG->expanded to so that it can contain SIZE\n+   tokens.  */\n+static void\n+ensure_expanded_arg_room (cpp_reader *pfile, macro_arg *arg,\n+\t\t\t  size_t size, size_t *expanded_capacity)\n+{\n+  if (size <= *expanded_capacity)\n+    return;\n+\n+  size *= 2;\n+\n+  arg->expanded =\n+    XRESIZEVEC (const cpp_token *, arg->expanded, size);\n+  *expanded_capacity = size;\n+\n+  if (CPP_OPTION (pfile, track_macro_expansion))\n+    {\n+      if (arg->expanded_virt_locs == NULL)\n+\targ->expanded_virt_locs = XNEWVEC (source_location, size);\n+      else\n+\targ->expanded_virt_locs = XRESIZEVEC (source_location,\n+\t\t\t\t\t      arg->expanded_virt_locs,\n+\t\t\t\t\t      size);\n+    }\n+}\n+\n /* Expand an argument ARG before replacing parameters in a\n    function-like macro.  This works by pushing a context with the\n    argument's tokens, and then expanding that into a temporary buffer\n@@ -1159,38 +2015,48 @@ _cpp_push_text_context (cpp_reader *pfile, cpp_hashnode *macro,\n static void\n expand_arg (cpp_reader *pfile, macro_arg *arg)\n {\n-  unsigned int capacity;\n+  size_t capacity;\n   bool saved_warn_trad;\n+  bool track_macro_exp_p = CPP_OPTION (pfile, track_macro_expansion);\n \n-  if (arg->count == 0)\n+  if (arg->count == 0\n+      || arg->expanded != NULL)\n     return;\n \n   /* Don't warn about funlike macros when pre-expanding.  */\n   saved_warn_trad = CPP_WTRADITIONAL (pfile);\n   CPP_WTRADITIONAL (pfile) = 0;\n \n-  /* Loop, reading in the arguments.  */\n+  /* Loop, reading in the tokens of the argument.  */\n   capacity = 256;\n-  arg->expanded = XNEWVEC (const cpp_token *, capacity);\n+  alloc_expanded_arg_mem (pfile, arg, capacity);\n+\n+  if (track_macro_exp_p)\n+    push_extended_tokens_context (pfile, NULL, NULL,\n+\t\t\t\t  arg->virt_locs,\n+\t\t\t\t  arg->first,\n+\t\t\t\t  arg->count + 1);\n+  else\n+    push_ptoken_context (pfile, NULL, NULL,\n+\t\t\t arg->first, arg->count + 1);\n \n-  push_ptoken_context (pfile, NULL, NULL, arg->first, arg->count + 1);\n   for (;;)\n     {\n       const cpp_token *token;\n+      source_location location;\n \n-      if (arg->expanded_count + 1 >= capacity)\n-\t{\n-\t  capacity *= 2;\n-\t  arg->expanded = XRESIZEVEC (const cpp_token *, arg->expanded,\n-                                      capacity);\n-\t}\n+      ensure_expanded_arg_room (pfile, arg, arg->expanded_count + 1,\n+\t\t\t\t&capacity);\n \n-      token = cpp_get_token (pfile);\n+      token = cpp_get_token_1 (pfile, &location);\n \n       if (token->type == CPP_EOF)\n \tbreak;\n \n-      arg->expanded[arg->expanded_count++] = token;\n+      set_arg_token (arg, token, location,\n+\t\t     arg->expanded_count, MACRO_ARG_TOKEN_EXPANDED,\n+\t\t     CPP_OPTION (pfile, track_macro_expansion));\n+      arg->expanded_count++;\n     }\n \n   _cpp_pop_context (pfile);\n@@ -1199,38 +2065,153 @@ expand_arg (cpp_reader *pfile, macro_arg *arg)\n }\n \n /* Pop the current context off the stack, re-enabling the macro if the\n-   context represented a macro's replacement list.  The context\n-   structure is not freed so that we can re-use it later.  */\n+   context represented a macro's replacement list.  Initially the\n+   context structure was not freed so that we can re-use it later, but\n+   now we do free it to reduce peak memory consumption.  */\n void\n _cpp_pop_context (cpp_reader *pfile)\n {\n   cpp_context *context = pfile->context;\n \n-  if (context->macro)\n-    context->macro->flags &= ~NODE_DISABLED;\n+  if (context->c.macro)\n+    {\n+      cpp_hashnode *macro;\n+      if (context->tokens_kind == TOKENS_KIND_EXTENDED)\n+\t{\n+\t  macro_context *mc = context->c.mc;\n+\t  macro = mc->macro_node;\n+\t  /* If context->buff is set, it means the life time of tokens\n+\t     is bound to the life time of this context; so we must\n+\t     free the tokens; that means we must free the virtual\n+\t     locations of these tokens too.  */\n+\t  if (context->buff && mc->virt_locs)\n+\t    {\n+\t      free (mc->virt_locs);\n+\t      mc->virt_locs = NULL;\n+\t    }\n+\t  free (mc);\n+\t  context->c.mc = NULL;\n+\t}\n+      else\n+\tmacro = context->c.macro;\n+\n+      /* Beware that MACRO can be NULL in cases like when we are\n+\t called from expand_arg.  In those cases, a dummy context with\n+\t tokens is pushed just for the purpose of walking them using\n+\t cpp_get_token_1.  In that case, no 'macro' field is set into\n+\t the dummy context.  */\n+      if (macro != NULL)\n+\tmacro->flags &= ~NODE_DISABLED;\n+    }\n \n   if (context->buff)\n-    _cpp_release_buff (pfile, context->buff);\n+    {\n+      /* Decrease memory peak consumption by freeing the memory used\n+\t by the context.  */\n+      _cpp_free_buff (context->buff);\n+    }\n \n   pfile->context = context->prev;\n+  /* decrease peak memory consumption by feeing the context.  */\n+  pfile->context->next = NULL;\n+  free (context);\n }\n \n-/* External routine to get a token.  Also used nearly everywhere\n-   internally, except for places where we know we can safely call\n-   _cpp_lex_token directly, such as lexing a directive name.\n+/* Return TRUE if we reached the end of the set of tokens stored in\n+   CONTEXT, FALSE otherwise.  */\n+static inline bool\n+reached_end_of_context (cpp_context *context)\n+{\n+  if (context->tokens_kind == TOKENS_KIND_DIRECT)\n+      return FIRST (context).token == LAST (context).token;\n+  else if (context->tokens_kind == TOKENS_KIND_INDIRECT\n+\t   || context->tokens_kind == TOKENS_KIND_EXTENDED)\n+    return FIRST (context).ptoken == LAST (context).ptoken;\n+  else\n+    abort ();\n+}\n+\n+/* Consume the next token contained in the current context of PFILE,\n+   and return it in *TOKEN. It's \"full location\" is returned in\n+   *LOCATION. If -ftrack-macro-location is in effeect, fFull location\"\n+   means the location encoding the locus of the token accross macro\n+   expansion; otherwise it's just is the \"normal\" location of the\n+   token which (*TOKEN)->src_loc.  */\n+static inline void\n+consume_next_token_from_context (cpp_reader *pfile,\n+\t\t\t\t const cpp_token ** token,\n+\t\t\t\t source_location *location)\n+{\n+  cpp_context *c = pfile->context;\n+\n+  if ((c)->tokens_kind == TOKENS_KIND_DIRECT)\n+    {\n+      *token = FIRST (c).token;\n+      *location = (*token)->src_loc;\n+      FIRST (c).token++;\n+    }\n+  else if ((c)->tokens_kind == TOKENS_KIND_INDIRECT)\t\t\n+    {\n+      *token = *FIRST (c).ptoken;\n+      *location = (*token)->src_loc;\n+      FIRST (c).ptoken++;\n+    }\n+  else if ((c)->tokens_kind == TOKENS_KIND_EXTENDED)\n+    {\n+      macro_context *m = c->c.mc;\n+      *token = *FIRST (c).ptoken;\n+      if (m->virt_locs)\n+\t{\n+\t  *location = *m->cur_virt_loc;\n+\t  m->cur_virt_loc++;\n+\t}\n+      else\n+\t*location = (*token)->src_loc;\n+      FIRST (c).ptoken++;\n+    }\n+  else\n+    abort ();\n+}\n+\n+/* In the traditional mode of the preprocessor, if we are currently in\n+   a directive, the location of a token must be the location of the\n+   start of the directive line.  This function returns the proper\n+   location if we are in the traditional mode, and just returns\n+   LOCATION otherwise.  */\n+\n+static inline source_location\n+maybe_adjust_loc_for_trad_cpp (cpp_reader *pfile, source_location location)\n+{\n+  if (CPP_OPTION (pfile, traditional))\n+    {\n+      if (pfile->state.in_directive)\n+\treturn pfile->directive_line;\n+    }\n+  return location;\n+}\n+\n+/* Routine to get a token as well as its location.\n \n    Macro expansions and directives are transparently handled,\n    including entering included files.  Thus tokens are post-macro\n    expansion, and after any intervening directives.  External callers\n    see CPP_EOF only at EOF.  Internal callers also see it when meeting\n    a directive inside a macro call, when at the end of a directive and\n    state.in_directive is still 1, and at the end of argument\n-   pre-expansion.  */\n-const cpp_token *\n-cpp_get_token (cpp_reader *pfile)\n+   pre-expansion.\n+\n+   LOC is an out parameter; *LOC is set to the location \"as expected\n+   by the user\".  Please read the comment of\n+   cpp_get_token_with_location to learn more about the meaning of this\n+   location.  */\n+static const cpp_token*\n+cpp_get_token_1 (cpp_reader *pfile, source_location *location)\n {\n   const cpp_token *result;\n   bool can_set = pfile->set_invocation_location;\n+  /* This token is a virtual token that either encodes a location\n+     related to macro expansion or a spelling location.  */\n+  source_location virt_loc = 0;\n   pfile->set_invocation_location = false;\n \n   for (;;)\n@@ -1240,28 +2221,30 @@ cpp_get_token (cpp_reader *pfile)\n \n       /* Context->prev == 0 <=> base context.  */\n       if (!context->prev)\n-\tresult = _cpp_lex_token (pfile);\n-      else if (FIRST (context).token != LAST (context).token)\n \t{\n-\t  if (context->direct_p)\n-\t    result = FIRST (context).token++;\n-\t  else\n-\t    result = *FIRST (context).ptoken++;\n-\n+\t  result = _cpp_lex_token (pfile);\n+\t  virt_loc = result->src_loc;\n+\t}\n+      else if (!reached_end_of_context (context))\n+\t{\n+\t  consume_next_token_from_context (pfile, &result,\n+\t\t\t\t\t   &virt_loc);\n \t  if (result->flags & PASTE_LEFT)\n \t    {\n \t      paste_all_tokens (pfile, result);\n \t      if (pfile->state.in_directive)\n \t\tcontinue;\n-\t      return padding_token (pfile, result);\n+\t      result = padding_token (pfile, result);\n+\t      goto out;\n \t    }\n \t}\n       else\n \t{\n \t  _cpp_pop_context (pfile);\n \t  if (pfile->state.in_directive)\n \t    continue;\n-\t  return &pfile->avoid_paste;\n+\t  result = &pfile->avoid_paste;\n+\t  goto out;\n \t}\n \n       if (pfile->state.in_directive && result->type == CPP_COMMENT)\n@@ -1280,7 +2263,7 @@ cpp_get_token (cpp_reader *pfile)\n \t  int ret = 0;\n \t  /* If not in a macro context, and we're going to start an\n \t     expansion, record the location.  */\n-\t  if (can_set && !context->macro)\n+\t  if (can_set && !context->c.macro)\n \t    pfile->invocation_location = result->src_loc;\n \t  if (pfile->state.prevent_expansion)\n \t    break;\n@@ -1298,7 +2281,8 @@ cpp_get_token (cpp_reader *pfile)\n \t\t\t\t      || (peek_tok->flags & PREV_WHITE));\n \t\t  node = pfile->cb.macro_to_expand (pfile, result);\n \t\t  if (node)\n-\t\t    ret = enter_macro_context (pfile, node, result);\n+\t\t    ret = enter_macro_context (pfile, node, result,\n+\t\t\t\t\t       virt_loc);\n \t\t  else if (whitespace_after)\n \t\t    {\n \t\t      /* If macro_to_expand hook returned NULL and it\n@@ -1315,12 +2299,14 @@ cpp_get_token (cpp_reader *pfile)\n \t\t}\n \t    }\n \t  else\n-\t    ret = enter_macro_context (pfile, node, result);\n+\t    ret = enter_macro_context (pfile, node, result, \n+\t\t\t\t       virt_loc);\n \t  if (ret)\n  \t    {\n \t      if (pfile->state.in_directive || ret == 2)\n \t\tcontinue;\n-\t      return padding_token (pfile, result);\n+\t      result = padding_token (pfile, result);\n+\t      goto out;\n \t    }\n \t}\n       else\n@@ -1337,27 +2323,88 @@ cpp_get_token (cpp_reader *pfile)\n       break;\n     }\n \n+ out:\n+  if (location != NULL)\n+    {\n+      if (virt_loc == 0)\n+\tvirt_loc = result->src_loc;\n+      *location = virt_loc;\n+\n+      if (!CPP_OPTION (pfile, track_macro_expansion)\n+\t  && can_set\n+\t  && pfile->context->c.macro != NULL)\n+\t/* We are in a macro expansion context, are not tracking\n+\t   virtual location, but were asked to report the location\n+\t   of the expansion point of the macro being expanded.  */\n+\t*location = pfile->invocation_location;\n+\n+      *location = maybe_adjust_loc_for_trad_cpp (pfile, *location);\n+    }\n   return result;\n }\n \n-/* Like cpp_get_token, but also returns a location separate from the\n-   one provided by the returned token.  LOC is an out parameter; *LOC\n-   is set to the location \"as expected by the user\".  This matters\n-   when a token results from macro expansion -- the token's location\n-   will indicate where the macro is defined, but *LOC will be the\n-   location of the start of the expansion.  */\n+/* External routine to get a token.  Also used nearly everywhere\n+   internally, except for places where we know we can safely call\n+   _cpp_lex_token directly, such as lexing a directive name.\n+\n+   Macro expansions and directives are transparently handled,\n+   including entering included files.  Thus tokens are post-macro\n+   expansion, and after any intervening directives.  External callers\n+   see CPP_EOF only at EOF.  Internal callers also see it when meeting\n+   a directive inside a macro call, when at the end of a directive and\n+   state.in_directive is still 1, and at the end of argument\n+   pre-expansion.  */\n+const cpp_token *\n+cpp_get_token (cpp_reader *pfile)\n+{\n+  return cpp_get_token_1 (pfile, NULL);\n+}\n+\n+/* Like cpp_get_token, but also returns a virtual token location\n+   separate from the spelling location carried by the returned token.\n+\n+   LOC is an out parameter; *LOC is set to the location \"as expected\n+   by the user\".  This matters when a token results from macro\n+   expansion; in that case the token's spelling location indicates the\n+   locus of the token in the definition of the macro but *LOC\n+   virtually encodes all the other meaningful locuses associated to\n+   the token.\n+\n+   What? virtual location? Yes, virtual location.\n+\n+   If the token results from macro expansion and if macro expansion\n+   location tracking is enabled its virtual location encodes (at the\n+   same time):\n+\n+   - the spelling location of the token\n+\n+   - the locus of the macro expansion point\n+\n+   - the locus of the point where the token got instantiated as part\n+     of the macro expansion process.\n+\n+   You have to use the linemap API to get the locus you are interested\n+   in from a given virtual location.\n+\n+   Note however that virtual locations are not necessarily ordered for\n+   relations '<' and '>'.  One must use the function\n+   linemap_location_before_p instead of using the relational operator\n+   '<'.\n+\n+   If macro expansion tracking is off and if the token results from\n+   macro expansion the virtual location is the expansion point of the\n+   macro that got expanded.\n+\n+   When the token doesn't result from macro expansion, the virtual\n+   location is just the same thing as its spelling location.  */\n+\n const cpp_token *\n cpp_get_token_with_location (cpp_reader *pfile, source_location *loc)\n {\n   const cpp_token *result;\n \n   pfile->set_invocation_location = true;\n-  result = cpp_get_token (pfile);\n-  if (pfile->context->macro)\n-    *loc = pfile->invocation_location;\n-  else\n-    *loc = result->src_loc;\n-\n+  result = cpp_get_token_1 (pfile, loc);\n   return result;\n }\n \n@@ -1367,7 +2414,7 @@ cpp_get_token_with_location (cpp_reader *pfile, source_location *loc)\n int\n cpp_sys_macro_p (cpp_reader *pfile)\n {\n-  cpp_hashnode *node = pfile->context->macro;\n+  cpp_hashnode *node = pfile->context->c.macro;\n \n   return node && node->value.macro && node->value.macro->syshdr;\n }\n@@ -1424,10 +2471,27 @@ _cpp_backup_tokens (cpp_reader *pfile, unsigned int count)\n     {\n       if (count != 1)\n \tabort ();\n-      if (pfile->context->direct_p)\n+      if (pfile->context->tokens_kind == TOKENS_KIND_DIRECT)\n \tFIRST (pfile->context).token--;\n-      else\n+      else if (pfile->context->tokens_kind == TOKENS_KIND_INDIRECT)\n \tFIRST (pfile->context).ptoken--;\n+      else if (pfile->context->tokens_kind == TOKENS_KIND_EXTENDED)\n+\t{\n+\t  FIRST (pfile->context).ptoken--;\n+\t  if (pfile->context->c.macro)\n+\t    {\n+\t      macro_context *m = pfile->context->c.mc;\n+\t      m->cur_virt_loc--;\n+#ifdef ENABLE_CHECKING\n+\t      if (m->cur_virt_loc < m->virt_locs)\n+\t\tabort ();\n+#endif\n+\t    }\n+\t  else\n+\t    abort ();\n+\t}\n+      else\n+\tabort ();\n     }\n }\n "}, {"sha": "4206b6fa7683f5802e8407c08e6f99fdbeaf095c", "filename": "libcpp/traditional.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2Ftraditional.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92582b753e34fd574b6a5672b2f82979c966187a/libcpp%2Ftraditional.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ftraditional.c?ref=92582b753e34fd574b6a5672b2f82979c966187a", "patch": "@@ -738,7 +738,7 @@ recursive_macro (cpp_reader *pfile, cpp_hashnode *node)\n       do\n \t{\n \t  depth++;\n-\t  if (context->macro == node && depth > 20)\n+\t  if (context->c.macro == node && depth > 20)\n \t    break;\n \t  context = context->prev;\n \t}"}]}