{"sha": "39403d8233deb862fc951f95cd11280440c90880", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk0MDNkODIzM2RlYjg2MmZjOTUxZjk1Y2QxMTI4MDQ0MGM5MDg4MA==", "commit": {"author": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "1998-07-02T11:53:24Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "1998-07-02T11:53:24Z"}, "message": "expr.h (STACK_SIZE_MODE): New macro.\n\n        * expr.h (STACK_SIZE_MODE): New macro.\n        * explow.c (allocate_dynamic_stack_space): Use it for\n        mode of allocate_stack pattern increment operand.\n        * tm.texi (STACK_SAVEAREA_MODE, STACK_SIZE_MODE): Document.\n        * md.texi (stack_save_block, ...): Reflect use of macro.\n        * rs6000.h (PROMOTE_MODE): Always promote to word_mode.\n        (PROMOTE_FUNCTION_ARGS): Define.\n        (PROMOTE_FUNCTION_RETURN): Define.\n        (FUNCTION_VALUE): Promote to word_mode if smaller.\n        Convert to gen_rtx_FOO.\n        * rs6000.md (call_indirect): Store doubleword in 64-bit mode.\n        Convert to gen_rtx_FOO.\n\nFrom-SVN: r20893", "tree": {"sha": "f6d56239789abb75a54e7c041d4876cd372838ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6d56239789abb75a54e7c041d4876cd372838ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39403d8233deb862fc951f95cd11280440c90880", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39403d8233deb862fc951f95cd11280440c90880", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39403d8233deb862fc951f95cd11280440c90880", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39403d8233deb862fc951f95cd11280440c90880/comments", "author": null, "committer": null, "parents": [{"sha": "848205e6edc05cb41e877c5835244ce3bd133fda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/848205e6edc05cb41e877c5835244ce3bd133fda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/848205e6edc05cb41e877c5835244ce3bd133fda"}], "stats": {"total": 341, "additions": 195, "deletions": 146}, "files": [{"sha": "0c525c041e3121b9f3246eac9c4c54bf5a5e8209", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39403d8233deb862fc951f95cd11280440c90880/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39403d8233deb862fc951f95cd11280440c90880/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39403d8233deb862fc951f95cd11280440c90880", "patch": "@@ -1,3 +1,20 @@\n+Thu Jul  2 14:34:48 1998  David Edelsohn  <edelsohn@mhpcc.edu>\n+\n+\t* expr.h (STACK_SIZE_MODE): New macro.\n+\t* explow.c (allocate_dynamic_stack_space): Use it for\n+\tmode of allocate_stack pattern increment operand.\n+\t* tm.texi (STACK_SAVEAREA_MODE, STACK_SIZE_MODE): Document.\n+\t* md.texi (stack_save_block, ...): Reflect use of macro.\n+\n+\t* rs6000.h (PROMOTE_MODE): Always promote to word_mode.\n+\t(PROMOTE_FUNCTION_ARGS): Define.\n+\t(PROMOTE_FUNCTION_RETURN): Define.\n+\t(FUNCTION_VALUE): Promote to word_mode if smaller.\n+\tConvert to gen_rtx_FOO.\n+\t* rs6000.md (call_indirect): Store doubleword in 64-bit mode.\n+\tConvert to gen_rtx_FOO.\n+\t* rs6000.c: Convert to gen_rtx_FOO.\n+\t\n Thu Jul  2 14:16:11 1998  Michael Meissner  <meissner@cygnus.com>\n \n \t* varray.{c,h}: New files to provide virtual array support.\n@@ -344,7 +361,7 @@ Sat Jun 27 20:20:00 1998  John Carr  <jfc@mit.edu>\n \n Sat Jun 27 20:18:34 1998  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n \n-\t* rs6000.c: Add trap_comparison_operator to PREDICATE_CODES.\n+\t* rs6000.h: Add trap_comparison_operator to PREDICATE_CODES.\n \n Sat Jun 27 16:45:42 1998  Jeffrey A Law  (law@cygnus.com)\n "}, {"sha": "379488c7523c733cf8aad5d89bf058e5749cf43e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39403d8233deb862fc951f95cd11280440c90880/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39403d8233deb862fc951f95cd11280440c90880/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=39403d8233deb862fc951f95cd11280440c90880", "patch": "@@ -1445,12 +1445,12 @@ function_arg (cum, mode, type, named)\n \t      && (DEFAULT_ABI != ABI_AIX\n \t\t  || ! TARGET_XL_CALL\n \t\t  || (align_words < GP_ARG_NUM_REG))))\n-\treturn gen_rtx (REG, mode, cum->fregno);\n+\treturn gen_rtx_REG (mode, cum->fregno);\n \n-      return gen_rtx (PARALLEL, mode,\n+      return gen_rtx_PARALLEL (mode,\n \t\t      gen_rtvec\n \t\t      (2,\n-\t\t       gen_rtx (EXPR_LIST, VOIDmode,\n+\t\t       gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t((align_words >= GP_ARG_NUM_REG)\n \t\t\t\t ? NULL_RTX\n \t\t\t\t : (align_words\n@@ -1459,13 +1459,13 @@ function_arg (cum, mode, type, named)\n \t\t\t\t    /* If this is partially on the stack, then\n \t\t\t\t       we only include the portion actually\n \t\t\t\t       in registers here.  */\n-\t\t\t\t    ? gen_rtx (REG, SImode,\n+\t\t\t\t    ? gen_rtx_REG (SImode,\n \t\t\t\t\t       GP_ARG_MIN_REG + align_words)\n-\t\t\t\t    : gen_rtx (REG, mode,\n+\t\t\t\t    : gen_rtx_REG (mode,\n \t\t\t\t\t       GP_ARG_MIN_REG + align_words))),\n \t\t\t\tconst0_rtx),\n-\t\t       gen_rtx (EXPR_LIST, VOIDmode,\n-\t\t\t\tgen_rtx (REG, mode, cum->fregno),\n+\t\t       gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\tgen_rtx_REG (mode, cum->fregno),\n \t\t\t\tconst0_rtx)));\n     }\n \n@@ -1479,7 +1479,7 @@ function_arg (cum, mode, type, named)\n     }\n \n   else if (align_words < GP_ARG_NUM_REG)\n-    return gen_rtx (REG, mode, GP_ARG_MIN_REG + align_words);\n+    return gen_rtx_REG (mode, GP_ARG_MIN_REG + align_words);\n \n   return NULL_RTX;\n }\n@@ -1601,7 +1601,7 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n       if (!no_rtl && first_reg_offset != GP_ARG_NUM_REG)\n \tmove_block_from_reg\n \t  (GP_ARG_MIN_REG + first_reg_offset,\n-\t   gen_rtx (MEM, BLKmode,\n+\t   gen_rtx_MEM (BLKmode,\n \t\t    plus_constant (save_area, first_reg_offset * reg_size)),\n \t   GP_ARG_NUM_REG - first_reg_offset,\n \t   (GP_ARG_NUM_REG - first_reg_offset) * UNITS_PER_WORD);\n@@ -1617,21 +1617,21 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n \n       if (num_fp_reg >= 0)\n \t{\n-\t  rtx cr1 = gen_rtx (REG, CCmode, 69);\n+\t  rtx cr1 = gen_rtx_REG (CCmode, 69);\n \t  rtx lab = gen_label_rtx ();\n \t  int off = (GP_ARG_NUM_REG * reg_size) + ((fregno - FP_ARG_MIN_REG) * 8);\n \n-\t  emit_jump_insn (gen_rtx (SET, VOIDmode,\n+\t  emit_jump_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\t   pc_rtx,\n-\t\t\t\t   gen_rtx (IF_THEN_ELSE, VOIDmode,\n-\t\t\t\t\t    gen_rtx (NE, VOIDmode, cr1, const0_rtx),\n-\t\t\t\t\t    gen_rtx (LABEL_REF, VOIDmode, lab),\n+\t\t\t\t   gen_rtx_IF_THEN_ELSE (VOIDmode,\n+\t\t\t\t\t    gen_rtx_NE (VOIDmode, cr1, const0_rtx),\n+\t\t\t\t\t    gen_rtx_LABEL_REF (VOIDmode, lab),\n \t\t\t\t\t    pc_rtx)));\n \n \t  while ( num_fp_reg-- >= 0)\n \t    {\n-\t      emit_move_insn (gen_rtx (MEM, DFmode, plus_constant (save_area, off)),\n-\t\t\t      gen_rtx (REG, DFmode, fregno++));\n+\t      emit_move_insn (gen_rtx_MEM (DFmode, plus_constant (save_area, off)),\n+\t\t\t      gen_rtx_REG (DFmode, fregno++));\n \t      off += 8;\n \t    }\n \n@@ -1673,7 +1673,7 @@ expand_block_move_mem (mode, addr, orig_mem)\n      rtx addr;\n      rtx orig_mem;\n {\n-  rtx mem = gen_rtx (MEM, mode, addr);\n+  rtx mem = gen_rtx_MEM (mode, addr);\n \n   RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (orig_mem);\n   MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (orig_mem);\n@@ -1849,8 +1849,8 @@ expand_block_move (operands)\n \t    }\n \t  else\n \t    {\n-\t      src_addr  = gen_rtx (PLUS, Pmode, src_reg,  GEN_INT (offset));\n-\t      dest_addr = gen_rtx (PLUS, Pmode, dest_reg, GEN_INT (offset));\n+\t      src_addr  = gen_rtx_PLUS (Pmode, src_reg,  GEN_INT (offset));\n+\t      dest_addr = gen_rtx_PLUS (Pmode, dest_reg, GEN_INT (offset));\n \t    }\n \n \t  /* Generate the appropriate load and store, saving the stores for later */\n@@ -2267,7 +2267,7 @@ rs6000_got_register (value)\n \tfatal_insn (\"internal error -- needed new GOT register during reload phase to load:\", value);\n \n       current_function_uses_pic_offset_table = 1;\n-      pic_offset_table_rtx = gen_rtx (REG, Pmode, GOT_TOC_REGNUM);\n+      pic_offset_table_rtx = gen_rtx_REG (Pmode, GOT_TOC_REGNUM);\n     }\n \n   return pic_offset_table_rtx;\n@@ -2388,7 +2388,7 @@ rs6000_finalize_pic ()\n \t  rtx init = gen_init_v4_pic (reg);\n \t  emit_insn_before (init, first_insn);\n \t  if (!optimize && last_insn)\n-\t    emit_insn_after (gen_rtx (USE, VOIDmode, reg), last_insn);\n+\t    emit_insn_after (gen_rtx_USE (VOIDmode, reg), last_insn);\n \t}\n     }\n }\n@@ -2403,7 +2403,7 @@ rs6000_reorg (insn)\n {\n   if (flag_pic && (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS))\n     {\n-      rtx got_reg = gen_rtx (REG, Pmode, GOT_TOC_REGNUM);\n+      rtx got_reg = gen_rtx_REG (Pmode, GOT_TOC_REGNUM);\n       for ( ; insn != NULL_RTX; insn = NEXT_INSN (insn))\n \tif (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n \t    && reg_mentioned_p (got_reg, PATTERN (insn)))\n@@ -4925,8 +4925,8 @@ rs6000_initialize_trampoline (addr, fnaddr, cxt)\n       abort ();\n \n /* Macros to shorten the code expansions below.  */\n-#define MEM_DEREF(addr) gen_rtx (MEM, pmode, memory_address (pmode, addr))\n-#define MEM_PLUS(addr,offset) gen_rtx (MEM, pmode, memory_address (pmode, plus_constant (addr, offset)))\n+#define MEM_DEREF(addr) gen_rtx_MEM (pmode, memory_address (pmode, addr))\n+#define MEM_PLUS(addr,offset) gen_rtx_MEM (pmode, memory_address (pmode, plus_constant (addr, offset)))\n \n     /* Under AIX, just build the 3 word function descriptor */\n     case ABI_AIX:\n@@ -4945,7 +4945,7 @@ rs6000_initialize_trampoline (addr, fnaddr, cxt)\n     case ABI_V4:\n     case ABI_SOLARIS:\n     case ABI_AIX_NODESC:\n-      emit_library_call (gen_rtx (SYMBOL_REF, SImode, \"__trampoline_setup\"),\n+      emit_library_call (gen_rtx_SYMBOL_REF (SImode, \"__trampoline_setup\"),\n \t\t\t FALSE, VOIDmode, 4,\n \t\t\t addr, pmode,\n \t\t\t GEN_INT (rs6000_trampoline_size ()), SImode,\n@@ -4962,15 +4962,15 @@ rs6000_initialize_trampoline (addr, fnaddr, cxt)\n \trtx fn_reg = gen_reg_rtx (pmode);\n \trtx toc_reg = gen_reg_rtx (pmode);\n \n-\temit_move_insn (tramp_reg, gen_rtx (SYMBOL_REF, pmode, \"..LTRAMP1..0\"));\n+\temit_move_insn (tramp_reg, gen_rtx_SYMBOL_REF (pmode, \"..LTRAMP1..0\"));\n \taddr = force_reg (pmode, addr);\n \temit_move_insn (fn_reg, MEM_DEREF (fnaddr));\n \temit_move_insn (toc_reg, MEM_PLUS (fnaddr, regsize));\n \temit_move_insn (MEM_DEREF (addr), tramp_reg);\n \temit_move_insn (MEM_PLUS (addr, regsize), addr);\n \temit_move_insn (MEM_PLUS (addr, 2*regsize), fn_reg);\n \temit_move_insn (MEM_PLUS (addr, 3*regsize), ctx_reg);\n-\temit_move_insn (MEM_PLUS (addr, 4*regsize), gen_rtx (REG, pmode, 2));\n+\temit_move_insn (MEM_PLUS (addr, 4*regsize), gen_rtx_REG (pmode, 2));\n       }\n       break;\n     }\n@@ -5107,8 +5107,8 @@ rs6000_dll_import_ref (call_ref)\n   strcat (p, call_name);\n   node = get_identifier (p);\n \n-  reg1 = force_reg (Pmode, gen_rtx (SYMBOL_REF, VOIDmode, IDENTIFIER_POINTER (node)));\n-  emit_move_insn (reg2, gen_rtx (MEM, Pmode, reg1));\n+  reg1 = force_reg (Pmode, gen_rtx_SYMBOL_REF (VOIDmode, IDENTIFIER_POINTER (node)));\n+  emit_move_insn (reg2, gen_rtx_MEM (Pmode, reg1));\n \n   return reg2;\n }\n@@ -5132,7 +5132,7 @@ rs6000_longcall_ref (call_ref)\n \tcall_name++;\n \n       node = get_identifier (call_name);\n-      call_ref = gen_rtx (SYMBOL_REF, VOIDmode, IDENTIFIER_POINTER (node));\n+      call_ref = gen_rtx_SYMBOL_REF (VOIDmode, IDENTIFIER_POINTER (node));\n     }\n \n   return force_reg (Pmode, call_ref);"}, {"sha": "fcfbcf763524dbb31ec9b0d5ebb4d6b7b14ea830", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39403d8233deb862fc951f95cd11280440c90880/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39403d8233deb862fc951f95cd11280440c90880/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=39403d8233deb862fc951f95cd11280440c90880", "patch": "@@ -483,10 +483,19 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n    type, but kept valid in the wider mode.  The signedness of the\n    extension may differ from that of the type.  */\n \n-#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)  \\\n-  if (GET_MODE_CLASS (MODE) == MODE_INT\t\\\n-      && GET_MODE_SIZE (MODE) < 4)  \t\\\n-    (MODE) = SImode;\n+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)\t\\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD) \\\n+    (MODE) = (! TARGET_POWERPC64 ? SImode : DImode);\n+\n+/* Define this if function arguments should also be promoted using the above\n+   procedure.  */\n+\n+#define PROMOTE_FUNCTION_ARGS\n+\n+/* Likewise, if the function return value is promoted.  */\n+\n+#define PROMOTE_FUNCTION_RETURN\n \n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields. */\n@@ -1303,15 +1312,19 @@ extern int rs6000_sysv_varargs_p;\n    On RS/6000 an integer value is in r3 and a floating-point value is in\n    fp1, unless -msoft-float.  */\n \n-#define FUNCTION_VALUE(VALTYPE, FUNC)\t\\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE),\t\\\n-\t   TREE_CODE (VALTYPE) == REAL_TYPE && TARGET_HARD_FLOAT ? 33 : 3)\n+#define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\\\n+  gen_rtx_REG ((INTEGRAL_TYPE_P (VALTYPE)\t\t\t\\\n+\t\t&& TYPE_PRECISION (VALTYPE) < BITS_PER_WORD)\t\\\n+\t       || POINTER_TYPE_P (VALTYPE)\t\t\t\\\n+\t       ? word_mode : TYPE_MODE (VALTYPE),\t\t\\\n+\t       TREE_CODE (VALTYPE) == REAL_TYPE && TARGET_HARD_FLOAT ? 33 : 3)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n #define LIBCALL_VALUE(MODE)\t\t\\\n-  gen_rtx (REG, MODE, GET_MODE_CLASS (MODE) == MODE_FLOAT && TARGET_HARD_FLOAT ? 33 : 3)\n+  gen_rtx_REG (MODE,\t\t\t\\\n+\t       GET_MODE_CLASS (MODE) == MODE_FLOAT && TARGET_HARD_FLOAT ? 33 : 3)\n \n /* The definition of this macro implies that there are cases where\n    a scalar value cannot be returned in registers.\n@@ -1624,10 +1637,10 @@ typedef struct rs6000_args\n    frame pointer.  */\n #define RETURN_ADDR_RTX(count, frame)\t\t\t\\\n   ((count == -1)\t\t\t\t\t\\\n-   ? gen_rtx (REG, Pmode, 65)\t\t\t\t\\\n-   : gen_rtx (MEM, Pmode,\t\t\t\t\\\n+   ? gen_rtx_REG (Pmode, 65)\t\t\t\t\\\n+   : gen_rtx_MEM (Pmode,\t\t\t\t\\\n \t      memory_address (Pmode, \t\t\t\\\n-\t\t\t      plus_constant (copy_to_reg (gen_rtx (MEM, Pmode, \\\n+\t\t\t      plus_constant (copy_to_reg (gen_rtx_MEM (Pmode, \\\n \t\t\t\t\t\t\t\t   memory_address (Pmode, frame))), \\\n \t\t\t\t\t     RETURN_ADDRESS_OFFSET))))\n \f\n@@ -1900,9 +1913,9 @@ typedef struct rs6000_args\n       low_int = INTVAL (XEXP (X, 1)) & 0xffff;\t\t\t\t\\\n       if (low_int & 0x8000)\t\t\t\t\t\t\\\n \thigh_int += 0x10000, low_int |= ((HOST_WIDE_INT) -1) << 16;\t\\\n-      sum = force_operand (gen_rtx (PLUS, Pmode, XEXP (X, 0),\t\t\\\n+      sum = force_operand (gen_rtx_PLUS (Pmode, XEXP (X, 0),\t\t\\\n \t\t\t\t    GEN_INT (high_int)), 0);\t\t\\\n-      (X) = gen_rtx (PLUS, Pmode, sum, GEN_INT (low_int));\t\t\\\n+      (X) = gen_rtx_PLUS (Pmode, sum, GEN_INT (low_int));\t\t\\\n       goto WIN;\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG\t\\\n@@ -1911,7 +1924,7 @@ typedef struct rs6000_args\n \t   && (TARGET_64BIT || (MODE) != DImode)\t\t\t\\\n \t   && (MODE) != TImode)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      (X) = gen_rtx (PLUS, Pmode, XEXP (X, 0),\t\t\t\t\\\n+      (X) = gen_rtx_PLUS (Pmode, XEXP (X, 0),\t\t\t\t\\\n \t\t     force_reg (Pmode, force_operand (XEXP (X, 1), 0))); \\\n       goto WIN;\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n@@ -1924,7 +1937,7 @@ typedef struct rs6000_args\n     {\t\t\t\t\t\t\t\t\t\\\n       rtx reg = gen_reg_rtx (Pmode);\t\t\t\t\t\\\n       emit_insn (gen_elf_high (reg, (X)));\t\t\t\t\\\n-      (X) = gen_rtx (LO_SUM, Pmode, reg, (X));\t\t\t\t\\\n+      (X) = gen_rtx_LO_SUM (Pmode, reg, (X));\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n@@ -3135,7 +3148,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"trap_comparison_operator\", {EQ, NE, LE, LT, GE,\t\t\\\n \t\t\t\tGT, LEU, LTU, GEU, GTU}},\n \n-\n /* uncomment for disabling the corresponding default options */\n /* #define  MACHINE_no_sched_interblock */\n /* #define  MACHINE_no_sched_speculative */"}, {"sha": "9fe4bfa63193bed3c16d4f9d0c2c072f94989b41", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 92, "deletions": 92, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39403d8233deb862fc951f95cd11280440c90880/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39403d8233deb862fc951f95cd11280440c90880/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=39403d8233deb862fc951f95cd11280440c90880", "patch": "@@ -1369,11 +1369,11 @@\n {\n   if (! TARGET_POWER && ! TARGET_POWERPC)\n     {\n-      emit_move_insn (gen_rtx (REG, SImode, 3), operands[1]);\n-      emit_move_insn (gen_rtx (REG, SImode, 4), operands[2]);\n+      emit_move_insn (gen_rtx_REG (SImode, 3), operands[1]);\n+      emit_move_insn (gen_rtx_REG (SImode, 4), operands[2]);\n       emit_insn (gen_divss_call ());\n-      emit_move_insn (operands[0], gen_rtx (REG, SImode, 3));\n-      emit_move_insn (operands[3], gen_rtx (REG, SImode, 4));\n+      emit_move_insn (operands[0], gen_rtx_REG (SImode, 3));\n+      emit_move_insn (operands[3], gen_rtx_REG (SImode, 4));\n       DONE;\n     }\n }\")\n@@ -1397,10 +1397,10 @@\n {\n   if (! TARGET_POWER && ! TARGET_POWERPC)\n     {\n-      emit_move_insn (gen_rtx (REG, SImode, 3), operands[1]);\n-      emit_move_insn (gen_rtx (REG, SImode, 4), operands[2]);\n+      emit_move_insn (gen_rtx_REG (SImode, 3), operands[1]);\n+      emit_move_insn (gen_rtx_REG (SImode, 4), operands[2]);\n       emit_insn (gen_quous_call ());\n-      emit_move_insn (operands[0], gen_rtx (REG, SImode, 3));\n+      emit_move_insn (operands[0], gen_rtx_REG (SImode, 3));\n       DONE;\n     }\n   else if (TARGET_POWER)\n@@ -1454,10 +1454,10 @@\n     FAIL;\n   else\n     {\n-      emit_move_insn (gen_rtx (REG, SImode, 3), operands[1]);\n-      emit_move_insn (gen_rtx (REG, SImode, 4), operands[2]);\n+      emit_move_insn (gen_rtx_REG (SImode, 3), operands[1]);\n+      emit_move_insn (gen_rtx_REG (SImode, 4), operands[2]);\n       emit_insn (gen_quoss_call ());\n-      emit_move_insn (operands[0], gen_rtx (REG, SImode, 3));\n+      emit_move_insn (operands[0], gen_rtx_REG (SImode, 3));\n       DONE;\n     }\n }\")\n@@ -1605,11 +1605,11 @@\n     {\n       if (! TARGET_POWERPC)\n         {\n-\t  emit_move_insn (gen_rtx (REG, SImode, 3), operands[1]);\n-\t  emit_move_insn (gen_rtx (REG, SImode, 4), operands[2]);\n+\t  emit_move_insn (gen_rtx_REG (SImode, 3), operands[1]);\n+\t  emit_move_insn (gen_rtx_REG (SImode, 4), operands[2]);\n \t  emit_insn (gen_divus_call ());\n-\t  emit_move_insn (operands[0], gen_rtx (REG, SImode, 3));\n-\t  emit_move_insn (operands[3], gen_rtx (REG, SImode, 4));\n+\t  emit_move_insn (operands[0], gen_rtx_REG (SImode, 3));\n+\t  emit_move_insn (operands[3], gen_rtx_REG (SImode, 4));\n \t  DONE;\n         }\n       else\n@@ -3665,7 +3665,7 @@\n   \"\n {\n   operands[6] = GEN_INT (0x80000000);\n-  operands[7] = gen_rtx (REG, DFmode, FPMEM_REGNUM);\n+  operands[7] = gen_rtx_REG (DFmode, FPMEM_REGNUM);\n }\")\n \n (define_expand \"floatunssidf2\"\n@@ -3717,7 +3717,7 @@\n    (set (match_dup 0)\n \t(minus:DF (match_dup 0)\n \t\t  (match_dup 3)))]\n-  \"operands[5] = gen_rtx (REG, DFmode, FPMEM_REGNUM);\")\n+  \"operands[5] = gen_rtx_REG (DFmode, FPMEM_REGNUM);\")\n \n ;; Load up scratch register with base address + offset if needed\n (define_insn \"*floatsidf2_loadaddr\"\n@@ -3756,8 +3756,8 @@\n   else\n     indx = stack_pointer_rtx;\n \n-  operands[2] = gen_rtx (MEM, SImode,\n-\t\t\t gen_rtx (PLUS, Pmode,\n+  operands[2] = gen_rtx_MEM (SImode,\n+\t\t\t gen_rtx_PLUS (Pmode,\n \t\t\t\t  indx,\n \t\t\t\t  GEN_INT ((((rs6000_fpmem_offset & 0xffff) ^ 0x8000) - 0x8000)\n \t\t\t\t\t   + ((WORDS_BIG_ENDIAN != 0) * 4))));\n@@ -3783,8 +3783,8 @@\n   else\n     indx = stack_pointer_rtx;\n \n-  operands[2] = gen_rtx (MEM, SImode,\n-\t\t\t gen_rtx (PLUS, Pmode,\n+  operands[2] = gen_rtx_MEM (SImode,\n+\t\t\t gen_rtx_PLUS (Pmode,\n \t\t\t\t  indx,\n \t\t\t\t  GEN_INT ((((rs6000_fpmem_offset & 0xffff) ^ 0x8000) - 0x8000)\n \t\t\t\t\t   + ((WORDS_BIG_ENDIAN == 0) * 4))));\n@@ -3813,8 +3813,8 @@\n   else\n     indx = stack_pointer_rtx;\n \n-  operands[2] = gen_rtx (MEM, SImode,\n-\t\t\t gen_rtx (PLUS, Pmode, indx, GEN_INT (offset)));\n+  operands[2] = gen_rtx_MEM (SImode,\n+\t\t\t gen_rtx_PLUS (Pmode, indx, GEN_INT (offset)));\n \n   return \\\"lfd %0,%2\\\";\n }\"\n@@ -3832,13 +3832,13 @@\n   if (!TARGET_POWER2 && !TARGET_POWERPC)\n     {\n       emit_insn (gen_trunc_call (operands[0], operands[1],\n-\t\t\t\t gen_rtx (SYMBOL_REF, Pmode, RS6000_ITRUNC)));\n+\t\t\t\t gen_rtx_SYMBOL_REF (Pmode, RS6000_ITRUNC)));\n       DONE;\n     }\n \n   operands[2] = gen_reg_rtx (DImode);\n   operands[3] = gen_reg_rtx (Pmode);\n-  operands[4] = gen_rtx (REG, DImode, FPMEM_REGNUM);\n+  operands[4] = gen_rtx_REG (DImode, FPMEM_REGNUM);\n }\")\n \n (define_insn \"*fix_truncdfsi2_internal\"\n@@ -3868,7 +3868,7 @@\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(unspec [(match_dup 4)\n \t\t (match_dup 3)] 16))]\n-  \"operands[4] = gen_rtx (REG, DImode, FPMEM_REGNUM);\")\n+  \"operands[4] = gen_rtx_REG (DImode, FPMEM_REGNUM);\")\n \n (define_insn \"*fix_truncdfsi2_store\"\n   [(set (reg:DI 76)\n@@ -3886,8 +3886,8 @@\n   else\n     indx = stack_pointer_rtx;\n \n-  operands[2] = gen_rtx (MEM, DFmode,\n-\t\t\t gen_rtx (PLUS, Pmode,\n+  operands[2] = gen_rtx_MEM (DFmode,\n+\t\t\t gen_rtx_PLUS (Pmode,\n \t\t\t\t  indx,\n \t\t\t\t  GEN_INT ((((rs6000_fpmem_offset & 0xffff)\n \t\t\t\t\t     ^ 0x8000) - 0x8000))));\n@@ -3912,8 +3912,8 @@\n   else\n     indx = stack_pointer_rtx;\n \n-  operands[2] = gen_rtx (MEM, DFmode,\n-\t\t\t gen_rtx (PLUS, Pmode,\n+  operands[2] = gen_rtx_MEM (DFmode,\n+\t\t\t gen_rtx_PLUS (Pmode,\n \t\t\t\t  indx,\n \t\t\t\t  GEN_INT ((((rs6000_fpmem_offset & 0xffff) ^ 0x8000) - 0x8000)\n \t\t\t\t\t   + ((WORDS_BIG_ENDIAN) ? 4 : 0))));\n@@ -3929,7 +3929,7 @@\n   \"\n {\n   emit_insn (gen_trunc_call (operands[0], operands[1],\n-\t\t\t     gen_rtx (SYMBOL_REF, Pmode, RS6000_UITRUNC)));\n+\t\t\t     gen_rtx_SYMBOL_REF (Pmode, RS6000_UITRUNC)));\n   DONE;\n }\")\n \n@@ -3944,9 +3944,9 @@\n   rtx first = XVECEXP (insns, 0, 0);\n   rtx last = XVECEXP (insns, 0, XVECLEN (insns, 0) - 1);\n \n-  REG_NOTES (first) = gen_rtx (INSN_LIST, REG_LIBCALL, last,\n+  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last,\n \t\t\t       REG_NOTES (first));\n-  REG_NOTES (last) = gen_rtx (INSN_LIST, REG_RETVAL, first, REG_NOTES (last));\n+  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n \n   emit_insn (insns);\n   DONE;\n@@ -4051,17 +4051,17 @@\n {\n   if (! TARGET_POWER && ! TARGET_POWERPC)\n     {\n-      emit_move_insn (gen_rtx (REG, SImode, 3), operands[1]);\n-      emit_move_insn (gen_rtx (REG, SImode, 4), operands[2]);\n+      emit_move_insn (gen_rtx_REG (SImode, 3), operands[1]);\n+      emit_move_insn (gen_rtx_REG (SImode, 4), operands[2]);\n       emit_insn (gen_mull_call ());\n       if (WORDS_BIG_ENDIAN)\n-        emit_move_insn (operands[0], gen_rtx (REG, DImode, 3));\n+        emit_move_insn (operands[0], gen_rtx_REG (DImode, 3));\n       else\n \t{\n \t  emit_move_insn (operand_subword (operands[0], 0, 0, DImode),\n-\t\t\t  gen_rtx (REG, SImode, 3));\n+\t\t\t  gen_rtx_REG (SImode, 3));\n \t  emit_move_insn (operand_subword (operands[0], 1, 0, DImode),\n-\t\t\t  gen_rtx (REG, SImode, 4));\n+\t\t\t  gen_rtx_REG (SImode, 4));\n \t}\n       DONE;\n     }\n@@ -4192,10 +4192,10 @@\n {\n   if (! TARGET_POWER && ! TARGET_POWERPC)\n     {\n-      emit_move_insn (gen_rtx (REG, SImode, 3), operands[1]);\n-      emit_move_insn (gen_rtx (REG, SImode, 4), operands[2]);\n+      emit_move_insn (gen_rtx_REG (SImode, 3), operands[1]);\n+      emit_move_insn (gen_rtx_REG (SImode, 4), operands[2]);\n       emit_insn (gen_mulh_call ());\n-      emit_move_insn (operands[0], gen_rtx (REG, SImode, 3));\n+      emit_move_insn (operands[0], gen_rtx_REG (SImode, 3));\n       DONE;\n     }\n   else if (TARGET_POWER)\n@@ -5400,7 +5400,7 @@\n       && (GET_CODE (operands[1]) == SYMBOL_REF || GET_CODE (operands[1]) == CONST)\n       && small_data_operand (operands[1], SImode))\n     {\n-      emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n       DONE;\n     }\n \n@@ -5430,7 +5430,7 @@\n \t  rtx new_ref;\n \t  while (*name == '.')\n \t    name++;\n-\t  new_ref = gen_rtx (SYMBOL_REF, Pmode, name);\n+\t  new_ref = gen_rtx_SYMBOL_REF (Pmode, name);\n \t  CONSTANT_POOL_ADDRESS_P (new_ref) = CONSTANT_POOL_ADDRESS_P (operands[1]);\n \t  SYMBOL_REF_FLAG (new_ref) = SYMBOL_REF_FLAG (operands[1]);\n \t  SYMBOL_REF_USED (new_ref) = SYMBOL_REF_USED (operands[1]);\n@@ -5479,7 +5479,7 @@\n \t This should not be done for operands that contain LABEL_REFs.\n \t For now, we just handle the obvious case.  */\n       if (GET_CODE (operands[1]) != LABEL_REF)\n-\temit_insn (gen_rtx (USE, VOIDmode, operands[1]));\n+\temit_insn (gen_rtx_USE (VOIDmode, operands[1]));\n \n       /* If we are to limit the number of things we put in the TOC and\n \t this is a symbol plus a constant we can add in one insn,\n@@ -6102,7 +6102,7 @@\n \t This should not be done for operands that contain LABEL_REFs.\n \t For now, we just handle the obvious case.  */\n       if (GET_CODE (operands[1]) != LABEL_REF)\n-\temit_insn (gen_rtx (USE, VOIDmode, operands[1]));\n+\temit_insn (gen_rtx_USE (VOIDmode, operands[1]));\n \n       /* If we are to limit the number of things we put in the TOC and\n \t this is a symbol plus a constant we can add in one insn,\n@@ -6188,8 +6188,8 @@\n    (set (match_dup 3) (match_dup 1))]\n   \"\n {\n-  operands[2] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n-  operands[3] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n+  operands[2] = gen_rtx_SUBREG (SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n+  operands[3] = gen_rtx_SUBREG (SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n   operands[4] = (INTVAL (operands[1]) & 0x80000000) ? constm1_rtx : const0_rtx;\n }\")\n \n@@ -6201,8 +6201,8 @@\n    (set (match_dup 3) (match_dup 5))]\n   \"\n {\n-  operands[2] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n-  operands[3] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n+  operands[2] = gen_rtx_SUBREG (SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n+  operands[3] = gen_rtx_SUBREG (SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n   operands[4] = GEN_INT (CONST_DOUBLE_HIGH (operands[1]));\n   operands[5] = GEN_INT (CONST_DOUBLE_LOW  (operands[1]));\n }\")\n@@ -6563,12 +6563,12 @@\n   count = INTVAL (operands[2]);\n   regno = REGNO (operands[0]);\n \n-  operands[3] = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (count));\n+  operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n   from = force_reg (SImode, XEXP (operands[1], 0));\n \n   for (i = 0; i < count; i++)\n     XVECEXP (operands[3], 0, i)\n-      = gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, regno + i),\n+      = gen_rtx_SET (VOIDmode, gen_rtx_REG (SImode, regno + i),\n \t\t change_address (operands[1], SImode,\n \t\t\t\t plus_constant (from, i * 4)));\n }\")\n@@ -6604,7 +6604,7 @@\n \telse if (i == 0)\n \t  {\n \t    xop[0] = operands[1];\n-\t    xop[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+\t    xop[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n \t    xop[2] = GEN_INT (4 * (words-1));\n \t    output_asm_insn (\\\"{cal %0,4(%0)|addi %0,%0,4}\\;{lsi|lswi} %1,%0,%2\\;{l|lwz} %0,-4(%0)\\\", xop);\n \t    return \\\"\\\";\n@@ -6614,7 +6614,7 @@\n \t    for (j = 0; j < words; j++)\n \t      if (j != i)\n \t\t{\n-\t\t  xop[0] = gen_rtx (REG, SImode, REGNO (operands[1]) + j);\n+\t\t  xop[0] = gen_rtx_REG (SImode, REGNO (operands[1]) + j);\n \t\t  xop[1] = operands[2];\n \t\t  xop[2] = GEN_INT (j * 4);\n \t\t  output_asm_insn (\\\"{l|lwz} %0,%2(%1)\\\", xop);\n@@ -6659,21 +6659,21 @@\n   count = INTVAL (operands[2]);\n   regno = REGNO (operands[1]);\n \n-  operands[3] = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (count + 1));\n+  operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count + 1));\n   to = force_reg (SImode, XEXP (operands[0], 0));\n \n   XVECEXP (operands[3], 0, 0)\n-    = gen_rtx (SET, VOIDmode, change_address (operands[0], SImode, to),\n+    = gen_rtx_SET (VOIDmode, change_address (operands[0], SImode, to),\n \t       operands[1]);\n-  XVECEXP (operands[3], 0, 1) = gen_rtx (CLOBBER, VOIDmode,\n-\t\t\t\t\t\t  gen_rtx (SCRATCH, SImode));\n+  XVECEXP (operands[3], 0, 1) = gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t\t  gen_rtx_SCRATCH (SImode));\n \n   for (i = 1; i < count; i++)\n     XVECEXP (operands[3], 0, i + 1)\n-      = gen_rtx (SET, VOIDmode,\n+      = gen_rtx_SET (VOIDmode,\n \t\t change_address (operands[0], SImode,\n \t\t\t\t plus_constant (to, i * 4)),\n-\t\t gen_rtx (REG, SImode, regno + i));\n+\t\t gen_rtx_REG (SImode, regno + i));\n }\")\n \n (define_insn \"\"\n@@ -7233,7 +7233,7 @@\n   \"\"\n   \"\n { rtx chain = gen_reg_rtx (Pmode);\n-  rtx stack_bot = gen_rtx (MEM, Pmode, stack_pointer_rtx);\n+  rtx stack_bot = gen_rtx_MEM (Pmode, stack_pointer_rtx);\n   rtx neg_op0;\n \n   emit_move_insn (chain, stack_bot);\n@@ -7245,7 +7245,7 @@\n       && (GET_CODE (operands[1]) != CONST_INT || INTVAL (operands[1]) > 4096))\n     {\n       rtx tmp = gen_reg_rtx (Pmode);\n-      emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"__allocate_stack\\\"),\n+      emit_library_call_value (gen_rtx_SYMBOL_REF (Pmode, \\\"__allocate_stack\\\"),\n \t\t\t       tmp, 0, Pmode, 1, operands[1], Pmode);\n       emit_insn (gen_set_sp (tmp));\n       emit_move_insn (operands[0], tmp);\n@@ -7273,7 +7273,7 @@\n     {\n       emit_insn ((* ((TARGET_32BIT) ? gen_addsi3 : gen_adddi3))\n \t\t (stack_pointer_rtx, stack_pointer_rtx, neg_op0));\n-      emit_move_insn (gen_rtx (MEM, Pmode, stack_pointer_rtx), chain);\n+      emit_move_insn (gen_rtx_MEM (Pmode, stack_pointer_rtx), chain);\n     }\n \n   emit_move_insn (operands[0], virtual_stack_dynamic_rtx);\n@@ -7318,7 +7318,7 @@\n   \"\n {\n   operands[2] = gen_reg_rtx (Pmode);\n-  operands[3] = gen_rtx (MEM, Pmode, operands[0]);\n+  operands[3] = gen_rtx_MEM (Pmode, operands[0]);\n }\")\n \n (define_expand \"save_stack_nonlocal\"\n@@ -7330,7 +7330,7 @@\n   rtx temp = gen_reg_rtx (Pmode);\n \n   /* Copy the backchain to the first word, sp to the second.  */\n-  emit_move_insn (temp, gen_rtx (MEM, Pmode, operands[1]));\n+  emit_move_insn (temp, gen_rtx_MEM (Pmode, operands[1]));\n   emit_move_insn (operand_subword (operands[0], 0, 0, (TARGET_32BIT ? DImode : TImode)),\n \t\t  temp);\n   emit_move_insn (operand_subword (operands[0], 1, 0, (TARGET_32BIT ? DImode : TImode)),\n@@ -7351,7 +7351,7 @@\n \t\t  operand_subword (operands[1], 0, 0, (TARGET_32BIT ? DImode : TImode)));\n   emit_move_insn (operands[0],\n \t\t  operand_subword (operands[1], 1, 0, (TARGET_32BIT ? DImode : TImode)));\n-  emit_move_insn (gen_rtx (MEM, Pmode, operands[0]), temp);\n+  emit_move_insn (gen_rtx_MEM (Pmode, operands[0]), temp);\n   DONE;\n }\")\n \n@@ -7409,7 +7409,7 @@\n    (clobber (match_scratch:SI 7 \"=l\"))]\n   \"TARGET_64BIT && DEFAULT_ABI == ABI_AIX\n    && (INTVAL (operands[2]) == CALL_NORMAL || (INTVAL (operands[2]) & CALL_LONG) != 0)\"\n-  \"stw %4,%a3\\;ld %6,0(%0)\\;ld %4,8(%0)\\;mt%7 %6\\;ld %5,16(%0)\\;blrl\\;ld %4,%a3\"\n+  \"std %4,%a3\\;ld %6,0(%0)\\;ld %4,8(%0)\\;mt%7 %6\\;ld %5,16(%0)\\;blrl\\;ld %4,%a3\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"28\")])\n \n@@ -7441,7 +7441,7 @@\n    (clobber (match_scratch:SI 8 \"=l\"))]\n   \"TARGET_64BIT && DEFAULT_ABI == ABI_AIX\n    && (INTVAL (operands[3]) == CALL_NORMAL || (INTVAL (operands[3]) & CALL_LONG) != 0)\"\n-  \"stw %5,%a4\\;ld %7,0(%1)\\;ld %5,8(%1)\\;mt%8 %7\\;ld %6,16(%1)\\;blrl\\;ld %5,%a4\"\n+  \"std %5,%a4\\;ld %7,0(%1)\\;ld %5,8(%1)\\;mt%8 %7\\;ld %6,16(%1)\\;blrl\\;ld %5,%a4\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"28\")])\n \n@@ -7565,13 +7565,13 @@\n \t\t\t\t\t\toperands[1], operands[2]));\n       else\n \t{\n-\t  rtx toc_reg = gen_rtx (REG, Pmode, 2);\n+\t  rtx toc_reg = gen_rtx_REG (Pmode, 2);\n \t  rtx toc_addr = RS6000_SAVE_TOC;\n \n \t  if (DEFAULT_ABI == ABI_AIX)\n \t    {\n \t      /* AIX function pointers are really pointers to a three word area */\n-\t      rtx static_chain = gen_rtx (REG, Pmode, STATIC_CHAIN_REGNUM);\n+\t      rtx static_chain = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n \t      emit_call_insn (TARGET_32BIT\n \t\t\t      ? gen_call_indirect_aix32 (force_reg (Pmode, operands[0]),\n \t\t\t\t\t\t         operands[1], operands[2],\n@@ -7627,13 +7627,13 @@\n \t\t\t\t\t\t      operands[2], operands[3]));\n       else\n \t{\n-\t  rtx toc_reg = gen_rtx (REG, Pmode, 2);\n+\t  rtx toc_reg = gen_rtx_REG (Pmode, 2);\n \t  rtx toc_addr = RS6000_SAVE_TOC;\n \n \t  if (DEFAULT_ABI == ABI_AIX)\n \t    {\n \t      /* AIX function pointers are really pointers to a three word area */\n-\t      rtx static_chain = gen_rtx (REG, Pmode, STATIC_CHAIN_REGNUM);\n+\t      rtx static_chain = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n \t      emit_call_insn (TARGET_32BIT\n \t\t\t      ? gen_call_value_indirect_aix32 (operands[0],\n \t\t\t\t\t\t\t       force_reg (Pmode, operands[1]),\n@@ -8023,7 +8023,7 @@\n   \"\"\n   \"\n { enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n-  operands[1] = gen_rtx (COMPARE, mode,\n+  operands[1] = gen_rtx_COMPARE (mode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n@@ -8038,7 +8038,7 @@\n   \"\"\n   \"\n { enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n-  operands[1] = gen_rtx (COMPARE, mode,\n+  operands[1] = gen_rtx_COMPARE (mode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n@@ -8053,7 +8053,7 @@\n   \"\"\n   \"\n { enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n-  operands[1] = gen_rtx (COMPARE, mode,\n+  operands[1] = gen_rtx_COMPARE (mode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n@@ -8068,7 +8068,7 @@\n   \"\"\n   \"\n { enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n-  operands[1] = gen_rtx (COMPARE, mode,\n+  operands[1] = gen_rtx_COMPARE (mode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n@@ -8083,7 +8083,7 @@\n   \"\"\n   \"\n { enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n-  operands[1] = gen_rtx (COMPARE, mode,\n+  operands[1] = gen_rtx_COMPARE (mode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n@@ -8098,7 +8098,7 @@\n   \"\"\n   \"\n { enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n-  operands[1] = gen_rtx (COMPARE, mode,\n+  operands[1] = gen_rtx_COMPARE (mode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n@@ -8112,7 +8112,7 @@\n \t\t      (pc)))]\n   \"\"\n   \"\n-{ operands[1] = gen_rtx (COMPARE, CCUNSmode,\n+{ operands[1] = gen_rtx_COMPARE (CCUNSmode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (CCUNSmode);\n }\")\n@@ -8126,7 +8126,7 @@\n \t\t      (pc)))]\n   \"\"\n   \"\n-{ operands[1] = gen_rtx (COMPARE, CCUNSmode,\n+{ operands[1] = gen_rtx_COMPARE (CCUNSmode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (CCUNSmode);\n }\")\n@@ -8140,7 +8140,7 @@\n \t\t      (pc)))]\n   \"\"\n   \"\n-{ operands[1] = gen_rtx (COMPARE, CCUNSmode,\n+{ operands[1] = gen_rtx_COMPARE (CCUNSmode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (CCUNSmode);\n }\")\n@@ -8154,7 +8154,7 @@\n \t\t      (pc)))]\n   \"\"\n   \"\n-{ operands[1] = gen_rtx (COMPARE, CCUNSmode,\n+{ operands[1] = gen_rtx_COMPARE (CCUNSmode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (CCUNSmode);\n }\")\n@@ -8171,7 +8171,7 @@\n   \"\"\n   \"\n { enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n-  operands[1] = gen_rtx (COMPARE, mode,\n+  operands[1] = gen_rtx_COMPARE (mode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n@@ -8185,7 +8185,7 @@\n { if (! rs6000_compare_fp_p)\n     FAIL;\n \n-  operands[1] = gen_rtx (COMPARE, CCFPmode,\n+  operands[1] = gen_rtx_COMPARE (CCFPmode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (CCFPmode);\n }\")\n@@ -8202,7 +8202,7 @@\n   if (! rs6000_compare_fp_p && rs6000_compare_op1 == const0_rtx)\n     FAIL;\n \n-  operands[1] = gen_rtx (COMPARE, mode,\n+  operands[1] = gen_rtx_COMPARE (mode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n@@ -8219,7 +8219,7 @@\n   if (! rs6000_compare_fp_p && rs6000_compare_op1 == const0_rtx)\n     FAIL;\n \n-  operands[1] = gen_rtx (COMPARE, mode,\n+  operands[1] = gen_rtx_COMPARE (mode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n@@ -8231,7 +8231,7 @@\n   \"\"\n   \"\n { enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n-  operands[1] = gen_rtx (COMPARE, mode,\n+  operands[1] = gen_rtx_COMPARE (mode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n@@ -8248,7 +8248,7 @@\n   if (! rs6000_compare_fp_p && rs6000_compare_op1 == const0_rtx)\n     FAIL;\n \n-  operands[1] = gen_rtx (COMPARE, mode,\n+  operands[1] = gen_rtx_COMPARE (mode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n@@ -8259,7 +8259,7 @@\n \t(gtu:SI (match_dup 2) (const_int 0)))]\n   \"\"\n   \"\n-{ operands[1] = gen_rtx (COMPARE, CCUNSmode,\n+{ operands[1] = gen_rtx_COMPARE (CCUNSmode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (CCUNSmode);\n }\")\n@@ -8270,7 +8270,7 @@\n \t(ltu:SI (match_dup 2) (const_int 0)))]\n   \"\"\n   \"\n-{ operands[1] = gen_rtx (COMPARE, CCUNSmode,\n+{ operands[1] = gen_rtx_COMPARE (CCUNSmode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (CCUNSmode);\n }\")\n@@ -8281,7 +8281,7 @@\n \t(geu:SI (match_dup 2) (const_int 0)))]\n   \"\"\n   \"\n-{ operands[1] = gen_rtx (COMPARE, CCUNSmode,\n+{ operands[1] = gen_rtx_COMPARE (CCUNSmode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (CCUNSmode);\n }\")\n@@ -8292,7 +8292,7 @@\n \t(leu:SI (match_dup 2) (const_int 0)))]\n   \"\"\n   \"\n-{ operands[1] = gen_rtx (COMPARE, CCUNSmode,\n+{ operands[1] = gen_rtx_COMPARE (CCUNSmode,\n \t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (CCUNSmode);\n }\")\n@@ -9728,7 +9728,7 @@\n   \"\"\n   \"\n { operands[0] = force_reg (SImode, operands[0]);\n-  operands[2] = force_reg (SImode, gen_rtx (LABEL_REF, VOIDmode, operands[1]));\n+  operands[2] = force_reg (SImode, gen_rtx_LABEL_REF (VOIDmode, operands[1]));\n   operands[3] = gen_reg_rtx (SImode);\n }\")\n \n@@ -9741,7 +9741,7 @@\n   \"\"\n   \"\n { operands[0] = force_reg (DImode, operands[0]);\n-  operands[2] = force_reg (DImode, gen_rtx (LABEL_REF, VOIDmode, operands[1]));\n+  operands[2] = force_reg (DImode, gen_rtx_LABEL_REF (VOIDmode, operands[1]));\n   operands[3] = gen_reg_rtx (DImode);\n }\")\n "}, {"sha": "58d4ebd975739f1db844d4b05ebd63afc1bdb784", "filename": "gcc/explow.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39403d8233deb862fc951f95cd11280440c90880/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39403d8233deb862fc951f95cd11280440c90880/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=39403d8233deb862fc951f95cd11280440c90880", "patch": "@@ -1238,15 +1238,17 @@ allocate_dynamic_stack_space (size, target, known_align)\n #ifdef HAVE_allocate_stack\n   if (HAVE_allocate_stack)\n     {\n+      enum machine_mode mode = STACK_SIZE_MODE;\n+\n       if (insn_operand_predicate[(int) CODE_FOR_allocate_stack][0]\n \t  && ! ((*insn_operand_predicate[(int) CODE_FOR_allocate_stack][0])\n \t\t(target, Pmode)))\n \ttarget = copy_to_mode_reg (Pmode, target);\n-      size = convert_modes (Pmode, ptr_mode, size, 1);\n+      size = convert_modes (mode, ptr_mode, size, 1);\n       if (insn_operand_predicate[(int) CODE_FOR_allocate_stack][1]\n \t  && ! ((*insn_operand_predicate[(int) CODE_FOR_allocate_stack][1])\n-\t\t(size, Pmode)))\n-\tsize = copy_to_mode_reg (Pmode, size);\n+\t\t(size, mode)))\n+\tsize = copy_to_mode_reg (mode, size);\n \n       emit_insn (gen_allocate_stack (target, size));\n     }"}, {"sha": "02d75bbf98e36ca923029e2c687217690a230831", "filename": "gcc/expr.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39403d8233deb862fc951f95cd11280440c90880/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39403d8233deb862fc951f95cd11280440c90880/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=39403d8233deb862fc951f95cd11280440c90880", "patch": "@@ -252,6 +252,13 @@ enum direction {none, upward, downward};  /* Value has this type.  */\n #define STACK_SAVEAREA_MODE(LEVEL) Pmode\n #endif\n \n+/* Supply a default definition of STACK_SIZE_MODE for\n+   allocate_dynamic_stack_space.  Normally PLUS/MINUS, so word_mode.  */\n+\n+#ifndef STACK_SIZE_MODE\n+#define STACK_SIZE_MODE word_mode\n+#endif\n+\n /* Provide default values for the macros controlling stack checking.  */\n \n #ifndef STACK_CHECK_BUILTIN"}, {"sha": "cfff3a0e63c31dcd3b0fd6690ce42e7355fdbfe6", "filename": "gcc/tm.texi", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39403d8233deb862fc951f95cd11280440c90880/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39403d8233deb862fc951f95cd11280440c90880/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=39403d8233deb862fc951f95cd11280440c90880", "patch": "@@ -982,16 +982,27 @@ appropriate sizes.  If this macro is undefined, @code{GET_MODE_BITSIZE\n @findex STACK_SAVEAREA_MODE\n @item STACK_SAVEAREA_MODE (@var{save_level})\n If defined, an expression of type @code{enum machine_mode} that\n-specifies the mode of a @code{save_stack_@var{level}} named pattern\n-(@pxref{Standard Names}).  @var{save_level} is one of @code{SAVE_BLOCK},\n-@code{SAVE_FUNCTION}, or @code{SAVE_NONLOCAL} and selects which of the\n-three named patterns is having its mode specified.\n+specifies the mode of the save area operand of a\n+@code{save_stack_@var{level}} named pattern (@pxref{Standard Names}).\n+@var{save_level} is one of @code{SAVE_BLOCK}, @code{SAVE_FUNCTION}, or\n+@code{SAVE_NONLOCAL} and selects which of the three named patterns is\n+having its mode specified.\n \n You need not define this macro if it always returns @code{Pmode}.  You\n would most commonly define this macro if the\n @code{save_stack_@var{level}} patterns need to support both a 32- and a\n 64-bit mode.\n \n+@findex STACK_SIZE_MODE\n+@item STACK_SIZE_MODE\n+If defined, an expression of type @code{enum machine_mode} that\n+specifies the mode of the size increment operand of an\n+@code{allocate_stack} named pattern (@pxref{Standard Names}).\n+\n+You need not define this macro if it always returns @code{word_mode}.\n+You would most commonly define this macro if the @code{allocate_stack}\n+pattern needs to support both a 32- and a 64-bit mode.\n+\n @findex CHECK_FLOAT_VALUE\n @item CHECK_FLOAT_VALUE (@var{mode}, @var{value}, @var{overflow})\n A C statement to validate the value @var{value} (of type"}]}