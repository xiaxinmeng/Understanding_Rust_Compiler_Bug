{"sha": "6bab4c63c4277ce8831c9d1cb6161f12f557f7f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJhYjRjNjNjNDI3N2NlODgzMWM5ZDFjYjYxNjFmMTJmNTU3ZjdmNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-02-17T00:50:23Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-02-17T00:50:23Z"}, "message": "re PR c++/10200 (Weird clash with same names in different scopes)\n\n\tPR c++/10200\n\tPR c++/69753\n\t* call.c, cp-tree.h, name-lookup.c, pt.c, search.c, semantics.c,\n\ttree.c, typeck2.c: Revert earlier changes.\n\t* parser.c (cp_parser_lookup_name): Ignore namespace-scope\n\tnon-type templates after -> or .\n\nFrom-SVN: r233481", "tree": {"sha": "a39646613764cf1028a7acfc0fc45dc4892df306", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a39646613764cf1028a7acfc0fc45dc4892df306"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a529923e35bcbb88d2eef4a77531092717356a23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a529923e35bcbb88d2eef4a77531092717356a23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a529923e35bcbb88d2eef4a77531092717356a23"}], "stats": {"total": 167, "additions": 107, "deletions": 60}, "files": [{"sha": "b76f85d8f365b5d1e361efdae7ea496737193334", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6bab4c63c4277ce8831c9d1cb6161f12f557f7f6", "patch": "@@ -1,3 +1,12 @@\n+2016-02-16  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/10200\n+\tPR c++/69753\n+\t* call.c, cp-tree.h, name-lookup.c, pt.c, search.c, semantics.c,\n+\ttree.c, typeck2.c: Revert earlier changes.\n+\t* parser.c (cp_parser_lookup_name): Ignore namespace-scope\n+\tnon-type templates after -> or .\n+\n 2016-02-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/69835"}, {"sha": "cb71176c6ca148ecaf49b24f2e16238d3653685a", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=6bab4c63c4277ce8831c9d1cb6161f12f557f7f6", "patch": "@@ -8160,7 +8160,7 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n \n       if (permerror (input_location,\n \t\t     \"cannot call constructor %<%T::%D%> directly\",\n-\t\t     BINFO_TYPE (access_binfo), name))\n+\t\t     basetype, name))\n \tinform (input_location, \"for a function-style cast, remove the \"\n \t\t\"redundant %<::%D%>\", name);\n       call = build_functional_cast (basetype, build_tree_list_vec (user_args),\n@@ -8377,9 +8377,6 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n \t\t     we know we really need it.  */\n \t\t  cand->first_arg = instance;\n \t\t}\n-\t      else if (any_dependent_bases_p ())\n-\t\t/* We can't tell until instantiation time whether we can use\n-\t\t   *this as the implicit object argument.  */;\n \t      else\n \t\t{\n \t\t  if (complain & tf_error)"}, {"sha": "3b91089f50d08645519305b797c6616b767bec79", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6bab4c63c4277ce8831c9d1cb6161f12f557f7f6", "patch": "@@ -6252,7 +6252,6 @@ extern tree adjust_result_of_qualified_name_lookup\n extern tree copied_binfo\t\t\t(tree, tree);\n extern tree original_binfo\t\t\t(tree, tree);\n extern int shared_member_p\t\t\t(tree);\n-extern bool any_dependent_bases_p (tree = current_nonlambda_class_type ());\n \n /* The representation of a deferred access check.  */\n \n@@ -6543,6 +6542,7 @@ extern tree get_first_fn\t\t\t(tree);\n extern tree ovl_cons\t\t\t\t(tree, tree);\n extern tree build_overload\t\t\t(tree, tree);\n extern tree ovl_scope\t\t\t\t(tree);\n+extern bool non_static_member_function_p        (tree);\n extern const char *cxx_printable_name\t\t(tree, int);\n extern const char *cxx_printable_name_translate\t(tree, int);\n extern tree build_exception_variant\t\t(tree, tree);"}, {"sha": "89d84d7b1c3982c67210c221c845c134017fb12a", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=6bab4c63c4277ce8831c9d1cb6161f12f557f7f6", "patch": "@@ -3333,6 +3333,8 @@ do_class_using_decl (tree scope, tree name)\n   /* True if any of the bases of CURRENT_CLASS_TYPE are dependent.  */\n   bool bases_dependent_p;\n   tree binfo;\n+  tree base_binfo;\n+  int i;\n \n   if (name == error_mark_node)\n     return NULL_TREE;\n@@ -3369,7 +3371,16 @@ do_class_using_decl (tree scope, tree name)\n \t\t      || (IDENTIFIER_TYPENAME_P (name)\n \t\t\t  && dependent_type_p (TREE_TYPE (name))));\n \n-  bases_dependent_p = any_dependent_bases_p (current_class_type);\n+  bases_dependent_p = false;\n+  if (processing_template_decl)\n+    for (binfo = TYPE_BINFO (current_class_type), i = 0;\n+\t BINFO_BASE_ITERATE (binfo, i, base_binfo);\n+\t i++)\n+      if (dependent_type_p (TREE_TYPE (base_binfo)))\n+\t{\n+\t  bases_dependent_p = true;\n+\t  break;\n+\t}\n \n   decl = NULL_TREE;\n "}, {"sha": "18f390206d0f3fcb1479cda8f47383bb7474bfcf", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=6bab4c63c4277ce8831c9d1cb6161f12f557f7f6", "patch": "@@ -7184,16 +7184,8 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n   if (token_type == CPP_DEREF)\n     postfix_expression = build_x_arrow (location, postfix_expression,\n \t\t\t\t\ttf_warning_or_error);\n-  /* According to the standard, no expression should ever have\n-     reference type.  Unfortunately, we do not currently match\n-     the standard in this respect in that our internal representation\n-     of an expression may have reference type even when the standard\n-     says it does not.  Therefore, we have to manually obtain the\n-     underlying type here.  */\n-  scope = non_reference (TREE_TYPE (postfix_expression));\n-  /* Check to see whether or not the expression is type-dependent and\n-     not the current instantiation.  */\n-  dependent_p = !scope || dependent_scope_p (scope);\n+  /* Check to see whether or not the expression is type-dependent.  */\n+  dependent_p = type_dependent_expression_p (postfix_expression);\n   /* The identifier following the `->' or `.' is not qualified.  */\n   parser->scope = NULL_TREE;\n   parser->qualifying_scope = NULL_TREE;\n@@ -7202,8 +7194,16 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \n   /* Enter the scope corresponding to the type of the object\n      given by the POSTFIX_EXPRESSION.  */\n-  if (!dependent_p)\n-    {\n+  if (!dependent_p && TREE_TYPE (postfix_expression) != NULL_TREE)\n+    {\n+      scope = TREE_TYPE (postfix_expression);\n+      /* According to the standard, no expression should ever have\n+\t reference type.  Unfortunately, we do not currently match\n+\t the standard in this respect in that our internal representation\n+\t of an expression may have reference type even when the standard\n+\t says it does not.  Therefore, we have to manually obtain the\n+\t underlying type here.  */\n+      scope = non_reference (scope);\n       /* The type of the POSTFIX_EXPRESSION must be complete.  */\n       if (scope == unknown_type_node)\n \t{\n@@ -7215,10 +7215,7 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t required to be of complete type for purposes of class member\n \t access (5.2.5) outside the member function body.  */\n       else if (postfix_expression != current_class_ref\n-\t       && !(processing_template_decl\n-\t\t    && current_class_type\n-\t\t    && (same_type_ignoring_top_level_qualifiers_p\n-\t\t\t(scope, current_class_type))))\n+\t       && !(processing_template_decl && scope == current_class_type))\n \tscope = complete_type_or_else (scope, NULL_TREE);\n       /* Let the name lookup machinery know that we are processing a\n \t class member access expression.  */\n@@ -24727,11 +24724,24 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \tdecl = NULL_TREE;\n \n       if (!decl)\n-\t/* Look it up in the enclosing context.  DR 141: When looking for a\n-\t   template-name after -> or ., only consider class templates.  */\n-\tdecl = lookup_name_real (name, tag_type != none_type || is_template,\n-\t\t\t\t /*nonclass=*/0,\n-\t\t\t\t /*block_p=*/true, is_namespace, 0);\n+\t{\n+\t  /* Look it up in the enclosing context.  */\n+\t  decl = lookup_name_real (name, tag_type != none_type,\n+\t\t\t\t   /*nonclass=*/0,\n+\t\t\t\t   /*block_p=*/true, is_namespace, 0);\n+\t  /* DR 141 says when looking for a template-name after -> or ., only\n+\t     consider class templates.  We need to fix our handling of\n+\t     dependent expressions to implement that properly, but for now\n+\t     let's ignore namespace-scope function templates.  */\n+\t  if (decl && is_template && !DECL_TYPE_TEMPLATE_P (decl))\n+\t    {\n+\t      tree d = decl;\n+\t      if (is_overloaded_fn (d))\n+\t\td = get_first_fn (d);\n+\t      if (DECL_P (d) && !DECL_CLASS_SCOPE_P (d))\n+\t\tdecl = NULL_TREE;\n+\t    }\n+\t}\n       if (object_type == unknown_type_node)\n \t/* The object is type-dependent, so we can't look anything up; we used\n \t   this to get the DR 141 behavior.  */"}, {"sha": "a55dc10fdfc1e8d1a847c4d4e89efcc6f574cccf", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6bab4c63c4277ce8831c9d1cb6161f12f557f7f6", "patch": "@@ -22904,16 +22904,9 @@ type_dependent_expression_p (tree expression)\n       && DECL_TEMPLATE_INFO (expression))\n     return any_dependent_template_arguments_p (DECL_TI_ARGS (expression));\n \n-  if (TREE_CODE (expression) == TEMPLATE_DECL)\n-    {\n-      if (DECL_CLASS_SCOPE_P (expression)\n-\t  && dependent_type_p (DECL_CONTEXT (expression)))\n-\t/* A template's own parameters don't make it dependent, since those can\n-\t   be deduced, but the enclosing class does.  */\n-\treturn true;\n-      if (!DECL_TEMPLATE_TEMPLATE_PARM_P (expression))\n-\treturn false;\n-    }\n+  if (TREE_CODE (expression) == TEMPLATE_DECL\n+      && !DECL_TEMPLATE_TEMPLATE_PARM_P (expression))\n+    return false;\n \n   if (TREE_CODE (expression) == STMT_EXPR)\n     expression = stmt_expr_value_expr (expression);"}, {"sha": "792461189152ad68c40023ae4756d5c3403c7e3a", "filename": "gcc/cp/search.c", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=6bab4c63c4277ce8831c9d1cb6161f12f557f7f6", "patch": "@@ -2842,21 +2842,3 @@ original_binfo (tree binfo, tree here)\n   return result;\n }\n \n-/* True iff TYPE has any dependent bases (and therefore we can't say\n-   definitively that another class is not a base of an instantiation of\n-   TYPE).  */\n-\n-bool\n-any_dependent_bases_p (tree type)\n-{\n-  if (!type || !CLASS_TYPE_P (type) || !processing_template_decl)\n-    return false;\n-\n-  unsigned i;\n-  tree base_binfo;\n-  FOR_EACH_VEC_SAFE_ELT (BINFO_BASE_BINFOS (TYPE_BINFO (type)), i, base_binfo)\n-    if (BINFO_DEPENDENT_BASE_P (base_binfo))\n-      return true;\n-\n-  return false;\n-}"}, {"sha": "f0288eae09d1c1aeeb77e9588cb4b4c3930b063e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=6bab4c63c4277ce8831c9d1cb6161f12f557f7f6", "patch": "@@ -2264,7 +2264,17 @@ finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,\n \t with no type; type_dependent_expression_p recognizes\n \t expressions with no type as being dependent.  */\n       if (type_dependent_expression_p (fn)\n-\t  || any_type_dependent_arguments_p (*args))\n+\t  || any_type_dependent_arguments_p (*args)\n+\t  /* For a non-static member function that doesn't have an\n+\t     explicit object argument, we need to specifically\n+\t     test the type dependency of the \"this\" pointer because it\n+\t     is not included in *ARGS even though it is considered to\n+\t     be part of the list of arguments.  Note that this is\n+\t     related to CWG issues 515 and 1005.  */\n+\t  || (TREE_CODE (fn) != COMPONENT_REF\n+\t      && non_static_member_function_p (fn)\n+\t      && current_class_ref\n+\t      && type_dependent_expression_p (current_class_ref)))\n \t{\n \t  result = build_nt_call_vec (fn, *args);\n \t  SET_EXPR_LOCATION (result, EXPR_LOC_OR_LOC (fn, input_location));\n@@ -2344,6 +2354,17 @@ finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,\n       object = maybe_dummy_object (BINFO_TYPE (BASELINK_ACCESS_BINFO (fn)),\n \t\t\t\t   NULL);\n \n+      if (processing_template_decl)\n+\t{\n+\t  if (type_dependent_expression_p (object))\n+\t    {\n+\t      tree ret = build_nt_call_vec (orig_fn, orig_args);\n+\t      release_tree_vector (orig_args);\n+\t      return ret;\n+\t    }\n+\t  object = build_non_dependent_expr (object);\n+\t}\n+\n       result = build_new_method_call (object, fn, args, NULL_TREE,\n \t\t\t\t      (disallow_virtual\n \t\t\t\t       ? LOOKUP_NORMAL|LOOKUP_NONVIRTUAL"}, {"sha": "3203acaff9e94f6d6c23a4f8390b82764ef5158e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=6bab4c63c4277ce8831c9d1cb6161f12f557f7f6", "patch": "@@ -2071,6 +2071,23 @@ ovl_scope (tree ovl)\n     ovl = OVL_CHAIN (ovl);\n   return CP_DECL_CONTEXT (OVL_CURRENT (ovl));\n }\n+\n+/* Return TRUE if FN is a non-static member function, FALSE otherwise.\n+   This function looks into BASELINK and OVERLOAD nodes.  */\n+\n+bool\n+non_static_member_function_p (tree fn)\n+{\n+  if (fn == NULL_TREE)\n+    return false;\n+\n+  if (is_overloaded_fn (fn))\n+    fn = get_first_fn (fn);\n+\n+  return (DECL_P (fn)\n+\t  && DECL_NONSTATIC_MEMBER_FUNCTION_P (fn));\n+}\n+\n \f\n #define PRINT_RING_SIZE 4\n "}, {"sha": "2a76c96c7d48d27e8082fc14924ccc02e132ed0c", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=6bab4c63c4277ce8831c9d1cb6161f12f557f7f6", "patch": "@@ -1694,10 +1694,7 @@ build_x_arrow (location_t loc, tree expr, tsubst_flags_t complain)\n \n   if (processing_template_decl)\n     {\n-      if (type && TREE_CODE (type) == POINTER_TYPE\n-\t  && !dependent_scope_p (TREE_TYPE (type)))\n-\t/* Pointer to current instantiation, don't treat as dependent.  */;\n-      else if (type_dependent_expression_p (expr))\n+      if (type_dependent_expression_p (expr))\n \treturn build_min_nt_loc (loc, ARROW_EXPR, expr);\n       expr = build_non_dependent_expr (expr);\n     }"}, {"sha": "7da060d4bb612cbfc0e943166c671bc95a7d75c5", "filename": "gcc/testsuite/g++.dg/template/dependent-expr9.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-expr9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bab4c63c4277ce8831c9d1cb6161f12f557f7f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-expr9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-expr9.C?ref=6bab4c63c4277ce8831c9d1cb6161f12f557f7f6", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/69753\n+\n+class A {\n+public:\n+  template <class> void m_fn1();\n+};\n+A *fn1(int *);\n+template <typename> class B : A {\n+  static int *m_fn2() { fn1(m_fn2())->m_fn1<A>(); }\n+};"}]}