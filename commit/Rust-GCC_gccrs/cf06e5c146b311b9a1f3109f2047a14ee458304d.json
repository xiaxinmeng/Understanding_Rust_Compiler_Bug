{"sha": "cf06e5c146b311b9a1f3109f2047a14ee458304d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YwNmU1YzE0NmIzMTFiOWExZjMxMDlmMjA0N2ExNGVlNDU4MzA0ZA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2007-01-02T04:32:07Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2007-01-02T04:32:07Z"}, "message": "fold-const.c (fold_binary): Fold \"(X^C1) eq/ne C2\" into \"X eq/ne (C1^C2)\".\n\n\n\t* fold-const.c (fold_binary) <EQ_EXPR>: Fold \"(X^C1) eq/ne C2\" into\n\t\"X eq/ne (C1^C2)\".  Fold \"(X^Z) eq/ne (Y^Z)\" as \"X eq/ne Y\" when Z\n\thas no side-effects.  Fold \"(X^C1) eq/ne (Y^C2)\" as \"(X^(C1^C2))\n\teq/ne Y\".\n\n\t* gcc.dg/fold-eqxor-4.c: New test case.\n\nFrom-SVN: r120333", "tree": {"sha": "a0d5ee6f7357a7c40aaea45db067994d2da661a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0d5ee6f7357a7c40aaea45db067994d2da661a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf06e5c146b311b9a1f3109f2047a14ee458304d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf06e5c146b311b9a1f3109f2047a14ee458304d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf06e5c146b311b9a1f3109f2047a14ee458304d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf06e5c146b311b9a1f3109f2047a14ee458304d/comments", "author": null, "committer": null, "parents": [{"sha": "e68ea32e9435ad3816d5acca3b45f9d3d7a9ae91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e68ea32e9435ad3816d5acca3b45f9d3d7a9ae91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e68ea32e9435ad3816d5acca3b45f9d3d7a9ae91"}], "stats": {"total": 72, "additions": 72, "deletions": 0}, "files": [{"sha": "dca58feec616a051b913a33d6b2766fe4a11b775", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf06e5c146b311b9a1f3109f2047a14ee458304d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf06e5c146b311b9a1f3109f2047a14ee458304d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf06e5c146b311b9a1f3109f2047a14ee458304d", "patch": "@@ -1,3 +1,10 @@\n+2007-01-01  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (fold_binary) <EQ_EXPR>: Fold \"(X^C1) eq/ne C2\" into\n+\t\"X eq/ne (C1^C2)\".  Fold \"(X^Z) eq/ne (Y^Z)\" as \"X eq/ne Y\" when Z\n+\thas no side-effects.  Fold \"(X^C1) eq/ne (Y^C2)\" as \"(X^(C1^C2))\n+\teq/ne Y\".\n+\n 2007-01-01  Mike Stump  <mrs@apple.com>\n \n \t* configure.ac: Remove support for building with Apple's gcc-3.1."}, {"sha": "8826908054d447455a884e3d28e261b76cf44dce", "filename": "gcc/fold-const.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf06e5c146b311b9a1f3109f2047a14ee458304d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf06e5c146b311b9a1f3109f2047a14ee458304d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=cf06e5c146b311b9a1f3109f2047a14ee458304d", "patch": "@@ -10753,6 +10753,15 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  && ! TREE_CONSTANT_OVERFLOW (tem))\n \treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0), tem);\n \n+      /* Similarly for a BIT_XOR_EXPR;  X ^ C1 == C2 is X == (C1 ^ C2).  */\n+      if (TREE_CODE (arg0) == BIT_XOR_EXPR\n+\t  && TREE_CODE (arg1) == INTEGER_CST\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n+\treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0),\n+\t\t\t    fold_build2 (BIT_XOR_EXPR, TREE_TYPE (arg0),\n+\t\t\t\t\t fold_convert (TREE_TYPE (arg0), arg1),\n+\t\t\t\t\t TREE_OPERAND (arg0, 1)));\n+\n       /* If we have X - Y == 0, we can convert that to X == Y and similarly\n \t for !=.  Don't do this for ordered comparisons due to overflow.  */\n       if (TREE_CODE (arg0) == MINUS_EXPR\n@@ -11106,6 +11115,36 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t\tbuild_int_cst (itype, 0));\n \t}\n \n+      if (TREE_CODE (arg0) == BIT_XOR_EXPR\n+\t  && TREE_CODE (arg1) == BIT_XOR_EXPR)\n+\t{\n+\t  tree arg00 = TREE_OPERAND (arg0, 0);\n+\t  tree arg01 = TREE_OPERAND (arg0, 1);\n+\t  tree arg10 = TREE_OPERAND (arg1, 0);\n+\t  tree arg11 = TREE_OPERAND (arg1, 1);\n+\t  tree itype = TREE_TYPE (arg0);\n+\n+\t  /* Optimize (X ^ Z) op (Y ^ Z) as X op Y, and symmetries.\n+\t     operand_equal_p guarantees no side-effects so we don't need\n+\t     to use omit_one_operand on Z.  */\n+\t  if (operand_equal_p (arg01, arg11, 0))\n+\t    return fold_build2 (code, type, arg00, arg10);\n+\t  if (operand_equal_p (arg01, arg10, 0))\n+\t    return fold_build2 (code, type, arg00, arg11);\n+\t  if (operand_equal_p (arg00, arg11, 0))\n+\t    return fold_build2 (code, type, arg01, arg10);\n+\t  if (operand_equal_p (arg00, arg10, 0))\n+\t    return fold_build2 (code, type, arg01, arg11);\n+\n+\t  /* Optimize (X ^ C1) op (Y ^ C2) as (X ^ (C1 ^ C2)) op Y.  */\n+\t  if (TREE_CODE (arg01) == INTEGER_CST\n+\t      && TREE_CODE (arg11) == INTEGER_CST)\n+\t    return fold_build2 (code, type,\n+\t\t\t\tfold_build2 (BIT_XOR_EXPR, itype, arg00,\n+\t\t\t\t\t     fold_build2 (BIT_XOR_EXPR, itype,\n+\t\t\t\t\t\t\t  arg01, arg11)),\n+\t\t\t\targ10);\n+\t}\n       return NULL_TREE;\n \n     case LT_EXPR:"}, {"sha": "429382b4f12a5a52156c96611ffc6df5012f2867", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf06e5c146b311b9a1f3109f2047a14ee458304d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf06e5c146b311b9a1f3109f2047a14ee458304d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cf06e5c146b311b9a1f3109f2047a14ee458304d", "patch": "@@ -1,3 +1,7 @@\n+2007-01-01  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.dg/fold-eqxor-4.c: New test case.\n+\n 2007-01-02  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR middle-end/30311"}, {"sha": "bdf31bc885014d8ff52faa83a8ee637172ffeabc", "filename": "gcc/testsuite/gcc.dg/fold-eqxor-4.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf06e5c146b311b9a1f3109f2047a14ee458304d/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-eqxor-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf06e5c146b311b9a1f3109f2047a14ee458304d/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-eqxor-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-eqxor-4.c?ref=cf06e5c146b311b9a1f3109f2047a14ee458304d", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-original\" } */\n+\n+int test1(int a)\n+{\n+  return (a ^ 6) == 2;\n+}\n+\n+int test2(int b, int c, int d)\n+{\n+  return (b ^ d) == (c ^ d);\n+}\n+\n+int test3(int e, int f)\n+{\n+  return (e ^ 6) == (f ^ 4);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"a == 4\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"b == c\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"e \\\\^ 2\" 1 \"original\" } } */\n+/* { dg-final { cleanup-tree-dump \"original\" } } */"}]}