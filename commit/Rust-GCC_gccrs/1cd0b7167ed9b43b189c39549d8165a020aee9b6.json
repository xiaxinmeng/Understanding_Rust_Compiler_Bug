{"sha": "1cd0b7167ed9b43b189c39549d8165a020aee9b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNkMGI3MTY3ZWQ5YjQzYjE4OWMzOTU0OWQ4MTY1YTAyMGFlZTliNg==", "commit": {"author": {"name": "Dave Korn", "email": "dave.korn.cygwin@gmail.com", "date": "2010-10-07T20:28:59Z"}, "committer": {"name": "Dave Korn", "email": "davek@gcc.gnu.org", "date": "2010-10-07T20:28:59Z"}, "message": "configure.ac (build_lto_plugin): New shell variable.\n\nChangeLog:\n\n2010-10-07  Dave Korn  <dave.korn.cygwin@gmail.com>\n\n\t* configure.ac (build_lto_plugin): New shell variable.\n\t(--enable-lto): Turn on by default for all non-ELF platforms that\n\thave had LTO support added so far.  Set build_lto_plugin appropriately\n\tfor both ELF and non-ELF.\n\t(configdirs): Add lto-plugin or not based on build_lto_plugin.\n\t* configure: Regenerate.\n\ngcc/ChangeLog:\n\n2010-10-07  Dave Korn  <dave.korn.cygwin@gmail.com>\n\n\t* config.host (host_lto_plugin_soname): New shell variable.\n\t* configure.ac (LTOPLUGINSONAME): Add an AC_DEFINE for the above.\n\t* config.in: Regenerate.\n\t* configure: Regenerate.\n\t* gcc.c (main): Use LTOPLUGINSONAME instead of hard-coding name of\n\tLTO plugin shared library.\n\nlto-plugin/ChangeLog:\n\n2010-10-07  Dave Korn  <dave.korn.cygwin@gmail.com>\n\n\t* configure.ac: Source config.gcc to determine lto_binary_reader.\n\t(LTO_FORMAT): New AC_SUBST variable inferred from lto_binary_reader.\n\t* Makefile.am (LTO_FORMAT): Import.\n\t(liblto_plugin_la_SOURCES): Add object format dependent module\n\tdefined by LTO_FORMAT.\n\t(liblto_plugin_la_LIBADD): Allow for both PIC and non-PIC libiberty,\n\tand work around libtool warning.\n\t* configure: Regenerate.\n\t* Makefile.in: Likewise.\n\t* lto-plugin.c (struct sym_aux): Move to new lto-plugin.h.\n\t(struct sym_aux): Likewise.\n\t(struct plugin_symtab): Likewise.\n\t(struct plugin_file_info): Likewise.\n\t(LTO_SECTION_PREFIX): Likewise.\n\t(add_symbols):  Make non-static.\n\t(claimed_files): Likewise.\n\t(num_claimed_files): Likewise.\n\t(check): Likewise.\n\t(parse_table_entry): Likewise.\n\t(translate): Likewise.\n\t(resolve_conflicts): Likewise.\n\t(process_symtab): Move to new lto-plugin-elf.c object format dependent\n\tsource file.\n\t(claim_file_handler): Likewise, and make non-static.\n\t(onload): Call new onload_format_checks function.\n\t* lto-plugin.h: New file.\n\t(LTO_SECTION_PREFIX): Move here.\n\t(struct sym_aux): Likewise.\n\t(struct plugin_symtab): Likewise.\n\t(struct plugin_file_info): Likewise.\n\t(claim_file_handler): Add new function prototype.\n\t(onload_format_checks): Likewise.\n\t(check): Declare extern.\n\t(translate): Likewise.\n\t(parse_table_entry): Likewise.\n\t(resolve_conflicts): Likewise.\n\t(add_symbols):  Likewise.\n\t(claimed_files): Likewise.\n\t(num_claimed_files): Likewise.\n\t* lto-plugin-elf.c (process_symtab): Move here.\n\t(claim_file_handler): Likewise, and make non-static.\n\t(onload_format_checks): New function factored out from onload.\n\t* lto-plugin-coff.c (claim_file_handler): New function stub.\n\t(onload_format_checks): Likewise.\n\nFrom-SVN: r165133", "tree": {"sha": "946186568fee00058aace74937894e09bce8b4b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/946186568fee00058aace74937894e09bce8b4b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1cd0b7167ed9b43b189c39549d8165a020aee9b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cd0b7167ed9b43b189c39549d8165a020aee9b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cd0b7167ed9b43b189c39549d8165a020aee9b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cd0b7167ed9b43b189c39549d8165a020aee9b6/comments", "author": {"login": "davek-cygwin", "id": 530057, "node_id": "MDQ6VXNlcjUzMDA1Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/530057?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davek-cygwin", "html_url": "https://github.com/davek-cygwin", "followers_url": "https://api.github.com/users/davek-cygwin/followers", "following_url": "https://api.github.com/users/davek-cygwin/following{/other_user}", "gists_url": "https://api.github.com/users/davek-cygwin/gists{/gist_id}", "starred_url": "https://api.github.com/users/davek-cygwin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davek-cygwin/subscriptions", "organizations_url": "https://api.github.com/users/davek-cygwin/orgs", "repos_url": "https://api.github.com/users/davek-cygwin/repos", "events_url": "https://api.github.com/users/davek-cygwin/events{/privacy}", "received_events_url": "https://api.github.com/users/davek-cygwin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6ba74c2d192958de47dc1d7b36125495441a4d50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ba74c2d192958de47dc1d7b36125495441a4d50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ba74c2d192958de47dc1d7b36125495441a4d50"}], "stats": {"total": 653, "additions": 465, "deletions": 188}, "files": [{"sha": "f9d37cb12098c3a41272263285f33eac149811b8", "filename": "ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cd0b7167ed9b43b189c39549d8165a020aee9b6/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cd0b7167ed9b43b189c39549d8165a020aee9b6/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=1cd0b7167ed9b43b189c39549d8165a020aee9b6", "patch": "@@ -1,3 +1,12 @@\n+2010-10-07  Dave Korn  <dave.korn.cygwin@gmail.com>\n+\n+\t* configure.ac (build_lto_plugin): New shell variable.\n+\t(--enable-lto): Turn on by default for all non-ELF platforms that\n+\thave had LTO support added so far.  Set build_lto_plugin appropriately\n+\tfor both ELF and non-ELF.\n+\t(configdirs): Add lto-plugin or not based on build_lto_plugin.\n+\t* configure: Regenerate.\n+\n 2010-10-07  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \tSync from src:"}, {"sha": "b1fbfaa73d087f2f81e62407f1b19e9981933ec4", "filename": "configure", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cd0b7167ed9b43b189c39549d8165a020aee9b6/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cd0b7167ed9b43b189c39549d8165a020aee9b6/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=1cd0b7167ed9b43b189c39549d8165a020aee9b6", "patch": "@@ -6676,11 +6676,13 @@ to specify its location.\" \"$LINENO\" 5\n   # Flags needed for libelf.\n \n \n+  # ELF platforms build the lto-plugin when GOLD is in use.\n+  build_lto_plugin=${ENABLE_GOLD}\n fi\n else\n   if test x\"$default_enable_lto\" = x\"yes\" ; then\n     case $target in\n-      *-apple-darwin*) ;;\n+      *-apple-darwin* | *-cygwin* | *-mingw*) ;;\n       # On other non-ELF platforms, LTO must be explicitly enabled.\n       *) enable_lto=no ;;\n     esac\n@@ -6691,13 +6693,18 @@ else\n   # warn during gcc/ subconfigure; unless you're bootstrapping with\n   # -flto it won't be needed until after installation anyway.\n     case $target in\n-      *-cygwin*|*-mingw* | *-apple-darwin*) ;;\n+      *-cygwin* | *-mingw* | *-apple-darwin*) ;;\n       *) if test x\"$enable_lto\" = x\"yes\"; then\n \tas_fn_error \"LTO support is not enabled for this target.\" \"$LINENO\" 5\n         fi\n       ;;\n     esac\n   fi\n+  # Among non-ELF, only Windows platforms support the lto-plugin so far.\n+  case $target in\n+    *-cygwin* | *-mingw*) build_lto_plugin=yes ;;\n+    *) ;;\n+  esac\n   default_enable_lto=no\n fi\n \n@@ -6778,7 +6785,7 @@ if test -d ${srcdir}/gcc; then\n       *,lto,*) ;;\n       *) enable_languages=\"${enable_languages},lto\" ;;\n     esac\n-    if test \"${ENABLE_GOLD}\" = \"yes\" ; then\n+    if test \"${build_lto_plugin}\" = \"yes\" ; then\n       configdirs=\"$configdirs lto-plugin\"\n       extra_host_libiberty_configure_flags=--enable-shared\n     fi"}, {"sha": "bf5fe3ad83285a1bbc7addba0ed39b484ba48bef", "filename": "configure.ac", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cd0b7167ed9b43b189c39549d8165a020aee9b6/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cd0b7167ed9b43b189c39549d8165a020aee9b6/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=1cd0b7167ed9b43b189c39549d8165a020aee9b6", "patch": "@@ -1786,9 +1786,11 @@ to specify its location.])\n   # Flags needed for libelf.\n   AC_SUBST(libelflibs)\n   AC_SUBST(libelfinc)\n+  # ELF platforms build the lto-plugin when GOLD is in use.\n+  build_lto_plugin=${ENABLE_GOLD}\n fi],[if test x\"$default_enable_lto\" = x\"yes\" ; then\n     case $target in\n-      *-apple-darwin*) ;;\n+      *-apple-darwin* | *-cygwin* | *-mingw*) ;;\n       # On other non-ELF platforms, LTO must be explicitly enabled.\n       *) enable_lto=no ;;\n     esac\n@@ -1799,13 +1801,18 @@ fi],[if test x\"$default_enable_lto\" = x\"yes\" ; then\n   # warn during gcc/ subconfigure; unless you're bootstrapping with\n   # -flto it won't be needed until after installation anyway.\n     case $target in\n-      *-cygwin*|*-mingw* | *-apple-darwin*) ;;\n+      *-cygwin* | *-mingw* | *-apple-darwin*) ;;\n       *) if test x\"$enable_lto\" = x\"yes\"; then\n \tAC_MSG_ERROR([LTO support is not enabled for this target.])\n         fi\n       ;;\n     esac\n   fi\n+  # Among non-ELF, only Windows platforms support the lto-plugin so far.\n+  case $target in\n+    *-cygwin* | *-mingw*) build_lto_plugin=yes ;;\n+    *) ;;\n+  esac\n   default_enable_lto=no])\n \n \n@@ -1884,7 +1891,7 @@ if test -d ${srcdir}/gcc; then\n       *,lto,*) ;;\n       *) enable_languages=\"${enable_languages},lto\" ;;\n     esac\n-    if test \"${ENABLE_GOLD}\" = \"yes\" ; then\n+    if test \"${build_lto_plugin}\" = \"yes\" ; then\n       configdirs=\"$configdirs lto-plugin\"\n       extra_host_libiberty_configure_flags=--enable-shared\n     fi"}, {"sha": "6b50b65d52a71a2d2e689a9fc23696ac11a0a0ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cd0b7167ed9b43b189c39549d8165a020aee9b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cd0b7167ed9b43b189c39549d8165a020aee9b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1cd0b7167ed9b43b189c39549d8165a020aee9b6", "patch": "@@ -1,3 +1,12 @@\n+2010-10-07  Dave Korn  <dave.korn.cygwin@gmail.com>\n+\n+\t* config.host (host_lto_plugin_soname): New shell variable.\n+\t* configure.ac (LTOPLUGINSONAME): Add an AC_DEFINE for the above.\n+\t* config.in: Regenerate.\n+\t* configure: Regenerate.\n+\t* gcc.c (main): Use LTOPLUGINSONAME instead of hard-coding name of\n+\tLTO plugin shared library.\n+\n 2010-10-07  Richard Henderson  <rth@redhat.com>\n \n \t* target.h (enum unwind_info_type): Move ..."}, {"sha": "c035a50c91eba5cf714fbd7e3897e1c4df7ae26a", "filename": "gcc/config.host", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cd0b7167ed9b43b189c39549d8165a020aee9b6/gcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cd0b7167ed9b43b189c39549d8165a020aee9b6/gcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.host?ref=1cd0b7167ed9b43b189c39549d8165a020aee9b6", "patch": "@@ -51,10 +51,15 @@\n #\n #  host_can_use_collect2 Set to yes normally; to no if the host cannot\n #\t\t\tlink or otherwise use collect2\n+#\n #  use_long_long_for_widest_fast_int Set this to 'yes' if 'long long'\n #\t\t\t(or '__int64') is wider than 'long' but still\n #\t\t\tefficeiently supported by the host hardware.\n #\t\t\tOnly affects compile speed.  Default is 'no'.\n+#\n+#  host_lto_plugin_soname Set this to the name to which the LTO linker\n+#\t\t\tplugin gets compiled on this host, if it is\n+#\t\t\tdifferent from the default \"liblto_plugin.so\".\n \n # When setting any of these variables, check to see if a corresponding\n # variable is present in config.build; if so, you will likely want to \n@@ -70,6 +75,7 @@ host_extra_gcc_objs=\n out_host_hook_obj=host-default.o\n host_can_use_collect2=yes\n use_long_long_for_widest_fast_int=no\n+host_lto_plugin_soname=liblto_plugin.so\n \n # Unsupported hosts list.  Generally, only include hosts known to fail here,\n # since we allow hosts not listed to be supported generically.\n@@ -206,19 +212,22 @@ case ${host} in\n     out_host_hook_obj=host-cygwin.o\n     host_xmake_file=\"${host_xmake_file} i386/x-cygwin\"\n     host_exeext=.exe\n+    host_lto_plugin_soname=cyglto_plugin-0.dll\n     ;;\n   i[34567]86-*-mingw32*)\n     host_xm_file=i386/xm-mingw32.h\n     host_xmake_file=\"${host_xmake_file} i386/x-mingw32\"\n     host_exeext=.exe\n     out_host_hook_obj=host-mingw32.o\n+    host_lto_plugin_soname=liblto_plugin-0.dll\n     ;;\n   x86_64-*-mingw*)\n     use_long_long_for_widest_fast_int=yes\n     host_xm_file=i386/xm-mingw32.h\n     host_xmake_file=\"${host_xmake_file} i386/x-mingw32\"\n     host_exeext=.exe\n     out_host_hook_obj=host-mingw32.o\n+    host_lto_plugin_soname=liblto_plugin-0.dll\n     ;;\n   i[34567]86-*-uwin*)\n     echo \"*** UWIN may not be used as a host platform because\""}, {"sha": "4576de072d2dda20f9122bb6741614c2114930f0", "filename": "gcc/config.in", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cd0b7167ed9b43b189c39549d8165a020aee9b6/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cd0b7167ed9b43b189c39549d8165a020aee9b6/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=1cd0b7167ed9b43b189c39549d8165a020aee9b6", "patch": "@@ -959,9 +959,6 @@\n /* Define if your assembler and linker support .hidden. */\n #undef HAVE_GAS_HIDDEN\n \n-/* Define if your system supports gnu indirect functions. */\n-#undef HAVE_GNU_INDIRECT_FUNCTION\n-\n /* Define if your assembler supports .lcomm with an alignment field. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_GAS_LCOMM_WITH_ALIGNMENT\n@@ -1062,6 +1059,12 @@\n #endif\n \n \n+/* Define if your system supports gnu indirect functions. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_GNU_INDIRECT_FUNCTION\n+#endif\n+\n+\n /* Define if using GNU ld. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_GNU_LD\n@@ -1543,6 +1546,13 @@\n #endif\n \n \n+/* Define to the name of the LTO plugin DSO that must be passed to the\n+   linker's -plugin=LIB option. */\n+#ifndef USED_FOR_TARGET\n+#undef LTOPLUGINSONAME\n+#endif\n+\n+\n /* Define to the sub-directory in which libtool stores uninstalled libraries.\n    */\n #ifndef USED_FOR_TARGET"}, {"sha": "68cb29e2eefdbb7d643a163d055af9b0d269d643", "filename": "gcc/configure", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cd0b7167ed9b43b189c39549d8165a020aee9b6/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cd0b7167ed9b43b189c39549d8165a020aee9b6/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=1cd0b7167ed9b43b189c39549d8165a020aee9b6", "patch": "@@ -11045,6 +11045,12 @@ case $use_collect2 in\n     ;;\n esac\n \n+\n+cat >>confdefs.h <<_ACEOF\n+#define LTOPLUGINSONAME \"${host_lto_plugin_soname}\"\n+_ACEOF\n+\n+\n # ---------------------------\n # Assembler & linker features\n # ---------------------------\n@@ -17127,7 +17133,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 17130 \"configure\"\n+#line 17136 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -17233,7 +17239,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 17236 \"configure\"\n+#line 17242 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H"}, {"sha": "9dd9c5d086ac7013f096f096e96957d8c46b7da3", "filename": "gcc/configure.ac", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cd0b7167ed9b43b189c39549d8165a020aee9b6/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cd0b7167ed9b43b189c39549d8165a020aee9b6/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=1cd0b7167ed9b43b189c39549d8165a020aee9b6", "patch": "@@ -1811,6 +1811,10 @@ case $use_collect2 in\n     ;;\n esac\n \n+AC_DEFINE_UNQUOTED(LTOPLUGINSONAME,\"${host_lto_plugin_soname}\",\n+[Define to the name of the LTO plugin DSO that must be\n+  passed to the linker's -plugin=LIB option.])\n+\n # ---------------------------\n # Assembler & linker features\n # ---------------------------"}, {"sha": "7005c5c59aa7120c536cc3dc644bcee0219bf7be", "filename": "gcc/gcc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cd0b7167ed9b43b189c39549d8165a020aee9b6/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cd0b7167ed9b43b189c39549d8165a020aee9b6/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=1cd0b7167ed9b43b189c39549d8165a020aee9b6", "patch": "@@ -6827,10 +6827,10 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t\t\t  fuse_linker_plugin + strlen (fuse_linker_plugin), 0))\n \t{\n \t  linker_plugin_file_spec = find_a_file (&exec_prefixes,\n-\t\t\t\t\t\t \"liblto_plugin.so\", R_OK,\n+\t\t\t\t\t\t LTOPLUGINSONAME, R_OK,\n \t\t\t\t\t\t false);\n \t  if (!linker_plugin_file_spec)\n-\t    fatal_error (\"-fuse-linker-plugin, but liblto_plugin.so not found\");\n+\t    fatal_error (\"-fuse-linker-plugin, but \" LTOPLUGINSONAME \" not found\");\n \n \t  lto_libgcc_spec = find_a_file (&startfile_prefixes, \"libgcc.a\",\n \t\t\t\t\t R_OK, true);"}, {"sha": "9caad6aab546a4943116424f7ed67e518447614f", "filename": "lto-plugin/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cd0b7167ed9b43b189c39549d8165a020aee9b6/lto-plugin%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cd0b7167ed9b43b189c39549d8165a020aee9b6/lto-plugin%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2FChangeLog?ref=1cd0b7167ed9b43b189c39549d8165a020aee9b6", "patch": "@@ -1,3 +1,50 @@\n+2010-10-07  Dave Korn  <dave.korn.cygwin@gmail.com>\n+\n+\t* configure.ac: Source config.gcc to determine lto_binary_reader.\n+\t(LTO_FORMAT): New AC_SUBST variable inferred from lto_binary_reader.\n+\t* Makefile.am (LTO_FORMAT): Import.\n+\t(liblto_plugin_la_SOURCES): Add object format dependent module\n+\tdefined by LTO_FORMAT.\n+\t(liblto_plugin_la_LIBADD): Allow for both PIC and non-PIC libiberty,\n+\tand work around libtool warning.\n+\t* configure: Regenerate.\n+\t* Makefile.in: Likewise.\n+\t* lto-plugin.c (struct sym_aux): Move to new lto-plugin.h.\n+\t(struct sym_aux): Likewise.\n+\t(struct plugin_symtab): Likewise.\n+\t(struct plugin_file_info): Likewise.\n+\t(LTO_SECTION_PREFIX): Likewise.\n+\t(add_symbols):  Make non-static.\n+\t(claimed_files): Likewise.\n+\t(num_claimed_files): Likewise.\n+\t(check): Likewise.\n+\t(parse_table_entry): Likewise.\n+\t(translate): Likewise.\n+\t(resolve_conflicts): Likewise.\n+\t(process_symtab): Move to new lto-plugin-elf.c object format dependent\n+\tsource file.\n+\t(claim_file_handler): Likewise, and make non-static.\n+\t(onload): Call new onload_format_checks function.\n+\t* lto-plugin.h: New file.\n+\t(LTO_SECTION_PREFIX): Move here.\n+\t(struct sym_aux): Likewise.\n+\t(struct plugin_symtab): Likewise.\n+\t(struct plugin_file_info): Likewise.\n+\t(claim_file_handler): Add new function prototype.\n+\t(onload_format_checks): Likewise.\n+\t(check): Declare extern.\n+\t(translate): Likewise.\n+\t(parse_table_entry): Likewise.\n+\t(resolve_conflicts): Likewise.\n+\t(add_symbols):  Likewise.\n+\t(claimed_files): Likewise.\n+\t(num_claimed_files): Likewise.\n+\t* lto-plugin-elf.c (process_symtab): Move here.\n+\t(claim_file_handler): Likewise, and make non-static.\n+\t(onload_format_checks): New function factored out from onload.\n+\t* lto-plugin-coff.c (claim_file_handler): New function stub.\n+\t(onload_format_checks): Likewise.\n+\n 2010-08-05  Andi Kleen  <ak@linux.intel.com>\n \n \t* lto-plugin.c: Include <hashtab.h>"}, {"sha": "52bf6719daa6a39e146517704886ea05973c36cf", "filename": "lto-plugin/Makefile.am", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cd0b7167ed9b43b189c39549d8165a020aee9b6/lto-plugin%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cd0b7167ed9b43b189c39549d8165a020aee9b6/lto-plugin%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2FMakefile.am?ref=1cd0b7167ed9b43b189c39549d8165a020aee9b6", "patch": "@@ -11,13 +11,19 @@ libexecsubdir := $(libexecdir)/gcc/$(target_noncanonical)/$(gcc_version)\n LIBELFLIBS = @LIBELFLIBS@\n LIBELFINC = @LIBELFINC@\n \n+# Which object format to parse.\n+LTO_FORMAT = @LTO_FORMAT@\n+\n AM_CPPFLAGS = -I$(top_srcdir)/../include $(LIBELFINC)\n AM_CFLAGS = -Wall -Werror\n \n libexecsub_LTLIBRARIES = liblto_plugin.la\n \n-liblto_plugin_la_SOURCES = lto-plugin.c\n-liblto_plugin_la_LIBADD = $(LIBELFLIBS) ../libiberty/pic/libiberty.a\n+liblto_plugin_la_SOURCES = lto-plugin.c lto-plugin-$(LTO_FORMAT).c\n+liblto_plugin_la_LIBADD = $(LIBELFLIBS) \\\n+\t$(if $(wildcard ../libiberty/pic/libiberty.a),../libiberty/pic/libiberty.a,)\n+liblto_plugin_la_LDFLAGS = -no-undefined -bindir $(libexecsubdir) \\\n+\t$(if $(wildcard ../libiberty/pic/libiberty.a),,-Wc,../libiberty/libiberty.a)\n \n all: copy_lto_plugin\n "}, {"sha": "c3f5260ed7d6930aa1ab12aa72036c2d40347997", "filename": "lto-plugin/Makefile.in", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cd0b7167ed9b43b189c39549d8165a020aee9b6/lto-plugin%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cd0b7167ed9b43b189c39549d8165a020aee9b6/lto-plugin%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2FMakefile.in?ref=1cd0b7167ed9b43b189c39549d8165a020aee9b6", "patch": "@@ -79,10 +79,14 @@ am__base_list = \\\n am__installdirs = \"$(DESTDIR)$(libexecsubdir)\"\n LTLIBRARIES = $(libexecsub_LTLIBRARIES)\n am__DEPENDENCIES_1 =\n-liblto_plugin_la_DEPENDENCIES = $(am__DEPENDENCIES_1) \\\n-\t../libiberty/pic/libiberty.a\n-am_liblto_plugin_la_OBJECTS = lto-plugin.lo\n+liblto_plugin_la_DEPENDENCIES = $(am__DEPENDENCIES_1) $(if $(wildcard \\\n+\t../libiberty/pic/libiberty.a),../libiberty/pic/libiberty.a,)\n+am_liblto_plugin_la_OBJECTS = lto-plugin.lo \\\n+\tlto-plugin-$(LTO_FORMAT).lo\n liblto_plugin_la_OBJECTS = $(am_liblto_plugin_la_OBJECTS)\n+liblto_plugin_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n+\t$(liblto_plugin_la_LDFLAGS) $(LDFLAGS) -o $@\n DEFAULT_INCLUDES = -I.@am__isrc@\n depcomp =\n am__depfiles_maybe =\n@@ -139,6 +143,9 @@ LIBTOOL = @LIBTOOL@\n LIPO = @LIPO@\n LN_S = @LN_S@\n LTLIBOBJS = @LTLIBOBJS@\n+\n+# Which object format to parse.\n+LTO_FORMAT = @LTO_FORMAT@\n MAINT = @MAINT@\n MAKEINFO = @MAKEINFO@\n MKDIR_P = @MKDIR_P@\n@@ -225,8 +232,13 @@ libexecsubdir := $(libexecdir)/gcc/$(target_noncanonical)/$(gcc_version)\n AM_CPPFLAGS = -I$(top_srcdir)/../include $(LIBELFINC)\n AM_CFLAGS = -Wall -Werror\n libexecsub_LTLIBRARIES = liblto_plugin.la\n-liblto_plugin_la_SOURCES = lto-plugin.c\n-liblto_plugin_la_LIBADD = $(LIBELFLIBS) ../libiberty/pic/libiberty.a\n+liblto_plugin_la_SOURCES = lto-plugin.c lto-plugin-$(LTO_FORMAT).c\n+liblto_plugin_la_LIBADD = $(LIBELFLIBS) \\\n+\t$(if $(wildcard ../libiberty/pic/libiberty.a),../libiberty/pic/libiberty.a,)\n+\n+liblto_plugin_la_LDFLAGS = -no-undefined -bindir $(libexecsubdir) \\\n+\t$(if $(wildcard ../libiberty/pic/libiberty.a),,-Wc,../libiberty/libiberty.a)\n+\n all: all-am\n \n .SUFFIXES:\n@@ -297,7 +309,7 @@ clean-libexecsubLTLIBRARIES:\n \t  rm -f \"$${dir}/so_locations\"; \\\n \tdone\n liblto_plugin.la: $(liblto_plugin_la_OBJECTS) $(liblto_plugin_la_DEPENDENCIES) \n-\t$(LINK) -rpath $(libexecsubdir) $(liblto_plugin_la_OBJECTS) $(liblto_plugin_la_LIBADD) $(LIBS)\n+\t$(liblto_plugin_la_LINK) -rpath $(libexecsubdir) $(liblto_plugin_la_OBJECTS) $(liblto_plugin_la_LIBADD) $(LIBS)\n \n mostlyclean-compile:\n \t-rm -f *.$(OBJEXT)"}, {"sha": "1e4041bc7e7a059baaffce156b34d412eb4e1680", "filename": "lto-plugin/configure", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cd0b7167ed9b43b189c39549d8165a020aee9b6/lto-plugin%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cd0b7167ed9b43b189c39549d8165a020aee9b6/lto-plugin%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2Fconfigure?ref=1cd0b7167ed9b43b189c39549d8165a020aee9b6", "patch": "@@ -601,6 +601,7 @@ ac_subst_vars='am__EXEEXT_FALSE\n am__EXEEXT_TRUE\n LTLIBOBJS\n LIBOBJS\n+LTO_FORMAT\n target_noncanonical\n CPP\n OTOOL64\n@@ -10397,7 +10398,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 10400 \"configure\"\n+#line 10401 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -10503,7 +10504,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 10506 \"configure\"\n+#line 10507 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -10741,6 +10742,14 @@ CC=\"$lt_save_CC\"\n \n \n \n+. ${srcdir}/../gcc/config.gcc\n+case ${lto_binary_reader} in\n+  *coff*) LTO_FORMAT=coff ;;\n+  *elf*)  LTO_FORMAT=elf ;;\n+  *) as_fn_error \"LTO plugin is not supported on this target.\" \"$LINENO\" 5 ;;\n+esac\n+\n+\n ac_fn_c_find_uintX_t \"$LINENO\" \"64\" \"ac_cv_c_uint64_t\"\n case $ac_cv_c_uint64_t in #(\n   no|yes) ;; #("}, {"sha": "c43b26434e8e2724f47ce3f8868f2b996393a053", "filename": "lto-plugin/configure.ac", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cd0b7167ed9b43b189c39549d8165a020aee9b6/lto-plugin%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cd0b7167ed9b43b189c39549d8165a020aee9b6/lto-plugin%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2Fconfigure.ac?ref=1cd0b7167ed9b43b189c39549d8165a020aee9b6", "patch": "@@ -9,6 +9,14 @@ AC_ARG_VAR(LIBELFLIBS,[How to link libelf])\n AC_ARG_VAR(LIBELFINC,[How to find libelf include files])\n AM_PROG_LIBTOOL\n AC_SUBST(target_noncanonical)\n+. ${srcdir}/../gcc/config.gcc\n+case ${lto_binary_reader} in\n+  *coff*) LTO_FORMAT=coff ;;\n+  *elf*)  LTO_FORMAT=elf ;;\n+  *) AC_MSG_ERROR([LTO plugin is not supported on this target.]) ;;\n+esac\n+\n+AC_SUBST(LTO_FORMAT)\n AC_TYPE_UINT64_T\n AC_CONFIG_FILES(Makefile)\n AC_OUTPUT"}, {"sha": "acaff5979f2172c912ba645bbb4ae8e36be5af6e", "filename": "lto-plugin/lto-plugin-coff.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cd0b7167ed9b43b189c39549d8165a020aee9b6/lto-plugin%2Flto-plugin-coff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cd0b7167ed9b43b189c39549d8165a020aee9b6/lto-plugin%2Flto-plugin-coff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2Flto-plugin-coff.c?ref=1cd0b7167ed9b43b189c39549d8165a020aee9b6", "patch": "@@ -0,0 +1,38 @@\n+/* LTO plugin for gold.\n+   Copyright (C) 2010 Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+This program is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Common definitions that the object format dependent code needs.  */\n+#include \"lto-plugin.h\"\n+\n+/* Callback used by gold to check if the plugin will claim FILE. Writes\n+   the result in CLAIMED. */\n+\n+enum ld_plugin_status\n+claim_file_handler (const struct ld_plugin_input_file *file, int *claimed)\n+{\n+  /* To be implemented; for now, simply do nothing.  */\n+  return LDPS_OK;\n+}\n+\n+/* Method called first thing at onload time to perform sanity checks.  */\n+\n+enum ld_plugin_status\n+onload_format_checks (struct ld_plugin_tv *tv)\n+{\n+  return LDPS_OK;\n+}\n+"}, {"sha": "afd79dac05687a6ba19cfaa1565e8eabab21887d", "filename": "lto-plugin/lto-plugin-elf.c", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cd0b7167ed9b43b189c39549d8165a020aee9b6/lto-plugin%2Flto-plugin-elf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cd0b7167ed9b43b189c39549d8165a020aee9b6/lto-plugin%2Flto-plugin-elf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2Flto-plugin-elf.c?ref=1cd0b7167ed9b43b189c39549d8165a020aee9b6", "patch": "@@ -0,0 +1,157 @@\n+/* LTO plugin for gold.\n+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+   Contributed by Rafael Avila de Espindola (espindola@google.com).\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+This program is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+#include <libiberty.h>\n+#include <stdlib.h>\n+#include <inttypes.h>\n+\n+/* The presence of gelf.h is checked by the toplevel configure script.  */\n+#include <gelf.h>\n+\n+/* Common definitions that the object format dependent code needs.  */\n+#include \"lto-plugin.h\"\n+\n+/* Process all lto symtabs of file ELF. */\n+\n+static int\n+process_symtab (Elf *elf, struct plugin_symtab *out)\n+{\n+  int found = 0;\n+  Elf_Scn *section = 0;\n+  GElf_Ehdr header;\n+  GElf_Ehdr *t = gelf_getehdr (elf, &header);\n+  if (t == NULL)\n+    return 0;\n+  assert (t == &header);\n+\n+  while ((section = elf_nextscn(elf, section)) != 0)\n+    {\n+      GElf_Shdr shdr;\n+      GElf_Shdr *tshdr = gelf_getshdr (section, &shdr);\n+      Elf_Data *symtab;\n+      const char *t;\n+      assert (tshdr == &shdr);\n+      t = elf_strptr (elf, header.e_shstrndx, shdr.sh_name);\n+      assert (t != NULL);\n+      if (strncmp (t, LTO_SECTION_PREFIX, strlen (LTO_SECTION_PREFIX)) == 0) \n+\t{\n+\t  char *s = strrchr (t, '.');\n+\t  if (s)\n+\t      sscanf (s, \".%x\", &out->id);\n+\t  symtab = elf_getdata (section, NULL);\n+\t  translate (symtab->d_buf, symtab->d_buf + symtab->d_size, out);\n+\t  found++;\n+\t}\n+    }\n+  return found;\n+}\n+\n+/* Callback used by gold to check if the plugin will claim FILE. Writes\n+   the result in CLAIMED. */\n+\n+enum ld_plugin_status\n+claim_file_handler (const struct ld_plugin_input_file *file, int *claimed)\n+{\n+  enum ld_plugin_status status;\n+  Elf *elf;\n+  struct plugin_file_info lto_file;\n+  int n;\n+\n+  memset (&lto_file, 0, sizeof (struct plugin_file_info));\n+\n+  if (file->offset != 0)\n+    {\n+      char *objname;\n+      Elf *archive;\n+      off_t offset;\n+      /* We pass the offset of the actual file, not the archive header. */\n+      int t = asprintf (&objname, \"%s@0x%\" PRIx64, file->name,\n+                        (int64_t) file->offset);\n+      check (t >= 0, LDPL_FATAL, \"asprintf failed\");\n+      lto_file.name = objname;\n+\n+      archive = elf_begin (file->fd, ELF_C_READ, NULL);\n+      check (elf_kind (archive) == ELF_K_AR, LDPL_FATAL,\n+             \"Not an archive and offset not 0\");\n+\n+      /* elf_rand expects the offset to point to the ar header, not the\n+         object itself. Subtract the size of the ar header (60 bytes).\n+         We don't uses sizeof (struct ar_hd) to avoid including ar.h */\n+\n+      offset = file->offset - 60;\n+      check (offset == elf_rand (archive, offset), LDPL_FATAL,\n+             \"could not seek in archive\");\n+      elf = elf_begin (file->fd, ELF_C_READ, archive);\n+      check (elf != NULL, LDPL_FATAL, \"could not find archive member\");\n+      elf_end (archive);\n+    }\n+  else\n+    {\n+      lto_file.name = xstrdup (file->name);\n+      elf = elf_begin (file->fd, ELF_C_READ, NULL);\n+    }\n+  lto_file.handle = file->handle;\n+\n+  *claimed = 0;\n+\n+  if (!elf)\n+    goto err;\n+\n+  n = process_symtab (elf, &lto_file.symtab);\n+  if (n == 0)\n+    goto err;\n+\n+  if (n > 1)\n+    resolve_conflicts (&lto_file.symtab, &lto_file.conflicts);\n+\n+  status = add_symbols (file->handle, lto_file.symtab.nsyms,\n+\t\t\tlto_file.symtab.syms);\n+  check (status == LDPS_OK, LDPL_FATAL, \"could not add symbols\");\n+\n+  *claimed = 1;\n+  num_claimed_files++;\n+  claimed_files =\n+    xrealloc (claimed_files,\n+\t      num_claimed_files * sizeof (struct plugin_file_info));\n+  claimed_files[num_claimed_files - 1] = lto_file;\n+\n+  goto cleanup;\n+\n+ err:\n+  free (lto_file.name);\n+\n+ cleanup:\n+  if (elf)\n+    elf_end (elf);\n+\n+  return LDPS_OK;\n+}\n+\n+/* Method called first thing at onload time to perform sanity checks.  */\n+\n+enum ld_plugin_status\n+onload_format_checks (struct ld_plugin_tv *tv)\n+{\n+  unsigned version = elf_version (EV_CURRENT);\n+  check (version != EV_NONE, LDPL_FATAL, \"invalid ELF version\");\n+  return LDPS_OK;\n+}\n+"}, {"sha": "7e8443d021e5e3c2510ff23b42c6268340c9878b", "filename": "lto-plugin/lto-plugin.c", "status": "modified", "additions": 20, "deletions": 165, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cd0b7167ed9b43b189c39549d8165a020aee9b6/lto-plugin%2Flto-plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cd0b7167ed9b43b189c39549d8165a020aee9b6/lto-plugin%2Flto-plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2Flto-plugin.c?ref=1cd0b7167ed9b43b189c39549d8165a020aee9b6", "patch": "@@ -1,5 +1,5 @@\n-/* LTO plugin for gold.\n-   Copyright (C) 2009 Free Software Foundation, Inc.\n+/* LTO plugin for gold and/or GNU ld.\n+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n    Contributed by Rafael Avila de Espindola (espindola@google.com).\n \n This program is free software; you can redistribute it and/or modify\n@@ -45,55 +45,26 @@ along with this program; see the file COPYING3.  If not see\n #include <stdbool.h>\n #include <libiberty.h>\n #include <hashtab.h>\n-\n-/* The presence of gelf.h is checked by the toplevel configure script.  */\n-#include <gelf.h>\n-\n-#include \"plugin-api.h\"\n #include \"../gcc/lto/common.h\"\n \n-/* The part of the symbol table the plugin has to keep track of. Note that we\n-   must keep SYMS until all_symbols_read is called to give the linker time to\n-   copy the symbol information. */\n-\n-struct sym_aux\n-{\n-  uint32_t slot;\n-  unsigned id;\n-  unsigned next_conflict;\n-};\n-\n-struct plugin_symtab\n-{\n-  int nsyms;\n-  struct sym_aux *aux;\n-  struct ld_plugin_symbol *syms;\n-  unsigned id;\n-};\n-\n-/* All that we have to remember about a file. */\n-\n-struct plugin_file_info\n-{\n-  char *name;\n-  void *handle;\n-  struct plugin_symtab symtab;\n-  struct plugin_symtab conflicts;\n-};\n-\n+/* Common definitions for/from the object format dependent code.  */\n+#include \"lto-plugin.h\"\n \n static char *arguments_file_name;\n static ld_plugin_register_claim_file register_claim_file;\n-static ld_plugin_add_symbols add_symbols;\n static ld_plugin_register_all_symbols_read register_all_symbols_read;\n static ld_plugin_get_symbols get_symbols;\n static ld_plugin_register_cleanup register_cleanup;\n static ld_plugin_add_input_file add_input_file;\n static ld_plugin_add_input_library add_input_library;\n static ld_plugin_message message;\n \n-static struct plugin_file_info *claimed_files = NULL;\n-static unsigned int num_claimed_files = 0;\n+/* These are not static because the object format dependent\n+   claim_file hooks in lto-plugin-{coff,elf}.c need them.  */\n+ld_plugin_add_symbols add_symbols;\n+\n+struct plugin_file_info *claimed_files = NULL;\n+unsigned int num_claimed_files = 0;\n \n static char **output_files = NULL;\n static unsigned int num_output_files = 0;\n@@ -108,7 +79,7 @@ static bool debug;\n static bool nop;\n static char *resolution_file = NULL;\n \n-static void\n+void\n check (bool gate, enum ld_plugin_level level, const char *text)\n {\n   if (gate)\n@@ -129,7 +100,7 @@ check (bool gate, enum ld_plugin_level level, const char *text)\n    by P and the result is written in ENTRY. The slot number is stored in SLOT.\n    Returns the address of the next entry. */\n \n-static char *\n+char *\n parse_table_entry (char *p, struct ld_plugin_symbol *entry, \n \t\t   struct sym_aux *aux)\n {\n@@ -191,16 +162,13 @@ parse_table_entry (char *p, struct ld_plugin_symbol *entry,\n   return p;\n }\n \n-#define LTO_SECTION_PREFIX \".gnu.lto_.symtab\"\n-\n-/* Translate the IL symbol table SYMTAB. Append the slots and symbols to OUT. */\n+/* Translate the IL symbol table located between DATA and END. Append the\n+   slots and symbols to OUT. */\n \n-static void\n-translate (Elf_Data *symtab, struct plugin_symtab *out)\n+void\n+translate (char *data, char *end, struct plugin_symtab *out)\n {\n   struct sym_aux *aux;\n-  char *data = symtab->d_buf;\n-  char *end = data + symtab->d_size;\n   struct ld_plugin_symbol *syms = NULL;\n   int n, len;\n \n@@ -224,39 +192,6 @@ translate (Elf_Data *symtab, struct plugin_symtab *out)\n   out->aux = aux;\n }\n \n-/* Process all lto symtabs of file ELF. */\n-\n-static int\n-process_symtab (Elf *elf, struct plugin_symtab *out)\n-{\n-  int found = 0;\n-  Elf_Scn *section = 0;\n-  GElf_Ehdr header;\n-  GElf_Ehdr *t = gelf_getehdr (elf, &header);\n-  if (t == NULL)\n-    return 0;\n-  assert (t == &header);\n-\n-  while ((section = elf_nextscn(elf, section)) != 0)\n-    {\n-      GElf_Shdr shdr;\n-      GElf_Shdr *tshdr = gelf_getshdr (section, &shdr);\n-      const char *t;\n-      assert (tshdr == &shdr);\n-      t = elf_strptr (elf, header.e_shstrndx, shdr.sh_name);\n-      assert (t != NULL);\n-      if (strncmp (t, LTO_SECTION_PREFIX, strlen (LTO_SECTION_PREFIX)) == 0) \n-\t{\n-\t  char *s = strrchr (t, '.');\n-\t  if (s)\n-\t      sscanf (s, \".%x\", &out->id);\n-\t  translate (elf_getdata (section, NULL), out);\n-\t  found++;\n-\t}\n-    }\n-  return found;\n-}\n-\n /* Free all memory that is no longer needed after writing the symbol\n    resolution. */\n \n@@ -686,7 +621,7 @@ static int symbol_strength (struct ld_plugin_symbol *s)\n    \n    XXX how to handle common? */\n \n-static void\n+void\n resolve_conflicts (struct plugin_symtab *t, struct plugin_symtab *conflicts)\n {\n   htab_t symtab = htab_create (t->nsyms, hash_sym, eq_sym, NULL);\n@@ -754,87 +689,6 @@ resolve_conflicts (struct plugin_symtab *t, struct plugin_symtab *conflicts)\n   htab_delete (symtab);\n }\n \n-/* Callback used by gold to check if the plugin will claim FILE. Writes\n-   the result in CLAIMED. */\n-\n-static enum ld_plugin_status\n-claim_file_handler (const struct ld_plugin_input_file *file, int *claimed)\n-{\n-  enum ld_plugin_status status;\n-  Elf *elf;\n-  struct plugin_file_info lto_file;\n-  int n;\n-\n-  memset (&lto_file, 0, sizeof (struct plugin_file_info));\n-\n-  if (file->offset != 0)\n-    {\n-      char *objname;\n-      Elf *archive;\n-      off_t offset;\n-      /* We pass the offset of the actual file, not the archive header. */\n-      int t = asprintf (&objname, \"%s@0x%\" PRIx64, file->name,\n-                        (int64_t) file->offset);\n-      check (t >= 0, LDPL_FATAL, \"asprintf failed\");\n-      lto_file.name = objname;\n-\n-      archive = elf_begin (file->fd, ELF_C_READ, NULL);\n-      check (elf_kind (archive) == ELF_K_AR, LDPL_FATAL,\n-             \"Not an archive and offset not 0\");\n-\n-      /* elf_rand expects the offset to point to the ar header, not the\n-         object itself. Subtract the size of the ar header (60 bytes).\n-         We don't uses sizeof (struct ar_hd) to avoid including ar.h */\n-\n-      offset = file->offset - 60;\n-      check (offset == elf_rand (archive, offset), LDPL_FATAL,\n-             \"could not seek in archive\");\n-      elf = elf_begin (file->fd, ELF_C_READ, archive);\n-      check (elf != NULL, LDPL_FATAL, \"could not find archive member\");\n-      elf_end (archive);\n-    }\n-  else\n-    {\n-      lto_file.name = xstrdup (file->name);\n-      elf = elf_begin (file->fd, ELF_C_READ, NULL);\n-    }\n-  lto_file.handle = file->handle;\n-\n-  *claimed = 0;\n-\n-  if (!elf)\n-    goto err;\n-\n-  n = process_symtab (elf, &lto_file.symtab);\n-  if (n == 0)\n-    goto err;\n-\n-  if (n > 1)\n-    resolve_conflicts (&lto_file.symtab, &lto_file.conflicts);\n-\n-  status = add_symbols (file->handle, lto_file.symtab.nsyms,\n-\t\t\tlto_file.symtab.syms);\n-  check (status == LDPS_OK, LDPL_FATAL, \"could not add symbols\");\n-\n-  *claimed = 1;\n-  num_claimed_files++;\n-  claimed_files =\n-    xrealloc (claimed_files,\n-\t      num_claimed_files * sizeof (struct plugin_file_info));\n-  claimed_files[num_claimed_files - 1] = lto_file;\n-\n-  goto cleanup;\n-\n- err:\n-  free (lto_file.name);\n-\n- cleanup:\n-  if (elf)\n-    elf_end (elf);\n-\n-  return LDPS_OK;\n-}\n-\n /* Parse the plugin options. */\n \n static void\n@@ -873,8 +727,9 @@ onload (struct ld_plugin_tv *tv)\n   struct ld_plugin_tv *p;\n   enum ld_plugin_status status;\n \n-  unsigned version = elf_version (EV_CURRENT);\n-  check (version != EV_NONE, LDPL_FATAL, \"invalid ELF version\");\n+  status = onload_format_checks (tv);\n+  if (status != LDPS_OK)\n+    return status;\n \n   p = tv;\n   while (p->tv_tag)"}, {"sha": "09eb85003a7b5d14606c48af360c59c9d3a71065", "filename": "lto-plugin/lto-plugin.h", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cd0b7167ed9b43b189c39549d8165a020aee9b6/lto-plugin%2Flto-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cd0b7167ed9b43b189c39549d8165a020aee9b6/lto-plugin%2Flto-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2Flto-plugin.h?ref=1cd0b7167ed9b43b189c39549d8165a020aee9b6", "patch": "@@ -0,0 +1,84 @@\n+/* Common declarations for LTO plugin for gold and/or GNU ld.\n+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+   Contributed by Rafael Avila de Espindola (espindola@google.com).\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+This program is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <stdbool.h>\n+#include \"plugin-api.h\"\n+\n+/* LTO magic section name.  */\n+\n+#define LTO_SECTION_PREFIX \".gnu.lto_.symtab\"\n+\n+/* The part of the symbol table the plugin has to keep track of. Note that we\n+   must keep SYMS until all_symbols_read is called to give the linker time to\n+   copy the symbol information. */\n+\n+struct sym_aux\n+{\n+  uint32_t slot;\n+  unsigned id;\n+  unsigned next_conflict;\n+};\n+\n+struct plugin_symtab\n+{\n+  int nsyms;\n+  struct sym_aux *aux;\n+  struct ld_plugin_symbol *syms;\n+  unsigned id;\n+};\n+\n+/* All that we have to remember about a file. */\n+\n+struct plugin_file_info\n+{\n+  char *name;\n+  void *handle;\n+  struct plugin_symtab symtab;\n+  struct plugin_symtab conflicts;\n+};\n+\n+/* These are the methods supplied by one of the object format\n+   dependent files lto-plugin-elf.c or lto-plugin-coff.c  */\n+\n+extern enum ld_plugin_status claim_file_handler \n+\t\t(const struct ld_plugin_input_file *file, int *claimed);\n+\n+extern enum ld_plugin_status onload_format_checks (struct ld_plugin_tv *tv);\n+\n+/* These methods are made available to the object format\n+   dependent files.  */\n+\n+extern void check (bool gate, enum ld_plugin_level level, const char *text);\n+\n+extern void translate (char *data, char *end, struct plugin_symtab *out);\n+\n+extern char *parse_table_entry (char *p, struct ld_plugin_symbol *entry,\n+\t\t\tstruct sym_aux *aux);\n+\n+extern void resolve_conflicts (struct plugin_symtab *t,\n+\t\t\tstruct plugin_symtab *conflicts);\n+\n+/* And this callback function is exposed.  */\n+\n+extern ld_plugin_add_symbols add_symbols;\n+\n+/* Along with these two variables.  */\n+\n+extern struct plugin_file_info *claimed_files;\n+extern unsigned int num_claimed_files;\n+"}]}