{"sha": "ef89d648b84b126fe6c15be5b09105bf705aa60a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY4OWQ2NDhiODRiMTI2ZmU2YzE1YmU1YjA5MTA1YmY3MDVhYTYwYQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@panix.com", "date": "2001-08-18T19:59:46Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-08-18T19:59:46Z"}, "message": "optabs.h (OTI_flodiv, [...]): Kill.\n\n\t* optabs.h (OTI_flodiv, flodiv_optab): Kill.\n\t* genopinit.c: Put floating point divide insns in sdiv_optab.\n\t* expr.c (expand_expr): Use sdiv_optab, not flodiv_optab.\n\t* config/gofast.h, config/c4x/c4x.h,\n\tconfig/ia64/hpux_longdouble.h, config/mips/mips.h,\n\tconfig/pa/long_double.h, config/rs6000/sysv4.h,\n\tconfig/sparc/sparc.h: Put floating point divide libcalls in sdiv_optab.\n\t* optabs.c (init_optab): Break into new_optab, init_optab, init_optabv.\n\t(init_optabs): Use init_optabv for overflow-trapping optabs.\n\tDon't init flodiv_optab.  Give mov_optab, movstrict_optab, and\n\tcmp_optab RTX codes so have_insn_for can find them.\n\n\t* optabs.c (expand_simple_binop, expand_simple_unop,\n\thave_insn_for, gen_sub3_insn): New interfaces.\n\t* expr.h: Prototype new functions.\n\t(enum optab_methods): Move here from optabs.h.\n\n\t* builtins.c, combine.c, doloop.c, function.c, ifcvt.c,\n\tloop.c, profile.c, simplify-rtx.c, stmt.c, unroll.c:\n\tUse new\tfunctions instead of working directly with optabs.\n\t* doloop.c, ifcvt.c, loop.c, profile.c, simplify-rtx.c,\n\tunroll.c: Don't include optabs.h.\n\t* caller-save.c, combine.c, function.c, stmt.c: Just include\n\tinsn-codes.h, not optabs.h.\n\t* Makefile.in: Update dependencies.\n\n\t* combine.c (make_compound_operation, simplify_comparison):\n\tFix typos testing for this or that instruction.\n\nFrom-SVN: r45008", "tree": {"sha": "f45f62817a1ba4ec89643d51d48fc4dea2c0237b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f45f62817a1ba4ec89643d51d48fc4dea2c0237b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef89d648b84b126fe6c15be5b09105bf705aa60a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef89d648b84b126fe6c15be5b09105bf705aa60a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef89d648b84b126fe6c15be5b09105bf705aa60a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef89d648b84b126fe6c15be5b09105bf705aa60a/comments", "author": {"login": "zackw", "id": 325899, "node_id": "MDQ6VXNlcjMyNTg5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/325899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackw", "html_url": "https://github.com/zackw", "followers_url": "https://api.github.com/users/zackw/followers", "following_url": "https://api.github.com/users/zackw/following{/other_user}", "gists_url": "https://api.github.com/users/zackw/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackw/subscriptions", "organizations_url": "https://api.github.com/users/zackw/orgs", "repos_url": "https://api.github.com/users/zackw/repos", "events_url": "https://api.github.com/users/zackw/events{/privacy}", "received_events_url": "https://api.github.com/users/zackw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8d36d7229213f91138844f0e710e68c185774aea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d36d7229213f91138844f0e710e68c185774aea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d36d7229213f91138844f0e710e68c185774aea"}], "stats": {"total": 511, "additions": 311, "deletions": 200}, "files": [{"sha": "2a9ca2ff2e226f12ce44ccb4eeb3289759f7ebfd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -1,3 +1,34 @@\n+2001-08-18  Zack Weinberg  <zackw@panix.com>\n+\n+\t* optabs.h (OTI_flodiv, flodiv_optab): Kill.\n+\t* genopinit.c: Put floating point divide insns in sdiv_optab.\n+\t* expr.c (expand_expr): Use sdiv_optab, not flodiv_optab.\n+\t* config/gofast.h, config/c4x/c4x.h,\n+\tconfig/ia64/hpux_longdouble.h, config/mips/mips.h,\n+\tconfig/pa/long_double.h, config/rs6000/sysv4.h,\n+\tconfig/sparc/sparc.h: Put floating point divide libcalls in sdiv_optab.\n+\t* optabs.c (init_optab): Break into new_optab, init_optab, init_optabv.\n+\t(init_optabs): Use init_optabv for overflow-trapping optabs.\n+\tDon't init flodiv_optab.  Give mov_optab, movstrict_optab, and\n+\tcmp_optab RTX codes so have_insn_for can find them.\n+\n+\t* optabs.c (expand_simple_binop, expand_simple_unop,\n+\thave_insn_for, gen_sub3_insn): New interfaces.\n+\t* expr.h: Prototype new functions.\n+\t(enum optab_methods): Move here from optabs.h.\n+\n+\t* builtins.c, combine.c, doloop.c, function.c, ifcvt.c,\n+\tloop.c, profile.c, simplify-rtx.c, stmt.c, unroll.c:\n+\tUse new\tfunctions instead of working directly with optabs.\n+\t* doloop.c, ifcvt.c, loop.c, profile.c, simplify-rtx.c,\n+\tunroll.c: Don't include optabs.h.\n+\t* caller-save.c, combine.c, function.c, stmt.c: Just include\n+\tinsn-codes.h, not optabs.h.\n+\t* Makefile.in: Update dependencies.\n+\n+\t* combine.c (make_compound_operation, simplify_comparison):\n+\tFix typos testing for this or that instruction.\n+\n 2001-08-18  Herman A.J. ten Brugge  <Haj.Ten.Brugge@net.HCC.nl>\n \n \t* mklibgcc.in: Prefer LIB1ASMFUNCS over LIB2_DIVMOD_FUNCS when"}, {"sha": "aa9f7ad4df6405c1bc7d9bb3840936259c9121d8", "filename": "gcc/Makefile.in", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -1380,10 +1380,10 @@ varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) flags.h \\\n    output.h c-pragma.h toplev.h xcoffout.h debug.h $(GGC_H) $(TM_P_H) \\\n    $(HASHTAB_H) $(TARGET_H)\n function.o : function.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n-   function.h $(EXPR_H) $(OPTABS_H) libfuncs.h $(REGS_H) hard-reg-set.h \\\n+   function.h insn-codes.h $(EXPR_H) libfuncs.h $(REGS_H) hard-reg-set.h \\\n    insn-config.h $(RECOG_H) output.h toplev.h except.h hash.h $(GGC_H) $(TM_P_H)\n stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h function.h  \\\n-   insn-config.h hard-reg-set.h $(EXPR_H) $(OPTABS_H) libfuncs.h except.h \\\n+   insn-config.h insn-codes.h hard-reg-set.h $(EXPR_H) libfuncs.h except.h \\\n    $(LOOP_H) $(RECOG_H) toplev.h output.h varray.h $(GGC_H) $(TM_P_H)\n except.o : except.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    except.h function.h $(EXPR_H) libfuncs.h integrate.h \\\n@@ -1442,7 +1442,7 @@ jump.o : jump.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h hard-reg-set.h $(REGS_H\n \n simplify-rtx.o : simplify-rtx.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n-   $(OPTABS_H) output.h function.h $(GGC_H) $(OBSTACK_H) $(TM_P_H)\n+   output.h function.h $(GGC_H) $(OBSTACK_H) $(TM_P_H)\n cselib.o : cselib.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n    output.h function.h cselib.h $(GGC_H) $(OBSTACK_H) $(TM_P_H)\n@@ -1473,24 +1473,24 @@ df.o : df.c $(CONFIG_H) system.h $(RTL_H) insn-config.h $(RECOG_H) \\\n conflict.o : conflict.c $(CONFIG_H) $(SYSTEM_H) $(OBSTACK_H) $(HASHTAB_H) \\\n    $(RTL_H) hard-reg-set.h $(BASIC_BLOCK_H)\n profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n-   insn-config.h output.h $(REGS_H) $(EXPR_H) $(OPTABS_H) function.h \\\n+   insn-config.h output.h $(REGS_H) $(EXPR_H) function.h \\\n    gcov-io.h toplev.h $(GGC_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TARGET_H)\n loop.o : loop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h $(LOOP_H) \\\n    insn-config.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) \\\n-   $(OPTABS_H) real.h $(PREDICT_H) $(BASIC_BLOCK_H) function.h \\\n+   real.h $(PREDICT_H) $(BASIC_BLOCK_H) function.h \\\n    toplev.h varray.h except.h cselib.h $(TM_P_H)\n doloop.o : doloop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h $(LOOP_H) \\\n-   $(EXPR_H) $(OPTABS_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H) toplev.h\n+   $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H) toplev.h\n unroll.o : unroll.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) insn-config.h function.h \\\n    $(INTEGRATE_H) $(REGS_H) $(RECOG_H) flags.h $(EXPR_H) $(LOOP_H) toplev.h \\\n-   hard-reg-set.h varray.h $(BASIC_BLOCK_H) $(TM_P_H) $(PREDICT_H) $(OPTABS_H)\n+   hard-reg-set.h varray.h $(BASIC_BLOCK_H) $(TM_P_H) $(PREDICT_H)\n flow.o : flow.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n    function.h except.h $(EXPR_H) ssa.h $(GGC_H) $(TM_P_H)\n dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) hard-reg-set.h \\\n    $(BASIC_BLOCK_H)\n combine.o : combine.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h function.h \\\n-   insn-config.h $(INSN_ATTR_H) $(OPTABS_H) $(REGS_H) $(EXPR_H) \\\n+   insn-config.h insn-codes.h $(INSN_ATTR_H) $(REGS_H) $(EXPR_H) \\\n    $(BASIC_BLOCK_H) $(RECOG_H) real.h hard-reg-set.h toplev.h $(TM_P_H)\n regclass.o : regclass.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) hard-reg-set.h flags.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) insn-config.h $(RECOG_H) reload.h real.h \\\n@@ -1515,7 +1515,7 @@ reload1.o : reload1.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) real.h flags.h \\\n    except.h\n caller-save.o : caller-save.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h \\\n    $(REGS_H) hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) function.h \\\n-   $(RECOG_H) reload.h $(EXPR_H) $(OPTABS_H) toplev.h $(TM_P_H)\n+   $(RECOG_H) reload.h $(EXPR_H) insn-codes.h toplev.h $(TM_P_H)\n reorg.o : reorg.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) conditions.h hard-reg-set.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) insn-config.h $(INSN_ATTR_H) \\\n    $(RECOG_H) function.h flags.h output.h $(EXPR_H) toplev.h $(PARAMS_H) $(TM_P_H)\n@@ -1562,7 +1562,7 @@ regrename.o : regrename.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) insn-config.h \\\n    resource.h $(OBSTACK_H) flags.h $(TM_P_H)\n ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(REGS_H) toplev.h \\\n    flags.h insn-config.h function.h $(RECOG_H) $(BASIC_BLOCK_H) $(EXPR_H) \\\n-   $(OPTABS_H) output.h $(TM_P_H)\n+   output.h $(TM_P_H)\n dependence.o : dependence.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) \\\n    $(C_COMMON_H) flags.h varray.h $(EXPR_H)\n params.o : params.c $(CONFIG_H) $(SYSTEM_H) $(PARAMS_H) toplev.h"}, {"sha": "b2f4a6bf73721d49e1a9f01e3fb41ccb01b78e71", "filename": "gcc/builtins.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -844,8 +844,7 @@ apply_args_size ()\n \t\t   mode != VOIDmode;\n \t\t   mode = GET_MODE_WIDER_MODE (mode))\n \t\tif (HARD_REGNO_MODE_OK (regno, mode)\n-\t\t    && (mov_optab->handlers[(int) mode].insn_code\n-\t\t\t!= CODE_FOR_nothing))\n+\t\t    && have_insn_for (SET, mode))\n \t\t  best_mode = mode;\n \n \t    mode = best_mode;\n@@ -901,8 +900,7 @@ apply_result_size ()\n \t\t   mode != VOIDmode;\n \t\t   mode = GET_MODE_WIDER_MODE (mode))\n \t\tif (HARD_REGNO_MODE_OK (regno, mode)\n-\t\t    && (mov_optab->handlers[(int) mode].insn_code\n-\t\t\t!= CODE_FOR_nothing))\n+\t\t    && have_insn_for (SET, mode))\n \t\t  best_mode = mode;\n \n \t    mode = best_mode;\n@@ -1072,8 +1070,8 @@ expand_builtin_apply (function, arguments, argsize)\n   emit_move_insn (incoming_args,\n \t\t  gen_rtx_MEM (Pmode, arguments));\n #ifndef STACK_GROWS_DOWNWARD\n-  incoming_args = expand_binop (Pmode, sub_optab, incoming_args, argsize,\n-\t\t\t\tincoming_args, 0, OPTAB_LIB_WIDEN);\n+  incoming_args = expand_simple_binop (Pmode, MINUS, incoming_args, argsize,\n+\t\t\t\t       incoming_args, 0, OPTAB_LIB_WIDEN);\n #endif\n \n   /* Perform postincrements before actually calling the function.  */"}, {"sha": "2cf2cf0ff835a26e32e9f4580ba3fa4057ae8db1", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -31,7 +31,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"reload.h\"\n #include \"function.h\"\n #include \"expr.h\"\n-#include \"optabs.h\"\n+#include \"insn-codes.h\"\n #include \"toplev.h\"\n #include \"tm_p.h\"\n "}, {"sha": "b45339661fb3f9eef9595efb097f5ec77bd90972", "filename": "gcc/combine.c", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -83,10 +83,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"insn-config.h\"\n+#include \"insn-codes.h\"\n #include \"function.h\"\n /* Include expr.h after insn-config.h so we get HAVE_conditional_move.  */\n #include \"expr.h\"\n-#include \"optabs.h\"\n #include \"insn-attr.h\"\n #include \"recog.h\"\n #include \"real.h\"\n@@ -5882,8 +5882,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t   && GET_CODE (inner) != MEM\n \t   && (! in_dest\n \t       || (GET_CODE (inner) == REG\n-\t\t   && (movstrict_optab->handlers[(int) tmode].insn_code\n-\t\t       != CODE_FOR_nothing))))\n+\t\t   && have_insn_for (STRICT_LOW_PART, tmode))))\n \t  || (GET_CODE (inner) == MEM && pos_rtx == 0\n \t      && (pos\n \t\t  % (STRICT_ALIGNMENT ? GET_MODE_ALIGNMENT (tmode)\n@@ -6383,10 +6382,9 @@ make_compound_operation (x, in_code)\n       /* On machines without logical shifts, if the operand of the AND is\n \t a logical shift and our mask turns off all the propagated sign\n \t bits, we can replace the logical shift with an arithmetic shift.  */\n-      else if (ashr_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing\n-\t       && (lshr_optab->handlers[(int) mode].insn_code\n-\t\t   == CODE_FOR_nothing)\n-\t       && GET_CODE (XEXP (x, 0)) == LSHIFTRT\n+      else if (GET_CODE (XEXP (x, 0)) == LSHIFTRT\n+\t       && !have_insn_for (LSHIFTRT, mode)\n+\t       && have_insn_for (ASHIFTRT, mode)\n \t       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n \t       && INTVAL (XEXP (XEXP (x, 0), 1)) >= 0\n \t       && INTVAL (XEXP (XEXP (x, 0), 1)) < HOST_BITS_PER_WIDE_INT\n@@ -6427,8 +6425,8 @@ make_compound_operation (x, in_code)\n     case LSHIFTRT:\n       /* If the sign bit is known to be zero, replace this with an\n \t arithmetic shift.  */\n-      if (ashr_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing\n-\t  && lshr_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing\n+      if (have_insn_for (ASHIFTRT, mode)\n+\t  && ! have_insn_for (LSHIFTRT, mode)\n \t  && mode_width <= HOST_BITS_PER_WIDE_INT\n \t  && (nonzero_bits (XEXP (x, 0), mode) & (1 << (mode_width - 1))) == 0)\n \t{\n@@ -6611,9 +6609,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n      that the operation is valid in MODE, in which case we do the operation\n      in MODE.  */\n   op_mode = ((GET_MODE_CLASS (mode) == GET_MODE_CLASS (GET_MODE (x))\n-\t      && code_to_optab[(int) code] != 0\n-\t      && (code_to_optab[(int) code]->handlers[(int) mode].insn_code\n-\t\t  != CODE_FOR_nothing))\n+\t      && have_insn_for (code, mode))\n \t     ? mode : GET_MODE (x));\n \n   /* It is not valid to do a right-shift in a narrower mode\n@@ -10893,12 +10889,12 @@ simplify_comparison (code, pop0, pop1)\n   mode = GET_MODE (op0);\n   if (mode != VOIDmode && GET_MODE_CLASS (mode) == MODE_INT\n       && GET_MODE_SIZE (mode) < UNITS_PER_WORD\n-      && cmp_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing)\n+      && ! have_insn_for (COMPARE, mode))\n     for (tmode = GET_MODE_WIDER_MODE (mode);\n \t (tmode != VOIDmode\n \t  && GET_MODE_BITSIZE (tmode) <= HOST_BITS_PER_WIDE_INT);\n \t tmode = GET_MODE_WIDER_MODE (tmode))\n-      if (cmp_optab->handlers[(int) tmode].insn_code != CODE_FOR_nothing)\n+      if (have_insn_for (COMPARE, tmode))\n \t{\n \t  /* If the only nonzero bits in OP0 and OP1 are those in the\n \t     narrower mode and this is an equality or unsigned comparison,\n@@ -10916,8 +10912,7 @@ simplify_comparison (code, pop0, pop1)\n \t      /* If OP0 is an AND and we don't have an AND in MODE either,\n \t\t make a new AND in the proper mode.  */\n \t      if (GET_CODE (op0) == AND\n-\t\t  && (add_optab->handlers[(int) mode].insn_code\n-\t\t      == CODE_FOR_nothing))\n+\t\t  && !have_insn_for (AND, mode))\n \t\top0 = gen_binary (AND, tmode,\n \t\t\t\t  gen_lowpart_for_combine (tmode,\n \t\t\t\t\t\t\t   XEXP (op0, 0)),"}, {"sha": "e2c483dc54bd1bb3da279dc6abe6fe45ef2c8fe9", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -1502,11 +1502,11 @@ CUMULATIVE_ARGS;\n       = init_one_libfunc (MODQI3_LIBCALL);\t\t\\\n     umod_optab->handlers[(int) QImode].libfunc\t\t\\\n       = init_one_libfunc (UMODQI3_LIBCALL);\t\t\\\n-    flodiv_optab->handlers[(int) QFmode].libfunc\t\\\n+    sdiv_optab->handlers[(int) QFmode].libfunc\t\t\\\n       = init_one_libfunc (DIVQF3_LIBCALL);\t\t\\\n     smul_optab->handlers[(int) HFmode].libfunc\t\t\\\n       = init_one_libfunc (MULHF3_LIBCALL);\t\t\\\n-    flodiv_optab->handlers[(int) HFmode].libfunc\t\\\n+    sdiv_optab->handlers[(int) HFmode].libfunc\t\t\\\n       = init_one_libfunc (DIVHF3_LIBCALL);\t\t\\\n     smul_optab->handlers[(int) HImode].libfunc\t\t\\\n       = init_one_libfunc (MULHI3_LIBCALL);\t\t\\"}, {"sha": "4c3c0ea9ae8cd9bcae21895c4fa96b77ceb94e8d", "filename": "gcc/config/gofast.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fconfig%2Fgofast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fconfig%2Fgofast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgofast.h?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -50,8 +50,8 @@ Boston, MA 02111-1307, USA.  */\n   sub_optab->handlers[(int) DFmode].libfunc = init_one_libfunc (\"dpsub\"); \\\n   smul_optab->handlers[(int) SFmode].libfunc = init_one_libfunc (\"fpmul\"); \\\n   smul_optab->handlers[(int) DFmode].libfunc = init_one_libfunc (\"dpmul\"); \\\n-  flodiv_optab->handlers[(int) SFmode].libfunc = init_one_libfunc (\"fpdiv\"); \\\n-  flodiv_optab->handlers[(int) DFmode].libfunc = init_one_libfunc (\"dpdiv\"); \\\n+  sdiv_optab->handlers[(int) SFmode].libfunc = init_one_libfunc (\"fpdiv\"); \\\n+  sdiv_optab->handlers[(int) DFmode].libfunc = init_one_libfunc (\"dpdiv\"); \\\n   cmp_optab->handlers[(int) SFmode].libfunc = init_one_libfunc (\"fpcmp\"); \\\n   cmp_optab->handlers[(int) DFmode].libfunc = init_one_libfunc (\"dpcmp\"); \\\n \\"}, {"sha": "bfc12d4fc70b773f78f57373e75c58e9c52907a9", "filename": "gcc/config/ia64/hpux_longdouble.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fconfig%2Fia64%2Fhpux_longdouble.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fconfig%2Fia64%2Fhpux_longdouble.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fhpux_longdouble.h?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -59,7 +59,7 @@ Boston, MA 02111-1307, USA.  */\n       = gen_rtx_SYMBOL_REF (Pmode, SUBTF3_LIBCALL);\t\t\t\\\n     smul_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n       = gen_rtx_SYMBOL_REF (Pmode, MULTF3_LIBCALL);\t\t\t\\\n-    flodiv_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n+    sdiv_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n       = gen_rtx_SYMBOL_REF (Pmode, DIVTF3_LIBCALL);\t\t\t\\\n     smin_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n       = gen_rtx_SYMBOL_REF (Pmode, SMINTF3_LIBCALL);\t\t\t\\"}, {"sha": "a3500eed39ef2cdb368e684fc51b51347bd8a2fb", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -4572,7 +4572,7 @@ do\t\t\t\t\t\t\t\t\t\\\n \t  init_one_libfunc (\"__mips16_subsf3\");\t\t\t\t\\\n \tsmul_optab->handlers[(int) SFmode].libfunc =\t\t\t\\\n \t  init_one_libfunc (\"__mips16_mulsf3\");\t\t\t\t\\\n-\tflodiv_optab->handlers[(int) SFmode].libfunc =\t\t\t\\\n+\tsdiv_optab->handlers[(int) SFmode].libfunc =\t\t\t\\\n \t  init_one_libfunc (\"__mips16_divsf3\");\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \teqsf2_libfunc = init_one_libfunc (\"__mips16_eqsf2\");\t\t\\\n@@ -4595,7 +4595,7 @@ do\t\t\t\t\t\t\t\t\t\\\n \t      init_one_libfunc (\"__mips16_subdf3\");\t\t\t\\\n \t    smul_optab->handlers[(int) DFmode].libfunc =\t\t\\\n \t      init_one_libfunc (\"__mips16_muldf3\");\t\t\t\\\n-\t    flodiv_optab->handlers[(int) DFmode].libfunc =\t\t\\\n+\t    sdiv_optab->handlers[(int) DFmode].libfunc =\t\t\\\n \t      init_one_libfunc (\"__mips16_divdf3\");\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t    extendsfdf2_libfunc =\t\t\t\t\t\\"}, {"sha": "fa7a71054bab7aeb1c0135894b5bc76a26a3197d", "filename": "gcc/config/pa/long_double.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fconfig%2Fpa%2Flong_double.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fconfig%2Fpa%2Flong_double.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Flong_double.h?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -70,7 +70,7 @@ do { long value[4];                                                     \\\n       = gen_rtx_SYMBOL_REF (Pmode, SUBTF3_LIBCALL);\t\t\t\\\n     smul_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n       = gen_rtx_SYMBOL_REF (Pmode, MULTF3_LIBCALL);\t\t\t\\\n-    flodiv_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n+    sdiv_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n       = gen_rtx_SYMBOL_REF (Pmode, DIVTF3_LIBCALL);\t\t\t\\\n     smin_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n       = gen_rtx_SYMBOL_REF (Pmode, SMINTF3_LIBCALL);\t\t\t\\"}, {"sha": "b8158ccf15bba91d520042518e49207d4bbcd2eb", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -1518,7 +1518,7 @@ ncrtn.o%s\"\n \t  = init_one_libfunc (NEGTF2_LIBCALL);\t\t\t\t\\\n \tsmul_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n \t  = init_one_libfunc (MULTF3_LIBCALL);\t\t\t\t\\\n-\tflodiv_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n+\tsdiv_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n \t  = init_one_libfunc (DIVTF3_LIBCALL);\t\t\t\t\\\n \teqtf2_libfunc = init_one_libfunc (EQTF2_LIBCALL);\t\t\\\n \tnetf2_libfunc = init_one_libfunc (NETF2_LIBCALL);\t\t\\"}, {"sha": "e24b0f99472885721cca48ac22f3de2a106be0c2", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -2771,7 +2771,7 @@ do {                                                                    \\\n \t  = init_one_libfunc (NEGTF2_LIBCALL);\t\t\t\t\\\n \tsmul_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n \t  = init_one_libfunc (MULTF3_LIBCALL);\t\t\t\t\\\n-\tflodiv_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n+\tsdiv_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n \t  = init_one_libfunc (DIVTF3_LIBCALL);\t\t\t\t\\\n \teqtf2_libfunc = init_one_libfunc (EQTF2_LIBCALL);\t\t\\\n \tnetf2_libfunc = init_one_libfunc (NETF2_LIBCALL);\t\t\\"}, {"sha": "289da282fb992d8ace27ab62e84e6dc4dc392c63", "filename": "gcc/doloop.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fdoloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fdoloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoloop.c?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -24,7 +24,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"flags.h\"\n #include \"expr.h\"\n-#include \"optabs.h\"\n #include \"loop.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n@@ -469,9 +468,9 @@ doloop_modify (loop, iterations, iterations_max,\n       if (GET_CODE (count) == CONST_INT)\n \tcount = GEN_INT (INTVAL (count) - 1);\n       else\n-\tcount = expand_binop (GET_MODE (counter_reg), sub_optab,\n-\t\t\t      count, GEN_INT (1),\n-\t\t\t      0, 0, OPTAB_LIB_WIDEN);\n+\tcount = expand_simple_binop (GET_MODE (counter_reg), MINUS,\n+\t\t\t\t     count, GEN_INT (1),\n+\t\t\t\t     0, 0, OPTAB_LIB_WIDEN);\n     }\n \n   /* Insert initialization of the count register into the loop header.  */\n@@ -592,10 +591,10 @@ doloop_modify_runtime (loop, iterations_max,\n \n   start_sequence ();\n   /* abs (final - initial)  */\n-  diff = expand_binop (mode, sub_optab,\n-\t\t       copy_rtx (neg_inc ? initial_value : final_value),\n-\t\t       copy_rtx (neg_inc ? final_value : initial_value),\n-\t\t       NULL_RTX, unsigned_p, OPTAB_LIB_WIDEN);\n+  diff = expand_simple_binop (mode, MINUS,\n+\t\t\t      copy_rtx (neg_inc ? initial_value : final_value),\n+\t\t\t      copy_rtx (neg_inc ? final_value : initial_value),\n+\t\t\t      NULL_RTX, unsigned_p, OPTAB_LIB_WIDEN);\n \n   if (abs_inc * loop_info->unroll_number != 1)\n     {\n@@ -609,18 +608,18 @@ doloop_modify_runtime (loop, iterations_max,\n \tabort ();\n \n       /* abs (final - initial) / (abs_inc * unroll_number)  */\n-      iterations = expand_binop (GET_MODE (diff), lshr_optab,\n-\t\t\t\t diff, GEN_INT (shift_count),\n-\t\t\t\t NULL_RTX, 1,\n-\t\t\t\t OPTAB_LIB_WIDEN);\n+      iterations = expand_simple_binop (GET_MODE (diff), LSHIFTRT,\n+\t\t\t\t\tdiff, GEN_INT (shift_count),\n+\t\t\t\t\tNULL_RTX, 1,\n+\t\t\t\t\tOPTAB_LIB_WIDEN);\n \n       if (abs_inc != 1)\n \t{\n \t  /* abs (final - initial) % (abs_inc * unroll_number)  */\n-\t  extra = expand_binop (GET_MODE (iterations), and_optab,\n-\t\t\t\tdiff, GEN_INT (abs_inc * loop_info->unroll_number - 1),\n-\t\t\t\tNULL_RTX, 1,\n-\t\t\t\tOPTAB_LIB_WIDEN);\n+\t  rtx count = GEN_INT (abs_inc * loop_info->unroll_number - 1);\n+\t  extra = expand_simple_binop (GET_MODE (iterations), AND,\n+\t\t\t\t       diff, count, NULL_RTX, 1,\n+\t\t\t\t       OPTAB_LIB_WIDEN);\n \n \t  /* If (abs (final - initial) % (abs_inc * unroll_number)\n \t       <= abs_inc * (unroll - 1)),\n@@ -634,10 +633,10 @@ doloop_modify_runtime (loop, iterations_max,\n \t  LABEL_NUSES (label)++;\n \n \t  /* Increment the iteration count by one.  */\n-\t  iterations = expand_binop (GET_MODE (iterations), add_optab,\n-\t\t\t\t     iterations, GEN_INT (1),\n-\t\t\t\t     iterations, 1,\n-\t\t\t\t     OPTAB_LIB_WIDEN);\n+\t  iterations = expand_simple_binop (GET_MODE (iterations), PLUS,\n+\t\t\t\t\t    iterations, GEN_INT (1),\n+\t\t\t\t\t    iterations, 1,\n+\t\t\t\t\t    OPTAB_LIB_WIDEN);\n \n \t  emit_label (label);\n \t}"}, {"sha": "ed7f33fcf1f3c3c1a77e0150b254b2a6f30b01ee", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -7861,7 +7861,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t\t  build_real (type, dconst1),\n \t\t\t\t\t  TREE_OPERAND (exp, 1))),\n \t\t\t    target, tmode, unsignedp);\n-      this_optab = flodiv_optab;\n+      this_optab = sdiv_optab;\n       goto binop;\n \n     case TRUNC_MOD_EXPR:"}, {"sha": "2ea167ec3d6b0fe1aee292275209924e20b9d734", "filename": "gcc/expr.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -256,6 +256,34 @@ enum direction {none, upward, downward};  /* Value has this type.  */\n /* Functions from optabs.c, commonly used, and without need for the optabs\n    tables:  */\n \n+/* Passed to expand_simple_binop and expand_binop to say which options\n+   to try to use if the requested operation can't be open-coded on the\n+   requisite mode.  Either OPTAB_LIB or OPTAB_LIB_WIDEN says try using\n+   a library call.  Either OPTAB_WIDEN or OPTAB_LIB_WIDEN says try\n+   using a wider mode.  OPTAB_MUST_WIDEN says try widening and don't\n+   try anything else.  */\n+\n+enum optab_methods\n+{\n+  OPTAB_DIRECT,\n+  OPTAB_LIB,\n+  OPTAB_WIDEN,\n+  OPTAB_LIB_WIDEN,\n+  OPTAB_MUST_WIDEN\n+};\n+\n+/* Generate code for a simple binary or unary operation.  \"Simple\" in\n+   this case means \"can be unambiguously described by a (mode, code)\n+   pair and mapped to a single optab.\"  */\n+extern rtx expand_simple_binop PARAMS ((enum machine_mode, enum rtx_code, rtx,\n+\t\t\t\t\trtx, rtx, int, enum optab_methods));\n+extern rtx expand_simple_unop PARAMS ((enum machine_mode, enum rtx_code,\n+\t\t\t\t       rtx, rtx, int));\n+\n+/* Report whether the machine description contains an insn which can\n+   perform the operation described by CODE and MODE.  */\n+extern int have_insn_for PARAMS ((enum rtx_code, enum machine_mode));\n+\n /* Emit code to make a call to a constant function or a library call. */\n extern void emit_libcall_block PARAMS ((rtx, rtx, rtx, rtx));\n \n@@ -266,6 +294,7 @@ extern void emit_libcall_block PARAMS ((rtx, rtx, rtx, rtx));\n extern rtx gen_add2_insn PARAMS ((rtx, rtx));\n extern rtx gen_add3_insn PARAMS ((rtx, rtx, rtx));\n extern rtx gen_sub2_insn PARAMS ((rtx, rtx));\n+extern rtx gen_sub3_insn PARAMS ((rtx, rtx, rtx));\n extern rtx gen_move_insn PARAMS ((rtx, rtx));\n extern int have_add2_insn PARAMS ((rtx, rtx));\n extern int have_sub2_insn PARAMS ((rtx, rtx));"}, {"sha": "c2424fd0732a539f7e708348b5005fcc683ea200", "filename": "gcc/function.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -46,11 +46,11 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"function.h\"\n #include \"expr.h\"\n-#include \"optabs.h\"\n #include \"libfuncs.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n #include \"insn-config.h\"\n+#include \"insn-codes.h\"\n #include \"recog.h\"\n #include \"output.h\"\n #include \"basic-block.h\"\n@@ -5693,12 +5693,13 @@ round_trampoline_addr (tramp)\n #ifdef TRAMPOLINE_ALIGNMENT\n   /* Round address up to desired boundary.  */\n   rtx temp = gen_reg_rtx (Pmode);\n-  temp = expand_binop (Pmode, add_optab, tramp,\n-\t\t       GEN_INT (TRAMPOLINE_ALIGNMENT / BITS_PER_UNIT - 1),\n-\t\t       temp, 0, OPTAB_LIB_WIDEN);\n-  tramp = expand_binop (Pmode, and_optab, temp,\n-\t\t\tGEN_INT (-TRAMPOLINE_ALIGNMENT / BITS_PER_UNIT),\n-\t\t\ttemp, 0, OPTAB_LIB_WIDEN);\n+  rtx addend = GEN_INT (TRAMPOLINE_ALIGNMENT / BITS_PER_UNIT - 1);\n+  rtx mask = GEN_INT (-TRAMPOLINE_ALIGNMENT / BITS_PER_UNIT);\n+\n+  temp  = expand_simple_binop (Pmode, PLUS, tramp, addend,\n+\t\t\t       temp, 0, OPTAB_LIB_WIDEN);\n+  tramp = expand_simple_binop (Pmode, AND, temp, mask,\n+\t\t\t       temp, 0, OPTAB_LIB_WIDEN);\n #endif\n   return tramp;\n }\n@@ -6321,15 +6322,15 @@ expand_main_function ()\n       int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n       rtx tmp;\n \n-      /* Forcably align the stack.  */\n+      /* Forcibly align the stack.  */\n #ifdef STACK_GROWS_DOWNWARD\n-      tmp = expand_binop (Pmode, and_optab, stack_pointer_rtx,\n-\t\t\t  GEN_INT (-align), stack_pointer_rtx, 1, OPTAB_WIDEN);\n+      tmp = expand_simple_binop (Pmode, AND, stack_pointer_rtx, GEN_INT(-align),\n+\t\t\t\t stack_pointer_rtx, 1, OPTAB_WIDEN);\n #else\n-      tmp = expand_binop (Pmode, add_optab, stack_pointer_rtx,\n-\t\t\t  GEN_INT (align - 1), NULL_RTX, 1, OPTAB_WIDEN);\n-      tmp = expand_binop (Pmode, and_optab, tmp, GEN_INT (-align),\n-\t\t\t  stack_pointer_rtx, 1, OPTAB_WIDEN);\n+      tmp = expand_simple_binop (Pmode, PLUS, stack_pointer_rtx,\n+\t\t\t\t GEN_INT (align - 1), NULL_RTX, 1, OPTAB_WIDEN);\n+      tmp = expand_simple_binop (Pmode, AND, tmp, GEN_INT (-align),\n+\t\t\t\t stack_pointer_rtx, 1, OPTAB_WIDEN);\n #endif\n       if (tmp != stack_pointer_rtx)\n \temit_move_insn (stack_pointer_rtx, tmp);"}, {"sha": "43355611008edc9fb823f4de738500449fd2e9e2", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -81,14 +81,13 @@ const char * const optabs[] =\n   \"smul_highpart_optab->handlers[$A].insn_code = CODE_FOR_$(smul$a3_highpart$)\",\n   \"smul_widen_optab->handlers[$B].insn_code = CODE_FOR_$(mul$a$b3$)$N\",\n   \"umul_widen_optab->handlers[$B].insn_code = CODE_FOR_$(umul$a$b3$)$N\",\n-  \"sdiv_optab->handlers[$A].insn_code = CODE_FOR_$(div$I$a3$)\",\n+  \"sdiv_optab->handlers[$A].insn_code = CODE_FOR_$(div$a3$)\",\n   \"sdivv_optab->handlers[(int) $A].insn_code = CODE_FOR_$(div$V$I$a3$)\",\n   \"udiv_optab->handlers[$A].insn_code = CODE_FOR_$(udiv$I$a3$)\",\n   \"sdivmod_optab->handlers[$A].insn_code = CODE_FOR_$(divmod$a4$)\",\n   \"udivmod_optab->handlers[$A].insn_code = CODE_FOR_$(udivmod$a4$)\",\n   \"smod_optab->handlers[$A].insn_code = CODE_FOR_$(mod$a3$)\",\n   \"umod_optab->handlers[$A].insn_code = CODE_FOR_$(umod$a3$)\",\n-  \"flodiv_optab->handlers[$A].insn_code = CODE_FOR_$(div$F$a3$)\",\n   \"ftrunc_optab->handlers[$A].insn_code = CODE_FOR_$(ftrunc$F$a2$)\",\n   \"and_optab->handlers[$A].insn_code = CODE_FOR_$(and$a3$)\",\n   \"ior_optab->handlers[$A].insn_code = CODE_FOR_$(ior$a3$)\","}, {"sha": "a877a90da183bdb9494515afcd1db8931cff7f81", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -30,7 +30,6 @@\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"expr.h\"\n-#include \"optabs.h\"\n #include \"real.h\"\n #include \"output.h\"\n #include \"toplev.h\"\n@@ -698,42 +697,42 @@ noce_try_store_flag_constants (if_info)\n \t =>   x = 3 + (test == 0);  */\n       if (diff == STORE_FLAG_VALUE || diff == -STORE_FLAG_VALUE)\n \t{\n-\t  target = expand_binop (mode,\n-\t\t\t\t (diff == STORE_FLAG_VALUE\n-\t\t\t\t  ? add_optab : sub_optab),\n-\t\t\t\t GEN_INT (ifalse), target, if_info->x, 0,\n-\t\t\t\t OPTAB_WIDEN);\n+\t  target = expand_simple_binop (mode,\n+\t\t\t\t\t(diff == STORE_FLAG_VALUE\n+\t\t\t\t\t ? PLUS : MINUS),\n+\t\t\t\t\tGEN_INT (ifalse), target, if_info->x, 0,\n+\t\t\t\t\tOPTAB_WIDEN);\n \t}\n \n       /* if (test) x = 8; else x = 0;\n \t =>   x = (test != 0) << 3;  */\n       else if (ifalse == 0 && (tmp = exact_log2 (itrue)) >= 0)\n \t{\n-\t  target = expand_binop (mode, ashl_optab,\n-\t\t\t\t target, GEN_INT (tmp), if_info->x, 0,\n-\t\t\t\t OPTAB_WIDEN);\n+\t  target = expand_simple_binop (mode, ASHIFT,\n+\t\t\t\t\ttarget, GEN_INT (tmp), if_info->x, 0,\n+\t\t\t\t\tOPTAB_WIDEN);\n \t}\n \n       /* if (test) x = -1; else x = b;\n \t =>   x = -(test != 0) | b;  */\n       else if (itrue == -1)\n \t{\n-\t  target = expand_binop (mode, ior_optab,\n-\t\t\t\t target, GEN_INT (ifalse), if_info->x, 0,\n-\t\t\t\t OPTAB_WIDEN);\n+\t  target = expand_simple_binop (mode, IOR,\n+\t\t\t\t\ttarget, GEN_INT (ifalse), if_info->x, 0,\n+\t\t\t\t\tOPTAB_WIDEN);\n \t}\n \n       /* if (test) x = a; else x = b;\n \t =>   x = (-(test != 0) & (b - a)) + a;  */\n       else\n \t{\n-\t  target = expand_binop (mode, and_optab,\n-\t\t\t\t target, GEN_INT (diff), if_info->x, 0,\n-\t\t\t\t OPTAB_WIDEN);\n+\t  target = expand_simple_binop (mode, AND,\n+\t\t\t\t\ttarget, GEN_INT (diff), if_info->x, 0,\n+\t\t\t\t\tOPTAB_WIDEN);\n \t  if (target)\n-\t    target = expand_binop (mode, add_optab,\n-\t\t\t\t   target, GEN_INT (ifalse), if_info->x, 0,\n-\t\t\t\t   OPTAB_WIDEN);\n+\t    target = expand_simple_binop (mode, PLUS,\n+\t\t\t\t\t  target, GEN_INT (ifalse),\n+\t\t\t\t\t  if_info->x, 0, OPTAB_WIDEN);\n \t}\n \n       if (! target)\n@@ -796,9 +795,10 @@ noce_try_store_flag_inc (if_info)\n \t\t\t\t     1, normalize);\n \n       if (target)\n-\ttarget = expand_binop (GET_MODE (if_info->x),\n-\t\t\t       subtract ? sub_optab : add_optab,\n-\t\t\t       if_info->x, target, if_info->x, 0, OPTAB_WIDEN);\n+\ttarget = expand_simple_binop (GET_MODE (if_info->x),\n+\t\t\t\t      subtract ? MINUS : PLUS,\n+\t\t\t\t      if_info->x, target, if_info->x,\n+\t\t\t\t      0, OPTAB_WIDEN);\n       if (target)\n \t{\n \t  if (target != if_info->x)\n@@ -847,9 +847,9 @@ noce_try_store_flag_mask (if_info)\n \t\t\t\t     gen_reg_rtx (GET_MODE (if_info->x)),\n \t\t\t\t     reversep, -1);\n       if (target)\n-        target = expand_binop (GET_MODE (if_info->x), and_optab,\n-\t\t\t       if_info->x, target, if_info->x, 0,\n-\t\t\t       OPTAB_WIDEN);\n+        target = expand_simple_binop (GET_MODE (if_info->x), AND,\n+\t\t\t\t      if_info->x, target, if_info->x, 0,\n+\t\t\t\t      OPTAB_WIDEN);\n \n       if (target)\n \t{\n@@ -1283,9 +1283,8 @@ noce_try_minmax (if_info)\n      struct noce_if_info *if_info;\n { \n   rtx cond, earliest, target, seq;\n-  enum rtx_code code;\n+  enum rtx_code code, op;\n   int unsignedp;\n-  optab op;\n \n   /* ??? Can't guarantee that expand_binop won't create pseudos.  */\n   if (no_new_pseudos)\n@@ -1328,24 +1327,24 @@ noce_try_minmax (if_info)\n     case LE:\n     case UNLT:\n     case UNLE:\n-      op = smax_optab;\n+      op = SMAX;\n       unsignedp = 0;\n       break;\n     case GT:\n     case GE:\n     case UNGT:\n     case UNGE:\n-      op = smin_optab;\n+      op = SMIN;\n       unsignedp = 0;\n       break;\n     case LTU:\n     case LEU:\n-      op = umax_optab;\n+      op = UMAX;\n       unsignedp = 1;\n       break;\n     case GTU:\n     case GEU:\n-      op = umin_optab;\n+      op = UMIN;\n       unsignedp = 1;\n       break;\n     default:\n@@ -1354,8 +1353,9 @@ noce_try_minmax (if_info)\n \n   start_sequence ();\n \n-  target = expand_binop (GET_MODE (if_info->x), op, if_info->a, if_info->b,\n-\t\t\t if_info->x, unsignedp, OPTAB_WIDEN);\n+  target = expand_simple_binop (GET_MODE (if_info->x), op,\n+\t\t\t\tif_info->a, if_info->b,\n+\t\t\t\tif_info->x, unsignedp, OPTAB_WIDEN);\n   if (! target)\n     {\n       end_sequence ();\n@@ -1466,12 +1466,12 @@ noce_try_abs (if_info)\n \n   start_sequence ();\n \n-  target = expand_unop (GET_MODE (if_info->x), abs_optab, b, if_info->x, 0);\n+  target = expand_simple_unop (GET_MODE (if_info->x), ABS, b, if_info->x, 0);\n \n   /* ??? It's a quandry whether cmove would be better here, especially\n      for integers.  Perhaps combine will clean things up.  */\n   if (target && negate)\n-    target = expand_unop (GET_MODE (target), neg_optab, target, if_info->x, 0);\n+    target = expand_simple_unop (GET_MODE (target), NEG, target, if_info->x, 0);\n \n   if (! target)\n     {"}, {"sha": "a8bf9c7cbd0c6c85918fdd50b0fad503e06a0dca", "filename": "gcc/loop.c", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -41,7 +41,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"function.h\"\n #include \"expr.h\"\n-#include \"optabs.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"insn-config.h\"\n@@ -1952,8 +1951,8 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t\t  rtx tem;\n \n \t\t\t  start_sequence ();\n-\t\t\t  tem = expand_binop\n-\t\t\t    (GET_MODE (reg), and_optab, reg,\n+\t\t\t  tem = expand_simple_binop\n+\t\t\t    (GET_MODE (reg), AND, reg,\n \t\t\t     GEN_INT ((((HOST_WIDE_INT) 1\n \t\t\t\t\t<< GET_MODE_BITSIZE (m->savemode)))\n \t\t\t\t      - 1),\n@@ -7578,41 +7577,31 @@ check_dbra_loop (loop, insn_count)\n \t\t}\n \t      else if (GET_CODE (initial_value) == CONST_INT)\n \t\t{\n-\t\t  rtx offset = GEN_INT (-INTVAL (initial_value) - add_adjust);\n \t\t  enum machine_mode mode = GET_MODE (reg);\n-\t\t  enum insn_code icode\n-\t\t    = add_optab->handlers[(int) mode].insn_code;\n-\n-\t\t  if (! (*insn_data[icode].operand[0].predicate) (reg, mode)\n-\t\t      || ! ((*insn_data[icode].operand[1].predicate)\n-\t\t\t    (comparison_value, mode))\n-\t\t      || ! ((*insn_data[icode].operand[2].predicate)\n-\t\t\t    (offset, mode)))\n+\t\t  rtx offset = GEN_INT (-INTVAL (initial_value) - add_adjust);\n+\t\t  rtx add_insn = gen_add3_insn (reg, comparison_value, offset);\n+\n+\t\t  if (add_insn == 0)\n \t\t    return 0;\n+\n \t\t  start_value\n \t\t    = gen_rtx_PLUS (mode, comparison_value, offset);\n-\t\t  loop_insn_hoist (loop, (GEN_FCN (icode)\n-\t\t\t\t\t     (reg, comparison_value, offset)));\n+\t\t  loop_insn_hoist (loop, add_insn);\n \t\t  if (GET_CODE (comparison) == LE)\n \t\t    final_value = gen_rtx_PLUS (mode, comparison_value,\n \t\t\t\t\t\tGEN_INT (add_val));\n \t\t}\n \t      else if (! add_adjust)\n \t\t{\n \t\t  enum machine_mode mode = GET_MODE (reg);\n-\t\t  enum insn_code icode\n-\t\t    = sub_optab->handlers[(int) mode].insn_code;\n-\t\t  if (! (*insn_data[icode].operand[0].predicate) (reg, mode)\n-\t\t      || ! ((*insn_data[icode].operand[1].predicate)\n-\t\t\t    (comparison_value, mode))\n-\t\t      || ! ((*insn_data[icode].operand[2].predicate)\n-\t\t\t    (initial_value, mode)))\n+\t\t  rtx sub_insn = gen_sub3_insn (reg, comparison_value,\n+\t\t\t\t\t\tinitial_value);\n+\n+\t\t  if (sub_insn == 0)\n \t\t    return 0;\n \t\t  start_value\n \t\t    = gen_rtx_MINUS (mode, comparison_value, initial_value);\n-\t\t  loop_insn_hoist (loop, (GEN_FCN (icode)\n-\t\t\t\t\t     (reg, comparison_value,\n-\t\t\t\t\t      initial_value)));\n+\t\t  loop_insn_hoist (loop, sub_insn);\n \t\t}\n \t      else\n \t\t/* We could handle the other cases too, but it'll be"}, {"sha": "1afff42c51f2ad50f4c68a748c6e45a210fa223c", "filename": "gcc/optabs.c", "status": "modified", "additions": 110, "deletions": 17, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -101,7 +101,9 @@ static enum insn_code can_fix_p\tPARAMS ((enum machine_mode, enum machine_mode,\n static enum insn_code can_float_p PARAMS ((enum machine_mode, enum machine_mode,\n \t\t\t\t\t int));\n static rtx ftruncify\tPARAMS ((rtx));\n-static optab init_optab\tPARAMS ((enum rtx_code));\n+static optab new_optab\tPARAMS ((void));\n+static inline optab init_optab\tPARAMS ((enum rtx_code));\n+static inline optab init_optabv\tPARAMS ((enum rtx_code));\n static void init_libfuncs PARAMS ((optab, int, int, const char *, int));\n static void init_integral_libfuncs PARAMS ((optab, const char *, int));\n static void init_floating_libfuncs PARAMS ((optab, const char *, int));\n@@ -599,6 +601,25 @@ expand_cmplxdiv_wide (real0, real1, imag0, imag1, realr, imagr, submode,\n   return 1;\n }\n \f\n+/* Wrapper around expand_binop which takes an rtx code to specify\n+   the operation to perform, not an optab pointer.  All other\n+   arguments are the same.  */\n+rtx\n+expand_simple_binop (mode, code, op0, op1, target, unsignedp, methods)\n+     enum machine_mode mode;\n+     enum rtx_code code;\n+     rtx op0, op1;\n+     rtx target;\n+     int unsignedp;\n+     enum optab_methods methods;\n+{\n+  optab binop = code_to_optab [(int) code];\n+  if (binop == 0)\n+    abort ();\n+\n+  return expand_binop (mode, binop, op0, op1, target, unsignedp, methods);\n+}\n+\n /* Generate code to perform an operation specified by BINOPTAB\n    on operands OP0 and OP1, with result having machine-mode MODE.\n \n@@ -2014,6 +2035,24 @@ expand_twoval_binop (binoptab, op0, op1, targ0, targ1, unsignedp)\n   return 0;\n }\n \f\n+/* Wrapper around expand_unop which takes an rtx code to specify\n+   the operation to perform, not an optab pointer.  All other\n+   arguments are the same.  */\n+rtx\n+expand_simple_unop (mode, code, op0, target, unsignedp)\n+     enum machine_mode mode;\n+     enum rtx_code code;\n+     rtx op0;\n+     rtx target;\n+     int unsignedp;\n+{\n+  optab unop = code_to_optab [(int) code];\n+  if (unop == 0)\n+    abort ();\n+\n+  return expand_unop (mode, unop, op0, target, unsignedp);\n+}\n+\n /* Generate code to perform an operation specified by UNOPTAB\n    on operand OP0, with result having machine-mode MODE.\n \n@@ -3830,6 +3869,26 @@ gen_sub2_insn (x, y)\n   return (GEN_FCN (icode) (x, x, y));\n }\n \n+/* Generate and return an insn body to subtract r1 and c,\n+   storing the result in r0.  */\n+rtx\n+gen_sub3_insn (r0, r1, c)\n+     rtx r0, r1, c;\n+{\n+  int icode = (int) sub_optab->handlers[(int) GET_MODE (r0)].insn_code;\n+\n+    if (icode == CODE_FOR_nothing\n+      || ! ((*insn_data[icode].operand[0].predicate)\n+\t    (r0, insn_data[icode].operand[0].mode))\n+      || ! ((*insn_data[icode].operand[1].predicate)\n+\t    (r1, insn_data[icode].operand[1].mode))\n+      || ! ((*insn_data[icode].operand[2].predicate)\n+\t    (c, insn_data[icode].operand[2].mode)))\n+    return NULL_RTX;\n+\n+  return (GEN_FCN (icode) (r0, r1, c));\n+}\n+\n int\n have_sub2_insn (x, y)\n      rtx x, y;\n@@ -4495,22 +4554,53 @@ expand_fix (to, from, unsignedp)\n     }\n }\n \f\n-static optab\n-init_optab (code)\n+/* Report whether we have an instruction to perform the operation\n+   specified by CODE on operands of mode MODE.  */\n+int\n+have_insn_for (code, mode)\n      enum rtx_code code;\n+     enum machine_mode mode;\n+{\n+  return (code_to_optab[(int) code] != 0\n+\t  && (code_to_optab[(int) code]->handlers[(int) mode].insn_code\n+\t      != CODE_FOR_nothing));\n+}\n+\n+/* Create a blank optab.  */\n+static optab\n+new_optab ()\n {\n   int i;\n   optab op = (optab) xmalloc (sizeof (struct optab));\n-  op->code = code;\n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n     {\n       op->handlers[i].insn_code = CODE_FOR_nothing;\n       op->handlers[i].libfunc = 0;\n     }\n \n-  if (code != UNKNOWN)\n-    code_to_optab[(int) code] = op;\n+  return op;\n+}\n \n+/* Same, but fill in its code as CODE, and write it into the\n+   code_to_optab table.  */\n+static inline optab\n+init_optab (code)\n+     enum rtx_code code;\n+{\n+  optab op = new_optab ();\n+  op->code = code;\n+  code_to_optab[(int) code] = op;\n+  return op;\n+}\n+\n+/* Same, but fill in its code as CODE, and do _not_ write it into\n+   the code_to_optab table.  */\n+static inline optab\n+init_optabv (code)\n+     enum rtx_code code;\n+{\n+  optab op = new_optab ();\n+  op->code = code;\n   return op;\n }\n \n@@ -4656,23 +4746,22 @@ init_optabs ()\n #endif\n \n   add_optab = init_optab (PLUS);\n-  addv_optab = init_optab (PLUS);\n+  addv_optab = init_optabv (PLUS);\n   sub_optab = init_optab (MINUS);\n-  subv_optab = init_optab (MINUS);\n+  subv_optab = init_optabv (MINUS);\n   smul_optab = init_optab (MULT);\n-  smulv_optab = init_optab (MULT);\n+  smulv_optab = init_optabv (MULT);\n   smul_highpart_optab = init_optab (UNKNOWN);\n   umul_highpart_optab = init_optab (UNKNOWN);\n   smul_widen_optab = init_optab (UNKNOWN);\n   umul_widen_optab = init_optab (UNKNOWN);\n   sdiv_optab = init_optab (DIV);\n-  sdivv_optab = init_optab (DIV);\n+  sdivv_optab = init_optabv (DIV);\n   sdivmod_optab = init_optab (UNKNOWN);\n   udiv_optab = init_optab (UDIV);\n   udivmod_optab = init_optab (UNKNOWN);\n   smod_optab = init_optab (MOD);\n   umod_optab = init_optab (UMOD);\n-  flodiv_optab = init_optab (DIV);\n   ftrunc_optab = init_optab (UNKNOWN);\n   and_optab = init_optab (AND);\n   ior_optab = init_optab (IOR);\n@@ -4686,15 +4775,19 @@ init_optabs ()\n   smax_optab = init_optab (SMAX);\n   umin_optab = init_optab (UMIN);\n   umax_optab = init_optab (UMAX);\n-  mov_optab = init_optab (UNKNOWN);\n-  movstrict_optab = init_optab (UNKNOWN);\n-  cmp_optab = init_optab (UNKNOWN);\n+\n+  /* These three have codes assigned exclusively for the sake of\n+     have_insn_for.  */\n+  mov_optab = init_optab (SET);\n+  movstrict_optab = init_optab (STRICT_LOW_PART);\n+  cmp_optab = init_optab (COMPARE);\n+\n   ucmp_optab = init_optab (UNKNOWN);\n   tst_optab = init_optab (UNKNOWN);\n   neg_optab = init_optab (NEG);\n-  negv_optab = init_optab (NEG);\n+  negv_optab = init_optabv (NEG);\n   abs_optab = init_optab (ABS);\n-  absv_optab = init_optab (ABS);\n+  absv_optab = init_optabv (ABS);\n   one_cmpl_optab = init_optab (NOT);\n   ffs_optab = init_optab (FFS);\n   sqrt_optab = init_optab (SQRT);\n@@ -4741,13 +4834,13 @@ init_optabs ()\n   init_integral_libfuncs (smulv_optab, \"mulv\", '3');\n   init_floating_libfuncs (smulv_optab, \"mul\", '3');\n   init_integral_libfuncs (sdiv_optab, \"div\", '3');\n+  init_floating_libfuncs (sdiv_optab, \"div\", '3');\n   init_integral_libfuncs (sdivv_optab, \"divv\", '3');\n   init_integral_libfuncs (udiv_optab, \"udiv\", '3');\n   init_integral_libfuncs (sdivmod_optab, \"divmod\", '4');\n   init_integral_libfuncs (udivmod_optab, \"udivmod\", '4');\n   init_integral_libfuncs (smod_optab, \"mod\", '3');\n   init_integral_libfuncs (umod_optab, \"umod\", '3');\n-  init_floating_libfuncs (flodiv_optab, \"div\", '3');\n   init_floating_libfuncs (ftrunc_optab, \"ftrunc\", '2');\n   init_integral_libfuncs (and_optab, \"and\", '3');\n   init_integral_libfuncs (ior_optab, \"ior\", '3');"}, {"sha": "dea49d3057cf2ccdb9ebb33d62d9bfabf2e1cfc3", "filename": "gcc/optabs.h", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -79,8 +79,6 @@ enum optab_index\n   /* Signed remainder */\n   OTI_smod,\n   OTI_umod,\n-  /* Optab for floating divide. */\n-  OTI_flodiv,\n   /* Convert float to integer in float fmt */\n   OTI_ftrunc,\n \n@@ -173,7 +171,6 @@ extern optab optab_table[OTI_MAX];\n #define udivmod_optab (optab_table[OTI_udivmod])\n #define smod_optab (optab_table[OTI_smod])\n #define umod_optab (optab_table[OTI_umod])\n-#define flodiv_optab (optab_table[OTI_flodiv])\n #define ftrunc_optab (optab_table[OTI_ftrunc])\n #define and_optab (optab_table[OTI_and])\n #define ior_optab (optab_table[OTI_ior])\n@@ -229,21 +226,6 @@ extern enum insn_code reload_out_optab[NUM_MACHINE_MODES];\n /* Contains the optab used for each rtx code.  */\n extern optab code_to_optab[NUM_RTX_CODE + 1];\n \n-/* Passed to expand_binop and expand_unop to say which options to try to use\n-   if the requested operation can't be open-coded on the requisite mode.\n-   Either OPTAB_LIB or OPTAB_LIB_WIDEN says try using a library call.\n-   Either OPTAB_WIDEN or OPTAB_LIB_WIDEN says try using a wider mode.\n-   OPTAB_MUST_WIDEN says try widening and don't try anything else.  */\n-\n-enum optab_methods\n-{\n-  OPTAB_DIRECT,\n-  OPTAB_LIB,\n-  OPTAB_WIDEN,\n-  OPTAB_LIB_WIDEN,\n-  OPTAB_MUST_WIDEN\n-};\n-\n \f\n typedef rtx (*rtxfun) PARAMS ((rtx));\n "}, {"sha": "86a91a0a19313775b03a43b34696e2afccc7b282", "filename": "gcc/profile.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -42,7 +42,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"regs.h\"\n #include \"expr.h\"\n-#include \"optabs.h\"\n #include \"function.h\"\n #include \"toplev.h\"\n #include \"ggc.h\"\n@@ -1072,8 +1071,8 @@ gen_edge_profiler (edgeno)\n   tmp = plus_constant (tmp, GCOV_TYPE_SIZE / BITS_PER_UNIT * edgeno);\n   mem_ref = validize_mem (gen_rtx_MEM (mode, tmp));\n \n-  tmp = expand_binop (mode, add_optab, mem_ref, const1_rtx,\n-\t\t      mem_ref, 0, OPTAB_WIDEN);\n+  tmp = expand_simple_binop (mode, PLUS, mem_ref, const1_rtx,\n+\t\t\t     mem_ref, 0, OPTAB_WIDEN);\n \n   if (tmp != mem_ref)\n     emit_move_insn (copy_rtx (mem_ref), tmp);"}, {"sha": "3dd0ee583cbc9a43ec0b6af0ef0917c24c460526", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -33,7 +33,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"function.h\"\n #include \"expr.h\"\n-#include \"optabs.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n #include \"ggc.h\"\n@@ -2520,8 +2519,7 @@ simplify_subreg (outermode, op, innermode, byte)\n       /* Allow splitting of volatile memory references in case we don't\n          have instruction to move the whole thing.  */\n       && (! MEM_VOLATILE_P (op)\n-\t  || (mov_optab->handlers[(int) innermode].insn_code\n-\t      == CODE_FOR_nothing))\n+\t  || ! have_insn_for (SET, innermode))\n       && GET_MODE_SIZE (outermode) <= GET_MODE_SIZE (GET_MODE (op)))\n     return adjust_address_nv (op, outermode, byte);\n "}, {"sha": "5ef7ba90c7c88bcfb60d5e774f0aee388625d2ce", "filename": "gcc/stmt.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -43,8 +43,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"function.h\"\n #include \"insn-config.h\"\n+#include \"insn-codes.h\"\n #include \"expr.h\"\n-#include \"optabs.h\"\n #include \"libfuncs.h\"\n #include \"hard-reg-set.h\"\n #include \"obstack.h\"\n@@ -5326,14 +5326,12 @@ expand_end_case (orig_index)\n \t     generate the conversion.  */\n \n \t  if (GET_MODE_CLASS (GET_MODE (index)) == MODE_INT\n-\t      && (cmp_optab->handlers[(int) GET_MODE (index)].insn_code\n-\t\t  == CODE_FOR_nothing))\n+\t      && ! have_insn_for (COMPARE, GET_MODE (index)))\n \t    {\n \t      enum machine_mode wider_mode;\n \t      for (wider_mode = GET_MODE (index); wider_mode != VOIDmode;\n \t\t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n-\t\tif (cmp_optab->handlers[(int) wider_mode].insn_code\n-\t\t    != CODE_FOR_nothing)\n+\t\tif (have_insn_for (COMPARE, wider_mode))\n \t\t  {\n \t\t    index = convert_to_mode (wider_mode, index, unsignedp);\n \t\t    break;\n@@ -6345,13 +6343,14 @@ emit_case_nodes (index, node, default_label, index_type)\n \t      tree type = type_for_mode (mode, unsignedp);\n \t      tree low = build1 (CONVERT_EXPR, type, node->low);\n \t      tree high = build1 (CONVERT_EXPR, type, node->high);\n-\t      rtx new_index, new_bound;\n+\t      rtx low_rtx, new_index, new_bound;\n \n \t      /* Instead of doing two branches, emit one unsigned branch for\n \t\t (index-low) > (high-low).  */\n-\t      new_index = expand_binop (mode, sub_optab, index,\n-\t\t\t\t\texpand_expr (low, NULL_RTX, mode, 0),\n-\t\t\t\t        NULL_RTX, unsignedp, OPTAB_WIDEN);\n+\t      low_rtx = expand_expr (low, NULL_RTX, mode, 0);\n+\t      new_index = expand_simple_binop (mode, MINUS, index, low_rtx,\n+\t\t\t\t\t       NULL_RTX, unsignedp,\n+\t\t\t\t\t       OPTAB_WIDEN);\n \t      new_bound = expand_expr (fold (build (MINUS_EXPR, type,\n \t\t\t\t\t\t    high, low)),\n \t\t\t\t       NULL_RTX, mode, 0);"}, {"sha": "eb33988bedc4b8399d7a78df6cbcefcea5e822e9", "filename": "gcc/unroll.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef89d648b84b126fe6c15be5b09105bf705aa60a/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=ef89d648b84b126fe6c15be5b09105bf705aa60a", "patch": "@@ -163,7 +163,6 @@ enum unroll_types\n #include \"flags.h\"\n #include \"function.h\"\n #include \"expr.h\"\n-#include \"optabs.h\"\n #include \"loop.h\"\n #include \"toplev.h\"\n #include \"hard-reg-set.h\"\n@@ -936,15 +935,15 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n \t     We must copy the final and initial values here to avoid\n \t     improperly shared rtl.  */\n \n-\t  diff = expand_binop (mode, sub_optab, copy_rtx (final_value),\n-\t\t\t       copy_rtx (initial_value), NULL_RTX, 0,\n-\t\t\t       OPTAB_LIB_WIDEN);\n+\t  diff = expand_simple_binop (mode, MINUS, copy_rtx (final_value),\n+\t\t\t\t      copy_rtx (initial_value), NULL_RTX, 0,\n+\t\t\t\t      OPTAB_LIB_WIDEN);\n \n \t  /* Now calculate (diff % (unroll * abs (increment))) by using an\n \t     and instruction.  */\n-\t  diff = expand_binop (GET_MODE (diff), and_optab, diff,\n-\t\t\t       GEN_INT (unroll_number * abs_inc - 1),\n-\t\t\t       NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+\t  diff = expand_simple_binop (GET_MODE (diff), AND, diff,\n+\t\t\t\t      GEN_INT (unroll_number * abs_inc - 1),\n+\t\t\t\t      NULL_RTX, 0, OPTAB_LIB_WIDEN);\n \n \t  /* Now emit a sequence of branches to jump to the proper precond\n \t     loop entry point.  */\n@@ -2298,8 +2297,8 @@ emit_unrolled_add (dest_reg, src_reg, increment)\n {\n   rtx result;\n \n-  result = expand_binop (GET_MODE (dest_reg), add_optab, src_reg, increment,\n-\t\t\t dest_reg, 0, OPTAB_LIB_WIDEN);\n+  result = expand_simple_binop (GET_MODE (dest_reg), PLUS, src_reg, increment,\n+\t\t\t\tdest_reg, 0, OPTAB_LIB_WIDEN);\n \n   if (dest_reg != result)\n     emit_move_insn (dest_reg, result);\n@@ -3314,9 +3313,9 @@ final_giv_value (loop, v)\n \t\tif (biv->insn == insn)\n \t\t  {\n \t\t    start_sequence ();\n-\t\t    tem = expand_binop (GET_MODE (tem), sub_optab, tem,\n-\t\t\t\t\tbiv->add_val, NULL_RTX, 0,\n-\t\t\t\t\tOPTAB_LIB_WIDEN);\n+\t\t    tem = expand_simple_binop (GET_MODE (tem), MINUS, tem,\n+\t\t\t\t\t       biv->add_val, NULL_RTX, 0,\n+\t\t\t\t\t       OPTAB_LIB_WIDEN);\n \t\t    seq = gen_sequence ();\n \t\t    end_sequence ();\n \t\t    loop_insn_sink (loop, seq);"}]}