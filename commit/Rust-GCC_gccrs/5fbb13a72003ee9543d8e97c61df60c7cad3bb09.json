{"sha": "5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZiYjEzYTcyMDAzZWU5NTQzZDhlOTdjNjFkZjYwYzdjYWQzYmIwOQ==", "commit": {"author": {"name": "Kirill Yukhin", "email": "kirill.yukhin@gmail.com", "date": "2016-11-17T22:11:21Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2016-11-17T22:11:21Z"}, "message": "Enable AVX512_4FMAPS and AVX512_4VNNIW instructions\n\nThis requires additional patch for register allocator from Vladimir\nMakarov.\n\ngcc/\n\n2016-11-17  Kirill Yukhin  <kirill.yukhin@gmail.com>\n\t    Andrew Senkevich <andrew.senkevich@intel.com>\n\n\t* common/config/i386/i386-common.c\n\t(OPTION_MASK_ISA_AVX5124FMAPS_SET,\n\tOPTION_MASK_ISA_AVX5124FMAPS_UNSET,\n\tOPTION_MASK_ISA_AVX5124VNNIW_SET,\n\tOPTION_MASK_ISA_AVX5124VNNIW_UNSET): New.\n\t(ix86_handle_option): Handle OPT_mavx5124fmaps,\n\tOPT_mavx5124vnniw.\n\t* config.gcc: Add avx5124fmapsintrin.h, avx5124vnniwintrin.h.\n\t* config/i386/avx5124fmapsintrin.h: New file.\n\t* config/i386/avx5124vnniwintrin.h: Ditto.\n\t* config/i386/constraints.md (h): New constraint.\n\t* config/i386/cpuid.h: (bit_AVX5124VNNIW,\n\tbit_AVX5124FMAPS): New.\n\t* config/i386/driver-i386.c (host_detect_local_cpu):\n\tDetect avx5124fmaps, avx5124vnniw.\n\t* config/i386/i386-builtin-types.def: Add types\n\tV16SF_FTYPE_V16SF_V16SF_V16SF_V16SF_V16SF_PCV4SF_V16SF_UHI,\n\tV16SF_FTYPE_V16SF_V16SF_V16SF_V16SF_V16SF_PCV4SF,\n\tV4SF_FTYPE_V4SF_V4SF_V4SF_V4SF_V4SF_PCV4SF,\n\tV4SF_FTYPE_V4SF_V4SF_V4SF_V4SF_V4SF_PCV4SF_V4SF_UQI,\n\tV16SI_FTYPE_V16SI_V16SI_V16SI_V16SI_V16SI_PCV4SI,\n\tV16SI_FTYPE_V16SI_V16SI_V16SI_V16SI_V16SI_PCV4SI_V16SI_UHI.\n\t* config/i386/i386-builtin.def (__builtin_ia32_4fmaddps_mask,\n\t__builtin_ia32_4fmaddps, __builtin_ia32_4fmaddss,\n\t__builtin_ia32_4fmaddss_mask, __builtin_ia32_4fnmaddps_mask,\n\t__builtin_ia32_4fnmaddps, __builtin_ia32_4fnmaddss,\n\t__builtin_ia32_4fnmaddss_mask, __builtin_ia32_vp4dpwssd,\n\t__builtin_ia32_vp4dpwssd_mask, __builtin_ia32_vp4dpwssds,\n\t__builtin_ia32_vp4dpwssds_mask): New.\n\t* config/i386/i386-c.c (ix86_target_macros_internal):\n\tDefine __AVX5124FMAPS__, __AVX5124VNNIW__.\n\t* config/i386/i386-modes.def: Fixed comment typos, added new\n\tmodes (VECTOR_MODES (FLOAT, 256), VECTOR_MODE (INT, SI, 64)).\n\t* config/i386/i386.c (ix86_target_string): Add -mavx5124fmaps,\n\t-mavx5124vnniw.\n\t(PTA_AVX5124FMAPS, PTA_AVX5124VNNIW): Define.\n\t(ix86_option_override_internal): Handle new options.\n\t(ix86_valid_target_attribute_inner_p): Add avx5124fmaps,\n\tavx5124vnniw.\n\t(ix86_expand_builtin): Handle new builtins.\n\t(ix86_additional_allocno_class_p): New.\n\t* config/i386/i386.h (TARGET_AVX5124FMAPS,\n\tTARGET_AVX5124FMAPS_P,\n\tTARGET_AVX5124VNNIW,\n\tTARGET_AVX5124VNNIW_P): Define.\n\t(reg_class): Add MOD4_SSE_REGS.\n\t(MOD4_SSE_REG_P, MOD4_SSE_REGNO_P): New.\n\t* config/i386/i386.opt: Add mavx5124fmaps, mavx5124vnniw.\n\t* config/i386/immintrin.h: Include avx5124fmapsintrin.h,\n\tavx5124vnniwintrin.h.\n\t* config/i386/sse.md (unspec): Add UNSPEC_VP4FMADD,\n\tUNSPEC_VP4FNMADD,\n\tUNSPEC_VP4DPWSSD, UNSPEC_VP4DPWSSDS.\n\t(define_mode_iterator IMOD4): New.\n\t(define_mode_attr imod4_narrow): Ditto.\n\t(define_insn \"mov<mode>\"): Ditto.\n\t(define_insn \"avx5124fmaddps_4fmaddps\"): Ditto.\n\t(define_insn \"avx5124fmaddps_4fmaddps_mask\"): Ditto.\n\t(define_insn \"avx5124fmaddps_4fmaddps_maskz\"): Ditto.\n\t(define_insn \"avx5124fmaddps_4fmaddss\"): Ditto.\n\t(define_insn \"avx5124fmaddps_4fmaddss_mask\"): Ditto.\n\t(define_insn \"avx5124fmaddps_4fmaddss_maskz\"): Ditto.\n\t(define_insn \"avx5124fmaddps_4fnmaddps\"): Ditto.\n\t(define_insn \"avx5124fmaddps_4fnmaddps_mask\"): Ditto.\n\t(define_insn \"avx5124fmaddps_4fnmaddps_maskz\"): Ditto.\n\t(define_insn \"avx5124fmaddps_4fnmaddss\"): Ditto.\n\t(define_insn \"avx5124fmaddps_4fnmaddss_mask\"): Ditto.\n\t(define_insn \"avx5124fmaddps_4fnmaddss_maskz\"): Ditto.\n\t(define_insn \"avx5124vnniw_vp4dpwssd\"): Ditto.\n\t(define_insn \"avx5124vnniw_vp4dpwssd_mask\"): Ditto.\n\t(define_insn \"avx5124vnniw_vp4dpwssd_maskz\"): Ditto.\n\t(define_insn \"avx5124vnniw_vp4dpwssds\"): Ditto.\n\t(define_insn \"avx5124vnniw_vp4dpwssds_mask\"): Ditto.\n\t(define_insn \"avx5124vnniw_vp4dpwssds_maskz\"): Ditto.\n\t* init-regs.c (initialize_uninitialized_regs): Add emit_clobber call.\n\t* genmodes.c (mode_size_inline): Extend return type.\n\t* machmode.h (mode_size, mode_base_align): Extend type.\n\ngcc/testsuite/\n\n2016-11-17  Kirill Yukhin  <kirill.yukhin@gmail.com>\n\t    Andrew Senkevich <andrew.senkevich@intel.com>\n\n\t* gcc.target/i386/avx5124fmadd-v4fmaddps-1.c: New test.\n\t* gcc.target/i386/avx5124fmadd-v4fmaddps-2.c: Ditto.\n\t* gcc.target/i386/avx5124fmadd-v4fmaddss-1.c: Ditto.\n\t* gcc.target/i386/avx5124fmadd-v4fnmaddps-1.c: Ditto.\n\t* gcc.target/i386/avx5124fmadd-v4fnmaddps-2.c: Ditto.\n\t* gcc.target/i386/avx5124fmadd-v4fnmaddss-1.c: Ditto.\n\t* gcc.target/i386/avx5124fmaps-check.h: Ditto.\n\t* gcc.target/i386/avx5124vnniw-check.h: Ditto.\n\t* gcc.target/i386/avx5124vnniw-vp4dpwssd-1.c: Ditto.\n\t* gcc.target/i386/avx5124vnniw-vp4dpwssd-2.c: Ditto.\n\t* gcc.target/i386/avx5124vnniw-vp4dpwssds-1.c: Ditto.\n\t* gcc.target/i386/avx5124vnniw-vp4dpwssds-2.c: Ditto.\n\t* gcc.target/i386/avx512f-helper.h: Add avx5124fmaps-check.h,\n\tavx5124vnniw-check.h.\n\t* gcc.target/i386/i386.exp (check_effective_target_avx5124fmaps,\n\tcheck_effective_target_avx5124vnniw): New.\n\t* gcc.target/i386/m128-check.h (ESP_FLOAT, ESP_DOUBLE):\n\tSet under ifndef.\n\t* gcc.target/i386/sse-12.c: Add -mavx5124fmaps, -mavx5124vnniw.\n\t* gcc.target/i386/sse-13.c: Ditto.\n\t* g++.dg/other/i386-2.C: Ditto.\n\t* g++.dg/other/i386-3.C: Ditto.\n\t* gcc.target/i386/sse-22.c: Ditto.\n\t* gcc.target/i386/sse-23.c: Ditto.\n\nFrom-SVN: r242569", "tree": {"sha": "bbfde3863dcc84bb08bc2cf77f2c66c845a700c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbfde3863dcc84bb08bc2cf77f2c66c845a700c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/comments", "author": null, "committer": null, "parents": [{"sha": "80557bb787a65fb5b7a65d14ccabe6e962f88079", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80557bb787a65fb5b7a65d14ccabe6e962f88079", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80557bb787a65fb5b7a65d14ccabe6e962f88079"}], "stats": {"total": 1832, "additions": 1773, "deletions": 59}, "files": [{"sha": "98224f54e91406bfa981fd76472f8bcfd7c03a0a", "filename": "gcc/common/config/i386/i386-common.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -76,6 +76,8 @@ along with GCC; see the file COPYING3.  If not see\n   (OPTION_MASK_ISA_AVX512IFMA | OPTION_MASK_ISA_AVX512F_SET)\n #define OPTION_MASK_ISA_AVX512VBMI_SET \\\n   (OPTION_MASK_ISA_AVX512VBMI | OPTION_MASK_ISA_AVX512BW_SET)\n+#define OPTION_MASK_ISA_AVX5124FMAPS_SET OPTION_MASK_ISA_AVX5124FMAPS\n+#define OPTION_MASK_ISA_AVX5124VNNIW_SET OPTION_MASK_ISA_AVX5124VNNIW\n #define OPTION_MASK_ISA_RTM_SET OPTION_MASK_ISA_RTM\n #define OPTION_MASK_ISA_PRFCHW_SET OPTION_MASK_ISA_PRFCHW\n #define OPTION_MASK_ISA_RDSEED_SET OPTION_MASK_ISA_RDSEED\n@@ -179,6 +181,8 @@ along with GCC; see the file COPYING3.  If not see\n #define OPTION_MASK_ISA_AVX512VL_UNSET OPTION_MASK_ISA_AVX512VL\n #define OPTION_MASK_ISA_AVX512IFMA_UNSET OPTION_MASK_ISA_AVX512IFMA\n #define OPTION_MASK_ISA_AVX512VBMI_UNSET OPTION_MASK_ISA_AVX512VBMI\n+#define OPTION_MASK_ISA_AVX5124FMAPS_UNSET OPTION_MASK_ISA_AVX5124FMAPS\n+#define OPTION_MASK_ISA_AVX5124VNNIW_UNSET OPTION_MASK_ISA_AVX5124VNNIW\n #define OPTION_MASK_ISA_RTM_UNSET OPTION_MASK_ISA_RTM\n #define OPTION_MASK_ISA_PRFCHW_UNSET OPTION_MASK_ISA_PRFCHW\n #define OPTION_MASK_ISA_RDSEED_UNSET OPTION_MASK_ISA_RDSEED\n@@ -399,6 +403,12 @@ ix86_handle_option (struct gcc_options *opts,\n \t{\n \t  opts->x_ix86_isa_flags &= ~OPTION_MASK_ISA_AVX512F_UNSET;\n \t  opts->x_ix86_isa_flags_explicit |= OPTION_MASK_ISA_AVX512F_UNSET;\n+\n+\t  /* Turn off additional isa flags.  */\n+\t  opts->x_ix86_isa_flags2 &= ~OPTION_MASK_ISA_AVX5124FMAPS_UNSET;\n+\t  opts->x_ix86_isa_flags2_explicit |= OPTION_MASK_ISA_AVX5124FMAPS_UNSET;\n+\t  opts->x_ix86_isa_flags2 &= ~OPTION_MASK_ISA_AVX5124VNNIW_UNSET;\n+\t  opts->x_ix86_isa_flags2_explicit |= OPTION_MASK_ISA_AVX5124VNNIW_UNSET;\n \t}\n       return true;\n \n@@ -441,6 +451,36 @@ ix86_handle_option (struct gcc_options *opts,\n \t}\n       return true;\n \n+    case OPT_mavx5124fmaps:\n+      if (value)\n+\t{\n+\t  opts->x_ix86_isa_flags2 |= OPTION_MASK_ISA_AVX5124FMAPS_SET;\n+\t  opts->x_ix86_isa_flags2_explicit |= OPTION_MASK_ISA_AVX5124FMAPS_SET;\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_AVX512F_SET;\n+\t  opts->x_ix86_isa_flags_explicit |= OPTION_MASK_ISA_AVX512F_SET;\n+\t}\n+      else\n+\t{\n+\t  opts->x_ix86_isa_flags2 &= ~OPTION_MASK_ISA_AVX5124FMAPS_UNSET;\n+\t  opts->x_ix86_isa_flags2_explicit |= OPTION_MASK_ISA_AVX5124FMAPS_UNSET;\n+\t}\n+      return true;\n+\n+    case OPT_mavx5124vnniw:\n+      if (value)\n+\t{\n+\t  opts->x_ix86_isa_flags2 |= OPTION_MASK_ISA_AVX5124VNNIW_SET;\n+\t  opts->x_ix86_isa_flags2_explicit |= OPTION_MASK_ISA_AVX5124VNNIW_SET;\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_AVX512F_SET;\n+\t  opts->x_ix86_isa_flags_explicit |= OPTION_MASK_ISA_AVX512F_SET;\n+\t}\n+      else\n+\t{\n+\t  opts->x_ix86_isa_flags2 &= ~OPTION_MASK_ISA_AVX5124VNNIW_UNSET;\n+\t  opts->x_ix86_isa_flags2_explicit |= OPTION_MASK_ISA_AVX5124VNNIW_UNSET;\n+\t}\n+      return true;\n+\n     case OPT_mavx512dq:\n       if (value)\n \t{"}, {"sha": "d68e9d6e42e26b32451b5a34831d99460c6ca2ea", "filename": "gcc/config.gcc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -374,8 +374,8 @@ i[34567]86-*-*)\n \t\t       xsavesintrin.h avx512dqintrin.h avx512bwintrin.h\n \t\t       avx512vlintrin.h avx512vlbwintrin.h avx512vldqintrin.h\n \t\t       avx512ifmaintrin.h avx512ifmavlintrin.h avx512vbmiintrin.h\n-\t\t       avx512vbmivlintrin.h clwbintrin.h mwaitxintrin.h\n-\t\t       clzerointrin.h pkuintrin.h\"\n+\t\t       avx512vbmivlintrin.h avx5124fmapsintrin.h avx5124vnniwintrin.h\n+\t\t       clwbintrin.h mwaitxintrin.h clzerointrin.h pkuintrin.h\"\n \t;;\n x86_64-*-*)\n \tcpu_type=i386\n@@ -396,8 +396,8 @@ x86_64-*-*)\n \t\t       xsavesintrin.h avx512dqintrin.h avx512bwintrin.h\n \t\t       avx512vlintrin.h avx512vlbwintrin.h avx512vldqintrin.h\n \t\t       avx512ifmaintrin.h avx512ifmavlintrin.h avx512vbmiintrin.h\n-\t\t       avx512vbmivlintrin.h clwbintrin.h mwaitxintrin.h\n-\t\t       clzerointrin.h pkuintrin.h\"\n+\t\t       avx512vbmivlintrin.h avx5124fmapsintrin.h avx5124vnniwintrin.h\n+\t\t       clwbintrin.h mwaitxintrin.h clzerointrin.h pkuintrin.h\"\n \t;;\n ia64-*-*)\n \textra_headers=ia64intrin.h"}, {"sha": "6113ee9e9a4943e4fd0e3736653a379a1def9d4c", "filename": "gcc/config/i386/avx5124fmapsintrin.h", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Favx5124fmapsintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Favx5124fmapsintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Favx5124fmapsintrin.h?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -0,0 +1,216 @@\n+/* Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#if !defined _IMMINTRIN_H_INCLUDED\n+# error \"Never use <avx5124fmapsintrin.h> directly; include <x86intrin.h> instead.\"\n+#endif\n+\n+#ifndef _AVX5124FMAPSINTRIN_H_INCLUDED\n+#define _AVX5124FMAPSINTRIN_H_INCLUDED\n+\n+#ifndef __AVX5124FMAPS__\n+#pragma GCC push_options\n+#pragma GCC target(\"avx5124fmaps\")\n+#define __DISABLE_AVX5124FMAPS__\n+#endif /* __AVX5124FMAPS__ */\n+\n+extern __inline __m512\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm512_4fmadd_ps (__m512 __A, __m512 __B, __m512 __C,\n+\t\t  __m512 __D, __m512 __E, __m128 *__F)\n+{\n+  return (__m512) __builtin_ia32_4fmaddps ((__v16sf) __B,\n+\t\t\t\t\t   (__v16sf) __C,\n+\t\t\t\t\t   (__v16sf) __D,\n+\t\t\t\t\t   (__v16sf) __E,\n+\t\t\t\t\t   (__v16sf) __A,\n+\t\t\t\t\t   (const __v4sf *) __F);\n+}\n+\n+extern __inline __m512\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm512_mask_4fmadd_ps (__m512 __A, __mmask16 __U, __m512 __B,\n+\t\t       __m512 __C, __m512 __D, __m512 __E, __m128 *__F)\n+{\n+  return (__m512) __builtin_ia32_4fmaddps_mask ((__v16sf) __B,\n+\t\t\t\t\t\t(__v16sf) __C,\n+\t\t\t\t\t\t(__v16sf) __D,\n+\t\t\t\t\t\t(__v16sf) __E,\n+\t\t\t\t\t\t(__v16sf) __A,\n+\t\t\t\t\t\t(const __v4sf *) __F,\n+\t\t\t\t\t\t(__v16sf) __A,\n+\t\t\t\t\t\t(__mmask16) __U);\n+}\n+\n+extern __inline __m512\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm512_maskz_4fmadd_ps (__mmask16 __U,\n+\t\t\t__m512 __A, __m512 __B, __m512 __C,\n+\t\t\t__m512 __D, __m512 __E, __m128 *__F)\n+{\n+  return (__m512) __builtin_ia32_4fmaddps_mask ((__v16sf) __B,\n+\t\t\t\t\t\t(__v16sf) __C,\n+\t\t\t\t\t\t(__v16sf) __D,\n+\t\t\t\t\t\t(__v16sf) __E,\n+\t\t\t\t\t\t(__v16sf) __A,\n+\t\t\t\t\t\t(const __v4sf *) __F,\n+\t\t\t\t\t\t(__v16sf) _mm512_setzero_ps (),\n+\t\t\t\t\t\t(__mmask16) __U);\n+}\n+\n+extern __inline __m128\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_4fmadd_ss (__m128 __A, __m128 __B, __m128 __C,\n+\t       __m128 __D, __m128 __E, __m128 *__F)\n+{\n+  return (__m128) __builtin_ia32_4fmaddss ((__v4sf) __B,\n+\t\t\t\t\t   (__v4sf) __C,\n+\t\t\t\t\t   (__v4sf) __D,\n+\t\t\t\t\t   (__v4sf) __E,\n+\t\t\t\t\t   (__v4sf) __A,\n+\t\t\t\t\t   (const __v4sf *) __F);\n+}\n+\n+extern __inline __m128\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_mask_4fmadd_ss (__m128 __A, __mmask8 __U, __m128 __B, __m128 __C,\n+\t\t    __m128 __D, __m128 __E, __m128 *__F)\n+{\n+  return (__m128) __builtin_ia32_4fmaddss_mask ((__v4sf) __B,\n+\t\t\t\t\t\t(__v4sf) __C,\n+\t\t\t\t\t\t(__v4sf) __D,\n+\t\t\t\t\t\t(__v4sf) __E,\n+\t\t\t\t\t\t(__v4sf) __A,\n+\t\t\t\t\t\t(const __v4sf *) __F,\n+\t\t\t\t\t\t(__v4sf) __A,\n+\t\t\t\t\t\t(__mmask8) __U);\n+}\n+\n+extern __inline __m128\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_maskz_4fmadd_ss (__mmask8 __U, __m128 __A, __m128 __B, __m128 __C,\n+\t\t     __m128 __D, __m128 __E, __m128 *__F)\n+{\n+  return (__m128) __builtin_ia32_4fmaddss_mask ((__v4sf) __B,\n+\t\t\t\t\t\t(__v4sf) __C,\n+\t\t\t\t\t\t(__v4sf) __D,\n+\t\t\t\t\t\t(__v4sf) __E,\n+\t\t\t\t\t\t(__v4sf) __A,\n+\t\t\t\t\t\t(const __v4sf *) __F,\n+\t\t\t\t\t\t(__v4sf) _mm_setzero_ps (),\n+\t\t\t\t\t\t(__mmask8) __U);\n+}\n+\n+extern __inline __m512\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm512_4fnmadd_ps (__m512 __A, __m512 __B, __m512 __C,\n+\t\t   __m512 __D, __m512 __E, __m128 *__F)\n+{\n+  return (__m512) __builtin_ia32_4fnmaddps ((__v16sf) __B,\n+\t\t\t\t\t    (__v16sf) __C,\n+\t\t\t\t\t    (__v16sf) __D,\n+\t\t\t\t\t    (__v16sf) __E,\n+\t\t\t\t\t    (__v16sf) __A,\n+\t\t\t\t\t    (const __v4sf *) __F);\n+}\n+\n+extern __inline __m512\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm512_mask_4fnmadd_ps (__m512 __A, __mmask16 __U, __m512 __B,\n+\t\t\t__m512 __C, __m512 __D, __m512 __E, __m128 *__F)\n+{\n+  return (__m512) __builtin_ia32_4fnmaddps_mask ((__v16sf) __B,\n+\t\t\t\t\t\t (__v16sf) __C,\n+\t\t\t\t\t\t (__v16sf) __D,\n+\t\t\t\t\t\t (__v16sf) __E,\n+\t\t\t\t\t\t (__v16sf) __A,\n+\t\t\t\t\t\t (const __v4sf *) __F,\n+\t\t\t\t\t\t (__v16sf) __A,\n+\t\t\t\t\t\t (__mmask16) __U);\n+}\n+\n+extern __inline __m512\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm512_maskz_4fnmadd_ps (__mmask16 __U,\n+\t\t\t __m512 __A, __m512 __B, __m512 __C,\n+\t\t\t __m512 __D, __m512 __E, __m128 *__F)\n+{\n+  return (__m512) __builtin_ia32_4fnmaddps_mask ((__v16sf) __B,\n+\t\t\t\t\t\t (__v16sf) __C,\n+\t\t\t\t\t\t (__v16sf) __D,\n+\t\t\t\t\t\t (__v16sf) __E,\n+\t\t\t\t\t\t (__v16sf) __A,\n+\t\t\t\t\t\t (const __v4sf *) __F,\n+\t\t\t\t\t\t (__v16sf) _mm512_setzero_ps (),\n+\t\t\t\t\t\t (__mmask16) __U);\n+}\n+\n+extern __inline __m128\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_4fnmadd_ss (__m128 __A, __m128 __B, __m128 __C,\n+\t\t__m128 __D, __m128 __E, __m128 *__F)\n+{\n+  return (__m128) __builtin_ia32_4fnmaddss ((__v4sf) __B,\n+\t\t\t\t\t    (__v4sf) __C,\n+\t\t\t\t\t    (__v4sf) __D,\n+\t\t\t\t\t    (__v4sf) __E,\n+\t\t\t\t\t    (__v4sf) __A,\n+\t\t\t\t\t    (const __v4sf *) __F);\n+}\n+\n+extern __inline __m128\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_mask_4fnmadd_ss (__m128 __A, __mmask8 __U, __m128 __B, __m128 __C,\n+\t\t     __m128 __D, __m128 __E, __m128 *__F)\n+{\n+  return (__m128) __builtin_ia32_4fnmaddss_mask ((__v4sf) __B,\n+\t\t\t\t\t\t (__v4sf) __C,\n+\t\t\t\t\t\t (__v4sf) __D,\n+\t\t\t\t\t\t (__v4sf) __E,\n+\t\t\t\t\t\t (__v4sf) __A,\n+\t\t\t\t\t\t (const __v4sf *) __F,\n+\t\t\t\t\t\t (__v4sf) __A,\n+\t\t\t\t\t\t (__mmask8) __U);\n+}\n+\n+extern __inline __m128\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_maskz_4fnmadd_ss (__mmask8 __U, __m128 __A, __m128 __B, __m128 __C,\n+\t\t      __m128 __D, __m128 __E, __m128 *__F)\n+{\n+  return (__m128) __builtin_ia32_4fnmaddss_mask ((__v4sf) __B,\n+\t\t\t\t\t\t (__v4sf) __C,\n+\t\t\t\t\t\t (__v4sf) __D,\n+\t\t\t\t\t\t (__v4sf) __E,\n+\t\t\t\t\t\t (__v4sf) __A,\n+\t\t\t\t\t\t (const __v4sf *) __F,\n+\t\t\t\t\t\t (__v4sf) _mm_setzero_ps (),\n+\t\t\t\t\t\t (__mmask8) __U);\n+}\n+\n+#ifdef __DISABLE_AVX5124FMAPS__\n+#undef __DISABLE_AVX5124FMAPS__\n+#pragma GCC pop_options\n+#endif /* __DISABLE_AVX5124FMAPS__ */\n+\n+#endif /* _AVX5124FMAPSINTRIN_H_INCLUDED */"}, {"sha": "392c6a5d46436547b9ed0edf84ab717258514e04", "filename": "gcc/config/i386/avx5124vnniwintrin.h", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Favx5124vnniwintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Favx5124vnniwintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Favx5124vnniwintrin.h?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -0,0 +1,132 @@\n+/* Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#if !defined _IMMINTRIN_H_INCLUDED\n+# error \"Never use <avx5124vnniwintrin.h> directly; include <x86intrin.h> instead.\"\n+#endif\n+\n+#ifndef _AVX5124VNNIWINTRIN_H_INCLUDED\n+#define _AVX5124VNNIWINTRIN_H_INCLUDED\n+\n+#ifndef __AVX5124VNNIW__\n+#pragma GCC push_options\n+#pragma GCC target(\"avx5124vnniw\")\n+#define __DISABLE_AVX5124VNNIW__\n+#endif /* __AVX5124VNNIW__ */\n+\n+extern __inline __m512i\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm512_4dpwssd_epi32 (__m512i __A, __m512i __B, __m512i __C,\n+\t\t      __m512i __D, __m512i __E, __m128i *__F)\n+{\n+  return (__m512i) __builtin_ia32_vp4dpwssd ((__v16si) __B,\n+\t\t\t\t\t     (__v16si) __C,\n+\t\t\t\t\t     (__v16si) __D,\n+\t\t\t\t\t     (__v16si) __E,\n+\t\t\t\t\t     (__v16si) __A,\n+\t\t\t\t\t     (const __v4si *) __F);\n+}\n+\n+extern __inline __m512i\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm512_mask_4dpwssd_epi32 (__m512i __A, __mmask16 __U, __m512i __B,\n+\t\t\t   __m512i __C, __m512i __D, __m512i __E,\n+\t\t\t   __m128i *__F)\n+{\n+  return (__m512i) __builtin_ia32_vp4dpwssd_mask ((__v16si) __B,\n+\t\t\t\t\t\t  (__v16si) __C,\n+\t\t\t\t\t\t  (__v16si) __D,\n+\t\t\t\t\t\t  (__v16si) __E,\n+\t\t\t\t\t\t  (__v16si) __A,\n+\t\t\t\t\t\t  (const __v4si *) __F,\n+\t\t\t\t\t\t  (__v16si) __A,\n+\t\t\t\t\t\t  (__mmask16) __U);\n+}\n+\n+extern __inline __m512i\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm512_maskz_4dpwssd_epi32 (__mmask16 __U, __m512i __A, __m512i __B,\n+\t\t\t    __m512i __C, __m512i __D, __m512i __E,\n+\t\t\t    __m128i *__F)\n+{\n+  return (__m512i) __builtin_ia32_vp4dpwssd_mask ((__v16si) __B,\n+\t\t\t\t\t\t  (__v16si) __C,\n+\t\t\t\t\t\t  (__v16si) __D,\n+\t\t\t\t\t\t  (__v16si) __E,\n+\t\t\t\t\t\t  (__v16si) __A,\n+\t\t\t\t\t\t  (const __v4si *) __F,\n+\t\t\t\t\t\t  (__v16si) _mm512_setzero_ps (),\n+\t\t\t\t\t\t  (__mmask16) __U);\n+}\n+\n+extern __inline __m512i\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm512_4dpwssds_epi32 (__m512i __A, __m512i __B, __m512i __C,\n+\t\t       __m512i __D, __m512i __E, __m128i *__F)\n+{\n+  return (__m512i) __builtin_ia32_vp4dpwssds ((__v16si) __B,\n+\t\t\t\t\t      (__v16si) __C,\n+\t\t\t\t\t      (__v16si) __D,\n+\t\t\t\t\t      (__v16si) __E,\n+\t\t\t\t\t      (__v16si) __A,\n+\t\t\t\t\t      (const __v4si *) __F);\n+}\n+\n+extern __inline __m512i\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm512_mask_4dpwssds_epi32 (__m512i __A, __mmask16 __U, __m512i __B,\n+\t\t\t    __m512i __C, __m512i __D, __m512i __E,\n+\t\t\t    __m128i *__F)\n+{\n+  return (__m512i) __builtin_ia32_vp4dpwssds_mask ((__v16si) __B,\n+\t\t\t\t\t\t   (__v16si) __C,\n+\t\t\t\t\t\t   (__v16si) __D,\n+\t\t\t\t\t\t   (__v16si) __E,\n+\t\t\t\t\t\t   (__v16si) __A,\n+\t\t\t\t\t\t   (const __v4si *) __F,\n+\t\t\t\t\t\t   (__v16si) __A,\n+\t\t\t\t\t\t   (__mmask16) __U);\n+}\n+\n+extern __inline __m512i\n+__attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm512_maskz_4dpwssds_epi32 (__mmask16 __U, __m512i __A, __m512i __B,\n+\t\t\t     __m512i __C, __m512i __D, __m512i __E,\n+\t\t\t     __m128i *__F)\n+{\n+  return (__m512i) __builtin_ia32_vp4dpwssds_mask ((__v16si) __B,\n+\t\t\t\t\t\t   (__v16si) __C,\n+\t\t\t\t\t\t   (__v16si) __D,\n+\t\t\t\t\t\t   (__v16si) __E,\n+\t\t\t\t\t\t   (__v16si) __A,\n+\t\t\t\t\t\t   (const __v4si *) __F,\n+\t\t\t\t\t\t   (__v16si) _mm512_setzero_ps (),\n+\t\t\t\t\t\t   (__mmask16) __U);\n+}\n+\n+#ifdef __DISABLE_AVX5124VNNIW__\n+#undef __DISABLE_AVX5124VNNIW__\n+#pragma GCC pop_options\n+#endif /* __DISABLE_AVX5124VNNIW__ */\n+\n+#endif /* _AVX5124VNNIWINTRIN_H_INCLUDED */"}, {"sha": "b734ce477b81e51dfddbc7a1d55591c8a5210979", "filename": "gcc/config/i386/constraints.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fconstraints.md?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -112,6 +112,7 @@\n ;;  f\tx87 register when 80387 floating point arithmetic is enabled\n ;;  r\tSSE regs not requiring REX prefix when prefixes avoidance is enabled\n ;;\tand all SSE regs otherwise\n+;;  h   EVEX encodable SSE register with number factor of four\n \n (define_register_constraint \"Yz\" \"TARGET_SSE ? SSE_FIRST_REG : NO_REGS\"\n  \"First SSE register (@code{%xmm0}).\")\n@@ -160,6 +161,9 @@\n  \"TARGET_AVX512VL ? ALL_SSE_REGS : TARGET_SSE ? SSE_REGS : NO_REGS\"\n  \"@internal For AVX512VL, any EVEX encodable SSE register (@code{%xmm0-%xmm31}), otherwise any SSE register.\")\n \n+(define_register_constraint \"Yh\" \"TARGET_AVX512F ? MOD4_SSE_REGS : NO_REGS\"\n+ \"@internal Any EVEX encodable SSE register, which has number factor of four.\")\n+\n ;; We use the B prefix to denote any number of internal operands:\n ;;  f  FLAGS_REG\n ;;  g  GOT memory operand."}, {"sha": "abe7c62a8f3f4fdd086291981cf0286005b12194", "filename": "gcc/config/i386/cpuid.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fcpuid.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fcpuid.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcpuid.h?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -60,6 +60,8 @@\n #define bit_MWAITX      (1 << 29)\n \n /* %edx */\n+#define bit_AVX5124VNNIW (1 << 2)\n+#define bit_AVX5124FMAPS (1 << 3)\n #define bit_MMXEXT\t(1 << 22)\n #define bit_LM\t\t(1 << 29)\n #define bit_3DNOWP\t(1 << 30)"}, {"sha": "f0d0e8f890c77ae47d03c4f61a16a8d251d00d92", "filename": "gcc/config/i386/driver-i386.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdriver-i386.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -414,6 +414,7 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n   unsigned int has_avx512dq = 0, has_avx512bw = 0, has_avx512vl = 0;\n   unsigned int has_avx512vbmi = 0, has_avx512ifma = 0, has_clwb = 0;\n   unsigned int has_mwaitx = 0, has_clzero = 0, has_pku = 0;\n+  unsigned int has_avx5124fmaps = 0, has_avx5124vnniw = 0;\n \n   bool arch;\n \n@@ -501,6 +502,8 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n       has_prefetchwt1 = ecx & bit_PREFETCHWT1;\n       has_avx512vbmi = ecx & bit_AVX512VBMI;\n       has_pku = ecx & bit_OSPKE;\n+      has_avx5124vnniw = edx & bit_AVX5124VNNIW;\n+      has_avx5124fmaps = edx & bit_AVX5124FMAPS;\n     }\n \n   if (max_level >= 13)\n@@ -1021,6 +1024,8 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n       const char *avx512vl = has_avx512vl ? \" -mavx512vl\" : \" -mno-avx512vl\";\n       const char *avx512ifma = has_avx512ifma ? \" -mavx512ifma\" : \" -mno-avx512ifma\";\n       const char *avx512vbmi = has_avx512vbmi ? \" -mavx512vbmi\" : \" -mno-avx512vbmi\";\n+      const char *avx5124vnniw = has_avx5124vnniw ? \" -mavx5124vnniw\" : \" -mno-avx5124vnniw\";\n+      const char *avx5124fmaps = has_avx5124fmaps ? \" -mavx5124fmaps\" : \" -mno-avx5124fmaps\";\n       const char *clwb = has_clwb ? \" -mclwb\" : \" -mno-clwb\";\n       const char *mwaitx  = has_mwaitx  ? \" -mmwaitx\"  : \" -mno-mwaitx\"; \n       const char *clzero  = has_clzero  ? \" -mclzero\"  : \" -mno-clzero\";\n@@ -1033,8 +1038,8 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n \t\t\tfxsr, xsave, xsaveopt, avx512f, avx512er,\n \t\t\tavx512cd, avx512pf, prefetchwt1, clflushopt,\n \t\t\txsavec, xsaves, avx512dq, avx512bw, avx512vl,\n-\t\t\tavx512ifma, avx512vbmi, clwb, mwaitx,\n-\t\t\tclzero, pku, NULL);\n+\t\t\tavx512ifma, avx512vbmi, avx5124fmaps, avx5124vnniw,\n+\t\t\tclwb, mwaitx, clzero, pku, NULL);\n     }\n \n done:"}, {"sha": "4a38c127dc014319ff8d55c8338c6409440800c3", "filename": "gcc/config/i386/i386-builtin-types.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -526,6 +526,15 @@ DEF_FUNCTION_TYPE (VOID, UNSIGNED, UNSIGNED)\n DEF_FUNCTION_TYPE (VOID, UNSIGNED, UNSIGNED, UNSIGNED)\n DEF_FUNCTION_TYPE (VOID, PV8DI, V8DI)\n \n+DEF_FUNCTION_TYPE (V16SF, V16SF, V16SF, V16SF, V16SF, V16SF, PCV4SF, V16SF, UHI)\n+DEF_FUNCTION_TYPE (V16SF, V16SF, V16SF, V16SF, V16SF, V16SF, PCV4SF)\n+DEF_FUNCTION_TYPE (V4SF, V4SF, V4SF, V4SF, V4SF, V4SF, PCV4SF)\n+DEF_FUNCTION_TYPE (V4SF, V4SF, V4SF, V4SF, V4SF, V4SF, PCV4SF, V4SF, UQI)\n+\n+DEF_FUNCTION_TYPE (V16SI, V16SI, V16SI, V16SI, V16SI, V16SI, PCV4SI, V16SI, UHI)\n+DEF_FUNCTION_TYPE (V16SI, V16SI, V16SI, V16SI, V16SI, V16SI, PCV4SI)\n+\n+\n # Instructions returning mask\n DEF_FUNCTION_TYPE (UHI, UHI)\n DEF_FUNCTION_TYPE (UHI, V16QI)"}, {"sha": "b23b70cf91cc5451e38e08102c00c3e376a52005", "filename": "gcc/config/i386/i386-builtin.def", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fi386-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fi386-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtin.def?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -2482,7 +2482,24 @@ BDESC (OPTION_MASK_ISA_AVX512DQ, CODE_FOR_ufix_truncv8dfv8di2_mask_round, \"__bui\n BDESC (OPTION_MASK_ISA_AVX512DQ, CODE_FOR_avx512dq_rangepv16sf_mask_round, \"__builtin_ia32_rangeps512_mask\", IX86_BUILTIN_RANGEPS512, UNKNOWN, (int) V16SF_FTYPE_V16SF_V16SF_INT_V16SF_HI_INT)\n BDESC (OPTION_MASK_ISA_AVX512DQ, CODE_FOR_avx512dq_rangepv8df_mask_round, \"__builtin_ia32_rangepd512_mask\", IX86_BUILTIN_RANGEPD512, UNKNOWN, (int) V8DF_FTYPE_V8DF_V8DF_INT_V8DF_QI_INT)\n \n-BDESC_END (ROUND_ARGS, MPX)\n+BDESC_END (ROUND_ARGS, ARGS2)\n+\n+/* AVX512_4FMAPS and AVX512_4VNNIW builtins with variable number of arguments. Defined in additional ix86_isa_flags2.  */\n+BDESC_FIRST (args2, ARGS2,\n+       OPTION_MASK_ISA_AVX5124FMAPS, CODE_FOR_avx5124fmaddps_4fmaddps_mask, \"__builtin_ia32_4fmaddps_mask\", IX86_BUILTIN_4FMAPS_MASK, UNKNOWN, (int) V16SF_FTYPE_V16SF_V16SF_V16SF_V16SF_V16SF_PCV4SF_V16SF_UHI)\n+BDESC (OPTION_MASK_ISA_AVX5124FMAPS, CODE_FOR_avx5124fmaddps_4fmaddps, \"__builtin_ia32_4fmaddps\", IX86_BUILTIN_4FMAPS, UNKNOWN, (int) V16SF_FTYPE_V16SF_V16SF_V16SF_V16SF_V16SF_PCV4SF)\n+BDESC (OPTION_MASK_ISA_AVX5124FMAPS, CODE_FOR_avx5124fmaddps_4fmaddss, \"__builtin_ia32_4fmaddss\", IX86_BUILTIN_4FMASS, UNKNOWN, (int) V4SF_FTYPE_V4SF_V4SF_V4SF_V4SF_V4SF_PCV4SF)\n+BDESC (OPTION_MASK_ISA_AVX5124FMAPS, CODE_FOR_avx5124fmaddps_4fmaddss_mask, \"__builtin_ia32_4fmaddss_mask\", IX86_BUILTIN_4FMASS_MASK, UNKNOWN, (int) V4SF_FTYPE_V4SF_V4SF_V4SF_V4SF_V4SF_PCV4SF_V4SF_UQI)\n+BDESC (OPTION_MASK_ISA_AVX5124FMAPS, CODE_FOR_avx5124fmaddps_4fnmaddps_mask, \"__builtin_ia32_4fnmaddps_mask\", IX86_BUILTIN_4FNMAPS_MASK, UNKNOWN, (int) V16SF_FTYPE_V16SF_V16SF_V16SF_V16SF_V16SF_PCV4SF_V16SF_UHI)\n+BDESC (OPTION_MASK_ISA_AVX5124FMAPS, CODE_FOR_avx5124fmaddps_4fnmaddps, \"__builtin_ia32_4fnmaddps\", IX86_BUILTIN_4FNMAPS, UNKNOWN, (int) V16SF_FTYPE_V16SF_V16SF_V16SF_V16SF_V16SF_PCV4SF)\n+BDESC (OPTION_MASK_ISA_AVX5124FMAPS, CODE_FOR_avx5124fmaddps_4fnmaddss, \"__builtin_ia32_4fnmaddss\", IX86_BUILTIN_4FNMASS, UNKNOWN, (int) V4SF_FTYPE_V4SF_V4SF_V4SF_V4SF_V4SF_PCV4SF)\n+BDESC (OPTION_MASK_ISA_AVX5124FMAPS, CODE_FOR_avx5124fmaddps_4fnmaddss_mask, \"__builtin_ia32_4fnmaddss_mask\", IX86_BUILTIN_4FNMASS_MASK, UNKNOWN, (int) V4SF_FTYPE_V4SF_V4SF_V4SF_V4SF_V4SF_PCV4SF_V4SF_UQI)\n+BDESC (OPTION_MASK_ISA_AVX5124VNNIW, CODE_FOR_avx5124vnniw_vp4dpwssd, \"__builtin_ia32_vp4dpwssd\", IX86_BUILTIN_4DPWSSD, UNKNOWN, (int) V16SI_FTYPE_V16SI_V16SI_V16SI_V16SI_V16SI_PCV4SI)\n+BDESC (OPTION_MASK_ISA_AVX5124VNNIW, CODE_FOR_avx5124vnniw_vp4dpwssd_mask, \"__builtin_ia32_vp4dpwssd_mask\", IX86_BUILTIN_4DPWSSD_MASK, UNKNOWN, (int) V16SI_FTYPE_V16SI_V16SI_V16SI_V16SI_V16SI_PCV4SI_V16SI_UHI)\n+BDESC (OPTION_MASK_ISA_AVX5124VNNIW, CODE_FOR_avx5124vnniw_vp4dpwssds, \"__builtin_ia32_vp4dpwssds\", IX86_BUILTIN_4DPWSSDS, UNKNOWN, (int) V16SI_FTYPE_V16SI_V16SI_V16SI_V16SI_V16SI_PCV4SI)\n+BDESC (OPTION_MASK_ISA_AVX5124VNNIW, CODE_FOR_avx5124vnniw_vp4dpwssds_mask, \"__builtin_ia32_vp4dpwssds_mask\", IX86_BUILTIN_4DPWSSDS_MASK, UNKNOWN, (int) V16SI_FTYPE_V16SI_V16SI_V16SI_V16SI_V16SI_PCV4SI_V16SI_UHI)\n+\n+BDESC_END (ARGS2, MPX)\n \n /* Builtins for MPX.  */\n BDESC_FIRST (mpx, MPX,"}, {"sha": "6e56c8386ff48a4b7e6bec9166c5fafe992e6992", "filename": "gcc/config/i386/i386-c.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fi386-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fi386-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-c.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -28,14 +28,14 @@ along with GCC; see the file COPYING3.  If not see\n \n static bool ix86_pragma_target_parse (tree, tree);\n static void ix86_target_macros_internal\n-  (HOST_WIDE_INT, enum processor_type, enum processor_type, enum fpmath_unit,\n+  (HOST_WIDE_INT, HOST_WIDE_INT, enum processor_type, enum processor_type, enum fpmath_unit,\n    void (*def_or_undef) (cpp_reader *, const char *));\n \n-\f\n /* Internal function to either define or undef the appropriate system\n    macros.  */\n static void\n ix86_target_macros_internal (HOST_WIDE_INT isa_flag,\n+\t\t\t     HOST_WIDE_INT isa_flag2,\n \t\t\t     enum processor_type arch,\n \t\t\t     enum processor_type tune,\n \t\t\t     enum fpmath_unit fpmath,\n@@ -376,6 +376,10 @@ ix86_target_macros_internal (HOST_WIDE_INT isa_flag,\n     def_or_undef (parse_in, \"__AVX512VBMI__\");\n   if (isa_flag & OPTION_MASK_ISA_AVX512IFMA)\n     def_or_undef (parse_in, \"__AVX512IFMA__\");\n+  if (isa_flag2 & OPTION_MASK_ISA_AVX5124VNNIW)\n+    def_or_undef (parse_in, \"__AVX5124VNNIW__\");\n+  if (isa_flag2 & OPTION_MASK_ISA_AVX5124FMAPS)\n+    def_or_undef (parse_in, \"__AVX5124FMAPS__\");\n   if (isa_flag & OPTION_MASK_ISA_FMA)\n     def_or_undef (parse_in, \"__FMA__\");\n   if (isa_flag & OPTION_MASK_ISA_RTM)\n@@ -462,6 +466,9 @@ ix86_pragma_target_parse (tree args, tree pop_target)\n   HOST_WIDE_INT prev_isa;\n   HOST_WIDE_INT cur_isa;\n   HOST_WIDE_INT diff_isa;\n+  HOST_WIDE_INT prev_isa2;\n+  HOST_WIDE_INT cur_isa2;\n+  HOST_WIDE_INT diff_isa2;\n   enum processor_type prev_arch;\n   enum processor_type prev_tune;\n   enum processor_type cur_arch;\n@@ -494,6 +501,9 @@ ix86_pragma_target_parse (tree args, tree pop_target)\n   prev_isa  = prev_opt->x_ix86_isa_flags;\n   cur_isa   = cur_opt->x_ix86_isa_flags;\n   diff_isa  = (prev_isa ^ cur_isa);\n+  prev_isa2  = prev_opt->x_ix86_isa_flags2;\n+  cur_isa2   = cur_opt->x_ix86_isa_flags2;\n+  diff_isa2  = (prev_isa2 ^ cur_isa2);\n   prev_arch = (enum processor_type) prev_opt->arch;\n   prev_tune = (enum processor_type) prev_opt->tune;\n   cur_arch  = (enum processor_type) cur_opt->arch;\n@@ -509,6 +519,7 @@ ix86_pragma_target_parse (tree args, tree pop_target)\n \n   /* Undef all of the macros for that are no longer current.  */\n   ix86_target_macros_internal (prev_isa & diff_isa,\n+\t\t\t       prev_isa2 & diff_isa2,\n \t\t\t       prev_arch,\n \t\t\t       prev_tune,\n \t\t\t       (enum fpmath_unit) prev_opt->x_ix86_fpmath,\n@@ -523,6 +534,7 @@ ix86_pragma_target_parse (tree args, tree pop_target)\n \n   /* Define all of the macros for new options that were just turned on.  */\n   ix86_target_macros_internal (cur_isa & diff_isa,\n+\t\t\t       cur_isa2 & diff_isa2,\n \t\t\t       cur_arch,\n \t\t\t       cur_tune,\n \t\t\t       (enum fpmath_unit) cur_opt->x_ix86_fpmath,\n@@ -583,6 +595,7 @@ ix86_target_macros (void)\n   cpp_define (parse_in, \"__GCC_ASM_FLAG_OUTPUTS__\");\n \n   ix86_target_macros_internal (ix86_isa_flags,\n+\t\t\t       ix86_isa_flags2,\n \t\t\t       ix86_arch,\n \t\t\t       ix86_tune,\n \t\t\t       ix86_fpmath,"}, {"sha": "1899d066f42084a9e871871e1469a32c748e29fc", "filename": "gcc/config/i386/i386-modes.def", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-modes.def?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -79,18 +79,20 @@ VECTOR_MODES (INT, 16);       /*   V16QI V8HI V4SI V2DI */\n VECTOR_MODES (INT, 32);       /*  V32QI V16HI V8SI V4DI */\n VECTOR_MODES (INT, 64);       /* V64QI V32HI V16SI V8DI */\n VECTOR_MODES (INT, 128);      /* V128QI V64HI V32SI V16DI */\n-VECTOR_MODES (FLOAT, 8);      /*              V4HF V2SF */\n-VECTOR_MODES (FLOAT, 16);     /*         V8HF V4SF V2DF */\n-VECTOR_MODES (FLOAT, 32);     /*        V16HF V8SF V4DF */\n-VECTOR_MODES (FLOAT, 64);     /*       V32HF V16SF V8DF */\n-VECTOR_MODES (FLOAT, 128);    /*      V64HF V32SF V16DF */\n+VECTOR_MODES (FLOAT, 8);      /*                   V2SF */\n+VECTOR_MODES (FLOAT, 16);     /*              V4SF V2DF */\n+VECTOR_MODES (FLOAT, 32);     /*         V8SF V4DF V2TF */\n+VECTOR_MODES (FLOAT, 64);     /*        V16SF V8DF V4TF */\n+VECTOR_MODES (FLOAT, 128);    /*       V32SF V16DF V8TF */\n+VECTOR_MODES (FLOAT, 256);    /*      V64SF V32DF V16TF */\n VECTOR_MODE (INT, TI, 1);     /*                   V1TI */\n VECTOR_MODE (INT, DI, 1);     /*                   V1DI */\n VECTOR_MODE (INT, SI, 1);     /*                   V1SI */\n VECTOR_MODE (INT, QI, 2);     /*                   V2QI */\n VECTOR_MODE (INT, QI, 12);    /*                  V12QI */\n VECTOR_MODE (INT, QI, 14);    /*                  V14QI */\n VECTOR_MODE (INT, HI, 6);     /*                   V6HI */\n+VECTOR_MODE (INT, SI, 64);    /* \t\t  V64SI */\n \n POINTER_BOUNDS_MODE (BND32, 8);\n POINTER_BOUNDS_MODE (BND64, 16);"}, {"sha": "1da1abcaa49d71c16ba0660f0e1194204dbbd16e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 400, "deletions": 26, "changes": 426, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -2579,7 +2579,7 @@ static int ix86_function_regparm (const_tree, const_tree);\n static void ix86_compute_frame_layout (struct ix86_frame *);\n static bool ix86_expand_vector_init_one_nonzero (bool, machine_mode,\n \t\t\t\t\t\t rtx, rtx, int);\n-static void ix86_add_new_builtins (HOST_WIDE_INT);\n+static void ix86_add_new_builtins (HOST_WIDE_INT, HOST_WIDE_INT);\n static tree ix86_canonical_va_list_type (tree);\n static void predict_jump (int);\n static unsigned int split_stack_prologue_scratch_regno (void);\n@@ -2592,8 +2592,9 @@ enum ix86_function_specific_strings\n   IX86_FUNCTION_SPECIFIC_MAX\n };\n \n-static char *ix86_target_string (HOST_WIDE_INT, int, int, const char *,\n-\t\t\t\t const char *, enum fpmath_unit, bool);\n+static char *ix86_target_string (HOST_WIDE_INT, HOST_WIDE_INT, int, int,\n+\t\t\t\t const char *, const char *, enum fpmath_unit,\n+\t\t\t\t bool);\n static void ix86_function_specific_save (struct cl_target_option *,\n \t\t\t\t\t struct gcc_options *opts);\n static void ix86_function_specific_restore (struct gcc_options *opts,\n@@ -4188,8 +4189,8 @@ ix86_using_red_zone (void)\n    responsible for freeing the string.  */\n \n static char *\n-ix86_target_string (HOST_WIDE_INT isa, int flags, int ix86_flags,\n-\t\t    const char *arch, const char *tune,\n+ix86_target_string (HOST_WIDE_INT isa, HOST_WIDE_INT isa2, int flags,\n+\t\t    int ix86_flags, const char *arch, const char *tune,\n \t\t    enum fpmath_unit fpmath, bool add_nl_p)\n {\n   struct ix86_target_opts\n@@ -4257,7 +4258,12 @@ ix86_target_string (HOST_WIDE_INT isa, int flags, int ix86_flags,\n     { \"-mclzero\",\tOPTION_MASK_ISA_CLZERO  },\n     { \"-mpku\",\t\tOPTION_MASK_ISA_PKU  },\n   };\n-\n+  /* Additional structure for isa flags.  */\n+  static struct ix86_target_opts isa_opts2[] =\n+  {\n+    { \"-mavx5124vnniw\", OPTION_MASK_ISA_AVX5124VNNIW },\n+    { \"-mavx5124fmaps\", OPTION_MASK_ISA_AVX5124FMAPS },\n+  };\n   /* Flag options.  */\n   static struct ix86_target_opts flag_opts[] =\n   {\n@@ -4298,8 +4304,8 @@ ix86_target_string (HOST_WIDE_INT isa, int flags, int ix86_flags,\n     { \"-mgeneral-regs-only\",\t\tOPTION_MASK_GENERAL_REGS_ONLY },\n   };\n \n-  const char *opts[ARRAY_SIZE (isa_opts) + ARRAY_SIZE (flag_opts)\n-\t\t   + ARRAY_SIZE (ix86_flag_opts) + 6][2];\n+  const char *opts[ARRAY_SIZE (isa_opts) + ARRAY_SIZE (isa_opts2)\n+\t\t   + ARRAY_SIZE (flag_opts) + ARRAY_SIZE (ix86_flag_opts) + 6][2];\n \n   char isa_other[40];\n   char target_other[40];\n@@ -4361,6 +4367,16 @@ ix86_target_string (HOST_WIDE_INT isa, int flags, int ix86_flags,\n \t       isa);\n     }\n \n+  /* Pick out the options in isa2 options.  */\n+  for (i = 0; i < ARRAY_SIZE (isa_opts2); i++)\n+    {\n+      if ((isa2 & isa_opts2[i].mask) != 0)\n+\t{\n+\t  opts[num++][0] = isa_opts2[i].option;\n+\t  isa &= ~ isa_opts2[i].mask;\n+\t}\n+    }\n+\n   /* Add flag options.  */\n   for (i = 0; i < ARRAY_SIZE (flag_opts); i++)\n     {\n@@ -4486,9 +4502,9 @@ ix86_profile_before_prologue (void)\n void ATTRIBUTE_UNUSED\n ix86_debug_options (void)\n {\n-  char *opts = ix86_target_string (ix86_isa_flags, target_flags,\n-\t\t\t\t   ix86_target_flags,\n-\t\t\t\t   ix86_arch_string, ix86_tune_string,\n+  char *opts = ix86_target_string (ix86_isa_flags, ix86_isa_flags2,\n+\t\t\t\t   target_flags, ix86_target_flags,\n+\t\t\t\t   ix86_arch_string,ix86_tune_string,\n \t\t\t\t   ix86_fpmath, true);\n \n   if (opts)\n@@ -4844,6 +4860,8 @@ ix86_option_override_internal (bool main_args_p,\n #define PTA_CLZERO\t\t(HOST_WIDE_INT_1 << 57)\n #define PTA_NO_80387\t\t(HOST_WIDE_INT_1 << 58)\n #define PTA_PKU\t\t(HOST_WIDE_INT_1 << 59)\n+#define PTA_AVX5124VNNIW\t(HOST_WIDE_INT_1 << 60)\n+#define PTA_AVX5124FMAPS\t(HOST_WIDE_INT_1 << 61)\n \n #define PTA_CORE2 \\\n   (PTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3 | PTA_SSSE3 \\\n@@ -5499,6 +5517,14 @@ ix86_option_override_internal (bool main_args_p,\n \tif (processor_alias_table[i].flags & PTA_AVX512IFMA\n \t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_AVX512IFMA))\n \t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_AVX512IFMA;\n+\n+\tif (processor_alias_table[i].flags & PTA_AVX5124VNNIW\n+\t    && !(opts->x_ix86_isa_flags2_explicit & OPTION_MASK_ISA_AVX5124VNNIW))\n+\t  opts->x_ix86_isa_flags2 |= OPTION_MASK_ISA_AVX5124VNNIW;\n+\tif (processor_alias_table[i].flags & PTA_AVX5124FMAPS\n+\t    && !(opts->x_ix86_isa_flags2_explicit & OPTION_MASK_ISA_AVX5124FMAPS))\n+\t  opts->x_ix86_isa_flags2 |= OPTION_MASK_ISA_AVX5124FMAPS;\n+\n \tif (processor_alias_table[i].flags & (PTA_PREFETCH_SSE | PTA_SSE))\n \t  x86_prefetch_sse = true;\n \tif (processor_alias_table[i].flags & PTA_MWAITX\n@@ -6298,6 +6324,7 @@ ix86_function_specific_save (struct cl_target_option *ptr,\n   ptr->tune_defaulted = ix86_tune_defaulted;\n   ptr->arch_specified = ix86_arch_specified;\n   ptr->x_ix86_isa_flags_explicit = opts->x_ix86_isa_flags_explicit;\n+  ptr->x_ix86_isa_flags2_explicit = opts->x_ix86_isa_flags2_explicit;\n   ptr->x_recip_mask_explicit = opts->x_recip_mask_explicit;\n   ptr->x_ix86_arch_string = opts->x_ix86_arch_string;\n   ptr->x_ix86_tune_string = opts->x_ix86_tune_string;\n@@ -6354,6 +6381,7 @@ ix86_function_specific_restore (struct gcc_options *opts,\n   ix86_tune_defaulted = ptr->tune_defaulted;\n   ix86_arch_specified = ptr->arch_specified;\n   opts->x_ix86_isa_flags_explicit = ptr->x_ix86_isa_flags_explicit;\n+  opts->x_ix86_isa_flags2_explicit = ptr->x_ix86_isa_flags2_explicit;\n   opts->x_recip_mask_explicit = ptr->x_recip_mask_explicit;\n   opts->x_ix86_arch_string = ptr->x_ix86_arch_string;\n   opts->x_ix86_tune_string = ptr->x_ix86_tune_string;\n@@ -6459,9 +6487,9 @@ ix86_function_specific_print (FILE *file, int indent,\n \t\t\t      struct cl_target_option *ptr)\n {\n   char *target_string\n-    = ix86_target_string (ptr->x_ix86_isa_flags, ptr->x_target_flags,\n-\t\t\t  ptr->x_ix86_target_flags, NULL, NULL,\n-\t\t\t  ptr->x_ix86_fpmath, false);\n+    = ix86_target_string (ptr->x_ix86_isa_flags, ptr->x_ix86_isa_flags2,\n+\t\t\t  ptr->x_target_flags, ptr->x_ix86_target_flags,\n+\t\t\t  NULL, NULL, ptr->x_ix86_fpmath, false);\n \n   gcc_assert (ptr->arch < PROCESSOR_max);\n   fprintf (file, \"%*sarch = %d (%s)\\n\",\n@@ -6538,6 +6566,8 @@ ix86_valid_target_attribute_inner_p (tree args, char *p_strings[],\n     IX86_ATTR_ISA (\"avx512dq\",\tOPT_mavx512dq),\n     IX86_ATTR_ISA (\"avx512bw\",\tOPT_mavx512bw),\n     IX86_ATTR_ISA (\"avx512vl\",\tOPT_mavx512vl),\n+    IX86_ATTR_ISA (\"avx5124fmaps\",\tOPT_mavx5124fmaps),\n+    IX86_ATTR_ISA (\"avx5124vnniw\",\tOPT_mavx5124vnniw),\n     IX86_ATTR_ISA (\"mmx\",\tOPT_mmmx),\n     IX86_ATTR_ISA (\"pclmul\",\tOPT_mpclmul),\n     IX86_ATTR_ISA (\"popcnt\",\tOPT_mpopcnt),\n@@ -6796,6 +6826,7 @@ ix86_valid_target_attribute_tree (tree args,\n      The string options are attribute options, and will be undone\n      when we copy the save structure.  */\n   if (opts->x_ix86_isa_flags != def->x_ix86_isa_flags\n+      || opts->x_ix86_isa_flags2 != def->x_ix86_isa_flags2\n       || opts->x_target_flags != def->x_target_flags\n       || option_strings[IX86_FUNCTION_SPECIFIC_ARCH]\n       || option_strings[IX86_FUNCTION_SPECIFIC_TUNE]\n@@ -6814,7 +6845,7 @@ ix86_valid_target_attribute_tree (tree args,\n \t\t\t\t     | OPTION_MASK_ABI_64\n \t\t\t\t     | OPTION_MASK_ABI_X32\n \t\t\t\t     | OPTION_MASK_CODE16);\n-\n+\t  opts->x_ix86_isa_flags &= 0;\n \t}\n       else if (!orig_arch_specified)\n \topts->x_ix86_arch_string = NULL;\n@@ -6848,7 +6879,7 @@ ix86_valid_target_attribute_tree (tree args,\n \t}\n \n       /* Add any builtin functions with the new isa if any.  */\n-      ix86_add_new_builtins (opts->x_ix86_isa_flags);\n+      ix86_add_new_builtins (opts->x_ix86_isa_flags, opts->x_ix86_isa_flags2);\n \n       /* Save the current options unless we are validating options for\n \t #pragma.  */\n@@ -6953,8 +6984,10 @@ ix86_can_inline_p (tree caller, tree callee)\n       /* Callee's isa options should a subset of the caller's, i.e. a SSE4 function\n \t can inline a SSE2 function but a SSE2 function can't inline a SSE4\n \t function.  */\n-      if ((caller_opts->x_ix86_isa_flags & callee_opts->x_ix86_isa_flags)\n-\t  != callee_opts->x_ix86_isa_flags)\n+      if (((caller_opts->x_ix86_isa_flags & callee_opts->x_ix86_isa_flags)\n+\t  != callee_opts->x_ix86_isa_flags) &\n+\t  ((caller_opts->x_ix86_isa_flags2 & callee_opts->x_ix86_isa_flags2)\n+\t  != callee_opts->x_ix86_isa_flags2))\n \tret = false;\n \n       /* See if we have the same non-isa options.  */\n@@ -12078,6 +12111,15 @@ ix86_hard_regno_scratch_ok (unsigned int regno)\n \t      && df_regs_ever_live_p (regno)));\n }\n \n+/* Return true if register class CL should be an additional allocno\n+   class.  */\n+\n+static bool\n+ix86_additional_allocno_class_p (reg_class_t cl)\n+{\n+  return cl == MOD4_SSE_REGS;\n+}\n+\n /* Return TRUE if we need to save REGNO.  */\n \n static bool\n@@ -30836,6 +30878,7 @@ struct builtin_isa {\n   const char *name;\t\t/* function name */\n   enum ix86_builtin_func_type tcode; /* type to use in the declaration */\n   HOST_WIDE_INT isa;\t\t/* isa_flags this builtin is defined for */\n+  HOST_WIDE_INT isa2;\t\t/* additional isa_flags this builtin is defined for */\n   bool const_p;\t\t\t/* true if the declaration is constant */\n   bool leaf_p;\t\t\t/* true if the declaration has leaf attribute */\n   bool nothrow_p;\t\t/* true if the declaration has nothrow attribute */\n@@ -30846,6 +30889,7 @@ static struct builtin_isa ix86_builtins_isa[(int) IX86_BUILTIN_MAX];\n \n /* Bits that can still enable any inclusion of a builtin.  */\n static HOST_WIDE_INT deferred_isa_values = 0;\n+static HOST_WIDE_INT deferred_isa_values2 = 0;\n \n /* Add an ix86 target builtin function with CODE, NAME and TYPE.  Save the MASK\n    of which isa_flags to use in the ix86_builtins_isa array.  Stores the\n@@ -30928,26 +30972,83 @@ def_builtin_const (HOST_WIDE_INT mask, const char *name,\n   return decl;\n }\n \n+/* Like def_builtin, but for additional isa2 flags.  */\n+\n+static inline tree\n+def_builtin2 (HOST_WIDE_INT mask, const char *name,\n+\t     enum ix86_builtin_func_type tcode,\n+\t     enum ix86_builtins code)\n+{\n+  tree decl = NULL_TREE;\n+\n+  ix86_builtins_isa[(int) code].isa2 = mask;\n+\n+  if (mask == 0\n+      || (mask & ix86_isa_flags2) != 0\n+      || (lang_hooks.builtin_function\n+\t  == lang_hooks.builtin_function_ext_scope))\n+\n+    {\n+      tree type = ix86_get_builtin_func_type (tcode);\n+      decl = add_builtin_function (name, type, code, BUILT_IN_MD,\n+\t\t\t\t   NULL, NULL_TREE);\n+\t  ix86_builtins[(int) code] = decl;\n+\t  ix86_builtins_isa[(int) code].set_and_not_built_p = false;\n+    }\n+  else\n+    {\n+      /* Just a MASK where set_and_not_built_p == true can potentially\n+\t include a builtin.  */\n+      deferred_isa_values2 |= mask;\n+      ix86_builtins[(int) code] = NULL_TREE;\n+      ix86_builtins_isa[(int) code].tcode = tcode;\n+      ix86_builtins_isa[(int) code].name = name;\n+      ix86_builtins_isa[(int) code].leaf_p = false;\n+      ix86_builtins_isa[(int) code].nothrow_p = false;\n+      ix86_builtins_isa[(int) code].const_p = false;\n+      ix86_builtins_isa[(int) code].set_and_not_built_p = true;\n+    }\n+\n+  return decl;\n+}\n+\n+/* Like def_builtin, but also marks the function decl \"const\".  */\n+\n+static inline tree\n+def_builtin_const2 (HOST_WIDE_INT mask, const char *name,\n+\t\t   enum ix86_builtin_func_type tcode, enum ix86_builtins code)\n+{\n+  tree decl = def_builtin2 (mask, name, tcode, code);\n+  if (decl)\n+    TREE_READONLY (decl) = 1;\n+  else\n+    ix86_builtins_isa[(int) code].const_p = true;\n+\n+  return decl;\n+}\n+\n /* Add any new builtin functions for a given ISA that may not have been\n    declared.  This saves a bit of space compared to adding all of the\n    declarations to the tree, even if we didn't use them.  */\n \n static void\n-ix86_add_new_builtins (HOST_WIDE_INT isa)\n+ix86_add_new_builtins (HOST_WIDE_INT isa, HOST_WIDE_INT isa2)\n {\n-  if ((isa & deferred_isa_values) == 0)\n+  if (((isa & deferred_isa_values) == 0)\n+      && ((isa2 & deferred_isa_values2) == 0))\n     return;\n \n   /* Bits in ISA value can be removed from potential isa values.  */\n   deferred_isa_values &= ~isa;\n+  deferred_isa_values2 &= ~isa2;\n \n   int i;\n   tree saved_current_target_pragma = current_target_pragma;\n   current_target_pragma = NULL_TREE;\n \n   for (i = 0; i < (int)IX86_BUILTIN_MAX; i++)\n     {\n-      if ((ix86_builtins_isa[i].isa & isa) != 0\n+      if ((((ix86_builtins_isa[i].isa & isa) != 0) || ((ix86_builtins_isa[i].isa2 & isa2) != 0))\n \t  && ix86_builtins_isa[i].set_and_not_built_p)\n \t{\n \t  tree decl, type;\n@@ -31185,8 +31286,10 @@ BDESC_VERIFYS (IX86_BUILTIN__BDESC_ARGS_FIRST,\n \t       IX86_BUILTIN__BDESC_SPECIAL_ARGS_LAST, 1);\n BDESC_VERIFYS (IX86_BUILTIN__BDESC_ROUND_ARGS_FIRST,\n \t       IX86_BUILTIN__BDESC_ARGS_LAST, 1);\n-BDESC_VERIFYS (IX86_BUILTIN__BDESC_MPX_FIRST,\n+BDESC_VERIFYS (IX86_BUILTIN__BDESC_ARGS2_FIRST,\n \t       IX86_BUILTIN__BDESC_ROUND_ARGS_LAST, 1);\n+BDESC_VERIFYS (IX86_BUILTIN__BDESC_MPX_FIRST,\n+\t       IX86_BUILTIN__BDESC_ARGS2_LAST, 1);\n BDESC_VERIFYS (IX86_BUILTIN__BDESC_MPX_CONST_FIRST,\n \t       IX86_BUILTIN__BDESC_MPX_LAST, 1);\n BDESC_VERIFYS (IX86_BUILTIN__BDESC_MULTI_ARG_FIRST,\n@@ -31237,6 +31340,18 @@ ix86_init_mmx_sse_builtins (void)\n \t\t IX86_BUILTIN__BDESC_ARGS_FIRST,\n \t\t ARRAY_SIZE (bdesc_args) - 1);\n \n+  /* Add all builtins with variable number of operands.  */\n+  for (i = 0, d = bdesc_args2;\n+       i < ARRAY_SIZE (bdesc_args2);\n+       i++, d++)\n+    {\n+      if (d->name == 0)\n+\tcontinue;\n+\n+      ftype = (enum ix86_builtin_func_type) d->flag;\n+      def_builtin_const2 (d->mask, d->name, ftype, d->code);\n+    }\n+\n   /* Add all builtins with rounding.  */\n   for (i = 0, d = bdesc_round_args;\n        i < ARRAY_SIZE (bdesc_round_args);\n@@ -36428,10 +36543,13 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n      current ISA based on the command line switches.  With function specific\n      options, we need to check in the context of the function making the call\n      whether it is supported.  */\n-  if (ix86_builtins_isa[fcode].isa\n-      && !(ix86_builtins_isa[fcode].isa & ix86_isa_flags))\n+  if ((ix86_builtins_isa[fcode].isa\n+       && !(ix86_builtins_isa[fcode].isa & ix86_isa_flags))\n+      && (ix86_builtins_isa[fcode].isa2\n+\t  && !(ix86_builtins_isa[fcode].isa2 & ix86_isa_flags2)))\n     {\n-      char *opts = ix86_target_string (ix86_builtins_isa[fcode].isa, 0, 0,\n+      char *opts = ix86_target_string (ix86_builtins_isa[fcode].isa,\n+\t\t\t\t       ix86_builtins_isa[fcode].isa2, 0, 0,\n \t\t\t\t       NULL, NULL, (enum fpmath_unit) 0,\n \t\t\t\t       false);\n       if (!opts)\n@@ -38091,6 +38209,246 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n \t}\n     }\n \n+  if (fcode >= IX86_BUILTIN__BDESC_ARGS2_FIRST\n+      && fcode <= IX86_BUILTIN__BDESC_ARGS2_LAST)\n+    {\n+      i = fcode - IX86_BUILTIN__BDESC_ARGS2_FIRST;\n+      rtx (*fcn) (rtx, rtx, rtx, rtx);\n+      rtx (*fcn_mask) (rtx, rtx, rtx, rtx, rtx);\n+      rtx (*fcn_maskz) (rtx, rtx, rtx, rtx, rtx, rtx);\n+      rtx (*msk_mov) (rtx, rtx, rtx, rtx);\n+      int masked = 1;\n+      machine_mode mode, wide_mode, nar_mode;\n+\n+      nar_mode  = V4SFmode;\n+      mode      = V16SFmode;\n+      wide_mode = V64SFmode;\n+      msk_mov   = gen_avx512f_loadv16sf_mask;\n+      fcn_mask  = gen_avx5124fmaddps_4fmaddps_mask;\n+      fcn_maskz = gen_avx5124fmaddps_4fmaddps_maskz;\n+\n+      switch (fcode)\n+\t{\n+\tcase IX86_BUILTIN_4FMAPS:\n+\t  fcn = gen_avx5124fmaddps_4fmaddps;\n+\t  masked = 0;\n+\t  goto v4fma_expand;\n+\n+\tcase IX86_BUILTIN_4DPWSSD:\n+\t  nar_mode  = V4SImode;\n+\t  mode      = V16SImode;\n+\t  wide_mode = V64SImode;\n+\t  fcn = gen_avx5124vnniw_vp4dpwssd;\n+\t  masked = 0;\n+\t  goto v4fma_expand;\n+\n+\tcase IX86_BUILTIN_4DPWSSDS:\n+\t  nar_mode  = V4SImode;\n+\t  mode      = V16SImode;\n+\t  wide_mode = V64SImode;\n+\t  fcn = gen_avx5124vnniw_vp4dpwssds;\n+\t  masked = 0;\n+\t  goto v4fma_expand;\n+\n+\tcase IX86_BUILTIN_4FNMAPS:\n+\t  fcn = gen_avx5124fmaddps_4fnmaddps;\n+\t  masked = 0;\n+\t  goto v4fma_expand;\n+\n+\tcase IX86_BUILTIN_4FNMAPS_MASK:\n+\t  fcn_mask  = gen_avx5124fmaddps_4fnmaddps_mask;\n+\t  fcn_maskz = gen_avx5124fmaddps_4fnmaddps_maskz;\n+\t  goto v4fma_expand;\n+\n+\tcase IX86_BUILTIN_4DPWSSD_MASK:\n+\t  nar_mode  = V4SImode;\n+\t  mode      = V16SImode;\n+\t  wide_mode = V64SImode;\n+\t  fcn_mask  = gen_avx5124vnniw_vp4dpwssd_mask;\n+\t  fcn_maskz = gen_avx5124vnniw_vp4dpwssd_maskz;\n+\t  msk_mov   = gen_avx512f_loadv16si_mask;\n+\t  goto v4fma_expand;\n+\n+\tcase IX86_BUILTIN_4DPWSSDS_MASK:\n+\t  nar_mode  = V4SImode;\n+\t  mode      = V16SImode;\n+\t  wide_mode = V64SImode;\n+\t  fcn_mask  = gen_avx5124vnniw_vp4dpwssds_mask;\n+\t  fcn_maskz = gen_avx5124vnniw_vp4dpwssds_maskz;\n+\t  msk_mov   = gen_avx512f_loadv16si_mask;\n+\t  goto v4fma_expand;\n+\n+\tcase IX86_BUILTIN_4FMAPS_MASK:\n+\t  {\n+\t    tree args[4];\n+\t    rtx ops[4];\n+\t    rtx wide_reg;\n+\t    rtx accum;\n+\t    rtx addr;\n+\t    rtx mem;\n+\n+v4fma_expand:\n+\t    wide_reg = gen_reg_rtx (wide_mode);\n+\t    for (i = 0; i < 4; i++)\n+\t      {\n+\t        args[i] = CALL_EXPR_ARG (exp, i);\n+\t\tops[i] = expand_normal (args[i]);\n+\n+\t\temit_move_insn (gen_rtx_SUBREG (mode, wide_reg, (i) * 64),\n+\t\t\t\t  ops[i]);\n+\t      }\n+\n+\t    accum = expand_normal (CALL_EXPR_ARG (exp, 4));\n+\t    accum = force_reg (mode, accum);\n+\n+\t    addr = expand_normal (CALL_EXPR_ARG (exp, 5));\n+\t    addr = force_reg (Pmode, addr);\n+\n+\t    mem = gen_rtx_MEM (nar_mode, addr);\n+\n+\t    target = gen_reg_rtx (mode);\n+\n+\t    emit_move_insn (target, accum);\n+\n+\t    if (! masked)\n+\t      emit_insn (fcn (target, accum, wide_reg, mem));\n+\t    else\n+\t      {\n+\t        rtx merge, mask;\n+\t\tmerge = expand_normal (CALL_EXPR_ARG (exp, 6));\n+\n+\t\tmask = expand_normal (CALL_EXPR_ARG (exp, 7));\n+\n+\t\tif (CONST_INT_P (mask))\n+\t\t  mask = fixup_modeless_constant (mask, HImode);\n+\n+\t\tmask = force_reg (HImode, mask);\n+\n+\t\tif (GET_MODE (mask) != HImode)\n+\t\t  mask = gen_rtx_SUBREG (HImode, mask, 0);\n+\n+\t\t/* If merge is 0 then we're about to emit z-masked variant.  */\n+\t\tif (const0_operand (merge, mode))\n+\t\t  emit_insn (fcn_maskz (target, accum, wide_reg, mem, merge, mask));\n+\t\t/* If merge is the same as accum then emit merge-masked variant.  */\n+\t\telse if (CALL_EXPR_ARG (exp, 6) == CALL_EXPR_ARG (exp, 4))\n+\t\t  {\n+\t\t    merge = force_reg (mode, merge);\n+\t\t    emit_insn (fcn_mask (target, wide_reg, mem, merge, mask));\n+\t\t  }\n+\t        /* Merge with something unknown might happen if we z-mask w/ -O0.  */\n+\t\telse\n+\t\t  {\n+\t\t    rtx tmp = target;\n+\t\t    emit_insn (fcn_mask (tmp, wide_reg, mem, tmp, mask));\n+\n+\t\t    target = force_reg (mode, merge);\n+\t\t    emit_insn (msk_mov (target, tmp, target, mask));\n+\t\t  }\n+\t      }\n+\t      return target;\n+\t    }\n+\n+\tcase IX86_BUILTIN_4FNMASS:\n+\t  fcn = gen_avx5124fmaddps_4fnmaddss;\n+\t  masked = 0;\n+\t  goto s4fma_expand;\n+\n+\tcase IX86_BUILTIN_4FMASS:\n+\t  fcn = gen_avx5124fmaddps_4fmaddss;\n+\t  masked = 0;\n+\t  goto s4fma_expand;\n+\n+\tcase IX86_BUILTIN_4FNMASS_MASK:\n+\t  fcn_mask = gen_avx5124fmaddps_4fnmaddss_mask;\n+\t  fcn_maskz = gen_avx5124fmaddps_4fnmaddss_maskz;\n+\t  msk_mov   = gen_avx512vl_loadv4sf_mask;\n+\t  goto s4fma_expand;\n+\n+\tcase IX86_BUILTIN_4FMASS_MASK:\n+\t  {\n+\t    tree args[4];\n+\t    rtx ops[4];\n+\t    rtx wide_reg;\n+\t    rtx accum;\n+\t    rtx addr;\n+\t    rtx mem;\n+\n+\t    fcn_mask = gen_avx5124fmaddps_4fmaddss_mask;\n+\t    fcn_maskz = gen_avx5124fmaddps_4fmaddss_maskz;\n+\t    msk_mov   = gen_avx512vl_loadv4sf_mask;\n+\n+s4fma_expand:\n+\t    mode = V4SFmode;\n+\t    wide_reg = gen_reg_rtx (V64SFmode);\n+\t    for (i = 0; i < 4; i++)\n+\t      {\n+\t\t rtx tmp;\n+\t\t args[i] = CALL_EXPR_ARG (exp, i);\n+\t\t ops[i] = expand_normal (args[i]);\n+\n+\t\t tmp = gen_reg_rtx (SFmode);\n+\t\t emit_move_insn (tmp, gen_rtx_SUBREG (SFmode, ops[i], 0));\n+\n+\t\t emit_move_insn (gen_rtx_SUBREG (V16SFmode, wide_reg, i * 64),\n+\t\t\t\t  gen_rtx_SUBREG (V16SFmode, tmp, 0));\n+\t      }\n+\n+\t    accum = expand_normal (CALL_EXPR_ARG (exp, 4));\n+\t    accum = force_reg (V4SFmode, accum);\n+\n+\t    addr = expand_normal (CALL_EXPR_ARG (exp, 5));\n+\t    addr = force_reg (Pmode, addr);\n+\n+\t    mem = gen_rtx_MEM (V4SFmode, addr);\n+\n+\t    target = gen_reg_rtx (V4SFmode);\n+\n+\t    emit_move_insn (target, accum);\n+\n+\t    if (! masked)\n+\t      emit_insn (fcn (target, accum, wide_reg, mem));\n+\t    else\n+\t      {\n+\t\t rtx merge, mask;\n+\t\t merge = expand_normal (CALL_EXPR_ARG (exp, 6));\n+\n+\t\t mask = expand_normal (CALL_EXPR_ARG (exp, 7));\n+\n+\t\t if (CONST_INT_P (mask))\n+\t\t   mask = fixup_modeless_constant (mask, QImode);\n+\n+\t\t mask = force_reg (QImode, mask);\n+\n+\t\t if (GET_MODE (mask) != QImode)\n+\t\t   mask = gen_rtx_SUBREG (QImode, mask, 0);\n+\n+\t\t /* If merge is 0 then we're about to emit z-masked variant.  */\n+\t\t if (const0_operand (merge, mode))\n+\t\t   emit_insn (fcn_maskz (target, accum, wide_reg, mem, merge, mask));\n+\t\t /* If merge is the same as accum then emit merge-masked variant.  */\n+\t\t else if (CALL_EXPR_ARG (exp, 6) == CALL_EXPR_ARG (exp, 4))\n+\t\t   {\n+\t\t     merge = force_reg (mode, merge);\n+\t\t     emit_insn (fcn_mask (target, wide_reg, mem, merge, mask));\n+\t\t   }\n+\t\t /* Merge with something unknown might happen if we z-mask w/ -O0.  */\n+\t\t else\n+\t\t   {\n+\t\t     rtx tmp = target;\n+\t\t     emit_insn (fcn_mask (tmp, wide_reg, mem, tmp, mask));\n+\n+\t\t     target = force_reg (mode, merge);\n+\t\t     emit_insn (msk_mov (target, tmp, target, mask));\n+\t\t   }\n+\t\t}\n+\t      return target;\n+\t    }\n+\t  default:\n+\t    return ix86_expand_args_builtin (bdesc_args2 + i, exp, target);\n+\t  }\n+    }\n+\n   if (fcode >= IX86_BUILTIN__BDESC_COMI_FIRST\n       && fcode <= IX86_BUILTIN__BDESC_COMI_LAST)\n     {\n@@ -38151,7 +38509,8 @@ static tree ix86_get_builtin (enum ix86_builtins code)\n \n   opts = TREE_TARGET_OPTION (target_tree);\n \n-  if (ix86_builtins_isa[(int) code].isa & opts->x_ix86_isa_flags)\n+  if ((ix86_builtins_isa[(int) code].isa & opts->x_ix86_isa_flags)\n+\t&& (ix86_builtins_isa[(int) code].isa2 & opts->x_ix86_isa_flags2))\n     return ix86_builtin_decl (code, true);\n   else\n     return NULL_TREE;\n@@ -39735,6 +40094,18 @@ ix86_hard_regno_mode_ok (int regno, machine_mode mode)\n \t      || VALID_AVX512F_SCALAR_MODE (mode)))\n \treturn true;\n \n+      /* For AVX-5124FMAPS allow V64SFmode for special regnos.  */\n+      if ((TARGET_AVX5124FMAPS || TARGET_AVX5124VNNIW)\n+\t  && MOD4_SSE_REGNO_P (regno)\n+\t  && mode == V64SFmode)\n+\treturn true;\n+\n+      /* For AVX-5124VNNIW allow V64SImode for special regnos.  */\n+      if ((TARGET_AVX5124FMAPS || TARGET_AVX5124VNNIW)\n+\t  && MOD4_SSE_REGNO_P (regno)\n+\t  && mode == V64SImode)\n+\treturn true;\n+\n       /* TODO check for QI/HI scalars.  */\n       /* AVX512VL allows sse regs16+ for 128/256 bit modes.  */\n       if (TARGET_AVX512VL\n@@ -51134,6 +51505,9 @@ ix86_run_selftests (void)\n #undef TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n #define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 1\n \n+#undef TARGET_ADDITIONAL_ALLOCNO_CLASS_P\n+#define TARGET_ADDITIONAL_ALLOCNO_CLASS_P ix86_additional_allocno_class_p\n+\n #undef TARGET_ADDR_SPACE_ZERO_ADDRESS_VALID\n #define TARGET_ADDR_SPACE_ZERO_ADDRESS_VALID ix86_addr_space_zero_address_valid\n "}, {"sha": "05d197c1518deac35f4b48f3c695ba5ff2f5729b", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -81,6 +81,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define TARGET_AVX512VBMI_P(x)\tTARGET_ISA_AVX512VBMI_P(x)\n #define TARGET_AVX512IFMA\tTARGET_ISA_AVX512IFMA\n #define TARGET_AVX512IFMA_P(x)\tTARGET_ISA_AVX512IFMA_P(x)\n+#define TARGET_AVX5124FMAPS\tTARGET_ISA_AVX5124FMAPS\n+#define TARGET_AVX5124FMAPS_P(x) TARGET_ISA_AVX5124FMAPS_P(x)\n+#define TARGET_AVX5124VNNIW\tTARGET_ISA_AVX5124VNNIW\n+#define TARGET_AVX5124VNNIW_P(x) TARGET_ISA_AVX5124VNNIW_P(x)\n #define TARGET_FMA\tTARGET_ISA_FMA\n #define TARGET_FMA_P(x)\tTARGET_ISA_FMA_P(x)\n #define TARGET_SSE4A\tTARGET_ISA_SSE4A\n@@ -1089,7 +1093,8 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n   (STACK_REGNO_P (REGNO) || SSE_REGNO_P (REGNO) || MMX_REGNO_P (REGNO)\t\\\n    || MASK_REGNO_P (REGNO) || BND_REGNO_P (REGNO)\t\t\t\\\n-   ? (COMPLEX_MODE_P (MODE) ? 2 : 1)\t\t\t\t\t\\\n+   ? (COMPLEX_MODE_P (MODE) ? 2 :\t\t\t\t\t\\\n+      (((MODE == V64SFmode) || (MODE == V64SImode)) ? 4 : 1))\t\t\\\n    : ((MODE) == XFmode\t\t\t\t\t\t\t\\\n       ? (TARGET_64BIT ? 2 : 3)\t\t\t\t\t\t\\\n       : ((MODE) == XCmode\t\t\t\t\t\t\\\n@@ -1365,6 +1370,7 @@ enum reg_class\n   FLOAT_INT_SSE_REGS,\n   MASK_EVEX_REGS,\n   MASK_REGS,\n+  MOD4_SSE_REGS,\n   ALL_REGS, LIM_REG_CLASSES\n };\n \n@@ -1425,6 +1431,7 @@ enum reg_class\n    \"FLOAT_INT_SSE_REGS\",\t\t\\\n    \"MASK_EVEX_REGS\",\t\t\t\\\n    \"MASK_REGS\",\t\t\t\t\\\n+   \"MOD4_SSE_REGS\"\t\t\t\\\n    \"ALL_REGS\" }\n \n /* Define which registers fit in which classes.  This is an initializer\n@@ -1465,9 +1472,10 @@ enum reg_class\n {   0x11ffff,    0x1fe0,    0x0 },       /* FLOAT_INT_REGS */            \\\n { 0x1ff100ff,0xffffffe0,   0x1f },       /* INT_SSE_REGS */              \\\n { 0x1ff1ffff,0xffffffe0,   0x1f },       /* FLOAT_INT_SSE_REGS */        \\\n-       { 0x0,       0x0, 0x1fc0 },       /* MASK_EVEX_REGS */           \\\n+       { 0x0,       0x0, 0x1fc0 },       /* MASK_EVEX_REGS */            \\\n        { 0x0,       0x0, 0x1fe0 },       /* MASK_REGS */                 \\\n-{ 0xffffffff,0xffffffff,0x1ffff }                                        \\\n+{ 0x1fe00000,0xffffe000,   0x1f },       /* MOD4_SSE_REGS */\t\t \\\n+{ 0xffffffff,0xffffffff,0x1ffff }\t\t\\\n }\n \n /* The same information, inverted:\n@@ -1533,6 +1541,16 @@ enum reg_class\n #define BND_REG_P(X) (REG_P (X) && BND_REGNO_P (REGNO (X)))\n #define BND_REGNO_P(N) IN_RANGE ((N), FIRST_BND_REG, LAST_BND_REG)\n \n+#define MOD4_SSE_REG_P(X) (REG_P (X) && MOD4_SSE_REGNO_P (REGNO (X)))\n+#define MOD4_SSE_REGNO_P(N) ((N) == XMM0_REG  \\\n+\t\t\t     || (N) == XMM4_REG  \\\n+\t\t\t     || (N) == XMM8_REG  \\\n+\t\t\t     || (N) == XMM12_REG \\\n+\t\t\t     || (N) == XMM16_REG \\\n+\t\t\t     || (N) == XMM20_REG \\\n+\t\t\t     || (N) == XMM24_REG \\\n+\t\t\t     || (N) == XMM28_REG)\n+\n /* First floating point reg */\n #define FIRST_FLOAT_REG FIRST_STACK_REG\n #define STACK_TOP_P(X) (REG_P (X) && REGNO (X) == FIRST_FLOAT_REG)"}, {"sha": "390412a37fdf432c00eb8ab5b6762412eb1b9d5f", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -25,11 +25,17 @@ config/i386/i386-opts.h\n Variable\n HOST_WIDE_INT ix86_isa_flags = TARGET_64BIT_DEFAULT | TARGET_SUBTARGET_ISA_DEFAULT\n \n+Variable\n+HOST_WIDE_INT ix86_isa_flags2 = 0\n+\n ; A mask of ix86_isa_flags that includes bit X if X was set or cleared\n ; on the command line.\n Variable\n HOST_WIDE_INT ix86_isa_flags_explicit\n \n+Variable\n+HOST_WIDE_INT ix86_isa_flags2_explicit\n+\n ; Additional target flags\n Variable\n int ix86_target_flags\n@@ -72,6 +78,10 @@ unsigned char prefetch_sse\n TargetSave\n unsigned char branch_cost\n \n+;; which flags were passed by the user\n+TargetSave\n+HOST_WIDE_INT x_ix86_isa_flags2_explicit\n+\n ;; which flags were passed by the user\n TargetSave\n HOST_WIDE_INT x_ix86_isa_flags_explicit\n@@ -687,6 +697,14 @@ mavx512vbmi\n Target Report Mask(ISA_AVX512VBMI) Var(ix86_isa_flags) Save\n Support MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX, AVX2 and AVX512F and AVX512VBMI built-in functions and code generation.\n \n+mavx5124fmaps\n+Target Report Mask(ISA_AVX5124FMAPS) Var(ix86_isa_flags2) Save\n+Support MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX, AVX2, AVX512F and AVX5124FMAPS built-in functions and code generation.\n+\n+mavx5124vnniw\n+Target Report Mask(ISA_AVX5124VNNIW) Var(ix86_isa_flags2) Save\n+Support MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX, AVX2, AVX512F and AVX5124VNNIW built-in functions and code generation.\n+\n mfma\n Target Report Mask(ISA_FMA) Var(ix86_isa_flags) Save\n Support MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX and FMA built-in functions and code generation."}, {"sha": "3fd3c9c3e00e6d373d9c495aedf20d3e78414445", "filename": "gcc/config/i386/immintrin.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fimmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fimmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fimmintrin.h?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -68,6 +68,10 @@\n \n #include <avx512vbmivlintrin.h>\n \n+#include <avx5124fmapsintrin.h>\n+\n+#include <avx5124vnniwintrin.h>\n+\n #include <shaintrin.h>\n \n #include <lzcntintrin.h>"}, {"sha": "81fcc1d5df0d031f0d1cf37e160fa82dc085a98b", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -146,6 +146,12 @@\n \n   ;; For AVX512VBMI support\n   UNSPEC_VPMULTISHIFT\n+\n+  ;; For AVX5124FMAPS/AVX5124VNNIW support\n+  UNSPEC_VP4FMADD\n+  UNSPEC_VP4FNMADD\n+  UNSPEC_VP4DPWSSD\n+  UNSPEC_VP4DPWSSDS\n ])\n \n (define_c_enum \"unspecv\" [\n@@ -19397,3 +19403,274 @@\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n+\n+(define_mode_iterator IMOD4\n+  [(V64SF \"TARGET_AVX5124FMAPS\") (V64SI \"TARGET_AVX5124VNNIW\")])\n+\n+(define_mode_attr imod4_narrow\n+  [(V64SF \"V16SF\") (V64SI \"V16SI\")])\n+\n+(define_insn \"mov<mode>\"\n+  [(set (match_operand:IMOD4 0 \"nonimmediate_operand\")\n+\t(match_operand:IMOD4 1 \"general_operand\"))]\n+  \"TARGET_AVX512F\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:IMOD4 0 \"register_operand\")\n+\t(match_operand:IMOD4 1 \"nonimmediate_operand\"))]\n+  \"TARGET_AVX512F && reload_completed\"\n+  [(set (subreg:<imod4_narrow> (match_dup 0) 0)\n+\t(subreg:<imod4_narrow> (match_dup 1) 0))\n+   (set (subreg:<imod4_narrow> (match_dup 0) 64)\n+\t(subreg:<imod4_narrow> (match_dup 1) 64))\n+   (set (subreg:<imod4_narrow> (match_dup 0) 128)\n+\t(subreg:<imod4_narrow> (match_dup 1) 128))\n+   (set (subreg:<imod4_narrow> (match_dup 0) 192)\n+\t(subreg:<imod4_narrow> (match_dup 1) 192))])\n+\n+(define_insn \"avx5124fmaddps_4fmaddps\"\n+  [(set (match_operand:V16SF 0 \"register_operand\" \"=v\")\n+\t(unspec:V16SF\n+\t  [(match_operand:V16SF 1 \"register_operand\" \"0\")\n+\t   (match_operand:V64SF 2 \"register_operand\" \"Yh\")\n+\t   (match_operand:V4SF 3 \"memory_operand\" \"m\")] UNSPEC_VP4FMADD))]\n+  \"TARGET_AVX5124FMAPS\"\n+  \"v4fmaddps\\t{%3, %g2, %0|%0, %g2, %3}\"\n+   [(set_attr (\"type\") (\"ssemuladd\"))\n+    (set_attr (\"prefix\") (\"evex\"))\n+    (set_attr (\"mode\") (\"V16SF\"))])\n+\n+(define_insn \"avx5124fmaddps_4fmaddps_mask\"\n+  [(set (match_operand:V16SF 0 \"register_operand\" \"=v\")\n+\t(vec_merge:V16SF\n+\t  (unspec:V16SF\n+\t     [(match_operand:V64SF 1 \"register_operand\" \"Yh\")\n+\t      (match_operand:V4SF 2 \"memory_operand\" \"m\")] UNSPEC_VP4FMADD)\n+\t  (match_operand:V16SF 3 \"register_operand\" \"0\")\n+\t  (match_operand:HI 4 \"register_operand\" \"Yk\")))]\n+  \"TARGET_AVX5124FMAPS\"\n+  \"v4fmaddps\\t{%2, %g1, %0%{%4%}|%{%4%}%0, %g1, %2}\"\n+   [(set_attr (\"type\") (\"ssemuladd\"))\n+    (set_attr (\"prefix\") (\"evex\"))\n+    (set_attr (\"mode\") (\"V16SF\"))])\n+\n+(define_insn \"avx5124fmaddps_4fmaddps_maskz\"\n+  [(set (match_operand:V16SF 0 \"register_operand\" \"=v\")\n+\t(vec_merge:V16SF\n+\t  (unspec:V16SF\n+\t    [(match_operand:V16SF 1 \"register_operand\" \"0\")\n+\t     (match_operand:V64SF 2 \"register_operand\" \"Yh\")\n+\t     (match_operand:V4SF 3 \"memory_operand\" \"m\")] UNSPEC_VP4FMADD)\n+\t  (match_operand:V16SF 4 \"const0_operand\" \"C\")\n+\t  (match_operand:HI 5 \"register_operand\" \"Yk\")))]\n+  \"TARGET_AVX5124FMAPS\"\n+  \"v4fmaddps\\t{%3, %g2, %0%{%5%}%{z%}|%{%5%}%{z%}%0, %g2, %3}\"\n+   [(set_attr (\"type\") (\"ssemuladd\"))\n+    (set_attr (\"prefix\") (\"evex\"))\n+    (set_attr (\"mode\") (\"V16SF\"))])\n+\n+(define_insn \"avx5124fmaddps_4fmaddss\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+\t(unspec:V4SF\n+\t  [(match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t   (match_operand:V64SF 2 \"register_operand\" \"Yh\")\n+\t   (match_operand:V4SF 3 \"memory_operand\" \"m\")] UNSPEC_VP4FMADD))]\n+  \"TARGET_AVX5124FMAPS\"\n+  \"v4fmaddss\\t{%3, %x2, %0|%0, %x2, %3}\"\n+   [(set_attr (\"type\") (\"ssemuladd\"))\n+    (set_attr (\"prefix\") (\"evex\"))\n+    (set_attr (\"mode\") (\"SF\"))])\n+\n+(define_insn \"avx5124fmaddps_4fmaddss_mask\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+\t(vec_merge:V4SF\n+\t  (unspec:V4SF\n+\t    [(match_operand:V64SF 1 \"register_operand\" \"Yh\")\n+\t     (match_operand:V4SF 2 \"memory_operand\" \"m\")] UNSPEC_VP4FMADD)\n+\t  (match_operand:V4SF 3 \"register_operand\" \"0\")\n+\t  (match_operand:QI 4 \"register_operand\" \"Yk\")))]\n+  \"TARGET_AVX5124FMAPS\"\n+  \"v4fmaddss\\t{%2, %x1, %0%{%4%}|%{%4%}%0, %x1, %2}\"\n+   [(set_attr (\"type\") (\"ssemuladd\"))\n+    (set_attr (\"prefix\") (\"evex\"))\n+    (set_attr (\"mode\") (\"SF\"))])\n+\n+(define_insn \"avx5124fmaddps_4fmaddss_maskz\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+\t(vec_merge:V4SF\n+\t  (unspec:V4SF\n+\t    [(match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t     (match_operand:V64SF 2 \"register_operand\" \"Yh\")\n+\t     (match_operand:V4SF 3 \"memory_operand\" \"m\")] UNSPEC_VP4FMADD)\n+\t  (match_operand:V4SF 4 \"const0_operand\" \"C\")\n+\t  (match_operand:QI 5 \"register_operand\" \"Yk\")))]\n+  \"TARGET_AVX5124FMAPS\"\n+  \"v4fmaddss\\t{%3, %x2, %0%{%5%}%{z%}|%{%5%}%{z%}%0, %x2, %3}\"\n+   [(set_attr (\"type\") (\"ssemuladd\"))\n+    (set_attr (\"prefix\") (\"evex\"))\n+    (set_attr (\"mode\") (\"SF\"))])\n+\n+(define_insn \"avx5124fmaddps_4fnmaddps\"\n+  [(set (match_operand:V16SF 0 \"register_operand\" \"=v\")\n+\t(unspec:V16SF\n+\t  [(match_operand:V16SF 1 \"register_operand\" \"0\")\n+\t   (match_operand:V64SF 2 \"register_operand\" \"Yh\")\n+\t   (match_operand:V4SF 3 \"memory_operand\" \"m\")] UNSPEC_VP4FNMADD))]\n+  \"TARGET_AVX5124FMAPS\"\n+  \"v4fnmaddps\\t{%3, %g2, %0|%0, %g2, %3}\"\n+   [(set_attr (\"type\") (\"ssemuladd\"))\n+    (set_attr (\"prefix\") (\"evex\"))\n+    (set_attr (\"mode\") (\"V16SF\"))])\n+\n+(define_insn \"avx5124fmaddps_4fnmaddps_mask\"\n+  [(set (match_operand:V16SF 0 \"register_operand\" \"=v\")\n+\t(vec_merge:V16SF\n+\t  (unspec:V16SF\n+\t     [(match_operand:V64SF 1 \"register_operand\" \"Yh\")\n+\t      (match_operand:V4SF 2 \"memory_operand\" \"m\")] UNSPEC_VP4FNMADD)\n+\t  (match_operand:V16SF 3 \"register_operand\" \"0\")\n+\t  (match_operand:HI 4 \"register_operand\" \"Yk\")))]\n+  \"TARGET_AVX5124FMAPS\"\n+  \"v4fnmaddps\\t{%2, %g1, %0%{%4%}|%{%4%}%0, %g1, %2}\"\n+   [(set_attr (\"type\") (\"ssemuladd\"))\n+    (set_attr (\"prefix\") (\"evex\"))\n+    (set_attr (\"mode\") (\"V16SF\"))])\n+\n+(define_insn \"avx5124fmaddps_4fnmaddps_maskz\"\n+  [(set (match_operand:V16SF 0 \"register_operand\" \"=v\")\n+\t(vec_merge:V16SF\n+\t  (unspec:V16SF\n+\t    [(match_operand:V16SF 1 \"register_operand\" \"0\")\n+\t     (match_operand:V64SF 2 \"register_operand\" \"Yh\")\n+\t     (match_operand:V4SF 3 \"memory_operand\" \"m\")] UNSPEC_VP4FNMADD)\n+\t  (match_operand:V16SF 4 \"const0_operand\" \"C\")\n+\t  (match_operand:HI 5 \"register_operand\" \"Yk\")))]\n+  \"TARGET_AVX5124FMAPS\"\n+  \"v4fnmaddps\\t{%3, %g2, %0%{%5%}%{z%}|%{%5%}%{z%}%0, %g2, %3}\"\n+   [(set_attr (\"type\") (\"ssemuladd\"))\n+    (set_attr (\"prefix\") (\"evex\"))\n+    (set_attr (\"mode\") (\"V16SF\"))])\n+\n+(define_insn \"avx5124fmaddps_4fnmaddss\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+\t(unspec:V4SF\n+\t  [(match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t   (match_operand:V64SF 2 \"register_operand\" \"Yh\")\n+\t   (match_operand:V4SF 3 \"memory_operand\" \"m\")] UNSPEC_VP4FNMADD))]\n+  \"TARGET_AVX5124FMAPS\"\n+  \"v4fnmaddss\\t{%3, %x2, %0|%0, %x2, %3}\"\n+   [(set_attr (\"type\") (\"ssemuladd\"))\n+    (set_attr (\"prefix\") (\"evex\"))\n+    (set_attr (\"mode\") (\"SF\"))])\n+\n+(define_insn \"avx5124fmaddps_4fnmaddss_mask\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+\t(vec_merge:V4SF\n+\t  (unspec:V4SF\n+\t    [(match_operand:V64SF 1 \"register_operand\" \"Yh\")\n+\t     (match_operand:V4SF 2 \"memory_operand\" \"m\")] UNSPEC_VP4FNMADD)\n+\t  (match_operand:V4SF 3 \"register_operand\" \"0\")\n+\t  (match_operand:QI 4 \"register_operand\" \"Yk\")))]\n+  \"TARGET_AVX5124FMAPS\"\n+  \"v4fnmaddss\\t{%2, %x1, %0%{%4%}|%{%4%}%0, %x1, %2}\"\n+   [(set_attr (\"type\") (\"ssemuladd\"))\n+    (set_attr (\"prefix\") (\"evex\"))\n+    (set_attr (\"mode\") (\"SF\"))])\n+\n+(define_insn \"avx5124fmaddps_4fnmaddss_maskz\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+\t(vec_merge:V4SF\n+\t  (unspec:V4SF\n+\t    [(match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t     (match_operand:V64SF 2 \"register_operand\" \"Yh\")\n+\t     (match_operand:V4SF 3 \"memory_operand\" \"m\")] UNSPEC_VP4FNMADD)\n+\t  (match_operand:V4SF 4 \"const0_operand\" \"C\")\n+\t  (match_operand:QI 5 \"register_operand\" \"Yk\")))]\n+  \"TARGET_AVX5124FMAPS\"\n+  \"v4fnmaddss\\t{%3, %x2, %0%{%5%}%{z%}|%{%5%}%{z%}%0, %x2, %3}\"\n+   [(set_attr (\"type\") (\"ssemuladd\"))\n+    (set_attr (\"prefix\") (\"evex\"))\n+    (set_attr (\"mode\") (\"SF\"))])\n+\n+(define_insn \"avx5124vnniw_vp4dpwssd\"\n+  [(set (match_operand:V16SI 0 \"register_operand\" \"=v\")\n+\t(unspec:V16SI\n+\t  [(match_operand:V16SI 1 \"register_operand\" \"0\")\n+\t   (match_operand:V64SI 2 \"register_operand\" \"Yh\")\n+\t   (match_operand:V4SI 3 \"memory_operand\" \"m\")] UNSPEC_VP4DPWSSD))]\n+  \"TARGET_AVX5124VNNIW\"\n+  \"vp4dpwssd\\t{%3, %g2, %0|%0, %g2, %3}\"\n+   [(set_attr (\"type\") (\"ssemuladd\"))\n+    (set_attr (\"prefix\") (\"evex\"))\n+    (set_attr (\"mode\") (\"TI\"))])\n+\n+(define_insn \"avx5124vnniw_vp4dpwssd_mask\"\n+  [(set (match_operand:V16SI 0 \"register_operand\" \"=v\")\n+\t(vec_merge:V16SI\n+\t  (unspec:V16SI\n+\t     [(match_operand:V64SI 1 \"register_operand\" \"Yh\")\n+\t      (match_operand:V4SI 2 \"memory_operand\" \"m\")] UNSPEC_VP4DPWSSD)\n+\t  (match_operand:V16SI 3 \"register_operand\" \"0\")\n+\t  (match_operand:HI 4 \"register_operand\" \"Yk\")))]\n+  \"TARGET_AVX5124VNNIW\"\n+  \"vp4dpwssd\\t{%2, %g1, %0%{%4%}|%{%4%}%0, %g1, %2}\"\n+   [(set_attr (\"type\") (\"ssemuladd\"))\n+    (set_attr (\"prefix\") (\"evex\"))\n+    (set_attr (\"mode\") (\"TI\"))])\n+\n+(define_insn \"avx5124vnniw_vp4dpwssd_maskz\"\n+  [(set (match_operand:V16SI 0 \"register_operand\" \"=v\")\n+\t(vec_merge:V16SI\n+\t  (unspec:V16SI\n+\t    [(match_operand:V16SI 1 \"register_operand\" \"0\")\n+\t     (match_operand:V64SI 2 \"register_operand\" \"Yh\")\n+\t     (match_operand:V4SI 3 \"memory_operand\" \"m\")] UNSPEC_VP4DPWSSD)\n+\t  (match_operand:V16SI 4 \"const0_operand\" \"C\")\n+\t  (match_operand:HI 5 \"register_operand\" \"Yk\")))]\n+  \"TARGET_AVX5124VNNIW\"\n+  \"vp4dpwssd\\t{%3, %g2, %0%{%5%}%{z%}|%{%5%}%{z%}%0, %g2, %3}\"\n+   [(set_attr (\"type\") (\"ssemuladd\"))\n+    (set_attr (\"prefix\") (\"evex\"))\n+    (set_attr (\"mode\") (\"TI\"))])\n+\n+(define_insn \"avx5124vnniw_vp4dpwssds\"\n+  [(set (match_operand:V16SI 0 \"register_operand\" \"=v\")\n+\t(unspec:V16SI\n+\t  [(match_operand:V16SI 1 \"register_operand\" \"0\")\n+\t   (match_operand:V64SI 2 \"register_operand\" \"Yh\")\n+\t   (match_operand:V4SI 3 \"memory_operand\" \"m\")] UNSPEC_VP4DPWSSDS))]\n+  \"TARGET_AVX5124VNNIW\"\n+  \"vp4dpwssds\\t{%3, %g2, %0|%0, %g2, %3}\"\n+   [(set_attr (\"type\") (\"ssemuladd\"))\n+    (set_attr (\"prefix\") (\"evex\"))\n+    (set_attr (\"mode\") (\"TI\"))])\n+\n+(define_insn \"avx5124vnniw_vp4dpwssds_mask\"\n+  [(set (match_operand:V16SI 0 \"register_operand\" \"=v\")\n+\t(vec_merge:V16SI\n+\t  (unspec:V16SI\n+\t     [(match_operand:V64SI 1 \"register_operand\" \"Yh\")\n+\t      (match_operand:V4SI 2 \"memory_operand\" \"m\")] UNSPEC_VP4DPWSSDS)\n+\t  (match_operand:V16SI 3 \"register_operand\" \"0\")\n+\t  (match_operand:HI 4 \"register_operand\" \"Yk\")))]\n+  \"TARGET_AVX5124VNNIW\"\n+  \"vp4dpwssds\\t{%2, %g1, %0%{%4%}|%{%4%}%0, %g1, %2}\"\n+   [(set_attr (\"type\") (\"ssemuladd\"))\n+    (set_attr (\"prefix\") (\"evex\"))\n+    (set_attr (\"mode\") (\"TI\"))])\n+\n+(define_insn \"avx5124vnniw_vp4dpwssds_maskz\"\n+  [(set (match_operand:V16SI 0 \"register_operand\" \"=v\")\n+\t(vec_merge:V16SI\n+\t  (unspec:V16SI\n+\t    [(match_operand:V16SI 1 \"register_operand\" \"0\")\n+\t     (match_operand:V64SI 2 \"register_operand\" \"Yh\")\n+\t     (match_operand:V4SI 3 \"memory_operand\" \"m\")] UNSPEC_VP4DPWSSDS)\n+\t  (match_operand:V16SI 4 \"const0_operand\" \"C\")\n+\t  (match_operand:HI 5 \"register_operand\" \"Yk\")))]\n+  \"TARGET_AVX5124VNNIW\"\n+  \"vp4dpwssds\\t{%3, %g2, %0%{%5%}%{z%}|%{%5%}%{z%}%0, %g2, %3}\"\n+   [(set_attr (\"type\") (\"ssemuladd\"))\n+    (set_attr (\"prefix\") (\"evex\"))\n+    (set_attr (\"mode\") (\"TI\"))])"}, {"sha": "42ab5f0f749c6b473671e932bc473802fb0259b6", "filename": "gcc/genmodes.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -973,10 +973,10 @@ inline __attribute__((__always_inline__))\\n\\\n #else\\n\\\n extern __inline__ __attribute__((__always_inline__, __gnu_inline__))\\n\\\n #endif\\n\\\n-unsigned char\\n\\\n+unsigned short\\n\\\n mode_size_inline (machine_mode mode)\\n\\\n {\\n\\\n-  extern %sunsigned char mode_size[NUM_MACHINE_MODES];\\n\\\n+  extern %sunsigned short mode_size[NUM_MACHINE_MODES];\\n\\\n   gcc_assert (mode >= 0 && mode < NUM_MACHINE_MODES);\\n\\\n   switch (mode)\\n\\\n     {\\n\", adj_bytesize ? \"\" : \"const \");\n@@ -1301,7 +1301,7 @@ emit_mode_size (void)\n   int c;\n   struct mode_data *m;\n \n-  print_maybe_const_decl (\"%sunsigned char\", \"mode_size\",\n+  print_maybe_const_decl (\"%sunsigned short\", \"mode_size\",\n \t\t\t  \"NUM_MACHINE_MODES\", bytesize);\n \n   for_all_modes (c, m)\n@@ -1492,7 +1492,7 @@ emit_mode_base_align (void)\n   int c;\n   struct mode_data *m;\n \n-  print_maybe_const_decl (\"%sunsigned char\",\n+  print_maybe_const_decl (\"%sunsigned short\",\n \t\t\t  \"mode_base_align\", \"NUM_MACHINE_MODES\",\n \t\t\t  alignment);\n "}, {"sha": "2ee4bd44362639aa5d25e054e53a4d63c2a89751", "filename": "gcc/init-regs.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Finit-regs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Finit-regs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finit-regs.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -104,6 +104,7 @@ initialize_uninitialized_regs (void)\n \t\t  bitmap_set_bit (already_genned, regno);\n \n \t\t  start_sequence ();\n+\t\t  emit_clobber (reg);\n \t\t  emit_move_insn (reg, CONST0_RTX (GET_MODE (reg)));\n \t\t  move_insn = get_insns ();\n \t\t  end_sequence ();"}, {"sha": "d924e83705b39b1733978ad4f3966ca450dfda07", "filename": "gcc/machmode.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -179,7 +179,7 @@ extern const unsigned char mode_class[NUM_MACHINE_MODES];\n \n /* Get the size in bytes and bits of an object of mode MODE.  */\n \n-extern CONST_MODE_SIZE unsigned char mode_size[NUM_MACHINE_MODES];\n+extern CONST_MODE_SIZE unsigned short mode_size[NUM_MACHINE_MODES];\n #if GCC_VERSION >= 4001\n #define GET_MODE_SIZE(MODE) \\\n   ((unsigned short) (__builtin_constant_p (MODE) \\\n@@ -330,7 +330,7 @@ extern machine_mode get_best_mode (int, int,\n \n /* Determine alignment, 1<=result<=BIGGEST_ALIGNMENT.  */\n \n-extern CONST_MODE_BASE_ALIGN unsigned char mode_base_align[NUM_MACHINE_MODES];\n+extern CONST_MODE_BASE_ALIGN unsigned short mode_base_align[NUM_MACHINE_MODES];\n \n extern unsigned get_mode_alignment (machine_mode);\n "}, {"sha": "701051d4e7df984946268aef88614780c6b3860e", "filename": "gcc/testsuite/g++.dg/other/i386-2.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-2.C?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -1,9 +1,10 @@\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n-/* { dg-options \"-O -pedantic-errors -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt  -mavx512dq -mavx512bw -mavx512vl -mavx512ifma -mavx512vbmi -mclwb -mmwaitx -mclzero -mpku\" } */\n+/* { dg-options \"-O -pedantic-errors -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt  -mavx512dq -mavx512bw -mavx512vl -mavx512ifma -mavx512vbmi -mavx5124fmaps -mavx5124vnniw -mclwb -mmwaitx -mclzero -mpku\" } */\n \n /* Test that {,x,e,p,t,s,w,a,b,i}mmintrin.h, mm3dnow.h, fma4intrin.h,\n    xopintrin.h, abmintrin.h, bmiintrin.h, tbmintrin.h, lwpintrin.h,\n-   popcntintrin.h, fmaintrin.h, pkuintrin.h and mm_malloc.h.h are usable with\n+   popcntintrin.h, fmaintrin.h, pkuintrin.h, avx5124fmapsintrin.h,\n+   avx5124vnniwintrin.h and mm_malloc.h.h are usable with\n    -O -pedantic-errors.  */\n \n #include <x86intrin.h>"}, {"sha": "cd8f217ef08262784b53c63f5375894b5a628db3", "filename": "gcc/testsuite/g++.dg/other/i386-3.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-3.C?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -1,9 +1,10 @@\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n-/* { dg-options \"-O -fkeep-inline-functions -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt -mavx512dq -mavx512bw -mavx512vl -mavx512ifma -mavx512vbmi -mclwb -mmwaitx -mclzero -mpku\" } */\n+/* { dg-options \"-O -fkeep-inline-functions -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt -mavx512dq -mavx512bw -mavx512vl -mavx512ifma -mavx512vbmi -mavx5124fmaps -mavx5124vnniw -mclwb -mmwaitx -mclzero -mpku\" } */\n \n /* Test that {,x,e,p,t,s,w,a,b,i}mmintrin.h, mm3dnow.h, fma4intrin.h,\n    xopintrin.h, abmintrin.h, bmiintrin.h, tbmintrin.h, lwpintrin.h,\n-   popcntintrin.h, fmaintrin.h, pkuintrin.h and mm_malloc.h are usable with\n+   popcntintrin.h, fmaintrin.h, pkuintrin.h, avx5124fmapsintrin.h,\n+   avx5124vnniwintrin.h and mm_malloc.h are usable with\n    -O -fkeep-inline-functions.  */\n \n #include <x86intrin.h>"}, {"sha": "1035f253f06614f90f26b84272e8e9a373308220", "filename": "gcc/testsuite/gcc.target/i386/avx5124fmadd-v4fmaddps-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmadd-v4fmaddps-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmadd-v4fmaddps-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmadd-v4fmaddps-1.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx5124fmaps\" } */\n+/* { dg-final { scan-assembler-times \"v4fmaddps\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+/* { dg-final { scan-assembler-times \"v4fmaddps\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+/* { dg-final { scan-assembler-times \"v4fmaddps\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+\n+#include <x86intrin.h>\n+\n+__m512 a, b, c, d, e, f, g, x1, x2, x3;\n+__m128 *mem;\n+__mmask16 m;\n+\n+int foo ()\n+{\n+  x1 = _mm512_4fmadd_ps (a, b, c, d, e, mem);\n+  x2 = _mm512_mask_4fmadd_ps (a, m, b, c, d, e, mem);\n+  x3 = _mm512_maskz_4fmadd_ps (m, a, b, c, d, e, mem);\n+}"}, {"sha": "f977b65dad01acbf8a02c65f4abd8b62e23bf33d", "filename": "gcc/testsuite/gcc.target/i386/avx5124fmadd-v4fmaddps-2.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmadd-v4fmaddps-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmadd-v4fmaddps-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmadd-v4fmaddps-2.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -mavx5124fmaps\" } */\n+/* { dg-require-effective-target avx5124fmaps } */\n+\n+#define ESP_FLOAT 1.0\n+\n+#define AVX5124FMAPS\n+#include \"avx512f-helper.h\"\n+\n+#define SIZE (AVX512F_LEN / 32)\n+\n+#include \"avx512f-mask-type.h\"\n+\n+void\n+CALC (float *src1, float* src2, float *src3,\n+      float *src4, float* prev_dst, float *mult, float *dst)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    {\n+      dst[i] = (double)prev_dst[i]\n+\t+ (double)src1[i] * (double)mult[0]\n+\t+ (double)src2[i] * (double)mult[1]\n+\t+ (double)src3[i] * (double)mult[2]\n+\t+ (double)src4[i] * (double)mult[3];\n+    }\n+}\n+\n+void\n+TEST (void)\n+{\n+  int i, sign;\n+  UNION_TYPE (AVX512F_LEN,) src1, src2, src3, src4, src5, dst, res1, res2, res3;\n+  UNION_TYPE (128,) mult;\n+  MASK_TYPE mask = MASK_VALUE;\n+  float res_ref[SIZE];\n+\n+  sign = -1;\n+  for (i = 0; i < SIZE; i++)\n+    {\n+      src1.a[i] = 1.5 + 34.67 * i * sign;\n+      src2.a[i] = -22.17 * i * sign;\n+      src3.a[i] = src1.a[i] * src1.a[i];\n+      src4.a[i] = src2.a[i] * src2.a[i];\n+      sign = sign * -1;\n+    }\n+  for (i = 0; i < 4; i++)\n+    mult.a[i] = 3.1415 + i * 2.71828;\n+\n+  for (i = 0; i < SIZE; i++)\n+    src5.a[i] = DEFAULT_VALUE;\n+\n+  CALC (src1.a, src2.a, src3.a, src4.a, src5.a, mult.a, res_ref);\n+\n+  res1.x = INTRINSIC (_4fmadd_ps)       (      src5.x, src1.x, src2.x, src3.x, src4.x, &mult.x);\n+  res2.x = INTRINSIC (_mask_4fmadd_ps)  (src5.x, mask, src1.x, src2.x, src3.x, src4.x, &mult.x);\n+  res3.x = INTRINSIC (_maskz_4fmadd_ps) (mask, src5.x, src1.x, src2.x, src3.x, src4.x, &mult.x);\n+\n+  if (UNION_FP_CHECK (AVX512F_LEN,) (res1, res_ref))\n+    abort ();\n+\n+  MASK_MERGE () (res_ref, mask, SIZE);\n+  if (UNION_FP_CHECK (AVX512F_LEN,) (res2, res_ref))\n+    abort ();\n+\n+  MASK_ZERO () (res_ref, mask, SIZE);\n+  if (UNION_FP_CHECK (AVX512F_LEN,) (res3, res_ref))\n+    abort ();\n+}"}, {"sha": "2f1a558a1a2e9af1ad72d5bd2ad9fec2b0579b75", "filename": "gcc/testsuite/gcc.target/i386/avx5124fmadd-v4fmaddss-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmadd-v4fmaddss-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmadd-v4fmaddss-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmadd-v4fmaddss-1.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx5124fmaps\" } */\n+/* { dg-final { scan-assembler-times \"v4fmaddss\\[ \\\\t\\]+\\[^\\{\\n\\]*%xmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+/* { dg-final { scan-assembler-times \"v4fmaddss\\[ \\\\t\\]+\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+/* { dg-final { scan-assembler-times \"v4fmaddss\\[ \\\\t\\]+\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+\n+#include <x86intrin.h>\n+\n+__m128 a, b, c, d, e, f, x1, x2, x3;\n+__m128 *mem;\n+__mmask8 m;\n+\n+int foo ()\n+{\n+  x1 = _mm_4fmadd_ss (a, b, c, d, e, mem);\n+  x2 = _mm_mask_4fmadd_ss (a, m, b, c, d, e, mem);\n+  x3 = _mm_maskz_4fmadd_ss (m, a, b, c, d, e, mem);\n+}"}, {"sha": "45bd7dace4835acc856e06059dc22a03455cba91", "filename": "gcc/testsuite/gcc.target/i386/avx5124fmadd-v4fnmaddps-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmadd-v4fnmaddps-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmadd-v4fnmaddps-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmadd-v4fnmaddps-1.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx5124fmaps\" } */\n+/* { dg-final { scan-assembler-times \"v4fnmaddps\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+/* { dg-final { scan-assembler-times \"v4fnmaddps\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+/* { dg-final { scan-assembler-times \"v4fnmaddps\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+\n+#include <x86intrin.h>\n+\n+__m512 a, b, c, d, e, f, g, x1, x2, x3;\n+__m128 *mem;\n+__mmask16 m;\n+\n+int foo ()\n+{\n+  x1 = _mm512_4fnmadd_ps (a, b, c, d, e, mem);\n+  x2 = _mm512_mask_4fnmadd_ps (a, m, b, c, d, e, mem);\n+  x3 = _mm512_maskz_4fnmadd_ps (m, a, b, c, d, e, mem);\n+}"}, {"sha": "3c75fcf2d15fff54c4d59910ea837bc9ced8db71", "filename": "gcc/testsuite/gcc.target/i386/avx5124fmadd-v4fnmaddps-2.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmadd-v4fnmaddps-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmadd-v4fnmaddps-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmadd-v4fnmaddps-2.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -mavx5124fmaps\" } */\n+/* { dg-require-effective-target avx5124fmaps } */\n+\n+#define ESP_FLOAT 1.0\n+\n+#define AVX5124FMAPS\n+#include \"avx512f-helper.h\"\n+\n+#define SIZE (AVX512F_LEN / 32)\n+\n+#include \"avx512f-mask-type.h\"\n+\n+void\n+CALC (float *src1, float* src2, float *src3,\n+      float *src4, float* prev_dst, float *mult, float *dst)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    {\n+      dst[i] = (double)prev_dst[i]\n+\t- (double)src1[i] * (double)mult[0]\n+\t- (double)src2[i] * (double)mult[1]\n+\t- (double)src3[i] * (double)mult[2]\n+\t- (double)src4[i] * (double)mult[3];\n+    }\n+}\n+\n+void\n+TEST (void)\n+{\n+  int i, sign;\n+  UNION_TYPE (AVX512F_LEN,) src1, src2, src3, src4, src5, dst, res1, res2, res3;\n+  UNION_TYPE (128,) mult;\n+  MASK_TYPE mask = MASK_VALUE;\n+  float res_ref[SIZE];\n+\n+  sign = -1;\n+  for (i = 0; i < SIZE; i++)\n+    {\n+      src1.a[i] = 1.5 + 34.67 * i * sign;\n+      src2.a[i] = -22.17 * i * sign;\n+      src3.a[i] = src1.a[i] * src1.a[i];\n+      src4.a[i] = src2.a[i] * src2.a[i];\n+      sign = sign * -1;\n+    }\n+  for (i = 0; i < 4; i++)\n+    mult.a[i] = 3.1415 + i * 2.71828;\n+\n+  for (i = 0; i < SIZE; i++)\n+    src5.a[i] = DEFAULT_VALUE;\n+\n+  CALC (src1.a, src2.a, src3.a, src4.a, src5.a, mult.a, res_ref);\n+\n+  res1.x = INTRINSIC (_4fnmadd_ps)       (      src5.x, src1.x, src2.x, src3.x, src4.x, &mult.x);\n+  res2.x = INTRINSIC (_mask_4fnmadd_ps)  (src5.x, mask, src1.x, src2.x, src3.x, src4.x, &mult.x);\n+  res3.x = INTRINSIC (_maskz_4fnmadd_ps) (mask, src5.x, src1.x, src2.x, src3.x, src4.x, &mult.x);\n+\n+  if (UNION_FP_CHECK (AVX512F_LEN,) (res1, res_ref))\n+    abort ();\n+\n+  MASK_MERGE () (res_ref, mask, SIZE);\n+  if (UNION_FP_CHECK (AVX512F_LEN,) (res2, res_ref))\n+    abort ();\n+\n+  MASK_ZERO () (res_ref, mask, SIZE);\n+  if (UNION_FP_CHECK (AVX512F_LEN,) (res3, res_ref))\n+    abort ();\n+}"}, {"sha": "1755afb9332c55823a2f71c9f7108a3ac6f09a66", "filename": "gcc/testsuite/gcc.target/i386/avx5124fmadd-v4fnmaddss-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmadd-v4fnmaddss-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmadd-v4fnmaddss-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmadd-v4fnmaddss-1.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx5124fmaps\" } */\n+/* { dg-final { scan-assembler-times \"v4fnmaddss\\[ \\\\t\\]+\\[^\\{\\n\\]*%xmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+/* { dg-final { scan-assembler-times \"v4fnmaddss\\[ \\\\t\\]+\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+/* { dg-final { scan-assembler-times \"v4fnmaddss\\[ \\\\t\\]+\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+\n+\n+#include <x86intrin.h>\n+\n+__m128 a, b, c, d, e, f, x1, x2, x3;\n+__m128 *mem;\n+__mmask8 m;\n+\n+int foo ()\n+{\n+  x1 = _mm_4fnmadd_ss (a, b, c, d, e, mem);\n+  x2 = _mm_mask_4fnmadd_ss (a, m, b, c, d, e, mem);\n+  x3 = _mm_maskz_4fnmadd_ss (m, a, b, c, d, e, mem);\n+}"}, {"sha": "13ea70b0a8d256c1dcfa8ae3972d42a81540c96d", "filename": "gcc/testsuite/gcc.target/i386/avx5124fmaps-check.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmaps-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmaps-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124fmaps-check.h?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -0,0 +1,47 @@\n+#include <stdlib.h>\n+#include \"cpuid.h\"\n+#include \"m512-check.h\"\n+#include \"avx512f-os-support.h\"\n+\n+static void avx5124fmaps_test (void);\n+\n+static void __attribute__ ((noinline)) do_test (void)\n+{\n+  avx5124fmaps_test ();\n+}\n+\n+int\n+main ()\n+{\n+  unsigned int eax, ebx, ecx, edx;\n+\n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+    return 0;\n+\n+  /* Run AVX512_4FMAPS test only if host has the support.  */\n+  if ((ecx & bit_OSXSAVE) == (bit_OSXSAVE))\n+    {\n+      if (__get_cpuid_max (0, NULL) < 7)\n+\treturn 0;\n+\n+      __cpuid_count (7, 0, eax, ebx, ecx, edx);\n+\n+      if ((avx512f_os_support ()) && ((edx & bit_AVX5124FMAPS) == bit_AVX5124FMAPS))\n+\t{\n+\t  do_test ();\n+#ifdef DEBUG\n+\t  printf (\"PASSED\\n\");\n+#endif\n+\t  return 0;\n+\t}\n+#ifdef DEBUG\n+      printf (\"SKIPPED\\n\");\n+#endif\n+    }\n+#ifdef DEBUG\n+  else\n+    printf (\"SKIPPED\\n\");\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "27d35a574902cb9af28110f4a7ccfae6d484d1eb", "filename": "gcc/testsuite/gcc.target/i386/avx5124vnniw-check.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124vnniw-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124vnniw-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124vnniw-check.h?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -0,0 +1,47 @@\n+#include <stdlib.h>\n+#include \"cpuid.h\"\n+#include \"m512-check.h\"\n+#include \"avx512f-os-support.h\"\n+\n+static void avx5124vnniw_test (void);\n+\n+static void __attribute__ ((noinline)) do_test (void)\n+{\n+  avx5124vnniw_test ();\n+}\n+\n+int\n+main ()\n+{\n+  unsigned int eax, ebx, ecx, edx;\n+\n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+    return 0;\n+\n+  /* Run AVX512_4VNNIW test only if host has the support.  */\n+  if ((ecx & bit_OSXSAVE) == (bit_OSXSAVE))\n+    {\n+      if (__get_cpuid_max (0, NULL) < 7)\n+\treturn 0;\n+\n+      __cpuid_count (7, 0, eax, ebx, ecx, edx);\n+\n+      if ((avx512f_os_support ()) && ((edx & bit_AVX5124VNNIW) == bit_AVX5124VNNIW))\n+\t{\n+\t  do_test ();\n+#ifdef DEBUG\n+\t  printf (\"PASSED\\n\");\n+#endif\n+\t  return 0;\n+\t}\n+#ifdef DEBUG\n+      printf (\"SKIPPED\\n\");\n+#endif\n+    }\n+#ifdef DEBUG\n+  else\n+    printf (\"SKIPPED\\n\");\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "a234fddf54a9f66e4b86e3960a51847774c71995", "filename": "gcc/testsuite/gcc.target/i386/avx5124vnniw-vp4dpwssd-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124vnniw-vp4dpwssd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124vnniw-vp4dpwssd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124vnniw-vp4dpwssd-1.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx5124vnniw\" } */\n+/* { dg-final { scan-assembler-times \"vp4dpwssd\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+/* { dg-final { scan-assembler-times \"vp4dpwssd\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+/* { dg-final { scan-assembler-times \"vp4dpwssd\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+\n+#include <x86intrin.h>\n+\n+__m512i a, b, c, d, e, f, g, x1, x2, x3;\n+__m128i *mem;\n+__mmask16 m;\n+\n+int foo ()\n+{\n+  x1 = _mm512_4dpwssd_epi32 (a, b, c, d, e, mem);\n+  x2 = _mm512_mask_4dpwssd_epi32 (a, m, b, c, d, e, mem);\n+  x3 = _mm512_maskz_4dpwssd_epi32 (m, a, b, c, d, e, mem);\n+}"}, {"sha": "a0a6825e7c9994cceddcdd13bcd2e68f5e765425", "filename": "gcc/testsuite/gcc.target/i386/avx5124vnniw-vp4dpwssd-2.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124vnniw-vp4dpwssd-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124vnniw-vp4dpwssd-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124vnniw-vp4dpwssd-2.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -0,0 +1,79 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -mavx5124vnniw\" } */\n+/* { dg-require-effective-target avx5124vnniw } */\n+\n+#define AVX5124VNNIW\n+#include \"avx512f-helper.h\"\n+\n+#define SIZE (AVX512F_LEN / 32)\n+\n+#include \"avx512f-mask-type.h\"\n+\n+void\n+CALC (short *src1, short* src2, short *src3,\n+      short *src4, int* prev_dst, short *mult, int *dst)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    {\n+      int p1dword, p2dword;\n+      dst[i] = prev_dst[i];\n+      p1dword = (int)(src1[2*i  ]) * (int)(mult[0]);\n+      p2dword = (int)(src1[2*i+1]) * (int)(mult[1]);\n+      dst[i] += p1dword + p2dword;\n+\n+      p1dword = (int)(src2[2*i  ]) * (int)(mult[2]);\n+      p2dword = (int)(src2[2*i+1]) * (int)(mult[3]);\n+      dst[i] += p1dword + p2dword;\n+\n+      p1dword = (int)(src3[2*i  ]) * (int)(mult[4]);\n+      p2dword = (int)(src3[2*i+1]) * (int)(mult[5]);\n+      dst[i] += p1dword + p2dword;\n+\n+      p1dword = (int)(src4[2*i  ]) * (int)(mult[6]);\n+      p2dword = (int)(src4[2*i+1]) * (int)(mult[7]);\n+      dst[i] += p1dword + p2dword;\n+    }\n+}\n+\n+void\n+TEST (void)\n+{\n+  int i;\n+  UNION_TYPE (AVX512F_LEN, i_w) src1, src2, src3, src4;\n+  UNION_TYPE (AVX512F_LEN, i_d) src5, dst, res1, res2, res3;\n+  UNION_TYPE (128, i_w) mult;\n+  MASK_TYPE mask = MASK_VALUE;\n+  int res_ref[SIZE];\n+\n+  for (i = 0; i < SIZE * 2; i++)\n+    {\n+      src1.a[i] = 2 + 7 * i % 291;\n+      src2.a[i] = 3 + 11 * (i % 377) * i;\n+      src3.a[i] = src1.a[i] * src1.a[i];\n+      src4.a[i] = src2.a[i] * src2.a[i];\n+    }\n+  for (i = 0; i < 8; i++)\n+    mult.a[i] = 3 + i * 2;\n+\n+  for (i = 0; i < SIZE; i++)\n+    src5.a[i] = DEFAULT_VALUE;\n+\n+  CALC (src1.a, src2.a, src3.a, src4.a, src5.a, mult.a, res_ref);\n+\n+  res1.x = INTRINSIC (_4dpwssd_epi32)       (      src5.x, src1.x, src2.x, src3.x, src4.x, &mult.x);\n+  res2.x = INTRINSIC (_mask_4dpwssd_epi32)  (src5.x, mask, src1.x, src2.x, src3.x, src4.x, &mult.x);\n+  res3.x = INTRINSIC (_maskz_4dpwssd_epi32) (mask, src5.x, src1.x, src2.x, src3.x, src4.x, &mult.x);\n+\n+  if (UNION_CHECK (AVX512F_LEN, i_d) (res1, res_ref))\n+    abort ();\n+\n+  MASK_MERGE (i_d) (res_ref, mask, SIZE);\n+  if (UNION_CHECK (AVX512F_LEN, i_d) (res2, res_ref))\n+    abort ();\n+\n+  MASK_ZERO (i_d) (res_ref, mask, SIZE);\n+  if (UNION_CHECK (AVX512F_LEN, i_d) (res3, res_ref))\n+    abort ();\n+}"}, {"sha": "d1bed37d1c0c120585485efaee9f9ee23f108b6a", "filename": "gcc/testsuite/gcc.target/i386/avx5124vnniw-vp4dpwssds-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124vnniw-vp4dpwssds-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124vnniw-vp4dpwssds-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124vnniw-vp4dpwssds-1.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx5124vnniw\" } */\n+/* { dg-final { scan-assembler-times \"vp4dpwssds\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+/* { dg-final { scan-assembler-times \"vp4dpwssds\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+/* { dg-final { scan-assembler-times \"vp4dpwssds\\[ \\\\t\\]+\\[^\\{\\n\\]*%zmm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\"  1 } } */\n+\n+#include <x86intrin.h>\n+\n+__m512i a, b, c, d, e, f, g, x1, x2, x3;\n+__m128i *mem;\n+__mmask16 m;\n+\n+int foo ()\n+{\n+  x1 = _mm512_4dpwssds_epi32 (a, b, c, d, e, mem);\n+  x2 = _mm512_mask_4dpwssds_epi32 (a, m, b, c, d, e, mem);\n+  x3 = _mm512_maskz_4dpwssds_epi32 (m, a, b, c, d, e, mem);\n+}"}, {"sha": "e1e5536558c2fac33f2d1800c6bcfada803ba38c", "filename": "gcc/testsuite/gcc.target/i386/avx5124vnniw-vp4dpwssds-2.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124vnniw-vp4dpwssds-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124vnniw-vp4dpwssds-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx5124vnniw-vp4dpwssds-2.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -0,0 +1,98 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -mavx5124vnniw\" } */\n+/* { dg-require-effective-target avx5124vnniw } */\n+\n+#define DEFAULT_VALUE 0x7ffffffe\n+\n+#define AVX5124VNNIW\n+#include \"avx512f-helper.h\"\n+\n+#define SIZE (AVX512F_LEN / 32)\n+\n+#include \"avx512f-mask-type.h\"\n+\n+void\n+CALC (short *src1, short* src2, short *src3,\n+      short *src4, int* prev_dst, short *mult, int *dst)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    {\n+      int p1dword, p2dword;\n+      long long int tmp;\n+      dst[i] = prev_dst[i];\n+      p1dword = (int)(src1[2*i  ]) * (int)(mult[0]);\n+      p2dword = (int)(src1[2*i+1]) * (int)(mult[1]);\n+      tmp = (long long)dst[i] + p1dword + p2dword;\n+      if (tmp > 0x7fffffff)\n+\tdst[i] = 0x7fffffff;\n+      else\n+\tdst[i] += p1dword + p2dword;\n+\n+      p1dword = (int)(src2[2*i  ]) * (int)(mult[2]);\n+      p2dword = (int)(src2[2*i+1]) * (int)(mult[3]);\n+      tmp = (long long)dst[i] + p1dword + p2dword;\n+      if (tmp > 0x7fffffff)\n+\tdst[i] = 0x7fffffff;\n+      else\n+\tdst[i] += p1dword + p2dword;\n+\n+      p1dword = (int)(src3[2*i  ]) * (int)(mult[4]);\n+      p2dword = (int)(src3[2*i+1]) * (int)(mult[5]);\n+      tmp = (long long)dst[i] + p1dword + p2dword;\n+      if (tmp > 0x7fffffff)\n+\tdst[i] = 0x7fffffff;\n+      else\n+\tdst[i] += p1dword + p2dword;\n+\n+      p1dword = (int)(src4[2*i  ]) * (int)(mult[6]);\n+      p2dword = (int)(src4[2*i+1]) * (int)(mult[7]);\n+      tmp = (long long)dst[i] + p1dword + p2dword;\n+      if (tmp > 0x7fffffff)\n+\tdst[i] = 0x7fffffff;\n+      else\n+\tdst[i] += p1dword + p2dword;\n+    }\n+}\n+\n+void\n+TEST (void)\n+{\n+  int i;\n+  UNION_TYPE (AVX512F_LEN, i_w) src1, src2, src3, src4;\n+  UNION_TYPE (AVX512F_LEN, i_d) src5, dst, res1, res2, res3;\n+  UNION_TYPE (128, i_w) mult;\n+  MASK_TYPE mask = MASK_VALUE;\n+  int res_ref[SIZE];\n+\n+  for (i = 0; i < SIZE * 2; i++)\n+    {\n+      src1.a[i] = 2 + 7 * i % 291;\n+      src2.a[i] = 3 + 11 * (i % 377) * i;\n+      src3.a[i] = src1.a[i] * src1.a[i];\n+      src4.a[i] = src2.a[i] * src2.a[i];\n+    }\n+  for (i = 0; i < 8; i++)\n+    mult.a[i] = 3 + i * 2;\n+\n+  for (i = 0; i < SIZE; i++)\n+    src5.a[i] = DEFAULT_VALUE;\n+\n+  CALC (src1.a, src2.a, src3.a, src4.a, src5.a, mult.a, res_ref);\n+\n+  res1.x = INTRINSIC (_4dpwssds_epi32)\t     (      src5.x, src1.x, src2.x, src3.x, src4.x, &mult.x);\n+  res2.x = INTRINSIC (_mask_4dpwssds_epi32)  (src5.x, mask, src1.x, src2.x, src3.x, src4.x, &mult.x);\n+  res3.x = INTRINSIC (_maskz_4dpwssds_epi32) (mask, src5.x, src1.x, src2.x, src3.x, src4.x, &mult.x);\n+\n+  if (UNION_CHECK (AVX512F_LEN, i_d) (res1, res_ref))\n+    abort ();\n+\n+  MASK_MERGE (i_d) (res_ref, mask, SIZE);\n+  if (UNION_CHECK (AVX512F_LEN, i_d) (res2, res_ref))\n+    abort ();\n+\n+  MASK_ZERO (i_d) (res_ref, mask, SIZE);\n+  if (UNION_CHECK (AVX512F_LEN, i_d) (res3, res_ref))\n+    abort ();\n+}"}, {"sha": "6aca0d6bdc22392cd7062fe2ad9b1a324bb9ff10", "filename": "gcc/testsuite/gcc.target/i386/avx512f-helper.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-helper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-helper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-helper.h?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -22,6 +22,10 @@\n #include \"avx512ifma-check.h\"\n #elif defined (AVX512VBMI) && !defined (AVX512VL)\n #include \"avx512vbmi-check.h\"\n+#elif defined (AVX5124FMAPS) && !defined (AVX512VL)\n+#include \"avx5124fmaps-check.h\"\n+#elif defined (AVX5124VNNIW) && !defined (AVX512VL)\n+#include \"avx5124vnniw-check.h\"\n #elif defined (AVX512VL)\n #include \"avx512vl-check.h\"\n #endif\n@@ -33,7 +37,9 @@\n /* Value to be written into destination.\n    We have one value for all types so it must be small enough\n    to fit into signed char.  */\n+#ifndef DEFAULT_VALUE\n #define DEFAULT_VALUE 117\n+#endif\n \n #define MAKE_MASK_MERGE(NAME, TYPE)\t\t\t\t      \\\n static void\t\t\t\t\t\t\t      \\\n@@ -132,6 +138,12 @@ avx512ifma_test (void) { test_512 (); }\n #elif defined (AVX512VBMI) && !defined (AVX512VL)\n void\n avx512vbmi_test (void) { test_512 (); }\n+#elif defined (AVX5124FMAPS) && !defined (AVX512VL)\n+void\n+avx5124fmaps_test (void) { test_512 (); }\n+#elif defined (AVX5124VNNIW) && !defined (AVX512VL)\n+void\n+avx5124vnniw_test (void) { test_512 (); }\n #elif defined (AVX512VL)\n void\n avx512vl_test (void) { test_256 (); test_128 (); }"}, {"sha": "40572409c3dd38366e0d8052ae4777981098102b", "filename": "gcc/testsuite/gcc.target/i386/i386.exp", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fi386.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fi386.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fi386.exp?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -366,6 +366,48 @@ proc check_effective_target_avx512vbmi { } {\n     } \"-mavx512vbmi\" ]\n }\n \n+# Return 1 if avx512_4fmaps instructions can be compiled.\n+proc check_effective_target_avx5124fmaps { } {\n+    return [check_no_compiler_messages avx5124fmaps object {\n+\ttypedef float __v16sf __attribute__ ((__vector_size__ (64)));\n+\ttypedef float __v4sf __attribute__ ((__vector_size__ (16)));\n+\n+\t__v16sf\n+\t_mm512_mask_4fmadd_ps (__v16sf __DEST, __v16sf __A, __v16sf __B, __v16sf __C,\n+\t\t\t       __v16sf __D, __v16sf __E, __v4sf *__F)\n+\t{\n+\t    return (__v16sf) __builtin_ia32_4fmaddps_mask ((__v16sf) __A,\n+\t\t\t\t\t\t\t  (__v16sf) __B,\n+\t\t\t\t\t\t\t  (__v16sf) __C,\n+\t\t\t\t\t\t\t  (__v16sf) __D,\n+\t\t\t\t\t\t\t  (__v16sf) __E,\n+\t\t\t\t\t\t\t  (const __v4sf *) __F,\n+\t\t\t\t\t\t\t  (__v16sf) __DEST,\n+\t\t\t\t\t\t\t  0xffff);\n+\t}\n+    } \"-mavx5124fmaps\" ]\n+}\n+\n+# Return 1 if avx512_4vnniw instructions can be compiled.\n+proc check_effective_target_avx5124vnniw { } {\n+    return [check_no_compiler_messages avx5124vnniw object {\n+\ttypedef int __v16si __attribute__ ((__vector_size__ (64)));\n+\ttypedef int __v4si __attribute__ ((__vector_size__ (16)));\n+\n+\t__v16si\n+\t_mm512_4dpwssd_epi32 (__v16si __A, __v16si __B, __v16si __C,\n+\t\t\t      __v16si __D, __v16si __E, __v4si *__F)\n+\t{\n+\t    return (__v16si) __builtin_ia32_vp4dpwssd ((__v16si) __B,\n+\t\t\t\t\t\t       (__v16si) __C,\n+\t\t\t\t\t\t       (__v16si) __D,\n+\t\t\t\t\t\t       (__v16si) __E,\n+\t\t\t\t\t\t       (__v16si) __A,\n+\t\t\t\t\t\t       (const __v4si *) __F);\n+\t}\n+    } \"-mavx5124vnniw\" ]\n+}\n+\n # If a testcase doesn't have special options, use these.\n global DEFAULT_CFLAGS\n if ![info exists DEFAULT_CFLAGS] then {"}, {"sha": "48b233285396c0b8a7182bdfa9143d0368e3a9d5", "filename": "gcc/testsuite/gcc.target/i386/m128-check.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fm128-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fm128-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fm128-check.h?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -108,8 +108,12 @@ CHECK_EXP (union128d, double, \"%f\")\n \n CHECK_EXP (union128, float, \"%f\")\n \n+#ifndef ESP_FLOAT\n #define ESP_FLOAT 0.000001\n+#endif\n+#ifndef ESP_DOUBLE\n #define ESP_DOUBLE 0.000001\n+#endif\n #define CHECK_ARRAY(ARRAY, TYPE, FMT)                   \\\n static int                                              \\\n __attribute__((noinline, unused))                       \\"}, {"sha": "3e8417b00cf7041257924bc58592f7e8f9abba3c", "filename": "gcc/testsuite/gcc.target/i386/sse-12.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-12.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -3,7 +3,7 @@\n    popcntintrin.h and mm_malloc.h are usable\n    with -O -std=c89 -pedantic-errors.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O -std=c89 -pedantic-errors -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt -mavx512bw -mavx512dq -mavx512vl -mavx512vbmi -mavx512ifma -mclwb -mmwaitx -mclzero -mpku\" } */\n+/* { dg-options \"-O -std=c89 -pedantic-errors -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt -mavx512bw -mavx512dq -mavx512vl -mavx512vbmi -mavx512ifma -mavx5124fmaps -mavx5124vnniw -mclwb -mmwaitx -mclzero -mpku\" } */\n \n #include <x86intrin.h>\n "}, {"sha": "67f3b932cfecf23dd145d5893b4c7c55c45f220c", "filename": "gcc/testsuite/gcc.target/i386/sse-13.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-13.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -Werror-implicit-function-declaration -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt -mavx512vl -mavx512dq -mavx512bw -mavx512vbmi -mavx512ifma -mclwb -mmwaitx -mclzero -mpku\" } */\n+/* { dg-options \"-O2 -Werror-implicit-function-declaration -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt -mavx512vl -mavx512dq -mavx512bw -mavx512vbmi -mavx512ifma -mavx5124fmaps -mavx5124vnniw -mclwb -mmwaitx -mclzero -mpku\" } */\n /* { dg-add-options bind_pic_locally } */\n \n #include <mm_malloc.h>"}, {"sha": "256d933faecc8acd008b8fb0feb9146ce315c6f3", "filename": "gcc/testsuite/gcc.target/i386/sse-22.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-22.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -8,7 +8,8 @@\n /* Test that the intrinsics compile with optimization.  All of them\n    are defined as inline functions in {,x,e,p,t,s,w,a,b,i}mmintrin.h,\n    mm3dnow.h, fma4intrin.h, xopintrin.h, abmintrin.h, bmiintrin.h,\n-   tbmintrin.h, lwpintrin.h, popcntintrin.h, fmaintrin.h and mm_malloc.h \n+   tbmintrin.h, lwpintrin.h, popcntintrin.h, fmaintrin.h,\n+   avx5124fmapsintrin.h, avx5124vnniwintrin.h and mm_malloc.h \n    that reference the proper builtin functions.\n \n    Defining away \"extern\" and \"__inline\" results in all of them being\n@@ -100,7 +101,7 @@\n \n \n #ifndef DIFFERENT_PRAGMAS\n-#pragma GCC target (\"sse4a,3dnow,avx,avx2,fma4,xop,aes,pclmul,popcnt,abm,lzcnt,bmi,bmi2,tbm,lwp,fsgsbase,rdrnd,f16c,rtm,rdseed,prfchw,adx,fxsr,xsaveopt,avx512f,avx512er,avx512cd,avx512pf,sha,prefetchwt1,avx512vl,avx512bw,avx512dq,avx512vbmi,avx512ifma\")\n+#pragma GCC target (\"sse4a,3dnow,avx,avx2,fma4,xop,aes,pclmul,popcnt,abm,lzcnt,bmi,bmi2,tbm,lwp,fsgsbase,rdrnd,f16c,rtm,rdseed,prfchw,adx,fxsr,xsaveopt,avx512f,avx512er,avx512cd,avx512pf,sha,prefetchwt1,avx512vl,avx512bw,avx512dq,avx512vbmi,avx512ifma,avx5124fmaps,avx5124vnniw\")\n #endif\n \n /* Following intrinsics require immediate arguments.  They"}, {"sha": "61f1b003f22bd02ee2ff324ec3a5cc39cee015ed", "filename": "gcc/testsuite/gcc.target/i386/sse-23.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fbb13a72003ee9543d8e97c61df60c7cad3bb09/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-23.c?ref=5fbb13a72003ee9543d8e97c61df60c7cad3bb09", "patch": "@@ -7,7 +7,8 @@\n /* Test that the intrinsics compile with optimization.  All of them\n    are defined as inline functions in {,x,e,p,t,s,w,a,b,i}mmintrin.h,\n    mm3dnow.h, fma4intrin.h, xopintrin.h, abmintrin.h, bmiintrin.h,\n-   tbmintrin.h, lwpintrin.h, popcntintrin.h, fmaintrin.h and mm_malloc.h \n+   tbmintrin.h, lwpintrin.h, popcntintrin.h, fmaintrin.h,\n+   avx5124fmapsintrin.h, avx5124vnniwintrin.h and mm_malloc.h \n    that reference the proper builtin functions.\n \n    Defining away \"extern\" and \"__inline\" results in all of them being\n@@ -594,6 +595,6 @@\n #define __builtin_ia32_extracti64x2_256_mask(A, E, C, D) __builtin_ia32_extracti64x2_256_mask(A, 1, C, D)\n #define __builtin_ia32_extractf64x2_256_mask(A, E, C, D) __builtin_ia32_extractf64x2_256_mask(A, 1, C, D)\n \n-#pragma GCC target (\"sse4a,3dnow,avx,avx2,fma4,xop,aes,pclmul,popcnt,abm,lzcnt,bmi,bmi2,tbm,lwp,fsgsbase,rdrnd,f16c,fma,rtm,rdseed,prfchw,adx,fxsr,xsaveopt,avx512f,avx512er,avx512cd,avx512pf,sha,prefetchwt1,xsavec,xsaves,clflushopt,avx512bw,avx512dq,avx512vl,avx512vbmi,avx512ifma,clwb,mwaitx,clzero,pku\")\n+#pragma GCC target (\"sse4a,3dnow,avx,avx2,fma4,xop,aes,pclmul,popcnt,abm,lzcnt,bmi,bmi2,tbm,lwp,fsgsbase,rdrnd,f16c,fma,rtm,rdseed,prfchw,adx,fxsr,xsaveopt,avx512f,avx512er,avx512cd,avx512pf,sha,prefetchwt1,xsavec,xsaves,clflushopt,avx512bw,avx512dq,avx512vl,avx512vbmi,avx512ifma,avx5124fmaps,avx5124vnniw,clwb,mwaitx,clzero,pku\")\n \n #include <x86intrin.h>"}]}