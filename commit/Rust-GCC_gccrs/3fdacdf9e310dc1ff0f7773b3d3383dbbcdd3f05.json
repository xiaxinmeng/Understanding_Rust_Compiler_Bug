{"sha": "3fdacdf9e310dc1ff0f7773b3d3383dbbcdd3f05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZkYWNkZjllMzEwZGMxZmYwZjc3NzNiM2QzMzgzZGJiY2RkM2YwNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-09-21T16:27:40Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-09-21T16:27:40Z"}, "message": "c-common.c (builtin_define_float_constants): Use real_format to get the floating-point parameters.\n\n        * c-common.c (builtin_define_float_constants): Use real_format\n        to get the floating-point parameters.\n\nFrom-SVN: r57390", "tree": {"sha": "4618876e1da3518fd1f181a85167f59d5312e039", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4618876e1da3518fd1f181a85167f59d5312e039"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fdacdf9e310dc1ff0f7773b3d3383dbbcdd3f05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fdacdf9e310dc1ff0f7773b3d3383dbbcdd3f05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fdacdf9e310dc1ff0f7773b3d3383dbbcdd3f05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fdacdf9e310dc1ff0f7773b3d3383dbbcdd3f05/comments", "author": null, "committer": null, "parents": [{"sha": "aa2046c41feedde364b54351b44ac6b9fb16017e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa2046c41feedde364b54351b44ac6b9fb16017e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa2046c41feedde364b54351b44ac6b9fb16017e"}], "stats": {"total": 197, "additions": 44, "deletions": 153}, "files": [{"sha": "6e6487acbc6522542e7f117431e925107ae4d762", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fdacdf9e310dc1ff0f7773b3d3383dbbcdd3f05/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fdacdf9e310dc1ff0f7773b3d3383dbbcdd3f05/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3fdacdf9e310dc1ff0f7773b3d3383dbbcdd3f05", "patch": "@@ -1,3 +1,8 @@\n+2002-09-21  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-common.c (builtin_define_float_constants): Use real_format\n+\tto get the floating-point parameters.\n+\n 2002-09-21  Richard Henderson  <rth@redhat.com>\n \n \t* real.c (struct real_format): Move to real.h."}, {"sha": "8104248ce1d13e8ffe3cb1d915f568b3eff3d9ae", "filename": "gcc/c-common.c", "status": "modified", "additions": 39, "deletions": 153, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fdacdf9e310dc1ff0f7773b3d3383dbbcdd3f05/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fdacdf9e310dc1ff0f7773b3d3383dbbcdd3f05/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=3fdacdf9e310dc1ff0f7773b3d3383dbbcdd3f05", "patch": "@@ -4802,141 +4802,23 @@ builtin_define_float_constants (name_prefix, fp_suffix, type)\n      mean time, I suspect using doubles won't harm the bootstrap here.  */\n \n   const double log10_2 = .30102999566398119521;\n-  const double log10_16 = 1.20411998265592478085;\n-  const double log10_b\n-    = TARGET_FLOAT_FORMAT == IBM_FLOAT_FORMAT ? log10_16 : log10_2;\n-\n-  const int log2_b = TARGET_FLOAT_FORMAT == IBM_FLOAT_FORMAT ? 4 : 1;\n+  double log10_b;\n+  const struct real_format *fmt;\n \n   char name[64], buf[128];\n-  int mant_dig, max_exp, min_exp;\n   int dig, min_10_exp, max_10_exp;\n   int decimal_dig;\n \n-  /* ??? This information should be shared with real.c.  */\n+  fmt = real_format_for_mode[TYPE_MODE (type) - QFmode];\n \n-#ifndef INTEL_EXTENDED_IEEE_FORMAT\n-#define INTEL_EXTENDED_IEEE_FORMAT 0\n-#endif\n-#ifndef TARGET_G_FLOAT\n-#define TARGET_G_FLOAT 0\n-#endif\n-\n-  switch (TARGET_FLOAT_FORMAT)\n-    {\n-    case IEEE_FLOAT_FORMAT:\n-      switch (TYPE_PRECISION (type))\n-\t{\n-\tcase 32:\n-\t  /* ??? Handle MIPS r5900, which doesn't implement Inf or NaN,\n-\t     but rather reuses the largest exponent as a normal number.  */\n-\t  mant_dig = 24;\n-\t  min_exp = -125;\n-\t  max_exp = 128;\n-\t  break;\n-\tcase 64:\n-\t  mant_dig = 53;\n-\t  min_exp = -1021;\n-\t  max_exp = 1024;\n-\t  break;\n-\tcase 128:\n-\t  if (!INTEL_EXTENDED_IEEE_FORMAT)\n-\t    {\n-\t      mant_dig = 113;\n-\t      min_exp = -16381;\n-\t      max_exp = 16384;\n-\t      break;\n-\t    }\n-\t  /* FALLTHRU */\n-\tcase 96:\n-\t  mant_dig = 64;\n-\t  max_exp = 16384;\n-\t  if (INTEL_EXTENDED_IEEE_FORMAT)\n-\t    min_exp = -16381;\n-\t  else\n-\t    /* ??? Otherwise assume m68k.  */\n-\t    min_exp = -16382;\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-      break;\n-\n-    case VAX_FLOAT_FORMAT:\n-      switch (TYPE_PRECISION (type))\n-\t{\n-\tcase 32: /* F_FLOAT */\n-\t  mant_dig = 24;\n-\t  min_exp = -127;\n-\t  max_exp = 127;\n-\t  break;\n-\tcase 64: /* G_FLOAT or D_FLOAT */\n-\t  if (TARGET_G_FLOAT)\n-\t    {\n-\t      mant_dig = 53;\n-\t      min_exp = -1023;\n-\t      max_exp = 1023;\n-\t    }\n-\t  else\n-\t    {\n-\t      mant_dig = 56;\n-\t      min_exp = -127;\n-\t      max_exp = 127;\n-\t    }\n-\t  break;\n-\tcase 128: /* H_FLOAT */\n-\t  mant_dig = 113;\n-\t  min_exp = -16383;\n-\t  max_exp = 16383;\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-      break;\n-\n-    case IBM_FLOAT_FORMAT:\n-      switch (TYPE_PRECISION (type))\n-\t{\n-\tcase 32:\n-\t  mant_dig = 6;\n-\t  min_exp = -64;\n-\t  max_exp = 63;\n-\t  break;\n-\tcase 64:\n-\t  mant_dig = 14;\n-\t  min_exp = -64;\n-\t  max_exp = 63;\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-      break;\n-      \n-    case C4X_FLOAT_FORMAT:\n-      switch (TYPE_PRECISION (type))\n-\t{\n-\tcase 32:\n-\t  mant_dig = 24;\n-\t  min_exp = -126;\n-\t  max_exp = 128;\n-\t  break;\n-\tcase 64:\n-\t  mant_dig = 32;\n-\t  min_exp = -126;\n-\t  max_exp = 128;\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n+  /* The radix of the exponent representation.  */\n+  if (type == float_type_node)\n+    builtin_define_with_int_value (\"__FLT_RADIX__\", fmt->b);\n+  log10_b = log10_2 * fmt->log2_b;\n \n   /* The number of radix digits, p, in the floating-point significand.  */\n   sprintf (name, \"__%s_MANT_DIG__\", name_prefix);\n-  builtin_define_with_int_value (name, mant_dig);\n+  builtin_define_with_int_value (name, fmt->p);\n \n   /* The number of decimal digits, q, such that any floating-point number\n      with q decimal digits can be rounded into a floating-point number with\n@@ -4945,37 +4827,37 @@ builtin_define_float_constants (name_prefix, fp_suffix, type)\n \tp log10 b\t\t\tif b is a power of 10\n  \tfloor((p - 1) log10 b)\t\totherwise\n   */\n-  dig = (mant_dig - 1) * log10_b;\n+  dig = (fmt->p - 1) * log10_b;\n   sprintf (name, \"__%s_DIG__\", name_prefix);\n   builtin_define_with_int_value (name, dig);\n \n   /* The minimum negative int x such that b**(x-1) is a normalized float.  */\n   sprintf (name, \"__%s_MIN_EXP__\", name_prefix);\n-  sprintf (buf, \"(%d)\", min_exp);\n+  sprintf (buf, \"(%d)\", fmt->emin);\n   builtin_define_with_value (name, buf, 0);\n \n   /* The minimum negative int x such that 10**x is a normalized float,\n \n-\t  ceil (log10 (b ** (min_exp - 1)))\n-\t= ceil (log10 (b) * (min_exp - 1))\n+\t  ceil (log10 (b ** (emin - 1)))\n+\t= ceil (log10 (b) * (emin - 1))\n \n-     Recall that min_exp is negative, so the integer truncation calculates\n+     Recall that emin is negative, so the integer truncation calculates\n      the ceiling, not the floor, in this case.  */\n-  min_10_exp = (min_exp - 1) * log10_b;\n+  min_10_exp = (fmt->emin - 1) * log10_b;\n   sprintf (name, \"__%s_MIN_10_EXP__\", name_prefix);\n   sprintf (buf, \"(%d)\", min_10_exp);\n   builtin_define_with_value (name, buf, 0);\n \n   /* The maximum int x such that b**(x-1) is a representable float.  */\n   sprintf (name, \"__%s_MAX_EXP__\", name_prefix);\n-  builtin_define_with_int_value (name, max_exp);\n+  builtin_define_with_int_value (name, fmt->emax);\n \n   /* The maximum int x such that 10**x is in the range of representable\n      finite floating-point numbers,\n \n-\t  floor (log10((1 - b**-p) * b**max_exp))\n-\t= floor (log10(1 - b**-p) + log10(b**max_exp))\n-\t= floor (log10(1 - b**-p) + log10(b)*max_exp)\n+\t  floor (log10((1 - b**-p) * b**emax))\n+\t= floor (log10(1 - b**-p) + log10(b**emax))\n+\t= floor (log10(1 - b**-p) + log10(b)*emax)\n \n      The safest thing to do here is to just compute this number.  But since\n      we don't link cc1 with libm, we cannot.  We could implement log10 here\n@@ -4996,7 +4878,7 @@ builtin_define_float_constants (name_prefix, fp_suffix, type)\n      Hand-waving aside, crunching all of the sets of constants above by hand\n      does not yield a case for which the first term is significant, which\n      in the end is all that matters.  */\n-  max_10_exp = max_exp * log10_b;\n+  max_10_exp = fmt->emax * log10_b;\n   sprintf (name, \"__%s_MAX_10_EXP__\", name_prefix);\n   builtin_define_with_int_value (name, max_10_exp);\n \n@@ -5010,7 +4892,7 @@ builtin_define_float_constants (name_prefix, fp_suffix, type)\n      The only macro we care about is this number for the widest supported\n      floating type, but we want this value for rendering constants below.  */\n   {\n-    double d_decimal_dig = 1 + mant_dig * log10_b;\n+    double d_decimal_dig = 1 + fmt->p * log10_b;\n     decimal_dig = d_decimal_dig;\n     if (decimal_dig < d_decimal_dig)\n       decimal_dig++;\n@@ -5023,40 +4905,49 @@ builtin_define_float_constants (name_prefix, fp_suffix, type)\n      constants.  */\n \n   /* The maximum representable finite floating-point number,\n-     (1 - b**-p) * b**max_exp  */\n+     (1 - b**-p) * b**emax  */\n   {\n     int i, n;\n     char *p;\n \n     strcpy (buf, \"0x0.\");\n-    n = mant_dig * log2_b;\n+    n = fmt->p * fmt->log2_b;\n     for (i = 0, p = buf + 4; i + 3 < n; i += 4)\n       *p++ = 'f';\n     if (i < n)\n       *p++ = \"08ce\"[n - i];\n-    sprintf (p, \"p%d\", max_exp * log2_b);\n+    sprintf (p, \"p%d\", fmt->emax * fmt->log2_b);\n   }\n   sprintf (name, \"__%s_MAX__\", name_prefix);\n   builtin_define_with_hex_fp_value (name, type, decimal_dig, buf, fp_suffix);\n \n   /* The minimum normalized positive floating-point number,\n-     b**(min_exp-1).  */\n+     b**(emin-1).  */\n   sprintf (name, \"__%s_MIN__\", name_prefix);\n-  sprintf (buf, \"0x1p%d\", (min_exp - 1) * log2_b);\n+  sprintf (buf, \"0x1p%d\", (fmt->emin - 1) * fmt->log2_b);\n   builtin_define_with_hex_fp_value (name, type, decimal_dig, buf, fp_suffix);\n \n   /* The difference between 1 and the least value greater than 1 that is\n      representable in the given floating point type, b**(1-p).  */\n   sprintf (name, \"__%s_EPSILON__\", name_prefix);\n-  sprintf (buf, \"0x1p%d\", (1 - mant_dig) * log2_b);\n+  sprintf (buf, \"0x1p%d\", (1 - fmt->p) * fmt->log2_b);\n   builtin_define_with_hex_fp_value (name, type, decimal_dig, buf, fp_suffix);\n \n   /* For C++ std::numeric_limits<T>::denorm_min.  The minimum denormalized\n-     positive floating-point number, b**(min_exp-p).  Winds up being zero\n-     for targets that don't support denormals.  */\n+     positive floating-point number, b**(emin-p).  Zero for formats that\n+     don't support denormals.  */\n   sprintf (name, \"__%s_DENORM_MIN__\", name_prefix);\n-  sprintf (buf, \"0x1p%d\", (min_exp - mant_dig) * log2_b);\n-  builtin_define_with_hex_fp_value (name, type, decimal_dig, buf, fp_suffix);\n+  if (fmt->has_denorm)\n+    {\n+      sprintf (buf, \"0x1p%d\", (fmt->emin - fmt->p) * fmt->log2_b);\n+      builtin_define_with_hex_fp_value (name, type, decimal_dig,\n+\t\t\t\t\tbuf, fp_suffix);\n+    }\n+  else\n+    {\n+      sprintf (buf, \"0.0%s\", fp_suffix);\n+      builtin_define_with_value (name, buf, 0);\n+    }\n }\n \n /* Hook that registers front end and target-specific built-ins.  */\n@@ -5114,11 +5005,6 @@ cb_register_builtins (pfile)\n \n   /* float.h needs to know these.  */\n \n-  /* The radix of the exponent representation.  */\n-  builtin_define_with_int_value (\"__FLT_RADIX__\",\n-\t\t\t         (TARGET_FLOAT_FORMAT == IBM_FLOAT_FORMAT\n-\t\t\t          ? 16 : 2));\n-\n   builtin_define_with_int_value (\"__FLT_EVAL_METHOD__\",\n \t\t\t\t TARGET_FLT_EVAL_METHOD);\n "}]}