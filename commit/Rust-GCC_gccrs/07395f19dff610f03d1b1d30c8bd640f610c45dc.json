{"sha": "07395f19dff610f03d1b1d30c8bd640f610c45dc", "node_id": "C_kwDOANBUbNoAKDA3Mzk1ZjE5ZGZmNjEwZjAzZDFiMWQzMGM4YmQ2NDBmNjEwYzQ1ZGM", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2022-02-16T14:44:27Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2022-03-04T13:47:19Z"}, "message": "Test '-fopt-info-omp-all' in 'libgomp.oacc-*/kernels-private-vars-*'\n\n\tlibgomp/\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-1.c:\n\tTest '-fopt-info-omp-all'.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-2.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-3.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-4.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-5.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-1.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-2.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-3.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-4.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-5.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-6.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-vector-1.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-vector-2.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-1.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-2.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-3.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-4.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-5.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-6.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-7.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-1.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-2.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-3.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-6.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-vector-1.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-vector-2.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-1.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-2.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-3.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-4.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-5.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-6.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-7.f90:\n\tLikewise.", "tree": {"sha": "536244b9328d16165a0ff1f8bc70d24f219fc258", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/536244b9328d16165a0ff1f8bc70d24f219fc258"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07395f19dff610f03d1b1d30c8bd640f610c45dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07395f19dff610f03d1b1d30c8bd640f610c45dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07395f19dff610f03d1b1d30c8bd640f610c45dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07395f19dff610f03d1b1d30c8bd640f610c45dc/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8935589b496f755e08cadf26d8ceddf0dd6e0968", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8935589b496f755e08cadf26d8ceddf0dd6e0968", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8935589b496f755e08cadf26d8ceddf0dd6e0968"}], "stats": {"total": 1325, "additions": 811, "deletions": 514}, "files": [{"sha": "acbeb65273f2d6fc6b8eb614c6d25d947c3d3edb", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-1.c", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-1.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,14 +1,22 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n-\n-#include <assert.h>\n-\n /* Test of worker-private variables declared in a local scope, broadcasting\n    to vector-partitioned mode.  Back-to-back worker loops.  */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n+\n int\n main (int argc, char* argv[])\n {\n@@ -17,46 +25,47 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr)\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n   {\n     int j;\n \n-    #pragma acc loop gang(num:32)\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+    #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n-\t#pragma acc loop worker(num:32)\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n-\t/* { dg-note {variable 'x' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-3 } */\n+\t#pragma acc loop worker(num:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'x' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n \t    int k;\n \t    int x = i ^ j * 3;\n \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += x * k;\n \t  }\n \n-\t#pragma acc loop worker(num:32)\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n-\t/* { dg-note {variable 'x' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-3 } */\n+\t#pragma acc loop worker(num:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'x' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n \t    int k;\n \t    int x = i | j * 5;\n \t    \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += x * k;\n \t  }\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "2558a68eb9454c52d2fcc51326b1330fdd5d424b", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-2.c", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-2.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,14 +1,22 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n-\n-#include <assert.h>\n-\n /* Test of worker-private variables declared in a local scope, broadcasting\n    to vector-partitioned mode.  Successive vector loops.  */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n+\n int\n main (int argc, char* argv[])\n {\n@@ -17,38 +25,39 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr)\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n   {\n     int j;\n \n-    #pragma acc loop gang(num:32)\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+    #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n-        #pragma acc loop worker(num:32)\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n-\t/* { dg-note {variable 'x' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-3 } */\n+        #pragma acc loop worker(num:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'x' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n \t    int k;\n \t    int x = i ^ j * 3;\n \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += x * k;\n \t    \n \t    x = i | j * 5;\n \t    \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += x * k;\n \t  }\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "b2a208c163f687e97f0b11ae90778182f84cd759", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-3.c", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-3.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,14 +1,22 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n-\n-#include <assert.h>\n-\n /* Test of worker-private variables declared in a local scope, broadcasting\n    to vector-partitioned mode.  Aggregate worker variable.  */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n+\n typedef struct\n {\n   int x, y;\n@@ -22,19 +30,19 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr)\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n   {\n     int j;\n \n-    #pragma acc loop gang(num:32)\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+    #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n-        #pragma acc loop worker(num:32)\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n-\t/* { dg-note {variable 'pt' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-3 } */\n+        #pragma acc loop worker(num:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'pt' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n \t    int k;\n@@ -43,18 +51,19 @@ main (int argc, char* argv[])\n \t    pt.x = i ^ j * 3;\n \t    pt.y = i | j * 5;\n \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += pt.x * k;\n \t    \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += pt.y * k;\n \t  }\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "46c395620feafe2dc6a88bdf2c2fe4b11b080c07", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-4.c", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-4.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,14 +1,22 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n-\n-#include <assert.h>\n-\n /* Test of worker-private variables declared in a local scope, broadcasting\n    to vector-partitioned mode.  Addressable worker variable.  */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n+\n typedef struct\n {\n   int x, y;\n@@ -22,20 +30,20 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr)\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n   {\n     int j;\n \n-    #pragma acc loop gang(num:32)\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+    #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n-        #pragma acc loop worker(num:32)\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n-\t/* { dg-note {variable 'pt' declared in block is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } .-3 } */\n-\t/* { dg-note {variable 'ptp' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-4 } */\n+        #pragma acc loop worker(num:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'pt' declared in block is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'ptp' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n \t    int k;\n@@ -45,20 +53,21 @@ main (int argc, char* argv[])\n \t    \n \t    pt.x = i ^ j * 3;\n \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += ptp->x * k;\n \n \t    ptp->y = i | j * 5;\n \t    \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += pt.y * k;\n \t  }\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "4b5a15e6ad4d937c1f45aaf0bb37acb4563a0c7f", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-5.c", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-5.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,14 +1,22 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n-\n-#include <assert.h>\n-\n /* Test of worker-private variables declared in a local scope, broadcasting\n    to vector-partitioned mode.  Array worker variable.  */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n+\n int\n main (int argc, char* argv[])\n {\n@@ -17,40 +25,41 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr)\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n   {\n     int j;\n \n-    #pragma acc loop gang(num:32)\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+    #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n-        #pragma acc loop worker(num:32)\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n-\t/* { dg-note {variable 'pt' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-3 } */\n+        #pragma acc loop worker(num:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'pt' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n \t    int k;\n \t    int pt[2];\n \t    \n \t    pt[0] = i ^ j * 3;\n \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += pt[0] * k;\n \n \t    pt[1] = i | j * 5;\n \t    \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += pt[1] * k;\n \t  }\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "4a824941427fcac9901a1150ef6b38401a8cbe86", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-1.c", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-1.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,12 +1,20 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n+/* Test of gang-private variables declared on loop directive.  */\n \n-#include <assert.h>\n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n-/* Test of gang-private variables declared on loop directive.  */\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n \n int\n main (int argc, char* argv[])\n@@ -16,17 +24,18 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr)\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n   {\n-    #pragma acc loop gang(num:32) private(x)\n-    /* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n+    #pragma acc loop gang(num:32) private(x) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n \tx = i * 2;\n \tarr[i] += x;\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     assert (arr[i] == i * 3);"}, {"sha": "039053f3c868b1b77fef2a4d10a53467279c42ec", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-2.c", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-2.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,14 +1,22 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n-\n-#include <assert.h>\n-\n /* Test of gang-private variables declared on loop directive, with broadcasting\n    to partitioned workers.  */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n+\n int\n main (int argc, char* argv[])\n {\n@@ -17,22 +25,23 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr)\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n   {\n-    #pragma acc loop gang(num:32) private(x)\n-    /* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n-    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-3 } */\n+    #pragma acc loop gang(num:32) private(x) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n \tx = i * 2;\n \n-\t#pragma acc loop worker(num:32)\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t#pragma acc loop worker(num:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (int j = 0; j < 32; j++)\n \t  arr[i * 32 + j] += x;\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32 * 32; i++)\n     assert (arr[i] == i + (i / 32) * 2);"}, {"sha": "2b89659a0076d06dfdd0ce7acc9a278671376ad9", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-3.c", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-3.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,14 +1,22 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n-\n-#include <assert.h>\n-\n /* Test of gang-private variables declared on loop directive, with broadcasting\n    to partitioned vectors.  */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n+\n int\n main (int argc, char* argv[])\n {\n@@ -17,22 +25,23 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr)\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n   {\n-    #pragma acc loop gang(num:32) private(x)\n-    /* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n-    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-3 } */\n+    #pragma acc loop gang(num:32) private(x) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n \tx = i * 2;\n \n-\t#pragma acc loop vector(length:32)\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t#pragma acc loop vector(length:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (int j = 0; j < 32; j++)\n \t  arr[i * 32 + j] += x;\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32 * 32; i++)\n     assert (arr[i] == i + (i / 32) * 2);"}, {"sha": "707607059253a69537c9da1e75b1eabd1a260b94", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-4.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-4.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,14 +1,22 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n-\n-#include <assert.h>\n-\n /* Test of gang-private addressable variable declared on loop directive, with\n    broadcasting to partitioned workers.  */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n+\n int\n main (int argc, char* argv[])\n {\n@@ -17,27 +25,28 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr)\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n   {\n-    #pragma acc loop gang(num:32) private(x)\n-    /* { dg-note {variable 'x' in 'private' clause is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } .-1 } */\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n-    /* { dg-note {variable 'p' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-3 } */\n-    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-4 } */\n+    #pragma acc loop gang(num:32) private(x) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'x' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'p' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n         int *p = &x;\n \n \tx = i * 2;\n \n-\t#pragma acc loop worker(num:32)\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t#pragma acc loop worker(num:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (int j = 0; j < 32; j++)\n \t  arr[i * 32 + j] += x;\n \n \t(*p)--;\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32 * 32; i++)\n     assert (arr[i] == i + (i / 32) * 2);"}, {"sha": "edf0e24af8b453e116512f37e37be130b8a7c743", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-5.c", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-5.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,14 +1,22 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n-\n-#include <assert.h>\n-\n /* Test of gang-private array variable declared on loop directive, with\n    broadcasting to partitioned workers.  */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n+\n int\n main (int argc, char* argv[])\n {\n@@ -17,23 +25,24 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr)\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n   {\n-    #pragma acc loop gang(num:32) private(x)\n-    /* { dg-note {variable 'x' in 'private' clause is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } .-1 } */\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n-    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-3 } */\n+    #pragma acc loop gang(num:32) private(x) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'x' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n         for (int j = 0; j < 8; j++)\n \t  x[j] = j * 2;\n \n-\t#pragma acc loop worker(num:32)\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t#pragma acc loop worker(num:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (int j = 0; j < 32; j++)\n \t  arr[i * 32 + j] += x[j % 8];\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32 * 32; i++)\n     assert (arr[i] == i + (i % 8) * 2);"}, {"sha": "a2df33b767dd7637ed22bdd4e60c03af1ee6b970", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-6.c", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-6.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,14 +1,22 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n-\n-#include <assert.h>\n-\n /* Test of gang-private aggregate variable declared on loop directive, with\n    broadcasting to partitioned workers.  */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n+\n typedef struct {\n   int x, y, z;\n   int attr[13];\n@@ -23,25 +31,26 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr)\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n   {\n-    #pragma acc loop gang private(pt)\n-    /* { dg-note {variable 'pt' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n-    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-3 } */\n+    #pragma acc loop gang private(pt) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'pt' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n         pt.x = i;\n \tpt.y = i * 2;\n \tpt.z = i * 4;\n \tpt.attr[5] = i * 6;\n \n-\t#pragma acc loop worker\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t#pragma acc loop worker /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (int j = 0; j < 32; j++)\n \t  arr[i * 32 + j] += pt.x + pt.y + pt.z + pt.attr[5];\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32 * 32; i++)\n     assert (arr[i] == i + (i / 32) * 13);"}, {"sha": "51c1de53414a86ed8e80bc35bb60bb6762e2b5a5", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-vector-1.c", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-vector-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-vector-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-vector-1.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,12 +1,20 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n+/* Test of vector-private variables declared on loop directive.  */\n \n-#include <assert.h>\n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n-/* Test of vector-private variables declared on loop directive.  */\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n \n int\n main (int argc, char* argv[])\n@@ -16,34 +24,34 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr)\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n   {\n     int j;\n \n-    #pragma acc loop gang(num:32)\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+    #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n-        #pragma acc loop worker(num:32)\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n+        #pragma acc loop worker(num:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n \t    int k;\n \n-\t    #pragma acc loop vector(length:32) private(x)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-\t    /* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n+\t    #pragma acc loop vector(length:32) private(x) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n+\t    /* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      {\n \t\tx = i ^ j * 3;\n \t\tarr[i * 1024 + j * 32 + k] += x * k;\n \t      }\n \n-\t    #pragma acc loop vector(length:32) private(x)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-\t    /* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n+\t    #pragma acc loop vector(length:32) private(x) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n+\t    /* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      {\n \t\tx = i | j * 5;\n@@ -52,6 +60,7 @@ main (int argc, char* argv[])\n \t  }\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "cb90eaab99d3962dba1c6190cd4fc7ec26ee1f45", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-vector-2.c", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-vector-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-vector-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-vector-2.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,12 +1,20 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n+/* Test of vector-private variables declared on loop directive. Array type.  */\n \n-#include <assert.h>\n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n-/* Test of vector-private variables declared on loop directive. Array type.  */\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n \n int\n main (int argc, char* argv[])\n@@ -16,25 +24,25 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr)\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n   {\n     int j;\n \n-    #pragma acc loop gang(num:32)\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+    #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n-        #pragma acc loop worker(num:32)\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n+        #pragma acc loop worker(num:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n \t    int k;\n \n-\t    #pragma acc loop vector(length:32) private(pt)\n-\t    /* { dg-note {variable 'pt' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n+\t    #pragma acc loop vector(length:32) private(pt) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'pt' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      {\n \t        pt[0] = i ^ j * 3;\n@@ -45,6 +53,7 @@ main (int argc, char* argv[])\n \t  }\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "54e1c93714b90fef58c16f404d26219ab0f6548a", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-1.c", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-1.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,12 +1,20 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n+/* Test of worker-private variables declared on a loop directive.  */\n \n-#include <assert.h>\n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n-/* Test of worker-private variables declared on a loop directive.  */\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n \n int\n main (int argc, char* argv[])\n@@ -16,18 +24,18 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr)\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n   {\n     int j;\n \n-    #pragma acc loop gang(num:32)\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+    #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n-        #pragma acc loop worker(num:32) private(x)\n-\t/* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n+        #pragma acc loop worker(num:32) private(x) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n \t    x = i ^ j * 3;\n@@ -38,6 +46,7 @@ main (int argc, char* argv[])\n \t  }\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32 * 32; i++)\n     assert (arr[i] == i + ((i / 32) ^ (i % 32) * 3));"}, {"sha": "80ac99013d68a4a2932a36c303b911cbd6eefd85", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-2.c", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-2.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,14 +1,22 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n-\n-#include <assert.h>\n-\n /* Test of worker-private variables declared on a loop directive, broadcasting\n    to vector-partitioned mode.  */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n+\n int\n main (int argc, char* argv[])\n {\n@@ -17,31 +25,32 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr)\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n   {\n     int j;\n \n-    #pragma acc loop gang(num:32)\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+    #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n-        #pragma acc loop worker(num:32) private(x)\n-\t/* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n-\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-3 } */\n+        #pragma acc loop worker(num:32) private(x) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n \t    int k;\n \t    x = i ^ j * 3;\n \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += x * k;\n \t  }\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "a05ac6091230a170377a4d2600d8cd2af952f07c", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-3.c", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-3.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,14 +1,22 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n-\n-#include <assert.h>\n-\n /* Test of worker-private variables declared on a loop directive, broadcasting\n    to vector-partitioned mode.  Back-to-back worker loops.  */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n+\n int\n main (int argc, char* argv[])\n {\n@@ -17,46 +25,47 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr)\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n   {\n     int j;\n \n-    #pragma acc loop gang(num:32)\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+    #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n-        #pragma acc loop worker(num:32) private(x)\n-\t/* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n-\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-3 } */\n+        #pragma acc loop worker(num:32) private(x) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n \t    int k;\n \t    x = i ^ j * 3;\n \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += x * k;\n \t  }\n \n-\t#pragma acc loop worker(num:32) private(x)\n-\t/* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n-\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-3 } */\n+\t#pragma acc loop worker(num:32) private(x) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n \t    int k;\n \t    x = i | j * 5;\n \t    \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += x * k;\n \t  }\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "d46bb948626304348bfb384451623aeb3675cfc6", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-4.c", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-4.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,14 +1,22 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n-\n-#include <assert.h>\n-\n /* Test of worker-private variables declared on a loop directive, broadcasting\n    to vector-partitioned mode.  Successive vector loops.  */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n+\n int\n main (int argc, char* argv[])\n {\n@@ -17,38 +25,39 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr)\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n   {\n     int j;\n \n-    #pragma acc loop gang(num:32)\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+    #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n-        #pragma acc loop worker(num:32) private(x)\n-\t/* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n-\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-3 } */\n+        #pragma acc loop worker(num:32) private(x) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n \t    int k;\n \t    x = i ^ j * 3;\n \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += x * k;\n \t    \n \t    x = i | j * 5;\n \t    \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += x * k;\n \t  }\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "644c61758637aa2dd32c5a20aa4477aa9921b89f", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-5.c", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-5.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,14 +1,22 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n-\n-#include <assert.h>\n-\n /* Test of worker-private variables declared on a loop directive, broadcasting\n    to vector-partitioned mode.  Addressable worker variable.  */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n+\n int\n main (int argc, char* argv[])\n {\n@@ -17,41 +25,42 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr)\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n   {\n     int j;\n \n-    #pragma acc loop gang(num:32)\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+    #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n-        #pragma acc loop worker(num:32) private(x)\n-\t/* { dg-note {variable 'x' in 'private' clause is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } .-1 } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n-\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-3 } */\n-\t/* { dg-note {variable 'p' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-4 } */\n+        #pragma acc loop worker(num:32) private(x) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'x' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'p' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n \t    int k;\n \t    int *p = &x;\n \t    \n \t    x = i ^ j * 3;\n \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += x * k;\n \t    \n \t    *p = i | j * 5;\n \t    \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += x * k;\n \t  }\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "182a12a1b3f3136409bbecc37516768bb421f0ce", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-6.c", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-6.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,14 +1,22 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n-\n-#include <assert.h>\n-\n /* Test of worker-private variables declared on a loop directive, broadcasting\n    to vector-partitioned mode.  Aggregate worker variable.  */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n+\n typedef struct\n {\n   int x, y;\n@@ -23,38 +31,39 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr)\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n   {\n     int j;\n \n-    #pragma acc loop gang(num:32)\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+    #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n-        #pragma acc loop worker(num:32) private(pt)\n-\t/* { dg-note {variable 'pt' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n-\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-3 } */\n+        #pragma acc loop worker(num:32) private(pt) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'pt' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n \t    int k;\n \t    \n \t    pt.x = i ^ j * 3;\n \t    pt.y = i | j * 5;\n \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += pt.x * k;\n \t    \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += pt.y * k;\n \t  }\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "bdfbb59c5c564adb6acca9e1f7f08cebaf417aa5", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-7.c", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-7.c?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -1,14 +1,22 @@\n-/* { dg-additional-options \"-fopt-info-note-omp\" }\n-   { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-   for testing/documenting aspects of that functionality.  */\n-\n-#include <assert.h>\n-\n /* Test of worker-private variables declared on loop directive, broadcasting\n    to vector-partitioned mode.  Array worker variable.  */\n \n+/* { dg-additional-options \"-fopt-info-omp-all\" }\n+   { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n+#include <assert.h>\n+\n int\n main (int argc, char* argv[])\n {\n@@ -20,40 +28,41 @@ main (int argc, char* argv[])\n \n   /* \"pt\" is treated as \"present_or_copy\" on the kernels directive because it\n      is an array variable.  */\n-  #pragma acc kernels copy(arr)\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n   {\n     int j;\n \n-    #pragma acc loop gang(num:32)\n-    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+    #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n         /* But here, it is made private per-worker.  */\n-        #pragma acc loop worker(num:32) private(pt)\n-\t/* { dg-note {variable 'pt' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 } */\n-\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-3 } */\n+        #pragma acc loop worker(num:32) private(pt) /* { dg-line l_loop_j[incr c_loop_j] } */\n+\t/* { dg-note {variable 'pt' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n \t    int k;\n \t    \n \t    pt[0] = i ^ j * 3;\n \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += pt[0] * k;\n \n \t    pt[1] = i | j * 5;\n \t    \n-\t    #pragma acc loop vector(length:32)\n-\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 } */\n+\t    #pragma acc loop vector(length:32) /* { dg-line l_loop_k[incr c_loop_k] } */\n+\t    /* { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k } */\n \t    for (k = 0; k < 32; k++)\n \t      arr[i * 1024 + j * 32 + k] += pt[1] * k;\n \t  }\n       }\n   }\n+  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "09ab39566245a0c679037da130202294ade8375a", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-1.f90", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-1.f90?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -2,11 +2,19 @@\n \n ! { dg-do run }\n \n-! { dg-additional-options \"-fopt-info-note-omp\" }\n+! { dg-additional-options \"-fopt-info-omp-all\" }\n+! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n+\n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-! { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-! for testing/documenting aspects of that functionality.\n+\n+! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+! so to maintain compatibility with earlier Tcl releases, we manually\n+! initialize counter variables:\n+! { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+! \"WARNING: dg-line var l_dummy defined, but not used\".\n \n program main\n   integer :: x, i, arr(32)\n@@ -15,15 +23,16 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr)\n-  !$acc loop gang(num:32) private(x)\n-  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n-  ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 }\n+  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc loop gang(num:32) private(x) ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, 32\n      x = i * 2;\n      arr(i) = arr(i) + x;\n   end do\n   !$acc end kernels\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 1, 32\n      if (arr(i) .ne. i * 3) stop 1"}, {"sha": "bec1069c2a843e0baef6767cc8a6c0d2eda57878", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-2.f90", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-2.f90?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -3,11 +3,19 @@\n \n ! { dg-do run }\n \n-! { dg-additional-options \"-fopt-info-note-omp\" }\n+! { dg-additional-options \"-fopt-info-omp-all\" }\n+! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n+\n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-! { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-! for testing/documenting aspects of that functionality.\n+\n+! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+! so to maintain compatibility with earlier Tcl releases, we manually\n+! initialize counter variables:\n+! { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+! \"WARNING: dg-line var l_dummy defined, but not used\".\n \n program main\n   integer :: x, i, j, arr(0:32*32)\n@@ -16,20 +24,21 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr)\n-  !$acc loop gang(num:32) private(x)\n-  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n-  ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 }\n+  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc loop gang(num:32) private(x) ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n      x = i * 2;\n \n-     !$acc loop worker(num:32)\n-     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+     !$acc loop worker(num:32) ! { dg-line l_loop_j[incr c_loop_j] }\n+     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n      do j = 0, 31\n         arr(i * 32 + j) = arr(i * 32 + j) + x;\n      end do\n   end do\n   !$acc end kernels\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 * 32 - 1\n      if (arr(i) .ne. i + (i / 32) * 2) stop 1"}, {"sha": "9fde012c19c0c21b7f29d17f6b7fe2d2b88206d1", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-3.f90", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-3.f90?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -3,11 +3,19 @@\n \n ! { dg-do run }\n \n-! { dg-additional-options \"-fopt-info-note-omp\" }\n+! { dg-additional-options \"-fopt-info-omp-all\" }\n+! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n+\n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-! { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-! for testing/documenting aspects of that functionality.\n+\n+! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+! so to maintain compatibility with earlier Tcl releases, we manually\n+! initialize counter variables:\n+! { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+! \"WARNING: dg-line var l_dummy defined, but not used\".\n \n program main\n   integer :: x, i, j, arr(0:32*32)\n@@ -16,20 +24,21 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr)\n-  !$acc loop gang(num:32) private(x)\n-  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n-  ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 }\n+  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc loop gang(num:32) private(x) ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n      x = i * 2;\n \n-     !$acc loop vector(length:32)\n-     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+     !$acc loop vector(length:32) ! { dg-line l_loop_j[incr c_loop_j] }\n+     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n      do j = 0, 31\n         arr(i * 32 + j) = arr(i * 32 + j) + x;\n      end do\n   end do\n   !$acc end kernels\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 * 32 - 1\n      if (arr(i) .ne. i + (i / 32) * 2) stop 1"}, {"sha": "02e09b31cf72b75d59d766a5a7cbdc37465b4997", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-6.f90", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-6.f90?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -3,11 +3,19 @@\n \n ! { dg-do run }\n \n-! { dg-additional-options \"-fopt-info-note-omp\" }\n+! { dg-additional-options \"-fopt-info-omp-all\" }\n+! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n+\n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-! { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-! for testing/documenting aspects of that functionality.\n+\n+! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+! so to maintain compatibility with earlier Tcl releases, we manually\n+! initialize counter variables:\n+! { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+! \"WARNING: dg-line var l_dummy defined, but not used\".\n \n program main\n   type vec3\n@@ -21,23 +29,24 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr)\n-  !$acc loop gang(num:32) private(pt)\n-  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n-  ! { dg-note {variable 'pt' in 'private' clause is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } .-2 }\n+  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc loop gang(num:32) private(pt) ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n+  ! { dg-note {variable 'pt' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n      pt%x = i\n      pt%y = i * 2\n      pt%z = i * 4\n      pt%attr(5) = i * 6\n \n-     !$acc loop vector(length:32)\n-     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+     !$acc loop vector(length:32) ! { dg-line l_loop_j[incr c_loop_j] }\n+     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n      do j = 0, 31\n         arr(i * 32 + j) = arr(i * 32 + j) + pt%x + pt%y + pt%z + pt%attr(5);\n      end do\n   end do\n   !$acc end kernels\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 * 32 - 1\n      if (arr(i) .ne. i + (i / 32) * 13) stop 1"}, {"sha": "5811d0c41b7399427f1bc7c0dddb441c6e64f1c3", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-vector-1.f90", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-vector-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-vector-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-vector-1.f90?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -2,11 +2,19 @@\n \n ! { dg-do run }\n \n-! { dg-additional-options \"-fopt-info-note-omp\" }\n+! { dg-additional-options \"-fopt-info-omp-all\" }\n+! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n+\n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-! { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-! for testing/documenting aspects of that functionality.\n+\n+! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+! so to maintain compatibility with earlier Tcl releases, we manually\n+! initialize counter variables:\n+! { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+! \"WARNING: dg-line var l_dummy defined, but not used\".\n \n program main\n   integer :: x, i, j, k, idx, arr(0:32*32*32)\n@@ -15,30 +23,31 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr)\n-  !$acc loop gang(num:32)\n-  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc loop gang(num:32) ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n-     !$acc loop worker(num:8)\n-     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+     !$acc loop worker(num:8) ! { dg-line l_loop_j[incr c_loop_j] }\n+     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n      do j = 0, 31\n-        !$acc loop vector(length:32) private(x)\n-        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n-        ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 }\n+        !$acc loop vector(length:32) private(x) ! { dg-line l_loop_k[incr c_loop_k] }\n+        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k }\n+        ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k }\n         do k = 0, 31\n            x = ieor(i, j * 3)\n            arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + x * k\n         end do\n-        !$acc loop vector(length:32) private(x)\n-        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n-        ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 }\n+        !$acc loop vector(length:32) private(x) ! { dg-line l_loop_k[incr c_loop_k] }\n+        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k }\n+        ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k }\n         do k = 0, 31\n            x = ior(i, j * 5)\n            arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + x * k\n         end do\n      end do\n   end do\n   !$acc end kernels\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 - 1\n      do j = 0, 32 -1"}, {"sha": "81125a24d0d1eb76020d96db45fdb6f9a7f5ea7a", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-vector-2.f90", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-vector-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-vector-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-vector-2.f90?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -2,11 +2,19 @@\n \n ! { dg-do run }\n \n-! { dg-additional-options \"-fopt-info-note-omp\" }\n+! { dg-additional-options \"-fopt-info-omp-all\" }\n+! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n+\n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-! { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-! for testing/documenting aspects of that functionality.\n+\n+! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+! so to maintain compatibility with earlier Tcl releases, we manually\n+! initialize counter variables:\n+! { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+! \"WARNING: dg-line var l_dummy defined, but not used\".\n \n program main\n   integer :: i, j, k, idx, arr(0:32*32*32), pt(2)\n@@ -15,16 +23,16 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr)\n-  !$acc loop gang(num:32)\n-  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc loop gang(num:32) ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n-     !$acc loop worker(num:8)\n-     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+     !$acc loop worker(num:8) ! { dg-line l_loop_j[incr c_loop_j] }\n+     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n      do j = 0, 31\n-        !$acc loop vector(length:32) private(x, pt)\n-        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n-        ! { dg-note {variable 'pt' in 'private' clause is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } .-2 }\n+        !$acc loop vector(length:32) private(x, pt) ! { dg-line l_loop_k[incr c_loop_k] }\n+        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k }\n+        ! { dg-note {variable 'pt' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l_loop_k$c_loop_k }\n         do k = 0, 31\n            pt(1) = ieor(i, j * 3)\n            pt(2) = ior(i, j * 5)\n@@ -34,6 +42,7 @@ program main\n      end do\n   end do\n   !$acc end kernels\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 - 1\n      do j = 0, 32 -1"}, {"sha": "824c198799ccb6d836b02d06c107f39d1cdc6b3c", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-1.f90", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-1.f90?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -2,11 +2,19 @@\n \n ! { dg-do run }\n \n-! { dg-additional-options \"-fopt-info-note-omp\" }\n+! { dg-additional-options \"-fopt-info-omp-all\" }\n+! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n+\n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-! { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-! for testing/documenting aspects of that functionality.\n+\n+! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+! so to maintain compatibility with earlier Tcl releases, we manually\n+! initialize counter variables:\n+! { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+! \"WARNING: dg-line var l_dummy defined, but not used\".\n \n program main\n   integer :: x, i, j, arr(0:32*32)\n@@ -16,19 +24,20 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr)\n-  !$acc loop gang(num:32) private(x)\n-  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc loop gang(num:32) private(x) ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n-     !$acc loop worker(num:8) private(x)\n-     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n-     ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 }\n+     !$acc loop worker(num:8) private(x) ! { dg-line l_loop_j[incr c_loop_j] }\n+     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n+     ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n      do j = 0, 31\n         x = ieor(i, j * 3)\n         arr(i * 32 + j) = arr(i * 32 + j) + x\n      end do\n   end do\n   !$acc end kernels\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 * 32 - 1\n      if (arr(i) .ne. i + ieor(i / 32, mod(i, 32) * 3)) stop 1"}, {"sha": "d25d419a11e0f02675e063040c6b395713f05a90", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-2.f90", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-2.f90?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -3,11 +3,19 @@\n \n ! { dg-do run }\n \n-! { dg-additional-options \"-fopt-info-note-omp\" }\n+! { dg-additional-options \"-fopt-info-omp-all\" }\n+! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n+\n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-! { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-! for testing/documenting aspects of that functionality.\n+\n+! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+! so to maintain compatibility with earlier Tcl releases, we manually\n+! initialize counter variables:\n+! { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+! \"WARNING: dg-line var l_dummy defined, but not used\".\n \n program main\n   integer :: x, i, j, k, idx, arr(0:32*32*32)\n@@ -16,24 +24,25 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr)\n-  !$acc loop gang(num:32)\n-  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc loop gang(num:32) ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n-     !$acc loop worker(num:8) private(x)\n-     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n-     ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 }\n+     !$acc loop worker(num:8) private(x) ! { dg-line l_loop_j[incr c_loop_j] }\n+     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n+     ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n      do j = 0, 31\n         x = ieor(i, j * 3)\n \n-        !$acc loop vector(length:32)\n-        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+        !$acc loop vector(length:32) ! { dg-line l_loop_k[incr c_loop_k] }\n+        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k }\n         do k = 0, 31\n            arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + x * k\n         end do\n      end do\n   end do\n   !$acc end kernels\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 - 1\n      do j = 0, 32 -1"}, {"sha": "7a69145b3b61fc87c88b0ea474a308d122d0b271", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-3.f90", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-3.f90?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -3,11 +3,19 @@\n \n ! { dg-do run }\n \n-! { dg-additional-options \"-fopt-info-note-omp\" }\n+! { dg-additional-options \"-fopt-info-omp-all\" }\n+! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n+\n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-! { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-! for testing/documenting aspects of that functionality.\n+\n+! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+! so to maintain compatibility with earlier Tcl releases, we manually\n+! initialize counter variables:\n+! { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+! \"WARNING: dg-line var l_dummy defined, but not used\".\n \n program main\n   integer :: x, i, j, k, idx, arr(0:32*32*32)\n@@ -16,37 +24,38 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr)\n-  !$acc loop gang(num:32)\n-  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc loop gang(num:32) ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n-     !$acc loop worker(num:8) private(x)\n-     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n-     ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 }\n+     !$acc loop worker(num:8) private(x) ! { dg-line l_loop_j[incr c_loop_j] }\n+     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n+     ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n      do j = 0, 31\n         x = ieor(i, j * 3)\n \n-        !$acc loop vector(length:32)\n-        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+        !$acc loop vector(length:32) ! { dg-line l_loop_k[incr c_loop_k] }\n+        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k }\n         do k = 0, 31\n            arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + x * k\n         end do\n      end do\n \n-     !$acc loop worker(num:8) private(x)\n-     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n-     ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 }\n+     !$acc loop worker(num:8) private(x) ! { dg-line l_loop_j[incr c_loop_j] }\n+     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n+     ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n      do j = 0, 31\n         x = ior(i, j * 5)\n \n-        !$acc loop vector(length:32)\n-        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+        !$acc loop vector(length:32) ! { dg-line l_loop_k[incr c_loop_k] }\n+        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k }\n         do k = 0, 31\n            arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + x * k\n         end do\n      end do\n   end do\n   !$acc end kernels\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 - 1\n      do j = 0, 32 -1"}, {"sha": "2c1d5665ce55178397b6068f5ceb867e587d4b0c", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-4.f90", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-4.f90?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -3,11 +3,19 @@\n \n ! { dg-do run }\n \n-! { dg-additional-options \"-fopt-info-note-omp\" }\n+! { dg-additional-options \"-fopt-info-omp-all\" }\n+! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n+\n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-! { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-! for testing/documenting aspects of that functionality.\n+\n+! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+! so to maintain compatibility with earlier Tcl releases, we manually\n+! initialize counter variables:\n+! { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+! \"WARNING: dg-line var l_dummy defined, but not used\".\n \n program main\n   integer :: x, i, j, k, idx, arr(0:32*32*32)\n@@ -16,32 +24,33 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr)\n-  !$acc loop gang(num:32)\n-  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc loop gang(num:32) ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n-     !$acc loop worker(num:8) private(x)\n-     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n-     ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 }\n+     !$acc loop worker(num:8) private(x) ! { dg-line l_loop_j[incr c_loop_j] }\n+     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n+     ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n      do j = 0, 31\n         x = ieor(i, j * 3)\n \n-        !$acc loop vector(length:32)\n-        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+        !$acc loop vector(length:32) ! { dg-line l_loop_k[incr c_loop_k] }\n+        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k }\n         do k = 0, 31\n            arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + x * k\n         end do\n \n         x = ior(i, j * 5)\n \n-        !$acc loop vector(length:32)\n-        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+        !$acc loop vector(length:32) ! { dg-line l_loop_k[incr c_loop_k] }\n+        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k }\n         do k = 0, 31\n            arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + x * k\n         end do\n      end do\n   end do\n   !$acc end kernels\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 - 1\n      do j = 0, 32 -1"}, {"sha": "4936e569b4440132677f7fb6b95be643b1ee39fe", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-5.f90", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-5.f90?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -3,11 +3,19 @@\n \n ! { dg-do run }\n \n-! { dg-additional-options \"-fopt-info-note-omp\" }\n+! { dg-additional-options \"-fopt-info-omp-all\" }\n+! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n+\n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-! { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-! for testing/documenting aspects of that functionality.\n+\n+! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+! so to maintain compatibility with earlier Tcl releases, we manually\n+! initialize counter variables:\n+! { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+! \"WARNING: dg-line var l_dummy defined, but not used\".\n \n program main\n   integer :: i, j, k, idx, arr(0:32*32*32)\n@@ -18,34 +26,35 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr)\n-  !$acc loop gang(num:32)\n-  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc loop gang(num:32) ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n-     !$acc loop worker(num:8) private(x, p)\n-     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n-     ! { dg-note {variable 'x' in 'private' clause is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } .-2 }\n-     ! { dg-note {variable 'p' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-3 }\n+     !$acc loop worker(num:8) private(x, p) ! { dg-line l_loop_j[incr c_loop_j] }\n+     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n+     ! { dg-note {variable 'x' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l_loop_j$c_loop_j }\n+     ! { dg-note {variable 'p' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n      do j = 0, 31\n         p => x\n         x = ieor(i, j * 3)\n \n-        !$acc loop vector(length:32)\n-        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+        !$acc loop vector(length:32) ! { dg-line l_loop_k[incr c_loop_k] }\n+        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k }\n         do k = 0, 31\n            arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + x * k\n         end do\n \n         p = ior(i, j * 5)\n \n-        !$acc loop vector(length:32)\n-        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+        !$acc loop vector(length:32) ! { dg-line l_loop_k[incr c_loop_k] }\n+        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k }\n         do k = 0, 31\n            arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + x * k\n         end do\n      end do\n   end do\n   !$acc end kernels\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 - 1\n      do j = 0, 32 -1"}, {"sha": "6b2ec1a004727c1703d30e6f2c7405fcb163ba7a", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-6.f90", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-6.f90?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -3,11 +3,19 @@\n \n ! { dg-do run }\n \n-! { dg-additional-options \"-fopt-info-note-omp\" }\n+! { dg-additional-options \"-fopt-info-omp-all\" }\n+! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n+\n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-! { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-! for testing/documenting aspects of that functionality.\n+\n+! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+! so to maintain compatibility with earlier Tcl releases, we manually\n+! initialize counter variables:\n+! { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+! \"WARNING: dg-line var l_dummy defined, but not used\".\n \n program main\n   type vec2\n@@ -21,31 +29,32 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr)\n-  !$acc loop gang(num:32)\n-  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc loop gang(num:32) ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n-     !$acc loop worker(num:8) private(pt)\n-     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n-     ! { dg-note {variable 'pt' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-2 }\n+     !$acc loop worker(num:8) private(pt) ! { dg-line l_loop_j[incr c_loop_j] }\n+     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n+     ! { dg-note {variable 'pt' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n      do j = 0, 31\n         pt%x = ieor(i, j * 3)\n         pt%y = ior(i, j * 5)\n         \n-        !$acc loop vector(length:32)\n-        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+        !$acc loop vector(length:32) ! { dg-line l_loop_k[incr c_loop_k] }\n+        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k }\n         do k = 0, 31\n            arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + pt%x * k\n         end do\n \n-        !$acc loop vector(length:32)\n-        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+        !$acc loop vector(length:32) ! { dg-line l_loop_k[incr c_loop_k] }\n+        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k }\n         do k = 0, 31\n            arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + pt%y * k\n         end do\n      end do\n   end do\n   !$acc end kernels\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 - 1\n      do j = 0, 32 -1"}, {"sha": "a90be1d45e8d7a2e4efa1d9f2101a6c1e99989b3", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-7.f90", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07395f19dff610f03d1b1d30c8bd640f610c45dc/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-7.f90?ref=07395f19dff610f03d1b1d30c8bd640f610c45dc", "patch": "@@ -3,11 +3,19 @@\n \n ! { dg-do run }\n \n-! { dg-additional-options \"-fopt-info-note-omp\" }\n+! { dg-additional-options \"-fopt-info-omp-all\" }\n+! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n+\n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-! { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n-! for testing/documenting aspects of that functionality.\n+\n+! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+! so to maintain compatibility with earlier Tcl releases, we manually\n+! initialize counter variables:\n+! { dg-line l_dummy[variable c_compute 0 c_loop_i 0 c_loop_j 0 c_loop_k 0] }\n+! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+! \"WARNING: dg-line var l_dummy defined, but not used\".\n \n program main\n   integer :: i, j, k, idx, arr(0:32*32*32), pt(2)\n@@ -16,31 +24,32 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr)\n-  !$acc loop gang(num:32)\n-  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc loop gang(num:32) ! { dg-line l_loop_i[incr c_loop_i] }\n+  ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n-     !$acc loop worker(num:8) private(pt)\n-     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n-     ! { dg-note {variable 'pt' in 'private' clause is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } .-2 }\n+     !$acc loop worker(num:8) private(pt) ! { dg-line l_loop_j[incr c_loop_j] }\n+     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j }\n+     ! { dg-note {variable 'pt' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l_loop_j$c_loop_j }\n      do j = 0, 31\n         pt(1) = ieor(i, j * 3)\n         pt(2) = ior(i, j * 5)\n         \n-        !$acc loop vector(length:32)\n-        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+        !$acc loop vector(length:32) ! { dg-line l_loop_k[incr c_loop_k] }\n+        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k }\n         do k = 0, 31\n            arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + pt(1) * k\n         end do\n \n-        !$acc loop vector(length:32)\n-        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } .-1 }\n+        !$acc loop vector(length:32) ! { dg-line l_loop_k[incr c_loop_k] }\n+        ! { dg-note {variable 'k' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_k$c_loop_k }\n         do k = 0, 31\n            arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + pt(2) * k\n         end do\n      end do\n   end do\n   !$acc end kernels\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 - 1\n      do j = 0, 32 -1"}]}