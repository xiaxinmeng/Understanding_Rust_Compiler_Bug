{"sha": "6693911f069b1ada7c04aa1d00c3653ba694958a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY5MzkxMWYwNjliMWFkYTdjMDRhYTFkMDBjMzY1M2JhNjk0OTU4YQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-01-29T12:13:13Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-01-29T12:13:13Z"}, "message": "SRA: Also propagate accesses from LHS to RHS [PR92706]\n\n2020-01-29  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/92706\n\t* tree-sra.c (struct access): Fields first_link, last_link,\n\tnext_queued and grp_queued renamed to first_rhs_link, last_rhs_link,\n\tnext_rhs_queued and grp_rhs_queued respectively, new fields\n\tfirst_lhs_link, last_lhs_link, next_lhs_queued and grp_lhs_queued.\n\t(struct assign_link): Field next renamed to next_rhs, new field\n\tnext_lhs.  Updated comment.\n\t(work_queue_head): Renamed to rhs_work_queue_head.\n\t(lhs_work_queue_head): New variable.\n\t(add_link_to_lhs): New function.\n\t(relink_to_new_repr): Also relink LHS lists.\n\t(add_access_to_work_queue): Renamed to add_access_to_rhs_work_queue.\n\t(add_access_to_lhs_work_queue): New function.\n\t(pop_access_from_work_queue): Renamed to\n\tpop_access_from_rhs_work_queue.\n\t(pop_access_from_lhs_work_queue): New function.\n\t(build_accesses_from_assign): Also add links to LHS lists and to LHS\n\twork_queue.\n\t(child_would_conflict_in_lacc): Renamed to\n\tchild_would_conflict_in_acc.  Adjusted parameter names.\n\t(create_artificial_child_access): New parameter set_grp_read, use it.\n\t(subtree_mark_written_and_enqueue): Renamed to\n\tsubtree_mark_written_and_rhs_enqueue.\n\t(propagate_subaccesses_across_link): Renamed to\n\tpropagate_subaccesses_from_rhs.\n\t(propagate_subaccesses_from_lhs): New function.\n\t(propagate_all_subaccesses): Also propagate subaccesses from LHSs to\n\tRHSs.\n\n\ttestsuite/\n\t* gcc.dg/tree-ssa/pr92706-1.c: New test.", "tree": {"sha": "4b68a2e96a8da5bc44a845347533f7ebf53655df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b68a2e96a8da5bc44a845347533f7ebf53655df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6693911f069b1ada7c04aa1d00c3653ba694958a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6693911f069b1ada7c04aa1d00c3653ba694958a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6693911f069b1ada7c04aa1d00c3653ba694958a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6693911f069b1ada7c04aa1d00c3653ba694958a/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "636e80eea24b780f1d5f4c14c58fc00001df8508", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636e80eea24b780f1d5f4c14c58fc00001df8508", "html_url": "https://github.com/Rust-GCC/gccrs/commit/636e80eea24b780f1d5f4c14c58fc00001df8508"}], "stats": {"total": 359, "additions": 284, "deletions": 75}, "files": [{"sha": "f8fe5ba21d95f1a2b4fd969aedbf3660f1550741", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6693911f069b1ada7c04aa1d00c3653ba694958a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6693911f069b1ada7c04aa1d00c3653ba694958a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6693911f069b1ada7c04aa1d00c3653ba694958a", "patch": "@@ -1,3 +1,34 @@\n+2020-01-29  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/92706\n+\t* tree-sra.c (struct access): Fields first_link, last_link,\n+\tnext_queued and grp_queued renamed to first_rhs_link, last_rhs_link,\n+\tnext_rhs_queued and grp_rhs_queued respectively, new fields\n+\tfirst_lhs_link, last_lhs_link, next_lhs_queued and grp_lhs_queued.\n+\t(struct assign_link): Field next renamed to next_rhs, new field\n+\tnext_lhs.  Updated comment.\n+\t(work_queue_head): Renamed to rhs_work_queue_head.\n+\t(lhs_work_queue_head): New variable.\n+\t(add_link_to_lhs): New function.\n+\t(relink_to_new_repr): Also relink LHS lists.\n+\t(add_access_to_work_queue): Renamed to add_access_to_rhs_work_queue.\n+\t(add_access_to_lhs_work_queue): New function.\n+\t(pop_access_from_work_queue): Renamed to\n+\tpop_access_from_rhs_work_queue.\n+\t(pop_access_from_lhs_work_queue): New function.\n+\t(build_accesses_from_assign): Also add links to LHS lists and to LHS\n+\twork_queue.\n+\t(child_would_conflict_in_lacc): Renamed to\n+\tchild_would_conflict_in_acc.  Adjusted parameter names.\n+\t(create_artificial_child_access): New parameter set_grp_read, use it.\n+\t(subtree_mark_written_and_enqueue): Renamed to\n+\tsubtree_mark_written_and_rhs_enqueue.\n+\t(propagate_subaccesses_across_link): Renamed to\n+\tpropagate_subaccesses_from_rhs.\n+\t(propagate_subaccesses_from_lhs): New function.\n+\t(propagate_all_subaccesses): Also propagate subaccesses from LHSs to\n+\tRHSs.\n+\n 2020-01-29  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/92706"}, {"sha": "33b5a6afae367905d08e7ef02e6a2edb228f49a7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6693911f069b1ada7c04aa1d00c3653ba694958a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6693911f069b1ada7c04aa1d00c3653ba694958a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6693911f069b1ada7c04aa1d00c3653ba694958a", "patch": "@@ -1,3 +1,8 @@\n+2020-01-29  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/92706\n+\t* gcc.dg/tree-ssa/pr92706-1.c: New test.\n+\n 2020-01-29  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/92706"}, {"sha": "c36d103798eb65b6de30b0b7ada1ac8d4067042d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr92706-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6693911f069b1ada7c04aa1d00c3653ba694958a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr92706-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6693911f069b1ada7c04aa1d00c3653ba694958a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr92706-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr92706-1.c?ref=6693911f069b1ada7c04aa1d00c3653ba694958a", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-esra-details\" } */\n+\n+struct S { int i[4]; } __attribute__((aligned(128)));\n+typedef __int128_t my_int128 __attribute__((may_alias));\n+__int128_t load (void *p)\n+{\n+  struct S v;\n+  __builtin_memcpy (&v, p, sizeof (struct S));\n+  struct S u;\n+  u = v;\n+  struct S w;\n+  w = u;\n+  return *(my_int128 *)&w;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Created a replacement for u offset: \\[^0\\]\" \"esra\" } } */"}, {"sha": "ea8594db19357b839e0663fb83774afaa694fe0b", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 231, "deletions": 75, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6693911f069b1ada7c04aa1d00c3653ba694958a/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6693911f069b1ada7c04aa1d00c3653ba694958a/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=6693911f069b1ada7c04aa1d00c3653ba694958a", "patch": "@@ -167,11 +167,15 @@ struct access\n   struct access *next_sibling;\n \n   /* Pointers to the first and last element in the linked list of assign\n-     links.  */\n-  struct assign_link *first_link, *last_link;\n+     links for propagation from LHS to RHS.  */\n+  struct assign_link *first_rhs_link, *last_rhs_link;\n \n-  /* Pointer to the next access in the work queue.  */\n-  struct access *next_queued;\n+  /* Pointers to the first and last element in the linked list of assign\n+     links for propagation from LHS to RHS.  */\n+  struct assign_link *first_lhs_link, *last_lhs_link;\n+\n+  /* Pointer to the next access in the work queues.  */\n+  struct access *next_rhs_queued, *next_lhs_queued;\n \n   /* Replacement variable for this access \"region.\"  Never to be accessed\n      directly, always only by the means of get_access_replacement() and only\n@@ -184,8 +188,11 @@ struct access\n   /* Is this particular access write access? */\n   unsigned write : 1;\n \n-  /* Is this access currently in the work queue?  */\n-  unsigned grp_queued : 1;\n+  /* Is this access currently in the rhs work queue?  */\n+  unsigned grp_rhs_queued : 1;\n+\n+  /* Is this access currently in the lhs work queue?  */\n+  unsigned grp_lhs_queued : 1;\n \n   /* Does this group contain a write access?  This flag is propagated down the\n      access tree.  */\n@@ -262,12 +269,14 @@ typedef struct access *access_p;\n static object_allocator<struct access> access_pool (\"SRA accesses\");\n \n /* A structure linking lhs and rhs accesses from an aggregate assignment.  They\n-   are used to propagate subaccesses from rhs to lhs as long as they don't\n-   conflict with what is already there.  */\n+   are used to propagate subaccesses from rhs to lhs and vice versa as long as\n+   they don't conflict with what is already there.  In the RHS->LHS direction,\n+   we also propagate grp_write flag to lazily mark that the access contains any\n+   meaningful data.  */\n struct assign_link\n {\n   struct access *lacc, *racc;\n-  struct assign_link *next;\n+  struct assign_link *next_rhs, *next_lhs;\n };\n \n /* Alloc pool for allocating assign link structures.  */\n@@ -327,7 +336,7 @@ static struct obstack name_obstack;\n \n /* Head of a linked list of accesses that need to have its subaccesses\n    propagated to their assignment counterparts. */\n-static struct access *work_queue_head;\n+static struct access *rhs_work_queue_head, *lhs_work_queue_head;\n \n /* Dump contents of ACCESS to file F in a human friendly way.  If GRP is true,\n    representative fields are dumped, otherwise those which only describe the\n@@ -534,79 +543,155 @@ get_var_base_offset_size_access (tree base, HOST_WIDE_INT offset,\n }\n \n /* Add LINK to the linked list of assign links of RACC.  */\n+\n static void\n add_link_to_rhs (struct access *racc, struct assign_link *link)\n {\n   gcc_assert (link->racc == racc);\n \n-  if (!racc->first_link)\n+  if (!racc->first_rhs_link)\n     {\n-      gcc_assert (!racc->last_link);\n-      racc->first_link = link;\n+      gcc_assert (!racc->last_rhs_link);\n+      racc->first_rhs_link = link;\n     }\n   else\n-    racc->last_link->next = link;\n+    racc->last_rhs_link->next_rhs = link;\n \n-  racc->last_link = link;\n-  link->next = NULL;\n+  racc->last_rhs_link = link;\n+  link->next_rhs = NULL;\n }\n \n-/* Move all link structures in their linked list in OLD_RACC to the linked list\n-   in NEW_RACC.  */\n+/* Add LINK to the linked list of lhs assign links of LACC.  */\n+\n static void\n-relink_to_new_repr (struct access *new_racc, struct access *old_racc)\n+add_link_to_lhs (struct access *lacc, struct assign_link *link)\n {\n-  if (!old_racc->first_link)\n+  gcc_assert (link->lacc == lacc);\n+\n+  if (!lacc->first_lhs_link)\n     {\n-      gcc_assert (!old_racc->last_link);\n-      return;\n+      gcc_assert (!lacc->last_lhs_link);\n+      lacc->first_lhs_link = link;\n     }\n+  else\n+    lacc->last_lhs_link->next_lhs = link;\n+\n+  lacc->last_lhs_link = link;\n+  link->next_lhs = NULL;\n+}\n \n-  if (new_racc->first_link)\n+/* Move all link structures in their linked list in OLD_ACC to the linked list\n+   in NEW_ACC.  */\n+static void\n+relink_to_new_repr (struct access *new_acc, struct access *old_acc)\n+{\n+  if (old_acc->first_rhs_link)\n     {\n-      gcc_assert (!new_racc->last_link->next);\n-      gcc_assert (!old_racc->last_link || !old_racc->last_link->next);\n \n-      new_racc->last_link->next = old_racc->first_link;\n-      new_racc->last_link = old_racc->last_link;\n+      if (new_acc->first_rhs_link)\n+\t{\n+\t  gcc_assert (!new_acc->last_rhs_link->next_rhs);\n+\t  gcc_assert (!old_acc->last_rhs_link\n+\t\t      || !old_acc->last_rhs_link->next_rhs);\n+\n+\t  new_acc->last_rhs_link->next_rhs = old_acc->first_rhs_link;\n+\t  new_acc->last_rhs_link = old_acc->last_rhs_link;\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (!new_acc->last_rhs_link);\n+\n+\t  new_acc->first_rhs_link = old_acc->first_rhs_link;\n+\t  new_acc->last_rhs_link = old_acc->last_rhs_link;\n+\t}\n+      old_acc->first_rhs_link = old_acc->last_rhs_link = NULL;\n     }\n   else\n+    gcc_assert (!old_acc->last_rhs_link);\n+\n+  if (old_acc->first_lhs_link)\n     {\n-      gcc_assert (!new_racc->last_link);\n \n-      new_racc->first_link = old_racc->first_link;\n-      new_racc->last_link = old_racc->last_link;\n+      if (new_acc->first_lhs_link)\n+\t{\n+\t  gcc_assert (!new_acc->last_lhs_link->next_lhs);\n+\t  gcc_assert (!old_acc->last_lhs_link\n+\t\t      || !old_acc->last_lhs_link->next_lhs);\n+\n+\t  new_acc->last_lhs_link->next_lhs = old_acc->first_lhs_link;\n+\t  new_acc->last_lhs_link = old_acc->last_lhs_link;\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (!new_acc->last_lhs_link);\n+\n+\t  new_acc->first_lhs_link = old_acc->first_lhs_link;\n+\t  new_acc->last_lhs_link = old_acc->last_lhs_link;\n+\t}\n+      old_acc->first_lhs_link = old_acc->last_lhs_link = NULL;\n     }\n-  old_racc->first_link = old_racc->last_link = NULL;\n+  else\n+    gcc_assert (!old_acc->last_lhs_link);\n+\n }\n \n-/* Add ACCESS to the work queue (which is actually a stack).  */\n+/* Add ACCESS to the work to queue for propagation of subaccesses from RHS to\n+   LHS (which is actually a stack).  */\n \n static void\n-add_access_to_work_queue (struct access *access)\n+add_access_to_rhs_work_queue (struct access *access)\n {\n-  if (access->first_link && !access->grp_queued)\n+  if (access->first_rhs_link && !access->grp_rhs_queued)\n     {\n-      gcc_assert (!access->next_queued);\n-      access->next_queued = work_queue_head;\n-      access->grp_queued = 1;\n-      work_queue_head = access;\n+      gcc_assert (!access->next_rhs_queued);\n+      access->next_rhs_queued = rhs_work_queue_head;\n+      access->grp_rhs_queued = 1;\n+      rhs_work_queue_head = access;\n     }\n }\n \n-/* Pop an access from the work queue, and return it, assuming there is one.  */\n+/* Add ACCESS to the work to queue for propagation of subaccesses from LHS to\n+   RHS (which is actually a stack).  */\n+\n+static void\n+add_access_to_lhs_work_queue (struct access *access)\n+{\n+  if (access->first_lhs_link && !access->grp_lhs_queued)\n+    {\n+      gcc_assert (!access->next_lhs_queued);\n+      access->next_lhs_queued = lhs_work_queue_head;\n+      access->grp_lhs_queued = 1;\n+      lhs_work_queue_head = access;\n+    }\n+}\n+\n+/* Pop an access from the work queue for propagating from RHS to LHS, and\n+   return it, assuming there is one.  */\n \n static struct access *\n-pop_access_from_work_queue (void)\n+pop_access_from_rhs_work_queue (void)\n {\n-  struct access *access = work_queue_head;\n+  struct access *access = rhs_work_queue_head;\n \n-  work_queue_head = access->next_queued;\n-  access->next_queued = NULL;\n-  access->grp_queued = 0;\n+  rhs_work_queue_head = access->next_rhs_queued;\n+  access->next_rhs_queued = NULL;\n+  access->grp_rhs_queued = 0;\n   return access;\n }\n \n+/* Pop an access from the work queue for propagating from LHS to RHS, and\n+   return it, assuming there is one.  */\n+\n+static struct access *\n+pop_access_from_lhs_work_queue (void)\n+{\n+  struct access *access = lhs_work_queue_head;\n+\n+  lhs_work_queue_head = access->next_lhs_queued;\n+  access->next_lhs_queued = NULL;\n+  access->grp_lhs_queued = 0;\n+  return access;\n+}\n \n /* Allocate necessary structures.  */\n \n@@ -1203,7 +1288,9 @@ build_accesses_from_assign (gimple *stmt)\n       link->lacc = lacc;\n       link->racc = racc;\n       add_link_to_rhs (racc, link);\n-      add_access_to_work_queue (racc);\n+      add_link_to_lhs (lacc, link);\n+      add_access_to_rhs_work_queue (racc);\n+      add_access_to_lhs_work_queue (lacc);\n \n       /* Let's delay marking the areas as written until propagation of accesses\n \t across link, unless the nature of rhs tells us that its data comes\n@@ -2492,17 +2579,17 @@ analyze_access_trees (struct access *access)\n   return ret;\n }\n \n-/* Return true iff a potential new child of LACC at offset OFFSET and with size\n+/* Return true iff a potential new child of ACC at offset OFFSET and with size\n    SIZE would conflict with an already existing one.  If exactly such a child\n-   already exists in LACC, store a pointer to it in EXACT_MATCH.  */\n+   already exists in ACC, store a pointer to it in EXACT_MATCH.  */\n \n static bool\n-child_would_conflict_in_lacc (struct access *lacc, HOST_WIDE_INT norm_offset,\n+child_would_conflict_in_acc (struct access *acc, HOST_WIDE_INT norm_offset,\n \t\t\t      HOST_WIDE_INT size, struct access **exact_match)\n {\n   struct access *child;\n \n-  for (child = lacc->first_child; child; child = child->next_sibling)\n+  for (child = acc->first_child; child; child = child->next_sibling)\n     {\n       if (child->offset == norm_offset && child->size == size)\n \t{\n@@ -2528,7 +2615,7 @@ child_would_conflict_in_lacc (struct access *lacc, HOST_WIDE_INT norm_offset,\n static struct access *\n create_artificial_child_access (struct access *parent, struct access *model,\n \t\t\t\tHOST_WIDE_INT new_offset,\n-\t\t\t\tbool set_grp_write)\n+\t\t\t\tbool set_grp_read, bool set_grp_write)\n {\n   struct access **child;\n   tree expr = parent->base;\n@@ -2551,8 +2638,8 @@ create_artificial_child_access (struct access *parent, struct access *model,\n   access->size = model->size;\n   access->type = model->type;\n   access->parent = parent;\n+  access->grp_read = set_grp_read;\n   access->grp_write = set_grp_write;\n-  access->grp_read = false;\n   access->reverse = model->reverse;\n \n   child = &parent->first_child;\n@@ -2571,16 +2658,16 @@ create_artificial_child_access (struct access *parent, struct access *model,\n    and has assignment links leading from it, re-enqueue it.  */\n \n static void\n-subtree_mark_written_and_enqueue (struct access *access)\n+subtree_mark_written_and_rhs_enqueue (struct access *access)\n {\n   if (access->grp_write)\n     return;\n   access->grp_write = true;\n-  add_access_to_work_queue (access);\n+  add_access_to_rhs_work_queue (access);\n \n   struct access *child;\n   for (child = access->first_child; child; child = child->next_sibling)\n-    subtree_mark_written_and_enqueue (child);\n+    subtree_mark_written_and_rhs_enqueue (child);\n }\n \n /* Propagate subaccesses and grp_write flags of RACC across an assignment link\n@@ -2590,7 +2677,7 @@ subtree_mark_written_and_enqueue (struct access *access)\n    possible.  */\n \n static bool\n-propagate_subaccesses_across_link (struct access *lacc, struct access *racc)\n+propagate_subaccesses_from_rhs (struct access *lacc, struct access *racc)\n {\n   struct access *rchild;\n   HOST_WIDE_INT norm_delta = lacc->offset - racc->offset;\n@@ -2603,7 +2690,7 @@ propagate_subaccesses_across_link (struct access *lacc, struct access *racc)\n       gcc_checking_assert (!comes_initialized_p (racc->base));\n       if (racc->grp_write)\n \t{\n-\t  subtree_mark_written_and_enqueue (lacc);\n+\t  subtree_mark_written_and_rhs_enqueue (lacc);\n \t  ret = true;\n \t}\n     }\n@@ -2615,7 +2702,7 @@ propagate_subaccesses_across_link (struct access *lacc, struct access *racc)\n       if (!lacc->grp_write)\n \t{\n \t  ret = true;\n-\t  subtree_mark_written_and_enqueue (lacc);\n+\t  subtree_mark_written_and_rhs_enqueue (lacc);\n \t}\n       return ret;\n     }\n@@ -2625,7 +2712,7 @@ propagate_subaccesses_across_link (struct access *lacc, struct access *racc)\n       if (!lacc->grp_write)\n \t{\n \t  ret = true;\n-\t  subtree_mark_written_and_enqueue (lacc);\n+\t  subtree_mark_written_and_rhs_enqueue (lacc);\n \t}\n       if (!lacc->first_child && !racc->first_child)\n \t{\n@@ -2655,33 +2742,33 @@ propagate_subaccesses_across_link (struct access *lacc, struct access *racc)\n       struct access *new_acc = NULL;\n       HOST_WIDE_INT norm_offset = rchild->offset + norm_delta;\n \n-      if (child_would_conflict_in_lacc (lacc, norm_offset, rchild->size,\n+      if (child_would_conflict_in_acc (lacc, norm_offset, rchild->size,\n \t\t\t\t\t&new_acc))\n \t{\n \t  if (new_acc)\n \t    {\n \t      if (!new_acc->grp_write && rchild->grp_write)\n \t\t{\n \t\t  gcc_assert (!lacc->grp_write);\n-\t\t  subtree_mark_written_and_enqueue (new_acc);\n+\t\t  subtree_mark_written_and_rhs_enqueue (new_acc);\n \t\t  ret = true;\n \t\t}\n \n \t      rchild->grp_hint = 1;\n \t      new_acc->grp_hint |= new_acc->grp_read;\n \t      if (rchild->first_child\n-\t\t  && propagate_subaccesses_across_link (new_acc, rchild))\n+\t\t  && propagate_subaccesses_from_rhs (new_acc, rchild))\n \t\t{\n \t\t  ret = 1;\n-\t\t  add_access_to_work_queue (new_acc);\n+\t\t  add_access_to_rhs_work_queue (new_acc);\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      if (!lacc->grp_write)\n \t\t{\n \t\t  ret = true;\n-\t\t  subtree_mark_written_and_enqueue (lacc);\n+\t\t  subtree_mark_written_and_rhs_enqueue (lacc);\n \t\t}\n \t    }\n \t  continue;\n@@ -2692,41 +2779,85 @@ propagate_subaccesses_across_link (struct access *lacc, struct access *racc)\n \t  if (rchild->grp_write && !lacc->grp_write)\n \t    {\n \t      ret = true;\n-\t      subtree_mark_written_and_enqueue (lacc);\n+\t      subtree_mark_written_and_rhs_enqueue (lacc);\n \t    }\n \t  continue;\n \t}\n \n       rchild->grp_hint = 1;\n       new_acc = create_artificial_child_access (lacc, rchild, norm_offset,\n-\t\t\t\t\t\tlacc->grp_write\n-\t\t\t\t\t\t|| rchild->grp_write);\n+\t\t\t\t\t\tfalse, (lacc->grp_write\n+\t\t\t\t\t\t\t|| rchild->grp_write));\n       gcc_checking_assert (new_acc);\n       if (racc->first_child)\n-\tpropagate_subaccesses_across_link (new_acc, rchild);\n+\tpropagate_subaccesses_from_rhs (new_acc, rchild);\n \n-      add_access_to_work_queue (lacc);\n+      add_access_to_rhs_work_queue (lacc);\n       ret = true;\n     }\n \n   return ret;\n }\n \n+/* Propagate subaccesses of LACC across an assignment link to RACC if they\n+   should inhibit total scalarization of the corresponding area.  No flags are\n+   being propagated in the process.  Return true if anything changed.  */\n+\n+static bool\n+propagate_subaccesses_from_lhs (struct access *lacc, struct access *racc)\n+{\n+  if (is_gimple_reg_type (racc->type)\n+      || lacc->grp_unscalarizable_region\n+      || racc->grp_unscalarizable_region)\n+    return false;\n+\n+  /* TODO: Do we want set some new racc flag to stop potential total\n+     scalarization if lacc is a scalar access (and none fo the two have\n+     children)?  */\n+\n+  bool ret = false;\n+  HOST_WIDE_INT norm_delta = racc->offset - lacc->offset;\n+  for (struct access *lchild = lacc->first_child;\n+       lchild;\n+       lchild = lchild->next_sibling)\n+    {\n+      struct access *matching_acc = NULL;\n+      HOST_WIDE_INT norm_offset = lchild->offset + norm_delta;\n+\n+      if (lchild->grp_unscalarizable_region\n+\t  || child_would_conflict_in_acc (racc, norm_offset, lchild->size,\n+\t\t\t\t\t  &matching_acc))\n+\t{\n+\t  if (matching_acc\n+\t      && propagate_subaccesses_from_lhs (lchild, matching_acc))\n+\t    add_access_to_lhs_work_queue (matching_acc);\n+\t  continue;\n+\t}\n+\n+      struct access *new_acc\n+\t=  create_artificial_child_access (racc, lchild, norm_offset,\n+\t\t\t\t\t   true, false);\n+      propagate_subaccesses_from_lhs (lchild, new_acc);\n+      ret = true;\n+    }\n+  return ret;\n+}\n+\n /* Propagate all subaccesses across assignment links.  */\n \n static void\n propagate_all_subaccesses (void)\n {\n-  while (work_queue_head)\n+  while (rhs_work_queue_head)\n     {\n-      struct access *racc = pop_access_from_work_queue ();\n+      struct access *racc = pop_access_from_rhs_work_queue ();\n       struct assign_link *link;\n \n       if (racc->group_representative)\n \tracc= racc->group_representative;\n-      gcc_assert (racc->first_link);\n+      gcc_assert (racc->first_rhs_link);\n \n-      for (link = racc->first_link; link; link = link->next)\n+      for (link = racc->first_rhs_link; link; link = link->next_rhs)\n \t{\n \t  struct access *lacc = link->lacc;\n \n@@ -2739,22 +2870,47 @@ propagate_all_subaccesses (void)\n \t    {\n \t      if (!lacc->grp_write)\n \t\t{\n-\t\t  subtree_mark_written_and_enqueue (lacc);\n+\t\t  subtree_mark_written_and_rhs_enqueue (lacc);\n \t\t  reque_parents = true;\n \t\t}\n \t    }\n-\t  else if (propagate_subaccesses_across_link (lacc, racc))\n+\t  else if (propagate_subaccesses_from_rhs (lacc, racc))\n \t    reque_parents = true;\n \n \t  if (reque_parents)\n \t    do\n \t      {\n-\t\tadd_access_to_work_queue (lacc);\n+\t\tadd_access_to_rhs_work_queue (lacc);\n \t\tlacc = lacc->parent;\n \t      }\n \t    while (lacc);\n \t}\n     }\n+\n+  while (lhs_work_queue_head)\n+    {\n+      struct access *lacc = pop_access_from_lhs_work_queue ();\n+      struct assign_link *link;\n+\n+      if (lacc->group_representative)\n+\tlacc = lacc->group_representative;\n+      gcc_assert (lacc->first_lhs_link);\n+\n+      if (!bitmap_bit_p (candidate_bitmap, DECL_UID (lacc->base)))\n+\tcontinue;\n+\n+      for (link = lacc->first_lhs_link; link; link = link->next_lhs)\n+\t{\n+\t  struct access *racc = link->racc;\n+\n+\t  if (racc->group_representative)\n+\t    racc = racc->group_representative;\n+\t  if (!bitmap_bit_p (candidate_bitmap, DECL_UID (racc->base)))\n+\t    continue;\n+\t  if (propagate_subaccesses_from_lhs (lacc, racc))\n+\t    add_access_to_lhs_work_queue (racc);\n+\t}\n+    }\n }\n \n /* Return true if the forest beginning with ROOT does not contain"}]}