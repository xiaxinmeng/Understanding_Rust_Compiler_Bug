{"sha": "787dc84216bdf0def91f8e2fa3bbb15415959af3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg3ZGM4NDIxNmJkZjBkZWY5MWY4ZTJmYTNiYmIxNTQxNTk1OWFmMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-02-28T16:24:00Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-02-28T16:24:00Z"}, "message": "caller-save.c (reg_save_code, [...]): Index by mode, not NREGS.\n\n\t* caller-save.c (reg_save_code, reg_restore_code):  Index by mode, not\n\tNREGS.\n\t(insert_save, insert_restore): New parameter save_mode.\n\t(init_caller_save): Update initialization of reg_save_code\n\tand reg_restore_code.\n\t(save_call_clobbered_regs):  Compute save_modes and update calls to\n\treg_save_code and reg_restore_code.\n\t(insert_restore):  Unsignetize numbers; use save_modes to choose mode\n\tof spill; update use of reg_restore_code.\n\t(insert_save):  Likewise.\n\t* i386.h (HARD_REGNO_CALLER_SAVE_MODE): Update.\n\t* c4x.h (HARD_REGNO_CALLER_SAVE_MODE): Update.\n\t* regs.h (HARD_REGNO_CALLER_SAVE_MODE): Likewise.\n\nFrom-SVN: r40120", "tree": {"sha": "31cd8790a0faef2e8fb8e0fb385ee169d62d5f59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31cd8790a0faef2e8fb8e0fb385ee169d62d5f59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/787dc84216bdf0def91f8e2fa3bbb15415959af3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/787dc84216bdf0def91f8e2fa3bbb15415959af3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/787dc84216bdf0def91f8e2fa3bbb15415959af3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/787dc84216bdf0def91f8e2fa3bbb15415959af3/comments", "author": null, "committer": null, "parents": [{"sha": "dc2698bc26065d3300ca0353f92c00f4f0a1496b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc2698bc26065d3300ca0353f92c00f4f0a1496b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc2698bc26065d3300ca0353f92c00f4f0a1496b"}], "stats": {"total": 166, "additions": 123, "deletions": 43}, "files": [{"sha": "b4ac8bc315b6a82d4300ca3156cc89bb07d4abc8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787dc84216bdf0def91f8e2fa3bbb15415959af3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787dc84216bdf0def91f8e2fa3bbb15415959af3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=787dc84216bdf0def91f8e2fa3bbb15415959af3", "patch": "@@ -1,4 +1,20 @@\n-Wed Feb 28 17:19:28 CET 2001  Jan Hubicka  <jh@suse.cz.\n+Wed Feb 28 17:22:35 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* caller-save.c (reg_save_code, reg_restore_code):  Index by mode, not\n+\tNREGS.\n+\t(insert_save, insert_restore): New parameter save_mode.\n+\t(init_caller_save): Update initialization of reg_save_code\n+\tand reg_restore_code.\n+\t(save_call_clobbered_regs):  Compute save_modes and update calls to\n+\treg_save_code and reg_restore_code.\n+\t(insert_restore):  Unsignetize numbers; use save_modes to choose mode\n+\tof spill; update use of reg_restore_code.\n+\t(insert_save):  Likewise.\n+\t* i386.h (HARD_REGNO_CALLER_SAVE_MODE): Update.\n+\t* c4x.h (HARD_REGNO_CALLER_SAVE_MODE): Update.\n+\t* regs.h (HARD_REGNO_CALLER_SAVE_MODE): Likewise.\n+\n+Wed Feb 28 17:19:28 CET 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* ifcvt.c (noce_emit_store_flag, noce_try_store_flag_constants,\n \tnoce_try_store_flag_inc, noce_try_store_flag_mask,"}, {"sha": "445de2cf532d33132a928847f6822d7fd5310f4f", "filename": "gcc/caller-save.c", "status": "modified", "additions": 96, "deletions": 37, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787dc84216bdf0def91f8e2fa3bbb15415959af3/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787dc84216bdf0def91f8e2fa3bbb15415959af3/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=787dc84216bdf0def91f8e2fa3bbb15415959af3", "patch": "@@ -65,9 +65,9 @@ static rtx\n    be recognized.  */\n \n static enum insn_code \n-  reg_save_code[FIRST_PSEUDO_REGISTER][MAX_MOVE_MAX / MIN_UNITS_PER_WORD + 1];\n+  reg_save_code[FIRST_PSEUDO_REGISTER][MAX_MACHINE_MODE];\n static enum insn_code \n-  reg_restore_code[FIRST_PSEUDO_REGISTER][MAX_MOVE_MAX / MIN_UNITS_PER_WORD + 1];\n+  reg_restore_code[FIRST_PSEUDO_REGISTER][MAX_MACHINE_MODE];\n \n /* Set of hard regs currently residing in save area (during insn scan).  */\n \n@@ -89,9 +89,10 @@ static HARD_REG_SET this_insn_sets;\n static void mark_set_regs\t\tPARAMS ((rtx, rtx, void *));\n static void mark_referenced_regs\tPARAMS ((rtx));\n static int insert_save\t\t\tPARAMS ((struct insn_chain *, int, int,\n-\t\t\t\t\t\t HARD_REG_SET *));\n+\t\t\t\t\t\t HARD_REG_SET *,\n+\t\t\t\t\t\t enum machine_mode *));\n static int insert_restore\t\tPARAMS ((struct insn_chain *, int, int,\n-\t\t\t\t\t\t int));\n+\t\t\t\t\t\t int, enum machine_mode *));\n static struct insn_chain *insert_one_insn PARAMS ((struct insn_chain *, int,\n \t\t\t\t\t\t   enum insn_code, rtx));\n static void add_stored_regs\t\tPARAMS ((rtx, rtx, void *));\n@@ -113,6 +114,7 @@ init_caller_save ()\n   int offset;\n   rtx address;\n   int i, j;\n+  enum machine_mode mode;\n \n   /* First find all the registers that we need to deal with and all\n      the modes that they can have.  If we can't find a mode to use,\n@@ -124,7 +126,8 @@ init_caller_save ()\n \t{\n \t  for (j = 1; j <= MOVE_MAX_WORDS; j++)\n \t    {\n-\t      regno_save_mode[i][j] = HARD_REGNO_CALLER_SAVE_MODE (i, j);\n+\t      regno_save_mode[i][j] = HARD_REGNO_CALLER_SAVE_MODE (i, j,\n+\t\t\t\t\t\t\t\t   VOIDmode);\n \t      if (regno_save_mode[i][j] == VOIDmode && j == 1)\n \t\t{\n \t\t  call_fixed_regs[i] = 1;\n@@ -179,24 +182,24 @@ init_caller_save ()\n   start_sequence ();\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    for (j = 1; j <= MOVE_MAX_WORDS; j++)\n-      if (regno_save_mode[i][j] != VOIDmode)\n+    for (mode = 0 ; mode < MAX_MACHINE_MODE; mode++)\n+      if (HARD_REGNO_MODE_OK (i, mode))\n         {\n-\t  rtx mem = gen_rtx_MEM (regno_save_mode[i][j], address);\n-\t  rtx reg = gen_rtx_REG (regno_save_mode[i][j], i);\n+\t  rtx mem = gen_rtx_MEM (mode, address);\n+\t  rtx reg = gen_rtx_REG (mode, i);\n \t  rtx savepat = gen_rtx_SET (VOIDmode, mem, reg);\n \t  rtx restpat = gen_rtx_SET (VOIDmode, reg, mem);\n \t  rtx saveinsn = emit_insn (savepat);\n \t  rtx restinsn = emit_insn (restpat);\n \t  int ok;\n \n-\t  reg_save_code[i][j] = recog_memoized (saveinsn);\n-\t  reg_restore_code[i][j] = recog_memoized (restinsn);\n+\t  reg_save_code[i][mode] = recog_memoized (saveinsn);\n+\t  reg_restore_code[i][mode] = recog_memoized (restinsn);\n \n \t  /* Now extract both insns and see if we can meet their\n              constraints.  */\n-\t  ok = (reg_save_code[i][j] != (enum insn_code)-1\n-\t\t&& reg_restore_code[i][j] != (enum insn_code)-1);\n+\t  ok = (reg_save_code[i][mode] != (enum insn_code)-1\n+\t\t&& reg_restore_code[i][mode] != (enum insn_code)-1);\n \t  if (ok)\n \t    {\n \t      extract_insn (saveinsn);\n@@ -207,14 +210,26 @@ init_caller_save ()\n \n \t  if (! ok)\n \t    {\n-\t      regno_save_mode[i][j] = VOIDmode;\n-\t      if (j == 1)\n-\t\t{\n-\t\t  call_fixed_regs[i] = 1;\n-\t\t  SET_HARD_REG_BIT (call_fixed_reg_set, i);\n-\t\t}\n+\t      reg_save_code[i][mode] = (enum insn_code) -1;\n+\t      reg_restore_code[i][mode] = (enum insn_code) -1;\n \t    }\n-      }\n+        }\n+      else\n+\t{\n+\t  reg_save_code[i][mode] = (enum insn_code) -1;\n+\t  reg_restore_code[i][mode] = (enum insn_code) -1;\n+\t}\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    for (j = 1; j <= MOVE_MAX_WORDS; j++)\n+      if (reg_save_code [i][regno_save_mode[i][j]] == (enum insn_code) -1)\n+\t{\n+\t  regno_save_mode[i][j] = VOIDmode;\n+\t  if (j == 1)\n+\t    {\n+\t      call_fixed_regs[i] = 1;\n+\t      SET_HARD_REG_BIT (call_fixed_reg_set, i);\n+\t    }\n+\t}\n \n   end_sequence ();\n }\n@@ -339,6 +354,7 @@ void\n save_call_clobbered_regs ()\n {\n   struct insn_chain *chain, *next;\n+  enum machine_mode save_mode [FIRST_PSEUDO_REGISTER];\n \n   CLEAR_HARD_REG_SET (hard_regs_saved);\n   n_regs_saved = 0;\n@@ -374,7 +390,7 @@ save_call_clobbered_regs ()\n \n \t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t\tif (TEST_HARD_REG_BIT (referenced_regs, regno))\n-\t\t  regno += insert_restore (chain, 1, regno, MOVE_MAX_WORDS);\n+\t\t  regno += insert_restore (chain, 1, regno, MOVE_MAX_WORDS, save_mode);\n \t    }\n \n \t  if (code == CALL_INSN)\n@@ -386,8 +402,37 @@ save_call_clobbered_regs ()\n \t\t regs are live during the call.  */\n \t      REG_SET_TO_HARD_REG_SET (hard_regs_to_save,\n \t\t\t\t       &chain->live_throughout);\n-\t      compute_use_by_pseudos (&hard_regs_to_save,\n-\t\t\t\t      &chain->live_throughout);\n+\t      /* Save hard registers always in the widest mode availble.  */\n+\t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t\tif (TEST_HARD_REG_BIT (hard_regs_to_save, regno))\n+\t\t  save_mode [regno] = regno_save_mode [regno][1];\n+\t\telse\n+\t\t  save_mode [regno] = VOIDmode;\n+\n+\t      /* Look trought all live pseudos, mark their hard registers\n+\t\t and choose proper mode for saving.  */\n+\t      EXECUTE_IF_SET_IN_REG_SET\n+\t\t(&chain->live_throughout, FIRST_PSEUDO_REGISTER, regno,\n+\t\t {\n+\t\t   int r = reg_renumber[regno];\n+\t\t   int nregs;\n+\n+\t\t   if (r > 0)\n+\t\t     {\n+\t\t       enum machine_mode mode;\n+\n+\t\t       nregs = HARD_REGNO_NREGS (r, PSEUDO_REGNO_MODE (regno));\n+\t\t       mode = HARD_REGNO_CALLER_SAVE_MODE\n+\t\t\t        (r, nregs, PSEUDO_REGNO_MODE (regno));\n+\t\t       if (GET_MODE_BITSIZE (mode)\n+\t\t\t   > GET_MODE_BITSIZE (save_mode[r]))\n+\t\t\t save_mode[r] = mode;\n+\t\t       while (nregs-- > 0)\n+\t\t\t SET_HARD_REG_BIT (hard_regs_to_save, r + nregs);\n+\t\t     }\n+\t\t   else\n+\t\t     abort ();\n+\t\t });\n \n \t      /* Record all registers set in this call insn.  These don't need\n \t\t to be saved.  N.B. the call insn might set a subreg of a\n@@ -404,7 +449,7 @@ save_call_clobbered_regs ()\n \n \t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t\tif (TEST_HARD_REG_BIT (hard_regs_to_save, regno))\n-\t\t  regno += insert_save (chain, 1, regno, &hard_regs_to_save);\n+\t\t  regno += insert_save (chain, 1, regno, &hard_regs_to_save, save_mode);\n \n \t      /* Must recompute n_regs_saved.  */\n \t      n_regs_saved = 0;\n@@ -425,7 +470,7 @@ save_call_clobbered_regs ()\n \t    for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t      if (TEST_HARD_REG_BIT (hard_regs_saved, regno))\n \t\tregno += insert_restore (chain, GET_CODE (insn) == JUMP_INSN,\n-\t\t\t\t\t regno, MOVE_MAX_WORDS);\n+\t\t\t\t\t regno, MOVE_MAX_WORDS, save_mode);\n \t}\n     }  \n }\n@@ -572,17 +617,19 @@ mark_referenced_regs (x)\n    Return the extra number of registers saved.  */\n \n static int\n-insert_restore (chain, before_p, regno, maxrestore)\n+insert_restore (chain, before_p, regno, maxrestore, save_mode)\n      struct insn_chain *chain;\n      int before_p;\n      int regno;\n      int maxrestore;\n+     enum machine_mode *save_mode;\n {\n   int i, k;\n   rtx pat = NULL_RTX;\n   enum insn_code code = CODE_FOR_nothing;\n-  int numregs = 0;\n+  unsigned int numregs = 0;\n   struct insn_chain *new;\n+  rtx mem;\n \n   /* A common failure mode if register status is not correct in the RTL\n      is for this routine to be called with a REGNO we didn't expect to\n@@ -620,11 +667,15 @@ insert_restore (chain, before_p, regno, maxrestore)\n       break;\n     }\n \n+  mem = regno_save_mem [regno][numregs];\n+  if (save_mode [regno] != VOIDmode\n+      && save_mode [regno] != GET_MODE (mem)\n+      && numregs == HARD_REGNO_NREGS (regno, save_mode [regno]))\n+    mem = change_address (mem, save_mode[regno], XEXP (mem, 0));\n   pat = gen_rtx_SET (VOIDmode,\n-\t\t     gen_rtx_REG (GET_MODE (regno_save_mem[regno][numregs]), \n-\t\t\t\t  regno), \n-\t\t     regno_save_mem[regno][numregs]);\n-  code = reg_restore_code[regno][numregs];\n+\t\t     gen_rtx_REG (GET_MODE (mem), \n+\t\t\t\t  regno), mem);\n+  code = reg_restore_code[regno][GET_MODE (mem)];\n   new = insert_one_insn (chain, before_p, code, pat);\n \n   /* Clear status for all registers we restored.  */\n@@ -643,17 +694,20 @@ insert_restore (chain, before_p, regno, maxrestore)\n \n /* Like insert_restore above, but save registers instead.  */\n static int\n-insert_save (chain, before_p, regno, to_save)\n+insert_save (chain, before_p, regno, to_save, save_mode)\n      struct insn_chain *chain;\n      int before_p;\n      int regno;\n      HARD_REG_SET *to_save;\n+     enum machine_mode *save_mode;\n {\n-  int i, k;\n+  int i;\n+  unsigned int k;\n   rtx pat = NULL_RTX;\n   enum insn_code code = CODE_FOR_nothing;\n-  int numregs = 0;\n+  unsigned int numregs = 0;\n   struct insn_chain *new;\n+  rtx mem;\n \n   /* A common failure mode if register status is not correct in the RTL\n      is for this routine to be called with a REGNO we didn't expect to\n@@ -690,10 +744,15 @@ insert_save (chain, before_p, regno, to_save)\n       break;\n     }\n \n-  pat = gen_rtx_SET (VOIDmode, regno_save_mem[regno][numregs],\n-\t\t     gen_rtx_REG (GET_MODE (regno_save_mem[regno][numregs]),\n+  mem = regno_save_mem [regno][numregs];\n+  if (save_mode [regno] != VOIDmode\n+      && save_mode [regno] != GET_MODE (mem)\n+      && numregs == HARD_REGNO_NREGS (regno, save_mode [regno]))\n+    mem = change_address (mem, save_mode[regno], XEXP (mem, 0));\n+  pat = gen_rtx_SET (VOIDmode, mem,\n+\t\t     gen_rtx_REG (GET_MODE (mem),\n \t\t\t\t  regno));\n-  code = reg_save_code[regno][numregs];\n+  code = reg_save_code[regno][GET_MODE (mem)];\n   new = insert_one_insn (chain, before_p, code, pat);\n \n   /* Set hard_regs_saved and dead_or_set for all the registers we saved.  */"}, {"sha": "4250bf55702040abdc7c4bbd7f6069cfbc4ef44a", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787dc84216bdf0def91f8e2fa3bbb15415959af3/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787dc84216bdf0def91f8e2fa3bbb15415959af3/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=787dc84216bdf0def91f8e2fa3bbb15415959af3", "patch": "@@ -648,7 +648,7 @@ extern const char *c4x_rpts_cycles_string, *c4x_cpu_version_string;\n \n /* Specify the modes required to caller save a given hard regno.  */\n \n-#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS) (c4x_caller_save_map[REGNO])\n+#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE) (c4x_caller_save_map[REGNO])\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE) c4x_hard_regno_mode_ok(REGNO, MODE)\n "}, {"sha": "1ba6118bdeba8c76b27a8c28ee44c1274dbed2d7", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787dc84216bdf0def91f8e2fa3bbb15415959af3/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787dc84216bdf0def91f8e2fa3bbb15415959af3/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=787dc84216bdf0def91f8e2fa3bbb15415959af3", "patch": "@@ -819,11 +819,16 @@ extern int ix86_arch;\n    || ((MODE1) == HImode && (MODE2) == SImode))\n \n /* Specify the modes required to caller save a given hard regno.\n-   We do this on i386 to prevent flags from being saved at all.  */\n+   We do this on i386 to prevent flags from being saved at all.\n \n-#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS)\t\t\\\n+   Kill any attempts to combine saving of modes.  */\n+\n+#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE)\t\t\\\n   (CC_REGNO_P (REGNO) ? VOIDmode\t\t\t\t\\\n-   : choose_hard_reg_mode ((REGNO), (NREGS)))\n+   : (MODE) == VOIDmode && (NREGS) != 1 ? VOIDmode\t\t\\\n+   : (MODE) == VOIDmode ? choose_hard_reg_mode ((REGNO), (NREGS)) \\\n+   : (MODE) == HImode && !TARGET_PARTIAL_REG_STALL ? SImode\t\\\n+   : (MODE) == QImode && (REGNO) >= 4 ? SImode : (MODE))\n \n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */"}, {"sha": "0822966602155ab9c4b124e44b043913e8589000", "filename": "gcc/regs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787dc84216bdf0def91f8e2fa3bbb15415959af3/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787dc84216bdf0def91f8e2fa3bbb15415959af3/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=787dc84216bdf0def91f8e2fa3bbb15415959af3", "patch": "@@ -192,7 +192,7 @@ extern int caller_save_needed;\n \n /* Select a register mode required for caller save of hard regno REGNO.  */\n #ifndef HARD_REGNO_CALLER_SAVE_MODE\n-#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS) \\\n+#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE) \\\n   choose_hard_reg_mode (REGNO, NREGS)\n #endif\n "}]}