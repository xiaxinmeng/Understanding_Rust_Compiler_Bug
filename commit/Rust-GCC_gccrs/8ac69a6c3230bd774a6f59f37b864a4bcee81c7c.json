{"sha": "8ac69a6c3230bd774a6f59f37b864a4bcee81c7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFjNjlhNmMzMjMwYmQ3NzRhNmY1OWYzN2I4NjRhNGJjZWU4MWM3Yw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2013-08-05T20:25:06Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2013-08-05T20:25:06Z"}, "message": "Rewrite how instances of passes are cloned\n\ngcc/\n\n\tRewrite how instances of passes are cloned to remove assumptions\n\tabout their sizes (thus allowing pass subclasses to have\n\tadditional data fields, albeit non-GC-managed ones at this point).\n\n\t* passes.c (make_pass_instance): Now that passes have clone\n\tmethods, rewrite this function to eliminate XNEW and memcpy\n\tcalls that used hardcoded sizes.  Since this function no longer\n\tcreates pass instances, rename it to...\n\t(add_pass_instance): ...this.  Document the old way that passes\n\twere numbered and flagged, and rework this function to continue\n\tusing it.\n\t(next_pass_1): Add an initial_pass argument for use by\n\tadd_pass_instance.\n\t(position_pass): When adding multiple instances of a pass, use\n\tthe pass's clone method, rather than relying on the XNEW/memcpy\n\twithin the former make_pass_instance (now add_pass_instance).\n\t(pass_manager::pass_manager): When invoking next_pass_1, also\n\tsupply the initial instance of the current pass within the\n\tpass manager.\n\nFrom-SVN: r201511", "tree": {"sha": "9d7205fbfbfe412c67cbe7d39301e7de74e9581b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d7205fbfbfe412c67cbe7d39301e7de74e9581b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ac69a6c3230bd774a6f59f37b864a4bcee81c7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ac69a6c3230bd774a6f59f37b864a4bcee81c7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ac69a6c3230bd774a6f59f37b864a4bcee81c7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ac69a6c3230bd774a6f59f37b864a4bcee81c7c/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "158922986553c3fe81df33b636bb8c8f1a38366e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/158922986553c3fe81df33b636bb8c8f1a38366e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/158922986553c3fe81df33b636bb8c8f1a38366e"}], "stats": {"total": 114, "additions": 77, "deletions": 37}, "files": [{"sha": "26a000f715684bbcdc5182fc96fd3926353a6fc5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac69a6c3230bd774a6f59f37b864a4bcee81c7c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac69a6c3230bd774a6f59f37b864a4bcee81c7c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ac69a6c3230bd774a6f59f37b864a4bcee81c7c", "patch": "@@ -1,3 +1,25 @@\n+2013-08-05  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tRewrite how instances of passes are cloned to remove assumptions\n+\tabout their sizes (thus allowing pass subclasses to have\n+\tadditional data fields, albeit non-GC-managed ones at this point).\n+\n+\t* passes.c (make_pass_instance): Now that passes have clone\n+\tmethods, rewrite this function to eliminate XNEW and memcpy\n+\tcalls that used hardcoded sizes.  Since this function no longer\n+\tcreates pass instances, rename it to...\n+\t(add_pass_instance): ...this.  Document the old way that passes\n+\twere numbered and flagged, and rework this function to continue\n+\tusing it.\n+\t(next_pass_1): Add an initial_pass argument for use by\n+\tadd_pass_instance.\n+\t(position_pass): When adding multiple instances of a pass, use\n+\tthe pass's clone method, rather than relying on the XNEW/memcpy\n+\twithin the former make_pass_instance (now add_pass_instance).\n+\t(pass_manager::pass_manager): When invoking next_pass_1, also\n+\tsupply the initial instance of the current pass within the\n+\tpass manager.\n+\n 2013-08-05  David Malcolm  <dmalcolm@redhat.com>\n \n \tThis is the automated part of the conversion of passes from C"}, {"sha": "aa273fbe6737d55767c81b700e420c51ac1153c8", "filename": "gcc/passes.c", "status": "modified", "additions": 55, "deletions": 37, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ac69a6c3230bd774a6f59f37b864a4bcee81c7c/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ac69a6c3230bd774a6f59f37b864a4bcee81c7c/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=8ac69a6c3230bd774a6f59f37b864a4bcee81c7c", "patch": "@@ -1167,68 +1167,77 @@ is_pass_explicitly_enabled_or_disabled (struct opt_pass *pass,\n   return false;\n }\n \n-/* Look at the static_pass_number and duplicate the pass\n-   if it is already added to a list. */\n \n-static struct opt_pass *\n-make_pass_instance (struct opt_pass *pass, bool track_duplicates)\n-{\n-  /* A nonzero static_pass_number indicates that the\n-     pass is already in the list.  */\n-  if (pass->static_pass_number)\n-    {\n-      struct opt_pass *new_pass;\n+/* Update static_pass_number for passes (and the flag\n+   TODO_mark_first_instance).\n \n-      if (pass->type == GIMPLE_PASS\n-          || pass->type == RTL_PASS\n-          || pass->type == SIMPLE_IPA_PASS)\n-        {\n-          new_pass = XNEW (struct opt_pass);\n-          memcpy (new_pass, pass, sizeof (struct opt_pass));\n-        }\n-      else if (pass->type == IPA_PASS)\n-        {\n-          new_pass = (struct opt_pass *)XNEW (struct ipa_opt_pass_d);\n-          memcpy (new_pass, pass, sizeof (struct ipa_opt_pass_d));\n-        }\n-      else\n-        gcc_unreachable ();\n+   Passes are constructed with static_pass_number preinitialized to 0\n+\n+   This field is used in two different ways: initially as instance numbers\n+   of their kind, and then as ids within the entire pass manager.\n+\n+   Within pass_manager::pass_manager:\n+\n+   * In add_pass_instance(), as called by next_pass_1 in\n+     NEXT_PASS in init_optimization_passes\n \n-      new_pass->next = NULL;\n+   * When the initial instance of a pass within a pass manager is seen,\n+     it is flagged, and its static_pass_number is set to -1\n \n+   * On subsequent times that it is seen, the static pass number\n+     is decremented each time, so that if there are e.g. 4 dups,\n+     they have static_pass_number -4, 2, 3, 4 respectively (note\n+     how the initial one is negative and gives the count); these\n+     can be thought of as instance numbers of the specific pass\n+\n+   * Within the register_dump_files () traversal, set_pass_for_id()\n+     is called on each pass, using these instance numbers to create\n+     dumpfile switches, and then overwriting them with a pass id,\n+     which are global to the whole pass manager (based on\n+     (TDI_end + current value of extra_dump_files_in_use) )  */\n+\n+static void\n+add_pass_instance (struct opt_pass *new_pass, bool track_duplicates,\n+\t\t   opt_pass *initial_pass)\n+{\n+  /* Are we dealing with the first pass of its kind, or a clone?  */\n+  if (new_pass != initial_pass)\n+    {\n+      /* We're dealing with a clone.  */\n       new_pass->todo_flags_start &= ~TODO_mark_first_instance;\n \n       /* Indicate to register_dump_files that this pass has duplicates,\n          and so it should rename the dump file.  The first instance will\n          be -1, and be number of duplicates = -static_pass_number - 1.\n          Subsequent instances will be > 0 and just the duplicate number.  */\n-      if ((pass->name && pass->name[0] != '*') || track_duplicates)\n+      if ((new_pass->name && new_pass->name[0] != '*') || track_duplicates)\n         {\n-          pass->static_pass_number -= 1;\n-          new_pass->static_pass_number = -pass->static_pass_number;\n+          initial_pass->static_pass_number -= 1;\n+          new_pass->static_pass_number = -initial_pass->static_pass_number;\n \t}\n-      return new_pass;\n     }\n   else\n     {\n-      pass->todo_flags_start |= TODO_mark_first_instance;\n-      pass->static_pass_number = -1;\n+      /* We're dealing with the first pass of its kind.  */\n+      new_pass->todo_flags_start |= TODO_mark_first_instance;\n+      new_pass->static_pass_number = -1;\n \n-      invoke_plugin_callbacks (PLUGIN_NEW_PASS, pass);\n+      invoke_plugin_callbacks (PLUGIN_NEW_PASS, new_pass);\n     }\n-  return pass;\n }\n \n /* Add a pass to the pass list. Duplicate the pass if it's already\n    in the list.  */\n \n static struct opt_pass **\n-next_pass_1 (struct opt_pass **list, struct opt_pass *pass)\n+next_pass_1 (struct opt_pass **list, struct opt_pass *pass,\n+\t     struct opt_pass *initial_pass)\n {\n   /* Every pass should have a name so that plugins can refer to them.  */\n   gcc_assert (pass->name != NULL);\n \n-  *list = make_pass_instance (pass, false);\n+  add_pass_instance (pass, false, initial_pass);\n+  *list = pass;\n \n   return &(*list)->next;\n }\n@@ -1278,7 +1287,16 @@ position_pass (struct register_pass_info *new_pass_info,\n           struct opt_pass *new_pass;\n           struct pass_list_node *new_pass_node;\n \n-\t  new_pass = make_pass_instance (new_pass_info->pass, true);\n+\t  if (new_pass_info->ref_pass_instance_number == 0)\n+\t    {\n+\t      new_pass = new_pass_info->pass->clone ();\n+\t      add_pass_instance (new_pass, true, new_pass_info->pass);\n+\t    }\n+\t  else\n+\t    {\n+\t      new_pass = new_pass_info->pass;\n+\t      add_pass_instance (new_pass, true, new_pass);\n+\t    }\n \n           /* Insert the new pass instance based on the positioning op.  */\n           switch (new_pass_info->pos_op)\n@@ -1484,7 +1502,7 @@ pass_manager::pass_manager (context *ctxt)\n         gcc_assert (PASS ## _1);                 \\\n         PASS ## _ ## NUM = PASS ## _1->clone (); \\\n       }                                          \\\n-    p = next_pass_1 (p, PASS ## _ ## NUM);  \\\n+    p = next_pass_1 (p, PASS ## _ ## NUM, PASS ## _1);  \\\n   } while (0)\n \n #define TERMINATE_PASS_LIST() \\"}]}