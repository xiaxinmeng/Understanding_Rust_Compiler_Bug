{"sha": "7a279bed24e1b2a628767a60a20f3dcf6f1088cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2EyNzliZWQyNGUxYjJhNjI4NzY3YTYwYTIwZjNkY2Y2ZjEwODhjYg==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@linux.ibm.com", "date": "2020-09-28T16:15:46Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@linux.ibm.com", "date": "2021-01-27T18:24:59Z"}, "message": "Combine patterns for p10 load-cmpi fusion\n\nThis patch adds the first batch of patterns to support p10 fusion. These\nwill allow combine to create a single insn for a pair of instructions\nthat power10 can fuse and execute. These particular fusion pairs have the\nrequirement that only cr0 can be used when fusing a load with a compare\nimmediate of -1/0/1 (if signed) or 0/1 (if unsigned), so we want combine\nto put that requirement in, and if it doesn't work out the splitter\ncan change it back into 2 insns so scheduling can move them apart.\n\nThe patterns are generated by a script genfusion.pl and live in new file\nfusion.md. This script will be expanded to generate more patterns for\nfusion.\n\nThis also adds option -mpower10-fusion which defaults on for power10 and\nwill gate all these fusion patterns. In addition I have added an\nundocumented option -mpower10-fusion-ld-cmpi (which may be removed later)\nthat just controls the load+compare-immediate patterns. I have made\nthese default on for power10 but they are not disallowed for earlier\nprocessors because it is still valid code. This allows us to test the\ncorrectness of fusion code generation by turning it on explicitly.\n\ngcc/ChangeLog:\n\n\t* config/rs6000/genfusion.pl: New script to generate\n\tdefine_insn_and_split patterns so combine can arrange fused\n\tinstructions next to each other.\n\t* config/rs6000/fusion.md: New file, generated fused instruction\n\tpatterns for combine.\n\t* config/rs6000/predicates.md (const_m1_to_1_operand): New predicate.\n\t(non_update_memory_operand): New predicate.\n\t* config/rs6000/rs6000-cpus.def: Add OPTION_MASK_P10_FUSION and\n\tOPTION_MASK_P10_FUSION_LD_CMPI to ISA_3_1_MASKS_SERVER and\n\tPOWERPC_MASKS.\n\t* config/rs6000/rs6000-protos.h (address_is_non_pfx_d_or_x): Add\n\tprototype.\n\t* config/rs6000/rs6000.c (rs6000_option_override_internal):\n\tAutomatically set OPTION_MASK_P10_FUSION and\n\tOPTION_MASK_P10_FUSION_LD_CMPI if target is power10.\n\t(rs600_opt_masks): Allow -mpower10-fusion\n\tin function attributes.\n\t(address_is_non_pfx_d_or_x): New function.\n\t* config/rs6000/rs6000.h: Add MASK_P10_FUSION.\n\t* config/rs6000/rs6000.md: Include fusion.md.\n\t* config/rs6000/rs6000.opt: Add -mpower10-fusion\n\tand -mpower10-fusion-ld-cmpi.\n\t* config/rs6000/t-rs6000: Add dependencies involving fusion.md.", "tree": {"sha": "7710b4bb56c542f02cbe3669608b7deaa11ca524", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7710b4bb56c542f02cbe3669608b7deaa11ca524"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a279bed24e1b2a628767a60a20f3dcf6f1088cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a279bed24e1b2a628767a60a20f3dcf6f1088cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a279bed24e1b2a628767a60a20f3dcf6f1088cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/comments", "author": {"login": "acsawdey", "id": 41373646, "node_id": "MDQ6VXNlcjQxMzczNjQ2", "avatar_url": "https://avatars.githubusercontent.com/u/41373646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acsawdey", "html_url": "https://github.com/acsawdey", "followers_url": "https://api.github.com/users/acsawdey/followers", "following_url": "https://api.github.com/users/acsawdey/following{/other_user}", "gists_url": "https://api.github.com/users/acsawdey/gists{/gist_id}", "starred_url": "https://api.github.com/users/acsawdey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acsawdey/subscriptions", "organizations_url": "https://api.github.com/users/acsawdey/orgs", "repos_url": "https://api.github.com/users/acsawdey/repos", "events_url": "https://api.github.com/users/acsawdey/events{/privacy}", "received_events_url": "https://api.github.com/users/acsawdey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "acsawdey", "id": 41373646, "node_id": "MDQ6VXNlcjQxMzczNjQ2", "avatar_url": "https://avatars.githubusercontent.com/u/41373646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acsawdey", "html_url": "https://github.com/acsawdey", "followers_url": "https://api.github.com/users/acsawdey/followers", "following_url": "https://api.github.com/users/acsawdey/following{/other_user}", "gists_url": "https://api.github.com/users/acsawdey/gists{/gist_id}", "starred_url": "https://api.github.com/users/acsawdey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acsawdey/subscriptions", "organizations_url": "https://api.github.com/users/acsawdey/orgs", "repos_url": "https://api.github.com/users/acsawdey/repos", "events_url": "https://api.github.com/users/acsawdey/events{/privacy}", "received_events_url": "https://api.github.com/users/acsawdey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3670dbe49059ab1746ac2e3b77940160c05db6c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3670dbe49059ab1746ac2e3b77940160c05db6c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3670dbe49059ab1746ac2e3b77940160c05db6c2"}], "stats": {"total": 595, "additions": 593, "deletions": 2}, "files": [{"sha": "a4d3a6ae7f3b16f851efd8964ea22791f97fa3c4", "filename": "gcc/config/rs6000/fusion.md", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Ffusion.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Ffusion.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ffusion.md?ref=7a279bed24e1b2a628767a60a20f3dcf6f1088cb", "patch": "@@ -0,0 +1,357 @@\n+;; -*- buffer-read-only: t -*-\n+;; Generated automatically by genfusion.pl\n+\n+;; Copyright (C) 2020 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it under\n+;; the terms of the GNU General Public License as published by the Free\n+;; Software Foundation; either version 3, or (at your option) any later\n+;; version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+;; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+;; for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\n+;; load mode is DI result mode is clobber compare mode is CC extend is none\n+(define_insn_and_split \"*ld_cmpdi_cr0_DI_clobber_CC_none\"\n+  [(set (match_operand:CC 2 \"cc_reg_operand\" \"=x\")\n+        (compare:CC (match_operand:DI 1 \"non_update_memory_operand\" \"m\")\n+                 (match_operand:DI 3 \"const_m1_to_1_operand\" \"n\")))\n+   (clobber (match_scratch:DI 0 \"=r\"))]\n+  \"(TARGET_P10_FUSION && TARGET_P10_FUSION_LD_CMPI)\"\n+  \"ld%X1 %0,%1\\;cmpdi 0,%0,%3\"\n+  \"&& reload_completed\n+   && (cc_reg_not_cr0_operand (operands[2], CCmode)\n+       || !address_is_non_pfx_d_or_x (XEXP (operands[1],0), DImode, NON_PREFIXED_DS))\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 2)\n+        (compare:CC (match_dup 0)\n+\t\t    (match_dup 3)))]\n+  \"\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"cost\" \"8\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\n+;; load mode is DI result mode is clobber compare mode is CCUNS extend is none\n+(define_insn_and_split \"*ld_cmpldi_cr0_DI_clobber_CCUNS_none\"\n+  [(set (match_operand:CCUNS 2 \"cc_reg_operand\" \"=x\")\n+        (compare:CCUNS (match_operand:DI 1 \"non_update_memory_operand\" \"m\")\n+                 (match_operand:DI 3 \"const_0_to_1_operand\" \"n\")))\n+   (clobber (match_scratch:DI 0 \"=r\"))]\n+  \"(TARGET_P10_FUSION && TARGET_P10_FUSION_LD_CMPI)\"\n+  \"ld%X1 %0,%1\\;cmpldi 0,%0,%3\"\n+  \"&& reload_completed\n+   && (cc_reg_not_cr0_operand (operands[2], CCmode)\n+       || !address_is_non_pfx_d_or_x (XEXP (operands[1],0), DImode, NON_PREFIXED_DS))\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 2)\n+        (compare:CCUNS (match_dup 0)\n+\t\t    (match_dup 3)))]\n+  \"\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"cost\" \"8\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\n+;; load mode is DI result mode is DI compare mode is CC extend is none\n+(define_insn_and_split \"*ld_cmpdi_cr0_DI_DI_CC_none\"\n+  [(set (match_operand:CC 2 \"cc_reg_operand\" \"=x\")\n+        (compare:CC (match_operand:DI 1 \"non_update_memory_operand\" \"m\")\n+                 (match_operand:DI 3 \"const_m1_to_1_operand\" \"n\")))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\") (match_dup 1))]\n+  \"(TARGET_P10_FUSION && TARGET_P10_FUSION_LD_CMPI)\"\n+  \"ld%X1 %0,%1\\;cmpdi 0,%0,%3\"\n+  \"&& reload_completed\n+   && (cc_reg_not_cr0_operand (operands[2], CCmode)\n+       || !address_is_non_pfx_d_or_x (XEXP (operands[1],0), DImode, NON_PREFIXED_DS))\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 2)\n+        (compare:CC (match_dup 0)\n+\t\t    (match_dup 3)))]\n+  \"\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"cost\" \"8\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\n+;; load mode is DI result mode is DI compare mode is CCUNS extend is none\n+(define_insn_and_split \"*ld_cmpldi_cr0_DI_DI_CCUNS_none\"\n+  [(set (match_operand:CCUNS 2 \"cc_reg_operand\" \"=x\")\n+        (compare:CCUNS (match_operand:DI 1 \"non_update_memory_operand\" \"m\")\n+                 (match_operand:DI 3 \"const_0_to_1_operand\" \"n\")))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\") (match_dup 1))]\n+  \"(TARGET_P10_FUSION && TARGET_P10_FUSION_LD_CMPI)\"\n+  \"ld%X1 %0,%1\\;cmpldi 0,%0,%3\"\n+  \"&& reload_completed\n+   && (cc_reg_not_cr0_operand (operands[2], CCmode)\n+       || !address_is_non_pfx_d_or_x (XEXP (operands[1],0), DImode, NON_PREFIXED_DS))\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 2)\n+        (compare:CCUNS (match_dup 0)\n+\t\t    (match_dup 3)))]\n+  \"\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"cost\" \"8\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\n+;; load mode is SI result mode is clobber compare mode is CC extend is none\n+(define_insn_and_split \"*lwa_cmpdi_cr0_SI_clobber_CC_none\"\n+  [(set (match_operand:CC 2 \"cc_reg_operand\" \"=x\")\n+        (compare:CC (match_operand:SI 1 \"non_update_memory_operand\" \"m\")\n+                 (match_operand:SI 3 \"const_m1_to_1_operand\" \"n\")))\n+   (clobber (match_scratch:SI 0 \"=r\"))]\n+  \"(TARGET_P10_FUSION && TARGET_P10_FUSION_LD_CMPI)\"\n+  \"lwa%X1 %0,%1\\;cmpdi 0,%0,%3\"\n+  \"&& reload_completed\n+   && (cc_reg_not_cr0_operand (operands[2], CCmode)\n+       || !address_is_non_pfx_d_or_x (XEXP (operands[1],0), SImode, NON_PREFIXED_DS))\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 2)\n+        (compare:CC (match_dup 0)\n+\t\t    (match_dup 3)))]\n+  \"\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"cost\" \"8\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\n+;; load mode is SI result mode is clobber compare mode is CCUNS extend is none\n+(define_insn_and_split \"*lwz_cmpldi_cr0_SI_clobber_CCUNS_none\"\n+  [(set (match_operand:CCUNS 2 \"cc_reg_operand\" \"=x\")\n+        (compare:CCUNS (match_operand:SI 1 \"non_update_memory_operand\" \"m\")\n+                 (match_operand:SI 3 \"const_0_to_1_operand\" \"n\")))\n+   (clobber (match_scratch:SI 0 \"=r\"))]\n+  \"(TARGET_P10_FUSION && TARGET_P10_FUSION_LD_CMPI)\"\n+  \"lwz%X1 %0,%1\\;cmpldi 0,%0,%3\"\n+  \"&& reload_completed\n+   && (cc_reg_not_cr0_operand (operands[2], CCmode)\n+       || !address_is_non_pfx_d_or_x (XEXP (operands[1],0), SImode, NON_PREFIXED_D))\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 2)\n+        (compare:CCUNS (match_dup 0)\n+\t\t    (match_dup 3)))]\n+  \"\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"cost\" \"8\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\n+;; load mode is SI result mode is SI compare mode is CC extend is none\n+(define_insn_and_split \"*lwa_cmpdi_cr0_SI_SI_CC_none\"\n+  [(set (match_operand:CC 2 \"cc_reg_operand\" \"=x\")\n+        (compare:CC (match_operand:SI 1 \"non_update_memory_operand\" \"m\")\n+                 (match_operand:SI 3 \"const_m1_to_1_operand\" \"n\")))\n+   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\") (match_dup 1))]\n+  \"(TARGET_P10_FUSION && TARGET_P10_FUSION_LD_CMPI)\"\n+  \"lwa%X1 %0,%1\\;cmpdi 0,%0,%3\"\n+  \"&& reload_completed\n+   && (cc_reg_not_cr0_operand (operands[2], CCmode)\n+       || !address_is_non_pfx_d_or_x (XEXP (operands[1],0), SImode, NON_PREFIXED_DS))\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 2)\n+        (compare:CC (match_dup 0)\n+\t\t    (match_dup 3)))]\n+  \"\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"cost\" \"8\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\n+;; load mode is SI result mode is SI compare mode is CCUNS extend is none\n+(define_insn_and_split \"*lwz_cmpldi_cr0_SI_SI_CCUNS_none\"\n+  [(set (match_operand:CCUNS 2 \"cc_reg_operand\" \"=x\")\n+        (compare:CCUNS (match_operand:SI 1 \"non_update_memory_operand\" \"m\")\n+                 (match_operand:SI 3 \"const_0_to_1_operand\" \"n\")))\n+   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\") (match_dup 1))]\n+  \"(TARGET_P10_FUSION && TARGET_P10_FUSION_LD_CMPI)\"\n+  \"lwz%X1 %0,%1\\;cmpldi 0,%0,%3\"\n+  \"&& reload_completed\n+   && (cc_reg_not_cr0_operand (operands[2], CCmode)\n+       || !address_is_non_pfx_d_or_x (XEXP (operands[1],0), SImode, NON_PREFIXED_D))\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 2)\n+        (compare:CCUNS (match_dup 0)\n+\t\t    (match_dup 3)))]\n+  \"\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"cost\" \"8\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\n+;; load mode is SI result mode is EXTSI compare mode is CC extend is sign\n+(define_insn_and_split \"*lwa_cmpdi_cr0_SI_EXTSI_CC_sign\"\n+  [(set (match_operand:CC 2 \"cc_reg_operand\" \"=x\")\n+        (compare:CC (match_operand:SI 1 \"non_update_memory_operand\" \"m\")\n+                 (match_operand:SI 3 \"const_m1_to_1_operand\" \"n\")))\n+   (set (match_operand:EXTSI 0 \"gpc_reg_operand\" \"=r\") (sign_extend:EXTSI (match_dup 1)))]\n+  \"(TARGET_P10_FUSION && TARGET_P10_FUSION_LD_CMPI)\"\n+  \"lwa%X1 %0,%1\\;cmpdi 0,%0,%3\"\n+  \"&& reload_completed\n+   && (cc_reg_not_cr0_operand (operands[2], CCmode)\n+       || !address_is_non_pfx_d_or_x (XEXP (operands[1],0), SImode, NON_PREFIXED_DS))\"\n+  [(set (match_dup 0) (sign_extend:EXTSI (match_dup 1)))\n+   (set (match_dup 2)\n+        (compare:CC (match_dup 0)\n+\t\t    (match_dup 3)))]\n+  \"\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"cost\" \"8\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\n+;; load mode is SI result mode is EXTSI compare mode is CCUNS extend is zero\n+(define_insn_and_split \"*lwz_cmpldi_cr0_SI_EXTSI_CCUNS_zero\"\n+  [(set (match_operand:CCUNS 2 \"cc_reg_operand\" \"=x\")\n+        (compare:CCUNS (match_operand:SI 1 \"non_update_memory_operand\" \"m\")\n+                 (match_operand:SI 3 \"const_0_to_1_operand\" \"n\")))\n+   (set (match_operand:EXTSI 0 \"gpc_reg_operand\" \"=r\") (zero_extend:EXTSI (match_dup 1)))]\n+  \"(TARGET_P10_FUSION && TARGET_P10_FUSION_LD_CMPI)\"\n+  \"lwz%X1 %0,%1\\;cmpldi 0,%0,%3\"\n+  \"&& reload_completed\n+   && (cc_reg_not_cr0_operand (operands[2], CCmode)\n+       || !address_is_non_pfx_d_or_x (XEXP (operands[1],0), SImode, NON_PREFIXED_D))\"\n+  [(set (match_dup 0) (zero_extend:EXTSI (match_dup 1)))\n+   (set (match_dup 2)\n+        (compare:CCUNS (match_dup 0)\n+\t\t    (match_dup 3)))]\n+  \"\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"cost\" \"8\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\n+;; load mode is HI result mode is clobber compare mode is CC extend is sign\n+(define_insn_and_split \"*lha_cmpdi_cr0_HI_clobber_CC_sign\"\n+  [(set (match_operand:CC 2 \"cc_reg_operand\" \"=x\")\n+        (compare:CC (match_operand:HI 1 \"non_update_memory_operand\" \"m\")\n+                 (match_operand:HI 3 \"const_m1_to_1_operand\" \"n\")))\n+   (clobber (match_scratch:GPR 0 \"=r\"))]\n+  \"(TARGET_P10_FUSION && TARGET_P10_FUSION_LD_CMPI)\"\n+  \"lha%X1 %0,%1\\;cmpdi 0,%0,%3\"\n+  \"&& reload_completed\n+   && (cc_reg_not_cr0_operand (operands[2], CCmode)\n+       || !address_is_non_pfx_d_or_x (XEXP (operands[1],0), HImode, NON_PREFIXED_D))\"\n+  [(set (match_dup 0) (sign_extend:GPR (match_dup 1)))\n+   (set (match_dup 2)\n+        (compare:CC (match_dup 0)\n+\t\t    (match_dup 3)))]\n+  \"\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"cost\" \"8\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\n+;; load mode is HI result mode is clobber compare mode is CCUNS extend is zero\n+(define_insn_and_split \"*lhz_cmpldi_cr0_HI_clobber_CCUNS_zero\"\n+  [(set (match_operand:CCUNS 2 \"cc_reg_operand\" \"=x\")\n+        (compare:CCUNS (match_operand:HI 1 \"non_update_memory_operand\" \"m\")\n+                 (match_operand:HI 3 \"const_0_to_1_operand\" \"n\")))\n+   (clobber (match_scratch:GPR 0 \"=r\"))]\n+  \"(TARGET_P10_FUSION && TARGET_P10_FUSION_LD_CMPI)\"\n+  \"lhz%X1 %0,%1\\;cmpldi 0,%0,%3\"\n+  \"&& reload_completed\n+   && (cc_reg_not_cr0_operand (operands[2], CCmode)\n+       || !address_is_non_pfx_d_or_x (XEXP (operands[1],0), HImode, NON_PREFIXED_D))\"\n+  [(set (match_dup 0) (zero_extend:GPR (match_dup 1)))\n+   (set (match_dup 2)\n+        (compare:CCUNS (match_dup 0)\n+\t\t    (match_dup 3)))]\n+  \"\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"cost\" \"8\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\n+;; load mode is HI result mode is EXTHI compare mode is CC extend is sign\n+(define_insn_and_split \"*lha_cmpdi_cr0_HI_EXTHI_CC_sign\"\n+  [(set (match_operand:CC 2 \"cc_reg_operand\" \"=x\")\n+        (compare:CC (match_operand:HI 1 \"non_update_memory_operand\" \"m\")\n+                 (match_operand:HI 3 \"const_m1_to_1_operand\" \"n\")))\n+   (set (match_operand:EXTHI 0 \"gpc_reg_operand\" \"=r\") (sign_extend:EXTHI (match_dup 1)))]\n+  \"(TARGET_P10_FUSION && TARGET_P10_FUSION_LD_CMPI)\"\n+  \"lha%X1 %0,%1\\;cmpdi 0,%0,%3\"\n+  \"&& reload_completed\n+   && (cc_reg_not_cr0_operand (operands[2], CCmode)\n+       || !address_is_non_pfx_d_or_x (XEXP (operands[1],0), HImode, NON_PREFIXED_D))\"\n+  [(set (match_dup 0) (sign_extend:EXTHI (match_dup 1)))\n+   (set (match_dup 2)\n+        (compare:CC (match_dup 0)\n+\t\t    (match_dup 3)))]\n+  \"\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"cost\" \"8\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\n+;; load mode is HI result mode is EXTHI compare mode is CCUNS extend is zero\n+(define_insn_and_split \"*lhz_cmpldi_cr0_HI_EXTHI_CCUNS_zero\"\n+  [(set (match_operand:CCUNS 2 \"cc_reg_operand\" \"=x\")\n+        (compare:CCUNS (match_operand:HI 1 \"non_update_memory_operand\" \"m\")\n+                 (match_operand:HI 3 \"const_0_to_1_operand\" \"n\")))\n+   (set (match_operand:EXTHI 0 \"gpc_reg_operand\" \"=r\") (zero_extend:EXTHI (match_dup 1)))]\n+  \"(TARGET_P10_FUSION && TARGET_P10_FUSION_LD_CMPI)\"\n+  \"lhz%X1 %0,%1\\;cmpldi 0,%0,%3\"\n+  \"&& reload_completed\n+   && (cc_reg_not_cr0_operand (operands[2], CCmode)\n+       || !address_is_non_pfx_d_or_x (XEXP (operands[1],0), HImode, NON_PREFIXED_D))\"\n+  [(set (match_dup 0) (zero_extend:EXTHI (match_dup 1)))\n+   (set (match_dup 2)\n+        (compare:CCUNS (match_dup 0)\n+\t\t    (match_dup 3)))]\n+  \"\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"cost\" \"8\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\n+;; load mode is QI result mode is clobber compare mode is CCUNS extend is zero\n+(define_insn_and_split \"*lbz_cmpldi_cr0_QI_clobber_CCUNS_zero\"\n+  [(set (match_operand:CCUNS 2 \"cc_reg_operand\" \"=x\")\n+        (compare:CCUNS (match_operand:QI 1 \"non_update_memory_operand\" \"m\")\n+                 (match_operand:QI 3 \"const_0_to_1_operand\" \"n\")))\n+   (clobber (match_scratch:GPR 0 \"=r\"))]\n+  \"(TARGET_P10_FUSION && TARGET_P10_FUSION_LD_CMPI)\"\n+  \"lbz%X1 %0,%1\\;cmpldi 0,%0,%3\"\n+  \"&& reload_completed\n+   && (cc_reg_not_cr0_operand (operands[2], CCmode)\n+       || !address_is_non_pfx_d_or_x (XEXP (operands[1],0), QImode, NON_PREFIXED_D))\"\n+  [(set (match_dup 0) (zero_extend:GPR (match_dup 1)))\n+   (set (match_dup 2)\n+        (compare:CCUNS (match_dup 0)\n+\t\t    (match_dup 3)))]\n+  \"\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"cost\" \"8\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\n+;; load mode is QI result mode is GPR compare mode is CCUNS extend is zero\n+(define_insn_and_split \"*lbz_cmpldi_cr0_QI_GPR_CCUNS_zero\"\n+  [(set (match_operand:CCUNS 2 \"cc_reg_operand\" \"=x\")\n+        (compare:CCUNS (match_operand:QI 1 \"non_update_memory_operand\" \"m\")\n+                 (match_operand:QI 3 \"const_0_to_1_operand\" \"n\")))\n+   (set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\") (zero_extend:GPR (match_dup 1)))]\n+  \"(TARGET_P10_FUSION && TARGET_P10_FUSION_LD_CMPI)\"\n+  \"lbz%X1 %0,%1\\;cmpldi 0,%0,%3\"\n+  \"&& reload_completed\n+   && (cc_reg_not_cr0_operand (operands[2], CCmode)\n+       || !address_is_non_pfx_d_or_x (XEXP (operands[1],0), QImode, NON_PREFIXED_D))\"\n+  [(set (match_dup 0) (zero_extend:GPR (match_dup 1)))\n+   (set (match_dup 2)\n+        (compare:CCUNS (match_dup 0)\n+\t\t    (match_dup 3)))]\n+  \"\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"cost\" \"8\")\n+   (set_attr \"length\" \"8\")])\n+"}, {"sha": "2b53c10e9e3fe9aba45df77a86fdbdbdb88a7b8d", "filename": "gcc/config/rs6000/genfusion.pl", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Fgenfusion.pl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Fgenfusion.pl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fgenfusion.pl?ref=7a279bed24e1b2a628767a60a20f3dcf6f1088cb", "patch": "@@ -0,0 +1,148 @@\n+#!/usr/bin/perl\n+# Generate fusion.md\n+#\n+# Copyright (C) 2020,2021 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+use warnings;\n+use strict;\n+\n+print <<'EOF';\n+;; Generated automatically by genfusion.pl\n+\n+;; Copyright (C) 2020,2021 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it under\n+;; the terms of the GNU General Public License as published by the Free\n+;; Software Foundation; either version 3, or (at your option) any later\n+;; version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+;; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+;; for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+EOF\n+\n+sub mode_to_ldst_char\n+{\n+    my ($mode) = @_;\n+    my %x = (DI => 'd', SI => 'w', HI => 'h', QI => 'b');\n+    return $x{$mode} if exists $x{$mode};\n+    return '?';\n+}\n+\n+sub gen_ld_cmpi_p10\n+{\n+    my ($lmode, $ldst, $clobbermode, $result, $cmpl, $echr, $constpred,\n+\t$ccmode, $np, $extend, $resultmode);\n+  LMODE: foreach $lmode ('DI','SI','HI','QI') {\n+      $ldst = mode_to_ldst_char($lmode);\n+      $clobbermode = $lmode;\n+      # For clobber, we need a SI/DI reg in case we\n+      # split because we have to sign/zero extend.\n+      if ($lmode eq 'HI' || $lmode eq 'QI') { $clobbermode = \"GPR\"; }\n+    RESULT: foreach $result ('clobber', $lmode,  \"EXT\".$lmode) {\n+\t# EXTDI does not exist, and we cannot directly produce HI/QI results.\n+\tnext RESULT if $result eq \"EXTDI\" || $result eq \"HI\" || $result eq \"QI\";\n+\t# Don't allow EXTQI because that would allow HI result which we can't do.\n+\t$result = \"GPR\" if $result eq \"EXTQI\";\n+      CCMODE: foreach $ccmode ('CC','CCUNS') {\n+\t  $np = \"NON_PREFIXED_D\";\n+\t  if ( $ccmode eq 'CC' ) {\n+\t      next CCMODE if $lmode eq 'QI';\n+\t      if ( $lmode eq 'DI' || $lmode eq 'SI' ) {\n+\t\t  # ld and lwa are both DS-FORM.\n+\t\t  $np = \"NON_PREFIXED_DS\";\n+\t      }\n+\t      $cmpl = \"\";\n+\t      $echr = \"a\";\n+\t      $constpred = \"const_m1_to_1_operand\";\n+\t  } else {\n+\t      if ( $lmode eq 'DI' ) {\n+\t\t  # ld is DS-form, but lwz is not.\n+\t\t  $np = \"NON_PREFIXED_DS\";\n+\t      }\n+\t      $cmpl = \"l\";\n+\t      $echr = \"z\";\n+\t      $constpred = \"const_0_to_1_operand\";\n+\t  }\n+\t  if ($lmode eq 'DI') { $echr = \"\"; }\n+\t  if ($result =~ m/^EXT/ || $result eq 'GPR' || $clobbermode eq 'GPR') {\n+\t      # We always need extension if result > lmode.\n+\t      if ( $ccmode eq 'CC' ) {\n+\t\t  $extend = \"sign\";\n+\t      } else {\n+\t\t  $extend = \"zero\";\n+\t      }\n+\t  } else {\n+\t      # Result of SI/DI does not need sign extension.\n+\t      $extend = \"none\";\n+\t  }\n+\t  print \";; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\\n\";\n+\t  print \";; load mode is $lmode result mode is $result compare mode is $ccmode extend is $extend\\n\";\n+\n+\t  print \"(define_insn_and_split \\\"*l${ldst}${echr}_cmp${cmpl}di_cr0_${lmode}_${result}_${ccmode}_${extend}\\\"\\n\";\n+\t  print \"  [(set (match_operand:${ccmode} 2 \\\"cc_reg_operand\\\" \\\"=x\\\")\\n\";\n+\t  print \"        (compare:${ccmode} (match_operand:${lmode} 1 \\\"non_update_memory_operand\\\" \\\"m\\\")\\n\";\n+\t  if ($ccmode eq 'CCUNS') { print \"   \"; }\n+\t  print \"                    (match_operand:${lmode} 3 \\\"${constpred}\\\" \\\"n\\\")))\\n\";\n+\t  if ($result eq 'clobber') {\n+\t      print \"   (clobber (match_scratch:${clobbermode} 0 \\\"=r\\\"))]\\n\";\n+\t  } elsif ($result eq $lmode) {\n+\t      print \"   (set (match_operand:${result} 0 \\\"gpc_reg_operand\\\" \\\"=r\\\") (match_dup 1))]\\n\";\n+\t  } else {\n+\t      print \"   (set (match_operand:${result} 0 \\\"gpc_reg_operand\\\" \\\"=r\\\") (${extend}_extend:${result} (match_dup 1)))]\\n\";\n+\t  }\n+\t  print \"  \\\"(TARGET_P10_FUSION && TARGET_P10_FUSION_LD_CMPI)\\\"\\n\";\n+\t  print \"  \\\"l${ldst}${echr}%X1 %0,%1\\\\;cmp${cmpl}di %2,%0,%3\\\"\\n\";\n+\t  print \"  \\\"&& reload_completed\\n\";\n+\t  print \"   && (cc_reg_not_cr0_operand (operands[2], CCmode)\\n\";\n+\t  print \"       || !address_is_non_pfx_d_or_x (XEXP (operands[1], 0),\\n\";\n+\t  print \"                                      ${lmode}mode, ${np}))\\\"\\n\";\n+\n+\t  if ($extend eq \"none\") {\n+\t      print \"  [(set (match_dup 0) (match_dup 1))\\n\";\n+\t  } else {\n+\t      $resultmode = $result;\n+\t      if ( $result eq 'clobber' ) { $resultmode = $clobbermode }\n+\t      print \"  [(set (match_dup 0) (${extend}_extend:${resultmode} (match_dup 1)))\\n\";\n+\t  }\n+\t  print \"   (set (match_dup 2)\\n\";\n+\t  print \"        (compare:${ccmode} (match_dup 0) (match_dup 3)))]\\n\";\n+\t  print \"  \\\"\\\"\\n\";\n+\t  print \"  [(set_attr \\\"type\\\" \\\"load\\\")\\n\";\n+\t  print \"   (set_attr \\\"cost\\\" \\\"8\\\")\\n\";\n+\t  print \"   (set_attr \\\"length\\\" \\\"8\\\")])\\n\";\n+\t  print \"\\n\";\n+      }\n+    }\n+  }\n+}\n+\n+\n+gen_ld_cmpi_p10();\n+\n+exit(0);\n+"}, {"sha": "76328ecff3d8bd1adc9a73c58fd23c41452e04cf", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=7a279bed24e1b2a628767a60a20f3dcf6f1088cb", "patch": "@@ -297,6 +297,11 @@\n   (and (match_code \"const_int\")\n        (match_test \"IN_RANGE (INTVAL (op), 0, 1)\")))\n \n+;; Match op = -1, op = 0, or op = 1.\n+(define_predicate \"const_m1_to_1_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), -1, 1)\")))\n+\n ;; Match op = 0..3.\n (define_predicate \"const_0_to_3_operand\"\n   (and (match_code \"const_int\")\n@@ -847,6 +852,15 @@\n \t\t    || GET_CODE (XEXP (op, 0)) == PRE_DEC\n \t\t    || GET_CODE (XEXP (op, 0)) == PRE_MODIFY))\"))\n \n+;; Anything that matches memory_operand but does not update the address.\n+(define_predicate \"non_update_memory_operand\"\n+  (match_code \"mem\")\n+{\n+  if (update_address_mem (op, mode))\n+    return 0;\n+  return memory_operand (op, mode);\n+})\n+\n ;; Return 1 if the operand is a MEM with an indexed-form address.\n (define_special_predicate \"indexed_address_mem\"\n   (match_test \"(MEM_P (op)"}, {"sha": "fc9376db3f48215e28701f89d7a58c3b941d42a0", "filename": "gcc/config/rs6000/rs6000-cpus.def", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def?ref=7a279bed24e1b2a628767a60a20f3dcf6f1088cb", "patch": "@@ -81,7 +81,9 @@\n \n #define ISA_3_1_MASKS_SERVER\t(ISA_3_0_MASKS_SERVER\t\t\t\\\n \t\t\t\t | OPTION_MASK_POWER10\t\t\t\\\n-\t\t\t\t | OTHER_POWER10_MASKS)\n+\t\t\t\t | OTHER_POWER10_MASKS\t\t\t\\\n+\t\t\t\t | OPTION_MASK_P10_FUSION\t\t\\\n+\t\t\t\t | OPTION_MASK_P10_FUSION_LD_CMPI)\n \n /* Flags that need to be turned off if -mno-power9-vector.  */\n #define OTHER_P9_VECTOR_MASKS\t(OPTION_MASK_FLOAT128_HW\t\t\\\n@@ -128,6 +130,8 @@\n \t\t\t\t | OPTION_MASK_FLOAT128_KEYWORD\t\t\\\n \t\t\t\t | OPTION_MASK_FPRND\t\t\t\\\n \t\t\t\t | OPTION_MASK_POWER10\t\t\t\\\n+\t\t\t\t | OPTION_MASK_P10_FUSION\t\t\\\n+\t\t\t\t | OPTION_MASK_P10_FUSION_LD_CMPI\t\\\n \t\t\t\t | OPTION_MASK_HTM\t\t\t\\\n \t\t\t\t | OPTION_MASK_ISEL\t\t\t\\\n \t\t\t\t | OPTION_MASK_MFCRF\t\t\t\\"}, {"sha": "6157097c1c253ef2dfe963b622848fc5dc474614", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=7a279bed24e1b2a628767a60a20f3dcf6f1088cb", "patch": "@@ -192,6 +192,8 @@ enum non_prefixed_form {\n \n extern enum insn_form address_to_insn_form (rtx, machine_mode,\n \t\t\t\t\t    enum non_prefixed_form);\n+extern bool address_is_non_pfx_d_or_x (rtx addr, machine_mode mode,\n+\t\t\t\t       enum non_prefixed_form non_prefix_format);\n extern bool prefixed_load_p (rtx_insn *);\n extern bool prefixed_store_p (rtx_insn *);\n extern bool prefixed_paddi_p (rtx_insn *);"}, {"sha": "e46d45f26b68e86392082e101df956313a82c403", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=7a279bed24e1b2a628767a60a20f3dcf6f1088cb", "patch": "@@ -4430,6 +4430,13 @@ rs6000_option_override_internal (bool global_init_p)\n   if (TARGET_POWER10 && (rs6000_isa_flags_explicit & OPTION_MASK_MMA) == 0)\n     rs6000_isa_flags |= OPTION_MASK_MMA;\n \n+  if (TARGET_POWER10 && (rs6000_isa_flags_explicit & OPTION_MASK_P10_FUSION) == 0)\n+    rs6000_isa_flags |= OPTION_MASK_P10_FUSION;\n+\n+  if (TARGET_POWER10 &&\n+      (rs6000_isa_flags_explicit & OPTION_MASK_P10_FUSION_LD_CMPI) == 0)\n+    rs6000_isa_flags |= OPTION_MASK_P10_FUSION_LD_CMPI;\n+\n   /* Turn off vector pair/mma options on non-power10 systems.  */\n   else if (!TARGET_POWER10 && TARGET_MMA)\n     {\n@@ -23787,6 +23794,7 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n   { \"power9-minmax\",\t\tOPTION_MASK_P9_MINMAX,\t\tfalse, true  },\n   { \"power9-misc\",\t\tOPTION_MASK_P9_MISC,\t\tfalse, true  },\n   { \"power9-vector\",\t\tOPTION_MASK_P9_VECTOR,\t\tfalse, true  },\n+  { \"power10-fusion\",\t\tOPTION_MASK_P10_FUSION,\t\tfalse, true  },\n   { \"powerpc-gfxopt\",\t\tOPTION_MASK_PPC_GFXOPT,\t\tfalse, true  },\n   { \"powerpc-gpopt\",\t\tOPTION_MASK_PPC_GPOPT,\t\tfalse, true  },\n   { \"prefixed\",\t\t\tOPTION_MASK_PREFIXED,\t\tfalse, true  },\n@@ -25878,6 +25886,50 @@ address_to_insn_form (rtx addr,\n   return INSN_FORM_BAD;\n }\n \n+/* Given address rtx ADDR for a load of MODE, is this legitimate for a\n+   non-prefixed D-form or X-form instruction?  NON_PREFIXED_FORMAT is\n+   given NON_PREFIXED_D or NON_PREFIXED_DS to indicate whether we want\n+   a D-form or DS-form instruction.  X-form and base_reg are always\n+   allowed.  */\n+bool\n+address_is_non_pfx_d_or_x (rtx addr, machine_mode mode,\n+\t\t\t   enum non_prefixed_form non_prefixed_format)\n+{\n+  enum insn_form result_form;\n+\n+  result_form = address_to_insn_form (addr, mode, non_prefixed_format);\n+\n+  switch (non_prefixed_format)\n+    {\n+    case NON_PREFIXED_D:\n+      switch (result_form)\n+\t{\n+\tcase INSN_FORM_X:\n+\tcase INSN_FORM_D:\n+\tcase INSN_FORM_DS:\n+\tcase INSN_FORM_BASE_REG:\n+\t  return true;\n+\tdefault:\n+\t  return false;\n+\t}\n+      break;\n+    case NON_PREFIXED_DS:\n+      switch (result_form)\n+\t{\n+\tcase INSN_FORM_X:\n+\tcase INSN_FORM_DS:\n+\tcase INSN_FORM_BASE_REG:\n+\t  return true;\n+\tdefault:\n+\t  return false;\n+\t}\n+      break;\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n /* Helper function to see if we're potentially looking at lfs/stfs.\n    - PARALLEL containing a SET and a CLOBBER\n    - stfs:"}, {"sha": "233a92baf3cd9cd351d1a5f5c189528ca022c127", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=7a279bed24e1b2a628767a60a20f3dcf6f1088cb", "patch": "@@ -539,6 +539,7 @@ extern int rs6000_vector_align[];\n #define MASK_UPDATE\t\t\tOPTION_MASK_UPDATE\n #define MASK_VSX\t\t\tOPTION_MASK_VSX\n #define MASK_POWER10\t\t\tOPTION_MASK_POWER10\n+#define MASK_P10_FUSION\t\t\tOPTION_MASK_P10_FUSION\n \n #ifndef IN_LIBGCC2\n #define MASK_POWERPC64\t\t\tOPTION_MASK_POWERPC64"}, {"sha": "a1315523fecd8f1cf74becec388a576c4e6afced", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=7a279bed24e1b2a628767a60a20f3dcf6f1088cb", "patch": "@@ -14927,3 +14927,4 @@\n (include \"dfp.md\")\n (include \"crypto.md\")\n (include \"htm.md\")\n+(include \"fusion.md\")"}, {"sha": "6240f779694e3600294169dca355a626ac41f9d7", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=7a279bed24e1b2a628767a60a20f3dcf6f1088cb", "patch": "@@ -479,6 +479,14 @@ mpower8-vector\n Target Mask(P8_VECTOR) Var(rs6000_isa_flags)\n Use vector and scalar instructions added in ISA 2.07.\n \n+mpower10-fusion\n+Target Mask(P10_FUSION) Var(rs6000_isa_flags)\n+Fuse certain integer operations together for better performance on power10.\n+\n+mpower10-fusion-ld-cmpi\n+Target Undocumented Mask(P10_FUSION_LD_CMPI) Var(rs6000_isa_flags)\n+Fuse certain integer operations together for better performance on power10.\n+\n mcrypto\n Target Mask(CRYPTO) Var(rs6000_isa_flags)\n Use ISA 2.07 Category:Vector.AES and Category:Vector.SHA2 instructions."}, {"sha": "e3a58bf31bf5b72c339263c67ad3e9dc55b285ea", "filename": "gcc/config/rs6000/t-rs6000", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a279bed24e1b2a628767a60a20f3dcf6f1088cb/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-rs6000?ref=7a279bed24e1b2a628767a60a20f3dcf6f1088cb", "patch": "@@ -47,6 +47,9 @@ rs6000-call.o: $(srcdir)/config/rs6000/rs6000-call.c\n \t$(COMPILE) $<\n \t$(POSTCOMPILE)\n \n+$(srcdir)/config/rs6000/fusion.md: $(srcdir)/config/rs6000/genfusion.pl\n+\t$(srcdir)/config/rs6000/genfusion.pl > $(srcdir)/config/rs6000/fusion.md\n+\n $(srcdir)/config/rs6000/rs6000-tables.opt: $(srcdir)/config/rs6000/genopt.sh \\\n   $(srcdir)/config/rs6000/rs6000-cpus.def\n \t$(SHELL) $(srcdir)/config/rs6000/genopt.sh $(srcdir)/config/rs6000 > \\\n@@ -86,4 +89,5 @@ MD_INCLUDES = $(srcdir)/config/rs6000/rs64.md \\\n \t$(srcdir)/config/rs6000/mma.md \\\n \t$(srcdir)/config/rs6000/crypto.md \\\n \t$(srcdir)/config/rs6000/htm.md \\\n-\t$(srcdir)/config/rs6000/dfp.md\n+\t$(srcdir)/config/rs6000/dfp.md \\\n+\t$(srcdir)/config/rs6000/fusion.md"}]}