{"sha": "aed5574e7b576594b71bbda5c822c667055b791c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVkNTU3NGU3YjU3NjU5NGI3MWJiZGE1YzgyMmM2NjcwNTViNzkxYw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-05-26T18:19:36Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-05-26T18:19:36Z"}, "message": "[multiple changes]\n\n2011-05-26  Paul Thomas  <pault@gcc.gnu.org>\n\t    Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/48955\n\t* trans-expr.c (gfc_trans_assignment_1): GFC_REVERSE_NOT_SET\n\tchanged to GFC_ENABLE_REVERSE.\n\t* trans-array.c (gfc_init_loopinfo): GFC_CANNOT_REVERSE changed\n\tto GFC_INHIBIT_REVERSE.\n\t* gfortran.h : Enum gfc_reverse is now GFC_ENABLE_REVERSE,\n\tGFC_FORWARD_SET, GFC_REVERSE_SET and GFC_INHIBIT_REVERSE.\n\t* dependency.c (gfc_dep_resolver): Change names for elements of\n\tgfc_reverse as necessary. Change the logic so that forward\n\tdependences are remembered as well as backward ones. When both\n\thave appeared, force a temporary.\n\n2011-05-26  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/48955\n\t* gfortran.dg/dependency_40.f90 : New test.\n\nFrom-SVN: r174302", "tree": {"sha": "ffed11dce78ea1dd3b66ef042c7218e1fa25507e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffed11dce78ea1dd3b66ef042c7218e1fa25507e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aed5574e7b576594b71bbda5c822c667055b791c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aed5574e7b576594b71bbda5c822c667055b791c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aed5574e7b576594b71bbda5c822c667055b791c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aed5574e7b576594b71bbda5c822c667055b791c/comments", "author": null, "committer": null, "parents": [{"sha": "b8ff4e88e790df436088012ce6db7f7d3b6c1514", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ff4e88e790df436088012ce6db7f7d3b6c1514", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8ff4e88e790df436088012ce6db7f7d3b6c1514"}], "stats": {"total": 94, "additions": 76, "deletions": 18}, "files": [{"sha": "304c887f2220853122a74b500c9b75886ec134d4", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aed5574e7b576594b71bbda5c822c667055b791c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aed5574e7b576594b71bbda5c822c667055b791c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=aed5574e7b576594b71bbda5c822c667055b791c", "patch": "@@ -1,3 +1,18 @@\n+2011-05-26  Paul Thomas  <pault@gcc.gnu.org>\n+\t    Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/48955\n+\t* trans-expr.c (gfc_trans_assignment_1): GFC_REVERSE_NOT_SET\n+\tchanged to GFC_ENABLE_REVERSE.\n+\t* trans-array.c (gfc_init_loopinfo): GFC_CANNOT_REVERSE changed\n+\tto GFC_INHIBIT_REVERSE.\n+\t* gfortran.h : Enum gfc_reverse is now GFC_ENABLE_REVERSE,\n+\tGFC_FORWARD_SET, GFC_REVERSE_SET and GFC_INHIBIT_REVERSE.\n+\t* dependency.c (gfc_dep_resolver): Change names for elements of\n+\tgfc_reverse as necessary. Change the logic so that forward\n+\tdependences are remembered as well as backward ones. When both\n+\thave appeared, force a temporary.\n+\n 2011-05-26  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/18918"}, {"sha": "cb5d10ca84bb5ca8468861a304d5fb89dbc2f161", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aed5574e7b576594b71bbda5c822c667055b791c/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aed5574e7b576594b71bbda5c822c667055b791c/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=aed5574e7b576594b71bbda5c822c667055b791c", "patch": "@@ -1807,33 +1807,42 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \n \t      /* Now deal with the loop reversal logic:  This only works on\n \t\t ranges and is activated by setting\n-\t\t\t\treverse[n] == GFC_CAN_REVERSE\n+\t\t\t\treverse[n] == GFC_ENABLE_REVERSE\n \t\t The ability to reverse or not is set by previous conditions\n \t\t in this dimension.  If reversal is not activated, the\n \t\t value GFC_DEP_BACKWARD is reset to GFC_DEP_OVERLAP.  */\n \t      if (rref->u.ar.dimen_type[n] == DIMEN_RANGE\n \t\t    && lref->u.ar.dimen_type[n] == DIMEN_RANGE)\n \t\t{\n \t\t  /* Set reverse if backward dependence and not inhibited.  */\n-\t\t  if (reverse && reverse[n] != GFC_CANNOT_REVERSE)\n+\t\t  if (reverse && reverse[n] == GFC_ENABLE_REVERSE)\n \t\t    reverse[n] = (this_dep == GFC_DEP_BACKWARD) ?\n \t\t\t         GFC_REVERSE_SET : reverse[n];\n \n-\t\t  /* Inhibit loop reversal if dependence not compatible.  */\n-\t\t  if (reverse && reverse[n] != GFC_REVERSE_NOT_SET\n-\t\t        && this_dep != GFC_DEP_EQUAL\n-\t\t        && this_dep != GFC_DEP_BACKWARD\n-\t\t        && this_dep != GFC_DEP_NODEP)\n+\t\t  /* Set forward if forward dependence and not inhibited.  */\n+\t\t  if (reverse && reverse[n] == GFC_ENABLE_REVERSE)\n+\t\t    reverse[n] = (this_dep == GFC_DEP_FORWARD) ?\n+\t\t\t         GFC_FORWARD_SET : reverse[n];\n+\n+\t\t  /* Flag up overlap if dependence not compatible with\n+\t\t     the overall state of the expression.  */\n+\t\t  if (reverse && reverse[n] == GFC_REVERSE_SET\n+\t\t        && this_dep == GFC_DEP_FORWARD)\n+\t\t    {\n+\t              reverse[n] = GFC_INHIBIT_REVERSE;\n+\t\t      this_dep = GFC_DEP_OVERLAP;\n+\t\t    }\n+\t\t  else if (reverse && reverse[n] == GFC_FORWARD_SET\n+\t\t        && this_dep == GFC_DEP_BACKWARD)\n \t\t    {\n-\t              reverse[n] = GFC_CANNOT_REVERSE;\n-\t\t      if (this_dep != GFC_DEP_FORWARD)\n-\t\t\tthis_dep = GFC_DEP_OVERLAP;\n+\t              reverse[n] = GFC_INHIBIT_REVERSE;\n+\t\t      this_dep = GFC_DEP_OVERLAP;\n \t\t    }\n \n \t\t  /* If no intention of reversing or reversing is explicitly\n \t\t     inhibited, convert backward dependence to overlap.  */\n-\t\t  if (this_dep == GFC_DEP_BACKWARD\n-\t\t      && (reverse == NULL || reverse[n] == GFC_CANNOT_REVERSE))\n+\t\t  if ((reverse == NULL && this_dep == GFC_DEP_BACKWARD)\n+\t\t      || (reverse != NULL && reverse[n] == GFC_INHIBIT_REVERSE))\n \t\t    this_dep = GFC_DEP_OVERLAP;\n \t\t}\n "}, {"sha": "6d9eb88a116c1c0e6e873d265c0b552eef3bfe25", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aed5574e7b576594b71bbda5c822c667055b791c/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aed5574e7b576594b71bbda5c822c667055b791c/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=aed5574e7b576594b71bbda5c822c667055b791c", "patch": "@@ -578,10 +578,10 @@ gfc_fcoarray;\n \n typedef enum\n {\n-  GFC_REVERSE_NOT_SET,\n+  GFC_ENABLE_REVERSE,\n+  GFC_FORWARD_SET,\n   GFC_REVERSE_SET,\n-  GFC_CAN_REVERSE,\n-  GFC_CANNOT_REVERSE\n+  GFC_INHIBIT_REVERSE\n }\n gfc_reverse;\n "}, {"sha": "b2992f0233dde857044f5177f6ff3f4accc37187", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aed5574e7b576594b71bbda5c822c667055b791c/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aed5574e7b576594b71bbda5c822c667055b791c/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=aed5574e7b576594b71bbda5c822c667055b791c", "patch": "@@ -2244,7 +2244,7 @@ gfc_init_loopinfo (gfc_loopinfo * loop)\n   for (n = 0; n < GFC_MAX_DIMENSIONS; n++)\n     {\n       loop->order[n] = n;\n-      loop->reverse[n] = GFC_CANNOT_REVERSE;\n+      loop->reverse[n] = GFC_INHIBIT_REVERSE;\n     }\n \n   loop->ss = gfc_ss_terminator;"}, {"sha": "bfe966f3f955c230a687eb9bcea275b2c69d5e09", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aed5574e7b576594b71bbda5c822c667055b791c/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aed5574e7b576594b71bbda5c822c667055b791c/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=aed5574e7b576594b71bbda5c822c667055b791c", "patch": "@@ -6069,8 +6069,8 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n       /* Calculate the bounds of the scalarization.  */\n       gfc_conv_ss_startstride (&loop);\n       /* Enable loop reversal.  */\n-      for (n = 0; n < loop.dimen; n++)\n-\tloop.reverse[n] = GFC_REVERSE_NOT_SET;\n+      for (n = 0; n < GFC_MAX_DIMENSIONS; n++)\n+\tloop.reverse[n] = GFC_ENABLE_REVERSE;\n       /* Resolve any data dependencies in the statement.  */\n       gfc_conv_resolve_dependencies (&loop, lss, rss);\n       /* Setup the scalarizing loops.  */"}, {"sha": "4805e9d27d0fb0e554a9984fe43c500ac38f44a3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aed5574e7b576594b71bbda5c822c667055b791c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aed5574e7b576594b71bbda5c822c667055b791c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aed5574e7b576594b71bbda5c822c667055b791c", "patch": "@@ -1,3 +1,8 @@\n+2011-05-26  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/48955\n+\t* gfortran.dg/dependency_40.f90 : New test.\n+\n 2011-05-26  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/18918"}, {"sha": "b7bd4f91184bed08eb10f480417fc567683fc766", "filename": "gcc/testsuite/gfortran.dg/dependency_40.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aed5574e7b576594b71bbda5c822c667055b791c/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_40.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aed5574e7b576594b71bbda5c822c667055b791c/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_40.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_40.f90?ref=aed5574e7b576594b71bbda5c822c667055b791c", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+! PR 48955 - missing array temporary when there was both a forward\n+! and a backward dependency.\n+! Test case slightly modified from the original one by Kacper Kowalik.\n+program ala\n+   implicit none\n+\n+   integer, parameter  :: n = 6\n+   real, dimension(n), parameter :: result = [1.,10.,30.,90.,270., 243.];\n+   real, dimension(n) :: v0, v1\n+   character(len=80) :: line1, line2\n+\n+   v0 = [1.0, 3.0, 9.0, 27.0, 81.0, 243.0]\n+   v1 = v0\n+\n+   v1(2:n-1) = v1(1:n-2) + v1(3:n)\n+   if (any(v1 /= result)) call abort\n+   v1 = v0\n+   v1(2:n-1) = v0(1:n-2) + v0(3:n)\n+   if (any(v1 /= result)) call abort\n+\n+   v1 = v0\n+   v1(2:n-1) = v1(3:n) + v1(1:n-2)\n+   if (any(v1 /= result)) call abort\n+   v1 = v0\n+   v1(2:n-1) = v0(3:n) + v0(1:n-2)\n+   if (any(v1 /= result)) call abort\n+\n+end program ala"}]}