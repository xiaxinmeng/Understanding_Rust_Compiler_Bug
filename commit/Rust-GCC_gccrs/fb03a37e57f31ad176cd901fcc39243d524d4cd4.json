{"sha": "fb03a37e57f31ad176cd901fcc39243d524d4cd4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmIwM2EzN2U1N2YzMWFkMTc2Y2Q5MDFmY2MzOTI0M2Q1MjRkNGNkNA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2011-05-29T18:41:00Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2011-05-29T18:41:00Z"}, "message": "re PR fortran/45786 (Relational operators .eq. and == are not recognized as equivalent)\n\n2011-05-29  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/45786\n\t* interface.c (gfc_equivalent_op):  New function.\n\t(gfc_check_interface):  Use gfc_equivalent_op instead\n\tof switch statement.\n\t* decl.c (access_attr_decl):  Also set access to an\n\tequivalent operator.\n\n2011-05-29  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/45786\n\t* gfortran.dg/operator_7.f90:  New test case.\n\nFrom-SVN: r174412", "tree": {"sha": "5226f832c787830f57624fc0a90fe130920aef55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5226f832c787830f57624fc0a90fe130920aef55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb03a37e57f31ad176cd901fcc39243d524d4cd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb03a37e57f31ad176cd901fcc39243d524d4cd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb03a37e57f31ad176cd901fcc39243d524d4cd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb03a37e57f31ad176cd901fcc39243d524d4cd4/comments", "author": null, "committer": null, "parents": [{"sha": "427180d243e562912cc37f09b140a4d8c042ae4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/427180d243e562912cc37f09b140a4d8c042ae4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/427180d243e562912cc37f09b140a4d8c042ae4c"}], "stats": {"total": 161, "additions": 96, "deletions": 65}, "files": [{"sha": "e97168fbad2ccec1f156f3ce5404a3d230bad25f", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb03a37e57f31ad176cd901fcc39243d524d4cd4/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb03a37e57f31ad176cd901fcc39243d524d4cd4/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=fb03a37e57f31ad176cd901fcc39243d524d4cd4", "patch": "@@ -6478,8 +6478,19 @@ access_attr_decl (gfc_statement st)\n \tcase INTERFACE_INTRINSIC_OP:\n \t  if (gfc_current_ns->operator_access[op] == ACCESS_UNKNOWN)\n \t    {\n+\t      gfc_intrinsic_op other_op;\n+\n \t      gfc_current_ns->operator_access[op] =\n \t\t(st == ST_PUBLIC) ? ACCESS_PUBLIC : ACCESS_PRIVATE;\n+\n+\t      /* Handle the case if there is another op with the same\n+\t\t function, for INTRINSIC_EQ vs. INTRINSIC_EQ_OS and so on.  */\n+\t      other_op = gfc_equivalent_op (op);\n+\n+\t      if (other_op != INTRINSIC_NONE)\n+\t\tgfc_current_ns->operator_access[other_op] =\n+\t\t  (st == ST_PUBLIC) ? ACCESS_PUBLIC : ACCESS_PRIVATE;\n+\n \t    }\n \t  else\n \t    {"}, {"sha": "72e412b3b9f4b4c4f933e0b8ebda3db3ea84de16", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb03a37e57f31ad176cd901fcc39243d524d4cd4/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb03a37e57f31ad176cd901fcc39243d524d4cd4/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=fb03a37e57f31ad176cd901fcc39243d524d4cd4", "patch": "@@ -2816,6 +2816,7 @@ gfc_symtree* gfc_find_sym_in_symtree (gfc_symbol*);\n bool gfc_arglist_matches_symbol (gfc_actual_arglist**, gfc_symbol*);\n bool gfc_check_operator_interface (gfc_symbol*, gfc_intrinsic_op, locus);\n int gfc_has_vector_subscript (gfc_expr*);\n+gfc_intrinsic_op gfc_equivalent_op (gfc_intrinsic_op);\n \n /* io.c */\n extern gfc_st_label format_asterisk;"}, {"sha": "46f9d146ce74e0d18013c3752ac4368dd65d0e13", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 57, "deletions": 65, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb03a37e57f31ad176cd901fcc39243d524d4cd4/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb03a37e57f31ad176cd901fcc39243d524d4cd4/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=fb03a37e57f31ad176cd901fcc39243d524d4cd4", "patch": "@@ -1264,6 +1264,54 @@ check_uop_interfaces (gfc_user_op *uop)\n     }\n }\n \n+/* Given an intrinsic op, return an equivalent op if one exists,\n+   or INTRINSIC_NONE otherwise.  */\n+\n+gfc_intrinsic_op\n+gfc_equivalent_op (gfc_intrinsic_op op)\n+{\n+  switch(op)\n+    {\n+    case INTRINSIC_EQ:\n+      return INTRINSIC_EQ_OS;\n+\n+    case INTRINSIC_EQ_OS:\n+      return INTRINSIC_EQ;\n+\n+    case INTRINSIC_NE:\n+      return INTRINSIC_NE_OS;\n+\n+    case INTRINSIC_NE_OS:\n+      return INTRINSIC_NE;\n+\n+    case INTRINSIC_GT:\n+      return INTRINSIC_GT_OS;\n+\n+    case INTRINSIC_GT_OS:\n+      return INTRINSIC_GT;\n+\n+    case INTRINSIC_GE:\n+      return INTRINSIC_GE_OS;\n+\n+    case INTRINSIC_GE_OS:\n+      return INTRINSIC_GE;\n+\n+    case INTRINSIC_LT:\n+      return INTRINSIC_LT_OS;\n+\n+    case INTRINSIC_LT_OS:\n+      return INTRINSIC_LT;\n+\n+    case INTRINSIC_LE:\n+      return INTRINSIC_LE_OS;\n+\n+    case INTRINSIC_LE_OS:\n+      return INTRINSIC_LE;\n+\n+    default:\n+      return INTRINSIC_NONE;\n+    }\n+}\n \n /* For the namespace, check generic, user operator and intrinsic\n    operator interfaces for consistency and to remove duplicate\n@@ -1304,75 +1352,19 @@ gfc_check_interfaces (gfc_namespace *ns)\n \n       for (ns2 = ns; ns2; ns2 = ns2->parent)\n \t{\n+\t  gfc_intrinsic_op other_op;\n+\t  \n \t  if (check_interface1 (ns->op[i], ns2->op[i], 0,\n \t\t\t\tinterface_name, true))\n \t    goto done;\n \n-\t  switch (i)\n-\t    {\n-\t      case INTRINSIC_EQ:\n-\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_EQ_OS],\n-\t\t\t\t      0, interface_name, true)) goto done;\n-\t\tbreak;\n-\n-\t      case INTRINSIC_EQ_OS:\n-\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_EQ],\n-\t\t\t\t      0, interface_name, true)) goto done;\n-\t\tbreak;\n-\n-\t      case INTRINSIC_NE:\n-\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_NE_OS],\n-\t\t\t\t      0, interface_name, true)) goto done;\n-\t\tbreak;\n-\n-\t      case INTRINSIC_NE_OS:\n-\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_NE],\n-\t\t\t\t      0, interface_name, true)) goto done;\n-\t\tbreak;\n-\n-\t      case INTRINSIC_GT:\n-\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_GT_OS],\n-\t\t\t\t      0, interface_name, true)) goto done;\n-\t\tbreak;\n-\n-\t      case INTRINSIC_GT_OS:\n-\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_GT],\n-\t\t\t\t      0, interface_name, true)) goto done;\n-\t\tbreak;\n-\n-\t      case INTRINSIC_GE:\n-\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_GE_OS],\n-\t\t\t\t      0, interface_name, true)) goto done;\n-\t\tbreak;\n-\n-\t      case INTRINSIC_GE_OS:\n-\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_GE],\n-\t\t\t\t      0, interface_name, true)) goto done;\n-\t\tbreak;\n-\n-\t      case INTRINSIC_LT:\n-\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_LT_OS],\n-\t\t\t\t      0, interface_name, true)) goto done;\n-\t\tbreak;\n-\n-\t      case INTRINSIC_LT_OS:\n-\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_LT],\n-\t\t\t\t      0, interface_name, true)) goto done;\n-\t\tbreak;\n-\n-\t      case INTRINSIC_LE:\n-\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_LE_OS],\n-\t\t\t\t      0, interface_name, true)) goto done;\n-\t\tbreak;\n-\n-\t      case INTRINSIC_LE_OS:\n-\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_LE],\n-\t\t\t\t      0, interface_name, true)) goto done;\n-\t\tbreak;\n-\n-\t      default:\n-\t\tbreak;\n-            }\n+\t  /* i should be gfc_intrinsic_op, but has to be int with this cast\n+\t     here for stupid C++ compatibility rules.  */\n+\t  other_op = gfc_equivalent_op ((gfc_intrinsic_op) i);\n+\t  if (other_op != INTRINSIC_NONE\n+\t    &&  check_interface1 (ns->op[i], ns2->op[other_op],\n+\t\t\t\t  0, interface_name, true))\n+\t    goto done;\n \t}\n     }\n "}, {"sha": "66d8dd187eecdee4818790e0d77fcfb315a5c70d", "filename": "gcc/testsuite/gfortran.dg/operator_7.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb03a37e57f31ad176cd901fcc39243d524d4cd4/gcc%2Ftestsuite%2Fgfortran.dg%2Foperator_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb03a37e57f31ad176cd901fcc39243d524d4cd4/gcc%2Ftestsuite%2Fgfortran.dg%2Foperator_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Foperator_7.f90?ref=fb03a37e57f31ad176cd901fcc39243d524d4cd4", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do compile }\n+! PR fortran/45786 - operators were not correctly marked as public\n+! if the alternative form was used.\n+! Test case contributed by Neil Carlson.\n+module foo_type\n+  private\n+  public :: foo, operator(==)\n+  type :: foo\n+    integer :: bar\n+  end type\n+  interface operator(.eq.)\n+    module procedure eq_foo\n+  end interface\n+contains\n+  logical function eq_foo (a, b)\n+    type(foo), intent(in) :: a, b\n+    eq_foo = (a%bar == b%bar)\n+  end function\n+end module\n+\n+ subroutine use_it (a, b)\n+  use foo_type\n+  type(foo) :: a, b\n+  print *, a == b\n+end subroutine\n+\n+! { dg-final { cleanup-modules \"foo_type\" } }"}]}