{"sha": "0c53708eadd727f4089028e09840865db25a3cd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM1MzcwOGVhZGQ3MjdmNDA4OTAyOGUwOTg0MDg2NWRiMjVhM2NkOQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2011-07-21T12:00:25Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-07-21T12:00:25Z"}, "message": "check.c (gfc_check_present): Allow coarrays.\n\n2011-07-21  Tobias Burnus  <burnus@net-b.de>\n\n        * check.c (gfc_check_present): Allow coarrays.\n        * trans-array.c (gfc_conv_array_ref): Avoid casting\n        when a pointer is wanted.\n        * trans-decl.c (create_function_arglist): For -fcoarray=lib,\n        handle hidden token and offset arguments for nondescriptor\n        coarrays.\n        * trans-expr.c (get_tree_for_caf_expr): New function.\n        (gfc_conv_procedure_call): For -fcoarray=lib pass the\n        token and offset for nondescriptor coarray dummies.\n        * trans.h (lang_type): Add caf_offset tree.\n        (GFC_TYPE_ARRAY_CAF_OFFSET): New macro.\n\n2011-07-21  Tobias Burnus  <burnus@net-b.de>\n\n        * gfortran.dg/coarray_lib_token_1.f90: New.\n\nFrom-SVN: r176562", "tree": {"sha": "90e38bf99a56bacbccf1b030246599e15eccdf02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90e38bf99a56bacbccf1b030246599e15eccdf02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c53708eadd727f4089028e09840865db25a3cd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c53708eadd727f4089028e09840865db25a3cd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c53708eadd727f4089028e09840865db25a3cd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c53708eadd727f4089028e09840865db25a3cd9/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "91bc61122f0f6781805aab89e21f674b218c72c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91bc61122f0f6781805aab89e21f674b218c72c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91bc61122f0f6781805aab89e21f674b218c72c9"}], "stats": {"total": 242, "additions": 238, "deletions": 4}, "files": [{"sha": "1e9bb56b4d67a18e59ffc06a0d06966295ecd9d4", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c53708eadd727f4089028e09840865db25a3cd9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c53708eadd727f4089028e09840865db25a3cd9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0c53708eadd727f4089028e09840865db25a3cd9", "patch": "@@ -1,3 +1,17 @@\n+2011-07-21  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* check.c (gfc_check_present): Allow coarrays.\n+\t* trans-array.c (gfc_conv_array_ref): Avoid casting\n+\twhen a pointer is wanted.\n+\t* trans-decl.c (create_function_arglist): For -fcoarray=lib,\n+\thandle hidden token and offset arguments for nondescriptor\n+\tcoarrays.\n+\t* trans-expr.c (get_tree_for_caf_expr): New function.\n+\t(gfc_conv_procedure_call): For -fcoarray=lib pass the\n+\ttoken and offset for nondescriptor coarray dummies.\n+\t* trans.h (lang_type): Add caf_offset tree.\n+\t(GFC_TYPE_ARRAY_CAF_OFFSET): New macro.\n+\n 2011-07-19  Tobias Burnus  <burnus@net-b.de>\n \n \t* expr.c (gfc_is_coarray): New function."}, {"sha": "a95865b9bc65f2e5fb7343e2ed5b4d7c918bcc0d", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c53708eadd727f4089028e09840865db25a3cd9/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c53708eadd727f4089028e09840865db25a3cd9/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=0c53708eadd727f4089028e09840865db25a3cd9", "patch": "@@ -2895,7 +2895,9 @@ gfc_check_present (gfc_expr *a)\n \n   if (a->ref != NULL\n       && !(a->ref->next == NULL && a->ref->type == REF_ARRAY\n-\t   && a->ref->u.ar.type == AR_FULL))\n+\t   && (a->ref->u.ar.type == AR_FULL\n+\t       || (a->ref->u.ar.type == AR_ELEMENT\n+\t\t   && a->ref->u.ar.as->rank == 0))))\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must not be a \"\n \t\t \"subobject of '%s'\", gfc_current_intrinsic_arg[0]->name,"}, {"sha": "9caa17fad0476dfe5b90695887c0353402364acf", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c53708eadd727f4089028e09840865db25a3cd9/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c53708eadd727f4089028e09840865db25a3cd9/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=0c53708eadd727f4089028e09840865db25a3cd9", "patch": "@@ -2631,10 +2631,11 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n \t  if (GFC_ARRAY_TYPE_P (TREE_TYPE (se->expr))\n \t      && TREE_CODE (TREE_TYPE (se->expr)) == POINTER_TYPE)\n \t    se->expr = build_fold_indirect_ref_loc (input_location, se->expr);\n-\t\n+\n \t  /* Use the actual tree type and not the wrapped coarray. */\n-\t  se->expr = fold_convert (TYPE_MAIN_VARIANT (TREE_TYPE (se->expr)),\n-\t\t\t\t   se->expr);\n+\t  if (!se->want_pointer)\n+\t    se->expr = fold_convert (TYPE_MAIN_VARIANT (TREE_TYPE (se->expr)),\n+\t\t\t\t     se->expr);\n \t}\n \n       return;"}, {"sha": "12c5262218dc0c8f2da6794f476062e48f32e125", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c53708eadd727f4089028e09840865db25a3cd9/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c53708eadd727f4089028e09840865db25a3cd9/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=0c53708eadd727f4089028e09840865db25a3cd9", "patch": "@@ -2104,6 +2104,48 @@ create_function_arglist (gfc_symbol * sym)\n \n       f->sym->backend_decl = parm;\n \n+      /* Coarrays which do not use a descriptor pass with -fcoarray=lib the\n+\t token and the offset as hidden arguments.  */\n+      if (f->sym->attr.codimension\n+\t  && gfc_option.coarray == GFC_FCOARRAY_LIB\n+\t  && !f->sym->attr.allocatable\n+\t  && f->sym->as->type != AS_ASSUMED_SHAPE)\n+\t{\n+\t  tree caf_type;\n+\t  tree token;\n+\t  tree offset;\n+\n+\t  gcc_assert (f->sym->backend_decl != NULL_TREE\n+\t\t      && !sym->attr.is_bind_c);\n+\t  caf_type = TREE_TYPE (f->sym->backend_decl);\n+\n+\t  gcc_assert (GFC_TYPE_ARRAY_CAF_TOKEN (caf_type) == NULL_TREE);\n+\t  token = build_decl (input_location, PARM_DECL,\n+\t\t\t      create_tmp_var_name (\"caf_token\"),\n+\t\t\t      build_qualified_type (pvoid_type_node,\n+\t\t\t\t\t\t    TYPE_QUAL_RESTRICT));\n+\t  GFC_TYPE_ARRAY_CAF_TOKEN (caf_type) = token;\n+\t  DECL_CONTEXT (token) = fndecl;\n+\t  DECL_ARTIFICIAL (token) = 1;\n+\t  DECL_ARG_TYPE (token) = TREE_VALUE (typelist);\n+\t  TREE_READONLY (token) = 1;\n+\t  hidden_arglist = chainon (hidden_arglist, token);\n+\t  gfc_finish_decl (token);\n+\n+\t  gcc_assert (GFC_TYPE_ARRAY_CAF_OFFSET (caf_type) == NULL_TREE);\n+\t  offset = build_decl (input_location, PARM_DECL,\n+\t\t\t       create_tmp_var_name (\"caf_offset\"),\n+\t\t\t       gfc_array_index_type);\n+\n+\t  GFC_TYPE_ARRAY_CAF_OFFSET (caf_type) = offset;\n+\t  DECL_CONTEXT (offset) = fndecl;\n+\t  DECL_ARTIFICIAL (offset) = 1;\n+\t  DECL_ARG_TYPE (offset) = TREE_VALUE (typelist);\n+\t  TREE_READONLY (offset) = 1;\n+\t  hidden_arglist = chainon (hidden_arglist, offset);\n+\t  gfc_finish_decl (offset);\n+\t}\n+\n       arglist = chainon (arglist, parm);\n       typelist = TREE_CHAIN (typelist);\n     }"}, {"sha": "762291024360a9f73751502b0a4d3293885b339f", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c53708eadd727f4089028e09840865db25a3cd9/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c53708eadd727f4089028e09840865db25a3cd9/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=0c53708eadd727f4089028e09840865db25a3cd9", "patch": "@@ -261,6 +261,33 @@ gfc_get_expr_charlen (gfc_expr *e)\n }\n \n \n+/* Return for an expression the backend decl of the coarray.  */\n+\n+static tree\n+get_tree_for_caf_expr (gfc_expr *expr)\n+{\n+   tree caf_decl = NULL_TREE;\n+   gfc_ref *ref;\n+\n+   gcc_assert (expr && expr->expr_type == EXPR_VARIABLE);\n+   if (expr->symtree->n.sym->attr.codimension)\n+     caf_decl = expr->symtree->n.sym->backend_decl;\n+\n+   for (ref = expr->ref; ref; ref = ref->next)\n+     if (ref->type == REF_COMPONENT)\n+       {\n+\tgfc_component *comp = ref->u.c.component;\n+        if (comp->attr.pointer || comp->attr.allocatable)\n+\t  caf_decl = NULL_TREE;\n+\tif (comp->attr.codimension)\n+\t  caf_decl = comp->backend_decl;\n+       }\n+\n+   gcc_assert (caf_decl != NULL_TREE);\n+   return caf_decl;\n+}\n+\n+\n /* For each character array constructor subexpression without a ts.u.cl->length,\n    replace it by its first element (if there aren't any elements, the length\n    should already be set to zero).  */\n@@ -2814,6 +2841,7 @@ conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n   return 0;\n }\n \n+\n /* Generate code for a procedure call.  Note can return se->post != NULL.\n    If se->direct_byref is set then se->expr contains the return parameter.\n    Return nonzero, if the call has alternate specifiers.\n@@ -3362,6 +3390,59 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       if (parmse.string_length != NULL_TREE && !sym->attr.is_bind_c)\n \tVEC_safe_push (tree, gc, stringargs, parmse.string_length);\n \n+      /* For descriptorless coarrays, we pass the token and the offset\n+\t as additional arguments.  */\n+      if (fsym && fsym->attr.codimension\n+\t  && gfc_option.coarray == GFC_FCOARRAY_LIB\n+\t  && !fsym->attr.allocatable && fsym->as->type != AS_ASSUMED_SHAPE\n+\t  && (e == NULL\n+\t      || GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (get_tree_for_caf_expr (e)))))\n+\t  /* FIXME: Remove the \"||\" condition when coarray descriptors have a\n+\t     \"token\" component. This condition occurs when passing an alloc\n+\t      coarray or assumed-shape dummy to an explict-shape dummy.  */\n+\t{\n+\t  /* Token and offset. */\n+\t  VEC_safe_push (tree, gc, stringargs, null_pointer_node);\n+\t  VEC_safe_push (tree, gc, stringargs,\n+\t\t\t build_int_cst (gfc_array_index_type, 0));\n+\t  gcc_assert (fsym->attr.optional || e != NULL); /* FIXME: \"||\" cond.  */\n+\t}\n+      else if (fsym && fsym->attr.codimension\n+\t       && !fsym->attr.allocatable && fsym->as->type != AS_ASSUMED_SHAPE\n+\t       && gfc_option.coarray == GFC_FCOARRAY_LIB)\n+\t{\n+\t  tree caf_decl, caf_type;\n+\t  tree offset;\n+\n+          caf_decl = get_tree_for_caf_expr (e);\n+\t  caf_type = TREE_TYPE (caf_decl);\n+\n+\t  gcc_assert (GFC_ARRAY_TYPE_P (caf_type)\n+\t\t      && GFC_TYPE_ARRAY_CAF_TOKEN (caf_type) != NULL_TREE);\n+\t  \n+\t  VEC_safe_push (tree, gc, stringargs,\n+\t\t\t GFC_TYPE_ARRAY_CAF_TOKEN (caf_type));\n+\n+\t  if (GFC_TYPE_ARRAY_CAF_OFFSET (caf_type) != NULL_TREE)\n+\t    offset = GFC_TYPE_ARRAY_CAF_OFFSET (caf_type);\n+\t  else\n+\t    offset = build_int_cst (gfc_array_index_type, 0);\n+\n+\t  gcc_assert (POINTER_TYPE_P (TREE_TYPE (caf_decl))\n+\t\t      && POINTER_TYPE_P (TREE_TYPE (parmse.expr)));\n+\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+                                 gfc_array_index_type,\n+                                 fold_convert (gfc_array_index_type,\n+\t\t\t\t\t       parmse.expr),\n+                                 fold_convert (gfc_array_index_type,\n+\t\t\t\t\t       caf_decl));\n+\t  offset = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t    gfc_array_index_type, offset, tmp);\n+\n+\t  VEC_safe_push (tree, gc, stringargs, offset);\n+\t}\n+\n       VEC_safe_push (tree, gc, arglist, parmse.expr);\n     }\n   gfc_finish_interface_mapping (&mapping, &se->pre, &se->post);"}, {"sha": "48e054f2342b2d2b3a539d0d1d7ddc268413660d", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c53708eadd727f4089028e09840865db25a3cd9/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c53708eadd727f4089028e09840865db25a3cd9/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=0c53708eadd727f4089028e09840865db25a3cd9", "patch": "@@ -736,6 +736,7 @@ struct GTY((variable_size))\tlang_type\t {\n   tree base_decl[2];\n   tree nonrestricted_type;\n   tree caf_token;\n+  tree caf_offset;\n };\n \n struct GTY((variable_size)) lang_decl {\n@@ -781,6 +782,7 @@ struct GTY((variable_size)) lang_decl {\n #define GFC_TYPE_ARRAY_RANK(node) (TYPE_LANG_SPECIFIC(node)->rank)\n #define GFC_TYPE_ARRAY_CORANK(node) (TYPE_LANG_SPECIFIC(node)->corank)\n #define GFC_TYPE_ARRAY_CAF_TOKEN(node) (TYPE_LANG_SPECIFIC(node)->caf_token)\n+#define GFC_TYPE_ARRAY_CAF_OFFSET(node) (TYPE_LANG_SPECIFIC(node)->caf_offset)\n #define GFC_TYPE_ARRAY_SIZE(node) (TYPE_LANG_SPECIFIC(node)->size)\n #define GFC_TYPE_ARRAY_OFFSET(node) (TYPE_LANG_SPECIFIC(node)->offset)\n #define GFC_TYPE_ARRAY_AKIND(node) (TYPE_LANG_SPECIFIC(node)->akind)"}, {"sha": "d0df27b541343c9f1720cca94b1c61286d13939a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c53708eadd727f4089028e09840865db25a3cd9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c53708eadd727f4089028e09840865db25a3cd9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0c53708eadd727f4089028e09840865db25a3cd9", "patch": "@@ -1,3 +1,7 @@\n+2011-07-21  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.dg/coarray_lib_token_1.f90: New.\n+\n 2011-07-21  Georg-Johann Lay  <avr@gjlay.de>\n \t\n \t* gcc.dg/pr32912-2.c: Skip for AVR."}, {"sha": "648a6a337a9c4b5f810cfb50069612af869dc6a7", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_token_1.f90", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c53708eadd727f4089028e09840865db25a3cd9/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_token_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c53708eadd727f4089028e09840865db25a3cd9/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_token_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_token_1.f90?ref=0c53708eadd727f4089028e09840865db25a3cd9", "patch": "@@ -0,0 +1,88 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=lib -fdump-tree-original\" }\n+!\n+! Check whether TOKEN and OFFSET are correctly propagated\n+! \n+\n+program main\n+  implicit none\n+  type t\n+    integer(4) :: a, b\n+  end type t\n+  integer :: caf[*]\n+  type(t) :: caf_dt[*]\n+\n+  caf = 42\n+  caf_dt = t (1,2)\n+  call sub (caf, caf_dt%b)\n+  print *,caf, caf_dt%b\n+  if (caf /= -99 .or. caf_dt%b /= -101) call abort ()\n+  call sub_opt ()\n+  call sub_opt (caf)\n+  if (caf /= 124) call abort ()\n+contains\n+\n+  subroutine sub (x1, x2)\n+    integer :: x1[*], x2[*]\n+\n+    call sub2 (x1, x2)\n+  end subroutine sub\n+\n+  subroutine sub2 (y1, y2)\n+    integer :: y1[*], y2[*]\n+\n+    print *, y1, y2\n+    if (y1 /= 42 .or. y2 /= 2) call abort ()\n+    y1 = -99\n+    y2 = -101\n+  end subroutine sub2\n+\n+  subroutine sub_opt (z)\n+    integer, optional :: z[*]\n+    if (present (z)) then\n+      if (z /= -99) call abort ()\n+      z = 124\n+    end if\n+  end subroutine sub_opt\n+\n+end program main\n+\n+! SCAN TREE DUMP AND CLEANUP\n+!\n+! PROTOTYPE 1:\n+!\n+! sub (integer(kind=4) * restrict x1, integer(kind=4) * restrict x2,\n+!      void * restrict caf_token.4, integer(kind=8) caf_offset.5,\n+!      void * restrict caf_token.6, integer(kind=8) caf_offset.7)\n+!\n+! { dg-final { scan-tree-dump-times \"sub \\\\(integer.kind=4. . restrict x1, integer.kind=4. . restrict x2, void . restrict caf_token.\\[0-9\\]+, integer.kind=.. caf_offset.\\[0-9\\]+, void . restrict caf_token.\\[0-9\\]+, integer.kind=.. caf_offset.\\[0-9\\]+\\\\)\" 1 \"original\"} }\n+!\n+! PROTOTYPE 2:\n+!\n+! sub2 (integer(kind=4) * restrict y1, integer(kind=4) * restrict y2,\n+!       void * restrict caf_token.0, integer(kind=8) caf_offset.1,\n+!       void * restrict caf_token.2, integer(kind=8) caf_offset.3)\n+!\n+! { dg-final { scan-tree-dump-times \"sub2 \\\\(integer.kind=4. . restrict y1, integer.kind=4. . restrict y2, void . restrict caf_token.\\[0-9\\]+, integer.kind=.. caf_offset.\\[0-9\\]+, void . restrict caf_token.\\[0-9\\]+, integer.kind=.. caf_offset.\\[0-9\\]+\\\\)\" 1 \"original\"} }\n+!\n+! CALL 1\n+!\n+!  sub ((integer(kind=4) *) caf, &caf_dt->b, caf_token.9, 0, caf_token.10, 4);\n+!\n+! { dg-final { scan-tree-dump-times \"sub \\\\(\\[^,\\]*caf, &caf_dt->b, caf_token.\\[0-9\\]+, 0, caf_token.\\[0-9\\]+, 4\\\\)\" 1 \"original\"} }\n+!\n+!  sub2 ((integer(kind=4) *) x1, (integer(kind=4) *) x2,\n+!        caf_token.4, NON_LVALUE_EXPR <caf_offset.5>,\n+!        caf_token.6, NON_LVALUE_EXPR <caf_offset.7>);\n+!\n+! { dg-final { scan-tree-dump-times \"sub2 \\\\(\\[^,\\]*x1, \\[^,\\]*x2, caf_token.\\[0-9]+, \\[^,\\]*caf_offset\\[^,\\]*, caf_token.\\[0-9\\]+, \\[^,\\]*caf_offset\\[^,\\]*\\\\)\" 1 \"original\"} }\n+!\n+! CALL 3\n+!\n+! { dg-final { scan-tree-dump-times \"sub_opt \\\\(0B, 0B, 0\\\\)\" 1 \"original\"} }\n+!\n+! CALL 4\n+!\n+! { dg-final { scan-tree-dump-times \"sub_opt \\\\(.integer.kind=4. .. caf, caf_token.\\[0-9\\]+, 0\\\\)\" 1 \"original\"} }\n+!\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}