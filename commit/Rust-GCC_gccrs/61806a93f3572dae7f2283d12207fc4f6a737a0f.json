{"sha": "61806a93f3572dae7f2283d12207fc4f6a737a0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE4MDZhOTNmMzU3MmRhZTdmMjI4M2QxMjIwN2ZjNGY2YTczN2EwZg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2012-06-22T01:34:05Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2012-06-22T01:34:05Z"}, "message": "re PR debug/53671 (Many guality test failures)\n\nPR debug/53671\nPR debug/49888\n* var-tracking.c (vt_get_canonicalize_base): New.\n(vt_canonicalize_addr, vt_stack_offset_p): New.\n(vt_canon_true_dep): New.\n(drop_overlapping_mem_locs): Use vt_canon_true_dep.\n(clobber_overlaping_mems): Use vt_canonicalize_addr.\n\nFrom-SVN: r188871", "tree": {"sha": "374a8e5c51e82603c86832f6b1ec9b32a5b6c020", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/374a8e5c51e82603c86832f6b1ec9b32a5b6c020"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61806a93f3572dae7f2283d12207fc4f6a737a0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61806a93f3572dae7f2283d12207fc4f6a737a0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61806a93f3572dae7f2283d12207fc4f6a737a0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61806a93f3572dae7f2283d12207fc4f6a737a0f/comments", "author": null, "committer": null, "parents": [{"sha": "48b00503b168518ebbf5bc54525b0c1157321501", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48b00503b168518ebbf5bc54525b0c1157321501", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48b00503b168518ebbf5bc54525b0c1157321501"}], "stats": {"total": 158, "additions": 151, "deletions": 7}, "files": [{"sha": "5ae0db9f76d4f9c47fc78384d551353079729707", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61806a93f3572dae7f2283d12207fc4f6a737a0f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61806a93f3572dae7f2283d12207fc4f6a737a0f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61806a93f3572dae7f2283d12207fc4f6a737a0f", "patch": "@@ -1,3 +1,13 @@\n+2012-06-21  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/53671\n+\tPR debug/49888\n+\t* var-tracking.c (vt_get_canonicalize_base): New.\n+\t(vt_canonicalize_addr, vt_stack_offset_p): New.\n+\t(vt_canon_true_dep): New.\n+\t(drop_overlapping_mem_locs): Use vt_canon_true_dep.\n+\t(clobber_overlaping_mems): Use vt_canonicalize_addr.\n+\n 2012-06-21  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR debug/53671"}, {"sha": "419269f945a8cf02dd48dad07c70aa5fc2474596", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 141, "deletions": 7, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61806a93f3572dae7f2283d12207fc4f6a737a0f/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61806a93f3572dae7f2283d12207fc4f6a737a0f/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=61806a93f3572dae7f2283d12207fc4f6a737a0f", "patch": "@@ -1955,6 +1955,144 @@ var_regno_delete (dataflow_set *set, int regno)\n   *reg = NULL;\n }\n \n+/* Strip constant offsets and alignments off of LOC.  Return the base\n+   expression.  */\n+\n+static rtx\n+vt_get_canonicalize_base (rtx loc)\n+{\n+  while ((GET_CODE (loc) == PLUS\n+\t  || GET_CODE (loc) == AND)\n+\t && GET_CODE (XEXP (loc, 1)) == CONST_INT\n+\t && (GET_CODE (loc) != AND\n+\t     || INTVAL (XEXP (loc, 1)) < 0))\n+    loc = XEXP (loc, 0);\n+\n+  return loc;\n+}\n+\n+/* Canonicalize LOC using equivalences from SET in addition to those\n+   in the cselib static table.  */\n+\n+static rtx\n+vt_canonicalize_addr (dataflow_set *set, rtx oloc)\n+{\n+  HOST_WIDE_INT ofst = 0;\n+  enum machine_mode mode = GET_MODE (oloc);\n+  rtx loc = canon_rtx (get_addr (oloc));\n+\n+  /* Try to substitute a base VALUE for equivalent expressions as much\n+     as possible.  The goal here is to expand stack-related addresses\n+     to one of the stack base registers, so that we can compare\n+     addresses for overlaps.  */\n+  while (GET_CODE (vt_get_canonicalize_base (loc)) == VALUE)\n+    {\n+      rtx x;\n+      decl_or_value dv;\n+      variable var;\n+      location_chain l;\n+\n+      while (GET_CODE (loc) == PLUS)\n+\t{\n+\t  ofst += INTVAL (XEXP (loc, 1));\n+\t  loc = XEXP (loc, 0);\n+\t  continue;\n+\t}\n+\n+      /* Alignment operations can't normally be combined, so just\n+\t canonicalize the base and we're done.  We'll normally have\n+\t only one stack alignment anyway.  */\n+      if (GET_CODE (loc) == AND)\n+\t{\n+\t  x = vt_canonicalize_addr (set, XEXP (loc, 0));\n+\t  if (x != XEXP (loc, 0))\n+\t    loc = gen_rtx_AND (mode, x, XEXP (loc, 1));\n+\t  loc = canon_rtx (get_addr (loc));\n+\t  break;\n+\t}\n+\n+      x = canon_rtx (get_addr (loc));\n+\n+      /* We've made progress!  Start over.  */\n+      if (x != loc || GET_CODE (x) != VALUE)\n+\t{\n+\t  loc = x;\n+\t  continue;\n+\t}\n+\n+      dv = dv_from_rtx (x);\n+      var = (variable) htab_find_with_hash (shared_hash_htab (set->vars),\n+\t\t\t\t\t    dv, dv_htab_hash (dv));\n+      if (!var)\n+\tbreak;\n+\n+      /* Look for an improved equivalent expression.  */\n+      for (l = var->var_part[0].loc_chain; l; l = l->next)\n+\t{\n+\t  rtx base = vt_get_canonicalize_base (l->loc);\n+\t  if (GET_CODE (base) == REG\n+\t      || (GET_CODE (base) == VALUE\n+\t\t  && canon_value_cmp (base, loc)))\n+\t    {\n+\t      loc = l->loc;\n+\t      break;\n+\t    }\n+\t}\n+\n+      /* No luck with the dataflow set, so we're done.  */\n+      if (!l)\n+\tbreak;\n+    }\n+\n+  /* Add OFST back in.  */\n+  if (ofst)\n+    {\n+      /* Don't build new RTL if we can help it.  */\n+      if (GET_CODE (oloc) == PLUS\n+\t  && XEXP (oloc, 0) == loc\n+\t  && INTVAL (XEXP (oloc, 1)) == ofst)\n+\treturn oloc;\n+\n+      loc = plus_constant (mode, loc, ofst);\n+    }\n+\n+  return loc;\n+}\n+\n+/* Return true iff ADDR has a stack register as the base address.  */\n+\n+static inline bool\n+vt_stack_offset_p (rtx addr)\n+{\n+  rtx base = vt_get_canonicalize_base (addr);\n+\n+  if (GET_CODE (base) != REG)\n+    return false;\n+\n+  return REGNO_PTR_FRAME_P (REGNO (base));\n+}\n+\n+/* Return true iff there's a true dependence between MLOC and LOC.\n+   MADDR must be a canonicalized version of MLOC's address.  */\n+\n+static inline bool\n+vt_canon_true_dep (dataflow_set *set, rtx mloc, rtx maddr, rtx loc)\n+{\n+  if (GET_CODE (loc) != MEM)\n+    return false;\n+\n+  if (!canon_true_dependence (mloc, GET_MODE (mloc), maddr, loc, NULL))\n+    return false;\n+\n+  if (!MEM_EXPR (loc) && vt_stack_offset_p (maddr))\n+    {\n+      rtx addr = vt_canonicalize_addr (set, XEXP (loc, 0));\n+      return canon_true_dependence (mloc, GET_MODE (mloc), maddr, loc, addr);\n+    }\n+\n+  return true;\n+}\n+\n /* Hold parameters for the hashtab traversal function\n    drop_overlapping_mem_locs, see below.  */\n \n@@ -1988,9 +2126,7 @@ drop_overlapping_mem_locs (void **slot, void *data)\n       if (shared_var_p (var, set->vars))\n \t{\n \t  for (loc = var->var_part[0].loc_chain; loc; loc = loc->next)\n-\t    if (GET_CODE (loc->loc) == MEM\n-\t\t&& canon_true_dependence (mloc, GET_MODE (mloc), addr,\n-\t\t\t\t\t  loc->loc, NULL))\n+\t    if (vt_canon_true_dep (set, mloc, addr, loc->loc))\n \t      break;\n \n \t  if (!loc)\n@@ -2009,9 +2145,7 @@ drop_overlapping_mem_locs (void **slot, void *data)\n       for (locp = &var->var_part[0].loc_chain, loc = *locp;\n \t   loc; loc = *locp)\n \t{\n-\t  if (GET_CODE (loc->loc) != MEM\n-\t      || !canon_true_dependence (mloc, GET_MODE (mloc), addr,\n-\t\t\t\t\t loc->loc, NULL))\n+\t  if (!vt_canon_true_dep (set, mloc, addr, loc->loc))\n \t    {\n \t      locp = &loc->next;\n \t      continue;\n@@ -2052,7 +2186,7 @@ clobber_overlapping_mems (dataflow_set *set, rtx loc)\n \n   coms.set = set;\n   coms.loc = canon_rtx (loc);\n-  coms.addr = canon_rtx (get_addr (XEXP (loc, 0)));\n+  coms.addr = vt_canonicalize_addr (set, XEXP (loc, 0));\n \n   set->traversed_vars = set->vars;\n   htab_traverse (shared_hash_htab (set->vars),"}]}