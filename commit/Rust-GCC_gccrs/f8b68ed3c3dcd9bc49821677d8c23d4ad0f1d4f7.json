{"sha": "f8b68ed3c3dcd9bc49821677d8c23d4ad0f1d4f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhiNjhlZDNjM2RjZDliYzQ5ODIxNjc3ZDhjMjNkNGFkMGYxZDRmNw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2010-03-21T20:27:00Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2010-03-21T20:27:00Z"}, "message": "re PR target/42321 (NEON/VFP registers from inline assembly clobber list are saved/restored incorrectly)\n\n\tPR target/42321\n\t* arm.c (arm_output_epilogue): Correctly match VFP pop instructions\n\twith their corresponding prologue pushes.\n\nFrom-SVN: r157609", "tree": {"sha": "2312aaf6703c79a8b840222145b8a7825f2990ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2312aaf6703c79a8b840222145b8a7825f2990ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8b68ed3c3dcd9bc49821677d8c23d4ad0f1d4f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8b68ed3c3dcd9bc49821677d8c23d4ad0f1d4f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8b68ed3c3dcd9bc49821677d8c23d4ad0f1d4f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8b68ed3c3dcd9bc49821677d8c23d4ad0f1d4f7/comments", "author": null, "committer": null, "parents": [{"sha": "474b97ce0ff47918ce4fb78b4ee970d4009ecf02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/474b97ce0ff47918ce4fb78b4ee970d4009ecf02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/474b97ce0ff47918ce4fb78b4ee970d4009ecf02"}], "stats": {"total": 33, "additions": 22, "deletions": 11}, "files": [{"sha": "06e2ffd83d023b3e55898ca359f75125673c7d46", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8b68ed3c3dcd9bc49821677d8c23d4ad0f1d4f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8b68ed3c3dcd9bc49821677d8c23d4ad0f1d4f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8b68ed3c3dcd9bc49821677d8c23d4ad0f1d4f7", "patch": "@@ -1,3 +1,9 @@\n+2010-03-21  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR target/42321\n+\t* arm.c (arm_output_epilogue): Correctly match VFP pop instructions\n+\twith their corresponding prologue pushes.\n+\n 2010-03-20  Andrew Pinski  <pinskia@gmail.com>\n \n \tPR target/43156"}, {"sha": "6f42dd00a097952d353d655b62411e3b3661414b", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8b68ed3c3dcd9bc49821677d8c23d4ad0f1d4f7/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8b68ed3c3dcd9bc49821677d8c23d4ad0f1d4f7/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f8b68ed3c3dcd9bc49821677d8c23d4ad0f1d4f7", "patch": "@@ -13731,24 +13731,29 @@ arm_output_epilogue (rtx sibling)\n \n       if (TARGET_HARD_FLOAT && TARGET_VFP)\n \t{\n-\t  start_reg = FIRST_VFP_REGNUM;\n-\t  for (reg = FIRST_VFP_REGNUM; reg < LAST_VFP_REGNUM; reg += 2)\n+\t  int end_reg = LAST_VFP_REGNUM + 1;\n+\n+\t  /* Scan the registers in reverse order.  We need to match\n+\t     any groupings made in the prologue and generate matching\n+\t     pop operations.  */\n+\t  for (reg = LAST_VFP_REGNUM - 1; reg >= FIRST_VFP_REGNUM; reg -= 2)\n \t    {\n \t      if ((!df_regs_ever_live_p (reg) || call_used_regs[reg])\n-\t\t  && (!df_regs_ever_live_p (reg + 1) || call_used_regs[reg + 1]))\n+\t\t  && (!df_regs_ever_live_p (reg + 1)\n+\t\t      || call_used_regs[reg + 1]))\n \t\t{\n-\t\t  if (start_reg != reg)\n+\t\t  if (end_reg > reg + 2)\n \t\t    vfp_output_fldmd (f, SP_REGNUM,\n-\t\t\t\t      (start_reg - FIRST_VFP_REGNUM) / 2,\n-\t\t\t\t      (reg - start_reg) / 2);\n-\t\t  start_reg = reg + 2;\n+\t\t\t\t      (reg + 2 - FIRST_VFP_REGNUM) / 2,\n+\t\t\t\t      (end_reg - (reg + 2)) / 2);\n+\t\t  end_reg = reg;\n \t\t}\n \t    }\n-\t  if (start_reg != reg)\n-\t    vfp_output_fldmd (f, SP_REGNUM,\n-\t\t\t      (start_reg - FIRST_VFP_REGNUM) / 2,\n-\t\t\t      (reg - start_reg) / 2);\n+\t  if (end_reg > reg + 2)\n+\t    vfp_output_fldmd (f, SP_REGNUM, 0,\n+\t\t\t      (end_reg - (reg + 2)) / 2);\n \t}\n+\n       if (TARGET_IWMMXT)\n \tfor (reg = FIRST_IWMMXT_REGNUM; reg <= LAST_IWMMXT_REGNUM; reg++)\n \t  if (df_regs_ever_live_p (reg) && !call_used_regs[reg])"}]}