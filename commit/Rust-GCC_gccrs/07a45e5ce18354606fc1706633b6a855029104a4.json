{"sha": "07a45e5ce18354606fc1706633b6a855029104a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdhNDVlNWNlMTgzNTQ2MDZmYzE3MDY2MzNiNmE4NTUwMjkxMDRhNA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-24T22:17:21Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-24T22:17:21Z"}, "message": "Correct typos and formatting problems.\n\n(cpu): Use sh_cpu_attr not sh_cpu.\n(adddi3, subdi3, udivsi3-1, divsi3-1, mulsi3_call-1, ashrsi2_16,\nashrsi2_31, dect, casesi_worker): Use arith_reg_operand not\nregister_operand.\n(ashlsi3_n, lshrsi3_n): Enable pattern.  Set length correctly.\nUse '#' to output it.\n(ashlsi3_n+1, lshrsi3_n+1): New patterns to split shifts.\n(ashlsi3, lshrsi3): Use shiftby_operand instead of gen_shifty_op.\n(lshlsi3_m): New pattern for single bit shifts.\n(lshlsi3_k): Only handle multiple bit shifts.\n(negc): Use IOR not PLUS to set carry bit.\n(push+2, pop+2, movsi_pi, movdi-2, movdf_k-1, movsf_i-1): Delete.\n(movsi_i, movqi_i, movhi_i): Delete redundant < and > constraints.\n(movsf_i): Delete incorrect < and > constraints.\n\nFrom-SVN: r9060", "tree": {"sha": "eab8133563ecca8bfff6a6e1c6abf1c50b2d87df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eab8133563ecca8bfff6a6e1c6abf1c50b2d87df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07a45e5ce18354606fc1706633b6a855029104a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07a45e5ce18354606fc1706633b6a855029104a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07a45e5ce18354606fc1706633b6a855029104a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07a45e5ce18354606fc1706633b6a855029104a4/comments", "author": null, "committer": null, "parents": [{"sha": "b1e9510ec9f0859c9a0a4241f4355cb3270c9ff3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1e9510ec9f0859c9a0a4241f4355cb3270c9ff3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1e9510ec9f0859c9a0a4241f4355cb3270c9ff3"}], "stats": {"total": 293, "additions": 131, "deletions": 162}, "files": [{"sha": "93bb13514d06017dd8e38ac07121b187a1046a4c", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 131, "deletions": 162, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07a45e5ce18354606fc1706633b6a855029104a4/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07a45e5ce18354606fc1706633b6a855029104a4/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=07a45e5ce18354606fc1706633b6a855029104a4", "patch": "@@ -30,16 +30,16 @@\n \n ;; Special constraints for SH machine description:\n ;;\n-;;    t -- T \n-;;    x -- mac \n-;;    l -- pr \n+;;    t -- T\n+;;    x -- mac\n+;;    l -- pr\n ;;    z -- r0\n ;;\n ;; Special formats used for outputting SH instructions:\n ;;\n ;;   %.  --  print a .s if insn needs delay slot\n ;;   %#  --  output a nop if there is nothing to put in the delay slot\n-;;   %R  --  print the lsw arg of a double, \n+;;   %R  --  print the lsw arg of a double,\n ;;   %S  --  print the msw arg of a double\n ;;   %O  --  print a constant without the #\n ;;   %M  --  print a constant as its negative\n@@ -53,7 +53,6 @@\n ;;  general_movdst_operand -- operand is valid move destination\n ;;  general_movsrc_operand -- operand is valid move source\n ;;  logical_operand        -- operand is valid source for logical op\n-;;  pop_operand            -- operand is a pop from the stack\n ;;  system_reg_operand     -- operand is MACL, MACH, or PR\n ;; -------------------------------------------------------------------------\n ;; Attributes\n@@ -62,7 +61,7 @@\n ; Target CPU.\n \n (define_attr \"cpu\" \"sh0,sh1,sh2,sh3\"\n-  (const (symbol_ref \"sh_cpu\")))\n+  (const (symbol_ref \"sh_cpu_attr\")))\n \n ;;\n ;; cbranch\tconditional branch instructions\n@@ -79,11 +78,11 @@\n ;; rte\t\treturn from exception\n ;; sfunc\tspecial function call with known used registers\n \n-(define_attr \"type\" \n+(define_attr \"type\"\n  \"cbranch,jump,arith,other,load,store,move,smpy,dmpy,return,pload,pcload,rte,sfunc\"\n   (const_string \"other\"))\n \n-; If a conditional branch destination is within -252..258 bytes away \n+; If a conditional branch destination is within -252..258 bytes away\n ; from the instruction it can be 2 bytes long.  Something in the\n ; range -4090..4100 bytes can be 6 bytes long.  All other conditional\n ; branches are 16 bytes long.\n@@ -98,7 +97,7 @@\n ; length.  This is because shorten_branches starts with the largest\n ; instruction size and then tries to reduce them.\n \n-(define_attr \"length\" \"\" \n+(define_attr \"length\" \"\"\n   (cond [(eq_attr \"type\" \"cbranch\")\n \t (if_then_else (and (ge (minus (match_dup 0) (pc))\n \t\t\t\t(const_int -252))\n@@ -123,7 +122,7 @@\n \n ;; (define_function_unit {name} {num-units} {n-users} {test}\n ;;                       {ready-delay} {issue-delay} [{conflict-list}])\n-\t\t\t\t      \n+\n (define_function_unit \"memory\" 1 0 (eq_attr \"type\" \"load,pcload,pload\") 2 2)\n (define_function_unit \"mpy\"    1 0 (eq_attr \"type\" \"smpy\") 2 2)\n (define_function_unit \"mpy\"    1 0 (eq_attr \"type\" \"dmpy\") 3 3)\n@@ -137,7 +136,7 @@\n (define_attr \"interrupt_function\" \"no,yes\"\n   (const (symbol_ref \"pragma_interrupt\")))\n \n-(define_attr \"in_delay_slot\" \"yes,no\" \n+(define_attr \"in_delay_slot\" \"yes,no\"\n   (cond [(eq_attr \"type\" \"cbranch\") (const_string \"no\")\n \t (eq_attr \"type\" \"pcload\") (const_string \"no\")\n \t (eq_attr \"needs_delay_slot\" \"yes\") (const_string \"no\")\n@@ -148,16 +147,16 @@\n   (eq_attr \"needs_delay_slot\" \"yes\")\n   [(eq_attr \"in_delay_slot\" \"yes\") (nil) (nil)])\n \n-(define_delay \n+(define_delay\n   (eq_attr \"type\" \"return\")\n-  [(and (eq_attr \"in_delay_slot\" \"yes\") \n+  [(and (eq_attr \"in_delay_slot\" \"yes\")\n \t(and (ior (eq_attr \"interrupt_function\" \"no\")\n \t\t  (eq_attr \"hit_stack\" \"no\"))\n \t     (ior (eq_attr \"interrupt_function\" \"yes\")\n \t\t  (eq_attr \"type\" \"!pload\")))) (nil) (nil)])\n \n-(define_delay \n-  (and (eq_attr \"type\" \"cbranch\") \n+(define_delay\n+  (and (eq_attr \"type\" \"cbranch\")\n        (eq_attr \"cpu\" \"sh2,sh3\"))\n   [(eq_attr \"in_delay_slot\" \"yes\") (nil) (nil)])\n \f\n@@ -184,6 +183,10 @@\n   \"\"\n   \"tst\t%1,%0\")\n \n+;; ??? Perhaps should only accept reg/constant if the register is reg 0.\n+;; That would still allow reload to create cmpi instructions, but would\n+;; perhaps allow forcing the constant into a register when that is better.\n+\n (define_insn \"cmpeqsi_t\"\n   [(set (reg:SI 18) (eq:SI (match_operand:SI 0 \"arith_reg_operand\" \"r,z,r\")\n \t\t\t   (match_operand:SI 1 \"arith_operand\" \"N,rI,r\")))]\n@@ -238,7 +241,6 @@\n   sh_compare_op1 = operands[1];\n   DONE;\n }\")\n-\n \f\n ;; -------------------------------------------------------------------------\n ;; Addition instructions\n@@ -247,9 +249,9 @@\n ;; this should be a define split.\n \n (define_insn \"adddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"r\")))\n+  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"arith_reg_operand\" \"%0\")\n+\t\t (match_operand:DI 2 \"arith_reg_operand\" \"r\")))\n    (clobber (reg:SI 18))]\n   \"\"\n   \"clrt\\;addc\t%R2,%R0\\;addc\t%S2,%S0\"\n@@ -270,9 +272,9 @@\n \n \n (define_insn \"subdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(minus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"r\")))\n+  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n+\t(minus:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n+\t\t (match_operand:DI 2 \"arith_reg_operand\" \"r\")))\n    (clobber (reg:SI 18))]\n   \"\"\n   \"clrt\\;subc\t%R2,%R0\\;subc\t%S2,%S0\"\n@@ -285,7 +287,6 @@\n   \"\"\n   \"sub\t%2,%0\"\n   [(set_attr \"type\" \"arith\")])\n-\n \f\n ;; -------------------------------------------------------------------------\n ;; Division instructions\n@@ -303,7 +304,7 @@\n    (clobber (reg:SI 17))\n    (clobber (reg:SI 6))\n    (clobber (reg:SI 4))\n-   (use (match_operand:SI 0 \"register_operand\" \"r\"))]\n+   (use (match_operand:SI 0 \"arith_reg_operand\" \"r\"))]\n   \"\"\n   \"jsr\t@%0%#\"\n   [(set_attr \"type\" \"sfunc\")\n@@ -321,7 +322,7 @@\n \t     (clobber (reg:SI 6))\n \t     (clobber (reg:SI 4))\n \t     (use (match_dup 3))])\n-   (set (match_operand:SI 0 \"general_operand\" \"=g\") \n+   (set (match_operand:SI 0 \"general_operand\" \"=g\")\n \t(reg:SI 0))]\n   \"\"\n   \"operands[3] = gen_reg_rtx(SImode);\")\n@@ -335,7 +336,7 @@\n    (clobber (reg:SI 1))\n    (clobber (reg:SI 2))\n    (clobber (reg:SI 3))\n-   (use (match_operand:SI 0 \"register_operand\" \"r\"))]\n+   (use (match_operand:SI 0 \"arith_reg_operand\" \"r\"))]\n   \"\"\n   \"jsr\t@%0%#\"\n   [(set_attr \"type\" \"sfunc\")\n@@ -354,11 +355,10 @@\n \t     (clobber (reg:SI 2))\n \t     (clobber (reg:SI 3))\n \t     (use (match_dup 3))])\n-   (set (match_operand:SI 0 \"general_operand\" \"=g\") \n+   (set (match_operand:SI 0 \"general_operand\" \"=g\")\n \t(reg:SI 0))]\n   \"\"\n   \"operands[3] = gen_reg_rtx(SImode);\")\n-\t    \n \f\n ;; -------------------------------------------------------------------------\n ;; Multiplication instructions\n@@ -416,7 +416,7 @@\n    (clobber (reg:SI 3))\n    (clobber (reg:SI 2))\n    (clobber (reg:SI 1))\n-   (use (match_operand:SI 0 \"register_operand\" \"r\"))]\n+   (use (match_operand:SI 0 \"arith_reg_operand\" \"r\"))]\n   \"\"\n   \"jsr\t@%0%#\"\n   [(set_attr \"type\" \"sfunc\")\n@@ -436,11 +436,11 @@\n \t     (clobber (reg:SI 2))\n \t     (clobber (reg:SI 1))\n \t     (use (match_dup 3))])\n-   (set (match_operand:SI 0 \"general_operand\" \"=g\") \n+   (set (match_operand:SI 0 \"general_operand\" \"=g\")\n \t(reg:SI 0))]\n   \"\"\n   \"operands[3] = gen_reg_rtx(SImode);\")\n-\t\n+\n (define_insn \"mul_l\"\n   [(set (reg:SI 21)\n \t(mult:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n@@ -500,7 +500,6 @@\n \t(reg:DI 20))]\n   \"(TARGET_SH2) && 0\"\n   \"\")\n-\n \f\n ;; -------------------------------------------------------------------------\n ;; Logical operations\n@@ -546,7 +545,6 @@\n   \"\"\n   \"xor\t%2,%0\"\n   [(set_attr \"type\" \"arith\")])\n-\n \f\n ;; -------------------------------------------------------------------------\n ;; Shifts and rotates\n@@ -620,7 +618,6 @@\n ;;\n ;; shift left\n \n-\n (define_insn \"ashlsi3_k\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,r\")\n \t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"0,0\")\n@@ -630,29 +627,43 @@\n \tadd\t%0,%0\n \tshll%O2\t%0\")\n \n-; ??? seperate pattern for shifts by any N.  Turn this on to recognize shift\n-; insns which aren't supported in the hardware.  This will allow the combiner\n-; to notice more patterns, but the down side is that the asm outputter will\n-; have to emit several instructions for each shift which isn't possible in\n-; the hardware, this makes scheduling perform badly.\n-\n (define_insn \"ashlsi3_n\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n \t\t   (match_operand:SI 2 \"immediate_operand\" \"n\")))\n    (clobber (reg:SI 18))]\n-  \"0\"\n-  \"*return output_shift(\\\"shll\\\", operands[0], operands[2], ASHIFT);\"\n-  [(set_attr \"length\" \"12\")\n+  \"\"\n+  \"#\"\n+  [(set (attr \"length\")\n+\t(cond [(eq (symbol_ref \"shift_insns_rtx (insn)\") (const_int 1))\n+\t       (const_string \"2\")\n+\t       (eq (symbol_ref \"shift_insns_rtx (insn)\") (const_int 2))\n+\t       (const_string \"4\")\n+\t       (eq (symbol_ref \"shift_insns_rtx (insn)\") (const_int 3))\n+\t       (const_string \"6\")]\n+\t      (const_string \"8\")))\n    (set_attr \"type\" \"arith\")])\n \n+(define_split\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n+\t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"n\")))\n+   (clobber (reg:SI 18))]\n+  \"\"\n+  [(use (reg:SI 0))]\n+  \"\n+{\n+  gen_shifty_op (ASHIFT, operands);\n+  DONE;\n+}\")\n+\n (define_expand \"ashlsi3\"\n   [(parallel[(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n \t\t  (ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n \t\t\t     (match_operand:SI 2 \"shiftby_operand\" \"\")))\n \t     (clobber (reg:SI 18))])]\n   \"\"\n-  \"if (gen_shifty_op (ASHIFT, operands)) DONE; else FAIL;\")\n+  \"if (! shiftby_operand (operands[2], SImode)) FAIL;\")\n \n ;\n ; arithmetic shift right\n@@ -668,16 +679,16 @@\n   [(set_attr \"type\" \"arith\")])\n \n (define_insn \"ashrsi2_16\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+        (ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n                      (const_int 16)))]\n   \"\"\n   \"swap.w\t%1,%0\\;exts.w\t%0,%0\"\n   [(set_attr \"length\" \"4\")])\n \n (define_insn \"ashrsi2_31\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-        (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,!r\")\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,r\")\n+        (ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0,!r\")\n                      (const_int 31)))\n    (clobber (reg:SI 18))]\n   \"\"\n@@ -694,10 +705,6 @@\n }\"\n   [(set_attr \"length\" \"4,6\")])\n \n-\n-\n-\n-\n (define_insn \"ashrsi3_n\"\n   [(set (reg:SI 4)\n \t(ashiftrt:SI (reg:SI 4)\n@@ -718,39 +725,64 @@\n   \"\"\n   \"if (gen_shifty_op (ASHIFTRT, operands)) DONE; else FAIL;\")\n \n-; logical shift right\n-;\n+;; logical shift right\n \n \n-(define_insn \"lshrsi3_k\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,r\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0,0\")\n-\t\t     (match_operand:SI 2 \"immediate_operand\" \"M,K\")))\n+;; ??? Only the single bit shift clobbers the T bit.\n+\n+(define_insn \"lshrsi3_m\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"M\")))\n    (clobber (reg:SI 18))]\n-  \"CONST_OK_FOR_K (INTVAL (operands[2]))\"\n-  \"@\n-\tshlr\t%0\n-\tshlr%O2\t%0\")\n+  \"CONST_OK_FOR_M (INTVAL (operands[2]))\"\n+  \"shlr\t%0\")\n \n-; ??? seperate pattern for shifts by any N.  See ashlsi3_n.\n+(define_insn \"lshrsi3_k\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"K\")))]\n+  \"CONST_OK_FOR_K (INTVAL (operands[2]))\n+   && ! CONST_OK_FOR_M (INTVAL (operands[2]))\"\n+  \"shlr%O2\t%0\")\n \n (define_insn \"lshrsi3_n\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"n\")))\n    (clobber (reg:SI 18))]\n-  \"0\"\n-  \"* return output_shift (\\\"shlr\\\", operands[0], operands[2], LSHIFTRT);\"\n-  [(set_attr \"length\" \"12\")\n+  \"\"\n+  \"#\"\n+  [(set (attr \"length\")\n+\t(cond [(eq (symbol_ref \"shift_insns_rtx (insn)\") (const_int 1))\n+\t       (const_string \"2\")\n+\t       (eq (symbol_ref \"shift_insns_rtx (insn)\") (const_int 2))\n+\t       (const_string \"4\")\n+\t       (eq (symbol_ref \"shift_insns_rtx (insn)\") (const_int 3))\n+\t       (const_string \"6\")]\n+\t      (const_string \"8\")))\n    (set_attr \"type\" \"arith\")])\n \n+(define_split\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"n\")))\n+   (clobber (reg:SI 18))]\n+  \"\"\n+  [(use (reg:SI 0))]\n+  \"\n+{\n+  gen_shifty_op (LSHIFTRT, operands);\n+  DONE;\n+}\")\n+\n (define_expand \"lshrsi3\"\n   [(parallel[(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n \t\t  (lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n \t\t\t       (match_operand:SI 2 \"shiftby_operand\" \"\")))\n \t     (clobber (reg:SI 18))])]\n   \"\"\n-  \"if (gen_shifty_op (LSHIFTRT, operands)) DONE; else FAIL;\") \n+  \"if (! shiftby_operand (operands[2], SImode)) FAIL;\")\n \n (define_insn \"ashldi3_k\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n@@ -766,9 +798,9 @@\n \t\t  (ashift:DI (match_operand:DI 1 \"arith_reg_operand\" \"\")\n \t\t\t     (match_operand:DI 2 \"immediate_operand\" \"\")))\n \t     (clobber (reg:SI 18))])]\n-\t    \n+\n   \"\"\n-  \"{ if (GET_CODE (operands[2]) != CONST_INT \t\n+  \"{ if (GET_CODE (operands[2]) != CONST_INT\n \t|| INTVAL (operands[2]) != 1) FAIL;} \")\n \n (define_insn \"lshrdi3_k\"\n@@ -786,7 +818,7 @@\n \t\t\t       (match_operand:DI 2 \"immediate_operand\" \"\")))\n \t     (clobber (reg:SI 18))])]\n   \"\"\n-  \"{ if (GET_CODE (operands[2]) != CONST_INT \n+  \"{ if (GET_CODE (operands[2]) != CONST_INT\n \t|| INTVAL (operands[2]) != 1) FAIL;} \")\n \n (define_insn \"ashrdi3_k\"\n@@ -804,9 +836,8 @@\n \t\t\t       (match_operand:DI 2 \"immediate_operand\" \"\")))\n \t     (clobber (reg:SI 18))])]\n   \"\"\n-  \"{ if (GET_CODE (operands[2]) != CONST_INT \n+  \"{ if (GET_CODE (operands[2]) != CONST_INT\n \t|| INTVAL (operands[2]) != 1) FAIL; } \")\n-\n \f\n ;; -------------------------------------------------------------------------\n ;; Unary arithmetic\n@@ -818,7 +849,7 @@\n \t(neg:SI (plus:SI (reg:SI 18)\n \t\t\t (match_operand:SI 1 \"arith_reg_operand\" \"r\"))))\n    (set (reg:SI 18)\n-\t(ne:SI (plus:SI (reg:SI 18) (match_dup 1))\n+\t(ne:SI (ior:SI (reg:SI 18) (match_dup 1))\n \t       (const_int 0)))]\n   \"\"\n   \"negc\t%1,%0\"\n@@ -857,7 +888,6 @@\n   \"\"\n   \"not\t%1,%0\"\n   [(set_attr \"type\" \"arith\")])\n-\n \f\n ;; -------------------------------------------------------------------------\n ;; Zero extension instructions\n@@ -875,15 +905,14 @@\n \t(zero_extend:SI (match_operand:QI 1 \"arith_reg_operand\" \"r\")))]\n   \"\"\n   \"extu.b\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")]) \n+  [(set_attr \"type\" \"arith\")])\n \n (define_insn \"zero_extendqihi2\"\n   [(set (match_operand:HI 0 \"arith_reg_operand\" \"=r\")\n \t(zero_extend:HI (match_operand:QI 1 \"arith_reg_operand\" \"r\")))]\n   \"\"\n   \"extu.b\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")]) \n-\n+  [(set_attr \"type\" \"arith\")])\n \f\n ;; -------------------------------------------------------------------------\n ;; Sign extension instructions\n@@ -895,7 +924,7 @@\n    (clobber (reg:SI 18))]\n   \"\"\n   \"mov\t%1,%S0\\;mov\t%1,%R0\\;shll\t%S0\\;subc\t%S0,%S0\"\n-  [(set_attr \"length\" \"8\")]) \n+  [(set_attr \"length\" \"8\")])\n \n (define_insn \"extendhisi2\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,r\")\n@@ -923,7 +952,6 @@\n \texts.b\t%1,%0\n \tmov.b\t%1,%0\"\n   [(set_attr \"type\" \"arith,load\")])\n-\n \f\n ;; -------------------------------------------------------------------------\n ;; Move instructions\n@@ -952,40 +980,14 @@\n   [(set_attr \"type\" \"load,pload,load\")\n    (set_attr \"hit_stack\" \"yes\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:SI 1 \"arith_reg_operand\" \"r,xl\"))]\n-  \"\"\n-  \"@\n-\tmov.l\t%1,%0\n-\tsts.l\t%1,%0\"\n-  [(set_attr \"type\" \"store\")])\n-\n-(define_insn \"\"\n-  [(set\t(match_operand:SI 0 \"arith_reg_operand\" \"=r,xl\")\n-\t(match_operand:SI 1 \"pop_operand\" \"=>,>\"))]\n-  \"\"\n-  \"@\n-\tmov.l\t%1,%0\n-\tlds.l\t%1,%0\"\n-  [(set_attr \"type\" \"load\")])\n-\n (define_insn \"clrt\"\n   [(set (reg:SI 18) (const_int 0))]\n   \"\"\n   \"clrt\")\n \n-;(define_insn \"movsi_pi\"\n-;  [(set (match_operand:SI 0 \"general_movdst_operand\" \"=r\")\n-;\t(mem:SI (post_inc (match_operand:SI 1 \"register_operand\" \"r\"))))]\n-;  \"\"\n-;  \"mov.l\t@%1,%0\\;add\t#4,%1\"\n-;  [(set_attr \"length\" \"4\")])\n-\n-\n (define_insn \"movsi_i\"\n-  [(set (match_operand:SI 0 \"general_movdst_operand\" \"=r,r,r,r,r,<m,<,xl,xl,t,r\")\n-\t(match_operand:SI 1 \"general_movsrc_operand\" \"Q,rI,>m,xl,t,r,xl,r,>,r,i\"))]\n+  [(set (match_operand:SI 0 \"general_movdst_operand\" \"=r,r,r,r,r,m,<,xl,xl,t,r\")\n+\t(match_operand:SI 1 \"general_movsrc_operand\" \"Q,rI,m,xl,t,r,xl,r,>,r,i\"))]\n   \"\"\n   \"@\n \tmov.l\t%1,%0\n@@ -1001,7 +1003,7 @@\n \tfake\t%1,%0\"\n   [(set_attr \"type\" \"pcload,move,load,move,store,store,move,load,move,move,move\")\n    (set_attr \"length\" \"*,*,*,*,*,*,*,*,*,8,*\")])\n-\t\t\t  \n+\n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"general_movdst_operand\" \"\")\n \t(match_operand:SI 1 \"general_movsrc_operand\" \"\"))]\n@@ -1011,9 +1013,9 @@\n \n \n (define_insn \"movqi_i\"\n-  [(set (match_operand:QI 0 \"general_movdst_operand\" \"=r,r,>m,r,r,l\")\n-\t(match_operand:QI 1 \"general_movsrc_operand\"  \"ri,<m,r,t,l,r\"))]\n-  \"arith_reg_operand (operands[0], QImode) \n+  [(set (match_operand:QI 0 \"general_movdst_operand\" \"=r,r,m,r,r,l\")\n+\t(match_operand:QI 1 \"general_movsrc_operand\"  \"ri,m,r,t,l,r\"))]\n+  \"arith_reg_operand (operands[0], QImode)\n    || arith_reg_operand (operands[1], QImode)\"\n   \"@\n \tmov\t%1,%0\n@@ -1031,8 +1033,8 @@\n   \"if (prepare_move_operands(operands, QImode)) DONE; \")\n \n (define_insn \"movhi_i\"\n-  [(set (match_operand:HI 0 \"general_movdst_operand\" \"=r,r,r,r,<m,r,l,r\")\n-\t(match_operand:HI 1 \"general_movsrc_operand\" \"Q,rI,>m,t,r,l,r,i\"))]\n+  [(set (match_operand:HI 0 \"general_movdst_operand\" \"=r,r,r,r,m,r,l,r\")\n+\t(match_operand:HI 1 \"general_movsrc_operand\" \"Q,rI,m,t,r,l,r,i\"))]\n   \"\"\n   \"@\n \tmov.w\t%1,%0\n@@ -1051,14 +1053,6 @@\n   \"\"\n   \"if (prepare_move_operands (operands, HImode)) DONE;\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"push_operand\" \"=<\")\n-\t(match_operand:DI 1 \"arith_reg_operand\" \"r\"))]\n-   \"\"\n-   \"mov.l\t%T1,%0\\;mov.l\t%01,%0\"\n-   [(set_attr \"length\" \"4\")\n-    (set_attr \"type\" \"store\")])\n-\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"general_movdst_operand\" \"=r,r,r,m,r\")\n \t(match_operand:DI 1 \"general_movsrc_operand\" \"Q,r,m,r,i\"))]\n@@ -1107,21 +1101,13 @@\n     FAIL;\n }\")\n \n-\t\n+\n (define_expand \"movdi\"\n   [(set (match_operand:DI 0 \"general_movdst_operand\" \"\")\n \t(match_operand:DI 1 \"general_movsrc_operand\" \"\"))]\n   \"\"\n   \"if ( prepare_move_operands(operands, DImode)) DONE; \")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"push_operand\" \"=<\")\n-\t(match_operand:DF 1 \"arith_reg_operand\" \"r\"))]\n-   \"\"\n-  \"mov.l\t%T1,%0\\;mov.l\t%1,%0\"\n-   [(set_attr \"length\" \"4\")\n-    (set_attr \"type\" \"store\")])\n-\n (define_insn \"movdf_k\"\n   [(set (match_operand:DF 0 \"general_movdst_operand\" \"=r,r,m\")\n \t(match_operand:DF 1 \"general_movsrc_operand\" \"r,m,r\"))]\n@@ -1133,7 +1119,7 @@\n \n ;; If the output is a register and the input is memory, we have to be careful\n ;; and see which word needs to be loaded first.\n-;;\n+\n (define_split\n   [(set (match_operand:DF 0 \"general_movdst_operand\" \"\")\n \t(match_operand:DF 1 \"general_movsrc_operand\" \"\"))]\n@@ -1176,38 +1162,24 @@\n   \"\"\n  \"{ if (prepare_move_operands(operands, DFmode)) DONE; } \")\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"push_operand\" \"=<\")\n-\t(match_operand:SF 1 \"arith_reg_operand\" \"r\"))]\n-   \"\"\n-   \"mov.l\t%1,%0\"\n-  [(set_attr \"type\" \"store\")])\n-\t\t\n-;; ??? Why do we have unsupported auto-inc in the dest, and auto-dec in the\n-;; source? And why is the supported auto-dec dest and auto-inc source missing?\n-\n (define_insn \"movsf_i\"\n-  [(set (match_operand:SF 0 \"general_movdst_operand\" \"=>,r,r,r,r,m,l,r\")\n-\t(match_operand:SF 1 \"general_movsrc_operand\"  \"r,<,r,I,m,r,r,l\"))]\n+  [(set (match_operand:SF 0 \"general_movdst_operand\" \"=r,r,r,m,l,r\")\n+\t(match_operand:SF 1 \"general_movsrc_operand\"  \"r,I,m,r,r,l\"))]\n   \"\"\n   \"@\n-        mov.l\t%1,@%N0\\;add\t#4,%N0\n-        add\t#-4,%1\\;mov.l\t@%N1,%0\n \tmov\t%1,%0\n \tmov\t%1,%0\n \tmov.l\t%1,%0\n \tmov.l\t%1,%0\n \tlds\t%1,%0\n \tsts\t%1,%0\"\n-  [(set_attr \"type\" \"store,load,move,move,load,store,move,move\")\n-   (set_attr \"length\" \"4,4,*,*,*,*,*,*\")])\n+  [(set_attr \"type\" \"move,move,load,store,move,move\")])\n \n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"general_movdst_operand\" \"\")\n \t(match_operand:SF 1 \"general_movsrc_operand\" \"\"))]\n   \"\"\n   \"if (prepare_move_operands (operands, SFmode)) DONE;\")\n-\n \f\n ;; ------------------------------------------------------------------------\n ;; Define the real conditional branch instructions.\n@@ -1244,7 +1216,6 @@\n   \"\"\n   \"* return output_branch (1, insn);\"\n   [(set_attr \"type\" \"cbranch\")])\n-\n \f\n ;; Conditional branch insns\n \n@@ -1350,7 +1321,6 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n   \"from_compare (operands, LEU);\")\n-\n \f\n ;; ------------------------------------------------------------------------\n ;; Jump and linkage insns\n@@ -1363,7 +1333,7 @@\n   \"*\n {\n   /* The length is 16 if the delay slot is unfilled.  */\n-  if (get_attr_length(insn) >= 14) \n+  if (get_attr_length(insn) >= 14)\n     {\n       return output_far_jump(insn, operands[0]);\n     }\n@@ -1425,7 +1395,7 @@\n \n (define_insn \"dect\"\n   [(parallel[\n-\t     (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t     (set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t\t  (plus:SI (match_dup 0)\n \t\t\t   (const_int -1)))\n \t     (set (reg:SI 18)\n@@ -1443,7 +1413,7 @@\n ;; This must use unspec, because this only works immediately before a casesi.\n \n (define_insn \"mova\"\n-  [(set (reg:SI 0) \n+  [(set (reg:SI 0)\n \t(unspec [(label_ref (match_operand 0 \"\" \"\"))] 1))]\n   \"\"\n   \"mova\t%O0,r0\"\n@@ -1490,15 +1460,15 @@\n }\")\n \n (define_insn \"casesi_worker\"\n-  [(set (reg:SI 0) \n-\t(plus:SI (reg:SI 0) \n+  [(set (reg:SI 0)\n+\t(plus:SI (reg:SI 0)\n \t\t (mem:HI (plus:SI (reg:SI 0)\n-\t\t\t\t  (match_operand:SI 0 \"register_operand\" \"=r\")))))\n+\t\t\t\t  (match_operand:SI 0 \"arith_reg_operand\" \"=r\")))))\n    (set (match_dup 0) (mem:HI (plus:SI (reg:SI 0)\n \t\t\t\t       (match_dup 0))))]\n   \"\"\n   \"*\n-\tif (TARGET_BIGTABLE) \n+\tif (TARGET_BIGTABLE)\n \t\treturn \\\"mov.l\t@(r0,%0),%0\\;add\t%0,r0\\\";\n \telse\n \t   \treturn \\\"mov.w\t@(r0,%0),%0\\;add\t%0,r0\\\";\"\n@@ -1526,7 +1496,6 @@\n   \"\"\n   \"\"\n   [(set_attr \"length\" \"0\")])\n-\n \f\n ;; ------------------------------------------------------------------------\n ;; Scc instructions\n@@ -1672,7 +1641,7 @@\n ;; Misc\n ;; -------------------------------------------------------------------------\n \n-;; String/block move insn.  \n+;; String/block move insn.\n \n (define_expand \"movstrsi\"\n   [(parallel [(set (mem:BLK (match_operand:BLK 0 \"\" \"\"))\n@@ -1726,7 +1695,7 @@\n ;; This matches cases where a stack pointer increment at the start of the\n ;; epilogue combines with a stack slot read loading the return value.\n \n-(define_peephole \n+(define_peephole\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n \t(mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")))\n    (set (match_dup 1) (plus:SI (match_dup 1) (const_int 4)))]\n@@ -1735,8 +1704,8 @@\n \n ;; See the comment on the dt combiner pattern above.\n \n-(define_peephole \n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+(define_peephole\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(plus:SI (match_dup 0)\n \t\t (const_int -1)))\n    (set (reg:SI 18)"}]}