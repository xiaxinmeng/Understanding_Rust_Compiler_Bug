{"sha": "1ed69f611a49303c68258905e067c1c5888b9248", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVkNjlmNjExYTQ5MzAzYzY4MjU4OTA1ZTA2N2MxYzU4ODhiOTI0OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-04-08T06:44:51Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-04-08T06:44:51Z"}, "message": "a-cgcaso.adb, [...]: (Swap, Sift): Avoid use of complex renaming.\n\n2008-04-08  Arnaud Charlet  <charlet@adacore.com>\n\t    Matthew Heaney  <heaney@adacore.com>\n\n\t* a-cgcaso.adb, a-convec.adb: (Swap, Sift): Avoid use of complex\n\trenaming.\n\n\t* a-cgaaso.ads, a-secain.ads, a-slcain.ads, a-shcain.ads,  \n\ta-crdlli.ads, a-coormu.ads, a-ciormu.ads: modified header to conform\n\tto convention for non-RM specs.\n\tAdd descriptive header, and documented each operation\n\tdocument each operation\n\nFrom-SVN: r134009", "tree": {"sha": "2b9618595abf244d6ac1c4834b62e41355ec9377", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b9618595abf244d6ac1c4834b62e41355ec9377"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ed69f611a49303c68258905e067c1c5888b9248", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ed69f611a49303c68258905e067c1c5888b9248", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ed69f611a49303c68258905e067c1c5888b9248", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ed69f611a49303c68258905e067c1c5888b9248/comments", "author": null, "committer": null, "parents": [{"sha": "43c6e0cb2115c752aaa0d7dbc9f04587cb43f350", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43c6e0cb2115c752aaa0d7dbc9f04587cb43f350", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43c6e0cb2115c752aaa0d7dbc9f04587cb43f350"}], "stats": {"total": 633, "additions": 572, "deletions": 61}, "files": [{"sha": "e189ccc572f7b4e4d5908af27840f55e091d535f", "filename": "gcc/ada/a-cgaaso.ads", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ed69f611a49303c68258905e067c1c5888b9248/gcc%2Fada%2Fa-cgaaso.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ed69f611a49303c68258905e067c1c5888b9248/gcc%2Fada%2Fa-cgaaso.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cgaaso.ads?ref=1ed69f611a49303c68258905e067c1c5888b9248", "patch": "@@ -6,11 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n+--          Copyright (C) 2004-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,7 +29,9 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n---  Documentation of this unit is needed ???\n+--  Allows an anonymous array (or array-like container) to be sorted. Generic\n+--  formal Less returns the result of comparing the elements designated by the\n+--  indices, and generic formal Swap exchanges the designated elements.\n \n generic\n    type Index_Type is (<>);\n@@ -42,5 +40,4 @@ generic\n \n procedure Ada.Containers.Generic_Anonymous_Array_Sort\n   (First, Last : Index_Type'Base);\n-\n pragma Pure (Ada.Containers.Generic_Anonymous_Array_Sort);"}, {"sha": "747c2a99ebf693fd8551d1ba6212bc7c98f4e5bb", "filename": "gcc/ada/a-cgcaso.adb", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ed69f611a49303c68258905e067c1c5888b9248/gcc%2Fada%2Fa-cgcaso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ed69f611a49303c68258905e067c1c5888b9248/gcc%2Fada%2Fa-cgcaso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cgcaso.adb?ref=1ed69f611a49303c68258905e067c1c5888b9248", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -91,14 +91,11 @@ is\n \n       while C /= S loop\n          declare\n-            Father      : constant T := C / 2;\n-            Father_Elem : Element_Type renames A (To_Index (Father));\n-\n+            Father : constant T := C / 2;\n          begin\n-            if Father_Elem < Temp then           -- Lt (Father, 0)\n-               A (To_Index (C)) := Father_Elem;  -- Move (Father, C)\n+            if A (To_Index (Father)) < Temp then           -- Lt (Father, 0)\n+               A (To_Index (C)) := A (To_Index (Father));  -- Move (Father, C)\n                C := Father;\n-\n             else\n                exit;\n             end if;\n@@ -117,12 +114,8 @@ begin\n    end loop;\n \n    while Max > 1 loop\n-      declare\n-         Max_Elem : Element_Type renames A (To_Index (Max));\n-      begin\n-         Temp := Max_Elem;         --  Move (Max, 0);\n-         Max_Elem := A (A'First);  --  Move (1, Max);\n-      end;\n+      Temp := A (To_Index (Max));         --  Move (Max, 0);\n+      A (To_Index (Max)) := A (A'First);  --  Move (1, Max);\n \n       Max := Max - 1;\n       Sift (1);"}, {"sha": "0b3719b5aa2b46c10498def9d62e403461130541", "filename": "gcc/ada/a-ciormu.ads", "status": "modified", "additions": 181, "deletions": 6, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ed69f611a49303c68258905e067c1c5888b9248/gcc%2Fada%2Fa-ciormu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ed69f611a49303c68258905e067c1c5888b9248/gcc%2Fada%2Fa-ciormu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciormu.ads?ref=1ed69f611a49303c68258905e067c1c5888b9248", "patch": "@@ -8,10 +8,6 @@\n --                                                                          --\n --          Copyright (C) 2004-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n -- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n@@ -33,7 +29,10 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n---  Documentation of this unit is needed ???\n+--  The indefinite ordered multiset container is similar to the indefinite\n+--  ordered set, but with the difference that multiple equivalent elements are\n+--  allowed. It also provides additional operations, to iterate over items that\n+--  are equivalent.\n \n private with Ada.Containers.Red_Black_Trees;\n private with Ada.Finalization;\n@@ -50,6 +49,8 @@ package Ada.Containers.Indefinite_Ordered_Multisets is\n    pragma Remote_Types;\n \n    function Equivalent_Elements (Left, Right : Element_Type) return Boolean;\n+   --  Returns False if Left is less than Right, or Right is less than Left;\n+   --  otherwise, it returns True.\n \n    type Set is tagged private;\n    pragma Preelaborable_Initialization (Set);\n@@ -58,40 +59,91 @@ package Ada.Containers.Indefinite_Ordered_Multisets is\n    pragma Preelaborable_Initialization (Cursor);\n \n    Empty_Set : constant Set;\n+   --  The default value for set objects declared without an explicit\n+   --  initialization expression.\n \n    No_Element : constant Cursor;\n+   --  The default value for cursor objects declared without an explicit\n+   --  initialization expression.\n \n    function \"=\" (Left, Right : Set) return Boolean;\n+   --  If Left denotes the same set object as Right, then equality returns\n+   --  True. If the length of Left is different from the length of Right, then\n+   --  it returns False. Otherwise, set equality iterates over Left and Right,\n+   --  comparing the element of Left to the element of Right using the equality\n+   --  operator for elements. If the elements compare False, then the iteration\n+   --  terminates and set equality returns False. Otherwise, if all elements\n+   --  compare True, then set equality returns True.\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean;\n+   --  Similar to set equality, but with the difference that elements are\n+   --  compared for equivalence instead of equality.\n \n    function To_Set (New_Item : Element_Type) return Set;\n+   --  Constructs a set object with New_Item as its single element\n \n    function Length (Container : Set) return Count_Type;\n+   --  Returns the total number of elements in Container\n \n    function Is_Empty (Container : Set) return Boolean;\n+   --  Returns True if Container.Length is 0\n \n    procedure Clear (Container : in out Set);\n+   --  Deletes all elements from Container\n \n    function Element (Position : Cursor) return Element_Type;\n+   --  If Position equals No_Element, then Constraint_Error is raised.\n+   --  Otherwise, function Element returns the element designed by Position.\n \n    procedure Replace_Element\n      (Container : in out Set;\n       Position  : Cursor;\n       New_Item  : Element_Type);\n+   --  If Position equals No_Element, then Constraint_Error is raised. If\n+   --  Position is associated with a set different from Container, then\n+   --  Program_Error is raised. If New_Item is equivalent to the element\n+   --  designated by Position, then if Container is locked (element tampering\n+   --  has been attempted), Program_Error is raised; otherwise, the element\n+   --  designated by Position is assigned the value of New_Item. If New_Item is\n+   --  not equivalent to the element designated by Position, then if the\n+   --  container is busy (cursor tampering has been attempted), Program_Error\n+   --  is raised; otherwise, the element designed by Position is assigned the\n+   --  value of New_Item, and the node is moved to its new position (in\n+   --  canonical insertion order).\n \n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n+   --  If Position equals No_Element, then Constraint_Error is\n+   --  raised. Otherwise, it calls Process with the element designated by\n+   --  Position as the parameter. This call locks the container, so attempts to\n+   --  change the value of the element while Process is executing (to \"tamper\n+   --  with elements\") will raise Program_Error.\n \n    procedure Move (Target : in out Set; Source : in out Set);\n+   --  If Target denotes the same object as Source, the operation does\n+   --  nothing. If either Target or Source is busy (cursor tampering is\n+   --  attempted), then it raises Program_Error. Otherwise, Target is cleared,\n+   --  and the nodes from Source are moved (not copied) to Target (so Source\n+   --  becomes empty).\n \n    procedure Insert\n      (Container : in out Set;\n       New_Item  : Element_Type;\n       Position  : out Cursor);\n+   --  Insert adds New_Item to Container, and returns cursor Position\n+   --  designating the newly inserted node. The node is inserted after any\n+   --  existing elements less than or equivalent to New_Item (and before any\n+   --  elements greater than New_Item). Note that the issue of where the new\n+   --  node is inserted relative to equivalent elements does not arise for\n+   --  unique-key containers, since in that case the insertion would simply\n+   --  fail. For a multiple-key container (the case here), insertion always\n+   --  succeeds, and is defined such that the new item is positioned after any\n+   --  equivalent elements already in the container.\n \n    procedure Insert (Container : in out Set; New_Item : Element_Type);\n+   --  Inserts New_Item in Container, but does not return a cursor designating\n+   --  the newly-inserted node.\n \n --  TODO: include Replace too???\n --\n@@ -100,98 +152,184 @@ package Ada.Containers.Indefinite_Ordered_Multisets is\n --        New_Item  : Element_Type);\n \n    procedure Exclude (Container : in out Set; Item : Element_Type);\n+   --  Deletes from Container all of the elements equivalent to Item\n \n    procedure Delete (Container : in out Set; Item : Element_Type);\n+   --  Deletes from Container all of the elements equivalent to Item. If there\n+   --  are no elements equivalent to Item, then it raises Constraint_Error.\n \n    procedure Delete (Container : in out Set; Position : in out Cursor);\n+   --  If Position equals No_Element, then Constraint_Error is raised. If\n+   --  Position is associated with a set different from Container, then\n+   --  Program_Error is raised. Otherwise, the node designated by Position is\n+   --  removed from Container, and Position is set to No_Element.\n \n    procedure Delete_First (Container : in out Set);\n+   --  Removes the first node from Container\n \n    procedure Delete_Last (Container : in out Set);\n+   --  Removes the last node from Container\n \n    procedure Union (Target : in out Set; Source : Set);\n+   --  If Target is busy (cursor tampering is attempted), then Program_Error is\n+   --  raised. Otherwise, it inserts each element of Source into Target.\n+   --  Elements are inserted in the canonical order for multisets, such that\n+   --  the elements from Source are inserted after equivalent elements already\n+   --  in Target.\n \n    function Union (Left, Right : Set) return Set;\n+   --  Returns a set comprising the all elements from Left and all of the\n+   --  elements from Right. The elements from Right follow the equivalent\n+   --  elements from Left.\n \n    function \"or\" (Left, Right : Set) return Set renames Union;\n \n    procedure Intersection (Target : in out Set; Source : Set);\n+   --  If Target denotes the same object as Source, the operation does\n+   --  nothing. If Target is busy (cursor tampering is attempted),\n+   --  Program_Error is raised. Otherwise, the elements in Target having no\n+   --  equivalent element in Source are deleted from Target.\n \n    function Intersection (Left, Right : Set) return Set;\n+   --  If Left denotes the same object as Right, then the function returns a\n+   --  copy of Left. Otherwise, it returns a set comprising the equivalent\n+   --  elements from both Left and Right. Items are inserted in the result set\n+   --  in canonical order, such that the elements from Left precede the\n+   --  equivalent elements from Right.\n \n    function \"and\" (Left, Right : Set) return Set renames Intersection;\n \n    procedure Difference (Target : in out Set; Source : Set);\n+   --  If Target is busy (cursor tampering is attempted), then Program_Error is\n+   --  raised. Otherwise, the elements in Target that are equivalent to\n+   --  elements in Source are deleted from Target.\n \n    function Difference (Left, Right : Set) return Set;\n+   --  Returns a set comprising the elements from Left that have no equivalent\n+   --  element in Right.\n \n    function \"-\" (Left, Right : Set) return Set renames Difference;\n \n    procedure Symmetric_Difference (Target : in out Set; Source : Set);\n+   --  If Target is busy, then Program_Error is raised. Otherwise, the elements\n+   --  in Target equivalent to elements in Source are deleted from Target, and\n+   --  the elements in Source not equivalent to elements in Target are inserted\n+   --  into Target.\n \n    function Symmetric_Difference (Left, Right : Set) return Set;\n+   --  Returns a set comprising the union of the elements from Target having no\n+   --  equivalent in Source, and the elements of Source having no equivalent in\n+   --  Target.\n \n    function \"xor\" (Left, Right : Set) return Set renames Symmetric_Difference;\n \n    function Overlap (Left, Right : Set) return Boolean;\n+   --  Returns True if Left contains an element equivalent to an element of\n+   --  Right.\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n+   --  Returns True if every element in Subset has an equivalent element in\n+   --  Of_Set.\n \n    function First (Container : Set) return Cursor;\n+   --  If Container is empty, the function returns No_Element. Otherwise, it\n+   --  returns a cursor designating the smallest element.\n \n    function First_Element (Container : Set) return Element_Type;\n+   --  Equivalent to Element (First (Container))\n \n    function Last (Container : Set) return Cursor;\n+   --  If Container is empty, the function returns No_Element. Otherwise, it\n+   --  returns a cursor designating the largest element.\n \n    function Last_Element (Container : Set) return Element_Type;\n+   --  Equivalent to Element (Last (Container))\n \n    function Next (Position : Cursor) return Cursor;\n+   --  If Position equals No_Element or Last (Container), the function returns\n+   --  No_Element. Otherwise, it returns a cursor designating the node that\n+   --  immediately follows (as per the insertion order) the node designated by\n+   --  Position.\n \n    procedure Next (Position : in out Cursor);\n+   --  Equivalent to Position := Next (Position)\n \n    function Previous (Position : Cursor) return Cursor;\n+   --  If Position equals No_Element or First (Container), the function returns\n+   --  No_Element. Otherwise, it returns a cursor designating the node that\n+   --  immediately precedes (as per the insertion order) the node designated by\n+   --  Position.\n \n    procedure Previous (Position : in out Cursor);\n+   --  Equivalent to Position := Previous (Position)\n \n    function Find (Container : Set; Item : Element_Type) return Cursor;\n+   --  Returns a cursor designating the first element in Container equivalent\n+   --  to Item. If there is no equivalent element, it returns No_Element.\n \n    function Floor (Container : Set; Item : Element_Type) return Cursor;\n+   --  If Container is empty, the function returns No_Element. If Item is\n+   --  equivalent to elements in Container, it returns a cursor designating the\n+   --  first equivalent element. Otherwise, it returns a cursor designating the\n+   --  largest element less than Item, or No_Element if all elements are\n+   --  greater than Item.\n \n    function Ceiling (Container : Set; Item : Element_Type) return Cursor;\n+   --  If Container is empty, the function returns No_Element. If Item is\n+   --  equivalent to elements of Container, it returns a cursor designating the\n+   --  last equivalent element. Otherwise, it returns a cursor designating the\n+   --  smallest element greater than Item, or No_Element if all elements are\n+   --  less than Item.\n \n    function Contains (Container : Set; Item : Element_Type) return Boolean;\n+   --  Equivalent to Container.Find (Item) /= No_Element\n \n    function Has_Element (Position : Cursor) return Boolean;\n+   --  Equivalent to Position /= No_Element\n \n    function \"<\" (Left, Right : Cursor) return Boolean;\n+   --  Equivalent to Element (Left) < Element (Right)\n \n    function \">\" (Left, Right : Cursor) return Boolean;\n+   --  Equivalent to Element (Right) < Element (Left)\n \n    function \"<\" (Left : Cursor; Right : Element_Type) return Boolean;\n+   --  Equivalent to Element (Left) < Right\n \n    function \">\" (Left : Cursor; Right : Element_Type) return Boolean;\n+   --  Equivalent to Right < Element (Left)\n \n    function \"<\" (Left : Element_Type; Right : Cursor) return Boolean;\n+   --  Equivalent to Left < Element (Right)\n \n    function \">\" (Left : Element_Type; Right : Cursor) return Boolean;\n+   --  Equivalent to Element (Right) < Left\n \n    procedure Iterate\n      (Container : Set;\n       Process   : not null access procedure (Position : Cursor));\n+   --  Calls Process with a cursor designating each element of Container, in\n+   --  order from Container.First to Container.Last.\n \n    procedure Reverse_Iterate\n      (Container : Set;\n       Process   : not null access procedure (Position : Cursor));\n+   --  Calls Process with a cursor designating each element of Container, in\n+   --  order from Container.Last to Container.First.\n \n    procedure Iterate\n      (Container : Set;\n       Item      : Element_Type;\n       Process   : not null access procedure (Position : Cursor));\n+   --  Call Process with a cursor designating each element equivalent to Item,\n+   --  in order from Container.Floor (Item) to Container.Ceiling (Item).\n \n    procedure Reverse_Iterate\n      (Container : Set;\n       Item      : Element_Type;\n       Process   : not null access procedure (Position : Cursor));\n+   --  Call Process with a cursor designating each element equivalent to Item,\n+   --  in order from Container.Ceiling (Item) to Container.Floor (Item).\n \n    generic\n       type Key_Type (<>) is private;\n@@ -203,38 +341,75 @@ package Ada.Containers.Indefinite_Ordered_Multisets is\n    package Generic_Keys is\n \n       function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+      --  Returns False if Left is less than Right, or Right is less than Left;\n+      --  otherwise, it returns True.\n \n       function Key (Position : Cursor) return Key_Type;\n+      --  Equivalent to Key (Element (Position))\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type;\n+      --  Equivalent to Element (Find (Container, Key))\n \n       procedure Exclude (Container : in out Set; Key : Key_Type);\n+      --  Deletes from Container any elements whose key is equivalent to Key\n \n       procedure Delete (Container : in out Set; Key : Key_Type);\n+      --  Deletes from Container any elements whose key is equivalent to\n+      --  Key. If there are no such elements, then it raises Constraint_Error.\n \n       function Find (Container : Set; Key : Key_Type) return Cursor;\n+      --  Returns a cursor designating the first element in Container whose key\n+      --  is equivalent to Key. If there is no equivalent element, it returns\n+      --  No_Element.\n \n       function Floor (Container : Set; Key : Key_Type) return Cursor;\n+      --  If Container is empty, the function returns No_Element. If Item is\n+      --  equivalent to the keys of elements in Container, it returns a cursor\n+      --  designating the first such element. Otherwise, it returns a cursor\n+      --  designating the largest element whose key is less than Item, or\n+      --  No_Element if all keys are greater than Item.\n \n       function Ceiling (Container : Set; Key : Key_Type) return Cursor;\n+      --  If Container is empty, the function returns No_Element. If Item is\n+      --  equivalent to the keys of elements of Container, it returns a cursor\n+      --  designating the last such element. Otherwise, it returns a cursor\n+      --  designating the smallest element whose key is greater than Item, or\n+      --  No_Element if all keys are less than Item.\n \n       function Contains (Container : Set; Key : Key_Type) return Boolean;\n+      --  Equivalent to Find (Container, Key) /= No_Element\n \n-      procedure Update_Element\n+      procedure Update_Element  -- Update_Element_Preserving_Key ???\n         (Container : in out Set;\n          Position  : Cursor;\n          Process   : not null access\n                        procedure (Element : in out Element_Type));\n+      --  If Position equals No_Element, then Constraint_Error is raised. If\n+      --  Position is associated with a set object different from Container,\n+      --  then Program_Error is raised. Otherwise, it makes a copy of the key\n+      --  of the element designated by Position, and then calls Process with\n+      --  the element as the parameter. Update_Element then compares the key\n+      --  value obtained before calling Process to the key value obtained from\n+      --  the element after calling Process. If the keys are equivalent then\n+      --  the operation terminates. If Container is busy (cursor tampering has\n+      --  been attempted), then Program_Error is raised. Otherwise, the node\n+      --  is moved to its new position (in canonical order).\n \n       procedure Iterate\n         (Container : Set;\n          Key       : Key_Type;\n          Process   : not null access procedure (Position : Cursor));\n+      --  Call Process with a cursor designating each element equivalent to\n+      --  Key, in order from Floor (Container, Key) to\n+      --  Ceiling (Container, Key).\n \n       procedure Reverse_Iterate\n         (Container : Set;\n          Key       : Key_Type;\n          Process   : not null access procedure (Position : Cursor));\n+      --  Call Process with a cursor designating each element equivalent to\n+      --  Key, in order from Ceiling (Container, Key) to\n+      --  Floor (Container, Key).\n \n    end Generic_Keys;\n "}, {"sha": "6175c2f3daa7911d3f20fedc0d5efa6b8472d375", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ed69f611a49303c68258905e067c1c5888b9248/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ed69f611a49303c68258905e067c1c5888b9248/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=1ed69f611a49303c68258905e067c1c5888b9248", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2077,14 +2077,10 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       declare\n-         EI : Element_Type renames Container.Elements.EA (I);\n-         EJ : Element_Type renames Container.Elements.EA (J);\n-\n-         EI_Copy : constant Element_Type := EI;\n-\n+         EI_Copy : constant Element_Type := Container.Elements.EA (I);\n       begin\n-         EI := EJ;\n-         EJ := EI_Copy;\n+         Container.Elements.EA (I) := Container.Elements.EA (J);\n+         Container.Elements.EA (J) := EI_Copy;\n       end;\n    end Swap;\n "}, {"sha": "b1a6d1a3f8b837aea0ae772e6f2910ab8c8f2d58", "filename": "gcc/ada/a-coormu.ads", "status": "modified", "additions": 180, "deletions": 6, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ed69f611a49303c68258905e067c1c5888b9248/gcc%2Fada%2Fa-coormu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ed69f611a49303c68258905e067c1c5888b9248/gcc%2Fada%2Fa-coormu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coormu.ads?ref=1ed69f611a49303c68258905e067c1c5888b9248", "patch": "@@ -8,10 +8,6 @@\n --                                                                          --\n --          Copyright (C) 2004-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n -- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n@@ -33,7 +29,9 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n---  Documentation is needed for this unit ???\n+--  The ordered multiset container is similar to the ordered set, but with the\n+--  difference that multiple equivalent elements are allowed. It also provides\n+--  additional operations, to iterate over items that are equivalent.\n \n private with Ada.Containers.Red_Black_Trees;\n private with Ada.Finalization;\n@@ -50,6 +48,8 @@ package Ada.Containers.Ordered_Multisets is\n    pragma Remote_Types;\n \n    function Equivalent_Elements (Left, Right : Element_Type) return Boolean;\n+   --  Returns False if Left is less than Right, or Right is less than Left;\n+   --  otherwise, it returns True.\n \n    type Set is tagged private;\n    pragma Preelaborable_Initialization (Set);\n@@ -58,42 +58,93 @@ package Ada.Containers.Ordered_Multisets is\n    pragma Preelaborable_Initialization (Cursor);\n \n    Empty_Set : constant Set;\n+   --  The default value for set objects declared without an explicit\n+   --  initialization expression.\n \n    No_Element : constant Cursor;\n+   --  The default value for cursor objects declared without an explicit\n+   --  initialization expression.\n \n    function \"=\" (Left, Right : Set) return Boolean;\n+   --  If Left denotes the same set object as Right, then equality returns\n+   --  True. If the length of Left is different from the length of Right, then\n+   --  it returns False. Otherwise, set equality iterates over Left and Right,\n+   --  comparing the element of Left to the element of Right using the equality\n+   --  operator for elements. If the elements compare False, then the iteration\n+   --  terminates and set equality returns False. Otherwise, if all elements\n+   --  compare True, then set equality returns True.\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean;\n+   --  Similar to set equality, but with the difference that elements are\n+   --  compared for equivalence instead of equality.\n \n    function To_Set (New_Item : Element_Type) return Set;\n+   --  Constructs a set object with New_Item as its single element\n \n    function Length (Container : Set) return Count_Type;\n+   --  Returns the total number of elements in Container\n \n    function Is_Empty (Container : Set) return Boolean;\n+   --  Returns True if Container.Length is 0\n \n    procedure Clear (Container : in out Set);\n+   --  Deletes all elements from Container\n \n    function Element (Position : Cursor) return Element_Type;\n+   --  If Position equals No_Element, then Constraint_Error is raised.\n+   --  Otherwise, function Element returns the element designed by Position.\n \n    procedure Replace_Element\n      (Container : in out Set;\n       Position  : Cursor;\n       New_Item  : Element_Type);\n+   --  If Position equals No_Element, then Constraint_Error is raised. If\n+   --  Position is associated with a set different from Container, then\n+   --  Program_Error is raised. If New_Item is equivalent to the element\n+   --  designated by Position, then if Container is locked (element tampering\n+   --  has been attempted), Program_Error is raised; otherwise, the element\n+   --  designated by Position is assigned the value of New_Item. If New_Item is\n+   --  not equivalent to the element designated by Position, then if the\n+   --  container is busy (cursor tampering has been attempted), Program_Error\n+   --  is raised; otherwise, the element designed by Position is assigned the\n+   --  value of New_Item, and the node is moved to its new position (in\n+   --  canonical insertion order).\n \n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n+   --  If Position equals No_Element, then Constraint_Error is\n+   --  raised. Otherwise, it calls Process with the element designated by\n+   --  Position as the parameter. This call locks the container, so attempts to\n+   --  change the value of the element while Process is executing (to \"tamper\n+   --  with elements\") will raise Program_Error.\n \n    procedure Move (Target : in out Set; Source : in out Set);\n+   --  If Target denotes the same object as Source, the operation does\n+   --  nothing. If either Target or Source is busy (cursor tampering is\n+   --  attempted), then it raises Program_Error. Otherwise, Target is cleared,\n+   --  and the nodes from Source are moved (not copied) to Target (so Source\n+   --  becomes empty).\n \n    procedure Insert\n      (Container : in out Set;\n       New_Item  : Element_Type;\n       Position  : out Cursor);\n+   --  Insert adds New_Item to Container, and returns cursor Position\n+   --  designating the newly inserted node. The node is inserted after any\n+   --  existing elements less than or equivalent to New_Item (and before any\n+   --  elements greater than New_Item). Note that the issue of where the new\n+   --  node is inserted relative to equivalent elements does not arise for\n+   --  unique-key containers, since in that case the insertion would simply\n+   --  fail. For a multiple-key container (the case here), insertion always\n+   --  succeeds, and is defined such that the new item is positioned after any\n+   --  equivalent elements already in the container.\n \n    procedure Insert\n      (Container : in out Set;\n       New_Item  : Element_Type);\n+   --  Inserts New_Item in Container, but does not return a cursor designating\n+   --  the newly-inserted node.\n \n --  TODO: include Replace too???\n --\n@@ -104,102 +155,188 @@ package Ada.Containers.Ordered_Multisets is\n    procedure Exclude\n      (Container : in out Set;\n       Item      : Element_Type);\n+   --  Deletes from Container all of the elements equivalent to Item\n \n    procedure Delete\n      (Container : in out Set;\n       Item      : Element_Type);\n+   --  Deletes from Container all of the elements equivalent to Item. If there\n+   --  are no elements equivalent to Item, then it raises Constraint_Error.\n \n    procedure Delete\n      (Container : in out Set;\n       Position  : in out Cursor);\n+   --  If Position equals No_Element, then Constraint_Error is raised. If\n+   --  Position is associated with a set different from Container, then\n+   --  Program_Error is raised. Otherwise, the node designated by Position is\n+   --  removed from Container, and Position is set to No_Element.\n \n    procedure Delete_First (Container : in out Set);\n+   --  Removes the first node from Container\n \n    procedure Delete_Last (Container : in out Set);\n+   --  Removes the last node from Container\n \n    procedure Union (Target : in out Set; Source : Set);\n+   --  If Target is busy (cursor tampering is attempted), the Program_Error is\n+   --  raised. Otherwise, it inserts each element of Source into\n+   --  Target. Elements are inserted in the canonical order for multisets, such\n+   --  that the elements from Source are inserted after equivalent elements\n+   --  already in Target.\n \n    function Union (Left, Right : Set) return Set;\n+   --  Returns a set comprising the all elements from Left and all of the\n+   --  elements from Right. The elements from Right follow the equivalent\n+   --  elements from Left.\n \n    function \"or\" (Left, Right : Set) return Set renames Union;\n \n    procedure Intersection (Target : in out Set; Source : Set);\n+   --  If Target denotes the same object as Source, the operation does\n+   --  nothing. If Target is busy (cursor tampering is attempted),\n+   --  Program_Error is raised. Otherwise, the elements in Target having no\n+   --  equivalent element in Source are deleted from Target.\n \n    function Intersection (Left, Right : Set) return Set;\n+   --  If Left denotes the same object as Right, then the function returns a\n+   --  copy of Left. Otherwise, it returns a set comprising the equivalent\n+   --  elements from both Left and Right. Items are inserted in the result set\n+   --  in canonical order, such that the elements from Left precede the\n+   --  equivalent elements from Right.\n \n    function \"and\" (Left, Right : Set) return Set renames Intersection;\n \n    procedure Difference (Target : in out Set; Source : Set);\n+   --  If Target is busy (cursor tampering is attempted), then Program_Error is\n+   --  raised. Otherwise, the elements in Target that are equivalent to\n+   --  elements in Source are deleted from Target.\n \n    function Difference (Left, Right : Set) return Set;\n+   --  Returns a set comprising the elements from Left that have no equivalent\n+   --  element in Right.\n \n    function \"-\" (Left, Right : Set) return Set renames Difference;\n \n    procedure Symmetric_Difference (Target : in out Set; Source : Set);\n+   --  If Target is busy, then Program_Error is raised. Otherwise, the elements\n+   --  in Target equivalent to elements in Source are deleted from Target, and\n+   --  the elements in Source not equivalent to elements in Target are inserted\n+   --  into Target.\n \n    function Symmetric_Difference (Left, Right : Set) return Set;\n+   --  Returns a set comprising the union of the elements from Target having no\n+   --  equivalent in Source, and the elements of Source having no equivalent in\n+   --  Target.\n \n    function \"xor\" (Left, Right : Set) return Set renames Symmetric_Difference;\n \n    function Overlap (Left, Right : Set) return Boolean;\n+   --  Returns True if Left contains an element equivalent to an element of\n+   --  Right.\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n+   --  Returns True if every element in Subset has an equivalent element in\n+   --  Of_Set.\n \n    function First (Container : Set) return Cursor;\n+   --  If Container is empty, the function returns No_Element. Otherwise, it\n+   --  returns a cursor designating the smallest element.\n \n    function First_Element (Container : Set) return Element_Type;\n+   --  Equivalent to Element (First (Container))\n \n    function Last (Container : Set) return Cursor;\n+   --  If Container is empty, the function returns No_Element. Otherwise, it\n+   --  returns a cursor designating the largest element.\n \n    function Last_Element (Container : Set) return Element_Type;\n+   --  Equivalent to Element (Last (Container))\n \n    function Next (Position : Cursor) return Cursor;\n+   --  If Position equals No_Element or Last (Container), the function returns\n+   --  No_Element. Otherwise, it returns a cursor designating the node that\n+   --  immediately follows (as per the insertion order) the node designated by\n+   --  Position.\n \n    procedure Next (Position : in out Cursor);\n+   --  Equivalent to Position := Next (Position)\n \n    function Previous (Position : Cursor) return Cursor;\n+   --  If Position equals No_Element or First (Container), the function returns\n+   --  No_Element. Otherwise, it returns a cursor designating the node that\n+   --  immediately precedes (as per the insertion order) the node designated by\n+   --  Position.\n \n    procedure Previous (Position : in out Cursor);\n+   --  Equivalent to Position := Previous (Position)\n \n    function Find (Container : Set; Item : Element_Type) return Cursor;\n+   --  Returns a cursor designating the first element in Container equivalent\n+   --  to Item. If there is no equivalent element, it returns No_Element.\n \n    function Floor (Container : Set; Item : Element_Type) return Cursor;\n+   --  If Container is empty, the function returns No_Element. If Item is\n+   --  equivalent to elements in Container, it returns a cursor designating the\n+   --  first equivalent element. Otherwise, it returns a cursor designating the\n+   --  largest element less than Item, or No_Element if all elements are\n+   --  greater than Item.\n \n    function Ceiling (Container : Set; Item : Element_Type) return Cursor;\n+   --  If Container is empty, the function returns No_Element. If Item is\n+   --  equivalent to elements of Container, it returns a cursor designating the\n+   --  last equivalent element. Otherwise, it returns a cursor designating the\n+   --  smallest element greater than Item, or No_Element if all elements are\n+   --  less than Item.\n \n    function Contains (Container : Set; Item : Element_Type) return Boolean;\n+   --  Equivalent to Container.Find (Item) /= No_Element\n \n    function Has_Element (Position : Cursor) return Boolean;\n+   --  Equivalent to Position /= No_Element\n \n    function \"<\" (Left, Right : Cursor) return Boolean;\n+   --  Equivalent to Element (Left) < Element (Right)\n \n    function \">\" (Left, Right : Cursor) return Boolean;\n+   --  Equivalent to Element (Right) < Element (Left)\n \n    function \"<\" (Left : Cursor; Right : Element_Type) return Boolean;\n+   --  Equivalent to Element (Left) < Right\n \n    function \">\" (Left : Cursor; Right : Element_Type) return Boolean;\n+   --  Equivalent to Right < Element (Left)\n \n    function \"<\" (Left : Element_Type; Right : Cursor) return Boolean;\n+   --  Equivalent to Left < Element (Right)\n \n    function \">\" (Left : Element_Type; Right : Cursor) return Boolean;\n+   --  Equivalent to Element (Right) < Left\n \n    procedure Iterate\n      (Container : Set;\n       Process   : not null access procedure (Position : Cursor));\n+   --  Calls Process with a cursor designating each element of Container, in\n+   --  order from Container.First to Container.Last.\n \n    procedure Reverse_Iterate\n      (Container : Set;\n       Process   : not null access procedure (Position : Cursor));\n+   --  Calls Process with a cursor designating each element of Container, in\n+   --  order from Container.Last to Container.First.\n \n    procedure Iterate\n      (Container : Set;\n       Item      : Element_Type;\n       Process   : not null access procedure (Position : Cursor));\n+   --  Call Process with a cursor designating each element equivalent to Item,\n+   --  in order from Container.Floor (Item) to Container.Ceiling (Item).\n \n    procedure Reverse_Iterate\n      (Container : Set;\n       Item      : Element_Type;\n       Process   : not null access procedure (Position : Cursor));\n+   --  Call Process with a cursor designating each element equivalent to Item,\n+   --  in order from Container.Ceiling (Item) to Container.Floor (Item).\n \n    generic\n       type Key_Type (<>) is private;\n@@ -211,38 +348,75 @@ package Ada.Containers.Ordered_Multisets is\n    package Generic_Keys is\n \n       function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+      --  Returns False if Left is less than Right, or Right is less than Left;\n+      --  otherwise, it returns True.\n \n       function Key (Position : Cursor) return Key_Type;\n+      --  Equivalent to Key (Element (Position))\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type;\n+      --  Equivalent to Element (Find (Container, Key))\n \n       procedure Exclude (Container : in out Set; Key : Key_Type);\n+      --  Deletes from Container any elements whose key is equivalent to Key\n \n       procedure Delete (Container : in out Set; Key : Key_Type);\n+      --  Deletes from Container any elements whose key is equivalent to\n+      --  Key. If there are no such elements, then it raises Constraint_Error.\n \n       function Find (Container : Set; Key : Key_Type) return Cursor;\n+      --  Returns a cursor designating the first element in Container whose key\n+      --  is equivalent to Key. If there is no equivalent element, it returns\n+      --  No_Element.\n \n       function Floor (Container : Set; Key : Key_Type) return Cursor;\n+      --  If Container is empty, the function returns No_Element. If Item is\n+      --  equivalent to the keys of elements in Container, it returns a cursor\n+      --  designating the first such element. Otherwise, it returns a cursor\n+      --  designating the largest element whose key is less than Item, or\n+      --  No_Element if all keys are greater than Item.\n \n       function Ceiling (Container : Set; Key : Key_Type) return Cursor;\n+      --  If Container is empty, the function returns No_Element. If Item is\n+      --  equivalent to the keys of elements of Container, it returns a cursor\n+      --  designating the last such element. Otherwise, it returns a cursor\n+      --  designating the smallest element whose key is greater than Item, or\n+      --  No_Element if all keys are less than Item.\n \n       function Contains (Container : Set; Key : Key_Type) return Boolean;\n+      --  Equivalent to Find (Container, Key) /= No_Element\n \n-      procedure Update_Element\n+      procedure Update_Element  -- Update_Element_Preserving_Key ???\n         (Container : in out Set;\n          Position  : Cursor;\n          Process   : not null access\n                        procedure (Element : in out Element_Type));\n+      --  If Position equals No_Element, then Constraint_Error is raised. If\n+      --  Position is associated with a set object different from Container,\n+      --  then Program_Error is raised. Otherwise, it makes a copy of the key\n+      --  of the element designated by Position, and then calls Process with\n+      --  the element as the parameter. Update_Element then compares the key\n+      --  value obtained before calling Process to the key value obtained from\n+      --  the element after calling Process. If the keys are equivalent then\n+      --  the operation terminates. If Container is busy (cursor tampering has\n+      --  been attempted), then Program_Error is raised. Otherwise, the node\n+      --  is moved to its new position (in canonical order).\n \n       procedure Iterate\n         (Container : Set;\n          Key       : Key_Type;\n          Process   : not null access procedure (Position : Cursor));\n+      --  Call Process with a cursor designating each element equivalent to\n+      --  Key, in order from Floor (Container, Key) to\n+      --  Ceiling (Container, Key).\n \n       procedure Reverse_Iterate\n         (Container : Set;\n          Key       : Key_Type;\n          Process   : not null access procedure (Position : Cursor));\n+      --  Call Process with a cursor designating each element equivalent to\n+      --  Key, in order from Ceiling (Container, Key) to\n+      --  Floor (Container, Key).\n \n    end Generic_Keys;\n "}, {"sha": "a97f354d43e1f40e0fca1662f1e1f89509cb411a", "filename": "gcc/ada/a-crdlli.ads", "status": "modified", "additions": 124, "deletions": 6, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ed69f611a49303c68258905e067c1c5888b9248/gcc%2Fada%2Fa-crdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ed69f611a49303c68258905e067c1c5888b9248/gcc%2Fada%2Fa-crdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crdlli.ads?ref=1ed69f611a49303c68258905e067c1c5888b9248", "patch": "@@ -6,11 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n+--          Copyright (C) 2004-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,7 +29,15 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n---  Documentation required for this unit ???\n+--  The doubly-linked list container provides constant-time insertion and\n+--  deletion at all positions, and allows iteration in both the forward and\n+--  reverse directions. This list form allocates storage for all nodes\n+--  statically (there is no dynamic allocation), and a discriminant is used to\n+--  specify the capacity. This container is also \"restricted\", meaning that\n+--  even though it does raise exceptions (as described below), it does not use\n+--  internal exception handlers. No state changes are made that would need to\n+--  be reverted (in the event of an exception), and so as a consequence, this\n+--  container cannot detect tampering (of cursors or elements).\n \n generic\n    type Element_Type is private;\n@@ -51,139 +55,253 @@ package Ada.Containers.Restricted_Doubly_Linked_Lists is\n    pragma Preelaborable_Initialization (Cursor);\n \n    Empty_List : constant List;\n+   --  The default value for list objects declared without an explicit\n+   --  initialization expression.\n \n    No_Element : constant Cursor;\n+   --  The default value for cursor objects declared without an explicit\n+   --  initialization expression.\n \n    function \"=\" (Left, Right : List) return Boolean;\n+   --  If Left denotes the same list object as Right, then equality returns\n+   --  True. If the length of Left is different from the length of Right, then\n+   --  it returns False. Otherwise, list equality iterates over Left and Right,\n+   --  comparing the element of Left to the corresponding element of Right\n+   --  using the generic actual equality operator for elements. If the elements\n+   --  compare False, then the iteration terminates and list equality returns\n+   --  False. Otherwise, if all elements return True, then list equality\n+   --  returns True.\n \n    procedure Assign (Target : in out List; Source : List);\n+   --  If Target denotes the same list object as Source, the operation does\n+   --  nothing. If Target.Capacity is less than Source.Length, then it raises\n+   --  Constraint_Error. Otherwise, it clears Target, and then inserts each\n+   --  element of Source into Target.\n \n    function Length (Container : List) return Count_Type;\n+   --  Returns the total number of (active) elements in Container\n \n    function Is_Empty (Container : List) return Boolean;\n+   --  Returns True if Container.Length is 0\n \n    procedure Clear (Container : in out List);\n+   --  Deletes all elements from Container. Note that this is a bounded\n+   --  container and so the element is not \"deallocated\" in the same sense that\n+   --  an unbounded form would deallocate the element. Rather, the node is\n+   --  relinked off of the active part of the list and onto the inactive part\n+   --  of the list (the storage from which new elements are \"allocated\").\n \n    function Element (Position : Cursor) return Element_Type;\n+   --  If Position equals No_Element, then Constraint_Error is raised.\n+   --  Otherwise, function Element returns the element designed by Position.\n \n    procedure Replace_Element\n      (Container : in out List;\n       Position  : Cursor;\n       New_Item  : Element_Type);\n+   --  If Position equals No_Element, then Constraint_Error is raised. If\n+   --  Position is associated with a list object different from Container,\n+   --  Program_Error is raised. Otherwise, the element designated by Position\n+   --  is assigned the value New_Item.\n \n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n+   --  If Position equals No_Element, then Constraint_Error is raised.\n+   --  Otherwise, it calls Process with (a constant view of) the element\n+   --  designated by Position as the parameter.\n \n    procedure Update_Element\n      (Container : in out List;\n       Position  : Cursor;\n       Process   : not null access procedure (Element : in out Element_Type));\n+   --  If Position equals No_Element, then Constraint_Error is raised.\n+   --  Otherwise, it calls Process with (a variable view of) the element\n+   --  designated by Position as the parameter.\n \n    procedure Insert\n      (Container : in out List;\n       Before    : Cursor;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1);\n+   --  Inserts Count new elements, all with the value New_Item, into Container,\n+   --  immediately prior to the position specified by Before. If Before has the\n+   --  value No_Element, this is interpreted to mean that the elements are\n+   --  appended to the list. If Before is associated with a list object\n+   --  different from Container, then Program_Error is raised. If there are\n+   --  fewer than Count nodes available, then Constraint_Error is raised.\n \n    procedure Insert\n      (Container : in out List;\n       Before    : Cursor;\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n       Count     : Count_Type := 1);\n+   --  Inserts elements into Container as described above, but with the\n+   --  difference that cursor Position is returned, which designates the first\n+   --  of the new elements inserted. If Count is 0, Position returns the value\n+   --  Before.\n \n    procedure Insert\n      (Container : in out List;\n       Before    : Cursor;\n       Position  : out Cursor;\n       Count     : Count_Type := 1);\n+   --  Inserts elements in Container as described above, but with the\n+   --  difference that the new elements are initialized to the default value\n+   --  for objects of type Element_Type.\n \n    procedure Prepend\n      (Container : in out List;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1);\n+   --  Inserts Count elements, all having the value New_Item, prior to the\n+   --  first element of Container.\n \n    procedure Append\n      (Container : in out List;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1);\n+   --  Inserts Count elements, all having the value New_Item, following the\n+   --  last element of Container.\n \n    procedure Delete\n      (Container : in out List;\n       Position  : in out Cursor;\n       Count     : Count_Type := 1);\n+   --  If Position equals No_Element, Constraint_Error is raised. If Position\n+   --  is associated with a list object different from Container, then\n+   --  Program_Error is raised. Otherwise, the Count nodes starting from\n+   --  Position are removed from Container (\"removed\" meaning that the nodes\n+   --  are unlinked from the active nodes of the list and relinked to inactive\n+   --  storage). On return, Position is set to No_Element.\n \n    procedure Delete_First\n      (Container : in out List;\n       Count     : Count_Type := 1);\n+   --  Removes the first Count nodes from Container\n \n    procedure Delete_Last\n      (Container : in out List;\n       Count     : Count_Type := 1);\n+   --  Removes the last Count nodes from Container\n \n    procedure Reverse_Elements (Container : in out List);\n+   --  Relinks the nodes in reverse order\n \n    procedure Swap\n      (Container : in out List;\n       I, J      : Cursor);\n+   --  If I or J equals No_Element, then Constraint_Error is raised. If I or J\n+   --  is associated with a list object different from Container, then\n+   --  Program_Error is raised. Otherwise, Swap exchanges (copies) the values\n+   --  of the elements (on the nodes) designated by I and J.\n \n    procedure Swap_Links\n      (Container : in out List;\n       I, J      : Cursor);\n+   --  If I or J equals No_Element, then Constraint_Error is raised. If I or J\n+   --  is associated with a list object different from Container, then\n+   --  Program_Error is raised. Otherwise, Swap exchanges (relinks) the nodes\n+   --  designated by I and J.\n \n    procedure Splice\n      (Container : in out List;\n       Before    : Cursor;\n       Position  : in out Cursor);\n+   --  If Before is associated with a list object different from Container,\n+   --  then Program_Error is raised. If Position equals No_element, then\n+   --  Constraint_Error is raised; if it associated with a list object\n+   --  different from Container, then Program_Error is raised. Otherwise, the\n+   --  node designated by Position is relinked immediately prior to Before. If\n+   --  Before equals No_Element, this is interpreted to mean to move the node\n+   --  designed by Position to the last end of the list.\n \n    function First (Container : List) return Cursor;\n+   --  If Container is empty, the function returns No_Element. Otherwise, it\n+   --  returns a cursor designating the first element.\n \n    function First_Element (Container : List) return Element_Type;\n+   --  Equivalent to Element (First (Container))\n \n    function Last (Container : List) return Cursor;\n+   --  If Container is empty, the function returns No_Element. Otherwise, it\n+   --  returns a cursor designating the last element.\n \n    function Last_Element (Container : List) return Element_Type;\n+   --  Equivalent to Element (Last (Container))\n \n    function Next (Position : Cursor) return Cursor;\n+   --  If Position equals No_Element or Last (Container), the function returns\n+   --  No_Element. Otherwise, it returns a cursor designating the node that\n+   --  immediately follows the node designated by Position.\n \n    procedure Next (Position : in out Cursor);\n+   --  Equivalent to Position := Next (Position)\n \n    function Previous (Position : Cursor) return Cursor;\n+   --  If Position equals No_Element or First (Container), the function returns\n+   --  No_Element. Otherwise, it returns a cursor designating the node that\n+   --  immediately precedes the node designated by Position.\n \n    procedure Previous (Position : in out Cursor);\n+   --  Equivalent to Position := Previous (Position)\n \n    function Find\n      (Container : List;\n       Item      : Element_Type;\n       Position  : Cursor := No_Element) return Cursor;\n+   --  Searches for the node whose element is equal to Item, starting from\n+   --  Position and continuing to the last end of the list. If Position equals\n+   --  No_Element, the seach starts from the first node. If Position is\n+   --  associated with a list object different from Container, then\n+   --  Program_Error is raised. If no node is found having an element equal to\n+   --  Item, then Find returns No_Element.\n \n    function Reverse_Find\n      (Container : List;\n       Item      : Element_Type;\n       Position  : Cursor := No_Element) return Cursor;\n+   --  Searches in reverse for the node whose element is equal to Item,\n+   --  starting from Position and continuing to the first end of the list. If\n+   --  Position equals No_Element, the seach starts from the last node. If\n+   --  Position is associated with a list object different from Container, then\n+   --  Program_Error is raised. If no node is found having an element equal to\n+   --  Item, then Reverse_Find returns No_Element.\n \n    function Contains\n      (Container : List;\n       Item      : Element_Type) return Boolean;\n+   --  Equivalent to Container.Find (Item) /= No_Element\n \n    function Has_Element (Position : Cursor) return Boolean;\n+   --  Equivalent to Position /= No_Element\n \n    procedure Iterate\n      (Container : List;\n       Process   : not null access procedure (Position : Cursor));\n+   --  Calls Process with a cursor designating each element of Container, in\n+   --  order from Container.First to Container.Last.\n \n    procedure Reverse_Iterate\n      (Container : List;\n       Process   : not null access procedure (Position : Cursor));\n+   --  Calls Process with a cursor designating each element of Container, in\n+   --  order from Container.Last to Container.First.\n \n    generic\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n    package Generic_Sorting is\n \n       function Is_Sorted (Container : List) return Boolean;\n+      --  Returns False if there exists an element which is less than its\n+      --  predecessor.\n \n       procedure Sort (Container : in out List);\n+      --  Sorts the elements of Container (by relinking nodes), according to\n+      --  the order specified by the generic formal less-than operator, such\n+      --  that smaller elements are first in the list. The sort is stable,\n+      --  meaning that the relative order of elements is preserved.\n \n    end Generic_Sorting;\n "}, {"sha": "9c2dfc3319fa35bfdc5dc5fc27cd212353548766", "filename": "gcc/ada/a-secain.ads", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ed69f611a49303c68258905e067c1c5888b9248/gcc%2Fada%2Fa-secain.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ed69f611a49303c68258905e067c1c5888b9248/gcc%2Fada%2Fa-secain.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-secain.ads?ref=1ed69f611a49303c68258905e067c1c5888b9248", "patch": "@@ -6,14 +6,35 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT.  In accordance with the copyright of that document, you can freely --\n--- copy and modify this specification,  provided that if you redistribute a --\n--- modified version,  any changes that you have made are clearly indicated. --\n+--          Copyright (C) 2004-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n function Ada.Strings.Equal_Case_Insensitive\n   (Left, Right : String) return Boolean;\n-\n pragma Pure (Ada.Strings.Equal_Case_Insensitive);\n+--  Performs a case-insensitive equality test of Left and Right. This is\n+--  useful as the generic actual equivalence operation (Equivalent_Keys)\n+--  when instantiating a hashed container package with type String as the\n+--  key. It is also useful as the generic actual equality operator when\n+--  instantiating a container package with type String as the element,\n+--  allowing case-insensitive container equality tests."}, {"sha": "45f4ab340692afcd8e97fb9517b311b70df3aa26", "filename": "gcc/ada/a-shcain.ads", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ed69f611a49303c68258905e067c1c5888b9248/gcc%2Fada%2Fa-shcain.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ed69f611a49303c68258905e067c1c5888b9248/gcc%2Fada%2Fa-shcain.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-shcain.ads?ref=1ed69f611a49303c68258905e067c1c5888b9248", "patch": "@@ -6,16 +6,34 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT.  In accordance with the copyright of that document, you can freely --\n--- copy and modify this specification,  provided that if you redistribute a --\n--- modified version,  any changes that you have made are clearly indicated. --\n+--          Copyright (C) 2004-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n with Ada.Containers;\n \n function Ada.Strings.Hash_Case_Insensitive\n   (Key : String) return Containers.Hash_Type;\n-\n pragma Pure (Ada.Strings.Hash_Case_Insensitive);\n+--  Computes a hash value for Key without regard for character case. This is\n+--  useful as the generic actual Hash function when instantiating a hashed\n+--  container package with type String as the key."}, {"sha": "848c1b7f0210e0c2466a87deffdb16e35326da48", "filename": "gcc/ada/a-slcain.ads", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ed69f611a49303c68258905e067c1c5888b9248/gcc%2Fada%2Fa-slcain.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ed69f611a49303c68258905e067c1c5888b9248/gcc%2Fada%2Fa-slcain.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-slcain.ads?ref=1ed69f611a49303c68258905e067c1c5888b9248", "patch": "@@ -6,14 +6,33 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT.  In accordance with the copyright of that document, you can freely --\n--- copy and modify this specification,  provided that if you redistribute a --\n--- modified version,  any changes that you have made are clearly indicated. --\n+--          Copyright (C) 2004-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n function Ada.Strings.Less_Case_Insensitive\n   (Left, Right : String) return Boolean;\n-\n pragma Pure (Ada.Strings.Less_Case_Insensitive);\n+--  Performs a case-insensitive lexicographic comparison of Left and\n+--  Right. This is useful as the generic actual less-than operator when\n+--  instantiating an ordered container package with type String as the key,\n+--  allowing case-insensitive equivalence tests."}]}