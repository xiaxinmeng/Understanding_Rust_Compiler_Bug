{"sha": "618f40737410aa6b19cb60c9937adf4665dd587c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE4ZjQwNzM3NDEwYWE2YjE5Y2I2MGM5OTM3YWRmNDY2NWRkNTg3Yw==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2015-04-22T00:45:06Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2015-04-22T00:45:06Z"}, "message": "remove more ifdefs for HAVE_cc0\n\ngcc/ChangeLog:\n\n2015-04-21  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* caller-save.c (insert_one_insn): Remove ifdef HAVE_cc0.\n\t* cfgcleanup.c (flow_find_cross_jump): Likewise.\n\t(flow_find_head_matching_sequence): Likewise.\n\t(try_head_merge_bb): Likewise.\n\t* combine.c (can_combine_p): Likewise.\n\t(try_combine): Likewise.\n\t(distribute_notes): Likewise.\n\t* df-problems.c (can_move_insns_across): Likewise.\n\t* final.c (final): Likewise.\n\t* gcse.c (insert_insn_end_basic_block): Likewise.\n\t* ira.c (find_moveable_pseudos): Likewise.\n\t* reorg.c (try_merge_delay_insns): Likewise.\n\t(fill_simple_delay_slots): Likewise.\n\t(fill_slots_from_thread): Likewise.\n\t* sched-deps.c (sched_analyze_2): Likewise.\n\nFrom-SVN: r222302", "tree": {"sha": "5070818be5a8d7c61eb97763ad664a7fb72d2cb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5070818be5a8d7c61eb97763ad664a7fb72d2cb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/618f40737410aa6b19cb60c9937adf4665dd587c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/618f40737410aa6b19cb60c9937adf4665dd587c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/618f40737410aa6b19cb60c9937adf4665dd587c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/618f40737410aa6b19cb60c9937adf4665dd587c/comments", "author": null, "committer": null, "parents": [{"sha": "faa7b0dee624ffa4a04a25d4c1336bc747086329", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faa7b0dee624ffa4a04a25d4c1336bc747086329", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faa7b0dee624ffa4a04a25d4c1336bc747086329"}], "stats": {"total": 197, "additions": 87, "deletions": 110}, "files": [{"sha": "541a3d39ee4b853a15868a1e4345b26128a8183f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=618f40737410aa6b19cb60c9937adf4665dd587c", "patch": "@@ -1,3 +1,21 @@\n+2015-04-21  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* caller-save.c (insert_one_insn): Remove ifdef HAVE_cc0.\n+\t* cfgcleanup.c (flow_find_cross_jump): Likewise.\n+\t(flow_find_head_matching_sequence): Likewise.\n+\t(try_head_merge_bb): Likewise.\n+\t* combine.c (can_combine_p): Likewise.\n+\t(try_combine): Likewise.\n+\t(distribute_notes): Likewise.\n+\t* df-problems.c (can_move_insns_across): Likewise.\n+\t* final.c (final): Likewise.\n+\t* gcse.c (insert_insn_end_basic_block): Likewise.\n+\t* ira.c (find_moveable_pseudos): Likewise.\n+\t* reorg.c (try_merge_delay_insns): Likewise.\n+\t(fill_simple_delay_slots): Likewise.\n+\t(fill_slots_from_thread): Likewise.\n+\t* sched-deps.c (sched_analyze_2): Likewise.\n+\n 2015-04-21  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* df-scan.c (df_get_entry_block_def_set): Remove #ifdef"}, {"sha": "76c3a7e5263e694ccd5d00b4ef6ad7c5c58847c6", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=618f40737410aa6b19cb60c9937adf4665dd587c", "patch": "@@ -1400,18 +1400,16 @@ insert_one_insn (struct insn_chain *chain, int before_p, int code, rtx pat)\n   rtx_insn *insn = chain->insn;\n   struct insn_chain *new_chain;\n \n-#if HAVE_cc0\n   /* If INSN references CC0, put our insns in front of the insn that sets\n      CC0.  This is always safe, since the only way we could be passed an\n      insn that references CC0 is for a restore, and doing a restore earlier\n      isn't a problem.  We do, however, assume here that CALL_INSNs don't\n      reference CC0.  Guard against non-INSN's like CODE_LABEL.  */\n \n-  if ((NONJUMP_INSN_P (insn) || JUMP_P (insn))\n+  if (HAVE_cc0 && (NONJUMP_INSN_P (insn) || JUMP_P (insn))\n       && before_p\n       && reg_referenced_p (cc0_rtx, PATTERN (insn)))\n     chain = chain->prev, insn = chain->insn;\n-#endif\n \n   new_chain = new_insn_chain ();\n   if (before_p)"}, {"sha": "477b6da2e81621db4a4ac7e9ec8b397378ecdaea", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=618f40737410aa6b19cb60c9937adf4665dd587c", "patch": "@@ -1456,12 +1456,11 @@ flow_find_cross_jump (basic_block bb1, basic_block bb2, rtx_insn **f1,\n       i2 = PREV_INSN (i2);\n     }\n \n-#if HAVE_cc0\n   /* Don't allow the insn after a compare to be shared by\n      cross-jumping unless the compare is also shared.  */\n-  if (ninsns && reg_mentioned_p (cc0_rtx, last1) && ! sets_cc0_p (last1))\n+  if (HAVE_cc0 && ninsns && reg_mentioned_p (cc0_rtx, last1)\n+      && ! sets_cc0_p (last1))\n     last1 = afterlast1, last2 = afterlast2, last_dir = afterlast_dir, ninsns--;\n-#endif\n \n   /* Include preceding notes and labels in the cross-jump.  One,\n      this may bring us to the head of the blocks as requested above.\n@@ -1579,12 +1578,11 @@ flow_find_head_matching_sequence (basic_block bb1, basic_block bb2, rtx_insn **f\n       i2 = NEXT_INSN (i2);\n     }\n \n-#if HAVE_cc0\n   /* Don't allow a compare to be shared by cross-jumping unless the insn\n      after the compare is also shared.  */\n-  if (ninsns && reg_mentioned_p (cc0_rtx, last1) && sets_cc0_p (last1))\n+  if (HAVE_cc0 && ninsns && reg_mentioned_p (cc0_rtx, last1)\n+      && sets_cc0_p (last1))\n     last1 = beforelast1, last2 = beforelast2, ninsns--;\n-#endif\n \n   if (ninsns)\n     {\n@@ -2370,11 +2368,9 @@ try_head_merge_bb (basic_block bb)\n   cond = get_condition (jump, &move_before, true, false);\n   if (cond == NULL_RTX)\n     {\n-#if HAVE_cc0\n-      if (reg_mentioned_p (cc0_rtx, jump))\n+      if (HAVE_cc0 && reg_mentioned_p (cc0_rtx, jump))\n \tmove_before = prev_nonnote_nondebug_insn (jump);\n       else\n-#endif\n \tmove_before = jump;\n     }\n \n@@ -2539,11 +2535,9 @@ try_head_merge_bb (basic_block bb)\n       cond = get_condition (jump, &move_before, true, false);\n       if (cond == NULL_RTX)\n \t{\n-#if HAVE_cc0\n-\t  if (reg_mentioned_p (cc0_rtx, jump))\n+\t  if (HAVE_cc0 && reg_mentioned_p (cc0_rtx, jump))\n \t    move_before = prev_nonnote_nondebug_insn (jump);\n \t  else\n-#endif\n \t    move_before = jump;\n \t}\n     }\n@@ -2562,12 +2556,10 @@ try_head_merge_bb (basic_block bb)\n \t  /* Try again, using a different insertion point.  */\n \t  move_before = jump;\n \n-#if HAVE_cc0\n \t  /* Don't try moving before a cc0 user, as that may invalidate\n \t     the cc0.  */\n-\t  if (reg_mentioned_p (cc0_rtx, jump))\n+\t  if (HAVE_cc0 && reg_mentioned_p (cc0_rtx, jump))\n \t    break;\n-#endif\n \n \t  continue;\n \t}\n@@ -2622,12 +2614,10 @@ try_head_merge_bb (basic_block bb)\n \t  /* For the unmerged insns, try a different insertion point.  */\n \t  move_before = jump;\n \n-#if HAVE_cc0\n \t  /* Don't try moving before a cc0 user, as that may invalidate\n \t     the cc0.  */\n-\t  if (reg_mentioned_p (cc0_rtx, jump))\n+\t  if (HAVE_cc0 && reg_mentioned_p (cc0_rtx, jump))\n \t    break;\n-#endif\n \n \t  for (ix = 0; ix < nedges; ix++)\n \t    currptr[ix] = headptr[ix] = nextptr[ix];"}, {"sha": "6f0007af24e1f8bb0f3ec06fec5fd9c168543afc", "filename": "gcc/combine.c", "status": "modified", "additions": 21, "deletions": 33, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=618f40737410aa6b19cb60c9937adf4665dd587c", "patch": "@@ -2066,7 +2066,6 @@ can_combine_p (rtx_insn *insn, rtx_insn *i3, rtx_insn *pred ATTRIBUTE_UNUSED,\n       return 0;\n #endif\n \n-#if HAVE_cc0\n   /* Don't combine an insn that follows a CC0-setting insn.\n      An insn that uses CC0 must not be separated from the one that sets it.\n      We do, however, allow I2 to follow a CC0-setting insn if that insn\n@@ -2076,11 +2075,13 @@ can_combine_p (rtx_insn *insn, rtx_insn *i3, rtx_insn *pred ATTRIBUTE_UNUSED,\n      It would be more logical to test whether CC0 occurs inside I1 or I2,\n      but that would be much slower, and this ought to be equivalent.  */\n \n-  p = prev_nonnote_insn (insn);\n-  if (p && p != pred && NONJUMP_INSN_P (p) && sets_cc0_p (PATTERN (p))\n-      && ! all_adjacent)\n-    return 0;\n-#endif\n+  if (HAVE_cc0)\n+    {\n+      p = prev_nonnote_insn (insn);\n+      if (p && p != pred && NONJUMP_INSN_P (p) && sets_cc0_p (PATTERN (p))\n+\t  && ! all_adjacent)\n+\treturn 0;\n+    }\n \n   /* If we get here, we have passed all the tests and the combination is\n      to be allowed.  */\n@@ -3114,7 +3115,6 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \n   subst_insn = i3;\n \n-#if !HAVE_cc0\n   /* Many machines that don't use CC0 have insns that can both perform an\n      arithmetic operation and set the condition code.  These operations will\n      be represented as a PARALLEL with the first element of the vector\n@@ -3126,7 +3126,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n      needed, and make the PARALLEL by just replacing I2DEST in I3SRC with\n      I2SRC.  Later we will make the PARALLEL that contains I2.  */\n \n-  if (i1 == 0 && added_sets_2 && GET_CODE (PATTERN (i3)) == SET\n+  if (!HAVE_cc0 && i1 == 0 && added_sets_2 && GET_CODE (PATTERN (i3)) == SET\n       && GET_CODE (SET_SRC (PATTERN (i3))) == COMPARE\n       && CONST_INT_P (XEXP (SET_SRC (PATTERN (i3)), 1))\n       && rtx_equal_p (XEXP (SET_SRC (PATTERN (i3)), 0), i2dest))\n@@ -3216,7 +3216,6 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t  i2_is_used = 1;\n \t}\n     }\n-#endif\n \n   if (i2_is_used == 0)\n     {\n@@ -3644,9 +3643,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t are set between I2 and I3.  */\n       if (insn_code_number < 0\n           && (split = find_split_point (&newpat, i3, false)) != 0\n-#if HAVE_cc0\n-\t  && REG_P (i2dest)\n-#endif\n+\t  && (!HAVE_cc0 || REG_P (i2dest))\n \t  /* We need I2DEST in the proper mode.  If it is a hard register\n \t     or the only use of a pseudo, we can change its mode.\n \t     Make sure we don't change a hard register to have a mode that\n@@ -3916,9 +3913,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t  && !(GET_CODE (SET_DEST (set1)) == SUBREG\n \t       && find_reg_note (i2, REG_DEAD,\n \t\t\t\t SUBREG_REG (SET_DEST (set1))))\n-#if HAVE_cc0\n-\t  && !reg_referenced_p (cc0_rtx, set0)\n-#endif\n+\t  && (!HAVE_cc0 || !reg_referenced_p (cc0_rtx, set0))\n \t  /* If I3 is a jump, ensure that set0 is a jump so that\n \t     we do not create invalid RTL.  */\n \t  && (!JUMP_P (i3) || SET_DEST (set0) == pc_rtx)\n@@ -3933,9 +3928,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t       && !(GET_CODE (SET_DEST (set0)) == SUBREG\n \t\t    && find_reg_note (i2, REG_DEAD,\n \t\t\t\t      SUBREG_REG (SET_DEST (set0))))\n-#if HAVE_cc0\n-\t       && !reg_referenced_p (cc0_rtx, set1)\n-#endif\n+\t       && (!HAVE_cc0 || !reg_referenced_p (cc0_rtx, set1))\n \t       /* If I3 is a jump, ensure that set1 is a jump so that\n \t\t  we do not create invalid RTL.  */\n \t       && (!JUMP_P (i3) || SET_DEST (set1) == pc_rtx)\n@@ -4000,19 +3993,18 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t}\n     }\n \n-#if HAVE_cc0\n   /* If I2 is the CC0 setter and I3 is the CC0 user then check whether\n      they are adjacent to each other or not.  */\n-  {\n-    rtx_insn *p = prev_nonnote_insn (i3);\n-    if (p && p != i2 && NONJUMP_INSN_P (p) && newi2pat\n-\t&& sets_cc0_p (newi2pat))\n-      {\n-\tundo_all ();\n-\treturn 0;\n-      }\n-  }\n-#endif\n+  if (HAVE_cc0)\n+    {\n+      rtx_insn *p = prev_nonnote_insn (i3);\n+      if (p && p != i2 && NONJUMP_INSN_P (p) && newi2pat\n+\t  && sets_cc0_p (newi2pat))\n+\t{\n+\t  undo_all ();\n+\t  return 0;\n+\t}\n+    }\n \n   /* Only allow this combination if insn_rtx_costs reports that the\n      replacement instructions are cheaper than the originals.  */\n@@ -13796,9 +13788,7 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,\n \t\t    {\n \t\t      rtx set = single_set (tem_insn);\n \t\t      rtx inner_dest = 0;\n-#if HAVE_cc0\n \t\t      rtx_insn *cc0_setter = NULL;\n-#endif\n \n \t\t      if (set != 0)\n \t\t\tfor (inner_dest = SET_DEST (set);\n@@ -13842,7 +13832,6 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,\n \t\t\t  if (tem_insn == i2)\n \t\t\t    i2 = NULL;\n \n-#if HAVE_cc0\n \t\t\t  /* Delete the setter too.  */\n \t\t\t  if (cc0_setter)\n \t\t\t    {\n@@ -13859,7 +13848,6 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,\n \t\t\t      if (cc0_setter == i2)\n \t\t\t\ti2 = NULL;\n \t\t\t    }\n-#endif\n \t\t\t}\n \t\t      else\n \t\t\t{"}, {"sha": "d3d06eedc7c2ea91da6b9683f30b30d751625041", "filename": "gcc/df-problems.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=618f40737410aa6b19cb60c9937adf4665dd587c", "patch": "@@ -3859,10 +3859,7 @@ can_move_insns_across (rtx_insn *from, rtx_insn *to,\n       if (NONDEBUG_INSN_P (insn))\n \t{\n \t  if (!bitmap_intersect_p (test_set, local_merge_live)\n-#if HAVE_cc0\n-\t      && !sets_cc0_p (insn)\n-#endif\n-\t      )\n+\t      && (!HAVE_cc0 || !sets_cc0_p (insn)))\n \t    {\n \t      max_to = insn;\n \t      break;"}, {"sha": "231cfe56249ee89456f0dc59f1447b5efc67857e", "filename": "gcc/final.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=618f40737410aa6b19cb60c9937adf4665dd587c", "patch": "@@ -2029,21 +2029,20 @@ final (rtx_insn *first, FILE *file, int optimize_p)\n \n   last_ignored_compare = 0;\n \n-#if HAVE_cc0\n-  for (insn = first; insn; insn = NEXT_INSN (insn))\n-    {\n-      /* If CC tracking across branches is enabled, record the insn which\n-\t jumps to each branch only reached from one place.  */\n-      if (optimize_p && JUMP_P (insn))\n-\t{\n-\t  rtx lab = JUMP_LABEL (insn);\n-\t  if (lab && LABEL_P (lab) && LABEL_NUSES (lab) == 1)\n-\t    {\n-\t      LABEL_REFS (lab) = insn;\n-\t    }\n-\t}\n-    }\n-#endif\n+  if (HAVE_cc0)\n+    for (insn = first; insn; insn = NEXT_INSN (insn))\n+      {\n+\t/* If CC tracking across branches is enabled, record the insn which\n+\t   jumps to each branch only reached from one place.  */\n+\tif (optimize_p && JUMP_P (insn))\n+\t  {\n+\t    rtx lab = JUMP_LABEL (insn);\n+\t    if (lab && LABEL_P (lab) && LABEL_NUSES (lab) == 1)\n+\t      {\n+\t\tLABEL_REFS (lab) = insn;\n+\t      }\n+\t  }\n+      }\n \n   init_recog ();\n "}, {"sha": "e4303fea10aeb8a3421c409ae8ebf67b8fb5c036", "filename": "gcc/gcse.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=618f40737410aa6b19cb60c9937adf4665dd587c", "patch": "@@ -2048,21 +2048,23 @@ insert_insn_end_basic_block (struct gcse_expr *expr, basic_block bb)\n \t  && (!single_succ_p (bb)\n \t      || single_succ_edge (bb)->flags & EDGE_ABNORMAL)))\n     {\n-#if HAVE_cc0\n       /* FIXME: 'twould be nice to call prev_cc0_setter here but it aborts\n \t if cc0 isn't set.  */\n-      rtx note = find_reg_note (insn, REG_CC_SETTER, NULL_RTX);\n-      if (note)\n-\tinsn = safe_as_a <rtx_insn *> (XEXP (note, 0));\n-      else\n+      if (HAVE_cc0)\n \t{\n-\t  rtx_insn *maybe_cc0_setter = prev_nonnote_insn (insn);\n-\t  if (maybe_cc0_setter\n-\t      && INSN_P (maybe_cc0_setter)\n-\t      && sets_cc0_p (PATTERN (maybe_cc0_setter)))\n-\t    insn = maybe_cc0_setter;\n+\t  rtx note = find_reg_note (insn, REG_CC_SETTER, NULL_RTX);\n+\t  if (note)\n+\t    insn = safe_as_a <rtx_insn *> (XEXP (note, 0));\n+\t  else\n+\t    {\n+\t      rtx_insn *maybe_cc0_setter = prev_nonnote_insn (insn);\n+\t      if (maybe_cc0_setter\n+\t\t  && INSN_P (maybe_cc0_setter)\n+\t\t  && sets_cc0_p (PATTERN (maybe_cc0_setter)))\n+\t\tinsn = maybe_cc0_setter;\n+\t    }\n \t}\n-#endif\n+\n       /* FIXME: What if something in cc0/jump uses value set in new insn?  */\n       new_insn = emit_insn_before_noloc (pat, insn, bb);\n     }"}, {"sha": "25baa90845ac506302422d32aea25dbc81f6051a", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=618f40737410aa6b19cb60c9937adf4665dd587c", "patch": "@@ -4724,10 +4724,7 @@ find_moveable_pseudos (void)\n \t    {\n \t      if (bitmap_bit_p (def_bb_moveable, regno)\n \t\t  && !control_flow_insn_p (use_insn)\n-#if HAVE_cc0\n-\t\t  && !sets_cc0_p (use_insn)\n-#endif\n-\t\t  )\n+\t\t  && (!HAVE_cc0 || !sets_cc0_p (use_insn)))\n \t\t{\n \t\t  if (modified_between_p (DF_REF_REG (use), def_insn, use_insn))\n \t\t    {"}, {"sha": "45c7201c99e5fa65723be47fe352cf4f28dff23f", "filename": "gcc/reorg.c", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=618f40737410aa6b19cb60c9937adf4665dd587c", "patch": "@@ -1364,10 +1364,8 @@ try_merge_delay_insns (rtx insn, rtx_insn *thread)\n \tcontinue;\n \n       if (GET_CODE (next_to_match) == GET_CODE (trial)\n-#if HAVE_cc0\n \t  /* We can't share an insn that sets cc0.  */\n-\t  && ! sets_cc0_p (pat)\n-#endif\n+\t  && (!HAVE_cc0 || ! sets_cc0_p (pat))\n \t  && ! insn_references_resource_p (trial, &set, true)\n \t  && ! insn_sets_resource_p (trial, &set, true)\n \t  && ! insn_sets_resource_p (trial, &needed, true)\n@@ -1437,9 +1435,7 @@ try_merge_delay_insns (rtx insn, rtx_insn *thread)\n \t  if (! insn_references_resource_p (dtrial, &set, true)\n \t      && ! insn_sets_resource_p (dtrial, &set, true)\n \t      && ! insn_sets_resource_p (dtrial, &needed, true)\n-#if HAVE_cc0\n-\t      && ! sets_cc0_p (PATTERN (dtrial))\n-#endif\n+\t      && (!HAVE_cc0 || ! sets_cc0_p (PATTERN (dtrial)))\n \t      && rtx_equal_p (PATTERN (next_to_match), PATTERN (dtrial))\n \t      /* Check that DTRIAL and NEXT_TO_MATCH does not reference a \n \t         resource modified between them (only dtrial is checked because\n@@ -2114,10 +2110,8 @@ fill_simple_delay_slots (int non_jumps_p)\n \t\t\t\t\t     filter_flags ? &fset : &set,\n \t\t\t\t\t     true)\n \t\t  && ! insn_sets_resource_p (trial, &needed, true)\n-#if HAVE_cc0\n \t\t  /* Can't separate set of cc0 from its use.  */\n-\t\t  && ! (reg_mentioned_p (cc0_rtx, pat) && ! sets_cc0_p (pat))\n-#endif\n+\t\t  && (!HAVE_cc0 || ! (reg_mentioned_p (cc0_rtx, pat) && ! sets_cc0_p (pat)))\n \t\t  && ! can_throw_internal (trial))\n \t\t{\n \t\t  trial = try_split (pat, trial, 1);\n@@ -2249,9 +2243,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t\t  && ! insn_references_resource_p (trial, &set, true)\n \t\t  && ! insn_sets_resource_p (trial, &set, true)\n \t\t  && ! insn_sets_resource_p (trial, &needed, true)\n-#if HAVE_cc0\n-\t\t  && ! (reg_mentioned_p (cc0_rtx, pat) && ! sets_cc0_p (pat))\n-#endif\n+\t\t  && (!HAVE_cc0 && ! (reg_mentioned_p (cc0_rtx, pat) && ! sets_cc0_p (pat)))\n \t\t  && ! (maybe_never && may_trap_or_fault_p (pat))\n \t\t  && (trial = try_split (pat, trial, 0))\n \t\t  && eligible_for_delay (insn, slots_filled, trial, flags)\n@@ -2297,9 +2289,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t      && ! insn_references_resource_p (next_trial, &set, true)\n \t      && ! insn_sets_resource_p (next_trial, &set, true)\n \t      && ! insn_sets_resource_p (next_trial, &needed, true)\n-#if HAVE_cc0\n-\t      && ! reg_mentioned_p (cc0_rtx, PATTERN (next_trial))\n-#endif\n+\t      && (!HAVE_cc0 || ! reg_mentioned_p (cc0_rtx, PATTERN (next_trial)))\n \t      && ! (maybe_never && may_trap_or_fault_p (PATTERN (next_trial)))\n \t      && (next_trial = try_split (PATTERN (next_trial), next_trial, 0))\n \t      && eligible_for_delay (insn, slots_filled, next_trial, flags)\n@@ -2510,10 +2500,8 @@ fill_slots_from_thread (rtx_insn *insn, rtx condition, rtx thread_or_return,\n       if (! insn_references_resource_p (trial, &set, true)\n \t  && ! insn_sets_resource_p (trial, &set, true)\n \t  && ! insn_sets_resource_p (trial, &needed, true)\n-#if HAVE_cc0\n-\t  && ! (reg_mentioned_p (cc0_rtx, pat)\n-\t\t&& (! own_thread || ! sets_cc0_p (pat)))\n-#endif\n+\t  && (!HAVE_cc0 || (! (reg_mentioned_p (cc0_rtx, pat)\n+\t\t\t      && (! own_thread || ! sets_cc0_p (pat)))))\n \t  && ! can_throw_internal (trial))\n \t{\n \t  rtx prior_insn;"}, {"sha": "e62456325e28390d71b610d4dec379ccc71ab31a", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618f40737410aa6b19cb60c9937adf4665dd587c/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=618f40737410aa6b19cb60c9937adf4665dd587c", "patch": "@@ -2609,9 +2609,9 @@ sched_analyze_2 (struct deps_desc *deps, rtx x, rtx_insn *insn)\n       return;\n \n     case CC0:\n-#if !HAVE_cc0\n-      gcc_unreachable ();\n-#endif\n+      if (!HAVE_cc0)\n+\tgcc_unreachable ();\n+\n       /* User of CC0 depends on immediately preceding insn.  */\n       SCHED_GROUP_P (insn) = 1;\n        /* Don't move CC0 setter to another block (it can set up the"}]}