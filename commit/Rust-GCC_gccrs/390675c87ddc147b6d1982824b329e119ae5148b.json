{"sha": "390675c87ddc147b6d1982824b329e119ae5148b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkwNjc1Yzg3ZGRjMTQ3YjZkMTk4MjgyNGIzMjllMTE5YWU1MTQ4Yg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-02-03T00:24:52Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-02-03T00:24:52Z"}, "message": "ipa-devirt.c (subbinfo_with_vtable_at_offset, [...]): New functions.\n\n\t* ipa-devirt.c (subbinfo_with_vtable_at_offset,\n\tvtable_pointer_value_to_binfo): New functions.\n\t* ipa-utils.h (vtable_pointer_value_to_binfo): Declare.\n\t* ipa-prop.c (extr_type_from_vtbl_ptr_store): Use it.\n\t* g++.dg/ipa/devirt-23.C: New testcase.\n\t* g++.dg/ipa/devirt-20.C: Fix template.\n\nFrom-SVN: r207413", "tree": {"sha": "76bd028dd2a79384d67f52b8ff5e5cbe8b093dfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76bd028dd2a79384d67f52b8ff5e5cbe8b093dfa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/390675c87ddc147b6d1982824b329e119ae5148b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/390675c87ddc147b6d1982824b329e119ae5148b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/390675c87ddc147b6d1982824b329e119ae5148b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/390675c87ddc147b6d1982824b329e119ae5148b/comments", "author": null, "committer": null, "parents": [{"sha": "06fcf6c19c42b104bb0e8598c9f9f8cbd4a8b8c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06fcf6c19c42b104bb0e8598c9f9f8cbd4a8b8c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06fcf6c19c42b104bb0e8598c9f9f8cbd4a8b8c7"}], "stats": {"total": 149, "additions": 139, "deletions": 10}, "files": [{"sha": "39e69d378d0dd5153ec812da839ff150130e553e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390675c87ddc147b6d1982824b329e119ae5148b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390675c87ddc147b6d1982824b329e119ae5148b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=390675c87ddc147b6d1982824b329e119ae5148b", "patch": "@@ -1,3 +1,10 @@\n+2014-02-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-devirt.c (subbinfo_with_vtable_at_offset,\n+\tvtable_pointer_value_to_binfo): New functions.\n+\t* ipa-utils.h (vtable_pointer_value_to_binfo): Declare.\n+\t* ipa-prop.c (extr_type_from_vtbl_ptr_store): Use it.\n+\n 2014-02-02  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* config/nios2/nios2.md (load_got_register): Initialize GOT"}, {"sha": "dcaebdf8659346d41ab5d4fd0ba212234c4f3d4c", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390675c87ddc147b6d1982824b329e119ae5148b/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390675c87ddc147b6d1982824b329e119ae5148b/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=390675c87ddc147b6d1982824b329e119ae5148b", "patch": "@@ -972,6 +972,70 @@ contains_type_p (tree outer_type, HOST_WIDE_INT offset,\n   return get_class_context (&context, otr_type);\n }\n \n+/* Lookup base of BINFO that has virtual table VTABLE with OFFSET.  */\n+\n+static tree\n+subbinfo_with_vtable_at_offset (tree binfo, tree offset, tree vtable)\n+{\n+  tree v = BINFO_VTABLE (binfo);\n+  int i;\n+  tree base_binfo;\n+\n+  gcc_assert (!v || TREE_CODE (v) == POINTER_PLUS_EXPR);\n+  \n+  if (v && tree_int_cst_equal (TREE_OPERAND (v, 1), offset)\n+      && TREE_OPERAND (TREE_OPERAND (v, 0), 0) == vtable)\n+    return binfo;\n+  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+    if (polymorphic_type_binfo_p (base_binfo))\n+      {\n+\tbase_binfo = subbinfo_with_vtable_at_offset (base_binfo, offset, vtable);\n+\tif (base_binfo)\n+\t  return base_binfo;\n+      }\n+  return NULL;\n+}\n+\n+/* T is known constant value of virtual table pointer.  Return BINFO of the\n+   instance type.  */\n+\n+tree\n+vtable_pointer_value_to_binfo (tree t)\n+{\n+  /* We expect &MEM[(void *)&virtual_table + 16B].\n+     We obtain object's BINFO from the context of the virtual table. \n+     This one contains pointer to virtual table represented via\n+     POINTER_PLUS_EXPR.  Verify that this pointer match to what\n+     we propagated through.\n+\n+     In the case of virtual inheritance, the virtual tables may\n+     be nested, i.e. the offset may be different from 16 and we may\n+     need to dive into the type representation.  */\n+  if (t && TREE_CODE (t) == ADDR_EXPR\n+      && TREE_CODE (TREE_OPERAND (t, 0)) == MEM_REF\n+      && TREE_CODE (TREE_OPERAND (TREE_OPERAND (t, 0), 0)) == ADDR_EXPR\n+      && TREE_CODE (TREE_OPERAND (TREE_OPERAND (t, 0), 1)) == INTEGER_CST\n+      && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (TREE_OPERAND (t, 0), 0), 0))\n+\t  == VAR_DECL)\n+      && DECL_VIRTUAL_P (TREE_OPERAND (TREE_OPERAND\n+\t\t\t\t\t (TREE_OPERAND (t, 0), 0), 0)))\n+    {\n+      tree vtable = TREE_OPERAND (TREE_OPERAND (TREE_OPERAND (t, 0), 0), 0);\n+      tree offset = TREE_OPERAND (TREE_OPERAND (t, 0), 1);\n+      tree binfo = TYPE_BINFO (DECL_CONTEXT (vtable));\n+\n+      binfo = subbinfo_with_vtable_at_offset (binfo, offset, vtable);\n+\n+      /* FIXME: for stores of construction vtables we return NULL,\n+\t because we do not have BINFO for those. Eventually we should fix\n+\t our representation to allow this case to be handled, too.\n+\t In the case we see store of BINFO we however may assume\n+\t that standard folding will be ale to cope with it.  */\n+      return binfo;\n+    }\n+  return NULL;\n+}\n+\n /* Given REF call in FNDECL, determine class of the polymorphic\n    call (OTR_TYPE), its token (OTR_TOKEN) and CONTEXT.\n    Return pointer to object described by the context  */"}, {"sha": "3024414ab8ac5ed73eaea0bda6181d4e87d6c8cb", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390675c87ddc147b6d1982824b329e119ae5148b/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390675c87ddc147b6d1982824b329e119ae5148b/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=390675c87ddc147b6d1982824b329e119ae5148b", "patch": "@@ -591,21 +591,15 @@ static tree\n extr_type_from_vtbl_ptr_store (gimple stmt, struct type_change_info *tci)\n {\n   HOST_WIDE_INT offset, size, max_size;\n-  tree lhs, rhs, base;\n+  tree lhs, rhs, base, binfo;\n \n   if (!gimple_assign_single_p (stmt))\n     return NULL_TREE;\n \n   lhs = gimple_assign_lhs (stmt);\n   rhs = gimple_assign_rhs1 (stmt);\n   if (TREE_CODE (lhs) != COMPONENT_REF\n-      || !DECL_VIRTUAL_P (TREE_OPERAND (lhs, 1))\n-      || TREE_CODE (rhs) != ADDR_EXPR)\n-    return NULL_TREE;\n-  rhs = get_base_address (TREE_OPERAND (rhs, 0));\n-  if (!rhs\n-      || TREE_CODE (rhs) != VAR_DECL\n-      || !DECL_VIRTUAL_P (rhs))\n+      || !DECL_VIRTUAL_P (TREE_OPERAND (lhs, 1)))\n     return NULL_TREE;\n \n   base = get_ref_base_and_extent (lhs, &offset, &size, &max_size);\n@@ -624,7 +618,16 @@ extr_type_from_vtbl_ptr_store (gimple stmt, struct type_change_info *tci)\n   else if (tci->object != base)\n     return NULL_TREE;\n \n-  return DECL_CONTEXT (rhs);\n+  binfo = vtable_pointer_value_to_binfo (rhs);\n+\n+  /* FIXME: vtable_pointer_value_to_binfo may return BINFO of a\n+     base of outer type.  In this case we would need to either\n+     work on binfos or translate it back to outer type and offset.\n+     KNOWN_TYPE jump functions are not ready for that, yet.  */\n+  if (!binfo || TYPE_BINFO (BINFO_TYPE (binfo)) != binfo)\n+   return NULL;\n+\n+  return BINFO_TYPE (binfo);\n }\n \n /* Callback of walk_aliased_vdefs and a helper function for"}, {"sha": "3212f38cc4c04cdac0ea02286b6191920ec72571", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390675c87ddc147b6d1982824b329e119ae5148b/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390675c87ddc147b6d1982824b329e119ae5148b/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=390675c87ddc147b6d1982824b329e119ae5148b", "patch": "@@ -87,6 +87,7 @@ tree method_class_type (tree);\n tree get_polymorphic_call_info (tree, tree, tree *,\n \t\t\t\tHOST_WIDE_INT *,\n \t\t\t\tipa_polymorphic_call_context *);\n+tree vtable_pointer_value_to_binfo (tree t);\n \n /* Return vector containing possible targets of polymorphic call E.\n    If FINALP is non-NULL, store true if the list is complette. "}, {"sha": "284b5bbd52e8765b391cf8cf0b06584c6174a00e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390675c87ddc147b6d1982824b329e119ae5148b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390675c87ddc147b6d1982824b329e119ae5148b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=390675c87ddc147b6d1982824b329e119ae5148b", "patch": "@@ -1,6 +1,11 @@\n 2014-02-02  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* g++.dg/ipa/devirt-23.C: New testcase.\n+\t* g++.dg/ipa/devirt-20.C: Fix template.\n+\n+2014-02-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* g++.dg/ipa/devirt-21.C: New testcase.\n \n 2014-02-02  Richard Sandiford  <rdsandiford@googlemail.com>\n "}, {"sha": "0ea245bafdf4ed6508738347b4f6c6d8b120a1ca", "filename": "gcc/testsuite/g++.dg/ipa/devirt-20.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390675c87ddc147b6d1982824b329e119ae5148b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390675c87ddc147b6d1982824b329e119ae5148b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-20.C?ref=390675c87ddc147b6d1982824b329e119ae5148b", "patch": "@@ -28,4 +28,4 @@ main(void)\n   return 0;\n }\n /* { dg-final { scan-tree-dump-not \"abort\" \"release_ssa\"  } } */\n-/* { dg-final { cleanup-ipa-dump \"release_ssa\" } } */\n+/* { dg-final { cleanup-tree-dump \"release_ssa\" } } */"}, {"sha": "a32c7d6748377c46d4a707783feff746b252025b", "filename": "gcc/testsuite/g++.dg/ipa/devirt-23.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390675c87ddc147b6d1982824b329e119ae5148b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390675c87ddc147b6d1982824b329e119ae5148b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-23.C?ref=390675c87ddc147b6d1982824b329e119ae5148b", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fno-partial-inlining -fdump-ipa-cp -fno-devirtualize-speculatively\"  } */\n+/* Main purpose is to verify that we do not produce wrong devirtualization to\n+   C::m_fn1.  We currently devirtualize to B::m_fn1, so check that. */\n+#include <stdlib.h>\n+class A {\n+public:\n+  unsigned length;\n+};\n+class B {};\n+class MultiTermDocs : public virtual B {\n+protected:\n+  A readerTermDocs;\n+  A subReaders;\n+  virtual B *m_fn1(int *) {}\n+  virtual inline  ~MultiTermDocs();\n+  inline void wrap(void)\n+  {\n+  m_fn1(NULL);\n+  m_fn1(NULL);\n+  m_fn1(NULL);\n+  m_fn1(NULL);\n+  m_fn1(NULL);\n+  m_fn1(NULL);\n+  m_fn1(NULL);\n+  m_fn1(NULL);\n+  m_fn1(NULL);\n+  }\n+};\n+class C : MultiTermDocs {\n+  B *m_fn1(int *);\n+};\n+MultiTermDocs::~MultiTermDocs() {\n+  wrap ();\n+  if (&readerTermDocs) {\n+    B *a;\n+    for (unsigned i = 0; i < subReaders.length; i++)\n+      (a != 0);\n+  }\n+}\n+\n+B *C::m_fn1(int *) { abort (); }\n+\n+main()\n+{\n+  class C c;\n+}\n+/* { dg-final { scan-ipa-dump \"Discovered a virtual call to\" \"cp\" } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */"}]}