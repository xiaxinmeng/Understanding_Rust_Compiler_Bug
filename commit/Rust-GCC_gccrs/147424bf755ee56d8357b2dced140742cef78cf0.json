{"sha": "147424bf755ee56d8357b2dced140742cef78cf0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ3NDI0YmY3NTVlZTU2ZDgzNTdiMmRjZWQxNDA3NDJjZWY3OGNmMA==", "commit": {"author": {"name": "David Billinghurst", "email": "David.Billinghurst@riotinto.com", "date": "2001-07-15T12:50:14Z"}, "committer": {"name": "Toon Moene", "email": "toon@gcc.gnu.org", "date": "2001-07-15T12:50:14Z"}, "message": "f90-intrinsic-numeric.f: New test.\n\n2001-01-15  David Billinghurst <David.Billinghurst@riotinto.com>\n\n\t* g77.f-torture/execute/f90-intrinsic-numeric.f: New test.\n\t* g77.f-torture/execute/f90-intrinsic-mathematical.f: New test.\n\nFrom-SVN: r44020", "tree": {"sha": "49c93a9ad6d07f9710981d58adf616b3084cf86d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49c93a9ad6d07f9710981d58adf616b3084cf86d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/147424bf755ee56d8357b2dced140742cef78cf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/147424bf755ee56d8357b2dced140742cef78cf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/147424bf755ee56d8357b2dced140742cef78cf0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/147424bf755ee56d8357b2dced140742cef78cf0/comments", "author": null, "committer": null, "parents": [{"sha": "03598deac80a78f0d3d63680597af47e1330e289", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03598deac80a78f0d3d63680597af47e1330e289", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03598deac80a78f0d3d63680597af47e1330e289"}], "stats": {"total": 424, "additions": 424, "deletions": 0}, "files": [{"sha": "6fe608adccd5f0c9a99aee2effe43a9d3edca6b1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/147424bf755ee56d8357b2dced140742cef78cf0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/147424bf755ee56d8357b2dced140742cef78cf0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=147424bf755ee56d8357b2dced140742cef78cf0", "patch": "@@ -1,3 +1,8 @@\n+2001-01-15  David Billinghurst <David.Billinghurst@riotinto.com>\n+\n+\t* g77.f-torture/execute/f90-intrinsic-numeric.f: New test.\n+\t* g77.f-torture/execute/f90-intrinsic-mathematical.f: New test.\n+\n 2001-07-14  Richard Henderson  <rth@redhat.com>\n \n \t* gcc.dg/iftrap-1.c: New."}, {"sha": "51147b2e06a1498ab66811db6f41a1045b4cac98", "filename": "gcc/testsuite/g77.f-torture/execute/f90-intrinsic-mathematical.f", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/147424bf755ee56d8357b2dced140742cef78cf0/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Ff90-intrinsic-mathematical.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/147424bf755ee56d8357b2dced140742cef78cf0/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Ff90-intrinsic-mathematical.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Ff90-intrinsic-mathematical.f?ref=147424bf755ee56d8357b2dced140742cef78cf0", "patch": "@@ -0,0 +1,137 @@\n+c  f90-intrinsic-mathematical.f\n+c\n+c Test Fortran 90 intrinsic mathematical functions - Section 13.10.3 and\n+13.13 \n+c     David Billinghurst <David.Billinghurst@riotinto.com>\n+c\n+c Notes:\n+c  * g77 does not fully comply with F90.  Noncompliances noted in comments.\n+c  * Section 13.12: Specific names for intrinsic functions tested in\n+intrinsic77.f\n+\n+      logical fail\n+      common /flags/ fail\n+      fail = .false.\n+\n+c     ACOS - Section 13.13.3\n+      call c_r(ACOS(0.54030231),1.0,'ACOS(real)')\n+      call c_d(ACOS(0.54030231d0),1.d0,'ACOS(double)')\n+\n+c     ASIN - Section 13.13.12\n+      call c_r(ASIN(0.84147098),1.0,'ASIN(real)')\n+      call c_d(ASIN(0.84147098d0),1.d0,'ASIN(double)')\n+\n+c     ATAN - Section 13.13.14\n+      call c_r(ATAN(1.5574077),1.0,'ATAN(real)')\n+      call c_d(ATAN(1.5574077d0),1.d0,'ATAN(double)')\n+      \n+c     ATAN2 - Section 13.13.15\n+      call c_r(ATAN2(1.5574077,1.),1.0,'ATAN2(real)')\n+      call c_d(ATAN2(1.5574077d0,1.d0),1.d0,'ATAN2(double)')\n+\n+c     COS - Section 13.13.22\n+      call c_r(COS(1.0),0.54030231,'COS(real)')\n+      call c_d(COS(1.d0),0.54030231d0,'COS(double)')\n+      call c_c(COS((1.,0.)),(0.54030231,0.),'COS(complex)')\n+      call c_z(COS((1.d0,0.d0)),(0.54030231d0,0.d0),\n+     $     'COS(double complex)')\n+\n+c     COSH - Section 13.13.23\n+      call c_r(COSH(1.0),1.5430806,'COSH(real)')\n+      call c_d(COSH(1.d0),1.5430806d0,'COSH(double)')\n+\n+c     EXP - Section 13.13.34\n+      call c_r(EXP(1.0),2.7182818,'EXP(real)')\n+      call c_d(EXP(1.d0),2.7182818d0,'EXP(double)')\n+      call c_c(EXP((1.,0.)),(2.7182818,0.),'EXP(complex)')\n+      call c_z(EXP((1.d0,0.d0)),(2.7182818d0,0.d0),\n+     $     'EXP(double complex)')\n+\n+c     LOG - Section 13.13.59\n+      call c_r(LOG(10.0),2.3025851,'LOG(real)')\n+      call c_d(LOG(10.d0),2.3025851d0,'LOG(double)')\n+      call c_c(LOG((10.,0.)),(2.3025851,0.),'LOG(complex)')\n+      call c_z(LOG((10.d0,0.)),(2.3025851d0,0.d0),\n+     $     'LOG(double complex)')\n+\n+c     LOG10 - Section 13.13.60\n+      call c_r(LOG10(10.0),1.0,'LOG10(real)')\n+      call c_d(LOG10(10.d0),1.d0,'LOG10(double)')\n+\n+c     SIN - Section 13.13.97\n+      call c_r(SIN(1.0),0.84147098,'SIN(real)')\n+      call c_d(SIN(1.d0),0.84147098d0,'SIN(double)')\n+      call c_c(SIN((1.,0.)),(0.84147098,0.),'SIN(complex)')\n+      call c_z(SIN((1.d0,0.d0)),(0.84147098d0,0.d0),\n+     $     'SIN(double complex)')\n+\n+c     SINH - Section 13.13.98\n+      call c_r(SINH(1.0),1.175201,'SINH(real)')\n+      call c_d(SINH(1.d0),1.175201d0,'SINH(double)')\n+\n+c     SQRT - Section 13.13.102\n+      call c_r(SQRT(4.0),2.0,'SQRT(real)')\n+      call c_d(SQRT(4.d0),2.d0,'SQRT(double)')\n+      call c_c(SQRT((4.,0.)),(2.,0.),'SQRT(complex)')\n+      call c_z(SQRT((4.d0,0.)),(2.d0,0.),\n+     $     'SQRT(double complex)')\n+ \n+c     TAN - Section 13.13.105\n+      call c_r(TAN(1.0),1.5574077,'TAN(real)')\n+      call c_d(TAN(1.d0),1.5574077d0,'TAN(double)')\n+     \n+c     TANH - Section 13.13.106\n+      call c_r(TANH(1.0),0.76159416,'TANH(real)')\n+      call c_d(TANH(1.d0),0.76159416d0,'TANH(double)')\n+\n+      if ( fail ) call abort()\n+      end\n+\n+      subroutine failure(label)\n+c     Report failure and set flag\n+      character*(*) label\n+      logical fail\n+      common /flags/ fail\n+      write(6,'(a,a,a)') 'Test ',label,' FAILED'\n+      fail = .true.\n+      end\n+\n+      subroutine c_r(a,b,label)\n+c     Check if REAL a equals b, and fail otherwise\n+      real a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0e-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end\n+\n+      subroutine c_d(a,b,label)\n+c     Check if DOUBLE PRECISION a equals b, and fail otherwise\n+      double precision a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0d-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end\n+\n+      subroutine c_c(a,b,label)\n+c     Check if COMPLEX a equals b, and fail otherwise\n+      complex a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0e-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end\n+\n+      subroutine c_z(a,b,label)\n+c     Check if COMPLEX a equals b, and fail otherwise\n+      double complex a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0d-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end"}, {"sha": "bdf7b750a67a1ffa2b2dc409f46e7d0daa6cfd32", "filename": "gcc/testsuite/g77.f-torture/execute/f90-intrinsic-numeric.f", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/147424bf755ee56d8357b2dced140742cef78cf0/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Ff90-intrinsic-numeric.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/147424bf755ee56d8357b2dced140742cef78cf0/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Ff90-intrinsic-numeric.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Ff90-intrinsic-numeric.f?ref=147424bf755ee56d8357b2dced140742cef78cf0", "patch": "@@ -0,0 +1,282 @@\n+c  f90-intrinsic-numeric.f\n+c\n+c Test Fortran 90 intrinsic numeric functions - Section 13.10.2 and 13.13 \n+c     David Billinghurst <David.Billinghurst@riotinto.com>\n+c\n+c Notes:\n+c  * g77 does not fully comply with F90.  Noncompliances noted in comments.\n+c  * Section 13.12: Specific names for intrinsic functions tested in\n+intrinsic77.f\n+\n+      logical fail\n+      integer*2 j, j2, ja\n+      integer*1 k, k2, ka\n+\n+      common /flags/ fail\n+      fail = .false.\n+\n+c     ABS - Section 13.13.1\n+      j = -9\n+      ja = 9\n+      k = j\n+      ka = ja\n+      call c_i(ABS(-7),7,'ABS(integer)')\n+      call c_i2(ABS(j),ja,'ABS(integer*2)')\n+      call c_i1(ABS(k),ka,'ABS(integer*1)')\n+      call c_r(ABS(-7.),7.,'ABS(real)')\n+      call c_d(ABS(-7.d0),7.d0,'ABS(double)')\n+      call c_r(ABS((3.,-4.)),5.0,'ABS(complex)')\n+      call c_d(ABS((3.d0,-4.d0)),5.0d0,'ABS(double complex)')\n+\n+c     AIMAG - Section 13.13.6\n+      call c_r(AIMAG((2.,-7.)),-7.,'AIMAG(complex)')\n+c     g77: AIMAG(double complex) does not comply with F90\n+c     call c_d(AIMAG((2.d0,-7.d0)),-7.d0,'AIMAG(double complex)')\n+\n+c     AINT - Section 13.13.7\n+      call c_r(AINT(2.783),2.0,'AINT(real) 1')\n+      call c_r(AINT(-2.783),-2.0,'AINT(real) 2')\n+      call c_d(AINT(2.783d0),2.0d0,'AINT(double precision) 1')\n+      call c_d(AINT(-2.783d0),-2.0d0,'AINT(double precision) 2')\n+c     Note:  g77 does not support optional argument KIND\n+\n+c     ANINT - Section 13.13.10\n+      call c_r(ANINT(2.783),3.0,'ANINT(real) 1')\n+      call c_r(ANINT(-2.783),-3.0,'ANINT(real) 2')\n+      call c_d(ANINT(2.783d0),3.0d0,'ANINT(double precision) 1')\n+      call c_d(ANINT(-2.783d0),-3.0d0,'ANINT(double precision) 2')  \n+c     Note:  g77 does not support optional argument KIND\n+\n+c     CEILING - Section 13.13.18\n+c     Not implemented\n+\n+c     CMPLX - Section 13.13.20\n+      j = 1\n+      ja = 2\n+      k = 1\n+      ka = 2\n+      call c_c(CMPLX(1),(1.,0.),'CMPLX(integer)')\n+      call c_c(CMPLX(1,2),(1.,2.),'CMPLX(integer, integer)')\n+      call c_c(CMPLX(j),(1.,0.),'CMPLX(integer*2)')\n+      call c_c(CMPLX(j,ja),(1.,2.),'CMPLX(integer*2, integer*2)')\n+      call c_c(CMPLX(k),(1.,0.),'CMPLX(integer*1)')\n+      call c_c(CMPLX(k,ka),(1.,2.),'CMPLX(integer*1, integer*1)')\n+      call c_c(CMPLX(1.),(1.,0.),'CMPLX(real)')\n+      call c_c(CMPLX(1.d0),(1.,0.),'CMPLX(double)')\n+      call c_c(CMPLX(1.d0,2.d0),(1.,2.),'CMPLX(double,double)')\n+      call c_c(CMPLX(1.,2.),(1.,2.),'CMPLX(complex)')\n+      call c_c(CMPLX(1.d0,2.d0),(1.,2.),'CMPLX(double complex)')\n+c     NOTE: g77 does not support optional argument KIND\n+   \n+c     CONJG - Section 13.13.21\n+      call c_c(CONJG((2.,-7.)),(2.,7.),'CONJG(complex)')\n+      call c_z(CONJG((2.d0,-7.d0)),(2.d0,7.d0),'CONJG(double complex)')\n+\n+c     DBLE - Section 13.13.27\n+      j = 5\n+      k = 5\n+      call c_d(DBLE(5),5.0d0,'DBLE(integer)')\n+      call c_d(DBLE(j),5.0d0,'DBLE(integer*2)')\n+      call c_d(DBLE(k),5.0d0,'DBLE(integer*1)')\n+      call c_d(DBLE(5.),5.0d0,'DBLE(real)')\n+      call c_d(DBLE(5.0d0),5.0d0,'DBLE(double)')\n+      call c_d(DBLE((5.0,0.5)),5.0d0,'DBLE(complex)')\n+      call c_d(DBLE((5.0d0,0.5d0)),5.0d0,'DBLE(double complex)')\n+\n+c     DIM - Section 13.13.29\n+      j = -8\n+      j2 = -3\n+      ja = 0\n+      k = -8\n+      k2 = -3\n+      ka = 0\n+      call c_i(DIM(-8,-3),0,'DIM(integer)')\n+      call c_i2(DIM(j,j2),ja,'DIM(integer*2)')\n+      call c_i1(DIM(k,k2),ka,'DIM(integer*1)')\n+      call c_r(DIM(-8.,-3.),0.,'DIM(real,real)')\n+      call c_d(DIM(-8.d0,-3.d0),0.d0,'DIM(double,double)')\n+ \n+c     DPROD - Section 13.13.31\n+      call c_d(DPROD(-8.,-3.),24.d0,'DPROD(real,real)')\n+     \n+c     FLOOR - Section 13.13.36\n+c     Not implemented\n+\n+c     INT - Section 13.13.47\n+      j = 5\n+      k = 5\n+      call c_i(INT(5),5,'INT(integer)')\n+      call c_i(INT(j),5,'INT(integer*2)')\n+      call c_i(INT(k),5,'INT(integer*1)')\n+      call c_i(INT(5.01),5,'INT(real)')\n+      call c_i(INT(5.01d0),5,'INT(double)')\n+c     Note: Does not accept optional second argument KIND\n+\n+c     MAX - Section 13.13.63\n+      j = 1\n+      j2 = 2\n+      ja = 2\n+      k = 1\n+      k2 = 2\n+      ka = 2\n+      call c_i(MAX(1,2,3),3,'MAX(integer,integer,integer)')\n+      call c_i2(MAX(j,j2),ja,'MAX(integer*2,integer*2)')\n+      call c_i1(MAX(k,k2),ka,'MAX(integer*1,integer*1)')\n+      call c_r(MAX(1.,2.,3.),3.,'MAX(real,real,real)')\n+      call c_d(MAX(1.d0,2.d0,3.d0),3.d0,'MAX(double,double,double)')\n+\n+c     MIN - Section 13.13.68\n+      j = 1\n+      j2 = 2\n+      ja = 1\n+      k = 1\n+      k2 = 2\n+      ka = 1\n+      call c_i(MIN(1,2,3),1,'MIN(integer,integer,integer)')\n+      call c_i2(MIN(j,j2),ja,'MIN(integer*2,integer*2)')\n+      call c_i1(MIN(k,k2),ka,'MIN(integer*1,integer*1)')\n+      call c_r(MIN(1.,2.,3.),1.,'MIN(real,real,real)')\n+      call c_d(MIN(1.d0,2.d0,3.d0),1.d0,'MIN(double,double,double)')\n+\n+c     MOD - Section 13.13.72\n+      call c_i(MOD(8,5),3,'MOD(integer,integer) 1')\n+      call c_i(MOD(-8,5),-3,'MOD(integer,integer) 2')\n+      call c_i(MOD(8,-5),3,'MOD(integer,integer) 3')\n+      call c_i(MOD(-8,-5),-3,'MOD(integer,integer) 4')\n+      j = 8\n+      j2 = 5\n+      ja = 3\n+      call c_i2(MOD(j,j2),ja,'MOD(integer*2,integer*2) 1')\n+      call c_i2(MOD(-j,j2),-ja,'MOD(integer*2,integer*2) 2')\n+      call c_i2(MOD(j,-j2),ja,'MOD(integer*2,integer*2) 3')\n+      call c_i2(MOD(-j,-j2),-ja,'MOD(integer*2,integer*2) 4')\n+      k = 8\n+      k2 = 5\n+      ka = 3\n+      call c_i1(MOD(k,k2),ka,'MOD(integer*1,integer*1) 1')\n+      call c_i1(MOD(-k,k2),-ka,'MOD(integer*1,integer*1) 2')\n+      call c_i1(MOD(k,-k2),ka,'MOD(integer*1,integer*1) 3')\n+      call c_i1(MOD(-k,-k2),-ka,'MOD(integer*1,integer*1) 4')\n+      call c_r(MOD(8.,5.),3.,'MOD(real,real) 1')\n+      call c_r(MOD(-8.,5.),-3.,'MOD(real,real) 2')\n+      call c_r(MOD(8.,-5.),3.,'MOD(real,real) 3')\n+      call c_r(MOD(-8.,-5.),-3.,'MOD(real,real) 4')\n+      call c_d(MOD(8.d0,5.d0),3.d0,'MOD(double,double) 1')\n+      call c_d(MOD(-8.d0,5.d0),-3.d0,'MOD(double,double) 2')\n+      call c_d(MOD(8.d0,-5.d0),3.d0,'MOD(double,double) 3')\n+      call c_d(MOD(-8.d0,-5.d0),-3.d0,'MOD(double,double) 4')\n+\n+c     MODULO - Section 13.13.73\n+c     Not implemented\n+\n+c     NINT - Section 13.13.76\n+      call c_i(NINT(2.783),3,'NINT(real)')\n+      call c_i(NINT(2.783d0),3,'NINT(double)')\n+c     Optional second argument KIND not implemented\n+\n+c     REAL - Section 13.13.86\n+      j = -2\n+      k = -2\n+      call c_r(REAL(-2),-2.0,'REAL(integer)')\n+      call c_r(REAL(j),-2.0,'REAL(integer*2)')\n+      call c_r(REAL(k),-2.0,'REAL(integer*1)')\n+      call c_r(REAL(-2.0),-2.0,'REAL(real)')\n+      call c_r(REAL(-2.0d0),-2.0,'REAL(double)')\n+      call c_r(REAL((-2.,9.)),-2.0,'REAL(complex)')\n+c     REAL(double complex) not implemented\n+c     call c_r(REAL((-2.d0,9.d0)),-2.0,'REAL(double complex)')\n+\n+c     SIGN - Section 13.13.96\n+      j = -3\n+      j2 = 2\n+      ja = 3\n+      k = -3\n+      k2 = 2\n+      ka = 3\n+      call c_i(SIGN(-3,2),3,'SIGN(integer)')\n+      call c_i2(SIGN(j,j2),ja,'SIGN(integer*2)')\n+      call c_i1(SIGN(k,k2),ka,'SIGN(integer*1)')\n+      call c_r(SIGN(-3.0,2.),3.,'SIGN(real,real)')\n+      call c_d(SIGN(-3.d0,2.d0),3.d0,'SIGN(double,double)')\n+ \n+      if ( fail ) call abort()\n+      end\n+\n+      subroutine failure(label)\n+c     Report failure and set flag\n+      character*(*) label\n+      logical fail\n+      common /flags/ fail\n+      write(6,'(a,a,a)') 'Test ',label,' FAILED'\n+      fail = .true.\n+      end\n+\n+      subroutine c_i(i,j,label)\n+c     Check if INTEGER i equals j, and fail otherwise\n+      integer i,j\n+      character*(*) label\n+      if ( i .ne. j ) then\n+         call failure(label)\n+         write(6,*) 'Got ',i,' expected ', j\n+      end if\n+      end\n+\n+      subroutine c_i2(i,j,label)\n+c     Check if INTEGER*2 i equals j, and fail otherwise\n+      integer*2 i,j\n+      character*(*) label\n+      if ( i .ne. j ) then\n+         call failure(label)\n+         write(6,*) 'Got ',i,' expected ', j\n+      end if\n+      end\n+\n+      subroutine c_i1(i,j,label)\n+c     Check if INTEGER*1 i equals j, and fail otherwise\n+      integer*1 i,j\n+      character*(*) label\n+      if ( i .ne. j ) then\n+         call failure(label)\n+         write(6,*) 'Got ',i,' expected ', j\n+      end if\n+      end\n+\n+      subroutine c_r(a,b,label)\n+c     Check if REAL a equals b, and fail otherwise\n+      real a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0e-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end\n+\n+      subroutine c_d(a,b,label)\n+c     Check if DOUBLE PRECISION a equals b, and fail otherwise\n+      double precision a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0d-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end\n+\n+      subroutine c_c(a,b,label)\n+c     Check if COMPLEX a equals b, and fail otherwise\n+      complex a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0e-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end\n+\n+      subroutine c_z(a,b,label)\n+c     Check if COMPLEX a equals b, and fail otherwise\n+      double complex a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0d-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end"}]}