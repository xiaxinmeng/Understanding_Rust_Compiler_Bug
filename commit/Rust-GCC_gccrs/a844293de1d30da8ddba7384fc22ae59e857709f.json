{"sha": "a844293de1d30da8ddba7384fc22ae59e857709f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg0NDI5M2RlMWQzMGRhOGRkYmE3Mzg0ZmMyMmFlNTllODU3NzA5Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-29T07:47:05Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-29T07:47:05Z"}, "message": "Set the call nothrow flag more often\n\nThis patch sets the nothrow flag for various calls to internal functions\nthat are not inherently NOTHROW (and so can't be declared that way in\ninternal-fn.def) but that are used in contexts that can guarantee\nNOTHROWness.\n\n2017-08-29  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* gimplify.c (gimplify_call_expr): Copy the nothrow flag to\n\tcalls to internal functions.\n\t(gimplify_modify_expr): Likewise.\n\t* tree-call-cdce.c (use_internal_fn): Likewise.\n\t* tree-ssa-math-opts.c (pass_cse_reciprocals::execute): Likewise.\n\t(convert_to_divmod): Set the nothrow flag.\n\t* tree-if-conv.c (predicate_mem_writes):  Likewise.\n\t* tree-vect-stmts.c (vectorizable_mask_load_store): Likewise.\n\t(vectorizable_call): Likewise.\n\t(vectorizable_store): Likewise.\n\t(vectorizable_load): Likewise.\n\t* tree-vect-patterns.c (vect_recog_pow_pattern): Likewise.\n\t(vect_recog_mask_conversion_pattern): Likewise.\n\nFrom-SVN: r251401", "tree": {"sha": "29ae014a56a196ff0764a9dd8c569efb193cb413", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29ae014a56a196ff0764a9dd8c569efb193cb413"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a844293de1d30da8ddba7384fc22ae59e857709f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a844293de1d30da8ddba7384fc22ae59e857709f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a844293de1d30da8ddba7384fc22ae59e857709f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a844293de1d30da8ddba7384fc22ae59e857709f/comments", "author": null, "committer": null, "parents": [{"sha": "130fcab02f1fbb097fc52fc9a8892472e3fa0c6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/130fcab02f1fbb097fc52fc9a8892472e3fa0c6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/130fcab02f1fbb097fc52fc9a8892472e3fa0c6c"}], "stats": {"total": 108, "additions": 79, "deletions": 29}, "files": [{"sha": "f8f6491dea13d55f9341ec28db98f414779a858e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a844293de1d30da8ddba7384fc22ae59e857709f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a844293de1d30da8ddba7384fc22ae59e857709f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a844293de1d30da8ddba7384fc22ae59e857709f", "patch": "@@ -1,3 +1,19 @@\n+2017-08-29  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gimplify.c (gimplify_call_expr): Copy the nothrow flag to\n+\tcalls to internal functions.\n+\t(gimplify_modify_expr): Likewise.\n+\t* tree-call-cdce.c (use_internal_fn): Likewise.\n+\t* tree-ssa-math-opts.c (pass_cse_reciprocals::execute): Likewise.\n+\t(convert_to_divmod): Set the nothrow flag.\n+\t* tree-if-conv.c (predicate_mem_writes):  Likewise.\n+\t* tree-vect-stmts.c (vectorizable_mask_load_store): Likewise.\n+\t(vectorizable_call): Likewise.\n+\t(vectorizable_store): Likewise.\n+\t(vectorizable_load): Likewise.\n+\t* tree-vect-patterns.c (vect_recog_pow_pattern): Likewise.\n+\t(vect_recog_mask_conversion_pattern): Likewise.\n+\n 2017-08-29  Martin Liska  <mliska@suse.cz>\n \n \tPR other/39851"}, {"sha": "8b29a7179c51ffb96b97c8f847e74e9408e4d5f3", "filename": "gcc/gimplify.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a844293de1d30da8ddba7384fc22ae59e857709f/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a844293de1d30da8ddba7384fc22ae59e857709f/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=a844293de1d30da8ddba7384fc22ae59e857709f", "patch": "@@ -3150,7 +3150,8 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n \n       if (EXPR_CILK_SPAWN (*expr_p))\n         gimplify_cilk_detach (pre_p);\n-      gimple *call = gimple_build_call_internal_vec (ifn, vargs);\n+      gcall *call = gimple_build_call_internal_vec (ifn, vargs);\n+      gimple_call_set_nothrow (call, TREE_NOTHROW (*expr_p));\n       gimplify_seq_add_stmt (pre_p, call);\n       return GS_ALL_DONE;\n     }\n@@ -5636,6 +5637,7 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t      vargs.quick_push (CALL_EXPR_ARG (*from_p, i));\n \t    }\n \t  call_stmt = gimple_build_call_internal_vec (ifn, vargs);\n+\t  gimple_call_set_nothrow (call_stmt, TREE_NOTHROW (*from_p));\n \t  gimple_set_location (call_stmt, EXPR_LOCATION (*expr_p));\n \t}\n       else"}, {"sha": "1578350c0c63eb4f09618411f792f27167d54da7", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a844293de1d30da8ddba7384fc22ae59e857709f/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a844293de1d30da8ddba7384fc22ae59e857709f/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=a844293de1d30da8ddba7384fc22ae59e857709f", "patch": "@@ -1019,6 +1019,7 @@ use_internal_fn (gcall *call)\n     args.safe_push (gimple_call_arg (call, i));\n   gcall *new_call = gimple_build_call_internal_vec (ifn, args);\n   gimple_set_location (new_call, gimple_location (call));\n+  gimple_call_set_nothrow (new_call, gimple_call_nothrow_p (call));\n \n   /* Transfer the LHS to the new call.  */\n   tree lhs = gimple_call_lhs (call);"}, {"sha": "dd686c1730530998bf22c80923dbf3ddfafec15c", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a844293de1d30da8ddba7384fc22ae59e857709f/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a844293de1d30da8ddba7384fc22ae59e857709f/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=a844293de1d30da8ddba7384fc22ae59e857709f", "patch": "@@ -2219,7 +2219,7 @@ predicate_mem_writes (loop_p loop)\n \t    tree lhs = gimple_assign_lhs (stmt);\n \t    tree rhs = gimple_assign_rhs1 (stmt);\n \t    tree ref, addr, ptr, mask;\n-\t    gimple *new_stmt;\n+\t    gcall *new_stmt;\n \t    gimple_seq stmts = NULL;\n \t    int bitsize = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (lhs)));\n \t    ref = TREE_CODE (lhs) == SSA_NAME ? rhs : lhs;\n@@ -2281,6 +2281,7 @@ predicate_mem_writes (loop_p loop)\n \t\tgimple_set_vdef (new_stmt, gimple_vdef (stmt));\n \t\tSSA_NAME_DEF_STMT (gimple_vdef (new_stmt)) = new_stmt;\n \t      }\n+\t    gimple_call_set_nothrow (new_stmt, true);\n \n \t    gsi_replace (&gsi, new_stmt, true);\n \t  }"}, {"sha": "df0bcd6d459119243a69fc652e761f90d574ca78", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a844293de1d30da8ddba7384fc22ae59e857709f/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a844293de1d30da8ddba7384fc22ae59e857709f/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=a844293de1d30da8ddba7384fc22ae59e857709f", "patch": "@@ -690,6 +690,8 @@ pass_cse_reciprocals::execute (function *fun)\n \t\t\t  gimple_set_vdef (stmt2, gimple_vdef (call));\n \t\t\t  SSA_NAME_DEF_STMT (gimple_vdef (stmt2)) = stmt2;\n \t\t\t}\n+\t\t      gimple_call_set_nothrow (stmt2,\n+\t\t\t\t\t       gimple_call_nothrow_p (call));\n \t\t      gimple_set_vuse (stmt2, gimple_vuse (call));\n \t\t      gimple_stmt_iterator gsi2 = gsi_for_stmt (call);\n \t\t      gsi_replace (&gsi2, stmt2, true);\n@@ -4100,6 +4102,8 @@ convert_to_divmod (gassign *stmt)\n   tree res = make_temp_ssa_name (build_complex_type (TREE_TYPE (op1)),\n \t\t\t\t call_stmt, \"divmod_tmp\");\n   gimple_call_set_lhs (call_stmt, res);\n+  /* We rejected throwing statements above.  */\n+  gimple_call_set_nothrow (call_stmt, true);\n \n   /* Insert the call before top_stmt.  */\n   gimple_stmt_iterator top_stmt_gsi = gsi_for_stmt (top_stmt);"}, {"sha": "cfdb72c6499fdcd2ffb954fe553fc1d7dd4e987b", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a844293de1d30da8ddba7384fc22ae59e857709f/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a844293de1d30da8ddba7384fc22ae59e857709f/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=a844293de1d30da8ddba7384fc22ae59e857709f", "patch": "@@ -1085,6 +1085,7 @@ vect_recog_pow_pattern (vec<gimple *> *stmts, tree *type_in,\n \t  gcall *stmt = gimple_build_call_internal (IFN_SQRT, 1, base);\n \t  var = vect_recog_temp_ssa_var (TREE_TYPE (base), stmt);\n \t  gimple_call_set_lhs (stmt, var);\n+\t  gimple_call_set_nothrow (stmt, true);\n \t  return stmt;\n \t}\n     }\n@@ -3867,14 +3868,14 @@ vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_in,\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   stmt_vec_info pattern_stmt_info;\n   vec_info *vinfo = stmt_vinfo->vinfo;\n-  gimple *pattern_stmt;\n \n   /* Check for MASK_LOAD ans MASK_STORE calls requiring mask conversion.  */\n   if (is_gimple_call (last_stmt)\n       && gimple_call_internal_p (last_stmt)\n       && (gimple_call_internal_fn (last_stmt) == IFN_MASK_STORE\n \t  || gimple_call_internal_fn (last_stmt) == IFN_MASK_LOAD))\n     {\n+      gcall *pattern_stmt;\n       bool load = (gimple_call_internal_fn (last_stmt) == IFN_MASK_LOAD);\n \n       if (load)\n@@ -3918,6 +3919,7 @@ vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_in,\n \t\t\t\t\t  tmp,\n \t\t\t\t\t  gimple_call_arg (last_stmt, 3));\n \n+      gimple_call_set_nothrow (pattern_stmt, true);\n \n       pattern_stmt_info = new_stmt_vec_info (pattern_stmt, vinfo);\n       set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n@@ -3940,6 +3942,7 @@ vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_in,\n   if (!is_gimple_assign (last_stmt))\n     return NULL;\n \n+  gimple *pattern_stmt;\n   lhs = gimple_assign_lhs (last_stmt);\n   rhs1 = gimple_assign_rhs1 (last_stmt);\n   rhs_code = gimple_assign_rhs_code (last_stmt);"}, {"sha": "013fb1fc1660a1d2646b5b54a33f8e6a6e4e9bef", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 49, "deletions": 26, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a844293de1d30da8ddba7384fc22ae59e857709f/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a844293de1d30da8ddba7384fc22ae59e857709f/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=a844293de1d30da8ddba7384fc22ae59e857709f", "patch": "@@ -2364,9 +2364,11 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\t\t  misalign);\n \t  tree ptr = build_int_cst (TREE_TYPE (gimple_call_arg (stmt, 1)),\n \t\t\t\t    misalign ? least_bit_hwi (misalign) : align);\n-\t  new_stmt\n+\t  gcall *call\n \t    = gimple_build_call_internal (IFN_MASK_STORE, 4, dataref_ptr,\n \t\t\t\t\t  ptr, vec_mask, vec_rhs);\n+\t  gimple_call_set_nothrow (call, true);\n+\t  new_stmt = call;\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t  if (i == 0)\n \t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n@@ -2414,16 +2416,17 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\t\t  misalign);\n \t  tree ptr = build_int_cst (TREE_TYPE (gimple_call_arg (stmt, 1)),\n \t\t\t\t    misalign ? least_bit_hwi (misalign) : align);\n-\t  new_stmt\n+\t  gcall *call\n \t    = gimple_build_call_internal (IFN_MASK_LOAD, 3, dataref_ptr,\n \t\t\t\t\t  ptr, vec_mask);\n-\t  gimple_call_set_lhs (new_stmt, make_ssa_name (vec_dest));\n-\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t  gimple_call_set_lhs (call, make_ssa_name (vec_dest));\n+\t  gimple_call_set_nothrow (call, true);\n+\t  vect_finish_stmt_generation (stmt, call, gsi);\n \t  if (i == 0)\n-\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = call;\n \t  else\n-\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = call;\n+\t  prev_stmt_info = vinfo_for_stmt (call);\n \t}\n     }\n \n@@ -2867,8 +2870,11 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t  if (modifier == NARROW)\n \t\t    {\n \t\t      tree half_res = make_ssa_name (vectype_in);\n-\t\t      new_stmt = gimple_build_call_internal_vec (ifn, vargs);\n-\t\t      gimple_call_set_lhs (new_stmt, half_res);\n+\t\t      gcall *call\n+\t\t\t= gimple_build_call_internal_vec (ifn, vargs);\n+\t\t      gimple_call_set_lhs (call, half_res);\n+\t\t      gimple_call_set_nothrow (call, true);\n+\t\t      new_stmt = call;\n \t\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t      if ((i & 1) == 0)\n \t\t\t{\n@@ -2881,12 +2887,15 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t    }\n \t\t  else\n \t\t    {\n+\t\t      gcall *call;\n \t\t      if (ifn != IFN_LAST)\n-\t\t\tnew_stmt = gimple_build_call_internal_vec (ifn, vargs);\n+\t\t\tcall = gimple_build_call_internal_vec (ifn, vargs);\n \t\t      else\n-\t\t\tnew_stmt = gimple_build_call_vec (fndecl, vargs);\n-\t\t      new_temp = make_ssa_name (vec_dest, new_stmt);\n-\t\t      gimple_call_set_lhs (new_stmt, new_temp);\n+\t\t\tcall = gimple_build_call_vec (fndecl, vargs);\n+\t\t      new_temp = make_ssa_name (vec_dest, call);\n+\t\t      gimple_call_set_lhs (call, new_temp);\n+\t\t      gimple_call_set_nothrow (call, true);\n+\t\t      new_stmt = call;\n \t\t    }\n \t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t  SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n@@ -2934,8 +2943,10 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  else if (modifier == NARROW)\n \t    {\n \t      tree half_res = make_ssa_name (vectype_in);\n-\t      new_stmt = gimple_build_call_internal_vec (ifn, vargs);\n-\t      gimple_call_set_lhs (new_stmt, half_res);\n+\t      gcall *call = gimple_build_call_internal_vec (ifn, vargs);\n+\t      gimple_call_set_lhs (call, half_res);\n+\t      gimple_call_set_nothrow (call, true);\n+\t      new_stmt = call;\n \t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t      if ((j & 1) == 0)\n \t\t{\n@@ -2948,12 +2959,15 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t    }\n \t  else\n \t    {\n+\t      gcall *call;\n \t      if (ifn != IFN_LAST)\n-\t\tnew_stmt = gimple_build_call_internal_vec (ifn, vargs);\n+\t\tcall = gimple_build_call_internal_vec (ifn, vargs);\n \t      else\n-\t\tnew_stmt = gimple_build_call_vec (fndecl, vargs);\n+\t\tcall = gimple_build_call_vec (fndecl, vargs);\n \t      new_temp = make_ssa_name (vec_dest, new_stmt);\n-\t      gimple_call_set_lhs (new_stmt, new_temp);\n+\t      gimple_call_set_lhs (call, new_temp);\n+\t      gimple_call_set_nothrow (call, true);\n+\t      new_stmt = call;\n \t    }\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \n@@ -2996,12 +3010,15 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t      vargs.quick_push (vec_oprndsk[i]);\n \t\t      vargs.quick_push (vec_oprndsk[i + 1]);\n \t\t    }\n+\t\t  gcall *call;\n \t\t  if (ifn != IFN_LAST)\n-\t\t    new_stmt = gimple_build_call_internal_vec (ifn, vargs);\n+\t\t    call = gimple_build_call_internal_vec (ifn, vargs);\n \t\t  else\n-\t\t    new_stmt = gimple_build_call_vec (fndecl, vargs);\n-\t\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n-\t\t  gimple_call_set_lhs (new_stmt, new_temp);\n+\t\t    call = gimple_build_call_vec (fndecl, vargs);\n+\t\t  new_temp = make_ssa_name (vec_dest, call);\n+\t\t  gimple_call_set_lhs (call, new_temp);\n+\t\t  gimple_call_set_nothrow (call, true);\n+\t\t  new_stmt = call;\n \t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t  SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n \t\t}\n@@ -6356,8 +6373,11 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  /* Emit:\n \t       MEM_REF[...all elements...] = STORE_LANES (VEC_ARRAY).  */\n \t  data_ref = create_array_ref (aggr_type, dataref_ptr, ref_type);\n-\t  new_stmt = gimple_build_call_internal (IFN_STORE_LANES, 1, vec_array);\n-\t  gimple_call_set_lhs (new_stmt, data_ref);\n+\t  gcall *call = gimple_build_call_internal (IFN_STORE_LANES, 1,\n+\t\t\t\t\t\t    vec_array);\n+\t  gimple_call_set_lhs (call, data_ref);\n+\t  gimple_call_set_nothrow (call, true);\n+\t  new_stmt = call;\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t}\n       else\n@@ -7448,8 +7468,11 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  /* Emit:\n \t       VEC_ARRAY = LOAD_LANES (MEM_REF[...all elements...]).  */\n \t  data_ref = create_array_ref (aggr_type, dataref_ptr, ref_type);\n-\t  new_stmt = gimple_build_call_internal (IFN_LOAD_LANES, 1, data_ref);\n-\t  gimple_call_set_lhs (new_stmt, vec_array);\n+\t  gcall *call = gimple_build_call_internal (IFN_LOAD_LANES, 1,\n+\t\t\t\t\t\t    data_ref);\n+\t  gimple_call_set_lhs (call, vec_array);\n+\t  gimple_call_set_nothrow (call, true);\n+\t  new_stmt = call;\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \n \t  /* Extract each vector into an SSA_NAME.  */"}]}