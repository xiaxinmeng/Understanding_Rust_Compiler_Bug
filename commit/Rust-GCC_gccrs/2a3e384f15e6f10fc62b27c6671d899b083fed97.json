{"sha": "2a3e384f15e6f10fc62b27c6671d899b083fed97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEzZTM4NGYxNWU2ZjEwZmM2MmIyN2M2NjcxZDg5OWIwODNmZWQ5Nw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-08-08T08:28:00Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-08-08T08:28:00Z"}, "message": "tm.texi (LOCAL_REGNO): Document.\n\n        * tm.texi (LOCAL_REGNO): Document.\n        * flow.c (LOCAL_REGNO, EPILOGUE_USES): Provide default.\n        (mark_regs_live_at_end): Don't mark LOCAL_REGNO registers.\n        * reload1.c (reload): Likewise when considering nonlocal labels.\n\n        * config/ia64/ia64.h (LOCAL_REGNO): New.\n        * config/sparc/sparc.h (LOCAL_REGNO): New.\n\nFrom-SVN: r35564", "tree": {"sha": "bef654b1dd4f2327e04b2250df973c7f458204ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bef654b1dd4f2327e04b2250df973c7f458204ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a3e384f15e6f10fc62b27c6671d899b083fed97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a3e384f15e6f10fc62b27c6671d899b083fed97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a3e384f15e6f10fc62b27c6671d899b083fed97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a3e384f15e6f10fc62b27c6671d899b083fed97/comments", "author": null, "committer": null, "parents": [{"sha": "43d1e05928a16e48e017625e8dad6aeca2a31282", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43d1e05928a16e48e017625e8dad6aeca2a31282", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43d1e05928a16e48e017625e8dad6aeca2a31282"}], "stats": {"total": 53, "additions": 41, "deletions": 12}, "files": [{"sha": "8b6db106efd815b97a2ba07bb064a3a84f2a1dd8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3e384f15e6f10fc62b27c6671d899b083fed97/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3e384f15e6f10fc62b27c6671d899b083fed97/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a3e384f15e6f10fc62b27c6671d899b083fed97", "patch": "@@ -1,3 +1,13 @@\n+2000-08-08  Richard Henderson  <rth@cygnus.com>\n+\n+\t* tm.texi (LOCAL_REGNO): Document.\n+\t* flow.c (LOCAL_REGNO, EPILOGUE_USES): Provide default.\n+\t(mark_regs_live_at_end): Don't mark LOCAL_REGNO registers.\n+\t* reload1.c (reload): Likewise when considering nonlocal labels.\n+\n+\t* config/ia64/ia64.h (LOCAL_REGNO): New.\n+\t* config/sparc/sparc.h (LOCAL_REGNO): New.\n+\n 2000-08-08  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* c-lex.c (yylex): Don't allow integer suffixes 'LUL', 'Ll', 'lL'."}, {"sha": "1b274f09327c088b3a4a4b7f915c41492e026869", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3e384f15e6f10fc62b27c6671d899b083fed97/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3e384f15e6f10fc62b27c6671d899b083fed97/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=2a3e384f15e6f10fc62b27c6671d899b083fed97", "patch": "@@ -686,6 +686,12 @@ while (0)\n #define OUTGOING_REGNO(IN) \\\n   ((unsigned) ((IN) - IN_REG (0)) < 8 ? OUT_REG ((IN) - IN_REG (0)) : (IN))\n \n+/* Define this macro if the target machine has register windows.  This\n+   C expression returns true if the register is call-saved but is in the\n+   register window.  */\n+\n+#define LOCAL_REGNO(REGNO) \\\n+  (IN_REGNO_P (REGNO) || LOC_REGNO_P (REGNO))\n \f\n /* Order of allocation of registers */\n "}, {"sha": "43790d9b206b177ff013e20658cdd2a5578b92fb", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3e384f15e6f10fc62b27c6671d899b083fed97/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3e384f15e6f10fc62b27c6671d899b083fed97/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=2a3e384f15e6f10fc62b27c6671d899b083fed97", "patch": "@@ -1711,6 +1711,13 @@ extern char leaf_reg_remap[];\n #define OUTGOING_REGNO(IN) \\\n  ((TARGET_FLAT || (IN) < 24 || (IN) > 31) ? (IN) : (IN) - 16)\n \n+/* Define this macro if the target machine has register windows.  This\n+   C expression returns true if the register is call-saved but is in the\n+   register window.  */\n+\n+#define LOCAL_REGNO(REGNO) \\\n+  (TARGET_FLAT ? 0 : (REGNO) >= 16 && (REGNO) <= 31)\n+\n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;"}, {"sha": "c1a8db82aff8bb1f44661992426e07ce3c72af6f", "filename": "gcc/flow.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3e384f15e6f10fc62b27c6671d899b083fed97/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3e384f15e6f10fc62b27c6671d899b083fed97/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=2a3e384f15e6f10fc62b27c6671d899b083fed97", "patch": "@@ -163,6 +163,13 @@ Boston, MA 02111-1307, USA.  */\n #define HAVE_sibcall_epilogue 0\n #endif\n \n+#ifndef LOCAL_REGNO\n+#define LOCAL_REGNO(REGNO)  0\n+#endif\n+#ifndef EPILOGUE_USES\n+#define EPILOGUE_USES(REGNO)  0\n+#endif\n+\n /* The contents of the current function definition are allocated\n    in this obstack, and all are freed at the end of the function.\n    For top-level functions, this is temporary_obstack.\n@@ -3051,8 +3058,9 @@ mark_regs_live_at_end (set)\n     {\n       SET_REGNO_REG_SET (set, FRAME_POINTER_REGNUM);\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-      /* If they are different, also mark the hard frame pointer as live */\n-      SET_REGNO_REG_SET (set, HARD_FRAME_POINTER_REGNUM);\n+      /* If they are different, also mark the hard frame pointer as live.  */\n+      if (! LOCAL_REGNO (HARD_FRAME_POINTER_REGNUM))\n+        SET_REGNO_REG_SET (set, HARD_FRAME_POINTER_REGNUM);\n #endif      \n     }\n \n@@ -3070,18 +3078,14 @@ mark_regs_live_at_end (set)\n      as being live at the end of the function since they may be\n      referenced by our caller.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (global_regs[i]\n-#ifdef EPILOGUE_USES\n-\t|| EPILOGUE_USES (i)\n-#endif\n-\t)\n+    if (global_regs[i] || EPILOGUE_USES (i))\n       SET_REGNO_REG_SET (set, i);\n \n   /* Mark all call-saved registers that we actaully used.  */\n   if (HAVE_epilogue && reload_completed)\n     {\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (! call_used_regs[i] && regs_ever_live[i])\n+\tif (regs_ever_live[i] && ! call_used_regs[i] && ! LOCAL_REGNO (i))\n \t  SET_REGNO_REG_SET (set, i);\n     }\n "}, {"sha": "fb7d2f5b863b892a08b82156bcf77db841dbf99f", "filename": "gcc/reload1.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3e384f15e6f10fc62b27c6671d899b083fed97/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3e384f15e6f10fc62b27c6671d899b083fed97/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=2a3e384f15e6f10fc62b27c6671d899b083fed97", "patch": "@@ -85,6 +85,10 @@ Boston, MA 02111-1307, USA.  */\n #ifndef REGISTER_MOVE_COST\n #define REGISTER_MOVE_COST(x, y) 2\n #endif\n+\n+#ifndef LOCAL_REGNO\n+#define LOCAL_REGNO(REGNO)  0\n+#endif\n \f\n /* During reload_as_needed, element N contains a REG rtx for the hard reg\n    into which reg N has been reloaded (perhaps for a previous insn).  */\n@@ -654,10 +658,8 @@ reload (first, global, dumpfile)\n      registers.  */\n   if (current_function_has_nonlocal_label)\n     for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-      {\n-\tif (! call_used_regs[i] && ! fixed_regs[i])\n-\t  regs_ever_live[i] = 1;\n-      }\n+      if (! call_used_regs[i] && ! fixed_regs[i] && ! LOCAL_REGNO (i))\n+\tregs_ever_live[i] = 1;\n \n   /* Find all the pseudo registers that didn't get hard regs\n      but do have known equivalent constants or memory slots."}]}