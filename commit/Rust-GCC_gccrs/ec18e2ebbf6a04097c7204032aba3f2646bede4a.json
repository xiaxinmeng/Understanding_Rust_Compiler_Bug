{"sha": "ec18e2ebbf6a04097c7204032aba3f2646bede4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMxOGUyZWJiZjZhMDQwOTdjNzIwNDAzMmFiYTNmMjY0NmJlZGU0YQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-06-17T07:42:47Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-06-17T07:42:47Z"}, "message": "tree-ssa-propagate.c: Include domwalk.h.\n\n2014-06-17  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-propagate.c: Include domwalk.h.\n\t(substitute_and_fold): Outline main worker into a domwalker ...\n\t(substitute_and_fold_dom_walker::before_dom_children): ... here.\n\tSchedule stmts we can fully propagate for removal.  Remove\n\tpoor-mans DCE.\n\t(substitute_and_fold): Apply a dominator walk to perform\n\tsubstitution.  Process stmts scheduled for removal here.\n\n\t* gcc.dg/tree-ssa/20041122-1.c: Adjust.\n\t* gcc.dg/tree-ssa/forwprop-21.c: Likewise.\n\t* gcc.dg/tree-ssa/vrp35.c: Revert previous adjustments.\n\t* gcc.dg/tree-ssa/vrp36.c: Likewise.\n\t* gcc.dg/vect/nodump-forwprop-22.c: Adjust.\n\nFrom-SVN: r211725", "tree": {"sha": "d6369b46de1be4b74f6def12abc41a2f75c74125", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6369b46de1be4b74f6def12abc41a2f75c74125"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec18e2ebbf6a04097c7204032aba3f2646bede4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec18e2ebbf6a04097c7204032aba3f2646bede4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec18e2ebbf6a04097c7204032aba3f2646bede4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec18e2ebbf6a04097c7204032aba3f2646bede4a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a4ab23b698ec5b8810a23df011453967d1d09180", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4ab23b698ec5b8810a23df011453967d1d09180", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4ab23b698ec5b8810a23df011453967d1d09180"}], "stats": {"total": 421, "additions": 217, "deletions": 204}, "files": [{"sha": "e12a8ab4a6177eca6c6506c138627c2595101e8e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec18e2ebbf6a04097c7204032aba3f2646bede4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec18e2ebbf6a04097c7204032aba3f2646bede4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec18e2ebbf6a04097c7204032aba3f2646bede4a", "patch": "@@ -1,3 +1,13 @@\n+2014-06-17  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-propagate.c: Include domwalk.h.\n+\t(substitute_and_fold): Outline main worker into a domwalker ...\n+\t(substitute_and_fold_dom_walker::before_dom_children): ... here.\n+\tSchedule stmts we can fully propagate for removal.  Remove\n+\tpoor-mans DCE.\n+\t(substitute_and_fold): Apply a dominator walk to perform\n+\tsubstitution.  Process stmts scheduled for removal here.\n+\n 2014-06-17  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-loop-im.c (determine_max_movement): Adjust cost"}, {"sha": "c9e15110a4408ab98f3490d4f2804944b700203a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec18e2ebbf6a04097c7204032aba3f2646bede4a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec18e2ebbf6a04097c7204032aba3f2646bede4a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ec18e2ebbf6a04097c7204032aba3f2646bede4a", "patch": "@@ -1,3 +1,11 @@\n+2014-06-17  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/20041122-1.c: Adjust.\n+\t* gcc.dg/tree-ssa/forwprop-21.c: Likewise.\n+\t* gcc.dg/tree-ssa/vrp35.c: Revert previous adjustments.\n+\t* gcc.dg/tree-ssa/vrp36.c: Likewise.\n+\t* gcc.dg/vect/nodump-forwprop-22.c: Adjust.\n+\n 2014-06-17  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/ssa-lim-12.c: New testcase."}, {"sha": "80068b86de7da07dddd6882ad33289e081941f9f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20041122-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec18e2ebbf6a04097c7204032aba3f2646bede4a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20041122-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec18e2ebbf6a04097c7204032aba3f2646bede4a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20041122-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20041122-1.c?ref=ec18e2ebbf6a04097c7204032aba3f2646bede4a", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fstrict-aliasing -fdump-tree-fre1\" } */\n+/* { dg-options \"-O1 -fstrict-aliasing -fdump-tree-cddce1\" } */\n \n __extension__ typedef __SIZE_TYPE__ size_t;\n extern void *xmalloc (size_t) __attribute__ ((__malloc__));\n@@ -34,5 +34,5 @@ find_unreachable_blocks (void)\n    able to determine that modifying e->dest->flags does not\n    modify e or e->dest if we can assert strict-aliasing rules.\n    The net result is that we only need one load of e->dest.  */\n-/* { dg-final { scan-tree-dump-times \"->dest\" 1 \"fre1\" } } */\n-/* { dg-final { cleanup-tree-dump \"fre1\" } } */\n+/* { dg-final { scan-tree-dump-times \"->dest\" 1 \"cddce1\" } } */\n+/* { dg-final { cleanup-tree-dump \"cddce1\" } } */"}, {"sha": "e6133325f40d1e5ae0e2535c0903a8c557413eb2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/forwprop-21.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec18e2ebbf6a04097c7204032aba3f2646bede4a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec18e2ebbf6a04097c7204032aba3f2646bede4a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-21.c?ref=ec18e2ebbf6a04097c7204032aba3f2646bede4a", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O -fdump-tree-copyprop1\" } */\n+/* { dg-options \"-O -fdump-tree-cddce1 -fno-tree-fre\" } */\n typedef int v4si __attribute__ ((vector_size (4 * sizeof(int))));\n \n int\n@@ -10,7 +10,7 @@ test (v4si *x, v4si *y)\n   return z[2];\n }\n \n-/* Optimization in forwprop1, cleanup in copyprop1.  */\n+/* Optimization in forwprop1, cleanup in cddce1.  */\n \n-/* { dg-final { scan-tree-dump-not \"VEC_PERM_EXPR\" \"copyprop1\" } } */\n-/* { dg-final { cleanup-tree-dump \"copyprop1\" } } */\n+/* { dg-final { scan-tree-dump-not \"VEC_PERM_EXPR\" \"cddce1\" } } */\n+/* { dg-final { cleanup-tree-dump \"cddce1\" } } */"}, {"sha": "06b567d43e34d571a88903de8f470cf880ade237", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp35.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec18e2ebbf6a04097c7204032aba3f2646bede4a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp35.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec18e2ebbf6a04097c7204032aba3f2646bede4a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp35.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp35.c?ref=ec18e2ebbf6a04097c7204032aba3f2646bede4a", "patch": "@@ -11,5 +11,5 @@ int test1(int i, int k)\n   return 1;\n }\n \n-/* { dg-final { scan-tree-dump-not \"j_.* == 10\" \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump \"Folding predicate j_.* == 10 to 0\" \"vrp1\" } } */\n /* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "9d61960c7ae853fabb23ab62dca5cbba7025edc3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp36.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec18e2ebbf6a04097c7204032aba3f2646bede4a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp36.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec18e2ebbf6a04097c7204032aba3f2646bede4a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp36.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp36.c?ref=ec18e2ebbf6a04097c7204032aba3f2646bede4a", "patch": "@@ -8,5 +8,5 @@ int foo(int i)\n   return 1;\n }\n \n-/* { dg-final { scan-tree-dump-not \"i_.* == 1\" \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump \"Folding predicate i_.* == 1 to 0\" \"vrp1\" } } */\n /* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "6d33f006a730f0773c89e9e5781cddd8e6fe335f", "filename": "gcc/testsuite/gcc.dg/vect/nodump-forwprop-22.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec18e2ebbf6a04097c7204032aba3f2646bede4a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fnodump-forwprop-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec18e2ebbf6a04097c7204032aba3f2646bede4a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fnodump-forwprop-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fnodump-forwprop-22.c?ref=ec18e2ebbf6a04097c7204032aba3f2646bede4a", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target vect_double } */\n /* { dg-require-effective-target vect_perm } */\n-/* { dg-additional-options \"-fdump-tree-copyprop1\" } */\n+/* { dg-additional-options \"-fdump-tree-cddce1 -fno-tree-fre\" } */\n \n typedef double vec __attribute__((vector_size (2 * sizeof (double))));\n void f (vec *px, vec *y, vec *z)\n@@ -13,8 +13,8 @@ void f (vec *px, vec *y, vec *z)\n   *z = t2;\n }\n \n-/* Optimization in forwprop1, cleanup in copyprop1.  */\n+/* Optimization in forwprop1, cleanup in cddce1.  */\n \n-/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 1 \"copyprop1\" } } */\n-/* { dg-final { scan-tree-dump-not \"BIT_FIELD_REF\" \"copyprop1\" } } */\n-/* { dg-final { cleanup-tree-dump \"copyprop1\" } } */\n+/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 1 \"cddce1\" } } */\n+/* { dg-final { scan-tree-dump-not \"BIT_FIELD_REF\" \"cddce1\" } } */\n+/* { dg-final { cleanup-tree-dump \"cddce1\" } } */"}, {"sha": "cdc9f6ad39b65a9fe65d08ffa3836e00021d16a9", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 185, "deletions": 190, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec18e2ebbf6a04097c7204032aba3f2646bede4a/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec18e2ebbf6a04097c7204032aba3f2646bede4a/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=ec18e2ebbf6a04097c7204032aba3f2646bede4a", "patch": "@@ -49,6 +49,7 @@\n #include \"tree-ssa-propagate.h\"\n #include \"langhooks.h\"\n #include \"value-prof.h\"\n+#include \"domwalk.h\"\n \n /* This file implements a generic value propagation engine based on\n    the same propagation used by the SSA-CCP algorithm [1].\n@@ -1017,225 +1018,218 @@ replace_phi_args_in (gimple phi, ssa_prop_get_value_fn get_value)\n }\n \n \n-/* Perform final substitution and folding of propagated values.\n-\n-   PROP_VALUE[I] contains the single value that should be substituted\n-   at every use of SSA name N_I.  If PROP_VALUE is NULL, no values are\n-   substituted.\n-\n-   If FOLD_FN is non-NULL the function will be invoked on all statements\n-   before propagating values for pass specific simplification.\n-\n-   DO_DCE is true if trivially dead stmts can be removed.\n-\n-   If DO_DCE is true, the statements within a BB are walked from\n-   last to first element.  Otherwise we scan from first to last element.\n-\n-   Return TRUE when something changed.  */\n-\n-bool\n-substitute_and_fold (ssa_prop_get_value_fn get_value_fn,\n-\t\t     ssa_prop_fold_stmt_fn fold_fn,\n-\t\t     bool do_dce)\n+class substitute_and_fold_dom_walker : public dom_walker\n {\n-  basic_block bb;\n-  bool something_changed = false;\n-  unsigned i;\n+public:\n+    substitute_and_fold_dom_walker (cdi_direction direction,\n+\t\t\t\t    ssa_prop_get_value_fn get_value_fn_,\n+\t\t\t\t    ssa_prop_fold_stmt_fn fold_fn_,\n+\t\t\t\t    bool do_dce_)\n+\t: dom_walker (direction), get_value_fn (get_value_fn_),\n+      fold_fn (fold_fn_), do_dce (do_dce_), something_changed (false)\n+    {\n+      stmts_to_remove.create (0);\n+    }\n+    ~substitute_and_fold_dom_walker () { stmts_to_remove.release (); }\n \n-  if (!get_value_fn && !fold_fn)\n-    return false;\n+    virtual void before_dom_children (basic_block);\n+    virtual void after_dom_children (basic_block) {}\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\nSubstituting values and folding statements\\n\\n\");\n+    ssa_prop_get_value_fn get_value_fn;\n+    ssa_prop_fold_stmt_fn fold_fn;\n+    bool do_dce;\n+    bool something_changed;\n+    vec<gimple> stmts_to_remove;\n+};\n \n-  memset (&prop_stats, 0, sizeof (prop_stats));\n+void\n+substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n+{\n+  gimple_stmt_iterator i;\n \n-  /* Substitute lattice values at definition sites.  */\n-  if (get_value_fn)\n-    for (i = 1; i < num_ssa_names; ++i)\n-      {\n-\ttree name = ssa_name (i);\n-\ttree val;\n-\tgimple def_stmt;\n-\tgimple_stmt_iterator gsi;\n-\n-\tif (!name\n-\t    || virtual_operand_p (name))\n-\t  continue;\n-\n-\tdef_stmt = SSA_NAME_DEF_STMT (name);\n-\tif (gimple_nop_p (def_stmt)\n-\t    /* Do not substitute ASSERT_EXPR rhs, this will confuse VRP.  */\n-\t    || (gimple_assign_single_p (def_stmt)\n-\t\t&& gimple_assign_rhs_code (def_stmt) == ASSERT_EXPR)\n-\t    || !(val = (*get_value_fn) (name))\n-\t    || !may_propagate_copy (name, val))\n-\t  continue;\n-\n-\tgsi = gsi_for_stmt (def_stmt);\n-\tif (is_gimple_assign (def_stmt))\n-\t  {\n-\t    gimple_assign_set_rhs_with_ops (&gsi, TREE_CODE (val),\n-\t\t\t\t\t    val, NULL_TREE);\n-\t    gcc_assert (gsi_stmt (gsi) == def_stmt);\n-\t    if (maybe_clean_eh_stmt (def_stmt))\n-\t      gimple_purge_dead_eh_edges (gimple_bb (def_stmt));\n-\t    update_stmt (def_stmt);\n-\t  }\n-\telse if (is_gimple_call (def_stmt))\n-\t  {\n-\t    int flags = gimple_call_flags (def_stmt);\n-\n-\t    /* Don't optimize away calls that have side-effects.  */\n-\t    if ((flags & (ECF_CONST|ECF_PURE)) == 0\n-\t\t|| (flags & ECF_LOOPING_CONST_OR_PURE))\n+  /* Propagate known values into PHI nodes.  */\n+  for (i = gsi_start_phis (bb); !gsi_end_p (i); gsi_next (&i))\n+    {\n+      gimple phi = gsi_stmt (i);\n+      tree res = gimple_phi_result (phi);\n+      if (virtual_operand_p (res))\n+\tcontinue;\n+      if (do_dce\n+\t  && res && TREE_CODE (res) == SSA_NAME)\n+\t{\n+\t  tree sprime = get_value_fn (res);\n+\t  if (sprime\n+\t      && sprime != res\n+\t      && may_propagate_copy (res, sprime))\n+\t    {\n+\t      stmts_to_remove.safe_push (phi);\n \t      continue;\n-\t    if (update_call_from_tree (&gsi, val)\n-\t\t&& maybe_clean_or_replace_eh_stmt (def_stmt, gsi_stmt (gsi)))\n-\t      gimple_purge_dead_eh_edges (gimple_bb (gsi_stmt (gsi)));\n-\t  }\n-\telse if (gimple_code (def_stmt) == GIMPLE_PHI)\n-\t  {\n-\t    gimple new_stmt = gimple_build_assign (name, val);\n-\t    gimple_stmt_iterator gsi2;\n-\t    gsi2 = gsi_after_labels (gimple_bb (def_stmt));\n-\t    gsi_insert_before (&gsi2, new_stmt, GSI_SAME_STMT);\n-\t    remove_phi_node (&gsi, false);\n-\t  }\n-\n-\tsomething_changed = true;\n-      }\n-\n-  /* Propagate into all uses and fold.  */\n-  FOR_EACH_BB_FN (bb, cfun)\n+\t    }\n+\t}\n+      replace_phi_args_in (phi, get_value_fn);\n+    }\n+\n+  /* Propagate known values into stmts.  In some case it exposes\n+     more trivially deletable stmts to walk backward.  */\n+  for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n     {\n-      gimple_stmt_iterator i;\n+      bool did_replace;\n+      gimple stmt = gsi_stmt (i);\n+      gimple old_stmt;\n+      enum gimple_code code = gimple_code (stmt);\n+\n+      /* Ignore ASSERT_EXPRs.  They are used by VRP to generate\n+\t range information for names and they are discarded\n+\t afterwards.  */\n \n-      /* Propagate known values into PHI nodes.  */\n-      if (get_value_fn)\n-\tfor (i = gsi_start_phis (bb); !gsi_end_p (i); gsi_next (&i))\n-\t  replace_phi_args_in (gsi_stmt (i), get_value_fn);\n+      if (code == GIMPLE_ASSIGN\n+\t  && TREE_CODE (gimple_assign_rhs1 (stmt)) == ASSERT_EXPR)\n+\tcontinue;\n \n-      /* Propagate known values into stmts.  Do a backward walk if\n-         do_dce is true. In some case it exposes\n-\t more trivially deletable stmts to walk backward.  */\n-      for (i = (do_dce ? gsi_last_bb (bb) : gsi_start_bb (bb)); !gsi_end_p (i);)\n+      /* No point propagating into a stmt we have a value for we\n+         can propagate into all uses.  Mark it for removal instead.  */\n+      tree lhs = gimple_get_lhs (stmt);\n+      if (do_dce\n+\t  && lhs && TREE_CODE (lhs) == SSA_NAME)\n \t{\n-          bool did_replace;\n-\t  gimple stmt = gsi_stmt (i);\n-\t  gimple old_stmt;\n-\t  enum gimple_code code = gimple_code (stmt);\n-\t  gimple_stmt_iterator oldi;\n-\n-\t  oldi = i;\n-\t  if (do_dce)\n-\t    gsi_prev (&i);\n-\t  else\n-\t    gsi_next (&i);\n-\n-\t  /* Ignore ASSERT_EXPRs.  They are used by VRP to generate\n-\t     range information for names and they are discarded\n-\t     afterwards.  */\n-\n-\t  if (code == GIMPLE_ASSIGN\n-\t      && TREE_CODE (gimple_assign_rhs1 (stmt)) == ASSERT_EXPR)\n-\t    continue;\n-\n-\t  /* No point propagating into a stmt whose result is not used,\n-\t     but instead we might be able to remove a trivially dead stmt.\n-\t     Don't do this when called from VRP, since the SSA_NAME which\n-\t     is going to be released could be still referenced in VRP\n-\t     ranges.  */\n-\t  if (do_dce\n-\t      && gimple_get_lhs (stmt)\n-\t      && TREE_CODE (gimple_get_lhs (stmt)) == SSA_NAME\n-\t      && has_zero_uses (gimple_get_lhs (stmt))\n+\t  tree sprime = get_value_fn (lhs);\n+\t  if (sprime\n+\t      && sprime != lhs\n+\t      && may_propagate_copy (lhs, sprime)\n \t      && !stmt_could_throw_p (stmt)\n \t      && !gimple_has_side_effects (stmt))\n \t    {\n-\t      gimple_stmt_iterator i2;\n-\n-\t      if (dump_file && dump_flags & TDF_DETAILS)\n-\t\t{\n-\t\t  fprintf (dump_file, \"Removing dead stmt \");\n-\t\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n-\t\t  fprintf (dump_file, \"\\n\");\n-\t\t}\n-\t      prop_stats.num_dce++;\n-\t      i2 = gsi_for_stmt (stmt);\n-\t      gsi_remove (&i2, true);\n-\t      release_defs (stmt);\n+\t      stmts_to_remove.safe_push (stmt);\n \t      continue;\n \t    }\n+\t}\n+\n+      /* Replace the statement with its folded version and mark it\n+\t folded.  */\n+      did_replace = false;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Folding statement: \");\n+\t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t}\n+\n+      old_stmt = stmt;\n+\n+      /* Some statements may be simplified using propagator\n+\t specific information.  Do this before propagating\n+\t into the stmt to not disturb pass specific information.  */\n+      if (fold_fn\n+\t  && (*fold_fn)(&i))\n+\t{\n+\t  did_replace = true;\n+\t  prop_stats.num_stmts_folded++;\n+\t  stmt = gsi_stmt (i);\n+\t  update_stmt (stmt);\n+\t}\n+\n+      /* Replace real uses in the statement.  */\n+      did_replace |= replace_uses_in (stmt, get_value_fn);\n+\n+      /* If we made a replacement, fold the statement.  */\n+      if (did_replace)\n+\tfold_stmt (&i);\n \n-\t  /* Replace the statement with its folded version and mark it\n-\t     folded.  */\n-\t  did_replace = false;\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+      /* Now cleanup.  */\n+      if (did_replace)\n+\t{\n+\t  stmt = gsi_stmt (i);\n+\n+\t  /* If we cleaned up EH information from the statement,\n+\t     remove EH edges.  */\n+\t  if (maybe_clean_or_replace_eh_stmt (old_stmt, stmt))\n+\t    gimple_purge_dead_eh_edges (bb);\n+\n+\t  if (is_gimple_assign (stmt)\n+\t      && (get_gimple_rhs_class (gimple_assign_rhs_code (stmt))\n+\t\t  == GIMPLE_SINGLE_RHS))\n \t    {\n-\t      fprintf (dump_file, \"Folding statement: \");\n-\t      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t      tree rhs = gimple_assign_rhs1 (stmt);\n+\n+\t      if (TREE_CODE (rhs) == ADDR_EXPR)\n+\t\trecompute_tree_invariant_for_addr_expr (rhs);\n \t    }\n \n-\t  old_stmt = stmt;\n+\t  /* Determine what needs to be done to update the SSA form.  */\n+\t  update_stmt (stmt);\n+\t  if (!is_gimple_debug (stmt))\n+\t    something_changed = true;\n+\t}\n \n-\t  /* Some statements may be simplified using propagator\n-\t     specific information.  Do this before propagating\n-\t     into the stmt to not disturb pass specific information.  */\n-\t  if (fold_fn\n-\t      && (*fold_fn)(&oldi))\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  if (did_replace)\n \t    {\n-\t      did_replace = true;\n-\t      prop_stats.num_stmts_folded++;\n-\t      stmt = gsi_stmt (oldi);\n-\t      update_stmt (stmt);\n+\t      fprintf (dump_file, \"Folded into: \");\n+\t      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\");\n \t    }\n+\t  else\n+\t    fprintf (dump_file, \"Not folded\\n\");\n+\t}\n+    }\n+}\n \n-\t  /* Replace real uses in the statement.  */\n-\t  if (get_value_fn)\n-\t    did_replace |= replace_uses_in (stmt, get_value_fn);\n \n-\t  /* If we made a replacement, fold the statement.  */\n-\t  if (did_replace)\n-\t    fold_stmt (&oldi);\n \n-\t  /* Now cleanup.  */\n-\t  if (did_replace)\n-\t    {\n-\t      stmt = gsi_stmt (oldi);\n+/* Perform final substitution and folding of propagated values.\n \n-              /* If we cleaned up EH information from the statement,\n-                 remove EH edges.  */\n-\t      if (maybe_clean_or_replace_eh_stmt (old_stmt, stmt))\n-\t\tgimple_purge_dead_eh_edges (bb);\n+   PROP_VALUE[I] contains the single value that should be substituted\n+   at every use of SSA name N_I.  If PROP_VALUE is NULL, no values are\n+   substituted.\n \n-              if (is_gimple_assign (stmt)\n-                  && (get_gimple_rhs_class (gimple_assign_rhs_code (stmt))\n-                      == GIMPLE_SINGLE_RHS))\n-              {\n-                tree rhs = gimple_assign_rhs1 (stmt);\n+   If FOLD_FN is non-NULL the function will be invoked on all statements\n+   before propagating values for pass specific simplification.\n \n-                if (TREE_CODE (rhs) == ADDR_EXPR)\n-                  recompute_tree_invariant_for_addr_expr (rhs);\n-              }\n+   DO_DCE is true if trivially dead stmts can be removed.\n \n-\t      /* Determine what needs to be done to update the SSA form.  */\n-\t      update_stmt (stmt);\n-\t      if (!is_gimple_debug (stmt))\n-\t\tsomething_changed = true;\n-\t    }\n+   If DO_DCE is true, the statements within a BB are walked from\n+   last to first element.  Otherwise we scan from first to last element.\n \n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      if (did_replace)\n-\t\t{\n-\t\t  fprintf (dump_file, \"Folded into: \");\n-\t\t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n-\t\t  fprintf (dump_file, \"\\n\");\n-\t\t}\n-\t      else\n-\t\tfprintf (dump_file, \"Not folded\\n\");\n-\t    }\n+   Return TRUE when something changed.  */\n+\n+bool\n+substitute_and_fold (ssa_prop_get_value_fn get_value_fn,\n+\t\t     ssa_prop_fold_stmt_fn fold_fn,\n+\t\t     bool do_dce)\n+{\n+  gcc_assert (get_value_fn);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\nSubstituting values and folding statements\\n\\n\");\n+\n+  memset (&prop_stats, 0, sizeof (prop_stats));\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  substitute_and_fold_dom_walker walker(CDI_DOMINATORS,\n+\t\t\t\t\tget_value_fn, fold_fn, do_dce);\n+  walker.walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+\n+  /* We cannot remove stmts during the BB walk, especially not release\n+     SSA names there as that destroys the lattice of our callers.\n+     Remove stmts in reverse order to make debug stmt creation possible.  */\n+  while (!walker.stmts_to_remove.is_empty ())\n+    {\n+      gimple stmt = walker.stmts_to_remove.pop ();\n+      if (dump_file && dump_flags & TDF_DETAILS)\n+\t{\n+\t  fprintf (dump_file, \"Removing dead stmt \");\n+\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      prop_stats.num_dce++;\n+      gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+      if (gimple_code (stmt) == GIMPLE_PHI)\n+\tremove_phi_node (&gsi, true);\n+      else\n+\t{\n+\t  unlink_stmt_vdef (stmt);\n+\t  gsi_remove (&gsi, true);\n+\t  release_defs (stmt);\n \t}\n     }\n \n@@ -1247,7 +1241,8 @@ substitute_and_fold (ssa_prop_get_value_fn get_value_fn,\n \t\t\t    prop_stats.num_stmts_folded);\n   statistics_counter_event (cfun, \"Statements deleted\",\n \t\t\t    prop_stats.num_dce);\n-  return something_changed;\n+\n+  return walker.something_changed;\n }\n \n "}]}