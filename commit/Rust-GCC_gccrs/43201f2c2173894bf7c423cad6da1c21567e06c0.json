{"sha": "43201f2c2173894bf7c423cad6da1c21567e06c0", "node_id": "C_kwDOANBUbNoAKDQzMjAxZjJjMjE3Mzg5NGJmN2M0MjNjYWQ2ZGExYzIxNTY3ZTA2YzA", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-05-30T20:20:09Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-05-30T20:20:09Z"}, "message": "PR target/70321: Split double word equality/inequality after STV on x86.\n\nThis patch resolves the last piece of PR target/70321 a code quality\n(P2 regression) affecting mainline.  Currently, for HJ's testcase:\n\nvoid foo (long long ixi)\n{\n  if (ixi != 14348907)\n    __builtin_abort ();\n}\n\nGCC with -m32 -O2 generates four instructions for the comparison:\n\n        movl    16(%esp), %eax\n        movl    20(%esp), %edx\n        xorl    $14348907, %eax\n        orl     %eax, %edx\n\nbut with this patch it now requires only three, making better use of\nx86's addressing modes:\n\n        movl    16(%esp), %eax\n        xorl    $14348907, %eax\n        orl     20(%esp), %eax\n\nThe solution is to expand \"doubleword\" equality/inequality expressions\nusing flag setting COMPARE instructions for the early RTL passes, and\nthen split them during split1, after STV and before reload.\nHence on x86_64, we now see/allow things like:\n\n(insn 11 8 12 2 (set (reg:CCZ 17 flags)\n        (compare:CCZ (reg/v:TI 84 [ x ])\n            (reg:TI 96))) \"cmpti.c\":2:43 30 {*cmpti_doubleword}\n\nThis allows the STV pass to decide whether it's preferrable to perform\nthis comparison using vector operations, i.e. a pxor/ptest sequence,\nor as scalar integer operations, i.e. a xor/xor/or sequence.  Alas\nthis required tweaking of the STV pass to recognize the \"new\" form of\nthese comparisons and split out the pxor operation itself.  To confirm\nthis still works as expected I've added a new STV test case:\n\nlong long a[1024];\nlong long b[1024];\n\nint foo()\n{\n  for (int i=0; i<1024; i++)\n  {\n    long long t = (a[i]<<8) | (b[i]<<24);\n    if (t == 0)\n      return 1;\n  }\n  return 0;\n}\n\nwhere with -m32 -O2 -msse4.1 the above comparison with zero should look\nlike:\n\n        punpcklqdq      %xmm0, %xmm0\n        ptest   %xmm0, %xmm0\n\nAlthough this patch includes one or two minor tweaks to provide all the\nnecessary infrastructure to support conversion of TImode comparisons to\nV1TImode (and SImode comparisons to V4SImode), STV doesn't yet implement\nthese transformations, but this is something that can be considered after\nstage 4.  Indeed the new convert_compare functionality is split out\ninto a method to simplify its potential reuse by the timode_scalar_chain\nclass.\n\n2022-05-30  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\tPR target/70321\n\t* config/i386/i386-expand.cc (ix86_expand_branch): Don't decompose\n\tDI mode equality/inequality using XOR here.  Instead generate a\n\tCOMPARE for doubleword modes (DImode on !TARGET_64BIT or TImode).\n\t* config/i386/i386-features.cc (gen_gpr_to_xmm_move_src): Use\n\tgen_rtx_SUBREG when NUNITS is 1, i.e. for TImode to V1TImode.\n\t(general_scalar_chain::convert_compare): New function to convert\n\tscalar equality/inequality comparison into vector operations.\n\t(general_scalar_chain::convert_insn) [COMPARE]: Refactor. Call\n\tnew convert_compare helper method.\n\t(convertible_comparion_p): Update to match doubleword COMPARE\n\tof two register, memory or integer constant operands.\n\t* config/i386/i386-features.h (general_scalar_chain::convert_compare):\n\tPrototype/declare member function here.\n\t* config/i386/i386.md (cstore<mode>4): Change mode to SDWIM, but\n\tonly allow new doubleword modes for EQ and NE operators.\n\t(*cmp<dwi>_doubleword): New define_insn_and_split, to split a\n\tdoubleword comparison into a pair of XORs followed by an IOR to\n\tset the (zero) flags register, optimizing the XORs if possible.\n\t* config/i386/sse.md (V_AVX): Include V1TI and V2TI in mode\n\titerator; V_AVX is (currently) only used by ptest.\n\t(sse4_1 mode attribute): Update to support V1TI and V2TI.\n\ngcc/testsuite/ChangeLog\n\tPR target/70321\n\t* gcc.target/i386/pr70321.c: New test case.\n\t* gcc.target/i386/sse4_1-stv-1.c: New test case.", "tree": {"sha": "3dfcef6b09bf1216aa6d6ac8c2e064a92f4a868a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dfcef6b09bf1216aa6d6ac8c2e064a92f4a868a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43201f2c2173894bf7c423cad6da1c21567e06c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43201f2c2173894bf7c423cad6da1c21567e06c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43201f2c2173894bf7c423cad6da1c21567e06c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43201f2c2173894bf7c423cad6da1c21567e06c0/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3595231d9f5aec301422b152809b1322bdb525fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3595231d9f5aec301422b152809b1322bdb525fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3595231d9f5aec301422b152809b1322bdb525fe"}], "stats": {"total": 242, "additions": 149, "deletions": 93}, "files": [{"sha": "8e9d2b61f05adb155d44df0ea6d307d9a028f373", "filename": "gcc/config/i386/i386-expand.cc", "status": "modified", "additions": 8, "deletions": 41, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43201f2c2173894bf7c423cad6da1c21567e06c0/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43201f2c2173894bf7c423cad6da1c21567e06c0/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.cc?ref=43201f2c2173894bf7c423cad6da1c21567e06c0", "patch": "@@ -2317,21 +2317,15 @@ ix86_expand_branch (enum rtx_code code, rtx op0, rtx op1, rtx label)\n     case E_DImode:\n       if (TARGET_64BIT)\n \tgoto simple;\n-      /* For 32-bit target DI comparison may be performed on\n-\t SSE registers.  To allow this we should avoid split\n-\t to SI mode which is achieved by doing xor in DI mode\n-\t and then comparing with zero (which is recognized by\n-\t STV pass).  We don't compare using xor when optimizing\n-\t for size.  */\n-      if (!optimize_insn_for_size_p ()\n-\t  && TARGET_STV\n-\t  && (code == EQ || code == NE))\n-\t{\n-\t  op0 = force_reg (mode, gen_rtx_XOR (mode, op0, op1));\n-\t  op1 = const0_rtx;\n-\t}\n       /* FALLTHRU */\n     case E_TImode:\n+      /* DI and TI mode equality/inequality comparisons may be performed\n+         on SSE registers.  Avoid splitting them, except when optimizing\n+\t for size.  */\n+      if ((code == EQ || code == NE)\n+\t  && !optimize_insn_for_size_p ())\n+\tgoto simple;\n+\n       /* Expand DImode branch into multiple compare+branch.  */\n       {\n \trtx lo[2], hi[2];\n@@ -2350,34 +2344,7 @@ ix86_expand_branch (enum rtx_code code, rtx op0, rtx op1, rtx label)\n \n \tsubmode = mode == DImode ? SImode : DImode;\n \n-\t/* When comparing for equality, we can use (hi0^hi1)|(lo0^lo1) to\n-\t   avoid two branches.  This costs one extra insn, so disable when\n-\t   optimizing for size.  */\n-\n-\tif ((code == EQ || code == NE)\n-\t    && (!optimize_insn_for_size_p ()\n-\t        || hi[1] == const0_rtx || lo[1] == const0_rtx))\n-\t  {\n-\t    rtx xor0, xor1;\n-\n-\t    xor1 = hi[0];\n-\t    if (hi[1] != const0_rtx)\n-\t      xor1 = expand_binop (submode, xor_optab, xor1, hi[1],\n-\t\t\t\t   NULL_RTX, 0, OPTAB_WIDEN);\n-\n-\t    xor0 = lo[0];\n-\t    if (lo[1] != const0_rtx)\n-\t      xor0 = expand_binop (submode, xor_optab, xor0, lo[1],\n-\t\t\t\t   NULL_RTX, 0, OPTAB_WIDEN);\n-\n-\t    tmp = expand_binop (submode, ior_optab, xor1, xor0,\n-\t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n-\n-\t    ix86_expand_branch (code, tmp, const0_rtx, label);\n-\t    return;\n-\t  }\n-\n-\t/* Otherwise, if we are doing less-than or greater-or-equal-than,\n+\t/* If we are doing less-than or greater-or-equal-than,\n \t   op1 is a constant and the low word is zero, then we can just\n \t   examine the high word.  Similarly for low word -1 and\n \t   less-or-equal-than or greater-than.  */"}, {"sha": "8908e42d3da7702403b25a60e45ffdfa42c51640", "filename": "gcc/config/i386/i386-features.cc", "status": "modified", "additions": 54, "deletions": 47, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43201f2c2173894bf7c423cad6da1c21567e06c0/gcc%2Fconfig%2Fi386%2Fi386-features.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43201f2c2173894bf7c423cad6da1c21567e06c0/gcc%2Fconfig%2Fi386%2Fi386-features.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.cc?ref=43201f2c2173894bf7c423cad6da1c21567e06c0", "patch": "@@ -711,8 +711,7 @@ gen_gpr_to_xmm_move_src (enum machine_mode vmode, rtx gpr)\n   switch (GET_MODE_NUNITS (vmode))\n     {\n     case 1:\n-      /* We are not using this case currently.  */\n-      gcc_unreachable ();\n+      return gen_rtx_SUBREG (vmode, gpr, 0);\n     case 2:\n       return gen_rtx_VEC_CONCAT (vmode, gpr,\n \t\t\t\t CONST0_RTX (GET_MODE_INNER (vmode)));\n@@ -932,6 +931,48 @@ general_scalar_chain::convert_op (rtx *op, rtx_insn *insn)\n     }\n }\n \n+/* Convert COMPARE to vector mode.  */\n+\n+rtx\n+general_scalar_chain::convert_compare (rtx op1, rtx op2, rtx_insn *insn)\n+{\n+  rtx tmp = gen_reg_rtx (vmode);\n+  rtx src;\n+  convert_op (&op1, insn);\n+  /* Comparison against anything other than zero, requires an XOR.  */\n+  if (op2 != const0_rtx)\n+    {\n+      convert_op (&op2, insn);\n+      /* If both operands are MEMs, explicitly load the OP1 into TMP.  */\n+      if (MEM_P (op1) && MEM_P (op2))\n+\t{\n+\t  emit_insn_before (gen_rtx_SET (tmp, op1), insn);\n+\t  src = tmp;\n+\t}\n+      else\n+\tsrc = op1;\n+      src = gen_rtx_XOR (vmode, src, op2);\n+    }\n+  else\n+    src = op1;\n+  emit_insn_before (gen_rtx_SET (tmp, src), insn);\n+\n+  if (vmode == V2DImode)\n+    emit_insn_before (gen_vec_interleave_lowv2di (copy_rtx_if_shared (tmp),\n+\t\t\t\t\t\t  copy_rtx_if_shared (tmp),\n+\t\t\t\t\t\t  copy_rtx_if_shared (tmp)),\n+\t\t      insn);\n+  else if (vmode == V4SImode)\n+    emit_insn_before (gen_sse2_pshufd (copy_rtx_if_shared (tmp),\n+\t\t\t\t       copy_rtx_if_shared (tmp),\n+\t\t\t\t       const0_rtx),\n+\t\t      insn);\n+\n+  return gen_rtx_UNSPEC (CCmode, gen_rtvec (2, copy_rtx_if_shared (tmp),\n+\t\t\t\t\t       copy_rtx_if_shared (tmp)),\n+\t\t\t UNSPEC_PTEST);\n+}\n+\n /* Convert INSN to vector mode.  */\n \n void\n@@ -1090,19 +1131,8 @@ general_scalar_chain::convert_insn (rtx_insn *insn)\n       break;\n \n     case COMPARE:\n-      src = SUBREG_REG (XEXP (XEXP (src, 0), 0));\n-\n-      gcc_assert (REG_P (src) && GET_MODE (src) == DImode);\n-      subreg = gen_rtx_SUBREG (V2DImode, src, 0);\n-      emit_insn_before (gen_vec_interleave_lowv2di\n-\t\t\t(copy_rtx_if_shared (subreg),\n-\t\t\t copy_rtx_if_shared (subreg),\n-\t\t\t copy_rtx_if_shared (subreg)),\n-\t\t\tinsn);\n       dst = gen_rtx_REG (CCmode, FLAGS_REG);\n-      src = gen_rtx_UNSPEC (CCmode, gen_rtvec (2, copy_rtx_if_shared (subreg),\n-\t\t\t\t\t       copy_rtx_if_shared (subreg)),\n-\t\t\t    UNSPEC_PTEST);\n+      src = convert_compare (XEXP (src, 0), XEXP (src, 1), insn);\n       break;\n \n     case CONST_INT:\n@@ -1339,20 +1369,14 @@ pseudo_reg_set (rtx_insn *insn)\n   return set;\n }\n \n-/* Check if comparison INSN may be transformed\n-   into vector comparison.  Currently we transform\n-   zero checks only which look like:\n-\n-   (set (reg:CCZ 17 flags)\n-        (compare:CCZ (ior:SI (subreg:SI (reg:DI x) 4)\n-                             (subreg:SI (reg:DI x) 0))\n-\t\t     (const_int 0 [0])))  */\n+/* Check if comparison INSN may be transformed into vector comparison.\n+   Currently we transform equality/inequality checks which look like:\n+   (set (reg:CCZ 17 flags) (compare:CCZ (reg:TI x) (reg:TI y)))  */\n \n static bool\n convertible_comparison_p (rtx_insn *insn, enum machine_mode mode)\n {\n-  /* ??? Currently convertible for double-word DImode chain only.  */\n-  if (TARGET_64BIT || mode != DImode)\n+  if (mode != (TARGET_64BIT ? TImode : DImode))\n     return false;\n \n   if (!TARGET_SSE4_1)\n@@ -1375,31 +1399,14 @@ convertible_comparison_p (rtx_insn *insn, enum machine_mode mode)\n   rtx op1 = XEXP (src, 0);\n   rtx op2 = XEXP (src, 1);\n \n-  if (op2 != CONST0_RTX (GET_MODE (op2)))\n+  if (!CONST_INT_P (op1)\n+      && ((!REG_P (op1) && !MEM_P (op1))\n+\t  || GET_MODE (op1) != mode))\n     return false;\n \n-  if (GET_CODE (op1) != IOR)\n-    return false;\n-\n-  op2 = XEXP (op1, 1);\n-  op1 = XEXP (op1, 0);\n-\n-  if (!SUBREG_P (op1)\n-      || !SUBREG_P (op2)\n-      || GET_MODE (op1) != SImode\n-      || GET_MODE (op2) != SImode\n-      || ((SUBREG_BYTE (op1) != 0\n-\t   || SUBREG_BYTE (op2) != GET_MODE_SIZE (SImode))\n-\t  && (SUBREG_BYTE (op2) != 0\n-\t      || SUBREG_BYTE (op1) != GET_MODE_SIZE (SImode))))\n-    return false;\n-\n-  op1 = SUBREG_REG (op1);\n-  op2 = SUBREG_REG (op2);\n-\n-  if (op1 != op2\n-      || !REG_P (op1)\n-      || GET_MODE (op1) != DImode)\n+  if (!CONST_INT_P (op2)\n+      && ((!REG_P (op2) && !MEM_P (op2))\n+\t  || GET_MODE (op2) != mode))\n     return false;\n \n   return true;"}, {"sha": "891cb4695a87c3b3a9e8e2423c79c11e61a8fb88", "filename": "gcc/config/i386/i386-features.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43201f2c2173894bf7c423cad6da1c21567e06c0/gcc%2Fconfig%2Fi386%2Fi386-features.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43201f2c2173894bf7c423cad6da1c21567e06c0/gcc%2Fconfig%2Fi386%2Fi386-features.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.h?ref=43201f2c2173894bf7c423cad6da1c21567e06c0", "patch": "@@ -181,6 +181,7 @@ class general_scalar_chain : public scalar_chain\n   void convert_reg (rtx_insn *insn, rtx dst, rtx src);\n   void make_vector_copies (rtx_insn *, rtx);\n   void convert_registers ();\n+  rtx convert_compare (rtx op1, rtx op2, rtx_insn *insn);\n   int vector_const_cost (rtx exp);\n };\n "}, {"sha": "2598cf70214350f1c25ac26eac3a552e43887e43", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 55, "deletions": 3, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43201f2c2173894bf7c423cad6da1c21567e06c0/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43201f2c2173894bf7c423cad6da1c21567e06c0/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=43201f2c2173894bf7c423cad6da1c21567e06c0", "patch": "@@ -1357,14 +1357,20 @@\n \n (define_expand \"cstore<mode>4\"\n   [(set (reg:CC FLAGS_REG)\n-\t(compare:CC (match_operand:SWIM 2 \"nonimmediate_operand\")\n-\t\t    (match_operand:SWIM 3 \"<general_operand>\")))\n+\t(compare:CC (match_operand:SDWIM 2 \"nonimmediate_operand\")\n+\t\t    (match_operand:SDWIM 3 \"<general_operand>\")))\n    (set (match_operand:QI 0 \"register_operand\")\n \t(match_operator 1 \"ordered_comparison_operator\"\n \t  [(reg:CC FLAGS_REG) (const_int 0)]))]\n   \"\"\n {\n-  if (MEM_P (operands[2]) && MEM_P (operands[3]))\n+  if (<MODE>mode == (TARGET_64BIT ? TImode : DImode))\n+    {\n+      if (GET_CODE (operands[1]) != EQ\n+\t  && GET_CODE (operands[1]) != NE)\n+\tFAIL;\n+    }\n+  else if (MEM_P (operands[2]) && MEM_P (operands[3]))\n     operands[2] = force_reg (<MODE>mode, operands[2]);\n   ix86_expand_setcc (operands[0], GET_CODE (operands[1]),\n \t\t     operands[2], operands[3]);\n@@ -1500,6 +1506,52 @@\n   [(set_attr \"type\" \"icmp\")\n    (set_attr \"mode\" \"QI\")])\n \n+(define_insn_and_split \"*cmp<dwi>_doubleword\"\n+  [(set (reg:CCZ FLAGS_REG)\n+\t(compare:CCZ (match_operand:<DWI> 0 \"nonimmediate_operand\")\n+\t\t     (match_operand:<DWI> 1 \"x86_64_general_operand\")))]\n+  \"ix86_pre_reload_split ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(parallel [(set (reg:CCZ FLAGS_REG)\n+\t\t   (compare:CCZ (ior:DWIH (match_dup 4) (match_dup 5))\n+\t\t\t\t(const_int 0)))\n+\t      (set (match_dup 4) (ior:DWIH (match_dup 4) (match_dup 5)))])]\n+{\n+  split_double_mode (<DWI>mode, &operands[0], 2, &operands[0], &operands[2]);\n+  /* Placing the SUBREG pieces in pseudos helps reload.  */\n+  for (int i = 0; i < 4; i++)\n+    if (SUBREG_P (operands[i]))\n+      operands[i] = force_reg (<MODE>mode, operands[i]);\n+\n+  operands[4] = gen_reg_rtx (<MODE>mode);\n+  if (operands[1] == const0_rtx)\n+    emit_move_insn (operands[4], operands[0]);\n+  else if (operands[0] == const0_rtx)\n+    emit_move_insn (operands[4], operands[1]);\n+  else if (operands[1] == constm1_rtx)\n+    emit_insn (gen_one_cmpl<mode>2 (operands[4], operands[0]));\n+  else if (operands[0] == constm1_rtx)\n+    emit_insn (gen_one_cmpl<mode>2 (operands[4], operands[1]));\n+  else\n+    emit_insn (gen_xor<mode>3 (operands[4], operands[0], operands[1]));\n+\n+  if (operands[3] == const0_rtx)\n+    operands[5] = operands[2];\n+  else if (operands[2] == const0_rtx)\n+    operands[5] = operands[3];\n+  else\n+    {\n+      operands[5] = gen_reg_rtx (<MODE>mode);\n+      if (operands[3] == constm1_rtx)\n+\temit_insn (gen_one_cmpl<mode>2 (operands[5], operands[2]));\n+      else if (operands[2] == constm1_rtx)\n+\temit_insn (gen_one_cmpl<mode>2 (operands[5], operands[3]));\n+      else\n+\temit_insn (gen_xor<mode>3 (operands[5], operands[2], operands[3]));\n+    }\n+})\n+\n ;; These implement float point compares.\n ;; %%% See if we can get away with VOIDmode operands on the actual insns,\n ;; which would allow mix and match FP modes on the compares.  Which is what"}, {"sha": "c2e046e812cd80d64558a2687c8b3998ace3a4d8", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43201f2c2173894bf7c423cad6da1c21567e06c0/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43201f2c2173894bf7c423cad6da1c21567e06c0/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=43201f2c2173894bf7c423cad6da1c21567e06c0", "patch": "@@ -466,9 +466,9 @@\n \n ;; All DImode vector integer modes\n (define_mode_iterator V_AVX\n-  [V16QI V8HI V4SI V2DI V4SF V2DF\n+  [V16QI V8HI V4SI V2DI V1TI V4SF V2DF\n    (V32QI \"TARGET_AVX\") (V16HI \"TARGET_AVX\")\n-   (V8SI \"TARGET_AVX\") (V4DI \"TARGET_AVX\")\n+   (V8SI \"TARGET_AVX\") (V4DI \"TARGET_AVX\") (V2TI \"TARGET_AVX\")\n    (V8SF \"TARGET_AVX\") (V4DF\"TARGET_AVX\")])\n \n (define_mode_iterator VI48_AVX\n@@ -890,6 +890,7 @@\n   [(V4SF \"sse4_1\") (V2DF \"sse4_1\")\n    (V8SF \"avx\") (V4DF \"avx\")\n    (V8DF \"avx512f\")\n+   (V2TI \"avx\") (V1TI \"sse4_1\")\n    (V4DI \"avx\") (V2DI \"sse4_1\")\n    (V8SI \"avx\") (V4SI \"sse4_1\")\n    (V16QI \"sse4_1\") (V32QI \"avx\")"}, {"sha": "eaba7285ccf6517a8b37105909f8708827096248", "filename": "gcc/testsuite/gcc.target/i386/pr70321.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43201f2c2173894bf7c423cad6da1c21567e06c0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr70321.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43201f2c2173894bf7c423cad6da1c21567e06c0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr70321.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr70321.c?ref=43201f2c2173894bf7c423cad6da1c21567e06c0", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile { target ia32 } } */\n+/* { dg-options \"-O2\" } */\n+\n+void foo (long long ixi)\n+{\n+  if (ixi != 14348907)\n+    __builtin_abort ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"mov\" 1 } } */"}, {"sha": "12db618fb7da2e3ea3d15002c4120fcfe44fb0b8", "filename": "gcc/testsuite/gcc.target/i386/sse4_1-stv-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43201f2c2173894bf7c423cad6da1c21567e06c0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43201f2c2173894bf7c423cad6da1c21567e06c0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-1.c?ref=43201f2c2173894bf7c423cad6da1c21567e06c0", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target ia32 } } */\n+/* { dg-options \"-O2 -msse4.1 -mstv -mno-stackrealign\" } */\n+long long a[1024];\n+long long b[1024];\n+\n+int foo()\n+{\n+  for (int i=0; i<1024; i++)\n+  {\n+    long long t = (a[i]<<8) | (b[i]<<24);\n+    if (t == 0)\n+      return 1;\n+  }\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"ptest\" } } */\n+/* { dg-final { scan-assembler-not \"pxor\" } } */"}]}