{"sha": "9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIzYjU1YTEwNTE2Y2YxNWQzN2YzOWFjNDczYWQ4NmI2YWUzYzNjZQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2006-12-11T17:50:53Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2006-12-11T17:50:53Z"}, "message": "* tree-scalar-evolution.c (scev_const_prop):\n\n\t* tree-phinodes.c (remove_phi_node): Add argument\n\tRELEASE_LHS_P.  If given, release the SSA name on the LHS of\n\tthe PHI node.\n\tUpdate all users.\n\t* tree-ssa-dce.c: Remove forward declarations for static\n\tfunctions.  Re-arrange functions bodies as needed.\n\t(find_obviously_necessary_stmts): Never mark PHI nodes as\n\tobviously necessary.\n\nFrom-SVN: r119740", "tree": {"sha": "c10c3e1e438be55ec7fabae41f6449845ab479fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c10c3e1e438be55ec7fabae41f6449845ab479fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/comments", "author": null, "committer": null, "parents": [{"sha": "546447ae68630c589ab35c109430caa4656a2453", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546447ae68630c589ab35c109430caa4656a2453", "html_url": "https://github.com/Rust-GCC/gccrs/commit/546447ae68630c589ab35c109430caa4656a2453"}], "stats": {"total": 350, "additions": 167, "deletions": 183}, "files": [{"sha": "9b4ad41528710eb41a8c178301e69957390c0911", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce", "patch": "@@ -1,3 +1,15 @@\n+2006-12-11  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-scalar-evolution.c (scev_const_prop):\n+\t* tree-phinodes.c (remove_phi_node): Add argument\n+\tRELEASE_LHS_P.  If given, release the SSA name on the LHS of\n+\tthe PHI node.\n+\tUpdate all users.\n+\t* tree-ssa-dce.c: Remove forward declarations for static\n+\tfunctions.  Re-arrange functions bodies as needed.\n+\t(find_obviously_necessary_stmts): Never mark PHI nodes as\n+\tobviously necessary.\n+\n 2006-12-11  Carlos O'Donell  <carlos@codesourcery.com>\n \n \t* config/arm/elf.h (MAX_OFILE_ALIGNMENT): Remove definition."}, {"sha": "8972e50b362881ae9114ddf8b54e8ac352863aa4", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce", "patch": "@@ -2474,13 +2474,9 @@ perfect_nestify (struct loop *loop,\n     }\n   e = redirect_edge_and_branch (single_succ_edge (preheaderbb), headerbb);\n \n-  /* Remove the exit phis from the old basic block.  Make sure to set\n-     PHI_RESULT to null so it doesn't get released.  */\n+  /* Remove the exit phis from the old basic block.  */\n   while (phi_nodes (olddest) != NULL)\n-    {\n-      SET_PHI_RESULT (phi_nodes (olddest), NULL);\n-      remove_phi_node (phi_nodes (olddest), NULL);\n-    }      \n+    remove_phi_node (phi_nodes (olddest), NULL, false);\n \n   /* and add them back to the new basic block.  */\n   while (VEC_length (tree, phis) != 0)"}, {"sha": "f738d409d53392b7ed8be016e27c03df54b1e137", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce", "patch": "@@ -1333,13 +1333,12 @@ tree_merge_blocks (basic_block a, basic_block b)\n \t     appear as arguments of the phi nodes.  */\n \t  copy = build2_gimple (GIMPLE_MODIFY_STMT, def, use);\n \t  bsi_insert_after (&bsi, copy, BSI_NEW_STMT);\n-\t  SET_PHI_RESULT (phi, NULL_TREE);\n \t  SSA_NAME_DEF_STMT (def) = copy;\n \t}\n       else\n \treplace_uses_by (def, use);\n \n-      remove_phi_node (phi, NULL);\n+      remove_phi_node (phi, NULL, false);\n     }\n \n   /* Ensure that B follows A.  */\n@@ -1970,7 +1969,7 @@ remove_phi_nodes_and_edges_for_unreachable_block (basic_block bb)\n   while (phi)\n     {\n       tree next = PHI_CHAIN (phi);\n-      remove_phi_node (phi, NULL_TREE);\n+      remove_phi_node (phi, NULL_TREE, true);\n       phi = next;\n     }\n "}, {"sha": "aa36ad4940de30c039d065f7158c50a5fd76dad7", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce", "patch": "@@ -687,7 +687,7 @@ extern void reserve_phi_args_for_new_edge (basic_block);\n extern tree create_phi_node (tree, basic_block);\n extern void add_phi_arg (tree, tree, edge);\n extern void remove_phi_args (edge);\n-extern void remove_phi_node (tree, tree);\n+extern void remove_phi_node (tree, tree, bool);\n extern tree phi_reverse (tree);\n \n /* In gimple-low.c  */"}, {"sha": "8197f1ac9b8b1db8c20765362f778dde34294b47", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce", "patch": "@@ -639,7 +639,7 @@ eliminate_virtual_phis (void)\n \t\t    }\n \t\t}\n #endif\n-\t      remove_phi_node (phi, NULL_TREE);\n+\t      remove_phi_node (phi, NULL_TREE, true);\n \t    }\n \t}\n     }\n@@ -1170,13 +1170,13 @@ remove_ssa_form (bool perform_ter)\n   if (values)\n     free (values);\n \n-  /* Remove phi nodes which have been translated back to real variables.  */\n+  /* Remove PHI nodes which have been translated back to real variables.  */\n   FOR_EACH_BB (bb)\n     {\n       for (phi = phi_nodes (bb); phi; phi = next)\n \t{\n \t  next = PHI_CHAIN (phi);\n-\t  remove_phi_node (phi, NULL_TREE);\n+\t  remove_phi_node (phi, NULL_TREE, true);\n \t}\n     }\n "}, {"sha": "344770e700ae5e6fe1c34504a179210b159ed127", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce", "patch": "@@ -233,6 +233,7 @@ make_phi_node (tree var, int len)\n       imm->next = NULL;\n       imm->stmt = phi;\n     }\n+\n   return phi;\n }\n \n@@ -301,7 +302,6 @@ resize_phi_node (tree *phi, int len)\n       imm->stmt = new_phi;\n     }\n \n-\n   *phi = new_phi;\n }\n \n@@ -343,6 +343,7 @@ reserve_phi_args_for_new_edge (basic_block bb)\n     }\n }\n \n+\n /* Create a new PHI node for variable VAR at basic block BB.  */\n \n tree\n@@ -362,6 +363,7 @@ create_phi_node (tree var, basic_block bb)\n   return phi;\n }\n \n+\n /* Add a new argument to PHI node PHI.  DEF is the incoming reaching\n    definition and E is the edge through which DEF reaches PHI.  The new\n    argument is added at the end of the argument list.\n@@ -394,6 +396,7 @@ add_phi_arg (tree phi, tree def, edge e)\n   SET_PHI_ARG_DEF (phi, e->dest_idx, def);\n }\n \n+\n /* Remove the Ith argument from PHI's argument list.  This routine\n    implements removal by swapping the last alternative with the\n    alternative we want to delete and then shrinking the vector, which\n@@ -406,7 +409,6 @@ remove_phi_arg_num (tree phi, int i)\n \n   gcc_assert (i < num_elem);\n \n-\n   /* Delink the item which is being removed.  */\n   delink_imm_use (&(PHI_ARG_IMM_USE_NODE (phi, i)));\n \n@@ -428,6 +430,7 @@ remove_phi_arg_num (tree phi, int i)\n   PHI_NUM_ARGS (phi)--;\n }\n \n+\n /* Remove all PHI arguments associated with edge E.  */\n \n void\n@@ -439,11 +442,14 @@ remove_phi_args (edge e)\n     remove_phi_arg_num (phi, e->dest_idx);\n }\n \n+\n /* Remove PHI node PHI from basic block BB.  If PREV is non-NULL, it is\n-   used as the node immediately before PHI in the linked list.  */\n+   used as the node immediately before PHI in the linked list.  If\n+   RELEASE_LHS_P is true, the LHS of this PHI node is released into\n+   the free pool of SSA names.  */\n \n void\n-remove_phi_node (tree phi, tree prev)\n+remove_phi_node (tree phi, tree prev, bool release_lhs_p)\n {\n   tree *loc;\n \n@@ -465,7 +471,8 @@ remove_phi_node (tree phi, tree prev)\n   /* If we are deleting the PHI node, then we should release the\n      SSA_NAME node so that it can be reused.  */\n   release_phi_node (phi);\n-  release_ssa_name (PHI_RESULT (phi));\n+  if (release_lhs_p)\n+    release_ssa_name (PHI_RESULT (phi));\n }\n \n "}, {"sha": "bd47befd6796e0a62960215e539f5ccd213a045a", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce", "patch": "@@ -2929,8 +2929,9 @@ scev_const_prop (void)\n \t}\n     }\n \n-  /* Remove the ssa names that were replaced by constants.  We do not remove them\n-     directly in the previous cycle, since this invalidates scev cache.  */\n+  /* Remove the ssa names that were replaced by constants.  We do not\n+     remove them directly in the previous cycle, since this\n+     invalidates scev cache.  */\n   if (ssa_names_to_remove)\n     {\n       bitmap_iterator bi;\n@@ -2941,7 +2942,7 @@ scev_const_prop (void)\n \t  phi = SSA_NAME_DEF_STMT (name);\n \n \t  gcc_assert (TREE_CODE (phi) == PHI_NODE);\n-\t  remove_phi_node (phi, NULL);\n+\t  remove_phi_node (phi, NULL, true);\n \t}\n \n       BITMAP_FREE (ssa_names_to_remove);\n@@ -2998,11 +2999,10 @@ scev_const_prop (void)\n \t      || contains_abnormal_ssa_name_p (def))\n \t    continue;\n \n-\t  /* Eliminate the phi node and replace it by a computation outside\n+\t  /* Eliminate the PHI node and replace it by a computation outside\n \t     the loop.  */\n \t  def = unshare_expr (def);\n-\t  SET_PHI_RESULT (phi, NULL_TREE);\n-\t  remove_phi_node (phi, NULL_TREE);\n+\t  remove_phi_node (phi, NULL_TREE, false);\n \n \t  ass = build2 (GIMPLE_MODIFY_STMT, void_type_node, rslt, NULL_TREE);\n \t  SSA_NAME_DEF_STMT (rslt) = ass;"}, {"sha": "16ff4a30d1f24b6b47677a81464ca835a5aa86c5", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 126, "deletions": 151, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce", "patch": "@@ -112,30 +112,7 @@ static bool cfg_altered;\n   EXECUTE_IF_SET_IN_BITMAP (control_dependence_map[(N)], 0,\t\\\n \t\t\t    (EDGE_NUMBER), (BI))\n \n-/* Local function prototypes.  */\n-static inline void set_control_dependence_map_bit (basic_block, int);\n-static inline void clear_control_dependence_bitmap (basic_block);\n-static void find_all_control_dependences (struct edge_list *);\n-static void find_control_dependence (struct edge_list *, int);\n-static inline basic_block find_pdom (basic_block);\n \n-static inline void mark_stmt_necessary (tree, bool);\n-static inline void mark_operand_necessary (tree, bool);\n-\n-static void mark_stmt_if_obviously_necessary (tree, bool);\n-static void find_obviously_necessary_stmts (struct edge_list *);\n-\n-static void mark_control_dependent_edges_necessary (basic_block, struct edge_list *);\n-static void propagate_necessity (struct edge_list *);\n-\n-static void eliminate_unnecessary_stmts (void);\n-static void remove_dead_phis (basic_block);\n-static void remove_dead_stmt (block_stmt_iterator *, basic_block);\n-\n-static void print_stats (void);\n-static void tree_dce_init (bool);\n-static void tree_dce_done (bool);\n-\f\n /* Indicate block BB is control dependent on an edge with index EDGE_INDEX.  */\n static inline void\n set_control_dependence_map_bit (basic_block bb, int edge_index)\n@@ -153,18 +130,27 @@ clear_control_dependence_bitmap (basic_block bb)\n   bitmap_clear (control_dependence_map[bb->index]);\n }\n \n-/* Record all blocks' control dependences on all edges in the edge\n-   list EL, ala Morgan, Section 3.6.  */\n \n-static void\n-find_all_control_dependences (struct edge_list *el)\n+/* Find the immediate postdominator PDOM of the specified basic block BLOCK.\n+   This function is necessary because some blocks have negative numbers.  */\n+\n+static inline basic_block\n+find_pdom (basic_block block)\n {\n-  int i;\n+  gcc_assert (block != ENTRY_BLOCK_PTR);\n \n-  for (i = 0; i < NUM_EDGES (el); ++i)\n-    find_control_dependence (el, i);\n+  if (block == EXIT_BLOCK_PTR)\n+    return EXIT_BLOCK_PTR;\n+  else\n+    {\n+      basic_block bb = get_immediate_dominator (CDI_POST_DOMINATORS, block);\n+      if (! bb)\n+\treturn EXIT_BLOCK_PTR;\n+      return bb;\n+    }\n }\n \n+\n /* Determine all blocks' control dependences on the given edge with edge_list\n    EL index EDGE_INDEX, ala Morgan, Section 3.6.  */\n \n@@ -197,25 +183,20 @@ find_control_dependence (struct edge_list *el, int edge_index)\n     }\n }\n \n-/* Find the immediate postdominator PDOM of the specified basic block BLOCK.\n-   This function is necessary because some blocks have negative numbers.  */\n \n-static inline basic_block\n-find_pdom (basic_block block)\n+/* Record all blocks' control dependences on all edges in the edge\n+   list EL, ala Morgan, Section 3.6.  */\n+\n+static void\n+find_all_control_dependences (struct edge_list *el)\n {\n-  gcc_assert (block != ENTRY_BLOCK_PTR);\n+  int i;\n \n-  if (block == EXIT_BLOCK_PTR)\n-    return EXIT_BLOCK_PTR;\n-  else\n-    {\n-      basic_block bb = get_immediate_dominator (CDI_POST_DOMINATORS, block);\n-      if (! bb)\n-\treturn EXIT_BLOCK_PTR;\n-      return bb;\n-    }\n+  for (i = 0; i < NUM_EDGES (el); ++i)\n+    find_control_dependence (el, i);\n }\n-\f\n+\n+\n #define NECESSARY(stmt)\t\tstmt->base.asm_written_flag\n \n /* If STMT is not already marked necessary, mark it, and add it to the\n@@ -268,7 +249,7 @@ mark_operand_necessary (tree op, bool phionly)\n   NECESSARY (stmt) = 1;\n   VEC_safe_push (tree, heap, worklist, stmt);\n }\n-\f\n+\n \n /* Mark STMT as necessary if it obviously is.  Add it to the worklist if\n    it can make other statements necessary.\n@@ -374,7 +355,38 @@ mark_stmt_if_obviously_necessary (tree stmt, bool aggressive)\n \n   return;\n }\n-\f\n+\n+\n+/* Make corresponding control dependent edges necessary.  We only\n+   have to do this once for each basic block, so we clear the bitmap\n+   after we're done.  */\n+static void\n+mark_control_dependent_edges_necessary (basic_block bb, struct edge_list *el)\n+{\n+  bitmap_iterator bi;\n+  unsigned edge_number;\n+\n+  gcc_assert (bb != EXIT_BLOCK_PTR);\n+\n+  if (bb == ENTRY_BLOCK_PTR)\n+    return;\n+\n+  EXECUTE_IF_CONTROL_DEPENDENT (bi, bb->index, edge_number)\n+    {\n+      tree t;\n+      basic_block cd_bb = INDEX_EDGE_PRED_BB (el, edge_number);\n+\n+      if (TEST_BIT (last_stmt_necessary, cd_bb->index))\n+\tcontinue;\n+      SET_BIT (last_stmt_necessary, cd_bb->index);\n+\n+      t = last_stmt (cd_bb);\n+      if (t && is_ctrl_stmt (t))\n+\tmark_stmt_necessary (t, true);\n+    }\n+}\n+\n+\n /* Find obviously necessary statements.  These are things like most function\n    calls, and stores to file level variables.\n \n@@ -393,21 +405,9 @@ find_obviously_necessary_stmts (struct edge_list *el)\n     {\n       tree phi;\n \n-      /* Check any PHI nodes in the block.  */\n+      /* PHI nodes are never inherently necessary.  */\n       for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  NECESSARY (phi) = 0;\n-\n-\t  /* PHIs for virtual variables do not directly affect code\n-\t     generation and need not be considered inherently necessary\n-\t     regardless of the bits set in their decl.\n-\n-\t     Thus, we only need to mark PHIs for real variables which\n-\t     need their result preserved as being inherently necessary.  */\n-\t  if (is_gimple_reg (PHI_RESULT (phi))\n-\t      && is_global_var (SSA_NAME_VAR (PHI_RESULT (phi))))\n-\t    mark_stmt_necessary (phi, true);\n-        }\n+\tNECESSARY (phi) = 0;\n \n       /* Check all statements in the block.  */\n       for (i = bsi_start (bb); ! bsi_end_p (i); bsi_next (&i))\n@@ -431,69 +431,42 @@ find_obviously_necessary_stmts (struct edge_list *el)\n \t}\n     }\n }\n-\f\n-/* Make corresponding control dependent edges necessary.  We only\n-   have to do this once for each basic block, so we clear the bitmap\n-   after we're done.  */\n-static void\n-mark_control_dependent_edges_necessary (basic_block bb, struct edge_list *el)\n-{\n-  bitmap_iterator bi;\n-  unsigned edge_number;\n-\n-  gcc_assert (bb != EXIT_BLOCK_PTR);\n-\n-  if (bb == ENTRY_BLOCK_PTR)\n-    return;\n-\n-  EXECUTE_IF_CONTROL_DEPENDENT (bi, bb->index, edge_number)\n-    {\n-      tree t;\n-      basic_block cd_bb = INDEX_EDGE_PRED_BB (el, edge_number);\n \n-      if (TEST_BIT (last_stmt_necessary, cd_bb->index))\n-\tcontinue;\n-      SET_BIT (last_stmt_necessary, cd_bb->index);\n \n-      t = last_stmt (cd_bb);\n-      if (t && is_ctrl_stmt (t))\n-\tmark_stmt_necessary (t, true);\n-    }\n-}\n-\f\n-/* Propagate necessity using the operands of necessary statements.  Process\n-   the uses on each statement in the worklist, and add all feeding statements\n-   which contribute to the calculation of this value to the worklist.\n+/* Propagate necessity using the operands of necessary statements.\n+   Process the uses on each statement in the worklist, and add all\n+   feeding statements which contribute to the calculation of this\n+   value to the worklist. \n \n    In conservative mode, EL is NULL.  */\n \n static void\n propagate_necessity (struct edge_list *el)\n {\n-  tree i;\n+  tree stmt;\n   bool aggressive = (el ? true : false); \n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\nProcessing worklist:\\n\");\n \n   while (VEC_length (tree, worklist) > 0)\n     {\n-      /* Take `i' from worklist.  */\n-      i = VEC_pop (tree, worklist);\n+      /* Take STMT from worklist.  */\n+      stmt = VEC_pop (tree, worklist);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"processing: \");\n-\t  print_generic_stmt (dump_file, i, TDF_SLIM);\n+\t  print_generic_stmt (dump_file, stmt, TDF_SLIM);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n \n       if (aggressive)\n \t{\n \t  /* Mark the last statements of the basic blocks that the block\n-\t     containing `i' is control dependent on, but only if we haven't\n+\t     containing STMT is control dependent on, but only if we haven't\n \t     already done so.  */\n-\t  basic_block bb = bb_for_stmt (i);\n+\t  basic_block bb = bb_for_stmt (stmt);\n \t  if (bb != ENTRY_BLOCK_PTR\n \t      && ! TEST_BIT (visited_control_parents, bb->index))\n \t    {\n@@ -502,7 +475,7 @@ propagate_necessity (struct edge_list *el)\n \t    }\n \t}\n \n-      if (TREE_CODE (i) == PHI_NODE)\n+      if (TREE_CODE (stmt) == PHI_NODE)\n \t{\n \t  /* PHI nodes are somewhat special in that each PHI alternative has\n \t     data and control dependencies.  All the statements feeding the\n@@ -511,18 +484,19 @@ propagate_necessity (struct edge_list *el)\n \t     predecessor block associated with each PHI alternative as\n \t     necessary.  */\n \t  int k;\n-\t  for (k = 0; k < PHI_NUM_ARGS (i); k++)\n+\n+\t  for (k = 0; k < PHI_NUM_ARGS (stmt); k++)\n             {\n-\t      tree arg = PHI_ARG_DEF (i, k);\n+\t      tree arg = PHI_ARG_DEF (stmt, k);\n \t      if (TREE_CODE (arg) == SSA_NAME)\n \t\tmark_operand_necessary (arg, false);\n \t    }\n \n \t  if (aggressive)\n \t    {\n-\t      for (k = 0; k < PHI_NUM_ARGS (i); k++)\n+\t      for (k = 0; k < PHI_NUM_ARGS (stmt); k++)\n \t\t{\n-\t\t  basic_block arg_bb = PHI_ARG_EDGE (i, k)->src;\n+\t\t  basic_block arg_bb = PHI_ARG_EDGE (stmt, k)->src;\n \t\t  if (arg_bb != ENTRY_BLOCK_PTR\n \t\t      && ! TEST_BIT (visited_control_parents, arg_bb->index))\n \t\t    {\n@@ -545,7 +519,7 @@ propagate_necessity (struct edge_list *el)\n \t     statement (V_MAY_DEF operands allow us to follow def-def \n \t     links).  */\n \n-\t  FOR_EACH_SSA_TREE_OPERAND (use, i, iter, SSA_OP_ALL_USES)\n+\t  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_ALL_USES)\n \t    mark_operand_necessary (use, false);\n \t}\n     }\n@@ -616,50 +590,6 @@ mark_really_necessary_kill_operand_phis (void)\n }\n \n \n-\f\n-\n-/* Eliminate unnecessary statements. Any instruction not marked as necessary\n-   contributes nothing to the program, and can be deleted.  */\n-\n-static void\n-eliminate_unnecessary_stmts (void)\n-{\n-  basic_block bb;\n-  block_stmt_iterator i;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\nEliminating unnecessary statements:\\n\");\n-  \n-  clear_special_calls ();\n-  FOR_EACH_BB (bb)\n-    {\n-      /* Remove dead PHI nodes.  */\n-      remove_dead_phis (bb);\n-    }\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      /* Remove dead statements.  */\n-      for (i = bsi_start (bb); ! bsi_end_p (i) ; )\n-\t{\n-         tree t = bsi_stmt (i);\n-\n-         stats.total++;\n-\n-         /* If `i' is not necessary then remove it.  */\n-         if (! NECESSARY (t))\n-           remove_dead_stmt (&i, bb);\n-         else\n-           {\n-             tree call = get_call_expr_in (t);\n-             if (call)\n-               notice_special_calls (call);\n-             bsi_next (&i);\n-           }\n-\t}\n-    }\n- }\n-\f\n /* Remove dead PHI nodes from block BB.  */\n \n static void\n@@ -684,7 +614,7 @@ remove_dead_phis (basic_block bb)\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \n-\t  remove_phi_node (phi, prev);\n+\t  remove_phi_node (phi, prev, true);\n \t  stats.removed_phis++;\n \t  phi = next;\n \t}\n@@ -695,7 +625,8 @@ remove_dead_phis (basic_block bb)\n \t}\n     }\n }\n-\f\n+\n+\n /* Remove dead statement pointed to by iterator I.  Receives the basic block BB\n    containing I so that we don't have to look it up.  */\n \n@@ -788,7 +719,51 @@ remove_dead_stmt (block_stmt_iterator *i, basic_block bb)\n   bsi_remove (i, true);  \n   release_defs (t); \n }\n-\f\n+\n+\n+/* Eliminate unnecessary statements. Any instruction not marked as necessary\n+   contributes nothing to the program, and can be deleted.  */\n+\n+static void\n+eliminate_unnecessary_stmts (void)\n+{\n+  basic_block bb;\n+  block_stmt_iterator i;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\nEliminating unnecessary statements:\\n\");\n+\n+  clear_special_calls ();\n+  FOR_EACH_BB (bb)\n+    {\n+      /* Remove dead PHI nodes.  */\n+      remove_dead_phis (bb);\n+    }\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      /* Remove dead statements.  */\n+      for (i = bsi_start (bb); ! bsi_end_p (i) ; )\n+\t{\n+\t  tree t = bsi_stmt (i);\n+\n+\t  stats.total++;\n+\n+\t  /* If `i' is not necessary then remove it.  */\n+\t  if (! NECESSARY (t))\n+\t    remove_dead_stmt (&i, bb);\n+\t  else\n+\t    {\n+\t      tree call = get_call_expr_in (t);\n+\t      if (call)\n+\t\tnotice_special_calls (call);\n+\t      bsi_next (&i);\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n /* Print out removed statement statistics.  */\n \n static void"}, {"sha": "dcd4b86b42a668e653823d705daab812b550690c", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce", "patch": "@@ -2089,7 +2089,7 @@ static void\n remove_stmt_or_phi (tree t)\n {\n   if (TREE_CODE (t) == PHI_NODE)\n-    remove_phi_node (t, NULL);\n+    remove_phi_node (t, NULL, true);\n   else\n     {\n       block_stmt_iterator bsi = bsi_for_stmt (t);"}, {"sha": "ca95823f6a2397fd7ca14cb0ac993bca8acaac87", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce", "patch": "@@ -5351,12 +5351,7 @@ remove_statement (tree stmt, bool including_defined_name)\n {\n   if (TREE_CODE (stmt) == PHI_NODE)\n     {\n-      if (!including_defined_name)\n-\t{\n-\t  /* Prevent the ssa name defined by the statement from being removed.  */\n-\t  SET_PHI_RESULT (stmt, NULL);\n-\t}\n-      remove_phi_node (stmt, NULL_TREE);\n+      remove_phi_node (stmt, NULL_TREE, including_defined_name);\n     }\n   else\n     {"}, {"sha": "c0c5d5eabfdf4e3e235b3d2f91e5ccda57c9e0c4", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=9b3b55a10516cf15d37f39ac473ad86b6ae3c3ce", "patch": "@@ -4035,7 +4035,7 @@ remove_dead_inserted_code (void)\n \n \t  if (TREE_CODE (t) == PHI_NODE)\n \t    {\n-\t      remove_phi_node (t, NULL);\n+\t      remove_phi_node (t, NULL, true);\n \t    }\n \t  else\n \t    {"}]}