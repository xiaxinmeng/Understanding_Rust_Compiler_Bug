{"sha": "ba42e045f7da0362ac1ff19ce0a2210999f7f1f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE0MmUwNDVmN2RhMDM2MmFjMWZmMTljZTBhMjIxMDk5OWY3ZjFmOA==", "commit": {"author": {"name": "Sebastian Pop", "email": "pop@cri.ensmp.fr", "date": "2006-03-26T20:48:05Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2006-03-26T20:48:05Z"}, "message": "tree-data-ref.c: Rename DDR_SIZE_VECT to DDR_NB_LOOPS.\n\n\t* tree-data-ref.c: Rename DDR_SIZE_VECT to DDR_NB_LOOPS.\n\t(subscript_dependence_tester_1): Declared.\n\t(print_dir_vectors, print_dist_vectors): New.\n\t(debug_data_dependence_relation): New.\n\t(dump_data_dependence_relation): Print more details.\n\t(initialize_data_dependence_relation): Initialize DDR_LOOP_NEST.\n\t(analyze_subscript_affine_affine): Don't ICE when gcd_alpha_beta is 0.\n\t(save_dist_v, save_dir_v, add_outer_distances,\n\tbuild_classic_dist_vector_1): New.\n\t(build_classic_dist_vector): Rewrite to work on DDR_LOOP_NEST.\n\tDon't test for lambda_vector_lexico_pos.\n\t(same_access_functions, add_multivariate_self_dist,\n\tadd_other_self_distances, dir_from_dist): New.\n\t(build_classic_dir_vector): Replace implementation almost identical to \n\tbuild_classic_dist_vector with a walk of DDR_DIST_VECTS with a call to\n\tdir_from_dist.\n\t(subscript_dependence_tester_1): New.\n\t(subscript_dependence_tester): Handle the lexicographically negative\n\tdistance vectors by recomputing the dependence relation.\n\t(compute_affine_dependence): Remove parameter loop_nest_depth.\n\t(compute_self_dependence): Don't call compute_subscript_distance.\n\t(compute_all_dependences): Remove parameters nb_loops, loop_nest_depth.\n\tAdd a parameter for the loop_nest.\n\t(find_loop_nest_1, find_loop_nest): New.\n\t(compute_data_dependences_for_loop): Compute the loop nest, and give\n\tup if the nest is not well formed.\n\t* tree-data-ref.h (loop_p): New.\n\t(struct data_dependence_relation): Replace size_vect field with \n\tloop_nest, a vec of loops.\n\t(DDR_SIZE_VECT): Renamed DDR_NB_LOOPS.\n\t(DDR_LOOP_NEST): New.\n\t(print_dir_vectors, print_dist_vectors,\n\tdebug_data_dependence_relation): Declared.\n\t(index_in_loop_nest): New.\n\t* tree-vect-analyze.c (vect_analyze_data_ref_dependence): Use\n\tDDR_LOOP_NEST and index_in_loop_nest to determine the dependence\n\tdistance.\n\nFrom-SVN: r112399", "tree": {"sha": "99a886cf9eb5495a779c7221d1a028574d5e242d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99a886cf9eb5495a779c7221d1a028574d5e242d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba42e045f7da0362ac1ff19ce0a2210999f7f1f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba42e045f7da0362ac1ff19ce0a2210999f7f1f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba42e045f7da0362ac1ff19ce0a2210999f7f1f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba42e045f7da0362ac1ff19ce0a2210999f7f1f8/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0535d6d75b7dd27343da2f6fcea8af9725305721", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0535d6d75b7dd27343da2f6fcea8af9725305721", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0535d6d75b7dd27343da2f6fcea8af9725305721"}], "stats": {"total": 944, "additions": 546, "deletions": 398}, "files": [{"sha": "890c90c7f536635d75a25c8a90884818bb8e80c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba42e045f7da0362ac1ff19ce0a2210999f7f1f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba42e045f7da0362ac1ff19ce0a2210999f7f1f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba42e045f7da0362ac1ff19ce0a2210999f7f1f8", "patch": "@@ -1,3 +1,43 @@\n+2006-03-26  Sebastian Pop  <pop@cri.ensmp.fr>\n+\n+\t* tree-data-ref.c: Rename DDR_SIZE_VECT to DDR_NB_LOOPS.\n+\t(subscript_dependence_tester_1): Declared.\n+\t(print_dir_vectors, print_dist_vectors): New.\n+\t(debug_data_dependence_relation): New.\n+\t(dump_data_dependence_relation): Print more details.\n+\t(initialize_data_dependence_relation): Initialize DDR_LOOP_NEST.\n+\t(analyze_subscript_affine_affine): Don't ICE when gcd_alpha_beta is 0.\n+\t(save_dist_v, save_dir_v, add_outer_distances,\n+\tbuild_classic_dist_vector_1): New.\n+\t(build_classic_dist_vector): Rewrite to work on DDR_LOOP_NEST.\n+\tDon't test for lambda_vector_lexico_pos.\n+\t(same_access_functions, add_multivariate_self_dist,\n+\tadd_other_self_distances, dir_from_dist): New.\n+\t(build_classic_dir_vector): Replace implementation almost identical to \n+\tbuild_classic_dist_vector with a walk of DDR_DIST_VECTS with a call to\n+\tdir_from_dist.\n+\t(subscript_dependence_tester_1): New.\n+\t(subscript_dependence_tester): Handle the lexicographically negative\n+\tdistance vectors by recomputing the dependence relation.\n+\t(compute_affine_dependence): Remove parameter loop_nest_depth.\n+\t(compute_self_dependence): Don't call compute_subscript_distance.\n+\t(compute_all_dependences): Remove parameters nb_loops, loop_nest_depth.\n+\tAdd a parameter for the loop_nest.\n+\t(find_loop_nest_1, find_loop_nest): New.\n+\t(compute_data_dependences_for_loop): Compute the loop nest, and give\n+\tup if the nest is not well formed.\n+\t* tree-data-ref.h (loop_p): New.\n+\t(struct data_dependence_relation): Replace size_vect field with \n+\tloop_nest, a vec of loops.\n+\t(DDR_SIZE_VECT): Renamed DDR_NB_LOOPS.\n+\t(DDR_LOOP_NEST): New.\n+\t(print_dir_vectors, print_dist_vectors,\n+\tdebug_data_dependence_relation): Declared.\n+\t(index_in_loop_nest): New.\n+\t* tree-vect-analyze.c (vect_analyze_data_ref_dependence): Use\n+\tDDR_LOOP_NEST and index_in_loop_nest to determine the dependence\n+\tdistance.\n+\n 2006-03-25  Adam Nemet  <anemet@caviumnetworks.com>\n \n \t* simplify-rtx.c (simplify_relational_operation): Call"}, {"sha": "8c3ee359e33ac03d8402ee5afbe67e41c86bd4fd", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 471, "deletions": 383, "changes": 854, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba42e045f7da0362ac1ff19ce0a2210999f7f1f8/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba42e045f7da0362ac1ff19ce0a2210999f7f1f8/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=ba42e045f7da0362ac1ff19ce0a2210999f7f1f8", "patch": "@@ -128,7 +128,9 @@ static struct data_reference * init_data_ref (tree, tree, tree, tree, bool,\n \t\t\t\t\t      tree, tree, tree, tree, tree, \n \t\t\t\t\t      struct ptr_info_def *,\n \t\t\t\t\t      enum  data_ref_type);\n-\n+static bool subscript_dependence_tester_1 (struct data_dependence_relation *,\n+\t\t\t\t\t   struct data_reference *,\n+\t\t\t\t\t   struct data_reference *);\n \n /* Determine if PTR and DECL may alias, the result is put in ALIASED.\n    Return FALSE if there is no symbol memory tag for PTR.  */\n@@ -653,6 +655,40 @@ print_direction_vector (FILE *outf,\n   fprintf (outf, \"\\n\");\n }\n \n+/* Print a vector of direction vectors.  */\n+\n+void\n+print_dir_vectors (FILE *outf, VEC (lambda_vector, heap) *dir_vects,\n+\t\t   int length)\n+{\n+  unsigned j;\n+  lambda_vector v;\n+\n+  for (j = 0; VEC_iterate (lambda_vector, dir_vects, j, v); j++)\n+    print_direction_vector (outf, v, length);\n+}\n+\n+/* Print a vector of distance vectors.  */\n+\n+void\n+print_dist_vectors  (FILE *outf, VEC (lambda_vector, heap) *dist_vects,\n+\t\t     int length)\n+{\n+  unsigned j;\n+  lambda_vector v;\n+\n+  for (j = 0; VEC_iterate (lambda_vector, dist_vects, j, v); j++)\n+    print_lambda_vector (outf, v, length);\n+}\n+\n+/* Debug version.  */\n+\n+void \n+debug_data_dependence_relation (struct data_dependence_relation *ddr)\n+{\n+  dump_data_dependence_relation (stderr, ddr);\n+}\n+\n /* Dump function for a DATA_DEPENDENCE_RELATION structure.  */\n \n void \n@@ -673,6 +709,7 @@ dump_data_dependence_relation (FILE *outf,\n   else if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n     {\n       unsigned int i;\n+      struct loop *loopi;\n \n       for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n \t{\n@@ -683,18 +720,23 @@ dump_data_dependence_relation (FILE *outf,\n \t  dump_subscript (outf, DDR_SUBSCRIPT (ddr, i));\n \t}\n \n+      fprintf (outf, \"  loop nest: (\");\n+      for (i = 0; VEC_iterate (loop_p, DDR_LOOP_NEST (ddr), i, loopi); i++)\n+\tfprintf (outf, \"%d \", loopi->num);\n+      fprintf (outf, \")\\n\");\n+\n       for (i = 0; i < DDR_NUM_DIST_VECTS (ddr); i++)\n \t{\n \t  fprintf (outf, \"  distance_vector: \");\n \t  print_lambda_vector (outf, DDR_DIST_VECT (ddr, i),\n-\t\t\t       DDR_SIZE_VECT (ddr));\n+\t\t\t       DDR_NB_LOOPS (ddr));\n \t}\n \n       for (i = 0; i < DDR_NUM_DIR_VECTS (ddr); i++)\n \t{\n \t  fprintf (outf, \"  direction_vector: \");\n \t  print_direction_vector (outf, DDR_DIR_VECT (ddr, i),\n-\t\t\t\t  DDR_SIZE_VECT (ddr));\n+\t\t\t\t  DDR_NB_LOOPS (ddr));\n \t}\n     }\n \n@@ -764,15 +806,15 @@ dump_dist_dir_vectors (FILE *file, varray_type ddrs)\n \t    {\n \t      fprintf (file, \"DISTANCE_V (\");\n \t      print_lambda_vector (file, DDR_DIST_VECT (ddr, j),\n-\t\t\t\t   DDR_SIZE_VECT (ddr));\n+\t\t\t\t   DDR_NB_LOOPS (ddr));\n \t      fprintf (file, \")\\n\");\n \t    }\n \n \t  for (j = 0; j < DDR_NUM_DIR_VECTS (ddr); j++)\n \t    {\n \t      fprintf (file, \"DIRECTION_V (\");\n \t      print_direction_vector (file, DDR_DIR_VECT (ddr, j),\n-\t\t\t\t      DDR_SIZE_VECT (ddr));\n+\t\t\t\t      DDR_NB_LOOPS (ddr));\n \t      fprintf (file, \")\\n\");\n \t    }\n \t}\n@@ -2047,7 +2089,7 @@ compute_subscript_distance (struct data_dependence_relation *ddr)\n static struct data_dependence_relation *\n initialize_data_dependence_relation (struct data_reference *a, \n \t\t\t\t     struct data_reference *b,\n-\t\t\t\t     int nb_loops)\n+ \t\t\t\t     VEC (loop_p, heap) *loop_nest)\n {\n   struct data_dependence_relation *res;\n   bool differ_p, known_dependence;\n@@ -2090,11 +2132,11 @@ initialize_data_dependence_relation (struct data_reference *a,\n       DDR_ARE_DEPENDENT (res) = chrec_known;    \n       return res;\n     }\n-\n+    \n   DDR_AFFINE_P (res) = true;\n   DDR_ARE_DEPENDENT (res) = NULL_TREE;\n   DDR_SUBSCRIPTS_VECTOR_INIT (res, DR_NUM_DIMENSIONS (a));\n-  DDR_SIZE_VECT (res) = nb_loops;\n+  DDR_LOOP_NEST (res) = loop_nest;\n   DDR_DIR_VECTS (res) = NULL;\n   DDR_DIST_VECTS (res) = NULL;\n \n@@ -2766,6 +2808,17 @@ analyze_subscript_affine_affine (tree chrec_a,\n     }\n   gcd_alpha_beta = S[0][0];\n \n+  /* Something went wrong: for example in {1, +, 0}_5 vs. {0, +, 0}_5,\n+     but that is a quite strange case.  Instead of ICEing, answer\n+     don't know.  */\n+  if (gcd_alpha_beta == 0)\n+    {\n+      *overlaps_a = chrec_dont_know;\n+      *overlaps_b = chrec_dont_know;\n+      *last_conflicts = chrec_dont_know;\n+      goto end_analyze_subs_aa;\n+    }\n+\n   /* The classic \"gcd-test\".  */\n   if (!int_divides_p (gcd_alpha_beta, gamma))\n     {\n@@ -3298,35 +3351,79 @@ analyze_overlapping_iterations (tree chrec_a,\n     }\n }\n \n-\f\n+/* Helper function for uniquely inserting distance vectors.  */\n \n-/* This section contains the affine functions dependences detector.  */\n+static void\n+save_dist_v (struct data_dependence_relation *ddr, lambda_vector dist_v)\n+{\n+  unsigned i;\n+  lambda_vector v;\n \n-/* Compute the classic per loop distance vector.\n+  for (i = 0; VEC_iterate (lambda_vector, DDR_DIST_VECTS (ddr), i, v); i++)\n+    if (lambda_vector_equal (v, dist_v, DDR_NB_LOOPS (ddr)))\n+      return;\n \n-   DDR is the data dependence relation to build a vector from.\n-   NB_LOOPS is the total number of loops we are considering.\n-   FIRST_LOOP_DEPTH is the loop->depth of the first loop in the analyzed\n-   loop nest.  \n-   Return FALSE when fail to represent the data dependence as a distance\n-   vector.\n-   Return TRUE otherwise.  */\n+  VEC_safe_push (lambda_vector, heap, DDR_DIST_VECTS (ddr), dist_v);\n+}\n \n-static bool\n-build_classic_dist_vector (struct data_dependence_relation *ddr, \n-\t\t\t   int first_loop_depth)\n+/* Helper function for uniquely inserting direction vectors.  */\n+\n+static void\n+save_dir_v (struct data_dependence_relation *ddr, lambda_vector dir_v)\n {\n   unsigned i;\n-  lambda_vector dist_v, init_v;\n-  int nb_loops = DDR_SIZE_VECT (ddr);\n-  bool init_b = false;\n-  \n-  DDR_SIZE_VECT (ddr) = nb_loops;\n-  dist_v = lambda_vector_new (nb_loops);\n-  init_v = lambda_vector_new (nb_loops);\n+  lambda_vector v;\n \n-  if (DDR_ARE_DEPENDENT (ddr) != NULL_TREE)\n-    return true;\n+  for (i = 0; VEC_iterate (lambda_vector, DDR_DIR_VECTS (ddr), i, v); i++)\n+    if (lambda_vector_equal (v, dir_v, DDR_NB_LOOPS (ddr)))\n+      return;\n+\n+  VEC_safe_push (lambda_vector, heap, DDR_DIR_VECTS (ddr), dir_v);\n+}\n+\n+/* Add a distance of 1 on all the loops outer than INDEX.  If we\n+   haven't yet determined a distance for this outer loop, push a new\n+   distance vector composed of the previous distance, and a distance\n+   of 1 for this outer loop.  Example:\n+\n+   | loop_1\n+   |   loop_2\n+   |     A[10]\n+   |   endloop_2\n+   | endloop_1\n+\n+   Saved vectors are of the form (dist_in_1, dist_in_2).  First, we\n+   save (0, 1), then we have to save (1, 0).  */\n+\n+static void\n+add_outer_distances (struct data_dependence_relation *ddr,\n+\t\t     lambda_vector dist_v, int index)\n+{\n+  /* For each outer loop where init_v is not set, the accesses are\n+     in dependence of distance 1 in the loop.  */\n+  while (--index >= 0)\n+    {\n+      lambda_vector save_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n+      lambda_vector_copy (dist_v, save_v, DDR_NB_LOOPS (ddr));\n+      save_v[index] = 1;\n+      save_dist_v (ddr, save_v);\n+    }\n+}\n+\n+/* Return false when fail to represent the data dependence as a\n+   distance vector.  INIT_B is set to true when a component has been\n+   added to the distance vector DIST_V.  INDEX_CARRY is then set to\n+   the index in DIST_V that carries the dependence.  */\n+\n+static bool\n+build_classic_dist_vector_1 (struct data_dependence_relation *ddr,\n+\t\t\t     struct data_reference *ddr_a,\n+\t\t\t     struct data_reference *ddr_b,\n+\t\t\t     lambda_vector dist_v, bool *init_b,\n+\t\t\t     int *index_carry)\n+{\n+  unsigned i;\n+  lambda_vector init_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n \n   for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n     {\n@@ -3336,47 +3433,20 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n       if (chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n \t{\n \t  non_affine_dependence_relation (ddr);\n-\t  return true;\n+\t  return false;\n \t}\n \n-      access_fn_a = DR_ACCESS_FN (DDR_A (ddr), i);\n-      access_fn_b = DR_ACCESS_FN (DDR_B (ddr), i);\n+      access_fn_a = DR_ACCESS_FN (ddr_a, i);\n+      access_fn_b = DR_ACCESS_FN (ddr_b, i);\n \n       if (TREE_CODE (access_fn_a) == POLYNOMIAL_CHREC \n \t  && TREE_CODE (access_fn_b) == POLYNOMIAL_CHREC)\n \t{\n-\t  int dist, loop_nb, loop_depth;\n-\t  int loop_nb_a = CHREC_VARIABLE (access_fn_a);\n-\t  int loop_nb_b = CHREC_VARIABLE (access_fn_b);\n-\t  struct loop *loop_a = current_loops->parray[loop_nb_a];\n-\t  struct loop *loop_b = current_loops->parray[loop_nb_b];\n-\n-\t  /* If the loop for either variable is at a lower depth than \n-\t     the first_loop's depth, then we can't possibly have a\n-\t     dependency at this level of the loop.  */\n-\t     \n-\t  if (loop_a->depth < first_loop_depth\n-\t      || loop_b->depth < first_loop_depth)\n-\t    return false;\n-\n-\t  if (loop_nb_a != loop_nb_b\n-\t      && !flow_loop_nested_p (loop_a, loop_b)\n-\t      && !flow_loop_nested_p (loop_b, loop_a))\n-\t    {\n-\t      /* Example: when there are two consecutive loops,\n-\n-\t\t | loop_1\n-\t\t |   A[{0, +, 1}_1]\n-\t\t | endloop_1\n-\t\t | loop_2\n-\t\t |   A[{0, +, 1}_2]\n-\t\t | endloop_2\n-\n-\t\t the dependence relation cannot be captured by the\n-\t\t distance abstraction.  */\n-\t      non_affine_dependence_relation (ddr);\n-\t      return true;\n-\t    }\n+\t  int dist, index;\n+\t  int index_a = index_in_loop_nest (CHREC_VARIABLE (access_fn_a),\n+\t\t\t\t\t    DDR_LOOP_NEST (ddr));\n+\t  int index_b = index_in_loop_nest (CHREC_VARIABLE (access_fn_b),\n+\t\t\t\t\t    DDR_LOOP_NEST (ddr));\n \n \t  /* The dependence is carried by the outermost loop.  Example:\n \t     | loop_1\n@@ -3386,349 +3456,327 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n \t     |   endloop_2\n \t     | endloop_1\n \t     In this case, the dependence is carried by loop_1.  */\n-\t  loop_nb = loop_nb_a < loop_nb_b ? loop_nb_a : loop_nb_b;\n-\t  loop_depth = current_loops->parray[loop_nb]->depth - first_loop_depth;\n-\n-\t  /* If the loop number is still greater than the number of\n-\t     loops we've been asked to analyze, or negative,\n-\t     something is borked.  */\n-\t  gcc_assert (loop_depth >= 0);\n-\t  gcc_assert (loop_depth < nb_loops);\n+\t  index = index_a < index_b ? index_a : index_b;\n+\t  *index_carry = MIN (index, *index_carry);\n+\n \t  if (chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n \t    {\n \t      non_affine_dependence_relation (ddr);\n-\t      return true;\n+\t      return false;\n \t    }\n \t  \n \t  dist = int_cst_value (SUB_DISTANCE (subscript));\n \n-\t  /* This is the subscript coupling test.  \n+\t  /* This is the subscript coupling test.  If we have already\n+\t     recorded a distance for this loop (a distance coming from\n+\t     another subscript), it should be the same.  For example,\n+\t     in the following code, there is no dependence:\n+\n \t     | loop i = 0, N, 1\n \t     |   T[i+1][i] = ...\n \t     |   ... = T[i][i]\n \t     | endloop\n-\t     There is no dependence.  */\n-\t  if (init_v[loop_depth] != 0\n-\t      && dist_v[loop_depth] != dist)\n+\t  */\n+\t  if (init_v[index] != 0 && dist_v[index] != dist)\n \t    {\n \t      finalize_ddr_dependent (ddr, chrec_known);\n-\t      return true;\n+\t      return false;\n \t    }\n \n-\t  dist_v[loop_depth] = dist;\n-\t  init_v[loop_depth] = 1;\n-\t  init_b = true;\n+\t  dist_v[index] = dist;\n+\t  init_v[index] = 1;\n+\t  *init_b = true;\n+\t}\n+      else\n+\t{\n+\t  /* This can be for example an affine vs. constant dependence\n+\t     (T[i] vs. T[3]) that is not an affine dependence and is\n+\t     not representable as a distance vector.  */\n+\t  non_affine_dependence_relation (ddr);\n+\t  return false;\n \t}\n     }\n \n-  /* Save the distance vector if we initialized one.  */\n-  if (init_b)\n-    {\n-      lambda_vector save_v;\n+  return true;\n+}\n \n-      /* Verify a basic constraint: classic distance vectors should always\n-\t be lexicographically positive.  */\n-      if (!lambda_vector_lexico_pos (dist_v, DDR_SIZE_VECT (ddr)))\n-\t{\n-\t  if (DDR_SIZE_VECT (ddr) == 1)\n-\t    /* This one is simple to fix, and can be fixed.\n-\t       Multidimensional arrays cannot be fixed that simply.  */\n-\t    lambda_vector_negate (dist_v, dist_v, DDR_SIZE_VECT (ddr));\n-\t  else\n-\t    /* This is not valid: we need the delta test for properly\n-\t       fixing all this.  */\n-\t    return false;\n-\t}\n+/* Return true when the DDR contains two data references that have the\n+   same access functions.  */\n \n-      save_v = lambda_vector_new (DDR_SIZE_VECT (ddr));\n-      lambda_vector_copy (dist_v, save_v, DDR_SIZE_VECT (ddr));\n-      VEC_safe_push (lambda_vector, heap, DDR_DIST_VECTS (ddr), save_v);\n+static bool\n+same_access_functions (struct data_dependence_relation *ddr)\n+{\n+  unsigned i;\n \n-      /* There is nothing more to do when there are no outer loops.  */\n-      if (DDR_SIZE_VECT (ddr) == 1)\n-\tgoto classic_dist_done;\n+  for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n+    {\n+      tree access_fun_a = DR_ACCESS_FN (DDR_A (ddr), i);\n+      tree access_fun_b = DR_ACCESS_FN (DDR_B (ddr), i);\n+      tree difference = chrec_fold_minus (integer_type_node, access_fun_a,\n+\t\t\t\t\t  access_fun_b);\n+      if (TREE_CODE (difference) != INTEGER_CST\n+\t  || !integer_zerop (difference))\n+\treturn false;\n     }\n \n-  /* There is a distance of 1 on all the outer loops: \n-     \n-     Example: there is a dependence of distance 1 on loop_1 for the array A.\n-     | loop_1\n-     |   A[5] = ...\n-     | endloop\n-  */\n-  {\n-    struct loop *lca, *loop_a, *loop_b;\n-    struct data_reference *a = DDR_A (ddr);\n-    struct data_reference *b = DDR_B (ddr);\n-    int lca_depth;\n-    loop_a = loop_containing_stmt (DR_STMT (a));\n-    loop_b = loop_containing_stmt (DR_STMT (b));\n-    \n-    /* Get the common ancestor loop.  */\n-    lca = find_common_loop (loop_a, loop_b); \n-    lca_depth = lca->depth - first_loop_depth;\n+  return true;\n+}\n \n-    gcc_assert (lca_depth >= 0);\n-    gcc_assert (lca_depth < nb_loops);\n-    \n-    /* For each outer loop where init_v is not set, the accesses are\n-       in dependence of distance 1 in the loop.  */\n-    while (lca->depth != 0)\n-      {\n-\t/* If we're considering just a sub-nest, then don't record\n-\t   any information on the outer loops.  */\n-\tif (lca_depth < 0)\n-\t  break;\n+/* Helper function for the case where DDR_A and DDR_B are the same\n+   multivariate access function.  */\n \n-\tgcc_assert (lca_depth < nb_loops);\n+static void\n+add_multivariate_self_dist (struct data_dependence_relation *ddr, tree c_2)\n+{\n+  int x_1, x_2;\n+  tree c_1 = CHREC_LEFT (c_2);\n+  tree c_0 = CHREC_LEFT (c_1);\n+  lambda_vector dist_v;\n \n-\t/* If we haven't yet determined a distance for this outer\n-\t   loop, push a new distance vector composed of the previous\n-\t   distance, and a distance of 1 for this outer loop.\n-\t   Example:\n+  /* Polynomials with more than 2 variables are not handled yet.  */\n+  if (TREE_CODE (c_0) != INTEGER_CST)\n+    {\n+      DDR_ARE_DEPENDENT (ddr) = chrec_dont_know;\n+      return;\n+    }\n \n-\t   | loop_1\n-\t   |   loop_2\n-\t   |     A[10]\n-\t   |   endloop_2\n-\t   | endloop_1\n+  x_2 = index_in_loop_nest (CHREC_VARIABLE (c_2), DDR_LOOP_NEST (ddr));\n+  x_1 = index_in_loop_nest (CHREC_VARIABLE (c_1), DDR_LOOP_NEST (ddr));\n \n-\t   Saved vectors are of the form (dist_in_1, dist_in_2).\n-\t   First, we save (0, 1), then we have to save (1, 0).  */\n-\tif (init_v[lca_depth] == 0)\n-\t  {\n-\t    lambda_vector save_v = lambda_vector_new (DDR_SIZE_VECT (ddr));\n+  /* For \"{{0, +, 2}_1, +, 3}_2\" the distance vector is (3, -2).  */\n+  dist_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n+  dist_v[x_1] = int_cst_value (CHREC_RIGHT (c_2));\n+  dist_v[x_2] = -int_cst_value (CHREC_RIGHT (c_1));\n+  save_dist_v (ddr, dist_v);\n \n-\t    lambda_vector_copy (dist_v, save_v, DDR_SIZE_VECT (ddr));\n-\t    save_v[lca_depth] = 1;\n-\t    VEC_safe_push (lambda_vector, heap, DDR_DIST_VECTS (ddr), save_v);\n-\t  }\n+  add_outer_distances (ddr, dist_v, x_1);\n+}\n \n-\tlca = lca->outer;\n-\tlca_depth = lca->depth - first_loop_depth;\n-      }\n-  }\n+/* Helper function for the case where DDR_A and DDR_B are the same\n+   access functions.  */\n \n- classic_dist_done:;\n+static void\n+add_other_self_distances (struct data_dependence_relation *ddr)\n+{\n+  lambda_vector dist_v;\n+  unsigned i;\n+  int index_carry = DDR_NB_LOOPS (ddr);\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n+  for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n     {\n-      fprintf (dump_file, \"(build_classic_dist_vector\\n\");\n+      tree access_fun = DR_ACCESS_FN (DDR_A (ddr), i);\n \n-      for (i = 0; i < DDR_NUM_DIST_VECTS (ddr); i++)\n+      if (TREE_CODE (access_fun) == POLYNOMIAL_CHREC)\n \t{\n-\t  fprintf (dump_file, \"  dist_vector = (\");\n-\t  print_lambda_vector (dump_file, DDR_DIST_VECT (ddr, i),\n-\t\t\t       DDR_SIZE_VECT (ddr));\n-\t  fprintf (dump_file, \"  )\\n\");\n+\t  if (!evolution_function_is_univariate_p (access_fun))\n+\t    {\n+\t      if (DDR_NUM_SUBSCRIPTS (ddr) != 1)\n+\t\t{\n+\t\t  DDR_ARE_DEPENDENT (ddr) = chrec_dont_know;\n+\t\t  return;\n+\t\t}\n+\n+\t      add_multivariate_self_dist (ddr, DR_ACCESS_FN (DDR_A (ddr), 0));\n+\t      return;\n+\t    }\n+\n+\t  index_carry = MIN (index_carry,\n+\t\t\t     index_in_loop_nest (CHREC_VARIABLE (access_fun),\n+\t\t\t\t\t\t DDR_LOOP_NEST (ddr)));\n \t}\n-      fprintf (dump_file, \")\\n\");\n     }\n \n-  return true;\n+  dist_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n+  add_outer_distances (ddr, dist_v, index_carry);\n }\n \n-/* Compute the classic per loop direction vector.  \n-\n-   DDR is the data dependence relation to build a vector from.\n-   NB_LOOPS is the total number of loops we are considering.\n-   FIRST_LOOP_DEPTH is the loop->depth of the first loop in the analyzed \n-   loop nest.\n-   Return FALSE if the dependence relation is outside of the loop nest\n-   at FIRST_LOOP_DEPTH. \n-   Return TRUE otherwise.  */\n+/* Compute the classic per loop distance vector.  DDR is the data\n+   dependence relation to build a vector from.  Return false when fail\n+   to represent the data dependence as a distance vector.  */\n \n static bool\n-build_classic_dir_vector (struct data_dependence_relation *ddr, \n-\t\t\t  int first_loop_depth)\n+build_classic_dist_vector (struct data_dependence_relation *ddr)\n {\n-  unsigned i;\n-  lambda_vector dir_v, init_v;\n-  int nb_loops = DDR_SIZE_VECT (ddr);\n   bool init_b = false;\n-  \n-  dir_v = lambda_vector_new (nb_loops);\n-  init_v = lambda_vector_new (nb_loops);\n+  int index_carry = DDR_NB_LOOPS (ddr);\n+  lambda_vector dist_v;\n \n-  DDR_SIZE_VECT (ddr) = nb_loops;\n-  \n   if (DDR_ARE_DEPENDENT (ddr) != NULL_TREE)\n     return true;\n-  \n-  for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n+\n+  if (same_access_functions (ddr))\n     {\n-      tree access_fn_a, access_fn_b;\n-      struct subscript *subscript = DDR_SUBSCRIPT (ddr, i);\n+      /* Save the 0 vector.  */\n+      dist_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n+      save_dist_v (ddr, dist_v);\n \n-      if (chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n-\t{\n-\t  non_affine_dependence_relation (ddr);\n-\t  return true;\n-\t}\n+      if (DDR_NB_LOOPS (ddr) > 1)\n+\tadd_other_self_distances (ddr);\n \n-      access_fn_a = DR_ACCESS_FN (DDR_A (ddr), i);\n-      access_fn_b = DR_ACCESS_FN (DDR_B (ddr), i);\n-      if (TREE_CODE (access_fn_a) == POLYNOMIAL_CHREC\n-\t  && TREE_CODE (access_fn_b) == POLYNOMIAL_CHREC)\n-\t{\n-\t  int dist, loop_nb, loop_depth;\n-\t  enum data_dependence_direction dir = dir_star;\n-\t  int loop_nb_a = CHREC_VARIABLE (access_fn_a);\n-\t  int loop_nb_b = CHREC_VARIABLE (access_fn_b);\n-\t  struct loop *loop_a = current_loops->parray[loop_nb_a];\n-\t  struct loop *loop_b = current_loops->parray[loop_nb_b];\n- \n-\t  /* If the loop for either variable is at a lower depth than \n-\t     the first_loop's depth, then we can't possibly have a\n-\t     dependency at this level of the loop.  */\n-\t     \n-\t  if (loop_a->depth < first_loop_depth\n-\t      || loop_b->depth < first_loop_depth)\n-\t    return false;\n-\n-\t  if (loop_nb_a != loop_nb_b\n-\t      && !flow_loop_nested_p (loop_a, loop_b)\n-\t      && !flow_loop_nested_p (loop_b, loop_a))\n-\t    {\n-\t      /* Example: when there are two consecutive loops,\n+      return true;\n+    }\n \n-\t\t | loop_1\n-\t\t |   A[{0, +, 1}_1]\n-\t\t | endloop_1\n-\t\t | loop_2\n-\t\t |   A[{0, +, 1}_2]\n-\t\t | endloop_2\n+  dist_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n+  if (!build_classic_dist_vector_1 (ddr, DDR_A (ddr), DDR_B (ddr),\n+\t\t\t\t    dist_v, &init_b, &index_carry))\n+    return false;\n \n-\t\t the dependence relation cannot be captured by the\n-\t\t distance abstraction.  */\n-\t      non_affine_dependence_relation (ddr);\n-\t      return true;\n+  /* Save the distance vector if we initialized one.  */\n+  if (init_b)\n+    {\n+      /* Verify a basic constraint: classic distance vectors should\n+\t always be lexicographically positive.\n+\n+\t Data references are collected in the order of execution of\n+\t the program, thus for the following loop\n+\n+\t | for (i = 1; i < 100; i++)\n+\t |   for (j = 1; j < 100; j++)\n+\t |     {\n+\t |       t = T[j+1][i-1];  // A\n+\t |       T[j][i] = t + 2;  // B\n+\t |     }\n+\n+\t references are collected following the direction of the wind:\n+\t A then B.  The data dependence tests are performed also\n+\t following this order, such that we're looking at the distance\n+\t separating the elements accessed by A from the elements later\n+\t accessed by B.  But in this example, the distance returned by\n+\t test_dep (A, B) is lexicographically negative (-1, 1), that\n+\t means that the access A occurs later than B with respect to\n+\t the outer loop, ie. we're actually looking upwind.  In this\n+\t case we solve test_dep (B, A) looking downwind to the\n+\t lexicographically positive solution, that returns the\n+\t distance vector (1, -1).  */\n+      if (!lambda_vector_lexico_pos (dist_v, DDR_NB_LOOPS (ddr)))\n+\t{\n+\t  lambda_vector save_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n+\t  subscript_dependence_tester_1 (ddr, DDR_B (ddr), DDR_A (ddr));\n+\t  compute_subscript_distance (ddr);\n+\t  build_classic_dist_vector_1 (ddr, DDR_B (ddr), DDR_A (ddr),\n+\t\t\t\t       save_v, &init_b, &index_carry);\n+\t  save_dist_v (ddr, save_v);\n+\n+\t  /* In this case there is a dependence forward for all the\n+\t     outer loops:\n+\n+\t     | for (k = 1; k < 100; k++)\n+\t     |  for (i = 1; i < 100; i++)\n+\t     |   for (j = 1; j < 100; j++)\n+\t     |     {\n+\t     |       t = T[j+1][i-1];  // A\n+\t     |       T[j][i] = t + 2;  // B\n+\t     |     }\n+\n+\t     the vectors are: \n+\t     (0,  1, -1)\n+\t     (1,  1, -1)\n+\t     (1, -1,  1)\n+\t  */\n+\t  if (DDR_NB_LOOPS (ddr) > 1)\n+\t    {\n+ \t      add_outer_distances (ddr, save_v, index_carry);\n+\t      add_outer_distances (ddr, dist_v, index_carry);\n \t    }\n+\t}\n+      else\n+\t{\n+\t  lambda_vector save_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n+\t  lambda_vector_copy (dist_v, save_v, DDR_NB_LOOPS (ddr));\n+\t  save_dist_v (ddr, save_v);\n \n-\t  /* The dependence is carried by the outermost loop.  Example:\n-\t     | loop_1\n-\t     |   A[{4, +, 1}_1]\n-\t     |   loop_2\n-\t     |     A[{5, +, 1}_2]\n-\t     |   endloop_2\n-\t     | endloop_1\n-\t     In this case, the dependence is carried by loop_1.  */\n-\t  loop_nb = loop_nb_a < loop_nb_b ? loop_nb_a : loop_nb_b;\n-\t  loop_depth = current_loops->parray[loop_nb]->depth - first_loop_depth;\n-\n-\t  /* If the loop number is still greater than the number of\n-\t     loops we've been asked to analyze, or negative,\n-\t     something is borked.  */\n-\t  gcc_assert (loop_depth >= 0);\n-\t  gcc_assert (loop_depth < nb_loops);\n-\n-\t  if (chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n+\t  if (DDR_NB_LOOPS (ddr) > 1)\n \t    {\n-\t      non_affine_dependence_relation (ddr);\n-\t      return true;\n-\t    }\n+\t      lambda_vector opposite_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n \n-\t  dist = int_cst_value (SUB_DISTANCE (subscript));\n+\t      subscript_dependence_tester_1 (ddr, DDR_B (ddr), DDR_A (ddr));\n+\t      compute_subscript_distance (ddr);\n+\t      build_classic_dist_vector_1 (ddr, DDR_B (ddr), DDR_A (ddr),\n+\t\t\t\t\t   opposite_v, &init_b, &index_carry);\n \n-\t  if (dist == 0)\n-\t    dir = dir_equal;\n-\t  else if (dist > 0)\n-\t    dir = dir_positive;\n-\t  else if (dist < 0)\n-\t    dir = dir_negative;\n-\t  \n-\t  /* This is the subscript coupling test.  \n-\t     | loop i = 0, N, 1\n-\t     |   T[i+1][i] = ...\n-\t     |   ... = T[i][i]\n-\t     | endloop\n-\t     There is no dependence.  */\n-\t  if (init_v[loop_depth] != 0\n-\t      && dir != dir_star\n-\t      && (enum data_dependence_direction) dir_v[loop_depth] != dir\n-\t      && (enum data_dependence_direction) dir_v[loop_depth] != dir_star)\n-\t    {\n-\t      finalize_ddr_dependent (ddr, chrec_known);\n-\t      return true;\n+\t      add_outer_distances (ddr, dist_v, index_carry);\n+\t      add_outer_distances (ddr, opposite_v, index_carry);\n \t    }\n-\t  \n-\t  dir_v[loop_depth] = dir;\n-\t  init_v[loop_depth] = 1;\n-\t  init_b = true;\n \t}\n     }\n+  else\n+    {\n+      /* There is a distance of 1 on all the outer loops: Example:\n+\t there is a dependence of distance 1 on loop_1 for the array A.\n \n-  /* Save the direction vector if we initialized one.  */\n-  if (init_b)\n+\t | loop_1\n+\t |   A[5] = ...\n+\t | endloop\n+      */\n+      add_outer_distances (ddr, dist_v,\n+\t\t\t   lambda_vector_first_nz (dist_v,\n+\t\t\t\t\t\t   DDR_NB_LOOPS (ddr), 0));\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      lambda_vector save_v = lambda_vector_new (DDR_SIZE_VECT (ddr));\n+      unsigned i;\n \n-      lambda_vector_copy (dir_v, save_v, DDR_SIZE_VECT (ddr));\n-      VEC_safe_push (lambda_vector, heap, DDR_DIR_VECTS (ddr), save_v);\n+      fprintf (dump_file, \"(build_classic_dist_vector\\n\");\n+      for (i = 0; i < DDR_NUM_DIST_VECTS (ddr); i++)\n+\t{\n+\t  fprintf (dump_file, \"  dist_vector = (\");\n+\t  print_lambda_vector (dump_file, DDR_DIST_VECT (ddr, i),\n+\t\t\t       DDR_NB_LOOPS (ddr));\n+\t  fprintf (dump_file, \"  )\\n\");\n+\t}\n+      fprintf (dump_file, \")\\n\");\n     }\n \n-  /* There is a distance of 1 on all the outer loops: \n-     \n-     Example: there is a dependence of distance 1 on loop_1 for the array A.\n-     | loop_1\n-     |   A[5] = ...\n-     | endloop\n-  */\n-  {\n-    struct loop *lca, *loop_a, *loop_b;\n-    struct data_reference *a = DDR_A (ddr);\n-    struct data_reference *b = DDR_B (ddr);\n-    int lca_depth;\n-    loop_a = loop_containing_stmt (DR_STMT (a));\n-    loop_b = loop_containing_stmt (DR_STMT (b));\n-    \n-    /* Get the common ancestor loop.  */\n-    lca = find_common_loop (loop_a, loop_b); \n-    lca_depth = lca->depth - first_loop_depth;\n+  return true;\n+}\n \n-    gcc_assert (lca_depth >= 0);\n-    gcc_assert (lca_depth < nb_loops);\n+/* Return the direction for a given distance.\n+   FIXME: Computing dir this way is suboptimal, since dir can catch\n+   cases that dist is unable to represent.  */\n \n-    while (lca->depth != 0)\n-      {\n-\t/* If we're considering just a sub-nest, then don't record\n-\t   any information on the outer loops.  */\n-\tif (lca_depth < 0)\n-\t  break;\n+static inline enum data_dependence_direction\n+dir_from_dist (int dist)\n+{\n+  if (dist > 0)\n+    return dir_positive;\n+  else if (dist < 0)\n+    return dir_negative;\n+  else\n+    return dir_equal;\n+}\n \n-\tgcc_assert (lca_depth < nb_loops);\n+/* Compute the classic per loop direction vector.  DDR is the data\n+   dependence relation to build a vector from.  */\n \n-\tif (init_v[lca_depth] == 0)\n-\t  {\n-\t    lambda_vector save_v = lambda_vector_new (DDR_SIZE_VECT (ddr));\n+static void\n+build_classic_dir_vector (struct data_dependence_relation *ddr)\n+{\n+  unsigned i, j;\n+  lambda_vector dist_v;\n \n-\t    lambda_vector_copy (dir_v, save_v, DDR_SIZE_VECT (ddr));\n-\t    save_v[lca_depth] = dir_positive;\n-\t    VEC_safe_push (lambda_vector, heap, DDR_DIR_VECTS (ddr), save_v);\n-\t  }\n+  for (i = 0; VEC_iterate (lambda_vector, DDR_DIST_VECTS (ddr), i, dist_v); i++)\n+    {\n+      lambda_vector dir_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n \n-\tlca = lca->outer;\n-\tlca_depth = lca->depth - first_loop_depth;\n-      }\n-  }\n+      for (j = 0; j < DDR_NB_LOOPS (ddr); j++)\n+\tdir_v[j] = dir_from_dist (dist_v[j]);\n \n-  return true;\n+      save_dir_v (ddr, dir_v);\n+    }\n }\n \n-/* Computes the conflicting iterations, and initialize DDR.  */\n+/* Helper function.  Returns true when there is a dependence between\n+   data references DRA and DRB.  */\n \n-static void\n-subscript_dependence_tester (struct data_dependence_relation *ddr,\n-\t\t\t     int loop_nest_depth)\n+static bool\n+subscript_dependence_tester_1 (struct data_dependence_relation *ddr,\n+\t\t\t       struct data_reference *dra,\n+\t\t\t       struct data_reference *drb)\n {\n   unsigned int i;\n-  struct data_reference *dra = DDR_A (ddr);\n-  struct data_reference *drb = DDR_B (ddr);\n   tree last_conflicts;\n-  \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"(subscript_dependence_tester \\n\");\n-  \n+\n   for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n     {\n       tree overlaps_a, overlaps_b;\n@@ -3744,15 +3792,15 @@ subscript_dependence_tester (struct data_dependence_relation *ddr,\n  \t{\n  \t  finalize_ddr_dependent (ddr, chrec_dont_know);\n \t  dependence_stats.num_dependence_undetermined++;\n-\t  goto subs_test_end;\n+\t  return false;\n  \t}\n       \n       else if (overlaps_a == chrec_known\n  \t       || overlaps_b == chrec_known)\n  \t{\n  \t  finalize_ddr_dependent (ddr, chrec_known);\n \t  dependence_stats.num_dependence_independent++;\n-\t  goto subs_test_end;\n+\t  return false;\n  \t}\n       \n       else\n@@ -3763,12 +3811,24 @@ subscript_dependence_tester (struct data_dependence_relation *ddr,\n  \t}\n     }\n \n-  dependence_stats.num_dependence_dependent++;\n+  return true;\n+}\n+\n+/* Computes the conflicting iterations, and initialize DDR.  */\n+\n+static void\n+subscript_dependence_tester (struct data_dependence_relation *ddr)\n+{\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"(subscript_dependence_tester \\n\");\n+  \n+  if (subscript_dependence_tester_1 (ddr, DDR_A (ddr), DDR_B (ddr)))\n+    dependence_stats.num_dependence_dependent++;\n \n- subs_test_end:;\n   compute_subscript_distance (ddr);\n-  if (build_classic_dist_vector (ddr, loop_nest_depth))\n-    build_classic_dir_vector (ddr, loop_nest_depth);\n+  if (build_classic_dist_vector (ddr))\n+    build_classic_dir_vector (ddr);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \")\\n\");\n@@ -3802,8 +3862,7 @@ access_functions_are_affine_or_constant_p (struct data_reference *a)\n    subscript.  */\n \n static void\n-compute_affine_dependence (struct data_dependence_relation *ddr,\n-\t\t\t   int loop_nest_depth)\n+compute_affine_dependence (struct data_dependence_relation *ddr)\n {\n   struct data_reference *dra = DDR_A (ddr);\n   struct data_reference *drb = DDR_B (ddr);\n@@ -3825,7 +3884,7 @@ compute_affine_dependence (struct data_dependence_relation *ddr,\n \n       if (access_functions_are_affine_or_constant_p (dra)\n \t  && access_functions_are_affine_or_constant_p (drb))\n-\tsubscript_dependence_tester (ddr, loop_nest_depth);\n+\tsubscript_dependence_tester (ddr);\n       \n       /* As a last case, if the dependence cannot be determined, or if\n \t the dependence is considered too difficult to determine, answer\n@@ -3857,7 +3916,6 @@ static void\n compute_self_dependence (struct data_dependence_relation *ddr)\n {\n   unsigned int i;\n-  lambda_vector dir_v, dist_v;\n \n   for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n     {\n@@ -3870,31 +3928,22 @@ compute_self_dependence (struct data_dependence_relation *ddr)\n     }\n \n   /* The distance vector is the zero vector.  */\n-  dist_v = lambda_vector_new (DDR_SIZE_VECT (ddr));\n-  dir_v = lambda_vector_new (DDR_SIZE_VECT (ddr));\n-\n-  VEC_safe_push (lambda_vector, heap, DDR_DIST_VECTS (ddr), dist_v);\n-  VEC_safe_push (lambda_vector, heap, DDR_DIR_VECTS (ddr), dir_v);\n-\n-  compute_subscript_distance (ddr);\n+  save_dist_v (ddr, lambda_vector_new (DDR_NB_LOOPS (ddr)));\n+  save_dir_v (ddr, lambda_vector_new (DDR_NB_LOOPS (ddr)));\n }\n \n-/* Compute a subset of the data dependence relation graph.  Don't\n-   compute read-read and self relations if \n-   COMPUTE_SELF_AND_READ_READ_DEPENDENCES is FALSE, and avoid the computation \n-   of the opposite relation, i.e. when AB has been computed, don't compute BA.\n-   DATAREFS contains a list of data references, and the result is set\n-   in DEPENDENCE_RELATIONS.  */\n+/* Compute in DEPENDENCE_RELATIONS the data dependence graph for all\n+   the data references in DATAREFS, in the LOOP_NEST.  When\n+   COMPUTE_SELF_AND_READ_READ_DEPENDENCES is FALSE, don't compute\n+   read-read and self relations.  */\n \n static void \n compute_all_dependences (varray_type datarefs,\n \t\t\t VEC(ddr_p,heap) **dependence_relations,\n-\t\t\t bool compute_self_and_read_read_dependences,\n-\t\t\t unsigned nb_loops, unsigned loop_nest_depth)\n+\t\t\t VEC (loop_p, heap) *loop_nest,\n+\t\t\t bool compute_self_and_read_read_dependences)\n {\n-  unsigned int i, j, N;\n-\n-  N = VARRAY_ACTIVE_SIZE (datarefs);\n+  unsigned int i, j, N = VARRAY_ACTIVE_SIZE (datarefs);\n \n   /* Note that we specifically skip i == j because it's a self dependence, and\n      use compute_self_dependence below.  */\n@@ -3912,9 +3961,9 @@ compute_all_dependences (varray_type datarefs,\n             && !compute_self_and_read_read_dependences)\n \t  continue;\n \n-\tddr = initialize_data_dependence_relation (a, b, nb_loops);\n+\tddr = initialize_data_dependence_relation (a, b, loop_nest);\n \tVEC_safe_push (ddr_p, heap, *dependence_relations, ddr);\n-\tcompute_affine_dependence (ddr, loop_nest_depth);\n+\tcompute_affine_dependence (ddr);\n       }\n \n   if (!compute_self_and_read_read_dependences)\n@@ -3928,7 +3977,7 @@ compute_all_dependences (varray_type datarefs,\n \n       a = VARRAY_GENERIC_PTR (datarefs, i);\n       b = VARRAY_GENERIC_PTR (datarefs, i);\n-      ddr = initialize_data_dependence_relation (a, b, nb_loops);\n+      ddr = initialize_data_dependence_relation (a, b, loop_nest);\n       VEC_safe_push (ddr_p, heap, *dependence_relations, ddr);\n       compute_self_dependence (ddr);\n     }\n@@ -4072,9 +4121,47 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n   return NULL_TREE;\n }\n \n-\f\n+/* Recursive helper function.  */\n+\n+static bool\n+find_loop_nest_1 (struct loop *loop, VEC (loop_p, heap) *loop_nest)\n+{\n+  /* Inner loops of the nest should not contain siblings.  Example:\n+     when there are two consecutive loops,\n+\n+     | loop_0\n+     |   loop_1\n+     |     A[{0, +, 1}_1]\n+     |   endloop_1\n+     |   loop_2\n+     |     A[{0, +, 1}_2]\n+     |   endloop_2\n+     | endloop_0\n+\n+     the dependence relation cannot be captured by the distance\n+     abstraction.  */\n+  if (loop->next)\n+    return false;\n \n-/* This section contains all the entry points.  */\n+  VEC_safe_push (loop_p, heap, loop_nest, loop);\n+  if (loop->inner)\n+    return find_loop_nest_1 (loop->inner, loop_nest);\n+  return true;\n+}\n+\n+/* Return false when the LOOP is not well nested.  Otherwise return\n+   true and insert in LOOP_NEST the loops of the nest.  LOOP_NEST will\n+   contain the loops from the outermost to the innermost, as they will\n+   appear in the classic distance vector.  */\n+\n+static bool\n+find_loop_nest (struct loop *loop, VEC (loop_p, heap) *loop_nest)\n+{\n+  VEC_safe_push (loop_p, heap, loop_nest, loop);\n+  if (loop->inner)\n+    return find_loop_nest_1 (loop->inner, loop_nest);\n+  return true;\n+}\n \n /* Given a loop nest LOOP, the following vectors are returned:\n    *DATAREFS is initialized to all the array elements contained in this loop, \n@@ -4088,39 +4175,40 @@ compute_data_dependences_for_loop (struct loop *loop,\n \t\t\t\t   varray_type *datarefs,\n \t\t\t\t   varray_type *dependence_relations)\n {\n-  unsigned int i, nb_loops;\n+  unsigned int i;\n   VEC(ddr_p,heap) *allrelations;\n   struct data_dependence_relation *ddr;\n   struct loop *loop_nest = loop;\n+  VEC (loop_p, heap) *vloops = VEC_alloc (loop_p, heap, 3);\n \n-  while (loop_nest && loop_nest->outer && loop_nest->outer->outer)\n-    loop_nest = loop_nest->outer;\n-\n-  nb_loops = loop_nest->level;\n   memset (&dependence_stats, 0, sizeof (dependence_stats));\n \n-  /* If one of the data references is not computable, give up without\n-     spending time to compute other dependences.  */\n-  if (find_data_references_in_loop (loop, datarefs) == chrec_dont_know)\n+  /* If the loop nest is not well formed, or one of the data references \n+     is not computable, give up without spending time to compute other\n+     dependences.  */\n+  if (!loop_nest\n+      || !find_loop_nest (loop_nest, vloops)\n+      || find_data_references_in_loop (loop, datarefs) == chrec_dont_know)\n     {\n       struct data_dependence_relation *ddr;\n \n       /* Insert a single relation into dependence_relations:\n \t chrec_dont_know.  */\n-      ddr = initialize_data_dependence_relation (NULL, NULL, nb_loops);\n+      ddr = initialize_data_dependence_relation (NULL, NULL, vloops);\n       VARRAY_PUSH_GENERIC_PTR (*dependence_relations, ddr);\n-      return;\n     }\n-\n-  allrelations = NULL;\n-  compute_all_dependences (*datarefs, &allrelations,\n-\t\t\t   compute_self_and_read_read_dependences,\n-\t\t\t   nb_loops, loop_nest->depth);\n-\n-  /* FIXME: We copy the contents of allrelations back to a VARRAY\n-     because the vectorizer has not yet been converted to use VECs.  */\n-  for (i = 0; VEC_iterate (ddr_p, allrelations, i, ddr); i++)\n-    VARRAY_PUSH_GENERIC_PTR (*dependence_relations, ddr);\n+  else\n+    {\n+      allrelations = NULL;\n+      compute_all_dependences (*datarefs, &allrelations, vloops,\n+\t\t\t       compute_self_and_read_read_dependences);\n+\t\t\t       \n+\n+      /* FIXME: We copy the contents of allrelations back to a VARRAY\n+\t because the vectorizer has not yet been converted to use VECs.  */\n+      for (i = 0; VEC_iterate (ddr_p, allrelations, i, ddr); i++)\n+\tVARRAY_PUSH_GENERIC_PTR (*dependence_relations, ddr);\n+    }\n \n   if (dump_file && (dump_flags & TDF_STATS))\n     {"}, {"sha": "1f996f43097a7b8668dde698cb861e30335ca480", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba42e045f7da0362ac1ff19ce0a2210999f7f1f8/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba42e045f7da0362ac1ff19ce0a2210999f7f1f8/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=ba42e045f7da0362ac1ff19ce0a2210999f7f1f8", "patch": "@@ -186,6 +186,10 @@ struct subscript\n #define SUB_LAST_CONFLICT(SUB) SUB->last_conflict\n #define SUB_DISTANCE(SUB) SUB->distance\n \n+typedef struct loop *loop_p;\n+DEF_VEC_P(loop_p);\n+DEF_VEC_ALLOC_P (loop_p, heap);\n+\n /* A data_dependence_relation represents a relation between two\n    data_references A and B.  */\n \n@@ -217,9 +221,8 @@ struct data_dependence_relation\n      the data_dependence_relation.  */\n   varray_type subscripts;\n \n-  /* The size of the direction/distance vectors: the depth of the\n-     analyzed loop nest.  */\n-  int size_vect;\n+  /* The analyzed loop nest.  */\n+  VEC (loop_p, heap) *loop_nest;\n \n   /* The classic direction vector.  */\n   VEC(lambda_vector,heap) *dir_vects;\n@@ -241,7 +244,11 @@ DEF_VEC_ALLOC_P(ddr_p,heap);\n   VARRAY_GENERIC_PTR_INIT (DDR_SUBSCRIPTS (DDR), N, \"subscripts_vector\");\n #define DDR_SUBSCRIPT(DDR, I) VARRAY_GENERIC_PTR (DDR_SUBSCRIPTS (DDR), I)\n #define DDR_NUM_SUBSCRIPTS(DDR) VARRAY_ACTIVE_SIZE (DDR_SUBSCRIPTS (DDR))\n-#define DDR_SIZE_VECT(DDR) DDR->size_vect\n+\n+#define DDR_LOOP_NEST(DDR) DDR->loop_nest\n+/* The size of the direction/distance vectors: the number of loops in\n+   the loop nest.  */\n+#define DDR_NB_LOOPS(DDR) (VEC_length (loop_p, DDR_LOOP_NEST (DDR)))\n \n #define DDR_DIST_VECTS(DDR) ((DDR)->dist_vects)\n #define DDR_DIR_VECTS(DDR) ((DDR)->dir_vects)\n@@ -260,11 +267,14 @@ extern tree find_data_references_in_loop (struct loop *, varray_type *);\n extern void compute_data_dependences_for_loop (struct loop *, bool,\n \t\t\t\t\t       varray_type *, varray_type *);\n extern void print_direction_vector (FILE *, lambda_vector, int);\n+extern void print_dir_vectors (FILE *, VEC (lambda_vector, heap) *, int);\n+extern void print_dist_vectors (FILE *, VEC (lambda_vector, heap) *, int);\n extern void dump_subscript (FILE *, struct subscript *);\n extern void dump_ddrs (FILE *, varray_type);\n extern void dump_dist_dir_vectors (FILE *, varray_type);\n extern void dump_data_reference (FILE *, struct data_reference *);\n extern void dump_data_references (FILE *, varray_type);\n+extern void debug_data_dependence_relation (struct data_dependence_relation *);\n extern void dump_data_dependence_relation (FILE *, \n \t\t\t\t\t   struct data_dependence_relation *);\n extern void dump_data_dependence_relations (FILE *, varray_type);\n@@ -276,6 +286,22 @@ extern void free_data_refs (varray_type);\n extern struct data_reference *analyze_array (tree, tree, bool);\n extern void estimate_iters_using_array (tree, tree);\n \n+/* Return the index of the variable VAR in the LOOP_NEST array.  */\n+\n+static inline int\n+index_in_loop_nest (int var, VEC (loop_p, heap) *loop_nest)\n+{\n+  struct loop *loopi;\n+  int var_index;\n+\n+  for (var_index = 0; VEC_iterate (loop_p, loop_nest, var_index, loopi);\n+       var_index++)\n+    if (loopi->num == var)\n+      break;\n+\n+  return var_index;\n+}\n+\n \f\n \n #endif  /* GCC_TREE_DATA_REF_H  */"}, {"sha": "8afaa1b37196d2115bd1bb4c1fa364913c8c6855", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba42e045f7da0362ac1ff19ce0a2210999f7f1f8/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba42e045f7da0362ac1ff19ce0a2210999f7f1f8/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=ba42e045f7da0362ac1ff19ce0a2210999f7f1f8", "patch": "@@ -584,12 +584,12 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n   unsigned int i;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   int vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  unsigned int loop_depth = 0;\n-  struct loop *loop_nest = loop;\n   struct data_reference *dra = DDR_A (ddr);\n   struct data_reference *drb = DDR_B (ddr);\n   stmt_vec_info stmtinfo_a = vinfo_for_stmt (DR_STMT (dra)); \n   stmt_vec_info stmtinfo_b = vinfo_for_stmt (DR_STMT (drb));\n+  lambda_vector dist_v;\n+  unsigned int loop_depth;\n          \n   if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n     return false;\n@@ -619,16 +619,10 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n       return true;\n     }    \n \n-  /* Find loop depth.  */\n-  while (loop_nest && loop_nest->outer && loop_nest->outer->outer)\n+  loop_depth = index_in_loop_nest (loop->num, DDR_LOOP_NEST (ddr));\n+  for (i = 0; VEC_iterate (lambda_vector, DDR_DIST_VECTS (ddr), i, dist_v); i++)\n     {\n-      loop_nest = loop_nest->outer;\n-      loop_depth++;\n-    }\n-\n-  for (i = 0; i < DDR_NUM_DIST_VECTS (ddr); i++)\n-    {\n-      int dist = DDR_DIST_VECT (ddr, i)[loop_depth];\n+      int dist = dist_v[loop_depth];\n \n       if (vect_print_dump_info (REPORT_DR_DETAILS))\n \tfprintf (vect_dump, \"dependence distance  = %d.\", dist);"}]}