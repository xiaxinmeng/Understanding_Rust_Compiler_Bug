{"sha": "ac3636f297d265d12cc31a4f77bbd586a4d2fb1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMzNjM2ZjI5N2QyNjVkMTJjYzMxYTRmNzdiYmQ1ODZhNGQyZmIxZA==", "commit": {"author": {"name": "Loren J. Rittle", "email": "ljrittle@acm.org", "date": "2001-10-11T06:07:50Z"}, "committer": {"name": "Loren J. Rittle", "email": "ljrittle@gcc.gnu.org", "date": "2001-10-11T06:07:50Z"}, "message": "index.html (Is libstdc++-v3 thread-safe?): Rewrite.\n\n        * docs/html/faq/index.html (Is libstdc++-v3 thread-safe?): Rewrite.\n        * docs/html/23_containers/howto.html (Containers and multithreading):\n        Update.\n\nFrom-SVN: r46175", "tree": {"sha": "7e3c06fb9b63e0330e79d786bff51243a77a4b8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e3c06fb9b63e0330e79d786bff51243a77a4b8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac3636f297d265d12cc31a4f77bbd586a4d2fb1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac3636f297d265d12cc31a4f77bbd586a4d2fb1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac3636f297d265d12cc31a4f77bbd586a4d2fb1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac3636f297d265d12cc31a4f77bbd586a4d2fb1d/comments", "author": null, "committer": null, "parents": [{"sha": "eb9d8e4d0ba0b89881d024c23ca5866bbc359409", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb9d8e4d0ba0b89881d024c23ca5866bbc359409", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb9d8e4d0ba0b89881d024c23ca5866bbc359409"}], "stats": {"total": 172, "additions": 102, "deletions": 70}, "files": [{"sha": "6f310e786cf7d23ab5797b807ddef2b0d62f2041", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3636f297d265d12cc31a4f77bbd586a4d2fb1d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3636f297d265d12cc31a4f77bbd586a4d2fb1d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ac3636f297d265d12cc31a4f77bbd586a4d2fb1d", "patch": "@@ -1,3 +1,9 @@\n+2001-10-11  Loren J. Rittle  <ljrittle@acm.org>\n+\n+\t* docs/html/faq/index.html (Is libstdc++-v3 thread-safe?): Rewrite.\n+\t* docs/html/23_containers/howto.html (Containers and multithreading):\n+\tUpdate.\n+\n 2001-10-09  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* docs/html/17_intro/howto.html:  Tweak markup and value type."}, {"sha": "9106c82b59174a70f36b7fc80a4b81f7ff81771a", "filename": "libstdc++-v3/docs/html/23_containers/howto.html", "status": "modified", "additions": 44, "deletions": 57, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3636f297d265d12cc31a4f77bbd586a4d2fb1d/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F23_containers%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3636f297d265d12cc31a4f77bbd586a4d2fb1d/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F23_containers%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F23_containers%2Fhowto.html?ref=ac3636f297d265d12cc31a4f77bbd586a4d2fb1d", "patch": "@@ -192,68 +192,55 @@ <h2><a name=\"2\">Variable-sized bitmasks</a></h2>\n \n <hr>\n <h2><a name=\"3\">Containers and multithreading</a></h2>\n-   <p>This section will mention some of the problems in designing MT\n-      programs that use Standard containers.  For information on other\n-      aspects of multithreading (e.g., the library as a whole), see\n-      the Received Wisdom on Chapter 17.  This section only applies\n-      when gcc and libstdc++-v3 were configured with --enable-threads.\n-   </p>\n-   <p>Two excellent pages to read when working with templatized containers\n-      and threads are\n+   <p>This section discusses issues surrounding the design of\n+      multithreaded applications which use Standard C++ containers.\n+      All information in this section is current as of the gcc 3.0\n+      release and all later point releases.  Although earlier gcc\n+      releases had a different approach to threading configuration and\n+      proper compilation, the basic code design rules presented here\n+      were similar.  For information on all other aspects of\n+      multithreading as it relates to libstdc++, including details on\n+      the proper compilation of threaded code (and compatibility between\n+      threaded and non-threaded code), see Chapter 17.\n+  </p>\n+   <p>Two excellent pages to read when working with the Standard C++\n+      containers and threads are\n       <a href=\"http://www.sgi.com/tech/stl/thread_safety.html\">SGI's\n       http://www.sgi.com/tech/stl/thread_safety.html</a> and\n       <a href=\"http://www.sgi.com/tech/stl/Allocators.html\">SGI's\n-      http://www.sgi.com/tech/stl/Allocators.html</a>.  The\n-      libstdc++-v3 uses the same definition of thread safety\n-      when discussing design.  A key point that beginners may miss is the\n+      http://www.sgi.com/tech/stl/Allocators.html</a>.\n+  </p>\n+   <p><em>However, please ignore all discussions about the user-level\n+      configuration of the lock implementation inside the STL\n+      container-memory allocator on those pages.  For the sake of this\n+      discussion, libstdc++-v3 configures the SGI STL implementation,\n+      not you.  This is quite different from how gcc pre-3.0 worked.\n+      In particular, past advice was for people using g++ to\n+      explicitly define _PTHREADS or other macros or port-specific\n+      compilation options on the command line to get a thread-safe\n+      STL.  This is no longer required for any port and should no\n+      longer be done unless you really know what you are doing and\n+      assume all responsibility.</em>\n+  </p>\n+   <p>Since the container implementation of libstdc++-v3 uses the SGI\n+      code, we use the same definition of thread safety as SGI when\n+      discussing design.  A key point that beginners may miss is the\n       fourth major paragraph of the first page mentioned above\n-      (&quot;For most clients,&quot;...), pointing\n-      out that locking must nearly always be done outside the container,\n-      by client code (that'd be you, not us *grin*).\n-      <em>However, please take caution when considering the discussion\n-      about the user-level configuration of the mutex lock\n-      implementation inside the STL container-memory allocator on that\n-      page.  For the sake of this discussion, libstdc++-v3 configures\n-      the SGI STL implementation, not you.  We attempt to configure\n-      the mutex lock as is best for your platform.  In particular,\n-      past advice was for people using g++ to explicitly define\n-      _PTHREADS on the command line to get a thread-safe STL.  This\n-      is no longer required for your port.  It may or may not be\n-      a good idea for your port.  Extremely big caution: if you\n-      compile some of your application code against the STL with one\n-      set of threading flags and macros and another portion of the\n-      code with different flags and macros that influence the\n-      selection of the mutex lock, you may well end up with multiple\n-      locking mechanisms in use which don't impact each other in the\n-      manner that they should.  Everything might link and all code\n-      might have been built with a perfectly reasonable thread model\n-      but you may have two internal ABIs in play within the\n-      application.  This might produce races, memory leaks and fatal\n-      crashes.  In any multithreaded application using STL, this\n-      is the first thing to study well before blaming the allocator.</em>\n-   </p>\n-   <p>You didn't read it, did you?  *sigh*  I'm serious, go read the\n-      SGI page.  It's really good and doesn't take long, and makes most\n-      of the points that would otherwise have to be made here (and does\n-      a better job).\n-   </p>\n-   <p>That's much better.  Now, the issue of MT has been brought up on\n-      the libstdc++-v3 mailing list as well as the main GCC mailing list\n-      several times.  The Chapter 17 HOWTO has some links into the mail\n-      archives, so you can see what's been thrown around.  The usual\n-      container (or pseudo-container, depending on how you look at it)\n-      that people have in mind is <code>string</code>, which is one of the\n-      points where libstdc++ departs from the SGI STL.  As of the\n-      2.90.8 snapshot, the libstdc++-v3 string class is safe for\n-      certain kinds of multithreaded access.\n-   </p>\n+      (&quot;For most clients,&quot;...), which points out that\n+      locking must nearly always be done outside the container, by\n+      client code (that'd be you, not us).  There is a notable\n+      exceptions to this rule.  Allocators called while a container or\n+      element is constructed uses an internal lock obtained and\n+      released solely within libstdc++-v3 code (in fact, this is the\n+      reason STL requires any knowledge of the thread configuration).\n+  </p>\n    <p>For implementing a container which does its own locking, it is\n-      trivial to (as SGI suggests) provide a wrapper class which obtains\n-      the lock, performs the container operation, then releases the lock.\n-      This could be templatized <em>to a certain extent</em>, on the\n-      underlying container and/or a locking mechanism.  Trying to provide\n-      a catch-all general template solution would probably be more trouble\n-      than it's worth.\n+      trivial to provide a wrapper class which obtains the lock (as\n+      SGI suggests), performs the container operation, and then\n+      releases the lock.  This could be templatized <em>to a certain\n+      extent</em>, on the underlying container and/or a locking\n+      mechanism.  Trying to provide a catch-all general template\n+      solution would probably be more trouble than it's worth.\n    </p>\n    <p>Return <a href=\"#top\">to top of page</a> or\n       <a href=\"../faq/index.html\">to the FAQ</a>."}, {"sha": "898821afcf3c895e4331bffc987008e03804cc05", "filename": "libstdc++-v3/docs/html/faq/index.html", "status": "modified", "additions": 52, "deletions": 13, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3636f297d265d12cc31a4f77bbd586a4d2fb1d/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3636f297d265d12cc31a4f77bbd586a4d2fb1d/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.html?ref=ac3636f297d265d12cc31a4f77bbd586a4d2fb1d", "patch": "@@ -686,19 +686,58 @@ <h2><a name=\"5_5\">5.5 [removed]</a></h2>\n \n <hr>\n    <h2><a name=\"5_6\">5.6 Is libstdc++-v3 thread-safe?</a></h2>\n-      <p>Quick answer:  no, as of 3.0, most of the library is not\n-         safe for multithreaded access.  The string class is MT-safe.\n-      </p>\n-      <p>This is assuming that your idea of &quot;multithreaded&quot;\n-         is the same as ours...  The general question of multithreading\n-         and libstdc++-v3 is addressed in the chapter-specific advice for\n-         <a href=\"../17_intro/howto.html#3\">Library Introduction</a>.\n-         Threadsafe containers are covered in more detail in\n-         <a href=\"../23_containers/howto.html\">the Received Wisdom section\n-         on containers</a>.  Threading and I/O are discussed in\n-         <a href=\"../27_io/howto.html\">the I/O chapter</a>.\n-         <!-- I have successfully evaded the topic; my work here is\n-              done- no, wait, I have to write those other sections... -->\n+      <p>When the system's libc is itself thread-safe, libstdc++-v3\n+         strives to be thread-safe.  The user-code must guard against\n+         concurrent method calls which may access any particular\n+         library object's state.  Typically, the application\n+         programmer may infer what object locks must be held based on\n+         the objects referenced in a method call.  Without getting\n+         into great detail, here is an example which requires\n+         user-level locks:\n+      </p>\n+         <pre>\n+       library_class_a shared_object_a;\n+\n+       thread_main () {\n+         library_class_b *object_b = new library_class_b;\n+\t shared_object_a.add_b (object_b); // must hold lock for shared_object_a\n+\t shared_object_a.mutate (); // must hold lock for shared_object_a\n+       }\n+\n+       // Multiple copies of thread_main() are started in independent threads.\n+         </pre>\n+      <p>Under the assumption that object_a and object_b are never\n+         exposed to another thread, here is an example that should not\n+         require any user-level locks:\n+      </p>\n+         <pre>\n+       thread_main () {\n+         library_class_a object_a;\n+         library_class_b *object_b = new library_class_b;\n+\t object_a.add_b (object_b);\n+\t object_a.mutate ();\n+       }\n+         </pre>\n+      <p>However, as of gcc 3.0 and point releases, beware that there\n+         may be cases where shared nested or global objects (neither\n+         of which are visible to user-code) are affected or used\n+         without any internal locking.\n+\t <!-- Is this warning still required? - Loren -->\n+      </p>\n+      <p>In some cases, a stronger thread-safe claim is made.  The\n+\t string class is thread-safe without user-code guards (i.e. a\n+\t string object may be shared and accessed between threads\n+\t without user-level locking).  The IO classes are thread-safe\n+\t with user-code guards whenever the same user-visible object\n+\t may be accessed by multiple threads.  The container classes\n+\t are thread-safe with user-code guards whenever the same\n+\t container may be accessed by multiple threads.  All accesses\n+\t to hidden shared objects (e.g. the global allocator objects)\n+\t are believed to be properly guarded within the library.\n+      </p>\n+      <p>See chapters <a href=\"../17_intro/howto.html#3\">17</a>,\n+         <a href=\"../23_containers/howto.html#3\">23</a> and\n+\t <a href=\"../27_io/howto.html#9\">27</a> for more information.\n       </p>\n \n <hr>"}]}