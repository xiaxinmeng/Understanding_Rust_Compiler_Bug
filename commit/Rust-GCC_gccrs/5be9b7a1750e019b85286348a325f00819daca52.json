{"sha": "5be9b7a1750e019b85286348a325f00819daca52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJlOWI3YTE3NTBlMDE5Yjg1Mjg2MzQ4YTMyNWYwMDgxOWRhY2E1Mg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2004-09-28T06:26:08Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2004-09-28T06:26:08Z"}, "message": "re PR target/16532 (Inefficient jump to epilogue)\n\n\tPR target/16532\n\t* config/sparc/sparc.c (struct machine_function): New field\n\t'leaf_function_p' and 'prologue_data_valid_p'.\n\t(sparc_leaf_function_p, sparc_prologue_data_valid_p): New macro\n\tto conveniently access the above fields.\n\t(TARGET_LATE_RTL_PROLOGUE_EPILOGUE): Delete.\n\t(eligible_for_return_delay): Use 'sparc_leaf_function_p' instead\n\tof the generic flavor 'current_function_uses_only_leaf_regs'.\n\t(eligible_for_sibcall_delay): Likewise.\n\t(sparc_expand_prologue): Compute 'sparc_leaf_function_p' and set\n\t'sparc_prologue_data_valid_p'.  Use 'sparc_leaf_function_p'.\n\t(sparc_asm_function_prologue): Add sanity check for the assumption\n\tmade in 'sparc_expand_prologue'.  Use 'sparc_leaf_function_p'.\n\t(sparc_can_use_return_insn_p): New function.\n\t(sparc_expand_epilogue): Use 'sparc_leaf_function_p'.\n\t(output_restore): Likewise.\n\t(output_sibcall): Likewise.\n\t(sparc_output_mi_thunk): Likewise.\n\t* config/sparc/sparc-protos.h (sparc_can_use_return_insn_p): Declare.\n\t* config/sparc/sparc.md (return): New expander.\n\n\t* config/sparc/sparc.h (INITIAL_ELIMINATION_OFFSET): Minor tweak.\n\nFrom-SVN: r88220", "tree": {"sha": "be38bba66d1221286973b3932565532de93fb5c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be38bba66d1221286973b3932565532de93fb5c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5be9b7a1750e019b85286348a325f00819daca52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5be9b7a1750e019b85286348a325f00819daca52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5be9b7a1750e019b85286348a325f00819daca52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5be9b7a1750e019b85286348a325f00819daca52/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4badaa417d86f108d2921a9588a0b9846d552118", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4badaa417d86f108d2921a9588a0b9846d552118", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4badaa417d86f108d2921a9588a0b9846d552118"}], "stats": {"total": 123, "additions": 99, "deletions": 24}, "files": [{"sha": "678c005e25a99973c37e843a234bafb7683ac120", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be9b7a1750e019b85286348a325f00819daca52/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be9b7a1750e019b85286348a325f00819daca52/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5be9b7a1750e019b85286348a325f00819daca52", "patch": "@@ -1,3 +1,28 @@\n+2004-09-28  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR target/16532\n+\t* config/sparc/sparc.c (struct machine_function): New field\n+\t'leaf_function_p' and 'prologue_data_valid_p'.\n+\t(sparc_leaf_function_p, sparc_prologue_data_valid_p): New macro\n+\tto conveniently access the above fields.\n+\t(TARGET_LATE_RTL_PROLOGUE_EPILOGUE): Delete.\n+\t(eligible_for_return_delay): Use 'sparc_leaf_function_p' instead\n+\tof the generic flavor 'current_function_uses_only_leaf_regs'.\n+\t(eligible_for_sibcall_delay): Likewise.\n+\t(sparc_expand_prologue): Compute 'sparc_leaf_function_p' and set\n+\t'sparc_prologue_data_valid_p'.  Use 'sparc_leaf_function_p'.\n+\t(sparc_asm_function_prologue): Add sanity check for the assumption\n+\tmade in 'sparc_expand_prologue'.  Use 'sparc_leaf_function_p'.\n+\t(sparc_can_use_return_insn_p): New function.\n+\t(sparc_expand_epilogue): Use 'sparc_leaf_function_p'.\n+\t(output_restore): Likewise.\n+\t(output_sibcall): Likewise.\n+\t(sparc_output_mi_thunk): Likewise.\n+\t* config/sparc/sparc-protos.h (sparc_can_use_return_insn_p): Declare.\n+\t* config/sparc/sparc.md (return): New expander.\n+\n+\t* config/sparc/sparc.h (INITIAL_ELIMINATION_OFFSET): Minor tweak.\n+\n 2004-09-27  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/17642"}, {"sha": "e181f8f73bb07fcd7791a3a94fb03a890f6d7ef6", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be9b7a1750e019b85286348a325f00819daca52/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be9b7a1750e019b85286348a325f00819daca52/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=5be9b7a1750e019b85286348a325f00819daca52", "patch": "@@ -47,6 +47,7 @@ extern void order_regs_for_local_alloc (void);\n extern HOST_WIDE_INT sparc_compute_frame_size (HOST_WIDE_INT, int);\n extern void sparc_expand_prologue (void);\n extern void sparc_expand_epilogue (void);\n+extern bool sparc_can_use_return_insn_p (void);\n extern int check_pic (int);\n extern int short_branch (int, int);\n extern void sparc_profile_hook (int);"}, {"sha": "aa1fa0905b1e106456560ec343e658b4df64c83f", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 65, "deletions": 21, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be9b7a1750e019b85286348a325f00819daca52/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be9b7a1750e019b85286348a325f00819daca52/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=5be9b7a1750e019b85286348a325f00819daca52", "patch": "@@ -270,8 +270,20 @@ struct machine_function GTY(())\n {\n   /* Some local-dynamic TLS symbol name.  */\n   const char *some_ld_name;\n+\n+  /* True if the current function is leaf and uses only leaf regs,\n+     so that the SPARC leaf function optimization can be applied.\n+     Private version of current_function_uses_only_leaf_regs, see\n+     sparc_expand_prologue for the rationale.  */\n+  int leaf_function_p;\n+\n+  /* True if the data calculated by sparc_expand_prologue are valid.  */\n+  bool prologue_data_valid_p;\n };\n \n+#define sparc_leaf_function_p  cfun->machine->leaf_function_p\n+#define sparc_prologue_data_valid_p  cfun->machine->prologue_data_valid_p\n+\n /* Register we pretend to think the frame pointer is allocated to.\n    Normally, this is %fp, but if we are in a leaf procedure, this\n    is %sp+\"something\".  We record \"something\" separately as it may\n@@ -452,9 +464,6 @@ enum processor_type sparc_cpu;\n #undef TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR sparc_gimplify_va_arg\n \n-#undef TARGET_LATE_RTL_PROLOGUE_EPILOGUE\n-#define TARGET_LATE_RTL_PROLOGUE_EPILOGUE true\n-\n #ifdef SUBTARGET_INSERT_ATTRIBUTES\n #undef TARGET_INSERT_ATTRIBUTES\n #define TARGET_INSERT_ATTRIBUTES SUBTARGET_INSERT_ATTRIBUTES\n@@ -3154,7 +3163,6 @@ eligible_for_restore_insn (rtx trial, bool return_p)\n int\n eligible_for_return_delay (rtx trial)\n {\n-  int leaf_function_p = current_function_uses_only_leaf_regs;\n   rtx pat;\n \n   if (GET_CODE (trial) != INSN || GET_CODE (PATTERN (trial)) != SET)\n@@ -3174,7 +3182,7 @@ eligible_for_return_delay (rtx trial)\n     return 0;\n \n   /* In the case of a true leaf function, anything can go into the slot.  */\n-  if (leaf_function_p)\n+  if (sparc_leaf_function_p)\n     return get_attr_in_uncond_branch_delay (trial)\n \t   == IN_UNCOND_BRANCH_DELAY_TRUE;\n \n@@ -3204,7 +3212,6 @@ eligible_for_return_delay (rtx trial)\n int\n eligible_for_sibcall_delay (rtx trial)\n {\n-  int leaf_function_p = current_function_uses_only_leaf_regs;\n   rtx pat;\n \n   if (GET_CODE (trial) != INSN || GET_CODE (PATTERN (trial)) != SET)\n@@ -3215,7 +3222,7 @@ eligible_for_sibcall_delay (rtx trial)\n \n   pat = PATTERN (trial);\n \n-  if (leaf_function_p)\n+  if (sparc_leaf_function_p)\n     {\n       /* If the tail call is done using the call instruction,\n \t we have to restore %o7 in the delay slot.  */\n@@ -4469,13 +4476,40 @@ emit_stack_pointer_decrement (rtx decrement)\n void\n sparc_expand_prologue (void)\n {\n-  int leaf_function_p = current_function_uses_only_leaf_regs;\n+  /* Compute a snapshot of current_function_uses_only_leaf_regs.  Relying\n+     on the final value of the flag means deferring the prologue/epilogue\n+     expansion until just before the second scheduling pass, which is too\n+     late to emit multiple epilogues or return insns.\n+\n+     Of course we are making the assumption that the value of the flag\n+     will not change between now and its final value.  Of the three parts\n+     of the formula, only the last one can reasonably vary.  Let's take a\n+     closer look, after assuming that the first two ones are set to true\n+     (otherwise the last value is effectively silenced).\n+\n+     If only_leaf_regs_used returns false, the global predicate will also\n+     be false so the actual frame size calculated below will be positive.\n+     As a consequence, the save_register_window insn will be emitted in\n+     the instruction stream; now this insn explicitly references %fp\n+     which is not a leaf register so only_leaf_regs_used will always\n+     return false subsequently.\n+\n+     If only_leaf_regs_used returns true, we hope that the subsequent\n+     optimization passes won't cause non-leaf registers to pop up.  For\n+     example, the regrename pass has special provisions to not rename to\n+     non-leaf registers in a leaf function.  */\n+  sparc_leaf_function_p\n+    = optimize > 0 && leaf_function_p () && only_leaf_regs_used ();\n \n   /* Need to use actual_fsize, since we are also allocating\n      space for our callee (and our own register save area).  */\n-  actual_fsize = sparc_compute_frame_size (get_frame_size(), leaf_function_p);\n+  actual_fsize\n+    = sparc_compute_frame_size (get_frame_size(), sparc_leaf_function_p);\n+\n+  /* Advertise that the data calculated just above are now valid.  */\n+  sparc_prologue_data_valid_p = true;\n \n-  if (leaf_function_p)\n+  if (sparc_leaf_function_p)\n     {\n       frame_base_reg = stack_pointer_rtx;\n       frame_base_offset = actual_fsize + SPARC_STACK_BIAS;\n@@ -4488,7 +4522,7 @@ sparc_expand_prologue (void)\n \n   if (actual_fsize == 0)\n     /* do nothing.  */ ;\n-  else if (leaf_function_p)\n+  else if (sparc_leaf_function_p)\n     {\n       if (actual_fsize <= 4096)\n \temit_stack_pointer_increment (GEN_INT (- actual_fsize));\n@@ -4542,7 +4576,9 @@ sparc_expand_prologue (void)\n static void\n sparc_asm_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n-  int leaf_function_p = current_function_uses_only_leaf_regs;\n+  /* Check that the assumption we made in sparc_expand_prologue is valid.  */\n+  if (sparc_leaf_function_p != current_function_uses_only_leaf_regs)\n+    abort();\n \n   sparc_output_scratch_registers (file);\n \n@@ -4552,12 +4588,12 @@ sparc_asm_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \n       /* The canonical frame address refers to the top of the frame.  */\n       dwarf2out_def_cfa (label,\n-\t\t\t leaf_function_p\n+\t\t\t sparc_leaf_function_p\n \t\t\t ? STACK_POINTER_REGNUM\n \t\t\t : HARD_FRAME_POINTER_REGNUM,\n \t\t\t frame_base_offset);\n \n-      if (! leaf_function_p)\n+      if (! sparc_leaf_function_p)\n \t{\n \t  /* Note the register window save.  This tells the unwinder that\n \t     it needs to restore the window registers from the previous\n@@ -4576,14 +4612,12 @@ sparc_asm_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n void\n sparc_expand_epilogue (void)\n {\n-  int leaf_function_p = current_function_uses_only_leaf_regs;\n-\n   if (num_gfregs)\n     emit_restore_regs ();\n \n   if (actual_fsize == 0)\n     /* do nothing.  */ ;\n-  else if (leaf_function_p)\n+  else if (sparc_leaf_function_p)\n     {\n       if (actual_fsize <= 4096)\n \temit_stack_pointer_decrement (GEN_INT (- actual_fsize));\n@@ -4600,6 +4634,16 @@ sparc_expand_epilogue (void)\n \t}\n     }\n }\n+\n+/* Return true if it is appropriate to emit `return' instructions in the\n+   body of a function.  */\n+\n+bool\n+sparc_can_use_return_insn_p (void)\n+{\n+  return sparc_prologue_data_valid_p\n+\t && (actual_fsize == 0 || !sparc_leaf_function_p);\n+}\n   \n /* This function generates the assembly code for function exit.  */\n   \n@@ -4677,7 +4721,7 @@ output_restore (rtx pat)\n const char *\n output_return (rtx insn)\n {\n-  if (current_function_uses_only_leaf_regs)\n+  if (sparc_leaf_function_p)\n     {\n       /* This is a leaf function so we don't have to bother restoring the\n \t register window, which frees us from dealing with the convoluted\n@@ -4766,7 +4810,7 @@ output_sibcall (rtx insn, rtx call_operand)\n \n   operands[0] = call_operand;\n \n-  if (current_function_uses_only_leaf_regs)\n+  if (sparc_leaf_function_p)\n     {\n       /* This is a leaf function so we don't have to bother restoring the\n \t register window.  We simply output the jump to the function and\n@@ -8499,7 +8543,7 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n     {\n       /* We will emit a regular sibcall below, so we need to instruct\n \t output_sibcall that we are in a leaf function.  */\n-      current_function_uses_only_leaf_regs = 1;\n+      sparc_leaf_function_p = 1;\n \n       /* This will cause final.c to invoke leaf_renumber_regs so we\n \t must behave as if we were in a not-yet-leafified function.  */\n@@ -8509,7 +8553,7 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n     {\n       /* We will emit the sibcall manually below, so we will need to\n \t manually spill non-leaf registers.  */\n-      current_function_uses_only_leaf_regs = 0;\n+      sparc_leaf_function_p = 0;\n \n       /* We really are in a leaf function.  */\n       int_arg_first = SPARC_OUTGOING_INT_ARG_FIRST;"}, {"sha": "d1b93ec1ab730f35ef074a1e1dd861594bc5ab61", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be9b7a1750e019b85286348a325f00819daca52/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be9b7a1750e019b85286348a325f00819daca52/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=5be9b7a1750e019b85286348a325f00819daca52", "patch": "@@ -1121,8 +1121,7 @@ extern int sparc_mode_class[];\n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms\n    may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.\n-   Used in flow.c, global.c, and reload1.c.  */\n+   Used in flow.c, global.c, ra.c and reload1.c.  */\n #define FRAME_POINTER_REQUIRED\t\\\n   (! (leaf_function_p () && only_leaf_regs_used ()))\n \n@@ -1594,9 +1593,10 @@ extern char leaf_reg_remap[];\n    is a leaf function, we guessed right!  */\n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    (OFFSET) = 0;\t\t\t\t\t\t\t\\\n     if ((TO) == STACK_POINTER_REGNUM)\t\t\t\t\t\\\n       (OFFSET) = sparc_compute_frame_size (get_frame_size (), 1);\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      (OFFSET) = 0;\t\t\t\t\t\t\t\\\n     (OFFSET) += SPARC_STACK_BIAS;\t\t\t\t\t\\\n   } while (0)\n "}, {"sha": "d91e51d56569b7287ac507dfcb59f1693e52d75c", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be9b7a1750e019b85286348a325f00819daca52/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be9b7a1750e019b85286348a325f00819daca52/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=5be9b7a1750e019b85286348a325f00819daca52", "patch": "@@ -7684,6 +7684,11 @@\n   sparc_expand_epilogue ();\n })\n \n+(define_expand \"return\"\n+  [(return)]\n+  \"sparc_can_use_return_insn_p ()\"\n+  \"\")\n+\n (define_insn \"*return_internal\"\n   [(return)]\n   \"\""}]}