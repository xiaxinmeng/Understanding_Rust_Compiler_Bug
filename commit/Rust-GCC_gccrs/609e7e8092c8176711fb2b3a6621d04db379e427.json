{"sha": "609e7e8092c8176711fb2b3a6621d04db379e427", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA5ZTdlODA5MmM4MTc2NzExZmIyYjNhNjYyMWQwNGRiMzc5ZTQyNw==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2007-03-19T08:51:20Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2007-03-19T08:51:20Z"}, "message": "s390.md (op_type attribute): RRR instruction type added.\n\n2007-03-19  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* config/s390/s390.md (op_type attribute): RRR instruction type added.\n\t(FP, DFP, SD_SF, DD_DF, TD_TF): New mode macros.\n\t(xde, xdee): Mode attributes adjusted to support DFP modes.\n\t(RRer, f0, op1, Rf, bt, bfp, HALF_TMODE): New mode attributes added.\n\t(\"cmp<mode>\", \"*cmp<mode>_css_0\", \"*cmp<mode>_ccs\", TF move splitters,\n\tDF move splitters, \"floatdi<mode>2\", \"add<mode>3\", \"*add<mode>3\", \n\t\"*add<mode>3_cc\", \"*add<mode>3_cconly\", \"sub<mode>3\", \"*sub<mode>3\",\n\t\"*sub<mode>3_cc\", \"*sub<mode>3_cconly\", \"mul<mode>3\", \"*mul<mode>3\",\n\t\"div<mode>3\", \"*div<mode>3\", \"*neg<mode>2_nocc\", \"*abs<mode>2_nocc\",\n\t\"*negabs<mode>2_nocc\", \"copysign<mode>3\"): Adjusted to support DFP \n\tnumbers.\n\t(\"*movtf_64\", \"*movtf_31\", \"*movdf_64dfp\", \"*movdf_64\", \"*movdf_31\",\n\t\"movsf\"): Insn definitions removed.\n\t(\"*mov<mode>_64\", \"*mov<mode>_31\", \"mov<mode>\", \"*mov<mode>_64dfp\",\n\t\"*mov<mode>_64\", \"*mov<mode>_31\", \"fix_trunc<DFP:mode>di2\",\n\t\"trunctddd2\", \"truncddsd2\", \"extendddtd2\", \"extendsddd2\"): Insn\n\tdefinitions added.\n\t(\"fixuns_truncdddi2\", \"fixuns_trunctddi2\", \"mov<mode>\",\n\t\"reload_in<mode>\", \"reload_out<mode>\"): Expander added.\n\t(\"movtf\", \"movdf\", \"reload_outtf\", \"reload_outdf\", \"reload_intf\"):\n\tExpander removed.\n\nFrom-SVN: r123058", "tree": {"sha": "99f3285f09feddf62c3643baa17d6e79c24287a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99f3285f09feddf62c3643baa17d6e79c24287a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/609e7e8092c8176711fb2b3a6621d04db379e427", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/609e7e8092c8176711fb2b3a6621d04db379e427", "html_url": "https://github.com/Rust-GCC/gccrs/commit/609e7e8092c8176711fb2b3a6621d04db379e427", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/609e7e8092c8176711fb2b3a6621d04db379e427/comments", "author": null, "committer": null, "parents": [{"sha": "7b6baae190cc4db3f48e6d292030ea1c86fd4cb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b6baae190cc4db3f48e6d292030ea1c86fd4cb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b6baae190cc4db3f48e6d292030ea1c86fd4cb1"}], "stats": {"total": 619, "additions": 406, "deletions": 213}, "files": [{"sha": "2e8292db81738cb5b916bba657ec93a09144254c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/609e7e8092c8176711fb2b3a6621d04db379e427/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/609e7e8092c8176711fb2b3a6621d04db379e427/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=609e7e8092c8176711fb2b3a6621d04db379e427", "patch": "@@ -1,3 +1,27 @@\n+2007-03-19  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* config/s390/s390.md (op_type attribute): RRR instruction type added.\n+\t(FP, DFP, SD_SF, DD_DF, TD_TF): New mode macros.\n+\t(xde, xdee): Mode attributes adjusted to support DFP modes.\n+\t(RRer, f0, op1, Rf, bt, bfp, HALF_TMODE): New mode attributes added.\n+\t(\"cmp<mode>\", \"*cmp<mode>_css_0\", \"*cmp<mode>_ccs\", TF move splitters,\n+\tDF move splitters, \"floatdi<mode>2\", \"add<mode>3\", \"*add<mode>3\", \n+\t\"*add<mode>3_cc\", \"*add<mode>3_cconly\", \"sub<mode>3\", \"*sub<mode>3\",\n+\t\"*sub<mode>3_cc\", \"*sub<mode>3_cconly\", \"mul<mode>3\", \"*mul<mode>3\",\n+\t\"div<mode>3\", \"*div<mode>3\", \"*neg<mode>2_nocc\", \"*abs<mode>2_nocc\",\n+\t\"*negabs<mode>2_nocc\", \"copysign<mode>3\"): Adjusted to support DFP \n+\tnumbers.\n+\t(\"*movtf_64\", \"*movtf_31\", \"*movdf_64dfp\", \"*movdf_64\", \"*movdf_31\",\n+\t\"movsf\"): Insn definitions removed.\n+\t(\"*mov<mode>_64\", \"*mov<mode>_31\", \"mov<mode>\", \"*mov<mode>_64dfp\",\n+\t\"*mov<mode>_64\", \"*mov<mode>_31\", \"fix_trunc<DFP:mode>di2\",\n+\t\"trunctddd2\", \"truncddsd2\", \"extendddtd2\", \"extendsddd2\"): Insn\n+\tdefinitions added.\n+\t(\"fixuns_truncdddi2\", \"fixuns_trunctddi2\", \"mov<mode>\",\n+\t\"reload_in<mode>\", \"reload_out<mode>\"): Expander added.\n+\t(\"movtf\", \"movdf\", \"reload_outtf\", \"reload_outdf\", \"reload_intf\"):\n+\tExpander removed.\n+\n 2007-03-19  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* config/s390/s390.md: Only non-functional changes.  Renamed"}, {"sha": "19e8402b5db32d3d1b8bad88e39e2550bd34eabc", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 382, "deletions": 213, "changes": 595, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/609e7e8092c8176711fb2b3a6621d04db379e427/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/609e7e8092c8176711fb2b3a6621d04db379e427/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=609e7e8092c8176711fb2b3a6621d04db379e427", "patch": "@@ -152,7 +152,7 @@\n ;; Used to determine defaults for length and other attribute values.\n \n (define_attr \"op_type\"\n-  \"NN,E,RR,RRE,RX,RS,RSI,RI,SI,S,SS,SSE,RXE,RSE,RIL,RIE,RXY,RSY,SIY,RRF\"\n+  \"NN,E,RR,RRE,RX,RS,RSI,RI,SI,S,SS,SSE,RXE,RSE,RIL,RIE,RXY,RSY,SIY,RRF,RRR\"\n   (const_string \"NN\"))\n \n ;; Instruction type attribute used for scheduling.\n@@ -214,8 +214,13 @@\n \n ;; This mode macro allows floating point patterns to be generated from the\n ;; same template.\n+(define_mode_macro FP [TF DF SF (TD \"TARGET_HARD_DFP\") (DD \"TARGET_HARD_DFP\")])\n (define_mode_macro BFP [TF DF SF])\n+(define_mode_macro DFP [TD DD])\n (define_mode_macro DSF [DF SF])\n+(define_mode_macro SD_SF [SF SD])\n+(define_mode_macro DD_DF [DF DD])\n+(define_mode_macro TD_TF [TF TD])\n \n ;; These mode macros allow 31-bit and 64-bit TDSI patterns to be generated\n ;; from the same template.\n@@ -255,23 +260,37 @@\n (define_code_attr atomic [(and \"and\") (ior \"ior\") (xor \"xor\") \n \t\t\t  (plus \"add\") (minus \"sub\") (mult \"nand\")])\n \n+;; In FP templates, a string like \"lt<de>br\" will expand to \"ltxbr\" in \n+;; TF/TDmode, \"ltdbr\" in DF/DDmode, and \"ltebr\" in SF/SDmode.\n+(define_mode_attr xde [(TF \"x\") (DF \"d\") (SF \"e\") (TD \"x\") (DD \"d\") (SD \"e\")])\n \n-;; In BFP templates, a string like \"lt<de>br\" will expand to \"ltxbr\" in TFmode,\n-;; \"ltdbr\" in DFmode, and \"ltebr\" in SFmode.\n-(define_mode_attr xde [(TF \"x\") (DF \"d\") (SF \"e\")])\n+;; In FP templates, a <dee> in \"m<dee><bt>r\" will expand to \"mx<bt>r\" in \n+;; TF/TDmode, \"md<bt>r\" in DF/DDmode, \"mee<bt>r\" in SFmode and \"me<bt>r in \n+;; SDmode.\n+(define_mode_attr xdee [(TF \"x\") (DF \"d\") (SF \"ee\") (TD \"x\") (DD \"d\") (SD \"e\")])\n \n-;; In BFP templates, a string like \"m<dee>br\" will expand to \"mxbr\" in TFmode,\n-;; \"mdbr\" in DFmode, and \"meebr\" in SFmode.\n-(define_mode_attr xdee [(TF \"x\") (DF \"d\") (SF \"ee\")])\n-\n-;; In BFP templates, \"<RRe>\" will expand to \"RRE\" in TFmode and \"RR\" otherwise.\n+;; In FP templates, \"<RRe>\" will expand to \"RRE\" in TFmode and \"RR\" otherwise.\n ;; Likewise for \"<RXe>\".\n (define_mode_attr RRe [(TF \"RRE\") (DF \"RR\") (SF \"RR\")])\n (define_mode_attr RXe [(TF \"RXE\") (DF \"RX\") (SF \"RX\")])\n \n-;; In BFP templates, \"<Rf>\" will expand to \"f\" in TFmode and \"R\" otherwise.\n-;; This is used to disable the memory alternative in TFmode patterns.\n-(define_mode_attr Rf [(TF \"f\") (DF \"R\") (SF \"R\")])\n+;; The decimal floating point variants of add, sub, div and mul support 3\n+;; fp register operands.  The following macros allow to merge the bfp and\n+;; dfp variants in a single insn definition.\n+\n+;; This macro is used to set op_type accordingly.\n+(define_mode_attr RRer [(TF \"RRE\") (DF \"RRE\") (SF \"RRE\") (TD \"RRR\") \n+                        (DD \"RRR\") (SD \"RRR\")])\n+\n+;; This macro is used in the operand constraint list in order to have the \n+;; first and the second operand match for bfp modes.\n+(define_mode_attr f0 [(TF \"0\") (DF \"0\") (SF \"0\") (TD \"f\") (DD \"f\") (DD \"f\")])\n+\n+;; This macro is used in the operand list of the instruction to have an \n+;; additional operand for the dfp instructions.\n+(define_mode_attr op1 [(TF \"\") (DF \"\") (SF \"\")\n+                       (TD \"%1,\") (DD \"%1,\") (SD \"%1,\")])\n+\n \n ;; This attribute is used in the operand constraint list\n ;; for instructions dealing with the sign bit of 32 or 64bit fp values.\n@@ -281,6 +300,20 @@\n ;; target operand uses the same fp register.\n (define_mode_attr fT0 [(TF \"0\") (DF \"f\") (SF \"f\")])\n \n+;; In FP templates, \"<Rf>\" will expand to \"f\" in TFmode and \"R\" otherwise.\n+;; This is used to disable the memory alternative in TFmode patterns.\n+(define_mode_attr Rf [(TF \"f\") (DF \"R\") (SF \"R\") (TD \"f\") (DD \"f\") (SD \"f\")])\n+\n+;; This macro adds b for bfp instructions and t for dfp instructions and is used\n+;; within instruction mnemonics.\n+(define_mode_attr bt [(TF \"b\") (DF \"b\") (SF \"b\") (TD \"t\") (DD \"t\") (SD \"t\")])\n+\n+;; Although it is unprecise for z9-ec we handle all dfp instructions like\n+;; bfp regarding the pipeline description.\n+(define_mode_attr bfp [(TF \"tf\") (DF \"df\") (SF \"sf\")\n+                       (TD \"tf\") (DD \"df\") (SD \"sf\")])\n+\n+\n ;; In GPR and P templates, a constraint like \"<d0>\" will expand to \"d\" in DImode\n ;; and \"0\" in SImode. This allows to combine instructions of which the 31bit\n ;; version only operates on one register.\n@@ -341,6 +374,10 @@\n ;; in SImode.\n (define_mode_attr DBL [(DI \"TI\") (SI \"DI\")])\n \n+;; This attribute expands to DF for TFmode and to DD for TDmode .  It is\n+;; used for Txmode splitters splitting a Txmode copy into 2 Dxmode copies.\n+(define_mode_attr HALF_TMODE [(TF \"DF\") (TD \"DD\")])\n+\n ;; Maximum unsigned integer that fits in MODE.\n (define_mode_attr max_uint [(HI \"65535\") (QI \"255\")])\n \n@@ -362,8 +399,8 @@\n \n (define_expand \"cmp<mode>\"\n   [(set (reg:CC CC_REGNUM)\n-        (compare:CC (match_operand:BFP 0 \"register_operand\" \"\")\n-                    (match_operand:BFP 1 \"general_operand\" \"\")))]\n+        (compare:CC (match_operand:FP 0 \"register_operand\" \"\")\n+                    (match_operand:FP 1 \"general_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT\"\n {\n   s390_compare_op0 = operands[0];\n@@ -748,17 +785,17 @@\n })\n \n \n-; (DF|SF) instructions\n+; (TF|DF|SF|TD|DD|SD) instructions\n \n-; ltxbr, ltdbr, ltebr\n+; ltxbr, ltdbr, ltebr, ltxtr, ltdtr\n (define_insn \"*cmp<mode>_ccs_0\"\n   [(set (reg CC_REGNUM)\n-        (compare (match_operand:BFP 0 \"register_operand\" \"f\")\n-                 (match_operand:BFP 1 \"const0_operand\" \"\")))]\n+        (compare (match_operand:FP 0 \"register_operand\" \"f\")\n+                 (match_operand:FP 1 \"const0_operand\"   \"\")))]\n   \"s390_match_ccmode(insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n-  \"lt<xde>br\\t%0,%0\"\n+  \"lt<xde><bt>r\\t%0,%0\"\n    [(set_attr \"op_type\" \"RRE\")\n-    (set_attr \"type\"  \"fsimp<mode>\")])\n+    (set_attr \"type\"  \"fsimp<bfp>\")])\n \n ; ltxr, ltdr, lter\n (define_insn \"*cmp<mode>_ccs_0_ibm\"\n@@ -770,17 +807,17 @@\n    [(set_attr \"op_type\" \"<RRe>\")\n     (set_attr \"type\"  \"fsimp<mode>\")])\n \n-; cxbr, cdbr, cebr, cxb, cdb, ceb\n+; cxtr, cxbr, cdbr, cebr, cxb, cdb, ceb, cxbtr, cdbtr\n (define_insn \"*cmp<mode>_ccs\"\n   [(set (reg CC_REGNUM)\n-        (compare (match_operand:BFP 0 \"register_operand\" \"f,f\")\n-                 (match_operand:BFP 1 \"general_operand\" \"f,<Rf>\")))]\n+        (compare (match_operand:FP 0 \"register_operand\" \"f,f\")\n+                 (match_operand:FP 1 \"general_operand\"  \"f,<Rf>\")))]\n   \"s390_match_ccmode(insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"@\n-   c<xde>br\\t%0,%1\n+   c<xde><bt>r\\t%0,%1\n    c<xde>b\\t%0,%1\"\n    [(set_attr \"op_type\" \"RRE,RXE\")\n-    (set_attr \"type\"  \"fsimp<mode>\")])\n+    (set_attr \"type\"  \"fsimp<bfp>\")])\n \n ; cxr, cdr, cer, cx, cd, ce\n (define_insn \"*cmp<mode>_ccs_ibm\"\n@@ -1472,18 +1509,18 @@\n    (set_attr \"type\" \"lr,load,load,*\")])\n \n ;\n-; movtf instruction pattern(s).\n+; mov(tf|td) instruction pattern(s).\n ;\n \n-(define_expand \"movtf\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:TF 1 \"general_operand\"       \"\"))]\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:TD_TF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:TD_TF 1 \"general_operand\"      \"\"))]\n   \"\"\n   \"\")\n \n-(define_insn \"*movtf_64\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=f,f,f,o,d,QS,d,o,Q\")\n-        (match_operand:TF 1 \"general_operand\"       \"G,f,o,f,QS,d,dm,d,Q\"))]\n+(define_insn \"*mov<mode>_64\"\n+  [(set (match_operand:TD_TF 0 \"nonimmediate_operand\" \"=f,f,f,o, d,QS, d,o,Q\")\n+        (match_operand:TD_TF 1 \"general_operand\"      \" G,f,o,f,QS, d,dm,d,Q\"))]\n   \"TARGET_64BIT\"\n   \"@\n    lzxr\\t%0\n@@ -1498,9 +1535,9 @@\n   [(set_attr \"op_type\" \"RRE,RRE,*,*,RSY,RSY,*,*,*\")\n    (set_attr \"type\"    \"fsimptf,fsimptf,*,*,lm,stm,*,*,*\")])\n \n-(define_insn \"*movtf_31\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=f,f,f,o,Q\")\n-        (match_operand:TF 1 \"general_operand\"       \"G,f,o,f,Q\"))]\n+(define_insn \"*mov<mode>_31\"\n+  [(set (match_operand:TD_TF 0 \"nonimmediate_operand\" \"=f,f,f,o,Q\")\n+        (match_operand:TD_TF 1 \"general_operand\"      \" G,f,o,f,Q\"))]\n   \"!TARGET_64BIT\"\n   \"@\n    lzxr\\t%0\n@@ -1514,80 +1551,84 @@\n ; TFmode in GPRs splitters\n \n (define_split\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:TF 1 \"general_operand\" \"\"))]\n+  [(set (match_operand:TD_TF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:TD_TF 1 \"general_operand\"      \"\"))]\n   \"TARGET_64BIT && reload_completed\n-   && s390_split_ok_p (operands[0], operands[1], TFmode, 0)\"\n+   && s390_split_ok_p (operands[0], operands[1], <MODE>mode, 0)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n {\n-  operands[2] = operand_subword (operands[0], 0, 0, TFmode);\n-  operands[3] = operand_subword (operands[0], 1, 0, TFmode);\n-  operands[4] = operand_subword (operands[1], 0, 0, TFmode);\n-  operands[5] = operand_subword (operands[1], 1, 0, TFmode);\n+  operands[2] = operand_subword (operands[0], 0, 0, <MODE>mode);\n+  operands[3] = operand_subword (operands[0], 1, 0, <MODE>mode);\n+  operands[4] = operand_subword (operands[1], 0, 0, <MODE>mode);\n+  operands[5] = operand_subword (operands[1], 1, 0, <MODE>mode);\n })\n \n (define_split\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:TF 1 \"general_operand\" \"\"))]\n+  [(set (match_operand:TD_TF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:TD_TF 1 \"general_operand\"      \"\"))]\n   \"TARGET_64BIT && reload_completed\n-   && s390_split_ok_p (operands[0], operands[1], TFmode, 1)\"\n+   && s390_split_ok_p (operands[0], operands[1], <MODE>mode, 1)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n {\n-  operands[2] = operand_subword (operands[0], 1, 0, TFmode);\n-  operands[3] = operand_subword (operands[0], 0, 0, TFmode);\n-  operands[4] = operand_subword (operands[1], 1, 0, TFmode);\n-  operands[5] = operand_subword (operands[1], 0, 0, TFmode);\n+  operands[2] = operand_subword (operands[0], 1, 0, <MODE>mode);\n+  operands[3] = operand_subword (operands[0], 0, 0, <MODE>mode);\n+  operands[4] = operand_subword (operands[1], 1, 0, <MODE>mode);\n+  operands[5] = operand_subword (operands[1], 0, 0, <MODE>mode);\n })\n \n (define_split\n-  [(set (match_operand:TF 0 \"register_operand\" \"\")\n-        (match_operand:TF 1 \"memory_operand\" \"\"))]\n+  [(set (match_operand:TD_TF 0 \"register_operand\" \"\")\n+        (match_operand:TD_TF 1 \"memory_operand\"   \"\"))]\n   \"TARGET_64BIT && reload_completed\n    && !FP_REG_P (operands[0])\n    && !s_operand (operands[1], VOIDmode)\"\n   [(set (match_dup 0) (match_dup 1))]\n {\n-  rtx addr = operand_subword (operands[0], 1, 0, DFmode);\n+  rtx addr = operand_subword (operands[0], 1, 0, <MODE>mode);\n   s390_load_address (addr, XEXP (operands[1], 0));\n   operands[1] = replace_equiv_address (operands[1], addr);\n })\n \n ; TFmode in BFPs splitters\n \n (define_split\n-  [(set (match_operand:TF 0 \"register_operand\" \"\")\n-        (match_operand:TF 1 \"memory_operand\" \"\"))]\n+  [(set (match_operand:TD_TF 0 \"register_operand\" \"\")\n+        (match_operand:TD_TF 1 \"memory_operand\" \"\"))]\n   \"reload_completed && offsettable_memref_p (operands[1]) \n    && FP_REG_P (operands[0])\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n {\n-  operands[2] = simplify_gen_subreg (DFmode, operands[0], TFmode, 0);\n-  operands[3] = simplify_gen_subreg (DFmode, operands[0], TFmode, 8);\n-  operands[4] = adjust_address_nv (operands[1], DFmode, 0);\n-  operands[5] = adjust_address_nv (operands[1], DFmode, 8);\n+  operands[2] = simplify_gen_subreg (<HALF_TMODE>mode, operands[0],\n+                                     <MODE>mode, 0);\n+  operands[3] = simplify_gen_subreg (<HALF_TMODE>mode, operands[0],\n+                                     <MODE>mode, 8);\n+  operands[4] = adjust_address_nv (operands[1], <HALF_TMODE>mode, 0);\n+  operands[5] = adjust_address_nv (operands[1], <HALF_TMODE>mode, 8);\n })\n \n (define_split\n-  [(set (match_operand:TF 0 \"memory_operand\" \"\")\n-        (match_operand:TF 1 \"register_operand\" \"\"))]\n+  [(set (match_operand:TD_TF 0 \"memory_operand\" \"\")\n+        (match_operand:TD_TF 1 \"register_operand\" \"\"))]\n   \"reload_completed && offsettable_memref_p (operands[0])\n    && FP_REG_P (operands[1])\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n {\n-  operands[2] = adjust_address_nv (operands[0], DFmode, 0);\n-  operands[3] = adjust_address_nv (operands[0], DFmode, 8);\n-  operands[4] = simplify_gen_subreg (DFmode, operands[1], TFmode, 0);\n-  operands[5] = simplify_gen_subreg (DFmode, operands[1], TFmode, 8);\n+  operands[2] = adjust_address_nv (operands[0], <HALF_TMODE>mode, 0);\n+  operands[3] = adjust_address_nv (operands[0], <HALF_TMODE>mode, 8);\n+  operands[4] = simplify_gen_subreg (<HALF_TMODE>mode, operands[1],\n+\t\t\t\t     <MODE>mode, 0);\n+  operands[5] = simplify_gen_subreg (<HALF_TMODE>mode, operands[1],\n+                                     <MODE>mode, 8);\n })\n \n-(define_expand \"reload_outtf\"\n-  [(parallel [(match_operand:TF 0 \"\" \"\")\n-              (match_operand:TF 1 \"register_operand\" \"f\")\n-              (match_operand:SI 2 \"register_operand\" \"=&a\")])]\n+(define_expand \"reload_out<mode>\"\n+  [(parallel [(match_operand:TD_TF 0 \"\" \"\")\n+              (match_operand:TD_TF 1 \"register_operand\" \"f\")\n+              (match_operand:SI 2    \"register_operand\" \"=&a\")])]\n   \"\"\n {\n   rtx addr = gen_lowpart (Pmode, operands[2]);\n@@ -1599,10 +1640,10 @@\n   DONE;\n })\n \n-(define_expand \"reload_intf\"\n-  [(parallel [(match_operand:TF 0 \"register_operand\" \"=f\")\n-              (match_operand:TF 1 \"\" \"\")\n-              (match_operand:SI 2 \"register_operand\" \"=&a\")])]\n+(define_expand \"reload_in<mode>\"\n+  [(parallel [(match_operand:TD_TF 0 \"register_operand\" \"=f\")\n+              (match_operand:TD_TF 1 \"\" \"\")\n+              (match_operand:SI 2    \"register_operand\" \"=&a\")])]\n   \"\"\n {\n   rtx addr = gen_lowpart (Pmode, operands[2]);\n@@ -1615,20 +1656,20 @@\n })\n \n ;\n-; movdf instruction pattern(s).\n+; mov(df|dd) instruction pattern(s).\n ;\n \n-(define_expand \"movdf\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:DF 1 \"general_operand\"  \"\"))]\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:DD_DF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:DD_DF 1 \"general_operand\"  \"\"))]\n   \"\"\n   \"\")\n \n-(define_insn \"*movdf_64dfp\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-\t\t\t    \"=f,f,f,d,f,f,R,T,d,d,m,?Q\")\n-        (match_operand:DF 1 \"general_operand\"\n-\t\t\t    \"G,f,d,f,R,T,f,f,d,m,d,?Q\"))]\n+(define_insn \"*mov<mode>_64dfp\"\n+  [(set (match_operand:DD_DF 0 \"nonimmediate_operand\"\n+\t\t\t       \"=f,f,f,d,f,f,R,T,d,d,m,?Q\")\n+        (match_operand:DD_DF 1 \"general_operand\"\n+\t\t\t       \"G,f,d,f,R,T,f,f,d,m,d,?Q\"))]\n   \"TARGET_64BIT && TARGET_DFP\"\n   \"@\n    lzdr\\t%0\n@@ -1647,9 +1688,9 @@\n    (set_attr \"type\" \"fsimpdf,floaddf,floaddf,floaddf,floaddf,floaddf,\n                      fstoredf,fstoredf,lr,load,store,*\")])\n \n-(define_insn \"*movdf_64\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,f,f,R,T,d,d,m,?Q\")\n-        (match_operand:DF 1 \"general_operand\"       \"G,f,R,T,f,f,d,m,d,?Q\"))]\n+(define_insn \"*mov<mode>_64\"\n+  [(set (match_operand:DD_DF 0 \"nonimmediate_operand\" \"=f,f,f,f,R,T,d,d,m,?Q\")\n+        (match_operand:DD_DF 1 \"general_operand\"       \"G,f,R,T,f,f,d,m,d,?Q\"))]\n   \"TARGET_64BIT\"\n   \"@\n    lzdr\\t%0\n@@ -1663,11 +1704,14 @@\n    stg\\t%1,%0\n    #\"\n   [(set_attr \"op_type\" \"RRE,RR,RX,RXY,RX,RXY,RRE,RXY,RXY,SS\")\n-   (set_attr \"type\" \"fsimpdf,floaddf,floaddf,floaddf,fstoredf,fstoredf,lr,load,store,*\")])\n-\n-(define_insn \"*movdf_31\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,f,f,R,T,d,d,Q,S,d,o,Q\")\n-        (match_operand:DF 1 \"general_operand\" \"G,f,R,T,f,f,Q,S,d,d,dPm,d,Q\"))]\n+   (set_attr \"type\" \"fsimp<bfp>,fload<bfp>,fload<bfp>,fload<bfp>,\n+                     fstore<bfp>,fstore<bfp>,lr,load,store,*\")])\n+\n+(define_insn \"*mov<mode>_31\"\n+  [(set (match_operand:DD_DF 0 \"nonimmediate_operand\"\n+                               \"=f,f,f,f,R,T,d,d,Q,S,  d,o,Q\")\n+        (match_operand:DD_DF 1 \"general_operand\"\n+                               \" G,f,R,T,f,f,Q,S,d,d,dPm,d,Q\"))]\n   \"!TARGET_64BIT\"\n   \"@\n    lzdr\\t%0\n@@ -1684,54 +1728,54 @@\n    #\n    #\"\n   [(set_attr \"op_type\" \"RRE,RR,RX,RXY,RX,RXY,RS,RSY,RS,RSY,*,*,SS\")\n-   (set_attr \"type\" \"fsimpdf,floaddf,floaddf,floaddf,fstoredf,fstoredf,\\\n-                     lm,lm,stm,stm,*,*,*\")])\n+   (set_attr \"type\" \"fsimp<bfp>,fload<bfp>,fload<bfp>,fload<bfp>,\n+                     fstore<bfp>,fstore<bfp>,lm,lm,stm,stm,*,*,*\")])\n \n (define_split\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:DF 1 \"general_operand\" \"\"))]\n+  [(set (match_operand:DD_DF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:DD_DF 1 \"general_operand\" \"\"))]\n   \"!TARGET_64BIT && reload_completed\n-   && s390_split_ok_p (operands[0], operands[1], DFmode, 0)\"\n+   && s390_split_ok_p (operands[0], operands[1], <MODE>mode, 0)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n {\n-  operands[2] = operand_subword (operands[0], 0, 0, DFmode);\n-  operands[3] = operand_subword (operands[0], 1, 0, DFmode);\n-  operands[4] = operand_subword (operands[1], 0, 0, DFmode);\n-  operands[5] = operand_subword (operands[1], 1, 0, DFmode);\n+  operands[2] = operand_subword (operands[0], 0, 0, <MODE>mode);\n+  operands[3] = operand_subword (operands[0], 1, 0, <MODE>mode);\n+  operands[4] = operand_subword (operands[1], 0, 0, <MODE>mode);\n+  operands[5] = operand_subword (operands[1], 1, 0, <MODE>mode);\n })\n \n (define_split\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:DF 1 \"general_operand\" \"\"))]\n+  [(set (match_operand:DD_DF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:DD_DF 1 \"general_operand\" \"\"))]\n   \"!TARGET_64BIT && reload_completed\n-   && s390_split_ok_p (operands[0], operands[1], DFmode, 1)\"\n+   && s390_split_ok_p (operands[0], operands[1], <MODE>mode, 1)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n {\n-  operands[2] = operand_subword (operands[0], 1, 0, DFmode);\n-  operands[3] = operand_subword (operands[0], 0, 0, DFmode);\n-  operands[4] = operand_subword (operands[1], 1, 0, DFmode);\n-  operands[5] = operand_subword (operands[1], 0, 0, DFmode);\n+  operands[2] = operand_subword (operands[0], 1, 0, <MODE>mode);\n+  operands[3] = operand_subword (operands[0], 0, 0, <MODE>mode);\n+  operands[4] = operand_subword (operands[1], 1, 0, <MODE>mode);\n+  operands[5] = operand_subword (operands[1], 0, 0, <MODE>mode);\n })\n \n (define_split\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-        (match_operand:DF 1 \"memory_operand\" \"\"))]\n+  [(set (match_operand:DD_DF 0 \"register_operand\" \"\")\n+        (match_operand:DD_DF 1 \"memory_operand\" \"\"))]\n   \"!TARGET_64BIT && reload_completed\n    && !FP_REG_P (operands[0])\n    && !s_operand (operands[1], VOIDmode)\"\n   [(set (match_dup 0) (match_dup 1))]\n {\n-  rtx addr = operand_subword (operands[0], 1, 0, DFmode);\n+  rtx addr = operand_subword (operands[0], 1, 0, <MODE>mode);\n   s390_load_address (addr, XEXP (operands[1], 0));\n   operands[1] = replace_equiv_address (operands[1], addr);\n })\n \n-(define_expand \"reload_outdf\"\n-  [(parallel [(match_operand:DF 0 \"\" \"\")\n-              (match_operand:DF 1 \"register_operand\" \"d\")\n-              (match_operand:SI 2 \"register_operand\" \"=&a\")])]\n+(define_expand \"reload_out<mode>\"\n+  [(parallel [(match_operand:DD_DF 0 \"\" \"\")\n+              (match_operand:DD_DF 1 \"register_operand\" \"d\")\n+              (match_operand:SI 2    \"register_operand\" \"=&a\")])]\n   \"!TARGET_64BIT\"\n {\n   gcc_assert (MEM_P (operands[0]));\n@@ -1742,12 +1786,14 @@\n })\n \n ;\n-; movsf instruction pattern(s).\n+; mov(sf|sd) instruction pattern(s).\n ;\n \n-(define_insn \"movsf\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f,f,f,R,T,d,d,d,R,T,?Q\")\n-        (match_operand:SF 1 \"general_operand\" \"G,f,R,T,f,f,d,R,T,d,d,?Q\"))]\n+(define_insn \"mov<mode>\"\n+  [(set (match_operand:SD_SF 0 \"nonimmediate_operand\"\n+\t\t\t       \"=f,f,f,f,R,T,d,d,d,R,T,?Q\")\n+        (match_operand:SD_SF 1 \"general_operand\"\n+\t\t\t       \" G,f,R,T,f,f,d,R,T,d,d,?Q\"))]\n   \"\"\n   \"@\n    lzer\\t%0\n@@ -1763,8 +1809,8 @@\n    sty\\t%1,%0\n    #\"\n   [(set_attr \"op_type\" \"RRE,RR,RX,RXY,RX,RXY,RR,RX,RXY,RX,RXY,SS\")\n-   (set_attr \"type\" \"fsimpsf,floadsf,floadsf,floadsf,fstoresf,fstoresf,\n-                     lr,load,load,store,store,*\")])\n+   (set_attr \"type\" \"fsimp<bfp>,fload<bfp>,fload<bfp>,fload<bfp>,\n+                     fstore<bfp>,fstore<bfp>,lr,load,load,store,store,*\")])\n \n ;\n ; movcc instruction pattern\n@@ -3143,9 +3189,76 @@\n    (set (strict_low_part (match_dup 2)) (match_dup 1))]\n   \"operands[2] = gen_lowpart (QImode, operands[0]);\")\n \n+;\n+; fixuns_trunc(dd|td)di2 instruction pattern(s).\n+;\n+\n+(define_expand \"fixuns_truncdddi2\"\n+  [(parallel\n+    [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t  (unsigned_fix:DI (match_operand:DD 1 \"register_operand\" \"\")))\n+     (clobber (match_scratch:TD 2 \"=f\"))])]\n+\t      \n+  \"TARGET_HARD_FLOAT && TARGET_HARD_DFP\"\n+{\n+  rtx label1 = gen_label_rtx ();\n+  rtx label2 = gen_label_rtx ();\n+  rtx temp = gen_reg_rtx (TDmode);\n+  REAL_VALUE_TYPE cmp, sub;\n+\n+  decimal_real_from_string (&cmp, \"9223372036854775808.0\");  /* 2^63 */\n+  decimal_real_from_string (&sub, \"18446744073709551616.0\"); /* 2^64 */\n+\n+  /* 2^63 can't be represented as 64bit DFP number with full precision.  The\n+     solution is doing the check and the subtraction in TD mode and using a \n+     TD -> DI convert afterwards.  */\n+  emit_insn (gen_extendddtd2 (temp, operands[1]));\n+  temp = force_reg (TDmode, temp);\n+  emit_insn (gen_cmptd (temp,\n+\tCONST_DOUBLE_FROM_REAL_VALUE (cmp, TDmode)));\n+  emit_jump_insn (gen_blt (label1));\n+  emit_insn (gen_subtd3 (temp, temp,\n+\tCONST_DOUBLE_FROM_REAL_VALUE (sub, TDmode)));\n+  emit_insn (gen_fix_trunctddi2 (operands[0], temp, GEN_INT(11)));\n+  emit_jump (label2);\n+\n+  emit_label (label1);\n+  emit_insn (gen_fix_truncdddi2 (operands[0], operands[1], GEN_INT(9)));\n+  emit_label (label2);\n+  DONE;\n+})\n+\n+(define_expand \"fixuns_trunctddi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+        (unsigned_fix:DI (match_operand:TD 1 \"register_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_HARD_DFP\"\n+{\n+  rtx label1 = gen_label_rtx ();\n+  rtx label2 = gen_label_rtx ();\n+  rtx temp = gen_reg_rtx (TDmode);\n+  REAL_VALUE_TYPE cmp, sub;\n+  \n+  operands[1] = force_reg (TDmode, operands[1]);\n+  decimal_real_from_string (&cmp, \"9223372036854775808.0\");  /* 2^63 */\n+  decimal_real_from_string (&sub, \"18446744073709551616.0\"); /* 2^64 */\n+  \n+  emit_insn (gen_cmptd (operands[1],\n+\tCONST_DOUBLE_FROM_REAL_VALUE (cmp, TDmode)));\n+  emit_jump_insn (gen_blt (label1));\n+  emit_insn (gen_subtd3 (temp, operands[1],\n+\tCONST_DOUBLE_FROM_REAL_VALUE (sub, TDmode)));\n+  emit_insn (gen_fix_trunctddi2 (operands[0], temp, GEN_INT(11)));\n+  emit_jump (label2);\n+\n+  emit_label (label1);\n+  emit_insn (gen_fix_trunctddi2 (operands[0], operands[1], GEN_INT(9)));\n+  emit_label (label2);\n+  DONE;\n+})\n \n ;\n-; fixuns_trunc(sf|df)(si|di)2 and fix_trunc(sf|df)(si|di)2 instruction pattern(s).\n+; fixuns_trunc(sf|df)(si|di)2 and fix_trunc(sf|df)(si|di)2 \n+; instruction pattern(s).\n ;\n \n (define_expand \"fixuns_trunc<BFP:mode><GPR:mode>2\"\n@@ -3200,6 +3313,23 @@\n   [(set_attr \"op_type\" \"RRE\")\n    (set_attr \"type\"    \"ftoi\")])\n \n+\n+;\n+; fix_trunc(td|dd)di2 instruction pattern(s).\n+;\n+\n+; cgxtr, cgdtr\n+(define_insn \"fix_trunc<DFP:mode>di2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (fix:DI (match_operand:DFP 1 \"register_operand\" \"f\")))\n+   (unspec:DI [(match_operand:DI 2 \"immediate_operand\" \"K\")] UNSPEC_ROUND)\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_64BIT && TARGET_HARD_FLOAT && TARGET_HARD_DFP\"\n+  \"cg<DFP:xde>tr\\t%0,%h2,%1\"\n+  [(set_attr \"op_type\" \"RRF\")\n+   (set_attr \"type\"    \"ftoi\")])\n+\n+\n ;\n ; fix_trunctf(si|di)2 instruction pattern(s).\n ;\n@@ -3288,12 +3418,12 @@\n ; float(si|di)(tf|df|sf)2 instruction pattern(s).\n ;\n \n-; cxgbr, cdgbr, cegbr\n+; cxgbr, cdgbr, cegbr, cxgtr, cdgtr\n (define_insn \"floatdi<mode>2\"\n-  [(set (match_operand:BFP 0 \"register_operand\" \"=f\")\n-        (float:BFP (match_operand:DI 1 \"register_operand\" \"d\")))]\n+  [(set (match_operand:FP 0 \"register_operand\" \"=f\")\n+        (float:FP (match_operand:DI 1 \"register_operand\" \"d\")))]\n   \"TARGET_64BIT && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n-  \"c<xde>gbr\\t%0,%1\"\n+  \"c<xde>g<bt>r\\t%0,%1\"\n   [(set_attr \"op_type\" \"RRE\")\n    (set_attr \"type\"    \"itof\" )])\n \n@@ -3457,6 +3587,26 @@\n   [(set_attr \"length\"  \"6\")\n    (set_attr \"type\"   \"ftrunctf\")])\n \n+;\n+; trunctddd2 and truncddsd2 instruction pattern(s).\n+;\n+\n+(define_insn \"trunctddd2\"\n+  [(set (match_operand:DD 0 \"register_operand\" \"=f\")\n+\t(float_truncate:DD (match_operand:TD 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_HARD_DFP\"\n+  \"ldxtr\\t%0,0,%1,0\"\n+  [(set_attr \"op_type\" \"RRF\")\n+   (set_attr \"type\"    \"fsimptf\")])\n+\n+(define_insn \"truncddsd2\"\n+  [(set (match_operand:SD 0 \"register_operand\" \"=f\")\n+\t(float_truncate:SD (match_operand:DD 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_HARD_DFP\"\n+  \"ledtr\\t%0,0,%1,0\"\n+  [(set_attr \"op_type\" \"RRF\")\n+   (set_attr \"type\"    \"fsimptf\")])\n+\n ;\n ; extendsfdf2 instruction pattern(s).\n ;\n@@ -3554,6 +3704,25 @@\n   [(set_attr \"op_type\"  \"RRE,RXE\")\n    (set_attr \"type\"   \"fsimptf, floadtf\")])\n \n+;\n+; extendddtd2 and extendsddd2 instruction pattern(s).\n+;\n+\n+(define_insn \"extendddtd2\"\n+  [(set (match_operand:TD 0 \"register_operand\" \"=f\")\n+\t(float_extend:TD (match_operand:DD 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_HARD_DFP\"\n+  \"lxdtr\\t%0,%1,0\"\n+  [(set_attr \"op_type\" \"RRF\")\n+   (set_attr \"type\"    \"fsimptf\")])\n+\n+(define_insn \"extendsddd2\"\n+  [(set (match_operand:DD 0 \"register_operand\" \"=f\")\n+\t(float_extend:DD (match_operand:SD 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_HARD_DFP\"\n+  \"ldetr\\t%0,%1,0\"\n+  [(set_attr \"op_type\" \"RRF\")\n+   (set_attr \"type\"    \"fsimptf\")])\n \n ;;\n ;; ARITHMETIC OPERATIONS\n@@ -3878,59 +4047,59 @@\n   [(set_attr \"op_type\"  \"RI,RIL\")])\n \n ;\n-; add(df|sf)3 instruction pattern(s).\n+; add(tf|df|sf|td|dd)3 instruction pattern(s).\n ;\n \n (define_expand \"add<mode>3\"\n   [(parallel\n-    [(set (match_operand:BFP 0 \"register_operand\" \"=f,f\")\n-          (plus:BFP (match_operand:BFP 1 \"nonimmediate_operand\" \"%0,0\")\n-                    (match_operand:BFP 2 \"general_operand\" \"f,<Rf>\")))\n+    [(set (match_operand:FP 0 \"register_operand\" \"\")\n+          (plus:FP (match_operand:FP 1 \"nonimmediate_operand\" \"\")\n+                    (match_operand:FP 2 \"general_operand\" \"\")))\n      (clobber (reg:CC CC_REGNUM))])]\n   \"TARGET_HARD_FLOAT\"\n   \"\")\n \n-; axbr, adbr, aebr, axb, adb, aeb\n+; axbr, adbr, aebr, axb, adb, aeb, adtr, axtr\n (define_insn \"*add<mode>3\"\n-  [(set (match_operand:BFP 0 \"register_operand\" \"=f,f\")\n-        (plus:BFP (match_operand:BFP 1 \"nonimmediate_operand\" \"%0,0\")\n-                  (match_operand:BFP 2 \"general_operand\" \"f,<Rf>\")))\n+  [(set (match_operand:FP 0 \"register_operand\"              \"=f,   f\")\n+        (plus:FP (match_operand:FP 1 \"nonimmediate_operand\" \"%<f0>,0\")\n+\t\t (match_operand:FP 2 \"general_operand\"      \" f,<Rf>\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"@\n-   a<xde>br\\t%0,%2\n+   a<xde><bt>r\\t%0,<op1>%2\n    a<xde>b\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RRE,RXE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+  [(set_attr \"op_type\"  \"<RRer>,RXE\")\n+   (set_attr \"type\"     \"fsimp<bfp>\")])\n \n-; axbr, adbr, aebr, axb, adb, aeb\n+; axbr, adbr, aebr, axb, adb, aeb, adtr, axtr\n (define_insn \"*add<mode>3_cc\"\n   [(set (reg CC_REGNUM)\n-\t(compare (plus:BFP (match_operand:BFP 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t   (match_operand:BFP 2 \"general_operand\" \"f,<Rf>\"))\n-\t\t (match_operand:BFP 3 \"const0_operand\" \"\")))\n-   (set (match_operand:BFP 0 \"register_operand\" \"=f,f\")\n-\t(plus:BFP (match_dup 1) (match_dup 2)))]\n+\t(compare (plus:FP (match_operand:FP 1 \"nonimmediate_operand\" \"%<f0>,0\")\n+\t\t\t  (match_operand:FP 2 \"general_operand\"      \" f,<Rf>\"))\n+\t\t (match_operand:FP 3 \"const0_operand\" \"\")))\n+   (set (match_operand:FP 0 \"register_operand\" \"=f,f\")\n+\t(plus:FP (match_dup 1) (match_dup 2)))]\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"@\n-   a<xde>br\\t%0,%2\n+   a<xde><bt>r\\t%0,<op1>%2\n    a<xde>b\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RRE,RXE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+  [(set_attr \"op_type\"  \"<RRer>,RXE\")\n+   (set_attr \"type\"     \"fsimp<bfp>\")])\n \n-; axbr, adbr, aebr, axb, adb, aeb\n+; axbr, adbr, aebr, axb, adb, aeb, adtr, axtr\n (define_insn \"*add<mode>3_cconly\"\n   [(set (reg CC_REGNUM)\n-\t(compare (plus:BFP (match_operand:BFP 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t   (match_operand:BFP 2 \"general_operand\" \"f,<Rf>\"))\n-\t\t (match_operand:BFP 3 \"const0_operand\" \"\")))\n-   (clobber (match_scratch:BFP 0 \"=f,f\"))]\n+\t(compare (plus:FP (match_operand:FP 1 \"nonimmediate_operand\" \"%<f0>,0\")\n+\t\t\t   (match_operand:FP 2 \"general_operand\"      \" f,<Rf>\"))\n+\t\t (match_operand:FP 3 \"const0_operand\" \"\")))\n+   (clobber (match_scratch:FP 0 \"=f,f\"))]\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"@\n-   a<xde>br\\t%0,%2\n+   a<xde><bt>r\\t%0,<op1>%2\n    a<xde>b\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RRE,RXE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+  [(set_attr \"op_type\"  \"<RRer>,RXE\")\n+   (set_attr \"type\"     \"fsimp<bfp>\")])\n \n ; axr, adr, aer, ax, ad, ae\n (define_insn \"*add<mode>3_ibm\"\n@@ -4221,59 +4390,59 @@\n   [(set_attr \"op_type\"  \"RR<E>,RX<Y>,RXY\")])\n \n ;\n-; sub(df|sf)3 instruction pattern(s).\n+; sub(tf|df|sf|td|dd)3 instruction pattern(s).\n ;\n \n (define_expand \"sub<mode>3\"\n   [(parallel\n-    [(set (match_operand:BFP 0 \"register_operand\" \"=f,f\")\n-          (minus:BFP (match_operand:BFP 1 \"register_operand\" \"0,0\")\n-                     (match_operand:BFP 2 \"general_operand\" \"f,R\")))\n+    [(set (match_operand:FP 0 \"register_operand\" \"\")\n+          (minus:FP (match_operand:FP 1 \"register_operand\" \"\")\n+                     (match_operand:FP 2 \"general_operand\" \"\")))\n      (clobber (reg:CC CC_REGNUM))])]\n   \"TARGET_HARD_FLOAT\"\n   \"\")\n \n-; sxbr, sdbr, sebr, sxb, sdb, seb\n+; sxbr, sdbr, sebr, sxb, sdb, seb, sxtr, sdtr\n (define_insn \"*sub<mode>3\"\n-  [(set (match_operand:BFP 0 \"register_operand\" \"=f,f\")\n-        (minus:BFP (match_operand:BFP 1 \"register_operand\" \"0,0\")\n-                   (match_operand:BFP 2 \"general_operand\" \"f,<Rf>\")))\n+  [(set (match_operand:FP 0 \"register_operand\"            \"=f,  f\")\n+        (minus:FP (match_operand:FP 1 \"register_operand\" \"<f0>,0\")\n+                   (match_operand:FP 2 \"general_operand\"  \"f,<Rf>\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"@\n-   s<xde>br\\t%0,%2\n+   s<xde><bt>r\\t%0,<op1>%2\n    s<xde>b\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RRE,RXE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+  [(set_attr \"op_type\"  \"<RRer>,RXE\")\n+   (set_attr \"type\"     \"fsimp<bfp>\")])\n \n-; sxbr, sdbr, sebr, sxb, sdb, seb\n+; sxbr, sdbr, sebr, sxb, sdb, seb, sxtr, sdtr\n (define_insn \"*sub<mode>3_cc\"\n   [(set (reg CC_REGNUM)\n-\t(compare (minus:BFP (match_operand:BFP 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t\t    (match_operand:BFP 2 \"general_operand\" \"f,<Rf>\"))\n-\t\t (match_operand:BFP 3 \"const0_operand\" \"\")))\n-   (set (match_operand:BFP 0 \"register_operand\" \"=f,f\")\n-\t(minus:BFP (match_dup 1) (match_dup 2)))]\n+\t(compare (minus:FP (match_operand:FP 1 \"nonimmediate_operand\" \"<f0>,0\")\n+\t\t\t    (match_operand:FP 2 \"general_operand\"      \"f,<Rf>\"))\n+\t\t (match_operand:FP 3 \"const0_operand\" \"\")))\n+   (set (match_operand:FP 0 \"register_operand\" \"=f,f\")\n+\t(minus:FP (match_dup 1) (match_dup 2)))]\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"@\n-   s<xde>br\\t%0,%2\n+   s<xde><bt>r\\t%0,<op1>%2\n    s<xde>b\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RRE,RXE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+  [(set_attr \"op_type\"  \"<RRer>,RXE\")\n+   (set_attr \"type\"     \"fsimp<bfp>\")])\n \n-; sxbr, sdbr, sebr, sxb, sdb, seb\n+; sxbr, sdbr, sebr, sxb, sdb, seb, sxtr, sdtr\n (define_insn \"*sub<mode>3_cconly\"\n   [(set (reg CC_REGNUM)\n-\t(compare (minus:BFP (match_operand:BFP 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t\t    (match_operand:BFP 2 \"general_operand\" \"f,<Rf>\"))\n-\t\t (match_operand:BFP 3 \"const0_operand\" \"\")))\n-   (clobber (match_scratch:BFP 0 \"=f,f\"))]\n+\t(compare (minus:FP (match_operand:FP 1 \"nonimmediate_operand\" \"<f0>,0\")\n+\t\t\t   (match_operand:FP 2 \"general_operand\"      \"f,<Rf>\"))\n+\t\t (match_operand:FP 3 \"const0_operand\" \"\")))\n+   (clobber (match_scratch:FP 0 \"=f,f\"))]\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"@\n-   s<xde>br\\t%0,%2\n+   s<xde><bt>r\\t%0,<op1>%2\n    s<xde>b\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RRE,RXE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+  [(set_attr \"op_type\"  \"<RRer>,RXE\")\n+   (set_attr \"type\"     \"fsimp<bfp>\")])\n \n ; sxr, sdr, ser, sx, sd, se\n (define_insn \"*sub<mode>3_ibm\"\n@@ -4531,27 +4700,27 @@\n    (set_attr \"type\"     \"imulsi\")])\n \n ;\n-; mul(df|sf)3 instruction pattern(s).\n+; mul(tf|df|sf|td|dd)3 instruction pattern(s).\n ;\n \n (define_expand \"mul<mode>3\"\n-  [(set (match_operand:BFP 0 \"register_operand\" \"=f,f\")\n-        (mult:BFP (match_operand:BFP 1 \"nonimmediate_operand\" \"%0,0\")\n-                  (match_operand:BFP 2 \"general_operand\" \"f,<Rf>\")))]\n+  [(set (match_operand:FP 0 \"register_operand\" \"\")\n+        (mult:FP (match_operand:FP 1 \"nonimmediate_operand\" \"\")\n+                  (match_operand:FP 2 \"general_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"\")\n \n-; mxbr mdbr, meebr, mxb, mxb, meeb\n+; mxbr mdbr, meebr, mxb, mxb, meeb, mdtr, mxtr\n (define_insn \"*mul<mode>3\"\n-  [(set (match_operand:BFP 0 \"register_operand\" \"=f,f\")\n-        (mult:BFP (match_operand:BFP 1 \"nonimmediate_operand\" \"%0,0\")\n-                  (match_operand:BFP 2 \"general_operand\" \"f,<Rf>\")))]\n+  [(set (match_operand:FP 0 \"register_operand\"              \"=f,f\")\n+        (mult:FP (match_operand:FP 1 \"nonimmediate_operand\" \"%<f0>,0\")\n+                 (match_operand:FP 2 \"general_operand\"      \"f,<Rf>\")))]\n   \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"@\n-   m<xdee>br\\t%0,%2\n+   m<xdee><bt>r\\t%0,<op1>%2\n    m<xdee>b\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RRE,RXE\")\n-   (set_attr \"type\"     \"fmul<mode>\")])\n+  [(set_attr \"op_type\"  \"<RRer>,RXE\")\n+   (set_attr \"type\"     \"fmul<bfp>\")])\n \n ; mxr, mdr, mer, mx, md, me\n (define_insn \"*mul<mode>3_ibm\"\n@@ -5014,23 +5183,23 @@\n ;\n \n (define_expand \"div<mode>3\"\n-  [(set (match_operand:BFP 0 \"register_operand\" \"=f,f\")\n-        (div:BFP (match_operand:BFP 1 \"register_operand\" \"0,0\")\n-                 (match_operand:BFP 2 \"general_operand\" \"f,<Rf>\")))]\n+  [(set (match_operand:FP 0 \"register_operand\" \"\")\n+        (div:FP (match_operand:FP 1 \"register_operand\" \"\")\n+                 (match_operand:FP 2 \"general_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"\")\n \n-; dxbr, ddbr, debr, dxb, ddb, deb\n+; dxbr, ddbr, debr, dxb, ddb, deb, ddtr, dxtr\n (define_insn \"*div<mode>3\"\n-  [(set (match_operand:BFP 0 \"register_operand\" \"=f,f\")\n-        (div:BFP (match_operand:BFP 1 \"register_operand\" \"0,0\")\n-                 (match_operand:BFP 2 \"general_operand\" \"f,<Rf>\")))]\n+  [(set (match_operand:FP 0 \"register_operand\"          \"=f,f\")\n+        (div:FP (match_operand:FP 1 \"register_operand\" \"<f0>,0\")\n+                 (match_operand:FP 2 \"general_operand\"  \"f,<Rf>\")))]\n   \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"@\n-   d<xde>br\\t%0,%2\n+   d<xde><bt>r\\t%0,<op1>%2\n    d<xde>b\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RRE,RXE\")\n-   (set_attr \"type\"     \"fdiv<mode>\")])\n+  [(set_attr \"op_type\"  \"<RRer>,RXE\")\n+   (set_attr \"type\"     \"fdiv<bfp>\")])\n \n ; dxr, ddr, der, dx, dd, de\n (define_insn \"*div<mode>3_ibm\"\n@@ -6045,12 +6214,12 @@\n \n ; lcdfr\n (define_insn \"*neg<mode>2_nocc\"\n-  [(set (match_operand:BFP 0 \"register_operand\"          \"=f\")\n-        (neg:BFP (match_operand:BFP 1 \"register_operand\" \"<fT0>\")))]\n+  [(set (match_operand:FP 0 \"register_operand\"         \"=f\")\n+        (neg:FP (match_operand:FP 1 \"register_operand\" \"<fT0>\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DFP\"\n   \"lcdfr\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+   (set_attr \"type\"     \"fsimp<bfp>\")])\n \n ; lcxbr, lcdbr, lcebr\n (define_insn \"*neg<mode>2\"\n@@ -6168,12 +6337,12 @@\n \n ; lpdfr\n (define_insn \"*abs<mode>2_nocc\"\n-  [(set (match_operand:BFP 0 \"register_operand\"          \"=f\")\n-        (abs:BFP (match_operand:BFP 1 \"register_operand\" \"<fT0>\")))]\n+  [(set (match_operand:FP 0 \"register_operand\"         \"=f\")\n+        (abs:FP (match_operand:FP 1 \"register_operand\" \"<fT0>\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DFP\"\n   \"lpdfr\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+   (set_attr \"type\"     \"fsimp<bfp>\")])\n \n ; lpxbr, lpdbr, lpebr\n (define_insn \"*abs<mode>2\"\n@@ -6283,12 +6452,12 @@\n \n ; lndfr\n (define_insn \"*negabs<mode>2_nocc\"\n-  [(set (match_operand:BFP 0 \"register_operand\"                   \"=f\")\n-        (neg:BFP (abs:BFP (match_operand:BFP 1 \"register_operand\" \"<fT0>\"))))]\n+  [(set (match_operand:FP 0 \"register_operand\"                  \"=f\")\n+        (neg:FP (abs:FP (match_operand:BFP 1 \"register_operand\" \"<fT0>\"))))]\n   \"TARGET_HARD_FLOAT && TARGET_DFP\"\n   \"lndfr\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+   (set_attr \"type\"     \"fsimp<bfp>\")])\n \n ; lnxbr, lndbr, lnebr\n (define_insn \"*negabs<mode>2\"\n@@ -6306,14 +6475,14 @@\n \n ; cpsdr\n (define_insn \"copysign<mode>3\"\n-  [(set (match_operand:BFP 0 \"register_operand\" \"=f\")\n-\t(unspec:BFP [(match_operand:BFP 1 \"register_operand\" \"<fT0>\")\n-\t\t     (match_operand:BFP 2 \"register_operand\" \"f\")] \n+  [(set (match_operand:FP 0 \"register_operand\" \"=f\")\n+\t(unspec:FP [(match_operand:FP 1 \"register_operand\" \"<fT0>\")\n+\t\t    (match_operand:FP 2 \"register_operand\" \"f\")] \n \t\t    UNSPEC_COPYSIGN))]\n   \"TARGET_HARD_FLOAT && TARGET_DFP\"\n   \"cpsdr\\t%0,%2,%1\"\n   [(set_attr \"op_type\"  \"RRF\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+   (set_attr \"type\"     \"fsimp<bfp>\")])\n \n ;;\n ;;- Square root instructions."}]}