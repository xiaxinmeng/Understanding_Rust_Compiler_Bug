{"sha": "a199fdd6758aa7e3bdff4a2a2a383d8a1baea657", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE5OWZkZDY3NThhYTdlM2JkZmY0YTJhMmEzODNkOGExYmFlYTY1Nw==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-08-28T01:43:02Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-08-28T01:43:02Z"}, "message": "(all patterns): Use GEN_INT instead of gen_rtx to get const_ints.\n\nAvoid double-negative \"! NON_*\" constructs for clarity.\nPass NULL_PTR as null parameter instead of 0.\n(sqrtM2): Patterns are only valid if IEEE FP or -ffast-math.\n(sinM2,cosM2): New patterns.\n(zero_extract test): New pattern.\n\nFrom-SVN: r1982", "tree": {"sha": "0fc62926420d7580f392df4bb48b3f92292205e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fc62926420d7580f392df4bb48b3f92292205e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a199fdd6758aa7e3bdff4a2a2a383d8a1baea657", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a199fdd6758aa7e3bdff4a2a2a383d8a1baea657", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a199fdd6758aa7e3bdff4a2a2a383d8a1baea657", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a199fdd6758aa7e3bdff4a2a2a383d8a1baea657/comments", "author": null, "committer": null, "parents": [{"sha": "435defd182d6958de238652ba7b6f8f36e153dce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/435defd182d6958de238652ba7b6f8f36e153dce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/435defd182d6958de238652ba7b6f8f36e153dce"}], "stats": {"total": 228, "additions": 155, "deletions": 73}, "files": [{"sha": "f6b031cdf353f4629e54a2d2b10461b50856e5c6", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 155, "deletions": 73, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a199fdd6758aa7e3bdff4a2a2a383d8a1baea657/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a199fdd6758aa7e3bdff4a2a2a383d8a1baea657/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=a199fdd6758aa7e3bdff4a2a2a383d8a1baea657", "patch": "@@ -52,7 +52,10 @@\n ;;    operand 1 is a register containing the value to scan for.  The mode\n ;;       of the scas opcode will be the same as the mode of this operand.\n ;;    operand 2 is the known alignment of operand 0.\n-\n+;; 1  This is a `sin' operation.  The mode of the UNSPEC is MODE_FLOAT.\n+;;    operand 0 is the argument for `sin'.\n+;; 2  This is a `cos' operation.  The mode of the UNSPEC is MODE_FLOAT.\n+;;    operand 0 is the argument for `cos'.\n \f\n ;; \"movl MEM,REG / testl REG,REG\" is faster on a 486 than \"cmpl $0,MEM\".\n ;; But restricting MEM here would mean that gcc could not remove a redundant\n@@ -427,7 +430,7 @@\n   /* For small integers, we may actually use testb. */\n   if (GET_CODE (operands[1]) == CONST_INT\n       && ! (GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0]))\n-      && ! NON_QI_REG_P (operands[0]))\n+      && (! REG_P (operands[0]) || QI_REG_P (operands[0])))\n     {\n       /* We may set the sign bit spuriously.  */\n \n@@ -440,8 +443,7 @@\n       if ((INTVAL (operands[1]) & ~0xff00) == 0)\n         {\n \t  cc_status.flags |= CC_NOT_NEGATIVE;\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t INTVAL (operands[1]) >> 8);\n+\t  operands[1] = GEN_INT (INTVAL (operands[1]) >> 8);\n \n \t  if (QI_REG_P (operands[0]))\n \t    return AS2 (test%B0,%1,%h0);\n@@ -456,19 +458,15 @@\n \t  && (INTVAL (operands[1]) & ~0xff0000) == 0)\n         {\n \t  cc_status.flags |= CC_NOT_NEGATIVE;\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t INTVAL (operands[1]) >> 16);\n-\n+\t  operands[1] = GEN_INT (INTVAL (operands[1]) >> 16);\n \t  operands[0] = adj_offsettable_operand (operands[0], 2);\n \t  return AS2 (test%B0,%1,%b0);\n \t}\n \n       if (GET_CODE (operands[0]) == MEM\n \t  && (INTVAL (operands[1]) & ~0xff000000) == 0)\n         {\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t (INTVAL (operands[1]) >> 24) & 0xff);\n-\n+\t  operands[1] = GEN_INT ((INTVAL (operands[1]) >> 24) & 0xff);\n \t  operands[0] = adj_offsettable_operand (operands[0], 3);\n \t  return AS2 (test%B0,%1,%b0);\n \t}\n@@ -489,14 +487,13 @@\n {\n   if (GET_CODE (operands[1]) == CONST_INT\n       && ! (GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0]))\n-      && ! NON_QI_REG_P (operands[0]))\n+      && (! REG_P (operands[0]) || QI_REG_P (operands[0])))\n     {\n       if ((INTVAL (operands[1]) & 0xff00) == 0)\n \t{\n \t  /* ??? This might not be necessary. */\n \t  if (INTVAL (operands[1]) & 0xffff0000)\n-\t    operands[1] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t   INTVAL (operands[1]) & 0xff);\n+\t    operands[1] = GEN_INT (INTVAL (operands[1]) & 0xff);\n \n \t  /* We may set the sign bit spuriously.  */\n \t  cc_status.flags |= CC_NOT_NEGATIVE;\n@@ -505,8 +502,7 @@\n \n       if ((INTVAL (operands[1]) & 0xff) == 0)\n         {\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t (INTVAL (operands[1]) >> 8) & 0xff);\n+\t  operands[1] = GEN_INT ((INTVAL (operands[1]) >> 8) & 0xff);\n \n \t  if (QI_REG_P (operands[0]))\n \t    return AS2 (test%B0,%1,%h0);\n@@ -772,7 +768,7 @@\n         abort ();\n \n       xops[0] = AT_SP (SFmode);\n-      xops[1] = gen_rtx (CONST_INT, VOIDmode, 4);\n+      xops[1] = GEN_INT (4);\n       xops[2] = stack_pointer_rtx;\n \n       output_asm_insn (AS2 (sub%L2,%1,%2), xops);\n@@ -853,7 +849,7 @@\n       rtx xops[3];\n \n       xops[0] = AT_SP (SFmode);\n-      xops[1] = gen_rtx (CONST_INT, VOIDmode, 8);\n+      xops[1] = GEN_INT (8);\n       xops[2] = stack_pointer_rtx;\n \n       output_asm_insn (AS2 (sub%L2,%1,%2), xops);\n@@ -974,7 +970,7 @@\n     {\n       rtx xops[2];\n       xops[0] = operands[0];\n-      xops[1] = gen_rtx (CONST_INT, VOIDmode, 0xffff);\n+      xops[1] = GEN_INT (0xffff);\n       output_asm_insn (AS2 (and%L0,%1,%k0), xops);\n       RET;\n     }\n@@ -998,7 +994,7 @@\n     {\n       rtx xops[2];\n       xops[0] = operands[0];\n-      xops[1] = gen_rtx (CONST_INT, VOIDmode, 0xff);\n+      xops[1] = GEN_INT (0xff);\n       output_asm_insn (AS2 (and%L0,%1,%k0), xops);\n       RET;\n     }\n@@ -1022,7 +1018,7 @@\n     {\n       rtx xops[2];\n       xops[0] = operands[0];\n-      xops[1] = gen_rtx (CONST_INT, VOIDmode, 0xff);\n+      xops[1] = GEN_INT (0xff);\n       output_asm_insn (AS2 (and%L0,%1,%k0), xops);\n       RET;\n     }\n@@ -1822,8 +1818,7 @@\n \t      return AS2 (mov%B0,%2,%b0);\n \t    }\n \n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t INTVAL (operands[2]) & 0xff);\n+\t  operands[2] = GEN_INT (INTVAL (operands[2]) & 0xff);\n \t  return AS2 (and%B0,%2,%b0);\n \t}\n \n@@ -1837,8 +1832,7 @@\n \t      return AS2 (mov%B0,%2,%h0);\n \t    }\n \n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t INTVAL (operands[2]) >> 8);\n+\t  operands[2] = GEN_INT (INTVAL (operands[2]) >> 8);\n \t  return AS2 (and%B0,%2,%h0);\n \t}\n \n@@ -1863,7 +1857,7 @@\n       && ! (GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0])))\n     {\n       /* Can we ignore the upper byte? */\n-      if (! NON_QI_REG_P (operands[0])\n+      if ((! REG_P (operands[0]) || QI_REG_P (operands[0]))\n \t  && (INTVAL (operands[2]) & 0xff00) == 0xff00)\n \t{\n \t  CC_STATUS_INIT;\n@@ -1874,8 +1868,7 @@\n \t      return AS2 (mov%B0,%2,%b0);\n \t    }\n \n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t INTVAL (operands[2]) & 0xff);\n+\t  operands[2] = GEN_INT (INTVAL (operands[2]) & 0xff);\n \t  return AS2 (and%B0,%2,%b0);\n \t}\n \n@@ -1891,8 +1884,7 @@\n \t      return AS2 (mov%B0,%2,%h0);\n \t    }\n \n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t (INTVAL (operands[2]) >> 8) & 0xff);\n+\t  operands[2] = GEN_INT ((INTVAL (operands[2]) >> 8) & 0xff);\n \t  return AS2 (and%B0,%2,%h0);\n \t}\n     }\n@@ -1944,7 +1936,8 @@\n   if (GET_CODE (operands[2]) == CONST_INT\n       && ! (GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0])))\n     {\n-      if (! NON_QI_REG_P (operands[0]) && (INTVAL (operands[2]) & ~0xff) == 0)\n+      if ((! REG_P (operands[0]) || QI_REG_P (operands[0]))\n+\t  && (INTVAL (operands[2]) & ~0xff) == 0)\n \t{\n \t  CC_STATUS_INIT;\n \n@@ -1957,8 +1950,7 @@\n       if (QI_REG_P (operands[0]) && (INTVAL (operands[2]) & ~0xff00) == 0)\n \t{\n \t  CC_STATUS_INIT;\n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t INTVAL (operands[2]) >> 8);\n+\t  operands[2] = GEN_INT (INTVAL (operands[2]) >> 8);\n \n \t  if (INTVAL (operands[2]) == 0xff)\n \t    return AS2 (mov%B0,%2,%h0);\n@@ -1981,13 +1973,12 @@\n       && ! (GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0])))\n     {\n       /* Can we ignore the upper byte? */\n-      if (! NON_QI_REG_P (operands[0])\n+      if ((! REG_P (operands[0]) || QI_REG_P (operands[0]))\n \t  && (INTVAL (operands[2]) & 0xff00) == 0)\n \t{\n \t  CC_STATUS_INIT;\n \t  if (INTVAL (operands[2]) & 0xffff0000)\n-\t    operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t   INTVAL (operands[2]) & 0xffff);\n+\t    operands[2] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n \n \t  if (INTVAL (operands[2]) == 0xff)\n \t    return AS2 (mov%B0,%2,%b0);\n@@ -2001,8 +1992,7 @@\n \t  && (INTVAL (operands[2]) & 0xff) == 0)\n \t{\n \t  CC_STATUS_INIT;\n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t (INTVAL (operands[2]) >> 8) & 0xff);\n+\t  operands[2] = GEN_INT ((INTVAL (operands[2]) >> 8) & 0xff);\n \n \t  if (INTVAL (operands[2]) == 0xff)\n \t    return AS2 (mov%B0,%2,%h0);\n@@ -2034,7 +2024,8 @@\n   if (GET_CODE (operands[2]) == CONST_INT\n       && ! (GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0])))\n     {\n-      if (! NON_QI_REG_P (operands[0]) && (INTVAL (operands[2]) & ~0xff) == 0)\n+      if ((! REG_P (operands[0]) || QI_REG_P (operands[0]))\n+\t  && (INTVAL (operands[2]) & ~0xff) == 0)\n \t{\n \t  CC_STATUS_INIT;\n \n@@ -2047,8 +2038,7 @@\n       if (QI_REG_P (operands[0]) && (INTVAL (operands[2]) & ~0xff00) == 0)\n \t{\n \t  CC_STATUS_INIT;\n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t INTVAL (operands[2]) >> 8);\n+\t  operands[2] = GEN_INT (INTVAL (operands[2]) >> 8);\n \n \t  if (INTVAL (operands[2]) == 0xff)\n \t    return AS1 (not%B0,%h0);\n@@ -2071,13 +2061,12 @@\n       && ! (GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0])))\n     {\n       /* Can we ignore the upper byte? */\n-      if (! NON_QI_REG_P (operands[0])\n+      if ((! REG_P (operands[0]) || QI_REG_P (operands[0]))\n \t  && (INTVAL (operands[2]) & 0xff00) == 0)\n \t{\n \t  CC_STATUS_INIT;\n \t  if (INTVAL (operands[2]) & 0xffff0000)\n-\t    operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t   INTVAL (operands[2]) & 0xffff);\n+\t    operands[2] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n \n \t  if (INTVAL (operands[2]) == 0xff)\n \t    return AS1 (not%B0,%b0);\n@@ -2091,8 +2080,7 @@\n \t  && (INTVAL (operands[2]) & 0xff) == 0)\n \t{\n \t  CC_STATUS_INIT;\n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t (INTVAL (operands[2]) >> 8) & 0xff);\n+\t  operands[2] = GEN_INT ((INTVAL (operands[2]) >> 8) & 0xff);\n \n \t  if (INTVAL (operands[2]) == 0xff)\n \t    return AS1 (not%B0,%h0);\n@@ -2192,21 +2180,59 @@\n (define_insn \"sqrtsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(sqrt:SF (match_operand:SF 1 \"general_operand\" \"0\")))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 && (TARGET_IEEE_FP || flag_fast_math)\"\n   \"fsqrt\")\n \n (define_insn \"sqrtdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(sqrt:DF (match_operand:DF 1 \"general_operand\" \"0\")))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 && (TARGET_IEEE_FP || flag_fast_math)\"\n   \"fsqrt\")\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(sqrt:DF (float_extend:DF\n \t\t  (match_operand:SF 1 \"general_operand\" \"0\"))))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 && (TARGET_IEEE_FP || flag_fast_math)\"\n   \"fsqrt\")\n+\n+(define_insn \"sindf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(unspec:DF [(match_operand:DF 1 \"register_operand\" \"0\")] 1))]\n+  \"TARGET_80387 && (TARGET_IEEE_FP || flag_fast_math)\"\n+  \"fsin\")\n+\n+(define_insn \"sinsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"0\")] 1))]\n+  \"TARGET_80387 && (TARGET_IEEE_FP || flag_fast_math)\"\n+  \"fsin\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(unspec:DF [(float_extend:DF\n+\t\t     (match_operand:SF 1 \"register_operand\" \"0\"))] 1))]\n+  \"TARGET_80387 && (TARGET_IEEE_FP || flag_fast_math)\"\n+  \"fsin\")\n+\n+(define_insn \"cosdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(unspec:DF [(match_operand:DF 1 \"register_operand\" \"0\")] 2))]\n+  \"TARGET_80387 && (TARGET_IEEE_FP || flag_fast_math)\"\n+  \"fcos\")\n+\n+(define_insn \"cossf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"0\")] 2))]\n+  \"TARGET_80387 && (TARGET_IEEE_FP || flag_fast_math)\"\n+  \"fcos\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(unspec:DF [(float_extend:DF\n+\t\t     (match_operand:SF 1 \"register_operand\" \"0\"))] 2))]\n+  \"TARGET_80387 && (TARGET_IEEE_FP || flag_fast_math)\"\n+  \"fcos\")\n \f\n ;;- one complement instructions\n \n@@ -2297,8 +2323,7 @@\n \n       if (INTVAL (xops[0]) > 32)\n         {\n-\t  xops[0] = gen_rtx (CONST_INT, VOIDmode, INTVAL (xops[0]) - 32);\n-\n+\t  xops[0] = GEN_INT (INTVAL (xops[0]) - 32);\n \t  output_asm_insn (AS2 (sal%L3,%0,%3), xops); /* Remaining shift */\n \t}\n     }\n@@ -2335,7 +2360,7 @@\n   output_asm_insn (AS3_SHIFT_DOUBLE (shld%L3,%0,%2,%3), xops);\n   output_asm_insn (AS2 (sal%L2,%0,%2), xops);\n \n-  xops[1] = gen_rtx (CONST_INT, VOIDmode, 7);\t/* shift count & 1 */\n+  xops[1] = GEN_INT (7);\t\t\t/* shift count & 1 */\n \n   output_asm_insn (AS2 (shr%B0,%1,%0), xops);\n \n@@ -2367,8 +2392,7 @@\n         {\n           CC_STATUS_INIT;\n           operands[1] = gen_rtx (MULT, SImode, operands[1],\n-\t\t\t\t gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t  1 << INTVAL (operands[2])));\n+\t\t\t\t GEN_INT (1 << INTVAL (operands[2])));\n \t  return AS2 (lea%L0,%a1,%0);\n \t}\n     }\n@@ -2455,14 +2479,13 @@\n \n   if (INTVAL (xops[0]) > 31)\n     {\n-      xops[1] = gen_rtx (CONST_INT, VOIDmode, 31);\n+      xops[1] = GEN_INT (31);\n       output_asm_insn (AS2 (mov%L2,%3,%2), xops);\n       output_asm_insn (AS2 (sar%L3,%1,%3), xops);\t/* shift by 32 */\n \n       if (INTVAL (xops[0]) > 32)\n         {\n-\t  xops[0] = gen_rtx (CONST_INT, VOIDmode, INTVAL (xops[0]) - 32);\n-\n+\t  xops[0] = GEN_INT (INTVAL (xops[0]) - 32);\n \t  output_asm_insn (AS2 (sar%L2,%0,%2), xops); /* Remaining shift */\n \t}\n     }\n@@ -2500,7 +2523,7 @@\n   output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);\n   output_asm_insn (AS2 (sar%L3,%0,%3), xops);\n \n-  xops[1] = gen_rtx (CONST_INT, VOIDmode, 7);\t/* shift count & 1 */\n+  xops[1] = GEN_INT (7);\t\t\t/* shift count & 1 */\n \n   output_asm_insn (AS2 (shr%B0,%1,%0), xops);\n \n@@ -2597,8 +2620,7 @@\n \n       if (INTVAL (xops[0]) > 32)\n         {\n-\t  xops[0] = gen_rtx (CONST_INT, VOIDmode, INTVAL (xops[0]) - 32);\n-\n+\t  xops[0] = GEN_INT (INTVAL (xops[0]) - 32);\n \t  output_asm_insn (AS2 (shr%L2,%0,%2), xops); /* Remaining shift */\n \t}\n     }\n@@ -2636,7 +2658,7 @@\n   output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);\n   output_asm_insn (AS2 (shr%L3,%0,%3), xops);\n \n-  xops[1] = gen_rtx (CONST_INT, VOIDmode, 7);\t/* shift count & 1 */\n+  xops[1] = GEN_INT (7);\t\t\t/* shift count & 1 */\n \n   output_asm_insn (AS2 (shr%B0,%1,%0), xops);\n \n@@ -2782,11 +2804,9 @@\n   if (GET_CODE (operands[3]) == CONST_INT)\n     {\n       unsigned int mask = (1 << INTVAL (operands[1])) - 1; \n-      operands[1] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t~(mask << INTVAL (operands[2])));\n+      operands[1] = GEN_INT (~(mask << INTVAL (operands[2])));\n       output_asm_insn (AS2 (and%L0,%1,%0), operands);\n-      operands[3] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t     INTVAL (operands[3]) << INTVAL (operands[2]));\n+      operands[3] = GEN_INT (INTVAL (operands[3]) << INTVAL (operands[2]));\n       output_asm_insn (AS2 (or%L0,%3,%0), operands);\n     }\n   else\n@@ -2795,8 +2815,7 @@\n       if (INTVAL (operands[2]))\n \toutput_asm_insn (AS2 (ror%L0,%2,%0), operands);\n       output_asm_insn (AS3 (shrd%L0,%1,%3,%0), operands);\n-      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t     BITS_PER_WORD\n+      operands[2] = GEN_INT (BITS_PER_WORD\n \t\t\t     - INTVAL (operands[1]) - INTVAL (operands[2]));\n       if (INTVAL (operands[2]))\n \toutput_asm_insn (AS2 (ror%L0,%2,%0), operands);\n@@ -2912,6 +2931,69 @@\n ;; don't allow a MEM in the operand predicate without allowing it in the\n ;; constraint.\n \n+;; ??? All bets are off if operand 0 is a volatile MEM reference.\n+\n+(define_insn \"\"\n+  [(set (cc0) (zero_extract (match_operand 0 \"general_operand\" \"rm\")\n+\t\t\t    (match_operand:SI 1 \"const_int_operand\" \"n\")\n+\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n+  \"GET_MODE_CLASS (GET_MODE (operands[0])) == MODE_INT\n+   && GET_MODE_SIZE (GET_MODE (operands[0])) <= 4\n+   && (GET_CODE (operands[0]) != MEM || ! MEM_VOLATILE_P (operands[0]))\"\n+  \"*\n+{\n+  unsigned int mask;\n+\n+  mask = ((1 << INTVAL (operands[1])) - 1) << INTVAL (operands[2]);\n+  operands[1] = GEN_INT (mask);\n+\n+  if (! REG_P (operands[0]) || QI_REG_P (operands[0]))\n+    {\n+      /* We may set the sign bit spuriously.  */\n+\n+      if ((mask & ~0xff) == 0)\n+        {\n+\t  cc_status.flags |= CC_NOT_NEGATIVE;\n+\t  return AS2 (test%B0,%1,%b0);\n+\t}\n+\n+      if ((mask & ~0xff00) == 0)\n+        {\n+\t  cc_status.flags |= CC_NOT_NEGATIVE;\n+\t  operands[1] = GEN_INT (mask >> 8);\n+\n+\t  if (QI_REG_P (operands[0]))\n+\t    return AS2 (test%B0,%1,%h0);\n+\t  else\n+\t    {\n+\t      operands[0] = adj_offsettable_operand (operands[0], 1);\n+\t      return AS2 (test%B0,%1,%b0);\n+\t    }\n+\t}\n+\n+      if (GET_CODE (operands[0]) == MEM && (mask & ~0xff0000) == 0)\n+        {\n+\t  cc_status.flags |= CC_NOT_NEGATIVE;\n+\t  operands[1] = GEN_INT (mask >> 16);\n+\t  operands[0] = adj_offsettable_operand (operands[0], 2);\n+\t  return AS2 (test%B0,%1,%b0);\n+\t}\n+\n+      if (GET_CODE (operands[0]) == MEM && (mask & ~0xff000000) == 0)\n+        {\n+\t  cc_status.flags |= CC_NOT_NEGATIVE;\n+\t  operands[1] = GEN_INT (mask >> 24);\n+\t  operands[0] = adj_offsettable_operand (operands[0], 3);\n+\t  return AS2 (test%B0,%1,%b0);\n+\t}\n+    }\n+\n+  if (CONSTANT_P (operands[1]) || GET_CODE (operands[0]) == MEM)\n+    return AS2 (test%L0,%1,%0);\n+\n+  return AS2 (test%L1,%0,%1);\n+}\")\n+\n (define_insn \"\"\n   [(set (cc0) (zero_extract (match_operand:SI 0 \"register_operand\" \"r\")\n \t\t\t    (const_int 1)\n@@ -2997,7 +3079,7 @@\n   if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387))\n     return AS1 (sete,%0);\n \n-  OUTPUT_JUMP (\\\"setg %0\\\", \\\"seta %0\\\", 0);\n+  OUTPUT_JUMP (\\\"setg %0\\\", \\\"seta %0\\\", NULL_PTR);\n }\")\n \n (define_expand \"sgtu\"\n@@ -3093,7 +3175,7 @@\n   if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387))\n     return AS1 (setb,%0);\n \n-  OUTPUT_JUMP (\\\"setle %0\\\", \\\"setbe %0\\\", 0);\n+  OUTPUT_JUMP (\\\"setle %0\\\", \\\"setbe %0\\\", NULL_PTR);\n }\")\n \n (define_expand \"sleu\"\n@@ -3201,7 +3283,7 @@\n   if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387))\n     return AS1 (je,%l0);\n \n-  OUTPUT_JUMP (\\\"jg %l0\\\", \\\"ja %l0\\\", 0);\n+  OUTPUT_JUMP (\\\"jg %l0\\\", \\\"ja %l0\\\", NULL_PTR);\n }\")\n \n (define_expand \"bgtu\"\n@@ -3333,7 +3415,7 @@\n   if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387))\n     return AS1 (jb,%l0);\n \n-  OUTPUT_JUMP (\\\"jle %l0\\\", \\\"jbe %l0\\\", 0);\n+  OUTPUT_JUMP (\\\"jle %l0\\\", \\\"jbe %l0\\\", NULL_PTR);\n }\")\n \n (define_expand \"bleu\"\n@@ -3399,7 +3481,7 @@\n   if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387))\n     return AS1 (jne,%l0);\n \n-  OUTPUT_JUMP (\\\"jle %l0\\\", \\\"jbe %l0\\\", 0);\n+  OUTPUT_JUMP (\\\"jle %l0\\\", \\\"jbe %l0\\\", NULL_PTR);\n }\")\n \n (define_insn \"\"\n@@ -3471,7 +3553,7 @@\n   if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387))\n     return AS1 (jae,%l0);\n \n-  OUTPUT_JUMP (\\\"jg %l0\\\", \\\"ja %l0\\\", 0);\n+  OUTPUT_JUMP (\\\"jg %l0\\\", \\\"ja %l0\\\", NULL_PTR);\n }\")\n \n (define_insn \"\"\n@@ -3825,7 +3907,7 @@\n     {\n       if (INTVAL (operands[2]) & ~0x03)\n \t{\n-\t  xops[0] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) >> 2);\n+\t  xops[0] = GEN_INT (INTVAL (operands[2]) >> 2);\n \t  xops[1] = operands[4];\n \n \t  output_asm_insn (AS2 (mov%L1,%0,%1), xops);"}]}