{"sha": "de91486c745d5ff6aff491cb9bd1a78875bf090c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU5MTQ4NmM3NDVkNWZmNmFmZjQ5MWNiOWJkMWE3ODg3NWJmMDkwYw==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2017-01-07T17:26:58Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2017-01-07T17:26:58Z"}, "message": "re PR fortran/78781 ([Coarray] ICE in gfc_deallocate_scalar_with_status, at fortran/trans.c:1588)\n\ngcc/fortran/ChangeLog:\n\n2017-01-07  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\tPR fortran/78781\n\tPR fortran/78935\n\t* expr.c (gfc_check_pointer_assign): Return the same error message for\n\trewritten coarray pointer assignments like for plain ones.\n\t* gfortran.h: Change prototype.\n\t* primary.c (caf_variable_attr): Set attributes used ones only only\n\tones.  Add setting of pointer_comp attribute.\n\t(gfc_caf_attr): Add setting of pointer_comp attribute.\n\t* trans-array.c (gfc_array_allocate): Add flag that the component to\n\tallocate is not an ultimate coarray component.  Add allocation of\n\tpointer arrays.\n\t(structure_alloc_comps): Extend nullify to treat pointer components in\n\tcoarrays correctly.  Restructure nullify to remove redundant code.\n\t(gfc_nullify_alloc_comp): Allow setting caf_mode flags.\n\t* trans-array.h: Change prototype of gfc_nullify_alloc_comp ().\n\t* trans-decl.c (generate_coarray_sym_init): Call nullify_alloc_comp for\n\tderived type coarrays with pointer components.\n\t* trans-expr.c (gfc_trans_structure_assign): Also treat pointer\n\tcomponents.\n\t(trans_caf_token_assign): Handle assignment of token of scalar pointer\n\tcomponents.\n\t(gfc_trans_pointer_assignment): Call above routine.\n\t* trans-intrinsic.c (conv_expr_ref_to_caf_ref): Add treating pointer\n\tcomponents.\n\t(gfc_conv_intrinsic_caf_get): Likewise.\n\t(conv_caf_send): Likewise.\n\t* trans-stmt.c (gfc_trans_allocate): After allocating a derived type in\n\ta coarray pre-register the tokens.\n\t(gfc_trans_deallocate): Simply determining the coarray type (scalar or\n\tarray) and deregistering it correctly.\n\t* trans-types.c (gfc_typenode_for_spec): Replace in_coarray flag by the\n\tactual codim to allow lookup of array types in the cache.\n\t(gfc_build_array_type): Likewise.\n\t(gfc_get_array_descriptor_base): Likewise.\n\t(gfc_get_array_type_bounds): Likewise.\n\t(gfc_get_derived_type): Likewise.\n\t* trans-types.h: Likewise.\n\t* trans.c (gfc_deallocate_with_status): Enable deregistering of all kind\n\tof coarray components.\n\t(gfc_deallocate_scalar_with_status): Use free() in fcoarray_single mode\n\tinstead of caf_deregister.\n\nlibgfortran/ChangeLog:\n\n2017-01-07  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\tPR fortran/78781\n\tPR fortran/78935\n\t* caf/single.c (send_by_ref): Fix addressing of non-allocatable scalar\n\tdestination components.\n\ngcc/testsuite/ChangeLog:\n\n2017-01-07  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* gfortran.dg/coarray/ptr_comp_1.f08: New test.\n\t* gfortran.dg/coarray/ptr_comp_2.f08: New test.\n\t* gfortran.dg/coarray/ptr_comp_3.f08: New test.\n\t* gfortran.dg/coarray/ptr_comp_4.f08: New test.\n\t* gfortran.dg/coarray_ptr_comp_1.f08: New test.\n\t* gfortran.dg/coarray_ptr_comp_2.f08: New test.\n\t* gfortran.dg/coarray_ptr_comp_3.f08: New test.\n\nFrom-SVN: r244196", "tree": {"sha": "f294640f3f31fa5e09df6b9587e7dd3cbfd62c4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f294640f3f31fa5e09df6b9587e7dd3cbfd62c4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de91486c745d5ff6aff491cb9bd1a78875bf090c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de91486c745d5ff6aff491cb9bd1a78875bf090c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de91486c745d5ff6aff491cb9bd1a78875bf090c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de91486c745d5ff6aff491cb9bd1a78875bf090c/comments", "author": null, "committer": null, "parents": [{"sha": "0fc08a17f0b750eeca8bae85eca0d944e4da130e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fc08a17f0b750eeca8bae85eca0d944e4da130e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fc08a17f0b750eeca8bae85eca0d944e4da130e"}], "stats": {"total": 732, "additions": 626, "deletions": 106}, "files": [{"sha": "f89f9fd9972487caafdf711cd5eee8f71915c6e2", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -1,3 +1,47 @@\n+2017-01-07  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tPR fortran/78781\n+\tPR fortran/78935\n+\t* expr.c (gfc_check_pointer_assign): Return the same error message for\n+\trewritten coarray pointer assignments like for plain ones.\n+\t* gfortran.h: Change prototype.\n+\t* primary.c (caf_variable_attr): Set attributes used ones only only\n+\tones.  Add setting of pointer_comp attribute.\n+\t(gfc_caf_attr): Add setting of pointer_comp attribute.\n+\t* trans-array.c (gfc_array_allocate): Add flag that the component to\n+\tallocate is not an ultimate coarray component.  Add allocation of\n+\tpointer arrays.\n+\t(structure_alloc_comps): Extend nullify to treat pointer components in\n+\tcoarrays correctly.  Restructure nullify to remove redundant code.\n+\t(gfc_nullify_alloc_comp): Allow setting caf_mode flags.\n+\t* trans-array.h: Change prototype of gfc_nullify_alloc_comp ().\n+\t* trans-decl.c (generate_coarray_sym_init): Call nullify_alloc_comp for\n+\tderived type coarrays with pointer components.\n+\t* trans-expr.c (gfc_trans_structure_assign): Also treat pointer\n+\tcomponents.\n+\t(trans_caf_token_assign): Handle assignment of token of scalar pointer\n+\tcomponents.\n+\t(gfc_trans_pointer_assignment): Call above routine.\n+\t* trans-intrinsic.c (conv_expr_ref_to_caf_ref): Add treating pointer\n+\tcomponents.\n+\t(gfc_conv_intrinsic_caf_get): Likewise.\n+\t(conv_caf_send): Likewise.\n+\t* trans-stmt.c (gfc_trans_allocate): After allocating a derived type in\n+\ta coarray pre-register the tokens.\n+\t(gfc_trans_deallocate): Simply determining the coarray type (scalar or\n+\tarray) and deregistering it correctly.\n+\t* trans-types.c (gfc_typenode_for_spec): Replace in_coarray flag by the\n+\tactual codim to allow lookup of array types in the cache.\n+\t(gfc_build_array_type): Likewise.\n+\t(gfc_get_array_descriptor_base): Likewise.\n+\t(gfc_get_array_type_bounds): Likewise.\n+\t(gfc_get_derived_type): Likewise.\n+\t* trans-types.h: Likewise.\n+\t* trans.c (gfc_deallocate_with_status): Enable deregistering of all kind\n+\tof coarray components.\n+\t(gfc_deallocate_scalar_with_status): Use free() in fcoarray_single mode\n+\tinstead of caf_deregister.\n+\n 2017-01-06  Jakub Jelinek  <jakub@redhat.com>\n \n \t* simplify.c (simplify_transformation_to_array): Use"}, {"sha": "7b95d206c538c46ee35513532e062a94cfc4b7a4", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -3708,9 +3708,20 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \n   if (rvalue->expr_type == EXPR_FUNCTION && !attr.pointer)\n     {\n-      gfc_error (\"Target expression in pointer assignment \"\n-\t\t \"at %L must deliver a pointer result\",\n-\t\t &rvalue->where);\n+      /* F2008, C725.  For PURE also C1283.  Sometimes rvalue is a function call\n+\t to caf_get.  Map this to the same error message as below when it is\n+\t still a variable expression.  */\n+      if (rvalue->value.function.isym\n+\t  && rvalue->value.function.isym->id == GFC_ISYM_CAF_GET)\n+\t/* The test above might need to be extend when F08, Note 5.4 has to be\n+\t   interpreted in the way that target and pointer with the same coindex\n+\t   are allowed.  */\n+\tgfc_error (\"Data target at %L shall not have a coindex\",\n+\t\t   &rvalue->where);\n+      else\n+\tgfc_error (\"Target expression in pointer assignment \"\n+\t\t   \"at %L must deliver a pointer result\",\n+\t\t   &rvalue->where);\n       return false;\n     }\n "}, {"sha": "f01a290e28f5087a1cc5ddc8fc397c6b50864176", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -2836,7 +2836,7 @@ int gfc_validate_kind (bt, int, bool);\n int gfc_get_int_kind_from_width_isofortranenv (int size);\n int gfc_get_real_kind_from_width_isofortranenv (int size);\n tree gfc_get_union_type (gfc_symbol *);\n-tree gfc_get_derived_type (gfc_symbol * derived, bool in_coarray = false);\n+tree gfc_get_derived_type (gfc_symbol * derived, int codimen = 0);\n extern int gfc_index_integer_kind;\n extern int gfc_default_integer_kind;\n extern int gfc_max_integer_kind;"}, {"sha": "d62f6bb181873f55f459b097c33b2220aaf74c8d", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -2436,8 +2436,7 @@ gfc_expr_attr (gfc_expr *e)\n static symbol_attribute\n caf_variable_attr (gfc_expr *expr, bool in_allocate, bool *refs_comp)\n {\n-  int dimension, codimension, pointer, allocatable, target, coarray_comp,\n-      alloc_comp;\n+  int dimension, codimension, pointer, allocatable, target, coarray_comp;\n   symbol_attribute attr;\n   gfc_ref *ref;\n   gfc_symbol *sym;\n@@ -2458,16 +2457,19 @@ caf_variable_attr (gfc_expr *expr, bool in_allocate, bool *refs_comp)\n       codimension = CLASS_DATA (sym)->attr.codimension;\n       pointer = CLASS_DATA (sym)->attr.class_pointer;\n       allocatable = CLASS_DATA (sym)->attr.allocatable;\n-      alloc_comp = CLASS_DATA (sym)->ts.u.derived->attr.alloc_comp;\n+      attr.alloc_comp = CLASS_DATA (sym)->ts.u.derived->attr.alloc_comp;\n+      attr.pointer_comp = CLASS_DATA (sym)->ts.u.derived->attr.pointer_comp;\n     }\n   else\n     {\n       dimension = sym->attr.dimension;\n       codimension = sym->attr.codimension;\n       pointer = sym->attr.pointer;\n       allocatable = sym->attr.allocatable;\n-      alloc_comp = sym->ts.type == BT_DERIVED\n+      attr.alloc_comp = sym->ts.type == BT_DERIVED\n \t  ? sym->ts.u.derived->attr.alloc_comp : 0;\n+      attr.pointer_comp = sym->ts.type == BT_DERIVED\n+\t  ? sym->ts.u.derived->attr.pointer_comp : 0;\n     }\n \n   target = coarray_comp = 0;\n@@ -2545,7 +2547,6 @@ caf_variable_attr (gfc_expr *expr, bool in_allocate, bool *refs_comp)\n   attr.target = target;\n   attr.save = sym->attr.save;\n   attr.coarray_comp = coarray_comp;\n-  attr.alloc_comp = alloc_comp;\n \n   return attr;\n }\n@@ -2575,6 +2576,8 @@ gfc_caf_attr (gfc_expr *e, bool in_allocate, bool *refs_comp)\n \t      attr.pointer = CLASS_DATA (sym)->attr.class_pointer;\n \t      attr.allocatable = CLASS_DATA (sym)->attr.allocatable;\n \t      attr.alloc_comp = CLASS_DATA (sym)->ts.u.derived->attr.alloc_comp;\n+\t      attr.pointer_comp = CLASS_DATA (sym)->ts.u.derived\n+\t\t  ->attr.pointer_comp;\n \t    }\n \t}\n       else if (e->symtree)"}, {"sha": "a3aab8e45286ed61c5b1cffadeabcfeb73f4ddf8", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 63, "deletions": 39, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -5469,7 +5469,8 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   gfc_expr **lower;\n   gfc_expr **upper;\n   gfc_ref *ref, *prev_ref = NULL, *coref;\n-  bool allocatable, coarray, dimension, alloc_w_e3_arr_spec = false;\n+  bool allocatable, coarray, dimension, alloc_w_e3_arr_spec = false,\n+      non_ulimate_coarray_ptr_comp;\n \n   ref = expr->ref;\n \n@@ -5483,10 +5484,17 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n     {\n       allocatable = expr->symtree->n.sym->attr.allocatable;\n       dimension = expr->symtree->n.sym->attr.dimension;\n+      non_ulimate_coarray_ptr_comp = false;\n     }\n   else\n     {\n       allocatable = prev_ref->u.c.component->attr.allocatable;\n+      /* Pointer components in coarrayed derived types must be treated\n+\t specially in that they are registered without a check if the are\n+\t already associated.  This does not hold for ultimate coarray\n+\t pointers.  */\n+      non_ulimate_coarray_ptr_comp = (prev_ref->u.c.component->attr.pointer\n+\t      && !prev_ref->u.c.component->attr.codimension);\n       dimension = prev_ref->u.c.component->attr.dimension;\n     }\n \n@@ -5599,20 +5607,27 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   if (POINTER_TYPE_P (TREE_TYPE (se->expr)))\n     se->expr = build_fold_indirect_ref_loc (input_location, se->expr);\n \n-  pointer = gfc_conv_descriptor_data_get (se->expr);\n-  STRIP_NOPS (pointer);\n-\n   if (coarray && flag_coarray == GFC_FCOARRAY_LIB)\n     {\n+      pointer = non_ulimate_coarray_ptr_comp ? se->expr\n+\t\t\t\t      : gfc_conv_descriptor_data_get (se->expr);\n       token = gfc_conv_descriptor_token (se->expr);\n       token = gfc_build_addr_expr (NULL_TREE, token);\n     }\n+  else\n+    pointer = gfc_conv_descriptor_data_get (se->expr);\n+  STRIP_NOPS (pointer);\n \n   /* The allocatable variant takes the old pointer as first argument.  */\n   if (allocatable)\n     gfc_allocate_allocatable (&elseblock, pointer, size, token,\n \t\t\t      status, errmsg, errlen, label_finish, expr,\n \t\t\t      coref != NULL ? coref->u.ar.as->corank : 0);\n+  else if (non_ulimate_coarray_ptr_comp && token)\n+    /* The token is set only for GFC_FCOARRAY_LIB mode.  */\n+    gfc_allocate_using_caf_lib (&elseblock, pointer, size, token, status,\n+\t\t\t\terrmsg, errlen,\n+\t\t\t\tGFC_CAF_COARRAY_ALLOC_ALLOCATE_ONLY);\n   else\n     gfc_allocate_using_malloc (&elseblock, pointer, size, status);\n \n@@ -8411,55 +8426,64 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t  break;\n \n \tcase NULLIFY_ALLOC_COMP:\n-\t  if (c->attr.pointer || c->attr.proc_pointer\n+\t  /* Nullify\n+\t     - allocatable components (regular or in class)\n+\t     - components that have allocatable components\n+\t     - pointer components when in a coarray.\n+\t     Skip everything else especially proc_pointers, which may come\n+\t     coupled with the regular pointer attribute.  */\n+\t  if (c->attr.proc_pointer\n \t      || !(c->attr.allocatable || (c->ts.type == BT_CLASS\n \t\t\t\t\t   && CLASS_DATA (c)->attr.allocatable)\n-\t\t   || cmp_has_alloc_comps))\n+\t\t   || (cmp_has_alloc_comps\n+\t\t       && ((c->ts.type == BT_DERIVED && !c->attr.pointer)\n+\t\t\t   || (c->ts.type == BT_CLASS\n+\t\t\t       && !CLASS_DATA (c)->attr.class_pointer)))\n+\t\t   || (caf_in_coarray (caf_mode) && c->attr.pointer)))\n \t    continue;\n \n-\t  /* Coarrays need the component to be initialized before the api-call\n-\t     is made.  */\n-\t  if (c->attr.allocatable && (c->attr.dimension || c->attr.codimension))\n-\t    {\n-\t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n-\t\t\t\t      decl, cdecl, NULL_TREE);\n-\t      gfc_conv_descriptor_data_set (&fnblock, comp, null_pointer_node);\n-\t      cmp_has_alloc_comps = false;\n-\t    }\n-\t  else if (c->attr.allocatable)\n+\t  /* Process class components first, because they always have the\n+\t     pointer-attribute set which would be caught wrong else.  */\n+\t  if (c->ts.type == BT_CLASS\n+\t      && (CLASS_DATA (c)->attr.allocatable\n+\t\t  || CLASS_DATA (c)->attr.class_pointer))\n \t    {\n-\t      /* Allocatable scalar components.  */\n+\t      /* Allocatable CLASS components.  */\n \t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n \t\t\t\t      decl, cdecl, NULL_TREE);\n-\t      tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n-\t\t\t\t     void_type_node, comp,\n-\t\t\t\t     build_int_cst (TREE_TYPE (comp), 0));\n-\t      gfc_add_expr_to_block (&fnblock, tmp);\n-\t      if (gfc_deferred_strlen (c, &comp))\n+\n+\t      comp = gfc_class_data_get (comp);\n+\t      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (comp)))\n+\t\tgfc_conv_descriptor_data_set (&fnblock, comp,\n+\t\t\t\t\t      null_pointer_node);\n+\t      else\n \t\t{\n-\t\t  comp = fold_build3_loc (input_location, COMPONENT_REF,\n-\t\t\t\t\t  TREE_TYPE (comp),\n-\t\t\t\t\t  decl, comp, NULL_TREE);\n \t\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n-\t\t\t\t\t TREE_TYPE (comp), comp,\n+\t\t\t\t\t void_type_node, comp,\n \t\t\t\t\t build_int_cst (TREE_TYPE (comp), 0));\n \t\t  gfc_add_expr_to_block (&fnblock, tmp);\n \t\t}\n \t      cmp_has_alloc_comps = false;\n \t    }\n-\t  else if (c->ts.type == BT_CLASS && CLASS_DATA (c)->attr.allocatable)\n+\t  /* Coarrays need the component to be nulled before the api-call\n+\t     is made.  */\n+\t  else if (c->attr.pointer || c->attr.allocatable)\n \t    {\n-\t      /* Allocatable CLASS components.  */\n \t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n \t\t\t\t      decl, cdecl, NULL_TREE);\n-\n-\t      comp = gfc_class_data_get (comp);\n-\t      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (comp)))\n-\t\tgfc_conv_descriptor_data_set (&fnblock, comp, null_pointer_node);\n+\t      if (c->attr.dimension || c->attr.codimension)\n+\t\tgfc_conv_descriptor_data_set (&fnblock, comp,\n+\t\t\t\t\t      null_pointer_node);\n \t      else\n+\t\tgfc_add_modify (&fnblock, comp,\n+\t\t\t\tbuild_int_cst (TREE_TYPE (comp), 0));\n+\t      if (gfc_deferred_strlen (c, &comp))\n \t\t{\n+\t\t  comp = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t\t  TREE_TYPE (comp),\n+\t\t\t\t\t  decl, comp, NULL_TREE);\n \t\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n-\t\t\t\t\t void_type_node, comp,\n+\t\t\t\t\t TREE_TYPE (comp), comp,\n \t\t\t\t\t build_int_cst (TREE_TYPE (comp), 0));\n \t\t  gfc_add_expr_to_block (&fnblock, tmp);\n \t\t}\n@@ -8476,6 +8500,9 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t      decl, cdecl, NULL_TREE);\n \t      if (c->attr.dimension || c->attr.codimension)\n \t\t{\n+\t\t  /* Set the dtype, because caf_register needs it.  */\n+\t\t  gfc_add_modify (&fnblock, gfc_conv_descriptor_dtype (comp),\n+\t\t\t\t  gfc_get_dtype (TREE_TYPE (comp)));\n \t\t  tmp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n \t\t\t\t\t decl, cdecl, NULL_TREE);\n \t\t  token = gfc_conv_descriptor_token (tmp);\n@@ -8494,10 +8521,6 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t  gfc_add_block_to_block (&fnblock, &se.pre);\n \t\t}\n \n-\t      /* NULL the member-token before registering it or uninitialized\n-\t\t memory accesses may occur.  */\n-\t      gfc_add_modify (&fnblock, token, fold_convert (TREE_TYPE (token),\n-\t\t\t\t\t\t\t    null_pointer_node));\n \t      gfc_allocate_using_caf_lib (&fnblock, comp, size_zero_node,\n \t\t\t\t\t  gfc_build_addr_expr (NULL_TREE,\n \t\t\t\t\t\t\t       token),\n@@ -8711,11 +8734,12 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n    nullify allocatable components.  */\n \n tree\n-gfc_nullify_alloc_comp (gfc_symbol * der_type, tree decl, int rank)\n+gfc_nullify_alloc_comp (gfc_symbol * der_type, tree decl, int rank,\n+\t\t\tint caf_mode)\n {\n   return structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n \t\t\t\tNULLIFY_ALLOC_COMP,\n-\t\t\t\tGFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY);\n+\t\t\t      GFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY | caf_mode);\n }\n \n "}, {"sha": "d87a9d880717bb9973c05d5c3fbb32b8835761ee", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -49,7 +49,7 @@ tree gfc_duplicate_allocatable_nocopy (tree, tree, tree, int);\n \n bool gfc_caf_is_dealloc_only (int);\n \n-tree gfc_nullify_alloc_comp (gfc_symbol *, tree, int);\n+tree gfc_nullify_alloc_comp (gfc_symbol *, tree, int, int cm = 0);\n \n tree gfc_deallocate_alloc_comp (gfc_symbol *, tree, int, int cm = 0);\n tree gfc_deallocate_alloc_comp_no_caf (gfc_symbol *, tree, int);"}, {"sha": "fffb4928f1ce84158a9b11445ad91d48d1cdce7c", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -5147,6 +5147,13 @@ generate_coarray_sym_init (gfc_symbol *sym)\n       sym->attr.pointer = 0;\n       gfc_add_expr_to_block (&caf_init_block, tmp);\n     }\n+  else if (sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.pointer_comp)\n+    {\n+      tmp = gfc_nullify_alloc_comp (sym->ts.u.derived, decl, sym->as\n+\t\t\t\t    ? sym->as->rank : 0,\n+\t\t\t\t    GFC_STRUCTURE_CAF_MODE_IN_COARRAY);\n+      gfc_add_expr_to_block (&caf_init_block, tmp);\n+    }\n }\n \n "}, {"sha": "caaee6b42daa0d0dc6dd55bcc7aa6f26b27ba010", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -7506,7 +7506,8 @@ gfc_trans_structure_assign (tree dest, gfc_expr * expr, bool init, bool coarray)\n \t Register only allocatable components, that are not coarray'ed\n \t components (%comp[*]).  Only register when the constructor is not the\n \t null-expression.  */\n-      if (coarray && !cm->attr.codimension && cm->attr.allocatable\n+      if (coarray && !cm->attr.codimension\n+\t  && (cm->attr.allocatable || cm->attr.pointer)\n \t  && (!c->expr || c->expr->expr_type == EXPR_NULL))\n \t{\n \t  tree token, desc, size;\n@@ -8121,6 +8122,52 @@ trans_class_vptr_len_assignment (stmtblock_t *block, gfc_expr * le,\n   return lhs_vptr;\n }\n \n+\n+/* Assign tokens for pointer components.  */\n+\n+static void\n+trans_caf_token_assign (gfc_se *lse, gfc_se *rse, gfc_expr *expr1,\n+\t\t\tgfc_expr *expr2)\n+{\n+  symbol_attribute lhs_attr, rhs_attr;\n+  tree tmp, lhs_tok, rhs_tok;\n+  /* Flag to indicated component refs on the rhs.  */\n+  bool rhs_cr;\n+\n+  lhs_attr = gfc_caf_attr (expr1);\n+  if (expr2->expr_type != EXPR_NULL)\n+    {\n+      rhs_attr = gfc_caf_attr (expr2, false, &rhs_cr);\n+      if (lhs_attr.codimension && rhs_attr.codimension)\n+\t{\n+\t  lhs_tok = gfc_get_ultimate_alloc_ptr_comps_caf_token (lse, expr1);\n+\t  lhs_tok = build_fold_indirect_ref (lhs_tok);\n+\n+\t  if (rhs_cr)\n+\t    rhs_tok = gfc_get_ultimate_alloc_ptr_comps_caf_token (rse, expr2);\n+\t  else\n+\t    {\n+\t      tree caf_decl;\n+\t      caf_decl = gfc_get_tree_for_caf_expr (expr2);\n+\t      gfc_get_caf_token_offset (rse, &rhs_tok, NULL, caf_decl,\n+\t\t\t\t\tNULL_TREE, NULL);\n+\t    }\n+\t  tmp = build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t\t    lhs_tok,\n+\t\t\t    fold_convert (TREE_TYPE (lhs_tok), rhs_tok));\n+\t  gfc_prepend_expr_to_block (&lse->post, tmp);\n+\t}\n+    }\n+  else if (lhs_attr.codimension)\n+    {\n+      lhs_tok = gfc_get_ultimate_alloc_ptr_comps_caf_token (lse, expr1);\n+      lhs_tok = build_fold_indirect_ref (lhs_tok);\n+      tmp = build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t\tlhs_tok, null_pointer_node);\n+      gfc_prepend_expr_to_block (&lse->post, tmp);\n+    }\n+}\n+\n /* Indentify class valued proc_pointer assignments.  */\n \n static bool\n@@ -8241,6 +8288,11 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n       gfc_add_modify (&block, lse.expr,\n \t\t      fold_convert (TREE_TYPE (lse.expr), rse.expr));\n \n+      /* Also set the tokens for pointer components in derived typed\n+\t coarrays.  */\n+      if (flag_coarray == GFC_FCOARRAY_LIB)\n+\ttrans_caf_token_assign (&lse, &rse, expr1, expr2);\n+\n       gfc_add_block_to_block (&block, &rse.post);\n       gfc_add_block_to_block (&block, &lse.post);\n     }"}, {"sha": "14781ac48146f9aeafedebb8ee299960db6bcfa7", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -1123,7 +1123,8 @@ conv_expr_ref_to_caf_ref (stmtblock_t *block, gfc_expr *expr)\n   if (expr->symtree)\n     {\n       last_component_ref_tree = expr->symtree->n.sym->backend_decl;\n-      ref_static_array = !expr->symtree->n.sym->attr.allocatable;\n+      ref_static_array = !expr->symtree->n.sym->attr.allocatable\n+\t  && !expr->symtree->n.sym->attr.pointer;\n     }\n \n   /* Prevent uninit-warning.  */\n@@ -1219,7 +1220,8 @@ conv_expr_ref_to_caf_ref (stmtblock_t *block, gfc_expr *expr)\n \t  tmp = fold_build3_loc (input_location, COMPONENT_REF,\n \t\t\t\t TREE_TYPE (field), inner_struct, field,\n \t\t\t\t NULL_TREE);\n-\t  if (ref->u.c.component->attr.allocatable\n+\t  if ((ref->u.c.component->attr.allocatable\n+\t       || ref->u.c.component->attr.pointer)\n \t      && ref->u.c.component->attr.dimension)\n \t    {\n \t      tree arr_desc_token_offset;\n@@ -1243,7 +1245,8 @@ conv_expr_ref_to_caf_ref (stmtblock_t *block, gfc_expr *expr)\n \n \t  /* Remember whether this ref was to a non-allocatable/non-pointer\n \t     component so the next array ref can be tailored correctly.  */\n-\t  ref_static_array = !ref->u.c.component->attr.allocatable;\n+\t  ref_static_array = !ref->u.c.component->attr.allocatable\n+\t      && !ref->u.c.component->attr.pointer;\n \t  last_component_ref_tree = ref_static_array\n \t      ? ref->u.c.component->backend_decl : NULL_TREE;\n \t  break;\n@@ -1627,7 +1630,7 @@ gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind,\n \n   /* Only use the new get_by_ref () where it is necessary.  I.e., when the lhs\n      is reallocatable or the right-hand side has allocatable components.  */\n-  if (caf_attr->alloc_comp || may_realloc)\n+  if (caf_attr->alloc_comp || caf_attr->pointer_comp || may_realloc)\n     {\n       /* Get using caf_get_by_ref.  */\n       caf_reference = conv_expr_ref_to_caf_ref (&se->pre, array_expr);\n@@ -1876,7 +1879,8 @@ conv_caf_send (gfc_code *code) {\n       lhs_se.expr = gfc_conv_scalar_to_descriptor (&lhs_se, lhs_se.expr, attr);\n       lhs_se.expr = gfc_build_addr_expr (NULL_TREE, lhs_se.expr);\n     }\n-  else if (lhs_caf_attr.alloc_comp && lhs_caf_attr.codimension)\n+  else if ((lhs_caf_attr.alloc_comp || lhs_caf_attr.pointer_comp)\n+\t   && lhs_caf_attr.codimension)\n     {\n       lhs_se.want_pointer = 1;\n       gfc_conv_expr_descriptor (&lhs_se, lhs_expr);\n@@ -1930,12 +1934,13 @@ conv_caf_send (gfc_code *code) {\n      temporary and a loop.  */\n   if (!gfc_is_coindexed (lhs_expr)\n       && (!lhs_caf_attr.codimension\n-\t  || !(lhs_expr->rank > 0 && lhs_caf_attr.allocatable)))\n+\t  || !(lhs_expr->rank > 0\n+\t       && (lhs_caf_attr.allocatable || lhs_caf_attr.pointer))))\n     {\n       bool lhs_may_realloc = lhs_expr->rank > 0 && lhs_caf_attr.allocatable;\n       gcc_assert (gfc_is_coindexed (rhs_expr));\n       gfc_init_se (&rhs_se, NULL);\n-      if (lhs_expr->rank == 0 && gfc_expr_attr (lhs_expr).allocatable)\n+      if (lhs_expr->rank == 0 && lhs_caf_attr.allocatable)\n \t{\n \t  gfc_se scal_se;\n \t  gfc_init_se (&scal_se, NULL);\n@@ -1997,7 +2002,8 @@ conv_caf_send (gfc_code *code) {\n       rhs_se.expr = gfc_conv_scalar_to_descriptor (&rhs_se, rhs_se.expr, attr);\n       rhs_se.expr = gfc_build_addr_expr (NULL_TREE, rhs_se.expr);\n     }\n-  else if (rhs_caf_attr.alloc_comp && rhs_caf_attr.codimension)\n+  else if ((rhs_caf_attr.alloc_comp || rhs_caf_attr.pointer_comp)\n+\t   && rhs_caf_attr.codimension)\n     {\n       tree tmp2;\n       rhs_se.want_pointer = 1;\n@@ -2065,7 +2071,7 @@ conv_caf_send (gfc_code *code) {\n \n   if (!gfc_is_coindexed (rhs_expr))\n     {\n-      if (lhs_caf_attr.alloc_comp)\n+      if (lhs_caf_attr.alloc_comp || lhs_caf_attr.pointer_comp)\n \t{\n \t  tree reference, dst_realloc;\n \t  reference = conv_expr_ref_to_caf_ref (&block, lhs_expr);\n@@ -2100,7 +2106,7 @@ conv_caf_send (gfc_code *code) {\n \tcaf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);\n       rhs_image_index = gfc_caf_get_image_index (&block, rhs_expr, caf_decl);\n       tmp = rhs_se.expr;\n-      if (rhs_caf_attr.alloc_comp)\n+      if (rhs_caf_attr.alloc_comp || rhs_caf_attr.pointer_comp)\n \t{\n \t  tmp_stat = gfc_find_stat_co (lhs_expr);\n "}, {"sha": "856008779babb6c82bcdb480758d39d4a21ae067", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -6299,6 +6299,40 @@ gfc_trans_allocate (gfc_code * code)\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n \n+      /* Nullify all pointers in derived type coarrays.  This registers a\n+\t token for them which allows their allocation.  */\n+      if (is_coarray)\n+\t{\n+\t  gfc_symbol *type = NULL;\n+\t  symbol_attribute caf_attr;\n+\t  int rank = 0;\n+\t  if (code->ext.alloc.ts.type == BT_DERIVED\n+\t      && code->ext.alloc.ts.u.derived->attr.pointer_comp)\n+\t    {\n+\t      type = code->ext.alloc.ts.u.derived;\n+\t      rank = type->attr.dimension ? type->as->rank : 0;\n+\t      gfc_clear_attr (&caf_attr);\n+\t    }\n+\t  else if (expr->ts.type == BT_DERIVED\n+\t\t   && expr->ts.u.derived->attr.pointer_comp)\n+\t    {\n+\t      type = expr->ts.u.derived;\n+\t      rank = expr->rank;\n+\t      caf_attr = gfc_caf_attr (expr, true);\n+\t    }\n+\n+\t  /* Initialize the tokens of pointer components in derived type\n+\t     coarrays.  */\n+\t  if (type)\n+\t    {\n+\t      tmp = (caf_attr.codimension && !caf_attr.dimension)\n+\t\t  ? gfc_conv_descriptor_data_get (se.expr) : se.expr;\n+\t      tmp = gfc_nullify_alloc_comp (type, tmp, rank,\n+\t\t\t\t\t    GFC_STRUCTURE_CAF_MODE_IN_COARRAY);\n+\t      gfc_add_expr_to_block (&block, tmp);\n+\t    }\n+\t}\n+\n       gfc_free_expr (expr);\n     } // for-loop\n \n@@ -6443,7 +6477,8 @@ gfc_trans_deallocate (gfc_code *code)\n       se.descriptor_only = 1;\n       gfc_conv_expr (&se, expr);\n \n-      if (flag_coarray == GFC_FCOARRAY_LIB)\n+      if (flag_coarray == GFC_FCOARRAY_LIB\n+\t  || flag_coarray == GFC_FCOARRAY_SINGLE)\n \t{\n \t  bool comp_ref;\n \t  symbol_attribute caf_attr = gfc_caf_attr (expr, false, &comp_ref);\n@@ -6453,15 +6488,15 @@ gfc_trans_deallocate (gfc_code *code)\n \t      is_coarray_array = caf_attr.dimension || !comp_ref\n \t\t  || caf_attr.coarray_comp;\n \n-\t      /* When the expression to deallocate is referencing a\n-\t\t component, then only deallocate it, but do not deregister.  */\n-\t      caf_mode = GFC_STRUCTURE_CAF_MODE_IN_COARRAY\n-\t\t  | (comp_ref && !caf_attr.coarray_comp\n-\t\t     ? GFC_STRUCTURE_CAF_MODE_DEALLOC_ONLY : 0);\n+\t      if (flag_coarray == GFC_FCOARRAY_LIB)\n+\t\t/* When the expression to deallocate is referencing a\n+\t\t   component, then only deallocate it, but do not\n+\t\t   deregister.  */\n+\t\tcaf_mode = GFC_STRUCTURE_CAF_MODE_IN_COARRAY\n+\t\t    | (comp_ref && !caf_attr.coarray_comp\n+\t\t       ? GFC_STRUCTURE_CAF_MODE_DEALLOC_ONLY : 0);\n \t    }\n \t}\n-      else if (flag_coarray == GFC_FCOARRAY_SINGLE)\n-\tis_coarray = is_coarray_array = gfc_caf_attr (expr).codimension;\n \n       if (expr->rank || is_coarray_array)\n \t{"}, {"sha": "156c0dac15d06d66cca415ac0c71f153757bc276", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -1050,7 +1050,7 @@ gfc_get_character_type (int kind, gfc_charlen * cl)\n /* Convert a basic type.  This will be an array for character types.  */\n \n tree\n-gfc_typenode_for_spec (gfc_typespec * spec, bool in_coarray)\n+gfc_typenode_for_spec (gfc_typespec * spec, int codim)\n {\n   tree basetype;\n \n@@ -1103,7 +1103,7 @@ gfc_typenode_for_spec (gfc_typespec * spec, bool in_coarray)\n \n     case BT_DERIVED:\n     case BT_CLASS:\n-      basetype = gfc_get_derived_type (spec->u.derived, in_coarray);\n+      basetype = gfc_get_derived_type (spec->u.derived, codim);\n \n       if (spec->type == BT_CLASS)\n \tGFC_CLASS_TYPE_P (basetype) = 1;\n@@ -1307,18 +1307,18 @@ gfc_is_nodesc_array (gfc_symbol * sym)\n static tree\n gfc_build_array_type (tree type, gfc_array_spec * as,\n \t\t      enum gfc_array_kind akind, bool restricted,\n-\t\t      bool contiguous, bool in_coarray)\n+\t\t      bool contiguous, int codim)\n {\n   tree lbound[GFC_MAX_DIMENSIONS];\n   tree ubound[GFC_MAX_DIMENSIONS];\n   int n, corank;\n \n   /* Assumed-shape arrays do not have codimension information stored in the\n      descriptor.  */\n-  corank = as->corank;\n+  corank = MAX (as->corank, codim);\n   if (as->type == AS_ASSUMED_SHAPE ||\n       (as->type == AS_ASSUMED_RANK && akind == GFC_ARRAY_ALLOCATABLE))\n-    corank = 0;\n+    corank = codim;\n \n   if (as->type == AS_ASSUMED_RANK)\n     for (n = 0; n < GFC_MAX_DIMENSIONS; n++)\n@@ -1356,8 +1356,8 @@ gfc_build_array_type (tree type, gfc_array_spec * as,\n \t\t       : GFC_ARRAY_ASSUMED_RANK;\n   return gfc_get_array_type_bounds (type, as->rank == -1\n \t\t\t\t\t  ? GFC_MAX_DIMENSIONS : as->rank,\n-\t\t\t\t    corank, lbound,\n-\t\t\t\t    ubound, 0, akind, restricted, in_coarray);\n+\t\t\t\t    corank, lbound, ubound, 0, akind,\n+\t\t\t\t    restricted);\n }\n \f\n /* Returns the struct descriptor_dimension type.  */\n@@ -1719,8 +1719,7 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed,\n /* Return or create the base type for an array descriptor.  */\n \n static tree\n-gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted,\n-\t\t\t       enum gfc_array_kind akind, bool in_coarray)\n+gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted)\n {\n   tree fat_type, decl, arraytype, *chain = NULL;\n   char name[16 + 2*GFC_RANK_DIGITS + 1 + 1];\n@@ -1782,8 +1781,7 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted,\n       TREE_NO_WARNING (decl) = 1;\n     }\n \n-  if (flag_coarray == GFC_FCOARRAY_LIB && (codimen || in_coarray)\n-      && akind == GFC_ARRAY_ALLOCATABLE)\n+  if (flag_coarray == GFC_FCOARRAY_LIB && codimen)\n     {\n       decl = gfc_add_field_to_struct_1 (fat_type,\n \t\t\t\t\tget_identifier (\"token\"),\n@@ -1795,8 +1793,7 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted,\n   gfc_finish_type (fat_type);\n   TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (fat_type)) = 1;\n \n-  if (flag_coarray == GFC_FCOARRAY_LIB && codimen\n-      && akind == GFC_ARRAY_ALLOCATABLE)\n+  if (flag_coarray == GFC_FCOARRAY_LIB && codimen)\n     gfc_array_descriptor_base_caf[idx] = fat_type;\n   else\n     gfc_array_descriptor_base[idx] = fat_type;\n@@ -1810,21 +1807,18 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted,\n tree\n gfc_get_array_type_bounds (tree etype, int dimen, int codimen, tree * lbound,\n \t\t\t   tree * ubound, int packed,\n-\t\t\t   enum gfc_array_kind akind, bool restricted,\n-\t\t\t   bool in_coarray)\n+\t\t\t   enum gfc_array_kind akind, bool restricted)\n {\n   char name[8 + 2*GFC_RANK_DIGITS + 1 + GFC_MAX_SYMBOL_LEN];\n   tree fat_type, base_type, arraytype, lower, upper, stride, tmp, rtype;\n   const char *type_name;\n   int n;\n \n-  base_type = gfc_get_array_descriptor_base (dimen, codimen, restricted, akind,\n-\t\t\t\t\t     in_coarray);\n+  base_type = gfc_get_array_descriptor_base (dimen, codimen, restricted);\n   fat_type = build_distinct_type_copy (base_type);\n   /* Make sure that nontarget and target array type have the same canonical\n      type (and same stub decl for debug info).  */\n-  base_type = gfc_get_array_descriptor_base (dimen, codimen, false, akind,\n-\t\t\t\t\t     in_coarray);\n+  base_type = gfc_get_array_descriptor_base (dimen, codimen, false);\n   TYPE_CANONICAL (fat_type) = base_type;\n   TYPE_STUB_DECL (fat_type) = TYPE_STUB_DECL (base_type);\n \n@@ -2416,7 +2410,7 @@ gfc_get_union_type (gfc_symbol *un)\n    in a parent namespace, this is used.  */\n \n tree\n-gfc_get_derived_type (gfc_symbol * derived, bool in_coarray)\n+gfc_get_derived_type (gfc_symbol * derived, int codimen)\n {\n   tree typenode = NULL, field = NULL, field_type = NULL;\n   tree canonical = NULL_TREE;\n@@ -2568,9 +2562,11 @@ gfc_get_derived_type (gfc_symbol * derived, bool in_coarray)\n       if ((!c->attr.pointer && !c->attr.proc_pointer\n \t  && !same_alloc_type)\n \t  || c->ts.u.derived->backend_decl == NULL)\n-\tc->ts.u.derived->backend_decl = gfc_get_derived_type (c->ts.u.derived,\n-\t\t\t\t\t\t\t      in_coarray\n-\t\t\t\t\t\t\t|| c->attr.codimension);\n+\t{\n+\t  int local_codim = c->attr.codimension ? c->as->corank: codimen;\n+\t  c->ts.u.derived->backend_decl = gfc_get_derived_type (c->ts.u.derived,\n+\t\t\t\t\t\t\t\tlocal_codim);\n+\t}\n \n       if (c->ts.u.derived->attr.is_iso_c)\n         {\n@@ -2629,7 +2625,7 @@ gfc_get_derived_type (gfc_symbol * derived, bool in_coarray)\n \t    c->ts.u.cl->backend_decl\n \t\t\t= build_int_cst (gfc_charlen_type_node, 0);\n \n-\t  field_type = gfc_typenode_for_spec (&c->ts, in_coarray);\n+\t  field_type = gfc_typenode_for_spec (&c->ts, codimen);\n \t}\n \n       /* This returns an array descriptor type.  Initialization may be\n@@ -2650,7 +2646,7 @@ gfc_get_derived_type (gfc_symbol * derived, bool in_coarray)\n \t\t\t\t\t\t !c->attr.target\n \t\t\t\t\t\t && !c->attr.pointer,\n \t\t\t\t\t\t c->attr.contiguous,\n-\t\t\t\t\t\t in_coarray);\n+\t\t\t\t\t\t codimen);\n \t    }\n \t  else\n \t    field_type = gfc_get_nodesc_array_type (field_type, c->as,\n@@ -2697,9 +2693,9 @@ gfc_get_derived_type (gfc_symbol * derived, bool in_coarray)\n \tc->backend_decl = field;\n \n       /* Do not add a caf_token field for classes' data components.  */\n-      if (in_coarray && !c->attr.dimension && !c->attr.codimension\n-\t  && c->attr.allocatable && c->caf_token == NULL_TREE\n-\t  && strcmp (\"_data\", c->name) != 0)\n+      if (codimen && !c->attr.dimension && !c->attr.codimension\n+\t  && (c->attr.allocatable || c->attr.pointer)\n+\t  && c->caf_token == NULL_TREE && strcmp (\"_data\", c->name) != 0)\n \t{\n \t  char caf_name[GFC_MAX_SYMBOL_LEN];\n \t  snprintf (caf_name, GFC_MAX_SYMBOL_LEN, \"_caf_%s\", c->name);"}, {"sha": "2974e4513049288cf8242a7b48dcffe7fea1ac9d", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -70,7 +70,7 @@ tree gfc_get_character_type_len (int, tree);\n tree gfc_get_character_type_len_for_eltype (tree, tree);\n \n tree gfc_sym_type (gfc_symbol *);\n-tree gfc_typenode_for_spec (gfc_typespec *, bool in_coarray = false);\n+tree gfc_typenode_for_spec (gfc_typespec *, int c = 0);\n int gfc_copy_dt_decls_ifequal (gfc_symbol *, gfc_symbol *, bool);\n \n tree gfc_get_function_type (gfc_symbol *);\n@@ -81,8 +81,7 @@ tree gfc_build_uint_type (int);\n \n tree gfc_get_element_type (tree);\n tree gfc_get_array_type_bounds (tree, int, int, tree *, tree *, int,\n-\t\t\t\tenum gfc_array_kind, bool,\n-\t\t\t\tbool in_coarray = false);\n+\t\t\t\tenum gfc_array_kind, bool);\n tree gfc_get_nodesc_array_type (tree, gfc_array_spec *, gfc_packed, bool);\n \n /* Add a field of given name and type to a UNION_TYPE or RECORD_TYPE.  */"}, {"sha": "82ed19ac2832aaea8811d08eb450aaff57b33ac7", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -1302,8 +1302,7 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n \t      pointer = gfc_conv_descriptor_data_get (caf_decl);\n \t      caf_type = TREE_TYPE (caf_decl);\n \t      STRIP_NOPS (pointer);\n-\t      if (GFC_DESCRIPTOR_TYPE_P (caf_type)\n-\t\t  && GFC_TYPE_ARRAY_AKIND (caf_type) == GFC_ARRAY_ALLOCATABLE)\n+\t      if (GFC_DESCRIPTOR_TYPE_P (caf_type))\n \t\ttoken = gfc_conv_descriptor_token (caf_decl);\n \t      else if (DECL_LANG_SPECIFIC (caf_decl)\n \t\t       && GFC_DECL_TOKEN (caf_decl) != NULL_TREE)\n@@ -1552,7 +1551,7 @@ gfc_deallocate_scalar_with_status (tree pointer, tree status, tree label_finish,\n       gfc_add_expr_to_block (&non_null, tmp);\n     }\n \n-  if (!coarray)\n+  if (!coarray || flag_coarray == GFC_FCOARRAY_SINGLE)\n     {\n       tmp = build_call_expr_loc (input_location,\n \t\t\t\t builtin_decl_explicit (BUILT_IN_FREE), 1,"}, {"sha": "0d5aa52cc0add5f35ae808c639577e22eb548b3e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -1,3 +1,13 @@\n+2017-01-07  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* gfortran.dg/coarray/ptr_comp_1.f08: New test.\n+\t* gfortran.dg/coarray/ptr_comp_2.f08: New test.\n+\t* gfortran.dg/coarray/ptr_comp_3.f08: New test.\n+\t* gfortran.dg/coarray/ptr_comp_4.f08: New test.\n+\t* gfortran.dg/coarray_ptr_comp_1.f08: New test.\n+\t* gfortran.dg/coarray_ptr_comp_2.f08: New test.\n+\t* gfortran.dg/coarray_ptr_comp_3.f08: New test.\n+\n 2017-01-06  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n \t* gcc.dg/memcmp-1.c: New.\n \t* gcc.dg/strncmp-1.c: New."}, {"sha": "fe70e63c32f034e3a1291c14cd010cf0d96ec44e", "filename": "gcc/testsuite/gfortran.dg/coarray/ptr_comp_1.f08", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fptr_comp_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fptr_comp_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fptr_comp_1.f08?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do run }\n+\n+program alloc_comp\n+   type t\n+      integer, pointer :: z\n+   end type\n+   type(t), save :: obj[*]\n+   integer, allocatable, target :: i[:]\n+\n+   if (associated(obj%z)) error stop \"'z' should not be associated yet.\"\n+   allocate (obj%z)\n+   call f(obj)\n+   if (associated(obj%z)) error stop \"'z' should not be associated anymore.\"\n+\n+   allocate(i[*], SOURCE=42)\n+   obj%z => i\n+   if (.not. allocated(i)) error stop \"'i' no longer allocated.\"\n+   i = 15\n+   if (obj%z /= 15) error stop \"'obj%z' is deep copy and not pointer.\"\n+\n+   nullify (obj%z)\n+   if (.not. allocated(i)) error stop \"'i' should still be allocated.\"\n+   if (associated(obj%z)) error stop \"'obj%z' should not be associated anymore.\"\n+\n+   obj%z => i\n+   call f(obj)\n+   ! One can not say anything about i here. The memory should be deallocated, but\n+   ! the pointer in i is still set.\n+   if (associated(obj%z)) error stop \"'obj%z' should not be associated anymore.\"\n+contains\n+   subroutine f(x)\n+      type(t) :: x[*]\n+      if ( associated(x%z) ) deallocate(x%z)\n+   end subroutine\n+end program\n+"}, {"sha": "91977ff1d35ec4acab9c35349943b8f39e63c519", "filename": "gcc/testsuite/gfortran.dg/coarray/ptr_comp_2.f08", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fptr_comp_2.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fptr_comp_2.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fptr_comp_2.f08?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do run }\n+\n+program ptr_comp \n+   type t\n+      integer, pointer :: z(:)\n+   end type\n+   type(t), save :: obj[*]\n+   integer, allocatable, target :: i(:)[:]\n+\n+   if (associated(obj%z)) error stop \"'z' should not be associated yet.\"\n+   allocate (obj%z(5))\n+   call f(obj)\n+   if (associated(obj%z)) error stop \"'z' should not be associated anymore.\"\n+\n+   allocate(i(7)[*], SOURCE=42)\n+   obj%z => i\n+   if (.not. allocated(i)) error stop \"'i' no longer allocated.\"\n+   i = 15\n+   if (any(obj%z(:) /= 15)) error stop \"'obj%z' is deep copy and not pointer.\"\n+\n+   nullify (obj%z)\n+   if (.not. allocated(i)) error stop \"'i' should still be allocated.\"\n+   if (associated(obj%z)) error stop \"'obj%z' should not be associated anymore.\"\n+\n+   obj%z => i\n+   call f(obj)\n+   ! One can not say anything about i here. The memory should be deallocated, but\n+   ! the pointer in i is still set.\n+   if (associated(obj%z)) error stop \"'obj%z' should not be associated anymore.\"\n+contains\n+   subroutine f(x)\n+      type(t) :: x[*]\n+      if ( associated(x%z) ) deallocate(x%z)\n+   end subroutine\n+end program\n+"}, {"sha": "ad7137f009eda80fe0d8d8e60e0f5e09e39ec932", "filename": "gcc/testsuite/gfortran.dg/coarray/ptr_comp_3.f08", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fptr_comp_3.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fptr_comp_3.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fptr_comp_3.f08?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+\n+! Contributed by Damian Rouson\n+! Same like coarray/alloc_comp_4\n+\n+program main\n+\n+  implicit none\n+\n+  type mytype\n+    integer, pointer :: indices(:)\n+  end type\n+\n+  type(mytype), save :: object[*]\n+  integer :: me\n+\n+  me=this_image()\n+  allocate(object%indices(me))\n+  object%indices = 42\n+\n+  if ( any( object[me]%indices(:) /= 42 ) ) call abort()\n+end program"}, {"sha": "e6189213122220b6ec4eaae272fda5f77bf4a30a", "filename": "gcc/testsuite/gfortran.dg/coarray/ptr_comp_4.f08", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fptr_comp_4.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fptr_comp_4.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fptr_comp_4.f08?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do run }\n+\n+! Same like coarray/alloc_comp_5 but for pointer comp.\n+\n+program Jac\n+  type Domain\n+    integer :: n=64\n+    integer, pointer :: endsi(:)\n+  end type\n+  type(Domain),allocatable :: D[:,:,:]\n+\n+  allocate(D[2,2,*])\n+  allocate(D%endsi(2), source = 0)\n+  ! No caf-runtime call needed her.\n+  D%endsi(2) = D%n\n+  if (any(D%endsi /= [ 0, 64])) error stop\n+  deallocate(D%endsi)\n+  deallocate(D)\n+end program\n+"}, {"sha": "f0b51d5ead19e957245fcd4786db5c715b84167f", "filename": "gcc/testsuite/gfortran.dg/coarray_ptr_comp_1.f08", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_ptr_comp_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_ptr_comp_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_ptr_comp_1.f08?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -0,0 +1,99 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=lib -lcaf_single\" }\n+! { dg-additional-options \"-latomic\" { target libatomic_available } }\n+\n+! Contributed by Damian Rouson\n+! Check the new _caf_get_by_ref()-routine.\n+! Same like coarray_alloc_comp_1 but for pointers.\n+\n+program main\n+\n+implicit none\n+\n+type :: mytype\n+  integer :: i\n+  integer, pointer :: indices(:)\n+  real, dimension(2,5,3) :: volume\n+  integer, pointer :: scalar\n+  integer :: j\n+  integer, pointer :: matrix(:,:)\n+  real, pointer :: dynvol(:,:,:)\n+end type\n+\n+type arrtype\n+  type(mytype), pointer :: vec(:)\n+  type(mytype), pointer :: mat(:,:)\n+end type arrtype\n+\n+type(mytype), save :: object[*]\n+type(arrtype), save :: bar[*]\n+integer :: i,j,me,neighbor\n+integer :: idx(5)\n+real, allocatable :: volume(:,:,:), vol2(:,:,:)\n+real, target :: vol_static(2,5,3)\n+\n+idx = (/ 1,2,1,7,5 /)\n+\n+me=this_image()\n+allocate(object%indices, source=[(i,i=1,5)])\n+allocate(object%scalar, object%matrix(10,7))\n+object%i = 37\n+object%scalar = 42\n+vol_static = reshape([(i, i=1, 2*5*3)], [2, 5, 3])\n+object%volume = vol_static\n+object%matrix = reshape([(i, i=1, 70)], [10, 7])\n+object%dynvol => vol_static\n+sync all\n+neighbor = merge(1,neighbor,me==num_images())\n+if (object[neighbor]%scalar /= 42) call abort()\n+if (object[neighbor]%indices(4) /= 4) call abort()\n+if (object[neighbor]%matrix(3,6) /= 53) call abort()\n+if (any( object[neighbor]%indices(:) /= [1,2,3,4,5] )) call abort()\n+if (any( object[neighbor]%matrix(:,:) /= reshape([(i, i=1, 70)], [10, 7]))) call abort()\n+if (any( object[neighbor]%matrix(3,:) /= [(i * 10 + 3, i=0, 6)])) call abort()\n+if (any( object[neighbor]%matrix(:,2) /= [(i + 10, i=1, 10)])) call abort()\n+if (any( object[neighbor]%matrix(idx,2) /= [11, 12, 11, 17, 15])) call abort()\n+if (any( object[neighbor]%matrix(3,idx) /= [3, 13, 3, 63, 43])) call abort()\n+if (any( object[neighbor]%matrix(2:8:4, 5:1:-1) /= reshape([42, 46, 32, 36, 22, 26, 12, 16, 2, 6], [2,5]))) call abort()\n+if (any( object[neighbor]%matrix(:8:4, 2::2) /= reshape([11, 15, 31, 35, 51, 55], [2,3]))) call abort()\n+if (any( object[neighbor]%volume /= vol_static)) call abort()\n+if (any( object[neighbor]%dynvol /= vol_static)) call abort()\n+if (any( object[neighbor]%volume(:, 2:4, :) /= vol_static(:, 2:4, :))) call abort()\n+if (any( object[neighbor]%dynvol(:, 2:4, :) /= vol_static(:, 2:4, :))) call abort()\n+\n+vol2 = vol_static(:, ::2, :)\n+if (any( object[neighbor]%volume(:, ::2, :) /= vol2)) call abort()\n+if (any( object[neighbor]%dynvol(:, ::2, :) /= vol2)) call abort()\n+\n+allocate(bar%vec(-2:2))\n+\n+bar%vec(1)%volume = vol_static\n+if (any(bar[neighbor]%vec(1)%volume /= vol_static)) call abort()\n+\n+i = 15\n+allocate(bar%vec(1)%scalar, bar%vec(0)%scalar)\n+bar%vec(1)%scalar = i\n+if (.not. associated(bar%vec(1)%scalar)) call abort()\n+if (bar[neighbor]%vec(1)%scalar /= 15) call abort()\n+\n+bar%vec(0)%scalar = 27\n+if (.not. associated(bar%vec(0)%scalar)) call abort()\n+if (bar[neighbor]%vec(0)%scalar /= 27) call abort()\n+\n+allocate(bar%vec(1)%indices(3), bar%vec(2)%indices(5))\n+bar%vec(1)%indices = [ 3, 4, 15 ]\n+bar%vec(2)%indices = 89\n+\n+if (.not. associated(bar%vec(1)%indices)) call abort()\n+if (associated(bar%vec(-2)%indices)) call abort()\n+if (associated(bar%vec(-1)%indices)) call abort()\n+if (associated(bar%vec( 0)%indices)) call abort()\n+if (.not. associated(bar%vec( 2)%indices)) call abort()\n+if (any(bar[me]%vec(2)%indices /= 89)) call abort()\n+\n+if (any (bar[neighbor]%vec(1)%indices /= [ 3,4,15])) call abort()\n+\n+deallocate(bar%vec(2)%indices, bar%vec(1)%indices, bar%vec(1)%scalar, bar%vec(0)%scalar)\n+deallocate(object%indices, object%scalar, object%matrix)\n+deallocate(bar%vec)\n+end program"}, {"sha": "d930a82f8a30069a4043950ed206e7e985d9576e", "filename": "gcc/testsuite/gfortran.dg/coarray_ptr_comp_2.f08", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_ptr_comp_2.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_ptr_comp_2.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_ptr_comp_2.f08?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -0,0 +1,88 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=lib -lcaf_single\" }\n+! { dg-additional-options \"-latomic\" { target libatomic_available } }\n+\n+! Contributed by Damian Rouson\n+! Check the new _caf_send_by_ref()-routine.\n+! Same as coarray_alloc_comp_2 but for pointers.\n+\n+program main\n+\n+implicit none\n+\n+type :: mytype\n+  integer :: i\n+  integer, pointer :: indices(:)\n+  real, dimension(2,5,3) :: volume\n+  integer, pointer :: scalar\n+  integer :: j\n+  integer, pointer :: matrix(:,:)\n+  real, pointer :: dynvol(:,:,:)\n+end type\n+\n+type arrtype\n+  type(mytype), pointer :: vec(:)\n+  type(mytype), pointer :: mat(:,:)\n+end type arrtype\n+\n+type(mytype), save :: object[*]\n+type(arrtype), save :: bar[*]\n+integer :: i,j,me,neighbor\n+integer :: idx(5)\n+real, allocatable :: volume(:,:,:), vol2(:,:,:)\n+real :: vol_static(2,5,3)\n+\n+idx = (/ 1,2,1,7,5 /)\n+\n+me=this_image()\n+neighbor = merge(1,me+1,me==num_images())\n+allocate(object%indices(5), object%scalar, object%matrix(10,7), object%dynvol(2,5,3))\n+object[neighbor]%indices=[(i,i=1,5)]\n+object[neighbor]%i = 37\n+object[neighbor]%scalar = 42\n+vol_static = reshape([(i, i=1, 2*5*3)], [2, 5, 3])\n+object[neighbor]%volume = vol_static\n+object[neighbor]%matrix = reshape([(i, i=1, 70)], [10, 7])\n+object[neighbor]%dynvol = vol_static\n+sync all\n+if (object%scalar /= 42) call abort()\n+if (any( object%indices /= [1,2,3,4,5] )) call abort()\n+if (any( object%matrix /= reshape([(i, i=1, 70)], [10, 7]))) call abort()\n+if (any( object%volume /= vol_static)) call abort()\n+if (any( object%dynvol /= vol_static)) call abort()\n+\n+vol2 = vol_static\n+vol2(:, ::2, :) = 42\n+object[neighbor]%volume(:, ::2, :) = 42\n+object[neighbor]%dynvol(:, ::2, :) = 42\n+if (any( object%volume /= vol2)) call abort()\n+if (any( object%dynvol /= vol2)) call abort()\n+\n+allocate(bar%vec(-2:2))\n+\n+bar[neighbor]%vec(1)%volume = vol_static\n+if (any(bar%vec(1)%volume /= vol_static)) call abort()\n+\n+allocate(bar%vec(1)%scalar, bar%vec(0)%scalar, bar%vec(1)%indices(3))\n+i = 15\n+bar[neighbor]%vec(1)%scalar = i\n+if (.not. associated(bar%vec(1)%scalar)) call abort()\n+if (bar%vec(1)%scalar /= 15) call abort()\n+\n+bar[neighbor]%vec(0)%scalar = 27\n+if (.not. associated(bar%vec(0)%scalar)) call abort()\n+if (bar%vec(0)%scalar /= 27) call abort()\n+\n+bar[neighbor]%vec(1)%indices = [ 3, 4, 15 ]\n+allocate(bar%vec(2)%indices(5))\n+bar[neighbor]%vec(2)%indices = 89\n+\n+if (.not. associated(bar%vec(1)%indices)) call abort()\n+if (associated(bar%vec(-2)%indices)) call abort()\n+if (associated(bar%vec(-1)%indices)) call abort()\n+if (associated(bar%vec( 0)%indices)) call abort()\n+if (.not. associated(bar%vec( 2)%indices)) call abort()\n+if (any(bar%vec(2)%indices /= 89)) call abort()\n+\n+if (any (bar%vec(1)%indices /= [ 3,4,15])) call abort()\n+end program"}, {"sha": "efdfb367040aae90807d329764ca7dc07994fbef", "filename": "gcc/testsuite/gfortran.dg/coarray_ptr_comp_3.f08", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_ptr_comp_3.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_ptr_comp_3.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_ptr_comp_3.f08?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=lib\" }\n+\n+program ptr_comp \n+   type t\n+      integer, pointer :: z(:)\n+   end type\n+   type(t), save :: obj[*]\n+   integer, allocatable, target :: i(:)[:]\n+\n+   obj%z => i(:)[4] ! { dg-error \"shall not have a coindex\" }\n+end program\n+"}, {"sha": "f07dff1b8d68561a257842c7ddd0d17a18c36460", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -1,3 +1,10 @@\n+2017-01-07  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tPR fortran/78781\n+\tPR fortran/78935\n+\t* caf/single.c (send_by_ref): Fix addressing of non-allocatable scalar\n+\tdestination components.\n+\n 2017-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "cf78a1a48fdb656e2961f06db524a565b4869a23", "filename": "libgfortran/caf/single.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de91486c745d5ff6aff491cb9bd1a78875bf090c/libgfortran%2Fcaf%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de91486c745d5ff6aff491cb9bd1a78875bf090c/libgfortran%2Fcaf%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fsingle.c?ref=de91486c745d5ff6aff491cb9bd1a78875bf090c", "patch": "@@ -1953,11 +1953,24 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t\t}\n \t      else\n \t\t{\n-\t\t  ds = GFC_DESCRIPTOR_DATA (dst);\n-\t\t  dst_type = GFC_DESCRIPTOR_TYPE (dst);\n+\t\t  single_token = *(caf_single_token_t *)\n+\t\t\t\t\t       (ds + ref->u.c.caf_token_offset);\n+\t\t  dst = single_token->desc;\n+\t\t  if (dst)\n+\t\t    {\n+\t\t      ds = GFC_DESCRIPTOR_DATA (dst);\n+\t\t      dst_type = GFC_DESCRIPTOR_TYPE (dst);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* When no destination descriptor is present, assume that\n+\t\t\t source and dest type are identical.  */\n+\t\t      dst_type = GFC_DESCRIPTOR_TYPE (src);\n+\t\t      ds = *(void **)(ds + ref->u.c.offset);\n+\t\t    }\n \t\t}\n \t      copy_data (ds, sr, dst_type, GFC_DESCRIPTOR_TYPE (src),\n-\t\t  dst_kind, src_kind, ref->item_size, src_size, 1, stat);\n+\t\t\t dst_kind, src_kind, ref->item_size, src_size, 1, stat);\n \t    }\n \t  else\n \t    copy_data (ds + ref->u.c.offset, sr,\n@@ -2055,7 +2068,7 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t  return;\n \t}\n       /* Only when on the left most index switch the data pointer to\n-\t     the array's data pointer.  And only for non-static arrays.  */\n+\t the array's data pointer.  And only for non-static arrays.  */\n       if (dst_dim == 0 && ref->type != CAF_REF_STATIC_ARRAY)\n \tds = GFC_DESCRIPTOR_DATA (dst);\n       switch (ref->u.a.mode[dst_dim])"}]}