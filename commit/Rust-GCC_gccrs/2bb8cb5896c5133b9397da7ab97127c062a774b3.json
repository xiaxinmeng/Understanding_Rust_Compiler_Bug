{"sha": "2bb8cb5896c5133b9397da7ab97127c062a774b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJiOGNiNTg5NmM1MTMzYjkzOTdkYTdhYjk3MTI3YzA2MmE3NzRiMw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2015-06-17T18:53:03Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2015-06-17T18:53:03Z"}, "message": "function.h (struct rtl_data): Remove struct and accessor macros.\n\n2015-06-17  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* function.h (struct rtl_data): Remove struct and accessor macros.\n\t* emit-rtl.h (struct rtl_data): Relocate to here.\n\t* Makefile.in (GTFILES): Add emit-rtl.h.\n\t* df-core.c: Include emit-rtl.h.\n\t* genattrtab.c: Likewise.\n\t* genconditions.c: Likewise.\n\t* genpreds.c: Likewise.\n\t* genrecog.c: Likewise.\n\t* regcprop.c: Likewise.\n\t* resource.c: Likewise.\n\t* sched-rgn.c: Likewise.\n\t* config/aarch64/cortex-a57-fma-steering.c: Likewise.\n\t* config/i386/winnt.c: Likewise.\n\nFrom-SVN: r224573", "tree": {"sha": "ec5e8298fd9f24f891d654baf86e6add87b61000", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec5e8298fd9f24f891d654baf86e6add87b61000"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bb8cb5896c5133b9397da7ab97127c062a774b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bb8cb5896c5133b9397da7ab97127c062a774b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bb8cb5896c5133b9397da7ab97127c062a774b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bb8cb5896c5133b9397da7ab97127c062a774b3/comments", "author": null, "committer": null, "parents": [{"sha": "a1ceb6041e32e5ab4b0c38dc5b52fe9d82948719", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ceb6041e32e5ab4b0c38dc5b52fe9d82948719", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1ceb6041e32e5ab4b0c38dc5b52fe9d82948719"}], "stats": {"total": 547, "additions": 285, "deletions": 262}, "files": [{"sha": "bddcd0f5606e4e6da1668e65361e28c50fa1769f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2bb8cb5896c5133b9397da7ab97127c062a774b3", "patch": "@@ -1,3 +1,19 @@\n+2015-06-17  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* function.h (struct rtl_data): Remove struct and accessor macros.\n+\t* emit-rtl.h (struct rtl_data): Relocate to here.\n+\t* Makefile.in (GTFILES): Add emit-rtl.h.\n+\t* df-core.c: Include emit-rtl.h.\n+\t* genattrtab.c: Likewise.\n+\t* genconditions.c: Likewise.\n+\t* genpreds.c: Likewise.\n+\t* genrecog.c: Likewise.\n+\t* regcprop.c: Likewise.\n+\t* resource.c: Likewise.\n+\t* sched-rgn.c: Likewise.\n+\t* config/aarch64/cortex-a57-fma-steering.c: Likewise.\n+\t* config/i386/winnt.c: Likewise.\n+\n 2015-06-17  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/66429"}, {"sha": "5742694b05055c5b1f2bb45618aa1b1555546c05", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2bb8cb5896c5133b9397da7ab97127c062a774b3", "patch": "@@ -2321,7 +2321,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/dwarf2cfi.c \\\n   $(srcdir)/dwarf2out.c \\\n   $(srcdir)/tree-vect-generic.c \\\n-  $(srcdir)/dojump.c \\\n+  $(srcdir)/dojump.c $(srcdir)/emit-rtl.h \\\n   $(srcdir)/emit-rtl.c $(srcdir)/except.h $(srcdir)/explow.c $(srcdir)/expr.c \\\n   $(srcdir)/expr.h \\\n   $(srcdir)/function.c $(srcdir)/except.c \\"}, {"sha": "648a88c70d4103ca2ea8ba81e0734737a0d0b9ca", "filename": "gcc/config/aarch64/cortex-a57-fma-steering.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fconfig%2Faarch64%2Fcortex-a57-fma-steering.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fconfig%2Faarch64%2Fcortex-a57-fma-steering.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fcortex-a57-fma-steering.c?ref=2bb8cb5896c5133b9397da7ab97127c062a774b3", "patch": "@@ -38,6 +38,7 @@\n #include \"df.h\"\n #include \"target.h\"\n #include \"rtl.h\"\n+#include \"emit-rtl.h\"\n #include \"context.h\"\n #include \"tree-pass.h\"\n #include \"regrename.h\""}, {"sha": "39249879b62f5e68a38b2622d6526dc14bee0be8", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=2bb8cb5896c5133b9397da7ab97127c062a774b3", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"except.h\"\n #include \"predict.h\"\n #include \"function.h\"\n+#include \"emit-rtl.h\"\n #include \"dominance.h\"\n #include \"cfg.h\"\n #include \"cfgrtl.h\""}, {"sha": "68d18497133b6d7173d67f2e05b02113dd69bc7f", "filename": "gcc/df-core.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=2bb8cb5896c5133b9397da7ab97127c062a774b3", "patch": "@@ -398,6 +398,7 @@ are write-only operations.\n #include \"tree-pass.h\"\n #include \"params.h\"\n #include \"cfgloop.h\"\n+#include \"emit-rtl.h\"\n \n static void *df_get_bb_info (struct dataflow *, unsigned int);\n static void df_set_bb_info (struct dataflow *, unsigned int, void *);"}, {"sha": "cccb1acbdcb6515bfc44d0bd8053c436499b364f", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=2bb8cb5896c5133b9397da7ab97127c062a774b3", "patch": "@@ -20,6 +20,264 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_EMIT_RTL_H\n #define GCC_EMIT_RTL_H\n \n+struct temp_slot;\n+typedef struct temp_slot *temp_slot_p;\n+\n+/* Datastructures maintained for currently processed function in RTL form.  */\n+struct GTY(()) rtl_data {\n+  struct expr_status expr;\n+  struct emit_status emit;\n+  struct varasm_status varasm;\n+  struct incoming_args args;\n+  struct function_subsections subsections;\n+  struct rtl_eh eh;\n+\n+  /* For function.c  */\n+\n+  /* # of bytes of outgoing arguments.  If ACCUMULATE_OUTGOING_ARGS is\n+     defined, the needed space is pushed by the prologue.  */\n+  int outgoing_args_size;\n+\n+  /* If nonzero, an RTL expression for the location at which the current\n+     function returns its result.  If the current function returns its\n+     result in a register, current_function_return_rtx will always be\n+     the hard register containing the result.  */\n+  rtx return_rtx;\n+  /* If nonxero, an RTL expression for the lcoation at which the current\n+     function returns bounds for its result.  */\n+  rtx return_bnd;\n+\n+  /* Vector of initial-value pairs.  Each pair consists of a pseudo\n+     register of approprite mode that stores the initial value a hard\n+     register REGNO, and that hard register itself.  */\n+  /* ??? This could be a VEC but there is currently no way to define an\n+\t opaque VEC type.  */\n+  struct initial_value_struct *hard_reg_initial_vals;\n+\n+  /* A variable living at the top of the frame that holds a known value.\n+     Used for detecting stack clobbers.  */\n+  tree stack_protect_guard;\n+\n+  /* List (chain of INSN_LIST) of labels heading the current handlers for\n+     nonlocal gotos.  */\n+  rtx_insn_list *x_nonlocal_goto_handler_labels;\n+\n+  /* Label that will go on function epilogue.\n+     Jumping to this label serves as a \"return\" instruction\n+     on machines which require execution of the epilogue on all returns.  */\n+  rtx_code_label *x_return_label;\n+\n+  /* Label that will go on the end of function epilogue.\n+     Jumping to this label serves as a \"naked return\" instruction\n+     on machines which require execution of the epilogue on all returns.  */\n+  rtx_code_label *x_naked_return_label;\n+\n+  /* List (chain of EXPR_LISTs) of all stack slots in this function.\n+     Made for the sake of unshare_all_rtl.  */\n+  rtx_expr_list *x_stack_slot_list;\n+\n+  /* List of empty areas in the stack frame.  */\n+  struct frame_space *frame_space_list;\n+\n+  /* Place after which to insert the tail_recursion_label if we need one.  */\n+  rtx_note *x_stack_check_probe_note;\n+\n+  /* Location at which to save the argument pointer if it will need to be\n+     referenced.  There are two cases where this is done: if nonlocal gotos\n+     exist, or if vars stored at an offset from the argument pointer will be\n+     needed by inner routines.  */\n+  rtx x_arg_pointer_save_area;\n+\n+  /* Dynamic Realign Argument Pointer used for realigning stack.  */\n+  rtx drap_reg;\n+\n+  /* Offset to end of allocated area of stack frame.\n+     If stack grows down, this is the address of the last stack slot allocated.\n+     If stack grows up, this is the address for the next slot.  */\n+  HOST_WIDE_INT x_frame_offset;\n+\n+  /* Insn after which register parms and SAVE_EXPRs are born, if nonopt.  */\n+  rtx_insn *x_parm_birth_insn;\n+\n+  /* List of all used temporaries allocated, by level.  */\n+  vec<temp_slot_p, va_gc> *x_used_temp_slots;\n+\n+  /* List of available temp slots.  */\n+  struct temp_slot *x_avail_temp_slots;\n+\n+  /* Current nesting level for temporaries.  */\n+  int x_temp_slot_level;\n+\n+  /* The largest alignment needed on the stack, including requirement\n+     for outgoing stack alignment.  */\n+  unsigned int stack_alignment_needed;\n+\n+  /* Preferred alignment of the end of stack frame, which is preferred\n+     to call other functions.  */\n+  unsigned int preferred_stack_boundary;\n+\n+  /* The minimum alignment of parameter stack.  */\n+  unsigned int parm_stack_boundary;\n+\n+  /* The largest alignment of slot allocated on the stack.  */\n+  unsigned int max_used_stack_slot_alignment;\n+\n+  /* The stack alignment estimated before reload, with consideration of\n+     following factors:\n+     1. Alignment of local stack variables (max_used_stack_slot_alignment)\n+     2. Alignment requirement to call other functions\n+        (preferred_stack_boundary)\n+     3. Alignment of non-local stack variables but might be spilled in\n+        local stack.  */\n+  unsigned int stack_alignment_estimated;\n+\n+  /* For reorg.  */\n+\n+  /* Nonzero if function being compiled called builtin_return_addr or\n+     builtin_frame_address with nonzero count.  */\n+  bool accesses_prior_frames;\n+\n+  /* Nonzero if the function calls __builtin_eh_return.  */\n+  bool calls_eh_return;\n+\n+  /* Nonzero if function saves all registers, e.g. if it has a nonlocal\n+     label that can reach the exit block via non-exceptional paths. */\n+  bool saves_all_registers;\n+\n+  /* Nonzero if function being compiled has nonlocal gotos to parent\n+     function.  */\n+  bool has_nonlocal_goto;\n+\n+  /* Nonzero if function being compiled has an asm statement.  */\n+  bool has_asm_statement;\n+\n+  /* This bit is used by the exception handling logic.  It is set if all\n+     calls (if any) are sibling calls.  Such functions do not have to\n+     have EH tables generated, as they cannot throw.  A call to such a\n+     function, however, should be treated as throwing if any of its callees\n+     can throw.  */\n+  bool all_throwers_are_sibcalls;\n+\n+  /* Nonzero if stack limit checking should be enabled in the current\n+     function.  */\n+  bool limit_stack;\n+\n+  /* Nonzero if profiling code should be generated.  */\n+  bool profile;\n+\n+  /* Nonzero if the current function uses the constant pool.  */\n+  bool uses_const_pool;\n+\n+  /* Nonzero if the current function uses pic_offset_table_rtx.  */\n+  bool uses_pic_offset_table;\n+\n+  /* Nonzero if the current function needs an lsda for exception handling.  */\n+  bool uses_eh_lsda;\n+\n+  /* Set when the tail call has been produced.  */\n+  bool tail_call_emit;\n+\n+  /* Nonzero if code to initialize arg_pointer_save_area has been emitted.  */\n+  bool arg_pointer_save_area_init;\n+\n+  /* Nonzero if current function must be given a frame pointer.\n+     Set in reload1.c or lra-eliminations.c if anything is allocated\n+     on the stack there.  */\n+  bool frame_pointer_needed;\n+\n+  /* When set, expand should optimize for speed.  */\n+  bool maybe_hot_insn_p;\n+\n+  /* Nonzero if function stack realignment is needed.  This flag may be\n+     set twice: before and after reload.  It is set before reload wrt\n+     stack alignment estimation before reload.  It will be changed after\n+     reload if by then criteria of stack realignment is different.\n+     The value set after reload is the accurate one and is finalized.  */\n+  bool stack_realign_needed;\n+\n+  /* Nonzero if function stack realignment is tried.  This flag is set\n+     only once before reload.  It affects register elimination.  This\n+     is used to generate DWARF debug info for stack variables.  */\n+  bool stack_realign_tried;\n+\n+  /* Nonzero if function being compiled needs dynamic realigned\n+     argument pointer (drap) if stack needs realigning.  */\n+  bool need_drap;\n+\n+  /* Nonzero if function stack realignment estimation is done, namely\n+     stack_realign_needed flag has been set before reload wrt estimated\n+     stack alignment info.  */\n+  bool stack_realign_processed;\n+\n+  /* Nonzero if function stack realignment has been finalized, namely\n+     stack_realign_needed flag has been set and finalized after reload.  */\n+  bool stack_realign_finalized;\n+\n+  /* True if dbr_schedule has already been called for this function.  */\n+  bool dbr_scheduled_p;\n+\n+  /* True if current function can not throw.  Unlike\n+     TREE_NOTHROW (current_function_decl) it is set even for overwritable\n+     function where currently compiled version of it is nothrow.  */\n+  bool nothrow;\n+\n+  /* True if we performed shrink-wrapping for the current function.  */\n+  bool shrink_wrapped;\n+\n+  /* Nonzero if function being compiled doesn't modify the stack pointer\n+     (ignoring the prologue and epilogue).  This is only valid after\n+     pass_stack_ptr_mod has run.  */\n+  bool sp_is_unchanging;\n+\n+  /* Nonzero if function being compiled doesn't contain any calls\n+     (ignoring the prologue and epilogue).  This is set prior to\n+     local register allocation and is valid for the remaining\n+     compiler passes.  */\n+  bool is_leaf;\n+\n+  /* Nonzero if the function being compiled is a leaf function which only\n+     uses leaf registers.  This is valid after reload (specifically after\n+     sched2) and is useful only if the port defines LEAF_REGISTERS.  */\n+  bool uses_only_leaf_regs;\n+\n+  /* Nonzero if the function being compiled has undergone hot/cold partitioning\n+     (under flag_reorder_blocks_and_partition) and has at least one cold\n+     block.  */\n+  bool has_bb_partition;\n+\n+  /* Nonzero if the function being compiled has completed the bb reordering\n+     pass.  */\n+  bool bb_reorder_complete;\n+\n+  /* Like regs_ever_live, but 1 if a reg is set or clobbered from an\n+     asm.  Unlike regs_ever_live, elements of this array corresponding\n+     to eliminable regs (like the frame pointer) are set if an asm\n+     sets them.  */\n+  HARD_REG_SET asm_clobbers;\n+};\n+\n+#define return_label (crtl->x_return_label)\n+#define naked_return_label (crtl->x_naked_return_label)\n+#define stack_slot_list (crtl->x_stack_slot_list)\n+#define parm_birth_insn (crtl->x_parm_birth_insn)\n+#define frame_offset (crtl->x_frame_offset)\n+#define stack_check_probe_note (crtl->x_stack_check_probe_note)\n+#define arg_pointer_save_area (crtl->x_arg_pointer_save_area)\n+#define used_temp_slots (crtl->x_used_temp_slots)\n+#define avail_temp_slots (crtl->x_avail_temp_slots)\n+#define temp_slot_level (crtl->x_temp_slot_level)\n+#define nonlocal_goto_handler_labels (crtl->x_nonlocal_goto_handler_labels)\n+#define frame_pointer_needed (crtl->frame_pointer_needed)\n+#define stack_realign_fp (crtl->stack_realign_needed && !crtl->need_drap)\n+#define stack_realign_drap (crtl->stack_realign_needed && crtl->need_drap)\n+\n+extern GTY(()) struct rtl_data x_rtl;\n+\n+/* Accessor to RTL datastructures.  We keep them statically allocated now since\n+   we never keep multiple functions.  For threaded compiler we might however\n+   want to do differently.  */\n+#define crtl (&x_rtl)\n+\n /* Return whether two MEM_ATTRs are equal.  */\n bool mem_attrs_eq_p (const struct mem_attrs *, const struct mem_attrs *);\n "}, {"sha": "54fea4b2c680e4d2e3bec0eb13f4ecc0d67f599f", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 261, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=2bb8cb5896c5133b9397da7ab97127c062a774b3", "patch": "@@ -153,8 +153,6 @@ struct GTY(()) rtl_eh {\n #define stack_pointer_delta (crtl->expr.x_stack_pointer_delta)\n \n struct gimple_df;\n-struct temp_slot;\n-typedef struct temp_slot *temp_slot_p;\n struct call_site_record_d;\n struct dw_fde_node;\n \n@@ -223,261 +221,6 @@ struct GTY(()) frame_space\n   HOST_WIDE_INT length;\n };\n \n-/* Datastructures maintained for currently processed function in RTL form.  */\n-struct GTY(()) rtl_data {\n-  struct expr_status expr;\n-  struct emit_status emit;\n-  struct varasm_status varasm;\n-  struct incoming_args args;\n-  struct function_subsections subsections;\n-  struct rtl_eh eh;\n-\n-  /* For function.c  */\n-\n-  /* # of bytes of outgoing arguments.  If ACCUMULATE_OUTGOING_ARGS is\n-     defined, the needed space is pushed by the prologue.  */\n-  int outgoing_args_size;\n-\n-  /* If nonzero, an RTL expression for the location at which the current\n-     function returns its result.  If the current function returns its\n-     result in a register, current_function_return_rtx will always be\n-     the hard register containing the result.  */\n-  rtx return_rtx;\n-  /* If nonxero, an RTL expression for the lcoation at which the current\n-     function returns bounds for its result.  */\n-  rtx return_bnd;\n-\n-  /* Vector of initial-value pairs.  Each pair consists of a pseudo\n-     register of approprite mode that stores the initial value a hard\n-     register REGNO, and that hard register itself.  */\n-  /* ??? This could be a VEC but there is currently no way to define an\n-\t opaque VEC type.  */\n-  struct initial_value_struct *hard_reg_initial_vals;\n-\n-  /* A variable living at the top of the frame that holds a known value.\n-     Used for detecting stack clobbers.  */\n-  tree stack_protect_guard;\n-\n-  /* List (chain of INSN_LIST) of labels heading the current handlers for\n-     nonlocal gotos.  */\n-  rtx_insn_list *x_nonlocal_goto_handler_labels;\n-\n-  /* Label that will go on function epilogue.\n-     Jumping to this label serves as a \"return\" instruction\n-     on machines which require execution of the epilogue on all returns.  */\n-  rtx_code_label *x_return_label;\n-\n-  /* Label that will go on the end of function epilogue.\n-     Jumping to this label serves as a \"naked return\" instruction\n-     on machines which require execution of the epilogue on all returns.  */\n-  rtx_code_label *x_naked_return_label;\n-\n-  /* List (chain of EXPR_LISTs) of all stack slots in this function.\n-     Made for the sake of unshare_all_rtl.  */\n-  rtx_expr_list *x_stack_slot_list;\n-\n-  /* List of empty areas in the stack frame.  */\n-  struct frame_space *frame_space_list;\n-\n-  /* Place after which to insert the tail_recursion_label if we need one.  */\n-  rtx_note *x_stack_check_probe_note;\n-\n-  /* Location at which to save the argument pointer if it will need to be\n-     referenced.  There are two cases where this is done: if nonlocal gotos\n-     exist, or if vars stored at an offset from the argument pointer will be\n-     needed by inner routines.  */\n-  rtx x_arg_pointer_save_area;\n-\n-  /* Dynamic Realign Argument Pointer used for realigning stack.  */\n-  rtx drap_reg;\n-\n-  /* Offset to end of allocated area of stack frame.\n-     If stack grows down, this is the address of the last stack slot allocated.\n-     If stack grows up, this is the address for the next slot.  */\n-  HOST_WIDE_INT x_frame_offset;\n-\n-  /* Insn after which register parms and SAVE_EXPRs are born, if nonopt.  */\n-  rtx_insn *x_parm_birth_insn;\n-\n-  /* List of all used temporaries allocated, by level.  */\n-  vec<temp_slot_p, va_gc> *x_used_temp_slots;\n-\n-  /* List of available temp slots.  */\n-  struct temp_slot *x_avail_temp_slots;\n-\n-  /* Current nesting level for temporaries.  */\n-  int x_temp_slot_level;\n-\n-  /* The largest alignment needed on the stack, including requirement\n-     for outgoing stack alignment.  */\n-  unsigned int stack_alignment_needed;\n-\n-  /* Preferred alignment of the end of stack frame, which is preferred\n-     to call other functions.  */\n-  unsigned int preferred_stack_boundary;\n-\n-  /* The minimum alignment of parameter stack.  */\n-  unsigned int parm_stack_boundary;\n-\n-  /* The largest alignment of slot allocated on the stack.  */\n-  unsigned int max_used_stack_slot_alignment;\n-\n-  /* The stack alignment estimated before reload, with consideration of\n-     following factors:\n-     1. Alignment of local stack variables (max_used_stack_slot_alignment)\n-     2. Alignment requirement to call other functions\n-        (preferred_stack_boundary)\n-     3. Alignment of non-local stack variables but might be spilled in\n-        local stack.  */\n-  unsigned int stack_alignment_estimated;\n-\n-  /* For reorg.  */\n-\n-  /* Nonzero if function being compiled called builtin_return_addr or\n-     builtin_frame_address with nonzero count.  */\n-  bool accesses_prior_frames;\n-\n-  /* Nonzero if the function calls __builtin_eh_return.  */\n-  bool calls_eh_return;\n-\n-  /* Nonzero if function saves all registers, e.g. if it has a nonlocal\n-     label that can reach the exit block via non-exceptional paths. */\n-  bool saves_all_registers;\n-\n-  /* Nonzero if function being compiled has nonlocal gotos to parent\n-     function.  */\n-  bool has_nonlocal_goto;\n-\n-  /* Nonzero if function being compiled has an asm statement.  */\n-  bool has_asm_statement;\n-\n-  /* This bit is used by the exception handling logic.  It is set if all\n-     calls (if any) are sibling calls.  Such functions do not have to\n-     have EH tables generated, as they cannot throw.  A call to such a\n-     function, however, should be treated as throwing if any of its callees\n-     can throw.  */\n-  bool all_throwers_are_sibcalls;\n-\n-  /* Nonzero if stack limit checking should be enabled in the current\n-     function.  */\n-  bool limit_stack;\n-\n-  /* Nonzero if profiling code should be generated.  */\n-  bool profile;\n-\n-  /* Nonzero if the current function uses the constant pool.  */\n-  bool uses_const_pool;\n-\n-  /* Nonzero if the current function uses pic_offset_table_rtx.  */\n-  bool uses_pic_offset_table;\n-\n-  /* Nonzero if the current function needs an lsda for exception handling.  */\n-  bool uses_eh_lsda;\n-\n-  /* Set when the tail call has been produced.  */\n-  bool tail_call_emit;\n-\n-  /* Nonzero if code to initialize arg_pointer_save_area has been emitted.  */\n-  bool arg_pointer_save_area_init;\n-\n-  /* Nonzero if current function must be given a frame pointer.\n-     Set in reload1.c or lra-eliminations.c if anything is allocated\n-     on the stack there.  */\n-  bool frame_pointer_needed;\n-\n-  /* When set, expand should optimize for speed.  */\n-  bool maybe_hot_insn_p;\n-\n-  /* Nonzero if function stack realignment is needed.  This flag may be\n-     set twice: before and after reload.  It is set before reload wrt\n-     stack alignment estimation before reload.  It will be changed after\n-     reload if by then criteria of stack realignment is different.\n-     The value set after reload is the accurate one and is finalized.  */\n-  bool stack_realign_needed;\n-\n-  /* Nonzero if function stack realignment is tried.  This flag is set\n-     only once before reload.  It affects register elimination.  This\n-     is used to generate DWARF debug info for stack variables.  */\n-  bool stack_realign_tried;\n-\n-  /* Nonzero if function being compiled needs dynamic realigned\n-     argument pointer (drap) if stack needs realigning.  */\n-  bool need_drap;\n-\n-  /* Nonzero if function stack realignment estimation is done, namely\n-     stack_realign_needed flag has been set before reload wrt estimated\n-     stack alignment info.  */\n-  bool stack_realign_processed;\n-\n-  /* Nonzero if function stack realignment has been finalized, namely\n-     stack_realign_needed flag has been set and finalized after reload.  */\n-  bool stack_realign_finalized;\n-\n-  /* True if dbr_schedule has already been called for this function.  */\n-  bool dbr_scheduled_p;\n-\n-  /* True if current function can not throw.  Unlike\n-     TREE_NOTHROW (current_function_decl) it is set even for overwritable\n-     function where currently compiled version of it is nothrow.  */\n-  bool nothrow;\n-\n-  /* True if we performed shrink-wrapping for the current function.  */\n-  bool shrink_wrapped;\n-\n-  /* Nonzero if function being compiled doesn't modify the stack pointer\n-     (ignoring the prologue and epilogue).  This is only valid after\n-     pass_stack_ptr_mod has run.  */\n-  bool sp_is_unchanging;\n-\n-  /* Nonzero if function being compiled doesn't contain any calls\n-     (ignoring the prologue and epilogue).  This is set prior to\n-     local register allocation and is valid for the remaining\n-     compiler passes.  */\n-  bool is_leaf;\n-\n-  /* Nonzero if the function being compiled is a leaf function which only\n-     uses leaf registers.  This is valid after reload (specifically after\n-     sched2) and is useful only if the port defines LEAF_REGISTERS.  */\n-  bool uses_only_leaf_regs;\n-\n-  /* Nonzero if the function being compiled has undergone hot/cold partitioning\n-     (under flag_reorder_blocks_and_partition) and has at least one cold\n-     block.  */\n-  bool has_bb_partition;\n-\n-  /* Nonzero if the function being compiled has completed the bb reordering\n-     pass.  */\n-  bool bb_reorder_complete;\n-\n-  /* Like regs_ever_live, but 1 if a reg is set or clobbered from an\n-     asm.  Unlike regs_ever_live, elements of this array corresponding\n-     to eliminable regs (like the frame pointer) are set if an asm\n-     sets them.  */\n-  HARD_REG_SET asm_clobbers;\n-};\n-\n-#define return_label (crtl->x_return_label)\n-#define naked_return_label (crtl->x_naked_return_label)\n-#define stack_slot_list (crtl->x_stack_slot_list)\n-#define parm_birth_insn (crtl->x_parm_birth_insn)\n-#define frame_offset (crtl->x_frame_offset)\n-#define stack_check_probe_note (crtl->x_stack_check_probe_note)\n-#define arg_pointer_save_area (crtl->x_arg_pointer_save_area)\n-#define used_temp_slots (crtl->x_used_temp_slots)\n-#define avail_temp_slots (crtl->x_avail_temp_slots)\n-#define temp_slot_level (crtl->x_temp_slot_level)\n-#define nonlocal_goto_handler_labels (crtl->x_nonlocal_goto_handler_labels)\n-#define frame_pointer_needed (crtl->frame_pointer_needed)\n-#define stack_realign_fp (crtl->stack_realign_needed && !crtl->need_drap)\n-#define stack_realign_drap (crtl->stack_realign_needed && crtl->need_drap)\n-\n-extern GTY(()) struct rtl_data x_rtl;\n-\n-/* Accessor to RTL datastructures.  We keep them statically allocated now since\n-   we never keep multiple functions.  For threaded compiler we might however\n-   want to do differently.  */\n-#define crtl (&x_rtl)\n-\n struct GTY(()) stack_usage\n {\n   /* # of bytes of static stack space allocated by the function.  */\n@@ -905,12 +648,8 @@ extern void expand_function_start (tree);\n extern void expand_dummy_function_end (void);\n \n extern void thread_prologue_and_epilogue_insns (void);\n-\n-#ifdef RTX_CODE\n extern void diddle_return_value (void (*)(rtx, void*), void*);\n extern void clobber_return_register (void);\n-#endif\n-\n extern void do_warn_unused_parameter (tree);\n extern void expand_function_end (void);\n extern rtx get_arg_pointer_save_area (void);"}, {"sha": "2ec02c366eb619e957a791e9fda1968dd89ee79d", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=2bb8cb5896c5133b9397da7ab97127c062a774b3", "patch": "@@ -5127,6 +5127,7 @@ write_header (FILE *outf)\n   fprintf (outf, \"#include \\\"toplev.h\\\"\\n\");\n   fprintf (outf, \"#include \\\"flags.h\\\"\\n\");\n   fprintf (outf, \"#include \\\"function.h\\\"\\n\");\n+  fprintf (outf, \"#include \\\"emit-rtl.h\\\"\\n\");\n   fprintf (outf, \"#include \\\"predict.h\\\"\\n\");\n   fprintf (outf, \"\\n\");\n   fprintf (outf, \"#define operands recog_data.operand\\n\\n\");"}, {"sha": "89d273898a69163ace2eb02ce4156e45e46e4528", "filename": "gcc/genconditions.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fgenconditions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fgenconditions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconditions.c?ref=2bb8cb5896c5133b9397da7ab97127c062a774b3", "patch": "@@ -73,6 +73,7 @@ write_header (void)\n #include \\\"tm_p.h\\\"\\n\\\n #include \\\"hard-reg-set.h\\\"\\n\\\n #include \\\"function.h\\\"\\n\\\n+#include \\\"emit-rtl.h\\\"\\n\\\n \\n\\\n /* Fake - insn-config.h doesn't exist yet.  */\\n\\\n #define MAX_RECOG_OPERANDS 10\\n\\"}, {"sha": "9a4c6a61539f7849122c2f1d449fd8456a6e886f", "filename": "gcc/genpreds.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=2bb8cb5896c5133b9397da7ab97127c062a774b3", "patch": "@@ -1558,6 +1558,7 @@ write_insn_preds_c (void)\n #include \\\"diagnostic-core.h\\\"\\n\\\n #include \\\"reload.h\\\"\\n\\\n #include \\\"regs.h\\\"\\n\\\n+#include \\\"emit-rtl.h\\\"\\n\\\n #include \\\"tm-constrs.h\\\"\\n\");\n \n   FOR_ALL_PREDICATES (p)"}, {"sha": "d62ba9f114a38c2e52a90a7b6c07177cdb6bbdde", "filename": "gcc/genrecog.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=2bb8cb5896c5133b9397da7ab97127c062a774b3", "patch": "@@ -4191,6 +4191,7 @@ write_header (void)\n #include \\\"hard-reg-set.h\\\"\\n\\\n #include \\\"input.h\\\"\\n\\\n #include \\\"function.h\\\"\\n\\\n+#include \\\"emit-rtl.h\\\"\\n\\\n #include \\\"insn-config.h\\\"\\n\\\n #include \\\"recog.h\\\"\\n\\\n #include \\\"output.h\\\"\\n\\"}, {"sha": "cca495e0952d5b0eb7463bd7ead998d12dcc9942", "filename": "gcc/regcprop.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=2bb8cb5896c5133b9397da7ab97127c062a774b3", "patch": "@@ -40,6 +40,7 @@\n #include \"tree-pass.h\"\n #include \"df.h\"\n #include \"rtl-iter.h\"\n+#include \"emit-rtl.h\"\n \n /* The following code does forward propagation of hard register copies.\n    The object is to eliminate as many dependencies as possible, so that"}, {"sha": "37b53a2daa3aa460d97853b71ed8871ad2288bae", "filename": "gcc/resource.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=2bb8cb5896c5133b9397da7ab97127c062a774b3", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"insn-attr.h\"\n #include \"params.h\"\n #include \"df.h\"\n+#include \"emit-rtl.h\"\n \n /* This structure is used to record liveness information at the targets or\n    fallthrough insns of branches.  We will most likely need the information"}, {"sha": "ccdde706ea7866434c35d36deb0f4915e358d28f", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb8cb5896c5133b9397da7ab97127c062a774b3/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=2bb8cb5896c5133b9397da7ab97127c062a774b3", "patch": "@@ -70,6 +70,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"tree-pass.h\"\n #include \"dbgcnt.h\"\n+#include \"emit-rtl.h\"\n \n #ifdef INSN_SCHEDULING\n "}]}