{"sha": "d116ffa6c26c2e431f9bf72db7b36e8ba84b8d04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDExNmZmYTZjMjZjMmU0MzFmOWJmNzJkYjdiMzZlOGJhODRiOGQwNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-11-21T00:51:39Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-11-21T00:51:39Z"}, "message": "re PR tree-optimization/24931 (uninitialized structure member after assignment)\n\n        PR 24931\n        * tree-sra.c (struct sra_elt): Add all_no_warning.\n        (struct sra_walk_fns) <use>: Add use_all argument.\n        (sra_walk_expr): Pass it.\n        (sra_walk_modify_expr): Likewise.\n        (scalarize_ldst): Likewise.\n        (scan_use): Update for new argument.\n        (mark_no_warning): New.\n        (scalarize_use): Use it.\n\nFrom-SVN: r107271", "tree": {"sha": "5633645a85dde92d6ea1cc3484c48034b292d0f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5633645a85dde92d6ea1cc3484c48034b292d0f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d116ffa6c26c2e431f9bf72db7b36e8ba84b8d04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d116ffa6c26c2e431f9bf72db7b36e8ba84b8d04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d116ffa6c26c2e431f9bf72db7b36e8ba84b8d04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d116ffa6c26c2e431f9bf72db7b36e8ba84b8d04/comments", "author": null, "committer": null, "parents": [{"sha": "6b6c5c5d6810fe2bc46b6d7e9c69a3a466f5bc3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b6c5c5d6810fe2bc46b6d7e9c69a3a466f5bc3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b6c5c5d6810fe2bc46b6d7e9c69a3a466f5bc3e"}], "stats": {"total": 77, "additions": 68, "deletions": 9}, "files": [{"sha": "765291e4ae64ba0e6a9d71260558fe733af4518d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d116ffa6c26c2e431f9bf72db7b36e8ba84b8d04/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d116ffa6c26c2e431f9bf72db7b36e8ba84b8d04/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d116ffa6c26c2e431f9bf72db7b36e8ba84b8d04", "patch": "@@ -1,3 +1,15 @@\n+2005-11-20  Richard Henderson  <rth@redhat.com>\n+\n+\tPR 24931\n+\t* tree-sra.c (struct sra_elt): Add all_no_warning.\n+\t(struct sra_walk_fns) <use>: Add use_all argument.\n+\t(sra_walk_expr): Pass it.\n+\t(sra_walk_modify_expr): Likewise.\n+\t(scalarize_ldst): Likewise.\n+\t(scan_use): Update for new argument.\n+\t(mark_no_warning): New.\n+\t(scalarize_use): Use it.\n+\n 2005-11-20  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* expr.c (expand_expr_real): Use usmul_optab for widening"}, {"sha": "41b4f622ae5414104a87034a8258530d4e3c9831", "filename": "gcc/testsuite/gcc.dg/uninit-14.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d116ffa6c26c2e431f9bf72db7b36e8ba84b8d04/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d116ffa6c26c2e431f9bf72db7b36e8ba84b8d04/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-14.c?ref=d116ffa6c26c2e431f9bf72db7b36e8ba84b8d04", "patch": "@@ -0,0 +1,20 @@\n+/* PR 24931 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O -Wuninitialized\" } */\n+\n+struct p {\n+        short x, y;\n+};\n+\n+struct s {\n+        int i;\n+        struct p p;\n+};\n+\n+struct s f()\n+{\n+        struct s s;\n+        s.p = (struct p){};\n+        s.i = (s.p.x || s.p.y);\n+        return s;\n+}"}, {"sha": "c25632020ea55c2276550ea73779b74171a7d5b0", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d116ffa6c26c2e431f9bf72db7b36e8ba84b8d04/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d116ffa6c26c2e431f9bf72db7b36e8ba84b8d04/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=d116ffa6c26c2e431f9bf72db7b36e8ba84b8d04", "patch": "@@ -127,6 +127,9 @@ struct sra_elt\n      should happen via memcpy and not per-element.  */\n   bool use_block_copy;\n \n+  /* True if everything under this element has been marked TREE_NO_WARNING.  */\n+  bool all_no_warning;\n+\n   /* A flag for use with/after random access traversals.  */\n   bool visited;\n };\n@@ -598,9 +601,10 @@ struct sra_walk_fns\n   /* Invoked when ELT is required as a unit.  Note that ELT might refer to\n      a leaf node, in which case this is a simple scalar reference.  *EXPR_P\n      points to the location of the expression.  IS_OUTPUT is true if this\n-     is a left-hand-side reference.  */\n+     is a left-hand-side reference.  USE_ALL is true if we saw something we\n+     couldn't quite identify and had to force the use of the entire object.  */\n   void (*use) (struct sra_elt *elt, tree *expr_p,\n-\t       block_stmt_iterator *bsi, bool is_output);\n+\t       block_stmt_iterator *bsi, bool is_output, bool use_all);\n \n   /* Invoked when we have a copy between two scalarizable references.  */\n   void (*copy) (struct sra_elt *lhs_elt, struct sra_elt *rhs_elt,\n@@ -654,6 +658,7 @@ sra_walk_expr (tree *expr_p, block_stmt_iterator *bsi, bool is_output,\n   tree expr = *expr_p;\n   tree inner = expr;\n   bool disable_scalarization = false;\n+  bool use_all_p = false;\n \n   /* We're looking to collect a reference expression between EXPR and INNER,\n      such that INNER is a scalarizable decl and all other nodes through EXPR\n@@ -674,7 +679,7 @@ sra_walk_expr (tree *expr_p, block_stmt_iterator *bsi, bool is_output,\n \t    if (disable_scalarization)\n \t      elt->cannot_scalarize = true;\n \t    else\n-\t      fns->use (elt, expr_p, bsi, is_output);\n+\t      fns->use (elt, expr_p, bsi, is_output, use_all_p);\n \t  }\n \treturn;\n \n@@ -742,6 +747,7 @@ sra_walk_expr (tree *expr_p, block_stmt_iterator *bsi, bool is_output,\n       use_all:\n         expr_p = &TREE_OPERAND (inner, 0);\n \tinner = expr = *expr_p;\n+\tuse_all_p = true;\n \tbreak;\n \n       default:\n@@ -813,7 +819,7 @@ sra_walk_modify_expr (tree expr, block_stmt_iterator *bsi,\n       if (!rhs_elt->is_scalar)\n \tfns->ldst (rhs_elt, lhs, bsi, false);\n       else\n-\tfns->use (rhs_elt, &TREE_OPERAND (expr, 1), bsi, false);\n+\tfns->use (rhs_elt, &TREE_OPERAND (expr, 1), bsi, false, false);\n     }\n \n   /* If it isn't scalarizable, there may be scalarizable variables within, so\n@@ -859,7 +865,7 @@ sra_walk_modify_expr (tree expr, block_stmt_iterator *bsi,\n       /* Otherwise we're being used in some context that requires the\n \t aggregate to be seen as a whole.  Invoke USE.  */\n       else\n-\tfns->use (lhs_elt, &TREE_OPERAND (expr, 0), bsi, true);\n+\tfns->use (lhs_elt, &TREE_OPERAND (expr, 0), bsi, true, false);\n     }\n \n   /* Similarly to above, LHS_ELT being null only means that the LHS as a\n@@ -967,7 +973,7 @@ find_candidates_for_sra (void)\n static void\n scan_use (struct sra_elt *elt, tree *expr_p ATTRIBUTE_UNUSED,\n \t  block_stmt_iterator *bsi ATTRIBUTE_UNUSED,\n-\t  bool is_output ATTRIBUTE_UNUSED)\n+\t  bool is_output ATTRIBUTE_UNUSED, bool use_all ATTRIBUTE_UNUSED)\n {\n   elt->n_uses += 1;\n }\n@@ -1472,6 +1478,23 @@ mark_all_v_defs (tree list)\n     }\n }\n \n+/* Mark every replacement under ELT with TREE_NO_WARNING.  */\n+\n+static void\n+mark_no_warning (struct sra_elt *elt)\n+{\n+  if (!elt->all_no_warning)\n+    {\n+      if (elt->replacement)\n+\tTREE_NO_WARNING (elt->replacement) = 1;\n+      else\n+\t{\n+\t  struct sra_elt *c;\n+\t  for (c = elt->children; c ; c = c->sibling)\n+\t    mark_no_warning (c);\n+\t}\n+    }\n+}\n \n /* Build a single level component reference to ELT rooted at BASE.  */\n \n@@ -1815,7 +1838,7 @@ sra_replace (block_stmt_iterator *bsi, tree list)\n \n static void\n scalarize_use (struct sra_elt *elt, tree *expr_p, block_stmt_iterator *bsi,\n-\t       bool is_output)\n+\t       bool is_output, bool use_all)\n {\n   tree list = NULL, stmt = bsi_stmt (*bsi);\n \n@@ -1850,7 +1873,11 @@ scalarize_use (struct sra_elt *elt, tree *expr_p, block_stmt_iterator *bsi,\n       if (is_output)\n \tsra_insert_after (bsi, list);\n       else\n-\tsra_insert_before (bsi, list);\n+\t{\n+\t  sra_insert_before (bsi, list);\n+\t  if (use_all)\n+\t    mark_no_warning (elt);\n+\t}\n     }\n }\n \n@@ -2015,7 +2042,7 @@ scalarize_ldst (struct sra_elt *elt, tree other,\n     {\n       /* Since ELT is not fully instantiated, we have to leave the\n \t block copy in place.  Treat this as a USE.  */\n-      scalarize_use (elt, NULL, bsi, is_output);\n+      scalarize_use (elt, NULL, bsi, is_output, false);\n     }\n   else\n     {"}]}