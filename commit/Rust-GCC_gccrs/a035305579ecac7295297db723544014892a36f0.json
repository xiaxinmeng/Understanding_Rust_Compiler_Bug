{"sha": "a035305579ecac7295297db723544014892a36f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAzNTMwNTU3OWVjYWM3Mjk1Mjk3ZGI3MjM1NDQwMTQ4OTJhMzZmMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-21T19:33:15Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-21T19:33:15Z"}, "message": "Make most functions static and add prototypes for all static functions.\n\n(GET_REAL, PUT_REAL): Cast parameter to proper pointer type in some\ncases; use unsigned array.\n\nFrom-SVN: r7120", "tree": {"sha": "b5143d578f8eb64b3cce1ab96141a80a4ae3ab09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5143d578f8eb64b3cce1ab96141a80a4ae3ab09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a035305579ecac7295297db723544014892a36f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a035305579ecac7295297db723544014892a36f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a035305579ecac7295297db723544014892a36f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a035305579ecac7295297db723544014892a36f0/comments", "author": null, "committer": null, "parents": [{"sha": "30d889161d10b19a26b4bffbbc4a69560410b4ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30d889161d10b19a26b4bffbbc4a69560410b4ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30d889161d10b19a26b4bffbbc4a69560410b4ce"}], "stats": {"total": 350, "additions": 225, "deletions": 125}, "files": [{"sha": "6933423161eb94a2c8e893ceb3964884157c1296", "filename": "gcc/real.c", "status": "modified", "additions": 225, "deletions": 125, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a035305579ecac7295297db723544014892a36f0/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a035305579ecac7295297db723544014892a36f0/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=a035305579ecac7295297db723544014892a36f0", "patch": "@@ -264,21 +264,21 @@ unknown arithmetic type\n    but host stores it in host endian-ness. */\n \n #if HOST_FLOAT_WORDS_BIG_ENDIAN == FLOAT_WORDS_BIG_ENDIAN\n-#define GET_REAL(r,e) e53toe ((r), (e))\n-#define PUT_REAL(e,r) etoe53 ((e), (r))\n+#define GET_REAL(r,e) e53toe ((unsigned EMUSHORT*) (r), (e))\n+#define PUT_REAL(e,r) etoe53 ((e), (unsigned EMUSHORT *) (r))\n \n #else /* endian-ness differs */\n /* emulator uses target endian-ness internally */\n #define GET_REAL(r,e)\t\t\\\n-do { EMUSHORT w[4];\t\t\\\n+do { unsigned EMUSHORT w[4];\t\\\n  w[3] = ((EMUSHORT *) r)[0];\t\\\n  w[2] = ((EMUSHORT *) r)[1];\t\\\n  w[1] = ((EMUSHORT *) r)[2];\t\\\n  w[0] = ((EMUSHORT *) r)[3];\t\\\n  e53toe (w, (e)); } while (0)\n \n #define PUT_REAL(e,r)\t\t\\\n-do { EMUSHORT w[4];\t\t\\\n+do { unsigned EMUSHORT w[4];\t\\\n  etoe53 ((e), w);\t\t\\\n  *((EMUSHORT *) r) = w[3];\t\\\n  *((EMUSHORT *) r + 1) = w[2];\t\\\n@@ -290,8 +290,8 @@ do { EMUSHORT w[4];\t\t\\\n #else /* not REAL_ARITHMETIC */\n \n /* emulator uses host format */\n-#define GET_REAL(r,e) e53toe ((r), (e))\n-#define PUT_REAL(e,r) etoe53 ((e), (r))\n+#define GET_REAL(r,e) e53toe ((unsigned EMUSHORT *) (r), (e))\n+#define PUT_REAL(e,r) etoe53 ((e), (unsigned EMUSHORT *) (r))\n \n #endif /* not REAL_ARITHMETIC */\n #endif /* not TFmode */\n@@ -318,29 +318,117 @@ do { EMUSHORT w[4];\t\t\\\n /* The exponent of 1.0 */\n #define EXONE (0x3fff)\n \n-void warning ();\n extern int extra_warnings;\n-int ecmp (), enormlz (), eshift ();\n-int eisneg (), eisinf (), eisnan (), eiisinf (), eiisnan (), eiisneg ();\n-void eadd (), esub (), emul (), ediv ();\n-void eshup1 (), eshup8 (), eshup6 (), eshdn1 (), eshdn8 (), eshdn6 ();\n-void eabs (), eneg (), emov (), eclear (), einfin (), efloor ();\n-void eldexp (), efrexp (), eifrac (), euifrac (), ltoe (), ultoe ();\n-void ereal_to_decimal (), eiinfin (), einan ();\n-void esqrt (), elog (), eexp (), etanh (), epow ();\n-void asctoe (), asctoe24 (), asctoe53 (), asctoe64 (), asctoe113 ();\n-void etoasc (), e24toasc (), e53toasc (), e64toasc (), e113toasc ();\n-void etoe64 (), etoe53 (), etoe24 (), e64toe (), e53toe (), e24toe ();\n-void etoe113 (), e113toe ();\n-void mtherr (), make_nan ();\n-void enan ();\n extern unsigned EMUSHORT ezero[], ehalf[], eone[], etwo[];\n extern unsigned EMUSHORT elog2[], esqrt2[];\n+\n+static void endian\tPROTO((unsigned EMUSHORT *, long *,\n+\t\t\t       enum machine_mode));\n+static void eclear\tPROTO((unsigned EMUSHORT *));\n+static void emov\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void eabs\tPROTO((unsigned EMUSHORT *));\n+static void eneg\tPROTO((unsigned EMUSHORT *));\n+static int eisneg\tPROTO((unsigned EMUSHORT *));\n+static int eisinf\tPROTO((unsigned EMUSHORT *));\n+static int eisnan\tPROTO((unsigned EMUSHORT *));\n+static void einfin\tPROTO((unsigned EMUSHORT *));\n+static void enan\tPROTO((unsigned EMUSHORT *, int));\n+static void emovi\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void emovo\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void ecleaz\tPROTO((unsigned EMUSHORT *));\n+static void ecleazs\tPROTO((unsigned EMUSHORT *));\n+static void emovz\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void einan\tPROTO((unsigned EMUSHORT *));\n+static int eiisnan\tPROTO((unsigned EMUSHORT *));\n+static int eiisneg\tPROTO((unsigned EMUSHORT *));\n+static void eiinfin\tPROTO((unsigned EMUSHORT *));\n+static int eiisinf\tPROTO((unsigned EMUSHORT *));\n+static int ecmpm\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void eshdn1\tPROTO((unsigned EMUSHORT *));\n+static void eshup1\tPROTO((unsigned EMUSHORT *));\n+static void eshdn8\tPROTO((unsigned EMUSHORT *));\n+static void eshup8\tPROTO((unsigned EMUSHORT *));\n+static void eshup6\tPROTO((unsigned EMUSHORT *));\n+static void eshdn6\tPROTO((unsigned EMUSHORT *));\n+static void eaddm\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\f\n+static void esubm\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void m16m\tPROTO((unsigned short, unsigned short *,\n+\t\t\t       unsigned short *));\n+static int edivm\tPROTO((unsigned short *, unsigned short *));\n+static int emulm\tPROTO((unsigned short *, unsigned short *));\n+static void emdnorm\tPROTO((unsigned EMUSHORT *, int, int, EMULONG, int));\n+static void esub\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *,\n+\t\t\t       unsigned EMUSHORT *));\n+static void eadd\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *,\n+\t\t\t       unsigned EMUSHORT *));\n+static void eadd1\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *,\n+\t\t\t       unsigned EMUSHORT *));\n+static void ediv\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *,\n+\t\t\t       unsigned EMUSHORT *));\n+static void emul\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *,\n+\t\t\t       unsigned EMUSHORT *));\n+static void e53toe\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void e64toe\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void e113toe\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void e24toe\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void etoe113\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void toe113\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void etoe64\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void toe64\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void etoe53\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void toe53\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void etoe24\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void toe24\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static int ecmp\t\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void eround\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void ltoe\tPROTO((HOST_WIDE_INT *, unsigned EMUSHORT *));\n+static void ultoe\tPROTO((unsigned HOST_WIDE_INT *, unsigned EMUSHORT *));\n+static void eifrac\tPROTO((unsigned EMUSHORT *, HOST_WIDE_INT *,\n+\t\t\t       unsigned EMUSHORT *));\n+static void euifrac\tPROTO((unsigned EMUSHORT *, unsigned HOST_WIDE_INT *,\n+\t\t\t       unsigned EMUSHORT *));\n+static int eshift\tPROTO((unsigned EMUSHORT *, int));\n+static int enormlz\tPROTO((unsigned EMUSHORT *));\n+static void e24toasc\tPROTO((unsigned EMUSHORT *, char *, int));\n+static void e53toasc\tPROTO((unsigned EMUSHORT *, char *, int));\n+static void e64toasc\tPROTO((unsigned EMUSHORT *, char *, int));\n+static void e113toasc\tPROTO((unsigned EMUSHORT *, char *, int));\n+static void etoasc\tPROTO((unsigned EMUSHORT *, char *, int));\n+static void asctoe24\tPROTO((char *, unsigned EMUSHORT *));\n+static void asctoe53\tPROTO((char *, unsigned EMUSHORT *));\n+static void asctoe64\tPROTO((char *, unsigned EMUSHORT *));\n+static void asctoe113\tPROTO((char *, unsigned EMUSHORT *));\n+static void asctoe\tPROTO((char *, unsigned EMUSHORT *));\n+static void asctoeg\tPROTO((char *, unsigned EMUSHORT *, int));\n+static void efloor\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void efrexp\tPROTO((unsigned EMUSHORT *, int *,\n+\t\t\t       unsigned EMUSHORT *));\n+static void eldexp\tPROTO((unsigned EMUSHORT *, int, unsigned EMUSHORT *));\n+static void eremain\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *,\n+\t\t\t       unsigned EMUSHORT *));\n+static void eiremain\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void mtherr\tPROTO((char *, int));\n+static void dectoe\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void etodec\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void todec\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void ibmtoe\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *,\n+\t\t\t       enum machine_mode));\n+static void etoibm\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *,\n+\t\t\t       enum machine_mode));\n+static void toibm\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *,\n+\t\t\t       enum machine_mode));\n+static void make_nan\tPROTO((unsigned EMUSHORT *, int, enum machine_mode));\n+static void uditoe\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void ditoe\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void etoudi\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void etodi\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n+static void esqrt\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n \f\n /* Copy 32-bit numbers obtained from array containing 16-bit numbers,\n    swapping ends if required, into output array of longs.  The\n    result is normally passed to fprintf by the ASM_OUTPUT_ macros.   */\n-void \n+\n+static void \n endian (e, x, mode)\n      unsigned EMUSHORT e[];\n      long x[];\n@@ -444,6 +532,7 @@ endian (e, x, mode)\n \n /* This is the implementation of the REAL_ARITHMETIC macro.\n  */\n+\n void \n earith (value, icode, r1, r2)\n      REAL_VALUE_TYPE *value;\n@@ -703,6 +792,7 @@ ereal_from_int (d, i, j)\n \n /* REAL_VALUE_FROM_UNSIGNED_INT macro.\n  */\n+\n void \n ereal_from_uint (d, i, j)\n      REAL_VALUE_TYPE *d;\n@@ -1260,32 +1350,17 @@ unsigned EMUSHORT epi[NE] =\n int rndprc = NBITS;\n extern int rndprc;\n \n-void eaddm (), esubm (), emdnorm (), asctoeg ();\n static void toe24 (), toe53 (), toe64 (), toe113 ();\n-void eremain (), einit (), eiremain ();\n-int ecmpm (), edivm (), emulm ();\n-void emovi (), emovo (), emovz (), ecleaz (), ecleazs (), eadd1 ();\n-#ifdef DEC\n-void etodec (), todec (), dectoe ();\n-#endif\n-#ifdef IBM\n-void etoibm (), toibm (), ibmtoe ();\n-#endif\n \n \n-void \n-einit ()\n-{\n-}\n-\n /*\n ; Clear out entire external format number.\n ;\n ; unsigned EMUSHORT x[];\n ; eclear (x);\n */\n \n-void \n+static void \n eclear (x)\n      register unsigned EMUSHORT *x;\n {\n@@ -1302,7 +1377,7 @@ eclear (x)\n  * emov (a, b);\n  */\n \n-void \n+static void \n emov (a, b)\n      register unsigned EMUSHORT *a, *b;\n {\n@@ -1320,12 +1395,12 @@ emov (a, b)\n ;\teabs (x);\n */\n \n-void \n+static void \n eabs (x)\n-     unsigned EMUSHORT x[];\t/* x is the memory address of a short */\n+     unsigned EMUSHORT x[];\n {\n-\n-  x[NE - 1] &= 0x7fff;\t\t/* sign is top bit of last word of external format */\n+  /* sign is top bit of last word of external format */\n+  x[NE - 1] &= 0x7fff;\t\t\n }\n \n \n@@ -1338,7 +1413,7 @@ eabs (x)\n ;\teneg (x);\n */\n \n-void \n+static void \n eneg (x)\n      unsigned EMUSHORT x[];\n {\n@@ -1351,7 +1426,7 @@ eneg (x)\n /* Return 1 if sign bit of external format number is nonzero,\n  * else return zero.\n  */\n-int \n+static int \n eisneg (x)\n      unsigned EMUSHORT x[];\n {\n@@ -1366,7 +1441,8 @@ eisneg (x)\n /* Return 1 if external format number is infinity.\n  * else return zero.\n  */\n-int \n+\n+static int \n eisinf (x)\n      unsigned EMUSHORT x[];\n {\n@@ -1386,7 +1462,7 @@ eisinf (x)\n    The bit pattern is one that we defined, so we know for sure how to\n    detect it.  */\n \n-int \n+static int \n eisnan (x)\n      unsigned EMUSHORT x[];\n {\n@@ -1409,7 +1485,7 @@ eisnan (x)\n /*  Fill external format number with infinity pattern (IEEE)\n     or largest possible number (non-IEEE). */\n \n-void \n+static void \n einfin (x)\n      register unsigned EMUSHORT *x;\n {\n@@ -1453,7 +1529,7 @@ einfin (x)\n    This generates Intel's quiet NaN pattern for extended real.\n    The exponent is 7fff, the leading mantissa word is c000.  */\n \n-void \n+static void \n enan (x, sign)\n      register unsigned EMUSHORT *x;\n      int sign;\n@@ -1470,7 +1546,7 @@ enan (x, sign)\n /* Move in external format number,\n  * converting it to internal format.\n  */\n-void \n+static void \n emovi (a, b)\n      unsigned EMUSHORT *a, *b;\n {\n@@ -1517,7 +1593,7 @@ emovi (a, b)\n /* Move internal format number out,\n  * converting it to external format.\n  */\n-void \n+static void \n emovo (a, b)\n      unsigned EMUSHORT *a, *b;\n {\n@@ -1560,7 +1636,7 @@ emovo (a, b)\n /* Clear out internal format number.\n  */\n \n-void \n+static void \n ecleaz (xi)\n      register unsigned EMUSHORT *xi;\n {\n@@ -1573,7 +1649,7 @@ ecleaz (xi)\n \n /* same, but don't touch the sign. */\n \n-void \n+static void \n ecleazs (xi)\n      register unsigned EMUSHORT *xi;\n {\n@@ -1588,7 +1664,8 @@ ecleazs (xi)\n \n /* Move internal format number from a to b.\n  */\n-void \n+\n+static void \n emovz (a, b)\n      register unsigned EMUSHORT *a, *b;\n {\n@@ -1604,7 +1681,7 @@ emovz (a, b)\n    The explicit pattern for this is maximum exponent and\n    top two significand bits set.  */\n \n-void\n+static void\n einan (x)\n      unsigned EMUSHORT x[];\n {\n@@ -1616,7 +1693,7 @@ einan (x)\n \n /* Return nonzero if internal format number is a NaN. */\n \n-int \n+static int \n eiisnan (x)\n      unsigned EMUSHORT x[];\n {\n@@ -1635,7 +1712,7 @@ eiisnan (x)\n \n /* Return nonzero if sign of internal format number is nonzero.  */\n \n-int \n+static int \n eiisneg (x)\n      unsigned EMUSHORT x[];\n {\n@@ -1646,7 +1723,7 @@ eiisneg (x)\n /* Fill internal format number with infinity pattern.\n    This has maximum exponent and significand all zeros.  */\n \n-void\n+static void\n eiinfin (x)\n      unsigned EMUSHORT x[];\n {\n@@ -1657,7 +1734,7 @@ eiinfin (x)\n \n /* Return nonzero if internal format number is infinite. */\n \n-int \n+static int \n eiisinf (x)\n      unsigned EMUSHORT x[];\n {\n@@ -1684,7 +1761,8 @@ eiisinf (x)\n ;\t\t 0 if a == b\n ;\t\t-1 if a < b\n */\n-int\n+\n+static int\n ecmpm (a, b)\n      register unsigned EMUSHORT *a, *b;\n {\n@@ -1711,7 +1789,7 @@ ecmpm (a, b)\n ;\tShift significand down by 1 bit\n */\n \n-void \n+static void \n eshdn1 (x)\n      register unsigned EMUSHORT *x;\n {\n@@ -1739,7 +1817,7 @@ eshdn1 (x)\n ;\tShift significand up by 1 bit\n */\n \n-void \n+static void \n eshup1 (x)\n      register unsigned EMUSHORT *x;\n {\n@@ -1767,7 +1845,7 @@ eshup1 (x)\n ;\tShift significand down by 8 bits\n */\n \n-void \n+static void \n eshdn8 (x)\n      register unsigned EMUSHORT *x;\n {\n@@ -1790,7 +1868,7 @@ eshdn8 (x)\n ;\tShift significand up by 8 bits\n */\n \n-void \n+static void \n eshup8 (x)\n      register unsigned EMUSHORT *x;\n {\n@@ -1814,7 +1892,7 @@ eshup8 (x)\n ;\tShift significand up by 16 bits\n */\n \n-void \n+static void \n eshup6 (x)\n      register unsigned EMUSHORT *x;\n {\n@@ -1834,7 +1912,7 @@ eshup6 (x)\n ;\tShift significand down by 16 bits\n */\n \n-void \n+static void \n eshdn6 (x)\n      register unsigned EMUSHORT *x;\n {\n@@ -1855,7 +1933,7 @@ eshdn6 (x)\n ;\tx + y replaces y\n */\n \n-void \n+static void \n eaddm (x, y)\n      unsigned EMUSHORT *x, *y;\n {\n@@ -1884,7 +1962,7 @@ eaddm (x, y)\n ;\ty - x replaces y\n */\n \n-void \n+static void \n esubm (x, y)\n      unsigned EMUSHORT *x, *y;\n {\n@@ -2066,9 +2144,9 @@ emulm (a, b)\n \n \n /* Multiply significand of e-type number b\n-by 16-bit quantity a, e-type result to c. */\n+   by 16-bit quantity a, e-type result to c. */\n \n-void\n+static void\n m16m (a, b, c)\n      unsigned short a;\n      unsigned short b[], c[];\n@@ -2112,7 +2190,7 @@ m16m (a, b, c)\n /* Divide significands. Neither the numerator nor the denominator\n    is permitted to have its high guard word nonzero.  */\n \n-int\n+static int\n edivm (den, num)\n      unsigned short den[], num[];\n {\n@@ -2178,7 +2256,7 @@ edivm (den, num)\n \n \n /* Multiply significands */\n-int\n+static int\n emulm (a, b)\n      unsigned short a[], b[];\n {\n@@ -2256,7 +2334,7 @@ static unsigned EMUSHORT rebit = 0;\n static int re = 0;\n static unsigned EMUSHORT rbit[NI];\n \n-void \n+static void \n emdnorm (s, lost, subflg, exp, rcntrl)\n      unsigned EMUSHORT s[];\n      int lost;\n@@ -2459,7 +2537,7 @@ emdnorm (s, lost, subflg, exp, rcntrl)\n \n static int subflg = 0;\n \n-void \n+static void \n esub (a, b, c)\n      unsigned EMUSHORT *a, *b, *c;\n {\n@@ -2496,7 +2574,8 @@ esub (a, b, c)\n ;\tunsigned EMUSHORT a[NE], b[NE], c[NE];\n ;\teadd (a, b, c);\t c = b + a\n */\n-void \n+\n+static void \n eadd (a, b, c)\n      unsigned EMUSHORT *a, *b, *c;\n {\n@@ -2527,7 +2606,7 @@ eadd (a, b, c)\n   eadd1 (a, b, c);\n }\n \n-void \n+static void \n eadd1 (a, b, c)\n      unsigned EMUSHORT *a, *b, *c;\n {\n@@ -2637,7 +2716,8 @@ eadd1 (a, b, c)\n ;\tunsigned EMUSHORT a[NE], b[NE], c[NE];\n ;\tediv (a, b, c);\tc = b / a\n */\n-void \n+\n+static void \n ediv (a, b, c)\n      unsigned EMUSHORT *a, *b, *c;\n {\n@@ -2745,7 +2825,8 @@ ediv (a, b, c)\n ;\tunsigned EMUSHORT a[NE], b[NE], c[NE];\n ;\temul (a, b, c);\tc = b * a\n */\n-void \n+\n+static void \n emul (a, b, c)\n      unsigned EMUSHORT *a, *b, *c;\n {\n@@ -2842,7 +2923,8 @@ emul (a, b, c)\n ;\tunsigned EMUSHORT x[N+2];\n ;\te53toe (&d, x);\n */\n-void \n+\n+static void\n e53toe (pe, y)\n      unsigned EMUSHORT *pe, *y;\n {\n@@ -2935,7 +3017,7 @@ e53toe (pe, y)\n #endif /* not DEC */\n }\n \n-void \n+static void \n e64toe (pe, y)\n      unsigned EMUSHORT *pe, *y;\n {\n@@ -3008,7 +3090,7 @@ e64toe (pe, y)\n }\n \n \n-void \n+static void \n e113toe (pe, y)\n      unsigned EMUSHORT *pe, *y;\n {\n@@ -3090,7 +3172,8 @@ e113toe (pe, y)\n ;\tunsigned EMUSHORT x[N+2];\n ;\tdtox (&d, x);\n */\n-void \n+\n+static void \n e24toe (pe, y)\n      unsigned EMUSHORT *pe, *y;\n {\n@@ -3178,7 +3261,7 @@ e24toe (pe, y)\n }\n \n \n-void \n+static void \n etoe113 (x, e)\n      unsigned EMUSHORT *x, *e;\n {\n@@ -3209,6 +3292,7 @@ etoe113 (x, e)\n }\n \n /* move out internal format to ieee long double */\n+\n static void \n toe113 (a, b)\n      unsigned EMUSHORT *a, *b;\n@@ -3260,7 +3344,7 @@ toe113 (a, b)\n #endif\n }\n \n-void \n+static void \n etoe64 (x, e)\n      unsigned EMUSHORT *x, *e;\n {\n@@ -3291,6 +3375,7 @@ etoe64 (x, e)\n   toe64 (xi, e);\n }\n \n+\n /* move out internal format to ieee long double */\n static void \n toe64 (a, b)\n@@ -3353,7 +3438,7 @@ toe64 (a, b)\n \n #ifdef DEC\n \n-void \n+static void \n etoe53 (x, e)\n      unsigned EMUSHORT *x, *e;\n {\n@@ -3649,7 +3734,8 @@ toe24 (x, y)\n  *          -1 if a < b\n  *          -2 if either a or b is a NaN.\n  */\n-int \n+\n+static int \n ecmp (a, b)\n      unsigned EMUSHORT *a, *b;\n {\n@@ -3719,7 +3805,8 @@ ecmp (a, b)\n  * unsigned EMUSHORT x[NE], y[NE]\n  * eround (x, y);\n  */\n-void \n+\n+static void \n eround (x, y)\n      unsigned EMUSHORT *x, *y;\n {\n@@ -3738,7 +3825,8 @@ eround (x, y)\n ;\tltoe (&l, x);\n ; note &l is the memory address of l\n */\n-void \n+\n+static void \n ltoe (lp, y)\n      HOST_WIDE_INT *lp;\n      unsigned EMUSHORT *y;\n@@ -3786,7 +3874,8 @@ ltoe (lp, y)\n ;\tltox (&l, x);\n ; note &l is the memory address of l\n */\n-void \n+\n+static void \n ultoe (lp, y)\n      unsigned HOST_WIDE_INT *lp;\n      unsigned EMUSHORT *y;\n@@ -3826,7 +3915,7 @@ ultoe (lp, y)\n    The output e-type fraction FRAC is the positive fractional\n    part of abs (X).  */\n \n-void \n+static void \n eifrac (x, i, frac)\n      unsigned EMUSHORT *x;\n      HOST_WIDE_INT *i;\n@@ -3909,7 +3998,7 @@ eifrac (x, i, frac)\n    A negative e type input yields integer output = 0\n    but correct fraction.  */\n \n-void \n+static void \n euifrac (x, i, frac)\n      unsigned EMUSHORT *x;\n      unsigned HOST_WIDE_INT *i;\n@@ -3984,7 +4073,8 @@ euifrac (x, i, frac)\n ;\tShifts significand area up or down by the number of bits\n ;\tgiven by the variable sc.\n */\n-int \n+\n+static int \n eshift (x, sc)\n      unsigned EMUSHORT *x;\n      int sc;\n@@ -4055,7 +4145,8 @@ eshift (x, sc)\n ; Shift normalizes the significand area pointed to by argument\n ; shift count (up = positive) is returned.\n */\n-int \n+\n+static int \n enormlz (x)\n      unsigned EMUSHORT x[];\n {\n@@ -4228,7 +4319,7 @@ static unsigned EMUSHORT emtens[NTEN + 1][NE] =\n };\n #endif\n \n-void \n+static void \n e24toasc (x, string, ndigs)\n      unsigned EMUSHORT x[];\n      char *string;\n@@ -4241,7 +4332,7 @@ e24toasc (x, string, ndigs)\n }\n \n \n-void \n+static void \n e53toasc (x, string, ndigs)\n      unsigned EMUSHORT x[];\n      char *string;\n@@ -4254,7 +4345,7 @@ e53toasc (x, string, ndigs)\n }\n \n \n-void \n+static void \n e64toasc (x, string, ndigs)\n      unsigned EMUSHORT x[];\n      char *string;\n@@ -4266,7 +4357,7 @@ e64toasc (x, string, ndigs)\n   etoasc (w, string, ndigs);\n }\n \n-void \n+static void \n e113toasc (x, string, ndigs)\n      unsigned EMUSHORT x[];\n      char *string;\n@@ -4281,7 +4372,7 @@ e113toasc (x, string, ndigs)\n \n static char wstring[80];\t/* working storage for ASCII output */\n \n-void \n+static void \n etoasc (x, string, ndigs)\n      unsigned EMUSHORT x[];\n      char *string;\n@@ -4610,7 +4701,8 @@ etoasc (x, string, ndigs)\n */\n \n /* ASCII to single */\n-void \n+\n+static void \n asctoe24 (s, y)\n      char *s;\n      unsigned EMUSHORT *y;\n@@ -4620,7 +4712,8 @@ asctoe24 (s, y)\n \n \n /* ASCII to double */\n-void \n+\n+static void \n asctoe53 (s, y)\n      char *s;\n      unsigned EMUSHORT *y;\n@@ -4634,7 +4727,8 @@ asctoe53 (s, y)\n \n \n /* ASCII to long double */\n-void \n+\n+static void \n asctoe64 (s, y)\n      char *s;\n      unsigned EMUSHORT *y;\n@@ -4643,7 +4737,8 @@ asctoe64 (s, y)\n }\n \n /* ASCII to 128-bit long double */\n-void \n+\n+static void \n asctoe113 (s, y)\n      char *s;\n      unsigned EMUSHORT *y;\n@@ -4652,7 +4747,7 @@ asctoe113 (s, y)\n }\n \n /* ASCII to super double */\n-void \n+static void \n asctoe (s, y)\n      char *s;\n      unsigned EMUSHORT *y;\n@@ -4662,7 +4757,7 @@ asctoe (s, y)\n \n \n /* ASCII to e type, with specified rounding precision = oprec. */\n-void \n+static void \n asctoeg (ss, y, oprec)\n      char *ss;\n      unsigned EMUSHORT *y;\n@@ -5001,7 +5096,7 @@ static unsigned EMUSHORT bmask[] =\n   0x0000,\n };\n \n-void \n+static void \n efloor (x, y)\n      unsigned EMUSHORT x[], y[];\n {\n@@ -5057,7 +5152,8 @@ efloor (x, y)\n  * For example, 1.1 = 0.55 * 2**1\n  * Handles denormalized numbers properly using long integer exp.\n  */\n-void \n+\n+static void \n efrexp (x, exp, s)\n      unsigned EMUSHORT x[];\n      int *exp;\n@@ -5087,7 +5183,8 @@ efrexp (x, exp, s)\n  *\n  * Returns y = x * 2**pwr2.\n  */\n-void \n+\n+static void \n eldexp (x, pwr2, y)\n      unsigned EMUSHORT x[];\n      int pwr2;\n@@ -5109,7 +5206,8 @@ eldexp (x, pwr2, y)\n /* c = remainder after dividing b by a\n  * Least significant integer quotient bits left in equot[].\n  */\n-void \n+\n+static void \n eremain (a, b, c)\n      unsigned EMUSHORT a[], b[], c[];\n {\n@@ -5142,7 +5240,7 @@ eremain (a, b, c)\n   emovo (num, c);\n }\n \n-void \n+static void \n eiremain (den, num)\n      unsigned EMUSHORT den[], num[];\n {\n@@ -5252,7 +5350,7 @@ static char *ermsg[NMSGS] =\n int merror = 0;\n extern int merror;\n \n-void \n+static void \n mtherr (name, code)\n      char *name;\n      int code;\n@@ -5291,7 +5389,8 @@ mtherr (name, code)\n ;\tEMUSHORT e[NE];\n ;\tdectoe (&d, e);\n */\n-void \n+\n+static void \n dectoe (d, e)\n      unsigned EMUSHORT *d;\n      unsigned EMUSHORT *e;\n@@ -5338,7 +5437,7 @@ dectoe (d, e)\n ;\tetodec (e, &d);\n */\n \n-void \n+static void \n etodec (x, d)\n      unsigned EMUSHORT *x, *d;\n {\n@@ -5356,7 +5455,7 @@ etodec (x, d)\n   todec (xi, d);\n }\n \n-void \n+static void \n todec (x, y)\n      unsigned EMUSHORT *x, *y;\n {\n@@ -5411,7 +5510,8 @@ todec (x, y)\n ;\tenum machine_mode mode;\tSFmode/DFmode\n ;\tibmtoe (&d, e, mode);\n */\n-void \n+\n+static void \n ibmtoe (d, e, mode)\n      unsigned EMUSHORT *d;\n      unsigned EMUSHORT *e;\n@@ -5461,7 +5561,7 @@ ibmtoe (d, e, mode)\n ;\tetoibm (e, &d, mode);\n */\n \n-void \n+static void \n etoibm (x, d, mode)\n      unsigned EMUSHORT *x, *d;\n      enum machine_mode mode;\n@@ -5480,7 +5580,7 @@ etoibm (x, d, mode)\n   toibm (xi, d, mode);\n }\n \n-void \n+static void \n toibm (x, y, mode)\n      unsigned EMUSHORT *x, *y;\n      enum machine_mode mode;\n@@ -5585,11 +5685,11 @@ unsigned EMUSHORT SFnan[2] = {0, 0xffc0};\n #endif\n \n \n-void\n+static void\n make_nan (nan, sign, mode)\n-unsigned EMUSHORT *nan;\n-int sign;\n-enum machine_mode mode;\n+     unsigned EMUSHORT *nan;\n+     int sign;\n+     enum machine_mode mode;\n {\n   int n;\n   unsigned EMUSHORT *p;\n@@ -5700,7 +5800,7 @@ ereal_from_double (d)\n    The endian-ness of DImode follows the convention for integers,\n    so we use WORDS_BIG_ENDIAN here, not FLOAT_WORDS_BIG_ENDIAN.  */\n \n-void\n+static void\n uditoe (di, e)\n      unsigned EMUSHORT *di;  /* Address of the 64-bit int. */\n      unsigned EMUSHORT *e;\n@@ -5726,7 +5826,7 @@ uditoe (di, e)\n \n /* Convert target computer signed 64-bit integer to e-type. */\n \n-void\n+static void\n ditoe (di, e)\n      unsigned EMUSHORT *di;  /* Address of the 64-bit int. */\n      unsigned EMUSHORT *e;\n@@ -5773,7 +5873,7 @@ ditoe (di, e)\n /* Convert e-type to unsigned 64-bit int. */\n \n void \n-etoudi (x, i)\n+static etoudi (x, i)\n      unsigned EMUSHORT *x;\n      unsigned EMUSHORT *i;\n {\n@@ -5852,7 +5952,7 @@ etoudi (x, i)\n \n /* Convert e-type to signed 64-bit int. */\n \n-void \n+static void \n etodi (x, i)\n      unsigned EMUSHORT *x;\n      unsigned EMUSHORT *i;\n@@ -5953,7 +6053,7 @@ etodi (x, i)\n static int esqinited = 0;\n static unsigned short sqrndbit[NI];\n \n-void \n+static void \n esqrt (x, y)\n      unsigned EMUSHORT *x, *y;\n {"}]}