{"sha": "f78c3290cdcd5328d1924935806f8ef24d7f7788", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc4YzMyOTBjZGNkNTMyOGQxOTI0OTM1ODA2ZjhlZjI0ZDdmNzc4OA==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2008-06-26T20:12:41Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2008-06-26T20:12:41Z"}, "message": "rs6000.c (emit_allocate_stack): Add copy_r11 parameter.\n\n\t* config/rs6000/rs6000.c (emit_allocate_stack): Add copy_r11\n\tparameter.  Copy stack_reg to r11 where appropriate.\n\t(no_global_regs_above): Add gpr parameter.\n\t(rs6000_stack_info): Only add padding for SPE save area if we\n\tare saving SPE GPRs and CR.\n\t(saveres_routine_syms): New variable.\n\t(FIRST_SAVRES_REGISTER, LAST_SAVRES_REGISTER, N_SAVRES_REGISTERS):\n\tDefine.\n\t(rs6000_savres_routine_sym): New function.\n\t(rs6000_emit_stack_reset, rs6000_restore_saved_cr): New functions,\n\tsplit out of...\n\t(rs6000_emit_epilogue): ...here.  Use rs6000_use_multiple_p and\n\trs6000_savres_strategy.  Restore GPRs out-of-line if appropriate.\n\tTweak FPR out-of-line saving.\n\t(rs6000_make_savres_rtx): New function.\n\t(rs6000_use_multiple_p): New function.\n\t(rs6000_savres_strategy): New function.\n\t(rs6000_emit_prologue): Use rs6000_savres_strategy.  Save GPRs\n\tout-of-line if appropriate.\n\t* config/rs6000/sysv4.h (FP_SAVE_INLINE): Save FPRs out-of-line\n\tif we are optimizing for size.\n\t(GP_SAVE_INLINE): Define.\n\t(SAVE_FP_SUFFIX, RESTORE_FP_SUFFIX): Only use _l on 64-bit targets.\n\t* config/rs6000/darwin.h (GP_SAVE_INLINE): Define.\n\t* config/rs6000/aix.h (GP_SAVE_INLINE): Define.\n\t* config/rs6000/rs6000.md (*save_gpregs_<mode>): New insn.\n\t(*save_fpregs_<mode>): Add use of r11.\n\t(*restore_gpregs_<mode>): New insn.\n\t(*return_and_restore_gpregs_<mode>): New insn.\n\t(*return_and_restore_fpregs_<mode>): Adjust to clobber LR and\n\tuse r11.\n\t* config/rs6000/spe.md (*save_gpregs_spe): New insn.\n\t(*restore_gpregs_spe): New insn.\n\t(*return_and_restore_gpregs_spe): New insn.\n\t* config/rs6000/predicates.md (save_world_operation): Fix check.\n\nFrom-SVN: r137160", "tree": {"sha": "a4b578b731cb2590f6903b103e988eaafd60303a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4b578b731cb2590f6903b103e988eaafd60303a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f78c3290cdcd5328d1924935806f8ef24d7f7788", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f78c3290cdcd5328d1924935806f8ef24d7f7788", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f78c3290cdcd5328d1924935806f8ef24d7f7788", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f78c3290cdcd5328d1924935806f8ef24d7f7788/comments", "author": null, "committer": null, "parents": [{"sha": "e24c4814fd36bb95521e729c648daee92c716a92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e24c4814fd36bb95521e729c648daee92c716a92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e24c4814fd36bb95521e729c648daee92c716a92"}], "stats": {"total": 1147, "additions": 746, "deletions": 401}, "files": [{"sha": "c6570991875770db903b952605c2a60756dea94a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78c3290cdcd5328d1924935806f8ef24d7f7788/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78c3290cdcd5328d1924935806f8ef24d7f7788/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f78c3290cdcd5328d1924935806f8ef24d7f7788", "patch": "@@ -1,3 +1,41 @@\n+2008-06-26  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* config/rs6000/rs6000.c (emit_allocate_stack): Add copy_r11\n+\tparameter.  Copy stack_reg to r11 where appropriate.\n+\t(no_global_regs_above): Add gpr parameter.\n+\t(rs6000_stack_info): Only add padding for SPE save area if we\n+\tare saving SPE GPRs and CR.\n+\t(saveres_routine_syms): New variable.\n+\t(FIRST_SAVRES_REGISTER, LAST_SAVRES_REGISTER, N_SAVRES_REGISTERS):\n+\tDefine.\n+\t(rs6000_savres_routine_sym): New function.\n+\t(rs6000_emit_stack_reset, rs6000_restore_saved_cr): New functions,\n+\tsplit out of...\n+\t(rs6000_emit_epilogue): ...here.  Use rs6000_use_multiple_p and\n+\trs6000_savres_strategy.  Restore GPRs out-of-line if appropriate.\n+\tTweak FPR out-of-line saving.\n+\t(rs6000_make_savres_rtx): New function.\n+\t(rs6000_use_multiple_p): New function.\n+\t(rs6000_savres_strategy): New function.\n+\t(rs6000_emit_prologue): Use rs6000_savres_strategy.  Save GPRs\n+\tout-of-line if appropriate.\n+\t* config/rs6000/sysv4.h (FP_SAVE_INLINE): Save FPRs out-of-line\n+\tif we are optimizing for size.\n+\t(GP_SAVE_INLINE): Define.\n+\t(SAVE_FP_SUFFIX, RESTORE_FP_SUFFIX): Only use _l on 64-bit targets.\n+\t* config/rs6000/darwin.h (GP_SAVE_INLINE): Define.\n+\t* config/rs6000/aix.h (GP_SAVE_INLINE): Define.\n+\t* config/rs6000/rs6000.md (*save_gpregs_<mode>): New insn.\n+\t(*save_fpregs_<mode>): Add use of r11.\n+\t(*restore_gpregs_<mode>): New insn.\n+\t(*return_and_restore_gpregs_<mode>): New insn.\n+\t(*return_and_restore_fpregs_<mode>): Adjust to clobber LR and\n+\tuse r11.\n+\t* config/rs6000/spe.md (*save_gpregs_spe): New insn.\n+\t(*restore_gpregs_spe): New insn.\n+\t(*return_and_restore_gpregs_spe): New insn.\n+\t* config/rs6000/predicates.md (save_world_operation): Fix check.\n+\n 2008-06-26  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* tree-into-ssa (insert_phi_nodes_for): 'var' must be a DECL at"}, {"sha": "48072988f33b22598c4878e4bbdb3297f0342a55", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78c3290cdcd5328d1924935806f8ef24d7f7788/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78c3290cdcd5328d1924935806f8ef24d7f7788/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=f78c3290cdcd5328d1924935806f8ef24d7f7788", "patch": "@@ -201,6 +201,8 @@\n \n /* Define cutoff for using external functions to save floating point.  */\n #define FP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) == 62 || (FIRST_REG) == 63)\n+/* And similarly for general purpose registers.  */\n+#define GP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) < 32)\n \n /* __throw will restore its own return address to be the same as the\n    return address of the function that the throw is being made to."}, {"sha": "d8550c86dfb1aec3e9ffedabeb66b97911ca10f7", "filename": "gcc/config/rs6000/darwin.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78c3290cdcd5328d1924935806f8ef24d7f7788/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78c3290cdcd5328d1924935806f8ef24d7f7788/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.h?ref=f78c3290cdcd5328d1924935806f8ef24d7f7788", "patch": "@@ -191,6 +191,8 @@\n \n #undef\tFP_SAVE_INLINE\n #define FP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) < 64)\n+#undef GP_SAVE_INLINE\n+#define GP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) < 32)\n \n /* Darwin uses a function call if everything needs to be saved/restored.  */\n #undef WORLD_SAVE_P"}, {"sha": "98cbdc64f91b0086980a1f3a053f7ec9b8920d95", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78c3290cdcd5328d1924935806f8ef24d7f7788/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78c3290cdcd5328d1924935806f8ef24d7f7788/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=f78c3290cdcd5328d1924935806f8ef24d7f7788", "patch": "@@ -912,7 +912,7 @@\n   rtx elt;\n   int count = XVECLEN (op, 0);\n \n-  if (count != 55)\n+  if (count != 54)\n     return 0;\n \n   index = 0;\n@@ -961,9 +961,8 @@\n       || GET_MODE (SET_SRC (elt)) != Pmode)\n     return 0;\n \n-  if (GET_CODE (XVECEXP (op, 0, index++)) != USE\n-      || GET_CODE (XVECEXP (op, 0, index++)) != USE\n-      || GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER)\n+  if (GET_CODE (XVECEXP (op, 0, index++)) != SET\n+      || GET_CODE (XVECEXP (op, 0, index++)) != SET)\n     return 0;\n   return 1;\n })"}, {"sha": "5fd021d2fa561e283c80dae2b7d04b15e9fc24e3", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 601, "deletions": 254, "changes": 855, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78c3290cdcd5328d1924935806f8ef24d7f7788/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78c3290cdcd5328d1924935806f8ef24d7f7788/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f78c3290cdcd5328d1924935806f8ef24d7f7788", "patch": "@@ -742,7 +742,7 @@ static bool spe_func_has_64bit_regs_p (void);\n static void emit_frame_save (rtx, rtx, enum machine_mode, unsigned int,\n \t\t\t     int, HOST_WIDE_INT);\n static rtx gen_frame_mem_offset (enum machine_mode, rtx, int);\n-static void rs6000_emit_allocate_stack (HOST_WIDE_INT, int);\n+static void rs6000_emit_allocate_stack (HOST_WIDE_INT, int, int);\n static unsigned rs6000_hash_constant (rtx);\n static unsigned toc_hash_function (const void *);\n static int toc_hash_eq (const void *, const void *);\n@@ -752,7 +752,7 @@ static bool legitimate_small_data_p (enum machine_mode, rtx);\n static bool legitimate_lo_sum_address_p (enum machine_mode, rtx, int);\n static struct machine_function * rs6000_init_machine_status (void);\n static bool rs6000_assemble_integer (rtx, unsigned int, int);\n-static bool no_global_regs_above (int);\n+static bool no_global_regs_above (int, bool);\n #ifdef HAVE_GAS_HIDDEN\n static void rs6000_assemble_visibility (tree, int);\n #endif\n@@ -765,7 +765,13 @@ static void rs6000_eliminate_indexed_memrefs (rtx operands[2]);\n static const char *rs6000_mangle_type (const_tree);\n extern const struct attribute_spec rs6000_attribute_table[];\n static void rs6000_set_default_type_attributes (tree);\n+static rtx rs6000_savres_routine_sym (rs6000_stack_t *, bool, bool, bool);\n+static void rs6000_emit_stack_reset (rs6000_stack_t *, rtx, rtx, int, bool);\n+static rtx rs6000_make_savres_rtx (rs6000_stack_t *, rtx, int,\n+\t\t\t\t   enum machine_mode, bool, bool, bool);\n static bool rs6000_reg_live_or_pic_offset_p (int);\n+static int rs6000_savres_strategy (rs6000_stack_t *, bool, int, int);\n+static void rs6000_restore_saved_cr (rtx, int);\n static void rs6000_output_function_prologue (FILE *, HOST_WIDE_INT);\n static void rs6000_output_function_epilogue (FILE *, HOST_WIDE_INT);\n static void rs6000_output_mi_thunk (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT,\n@@ -14608,7 +14614,7 @@ rs6000_stack_info (void)\n \t{\n \t  /* Align stack so SPE GPR save area is aligned on a\n \t     double-word boundary.  */\n-\t  if (info_ptr->spe_gp_size != 0)\n+\t  if (info_ptr->spe_gp_size != 0 && info_ptr->cr_save_offset != 0)\n \t    info_ptr->spe_padding_size\n \t      = 8 - (-info_ptr->cr_save_offset % 8);\n \t  else\n@@ -15263,10 +15269,12 @@ rs6000_emit_stack_tie (void)\n \n /* Emit the correct code for allocating stack space, as insns.\n    If COPY_R12, make sure a copy of the old frame is left in r12.\n+   If COPY_R11, make sure a copy of the old frame is left in r11,\n+   in preference to r12 if COPY_R12.\n    The generated code may use hard register 0 as a temporary.  */\n \n static void\n-rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12)\n+rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12, int copy_r11)\n {\n   rtx insn;\n   rtx stack_reg = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n@@ -15315,8 +15323,11 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12)\n \twarning (0, \"stack limit expression is not supported\");\n     }\n \n-  if (copy_r12 || ! TARGET_UPDATE)\n-    emit_move_insn (gen_rtx_REG (Pmode, 12), stack_reg);\n+  if (copy_r12 || copy_r11 || ! TARGET_UPDATE)\n+    emit_move_insn (copy_r11\n+                    ? gen_rtx_REG (Pmode, 11)\n+                    : gen_rtx_REG (Pmode, 12),\n+                    stack_reg);\n \n   if (TARGET_UPDATE)\n     {\n@@ -15342,7 +15353,9 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12)\n \t\t\t? gen_addsi3 (stack_reg, stack_reg, todec)\n \t\t\t: gen_adddi3 (stack_reg, stack_reg, todec));\n       emit_move_insn (gen_rtx_MEM (Pmode, stack_reg),\n-\t\t      gen_rtx_REG (Pmode, 12));\n+\t\t      copy_r11\n+                      ? gen_rtx_REG (Pmode, 11)\n+                      : gen_rtx_REG (Pmode, 12));\n     }\n \n   RTX_FRAME_RELATED_P (insn) = 1;\n@@ -15565,11 +15578,11 @@ gen_frame_mem_offset (enum machine_mode mode, rtx reg, int offset)\n    and cannot use stmw/lmw if there are any in its range.  */\n \n static bool\n-no_global_regs_above (int first_greg)\n+no_global_regs_above (int first, bool gpr)\n {\n   int i;\n-  for (i = 0; i < 32 - first_greg; i++)\n-    if (global_regs[first_greg + i])\n+  for (i = first; i < gpr ? 32 : 64 ; i++)\n+    if (global_regs[i])\n       return false;\n   return true;\n }\n@@ -15578,6 +15591,163 @@ no_global_regs_above (int first_greg)\n #define TARGET_FIX_AND_CONTINUE 0\n #endif\n \n+/* It's really GPR 13 and FPR 14, but we need the smaller of the two.  */\n+#define FIRST_SAVRES_REGISTER FIRST_SAVED_GP_REGNO\n+#define LAST_SAVRES_REGISTER 31\n+#define N_SAVRES_REGISTERS (LAST_SAVRES_REGISTER - FIRST_SAVRES_REGISTER + 1)\n+\n+static GTY(()) rtx savres_routine_syms[N_SAVRES_REGISTERS][8];\n+\n+/* Return the symbol for an out-of-line register save/restore routine.\n+   We are saving/restoring GPRs if GPR is true.  */\n+\n+static rtx\n+rs6000_savres_routine_sym (rs6000_stack_t *info, bool savep, bool gpr, bool exitp)\n+{\n+  int regno = gpr ? info->first_gp_reg_save : (info->first_fp_reg_save - 32);\n+  rtx sym;\n+  int select = ((savep ? 1 : 0) << 2\n+\t\t| (gpr\n+\t\t   /* On the SPE, we never have any FPRs, but we do have\n+\t\t      32/64-bit versions of the routines.  */\n+\t\t   ? (TARGET_SPE_ABI && info->spe_64bit_regs_used ? 1 : 0)\n+\t\t   : 0) << 1\n+\t\t| (exitp ? 1: 0));\n+\n+  /* Don't generate bogus routine names.  */\n+  gcc_assert (FIRST_SAVRES_REGISTER <= regno && regno <= LAST_SAVRES_REGISTER);\n+\n+  sym = savres_routine_syms[regno-FIRST_SAVRES_REGISTER][select];\n+\n+  if (sym == NULL)\n+    {\n+      char name[30];\n+      const char *action;\n+      const char *regkind;\n+      const char *exit_suffix;\n+\n+      action = savep ? \"save\" : \"rest\";\n+\n+      /* SPE has slightly different names for its routines depending on\n+\t whether we are saving 32-bit or 64-bit registers.  */\n+      if (TARGET_SPE_ABI)\n+\t{\n+\t  /* No floating point saves on the SPE.  */\n+\t  gcc_assert (gpr);\n+\n+\t  regkind = info->spe_64bit_regs_used ? \"64gpr\" : \"32gpr\";\n+\t}\n+      else\n+\tregkind = gpr ? \"gpr\" : \"fpr\";\n+\n+      exit_suffix = exitp ? \"_x\" : \"\";\n+\n+      sprintf (name, \"_%s%s_%d%s\", action, regkind, regno, exit_suffix);\n+\n+      sym = savres_routine_syms[regno-FIRST_SAVRES_REGISTER][select]\n+\t= gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));\n+    }\n+\n+  return sym;\n+}\n+\n+/* Emit a sequence of insns, including a stack tie if needed, for\n+   resetting the stack pointer.  If SAVRES is true, then don't reset the\n+   stack pointer, but move the base of the frame into r11 for use by\n+   out-of-line register restore routines.  */\n+\n+static void\n+rs6000_emit_stack_reset (rs6000_stack_t *info,\n+\t\t\t rtx sp_reg_rtx, rtx frame_reg_rtx,\n+\t\t\t int sp_offset, bool savres)\n+{\n+  /* This blockage is needed so that sched doesn't decide to move\n+     the sp change before the register restores.  */\n+  if (frame_reg_rtx != sp_reg_rtx\n+      || (TARGET_SPE_ABI\n+\t  && info->spe_64bit_regs_used != 0\n+\t  && info->first_gp_reg_save != 32))\n+    rs6000_emit_stack_tie ();\n+  \n+  if (frame_reg_rtx != sp_reg_rtx)\n+    {\n+      rs6000_emit_stack_tie ();\n+      if (sp_offset != 0)\n+\temit_insn (gen_addsi3 (sp_reg_rtx, frame_reg_rtx,\n+\t\t\t       GEN_INT (sp_offset)));\n+      else if (!savres)\n+\temit_move_insn (sp_reg_rtx, frame_reg_rtx);\n+    }\n+  else if (sp_offset != 0)\n+    {\n+      /* If we are restoring registers out-of-line, we will be using the\n+\t \"exit\" variants of the restore routines, which will reset the\n+\t stack for us.\tBut we do need to point r11 into the right place\n+\t for those routines.  */\n+      rtx dest_reg = (savres\n+\t\t      ? gen_rtx_REG (Pmode, 11)\n+\t\t      : sp_reg_rtx);\n+\n+      emit_insn (TARGET_32BIT\n+\t\t ? gen_addsi3 (dest_reg, sp_reg_rtx,\n+\t\t\t       GEN_INT (sp_offset))\n+\t\t : gen_adddi3 (dest_reg, sp_reg_rtx,\n+\t\t\t       GEN_INT (sp_offset)));\n+    }\n+}\n+\n+/* Construct a parallel rtx describing the effect of a call to an\n+   out-of-line register save/restore routine.  */\n+\n+static rtx\n+rs6000_make_savres_rtx (rs6000_stack_t *info,\n+\t\t\trtx frame_reg_rtx, int save_area_offset,\n+\t\t\tenum machine_mode reg_mode,\n+\t\t\tbool savep, bool gpr, bool exitp)\n+{\n+  int i;\n+  int offset, start_reg, end_reg, n_regs;\n+  int reg_size = GET_MODE_SIZE (reg_mode);\n+  rtx sym;\n+  rtvec p;\n+\n+  offset = 0;\n+  start_reg = (gpr\n+\t       ? info->first_gp_reg_save\n+\t       : info->first_fp_reg_save);\n+  end_reg = gpr ? 32 : 64;\n+  n_regs = end_reg - start_reg;\n+  p = rtvec_alloc ((exitp ? 4 : 3) + n_regs);\n+\n+  /* If we're saving registers, then we should never say we're exiting.\t */\n+  gcc_assert ((savep && !exitp) || !savep);\n+\n+  if (exitp)\n+    RTVEC_ELT (p, offset++) = gen_rtx_RETURN (VOIDmode);\n+\n+  RTVEC_ELT (p, offset++)\n+    = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 65));\n+\n+  sym = rs6000_savres_routine_sym (info, savep, gpr, exitp);\n+  RTVEC_ELT (p, offset++) = gen_rtx_USE (VOIDmode, sym);\n+  RTVEC_ELT (p, offset++) = gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, 11));\n+\n+  for (i = 0; i < end_reg - start_reg; i++)\n+    {\n+      rtx addr, reg, mem;\n+      reg = gen_rtx_REG (reg_mode, start_reg + i);\n+      addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t   GEN_INT (save_area_offset + reg_size*i));\n+      mem = gen_frame_mem (reg_mode, addr);\n+\n+      RTVEC_ELT (p, i + offset) = gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t       savep ? mem : reg,\n+\t\t\t\t\t       savep ? reg : mem);\n+    }\n+\n+  return gen_rtx_PARALLEL (VOIDmode, p);\n+}\n+\n /* Determine whether the gp REG is really used.  */\n \n static bool\n@@ -15592,6 +15762,85 @@ rs6000_reg_live_or_pic_offset_p (int reg)\n                   || (DEFAULT_ABI == ABI_DARWIN && flag_pic))));\n }\n \n+enum {\n+  SAVRES_MULTIPLE = 0x1,\n+  SAVRES_INLINE_FPRS = 0x2,\n+  SAVRES_INLINE_GPRS = 0x4\n+};\n+\n+/* Determine the strategy for savings/restoring registers.  */\n+\n+static int\n+rs6000_savres_strategy (rs6000_stack_t *info, bool savep,\n+\t\t\tint using_static_chain_p, int sibcall)\n+{\n+  bool using_multiple_p;\n+  bool common;\n+  bool savres_fprs_inline;\n+  bool savres_gprs_inline;\n+  bool noclobber_global_gprs\n+    = no_global_regs_above (info->first_gp_reg_save, /*gpr=*/true);\n+\n+  using_multiple_p = (TARGET_MULTIPLE && ! TARGET_POWERPC64\n+\t\t      && (!TARGET_SPE_ABI\n+\t\t\t  || info->spe_64bit_regs_used == 0)\n+\t\t      && info->first_gp_reg_save < 31\n+\t\t      && noclobber_global_gprs);\n+  /* Don't bother to try to save things out-of-line if r11 is occupied\n+     by the static chain.  It would require too much fiddling and the\n+     static chain is rarely used anyway.  */\n+  common = (using_static_chain_p\n+\t    || sibcall\n+\t    || crtl->calls_eh_return\n+\t    || !info->lr_save_p\n+\t    || cfun->machine->ra_need_lr\n+\t    || info->total_size > 32767);\n+  savres_fprs_inline = (common\n+\t\t\t|| info->first_fp_reg_save == 64\n+\t\t\t|| !no_global_regs_above (info->first_fp_reg_save,\n+\t\t\t\t\t\t  /*gpr=*/false)\n+\t\t\t|| FP_SAVE_INLINE (info->first_fp_reg_save));\n+  savres_gprs_inline = (common\n+\t\t\t/* Saving CR interferes with the exit routines\n+\t\t\t   used on the SPE, so just punt here.  */\n+\t\t\t|| (!savep\n+\t\t\t    && TARGET_SPE_ABI\n+\t\t\t    && info->spe_64bit_regs_used != 0\n+\t\t\t    && info->cr_save_p != 0)\n+\t\t\t|| info->first_gp_reg_save == 32\n+\t\t\t|| !noclobber_global_gprs\n+\t\t\t|| GP_SAVE_INLINE (info->first_gp_reg_save));\n+\n+  if (savep)\n+    /* If we are going to use store multiple, then don't even bother\n+     with the out-of-line routines, since the store-multiple instruction\n+     will always be smaller.  */\n+    savres_gprs_inline = savres_gprs_inline || using_multiple_p;\n+  else\n+    {\n+      /* The situation is more complicated with load multiple.  We'd\n+         prefer to use the out-of-line routines for restores, since the\n+         \"exit\" out-of-line routines can handle the restore of LR and\n+         the frame teardown.  But we can only use the out-of-line\n+         routines if we know that we've used store multiple or\n+         out-of-line routines in the prologue, i.e. if we've saved all\n+         the registers from first_gp_reg_save.  Otherwise, we risk\n+         loading garbage from the stack.  Furthermore, we can only use\n+         the \"exit\" out-of-line gpr restore if we haven't saved any\n+         fprs.  */\n+      bool saved_all = !savres_gprs_inline || using_multiple_p;\n+\n+      if (saved_all && info->first_fp_reg_save != 64)\n+\t/* We can't use the exit routine; use load multiple if it's\n+\t   available.  */\n+\tsavres_gprs_inline = savres_gprs_inline || using_multiple_p;\n+    }\n+\n+  return (using_multiple_p\n+\t  | (savres_fprs_inline << 1)\n+\t  | (savres_gprs_inline << 2));\n+}\n+\n /* Emit function prologue as insns.  */\n \n void\n@@ -15605,8 +15854,13 @@ rs6000_emit_prologue (void)\n   rtx frame_reg_rtx = sp_reg_rtx;\n   rtx cr_save_rtx = NULL_RTX;\n   rtx insn;\n+  int strategy;\n   int saving_FPRs_inline;\n+  int saving_GPRs_inline;\n   int using_store_multiple;\n+  int using_static_chain_p = (cfun->static_chain_decl != NULL_TREE\n+                              && df_regs_ever_live_p (STATIC_CHAIN_REGNUM)\n+                              && !call_used_regs[STATIC_CHAIN_REGNUM]);\n   HOST_WIDE_INT sp_offset = 0;\n \n   if (TARGET_FIX_AND_CONTINUE)\n@@ -15629,33 +15883,37 @@ rs6000_emit_prologue (void)\n       reg_size = 8;\n     }\n \n-  using_store_multiple = (TARGET_MULTIPLE && ! TARGET_POWERPC64\n-\t\t\t  && (!TARGET_SPE_ABI\n-\t\t\t      || info->spe_64bit_regs_used == 0)\n-\t\t\t  && info->first_gp_reg_save < 31\n-\t\t\t  && no_global_regs_above (info->first_gp_reg_save));\n-  saving_FPRs_inline = (info->first_fp_reg_save == 64\n-\t\t\t|| FP_SAVE_INLINE (info->first_fp_reg_save)\n-\t\t\t|| crtl->calls_eh_return\n-\t\t\t|| cfun->machine->ra_need_lr);\n+  strategy = rs6000_savres_strategy (info, /*savep=*/true,\n+\t\t\t\t     /*static_chain_p=*/using_static_chain_p,\n+\t\t\t\t     /*sibcall=*/0);\n+  using_store_multiple = strategy & SAVRES_MULTIPLE;\n+  saving_FPRs_inline = strategy & SAVRES_INLINE_FPRS;\n+  saving_GPRs_inline = strategy & SAVRES_INLINE_GPRS;\n \n   /* For V.4, update stack before we do any saving and set back pointer.  */\n   if (! WORLD_SAVE_P (info)\n       && info->push_p\n       && (DEFAULT_ABI == ABI_V4\n \t  || crtl->calls_eh_return))\n     {\n+      bool need_r11 = (TARGET_SPE\n+\t\t       ? (!saving_GPRs_inline\n+\t\t\t  && info->spe_64bit_regs_used == 0)\n+\t\t       : (!saving_FPRs_inline || !saving_GPRs_inline));\n       if (info->total_size < 32767)\n \tsp_offset = info->total_size;\n       else\n-\tframe_reg_rtx = frame_ptr_rtx;\n+\tframe_reg_rtx = (need_r11\n+\t\t\t ? gen_rtx_REG (Pmode, 11)\n+\t\t\t : frame_ptr_rtx);\n       rs6000_emit_allocate_stack (info->total_size,\n \t\t\t\t  (frame_reg_rtx != sp_reg_rtx\n \t\t\t\t   && (info->cr_save_p\n \t\t\t\t       || info->lr_save_p\n \t\t\t\t       || info->first_fp_reg_save < 64\n \t\t\t\t       || info->first_gp_reg_save < 32\n-\t\t\t\t       )));\n+\t\t\t\t       )),\n+\t\t\t\t  need_r11);\n       if (frame_reg_rtx != sp_reg_rtx)\n \trs6000_emit_stack_tie ();\n     }\n@@ -15831,41 +16089,148 @@ rs6000_emit_prologue (void)\n \t\t\t   info->total_size);\n     }\n   else if (!WORLD_SAVE_P (info) && info->first_fp_reg_save != 64)\n+    {\n+      rtx par;\n+\n+      par = rs6000_make_savres_rtx (info, frame_reg_rtx,\n+\t\t\t\t    info->fp_save_offset + sp_offset,\n+\t\t\t\t    DFmode,\n+\t\t\t\t    /*savep=*/true, /*gpr=*/false,\n+\t\t\t\t    /*exitp=*/false);\n+      insn = emit_insn (par);\n+      rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n+\t\t\t    NULL_RTX, NULL_RTX);\n+    }\n+\n+  /* Save GPRs.  This is done as a PARALLEL if we are using\n+     the store-multiple instructions.  */\n+  if (!WORLD_SAVE_P (info)\n+      && TARGET_SPE_ABI\n+      && info->spe_64bit_regs_used != 0\n+      && info->first_gp_reg_save != 32)\n     {\n       int i;\n-      char rname[30];\n-      const char *alloc_rname;\n-      rtvec p;\n-      p = rtvec_alloc (2 + 64 - info->first_fp_reg_save);\n+      rtx spe_save_area_ptr;\n+ \n+      /* Determine whether we can address all of the registers that need\n+\t to be saved with an offset from the stack pointer that fits in\n+\t the small const field for SPE memory instructions.  */\n+      int spe_regs_addressable_via_sp\n+\t= (SPE_CONST_OFFSET_OK(info->spe_gp_save_offset + sp_offset\n+\t\t\t       + (32 - info->first_gp_reg_save - 1) * reg_size)\n+\t   && saving_GPRs_inline);\n+      int spe_offset;\n+ \n+      if (spe_regs_addressable_via_sp)\n+\t{\n+\t  spe_save_area_ptr = frame_reg_rtx;\n+\t  spe_offset = info->spe_gp_save_offset + sp_offset;\n+\t}\n+      else\n+\t{\n+\t  /* Make r11 point to the start of the SPE save area.  We need\n+\t     to be careful here if r11 is holding the static chain.  If\n+\t     it is, then temporarily save it in r0.  We would use r0 as\n+\t     our base register here, but using r0 as a base register in\n+\t     loads and stores means something different from what we\n+\t     would like.  */\n+\t  int ool_adjust = (saving_GPRs_inline\n+\t\t\t    ? 0\n+\t\t\t    : (info->first_gp_reg_save\n+\t\t\t       - (FIRST_SAVRES_REGISTER+1))*8);\n+\t  HOST_WIDE_INT offset = (info->spe_gp_save_offset\n+\t\t\t\t  + sp_offset - ool_adjust);\n+\n+\t  if (using_static_chain_p)\n+\t    {\n+\t      rtx r0 = gen_rtx_REG (Pmode, 0);\n+\t      gcc_assert (info->first_gp_reg_save > 11);\n+ \n+\t      emit_move_insn (r0, gen_rtx_REG (Pmode, 11));\n+\t    }\n+ \n+\t  spe_save_area_ptr = gen_rtx_REG (Pmode, 11);\n+\t  insn = emit_insn (gen_addsi3 (spe_save_area_ptr,\n+\t\t\t\t\tframe_reg_rtx,\n+\t\t\t\t\tGEN_INT (offset)));\n+\t  /* We need to make sure the move to r11 gets noted for\n+\t     properly outputting unwind information.  */\n+\t  if (!saving_GPRs_inline)\n+\t    rs6000_frame_related (insn, frame_reg_rtx, offset,\n+\t\t\t\t  NULL_RTX, NULL_RTX);\n+\t  spe_offset = 0;\n+\t}\n+ \n+      if (saving_GPRs_inline)\n+\t{\n+\t  for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n+\t    if (rs6000_reg_live_or_pic_offset_p (info->first_gp_reg_save + i))\n+\t      {\n+\t\trtx reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n+\t\trtx offset, addr, mem;\n \n-      RTVEC_ELT (p, 0) = gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t  gen_rtx_REG (Pmode,\n-\t\t\t\t\t\t       LR_REGNO));\n-      sprintf (rname, \"%s%d%s\", SAVE_FP_PREFIX,\n-\t       info->first_fp_reg_save - 32, SAVE_FP_SUFFIX);\n-      alloc_rname = ggc_strdup (rname);\n-      RTVEC_ELT (p, 1) = gen_rtx_USE (VOIDmode,\n-\t\t\t\t      gen_rtx_SYMBOL_REF (Pmode,\n-\t\t\t\t\t\t\t  alloc_rname));\n-      for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n+\t\t/* We're doing all this to ensure that the offset fits into\n+\t\t   the immediate offset of 'evstdd'.  */\n+\t\tgcc_assert (SPE_CONST_OFFSET_OK (reg_size * i + spe_offset));\n+ \n+\t\toffset = GEN_INT (reg_size * i + spe_offset);\n+\t\taddr = gen_rtx_PLUS (Pmode, spe_save_area_ptr, offset);\n+\t\tmem = gen_rtx_MEM (V2SImode, addr);\n+  \n+\t\tinsn = emit_move_insn (mem, reg);\n+\t   \n+\t\trs6000_frame_related (insn, spe_save_area_ptr,\n+\t\t\t\t      info->spe_gp_save_offset\n+\t\t\t\t      + sp_offset + reg_size * i,\n+\t\t\t\t      offset, const0_rtx);\n+\t      }\n+\t}\n+      else\n \t{\n-\t  rtx addr, reg, mem;\n-\t  reg = gen_rtx_REG (DFmode, info->first_fp_reg_save + i);\n-\t  addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t       GEN_INT (info->fp_save_offset\n-\t\t\t\t\t+ sp_offset + 8*i));\n-\t  mem = gen_frame_mem (DFmode, addr);\n+\t  rtx par;\n \n-\t  RTVEC_ELT (p, i + 2) = gen_rtx_SET (VOIDmode, mem, reg);\n+\t  par = rs6000_make_savres_rtx (info, gen_rtx_REG (Pmode, 11),\n+\t\t\t\t\t0, reg_mode,\n+\t\t\t\t\t/*savep=*/true, /*gpr=*/true,\n+\t\t\t\t\t/*exitp=*/false);\n+\t  insn = emit_insn (par);\n+\t  rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n+\t\t\t\tNULL_RTX, NULL_RTX);\n \t}\n-      insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n+\t\t\t\t\t\n+ \n+      /* Move the static chain pointer back.  */\n+      if (using_static_chain_p && !spe_regs_addressable_via_sp)\n+\temit_move_insn (gen_rtx_REG (Pmode, 11), gen_rtx_REG (Pmode, 0));\n+    }\n+  else if (!WORLD_SAVE_P (info) && !saving_GPRs_inline)\n+    {\n+      rtx par;\n+\n+      /* Need to adjust r11 if we saved any FPRs.  */\n+      if (info->first_fp_reg_save != 64)\n+        {\n+          rtx r11 = gen_rtx_REG (reg_mode, 11);\n+          rtx offset = GEN_INT (info->total_size\n+                                + (-8 * (64-info->first_fp_reg_save)));\n+          rtx ptr_reg = (sp_reg_rtx == frame_reg_rtx\n+                         ? sp_reg_rtx : r11);\n+\n+          emit_insn (TARGET_32BIT\n+                     ? gen_addsi3 (r11, ptr_reg, offset)\n+                     : gen_adddi3 (r11, ptr_reg, offset));\n+        }\n+\n+      par = rs6000_make_savres_rtx (info, frame_reg_rtx,\n+\t\t\t\t    info->gp_save_offset + sp_offset,\n+\t\t\t\t    reg_mode,\n+\t\t\t\t    /*savep=*/true, /*gpr=*/true,\n+\t\t\t\t    /*exitp=*/false);\n+      insn = emit_insn (par);\n       rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n \t\t\t    NULL_RTX, NULL_RTX);\n     }\n-\n-  /* Save GPRs.  This is done as a PARALLEL if we are using\n-     the store-multiple instructions.  */\n-  if (!WORLD_SAVE_P (info) && using_store_multiple)\n+  else if (!WORLD_SAVE_P (info) && using_store_multiple)\n     {\n       rtvec p;\n       int i;\n@@ -15886,80 +16251,6 @@ rs6000_emit_prologue (void)\n       rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n \t\t\t    NULL_RTX, NULL_RTX);\n     }\n-   else if (!WORLD_SAVE_P (info)\n-            && TARGET_SPE_ABI\n-            && info->spe_64bit_regs_used != 0\n-            && info->first_gp_reg_save != 32)\n-     {\n-       int i;\n-       rtx spe_save_area_ptr;\n-       int using_static_chain_p = (cfun->static_chain_decl != NULL_TREE\n-                                   && df_regs_ever_live_p (STATIC_CHAIN_REGNUM)\n-                                   && !call_used_regs[STATIC_CHAIN_REGNUM]);\n- \n-       /* Determine whether we can address all of the registers that need\n-          to be saved with an offset from the stack pointer that fits in\n-          the small const field for SPE memory instructions.  */\n-       int spe_regs_addressable_via_sp\n-         = SPE_CONST_OFFSET_OK(info->spe_gp_save_offset + sp_offset\n-                               + (32 - info->first_gp_reg_save - 1) * reg_size);\n-       int spe_offset;\n- \n-       if (spe_regs_addressable_via_sp)\n-         {\n-           spe_save_area_ptr = frame_reg_rtx;\n-           spe_offset = info->spe_gp_save_offset + sp_offset;\n-         }\n-       else\n-         {\n-           /* Make r11 point to the start of the SPE save area.  We need\n-              to be careful here if r11 is holding the static chain.  If\n-              it is, then temporarily save it in r0.  We would use r0 as\n-              our base register here, but using r0 as a base register in\n-              loads and stores means something different from what we\n-              would like.  */\n-           if (using_static_chain_p)\n-             {\n-               rtx r0 = gen_rtx_REG (Pmode, 0);\n- \n-               gcc_assert (info->first_gp_reg_save > 11);\n- \n-               emit_move_insn (r0, gen_rtx_REG (Pmode, 11));\n-             }\n- \n-           spe_save_area_ptr = gen_rtx_REG (Pmode, 11);\n-           emit_insn (gen_addsi3 (spe_save_area_ptr, frame_reg_rtx,\n-                                  GEN_INT (info->spe_gp_save_offset + sp_offset)));\n- \n-           spe_offset = 0;\n-         }\n- \n-       for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n-         if (rs6000_reg_live_or_pic_offset_p (info->first_gp_reg_save + i))\n-           {\n-             rtx reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n-             rtx offset, addr, mem;\n- \n-             /* We're doing all this to ensure that the offset fits into\n-                the immediate offset of 'evstdd'.  */\n-             gcc_assert (SPE_CONST_OFFSET_OK (reg_size * i + spe_offset));\n- \n-             offset = GEN_INT (reg_size * i + spe_offset);\n-             addr = gen_rtx_PLUS (Pmode, spe_save_area_ptr, offset);\n-             mem = gen_rtx_MEM (V2SImode, addr);\n- \n-             insn = emit_move_insn (mem, reg);\n-           \n-             rs6000_frame_related (insn, spe_save_area_ptr,\n-                                   info->spe_gp_save_offset\n-                                   + sp_offset + reg_size * i,\n-                                   offset, const0_rtx);\n-           }\n- \n-       /* Move the static chain pointer back.  */\n-       if (using_static_chain_p && !spe_regs_addressable_via_sp)\n-         emit_move_insn (gen_rtx_REG (Pmode, 11), gen_rtx_REG (Pmode, 0));\n-     }\n   else if (!WORLD_SAVE_P (info))\n     {\n       int i;\n@@ -16059,7 +16350,8 @@ rs6000_emit_prologue (void)\n \t\t\t\t  (frame_reg_rtx != sp_reg_rtx\n \t\t\t\t   && ((info->altivec_size != 0)\n \t\t\t\t       || (info->vrsave_mask != 0)\n-\t\t\t\t       )));\n+\t\t\t\t       )),\n+\t\t\t\t  FALSE);\n       if (frame_reg_rtx != sp_reg_rtx)\n \trs6000_emit_stack_tie ();\n     }\n@@ -16215,8 +16507,7 @@ rs6000_output_function_prologue (FILE *file,\n       && !FP_SAVE_INLINE (info->first_fp_reg_save))\n     fprintf (file, \"\\t.extern %s%d%s\\n\\t.extern %s%d%s\\n\",\n \t     SAVE_FP_PREFIX, info->first_fp_reg_save - 32, SAVE_FP_SUFFIX,\n-\t     RESTORE_FP_PREFIX, info->first_fp_reg_save - 32,\n-\t     RESTORE_FP_SUFFIX);\n+\t     RESTORE_FP_PREFIX, info->first_fp_reg_save - 32, RESTORE_FP_SUFFIX);\n \n   /* Write .extern for AIX common mode routines, if needed.  */\n   if (! TARGET_POWER && ! TARGET_POWERPC && ! common_mode_defined)\n@@ -16264,6 +16555,54 @@ rs6000_output_function_prologue (FILE *file,\n    we restore after the pop when possible.  */\n #define ALWAYS_RESTORE_ALTIVEC_BEFORE_POP 0\n \n+/* Reload CR from REG.  */\n+\n+static void\n+rs6000_restore_saved_cr (rtx reg, int using_mfcr_multiple)\n+{\n+  int count = 0;\n+  int i;\n+\n+  if (using_mfcr_multiple)\n+    {\n+      for (i = 0; i < 8; i++)\n+\tif (df_regs_ever_live_p (CR0_REGNO+i) && ! call_used_regs[CR0_REGNO+i])\n+\t  count++;\n+      gcc_assert (count);\n+    }\n+\n+  if (using_mfcr_multiple && count > 1)\n+    {\n+      rtvec p;\n+      int ndx;\n+\n+      p = rtvec_alloc (count);\n+\n+      ndx = 0;\n+      for (i = 0; i < 8; i++)\n+\tif (df_regs_ever_live_p (CR0_REGNO+i) && ! call_used_regs[CR0_REGNO+i])\n+\t  {\n+\t    rtvec r = rtvec_alloc (2);\n+\t    RTVEC_ELT (r, 0) = reg;\n+\t    RTVEC_ELT (r, 1) = GEN_INT (1 << (7-i));\n+\t    RTVEC_ELT (p, ndx) =\n+\t      gen_rtx_SET (VOIDmode, gen_rtx_REG (CCmode, CR0_REGNO+i),\n+\t\t\t   gen_rtx_UNSPEC (CCmode, r, UNSPEC_MOVESI_TO_CR));\n+\t    ndx++;\n+\t  }\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n+      gcc_assert (ndx == count);\n+    }\n+  else\n+    for (i = 0; i < 8; i++)\n+      if (df_regs_ever_live_p (CR0_REGNO+i) && ! call_used_regs[CR0_REGNO+i])\n+\t{\n+\t  emit_insn (gen_movsi_to_cr_one (gen_rtx_REG (CCmode,\n+\t\t\t\t\t\t       CR0_REGNO+i),\n+\t\t\t\t\t  reg));\n+\t}\n+}\n+\n /* Emit function epilogue as insns.\n \n    At present, dwarf2out_frame_debug_expr doesn't understand\n@@ -16275,10 +16614,13 @@ void\n rs6000_emit_epilogue (int sibcall)\n {\n   rs6000_stack_t *info;\n+  int restoring_GPRs_inline;\n   int restoring_FPRs_inline;\n   int using_load_multiple;\n   int using_mtcr_multiple;\n   int use_backchain_to_restore_sp;\n+  int restore_lr;\n+  int strategy;\n   int sp_offset = 0;\n   rtx sp_reg_rtx = gen_rtx_REG (Pmode, 1);\n   rtx frame_reg_rtx = sp_reg_rtx;\n@@ -16294,15 +16636,11 @@ rs6000_emit_epilogue (int sibcall)\n       reg_size = 8;\n     }\n \n-  using_load_multiple = (TARGET_MULTIPLE && ! TARGET_POWERPC64\n-\t\t\t && (!TARGET_SPE_ABI\n-\t\t\t     || info->spe_64bit_regs_used == 0)\n-\t\t\t && info->first_gp_reg_save < 31\n-\t\t\t && no_global_regs_above (info->first_gp_reg_save));\n-  restoring_FPRs_inline = (sibcall\n-\t\t\t   || crtl->calls_eh_return\n-\t\t\t   || info->first_fp_reg_save == 64\n-\t\t\t   || FP_SAVE_INLINE (info->first_fp_reg_save));\n+  strategy = rs6000_savres_strategy (info, /*savep=*/false,\n+\t\t\t\t     /*static_chain_p=*/0, sibcall);\n+  using_load_multiple = strategy & SAVRES_MULTIPLE;\n+  restoring_FPRs_inline = strategy & SAVRES_INLINE_FPRS;\n+  restoring_GPRs_inline = strategy & SAVRES_INLINE_GPRS;\n   using_mtcr_multiple = (rs6000_cpu == PROCESSOR_PPC601\n \t\t\t || rs6000_cpu == PROCESSOR_PPC603\n \t\t\t || rs6000_cpu == PROCESSOR_PPC750\n@@ -16318,6 +16656,9 @@ rs6000_emit_epilogue (int sibcall)\n \t\t\t\t       > 32767\n \t\t\t\t || (cfun->calls_alloca\n \t\t\t\t     && !frame_pointer_needed));\n+  restore_lr = (info->lr_save_p\n+\t\t&& restoring_GPRs_inline\n+\t\t&& restoring_FPRs_inline);\n \n   if (WORLD_SAVE_P (info))\n     {\n@@ -16584,8 +16925,9 @@ rs6000_emit_epilogue (int sibcall)\n       emit_insn (generate_set_vrsave (reg, info, 1));\n     }\n \n-  /* Get the old lr if we saved it.  */\n-  if (info->lr_save_p)\n+  /* Get the old lr if we saved it.  If we are restoring registers\n+     out-of-line, then the out-of-line routines can do this for us.  */\n+  if (restore_lr)\n     {\n       rtx mem = gen_frame_mem_offset (Pmode, frame_reg_rtx,\n \t\t\t\t      info->lr_save_offset + sp_offset);\n@@ -16604,7 +16946,7 @@ rs6000_emit_epilogue (int sibcall)\n     }\n \n   /* Set LR here to try to overlap restores below.  */\n-  if (info->lr_save_p)\n+  if (restore_lr)\n     emit_move_insn (gen_rtx_REG (Pmode, LR_REGNO),\n \t\t    gen_rtx_REG (Pmode, 0));\n \n@@ -16640,35 +16982,17 @@ rs6000_emit_epilogue (int sibcall)\n \n   /* Restore GPRs.  This is done as a PARALLEL if we are using\n      the load-multiple instructions.  */\n-  if (using_load_multiple)\n-    {\n-      rtvec p;\n-      p = rtvec_alloc (32 - info->first_gp_reg_save);\n-      for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n-\t{\n-\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t\t   GEN_INT (info->gp_save_offset\n-\t\t\t\t\t    + sp_offset\n-\t\t\t\t\t    + reg_size * i));\n-\t  rtx mem = gen_frame_mem (reg_mode, addr);\n-\n-\t  RTVEC_ELT (p, i) =\n-\t    gen_rtx_SET (VOIDmode,\n-\t\t\t gen_rtx_REG (reg_mode, info->first_gp_reg_save + i),\n-\t\t\t mem);\n-\t}\n-      emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n-    }\n-  else if (TARGET_SPE_ABI\n-           && info->spe_64bit_regs_used != 0\n-           && info->first_gp_reg_save != 32)\n+  if (TARGET_SPE_ABI\n+      && info->spe_64bit_regs_used != 0\n+      && info->first_gp_reg_save != 32)\n     {\n       /* Determine whether we can address all of the registers that need\n          to be saved with an offset from the stack pointer that fits in\n          the small const field for SPE memory instructions.  */\n       int spe_regs_addressable_via_sp\n-        = SPE_CONST_OFFSET_OK(info->spe_gp_save_offset + sp_offset\n-                              + (32 - info->first_gp_reg_save - 1) * reg_size);\n+\t= (SPE_CONST_OFFSET_OK(info->spe_gp_save_offset + sp_offset\n+\t\t\t       + (32 - info->first_gp_reg_save - 1) * reg_size)\n+\t   && restoring_GPRs_inline);\n       int spe_offset;\n \n       if (spe_regs_addressable_via_sp)\n@@ -16680,47 +17004,127 @@ rs6000_emit_epilogue (int sibcall)\n              not clobbering it when we were saving registers in the prologue.\n              There's no need to worry here because the static chain is passed\n              anew to every function.  */\n+\t  int ool_adjust = (restoring_GPRs_inline\n+\t\t\t    ? 0\n+\t\t\t    : (info->first_gp_reg_save\n+\t\t\t       - (FIRST_SAVRES_REGISTER+1))*8);\n+\n \t  if (frame_reg_rtx == sp_reg_rtx)\n \t    frame_reg_rtx = gen_rtx_REG (Pmode, 11);\n           emit_insn (gen_addsi3 (frame_reg_rtx, old_frame_reg_rtx,\n-                                 GEN_INT (info->spe_gp_save_offset + sp_offset)));\n+\t\t\t\t GEN_INT (info->spe_gp_save_offset\n+\t\t\t\t\t  + sp_offset\n+\t\t\t\t\t  - ool_adjust)));\n \t  /* Keep the invariant that frame_reg_rtx + sp_offset points\n \t     at the top of the stack frame.  */\n \t  sp_offset = -info->spe_gp_save_offset;\n \n           spe_offset = 0;\n         }\n \n-      for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n-        if (rs6000_reg_live_or_pic_offset_p (info->first_gp_reg_save + i))\n-          {\n-            rtx offset, addr, mem;\n+      if (restoring_GPRs_inline)\n+\t{\n+\t  for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n+\t    if (rs6000_reg_live_or_pic_offset_p (info->first_gp_reg_save + i))\n+\t      {\n+\t\trtx offset, addr, mem;\n \n-            /* We're doing all this to ensure that the immediate offset\n-               fits into the immediate field of 'evldd'.  */\n-            gcc_assert (SPE_CONST_OFFSET_OK (spe_offset + reg_size * i));\n+\t\t/* We're doing all this to ensure that the immediate offset\n+\t\t   fits into the immediate field of 'evldd'.  */\n+\t\tgcc_assert (SPE_CONST_OFFSET_OK (spe_offset + reg_size * i));\n \n-            offset = GEN_INT (spe_offset + reg_size * i);\n-            addr = gen_rtx_PLUS (Pmode, frame_reg_rtx, offset);\n-            mem = gen_rtx_MEM (V2SImode, addr);\n+\t\toffset = GEN_INT (spe_offset + reg_size * i);\n+\t\taddr = gen_rtx_PLUS (Pmode, frame_reg_rtx, offset);\n+\t\tmem = gen_rtx_MEM (V2SImode, addr);\n \n-            emit_move_insn (gen_rtx_REG (reg_mode, info->first_gp_reg_save + i),\n-                            mem);\n-          }\n+\t\temit_move_insn (gen_rtx_REG (reg_mode, info->first_gp_reg_save + i),\n+\t\t\t\tmem);\n+\t      }\n+\t}\n+      else\n+\t{\n+\t  rtx par;\n+\n+\t  par = rs6000_make_savres_rtx (info, gen_rtx_REG (Pmode, 11),\n+\t\t\t\t\t0, reg_mode,\n+\t\t\t\t\t/*savep=*/false, /*gpr=*/true,\n+\t\t\t\t\t/*exitp=*/true);\n+\t  emit_jump_insn (par);\n+\n+\t  /* We don't want anybody else emitting things after we jumped\n+\t     back.  */\n+\t  return;\n+\t}\n     }\n-  else\n-    for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n-      if (rs6000_reg_live_or_pic_offset_p (info->first_gp_reg_save + i))\n+  else if (!restoring_GPRs_inline)\n+    {\n+      /* We are jumping to an out-of-line function.  */\n+      bool can_use_exit = info->first_fp_reg_save == 64;\n+      rtx par;\n+\n+      /* Emit stack reset code if we need it.  */\n+      if (can_use_exit)\n+\trs6000_emit_stack_reset (info, sp_reg_rtx, frame_reg_rtx,\n+\t\t\t\t sp_offset, can_use_exit);\n+      else\n+\temit_insn (gen_addsi3 (gen_rtx_REG (Pmode, 11),\n+\t\t\t       sp_reg_rtx,\n+\t\t\t       GEN_INT (sp_offset - info->fp_size)));\n+\n+      par = rs6000_make_savres_rtx (info, frame_reg_rtx,\n+\t\t\t\t    info->gp_save_offset, reg_mode,\n+\t\t\t\t    /*savep=*/false, /*gpr=*/true,\n+\t\t\t\t    /*exitp=*/can_use_exit);\n+\n+      if (can_use_exit)\n+\t{\n+\t  if (info->cr_save_p)\n+\t    rs6000_restore_saved_cr (gen_rtx_REG (SImode, 12),\n+\t\t\t\t     using_mtcr_multiple);\n+\n+\t  emit_jump_insn (par);\n+\n+\t  /* We don't want anybody else emitting things after we jumped\n+\t     back.  */\n+\t  return;\n+\t}\n+      else\n+\temit_insn (par);\n+    }\n+  else if (using_load_multiple)\n+    {\n+      rtvec p;\n+      p = rtvec_alloc (32 - info->first_gp_reg_save);\n+      for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n \t{\n \t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n \t\t\t\t   GEN_INT (info->gp_save_offset\n \t\t\t\t\t    + sp_offset\n \t\t\t\t\t    + reg_size * i));\n \t  rtx mem = gen_frame_mem (reg_mode, addr);\n \n-\t  emit_move_insn (gen_rtx_REG (reg_mode,\n-\t\t\t\t       info->first_gp_reg_save + i), mem);\n+\t  RTVEC_ELT (p, i) =\n+\t    gen_rtx_SET (VOIDmode,\n+\t\t\t gen_rtx_REG (reg_mode, info->first_gp_reg_save + i),\n+\t\t\t mem);\n \t}\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n+    }\n+  else\n+    {\n+      for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n+        if (rs6000_reg_live_or_pic_offset_p (info->first_gp_reg_save + i))\n+\t  {\n+            rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+                                     GEN_INT (info->gp_save_offset\n+                                              + sp_offset\n+                                              + reg_size * i));\n+            rtx mem = gen_frame_mem (reg_mode, addr);\n+\n+            emit_move_insn (gen_rtx_REG (reg_mode,\n+                                         info->first_gp_reg_save + i), mem);\n+          }\n+    }\n \n   /* Restore fpr's if we need to do it without calling a function.  */\n   if (restoring_FPRs_inline)\n@@ -16742,69 +17146,12 @@ rs6000_emit_epilogue (int sibcall)\n \n   /* If we saved cr, restore it here.  Just those that were used.  */\n   if (info->cr_save_p)\n-    {\n-      rtx r12_rtx = gen_rtx_REG (SImode, 12);\n-      int count = 0;\n-\n-      if (using_mtcr_multiple)\n-\t{\n-\t  for (i = 0; i < 8; i++)\n-\t    if (df_regs_ever_live_p (CR0_REGNO+i) && ! call_used_regs[CR0_REGNO+i])\n-\t      count++;\n-\t  gcc_assert (count);\n-\t}\n-\n-      if (using_mtcr_multiple && count > 1)\n-\t{\n-\t  rtvec p;\n-\t  int ndx;\n-\n-\t  p = rtvec_alloc (count);\n-\n-\t  ndx = 0;\n-\t  for (i = 0; i < 8; i++)\n-\t    if (df_regs_ever_live_p (CR0_REGNO+i) && ! call_used_regs[CR0_REGNO+i])\n-\t      {\n-\t\trtvec r = rtvec_alloc (2);\n-\t\tRTVEC_ELT (r, 0) = r12_rtx;\n-\t\tRTVEC_ELT (r, 1) = GEN_INT (1 << (7-i));\n-\t\tRTVEC_ELT (p, ndx) =\n-\t\t  gen_rtx_SET (VOIDmode, gen_rtx_REG (CCmode, CR0_REGNO+i),\n-\t\t\t       gen_rtx_UNSPEC (CCmode, r, UNSPEC_MOVESI_TO_CR));\n-\t\tndx++;\n-\t      }\n-\t  emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n-\t  gcc_assert (ndx == count);\n-\t}\n-      else\n-\tfor (i = 0; i < 8; i++)\n-\t  if (df_regs_ever_live_p (CR0_REGNO+i) && ! call_used_regs[CR0_REGNO+i])\n-\t    {\n-\t      emit_insn (gen_movsi_to_cr_one (gen_rtx_REG (CCmode,\n-\t\t\t\t\t\t\t   CR0_REGNO+i),\n-\t\t\t\t\t      r12_rtx));\n-\t    }\n-    }\n+    rs6000_restore_saved_cr (gen_rtx_REG (SImode, 12), using_mtcr_multiple);\n \n   /* If this is V.4, unwind the stack pointer after all of the loads\n      have been done.  */\n-  if (frame_reg_rtx != sp_reg_rtx)\n-    {\n-      /* This blockage is needed so that sched doesn't decide to move\n-\t the sp change before the register restores.  */\n-      rs6000_emit_stack_tie ();\n-      if (sp_offset != 0)\n-        emit_insn (gen_addsi3 (sp_reg_rtx, frame_reg_rtx,\n-\t\t\t       GEN_INT (sp_offset)));\n-      else\n-        emit_move_insn (sp_reg_rtx, frame_reg_rtx);\n-    }\n-  else if (sp_offset != 0)\n-    emit_insn (TARGET_32BIT\n-\t       ? gen_addsi3 (sp_reg_rtx, sp_reg_rtx,\n-\t\t\t     GEN_INT (sp_offset))\n-\t       : gen_adddi3 (sp_reg_rtx, sp_reg_rtx,\n-\t\t\t     GEN_INT (sp_offset)));\n+  rs6000_emit_stack_reset (info, sp_reg_rtx, frame_reg_rtx,\n+\t\t\t   sp_offset, !restoring_FPRs_inline);\n \n   if (crtl->calls_eh_return)\n     {\n@@ -16818,38 +17165,38 @@ rs6000_emit_epilogue (int sibcall)\n     {\n       rtvec p;\n       if (! restoring_FPRs_inline)\n-\tp = rtvec_alloc (3 + 64 - info->first_fp_reg_save);\n+\tp = rtvec_alloc (4 + 64 - info->first_fp_reg_save);\n       else\n \tp = rtvec_alloc (2);\n \n       RTVEC_ELT (p, 0) = gen_rtx_RETURN (VOIDmode);\n-      RTVEC_ELT (p, 1) = gen_rtx_USE (VOIDmode,\n-\t\t\t\t      gen_rtx_REG (Pmode,\n-\t\t\t\t\t\t   LR_REGNO));\n+      RTVEC_ELT (p, 1) = (restoring_FPRs_inline\n+\t\t\t  ? gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, 65))\n+\t\t\t  : gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t     gen_rtx_REG (Pmode, 65)));\n \n       /* If we have to restore more than two FP registers, branch to the\n \t restore function.  It will return to our caller.  */\n       if (! restoring_FPRs_inline)\n \t{\n \t  int i;\n-\t  char rname[30];\n-\t  const char *alloc_rname;\n-\n-\t  sprintf (rname, \"%s%d%s\", RESTORE_FP_PREFIX,\n-\t\t   info->first_fp_reg_save - 32, RESTORE_FP_SUFFIX);\n-\t  alloc_rname = ggc_strdup (rname);\n-\t  RTVEC_ELT (p, 2) = gen_rtx_USE (VOIDmode,\n-\t\t\t\t\t  gen_rtx_SYMBOL_REF (Pmode,\n-\t\t\t\t\t\t\t      alloc_rname));\n-\n+\t  rtx sym;\n+\n+\t  sym = rs6000_savres_routine_sym (info,\n+\t\t\t\t\t   /*savep=*/false,\n+\t\t\t\t\t   /*gpr=*/false,\n+\t\t\t\t\t   /*exitp=*/true);\n+\t  RTVEC_ELT (p, 2) = gen_rtx_USE (VOIDmode, sym);\n+\t  RTVEC_ELT (p, 3) = gen_rtx_USE (VOIDmode,\n+\t\t\t\t\t  gen_rtx_REG (Pmode, 11));\n \t  for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n \t    {\n \t      rtx addr, mem;\n \t      addr = gen_rtx_PLUS (Pmode, sp_reg_rtx,\n \t\t\t\t   GEN_INT (info->fp_save_offset + 8*i));\n \t      mem = gen_frame_mem (DFmode, addr);\n \n-\t      RTVEC_ELT (p, i+3) =\n+\t      RTVEC_ELT (p, i+4) =\n \t\tgen_rtx_SET (VOIDmode,\n \t\t\t     gen_rtx_REG (DFmode, info->first_fp_reg_save + i),\n \t\t\t     mem);"}, {"sha": "461eda7c6a54fe13055f588c8ba92d131ec12876", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78c3290cdcd5328d1924935806f8ef24d7f7788/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78c3290cdcd5328d1924935806f8ef24d7f7788/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=f78c3290cdcd5328d1924935806f8ef24d7f7788", "patch": "@@ -14421,12 +14421,25 @@\n   \"{stm|stmw} %2,%1\"\n   [(set_attr \"type\" \"store_ux\")])\n \n+(define_insn \"*save_gpregs_<mode>\"\n+  [(match_parallel 0 \"any_parallel_operand\"\n+\t\t   [(clobber (reg:P 65))\n+\t\t    (use (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n+                    (use (match_operand:P 2 \"gpc_reg_operand\" \"r\"))\n+\t\t    (set (match_operand:P 3 \"memory_operand\" \"=m\")\n+\t\t\t (match_operand:P 4 \"gpc_reg_operand\" \"r\"))])]\n+  \"\"\n+  \"bl %z1\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"*save_fpregs_<mode>\"\n   [(match_parallel 0 \"any_parallel_operand\"\n \t\t   [(clobber (reg:P 65))\n-\t\t    (use (match_operand:P 1 \"call_operand\" \"s\"))\n-\t\t    (set (match_operand:DF 2 \"memory_operand\" \"=m\")\n-\t\t\t (match_operand:DF 3 \"gpc_reg_operand\" \"f\"))])]\n+\t\t    (use (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n+                    (use (match_operand:P 2 \"gpc_reg_operand\" \"r\"))\n+\t\t    (set (match_operand:DF 3 \"memory_operand\" \"=m\")\n+\t\t\t (match_operand:DF 4 \"gpc_reg_operand\" \"f\"))])]\n   \"\"\n   \"bl %z1\"\n   [(set_attr \"type\" \"branch\")\n@@ -14514,15 +14527,43 @@\n ; FIXME: This would probably be somewhat simpler if the Cygnus sibcall\n ; stuff was in GCC.  Oh, and \"any_parallel_operand\" is a bit flexible...\n \n+(define_insn \"*restore_gpregs_<mode>\"\n+ [(match_parallel 0 \"any_parallel_operand\"\n+                  [(clobber (match_operand:P 1 \"register_operand\" \"=l\"))\n+                   (use (match_operand:P 2 \"symbol_ref_operand\" \"s\"))\n+                   (use (match_operand:P 3 \"gpc_reg_operand\" \"r\"))\n+\t\t   (set (match_operand:P 4 \"gpc_reg_operand\" \"=r\")\n+\t\t\t(match_operand:P 5 \"memory_operand\" \"m\"))])]\n+ \"\"\n+ \"bl %z2\"\n+ [(set_attr \"type\" \"branch\")\n+  (set_attr \"length\" \"4\")])\n+\n+(define_insn \"*return_and_restore_gpregs_<mode>\"\n+ [(match_parallel 0 \"any_parallel_operand\"\n+                  [(return)\n+\t\t   (clobber (match_operand:P 1 \"register_operand\" \"=l\"))\n+\t\t   (use (match_operand:P 2 \"symbol_ref_operand\" \"s\"))\n+                   (use (match_operand:P 3 \"gpc_reg_operand\" \"r\"))\n+\t\t   (set (match_operand:P 4 \"gpc_reg_operand\" \"=r\")\n+\t\t\t(match_operand:P 5 \"memory_operand\" \"m\"))])]\n+ \"\"\n+ \"b %z2\"\n+ [(set_attr \"type\" \"branch\")\n+  (set_attr \"length\" \"4\")])\n+\n (define_insn \"*return_and_restore_fpregs_<mode>\"\n  [(match_parallel 0 \"any_parallel_operand\"\n                   [(return)\n-\t\t   (use (reg:P 65))\n-\t\t   (use (match_operand:P 1 \"call_operand\" \"s\"))\n-\t\t   (set (match_operand:DF 2 \"gpc_reg_operand\" \"=f\")\n-\t\t\t(match_operand:DF 3 \"memory_operand\" \"m\"))])]\n+\t\t   (clobber (match_operand:P 1 \"register_operand\" \"=l\"))\n+\t\t   (use (match_operand:P 2 \"symbol_ref_operand\" \"s\"))\n+                   (use (match_operand:P 3 \"gpc_reg_operand\" \"r\"))\n+\t\t   (set (match_operand:DF 4 \"gpc_reg_operand\" \"=f\")\n+\t\t\t(match_operand:DF 5 \"memory_operand\" \"m\"))])]\n  \"\"\n- \"b %z1\")\n+ \"b %z2\"\n+ [(set_attr \"type\" \"branch\")\n+  (set_attr \"length\" \"4\")])\n \n ; This is used in compiling the unwind routines.\n (define_expand \"eh_return\""}, {"sha": "96be255895b128867d35c2ddf4269cc665c3459b", "filename": "gcc/config/rs6000/spe.md", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78c3290cdcd5328d1924935806f8ef24d7f7788/gcc%2Fconfig%2Frs6000%2Fspe.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78c3290cdcd5328d1924935806f8ef24d7f7788/gcc%2Fconfig%2Frs6000%2Fspe.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fspe.md?ref=f78c3290cdcd5328d1924935806f8ef24d7f7788", "patch": "@@ -3138,3 +3138,41 @@\n   \"TARGET_E500\"\n   \"cror 4*%0+gt,4*%1+gt,4*%2+gt\"\n   [(set_attr \"type\" \"cr_logical\")])\n+\n+;; Out-of-line prologues and epilogues.\n+(define_insn \"*save_gpregs_spe\"\n+  [(match_parallel 0 \"any_parallel_operand\"\n+\t\t   [(clobber (reg:P 65))\n+\t\t    (use (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n+\t\t    (use (match_operand:P 2 \"gpc_reg_operand\" \"r\"))\n+\t\t    (set (match_operand:V2SI 3 \"memory_operand\" \"=m\")\n+\t\t\t (match_operand:V2SI 4 \"gpc_reg_operand\" \"r\"))])]\n+  \"TARGET_SPE_ABI\"\n+  \"bl %z1\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"*restore_gpregs_spe\"\n+ [(match_parallel 0 \"any_parallel_operand\"\n+\t\t  [(clobber (reg:P 65))\n+\t\t   (use (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n+\t\t   (use (match_operand:P 2 \"gpc_reg_operand\" \"r\"))\n+\t\t   (set (match_operand:V2SI 3 \"gpc_reg_operand\" \"=r\")\n+\t\t\t(match_operand:V2SI 4 \"memory_operand\" \"m\"))])]\n+ \"TARGET_SPE_ABI\"\n+ \"bl %z1\"\n+ [(set_attr \"type\" \"branch\")\n+  (set_attr \"length\" \"4\")])\n+\n+(define_insn \"*return_and_restore_gpregs_spe\"\n+ [(match_parallel 0 \"any_parallel_operand\"\n+\t\t  [(return)\n+\t\t   (clobber (reg:P 65))\n+\t\t   (use (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n+\t\t   (use (match_operand:P 2 \"gpc_reg_operand\" \"r\"))\n+\t\t   (set (match_operand:V2SI 3 \"gpc_reg_operand\" \"=r\")\n+\t\t\t(match_operand:V2SI 4 \"memory_operand\" \"m\"))])]\n+ \"TARGET_SPE_ABI\"\n+ \"b %z1\"\n+ [(set_attr \"type\" \"branch\")\n+  (set_attr \"length\" \"4\")])"}, {"sha": "b94de3bbbf4a5fafe978934fe874a466c398c88f", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78c3290cdcd5328d1924935806f8ef24d7f7788/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78c3290cdcd5328d1924935806f8ef24d7f7788/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=f78c3290cdcd5328d1924935806f8ef24d7f7788", "patch": "@@ -266,19 +266,27 @@ do {\t\t\t\t\t\t\t\t\t\\\n #endif\n \n /* Define cutoff for using external functions to save floating point.\n-   Currently on V.4, always use inline stores.  */\n-#define FP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) < 64)\n+   Currently on 64-bit V.4, always use inline stores.  When optimizing\n+   for size on 32-bit targets, use external functions when\n+   profitable.  */\n+#define FP_SAVE_INLINE(FIRST_REG) (optimize_size && !TARGET_64BIT\t\\\n+\t\t\t\t   ? ((FIRST_REG) == 62\t\t\t\\\n+\t\t\t\t      || (FIRST_REG) == 63)\t\t\\\n+\t\t\t\t   : (FIRST_REG) < 64)\n+/* And similarly for general purpose registers.  */\n+#define GP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) < 32\t\\\n+\t\t\t\t   && (TARGET_64BIT || !optimize_size))\n \n /* Put jump tables in read-only memory, rather than in .text.  */\n #define JUMP_TABLES_IN_TEXT_SECTION 0\n \n /* Prefix and suffix to use to saving floating point.  */\n #define\tSAVE_FP_PREFIX \"_savefpr_\"\n-#define SAVE_FP_SUFFIX \"_l\"\n+#define SAVE_FP_SUFFIX (TARGET_64BIT ? \"_l\" : \"\")\n \n /* Prefix and suffix to use to restoring floating point.  */\n #define\tRESTORE_FP_PREFIX \"_restfpr_\"\n-#define RESTORE_FP_SUFFIX \"_l\"\n+#define RESTORE_FP_SUFFIX (TARGET_64BIT ? \"_l\" : \"\")\n \n /* Type used for ptrdiff_t, as a string used in a declaration.  */\n #define PTRDIFF_TYPE \"int\""}, {"sha": "3645571223f472a249fc6ac5ef14913fc333206b", "filename": "gcc/config/rs6000/t-ppccomm", "status": "modified", "additions": 1, "deletions": 131, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78c3290cdcd5328d1924935806f8ef24d7f7788/gcc%2Fconfig%2Frs6000%2Ft-ppccomm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78c3290cdcd5328d1924935806f8ef24d7f7788/gcc%2Fconfig%2Frs6000%2Ft-ppccomm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-ppccomm?ref=f78c3290cdcd5328d1924935806f8ef24d7f7788", "patch": "@@ -3,23 +3,7 @@\n LIB2FUNCS_EXTRA += tramp.S $(srcdir)/config/rs6000/darwin-ldouble.c\n \n # These can't end up in shared libgcc\n-LIB2FUNCS_STATIC_EXTRA = eabi.S \\\n-  crtsavfpr.S crtresfpr.S \\\n-  crtsavgpr.S crtresgpr.S \\\n-  crtresxfpr.S crtresxgpr.S \\\n-  e500crtres32gpr.S \\\n-  e500crtres64gpr.S \\\n-  e500crtres64gprctr.S \\\n-  e500crtrest32gpr.S \\\n-  e500crtrest64gpr.S \\\n-  e500crtresx32gpr.S \\\n-  e500crtresx64gpr.S \\\n-  e500crtsav32gpr.S \\\n-  e500crtsav64gpr.S \\\n-  e500crtsav64gprctr.S \\\n-  e500crtsavg32gpr.S \\\n-  e500crtsavg64gpr.S \\\n-  e500crtsavg64gprctr.S\n+LIB2FUNCS_STATIC_EXTRA = eabi.S\n \n eabi.S: $(srcdir)/config/rs6000/eabi.asm\n \tcat $(srcdir)/config/rs6000/eabi.asm > eabi.S\n@@ -52,63 +36,6 @@ ncrti.S: $(srcdir)/config/rs6000/sol-ci.asm\n ncrtn.S: $(srcdir)/config/rs6000/sol-cn.asm\n \tcat $(srcdir)/config/rs6000/sol-cn.asm >ncrtn.S\n \n-crtsavfpr.S: $(srcdir)/config/rs6000/crtsavfpr.asm\n-\tcat $(srcdir)/config/rs6000/crtsavfpr.asm >crtsavfpr.S\n-\n-crtresfpr.S: $(srcdir)/config/rs6000/crtresfpr.asm\n-\tcat $(srcdir)/config/rs6000/crtresfpr.asm >crtresfpr.S\n-\n-crtsavgpr.S: $(srcdir)/config/rs6000/crtsavgpr.asm\n-\tcat $(srcdir)/config/rs6000/crtsavgpr.asm >crtsavgpr.S\n-\n-crtresgpr.S: $(srcdir)/config/rs6000/crtresgpr.asm\n-\tcat $(srcdir)/config/rs6000/crtresgpr.asm >crtresgpr.S\n-\n-crtresxfpr.S: $(srcdir)/config/rs6000/crtresxfpr.asm\n-\tcat $(srcdir)/config/rs6000/crtresxfpr.asm >crtresxfpr.S\n-\n-crtresxgpr.S: $(srcdir)/config/rs6000/crtresxgpr.asm\n-\tcat $(srcdir)/config/rs6000/crtresxgpr.asm >crtresxgpr.S\n-\n-e500crtres32gpr.S: $(srcdir)/config/rs6000/e500crtres32gpr.asm\n-\tcat $(srcdir)/config/rs6000/e500crtres32gpr.asm >e500crtres32gpr.S\n-\n-e500crtres64gpr.S: $(srcdir)/config/rs6000/e500crtres64gpr.asm\n-\tcat $(srcdir)/config/rs6000/e500crtres64gpr.asm >e500crtres64gpr.S\n-\n-e500crtres64gprctr.S: $(srcdir)/config/rs6000/e500crtres64gprctr.asm\n-\tcat $(srcdir)/config/rs6000/e500crtres64gprctr.asm >e500crtres64gprctr.S\n-\n-e500crtrest32gpr.S: $(srcdir)/config/rs6000/e500crtrest32gpr.asm\n-\tcat $(srcdir)/config/rs6000/e500crtrest32gpr.asm >e500crtrest32gpr.S\n-\n-e500crtrest64gpr.S: $(srcdir)/config/rs6000/e500crtrest64gpr.asm\n-\tcat $(srcdir)/config/rs6000/e500crtrest64gpr.asm >e500crtrest64gpr.S\n-\n-e500crtresx32gpr.S: $(srcdir)/config/rs6000/e500crtresx32gpr.asm\n-\tcat $(srcdir)/config/rs6000/e500crtresx32gpr.asm >e500crtresx32gpr.S\n-\n-e500crtresx64gpr.S: $(srcdir)/config/rs6000/e500crtresx64gpr.asm\n-\tcat $(srcdir)/config/rs6000/e500crtresx64gpr.asm >e500crtresx64gpr.S\n-\n-e500crtsav32gpr.S: $(srcdir)/config/rs6000/e500crtsav32gpr.asm\n-\tcat $(srcdir)/config/rs6000/e500crtsav32gpr.asm >e500crtsav32gpr.S\n-\n-e500crtsav64gpr.S: $(srcdir)/config/rs6000/e500crtsav64gpr.asm\n-\tcat $(srcdir)/config/rs6000/e500crtsav64gpr.asm >e500crtsav64gpr.S\n-\n-e500crtsav64gprctr.S: $(srcdir)/config/rs6000/e500crtsav64gprctr.asm\n-\tcat $(srcdir)/config/rs6000/e500crtsav64gprctr.asm >e500crtsav64gprctr.S\n-\n-e500crtsavg32gpr.S: $(srcdir)/config/rs6000/e500crtsavg32gpr.asm\n-\tcat $(srcdir)/config/rs6000/e500crtsavg32gpr.asm >e500crtsavg32gpr.S\n-\n-e500crtsavg64gpr.S: $(srcdir)/config/rs6000/e500crtsavg64gpr.asm\n-\tcat $(srcdir)/config/rs6000/e500crtsavg64gpr.asm >e500crtsavg64gpr.S\n-\n-e500crtsavg64gprctr.S: $(srcdir)/config/rs6000/e500crtsavg64gprctr.asm\n-\tcat $(srcdir)/config/rs6000/e500crtsavg64gprctr.asm >e500crtsavg64gprctr.S\n-\n # Build multiple copies of ?crt{i,n}.o, one for each target switch.\n $(T)ecrti$(objext): ecrti.S\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c ecrti.S -o $(T)ecrti$(objext)\n@@ -122,63 +49,6 @@ $(T)ncrti$(objext): ncrti.S\n $(T)ncrtn$(objext): ncrtn.S\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c ncrtn.S -o $(T)ncrtn$(objext)\n \n-$(T)crtsavfpr$(objext): crtsavfpr.S\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c crtsavfpr.S -o $(T)crtsavfpr$(objext)\n-\n-$(T)crtresfpr$(objext): crtresfpr.S\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c crtresfpr.S -o $(T)crtresfpr$(objext)\n-\n-$(T)crtsavgpr$(objext): crtsavgpr.S\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c crtsavgpr.S -o $(T)crtsavgpr$(objext)\n-\n-$(T)crtresgpr$(objext): crtresgpr.S\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c crtresgpr.S -o $(T)crtresgpr$(objext)\n-\n-$(T)crtresxfpr$(objext): crtresxfpr.S\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c crtresxfpr.S -o $(T)crtresxfpr$(objext)\n-\n-$(T)crtresxgpr$(objext): crtresxgpr.S\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c crtresxgpr.S -o $(T)crtresxgpr$(objext)\n-\n-$(T)e500crtres32gpr$(objext): e500crtres32gpr.S\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtres32gpr.S -o $(T)e500crtres32gpr$(objext)\n-\n-$(T)e500crtres64gpr$(objext): e500crtres64gpr.S\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtres64gpr.S -o $(T)e500crtres64gpr$(objext)\n-\n-$(T)e500crtres64gprctr$(objext): e500crtres64gprctr.S\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtres64gprctr.S -o $(T)e500crtres64gprctr$(objext)\n-\n-$(T)e500crtrest32gpr$(objext): e500crtrest32gpr.S\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtrest32gpr.S -o $(T)e500crtrest32gpr$(objext)\n-\n-$(T)e500crtrest64gpr$(objext): e500crtrest64gpr.S\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtrest64gpr.S -o $(T)e500crtrest64gpr$(objext)\n-\n-$(T)e500crtresx32gpr$(objext): e500crtresx32gpr.S\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtresx32gpr.S -o $(T)e500crtresx32gpr$(objext)\n-\n-$(T)e500crtresx64gpr$(objext): e500crtresx64gpr.S\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtresx64gpr.S -o $(T)e500crtresx64gpr$(objext)\n-\n-$(T)e500crtsav32gpr$(objext): e500crtsav32gpr.S\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtsav32gpr.S -o $(T)e500crtsav32gpr$(objext)\n-\n-$(T)e500crtsav64gpr$(objext): e500crtsav64gpr.S\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtsav64gpr.S -o $(T)e500crtsav64gpr$(objext)\n-\n-$(T)e500crtsav64gprctr$(objext): e500crtsav64gprctr.S\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtsav64gprctr.S -o $(T)e500crtsav64gprctr$(objext)\n-\n-$(T)e500crtsavg32gpr$(objext): e500crtsavg32gpr.S\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtsavg32gpr.S -o $(T)e500crtsavg32gpr$(objext)\n-\n-$(T)e500crtsavg64gpr$(objext): e500crtsavg64gpr.S\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtsavg64gpr.S -o $(T)e500crtsavg64gpr$(objext)\n-\n-$(T)e500crtsavg64gprctr$(objext): e500crtsavg64gprctr.S\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -c e500crtsavg64gprctr.S -o $(T)e500crtsavg64gprctr$(objext)\n-\n # It is important that crtbegin.o, etc., aren't surprised by stuff in .sdata.\n CRTSTUFF_T_CFLAGS = -msdata=none\n # Make sure crt*.o are built with -fPIC even if configured with "}]}