{"sha": "27d0d96a8f40647fe821be7793e31e7c082a564d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdkMGQ5NmE4ZjQwNjQ3ZmU4MjFiZTc3OTNlMzFlN2MwODJhNTY0ZA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-04-24T18:53:47Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-04-24T18:53:47Z"}, "message": "re PR tree-optimization/41442 (missed optimization for boolean expression)\n\ngcc/\n\tPR tree-optimization/41442\n\t* fold-const.c (merge_truthop_with_opposite_arm): New function.\n\t(fold_binary_loc): Call it.\n\ngcc/testsuite/\n\tPR tree-optimization/41442\n\t* gcc.target/i386/pr41442.c: New test.\n\nFrom-SVN: r158689", "tree": {"sha": "cbc59ec806acc463682d986f791c4a908d35d144", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbc59ec806acc463682d986f791c4a908d35d144"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27d0d96a8f40647fe821be7793e31e7c082a564d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27d0d96a8f40647fe821be7793e31e7c082a564d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27d0d96a8f40647fe821be7793e31e7c082a564d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27d0d96a8f40647fe821be7793e31e7c082a564d/comments", "author": null, "committer": null, "parents": [{"sha": "1cef01a08678826d1c58fb1f47879e280872e8e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cef01a08678826d1c58fb1f47879e280872e8e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cef01a08678826d1c58fb1f47879e280872e8e6"}], "stats": {"total": 115, "additions": 115, "deletions": 0}, "files": [{"sha": "9e1a30a101b84ee5c75d0412efba5af579d94698", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27d0d96a8f40647fe821be7793e31e7c082a564d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27d0d96a8f40647fe821be7793e31e7c082a564d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27d0d96a8f40647fe821be7793e31e7c082a564d", "patch": "@@ -1,3 +1,9 @@\n+2010-04-24  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR tree-optimization/41442\n+\t* fold-const.c (merge_truthop_with_opposite_arm): New function.\n+\t(fold_binary_loc): Call it.\n+\n 2010-04-23  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* toplev.c (general_init): Set default for"}, {"sha": "ffd9d30ef2e0a873bef76a4c7347d0bece934773", "filename": "gcc/fold-const.c", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27d0d96a8f40647fe821be7793e31e7c082a564d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27d0d96a8f40647fe821be7793e31e7c082a564d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=27d0d96a8f40647fe821be7793e31e7c082a564d", "patch": "@@ -4997,6 +4997,76 @@ unextend (tree c, int p, int unsignedp, tree mask)\n \t\t       const_binop (BIT_XOR_EXPR, c, temp, 0));\n }\n \f\n+/* For an expression that has the form\n+     (A && B) || ~B\n+   or\n+     (A || B) && ~B,\n+   we can drop one of the inner expressions and simplify to\n+     A || ~B\n+   or\n+     A && ~B\n+   LOC is the location of the resulting expression.  OP is the inner \n+   logical operation; the left-hand side in the examples above, while CMPOP\n+   is the right-hand side.  RHS_ONLY is used to prevent us from accidentally\n+   removing a condition that guards another, as in\n+     (A != NULL && A->...) || A == NULL\n+   which we must not transform.  If RHS_ONLY is true, only eliminate the\n+   right-most operand of the inner logical operation.  */\n+\n+static tree\n+merge_truthop_with_opposite_arm (location_t loc, tree op, tree cmpop,\n+\t\t\t\t bool rhs_only)\n+{\n+  tree type = TREE_TYPE (cmpop);\n+  enum tree_code code = TREE_CODE (cmpop);\n+  enum tree_code truthop_code = TREE_CODE (op);\n+  tree lhs = TREE_OPERAND (op, 0);\n+  tree rhs = TREE_OPERAND (op, 1);\n+  tree orig_lhs = lhs, orig_rhs = rhs;\n+  enum tree_code rhs_code = TREE_CODE (rhs);\n+  enum tree_code lhs_code = TREE_CODE (lhs);\n+  enum tree_code inv_code;\n+\n+  if (TREE_SIDE_EFFECTS (op) || TREE_SIDE_EFFECTS (cmpop))\n+    return NULL_TREE;\n+\n+  if (TREE_CODE_CLASS (code) != tcc_comparison)\n+    return NULL_TREE;\n+\n+  if (rhs_code == truthop_code)\n+    {\n+      tree newrhs = merge_truthop_with_opposite_arm (loc, rhs, cmpop, rhs_only);\n+      if (newrhs != NULL_TREE)\n+\t{\n+\t  rhs = newrhs;\n+\t  rhs_code = TREE_CODE (rhs);\n+\t}\n+    }\n+  if (lhs_code == truthop_code && !rhs_only)\n+    {\n+      tree newlhs = merge_truthop_with_opposite_arm (loc, lhs, cmpop, false);\n+      if (newlhs != NULL_TREE)\n+\t{\n+\t  lhs = newlhs;\n+\t  lhs_code = TREE_CODE (lhs);\n+\t}\n+    }\n+\n+  inv_code = invert_tree_comparison (code, HONOR_NANS (TYPE_MODE (type)));\n+  if (inv_code == rhs_code\n+      && operand_equal_p (TREE_OPERAND (rhs, 0), TREE_OPERAND (cmpop, 0), 0)\n+      && operand_equal_p (TREE_OPERAND (rhs, 1), TREE_OPERAND (cmpop, 1), 0))\n+    return lhs;\n+  if (!rhs_only && inv_code == lhs_code\n+      && operand_equal_p (TREE_OPERAND (lhs, 0), TREE_OPERAND (cmpop, 0), 0)\n+      && operand_equal_p (TREE_OPERAND (lhs, 1), TREE_OPERAND (cmpop, 1), 0))\n+    return rhs;\n+  if (rhs != orig_rhs || lhs != orig_lhs)\n+    return fold_build2_loc (loc, truthop_code, TREE_TYPE (cmpop),\n+\t\t\t    lhs, rhs);\n+  return NULL_TREE;\n+}\n+\n /* Find ways of folding logical expressions of LHS and RHS:\n    Try to merge two comparisons to the same innermost item.\n    Look for range tests like \"ch >= '0' && ch <= '9'\".\n@@ -11833,6 +11903,22 @@ fold_binary_loc (location_t loc,\n       if (0 != (tem = fold_range_test (loc, code, type, op0, op1)))\n \treturn tem;\n \n+      if ((code == TRUTH_ANDIF_EXPR && TREE_CODE (arg0) == TRUTH_ORIF_EXPR)\n+\t  || (code == TRUTH_ORIF_EXPR && TREE_CODE (arg0) == TRUTH_ANDIF_EXPR))\n+\t{\n+\t  tem = merge_truthop_with_opposite_arm (loc, arg0, arg1, true);\n+\t  if (tem)\n+\t    return fold_build2_loc (loc, code, type, tem, arg1);\n+\t}\n+\n+      if ((code == TRUTH_ANDIF_EXPR && TREE_CODE (arg1) == TRUTH_ORIF_EXPR)\n+\t  || (code == TRUTH_ORIF_EXPR && TREE_CODE (arg1) == TRUTH_ANDIF_EXPR))\n+\t{\n+\t  tem = merge_truthop_with_opposite_arm (loc, arg1, arg0, false);\n+\t  if (tem)\n+\t    return fold_build2_loc (loc, code, type, arg0, tem);\n+\t}\n+\n       /* Check for the possibility of merging component references.  If our\n \t lhs is another similar operation, try to merge its rhs with our\n \t rhs.  Then try to merge our lhs and rhs.  */"}, {"sha": "0133717fc204a964e1587b866f256b247c43fcb4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27d0d96a8f40647fe821be7793e31e7c082a564d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27d0d96a8f40647fe821be7793e31e7c082a564d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=27d0d96a8f40647fe821be7793e31e7c082a564d", "patch": "@@ -1,3 +1,8 @@\n+2010-04-24  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR tree-optimization/41442\n+\t* gcc.target/i386/pr41442.c: New test.\n+\n 2010-04-24  Hans-Peter Nilsson  <hp@axis.com>\n \n \tPR fortran/43832"}, {"sha": "feae791bdd0045bcc11c60e0ef920985d2c2d49e", "filename": "gcc/testsuite/gcc.target/i386/pr41442.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27d0d96a8f40647fe821be7793e31e7c082a564d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr41442.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27d0d96a8f40647fe821be7793e31e7c082a564d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr41442.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr41442.c?ref=27d0d96a8f40647fe821be7793e31e7c082a564d", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+typedef struct LINK link;\n+struct LINK\n+{\n+    link* next;\n+};\n+\n+int haha(link* p1, link* p2)\n+{\n+  if ((p1->next && !p2->next) || p2->next)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* { dg-final { scan-assembler-times \"test|cmp\" 2 } } */"}]}