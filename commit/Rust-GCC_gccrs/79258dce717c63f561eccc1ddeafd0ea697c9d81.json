{"sha": "79258dce717c63f561eccc1ddeafd0ea697c9d81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkyNThkY2U3MTdjNjNmNTYxZWNjYzFkZGVhZmQwZWE2OTdjOWQ4MQ==", "commit": {"author": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2002-07-24T13:41:22Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2002-07-24T13:41:22Z"}, "message": "[multiple changes]\n\n2002-07-24  Frank van der Linden  <fvdl@wasabisystems.com>\n\n\tPR optimization/7291\n\t* config/i386/i386.c (ix86_expand_clrstr): Fix bzero alignment\n\tproblem on x86_64.\n\n2002-07-24  Roger Sayle  <roger@eyesopen.com>\n\n\t* gcc.c-torture/execute/memset-3.c: New testcase.\n\nFrom-SVN: r55704", "tree": {"sha": "6151e54d163abccb0bc94d5f4028f84249cf9657", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6151e54d163abccb0bc94d5f4028f84249cf9657"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79258dce717c63f561eccc1ddeafd0ea697c9d81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79258dce717c63f561eccc1ddeafd0ea697c9d81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79258dce717c63f561eccc1ddeafd0ea697c9d81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79258dce717c63f561eccc1ddeafd0ea697c9d81/comments", "author": null, "committer": null, "parents": [{"sha": "26ff2117a92699fbbf8ba5559248df3696b88ce1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26ff2117a92699fbbf8ba5559248df3696b88ce1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26ff2117a92699fbbf8ba5559248df3696b88ce1"}], "stats": {"total": 220, "additions": 219, "deletions": 1}, "files": [{"sha": "7e9cd869832c40a0979aea2aee40bd7a1bbe71a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79258dce717c63f561eccc1ddeafd0ea697c9d81/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79258dce717c63f561eccc1ddeafd0ea697c9d81/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79258dce717c63f561eccc1ddeafd0ea697c9d81", "patch": "@@ -1,3 +1,9 @@\n+2002-07-24  Frank van der Linden  <fvdl@wasabisystems.com>\n+\n+\tPR optimization/7291\n+\t* config/i386/i386.c (ix86_expand_clrstr): Fix bzero alignment\n+\tproblem on x86_64.\n+\n 2002-07-24  Gabriel Dos Reis  <gdr@nerim.net>\n \n \t* pretty-print.h: Add macros from cp/error.c"}, {"sha": "0b4cf9ddd253a83c6ae63422c48dc9ecdf5ce5f5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79258dce717c63f561eccc1ddeafd0ea697c9d81/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79258dce717c63f561eccc1ddeafd0ea697c9d81/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=79258dce717c63f561eccc1ddeafd0ea697c9d81", "patch": "@@ -10193,7 +10193,7 @@ ix86_expand_clrstr (src, count_exp, align_exp)\n \t\t\t\t gen_rtx_SUBREG (SImode, zeroreg, 0)));\n       if (TARGET_64BIT && (align <= 4 || count == 0))\n \t{\n-\t  rtx label = ix86_expand_aligntest (countreg, 2);\n+\t  rtx label = ix86_expand_aligntest (countreg, 4);\n \t  emit_insn (gen_strsetsi (destreg,\n \t\t\t\t   gen_rtx_SUBREG (SImode, zeroreg, 0)));\n \t  emit_label (label);"}, {"sha": "89d69d35945ba7860c06691c2ac6bc6f1678ccd4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79258dce717c63f561eccc1ddeafd0ea697c9d81/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79258dce717c63f561eccc1ddeafd0ea697c9d81/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=79258dce717c63f561eccc1ddeafd0ea697c9d81", "patch": "@@ -1,3 +1,7 @@\n+2002-07-24  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.c-torture/execute/memset-3.c: New testcase.\n+\n 2002-07-24  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* gcc.dg/cpp/trad/Wunused.c, gcc.dg/cpp/trad/Wunused.h,"}, {"sha": "64032a7754096e9ed119d2d06ff821715279c844", "filename": "gcc/testsuite/gcc.c-torture/execute/memset-3.c", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79258dce717c63f561eccc1ddeafd0ea697c9d81/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemset-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79258dce717c63f561eccc1ddeafd0ea697c9d81/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemset-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemset-3.c?ref=79258dce717c63f561eccc1ddeafd0ea697c9d81", "patch": "@@ -0,0 +1,208 @@\n+/* Copyright (C) 2002  Free Software Foundation.\n+\n+   Test memset with various combinations of constant pointer alignments and\n+   lengths to make sure any optimizations in the compiler are correct.\n+\n+   Written by Roger Sayle, July 22, 2002.  */\n+\n+#ifndef MAX_OFFSET\n+#define MAX_OFFSET (sizeof (long long))\n+#endif\n+\n+#ifndef MAX_COPY\n+#define MAX_COPY 15\n+#endif\n+\n+#ifndef MAX_EXTRA\n+#define MAX_EXTRA (sizeof (long long))\n+#endif\n+\n+#define MAX_LENGTH (MAX_OFFSET + MAX_COPY + MAX_EXTRA)\n+\n+static union {\n+  char buf[MAX_LENGTH];\n+  long long align_int;\n+  long double align_fp;\n+} u;\n+\n+char A = 'A';\n+\n+void reset ()\n+{\n+  int i;\n+\n+  for (i = 0; i < MAX_LENGTH; i++)\n+    u.buf[i] = 'a';\n+}\n+\n+void check (int off, int len, int ch)\n+{\n+  char *q;\n+  int i;\n+\n+  q = u.buf;\n+  for (i = 0; i < off; i++, q++)\n+    if (*q != 'a')\n+      abort ();\n+\n+  for (i = 0; i < len; i++, q++)\n+    if (*q != ch)\n+      abort ();\n+\n+  for (i = 0; i < MAX_EXTRA; i++, q++)\n+    if (*q != 'a')\n+      abort ();\n+}\n+\n+int main ()\n+{\n+  int len;\n+  char *p;\n+\n+  /* off == 0 */\n+  for (len = 0; len < MAX_COPY; len++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf, '\\0', len);\n+      if (p != u.buf) abort ();\n+      check (0, len, '\\0');\n+\n+      p = memset (u.buf, A, len);\n+      if (p != u.buf) abort ();\n+      check (0, len, 'A');\n+\n+      p = memset (u.buf, 'B', len);\n+      if (p != u.buf) abort ();\n+      check (0, len, 'B');\n+    }\n+\n+  /* off == 1 */\n+  for (len = 0; len < MAX_COPY; len++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf+1, '\\0', len);\n+      if (p != u.buf+1) abort ();\n+      check (1, len, '\\0');\n+\n+      p = memset (u.buf+1, A, len);\n+      if (p != u.buf+1) abort ();\n+      check (1, len, 'A');\n+\n+      p = memset (u.buf+1, 'B', len);\n+      if (p != u.buf+1) abort ();\n+      check (1, len, 'B');\n+    }\n+\n+  /* off == 2 */\n+  for (len = 0; len < MAX_COPY; len++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf+2, '\\0', len);\n+      if (p != u.buf+2) abort ();\n+      check (2, len, '\\0');\n+\n+      p = memset (u.buf+2, A, len);\n+      if (p != u.buf+2) abort ();\n+      check (2, len, 'A');\n+\n+      p = memset (u.buf+2, 'B', len);\n+      if (p != u.buf+2) abort ();\n+      check (2, len, 'B');\n+    }\n+\n+  /* off == 3 */\n+  for (len = 0; len < MAX_COPY; len++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf+3, '\\0', len);\n+      if (p != u.buf+3) abort ();\n+      check (3, len, '\\0');\n+\n+      p = memset (u.buf+3, A, len);\n+      if (p != u.buf+3) abort ();\n+      check (3, len, 'A');\n+\n+      p = memset (u.buf+3, 'B', len);\n+      if (p != u.buf+3) abort ();\n+      check (3, len, 'B');\n+    }\n+\n+  /* off == 4 */\n+  for (len = 0; len < MAX_COPY; len++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf+4, '\\0', len);\n+      if (p != u.buf+4) abort ();\n+      check (4, len, '\\0');\n+\n+      p = memset (u.buf+4, A, len);\n+      if (p != u.buf+4) abort ();\n+      check (4, len, 'A');\n+\n+      p = memset (u.buf+4, 'B', len);\n+      if (p != u.buf+4) abort ();\n+      check (4, len, 'B');\n+    }\n+\n+  /* off == 5 */\n+  for (len = 0; len < MAX_COPY; len++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf+5, '\\0', len);\n+      if (p != u.buf+5) abort ();\n+      check (5, len, '\\0');\n+\n+      p = memset (u.buf+5, A, len);\n+      if (p != u.buf+5) abort ();\n+      check (5, len, 'A');\n+\n+      p = memset (u.buf+5, 'B', len);\n+      if (p != u.buf+5) abort ();\n+      check (5, len, 'B');\n+    }\n+\n+  /* off == 6 */\n+  for (len = 0; len < MAX_COPY; len++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf+6, '\\0', len);\n+      if (p != u.buf+6) abort ();\n+      check (6, len, '\\0');\n+\n+      p = memset (u.buf+6, A, len);\n+      if (p != u.buf+6) abort ();\n+      check (6, len, 'A');\n+\n+      p = memset (u.buf+6, 'B', len);\n+      if (p != u.buf+6) abort ();\n+      check (6, len, 'B');\n+    }\n+\n+  /* off == 7 */\n+  for (len = 0; len < MAX_COPY; len++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf+7, '\\0', len);\n+      if (p != u.buf+7) abort ();\n+      check (7, len, '\\0');\n+\n+      p = memset (u.buf+7, A, len);\n+      if (p != u.buf+7) abort ();\n+      check (7, len, 'A');\n+\n+      p = memset (u.buf+7, 'B', len);\n+      if (p != u.buf+7) abort ();\n+      check (7, len, 'B');\n+    }\n+\n+  exit (0);\n+}\n+"}]}