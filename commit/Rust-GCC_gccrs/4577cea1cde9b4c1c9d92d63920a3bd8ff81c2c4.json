{"sha": "4577cea1cde9b4c1c9d92d63920a3bd8ff81c2c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU3N2NlYTFjZGU5YjRjMWM5ZDkyZDYzOTIwYTNiZDhmZjgxYzJjNA==", "commit": {"author": {"name": "Xinliang David Li", "email": "davidxl@google.com", "date": "2009-03-27T17:18:58Z"}, "committer": {"name": "Xinliang David Li", "email": "davidxl@gcc.gnu.org", "date": "2009-03-27T17:18:58Z"}, "message": "Fix for PR39548\n\nFrom-SVN: r145118", "tree": {"sha": "a8ca7ed410f4b6d55c2ad1ff5ef09a34dc57c94f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8ca7ed410f4b6d55c2ad1ff5ef09a34dc57c94f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4577cea1cde9b4c1c9d92d63920a3bd8ff81c2c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4577cea1cde9b4c1c9d92d63920a3bd8ff81c2c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4577cea1cde9b4c1c9d92d63920a3bd8ff81c2c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4577cea1cde9b4c1c9d92d63920a3bd8ff81c2c4/comments", "author": {"login": "vns-mn", "id": 57157229, "node_id": "MDQ6VXNlcjU3MTU3MjI5", "avatar_url": "https://avatars.githubusercontent.com/u/57157229?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vns-mn", "html_url": "https://github.com/vns-mn", "followers_url": "https://api.github.com/users/vns-mn/followers", "following_url": "https://api.github.com/users/vns-mn/following{/other_user}", "gists_url": "https://api.github.com/users/vns-mn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vns-mn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vns-mn/subscriptions", "organizations_url": "https://api.github.com/users/vns-mn/orgs", "repos_url": "https://api.github.com/users/vns-mn/repos", "events_url": "https://api.github.com/users/vns-mn/events{/privacy}", "received_events_url": "https://api.github.com/users/vns-mn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0f7464f40330f3c81d57aa433f5285fe9f00abd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f7464f40330f3c81d57aa433f5285fe9f00abd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f7464f40330f3c81d57aa433f5285fe9f00abd8"}], "stats": {"total": 753, "additions": 752, "deletions": 1}, "files": [{"sha": "3b91d915a9f7aec597cba4f56da072f11560b02e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4577cea1cde9b4c1c9d92d63920a3bd8ff81c2c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4577cea1cde9b4c1c9d92d63920a3bd8ff81c2c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4577cea1cde9b4c1c9d92d63920a3bd8ff81c2c4", "patch": "@@ -1,3 +1,9 @@\n+2009-03-27  Xinliang David Li  <davidxl@google.com>\n+\n+\tPR tree-optimization/39548\n+\t* tree-ssa-copy.c (copy_prop_visit_phi_node): Add copy \n+\tcandidate check.\n+\n 2009-03-27  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* c-common.c (pointer_int_sum): Use %wd on return from"}, {"sha": "4b64a988f6392b1a599317f07c0936bb7fcba160", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4577cea1cde9b4c1c9d92d63920a3bd8ff81c2c4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4577cea1cde9b4c1c9d92d63920a3bd8ff81c2c4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4577cea1cde9b4c1c9d92d63920a3bd8ff81c2c4", "patch": "@@ -1,3 +1,8 @@\n+2009-03-27  Xinliang David Li  <davidxl@google.com>\n+\n+\tPR tree-optimization/39548\n+\t* g++.dg/tree-ssa/copyprop.C: New test.\n+\n 2009-03-27  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR c++/38638"}, {"sha": "e785755eb077f2244764aa93a2d78065a18b0ad7", "filename": "gcc/testsuite/g++.dg/tree-ssa/copyprop.C", "status": "added", "additions": 739, "deletions": 0, "changes": 739, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4577cea1cde9b4c1c9d92d63920a3bd8ff81c2c4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fcopyprop.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4577cea1cde9b4c1c9d92d63920a3bd8ff81c2c4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fcopyprop.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fcopyprop.C?ref=4577cea1cde9b4c1c9d92d63920a3bd8ff81c2c4", "patch": "@@ -0,0 +1,739 @@\n+// PR 39548 verify ssa ICE\n+//\n+// { dg-do compile { target { lp64 } } }\n+// { dg-options  \"-Wno-error -fno-exceptions -fno-tree-vrp -O2 -fprofile-generate  -finline-limit=500\"  } \n+//\n+\n+#include <map>\n+#include <vector>\n+#include <iostream>\n+using namespace std;\n+extern void free (void *);\n+template<typename _FIter, typename _Tp> _FIter lower_bound(_FIter, _FIter, _Tp&);\n+template<class _Key> struct hash { };\n+template<class _Val> struct _Hashtable_node {\n+  _Hashtable_node* _M_next;\n+  _Val _M_val;\n+};\n+static const unsigned long __stl_prime_list[] = { 2, 3, 5 };\n+inline unsigned long prime(unsigned long __n)   {\n+  const unsigned long* __first = __stl_prime_list;\n+  const unsigned long* __last = __stl_prime_list + 29;\n+  const unsigned long* pos = lower_bound(__first, __last, __n);\n+  return pos == __last ? *(__last - 1) : *pos;\n+}\n+template<class _Val, class _Key, class _HashFcn,     class _ExtractKey, class _EqualKey, class _Alloc>     struct hashtable  {\n+  typedef _Key key_type;\n+  typedef _Val value_type;\n+  typedef _HashFcn hasher;\n+  typedef _EqualKey key_equal;\n+  typedef size_t size_type;\n+  typedef value_type& reference;\n+  typedef _Hashtable_node<_Val> _Node;\n+  typedef typename _Alloc::template rebind<value_type>::other allocator_type;\n+  allocator_type get_allocator() const { }\n+  typedef typename _Alloc::template rebind<_Node>::other _Node_Alloc;\n+  typedef typename _Alloc::template rebind<_Node*>::other _Nodeptr_Alloc;\n+  typedef vector<_Node*, _Nodeptr_Alloc> _Vector_type;\n+  _Node_Alloc _M_node_allocator;\n+  void _M_put_node(_Node* __p) {\n+    _M_node_allocator.deallocate(__p, 1);\n+  }\n+  hasher _M_hash;\n+  key_equal _M_equals;\n+  _ExtractKey _M_get_key;\n+  _Vector_type _M_buckets;\n+  size_type _M_num_elements;\n+  hashtable(size_type __n, const _HashFcn& __hf,   const _EqualKey& __eql,   const allocator_type& __a = allocator_type())  : _M_num_elements(0)  {\n+    _M_initialize_buckets(__n);\n+  }\n+  ~hashtable() { clear(); }\n+  reference  find_or_insert(const value_type& __obj);\n+  size_type  count(const key_type& __key) const {\n+    const size_type __n = _M_bkt_num_key(__key);\n+    size_type __result = 0;\n+    for (const _Node* __cur = _M_buckets[__n]; __cur; __cur = __cur->_M_next)\n+      if (_M_equals(_M_get_key(__cur->_M_val), __key))   ++__result;\n+  }\n+  size_type erase(const key_type& __key);\n+  void clear();\n+  size_type _M_next_size(size_type __n) const { return prime(__n); }\n+  void  _M_initialize_buckets(size_type __n)       {\n+    const size_type __n_buckets = _M_next_size(__n);\n+    _M_buckets.reserve(__n_buckets);\n+    _M_buckets.insert(_M_buckets.end(), __n_buckets, (_Node*) 0);\n+  }\n+  size_type       _M_bkt_num_key(const key_type& __key) const  {\n+    return _M_bkt_num_key(__key, _M_buckets.size());\n+  }\n+  size_type       _M_bkt_num_key(const key_type& __key, size_t __n) const  {\n+    return _M_hash(__key) % __n;\n+  }\n+  void       _M_delete_node(_Node* __n)  {\n+    this->get_allocator().destroy(&__n->_M_val);\n+    _M_put_node(__n);\n+  }\n+};\n+template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>     typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::size_type     hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::     erase(const key_type& __key)     {\n+  const size_type __n = _M_bkt_num_key(__key);\n+  _Node* __first = _M_buckets[__n];\n+  if (__first)     _Node* __cur = __first;\n+}\n+template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>     void     hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::     clear()     {\n+  for (size_type __i = 0; __i < _M_buckets.size(); ++__i)  {\n+    _Node* __cur = _M_buckets[__i];\n+    while (__cur != 0)  { _M_delete_node(__cur); }\n+  }\n+}\n+template<class _Key, class _Tp, class _HashFn = hash<_Key>,     class _EqualKey = equal_to<_Key>, class _Alloc = allocator<_Tp> >   struct hash_map     {\n+  typedef hashtable<pair<const _Key, _Tp>,_Key, _HashFn,    _Select1st<pair<const _Key, _Tp> >,    _EqualKey, _Alloc> _Ht;\n+  _Ht _M_ht;\n+  typedef typename _Ht::key_type key_type;\n+  typedef typename _Ht::value_type value_type;\n+  typedef typename _Ht::hasher hasher;\n+  typedef typename _Ht::key_equal key_equal;\n+  typedef typename _Ht::size_type size_type;\n+  typedef typename _Ht::allocator_type allocator_type;\n+  hash_map()       : _M_ht(100, hasher(), key_equal(), allocator_type()) { }\n+  _Tp&       operator[](const key_type& __key)   {\n+    return _M_ht.find_or_insert(value_type(__key, _Tp())).second;\n+  }\n+  size_type count(const key_type& __key) const { return _M_ht.count(__key); }\n+  size_type erase(const key_type& __key) {\n+    return _M_ht.erase(__key);\n+  }\n+};\n+extern size_t strlen (__const char *__s);\n+template <class C> struct scoped_ptr {\n+  explicit scoped_ptr(C* p = __null) : ptr_(p) { delete ptr_; }\n+  void reset(C* p = __null) {\n+    if (p != ptr_) { delete ptr_; }\n+  }\n+  C& operator*() const {}\n+  C* operator->() const {}\n+  bool operator==(C* p) const { return ptr_ == p; }\n+  bool operator!=(C* p) const { return ptr_ != p; }\n+  C* ptr_;\n+};\n+namespace std {\n+class strstreambuf  : public basic_streambuf<char, char_traits<char> >      {\n+};\n+class strstream  : public basic_iostream<char>    {\n+ public:        int pcount() const;\n+  char* str();\n+  strstreambuf _M_buf;\n+};\n+};\n+const int INFO = 0,  WARNING = 1,  ERROR = 2,  FATAL = 3,  NUM_SEVERITIES = 4;\n+struct foo_1 {\n+  foo_1(string* str) : str_(str)  { }\n+  operator bool() const {\n+    return (__builtin_expect(str_ != __null, 0));\n+  }\n+  string* str_;\n+};\n+template<class t1, class t2> string* Makefoo_1(const t1& v1, const t2& v2, const char* names) {\n+  strstream ss;\n+  ss << names << \" (\" << v1 << \" vs. \" << v2 << \")\";\n+  return new string(ss.str(), ss.pcount());\n+}\n+template <class t1, class t2> inline string* Check_GTImpl(const t1& v1, const t2& v2, const char* names) {\n+  if (v1 > v2) return __null;\n+  else return Makefoo_1(v1, v2, names);\n+}\n+struct blah_54 {\n+  blah_54(const char* file, int line, int severity);\n+  ~blah_54();\n+  ostream& stream() { };\n+};\n+class blah_0  : public blah_54  {\n+ public:   blah_0(const char* file, int line);\n+  blah_0(const char* file, int line, const foo_1& result);\n+};\n+template <class Value, class Key, class HashFcn,  class ExtractKey, class EqualKey, class Alloc> class dense_hashtable;\n+template <class V, class K, class HF, class ExK, class EqK, class A> struct dense_hashtable_iterator {\n+  typedef V* pointer;\n+  dense_hashtable_iterator(const dense_hashtable<V,K,HF,ExK,EqK,A> *h, pointer it, pointer it_end, bool advance)        :    ht(h),    pos(it),    end(it_end)     {\n+    if (advance)        advance_past_empty_and_deleted();\n+  }\n+  pointer operator->() const { }\n+  void advance_past_empty_and_deleted() {\n+    while ( pos != end && (ht->test_empty(*this) || ht->test_deleted(*this)) )  ++pos;\n+  }\n+  const dense_hashtable<V,K,HF,ExK,EqK,A> *ht;\n+  pointer pos, end;\n+};\n+template <class V, class K, class HF, class ExK, class EqK, class A> struct dense_hashtable_const_iterator {\n+  typedef dense_hashtable_iterator<V,K,HF,ExK,EqK,A> iterator;\n+  typedef dense_hashtable_const_iterator<V,K,HF,ExK,EqK,A> const_iterator;\n+  typedef const V& reference;\n+  typedef const V* pointer;\n+  dense_hashtable_const_iterator(const dense_hashtable<V,K,HF,ExK,EqK,A> *h,  pointer it, pointer it_end, bool advance)          :  ht(h),  pos(it),  end(it_end)  \t{\n+    if (advance)  advance_past_empty_and_deleted();\n+  }\n+  dense_hashtable_const_iterator(const iterator &it)  :  pos(it.pos), end(it.end)  {}\n+  reference operator*() const  { return *pos; }\n+  pointer operator->() const {}\n+  void advance_past_empty_and_deleted() {\n+    while ( pos != end && (ht->test_empty(*this) || ht->test_deleted(*this))) ++pos;\n+  }\n+  const_iterator& operator++() { }\n+  bool operator!=(const const_iterator& it) const { }\n+  const dense_hashtable<V,K,HF,ExK,EqK,A> *ht;\n+  pointer pos, end;\n+};\n+template <class Value, class Key, class HashFcn,  class ExtractKey, class EqualKey, class Alloc> class dense_hashtable {\n+ public:   typedef Key key_type;\n+  typedef Value value_type;\n+  typedef HashFcn hasher;\n+  typedef EqualKey key_equal;\n+  typedef size_t size_type;\n+  typedef dense_hashtable_iterator<Value, Key, HashFcn,   ExtractKey, EqualKey, Alloc>   iterator;\n+  typedef dense_hashtable_const_iterator<Value, Key, HashFcn,  ExtractKey, EqualKey, Alloc>   const_iterator;\n+  static const float HT_OCCUPANCY_FLT;\n+  static const float HT_EMPTY_FLT;\n+  static const size_t HT_MIN_BUCKETS = 32;\n+  iterator end() {\n+    return iterator(this, table + num_buckets, table + num_buckets, true);\n+  }\n+  const_iterator end() const {\n+    return const_iterator(this, table + num_buckets, table+num_buckets,true);\n+  }\n+  void set_value(value_type* dst, const value_type& src) {\n+    new(dst) value_type(src);\n+  }\n+  void destroy_buckets(size_type first, size_type last) {\n+    for (; first != last; ++first) table[first].~value_type();\n+  }\n+ private:   void squash_deleted() {\n+    if ( num_deleted ) {\n+      dense_hashtable tmp(*this);\n+      swap(tmp);\n+    }\n+ }\n+  public:   void set_deleted_key(const value_type &val) { squash_deleted(); }\n+  bool test_deleted(size_type bucknum) const {\n+    return (use_deleted && num_deleted > 0 && equals(get_key(delval), get_key(table[bucknum])));\n+  }\n+  bool test_deleted(const const_iterator &it) const {\n+    return (use_deleted && num_deleted > 0 && equals(get_key(delval), get_key(*it)));\n+  }\n+  bool set_deleted(const_iterator &it) {\n+    set_value(const_cast<value_type*>(&(*it)), delval);\n+  }\n+  bool test_empty(size_type bucknum) const {\n+    return equals(get_key(emptyval), get_key(table[bucknum]));\n+  }\n+  bool test_empty(const const_iterator &it) const {\n+    return equals(get_key(emptyval), get_key(*it));\n+  }\n+  void fill_range_with_empty(value_type* table_start, value_type* table_end) {\n+    uninitialized_fill(table_start, table_end, emptyval);\n+  }\n+  void set_empty(size_type buckstart, size_type buckend) {\n+    destroy_buckets(buckstart, buckend);\n+    fill_range_with_empty(table + buckstart, table + buckend);\n+  }\n+  size_type size() const {\n+    return num_elements - num_deleted;\n+  }\n+  size_type bucket_count() const { }\n+  static const size_type ILLEGAL_BUCKET = size_type(-1);\n+  size_type min_size(size_type num_elts, size_type min_buckets_wanted) {\n+    size_type sz = HT_MIN_BUCKETS;\n+    while ( sz < min_buckets_wanted || num_elts >= sz * enlarge_resize_percent )  sz *= 2;\n+  }\n+  void maybe_shrink() {\n+    if (shrink_threshold > 0 &&  (num_elements-num_deleted) < shrink_threshold &&  bucket_count() > HT_MIN_BUCKETS ) {\n+      size_type sz = bucket_count() / 2;\n+      sz /= 2;\n+      dense_hashtable tmp(*this, sz);\n+      swap(tmp);\n+    }\n+  }\n+  void resize_delta(size_type delta, size_type min_buckets_wanted = 0) {\n+    if ( consider_shrink )       maybe_shrink();\n+    const size_type needed_size = min_size(num_elements + delta,  min_buckets_wanted);\n+    if ( needed_size > bucket_count() ) {\n+      const size_type resize_to = min_size(num_elements - num_deleted + delta,  min_buckets_wanted);\n+      dense_hashtable tmp(*this, resize_to);\n+      swap(tmp);\n+    }\n+  }\n+  void copy_from(const dense_hashtable &ht, size_type min_buckets_wanted = 0) {\n+    clear();\n+    const size_type resize_to = min_size(ht.size(), min_buckets_wanted);\n+    num_elements++;\n+  }\n+  explicit dense_hashtable(size_type n = 0, const HashFcn& hf = HashFcn(),       const EqualKey& eql = EqualKey(),const ExtractKey& ext = ExtractKey()) : num_deleted(0), use_deleted(false), use_empty(false), delval(),  emptyval(),      enlarge_resize_percent(HT_OCCUPANCY_FLT),      shrink_resize_percent(HT_EMPTY_FLT), table(__null), num_buckets(min_size(0, n)),  num_elements(0)  {\n+    reset_thresholds();\n+   }\n+   dense_hashtable(const dense_hashtable& ht, size_type min_buckets_wanted = 0) :   num_deleted(0), use_deleted(ht.use_deleted),   use_empty(ht.use_empty), delval(ht.delval), emptyval(ht.emptyval), enlarge_resize_percent(ht.enlarge_resize_percent),          shrink_resize_percent(ht.shrink_resize_percent),    table(__null),         num_buckets(0),    num_elements(0)  {\n+     reset_thresholds();\n+     copy_from(ht, min_buckets_wanted);\n+     set_value(&emptyval, ht.emptyval);\n+     enlarge_resize_percent = ht.enlarge_resize_percent;\n+     copy_from(ht);\n+   }\n+  ~dense_hashtable() {\n+    if (table) {\n+      destroy_buckets(0, num_buckets);\n+      free(table);\n+    }\n+  }\n+  void swap(dense_hashtable& ht) {\n+    std::swap(equals, ht.equals);\n+    {\n+      value_type tmp;\n+      set_value(&delval, ht.delval);\n+      set_value(&ht.delval, tmp);\n+      set_value(&ht.emptyval, tmp);\n+    }\n+    std::swap(table, ht.table);\n+    std::swap(num_buckets, ht.num_buckets);\n+    reset_thresholds();\n+    ht.reset_thresholds();\n+  }\n+  void clear() {\n+    if (table)  destroy_buckets(0, num_buckets);\n+    num_buckets = min_size(0,0);\n+    set_empty(0, num_buckets);\n+  }\n+  pair<size_type, size_type> find_position(const key_type &key) const {\n+    const size_type bucket_count_minus_one = bucket_count() - 1;\n+    size_type bucknum = hash(key) & bucket_count_minus_one;\n+    size_type insert_pos = ILLEGAL_BUCKET;\n+    while ( 1 ) {\n+      if ( test_empty(bucknum) ) {\n+        if ( insert_pos == ILLEGAL_BUCKET )  return pair<size_type,size_type>(ILLEGAL_BUCKET, insert_pos);\n+      }\n+      else if ( test_deleted(bucknum) ) {\n+        if ( insert_pos == ILLEGAL_BUCKET )            insert_pos = bucknum;\n+      }\n+      else if ( equals(key, get_key(table[bucknum])) ) {\n+        return pair<size_type,size_type>(bucknum, ILLEGAL_BUCKET);\n+      }\n+    }\n+  }\n+  iterator find(const key_type& key) {\n+    if ( size() == 0 ) return end();\n+    pair<size_type, size_type> pos = find_position(key);\n+    if ( pos.first == ILLEGAL_BUCKET )              return end();\n+    return iterator(this, table + pos.first, table + num_buckets, false);\n+  }\n+  const_iterator find(const key_type& key) const {\n+    if ( size() == 0 )         return end();\n+    pair<size_type, size_type> pos = find_position(key);\n+    if ( pos.first == ILLEGAL_BUCKET )                return end();\n+    return const_iterator(this, table + pos.first, table+num_buckets, false);\n+  }\n+  size_type count(const key_type &key) const {\n+    pair<size_type, size_type> pos = find_position(key); }\n+  pair<iterator, bool> insert_noresize(const value_type& obj) {\n+    const pair<size_type,size_type> pos = find_position(get_key(obj));\n+    if ( pos.first != ILLEGAL_BUCKET) {\n+      return pair<iterator,bool>(iterator(this, table + pos.first, table + num_buckets, false), false);\n+    }\n+    else {\n+      if ( test_deleted(pos.second) ) { ++num_elements; }\n+      return pair<iterator,bool>(iterator(this, table + pos.second, table + num_buckets, false), true);\n+    }\n+  }\n+  pair<iterator, bool> insert(const value_type& obj) {\n+    resize_delta(1);\n+    return insert_noresize(obj);\n+  }\n+  size_type erase(const key_type& key) {\n+    const_iterator pos = find(key);\n+    if ( pos != end() ) {\n+      set_deleted(pos);\n+    }\n+  }\n+  hasher hash;\n+  key_equal equals;\n+  ExtractKey get_key;\n+  size_type num_deleted;\n+  bool use_deleted;\n+  bool use_empty;\n+  value_type delval;\n+  value_type emptyval;\n+  float enlarge_resize_percent;\n+  float shrink_resize_percent;\n+  size_type shrink_threshold;\n+  size_type enlarge_threshold;\n+  value_type *table;\n+  size_type num_buckets;\n+  size_type num_elements;\n+  bool consider_shrink;\n+  void reset_thresholds() {\n+    enlarge_threshold = static_cast<size_type>(num_buckets  * shrink_resize_percent);\n+  }\n+};\n+template<> struct hash<long> {\n+  size_t operator()(long x) const {\n+  }\n+};\n+template<> struct hash<unsigned long> {\n+  size_t operator()(unsigned long x) const {\n+  }\n+};\n+template <class Key, class T, class HashFcn = hash<Key>,  class EqualKey = equal_to<Key>, class Alloc = allocator<T> > class dense_hash_map {\n+  struct SelectKey {\n+    const Key& operator()(const pair<const Key, T>& p) const {\n+      return p.first;\n+    }\n+  };\n+  typedef dense_hashtable<pair<const Key, T>, Key, HashFcn, SelectKey, EqualKey, Alloc> ht;\n+  ht rep;\n+ public:    typedef typename ht::key_type key_type;\n+  typedef T data_type;\n+  typedef typename ht::value_type value_type;\n+  typedef typename ht::size_type size_type;\n+  typedef typename ht::iterator iterator;\n+  typedef typename ht::const_iterator const_iterator;\n+  iterator end() {\n+    return rep.end();\n+  }\n+  iterator find(const key_type& key) { return rep.find(key); }\n+  data_type& operator[](const key_type& key) {\n+    iterator it = find(key);\n+    return insert(value_type(key, data_type())).first->second;\n+  }\n+  pair<iterator, bool> insert(const value_type& obj) {\n+    return rep.insert(obj);\n+  }\n+  void set_deleted_key(const key_type& key) {\n+    rep.set_deleted_key(value_type(key, data_type()));\n+  }\n+  size_type erase(const key_type& key) { return rep.erase(key); }\n+};\n+template <class Value, class HashFcn = hash<Value>, class EqualKey = equal_to<Value>, class Alloc = allocator<Value> > class dense_hash_set {\n+  struct Identity {\n+    const Value& operator()(const Value& v) const { return v; }\n+  };\n+  typedef dense_hashtable<Value, Value, HashFcn, Identity, EqualKey, Alloc> ht;\n+  ht rep;\n+ public:    typedef typename ht::key_type key_type;\n+  typedef typename ht::value_type value_type;\n+  typedef typename ht::size_type size_type;\n+  typedef typename ht::const_iterator iterator;\n+  size_type count(const key_type& key) const {\n+    return rep.count(key);\n+  }\n+  pair<iterator, bool> insert(const value_type& obj) {\n+    pair<typename ht::iterator, bool> p = rep.insert(obj);\n+  }\n+  size_type erase(const key_type& key) {\n+    return rep.erase(key);\n+  }\n+};\n+class linked_ptr_internal {\n+ public:   bool depart() { if (next_ == this) return true; }\n+  mutable linked_ptr_internal const* next_;\n+};\n+template <typename T> class linked_ptr {\n+ public:     explicit linked_ptr(T* ptr = __null) {\n+ }\n+  ~linked_ptr() { depart(); }\n+  T& operator*() const { }\n+  T* value_;\n+  linked_ptr_internal link_;\n+  void depart() {\n+    if (link_.depart()) delete value_;\n+  }\n+};\n+class blah_3 {\n+  const char* ptr_;\n+  int length_;\n+ public:   blah_3(const char* str) : ptr_(str), length_((str == __null) ? 0 : static_cast<int>(strlen(str))) { }\n+};\n+class blah_5;\n+class Bitmap {\n+ public:   Bitmap(unsigned int size) : array_size_(RequiredArraySize(size)) { }\n+  static unsigned int RequiredArraySize(unsigned int num_bits) { return (num_bits + 31) >> 5; }\n+   unsigned int array_size_;\n+};\n+enum blah_31 { CREATIVE_FORMAT_TEXT_NARROW,  kNumblah_31s  };\n+enum blah_33 { BLACKLISTED  }; \n+template <typename EnumT> class blah_55;\n+typedef blah_55<blah_31> blah_31Set;\n+enum blah_36 { APPROVAL_STATUS_APPROVED, APPROVAL_STATUS_UNKNOWN };\n+enum blah_37 { hahah_INVALID, hahah_KEYWORD };\n+template<typename EnumT> class blah_55 {\n+ public:    blah_55(int enum_size);\n+  bool Insert(EnumT x);\n+  const int enum_size_;\n+  Bitmap elements_;\n+};\n+template<typename EnumT> blah_55<EnumT>::blah_55(int enum_size) :enum_size_(enum_size), elements_(enum_size)   {\n+  while (foo_1 _result = Check_GTImpl(1, 0, \"enum_size\" \" \" \">\" \" \" \"0\")) blah_0(\".h\", 1902, _result).stream();\n+};\n+enum blah_38 {\n+  ttttttt_9,    };\n+class blah_46 {\n+ public:   blah_46()       :     hahaha_id_(0),             type_(hahah_INVALID),             approval_status_(APPROVAL_STATUS_APPROVED)     {\n+ }\n+  blah_46(long cid)       :     hahaha_id_(cid),             type_(hahah_INVALID),             approval_status_(APPROVAL_STATUS_APPROVED)    {\n+  }\n+  long id() const {\n+    return (static_cast<long>(hahaha_id_) << 16) >> 16;\n+  }\n+  static const blah_46 kBlacklistedID;\n+  bool operator == (const blah_46& x) const { return id() == x.id(); }\n+  bool operator < (const blah_46& x) const { return id() < x.id(); }\n+  long hahaha_id_ : 48;\n+  blah_37 type_ : 8;\n+  blah_36 approval_status_ : 4;\n+};\n+template <> struct hash<blah_46> {\n+  size_t operator()(const blah_46 &x) const {\n+    return size_t(x.id());\n+  }\n+};\n+class blah_57 {\n+ public:   blah_57();\n+  void AddReason(blah_33 reason, const blah_3& debug_str, const blah_46& hahaha_id, bool );\n+  void set_collects_multiple_reasons(bool t) { }\n+ private:   struct foo_3 {\n+   string reject_desc;\n+ };\n+  foo_3 first_reason_;\n+};\n+template <class T> struct foo_5   : public unary_function<T*, long> {\n+  long operator()(const T* p) const {\n+    long id = reinterpret_cast<long>(p);\n+    if (id < 2)  return -id;\n+  }\n+};\n+template <class T> class DensePtrSet : public dense_hashtable<T*, long,   hash<long>, foo_5<T>, equal_to<long>, allocator<T*> > {\n+ public:    DensePtrSet() {\n+   this->set_deleted_key(reinterpret_cast<T*>(1));\n+ }\n+  const T* Find(long key) const {\n+    typename DensePtrSet<T>::const_iterator it = this->find(key);\n+    return it != this->end() ? *it : __null;\n+  }\n+};\n+struct foo_7 {\n+  foo_7(bool spell_correction, bool query_broadening, bool previous_query, bool near_aaaaa, bool same_length, float mult, float exp_score)    :     shengmo_0(spell_correction),    shengmo_1(query_broadening),    shengmo_2(previous_query),    shengmo_3(near_aaaaa),    shengmo_4(same_length),    multiplier(mult),    expansion_score(exp_score)    {\n+  }\n+  int CompareSameKeywordMatch(const foo_7& compare) const;\n+  bool shengmo_0, shengmo_1, shengmo_2, shengmo_3, shengmo_4;\n+  float multiplier, expansion_score;\n+};\n+enum blah_41 {\n+  ACP_ECPM_EARLY = 2 };\n+struct foo_8  { unsigned int packed_ctr1; };\n+struct foo_9  { foo_9() {}};\n+class blah_16;\n+class blah_17;\n+class foo_12 { public:   foo_12() {}\n+  unsigned long hahaha_id() const {}\n+  unsigned int qbb_score() const {}\n+ private:   static const vector<blah_46> hmmmmh_4;\n+  long hahaha_id_ : 40;\n+};\n+class foo_13 {\n+ public:    typedef dense_hash_map<long, int> BestMap;\n+  foo_13() { best_rrrrrrr_.set_deleted_key(-1); }\n+  void erase(long ad_group_id)  {\n+    best_rrrrrrr_.erase(ad_group_id);\n+  }\n+  typedef BestMap::iterator iterator;\n+  typedef BestMap::const_iterator const_iterator;\n+  const_iterator begin() const  { }\n+  iterator end() { return best_rrrrrrr_.end(); }\n+  iterator find(long ad_group_id) { return best_rrrrrrr_.find(ad_group_id); }\n+   const foo_12& GetMatch(const_iterator it) const {}\n+  void hmmmmh_27(long ad_group_id, const foo_12& addme);\n+ private:   BestMap best_rrrrrrr_;\n+  vector<foo_12> rrrrrrr_buffer_;\n+};\n+struct foo_10  : public dense_hash_set<blah_46> {};\n+class foo_9Set : public DensePtrSet<foo_9> {};\n+typedef map<blah_46, foo_7*> foo_6Data;\n+typedef hash_map<long, linked_ptr<blah_57> > RejectedAdGroupMap;\n+enum blah_43 {};\n+class foo_14 {\n+ public:   foo_14(const unsigned int, const blah_16*, const int*);\n+  bool GathersMultipleRejectionReasons() const;\n+  void hmmmmh_30(blah_46 hahaha_id, blah_38 type);\n+  const foo_7* Insertfoo_6(const blah_46 hahaha_id, bool shengmo_0, bool shengmo_1, bool shengmo_2, bool shengmo_3, bool shengmo_4_rewrite, float multiplier, float context_score);\n+  void hmmmmh_7(blah_46 hahaha_id, blah_38 type);\n+  foo_9* Insertfoo_9();\n+  bool hmmmmh_8(long ad_group_id, const foo_12 &entry);\n+  void hmmmmh_9(long ad_group_id);\n+  foo_13::iterator hmmmmh_0(long ad_group_id);\n+  bool hmmmmh_8(long ad_group_id, foo_13::iterator best, const foo_12& entry);\n+  void hmmmmh_5(const blah_46 hahaha_id);\n+  void hmmmmh_29(const blah_46 hahaha_id);\n+  bool hmmmmh_12(const blah_46 hahaha_id) const;\n+  bool hmmmmh_13(const blah_46 hahaha_id) const;\n+  const foo_9* Getfoo_9(const blah_46 hahaha_id) const;\n+  bool Gathersfoo_9() const {}\n+  const foo_10* rrrrrrr_type_data() const {}\n+  const foo_10* negative_rrrrrrr_type_data() const {}\n+  const foo_10* positive_rrrrrrr_type_data() const {}\n+  const foo_9Set* kw_info_set() const { }\n+   const foo_6Data* rewrite_data() const {}\n+  const vector<blah_17>& query_rectangles() const {}\n+   void hmmmmh_14();\n+   void AddQueryRectangle(const blah_17& query_rectangle);\n+   void hmmmmh_15(long ad_group_id, const blah_46 hahaha_id,  blah_33 reject_class, const char* reject_desc = __null);\n+   void hmmmmh_16(const vector<long>& rejected_sssr_ids);\n+   void Copy(const foo_14& cmi);\n+   void hmmmmh_10();\n+ private:   const blah_16* ad_request_;\n+  const int* cr_query_;\n+  blah_43 gather_flags_;\n+  vector<blah_17> query_rectangles_;\n+  foo_10 rrrrrrr_type_data_;\n+  foo_9Set kw_info_set_;\n+  foo_6Data rewrite_data_;\n+  scoped_ptr<RejectedAdGroupMap> rejected_sssr_map_;\n+  foo_13 ad_group_rrrrrrr_data_;\n+  vector<blah_46> geo_hahaha_;\n+  bool geo_hahaha_is_sorted_;\n+  foo_10 negative_rrrrrrr_type_data_, positive_rrrrrrr_type_data_;\n+  scoped_ptr<foo_10> extra_hahaha_set_;\n+  int dimension_id_;\n+  blah_31Set creative_formats_;\n+  scoped_ptr<dense_hash_set<unsigned long> > near_aaaaa_rrrrrrr_fps_;\n+  blah_41 comparison_policy_;\n+  blah_46 next_virtual_hahaha_id_;\n+  vector<void*>* sub_queries_;\n+  bool allow_only_whitelisted_customers_, automatic_hahaha_rrrrrrr_;\n+  scoped_ptr<blah_5> kw_arena_, expanded_rrrrrrr_arena_;\n+};\n+class blah_19 {\n+  void hmmmmh_3();\n+  enum blah_45 {};\n+};\n+void blah_19::hmmmmh_3() {}\n+class blah_16 {\n+ public:   int near_aaaaa_rrrrrrr_fps_size() const {}\n+  unsigned long near_aaaaa_rrrrrrr_fps(int i) const {}\n+};\n+class blah_21 {\n+ protected:   blah_21(char* first_block, const size_t block_size, bool align_to_page);\n+  void* GetMemoryFallback(const size_t size, const int align);\n+  void* GetMemory(const size_t size, const int align) {\n+    if ( size > 0 && size < remaining_ && align == 1 ) {\n+      last_alloc_ = freestart_;\n+    }\n+    return GetMemoryFallback(size, align);\n+  }\n+  char* freestart_;\n+  char* last_alloc_;\n+  size_t remaining_;\n+};\n+class blah_5 : blah_21 {\n+ public:   char* Alloc(const size_t size) {\n+   return reinterpret_cast<char*>(GetMemory(size, 1));\n+ }\n+};\n+class blah_25 {\n+ public:   virtual ~blah_25();\n+};\n+class blah_17 : blah_25 { };\n+void Fillfoo_8(const foo_12& x2, struct foo_8* out) {\n+  out->packed_ctr1 = x2.qbb_score();\n+}\n+const vector<blah_46> foo_12::hmmmmh_4;\n+foo_14::foo_14(const unsigned int gather_flags,   const blah_16* ad_request, const int* cr_query):    ad_request_(ad_request),     cr_query_(cr_query),        gather_flags_(static_cast<blah_43>(gather_flags)),      geo_hahaha_is_sorted_(false),         dimension_id_(0),       creative_formats_(kNumblah_31s),         comparison_policy_(ACP_ECPM_EARLY),      sub_queries_(new vector<void*>()),         allow_only_whitelisted_customers_(false),       automatic_hahaha_rrrrrrr_(false) {\n+  hmmmmh_10();\n+}\n+void foo_14::hmmmmh_5(const blah_46 hahaha_id) {\n+  negative_rrrrrrr_type_data_.insert(hahaha_id);\n+}\n+void foo_14::hmmmmh_7(blah_46 hahaha_id, blah_38 type) { }\n+foo_13::iterator foo_14::hmmmmh_0(     long ad_group_id) {\n+  return ad_group_rrrrrrr_data_.find(ad_group_id);\n+}\n+bool foo_14::hmmmmh_8(long ad_group_id, foo_13::iterator best, const foo_12& entry) {\n+  rejected_sssr_map_->erase(ad_group_id);\n+  ad_group_rrrrrrr_data_.hmmmmh_27(ad_group_id, entry);\n+}\n+bool foo_14::hmmmmh_8(long ad_group_id, const foo_12& entry) {\n+  foo_13::iterator best = hmmmmh_0(ad_group_id);\n+}\n+void foo_14::hmmmmh_9(long ad_group_id) {\n+  ad_group_rrrrrrr_data_.erase(ad_group_id);\n+}\n+void foo_14::hmmmmh_10() {\n+  if (near_aaaaa_rrrrrrr_fps_ != __null) {\n+    blah_54(\".cc\", 226, WARNING).stream() << \"\";\n+    for (int j = 0;\n+         j < ad_request_->near_aaaaa_rrrrrrr_fps_size(); j++) {\n+      near_aaaaa_rrrrrrr_fps_->insert(ad_request_->near_aaaaa_rrrrrrr_fps(j));\n+    }\n+  }\n+}\n+const foo_7* foo_14::Insertfoo_6(const blah_46 hahaha_id, bool shengmo_0, bool shengmo_1, bool shengmo_2,  bool shengmo_3, bool shengmo_4_rewrite, float multiplier, float context_score) {\n+  if (rrrrrrr_type_data_.count(hahaha_id) > 0)   return __null;\n+  foo_7* new_info =  new(expanded_rrrrrrr_arena_->Alloc(sizeof(foo_7))) foo_7(shengmo_0,shengmo_1, shengmo_2, shengmo_3, shengmo_4_rewrite, multiplier, context_score);\n+  pair<foo_6Data::iterator, bool> status = rewrite_data_.insert( make_pair(hahaha_id, new_info));\n+  foo_7* inserted = status.first->second;\n+  if (!status.second) {\n+    if (inserted->CompareSameKeywordMatch(*new_info) < 0)   *inserted = *new_info;\n+  }\n+}\n+foo_9* foo_14::Insertfoo_9() {\n+  foo_9* info = new(kw_arena_->Alloc(sizeof(foo_9))) foo_9;\n+  if (Gathersfoo_9())     kw_info_set_.insert(info);\n+  creative_formats_.Insert(CREATIVE_FORMAT_TEXT_NARROW);\n+}\n+bool foo_14::hmmmmh_12(const blah_46 hahaha_id) const {\n+  if (rrrrrrr_type_data_.count(hahaha_id)) return true;\n+}\n+bool foo_14::hmmmmh_13(const blah_46 hahaha_id) const {\n+  if (positive_rrrrrrr_type_data_.count(hahaha_id)) return true;\n+}\n+const foo_9* foo_14::Getfoo_9(const blah_46 hahaha_id) const {\n+  if (Gathersfoo_9())     return kw_info_set_.Find(hahaha_id.id());\n+  static int occurrences_383 = 0, occurrences_mod_n_383 = 0;\n+  if (++occurrences_mod_n_383 > 1000)      occurrences_mod_n_383 -= 1000;\n+}\n+void foo_14::hmmmmh_15(long ad_group_id, const blah_46 hahaha_id,  blah_33 reject_class,  const char* reject_desc) {\n+  if (rejected_sssr_map_ == __null) {\n+    blah_54(\"a.cc\", 413, ERROR).stream() << \"re NULL\";\n+    rejected_sssr_map_.reset(new RejectedAdGroupMap);\n+  }\n+  if (rejected_sssr_map_->count(ad_group_id) == 0) {\n+    blah_57* ad_rejection = new blah_57();\n+    ad_rejection->set_collects_multiple_reasons( GathersMultipleRejectionReasons());\n+    (*rejected_sssr_map_)[ad_group_id] = linked_ptr<blah_57>(ad_rejection);\n+  }\n+  blah_57& ad_rejection = *(*rejected_sssr_map_)[ad_group_id];\n+  ad_rejection.AddReason(reject_class, reject_desc, hahaha_id, false);\n+}\n+void foo_14::hmmmmh_16(const vector<long>& rejected_sssr_ids) {\n+  for (vector<long>::const_iterator it = rejected_sssr_ids.begin();\n+       it != rejected_sssr_ids.end(); ++it) {\n+    ad_group_rrrrrrr_data_.erase(*it);\n+    for (foo_13::const_iterator it = ad_group_rrrrrrr_data_.begin();\n+         it != ad_group_rrrrrrr_data_.end(); ++it) {\n+      hmmmmh_15(it->first,  ad_group_rrrrrrr_data_.GetMatch(it).hahaha_id(), BLACKLISTED);\n+    }\n+  }\n+  hmmmmh_30(blah_46::kBlacklistedID, ttttttt_9);\n+}\n+void foo_14::Copy(const foo_14& cmi) {\n+  rrrrrrr_type_data_ = *cmi.rrrrrrr_type_data();\n+  negative_rrrrrrr_type_data_ = *cmi.negative_rrrrrrr_type_data();\n+  positive_rrrrrrr_type_data_ = *cmi.positive_rrrrrrr_type_data();\n+  if (cmi.Gathersfoo_9()) {\n+    kw_info_set_ = *cmi.kw_info_set();\n+    rewrite_data_ = *cmi.rewrite_data();\n+  }\n+  hmmmmh_14();\n+  for (int i = 0; i < cmi.query_rectangles().size();\n+       ++i)  AddQueryRectangle(cmi.query_rectangles()[i]);\n+}\n+void foo_13::hmmmmh_27(long ad_group_id, const foo_12& addme) {\n+  int& best_index = best_rrrrrrr_[ad_group_id];\n+  rrrrrrr_buffer_.push_back(addme);\n+}\n+void foo_14::hmmmmh_29(const blah_46 hahaha_id) {\n+  if (extra_hahaha_set_ != __null) extra_hahaha_set_->erase(hahaha_id);\n+}"}, {"sha": "64c697a51968084608df3665add68ae1930aacb0", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4577cea1cde9b4c1c9d92d63920a3bd8ff81c2c4/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4577cea1cde9b4c1c9d92d63920a3bd8ff81c2c4/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=4577cea1cde9b4c1c9d92d63920a3bd8ff81c2c4", "patch": "@@ -908,7 +908,8 @@ copy_prop_visit_phi_node (gimple phi)\n \t}\n     }\n \n-  if (phi_val.value && set_copy_of_val (lhs, phi_val.value))\n+  if (phi_val.value &&  may_propagate_copy (lhs, phi_val.value)\n+      && set_copy_of_val (lhs, phi_val.value))\n     retval = (phi_val.value != lhs) ? SSA_PROP_INTERESTING : SSA_PROP_VARYING;\n   else\n     retval = SSA_PROP_NOT_INTERESTING;"}]}