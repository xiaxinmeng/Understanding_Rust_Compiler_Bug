{"sha": "e4abc3d580c4fb7f63776b4653a710f30e57a265", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRhYmMzZDU4MGM0ZmI3ZjYzNzc2YjQ2NTNhNzEwZjMwZTU3YTI2NQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-12-23T13:02:18Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-12-23T13:02:18Z"}, "message": "calls.c (expand_call): Don't turn off ECF_LIBCALL_BLOCK for an invalid result register...\n\n        * calls.c (expand_call): Don't turn off ECF_LIBCALL_BLOCK for\n        an invalid result register; do end the sequence properly.\n        (emit_library_call_value_1): Likewise.\n\nFrom-SVN: r48287", "tree": {"sha": "9e46f90736e54cf6b2d557a083a96a27c888a025", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e46f90736e54cf6b2d557a083a96a27c888a025"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4abc3d580c4fb7f63776b4653a710f30e57a265", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4abc3d580c4fb7f63776b4653a710f30e57a265", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4abc3d580c4fb7f63776b4653a710f30e57a265", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4abc3d580c4fb7f63776b4653a710f30e57a265/comments", "author": null, "committer": null, "parents": [{"sha": "ece2d1b8245459f35afcaf72ff1f5cd1d1c859e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ece2d1b8245459f35afcaf72ff1f5cd1d1c859e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ece2d1b8245459f35afcaf72ff1f5cd1d1c859e5"}], "stats": {"total": 117, "additions": 71, "deletions": 46}, "files": [{"sha": "3db09bb78395dc71d5df89f28384197e074de266", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4abc3d580c4fb7f63776b4653a710f30e57a265/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4abc3d580c4fb7f63776b4653a710f30e57a265/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4abc3d580c4fb7f63776b4653a710f30e57a265", "patch": "@@ -1,3 +1,9 @@\n+2001-12-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* calls.c (expand_call): Don't turn off ECF_LIBCALL_BLOCK for\n+\tan invalid result register; do end the sequence properly.\n+\t(emit_library_call_value_1): Likewise.\n+\n 2001-12-22  Aldy Hernandez  <aldyh@redhat.com>\n \n         * config/rs6000/rs6000.h (rs6000_builtins): Add vsldoi variants."}, {"sha": "a6c999c01253fd26dba5a3084e7329b608eae9a9", "filename": "gcc/calls.c", "status": "modified", "additions": 65, "deletions": 46, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4abc3d580c4fb7f63776b4653a710f30e57a265/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4abc3d580c4fb7f63776b4653a710f30e57a265/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=e4abc3d580c4fb7f63776b4653a710f30e57a265", "patch": "@@ -2937,9 +2937,6 @@ expand_call (exp, target, ignore)\n \t    valreg = hard_function_value (TREE_TYPE (exp), fndecl, (pass == 0));\n \t}\n \n-      if (valreg == 0 || GET_CODE (valreg) == PARALLEL)\n-        flags &= ~ECF_LIBCALL_BLOCK;\n-\n       /* Precompute all register parameters.  It isn't safe to compute anything\n \t once we have started filling any specific hard regs.  */\n       precompute_register_parameters (num_actuals, args, &reg_parm_seen);\n@@ -3071,32 +3068,45 @@ expand_call (exp, target, ignore)\n \t we have no way to move such values into a pseudo register.  */\n       if (pass && (flags & ECF_LIBCALL_BLOCK))\n \t{\n-\t  rtx note = 0;\n-\t  rtx temp = gen_reg_rtx (GET_MODE (valreg));\n \t  rtx insns;\n \n-\t  /* Mark the return value as a pointer if needed.  */\n-\t  if (TREE_CODE (TREE_TYPE (exp)) == POINTER_TYPE)\n-\t    mark_reg_pointer (temp, TYPE_ALIGN (TREE_TYPE (TREE_TYPE (exp))));\n-\n-\t  /* Construct an \"equal form\" for the value which mentions all the\n-\t     arguments in order as well as the function name.  */\n-\t  for (i = 0; i < num_actuals; i++)\n-\t    note = gen_rtx_EXPR_LIST (VOIDmode, args[i].initial_value, note);\n-\t  note = gen_rtx_EXPR_LIST (VOIDmode, funexp, note);\n-\n-\t  insns = get_insns ();\n-\t  end_sequence ();\n-\n-\t  if (flags & ECF_PURE)\n-\t    note = gen_rtx_EXPR_LIST (VOIDmode,\n-\t       gen_rtx_USE (VOIDmode,\n-\t\t\t    gen_rtx_MEM (BLKmode,\n-\t\t\t\t    \t gen_rtx_SCRATCH (VOIDmode))), note);\n-\n-\t  emit_libcall_block (insns, temp, valreg, note);\n-\n-\t  valreg = temp;\n+\t  if (valreg == 0 || GET_CODE (valreg) == PARALLEL)\n+\t    {\n+\t      insns = get_insns ();\n+\t      end_sequence ();\n+\t      emit_insns (insns);\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx note = 0;\n+\t      rtx temp = gen_reg_rtx (GET_MODE (valreg));\n+\n+\t      /* Mark the return value as a pointer if needed.  */\n+\t      if (TREE_CODE (TREE_TYPE (exp)) == POINTER_TYPE)\n+\t\tmark_reg_pointer (temp,\n+\t\t\t\t  TYPE_ALIGN (TREE_TYPE (TREE_TYPE (exp))));\n+\n+\t      /* Construct an \"equal form\" for the value which mentions all the\n+\t\t arguments in order as well as the function name.  */\n+\t      for (i = 0; i < num_actuals; i++)\n+\t\tnote = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t  args[i].initial_value, note);\n+\t      note = gen_rtx_EXPR_LIST (VOIDmode, funexp, note);\n+\n+\t      insns = get_insns ();\n+\t      end_sequence ();\n+\n+\t      if (flags & ECF_PURE)\n+\t\tnote = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\tgen_rtx_USE (VOIDmode,\n+\t\t\t\t     gen_rtx_MEM (BLKmode,\n+\t\t\t\t\t\t  gen_rtx_SCRATCH (VOIDmode))),\n+\t\t\tnote);\n+\n+\t      emit_libcall_block (insns, temp, valreg, note);\n+\n+\t      valreg = temp;\n+\t    }\n \t}\n       else if (pass && (flags & ECF_MALLOC))\n \t{\n@@ -4021,8 +4031,6 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n   NO_DEFER_POP;\n   valreg = (mem_value == 0 && outmode != VOIDmode\n \t    ? hard_libcall_value (outmode) : NULL_RTX);\n-  if (valreg == 0 || GET_CODE (valreg) == PARALLEL)\n-    flags &= ~ECF_LIBCALL_BLOCK;\n \n   /* Stack must be properly aligned now.  */\n   if (stack_pointer_delta & (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT - 1))\n@@ -4078,29 +4086,40 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n      we have no way to move such values into a pseudo register.  */\n   if (flags & ECF_LIBCALL_BLOCK)\n     {\n-      rtx note = 0;\n-      rtx temp = gen_reg_rtx (GET_MODE (valreg));\n       rtx insns;\n-      int i;\n \n-      /* Construct an \"equal form\" for the value which mentions all the\n-\t arguments in order as well as the function name.  */\n-      for (i = 0; i < nargs; i++)\n-\tnote = gen_rtx_EXPR_LIST (VOIDmode, argvec[i].value, note);\n-      note = gen_rtx_EXPR_LIST (VOIDmode, fun, note);\n+      if (valreg == 0 || GET_CODE (valreg) == PARALLEL)\n+\t{\n+\t  insns = get_insns ();\n+\t  end_sequence ();\n+\t  emit_insns (insns);\n+\t}\n+      else\n+\t{\n+\t  rtx note = 0;\n+\t  rtx temp = gen_reg_rtx (GET_MODE (valreg));\n+\t  int i;\n \n-      insns = get_insns ();\n-      end_sequence ();\n+\t  /* Construct an \"equal form\" for the value which mentions all the\n+\t     arguments in order as well as the function name.  */\n+\t  for (i = 0; i < nargs; i++)\n+\t    note = gen_rtx_EXPR_LIST (VOIDmode, argvec[i].value, note);\n+\t  note = gen_rtx_EXPR_LIST (VOIDmode, fun, note);\n \n-      if (flags & ECF_PURE)\n-\tnote = gen_rtx_EXPR_LIST (VOIDmode,\n-\t   gen_rtx_USE (VOIDmode,\n-\t\t\tgen_rtx_MEM (BLKmode,\n-\t\t\t\t     gen_rtx_SCRATCH (VOIDmode))), note);\n+\t  insns = get_insns ();\n+\t  end_sequence ();\n \n-      emit_libcall_block (insns, temp, valreg, note);\n+\t  if (flags & ECF_PURE)\n+\t    note = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\tgen_rtx_USE (VOIDmode,\n+\t\t\t\t     gen_rtx_MEM (BLKmode,\n+\t\t\t\t\t\t  gen_rtx_SCRATCH (VOIDmode))),\n+\t\t\tnote);\n+\n+\t  emit_libcall_block (insns, temp, valreg, note);\n \n-      valreg = temp;\n+\t  valreg = temp;\n+\t}\n     }\n   pop_temp_slots ();\n "}]}