{"sha": "237dde3d03c573eb13c0e765520ee4b713aa2c7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM3ZGRlM2QwM2M1NzNlYjEzYzBlNzY1NTIwZWU0YjcxM2FhMmM3ZQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-04-30T22:45:46Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-04-30T22:45:46Z"}, "message": "libstdc++: Implement P2328 changes to join_view\n\nThis implements the wording changes of P2328R0 \"join_view should join\nall views of ranges\".\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/ranges (__detail::__non_propating_cache): Define\n\tas per P2328.\n\t(join_view): Remove constraints on the value and reference types\n\tof the wrapped iterator type as per P2328.\n\t(join_view::_Iterator::_M_satisfy): Adjust as per P2328.\n\t(join_view::_Iterator::operator++): Likewise.\n\t(join_view::_M_inner): Use __non_propating_cache as per P2328.\n\tRemove now-redundant use of __maybe_present_t.\n\t* testsuite/std/ranges/adaptors/join.cc: Include <array>.\n\t(test10): New test.", "tree": {"sha": "e941c9283504e5b8d717ef25fed3b318f4b705b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e941c9283504e5b8d717ef25fed3b318f4b705b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/237dde3d03c573eb13c0e765520ee4b713aa2c7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/237dde3d03c573eb13c0e765520ee4b713aa2c7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/237dde3d03c573eb13c0e765520ee4b713aa2c7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/237dde3d03c573eb13c0e765520ee4b713aa2c7e/comments", "author": null, "committer": null, "parents": [{"sha": "3215d4f5b3d08e0087a88df9e155c779927ace1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3215d4f5b3d08e0087a88df9e155c779927ace1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3215d4f5b3d08e0087a88df9e155c779927ace1a"}], "stats": {"total": 101, "additions": 90, "deletions": 11}, "files": [{"sha": "4a7ca49b45d0c21322d96faf35676276b9d55f77", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 66, "deletions": 11, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/237dde3d03c573eb13c0e765520ee4b713aa2c7e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/237dde3d03c573eb13c0e765520ee4b713aa2c7e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=237dde3d03c573eb13c0e765520ee4b713aa2c7e", "patch": "@@ -2241,10 +2241,68 @@ namespace views::__adaptor\n     inline constexpr _DropWhile drop_while;\n   } // namespace views\n \n+  namespace __detail\n+  {\n+    template<typename _Tp>\n+      struct __non_propagating_cache\n+      {\n+\t// When _Tp is not an object type (e.g. is a reference type), we make\n+\t// __non_propagating_cache<_Tp> empty rather than ill-formed so that\n+\t// users can easily conditionally declare data members with this type\n+\t// (such as join_view::_M_inner).\n+      };\n+\n+    template<typename _Tp>\n+      requires is_object_v<_Tp>\n+      struct __non_propagating_cache<_Tp> : private _Optional_base<_Tp>\n+      {\n+\t__non_propagating_cache() = default;\n+\n+\tconstexpr\n+\t__non_propagating_cache(const __non_propagating_cache&) noexcept\n+\t{ }\n+\n+\tconstexpr\n+\t__non_propagating_cache(__non_propagating_cache&& __other) noexcept\n+\t{ __other._M_reset(); }\n+\n+\tconstexpr __non_propagating_cache&\n+\toperator=(const __non_propagating_cache& __other) noexcept\n+\t{\n+\t  if (std::__addressof(__other) != this)\n+\t    this->_M_reset();\n+\t  return *this;\n+\t}\n+\n+\tconstexpr __non_propagating_cache&\n+\toperator=(__non_propagating_cache&& __other) noexcept\n+\t{\n+\t  this->_M_reset();\n+\t  __other._M_reset();\n+\t  return *this;\n+\t}\n+\n+\tconstexpr _Tp&\n+\toperator*() noexcept\n+\t{ return this->_M_get(); }\n+\n+\ttemplate<typename _Iter>\n+\t  _Tp&\n+\t  _M_emplace_deref(const _Iter& __i)\n+\t  {\n+\t    this->_M_reset();\n+\t    // Using _Optional_base::_M_construct to initialize from '*__i'\n+\t    // would incur an extra move due to the indirection, so we instead\n+\t    // use placement new directly.\n+\t    ::new ((void *) std::__addressof(this->_M_payload._M_payload)) _Tp(*__i);\n+\t    this->_M_payload._M_engaged = true;\n+\t    return this->_M_get();\n+\t  }\n+      };\n+  }\n+\n   template<input_range _Vp>\n     requires view<_Vp> && input_range<range_reference_t<_Vp>>\n-      && (is_reference_v<range_reference_t<_Vp>>\n-\t  || view<range_value_t<_Vp>>)\n     class join_view : public view_interface<join_view<_Vp>>\n     {\n     private:\n@@ -2310,17 +2368,16 @@ namespace views::__adaptor\n \t  constexpr void\n \t  _M_satisfy()\n \t  {\n-\t    auto __update_inner = [this] (range_reference_t<_Base> __x) -> auto&\n-\t    {\n+\t    auto __update_inner = [this] (const iterator_t<_Base>& __x) -> auto&& {\n \t      if constexpr (_S_ref_is_glvalue)\n-\t\treturn __x;\n+\t\treturn *__x;\n \t      else\n-\t\treturn (_M_parent->_M_inner = views::all(std::move(__x)));\n+\t\treturn _M_parent->_M_inner._M_emplace_deref(__x);\n \t    };\n \n \t    for (; _M_outer != ranges::end(_M_parent->_M_base); ++_M_outer)\n \t      {\n-\t\tauto& __inner = __update_inner(*_M_outer);\n+\t\tauto&& __inner = __update_inner(_M_outer);\n \t\t_M_inner = ranges::begin(__inner);\n \t\tif (_M_inner != ranges::end(__inner))\n \t\t  return;\n@@ -2396,7 +2453,7 @@ namespace views::__adaptor\n \t      if constexpr (_S_ref_is_glvalue)\n \t\treturn *_M_outer;\n \t      else\n-\t\treturn _M_parent->_M_inner;\n+\t\treturn *_M_parent->_M_inner;\n \t    }();\n \t    if (++_M_inner == ranges::end(__inner_range))\n \t      {\n@@ -2507,10 +2564,8 @@ namespace views::__adaptor\n \t  friend _Sentinel<!_Const>;\n \t};\n \n-      // XXX: _M_inner is \"present only when !is_reference_v<_InnerRange>\"\n       [[no_unique_address]]\n-\t__detail::__maybe_present_t<!is_reference_v<_InnerRange>,\n-\t\t\t\t    views::all_t<_InnerRange>> _M_inner;\n+\t__detail::__non_propagating_cache<remove_cv_t<_InnerRange>> _M_inner;\n       _Vp _M_base = _Vp();\n \n     public:"}, {"sha": "d774e8d938595501b44d4319430874def7d3a286", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/join.cc", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/237dde3d03c573eb13c0e765520ee4b713aa2c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fjoin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/237dde3d03c573eb13c0e765520ee4b713aa2c7e/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fjoin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fjoin.cc?ref=237dde3d03c573eb13c0e765520ee4b713aa2c7e", "patch": "@@ -19,6 +19,7 @@\n // { dg-do run { target c++2a } }\n \n #include <algorithm>\n+#include <array>\n #include <ranges>\n #include <string>\n #include <string_view>\n@@ -170,6 +171,28 @@ test10()\n   VERIFY( ranges::next(v.begin()) == v.end() );\n }\n \n+void\n+test11()\n+{\n+  // Verify P2328 changes.\n+  int r[] = {1, 2, 3};\n+  auto v = r\n+    | views::transform([] (int n) { return std::vector{{n, -n}}; })\n+    | views::join;\n+  VERIFY( ranges::equal(v, (int[]){1, -1, 2, -2, 3, -3}) );\n+\n+  struct S {\n+    S() = default;\n+    S(const S&) = delete;\n+    S(S&&) = delete;\n+  };\n+  auto w = r\n+    | views::transform([] (int) { return std::array<S, 2>{}; })\n+    | views::join;\n+  for (auto& i : w)\n+    ;\n+}\n+\n int\n main()\n {\n@@ -183,4 +206,5 @@ main()\n   test08();\n   test09();\n   test10();\n+  test11();\n }"}]}