{"sha": "cad7e87b1191e2b96f22ca5b12cddc528e364340", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FkN2U4N2IxMTkxZTJiOTZmMjJjYTViMTJjZGRjNTI4ZTM2NDM0MA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-07-12T16:06:40Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-07-12T16:06:40Z"}, "message": "call.c (build_user_type_conversion_1, [...]): Pass type directly to lookup_fnfields & build_special_member_call.\n\n\t* call.c (build_user_type_conversion_1, build_new_op,\n\tcheck_constructor_callable, build_temp,\n\tperform_direct_initialization_of_possible): Pass type directly to\n\tlookup_fnfields & build_special_member_call.\n\t(build_special_member_call): Accept a type, and complete it.\n\t* class.c (finish_stuct_bits): Copy the BINFOs here.\n\t* cvt.c (ocp_convert): Pass type directly to\n\tbuild_special_member_call.\n\t* decl.c (build_ptrmemfunc_type): Call xref_bastypes here.\n\t(xref_basetypes): Allocate the binfo here. Adjust.\n\t* init.c (build_init, build_new_1): Pass type directly to\n\tbuild_special_member_call.\n\t* lex.c (cxx_make_type): Do not allocate binfo here.\n\t* name-lookup.c (arg_assoc_class): Incomplete types have no binfo.\n\t* parser.c (cp_parser_class_head): Always call xref_basetypes.\n\t* pt.c (instantiate_class_template): Likewise. Inhibit access\n\tchecking for template friends.\n\t* ptree.c (cxx_print_type): Adjust record printing.\n\t* search.c (lookup_base): When taking a type, complete it before\n\tlooking for a binfo.\n\t(lookup_member): Delay completing a type.\n\t(push_class_decls): Don't walk an incomplete type.\n\t(lookup_conversions): Likewise.\n\t* semantics.c (finish_stmt_expr_expr): Pass type directly to\n\tbuild_special_member_call.\n\t* tree.c (copy_base_binfos): Adjust.\n\t(make_binfo): Likewise.\n\t* typeck.c (build_modify_expr): Pass type directly to\n\tbuild_special_member_call.\n\t* typeck2.c (process_init_constructor): Check a binfo exists.\n\t(build_m_component_ref): Allow accessing an incomplete type.\n\t(build_functional_cast): Pass type directly to\n\tbuild_special_member_call.\n\nFrom-SVN: r84562", "tree": {"sha": "bb13256ed44abc12331324fbb0e1e57406cd13df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb13256ed44abc12331324fbb0e1e57406cd13df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cad7e87b1191e2b96f22ca5b12cddc528e364340", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cad7e87b1191e2b96f22ca5b12cddc528e364340", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cad7e87b1191e2b96f22ca5b12cddc528e364340", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cad7e87b1191e2b96f22ca5b12cddc528e364340/comments", "author": null, "committer": null, "parents": [{"sha": "255cd731f40dd7b5855e0bc12a9cdd6383e65321", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/255cd731f40dd7b5855e0bc12a9cdd6383e65321", "html_url": "https://github.com/Rust-GCC/gccrs/commit/255cd731f40dd7b5855e0bc12a9cdd6383e65321"}], "stats": {"total": 277, "additions": 186, "deletions": 91}, "files": [{"sha": "392a7321c5205cef21bccae731d39905201750d1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cad7e87b1191e2b96f22ca5b12cddc528e364340", "patch": "@@ -1,3 +1,39 @@\n+2004-07-12  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* call.c (build_user_type_conversion_1, build_new_op,\n+\tcheck_constructor_callable, build_temp,\n+\tperform_direct_initialization_of_possible): Pass type directly to\n+\tlookup_fnfields & build_special_member_call.\n+\t(build_special_member_call): Accept a type, and complete it.\n+\t* class.c (finish_stuct_bits): Copy the BINFOs here.\n+\t* cvt.c (ocp_convert): Pass type directly to\n+\tbuild_special_member_call.\n+\t* decl.c (build_ptrmemfunc_type): Call xref_bastypes here.\n+\t(xref_basetypes): Allocate the binfo here. Adjust.\n+\t* init.c (build_init, build_new_1): Pass type directly to\n+\tbuild_special_member_call.\n+\t* lex.c (cxx_make_type): Do not allocate binfo here.\n+\t* name-lookup.c (arg_assoc_class): Incomplete types have no binfo.\n+\t* parser.c (cp_parser_class_head): Always call xref_basetypes.\n+\t* pt.c (instantiate_class_template): Likewise. Inhibit access\n+\tchecking for template friends.\n+\t* ptree.c (cxx_print_type): Adjust record printing.\n+\t* search.c (lookup_base): When taking a type, complete it before\n+\tlooking for a binfo.\n+\t(lookup_member): Delay completing a type.\n+\t(push_class_decls): Don't walk an incomplete type.\n+\t(lookup_conversions): Likewise.\n+\t* semantics.c (finish_stmt_expr_expr): Pass type directly to\n+\tbuild_special_member_call.\n+\t* tree.c (copy_base_binfos): Adjust.\n+\t(make_binfo): Likewise.\n+\t* typeck.c (build_modify_expr): Pass type directly to\n+\tbuild_special_member_call.\n+\t* typeck2.c (process_init_constructor): Check a binfo exists.\n+\t(build_m_component_ref): Allow accessing an incomplete type.\n+\t(build_functional_cast): Pass type directly to\n+\tbuild_special_member_call.\n+\n 2004-07-12  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \tPR c++/2204"}, {"sha": "d2a17d9a7ed4ea7318e9e2925f64c5ee18894554", "filename": "gcc/cp/call.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=cad7e87b1191e2b96f22ca5b12cddc528e364340", "patch": "@@ -2500,9 +2500,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \t\t      || !DERIVED_FROM_P (totype, fromtype), 20011226);\n \n   if (IS_AGGR_TYPE (totype))\n-    ctors = lookup_fnfields (TYPE_BINFO (totype),\n-\t\t\t     complete_ctor_identifier,\n-\t\t\t     0);\n+    ctors = lookup_fnfields (totype, complete_ctor_identifier, 0);\n \n   if (IS_AGGR_TYPE (fromtype))\n     conv_fns = lookup_conversions (fromtype);\n@@ -3650,7 +3648,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n     {\n       tree fns;\n \n-      fns = lookup_fnfields (TYPE_BINFO (TREE_TYPE (arg1)), fnname, 1);\n+      fns = lookup_fnfields (TREE_TYPE (arg1), fnname, 1);\n       if (fns == error_mark_node)\n \t{\n \t  result = error_mark_node;\n@@ -4092,7 +4090,7 @@ check_constructor_callable (tree type, tree expr)\n   build_special_member_call (NULL_TREE,\n \t\t\t     complete_ctor_identifier,\n \t\t\t     build_tree_list (NULL_TREE, expr), \n-\t\t\t     TYPE_BINFO (type),\n+\t\t\t     type,\n \t\t\t     LOOKUP_NORMAL | LOOKUP_ONLYCONVERTING\n \t\t\t     | LOOKUP_CONSTRUCTOR_CALLABLE);\n }\n@@ -4113,8 +4111,7 @@ build_temp (tree expr, tree type, int flags,\n   expr = build_special_member_call (NULL_TREE,\n \t\t\t\t    complete_ctor_identifier,\n \t\t\t\t    build_tree_list (NULL_TREE, expr), \n-\t\t\t\t    TYPE_BINFO (type),\n-\t\t\t\t    flags);\n+\t\t\t\t    type, flags);\n   if (warningcount > savew)\n     *diagnostic_fn = warning;\n   else if (errorcount > savee)\n@@ -5014,6 +5011,15 @@ build_special_member_call (tree instance, tree name, tree args,\n \t\t      || name == deleting_dtor_identifier\n \t\t      || name == ansi_assopname (NOP_EXPR),\n \t\t      20020712);\n+  if (TYPE_P (binfo))\n+    {\n+      /* Resolve the name.  */\n+      if (!complete_type_or_else (binfo, NULL_TREE))\n+\treturn error_mark_node;\n+\n+      binfo = TYPE_BINFO (binfo);\n+    }\n+  \n   my_friendly_assert (binfo != NULL_TREE, 20020712);\n \n   class_type = BINFO_TYPE (binfo);\n@@ -5053,10 +5059,6 @@ build_special_member_call (tree instance, tree name, tree args,\n   \n   my_friendly_assert (instance != NULL_TREE, 20020712);\n \n-  /* Resolve the name.  */\n-  if (!complete_type_or_else (BINFO_TYPE (binfo), NULL_TREE))\n-    return error_mark_node;\n-\n   fns = lookup_fnfields (binfo, name, 1);\n     \n   /* When making a call to a constructor or destructor for a subobject\n@@ -6302,8 +6304,7 @@ perform_direct_initialization_if_possible (tree type, tree expr)\n     {\n       expr = build_special_member_call (NULL_TREE, complete_ctor_identifier,\n \t\t\t\t\tbuild_tree_list (NULL_TREE, expr),\n-\t\t\t\t\tTYPE_BINFO (type),\n-\t\t\t\t\tLOOKUP_NORMAL);\n+\t\t\t\t\ttype, LOOKUP_NORMAL);\n       return build_cplus_new (type, expr);\n     }\n "}, {"sha": "2e5b89b5b0b232cfdfaa1cdb9e5ca32aeed058bb", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=cad7e87b1191e2b96f22ca5b12cddc528e364340", "patch": "@@ -1501,12 +1501,16 @@ finish_struct_bits (tree t)\n \t= TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (t);\n       TYPE_POLYMORPHIC_P (variants) = TYPE_POLYMORPHIC_P (t);\n       TYPE_USES_VIRTUAL_BASECLASSES (variants) = TYPE_USES_VIRTUAL_BASECLASSES (t);\n+      \n+      TYPE_BINFO (variants) = TYPE_BINFO (t);\n+\n       /* Copy whatever these are holding today.  */\n       TYPE_VFIELD (variants) = TYPE_VFIELD (t);\n       TYPE_METHODS (variants) = TYPE_METHODS (t);\n       TYPE_FIELDS (variants) = TYPE_FIELDS (t);\n       TYPE_SIZE (variants) = TYPE_SIZE (t);\n       TYPE_SIZE_UNIT (variants) = TYPE_SIZE_UNIT (t);\n+      \n       variants = TYPE_NEXT_VARIANT (variants);\n     }\n "}, {"sha": "34a21ec5ebb971bef48a099304ef41c907cce2ab", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=cad7e87b1191e2b96f22ca5b12cddc528e364340", "patch": "@@ -748,7 +748,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \tctor = build_special_member_call (NULL_TREE, \n \t\t\t\t\t  complete_ctor_identifier,\n \t\t\t\t\t  build_tree_list (NULL_TREE, ctor),\n-\t\t\t\t\t  TYPE_BINFO (type), flags);\n+\t\t\t\t\t  type, flags);\n       if (ctor)\n \treturn build_cplus_new (type, ctor);\n     }"}, {"sha": "39b0a17c28bc5b9553ef96ea1d165c48be075d7c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cad7e87b1191e2b96f22ca5b12cddc528e364340", "patch": "@@ -5852,6 +5852,8 @@ build_ptrmemfunc_type (tree type)\n       = build_ptrmemfunc_type (TYPE_MAIN_VARIANT (type));\n \n   t = make_aggr_type (RECORD_TYPE);\n+  xref_basetypes (t, NULL_TREE);\n+  \n   /* Let the front-end know this is a pointer to member function...  */\n   TYPE_PTRMEMFUNC_FLAG (t) = 1;\n   /* ... and not really an aggregate.  */\n@@ -9037,13 +9039,8 @@ xref_basetypes (tree ref, tree base_list)\n   if (ref == error_mark_node)\n     return;\n \n-  if (TREE_CODE (ref) == UNION_TYPE)\n-    {\n-      error (\"derived union `%T' invalid\", ref);\n-      return;\n-    }\n-\n-  tag_code = (CLASSTYPE_DECLARED_CLASS (ref) ? class_type : record_type);\n+  tag_code = TREE_CODE (ref) == UNION_TYPE ? union_type\n+    : (CLASSTYPE_DECLARED_CLASS (ref) ? class_type : record_type);\n \n   /* First, make sure that any templates in base-classes are\n      instantiated.  This ensures that if we call ourselves recursively\n@@ -9053,6 +9050,7 @@ xref_basetypes (tree ref, tree base_list)\n   while (*basep) \n     {\n       tree basetype = TREE_VALUE (*basep);\n+      \n       if (!(processing_template_decl && uses_template_parms (basetype))\n \t  && !complete_type_or_else (basetype, NULL))\n \t/* An incomplete type.  Remove it from the list.  */\n@@ -9063,6 +9061,11 @@ xref_basetypes (tree ref, tree base_list)\n \n   SET_CLASSTYPE_MARKED (ref);\n   i = list_length (base_list);\n+  /* The binfo slot should be empty, unless this is an (ill-formed)\n+     redefinition.  */\n+  my_friendly_assert (!TYPE_BINFO (ref) || TYPE_SIZE (ref), 20040706);\n+  TYPE_BINFO (ref) = make_binfo (size_zero_node, ref, NULL_TREE, NULL_TREE);\n+  \n   if (i)\n     {\n       tree binfo = TYPE_BINFO (ref);\n@@ -9115,14 +9118,22 @@ xref_basetypes (tree ref, tree base_list)\n \t  if (CLASS_TYPE_P (basetype))\n \t    {\n \t      base_binfo = TYPE_BINFO (basetype);\n-\t      /* This flag will be in the binfo of the base type, we must\n-\t     \t clear it after copying the base binfos.  */\n-\t      BINFO_DEPENDENT_BASE_P (base_binfo)\n-\t\t= dependent_type_p (basetype);\n+\n+\t      if (dependent_type_p (basetype))\n+\t\t{\n+\t\t  base_binfo = make_binfo (size_zero_node, basetype,\n+\t\t\t\t\t   NULL_TREE, NULL_TREE);\n+\t\t  BINFO_DEPENDENT_BASE_P (base_binfo) = 1;\n+\t\t}\n+\t      else\n+\t\tmy_friendly_assert (base_binfo, 20040706);\n \t    }\n \t  else\n-\t    base_binfo = make_binfo (size_zero_node, basetype,\n-\t\t\t\t     NULL_TREE, NULL_TREE);\n+\t    {\n+\t      base_binfo = make_binfo (size_zero_node, basetype,\n+\t\t\t\t       NULL_TREE, NULL_TREE);\n+\t      BINFO_DEPENDENT_BASE_P (base_binfo) = 1;\n+\t    }\n \t  \n \t  TREE_VEC_ELT (binfos, i) = base_binfo;\n \t  TREE_VEC_ELT (accesses, i) = access;\n@@ -9182,6 +9193,12 @@ xref_basetypes (tree ref, tree base_list)\n      inheritance order chain.  */\n   copy_base_binfos (TYPE_BINFO (ref), ref, NULL_TREE);\n \n+  if (TREE_CODE (ref) == UNION_TYPE)\n+    {\n+      if (i)\n+\terror (\"derived union `%T' invalid\", ref);\n+    }\n+\n   if (TYPE_FOR_JAVA (ref))\n     {\n       if (TYPE_USES_MULTIPLE_INHERITANCE (ref))\n@@ -9193,14 +9210,12 @@ xref_basetypes (tree ref, tree base_list)\n   /* Unmark all the types.  */\n   while (i--)\n     {\n-      tree basetype = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (ref), i));\n+      tree binfo = BINFO_BASE_BINFO (TYPE_BINFO (ref), i);\n+      tree basetype = BINFO_TYPE (binfo);\n       \n       CLEAR_CLASSTYPE_MARKED (basetype);\n-      if (CLASS_TYPE_P (basetype))\n-\t{\n-\t  BINFO_VIRTUAL_P (TYPE_BINFO (basetype)) = 0;\n-\t  BINFO_DEPENDENT_BASE_P (TYPE_BINFO (basetype)) = 0;\n-\t}\n+      if (!BINFO_DEPENDENT_BASE_P (binfo))\n+\tBINFO_VIRTUAL_P (TYPE_BINFO (basetype)) = 0;\n     }\n   CLEAR_CLASSTYPE_MARKED (ref);\n }"}, {"sha": "9b2a8f56c305e58ba94b36eeea3813ea00e4cc2e", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=cad7e87b1191e2b96f22ca5b12cddc528e364340", "patch": "@@ -1145,7 +1145,7 @@ build_init (tree decl, tree init, int flags)\n   else if (CLASS_TYPE_P (TREE_TYPE (decl)))\n     expr = build_special_member_call (decl, complete_ctor_identifier,\n \t\t\t\t      build_tree_list (NULL_TREE, init),\n-\t\t\t\t      TYPE_BINFO (TREE_TYPE (decl)),\n+\t\t\t\t      TREE_TYPE (decl),\n \t\t\t\t      LOOKUP_NORMAL|flags);\n   else\n     expr = build (INIT_EXPR, TREE_TYPE (decl), decl, init);\n@@ -2088,7 +2088,7 @@ build_new_1 (tree exp)\n \t{\n \t  init_expr = build_special_member_call (init_expr, \n \t\t\t\t\t\t complete_ctor_identifier,\n-\t\t\t\t\t\t init, TYPE_BINFO (true_type),\n+\t\t\t\t\t\t init, true_type,\n \t\t\t\t\t\t LOOKUP_NORMAL);\n \t  stable = stabilize_init (init_expr, &init_preeval_expr);\n \t}"}, {"sha": "4b3ba7ac93f6f38b5e397f09e2f4a4b0b252b916", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=cad7e87b1191e2b96f22ca5b12cddc528e364340", "patch": "@@ -782,8 +782,6 @@ cxx_make_type (enum tree_code code)\n \t presence of parse errors, the normal was of assuring this\n \t might not ever get executed, so we lay it out *immediately*.  */\n       build_pointer_type (t);\n-\n-      TYPE_BINFO (t) = make_binfo (size_zero_node, t, NULL_TREE, NULL_TREE);\n     }\n   else\n     /* We use TYPE_ALIAS_SET for the CLASSTYPE_MARKED bits.  But,"}, {"sha": "08ee8751c7d0c447ad9cad8e92055a5e4bf3228c", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=cad7e87b1191e2b96f22ca5b12cddc528e364340", "patch": "@@ -12494,6 +12494,7 @@ cp_parser_class_head (cp_parser* parser,\n   bool invalid_explicit_specialization_p = false;\n   bool pop_p = false;\n   unsigned num_templates;\n+  tree bases;\n \n   /* Assume no nested-name-specifier will be present.  */\n   *nested_name_specifier_p = false;\n@@ -12770,17 +12771,16 @@ cp_parser_class_head (cp_parser* parser,\n      is valid.  */\n   if (nested_name_specifier)\n     pop_p = push_scope (nested_name_specifier);\n-  /* Now, look for the base-clause.  */\n-  token = cp_lexer_peek_token (parser->lexer);\n-  if (token->type == CPP_COLON)\n-    {\n-      tree bases;\n+  \n+  bases = NULL_TREE;\n+  \n+  /* Get the list of base-classes, if there is one.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n+    bases = cp_parser_base_clause (parser);\n+  \n+  /* Process the base classes.  */\n+  xref_basetypes (type, bases);\n \n-      /* Get the list of base-classes.  */\n-      bases = cp_parser_base_clause (parser);\n-      /* Process them.  */\n-      xref_basetypes (type, bases);\n-    }\n   /* Leave the scope given by the nested-name-specifier.  We will\n      enter the class scope itself while processing the members.  */\n   if (pop_p)"}, {"sha": "3d46883aee83b0a15efeb23d36ebbd4ad75ce49b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cad7e87b1191e2b96f22ca5b12cddc528e364340", "patch": "@@ -5286,6 +5286,7 @@ instantiate_class_template (tree type)\n   tree template, args, pattern, t, member;\n   tree typedecl;\n   tree pbinfo;\n+  tree base_list;\n   \n   if (type == error_mark_node)\n     return error_mark_node;\n@@ -5419,9 +5420,9 @@ instantiate_class_template (tree type)\n     abort ();\n #endif\n \n+  base_list = NULL_TREE;\n   if (BINFO_BASE_BINFOS (pbinfo))\n     {\n-      tree base_list = NULL_TREE;\n       tree pbases = BINFO_BASE_BINFOS (pbinfo);\n       tree paccesses = BINFO_BASE_ACCESSES (pbinfo);\n       tree context = TYPE_CONTEXT (type);\n@@ -5457,13 +5458,13 @@ instantiate_class_template (tree type)\n       /* The list is now in reverse order; correct that.  */\n       base_list = nreverse (base_list);\n \n-      /* Now call xref_basetypes to set up all the base-class\n-\t information.  */\n-      xref_basetypes (type, base_list);\n-\n       if (pop_p)\n \tpop_scope (context ? context : global_namespace);\n     }\n+  /* Now call xref_basetypes to set up all the base-class\n+     information.  */\n+  xref_basetypes (type, base_list);\n+\n \n   /* Now that our base classes are set up, enter the scope of the\n      class, so that name lookups into base classes, etc. will work\n@@ -5647,11 +5648,18 @@ instantiate_class_template (tree type)\n \t      tree r;\n \n \t      if (TREE_CODE (t) == TEMPLATE_DECL)\n-\t\t++processing_template_decl;\n+\t\t{\n+\t\t  ++processing_template_decl;\n+\t\t  push_deferring_access_checks (dk_no_check);\n+\t\t}\n+\t      \n \t      r = tsubst_friend_function (t, args);\n-\t      if (TREE_CODE (t) == TEMPLATE_DECL)\n-\t\t--processing_template_decl;\n \t      add_friend (type, r, /*complain=*/false);\n+\t      if (TREE_CODE (t) == TEMPLATE_DECL)\n+\t\t{\n+\t\t  pop_deferring_access_checks ();\n+\t\t  --processing_template_decl;\n+\t\t}\n \t    }\n \t}\n     }"}, {"sha": "ba5533a36dda5664faccafaa079d3b417883d584", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=cad7e87b1191e2b96f22ca5b12cddc528e364340", "patch": "@@ -128,7 +128,12 @@ cxx_print_type (FILE *file, tree node, int indent)\n \n   if (TREE_CODE (node) == RECORD_TYPE)\n     {\n-      fprintf (file, \" n_parents %d\", BINFO_N_BASE_BINFOS (TYPE_BINFO (node)));\n+      if (TYPE_BINFO (node))\n+\tfprintf (file, \" n_parents=%d\",\n+\t\t BINFO_N_BASE_BINFOS (TYPE_BINFO (node)));\n+      else\n+\tfprintf (file, \" no-binfo\");\n+      \n       fprintf (file, \" use_template=%d\", CLASSTYPE_USE_TEMPLATE (node));\n       if (CLASSTYPE_INTERFACE_ONLY (node))\n \tfprintf (file, \" interface-only\");"}, {"sha": "dbc3e40340ec78393d3a22133fdc0e7414088f2a", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=cad7e87b1191e2b96f22ca5b12cddc528e364340", "patch": "@@ -20,7 +20,6 @@ along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\""}, {"sha": "83925b8d2fdb904653712269773f9b8cbb746a17", "filename": "gcc/cp/search.c", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=cad7e87b1191e2b96f22ca5b12cddc528e364340", "patch": "@@ -270,8 +270,8 @@ accessible_base_p (tree t, tree base)\n tree\n lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n {\n-  tree binfo = NULL;\t\t/* The binfo we've found so far.  */\n-  tree t_binfo = NULL;\n+  tree binfo = NULL_TREE;\t/* The binfo we've found so far.  */\n+  tree t_binfo = NULL_TREE;\n   base_kind bk;\n   \n   if (t == error_mark_node || base == error_mark_node)\n@@ -287,14 +287,18 @@ lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n       t_binfo = t;\n       t = BINFO_TYPE (t);\n     }\n-  else \n-    t_binfo = TYPE_BINFO (t);\n-\n-  /* Ensure that the types are instantiated.  */\n-  t = complete_type (TYPE_MAIN_VARIANT (t));\n-  base = complete_type (TYPE_MAIN_VARIANT (base));\n+  else  \n+    {\n+      t = complete_type (TYPE_MAIN_VARIANT (t));\n+      t_binfo = TYPE_BINFO (t);\n+    }\n   \n-  bk = lookup_base_r (t_binfo, base, access, 0, &binfo);\n+  base = complete_type (TYPE_MAIN_VARIANT (base));\n+\n+  if (t_binfo)\n+    bk = lookup_base_r (t_binfo, base, access, 0, &binfo);\n+  else\n+    bk = bk_not_base;\n \n   /* Check that the base is unambiguous and accessible.  */\n   if (access != ba_any)\n@@ -1256,8 +1260,7 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type)\n     {\n       my_friendly_assert (IS_AGGR_TYPE_CODE (TREE_CODE (xbasetype)), 20030624);\n       type = xbasetype;\n-      basetype_path = TYPE_BINFO (type);\n-      my_friendly_assert (!BINFO_INHERITANCE_CHAIN (basetype_path), 980827);\n+      xbasetype = NULL_TREE;\n     }\n \n   if (type == current_class_type && TYPE_BEING_DEFINED (type)\n@@ -1271,7 +1274,12 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type)\n \treturn field;\n     }\n \n-  complete_type (type);\n+  type = complete_type (type);\n+  if (!basetype_path)\n+    basetype_path = TYPE_BINFO (type);\n+\n+  if (!basetype_path)\n+    return NULL_TREE;\n \n #ifdef GATHER_STATISTICS\n   n_calls_lookup_field++;\n@@ -2239,6 +2247,11 @@ push_class_decls (tree type)\n {\n   search_stack = push_search_level (search_stack, &search_obstack);\n \n+  if (!TYPE_BINFO (type))\n+    /* This occurs when parsing an invalid declarator id where the\n+       scope is incomplete.  */\n+    return;\n+  \n   /* Enter type declarations and mark.  */\n   dfs_walk (TYPE_BINFO (type), dfs_push_type_decls, unmarked_pushdecls_p, 0);\n \n@@ -2351,7 +2364,8 @@ lookup_conversions (tree type)\n   tree conversions = NULL_TREE;\n \n   complete_type (type);\n-  bfs_walk (TYPE_BINFO (type), add_conversions, 0, &conversions);\n+  if (TYPE_BINFO (type))\n+    bfs_walk (TYPE_BINFO (type), add_conversions, 0, &conversions);\n \n   for (t = conversions; t; t = TREE_CHAIN (t))\n     IDENTIFIER_MARKED (DECL_NAME (OVL_CURRENT (TREE_VALUE (t)))) = 0;"}, {"sha": "929a0e632a1a8ea9ad39df2cdf9ada3e1f5c7e22", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=cad7e87b1191e2b96f22ca5b12cddc528e364340", "patch": "@@ -1490,7 +1490,7 @@ finish_stmt_expr_expr (tree expr, tree stmt_expr)\n \t      expr = build_special_member_call\n \t\t(NULL_TREE, complete_ctor_identifier,\n \t\t build_tree_list (NULL_TREE, expr),\n-\t\t TYPE_BINFO (type), LOOKUP_NORMAL);\n+\t\t type, LOOKUP_NORMAL);\n \t      expr = build_cplus_new (type, expr);\n \t      my_friendly_assert (TREE_CODE (expr) == TARGET_EXPR, 20030729);\n \t    }"}, {"sha": "b463fc1bea509e1cfede832723fba5f70d0260f8", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=cad7e87b1191e2b96f22ca5b12cddc528e364340", "patch": "@@ -602,7 +602,7 @@ copy_base_binfos (tree binfo, tree t, tree prev)\n       tree base_binfo = TREE_VEC_ELT (binfos, ix);\n       tree new_binfo = NULL_TREE;\n \n-      if (!CLASS_TYPE_P (BINFO_TYPE (base_binfo)))\n+      if (BINFO_DEPENDENT_BASE_P (base_binfo))\n \t{\n \t  my_friendly_assert (binfo == TYPE_BINFO (t), 20030204);\n \t  \n@@ -777,22 +777,20 @@ make_binfo (tree offset, tree binfo, tree vtable, tree virtuals)\n   if (TREE_CODE (binfo) == TREE_BINFO)\n     {\n       type = BINFO_TYPE (binfo);\n-      BINFO_DEPENDENT_BASE_P (new_binfo) = BINFO_DEPENDENT_BASE_P (binfo);\n+      my_friendly_assert (!BINFO_DEPENDENT_BASE_P (binfo), 20040706);\n     }\n   else\n     {\n       type = binfo;\n       binfo = NULL_TREE;\n-      BINFO_DEPENDENT_BASE_P (new_binfo) = 1;\n     }\n \n   TREE_TYPE (new_binfo) = TYPE_MAIN_VARIANT (type);\n   BINFO_OFFSET (new_binfo) = offset;\n   BINFO_VTABLE (new_binfo) = vtable;\n   BINFO_VIRTUALS (new_binfo) = virtuals;\n \n-  if (binfo && !BINFO_DEPENDENT_BASE_P (binfo)\n-      && BINFO_BASE_BINFOS (binfo) != NULL_TREE)\n+  if (binfo && BINFO_BASE_BINFOS (binfo))\n     {\n       BINFO_BASE_BINFOS (new_binfo) = copy_node (BINFO_BASE_BINFOS (binfo));\n       /* We do not need to copy the accesses, as they are read only.  */"}, {"sha": "651067adb9bb886ccd2c2bf3a094e0a2fd51c1d9", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=cad7e87b1191e2b96f22ca5b12cddc528e364340", "patch": "@@ -5071,8 +5071,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t{\n \t  result = build_special_member_call (lhs, complete_ctor_identifier,\n \t\t\t\t\t      build_tree_list (NULL_TREE, rhs),\n-\t\t\t\t\t      TYPE_BINFO (lhstype), \n-\t\t\t\t\t      LOOKUP_NORMAL);\n+\t\t\t\t\t      lhstype, LOOKUP_NORMAL);\n \t  if (result == NULL_TREE)\n \t    return error_mark_node;\n \t  return result;"}, {"sha": "21bca0025dd84d6a890a19a8419bc60773723f30", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad7e87b1191e2b96f22ca5b12cddc528e364340/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=cad7e87b1191e2b96f22ca5b12cddc528e364340", "patch": "@@ -954,7 +954,7 @@ process_init_constructor (tree type, tree init, tree* elts)\n \t      return error_mark_node;\n \t    }\n \n-\t  if (BINFO_BASE_BINFOS (TYPE_BINFO (type)))\n+\t  if (TYPE_BINFO (type) && BINFO_BASE_BINFOS (TYPE_BINFO (type)))\n \t    {\n \t      sorry (\"initializer list for object of class with base classes\");\n \t      return error_mark_node;\n@@ -1304,6 +1304,7 @@ build_m_component_ref (tree datum, tree component)\n   tree objtype;\n   tree type;\n   tree binfo;\n+  tree ctype;\n \n   datum = decay_conversion (datum);\n \n@@ -1327,16 +1328,28 @@ build_m_component_ref (tree datum, tree component)\n     }\n \n   type = TYPE_PTRMEM_POINTED_TO_TYPE (ptrmem_type);\n-  binfo = lookup_base (objtype, TYPE_PTRMEM_CLASS_TYPE (ptrmem_type),\n-\t\t       ba_check, NULL);\n-  if (!binfo)\n+  ctype = complete_type (TYPE_PTRMEM_CLASS_TYPE (ptrmem_type));\n+\n+  if (!COMPLETE_TYPE_P (ctype))\n     {\n-      error (\"member type `%T::' incompatible with object type `%T'\",\n-\t     type, objtype);\n-      return error_mark_node;\n+      if (!same_type_p (ctype, objtype))\n+\tgoto mismatch;\n+      binfo = NULL;\n+    }\n+  else\n+    {\n+      binfo = lookup_base (objtype, ctype, ba_check, NULL);\n+      \n+      if (!binfo)\n+\t{\n+\tmismatch:\n+\t  error (\"pointer to member type `%T' incompatible with object type `%T'\",\n+\t\t type, objtype);\n+\t  return error_mark_node;\n+\t}\n+      else if (binfo == error_mark_node)\n+\treturn error_mark_node;\n     }\n-  else if (binfo == error_mark_node)\n-    return error_mark_node;\n \n   if (TYPE_PTRMEM_P (ptrmem_type))\n     {\n@@ -1347,12 +1360,17 @@ build_m_component_ref (tree datum, tree component)\n       type = cp_build_qualified_type (type,\n \t\t\t\t      (cp_type_quals (type)  \n \t\t\t\t       | cp_type_quals (TREE_TYPE (datum))));\n+\n+      datum = build_address (datum);\n+      \n+      /* Convert object to the correct base.  */\n+      if (binfo)\n+\tdatum = build_base_path (PLUS_EXPR, datum, binfo, 1);\n+      \n       /* Build an expression for \"object + offset\" where offset is the\n \t value stored in the pointer-to-data-member.  */\n       datum = build (PLUS_EXPR, build_pointer_type (type),\n-\t\t     build_base_path (PLUS_EXPR, build_address (datum), \n-\t\t\t\t      binfo, 1),\n-\t\t     build_nop (ptrdiff_type_node, component));\n+\t\t     datum, build_nop (ptrdiff_type_node, component));\n       return build_indirect_ref (datum, 0);\n     }\n   else\n@@ -1420,7 +1438,7 @@ build_functional_cast (tree exp, tree parms)\n     }\n \n   exp = build_special_member_call (NULL_TREE, complete_ctor_identifier, parms,\n-\t\t\t\t   TYPE_BINFO (type), LOOKUP_NORMAL);\n+\t\t\t\t   type, LOOKUP_NORMAL);\n \n   if (exp == error_mark_node)\n     return error_mark_node;"}]}