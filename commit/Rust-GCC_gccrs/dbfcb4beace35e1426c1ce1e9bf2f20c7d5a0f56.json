{"sha": "dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJmY2I0YmVhY2UzNWUxNDI2YzFjZTFlOWJmMmYyMGM3ZDVhMGY1Ng==", "commit": {"author": {"name": "Brendan Kehoe", "email": "brendan@gcc.gnu.org", "date": "1997-09-06T07:44:38Z"}, "committer": {"name": "Brendan Kehoe", "email": "brendan@gcc.gnu.org", "date": "1997-09-06T07:44:38Z"}, "message": "Insert libio rewrite and its various changes from devo.\n\nFrom-SVN: r15129", "tree": {"sha": "82e1a9aef1a37d3e21b8f1d0fe3a9435ad5a2f53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82e1a9aef1a37d3e21b8f1d0fe3a9435ad5a2f53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/comments", "author": null, "committer": null, "parents": [{"sha": "1496c1bb0be5c2981f056fa169cf1c199f50a38a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1496c1bb0be5c2981f056fa169cf1c199f50a38a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1496c1bb0be5c2981f056fa169cf1c199f50a38a"}], "stats": {"total": 4850, "additions": 3323, "deletions": 1527}, "files": [{"sha": "bc9267442d21964e4a75bcb32aab74be3bdf5a27", "filename": "libio/ChangeLog", "status": "modified", "additions": 175, "deletions": 2, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2FChangeLog?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,7 +1,180 @@\n+Fri Sep  5 09:58:43 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* Makefile.in (iostream.list): Instead of adding stdio.list, add\n+\tSTDIO_WRAP_OBJECTS.\n+\t(iostream.list): Lose dependency on stmp-stdio, not necessary for\n+\tour stuff.  The stdio stuff is present here just for uniformity\n+\twith glibc.\n+\n+Thu Sep  4 17:26:22 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* parsestream.cc (general_parsebuf): Cast return of malloc to char*.\n+\n+1997-09-04 16:11  Ulrich Drepper  <drepper@cygnus.com>\n+\n+\tChange compared to version initially intended to in:\n+\t* strops.c (_IO_str_count): Still use _IO_write_ptr, not\n+\t_IO_write_end, for now.\n+\n+\t* iofeof.c, ioferror.c, iofflush_u.c, iogetc.c, ioputc.c, peekc.c,\n+\tstdio-lock.h: New files.\n+\n+\t* include: New dir.\n+\t* include/empty.h: New header.\n+\n+\t* filedoalloc.c: Update and reformat copyright.\n+\tDon't use DEFUN.\n+\tUse __set_errno throughout the code to support multi-threaded\n+\tprograms.\n+\tCorrect layout to follow the Coding Standard.\n+\tAdd casts to prevent warnings.\n+\t* fileops.c: Likewise.\n+\t* genops.c: Likewise.\n+\t* iofclose.c: Likewise.\n+\t* iofdopen.c: Likewise.\n+\t* iofflush.c: Likewise.\n+\t* iofgetpos.c: Likewise.\n+\t* iofgets.c: Likewise.\n+\t* iofopen.c: Likewise.\n+\t* iofprintf.c: Likewise.\n+\t* iofputs.c: Likewise.\n+\t* iofread.c: Likewise.\n+\t* iofsetpos.c: Likewise.\n+\t* ioftell.c: Likewise.\n+\t* iofwrite.c: Likewise.\n+\t* iogetdelim.c: Likewise.\n+\t* iogetline.c: Likewise.\n+\t* iogets.c: Likewise.\n+\t* iopadn.c: Likewise.\n+\t* iopopen.c: Likewise.\n+\t* ioputs.c: Likewise.\n+\t* ioseekoff.c: Likewise.\n+\t* iosetbuffer.c: Likewise.\n+\t* iosetvbuf.c: Likewise.\n+\t* iosprintf.c: Likewise.\n+\t* ioungetc.c: Likewise.\n+\t* iovsprintf.c: Likewise.\n+\t* iovsscanf.c: Likewise.\n+\t* libio.h: Likewise.\n+\t* libioP.h: Likewise.\n+\t* stdfiles.c: Likewise.\n+\t* strfile.h: Likewise.\n+\t* strops.c: Likewise.\n+\n+\t* Makefile.in (IO_OBJECTS): Add peekc.o, iogetc.o, ioputc.o,\n+\tiofeof.o, and ioferror.o.\n+\t(iostream.list): Depend upon stmp-stdio.  Add the entries\n+\tfrom stdio.list to iostream.list.\n+\t(stmp-stdio): New name for what was the stdio/stdio.list rule.\n+\tAll it now does is cd down into stdio and build stdio.list.\n+\n+\t* configure.in (ALL): Add libiostream.a.\n+\n+\t* libio.h [_IO_MTSFE_IO]: Include header declaring locking code.\n+\tOtherwise define opaque _IO_lock_t.\n+\tDefine _IO_cookie_file.\n+\tRename _IO_getc to _IO_getc_unlocked, _IO_peekc to _IO_peekc_unlocked,\n+\t_IO_putc to _IO_putc_unlocked, _IO_feof to _IO_feof_unclocked, and\n+\t_IO_ferror to _IO_ferror_unlocked.\n+\tAdd prototypes for _IO_getc, _IO_putc, _IO_feof, _IO_ferror,\n+\tand _IO_peekc_locked.\n+\tAdd declarations for _IO_flockfile, _IO_funlockfile, and\n+\t_IO_ftrylockfile.  If !_IO_MTSAFE_IO define _IO_flockfile,\n+\t_IO_funlockfile, _IO_ftrylockfile, _IO_cleanup_region_start, and\n+\t_IO_cleanup_region_end as empty macros.\n+\n+\t* libioP.h: Change type of finish function to take an additional int\n+\targument and change declaration of finish functions.\n+\tAdd prototypes for _IO_seekoff and _IO_seekpos.\n+\tIf _G_HAVE_MMAP is defined use stream buffers allocated with mmap.\n+\tRedefine FREE_BUF and ALLOC_BUF macros to help in both situations.\n+\t(FILEBUF_LITERAL): If we compile for a thread-safe library also\n+\tinitialize lock member.\n+\n+\t* filedoalloc.c: Take care for systems already defining _POSIX_SOURCE.\n+\tKeep name space clean on systems which require this.\n+\t(_IO_file_doallocate): Adopt ALLOC_BUF call for changed semantic.\n+\n+\t* fileops.c: Keep name space clean on systems which require this.\n+\t(_IO_file_attach): Don't fail if seek failed because it's used on a\n+\tpipe.\n+\t(_IO_file_underflow): Update buffer pointers before calling `read'\n+\tsince the `read' might not return anymore.\n+\t(_IO_file_overflow): If stream allows no writes set error flag.\n+\t(_IO_seekoff): Make sure that after flushing the file pointer in\n+\tthe underlying file is exact.\n+\t(_IO_file_read): Don't restart `read' syscall if it return EINTR.\n+\tThis violates POSIX.\n+\t(_IO_file_write): Likewise for `write'.\n+\t(_IO_cleanup): Install as exit handler in glibc.\n+\n+\t* genops.c (_IO_setb): Correctly use FREE_BUF.\n+\t(_IO_default_doallocate): Correctly use ALLOC_BUF.\n+\t(_IO_init): Initialize lock in stream structure.\n+\t(_IO_default_finish): Destroy lock.\n+\t(_IO_get_column): Don't compile since it's not needed.\n+\t(_IO_nobackup_default): Likewise.\n+\n+\t* iopopen.c: Take care for systems already defining _POSIX_SOURCE.\n+\tCorrect _IO_fork and _IO_dup2 prototypes.\n+\n+\t* iofclose.c: Acquire lock before starting the work.\n+\t* iofflush.c: Likewise.\n+\t* iofgetpos.c: Likewise.\n+\t* iofgets.c: Likewise.\n+\t* iofputs.c: Likewise.\n+\t* iofread.c: Likewise.\n+\t* iofsetpos.c: Likewise.\n+\t* ioftell.c: Likewise.\n+\t* iofwrite.c: Likewise.\n+\t* iogetdelim.c: Likewise.\n+\t* iogets.c: Likewise.\n+\t* ioputs.c: Likewise.\n+\t* iosetbuffer.c: Likewise.\n+\t* iosetvbuf.c: Likewise.\n+\t* ioungetc.c: Likewise.\n+\n+\t* iofdopen.c: Create and initialize lock for new stream.\n+\t* iofopen.c: Likewise.\n+\t* iopopen.c (_IO_popen): Likewise.\n+\t* iovsprintf.c: Likewise.\n+\t* iovsscanf.c: Likewise.\n+\n+\t* genops.c: Make weak aliases for various functions.\n+\t* iofclose.c: Likewise.\n+\t* iofdopen.c: Likewise.\n+\t* iofflush.c: Likewise.\n+\t* iofgetpos.c: Likewise.\n+\t* iofgets.c: Likewise.\n+\t* iofopen.c: Likewise.\n+\t* iofputs.c: Likewise.\n+\t* iofread.c: Likewise.\n+\t* iofsetpos.c: Likewise.\n+\t* ioftell.c: Likewise.\n+\t* iofwrite.c: Likewise.\n+\t* iogetdelim.c: Likewise.\n+\t* iogets.c: Likewise.\n+\t* ioputs.c: Likewise.\n+\t* iosetbuffer.c: Likewise.\n+\t* iosetvbuf.c: Likewise.\n+\t* ioungetc.c: Likewise.\n+\t* iovsprintf.c: Likewise.\n+\t* iovsscanf.c: Likewise.\n+\n+\t* iofflush_u.c: New file.  fflush_unlocked implementation.\n+\n+\t* iostream.h [_G_HAVE_LONG_DOUBLE_IO]: Declare real long double\n+\toutput operator.\n+\n+\t* peekc.c: New file.  Implement _IO_peekc_locked function.\n+\n+\t* stdfiles.c: If we compile for a thread-safe library also define\n+\tlock variable.\n+\n Tue Aug 26 12:24:01 1997  H.J. Lu  (hjl@gnu.ai.mit.edu)\n \n-        * testsuite/Makefile.in (check): Don't depend on site.exp.\n-        (just-check): Depend on site.exp.\n+\t* testsuite/Makefile.in (check): Don't depend on site.exp.\n+\t(just-check): Depend on site.exp.\n \n Wed Aug 20 02:01:34 1997  Jason Merrill  <jason@yorick.cygnus.com>\n "}, {"sha": "aab8ac601282d889c0b9bf2b93202291c8b86b36", "filename": "libio/Makefile.in", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2FMakefile.in?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -29,7 +29,8 @@ IO_OBJECTS = filedoalloc.o floatconv.o genops.o fileops.o \\\n   iofgetpos.o iofread.o iofscanf.o \\\n   iofsetpos.o iogetdelim.o iogetline.o \\\n   ioprintf.o ioseekoff.o ioseekpos.o \\\n-  outfloat.o strops.o iofclose.o iopopen.o ioungetc.o\n+  outfloat.o strops.o iofclose.o iopopen.o ioungetc.o peekc.o iogetc.o \\\n+  ioputc.o iofeof.o ioferror.o\n \n # These emulate stdio functionality, but with a different name (_IO_ungetc\n # instead of ungetc), and using _IO_FILE instead of FILE.\n@@ -40,7 +41,7 @@ IO_OBJECTS = filedoalloc.o floatconv.o genops.o fileops.o \\\n # iofclose.o is not here, because it is needed for stdio (by pclose).\n STDIO_WRAP_OBJECTS =  iofdopen.o iofflush.o iofgets.o iofopen.o iofprintf.o iofputs.o iofwrite.o \\\n   iogets.o ioperror.o ioputs.o ioscanf.o iosetbuffer.o iosetvbuf.o \\\n-  iosprintf.o iosscanf.o ioftell.o iovsprintf.o iovsscanf.o\n+  iosprintf.o iosscanf.o ioftell.o iovsscanf.o iovsprintf.o\n \n IOSTREAM_OBJECTS = builtinbuf.o filebuf.o fstream.o \\\n   indstream.o ioassign.o ioextend.o iomanip.o iostream.o \\\n@@ -82,16 +83,12 @@ tpipe: tpipe.o libio.a\n \n iostream.list: stamp-picdir $(_G_CONFIG_H) $(LIBIOSTREAM_DEP)\n \t@echo \"$(LIBIOSTREAM_USE)\"> iostream.list\n+\t@echo \"$(STDIO_WRAP_OBJECTS)\" >> iostream.list\n \n-stdio/stdio.list: force\n+stmp-stdio:\n \t@rootme=`pwd`/ ; export rootme; cd stdio ; \\\n \t  $(MAKE) $(FLAGS_TO_PASS) stdio.list\n \n-stdio.list: stdio/stdio.list\n-\trm -f tstdio.list\n-\tsed 's,\\([a-z_]*\\.o\\),stdio/\\1,g' stdio/stdio.list > tstdio.list\n-\tmv tstdio.list stdio.list\n-\n _G_config.h: ${srcdir}/gen-params\n \trootme=`pwd`/ ; export rootme; \\\n \tCC=\"$(CC)\"; export CC; \\"}, {"sha": "b14c3b17215500d23ea074b81312084a6c9ca040", "filename": "libio/configure.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfigure.in?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -57,7 +57,7 @@ ${moveifchange} temp.mt target-mkfrag\n \n LIBDIR=yes\n TO_TOPDIR=../\n-ALL='$(_G_CONFIG_H) libio.a iostream.list'\n+ALL='$(_G_CONFIG_H) libio.a libiostream.a iostream.list'\n XCINCLUDES='-I. -I$(srcdir)'\n XCXXINCLUDES='-I. -I$(srcdir)'\n MOSTLYCLEAN='*.o pic stamp-picdir core iostream.list'"}, {"sha": "f1b781e8a0fabfe3338ef7ba8a768d908c947eab", "filename": "libio/filedoalloc.c", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Ffiledoalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Ffiledoalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ffiledoalloc.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,26 +1,27 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n /*\n  * Copyright (c) 1990 The Regents of the University of California.\n@@ -41,7 +42,9 @@ the executable file might be covered by the GNU General Public License. */\n \n /* Modified for GNU iostream by Per Bothner 1991, 1992. */\n \n-#define _POSIX_SOURCE\n+#ifndef _POSIX_SOURCE\n+# define _POSIX_SOURCE\n+#endif\n #include \"libioP.h\"\n #include <sys/types.h>\n #include <sys/stat.h>\n@@ -50,6 +53,11 @@ the executable file might be covered by the GNU General Public License. */\n #include <unistd.h>\n #endif\n \n+#ifdef _LIBC\n+# undef isatty\n+# define isatty(Fd) __isatty (Fd)\n+#endif\n+\n /*\n  * Allocate a file buffer, or switch to unbuffered I/O.\n  * Per the ANSI C standard, ALL tty devices default to line buffered.\n@@ -59,21 +67,23 @@ the executable file might be covered by the GNU General Public License. */\n  */\n \n int\n-DEFUN(_IO_file_doallocate, (fp),\n-      register _IO_FILE *fp)\n+_IO_file_doallocate (fp)\n+     _IO_FILE *fp;\n {\n-  register _IO_size_t size;\n+  _IO_size_t size;\n   int couldbetty;\n-  register char *p;\n+  char *p;\n   struct stat st;\n \n+#ifndef _LIBC\n   /* If _IO_cleanup_registration_needed is non-zero, we should call the\n      function it points to.  This is to make sure _IO_cleanup gets called\n      on exit.  We call it from _IO_file_doallocate, since that is likely\n      to get called by any program that does buffered I/O. */\n   if (_IO_cleanup_registration_needed)\n-    (*_IO_cleanup_registration_needed)();\n-  \n+    (*_IO_cleanup_registration_needed) ();\n+#endif\n+\n   if (fp->_fileno < 0 || _IO_SYSSTAT (fp, &st) < 0)\n     {\n       couldbetty = 0;\n@@ -85,18 +95,16 @@ DEFUN(_IO_file_doallocate, (fp),\n     }\n   else\n     {\n-      couldbetty = S_ISCHR(st.st_mode);\n+      couldbetty = S_ISCHR (st.st_mode);\n #if _IO_HAVE_ST_BLKSIZE\n       size = st.st_blksize <= 0 ? _IO_BUFSIZ : st.st_blksize;\n #else\n       size = _IO_BUFSIZ;\n #endif\n     }\n-  p = ALLOC_BUF(size);\n-  if (p == NULL)\n-    return EOF;\n-  _IO_setb(fp, p, p+size, 1);\n-  if (couldbetty && isatty(fp->_fileno))\n+  ALLOC_BUF (p, size, EOF);\n+  _IO_setb (fp, p, p + size, 1);\n+  if (couldbetty && isatty (fp->_fileno))\n     fp->_flags |= _IO_LINE_BUF;\n   return 1;\n }"}, {"sha": "b3a3a24651fbe1cd92ae667ddc2fccec4112d8c9", "filename": "libio/fileops.c", "status": "modified", "additions": 285, "deletions": 215, "changes": 500, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Ffileops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Ffileops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Ffileops.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,30 +1,33 @@\n-/* \n-Copyright (C) 1993, 1995 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-/*  written by Per Bothner (bothner@cygnus.com) */\n-\n-#define _POSIX_SOURCE\n+/* Copyright (C) 1993, 1995, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+   Written by Per Bothner <bothner@cygnus.com>.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+\n+#ifndef _POSIX_SOURCE\n+# define _POSIX_SOURCE\n+#endif\n #include \"libioP.h\"\n #include <fcntl.h>\n #include <sys/types.h>\n@@ -35,11 +38,16 @@ the executable file might be covered by the GNU General Public License. */\n extern int errno;\n #endif\n \n+\n+#ifdef _LIBC\n+# define open(Name, Flags, Prot) __open ((Name), (Flags), (Prot))\n+#endif\n+\n /* An fstream can be in at most one of put mode, get mode, or putback mode.\n    Putback mode is a variant of get mode.\n \n    In a filebuf, there is only one current position, instead of two\n-   separate get and put pointers.  In get mode, the current posistion\n+   separate get and put pointers.  In get mode, the current position\n    is that of gptr(); in put mode that of pptr().\n \n    The position in the buffer that corresponds to the position\n@@ -73,14 +81,14 @@ extern int errno;\n    (The pointers save_gptr() and save_egptr() are the values\n    of gptr() and egptr() at the time putback mode was entered.)\n    The OS position corresponds to that of save_egptr().\n-   \n+\n    LINE BUFFERED OUTPUT:\n    During line buffered output, _IO_write_base==base() && epptr()==base().\n    However, ptr() may be anywhere between base() and ebuf().\n    This forces a call to filebuf::overflow(int C) on every put.\n    If there is more space in the buffer, and C is not a '\\n',\n    then C is inserted, and pptr() incremented.\n-   \n+\n    UNBUFFERED STREAMS:\n    If a filebuf is unbuffered(), the _shortbuf[1] is used as the buffer.\n */\n@@ -90,8 +98,8 @@ extern int errno;\n \n \n void\n-DEFUN(_IO_file_init, (fp),\n-      register _IO_FILE *fp)\n+_IO_file_init (fp)\n+     _IO_FILE *fp;\n {\n   /* POSIX.1 allows another file handle to be used to change the position\n      of our file descriptor.  Hence we actually don't know the actual\n@@ -104,11 +112,11 @@ DEFUN(_IO_file_init, (fp),\n }\n \n int\n-DEFUN(_IO_file_close_it, (fp),\n-      register _IO_FILE* fp)\n+_IO_file_close_it (fp)\n+     _IO_FILE *fp;\n {\n   int write_status, close_status;\n-  if (!_IO_file_is_open(fp))\n+  if (!_IO_file_is_open (fp))\n     return EOF;\n \n   write_status = _IO_do_flush (fp);\n@@ -118,11 +126,11 @@ DEFUN(_IO_file_close_it, (fp),\n   close_status = _IO_SYSCLOSE (fp);\n \n   /* Free buffer. */\n-  _IO_setb(fp, NULL, NULL, 0);\n-  _IO_setg(fp, NULL, NULL, NULL);\n-  _IO_setp(fp, NULL, NULL);\n+  _IO_setb (fp, NULL, NULL, 0);\n+  _IO_setg (fp, NULL, NULL, NULL);\n+  _IO_setp (fp, NULL, NULL);\n \n-  _IO_un_link(fp);\n+  _IO_un_link (fp);\n   fp->_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;\n   fp->_fileno = EOF;\n   fp->_offset = _IO_pos_BAD;\n@@ -131,86 +139,99 @@ DEFUN(_IO_file_close_it, (fp),\n }\n \n void\n-DEFUN(_IO_file_finish, (fp),\n-      register _IO_FILE* fp)\n+_IO_file_finish (fp, dummy)\n+     _IO_FILE *fp;\n+     int dummy;\n {\n-  if (_IO_file_is_open(fp))\n+  if (_IO_file_is_open (fp))\n     {\n       _IO_do_flush (fp);\n       if (!(fp->_flags & _IO_DELETE_DONT_CLOSE))\n \t_IO_SYSCLOSE (fp);\n     }\n-  _IO_default_finish(fp);\n+  _IO_default_finish (fp, 0);\n }\n \n _IO_FILE *\n-DEFUN(_IO_file_fopen, (fp, filename, mode),\n-      register _IO_FILE *fp AND const char *filename AND const char *mode)\n+_IO_file_fopen (fp, filename, mode)\n+     _IO_FILE *fp;\n+     const char *filename;\n+     const char *mode;\n {\n   int oflags = 0, omode;\n   int read_write, fdesc;\n   int oprot = 0666;\n   if (_IO_file_is_open (fp))\n     return 0;\n-  switch (*mode++) {\n-  case 'r':\n-    omode = O_RDONLY;\n-    read_write = _IO_NO_WRITES;\n-    break;\n-  case 'w':\n-    omode = O_WRONLY;\n-    oflags = O_CREAT|O_TRUNC;\n-    read_write = _IO_NO_READS;\n-    break;\n-  case 'a':\n-    omode = O_WRONLY;\n-    oflags = O_CREAT|O_APPEND;\n-    read_write = _IO_NO_READS|_IO_IS_APPENDING;\n-    break;\n-  default:\n-    errno = EINVAL;\n-    return NULL;\n-  }\n-  if (mode[0] == '+' || (mode[0] == 'b' && mode[1] == '+')) {\n-    omode = O_RDWR;\n-    read_write &= _IO_IS_APPENDING;\n-  }\n-  fdesc = open(filename, omode|oflags, oprot);\n+  switch (*mode++)\n+    {\n+    case 'r':\n+      omode = O_RDONLY;\n+      read_write = _IO_NO_WRITES;\n+      break;\n+    case 'w':\n+      omode = O_WRONLY;\n+      oflags = O_CREAT|O_TRUNC;\n+      read_write = _IO_NO_READS;\n+      break;\n+    case 'a':\n+      omode = O_WRONLY;\n+      oflags = O_CREAT|O_APPEND;\n+      read_write = _IO_NO_READS|_IO_IS_APPENDING;\n+      break;\n+    default:\n+      __set_errno (EINVAL);\n+      return NULL;\n+    }\n+  if (mode[0] == '+' || (mode[0] == 'b' && mode[1] == '+'))\n+    {\n+      omode = O_RDWR;\n+      read_write &= _IO_IS_APPENDING;\n+    }\n+  fdesc = open (filename, omode|oflags, oprot);\n   if (fdesc < 0)\n     return NULL;\n   fp->_fileno = fdesc;\n-  _IO_mask_flags(fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);\n+  _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);\n   if (read_write & _IO_IS_APPENDING)\n     if (_IO_SEEKOFF (fp, (_IO_off_t)0, _IO_seek_end, _IOS_INPUT|_IOS_OUTPUT)\n-\t== _IO_pos_BAD)\n+\t== _IO_pos_BAD && errno != ESPIPE)\n       return NULL;\n-  _IO_link_in(fp);\n+  _IO_link_in (fp);\n   return fp;\n }\n \n-_IO_FILE*\n-DEFUN(_IO_file_attach, (fp, fd),\n-      _IO_FILE *fp AND int fd)\n+_IO_FILE *\n+_IO_file_attach (fp, fd)\n+     _IO_FILE *fp;\n+     int fd;\n {\n-  if (_IO_file_is_open(fp))\n+  if (_IO_file_is_open (fp))\n     return NULL;\n   fp->_fileno = fd;\n   fp->_flags &= ~(_IO_NO_READS+_IO_NO_WRITES);\n   fp->_flags |= _IO_DELETE_DONT_CLOSE;\n+  /* Get the current position of the file. */\n+  /* We have to do that since that may be junk. */\n   fp->_offset = _IO_pos_BAD;\n+  if (_IO_SEEKOFF (fp, (_IO_off_t)0, _IO_seek_cur, _IOS_INPUT|_IOS_OUTPUT)\n+      == _IO_pos_BAD && errno != ESPIPE)\n+    return NULL;\n   return fp;\n }\n \n-_IO_FILE*\n-DEFUN(_IO_file_setbuf, (fp, p, len),\n-      register _IO_FILE *fp AND char* p AND _IO_ssize_t len)\n+_IO_FILE *\n+_IO_file_setbuf (fp, p, len)\n+     _IO_FILE *fp;\n+     char *p;\n+     _IO_ssize_t len;\n {\n-    if (_IO_default_setbuf(fp, p, len) == NULL)\n-\treturn NULL;\n+    if (_IO_default_setbuf (fp, p, len) == NULL)\n+      return NULL;\n \n     fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end\n       = fp->_IO_buf_base;\n-    _IO_setg(fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n+    _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n \n     return fp;\n }\n@@ -219,44 +240,42 @@ DEFUN(_IO_file_setbuf, (fp, p, len),\n    Then mark FP as having empty buffers. */\n \n int\n-DEFUN(_IO_do_write, (fp, data, to_do),\n-      register _IO_FILE *fp AND const char* data AND _IO_size_t to_do)\n+_IO_do_write (fp, data, to_do)\n+     _IO_FILE *fp;\n+     const char *data;\n+     _IO_size_t to_do;\n {\n   _IO_size_t count;\n   if (to_do == 0)\n     return 0;\n-  else\n+  if (fp->_flags & _IO_IS_APPENDING)\n+    /* On a system without a proper O_APPEND implementation,\n+       you would need to sys_seek(0, SEEK_END) here, but is\n+       is not needed nor desirable for Unix- or Posix-like systems.\n+       Instead, just indicate that offset (before and after) is\n+       unpredictable. */\n+    fp->_offset = _IO_pos_BAD;\n+  else if (fp->_IO_read_end != fp->_IO_write_base)\n     {\n-      if (fp->_flags & _IO_IS_APPENDING)\n-\t/* On a system without a proper O_APPEND implementation,\n-\t   you would need to sys_seek(0, SEEK_END) here, but is\n-\t   is not needed nor desirable for Unix- or Posix-like systems.\n-\t   Instead, just indicate that offset (before and after) is\n-\t   unpredictable. */\n-\tfp->_offset = _IO_pos_BAD;\n-      else if (fp->_IO_read_end != fp->_IO_write_base)\n-\t{ \n-\t  _IO_pos_t new_pos\n-\t    = _IO_SYSSEEK(fp, fp->_IO_write_base - fp->_IO_read_end, 1);\n-\t  if (new_pos == _IO_pos_BAD)\n-\t    return EOF;\n-\t  fp->_offset = new_pos;\n-\t}\n-      count = _IO_SYSWRITE (fp, data, to_do);\n-      if (fp->_cur_column)\n-\tfp->_cur_column\n-\t  = _IO_adjust_column (fp->_cur_column - 1, data, to_do) + 1;\n+      _IO_pos_t new_pos\n+\t= _IO_SYSSEEK (fp, fp->_IO_write_base - fp->_IO_read_end, 1);\n+      if (new_pos == _IO_pos_BAD)\n+\treturn EOF;\n+      fp->_offset = new_pos;\n     }\n-  _IO_setg(fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n+  count = _IO_SYSWRITE (fp, data, to_do);\n+  if (fp->_cur_column)\n+    fp->_cur_column = _IO_adjust_column (fp->_cur_column - 1, data, to_do) + 1;\n+  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n   fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_buf_base;\n-  fp->_IO_write_end = (fp->_flags & (_IO_LINE_BUF+_IO_UNBUFFERED)) ? fp->_IO_buf_base\n-    : fp->_IO_buf_end;\n+  fp->_IO_write_end = ((fp->_flags & (_IO_LINE_BUF+_IO_UNBUFFERED))\n+\t\t       ? fp->_IO_buf_base : fp->_IO_buf_end);\n   return count != to_do ? EOF : 0;\n }\n \n int\n-DEFUN(_IO_file_underflow, (fp),\n-      register _IO_FILE *fp)\n+_IO_file_underflow (fp)\n+     _IO_FILE *fp;\n {\n   _IO_ssize_t count;\n #if 0\n@@ -266,19 +285,31 @@ DEFUN(_IO_file_underflow, (fp),\n #endif\n \n   if (fp->_flags & _IO_NO_READS)\n-    return EOF;\n+    {\n+      __set_errno (EBADF);\n+      return EOF;\n+    }\n   if (fp->_IO_read_ptr < fp->_IO_read_end)\n-    return *(unsigned char*)fp->_IO_read_ptr;\n+    return *(unsigned char *) fp->_IO_read_ptr;\n \n   if (fp->_IO_buf_base == NULL)\n-    _IO_doallocbuf(fp);\n+    _IO_doallocbuf (fp);\n \n   /* Flush all line buffered files before reading. */\n   /* FIXME This can/should be moved to genops ?? */\n   if (fp->_flags & (_IO_LINE_BUF|_IO_UNBUFFERED))\n-    _IO_flush_all_linebuffered();\n+    _IO_flush_all_linebuffered ();\n \n-  _IO_switch_to_get_mode(fp);\n+  _IO_switch_to_get_mode (fp);\n+\n+  /* This is very tricky. We have to adjust those\n+     pointers before we call _IO_SYSREAD () since\n+     we may longjump () out while waiting for\n+     input. Those pointers may be screwed up. H.J. */\n+  fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_buf_base;\n+  fp->_IO_read_end = fp->_IO_buf_base;\n+  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end\n+    = fp->_IO_buf_base;\n \n   count = _IO_SYSREAD (fp, fp->_IO_buf_base,\n \t\t       fp->_IO_buf_end - fp->_IO_buf_base);\n@@ -289,30 +320,32 @@ DEFUN(_IO_file_underflow, (fp),\n       else\n \tfp->_flags |= _IO_ERR_SEEN, count = 0;\n   }\n-  fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_buf_base;\n-  fp->_IO_read_end = fp->_IO_buf_base + count;\n-  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end\n-    = fp->_IO_buf_base;\n+  fp->_IO_read_end += count;\n   if (count == 0)\n     return EOF;\n   if (fp->_offset != _IO_pos_BAD)\n-    _IO_pos_adjust(fp->_offset, count);\n-  return *(unsigned char*)fp->_IO_read_ptr;\n+    _IO_pos_adjust (fp->_offset, count);\n+  return *(unsigned char *) fp->_IO_read_ptr;\n }\n \n int\n-DEFUN(_IO_file_overflow, (f, ch),\n-      register _IO_FILE* f AND int ch)\n+_IO_file_overflow (f, ch)\n+      _IO_FILE *f;\n+      int ch;\n {\n   if (f->_flags & _IO_NO_WRITES) /* SET ERROR */\n-    return EOF;\n+    {\n+      f->_flags |= _IO_ERR_SEEN;\n+      __set_errno (EBADF);\n+      return EOF;\n+    }\n   /* If currently reading or no buffer allocated. */\n   if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0)\n     {\n       /* Allocate a buffer if needed. */\n       if (f->_IO_write_base == 0)\n \t{\n-\t  _IO_doallocbuf(f);\n+\t  _IO_doallocbuf (f);\n \t  _IO_setg (f, f->_IO_buf_base, f->_IO_buf_base, f->_IO_buf_base);\n \t}\n       /* Otherwise must be currently reading.\n@@ -334,35 +367,35 @@ DEFUN(_IO_file_overflow, (f, ch),\n       f->_flags |= _IO_CURRENTLY_PUTTING;\n     }\n   if (ch == EOF)\n-    return _IO_do_flush(f);\n+    return _IO_do_flush (f);\n   if (f->_IO_write_ptr == f->_IO_buf_end ) /* Buffer is really full */\n-    if (_IO_do_flush(f) == EOF)\n+    if (_IO_do_flush (f) == EOF)\n       return EOF;\n   *f->_IO_write_ptr++ = ch;\n   if ((f->_flags & _IO_UNBUFFERED)\n       || ((f->_flags & _IO_LINE_BUF) && ch == '\\n'))\n-    if (_IO_do_flush(f) == EOF)\n+    if (_IO_do_flush (f) == EOF)\n       return EOF;\n-  return (unsigned char)ch;\n+  return (unsigned char) ch;\n }\n \n int\n-DEFUN(_IO_file_sync, (fp),\n-      register _IO_FILE* fp)\n+_IO_file_sync (fp)\n+     _IO_FILE *fp;\n {\n   _IO_size_t delta;\n   /*    char* ptr = cur_ptr(); */\n   if (fp->_IO_write_ptr > fp->_IO_write_base)\n     if (_IO_do_flush(fp)) return EOF;\n-  delta = fp->_IO_read_ptr - fp->_IO_read_end; \n+  delta = fp->_IO_read_ptr - fp->_IO_read_end;\n   if (delta != 0)\n     {\n #ifdef TODO\n-      if (_IO_in_backup(fp))\n-\tdelta -= eGptr() - Gbase();\n+      if (_IO_in_backup (fp))\n+\tdelta -= eGptr () - Gbase ();\n #endif\n       _IO_off_t new_pos = _IO_SYSSEEK (fp, delta, 1);\n-      if (new_pos != (_IO_off_t)EOF)\n+      if (new_pos != (_IO_off_t) EOF)\n \tfp->_IO_read_end = fp->_IO_read_ptr;\n #ifdef ESPIPE\n       else if (errno == ESPIPE)\n@@ -378,12 +411,19 @@ DEFUN(_IO_file_sync, (fp),\n }\n \n _IO_pos_t\n-DEFUN(_IO_file_seekoff, (fp, offset, dir, mode),\n-      register _IO_FILE *fp AND _IO_off_t offset AND int dir AND int mode)\n+_IO_file_seekoff (fp, offset, dir, mode)\n+     _IO_FILE *fp;\n+     _IO_off_t offset;\n+     int dir;\n+     int mode;\n {\n   _IO_pos_t result;\n   _IO_off_t delta, new_offset;\n   long count;\n+  /* POSIX.1 8.2.3.7 says that after a call the fflush() the file\n+     offset of the underlying file must be exact.  */\n+  int must_be_exact = (fp->_IO_read_base == fp->_IO_read_end\n+\t\t       && fp->_IO_write_base == fp->_IO_write_ptr);\n \n   if (mode == 0)\n     dir = _IO_seek_cur, offset = 0; /* Don't move any pointers. */\n@@ -396,14 +436,15 @@ DEFUN(_IO_file_seekoff, (fp, offset, dir, mode),\n      end up flushing when we close(), it doesn't make much difference.)\n      FIXME: simulate mem-papped files. */\n \n-  if (fp->_IO_write_ptr > fp->_IO_write_base || _IO_in_put_mode(fp))\n-    if (_IO_switch_to_get_mode(fp)) return EOF;\n+  if (fp->_IO_write_ptr > fp->_IO_write_base || _IO_in_put_mode (fp))\n+    if (_IO_switch_to_get_mode (fp))\n+      return EOF;\n \n   if (fp->_IO_buf_base == NULL)\n     {\n-      _IO_doallocbuf(fp);\n-      _IO_setp(fp, fp->_IO_buf_base, fp->_IO_buf_base);\n-      _IO_setg(fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n+      _IO_doallocbuf (fp);\n+      _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n+      _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n     }\n \n   switch (dir)\n@@ -414,7 +455,7 @@ DEFUN(_IO_file_seekoff, (fp, offset, dir, mode),\n       if (fp->_offset == _IO_pos_BAD)\n \tgoto dumb;\n       /* Make offset absolute, assuming current pointer is file_ptr(). */\n-      offset += _IO_pos_as_off(fp->_offset);\n+      offset += _IO_pos_as_off (fp->_offset);\n \n       dir = _IO_seek_set;\n       break;\n@@ -423,7 +464,7 @@ DEFUN(_IO_file_seekoff, (fp, offset, dir, mode),\n     case _IO_seek_end:\n       {\n \tstruct stat st;\n-\tif (_IO_SYSSTAT (fp, &st) == 0 && S_ISREG(st.st_mode))\n+\tif (_IO_SYSSTAT (fp, &st) == 0 && S_ISREG (st.st_mode))\n \t  {\n \t    offset += st.st_size;\n \t    dir = _IO_seek_set;\n@@ -439,46 +480,46 @@ DEFUN(_IO_file_seekoff, (fp, offset, dir, mode),\n       && !_IO_in_backup (fp))\n     {\n       /* Offset relative to start of main get area. */\n-      _IO_pos_t rel_offset = offset - fp->_offset\n-\t+ (fp->_IO_read_end - fp->_IO_read_base);\n+      _IO_pos_t rel_offset = (offset - fp->_offset\n+\t\t\t      + (fp->_IO_read_end - fp->_IO_read_base));\n       if (rel_offset >= 0)\n \t{\n #if 0\n-\t  if (_IO_in_backup(fp))\n-\t    _IO_switch_to_main_get_area(fp);\n+\t  if (_IO_in_backup (fp))\n+\t    _IO_switch_to_main_get_area (fp);\n #endif\n \t  if (rel_offset <= fp->_IO_read_end - fp->_IO_read_base)\n \t    {\n-\t      _IO_setg(fp, fp->_IO_buf_base, fp->_IO_buf_base + rel_offset,\n-\t\t       fp->_IO_read_end);\n-\t      _IO_setp(fp, fp->_IO_buf_base, fp->_IO_buf_base);\n+\t      _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base + rel_offset,\n+\t\t\tfp->_IO_read_end);\n+\t      _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n \t      return offset;\n \t    }\n #ifdef TODO\n \t    /* If we have streammarkers, seek forward by reading ahead. */\n-\t    if (_IO_have_markers(fp))\n+\t    if (_IO_have_markers (fp))\n \t      {\n \t\tint to_skip = rel_offset\n \t\t  - (fp->_IO_read_ptr - fp->_IO_read_base);\n-\t\tif (ignore(to_skip) != to_skip)\n+\t\tif (ignore (to_skip) != to_skip)\n \t\t  goto dumb;\n \t\treturn offset;\n \t      }\n #endif\n \t}\n #ifdef TODO\n-      if (rel_offset < 0 && rel_offset >= Bbase() - Bptr())\n+      if (rel_offset < 0 && rel_offset >= Bbase () - Bptr ())\n \t{\n-\t  if (!_IO_in_backup(fp))\n-\t    _IO_switch_to_backup_area(fp);\n-\t  gbump(fp->_IO_read_end + rel_offset - fp->_IO_read_ptr);\n+\t  if (!_IO_in_backup (fp))\n+\t    _IO_switch_to_backup_area (fp);\n+\t  gbump (fp->_IO_read_end + rel_offset - fp->_IO_read_ptr);\n \t  return offset;\n \t}\n #endif\n     }\n \n #ifdef TODO\n-  _IO_unsave_markers(fp);\n+  _IO_unsave_markers (fp);\n #endif\n \n   if (fp->_flags & _IO_NO_READS)\n@@ -500,7 +541,8 @@ DEFUN(_IO_file_seekoff, (fp, offset, dir, mode),\n   else\n     {\n       count = _IO_SYSREAD (fp, fp->_IO_buf_base,\n-\t\t\t   fp->_IO_buf_end - fp->_IO_buf_base);\n+\t\t\t   (must_be_exact\n+\t\t\t    ? delta : fp->_IO_buf_end - fp->_IO_buf_base));\n       if (count < delta)\n \t{\n \t  /* We weren't allowed to read, but try to seek the remainder. */\n@@ -509,31 +551,38 @@ DEFUN(_IO_file_seekoff, (fp, offset, dir, mode),\n \t  goto dumb;\n \t}\n     }\n-  _IO_setg(fp, fp->_IO_buf_base, fp->_IO_buf_base+delta, fp->_IO_buf_base+count);\n-  _IO_setp(fp, fp->_IO_buf_base, fp->_IO_buf_base);\n+  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base + delta,\n+\t    fp->_IO_buf_base + count);\n+  _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n   fp->_offset = result + count;\n-  _IO_mask_flags(fp, 0, _IO_EOF_SEEN);\n+  _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n   return offset;\n  dumb:\n \n-  _IO_unsave_markers(fp);\n+  _IO_unsave_markers (fp);\n   result = _IO_SYSSEEK (fp, offset, dir);\n   if (result != EOF)\n-    _IO_mask_flags(fp, 0, _IO_EOF_SEEN);\n+    _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n   fp->_offset = result;\n-  _IO_setg(fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n-  _IO_setp(fp, fp->_IO_buf_base, fp->_IO_buf_base);\n+  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n+  _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n   return result;\n }\n \n _IO_ssize_t\n-DEFUN(_IO_file_read, (fp, buf, size),\n-      register _IO_FILE* fp AND void* buf AND _IO_ssize_t size)\n+_IO_file_read (fp, buf, size)\n+     _IO_FILE *fp;\n+     void *buf;\n+     _IO_ssize_t size;\n {\n   for (;;)\n     {\n-      _IO_ssize_t count = _IO_read(fp->_fileno, buf, size);\n-#ifdef EINTR\n+      _IO_ssize_t count = _IO_read (fp->_fileno, buf, size);\n+#if 0 && defined EINTR\n+      /* We must not do this optimization since POSIX.1 explicitly\n+\t requests that the stream operations must return with the\n+\t error EINTR if this happens.  There must be the possibility\n+\t that stream operations time out.  --drepper  */\n       if (count == -1 && errno == EINTR)\n \tcontinue;\n #endif\n@@ -542,37 +591,46 @@ DEFUN(_IO_file_read, (fp, buf, size),\n }\n \n _IO_pos_t\n-DEFUN(_IO_file_seek, (fp, offset, dir),\n-      _IO_FILE *fp AND _IO_off_t offset AND int dir)\n+_IO_file_seek (fp, offset, dir)\n+     _IO_FILE *fp;\n+     _IO_off_t offset;\n+     int dir;\n {\n-  return _IO_lseek(fp->_fileno, offset, dir);\n+  return _IO_lseek (fp->_fileno, offset, dir);\n }\n \n int\n-DEFUN(_IO_file_stat, (fp, st),\n-      _IO_FILE *fp AND void* st)\n+_IO_file_stat (fp, st)\n+     _IO_FILE *fp;\n+     void *st;\n {\n-  return _IO_fstat(fp->_fileno, (struct stat*)st);\n+  return _IO_fstat (fp->_fileno, (struct stat *) st);\n }\n \n int\n-DEFUN(_IO_file_close, (fp),\n-      _IO_FILE* fp)\n+_IO_file_close (fp)\n+     _IO_FILE *fp;\n {\n-  return _IO_close(fp->_fileno);\n+  return _IO_close (fp->_fileno);\n }\n \n _IO_ssize_t\n-DEFUN(_IO_file_write, (f, data, n),\n-      register _IO_FILE* f AND const void* data AND _IO_ssize_t n)\n+_IO_file_write (f, data, n)\n+     _IO_FILE *f;\n+     const void *data;\n+     _IO_ssize_t n;\n {\n   _IO_ssize_t to_do = n;\n   while (to_do > 0)\n     {\n-      _IO_ssize_t count = _IO_write(f->_fileno, data, to_do);\n+      _IO_ssize_t count = _IO_write (f->_fileno, data, to_do);\n       if (count == EOF)\n \t{\n-#ifdef EINTR\n+#if 0 && defined EINTR\n+\t  /* We must not do this optimization since POSIX.1 explicitly\n+\t     requests that the stream operations must return with the\n+\t     error EINTR if this happens.  There must be the\n+\t     possibility that stream operations time out.  --drepper  */\n \t  if (errno == EINTR)\n \t    continue;\n \t  else\n@@ -583,7 +641,7 @@ DEFUN(_IO_file_write, (f, data, n),\n             }\n         }\n       to_do -= count;\n-      data = (void*)((char*)data + count);\n+      data = (void *) ((char *) data + count);\n     }\n   n -= to_do;\n   if (f->_offset >= 0)\n@@ -592,10 +650,12 @@ DEFUN(_IO_file_write, (f, data, n),\n }\n \n _IO_size_t\n-DEFUN(_IO_file_xsputn, (f, data, n),\n-      _IO_FILE *f AND const void *data AND _IO_size_t n)\n+_IO_file_xsputn (f, data, n)\n+     _IO_FILE *f;\n+     const void *data;\n+     _IO_size_t n;\n {\n-  register const char *s = (char*) data;\n+  register const char *s = (char *) data;\n   _IO_size_t to_do = n;\n   int must_flush = 0;\n   _IO_size_t count;\n@@ -612,14 +672,16 @@ DEFUN(_IO_file_xsputn, (f, data, n),\n     {\n       count = f->_IO_buf_end - f->_IO_write_ptr;\n       if (count >= n)\n-\t{ register const char *p;\n+\t{\n+\t  register const char *p;\n \t  for (p = s + n; p > s; )\n \t    {\n-\t      if (*--p == '\\n') {\n-\t\tcount = p - s + 1;\n-\t\tmust_flush = 1;\n-\t\tbreak;\n-\t      }\n+\t      if (*--p == '\\n')\n+\t\t{\n+\t\t  count = p - s + 1;\n+\t\t  must_flush = 1;\n+\t\t  break;\n+\t\t}\n \t    }\n \t}\n     }\n@@ -628,23 +690,26 @@ DEFUN(_IO_file_xsputn, (f, data, n),\n     {\n       if (count > to_do)\n \tcount = to_do;\n-      if (count > 20) {\n-\tmemcpy(f->_IO_write_ptr, s, count);\n-\ts += count;\n-      }\n+      if (count > 20)\n+\t{\n+\t  memcpy (f->_IO_write_ptr, s, count);\n+\t  s += count;\n+\t}\n       else\n \t{\n \t  register char *p = f->_IO_write_ptr;\n-\t  register int i = (int)count;\n-\t  while (--i >= 0) *p++ = *s++;\n+\t  register int i = (int) count;\n+\t  while (--i >= 0)\n+\t    *p++ = *s++;\n \t}\n       f->_IO_write_ptr += count;\n       to_do -= count;\n     }\n   if (to_do + must_flush > 0)\n-    { _IO_size_t block_size, dont_write;\n+    {\n+      _IO_size_t block_size, dont_write;\n       /* Next flush the (full) buffer. */\n-      if (__overflow(f, EOF) == EOF)\n+      if (__overflow (f, EOF) == EOF)\n \treturn n - to_do;\n \n       /* Try to maintain alignment: write a whole number of blocks.\n@@ -653,37 +718,40 @@ DEFUN(_IO_file_xsputn, (f, data, n),\n       dont_write = block_size >= 128 ? to_do % block_size : 0;\n \n       count = to_do - dont_write;\n-      if (_IO_do_write(f, s, count) == EOF)\n+      if (_IO_do_write (f, s, count) == EOF)\n \treturn n - to_do;\n       to_do = dont_write;\n-      \n+\n       /* Now write out the remainder.  Normally, this will fit in the\n \t buffer, but it's somewhat messier for line-buffered files,\n \t so we let _IO_default_xsputn handle the general case. */\n       if (dont_write)\n-\tto_do -= _IO_default_xsputn(f, s+count, dont_write);\n+\tto_do -= _IO_default_xsputn (f, s+count, dont_write);\n     }\n   return n - to_do;\n }\n \n #if 0\n /* Work in progress */\n _IO_size_t\n-DEFUN(_IO_file_xsgetn, (fp, data, n),\n-      _IO_FILE *fp AND void *data AND _IO_size_t n)\n+_IO_file_xsgetn (fp, data, n)\n+     _IO_FILE *fp;\n+     void *data;\n+     _IO_size_t n;\n {\n   register _IO_size_t more = n;\n   register char *s = data;\n   for (;;)\n     {\n-      _IO_ssize_t count = fp->_IO_read_end - fp->_IO_read_ptr; /* Data available. */\n+      /* Data available. */\n+      _IO_ssize_t count = fp->_IO_read_end - fp->_IO_read_ptr;\n       if (count > 0)\n \t{\n \t  if (count > more)\n \t    count = more;\n \t  if (count > 20)\n \t    {\n-\t      memcpy(s, fp->_IO_read_ptr, count);\n+\t      memcpy (s, fp->_IO_read_ptr, count);\n \t      s += count;\n \t      fp->_IO_read_ptr += count;\n \t    }\n@@ -692,8 +760,9 @@ DEFUN(_IO_file_xsgetn, (fp, data, n),\n \t  else\n \t    {\n \t      register char *p = fp->_IO_read_ptr;\n-\t      register int i = (int)count;\n-\t      while (--i >= 0) *s++ = *p++;\n+\t      register int i = (int) count;\n+\t      while (--i >= 0)\n+\t\t*s++ = *p++;\n \t      fp->_IO_read_ptr = p;\n             }\n             more -= count;\n@@ -708,11 +777,11 @@ DEFUN(_IO_file_xsgetn, (fp, data, n),\n \t  /* If we're reading a lot of data, don't bother allocating\n \t     a buffer.  But if we're only reading a bit, perhaps we should ??*/\n \t  if (count <= 512 && fp->_IO_buf_base == NULL)\n-\t    _IO_doallocbuf(fp);\n+\t    _IO_doallocbuf (fp);\n \t  if (fp->_flags & (_IO_LINE_BUF|_IO_UNBUFFERED))\n-\t    _IO_flush_all_linebuffered();\n+\t    _IO_flush_all_linebuffered ();\n \n-\t  _IO_switch_to_get_mode(fp); ???;\n+\t  _IO_switch_to_get_mode (fp); ???;\n \t  count = _IO_SYSREAD (fp, s, more);\n \t  if (count <= 0)\n \t     {\n@@ -721,19 +790,20 @@ DEFUN(_IO_file_xsgetn, (fp, data, n),\n \t       else\n \t\t fp->_flags |= _IO_ERR_SEEN, count = 0;\n \t     }\n-\t  \n+\n \t  s += count;\n \t  more -= count;\n \t}\n #endif\n-      if (more == 0 || __underflow(fp) == EOF)\n+      if (more == 0 || __underflow (fp) == EOF)\n \tbreak;\n     }\n   return n - more;\n }\n #endif\n \n-struct _IO_jump_t _IO_file_jumps = {\n+struct _IO_jump_t _IO_file_jumps =\n+{\n   JUMP_INIT_DUMMY,\n   JUMP_INIT(finish, _IO_file_finish),\n   JUMP_INIT(overflow, _IO_file_overflow),"}, {"sha": "de9c826b9fed66822a835556f261bc4378879066", "filename": "libio/genops.c", "status": "modified", "additions": 368, "deletions": 276, "changes": 644, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fgenops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fgenops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fgenops.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,26 +1,27 @@\n-/* \n-Copyright (C) 1993, 1995 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+/* Copyright (C) 1993, 1995, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n /* Generic or default I/O operations. */\n \n@@ -31,41 +32,46 @@ the executable file might be covered by the GNU General Public License. */\n #include <string.h>\n \n void\n-DEFUN(_IO_un_link, (fp),\n-      _IO_FILE *fp)\n-{\n-  if (fp->_flags & _IO_LINKED) {\n-    _IO_FILE **f;\n-    for (f = &_IO_list_all; *f != NULL; f = &(*f)->_chain) {\n-      if (*f == fp) {\n-\t*f = fp->_chain;\n-\tbreak;\n-      }\n+_IO_un_link (fp)\n+     _IO_FILE *fp;\n+{\n+  if (fp->_flags & _IO_LINKED)\n+    {\n+      _IO_FILE **f;\n+      for (f = &_IO_list_all; *f != NULL; f = &(*f)->_chain)\n+\t{\n+\t  if (*f == fp)\n+\t    {\n+\t      *f = fp->_chain;\n+\t      break;\n+\t    }\n+\t}\n+      fp->_flags &= ~_IO_LINKED;\n     }\n-    fp->_flags &= ~_IO_LINKED;\n-  }\n }\n \n void\n-DEFUN(_IO_link_in, (fp),\n-      _IO_FILE *fp)\n+_IO_link_in (fp)\n+     _IO_FILE *fp;\n {\n-    if ((fp->_flags & _IO_LINKED) == 0) {\n+    if ((fp->_flags & _IO_LINKED) == 0)\n+      {\n \tfp->_flags |= _IO_LINKED;\n \tfp->_chain = _IO_list_all;\n \t_IO_list_all = fp;\n-    }\n+      }\n }\n \n /* Return minimum _pos markers\n    Assumes the current get area is the main get area. */\n+static _IO_size_t _IO_least_marker __P ((_IO_FILE *fp));\n \n-_IO_size_t\n-DEFUN(_IO_least_marker, (fp),\n-      register _IO_FILE *fp)\n+static _IO_size_t\n+_IO_least_marker (fp)\n+     _IO_FILE *fp;\n {\n   _IO_ssize_t least_so_far = fp->_IO_read_end - fp->_IO_read_base;\n-  register struct _IO_marker *mark;\n+  struct _IO_marker *mark;\n   for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n     if (mark->_pos < least_so_far)\n       least_so_far = mark->_pos;\n@@ -75,41 +81,51 @@ DEFUN(_IO_least_marker, (fp),\n /* Switch current get area from backup buffer to (start of) main get area. */\n \n void\n-DEFUN(_IO_switch_to_main_get_area, (fp),\n-      _IO_FILE *fp)\n+_IO_switch_to_main_get_area (fp)\n+     _IO_FILE *fp;\n {\n   char *tmp;\n   fp->_flags &= ~_IO_IN_BACKUP;\n   /* Swap _IO_read_end and _IO_save_end. */\n-  tmp = fp->_IO_read_end; fp->_IO_read_end= fp->_IO_save_end; fp->_IO_save_end= tmp;\n+  tmp = fp->_IO_read_end;\n+  fp->_IO_read_end = fp->_IO_save_end;\n+  fp->_IO_save_end= tmp;\n   /* Swap _IO_read_base and _IO_save_base. */\n-  tmp = fp->_IO_read_base; fp->_IO_read_base = fp->_IO_save_base; fp->_IO_save_base = tmp;\n+  tmp = fp->_IO_read_base;\n+  fp->_IO_read_base = fp->_IO_save_base;\n+  fp->_IO_save_base = tmp;\n+\n   fp->_IO_read_ptr = fp->_IO_read_base;\n }\n \n /* Switch current get area from main get area to (end of) backup area. */\n \n void\n-DEFUN(_IO_switch_to_backup_area, (fp),\n-     register _IO_FILE *fp)\n+_IO_switch_to_backup_area (fp)\n+     _IO_FILE *fp;\n {\n   char *tmp;\n   fp->_flags |= _IO_IN_BACKUP;\n   /* Swap _IO_read_end and _IO_save_end. */\n-  tmp = fp->_IO_read_end; fp->_IO_read_end = fp->_IO_save_end; fp->_IO_save_end = tmp;\n+  tmp = fp->_IO_read_end;\n+  fp->_IO_read_end = fp->_IO_save_end;\n+  fp->_IO_save_end = tmp;\n   /* Swap _gbase and _IO_save_base. */\n-  tmp = fp->_IO_read_base; fp->_IO_read_base = fp->_IO_save_base; fp->_IO_save_base = tmp;\n+  tmp = fp->_IO_read_base;\n+  fp->_IO_read_base = fp->_IO_save_base;\n+  fp->_IO_save_base = tmp;\n+\n   fp->_IO_read_ptr = fp->_IO_read_end;\n }\n \n int\n-DEFUN(_IO_switch_to_get_mode, (fp),\n-     register _IO_FILE *fp)\n+_IO_switch_to_get_mode (fp)\n+     _IO_FILE *fp;\n {\n   if (fp->_IO_write_ptr > fp->_IO_write_base)\n     if (_IO_OVERFLOW (fp, EOF) == EOF)\n       return EOF;\n-  if (_IO_in_backup(fp))\n+  if (_IO_in_backup (fp))\n     fp->_IO_read_base = fp->_IO_backup_base;\n   else\n     {\n@@ -126,11 +142,11 @@ DEFUN(_IO_switch_to_get_mode, (fp),\n }\n \n void\n-DEFUN(_IO_free_backup_area, (fp),\n-     register _IO_FILE *fp)\n+_IO_free_backup_area (fp)\n+     _IO_FILE *fp;\n {\n   if (_IO_in_backup (fp))\n-    _IO_switch_to_main_get_area(fp);  /* Just in case. */\n+    _IO_switch_to_main_get_area (fp);  /* Just in case. */\n   free (fp->_IO_save_base);\n   fp->_IO_save_base = NULL;\n   fp->_IO_save_end = NULL;\n@@ -139,13 +155,14 @@ DEFUN(_IO_free_backup_area, (fp),\n \n #if 0\n int\n-DEFUN(_IO_switch_to_put_mode, (fp),\n-      register _IO_FILE *fp)\n+_IO_switch_to_put_mode (fp)\n+     _IO_FILE *fp;\n {\n   fp->_IO_write_base = fp->_IO_read_ptr;\n   fp->_IO_write_ptr = fp->_IO_read_ptr;\n   /* Following is wrong if line- or un-buffered? */\n-  fp->_IO_write_end = fp->_flags & _IO_IN_BACKUP ? fp->_IO_read_end : fp->_IO_buf_end;\n+  fp->_IO_write_end = (fp->_flags & _IO_IN_BACKUP\n+\t\t       ? fp->_IO_read_end : fp->_IO_buf_end);\n \n   fp->_IO_read_ptr = fp->_IO_read_end;\n   fp->_IO_read_base = fp->_IO_read_end;\n@@ -156,18 +173,21 @@ DEFUN(_IO_switch_to_put_mode, (fp),\n #endif\n \n int\n-DEFUN(__overflow, (f, ch),\n-      _IO_FILE *f AND int ch)\n+__overflow (f, ch)\n+     _IO_FILE *f;\n+     int ch;\n {\n   return _IO_OVERFLOW (f, ch);\n }\n \n-static int\n-DEFUN(save_for_backup, (fp),\n-      _IO_FILE *fp)\n+static int save_for_backup __P ((_IO_FILE *fp));\n+\n+     static int\n+save_for_backup (fp)\n+     _IO_FILE *fp;\n {\n   /* Append [_IO_read_base.._IO_read_end] to backup area. */\n-  int least_mark = _IO_least_marker(fp);\n+  int least_mark = _IO_least_marker (fp);\n   /* needed_size is how much space we need in the backup area. */\n   int needed_size = (fp->_IO_read_end - fp->_IO_read_base) - least_mark;\n   int current_Bsize = fp->_IO_save_end - fp->_IO_save_base;\n@@ -178,22 +198,22 @@ DEFUN(save_for_backup, (fp),\n     {\n       char *new_buffer;\n       avail = 100;\n-      new_buffer = (char*)malloc(avail+needed_size);\n+      new_buffer = (char *) malloc (avail + needed_size);\n       if (new_buffer == NULL)\n \treturn EOF;\t\t/* FIXME */\n       if (least_mark < 0)\n \t{\n-\t  memcpy(new_buffer + avail,\n-\t\t fp->_IO_save_end + least_mark,\n-\t\t -least_mark);\n-\t  memcpy(new_buffer +avail - least_mark,\n-\t\t fp->_IO_read_base,\n-\t\t fp->_IO_read_end - fp->_IO_read_base);\n+\t  memcpy (new_buffer + avail,\n+\t\t  fp->_IO_save_end + least_mark,\n+\t\t  -least_mark);\n+\t  memcpy (new_buffer + avail - least_mark,\n+\t\t  fp->_IO_read_base,\n+\t\t  fp->_IO_read_end - fp->_IO_read_base);\n \t}\n       else\n-\tmemcpy(new_buffer + avail,\n-\t       fp->_IO_read_base + least_mark,\n-\t       needed_size);\n+\tmemcpy (new_buffer + avail,\n+\t\tfp->_IO_read_base + least_mark,\n+\t\tneeded_size);\n       if (fp->_IO_save_base)\n \tfree (fp->_IO_save_base);\n       fp->_IO_save_base = new_buffer;\n@@ -204,17 +224,17 @@ DEFUN(save_for_backup, (fp),\n       avail = current_Bsize - needed_size;\n       if (least_mark < 0)\n \t{\n-\t  memmove(fp->_IO_save_base + avail,\n-\t\t  fp->_IO_save_end + least_mark,\n-\t\t  -least_mark);\n-\t  memcpy(fp->_IO_save_base + avail - least_mark,\n-\t\t fp->_IO_read_base,\n-\t\t fp->_IO_read_end - fp->_IO_read_base);\n+\t  memmove (fp->_IO_save_base + avail,\n+\t\t   fp->_IO_save_end + least_mark,\n+\t\t   -least_mark);\n+\t  memcpy (fp->_IO_save_base + avail - least_mark,\n+\t\t  fp->_IO_read_base,\n+\t\t  fp->_IO_read_end - fp->_IO_read_base);\n \t}\n       else if (needed_size > 0)\n-\tmemcpy(fp->_IO_save_base + avail,\n-\t       fp->_IO_read_base + least_mark,\n-\t       needed_size);\n+\tmemcpy (fp->_IO_save_base + avail,\n+\t\tfp->_IO_read_base + least_mark,\n+\t\tneeded_size);\n     }\n   /* FIXME: Dubious arithmetic if pointers are NULL */\n   fp->_IO_backup_base = fp->_IO_save_base + avail;\n@@ -226,59 +246,64 @@ DEFUN(save_for_backup, (fp),\n }\n \n int\n-DEFUN(__underflow, (fp),\n-      _IO_FILE *fp)\n+__underflow (fp)\n+     _IO_FILE *fp;\n {\n-  if (_IO_in_put_mode(fp))\n-    if (_IO_switch_to_get_mode(fp) == EOF) return EOF;\n+  if (_IO_in_put_mode (fp))\n+    if (_IO_switch_to_get_mode (fp) == EOF)\n+      return EOF;\n   if (fp->_IO_read_ptr < fp->_IO_read_end)\n-    return *(unsigned char*)fp->_IO_read_ptr;\n-  if (_IO_in_backup(fp))\n+    return *(unsigned char *) fp->_IO_read_ptr;\n+  if (_IO_in_backup (fp))\n     {\n-      _IO_switch_to_main_get_area(fp);\n+      _IO_switch_to_main_get_area (fp);\n       if (fp->_IO_read_ptr < fp->_IO_read_end)\n \treturn *fp->_IO_read_ptr;\n     }\n-  if (_IO_have_markers(fp))\n+  if (_IO_have_markers (fp))\n     {\n       if (save_for_backup (fp))\n \treturn EOF;\n     }\n-  else if (_IO_have_backup(fp))\n-    _IO_free_backup_area(fp);\n+  else if (_IO_have_backup (fp))\n+    _IO_free_backup_area (fp);\n   return _IO_UNDERFLOW (fp);\n }\n \n int\n-DEFUN(__uflow, (fp),\n-     _IO_FILE *fp)\n+__uflow (fp)\n+     _IO_FILE *fp;\n {\n-  if (_IO_in_put_mode(fp))\n-    if (_IO_switch_to_get_mode(fp) == EOF) return EOF;\n+  if (_IO_in_put_mode (fp))\n+    if (_IO_switch_to_get_mode (fp) == EOF)\n+      return EOF;\n   if (fp->_IO_read_ptr < fp->_IO_read_end)\n-    return *(unsigned char*)fp->_IO_read_ptr++;\n-  if (_IO_in_backup(fp))\n+    return *(unsigned char *) fp->_IO_read_ptr++;\n+  if (_IO_in_backup (fp))\n     {\n-      _IO_switch_to_main_get_area(fp);\n+      _IO_switch_to_main_get_area (fp);\n       if (fp->_IO_read_ptr < fp->_IO_read_end)\n \treturn *fp->_IO_read_ptr++;\n     }\n-  if (_IO_have_markers(fp))\n+  if (_IO_have_markers (fp))\n     {\n       if (save_for_backup (fp))\n \treturn EOF;\n     }\n-  else if (_IO_have_backup(fp))\n-    _IO_free_backup_area(fp);\n+  else if (_IO_have_backup (fp))\n+    _IO_free_backup_area (fp);\n   return _IO_UFLOW (fp);\n }\n \n void\n-DEFUN(_IO_setb, (f, b, eb, a),\n-      _IO_FILE *f AND char *b AND char *eb AND int a)\n+_IO_setb (f, b, eb, a)\n+     _IO_FILE *f;\n+      char *b;\n+     char *eb;\n+     int a;\n {\n   if (f->_IO_buf_base && !(f->_flags & _IO_USER_BUF))\n-    FREE_BUF(f->_IO_buf_base);\n+    FREE_BUF (f->_IO_buf_base, _IO_blen (f));\n   f->_IO_buf_base = b;\n   f->_IO_buf_end = eb;\n   if (a)\n@@ -288,166 +313,184 @@ DEFUN(_IO_setb, (f, b, eb, a),\n }\n \n void\n-DEFUN(_IO_doallocbuf, (fp),\n-      register _IO_FILE *fp)\n+_IO_doallocbuf (fp)\n+     _IO_FILE *fp;\n {\n   if (fp->_IO_buf_base)\n     return;\n   if (!(fp->_flags & _IO_UNBUFFERED))\n     if (_IO_DOALLOCATE (fp) != EOF)\n       return;\n-  _IO_setb(fp, fp->_shortbuf, fp->_shortbuf+1, 0);\n+  _IO_setb (fp, fp->_shortbuf, fp->_shortbuf+1, 0);\n }\n \n int\n-DEFUN(_IO_default_underflow, (fp),\n-      _IO_FILE *fp)\n+_IO_default_underflow (fp)\n+     _IO_FILE *fp;\n {\n   return EOF;\n }\n \n int\n-DEFUN(_IO_default_uflow, (fp),\n-      _IO_FILE *fp)\n+_IO_default_uflow (fp)\n+     _IO_FILE *fp;\n {\n   int ch = _IO_UNDERFLOW (fp);\n   if (ch == EOF)\n     return EOF;\n-  return *(unsigned char*)fp->_IO_read_ptr++;\n+  return *(unsigned char *) fp->_IO_read_ptr++;\n }\n \n _IO_size_t\n-DEFUN(_IO_default_xsputn, (f, data, n),\n-      register _IO_FILE *f AND const void *data AND _IO_size_t n)\n+_IO_default_xsputn (f, data, n)\n+     _IO_FILE *f;\n+     const void *data;\n+     _IO_size_t n;\n {\n-  register const char *s = (char*) data;\n-  register _IO_size_t more = n;\n+  const char *s = (char *) data;\n+  _IO_size_t more = n;\n   if (more <= 0)\n     return 0;\n   for (;;)\n     {\n-      _IO_ssize_t count = f->_IO_write_end - f->_IO_write_ptr; /* Space available. */\n+      /* Space available. */\n+      _IO_ssize_t count = f->_IO_write_end - f->_IO_write_ptr;\n       if (count > 0)\n \t{\n-\t  if (count > more)\n+\t  if ((_IO_size_t) count > more)\n \t    count = more;\n \t  if (count > 20)\n \t    {\n-\t      memcpy(f->_IO_write_ptr, s, count);\n+\t      memcpy (f->_IO_write_ptr, s, count);\n \t      s += count;\n \t      f->_IO_write_ptr += count;\n             }\n \t  else if (count <= 0)\n \t    count = 0;\n \t  else\n \t    {\n-\t      register char *p = f->_IO_write_ptr;\n-\t      register _IO_ssize_t i;\n-\t      for (i = count; --i >= 0; ) *p++ = *s++;\n+\t      char *p = f->_IO_write_ptr;\n+\t      _IO_ssize_t i;\n+\t      for (i = count; --i >= 0; )\n+\t\t*p++ = *s++;\n \t      f->_IO_write_ptr = p;\n             }\n \t  more -= count;\n         }\n-      if (more == 0 || __overflow(f, (unsigned char)*s++) == EOF)\n+      if (more == 0 || __overflow (f, (unsigned char) *s++) == EOF)\n \tbreak;\n       more--;\n     }\n   return n - more;\n }\n \n _IO_size_t\n-DEFUN(_IO_sgetn, (fp, data, n),\n-      _IO_FILE *fp AND void *data AND _IO_size_t n)\n+_IO_sgetn (fp, data, n)\n+     _IO_FILE *fp;\n+     void *data;\n+     _IO_size_t n;\n {\n   /* FIXME handle putback buffer here! */\n   return _IO_XSGETN (fp, data, n);\n }\n \n _IO_size_t\n-DEFUN(_IO_default_xsgetn, (fp, data, n),\n-      _IO_FILE *fp AND void *data AND _IO_size_t n)\n+_IO_default_xsgetn (fp, data, n)\n+     _IO_FILE *fp;\n+     void *data;\n+     _IO_size_t n;\n {\n-  register _IO_size_t more = n;\n-  register char *s = (char*) data;\n+  _IO_size_t more = n;\n+  char *s = (char*) data;\n   for (;;)\n     {\n-      _IO_ssize_t count = fp->_IO_read_end - fp->_IO_read_ptr; /* Data available. */\n+      /* Data available. */\n+      _IO_ssize_t count = fp->_IO_read_end - fp->_IO_read_ptr;\n       if (count > 0)\n \t{\n-\t  if (count > more)\n+\t  if ((_IO_size_t) count > more)\n \t    count = more;\n \t  if (count > 20)\n \t    {\n-\t      memcpy(s, fp->_IO_read_ptr, count);\n+\t      memcpy (s, fp->_IO_read_ptr, count);\n \t      s += count;\n \t      fp->_IO_read_ptr += count;\n \t    }\n \t  else if (count <= 0)\n \t    count = 0;\n \t  else\n \t    {\n-\t      register char *p = fp->_IO_read_ptr;\n-\t      register int i = (int)count;\n-\t      while (--i >= 0) *s++ = *p++;\n+\t      char *p = fp->_IO_read_ptr;\n+\t      int i = (int) count;\n+\t      while (--i >= 0)\n+\t\t*s++ = *p++;\n \t      fp->_IO_read_ptr = p;\n             }\n             more -= count;\n         }\n-      if (more == 0 || __underflow(fp) == EOF)\n+      if (more == 0 || __underflow (fp) == EOF)\n \tbreak;\n     }\n   return n - more;\n }\n \n+#if 0\n+/* Seems not to be needed. --drepper */\n int\n-DEFUN(_IO_sync, (fp),\n-      register _IO_FILE *fp)\n+_IO_sync (fp)\n+     _IO_FILE *fp;\n {\n   return 0;\n }\n+#endif\n \n-_IO_FILE*\n-DEFUN(_IO_default_setbuf, (fp, p, len),\n-      register _IO_FILE *fp AND char* p AND _IO_ssize_t len)\n+_IO_FILE *\n+_IO_default_setbuf (fp, p, len)\n+     _IO_FILE *fp;\n+     char *p;\n+     _IO_ssize_t len;\n {\n     if (_IO_SYNC (fp) == EOF)\n \treturn NULL;\n     if (p == NULL || len == 0)\n       {\n \tfp->_flags |= _IO_UNBUFFERED;\n-\t_IO_setb(fp, fp->_shortbuf, fp->_shortbuf+1, 0);\n+\t_IO_setb (fp, fp->_shortbuf, fp->_shortbuf+1, 0);\n       }\n     else\n       {\n \tfp->_flags &= ~_IO_UNBUFFERED;\n-\t_IO_setb(fp, p, p+len, 0);\n+\t_IO_setb (fp, p, p+len, 0);\n       }\n     fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end = 0;\n     fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_read_end = 0;\n     return fp;\n }\n \n _IO_pos_t\n-DEFUN(_IO_default_seekpos, (fp, pos, mode),\n-      _IO_FILE *fp AND _IO_pos_t pos AND int mode)\n+_IO_default_seekpos (fp, pos, mode)\n+     _IO_FILE *fp;\n+     _IO_pos_t pos;\n+     int mode;\n {\n-  return _IO_SEEKOFF (fp, _IO_pos_as_off(pos), 0, mode);\n+  return _IO_SEEKOFF (fp, _IO_pos_as_off (pos), 0, mode);\n }\n \n int\n-DEFUN(_IO_default_doallocate, (fp),\n-      _IO_FILE *fp)\n+_IO_default_doallocate (fp)\n+     _IO_FILE *fp;\n {\n-  char *buf = ALLOC_BUF(_IO_BUFSIZ);\n-  if (buf == NULL)\n-    return EOF;\n-  _IO_setb(fp, buf, buf+_IO_BUFSIZ, 1);\n+  char *buf;\n+\n+  ALLOC_BUF (buf, _IO_BUFSIZ, EOF);\n+  _IO_setb (fp, buf, buf+_IO_BUFSIZ, 1);\n   return 1;\n }\n \n void\n-DEFUN(_IO_init, (fp, flags),\n-      register _IO_FILE *fp AND int flags)\n+_IO_init (fp, flags)\n+     _IO_FILE *fp;\n+     int flags;\n {\n   fp->_flags = _IO_MAGIC|flags;\n   fp->_IO_buf_base = NULL;\n@@ -465,11 +508,14 @@ DEFUN(_IO_init, (fp, flags),\n   fp->_IO_save_end = NULL;\n   fp->_markers = NULL;\n   fp->_cur_column = 0;\n+#ifdef _IO_MTSAFE_IO\n+  _IO_lock_init (*fp->_lock);\n+#endif\n }\n \n int\n-DEFUN(_IO_default_sync, (fp),\n-      _IO_FILE *fp)\n+_IO_default_sync (fp)\n+     _IO_FILE *fp;\n {\n   return 0;\n }\n@@ -478,13 +524,14 @@ DEFUN(_IO_default_sync, (fp),\n    current implementation, this function can get called twice! */\n \n void\n-DEFUN(_IO_default_finish, (fp),\n-      _IO_FILE *fp)\n+_IO_default_finish (fp, dummy)\n+     _IO_FILE *fp;\n+     int dummy;\n {\n   struct _IO_marker *mark;\n   if (fp->_IO_buf_base && !(fp->_flags & _IO_USER_BUF))\n     {\n-      FREE_BUF(fp->_IO_buf_base);\n+      FREE_BUF (fp->_IO_buf_base, _IO_blen (fp));\n       fp->_IO_buf_base = fp->_IO_buf_end = NULL;\n     }\n \n@@ -497,27 +544,35 @@ DEFUN(_IO_default_finish, (fp),\n       fp->_IO_save_base = NULL;\n     }\n \n-  _IO_un_link(fp);\n+#ifdef _IO_MTSAFE_IO\n+  _IO_lock_fini (*fp->_lock);\n+#endif\n+\n+  _IO_un_link (fp);\n }\n \n _IO_pos_t\n-DEFUN(_IO_default_seekoff, (fp, offset, dir, mode),\n-      register _IO_FILE *fp AND _IO_off_t offset AND int dir AND int mode)\n+_IO_default_seekoff (fp, offset, dir, mode)\n+     _IO_FILE *fp;\n+     _IO_off_t offset;\n+     int dir;\n+     int mode;\n {\n     return _IO_pos_BAD;\n }\n \n int\n-DEFUN(_IO_sputbackc, (fp, c),\n-      register _IO_FILE *fp AND int c)\n+_IO_sputbackc (fp, c)\n+     _IO_FILE *fp;\n+     int c;\n {\n   int result;\n-  \n+\n   if (fp->_IO_read_ptr > fp->_IO_read_base\n       && (unsigned char)fp->_IO_read_ptr[-1] == (unsigned char)c)\n     {\n       fp->_IO_read_ptr--;\n-      result = (unsigned char)c;\n+      result = (unsigned char) c;\n     }\n   else\n     result = _IO_PBACKFAIL (fp, c);\n@@ -529,15 +584,15 @@ DEFUN(_IO_sputbackc, (fp, c),\n }\n \n int\n-DEFUN(_IO_sungetc, (fp),\n-      register _IO_FILE *fp)\n+_IO_sungetc (fp)\n+     _IO_FILE *fp;\n {\n   int result;\n-  \n+\n   if (fp->_IO_read_ptr > fp->_IO_read_base)\n     {\n       fp->_IO_read_ptr--;\n-      result = (unsigned char)*fp->_IO_read_ptr;\n+      result = (unsigned char) *fp->_IO_read_ptr;\n     }\n   else\n     result = _IO_PBACKFAIL (fp, EOF);\n@@ -549,9 +604,12 @@ DEFUN(_IO_sungetc, (fp),\n }\n \n #if 0 /* Work in progress */\n+/* Seems not to be needed.  */\n+#if 0\n void\n-DEFUN(_IO_set_column, (fp, c),\n-      register _IO_FILE *fp AND int c)\n+_IO_set_column (fp, c)\n+     _IO_FILE *fp;\n+     int c;\n {\n   if (c == -1)\n     fp->_column = -1;\n@@ -560,39 +618,46 @@ DEFUN(_IO_set_column, (fp, c),\n }\n #else\n int\n-DEFUN(_IO_set_column, (fp, i),\n-      register _IO_FILE *fp AND int i)\n+_IO_set_column (fp, i)\n+     _IO_FILE *fp;\n+     int i;\n {\n-  fp->_cur_column = i+1;\n+  fp->_cur_column = i + 1;\n   return 0;\n }\n #endif\n+#endif\n \n \n unsigned\n-DEFUN(_IO_adjust_column, (start, line, count),\n-      unsigned start AND const char *line AND int count)\n+_IO_adjust_column (start, line, count)\n+     unsigned start;\n+     const char *line;\n+     int count;\n {\n-  register const char *ptr = line + count;\n+  const char *ptr = line + count;\n   while (ptr > line)\n     if (*--ptr == '\\n')\n       return line + count - ptr - 1;\n   return start + count;\n }\n \n+#if 0\n+/* Seems not to be needed. --drepper */\n int\n-DEFUN(_IO_get_column, (fp),\n-      register _IO_FILE *fp)\n+_IO_get_column (fp)\n+     _IO_FILE *fp;\n {\n-  if (fp->_cur_column) \n-    return _IO_adjust_column(fp->_cur_column - 1,\n+  if (fp->_cur_column)\n+    return _IO_adjust_column (fp->_cur_column - 1,\n \t\t\t      fp->_IO_write_base,\n \t\t\t      fp->_IO_write_ptr - fp->_IO_write_base);\n   return -1;\n }\n+#endif\n \n int\n-DEFUN_VOID(_IO_flush_all)\n+_IO_flush_all ()\n {\n   int result = 0;\n   _IO_FILE *fp;\n@@ -604,16 +669,18 @@ DEFUN_VOID(_IO_flush_all)\n }\n \n void\n-DEFUN_VOID(_IO_flush_all_linebuffered)\n+_IO_flush_all_linebuffered ()\n {\n   _IO_FILE *fp;\n   for (fp = _IO_list_all; fp != NULL; fp = fp->_chain)\n-    if (fp->_flags & _IO_LINE_BUF)\n+    if ((fp->_flags & _IO_NO_WRITES) == 0 && fp->_flags & _IO_LINE_BUF)\n       _IO_OVERFLOW (fp, EOF);\n }\n \n-void\n-DEFUN_VOID(_IO_unbuffer_all)\n+static void _IO_unbuffer_all __P ((void));\n+\n+static void\n+_IO_unbuffer_all ()\n {\n   _IO_FILE *fp;\n   for (fp = _IO_list_all; fp != NULL; fp = fp->_chain)\n@@ -622,43 +689,44 @@ DEFUN_VOID(_IO_unbuffer_all)\n }\n \n void\n-DEFUN_VOID(_IO_cleanup)\n+_IO_cleanup ()\n {\n   _IO_flush_all ();\n \n   /* We currently don't have a reliable mechanism for making sure that\n      C++ static destructors are executed in the correct order.\n-     So it is possible that other static destructord might want to\n+     So it is possible that other static destructors might want to\n      write to cout - and they're supposed to be able to do so.\n \n-     The following will make the standard streambufs be unbuffered, \n+     The following will make the standard streambufs be unbuffered,\n      which forces any output from late destructors to be written out. */\n   _IO_unbuffer_all ();\n }\n \n void\n-DEFUN(_IO_init_marker, (marker, fp),\n-      struct _IO_marker *marker AND _IO_FILE *fp)\n+_IO_init_marker (marker, fp)\n+     struct _IO_marker *marker;\n+     _IO_FILE *fp;\n {\n   marker->_sbuf = fp;\n-  if (_IO_in_put_mode(fp))\n-    _IO_switch_to_get_mode(fp);\n-  if (_IO_in_backup(fp))\n+  if (_IO_in_put_mode (fp))\n+    _IO_switch_to_get_mode (fp);\n+  if (_IO_in_backup (fp))\n     marker->_pos = fp->_IO_read_ptr - fp->_IO_read_end;\n   else\n     marker->_pos = fp->_IO_read_ptr - fp->_IO_read_base;\n-  \n+\n   /* Should perhaps sort the chain? */\n   marker->_next = fp->_markers;\n   fp->_markers = marker;\n }\n \n void\n-DEFUN(_IO_remove_marker, (marker),\n-      register struct _IO_marker *marker)\n+_IO_remove_marker (marker)\n+     struct _IO_marker *marker;\n {\n   /* Unlink from sb's chain. */\n-  register struct _IO_marker **ptr = &marker->_sbuf->_markers;\n+  struct _IO_marker **ptr = &marker->_sbuf->_markers;\n   for (; ; ptr = &(*ptr)->_next)\n     {\n       if (*ptr == NULL)\n@@ -678,157 +746,173 @@ DEFUN(_IO_remove_marker, (marker),\n #define BAD_DELTA EOF\n \n int\n-DEFUN(_IO_marker_difference, (mark1, mark2),\n-      struct _IO_marker *mark1 AND struct _IO_marker *mark2)\n+_IO_marker_difference (mark1, mark2)\n+     struct _IO_marker *mark1;\n+     struct _IO_marker *mark2;\n {\n   return mark1->_pos - mark2->_pos;\n }\n \n-/* Return difference between MARK and current posistion of MARK's stream. */\n+/* Return difference between MARK and current position of MARK's stream. */\n int\n-DEFUN(_IO_marker_delta, (mark),\n-      struct _IO_marker *mark)\n+_IO_marker_delta (mark)\n+     struct _IO_marker *mark;\n {\n   int cur_pos;\n   if (mark->_sbuf == NULL)\n     return BAD_DELTA;\n-  if (_IO_in_backup(mark->_sbuf))\n+  if (_IO_in_backup (mark->_sbuf))\n     cur_pos = mark->_sbuf->_IO_read_ptr - mark->_sbuf->_IO_read_end;\n   else\n     cur_pos = mark->_sbuf->_IO_read_ptr - mark->_sbuf->_IO_read_base;\n   return mark->_pos - cur_pos;\n }\n \n int\n-DEFUN(_IO_seekmark, (fp, mark, delta),\n-      _IO_FILE *fp AND struct _IO_marker *mark AND int delta)\n+_IO_seekmark (fp, mark, delta)\n+     _IO_FILE *fp;\n+     struct _IO_marker *mark;\n+     int delta;\n {\n   if (mark->_sbuf != fp)\n     return EOF;\n  if (mark->_pos >= 0)\n     {\n-      if (_IO_in_backup(fp))\n-\t_IO_switch_to_main_get_area(fp);\n+      if (_IO_in_backup (fp))\n+\t_IO_switch_to_main_get_area (fp);\n       fp->_IO_read_ptr = fp->_IO_read_base + mark->_pos;\n     }\n   else\n     {\n-      if (!_IO_in_backup(fp))\n-\t_IO_switch_to_backup_area(fp);\n+      if (!_IO_in_backup (fp))\n+\t_IO_switch_to_backup_area (fp);\n       fp->_IO_read_ptr = fp->_IO_read_end + mark->_pos;\n     }\n   return 0;\n }\n \n void\n-DEFUN(_IO_unsave_markers, (fp),\n-     register _IO_FILE *fp)\n+_IO_unsave_markers (fp)\n+     _IO_FILE *fp;\n {\n-  register struct _IO_marker *mark = fp->_markers;\n+  struct _IO_marker *mark = fp->_markers;\n   if (mark)\n     {\n #ifdef TODO\n-      streampos offset = seekoff(0, ios::cur, ios::in);\n+      streampos offset = seekoff (0, ios::cur, ios::in);\n       if (offset != EOF)\n \t{\n-\t  offset += eGptr() - Gbase();\n+\t  offset += eGptr () - Gbase ();\n \t  for ( ; mark != NULL; mark = mark->_next)\n-\t    mark->set_streampos(mark->_pos + offset);\n+\t    mark->set_streampos (mark->_pos + offset);\n \t}\n     else\n       {\n \tfor ( ; mark != NULL; mark = mark->_next)\n-\t  mark->set_streampos(EOF);\n+\t  mark->set_streampos (EOF);\n       }\n #endif\n       fp->_markers = 0;\n     }\n \n-  if (_IO_have_backup(fp))\n-    _IO_free_backup_area(fp);\n+  if (_IO_have_backup (fp))\n+    _IO_free_backup_area (fp);\n }\n \n+#if 0\n+/* Seems not to be needed. --drepper */\n int\n-DEFUN(_IO_nobackup_pbackfail, (fp, c),\n-     register _IO_FILE *fp AND int c)\n+_IO_nobackup_pbackfail (fp, c)\n+     _IO_FILE *fp;\n+     int c;\n {\n   if (fp->_IO_read_ptr > fp->_IO_read_base)\n \tfp->_IO_read_ptr--;\n   if (c != EOF && *fp->_IO_read_ptr != c)\n       *fp->_IO_read_ptr = c;\n-  return (unsigned char)c;\n+  return (unsigned char) c;\n }\n+#endif\n \n int\n-DEFUN(_IO_default_pbackfail, (fp, c),\n-      register _IO_FILE *fp AND int c)\n+_IO_default_pbackfail (fp, c)\n+     _IO_FILE *fp;\n+     int c;\n {\n   if (fp->_IO_read_ptr <= fp->_IO_read_base)\n-      {\n-\t/* Need to handle a filebuf in write mode (switch to read mode). FIXME!*/\n-\tif (_IO_have_backup(fp) && !_IO_in_backup(fp))\n-\t  _IO_switch_to_backup_area(fp);\n-\t\n-\tif (!_IO_have_backup(fp))\n-\t  {\n-\t    /* No backup buffer: allocate one. */\n-\t    /* Use nshort buffer, if unused? (probably not)  FIXME */\n-\t    int backup_size = 128;\n-\t    char *bbuf = (char*)malloc(backup_size);\n-\t    if (bbuf == NULL)\n-\t      return EOF;\n-\t    fp->_IO_save_base = bbuf;\n-\t    fp->_IO_save_end = fp->_IO_save_base + backup_size;\n-\t    fp->_IO_backup_base = fp->_IO_save_end;\n-\t    _IO_switch_to_backup_area(fp);\n-\t  }\n-\telse if (fp->_IO_read_ptr <= fp->_IO_read_base)\n-\t  {\n-\t    /* Increase size of existing backup buffer. */\n-\t    _IO_size_t new_size;\n-\t    _IO_size_t old_size = fp->_IO_read_end - fp->_IO_read_base;\n-\t    char *new_buf;\n-\t    new_size = 2 * old_size;\n-\t    new_buf = (char*)malloc(new_size);\n-\t    if (new_buf == NULL)\n-\t      return EOF;\n-\t    memcpy(new_buf+(new_size-old_size), fp->_IO_read_base, old_size);\n-\t    free (fp->_IO_read_base);\n-\t    _IO_setg(fp,\n-\t\t     new_buf, new_buf+(new_size-old_size), new_buf+new_size);\n-\t    fp->_IO_backup_base = fp->_IO_read_ptr;\n-\t  }\n-      }\n-  fp->_IO_read_ptr--;\n+    {\n+      /* Need to handle a filebuf in write mode (switch to read mode). FIXME!*/\n+      if (_IO_have_backup (fp) && !_IO_in_backup (fp))\n+\t_IO_switch_to_backup_area (fp);\n+\n+      if (!_IO_have_backup (fp))\n+\t{\n+\t  /* No backup buffer: allocate one. */\n+\t  /* Use nshort buffer, if unused? (probably not)  FIXME */\n+\t  int backup_size = 128;\n+\t  char *bbuf = (char *) malloc (backup_size);\n+\t  if (bbuf == NULL)\n+\t    return EOF;\n+\t  fp->_IO_save_base = bbuf;\n+\t  fp->_IO_save_end = fp->_IO_save_base + backup_size;\n+\t  fp->_IO_backup_base = fp->_IO_save_end;\n+\t  _IO_switch_to_backup_area (fp);\n+\t}\n+      else if (fp->_IO_read_ptr <= fp->_IO_read_base)\n+\t{\n+\t  /* Increase size of existing backup buffer. */\n+\t  _IO_size_t new_size;\n+\t  _IO_size_t old_size = fp->_IO_read_end - fp->_IO_read_base;\n+\t  char *new_buf;\n+\t  new_size = 2 * old_size;\n+\t  new_buf = (char *) malloc (new_size);\n+\t  if (new_buf == NULL)\n+\t    return EOF;\n+\t  memcpy (new_buf + (new_size - old_size), fp->_IO_read_base,\n+\t\t  old_size);\n+\t  free (fp->_IO_read_base);\n+\t  _IO_setg (fp, new_buf, new_buf + (new_size - old_size),\n+\t\t    new_buf + new_size);\n+\t  fp->_IO_backup_base = fp->_IO_read_ptr;\n+\t}\n+    }\n+  --fp->_IO_read_ptr;\n   if (c != EOF && *fp->_IO_read_ptr != c)\n     *fp->_IO_read_ptr = c;\n-  return (unsigned char)*fp->_IO_read_ptr;\n+  return (unsigned char) *fp->_IO_read_ptr;\n }\n \n _IO_pos_t\n-DEFUN(_IO_default_seek, (fp, offset, dir),\n-      _IO_FILE *fp AND _IO_off_t offset AND int dir)\n+_IO_default_seek (fp, offset, dir)\n+     _IO_FILE *fp;\n+     _IO_off_t offset;\n+     int dir;\n {\n   return _IO_pos_BAD;\n }\n \n int\n-DEFUN(_IO_default_stat, (fp, st),\n-      _IO_FILE *fp AND void* st)\n+_IO_default_stat (fp, st)\n+     _IO_FILE *fp;\n+     void* st;\n {\n   return EOF;\n }\n \n _IO_ssize_t\n-DEFUN(_IO_default_read, (fp, data, n),\n-      register _IO_FILE* fp AND void* data AND _IO_ssize_t n)\n+_IO_default_read (fp, data, n)\n+     _IO_FILE* fp;\n+     void *data;\n+     _IO_ssize_t n;\n {\n   return -1;\n }\n \n _IO_ssize_t\n-DEFUN(_IO_default_write, (fp, data, n),\n-      register _IO_FILE* fp AND const void* data AND _IO_ssize_t n)\n+_IO_default_write (fp, data, n)\n+     _IO_FILE *fp;\n+     const void *data;\n+     _IO_ssize_t n;\n {\n   return 0;\n }\n@@ -844,9 +928,17 @@ DEFUN(_IO_default_write, (fp, data, n),\n #else\n struct __io_defs {\n     __io_defs() { }\n-    ~__io_defs() { _IO_cleanup(); }\n-};   \n+    ~__io_defs() { _IO_cleanup (); }\n+};\n __io_defs io_defs__;\n #endif\n \n #endif /* TODO */\n+\n+#ifdef weak_alias\n+weak_alias (_IO_cleanup, _cleanup)\n+#endif\n+\n+#ifdef text_set_element\n+text_set_element(__libc_atexit, _cleanup);\n+#endif"}, {"sha": "42dc21883360a87978adc317913a83ec8255fb54", "filename": "libio/include/empty.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Finclude%2Fempty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Finclude%2Fempty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Finclude%2Fempty.h?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -0,0 +1 @@\n+/* this will be used later*/"}, {"sha": "35f4a8b56916a724a4a09cd4c1fbc03457d7313a", "filename": "libio/iofclose.c", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofclose.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofclose.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofclose.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,47 +1,58 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+/* Copyright (C) 1993, 1995, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n #ifdef __STDC__\n #include <stdlib.h>\n #endif\n \n int\n-DEFUN(_IO_fclose, (fp),\n-      register _IO_FILE *fp)\n+_IO_fclose (fp)\n+     _IO_FILE *fp;\n {\n   int status;\n+\n   CHECK_FILE(fp, EOF);\n+\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n   if (fp->_IO_file_flags & _IO_IS_FILEBUF)\n-    status = _IO_file_close_it(fp);\n+    status = _IO_file_close_it (fp);\n   else\n     status = fp->_flags & _IO_ERR_SEEN ? -1 : 0;\n   _IO_FINISH (fp);\n+  _IO_cleanup_region_end (1);\n   if (fp != _IO_stdin && fp != _IO_stdout && fp != _IO_stderr)\n     {\n       fp->_IO_file_flags = 0;\n       free(fp);\n     }\n+\n   return status;\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_fclose, fclose)\n+#endif"}, {"sha": "841e7032b803218d1ed94896755146dea4eb8628", "filename": "libio/iofdopen.c", "status": "modified", "additions": 56, "deletions": 43, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofdopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofdopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofdopen.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,26 +1,27 @@\n-/* \n-Copyright (C) 1993, 1994 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+/* Copyright (C) 1993, 1994, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #ifdef __STDC__\n #include <stdlib.h>\n@@ -33,12 +34,19 @@ the executable file might be covered by the GNU General Public License. */\n #endif\n \n _IO_FILE *\n-DEFUN(_IO_fdopen, (fd, mode),\n-      int fd AND const char *mode)\n+_IO_fdopen (fd, mode)\n+     int fd;\n+     const char *mode;\n {\n   int read_write;\n   int posix_mode = 0;\n-  struct _IO_FILE_plus *fp;\n+  struct locked_FILE\n+  {\n+    struct _IO_FILE_plus fp;\n+#ifdef _IO_MTSAFE_IO\n+    _IO_lock_t lock;\n+#endif\n+  } *new_f;\n   int fd_flags;\n \n   switch (*mode++)\n@@ -54,9 +62,7 @@ DEFUN(_IO_fdopen, (fd, mode),\n       read_write = _IO_NO_READS|_IO_IS_APPENDING;\n       break;\n     default:\n-#ifdef EINVAL\n-      errno = EINVAL;\n-#endif\n+      MAYBE_SET_EINVAL;\n       return NULL;\n   }\n   if (mode[0] == '+' || (mode[0] == 'b' && mode[1] == '+'))\n@@ -96,26 +102,33 @@ DEFUN(_IO_fdopen, (fd, mode),\n     }\n #endif\n \n-  fp = (struct _IO_FILE_plus*)malloc(sizeof(struct _IO_FILE_plus));\n-  if (fp == NULL)\n+  new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));\n+  if (new_f == NULL)\n     return NULL;\n-  _IO_init(&fp->file, 0);\n-  _IO_JUMPS(&fp->file) = &_IO_file_jumps;\n-  _IO_file_init(&fp->file);\n+#ifdef _IO_MTSAFE_IO\n+  new_f->fp.file._lock = &new_f->lock;\n+#endif\n+  _IO_init (&new_f->fp.file, 0);\n+  _IO_JUMPS (&new_f->fp.file) = &_IO_file_jumps;\n+  _IO_file_init (&new_f->fp.file);\n #if  !_IO_UNIFIED_JUMPTABLES\n-  fp->vtable = NULL;\n+  new_f->fp.vtable = NULL;\n #endif\n-  if (_IO_file_attach(&fp->file, fd) == NULL)\n+  if (_IO_file_attach (&new_f->fp.file, fd) == NULL)\n     {\n-      _IO_un_link(&fp->file);\n-      free (fp);\n+      _IO_un_link (&new_f->fp.file);\n+      free (new_f);\n       return NULL;\n     }\n-  fp->file._flags &= ~_IO_DELETE_DONT_CLOSE;\n+  new_f->fp.file._flags &= ~_IO_DELETE_DONT_CLOSE;\n \n-  fp->file._IO_file_flags = \n-    _IO_mask_flags(&fp->file, read_write,\n-\t\t   _IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);\n+  new_f->fp.file._IO_file_flags =\n+    _IO_mask_flags (&new_f->fp.file, read_write,\n+\t\t    _IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);\n \n-  return (_IO_FILE*)fp;\n+  return (_IO_FILE *) &new_f->fp;\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_fdopen, fdopen)\n+#endif"}, {"sha": "d06de044fba5f8b36e5a0ab17e826dc05de336f2", "filename": "libio/iofeof.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofeof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofeof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofeof.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -0,0 +1,43 @@\n+/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+#include \"libioP.h\"\n+#include \"stdio.h\"\n+\n+int\n+_IO_feof (fp)\n+     _IO_FILE* fp;\n+{\n+  int result;\n+  CHECK_FILE (fp, EOF);\n+  _IO_flockfile (fp);\n+  result = _IO_feof_unlocked (fp);\n+  _IO_funlockfile (fp);\n+  return result;\n+}\n+\n+#ifdef weak_alias\n+weak_alias (_IO_feof, feof)\n+#endif"}, {"sha": "855627ade66d987e08c3acf905918751bad23b8e", "filename": "libio/ioferror.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fioferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fioferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioferror.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -0,0 +1,43 @@\n+/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+#include \"libioP.h\"\n+#include \"stdio.h\"\n+\n+int\n+_IO_ferror (fp)\n+     _IO_FILE* fp;\n+{\n+  int result;\n+  CHECK_FILE (fp, EOF);\n+  _IO_flockfile (fp);\n+  result = _IO_ferror_unlocked (fp);\n+  _IO_funlockfile (fp);\n+  return result;\n+}\n+\n+#ifdef weak_alias\n+weak_alias (_IO_ferror, ferror)\n+#endif"}, {"sha": "540c99d535ee8c72551240133121a2f88828a7ef", "filename": "libio/iofflush.c", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofflush.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofflush.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofflush.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,38 +1,49 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n+#include <stdio.h>\n \n int\n-DEFUN(_IO_fflush, (fp),\n-      register _IO_FILE *fp)\n+_IO_fflush (fp)\n+     _IO_FILE *fp;\n {\n   if (fp == NULL)\n-    return _IO_flush_all();\n+    return _IO_flush_all ();\n   else\n     {\n-      CHECK_FILE(fp, EOF);\n-      return _IO_SYNC (fp) ? EOF : 0;\n+      int result;\n+      CHECK_FILE (fp, EOF);\n+      _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+      _IO_flockfile (fp);\n+      result = _IO_SYNC (fp) ? EOF : 0;\n+      _IO_cleanup_region_end (1);\n+      return result;\n     }\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_fflush, fflush)\n+#endif"}, {"sha": "b46ae4a3f94948cdaa5a940fc0d2b9c54a197ed9", "filename": "libio/iofflush_u.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofflush_u.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofflush_u.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofflush_u.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+#include \"libioP.h\"\n+#include <stdio.h>\n+\n+int\n+fflush_unlocked (fp)\n+     _IO_FILE *fp;\n+{\n+  if (fp == NULL)\n+    return _IO_flush_all ();\n+  else\n+    {\n+      CHECK_FILE (fp, EOF);\n+      return _IO_SYNC (fp) ? EOF : 0;\n+    }\n+}"}, {"sha": "716be4bca107b19e151f2c802dbc2b7d8322350a", "filename": "libio/iofgetpos.c", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofgetpos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofgetpos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofgetpos.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,46 +1,55 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n #include <errno.h>\n-/* ANSI explicily requires setting errno to a positive value on failure. */\n+/* ANSI explicitly requires setting errno to a positive value on failure. */\n \n int\n-DEFUN(_IO_fgetpos, (fp, posp),\n-      _IO_FILE* fp AND _IO_fpos_t *posp)\n+_IO_fgetpos (fp, posp)\n+     _IO_FILE* fp;\n+     _IO_fpos_t *posp;\n {\n   _IO_fpos_t pos;\n-  CHECK_FILE(fp, EOF);\n-  pos = _IO_seekoff(fp, 0, _IO_seek_cur, 0);\n+  CHECK_FILE (fp, EOF);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+  pos = _IO_seekoff (fp, 0, _IO_seek_cur, 0);\n+  _IO_cleanup_region_end (1);\n   if (pos == _IO_pos_BAD)\n     {\n #ifdef EIO\n       if (errno == 0)\n-\terrno = EIO;\n+\t__set_errno (EIO);\n #endif\n       return EOF;\n     }\n   *posp = pos;\n   return 0;\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_fgetpos, fgetpos)\n+#endif"}, {"sha": "74754d5d1ea811e84b2a4794e385114e3f2f556d", "filename": "libio/iofgets.c", "status": "modified", "additions": 43, "deletions": 27, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofgets.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofgets.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofgets.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,40 +1,56 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n+#include <stdio.h>\n \n-char*\n-DEFUN(_IO_fgets, (buf, n, fp),\n-      char* buf AND int n AND _IO_FILE* fp)\n+char *\n+_IO_fgets (buf, n, fp)\n+     char *buf;\n+     int n;\n+     _IO_FILE *fp;\n {\n   _IO_size_t count;\n-  CHECK_FILE(fp, NULL);\n+  char *result;\n+  CHECK_FILE (fp, NULL);\n   if (n <= 0)\n     return NULL;\n-  count = _IO_getline(fp, buf, n - 1, '\\n', 1);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+  count = _IO_getline (fp, buf, n - 1, '\\n', 1);\n   if (count == 0 || (fp->_IO_file_flags & _IO_ERR_SEEN))\n-    return NULL;\n-  buf[count] = 0;\n-  return buf;\n+    result = NULL;\n+  else\n+    {\n+      buf[count] = '\\0';\n+      result = buf;\n+    }\n+  _IO_cleanup_region_end (1);\n+  return result;\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_fgets, fgets)\n+#endif"}, {"sha": "1dbeccb81a8fcf5c9f9c278dc691b1e7b4dac8e1", "filename": "libio/iofopen.c", "status": "modified", "additions": 51, "deletions": 36, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofopen.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,49 +1,64 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n #ifdef __STDC__\n #include <stdlib.h>\n #endif\n \n _IO_FILE *\n-DEFUN(_IO_fopen, (filename, mode),\n-      const char *filename AND const char *mode)\n+_IO_fopen (filename, mode)\n+     const char *filename;\n+     const char *mode;\n {\n-  struct _IO_FILE_plus *fp =\n-    (struct _IO_FILE_plus*)malloc(sizeof(struct _IO_FILE_plus));\n-  if (fp == NULL)\n+  struct locked_FILE\n+  {\n+    struct _IO_FILE_plus fp;\n+#ifdef _IO_MTSAFE_IO\n+    _IO_lock_t lock;\n+#endif\n+  } *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));\n+\n+  if (new_f == NULL)\n     return NULL;\n-  _IO_init(&fp->file, 0);\n-  _IO_JUMPS(&fp->file) = &_IO_file_jumps;\n-  _IO_file_init(&fp->file);\n+#ifdef _IO_MTSAFE_IO\n+  new_f->fp.file._lock = &new_f->lock;\n+#endif\n+  _IO_init (&new_f->fp.file, 0);\n+  _IO_JUMPS (&new_f->fp.file) = &_IO_file_jumps;\n+  _IO_file_init (&new_f->fp.file);\n #if  !_IO_UNIFIED_JUMPTABLES\n-  fp->vtable = NULL;\n+  new_f->fp.vtable = NULL;\n #endif\n-  if (_IO_file_fopen(&fp->file, filename, mode) != NULL)\n-        return (_IO_FILE*)fp;\n-  _IO_un_link(&fp->file);\n-  free (fp);\n+  if (_IO_file_fopen (&new_f->fp.file, filename, mode) != NULL)\n+        return (_IO_FILE *) &new_f->fp;\n+  _IO_un_link (&new_f->fp.file);\n+  free (new_f);\n   return NULL;\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_fopen, fopen)\n+#endif"}, {"sha": "4dc9d3f6617e9b0be62ff531208eab664e03b591", "filename": "libio/iofprintf.c", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofprintf.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,26 +1,27 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n \n@@ -31,18 +32,20 @@ the executable file might be covered by the GNU General Public License. */\n #endif\n \n int\n-_IO_fprintf\n #ifdef __STDC__\n-  (_IO_FILE *fp, const char* format, ...)\n+_IO_fprintf (_IO_FILE *fp, const char* format, ...)\n #else\n-(fp, format, va_alist) _IO_FILE *fp; char *format; va_dcl\n+_IO_fprintf (fp, format, va_alist)\n+     _IO_FILE *fp;\n+     char *format;\n+     va_dcl\n #endif\n {\n   int ret;\n   va_list args;\n-  CHECK_FILE(fp, -1);\n-  _IO_va_start(args, format);\n-  ret = _IO_vfprintf(fp, format, args);\n-  va_end(args);\n+  CHECK_FILE (fp, -1);\n+  _IO_va_start (args, format);\n+  ret = _IO_vfprintf (fp, format, args);\n+  va_end (args);\n   return ret;\n }"}, {"sha": "1a329bbe26fc20b5c7f3a872c1af2381437880ee", "filename": "libio/iofputs.c", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofputs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofputs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofputs.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,37 +1,49 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n #include <string.h>\n \n int\n-DEFUN(_IO_fputs, (str, fp),\n-      const char *str AND _IO_FILE *fp)\n+_IO_fputs (str, fp)\n+      const char *str;\n+      _IO_FILE *fp;\n {\n-  _IO_size_t len = strlen(str);\n-  CHECK_FILE(fp, EOF);\n-  if (_IO_sputn(fp, str, len) != len)\n-    return EOF;\n-  return 1;\n+  _IO_size_t len = strlen (str);\n+  int result;\n+  CHECK_FILE (fp, EOF);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+  if (_IO_sputn (fp, str, len) != len)\n+    result = EOF;\n+  else\n+    result = 1;\n+  _IO_cleanup_region_end (1);\n+  return result;\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_fputs, fputs)\n+#endif"}, {"sha": "c83d2b638c97d99fee08538d368521c897e5aac5", "filename": "libio/iofread.c", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofread.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,38 +1,49 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1995, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n \n _IO_size_t\n-DEFUN(_IO_fread, (buf, size, count, fp),\n-      void *buf AND _IO_size_t size AND _IO_size_t count AND _IO_FILE* fp)\n+_IO_fread (buf, size, count, fp)\n+     void *buf;\n+     _IO_size_t size;\n+     _IO_size_t count;\n+     _IO_FILE *fp;\n {\n   _IO_size_t bytes_requested = size*count;\n   _IO_size_t bytes_read;\n-  CHECK_FILE(fp, 0);\n+  CHECK_FILE (fp, 0);\n   if (bytes_requested == 0)\n     return 0;\n-  bytes_read = _IO_sgetn(fp, (char *)buf, bytes_requested);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);\n+  _IO_cleanup_region_end (1);\n   return bytes_requested == bytes_read ? count : bytes_read / size;\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_fread, fread)\n+#endif"}, {"sha": "a8d816f5a393a549393c62b267ec729f9685e99b", "filename": "libio/iofsetpos.c", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofsetpos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofsetpos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofsetpos.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,43 +1,56 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1995, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include <libioP.h>\n #include <errno.h>\n \n int\n-DEFUN(_IO_fsetpos, (fp, posp),\n-      _IO_FILE* fp AND const _IO_fpos_t *posp)\n+_IO_fsetpos (fp, posp)\n+     _IO_FILE *fp;\n+     const _IO_fpos_t *posp;\n {\n-  CHECK_FILE(fp, EOF);\n-  if (_IO_seekpos(fp, *posp, _IOS_INPUT|_IOS_OUTPUT) == _IO_pos_BAD)\n+  int result;\n+  CHECK_FILE (fp, EOF);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+  if (_IO_seekpos (fp, *posp, _IOS_INPUT|_IOS_OUTPUT) == _IO_pos_BAD)\n     {\n-      /*ANSI explicily requires setting errno to a positive value on failure.*/\n+      /* ANSI explicitly requires setting errno to a positive value on\n+\t failure.  */\n #ifdef EIO\n       if (errno == 0)\n-\terrno = EIO;\n+\t__set_errno (EIO);\n #endif\n-      return EOF;\n+      result = EOF;\n     }\n-  return 0;\n+  else\n+    result = 0;\n+  _IO_cleanup_region_end (1);\n+  return result;\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_fsetpos, fsetpos)\n+#endif"}, {"sha": "d8a1ce1d24239a66e5e2937beb10cca59456f1d9", "filename": "libio/ioftell.c", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fioftell.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fioftell.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioftell.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,45 +1,53 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n #include <errno.h>\n /* ANSI explicily requires setting errno to a positive value on failure. */\n \n long int\n-DEFUN(_IO_ftell, (fp),\n-      _IO_FILE* fp)\n+_IO_ftell (fp)\n+     _IO_FILE *fp;\n {\n   _IO_pos_t pos;\n-  CHECK_FILE(fp, -1L);\n-  pos = _IO_seekoff(fp, 0, _IO_seek_cur, 0);\n+  CHECK_FILE (fp, -1L);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+  pos = _IO_seekoff (fp, 0, _IO_seek_cur, 0);\n+  _IO_cleanup_region_end (1);\n   if (pos == _IO_pos_BAD)\n     {\n #ifdef EIO\n       if (errno == 0)\n-\terrno = EIO;\n+\t__set_errno (EIO);\n #endif\n       return -1L;\n     }\n-  return _IO_pos_as_off(pos);\n+  return _IO_pos_as_off (pos);\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_ftell, ftell)\n+#endif"}, {"sha": "5bc525ffc704d6c4d5cd3cd4074f2f3edbf1b676", "filename": "libio/iofwrite.c", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiofwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiofwrite.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,44 +1,54 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n \n _IO_size_t\n-DEFUN(_IO_fwrite, (buf, size, count, fp),\n-      const void* buf AND _IO_size_t size AND _IO_size_t count\n-      AND _IO_FILE *fp)\n+_IO_fwrite (buf, size, count, fp)\n+     const void *buf;\n+     _IO_size_t size;\n+     _IO_size_t count;\n+     _IO_FILE *fp;\n {\n-  _IO_size_t request = size*count;\n+  _IO_size_t request = size * count;\n   _IO_size_t written;\n-  CHECK_FILE(fp, 0);\n+  CHECK_FILE (fp, 0);\n   if (request == 0)\n     return 0;\n-  written = _IO_sputn(fp, (const char *)buf, request);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+  written = _IO_sputn (fp, (const char *) buf, request);\n+  _IO_cleanup_region_end (1);\n   /* Many traditional implementations return 0 if size==0 && count > 0,\n-     but ANSI seems to require us to return count in this case. */\n+     but ANSI requires us to return count in this case. */\n   if (written == request)\n     return count;\n   else\n-    return written/size;\n+    return written / size;\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_fwrite, fwrite)\n+#endif"}, {"sha": "f7465f1914b1da51e49052819289426007d003c8", "filename": "libio/iogetc.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiogetc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiogetc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiogetc.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -0,0 +1,48 @@\n+/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+#include \"libioP.h\"\n+#include \"stdio.h\"\n+\n+#undef _IO_getc\n+\n+int\n+_IO_getc (fp)\n+     _IO_FILE *fp;\n+{\n+  int result;\n+  CHECK_FILE (fp, EOF);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+  result = _IO_getc_unlocked (fp);\n+  _IO_cleanup_region_end (1);\n+  return result;\n+}\n+\n+#undef getc\n+\n+#ifdef weak_alias\n+weak_alias (_IO_getc, getc)\n+#endif"}, {"sha": "50918b3e8dcc1e3ebc95d49acad6b80c11d9f69c", "filename": "libio/iogetdelim.c", "status": "modified", "additions": 59, "deletions": 33, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiogetdelim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiogetdelim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiogetdelim.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,26 +1,27 @@\n-/* \n-Copyright (C) 1994 Free Software Foundation\n+/* Copyright (C) 1994, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #ifdef __STDC__\n #include <stdlib.h>\n@@ -36,36 +37,49 @@ the executable file might be covered by the GNU General Public License. */\n    null terminator), or -1 on error or EOF.  */\n \n _IO_ssize_t\n-DEFUN(_IO_getdelim, (lineptr, n, delimiter, fp),\n-      char **lineptr AND _IO_size_t *n AND int delimiter AND _IO_FILE *fp)\n+_IO_getdelim (lineptr, n, delimiter, fp)\n+     char **lineptr;\n+     _IO_size_t *n;\n+     int delimiter;\n+     _IO_FILE *fp;\n {\n-  register _IO_ssize_t cur_len = 0;\n+  int result;\n+  _IO_ssize_t cur_len = 0;\n   _IO_ssize_t len;\n \n   if (lineptr == NULL || n == NULL)\n     {\n-#ifdef EINVAL\n-      errno = EINVAL;\n-#endif\n+      MAYBE_SET_EINVAL;\n       return -1;\n     }\n   CHECK_FILE (fp, -1);\n-  if (_IO_ferror (fp))\n-    return -1;\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+  if (_IO_ferror_unlocked (fp))\n+    {\n+      result = -1;\n+      goto unlock_return;\n+    }\n \n   if (*lineptr == NULL || *n == 0)\n     {\n       *n = 120;\n       *lineptr = (char *) malloc (*n);\n       if (*lineptr == NULL)\n-\treturn -1;\n+\t{\n+\t  result = -1;\n+\t  goto unlock_return;\n+\t}\n     }\n \n   len = fp->_IO_read_end - fp->_IO_read_ptr;\n   if (len <= 0)\n     {\n       if (__underflow (fp) == EOF)\n-\treturn -1;\n+\t{\n+\t  result = -1;\n+\t  goto unlock_return;\n+\t}\n       len = fp->_IO_read_end - fp->_IO_read_ptr;\n     }\n \n@@ -76,16 +90,19 @@ DEFUN(_IO_getdelim, (lineptr, n, delimiter, fp),\n       t = (char *) memchr ((void *) fp->_IO_read_ptr, delimiter, len);\n       if (t != NULL)\n \tlen = (t - fp->_IO_read_ptr) + 1;\n-      /* make enough space for len+1 (for final NUL) bytes. */\n+      /* Make enough space for len+1 (for final NUL) bytes.  */\n       needed = cur_len + len + 1;\n       if (needed > *n)\n \t{\n-\t  if (t == NULL && needed < 2 * *n)\n+\t  if (needed < 2 * *n)\n \t    needed = 2 * *n;  /* Be generous. */\n \t  *n = needed;\n \t  *lineptr = (char *) realloc (*lineptr, needed);\n \t  if (*lineptr == NULL)\n-\t    return -1;\n+\t    {\n+\t      result = -1;\n+\t      goto unlock_return;\n+\t    }\n \t}\n       memcpy (*lineptr + cur_len, (void *) fp->_IO_read_ptr, len);\n       fp->_IO_read_ptr += len;\n@@ -95,5 +112,14 @@ DEFUN(_IO_getdelim, (lineptr, n, delimiter, fp),\n       len = fp->_IO_read_end - fp->_IO_read_ptr;\n     }\n   (*lineptr)[cur_len] = '\\0';\n-  return cur_len;\n+  result = cur_len;\n+\n+unlock_return:\n+  _IO_cleanup_region_end (1);\n+  return result;\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_getdelim, __getdelim)\n+weak_alias (_IO_getdelim, getdelim)\n+#endif"}, {"sha": "bd1a7431f362349b6be064b186896af71c1d1832", "filename": "libio/iogetline.c", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiogetline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiogetline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiogetline.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,26 +1,27 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n #include <string.h>\n@@ -34,38 +35,41 @@ the executable file might be covered by the GNU General Public License. */\n    If extract_delim > 0, insert delim in output. */\n \n _IO_size_t\n-DEFUN(_IO_getline, (fp, buf, n, delim, extract_delim),\n-      _IO_FILE *fp AND char* buf AND _IO_size_t n\n-      AND int delim AND int extract_delim)\n+_IO_getline (fp, buf, n, delim, extract_delim)\n+     _IO_FILE *fp;\n+     char *buf;\n+     _IO_size_t n;\n+     int delim;\n+     int extract_delim;\n {\n-  register char *ptr = buf;\n+  char *ptr = buf;\n   do\n     {\n       _IO_ssize_t len = fp->_IO_read_end - fp->_IO_read_ptr;\n       char *t;\n       if (len <= 0)\n-\tif (__underflow(fp) == EOF)\n+\tif (__underflow (fp) == EOF)\n \t  break;\n \telse\n \t  len = fp->_IO_read_end - fp->_IO_read_ptr;\n-      if (len >= n)\n+      if ((_IO_size_t) len >= n)\n \tlen = n;\n-      t = (char*)memchr((void*)fp->_IO_read_ptr, delim, len);\n+      t = (char *) memchr ((void *) fp->_IO_read_ptr, delim, len);\n       if (t != NULL)\n \t{\n \t  _IO_size_t old_len = ptr-buf;\n \t  len = t - fp->_IO_read_ptr;\n \t  if (extract_delim >= 0)\n \t    {\n-\t      t++;\n+\t      ++t;\n \t      if (extract_delim > 0)\n-\t\tlen++;\n+\t\t++len;\n \t    }\n-\t  memcpy((void*)ptr, (void*)fp->_IO_read_ptr, len);\n+\t  memcpy ((void *) ptr, (void *) fp->_IO_read_ptr, len);\n \t  fp->_IO_read_ptr = t;\n \t  return old_len + len;\n \t}\n-      memcpy((void*)ptr, (void*)fp->_IO_read_ptr, len);\n+      memcpy ((void *) ptr, (void *) fp->_IO_read_ptr, len);\n       fp->_IO_read_ptr += len;\n       ptr += len;\n       n -= len;"}, {"sha": "9e88ca1037ae55c70fd7b08fa748a1f43396356e", "filename": "libio/iogets.c", "status": "modified", "additions": 55, "deletions": 31, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiogets.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiogets.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiogets.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,47 +1,71 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n #include <limits.h>\n \n char*\n-DEFUN(_IO_gets, (buf),\n-      char* buf)\n+_IO_gets (buf)\n+     char *buf;\n {\n   _IO_size_t count;\n-  int ch = _IO_getc (_IO_stdin);\n+  int ch;\n+  char *retval;\n+\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t    _IO_stdin);\n+  _IO_flockfile (_IO_stdin);\n+  ch = _IO_getc_unlocked (_IO_stdin);\n   if (ch == EOF)\n-    return NULL;\n+    {\n+      retval = NULL;\n+      goto unlock_return;\n+    }\n   if (ch == '\\n')\n     count = 0;\n   else\n     {\n-      buf[0] = (char)ch;\n-      count = _IO_getline(_IO_stdin, buf + 1, INT_MAX, '\\n', 0) + 1;\n+      buf[0] = (char) ch;\n+      count = _IO_getline (_IO_stdin, buf + 1, INT_MAX, '\\n', 0) + 1;\n       if (_IO_stdin->_IO_file_flags & _IO_ERR_SEEN)\n-\treturn NULL;\n+\t{\n+\t  retval = NULL;\n+\t  goto unlock_return;\n+\t}\n     }\n   buf[count] = 0;\n-  return buf;\n+  retval = buf;\n+unlock_return:\n+  _IO_cleanup_region_end (1);\n+  return retval;\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_gets, gets)\n+#endif\n+\n+#ifdef _LIBC\n+link_warning (gets, \"the `gets' function is dangerous and should not be used.\")\n+#endif"}, {"sha": "087715b349b8a4aed5850749f8395ff43eb6a538", "filename": "libio/iopadn.c", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiopadn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiopadn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiopadn.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,26 +1,27 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n \n@@ -31,34 +32,38 @@ static char const zeroes[PADSIZE] =\n {'0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0'};\n \n _IO_ssize_t\n-DEFUN(_IO_padn, (fp, pad, count),\n-      _IO_FILE *fp AND int pad AND _IO_ssize_t count)\n+_IO_padn (fp, pad, count)\n+      _IO_FILE *fp;\n+      int pad;\n+      _IO_ssize_t count;\n {\n   char padbuf[PADSIZE];\n   const char *padptr;\n-  register int i;\n-  _IO_size_t written = 0, w;\n-  \n+  int i;\n+  _IO_size_t written = 0;\n+  _IO_size_t w;\n+\n   if (pad == ' ')\n     padptr = blanks;\n   else if (pad == '0')\n     padptr = zeroes;\n   else\n     {\n-      for (i = PADSIZE; --i >= 0; ) padbuf[i] = pad;\n+      for (i = PADSIZE; --i >= 0; )\n+\tpadbuf[i] = pad;\n       padptr = padbuf;\n     }\n   for (i = count; i >= PADSIZE; i -= PADSIZE)\n     {\n-      w = _IO_sputn(fp, padptr, PADSIZE);\n+      w = _IO_sputn (fp, padptr, PADSIZE);\n       written += w;\n       if (w != PADSIZE)\n \treturn written;\n     }\n-      \n+\n   if (i > 0)\n     {\n-      w = _IO_sputn(fp, padptr, i);\n+      w = _IO_sputn (fp, padptr, i);\n       written += w;\n     }\n   return written;"}, {"sha": "434008609f476c2f161188fa58a3b3bfbd8609a7", "filename": "libio/iopopen.c", "status": "modified", "additions": 91, "deletions": 66, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiopopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiopopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiopopen.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,55 +1,60 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n-\n-/*  written by Per Bothner (bothner@cygnus.com) */\n-\n-#define _POSIX_SOURCE\n+/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+   Written by Per Bothner <bothner@cygnus.com>.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+#ifndef _POSIX_SOURCE\n+# define _POSIX_SOURCE\n+#endif\n #include \"libioP.h\"\n-#include <sys/types.h>\n #if _IO_HAVE_SYS_WAIT\n #include <signal.h>\n #include <unistd.h>\n #ifdef __STDC__\n #include <stdlib.h>\n #endif\n+#ifdef _LIBC\n+# include <unistd.h>\n+#endif\n+#include <sys/types.h>\n #include <sys/wait.h>\n \n #ifndef _IO_fork\n #define _IO_fork vfork /* defined in libiberty, if needed */\n-_IO_pid_t _IO_fork();\n+extern _IO_pid_t _IO_fork __P ((void));\n #endif\n \n #endif /* _IO_HAVE_SYS_WAIT */\n \n #ifndef _IO_pipe\n #define _IO_pipe pipe\n-extern int _IO_pipe();\n+extern int _IO_pipe __P ((int des[2]));\n #endif\n \n #ifndef _IO_dup2\n #define _IO_dup2 dup2\n-extern int _IO_dup2();\n+extern int _IO_dup2 __P ((int fd, int fd2));\n #endif\n \n #ifndef _IO_waitpid\n@@ -75,17 +80,19 @@ typedef struct _IO_proc_file _IO_proc_file;\n static struct _IO_proc_file *proc_file_chain = NULL;\n \n _IO_FILE *\n-DEFUN(_IO_proc_open, (fp, command, mode),\n-      _IO_FILE* fp AND const char *command AND const char *mode)\n+_IO_proc_open (fp, command, mode)\n+     _IO_FILE *fp;\n+     const char *command;\n+     const char *mode;\n {\n #if _IO_HAVE_SYS_WAIT\n-  int read_or_write;\n+  volatile int read_or_write;\n+  volatile int parent_end, child_end;\n   int pipe_fds[2];\n-  int parent_end, child_end;\n   _IO_pid_t child_pid;\n-  if (_IO_file_is_open(fp))\n+  if (_IO_file_is_open (fp))\n     return NULL;\n-  if (_IO_pipe(pipe_fds) < 0)\n+  if (_IO_pipe (pipe_fds) < 0)\n     return NULL;\n   if (mode[0] == 'r')\n     {\n@@ -99,17 +106,17 @@ DEFUN(_IO_proc_open, (fp, command, mode),\n       child_end = pipe_fds[0];\n       read_or_write = _IO_NO_READS;\n     }\n-  ((_IO_proc_file*)fp)->pid = child_pid = _IO_fork();\n+  ((_IO_proc_file *) fp)->pid = child_pid = _IO_fork ();\n   if (child_pid == 0)\n     {\n       int child_std_end = mode[0] == 'r' ? 1 : 0;\n-      _IO_close(parent_end);\n+      _IO_close (parent_end);\n       if (child_end != child_std_end)\n \t{\n-\t  _IO_dup2(child_end, child_std_end);\n-\t  _IO_close(child_end);\n+\t  _IO_dup2 (child_end, child_std_end);\n+\t  _IO_close (child_end);\n \t}\n-      /* Posix.2:  \"popen() shall ensure that any streams from previous\n+      /* POSIX.2:  \"popen() shall ensure that any streams from previous\n          popen() calls that remain open in the parent process are closed\n \t in the new child process.\" */\n       while (proc_file_chain)\n@@ -118,20 +125,20 @@ DEFUN(_IO_proc_open, (fp, command, mode),\n \t  proc_file_chain = proc_file_chain->next;\n \t}\n \n-      _IO_execl(\"/bin/sh\", \"sh\", \"-c\", command, (char *)0);\n-      _IO__exit(127);\n+      _IO_execl (\"/bin/sh\", \"sh\", \"-c\", command, (char *) 0);\n+      _IO__exit (127);\n     }\n-  _IO_close(child_end);\n+  _IO_close (child_end);\n   if (child_pid < 0)\n     {\n-      _IO_close(parent_end);\n+      _IO_close (parent_end);\n       return NULL;\n     }\n-  _IO_fileno(fp) = parent_end;\n+  _IO_fileno (fp) = parent_end;\n \n   /* Link into proc_file_chain. */\n-  ((_IO_proc_file*)fp)->next = proc_file_chain;\n-  proc_file_chain = (_IO_proc_file*)fp;\n+  ((_IO_proc_file *) fp)->next = proc_file_chain;\n+  proc_file_chain = (_IO_proc_file *) fp;\n \n   _IO_mask_flags (fp, read_or_write, _IO_NO_READS|_IO_NO_WRITES);\n   return fp;\n@@ -141,57 +148,75 @@ DEFUN(_IO_proc_open, (fp, command, mode),\n }\n \n _IO_FILE *\n-DEFUN(_IO_popen, (command, mode),\n-      const char *command AND const char *mode)\n+_IO_popen (command, mode)\n+     const char *command;\n+     const char *mode;\n {\n-  _IO_proc_file *fpx = (_IO_proc_file*)malloc(sizeof(_IO_proc_file));\n-  _IO_FILE *fp = (_IO_FILE*)fpx;\n-  if (fp == NULL)\n+  struct locked_FILE\n+  {\n+    struct _IO_proc_file fpx;\n+#ifdef _IO_MTSAFE_IO\n+    _IO_lock_t lock;\n+#endif\n+  } *new_f;\n+  _IO_FILE *fp;\n+\n+  new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));\n+  if (new_f == NULL)\n     return NULL;\n-  _IO_init(fp, 0);\n-  _IO_JUMPS(fp) = &_IO_proc_jumps;\n-  _IO_file_init(fp);\n+#ifdef _IO_MTSAFE_IO\n+  new_f->fpx.file.file._lock = &new_f->lock;\n+#endif\n+  fp = (_IO_FILE*)&new_f->fpx;\n+  _IO_init (fp, 0);\n+  _IO_JUMPS (fp) = &_IO_proc_jumps;\n+  _IO_file_init (fp);\n #if  !_IO_UNIFIED_JUMPTABLES\n-  ((struct _IO_FILE_plus*)fp)->vtable = NULL;\n+  ((struct _IO_FILE_plus *) fp)->vtable = NULL;\n #endif\n   if (_IO_proc_open (fp, command, mode) != NULL)\n     return fp;\n-  free (fpx);\n+  free (new_f);\n   return NULL;\n }\n \n+#ifdef strong_alias\n+strong_alias (_IO_popen, popen);\n+#endif\n+\n int\n-DEFUN(_IO_proc_close, (fp),\n-      _IO_FILE *fp)\n+_IO_proc_close (fp)\n+     _IO_FILE *fp;\n {\n   /* This is not name-space clean. FIXME! */\n #if _IO_HAVE_SYS_WAIT\n   int wstatus;\n   _IO_proc_file **ptr = &proc_file_chain;\n   _IO_pid_t wait_pid;\n   int status = -1;\n-  \n+\n   /* Unlink from proc_file_chain. */\n   for ( ; *ptr != NULL; ptr = &(*ptr)->next)\n     {\n-      if (*ptr == (_IO_proc_file*)fp)\n+      if (*ptr == (_IO_proc_file *) fp)\n \t{\n \t  *ptr = (*ptr)->next;\n \t  status = 0;\n \t  break;\n \t}\n     }\n \n-  if (status < 0 || _IO_close(_IO_fileno(fp)) < 0)\n+  if (status < 0 || _IO_close (_IO_fileno(fp)) < 0)\n     return -1;\n   /* POSIX.2 Rationale:  \"Some historical implementations either block\n      or ignore the signals SIGINT, SIGQUIT, and SIGHUP while waiting\n      for the child process to terminate.  Since this behavior is not\n      described in POSIX.2, such implementations are not conforming.\" */\n   do\n     {\n-      wait_pid = _IO_waitpid (((_IO_proc_file*)fp)->pid, &wstatus, 0);\n-    } while (wait_pid == -1 && errno == EINTR);\n+      wait_pid = _IO_waitpid (((_IO_proc_file *) fp)->pid, &wstatus, 0);\n+    }\n+  while (wait_pid == -1 && errno == EINTR);\n   if (wait_pid == -1)\n     return -1;\n   return wstatus;"}, {"sha": "3c35c365f07a53417f1473ece3f2d9ecd6d3577d", "filename": "libio/ioputc.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fioputc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fioputc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioputc.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -0,0 +1,42 @@\n+/* Copyright (C) 1991, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Library General Public License as\n+   published by the Free Software Foundation; either version 2 of the\n+   License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#include \"libioP.h\"\n+#include \"stdio.h\"\n+\n+#undef _IO_putc\n+\n+int\n+_IO_putc (c, fp)\n+     int c;\n+     _IO_FILE *fp;\n+{\n+  int result;\n+  CHECK_FILE (fp, EOF);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+  result = _IO_putc_unlocked (c, fp);\n+  _IO_cleanup_region_end (1);\n+  return result;\n+}\n+\n+#undef putc\n+\n+#ifdef weak_alias\n+weak_alias (_IO_putc, putc)\n+#endif"}, {"sha": "ab5e6aaa4cc95aa490a93828b6a40df6d4d51918", "filename": "libio/ioputs.c", "status": "modified", "additions": 38, "deletions": 27, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fioputs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fioputs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioputs.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,38 +1,49 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n #include <string.h>\n \n int\n-DEFUN(_IO_puts, (str),\n-      const char *str)\n+_IO_puts (str)\n+     const char *str;\n {\n-  _IO_size_t len = strlen(str);\n-  if (_IO_sputn(_IO_stdout, str, len) != len)\n-    return EOF;\n-  if (_IO_putc('\\n', _IO_stdout) == EOF)\n-    return EOF;\n-  return len+1;\n+  int result;\n+  _IO_size_t len = strlen (str);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t    _IO_stdout);\n+  _IO_flockfile (_IO_stdout);\n+  if (_IO_sputn (_IO_stdout, str, len) == len\n+      && _IO_putc_unlocked ('\\n', _IO_stdout) != EOF)\n+    result = len + 1;\n+  else\n+    result = EOF;\n+  _IO_cleanup_region_end (1);\n+  return result;\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_puts, puts)\n+#endif"}, {"sha": "8c642165f637aaa3e09f1f1f0fb5505e4a9fa45a", "filename": "libio/ioseekoff.c", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fioseekoff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fioseekoff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioseekoff.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,32 +1,36 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include <libioP.h>\n \n _IO_pos_t\n-DEFUN(_IO_seekoff, (fp, offset, dir, mode),\n-      _IO_FILE* fp AND _IO_off_t offset AND int dir AND int mode)\n+_IO_seekoff (fp, offset, dir, mode)\n+     _IO_FILE *fp;\n+     _IO_off_t offset;\n+     int dir;\n+     int mode;\n {\n   /* If we have a backup buffer, get rid of it, since the __seekoff\n      callback may not know to do the right thing about it."}, {"sha": "1ae88fb84823781770f2f7521c191ce4e2ba9d7f", "filename": "libio/ioseekpos.c", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fioseekpos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fioseekpos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioseekpos.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,32 +1,35 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include <libioP.h>\n \n _IO_pos_t\n-DEFUN(_IO_seekpos, (fp, pos, mode),\n-      _IO_FILE* fp AND _IO_pos_t pos AND int mode)\n+_IO_seekpos (fp, pos, mode)\n+     _IO_FILE *fp;\n+     _IO_pos_t pos;\n+     int mode;\n {\n   /* If we have a backup buffer, get rid of it, since the __seekoff\n      callback may not know to do the right thing about it."}, {"sha": "f140a9ad046eb68daabb015bdcd9754d1113bb94", "filename": "libio/iosetbuffer.c", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiosetbuffer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiosetbuffer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiosetbuffer.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,36 +1,46 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n \n void\n-DEFUN(_IO_setbuffer, (fp, buf, size),\n-      _IO_FILE *fp AND char *buf AND _IO_size_t size)\n+_IO_setbuffer (fp, buf, size)\n+     _IO_FILE *fp;\n+     char *buf;\n+     _IO_size_t size;\n {\n-  CHECK_FILE(fp, );\n+  CHECK_FILE (fp, );\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n   fp->_flags &= ~_IO_LINE_BUF;\n   if (!buf)\n     size = 0;\n   (void) _IO_SETBUF (fp, buf, size);\n+  _IO_cleanup_region_end (1);\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_setbuffer, setbuffer)\n+#endif"}, {"sha": "65eeea51a6faa6fce20eeafc4ff64b8dc069f6ab", "filename": "libio/iosetvbuf.c", "status": "modified", "additions": 49, "deletions": 27, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiosetvbuf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiosetvbuf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiosetvbuf.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,26 +1,27 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n \n@@ -29,10 +30,16 @@ the executable file might be covered by the GNU General Public License. */\n #define _IONBF 2 /* No buffering. */\n \n int\n-DEFUN(_IO_setvbuf, (fp, buf, mode, size),\n-      _IO_FILE* fp AND char* buf AND int mode AND _IO_size_t size)\n+_IO_setvbuf (fp, buf, mode, size)\n+     _IO_FILE *fp;\n+     char *buf;\n+     int mode;\n+     _IO_size_t size;\n {\n-  CHECK_FILE(fp, EOF);\n+  int result;\n+  CHECK_FILE (fp, EOF);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n   switch (mode)\n     {\n     case _IOFBF:\n@@ -55,24 +62,39 @@ DEFUN(_IO_setvbuf, (fp, buf, mode, size),\n \t\t A possibly cleaner alternative would be to add an\n \t\t extra flag, but then flags are a finite resource.  */\n \t      if (_IO_DOALLOCATE (fp) < 0)\n-\t\treturn EOF;\n+\t\t{\n+\t\t  result = EOF;\n+\t\t  goto unlock_return;\n+\t\t}\n \t      fp->_IO_file_flags &= ~_IO_LINE_BUF;\n \t    }\n-\t  return 0;\n+\t  result = 0;\n+\t  goto unlock_return;\n \t}\n       break;\n     case _IOLBF:\n       fp->_IO_file_flags &= ~_IO_UNBUFFERED;\n       fp->_IO_file_flags |= _IO_LINE_BUF;\n       if (buf == NULL)\n-\treturn 0;\n+\t{\n+\t  result = 0;\n+\t  goto unlock_return;\n+\t}\n       break;\n     case _IONBF:\n       buf = NULL;\n       size = 0;\n       break;\n     default:\n-      return EOF;\n+      result = EOF;\n+      goto unlock_return;\n     }\n-  return _IO_SETBUF (fp, buf, size) == NULL ? EOF : 0;\n+  result = _IO_SETBUF (fp, buf, size) == NULL ? EOF : 0;\n+unlock_return:\n+  _IO_cleanup_region_end (1);\n+  return result;\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_setvbuf, setvbuf)\n+#endif"}, {"sha": "704a6dbd72d949efcaa8c73f9df849bbb9f6b7c8", "filename": "libio/iosprintf.c", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiosprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiosprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiosprintf.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,26 +1,27 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n \n@@ -31,17 +32,19 @@ the executable file might be covered by the GNU General Public License. */\n #endif\n \n int\n-_IO_sprintf\n #ifdef __STDC__\n-  (char *string, const char* format, ...)\n+_IO_sprintf (char *string, const char* format, ...)\n #else\n-(string, format, va_alist) char *string; char *format; va_dcl\n+_IO_sprintf (string, format, va_alist)\n+     char *string;\n+     char *format;\n+     va_dcl\n #endif\n {\n   int ret;\n   va_list args;\n-  _IO_va_start(args, format);\n-  ret = _IO_vsprintf(string, format, args);\n-  va_end(args);\n+  _IO_va_start (args, format);\n+  ret = _IO_vsprintf (string, format, args);\n+  va_end (args);\n   return ret;\n }"}, {"sha": "a6ede4302980fec13b518c9309b4285de37f6d94", "filename": "libio/iostream.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiostream.h?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,4 +1,4 @@\n-/*  This is part of libio/iostream, providing -*- C++ -*- input/output. \n+/*  This is part of libio/iostream, providing -*- C++ -*- input/output.\n Copyright (C) 1993 Free Software Foundation\n \n This file is part of the GNU IO Library.  This library is free\n@@ -96,7 +96,11 @@ class ostream : virtual public ios\n #endif\n     ostream& operator<<(double n);\n     ostream& operator<<(float n) { return operator<<((double)n); }\n+#if _G_HAVE_LONG_DOUBLE_IO\n+    ostream& operator<<(long double n);\n+#else\n     ostream& operator<<(long double n) { return operator<<((double)n); }\n+#endif\n     ostream& operator<<(__omanip func) { return (*func)(*this); }\n     ostream& operator<<(__manip func) {(*func)(*this); return *this;}\n     ostream& operator<<(streambuf*);"}, {"sha": "07f38e747bf363e42a5183f547cba527b8b2e37b", "filename": "libio/ioungetc.c", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fioungetc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fioungetc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fioungetc.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,35 +1,46 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n \n int\n-DEFUN(_IO_ungetc, (c, fp),\n-      int c AND _IO_FILE *fp)\n+_IO_ungetc (c, fp)\n+     int c;\n+     _IO_FILE *fp;\n {\n-  CHECK_FILE(fp, EOF);\n+  int result;\n+  CHECK_FILE (fp, EOF);\n   if (c == EOF)\n     return EOF;\n-  return _IO_sputbackc(fp, (unsigned char)c);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+  result = _IO_sputbackc (fp, (unsigned char) c);\n+  _IO_cleanup_region_end (1);\n+  return result;\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_ungetc, ungetc)\n+#endif"}, {"sha": "34919588ce10083baf3cdef72596f9b59464c0be", "filename": "libio/iovsprintf.c", "status": "modified", "additions": 47, "deletions": 30, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiovsprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiovsprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiovsprintf.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,40 +1,57 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n #include \"strfile.h\"\n \n int\n-DEFUN(_IO_vsprintf, (string, format, args),\n-      char *string AND const char *format AND _IO_va_list args)\n+_IO_vsprintf (string, format, args)\n+     char *string;\n+     const char *format;\n+     _IO_va_list args;\n {\n   _IO_strfile sf;\n+#ifdef _IO_MTSAFE_IO\n+  _IO_lock_t lock;\n+#endif\n   int ret;\n-  _IO_init((_IO_FILE*)&sf, 0);\n-  _IO_JUMPS((_IO_FILE*)&sf) = &_IO_str_jumps;\n-  _IO_str_init_static ((_IO_FILE*)&sf, string, -1, string);\n-  ret = _IO_vfprintf((_IO_FILE*)&sf, format, args);\n-  _IO_putc('\\0', (_IO_FILE*)&sf);\n+\n+#ifdef _IO_MTSAFE_IO\n+  sf._sbf._f._lock = &lock;\n+#endif\n+  _IO_init (&sf._sbf._f, 0);\n+  _IO_JUMPS (&sf._sbf._f) = &_IO_str_jumps;\n+  _IO_str_init_static (&sf._sbf._f, string, -1, string);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, &sf);\n+  _IO_flockfile (&sf._sbf._f);\n+  ret = _IO_vfprintf (&sf._sbf._f, format, args);\n+  _IO_putc_unlocked ('\\0', &sf._sbf._f);\n+  _IO_cleanup_region_end (1);\n   return ret;\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_vsprintf, vsprintf)\n+#endif"}, {"sha": "21600f53efb24e917cb41be7c4c7e0b9b273b31e", "filename": "libio/iovsscanf.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiovsscanf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fiovsscanf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiovsscanf.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,37 +1,54 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n #include \"strfile.h\"\n \n int\n-DEFUN(_IO_vsscanf, (string, format, args),\n-      const char *string AND const char *format AND _IO_va_list args)\n+_IO_vsscanf (string, format, args)\n+     const char *string;\n+     const char *format;\n+     _IO_va_list args;\n {\n+  int ret;\n   _IO_strfile sf;\n-  _IO_init((_IO_FILE*)&sf, 0);\n-  _IO_JUMPS((_IO_FILE*)&sf) = &_IO_str_jumps;\n-  _IO_str_init_static ((_IO_FILE*)&sf, (char*)string, 0, NULL);\n-  return _IO_vfscanf((_IO_FILE*)&sf, format, args, NULL);\n+#ifdef _IO_MTSAFE_IO\n+  _IO_lock_t lock;\n+  sf._sbf._f._lock = &lock;\n+#endif\n+  _IO_init (&sf._sbf._f, 0);\n+  _IO_JUMPS (&sf._sbf._f) = &_IO_str_jumps;\n+  _IO_str_init_static (&sf._sbf._f, (char*)string, 0, NULL);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, &sf);\n+  _IO_flockfile (&sf._sbf._f);\n+  ret = _IO_vfscanf (&sf._sbf._f, format, args, NULL);\n+  _IO_cleanup_region_end (1);\n+  return ret;\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_vsscanf, __vsscanf)\n+weak_alias (_IO_vsscanf, vsscanf)\n+#endif"}, {"sha": "c79b623920516bf05f9fdf2c76ee884f6f8ca5b3", "filename": "libio/libio.h", "status": "modified", "additions": 61, "deletions": 10, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Flibio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Flibio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Flibio.h?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,4 +1,4 @@\n-/* \n+/*\n Copyright (C) 1991, 1992, 1993, 1994 Free Software Foundation\n \n This file is part of the GNU IO Library.  This library is free\n@@ -153,6 +153,14 @@ the executable file might be covered by the GNU General Public License. */\n \n struct _IO_jump_t;  struct _IO_FILE;\n \n+/* Handle lock.  */\n+#ifdef _IO_MTSAFE_IO\n+# include <stdio-lock.h>\n+#else\n+typedef void _IO_lock_t;\n+#endif\n+\n+\n struct _IO_marker {\n   struct _IO_marker *_next;\n   struct _IO_FILE *_sbuf;\n@@ -196,20 +204,22 @@ struct _IO_FILE {\n   char *_IO_save_end; /* Pointer to end of non-current get area. */\n \n   struct _IO_marker *_markers;\n-  \n+\n   struct _IO_FILE *_chain;\n-  \n+\n   int _fileno;\n   int _blksize;\n   _IO_off_t _offset;\n-  \n+\n #define __HAVE_COLUMN /* temporary */\n   /* 1+column number of pbase(); 0 is unknown. */\n   unsigned short _cur_column;\n   char _unused;\n   char _shortbuf[1];\n-  \n+\n   /*  char* _save_gptr;  char* _save_egptr; */\n+\n+  _IO_lock_t *_lock;\n };\n \n #ifndef __cplusplus\n@@ -222,6 +232,26 @@ extern struct _IO_FILE_plus _IO_stdin_, _IO_stdout_, _IO_stderr_;\n #define _IO_stdout ((_IO_FILE*)(&_IO_stdout_))\n #define _IO_stderr ((_IO_FILE*)(&_IO_stderr_))\n \n+\n+/* Define the user-visible type, with user-friendly member names.  */\n+typedef struct\n+{\n+  _IO_ssize_t (*read) __P ((struct _IO_FILE *, void *, _IO_ssize_t));\n+  _IO_ssize_t (*write) __P ((struct _IO_FILE *, const void *, _IO_ssize_t));\n+  _IO_fpos_t (*seek) __P ((struct _IO_FILE *, _IO_off_t, int));\n+  int (*close) __P ((struct _IO_FILE *));\n+} _IO_cookie_io_functions_t;\n+\n+/* Special file type for fopencookie function.  */\n+struct _IO_cookie_file\n+{\n+  struct _IO_FILE file;\n+  const void *vtable;\n+  void *cookie;\n+  _IO_cookie_io_functions_t io_functions;\n+};\n+\n+\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n@@ -230,26 +260,47 @@ extern int __underflow __P((_IO_FILE*));\n extern int __uflow __P((_IO_FILE*));\n extern int __overflow __P((_IO_FILE*, int));\n \n-#define _IO_getc(_fp) \\\n+#define _IO_getc_unlocked(_fp) \\\n        ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end ? __uflow(_fp) \\\n \t: *(unsigned char*)(_fp)->_IO_read_ptr++)\n-#define _IO_peekc(_fp) \\\n+#define _IO_peekc_unlocked(_fp) \\\n        ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end \\\n \t  && __underflow(_fp) == EOF ? EOF \\\n \t: *(unsigned char*)(_fp)->_IO_read_ptr)\n \n-#define _IO_putc(_ch, _fp) \\\n+#define _IO_putc_unlocked(_ch, _fp) \\\n    (((_fp)->_IO_write_ptr >= (_fp)->_IO_write_end) \\\n     ? __overflow(_fp, (unsigned char)(_ch)) \\\n     : (unsigned char)(*(_fp)->_IO_write_ptr++ = (_ch)))\n \n-#define _IO_feof(__fp) (((__fp)->_flags & _IO_EOF_SEEN) != 0)\n-#define _IO_ferror(__fp) (((__fp)->_flags & _IO_ERR_SEEN) != 0)\n+#define _IO_feof_unclocked(__fp) (((__fp)->_flags & _IO_EOF_SEEN) != 0)\n+#define _IO_ferror_unlocked(__fp) (((__fp)->_flags & _IO_ERR_SEEN) != 0)\n+\n+extern int _IO_getc __P ((_IO_FILE *__fp));\n+extern int _IO_putc __P ((int __c, _IO_FILE *__fp));\n+extern int _IO_feof __P ((_IO_FILE *__fp));\n+extern int _IO_ferror __P ((_IO_FILE *__fp));\n+\n+extern int _IO_peekc_locked __P ((_IO_FILE *__fp));\n \n /* This one is for Emacs. */\n #define _IO_PENDING_OUTPUT_COUNT(_fp)\t\\\n \t((_fp)->_IO_write_ptr - (_fp)->_IO_write_base)\n \n+extern void _IO_flockfile __P ((_IO_FILE *));\n+extern void _IO_funlockfile __P ((_IO_FILE *));\n+extern int _IO_ftrylockfile __P ((_IO_FILE *));\n+\n+#ifndef _IO_MTSAFE_IO\n+# define _IO_flockfile(_fp) /**/\n+# define _IO_funlockfile(_fp) /**/\n+# define _IO_ftrylockfile(_fp) /**/\n+# define _IO_cleanup_region_start(_fct, _fp) /**/\n+# define _IO_cleanup_region_end(_Doit) /**/\n+#endif /* !_IO_MTSAFE_IO */\n+\n+#define _IO_peekc(_fp) _IO_peekc_locked (_fp)\n+\n extern int _IO_vfscanf __P((_IO_FILE*, const char*, _IO_va_list, int*));\n extern int _IO_vfprintf __P((_IO_FILE*, const char*, _IO_va_list));\n extern _IO_ssize_t _IO_padn __P((_IO_FILE *, int, _IO_ssize_t));"}, {"sha": "ea3f36e33952b247d9a4936dc0cc694a9a1f46f7", "filename": "libio/libioP.h", "status": "modified", "additions": 100, "deletions": 31, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2FlibioP.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2FlibioP.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2FlibioP.h?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,31 +1,37 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include <errno.h>\n #ifndef errno\n extern int errno;\n #endif\n+#ifndef __set_errno\n+/* This is a GNU libc special.  Simply set errno to the  given value here.  */\n+#define __set_errno(Val) (errno = (Val))\n+#endif\n+#include <stdio-lock.h>\n \n #include \"iolibio.h\"\n \n@@ -100,8 +106,8 @@ extern \"C\" {\n /* The 'finish' function does any final cleaning up of an _IO_FILE object.\n    It does not delete (free) it, but does everything else to finalize it/\n    It matches the streambuf::~streambuf virtual destructor.  */\n-typedef void (*_IO_finish_t) __P((_IO_FILE*)); /* finalize */\n-#define _IO_FINISH(FP) JUMP0(__finish, FP)\n+typedef void (*_IO_finish_t) __P((_IO_FILE*, int)); /* finalize */\n+#define _IO_FINISH(FP) JUMP1(__finish, FP, 0)\n \n /* The 'overflow' hook flushes the buffer.\n    The second argument is a character, or EOF.\n@@ -266,6 +272,9 @@ struct _IO_FILE_plus {\n \n /* Generic functions */\n \n+extern _IO_fpos_t _IO_seekoff __P((_IO_FILE*, _IO_off_t, int, int));\n+extern _IO_fpos_t _IO_seekpos __P((_IO_FILE*, _IO_fpos_t, int));\n+\n extern int _IO_switch_to_get_mode __P((_IO_FILE*));\n extern void _IO_init __P((_IO_FILE*, int));\n extern int _IO_sputbackc __P((_IO_FILE*, int));\n@@ -291,7 +300,7 @@ extern int _IO_seekmark __P((_IO_FILE *, struct _IO_marker *, int));\n extern int _IO_default_underflow __P((_IO_FILE*));\n extern int _IO_default_uflow __P((_IO_FILE*));\n extern int _IO_default_doallocate __P((_IO_FILE*));\n-extern void _IO_default_finish __P((_IO_FILE *));\n+extern void _IO_default_finish __P((_IO_FILE *, int));\n extern int _IO_default_pbackfail __P((_IO_FILE*, int));\n extern _IO_FILE* _IO_default_setbuf __P((_IO_FILE *, char*, _IO_ssize_t));\n extern _IO_size_t _IO_default_xsputn __P((_IO_FILE *, const void*, _IO_size_t));\n@@ -347,7 +356,7 @@ extern _IO_ssize_t _IO_file_read __P((_IO_FILE*, void*, _IO_ssize_t));\n extern int _IO_file_sync __P((_IO_FILE*));\n extern int _IO_file_close_it __P((_IO_FILE*));\n extern _IO_fpos_t _IO_file_seek __P((_IO_FILE *, _IO_off_t, int));\n-extern void _IO_file_finish __P((_IO_FILE*));\n+extern void _IO_file_finish __P((_IO_FILE*, int));\n \n /* Other file functions. */\n extern _IO_FILE* _IO_file_attach __P((_IO_FILE *, int));\n@@ -361,12 +370,20 @@ extern int _IO_str_underflow __P((_IO_FILE*));\n extern int _IO_str_overflow __P((_IO_FILE *, int));\n extern int _IO_str_pbackfail __P((_IO_FILE*, int));\n extern _IO_fpos_t _IO_str_seekoff __P((_IO_FILE*,_IO_off_t,int,int));\n+extern void _IO_str_finish __P ((_IO_FILE*, int));\n \n /* Other strfile functions */\n extern void _IO_str_init_static __P((_IO_FILE *, char*, int, char*));\n extern void _IO_str_init_readonly __P((_IO_FILE *, const char*, int));\n extern _IO_ssize_t _IO_str_count __P ((_IO_FILE*));\n \n+extern int _IO_vasprintf __P ((char **result_ptr, __const char *format,\n+\t\t\t       _IO_va_list args));\n+extern int _IO_vdprintf __P ((int d, __const char *format, _IO_va_list arg));\n+extern int _IO_vsnprintf __P ((char *string, _IO_size_t maxlen,\n+\t\t\t       __const char *format, _IO_va_list args));\n+\n+\n extern _IO_size_t _IO_getline __P((_IO_FILE*,char*,_IO_size_t,int,int));\n extern _IO_ssize_t _IO_getdelim __P((char**, _IO_size_t*, int, _IO_FILE*));\n extern double _IO_strtod __P((const char *, char **));\n@@ -394,8 +411,52 @@ extern void (*_IO_cleanup_registration_needed) __P ((void));\n #endif\n #endif\n \n-#define FREE_BUF(_B) free(_B)\n-#define ALLOC_BUF(_S) (char*)malloc(_S)\n+#if _G_HAVE_MMAP\n+\n+#include <unistd.h>\n+#include <fcntl.h>\n+#include <sys/mman.h>\n+#include <sys/param.h>\n+\n+#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)\n+#define MAP_ANONYMOUS MAP_ANON\n+#endif\n+\n+#if !defined(MAP_ANONYMOUS) || !defined(EXEC_PAGESIZE)\n+#undef _G_HAVE_MMAP\n+#define _G_HAVE_MMAP 0\n+#endif\n+\n+#endif /* _G_HAVE_MMAP */\n+\n+#if _G_HAVE_MMAP\n+\n+#define ROUND_TO_PAGE(_S) \\\n+       (((_S) + EXEC_PAGESIZE - 1) & ~(EXEC_PAGESIZE - 1))\n+\n+#define FREE_BUF(_B, _S) \\\n+       munmap ((_B), ROUND_TO_PAGE (_S))\n+#define ALLOC_BUF(_B, _S, _R) \\\n+       do {\t\t\t\t\t\t\t\t      \\\n+         (_B) = (char *) mmap (0, ROUND_TO_PAGE (_S),\t\t\t      \\\n+                               PROT_READ | PROT_WRITE,\t\t\t      \\\n+                               MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\t      \\\n+         if ((_B) == (char *) -1)\t\t\t\t\t      \\\n+           return _R;\t\t\t\t\t\t\t      \\\n+       } while (0)\n+\n+#else /* _G_HAVE_MMAP */\n+\n+#define FREE_BUF(_B, _S) \\\n+       free(_B)\n+#define ALLOC_BUF(_B, _S, _R) \\\n+       do {\t\t\t\t\t\t\t\t      \\\n+         (_B) = (char*)malloc(_S);\t\t\t\t\t      \\\n+         if ((_B) == NULL)\t\t\t\t\t\t      \\\n+           return _R;\t\t\t\t\t\t\t      \\\n+       } while (0)\n+\n+#endif /* _G_HAVE_MMAP */\n \n #ifndef OS_FSTAT\n #define OS_FSTAT fstat\n@@ -433,10 +494,18 @@ extern int _IO_fstat __P((int, struct stat *));\n }\n #endif\n \n+#ifdef _IO_MTSAFE_IO\n+/* check following! */\n+#define FILEBUF_LITERAL(CHAIN, FLAGS, FD) \\\n+\t{ _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \\\n+\t  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, CHAIN, FD, \\\n+\t  0, 0, 0, 0, { 0 }, &_IO_stdfile_##FD##_lock }\n+#else\n /* check following! */\n #define FILEBUF_LITERAL(CHAIN, FLAGS, FD) \\\n        { _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \\\n          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, CHAIN, FD}\n+#endif\n \n /* VTABLE_LABEL defines NAME as of the CLASS class.\n    CNLENGTH is strlen(#CLASS).  */\n@@ -480,7 +549,7 @@ extern struct _IO_fake_stdiobuf _IO_stdin_buf, _IO_stdout_buf, _IO_stderr_buf;\n #endif\n \n #ifdef EINVAL\n-#define MAYBE_SET_EINVAL errno = EINVAL\n+#define MAYBE_SET_EINVAL __set_errno (EINVAL)\n #else\n #define MAYBE_SET_EINVAL /* nothing */\n #endif\n@@ -490,7 +559,7 @@ extern struct _IO_fake_stdiobuf _IO_stdin_buf, _IO_stdout_buf, _IO_stderr_buf;\n \tif ((FILE) == NULL) { MAYBE_SET_EINVAL; return RET; } \\\n \telse { COERCE_FILE(FILE); \\\n \t       if (((FILE)->_IO_file_flags & _IO_MAGIC_MASK) != _IO_MAGIC) \\\n-\t  { errno = EINVAL; return RET; }}\n+\t  { MAYBE_SET_EINVAL; return RET; }}\n #else\n #define CHECK_FILE(FILE,RET) \\\n \tCOERCE_FILE(FILE)"}, {"sha": "e430e602c8dcd6bbafdb4211dc1f2e4de5ecd5ef", "filename": "libio/parsestream.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fparsestream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fparsestream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fparsestream.cc?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -137,7 +137,7 @@ general_parsebuf::general_parsebuf(streambuf *buf, int delete_arg_buf)\n     delete_buf = delete_arg_buf;\n     sbuf = buf;\n     int buf_size = 128;\n-    char* buffer = ALLOC_BUF(buf_size);\n+    char* buffer = (char*)malloc(buf_size);\n     setb(buffer, buffer+buf_size, 1);\n //    setg(buffer, buffer, buffer);\n }"}, {"sha": "0b3b5140c26f7a4fb32617b9a65b6b55b405eeb3", "filename": "libio/peekc.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fpeekc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fpeekc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fpeekc.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -0,0 +1,42 @@\n+/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+#include \"libioP.h\"\n+#include \"stdio.h\"\n+\n+#undef _IO_peekc\n+\n+int\n+_IO_peekc_locked (fp)\n+     _IO_FILE *fp;\n+{\n+  int result;\n+  CHECK_FILE (fp, EOF);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+  result = _IO_peekc_unlocked (fp);\n+  _IO_cleanup_region_end (1);\n+  return result;\n+}"}, {"sha": "8453e33c34cd8a18d89eed06ad2f25f97cb30b5d", "filename": "libio/stdfiles.c", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdfiles.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,26 +1,27 @@\n-/* \n-Copyright (C) 1993, 1994 Free Software Foundation\n+/* Copyright (C) 1993, 1994, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n \n /* This file provides definitions of _IO_stdin, _IO_stdout, and _IO_stderr\n@@ -31,10 +32,16 @@ the executable file might be covered by the GNU General Public License. */\n \n #include \"libioP.h\"\n \n-\n+#ifdef _IO_MTSAFE_IO\n+#define DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \\\n+  static _IO_lock_t _IO_stdfile_##FD##_lock = _IO_lock_initializer; \\\n+  struct _IO_FILE_plus NAME \\\n+    = {FILEBUF_LITERAL(CHAIN, FLAGS, FD), &_IO_file_jumps}\n+#else\n #define DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \\\n   struct _IO_FILE_plus NAME \\\n     = {FILEBUF_LITERAL(CHAIN, FLAGS, FD), &_IO_file_jumps}\n+#endif\n \n DEF_STDFILE(_IO_stdin_, 0, 0, _IO_NO_WRITES);\n DEF_STDFILE(_IO_stdout_, 1, &_IO_stdin_.file, _IO_NO_READS);"}, {"sha": "42dc21883360a87978adc317913a83ec8255fb54", "filename": "libio/stdio-lock.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio-lock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio-lock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio-lock.h?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -0,0 +1 @@\n+/* this will be used later*/"}, {"sha": "788c055e8d15c0ee7e8aed952fae8d47d204f1be", "filename": "libio/stdio/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2FChangeLog?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,3 +1,44 @@\n+1997-09-04 16:11  Ulrich Drepper  <drepper@cygnus.com>\n+\n+\t* Makefile.in (STDIO_OBJECTS): Lose feof.o and ferror.o.  Add getc.o\n+\tand putc.o.\n+\t(stmp-libio, stmp-libiostream, stmp-io, stmp-streamlib): New rules.\n+\n+\t(iostream.list): Depend upon stmp-stdio.  Add the entries\n+\tfrom stdio.list to iostream.list.\n+\t(stmp-stdio): New name for what was the stdio/stdio.list rule.\n+\tAll it now does is cd down into stdio and build stdio.list.\n+\n+\t* clearerr.c: Add copyright and lock stream before use.\n+\t* feof.c: Likewise.\n+\t* ferror.c: Likewise.\n+\t* fgetc.c: Likewise.\n+\t* fputc.c: Likewise.\n+\t* freopen.c: Likewise.\n+\t* fseek.c: Likewise.\n+\t* getc.c: Likewise.\n+\t* getchar.c: Likewise.\n+\t* putc.c: Likewise.\n+\t* putchar.c: Likewise.\n+\t* rewind.c: Likewise.\n+\n+\t* setbuf.c: Update copyright.\n+\t* setlinebuf.c: Likewise.\n+\t* vscanf.c: Likewise.\n+\n+\t* fileno.c: Define alias fileno_unlocked.  Update copyright.\n+\n+\t* clearerr_u.c: New file.  Implement clearerr_unlocked function.\n+\t* feof_u.c: New file.  Implement feof_unlocked function.\n+\t* ferror_u.c: New file.  Implement ferror_unlocked function.\n+\t* fputc_u.c: New file.  Implement fputc_unlocked function.\n+\t* getc_u.c: New file.  Implement getc_unclocked function.\n+\t* getchar_u.c: New file.  Implement getchar_unclocked function.\n+\t* putc_u.c: New file.  Implement putc_unclocked function.\n+\t* putchar_u.c: New file.  Implement putchar_unclocked function.\n+\n+\t* vsnprintf.c: Rewrite according to ISO C 9X draft.\n+\n Thu May  1 11:03:45 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n \n \t* stdio.h (TMP_MAX): Wrap it with #ifndef for now, since it can"}, {"sha": "680c8a497a4116b7339097c75599a71dd99feaab", "filename": "libio/stdio/Makefile.in", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2FMakefile.in?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -7,9 +7,9 @@ srcdir = .\n STDIO_RENAMED_OBJECTS = ... filled in by configure ...\n # These are the files that a libc would want.\n STDIO_OBJECTS = $(STDIO_RENAMED_OBJECTS) \\\n-  clearerr.o fdopen.o feof.o ferror.o fgetc.o fileno.o \\\n-  fputc.o freopen.o fseek.o getc.o getchar.o getline.o getw.o \\\n-  popen.o putc.o putchar.o putw.o rewind.o \\\n+  clearerr.o fdopen.o fgetc.o fileno.o \\\n+  fputc.o freopen.o fseek.o getchar.o getline.o getw.o \\\n+  popen.o putchar.o putw.o rewind.o \\\n   setbuf.o setfileno.o setlinebuf.o snprintf.o \\\n   vfprintf.o vfscanf.o vprintf.o vscanf.o vsnprintf.o\n \n@@ -18,6 +18,18 @@ CINCLUDES = -I. -I$(srcdir) -I.. -I$(srcdir)/.. -D__USE_GNU\n \n nothing:\n \n+stmp-libio: stdio.list stamp-io\n+\n+stamp-io:\n+\t$(AR) $(AR_FLAGS) ../libio.a $(STDIO_OBJECTS)\n+\ttouch stmp-io\n+\n+stmp-libiostream: stdio.list stamp-streamlib\n+\n+stamp-streamlib:\n+\t$(AR) $(AR_FLAGS) ../libiostream.a $(STDIO_OBJECTS)\n+\ttouch stmp-streamlib\n+\n stdio.list: stamp-picdir $(STDIO_OBJECTS)\n \t@echo \"$(STDIO_OBJECTS)\" >stdio.list\n "}, {"sha": "4776250ff8d943b2ce7311f81a9214638ae1fde3", "filename": "libio/stdio/clearerr.c", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fclearerr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fclearerr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fclearerr.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,10 +1,30 @@\n+/* Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Library General Public License as\n+   published by the Free Software Foundation; either version 2 of the\n+   License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n #include \"libioP.h\"\n #include \"stdio.h\"\n \n void\n-clearerr(fp)\n-     FILE* fp;\n+clearerr (fp)\n+     FILE *fp;\n {\n-  CHECK_FILE(fp, /*nothing*/);\n-  _IO_clearerr(fp);\n+  CHECK_FILE (fp, /*nothing*/);\n+  _IO_flockfile (fp);\n+  _IO_clearerr (fp);\n+  _IO_funlockfile (fp);\n }"}, {"sha": "2a1ba7070bb77f995e9b35a8307a373405a74da7", "filename": "libio/stdio/clearerr_u.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fclearerr_u.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fclearerr_u.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fclearerr_u.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -0,0 +1,28 @@\n+/* Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Library General Public License as\n+   published by the Free Software Foundation; either version 2 of the\n+   License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#include \"libioP.h\"\n+#include \"stdio.h\"\n+\n+void\n+clearerr_unlocked (fp)\n+     FILE *fp;\n+{\n+  CHECK_FILE (fp, /*nothing*/);\n+  _IO_clearerr (fp);\n+}"}, {"sha": "4773599012dda73de9940de63aaa4ebe4644fbdf", "filename": "libio/stdio/feof_u.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Ffeof_u.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Ffeof_u.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Ffeof_u.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+#include \"libioP.h\"\n+#include \"stdio.h\"\n+\n+#undef feof_unlocked\n+\n+int\n+feof_unlocked (fp)\n+     _IO_FILE* fp;\n+{\n+  CHECK_FILE (fp, EOF);\n+  return _IO_feof_unlocked (fp);\n+}"}, {"sha": "6e13e53ddc0090eac6bb5ad62a6b0c39c3e74baa", "filename": "libio/stdio/ferror_u.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fferror_u.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fferror_u.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fferror_u.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+#include \"libioP.h\"\n+#include \"stdio.h\"\n+\n+#undef ferror_unlocked\n+\n+int\n+ferror_unlocked (fp)\n+     _IO_FILE* fp;\n+{\n+  CHECK_FILE (fp, EOF);\n+  return _IO_ferror_unlocked (fp);\n+}"}, {"sha": "174e60fa3fd27afb4c5e2b5983617742f5cad8ca", "filename": "libio/stdio/fgetc.c", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Ffgetc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Ffgetc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Ffgetc.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,10 +1,40 @@\n+/* Copyright (C) 1993, 1995, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n #include \"libioP.h\"\n #include \"stdio.h\"\n \n int\n-fgetc(fp)\n+fgetc (fp)\n      FILE *fp;\n {\n-  CHECK_FILE(fp, EOF);\n-  return _IO_getc(fp);\n+  int result;\n+  CHECK_FILE (fp, EOF);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+  result = _IO_getc_unlocked (fp);\n+  _IO_cleanup_region_end (1);\n+  return result;\n }"}, {"sha": "7ff93e6a8138839d825718280f4407b639e88ab6", "filename": "libio/stdio/fileno.c", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Ffileno.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Ffileno.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Ffileno.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,12 +1,49 @@\n+/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n #include \"libioP.h\"\n #include \"stdio.h\"\n \n int\n-fileno(fp)\n+fileno (fp)\n      _IO_FILE* fp;\n {\n-  CHECK_FILE(fp, EOF);\n+  CHECK_FILE (fp, EOF);\n+\n   if (!(fp->_flags & _IO_IS_FILEBUF))\n     return EOF;\n-  return _IO_fileno(fp);\n+\n+  return _IO_fileno (fp);\n }\n+\n+#ifdef _IO_MTSAFE_IO\n+#ifdef weak_alias\n+/* The fileno implementation for libio does not require locking because\n+   it only accesses once a single variable and this is already atomic\n+   (at least at thread level).  */\n+\n+weak_alias (fileno, fileno_unlocked)\n+#endif\n+#endif"}, {"sha": "22cdfab9a8442b3a5cc6810c06b23cfaca3d1e23", "filename": "libio/stdio/fputc.c", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Ffputc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Ffputc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Ffputc.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,11 +1,41 @@\n+/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n #include \"libioP.h\"\n #include \"stdio.h\"\n \n int\n-fputc(c, fp)\n+fputc (c, fp)\n      int c;\n-     FILE *fp;\n+     _IO_FILE *fp;\n {\n-  CHECK_FILE(fp, EOF);\n-  return _IO_putc(c, fp);\n+  int result;\n+  CHECK_FILE (fp, EOF);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+  result = _IO_putc_unlocked (c, fp);\n+  _IO_cleanup_region_end (1);\n+  return result;\n }"}, {"sha": "48701e1d6cb50e9fd331ec128eca5425589bbd0c", "filename": "libio/stdio/fputc_u.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Ffputc_u.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Ffputc_u.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Ffputc_u.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -0,0 +1,38 @@\n+/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+#include \"libioP.h\"\n+#include \"stdio.h\"\n+\n+#undef fputc_unlocked\n+\n+int\n+fputc_unlocked (c, fp)\n+     int c;\n+     _IO_FILE *fp;\n+{\n+  CHECK_FILE (fp, EOF);\n+  return _IO_putc_unlocked (c, fp);\n+}"}, {"sha": "ff57d6033dc1d8cea749433db69add146d610d9f", "filename": "libio/stdio/freopen.c", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Ffreopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Ffreopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Ffreopen.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,14 +1,44 @@\n+/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n #include \"libioP.h\"\n #include \"stdio.h\"\n \n FILE*\n-freopen(filename, mode, fp)\n+freopen (filename, mode, fp)\n      const char* filename;\n      const char* mode;\n      FILE* fp;\n {\n-  CHECK_FILE(fp, NULL);\n+  FILE *result;\n+  CHECK_FILE (fp, NULL);\n   if (!(fp->_flags & _IO_IS_FILEBUF))\n     return NULL;\n-  return _IO_freopen(filename, mode, fp);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+  result = _IO_freopen (filename, mode, fp);\n+  _IO_cleanup_region_end (1);\n+  return result;\n }"}, {"sha": "f2563d33f28f4cdca470293fc8adad583a95f24f", "filename": "libio/stdio/fseek.c", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Ffseek.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Ffseek.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Ffseek.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,12 +1,42 @@\n-#include \"stdio.h\"\n+/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n #include \"libioP.h\"\n+#include \"stdio.h\"\n \n int\n-fseek(fp, offset, whence)\n+fseek (fp, offset, whence)\n      _IO_FILE* fp;\n      long int offset;\n      int whence;\n {\n-  CHECK_FILE(fp, -1);\n-  return _IO_fseek(fp, offset, whence);\n+  int result;\n+  CHECK_FILE (fp, -1);\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+  result = _IO_fseek (fp, offset, whence);\n+  _IO_cleanup_region_end (1);\n+  return result;\n }"}, {"sha": "f07442744661bc555502f05401d5e07bf24be5ef", "filename": "libio/stdio/getc_u.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fgetc_u.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fgetc_u.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fgetc_u.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+#include \"libioP.h\"\n+#include \"stdio.h\"\n+\n+#undef getc_unlocked\n+\n+int\n+getc_unlocked (fp)\n+     FILE *fp;\n+{\n+  CHECK_FILE (fp, EOF);\n+  return _IO_getc_unlocked (fp);\n+}"}, {"sha": "93194b3912d91def27b6096639945f7f671d1349", "filename": "libio/stdio/getchar.c", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fgetchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fgetchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fgetchar.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,3 +1,28 @@\n+/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n #include \"libioP.h\"\n #include \"stdio.h\"\n \n@@ -6,5 +31,10 @@\n int\n getchar ()\n {\n-  return _IO_getc (stdin);\n+  int result;\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, stdin);\n+  _IO_flockfile (stdin);\n+  result = _IO_getc_unlocked (stdin);\n+  _IO_cleanup_region_end (1);\n+  return result;\n }"}, {"sha": "bfbe56b30c09d9854aeff81f0bb7ea605d0810c6", "filename": "libio/stdio/getchar_u.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fgetchar_u.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fgetchar_u.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fgetchar_u.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -0,0 +1,35 @@\n+/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+#include \"libioP.h\"\n+#include \"stdio.h\"\n+\n+#undef getchar_unlocked\n+\n+int\n+getchar_unlocked ()\n+{\n+  return _IO_getc_unlocked (stdin);\n+}"}, {"sha": "b4d94e8912bc7358300282552c7ae27528e59f6c", "filename": "libio/stdio/putc_u.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fputc_u.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fputc_u.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fputc_u.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -0,0 +1,31 @@\n+/* Copyright (C) 1991, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Library General Public License as\n+   published by the Free Software Foundation; either version 2 of the\n+   License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#include \"libioP.h\"\n+#include \"stdio.h\"\n+\n+#undef putc_unlocked\n+\n+int\n+putc_unlocked (c, fp)\n+     int c;\n+     _IO_FILE *fp;\n+{\n+  CHECK_FILE (fp, EOF);\n+  return _IO_putc_unlocked (c, fp);\n+}"}, {"sha": "f97af04870138596c1c672a07b144593d90e133f", "filename": "libio/stdio/putchar.c", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fputchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fputchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fputchar.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,10 +1,35 @@\n+/* Copyright (C) 1991, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Library General Public License as\n+   published by the Free Software Foundation; either version 2 of the\n+   License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n #include \"libioP.h\"\n #include \"stdio.h\"\n+\n #undef putchar\n \n int\n-putchar(c)\n+putchar (c)\n      int c;\n {\n-  return _IO_putc(c, stdout);\n+  int result;\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t    _IO_stdout);\n+  _IO_flockfile (_IO_stdout);\n+  result = _IO_putc_unlocked (c, _IO_stdout);\n+  _IO_cleanup_region_end (1);\n+  return result;\n }"}, {"sha": "f8f387ac4edbaeae98819e539691636971ef45c1", "filename": "libio/stdio/putchar_u.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fputchar_u.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fputchar_u.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fputchar_u.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -0,0 +1,30 @@\n+/* Copyright (C) 1991, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Library General Public License as\n+   published by the Free Software Foundation; either version 2 of the\n+   License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#include \"libioP.h\"\n+#include \"stdio.h\"\n+\n+#undef putchar_unlocked\n+\n+int\n+putchar_unlocked (c)\n+     int c;\n+{\n+  CHECK_FILE (stdout, EOF);\n+  return _IO_putc_unlocked (c, stdout);\n+}"}, {"sha": "bce27575fd8a677ed397f56ea3e1c1d6fd106dd5", "filename": "libio/stdio/rewind.c", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Frewind.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Frewind.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Frewind.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,10 +1,38 @@\n-#include \"stdio.h\"\n+/* Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n #include \"libioP.h\"\n+#include \"stdio.h\"\n \n void\n-rewind(fp)\n-     _IO_FILE* fp;\n+rewind (fp)\n+     _IO_FILE *fp;\n {\n-  CHECK_FILE(fp, );\n-  _IO_rewind(fp);\n+  CHECK_FILE (fp, );\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+  _IO_rewind (fp);\n+  _IO_cleanup_region_end (1);\n }"}, {"sha": "ac323a31b5ba3a05cadd94ee9eb8d0abe01f3051", "filename": "libio/stdio/setbuf.c", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fsetbuf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fsetbuf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fsetbuf.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,9 +1,35 @@\n+/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n #include \"libioP.h\"\n #include \"stdio.h\"\n \n void\n setbuf (fp, buf)\n-     FILE *fp;  char *buf;\n+     _IO_FILE *fp;\n+     char *buf;\n {\n-  _IO_setbuffer(fp, buf, _IO_BUFSIZ);\n+  _IO_setbuffer (fp, buf, _IO_BUFSIZ);\n }"}, {"sha": "e4e029faeac2f71833e7ebc93dd752991685904b", "filename": "libio/stdio/setlinebuf.c", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fsetlinebuf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fsetlinebuf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fsetlinebuf.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,11 +1,36 @@\n+/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n #include \"libioP.h\"\n #include \"stdio.h\"\n \n #undef setlinebuf\n \n void\n setlinebuf (stream)\n-  FILE *stream;\n+     _IO_FILE *stream;\n {\n-  _IO_setvbuf(stream, NULL, 1, 0);\n+  _IO_setvbuf (stream, NULL, 1, 0);\n }"}, {"sha": "8b92ae270e6d56f34b2a377d732f062b508e33a9", "filename": "libio/stdio/vscanf.c", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fvscanf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fvscanf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fvscanf.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,34 +1,41 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n #include \"stdio.h\"\n \n+#undef vscanf\n+\n int\n-vscanf(format, args)\n+_IO_vscanf (format, args)\n      const char *format;\n      _IO_va_list args;\n {\n-  return _IO_vfscanf(_IO_stdin, format, args, NULL);\n+  return _IO_vfscanf (_IO_stdin, format, args, NULL);\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_vscanf, vscanf)\n+#endif"}, {"sha": "3f35af299ab7cbd0fa94becb8195b03a32d78626", "filename": "libio/stdio/vsnprintf.c", "status": "modified", "additions": 123, "deletions": 30, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fvsnprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstdio%2Fvsnprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fvsnprintf.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,43 +1,136 @@\n-/*\n-Copyright (C) 1994 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+/* Copyright (C) 1994, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"libioP.h\"\n #include \"strfile.h\"\n \n+\n+typedef struct\n+{\n+  _IO_strfile f;\n+  /* This is used for the characters which do not fit in the buffer\n+     provided by the user.  */\n+  char overflow_buf[64];\n+} _IO_strnfile;\n+\n+\n+static int _IO_strn_overflow __P ((_IO_FILE *fp, int c));\n+\n+static int\n+_IO_strn_overflow (fp, c)\n+     _IO_FILE *fp;\n+     int c;\n+{\n+  /* When we come to here this means the user supplied buffer is\n+     filled.  But since we must return the number of characters which\n+     would have been written in total we must provide a buffer for\n+     further use.  We can do this by writing on and on in the overflow\n+     buffer in the _IO_strnfile structure.  */\n+  _IO_strnfile *snf = (_IO_strnfile *) fp;\n+\n+  if (fp->_IO_buf_base != snf->overflow_buf)\n+    {\n+      /* Terminate the string.  We know that there is room for at\n+\t least one more character since we initialized the stream with\n+\t a size to make this possible.  */\n+      *fp->_IO_write_ptr = '\\0';\n+\n+      _IO_setb (fp, snf->overflow_buf,\n+\t\tsnf->overflow_buf + sizeof (snf->overflow_buf), 0);\n+\n+      fp->_IO_write_base = snf->overflow_buf;\n+      fp->_IO_read_base = snf->overflow_buf;\n+      fp->_IO_read_ptr = snf->overflow_buf;\n+      fp->_IO_read_end = snf->overflow_buf + sizeof (snf->overflow_buf);\n+    }\n+\n+  fp->_IO_write_ptr = snf->overflow_buf;\n+  fp->_IO_write_end = snf->overflow_buf;\n+\n+  /* Since we are not really interested in storing the characters\n+     which do not fit in the buffer we simply ignore it.  */\n+  return c;\n+}\n+\n+\n+static struct _IO_jump_t _IO_strn_jumps =\n+{\n+  JUMP_INIT_DUMMY,\n+  JUMP_INIT(finish, _IO_str_finish),\n+  JUMP_INIT(overflow, _IO_strn_overflow),\n+  JUMP_INIT(underflow, _IO_str_underflow),\n+  JUMP_INIT(uflow, _IO_default_uflow),\n+  JUMP_INIT(pbackfail, _IO_str_pbackfail),\n+  JUMP_INIT(xsputn, _IO_default_xsputn),\n+  JUMP_INIT(xsgetn, _IO_default_xsgetn),\n+  JUMP_INIT(seekoff, _IO_str_seekoff),\n+  JUMP_INIT(seekpos, _IO_default_seekpos),\n+  JUMP_INIT(setbuf, _IO_default_setbuf),\n+  JUMP_INIT(sync, _IO_default_sync),\n+  JUMP_INIT(doallocate, _IO_default_doallocate),\n+  JUMP_INIT(read, _IO_default_read),\n+  JUMP_INIT(write, _IO_default_write),\n+  JUMP_INIT(seek, _IO_default_seek),\n+  JUMP_INIT(close, _IO_default_close),\n+  JUMP_INIT(stat, _IO_default_stat)\n+};\n+\n+\n int\n-vsnprintf (string, maxlen, format, args)\n+_IO_vsnprintf (string, maxlen, format, args)\n      char *string;\n      _IO_size_t maxlen;\n      const char *format;\n      _IO_va_list args;\n {\n-  _IO_strfile sf;\n+  _IO_strnfile sf;\n   int ret;\n-  _IO_init((_IO_FILE*)&sf, 0);\n-  _IO_JUMPS((_IO_FILE*)&sf) = &_IO_str_jumps;\n-  _IO_str_init_static ((_IO_FILE*)&sf, string, maxlen - 1, string);\n-  ret = _IO_vfprintf((_IO_FILE*)&sf, format, args);\n-  *((_IO_FILE*)&sf)->_IO_write_ptr = '\\0';\n+#ifdef _IO_MTSAFE_IO\n+  _IO_lock_t lock;\n+  sf.f._sbf._f._lock = &lock;\n+#endif\n+\n+  /* We need to handle the special case where MAXLEN is 0.  Use the\n+     overflow buffer right from the start.  */\n+  if (maxlen == 0)\n+    {\n+      string = sf.overflow_buf;\n+      maxlen = sizeof (sf.overflow_buf);\n+    }\n+\n+  _IO_init ((_IO_FILE *) &sf, 0);\n+  _IO_JUMPS ((_IO_FILE *) &sf) = &_IO_strn_jumps;\n+  _IO_str_init_static ((_IO_FILE *) &sf, string, maxlen - 1, string);\n+  ret = _IO_vfprintf ((_IO_FILE *) &sf, format, args);\n+\n+  if (sf.f._sbf._f._IO_buf_base != sf.overflow_buf)\n+    *sf.f._sbf._f._IO_write_ptr = '\\0';\n   return ret;\n }\n+\n+#ifdef weak_alias\n+weak_alias (_IO_vsnprintf, __vsnprintf)\n+weak_alias (_IO_vsnprintf, vsnprintf)\n+#endif"}, {"sha": "8f7908b8403d4351f355df903b5cb57d6c32bcdd", "filename": "libio/streambuf.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstreambuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstreambuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstreambuf.cc?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -213,7 +213,7 @@ streambuf::streambuf(int flags)\n #endif\n }\n \n-streambuf::~streambuf() { _IO_default_finish(this); }\n+streambuf::~streambuf() { _IO_default_finish(this,0); }\n \n streampos\n streambuf::seekoff(streamoff, _seek_dir, int /*=ios::in|ios::out*/)"}, {"sha": "a492f636d874ec5f4913aca942e2f5a54f86b14a", "filename": "libio/streambuf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstreambuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstreambuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstreambuf.h?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -138,7 +138,7 @@ class ios : public _ios_fields {\n \tbin = _IOS_BIN, // Deprecated - ANSI uses ios::binary.\n \tbinary = _IOS_BIN };\n     enum seek_dir { beg, cur, end};\n-    // ANSI: typedef enum seek_dir seekdir; etc\n+    typedef enum seek_dir seekdir;\n     // NOTE: If adding flags here, before to update ios::bitalloc().\n     enum { skipws=_IO_SKIPWS,\n \t   left=_IO_LEFT, right=_IO_RIGHT, internal=_IO_INTERNAL,"}, {"sha": "a0e47021f6ec2b6aa29fd4371d74231be6e88ced", "filename": "libio/strfile.h", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstrfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstrfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstrfile.h?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,34 +1,35 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n-\n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include <libio.h>\n #ifdef TODO\n Merge into  libio.h ?\n #endif\n \n-typedef void *(*_IO_alloc_type) __P((_IO_size_t));\n-typedef void (*_IO_free_type) __P((void*));\n+typedef void *(*_IO_alloc_type) __P ((_IO_size_t));\n+typedef void (*_IO_free_type) __P ((void*));\n \n struct _IO_str_fields\n {"}, {"sha": "a9f812e04511cf9d23962cea0b6b9c292afb57da", "filename": "libio/strops.c", "status": "modified", "additions": 73, "deletions": 60, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstrops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56/libio%2Fstrops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstrops.c?ref=dbfcb4beace35e1426c1ce1e9bf2f20c7d5a0f56", "patch": "@@ -1,34 +1,35 @@\n-/* \n-Copyright (C) 1993 Free Software Foundation\n+/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n \n-This file is part of the GNU IO Library.  This library is free\n-software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n \n-This library is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this library; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n \n-As a special exception, if you link this library with files\n-compiled with a GNU compiler to produce an executable, this does not cause\n-the resulting executable to be covered by the GNU General Public License.\n-This exception does not however invalidate any other reasons why\n-the executable file might be covered by the GNU General Public License. */\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n \n #include \"strfile.h\"\n #include \"libioP.h\"\n #include <string.h>\n \n #if 0\n /* The following definitions are for exposition only.\n-   They map the terminlogy used in the ANSI/ISO C++ draft standard\n+   They map the terminology used in the ANSI/ISO C++ draft standard\n    to the implementation. */\n \n /* allocated:  set  when a dynamic array object has been allocated, and\n@@ -59,16 +60,19 @@ the executable file might be covered by the GNU General Public License. */\n #endif\n \n void\n-DEFUN(_IO_str_init_static, (fp, ptr, size, pstart),\n-      _IO_FILE *fp AND char *ptr AND int size AND char *pstart)\n+_IO_str_init_static (fp, ptr, size, pstart)\n+     _IO_FILE *fp;\n+     char *ptr;\n+     int size;\n+     char *pstart;\n {\n   if (size == 0)\n-    size = strlen(ptr);\n+    size = strlen (ptr);\n   else if (size < 0)\n     {\n       /* If size is negative 'the characters are assumed to\n \t continue indefinitely.'  This is kind of messy ... */\n-      _G_int32_t s;\n+      int s;\n       size = 512;\n       /* Try increasing powers of 2, as long as we don't wrap around. */\n       for (; s = 2*size, s > 0 && ptr + s > ptr && s < 0x4000000L; )\n@@ -80,15 +84,15 @@ DEFUN(_IO_str_init_static, (fp, ptr, size, pstart),\n \t    size += s;\n \t}\n     }\n-  _IO_setb(fp, ptr, ptr+size, 0);\n+  _IO_setb (fp, ptr, ptr + size, 0);\n \n   fp->_IO_write_base = ptr;\n   fp->_IO_read_base = ptr;\n   fp->_IO_read_ptr = ptr;\n   if (pstart)\n     {\n       fp->_IO_write_ptr = pstart;\n-      fp->_IO_write_end = ptr+size;\n+      fp->_IO_write_end = ptr + size;\n       fp->_IO_read_end = pstart;\n     }\n   else\n@@ -98,20 +102,23 @@ DEFUN(_IO_str_init_static, (fp, ptr, size, pstart),\n       fp->_IO_read_end = ptr+size;\n     }\n   /* A null _allocate_buffer function flags the strfile as being static. */\n-  (((_IO_strfile*)(fp))->_s._allocate_buffer) =  (_IO_alloc_type)0;\n+  (((_IO_strfile *) fp)->_s._allocate_buffer) =  (_IO_alloc_type)0;\n }\n \n void\n-DEFUN(_IO_str_init_readonly, (fp, ptr, size),\n-      _IO_FILE *fp AND const char *ptr AND int size)\n+_IO_str_init_readonly (fp, ptr, size)\n+     _IO_FILE *fp;\n+     const char *ptr;\n+     int size;\n {\n-  _IO_str_init_static (fp, (char*)ptr, size, NULL);\n+  _IO_str_init_static (fp, (char *) ptr, size, NULL);\n   fp->_IO_file_flags |= _IO_NO_WRITES;\n }\n \n int\n-DEFUN(_IO_str_overflow, (fp, c),\n-      register _IO_FILE* fp AND int c)\n+_IO_str_overflow (fp, c)\n+     _IO_FILE *fp;\n+     int c;\n {\n   int flush_only = c == EOF;\n   _IO_size_t pos;\n@@ -124,34 +131,34 @@ DEFUN(_IO_str_overflow, (fp, c),\n       fp->_IO_read_ptr = fp->_IO_read_end;\n     }\n   pos =  fp->_IO_write_ptr - fp->_IO_write_base;\n-  if (pos >= _IO_blen(fp) + flush_only)\n+  if (pos >= (_IO_size_t) (_IO_blen (fp) + flush_only))\n     {\n       if (fp->_flags & _IO_USER_BUF) /* not allowed to enlarge */\n \treturn EOF;\n       else\n \t{\n \t  char *new_buf;\n \t  char *old_buf = fp->_IO_buf_base;\n-\t  _IO_size_t new_size = 2 * _IO_blen(fp) + 100;\n+\t  _IO_size_t new_size = 2 * _IO_blen (fp) + 100;\n \t  new_buf\n-\t    = (char*)(*((_IO_strfile*)fp)->_s._allocate_buffer)(new_size);\n+\t    = (char *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (new_size);\n \t  if (new_buf == NULL)\n \t    {\n \t      /*\t  __ferror(fp) = 1; */\n \t      return EOF;\n \t    }\n \t  if (fp->_IO_buf_base)\n \t    {\n-\t      memcpy(new_buf, old_buf, _IO_blen(fp));\n-\t      (*((_IO_strfile*)fp)->_s._free_buffer)(fp->_IO_buf_base);\n+\t      memcpy (new_buf, old_buf, _IO_blen (fp));\n+\t      (*((_IO_strfile *) fp)->_s._free_buffer) (fp->_IO_buf_base);\n \t      /* Make sure _IO_setb won't try to delete _IO_buf_base. */\n \t      fp->_IO_buf_base = NULL;\n \t    }\n #if 0\n \t  if (lenp == &LEN(fp)) /* use '\\0'-filling */\n-\t      memset(new_buf + pos, 0, blen() - pos);\n+\t      memset (new_buf + pos, 0, blen() - pos);\n #endif\n-\t  _IO_setb(fp, new_buf, new_buf + new_size, 1);\n+\t  _IO_setb (fp, new_buf, new_buf + new_size, 1);\n \t  fp->_IO_read_base = new_buf + (fp->_IO_read_base - old_buf);\n \t  fp->_IO_read_ptr = new_buf + (fp->_IO_read_ptr - old_buf);\n \t  fp->_IO_read_end = new_buf + (fp->_IO_read_end - old_buf);\n@@ -170,8 +177,8 @@ DEFUN(_IO_str_overflow, (fp, c),\n }\n \n int\n-DEFUN(_IO_str_underflow, (fp),\n-      register _IO_FILE* fp)\n+_IO_str_underflow (fp)\n+     _IO_FILE *fp;\n {\n   if (fp->_IO_write_ptr > fp->_IO_read_end)\n     fp->_IO_read_end = fp->_IO_write_ptr;\n@@ -190,19 +197,22 @@ DEFUN(_IO_str_underflow, (fp),\n /* The size of the valid part of the buffer.  */\n \n _IO_ssize_t\n-DEFUN(_IO_str_count, (fp),\n-      register _IO_FILE *fp)\n+_IO_str_count (fp)\n+     _IO_FILE *fp;\n {\n-  return (fp->_IO_write_ptr > fp->_IO_read_end ? fp->_IO_write_ptr\n-\t  : fp->_IO_read_end)\n-    - fp->_IO_read_base;\n-}     \n+  return ((fp->_IO_write_ptr > fp->_IO_read_end\n+\t   ? fp->_IO_write_ptr : fp->_IO_read_end)\n+\t  - fp->_IO_read_base);\n+}\n \n _IO_pos_t\n-DEFUN(_IO_str_seekoff, (fp, offset, dir, mode),\n-      register _IO_FILE *fp AND _IO_off_t offset AND int dir AND int mode)\n+_IO_str_seekoff (fp, offset, dir, mode)\n+     _IO_FILE *fp;\n+     _IO_off_t offset;\n+     int dir;\n+     int mode;\n {\n-  _IO_ssize_t cur_size = _IO_str_count(fp);\n+  _IO_ssize_t cur_size = _IO_str_count (fp);\n   _IO_pos_t new_pos = EOF;\n \n   /* Move the get pointer, if requested. */\n@@ -219,7 +229,7 @@ DEFUN(_IO_str_seekoff, (fp, offset, dir, mode),\n \tdefault: /* case _IO_seek_set: */\n \t  break;\n \t}\n-      if (offset < 0 || (_IO_size_t)offset > cur_size)\n+      if (offset < 0 || (_IO_ssize_t) offset > cur_size)\n \treturn EOF;\n       fp->_IO_read_ptr = fp->_IO_read_base + offset;\n       fp->_IO_read_end = fp->_IO_read_base + cur_size;\n@@ -240,7 +250,7 @@ DEFUN(_IO_str_seekoff, (fp, offset, dir, mode),\n \tdefault: /* case _IO_seek_set: */\n \t  break;\n \t}\n-      if (offset < 0 || (_IO_size_t)offset > cur_size)\n+      if (offset < 0 || (_IO_ssize_t) offset > cur_size)\n \treturn EOF;\n       fp->_IO_write_ptr = fp->_IO_write_base + offset;\n       new_pos = offset;\n@@ -249,26 +259,29 @@ DEFUN(_IO_str_seekoff, (fp, offset, dir, mode),\n }\n \n int\n-DEFUN(_IO_str_pbackfail, (fp, c),\n-      register _IO_FILE *fp AND int c)\n+_IO_str_pbackfail (fp, c)\n+     _IO_FILE *fp;\n+     int c;\n {\n   if ((fp->_flags & _IO_NO_WRITES) && c != EOF)\n     return EOF;\n-  return _IO_default_pbackfail(fp, c);\n+  return _IO_default_pbackfail (fp, c);\n }\n \n void\n-DEFUN (_IO_str_finish, (fp),\n-      register _IO_FILE* fp)\n+_IO_str_finish (fp, dummy)\n+     _IO_FILE *fp;\n+     int dummy;\n {\n   if (fp->_IO_buf_base && !(fp->_flags & _IO_USER_BUF))\n-    (((_IO_strfile*)fp)->_s._free_buffer)(fp->_IO_buf_base);\n+    (((_IO_strfile *) fp)->_s._free_buffer) (fp->_IO_buf_base);\n   fp->_IO_buf_base = NULL;\n \n-  _IO_default_finish(fp);\n+  _IO_default_finish (fp, 0);\n }\n \n-struct _IO_jump_t _IO_str_jumps = {\n+struct _IO_jump_t _IO_str_jumps =\n+{\n   JUMP_INIT_DUMMY,\n   JUMP_INIT(finish, _IO_str_finish),\n   JUMP_INIT(overflow, _IO_str_overflow),"}]}