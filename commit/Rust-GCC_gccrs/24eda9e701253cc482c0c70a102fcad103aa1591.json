{"sha": "24eda9e701253cc482c0c70a102fcad103aa1591", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRlZGE5ZTcwMTI1M2NjNDgyYzBjNzBhMTAyZmNhZDEwM2FhMTU5MQ==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2020-02-17T06:31:57Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-08T07:51:06Z"}, "message": "[Ada] Implement predicate checks on qualified expressions (AI12-0100)\n\n2020-06-08  Gary Dismukes  <dismukes@adacore.com>\n\ngcc/ada/\n\n\t* checks.adb (Apply_Predicate_Check): Refine test for being in a\n\tsubprogram body to account for no Corresponding_Body case,\n\tavoiding blowups arising due to other changes here.\n\t* exp_ch4.adb (Expand_N_Qualified_Expression): Apply predicate\n\tchecks, if any, after constraint checks are applied.\n\t* sem_eval.ads (Check_Expression_Against_Static_Predicate): Add\n\tCheck_Failure_Is_Error formal for conditionalizing warning vs.\n\terror messages.\n\t* sem_eval.adb (Check_Expression_Against_Static_Predicate):\n\tIssue an error message rather than a warning when the new\n\tCheck_Failure_Is_Error formal is True. In the nonstatic or\n\tDynamic_Predicate case where the predicate is known to fail,\n\temit the check to ensure that folded cases get checks applied.\n\t* sem_res.adb (Resolve_Qualified_Expression): Call\n\tCheck_Expression_Against_Static_Predicate, passing True for\n\tCheck_Failure_Is_Error, to ensure we reject static predicate\n\tviolations. Remove code that was conditionally calling\n\tApply_Predicate_Check, which is no longer needed, and that check\n\tprocedure shouldn't be called from a resolution routine in any\n\tcase. Also remove associated comment about preventing infinite\n\trecursion and consistency with Resolve_Type_Conversion, since\n\tthat handling was already similarly removed from\n\tResolve_Type_Convesion at some point.\n\t(Resolve_Type_Conversion): Add passing of True for\n\tCheck_Failure_Is_Error parameter on call to\n\tCheck_Expression_Against_Static_Predicate, to ensure that static\n\tconversion cases that violate a predicate are rejected as\n\terrors.", "tree": {"sha": "2e150de90a88d8c8218f183259908a98fab78b9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e150de90a88d8c8218f183259908a98fab78b9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24eda9e701253cc482c0c70a102fcad103aa1591", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24eda9e701253cc482c0c70a102fcad103aa1591", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24eda9e701253cc482c0c70a102fcad103aa1591", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24eda9e701253cc482c0c70a102fcad103aa1591/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b7f1ca1b28b650eedd1074bf723b04e99adcdaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b7f1ca1b28b650eedd1074bf723b04e99adcdaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b7f1ca1b28b650eedd1074bf723b04e99adcdaf"}], "stats": {"total": 101, "additions": 61, "deletions": 40}, "files": [{"sha": "945c7d30c6b7d101d08ad63922eed4005ecd0e86", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24eda9e701253cc482c0c70a102fcad103aa1591/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24eda9e701253cc482c0c70a102fcad103aa1591/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=24eda9e701253cc482c0c70a102fcad103aa1591", "patch": "@@ -2789,7 +2789,13 @@ package body Checks is\n                begin\n                   while Present (P) loop\n                      if Nkind (P) = N_Subprogram_Body\n-                       and then Corresponding_Spec (P) = Scope (Entity (N))\n+                       and then\n+                         ((Present (Corresponding_Spec (P))\n+                            and then\n+                              Corresponding_Spec (P) = Scope (Entity (N)))\n+                            or else\n+                              Defining_Unit_Name (Specification (P)) =\n+                                Scope (Entity (N)))\n                      then\n                         In_Body := True;\n                         exit;"}, {"sha": "8631ded4ea91b5ca401f1683bb14a8015ef38a77", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24eda9e701253cc482c0c70a102fcad103aa1591/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24eda9e701253cc482c0c70a102fcad103aa1591/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=24eda9e701253cc482c0c70a102fcad103aa1591", "patch": "@@ -10424,6 +10424,10 @@ package body Exp_Ch4 is\n \n       Apply_Constraint_Check (Operand, Target_Type, No_Sliding => True);\n \n+      --  Apply possible predicate check\n+\n+      Apply_Predicate_Check (Operand, Target_Type);\n+\n       if Do_Range_Check (Operand) then\n          Generate_Range_Check (Operand, Target_Type, CE_Range_Check_Failed);\n       end if;"}, {"sha": "2fab4bb9a6fd1cbccb33c0b8db733eb55338bdca", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24eda9e701253cc482c0c70a102fcad103aa1591/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24eda9e701253cc482c0c70a102fcad103aa1591/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=24eda9e701253cc482c0c70a102fcad103aa1591", "patch": "@@ -324,8 +324,9 @@ package body Sem_Eval is\n    -----------------------------------------------\n \n    procedure Check_Expression_Against_Static_Predicate\n-     (Expr : Node_Id;\n-      Typ  : Entity_Id)\n+     (Expr                    : Node_Id;\n+      Typ                     : Entity_Id;\n+      Static_Failure_Is_Error : Boolean := False)\n    is\n    begin\n       --  Nothing to do if expression is not known at compile time, or the\n@@ -383,18 +384,28 @@ package body Sem_Eval is\n       --  Here we know that the predicate will fail\n \n       --  Special case of static expression failing a predicate (other than one\n-      --  that was explicitly specified with a Dynamic_Predicate aspect). This\n-      --  is the case where the expression is no longer considered static.\n+      --  that was explicitly specified with a Dynamic_Predicate aspect). If\n+      --  the expression comes from a qualified_expression or type_conversion\n+      --  this is an error (Static_Failure_Is_Error); otherwise we only issue\n+      --  a warning and the expression is no longer considered static.\n \n       if Is_Static_Expression (Expr)\n         and then not Has_Dynamic_Predicate_Aspect (Typ)\n       then\n-         Error_Msg_NE\n-           (\"??static expression fails static predicate check on &\",\n-            Expr, Typ);\n-         Error_Msg_N\n-           (\"\\??expression is no longer considered static\", Expr);\n-         Set_Is_Static_Expression (Expr, False);\n+         if Static_Failure_Is_Error then\n+            Error_Msg_NE\n+              (\"static expression fails static predicate check on &\",\n+               Expr, Typ);\n+\n+         else\n+            Error_Msg_NE\n+              (\"??static expression fails static predicate check on &\",\n+               Expr, Typ);\n+            Error_Msg_N\n+              (\"\\??expression is no longer considered static\", Expr);\n+\n+            Set_Is_Static_Expression (Expr, False);\n+         end if;\n \n       --  In all other cases, this is just a warning that a test will fail.\n       --  It does not matter if the expression is static or not, or if the\n@@ -403,6 +414,15 @@ package body Sem_Eval is\n       else\n          Error_Msg_NE\n            (\"??expression fails predicate check on &\", Expr, Typ);\n+\n+         --  Force a check here, which is potentially a redundant check, but\n+         --  this ensures a check will be done in cases where the expression\n+         --  is folded, and since this is definitely a failure, extra checks\n+         --  are OK.\n+\n+         Insert_Action (Expr,\n+           Make_Predicate_Check\n+             (Typ, Duplicate_Subexpr (Expr)), Suppress => All_Checks);\n       end if;\n    end Check_Expression_Against_Static_Predicate;\n "}, {"sha": "984a75f952dc7dbe57eaacb4758bb13fd2ce730c", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24eda9e701253cc482c0c70a102fcad103aa1591/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24eda9e701253cc482c0c70a102fcad103aa1591/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=24eda9e701253cc482c0c70a102fcad103aa1591", "patch": "@@ -125,15 +125,18 @@ package Sem_Eval is\n    -----------------\n \n    procedure Check_Expression_Against_Static_Predicate\n-     (Expr : Node_Id;\n-      Typ  : Entity_Id);\n+     (Expr                    : Node_Id;\n+      Typ                     : Entity_Id;\n+      Static_Failure_Is_Error : Boolean := False);\n    --  Determine whether an arbitrary expression satisfies the static predicate\n    --  of a type. The routine does nothing if Expr is not known at compile time\n-   --  or Typ lacks a static predicate, otherwise it may emit a warning if the\n-   --  expression is prohibited by the predicate. If the expression is a static\n-   --  expression and it fails a predicate that was not explicitly stated to be\n-   --  a dynamic predicate, then an additional warning is given, and the flag\n-   --  Is_Static_Expression is reset on Expr.\n+   --  or Typ lacks a static predicate; otherwise it may emit a warning if the\n+   --  expression is prohibited by the predicate, or if Static_Failure_Is_Error\n+   --  is True then an error will be flagged. If the expression is a static\n+   --  expression, it fails a predicate that was not explicitly stated to be\n+   --  a dynamic predicate, and Static_Failure_Is_Error is False, then an\n+   --  additional warning is given, and the flag Is_Static_Expression is reset\n+   --  on Expr.\n \n    procedure Check_Non_Static_Context (N : Node_Id);\n    --  Deals with the special check required for a static expression that"}, {"sha": "0856c893562ab30fb67f5113390025697716d426", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24eda9e701253cc482c0c70a102fcad103aa1591/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24eda9e701253cc482c0c70a102fcad103aa1591/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=24eda9e701253cc482c0c70a102fcad103aa1591", "patch": "@@ -10008,27 +10008,13 @@ package body Sem_Res is\n          Apply_Scalar_Range_Check (Expr, Typ);\n       end if;\n \n-      --  Finally, check whether a predicate applies to the target type. This\n-      --  comes from AI12-0100. As for type conversions, check the enclosing\n-      --  context to prevent an infinite expansion.\n+      --  AI12-0100: Once the qualified expression is resolved, check whether\n+      --  operand statisfies a static predicate of the target subtype, if any.\n+      --  In the static expression case, a predicate check failure is an error.\n \n       if Has_Predicates (Target_Typ) then\n-         if Nkind (Parent (N)) = N_Function_Call\n-           and then Present (Name (Parent (N)))\n-           and then (Is_Predicate_Function (Entity (Name (Parent (N))))\n-                       or else\n-                     Is_Predicate_Function_M (Entity (Name (Parent (N)))))\n-         then\n-            null;\n-\n-         --  In the case of a qualified expression in an allocator, the check\n-         --  is applied when expanding the allocator, so avoid redundant check.\n-\n-         elsif Nkind (N) = N_Qualified_Expression\n-           and then Nkind (Parent (N)) /= N_Allocator\n-         then\n-            Apply_Predicate_Check (N, Target_Typ);\n-         end if;\n+         Check_Expression_Against_Static_Predicate\n+           (N, Target_Typ, Static_Failure_Is_Error => True);\n       end if;\n    end Resolve_Qualified_Expression;\n \n@@ -11553,11 +11539,13 @@ package body Sem_Res is\n          end;\n       end if;\n \n-      --  Ada 2012: once the type conversion is resolved, check whether the\n-      --  operand statisfies the static predicate of the target type.\n+      --  Ada 2012: Once the type conversion is resolved, check whether the\n+      --  operand statisfies a static predicate of the target subtype, if any.\n+      --  In the static expression case, a predicate check failure is an error.\n \n       if Has_Predicates (Target_Typ) then\n-         Check_Expression_Against_Static_Predicate (N, Target_Typ);\n+         Check_Expression_Against_Static_Predicate\n+           (N, Target_Typ, Static_Failure_Is_Error => True);\n       end if;\n \n       --  If at this stage we have a real to integer conversion, make sure that"}]}