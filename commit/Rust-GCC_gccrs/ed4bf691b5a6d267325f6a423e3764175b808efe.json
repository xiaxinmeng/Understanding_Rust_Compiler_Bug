{"sha": "ed4bf691b5a6d267325f6a423e3764175b808efe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ0YmY2OTFiNWE2ZDI2NzMyNWY2YTQyM2UzNzY0MTc1YjgwOGVmZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2015-01-28T23:23:55Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2015-01-28T23:23:55Z"}, "message": "Merge with upstream libffi db1b34b7e1f5e473d17557e454a29933dfecd1af\n\nIncludes build fixes for Solaris and FreeBSD.\n\nFrom-SVN: r220222", "tree": {"sha": "089358be9a84cd152b084f2ad44dc4bf48701683", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/089358be9a84cd152b084f2ad44dc4bf48701683"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed4bf691b5a6d267325f6a423e3764175b808efe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed4bf691b5a6d267325f6a423e3764175b808efe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed4bf691b5a6d267325f6a423e3764175b808efe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed4bf691b5a6d267325f6a423e3764175b808efe/comments", "author": null, "committer": null, "parents": [{"sha": "2dde0c3197cf0815c38466f4943828038f0629d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dde0c3197cf0815c38466f4943828038f0629d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dde0c3197cf0815c38466f4943828038f0629d8"}], "stats": {"total": 641, "additions": 467, "deletions": 174}, "files": [{"sha": "3bc3036ca23138e774eea251befbf013882fe9dc", "filename": "libffi/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed4bf691b5a6d267325f6a423e3764175b808efe/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed4bf691b5a6d267325f6a423e3764175b808efe/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=ed4bf691b5a6d267325f6a423e3764175b808efe", "patch": "@@ -1,3 +1,7 @@\n+2015-01-28  Richard Henderson  <rth@redhat.com>\n+\n+\t* Merge to upstream commit db1b34b7e1f5e473d17557e454a29933dfecd1af.\n+\n 2015-01-27  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* testsuite/lib/libffi.exp: Load target-supports.exp."}, {"sha": "751ed015f3a91c945c32800d49c2c6b54a1f0ed9", "filename": "libffi/configure", "status": "modified", "additions": 9, "deletions": 77, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed4bf691b5a6d267325f6a423e3764175b808efe/libffi%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed4bf691b5a6d267325f6a423e3764175b808efe/libffi%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure?ref=ed4bf691b5a6d267325f6a423e3764175b808efe", "patch": "@@ -15643,7 +15643,8 @@ $as_echo \"#define HAVE_AS_CFI_PSEUDO_OP 1\" >>confdefs.h\n  fi\n \n \n-if test x$TARGET = xSPARC; then\n+case \"$TARGET\" in\n+  SPARC)\n     { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler and linker support unaligned pc related relocs\" >&5\n $as_echo_n \"checking assembler and linker support unaligned pc related relocs... \" >&6; }\n if test \"${libffi_cv_as_sparc_ua_pcrel+set}\" = set; then :\n@@ -15717,9 +15718,9 @@ $as_echo \"$libffi_cv_as_register_pseudo_op\" >&6; }\n $as_echo \"#define HAVE_AS_REGISTER_PSEUDO_OP 1\" >>confdefs.h\n \n     fi\n-fi\n+    ;;\n \n-if test x$TARGET = xX86 || test x$TARGET = xX86_WIN32 || test x$TARGET = xX86_64; then\n+  X86*)\n     { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler supports pc related relocs\" >&5\n $as_echo_n \"checking assembler supports pc related relocs... \" >&6; }\n if test \"${libffi_cv_as_x86_pcrel+set}\" = set; then :\n@@ -15740,79 +15741,9 @@ $as_echo \"$libffi_cv_as_x86_pcrel\" >&6; }\n $as_echo \"#define HAVE_AS_X86_PCREL 1\" >>confdefs.h\n \n     fi\n+    ;;\n \n-    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler .ascii pseudo-op support\" >&5\n-$as_echo_n \"checking assembler .ascii pseudo-op support... \" >&6; }\n-if test \"${libffi_cv_as_ascii_pseudo_op+set}\" = set; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-\n-       libffi_cv_as_ascii_pseudo_op=unknown\n-       # Check if we have .ascii\n-       cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-\n-int\n-main ()\n-{\n-asm (\".ascii \\\\\"string\\\\\"\");\n-  ;\n-  return 0;\n-}\n-_ACEOF\n-if ac_fn_c_try_compile \"$LINENO\"; then :\n-  libffi_cv_as_ascii_pseudo_op=yes\n-else\n-  libffi_cv_as_ascii_pseudo_op=no\n-fi\n-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n-\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libffi_cv_as_ascii_pseudo_op\" >&5\n-$as_echo \"$libffi_cv_as_ascii_pseudo_op\" >&6; }\n-    if test \"x$libffi_cv_as_ascii_pseudo_op\" = xyes; then\n-\n-$as_echo \"#define HAVE_AS_ASCII_PSEUDO_OP 1\" >>confdefs.h\n-\n-    fi\n-\n-    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler .string pseudo-op support\" >&5\n-$as_echo_n \"checking assembler .string pseudo-op support... \" >&6; }\n-if test \"${libffi_cv_as_string_pseudo_op+set}\" = set; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-\n-       libffi_cv_as_string_pseudo_op=unknown\n-       # Check if we have .string\n-       cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-\n-int\n-main ()\n-{\n-asm (\".string \\\\\"string\\\\\"\");\n-  ;\n-  return 0;\n-}\n-_ACEOF\n-if ac_fn_c_try_compile \"$LINENO\"; then :\n-  libffi_cv_as_string_pseudo_op=yes\n-else\n-  libffi_cv_as_string_pseudo_op=no\n-fi\n-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n-\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libffi_cv_as_string_pseudo_op\" >&5\n-$as_echo \"$libffi_cv_as_string_pseudo_op\" >&6; }\n-    if test \"x$libffi_cv_as_string_pseudo_op\" = xyes; then\n-\n-$as_echo \"#define HAVE_AS_STRING_PSEUDO_OP 1\" >>confdefs.h\n-\n-    fi\n-fi\n-\n-if test x$TARGET = xS390; then\n+  S390)\n     { $as_echo \"$as_me:${as_lineno-$LINENO}: checking compiler uses zarch features\" >&5\n $as_echo_n \"checking compiler uses zarch features... \" >&6; }\n if test \"${libffi_cv_as_s390_zarch+set}\" = set; then :\n@@ -15835,7 +15766,8 @@ $as_echo \"$libffi_cv_as_s390_zarch\" >&6; }\n $as_echo \"#define HAVE_AS_S390_ZARCH 1\" >>confdefs.h\n \n     fi\n-fi\n+    ;;\n+esac\n \n # On PaX enable kernels that have MPROTECT enable we can't use PROT_EXEC.\n # Check whether --enable-pax_emutramp was given.\n@@ -15850,7 +15782,7 @@ fi\n \n FFI_EXEC_TRAMPOLINE_TABLE=0\n case \"$target\" in\n-     *arm*-apple-darwin*)\n+     *arm*-apple-darwin* | aarch64-apple-darwin*)\n        FFI_EXEC_TRAMPOLINE_TABLE=1\n \n $as_echo \"#define FFI_EXEC_TRAMPOLINE_TABLE 1\" >>confdefs.h"}, {"sha": "68501d100dcb7981644916a652d1048f0ed36529", "filename": "libffi/configure.ac", "status": "modified", "additions": 9, "deletions": 33, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed4bf691b5a6d267325f6a423e3764175b808efe/libffi%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed4bf691b5a6d267325f6a423e3764175b808efe/libffi%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.ac?ref=ed4bf691b5a6d267325f6a423e3764175b808efe", "patch": "@@ -112,7 +112,8 @@ AC_C_BIGENDIAN\n \n GCC_AS_CFI_PSEUDO_OP\n \n-if test x$TARGET = xSPARC; then\n+case \"$TARGET\" in\n+  SPARC)\n     AC_CACHE_CHECK([assembler and linker support unaligned pc related relocs],\n \tlibffi_cv_as_sparc_ua_pcrel, [\n \tsave_CFLAGS=\"$CFLAGS\"\n@@ -141,9 +142,9 @@ if test x$TARGET = xSPARC; then\n        AC_DEFINE(HAVE_AS_REGISTER_PSEUDO_OP, 1,\n \t       [Define if your assembler supports .register.])\n     fi\n-fi\n+    ;;\n \n-if test x$TARGET = xX86 || test x$TARGET = xX86_WIN32 || test x$TARGET = xX86_64; then\n+  X86*)\n     AC_CACHE_CHECK([assembler supports pc related relocs],\n \tlibffi_cv_as_x86_pcrel, [\n \tlibffi_cv_as_x86_pcrel=no\n@@ -156,35 +157,9 @@ if test x$TARGET = xX86 || test x$TARGET = xX86_WIN32 || test x$TARGET = xX86_64\n \tAC_DEFINE(HAVE_AS_X86_PCREL, 1,\n \t\t  [Define if your assembler supports PC relative relocs.])\n     fi\n+    ;;\n \n-    AC_CACHE_CHECK([assembler .ascii pseudo-op support],\n-       libffi_cv_as_ascii_pseudo_op, [\n-       libffi_cv_as_ascii_pseudo_op=unknown\n-       # Check if we have .ascii\n-       AC_TRY_COMPILE(,[asm (\".ascii \\\\\"string\\\\\"\");],\n-\t\t       [libffi_cv_as_ascii_pseudo_op=yes],\n-\t\t       [libffi_cv_as_ascii_pseudo_op=no])\n-    ])\n-    if test \"x$libffi_cv_as_ascii_pseudo_op\" = xyes; then\n-       AC_DEFINE(HAVE_AS_ASCII_PSEUDO_OP, 1,\n-\t       [Define if your assembler supports .ascii.])\n-    fi\n-\n-    AC_CACHE_CHECK([assembler .string pseudo-op support],\n-       libffi_cv_as_string_pseudo_op, [\n-       libffi_cv_as_string_pseudo_op=unknown\n-       # Check if we have .string\n-       AC_TRY_COMPILE(,[asm (\".string \\\\\"string\\\\\"\");],\n-\t\t       [libffi_cv_as_string_pseudo_op=yes],\n-\t\t       [libffi_cv_as_string_pseudo_op=no])\n-    ])\n-    if test \"x$libffi_cv_as_string_pseudo_op\" = xyes; then\n-       AC_DEFINE(HAVE_AS_STRING_PSEUDO_OP, 1,\n-\t       [Define if your assembler supports .string.])\n-    fi\n-fi\n-\n-if test x$TARGET = xS390; then\n+  S390)\n     AC_CACHE_CHECK([compiler uses zarch features],\n \tlibffi_cv_as_s390_zarch, [\n \tlibffi_cv_as_s390_zarch=no\n@@ -199,7 +174,8 @@ if test x$TARGET = xS390; then\n \tAC_DEFINE(HAVE_AS_S390_ZARCH, 1,\n \t\t  [Define if the compiler uses zarch features.])\n     fi\n-fi\n+    ;;\n+esac\n \n # On PaX enable kernels that have MPROTECT enable we can't use PROT_EXEC.\n AC_ARG_ENABLE(pax_emutramp,\n@@ -211,7 +187,7 @@ AC_ARG_ENABLE(pax_emutramp,\n \n FFI_EXEC_TRAMPOLINE_TABLE=0\n case \"$target\" in\n-     *arm*-apple-darwin*)\n+     *arm*-apple-darwin* | aarch64-apple-darwin*)\n        FFI_EXEC_TRAMPOLINE_TABLE=1\n        AC_DEFINE(FFI_EXEC_TRAMPOLINE_TABLE, 1,\n                  [Cannot use PROT_EXEC on this target, so, we revert to"}, {"sha": "b9887a8c65b75a4908cb45ec71e9a419737150a7", "filename": "libffi/doc/libffi.texi", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed4bf691b5a6d267325f6a423e3764175b808efe/libffi%2Fdoc%2Flibffi.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed4bf691b5a6d267325f6a423e3764175b808efe/libffi%2Fdoc%2Flibffi.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fdoc%2Flibffi.texi?ref=ed4bf691b5a6d267325f6a423e3764175b808efe", "patch": "@@ -747,11 +747,6 @@ Variadic closures.\n @item\n There is no support for bit fields in structures.\n \n-@item\n-The closure API is\n-\n-@c FIXME: ...\n-\n @item\n The ``raw'' API is undocumented.\n @c argument promotion?"}, {"sha": "f79602bb7b8b7611be975b25337484a2331b81ba", "filename": "libffi/src/aarch64/ffi.c", "status": "modified", "additions": 255, "deletions": 13, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed4bf691b5a6d267325f6a423e3764175b808efe/libffi%2Fsrc%2Faarch64%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed4bf691b5a6d267325f6a423e3764175b808efe/libffi%2Fsrc%2Faarch64%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Faarch64%2Fffi.c?ref=ed4bf691b5a6d267325f6a423e3764175b808efe", "patch": "@@ -725,38 +725,280 @@ ffi_call_go (ffi_cif *cif, void (*fn) (void), void *rvalue,\n extern void ffi_closure_SYSV (void) FFI_HIDDEN;\n extern void ffi_closure_SYSV_V (void) FFI_HIDDEN;\n \n+#if FFI_EXEC_TRAMPOLINE_TABLE\n+\n+#include <mach/mach.h>\n+#include <pthread.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+extern void *ffi_closure_trampoline_table_page;\n+\n+typedef struct ffi_trampoline_table ffi_trampoline_table;\n+typedef struct ffi_trampoline_table_entry ffi_trampoline_table_entry;\n+\n+struct ffi_trampoline_table\n+{\n+  /* contiguous writable and executable pages */\n+  vm_address_t config_page;\n+  vm_address_t trampoline_page;\n+\n+  /* free list tracking */\n+  uint16_t free_count;\n+  ffi_trampoline_table_entry *free_list;\n+  ffi_trampoline_table_entry *free_list_pool;\n+\n+  ffi_trampoline_table *prev;\n+  ffi_trampoline_table *next;\n+};\n+\n+struct ffi_trampoline_table_entry\n+{\n+  void *(*trampoline) ();\n+  ffi_trampoline_table_entry *next;\n+};\n+\n+/* The trampoline configuration is placed a page prior to the trampoline's entry point */\n+#define FFI_TRAMPOLINE_CODELOC_CONFIG(codeloc) ((void **) (((uint8_t *) codeloc) - PAGE_SIZE));\n+\n+/* Total number of trampolines that fit in one trampoline table */\n+#define FFI_TRAMPOLINE_COUNT (PAGE_SIZE / FFI_TRAMPOLINE_SIZE)\n+\n+static pthread_mutex_t ffi_trampoline_lock = PTHREAD_MUTEX_INITIALIZER;\n+static ffi_trampoline_table *ffi_trampoline_tables = NULL;\n+\n+static ffi_trampoline_table *\n+ffi_trampoline_table_alloc ()\n+{\n+  ffi_trampoline_table *table = NULL;\n+\n+  /* Loop until we can allocate two contiguous pages */\n+  while (table == NULL)\n+    {\n+      vm_address_t config_page = 0x0;\n+      kern_return_t kt;\n+\n+      /* Try to allocate two pages */\n+      kt =\n+\tvm_allocate (mach_task_self (), &config_page, PAGE_SIZE * 2,\n+\t\t     VM_FLAGS_ANYWHERE);\n+      if (kt != KERN_SUCCESS)\n+\t{\n+\t  fprintf (stderr, \"vm_allocate() failure: %d at %s:%d\\n\", kt,\n+\t\t   __FILE__, __LINE__);\n+\t  break;\n+\t}\n+\n+      /* Now drop the second half of the allocation to make room for the trampoline table */\n+      vm_address_t trampoline_page = config_page + PAGE_SIZE;\n+      kt = vm_deallocate (mach_task_self (), trampoline_page, PAGE_SIZE);\n+      if (kt != KERN_SUCCESS)\n+\t{\n+\t  fprintf (stderr, \"vm_deallocate() failure: %d at %s:%d\\n\", kt,\n+\t\t   __FILE__, __LINE__);\n+\t  break;\n+\t}\n+\n+      /* Remap the trampoline table to directly follow the config page */\n+      vm_prot_t cur_prot;\n+      vm_prot_t max_prot;\n+\n+      kt =\n+\tvm_remap (mach_task_self (), &trampoline_page, PAGE_SIZE, 0x0, FALSE,\n+\t\t  mach_task_self (),\n+\t\t  (vm_address_t) & ffi_closure_trampoline_table_page, FALSE,\n+\t\t  &cur_prot, &max_prot, VM_INHERIT_SHARE);\n+\n+      /* If we lost access to the destination trampoline page, drop our config allocation mapping and retry */\n+      if (kt != KERN_SUCCESS)\n+\t{\n+\t  /* Log unexpected failures */\n+\t  if (kt != KERN_NO_SPACE)\n+\t    {\n+\t      fprintf (stderr, \"vm_remap() failure: %d at %s:%d\\n\", kt,\n+\t\t       __FILE__, __LINE__);\n+\t    }\n+\n+\t  vm_deallocate (mach_task_self (), config_page, PAGE_SIZE);\n+\t  continue;\n+\t}\n+\n+      /* We have valid trampoline and config pages */\n+      table = calloc (1, sizeof (ffi_trampoline_table));\n+      table->free_count = FFI_TRAMPOLINE_COUNT;\n+      table->config_page = config_page;\n+      table->trampoline_page = trampoline_page;\n+\n+      /* Create and initialize the free list */\n+      table->free_list_pool =\n+\tcalloc (FFI_TRAMPOLINE_COUNT, sizeof (ffi_trampoline_table_entry));\n+\n+      uint16_t i;\n+      for (i = 0; i < table->free_count; i++)\n+\t{\n+\t  ffi_trampoline_table_entry *entry = &table->free_list_pool[i];\n+\t  entry->trampoline =\n+\t    (void *) (table->trampoline_page + (i * FFI_TRAMPOLINE_SIZE));\n+\n+\t  if (i < table->free_count - 1)\n+\t    entry->next = &table->free_list_pool[i + 1];\n+\t}\n+\n+      table->free_list = table->free_list_pool;\n+    }\n+\n+  return table;\n+}\n+\n+void *\n+ffi_closure_alloc (size_t size, void **code)\n+{\n+  /* Create the closure */\n+  ffi_closure *closure = malloc (size);\n+  if (closure == NULL)\n+    return NULL;\n+\n+  pthread_mutex_lock (&ffi_trampoline_lock);\n+\n+  /* Check for an active trampoline table with available entries. */\n+  ffi_trampoline_table *table = ffi_trampoline_tables;\n+  if (table == NULL || table->free_list == NULL)\n+    {\n+      table = ffi_trampoline_table_alloc ();\n+      if (table == NULL)\n+\t{\n+\t  free (closure);\n+\t  return NULL;\n+\t}\n+\n+      /* Insert the new table at the top of the list */\n+      table->next = ffi_trampoline_tables;\n+      if (table->next != NULL)\n+\ttable->next->prev = table;\n+\n+      ffi_trampoline_tables = table;\n+    }\n+\n+  /* Claim the free entry */\n+  ffi_trampoline_table_entry *entry = ffi_trampoline_tables->free_list;\n+  ffi_trampoline_tables->free_list = entry->next;\n+  ffi_trampoline_tables->free_count--;\n+  entry->next = NULL;\n+\n+  pthread_mutex_unlock (&ffi_trampoline_lock);\n+\n+  /* Initialize the return values */\n+  *code = entry->trampoline;\n+  closure->trampoline_table = table;\n+  closure->trampoline_table_entry = entry;\n+\n+  return closure;\n+}\n+\n+void\n+ffi_closure_free (void *ptr)\n+{\n+  ffi_closure *closure = ptr;\n+\n+  pthread_mutex_lock (&ffi_trampoline_lock);\n+\n+  /* Fetch the table and entry references */\n+  ffi_trampoline_table *table = closure->trampoline_table;\n+  ffi_trampoline_table_entry *entry = closure->trampoline_table_entry;\n+\n+  /* Return the entry to the free list */\n+  entry->next = table->free_list;\n+  table->free_list = entry;\n+  table->free_count++;\n+\n+  /* If all trampolines within this table are free, and at least one other table exists, deallocate\n+   * the table */\n+  if (table->free_count == FFI_TRAMPOLINE_COUNT\n+      && ffi_trampoline_tables != table)\n+    {\n+      /* Remove from the list */\n+      if (table->prev != NULL)\n+\ttable->prev->next = table->next;\n+\n+      if (table->next != NULL)\n+\ttable->next->prev = table->prev;\n+\n+      /* Deallocate pages */\n+      kern_return_t kt;\n+      kt = vm_deallocate (mach_task_self (), table->config_page, PAGE_SIZE);\n+      if (kt != KERN_SUCCESS)\n+\tfprintf (stderr, \"vm_deallocate() failure: %d at %s:%d\\n\", kt,\n+\t\t __FILE__, __LINE__);\n+\n+      kt =\n+\tvm_deallocate (mach_task_self (), table->trampoline_page, PAGE_SIZE);\n+      if (kt != KERN_SUCCESS)\n+\tfprintf (stderr, \"vm_deallocate() failure: %d at %s:%d\\n\", kt,\n+\t\t __FILE__, __LINE__);\n+\n+      /* Deallocate free list */\n+      free (table->free_list_pool);\n+      free (table);\n+    }\n+  else if (ffi_trampoline_tables != table)\n+    {\n+      /* Otherwise, bump this table to the top of the list */\n+      table->prev = NULL;\n+      table->next = ffi_trampoline_tables;\n+      if (ffi_trampoline_tables != NULL)\n+\tffi_trampoline_tables->prev = table;\n+\n+      ffi_trampoline_tables = table;\n+    }\n+\n+  pthread_mutex_unlock (&ffi_trampoline_lock);\n+\n+  /* Free the closure */\n+  free (closure);\n+}\n+\n+#endif\n+\n ffi_status\n ffi_prep_closure_loc (ffi_closure *closure,\n                       ffi_cif* cif,\n                       void (*fun)(ffi_cif*,void*,void**,void*),\n                       void *user_data,\n                       void *codeloc)\n {\n+  if (cif->abi != FFI_SYSV)\n+    return FFI_BAD_ABI;\n+\n+  void (*start)(void);\n+  \n+  if (cif->flags & AARCH64_FLAG_ARG_V)\n+    start = ffi_closure_SYSV_V;\n+  else\n+    start = ffi_closure_SYSV;\n+\n+#if FFI_EXEC_TRAMPOLINE_TABLE\n+  void **config = FFI_TRAMPOLINE_CODELOC_CONFIG (codeloc);\n+  config[0] = closure;\n+  config[1] = start;\n+#else\n   static const unsigned char trampoline[16] = {\n     0x90, 0x00, 0x00, 0x58,\t/* ldr\tx16, tramp+16\t*/\n     0xf1, 0xff, 0xff, 0x10,\t/* adr\tx17, tramp+0\t*/\n     0x00, 0x02, 0x1f, 0xd6\t/* br\tx16\t\t*/\n   };\n   char *tramp = closure->tramp;\n-  void (*start)(void);\n+  \n+  memcpy (tramp, trampoline, sizeof(trampoline));\n+  \n+  *(UINT64 *)(tramp + 16) = (uintptr_t)start;\n \n-  if (cif->abi != FFI_SYSV)\n-    return FFI_BAD_ABI;\n+  ffi_clear_cache(tramp, tramp + FFI_TRAMPOLINE_SIZE);\n+#endif\n \n   closure->cif = cif;\n   closure->fun = fun;\n   closure->user_data = user_data;\n \n-  memcpy (tramp, trampoline, sizeof(trampoline));\n-\n-  if (cif->flags & AARCH64_FLAG_ARG_V)\n-    start = ffi_closure_SYSV_V;\n-  else\n-    start = ffi_closure_SYSV;\n-  *(UINT64 *)(tramp + 16) = (uintptr_t)start;\n-\n-  ffi_clear_cache(tramp, tramp + FFI_TRAMPOLINE_SIZE);\n-\n   return FFI_OK;\n }\n "}, {"sha": "fca2811ae214fc89a2ec48fdd99e96425ec774f9", "filename": "libffi/src/aarch64/ffitarget.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed4bf691b5a6d267325f6a423e3764175b808efe/libffi%2Fsrc%2Faarch64%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed4bf691b5a6d267325f6a423e3764175b808efe/libffi%2Fsrc%2Faarch64%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Faarch64%2Fffitarget.h?ref=ed4bf691b5a6d267325f6a423e3764175b808efe", "patch": "@@ -42,7 +42,13 @@ typedef enum ffi_abi\n /* ---- Definitions for closures ----------------------------------------- */\n \n #define FFI_CLOSURES 1\n+#if defined (__APPLE__)\n+#define FFI_TRAMPOLINE_SIZE 20\n+#define FFI_TRAMPOLINE_CLOSURE_OFFSET 16\n+#else\n #define FFI_TRAMPOLINE_SIZE 24\n+#define FFI_TRAMPOLINE_CLOSURE_OFFSET FFI_TRAMPOLINE_SIZE\n+#endif\n #define FFI_NATIVE_RAW_API 0\n \n /* ---- Internal ---- */"}, {"sha": "46f50b9ef21818c7b5eda59964ff7a27746322ff", "filename": "libffi/src/aarch64/sysv.S", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed4bf691b5a6d267325f6a423e3764175b808efe/libffi%2Fsrc%2Faarch64%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed4bf691b5a6d267325f6a423e3764175b808efe/libffi%2Fsrc%2Faarch64%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Faarch64%2Fsysv.S?ref=ed4bf691b5a6d267325f6a423e3764175b808efe", "patch": "@@ -134,17 +134,17 @@ CNAME(ffi_call_SYSV):\n \tret\n 7:\tbrk\t#1000\t\t\t/* UNUSED */\n \tret\n-8:\tst4\t{ v0.s-v3.s }[0], [x3]\t/* S4 */\n+8:\tst4\t{ v0.s, v1.s, v2.s, v3.s }[0], [x3]\t/* S4 */\n \tret\n-9:\tst3\t{ v0.s-v2.s }[0], [x3]\t/* S3 */\n+9:\tst3\t{ v0.s, v1.s, v2.s }[0], [x3]\t/* S3 */\n \tret\n 10:\tstp\ts0, s1, [x3]\t\t/* S2 */\n \tret\n 11:\tstr\ts0, [x3]\t\t/* S1 */\n \tret\n-12:\tst4\t{ v0.d-v3.d }[0], [x3]\t/* D4 */\n+12:\tst4\t{ v0.d, v1.d, v2.d, v3.d }[0], [x3]\t/* D4 */\n \tret\n-13:\tst3\t{ v0.d-v2.d }[0], [x3]\t/* D3 */\n+13:\tst3\t{ v0.d, v1.d, v2.d }[0], [x3]\t/* D3 */\n \tret\n 14:\tstp\td0, d1, [x3]\t\t/* D2 */\n \tret\n@@ -248,8 +248,8 @@ CNAME(ffi_closure_SYSV):\n \tstp     x6, x7, [sp, #16 + 16*N_V_ARG_REG + 48]\n \n \t/* Load ffi_closure_inner arguments.  */\n-\tldp\tx0, x1, [x17, #FFI_TRAMPOLINE_SIZE]\t/* load cif, fn */\n-\tldr\tx2, [x17, #FFI_TRAMPOLINE_SIZE+16]\t/* load user_data */\n+\tldp\tx0, x1, [x17, #FFI_TRAMPOLINE_CLOSURE_OFFSET]\t/* load cif, fn */\n+\tldr\tx2, [x17, #FFI_TRAMPOLINE_CLOSURE_OFFSET+16]\t/* load user_data */\n .Ldo_closure:\n \tadd\tx3, sp, #16\t\t\t\t/* load context */\n \tadd\tx4, sp, #ffi_closure_SYSV_FS\t\t/* load stack */\n@@ -343,6 +343,25 @@ CNAME(ffi_closure_SYSV):\n \t.size\tCNAME(ffi_closure_SYSV), . - CNAME(ffi_closure_SYSV)\n #endif\n \n+#if FFI_EXEC_TRAMPOLINE_TABLE\n+    .align 12\n+CNAME(ffi_closure_trampoline_table_page):\n+    .rept 16384 / FFI_TRAMPOLINE_SIZE\n+    adr\tx17, -16384\n+    adr\tx16, -16380\n+    ldr x16, [x16]\n+    ldr x17, [x17]\n+    br\tx16\n+    .endr\n+    \n+    .globl CNAME(ffi_closure_trampoline_table_page)\n+    #ifdef __ELF__\n+    \t.type\tCNAME(ffi_closure_trampoline_table_page), #function\n+    \t.hidden\tCNAME(ffi_closure_trampoline_table_page)\n+    \t.size\tCNAME(ffi_closure_trampoline_table_page), . - CNAME(ffi_closure_trampoline_table_page)\n+    #endif\n+#endif\n+\n #ifdef FFI_GO_CLOSURES\n \t.align 4\n CNAME(ffi_go_closure_SYSV_V):"}, {"sha": "a2e4908fd417a707260994f2ffbf9e31355eccaa", "filename": "libffi/src/sparc/v8.S", "status": "modified", "additions": 81, "deletions": 21, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed4bf691b5a6d267325f6a423e3764175b808efe/libffi%2Fsrc%2Fsparc%2Fv8.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed4bf691b5a6d267325f6a423e3764175b808efe/libffi%2Fsrc%2Fsparc%2Fv8.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fv8.S?ref=ed4bf691b5a6d267325f6a423e3764175b808efe", "patch": "@@ -28,7 +28,6 @@\n #define LIBFFI_ASM\n #include <fficonfig.h>\n #include <ffi.h>\n-#include <ffi_cfi.h>\n #include \"internal.h\"\n \n #ifndef SPARC64\n@@ -52,7 +51,6 @@\n \tFFI_HIDDEN(C(ffi_flush_icache))\n \n C(ffi_flush_icache):\n-\tcfi_startproc\n 1:\tiflush %o0\n \tiflush %o+8\n \tnop\n@@ -62,7 +60,6 @@ C(ffi_flush_icache):\n \tnop\n \tretl\n \t nop\n-\tcfi_endproc\n \t.size\tC(ffi_flush_icache), . - C(ffi_flush_icache)\n #endif\n \n@@ -78,13 +75,10 @@ C(ffi_flush_icache):\n \tFFI_HIDDEN(C(ffi_call_v8))\n \n C(ffi_call_v8):\n-\tcfi_startproc\n+.LUW0:\n \t! Allocate a stack frame sized by ffi_call.\n \tsave\t%sp, %o4, %sp\n-\tcfi_def_cfa_register(%fp)\n-\tcfi_window_save\n-\tcfi_register(%o7, %i7)\n-\n+.LUW1:\n \tmov\t%i0, %o0\t\t! copy cif\n \tadd\t%sp, 64+32, %o1\t\t! load args area\n \tmov\t%i2, %o2\t\t! copy rvalue\n@@ -233,7 +227,7 @@ E(SPARC_RET_F_1)\n \trept256; rept256; rept256; rept256\n \trept256; rept256; rept256; rept256\n \n-\tcfi_endproc\n+.LUW2:\n \t.size\tC(ffi_call_v8),. - C(ffi_call_v8)\n \n \n@@ -255,17 +249,14 @@ E(SPARC_RET_F_1)\n \tFFI_HIDDEN(C(ffi_go_closure_v8))\n \n C(ffi_go_closure_v8):\n-\tcfi_startproc\n+.LUW3:\n \tsave\t%sp, -STACKFRAME, %sp\n-\tcfi_def_cfa_register(%fp)\n-\tcfi_window_save\n-\tcfi_register(%o7, %i7)\n-\n+.LUW4:\n \tld\t[%g2+4], %o0\t\t\t! load cif\n \tld\t[%g2+8], %o1\t\t\t! load fun\n \tb\t0f\n \t mov\t%g2, %o2\t\t\t! load user_data\n-\tcfi_endproc\n+.LUW5:\n \t.size\tC(ffi_go_closure_v8), . - C(ffi_go_closure_v8)\n \n \t.align 8\n@@ -274,12 +265,9 @@ C(ffi_go_closure_v8):\n \tFFI_HIDDEN(C(ffi_closure_v8))\n \n C(ffi_closure_v8):\n-\tcfi_startproc\n+.LUW6:\n \tsave\t%sp, -STACKFRAME, %sp\n-\tcfi_def_cfa_register(%fp)\n-\tcfi_window_save\n-\tcfi_register(%o7, %i7)\n-\n+.LUW7:\n \tld\t[%g2+FFI_TRAMPOLINE_SIZE], %o0\t\t! load cif\n \tld\t[%g2+FFI_TRAMPOLINE_SIZE+4], %o1\t! load fun\n \tld\t[%g2+FFI_TRAMPOLINE_SIZE+8], %o2\t! load user_data\n@@ -375,8 +363,80 @@ E(SPARC_RET_F_1)\n \tret\n \t restore\n \n-\tcfi_endproc\n+.LUW8:\n \t.size\tC(ffi_closure_v8), . - C(ffi_closure_v8)\n+\n+#ifdef HAVE_RO_EH_FRAME\n+        .section        \".eh_frame\",#alloc\n+#else\n+        .section        \".eh_frame\",#alloc,#write\n+#endif\n+\n+#ifdef HAVE_AS_SPARC_UA_PCREL\n+# define FDE_ADDR(X)\t%r_disp32(X)\n+#else\n+# define FDE_ADDR(X)\tX\n+#endif\n+\n+\t.align 4\n+.LCIE:\n+\t.long\t.LECIE - .LSCIE\t\t! CIE Length\n+.LSCIE:\n+\t.long\t0\t\t\t! CIE Identifier Tag\n+\t.byte\t1\t\t\t! CIE Version\n+\t.ascii\t\"zR\\0\"\t\t\t! CIE Augmentation\n+\t.byte\t4\t\t\t! CIE Code Alignment Factor\n+\t.byte\t0x7c\t\t\t! CIE Data Alignment Factor\n+\t.byte\t15\t\t\t! CIE RA Column\n+\t.byte\t1\t\t\t! Augmentation size\n+#ifdef HAVE_AS_SPARC_UA_PCREL\n+\t.byte\t0x1b\t\t\t! FDE Encoding (pcrel sdata4)\n+#else\n+\t.byte\t0x50\t\t\t! FDE Encoding (aligned absolute)\n+#endif\n+\t.byte\t0xc, 14, 0\t\t! DW_CFA_def_cfa, %o6, offset 0\n+\t.align\t4\n+.LECIE:\n+\n+\t.long\t.LEFDE1 - .LSFDE1\t! FDE Length\n+.LSFDE1:\n+\t.long\t.LSFDE1 - .LCIE\t\t! FDE CIE offset\n+\t.long\tFDE_ADDR(.LUW0)\t\t! Initial location\n+\t.long\t.LUW2 - .LUW0\t\t! Address range\n+\t.byte\t0\t\t\t! Augmentation size\n+\t.byte\t0x40+1\t\t\t! DW_CFA_advance_loc 4\n+\t.byte\t0xd, 30\t\t\t! DW_CFA_def_cfa_register, %i6\n+\t.byte\t0x2d\t\t\t! DW_CFA_GNU_window_save\n+\t.byte\t0x9, 15, 31\t\t! DW_CFA_register, %o7, %i7\n+\t.align\t4\n+.LEFDE1:\n+\n+\t.long\t.LEFDE2 - .LSFDE2\t! FDE Length\n+.LSFDE2:\n+\t.long\t.LSFDE2 - .LCIE\t\t! FDE CIE offset\n+\t.long\tFDE_ADDR(.LUW3)\t\t! Initial location\n+\t.long\t.LUW5 - .LUW3\t\t! Address range\n+\t.byte\t0\t\t\t! Augmentation size\n+\t.byte\t0x40+1\t\t\t! DW_CFA_advance_loc 4\n+\t.byte\t0xd, 30\t\t\t! DW_CFA_def_cfa_register, %i6\n+\t.byte\t0x2d\t\t\t! DW_CFA_GNU_window_save\n+\t.byte\t0x9, 15, 31\t\t! DW_CFA_register, %o7, %i7\n+\t.align\t4\n+.LEFDE2:\n+\n+\t.long\t.LEFDE3 - .LSFDE3\t! FDE Length\n+.LSFDE3:\n+\t.long\t.LSFDE3 - .LCIE\t\t! FDE CIE offset\n+\t.long\tFDE_ADDR(.LUW6)\t\t! Initial location\n+\t.long\t.LUW8 - .LUW6\t\t! Address range\n+\t.byte\t0\t\t\t! Augmentation size\n+\t.byte\t0x40+1\t\t\t! DW_CFA_advance_loc 4\n+\t.byte\t0xd, 30\t\t\t! DW_CFA_def_cfa_register, %i6\n+\t.byte\t0x2d\t\t\t! DW_CFA_GNU_window_save\n+\t.byte\t0x9, 15, 31\t\t! DW_CFA_register, %o7, %i7\n+\t.align\t4\n+.LEFDE3:\n+\n #endif /* !SPARC64 */\n #if defined __ELF__ && defined __linux__\n \t.section\t.note.GNU-stack,\"\",@progbits"}, {"sha": "55f8f4324cfeba4c1c580fb78139a7875c3c9c87", "filename": "libffi/src/sparc/v9.S", "status": "modified", "additions": 78, "deletions": 19, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed4bf691b5a6d267325f6a423e3764175b808efe/libffi%2Fsrc%2Fsparc%2Fv9.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed4bf691b5a6d267325f6a423e3764175b808efe/libffi%2Fsrc%2Fsparc%2Fv9.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fv9.S?ref=ed4bf691b5a6d267325f6a423e3764175b808efe", "patch": "@@ -27,7 +27,6 @@\n #define LIBFFI_ASM\t\n #include <fficonfig.h>\n #include <ffi.h>\n-#include <ffi_cfi.h>\n #include \"internal.h\"\n \n #ifdef SPARC64\n@@ -57,12 +56,9 @@\n \tFFI_HIDDEN(C(ffi_call_v9))\n \n C(ffi_call_v9):\n-\tcfi_startproc\n+.LUW0:\n \tsave\t%sp, %o4, %sp\n-\tcfi_def_cfa_register(%fp)\n-\tcfi_window_save\n-\tcfi_register(%o7, %i7)\n-\t\n+.LUW1:\n \tmov\t%i0, %o0\t\t\t! copy cif\n \tadd\t%sp, STACK_BIAS+128+48, %o1\t! load args area\n \tmov\t%i2, %o2\t\t\t! copy rvalue\n@@ -199,7 +195,7 @@ E(SPARC_RET_F_1)\n \treturn\t%i7+8\n \t nop\n \n-\tcfi_endproc\n+.LUW2:\n \t.size\tC(ffi_call_v9), . - C(ffi_call_v9)\n \n \n@@ -219,18 +215,15 @@ E(SPARC_RET_F_1)\n \tFFI_HIDDEN(C(ffi_go_closure_v9))\n \n C(ffi_go_closure_v9):\n-\tcfi_startproc\n+.LUW3:\n \tsave\t%sp, -STACKFRAME, %sp\n-\tcfi_def_cfa_register(%fp)\n-\tcfi_window_save\n-\tcfi_register(%o7, %i7)\n-\n+.LUW4:\n \tldx\t[%g5+8], %o0\n \tldx\t[%g5+16], %o1\n \tb\t0f\n \t mov\t%g5, %o2\n \n-\tcfi_endproc\n+.LUW5:\n \t.size\tC(ffi_go_closure_v9), . - C(ffi_go_closure_v9)\n \n \t.align 8\n@@ -239,12 +232,9 @@ C(ffi_go_closure_v9):\n \tFFI_HIDDEN(C(ffi_closure_v9))\n \n C(ffi_closure_v9):\n-\tcfi_startproc\n+.LUW6:\n \tsave\t%sp, -STACKFRAME, %sp\n-\tcfi_def_cfa_register(%fp)\n-\tcfi_window_save\n-\tcfi_register(%o7, %i7)\n-\n+.LUW7:\n \tldx\t[%g1+FFI_TRAMPOLINE_SIZE], %o0\n \tldx\t[%g1+FFI_TRAMPOLINE_SIZE+8], %o1\n \tldx\t[%g1+FFI_TRAMPOLINE_SIZE+16], %o2\n@@ -373,8 +363,77 @@ E(SPARC_RET_F_1)\n \treturn\t%i7+8\n \t nop\n \n-\tcfi_endproc\n+.LUW8:\n \t.size\tC(ffi_closure_v9), . - C(ffi_closure_v9)\n+\n+#ifdef HAVE_RO_EH_FRAME\n+        .section        \".eh_frame\",#alloc\n+#else\n+        .section        \".eh_frame\",#alloc,#write\n+#endif\n+\n+#ifdef HAVE_AS_SPARC_UA_PCREL\n+# define FDE_RANGE(B, E)  .long %r_disp32(B), E - B\n+#else\n+# define FDE_RANGE(B, E)  .align 8; .xword B, E - B\n+#endif\n+\n+\t.align 8\n+.LCIE:\n+\t.long\t.LECIE - .LSCIE\t\t! CIE Length\n+.LSCIE:\n+\t.long\t0\t\t\t! CIE Identifier Tag\n+\t.byte\t1\t\t\t! CIE Version\n+\t.ascii\t\"zR\\0\"\t\t\t! CIE Augmentation\n+\t.byte\t4\t\t\t! CIE Code Alignment Factor\n+\t.byte\t0x78\t\t\t! CIE Data Alignment Factor\n+\t.byte\t15\t\t\t! CIE RA Column\n+\t.byte\t1\t\t\t! Augmentation size\n+#ifdef HAVE_AS_SPARC_UA_PCREL\n+\t.byte\t0x1b\t\t\t! FDE Encoding (pcrel sdata4)\n+#else\n+\t.byte\t0x50\t\t\t! FDE Encoding (aligned absolute)\n+#endif\n+\t.byte\t0xc, 14, 0xff, 0xf\t! DW_CFA_def_cfa, %o6, offset 0x7ff\n+\t.align\t8\n+.LECIE:\n+\n+\t.long\t.LEFDE1 - .LSFDE1\t! FDE Length\n+.LSFDE1:\n+\t.long\t.LSFDE1 - .LCIE\t\t! FDE CIE offset\n+\tFDE_RANGE(.LUW0, .LUW2)\n+\t.byte\t0\t\t\t! Augmentation size\n+\t.byte\t0x40+1\t\t\t! DW_CFA_advance_loc 4\n+\t.byte\t0xd, 30\t\t\t! DW_CFA_def_cfa_register, %i6\n+\t.byte\t0x2d\t\t\t! DW_CFA_GNU_window_save\n+\t.byte\t0x9, 15, 31\t\t! DW_CFA_register, %o7, %i7\n+\t.align\t8\n+.LEFDE1:\n+\n+\t.long\t.LEFDE2 - .LSFDE2\t! FDE Length\n+.LSFDE2:\n+\t.long\t.LSFDE2 - .LCIE\t\t! FDE CIE offset\n+\tFDE_RANGE(.LUW3, .LUW5)\n+\t.byte\t0\t\t\t! Augmentation size\n+\t.byte\t0x40+1\t\t\t! DW_CFA_advance_loc 4\n+\t.byte\t0xd, 30\t\t\t! DW_CFA_def_cfa_register, %i6\n+\t.byte\t0x2d\t\t\t! DW_CFA_GNU_window_save\n+\t.byte\t0x9, 15, 31\t\t! DW_CFA_register, %o7, %i7\n+\t.align\t8\n+.LEFDE2:\n+\n+\t.long\t.LEFDE3 - .LSFDE3\t! FDE Length\n+.LSFDE3:\n+\t.long\t.LSFDE3 - .LCIE\t\t! FDE CIE offset\n+\tFDE_RANGE(.LUW6, .LUW8)\n+\t.byte\t0\t\t\t! Augmentation size\n+\t.byte\t0x40+1\t\t\t! DW_CFA_advance_loc 4\n+\t.byte\t0xd, 30\t\t\t! DW_CFA_def_cfa_register, %i6\n+\t.byte\t0x2d\t\t\t! DW_CFA_GNU_window_save\n+\t.byte\t0x9, 15, 31\t\t! DW_CFA_register, %o7, %i7\n+\t.align\t8\n+.LEFDE3:\n+\n #endif /* SPARC64 */\n #ifdef __linux__\n \t.section\t.note.GNU-stack,\"\",@progbits"}]}