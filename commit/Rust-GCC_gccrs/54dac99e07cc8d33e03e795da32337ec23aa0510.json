{"sha": "54dac99e07cc8d33e03e795da32337ec23aa0510", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRkYWM5OWUwN2NjOGQzM2UwM2U3OTVkYTMyMzM3ZWMyM2FhMDUxMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-11-05T23:39:50Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-11-05T23:39:50Z"}, "message": "Initial revision\n\nFrom-SVN: r56", "tree": {"sha": "8d7c3a647f58546578c58acac0de0e6a43b40eb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d7c3a647f58546578c58acac0de0e6a43b40eb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54dac99e07cc8d33e03e795da32337ec23aa0510", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54dac99e07cc8d33e03e795da32337ec23aa0510", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54dac99e07cc8d33e03e795da32337ec23aa0510", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54dac99e07cc8d33e03e795da32337ec23aa0510/comments", "author": null, "committer": null, "parents": [{"sha": "d14a15b6c5e6794076008446696c53fe808d5c11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d14a15b6c5e6794076008446696c53fe808d5c11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d14a15b6c5e6794076008446696c53fe808d5c11"}], "stats": {"total": 1132, "additions": 1132, "deletions": 0}, "files": [{"sha": "8416a7cf6dfca56f17d6760940e0302136e2569b", "filename": "gcc/regclass.c", "status": "added", "additions": 1132, "deletions": 0, "changes": 1132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54dac99e07cc8d33e03e795da32337ec23aa0510/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54dac99e07cc8d33e03e795da32337ec23aa0510/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=54dac99e07cc8d33e03e795da32337ec23aa0510", "patch": "@@ -0,0 +1,1132 @@\n+/* Compute register class preferences for pseudo-registers.\n+   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* This file contains two passes of the compiler: reg_scan and reg_class.\n+   It also defines some tables of information about the hardware registers\n+   and a function init_reg_sets to initialize the tables.  */\n+\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n+#include \"flags.h\"\n+#include \"basic-block.h\"\n+#include \"regs.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+\n+#ifndef REGISTER_MOVE_COST\n+#define REGISTER_MOVE_COST(x, y) 2\n+#endif\n+\n+#ifndef MEMORY_MOVE_COST\n+#define MEMORY_MOVE_COST(x) 2\n+#endif\n+\f\n+/* Register tables used by many passes.  */\n+\n+/* Indexed by hard register number, contains 1 for registers\n+   that are fixed use (stack pointer, pc, frame pointer, etc.).\n+   These are the registers that cannot be used to allocate\n+   a pseudo reg whose life does not cross calls.  */\n+\n+char fixed_regs[FIRST_PSEUDO_REGISTER];\n+\n+/* Same info as a HARD_REG_SET.  */\n+\n+HARD_REG_SET fixed_reg_set;\n+\n+/* Data for initializing the above.  */\n+\n+static char initial_fixed_regs[] = FIXED_REGISTERS;\n+\n+/* Indexed by hard register number, contains 1 for registers\n+   that are fixed use or are clobbered by function calls.\n+   These are the registers that cannot be used to allocate\n+   a pseudo reg whose life crosses calls.  */\n+\n+char call_used_regs[FIRST_PSEUDO_REGISTER];\n+\n+/* Same info as a HARD_REG_SET.  */\n+\n+HARD_REG_SET call_used_reg_set;\n+\n+/* Data for initializing the above.  */\n+\n+static char initial_call_used_regs[] = CALL_USED_REGISTERS;\n+  \n+/* Indexed by hard register number, contains 1 for registers that are\n+   fixed use -- i.e. in fixed_regs -- or a function value return register\n+   or STRUCT_VALUE_REGNUM or STATIC_CHAIN_REGNUM.  These are the\n+   registers that cannot hold quantities across calls even if we are\n+   willing to save and restore them.  */\n+\n+char call_fixed_regs[FIRST_PSEUDO_REGISTER];\n+\n+/* The same info as a HARD_REG_SET.  */\n+\n+HARD_REG_SET call_fixed_reg_set;\n+\n+/* Number of non-fixed registers.  */\n+\n+int n_non_fixed_regs;\n+\n+/* Indexed by hard register number, contains 1 for registers\n+   that are being used for global register decls.\n+   These must be exempt from ordinary flow analysis\n+   and are also considered fixed.  */\n+\n+char global_regs[FIRST_PSEUDO_REGISTER];\n+  \n+/* Table of register numbers in the order in which to try to use them.  */\n+#ifdef REG_ALLOC_ORDER\n+int reg_alloc_order[FIRST_PSEUDO_REGISTER] = REG_ALLOC_ORDER;\n+#endif\n+\n+/* For each reg class, a HARD_REG_SET saying which registers are in it.  */\n+\n+HARD_REG_SET reg_class_contents[] = REG_CLASS_CONTENTS;\n+\n+/* For each reg class, number of regs it contains.  */\n+\n+int reg_class_size[N_REG_CLASSES];\n+\n+/* For each reg class, table listing all the containing classes.  */\n+\n+enum reg_class reg_class_superclasses[N_REG_CLASSES][N_REG_CLASSES];\n+\n+/* For each reg class, table listing all the classes contained in it.  */\n+\n+enum reg_class reg_class_subclasses[N_REG_CLASSES][N_REG_CLASSES];\n+\n+/* For each pair of reg classes,\n+   a largest reg class contained in their union.  */\n+\n+enum reg_class reg_class_subunion[N_REG_CLASSES][N_REG_CLASSES];\n+\n+/* For each pair of reg classes,\n+   the smallest reg class containing their union.  */\n+\n+enum reg_class reg_class_superunion[N_REG_CLASSES][N_REG_CLASSES];\n+\n+/* Array containing all of the register names */\n+\n+char *reg_names[] = REGISTER_NAMES;\n+\n+\n+/* Indexed by n, gives number of times (REG n) is set or clobbered.\n+   This information remains valid for the rest of the compilation\n+   of the current function; it is used to control register allocation.\n+\n+   This information applies to both hard registers and pseudo registers,\n+   unlike much of the information above.  */\n+\n+short *reg_n_sets;\n+\n+/* Function called only once to initialize the above data on reg usage.\n+   Once this is done, various switches may override.  */\n+\n+void\n+init_reg_sets ()\n+{\n+  register int i, j;\n+\n+  bcopy (initial_fixed_regs, fixed_regs, sizeof fixed_regs);\n+  bcopy (initial_call_used_regs, call_used_regs, sizeof call_used_regs);\n+  bzero (global_regs, sizeof global_regs);\n+\n+  /* Compute number of hard regs in each class.  */\n+\n+  bzero (reg_class_size, sizeof reg_class_size);\n+  for (i = 0; i < N_REG_CLASSES; i++)\n+    for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n+      if (TEST_HARD_REG_BIT (reg_class_contents[i], j))\n+\treg_class_size[i]++;\n+\n+  /* Initialize the table of subunions.\n+     reg_class_subunion[I][J] gets the largest-numbered reg-class\n+     that is contained in the union of classes I and J.  */\n+\n+  for (i = 0; i < N_REG_CLASSES; i++)\n+    {\n+      for (j = 0; j < N_REG_CLASSES; j++)\n+\t{\n+#ifdef HARD_REG_SET\n+\t  register\t\t/* Declare it register if it's a scalar.  */\n+#endif\n+\t    HARD_REG_SET c;\n+\t  register int k;\n+\n+\t  COPY_HARD_REG_SET (c, reg_class_contents[i]);\n+\t  IOR_HARD_REG_SET (c, reg_class_contents[j]);\n+\t  for (k = 0; k < N_REG_CLASSES; k++)\n+\t    {\n+\t      GO_IF_HARD_REG_SUBSET (reg_class_contents[k], c,\n+\t\t\t\t     subclass1);\n+\t      continue;\n+\n+\t    subclass1:\n+\t      /* keep the largest subclass */\t\t/* SPEE 900308 */\n+\t      GO_IF_HARD_REG_SUBSET (reg_class_contents[k],\n+\t\t\t\t     reg_class_contents[(int) reg_class_subunion[i][j]],\n+\t\t\t\t     subclass2);\n+\t      reg_class_subunion[i][j] = (enum reg_class) k;\n+\t    subclass2:\n+\t      ;\n+\t    }\n+\t}\n+    }\n+\n+  /* Initialize the table of superunions.\n+     reg_class_superunion[I][J] gets the smallest-numbered reg-class\n+     containing the union of classes I and J.  */\n+\n+  for (i = 0; i < N_REG_CLASSES; i++)\n+    {\n+      for (j = 0; j < N_REG_CLASSES; j++)\n+\t{\n+#ifdef HARD_REG_SET\n+\t  register\t\t/* Declare it register if it's a scalar.  */\n+#endif\n+\t    HARD_REG_SET c;\n+\t  register int k;\n+\n+\t  COPY_HARD_REG_SET (c, reg_class_contents[i]);\n+\t  IOR_HARD_REG_SET (c, reg_class_contents[j]);\n+\t  for (k = 0; k < N_REG_CLASSES; k++)\n+\t    GO_IF_HARD_REG_SUBSET (c, reg_class_contents[k], superclass);\n+\n+\tsuperclass:\n+\t  reg_class_superunion[i][j] = (enum reg_class) k;\n+\t}\n+    }\n+\n+  /* Initialize the tables of subclasses and superclasses of each reg class.\n+     First clear the whole table, then add the elements as they are found.  */\n+\n+  for (i = 0; i < N_REG_CLASSES; i++)\n+    {\n+      for (j = 0; j < N_REG_CLASSES; j++)\n+\t{\n+\t  reg_class_superclasses[i][j] = LIM_REG_CLASSES;\n+\t  reg_class_subclasses[i][j] = LIM_REG_CLASSES;\n+\t}\n+    }\n+\n+  for (i = 0; i < N_REG_CLASSES; i++)\n+    {\n+      if (i == (int) NO_REGS)\n+\tcontinue;\n+\n+      for (j = i + 1; j < N_REG_CLASSES; j++)\n+\t{\n+\t  enum reg_class *p;\n+\n+\t  GO_IF_HARD_REG_SUBSET (reg_class_contents[i], reg_class_contents[j],\n+\t\t\t\t subclass);\n+\t  continue;\n+\tsubclass:\n+\t  /* Reg class I is a subclass of J.\n+\t     Add J to the table of superclasses of I.  */\n+\t  p = &reg_class_superclasses[i][0];\n+\t  while (*p != LIM_REG_CLASSES) p++;\n+\t  *p = (enum reg_class) j;\n+\t  /* Add I to the table of superclasses of J.  */\n+\t  p = &reg_class_subclasses[j][0];\n+\t  while (*p != LIM_REG_CLASSES) p++;\n+\t  *p = (enum reg_class) i;\n+\t}\n+    }\n+}\n+\n+/* After switches have been processed, which perhaps alter\n+   `fixed_regs' and `call_used_regs', convert them to HARD_REG_SETs.  */\n+\n+void\n+init_reg_sets_1 ()\n+{\n+  register int i;\n+\n+  /* This macro allows the fixed or call-used registers\n+     to depend on target flags.  */\n+\n+#ifdef CONDITIONAL_REGISTER_USAGE\n+  CONDITIONAL_REGISTER_USAGE;\n+#endif\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (global_regs[i])\n+      {\n+\tif (call_used_regs[i] && ! fixed_regs[i])\n+\t  warning (\"call-clobbered register used for global register variable\");\n+\tfixed_regs[i] = 1;\n+\t/* Prevent saving/restoring of this reg.  */\n+\tcall_used_regs[i] = 1;\n+      }\n+\n+  /* Initialize \"constant\" tables.  */\n+\n+  CLEAR_HARD_REG_SET (fixed_reg_set);\n+  CLEAR_HARD_REG_SET (call_used_reg_set);\n+  CLEAR_HARD_REG_SET (call_fixed_reg_set);\n+\n+  bcopy (fixed_regs, call_fixed_regs, sizeof call_fixed_regs);\n+#ifdef STRUCT_VALUE_REGNUM\n+  call_fixed_regs[STRUCT_VALUE_REGNUM] = 1;\n+#endif\n+#ifdef STATIC_CHAIN_REGNUM\n+  call_fixed_regs[STATIC_CHAIN_REGNUM] = 1;\n+#endif\n+\n+  n_non_fixed_regs = 0;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (FUNCTION_VALUE_REGNO_P (i))\n+\tcall_fixed_regs[i] = 1;\n+      if (fixed_regs[i])\n+\tSET_HARD_REG_BIT (fixed_reg_set, i);\n+      else\n+\tn_non_fixed_regs++;\n+\n+      if (call_used_regs[i])\n+\tSET_HARD_REG_BIT (call_used_reg_set, i);\n+      if (call_fixed_regs[i])\n+\tSET_HARD_REG_BIT (call_fixed_reg_set, i);\n+    }\n+}\n+\n+/* Specify the usage characteristics of the register named NAME.\n+   It should be a fixed register if FIXED and a\n+   call-used register if CALL_USED.  */\n+\n+void\n+fix_register (name, fixed, call_used)\n+     char *name;\n+     int fixed, call_used;\n+{\n+  int i;\n+\n+  /* Decode the name and update the primary form of\n+     the register info.  */\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (!strcmp (reg_names[i], name))\n+      {\n+\tfixed_regs[i] = fixed;\n+\tcall_used_regs[i] = call_used;\n+\tbreak;\n+      }\n+\n+  if (i == FIRST_PSEUDO_REGISTER)\n+    {\n+      warning (\"unknown register name: %s\", name);\n+      return;\n+    }\n+}\n+\f\n+/* Now the data and code for the `regclass' pass, which happens\n+   just before local-alloc.  */\n+\n+/* savings[R].savings[CL] is twice the amount saved by putting register R\n+   in class CL.  This data is used within `regclass' and freed\n+   when it is finished.  */\n+\n+struct savings\n+{\n+  short savings[N_REG_CLASSES];\n+  short memcost;\n+  short nrefs;\n+};\n+\n+static struct savings *savings;\n+\n+/* (enum reg_class) prefclass[R] is the preferred class for pseudo number R.\n+   This is available after `regclass' is run.  */\n+\n+static char *prefclass;\n+\n+/* preferred_or_nothing[R] is nonzero if we should put pseudo number R\n+   in memory if we can't get its perferred class.\n+   This is available after `regclass' is run.  */\n+\n+static char *preferred_or_nothing;\n+\n+/* Record the depth of loops that we are in, 1 for no loops.  */\n+\n+static int loop_depth;\n+\n+void reg_class_record ();\n+void record_address_regs ();\n+\n+\n+/* Return the reg_class in which pseudo reg number REGNO is best allocated.\n+   This function is sometimes called before the info has been computed.\n+   When that happens, just return GENERAL_REGS, which is innocuous.  */\n+\n+enum reg_class\n+reg_preferred_class (regno)\n+     int regno;\n+{\n+  if (prefclass == 0)\n+    return GENERAL_REGS;\n+  return (enum reg_class) prefclass[regno];\n+}\n+\n+int\n+reg_preferred_or_nothing (regno)\n+{\n+  if (prefclass == 0)\n+    return 0;\n+  return preferred_or_nothing[regno];\n+}\n+\n+/* This prevents dump_flow_info from losing if called\n+   before regclass is run.  */\n+\n+void\n+regclass_init ()\n+{\n+  prefclass = 0;\n+}\n+\f\n+/* This is a pass of the compiler that scans all instructions\n+   and calculates the preferred class for each pseudo-register.\n+   This information can be accessed later by calling `reg_preferred_class'.\n+   This pass comes just before local register allocation.  */\n+\n+void\n+regclass (f, nregs)\n+     rtx f;\n+     int nregs;\n+{\n+#ifdef REGISTER_CONSTRAINTS\n+  register rtx insn;\n+  register int i;\n+\n+  init_recog ();\n+\n+  /* Zero out our accumulation of the cost of each class for each reg.  */\n+\n+  savings = (struct savings *) alloca (nregs * sizeof (struct savings));\n+  bzero (savings, nregs * sizeof (struct savings));\n+\n+  loop_depth = 1;\n+\n+  /* Scan the instructions and record each time it would\n+     save code to put a certain register in a certain class.  */\n+\n+  for (insn = f; insn; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == NOTE\n+\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+\tloop_depth++;\n+      else if (GET_CODE (insn) == NOTE\n+\t       && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n+\tloop_depth--;\n+      else if ((GET_CODE (insn) == INSN\n+\t\t&& GET_CODE (PATTERN (insn)) != USE\n+\t\t&& GET_CODE (PATTERN (insn)) != CLOBBER\n+\t\t&& GET_CODE (PATTERN (insn)) != ASM_INPUT)\n+\t       || (GET_CODE (insn) == JUMP_INSN\n+\t\t   && GET_CODE (PATTERN (insn)) != ADDR_VEC\n+\t\t   && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC)\n+\t       || GET_CODE (insn) == CALL_INSN)\n+\t{\n+\t  if (GET_CODE (insn) == INSN && asm_noperands (PATTERN (insn)) >= 0)\n+\t    {\n+\t      int noperands = asm_noperands (PATTERN (insn));\n+\t      /* We don't use alloca because alloca would not free\n+\t\t any of the space until this function returns.  */\n+\t      rtx *operands = (rtx *) oballoc (noperands * sizeof (rtx));\n+\t      char **constraints\n+\t\t= (char **) oballoc (noperands * sizeof (char *));\n+\n+\t      decode_asm_operands (PATTERN (insn), operands, 0, constraints, 0);\n+\n+\t      for (i = noperands - 1; i >= 0; i--)\n+\t\treg_class_record (operands[i], i, constraints);\n+\n+\t      obfree (operands);\n+\t    }\n+\t  else\n+\t    {\n+\t      int insn_code_number = recog_memoized (insn);\n+\t      rtx set = single_set (insn);\n+\n+\t      insn_extract (insn);\n+\n+\t      for (i = insn_n_operands[insn_code_number] - 1; i >= 0; i--)\n+\t\treg_class_record (recog_operand[i], i,\n+\t\t\t\t  insn_operand_constraint[insn_code_number]);\n+\n+\t      /* If this insn loads a parameter from its stack slot,\n+\t\t then it represents a savings, rather than a cost,\n+\t\t if the parameter is stored in memory.  Record this fact.  */\n+\t      if (set != 0 && GET_CODE (SET_DEST (set)) == REG\n+\t\t  && GET_CODE (SET_SRC (set)) == MEM)\n+\t\t{\n+\t\t  rtx note = find_reg_note (insn, REG_EQUIV, 0);\n+\t\t  if (note != 0 && GET_CODE (XEXP (note, 0)) == MEM)\n+\t\t    savings[REGNO (SET_DEST (set))].memcost\n+\t\t      -= (MEMORY_MOVE_COST (GET_MODE (SET_DEST (set)))\n+\t\t\t  * loop_depth);\n+\t\t}\n+\t      \n+\t      /* Improve handling of two-address insns such as\n+\t\t (set X (ashift CONST Y)) where CONST must be made to match X.\n+\t\t Change it into two insns: (set X CONST)  (set X (ashift X Y)).\n+\t\t If we left this for reloading, it would probably get three\n+\t\t insns because X and Y might go in the same place.\n+\t\t This prevents X and Y from receiving the same hard reg.\n+\n+\t\t We can only do this if the modes of operands 0 and 1 (which\n+\t\t might not be the same) are tieable.  */\n+\n+\t      if (optimize\n+\t\t  && insn_n_operands[insn_code_number] >= 3\n+\t\t  && insn_operand_constraint[insn_code_number][1][0] == '0'\n+\t\t  && insn_operand_constraint[insn_code_number][1][1] == 0\n+\t\t  && CONSTANT_P (recog_operand[1])\n+\t\t  && ! rtx_equal_p (recog_operand[0], recog_operand[1])\n+\t\t  && ! rtx_equal_p (recog_operand[0], recog_operand[2])\n+\t\t  && GET_CODE (recog_operand[0]) == REG\n+\t\t  && MODES_TIEABLE_P (GET_MODE (recog_operand[0]),\n+\t\t\t\t      insn_operand_mode[insn_code_number][1]))\n+\t\t{\n+\t\t  rtx previnsn = prev_real_insn (insn);\n+\t\t  rtx dest\n+\t\t    = gen_lowpart (insn_operand_mode[insn_code_number][1],\n+\t\t\t\t   recog_operand[0]);\n+\t\t  rtx newinsn\n+\t\t    = emit_insn_before (gen_move_insn (dest, recog_operand[1]),\n+\t\t\t\t\tinsn);\n+\n+\t\t  /* If this insn was the start of a basic block,\n+\t\t     include the new insn in that block.  */\n+\t\t  if (previnsn == 0 || GET_CODE (previnsn) == JUMP_INSN)\n+\t\t    {\n+\t\t      int b;\n+\t\t      for (b = 0; b < n_basic_blocks; b++)\n+\t\t\tif (insn == basic_block_head[b])\n+\t\t\t  basic_block_head[b] = newinsn;\n+\t\t    }\n+\n+\t\t  /* This makes one more setting of new insns's destination. */\n+\t\t  reg_n_sets[REGNO (recog_operand[0])]++;\n+\n+\t\t  *recog_operand_loc[1] = recog_operand[0];\n+\t\t  for (i = insn_n_dups[insn_code_number] - 1; i >= 0; i--)\n+\t\t    if (recog_dup_num[i] == 1)\n+\t\t      *recog_dup_loc[i] = recog_operand[0];\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  /* Now for each register look at how desirable each class is\n+     and find which class is preferred.  Store that in `prefclass[REGNO]'.  */\n+    \n+  prefclass = (char *) oballoc (nregs);\n+    \n+  preferred_or_nothing = (char *) oballoc (nregs);\n+\n+  for (i = FIRST_PSEUDO_REGISTER; i < nregs; i++)\n+    {\n+      register int best_savings = 0;\n+      enum reg_class best = ALL_REGS;\n+\n+      /* This is an enum reg_class, but we call it an int\n+\t to save lots of casts.  */\n+      register int class;\n+      register struct savings *p = &savings[i];\n+\n+      for (class = (int) ALL_REGS - 1; class > 0; class--)\n+\t{\n+\t  if (p->savings[class] > best_savings)\n+\t    {\n+\t      best_savings = p->savings[class];\n+\t      best = (enum reg_class) class;\n+\t    }\n+\t  else if (p->savings[class] == best_savings)\n+\t    {\n+\t      best = reg_class_subunion[(int)best][class];\n+\t    }\n+\t}\n+\n+#if 0\n+      /* Note that best_savings is twice number of places something\n+\t is saved.  */\n+      if ((best_savings - p->savings[(int) GENERAL_REGS]) * 5 < reg_n_refs[i])\n+\tprefclass[i] = (int) GENERAL_REGS;\n+      else\n+\tprefclass[i] = (int) best;\n+#else\n+      /* We cast to (int) because (char) hits bugs in some compilers.  */\n+      prefclass[i] = (int) best;\n+#endif\n+\n+      /* reg_n_refs + p->memcost measures the cost of putting in memory.\n+\t If a GENERAL_REG is no better, don't even try for one.\n+\t Since savings and memcost are 2 * number of refs,\n+\t this effectively counts each memory operand not needing reloading\n+\t as costing 1/2 of a reload insn.  */\n+      if (reg_n_refs != 0)\n+\tpreferred_or_nothing[i]\n+\t  = ((best_savings - p->savings[(int) GENERAL_REGS])\n+\t     >= p->nrefs + p->memcost);\n+    }\n+#endif /* REGISTER_CONSTRAINTS */\n+}\n+\f\n+#ifdef REGISTER_CONSTRAINTS\n+\n+/* Scan an operand OP for register class preferences.\n+   OPNO is the operand number, and CONSTRAINTS is the constraint\n+   vector for the insn.\n+\n+   Record the preferred register classes from the constraint for OP\n+   if OP is a register.  If OP is a memory reference, record suitable\n+   preferences for registers used in the address.  */\n+\n+void\n+reg_class_record (op, opno, constraints)\n+     rtx op;\n+     int opno;\n+     char **constraints;\n+{\n+  char *constraint = constraints[opno];\n+  register char *p;\n+  register enum reg_class class = NO_REGS;\n+  char *next = 0;\n+  int memok = 0;\n+  int double_cost = 0;\n+\n+  if (op == 0)\n+    return;\n+\n+  while (1)\n+    {\n+      if (GET_CODE (op) == SUBREG)\n+\top = SUBREG_REG (op);\n+      else break;\n+    }\n+\n+  /* Memory reference: scan the address.  */\n+\n+  if (GET_CODE (op) == MEM)\n+    record_address_regs (XEXP (op, 0), 2, 0);\n+\n+  if (GET_CODE (op) != REG)\n+    {\n+      /* If the constraint says the operand is supposed to BE an address,\n+\t scan it as one.  */\n+\n+      if (constraint != 0 && constraint[0] == 'p')\n+\trecord_address_regs (op, 2, 0);\n+      return;\n+    }\n+\n+  /* Operand is a register: examine the constraint for specified classes.  */\n+\n+  for (p = constraint; *p || next; p++)\n+    {\n+      enum reg_class new_class = NO_REGS;\n+\n+      if (*p == 0)\n+\t{\n+\t  p = next;\n+\t  next = 0;\n+\t}\n+      switch (*p)\n+\t{\n+\tcase '=':\n+\tcase '?':\n+\tcase '#':\n+\tcase '&':\n+\tcase '!':\n+\tcase '%':\n+\tcase 'E':\n+\tcase 'F':\n+\tcase 'G':\n+\tcase 'H':\n+\tcase 'i':\n+\tcase 'n':\n+\tcase 's':\n+\tcase 'p':\n+\tcase ',':\n+\tcase 'I':\n+\tcase 'J':\n+\tcase 'K':\n+\tcase 'L':\n+\tcase 'M':\n+\tcase 'N':\n+\tcase 'O':\n+\tcase 'P':\n+#ifdef EXTRA_CONSTRAINT\n+\tcase 'Q':\n+\tcase 'R':\n+\tcase 'S':\n+\tcase 'T':\n+\tcase 'U':\n+#endif\n+\tcase 'V':\n+\tcase 'X':\n+\t  break;\n+\n+\tcase '+':\n+\t  /* An input-output operand is twice as costly if it loses.  */\n+\t  double_cost = 1;\n+\t  break;\n+\n+\tcase 'm':\n+\tcase 'o':\n+\t  memok = 1;\n+\t  break;\n+\n+\t  /* * means ignore following letter\n+\t     when choosing register preferences.  */\n+\tcase '*':\n+\t  p++;\n+\t  break;\n+\n+\tcase 'g':\n+\tcase 'r':\n+\t  new_class = GENERAL_REGS;\n+\t  break;\n+\n+\tcase '0':\n+\tcase '1':\n+\tcase '2':\n+\tcase '3':\n+\tcase '4':\n+\t  /* If constraint says \"match another operand\",\n+\t     use that operand's constraint to choose preferences.  */\n+\t  next = constraints[*p - '0'];\n+\t  break;\n+\n+\tdefault:\n+\t  new_class = REG_CLASS_FROM_LETTER (*p);\n+\t  break;\n+\t}\n+\n+      /* If this object can fit into the class requested, compute the subunion\n+\t of the requested class and classes found so far.  */\n+      if (CLASS_MAX_NREGS (new_class, GET_MODE (op))\n+\t  <= reg_class_size[(int) new_class])\n+\tclass = reg_class_subunion[(int) class][(int) new_class];\n+    }\n+\n+  {\n+    register int i;\n+    register struct savings *pp;\n+    register enum reg_class class1;\n+    int cost = 2 * (1 + double_cost) * loop_depth;\n+    pp = &savings[REGNO (op)];\n+\n+    /* Increment the savings for this reg\n+       for each class contained in the one the constraint asks for.  */\n+\n+    if (class != NO_REGS && class != ALL_REGS)\n+      {\n+\tint extracost;\n+\n+\tpp->savings[(int) class] += cost;\n+\tfor (i = 0; ; i++)\n+\t  {\n+\t    class1 = reg_class_subclasses[(int)class][i];\n+\t    if (class1 == LIM_REG_CLASSES)\n+\t      break;\n+\t    pp->savings[(int) class1] += cost;\n+\t  }\n+\t/* If it's slow to move data between this class and GENERAL_REGS,\n+\t   record that fact.  */\n+\textracost = (REGISTER_MOVE_COST (class, GENERAL_REGS) - 2) * loop_depth;\n+\tif (extracost > 0)\n+\t  {\n+\t    /* Check that this class and GENERAL_REGS don't overlap.\n+\t       REGISTER_MOVE_COST is meaningless if there is overlap.  */\n+\t    HARD_REG_SET temp;\n+\t    COMPL_HARD_REG_SET (temp, reg_class_contents[(int) class]);\n+\t    GO_IF_HARD_REG_SUBSET (reg_class_contents[(int) GENERAL_REGS],\n+\t\t\t\t   temp, label1);\n+\t    /* Overlap.  */\n+\t    goto label2;\n+\n+\t  label1: /* No overlap.  */\n+\t    /* Charge this extra cost to GENERAL_REGS\n+\t       and all its subclasses (none of which overlap this class).  */\n+\t    extracost = extracost * cost / (2 * loop_depth);\n+\t    pp->savings[(int) GENERAL_REGS] -= extracost;\n+\t    for (i = 0; ; i++)\n+\t      {\n+\t\tclass1 = reg_class_subclasses[(int)GENERAL_REGS][i];\n+\t\tif (class1 == LIM_REG_CLASSES)\n+\t\t  break;\n+\t\tpp->savings[(int) class1] -= extracost;\n+\t      }\n+\n+\t  label2: ;\n+\t  }\n+      }\n+\n+    if (! memok)\n+      pp->memcost += (MEMORY_MOVE_COST (GET_MODE (op)) * (1 + double_cost)\n+\t\t      - 1) * loop_depth;\n+    pp->nrefs += loop_depth;\n+  }\n+}\n+\n+/* Record the pseudo registers we must reload into hard registers\n+   in a subexpression of a memory address, X.\n+   BCOST is the cost if X is a register and it fails to be in BASE_REG_CLASS.\n+   ICOST is the cost if it fails to be in INDEX_REG_CLASS. */\n+\n+void\n+record_address_regs (x, bcost, icost)\n+     rtx x;\n+     int bcost, icost;\n+{\n+  register enum rtx_code code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+    case CONST:\n+    case CC0:\n+    case PC:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return;\n+\n+    case PLUS:\n+      /* When we have an address that is a sum,\n+\t we must determine whether registers are \"base\" or \"index\" regs.\n+\t If there is a sum of two registers, we must choose one to be\n+\t the \"base\".  Luckily, we can use the REGNO_POINTER_FLAG\n+\t to make a good choice most of the time.  */\n+      {\n+\trtx arg0 = XEXP (x, 0);\n+\trtx arg1 = XEXP (x, 1);\n+\tregister enum rtx_code code0 = GET_CODE (arg0);\n+\tregister enum rtx_code code1 = GET_CODE (arg1);\n+\tint icost0 = 0;\n+\tint icost1 = 0;\n+\tint suppress1 = 0;\n+\tint suppress0 = 0;\n+\n+\t/* Look inside subregs.  */\n+\twhile (code0 == SUBREG)\n+\t  arg0 = SUBREG_REG (arg0), code0 = GET_CODE (arg0);\n+\twhile (code1 == SUBREG)\n+\t  arg1 = SUBREG_REG (arg1), code1 = GET_CODE (arg1);\n+\n+\tif (code0 == MULT || code1 == MEM)\n+\t  icost0 = 2;\n+\telse if (code1 == MULT || code0 == MEM)\n+\t  icost1 = 2;\n+\telse if (code0 == CONST_INT)\n+\t  suppress0 = 1;\n+\telse if (code1 == CONST_INT)\n+\t  suppress1 = 1;\n+\telse if (code0 == REG && code1 == REG)\n+\t  {\n+\t    if (REGNO_POINTER_FLAG (REGNO (arg0)))\n+\t      icost1 = 2;\n+\t    else if (REGNO_POINTER_FLAG (REGNO (arg1)))\n+\t      icost0 = 2;\n+\t    else\n+\t      icost0 = icost1 = 1;\n+\t  }\n+\telse if (code0 == REG)\n+\t  {\n+\t    if (code1 == PLUS\n+\t\t&& ! REGNO_POINTER_FLAG (REGNO (arg0)))\n+\t      icost0 = 2;\n+\t    else\n+\t      REGNO_POINTER_FLAG (REGNO (arg0)) = 1;\n+\t  }\n+\telse if (code1 == REG)\n+\t  {\n+\t    if (code0 == PLUS\n+\t\t&& ! REGNO_POINTER_FLAG (REGNO (arg1)))\n+\t      icost1 = 2;\n+\t    else\n+\t      REGNO_POINTER_FLAG (REGNO (arg1)) = 1;\n+\t  }\n+\n+\t/* ICOST0 determines whether we are treating operand 0\n+\t   as a base register or as an index register.\n+\t   SUPPRESS0 nonzero means it isn't a register at all.\n+\t   ICOST1 and SUPPRESS1 are likewise for operand 1.  */\n+\n+\tif (! suppress0)\n+\t  record_address_regs (arg0, 2 - icost0, icost0);\n+\tif (! suppress1)\n+\t  record_address_regs (arg1, 2 - icost1, icost1);\n+      }\n+      break;\n+\n+    case POST_INC:\n+    case PRE_INC:\n+    case POST_DEC:\n+    case PRE_DEC:\n+      /* Double the importance of a pseudo register that is incremented\n+\t or decremented, since it would take two extra insns\n+\t if it ends up in the wrong place.  */\n+      record_address_regs (XEXP (x, 0), 2 * bcost, 2 * icost);\n+      break;\n+\n+    case REG:\n+      {\n+\tregister struct savings *pp;\n+\tregister enum reg_class class, class1;\n+\tpp = &savings[REGNO (x)];\n+\tpp->nrefs += loop_depth;\n+\n+\t/* We have an address (or part of one) that is just one register.  */\n+\n+\t/* Record BCOST worth of savings for classes contained\n+\t   in BASE_REG_CLASS.  */\n+\n+\tclass = BASE_REG_CLASS;\n+\tif (class != NO_REGS && class != ALL_REGS)\n+\t  {\n+\t    register int i;\n+\t    pp->savings[(int) class] += bcost * loop_depth;\n+\t    for (i = 0; ; i++)\n+\t      {\n+\t\tclass1 = reg_class_subclasses[(int)class][i];\n+\t\tif (class1 == LIM_REG_CLASSES)\n+\t\t  break;\n+\t\tpp->savings[(int) class1] += bcost * loop_depth;\n+\t      }\n+\t  }\n+\n+\t/* Record ICOST worth of savings for classes contained\n+\t   in INDEX_REG_CLASS.  */\n+\n+\tclass = INDEX_REG_CLASS;\n+\tif (icost != 0 && class != NO_REGS && class != ALL_REGS)\n+\t  {\n+\t    register int i;\n+\t    pp->savings[(int) class] += icost * loop_depth;\n+\t    for (i = 0; ; i++)\n+\t      {\n+\t\tclass1 = reg_class_subclasses[(int)class][i];\n+\t\tif (class1 == LIM_REG_CLASSES)\n+\t\t  break;\n+\t\tpp->savings[(int) class1] += icost * loop_depth;\n+\t      }\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      {\n+\tregister char *fmt = GET_RTX_FORMAT (code);\n+\tregister int i;\n+\tfor (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+\t  if (fmt[i] == 'e')\n+\t    record_address_regs (XEXP (x, i), bcost, icost);\n+      }\n+    }\n+}\n+#endif /* REGISTER_CONSTRAINTS */\n+\f\n+/* This is the `regscan' pass of the compiler, run just before cse\n+   and again just before loop.\n+\n+   It finds the first and last use of each pseudo-register\n+   and records them in the vectors regno_first_uid, regno_last_uid\n+   and counts the number of sets in the vector reg_n_sets.\n+\n+   REPEAT is nonzero the second time this is called.  */\n+\n+/* Indexed by pseudo register number, gives uid of first insn using the reg\n+   (as of the time reg_scan is called).  */\n+\n+short *regno_first_uid;\n+\n+/* Indexed by pseudo register number, gives uid of last insn using the reg\n+   (as of the time reg_scan is called).  */\n+\n+short *regno_last_uid;\n+\n+/* Record the number of registers we used when we allocated the above two\n+   tables.  If we are called again with more than this, we must re-allocate\n+   the tables.  */\n+\n+static int highest_regno_in_uid_map;\n+\n+/* Maximum number of parallel sets and clobbers in any insn in this fn.\n+   Always at least 3, since the combiner could put that many togetherm\n+   and we want this to remain correct for all the remaining passes.  */\n+\n+int max_parallel;\n+\n+void reg_scan_mark_refs ();\n+\n+void\n+reg_scan (f, nregs, repeat)\n+     rtx f;\n+     int nregs;\n+     int repeat;\n+{\n+  register rtx insn;\n+\n+  if (!repeat || nregs > highest_regno_in_uid_map)\n+    {\n+      /* Leave some spare space in case more regs are allocated.  */\n+      highest_regno_in_uid_map = nregs + nregs / 20;\n+      regno_first_uid\n+\t= (short *) oballoc (highest_regno_in_uid_map * sizeof (short));\n+      regno_last_uid\n+\t= (short *) oballoc (highest_regno_in_uid_map * sizeof (short));\n+      reg_n_sets\n+\t= (short *) oballoc (highest_regno_in_uid_map * sizeof (short));\n+    }\n+\n+  bzero (regno_first_uid, highest_regno_in_uid_map * sizeof (short));\n+  bzero (regno_last_uid, highest_regno_in_uid_map * sizeof (short));\n+  bzero (reg_n_sets, highest_regno_in_uid_map * sizeof (short));\n+\n+  max_parallel = 3;\n+\n+  for (insn = f; insn; insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == INSN\n+\t|| GET_CODE (insn) == CALL_INSN\n+\t|| GET_CODE (insn) == JUMP_INSN)\n+      {\n+\tif (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t    && XVECLEN (PATTERN (insn), 0) > max_parallel)\n+\t  max_parallel = XVECLEN (PATTERN (insn), 0);\n+\treg_scan_mark_refs (PATTERN (insn), INSN_UID (insn));\n+      }\n+}\n+\n+void\n+reg_scan_mark_refs (x, uid)\n+     rtx x;\n+     int uid;\n+{\n+  register enum rtx_code code = GET_CODE (x);\n+  register rtx dest;\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+    case CONST:\n+    case CONST_DOUBLE:\n+    case CC0:\n+    case PC:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case ADDR_VEC:\n+    case ADDR_DIFF_VEC:\n+      return;\n+\n+    case REG:\n+      {\n+\tregister int regno = REGNO (x);\n+\n+\tregno_last_uid[regno] = uid;\n+\tif (regno_first_uid[regno] == 0)\n+\t  regno_first_uid[regno] = uid;\n+      }\n+      break;\n+\n+    case SET:\n+      /* Count a set of the destination if it is a register.  */\n+      for (dest = SET_DEST (x);\n+\t   GET_CODE (dest) == SUBREG || GET_CODE (dest) == STRICT_LOW_PART\n+\t   || GET_CODE (dest) == ZERO_EXTEND;\n+\t   dest = XEXP (dest, 0))\n+\t;\n+\n+      if (GET_CODE (dest) == REG)\n+\treg_n_sets[REGNO (dest)]++;\n+\n+      /* ... fall through ... */\n+\n+    default:\n+      {\n+\tregister char *fmt = GET_RTX_FORMAT (code);\n+\tregister int i;\n+\tfor (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+\t  {\n+\t    if (fmt[i] == 'e')\n+\t      reg_scan_mark_refs (XEXP (x, i), uid);\n+\t    else if (fmt[i] == 'E' && XVEC (x, i) != 0)\n+\t      {\n+\t\tregister int j;\n+\t\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t\t  reg_scan_mark_refs (XVECEXP (x, i, j), uid);\t\t  \n+\t      }\n+\t  }\n+      }\n+    }\n+}\n+\f\n+/* Return nonzero if C1 is a subset of C2, i.e., if every register in C1\n+   is also in C2.  */\n+\n+int\n+reg_class_subset_p (c1, c2)\n+     register enum reg_class c1;\n+     register enum reg_class c2;\n+{\n+  if (c1 == c2) return 1;\n+\n+  if (c2 == ALL_REGS)\n+  win:\n+    return 1;\n+  GO_IF_HARD_REG_SUBSET (reg_class_contents[(int)c1],\n+\t\t\t reg_class_contents[(int)c2],\n+\t\t\t win);\n+  return 0;\n+}\n+\n+/* Return nonzero if there is a register that is in both C1 and C2.  */\n+\n+int\n+reg_classes_intersect_p (c1, c2)\n+     register enum reg_class c1;\n+     register enum reg_class c2;\n+{\n+#ifdef HARD_REG_SET\n+  register\n+#endif\n+    HARD_REG_SET c;\n+\n+  if (c1 == c2) return 1;\n+\n+  if (c1 == ALL_REGS || c2 == ALL_REGS)\n+    return 1;\n+\n+  COPY_HARD_REG_SET (c, reg_class_contents[(int) c1]);\n+  AND_HARD_REG_SET (c, reg_class_contents[(int) c2]);\n+\n+  GO_IF_HARD_REG_SUBSET (c, reg_class_contents[(int) NO_REGS], lose);\n+  return 1;\n+\n+ lose:\n+  return 0;\n+}\n+"}]}