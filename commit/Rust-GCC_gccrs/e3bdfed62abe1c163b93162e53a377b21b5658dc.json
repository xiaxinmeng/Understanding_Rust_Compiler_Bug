{"sha": "e3bdfed62abe1c163b93162e53a377b21b5658dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNiZGZlZDYyYWJlMWMxNjNiOTMxNjJlNTNhMzc3YjIxYjU2NThkYw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-05-06T09:04:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-05-06T09:04:00Z"}, "message": "re PR tree-optimization/43934 (LIM should handle PHI nodes)\n\n2010-05-06  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/43934\n\t* tree-ssa-loop-im.c (movement_possibility): Handle PHI nodes.\n\t(stmt_cost): Likewise.\n\t(extract_true_false_args_from_phi): New helper.\n\t(determine_max_movement): For PHI nodes verify we can hoist them\n\tand compute their cost.\n\t(determine_invariantness_stmt): Handle PHI nodes.\n\t(move_computations_stmt): Likewise.  Hoist PHI nodes in\n\tif-converted form using COND_EXPRs.\n\t(move_computations): Return TODO_cleanup_cfg if we hoisted PHI\n\tnodes.\n\t(tree_ssa_lim): Likewise.\n\t* tree-flow.h (tree_ssa_lim): Adjust prototype.\n\t* tree-ssa-loop.c (tree_ssa_loop_im): Return todo.\n\n\t* gcc.dg/tree-ssa/ssa-lim-9.c: New testcase.\n\nFrom-SVN: r159099", "tree": {"sha": "06f32bf636037d2caf5f7c51678ee35c661cafa5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06f32bf636037d2caf5f7c51678ee35c661cafa5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3bdfed62abe1c163b93162e53a377b21b5658dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3bdfed62abe1c163b93162e53a377b21b5658dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3bdfed62abe1c163b93162e53a377b21b5658dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3bdfed62abe1c163b93162e53a377b21b5658dc/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a81b065a47a134e66937060f7ae14f1ae939b7b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a81b065a47a134e66937060f7ae14f1ae939b7b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a81b065a47a134e66937060f7ae14f1ae939b7b5"}], "stats": {"total": 315, "additions": 304, "deletions": 11}, "files": [{"sha": "5051eced3b24b91b1d98a65ac88ddc6b57f9dd9c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3bdfed62abe1c163b93162e53a377b21b5658dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3bdfed62abe1c163b93162e53a377b21b5658dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3bdfed62abe1c163b93162e53a377b21b5658dc", "patch": "@@ -1,3 +1,20 @@\n+2010-05-06  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/43934\n+\t* tree-ssa-loop-im.c (movement_possibility): Handle PHI nodes.\n+\t(stmt_cost): Likewise.\n+\t(extract_true_false_args_from_phi): New helper.\n+\t(determine_max_movement): For PHI nodes verify we can hoist them\n+\tand compute their cost.\n+\t(determine_invariantness_stmt): Handle PHI nodes.\n+\t(move_computations_stmt): Likewise.  Hoist PHI nodes in\n+\tif-converted form using COND_EXPRs.\n+\t(move_computations): Return TODO_cleanup_cfg if we hoisted PHI\n+\tnodes.\n+\t(tree_ssa_lim): Likewise.\n+\t* tree-flow.h (tree_ssa_lim): Adjust prototype.\n+\t* tree-ssa-loop.c (tree_ssa_loop_im): Return todo.\n+\n 2010-05-06  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/43987"}, {"sha": "2eebcf397d1dcee6e003ee23df9b573f986ab170", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3bdfed62abe1c163b93162e53a377b21b5658dc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3bdfed62abe1c163b93162e53a377b21b5658dc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e3bdfed62abe1c163b93162e53a377b21b5658dc", "patch": "@@ -1,3 +1,18 @@\n+2010-05-06  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/43934\n+\t* gcc.dg/tree-ssa/ssa-lim-9.c: New testcase.\n+\n+2010-05-06  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/43987\n+\t* gcc.c-torture/execute/pr43987.c: New testcase.\n+\t* gcc.dg/torture/pta-escape-1.c: Adjust.\n+\t* gcc.dg/tree-ssa/pta-escape-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/pta-escape-2.c: Likewise.\n+\t* gcc.dg/tree-ssa/pta-escape-3.c: Likewise.\n+\t* gcc.dg/ipa/ipa-pta-11.c: Likewise.\n+\n 2010-04-22  Jakub Jelinek <jakub@redhat.com>\n \t    Dodji Seketeli  <dodji@redhat.com>\n "}, {"sha": "c5a67653badd51fbc362ffdca4ac671e94334d0d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-9.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3bdfed62abe1c163b93162e53a377b21b5658dc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3bdfed62abe1c163b93162e53a377b21b5658dc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-9.c?ref=e3bdfed62abe1c163b93162e53a377b21b5658dc", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-lim1-details\" } */\n+\n+void bar (int);\n+void foo (int n, int m)\n+{\n+  unsigned i;\n+  for (i = 0; i < n; ++i)\n+    {\n+      int x;\n+      if (m < 0)\n+\tx = 1+n;\n+      else\n+\tx = m-n;\n+      bar (x);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Moving PHI node\" 1 \"lim1\"  } } */\n+/* { dg-final { cleanup-tree-dump \"lim1\" } } */"}, {"sha": "67fb70fbcd9b1177f5b7604277911de4851101e2", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3bdfed62abe1c163b93162e53a377b21b5658dc/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3bdfed62abe1c163b93162e53a377b21b5658dc/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=e3bdfed62abe1c163b93162e53a377b21b5658dc", "patch": "@@ -685,7 +685,7 @@ basic_block *blocks_in_phiopt_order (void);\n \n /* In tree-ssa-loop*.c  */\n \n-void tree_ssa_lim (void);\n+unsigned int tree_ssa_lim (void);\n unsigned int tree_ssa_unswitch_loops (void);\n unsigned int canonicalize_induction_variables (void);\n unsigned int tree_unroll_loops_completely (bool, bool);"}, {"sha": "51d9e938fd1e880ef94e6a5500293bb9f4297c1f", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 250, "deletions": 8, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3bdfed62abe1c163b93162e53a377b21b5658dc/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3bdfed62abe1c163b93162e53a377b21b5658dc/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=e3bdfed62abe1c163b93162e53a377b21b5658dc", "patch": "@@ -359,6 +359,12 @@ movement_possibility (gimple stmt)\n       return MOVE_POSSIBLE;\n     }\n \n+  if (gimple_code (stmt) == GIMPLE_PHI\n+      && gimple_phi_num_args (stmt) <= 2\n+      && is_gimple_reg (gimple_phi_result (stmt))\n+      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_phi_result (stmt)))\n+    return MOVE_POSSIBLE;\n+\n   if (gimple_get_lhs (stmt) == NULL_TREE)\n     return MOVE_IMPOSSIBLE;\n \n@@ -513,7 +519,8 @@ stmt_cost (gimple stmt)\n   unsigned cost = 1;\n \n   /* Always try to create possibilities for unswitching.  */\n-  if (gimple_code (stmt) == GIMPLE_COND)\n+  if (gimple_code (stmt) == GIMPLE_COND\n+      || gimple_code (stmt) == GIMPLE_PHI)\n     return LIM_EXPENSIVE;\n \n   /* Hoisting memory references out should almost surely be a win.  */\n@@ -651,6 +658,63 @@ mem_ref_in_stmt (gimple stmt)\n   return ref;\n }\n \n+/* From a controlling predicate in DOM determine the arguments from\n+   the PHI node PHI that are chosen if the predicate evaluates to\n+   true and false and store them to *TRUE_ARG_P and *FALSE_ARG_P if\n+   they are non-NULL.  Returns true if the arguments can be determined,\n+   else return false.  */\n+\n+static bool\n+extract_true_false_args_from_phi (basic_block dom, gimple phi,\n+\t\t\t\t  tree *true_arg_p, tree *false_arg_p)\n+{\n+  basic_block bb = gimple_bb (phi);\n+  edge true_edge, false_edge, tem;\n+  tree arg0 = NULL_TREE, arg1 = NULL_TREE;\n+\n+  /* We have to verify that one edge into the PHI node is dominated\n+     by the true edge of the predicate block and the other edge\n+     dominated by the false edge.  This ensures that the PHI argument\n+     we are going to take is completely determined by the path we\n+     take from the predicate block.  */\n+  extract_true_false_edges_from_block (dom, &true_edge, &false_edge);\n+  tem = EDGE_PRED (bb, 0);\n+  if (tem == true_edge\n+      || tem->src == true_edge->dest\n+      || dominated_by_p (CDI_DOMINATORS,\n+\t\t\t tem->src, true_edge->dest))\n+    arg0 = PHI_ARG_DEF (phi, tem->dest_idx);\n+  else if (tem == false_edge\n+\t   || tem->src == false_edge->dest\n+\t   || dominated_by_p (CDI_DOMINATORS,\n+\t\t\t      tem->src, false_edge->dest))\n+    arg1 = PHI_ARG_DEF (phi, tem->dest_idx);\n+  else\n+    return false;\n+  tem = EDGE_PRED (bb, 1);\n+  if (tem == true_edge\n+      || tem->src == true_edge->dest\n+      || dominated_by_p (CDI_DOMINATORS,\n+\t\t\t tem->src, true_edge->dest))\n+    arg0 = PHI_ARG_DEF (phi, tem->dest_idx);\n+  else if (tem == false_edge\n+\t   || tem->src == false_edge->dest\n+\t   || dominated_by_p (CDI_DOMINATORS,\n+\t\t\t      tem->src, false_edge->dest))\n+    arg1 = PHI_ARG_DEF (phi, tem->dest_idx);\n+  else\n+    return false;\n+  if (!arg0 || !arg1)\n+    return false;\n+\n+  if (true_arg_p)\n+    *true_arg_p = arg0;\n+  if (false_arg_p)\n+    *false_arg_p = arg1;\n+\n+  return true;\n+}\n+\n /* Determine the outermost loop to that it is possible to hoist a statement\n    STMT and store it to LIM_DATA (STMT)->max_loop.  To do this we determine\n    the outermost loop in that the value computed by STMT is invariant.\n@@ -677,9 +741,81 @@ determine_max_movement (gimple stmt, bool must_preserve_exec)\n     level = superloop_at_depth (loop, 1);\n   lim_data->max_loop = level;\n \n-  FOR_EACH_SSA_TREE_OPERAND (val, stmt, iter, SSA_OP_USE)\n-    if (!add_dependency (val, lim_data, loop, true))\n-      return false;\n+  if (gimple_code (stmt) == GIMPLE_PHI)\n+    {\n+      use_operand_p use_p;\n+      unsigned min_cost = UINT_MAX;\n+      unsigned total_cost = 0;\n+      struct lim_aux_data *def_data;\n+\n+      /* We will end up promoting dependencies to be unconditionally\n+\t evaluated.  For this reason the PHI cost (and thus the\n+\t cost we remove from the loop by doing the invariant motion)\n+\t is that of the cheapest PHI argument dependency chain.  */\n+      FOR_EACH_PHI_ARG (use_p, stmt, iter, SSA_OP_USE)\n+\t{\n+\t  val = USE_FROM_PTR (use_p);\n+\t  if (TREE_CODE (val) != SSA_NAME)\n+\t    continue;\n+\t  if (!add_dependency (val, lim_data, loop, false))\n+\t    return false;\n+\t  def_data = get_lim_data (SSA_NAME_DEF_STMT (val));\n+\t  if (def_data)\n+\t    {\n+\t      min_cost = MIN (min_cost, def_data->cost);\n+\t      total_cost += def_data->cost;\n+\t    }\n+\t}\n+\n+      lim_data->cost += min_cost;\n+\n+      if (gimple_phi_num_args (stmt) > 1)\n+\t{\n+\t  basic_block dom = get_immediate_dominator (CDI_DOMINATORS, bb);\n+\t  gimple cond;\n+\t  if (gsi_end_p (gsi_last_bb (dom)))\n+\t    return false;\n+\t  cond = gsi_stmt (gsi_last_bb (dom));\n+\t  if (gimple_code (cond) != GIMPLE_COND)\n+\t    return false;\n+\t  /* Verify that this is an extended form of a diamond and\n+\t     the PHI arguments are completely controlled by the\n+\t     predicate in DOM.  */\n+\t  if (!extract_true_false_args_from_phi (dom, stmt, NULL, NULL))\n+\t    return false;\n+\n+\t  /* Fold in dependencies and cost of the condition.  */\n+\t  FOR_EACH_SSA_TREE_OPERAND (val, cond, iter, SSA_OP_USE)\n+\t    {\n+\t      if (!add_dependency (val, lim_data, loop, false))\n+\t\treturn false;\n+\t      def_data = get_lim_data (SSA_NAME_DEF_STMT (val));\n+\t      if (def_data)\n+\t\ttotal_cost += def_data->cost;\n+\t    }\n+\n+\t  /* We want to avoid unconditionally executing very expensive\n+\t     operations.  As costs for our dependencies cannot be\n+\t     negative just claim we are not invariand for this case.\n+\t     We also are not sure whether the control-flow inside the\n+\t     loop will vanish.  */\n+\t  if (total_cost - min_cost >= 2 * LIM_EXPENSIVE\n+\t      && !(min_cost != 0\n+\t\t   && total_cost / min_cost <= 2))\n+\t    return false;\n+\n+\t  /* Assume that the control-flow in the loop will vanish.\n+\t     ???  We should verify this and not artificially increase\n+\t     the cost if that is not the case.  */\n+\t  lim_data->cost += stmt_cost (stmt);\n+\t}\n+\n+      return true;\n+    }\n+  else\n+    FOR_EACH_SSA_TREE_OPERAND (val, stmt, iter, SSA_OP_USE)\n+      if (!add_dependency (val, lim_data, loop, true))\n+\treturn false;\n \n   if (gimple_vuse (stmt))\n     {\n@@ -920,6 +1056,43 @@ determine_invariantness_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n     fprintf (dump_file, \"Basic block %d (loop %d -- depth %d):\\n\\n\",\n \t     bb->index, bb->loop_father->num, loop_depth (bb->loop_father));\n \n+  /* Look at PHI nodes, but only if there is at most two.\n+     ???  We could relax this further by post-processing the inserted\n+     code and transforming adjacent cond-exprs with the same predicate\n+     to control flow again.  */\n+  bsi = gsi_start_phis (bb);\n+  if (!gsi_end_p (bsi)\n+      && ((gsi_next (&bsi), gsi_end_p (bsi))\n+\t  || (gsi_next (&bsi), gsi_end_p (bsi))))\n+    for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+      {\n+\tstmt = gsi_stmt (bsi);\n+\n+\tpos = movement_possibility (stmt);\n+\tif (pos == MOVE_IMPOSSIBLE)\n+\t  continue;\n+\n+\tlim_data = init_lim_data (stmt);\n+\tlim_data->always_executed_in = outermost;\n+\n+\tif (!determine_max_movement (stmt, false))\n+\t  {\n+\t    lim_data->max_loop = NULL;\n+\t    continue;\n+\t  }\n+\n+\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t  {\n+\t    print_gimple_stmt (dump_file, stmt, 2, 0);\n+\t    fprintf (dump_file, \"  invariant up to level %d, cost %d.\\n\\n\",\n+\t\t     loop_depth (lim_data->max_loop),\n+\t\t     lim_data->cost);\n+\t  }\n+\n+\tif (lim_data->cost >= LIM_EXPENSIVE)\n+\t  set_profitable_level (stmt);\n+      }\n+\n   for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n     {\n       stmt = gsi_stmt (bsi);\n@@ -1021,7 +1194,7 @@ determine_invariantness (void)\n    for walk_dominator_tree.  */\n \n static void\n-move_computations_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n+move_computations_stmt (struct dom_walk_data *dw_data,\n \t\t\tbasic_block bb)\n {\n   struct loop *level;\n@@ -1033,6 +1206,67 @@ move_computations_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n   if (!loop_outer (bb->loop_father))\n     return;\n \n+  for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); )\n+    {\n+      gimple new_stmt;\n+      stmt = gsi_stmt (bsi);\n+\n+      lim_data = get_lim_data (stmt);\n+      if (lim_data == NULL)\n+\t{\n+\t  gsi_next (&bsi);\n+\t  continue;\n+\t}\n+\n+      cost = lim_data->cost;\n+      level = lim_data->tgt_loop;\n+      clear_lim_data (stmt);\n+\n+      if (!level)\n+\t{\n+\t  gsi_next (&bsi);\n+\t  continue;\n+\t}\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Moving PHI node\\n\");\n+\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t  fprintf (dump_file, \"(cost %u) out of loop %d.\\n\\n\",\n+\t\t   cost, level->num);\n+\t}\n+\n+      if (gimple_phi_num_args (stmt) == 1)\n+\t{\n+\t  tree arg = PHI_ARG_DEF (stmt, 0);\n+\t  new_stmt = gimple_build_assign_with_ops (TREE_CODE (arg),\n+\t\t\t\t\t\t   gimple_phi_result (stmt),\n+\t\t\t\t\t\t   arg, NULL_TREE);\n+\t  SSA_NAME_DEF_STMT (gimple_phi_result (stmt)) = new_stmt;\n+\t}\n+      else\n+\t{\n+\t  basic_block dom = get_immediate_dominator (CDI_DOMINATORS, bb);\n+\t  gimple cond = gsi_stmt (gsi_last_bb (dom));\n+\t  tree arg0 = NULL_TREE, arg1 = NULL_TREE, t;\n+\t  /* Get the PHI arguments corresponding to the true and false\n+\t     edges of COND.  */\n+\t  extract_true_false_args_from_phi (dom, stmt, &arg0, &arg1);\n+\t  gcc_assert (arg0 && arg1);\n+\t  t = build2 (gimple_cond_code (cond), boolean_type_node,\n+\t\t      gimple_cond_lhs (cond), gimple_cond_rhs (cond));\n+\t  t = build3 (COND_EXPR, TREE_TYPE (gimple_phi_result (stmt)),\n+\t\t      t, arg0, arg1);\n+\t  new_stmt = gimple_build_assign_with_ops (COND_EXPR,\n+\t\t\t\t\t\t   gimple_phi_result (stmt),\n+\t\t\t\t\t\t   t, NULL_TREE);\n+\t  SSA_NAME_DEF_STMT (gimple_phi_result (stmt)) = new_stmt;\n+\t  *((unsigned int *)(dw_data->global_data)) |= TODO_cleanup_cfg;\n+\t}\n+      gsi_insert_on_edge (loop_preheader_edge (level), new_stmt);\n+      remove_phi_node (&bsi, false);\n+    }\n+\n   for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); )\n     {\n       stmt = gsi_stmt (bsi);\n@@ -1076,12 +1310,14 @@ move_computations_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n /* Hoist the statements out of the loops prescribed by data stored in\n    LIM_DATA structures associated with each statement.*/\n \n-static void\n+static unsigned int\n move_computations (void)\n {\n   struct dom_walk_data walk_data;\n+  unsigned int todo = 0;\n \n   memset (&walk_data, 0, sizeof (struct dom_walk_data));\n+  walk_data.global_data = &todo;\n   walk_data.dom_direction = CDI_DOMINATORS;\n   walk_data.before_dom_children = move_computations_stmt;\n \n@@ -1092,6 +1328,8 @@ move_computations (void)\n   gsi_commit_edge_inserts ();\n   if (need_ssa_update_p (cfun))\n     rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n+\n+  return todo;\n }\n \n /* Checks whether the statement defining variable *INDEX can be hoisted\n@@ -2328,9 +2566,11 @@ tree_ssa_lim_finalize (void)\n /* Moves invariants from loops.  Only \"expensive\" invariants are moved out --\n    i.e. those that are likely to be win regardless of the register pressure.  */\n \n-void\n+unsigned int\n tree_ssa_lim (void)\n {\n+  unsigned int todo;\n+\n   tree_ssa_lim_initialize ();\n \n   /* Gathers information about memory accesses in the loops.  */\n@@ -2345,7 +2585,9 @@ tree_ssa_lim (void)\n   store_motion ();\n \n   /* Move the expressions that are expensive enough.  */\n-  move_computations ();\n+  todo = move_computations ();\n \n   tree_ssa_lim_finalize ();\n+\n+  return todo;\n }"}, {"sha": "d1b1e8ec688bffc9568da0641d1ba9ea7bb59aa3", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3bdfed62abe1c163b93162e53a377b21b5658dc/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3bdfed62abe1c163b93162e53a377b21b5658dc/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=e3bdfed62abe1c163b93162e53a377b21b5658dc", "patch": "@@ -109,8 +109,7 @@ tree_ssa_loop_im (void)\n   if (number_of_loops () <= 1)\n     return 0;\n \n-  tree_ssa_lim ();\n-  return 0;\n+  return tree_ssa_lim ();\n }\n \n static bool"}]}