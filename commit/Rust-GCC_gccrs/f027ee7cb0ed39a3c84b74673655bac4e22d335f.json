{"sha": "f027ee7cb0ed39a3c84b74673655bac4e22d335f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAyN2VlN2NiMGVkMzlhM2M4NGI3NDY3MzY1NWJhYzRlMjJkMzM1Zg==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2011-07-04T08:02:50Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2011-07-04T08:02:50Z"}, "message": "In gcc/objc/: 2011-07-04 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/objc/:\n2011-07-04  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\tRefactored encoding code into objc-encoding.h and objc-encoding.c.\n\t* objc-act.c (util_obstack, util_firstobj, encode_type_qualifiers,\n\tencode_type, generating_instance_variables, objc_method_parm_type,\n\tobjc_encoded_type_size, encode_method_prototype,\n\tobjc_build_encode_expr, pointee_is_readonly, encode_pointer,\n\tencode_array, encode_vector, encode_aggregate_fields,\n\tencode_aggregate_within, encode_next_bitfield,\n\tencode_gnu_bitfield, encode_field_decl,\n\tobjc_v2_encode_property_attr): Moved to objc-encoding.h and\n\tobjc-encoding.c.  No change in the actual code.\n\tInclude objc-encoding.h.\n\t(objc_init): Added TODO.\n\t(objc_build_property_setter_name): Made non-static so it can be\n\tcalled from objc-encoding.c.\n\t* objc-act.h (OBJC_ENCODE_INLINE_DEFS,\n\tOBJC_ENCODE_DONT_INLINE_DEFS): Moved to objc-encoding.h.\n\t* objc-runtime-shared-support.h (objc_v2_encode_property_attr,\n\tencode_method_prototype, encode_field_decl,\n\tgenerating_instance_variables): Moved to objc-encoding.h.\t\n\t(objc_build_property_setter_name): Declare.\n\t* objc-encoding.c: New.\n\t* objc-encoding.h: New.\n\t* objc-gnu-runtime-abi-01.c: Include objc-encoding.h.\n\t* objc-next-runtime-abi-01.c: Likewise.\n\t* objc-next-runtime-abi-02.c: Likewise.\t\n\t* objc-runtime-shared-support.c: Likewise.\n\t* Make-lang.in (OBJC_OBJS): Added objc-encoding.o.\n\t(objc/objc-lang.o): Reordered dependencies.\n\t(objc/objc-runtime-shared-support.o): Reordered dependencies.\n\tAdded dependencies on objc-encoding.h and on $(GGC_H),\n\t$(DIAGNOSTIC_CORE_H), $(FLAGS_H) and input.h.\n\t(objc/objc-gnu-runtime-abi-01.o): Likewise.\n\t(objc/objc-next-runtime-abi-01.o): Likewise.\n\t(objc/objc-next-runtime-abi-02.o): Likewise.\n\t(objc/objc-act.o): Reordered dependencies.  Added dependency on\n\tobjc-encoding.h.\n\t(objc/objc-encoding.o): New rule.\n\n\t* objc-encoding.c (encode_type): Use \"%<%T%>\" format when printing\n\twarning \"unknown type %<%T%> found during Objective-C encoding\"\n\tinstead of using gen_type_name.\n\t\nIn gcc/objcp/:\n2011-07-04  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* Make-lang.in (OBJCXX_OBJS): Added objc-encoding.o.\n\t(objcp/objcp-lang.o): Reordered dependencies.  Depend on GGC_H.\n\t(objcp/objcp-decl.o): Reordered dependencies.\n\t(objcp/objc-runtime-shared-support.o): Reordered dependencies.\n\tUpdated them to be identical to the corresponding new objc/ ones,\n\twith the addition of objcp-decl.h.\n\t(objcp/objc-runtime-shared-support.o): Likewise.\n\t(objcp/objc-gnu-runtime-abi-01.o): Likewise.\n\t(objcp/objc-next-runtime-abi-01.o): Likewise.\n\t(objcp/objc-next-runtime-abi-02.o): Likewise.\n\t(objcp/objcp-act.o): Reordered dependencies.  Added dependency on\n\tobjc-encoding.h.\n\t(objcp/objc-encoding.o): New rule.\n\nFrom-SVN: r175797", "tree": {"sha": "cb74883a8d479cb7d23bc099e02c2f37121c8ed6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb74883a8d479cb7d23bc099e02c2f37121c8ed6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f027ee7cb0ed39a3c84b74673655bac4e22d335f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f027ee7cb0ed39a3c84b74673655bac4e22d335f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f027ee7cb0ed39a3c84b74673655bac4e22d335f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f027ee7cb0ed39a3c84b74673655bac4e22d335f/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7e6fd113c9b2eacbb749254064bb54e436efd1c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e6fd113c9b2eacbb749254064bb54e436efd1c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e6fd113c9b2eacbb749254064bb54e436efd1c7"}], "stats": {"total": 2163, "additions": 1207, "deletions": 956}, "files": [{"sha": "e27419775468a9ba3f193e4cf2233fa8637ef448", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=f027ee7cb0ed39a3c84b74673655bac4e22d335f", "patch": "@@ -1,3 +1,47 @@\n+2011-07-04  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tRefactored encoding code into objc-encoding.h and objc-encoding.c.\n+\t* objc-act.c (util_obstack, util_firstobj, encode_type_qualifiers,\n+\tencode_type, generating_instance_variables, objc_method_parm_type,\n+\tobjc_encoded_type_size, encode_method_prototype,\n+\tobjc_build_encode_expr, pointee_is_readonly, encode_pointer,\n+\tencode_array, encode_vector, encode_aggregate_fields,\n+\tencode_aggregate_within, encode_next_bitfield,\n+\tencode_gnu_bitfield, encode_field_decl,\n+\tobjc_v2_encode_property_attr): Moved to objc-encoding.h and\n+\tobjc-encoding.c.  No change in the actual code.\n+\tInclude objc-encoding.h.\n+\t(objc_init): Added TODO.\n+\t(objc_build_property_setter_name): Made non-static so it can be\n+\tcalled from objc-encoding.c.\n+\t* objc-act.h (OBJC_ENCODE_INLINE_DEFS,\n+\tOBJC_ENCODE_DONT_INLINE_DEFS): Moved to objc-encoding.h.\n+\t* objc-runtime-shared-support.h (objc_v2_encode_property_attr,\n+\tencode_method_prototype, encode_field_decl,\n+\tgenerating_instance_variables): Moved to objc-encoding.h.\t\n+\t(objc_build_property_setter_name): Declare.\n+\t* objc-encoding.c: New.\n+\t* objc-encoding.h: New.\n+\t* objc-gnu-runtime-abi-01.c: Include objc-encoding.h.\n+\t* objc-next-runtime-abi-01.c: Likewise.\n+\t* objc-next-runtime-abi-02.c: Likewise.\t\n+\t* objc-runtime-shared-support.c: Likewise.\n+\t* Make-lang.in (OBJC_OBJS): Added objc-encoding.o.\n+\t(objc/objc-lang.o): Reordered dependencies.\n+\t(objc/objc-runtime-shared-support.o): Reordered dependencies.\n+\tAdded dependencies on objc-encoding.h and on $(GGC_H),\n+\t$(DIAGNOSTIC_CORE_H), $(FLAGS_H) and input.h.\n+\t(objc/objc-gnu-runtime-abi-01.o): Likewise.\n+\t(objc/objc-next-runtime-abi-01.o): Likewise.\n+\t(objc/objc-next-runtime-abi-02.o): Likewise.\n+\t(objc/objc-act.o): Reordered dependencies.  Added dependency on\n+\tobjc-encoding.h.\n+\t(objc/objc-encoding.o): New rule.\n+\n+\t* objc-encoding.c (encode_type): Use \"%<%T%>\" format when printing\n+\twarning \"unknown type %<%T%> found during Objective-C encoding\"\n+\tinstead of using gen_type_name.\n+\t\n 2011-06-05  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (receiver_is_class_object): Expanded comment."}, {"sha": "1ac74ba4549b9aee7307195ff7289fcad9018d0e", "filename": "gcc/objc/Make-lang.in", "status": "modified", "additions": 67, "deletions": 24, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FMake-lang.in?ref=f027ee7cb0ed39a3c84b74673655bac4e22d335f", "patch": "@@ -55,6 +55,7 @@ OBJC_OBJS = objc/objc-lang.o objc/objc-act.o \\\n    objc/objc-gnu-runtime-abi-01.o \\\n    objc/objc-next-runtime-abi-01.o \\\n    objc/objc-next-runtime-abi-02.o \\\n+   objc/objc-encoding.o\n \n objc_OBJS = $(OBJC_OBJS) cc1obj-checksum.o\n \n@@ -73,33 +74,75 @@ cc1obj$(exeext): $(OBJC_OBJS) $(C_AND_OBJC_OBJS) cc1obj-checksum.o $(BACKEND) $(\n \n # Objective C language specific files.\n \n-objc/objc-lang.o : objc/objc-lang.c $(START_HDRS) \\\n-   $(GGC_H) $(LANGHOOKS_DEF_H) $(C_COMMON_H) gtype-objc.h \\\n+# When editing, please keep the objc/ header dependencies in\n+# alphabetical order, and try to use a similar logical order for the\n+# other files between the different targets.\n+\n+objc/objc-lang.o : objc/objc-lang.c \\\n+   $(START_HDRS) \\\n+   $(GGC_H) \\\n+   $(LANGHOOKS_DEF_H) $(C_COMMON_H) gtype-objc.h \\\n    c-objc-common.h\n \n objc/objc-runtime-shared-support.o : objc/objc-runtime-shared-support.c \\\n-   $(START_HDRS) objc/objc-runtime-shared-support.h $(OBSTACK_H) \\\n-   objc/objc-next-metadata-tags.h gt-objc-objc-runtime-shared-support.h\n-\n-objc/objc-gnu-runtime-abi-01.o: objc/objc-gnu-runtime-abi-01.c $(START_HDRS) \\\n-   objc/objc-runtime-hooks.h $(GGC_H) \\\n-   objc/objc-runtime-shared-support.h gt-objc-objc-gnu-runtime-abi-01.h toplev.h\n-\n-objc/objc-next-runtime-abi-01.o: objc/objc-next-runtime-abi-01.c $(START_HDRS) \\\n-   $(GGC_H) objc/objc-runtime-hooks.h \\\n-   objc/objc-next-metadata-tags.h gt-objc-objc-next-runtime-abi-01.h output.h \\\n-   objc/objc-runtime-shared-support.h $(TARGET_H)\n-\n-objc/objc-next-runtime-abi-02.o: objc/objc-next-runtime-abi-02.c $(START_HDRS) \\\n-   $(GGC_H) objc/objc-runtime-hooks.h \\\n-   objc/objc-next-metadata-tags.h gt-objc-objc-next-runtime-abi-02.h $(TARGET_H) \\\n-   objc/objc-runtime-shared-support.h $(OBSTACK_H)\n-\n-objc/objc-act.o : objc/objc-act.c $(START_HDRS) $(GGC_H) \\\n-   $(DIAGNOSTIC_CORE_H) toplev.h $(FLAGS_H) input.h $(FUNCTION_H) output.h debug.h \\\n-   $(LANGHOOKS_DEF_H) $(HASHTAB_H) $(C_PRAGMA_H) gt-objc-objc-act.h $(OBSTACK_H) \\\n-   $(GIMPLE_H) objc/objc-runtime-shared-support.h objc/objc-runtime-hooks.h \\\n-   $(C_TARGET_H)\n+   gt-objc-objc-runtime-shared-support.h \\\n+   $(START_HDRS) \\\n+   $(GGC_H) $(DIAGNOSTIC_CORE_H) $(FLAGS_H) input.h \\\n+   $(OBSTACK_H) \\\n+   objc/objc-encoding.h \\\n+   objc/objc-next-metadata-tags.h \\\n+   objc/objc-runtime-shared-support.h\n+\n+objc/objc-gnu-runtime-abi-01.o: objc/objc-gnu-runtime-abi-01.c \\\n+   gt-objc-objc-gnu-runtime-abi-01.h \\\n+   $(START_HDRS) \\\n+   $(GGC_H) $(DIAGNOSTIC_CORE_H) $(FLAGS_H) input.h \\\n+   $(OBSTACK_H) \\\n+   toplev.h \\\n+   objc/objc-encoding.h \\\n+   objc/objc-runtime-hooks.h \\\n+   objc/objc-runtime-shared-support.h\n+\n+objc/objc-next-runtime-abi-01.o: objc/objc-next-runtime-abi-01.c \\\n+   gt-objc-objc-next-runtime-abi-01.h \\\n+   $(START_HDRS) \\\n+   $(GGC_H) $(DIAGNOSTIC_CORE_H) $(FLAGS_H) input.h \\\n+   $(OBSTACK_H) \\\n+   $(TARGET_H) output.h \\\n+   objc/objc-encoding.h \\\n+   objc/objc-next-metadata-tags.h \\\n+   objc/objc-runtime-hooks.h \\\n+   objc/objc-runtime-shared-support.h\n+\n+objc/objc-next-runtime-abi-02.o: objc/objc-next-runtime-abi-02.c \\\n+   gt-objc-objc-next-runtime-abi-02.h \\\n+   $(START_HDRS) \\\n+   $(GGC_H) $(DIAGNOSTIC_CORE_H) $(FLAGS_H) input.h \\\n+   $(OBSTACK_H) \\\n+   $(TARGET_H) \\\n+   objc/objc-encoding.h \\\n+   objc/objc-next-metadata-tags.h \\\n+   objc/objc-runtime-hooks.h \\\n+   objc/objc-runtime-shared-support.h\n+\n+objc/objc-act.o : objc/objc-act.c \\\n+   gt-objc-objc-act.h \\\n+   $(START_HDRS) \\\n+   $(GGC_H) $(DIAGNOSTIC_CORE_H) $(FLAGS_H) input.h \\\n+   $(OBSTACK_H) \\\n+   toplev.h $(FUNCTION_H) output.h debug.h $(LANGHOOKS_DEF_H) \\\n+   $(HASHTAB_H) $(GIMPLE_H) \\\n+   $(C_PRAGMA_H) $(C_TARGET_H) \\\n+   objc/objc-encoding.h \\\n+   objc/objc-runtime-hooks.h \\\n+   objc/objc-runtime-shared-support.h\n+\n+objc/objc-encoding.o : objc/objc-encoding.c \\\n+   $(START_HDRS) \\\n+   $(GGC_H) $(DIAGNOSTIC_CORE_H) $(FLAGS_H) input.h \\\n+   $(OBSTACK_H) \\\n+   objc/objc-encoding.h \\\n+   objc/objc-runtime-shared-support.h\n \n objc.srcextra:\n "}, {"sha": "14db224df75388364299234f7a4b28493a7d36f5", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 5, "deletions": 901, "changes": 906, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=f027ee7cb0ed39a3c84b74673655bac4e22d335f", "patch": "@@ -64,6 +64,9 @@ along with GCC; see the file COPYING3.  If not see\n /* For enum gimplify_status */\n #include \"gimple.h\"\n \n+/* For encode_method_prototype().  */\n+#include \"objc-encoding.h\"\n+\n static unsigned int should_call_super_dealloc = 0;\n \n /* When building Objective-C++, we are not linking against the C front-end\n@@ -105,17 +108,6 @@ static unsigned int should_call_super_dealloc = 0;\n #define OBJC_FORWARDING_MIN_OFFSET 0\n #endif\n \n-/* Set up for use of obstacks.  */\n-\n-#include \"obstack.h\"\n-\n-/* This obstack is used to accumulate the encoding of a data type.  */\n-struct obstack util_obstack;\n-\n-/* This points to the beginning of obstack contents, so we can free\n-   the whole contents.  */\n-char *util_firstobj;\n-\n /*** Private Interface (procedures) ***/\n \n /* Init stuff.  */\n@@ -146,7 +138,6 @@ static bool objc_derived_from_p (tree, tree);\n static void objc_gen_property_data (tree, tree);\n static void objc_synthesize_getter (tree, tree, tree);\n static void objc_synthesize_setter (tree, tree, tree);\n-static char *objc_build_property_setter_name (tree);\n static tree lookup_property (tree, tree);\n static tree lookup_property_in_list (tree, tree);\n static tree lookup_property_in_protocol_list (tree, tree);\n@@ -195,11 +186,6 @@ static inline tree lookup_category (tree, tree);\n static tree lookup_protocol (tree, bool, bool);\n static tree lookup_and_install_protocols (tree, bool);\n \n-/* Type encoding.  */\n-\n-static void encode_type_qualifiers (tree);\n-static void encode_type (tree, int, int);\n-\n #ifdef OBJCPLUS\n static void really_start_method (tree, tree);\n #else\n@@ -279,13 +265,6 @@ static GTY((param_is (struct string_descriptor))) htab_t string_htab;\n \n FILE *gen_declaration_file;\n \n-/* Tells \"encode_pointer/encode_aggregate\" whether we are generating\n-   type descriptors for instance variables (as opposed to methods).\n-   Type descriptors for instance variables contain more information\n-   than methods (for static typing and embedded structures).  */\n-\n-int generating_instance_variables = 0;\n-\n /* Hooks for stuff that differs between runtimes.  */\n objc_runtime_hooks runtime;\n \n@@ -402,9 +381,9 @@ objc_init (void)\n   /* Set up stuff used by FE parser and all runtimes.  */\n   errbuf = XNEWVEC (char, 1024 * 10);\n   hash_init ();\n+  /* TODO: Use objc_encoding_init().  */\n   gcc_obstack_init (&util_obstack);\n   util_firstobj = (char *) obstack_finish (&util_obstack);\n-\n   /* ... and then check flags and set-up for the selected runtime ... */\n   if (flag_next_runtime && flag_objc_abi >= 2)\n     ok = objc_next_runtime_abi_02_init (&runtime);\n@@ -4451,110 +4430,6 @@ build_private_template (tree klass)\n     }\n }\n \n-/* Begin code generation for protocols...  */\n-\n-static tree\n-objc_method_parm_type (tree type)\n-{\n-  type = TREE_VALUE (TREE_TYPE (type));\n-  if (TREE_CODE (type) == TYPE_DECL)\n-    type = TREE_TYPE (type);\n-  return type;\n-}\n-\n-static int\n-objc_encoded_type_size (tree type)\n-{\n-  int sz = int_size_in_bytes (type);\n-\n-  /* Make all integer and enum types at least as large\n-     as an int.  */\n-  if (sz > 0 && INTEGRAL_TYPE_P (type))\n-    sz = MAX (sz, int_size_in_bytes (integer_type_node));\n-  /* Treat arrays as pointers, since that's how they're\n-     passed in.  */\n-  else if (TREE_CODE (type) == ARRAY_TYPE)\n-    sz = int_size_in_bytes (ptr_type_node);\n-  return sz;\n-}\n-\n-/* Encode a method prototype.\n-\n-   The format is described in gcc/doc/objc.texi, section 'Method\n-   signatures'.\n- */\n-\n-tree\n-encode_method_prototype (tree method_decl)\n-{\n-  tree parms;\n-  int parm_offset, i;\n-  char buf[40];\n-  tree result;\n-\n-  /* ONEWAY and BYCOPY, for remote object are the only method qualifiers.  */\n-  encode_type_qualifiers (TREE_PURPOSE (TREE_TYPE (method_decl)));\n-\n-  /* Encode return type.  */\n-  encode_type (objc_method_parm_type (method_decl),\n-\t       obstack_object_size (&util_obstack),\n-\t       OBJC_ENCODE_INLINE_DEFS);\n-\n-  /* Stack size.  */\n-  /* The first two arguments (self and _cmd) are pointers; account for\n-     their size.  */\n-  i = int_size_in_bytes (ptr_type_node);\n-  parm_offset = 2 * i;\n-  for (parms = METHOD_SEL_ARGS (method_decl); parms;\n-       parms = DECL_CHAIN (parms))\n-    {\n-      tree type = objc_method_parm_type (parms);\n-      int sz = objc_encoded_type_size (type);\n-\n-      /* If a type size is not known, bail out.  */\n-      if (sz < 0)\n-\t{\n-\t  error_at (DECL_SOURCE_LOCATION (method_decl),\n-\t\t    \"type %qT does not have a known size\",\n-\t\t    type);\n-\t  /* Pretend that the encoding succeeded; the compilation will\n-\t     fail nevertheless.  */\n-\t  goto finish_encoding;\n-\t}\n-      parm_offset += sz;\n-    }\n-\n-  sprintf (buf, \"%d@0:%d\", parm_offset, i);\n-  obstack_grow (&util_obstack, buf, strlen (buf));\n-\n-  /* Argument types.  */\n-  parm_offset = 2 * i;\n-  for (parms = METHOD_SEL_ARGS (method_decl); parms;\n-       parms = DECL_CHAIN (parms))\n-    {\n-      tree type = objc_method_parm_type (parms);\n-\n-      /* Process argument qualifiers for user supplied arguments.  */\n-      encode_type_qualifiers (TREE_PURPOSE (TREE_TYPE (parms)));\n-\n-      /* Type.  */\n-      encode_type (type, obstack_object_size (&util_obstack),\n-\t\t   OBJC_ENCODE_INLINE_DEFS);\n-\n-      /* Compute offset.  */\n-      sprintf (buf, \"%d\", parm_offset);\n-      parm_offset += objc_encoded_type_size (type);\n-\n-      obstack_grow (&util_obstack, buf, strlen (buf));\n-    }\n-\n-  finish_encoding:\n-  obstack_1grow (&util_obstack, '\\0');\n-  result = get_identifier (XOBFINISH (&util_obstack, char *));\n-  obstack_free (&util_obstack, util_firstobj);\n-  return result;\n-}\n-\n /* Generate either '- .cxx_construct' or '- .cxx_destruct' for the\n    current class.  */\n #ifdef OBJCPLUS\n@@ -5864,25 +5739,6 @@ objc_build_selector_expr (location_t loc, tree selnamelist)\n   return (*runtime.build_selector_reference) (loc, selname, NULL_TREE);\n }\n \n-/* This is used to implement @encode().  See gcc/doc/objc.texi,\n-   section '@encode'.  */\n-tree\n-objc_build_encode_expr (tree type)\n-{\n-  tree result;\n-  const char *string;\n-\n-  encode_type (type, obstack_object_size (&util_obstack),\n-\t       OBJC_ENCODE_INLINE_DEFS);\n-  obstack_1grow (&util_obstack, 0);    /* null terminate string */\n-  string = XOBFINISH (&util_obstack, const char *);\n-\n-  /* Synthesize a string that represents the encoded struct/union.  */\n-  result = my_build_string (strlen (string) + 1, string);\n-  obstack_free (&util_obstack, util_firstobj);\n-  return result;\n-}\n-\n static tree\n build_ivar_reference (tree id)\n {\n@@ -7308,7 +7164,7 @@ continue_class (tree klass)\n }\n \n /* This routine builds name of the setter synthesized function. */\n-static char *\n+char *\n objc_build_property_setter_name (tree ident)\n {\n   /* TODO: Use alloca to allocate buffer of appropriate size.  */\n@@ -10306,758 +10162,6 @@ objc_check_format_arg (tree ARG_UNUSED (format_arg),\n {\n }\n \n-/* --- Encode --- */\n-/* \"Encode\" a data type into a string, which grows in util_obstack.\n-\n-   The format is described in gcc/doc/objc.texi, section 'Type\n-   encoding'.\n-\n-   Most of the encode_xxx functions have a 'type' argument, which is\n-   the type to encode, and an integer 'curtype' argument, which is the\n-   index in the encoding string of the beginning of the encoding of\n-   the current type, and allows you to find what characters have\n-   already been written for the current type (they are the ones in the\n-   current encoding string starting from 'curtype').\n-\n-   For example, if we are encoding a method which returns 'int' and\n-   takes a 'char **' argument, then when we get to the point of\n-   encoding the 'char **' argument, the encoded string already\n-   contains 'i12@0:4' (assuming a pointer size of 4 bytes).  So,\n-   'curtype' will be set to 7 when starting to encode 'char **'.\n-   During the whole of the encoding of 'char **', 'curtype' will be\n-   fixed at 7, so the routine encoding the second pointer can find out\n-   that it's actually encoding a pointer to a pointer by looking\n-   backwards at what has already been encoded for the current type,\n-   and seeing there is a \"^\" (meaning a pointer) in there.\n-*/\n-\n-\n-/* Encode type qualifiers encodes one of the \"PQ\" Objective-C\n-   keywords, ie 'in', 'out', 'inout', 'bycopy', 'byref', 'oneway'.\n-   'const', instead, is encoded directly as part of the type.\n- */\n-\n-static void\n-encode_type_qualifiers (tree declspecs)\n-{\n-  tree spec;\n-\n-  for (spec = declspecs; spec; spec = TREE_CHAIN (spec))\n-    {\n-      /* FIXME: Shouldn't we use token->keyword here ? */\n-      if (ridpointers[(int) RID_IN] == TREE_VALUE (spec))\n-\tobstack_1grow (&util_obstack, 'n');\n-      else if (ridpointers[(int) RID_INOUT] == TREE_VALUE (spec))\n-\tobstack_1grow (&util_obstack, 'N');\n-      else if (ridpointers[(int) RID_OUT] == TREE_VALUE (spec))\n-\tobstack_1grow (&util_obstack, 'o');\n-      else if (ridpointers[(int) RID_BYCOPY] == TREE_VALUE (spec))\n-\tobstack_1grow (&util_obstack, 'O');\n-      else if (ridpointers[(int) RID_BYREF] == TREE_VALUE (spec))\n-        obstack_1grow (&util_obstack, 'R');\n-      else if (ridpointers[(int) RID_ONEWAY] == TREE_VALUE (spec))\n-\tobstack_1grow (&util_obstack, 'V');\n-      else\n-\tgcc_unreachable ();\n-    }\n-}\n-\n-/* Determine if a pointee is marked read-only.  Only used by the NeXT\n-   runtime to be compatible with gcc-3.3.  */\n-\n-static bool\n-pointee_is_readonly (tree pointee)\n-{\n-  while (POINTER_TYPE_P (pointee))\n-    pointee = TREE_TYPE (pointee);\n-\n-  return TYPE_READONLY (pointee);\n-}\n-\n-/* Encode a pointer type.  */\n-\n-static void\n-encode_pointer (tree type, int curtype, int format)\n-{\n-  tree pointer_to = TREE_TYPE (type);\n-\n-  if (flag_next_runtime)\n-    {\n-      /* This code is used to be compatible with gcc-3.3.  */\n-      /* For historical/compatibility reasons, the read-only qualifier\n-\t of the pointee gets emitted _before_ the '^'.  The read-only\n-\t qualifier of the pointer itself gets ignored, _unless_ we are\n-\t looking at a typedef!  Also, do not emit the 'r' for anything\n-\t but the outermost type!  */\n-      if (!generating_instance_variables\n-\t  && (obstack_object_size (&util_obstack) - curtype <= 1)\n-\t  && (TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-\t      ? TYPE_READONLY (type)\n-\t      : pointee_is_readonly (pointer_to)))\n-\tobstack_1grow (&util_obstack, 'r');\n-    }\n-\n-  if (TREE_CODE (pointer_to) == RECORD_TYPE)\n-    {\n-      if (OBJC_TYPE_NAME (pointer_to)\n-\t  && TREE_CODE (OBJC_TYPE_NAME (pointer_to)) == IDENTIFIER_NODE)\n-\t{\n-\t  const char *name = IDENTIFIER_POINTER (OBJC_TYPE_NAME (pointer_to));\n-\n-\t  if (strcmp (name, TAG_OBJECT) == 0) /* '@' */\n-\t    {\n-\t      obstack_1grow (&util_obstack, '@');\n-\t      return;\n-\t    }\n-\t  else if (TYPE_HAS_OBJC_INFO (pointer_to)\n-\t\t   && TYPE_OBJC_INTERFACE (pointer_to))\n-\t    {\n-              if (generating_instance_variables)\n-\t        {\n-\t          obstack_1grow (&util_obstack, '@');\n-\t          obstack_1grow (&util_obstack, '\"');\n-\t          obstack_grow (&util_obstack, name, strlen (name));\n-\t          obstack_1grow (&util_obstack, '\"');\n-\t          return;\n-\t\t}\n-              else\n-\t        {\n-\t          obstack_1grow (&util_obstack, '@');\n-\t          return;\n-\t\t}\n-\t    }\n-\t  else if (strcmp (name, TAG_CLASS) == 0) /* '#' */\n-\t    {\n-\t      obstack_1grow (&util_obstack, '#');\n-\t      return;\n-\t    }\n-\t  else if (strcmp (name, TAG_SELECTOR) == 0) /* ':' */\n-\t    {\n-\t      obstack_1grow (&util_obstack, ':');\n-\t      return;\n-\t    }\n-\t}\n-    }\n-  else if (TREE_CODE (pointer_to) == INTEGER_TYPE\n-\t   && TYPE_MODE (pointer_to) == QImode)\n-    {\n-      tree pname = TREE_CODE (OBJC_TYPE_NAME (pointer_to)) == IDENTIFIER_NODE\n-\t          ? OBJC_TYPE_NAME (pointer_to)\n-\t          : DECL_NAME (OBJC_TYPE_NAME (pointer_to));\n-\n-      /* (BOOL *) are an exception and are encoded as ^c, while all\n-\t other pointers to char are encoded as *.   */\n-      if (strcmp (IDENTIFIER_POINTER (pname), \"BOOL\"))\n-\t{\n-\t  if (!flag_next_runtime)\n-\t    {\n-\t      /* The NeXT runtime adds the 'r' before getting here.  */\n-\n-\t      /* It appears that \"r*\" means \"const char *\" rather than\n-\t\t \"char *const\".  \"char *const\" is encoded as \"*\",\n-\t\t which is identical to \"char *\", so the \"const\" is\n-\t\t unfortunately lost.  */\n-\t      if (TYPE_READONLY (pointer_to))\n-\t\tobstack_1grow (&util_obstack, 'r');\n-\t    }\n-\n-\t  obstack_1grow (&util_obstack, '*');\n-\t  return;\n-\t}\n-    }\n-\n-  /* We have a normal pointer type that does not get special treatment.  */\n-  obstack_1grow (&util_obstack, '^');\n-  encode_type (pointer_to, curtype, format);\n-}\n-\n-static void\n-encode_array (tree type, int curtype, int format)\n-{\n-  tree an_int_cst = TYPE_SIZE (type);\n-  tree array_of = TREE_TYPE (type);\n-  char buffer[40];\n-\n-  if (an_int_cst == NULL)\n-    {\n-      /* We are trying to encode an incomplete array.  An incomplete\n-\t array is forbidden as part of an instance variable; but it\n-\t may occur if the instance variable is a pointer to such an\n-\t array.  */\n-\n-      /* So the only case in which an incomplete array could occur\n-\t (without being pointed to) is if we are encoding the\n-\t arguments or return value of a method.  In that case, an\n-\t incomplete array argument or return value (eg,\n-\t -(void)display: (char[])string) is treated like a pointer\n-\t because that is how the compiler does the function call.  A\n-\t special, more complicated case, is when the incomplete array\n-\t is the last member of a struct (eg, if we are encoding\n-\t \"struct { unsigned long int a;double b[];}\"), which is again\n-\t part of a method argument/return value.  In that case, we\n-\t really need to communicate to the runtime that there is an\n-\t incomplete array (not a pointer!) there.  So, we detect that\n-\t special case and encode it as a zero-length array.\n-\n-\t Try to detect that we are part of a struct.  We do this by\n-\t searching for '=' in the type encoding for the current type.\n-\t NB: This hack assumes that you can't use '=' as part of a C\n-\t identifier.\n-      */\n-      {\n-\tchar *enc = obstack_base (&util_obstack) + curtype;\n-\tif (memchr (enc, '=',\n-\t\t    obstack_object_size (&util_obstack) - curtype) == NULL)\n-\t  {\n-\t    /* We are not inside a struct.  Encode the array as a\n-\t       pointer.  */\n-\t    encode_pointer (type, curtype, format);\n-\t    return;\n-\t  }\n-      }\n-\n-      /* Else, we are in a struct, and we encode it as a zero-length\n-\t array.  */\n-      sprintf (buffer, \"[\" HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT)0);\n-    }\n-  else if (TREE_INT_CST_LOW (TYPE_SIZE (array_of)) == 0)\n-   sprintf (buffer, \"[\" HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT)0);\n-  else\n-    sprintf (buffer, \"[\" HOST_WIDE_INT_PRINT_DEC,\n-\t     TREE_INT_CST_LOW (an_int_cst)\n-\t      / TREE_INT_CST_LOW (TYPE_SIZE (array_of)));\n-\n-  obstack_grow (&util_obstack, buffer, strlen (buffer));\n-  encode_type (array_of, curtype, format);\n-  obstack_1grow (&util_obstack, ']');\n-  return;\n-}\n-\n-/* Encode a vector.  The vector type is a GCC extension to C.  */\n-static void\n-encode_vector (tree type, int curtype, int format)\n-{\n-  tree vector_of = TREE_TYPE (type);\n-  char buffer[40];\n-\n-  /* Vectors are like simple fixed-size arrays.  */\n-\n-  /* Output ![xx,yy,<code>] where xx is the vector_size, yy is the\n-     alignment of the vector, and <code> is the base type.  Eg, int\n-     __attribute__ ((vector_size (16))) gets encoded as ![16,32,i]\n-     assuming that the alignment is 32 bytes.  We include size and\n-     alignment in bytes so that the runtime does not have to have any\n-     knowledge of the actual types.\n-  */\n-  sprintf (buffer, \"![\" HOST_WIDE_INT_PRINT_DEC \",%d\",\n-\t   /* We want to compute the equivalent of sizeof (<vector>).\n-\t      Code inspired by c_sizeof_or_alignof_type.  */\n-\t   ((TREE_INT_CST_LOW (TYPE_SIZE_UNIT (type))\n-\t     / (TYPE_PRECISION (char_type_node) / BITS_PER_UNIT))),\n-\t   /* We want to compute the equivalent of __alignof__\n-\t      (<vector>).  Code inspired by\n-\t      c_sizeof_or_alignof_type.  */\n-\t   TYPE_ALIGN_UNIT (type));\n-  obstack_grow (&util_obstack, buffer, strlen (buffer));\n-  encode_type (vector_of, curtype, format);\n-  obstack_1grow (&util_obstack, ']');\n-  return;\n-}\n-\f\n-static void\n-encode_aggregate_fields (tree type, bool pointed_to, int curtype, int format)\n-{\n-  tree field = TYPE_FIELDS (type);\n-\n-  for (; field; field = DECL_CHAIN (field))\n-    {\n-#ifdef OBJCPLUS\n-      /* C++ static members, and things that are not field at all,\n-\t should not appear in the encoding.  */\n-      if (TREE_CODE (field) != FIELD_DECL || TREE_STATIC (field))\n-\tcontinue;\n-#endif\n-\n-      /* Recursively encode fields of embedded base classes.  */\n-      if (DECL_ARTIFICIAL (field) && !DECL_NAME (field)\n-\t  && TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE)\n-\t{\n-\t  encode_aggregate_fields (TREE_TYPE (field),\n-\t\t\t\t   pointed_to, curtype, format);\n-\t  continue;\n-\t}\n-\n-      if (generating_instance_variables && !pointed_to)\n-\t{\n-\t  tree fname = DECL_NAME (field);\n-\n-\t  obstack_1grow (&util_obstack, '\"');\n-\n-\t  if (fname && TREE_CODE (fname) == IDENTIFIER_NODE)\n-\t    obstack_grow (&util_obstack,\n-\t\t\t  IDENTIFIER_POINTER (fname),\n-\t\t\t  strlen (IDENTIFIER_POINTER (fname)));\n-\n-\t  obstack_1grow (&util_obstack, '\"');\n-        }\n-\n-      encode_field_decl (field, curtype, format);\n-    }\n-}\n-\n-static void\n-encode_aggregate_within (tree type, int curtype, int format, int left,\n-\t\t\t int right)\n-{\n-  tree name;\n-  /* NB: aggregates that are pointed to have slightly different encoding\n-     rules in that you never encode the names of instance variables.  */\n-  int ob_size = obstack_object_size (&util_obstack);\n-  bool inline_contents = false;\n-  bool pointed_to = false;\n-\n-  if (flag_next_runtime)\n-    {\n-      if (ob_size > 0  &&  *(obstack_next_free (&util_obstack) - 1) == '^')\n-\tpointed_to = true;\n-\n-      if ((format == OBJC_ENCODE_INLINE_DEFS || generating_instance_variables)\n-\t  && (!pointed_to || ob_size - curtype == 1\n-\t      || (ob_size - curtype == 2\n-\t\t  && *(obstack_next_free (&util_obstack) - 2) == 'r')))\n-\tinline_contents = true;\n-    }\n-  else\n-    {\n-      /* c0 and c1 are the last two characters in the encoding of the\n-\t current type; if the last two characters were '^' or '^r',\n-\t then we are encoding an aggregate that is \"pointed to\".  The\n-\t comment above applies: in that case we should avoid encoding\n-\t the names of instance variables.\n-      */\n-      char c1 = ob_size > 1 ? *(obstack_next_free (&util_obstack) - 2) : 0;\n-      char c0 = ob_size > 0 ? *(obstack_next_free (&util_obstack) - 1) : 0;\n-\n-      if (c0 == '^' || (c1 == '^' && c0 == 'r'))\n-\tpointed_to = true;\n-\n-      if (format == OBJC_ENCODE_INLINE_DEFS || generating_instance_variables)\n-\t{\n-\t  if (!pointed_to)\n-\t    inline_contents = true;\n-\t  else\n-\t    {\n-\t      /* Note that the check (ob_size - curtype < 2) prevents\n-\t\t infinite recursion when encoding a structure which is\n-\t\t a linked list (eg, struct node { struct node *next;\n-\t\t }).  Each time we follow a pointer, we add one\n-\t\t character to ob_size, and curtype is fixed, so after\n-\t\t at most two pointers we stop inlining contents and\n-\t\t break the loop.\n-\n-\t\t The other case where we don't inline is \"^r\", which\n-\t\t is a pointer to a constant struct.\n-\t      */\n-\t      if ((ob_size - curtype <= 2) && !(c0 == 'r'))\n-\t\tinline_contents = true;\n-\t    }\n-\t}\n-    }\n-\n-  /* Traverse struct aliases; it is important to get the\n-     original struct and its tag name (if any).  */\n-  type = TYPE_MAIN_VARIANT (type);\n-  name = OBJC_TYPE_NAME (type);\n-  /* Open parenth/bracket.  */\n-  obstack_1grow (&util_obstack, left);\n-\n-  /* Encode the struct/union tag name, or '?' if a tag was\n-     not provided.  Typedef aliases do not qualify.  */\n-#ifdef OBJCPLUS\n-  /* For compatibility with the NeXT runtime, ObjC++ encodes template\n-     args as a composite struct tag name. */\n-  if (name && TREE_CODE (name) == IDENTIFIER_NODE\n-      /* Did this struct have a tag?  */\n-      && !TYPE_WAS_ANONYMOUS (type))\n-    obstack_grow (&util_obstack,\n-\t\t  decl_as_string (type, TFF_DECL_SPECIFIERS | TFF_UNQUALIFIED_NAME),\n-\t\t  strlen (decl_as_string (type, TFF_DECL_SPECIFIERS | TFF_UNQUALIFIED_NAME)));\n-#else\n-  if (name && TREE_CODE (name) == IDENTIFIER_NODE)\n-    obstack_grow (&util_obstack,\n-\t\t  IDENTIFIER_POINTER (name),\n-\t\t  strlen (IDENTIFIER_POINTER (name)));\n-#endif\n-  else\n-    obstack_1grow (&util_obstack, '?');\n-\n-  /* Encode the types (and possibly names) of the inner fields,\n-     if required.  */\n-  if (inline_contents)\n-    {\n-      obstack_1grow (&util_obstack, '=');\n-      encode_aggregate_fields (type, pointed_to, curtype, format);\n-    }\n-  /* Close parenth/bracket.  */\n-  obstack_1grow (&util_obstack, right);\n-}\n-\n-/* Encode a bitfield NeXT-style (i.e., without a bit offset or the underlying\n-   field type.  */\n-\n-static void\n-encode_next_bitfield (int width)\n-{\n-  char buffer[40];\n-  sprintf (buffer, \"b%d\", width);\n-  obstack_grow (&util_obstack, buffer, strlen (buffer));\n-}\n-\n-/* Encodes 'type', ignoring type qualifiers (which you should encode\n-   beforehand if needed) with the exception of 'const', which is\n-   encoded by encode_type.  See above for the explanation of\n-   'curtype'.  'format' can be OBJC_ENCODE_INLINE_DEFS or\n-   OBJC_ENCODE_DONT_INLINE_DEFS.\n-*/\n-static void\n-encode_type (tree type, int curtype, int format)\n-{\n-  enum tree_code code = TREE_CODE (type);\n-\n-  /* Ignore type qualifiers other than 'const' when encoding a\n-     type.  */\n-\n-  if (type == error_mark_node)\n-    return;\n-\n-  if (!flag_next_runtime)\n-    {\n-      if (TYPE_READONLY (type))\n-\tobstack_1grow (&util_obstack, 'r');\n-    }\n-\n-  switch (code)\n-    {\n-    case ENUMERAL_TYPE:\n-      if (flag_next_runtime)\n-\t{\n-\t  /* Kludge for backwards-compatibility with gcc-3.3: enums\n-\t     are always encoded as 'i' no matter what type they\n-\t     actually are (!).  */\n-\t  obstack_1grow (&util_obstack, 'i');\n-\t  break;\n-\t}\n-      /* Else, they are encoded exactly like the integer type that is\n-\t used by the compiler to store them.  */\n-    case INTEGER_TYPE:\n-      {\n-\tchar c;\n-\tswitch (GET_MODE_BITSIZE (TYPE_MODE (type)))\n-\t  {\n-\t  case 8:  c = TYPE_UNSIGNED (type) ? 'C' : 'c'; break;\n-\t  case 16: c = TYPE_UNSIGNED (type) ? 'S' : 's'; break;\n-\t  case 32:\n-\t    {\n-\t      tree int_type = type;\n-\t      if (flag_next_runtime)\n-\t\t{\n-\t\t  /* Another legacy kludge for compatiblity with\n-\t\t     gcc-3.3: 32-bit longs are encoded as 'l' or 'L',\n-\t\t     but not always.  For typedefs, we need to use 'i'\n-\t\t     or 'I' instead if encoding a struct field, or a\n-\t\t     pointer!  */\n-\t\t  int_type =  ((!generating_instance_variables\n-\t\t\t\t&& (obstack_object_size (&util_obstack)\n-\t\t\t\t    == (unsigned) curtype))\n-\t\t\t       ? TYPE_MAIN_VARIANT (type)\n-\t\t\t       : type);\n-\t\t}\n-\t      if (int_type == long_unsigned_type_node\n-\t\t  || int_type == long_integer_type_node)\n-\t\tc = TYPE_UNSIGNED (type) ? 'L' : 'l';\n-\t      else\n-\t\tc = TYPE_UNSIGNED (type) ? 'I' : 'i';\n-\t    }\n-\t    break;\n-\t  case 64:  c = TYPE_UNSIGNED (type) ? 'Q' : 'q'; break;\n-\t  case 128: c = TYPE_UNSIGNED (type) ? 'T' : 't'; break;\n-\t  default: gcc_unreachable ();\n-\t  }\n-\tobstack_1grow (&util_obstack, c);\n-\tbreak;\n-      }\n-    case REAL_TYPE:\n-      {\n-\tchar c;\n-\t/* Floating point types.  */\n-\tswitch (GET_MODE_BITSIZE (TYPE_MODE (type)))\n-\t  {\n-\t  case 32:  c = 'f'; break;\n-\t  case 64:  c = 'd'; break;\n-\t  case 96:\n-\t  case 128: c = 'D'; break;\n-\t  default: gcc_unreachable ();\n-\t  }\n-\tobstack_1grow (&util_obstack, c);\n-\tbreak;\n-      }\n-    case VOID_TYPE:\n-      obstack_1grow (&util_obstack, 'v');\n-      break;\n-\n-    case BOOLEAN_TYPE:\n-      obstack_1grow (&util_obstack, 'B');\n-      break;\n-\n-    case ARRAY_TYPE:\n-      encode_array (type, curtype, format);\n-      break;\n-\n-    case POINTER_TYPE:\n-#ifdef OBJCPLUS\n-    case REFERENCE_TYPE:\n-#endif\n-      encode_pointer (type, curtype, format);\n-      break;\n-\n-    case RECORD_TYPE:\n-      encode_aggregate_within (type, curtype, format, '{', '}');\n-      break;\n-\n-    case UNION_TYPE:\n-      encode_aggregate_within (type, curtype, format, '(', ')');\n-      break;\n-\n-    case FUNCTION_TYPE: /* '?' means an unknown type.  */\n-      obstack_1grow (&util_obstack, '?');\n-      break;\n-\n-    case COMPLEX_TYPE:\n-      /* A complex is encoded as 'j' followed by the inner type (eg,\n-\t \"_Complex int\" is encoded as 'ji').  */\n-      obstack_1grow (&util_obstack, 'j');\n-      encode_type (TREE_TYPE (type), curtype, format);\n-      break;\n-\n-    case VECTOR_TYPE:\n-      encode_vector (type, curtype, format);\n-      break;\n-\n-    default:\n-      warning (0, \"unknown type %s found during Objective-C encoding\",\n-\t       gen_type_name (type));\n-      obstack_1grow (&util_obstack, '?');\n-      break;\n-    }\n-\n-  if (flag_next_runtime)\n-    {\n-      /* Super-kludge.  Some ObjC qualifier and type combinations need\n-\t to be rearranged for compatibility with gcc-3.3.  */\n-      if (code == POINTER_TYPE && obstack_object_size (&util_obstack) >= 3)\n-\t{\n-\t  char *enc = obstack_base (&util_obstack) + curtype;\n-\n-\t  /* Rewrite \"in const\" from \"nr\" to \"rn\".  */\n-\t  if (curtype >= 1 && !strncmp (enc - 1, \"nr\", 2))\n-\t    strncpy (enc - 1, \"rn\", 2);\n-\t}\n-    }\n-}\n-\n-static void\n-encode_gnu_bitfield (int position, tree type, int size)\n-{\n-  enum tree_code code = TREE_CODE (type);\n-  char buffer[40];\n-  char charType = '?';\n-\n-  /* This code is only executed for the GNU runtime, so we can ignore\n-     the NeXT runtime kludge of always encoding enums as 'i' no matter\n-     what integers they actually are.  */\n-  if (code == INTEGER_TYPE  ||  code == ENUMERAL_TYPE)\n-    {\n-      if (integer_zerop (TYPE_MIN_VALUE (type)))\n-\t/* Unsigned integer types.  */\n-\t{\n-\t  switch (TYPE_MODE (type))\n-\t    {\n-\t    case QImode:\n-\t      charType = 'C'; break;\n-\t    case HImode:\n-\t      charType = 'S'; break;\n-\t    case SImode:\n-\t      {\n-\t\tif (type == long_unsigned_type_node)\n-\t\t  charType = 'L';\n-\t\telse\n-\t\t  charType = 'I';\n-\t\tbreak;\n-\t      }\n-\t    case DImode:\n-\t      charType = 'Q'; break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t}\n-      else\n-\t/* Signed integer types.  */\n-\t{\n-\t  switch (TYPE_MODE (type))\n-\t    {\n-\t    case QImode:\n-\t      charType = 'c'; break;\n-\t    case HImode:\n-\t      charType = 's'; break;\n-\t    case SImode:\n-\t      {\n-\t\tif (type == long_integer_type_node)\n-\t\t  charType = 'l';\n-\t\telse\n-\t\t  charType = 'i';\n-\t\tbreak;\n-\t      }\n-\t    case DImode:\n-\t      charType = 'q'; break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t}\n-    }\n-  else\n-    {\n-      /* Do not do any encoding, produce an error and keep going.  */\n-      error (\"trying to encode non-integer type as a bitfield\");\n-      return;\n-    }\n-\n-  sprintf (buffer, \"b%d%c%d\", position, charType, size);\n-  obstack_grow (&util_obstack, buffer, strlen (buffer));\n-}\n-\n-void\n-encode_field_decl (tree field_decl, int curtype, int format)\n-{\n-#ifdef OBJCPLUS\n-  /* C++ static members, and things that are not fields at all,\n-     should not appear in the encoding.  */\n-  if (TREE_CODE (field_decl) != FIELD_DECL || TREE_STATIC (field_decl))\n-    return;\n-#endif\n-\n-  /* Generate the bitfield typing information, if needed.  Note the difference\n-     between GNU and NeXT runtimes.  */\n-  if (DECL_BIT_FIELD_TYPE (field_decl))\n-    {\n-      int size = tree_low_cst (DECL_SIZE (field_decl), 1);\n-\n-      if (flag_next_runtime)\n-\tencode_next_bitfield (size);\n-      else\n-\tencode_gnu_bitfield (int_bit_position (field_decl),\n-\t\t\t     DECL_BIT_FIELD_TYPE (field_decl), size);\n-    }\n-  else\n-    encode_type (TREE_TYPE (field_decl), curtype, format);\n-}\n-\n-/* This routine encodes the attribute of the input PROPERTY according\n-   to following formula:\n-\n-   Property attributes are stored as a comma-delimited C string.\n-   Simple attributes such as readonly are encoded as single\n-   character. The parametrized attributes, getter=name and\n-   setter=name, are encoded as a single character followed by an\n-   identifier.  Property types are also encoded as a parametrized\n-   attribute.  The characters used to encode these attributes are\n-   defined by the following enumeration:\n-\n-   enum PropertyAttributes {\n-     kPropertyReadOnly = 'R',\n-     kPropertyBycopy = 'C',\n-     kPropertyByref = '&',\n-     kPropertyDynamic = 'D',\n-     kPropertyGetter = 'G',\n-     kPropertySetter = 'S',\n-     kPropertyInstanceVariable = 'V',\n-     kPropertyType = 'T',\n-     kPropertyWeak = 'W',\n-     kPropertyStrong = 'P',\n-     kPropertyNonAtomic = 'N'\n-   };  */\n-tree\n-objc_v2_encode_prop_attr (tree property)\n-{\n-  const char *string;\n-  tree type = TREE_TYPE (property);\n-\n-  obstack_1grow (&util_obstack, 'T');\n-  encode_type (type, obstack_object_size (&util_obstack),\n-\t       OBJC_ENCODE_INLINE_DEFS);\n-\n-  if (PROPERTY_READONLY (property))\n-    obstack_grow (&util_obstack, \",R\", 2);\n-\n-  switch (PROPERTY_ASSIGN_SEMANTICS (property))\n-    {\n-    case OBJC_PROPERTY_COPY:\n-      obstack_grow (&util_obstack, \",C\", 2);\n-      break;\n-    case OBJC_PROPERTY_RETAIN:\n-      obstack_grow (&util_obstack, \",&\", 2);\n-      break;\n-    case OBJC_PROPERTY_ASSIGN:\n-    default:\n-      break;\n-    }\n-\n-  if (PROPERTY_DYNAMIC (property))\n-    obstack_grow (&util_obstack, \",D\", 2);\n-\n-  if (PROPERTY_NONATOMIC (property))\n-    obstack_grow (&util_obstack, \",N\", 2);\n-\n-  /* Here we want to encode the getter name, but only if it's not the\n-     standard one.  */\n-  if (PROPERTY_GETTER_NAME (property) != PROPERTY_NAME (property))\n-    {\n-      obstack_grow (&util_obstack, \",G\", 2);\n-      string = IDENTIFIER_POINTER (PROPERTY_GETTER_NAME (property));\n-      obstack_grow (&util_obstack, string, strlen (string));\n-    }\n-\n-  if (!PROPERTY_READONLY (property))\n-    {\n-      /* Here we want to encode the setter name, but only if it's not\n-\t the standard one.  */\n-      tree standard_setter = get_identifier (objc_build_property_setter_name (PROPERTY_NAME (property)));\n-      if (PROPERTY_SETTER_NAME (property) != standard_setter)\n-\t{\n-\t  obstack_grow (&util_obstack, \",S\", 2);\n-\t  string = IDENTIFIER_POINTER (PROPERTY_SETTER_NAME (property));\n-\t  obstack_grow (&util_obstack, string, strlen (string));\n-\t}\n-    }\n-\n-  /* TODO: Encode strong ('P'), weak ('W') for garbage collection.  */\n-\n-  if (!PROPERTY_DYNAMIC (property))\n-    {\n-      obstack_grow (&util_obstack, \",V\", 2);\n-      if (PROPERTY_IVAR_NAME (property))\n-\tstring = IDENTIFIER_POINTER (PROPERTY_IVAR_NAME (property));\n-      else\n-\tstring = IDENTIFIER_POINTER (PROPERTY_NAME (property));\n-      obstack_grow (&util_obstack, string, strlen (string));\n-    }\n-\n-  /* NULL-terminate string.  */\n-  obstack_1grow (&util_obstack, 0);\n-  string = XOBFINISH (&util_obstack, char *);\n-  obstack_free (&util_obstack, util_firstobj);\n-  return get_identifier (string);\n-}\n-\n void\n objc_common_init_ts (void)\n {"}, {"sha": "33f90fdb7850f3e8e838999b97f67f9a524bf634", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=f027ee7cb0ed39a3c84b74673655bac4e22d335f", "patch": "@@ -642,10 +642,6 @@ typedef enum string_section\n #define METHOD_DEF\t\t\t0\n #define METHOD_REF\t\t\t1\n \n-/* (Decide if these can ever be validly changed.) */\n-#define OBJC_ENCODE_INLINE_DEFS\t\t0\n-#define OBJC_ENCODE_DONT_INLINE_DEFS\t1\n-\n #define BUFSIZE\t\t\t\t1024\n \n #define CLS_FACTORY\t\t\t0x0001L"}, {"sha": "cb1d0c4e992beb1214dfd1c9e797c1d5c0daf92c", "filename": "gcc/objc/objc-encoding.c", "status": "added", "additions": 926, "deletions": 0, "changes": 926, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2Fobjc-encoding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2Fobjc-encoding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-encoding.c?ref=f027ee7cb0ed39a3c84b74673655bac4e22d335f", "patch": "@@ -0,0 +1,926 @@\n+/* Routines dealing with ObjC encoding of types\n+   Copyright (C) 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2001,\n+   2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+\n+#ifdef OBJCPLUS\n+#include \"cp-tree.h\"\n+#else\n+#include \"c-tree.h\"\n+#include \"c-lang.h\"\n+#endif\n+\n+#include \"c-family/c-common.h\"\n+#include \"c-family/c-objc.h\"\n+\n+#include \"objc-encoding.h\"\n+#include \"objc-act.h\"\n+\n+/* For my_build_string().  */\n+#include \"objc-runtime-shared-support.h\"\n+\n+/* For BITS_PER_UNIT.  */\n+#include \"tm.h\"\n+\n+/* When building Objective-C++, we are not linking against the C front-end\n+   and so need to replicate the C tree-construction functions in some way.  */\n+#ifdef OBJCPLUS\n+#define OBJCP_REMAP_FUNCTIONS\n+#include \"objcp-decl.h\"\n+#endif  /* OBJCPLUS */\n+\n+/* Set up for use of obstacks.  */\n+#include \"obstack.h\"\n+\n+/* This obstack is used to accumulate the encoding of a data type.\n+   TODO: Make this static.  */\n+struct obstack util_obstack;\n+\n+/* This points to the beginning of obstack contents, so we can free\n+   the whole contents.  TODO: Make this static.  */\n+char *util_firstobj;\n+\n+int generating_instance_variables = 0;\n+\n+static void encode_type_qualifiers (tree);\n+static void encode_type (tree, int, int);\n+\n+static tree\n+objc_method_parm_type (tree type)\n+{\n+  type = TREE_VALUE (TREE_TYPE (type));\n+  if (TREE_CODE (type) == TYPE_DECL)\n+    type = TREE_TYPE (type);\n+  return type;\n+}\n+\n+static int\n+objc_encoded_type_size (tree type)\n+{\n+  int sz = int_size_in_bytes (type);\n+\n+  /* Make all integer and enum types at least as large\n+     as an int.  */\n+  if (sz > 0 && INTEGRAL_TYPE_P (type))\n+    sz = MAX (sz, int_size_in_bytes (integer_type_node));\n+  /* Treat arrays as pointers, since that's how they're\n+     passed in.  */\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n+    sz = int_size_in_bytes (ptr_type_node);\n+  return sz;\n+}\n+\n+/* Encode a method prototype.  */\n+tree\n+encode_method_prototype (tree method_decl)\n+{\n+  tree parms;\n+  int parm_offset, i;\n+  char buf[40];\n+  tree result;\n+\n+  /* ONEWAY and BYCOPY, for remote object are the only method qualifiers.  */\n+  encode_type_qualifiers (TREE_PURPOSE (TREE_TYPE (method_decl)));\n+\n+  /* Encode return type.  */\n+  encode_type (objc_method_parm_type (method_decl),\n+\t       obstack_object_size (&util_obstack),\n+\t       OBJC_ENCODE_INLINE_DEFS);\n+\n+  /* Stack size.  */\n+  /* The first two arguments (self and _cmd) are pointers; account for\n+     their size.  */\n+  i = int_size_in_bytes (ptr_type_node);\n+  parm_offset = 2 * i;\n+  for (parms = METHOD_SEL_ARGS (method_decl); parms;\n+       parms = DECL_CHAIN (parms))\n+    {\n+      tree type = objc_method_parm_type (parms);\n+      int sz = objc_encoded_type_size (type);\n+\n+      /* If a type size is not known, bail out.  */\n+      if (sz < 0)\n+\t{\n+\t  error_at (DECL_SOURCE_LOCATION (method_decl),\n+\t\t    \"type %qT does not have a known size\",\n+\t\t    type);\n+\t  /* Pretend that the encoding succeeded; the compilation will\n+\t     fail nevertheless.  */\n+\t  goto finish_encoding;\n+\t}\n+      parm_offset += sz;\n+    }\n+\n+  sprintf (buf, \"%d@0:%d\", parm_offset, i);\n+  obstack_grow (&util_obstack, buf, strlen (buf));\n+\n+  /* Argument types.  */\n+  parm_offset = 2 * i;\n+  for (parms = METHOD_SEL_ARGS (method_decl); parms;\n+       parms = DECL_CHAIN (parms))\n+    {\n+      tree type = objc_method_parm_type (parms);\n+\n+      /* Process argument qualifiers for user supplied arguments.  */\n+      encode_type_qualifiers (TREE_PURPOSE (TREE_TYPE (parms)));\n+\n+      /* Type.  */\n+      encode_type (type, obstack_object_size (&util_obstack),\n+\t\t   OBJC_ENCODE_INLINE_DEFS);\n+\n+      /* Compute offset.  */\n+      sprintf (buf, \"%d\", parm_offset);\n+      parm_offset += objc_encoded_type_size (type);\n+\n+      obstack_grow (&util_obstack, buf, strlen (buf));\n+    }\n+\n+  finish_encoding:\n+  obstack_1grow (&util_obstack, '\\0');\n+  result = get_identifier (XOBFINISH (&util_obstack, char *));\n+  obstack_free (&util_obstack, util_firstobj);\n+  return result;\n+}\n+\n+/* This is used to implement @encode().  */\n+tree\n+objc_build_encode_expr (tree type)\n+{\n+  tree result;\n+  const char *string;\n+\n+  encode_type (type, obstack_object_size (&util_obstack),\n+\t       OBJC_ENCODE_INLINE_DEFS);\n+  obstack_1grow (&util_obstack, 0);    /* null terminate string */\n+  string = XOBFINISH (&util_obstack, const char *);\n+\n+  /* Synthesize a string that represents the encoded struct/union.  */\n+  result = my_build_string (strlen (string) + 1, string);\n+  obstack_free (&util_obstack, util_firstobj);\n+  return result;\n+}\n+\n+/* \"Encode\" a data type into a string, which grows in util_obstack.\n+\n+   The format is described in gcc/doc/objc.texi, section 'Type\n+   encoding'.\n+\n+   Most of the encode_xxx functions have a 'type' argument, which is\n+   the type to encode, and an integer 'curtype' argument, which is the\n+   index in the encoding string of the beginning of the encoding of\n+   the current type, and allows you to find what characters have\n+   already been written for the current type (they are the ones in the\n+   current encoding string starting from 'curtype').\n+\n+   For example, if we are encoding a method which returns 'int' and\n+   takes a 'char **' argument, then when we get to the point of\n+   encoding the 'char **' argument, the encoded string already\n+   contains 'i12@0:4' (assuming a pointer size of 4 bytes).  So,\n+   'curtype' will be set to 7 when starting to encode 'char **'.\n+   During the whole of the encoding of 'char **', 'curtype' will be\n+   fixed at 7, so the routine encoding the second pointer can find out\n+   that it's actually encoding a pointer to a pointer by looking\n+   backwards at what has already been encoded for the current type,\n+   and seeing there is a \"^\" (meaning a pointer) in there.  */\n+\n+\n+/* Encode type qualifiers encodes one of the \"PQ\" Objective-C\n+   keywords, ie 'in', 'out', 'inout', 'bycopy', 'byref', 'oneway'.\n+   'const', instead, is encoded directly as part of the type.  */\n+static void\n+encode_type_qualifiers (tree declspecs)\n+{\n+  tree spec;\n+\n+  for (spec = declspecs; spec; spec = TREE_CHAIN (spec))\n+    {\n+      /* FIXME: Shouldn't we use token->keyword here ? */\n+      if (ridpointers[(int) RID_IN] == TREE_VALUE (spec))\n+\tobstack_1grow (&util_obstack, 'n');\n+      else if (ridpointers[(int) RID_INOUT] == TREE_VALUE (spec))\n+\tobstack_1grow (&util_obstack, 'N');\n+      else if (ridpointers[(int) RID_OUT] == TREE_VALUE (spec))\n+\tobstack_1grow (&util_obstack, 'o');\n+      else if (ridpointers[(int) RID_BYCOPY] == TREE_VALUE (spec))\n+\tobstack_1grow (&util_obstack, 'O');\n+      else if (ridpointers[(int) RID_BYREF] == TREE_VALUE (spec))\n+        obstack_1grow (&util_obstack, 'R');\n+      else if (ridpointers[(int) RID_ONEWAY] == TREE_VALUE (spec))\n+\tobstack_1grow (&util_obstack, 'V');\n+      else\n+\tgcc_unreachable ();\n+    }\n+}\n+\n+/* Determine if a pointee is marked read-only.  Only used by the NeXT\n+   runtime to be compatible with gcc-3.3.  */\n+static bool\n+pointee_is_readonly (tree pointee)\n+{\n+  while (POINTER_TYPE_P (pointee))\n+    pointee = TREE_TYPE (pointee);\n+\n+  return TYPE_READONLY (pointee);\n+}\n+\n+/* Encode a pointer type.  */\n+static void\n+encode_pointer (tree type, int curtype, int format)\n+{\n+  tree pointer_to = TREE_TYPE (type);\n+\n+  if (flag_next_runtime)\n+    {\n+      /* This code is used to be compatible with gcc-3.3.  */\n+      /* For historical/compatibility reasons, the read-only qualifier\n+\t of the pointee gets emitted _before_ the '^'.  The read-only\n+\t qualifier of the pointer itself gets ignored, _unless_ we are\n+\t looking at a typedef!  Also, do not emit the 'r' for anything\n+\t but the outermost type!  */\n+      if (!generating_instance_variables\n+\t  && (obstack_object_size (&util_obstack) - curtype <= 1)\n+\t  && (TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+\t      ? TYPE_READONLY (type)\n+\t      : pointee_is_readonly (pointer_to)))\n+\tobstack_1grow (&util_obstack, 'r');\n+    }\n+\n+  if (TREE_CODE (pointer_to) == RECORD_TYPE)\n+    {\n+      if (OBJC_TYPE_NAME (pointer_to)\n+\t  && TREE_CODE (OBJC_TYPE_NAME (pointer_to)) == IDENTIFIER_NODE)\n+\t{\n+\t  const char *name = IDENTIFIER_POINTER (OBJC_TYPE_NAME (pointer_to));\n+\n+\t  if (strcmp (name, TAG_OBJECT) == 0) /* '@' */\n+\t    {\n+\t      obstack_1grow (&util_obstack, '@');\n+\t      return;\n+\t    }\n+\t  else if (TYPE_HAS_OBJC_INFO (pointer_to)\n+\t\t   && TYPE_OBJC_INTERFACE (pointer_to))\n+\t    {\n+              if (generating_instance_variables)\n+\t        {\n+\t          obstack_1grow (&util_obstack, '@');\n+\t          obstack_1grow (&util_obstack, '\"');\n+\t          obstack_grow (&util_obstack, name, strlen (name));\n+\t          obstack_1grow (&util_obstack, '\"');\n+\t          return;\n+\t\t}\n+              else\n+\t        {\n+\t          obstack_1grow (&util_obstack, '@');\n+\t          return;\n+\t\t}\n+\t    }\n+\t  else if (strcmp (name, TAG_CLASS) == 0) /* '#' */\n+\t    {\n+\t      obstack_1grow (&util_obstack, '#');\n+\t      return;\n+\t    }\n+\t  else if (strcmp (name, TAG_SELECTOR) == 0) /* ':' */\n+\t    {\n+\t      obstack_1grow (&util_obstack, ':');\n+\t      return;\n+\t    }\n+\t}\n+    }\n+  else if (TREE_CODE (pointer_to) == INTEGER_TYPE\n+\t   && TYPE_MODE (pointer_to) == QImode)\n+    {\n+      tree pname = TREE_CODE (OBJC_TYPE_NAME (pointer_to)) == IDENTIFIER_NODE\n+\t          ? OBJC_TYPE_NAME (pointer_to)\n+\t          : DECL_NAME (OBJC_TYPE_NAME (pointer_to));\n+\n+      /* (BOOL *) are an exception and are encoded as ^c, while all\n+\t other pointers to char are encoded as *.   */\n+      if (strcmp (IDENTIFIER_POINTER (pname), \"BOOL\"))\n+\t{\n+\t  if (!flag_next_runtime)\n+\t    {\n+\t      /* The NeXT runtime adds the 'r' before getting here.  */\n+\n+\t      /* It appears that \"r*\" means \"const char *\" rather than\n+\t\t \"char *const\".  \"char *const\" is encoded as \"*\",\n+\t\t which is identical to \"char *\", so the \"const\" is\n+\t\t unfortunately lost.  */\n+\t      if (TYPE_READONLY (pointer_to))\n+\t\tobstack_1grow (&util_obstack, 'r');\n+\t    }\n+\n+\t  obstack_1grow (&util_obstack, '*');\n+\t  return;\n+\t}\n+    }\n+\n+  /* We have a normal pointer type that does not get special treatment.  */\n+  obstack_1grow (&util_obstack, '^');\n+  encode_type (pointer_to, curtype, format);\n+}\n+\n+static void\n+encode_array (tree type, int curtype, int format)\n+{\n+  tree an_int_cst = TYPE_SIZE (type);\n+  tree array_of = TREE_TYPE (type);\n+  char buffer[40];\n+\n+  if (an_int_cst == NULL)\n+    {\n+      /* We are trying to encode an incomplete array.  An incomplete\n+\t array is forbidden as part of an instance variable; but it\n+\t may occur if the instance variable is a pointer to such an\n+\t array.  */\n+\n+      /* So the only case in which an incomplete array could occur\n+\t (without being pointed to) is if we are encoding the\n+\t arguments or return value of a method.  In that case, an\n+\t incomplete array argument or return value (eg,\n+\t -(void)display: (char[])string) is treated like a pointer\n+\t because that is how the compiler does the function call.  A\n+\t special, more complicated case, is when the incomplete array\n+\t is the last member of a struct (eg, if we are encoding\n+\t \"struct { unsigned long int a;double b[];}\"), which is again\n+\t part of a method argument/return value.  In that case, we\n+\t really need to communicate to the runtime that there is an\n+\t incomplete array (not a pointer!) there.  So, we detect that\n+\t special case and encode it as a zero-length array.\n+\n+\t Try to detect that we are part of a struct.  We do this by\n+\t searching for '=' in the type encoding for the current type.\n+\t NB: This hack assumes that you can't use '=' as part of a C\n+\t identifier.\n+      */\n+      {\n+\tchar *enc = obstack_base (&util_obstack) + curtype;\n+\tif (memchr (enc, '=',\n+\t\t    obstack_object_size (&util_obstack) - curtype) == NULL)\n+\t  {\n+\t    /* We are not inside a struct.  Encode the array as a\n+\t       pointer.  */\n+\t    encode_pointer (type, curtype, format);\n+\t    return;\n+\t  }\n+      }\n+\n+      /* Else, we are in a struct, and we encode it as a zero-length\n+\t array.  */\n+      sprintf (buffer, \"[\" HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT)0);\n+    }\n+  else if (TREE_INT_CST_LOW (TYPE_SIZE (array_of)) == 0)\n+   sprintf (buffer, \"[\" HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT)0);\n+  else\n+    sprintf (buffer, \"[\" HOST_WIDE_INT_PRINT_DEC,\n+\t     TREE_INT_CST_LOW (an_int_cst)\n+\t      / TREE_INT_CST_LOW (TYPE_SIZE (array_of)));\n+\n+  obstack_grow (&util_obstack, buffer, strlen (buffer));\n+  encode_type (array_of, curtype, format);\n+  obstack_1grow (&util_obstack, ']');\n+  return;\n+}\n+\n+/* Encode a vector.  The vector type is a GCC extension to C.  */\n+static void\n+encode_vector (tree type, int curtype, int format)\n+{\n+  tree vector_of = TREE_TYPE (type);\n+  char buffer[40];\n+\n+  /* Vectors are like simple fixed-size arrays.  */\n+\n+  /* Output ![xx,yy,<code>] where xx is the vector_size, yy is the\n+     alignment of the vector, and <code> is the base type.  Eg, int\n+     __attribute__ ((vector_size (16))) gets encoded as ![16,32,i]\n+     assuming that the alignment is 32 bytes.  We include size and\n+     alignment in bytes so that the runtime does not have to have any\n+     knowledge of the actual types.\n+  */\n+  sprintf (buffer, \"![\" HOST_WIDE_INT_PRINT_DEC \",%d\",\n+\t   /* We want to compute the equivalent of sizeof (<vector>).\n+\t      Code inspired by c_sizeof_or_alignof_type.  */\n+\t   ((TREE_INT_CST_LOW (TYPE_SIZE_UNIT (type))\n+\t     / (TYPE_PRECISION (char_type_node) / BITS_PER_UNIT))),\n+\t   /* We want to compute the equivalent of __alignof__\n+\t      (<vector>).  Code inspired by\n+\t      c_sizeof_or_alignof_type.  */\n+\t   TYPE_ALIGN_UNIT (type));\n+  obstack_grow (&util_obstack, buffer, strlen (buffer));\n+  encode_type (vector_of, curtype, format);\n+  obstack_1grow (&util_obstack, ']');\n+  return;\n+}\n+\n+static void\n+encode_aggregate_fields (tree type, bool pointed_to, int curtype, int format)\n+{\n+  tree field = TYPE_FIELDS (type);\n+\n+  for (; field; field = DECL_CHAIN (field))\n+    {\n+#ifdef OBJCPLUS\n+      /* C++ static members, and things that are not field at all,\n+\t should not appear in the encoding.  */\n+      if (TREE_CODE (field) != FIELD_DECL || TREE_STATIC (field))\n+\tcontinue;\n+#endif\n+\n+      /* Recursively encode fields of embedded base classes.  */\n+      if (DECL_ARTIFICIAL (field) && !DECL_NAME (field)\n+\t  && TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE)\n+\t{\n+\t  encode_aggregate_fields (TREE_TYPE (field),\n+\t\t\t\t   pointed_to, curtype, format);\n+\t  continue;\n+\t}\n+\n+      if (generating_instance_variables && !pointed_to)\n+\t{\n+\t  tree fname = DECL_NAME (field);\n+\n+\t  obstack_1grow (&util_obstack, '\"');\n+\n+\t  if (fname && TREE_CODE (fname) == IDENTIFIER_NODE)\n+\t    obstack_grow (&util_obstack,\n+\t\t\t  IDENTIFIER_POINTER (fname),\n+\t\t\t  strlen (IDENTIFIER_POINTER (fname)));\n+\n+\t  obstack_1grow (&util_obstack, '\"');\n+        }\n+\n+      encode_field_decl (field, curtype, format);\n+    }\n+}\n+\n+static void\n+encode_aggregate_within (tree type, int curtype, int format, int left,\n+\t\t\t int right)\n+{\n+  tree name;\n+  /* NB: aggregates that are pointed to have slightly different encoding\n+     rules in that you never encode the names of instance variables.  */\n+  int ob_size = obstack_object_size (&util_obstack);\n+  bool inline_contents = false;\n+  bool pointed_to = false;\n+\n+  if (flag_next_runtime)\n+    {\n+      if (ob_size > 0  &&  *(obstack_next_free (&util_obstack) - 1) == '^')\n+\tpointed_to = true;\n+\n+      if ((format == OBJC_ENCODE_INLINE_DEFS || generating_instance_variables)\n+\t  && (!pointed_to || ob_size - curtype == 1\n+\t      || (ob_size - curtype == 2\n+\t\t  && *(obstack_next_free (&util_obstack) - 2) == 'r')))\n+\tinline_contents = true;\n+    }\n+  else\n+    {\n+      /* c0 and c1 are the last two characters in the encoding of the\n+\t current type; if the last two characters were '^' or '^r',\n+\t then we are encoding an aggregate that is \"pointed to\".  The\n+\t comment above applies: in that case we should avoid encoding\n+\t the names of instance variables.\n+      */\n+      char c1 = ob_size > 1 ? *(obstack_next_free (&util_obstack) - 2) : 0;\n+      char c0 = ob_size > 0 ? *(obstack_next_free (&util_obstack) - 1) : 0;\n+\n+      if (c0 == '^' || (c1 == '^' && c0 == 'r'))\n+\tpointed_to = true;\n+\n+      if (format == OBJC_ENCODE_INLINE_DEFS || generating_instance_variables)\n+\t{\n+\t  if (!pointed_to)\n+\t    inline_contents = true;\n+\t  else\n+\t    {\n+\t      /* Note that the check (ob_size - curtype < 2) prevents\n+\t\t infinite recursion when encoding a structure which is\n+\t\t a linked list (eg, struct node { struct node *next;\n+\t\t }).  Each time we follow a pointer, we add one\n+\t\t character to ob_size, and curtype is fixed, so after\n+\t\t at most two pointers we stop inlining contents and\n+\t\t break the loop.\n+\n+\t\t The other case where we don't inline is \"^r\", which\n+\t\t is a pointer to a constant struct.\n+\t      */\n+\t      if ((ob_size - curtype <= 2) && !(c0 == 'r'))\n+\t\tinline_contents = true;\n+\t    }\n+\t}\n+    }\n+\n+  /* Traverse struct aliases; it is important to get the\n+     original struct and its tag name (if any).  */\n+  type = TYPE_MAIN_VARIANT (type);\n+  name = OBJC_TYPE_NAME (type);\n+  /* Open parenth/bracket.  */\n+  obstack_1grow (&util_obstack, left);\n+\n+  /* Encode the struct/union tag name, or '?' if a tag was\n+     not provided.  Typedef aliases do not qualify.  */\n+#ifdef OBJCPLUS\n+  /* For compatibility with the NeXT runtime, ObjC++ encodes template\n+     args as a composite struct tag name. */\n+  if (name && TREE_CODE (name) == IDENTIFIER_NODE\n+      /* Did this struct have a tag?  */\n+      && !TYPE_WAS_ANONYMOUS (type))\n+    obstack_grow (&util_obstack,\n+\t\t  decl_as_string (type, TFF_DECL_SPECIFIERS | TFF_UNQUALIFIED_NAME),\n+\t\t  strlen (decl_as_string (type, TFF_DECL_SPECIFIERS | TFF_UNQUALIFIED_NAME)));\n+#else\n+  if (name && TREE_CODE (name) == IDENTIFIER_NODE)\n+    obstack_grow (&util_obstack,\n+\t\t  IDENTIFIER_POINTER (name),\n+\t\t  strlen (IDENTIFIER_POINTER (name)));\n+#endif\n+  else\n+    obstack_1grow (&util_obstack, '?');\n+\n+  /* Encode the types (and possibly names) of the inner fields,\n+     if required.  */\n+  if (inline_contents)\n+    {\n+      obstack_1grow (&util_obstack, '=');\n+      encode_aggregate_fields (type, pointed_to, curtype, format);\n+    }\n+  /* Close parenth/bracket.  */\n+  obstack_1grow (&util_obstack, right);\n+}\n+\n+/* Encode a bitfield NeXT-style (i.e., without a bit offset or the underlying\n+   field type.  */\n+static void\n+encode_next_bitfield (int width)\n+{\n+  char buffer[40];\n+  sprintf (buffer, \"b%d\", width);\n+  obstack_grow (&util_obstack, buffer, strlen (buffer));\n+}\n+\n+/* Encodes 'type', ignoring type qualifiers (which you should encode\n+   beforehand if needed) with the exception of 'const', which is\n+   encoded by encode_type.  See above for the explanation of\n+   'curtype'.  'format' can be OBJC_ENCODE_INLINE_DEFS or\n+   OBJC_ENCODE_DONT_INLINE_DEFS.  */\n+static void\n+encode_type (tree type, int curtype, int format)\n+{\n+  enum tree_code code = TREE_CODE (type);\n+\n+  /* Ignore type qualifiers other than 'const' when encoding a\n+     type.  */\n+\n+  if (type == error_mark_node)\n+    return;\n+\n+  if (!flag_next_runtime)\n+    {\n+      if (TYPE_READONLY (type))\n+\tobstack_1grow (&util_obstack, 'r');\n+    }\n+\n+  switch (code)\n+    {\n+    case ENUMERAL_TYPE:\n+      if (flag_next_runtime)\n+\t{\n+\t  /* Kludge for backwards-compatibility with gcc-3.3: enums\n+\t     are always encoded as 'i' no matter what type they\n+\t     actually are (!).  */\n+\t  obstack_1grow (&util_obstack, 'i');\n+\t  break;\n+\t}\n+      /* Else, they are encoded exactly like the integer type that is\n+\t used by the compiler to store them.  */\n+    case INTEGER_TYPE:\n+      {\n+\tchar c;\n+\tswitch (GET_MODE_BITSIZE (TYPE_MODE (type)))\n+\t  {\n+\t  case 8:  c = TYPE_UNSIGNED (type) ? 'C' : 'c'; break;\n+\t  case 16: c = TYPE_UNSIGNED (type) ? 'S' : 's'; break;\n+\t  case 32:\n+\t    {\n+\t      tree int_type = type;\n+\t      if (flag_next_runtime)\n+\t\t{\n+\t\t  /* Another legacy kludge for compatiblity with\n+\t\t     gcc-3.3: 32-bit longs are encoded as 'l' or 'L',\n+\t\t     but not always.  For typedefs, we need to use 'i'\n+\t\t     or 'I' instead if encoding a struct field, or a\n+\t\t     pointer!  */\n+\t\t  int_type =  ((!generating_instance_variables\n+\t\t\t\t&& (obstack_object_size (&util_obstack)\n+\t\t\t\t    == (unsigned) curtype))\n+\t\t\t       ? TYPE_MAIN_VARIANT (type)\n+\t\t\t       : type);\n+\t\t}\n+\t      if (int_type == long_unsigned_type_node\n+\t\t  || int_type == long_integer_type_node)\n+\t\tc = TYPE_UNSIGNED (type) ? 'L' : 'l';\n+\t      else\n+\t\tc = TYPE_UNSIGNED (type) ? 'I' : 'i';\n+\t    }\n+\t    break;\n+\t  case 64:  c = TYPE_UNSIGNED (type) ? 'Q' : 'q'; break;\n+\t  case 128: c = TYPE_UNSIGNED (type) ? 'T' : 't'; break;\n+\t  default: gcc_unreachable ();\n+\t  }\n+\tobstack_1grow (&util_obstack, c);\n+\tbreak;\n+      }\n+    case REAL_TYPE:\n+      {\n+\tchar c;\n+\t/* Floating point types.  */\n+\tswitch (GET_MODE_BITSIZE (TYPE_MODE (type)))\n+\t  {\n+\t  case 32:  c = 'f'; break;\n+\t  case 64:  c = 'd'; break;\n+\t  case 96:\n+\t  case 128: c = 'D'; break;\n+\t  default: gcc_unreachable ();\n+\t  }\n+\tobstack_1grow (&util_obstack, c);\n+\tbreak;\n+      }\n+    case VOID_TYPE:\n+      obstack_1grow (&util_obstack, 'v');\n+      break;\n+\n+    case BOOLEAN_TYPE:\n+      obstack_1grow (&util_obstack, 'B');\n+      break;\n+\n+    case ARRAY_TYPE:\n+      encode_array (type, curtype, format);\n+      break;\n+\n+    case POINTER_TYPE:\n+#ifdef OBJCPLUS\n+    case REFERENCE_TYPE:\n+#endif\n+      encode_pointer (type, curtype, format);\n+      break;\n+\n+    case RECORD_TYPE:\n+      encode_aggregate_within (type, curtype, format, '{', '}');\n+      break;\n+\n+    case UNION_TYPE:\n+      encode_aggregate_within (type, curtype, format, '(', ')');\n+      break;\n+\n+    case FUNCTION_TYPE: /* '?' means an unknown type.  */\n+      obstack_1grow (&util_obstack, '?');\n+      break;\n+\n+    case COMPLEX_TYPE:\n+      /* A complex is encoded as 'j' followed by the inner type (eg,\n+\t \"_Complex int\" is encoded as 'ji').  */\n+      obstack_1grow (&util_obstack, 'j');\n+      encode_type (TREE_TYPE (type), curtype, format);\n+      break;\n+\n+    case VECTOR_TYPE:\n+      encode_vector (type, curtype, format);\n+      break;\n+\n+    default:\n+      warning (0, \"unknown type %<%T%> found during Objective-C encoding\",\n+\t       TREE_TYPE (type));\n+      obstack_1grow (&util_obstack, '?');\n+      break;\n+    }\n+\n+  if (flag_next_runtime)\n+    {\n+      /* Super-kludge.  Some ObjC qualifier and type combinations need\n+\t to be rearranged for compatibility with gcc-3.3.  */\n+      if (code == POINTER_TYPE && obstack_object_size (&util_obstack) >= 3)\n+\t{\n+\t  char *enc = obstack_base (&util_obstack) + curtype;\n+\n+\t  /* Rewrite \"in const\" from \"nr\" to \"rn\".  */\n+\t  if (curtype >= 1 && !strncmp (enc - 1, \"nr\", 2))\n+\t    strncpy (enc - 1, \"rn\", 2);\n+\t}\n+    }\n+}\n+\n+static void\n+encode_gnu_bitfield (int position, tree type, int size)\n+{\n+  enum tree_code code = TREE_CODE (type);\n+  char buffer[40];\n+  char charType = '?';\n+\n+  /* This code is only executed for the GNU runtime, so we can ignore\n+     the NeXT runtime kludge of always encoding enums as 'i' no matter\n+     what integers they actually are.  */\n+  if (code == INTEGER_TYPE  ||  code == ENUMERAL_TYPE)\n+    {\n+      if (integer_zerop (TYPE_MIN_VALUE (type)))\n+\t/* Unsigned integer types.  */\n+\t{\n+\t  switch (TYPE_MODE (type))\n+\t    {\n+\t    case QImode:\n+\t      charType = 'C'; break;\n+\t    case HImode:\n+\t      charType = 'S'; break;\n+\t    case SImode:\n+\t      {\n+\t\tif (type == long_unsigned_type_node)\n+\t\t  charType = 'L';\n+\t\telse\n+\t\t  charType = 'I';\n+\t\tbreak;\n+\t      }\n+\t    case DImode:\n+\t      charType = 'Q'; break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+      else\n+\t/* Signed integer types.  */\n+\t{\n+\t  switch (TYPE_MODE (type))\n+\t    {\n+\t    case QImode:\n+\t      charType = 'c'; break;\n+\t    case HImode:\n+\t      charType = 's'; break;\n+\t    case SImode:\n+\t      {\n+\t\tif (type == long_integer_type_node)\n+\t\t  charType = 'l';\n+\t\telse\n+\t\t  charType = 'i';\n+\t\tbreak;\n+\t      }\n+\t    case DImode:\n+\t      charType = 'q'; break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      /* Do not do any encoding, produce an error and keep going.  */\n+      error (\"trying to encode non-integer type as a bitfield\");\n+      return;\n+    }\n+\n+  sprintf (buffer, \"b%d%c%d\", position, charType, size);\n+  obstack_grow (&util_obstack, buffer, strlen (buffer));\n+}\n+\n+void\n+encode_field_decl (tree field_decl, int curtype, int format)\n+{\n+#ifdef OBJCPLUS\n+  /* C++ static members, and things that are not fields at all,\n+     should not appear in the encoding.  */\n+  if (TREE_CODE (field_decl) != FIELD_DECL || TREE_STATIC (field_decl))\n+    return;\n+#endif\n+\n+  /* Generate the bitfield typing information, if needed.  Note the difference\n+     between GNU and NeXT runtimes.  */\n+  if (DECL_BIT_FIELD_TYPE (field_decl))\n+    {\n+      int size = tree_low_cst (DECL_SIZE (field_decl), 1);\n+\n+      if (flag_next_runtime)\n+\tencode_next_bitfield (size);\n+      else\n+\tencode_gnu_bitfield (int_bit_position (field_decl),\n+\t\t\t     DECL_BIT_FIELD_TYPE (field_decl), size);\n+    }\n+  else\n+    encode_type (TREE_TYPE (field_decl), curtype, format);\n+}\n+\n+/* This routine encodes the attribute of the input PROPERTY according\n+   to following formula:\n+\n+   Property attributes are stored as a comma-delimited C string.\n+   Simple attributes such as readonly are encoded as single\n+   character. The parametrized attributes, getter=name and\n+   setter=name, are encoded as a single character followed by an\n+   identifier.  Property types are also encoded as a parametrized\n+   attribute.  The characters used to encode these attributes are\n+   defined by the following enumeration:\n+\n+   enum PropertyAttributes {\n+     kPropertyReadOnly = 'R',\n+     kPropertyBycopy = 'C',\n+     kPropertyByref = '&',\n+     kPropertyDynamic = 'D',\n+     kPropertyGetter = 'G',\n+     kPropertySetter = 'S',\n+     kPropertyInstanceVariable = 'V',\n+     kPropertyType = 'T',\n+     kPropertyWeak = 'W',\n+     kPropertyStrong = 'P',\n+     kPropertyNonAtomic = 'N'\n+   };  */\n+tree\n+objc_v2_encode_prop_attr (tree property)\n+{\n+  const char *string;\n+  tree type = TREE_TYPE (property);\n+\n+  obstack_1grow (&util_obstack, 'T');\n+  encode_type (type, obstack_object_size (&util_obstack),\n+\t       OBJC_ENCODE_INLINE_DEFS);\n+\n+  if (PROPERTY_READONLY (property))\n+    obstack_grow (&util_obstack, \",R\", 2);\n+\n+  switch (PROPERTY_ASSIGN_SEMANTICS (property))\n+    {\n+    case OBJC_PROPERTY_COPY:\n+      obstack_grow (&util_obstack, \",C\", 2);\n+      break;\n+    case OBJC_PROPERTY_RETAIN:\n+      obstack_grow (&util_obstack, \",&\", 2);\n+      break;\n+    case OBJC_PROPERTY_ASSIGN:\n+    default:\n+      break;\n+    }\n+\n+  if (PROPERTY_DYNAMIC (property))\n+    obstack_grow (&util_obstack, \",D\", 2);\n+\n+  if (PROPERTY_NONATOMIC (property))\n+    obstack_grow (&util_obstack, \",N\", 2);\n+\n+  /* Here we want to encode the getter name, but only if it's not the\n+     standard one.  */\n+  if (PROPERTY_GETTER_NAME (property) != PROPERTY_NAME (property))\n+    {\n+      obstack_grow (&util_obstack, \",G\", 2);\n+      string = IDENTIFIER_POINTER (PROPERTY_GETTER_NAME (property));\n+      obstack_grow (&util_obstack, string, strlen (string));\n+    }\n+\n+  if (!PROPERTY_READONLY (property))\n+    {\n+      /* Here we want to encode the setter name, but only if it's not\n+\t the standard one.  */\n+      tree standard_setter = get_identifier (objc_build_property_setter_name (PROPERTY_NAME (property)));\n+      if (PROPERTY_SETTER_NAME (property) != standard_setter)\n+\t{\n+\t  obstack_grow (&util_obstack, \",S\", 2);\n+\t  string = IDENTIFIER_POINTER (PROPERTY_SETTER_NAME (property));\n+\t  obstack_grow (&util_obstack, string, strlen (string));\n+\t}\n+    }\n+\n+  /* TODO: Encode strong ('P'), weak ('W') for garbage collection.  */\n+\n+  if (!PROPERTY_DYNAMIC (property))\n+    {\n+      obstack_grow (&util_obstack, \",V\", 2);\n+      if (PROPERTY_IVAR_NAME (property))\n+\tstring = IDENTIFIER_POINTER (PROPERTY_IVAR_NAME (property));\n+      else\n+\tstring = IDENTIFIER_POINTER (PROPERTY_NAME (property));\n+      obstack_grow (&util_obstack, string, strlen (string));\n+    }\n+\n+  /* NULL-terminate string.  */\n+  obstack_1grow (&util_obstack, 0);\n+  string = XOBFINISH (&util_obstack, char *);\n+  obstack_free (&util_obstack, util_firstobj);\n+  return get_identifier (string);\n+}"}, {"sha": "2fad5937bc9c7cc58eb622ad1e0acfdd8e40599d", "filename": "gcc/objc/objc-encoding.h", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2Fobjc-encoding.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2Fobjc-encoding.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-encoding.h?ref=f027ee7cb0ed39a3c84b74673655bac4e22d335f", "patch": "@@ -0,0 +1,74 @@\n+/* Routines dealing with ObjC encoding of types\n+   Copyright (C) 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2001,\n+   2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_OBJC_ENCODING_H\n+#define GCC_OBJC_ENCODING_H\n+\n+/* TODO: Hide the following obstack code in objc-encoding.c, and have\n+   a objc_encoding_init() that is called by objc_init() to set them\n+   up.  */\n+\n+/* Set up for use of obstacks.  */\n+#include \"obstack.h\"\n+\n+/* This obstack is used to accumulate the encoding of a data type.  */\n+extern struct obstack util_obstack;\n+\n+/* This points to the beginning of obstack contents, so we can free\n+   the whole contents.  */\n+extern char *util_firstobj;\n+\n+/* This will be used to initialize the obstacks used by encoding.  It\n+   should be called before any encoding function is used.  It is\n+   usually done in objc_init().  */\n+/* extern void objc_encoding_init (void); */\n+\n+\n+/* Encode a method prototype.  The format is described in\n+   gcc/doc/objc.texi, section 'Method signatures'.  */\n+extern tree encode_method_prototype (tree method_decl);\n+\n+/* This is used to implement @encode().  See gcc/doc/objc.texi,\n+   section '@encode'.  */\n+extern tree objc_build_encode_expr (tree type);\n+\n+/* (Decide if these can ever be validly changed.)  */\n+#define OBJC_ENCODE_INLINE_DEFS\t\t0\n+#define OBJC_ENCODE_DONT_INLINE_DEFS\t1\n+\n+/* Encode the attributes of a property.  */\n+extern tree objc_v2_encode_prop_attr (tree property);\n+\n+/* Encode the type of a field.  */\n+extern void encode_field_decl (tree field_decl, int curtype, int format);\n+\n+/* Tells \"encode_pointer/encode_aggregate\" whether we are generating\n+   type descriptors for instance variables (as opposed to methods).\n+   Type descriptors for instance variables contain more information\n+   than methods (for static typing and embedded structures).\n+\n+   TODO: Replace this global variable with an argument that is passed\n+   to the various encode() functions.\n+\n+   TODO: Change it to a 'bool'.  */\n+extern int generating_instance_variables;\n+\n+#endif /* GCC_OBJC_ENCODING_H */"}, {"sha": "fef5355c6a6e20991a8782f7b37417a57023dfdd", "filename": "gcc/objc/objc-gnu-runtime-abi-01.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c?ref=f027ee7cb0ed39a3c84b74673655bac4e22d335f", "patch": "@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"objc-runtime-hooks.h\"\n #include \"objc-runtime-shared-support.h\"\n+#include \"objc-encoding.h\"\n \n /* GNU runtime private definitions.  */\n #define DEF_CONSTANT_STRING_CLASS_NAME \"NXConstantString\""}, {"sha": "6183a21e5e85c62e9a6d9f68b331a77470d2bef0", "filename": "gcc/objc/objc-next-runtime-abi-01.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c?ref=f027ee7cb0ed39a3c84b74673655bac4e22d335f", "patch": "@@ -54,6 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"objc-runtime-hooks.h\"\n #include \"objc-runtime-shared-support.h\"\n+#include \"objc-encoding.h\"\n \n /* NeXT ABI 0 and 1 private definitions.  */\n #define DEF_CONSTANT_STRING_CLASS_NAME \"NSConstantString\""}, {"sha": "e7570c7e4b25e5b7093cf175bb6a07e1c89c91ab", "filename": "gcc/objc/objc-next-runtime-abi-02.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c?ref=f027ee7cb0ed39a3c84b74673655bac4e22d335f", "patch": "@@ -58,8 +58,8 @@ extern struct obstack util_obstack;\n extern char *util_firstobj;\n \n #include \"objc-runtime-hooks.h\"\n-\n #include \"objc-runtime-shared-support.h\"\n+#include \"objc-encoding.h\"\n \n /* ABI 2 Private definitions. */\n #define DEF_CONSTANT_STRING_CLASS_NAME \"NSConstantString\""}, {"sha": "913b0fd7e2b45ed6b91a9cbb17ebe991efd26b2a", "filename": "gcc/objc/objc-runtime-shared-support.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2Fobjc-runtime-shared-support.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2Fobjc-runtime-shared-support.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-runtime-shared-support.c?ref=f027ee7cb0ed39a3c84b74673655bac4e22d335f", "patch": "@@ -51,6 +51,7 @@ extern char *util_firstobj;\n #include \"objc-runtime-hooks.h\"\n \n #include \"objc-runtime-shared-support.h\"\n+#include \"objc-encoding.h\"\n \n /* rt_trees identifiers - shared between NeXT implementations.  These allow\n    the FE to tag meta-data in a manner that survives LTO and can be used when"}, {"sha": "0db8bed124086bf4204876f6e3b9e99ae34f5b66", "filename": "gcc/objc/objc-runtime-shared-support.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2Fobjc-runtime-shared-support.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjc%2Fobjc-runtime-shared-support.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-runtime-shared-support.h?ref=f027ee7cb0ed39a3c84b74673655bac4e22d335f", "patch": "@@ -52,20 +52,17 @@ extern void objc_push_parm (tree);\n \n extern tree build_function_type_for_method (tree, tree, int, bool);\n \n+extern char *objc_build_property_setter_name (tree);\n+\n /* Stuff that should be migrated to shared support (or some v1-only file).  */\n extern void build_super_template (void);\n \n extern tree objc_build_component_ref (tree, tree);\n \n-extern tree objc_v2_encode_prop_attr (tree);\n extern tree build_descriptor_table_initializer (tree, tree);\n extern tree build_method_prototype_list_template (tree, int);\n extern tree build_protocol_initializer (tree, tree, tree, tree, tree);\n \n-/* Stuff that should be migrated to shared encode.  */\n-extern tree encode_method_prototype (tree);\n-extern void encode_field_decl (tree, int, int);\n-\n /* Moved or new routines in objc-runtime-shared-support.c  */\n \n extern tree build_selector (tree);\n@@ -85,7 +82,6 @@ extern tree build_ivar_template (void);\n extern void generate_strings (void);\n \n extern void dump_interface (FILE *, tree);\n-extern int generating_instance_variables;\n extern FILE *gen_declaration_file;\n \n #endif /* _OBJC_RUNTIME_SHARED_SUPPORT_H_ */"}, {"sha": "e137c9936e3657fa0bd19df78132b7d47c57ac07", "filename": "gcc/objcp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FChangeLog?ref=f027ee7cb0ed39a3c84b74673655bac4e22d335f", "patch": "@@ -1,3 +1,19 @@\n+2011-07-04  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* Make-lang.in (OBJCXX_OBJS): Added objc-encoding.o.\n+\t(objcp/objcp-lang.o): Reordered dependencies.  Depend on GGC_H.\n+\t(objcp/objcp-decl.o): Reordered dependencies.\n+\t(objcp/objc-runtime-shared-support.o): Reordered dependencies.\n+\tUpdated them to be identical to the corresponding new objc/ ones,\n+\twith the addition of objcp-decl.h.\n+\t(objcp/objc-runtime-shared-support.o): Likewise.\n+\t(objcp/objc-gnu-runtime-abi-01.o): Likewise.\n+\t(objcp/objc-next-runtime-abi-01.o): Likewise.\n+\t(objcp/objc-next-runtime-abi-02.o): Likewise.\n+\t(objcp/objcp-act.o): Reordered dependencies.  Added dependency on\n+\tobjc-encoding.h.\n+\t(objcp/objc-encoding.o): New rule.\n+\t\n 2011-04-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objcp-decl.c (objcp_finish_struct): Use"}, {"sha": "f454e5fcd221015f43cf33b520b7d330b99500a5", "filename": "gcc/objcp/Make-lang.in", "status": "modified", "additions": 69, "deletions": 20, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f027ee7cb0ed39a3c84b74673655bac4e22d335f/gcc%2Fobjcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FMake-lang.in?ref=f027ee7cb0ed39a3c84b74673655bac4e22d335f", "patch": "@@ -57,6 +57,7 @@ OBJCXX_OBJS = objcp/objcp-act.o objcp/objcp-lang.o objcp/objcp-decl.o \\\n    objcp/objc-gnu-runtime-abi-01.o \\\n    objcp/objc-next-runtime-abi-01.o \\\n    objcp/objc-next-runtime-abi-02.o \\\n+   objcp/objc-encoding.o \\\n    $(CXX_AND_OBJCXX_OBJS)\n \n obj-c++_OBJS = $(OBJCXX_OBJS) cc1objplus-checksum.o\n@@ -76,48 +77,96 @@ cc1objplus$(exeext): $(OBJCXX_OBJS) cc1objplus-checksum.o $(BACKEND) $(LIBDEPS)\n \n # Objective C++ language specific files.\n \n-objcp/objcp-lang.o : objcp/objcp-lang.c $(START_HDRS) \\\n+objcp/objcp-lang.o : objcp/objcp-lang.c \\\n+  $(START_HDRS) \\\n+  $(GGC_H) \\\n   $(C_COMMON_H) $(LANGHOOKS_DEF_H) cp/cp-objcp-common.h \\\n   $(TARGET_H) gtype-objcp.h\n \n objcp/objcp-decl.o : objcp/objcp-decl.c \\\n    $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(CXX_TREE_H) \\\n-   objc/objc-act.h objcp/objcp-decl.h c-family/c-objc.h\n+   objc/objc-act.h c-family/c-objc.h \\\n+   objcp/objcp-decl.h\n \n objcp/objc-runtime-shared-support.o : objc/objc-runtime-shared-support.c \\\n-   $(START_HDRS) objc/objc-runtime-shared-support.h $(OBSTACK_H) \\\n-   objc/objc-next-metadata-tags.h gt-objc-objc-runtime-shared-support.h\n+   gt-objc-objc-runtime-shared-support.h \\\n+   $(START_HDRS) \\\n+   $(GGC_H) $(DIAGNOSTIC_CORE_H) $(FLAGS_H) input.h \\\n+   $(OBSTACK_H) \\\n+   objc/objc-encoding.h \\\n+   objc/objc-next-metadata-tags.h \\\n+   objc/objc-runtime-shared-support.h \\\n+   objcp/objcp-decl.h\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< \\\n \t\t$(OUTPUT_OPTION)\n \n-objcp/objc-gnu-runtime-abi-01.o: objc/objc-gnu-runtime-abi-01.c $(START_HDRS) \\\n-   objc/objc-runtime-hooks.h $(GGC_H) \\\n-   gt-objc-objc-gnu-runtime-abi-01.h toplev.h \n+objcp/objc-gnu-runtime-abi-01.o: objc/objc-gnu-runtime-abi-01.c \\\n+   gt-objc-objc-gnu-runtime-abi-01.h \\\n+   $(START_HDRS) \\\n+   $(GGC_H) $(DIAGNOSTIC_CORE_H) $(FLAGS_H) input.h \\\n+   $(OBSTACK_H) \\\n+   toplev.h \\\n+   objc/objc-encoding.h \\\n+   objc/objc-runtime-hooks.h \\\n+   objc/objc-runtime-shared-support.h \\\n+   objcp/objcp-decl.h\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< \\\n \t\t$(OUTPUT_OPTION)\n \n-objcp/objc-next-runtime-abi-01.o: objc/objc-next-runtime-abi-01.c $(START_HDRS) \\\n-   $(GGC_H) objc/objc-runtime-hooks.h \\\n-   objc/objc-next-metadata-tags.h gt-objc-objc-next-runtime-abi-01.h output.h \\\n-   objc/objc-runtime-shared-support.h $(TARGET_H)\n+objcp/objc-next-runtime-abi-01.o: objc/objc-next-runtime-abi-01.c \\\n+   gt-objc-objc-next-runtime-abi-01.h \\\n+   $(START_HDRS) \\\n+   $(GGC_H) $(DIAGNOSTIC_CORE_H) $(FLAGS_H) input.h \\\n+   $(OBSTACK_H) \\\n+   $(TARGET_H) output.h \\\n+   objc/objc-encoding.h \\\n+   objc/objc-next-metadata-tags.h \\\n+   objc/objc-runtime-hooks.h \\\n+   objc/objc-runtime-shared-support.h \\\n+   objcp/objcp-decl.h\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< \\\n \t\t$(OUTPUT_OPTION)\n \n-objcp/objc-next-runtime-abi-02.o: objc/objc-next-runtime-abi-02.c $(START_HDRS) \\\n-   $(GGC_H) objc/objc-runtime-hooks.h \\\n-   objc/objc-next-metadata-tags.h gt-objc-objc-next-runtime-abi-02.h $(TARGET_H) \\\n-   objc/objc-runtime-shared-support.h $(OBSTACK_H)\n+objcp/objc-next-runtime-abi-02.o: objc/objc-next-runtime-abi-02.c \\\n+   gt-objc-objc-next-runtime-abi-02.h \\\n+   $(START_HDRS) \\\n+   $(GGC_H) $(DIAGNOSTIC_CORE_H) $(FLAGS_H) input.h \\\n+   $(OBSTACK_H) \\\n+   $(TARGET_H) \\\n+   objc/objc-encoding.h \\\n+   objc/objc-next-metadata-tags.h \\\n+   objc/objc-runtime-hooks.h \\\n+   objc/objc-runtime-shared-support.h \\\n+   objcp/objcp-decl.h\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< \\\n \t\t$(OUTPUT_OPTION)\n \n \n # The following must be an explicit rule; please keep in sync with the implicit\n # one in Makefile.in.\n-objcp/objcp-act.o : objc/objc-act.c $(START_HDRS) $(GGC_H) \\\n-   $(RTL_H) $(EXPR_H) $(TARGET_H) $(DIAGNOSTIC_H) toplev.h $(FLAGS_H) \\\n-   input.h $(FUNCTION_H) output.h debug.h $(OBSTACK_H) \\\n-   objcp/objcp-decl.h $(LANGHOOKS_DEF_H) $(HASHTAB_H) gt-objc-objc-act.h \\\n-   $(GIMPLE_H) objc/objc-runtime-hooks.h objc/objc-runtime-shared-support.h\n+objcp/objcp-act.o : objc/objc-act.c \\\n+   gt-objc-objc-act.h \\\n+   $(START_HDRS) \\\n+   $(GGC_H) $(DIAGNOSTIC_H) $(FLAGS_H) input.h \\\n+   $(OBSTACK_H) \\\n+   toplev.h $(FUNCTION_H) output.h debug.h $(LANGHOOKS_DEF_H) \\\n+   $(HASHTAB_H) $(GIMPLE_H) \\\n+   $(RTL_H) $(EXPR_H) $(TARGET_H) \\\n+   objcp/objcp-decl.h \\\n+   objc/objc-encoding.h \\\n+   objc/objc-runtime-hooks.h \\\n+   objc/objc-runtime-shared-support.h \\\n+   objcp/objcp-decl.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< \\\n+\t\t$(OUTPUT_OPTION)\n+\n+objcp/objc-encoding.o : objc/objc-encoding.c \\\n+   $(START_HDRS) \\\n+   $(GGC_H) $(DIAGNOSTIC_CORE_H) $(FLAGS_H) input.h \\\n+   $(OBSTACK_H) \\\n+   objc/objc-encoding.h \\\n+   objc/objc-runtime-shared-support.h \\\n+   objcp/objcp-decl.h\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< \\\n \t\t$(OUTPUT_OPTION)\n "}]}