{"sha": "ebedc9a3414d842274607b77597759bd36e0f3e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJlZGM5YTM0MTRkODQyMjc0NjA3Yjc3NTk3NzU5YmQzNmUwZjNlMA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-11-13T16:29:59Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-11-13T16:29:59Z"}, "message": "Source range tracking in libcpp and C FE, with bit-packing optimization\n\nThis patch combines:\n  [PATCH 05/10] Add ranges to libcpp tokens (via ad-hoc data, unoptimized)\n  [PATCH 06/10] Track expression ranges in C frontend\n  [PATCH 07/10] Add plugin to recursively dump the source-ranges in a tree (v2)\n  [PATCH 08/10] Wire things up so that libcpp users get token underlines\n  [PATCH 09/10] Delay some resolution of ad-hoc locations, preserving ranges\n  [PATCH 10/10] Compress short ranges into source_location\n  [PATCH] libcpp: add examples to source_location description\nalong with fixes for the nits identified during review.\n\ngcc/ChangeLog:\n\t* Makefile.in (OBJS): Add gcc-rich-location.o.\n\t* diagnostic.c (diagnostic_append_note): Pass line_table to\n\trich_location ctor.\n\t(emit_diagnostic): Likewise.\n\t(inform): Likewise.\n\t(inform_n): Likewise.\n\t(warning): Likewise.\n\t(warning_at): Likewise.\n\t(warning_n): Likewise.\n\t(pedwarn): Likewise.\n\t(permerror): Likewise.\n\t(error): Likewise.\n\t(error_n): Likewise.\n\t(error_at): Likewise.\n\t(sorry): Likewise.\n\t(fatal_error): Likewise.\n\t(internal_error): Likewise.\n\t(internal_error_no_backtrace): Likewise.\n\t(source_range::debug): Likewise.\n\t* gcc-rich-location.c: New file.\n\t* gcc-rich-location.h: New file.\n\t* genmatch.c (fatal_at): Pass line_table to rich_location ctor.\n\t(warning_at): Likewise.\n\t* gimple.h (gimple_set_block): Use set_block function.\n\t* input.c (dump_line_table_statistics): Dump stats on how many\n\tranges were optimized vs how many needed ad-hoc table.\n\t(write_digit_row): Add \"map\" param; use its range_bits\n\tto calculate the per-character offset.\n\t(dump_location_info): Print the range and column bits for each\n\tordinary map.  Use the range bits to calculate the per-character\n\toffset.  Pass the map as a new param to the various calls to\n\twrite_digit_row.  Eliminate uses of\n\tORDINARY_MAP_NUMBER_OF_COLUMN_BITS.\n\t* print-tree.c (print_node): Print any source range information.\n\t* rtl-error.c (diagnostic_for_asm): Likewise.\n\t* toplev.c (general_init): Initialize line_table's\n\tdefault_range_bits.\n\t* tree-cfg.c (move_block_to_fn): Likewise.\n\t(move_block_to_fn): Likewise.\n\t* tree-inline.c (copy_phis_for_bb): Likewise.\n\t* tree.c (tree_set_block): Likewise.\n\t(get_pure_location): New function.\n\t(set_source_range): New functions.\n\t(set_block): New function.\n\t(set_source_range): New functions.\n\t* tree.h (CAN_HAVE_RANGE_P): New.\n\t(EXPR_LOCATION_RANGE): New.\n\t(EXPR_HAS_RANGE): New.\n\t(get_expr_source_range): New inline function.\n\t(DECL_LOCATION_RANGE): New.\n\t(set_source_range): New decls.\n\t(get_decl_source_range): New inline function.\n\ngcc/ada/ChangeLog:\n\t* gcc-interface/trans.c (Sloc_to_locus): Add line_table param when\n\tcalling linemap_position_for_line_and_column.\n\ngcc/c-family/ChangeLog:\n\t* c-common.c (c_fully_fold_internal): Capture existing souce_range,\n\tand store it on the result.\n\t* c-opts.c (c_common_init_options): Set\n\tglobal_dc->colorize_source_p.\n\ngcc/c/ChangeLog:\n\t* c-decl.c (warn_defaults_to): Pass line_table to\n\trich_location ctor.\n\t* c-errors.c (pedwarn_c99): Likewise.\n\t(pedwarn_c90): Likewise.\n\t* c-parser.c (set_c_expr_source_range): New functions.\n\t(c_token::get_range): New method.\n\t(c_token::get_finish): New method.\n\t(c_parser_expr_no_commas): Call set_c_expr_source_range on the ret\n\tbased on the range from the start of the LHS to the end of the\n\tRHS.\n\t(c_parser_conditional_expression): Likewise, based on the range\n\tfrom the start of the cond.value to the end of exp2.value.\n\t(c_parser_binary_expression): Call set_c_expr_source_range on\n\tthe stack values for TRUTH_ANDIF_EXPR and TRUTH_ORIF_EXPR.\n\t(c_parser_cast_expression): Call set_c_expr_source_range on ret\n\tbased on the cast_loc through to the end of the expr.\n\t(c_parser_unary_expression): Likewise, based on the\n\top_loc through to the end of op.\n\t(c_parser_sizeof_expression) Likewise, based on the start of the\n\tsizeof token through to either the closing paren or the end of\n\texpr.\n\t(c_parser_postfix_expression): Likewise, using the token range,\n\tor from the open paren through to the close paren for\n\tparenthesized expressions.\n\t(c_parser_postfix_expression_after_primary): Likewise, for\n\tvarious kinds of expression.\n\t* c-tree.h (struct c_expr): Add field \"src_range\".\n\t(c_expr::get_start): New method.\n\t(c_expr::get_finish): New method.\n\t(set_c_expr_source_range): New decls.\n\t* c-typeck.c (parser_build_unary_op): Call set_c_expr_source_range\n\ton ret for prefix unary ops.\n\t(parser_build_binary_op): Likewise, running from the start of\n\targ1.value through to the end of arg2.value.\n\ngcc/cp/ChangeLog:\n\t* error.c (pedwarn_cxx98): Pass line_table to rich_location ctor.\n\ngcc/fortran/ChangeLog:\n\t* error.c (gfc_warning): Pass line_table to rich_location ctor.\n\t(gfc_warning_now_at): Likewise.\n\t(gfc_warning_now): Likewise.\n\t(gfc_error_now): Likewise.\n\t(gfc_fatal_error): Likewise.\n\t(gfc_error): Likewise.\n\t(gfc_internal_error): Likewise.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/diagnostic-token-ranges.c: New file.\n\t* gcc.dg/diagnostic-tree-expr-ranges-2.c: New file.\n\t* gcc.dg/plugin/diagnostic-test-expressions-1.c: New file.\n\t* gcc.dg/plugin/diagnostic-test-show-trees-1.c: New file.\n\t* gcc.dg/plugin/diagnostic_plugin_show_trees.c: New file.\n\t* gcc.dg/plugin/diagnostic_plugin_test_show_locus.c (get_loc): Add\n\tline_table param when calling\n\tlinemap_position_for_line_and_column.\n\t(test_show_locus): Pass line_table to rich_location ctors.\n\t(plugin_init): Remove setting of global_dc->colorize_source_p.\n\t* gcc.dg/plugin/diagnostic_plugin_test_tree_expression_range.c:\n\tNew file.\n\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Add\n\tdiagnostic_plugin_test_tree_expression_range.c,\n\tdiagnostic-test-expressions-1.c, diagnostic_plugin_show_trees.c,\n\tand diagnostic-test-show-trees-1.c.\n\nlibcpp/ChangeLog:\n\t* errors.c (cpp_diagnostic): Pass pfile->line_table to\n\trich_location ctor.\n\t(cpp_diagnostic_with_line): Likewise.\n\t* include/cpplib.h (struct cpp_token): Update comment for src_loc\n\tto indicate that the range of the token is \"baked into\" the\n\tsource_location.\n\t* include/line-map.h (source_location): Update the descriptive\n\tcomment to reflect the packing scheme for short ranges, adding\n\tworked examples of location encoding.\n\t(struct line_map_ordinary): Drop field \"column_bits\" in favor\n\tof field \"m_column_and_range_bits\"; add field \"m_range_bits\".\n\t(ORDINARY_MAP_NUMBER_OF_COLUMN_BITS): Delete.\n\t(location_adhoc_data): Add source_range field.\n\t(struct line_maps): Add fields \"default_range_bits\",\n\t\"num_optimized_ranges\" and \"num_unoptimized_ranges\".\n\t(get_combined_adhoc_loc): Add source_range param.\n\t(get_range_from_loc): New declaration.\n\t(pure_location_p): New prototype.\n\t(COMBINE_LOCATION_DATA):  Add source_range param.\n\t(SOURCE_LINE): Update for renaming of column_bits.\n\t(SOURCE_COLUMN): Likewise.  Shift the column right by the map's\n\trange_bits.\n\t(LAST_SOURCE_LINE_LOCATION): Update for renaming of column_bits.\n\t(linemap_position_for_line_and_column): Add line_maps * params.\n\t(rich_location::rich_location): Likewise.\n\t* lex.c (_cpp_lex_direct): Capture the range of the token, baking\n\tit into token->src_loc via a call to COMBINE_LOCATION_DATA.\n\t* line-map.c (LINE_MAP_MAX_COLUMN_NUMBER): Reduce from 1U << 17 to\n\t1U << 12.\n\t(location_adhoc_data_hash): Add the src_range into\n\tthe hash value.\n\t(location_adhoc_data_eq): Require equality of the src_range\n\tvalues.\n\t(can_be_stored_compactly_p): New function.\n\t(get_combined_adhoc_loc): Add src_range param, and store it,\n\tvia a bit-packing scheme for short ranges, otherwise within the\n\tlookaside table.  Remove the requirement that data is non-NULL.\n\t(get_range_from_adhoc_loc): New function.\n\t(get_range_from_loc): New function.\n\t(pure_location_p): New function.\n\t(linemap_add): Ensure that start_location has zero for the\n\trange_bits, unless we're past LINE_MAP_MAX_LOCATION_WITH_COLS.\n\tInitialize range_bits to zero.  Assert that the start_location\n\tis \"pure\".\n\t(linemap_line_start): Assert that the\n\tcolumn_and_range_bits >= range_bits.\n\tUpdate determinination of whether we need to start a new map\n\tusing the effective column bits, without the range bits.\n\tUse the set's default_range_bits in new maps, apart from\n\tthose with column_bits == 0, which should also have 0 range_bits.\n\tIncrease the column bits for new maps by the range bits.\n\tWhen adding lines to an existing map, use set->highest_line\n\tdirectly rather than offsetting highest by SOURCE_COLUMN.\n\tAdd assertions to sanity-check the return value.\n\t(linemap_position_for_column): Offset to_column by range_bits.\n\tUpdate set->highest_location if necessary.\n\t(linemap_position_for_line_and_column): Add line_maps * param.\n\tUpdate the calculation to offset the column by range_bits, and\n\tconditionalize it on being <= LINE_MAP_MAX_LOCATION_WITH_COLS.\n\tBound it by LINEMAPS_MACRO_LOWEST_LOCATION.  Update\n\tset->highest_location if necessary.\n\t(linemap_position_for_loc_and_offset): Handle ad-hoc locations;\n\tpass \"set\" to linemap_position_for_line_and_column.\n\t(linemap_macro_map_loc_unwind_toward_spelling): Add line_maps\n\tparam.  Handle ad-hoc locations.\n\t(linemap_location_in_system_header_p): Pass on \"set\" to call to\n\tlinemap_macro_map_loc_unwind_toward_spelling.\n\t(linemap_macro_loc_to_spelling_point): Retain ad-hoc locations.\n\tPass on \"set\" to call to\n\tlinemap_macro_map_loc_unwind_toward_spelling.\n\t(linemap_resolve_location): Retain ad-hoc locations.  Pass on\n\t\"set\" to call to linemap_macro_map_loc_unwind_toward_spelling.\n\t(linemap_unwind_toward_expansion):  Pass on \"set\" to call to\n\tlinemap_macro_map_loc_unwind_toward_spelling.\n\t(linemap_expand_location): Extract the data pointer before\n\textracting the location.\n\t(rich_location::rich_location): Add line_maps param; use it to\n\textract the range from the source_location.\n\t* location-example.txt: Regenerate, showing new representation.\n\nFrom-SVN: r230331", "tree": {"sha": "d1ab10c369a8f1ec9f67e1e8cb70acef36897f21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1ab10c369a8f1ec9f67e1e8cb70acef36897f21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebedc9a3414d842274607b77597759bd36e0f3e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebedc9a3414d842274607b77597759bd36e0f3e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebedc9a3414d842274607b77597759bd36e0f3e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebedc9a3414d842274607b77597759bd36e0f3e0/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1ba91a49a97955057bb8a07b42feb901ee9cee4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ba91a49a97955057bb8a07b42feb901ee9cee4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ba91a49a97955057bb8a07b42feb901ee9cee4e"}], "stats": {"total": 2349, "additions": 2107, "deletions": 242}, "files": [{"sha": "a170b6015fafc22fe990ff7c81398a3a140d2080", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -1,3 +1,58 @@\n+2015-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (OBJS): Add gcc-rich-location.o.\n+\t* diagnostic.c (diagnostic_append_note): Pass line_table to\n+\trich_location ctor.\n+\t(emit_diagnostic): Likewise.\n+\t(inform): Likewise.\n+\t(inform_n): Likewise.\n+\t(warning): Likewise.\n+\t(warning_at): Likewise.\n+\t(warning_n): Likewise.\n+\t(pedwarn): Likewise.\n+\t(permerror): Likewise.\n+\t(error): Likewise.\n+\t(error_n): Likewise.\n+\t(error_at): Likewise.\n+\t(sorry): Likewise.\n+\t(fatal_error): Likewise.\n+\t(internal_error): Likewise.\n+\t(internal_error_no_backtrace): Likewise.\n+\t(source_range::debug): Likewise.\n+\t* gcc-rich-location.c: New file.\n+\t* gcc-rich-location.h: New file.\n+\t* genmatch.c (fatal_at): Pass line_table to rich_location ctor.\n+\t(warning_at): Likewise.\n+\t* gimple.h (gimple_set_block): Use set_block function.\n+\t* input.c (dump_line_table_statistics): Dump stats on how many\n+\tranges were optimized vs how many needed ad-hoc table.\n+\t(write_digit_row): Add \"map\" param; use its range_bits\n+\tto calculate the per-character offset.\n+\t(dump_location_info): Print the range and column bits for each\n+\tordinary map.  Use the range bits to calculate the per-character\n+\toffset.  Pass the map as a new param to the various calls to\n+\twrite_digit_row.  Eliminate uses of\n+\tORDINARY_MAP_NUMBER_OF_COLUMN_BITS.\n+\t* print-tree.c (print_node): Print any source range information.\n+\t* rtl-error.c (diagnostic_for_asm): Likewise.\n+\t* toplev.c (general_init): Initialize line_table's\n+\tdefault_range_bits.\n+\t* tree-cfg.c (move_block_to_fn): Likewise.\n+\t(move_block_to_fn): Likewise.\n+\t* tree-inline.c (copy_phis_for_bb): Likewise.\n+\t* tree.c (tree_set_block): Likewise.\n+\t(get_pure_location): New function.\n+\t(set_source_range): New functions.\n+\t(set_block): New function.\n+\t(set_source_range): New functions.\n+\t* tree.h (CAN_HAVE_RANGE_P): New.\n+\t(EXPR_LOCATION_RANGE): New.\n+\t(EXPR_HAS_RANGE): New.\n+\t(get_expr_source_range): New inline function.\n+\t(DECL_LOCATION_RANGE): New.\n+\t(set_source_range): New decls.\n+\t(get_decl_source_range): New inline function.\n+\n 2015-11-13  Alan Lawrence  <alan.lawrence@arm.com>\n \n \tPR tree-optimization/67682"}, {"sha": "d3fd5e96442de64a964947ac925f82e2313bb21e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -1263,6 +1263,7 @@ OBJS = \\\n \tfold-const-call.o \\\n \tfunction.o \\\n \tfwprop.o \\\n+\tgcc-rich-location.o \\\n \tgcse.o \\\n \tgcse-common.o \\\n \tggc-common.o \\"}, {"sha": "00c044a921f58a5f88a6132d9ef04c01e83e9dfe", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -1,3 +1,8 @@\n+2015-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc-interface/trans.c (Sloc_to_locus): Add line_table param when\n+\tcalling linemap_position_for_line_and_column.\n+\n 2015-11-13  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_attr.adb: Minor reformatting."}, {"sha": "eeb2aaca5cffd6b23841a4849c3b7b9746512905", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -9650,7 +9650,8 @@ Sloc_to_locus (Source_Ptr Sloc, location_t *locus, bool clear_column)\n     line = 1;\n \n   /* Translate the location.  */\n-  *locus = linemap_position_for_line_and_column (map, line, column);\n+  *locus = linemap_position_for_line_and_column (line_table, map,\n+\t\t\t\t\t\t line, column);\n \n   return true;\n }"}, {"sha": "e3f81ff6219a2c76d153bc253c3026965c30e502", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -1,3 +1,10 @@\n+2015-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-common.c (c_fully_fold_internal): Capture existing souce_range,\n+\tand store it on the result.\n+\t* c-opts.c (c_common_init_options): Set\n+\tglobal_dc->colorize_source_p.\n+\n 2015-11-12  James Norris  <jnorris@codesourcery.com>\n \t    Joseph Myers  <joseph@codesourcery.com>\n "}, {"sha": "89e978d16de2b378343b7f7c04c4eafc4cc57bf1", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -1187,6 +1187,7 @@ c_fully_fold_internal (tree expr, bool in_init, bool *maybe_const_operands,\n   bool op0_const_self = true, op1_const_self = true, op2_const_self = true;\n   bool nowarning = TREE_NO_WARNING (expr);\n   bool unused_p;\n+  source_range old_range;\n \n   /* This function is not relevant to C++ because C++ folds while\n      parsing, and may need changes to be correct for C++ when C++\n@@ -1202,6 +1203,9 @@ c_fully_fold_internal (tree expr, bool in_init, bool *maybe_const_operands,\n       || code == SAVE_EXPR)\n     return expr;\n \n+  if (IS_EXPR_CODE_CLASS (kind))\n+    old_range = EXPR_LOCATION_RANGE (expr);\n+\n   /* Operands of variable-length expressions (function calls) have\n      already been folded, as have __builtin_* function calls, and such\n      expressions cannot occur in constant expressions.  */\n@@ -1626,7 +1630,11 @@ c_fully_fold_internal (tree expr, bool in_init, bool *maybe_const_operands,\n       TREE_NO_WARNING (ret) = 1;\n     }\n   if (ret != expr)\n-    protected_set_expr_location (ret, loc);\n+    {\n+      protected_set_expr_location (ret, loc);\n+      if (IS_EXPR_CODE_CLASS (kind))\n+\tset_source_range (ret, old_range.m_start, old_range.m_finish);\n+    }\n   return ret;\n }\n "}, {"sha": "9ae181f26ed6ce9bbca4b8137af9f3027fe15773", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -245,6 +245,8 @@ c_common_init_options (unsigned int decoded_options_count,\n \t    break;\n \t  }\n     }\n+\n+  global_dc->colorize_source_p = true;\n }\n \n /* Handle switch SCODE with argument ARG.  VALUE is true, unless no-"}, {"sha": "810f2c6c575707b78c6632cf3814c222dda5cbe2", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -1,3 +1,40 @@\n+2015-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-decl.c (warn_defaults_to): Pass line_table to\n+\trich_location ctor.\n+\t* c-errors.c (pedwarn_c99): Likewise.\n+\t(pedwarn_c90): Likewise.\n+\t* c-parser.c (set_c_expr_source_range): New functions.\n+\t(c_token::get_range): New method.\n+\t(c_token::get_finish): New method.\n+\t(c_parser_expr_no_commas): Call set_c_expr_source_range on the ret\n+\tbased on the range from the start of the LHS to the end of the\n+\tRHS.\n+\t(c_parser_conditional_expression): Likewise, based on the range\n+\tfrom the start of the cond.value to the end of exp2.value.\n+\t(c_parser_binary_expression): Call set_c_expr_source_range on\n+\tthe stack values for TRUTH_ANDIF_EXPR and TRUTH_ORIF_EXPR.\n+\t(c_parser_cast_expression): Call set_c_expr_source_range on ret\n+\tbased on the cast_loc through to the end of the expr.\n+\t(c_parser_unary_expression): Likewise, based on the\n+\top_loc through to the end of op.\n+\t(c_parser_sizeof_expression) Likewise, based on the start of the\n+\tsizeof token through to either the closing paren or the end of\n+\texpr.\n+\t(c_parser_postfix_expression): Likewise, using the token range,\n+\tor from the open paren through to the close paren for\n+\tparenthesized expressions.\n+\t(c_parser_postfix_expression_after_primary): Likewise, for\n+\tvarious kinds of expression.\n+\t* c-tree.h (struct c_expr): Add field \"src_range\".\n+\t(c_expr::get_start): New method.\n+\t(c_expr::get_finish): New method.\n+\t(set_c_expr_source_range): New decls.\n+\t* c-typeck.c (parser_build_unary_op): Call set_c_expr_source_range\n+\ton ret for prefix unary ops.\n+\t(parser_build_binary_op): Likewise, running from the start of\n+\targ1.value through to the end of arg2.value.\n+\n 2015-11-13  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/68320"}, {"sha": "9a222d8f511e0fc2c7525b6a18010825f58a4f02", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -5278,7 +5278,7 @@ warn_defaults_to (location_t location, int opt, const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n-  rich_location richloc (location);\n+  rich_location richloc (line_table, location);\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc,"}, {"sha": "ee9c2b5858df6c96174ecfab67f63a00e74fdb74", "filename": "gcc/c/c-errors.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fc%2Fc-errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fc%2Fc-errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-errors.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -37,7 +37,7 @@ pedwarn_c99 (location_t location, int opt, const char *gmsgid, ...)\n   diagnostic_info diagnostic;\n   va_list ap;\n   bool warned = false;\n-  rich_location richloc (location);\n+  rich_location richloc (line_table, location);\n \n   va_start (ap, gmsgid);\n   /* If desired, issue the C99/C11 compat warning, which is more specific\n@@ -76,7 +76,7 @@ pedwarn_c90 (location_t location, int opt, const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n-  rich_location richloc (location);\n+  rich_location richloc (line_table, location);\n \n   va_start (ap, gmsgid);\n   /* Warnings such as -Wvla are the most specific ones.  */"}, {"sha": "943d3e58d279222f4a896d227e822dca1d3eac57", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 89, "deletions": 3, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -59,6 +59,23 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-expr.h\"\n #include \"context.h\"\n \n+void\n+set_c_expr_source_range (c_expr *expr,\n+\t\t\t location_t start, location_t finish)\n+{\n+  expr->src_range.m_start = start;\n+  expr->src_range.m_finish = finish;\n+  set_source_range (expr->value, start, finish);\n+}\n+\n+void\n+set_c_expr_source_range (c_expr *expr,\n+\t\t\t source_range src_range)\n+{\n+  expr->src_range = src_range;\n+  set_source_range (expr->value, src_range);\n+}\n+\n \f\n /* Initialization routine for this file.  */\n \n@@ -164,6 +181,16 @@ struct GTY (()) c_token {\n   location_t location;\n   /* The value associated with this token, if any.  */\n   tree value;\n+\n+  source_range get_range () const\n+  {\n+    return get_range_from_loc (line_table, location);\n+  }\n+\n+  location_t get_finish () const\n+  {\n+    return get_range ().m_finish;\n+  }\n };\n \n /* A parser structure recording information about the state and\n@@ -6117,6 +6144,7 @@ c_parser_expr_no_commas (c_parser *parser, struct c_expr *after,\n   ret.value = build_modify_expr (op_location, lhs.value, lhs.original_type,\n \t\t\t\t code, exp_location, rhs.value,\n \t\t\t\t rhs.original_type);\n+  set_c_expr_source_range (&ret, lhs.get_start (), rhs.get_finish ());\n   if (code == NOP_EXPR)\n     ret.original_code = MODIFY_EXPR;\n   else\n@@ -6147,14 +6175,18 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after,\n \t\t\t\t tree omp_atomic_lhs)\n {\n   struct c_expr cond, exp1, exp2, ret;\n-  location_t cond_loc, colon_loc, middle_loc;\n+  location_t start, cond_loc, colon_loc, middle_loc;\n \n   gcc_assert (!after || c_dialect_objc ());\n \n   cond = c_parser_binary_expression (parser, after, omp_atomic_lhs);\n \n   if (c_parser_next_token_is_not (parser, CPP_QUERY))\n     return cond;\n+  if (cond.value != error_mark_node)\n+    start = cond.get_start ();\n+  else\n+    start = UNKNOWN_LOCATION;\n   cond_loc = c_parser_peek_token (parser)->location;\n   cond = convert_lvalue_to_rvalue (cond_loc, cond, true, true);\n   c_parser_consume_token (parser);\n@@ -6230,6 +6262,7 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after,\n \t\t\t   ? t1\n \t\t\t   : NULL);\n     }\n+  set_c_expr_source_range (&ret, start, exp2.get_finish ());\n   return ret;\n }\n \n@@ -6382,6 +6415,7 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after,\n     {\n       enum c_parser_prec oprec;\n       enum tree_code ocode;\n+      source_range src_range;\n       if (parser->error)\n \tgoto out;\n       switch (c_parser_peek_token (parser)->type)\n@@ -6470,22 +6504,26 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after,\n       switch (ocode)\n \t{\n \tcase TRUTH_ANDIF_EXPR:\n+\t  src_range = stack[sp].expr.src_range;\n \t  stack[sp].expr\n \t    = convert_lvalue_to_rvalue (stack[sp].loc,\n \t\t\t\t\tstack[sp].expr, true, true);\n \t  stack[sp].expr.value = c_objc_common_truthvalue_conversion\n \t    (stack[sp].loc, default_conversion (stack[sp].expr.value));\n \t  c_inhibit_evaluation_warnings += (stack[sp].expr.value\n \t\t\t\t\t    == truthvalue_false_node);\n+\t  set_c_expr_source_range (&stack[sp].expr, src_range);\n \t  break;\n \tcase TRUTH_ORIF_EXPR:\n+\t  src_range = stack[sp].expr.src_range;\n \t  stack[sp].expr\n \t    = convert_lvalue_to_rvalue (stack[sp].loc,\n \t\t\t\t\tstack[sp].expr, true, true);\n \t  stack[sp].expr.value = c_objc_common_truthvalue_conversion\n \t    (stack[sp].loc, default_conversion (stack[sp].expr.value));\n \t  c_inhibit_evaluation_warnings += (stack[sp].expr.value\n \t\t\t\t\t    == truthvalue_true_node);\n+\t  set_c_expr_source_range (&stack[sp].expr, src_range);\n \t  break;\n \tdefault:\n \t  break;\n@@ -6554,6 +6592,8 @@ c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n \texpr = convert_lvalue_to_rvalue (expr_loc, expr, true, true);\n       }\n       ret.value = c_cast_expr (cast_loc, type_name, expr.value);\n+      if (ret.value && expr.value)\n+\tset_c_expr_source_range (&ret, cast_loc, expr.get_finish ());\n       ret.original_code = ERROR_MARK;\n       ret.original_type = NULL;\n       return ret;\n@@ -6603,6 +6643,7 @@ c_parser_unary_expression (c_parser *parser)\n   struct c_expr ret, op;\n   location_t op_loc = c_parser_peek_token (parser)->location;\n   location_t exp_loc;\n+  location_t finish;\n   ret.original_code = ERROR_MARK;\n   ret.original_type = NULL;\n   switch (c_parser_peek_token (parser)->type)\n@@ -6642,8 +6683,10 @@ c_parser_unary_expression (c_parser *parser)\n       c_parser_consume_token (parser);\n       exp_loc = c_parser_peek_token (parser)->location;\n       op = c_parser_cast_expression (parser, NULL);\n+      finish = op.get_finish ();\n       op = convert_lvalue_to_rvalue (exp_loc, op, true, true);\n       ret.value = build_indirect_ref (op_loc, op.value, RO_UNARY_STAR);\n+      set_c_expr_source_range (&ret, op_loc, finish);\n       return ret;\n     case CPP_PLUS:\n       if (!c_dialect_objc () && !in_system_header_at (input_location))\n@@ -6731,8 +6774,15 @@ static struct c_expr\n c_parser_sizeof_expression (c_parser *parser)\n {\n   struct c_expr expr;\n+  struct c_expr result;\n   location_t expr_loc;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_SIZEOF));\n+\n+  location_t start;\n+  location_t finish = UNKNOWN_LOCATION;\n+\n+  start = c_parser_peek_token (parser)->location;\n+\n   c_parser_consume_token (parser);\n   c_inhibit_evaluation_warnings++;\n   in_sizeof++;\n@@ -6746,6 +6796,7 @@ c_parser_sizeof_expression (c_parser *parser)\n       expr_loc = c_parser_peek_token (parser)->location;\n       type_name = c_parser_type_name (parser);\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      finish = parser->tokens_buf[0].location;\n       if (type_name == NULL)\n \t{\n \t  struct c_expr ret;\n@@ -6761,26 +6812,31 @@ c_parser_sizeof_expression (c_parser *parser)\n \t  expr = c_parser_postfix_expression_after_paren_type (parser,\n \t\t\t\t\t\t\t       type_name,\n \t\t\t\t\t\t\t       expr_loc);\n+\t  finish = expr.get_finish ();\n \t  goto sizeof_expr;\n \t}\n       /* sizeof ( type-name ).  */\n       c_inhibit_evaluation_warnings--;\n       in_sizeof--;\n-      return c_expr_sizeof_type (expr_loc, type_name);\n+      result = c_expr_sizeof_type (expr_loc, type_name);\n     }\n   else\n     {\n       expr_loc = c_parser_peek_token (parser)->location;\n       expr = c_parser_unary_expression (parser);\n+      finish = expr.get_finish ();\n     sizeof_expr:\n       c_inhibit_evaluation_warnings--;\n       in_sizeof--;\n       mark_exp_read (expr.value);\n       if (TREE_CODE (expr.value) == COMPONENT_REF\n \t  && DECL_C_BIT_FIELD (TREE_OPERAND (expr.value, 1)))\n \terror_at (expr_loc, \"%<sizeof%> applied to a bit-field\");\n-      return c_expr_sizeof_expr (expr_loc, expr);\n+      result = c_expr_sizeof_expr (expr_loc, expr);\n     }\n+  if (finish != UNKNOWN_LOCATION)\n+    set_c_expr_source_range (&result, start, finish);\n+  return result;\n }\n \n /* Parse an alignof expression.  */\n@@ -7200,12 +7256,14 @@ c_parser_postfix_expression (c_parser *parser)\n   struct c_expr expr, e1;\n   struct c_type_name *t1, *t2;\n   location_t loc = c_parser_peek_token (parser)->location;;\n+  source_range tok_range = c_parser_peek_token (parser)->get_range ();\n   expr.original_code = ERROR_MARK;\n   expr.original_type = NULL;\n   switch (c_parser_peek_token (parser)->type)\n     {\n     case CPP_NUMBER:\n       expr.value = c_parser_peek_token (parser)->value;\n+      set_c_expr_source_range (&expr, tok_range);\n       loc = c_parser_peek_token (parser)->location;\n       c_parser_consume_token (parser);\n       if (TREE_CODE (expr.value) == FIXED_CST\n@@ -7220,6 +7278,7 @@ c_parser_postfix_expression (c_parser *parser)\n     case CPP_CHAR32:\n     case CPP_WCHAR:\n       expr.value = c_parser_peek_token (parser)->value;\n+      set_c_expr_source_range (&expr, tok_range);\n       c_parser_consume_token (parser);\n       break;\n     case CPP_STRING:\n@@ -7228,13 +7287,15 @@ c_parser_postfix_expression (c_parser *parser)\n     case CPP_WSTRING:\n     case CPP_UTF8STRING:\n       expr.value = c_parser_peek_token (parser)->value;\n+      set_c_expr_source_range (&expr, tok_range);\n       expr.original_code = STRING_CST;\n       c_parser_consume_token (parser);\n       break;\n     case CPP_OBJC_STRING:\n       gcc_assert (c_dialect_objc ());\n       expr.value\n \t= objc_build_string_object (c_parser_peek_token (parser)->value);\n+      set_c_expr_source_range (&expr, tok_range);\n       c_parser_consume_token (parser);\n       break;\n     case CPP_NAME:\n@@ -7248,6 +7309,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t\t\t\t\t     (c_parser_peek_token (parser)->type\n \t\t\t\t\t      == CPP_OPEN_PAREN),\n \t\t\t\t\t     &expr.original_type);\n+\t    set_c_expr_source_range (&expr, tok_range);\n \t    break;\n \t  }\n \tcase C_ID_CLASSNAME:\n@@ -7336,13 +7398,16 @@ c_parser_postfix_expression (c_parser *parser)\n       else\n \t{\n \t  /* A parenthesized expression.  */\n+\t  location_t loc_open_paren = c_parser_peek_token (parser)->location;\n \t  c_parser_consume_token (parser);\n \t  expr = c_parser_expression (parser);\n \t  if (TREE_CODE (expr.value) == MODIFY_EXPR)\n \t    TREE_NO_WARNING (expr.value) = 1;\n \t  if (expr.original_code != C_MAYBE_CONST_EXPR)\n \t    expr.original_code = ERROR_MARK;\n \t  /* Don't change EXPR.ORIGINAL_TYPE.  */\n+\t  location_t loc_close_paren = c_parser_peek_token (parser)->location;\n+\t  set_c_expr_source_range (&expr, loc_open_paren, loc_close_paren);\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n \t}\n@@ -7933,6 +7998,8 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n   vec<tree, va_gc> *exprlist;\n   vec<tree, va_gc> *origtypes = NULL;\n   vec<location_t> arg_loc = vNULL;\n+  location_t start;\n+  location_t finish;\n \n   while (true)\n     {\n@@ -7969,7 +8036,10 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t\t{\n \t\t  c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,\n \t\t\t\t\t     \"expected %<]%>\");\n+\t\t  start = expr.get_start ();\n+\t\t  finish = parser->tokens_buf[0].location;\n \t\t  expr.value = build_array_ref (op_loc, expr.value, idx);\n+\t\t  set_c_expr_source_range (&expr, start, finish);\n \t\t}\n \t    }\n \t  expr.original_code = ERROR_MARK;\n@@ -8012,9 +8082,13 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t\t\t\"%<memset%> used with constant zero length parameter; \"\n \t\t\t\"this could be due to transposed parameters\");\n \n+\t  start = expr.get_start ();\n+\t  finish = parser->tokens_buf[0].get_finish ();\n \t  expr.value\n \t    = c_build_function_call_vec (expr_loc, arg_loc, expr.value,\n \t\t\t\t\t exprlist, origtypes);\n+\t  set_c_expr_source_range (&expr, start, finish);\n+\n \t  expr.original_code = ERROR_MARK;\n \t  if (TREE_CODE (expr.value) == INTEGER_CST\n \t      && TREE_CODE (orig_expr.value) == FUNCTION_DECL\n@@ -8043,8 +8117,11 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n               expr.original_type = NULL;\n \t      return expr;\n \t    }\n+\t  start = expr.get_start ();\n+\t  finish = c_parser_peek_token (parser)->get_finish ();\n \t  c_parser_consume_token (parser);\n \t  expr.value = build_component_ref (op_loc, expr.value, ident);\n+\t  set_c_expr_source_range (&expr, start, finish);\n \t  expr.original_code = ERROR_MARK;\n \t  if (TREE_CODE (expr.value) != COMPONENT_REF)\n \t    expr.original_type = NULL;\n@@ -8072,12 +8149,15 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t      expr.original_type = NULL;\n \t      return expr;\n \t    }\n+\t  start = expr.get_start ();\n+\t  finish = c_parser_peek_token (parser)->get_finish ();\n \t  c_parser_consume_token (parser);\n \t  expr.value = build_component_ref (op_loc,\n \t\t\t\t\t    build_indirect_ref (op_loc,\n \t\t\t\t\t\t\t\texpr.value,\n \t\t\t\t\t\t\t\tRO_ARROW),\n \t\t\t\t\t    ident);\n+\t  set_c_expr_source_range (&expr, start, finish);\n \t  expr.original_code = ERROR_MARK;\n \t  if (TREE_CODE (expr.value) != COMPONENT_REF)\n \t    expr.original_type = NULL;\n@@ -8093,6 +8173,8 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t  break;\n \tcase CPP_PLUS_PLUS:\n \t  /* Postincrement.  */\n+\t  start = expr.get_start ();\n+\t  finish = c_parser_peek_token (parser)->get_finish ();\n \t  c_parser_consume_token (parser);\n \t  /* If the expressions have array notations, we expand them.  */\n \t  if (flag_cilkplus\n@@ -8104,11 +8186,14 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t      expr.value = build_unary_op (op_loc,\n \t\t\t\t\t   POSTINCREMENT_EXPR, expr.value, 0);\n \t    }\n+\t  set_c_expr_source_range (&expr, start, finish);\n \t  expr.original_code = ERROR_MARK;\n \t  expr.original_type = NULL;\n \t  break;\n \tcase CPP_MINUS_MINUS:\n \t  /* Postdecrement.  */\n+\t  start = expr.get_start ();\n+\t  finish = c_parser_peek_token (parser)->get_finish ();\n \t  c_parser_consume_token (parser);\n \t  /* If the expressions have array notations, we expand them.  */\n \t  if (flag_cilkplus\n@@ -8120,6 +8205,7 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t      expr.value = build_unary_op (op_loc,\n \t\t\t\t\t   POSTDECREMENT_EXPR, expr.value, 0);\n \t    }\n+\t  set_c_expr_source_range (&expr, start, finish);\n \t  expr.original_code = ERROR_MARK;\n \t  expr.original_type = NULL;\n \t  break;"}, {"sha": "6bc216af889b8a28b76bf08225d389d7f5e32891", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -132,6 +132,17 @@ struct c_expr\n      The type of an enum constant is a plain integer type, but this\n      field will be the enum type.  */\n   tree original_type;\n+\n+  /* The source range of this expression.  This is redundant\n+     for node values that have locations, but not all node kinds\n+     have locations (e.g. constants, and references to params, locals,\n+     etc), so we stash a copy here.  */\n+  source_range src_range;\n+\n+  /* Access to the first and last locations within the source spelling\n+     of this expression.  */\n+  location_t get_start () const { return src_range.m_start; }\n+  location_t get_finish () const { return src_range.m_finish; }\n };\n \n /* Type alias for struct c_expr. This allows to use the structure\n@@ -708,4 +719,12 @@ extern void pedwarn_c90 (location_t, int opt, const char *, ...)\n extern bool pedwarn_c99 (location_t, int opt, const char *, ...)\n     ATTRIBUTE_GCC_DIAG(3,4);\n \n+extern void\n+set_c_expr_source_range (c_expr *expr,\n+\t\t\t location_t start, location_t finish);\n+\n+extern void\n+set_c_expr_source_range (c_expr *expr,\n+\t\t\t source_range src_range);\n+\n #endif /* ! GCC_C_TREE_H */"}, {"sha": "4db9bbf1c3c183f6685a828b55801b06776f99a9", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -3460,6 +3460,12 @@ parser_build_unary_op (location_t loc, enum tree_code code, struct c_expr arg)\n     overflow_warning (loc, result.value);\n     }\n \n+  /* We are typically called when parsing a prefix token at LOC acting on\n+     ARG.  Reflect this by updating the source range of the result to\n+     start at LOC and end at the end of ARG.  */\n+  set_c_expr_source_range (&result,\n+\t\t\t   loc, arg.get_finish ());\n+\n   return result;\n }\n \n@@ -3497,6 +3503,10 @@ parser_build_binary_op (location_t location, enum tree_code code,\n   if (location != UNKNOWN_LOCATION)\n     protected_set_expr_location (result.value, location);\n \n+  set_c_expr_source_range (&result,\n+\t\t\t   arg1.get_start (),\n+\t\t\t   arg2.get_finish ());\n+\n   /* Check for cases such as x+y<<z which users are likely\n      to misinterpret.  */\n   if (warn_parentheses)"}, {"sha": "52f95a04131d19fd5074edfa2d48998ffabfd299", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -1,3 +1,7 @@\n+2015-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* error.c (pedwarn_cxx98): Pass line_table to rich_location ctor.\n+\n 2015-11-12  James Norris  <jnorris@codesourcery.com>\n \n \t* parser.c (cp_parser_oacc_declare): Remove unused."}, {"sha": "38548c72fe06feda5a21a0546ed309bf448f1d91", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -3673,7 +3673,7 @@ pedwarn_cxx98 (location_t location, int opt, const char *gmsgid, ...)\n   diagnostic_info diagnostic;\n   va_list ap;\n   bool ret;\n-  rich_location richloc (location);\n+  rich_location richloc (line_table, location);\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc,"}, {"sha": "b4d3a7d59ce2f59264590c2d58568da0ce2ba786", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -867,7 +867,7 @@ diagnostic_append_note (diagnostic_context *context,\n   diagnostic_info diagnostic;\n   va_list ap;\n   const char *saved_prefix;\n-  rich_location richloc (location);\n+  rich_location richloc (line_table, location);\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_NOTE);\n@@ -925,7 +925,7 @@ emit_diagnostic (diagnostic_t kind, location_t location, int opt,\n   diagnostic_info diagnostic;\n   va_list ap;\n   bool ret;\n-  rich_location richloc (location);\n+  rich_location richloc (line_table, location);\n \n   va_start (ap, gmsgid);\n   if (kind == DK_PERMERROR)\n@@ -952,7 +952,7 @@ inform (location_t location, const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n-  rich_location richloc (location);\n+  rich_location richloc (line_table, location);\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_NOTE);\n@@ -981,7 +981,7 @@ inform_n (location_t location, int n, const char *singular_gmsgid,\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n-  rich_location richloc (location);\n+  rich_location richloc (line_table, location);\n \n   va_start (ap, plural_gmsgid);\n   diagnostic_set_info_translated (&diagnostic,\n@@ -1000,7 +1000,7 @@ warning (int opt, const char *gmsgid, ...)\n   diagnostic_info diagnostic;\n   va_list ap;\n   bool ret;\n-  rich_location richloc (input_location);\n+  rich_location richloc (line_table, input_location);\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_WARNING);\n@@ -1021,7 +1021,7 @@ warning_at (location_t location, int opt, const char *gmsgid, ...)\n   diagnostic_info diagnostic;\n   va_list ap;\n   bool ret;\n-  rich_location richloc (location);\n+  rich_location richloc (line_table, location);\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_WARNING);\n@@ -1059,7 +1059,7 @@ warning_n (location_t location, int opt, int n, const char *singular_gmsgid,\n   diagnostic_info diagnostic;\n   va_list ap;\n   bool ret;\n-  rich_location richloc (location);\n+  rich_location richloc (line_table, location);\n \n   va_start (ap, plural_gmsgid);\n   diagnostic_set_info_translated (&diagnostic,\n@@ -1091,7 +1091,7 @@ pedwarn (location_t location, int opt, const char *gmsgid, ...)\n   diagnostic_info diagnostic;\n   va_list ap;\n   bool ret;\n-  rich_location richloc (location);\n+  rich_location richloc (line_table, location);\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc,  DK_PEDWARN);\n@@ -1114,7 +1114,7 @@ permerror (location_t location, const char *gmsgid, ...)\n   diagnostic_info diagnostic;\n   va_list ap;\n   bool ret;\n-  rich_location richloc (location);\n+  rich_location richloc (line_table, location);\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc,\n@@ -1150,7 +1150,7 @@ error (const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n-  rich_location richloc (input_location);\n+  rich_location richloc (line_table, input_location);\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_ERROR);\n@@ -1166,7 +1166,7 @@ error_n (location_t location, int n, const char *singular_gmsgid,\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n-  rich_location richloc (location);\n+  rich_location richloc (line_table, location);\n \n   va_start (ap, plural_gmsgid);\n   diagnostic_set_info_translated (&diagnostic,\n@@ -1182,7 +1182,7 @@ error_at (location_t loc, const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n-  rich_location richloc (loc);\n+  rich_location richloc (line_table, loc);\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_ERROR);\n@@ -1213,7 +1213,7 @@ sorry (const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n-  rich_location richloc (input_location);\n+  rich_location richloc (line_table, input_location);\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_SORRY);\n@@ -1237,7 +1237,7 @@ fatal_error (location_t loc, const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n-  rich_location richloc (loc);\n+  rich_location richloc (line_table, loc);\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_FATAL);\n@@ -1256,7 +1256,7 @@ internal_error (const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n-  rich_location richloc (input_location);\n+  rich_location richloc (line_table, input_location);\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_ICE);\n@@ -1274,7 +1274,7 @@ internal_error_no_backtrace (const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n-  rich_location richloc (input_location);\n+  rich_location richloc (line_table, input_location);\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_ICE_NOBT);\n@@ -1351,7 +1351,7 @@ real_abort (void)\n DEBUG_FUNCTION void\n source_range::debug (const char *msg) const\n {\n-  rich_location richloc (m_start);\n+  rich_location richloc (line_table, m_start);\n   richloc.add_range (m_start, m_finish, false);\n   inform_at_rich_loc (&richloc, \"%s\", msg);\n }"}, {"sha": "b2c1d9bcb05b4a887ec6a6d9c7f2b2ea08e783d7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -1,3 +1,13 @@\n+2015-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* error.c (gfc_warning): Pass line_table to rich_location ctor.\n+\t(gfc_warning_now_at): Likewise.\n+\t(gfc_warning_now): Likewise.\n+\t(gfc_error_now): Likewise.\n+\t(gfc_fatal_error): Likewise.\n+\t(gfc_error): Likewise.\n+\t(gfc_internal_error): Likewise.\n+\n 2015-11-12  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/68318"}, {"sha": "b4f70203078ca571bb0f329cbdf9bc8e7c05e0b9", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -773,7 +773,7 @@ gfc_warning (int opt, const char *gmsgid, va_list ap)\n   va_copy (argp, ap);\n \n   diagnostic_info diagnostic;\n-  rich_location rich_loc (UNKNOWN_LOCATION);\n+  rich_location rich_loc (line_table, UNKNOWN_LOCATION);\n   bool fatal_errors = global_dc->fatal_errors;\n   pretty_printer *pp = global_dc->printer;\n   output_buffer *tmp_buffer = pp->buffer;\n@@ -1120,7 +1120,7 @@ gfc_warning_now_at (location_t loc, int opt, const char *gmsgid, ...)\n {\n   va_list argp;\n   diagnostic_info diagnostic;\n-  rich_location rich_loc (loc);\n+  rich_location rich_loc (line_table, loc);\n   bool ret;\n \n   va_start (argp, gmsgid);\n@@ -1138,7 +1138,7 @@ gfc_warning_now (int opt, const char *gmsgid, ...)\n {\n   va_list argp;\n   diagnostic_info diagnostic;\n-  rich_location rich_loc (UNKNOWN_LOCATION);\n+  rich_location rich_loc (line_table, UNKNOWN_LOCATION);\n   bool ret;\n \n   va_start (argp, gmsgid);\n@@ -1158,7 +1158,7 @@ gfc_error_now (const char *gmsgid, ...)\n {\n   va_list argp;\n   diagnostic_info diagnostic;\n-  rich_location rich_loc (UNKNOWN_LOCATION);\n+  rich_location rich_loc (line_table, UNKNOWN_LOCATION);\n \n   error_buffer.flag = true;\n \n@@ -1176,7 +1176,7 @@ gfc_fatal_error (const char *gmsgid, ...)\n {\n   va_list argp;\n   diagnostic_info diagnostic;\n-  rich_location rich_loc (UNKNOWN_LOCATION);\n+  rich_location rich_loc (line_table, UNKNOWN_LOCATION);\n \n   va_start (argp, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &argp, &rich_loc, DK_FATAL);\n@@ -1242,7 +1242,7 @@ gfc_error (const char *gmsgid, va_list ap)\n     }\n \n   diagnostic_info diagnostic;\n-  rich_location richloc (UNKNOWN_LOCATION);\n+  rich_location richloc (line_table, UNKNOWN_LOCATION);\n   bool fatal_errors = global_dc->fatal_errors;\n   pretty_printer *pp = global_dc->printer;\n   output_buffer *tmp_buffer = pp->buffer;\n@@ -1288,7 +1288,7 @@ gfc_internal_error (const char *gmsgid, ...)\n {\n   va_list argp;\n   diagnostic_info diagnostic;\n-  rich_location rich_loc (UNKNOWN_LOCATION);\n+  rich_location rich_loc (line_table, UNKNOWN_LOCATION);\n \n   va_start (argp, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &argp, &rich_loc, DK_ICE);"}, {"sha": "b0ec47bc001f98a3b202f1e814759a8637d9e320", "filename": "gcc/gcc-rich-location.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fgcc-rich-location.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fgcc-rich-location.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc-rich-location.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -0,0 +1,86 @@\n+/* Implementation of gcc_rich_location class\n+   Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"hash-set.h\"\n+#include \"machmode.h\"\n+#include \"vec.h\"\n+#include \"double-int.h\"\n+#include \"input.h\"\n+#include \"alias.h\"\n+#include \"symtab.h\"\n+#include \"wide-int.h\"\n+#include \"inchash.h\"\n+#include \"tree-core.h\"\n+#include \"tree.h\"\n+#include \"diagnostic-core.h\"\n+#include \"gcc-rich-location.h\"\n+#include \"print-tree.h\"\n+#include \"pretty-print.h\"\n+#include \"intl.h\"\n+#include \"cpplib.h\"\n+#include \"diagnostic.h\"\n+\n+/* Extract any source range information from EXPR and write it\n+   to *R.  */\n+\n+static bool\n+get_range_for_expr (tree expr, location_range *r)\n+{\n+  if (EXPR_HAS_RANGE (expr))\n+    {\n+      source_range sr = EXPR_LOCATION_RANGE (expr);\n+\n+      /* Do we have meaningful data?  */\n+      if (sr.m_start && sr.m_finish)\n+\t{\n+\t  r->m_start = expand_location (sr.m_start);\n+\t  r->m_finish = expand_location (sr.m_finish);\n+\t  return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Add a range to the rich_location, covering expression EXPR. */\n+\n+void\n+gcc_rich_location::add_expr (tree expr)\n+{\n+  gcc_assert (expr);\n+\n+  location_range r;\n+  r.m_show_caret_p = false;\n+  if (get_range_for_expr (expr, &r))\n+    add_range (&r);\n+}\n+\n+/* If T is an expression, add a range for it to the rich_location.  */\n+\n+void\n+gcc_rich_location::maybe_add_expr (tree t)\n+{\n+  if (EXPR_P (t))\n+    add_expr (t);\n+}"}, {"sha": "2f9291df6f40dbbd625a3e1ad1a68b3108fcc519", "filename": "gcc/gcc-rich-location.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fgcc-rich-location.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fgcc-rich-location.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc-rich-location.h?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -0,0 +1,47 @@\n+/* Declarations relating to class gcc_rich_location\n+   Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_RICH_LOCATION_H\n+#define GCC_RICH_LOCATION_H\n+\n+/* A gcc_rich_location is libcpp's rich_location with additional\n+   helper methods for working with gcc's types.  */\n+class gcc_rich_location : public rich_location\n+{\n+ public:\n+  /* Constructors.  */\n+\n+  /* Constructing from a location.  */\n+  gcc_rich_location (source_location loc) :\n+    rich_location (line_table, loc) {}\n+\n+  /* Constructing from a source_range.  */\n+  gcc_rich_location (source_range src_range) :\n+    rich_location (src_range) {}\n+\n+\n+  /* Methods for adding ranges via gcc entities.  */\n+  void\n+  add_expr (tree expr);\n+\n+  void\n+  maybe_add_expr (tree t);\n+};\n+\n+#endif /* GCC_RICH_LOCATION_H */"}, {"sha": "9d74ed75a53a6ed2556bff16dee36ce4a1b99802", "filename": "gcc/genmatch.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -119,7 +119,7 @@ __attribute__((format (printf, 2, 3)))\n #endif\n fatal_at (const cpp_token *tk, const char *msg, ...)\n {\n-  rich_location richloc (tk->src_loc);\n+  rich_location richloc (line_table, tk->src_loc);\n   va_list ap;\n   va_start (ap, msg);\n   error_cb (NULL, CPP_DL_FATAL, 0, &richloc, msg, &ap);\n@@ -132,7 +132,7 @@ __attribute__((format (printf, 2, 3)))\n #endif\n fatal_at (source_location loc, const char *msg, ...)\n {\n-  rich_location richloc (loc);\n+  rich_location richloc (line_table, loc);\n   va_list ap;\n   va_start (ap, msg);\n   error_cb (NULL, CPP_DL_FATAL, 0, &richloc, msg, &ap);\n@@ -145,7 +145,7 @@ __attribute__((format (printf, 2, 3)))\n #endif\n warning_at (const cpp_token *tk, const char *msg, ...)\n {\n-  rich_location richloc (tk->src_loc);\n+  rich_location richloc (line_table, tk->src_loc);\n   va_list ap;\n   va_start (ap, msg);\n   error_cb (NULL, CPP_DL_WARNING, 0, &richloc, msg, &ap);\n@@ -158,7 +158,7 @@ __attribute__((format (printf, 2, 3)))\n #endif\n warning_at (source_location loc, const char *msg, ...)\n {\n-  rich_location richloc (loc);\n+  rich_location richloc (line_table, loc);\n   va_list ap;\n   va_start (ap, msg);\n   error_cb (NULL, CPP_DL_WARNING, 0, &richloc, msg, &ap);"}, {"sha": "6486dff03b7bfb113491314a7d3f9bfc93fe273a", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -1740,11 +1740,7 @@ gimple_block (const gimple *g)\n static inline void\n gimple_set_block (gimple *g, tree block)\n {\n-  if (block)\n-    g->location =\n-\tCOMBINE_LOCATION_DATA (line_table, g->location, block);\n-  else\n-    g->location = LOCATION_LOCUS (g->location);\n+  g->location = set_block (g->location, block);\n }\n \n "}, {"sha": "ce84f10037108a718595ab9c23c861d8973aa9dd", "filename": "gcc/input.c", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -887,6 +887,10 @@ dump_line_table_statistics (void)\n \t   STAT_LABEL (s.adhoc_table_size));\n   fprintf (stderr, \"Ad-hoc table entries used:           %5ld\\n\",\n \t   s.adhoc_table_entries_used);\n+  fprintf (stderr, \"optimized_ranges: %i\\n\",\n+\t   line_table->num_optimized_ranges);\n+  fprintf (stderr, \"unoptimized_ranges: %i\\n\",\n+\t   line_table->num_unoptimized_ranges);\n \n   fprintf (stderr, \"\\n\");\n }\n@@ -917,13 +921,14 @@ write_digit (FILE *stream, int digit)\n \n static void\n write_digit_row (FILE *stream, int indent,\n+\t\t const line_map_ordinary *map,\n \t\t source_location loc, int max_col, int divisor)\n {\n   fprintf (stream, \"%*c\", indent, ' ');\n   fprintf (stream, \"|\");\n   for (int column = 1; column < max_col; column++)\n     {\n-      source_location column_loc = loc + column;\n+      source_location column_loc = loc + (column << map->m_range_bits);\n       write_digit (stream, column_loc / divisor);\n     }\n   fprintf (stream, \"\\n\");\n@@ -977,14 +982,20 @@ dump_location_info (FILE *stream)\n       fprintf (stream, \"  file: %s\\n\", ORDINARY_MAP_FILE_NAME (map));\n       fprintf (stream, \"  starting at line: %i\\n\",\n \t       ORDINARY_MAP_STARTING_LINE_NUMBER (map));\n+      fprintf (stream, \"  column and range bits: %i\\n\",\n+\t       map->m_column_and_range_bits);\n       fprintf (stream, \"  column bits: %i\\n\",\n-\t       ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map));\n+\t       map->m_column_and_range_bits - map->m_range_bits);\n+      fprintf (stream, \"  range bits: %i\\n\",\n+\t       map->m_range_bits);\n \n       /* Render the span of source lines that this \"map\" covers.  */\n       for (source_location loc = MAP_START_LOCATION (map);\n \t   loc < end_location;\n-\t   loc++)\n+\t   loc += (1 << map->m_range_bits) )\n \t{\n+\t  gcc_assert (pure_location_p (line_table, loc) );\n+\n \t  expanded_location exploc\n \t    = linemap_expand_location (line_table, map, loc);\n \n@@ -1008,26 +1019,25 @@ dump_location_info (FILE *stream)\n \t\t Render the locations *within* the line, by underlining\n \t\t it, showing the source_location numeric values\n \t\t at each column.  */\n-\t      int max_col\n-\t\t= (1 << ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map)) - 1;\n+\t      int max_col = (1 << map->m_column_and_range_bits) - 1;\n \t      if (max_col > line_size)\n \t\tmax_col = line_size + 1;\n \n \t      int indent = 14 + strlen (exploc.file);\n \n \t      /* Thousands.  */\n \t      if (end_location > 999)\n-\t\twrite_digit_row (stream, indent, loc, max_col, 1000);\n+\t\twrite_digit_row (stream, indent, map, loc, max_col, 1000);\n \n \t      /* Hundreds.  */\n \t      if (end_location > 99)\n-\t\twrite_digit_row (stream, indent, loc, max_col, 100);\n+\t\twrite_digit_row (stream, indent, map, loc, max_col, 100);\n \n \t      /* Tens.  */\n-\t      write_digit_row (stream, indent, loc, max_col, 10);\n+\t      write_digit_row (stream, indent, map, loc, max_col, 10);\n \n \t      /* Units.  */\n-\t      write_digit_row (stream, indent, loc, max_col, 1);\n+\t      write_digit_row (stream, indent, map, loc, max_col, 1);\n \t    }\n \t}\n       fprintf (stream, \"\\n\");"}, {"sha": "cb0f1fd38f42fe4ddcd6c7c25b64f8572bc27d76", "filename": "gcc/print-tree.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -938,6 +938,27 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       expanded_location xloc = expand_location (EXPR_LOCATION (node));\n       indent_to (file, indent+4);\n       fprintf (file, \"%s:%d:%d\", xloc.file, xloc.line, xloc.column);\n+\n+      /* Print the range, if any */\n+      source_range r = EXPR_LOCATION_RANGE (node);\n+      if (r.m_start)\n+\t{\n+\t  xloc = expand_location (r.m_start);\n+\t  fprintf (file, \" start: %s:%d:%d\", xloc.file, xloc.line, xloc.column);\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \" start: unknown\");\n+\t}\n+      if (r.m_finish)\n+\t{\n+\t  xloc = expand_location (r.m_finish);\n+\t  fprintf (file, \" finish: %s:%d:%d\", xloc.file, xloc.line, xloc.column);\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \" finish: unknown\");\n+\t}\n     }\n \n   fprintf (file, \">\");"}, {"sha": "088bb8a89627f7a4a8f7153aa1ed0152fde16704", "filename": "gcc/rtl-error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Frtl-error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Frtl-error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-error.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -67,7 +67,7 @@ diagnostic_for_asm (const rtx_insn *insn, const char *msg, va_list *args_ptr,\n \t\t    diagnostic_t kind)\n {\n   diagnostic_info diagnostic;\n-  rich_location richloc (location_for_asm (insn));\n+  rich_location richloc (line_table, location_for_asm (insn));\n \n   diagnostic_set_info (&diagnostic, msg, args_ptr,\n \t\t       &richloc, kind);"}, {"sha": "3124504a042682cf136c737c5ef9ea80b1ccc1d8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -1,3 +1,22 @@\n+2015-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/diagnostic-token-ranges.c: New file.\n+\t* gcc.dg/diagnostic-tree-expr-ranges-2.c: New file.\n+\t* gcc.dg/plugin/diagnostic-test-expressions-1.c: New file.\n+\t* gcc.dg/plugin/diagnostic-test-show-trees-1.c: New file.\n+\t* gcc.dg/plugin/diagnostic_plugin_show_trees.c: New file.\n+\t* gcc.dg/plugin/diagnostic_plugin_test_show_locus.c (get_loc): Add\n+\tline_table param when calling\n+\tlinemap_position_for_line_and_column.\n+\t(test_show_locus): Pass line_table to rich_location ctors.\n+\t(plugin_init): Remove setting of global_dc->colorize_source_p.\n+\t* gcc.dg/plugin/diagnostic_plugin_test_tree_expression_range.c:\n+\tNew file.\n+\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Add\n+\tdiagnostic_plugin_test_tree_expression_range.c,\n+\tdiagnostic-test-expressions-1.c, diagnostic_plugin_show_trees.c,\n+\tand diagnostic-test-show-trees-1.c.\n+\n 2015-11-13  Alan Lawrence  <alan.lawrence@arm.com>\n \n \tPR tree-optimization/67682"}, {"sha": "ac969e30d94963d70881a1d60c32c98a6ab3443c", "filename": "gcc/testsuite/gcc.dg/diagnostic-token-ranges.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftestsuite%2Fgcc.dg%2Fdiagnostic-token-ranges.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftestsuite%2Fgcc.dg%2Fdiagnostic-token-ranges.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdiagnostic-token-ranges.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -0,0 +1,120 @@\n+/* { dg-options \"-fdiagnostics-show-caret -Wc++-compat\" } */\n+\n+/* Verify that various diagnostics show source code ranges.  */\n+\n+/* These ones merely use token ranges; they don't use tree ranges.  */\n+\n+void undeclared_identifier (void)\n+{\n+  name; /* { dg-error \"'name' undeclared\" } */\n+/*\n+{ dg-begin-multiline-output \"\" }\n+   name;\n+   ^~~~\n+{ dg-end-multiline-output \"\" }\n+*/\n+}\n+\n+void unknown_type_name (void)\n+{\n+  foo bar; /* { dg-error \"unknown type name 'foo'\" } */\n+/*\n+{ dg-begin-multiline-output \"\" }\n+   foo bar;\n+   ^~~\n+{ dg-end-multiline-output \"\" }\n+*/\n+\n+  qux *baz; /* { dg-error \"unknown type name 'qux'\" } */\n+/*\n+{ dg-begin-multiline-output \"\" }\n+   qux *baz;\n+   ^~~\n+{ dg-end-multiline-output \"\" }\n+*/\n+}\n+\n+void test_identifier_conflicts_with_cplusplus (void)\n+{\n+  int new; /* { dg-warning \"identifier 'new' conflicts with\" } */\n+/*\n+{ dg-begin-multiline-output \"\" }\n+   int new;\n+       ^~~\n+{ dg-end-multiline-output \"\" }\n+*/\n+}\n+\n+extern void\n+bogus_varargs (...); /* { dg-error \"ISO C requires a named argument before '...'\" } */\n+/*\n+{ dg-begin-multiline-output \"\" }\n+ bogus_varargs (...);\n+                ^~~\n+{ dg-end-multiline-output \"\" }\n+*/\n+\n+extern void\n+foo (unknown_type param); /* { dg-error \"unknown type name 'unknown_type'\" } */\n+/*\n+{ dg-begin-multiline-output \"\" }\n+ foo (unknown_type param);\n+      ^~~~~~~~~~~~\n+{ dg-end-multiline-output \"\" }\n+*/\n+\n+void wide_string_literal_in_asm (void)\n+{\n+  asm (L\"nop\"); /* { dg-error \"wide string literal in 'asm'\" } */\n+/*\n+{ dg-begin-multiline-output \"\" }\n+   asm (L\"nop\");\n+        ^~~~~~\n+{ dg-end-multiline-output \"\" }\n+*/\n+}\n+\n+void break_and_continue_in_wrong_places (void)\n+{\n+  if (0)\n+    break; /* { dg-error \"break statement not within loop or switch\" } */\n+/* { dg-begin-multiline-output \"\" }\n+     break;\n+     ^~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  if (1)\n+    ;\n+  else\n+    continue; /* { dg-error \"continue statement not within a loop\" } */\n+/* { dg-begin-multiline-output \"\" }\n+     continue;\n+     ^~~~~~~~\n+    { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Various examples of bad type decls.  */\n+\n+int float bogus; /* { dg-error \"two or more data types in declaration specifiers\" } */\n+/* { dg-begin-multiline-output \"\" }\n+ int float bogus;\n+     ^~~~~\n+    { dg-end-multiline-output \"\" } */\n+\n+long long long bogus2; /* { dg-error \"'long long long' is too long for GCC\" } */\n+/* { dg-begin-multiline-output \"\" }\n+ long long long bogus2;\n+           ^~~~\n+    { dg-end-multiline-output \"\" } */\n+\n+long short bogus3; /* { dg-error \"both 'long' and 'short' in declaration specifiers\" } */\n+/* { dg-begin-multiline-output \"\" }\n+ long short bogus3;\n+      ^~~~~\n+    { dg-end-multiline-output \"\" } */\n+\n+signed unsigned bogus4; /* { dg-error \"both 'signed' and 'unsigned' in declaration specifiers\" } */\n+/* { dg-begin-multiline-output \"\" }\n+ signed unsigned bogus4;\n+        ^~~~~~~~\n+    { dg-end-multiline-output \"\" } */"}, {"sha": "302e233a04acccf20dd25ffd92f0345614e81716", "filename": "gcc/testsuite/gcc.dg/diagnostic-tree-expr-ranges-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftestsuite%2Fgcc.dg%2Fdiagnostic-tree-expr-ranges-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftestsuite%2Fgcc.dg%2Fdiagnostic-tree-expr-ranges-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdiagnostic-tree-expr-ranges-2.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -fdiagnostics-show-caret\" } */\n+\n+int test_uninit_1 (void)\n+{\n+  int result;\n+  return result;  /* { dg-warning \"uninitialized\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   return result;\n+          ^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+int test_uninit_2 (void)\n+{\n+  int result;\n+  result += 3; /* { dg-warning \"uninitialized\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   result += 3;\n+   ~~~~~~~^~~~\n+   { dg-end-multiline-output \"\" } */\n+  return result;\n+}"}, {"sha": "5485aafec01f470af138d0d82a1647443bd789de", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-expressions-1.c", "status": "added", "additions": 422, "deletions": 0, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-expressions-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-expressions-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-expressions-1.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -0,0 +1,422 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdiagnostics-show-caret\" } */\n+\n+/* This is a collection of unittests to verify that we're correctly\n+   capturing the source code ranges of various kinds of expression.\n+\n+   It uses the various \"diagnostic_test_*_expression_range_plugin\"\n+   plugins which handles \"__emit_expression_range\" by generating a warning\n+   at the given source range of the input argument.  Each of the\n+   different plugins do this at a different phase of the internal\n+   representation (tree, gimple, etc), so we can verify that the\n+   source code range information is valid at each phase.\n+\n+   We want to accept an expression of any type.  To do this in C, we\n+   use variadic arguments, but C requires at least one argument before\n+   the ellipsis, so we have a dummy one.  */\n+\n+extern void __emit_expression_range (int dummy, ...);\n+\n+int global;\n+\n+void test_parentheses (int a, int b)\n+{\n+  __emit_expression_range (0, (a + b) ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, (a + b) );\n+                               ~~~^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, (a + b) * (a - b) ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, (a + b) * (a - b) );\n+                               ~~~~~~~~^~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, !(a && b) ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, !(a && b) );\n+                               ^~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Postfix expressions.  ************************************************/\n+\n+void test_array_reference (int *arr)\n+{\n+  __emit_expression_range (0, arr[100] ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, arr[100] );\n+                               ~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+int test_function_call (int p, int q, int r)\n+{\n+  __emit_expression_range (0, test_function_call (p, q, r) ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, test_function_call (p, q, r) );\n+                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  return 0;\n+}\n+\n+struct test_struct\n+{\n+  int field;\n+};\n+\n+int test_structure_references (struct test_struct *ptr)\n+{\n+  struct test_struct local;\n+  local.field = 42;\n+\n+  __emit_expression_range (0, local.field ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, local.field );\n+                               ~~~~~^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, ptr->field ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, ptr->field );\n+                               ~~~^~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+int test_postfix_incdec (int i)\n+{\n+  __emit_expression_range (0, i++ ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, i++ );\n+                               ~^~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, i-- ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, i-- );\n+                               ~^~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Unary operators.  ****************************************************/\n+\n+int test_prefix_incdec (int i)\n+{\n+  __emit_expression_range (0, ++i ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, ++i );\n+                               ^~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, --i ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, --i );\n+                               ^~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_address_operator (void)\n+{\n+  __emit_expression_range (0, &global ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, &global );\n+                               ^~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_indirection (int *ptr)\n+{\n+  __emit_expression_range (0, *ptr ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, *ptr );\n+                               ^~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_unary_minus (int i)\n+{\n+  __emit_expression_range (0, -i ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, -i );\n+                               ^~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_ones_complement (int i)\n+{\n+  __emit_expression_range (0, ~i ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, ~i );\n+                               ^~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_logical_negation (int flag)\n+{\n+  __emit_expression_range (0, !flag ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, !flag );\n+                               ^~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Casts.  ****************************************************/\n+\n+void test_cast (void *ptr)\n+{\n+  __emit_expression_range (0, (int *)ptr ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, (int *)ptr );\n+                               ^~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+}\n+\n+/* Binary operators.  *******************************************/\n+\n+void test_multiplicative_operators (int lhs, int rhs)\n+{\n+  __emit_expression_range (0, lhs * rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs * rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs / rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs / rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs % rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs % rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_additive_operators (int lhs, int rhs)\n+{\n+  __emit_expression_range (0, lhs + rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs + rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs - rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs - rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_shift_operators (int lhs, int rhs)\n+{\n+  __emit_expression_range (0, lhs << rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs << rhs );\n+                               ~~~~^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs >> rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs >> rhs );\n+                               ~~~~^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_relational_operators (int lhs, int rhs)\n+{\n+  __emit_expression_range (0, lhs < rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs < rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs > rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs > rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs <= rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs <= rhs );\n+                               ~~~~^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs >= rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs >= rhs );\n+                               ~~~~^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_equality_operators (int lhs, int rhs)\n+{\n+  __emit_expression_range (0, lhs == rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs == rhs );\n+                               ~~~~^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs != rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs != rhs );\n+                               ~~~~^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_bitwise_binary_operators (int lhs, int rhs)\n+{\n+  __emit_expression_range (0, lhs & rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs & rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs ^ rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs ^ rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs | rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs | rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_logical_operators (int lhs, int rhs)\n+{\n+  __emit_expression_range (0, lhs && rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs && rhs );\n+                               ~~~~^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs || rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs || rhs );\n+                               ~~~~^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Conditional operator.  *******************************************/\n+\n+void test_conditional_operators (int flag, int on_true, int on_false)\n+{\n+  __emit_expression_range (0, flag ? on_true : on_false ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, flag ? on_true : on_false );\n+                               ~~~~~~~~~~~~~~~^~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Assignment expressions.  *******************************************/\n+\n+void test_assignment_expressions (int dest, int other)\n+{\n+  __emit_expression_range (0, dest = other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest = other );\n+                               ~~~~~^~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest *= other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest *= other );\n+                               ~~~~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest /= other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest /= other );\n+                               ~~~~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest %= other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest %= other );\n+                               ~~~~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest += other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest += other );\n+                               ~~~~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest -= other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest -= other );\n+                               ~~~~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest <<= other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest <<= other );\n+                               ~~~~~^~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest >>= other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest >>= other );\n+                               ~~~~~^~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest &= other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest &= other );\n+                               ~~~~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest ^= other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest ^= other );\n+                               ~~~~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest |= other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest |= other );\n+                               ~~~~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Comma operator.  *******************************************/\n+\n+void test_comma_operator (int a, int b)\n+{\n+  __emit_expression_range (0, (a++, a + b) ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, (a++, a + b) );\n+                               ~~~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Examples of non-trivial expressions.  ****************************/\n+\n+extern double sqrt (double x);\n+\n+void test_quadratic (double a, double b, double c)\n+{\n+  __emit_expression_range (0, b * b - 4 * a * c ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, b * b - 4 * a * c );\n+                               ~~~~~~^~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0,\n+     (-b + sqrt (b * b - 4 * a * c))\n+     / (2 * a)); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+      (-b + sqrt (b * b - 4 * a * c))\n+      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+      / (2 * a));\n+      ^~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+}"}, {"sha": "7473a07961f2d4811b8eadc0b5081330598545ed", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-show-trees-1.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-trees-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-trees-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-trees-1.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdiagnostics-show-caret\" } */\n+\n+/* This is an example file for use with\n+   diagnostic_plugin_show_trees.c.\n+\n+   The plugin handles \"__show_tree\" by recursively dumping\n+   the internal structure of the second input argument.\n+\n+   We want to accept an expression of any type.  To do this in C, we\n+   use variadic arguments, but C requires at least one argument before\n+   the ellipsis, so we have a dummy one.  */\n+\n+extern void __show_tree (int dummy, ...);\n+\n+extern double sqrt (double x);\n+\n+void test_quadratic (double a, double b, double c)\n+{\n+  __show_tree (0,\n+     (-b + sqrt (b * b - 4 * a * c))\n+     / (2 * a));\n+\n+/* { dg-begin-multiline-output \"\" }\n+      (-b + sqrt (b * b - 4 * a * c))\n+      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+      / (2 * a));\n+      ^~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* { dg-begin-multiline-output \"\" }\n+      (-b + sqrt (b * b - 4 * a * c))\n+      ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* { dg-begin-multiline-output \"\" }\n+      (-b + sqrt (b * b - 4 * a * c))\n+            ^~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* { dg-begin-multiline-output \"\" }\n+      (-b + sqrt (b * b - 4 * a * c))\n+                  ~~~~~~^~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* { dg-begin-multiline-output \"\" }\n+      (-b + sqrt (b * b - 4 * a * c))\n+                  ~~^~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* { dg-begin-multiline-output \"\" }\n+      (-b + sqrt (b * b - 4 * a * c))\n+                          ~~~~~~^~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* { dg-begin-multiline-output \"\" }\n+      (-b + sqrt (b * b - 4 * a * c))\n+                          ~~^~~\n+   { dg-end-multiline-output \"\" } */\n+\n+/* { dg-begin-multiline-output \"\" }\n+      / (2 * a));\n+        ~~~^~~~\n+   { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "5a911c17a4e025dec4b700a44db7c3e258919467", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic_plugin_show_trees.c", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_show_trees.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_show_trees.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_show_trees.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -0,0 +1,174 @@\n+/* This plugin recursively dumps the source-code location ranges of\n+   expressions, at the pre-gimplification tree stage.  */\n+/* { dg-options \"-O\" } */\n+\n+#include \"gcc-plugin.h\"\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"toplev.h\"\n+#include \"basic-block.h\"\n+#include \"hash-table.h\"\n+#include \"vec.h\"\n+#include \"ggc.h\"\n+#include \"basic-block.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"internal-fn.h\"\n+#include \"gimple-fold.h\"\n+#include \"tree-eh.h\"\n+#include \"gimple-expr.h\"\n+#include \"is-a.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree.h\"\n+#include \"tree-pass.h\"\n+#include \"intl.h\"\n+#include \"plugin-version.h\"\n+#include \"diagnostic.h\"\n+#include \"context.h\"\n+#include \"gcc-rich-location.h\"\n+#include \"print-tree.h\"\n+\n+/*\n+  Hack: fails with linker error:\n+./diagnostic_plugin_show_trees.so: undefined symbol: _ZN17gcc_rich_location8add_exprEP9tree_node\n+  since nothing in the tree is using gcc_rich_location::add_expr yet.\n+\n+  I've tried various workarounds (adding DEBUG_FUNCTION to the\n+  method, taking its address), but can't seem to fix it that way.\n+  So as a nasty workaround, the following material is copied&pasted\n+  from gcc-rich-location.c: */\n+\n+static bool\n+get_range_for_expr (tree expr, location_range *r)\n+{\n+  if (EXPR_HAS_RANGE (expr))\n+    {\n+      source_range sr = EXPR_LOCATION_RANGE (expr);\n+\n+      /* Do we have meaningful data?  */\n+      if (sr.m_start && sr.m_finish)\n+\t{\n+\t  r->m_start = expand_location (sr.m_start);\n+\t  r->m_finish = expand_location (sr.m_finish);\n+\t  return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Add a range to the rich_location, covering expression EXPR. */\n+\n+void\n+gcc_rich_location::add_expr (tree expr)\n+{\n+  gcc_assert (expr);\n+\n+  location_range r;\n+  r.m_show_caret_p = false;\n+  if (get_range_for_expr (expr, &r))\n+    add_range (&r);\n+}\n+\n+/* FIXME: end of material taken from gcc-rich-location.c */\n+\n+int plugin_is_GPL_compatible;\n+\n+static void\n+show_tree (tree node)\n+{\n+  if (!CAN_HAVE_RANGE_P (node))\n+    return;\n+\n+  gcc_rich_location richloc (EXPR_LOCATION (node));\n+  richloc.add_expr (node);\n+\n+  if (richloc.get_num_locations () < 2)\n+    {\n+      error_at_rich_loc (&richloc, \"range not found\");\n+      return;\n+    }\n+\n+  enum tree_code code = TREE_CODE (node);\n+\n+  location_range *range = richloc.get_range (1);\n+  inform_at_rich_loc (&richloc,\n+\t\t      \"%s at range %i:%i-%i:%i\",\n+\t\t      get_tree_code_name (code),\n+\t\t      range->m_start.line,\n+\t\t      range->m_start.column,\n+\t\t      range->m_finish.line,\n+\t\t      range->m_finish.column);\n+\n+  /* Recurse.  */\n+  int min_idx = 0;\n+  int max_idx = TREE_OPERAND_LENGTH (node);\n+  switch (code)\n+    {\n+    case CALL_EXPR:\n+      min_idx = 3;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  for (int i = min_idx; i < max_idx; i++)\n+    show_tree (TREE_OPERAND (node, i));\n+}\n+\n+tree\n+cb_walk_tree_fn (tree * tp, int * walk_subtrees,\n+\t\t void * data ATTRIBUTE_UNUSED)\n+{\n+  if (TREE_CODE (*tp) != CALL_EXPR)\n+    return NULL_TREE;\n+\n+  tree call_expr = *tp;\n+  tree fn = CALL_EXPR_FN (call_expr);\n+  if (TREE_CODE (fn) != ADDR_EXPR)\n+    return NULL_TREE;\n+  fn = TREE_OPERAND (fn, 0);\n+  if (TREE_CODE (fn) != FUNCTION_DECL)\n+    return NULL_TREE;\n+  if (strcmp (IDENTIFIER_POINTER (DECL_NAME (fn)), \"__show_tree\"))\n+    return NULL_TREE;\n+\n+  /* Get arg 1; print it! */\n+  tree arg = CALL_EXPR_ARG (call_expr, 1);\n+\n+  show_tree (arg);\n+\n+  return NULL_TREE;\n+}\n+\n+static void\n+callback (void *gcc_data, void *user_data)\n+{\n+  tree fndecl = (tree)gcc_data;\n+  walk_tree (&DECL_SAVED_TREE (fndecl), cb_walk_tree_fn, NULL, NULL);\n+}\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version *version)\n+{\n+  struct register_pass_info pass_info;\n+  const char *plugin_name = plugin_info->base_name;\n+  int argc = plugin_info->argc;\n+  struct plugin_argument *argv = plugin_info->argv;\n+\n+  if (!plugin_default_version_check (version, &gcc_version))\n+    return 1;\n+\n+  register_callback (plugin_name,\n+\t\t     PLUGIN_PRE_GENERICIZE,\n+\t\t     callback,\n+\t\t     NULL);\n+\n+  return 0;\n+}"}, {"sha": "158c6124a996fb15f6c310d83babda92cb5229e4", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic_plugin_test_show_locus.c", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -109,7 +109,8 @@ get_loc (unsigned int line_num, unsigned int col_num)\n \n   /* Convert from 0-based column numbers to 1-based column numbers.  */\n   source_location loc\n-    = linemap_position_for_line_and_column (line_map,\n+    = linemap_position_for_line_and_column (line_table,\n+\t\t\t\t\t    line_map,\n \t\t\t\t\t    line_num, col_num + 1);\n \n   return loc;\n@@ -163,7 +164,7 @@ test_show_locus (function *fun)\n   if (0 == strcmp (fnname, \"test_simple\"))\n     {\n       const int line = fnstart_line + 2;\n-      rich_location richloc (get_loc (line, 15));\n+      rich_location richloc (line_table, get_loc (line, 15));\n       richloc.add_range (get_loc (line, 10), get_loc (line, 14), false);\n       richloc.add_range (get_loc (line, 16), get_loc (line, 16), false);\n       warning_at_rich_loc (&richloc, 0, \"test\");\n@@ -172,7 +173,7 @@ test_show_locus (function *fun)\n   if (0 == strcmp (fnname, \"test_simple_2\"))\n     {\n       const int line = fnstart_line + 2;\n-      rich_location richloc (get_loc (line, 24));\n+      rich_location richloc (line_table, get_loc (line, 24));\n       richloc.add_range (get_loc (line, 6),\n \t\t\t get_loc (line, 22), false);\n       richloc.add_range (get_loc (line, 26),\n@@ -183,7 +184,7 @@ test_show_locus (function *fun)\n   if (0 == strcmp (fnname, \"test_multiline\"))\n     {\n       const int line = fnstart_line + 2;\n-      rich_location richloc (get_loc (line + 1, 7));\n+      rich_location richloc (line_table, get_loc (line + 1, 7));\n       richloc.add_range (get_loc (line, 7),\n \t\t\t get_loc (line, 23), false);\n       richloc.add_range (get_loc (line + 1, 9),\n@@ -194,7 +195,7 @@ test_show_locus (function *fun)\n   if (0 == strcmp (fnname, \"test_many_lines\"))\n     {\n       const int line = fnstart_line + 2;\n-      rich_location richloc (get_loc (line + 5, 7));\n+      rich_location richloc (line_table, get_loc (line + 5, 7));\n       richloc.add_range (get_loc (line, 7),\n \t\t\t get_loc (line + 4, 65), false);\n       richloc.add_range (get_loc (line + 5, 9),\n@@ -223,7 +224,7 @@ test_show_locus (function *fun)\n       source_range src_range;\n       src_range.m_start = get_loc (line, 12);\n       src_range.m_finish = get_loc (line, 20);\n-      rich_location richloc (caret);\n+      rich_location richloc (line_table, caret);\n       richloc.set_range (0, src_range, true, false);\n       warning_at_rich_loc (&richloc, 0, \"test\");\n     }\n@@ -237,7 +238,7 @@ test_show_locus (function *fun)\n       source_range src_range;\n       src_range.m_start = get_loc (line, 90);\n       src_range.m_finish = get_loc (line, 98);\n-      rich_location richloc (caret);\n+      rich_location richloc (line_table, caret);\n       richloc.set_range (0, src_range, true, false);\n       warning_at_rich_loc (&richloc, 0, \"test\");\n     }\n@@ -248,7 +249,7 @@ test_show_locus (function *fun)\n       const int line = fnstart_line + 2;\n       location_t caret_a = get_loc (line, 7);\n       location_t caret_b = get_loc (line, 11);\n-      rich_location richloc (caret_a);\n+      rich_location richloc (line_table, caret_a);\n       richloc.add_range (caret_b, caret_b, true);\n       global_dc->caret_chars[0] = 'A';\n       global_dc->caret_chars[1] = 'B';\n@@ -269,7 +270,7 @@ test_show_locus (function *fun)\n       const int line = fnstart_line + 3;\n       location_t caret_a = get_loc (line, 5);\n       location_t caret_b = get_loc (line - 1, 19);\n-      rich_location richloc (caret_a);\n+      rich_location richloc (line_table, caret_a);\n       richloc.add_range (caret_b, caret_b, true);\n       global_dc->caret_chars[0] = '1';\n       global_dc->caret_chars[1] = '2';\n@@ -304,11 +305,6 @@ plugin_init (struct plugin_name_args *plugin_info,\n   if (!plugin_default_version_check (version, &gcc_version))\n     return 1;\n \n-  /* For now, tell the dc to expect ranges and thus to colorize the source\n-     lines, not just the carets/underlines.  This will be redundant\n-     once the C frontend generates ranges.  */\n-  global_dc->colorize_source_p = true;\n-\n   for (int i = 0; i < argc; i++)\n     {\n       if (0 == strcmp (argv[i].key, \"color\"))"}, {"sha": "89cc95acd9999e4f47b103912ebaf16a028540b2", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic_plugin_test_tree_expression_range.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_tree_expression_range.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_tree_expression_range.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_tree_expression_range.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -0,0 +1,98 @@\n+/* This plugin verifies the source-code location ranges of\n+   expressions, at the pre-gimplification tree stage.  */\n+/* { dg-options \"-O\" } */\n+\n+#include \"gcc-plugin.h\"\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"toplev.h\"\n+#include \"basic-block.h\"\n+#include \"hash-table.h\"\n+#include \"vec.h\"\n+#include \"ggc.h\"\n+#include \"basic-block.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"internal-fn.h\"\n+#include \"gimple-fold.h\"\n+#include \"tree-eh.h\"\n+#include \"gimple-expr.h\"\n+#include \"is-a.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree.h\"\n+#include \"tree-pass.h\"\n+#include \"intl.h\"\n+#include \"plugin-version.h\"\n+#include \"diagnostic.h\"\n+#include \"context.h\"\n+#include \"print-tree.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+static void\n+emit_warning (location_t loc)\n+{\n+  source_range src_range = get_range_from_loc (line_table, loc);\n+  warning_at (loc, 0,\n+\t      \"tree range %i:%i-%i:%i\",\n+\t      LOCATION_LINE (src_range.m_start),\n+\t      LOCATION_COLUMN (src_range.m_start),\n+\t      LOCATION_LINE (src_range.m_finish),\n+\t      LOCATION_COLUMN (src_range.m_finish));\n+}\n+\n+tree\n+cb_walk_tree_fn (tree * tp, int * walk_subtrees,\n+\t\t void * data ATTRIBUTE_UNUSED)\n+{\n+  if (TREE_CODE (*tp) != CALL_EXPR)\n+    return NULL_TREE;\n+\n+  tree call_expr = *tp;\n+  tree fn = CALL_EXPR_FN (call_expr);\n+  if (TREE_CODE (fn) != ADDR_EXPR)\n+    return NULL_TREE;\n+  fn = TREE_OPERAND (fn, 0);\n+  if (TREE_CODE (fn) != FUNCTION_DECL)\n+    return NULL_TREE;\n+  if (strcmp (IDENTIFIER_POINTER (DECL_NAME (fn)), \"__emit_expression_range\"))\n+    return NULL_TREE;\n+\n+  /* Get arg 1; print it! */\n+  tree arg = CALL_EXPR_ARG (call_expr, 1);\n+\n+  emit_warning (EXPR_LOCATION (arg));\n+\n+  return NULL_TREE;\n+}\n+\n+static void\n+callback (void *gcc_data, void *user_data)\n+{\n+  tree fndecl = (tree)gcc_data;\n+  walk_tree (&DECL_SAVED_TREE (fndecl), cb_walk_tree_fn, NULL, NULL);\n+}\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version *version)\n+{\n+  struct register_pass_info pass_info;\n+  const char *plugin_name = plugin_info->base_name;\n+  int argc = plugin_info->argc;\n+  struct plugin_argument *argv = plugin_info->argv;\n+\n+  if (!plugin_default_version_check (version, &gcc_version))\n+    return 1;\n+\n+  register_callback (plugin_name,\n+\t\t     PLUGIN_PRE_GENERICIZE,\n+\t\t     callback,\n+\t\t     NULL);\n+\n+  return 0;\n+}"}, {"sha": "06080cce8d26b00f95b61485222dbd4c7ba81405", "filename": "gcc/testsuite/gcc.dg/plugin/plugin.exp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -66,6 +66,10 @@ set plugin_test_list [list \\\n     { diagnostic_plugin_test_show_locus.c \\\n \t  diagnostic-test-show-locus-bw.c \\\n \t  diagnostic-test-show-locus-color.c } \\\n+    { diagnostic_plugin_test_tree_expression_range.c \\\n+\t  diagnostic-test-expressions-1.c } \\\n+    { diagnostic_plugin_show_trees.c \\\n+\t  diagnostic-test-show-trees-1.c } \\\n     { levenshtein_plugin.c levenshtein-test-1.c } \\\n ]\n "}, {"sha": "588d89dce8962576b9aaafe98512432789c54ea1", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -1130,6 +1130,7 @@ general_init (const char *argv0, bool init_signals)\n   linemap_init (line_table, BUILTINS_LOCATION);\n   line_table->reallocator = realloc_for_line_map;\n   line_table->round_alloc_size = ggc_round_alloc_size;\n+  line_table->default_range_bits = 5;\n   init_ttree ();\n \n   /* Initialize register usage now so switches may override.  */"}, {"sha": "0c624aa3f3ed0e49b8fec8158e7f703fbcbd96c1", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -6719,10 +6719,7 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n \t    continue;\n \t  if (d->orig_block == NULL_TREE || block == d->orig_block)\n \t    {\n-\t      if (d->new_block == NULL_TREE)\n-\t\tlocus = LOCATION_LOCUS (locus);\n-\t      else\n-\t\tlocus = COMBINE_LOCATION_DATA (line_table, locus, d->new_block);\n+\t      locus = set_block (locus, d->new_block);\n \t      gimple_phi_arg_set_location (phi, i, locus);\n \t    }\n \t}\n@@ -6782,9 +6779,7 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n \ttree block = LOCATION_BLOCK (e->goto_locus);\n \tif (d->orig_block == NULL_TREE\n \t    || block == d->orig_block)\n-\t  e->goto_locus = d->new_block ?\n-\t      COMBINE_LOCATION_DATA (line_table, e->goto_locus, d->new_block) :\n-\t      LOCATION_LOCUS (e->goto_locus);\n+\t  e->goto_locus = set_block (e->goto_locus, d->new_block);\n       }\n }\n "}, {"sha": "205c869b88e714bd71f1a35331e89dca88180abd", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -2348,10 +2348,7 @@ copy_phis_for_bb (basic_block bb, copy_body_data *id)\n \t\t  tree *n;\n \t\t  n = id->decl_map->get (LOCATION_BLOCK (locus));\n \t\t  gcc_assert (n);\n-\t\t  if (*n)\n-\t\t    locus = COMBINE_LOCATION_DATA (line_table, locus, *n);\n-\t\t  else\n-\t\t    locus = LOCATION_LOCUS (locus);\n+\t\t  locus = set_block (locus, *n);\n \t\t}\n \t      else\n \t\tlocus = LOCATION_LOCUS (locus);"}, {"sha": "1d770c36a7bccc8afca2db7391d841fce312b550", "filename": "gcc/tree.c", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -11789,10 +11789,7 @@ tree_set_block (tree t, tree b)\n \n   if (IS_EXPR_CODE_CLASS (c))\n     {\n-      if (b)\n-\tt->exp.locus = COMBINE_LOCATION_DATA (line_table, t->exp.locus, b);\n-      else\n-\tt->exp.locus = LOCATION_LOCUS (t->exp.locus);\n+      t->exp.locus = set_block (t->exp.locus, b);\n     }\n   else\n     gcc_unreachable ();\n@@ -13813,5 +13810,60 @@ nonnull_arg_p (const_tree arg)\n   return false;\n }\n \n+/* Given location LOC, strip away any packed range information\n+   or ad-hoc information.  */\n+\n+static location_t\n+get_pure_location (location_t loc)\n+{\n+  if (IS_ADHOC_LOC (loc))\n+    loc\n+      = line_table->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n+\n+  if (loc >= LINEMAPS_MACRO_LOWEST_LOCATION (line_table))\n+    return loc;\n+\n+  if (loc < RESERVED_LOCATION_COUNT)\n+    return loc;\n+\n+  const line_map *map = linemap_lookup (line_table, loc);\n+  const line_map_ordinary *ordmap = linemap_check_ordinary (map);\n+\n+  return loc & ~((1 << ordmap->m_range_bits) - 1);\n+}\n+\n+/* Combine LOC and BLOCK to a combined adhoc loc, retaining any range\n+   information.  */\n+\n+location_t\n+set_block (location_t loc, tree block)\n+{\n+  location_t pure_loc = get_pure_location (loc);\n+  source_range src_range = get_range_from_loc (line_table, loc);\n+  return COMBINE_LOCATION_DATA (line_table, pure_loc, src_range, block);\n+}\n+\n+void\n+set_source_range (tree expr, location_t start, location_t finish)\n+{\n+  source_range src_range;\n+  src_range.m_start = start;\n+  src_range.m_finish = finish;\n+  set_source_range (expr, src_range);\n+}\n+\n+void\n+set_source_range (tree expr, source_range src_range)\n+{\n+  if (!EXPR_P (expr))\n+    return;\n+\n+  location_t pure_loc = get_pure_location (EXPR_LOCATION (expr));\n+  location_t adhoc = COMBINE_LOCATION_DATA (line_table,\n+\t\t\t\t\t    pure_loc,\n+\t\t\t\t\t    src_range,\n+\t\t\t\t\t    NULL);\n+  SET_EXPR_LOCATION (expr, adhoc);\n+}\n \n #include \"gt-tree.h\""}, {"sha": "0b9c3b915dcaa0bae5b7d5f2c430dcf6769584a1", "filename": "gcc/tree.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -1096,10 +1096,25 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n #define EXPR_FILENAME(NODE) LOCATION_FILE (EXPR_CHECK ((NODE))->exp.locus)\n #define EXPR_LINENO(NODE) LOCATION_LINE (EXPR_CHECK (NODE)->exp.locus)\n \n+#define CAN_HAVE_RANGE_P(NODE) (CAN_HAVE_LOCATION_P (NODE))\n+#define EXPR_LOCATION_RANGE(NODE) (get_expr_source_range (EXPR_CHECK ((NODE))))\n+\n+#define EXPR_HAS_RANGE(NODE) \\\n+    (CAN_HAVE_RANGE_P (NODE) \\\n+     ? EXPR_LOCATION_RANGE (NODE).m_start != UNKNOWN_LOCATION \\\n+     : false)\n+\n /* True if a tree is an expression or statement that can have a\n    location.  */\n #define CAN_HAVE_LOCATION_P(NODE) ((NODE) && EXPR_P (NODE))\n \n+static inline source_range\n+get_expr_source_range (tree expr)\n+{\n+  location_t loc = EXPR_LOCATION (expr);\n+  return get_range_from_loc (line_table, loc);\n+}\n+\n extern void protected_set_expr_location (tree, location_t);\n \n /* In a TARGET_EXPR node.  */\n@@ -2172,6 +2187,9 @@ extern machine_mode element_mode (const_tree t);\n #define DECL_IS_BUILTIN(DECL) \\\n   (LOCATION_LOCUS (DECL_SOURCE_LOCATION (DECL)) <= BUILTINS_LOCATION)\n \n+#define DECL_LOCATION_RANGE(NODE) \\\n+  (get_decl_source_range (DECL_MINIMAL_CHECK (NODE)))\n+\n /*  For FIELD_DECLs, this is the RECORD_TYPE, UNION_TYPE, or\n     QUAL_UNION_TYPE node that the field is a member of.  For VAR_DECL,\n     PARM_DECL, FUNCTION_DECL, LABEL_DECL, RESULT_DECL, and CONST_DECL\n@@ -5277,10 +5295,25 @@ type_with_alias_set_p (const_tree t)\n   return false;\n }\n \n+extern location_t set_block (location_t loc, tree block);\n+\n extern void gt_ggc_mx (tree &);\n extern void gt_pch_nx (tree &);\n extern void gt_pch_nx (tree &, gt_pointer_operator, void *);\n \n extern bool nonnull_arg_p (const_tree);\n \n+extern void\n+set_source_range (tree expr, location_t start, location_t finish);\n+\n+extern void\n+set_source_range (tree expr, source_range src_range);\n+\n+static inline source_range\n+get_decl_source_range (tree decl)\n+{\n+  location_t loc = DECL_SOURCE_LOCATION (decl);\n+  return get_range_from_loc (line_table, loc);\n+}\n+\n #endif  /* GCC_TREE_H  */"}, {"sha": "5a87c1791c4bcb5e70c190306988cd53e9420e7b", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -1,3 +1,85 @@\n+2015-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* errors.c (cpp_diagnostic): Pass pfile->line_table to\n+\trich_location ctor.\n+\t(cpp_diagnostic_with_line): Likewise.\n+\t* include/cpplib.h (struct cpp_token): Update comment for src_loc\n+\tto indicate that the range of the token is \"baked into\" the\n+\tsource_location.\n+\t* include/line-map.h (source_location): Update the descriptive\n+\tcomment to reflect the packing scheme for short ranges, adding\n+\tworked examples of location encoding.\n+\t(struct line_map_ordinary): Drop field \"column_bits\" in favor\n+\tof field \"m_column_and_range_bits\"; add field \"m_range_bits\".\n+\t(ORDINARY_MAP_NUMBER_OF_COLUMN_BITS): Delete.\n+\t(location_adhoc_data): Add source_range field.\n+\t(struct line_maps): Add fields \"default_range_bits\",\n+\t\"num_optimized_ranges\" and \"num_unoptimized_ranges\".\n+\t(get_combined_adhoc_loc): Add source_range param.\n+\t(get_range_from_loc): New declaration.\n+\t(pure_location_p): New prototype.\n+\t(COMBINE_LOCATION_DATA):  Add source_range param.\n+\t(SOURCE_LINE): Update for renaming of column_bits.\n+\t(SOURCE_COLUMN): Likewise.  Shift the column right by the map's\n+\trange_bits.\n+\t(LAST_SOURCE_LINE_LOCATION): Update for renaming of column_bits.\n+\t(linemap_position_for_line_and_column): Add line_maps * params.\n+\t(rich_location::rich_location): Likewise.\n+\t* lex.c (_cpp_lex_direct): Capture the range of the token, baking\n+\tit into token->src_loc via a call to COMBINE_LOCATION_DATA.\n+\t* line-map.c (LINE_MAP_MAX_COLUMN_NUMBER): Reduce from 1U << 17 to\n+\t1U << 12.\n+\t(location_adhoc_data_hash): Add the src_range into\n+\tthe hash value.\n+\t(location_adhoc_data_eq): Require equality of the src_range\n+\tvalues.\n+\t(can_be_stored_compactly_p): New function.\n+\t(get_combined_adhoc_loc): Add src_range param, and store it,\n+\tvia a bit-packing scheme for short ranges, otherwise within the\n+\tlookaside table.  Remove the requirement that data is non-NULL.\n+\t(get_range_from_adhoc_loc): New function.\n+\t(get_range_from_loc): New function.\n+\t(pure_location_p): New function.\n+\t(linemap_add): Ensure that start_location has zero for the\n+\trange_bits, unless we're past LINE_MAP_MAX_LOCATION_WITH_COLS.\n+\tInitialize range_bits to zero.  Assert that the start_location\n+\tis \"pure\".\n+\t(linemap_line_start): Assert that the\n+\tcolumn_and_range_bits >= range_bits.\n+\tUpdate determinination of whether we need to start a new map\n+\tusing the effective column bits, without the range bits.\n+\tUse the set's default_range_bits in new maps, apart from\n+\tthose with column_bits == 0, which should also have 0 range_bits.\n+\tIncrease the column bits for new maps by the range bits.\n+\tWhen adding lines to an existing map, use set->highest_line\n+\tdirectly rather than offsetting highest by SOURCE_COLUMN.\n+\tAdd assertions to sanity-check the return value.\n+\t(linemap_position_for_column): Offset to_column by range_bits.\n+\tUpdate set->highest_location if necessary.\n+\t(linemap_position_for_line_and_column): Add line_maps * param.\n+\tUpdate the calculation to offset the column by range_bits, and\n+\tconditionalize it on being <= LINE_MAP_MAX_LOCATION_WITH_COLS.\n+\tBound it by LINEMAPS_MACRO_LOWEST_LOCATION.  Update\n+\tset->highest_location if necessary.\n+\t(linemap_position_for_loc_and_offset): Handle ad-hoc locations;\n+\tpass \"set\" to linemap_position_for_line_and_column.\n+\t(linemap_macro_map_loc_unwind_toward_spelling): Add line_maps\n+\tparam.  Handle ad-hoc locations.\n+\t(linemap_location_in_system_header_p): Pass on \"set\" to call to\n+\tlinemap_macro_map_loc_unwind_toward_spelling.\n+\t(linemap_macro_loc_to_spelling_point): Retain ad-hoc locations.\n+\tPass on \"set\" to call to\n+\tlinemap_macro_map_loc_unwind_toward_spelling.\n+\t(linemap_resolve_location): Retain ad-hoc locations.  Pass on\n+\t\"set\" to call to linemap_macro_map_loc_unwind_toward_spelling.\n+\t(linemap_unwind_toward_expansion):  Pass on \"set\" to call to\n+\tlinemap_macro_map_loc_unwind_toward_spelling.\n+\t(linemap_expand_location): Extract the data pointer before\n+\textracting the location.\n+\t(rich_location::rich_location): Add line_maps param; use it to\n+\textract the range from the source_location.\n+\t* location-example.txt: Regenerate, showing new representation.\n+\n 2015-11-06  David Malcolm  <dmalcolm@redhat.com>\n \n \t* errors.c (cpp_diagnostic): Update for change in signature"}, {"sha": "8790e10f5c888f73c48c828d28b75dcd80db4a8a", "filename": "libcpp/errors.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/libcpp%2Ferrors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/libcpp%2Ferrors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ferrors.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -57,7 +57,7 @@ cpp_diagnostic (cpp_reader * pfile, int level, int reason,\n \n   if (!pfile->cb.error)\n     abort ();\n-  rich_location richloc (src_loc);\n+  rich_location richloc (pfile->line_table, src_loc);\n   ret = pfile->cb.error (pfile, level, reason, &richloc, _(msgid), ap);\n \n   return ret;\n@@ -140,7 +140,7 @@ cpp_diagnostic_with_line (cpp_reader * pfile, int level, int reason,\n   \n   if (!pfile->cb.error)\n     abort ();\n-  rich_location richloc (src_loc);\n+  rich_location richloc (pfile->line_table, src_loc);\n   richloc.override_column (column);\n   ret = pfile->cb.error (pfile, level, reason, &richloc, _(msgid), ap);\n "}, {"sha": "f5c2a21e95245ad524da83308f4b34b6bbac9285", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -237,7 +237,8 @@ struct GTY(()) cpp_identifier {\n /* A preprocessing token.  This has been carefully packed and should\n    occupy 16 bytes on 32-bit hosts and 24 bytes on 64-bit hosts.  */\n struct GTY(()) cpp_token {\n-  source_location src_loc;\t/* Location of first char of token.  */\n+  source_location src_loc;\t/* Location of first char of token,\n+\t\t\t\t   together with range of full token.  */\n   ENUM_BITFIELD(cpp_ttype) type : CHAR_BIT;  /* token type */\n   unsigned short flags;\t\t/* flags - see above */\n "}, {"sha": "e7608f1e468f54d784cac4cea6c02cf76454329e", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 188, "deletions": 31, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -47,7 +47,8 @@ enum lc_reason\n typedef unsigned int linenum_type;\n \n /* The typedef \"source_location\" is a key within the location database,\n-   identifying a source location or macro expansion.\n+   identifying a source location or macro expansion, along with range\n+   information, and (optionally) a pointer for use by gcc.\n \n    This key only has meaning in relation to a line_maps instance.  Within\n    gcc there is a single line_maps instance: \"line_table\", declared in\n@@ -69,13 +70,48 @@ typedef unsigned int linenum_type;\n              |  ordmap[0]->start_location)   | first line in ordmap 0\n   -----------+-------------------------------+-------------------------------\n              | ordmap[1]->start_location     | First line in ordmap 1\n-             | ordmap[1]->start_location+1   | First column in that line\n-             | ordmap[1]->start_location+2   | 2nd column in that line\n-             |                               | Subsequent lines are offset by\n-             |                               | (1 << column_bits),\n-             |                               | e.g. 128 for 7 bits, with a\n-             |                               | column value of 0 representing\n-             |                               | \"the whole line\".\n+             | ordmap[1]->start_location+32  | First column in that line\n+             |   (assuming range_bits == 5)  |\n+             | ordmap[1]->start_location+64  | 2nd column in that line\n+             | ordmap[1]->start_location+4096| Second line in ordmap 1\n+             |   (assuming column_bits == 12)\n+             |\n+             |   Subsequent lines are offset by (1 << column_bits),\n+             |   e.g. 4096 for 12 bits, with a column value of 0 representing\n+             |   \"the whole line\".\n+             |\n+             |   Within a line, the low \"range_bits\" (typically 5) are used for\n+             |   storing short ranges, so that there's an offset of\n+             |     (1 << range_bits) between individual columns within a line,\n+             |   typically 32.\n+             |   The low range_bits store the offset of the end point from the\n+             |   start point, and the start point is found by masking away\n+             |   the range bits.\n+             |\n+             |   For example:\n+             |      ordmap[1]->start_location+64    \"2nd column in that line\"\n+             |   above means a caret at that location, with a range\n+             |   starting and finishing at the same place (the range bits\n+             |   are 0), a range of length 1.\n+             |\n+             |   By contrast:\n+             |      ordmap[1]->start_location+68\n+             |   has range bits 0x4, meaning a caret with a range starting at\n+             |   that location, but with endpoint 4 columns further on: a range\n+             |   of length 5.\n+             |\n+             |   Ranges that have caret != start, or have an endpoint too\n+             |   far away to fit in range_bits are instead stored as ad-hoc\n+             |   locations.  Hence for range_bits == 5 we can compactly store\n+             |   tokens of length <= 32 without needing to use the ad-hoc\n+             |   table.\n+             |\n+             |   This packing scheme means we effectively have\n+             |     (column_bits - range_bits)\n+             |   of bits for the columns, typically (12 - 5) = 7, for 128\n+             |   columns; longer line widths are accomodated by starting a\n+             |   new ordmap with a higher column_bits.\n+             |\n              | ordmap[2]->start_location-1   | Final location in ordmap 1\n   -----------+-------------------------------+-------------------------------\n              | ordmap[2]->start_location     | First line in ordmap 2\n@@ -127,8 +163,101 @@ typedef unsigned int linenum_type;\n   0xffffffff | UINT_MAX                      |\n   -----------+-------------------------------+-------------------------------\n \n-  To see how this works in practice, see the worked example in\n-  libcpp/location-example.txt.  */\n+   Examples of location encoding.\n+\n+   Packed ranges\n+   =============\n+\n+   Consider encoding the location of a token \"foo\", seen underlined here\n+   on line 523, within an ordinary line_map that starts at line 500:\n+\n+                 11111111112\n+        12345678901234567890\n+     522\n+     523   return foo + bar;\n+                  ^~~\n+     524\n+\n+   The location's caret and start are both at line 523, column 11; the\n+   location's finish is on the same line, at column 13 (an offset of 2\n+   columns, for length 3).\n+\n+   Line 523 is offset 23 from the starting line of the ordinary line_map.\n+\n+   caret == start, and the offset of the finish fits within 5 bits, so\n+   this can be stored as a packed range.\n+\n+   This is encoded as:\n+      ordmap->start\n+         + (line_offset << ordmap->m_column_and_range_bits)\n+         + (column << ordmap->m_range_bits)\n+         + (range_offset);\n+   i.e. (for line offset 23, column 11, range offset 2):\n+      ordmap->start\n+         + (23 << 12)\n+         + (11 << 5)\n+         + 2;\n+   i.e.:\n+      ordmap->start + 0x17162\n+   assuming that the line_map uses the default of 7 bits for columns and\n+   5 bits for packed range (giving 12 bits for m_column_and_range_bits).\n+\n+\n+   \"Pure\" locations\n+   ================\n+\n+   These are a special case of the above, where\n+      caret == start == finish\n+   They are stored as packed ranges with offset == 0.\n+   For example, the location of the \"f\" of \"foo\" could be stored\n+   as above, but with range offset 0, giving:\n+      ordmap->start\n+         + (23 << 12)\n+         + (11 << 5)\n+         + 0;\n+   i.e.:\n+      ordmap->start + 0x17160\n+\n+\n+   Unoptimized ranges\n+   ==================\n+\n+   Consider encoding the location of the binary expression\n+   below:\n+\n+                 11111111112\n+        12345678901234567890\n+     521\n+     523   return foo + bar;\n+                  ~~~~^~~~~\n+     523\n+\n+   The location's caret is at the \"+\", line 523 column 15, but starts\n+   earlier, at the \"f\" of \"foo\" at column 11.  The finish is at the \"r\"\n+   of \"bar\" at column 19.\n+\n+   This can't be stored as a packed range since start != caret.\n+   Hence it is stored as an ad-hoc location e.g. 0x80000003.\n+\n+   Stripping off the top bit gives us an index into the ad-hoc\n+   lookaside table:\n+\n+     line_table->location_adhoc_data_map.data[0x3]\n+\n+   from which the caret, start and finish can be looked up,\n+   encoded as \"pure\" locations:\n+\n+     start  == ordmap->start + (23 << 12) + (11 << 5)\n+            == ordmap->start + 0x17160  (as above; the \"f\" of \"foo\")\n+\n+     caret  == ordmap->start + (23 << 12) + (15 << 5)\n+            == ordmap->start + 0x171e0\n+\n+     finish == ordmap->start + (23 << 12) + (19 << 5)\n+            == ordmap->start + 0x17260\n+\n+   To further see how source_location works in practice, see the\n+   worked example in libcpp/location-example.txt.  */\n typedef unsigned int source_location;\n \n /* A range of source locations.\n@@ -217,8 +346,9 @@ struct GTY((tag (\"0\"), desc (\"%h.reason == LC_ENTER_MACRO ? 2 : 1\"))) line_map {\n    \n    Physical source file TO_FILE at line TO_LINE at column 0 is represented\n    by the logical START_LOCATION.  TO_LINE+L at column C is represented by\n-   START_LOCATION+(L*(1<<column_bits))+C, as long as C<(1<<column_bits),\n-   and the result_location is less than the next line_map's start_location.\n+   START_LOCATION+(L*(1<<m_column_and_range_bits))+(C*1<<m_range_bits), as\n+   long as C<(1<<effective range bits), and the result_location is less than\n+   the next line_map's start_location.\n    (The top line is line 1 and the leftmost column is column 1; line/column 0\n    means \"entire file/line\" or \"unknown line/column\" or \"not applicable\".)\n \n@@ -238,8 +368,24 @@ struct GTY((tag (\"1\"))) line_map_ordinary : public line_map {\n      cpp_buffer.  */\n   unsigned char sysp;\n \n-  /* Number of the low-order source_location bits used for a column number.  */\n-  unsigned int column_bits : 8;\n+  /* Number of the low-order source_location bits used for column numbers\n+     and ranges.  */\n+  unsigned int m_column_and_range_bits : 8;\n+\n+  /* Number of the low-order \"column\" bits used for storing short ranges\n+     inline, rather than in the ad-hoc table.\n+     MSB                                                                 LSB\n+     31                                                                    0\n+     +-------------------------+-------------------------------------------+\n+     |                         |<---map->column_and_range_bits (e.g. 12)-->|\n+     +-------------------------+-----------------------+-------------------+\n+     |                         | column_and_range_bits | map->range_bits   |\n+     |                         |   - range_bits        |                   |\n+     +-------------------------+-----------------------+-------------------+\n+     | row bits                | effective column bits | short range bits  |\n+     |                         |    (e.g. 7)           |   (e.g. 5)        |\n+     +-------------------------+-----------------------+-------------------+ */\n+  unsigned int m_range_bits : 8;\n };\n \n /* This is the highest possible source location encoded within an\n@@ -435,15 +581,6 @@ ORDINARY_MAP_IN_SYSTEM_HEADER_P (const line_map_ordinary *ord_map)\n   return ord_map->sysp;\n }\n \n-/* Get the number of the low-order source_location bits used for a\n-   column number within ordinary map MAP.  */\n-\n-inline unsigned char\n-ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (const line_map_ordinary *ord_map)\n-{\n-  return ord_map->column_bits;\n-}\n-\n /* Get the filename of ordinary map MAP.  */\n \n inline const char *\n@@ -524,9 +661,11 @@ struct GTY(()) maps_info_macro {\n   unsigned int cache;\n };\n \n-/* Data structure to associate an arbitrary data to a source location.  */\n+/* Data structure to associate a source_range together with an arbitrary\n+   data pointer with a source location.  */\n struct GTY(()) location_adhoc_data {\n   source_location locus;\n+  source_range src_range;\n   void * GTY((skip)) data;\n };\n \n@@ -588,6 +727,12 @@ struct GTY(()) line_maps {\n \n   /* True if we've seen a #line or # 44 \"file\" directive.  */\n   bool seen_line_directive;\n+\n+  /* The default value of range_bits in ordinary line maps.  */\n+  unsigned int default_range_bits;\n+\n+  unsigned int num_optimized_ranges;\n+  unsigned int num_unoptimized_ranges;\n };\n \n /* Returns the number of allocated maps so far. MAP_KIND shall be TRUE\n@@ -825,11 +970,15 @@ LINEMAPS_LAST_ALLOCATED_MACRO_MAP (const line_maps *set)\n \n extern void location_adhoc_data_fini (struct line_maps *);\n extern source_location get_combined_adhoc_loc (struct line_maps *,\n-\t\t\t\t\t       source_location, void *);\n+\t\t\t\t\t       source_location,\n+\t\t\t\t\t       source_range,\n+\t\t\t\t\t       void *);\n extern void *get_data_from_adhoc_loc (struct line_maps *, source_location);\n extern source_location get_location_from_adhoc_loc (struct line_maps *,\n \t\t\t\t\t\t    source_location);\n \n+extern source_range get_range_from_loc (line_maps *set, source_location loc);\n+\n /* Get whether location LOC is an ad-hoc location.  */\n \n inline bool\n@@ -838,14 +987,21 @@ IS_ADHOC_LOC (source_location loc)\n   return (loc & MAX_SOURCE_LOCATION) != loc;\n }\n \n+/* Get whether location LOC is a \"pure\" location, or\n+   whether it is an ad-hoc location, or embeds range information.  */\n+\n+bool\n+pure_location_p (line_maps *set, source_location loc);\n+\n /* Combine LOC and BLOCK, giving a combined adhoc location.  */\n \n inline source_location\n COMBINE_LOCATION_DATA (struct line_maps *set,\n \t\t       source_location loc,\n+\t\t       source_range src_range,\n \t\t       void *block)\n {\n-  return get_combined_adhoc_loc (set, loc, block);\n+  return get_combined_adhoc_loc (set, loc, src_range, block);\n }\n \n extern void rebuild_location_adhoc_htab (struct line_maps *);\n@@ -931,15 +1087,15 @@ inline linenum_type\n SOURCE_LINE (const line_map_ordinary *ord_map, source_location loc)\n {\n   return ((loc - ord_map->start_location)\n-\t  >> ord_map->column_bits) + ord_map->to_line;\n+\t  >> ord_map->m_column_and_range_bits) + ord_map->to_line;\n }\n \n /* Convert a map and source_location to source column number.  */\n inline linenum_type\n SOURCE_COLUMN (const line_map_ordinary *ord_map, source_location loc)\n {\n   return ((loc - ord_map->start_location)\n-\t  & ((1 << ord_map->column_bits) - 1));\n+\t  & ((1 << ord_map->m_column_and_range_bits) - 1)) >> ord_map->m_range_bits;\n }\n \n /* Return the location of the last source line within an ordinary\n@@ -949,7 +1105,7 @@ LAST_SOURCE_LINE_LOCATION (const line_map_ordinary *map)\n {\n   return (((map[1].start_location - 1\n \t    - map->start_location)\n-\t   & ~((1 << map->column_bits) - 1))\n+\t   & ~((1 << map->m_column_and_range_bits) - 1))\n \t  + map->start_location);\n }\n \n@@ -999,7 +1155,8 @@ linemap_position_for_column (struct line_maps *, unsigned int);\n /* Encode and return a source location from a given line and\n    column.  */\n source_location\n-linemap_position_for_line_and_column (const line_map_ordinary *,\n+linemap_position_for_line_and_column (line_maps *set,\n+\t\t\t\t      const line_map_ordinary *,\n \t\t\t\t      linenum_type, unsigned int);\n \n /* Encode and return a source_location starting from location LOC and\n@@ -1187,7 +1344,7 @@ class rich_location\n   /* Constructors.  */\n \n   /* Constructing from a location.  */\n-  rich_location (source_location loc);\n+  rich_location (line_maps *set, source_location loc);\n \n   /* Constructing from a source_range.  */\n   rich_location (source_range src_range);"}, {"sha": "d9b428ad8d8890084f8734f36194daa1c4062ec3", "filename": "libcpp/lex.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -2723,6 +2723,19 @@ _cpp_lex_direct (cpp_reader *pfile)\n       break;\n     }\n \n+  source_range tok_range;\n+  tok_range.m_start = result->src_loc;\n+  if (result->src_loc >= RESERVED_LOCATION_COUNT)\n+    tok_range.m_finish\n+      = linemap_position_for_column (pfile->line_table,\n+\t\t\t\t     CPP_BUF_COLUMN (buffer, buffer->cur));\n+  else\n+    tok_range.m_finish = tok_range.m_start;\n+\n+  result->src_loc = COMBINE_LOCATION_DATA (pfile->line_table,\n+\t\t\t\t\t   result->src_loc,\n+\t\t\t\t\t   tok_range, NULL);\n+\n   return result;\n }\n "}, {"sha": "c5aa4223b1be18753c2284226dbbe3721c901f53", "filename": "libcpp/line-map.c", "status": "modified", "additions": 233, "deletions": 41, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -27,9 +27,9 @@ along with this program; see the file COPYING3.  If not see\n #include \"hashtab.h\"\n \n /* Do not track column numbers higher than this one.  As a result, the\n-   range of column_bits is [7, 18] (or 0 if column numbers are\n+   range of column_bits is [12, 18] (or 0 if column numbers are\n    disabled).  */\n-const unsigned int LINE_MAP_MAX_COLUMN_NUMBER = (1U << 17);\n+const unsigned int LINE_MAP_MAX_COLUMN_NUMBER = (1U << 12);\n \n /* Do not track column numbers if locations get higher than this.  */\n const source_location LINE_MAP_MAX_LOCATION_WITH_COLS = 0x60000000;\n@@ -46,7 +46,7 @@ static const line_map_macro* linemap_macro_map_lookup (struct line_maps *,\n static source_location linemap_macro_map_loc_to_def_point\n (const line_map_macro *, source_location);\n static source_location linemap_macro_map_loc_unwind_toward_spelling\n-(const line_map_macro *, source_location);\n+(line_maps *set, const line_map_macro *, source_location);\n static source_location linemap_macro_map_loc_to_exp_point\n (const line_map_macro *, source_location);\n static source_location linemap_macro_loc_to_spelling_point\n@@ -69,7 +69,10 @@ location_adhoc_data_hash (const void *l)\n {\n   const struct location_adhoc_data *lb =\n       (const struct location_adhoc_data *) l;\n-  return (hashval_t) lb->locus + (size_t) lb->data;\n+  return ((hashval_t) lb->locus\n+\t  + (hashval_t) lb->src_range.m_start\n+\t  + (hashval_t) lb->src_range.m_finish\n+\t  + (size_t) lb->data);\n }\n \n /* Compare function for location_adhoc_data hashtable.  */\n@@ -81,7 +84,10 @@ location_adhoc_data_eq (const void *l1, const void *l2)\n       (const struct location_adhoc_data *) l1;\n   const struct location_adhoc_data *lb2 =\n       (const struct location_adhoc_data *) l2;\n-  return lb1->locus == lb2->locus && lb1->data == lb2->data;\n+  return (lb1->locus == lb2->locus\n+\t  && lb1->src_range.m_start == lb2->src_range.m_start\n+\t  && lb1->src_range.m_finish == lb2->src_range.m_finish\n+\t  && lb1->data == lb2->data);\n }\n \n /* Update the hashtable when location_adhoc_data is reallocated.  */\n@@ -106,23 +112,103 @@ rebuild_location_adhoc_htab (struct line_maps *set)\n \t\t    set->location_adhoc_data_map.data + i, INSERT);\n }\n \n+/* Helper function for get_combined_adhoc_loc.\n+   Can the given LOCUS + SRC_RANGE and DATA pointer be stored compactly\n+   within a source_location, without needing to use an ad-hoc location.  */\n+\n+static bool\n+can_be_stored_compactly_p (struct line_maps *set,\n+\t\t\t   source_location locus,\n+\t\t\t   source_range src_range,\n+\t\t\t   void *data)\n+{\n+  /* If there's an ad-hoc pointer, we can't store it directly in the\n+     source_location, we need the lookaside.  */\n+  if (data)\n+    return false;\n+\n+  /* We only store ranges that begin at the locus and that are sufficiently\n+     \"sane\".  */\n+  if (src_range.m_start != locus)\n+    return false;\n+\n+  if (src_range.m_finish < src_range.m_start)\n+    return false;\n+\n+  if (src_range.m_start < RESERVED_LOCATION_COUNT)\n+    return false;\n+\n+  if (locus >= LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return false;\n+\n+  /* All 3 locations must be within ordinary maps, typically, the same\n+     ordinary map.  */\n+  source_location lowest_macro_loc = LINEMAPS_MACRO_LOWEST_LOCATION (set);\n+  if (locus >= lowest_macro_loc)\n+    return false;\n+  if (src_range.m_start >= lowest_macro_loc)\n+    return false;\n+  if (src_range.m_finish >= lowest_macro_loc)\n+    return false;\n+\n+  /* Passed all tests.  */\n+  return true;\n+}\n+\n /* Combine LOCUS and DATA to a combined adhoc loc.  */\n \n source_location\n get_combined_adhoc_loc (struct line_maps *set,\n-\t\t\tsource_location locus, void *data)\n+\t\t\tsource_location locus,\n+\t\t\tsource_range src_range,\n+\t\t\tvoid *data)\n {\n   struct location_adhoc_data lb;\n   struct location_adhoc_data **slot;\n \n-  linemap_assert (data);\n-\n   if (IS_ADHOC_LOC (locus))\n     locus\n       = set->location_adhoc_data_map.data[locus & MAX_SOURCE_LOCATION].locus;\n   if (locus == 0 && data == NULL)\n     return 0;\n+\n+  /* Any ordinary locations ought to be \"pure\" at this point: no\n+     compressed ranges.  */\n+  linemap_assert (locus < RESERVED_LOCATION_COUNT\n+\t\t  || locus >= LINE_MAP_MAX_LOCATION_WITH_COLS\n+\t\t  || locus >= LINEMAPS_MACRO_LOWEST_LOCATION (set)\n+\t\t  || pure_location_p (set, locus));\n+\n+  /* Consider short-range optimization.  */\n+  if (can_be_stored_compactly_p (set, locus, src_range, data))\n+    {\n+      /* The low bits ought to be clear.  */\n+      linemap_assert (pure_location_p (set, locus));\n+      const line_map *map = linemap_lookup (set, locus);\n+      const line_map_ordinary *ordmap = linemap_check_ordinary (map);\n+      unsigned int int_diff = src_range.m_finish - src_range.m_start;\n+      unsigned int col_diff = (int_diff >> ordmap->m_range_bits);\n+      if (col_diff < (1U << ordmap->m_range_bits))\n+\t{\n+\t  source_location packed = locus | col_diff;\n+\t  set->num_optimized_ranges++;\n+\t  return packed;\n+\t}\n+    }\n+\n+  /* We can also compactly store the reserved locations\n+     when locus == start == finish (and data is NULL).  */\n+  if (locus < RESERVED_LOCATION_COUNT\n+      && locus == src_range.m_start\n+      && locus == src_range.m_finish\n+      && !data)\n+    return locus;\n+\n+  if (!data)\n+    set->num_unoptimized_ranges++;\n+\n   lb.locus = locus;\n+  lb.src_range = src_range;\n   lb.data = data;\n   slot = (struct location_adhoc_data **)\n       htab_find_slot (set->location_adhoc_data_map.htab, &lb, INSERT);\n@@ -177,6 +263,60 @@ get_location_from_adhoc_loc (struct line_maps *set, source_location loc)\n   return set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n }\n \n+/* Return the source_range for adhoc location LOC.  */\n+\n+static source_range\n+get_range_from_adhoc_loc (struct line_maps *set, source_location loc)\n+{\n+  linemap_assert (IS_ADHOC_LOC (loc));\n+  return set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].src_range;\n+}\n+\n+/* Get the source_range of location LOC, either from the ad-hoc\n+   lookaside table, or embedded inside LOC itself.  */\n+\n+source_range\n+get_range_from_loc (struct line_maps *set,\n+\t\t    source_location loc)\n+{\n+  if (IS_ADHOC_LOC (loc))\n+    return get_range_from_adhoc_loc (set, loc);\n+\n+  /* For ordinary maps, extract packed range.  */\n+  if (loc >= RESERVED_LOCATION_COUNT\n+      && loc < LINEMAPS_MACRO_LOWEST_LOCATION (set)\n+      && loc <= LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    {\n+      const line_map *map = linemap_lookup (set, loc);\n+      const line_map_ordinary *ordmap = linemap_check_ordinary (map);\n+      source_range result;\n+      int offset = loc & ((1 << ordmap->m_range_bits) - 1);\n+      result.m_start = loc - offset;\n+      result.m_finish = result.m_start + (offset << ordmap->m_range_bits);\n+      return result;\n+    }\n+\n+  return source_range::from_location (loc);\n+}\n+\n+/* Get whether location LOC is a \"pure\" location, or\n+   whether it is an ad-hoc location, or embeds range information.  */\n+\n+bool\n+pure_location_p (line_maps *set, source_location loc)\n+{\n+  if (IS_ADHOC_LOC (loc))\n+    return false;\n+\n+  const line_map *map = linemap_lookup (set, loc);\n+  const line_map_ordinary *ordmap = linemap_check_ordinary (map);\n+\n+  if (loc & ((1U << ordmap->m_range_bits) - 1))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Finalize the location_adhoc_data structure.  */\n void\n location_adhoc_data_fini (struct line_maps *set)\n@@ -319,7 +459,19 @@ const struct line_map *\n linemap_add (struct line_maps *set, enum lc_reason reason,\n \t     unsigned int sysp, const char *to_file, linenum_type to_line)\n {\n-  source_location start_location = set->highest_location + 1;\n+  /* Generate a start_location above the current highest_location.\n+     If possible, make the low range bits be zero.  */\n+  source_location start_location;\n+  if (set->highest_location < LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    {\n+      start_location = set->highest_location + (1 << set->default_range_bits);\n+      if (set->default_range_bits)\n+\tstart_location &= ~((1 << set->default_range_bits) - 1);\n+      linemap_assert (0 == (start_location\n+\t\t\t    & ((1 << set->default_range_bits) - 1)));\n+    }\n+  else\n+    start_location = set->highest_location + 1;\n \n   linemap_assert (!(LINEMAPS_ORDINARY_USED (set)\n \t\t    && (start_location\n@@ -398,11 +550,18 @@ linemap_add (struct line_maps *set, enum lc_reason reason,\n   map->to_file = to_file;\n   map->to_line = to_line;\n   LINEMAPS_ORDINARY_CACHE (set) = LINEMAPS_ORDINARY_USED (set) - 1;\n-  map->column_bits = 0;\n+  map->m_column_and_range_bits = 0;\n+  map->m_range_bits = 0;\n   set->highest_location = start_location;\n   set->highest_line = start_location;\n   set->max_column_hint = 0;\n \n+  /* This assertion is placed after set->highest_location has\n+     been updated, since the latter affects\n+     linemap_location_from_macro_expansion_p, which ultimately affects\n+     pure_location_p.  */\n+  linemap_assert (pure_location_p (set, start_location));\n+\n   if (reason == LC_ENTER)\n     {\n       map->included_from =\n@@ -549,13 +708,14 @@ linemap_line_start (struct line_maps *set, linenum_type to_line,\n     SOURCE_LINE (map, set->highest_line);\n   int line_delta = to_line - last_line;\n   bool add_map = false;\n+  linemap_assert (map->m_column_and_range_bits >= map->m_range_bits);\n+  int effective_column_bits = map->m_column_and_range_bits - map->m_range_bits;\n \n   if (line_delta < 0\n       || (line_delta > 10\n-\t  && line_delta * ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map) > 1000)\n-      || (max_column_hint >= (1U << ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map)))\n-      || (max_column_hint <= 80\n-\t  && ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map) >= 10)\n+\t  && line_delta * map->m_column_and_range_bits > 1000)\n+      || (max_column_hint >= (1U << effective_column_bits))\n+      || (max_column_hint <= 80 && effective_column_bits >= 10)\n       || (highest > LINE_MAP_MAX_LOCATION_WITH_COLS\n \t  && (set->max_column_hint || highest >= LINE_MAP_MAX_SOURCE_LOCATION)))\n     add_map = true;\n@@ -564,22 +724,27 @@ linemap_line_start (struct line_maps *set, linenum_type to_line,\n   if (add_map)\n     {\n       int column_bits;\n+      int range_bits;\n       if (max_column_hint > LINE_MAP_MAX_COLUMN_NUMBER\n \t  || highest > LINE_MAP_MAX_LOCATION_WITH_COLS)\n \t{\n \t  /* If the column number is ridiculous or we've allocated a huge\n-\t     number of source_locations, give up on column numbers. */\n+\t     number of source_locations, give up on column numbers\n+\t     (and on packed ranges).  */\n \t  max_column_hint = 0;\n \t  column_bits = 0;\n+\t  range_bits = 0;\n \t  if (highest > LINE_MAP_MAX_SOURCE_LOCATION)\n \t    return 0;\n \t}\n       else\n \t{\n \t  column_bits = 7;\n+\t  range_bits = set->default_range_bits;\n \t  while (max_column_hint >= (1U << column_bits))\n \t    column_bits++;\n \t  max_column_hint = 1U << column_bits;\n+\t  column_bits += range_bits;\n \t}\n       /* Allocate the new line_map.  However, if the current map only has a\n \t single line we can sometimes just increase its column_bits instead. */\n@@ -592,14 +757,14 @@ linemap_line_start (struct line_maps *set, linenum_type to_line,\n \t\t\t\tORDINARY_MAP_IN_SYSTEM_HEADER_P (map),\n \t\t\t\tORDINARY_MAP_FILE_NAME (map),\n \t\t\t\tto_line)));\n-      map->column_bits = column_bits;\n+      map->m_column_and_range_bits = column_bits;\n+      map->m_range_bits = range_bits;\n       r = (MAP_START_LOCATION (map)\n \t   + ((to_line - ORDINARY_MAP_STARTING_LINE_NUMBER (map))\n \t      << column_bits));\n     }\n   else\n-    r = highest - SOURCE_COLUMN (map, highest)\n-      + (line_delta << ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map));\n+    r = set->highest_line + (line_delta << map->m_column_and_range_bits);\n \n   /* Locations of ordinary tokens are always lower than locations of\n      macro tokens.  */\n@@ -610,6 +775,18 @@ linemap_line_start (struct line_maps *set, linenum_type to_line,\n   if (r > set->highest_location)\n     set->highest_location = r;\n   set->max_column_hint = max_column_hint;\n+\n+  /* At this point, we expect one of:\n+     (a) the normal case: a \"pure\" location with 0 range bits, or\n+     (b) we've gone past LINE_MAP_MAX_LOCATION_WITH_COLS so can't track\n+        columns anymore (or ranges), or\n+     (c) we're in a region with a column hint exceeding\n+        LINE_MAP_MAX_COLUMN_NUMBER, so column-tracking is off,\n+\twith column_bits == 0.  */\n+  linemap_assert (pure_location_p (set, r)\n+\t\t  || r >= LINE_MAP_MAX_LOCATION_WITH_COLS\n+\t\t  || map->m_column_and_range_bits == 0);\n+  linemap_assert (SOURCE_LINE (map, r) == to_line);\n   return r;\n }\n \n@@ -640,7 +817,8 @@ linemap_position_for_column (struct line_maps *set, unsigned int to_column)\n \t  r = linemap_line_start (set, SOURCE_LINE (map, r), to_column + 50);\n \t}\n     }\n-  r = r + to_column;\n+  line_map_ordinary *map = LINEMAPS_LAST_ORDINARY_MAP (set);\n+  r = r + (to_column << map->m_range_bits);\n   if (r >= set->highest_location)\n     set->highest_location = r;\n   return r;\n@@ -650,16 +828,25 @@ linemap_position_for_column (struct line_maps *set, unsigned int to_column)\n    column.  */\n \n source_location\n-linemap_position_for_line_and_column (const line_map_ordinary *ord_map,\n+linemap_position_for_line_and_column (line_maps *set,\n+\t\t\t\t      const line_map_ordinary *ord_map,\n \t\t\t\t      linenum_type line,\n \t\t\t\t      unsigned column)\n {\n   linemap_assert (ORDINARY_MAP_STARTING_LINE_NUMBER (ord_map) <= line);\n \n-  return (MAP_START_LOCATION (ord_map)\n-\t  + ((line - ORDINARY_MAP_STARTING_LINE_NUMBER (ord_map))\n-\t     << ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (ord_map))\n-\t  + (column & ((1 << ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (ord_map)) - 1)));\n+  source_location r = MAP_START_LOCATION (ord_map);\n+  r += ((line - ORDINARY_MAP_STARTING_LINE_NUMBER (ord_map))\n+\t<< ord_map->m_column_and_range_bits);\n+  if (r <= LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    r += ((column & ((1 << ord_map->m_column_and_range_bits) - 1))\n+\t  << ord_map->m_range_bits);\n+  source_location upper_limit = LINEMAPS_MACRO_LOWEST_LOCATION (set);\n+  if (r >= upper_limit)\n+    r = upper_limit - 1;\n+  if (r > set->highest_location)\n+    set->highest_location = r;\n+  return r;\n }\n \n /* Encode and return a source_location starting from location LOC and\n@@ -673,6 +860,9 @@ linemap_position_for_loc_and_offset (struct line_maps *set,\n {\n   const line_map_ordinary * map = NULL;\n \n+  if (IS_ADHOC_LOC (loc))\n+    loc = set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n+\n   /* This function does not support virtual locations yet.  */\n   if (linemap_assert_fails\n       (!linemap_location_from_macro_expansion_p (set, loc)))\n@@ -711,11 +901,11 @@ linemap_position_for_loc_and_offset (struct line_maps *set,\n     }\n \n   offset += column;\n-  if (linemap_assert_fails (offset < (1u << map->column_bits)))\n+  if (linemap_assert_fails (offset < (1u << map->m_column_and_range_bits)))\n     return loc;\n \n   source_location r = \n-    linemap_position_for_line_and_column (map, line, offset);\n+    linemap_position_for_line_and_column (set, map, line, offset);\n   if (linemap_assert_fails (r <= set->highest_location)\n       || linemap_assert_fails (map == linemap_lookup (set, r)))\n     return loc;\n@@ -893,14 +1083,19 @@ linemap_macro_map_loc_to_def_point (const line_map_macro *map,\n    In other words, this returns the xI location presented in the\n    comments of line_map_macro above.  */\n source_location\n-linemap_macro_map_loc_unwind_toward_spelling (const line_map_macro* map,\n+linemap_macro_map_loc_unwind_toward_spelling (line_maps *set,\n+\t\t\t\t\t      const line_map_macro* map,\n \t\t\t\t\t      source_location location)\n {\n   unsigned token_no;\n \n+  if (IS_ADHOC_LOC (location))\n+    location = get_location_from_adhoc_loc (set, location);\n+\n   linemap_assert (linemap_macro_expansion_map_p (map)\n \t\t  && location >= MAP_START_LOCATION (map));\n   linemap_assert (location >= RESERVED_LOCATION_COUNT);\n+  linemap_assert (!IS_ADHOC_LOC (location));\n \n   token_no = location - MAP_START_LOCATION (map);\n   linemap_assert (token_no < MACRO_MAP_NUM_MACRO_TOKENS (map));\n@@ -1010,7 +1205,7 @@ linemap_location_in_system_header_p (struct line_maps *set,\n \n \t      /* It's a token resulting from a macro expansion.  */\n \t      source_location loc =\n-\t\tlinemap_macro_map_loc_unwind_toward_spelling (macro_map, location);\n+\t\tlinemap_macro_map_loc_unwind_toward_spelling (set, macro_map, location);\n \t      if (loc < RESERVED_LOCATION_COUNT)\n \t\t/* This token might come from a built-in macro.  Let's\n \t\t   look at where that macro got expanded.  */\n@@ -1183,11 +1378,6 @@ linemap_macro_loc_to_spelling_point (struct line_maps *set,\n \t\t\t\t     const line_map_ordinary **original_map)\n {\n   struct line_map *map;\n-\n-  if (IS_ADHOC_LOC (location))\n-    location = set->location_adhoc_data_map.data[location\n-\t\t\t\t\t\t & MAX_SOURCE_LOCATION].locus;\n-\n   linemap_assert (set && location >= RESERVED_LOCATION_COUNT);\n \n   while (true)\n@@ -1198,7 +1388,7 @@ linemap_macro_loc_to_spelling_point (struct line_maps *set,\n \n       location\n \t= linemap_macro_map_loc_unwind_toward_spelling\n-\t    (linemap_check_macro (map),\n+\t    (set, linemap_check_macro (map),\n \t     location);\n     }\n \n@@ -1341,10 +1531,11 @@ linemap_resolve_location (struct line_maps *set,\n \t\t\t  enum location_resolution_kind lrk,\n \t\t\t  const line_map_ordinary **map)\n {\n+  source_location locus = loc;\n   if (IS_ADHOC_LOC (loc))\n-    loc = set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n+    locus = set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n \n-  if (loc < RESERVED_LOCATION_COUNT)\n+  if (locus < RESERVED_LOCATION_COUNT)\n     {\n       /* A reserved location wasn't encoded in a map.  Let's return a\n \t NULL map here, just like what linemap_ordinary_map_lookup\n@@ -1396,7 +1587,7 @@ linemap_unwind_toward_expansion (struct line_maps *set,\n     loc = set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n \n   resolved_location =\n-    linemap_macro_map_loc_unwind_toward_spelling (macro_map, loc);\n+    linemap_macro_map_loc_unwind_toward_spelling (set, macro_map, loc);\n   resolved_map = linemap_lookup (set, resolved_location);\n \n   if (!linemap_macro_expansion_map_p (resolved_map))\n@@ -1478,9 +1669,9 @@ linemap_expand_location (struct line_maps *set,\n   memset (&xloc, 0, sizeof (xloc));\n   if (IS_ADHOC_LOC (loc))\n     {\n-      loc = set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n       xloc.data\n \t= set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].data;\n+      loc = set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n     }\n \n   if (loc < RESERVED_LOCATION_COUNT)\n@@ -1760,13 +1951,14 @@ line_table_dump (FILE *stream, struct line_maps *set, unsigned int num_ordinary,\n \n /* Construct a rich_location with location LOC as its initial range.  */\n \n-rich_location::rich_location (source_location loc) :\n+rich_location::rich_location (line_maps *set, source_location loc) :\n   m_loc (loc),\n   m_num_ranges (0),\n   m_have_expanded_location (false)\n {\n-  /* Set up the 0th range: */\n-  add_range (loc, loc, true);\n+  /* Set up the 0th range, extracting any range from LOC.  */\n+  source_range src_range = get_range_from_loc (set, loc);\n+  add_range (src_range, true);\n   m_ranges[0].m_caret = lazily_expand_location ();\n }\n "}, {"sha": "14b5c2e284a0244e14e6629c0337c4a52fcf2594", "filename": "libcpp/location-example.txt", "status": "modified", "additions": 102, "deletions": 86, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebedc9a3414d842274607b77597759bd36e0f3e0/libcpp%2Flocation-example.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebedc9a3414d842274607b77597759bd36e0f3e0/libcpp%2Flocation-example.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flocation-example.txt?ref=ebedc9a3414d842274607b77597759bd36e0f3e0", "patch": "@@ -30,142 +30,154 @@ RESERVED LOCATIONS\n   source_location interval: 0 <= loc < 2\n \n ORDINARY MAP: 0\n-  source_location interval: 2 <= loc < 3\n+  source_location interval: 32 <= loc < 64\n   file: test.c\n   starting at line: 1\n-  column bits: 7\n-test.c:  1|loc:    2|#include \"test.h\"\n-                    |00000001111111111\n-                    |34567890123456789\n+  column bits: 12\n+  range bits: 5\n+test.c:  1|loc:   32|#include \"test.h\"\n+                    |69269258258148147\n+                    |46802468024680246\n \n ORDINARY MAP: 1\n-  source_location interval: 3 <= loc < 4\n+  source_location interval: 64 <= loc < 96\n   file: <built-in>\n   starting at line: 0\n   column bits: 0\n+  range bits: 0\n \n ORDINARY MAP: 2\n-  source_location interval: 4 <= loc < 5\n+  source_location interval: 96 <= loc < 128\n   file: <command-line>\n   starting at line: 0\n   column bits: 0\n+  range bits: 0\n \n ORDINARY MAP: 3\n-  source_location interval: 5 <= loc < 5005\n+  source_location interval: 128 <= loc < 160128\n   file: /usr/include/stdc-predef.h\n   starting at line: 1\n-  column bits: 7\n+  column bits: 12\n+  range bits: 5\n (contents of /usr/include/stdc-predef.h snipped for brevity)\n \n ORDINARY MAP: 4\n-  source_location interval: 5005 <= loc < 5006\n+  source_location interval: 160128 <= loc < 160160\n   file: <command-line>\n-  starting at line: 1\n-  column bits: 7\n+  starting at line: 32\n+  column bits: 12\n+  range bits: 5\n \n ORDINARY MAP: 5\n-  source_location interval: 5006 <= loc < 5134\n+  source_location interval: 160160 <= loc < 164256\n   file: test.c\n   starting at line: 1\n-  column bits: 7\n-test.c:  1|loc: 5006|#include \"test.h\"\n-                    |55555555555555555\n+  column bits: 12\n+  range bits: 5\n+test.c:  1|loc:160160|#include \"test.h\"\n                     |00000000000000000\n-                    |00011111111112222\n-                    |78901234567890123\n+                    |12223334445556667\n+                    |92582581481470470\n+                    |24680246802468024\n \n ORDINARY MAP: 6\n-  source_location interval: 5134 <= loc < 5416\n+  source_location interval: 164256 <= loc < 173280\n   file: test.h\n   starting at line: 1\n-  column bits: 7\n-test.h:  1|loc: 5134|extern int foo ();\n-                    |555555555555555555\n-                    |111111111111111111\n-                    |333334444444444555\n-                    |567890123456789012\n-test.h:  2|loc: 5262|\n+  column bits: 12\n+  range bits: 5\n+test.h:  1|loc:164256|extern int foo ();\n+                    |444444444444444444\n+                    |233344455566677788\n+                    |825814814704703603\n+                    |802468024680246802\n+test.h:  2|loc:168352|\n                     |\n                     |\n                     |\n                     |\n-test.h:  3|loc: 5390|#define PLUS(A, B) A + B\n-                    |555555555555555555555555\n-                    |333333333444444444444444\n-                    |999999999000000000011111\n-                    |123456789012345678901234\n+test.h:  3|loc:172448|#define PLUS(A, B) A + B\n+                    |222222222222222223333333\n+                    |455566677788889990001112\n+                    |814704703603692692582581\n+                    |024680246802468024680246\n \n ORDINARY MAP: 7\n-  source_location interval: 5416 <= loc < 6314\n+  source_location interval: 173280 <= loc < 202016\n   file: test.c\n   starting at line: 2\n-  column bits: 7\n-test.c:  2|loc: 5416|\n+  column bits: 12\n+  range bits: 5\n+test.c:  2|loc:173280|\n                     |\n                     |\n                     |\n                     |\n-test.c:  3|loc: 5544|int\n-                    |555\n-                    |555\n+test.c:  3|loc:177376|int\n+                    |777\n                     |444\n-                    |567\n-test.c:  4|loc: 5672|main (int argc, char **argv)\n-                    |5555555555555555555555555555\n-                    |6666666666666666666666666667\n-                    |7777777888888888899999999990\n-                    |3456789012345678901234567890\n-test.c:  5|loc: 5800|{\n+                    |047\n+                    |802\n+test.c:  4|loc:181472|main (int argc, char **argv)\n+                    |1111111111111111222222222222\n+                    |5556666777888999000111222333\n+                    |0360369269258258148147047036\n+                    |4680246802468024680246802468\n+test.c:  5|loc:185568|{\n                     |5\n-                    |8\n-                    |0\n-                    |1\n-test.c:  6|loc: 5928|  int a = PLUS (1,2);\n-                    |555555555555555555555\n-                    |999999999999999999999\n-                    |233333333334444444444\n-                    |901234567890123456789\n-test.c:  7|loc: 6056|  int b = PLUS (3,4);\n-                    |666666666666666666666\n-                    |000000000000000000000\n-                    |555666666666677777777\n-                    |789012345678901234567\n-test.c:  8|loc: 6184|  return 0;\n-                    |66666666666\n-                    |11111111111\n-                    |88888999999\n-                    |56789012345\n-test.c:  9|loc: 6312|}\n                     |6\n-                    |3\n+                    |0\n+                    |0\n+test.c:  6|loc:189664|  int a = PLUS (1,2);\n+                    |999999999900000000000\n+                    |677788899900011122233\n+                    |926925825814814704703\n+                    |680246802468024680246\n+test.c:  7|loc:193760|  int b = PLUS (3,4);\n+                    |333333344444444444444\n+                    |788899900011122233344\n+                    |925825814814704703603\n+                    |246802468024680246802\n+test.c:  8|loc:197856|  return 0;\n+                    |77778888888\n+                    |89990001112\n+                    |82581481470\n+                    |80246802468\n+test.c:  9|loc:201952|}\n                     |1\n-                    |3\n+                    |9\n+                    |8\n+                    |4\n \n UNALLOCATED LOCATIONS\n-  source_location interval: 6314 <= loc < 2147483633\n+  source_location interval: 202016 <= loc < 2147483633\n \n MACRO 1: PLUS (7 tokens)\n   source_location interval: 2147483633 <= loc < 2147483640\n-test.c:7:11: note: expansion point is location 6067\n+test.c:7:11: note: expansion point is location 194115\n    int b = PLUS (3,4);\n-           ^\n+           ^~~~\n+\n   map->start_location: 2147483633\n   macro_locations:\n-    0: 6073, 5410\n-test.c:7:17: note: token 0 has x-location == 6073\n+    0: 194304, 173088\n+test.c:7:17: note: token 0 has x-location == 194304\n    int b = PLUS (3,4);\n                  ^\n-test.c:7:17: note: token 0 has y-location == 5410\n-    1: 5412, 5412\n+\n+test.c:7:17: note: token 0 has y-location == 173088\n+    1: 173152, 173152\n In file included from test.c:1:0:\n-test.h:3:22: note: token 1 has x-location == y-location == 5412\n+test.h:3:22: note: token 1 has x-location == y-location == 173152\n  #define PLUS(A, B) A + B\n                       ^\n-    2: 6075, 5414\n-test.c:7:19: note: token 2 has x-location == 6075\n+\n+    2: 194368, 173216\n+test.c:7:19: note: token 2 has x-location == 194368\n    int b = PLUS (3,4);\n                    ^\n-test.c:7:19: note: token 2 has y-location == 5414\n+\n+test.c:7:19: note: token 2 has y-location == 173216\n     3: 0, 2947526575\n cc1: note: token 3 has x-location == 0\n cc1: note: token 3 has y-location == 2947526575\n@@ -178,26 +190,30 @@ x-location == y-location == 2947526575 encodes token # 800042942\n \n MACRO 0: PLUS (7 tokens)\n   source_location interval: 2147483640 <= loc < 2147483647\n-test.c:6:11: note: expansion point is location 5939\n+test.c:6:11: note: expansion point is location 190019\n    int a = PLUS (1,2);\n-           ^\n+           ^~~~\n+\n   map->start_location: 2147483640\n   macro_locations:\n-    0: 5945, 5410\n-test.c:6:17: note: token 0 has x-location == 5945\n+    0: 190208, 173088\n+test.c:6:17: note: token 0 has x-location == 190208\n    int a = PLUS (1,2);\n                  ^\n-test.c:6:17: note: token 0 has y-location == 5410\n-    1: 5412, 5412\n+\n+test.c:6:17: note: token 0 has y-location == 173088\n+    1: 173152, 173152\n In file included from test.c:1:0:\n-test.h:3:22: note: token 1 has x-location == y-location == 5412\n+test.h:3:22: note: token 1 has x-location == y-location == 173152\n  #define PLUS(A, B) A + B\n                       ^\n-    2: 5947, 5414\n-test.c:6:19: note: token 2 has x-location == 5947\n+\n+    2: 190272, 173216\n+test.c:6:19: note: token 2 has x-location == 190272\n    int a = PLUS (1,2);\n                    ^\n-test.c:6:19: note: token 2 has y-location == 5414\n+\n+test.c:6:19: note: token 2 has y-location == 173216\n     3: 0, 2947526575\n cc1: note: token 3 has x-location == 0\n cc1: note: token 3 has y-location == 2947526575"}]}