{"sha": "64ab8765d7e45ed19d4a571b2aaba0abf7f834c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRhYjg3NjVkN2U0NWVkMTlkNGE1NzFiMmFhYmEwYWJmN2Y4MzRjMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:11:23Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:11:23Z"}, "message": "[24/77] Replace a != BLKmode check with is_a <scalar_int_mode>\n\nThis patch replaces a check against BLKmode with a check\nof is_a <scalar_int_mode>, in a case where scalar integer\nmodes were the only useful alternatives left.\n\ngcc/\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\n\t* gimple-fold.c (gimple_fold_builtin_memory_op): Use\n\tis_a <scalar_int_mode> instead of != BLKmode.\n\nFrom-SVN: r251476", "tree": {"sha": "b05715fb0b8144f639b5f3e330714a2b5031ac3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b05715fb0b8144f639b5f3e330714a2b5031ac3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64ab8765d7e45ed19d4a571b2aaba0abf7f834c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64ab8765d7e45ed19d4a571b2aaba0abf7f834c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64ab8765d7e45ed19d4a571b2aaba0abf7f834c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64ab8765d7e45ed19d4a571b2aaba0abf7f834c3/comments", "author": null, "committer": null, "parents": [{"sha": "673bf5a6b65e51d177d2cf9fc4002171b1f467ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/673bf5a6b65e51d177d2cf9fc4002171b1f467ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/673bf5a6b65e51d177d2cf9fc4002171b1f467ab"}], "stats": {"total": 24, "additions": 11, "deletions": 13}, "files": [{"sha": "5886b3db91c9e59a38f3c588137bc537cc1e5d76", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ab8765d7e45ed19d4a571b2aaba0abf7f834c3/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ab8765d7e45ed19d4a571b2aaba0abf7f834c3/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=64ab8765d7e45ed19d4a571b2aaba0abf7f834c3", "patch": "@@ -748,31 +748,29 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \t  unsigned ilen = tree_to_uhwi (len);\n \t  if (pow2p_hwi (ilen))\n \t    {\n+\t      scalar_int_mode mode;\n \t      tree type = lang_hooks.types.type_for_size (ilen * 8, 1);\n \t      if (type\n-\t\t  && TYPE_MODE (type) != BLKmode\n-\t\t  && (GET_MODE_SIZE (TYPE_MODE (type)) * BITS_PER_UNIT\n-\t\t      == ilen * 8)\n+\t\t  && is_a <scalar_int_mode> (TYPE_MODE (type), &mode)\n+\t\t  && GET_MODE_SIZE (mode) * BITS_PER_UNIT == ilen * 8\n \t\t  /* If the destination pointer is not aligned we must be able\n \t\t     to emit an unaligned store.  */\n-\t\t  && (dest_align >= GET_MODE_ALIGNMENT (TYPE_MODE (type))\n-\t\t      || !SLOW_UNALIGNED_ACCESS (TYPE_MODE (type), dest_align)\n-\t\t      || (optab_handler (movmisalign_optab, TYPE_MODE (type))\n+\t\t  && (dest_align >= GET_MODE_ALIGNMENT (mode)\n+\t\t      || !SLOW_UNALIGNED_ACCESS (mode, dest_align)\n+\t\t      || (optab_handler (movmisalign_optab, mode)\n \t\t\t  != CODE_FOR_nothing)))\n \t\t{\n \t\t  tree srctype = type;\n \t\t  tree desttype = type;\n-\t\t  if (src_align < GET_MODE_ALIGNMENT (TYPE_MODE (type)))\n+\t\t  if (src_align < GET_MODE_ALIGNMENT (mode))\n \t\t    srctype = build_aligned_type (type, src_align);\n \t\t  tree srcmem = fold_build2 (MEM_REF, srctype, src, off0);\n \t\t  tree tem = fold_const_aggregate_ref (srcmem);\n \t\t  if (tem)\n \t\t    srcmem = tem;\n-\t\t  else if (src_align < GET_MODE_ALIGNMENT (TYPE_MODE (type))\n-\t\t\t   && SLOW_UNALIGNED_ACCESS (TYPE_MODE (type),\n-\t\t\t\t\t\t     src_align)\n-\t\t\t   && (optab_handler (movmisalign_optab,\n-\t\t\t\t\t      TYPE_MODE (type))\n+\t\t  else if (src_align < GET_MODE_ALIGNMENT (mode)\n+\t\t\t   && SLOW_UNALIGNED_ACCESS (mode, src_align)\n+\t\t\t   && (optab_handler (movmisalign_optab, mode)\n \t\t\t       == CODE_FOR_nothing))\n \t\t    srcmem = NULL_TREE;\n \t\t  if (srcmem)\n@@ -788,7 +786,7 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \t\t\t  gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n \t\t\t  gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n \t\t\t}\n-\t\t      if (dest_align < GET_MODE_ALIGNMENT (TYPE_MODE (type)))\n+\t\t      if (dest_align < GET_MODE_ALIGNMENT (mode))\n \t\t\tdesttype = build_aligned_type (type, dest_align);\n \t\t      new_stmt\n \t\t\t= gimple_build_assign (fold_build2 (MEM_REF, desttype,"}]}