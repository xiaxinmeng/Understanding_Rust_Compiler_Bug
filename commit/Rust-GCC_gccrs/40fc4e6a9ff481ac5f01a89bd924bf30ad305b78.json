{"sha": "40fc4e6a9ff481ac5f01a89bd924bf30ad305b78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBmYzRlNmE5ZmY0ODFhYzVmMDFhODliZDkyNGJmMzBhZDMwNWI3OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-07-24T22:34:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-07-24T22:34:43Z"}, "message": "flow.c (try_forward_edges): Accept fallthru edge; Update comment.\n\n\t* flow.c (try_forward_edges): Accept fallthru edge; Update comment.\n\t(try_crossjump_to_edge): Update commetns.\n\t(try_crossjump_bb): Likewise.\n\nFrom-SVN: r44318", "tree": {"sha": "383754d4dac825fcb2cac4416ff6598032949560", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/383754d4dac825fcb2cac4416ff6598032949560"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40fc4e6a9ff481ac5f01a89bd924bf30ad305b78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40fc4e6a9ff481ac5f01a89bd924bf30ad305b78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40fc4e6a9ff481ac5f01a89bd924bf30ad305b78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40fc4e6a9ff481ac5f01a89bd924bf30ad305b78/comments", "author": null, "committer": null, "parents": [{"sha": "e7139885a924d6ad2316a4526a84dda352ca2373", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7139885a924d6ad2316a4526a84dda352ca2373", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7139885a924d6ad2316a4526a84dda352ca2373"}], "stats": {"total": 24, "additions": 16, "deletions": 8}, "files": [{"sha": "30db51bd0d3c8af536283127e3a1cb4f7e051404", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fc4e6a9ff481ac5f01a89bd924bf30ad305b78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fc4e6a9ff481ac5f01a89bd924bf30ad305b78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40fc4e6a9ff481ac5f01a89bd924bf30ad305b78", "patch": "@@ -1,3 +1,9 @@\n+Wed Jul 25 00:32:49 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* flow.c (try_forward_edges): Accept fallthru edge; Update comment.\n+\t(try_crossjump_to_edge): Update commetns.\n+\t(try_crossjump_bb): Likewise.\n+\n 2001-07-24  Richard Henderson  <rth@redhat.com>\n \n \t* combine.c (distribute_notes): Move set of need_refresh"}, {"sha": "ac1ea5ccee3125600e16ada452b92b36fa92d23e", "filename": "gcc/flow.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fc4e6a9ff481ac5f01a89bd924bf30ad305b78/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fc4e6a9ff481ac5f01a89bd924bf30ad305b78/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=40fc4e6a9ff481ac5f01a89bd924bf30ad305b78", "patch": "@@ -3106,8 +3106,11 @@ try_forward_edges (b)\n       next = e->succ_next;\n \n       /* Skip complex edges because we don't know how to update them.\n-\t Skip fallthru edges because there's no jump to update.  */\n-      if (e->flags & (EDGE_COMPLEX | EDGE_FALLTHRU))\n+        \n+         Still handle fallthru edges, as we can suceed to forward fallthru\n+         edge to the same place as the branch edge of conditional branch\n+         and turn conditional branch to an unconditonal branch.  */\n+      if (e->flags & EDGE_COMPLEX)\n \tcontinue;\n \n       target = first = e->dest;\n@@ -3517,14 +3520,14 @@ try_crossjump_to_edge (mode, e1, e2)\n       && forwarder_block_p (e2->dest->succ->dest))\n     return false;\n \n-  /* Likewise with dead code.  */\n-  /* ??? Won't we have eliminated these by now?  */\n+  /* Likewise with dead code (possibly newly created by the other optimizations\n+     of cfg_cleanup).  */\n   if (!src1->pred || !src2->pred)\n     return false;\n \n-  /* Likewise with non-jump edges.  */\n-  /* ??? Non-jump?  You mean GET_CODE (e1->src-end) != JUMP_INSN?\n-     This fails for computed-goto as well, which may in fact be joinable.  */\n+  /* Likewise with complex edges.\n+     ??? We should be able to handle most complex edges later with some\n+     care.  */\n   if (e1->flags & EDGE_COMPLEX)\n     return false;\n \n@@ -3724,7 +3727,6 @@ try_crossjump_bb (mode, bb)\n \t     checks of crossjump(A,B).  In order to prevent redundant\n \t     checks of crossjump(B,A), require that A be the block \n \t     with the lowest index.  */\n-\t  /* ??? Perhaps better is lowest execution frequency.  */\n \t  if (e->src->index > e2->src->index)\n \t    continue;\n "}]}