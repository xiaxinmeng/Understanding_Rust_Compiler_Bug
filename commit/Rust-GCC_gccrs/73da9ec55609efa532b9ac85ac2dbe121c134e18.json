{"sha": "73da9ec55609efa532b9ac85ac2dbe121c134e18", "node_id": "C_kwDOANBUbNoAKDczZGE5ZWM1NTYwOWVmYTUzMmI5YWM4NWFjMmRiZTEyMWMxMzRlMTg", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-04-11T16:44:14Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-04-11T16:59:50Z"}, "message": "libstdc++: Fix std::basic_stacktrace special members [PR105031]\n\nThe PR points out that there is a non-constant condition used for an\nif-constexpr statement, but there are several other problems with the\ncopy, move and swap members of std::basic_stacktrace.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/105031\n\t* include/std/stacktrace (basic_stacktrace::basic_stacktrace):\n\tFix allocator usage in constructors.\n\t(basic_stacktrace::operator=(const basic_stacktrace&)): Do not\n\ttry to reallocate using const allocator.\n\t(basic_stacktrace::operator=(basic_stacktrace&&)): Fix\n\tif-constexpr with non-constant condition. Do not allocate new\n\tstorage if allocator propagates. Do not set _M_size if\n\tallocation fails.\n\t(basic_stacktrace::swap(basic_stacktrace&)): Fix typo. Add\n\tassertion that non-propagating allocators are equal.\n\t* testsuite/19_diagnostics/stacktrace/stacktrace.cc: New test.", "tree": {"sha": "a58b51c6f7dfbe3f627e9f32f98706a0ad99ea8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a58b51c6f7dfbe3f627e9f32f98706a0ad99ea8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73da9ec55609efa532b9ac85ac2dbe121c134e18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73da9ec55609efa532b9ac85ac2dbe121c134e18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73da9ec55609efa532b9ac85ac2dbe121c134e18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73da9ec55609efa532b9ac85ac2dbe121c134e18/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdb9639ee99b68a8c7541e78057e96fe6a2c62ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdb9639ee99b68a8c7541e78057e96fe6a2c62ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdb9639ee99b68a8c7541e78057e96fe6a2c62ed"}], "stats": {"total": 274, "additions": 252, "deletions": 22}, "files": [{"sha": "dd78c71c5dc416e2aaeffb4f740fd1380117e320", "filename": "libstdc++-v3/include/std/stacktrace", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73da9ec55609efa532b9ac85ac2dbe121c134e18/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstacktrace", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73da9ec55609efa532b9ac85ac2dbe121c134e18/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstacktrace", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstacktrace?ref=73da9ec55609efa532b9ac85ac2dbe121c134e18", "patch": "@@ -301,7 +301,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { }\n \n       basic_stacktrace(const basic_stacktrace& __other) noexcept\n-      : basic_stacktrace(__other, __other._M_alloc)\n+      : basic_stacktrace(__other,\n+\t  _AllocTraits::select_on_container_copy_construction(__other._M_alloc))\n       { }\n \n       basic_stacktrace(basic_stacktrace&& __other) noexcept\n@@ -326,13 +327,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       : _M_alloc(__alloc)\n       {\n \tif constexpr (_Allocator::is_always_equal::value)\n-\t  {\n-\t    _M_impl = std::__exchange(__other._M_impl, {});\n-\t  }\n+\t  _M_impl = std::__exchange(__other._M_impl, {});\n \telse if (_M_alloc == __other._M_alloc)\n-\t  {\n-\t    _M_impl = std::__exchange(__other._M_impl, {});\n-\t  }\n+\t  _M_impl = std::__exchange(__other._M_impl, {});\n+\telse if (const auto __s = __other._M_impl._M_size)\n+\t  if (auto __f = _M_impl._M_allocate(_M_alloc, __s))\n+\t    {\n+\t      std::uninitialized_copy_n(__other.begin(), __s, __f);\n+\t      _M_impl._M_size = __s;\n+\t    }\n       }\n \n       basic_stacktrace&\n@@ -361,9 +364,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    // Need to allocate new storage.\n \t    _M_clear();\n \n-\t    // Use the allocator we will have after this function returns.\n-\t    auto& __alloc = __pocca ? __other._M_alloc : _M_alloc;\n-\t    if (auto __f = _M_impl._M_allocate(__alloc, __s))\n+\t    if constexpr (__pocca)\n+\t      _M_alloc = __other._M_alloc;\n+\n+\t    if (auto __f = _M_impl._M_allocate(_M_alloc, __s))\n \t      {\n \t\tstd::uninitialized_copy_n(__other.begin(), __s, __f);\n \t\t_M_impl._M_size = __s;\n@@ -376,10 +380,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    auto __to = std::copy_n(__other.begin(), __s, begin());\n \t    std::destroy(__to, end());\n \t    _M_impl._M_size = __s;\n-\t  }\n \n-\tif constexpr (__pocca)\n-\t  _M_alloc = __other._M_alloc;\n+\t    if constexpr (__pocca)\n+\t      _M_alloc = __other._M_alloc;\n+\t  }\n \n \treturn *this;\n       }\n@@ -397,19 +401,26 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  std::swap(_M_impl, __other._M_impl);\n \telse if (_M_alloc == __other._M_alloc)\n \t  std::swap(_M_impl, __other._M_impl);\n-\telse\n+\telse if constexpr (__pocma)\n \t  {\n-\t    const auto __s = __other.size();\n+\t    // Free current storage and take ownership of __other's storage.\n+\t    _M_clear();\n+\t    _M_impl = std::__exchange(__other._M_impl, {});\n+\t  }\n+\telse // Allocators are unequal and don't propagate.\n+\t  {\n+\t    const size_type __s = __other.size();\n \n-\t    if constexpr (__pocma || _M_impl._M_capacity < __s)\n+\t    if (_M_impl._M_capacity < __s)\n \t      {\n \t\t// Need to allocate new storage.\n \t\t_M_clear();\n \n-\t\t// Use the allocator we will have after this function returns.\n-\t\tauto& __alloc = __pocma ? __other._M_alloc : _M_alloc;\n-\t\tif (auto __f = _M_impl._M_allocate(__alloc, __s))\n-\t\t  std::uninitialized_copy_n(__other.begin(), __s, __f);\n+\t\tif (auto __f = _M_impl._M_allocate(_M_alloc, __s))\n+\t\t  {\n+\t\t    std::uninitialized_copy_n(__other.begin(), __s, __f);\n+\t\t    _M_impl._M_size = __s;\n+\t\t  }\n \t      }\n \t    else\n \t      {\n@@ -420,8 +431,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\tauto __to = std::copy(__first, __mid, begin());\n \t\t__to = std::uninitialized_copy(__mid, __last, __to);\n \t\tstd::destroy(__to, end());\n+\t\t_M_impl._M_size = __s;\n \t      }\n-\t    _M_impl._M_size = __s;\n \t  }\n \n \tif constexpr (__pocma)\n@@ -503,9 +514,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       swap(basic_stacktrace& __other) noexcept\n       {\n-\tstd::swap(_M_impl. __other._M_impl);\n+\tstd::swap(_M_impl, __other._M_impl);\n \tif constexpr (_AllocTraits::propagate_on_container_swap::value)\n \t  std::swap(_M_alloc, __other._M_alloc);\n+\telse if constexpr (!_AllocTraits::is_always_equal::value)\n+\t  {\n+\t    __glibcxx_assert(_M_alloc == __other._M_alloc);\n+\t  }\n       }\n \n     private:"}, {"sha": "8dfdf4739bee6abe28142f65b29cffa6bc34ae6a", "filename": "libstdc++-v3/testsuite/19_diagnostics/stacktrace/stacktrace.cc", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73da9ec55609efa532b9ac85ac2dbe121c134e18/libstdc%2B%2B-v3%2Ftestsuite%2F19_diagnostics%2Fstacktrace%2Fstacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73da9ec55609efa532b9ac85ac2dbe121c134e18/libstdc%2B%2B-v3%2Ftestsuite%2F19_diagnostics%2Fstacktrace%2Fstacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F19_diagnostics%2Fstacktrace%2Fstacktrace.cc?ref=73da9ec55609efa532b9ac85ac2dbe121c134e18", "patch": "@@ -0,0 +1,215 @@\n+// { dg-options \"-std=gnu++23 -lstdc++_libbacktrace\" }\n+// { dg-do run { target c++23 } }\n+// { dg-require-effective-target stacktrace }\n+\n+#include <stacktrace>\n+#include \"testsuite_allocator.h\"\n+\n+static_assert( std::is_nothrow_default_constructible_v<std::stacktrace> );\n+static_assert( std::is_copy_constructible_v<std::stacktrace> );\n+static_assert( std::is_nothrow_move_constructible_v<std::stacktrace> );\n+static_assert( std::is_copy_assignable_v<std::stacktrace> );\n+static_assert( std::is_nothrow_move_assignable_v<std::stacktrace> );\n+static_assert( std::is_nothrow_swappable_v<std::stacktrace> );\n+\n+void\n+test_cons()\n+{\n+  {\n+    using Stacktrace = std::stacktrace;\n+    using Alloc = Stacktrace::allocator_type;\n+\n+    Stacktrace s0;\n+    VERIFY( s0.empty() );\n+    VERIFY( s0.size() == 0 );\n+    VERIFY( s0.begin() == s0.end() );\n+\n+    Stacktrace s1(Alloc{});\n+    VERIFY( s1.empty() );\n+    VERIFY( s1.size() == 0 );\n+    VERIFY( s1.begin() == s1.end() );\n+\n+    VERIFY( s0 == s1 );\n+\n+    Stacktrace s2(s0);\n+    VERIFY( s2 == s0 );\n+\n+    const Stacktrace curr = Stacktrace::current();\n+\n+    Stacktrace s3(curr);\n+    VERIFY( ! s3.empty() );\n+    VERIFY( s3.size() != 0 );\n+    VERIFY( s3.begin() != s3.end() );\n+    VERIFY( s3 != s0 );\n+\n+    Stacktrace s4(s3);\n+    VERIFY( ! s4.empty() );\n+    VERIFY( s4.size() != 0 );\n+    VERIFY( s4.begin() != s4.end() );\n+    VERIFY( s4 == s3 );\n+    VERIFY( s4 != s0 );\n+\n+    Stacktrace s5(std::move(s3));\n+    VERIFY( ! s5.empty() );\n+    VERIFY( s5.size() != 0 );\n+    VERIFY( s5.begin() != s5.end() );\n+    VERIFY( s5 == s4 );\n+    VERIFY( s5 != s0 );\n+    VERIFY( s3 == s0 );\n+\n+    Stacktrace s6(s4, Alloc{});\n+    VERIFY( s6 == s4 );\n+\n+    Stacktrace s7(std::move(s6), Alloc{});\n+    VERIFY( s7 == s4 );\n+  }\n+\n+  {\n+    using Alloc = __gnu_test::uneq_allocator<std::stacktrace_entry>;\n+    using Stacktrace = std::basic_stacktrace<Alloc>;\n+\n+    Stacktrace s0;\n+    VERIFY( s0.empty() );\n+    VERIFY( s0.size() == 0 );\n+    VERIFY( s0.begin() == s0.end() );\n+\n+    Stacktrace s1(Alloc{});\n+    VERIFY( s1.empty() );\n+    VERIFY( s1.size() == 0 );\n+    VERIFY( s1.begin() == s1.end() );\n+\n+    VERIFY( s0 == s1 );\n+\n+    Stacktrace s2(s0);\n+    VERIFY( s2 == s0 );\n+\n+    const Stacktrace curr = Stacktrace::current();\n+\n+    Stacktrace s3(curr);\n+    VERIFY( ! s3.empty() );\n+    VERIFY( s3.size() != 0 );\n+    VERIFY( s3.begin() != s3.end() );\n+    VERIFY( s3 != s0 );\n+\n+    Stacktrace s4(s3);\n+    VERIFY( ! s4.empty() );\n+    VERIFY( s4.size() != 0 );\n+    VERIFY( s4.begin() != s4.end() );\n+    VERIFY( s4 == s3 );\n+    VERIFY( s4 != s0 );\n+\n+    Stacktrace s5(std::move(s3));\n+    VERIFY( ! s5.empty() );\n+    VERIFY( s5.size() != 0 );\n+    VERIFY( s5.begin() != s5.end() );\n+    VERIFY( s5 == s4 );\n+    VERIFY( s5 != s0 );\n+    VERIFY( s3 == s0 );\n+\n+    // TODO test allocator-extended copy/move\n+\n+    // TODO test allocator propagation\n+  }\n+}\n+\n+\n+void\n+test_assign()\n+{\n+  {\n+    using Stacktrace = std::stacktrace;\n+\n+    Stacktrace s0;\n+    s0 = s0;\n+    VERIFY( s0.empty() );\n+    s0 = std::move(s0);\n+    VERIFY( s0.empty() );\n+\n+    Stacktrace s1 = Stacktrace::current();\n+    VERIFY( s1 != s0 );\n+    s0 = s1;\n+    VERIFY( s0 == s1 );\n+    VERIFY( s0.at(0).source_line() == (__LINE__ - 4) );\n+\n+    s1 = Stacktrace::current();\n+    VERIFY( s1 != s0 );\n+    Stacktrace s2 = s0;\n+    Stacktrace s3 = s1;\n+    s0 = std::move(s1);\n+    VERIFY( s0 == s3 );\n+    VERIFY( s1 == s2 ); // ISO C++: valid but unspecified; GCC: swapped.\n+  }\n+\n+  {\n+    using Alloc = __gnu_test::uneq_allocator<std::stacktrace_entry>;\n+    using Stacktrace = std::basic_stacktrace<Alloc>;\n+\n+    Stacktrace s0;\n+    s0 = s0;\n+    VERIFY( s0.empty() );\n+    s0 = std::move(s0);\n+    VERIFY( s0.empty() );\n+\n+    Stacktrace s1 = Stacktrace::current();\n+    VERIFY( s1 != s0 );\n+    s0 = s1;\n+    VERIFY( s0 == s1 );\n+\n+    s1 = Stacktrace::current(Alloc(__LINE__));\n+    VERIFY( s1 != s0 );\n+    s0 = std::move(s1);\n+    VERIFY( s0.at(0).source_line() == s0.get_allocator().get_personality() );\n+    VERIFY( s1.empty() ); // ISO C++: valid but unspecified; GCC: empty.\n+\n+    Stacktrace s2 = Stacktrace::current(s0.get_allocator());\n+    Stacktrace s3 = s2;\n+    s2 = std::move(s0);\n+    VERIFY( s2.at(0).source_line() == s2.get_allocator().get_personality() );\n+    VERIFY( s0 == s3 ); // ISO C++: valid but unspecified, GCC: swapped.\n+  }\n+}\n+\n+void\n+test_swap()\n+{\n+  {\n+    using Stacktrace = std::stacktrace;\n+\n+    Stacktrace s0;\n+    Stacktrace s1 = Stacktrace::current();\n+    swap(s0, s1);\n+    VERIFY( s1.empty() );\n+    VERIFY( ! s0.empty() );\n+  }\n+\n+  {\n+    using Alloc = __gnu_test::uneq_allocator<std::stacktrace_entry>;\n+    using Stacktrace = std::basic_stacktrace<Alloc>;\n+\n+    Stacktrace s0;\n+    Stacktrace s1 = Stacktrace::current();\n+    swap(s0, s1);\n+    VERIFY( s1.empty() );\n+    VERIFY( ! s0.empty() );\n+\n+    // TODO test allocator propagation\n+  }\n+}\n+\n+void\n+test_pr105031()\n+{\n+  // PR libstdc++/105031\n+  // wrong constexpr if statement in operator=(basic_stacktrace&&)\n+  using Alloc = __gnu_test::uneq_allocator<std::stacktrace_entry>;\n+  std::basic_stacktrace<Alloc> s;\n+  s = auto(s);\n+}\n+\n+int main()\n+{\n+  test_cons();\n+  test_assign();\n+  test_swap();\n+  test_pr105031();\n+}"}]}