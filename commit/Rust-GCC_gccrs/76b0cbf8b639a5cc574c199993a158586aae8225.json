{"sha": "76b0cbf8b639a5cc574c199993a158586aae8225", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZiMGNiZjhiNjM5YTVjYzU3NGMxOTk5OTNhMTU4NTg2YWFlODIyNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-04T10:50:38Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-04T10:50:38Z"}, "message": "Turn FUNCTION_ARG_PADDING into a target hook\n\nThis involved renaming the rather general-sounding \"enum direction\" to\n\"enum pad_direction\" to avoid a conflict with the Fortran frontend.\n\n2017-09-04  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* coretypes.h (pad_direction): New enum.\n\t* defaults.h (DEFAULT_FUNCTION_ARG_PADDING): Delete.\n\t(FUNCTION_ARG_PADDING): Likewise.\n\t* target.def (function_arg_padding): New hook.\n\t* targhooks.h (default_function_arg_padding): Declare.\n\t* targhooks.c (default_function_arg_padding): New function.\n\t* doc/tm.texi.in (FUNCTION_ARG_PADDING): Replace with...\n\t(TARGET_FUNCTION_ARG_PADDING): ...this.\n\t* doc/tm.texi: Regenerate.\n\t* calls.c (store_unaligned_arguments_into_pseudos): Use pad_direction\n\tinstead of direction.\n\t(compute_argument_addresses): Likewise.\n\t(load_register_parameters): Likewise.\n\t(emit_library_call_value_1): Likewise.\n\t(store_one_arg): Use targetm.calls.function_arg_padding instead\n\tof FUNCTION_ARG_PADDING.\n\t(must_pass_in_stack_var_size_or_pad): Likewise.\n\t* expr.c (emit_group_load_1): Use pad_direction instead of direction.\n\t(emit_group_store): Likewise.\n\t(emit_single_push_insn_1): Use targetm.calls.function_arg_padding\n\tinstead of FUNCTION_ARG_PADDING.\n\t(emit_push_insn): Likewise, and propagate enum change throughout\n\tfunction.\n\t* function.h (direction): Delete.\n\t(locate_and_pad_arg_data::where_pad): Use pad_direction instead\n\tof direction.\n\t* function.c (assign_parm_find_stack_rtl): Likewise.\n\t(assign_parm_setup_block_p): Likewise.\n\t(assign_parm_setup_block): Likewise.\n\t(gimplify_parameters): Likewise.\n\t(locate_and_pad_parm): Use targetm.calls.function_arg_padding\n\tinstead of FUNCTION_ARG_PADDING, and propagate enum change throughout\n\tfunction.\n\t* config/aarch64/aarch64.h (FUNCTION_ARG_PADDING): Delete.\n\t(BLOCK_REG_PADDING): Use pad_direction instead of direction.\n\t* config/aarch64/aarch64-protos.h (aarch64_pad_arg_upward): Delete.\n\t* config/aarch64/aarch64.c (aarch64_pad_arg_upward): Replace with...\n\t(aarch64_function_arg_padding): ...this new function.\n\t(aarch64_gimplify_va_arg_expr): Use pad_direction instead of direction.\n\t(TARGET_FUNCTION_ARG_PADDING): Redefine.\n\t* config/arm/arm.h (FUNCTION_ARG_PADDING): Delete.\n\t(BLOCK_REG_PADDING): Use pad_direction instead of direction.\n\t* config/arm/arm-protos.h (arm_pad_arg_upward): Delete.\n\t* config/arm/arm.c (TARGET_FUNCTION_ARG_PADDING): Redefine.\n\t(arm_pad_arg_upward): Replace with...\n\t(arm_function_arg_padding): ...this new function.\n\t* config/c6x/c6x.h (BLOCK_REG_PADDING): Use pad_direction instead\n\tof direction.\n\t* config/ia64/hpux.h (FUNCTION_ARG_PADDING): Delete.\n\t* config/ia64/ia64-protos.h (ia64_hpux_function_arg_padding): Delete.\n\t* config/ia64/ia64.c (TARGET_FUNCTION_ARG_PADDING): Redefine.\n\t(ia64_hpux_function_arg_padding): Replace with...\n\t(ia64_function_arg_padding): ...this new function.  Use pad_direction\n\tinstead of direction.  Check for TARGET_HPUX.\n\t* config/iq2000/iq2000.h (FUNCTION_ARG_PADDING): Delete.\n\t* config/iq2000/iq2000.c (TARGET_FUNCTION_ARG_PADDING): Redefine.\n\t(iq2000_function_arg_padding): New function.\n\t* config/mips/mips-protos.h (mips_pad_arg_upward): Delete.\n\t* config/mips/mips.c (mips_pad_arg_upward): Replace with...\n\t(mips_function_arg_padding): ...this new function.\n\t(mips_pad_reg_upward): Update accordingly.\n\t(TARGET_FUNCTION_ARG_PADDING): Redefine.\n\t* config/mips/mips.h (PAD_VARARGS_DOWN): Use\n\ttargetm.calls.function_arg_padding.\n\t(FUNCTION_ARG_PADDING): Delete.\n\t(BLOCK_REG_PADDING): Use pad_direction instead of direction.\n\t* config/nios2/nios2.h (FUNCTION_ARG_PADDING): Delete.\n\t(PAD_VARARGS_DOWN): Use targetm.calls.function_arg_padding.\n\t* config/nios2/nios2-protos.h (nios2_function_arg_padding): Delete.\n\t(nios2_block_reg_padding): Return pad_direction instead of direction.\n\t* config/nios2/nios2.c (nios2_block_reg_padding): Return pad_direction\n\tinstead of direction.\n\t(nios2_function_arg_padding): Likewise.  Make static.\n\t(TARGET_FUNCTION_ARG_PADDING): Redefine.\n\t* config/pa/pa.h (FUNCTION_ARG_PADDING): Delete.\n\t(BLOCK_REG_PADDING): Use targetm.calls.function_arg_padding.\n\t* config/pa/pa-protos.h (pa_function_arg_padding): Delete.\n\t* config/pa/pa.c (TARGET_FUNCTION_ARG_PADDING): Redefine.\n\t(pa_function_arg_padding): Make static.  Return pad_direction instead\n\tof direction.\n\t* config/powerpcspe/powerpcspe.h (FUNCTION_ARG_PADDING): Delete.\n\t(PAD_VARARGS_DOWN): Use targetm.calls.function_arg_padding.\n\t* config/powerpcspe/aix.h (BLOCK_REG_PADDING): Use pad_direction\n\tinstead of direction.  Use targetm.calls.function_arg_padding.\n\t* config/powerpcspe/darwin.h (BLOCK_REG_PADDING): Likewise.\n\t* config/powerpcspe/freebsd64.h (BLOCK_REG_PADDING): Likewise.\n\t* config/powerpcspe/linux64.h (BLOCK_REG_PADDING): Likewise.\n\t* config/powerpcspe/powerpcspe-protos.h (function_arg_padding): Delete.\n\t* config/powerpcspe/powerpcspe.c (TARGET_FUNCTION_ARG_PADDING):\n\tRedefine.\n\t(function_arg_padding): Rename to...\n\t(rs6000_function_arg_padding): ...this.  Make static.  Return\n\tpad_direction instead of direction.\n\t(rs6000_return_in_msb): Use rs6000_function_arg_padding.\n\t* config/rs6000/rs6000.h (FUNCTION_ARG_PADDING): Delete.\n\t(PAD_VARARGS_DOWN): Use targetm.calls.function_arg_padding.\n\t* config/rs6000/aix.h (BLOCK_REG_PADDING): Use pad_direction\n\tinstead of direction.  Use targetm.calls.function_arg_padding.\n\t* config/rs6000/darwin.h (BLOCK_REG_PADDING): Likewise.\n\t* config/rs6000/freebsd64.h (BLOCK_REG_PADDING): Likewise.\n\t* config/rs6000/linux64.h (BLOCK_REG_PADDING): Likewise.\n\t* config/rs6000/rs6000-protos.h (function_arg_padding): Delete.\n\t* config/rs6000/rs6000.c (TARGET_FUNCTION_ARG_PADDING): Redefine.\n\t(function_arg_padding): Rename to...\n\t(rs6000_function_arg_padding): ...this.  Make static.  Return\n\tpad_direction instead of direction.\n\t(rs6000_return_in_msb): Use rs6000_function_arg_padding.\n\t* config/s390/s390.h (FUNCTION_ARG_PADDING): Delete.\n\t* config/s390/s390.c (s390_function_arg_padding): New function.\n\t(TARGET_FUNCTION_ARG_PADDING): Redefine.\n\t* config/sparc/sparc.h (FUNCTION_ARG_PADDING): Delete.\n\t* config/sparc/sparc-protos.h (function_arg_padding): Delete.\n\t* config/sparc/sparc.c (TARGET_FUNCTION_ARG_PADDING): Redefine.\n\t(function_arg_padding): Rename to...\n\t(sparc_function_arg_padding): ...this.  Make static.  Return\n\tpad_direction instead of direction.\n\t* config/spu/spu.h (FUNCTION_ARG_PADDING): Delete.\n\t* config/spu/spu.c (spu_function_arg_padding): New function.\n\t(TARGET_FUNCTION_ARG_PADDING): Redefine.\n\t* system.h (FUNCTION_ARG_PADDING): Poison.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251648", "tree": {"sha": "b60ab368921a9b928ff81800a96afd5d8d8655f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b60ab368921a9b928ff81800a96afd5d8d8655f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76b0cbf8b639a5cc574c199993a158586aae8225", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76b0cbf8b639a5cc574c199993a158586aae8225", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76b0cbf8b639a5cc574c199993a158586aae8225", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76b0cbf8b639a5cc574c199993a158586aae8225/comments", "author": null, "committer": null, "parents": [{"sha": "99e1629ff116e2e1aa37a14aa0d15b4533068927", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99e1629ff116e2e1aa37a14aa0d15b4533068927", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99e1629ff116e2e1aa37a14aa0d15b4533068927"}], "stats": {"total": 709, "additions": 418, "deletions": 291}, "files": [{"sha": "238317ea25ec71a3012d22358306fc7d5e24e67f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -1,3 +1,128 @@\n+2017-09-04  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* coretypes.h (pad_direction): New enum.\n+\t* defaults.h (DEFAULT_FUNCTION_ARG_PADDING): Delete.\n+\t(FUNCTION_ARG_PADDING): Likewise.\n+\t* target.def (function_arg_padding): New hook.\n+\t* targhooks.h (default_function_arg_padding): Declare.\n+\t* targhooks.c (default_function_arg_padding): New function.\n+\t* doc/tm.texi.in (FUNCTION_ARG_PADDING): Replace with...\n+\t(TARGET_FUNCTION_ARG_PADDING): ...this.\n+\t* doc/tm.texi: Regenerate.\n+\t* calls.c (store_unaligned_arguments_into_pseudos): Use pad_direction\n+\tinstead of direction.\n+\t(compute_argument_addresses): Likewise.\n+\t(load_register_parameters): Likewise.\n+\t(emit_library_call_value_1): Likewise.\n+\t(store_one_arg): Use targetm.calls.function_arg_padding instead\n+\tof FUNCTION_ARG_PADDING.\n+\t(must_pass_in_stack_var_size_or_pad): Likewise.\n+\t* expr.c (emit_group_load_1): Use pad_direction instead of direction.\n+\t(emit_group_store): Likewise.\n+\t(emit_single_push_insn_1): Use targetm.calls.function_arg_padding\n+\tinstead of FUNCTION_ARG_PADDING.\n+\t(emit_push_insn): Likewise, and propagate enum change throughout\n+\tfunction.\n+\t* function.h (direction): Delete.\n+\t(locate_and_pad_arg_data::where_pad): Use pad_direction instead\n+\tof direction.\n+\t* function.c (assign_parm_find_stack_rtl): Likewise.\n+\t(assign_parm_setup_block_p): Likewise.\n+\t(assign_parm_setup_block): Likewise.\n+\t(gimplify_parameters): Likewise.\n+\t(locate_and_pad_parm): Use targetm.calls.function_arg_padding\n+\tinstead of FUNCTION_ARG_PADDING, and propagate enum change throughout\n+\tfunction.\n+\t* config/aarch64/aarch64.h (FUNCTION_ARG_PADDING): Delete.\n+\t(BLOCK_REG_PADDING): Use pad_direction instead of direction.\n+\t* config/aarch64/aarch64-protos.h (aarch64_pad_arg_upward): Delete.\n+\t* config/aarch64/aarch64.c (aarch64_pad_arg_upward): Replace with...\n+\t(aarch64_function_arg_padding): ...this new function.\n+\t(aarch64_gimplify_va_arg_expr): Use pad_direction instead of direction.\n+\t(TARGET_FUNCTION_ARG_PADDING): Redefine.\n+\t* config/arm/arm.h (FUNCTION_ARG_PADDING): Delete.\n+\t(BLOCK_REG_PADDING): Use pad_direction instead of direction.\n+\t* config/arm/arm-protos.h (arm_pad_arg_upward): Delete.\n+\t* config/arm/arm.c (TARGET_FUNCTION_ARG_PADDING): Redefine.\n+\t(arm_pad_arg_upward): Replace with...\n+\t(arm_function_arg_padding): ...this new function.\n+\t* config/c6x/c6x.h (BLOCK_REG_PADDING): Use pad_direction instead\n+\tof direction.\n+\t* config/ia64/hpux.h (FUNCTION_ARG_PADDING): Delete.\n+\t* config/ia64/ia64-protos.h (ia64_hpux_function_arg_padding): Delete.\n+\t* config/ia64/ia64.c (TARGET_FUNCTION_ARG_PADDING): Redefine.\n+\t(ia64_hpux_function_arg_padding): Replace with...\n+\t(ia64_function_arg_padding): ...this new function.  Use pad_direction\n+\tinstead of direction.  Check for TARGET_HPUX.\n+\t* config/iq2000/iq2000.h (FUNCTION_ARG_PADDING): Delete.\n+\t* config/iq2000/iq2000.c (TARGET_FUNCTION_ARG_PADDING): Redefine.\n+\t(iq2000_function_arg_padding): New function.\n+\t* config/mips/mips-protos.h (mips_pad_arg_upward): Delete.\n+\t* config/mips/mips.c (mips_pad_arg_upward): Replace with...\n+\t(mips_function_arg_padding): ...this new function.\n+\t(mips_pad_reg_upward): Update accordingly.\n+\t(TARGET_FUNCTION_ARG_PADDING): Redefine.\n+\t* config/mips/mips.h (PAD_VARARGS_DOWN): Use\n+\ttargetm.calls.function_arg_padding.\n+\t(FUNCTION_ARG_PADDING): Delete.\n+\t(BLOCK_REG_PADDING): Use pad_direction instead of direction.\n+\t* config/nios2/nios2.h (FUNCTION_ARG_PADDING): Delete.\n+\t(PAD_VARARGS_DOWN): Use targetm.calls.function_arg_padding.\n+\t* config/nios2/nios2-protos.h (nios2_function_arg_padding): Delete.\n+\t(nios2_block_reg_padding): Return pad_direction instead of direction.\n+\t* config/nios2/nios2.c (nios2_block_reg_padding): Return pad_direction\n+\tinstead of direction.\n+\t(nios2_function_arg_padding): Likewise.  Make static.\n+\t(TARGET_FUNCTION_ARG_PADDING): Redefine.\n+\t* config/pa/pa.h (FUNCTION_ARG_PADDING): Delete.\n+\t(BLOCK_REG_PADDING): Use targetm.calls.function_arg_padding.\n+\t* config/pa/pa-protos.h (pa_function_arg_padding): Delete.\n+\t* config/pa/pa.c (TARGET_FUNCTION_ARG_PADDING): Redefine.\n+\t(pa_function_arg_padding): Make static.  Return pad_direction instead\n+\tof direction.\n+\t* config/powerpcspe/powerpcspe.h (FUNCTION_ARG_PADDING): Delete.\n+\t(PAD_VARARGS_DOWN): Use targetm.calls.function_arg_padding.\n+\t* config/powerpcspe/aix.h (BLOCK_REG_PADDING): Use pad_direction\n+\tinstead of direction.  Use targetm.calls.function_arg_padding.\n+\t* config/powerpcspe/darwin.h (BLOCK_REG_PADDING): Likewise.\n+\t* config/powerpcspe/freebsd64.h (BLOCK_REG_PADDING): Likewise.\n+\t* config/powerpcspe/linux64.h (BLOCK_REG_PADDING): Likewise.\n+\t* config/powerpcspe/powerpcspe-protos.h (function_arg_padding): Delete.\n+\t* config/powerpcspe/powerpcspe.c (TARGET_FUNCTION_ARG_PADDING):\n+\tRedefine.\n+\t(function_arg_padding): Rename to...\n+\t(rs6000_function_arg_padding): ...this.  Make static.  Return\n+\tpad_direction instead of direction.\n+\t(rs6000_return_in_msb): Use rs6000_function_arg_padding.\n+\t* config/rs6000/rs6000.h (FUNCTION_ARG_PADDING): Delete.\n+\t(PAD_VARARGS_DOWN): Use targetm.calls.function_arg_padding.\n+\t* config/rs6000/aix.h (BLOCK_REG_PADDING): Use pad_direction\n+\tinstead of direction.  Use targetm.calls.function_arg_padding.\n+\t* config/rs6000/darwin.h (BLOCK_REG_PADDING): Likewise.\n+\t* config/rs6000/freebsd64.h (BLOCK_REG_PADDING): Likewise.\n+\t* config/rs6000/linux64.h (BLOCK_REG_PADDING): Likewise.\n+\t* config/rs6000/rs6000-protos.h (function_arg_padding): Delete.\n+\t* config/rs6000/rs6000.c (TARGET_FUNCTION_ARG_PADDING): Redefine.\n+\t(function_arg_padding): Rename to...\n+\t(rs6000_function_arg_padding): ...this.  Make static.  Return\n+\tpad_direction instead of direction.\n+\t(rs6000_return_in_msb): Use rs6000_function_arg_padding.\n+\t* config/s390/s390.h (FUNCTION_ARG_PADDING): Delete.\n+\t* config/s390/s390.c (s390_function_arg_padding): New function.\n+\t(TARGET_FUNCTION_ARG_PADDING): Redefine.\n+\t* config/sparc/sparc.h (FUNCTION_ARG_PADDING): Delete.\n+\t* config/sparc/sparc-protos.h (function_arg_padding): Delete.\n+\t* config/sparc/sparc.c (TARGET_FUNCTION_ARG_PADDING): Redefine.\n+\t(function_arg_padding): Rename to...\n+\t(sparc_function_arg_padding): ...this.  Make static.  Return\n+\tpad_direction instead of direction.\n+\t* config/spu/spu.h (FUNCTION_ARG_PADDING): Delete.\n+\t* config/spu/spu.c (spu_function_arg_padding): New function.\n+\t(TARGET_FUNCTION_ARG_PADDING): Redefine.\n+\t* system.h (FUNCTION_ARG_PADDING): Poison.\n+\n 2017-09-04  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "e7572343ba89cbcb3e56ad5c16840b4d2515aaa6", "filename": "gcc/calls.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -1154,7 +1154,7 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n #ifdef BLOCK_REG_PADDING\n \t    && (BLOCK_REG_PADDING (args[i].mode,\n \t\t\t\t   TREE_TYPE (args[i].tree_value), 1)\n-\t\t== downward)\n+\t\t== PAD_DOWNWARD)\n #else\n \t    && BYTES_BIG_ENDIAN\n #endif\n@@ -2222,7 +2222,7 @@ compute_argument_addresses (struct arg_data *args, rtx argblock, int num_actuals\n \t    }\n \t  align = BITS_PER_UNIT;\n \t  boundary = args[i].locate.boundary;\n-\t  if (args[i].locate.where_pad != downward)\n+\t  if (args[i].locate.where_pad != PAD_DOWNWARD)\n \t    align = boundary;\n \t  else if (CONST_INT_P (offset))\n \t    {\n@@ -2519,7 +2519,7 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t\t upward on a BYTES_BIG_ENDIAN machine.  */\n \t      if (size < UNITS_PER_WORD\n \t\t  && (args[i].locate.where_pad\n-\t\t      == (BYTES_BIG_ENDIAN ? upward : downward)))\n+\t\t      == (BYTES_BIG_ENDIAN ? PAD_UPWARD : PAD_DOWNWARD)))\n \t\t{\n \t\t  rtx x;\n \t\t  int shift = (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n@@ -2580,7 +2580,7 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t      /* Handle a BLKmode that needs shifting.  */\n \t      if (nregs == 1 && size < UNITS_PER_WORD\n #ifdef BLOCK_REG_PADDING\n-\t\t  && args[i].locate.where_pad == downward\n+\t\t  && args[i].locate.where_pad == PAD_DOWNWARD\n #else\n \t\t  && BYTES_BIG_ENDIAN\n #endif\n@@ -4919,7 +4919,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t     upward on a BYTES_BIG_ENDIAN machine.  */\n \t  if (size < UNITS_PER_WORD\n \t      && (argvec[argnum].locate.where_pad\n-\t\t  == (BYTES_BIG_ENDIAN ? upward : downward)))\n+\t\t  == (BYTES_BIG_ENDIAN ? PAD_UPWARD : PAD_DOWNWARD)))\n \t    {\n \t      rtx x;\n \t      int shift = (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n@@ -5397,14 +5397,16 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \n       /* Compute how much space the argument should get:\n \t round up to a multiple of the alignment for arguments.  */\n-      if (none != FUNCTION_ARG_PADDING (arg->mode, TREE_TYPE (pval)))\n+      if (targetm.calls.function_arg_padding (arg->mode, TREE_TYPE (pval))\n+\t  != PAD_NONE)\n \tused = (((size + PARM_BOUNDARY / BITS_PER_UNIT - 1)\n \t\t / (PARM_BOUNDARY / BITS_PER_UNIT))\n \t\t* (PARM_BOUNDARY / BITS_PER_UNIT));\n \n       /* Compute the alignment of the pushed argument.  */\n       parm_align = arg->locate.boundary;\n-      if (FUNCTION_ARG_PADDING (arg->mode, TREE_TYPE (pval)) == downward)\n+      if (targetm.calls.function_arg_padding (arg->mode, TREE_TYPE (pval))\n+\t  == PAD_DOWNWARD)\n \t{\n \t  int pad = used - size;\n \t  if (pad)\n@@ -5463,7 +5465,8 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \n       /* When an argument is padded down, the block is aligned to\n \t PARM_BOUNDARY, but the actual argument isn't.  */\n-      if (FUNCTION_ARG_PADDING (arg->mode, TREE_TYPE (pval)) == downward)\n+      if (targetm.calls.function_arg_padding (arg->mode, TREE_TYPE (pval))\n+\t  == PAD_DOWNWARD)\n \t{\n \t  if (arg->locate.size.var)\n \t    parm_align = BITS_PER_UNIT;\n@@ -5614,8 +5617,8 @@ must_pass_in_stack_var_size_or_pad (machine_mode mode, const_tree type)\n      a register would put it into the wrong part of the register.  */\n   if (mode == BLKmode\n       && int_size_in_bytes (type) % (PARM_BOUNDARY / BITS_PER_UNIT)\n-      && (FUNCTION_ARG_PADDING (mode, type)\n-\t  == (BYTES_BIG_ENDIAN ? upward : downward)))\n+      && (targetm.calls.function_arg_padding (mode, type)\n+\t  == (BYTES_BIG_ENDIAN ? PAD_UPWARD : PAD_DOWNWARD)))\n     return true;\n \n   return false;"}, {"sha": "a2debe1bf7fd5e7ef3107360f2ece4d2b6ca977e", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -347,7 +347,6 @@ rtx aarch64_reverse_mask (machine_mode);\n bool aarch64_offset_7bit_signed_scaled_p (machine_mode, HOST_WIDE_INT);\n char *aarch64_output_scalar_simd_mov_immediate (rtx, machine_mode);\n char *aarch64_output_simd_mov_immediate (rtx, machine_mode, unsigned);\n-bool aarch64_pad_arg_upward (machine_mode, const_tree);\n bool aarch64_pad_reg_upward (machine_mode, const_tree, bool);\n bool aarch64_regno_ok_for_base_p (int, bool);\n bool aarch64_regno_ok_for_index_p (int, bool);"}, {"sha": "65a8df1a1ff47952a2047d78957e445b4f18b7df", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -2593,22 +2593,19 @@ aarch64_function_arg_boundary (machine_mode mode, const_tree type)\n   return MIN (MAX (alignment, PARM_BOUNDARY), STACK_BOUNDARY);\n }\n \n-/* For use by FUNCTION_ARG_PADDING (MODE, TYPE).\n-\n-   Return true if an argument passed on the stack should be padded upwards,\n-   i.e. if the least-significant byte of the stack slot has useful data.\n+/* Implement TARGET_FUNCTION_ARG_PADDING.\n \n    Small aggregate types are placed in the lowest memory address.\n \n    The related parameter passing rules are B.4, C.3, C.5 and C.14.  */\n \n-bool\n-aarch64_pad_arg_upward (machine_mode mode, const_tree type)\n+static pad_direction\n+aarch64_function_arg_padding (machine_mode mode, const_tree type)\n {\n   /* On little-endian targets, the least significant byte of every stack\n      argument is passed at the lowest byte address of the stack slot.  */\n   if (!BYTES_BIG_ENDIAN)\n-    return true;\n+    return PAD_UPWARD;\n \n   /* Otherwise, integral, floating-point and pointer types are padded downward:\n      the least significant byte of a stack argument is passed at the highest\n@@ -2617,10 +2614,10 @@ aarch64_pad_arg_upward (machine_mode mode, const_tree type)\n       ? (INTEGRAL_TYPE_P (type) || SCALAR_FLOAT_TYPE_P (type)\n \t || POINTER_TYPE_P (type))\n       : (SCALAR_INT_MODE_P (mode) || SCALAR_FLOAT_MODE_P (mode)))\n-    return false;\n+    return PAD_DOWNWARD;\n \n   /* Everything else padded upward, i.e. data in first byte of stack slot.  */\n-  return true;\n+  return PAD_UPWARD;\n }\n \n /* Similarly, for use by BLOCK_REG_PADDING (MODE, TYPE, FIRST).\n@@ -10633,7 +10630,7 @@ aarch64_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n \t  if (BYTES_BIG_ENDIAN && GET_MODE_SIZE (ag_mode) < UNITS_PER_VREG)\n \t    adjust = UNITS_PER_VREG - GET_MODE_SIZE (ag_mode);\n \t}\n-      else if (BLOCK_REG_PADDING (mode, type, 1) == downward\n+      else if (BLOCK_REG_PADDING (mode, type, 1) == PAD_DOWNWARD\n \t       && size < UNITS_PER_VREG)\n \t{\n \t  adjust = UNITS_PER_VREG - size;\n@@ -10652,7 +10649,7 @@ aarch64_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n       if (align > 8)\n \tdw_align = true;\n \n-      if (BLOCK_REG_PADDING (mode, type, 1) == downward\n+      if (BLOCK_REG_PADDING (mode, type, 1) == PAD_DOWNWARD\n \t  && size < UNITS_PER_WORD)\n \t{\n \t  adjust = UNITS_PER_WORD  - size;\n@@ -10727,7 +10724,7 @@ aarch64_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n   /* String up with arg */\n   on_stack = build2 (COMPOUND_EXPR, TREE_TYPE (arg), t, arg);\n   /* Big-endianness related address adjustment.  */\n-  if (BLOCK_REG_PADDING (mode, type, 1) == downward\n+  if (BLOCK_REG_PADDING (mode, type, 1) == PAD_DOWNWARD\n       && size < UNITS_PER_WORD)\n   {\n     t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (arg), arg,\n@@ -15385,6 +15382,9 @@ aarch64_run_selftests (void)\n #undef TARGET_FUNCTION_ARG_BOUNDARY\n #define TARGET_FUNCTION_ARG_BOUNDARY aarch64_function_arg_boundary\n \n+#undef TARGET_FUNCTION_ARG_PADDING\n+#define TARGET_FUNCTION_ARG_PADDING aarch64_function_arg_padding\n+\n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL aarch64_function_ok_for_sibcall\n "}, {"sha": "8fada9ed5bfb0e1fe4e392e7de8a0833e99aa74e", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -668,11 +668,8 @@ typedef struct\n } CUMULATIVE_ARGS;\n #endif\n \n-#define FUNCTION_ARG_PADDING(MODE, TYPE) \\\n-  (aarch64_pad_arg_upward (MODE, TYPE) ? upward : downward)\n-\n #define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n-  (aarch64_pad_reg_upward (MODE, TYPE, FIRST) ? upward : downward)\n+  (aarch64_pad_reg_upward (MODE, TYPE, FIRST) ? PAD_UPWARD : PAD_DOWNWARD)\n \n #define PAD_VARARGS_DOWN\t0\n "}, {"sha": "4538078fe60581f239bf99d3c9edbb8a2ab9648c", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -177,7 +177,6 @@ extern bool arm_coproc_ldc_stc_legitimate_address (rtx);\n \n #if defined TREE_CODE\n extern void arm_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n-extern bool arm_pad_arg_upward (machine_mode, const_tree);\n extern bool arm_pad_reg_upward (machine_mode, tree, int);\n #endif\n extern int arm_apply_result_size (void);"}, {"sha": "e31ab608dd346d7bfd4e90b6cc8c9d5c03636808", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -186,6 +186,7 @@ static rtx arm_function_arg (cumulative_args_t, machine_mode,\n \t\t\t     const_tree, bool);\n static void arm_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t      const_tree, bool);\n+static pad_direction arm_function_arg_padding (machine_mode, const_tree);\n static unsigned int arm_function_arg_boundary (machine_mode, const_tree);\n static rtx aapcs_allocate_return_reg (machine_mode, const_tree,\n \t\t\t\t      const_tree);\n@@ -536,6 +537,8 @@ static const struct attribute_spec arm_attribute_table[] =\n #define TARGET_FUNCTION_ARG arm_function_arg\n #undef TARGET_FUNCTION_ARG_ADVANCE\n #define TARGET_FUNCTION_ARG_ADVANCE arm_function_arg_advance\n+#undef TARGET_FUNCTION_ARG_PADDING\n+#define TARGET_FUNCTION_ARG_PADDING arm_function_arg_padding\n #undef TARGET_FUNCTION_ARG_BOUNDARY\n #define TARGET_FUNCTION_ARG_BOUNDARY arm_function_arg_boundary\n \n@@ -15155,22 +15158,21 @@ arm_must_pass_in_stack (machine_mode mode, const_tree type)\n }\n \n \n-/* For use by FUNCTION_ARG_PADDING (MODE, TYPE).\n-   Return true if an argument passed on the stack should be padded upwards,\n-   i.e. if the least-significant byte has useful data.\n-   For legacy APCS ABIs we use the default.  For AAPCS based ABIs small\n-   aggregate types are placed in the lowest memory address.  */\n+/* Implement TARGET_FUNCTION_ARG_PADDING; return PAD_UPWARD if the lowest\n+   byte of a stack argument has useful data.  For legacy APCS ABIs we use\n+   the default.  For AAPCS based ABIs small aggregate types are placed\n+   in the lowest memory address.  */\n \n-bool\n-arm_pad_arg_upward (machine_mode mode ATTRIBUTE_UNUSED, const_tree type)\n+static pad_direction\n+arm_function_arg_padding (machine_mode mode, const_tree type)\n {\n   if (!TARGET_AAPCS_BASED)\n-    return DEFAULT_FUNCTION_ARG_PADDING(mode, type) == upward;\n+    return default_function_arg_padding (mode, type);\n \n   if (type && BYTES_BIG_ENDIAN && INTEGRAL_TYPE_P (type))\n-    return false;\n+    return PAD_DOWNWARD;\n \n-  return true;\n+  return PAD_UPWARD;\n }\n \n "}, {"sha": "5fdb65be6466eb5f4334dd108375b4a69742b7a0", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -1480,11 +1480,8 @@ typedef struct\n } CUMULATIVE_ARGS;\n #endif\n \n-#define FUNCTION_ARG_PADDING(MODE, TYPE) \\\n-  (arm_pad_arg_upward (MODE, TYPE) ? upward : downward)\n-\n #define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n-  (arm_pad_reg_upward (MODE, TYPE, FIRST) ? upward : downward)\n+  (arm_pad_reg_upward (MODE, TYPE, FIRST) ? PAD_UPWARD : PAD_DOWNWARD)\n \n /* For AAPCS, padding should never be below the argument. For other ABIs,\n  * mimic the default.  */"}, {"sha": "d0b98f8ce8c3638882d7af93007c3f8f02c287a9", "filename": "gcc/config/c6x/c6x.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fc6x%2Fc6x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fc6x%2Fc6x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -345,7 +345,7 @@ struct c6x_args {\n   c6x_init_cumulative_args (&cum, fntype, libname, n_named_args)\n \n #define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n-  (c6x_block_reg_pad_upward (MODE, TYPE, FIRST) ? upward : downward)\n+  (c6x_block_reg_pad_upward (MODE, TYPE, FIRST) ? PAD_UPWARD : PAD_DOWNWARD)\n \n #define FUNCTION_ARG_REGNO_P(r) \\\n     (((r) >= REG_A4 && (r) <= REG_A13) || ((r) >= REG_B4 && (r) <= REG_B13))"}, {"sha": "5c8e43fcfbb509d41c5da5ab79a3d62a1c74a092", "filename": "gcc/config/ia64/hpux.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fia64%2Fhpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fia64%2Fhpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fhpux.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -125,10 +125,6 @@ do {\t\t\t\t\t\t\t\t\\\n   ASM_OUTPUT_TYPE_DIRECTIVE (FILE, XSTR (FUN, 0), \"function\");\t\\\n } while (0)\n \n-#undef FUNCTION_ARG_PADDING\n-#define FUNCTION_ARG_PADDING(MODE, TYPE) \\\n-\tia64_hpux_function_arg_padding ((MODE), (TYPE))\n-\n #undef PAD_VARARGS_DOWN\n #define PAD_VARARGS_DOWN (!AGGREGATE_TYPE_P (type))\n "}, {"sha": "cbabbd3b757204d1c10655c639242154f2373f9c", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -89,11 +89,6 @@ extern int ia64_dbx_register_number (int);\n extern rtx ia64_return_addr_rtx (HOST_WIDE_INT, rtx);\n extern void ia64_split_return_addr_rtx (rtx);\n \n-#ifdef ARGS_SIZE_RTX\n-/* expr.h defines ARGS_SIZE_RTX and `enum direction'.  */\n-extern enum direction ia64_hpux_function_arg_padding (machine_mode, const_tree);\n-#endif /* ARGS_SIZE_RTX */\n-\n extern void ia64_hpux_handle_builtin_pragma (struct cpp_reader *);\n extern void ia64_output_function_profiler (FILE *, int);\n extern void ia64_profile_hook (int);"}, {"sha": "8a3c875cd06885d040206d674ae6c383a0b85f29", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -209,6 +209,7 @@ static rtx ia64_function_incoming_arg (cumulative_args_t,\n \t\t\t\t       machine_mode, const_tree, bool);\n static void ia64_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n+static pad_direction ia64_function_arg_padding (machine_mode, const_tree);\n static unsigned int ia64_function_arg_boundary (machine_mode,\n \t\t\t\t\t\tconst_tree);\n static bool ia64_function_ok_for_sibcall (tree, tree);\n@@ -509,6 +510,8 @@ static const struct attribute_spec ia64_attribute_table[] =\n #define TARGET_FUNCTION_INCOMING_ARG ia64_function_incoming_arg\n #undef TARGET_FUNCTION_ARG_ADVANCE\n #define TARGET_FUNCTION_ARG_ADVANCE ia64_function_arg_advance\n+#undef TARGET_FUNCTION_ARG_PADDING\n+#define TARGET_FUNCTION_ARG_PADDING ia64_function_arg_padding\n #undef TARGET_FUNCTION_ARG_BOUNDARY\n #define TARGET_FUNCTION_ARG_BOUNDARY ia64_function_arg_boundary\n \n@@ -10608,20 +10611,23 @@ ia64_builtin_decl (unsigned code, bool initialize_p ATTRIBUTE_UNUSED)\n   return ia64_builtins[code];\n }\n \n-/* For the HP-UX IA64 aggregate parameters are passed stored in the\n+/* Implement TARGET_FUNCTION_ARG_PADDING.\n+\n+   For the HP-UX IA64 aggregate parameters are passed stored in the\n    most significant bits of the stack slot.  */\n \n-enum direction\n-ia64_hpux_function_arg_padding (machine_mode mode, const_tree type)\n+static pad_direction\n+ia64_function_arg_padding (machine_mode mode, const_tree type)\n {\n-   /* Exception to normal case for structures/unions/etc.  */\n-\n-   if (type && AGGREGATE_TYPE_P (type)\n-       && int_size_in_bytes (type) < UNITS_PER_WORD)\n-     return upward;\n+  /* Exception to normal case for structures/unions/etc.  */\n+  if (TARGET_HPUX\n+      && type\n+      && AGGREGATE_TYPE_P (type)\n+      && int_size_in_bytes (type) < UNITS_PER_WORD)\n+    return PAD_UPWARD;\n \n-   /* Fall back to the default.  */\n-   return DEFAULT_FUNCTION_ARG_PADDING (mode, type);\n+  /* Fall back to the default.  */\n+  return default_function_arg_padding (mode, type);\n }\n \n /* Emit text to declare externally defined variables and functions, because"}, {"sha": "460e38d2df165d69c419efb07910fb8c5245e395", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -165,6 +165,7 @@ static rtx iq2000_function_arg\t      (cumulative_args_t,\n \t\t\t\t       machine_mode, const_tree, bool);\n static void iq2000_function_arg_advance (cumulative_args_t,\n \t\t\t\t\t machine_mode, const_tree, bool);\n+static pad_direction iq2000_function_arg_padding (machine_mode, const_tree);\n static unsigned int iq2000_function_arg_boundary (machine_mode,\n \t\t\t\t\t\t  const_tree);\n static void iq2000_va_start\t      (tree, rtx);\n@@ -231,6 +232,8 @@ static bool iq2000_modes_tieable_p (machine_mode, machine_mode);\n #define TARGET_FUNCTION_ARG\t\tiq2000_function_arg\n #undef  TARGET_FUNCTION_ARG_ADVANCE\n #define TARGET_FUNCTION_ARG_ADVANCE\tiq2000_function_arg_advance\n+#undef  TARGET_FUNCTION_ARG_PADDING\n+#define TARGET_FUNCTION_ARG_PADDING\tiq2000_function_arg_padding\n #undef  TARGET_FUNCTION_ARG_BOUNDARY\n #define TARGET_FUNCTION_ARG_BOUNDARY\tiq2000_function_arg_boundary\n \n@@ -1376,6 +1379,22 @@ iq2000_function_arg (cumulative_args_t cum_v, machine_mode mode,\n   return ret;\n }\n \n+/* Implement TARGET_FUNCTION_ARG_PADDING.  */\n+\n+static pad_direction\n+iq2000_function_arg_padding (machine_mode mode, const_tree type)\n+{\n+  return (! BYTES_BIG_ENDIAN\n+\t  ? PAD_UPWARD\n+\t  : ((mode == BLKmode\n+\t      ? (type\n+\t\t && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n+\t\t && int_size_in_bytes (type) < (PARM_BOUNDARY / BITS_PER_UNIT))\n+\t      : (GET_MODE_BITSIZE (mode) < PARM_BOUNDARY\n+\t\t && GET_MODE_CLASS (mode) == MODE_INT))\n+\t     ? PAD_DOWNWARD : PAD_UPWARD));\n+}\n+\n static unsigned int\n iq2000_function_arg_boundary (machine_mode mode, const_tree type)\n {"}, {"sha": "dfb1e1fda2b0c65d527a0ad2cbf90763a58df076", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -308,16 +308,6 @@ typedef struct iq2000_args\n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n   init_cumulative_args (& CUM, FNTYPE, LIBNAME)\t\t\t\t\\\n \n-#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\t\\\n-  (! BYTES_BIG_ENDIAN\t\t\t\t\t\t\t\\\n-   ? upward\t\t\t\t\t\t\t\t\\\n-   : (((MODE) == BLKmode\t\t\t\t\t\t\\\n-       ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST\t\t\\\n-\t  && int_size_in_bytes (TYPE) < (PARM_BOUNDARY / BITS_PER_UNIT))\\\n-       : (GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY\t\t\t\\\n-\t  && (GET_MODE_CLASS (MODE) == MODE_INT)))\t\t\t\\\n-      ? downward : upward))\n-\n #define FUNCTION_ARG_REGNO_P(N)\t\t\t\t\t\t\\\n   (((N) >= GP_ARG_FIRST && (N) <= GP_ARG_LAST))\t\t\t\n "}, {"sha": "139209c44a5660fd61d47f032b73244cdc402155", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -246,7 +246,6 @@ extern bool mips_expand_block_move (rtx, rtx, rtx);\n extern void mips_expand_synci_loop (rtx, rtx);\n \n extern void mips_init_cumulative_args (CUMULATIVE_ARGS *, tree);\n-extern bool mips_pad_arg_upward (machine_mode, const_tree);\n extern bool mips_pad_reg_upward (machine_mode, tree);\n \n extern bool mips_expand_ext_as_unaligned_load (rtx, rtx, HOST_WIDE_INT,"}, {"sha": "4f7d5bd6f41fb6bb01406f0cd405814edc6886ab", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -6117,18 +6117,17 @@ mips_get_reg_raw_mode (int regno)\n   return default_get_reg_raw_mode (regno);\n }\n \n-/* Return true if FUNCTION_ARG_PADDING (MODE, TYPE) should return\n-   upward rather than downward.  In other words, return true if the\n-   first byte of the stack slot has useful data, false if the last\n-   byte does.  */\n+/* Implement TARGET_FUNCTION_ARG_PADDING; return PAD_UPWARD if the first\n+   byte of the stack slot has useful data, PAD_DOWNWARD if the last byte\n+   does.  */\n \n-bool\n-mips_pad_arg_upward (machine_mode mode, const_tree type)\n+static pad_direction\n+mips_function_arg_padding (machine_mode mode, const_tree type)\n {\n   /* On little-endian targets, the first byte of every stack argument\n      is passed in the first byte of the stack slot.  */\n   if (!BYTES_BIG_ENDIAN)\n-    return true;\n+    return PAD_UPWARD;\n \n   /* Otherwise, integral types are padded downward: the last byte of a\n      stack argument is passed in the last byte of the stack slot.  */\n@@ -6138,22 +6137,24 @@ mips_pad_arg_upward (machine_mode mode, const_tree type)\n \t || FIXED_POINT_TYPE_P (type))\n       : (SCALAR_INT_MODE_P (mode)\n \t || ALL_SCALAR_FIXED_POINT_MODE_P (mode)))\n-    return false;\n+    return PAD_DOWNWARD;\n \n   /* Big-endian o64 pads floating-point arguments downward.  */\n   if (mips_abi == ABI_O64)\n     if (type != 0 ? FLOAT_TYPE_P (type) : GET_MODE_CLASS (mode) == MODE_FLOAT)\n-      return false;\n+      return PAD_DOWNWARD;\n \n   /* Other types are padded upward for o32, o64, n32 and n64.  */\n   if (mips_abi != ABI_EABI)\n-    return true;\n+    return PAD_UPWARD;\n \n   /* Arguments smaller than a stack slot are padded downward.  */\n-  if (mode != BLKmode)\n-    return GET_MODE_BITSIZE (mode) >= PARM_BOUNDARY;\n-  else\n-    return int_size_in_bytes (type) >= (PARM_BOUNDARY / BITS_PER_UNIT);\n+  if (mode != BLKmode\n+      ? GET_MODE_BITSIZE (mode) >= PARM_BOUNDARY\n+      : int_size_in_bytes (type) >= (PARM_BOUNDARY / BITS_PER_UNIT))\n+    return PAD_UPWARD;\n+\n+  return PAD_DOWNWARD;\n }\n \n /* Likewise BLOCK_REG_PADDING (MODE, TYPE, ...).  Return !BYTES_BIG_ENDIAN\n@@ -6169,7 +6170,7 @@ mips_pad_reg_upward (machine_mode mode, tree type)\n \n   /* Otherwise, apply the same padding to register arguments as we do\n      to stack arguments.  */\n-  return mips_pad_arg_upward (mode, type);\n+  return mips_function_arg_padding (mode, type) == PAD_UPWARD;\n }\n \n /* Return nonzero when an argument must be passed by reference.  */\n@@ -22459,6 +22460,8 @@ mips_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n #define TARGET_FUNCTION_ARG mips_function_arg\n #undef TARGET_FUNCTION_ARG_ADVANCE\n #define TARGET_FUNCTION_ARG_ADVANCE mips_function_arg_advance\n+#undef TARGET_FUNCTION_ARG_PADDING\n+#define TARGET_FUNCTION_ARG_PADDING mips_function_arg_padding\n #undef TARGET_FUNCTION_ARG_BOUNDARY\n #define TARGET_FUNCTION_ARG_BOUNDARY mips_function_arg_boundary\n #undef TARGET_GET_RAW_RESULT_MODE"}, {"sha": "f598c32bb43ed315bbbf7884331262aa730c5591", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -1679,7 +1679,7 @@ FP_ASM_SPEC \"\\\n   DATA_ALIGNMENT (TYPE, ALIGN)\n   \n #define PAD_VARARGS_DOWN \\\n-  (FUNCTION_ARG_PADDING (TYPE_MODE (type), type) == downward)\n+  (targetm.calls.function_arg_padding (TYPE_MODE (type), type) == PAD_DOWNWARD)\n \n /* Define if operations between registers always perform the operation\n    on the full register even if a narrower mode is specified.  */\n@@ -2521,11 +2521,8 @@ typedef struct mips_args {\n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n   mips_init_cumulative_args (&CUM, FNTYPE)\n \n-#define FUNCTION_ARG_PADDING(MODE, TYPE) \\\n-  (mips_pad_arg_upward (MODE, TYPE) ? upward : downward)\n-\n #define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n-  (mips_pad_reg_upward (MODE, TYPE) ? upward : downward)\n+  (mips_pad_reg_upward (MODE, TYPE) ? PAD_UPWARD : PAD_DOWNWARD)\n \n /* True if using EABI and varargs can be passed in floating-point\n    registers.  Under these conditions, we need a more complex form"}, {"sha": "4478334970ce61e9ea1932edb4bd8aa0a585b5cf", "filename": "gcc/config/nios2/nios2-protos.h", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fnios2%2Fnios2-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fnios2%2Fnios2-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2-protos.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -59,14 +59,8 @@ extern bool gen_ldstwm_peep (bool, int, rtx, rtx *);\n \n extern void nios2_adjust_reg_alloc_order (void);\n \n-#ifdef TREE_CODE\n-#ifdef ARGS_SIZE_RTX\n-/* expr.h defines both ARGS_SIZE_RTX and `enum direction' */\n-extern enum direction nios2_function_arg_padding (machine_mode, const_tree);\n-extern enum direction nios2_block_reg_padding (machine_mode, tree, int);\n-#endif /* ARGS_SIZE_RTX */\n-\n-#endif /* TREE_CODE */\n+extern pad_direction nios2_block_reg_padding (machine_mode, tree, int);\n+\n #endif /* RTX_CODE */\n \n #endif /* GCC_NIOS2_PROTOS_H */"}, {"sha": "893ddd19e59dc25ed3cf33061febe0a878e40748", "filename": "gcc/config/nios2/nios2.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fnios2%2Fnios2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fnios2%2Fnios2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.c?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -2983,30 +2983,31 @@ nios2_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n     cum->regs_used += param_size;\n }\n \n-enum direction\n+static pad_direction\n nios2_function_arg_padding (machine_mode mode, const_tree type)\n {\n   /* On little-endian targets, the first byte of every stack argument\n      is passed in the first byte of the stack slot.  */\n   if (!BYTES_BIG_ENDIAN)\n-    return upward;\n+    return PAD_UPWARD;\n \n   /* Otherwise, integral types are padded downward: the last byte of a\n      stack argument is passed in the last byte of the stack slot.  */\n   if (type != 0\n       ? INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type)\n       : GET_MODE_CLASS (mode) == MODE_INT)\n-    return downward;\n+    return PAD_DOWNWARD;\n \n   /* Arguments smaller than a stack slot are padded downward.  */\n   if (mode != BLKmode)\n-    return (GET_MODE_BITSIZE (mode) >= PARM_BOUNDARY) ? upward : downward;\n+    return (GET_MODE_BITSIZE (mode) >= PARM_BOUNDARY\n+\t    ? PAD_UPWARD : PAD_DOWNWARD);\n \n   return ((int_size_in_bytes (type) >= (PARM_BOUNDARY / BITS_PER_UNIT))\n-\t  ? upward : downward);\n+\t  ? PAD_UPWARD : PAD_DOWNWARD);\n }\n \n-enum direction\n+pad_direction\n nios2_block_reg_padding (machine_mode mode, tree type,\n                          int first ATTRIBUTE_UNUSED)\n {\n@@ -5009,6 +5010,9 @@ nios2_adjust_reg_alloc_order (void)\n #undef TARGET_FUNCTION_ARG_ADVANCE\n #define TARGET_FUNCTION_ARG_ADVANCE nios2_function_arg_advance\n \n+#undef TARGET_FUNCTION_ARG_PADDING\n+#define TARGET_FUNCTION_ARG_PADDING nios2_function_arg_padding\n+\n #undef TARGET_ARG_PARTIAL_BYTES\n #define TARGET_ARG_PARTIAL_BYTES nios2_arg_partial_bytes\n "}, {"sha": "3e26cb67247038801ec3a184878a9b479c2a8ef5", "filename": "gcc/config/nios2/nios2.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fnios2%2Fnios2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fnios2%2Fnios2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -294,11 +294,8 @@ typedef struct nios2_args\n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \\\n   do { (CUM).regs_used = 0; } while (0)\n \n-#define FUNCTION_ARG_PADDING(MODE, TYPE) \\\n-  (nios2_function_arg_padding ((MODE), (TYPE)))\n-\n #define PAD_VARARGS_DOWN \\\n-  (FUNCTION_ARG_PADDING (TYPE_MODE (type), type) == downward)\n+  (targetm.calls.function_arg_padding (TYPE_MODE (type), type) == PAD_DOWNWARD)\n \n #define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n   (nios2_block_reg_padding ((MODE), (TYPE), (FIRST)))"}, {"sha": "ba496f966d55f10c9e7eb1d132e76a137b006060", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -71,12 +71,6 @@ extern rtx pa_legitimize_reload_address (rtx, machine_mode,\n \n extern rtx pa_return_addr_rtx (int, rtx);\n \n-#ifdef ARGS_SIZE_RTX\n-/* expr.h defines ARGS_SIZE_RTX and `enum direction' */\n-#ifdef TREE_CODE\n-extern enum direction pa_function_arg_padding (machine_mode, const_tree);\n-#endif\n-#endif /* ARGS_SIZE_RTX */\n extern int pa_insn_refs_are_delayed (rtx_insn *);\n extern rtx pa_get_deferred_plabel (rtx);\n extern rtx pa_maybe_emit_compare_and_swap_exchange_loop (rtx, rtx, rtx);"}, {"sha": "3ce8b3c141f2da9ed3d3a1513af381a8a1234168", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -172,6 +172,7 @@ static void pa_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t     const_tree, bool);\n static rtx pa_function_arg (cumulative_args_t, machine_mode,\n \t\t\t    const_tree, bool);\n+static pad_direction pa_function_arg_padding (machine_mode, const_tree);\n static unsigned int pa_function_arg_boundary (machine_mode, const_tree);\n static struct machine_function * pa_init_machine_status (void);\n static reg_class_t pa_secondary_reload (bool, rtx, reg_class_t,\n@@ -355,6 +356,8 @@ static size_t n_deferred_plabels = 0;\n #define TARGET_FUNCTION_ARG pa_function_arg\n #undef TARGET_FUNCTION_ARG_ADVANCE\n #define TARGET_FUNCTION_ARG_ADVANCE pa_function_arg_advance\n+#undef TARGET_FUNCTION_ARG_PADDING\n+#define TARGET_FUNCTION_ARG_PADDING pa_function_arg_padding\n #undef TARGET_FUNCTION_ARG_BOUNDARY\n #define TARGET_FUNCTION_ARG_BOUNDARY pa_function_arg_boundary\n \n@@ -6241,7 +6244,9 @@ pa_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n     return size <= 0 || size > 8;\n }\n \n-enum direction\n+/* Implement TARGET_FUNCTION_ARG_PADDING.  */\n+\n+static pad_direction\n pa_function_arg_padding (machine_mode mode, const_tree type)\n {\n   if (mode == BLKmode\n@@ -6251,11 +6256,11 @@ pa_function_arg_padding (machine_mode mode, const_tree type)\n \t      || TREE_CODE (type) == COMPLEX_TYPE\n \t      || TREE_CODE (type) == VECTOR_TYPE)))\n     {\n-      /* Return none if justification is not required.  */\n+      /* Return PAD_NONE if justification is not required.  */\n       if (type\n \t  && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n \t  && (int_size_in_bytes (type) * BITS_PER_UNIT) % PARM_BOUNDARY == 0)\n-\treturn none;\n+\treturn PAD_NONE;\n \n       /* The directions set here are ignored when a BLKmode argument larger\n \t than a word is placed in a register.  Different code is used for\n@@ -6265,18 +6270,18 @@ pa_function_arg_padding (machine_mode mode, const_tree type)\n \t the stack and in registers should be identical.  */\n       if (TARGET_64BIT)\n \t/* The 64-bit runtime specifies left justification for aggregates.  */\n-        return upward;\n+\treturn PAD_UPWARD;\n       else\n \t/* The 32-bit runtime architecture specifies right justification.\n \t   When the argument is passed on the stack, the argument is padded\n \t   with garbage on the left.  The HP compiler pads with zeros.  */\n-\treturn downward;\n+\treturn PAD_DOWNWARD;\n     }\n \n   if (GET_MODE_BITSIZE (mode) < PARM_BOUNDARY)\n-    return downward;\n+    return PAD_DOWNWARD;\n   else\n-    return none;\n+    return PAD_NONE;\n }\n \n \f"}, {"sha": "37881dcfb6722ec0e3480cafdf8008b4d745935a", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -663,11 +663,6 @@ struct hppa_args {int words, nargs_prototype, incoming, indirect; };\n   the standard parameter passing conventions on the RS6000.  That's why\n   you'll see lots of similar code in rs6000.h.  */\n \n-/* If defined, a C expression which determines whether, and in which\n-   direction, to pad out an argument with extra space.  */\n-#define FUNCTION_ARG_PADDING(MODE, TYPE) \\\n-  pa_function_arg_padding ((MODE), (TYPE))\n-\n /* Specify padding for the last element of a block move between registers\n    and memory.\n \n@@ -678,7 +673,7 @@ struct hppa_args {int words, nargs_prototype, incoming, indirect; };\n    so that there is only one element.  This allows the object to be\n    correctly padded.  */\n #define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n-  pa_function_arg_padding ((MODE), (TYPE))\n+  targetm.calls.function_arg_padding ((MODE), (TYPE))\n \n \f\n /* On HPPA, we emit profiling code as rtl via PROFILE_HOOK rather than"}, {"sha": "6c91a90cc0025754dd42695998d00038ca2de837", "filename": "gcc/config/powerpcspe/aix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpowerpcspe%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpowerpcspe%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Faix.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -248,7 +248,7 @@\n    registers and memory.  FIRST is nonzero if this is the only\n    element.  */\n #define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n-  (!(FIRST) ? upward : FUNCTION_ARG_PADDING (MODE, TYPE))\n+  (!(FIRST) ? PAD_UPWARD : targetm.calls.function_arg_padding (MODE, TYPE))\n \n /* Indicate that jump tables go in the text section.  */\n "}, {"sha": "51474ae00c717e925cacfa41823cd2faaaea4384", "filename": "gcc/config/powerpcspe/darwin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpowerpcspe%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpowerpcspe%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fdarwin.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -344,7 +344,7 @@ extern int darwin_emit_branch_islands;\n    registers and memory.  FIRST is nonzero if this is the only\n    element.  */\n #define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n-  (!(FIRST) ? upward : FUNCTION_ARG_PADDING (MODE, TYPE))\n+  (!(FIRST) ? PAD_UPWARD : targetm.calls.function_arg_padding (MODE, TYPE))\n \n #define DOUBLE_INT_ASM_OP \"\\t.quad\\t\"\n "}, {"sha": "f1987918bf8df5c45a014daf63e4cf63ddda554c", "filename": "gcc/config/powerpcspe/freebsd64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpowerpcspe%2Ffreebsd64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpowerpcspe%2Ffreebsd64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Ffreebsd64.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -225,7 +225,7 @@ extern int dot_symbols;\n    registers and memory.  FIRST is nonzero if this is the only\n    element.  */\n #define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n-  (!(FIRST) ? upward : FUNCTION_ARG_PADDING (MODE, TYPE))\n+  (!(FIRST) ? PAD_UPWARD : targetm.calls.function_arg_padding (MODE, TYPE))\n \n /* FreeBSD doesn't support saving and restoring 64-bit regs with a 32-bit\n    kernel. This is supported when running on a 64-bit kernel with"}, {"sha": "88cbeca6fe9c5a5e0cd5fbf706eda616ca876941", "filename": "gcc/config/powerpcspe/linux64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpowerpcspe%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpowerpcspe%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Flinux64.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -340,7 +340,7 @@ extern int dot_symbols;\n    registers and memory.  FIRST is nonzero if this is the only\n    element.  */\n #define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n-  (!(FIRST) ? upward : FUNCTION_ARG_PADDING (MODE, TYPE))\n+  (!(FIRST) ? PAD_UPWARD : targetm.calls.function_arg_padding (MODE, TYPE))\n \n /* Linux doesn't support saving and restoring 64-bit regs in a 32-bit\n    process.  */"}, {"sha": "20587ba17a685017d04f8c55d38cf9eeb4eab1f0", "filename": "gcc/config/powerpcspe/powerpcspe-protos.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-protos.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -196,10 +196,6 @@ extern void rs6000_xcoff_asm_output_aligned_decl_common (FILE *, tree,\n \t\t\t\t\t\t\t unsigned HOST_WIDE_INT);\n extern void rs6000_elf_declare_function_name (FILE *, const char *, tree);\n extern bool rs6000_elf_in_small_data_p (const_tree);\n-#ifdef ARGS_SIZE_RTX\n-/* expr.h defines ARGS_SIZE_RTX and `enum direction' */\n-extern enum direction function_arg_padding (machine_mode, const_tree);\n-#endif /* ARGS_SIZE_RTX */\n \n #endif /* TREE_CODE */\n "}, {"sha": "7dd2170f0a84743e95940e4008586716a31a0240", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -88,6 +88,8 @@\n #define min(A,B)\t((A) < (B) ? (A) : (B))\n #define max(A,B)\t((A) > (B) ? (A) : (B))\n \n+static pad_direction rs6000_function_arg_padding (machine_mode, const_tree);\n+\n /* Structure used to define the rs6000 stack */\n typedef struct rs6000_stack {\n   int reload_completed;\t\t/* stack info won't change from here on */\n@@ -1809,6 +1811,8 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #define TARGET_FUNCTION_ARG_ADVANCE rs6000_function_arg_advance\n #undef TARGET_FUNCTION_ARG\n #define TARGET_FUNCTION_ARG rs6000_function_arg\n+#undef TARGET_FUNCTION_ARG_PADDING\n+#define TARGET_FUNCTION_ARG_PADDING rs6000_function_arg_padding\n #undef TARGET_FUNCTION_ARG_BOUNDARY\n #define TARGET_FUNCTION_ARG_BOUNDARY rs6000_function_arg_boundary\n \n@@ -11813,7 +11817,8 @@ rs6000_return_in_msb (const_tree valtype)\n   return (DEFAULT_ABI == ABI_ELFv2\n \t  && BYTES_BIG_ENDIAN\n \t  && AGGREGATE_TYPE_P (valtype)\n-\t  && FUNCTION_ARG_PADDING (TYPE_MODE (valtype), valtype) == upward);\n+\t  && rs6000_function_arg_padding (TYPE_MODE (valtype),\n+\t\t\t\t\t  valtype) == PAD_UPWARD);\n }\n \n #ifdef HAVE_AS_GNU_ATTRIBUTE\n@@ -12030,17 +12035,13 @@ abi_v4_pass_in_fpr (machine_mode mode)\n   return false;\n }\n \n-/* If defined, a C expression which determines whether, and in which\n-   direction, to pad out an argument with extra space.  The value\n-   should be of type `enum direction': either `upward' to pad above\n-   the argument, `downward' to pad below, or `none' to inhibit\n-   padding.\n+/* Implement TARGET_FUNCTION_ARG_PADDING\n \n    For the AIX ABI structs are always stored left shifted in their\n    argument slot.  */\n \n-enum direction\n-function_arg_padding (machine_mode mode, const_tree type)\n+static pad_direction\n+rs6000_function_arg_padding (machine_mode mode, const_tree type)\n {\n #ifndef AGGREGATE_PADDING_FIXED\n #define AGGREGATE_PADDING_FIXED 0\n@@ -12052,7 +12053,7 @@ function_arg_padding (machine_mode mode, const_tree type)\n   if (!AGGREGATE_PADDING_FIXED)\n     {\n       /* GCC used to pass structures of the same size as integer types as\n-\t if they were in fact integers, ignoring FUNCTION_ARG_PADDING.\n+\t if they were in fact integers, ignoring TARGET_FUNCTION_ARG_PADDING.\n \t i.e. Structures of size 1 or 2 (or 4 when TARGET_64BIT) were\n \t passed padded downward, except that -mstrict-align further\n \t muddied the water in that multi-component structures of 2 and 4\n@@ -12073,19 +12074,19 @@ function_arg_padding (machine_mode mode, const_tree type)\n \t    size = GET_MODE_SIZE (mode);\n \n \t  if (size == 1 || size == 2 || size == 4)\n-\t    return downward;\n+\t    return PAD_DOWNWARD;\n \t}\n-      return upward;\n+      return PAD_UPWARD;\n     }\n \n   if (AGGREGATES_PAD_UPWARD_ALWAYS)\n     {\n       if (type != 0 && AGGREGATE_TYPE_P (type))\n-\treturn upward;\n+\treturn PAD_UPWARD;\n     }\n \n   /* Fall back to the default.  */\n-  return DEFAULT_FUNCTION_ARG_PADDING (mode, type);\n+  return default_function_arg_padding (mode, type);\n }\n \n /* If defined, a C expression that gives the alignment boundary, in bits,"}, {"sha": "548e615ab37f142acbe7c342e30f0b772b290b65", "filename": "gcc/config/powerpcspe/powerpcspe.h", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -1901,16 +1901,8 @@ typedef struct rs6000_args\n   init_cumulative_args (&CUM, NULL_TREE, LIBNAME, FALSE, TRUE, \\\n \t\t\t0, NULL_TREE, MODE)\n \n-/* If defined, a C expression which determines whether, and in which\n-   direction, to pad out an argument with extra space.  The value\n-   should be of type `enum direction': either `upward' to pad above\n-   the argument, `downward' to pad below, or `none' to inhibit\n-   padding.  */\n-\n-#define FUNCTION_ARG_PADDING(MODE, TYPE) function_arg_padding (MODE, TYPE)\n-\n #define PAD_VARARGS_DOWN \\\n-   (FUNCTION_ARG_PADDING (TYPE_MODE (type), type) == downward)\n+  (targetm.calls.function_arg_padding (TYPE_MODE (type), type) == PAD_DOWNWARD)\n \n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */"}, {"sha": "6c91a90cc0025754dd42695998d00038ca2de837", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -248,7 +248,7 @@\n    registers and memory.  FIRST is nonzero if this is the only\n    element.  */\n #define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n-  (!(FIRST) ? upward : FUNCTION_ARG_PADDING (MODE, TYPE))\n+  (!(FIRST) ? PAD_UPWARD : targetm.calls.function_arg_padding (MODE, TYPE))\n \n /* Indicate that jump tables go in the text section.  */\n "}, {"sha": "aeb4762387f2be60ddcbc0e91478b404d5c31505", "filename": "gcc/config/rs6000/darwin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -339,7 +339,7 @@ extern int darwin_emit_branch_islands;\n    registers and memory.  FIRST is nonzero if this is the only\n    element.  */\n #define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n-  (!(FIRST) ? upward : FUNCTION_ARG_PADDING (MODE, TYPE))\n+  (!(FIRST) ? PAD_UPWARD : targetm.calls.function_arg_padding (MODE, TYPE))\n \n #define DOUBLE_INT_ASM_OP \"\\t.quad\\t\"\n "}, {"sha": "f1987918bf8df5c45a014daf63e4cf63ddda554c", "filename": "gcc/config/rs6000/freebsd64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Frs6000%2Ffreebsd64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Frs6000%2Ffreebsd64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ffreebsd64.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -225,7 +225,7 @@ extern int dot_symbols;\n    registers and memory.  FIRST is nonzero if this is the only\n    element.  */\n #define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n-  (!(FIRST) ? upward : FUNCTION_ARG_PADDING (MODE, TYPE))\n+  (!(FIRST) ? PAD_UPWARD : targetm.calls.function_arg_padding (MODE, TYPE))\n \n /* FreeBSD doesn't support saving and restoring 64-bit regs with a 32-bit\n    kernel. This is supported when running on a 64-bit kernel with"}, {"sha": "1dbb3d94a739c0752972e801dfb1e13227fd9e94", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -340,7 +340,7 @@ extern int dot_symbols;\n    registers and memory.  FIRST is nonzero if this is the only\n    element.  */\n #define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n-  (!(FIRST) ? upward : FUNCTION_ARG_PADDING (MODE, TYPE))\n+  (!(FIRST) ? PAD_UPWARD : targetm.calls.function_arg_padding (MODE, TYPE))\n \n /* Linux doesn't support saving and restoring 64-bit regs in a 32-bit\n    process.  */"}, {"sha": "f9be5d3ff9361a5647349b7d26622a4d0a7b3103", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -197,10 +197,6 @@ extern void rs6000_xcoff_asm_output_aligned_decl_common (FILE *, tree,\n \t\t\t\t\t\t\t unsigned HOST_WIDE_INT);\n extern void rs6000_elf_declare_function_name (FILE *, const char *, tree);\n extern bool rs6000_elf_in_small_data_p (const_tree);\n-#ifdef ARGS_SIZE_RTX\n-/* expr.h defines ARGS_SIZE_RTX and `enum direction' */\n-extern enum direction function_arg_padding (machine_mode, const_tree);\n-#endif /* ARGS_SIZE_RTX */\n \n #endif /* TREE_CODE */\n "}, {"sha": "773745e593075824108f833c40e1c0cae72a1461", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -89,6 +89,8 @@\n #define min(A,B)\t((A) < (B) ? (A) : (B))\n #define max(A,B)\t((A) > (B) ? (A) : (B))\n \n+static pad_direction rs6000_function_arg_padding (machine_mode, const_tree);\n+\n /* Structure used to define the rs6000 stack */\n typedef struct rs6000_stack {\n   int reload_completed;\t\t/* stack info won't change from here on */\n@@ -1794,6 +1796,8 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #define TARGET_FUNCTION_ARG_ADVANCE rs6000_function_arg_advance\n #undef TARGET_FUNCTION_ARG\n #define TARGET_FUNCTION_ARG rs6000_function_arg\n+#undef TARGET_FUNCTION_ARG_PADDING\n+#define TARGET_FUNCTION_ARG_PADDING rs6000_function_arg_padding\n #undef TARGET_FUNCTION_ARG_BOUNDARY\n #define TARGET_FUNCTION_ARG_BOUNDARY rs6000_function_arg_boundary\n \n@@ -11247,7 +11251,8 @@ rs6000_return_in_msb (const_tree valtype)\n   return (DEFAULT_ABI == ABI_ELFv2\n \t  && BYTES_BIG_ENDIAN\n \t  && AGGREGATE_TYPE_P (valtype)\n-\t  && FUNCTION_ARG_PADDING (TYPE_MODE (valtype), valtype) == upward);\n+\t  && (rs6000_function_arg_padding (TYPE_MODE (valtype), valtype)\n+\t      == PAD_UPWARD));\n }\n \n #ifdef HAVE_AS_GNU_ATTRIBUTE\n@@ -11464,17 +11469,13 @@ abi_v4_pass_in_fpr (machine_mode mode)\n   return false;\n }\n \n-/* If defined, a C expression which determines whether, and in which\n-   direction, to pad out an argument with extra space.  The value\n-   should be of type `enum direction': either `upward' to pad above\n-   the argument, `downward' to pad below, or `none' to inhibit\n-   padding.\n+/* Implement TARGET_FUNCTION_ARG_PADDING.\n \n    For the AIX ABI structs are always stored left shifted in their\n    argument slot.  */\n \n-enum direction\n-function_arg_padding (machine_mode mode, const_tree type)\n+static pad_direction\n+rs6000_function_arg_padding (machine_mode mode, const_tree type)\n {\n #ifndef AGGREGATE_PADDING_FIXED\n #define AGGREGATE_PADDING_FIXED 0\n@@ -11486,7 +11487,7 @@ function_arg_padding (machine_mode mode, const_tree type)\n   if (!AGGREGATE_PADDING_FIXED)\n     {\n       /* GCC used to pass structures of the same size as integer types as\n-\t if they were in fact integers, ignoring FUNCTION_ARG_PADDING.\n+\t if they were in fact integers, ignoring TARGET_FUNCTION_ARG_PADDING.\n \t i.e. Structures of size 1 or 2 (or 4 when TARGET_64BIT) were\n \t passed padded downward, except that -mstrict-align further\n \t muddied the water in that multi-component structures of 2 and 4\n@@ -11507,19 +11508,19 @@ function_arg_padding (machine_mode mode, const_tree type)\n \t    size = GET_MODE_SIZE (mode);\n \n \t  if (size == 1 || size == 2 || size == 4)\n-\t    return downward;\n+\t    return PAD_DOWNWARD;\n \t}\n-      return upward;\n+      return PAD_UPWARD;\n     }\n \n   if (AGGREGATES_PAD_UPWARD_ALWAYS)\n     {\n       if (type != 0 && AGGREGATE_TYPE_P (type))\n-\treturn upward;\n+\treturn PAD_UPWARD;\n     }\n \n   /* Fall back to the default.  */\n-  return DEFAULT_FUNCTION_ARG_PADDING (mode, type);\n+  return default_function_arg_padding (mode, type);\n }\n \n /* If defined, a C expression that gives the alignment boundary, in bits,"}, {"sha": "9bf32dbe9b980d82f3d2b7b70e7dfdcd598efb1b", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -1803,16 +1803,8 @@ typedef struct rs6000_args\n   init_cumulative_args (&CUM, NULL_TREE, LIBNAME, FALSE, TRUE, \\\n \t\t\t0, NULL_TREE, MODE)\n \n-/* If defined, a C expression which determines whether, and in which\n-   direction, to pad out an argument with extra space.  The value\n-   should be of type `enum direction': either `upward' to pad above\n-   the argument, `downward' to pad below, or `none' to inhibit\n-   padding.  */\n-\n-#define FUNCTION_ARG_PADDING(MODE, TYPE) function_arg_padding (MODE, TYPE)\n-\n #define PAD_VARARGS_DOWN \\\n-   (FUNCTION_ARG_PADDING (TYPE_MODE (type), type) == downward)\n+  (targetm.calls.function_arg_padding (TYPE_MODE (type), type) == PAD_DOWNWARD)\n \n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */"}, {"sha": "3fd1ff618d9357ab223b778769b619accf56db7d", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -12124,6 +12124,18 @@ s390_function_arg (cumulative_args_t cum_v, machine_mode mode,\n   gcc_unreachable ();\n }\n \n+/* Implement TARGET_FUNCTION_ARG_BOUNDARY.  Vector arguments are\n+   left-justified when placed on the stack during parameter passing.  */\n+\n+static pad_direction\n+s390_function_arg_padding (machine_mode mode, const_tree type)\n+{\n+  if (s390_function_arg_vector (mode, type))\n+    return PAD_UPWARD;\n+\n+  return default_function_arg_padding (mode, type);\n+}\n+\n /* Return true if return values of type TYPE should be returned\n    in a memory buffer whose address is passed by the caller as\n    hidden first argument.  */\n@@ -15886,6 +15898,8 @@ s390_asan_shadow_offset (void)\n #define TARGET_FUNCTION_ARG s390_function_arg\n #undef TARGET_FUNCTION_ARG_ADVANCE\n #define TARGET_FUNCTION_ARG_ADVANCE s390_function_arg_advance\n+#undef TARGET_FUNCTION_ARG_PADDING\n+#define TARGET_FUNCTION_ARG_PADDING s390_function_arg_padding\n #undef TARGET_FUNCTION_VALUE\n #define TARGET_FUNCTION_VALUE s390_function_value\n #undef TARGET_LIBCALL_VALUE"}, {"sha": "34fffb4a277eee8a977fe6fa21e7f8d624d31401", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -273,13 +273,6 @@ extern const char *s390_host_detect_local_cpu (int argc, const char **argv);\n \n #define STACK_SIZE_MODE (Pmode)\n \n-/* Vector arguments are left-justified when placed on the stack during\n-   parameter passing.  */\n-#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\\\n-  (s390_function_arg_vector ((MODE), (TYPE))\t\t\t\\\n-   ? upward\t\t\t\t\t\t\t\\\n-   : DEFAULT_FUNCTION_ARG_PADDING ((MODE), (TYPE)))\n-\n #ifndef IN_LIBGCC2\n \n /* Width of a word, in units (bytes).  */"}, {"sha": "507f0b1bd41a2e46c271a8efd91832b6b2795593", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -28,10 +28,6 @@ along with GCC; see the file COPYING3.  If not see\n extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n #endif\n extern unsigned long sparc_type_code (tree);\n-#ifdef ARGS_SIZE_RTX\n-/* expr.h defines ARGS_SIZE_RTX and `enum direction' */\n-extern enum direction function_arg_padding (machine_mode, const_tree);\n-#endif /* ARGS_SIZE_RTX */\n #endif /* TREE_CODE */\n \n extern void order_regs_for_local_alloc (void);"}, {"sha": "2fa22b8ebf1c626d3bab11db3def6c27adb8b983", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -648,6 +648,7 @@ static rtx sparc_function_arg (cumulative_args_t,\n \t\t\t       machine_mode, const_tree, bool);\n static rtx sparc_function_incoming_arg (cumulative_args_t,\n \t\t\t\t\tmachine_mode, const_tree, bool);\n+static pad_direction sparc_function_arg_padding (machine_mode, const_tree);\n static unsigned int sparc_function_arg_boundary (machine_mode,\n \t\t\t\t\t\t const_tree);\n static int sparc_arg_partial_bytes (cumulative_args_t,\n@@ -796,6 +797,8 @@ char sparc_hard_reg_printed[8];\n #define TARGET_FUNCTION_ARG sparc_function_arg\n #undef TARGET_FUNCTION_INCOMING_ARG\n #define TARGET_FUNCTION_INCOMING_ARG sparc_function_incoming_arg\n+#undef TARGET_FUNCTION_ARG_PADDING\n+#define TARGET_FUNCTION_ARG_PADDING sparc_function_arg_padding\n #undef TARGET_FUNCTION_ARG_BOUNDARY\n #define TARGET_FUNCTION_ARG_BOUNDARY sparc_function_arg_boundary\n \n@@ -7315,18 +7318,17 @@ sparc_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n     }\n }\n \n-/* Handle the FUNCTION_ARG_PADDING macro.\n-   For the 64-bit ABI structs are always stored left shifted in their\n-   argument slot.  */\n+/* Implement TARGET_FUNCTION_ARG_PADDING.  For the 64-bit ABI structs\n+   are always stored left shifted in their argument slot.  */\n \n-enum direction\n-function_arg_padding (machine_mode mode, const_tree type)\n+static pad_direction\n+sparc_function_arg_padding (machine_mode mode, const_tree type)\n {\n   if (TARGET_ARCH64 && type && AGGREGATE_TYPE_P (type))\n-    return upward;\n+    return PAD_UPWARD;\n \n   /* Fall back to the default.  */\n-  return DEFAULT_FUNCTION_ARG_PADDING (mode, type);\n+  return default_function_arg_padding (mode, type);\n }\n \n /* Handle the TARGET_RETURN_IN_MEMORY target hook."}, {"sha": "36f7667100eca31d84f8b0bc919640d26419500f", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -1215,14 +1215,6 @@ struct sparc_args {\n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \\\n init_cumulative_args (& (CUM), (FNTYPE), (LIBNAME), (FNDECL));\n \n-/* If defined, a C expression which determines whether, and in which direction,\n-   to pad out an argument with extra space.  The value should be of type\n-   `enum direction': either `upward' to pad above the argument,\n-   `downward' to pad below, or `none' to inhibit padding.  */\n-\n-#define FUNCTION_ARG_PADDING(MODE, TYPE) \\\n-function_arg_padding ((MODE), (TYPE))\n-\n \f\n /* Generate the special assembly code needed to tell the assembler whatever\n    it might need to know about the return value of a function."}, {"sha": "d9a0435a1b65510d515fd308253846dee1b4ac72", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -3873,6 +3873,14 @@ spu_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t   : HARD_REGNO_NREGS (cum, mode));\n }\n \n+/* Implement TARGET_FUNCTION_ARG_PADDING.  */\n+\n+static pad_direction\n+spu_function_arg_padding (machine_mode, const_tree)\n+{\n+  return PAD_UPWARD;\n+}\n+\n /* Variable sized types are passed by reference.  */\n static bool\n spu_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n@@ -7265,6 +7273,9 @@ static const struct attribute_spec spu_attribute_table[] =\n #undef TARGET_FUNCTION_ARG_ADVANCE\n #define TARGET_FUNCTION_ARG_ADVANCE spu_function_arg_advance\n \n+#undef TARGET_FUNCTION_ARG_PADDING\n+#define TARGET_FUNCTION_ARG_PADDING spu_function_arg_padding\n+\n #undef TARGET_MUST_PASS_IN_STACK\n #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n "}, {"sha": "c995d5303a86c9d230f1ac5d8ce71260effc9a02", "filename": "gcc/config/spu/spu.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -329,8 +329,6 @@ targetm.resolve_overloaded_builtin = spu_resolve_overloaded_builtin;\t\\\n  ? (4 - GET_MODE_SIZE (MODE))\t\t\t\t\t\t\\\n  : 0)\n \n-#define FUNCTION_ARG_PADDING(MODE,TYPE) upward\n-\n #define PAD_VARARGS_DOWN 0\n \n #define FUNCTION_ARG_REGNO_P(N) ((N) >= (FIRST_ARG_REGNUM) && (N) <= (LAST_ARG_REGNUM))"}, {"sha": "410583e1ce24f0ea22a92d165e9d450403b345f5", "filename": "gcc/coretypes.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -230,6 +230,22 @@ enum optimization_type {\n   OPTIMIZE_FOR_SIZE\n };\n \n+/* Enumerates a padding direction.  */\n+enum pad_direction {\n+  /* No padding is required.  */\n+  PAD_NONE,\n+\n+  /* Insert padding above the data, i.e. at higher memeory addresses\n+     when dealing with memory, and at the most significant end when\n+     dealing with registers.  */\n+  PAD_UPWARD,\n+\n+  /* Insert padding below the data, i.e. at lower memeory addresses\n+     when dealing with memory, and at the least significant end when\n+     dealing with registers.  */\n+  PAD_DOWNWARD\n+};\n+\n /* Possible initialization status of a variable.   When requested\n    by the user, this information is tracked and recorded in the DWARF\n    debug information, along with the variable's location.  */"}, {"sha": "d27eddf55b027b671ee22ea4a995233b3a147a86", "filename": "gcc/defaults.h", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -1355,24 +1355,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define SET_RATIO(speed) MOVE_RATIO (speed)\n #endif\n \n-/* Supply a default definition for FUNCTION_ARG_PADDING:\n-   usually pad upward, but pad short args downward on\n-   big-endian machines.  */\n-\n-#define DEFAULT_FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\\\n-  (! BYTES_BIG_ENDIAN\t\t\t\t\t\t\t\\\n-   ? upward\t\t\t\t\t\t\t\t\\\n-   : (((MODE) == BLKmode\t\t\t\t\t\t\\\n-       ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST\t\t\\\n-\t  && int_size_in_bytes (TYPE) < (PARM_BOUNDARY / BITS_PER_UNIT)) \\\n-       : GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY)\t\t\t\\\n-      ? downward : upward))\n-\n-#ifndef FUNCTION_ARG_PADDING\n-#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\\\n-  DEFAULT_FUNCTION_ARG_PADDING ((MODE), (TYPE))\n-#endif\n-\n /* Supply a default definition of STACK_SAVEAREA_MODE for emit_stack_save.\n    Normally move_insn, so Pmode stack pointer.  */\n "}, {"sha": "2e22047d8f743d6c29b322426e81f7fab5fb404d", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -4096,21 +4096,21 @@ slot that is in the middle of the quad word instead of starting at the\n top.\n @end defmac\n \n-@defmac FUNCTION_ARG_PADDING (@var{mode}, @var{type})\n-If defined, a C expression which determines whether, and in which direction,\n-to pad out an argument with extra space.  The value should be of type\n-@code{enum direction}: either @code{upward} to pad above the argument,\n-@code{downward} to pad below, or @code{none} to inhibit padding.\n+@deftypefn {Target Hook} pad_direction TARGET_FUNCTION_ARG_PADDING (machine_mode @var{mode}, const_tree @var{type})\n+This hook determines whether, and in which direction, to pad out\n+an argument of mode @var{mode} and type @var{type}.  It returns\n+@code{PAD_UPWARD} to insert padding above the argument, @code{PAD_DOWNWARD}\n+to insert padding below the argument, or @code{PAD_NONE} to inhibit padding.\n \n-The @emph{amount} of padding is not controlled by this macro, but by the\n-target hook @code{TARGET_FUNCTION_ARG_ROUND_BOUNDARY}.  It is\n-always just enough to reach the next multiple of that boundary. \n+The @emph{amount} of padding is not controlled by this hook, but by\n+@code{TARGET_FUNCTION_ARG_ROUND_BOUNDARY}.  It is always just enough\n+to reach the next multiple of that boundary.\n \n-This macro has a default definition which is right for most systems.\n+This hook has a default definition that is right for most systems.\n For little-endian machines, the default is to pad upward.  For\n big-endian machines, the default is to pad downward for an argument of\n constant size shorter than an @code{int}, and upward otherwise.\n-@end defmac\n+@end deftypefn\n \n @defmac PAD_VARARGS_DOWN\n If defined, a C expression which determines whether the default"}, {"sha": "8c35a0a0261d9e8e0aff6a455aad6459e8b87af2", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -3363,21 +3363,7 @@ slot that is in the middle of the quad word instead of starting at the\n top.\n @end defmac\n \n-@defmac FUNCTION_ARG_PADDING (@var{mode}, @var{type})\n-If defined, a C expression which determines whether, and in which direction,\n-to pad out an argument with extra space.  The value should be of type\n-@code{enum direction}: either @code{upward} to pad above the argument,\n-@code{downward} to pad below, or @code{none} to inhibit padding.\n-\n-The @emph{amount} of padding is not controlled by this macro, but by the\n-target hook @code{TARGET_FUNCTION_ARG_ROUND_BOUNDARY}.  It is\n-always just enough to reach the next multiple of that boundary. \n-\n-This macro has a default definition which is right for most systems.\n-For little-endian machines, the default is to pad upward.  For\n-big-endian machines, the default is to pad downward for an argument of\n-constant size shorter than an @code{int}, and upward otherwise.\n-@end defmac\n+@hook TARGET_FUNCTION_ARG_PADDING\n \n @defmac PAD_VARARGS_DOWN\n If defined, a C expression which determines whether the default"}, {"sha": "b825f49fb49e5cc9c884eca5bf8bc5c9baa3d5ac", "filename": "gcc/expr.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -2150,7 +2150,7 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n \t  if (\n #ifdef BLOCK_REG_PADDING\n \t      BLOCK_REG_PADDING (GET_MODE (orig_src), type, i == start)\n-\t      == (BYTES_BIG_ENDIAN ? upward : downward)\n+\t      == (BYTES_BIG_ENDIAN ? PAD_UPWARD : PAD_DOWNWARD)\n #else\n \t      BYTES_BIG_ENDIAN\n #endif\n@@ -2564,7 +2564,7 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n \t  if (\n #ifdef BLOCK_REG_PADDING\n \t      BLOCK_REG_PADDING (GET_MODE (orig_dst), type, i == start)\n-\t      == (BYTES_BIG_ENDIAN ? upward : downward)\n+\t      == (BYTES_BIG_ENDIAN ? PAD_UPWARD : PAD_DOWNWARD)\n #else\n \t      BYTES_BIG_ENDIAN\n #endif\n@@ -4130,7 +4130,7 @@ emit_single_push_insn_1 (machine_mode mode, rtx x, tree type)\n      then store X into the stack location using an offset.  This is\n      because emit_move_insn does not know how to pad; it does not have\n      access to type.  */\n-  else if (FUNCTION_ARG_PADDING (mode, type) == downward)\n+  else if (targetm.calls.function_arg_padding (mode, type) == PAD_DOWNWARD)\n     {\n       unsigned padding_size = rounded_size - GET_MODE_SIZE (mode);\n       HOST_WIDE_INT offset;\n@@ -4274,18 +4274,19 @@ emit_push_insn (rtx x, machine_mode mode, tree type, rtx size,\n \t\trtx alignment_pad, bool sibcall_p)\n {\n   rtx xinner;\n-  enum direction stack_direction = STACK_GROWS_DOWNWARD ? downward : upward;\n+  pad_direction stack_direction\n+    = STACK_GROWS_DOWNWARD ? PAD_DOWNWARD : PAD_UPWARD;\n \n-  /* Decide where to pad the argument: `downward' for below,\n-     `upward' for above, or `none' for don't pad it.\n+  /* Decide where to pad the argument: PAD_DOWNWARD for below,\n+     PAD_UPWARD for above, or PAD_NONE for don't pad it.\n      Default is below for small data on big-endian machines; else above.  */\n-  enum direction where_pad = FUNCTION_ARG_PADDING (mode, type);\n+  pad_direction where_pad = targetm.calls.function_arg_padding (mode, type);\n \n   /* Invert direction if stack is post-decrement.\n      FIXME: why?  */\n   if (STACK_PUSH_CODE == POST_DEC)\n-    if (where_pad != none)\n-      where_pad = (where_pad == downward ? upward : downward);\n+    if (where_pad != PAD_NONE)\n+      where_pad = (where_pad == PAD_DOWNWARD ? PAD_UPWARD : PAD_DOWNWARD);\n \n   xinner = x;\n \n@@ -4357,7 +4358,7 @@ emit_push_insn (rtx x, machine_mode mode, tree type, rtx size,\n \t     or if padding below and stack grows up.\n \t     But if space already allocated, this has already been done.  */\n \t  if (extra && args_addr == 0\n-\t      && where_pad != none && where_pad != stack_direction)\n+\t      && where_pad != PAD_NONE && where_pad != stack_direction)\n \t    anti_adjust_stack (GEN_INT (extra));\n \n \t  move_by_pieces (NULL, xinner, INTVAL (size) - used, align, 0);\n@@ -4386,7 +4387,7 @@ emit_push_insn (rtx x, machine_mode mode, tree type, rtx size,\n \t     A single stack adjust will do.  */\n \t  if (! args_addr)\n \t    {\n-\t      temp = push_block (size, extra, where_pad == downward);\n+\t      temp = push_block (size, extra, where_pad == PAD_DOWNWARD);\n \t      extra = 0;\n \t    }\n \t  else if (CONST_INT_P (args_so_far))\n@@ -4480,7 +4481,7 @@ emit_push_insn (rtx x, machine_mode mode, tree type, rtx size,\n \t or if padding below and stack grows up.\n \t But if space already allocated, this has already been done.  */\n       if (extra && args_addr == 0\n-\t  && where_pad != none && where_pad != stack_direction)\n+\t  && where_pad != PAD_NONE && where_pad != stack_direction)\n \tanti_adjust_stack (GEN_INT (extra));\n \n       /* If we make space by pushing it, we might as well push\n@@ -4531,7 +4532,7 @@ emit_push_insn (rtx x, machine_mode mode, tree type, rtx size,\n \t or if padding below and stack grows up.\n \t But if space already allocated, this has already been done.  */\n       if (extra && args_addr == 0\n-\t  && where_pad != none && where_pad != stack_direction)\n+\t  && where_pad != PAD_NONE && where_pad != stack_direction)\n \tanti_adjust_stack (GEN_INT (extra));\n \n #ifdef PUSH_ROUNDING"}, {"sha": "f221d6ca7db889e6d5a5cd50b3def8a564e47e37", "filename": "gcc/function.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -2713,7 +2713,7 @@ assign_parm_find_stack_rtl (tree parm, struct assign_parm_data_one *data)\n      is TARGET_FUNCTION_ARG_BOUNDARY.  If we're using slot_offset, we're\n      intentionally forcing upward padding.  Otherwise we have to come\n      up with a guess at the alignment based on OFFSET_RTX.  */\n-  if (data->locate.where_pad != downward || data->entry_parm)\n+  if (data->locate.where_pad != PAD_DOWNWARD || data->entry_parm)\n     align = boundary;\n   else if (CONST_INT_P (offset_rtx))\n     {\n@@ -2867,7 +2867,7 @@ assign_parm_setup_block_p (struct assign_parm_data_one *data)\n   if (REG_P (data->entry_parm)\n       && GET_MODE_SIZE (data->promoted_mode) < UNITS_PER_WORD\n       && (BLOCK_REG_PADDING (data->passed_mode, data->passed_type, 1)\n-\t  == (BYTES_BIG_ENDIAN ? upward : downward)))\n+\t  == (BYTES_BIG_ENDIAN ? PAD_UPWARD : PAD_DOWNWARD)))\n     return true;\n #endif\n \n@@ -2985,7 +2985,7 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n #ifdef BLOCK_REG_PADDING\n \t      && (size == UNITS_PER_WORD\n \t\t  || (BLOCK_REG_PADDING (mode, data->passed_type, 1)\n-\t\t      != (BYTES_BIG_ENDIAN ? upward : downward)))\n+\t\t      != (BYTES_BIG_ENDIAN ? PAD_UPWARD : PAD_DOWNWARD)))\n #endif\n \t      )\n \t    {\n@@ -3025,7 +3025,7 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n \t      gcc_checking_assert (BYTES_BIG_ENDIAN\n \t\t\t\t   && (BLOCK_REG_PADDING (mode,\n \t\t\t\t\t\t\t  data->passed_type, 1)\n-\t\t\t\t       == upward));\n+\t\t\t\t       == PAD_UPWARD));\n \n \t      int by = (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n \n@@ -3046,7 +3046,7 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n \t  else if (size != UNITS_PER_WORD\n #ifdef BLOCK_REG_PADDING\n \t\t   && (BLOCK_REG_PADDING (mode, data->passed_type, 1)\n-\t\t       == downward)\n+\t\t       == PAD_DOWNWARD)\n #else\n \t\t   && BYTES_BIG_ENDIAN\n #endif\n@@ -3070,7 +3070,7 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n #ifdef BLOCK_REG_PADDING\n \t  gcc_checking_assert (BLOCK_REG_PADDING (GET_MODE (mem),\n \t\t\t\t\t\t  data->passed_type, 0)\n-\t\t\t       == upward);\n+\t\t\t       == PAD_UPWARD);\n #endif\n \t  emit_move_insn (mem, entry_parm);\n \t}\n@@ -4098,7 +4098,7 @@ gimplify_parameters (void)\n    rounding affects the initial and starting offsets, but not the argument\n    size.\n \n-   The second, controlled by FUNCTION_ARG_PADDING and PARM_BOUNDARY,\n+   The second, controlled by TARGET_FUNCTION_ARG_PADDING and PARM_BOUNDARY,\n    optionally rounds the size of the parm to PARM_BOUNDARY.  The\n    initial offset is not affected by this rounding, while the size always\n    is and the starting offset may be.  */\n@@ -4116,7 +4116,7 @@ locate_and_pad_parm (machine_mode passed_mode, tree type, int in_regs,\n \t\t     struct locate_and_pad_arg_data *locate)\n {\n   tree sizetree;\n-  enum direction where_pad;\n+  pad_direction where_pad;\n   unsigned int boundary, round_boundary;\n   int part_size_in_regs;\n \n@@ -4142,7 +4142,7 @@ locate_and_pad_parm (machine_mode passed_mode, tree type, int in_regs,\n \n   sizetree\n     = type ? size_in_bytes (type) : size_int (GET_MODE_SIZE (passed_mode));\n-  where_pad = FUNCTION_ARG_PADDING (passed_mode, type);\n+  where_pad = targetm.calls.function_arg_padding (passed_mode, type);\n   boundary = targetm.calls.function_arg_boundary (passed_mode, type);\n   round_boundary = targetm.calls.function_arg_round_boundary (passed_mode,\n \t\t\t\t\t\t\t      type);\n@@ -4191,7 +4191,7 @@ locate_and_pad_parm (machine_mode passed_mode, tree type, int in_regs,\n \n       {\n \ttree s2 = sizetree;\n-\tif (where_pad != none\n+\tif (where_pad != PAD_NONE\n \t    && (!tree_fits_uhwi_p (sizetree)\n \t\t|| (tree_to_uhwi (sizetree) * BITS_PER_UNIT) % round_boundary))\n \t  s2 = round_up (s2, round_boundary / BITS_PER_UNIT);\n@@ -4216,7 +4216,7 @@ locate_and_pad_parm (machine_mode passed_mode, tree type, int in_regs,\n       /* Pad_below needs the pre-rounded size to know how much to pad\n \t below.  */\n       locate->offset = locate->slot_offset;\n-      if (where_pad == downward)\n+      if (where_pad == PAD_DOWNWARD)\n \tpad_below (&locate->offset, passed_mode, sizetree);\n \n     }\n@@ -4235,10 +4235,10 @@ locate_and_pad_parm (machine_mode passed_mode, tree type, int in_regs,\n       /* Pad_below needs the pre-rounded size to know how much to pad below\n \t so this must be done before rounding up.  */\n       locate->offset = locate->slot_offset;\n-      if (where_pad == downward)\n+      if (where_pad == PAD_DOWNWARD)\n \tpad_below (&locate->offset, passed_mode, sizetree);\n \n-      if (where_pad != none\n+      if (where_pad != PAD_NONE\n \t  && (!tree_fits_uhwi_p (sizetree)\n \t      || (tree_to_uhwi (sizetree) * BITS_PER_UNIT) % round_boundary))\n \tsizetree = round_up (sizetree, round_boundary / BITS_PER_UNIT);"}, {"sha": "91e0138325225aee045c63a8f788c56e32335382", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -469,8 +469,6 @@ set_loops_for_fn (struct function *fn, struct loops *loops)\n    data structures.  */\n extern struct machine_function * (*init_machine_status) (void);\n \n-enum direction {none, upward, downward};\n-\n /* Structure to record the size of a sequence of arguments\n    as the sum of a tree-expression and a constant.  This structure is\n    also used to store offsets from the stack, which might be negative,\n@@ -499,7 +497,7 @@ struct locate_and_pad_arg_data\n      force alignment for the next argument.  */\n   struct args_size alignment_pad;\n   /* Which way we should pad this arg.  */\n-  enum direction where_pad;\n+  pad_direction where_pad;\n   /* slot_offset is at least this aligned.  */\n   unsigned int boundary;\n };"}, {"sha": "672fe2d3ceb21cdcc7c003cc34585f4601b7377e", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -912,7 +912,7 @@ extern void fancy_abort (const char *, int, const char *)\n \tCLEAR_BY_PIECES_P MOVE_BY_PIECES_P SET_BY_PIECES_P\t\t\\\n \tSTORE_BY_PIECES_P TARGET_FLT_EVAL_METHOD\t\t\t\\\n \tHARD_REGNO_CALL_PART_CLOBBERED HARD_REGNO_MODE_OK\t\t\\\n-\tMODES_TIEABLE_P\n+\tMODES_TIEABLE_P FUNCTION_ARG_PADDING\n \n /* Target macros only used for code built for the target, that have\n    moved to libgcc-tm.h or have never been present elsewhere.  */"}, {"sha": "a94175781aaf5157dc5dfd98f53eade29a1ec642", "filename": "gcc/target.def", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -4533,6 +4533,24 @@ used for arguments without any special help.\",\n  (cumulative_args_t ca, machine_mode mode, const_tree type, bool named),\n  default_function_arg_advance)\n \n+DEFHOOK\n+(function_arg_padding,\n+ \"This hook determines whether, and in which direction, to pad out\\n\\\n+an argument of mode @var{mode} and type @var{type}.  It returns\\n\\\n+@code{PAD_UPWARD} to insert padding above the argument, @code{PAD_DOWNWARD}\\n\\\n+to insert padding below the argument, or @code{PAD_NONE} to inhibit padding.\\n\\\n+\\n\\\n+The @emph{amount} of padding is not controlled by this hook, but by\\n\\\n+@code{TARGET_FUNCTION_ARG_ROUND_BOUNDARY}.  It is always just enough\\n\\\n+to reach the next multiple of that boundary.\\n\\\n+\\n\\\n+This hook has a default definition that is right for most systems.\\n\\\n+For little-endian machines, the default is to pad upward.  For\\n\\\n+big-endian machines, the default is to pad downward for an argument of\\n\\\n+constant size shorter than an @code{int}, and upward otherwise.\",\n+ pad_direction, (machine_mode mode, const_tree type),\n+ default_function_arg_padding)\n+\n /* Return zero if the argument described by the state of CA should\n    be placed on a stack, or a hard register in which to store the\n    argument.  The values MODE, TYPE, and NAMED describe that"}, {"sha": "0a4274785363ecc5211cb257cabf714f548bec36", "filename": "gcc/targhooks.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -734,6 +734,31 @@ default_function_arg_advance (cumulative_args_t ca ATTRIBUTE_UNUSED,\n   gcc_unreachable ();\n }\n \n+/* Default implementation of TARGET_FUNCTION_ARG_PADDING: usually pad\n+   upward, but pad short args downward on big-endian machines.  */\n+\n+pad_direction\n+default_function_arg_padding (machine_mode mode, const_tree type)\n+{\n+  if (!BYTES_BIG_ENDIAN)\n+    return PAD_UPWARD;\n+\n+  unsigned HOST_WIDE_INT size;\n+  if (mode == BLKmode)\n+    {\n+      if (!type || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+\treturn PAD_UPWARD;\n+      size = int_size_in_bytes (type);\n+    }\n+  else\n+    size = GET_MODE_SIZE (mode);\n+\n+  if (size < (PARM_BOUNDARY / BITS_PER_UNIT))\n+    return PAD_DOWNWARD;\n+\n+  return PAD_UPWARD;\n+}\n+\n rtx\n default_function_arg (cumulative_args_t ca ATTRIBUTE_UNUSED,\n \t\t      machine_mode mode ATTRIBUTE_UNUSED,"}, {"sha": "a7fb83a24bfaed9c57daa4877cb7cd1b2f4bc849", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b0cbf8b639a5cc574c199993a158586aae8225/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=76b0cbf8b639a5cc574c199993a158586aae8225", "patch": "@@ -132,6 +132,7 @@ extern const char *hook_invalid_arg_for_unprototyped_fn\n   (const_tree, const_tree, const_tree);\n extern void default_function_arg_advance\n   (cumulative_args_t, machine_mode, const_tree, bool);\n+extern pad_direction default_function_arg_padding (machine_mode, const_tree);\n extern rtx default_function_arg\n   (cumulative_args_t, machine_mode, const_tree, bool);\n extern rtx default_function_incoming_arg"}]}