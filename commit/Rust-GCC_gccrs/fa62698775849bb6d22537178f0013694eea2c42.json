{"sha": "fa62698775849bb6d22537178f0013694eea2c42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE2MjY5ODc3NTg0OWJiNmQyMjUzNzE3OGYwMDEzNjk0ZWVhMmM0Mg==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2016-07-21T11:00:56Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2016-07-21T11:00:56Z"}, "message": "Some patterns for moving one bit around by BST + BLD.\n\n\t* config/avr/avr.md (any_extract, any_shiftrt): New code iterators.\n\t(*insv.extract, *insv.shiftrt, *insv.not-bit.0, *insv.not-bit.7)\n\t(*insv.xor-extract, *insv.xor1-bit.0): New insns.\n\t(adjust_len) [insv_notbit, insv_notbit_0, insv_notbit_7]: New\n\tvalues for insn attribute.\n\t* config/avr/avr.c (avr_out_insert_notbit): New function.\n\t(avr_adjust_insn_length): Handle ADJUST_LEN_INSV_NOTBIT,\n\tADJUST_LEN_INSV_NOTBIT_0/_7.\n\t* config/avr/avr-protos.h (avr_out_insert_notbit): New proto.\n\nFrom-SVN: r238587", "tree": {"sha": "a2703966854cb649d7a99bc67609e68e204263fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2703966854cb649d7a99bc67609e68e204263fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa62698775849bb6d22537178f0013694eea2c42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa62698775849bb6d22537178f0013694eea2c42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa62698775849bb6d22537178f0013694eea2c42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa62698775849bb6d22537178f0013694eea2c42/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b24d94207914fb8695bd7307187a5a0bfcddc8c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b24d94207914fb8695bd7307187a5a0bfcddc8c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b24d94207914fb8695bd7307187a5a0bfcddc8c2"}], "stats": {"total": 199, "additions": 198, "deletions": 1}, "files": [{"sha": "d400f82b3ff9d9b1350123b54530c5a2e8fd1d2f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa62698775849bb6d22537178f0013694eea2c42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa62698775849bb6d22537178f0013694eea2c42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa62698775849bb6d22537178f0013694eea2c42", "patch": "@@ -1,3 +1,15 @@\n+2016-07-21  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\t* config/avr/avr.md (any_extract, any_shiftrt): New code iterators.\n+\t(*insv.extract, *insv.shiftrt, *insv.not-bit.0, *insv.not-bit.7)\n+\t(*insv.xor-extract, *insv.xor1-bit.0): New insns.\n+\t(adjust_len) [insv_notbit, insv_notbit_0, insv_notbit_7]: New\n+\tvalues for insn attribute.\n+\t* config/avr/avr.c (avr_out_insert_notbit): New function.\n+\t(avr_adjust_insn_length): Handle ADJUST_LEN_INSV_NOTBIT,\n+\tADJUST_LEN_INSV_NOTBIT_0/_7.\n+\t* config/avr/avr-protos.h (avr_out_insert_notbit): New proto.\n+\n 2016-07-21  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-chrec.c (convert_affine_scev): New parameter.  Pass new arg."}, {"sha": "ddc3047b32bc3b100c4b225009cdc2d5f5e94c40", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa62698775849bb6d22537178f0013694eea2c42/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa62698775849bb6d22537178f0013694eea2c42/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=fa62698775849bb6d22537178f0013694eea2c42", "patch": "@@ -58,6 +58,7 @@ extern const char *avr_out_compare64 (rtx_insn *, rtx*, int*);\n extern const char *ret_cond_branch (rtx x, int len, int reverse);\n extern const char *avr_out_movpsi (rtx_insn *, rtx*, int*);\n extern const char *avr_out_sign_extend (rtx_insn *, rtx*, int*);\n+extern const char *avr_out_insert_notbit (rtx_insn *, rtx*, rtx, int*);\n \n extern const char *ashlqi3_out (rtx_insn *insn, rtx operands[], int *len);\n extern const char *ashlhi3_out (rtx_insn *insn, rtx operands[], int *len);"}, {"sha": "13e7371a8e0268b1f618aef0ac59776e998f268a", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa62698775849bb6d22537178f0013694eea2c42/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa62698775849bb6d22537178f0013694eea2c42/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=fa62698775849bb6d22537178f0013694eea2c42", "patch": "@@ -7973,6 +7973,76 @@ avr_out_addto_sp (rtx *op, int *plen)\n }\n \n \n+/* Output instructions to insert an inverted bit into OPERANDS[0]:\n+   $0.$1 = ~$2.$3      if XBITNO = NULL\n+   $0.$1 = ~$2.XBITNO  if XBITNO != NULL.\n+   If PLEN = NULL then output the respective instruction sequence which\n+   is a combination of BST / BLD and some instruction(s) to invert the bit.\n+   If PLEN != NULL then store the length of the sequence (in words) in *PLEN.\n+   Return \"\".  */\n+\n+const char*\n+avr_out_insert_notbit (rtx_insn *insn, rtx operands[], rtx xbitno, int *plen)\n+{\n+  rtx op[4] = { operands[0], operands[1], operands[2],\n+                xbitno == NULL_RTX ? operands [3] : xbitno };\n+\n+  if (INTVAL (op[1]) == 7\n+      && test_hard_reg_class (LD_REGS, op[0]))\n+    {\n+      /* If the inserted bit number is 7 and we have a d-reg, then invert\n+         the bit after the insertion by means of SUBI *,0x80.  */\n+\n+      if (INTVAL (op[3]) == 7\n+          && REGNO (op[0]) == REGNO (op[2]))\n+        {\n+          avr_asm_len (\"subi %0,0x80\", op, plen, -1);\n+        }\n+      else\n+        {\n+          avr_asm_len (\"bst %2,%3\" CR_TAB\n+                       \"bld %0,%1\" CR_TAB\n+                       \"subi %0,0x80\", op, plen, -3);\n+        }\n+    }\n+  else if (test_hard_reg_class (LD_REGS, op[0])\n+           && (INTVAL (op[1]) != INTVAL (op[3])\n+               || !reg_overlap_mentioned_p (op[0], op[2])))\n+    {\n+      /* If the destination bit is in a d-reg we can jump depending\n+         on the source bit and use ANDI / ORI.  This just applies if we\n+         have not an early-clobber situation with the bit.  */\n+\n+      avr_asm_len (\"andi %0,~(1<<%1)\" CR_TAB\n+                   \"sbrs %2,%3\"       CR_TAB\n+                   \"ori %0,1<<%1\", op, plen, -3);\n+    }\n+  else\n+    {\n+      /* Otherwise, invert the bit by means of COM before we store it with\n+         BST and then undo the COM if needed.  */\n+\n+      avr_asm_len (\"com %2\" CR_TAB\n+                   \"bst %2,%3\", op, plen, -2);\n+\n+      if (!reg_unused_after (insn, op[2])\n+          // A simple 'reg_unused_after' is not enough because that function\n+          // assumes that the destination register is overwritten completely\n+          // and hence is in order for our purpose.  This is not the case\n+          // with BLD which just changes one bit of the destination.\n+          || reg_overlap_mentioned_p (op[0], op[2]))\n+        {\n+          /* Undo the COM from above.  */\n+          avr_asm_len (\"com %2\", op, plen, 1);\n+        }\n+\n+      avr_asm_len (\"bld %0,%1\", op, plen, 1);\n+    }\n+              \n+  return \"\";\n+}\n+\n+\n /* Outputs instructions needed for fixed point type conversion.\n    This includes converting between any fixed point type, as well\n    as converting to any integer type.  Conversion between integer\n@@ -8810,6 +8880,16 @@ avr_adjust_insn_length (rtx_insn *insn, int len)\n \n     case ADJUST_LEN_INSERT_BITS: avr_out_insert_bits (op, &len); break;\n \n+    case ADJUST_LEN_INSV_NOTBIT:\n+      avr_out_insert_notbit (insn, op, NULL_RTX, &len);\n+      break;\n+    case ADJUST_LEN_INSV_NOTBIT_0:\n+      avr_out_insert_notbit (insn, op, const0_rtx, &len);\n+      break;\n+    case ADJUST_LEN_INSV_NOTBIT_7:\n+      avr_out_insert_notbit (insn, op, GEN_INT (7), &len);\n+      break;\n+\n     default:\n       gcc_unreachable();\n     }"}, {"sha": "1e64bd36d54b2dbd322a0189b5b5267a4459b644", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 105, "deletions": 1, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa62698775849bb6d22537178f0013694eea2c42/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa62698775849bb6d22537178f0013694eea2c42/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=fa62698775849bb6d22537178f0013694eea2c42", "patch": "@@ -156,7 +156,7 @@\n    ashlhi, ashrhi, lshrhi,\n    ashlsi, ashrsi, lshrsi,\n    ashlpsi, ashrpsi, lshrpsi,\n-   insert_bits,\n+   insert_bits, insv_notbit, insv_notbit_0, insv_notbit_7,\n    no\"\n   (const_string \"no\"))\n \n@@ -264,6 +264,8 @@\n ;; Define two incarnations so that we can build the cross product.\n (define_code_iterator any_extend  [sign_extend zero_extend])\n (define_code_iterator any_extend2 [sign_extend zero_extend])\n+(define_code_iterator any_extract [sign_extract zero_extract])\n+(define_code_iterator any_shiftrt [lshiftrt ashiftrt])\n \n (define_code_iterator xior [xor ior])\n (define_code_iterator eqne [eq ne])\n@@ -6485,6 +6487,11 @@\n         (match_operand:QI 3 \"nonmemory_operand\" \"\"))]\n   \"optimize\")\n \n+;; Some more patterns to support moving around one bit which can be accomplished\n+;; by BST + BLD in most situations.  Unfortunately, there is no canonical\n+;; representation, and we just implement some more cases that are not too\n+;; complicated.\n+\n ;; Insert bit $2.0 into $0.$1\n (define_insn \"*insv.reg\"\n   [(set (zero_extract:QI (match_operand:QI 0 \"register_operand\"    \"+r,d,d,l,l\")\n@@ -6501,6 +6508,103 @@\n   [(set_attr \"length\" \"2,1,1,2,2\")\n    (set_attr \"cc\" \"none,set_zn,set_zn,none,none\")])\n \n+;; Insert bit $2.$3 into $0.$1\n+(define_insn \"*insv.extract\"\n+  [(set (zero_extract:QI (match_operand:QI 0 \"register_operand\"    \"+r\")\n+                         (const_int 1)\n+                         (match_operand:QI 1 \"const_0_to_7_operand\" \"n\"))\n+        (any_extract:QI (match_operand:QI 2 \"register_operand\"      \"r\")\n+                        (const_int 1)\n+                        (match_operand:QI 3 \"const_0_to_7_operand\"  \"n\")))]\n+  \"\"\n+  \"bst %2,%3\\;bld %0,%1\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none\")])\n+\n+;; Insert bit $2.$3 into $0.$1\n+(define_insn \"*insv.shiftrt\"\n+  [(set (zero_extract:QI (match_operand:QI 0 \"register_operand\"    \"+r\")\n+                         (const_int 1)\n+                         (match_operand:QI 1 \"const_0_to_7_operand\" \"n\"))\n+        (any_shiftrt:QI (match_operand:QI 2 \"register_operand\"      \"r\")\n+                        (match_operand:QI 3 \"const_0_to_7_operand\"  \"n\")))]\n+  \"\"\n+  \"bst %2,%3\\;bld %0,%1\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none\")])\n+\n+;; Same, but with a NOT inverting the source bit.\n+;; Insert bit ~$2.$3 into $0.$1\n+(define_insn \"*insv.not-shiftrt\"\n+  [(set (zero_extract:QI (match_operand:QI 0 \"register_operand\"           \"+r\")\n+                         (const_int 1)\n+                         (match_operand:QI 1 \"const_0_to_7_operand\"        \"n\"))\n+        (not:QI (any_shiftrt:QI (match_operand:QI 2 \"register_operand\"     \"r\")\n+                                (match_operand:QI 3 \"const_0_to_7_operand\" \"n\"))))]\n+  \"\"\n+  {\n+    return avr_out_insert_notbit (insn, operands, NULL_RTX, NULL);\n+  }\n+  [(set_attr \"adjust_len\" \"insv_notbit\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Insert bit ~$2.0 into $0.$1\n+(define_insn \"*insv.xor1-bit.0\"\n+  [(set (zero_extract:QI (match_operand:QI 0 \"register_operand\"    \"+r\")\n+                         (const_int 1)\n+                         (match_operand:QI 1 \"const_0_to_7_operand\" \"n\"))\n+        (xor:QI (match_operand:QI 2 \"register_operand\"              \"r\")\n+                (const_int 1)))]\n+  \"\"\n+  {\n+    return avr_out_insert_notbit (insn, operands, const0_rtx, NULL);\n+  }\n+  [(set_attr \"adjust_len\" \"insv_notbit_0\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Insert bit ~$2.0 into $0.$1\n+(define_insn \"*insv.not-bit.0\"\n+  [(set (zero_extract:QI (match_operand:QI 0 \"register_operand\"    \"+r\")\n+                         (const_int 1)\n+                         (match_operand:QI 1 \"const_0_to_7_operand\" \"n\"))\n+        (not:QI (match_operand:QI 2 \"register_operand\"              \"r\")))]\n+  \"\"\n+  {\n+    return avr_out_insert_notbit (insn, operands, const0_rtx, NULL);\n+  }\n+  [(set_attr \"adjust_len\" \"insv_notbit_0\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Insert bit ~$2.7 into $0.$1\n+(define_insn \"*insv.not-bit.7\"\n+  [(set (zero_extract:QI (match_operand:QI 0 \"register_operand\"    \"+r\")\n+                         (const_int 1)\n+                         (match_operand:QI 1 \"const_0_to_7_operand\" \"n\"))\n+        (ge:QI (match_operand:QI 2 \"register_operand\"               \"r\")\n+               (const_int 0)))]\n+  \"\"\n+  {\n+    return avr_out_insert_notbit (insn, operands, GEN_INT (7), NULL);\n+  }\n+  [(set_attr \"adjust_len\" \"insv_notbit_7\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Insert bit ~$2.$3 into $0.$1\n+(define_insn \"*insv.xor-extract\"\n+  [(set (zero_extract:QI (match_operand:QI 0 \"register_operand\"        \"+r\")\n+                         (const_int 1)\n+                         (match_operand:QI 1 \"const_0_to_7_operand\"     \"n\"))\n+        (any_extract:QI (xor:QI (match_operand:QI 2 \"register_operand\"  \"r\")\n+                                (match_operand:QI 4 \"const_int_operand\" \"n\"))\n+                        (const_int 1)\n+                        (match_operand:QI 3 \"const_0_to_7_operand\"      \"n\")))]\n+  \"INTVAL (operands[4]) & (1 << INTVAL (operands[3]))\"\n+  {\n+    return avr_out_insert_notbit (insn, operands, NULL_RTX, NULL);\n+  }\n+  [(set_attr \"adjust_len\" \"insv_notbit\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n \f\n ;; Some combine patterns that try to fix bad code when a value is composed\n ;; from byte parts like in PR27663."}]}