{"sha": "01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFlYjdmOWExY2NkN2EyZWRiODkwMmRlZTQ1NDZjYzlmNWUxNTRlYw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1997-12-12T07:35:04Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-12-12T07:35:04Z"}, "message": "except.c (call_get_eh_context): Don't take a parm.\n\n\t* except.c (call_get_eh_context): Don't take a parm.\n\tPut the call at the top of the function.\n\t(emit_eh_context): Adjust.\n\t(get_eh_context): Replace with former use_eh_context.\n\t(get_eh_context_once, get_saved_pc_ref): Remove.\n\t(start_eh_unwinder, end_eh_unwinder, emit_unwinder): Remove.\n\t* except.h: Adjust.\n\t* integrate.c (expand_inline_function): Adjust.\n\t* toplev.c (rest_of_compilation): Don't call emit_unwinder.\n\ntidy tidy tidy\n\nFrom-SVN: r17065", "tree": {"sha": "ad72cd11014b48175c8bab39afb7a42cda08bb2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad72cd11014b48175c8bab39afb7a42cda08bb2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec/comments", "author": null, "committer": null, "parents": [{"sha": "d19814a309796f785229a676f8bb78a25419a106", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d19814a309796f785229a676f8bb78a25419a106", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d19814a309796f785229a676f8bb78a25419a106"}], "stats": {"total": 280, "additions": 22, "deletions": 258}, "files": [{"sha": "8e98717d9202f5b18d349715a420c2484237cae2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec", "patch": "@@ -1,3 +1,15 @@\n+Thu Dec 11 23:33:48 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* except.c (call_get_eh_context): Don't take a parm.\n+\tPut the call at the top of the function.\n+\t(emit_eh_context): Adjust.\n+\t(get_eh_context): Replace with former use_eh_context.\n+\t(get_eh_context_once, get_saved_pc_ref): Remove.\n+\t(start_eh_unwinder, end_eh_unwinder, emit_unwinder): Remove.\n+\t* except.h: Adjust.\n+\t* integrate.c (expand_inline_function): Adjust.\n+\t* toplev.c (rest_of_compilation): Don't call emit_unwinder.\n+\n Fri Oct 10 17:58:31 CEST 1997  Marc Lehmann <pcg@goof.com>\n \n \t* i386/xm-go32.h (EXECUTABLE_SUFFIX): Define."}, {"sha": "95f8b2ceb99400bc32258f5923a8d5376018f7a4", "filename": "gcc/except.c", "status": "modified", "additions": 8, "deletions": 243, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec", "patch": "@@ -707,11 +707,11 @@ add_partial_entry (handler)\n   pop_obstacks ();\n }\n \n-/* Emit code to get EH context to current function. */\n+/* Emit code to get EH context to current function.  Should only be used\n+   by emit_eh_context.  */\n \n static rtx\n-call_get_eh_context (before)\n-     rtx before;\n+call_get_eh_context ()\n {\n   static tree fn;\n   tree expr;\n@@ -748,10 +748,7 @@ call_get_eh_context (before)\n   insns = get_insns ();\n   end_sequence ();\n \n-  if (before != 0)\n-    emit_insns_before (insns, before);\n-  else\n-    emit_insns (insns);\n+  emit_insns_before (insns, get_first_nonparm_insn ());\n \n   return reg;\n }\n@@ -764,7 +761,7 @@ call_get_eh_context (before)\n    in libgcc2, and copy the value to the register we have generated. */\n \n rtx\n-use_eh_context ()\n+get_eh_context ()\n {\n   if (current_function_ehc == 0)\n     {\n@@ -785,39 +782,6 @@ use_eh_context ()\n   return current_function_ehc;\n }\n      \n-/* Get reference to EH context only once per fn. */\n-\n-rtx\n-get_eh_context_once ()\n-{\n-  rtx ehc;\n-\n-  if (current_function_ehc == 0)\n-    use_eh_context ();\n-  \n-  ehc = gen_reg_rtx (Pmode);\n-  emit_move_insn (ehc, current_function_ehc);\n-\n-  return ehc;\n-}\n-\n-/* Get reference to EH context by calling __get_eh_context. */\n-\n-rtx\n-get_eh_context ()\n-{\n-  rtx ehc;\n-\n-  /* If we already have an EH context in the current function,\n-     use it. */\n-  if (current_function_ehc)\n-    ehc = get_eh_context_once ();\n-  else\n-    ehc = call_get_eh_context (0);\n-\n-  return ehc;\n-}\n-\n /* Get a reference to the dynamic handler chain.  It points to the\n    pointer to the next element in the dynamic handler chain.  It ends\n    when there are no more elements in the dynamic handler chain, when\n@@ -832,7 +796,7 @@ get_dynamic_handler_chain ()\n {\n   rtx ehc, dhc, result;\n \n-  ehc = get_eh_context_once ();\n+  ehc = get_eh_context ();\n   dhc = ehc;\n \n   result = copy_to_reg (dhc);\n@@ -861,22 +825,6 @@ get_dynamic_cleanup_chain ()\n   return gen_rtx (MEM, Pmode, result);\n }\n \n-/* Get a reference to the saved_pc variable. */\n-\n-rtx\n-get_saved_pc_ref ()\n-{\n-  rtx ehc, ehpc, result;\n-\n-  /* Saved PC is the second word into the returned structure. */\n-  ehc = get_eh_context ();\n-  ehpc = plus_constant (ehc, GET_MODE_SIZE (Pmode));\n-  result = copy_to_reg (ehpc);\n-\n-  /* We don't want a copy of the ehpc, but rather, the single ehpc.  */\n-  return gen_rtx (MEM, Pmode, result);\n-}\n-\n /* Generate code to evaluate X and jump to LABEL if the value is nonzero.\n    LABEL is an rtx of code CODE_LABEL, in this function.  */\n \n@@ -1704,189 +1652,6 @@ register_exception_table ()\n \t\t     Pmode);\n }\n \f\n-/* Emit the RTL for the start of the per-function unwinder for the\n-   current function. See emit_unwinder for further information.\n-\n-   DOESNT_NEED_UNWINDER is a target-specific macro that determines if\n-   the current function actually needs a per-function unwinder or not.\n-   By default, all functions need one.  */\n-\n-void\n-start_eh_unwinder ()\n-{\n-#ifdef DOESNT_NEED_UNWINDER\n-  if (DOESNT_NEED_UNWINDER)\n-    return;\n-#endif\n-\n-  /* If we are using the setjmp/longjmp implementation, we don't need a\n-     per function unwinder.  */\n-\n-  if (exceptions_via_longjmp)\n-    return;\n-\n-#ifdef DWARF2_UNWIND_INFO\n-  return;\n-#endif\n-\n-  expand_eh_region_start ();\n-}\n-\n-/* Emit insns for the end of the per-function unwinder for the\n-   current function.  */\n-\n-void\n-end_eh_unwinder ()\n-{\n-  tree expr;\n-  rtx return_val_rtx, ret_val, label, end, insns;\n-\n-  if (! doing_eh (0))\n-    return;\n-\n-#ifdef DOESNT_NEED_UNWINDER\n-  if (DOESNT_NEED_UNWINDER)\n-    return;\n-#endif\n-\n-  /* If we are using the setjmp/longjmp implementation, we don't need a\n-     per function unwinder.  */\n-\n-  if (exceptions_via_longjmp)\n-    return;\n-\n-#ifdef DWARF2_UNWIND_INFO\n-  return;\n-#else /* DWARF2_UNWIND_INFO */\n-\n-  expr = make_node (RTL_EXPR);\n-  TREE_TYPE (expr) = void_type_node;\n-  RTL_EXPR_RTL (expr) = const0_rtx;\n-  TREE_SIDE_EFFECTS (expr) = 1;\n-  start_sequence_for_rtl_expr (expr);\n-\n-  /* ret_val will contain the address of the code where the call\n-     to the current function occurred.  */\n-  ret_val = expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,\n-\t\t\t\t\t0, hard_frame_pointer_rtx);\n-  return_val_rtx = copy_to_reg (ret_val);\n-\n-  /* Get the address we need to use to determine what exception\n-     handler should be invoked, and store it in __eh_pc.  */\n-  return_val_rtx = eh_outer_context (return_val_rtx);\n-  return_val_rtx = expand_binop (Pmode, sub_optab, return_val_rtx, GEN_INT (1),\n-\t\t\t\t NULL_RTX, 0, OPTAB_LIB_WIDEN);\n-  emit_move_insn (get_saved_pc_ref (), return_val_rtx);\n-  \n-  /* Either set things up so we do a return directly to __throw, or\n-     we return here instead.  */\n-#ifdef JUMP_TO_THROW\n-  emit_move_insn (ret_val, throw_libfunc);\n-#else\n-  label = gen_label_rtx ();\n-  emit_move_insn (ret_val, gen_rtx (LABEL_REF, Pmode, label));\n-#endif\n-\n-#ifdef RETURN_ADDR_OFFSET\n-  return_val_rtx = plus_constant (ret_val, -RETURN_ADDR_OFFSET);\n-  if (return_val_rtx != ret_val)\n-    emit_move_insn (ret_val, return_val_rtx);\n-#endif\n-  \n-  end = gen_label_rtx ();\n-  emit_jump (end);  \n-\n-  RTL_EXPR_SEQUENCE (expr) = get_insns ();\n-  end_sequence ();\n-\n-  expand_eh_region_end (expr);\n-\n-  emit_jump (end);\n-\n-#ifndef JUMP_TO_THROW\n-  emit_label (label);\n-  emit_throw ();\n-#endif\n-  \n-  expand_leftover_cleanups ();\n-\n-  emit_label (end);\n-\n-#ifdef HAVE_return\n-  if (HAVE_return)\n-    {\n-      emit_jump_insn (gen_return ());\n-      emit_barrier ();\n-    }\n-#endif\n-#endif /* DWARF2_UNWIND_INFO */\n-}\n-\n-/* If necessary, emit insns for the per function unwinder for the\n-   current function.  Called after all the code that needs unwind\n-   protection is output.  \n-\n-   The unwinder takes care of catching any exceptions that have not\n-   been previously caught within the function, unwinding the stack to\n-   the next frame, and rethrowing using the address of the current\n-   function's caller as the context of the throw.\n-\n-   On some platforms __throw can do this by itself (or with the help\n-   of __unwind_function) so the per-function unwinder is\n-   unnecessary.\n-  \n-   We cannot place the unwinder into the function until after we know\n-   we are done inlining, as we don't want to have more than one\n-   unwinder per non-inlined function.  */\n-\n-void\n-emit_unwinder ()\n-{\n-  rtx insns, insn;\n-\n-  start_sequence ();\n-  start_eh_unwinder ();\n-  insns = get_insns ();\n-  end_sequence ();\n-\n-  /* We place the start of the exception region associated with the\n-     per function unwinder at the top of the function.  */\n-  if (insns)\n-    emit_insns_after (insns, get_insns ());\n-\n-  start_sequence ();\n-  end_eh_unwinder ();\n-  insns = get_insns ();\n-  end_sequence ();\n-\n-  /* And we place the end of the exception region before the USE and\n-     CLOBBER insns that may come at the end of the function.  */\n-  if (insns == 0)\n-    return;\n-\n-  insn = get_last_insn ();\n-  while (GET_CODE (insn) == NOTE\n-\t || (GET_CODE (insn) == INSN\n-\t     && (GET_CODE (PATTERN (insn)) == USE\n-\t\t || GET_CODE (PATTERN (insn)) == CLOBBER)))\n-    insn = PREV_INSN (insn);\n-\n-  if (GET_CODE (insn) == CODE_LABEL\n-      && GET_CODE (PREV_INSN (insn)) == BARRIER)\n-    {\n-      insn = PREV_INSN (insn);\n-    }\n-  else\n-    {\n-      rtx label = gen_label_rtx ();\n-      emit_label_after (label, insn);\n-      insn = emit_jump_insn_after (gen_jump (label), insn);\n-      insn = emit_barrier_after (insn);\n-    }\n-    \n-  emit_insns_after (insns, insn);\n-}\n-\n /* Emit code to get EH context.\n    \n    We have to scan thru the code to find possible EH context registers.\n@@ -1913,9 +1678,9 @@ emit_eh_context ()\n \t  {\n \t    rtx insns;\n \t    \n-\t    /* If this is the first use insn, emit the call here. */\n+\t    /* If this is the first use insn, emit the call. */\n \t    if (ehc == 0)\n-\t      ehc = call_get_eh_context (insn);\n+\t      ehc = call_get_eh_context ();\n \n \t    start_sequence ();\n \t    emit_move_insn (XEXP (reg, 0), ehc);"}, {"sha": "cdc1bd7356ca8ccd931f2d04cc6d9d518e0b8ad8", "filename": "gcc/except.h", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec", "patch": "@@ -250,13 +250,7 @@ extern rtx exception_handler_labels;\n \n extern void exception_optimize\t\t\tPROTO((void));\n \n-/* Use EH context once per fn.  */\n-extern rtx use_eh_context\t\t\tPROTO((void));\n-\n-/* Get the EH contex only once per fn.  */\n-extern rtx get_eh_context_once\t\t\tPROTO((void));\n-\n-/* Get the EH contex.  */\n+/* Return EH context (and set it up once per fn).  */\n extern rtx get_eh_context\t\t\tPROTO((void));\n \n /* Get the dynamic handler chain.  */\n@@ -265,9 +259,6 @@ extern rtx get_dynamic_handler_chain\t\tPROTO((void));\n /* Get the dynamic cleanup chain.  */\n extern rtx get_dynamic_cleanup_chain\t\tPROTO((void));\n \n-/* Get the saved PC variable. */\n-extern rtx get_saved_pc_ref\t\t\tPROTO((void));\n-\n /* Throw an exception.  */\n \n extern void emit_throw\t\t\t\tPROTO((void));"}, {"sha": "6d27e4957653731770ed6c2ec4a901ea6d14a89b", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec", "patch": "@@ -1809,7 +1809,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t     the current fn has one. */\n \t  if (GET_CODE (pattern) == USE\n \t      && find_reg_note (insn, REG_EH_CONTEXT, 0) != 0)\n-\t    use_eh_context ();\n+\t    get_eh_context ();\n \n \t  /* Ignore setting a function value that we don't want to use.  */\n \t  if (map->inline_target == 0"}, {"sha": "d2c906cd59cc4f9c438036154a1dafb36ab6d9ae", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=01eb7f9a1ccd7a2edb8902dee4546cc9f5e154ec", "patch": "@@ -3205,10 +3205,6 @@ rest_of_compilation (decl)\n   /* Emit code to get eh context, if needed. */\n   emit_eh_context ();\n \n-  /* Add an unwinder for exception handling, if needed.\n-     This must be done before we finalize PIC code.  */\n-  emit_unwinder ();\n-\n #ifdef FINALIZE_PIC\n   /* If we are doing position-independent code generation, now\n      is the time to output special prologues and epilogues."}]}