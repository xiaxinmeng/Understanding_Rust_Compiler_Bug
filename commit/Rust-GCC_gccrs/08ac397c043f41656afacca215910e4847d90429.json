{"sha": "08ac397c043f41656afacca215910e4847d90429", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhhYzM5N2MwNDNmNDE2NTZhZmFjY2EyMTU5MTBlNDg0N2Q5MDQyOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2001-07-25T15:04:32Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-07-25T15:04:32Z"}, "message": "call.c (joust): Only prefer a non-builtin candidate to a builtin one if...\n\n        * call.c (joust): Only prefer a non-builtin candidate to a builtin\n        one if they have the same signature.\n\n        * cvt.c (build_up_reference): Take DECL parm.  Check TREE_STATIC on\n        it rather than toplevel_bindings_p.  Give it a mangled name if static.\n        (convert_to_reference): Adjust.\n        * decl2.c (get_temp_name): Lose.\n        * mangle.c (mangle_ref_init_variable): New fn.\n        (mangle_guard_variable): Strip the ref-init header.\n        * cp-tree.h: Adjust.\n        * decl.c (cp_finish_decl): Add the DECL_STMT after processing the\n        initializer.\n        (grok_reference_init): Always use DECL_INITIAL.\n\nFrom-SVN: r44358", "tree": {"sha": "1ff1db2f3cbcf8e88fb53dffde7dfb01277d772d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ff1db2f3cbcf8e88fb53dffde7dfb01277d772d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08ac397c043f41656afacca215910e4847d90429", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08ac397c043f41656afacca215910e4847d90429", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08ac397c043f41656afacca215910e4847d90429", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08ac397c043f41656afacca215910e4847d90429/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ea0eceb16511d7e3e6ab0fb78e6641b8aed4e829", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea0eceb16511d7e3e6ab0fb78e6641b8aed4e829", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea0eceb16511d7e3e6ab0fb78e6641b8aed4e829"}], "stats": {"total": 217, "additions": 133, "deletions": 84}, "files": [{"sha": "050f437f6d7d7d19ff1e4699d9f6d5a5598b6147", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ac397c043f41656afacca215910e4847d90429/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ac397c043f41656afacca215910e4847d90429/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=08ac397c043f41656afacca215910e4847d90429", "patch": "@@ -1,3 +1,19 @@\n+2001-07-25  Jason Merrill  <jason_merrill@redhat.com>\n+\t\n+\t* call.c (joust): Only prefer a non-builtin candidate to a builtin\n+\tone if they have the same signature.\n+\n+\t* cvt.c (build_up_reference): Take DECL parm.  Check TREE_STATIC on\n+\tit rather than toplevel_bindings_p.  Give it a mangled name if static.\n+\t(convert_to_reference): Adjust.\n+\t* decl2.c (get_temp_name): Lose.\n+\t* mangle.c (mangle_ref_init_variable): New fn.\n+\t(mangle_guard_variable): Strip the ref-init header.\n+\t* cp-tree.h: Adjust.\n+\t* decl.c (cp_finish_decl): Add the DECL_STMT after processing the\n+\tinitializer.\n+\t(grok_reference_init): Always use DECL_INITIAL.\n+\n 2001-07-25  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/3416"}, {"sha": "268cc273a561843e64494676787e5f730bc1ec24", "filename": "gcc/cp/call.c", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ac397c043f41656afacca215910e4847d90429/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ac397c043f41656afacca215910e4847d90429/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=08ac397c043f41656afacca215910e4847d90429", "patch": "@@ -5353,22 +5353,6 @@ joust (cand1, cand2, warn)\n         return winner;\n     }\n \n-  /* a non-template user function is better than a builtin.  (Pedantically\n-     the builtin which matched the user function should not be added to\n-     the overload set, but we spot it here.\n-     \n-     [over.match.oper]\n-     ... the builtin candidates include ...\n-     - do not have the same parameter type list as any non-template\n-       non-member candidate.  */\n-                            \n-  if (TREE_CODE (cand1->fn) != IDENTIFIER_NODE\n-      && TREE_CODE (cand2->fn) == IDENTIFIER_NODE)\n-    return 1;\n-  else if (TREE_CODE (cand1->fn) == IDENTIFIER_NODE\n-           && TREE_CODE (cand2->fn) != IDENTIFIER_NODE)\n-    return -1;\n-  \n   /* or, if not that,\n      the  context  is  an  initialization by user-defined conversion (see\n      _dcl.init_  and  _over.match.user_)  and  the  standard   conversion\n@@ -5384,21 +5368,42 @@ joust (cand1, cand2, warn)\n         return winner;\n     }\n   \n-  /* If the built-in candidates are the same, arbitrarily pick one.  */\n-  if (cand1->fn == cand2->fn\n-      && TREE_CODE (cand1->fn) == IDENTIFIER_NODE)\n+  /* Check whether we can discard a builtin candidate, either because we\n+     have two identical ones or matching builtin and non-builtin candidates.\n+\n+     (Pedantically in the latter case the builtin which matched the user\n+     function should not be added to the overload set, but we spot it here.\n+     \n+     [over.match.oper]\n+     ... the builtin candidates include ...\n+     - do not have the same parameter type list as any non-template\n+       non-member candidate.  */\n+                            \n+  if (TREE_CODE (cand1->fn) == IDENTIFIER_NODE\n+      || TREE_CODE (cand2->fn) == IDENTIFIER_NODE)\n     {\n       for (i = 0; i < len; ++i)\n \tif (!same_type_p (TREE_TYPE (TREE_VEC_ELT (cand1->convs, i)),\n \t\t\t  TREE_TYPE (TREE_VEC_ELT (cand2->convs, i))))\n \t  break;\n       if (i == TREE_VEC_LENGTH (cand1->convs))\n-\treturn 1;\n+\t{\n+\t  if (cand1->fn == cand2->fn)\n+\t    /* Two built-in candidates; arbitrarily pick one.  */\n+\t    return 1;\n+\t  else if (TREE_CODE (cand1->fn) == IDENTIFIER_NODE)\n+\t    /* cand1 is built-in; prefer cand2.  */\n+\t    return -1;\n+\t  else\n+\t    /* cand2 is built-in; prefer cand1.  */\n+\t    return 1;\n+\t}\n \n       /* Kludge around broken overloading rules whereby\n \t Integer a, b; test ? a : b; is ambiguous, since there's a builtin\n \t that takes references and another that takes values.  */\n-      if (cand1->fn == ansi_opname (COND_EXPR))\n+      if (cand1->fn == cand2->fn\n+\t  && cand1->fn == ansi_opname (COND_EXPR))\n \t{\n \t  tree c1 = TREE_VEC_ELT (cand1->convs, 1);\n \t  tree c2 = TREE_VEC_ELT (cand2->convs, 1);"}, {"sha": "d5f10e4397d3b1bf2df7844fb78ed1ff5c4c0852", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ac397c043f41656afacca215910e4847d90429/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ac397c043f41656afacca215910e4847d90429/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=08ac397c043f41656afacca215910e4847d90429", "patch": "@@ -3784,7 +3784,6 @@ extern void cplus_decl_attributes\t\tPARAMS ((tree *, tree, tree, int));\n extern tree constructor_name_full\t\tPARAMS ((tree));\n extern tree constructor_name\t\t\tPARAMS ((tree));\n extern void defer_fn            \t\tPARAMS ((tree));\n-extern tree get_temp_name\t\t\tPARAMS ((tree));\n extern void finish_anon_union\t\t\tPARAMS ((tree));\n extern tree finish_table\t\t\tPARAMS ((tree, tree, tree, int));\n extern void finish_builtin_type\t\t\tPARAMS ((tree, const char *,\n@@ -4384,6 +4383,7 @@ extern tree mangle_ctor_vtbl_for_type           PARAMS ((tree, tree));\n extern tree mangle_thunk                        PARAMS ((tree, tree, tree));\n extern tree mangle_conv_op_name_for_type        PARAMS ((tree));\n extern tree mangle_guard_variable               PARAMS ((tree));\n+extern tree mangle_ref_init_variable            PARAMS ((tree));\n \n /* in dump.c */\n extern int cp_dump_tree                         PARAMS ((dump_info_p, tree));"}, {"sha": "3637cc0535a52b958f1006634f0112da4d81c7a4", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ac397c043f41656afacca215910e4847d90429/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ac397c043f41656afacca215910e4847d90429/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=08ac397c043f41656afacca215910e4847d90429", "patch": "@@ -37,7 +37,7 @@ Boston, MA 02111-1307, USA.  */\n \n static tree cp_convert_to_pointer PARAMS ((tree, tree, int));\n static tree convert_to_pointer_force PARAMS ((tree, tree));\n-static tree build_up_reference PARAMS ((tree, tree, int));\n+static tree build_up_reference PARAMS ((tree, tree, int, tree));\n static void warn_ref_binding PARAMS ((tree, tree, tree));\n \n /* Change of width--truncation and extension of integers or reals--\n@@ -358,11 +358,12 @@ convert_to_pointer_force (type, expr)\n    value we have to begin with is in ARG.\n \n    FLAGS controls how we manage access checking.\n-   DIRECT_BIND in FLAGS controls how any temporaries are generated.  */\n+   DIRECT_BIND in FLAGS controls how any temporaries are generated.\n+     If DIRECT_BIND is set, DECL is the reference we're binding to.  */\n \n static tree\n-build_up_reference (type, arg, flags)\n-     tree type, arg;\n+build_up_reference (type, arg, flags, decl)\n+     tree type, arg, decl;\n      int flags;\n {\n   tree rval;\n@@ -374,15 +375,28 @@ build_up_reference (type, arg, flags)\n \n   if ((flags & DIRECT_BIND) && ! real_lvalue_p (arg))\n     {\n-      /* Create a new temporary variable.  */\n+      /* Create a new temporary variable.  We can't just use a TARGET_EXPR\n+\t here because it needs to live as long as DECL.  */\n       tree targ = arg;\n-      if (toplevel_bindings_p ())\n-\targ = get_temp_name (argtype);\n+\n+      arg = build_decl (VAR_DECL, NULL_TREE, argtype);\n+      DECL_ARTIFICIAL (arg) = 1;\n+      TREE_USED (arg) = 1;\n+      TREE_STATIC (arg) = TREE_STATIC (decl);\n+\n+      if (TREE_STATIC (decl))\n+\t{\n+\t  /* Namespace-scope or local static; give it a mangled name.  */\n+\t  tree name = mangle_ref_init_variable (decl);\n+\t  DECL_NAME (arg) = name;\n+\t  SET_DECL_ASSEMBLER_NAME (arg, name);\n+\t  arg = pushdecl_top_level (arg);\n+\t}\n       else\n \t{\n+\t  /* automatic; make sure we handle the cleanup properly.  */\n \t  maybe_push_cleanup_level (argtype);\n-\t  arg = pushdecl (build_decl (VAR_DECL, NULL_TREE, argtype));\n-\t  DECL_ARTIFICIAL (arg) = 1;\n+\t  arg = pushdecl (arg);\n \t}\n \n       /* Process the initializer for the declaration.  */\n@@ -393,7 +407,7 @@ build_up_reference (type, arg, flags)\n   else if (!(flags & DIRECT_BIND) && ! lvalue_p (arg))\n     return get_target_expr (arg);\n \n-  /* If we had a way to wrap this up, and say, if we ever needed it's\n+  /* If we had a way to wrap this up, and say, if we ever needed its\n      address, transform all occurrences of the register, into a memory\n      reference we could win better.  */\n   rval = build_unary_op (ADDR_EXPR, arg, 1);\n@@ -531,7 +545,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t\t\tttr, reftype);\n \t}\n \n-      return build_up_reference (reftype, expr, flags);\n+      return build_up_reference (reftype, expr, flags, decl);\n     }\n   else if ((convtype & CONV_REINTERPRET) && lvalue_p (expr))\n     {\n@@ -562,7 +576,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n       if (rval == NULL_TREE || rval == error_mark_node)\n \treturn rval;\n       warn_ref_binding (reftype, intype, decl);\n-      rval = build_up_reference (reftype, rval, flags);\n+      rval = build_up_reference (reftype, rval, flags, decl);\n     }\n \n   if (rval)"}, {"sha": "4bbf2e0f5d489474170d72dc26287fb6ae244c58", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ac397c043f41656afacca215910e4847d90429/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ac397c043f41656afacca215910e4847d90429/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=08ac397c043f41656afacca215910e4847d90429", "patch": "@@ -7386,14 +7386,7 @@ grok_reference_init (decl, type, init)\n   if (TREE_STATIC (decl) && !TREE_CONSTANT (tmp))\n     return tmp;\n \n-  if (building_stmt_tree ())\n-    {\n-      /* Initialize the declaration.  */\n-      tmp = build (INIT_EXPR, TREE_TYPE (decl), decl, tmp);\n-      finish_expr_stmt (tmp);\n-    }\n-  else\n-    DECL_INITIAL (decl) = tmp;\n+  DECL_INITIAL (decl) = tmp;\n \n   return NULL_TREE;\n }\n@@ -8010,17 +8003,16 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n   if (type == error_mark_node)\n     return;\n \n-  /* Add this declaration to the statement-tree.  */\n-  if (building_stmt_tree ()\n-      && at_function_scope_p ()\n-      && TREE_CODE (decl) != RESULT_DECL)\n-    add_decl_stmt (decl);\n-\n   if (TYPE_HAS_MUTABLE_P (type))\n     TREE_READONLY (decl) = 0;\n \n   if (processing_template_decl)\n     {\n+      /* Add this declaration to the statement-tree.  */\n+      if (at_function_scope_p ()\n+\t  && TREE_CODE (decl) != RESULT_DECL)\n+\tadd_decl_stmt (decl);\n+\n       if (init && DECL_INITIAL (decl))\n \tDECL_INITIAL (decl) = init;\n       goto finish_end0;\n@@ -8089,6 +8081,12 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n \n   GNU_xref_decl (current_function_decl, decl);\n \n+  /* Add this declaration to the statement-tree.  */\n+  if (building_stmt_tree ()\n+      && at_function_scope_p ()\n+      && TREE_CODE (decl) != RESULT_DECL)\n+    add_decl_stmt (decl);\n+\n   if (TREE_CODE (decl) == VAR_DECL)\n     layout_var_decl (decl);\n "}, {"sha": "ef419bd474194edda0afd872eb8414ab23fa3f7b", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ac397c043f41656afacca215910e4847d90429/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ac397c043f41656afacca215910e4847d90429/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=08ac397c043f41656afacca215910e4847d90429", "patch": "@@ -1946,41 +1946,6 @@ defer_fn (fn)\n   VARRAY_PUSH_TREE (deferred_fns, fn);\n }\n \n-/* Hand off a unique name which can be used for variable we don't really\n-   want to know about anyway, for example, the anonymous variables which\n-   are needed to make references work.  Declare this thing so we can use it.\n-   The variable created will be of type TYPE, and will have internal\n-   linkage.  */\n-\n-tree\n-get_temp_name (type)\n-     tree type;\n-{\n-  char buf[sizeof (AUTO_TEMP_FORMAT) + 20];\n-  tree decl;\n-  int toplev = toplevel_bindings_p ();\n-\n-  sprintf (buf, AUTO_TEMP_FORMAT, global_temp_name_counter++);\n-  decl = build_decl (VAR_DECL, get_identifier (buf), type);\n-  DECL_ARTIFICIAL (decl) = 1;\n-  TREE_USED (decl) = 1;\n-  TREE_STATIC (decl) = 1;\n-  \n-  decl = pushdecl_top_level (decl);\n-\n-  /* If this is a local variable, then lay out its rtl now.\n-     Otherwise, callers of this function are responsible for dealing\n-     with this variable's rtl.  */\n-  if (! toplev)\n-    {\n-      expand_decl (decl);\n-      my_friendly_assert (DECL_INITIAL (decl) == NULL_TREE,\n-\t\t\t  19990826);\n-    }\n-\n-  return decl;\n-}\n-\n /* Hunts through the global anonymous union ANON_DECL, building\n    appropriate VAR_DECLs.  Stores cleanups on the list of ELEMS, and\n    returns a VAR_DECL whose size is the same as the size of the"}, {"sha": "6e94681e51eae6e58b421a6892418e8abf58e9f8", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ac397c043f41656afacca215910e4847d90429/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ac397c043f41656afacca215910e4847d90429/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=08ac397c043f41656afacca215910e4847d90429", "patch": "@@ -2420,10 +2420,28 @@ mangle_guard_variable (variable)\n {\n   start_mangling ();\n   write_string (\"_ZGV\");\n-  write_name (variable, /*ignore_local_scope=*/0);\n+  if (strncmp (IDENTIFIER_POINTER (DECL_NAME (variable)), \"_ZGR\", 4) == 0)\n+    /* The name of a guard variable for a reference temporary should refer\n+       to the reference, not the temporary.  */\n+    write_string (IDENTIFIER_POINTER (DECL_NAME (variable)) + 4);\n+  else\n+    write_name (variable, /*ignore_local_scope=*/0);\n   return get_identifier (finish_mangling ());\n }\n \n+/* Return an identifier for the name of a temporary variable used to\n+   initialize a static reference.  This isn't part of the ABI, but we might\n+   as well call them something readable.  */\n+\n+tree\n+mangle_ref_init_variable (variable)\n+     tree variable;\n+{\n+  start_mangling ();\n+  write_string (\"_ZGR\");\n+  write_name (variable, /*ignore_local_scope=*/0);\n+  return get_identifier (finish_mangling ());\n+}\n \f\n \n /* Foreign language type mangling section.  */"}, {"sha": "318b819834dad663da54374aaee81a2b1fe934c1", "filename": "gcc/testsuite/g++.dg/README", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ac397c043f41656afacca215910e4847d90429/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ac397c043f41656afacca215910e4847d90429/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FREADME?ref=08ac397c043f41656afacca215910e4847d90429", "patch": "@@ -0,0 +1,17 @@\n+Subdirectories:\n+\n+abi\t Tests for ABI compatibility -- mangling, object layout, etc.\n+eh\t Tests for exception handling.\n+ext\t Tests for GNU language extensions.\n+inherit\t Tests for inheritance -- virtual functions, multiple inheritance, etc.\n+init\t Tests for initialization semantics, constructors/destructors, etc.\n+lookup\t Tests for lookup semantics, namespaces, etc.\n+overload Tests for overload resolution and conversions.\n+rtti\t Tests for run-time type identification (typeid, dynamic_cast, etc.)\n+template Tests for templates.\n+warn\t Tests for compiler warnings.\n+\n+other\t Tests that don't fit into one of the other categories.\n+\n+special\t Tests that need custom expect code to run them; see special/ecos.exp\n+\t for an example."}, {"sha": "d0170cd18f6765431422533b1edbb17d962b90f7", "filename": "gcc/testsuite/g++.dg/init/init-ref1.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ac397c043f41656afacca215910e4847d90429/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Finit-ref1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ac397c043f41656afacca215910e4847d90429/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Finit-ref1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Finit-ref1.C?ref=08ac397c043f41656afacca215910e4847d90429", "previous_filename": "gcc/testsuite/g++.dg/other/init-ref1.C"}, {"sha": "6d9448a8e9c8628aa5d26526688b7474f7d31abc", "filename": "gcc/testsuite/g++.dg/init/init-ref2.C", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ac397c043f41656afacca215910e4847d90429/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Finit-ref2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ac397c043f41656afacca215910e4847d90429/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Finit-ref2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Finit-ref2.C?ref=08ac397c043f41656afacca215910e4847d90429", "previous_filename": "gcc/testsuite/g++.dg/other/init-ref2.C"}, {"sha": "9f66e336065103b7bd36d05cd31555af37f80286", "filename": "gcc/testsuite/g++.dg/overload/builtin1.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ac397c043f41656afacca215910e4847d90429/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fbuiltin1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ac397c043f41656afacca215910e4847d90429/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fbuiltin1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fbuiltin1.C?ref=08ac397c043f41656afacca215910e4847d90429", "patch": "@@ -0,0 +1,16 @@\n+// Test that we don't discard builtin candidates inappropriately.\n+\n+struct B { };\n+\n+struct A {\n+  operator int ();\n+  operator B ();\n+};\n+\n+void operator+ (B, B);\t\t// { dg-error \"\" \"candidate\" }\n+\n+int main ()\n+{\n+  A a;\n+  a + a;\t\t\t// { dg-error \"\" \"ambiguous\" }\n+}"}]}