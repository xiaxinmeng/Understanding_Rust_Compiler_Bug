{"sha": "4afe82523f19171fb0a67fab5ec80c8f645db517", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFmZTgyNTIzZjE5MTcxZmIwYTY3ZmFiNWVjODBjOGY2NDVkYjUxNw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2019-02-24T22:49:47Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2019-02-24T22:49:47Z"}, "message": "re PR fortran/89174 (Allocation segfault with CLASS(*) MOLD)\n\n2019-02-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/89174\n\t* trans-expr.c (gfc_find_and_cut_at_last_class_ref): Add is_mold\n\tto garguments. If we are dealing with a MOLD, call\n\tgfc_expr_to_initialize().\n\t* trans-stmt.c (gfc_trans_allocate): For MOLD, pass is_mold=true\n\tto gfc_find_and_cut_at_last_class_ref.\n\t* trans.h (gfc_find_and_cut_at_last_class_ref): Add optional\n\targument is_mold with default false.\n\n2019-02-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/89174\n\t* gfortran.dg/allocate_with_mold_3.f90: New test.\n\nFrom-SVN: r269179", "tree": {"sha": "15d890f60a78e20ebf11013e77630181130508cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15d890f60a78e20ebf11013e77630181130508cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4afe82523f19171fb0a67fab5ec80c8f645db517", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4afe82523f19171fb0a67fab5ec80c8f645db517", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4afe82523f19171fb0a67fab5ec80c8f645db517", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4afe82523f19171fb0a67fab5ec80c8f645db517/comments", "author": null, "committer": null, "parents": [{"sha": "28d08ad204087e2c9e979d8dc94daba7ac4c63a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28d08ad204087e2c9e979d8dc94daba7ac4c63a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28d08ad204087e2c9e979d8dc94daba7ac4c63a3"}], "stats": {"total": 48, "additions": 44, "deletions": 4}, "files": [{"sha": "16b8eb0555f45332402a55c8f3b2fbcfe442593d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4afe82523f19171fb0a67fab5ec80c8f645db517/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4afe82523f19171fb0a67fab5ec80c8f645db517/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4afe82523f19171fb0a67fab5ec80c8f645db517", "patch": "@@ -1,3 +1,14 @@\n+2019-02-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/89174\n+\t* trans-expr.c (gfc_find_and_cut_at_last_class_ref): Add is_mold\n+\tto garguments. If we are dealing with a MOLD, call\n+\tgfc_expr_to_initialize().\n+\t* trans-stmt.c (gfc_trans_allocate): For MOLD, pass is_mold=true\n+\tto gfc_find_and_cut_at_last_class_ref.\n+\t* trans.h (gfc_find_and_cut_at_last_class_ref): Add optional\n+\targument is_mold with default false.\n+\n 2019-02-24  Harald Anlauf  <anlauf@gmx.de>\n \n \tPR fortran/89266"}, {"sha": "07027139d048c82891ae71908f2fc89925d646c2", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4afe82523f19171fb0a67fab5ec80c8f645db517/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4afe82523f19171fb0a67fab5ec80c8f645db517/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=4afe82523f19171fb0a67fab5ec80c8f645db517", "patch": "@@ -352,7 +352,7 @@ gfc_vptr_size_get (tree vptr)\n    of refs following.  */\n \n gfc_expr *\n-gfc_find_and_cut_at_last_class_ref (gfc_expr *e)\n+gfc_find_and_cut_at_last_class_ref (gfc_expr *e, bool is_mold)\n {\n   gfc_expr *base_expr;\n   gfc_ref *ref, *class_ref, *tail = NULL, *array_ref;\n@@ -394,7 +394,10 @@ gfc_find_and_cut_at_last_class_ref (gfc_expr *e)\n       e->ref = NULL;\n     }\n \n-  base_expr = gfc_copy_expr (e);\n+  if (is_mold)\n+    base_expr = gfc_expr_to_initialize (e);\n+  else\n+    base_expr = gfc_copy_expr (e);\n \n   /* Restore the original tail expression.  */\n   if (class_ref)"}, {"sha": "5b6625fdacb998cfaae39216ca4ec6b9da49864d", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4afe82523f19171fb0a67fab5ec80c8f645db517/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4afe82523f19171fb0a67fab5ec80c8f645db517/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=4afe82523f19171fb0a67fab5ec80c8f645db517", "patch": "@@ -6641,7 +6641,7 @@ gfc_trans_allocate (gfc_code * code)\n \t  /* Use class_init_assign to initialize expr.  */\n \t  gfc_code *ini;\n \t  ini = gfc_get_code (EXEC_INIT_ASSIGN);\n-\t  ini->expr1 = gfc_find_and_cut_at_last_class_ref (expr);\n+\t  ini->expr1 = gfc_find_and_cut_at_last_class_ref (expr, true);\n \t  tmp = gfc_trans_class_init_assign (ini);\n \t  gfc_free_statements (ini);\n \t  gfc_add_expr_to_block (&block, tmp);"}, {"sha": "9d9ac225b8dc85e2a932aa62e2a2195d5fe19014", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4afe82523f19171fb0a67fab5ec80c8f645db517/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4afe82523f19171fb0a67fab5ec80c8f645db517/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=4afe82523f19171fb0a67fab5ec80c8f645db517", "patch": "@@ -412,7 +412,7 @@ tree gfc_class_data_get (tree);\n tree gfc_class_vptr_get (tree);\n tree gfc_class_len_get (tree);\n tree gfc_class_len_or_zero_get (tree);\n-gfc_expr * gfc_find_and_cut_at_last_class_ref (gfc_expr *);\n+gfc_expr * gfc_find_and_cut_at_last_class_ref (gfc_expr *, bool is_mold = false);\n /* Get an accessor to the class' vtab's * field, when a class handle is\n    available.  */\n tree gfc_class_vtab_hash_get (tree);"}, {"sha": "624382c64bd1accae316232fc66a837730dbf573", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4afe82523f19171fb0a67fab5ec80c8f645db517/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4afe82523f19171fb0a67fab5ec80c8f645db517/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4afe82523f19171fb0a67fab5ec80c8f645db517", "patch": "@@ -1,3 +1,8 @@\n+2019-02-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/89174\n+\t* gfortran.dg/allocate_with_mold_3.f90: New test.\n+\n 2019-02-24  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/87007"}, {"sha": "797edbe7d49e5bf569483e6ba78d58423b8fa665", "filename": "gcc/testsuite/gfortran.dg/allocate_with_mold_3.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4afe82523f19171fb0a67fab5ec80c8f645db517/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_mold_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4afe82523f19171fb0a67fab5ec80c8f645db517/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_mold_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_mold_3.f90?ref=4afe82523f19171fb0a67fab5ec80c8f645db517", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do  run }\n+! PR fortran/89174 - this used to segfault on execution.\n+! Test case by Neil Carlson.\n+module mod\n+  type :: array_data\n+    class(*), allocatable :: mold\n+  contains\n+    procedure :: push\n+  end type\n+contains\n+  subroutine push(this, value)\n+    class(array_data), intent(inout) :: this\n+    class(*), intent(in) :: value\n+    allocate(this%mold, mold=value) ! <== SEGFAULTS HERE\n+  end subroutine\n+end module\n+\n+use mod\n+type(array_data) :: foo\n+call foo%push(42)\n+end"}]}