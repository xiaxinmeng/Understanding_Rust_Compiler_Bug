{"sha": "325c36911589375105e5437c513bf880aeffdc75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI1YzM2OTExNTg5Mzc1MTA1ZTU0MzdjNTEzYmY4ODBhZWZmZGM3NQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-06-16T01:21:38Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-06-16T01:21:38Z"}, "message": "c-common.c (lang_gimplify_stmt): Remove next_p argument.\n\n\t* c-common.c (lang_gimplify_stmt): Remove next_p argument.\n\t(if_elt, if_stack, if_stack_space, c_expand_start_cond, c_finish_then,\n\tc_expand_end_cond, c_expand_start_else, c_finish_else, c_begin_if_stmt,\n\tc_begin_while_stmt, c_finish_while_stmt_cond): Move to c-typeck.c.\n\t(finish_fname_decls, fname_decl): Use statement_lists.\n\t(c_expand_expr_stmt): Don't set last_expr_type.\n\t(c_type_hash): Fix indentation.\n\t(c_safe_from_p): Don't follow TREE_CHAIN.\n\t(c_tree_chain_matters_p): Remove.\n\t* c-common.def (SCOPE_STMT): Remove.\n\t(CLEANUP_STMT): Redefine to contain its own body.\n\t* c-common.h (struct stmt_tree_s): Remove x_last_stmt,\n\tx_last_expr_type, x_last_expr_filename, x_scope_stmt_stack.\n\tAdd x_cur_stmt_list.\n\t(last_tree, last_expr_type, last_expr_filename, RECHAIN_STMTS): Remove.\n\t(cur_stmt_list): New.\n\t(STATEMENT_LIST_STMT_EXPR): New.\n\t(SCOPE_BEGIN_P, SCOPE_END_P, SCOPE_STMT_BLOCK, SCOPE_NULLIFIED_P,\n\tSCOPE_NO_CLEANUPS_P, SCOPE_PARTIAL_P, NEW_FOR_SCOPE_P): Remove.\n\t(CLEANUP_BODY): New.\n\t(CLEANUP_DECL): Move to operand 2.\n\t(c_common_stmt_codes): Remove SCOPE_STMT.\n\t(COMPOUND_STMT_NO_SCOPE, COMPOUND_STMT_BODY_BLOCK): Remove.\n\t* c-decl.c (c_scope_stmt_stack, current_scope_stmt_stack): Remove.\n\t(c_push_function_context, c_pop_function_context): Don't save it.\n\t(finish_decl): Set TREE_USED on the decl for a cleanup.\n\tUse push_cleanup.\n\t(store_parm_decls): Use statement lists.\n\t(finish_function): Remove compstmt rule workaround.  Use statement\n\tlists.  Call finish_fname_decls after finalizing the body.\n\t(c_begin_compound_stmt): Move to c-typeck.c.\n\t* c-dump.c (c_dump_tree): Remove SCOPE_STMT.\n\t* c-gimplify.c (gimplify_cleanup_stmt, gimplify_cleanup_stmts): New.\n\t(c_genericize): Invoke them.\n\t(c_gimplify_stmt): Don't look through TREE_CHAIN.  Kill SCOPE_STMT.\n\t(c_build_bind_expr): Export.\n\t(gimplify_block, gimplify_cleanup): Remove.\n\t(gimplify_condition): Use gimplify_stmt.\n\t(gimplify_for_stmt): Remove FOR_INIT_STMT chaining hack.\n\t(gimplify_if_stmt): Remove recursion hack.\n\t(c_gimplify_expr): Remove STMT_EXPR handling.\n\t(stmt_expr_last_stmt, gimplify_stmt_expr): Remove.\n\t(is_last_stmt_of_scope): Remove.\n\t* c-lang.c (LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P): Remove.\n\t* c-mudflap.c (mflang_flush_calls): Use c_begin_compound_stmt,\n\tc_end_compound_stmt.\n\t* c-objc-common.c (build_cdtor): Likewise.\n\t* c-parse.in (primary): Use c_finish_stmt_expr.\n\t(push_scope, pop_scope): Remove.\n\t(c99_block_start, compstmt_start): Use c_begin_compound_stmt.\n\t(c99_block_end, compstmt): Use c_end_compound_stmt.\n\t(c99_block_lineno_labeled_stmt): Likewise.\n\t(compstmt_primary_start): Use c_begin_stmt_expr.\n\t(simple_if, select_or_iter_stmt): Update calls to stmt builders.\n\t(do_stmt_start): Fill in body directly.\n\t(lineno_stmt): Avoid setting lineno on constants.\n\t* c-pretty-print.c (pp_c_statement): Handle STATEMENT_LIST.\n\tRemove SCOPE_STMT.\n\t* c-semantics.c (begin_stmt_tree): Remove.\n\t(push_stmt_list, re_push_stmt_list, pop_stmt_list): New.\n\t(add_stmt): Use statement lists.\n\t(add_scope_stmt, finish_stmt_tree): Remove.\n\t(push_cleanup): New.\n\t* c-tree.h: Move some decls from c-common.h.\n\t* c-typeck.c (c_tree_expr_nonnegative_p): Simplify for statement lists.\n\t(do_case, c_finish_case): Likewise.\n\t(c_finish_then): Take body for then as argument.\n\t(c_finish_else): Similarly.\n\t(c_begin_for_stmt, c_finish_for_stmt_init, c_finish_for_stmt_cond,\n\tc_finish_for_stmt_incr, c_finish_for_stmt): New.\n\t(c_begin_stmt_expr, c_finish_stmt_expr): New.\n\t(c_begin_compound_stmt): Do scope management.\n\t(c_end_compound_stmt): New.\n\t* fold-const.c (tree_expr_nonnegative_p): Fix BIND_EXPR.\n\t* gimplify.c (voidify_wrapper_expr): Accept temporary argument.\n\tLook through exception handling constructs.\n\t(gimplify_bind_expr): Accept temporary argument.\n\t(gimplify_target_expr): Special case BIND_EXPR bodies.\n\t(gimplify_expr): Handle fallback == fb_none like a statement.\n\t* langhooks-def.h (LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P): Kill.\n\t* langhooks.c (lhd_tree_inlining_tree_chain_matters_p): Remove.\n\t* langhooks.h (tree_chain_matters_p): Remove.\n\t* stub-objc.c (objc_clear_super_receiver): New.\n\t* tree-gimple.h (voidify_wrapper_expr): Update decl.\n\t(append_to_statement_list, append_to_statement_list_force): Move\n\tto tree-iterator.h.\n\t* tree-inline.c (expand_call_inline): Update call.\n\t(clone_body): Use statement lists.\n\t(walk_tree): Don't check tree_chain_matters_p.\n\t(copy_tree_r): Likewise.\n\t* tree-iterator.c (alloc_stmt_list): Clear lang bits.\n\t(tsi_link_before, tsi_link_after): Set TREE_SIDE_EFFECTS properly.\n\t* tree-iterator.h (append_to_statement_list,\n\tappend_to_statement_list_force): Moved from tree-gimple.h.\n\t* tree-pretty-print.c (dump_generic_node): Clean up TARGET_EXPR dump.\n\t* objc/objc-act.c (build_module_descriptor): Use c_begin_compound_stmt.\n\t(objc_enter_block): Likewise.\n\t(objc_exit_block): Use c_end_compound_stmt.\n\t(objc_build_try_enter_fragment): Add #error and comment for\n\trewriting for OBJCPLUS.\n\t(objc_build_extract_fragment, objc_build_try_epilogue,\n\tobjc_build_catch_stmt, objc_build_finally_prologue,\n\tobjc_build_finally_epilogue): Update for C statement builders.\n\t* objc/objc-lang.c (LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P):\n\tRemove.\ncp/\n\t* call.c (initialize_reference): Don't build CLEANUP_STMT here.\n\t* cp-gimplify.c (cp_gimplify_stmt): Remove next_p argument.\n\t(genericize_try_block): Use gimplify_stmt.\n\t(genericize_catch_block, genericize_eh_spec_block): Likewise.\n\t(cp_gimplify_init_expr): Remove STMT_EXPR special case.\n\t(gimplify_must_not_throw_expr): Update voidify_wrapper_expr call.\n\t* cp-lang.c (LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P): Remove.\n\t(cp_tree_chain_matters_p): Remove.\n\t* cp-tree.h (COMPOUND_STMT_TRY_BLOCK): New.\n\t(COMPOUND_STMT_BODY_BLOCK): New.\n\t(STATEMENT_LIST_NO_SCOPE, STATEMENT_LIST_TRY_BLOCK): New.\n\t(EXPR_STMT_STMT_EXPR_RESULT): New.\n\t(building_stmt_tree): Check cur_stmt_list.\n\t(tf_stmt_expr_cmpd, tf_stmt_expr_body): Remove.\n\t(BCS_NO_SCOPE, BCS_TRY_BLOCK, BCS_FN_BODY): New.\n\t* decl.c (poplevel): Use pop_stmt_list for minding cleanups.\n\t(cp_finish_decl): Use push_cleanup.\n\t(start_function, finish_function): Use statement lists.\n\t(finish_stmt): Do nothing.\n\t* except.c (begin_eh_spec_block): Use statement lists.\n\t(check_handlers_1, check_handlers): Likewise.\n\t* init.c (construct_virtual_base): Don't add extra compound stmts.\n\t(build_vec_init): Likewise.\n\t* name-lookup.c (maybe_push_cleanup_level): Use statement lists.\n\t* name-lookup.h (struct cp_binding_level): Add statement_list.\n\t* parser.c (cp_parser_statement): Take the STMT_EXPR node, not a bool.\n\t(cp_parser_labeled_statement, cp_parser_expression_statement,\n\tcp_parser_statement_seq_opt): Likewise.\n\t(cp_parser_compound_statement): Likewise.  Take bool for try block.\n\t(cp_parser_selection_statement): Tidy if processing.\n\t(cp_parser_already_scoped_statement): Rewrite to do what it says.\n\t* pt.c (tsubst_copy): Move STMT_EXPR to tsubst_expr.\n\t(tsubst_expr): Rewrite STMT_EXPR processing.  Handle STATEMENT_LIST.\n\tMind COMPOUND_STMT_TRY_BLOCK, EXPR_STMT_STMT_EXPR_RESULT.\n\t* semantics.c (do_poplevel, do_pushlevel): Use statement lists.\n\t(finish_cond): New, rewritten from FINISH_COND.\n\t(simplify_loop_decl_cond): New.\n\t(finish_expr_stmt): Avoid nested EXPR_STMTs.\n\t(begin_if_stmt, finish_if_stmt_cond, finish_then_clause,\n\tbegin_else_clause, finish_else_clause, finish_if_stmt,\n\tbegin_while_stmt, finish_while_stmt_cond, finish_while_stmt,\n\tbegin_do_stmt, finish_do_body, begin_for_stmt, finish_for_init_stmt,\n\tfinish_for_cond, finish_for_stmt, begin_switch_stmt,\n\tfinish_switch_cond, finish_switch_stmt, begin_try_block,\n\tfinish_try_block, finish_cleanup_try_block, finish_function_try_block,\n\tfinish_handler_sequence, finish_function_handler_sequence,\n\tbegin_handler, finish_handler_parms, finish_handler,\n\tbegin_stmt_expr, finish_stmt_expr_expr, finish_stmt_expr): Rewrite\n\tusing statement lists.\n\t(begin_compound_stmt): Replace has_no_scope argument with flags.\n\tUpdate all callers.  Use statement lists.\n\t(finish_compound_stmt): Likewise.\n\t(finish_decl_cleanup, finish_eh_cleanup): Use push_cleanup.\n\t(current_scope_stmt_stack): Remove.\n\t(simplify_aggr_init_expr): Don't muck with TREE_CHAIN.\n\t* typeck2.c (split_nonconstant_init_1, split_nonconstant_init):\n\tRewrite with statement lists.\ntestsuite/\n\t* g++.dg/ext/stmtexpr1.C: XFAIL.\n\t* gcc.dg/20030612-1.c: XFAIL.\n\nFrom-SVN: r83221", "tree": {"sha": "fd045b9b0d56d6e00876348ae58483539fd0ec02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd045b9b0d56d6e00876348ae58483539fd0ec02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/325c36911589375105e5437c513bf880aeffdc75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/325c36911589375105e5437c513bf880aeffdc75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/325c36911589375105e5437c513bf880aeffdc75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/325c36911589375105e5437c513bf880aeffdc75/comments", "author": null, "committer": null, "parents": [{"sha": "aaab7bb6d7660df0773a444bd6a4a20f586f1a98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaab7bb6d7660df0773a444bd6a4a20f586f1a98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaab7bb6d7660df0773a444bd6a4a20f586f1a98"}], "stats": {"total": 3163, "additions": 1513, "deletions": 1650}, "files": [{"sha": "cdea3c05152d0d2c925f3225061c5080080c2c45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -1,3 +1,111 @@\n+2004-06-15  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-common.c (lang_gimplify_stmt): Remove next_p argument.\n+\t(if_elt, if_stack, if_stack_space, c_expand_start_cond, c_finish_then,\n+\tc_expand_end_cond, c_expand_start_else, c_finish_else, c_begin_if_stmt,\n+\tc_begin_while_stmt, c_finish_while_stmt_cond): Move to c-typeck.c.\n+\t(finish_fname_decls, fname_decl): Use statement_lists.\n+\t(c_expand_expr_stmt): Don't set last_expr_type.\n+\t(c_type_hash): Fix indentation.\n+\t(c_safe_from_p): Don't follow TREE_CHAIN.\n+\t(c_tree_chain_matters_p): Remove.\n+\t* c-common.def (SCOPE_STMT): Remove.\n+\t(CLEANUP_STMT): Redefine to contain its own body.\n+\t* c-common.h (struct stmt_tree_s): Remove x_last_stmt,\n+\tx_last_expr_type, x_last_expr_filename, x_scope_stmt_stack.\n+\tAdd x_cur_stmt_list.\n+\t(last_tree, last_expr_type, last_expr_filename, RECHAIN_STMTS): Remove.\n+\t(cur_stmt_list): New.\n+\t(STATEMENT_LIST_STMT_EXPR): New.\n+\t(SCOPE_BEGIN_P, SCOPE_END_P, SCOPE_STMT_BLOCK, SCOPE_NULLIFIED_P,\n+\tSCOPE_NO_CLEANUPS_P, SCOPE_PARTIAL_P, NEW_FOR_SCOPE_P): Remove.\n+\t(CLEANUP_BODY): New.\n+\t(CLEANUP_DECL): Move to operand 2.\n+\t(c_common_stmt_codes): Remove SCOPE_STMT.\n+\t(COMPOUND_STMT_NO_SCOPE, COMPOUND_STMT_BODY_BLOCK): Remove.\n+\t* c-decl.c (c_scope_stmt_stack, current_scope_stmt_stack): Remove.\n+\t(c_push_function_context, c_pop_function_context): Don't save it.\n+\t(finish_decl): Set TREE_USED on the decl for a cleanup.\n+\tUse push_cleanup.\n+\t(store_parm_decls): Use statement lists.\n+\t(finish_function): Remove compstmt rule workaround.  Use statement\n+\tlists.  Call finish_fname_decls after finalizing the body.\n+\t(c_begin_compound_stmt): Move to c-typeck.c.\n+\t* c-dump.c (c_dump_tree): Remove SCOPE_STMT.\n+\t* c-gimplify.c (gimplify_cleanup_stmt, gimplify_cleanup_stmts): New.\n+\t(c_genericize): Invoke them.\n+\t(c_gimplify_stmt): Don't look through TREE_CHAIN.  Kill SCOPE_STMT.\n+\t(c_build_bind_expr): Export.\n+\t(gimplify_block, gimplify_cleanup): Remove.\n+\t(gimplify_condition): Use gimplify_stmt.\n+\t(gimplify_for_stmt): Remove FOR_INIT_STMT chaining hack.\n+\t(gimplify_if_stmt): Remove recursion hack.\n+\t(c_gimplify_expr): Remove STMT_EXPR handling.\n+\t(stmt_expr_last_stmt, gimplify_stmt_expr): Remove.\n+\t(is_last_stmt_of_scope): Remove.\n+\t* c-lang.c (LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P): Remove.\n+\t* c-mudflap.c (mflang_flush_calls): Use c_begin_compound_stmt,\n+\tc_end_compound_stmt.\n+\t* c-objc-common.c (build_cdtor): Likewise.\n+\t* c-parse.in (primary): Use c_finish_stmt_expr.\n+\t(push_scope, pop_scope): Remove.\n+\t(c99_block_start, compstmt_start): Use c_begin_compound_stmt.\n+\t(c99_block_end, compstmt): Use c_end_compound_stmt.\n+\t(c99_block_lineno_labeled_stmt): Likewise.\n+\t(compstmt_primary_start): Use c_begin_stmt_expr.\n+\t(simple_if, select_or_iter_stmt): Update calls to stmt builders.\n+\t(do_stmt_start): Fill in body directly.\n+\t(lineno_stmt): Avoid setting lineno on constants.\n+\t* c-pretty-print.c (pp_c_statement): Handle STATEMENT_LIST.\n+\tRemove SCOPE_STMT.\n+\t* c-semantics.c (begin_stmt_tree): Remove.\n+\t(push_stmt_list, re_push_stmt_list, pop_stmt_list): New.\n+\t(add_stmt): Use statement lists.\n+\t(add_scope_stmt, finish_stmt_tree): Remove.\n+\t(push_cleanup): New.\n+\t* c-tree.h: Move some decls from c-common.h.\n+\t* c-typeck.c (c_tree_expr_nonnegative_p): Simplify for statement lists.\n+\t(do_case, c_finish_case): Likewise.\n+\t(c_finish_then): Take body for then as argument.\n+\t(c_finish_else): Similarly.\n+\t(c_begin_for_stmt, c_finish_for_stmt_init, c_finish_for_stmt_cond,\n+\tc_finish_for_stmt_incr, c_finish_for_stmt): New.\n+\t(c_begin_stmt_expr, c_finish_stmt_expr): New.\n+\t(c_begin_compound_stmt): Do scope management.\n+\t(c_end_compound_stmt): New.\n+\t* fold-const.c (tree_expr_nonnegative_p): Fix BIND_EXPR.\n+\t* gimplify.c (voidify_wrapper_expr): Accept temporary argument.\n+\tLook through exception handling constructs.\n+\t(gimplify_bind_expr): Accept temporary argument.\n+\t(gimplify_target_expr): Special case BIND_EXPR bodies.\n+\t(gimplify_expr): Handle fallback == fb_none like a statement.\n+\t* langhooks-def.h (LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P): Kill.\n+\t* langhooks.c (lhd_tree_inlining_tree_chain_matters_p): Remove.\n+\t* langhooks.h (tree_chain_matters_p): Remove.\n+\t* stub-objc.c (objc_clear_super_receiver): New.\n+\t* tree-gimple.h (voidify_wrapper_expr): Update decl.\n+\t(append_to_statement_list, append_to_statement_list_force): Move\n+\tto tree-iterator.h.\n+\t* tree-inline.c (expand_call_inline): Update call.\n+\t(clone_body): Use statement lists.\n+\t(walk_tree): Don't check tree_chain_matters_p.\n+\t(copy_tree_r): Likewise.\n+\t* tree-iterator.c (alloc_stmt_list): Clear lang bits.\n+\t(tsi_link_before, tsi_link_after): Set TREE_SIDE_EFFECTS properly.\n+\t* tree-iterator.h (append_to_statement_list,\n+\tappend_to_statement_list_force): Moved from tree-gimple.h.\n+\t* tree-pretty-print.c (dump_generic_node): Clean up TARGET_EXPR dump.\n+\t* objc/objc-act.c (build_module_descriptor): Use c_begin_compound_stmt.\n+\t(objc_enter_block): Likewise.\n+\t(objc_exit_block): Use c_end_compound_stmt.\n+\t(objc_build_try_enter_fragment): Add #error and comment for\n+\trewriting for OBJCPLUS.\n+\t(objc_build_extract_fragment, objc_build_try_epilogue,\n+\tobjc_build_catch_stmt, objc_build_finally_prologue,\n+\tobjc_build_finally_epilogue): Update for C statement builders.\n+\t* objc/objc-lang.c (LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P):\n+\tRemove.\n+\n 2004-06-15  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* df.c (df_reg_clobber_gen): Removed."}, {"sha": "2b68c0aa5f80955921de5725c7c597cff927f044", "filename": "gcc/c-common.c", "status": "modified", "additions": 50, "deletions": 226, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -690,7 +690,7 @@ int (*lang_statement_code_p) (enum tree_code);\n /* If non-NULL, the address of a language-specific function that does any\n    language-specific gimplification for _STMT nodes and returns 1 iff\n    handled.  */\n-int (*lang_gimplify_stmt) (tree *, tree *);\n+int (*lang_gimplify_stmt) (tree *);\n \n /* If non-NULL, the address of a language-specific function that takes\n    any action required right before expand_function_end is called.  */\n@@ -723,27 +723,6 @@ const struct fname_var_t fname_vars[] =\n \n static int constant_fits_type_p (tree, tree);\n \n-/* Keep a stack of if statements.  We record the number of compound\n-   statements seen up to the if keyword, as well as the line number\n-   and file of the if.  If a potentially ambiguous else is seen, that\n-   fact is recorded; the warning is issued when we can be sure that\n-   the enclosing if statement does not have an else branch.  */\n-typedef struct\n-{\n-  int compstmt_count;\n-  location_t locus;\n-  int needs_warning;\n-  tree if_stmt;\n-} if_elt;\n-\n-static if_elt *if_stack;\n-\n-/* Amount of space in the if statement stack.  */\n-static int if_stack_space = 0;\n-\n-/* Stack pointer.  */\n-static int if_stack_pointer = 0;\n-\n static tree handle_packed_attribute (tree *, tree, tree, int, bool *);\n static tree handle_nocommon_attribute (tree *, tree, tree, int, bool *);\n static tree handle_common_attribute (tree *, tree, tree, int, bool *);\n@@ -876,131 +855,6 @@ const struct attribute_spec c_common_format_attribute_table[] =\n   { NULL,                     0, 0, false, false, false, NULL }\n };\n \n-/* Record the start of an if-then, and record the start of it\n-   for ambiguous else detection.\n-\n-   COND is the condition for the if-then statement.\n-\n-   IF_STMT is the statement node that has already been created for\n-   this if-then statement.  It is created before parsing the\n-   condition to keep line number information accurate.  */\n-\n-void\n-c_expand_start_cond (tree cond, int compstmt_count, tree if_stmt)\n-{\n-  /* Make sure there is enough space on the stack.  */\n-  if (if_stack_space == 0)\n-    {\n-      if_stack_space = 10;\n-      if_stack = xmalloc (10 * sizeof (if_elt));\n-    }\n-  else if (if_stack_space == if_stack_pointer)\n-    {\n-      if_stack_space += 10;\n-      if_stack = xrealloc (if_stack, if_stack_space * sizeof (if_elt));\n-    }\n-\n-  IF_COND (if_stmt) = cond;\n-  add_stmt (if_stmt);\n-\n-  /* Record this if statement.  */\n-  if_stack[if_stack_pointer].compstmt_count = compstmt_count;\n-  if_stack[if_stack_pointer].locus = input_location;\n-  if_stack[if_stack_pointer].needs_warning = 0;\n-  if_stack[if_stack_pointer].if_stmt = if_stmt;\n-  if_stack_pointer++;\n-}\n-\n-/* Called after the then-clause for an if-statement is processed.  */\n-\n-void\n-c_finish_then (void)\n-{\n-  tree if_stmt = if_stack[if_stack_pointer - 1].if_stmt;\n-  RECHAIN_STMTS (if_stmt, THEN_CLAUSE (if_stmt));\n-}\n-\n-/* Record the end of an if-then.  Optionally warn if a nested\n-   if statement had an ambiguous else clause.  */\n-\n-void\n-c_expand_end_cond (void)\n-{\n-  if_stack_pointer--;\n-  if (if_stack[if_stack_pointer].needs_warning)\n-    warning (\"%Hsuggest explicit braces to avoid ambiguous `else'\",\n-\t     &if_stack[if_stack_pointer].locus);\n-  last_expr_type = NULL_TREE;\n-}\n-\n-/* Called between the then-clause and the else-clause\n-   of an if-then-else.  */\n-\n-void\n-c_expand_start_else (void)\n-{\n-  /* An ambiguous else warning must be generated for the enclosing if\n-     statement, unless we see an else branch for that one, too.  */\n-  if (warn_parentheses\n-      && if_stack_pointer > 1\n-      && (if_stack[if_stack_pointer - 1].compstmt_count\n-\t  == if_stack[if_stack_pointer - 2].compstmt_count))\n-    if_stack[if_stack_pointer - 2].needs_warning = 1;\n-\n-  /* Even if a nested if statement had an else branch, it can't be\n-     ambiguous if this one also has an else.  So don't warn in that\n-     case.  Also don't warn for any if statements nested in this else.  */\n-  if_stack[if_stack_pointer - 1].needs_warning = 0;\n-  if_stack[if_stack_pointer - 1].compstmt_count--;\n-}\n-\n-/* Called after the else-clause for an if-statement is processed.  */\n-\n-void\n-c_finish_else (void)\n-{\n-  tree if_stmt = if_stack[if_stack_pointer - 1].if_stmt;\n-  RECHAIN_STMTS (if_stmt, ELSE_CLAUSE (if_stmt));\n-}\n-\n-/* Begin an if-statement.  Returns a newly created IF_STMT if\n-   appropriate.\n-\n-   Unlike the C++ front-end, we do not call add_stmt here; it is\n-   probably safe to do so, but I am not very familiar with this\n-   code so I am being extra careful not to change its behavior\n-   beyond what is strictly necessary for correctness.  */\n-\n-tree\n-c_begin_if_stmt (void)\n-{\n-  tree r;\n-  r = build_stmt (IF_STMT, NULL_TREE, NULL_TREE, NULL_TREE);\n-  return r;\n-}\n-\n-/* Begin a while statement.  Returns a newly created WHILE_STMT if\n-   appropriate.\n-\n-   Unlike the C++ front-end, we do not call add_stmt here; it is\n-   probably safe to do so, but I am not very familiar with this\n-   code so I am being extra careful not to change its behavior\n-   beyond what is strictly necessary for correctness.  */\n-\n-tree\n-c_begin_while_stmt (void)\n-{\n-  tree r;\n-  r = build_stmt (WHILE_STMT, NULL_TREE, NULL_TREE);\n-  return r;\n-}\n-\n-void\n-c_finish_while_stmt_cond (tree cond, tree while_stmt)\n-{\n-  WHILE_COND (while_stmt) = cond;\n-}\n-\n /* Push current bindings for the function name VAR_DECLS.  */\n \n void\n@@ -1026,43 +880,32 @@ start_fname_decls (void)\n \t\t\t\t\t   saved_function_name_decls);\n }\n \n-/* Finish up the current bindings, adding them into the\n-   current function's statement tree. This is done by wrapping the\n-   function's body in a COMPOUND_STMT containing these decls too. This\n-   must be done _before_ finish_stmt_tree is called. If there is no\n-   current function, we must be at file scope and no statements are\n-   involved. Pop the previous bindings.  */\n+/* Finish up the current bindings, adding them into the current function's\n+   statement tree.  This must be done _before_ finish_stmt_tree is called.\n+   If there is no current function, we must be at file scope and no statements\n+   are involved. Pop the previous bindings.  */\n \n void\n finish_fname_decls (void)\n {\n   unsigned ix;\n-  tree body = NULL_TREE;\n+  tree stmts = NULL_TREE;\n   tree stack = saved_function_name_decls;\n \n   for (; stack && TREE_VALUE (stack); stack = TREE_CHAIN (stack))\n-    body = chainon (TREE_VALUE (stack), body);\n+    append_to_statement_list (TREE_VALUE (stack), &stmts);\n \n-  if (body)\n+  if (stmts)\n     {\n-      /* They were called into existence, so add to statement tree.  Add\n-\t the DECL_STMTs inside the outermost scope.  */\n-      tree *p = &DECL_SAVED_TREE (current_function_decl);\n-      /* Skip the dummy EXPR_STMT and any EH_SPEC_BLOCK.  */\n-      while (TREE_CODE (*p) != COMPOUND_STMT)\n-       {\n-         if (TREE_CODE (*p) == EXPR_STMT)\n-           p = &TREE_CHAIN (*p);\n-         else\n-           p = &TREE_OPERAND(*p, 0);\n-       }\n+      tree *bodyp = &DECL_SAVED_TREE (current_function_decl);\n \n-      p = &COMPOUND_BODY (*p);\n-      if (TREE_CODE (*p) == SCOPE_STMT)\n-\tp = &TREE_CHAIN (*p);\n+      if (TREE_CODE (*bodyp) == COMPOUND_STMT)\n+\tbodyp = &COMPOUND_BODY (*bodyp);\n+      if (TREE_CODE (*bodyp) == BIND_EXPR)\n+\tbodyp = &BIND_EXPR_BODY (*bodyp);\n \n-      body = chainon (body, *p);\n-      *p = body;\n+      append_to_statement_list (*bodyp, &stmts);\n+      *bodyp = stmts;\n     }\n \n   for (ix = 0; fname_vars[ix].decl; ix++)\n@@ -1167,30 +1010,23 @@ fname_decl (unsigned int rid, tree id)\n   decl = *fname_vars[ix].decl;\n   if (!decl)\n     {\n-      tree saved_last_tree = last_tree;\n       /* If a tree is built here, it would normally have the lineno of\n \t the current statement.  Later this tree will be moved to the\n \t beginning of the function and this line number will be wrong.\n \t To avoid this problem set the lineno to 0 here; that prevents\n \t it from appearing in the RTL.  */\n-      int saved_lineno = input_line;\n+      tree stmts;\n+      location_t saved_locus = input_location;\n       input_line = 0;\n \n+      stmts = push_stmt_list ();\n       decl = (*make_fname_decl) (id, fname_vars[ix].pretty);\n-      if (last_tree != saved_last_tree)\n-\t{\n-\t  /* We created some statement tree for the decl. This belongs\n-\t     at the start of the function, so remove it now and reinsert\n-\t     it after the function is complete.  */\n-\t  tree stmts = TREE_CHAIN (saved_last_tree);\n-\n-\t  TREE_CHAIN (saved_last_tree) = NULL_TREE;\n-\t  last_tree = saved_last_tree;\n-\t  saved_function_name_decls = tree_cons (decl, stmts,\n-\t\t\t\t\t\t saved_function_name_decls);\n-\t}\n+      stmts = pop_stmt_list (stmts);\n+      if (!IS_EMPTY_STMT (stmts))\n+\tsaved_function_name_decls\n+\t  = tree_cons (decl, stmts, saved_function_name_decls);\n       *fname_vars[ix].decl = decl;\n-      input_line = saved_lineno;\n+      input_location = saved_locus;\n     }\n   if (!ix && !current_function_decl)\n     pedwarn (\"%J'%D' is not defined outside of function scope\", decl, decl);\n@@ -1790,7 +1626,11 @@ c_expand_expr_stmt (tree expr)\n       && TREE_CODE (TREE_TYPE (expr)) != ARRAY_TYPE)\n     error (\"expression statement has incomplete type\");\n \n-  last_expr_type = TREE_TYPE (expr);\n+  /* As tempting as it might be, we can't diagnose statement with no\n+     effect yet.  We have to wait until after statement expressions\n+     have been parsed, and that process modifies the trees we are\n+     creating here.  */\n+\n   return add_stmt (build_stmt (EXPR_STMT, expr));\n }\n \f\n@@ -2855,28 +2695,28 @@ c_type_hash (const void *p)\n   tree t2;\n   switch (TREE_CODE (t))\n     {\n-      /* For pointers, hash on pointee type plus some swizzling.  */\n-      case POINTER_TYPE:\n-  return c_type_hash (TREE_TYPE (t)) ^ 0x3003003;\n-      /* Hash on number of elements and total size.  */\n-      case ENUMERAL_TYPE:\n-  shift = 3;\n-  t2 = TYPE_VALUES (t);\n-  break;\n-      case RECORD_TYPE:\n-  shift = 0;\n-  t2 = TYPE_FIELDS (t);\n-  break;\n-      case QUAL_UNION_TYPE:\n-  shift = 1;\n-  t2 = TYPE_FIELDS (t);\n-  break;\n-      case UNION_TYPE:\n-  shift = 2;\n-  t2 = TYPE_FIELDS (t);\n-  break;\n-      default:\n-  abort ();\n+    /* For pointers, hash on pointee type plus some swizzling. */\n+    case POINTER_TYPE:\n+      return c_type_hash (TREE_TYPE (t)) ^ 0x3003003;\n+    /* Hash on number of elements and total size.  */\n+    case ENUMERAL_TYPE:\n+      shift = 3;\n+      t2 = TYPE_VALUES (t);\n+      break;\n+    case RECORD_TYPE:\n+      shift = 0;\n+      t2 = TYPE_FIELDS (t);\n+      break;\n+    case QUAL_UNION_TYPE:\n+      shift = 1;\n+      t2 = TYPE_FIELDS (t);\n+      break;\n+    case UNION_TYPE:\n+      shift = 2;\n+      t2 = TYPE_FIELDS (t);\n+      break;\n+    default:\n+      abort ();\n     }\n   for (; t2; t2 = TREE_CHAIN (t2))\n     i++;\n@@ -4287,10 +4127,6 @@ c_safe_from_p (rtx target, tree exp)\n \treturn 0;\n     }\n \n-  /* For any statement, we must follow the statement-chain.  */\n-  if (STATEMENT_CODE_P (TREE_CODE (exp)) && TREE_CHAIN (exp))\n-    return safe_from_p (target, TREE_CHAIN (exp), /*top_p=*/0);\n-\n   /* Assume everything else is safe.  */\n   return 1;\n }\n@@ -5727,18 +5563,6 @@ c_walk_subtrees (tree *tp, int *walk_subtrees_p ATTRIBUTE_UNUSED,\n #undef WALK_SUBTREE\n }\n \n-/* C implementation of lang_hooks.tree_inlining.tree_chain_matters_p.\n-   Apart from TREE_LISTs, the only trees whose TREE_CHAIN we care about are\n-   _STMT nodes.  */\n-\n-int\n-c_tree_chain_matters_p (tree t)\n-{\n-  /* For statements, we also walk the chain so that we cover the\n-     entire statement tree.  */\n-  return STATEMENT_CODE_P (TREE_CODE (t));\n-}\n-\n /* Function to help qsort sort FIELD_DECLs by name order.  */\n \n int"}, {"sha": "67730fb538c319044b92c0410fef13fa96004585", "filename": "gcc/c-common.def", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.def?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -81,14 +81,6 @@ DEFTREECODE (LABEL_STMT, \"label_stmt\", 'e', 1)\n /* Used to represent an inline assembly statement.  */\n DEFTREECODE (ASM_STMT, \"asm_stmt\", 'e', 4)\n \n-/* A SCOPE_STMT marks the beginning or end of a scope.  If\n-   SCOPE_BEGIN_P holds, then this is the start of a scope.  If\n-   SCOPE_END_P holds, then this is the end of a scope.  If\n-   SCOPE_NULLIFIED_P holds then there turned out to be no variables in\n-   this scope.  The SCOPE_STMT_BLOCK is the BLOCK containing the\n-   variables declared in this scope.  */\n-DEFTREECODE (SCOPE_STMT, \"scope_stmt\", 'e', 1)\n-\n /* Used to represent a CASE_LABEL. The operands are CASE_LOW and\n    CASE_HIGH, respectively. If CASE_LOW is NULL_TREE, the label is a\n    'default' label. If CASE_HIGH is NULL_TREE, the label is a normal case\n@@ -107,9 +99,9 @@ DEFTREECODE (STMT_EXPR, \"stmt_expr\", 'e', 1)\n DEFTREECODE (COMPOUND_LITERAL_EXPR, \"compound_literal_expr\", 'e', 1)\n \n /* A CLEANUP_STMT marks the point at which a declaration is fully\n-   constructed.  If, after this point, the CLEANUP_DECL goes out of\n-   scope, the CLEANUP_EXPR must be run.  */\n-DEFTREECODE (CLEANUP_STMT, \"cleanup_stmt\", 'e', 2)\n+   constructed.  The CLEANUP_EXPR is run on behalf of CLEANUP_DECL\n+   when CLEANUP_BODY completes.  */\n+DEFTREECODE (CLEANUP_STMT, \"cleanup_stmt\", 'e', 3)\n \n /*\n Local variables:"}, {"sha": "59074b57b77db3d8282c79ae50b9cd9561debe3e", "filename": "gcc/c-common.h", "status": "modified", "additions": 29, "deletions": 101, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -27,20 +27,17 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n \n /* Usage of TREE_LANG_FLAG_?:\n-   0: COMPOUND_STMT_NO_SCOPE (in COMPOUND_STMT).\n-      TREE_NEGATED_INT (in INTEGER_CST).\n+   0: TREE_NEGATED_INT (in INTEGER_CST).\n       IDENTIFIER_MARKED (used by search routines).\n-      SCOPE_BEGIN_P (in SCOPE_STMT)\n       DECL_PRETTY_FUNCTION_P (in VAR_DECL)\n-      NEW_FOR_SCOPE_P (in FOR_STMT)\n       ASM_INPUT_P (in ASM_STMT)\n       STMT_EXPR_NO_SCOPE (in STMT_EXPR)\n    1: C_DECLARED_LABEL_FLAG (in LABEL_DECL)\n       STMT_IS_FULL_EXPR_P (in _STMT)\n+      STATEMENT_LIST_STMT_EXPR (in STATEMENT_LIST)\n    2: unused\n-   3: SCOPE_NO_CLEANUPS_P (in SCOPE_STMT)\n-      COMPOUND_STMT_BODY_BLOCK (in COMPOUND_STMT)\n-   4: SCOPE_PARTIAL_P (in SCOPE_STMT)\n+   3: unused\n+   4: unused\n */\n \n /* Reserved identifiers.  This is the union of all the keywords for C,\n@@ -245,13 +242,9 @@ extern c_language_kind c_language;\n /* Information about a statement tree.  */\n \n struct stmt_tree_s GTY(()) {\n-  /* The last statement added to the tree.  */\n-  tree x_last_stmt;\n-  /* The type of the last expression statement.  (This information is\n-     needed to implement the statement-expression extension.)  */\n-  tree x_last_expr_type;\n-  /* The last filename we recorded.  */\n-  const char *x_last_expr_filename;\n+  /* The current statment list being collected.  */\n+  tree x_cur_stmt_list;\n+\n   /* In C++, Nonzero if we should treat statements as full\n      expressions.  In particular, this variable is no-zero if at the\n      end of a statement we should destroy any temporaries created\n@@ -278,38 +271,17 @@ struct c_language_function GTY(()) {\n   /* While we are parsing the function, this contains information\n      about the statement-tree that we are building.  */\n   struct stmt_tree_s x_stmt_tree;\n-  /* The stack of SCOPE_STMTs for the current function.  */\n-  tree x_scope_stmt_stack;\n };\n \n-/* When building a statement-tree, this is the last statement added to\n-   the tree.  */\n-\n-#define last_tree (current_stmt_tree ()->x_last_stmt)\n-\n-/* The type of the last expression-statement we have seen.  */\n-\n-#define last_expr_type (current_stmt_tree ()->x_last_expr_type)\n+/* When building a statement-tree, this is the current statment list\n+   being collected.  It's TREE_CHAIN is a back-pointer to the previous\n+   statment list.  */\n \n-/* The name of the last file we have seen.  */\n-\n-#define last_expr_filename (current_stmt_tree ()->x_last_expr_filename)\n-\n-/* LAST_TREE contains the last statement parsed.  These are chained\n-   together through the TREE_CHAIN field, but often need to be\n-   re-organized since the parse is performed bottom-up.  This macro\n-   makes LAST_TREE the indicated SUBSTMT of STMT.  */\n-\n-#define RECHAIN_STMTS(stmt, substmt)\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    substmt = TREE_CHAIN (stmt);\t\t\\\n-    TREE_CHAIN (stmt) = NULL_TREE;\t\t\\\n-    last_tree = stmt;\t\t\t\t\\\n-  } while (0)\n+#define cur_stmt_list (current_stmt_tree ()->x_cur_stmt_list)\n \n /* Language-specific hooks.  */\n \n-extern int (*lang_gimplify_stmt) (tree *, tree *);\n+extern int (*lang_gimplify_stmt) (tree *);\n extern void (*lang_expand_function_end) (void);\n \n /* Callback that determines if it's ok for a function to have no\n@@ -320,12 +292,12 @@ extern void push_file_scope (void);\n extern void pop_file_scope (void);\n extern int yyparse (void);\n extern stmt_tree current_stmt_tree (void);\n-extern tree *current_scope_stmt_stack (void);\n-extern void begin_stmt_tree (tree *);\n+extern tree push_stmt_list (void);\n+extern tree re_push_stmt_list (tree);\n+extern tree pop_stmt_list (tree);\n extern tree add_stmt (tree);\n extern void add_decl_stmt (tree);\n-extern tree add_scope_stmt (int, int);\n-extern void finish_stmt_tree (tree *);\n+extern void push_cleanup (tree, tree, bool);\n \n extern tree walk_stmt_tree (tree *, walk_tree_fn, void *);\n extern void prep_stmt (tree);\n@@ -891,11 +863,6 @@ extern void binary_op_error (enum tree_code);\n  (((EXP) == 0) ? (fancy_abort (__FILE__, __LINE__, __FUNCTION__), 0) : 0)\n \n extern tree c_expand_expr_stmt (tree);\n-extern void c_expand_start_cond (tree, int, tree);\n-extern void c_finish_then (void);\n-extern void c_expand_start_else (void);\n-extern void c_finish_else (void);\n-extern void c_expand_end_cond (void);\n /* Validate the expression after `case' and apply default promotions.  */\n extern tree check_case_value (tree);\n extern tree fix_string_type (tree);\n@@ -952,6 +919,11 @@ extern void finish_file\t(void);\n    will always be false, since there are no destructors.)  */\n #define STMT_IS_FULL_EXPR_P(NODE) TREE_LANG_FLAG_1 ((NODE))\n \n+/* Nonzero if a given STATEMENT_LIST represents the outermost binding\n+   if a statement expression.  */\n+#define STATEMENT_LIST_STMT_EXPR(NODE) \\\n+  TREE_LANG_FLAG_1 (STATEMENT_LIST_CHECK (NODE))\n+\n /* IF_STMT accessors. These give access to the condition of the if\n    statement, the then block of the if statement, and the else block\n    of the if statement if it exists.  */\n@@ -1019,53 +991,15 @@ extern void finish_file\t(void);\n #define COMPOUND_LITERAL_EXPR_DECL(NODE)\t\t\t\\\n   DECL_STMT_DECL (COMPOUND_LITERAL_EXPR_DECL_STMT (NODE))\n \n-/* Nonzero if this SCOPE_STMT is for the beginning of a scope.  */\n-#define SCOPE_BEGIN_P(NODE) \\\n-  (TREE_LANG_FLAG_0 (SCOPE_STMT_CHECK (NODE)))\n-\n-/* Nonzero if this SCOPE_STMT is for the end of a scope.  */\n-#define SCOPE_END_P(NODE) \\\n-  (!SCOPE_BEGIN_P (SCOPE_STMT_CHECK (NODE)))\n-\n-/* The BLOCK containing the declarations contained in this scope.  */\n-#define SCOPE_STMT_BLOCK(NODE) \\\n-  (TREE_OPERAND (SCOPE_STMT_CHECK (NODE), 0))\n-\n-/* Nonzero for a SCOPE_STMT if there were no variables in this scope.  */\n-#define SCOPE_NULLIFIED_P(NODE) \\\n-  (SCOPE_STMT_BLOCK ((NODE)) == NULL_TREE)\n-\n-/* Nonzero for a SCOPE_STMT which represents a lexical scope, but\n-   which should be treated as non-existent from the point of view of\n-   running cleanup actions.  */\n-#define SCOPE_NO_CLEANUPS_P(NODE) \\\n-  (TREE_LANG_FLAG_3 (SCOPE_STMT_CHECK (NODE)))\n-\n-/* Nonzero for a SCOPE_STMT if this statement is for a partial scope.\n-   For example, in:\n-\n-     S s;\n-     l:\n-     S s2;\n-     goto l;\n-\n-   there is (implicitly) a new scope after `l', even though there are\n-   no curly braces.  In particular, when we hit the goto, we must\n-   destroy s2 and then re-construct it.  For the implicit scope,\n-   SCOPE_PARTIAL_P will be set.  */\n-#define SCOPE_PARTIAL_P(NODE) \\\n-  (TREE_LANG_FLAG_4 (SCOPE_STMT_CHECK (NODE)))\n-\n-/* The VAR_DECL to clean up in a CLEANUP_STMT.  */\n-#define CLEANUP_DECL(NODE) \\\n+/* The body of the CLEANUP_STMT.  */\n+#define CLEANUP_BODY(NODE) \\\n   TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 0)\n /* The cleanup to run in a CLEANUP_STMT.  */\n #define CLEANUP_EXPR(NODE) \\\n   TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 1)\n-\n-/* Nonzero if we want the new ISO rules for pushing a new scope for `for'\n-   initialization variables.  */\n-#define NEW_FOR_SCOPE_P(NODE) (TREE_LANG_FLAG_0 (NODE))\n+/* The VAR_DECL to clean up in a CLEANUP_STMT.  */\n+#define CLEANUP_DECL(NODE) \\\n+  TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 2)\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,\n \n@@ -1081,7 +1015,7 @@ enum c_tree_code {\n    CLEANUP_STMT,\tEXPR_STMT,\tCOMPOUND_STMT,\t\\\n    DECL_STMT,\t\tIF_STMT,\tFOR_STMT,\t\\\n    WHILE_STMT,\t\tDO_STMT,\tRETURN_STMT,\t\\\n-   BREAK_STMT,\t\tCONTINUE_STMT,\tSCOPE_STMT,\t\\\n+   BREAK_STMT,\t\tCONTINUE_STMT,\t\t\t\\\n    SWITCH_STMT,\t\tGOTO_STMT,\tLABEL_STMT,\t\\\n    ASM_STMT,\t\tCASE_LABEL\n \n@@ -1124,12 +1058,6 @@ extern tree build_continue_stmt (void);\n extern tree build_break_stmt (void);\n extern tree build_return_stmt (tree);\n \n-#define COMPOUND_STMT_NO_SCOPE(NODE)\tTREE_LANG_FLAG_0 (NODE)\n-\n-/* Used by the C++ frontend to mark the block around the member\n-   initializers and cleanups.  */\n-#define COMPOUND_STMT_BODY_BLOCK(NODE)\tTREE_LANG_FLAG_3 (NODE)\n-\n extern void c_expand_asm_operands (tree, tree, tree, tree, int, location_t);\n \n /* These functions must be defined by each front-end which implements\n@@ -1204,14 +1132,13 @@ extern bool c_dump_tree (void *, tree);\n \n extern int c_gimplify_expr (tree *, tree *, tree *);\n extern tree c_walk_subtrees (tree*, int*, walk_tree_fn, void*, void*);\n-extern int c_tree_chain_matters_p (tree);\n \n extern void c_warn_unused_result (tree *);\n \n /* In c-simplify.c  */\n extern void c_genericize (tree);\n extern int c_gimplify_stmt (tree *);\n-extern tree stmt_expr_last_stmt (tree);\n+extern tree c_build_bind_expr (tree, tree);\n \n extern void pch_init (void);\n extern int c_common_valid_pch (cpp_reader *pfile, const char *name, int fd);\n@@ -1236,6 +1163,7 @@ extern tree objc_message_selector (void);\n extern tree lookup_objc_ivar (tree);\n extern void *get_current_scope (void);\n extern void objc_mark_locals_volatile (void *);\n+extern void objc_clear_super_receiver (void);\n extern int objc_is_public (tree, tree);\n \n /* In c-ppoutput.c  */"}, {"sha": "f8d5f588e4d6e22c7648b84e302cdd0700d7f561", "filename": "gcc/c-decl.c", "status": "modified", "additions": 6, "deletions": 49, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -105,10 +105,6 @@ static location_t current_function_prototype_locus;\n \n static GTY(()) struct stmt_tree_s c_stmt_tree;\n \n-/* The current scope statement stack.  */\n-\n-static GTY(()) tree c_scope_stmt_stack;\n-\n /* State saving variables.  */\n int c_in_iteration_stmt;\n int c_in_case_stmt;\n@@ -2999,6 +2995,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \n \t  /* Don't warn about decl unused; the cleanup uses it.  */\n \t  TREE_USED (decl) = 1;\n+\t  TREE_USED (cleanup_decl) = 1;\n \n \t  /* Initialize EH, if we've been told to do so.  */\n \t  if (flag_exceptions && !eh_initialized_p)\n@@ -3011,7 +3008,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t      using_eh_for_cleanups ();\n \t    }\n \n-\t  add_stmt (build_stmt (CLEANUP_STMT, decl, cleanup));\n+\t  push_cleanup (decl, cleanup, false);\n \t}\n     }\n }\n@@ -6142,7 +6139,7 @@ store_parm_decls (void)\n   allocate_struct_function (fndecl);\n \n   /* Begin the statement tree for this function.  */\n-  begin_stmt_tree (&DECL_SAVED_TREE (fndecl));\n+  DECL_SAVED_TREE (fndecl) = push_stmt_list ();\n \n   /* If this is a nested function, save away the sizes of any\n      variable-size types so that we can expand them when generating\n@@ -6214,22 +6211,6 @@ finish_function (void)\n {\n   tree fndecl = current_function_decl;\n \n-  /* When a function declaration is totally empty, e.g.\n-        void foo(void) { }\n-     (the argument list is irrelevant) the compstmt rule will not\n-     bother calling push_scope/pop_scope, which means we get here with\n-     the scope stack out of sync.  Detect this situation by noticing\n-     that current_scope is still as store_parm_decls left it, and do\n-     a dummy push/pop to get back to consistency.\n-     Note that the call to push_scope does not actually push another\n-     scope - see there for details.  */\n-\n-  if (current_scope->parm_flag && next_is_function_body)\n-    {\n-      push_scope ();\n-      pop_scope ();\n-    }\n-\n   if (TREE_CODE (fndecl) == FUNCTION_DECL\n       && targetm.calls.promote_prototypes (TREE_TYPE (fndecl)))\n     {\n@@ -6273,10 +6254,10 @@ finish_function (void)\n \t}\n     }\n \n-  finish_fname_decls ();\n-\n   /* Tie off the statement tree for this function.  */\n-  finish_stmt_tree (&DECL_SAVED_TREE (fndecl));\n+  DECL_SAVED_TREE (fndecl) = pop_stmt_list (DECL_SAVED_TREE (fndecl));\n+\n+  finish_fname_decls ();\n \n   /* Complain if there's just no return statement.  */\n   if (warn_return_type\n@@ -6438,7 +6419,6 @@ c_push_function_context (struct function *f)\n   f->language = p;\n \n   p->base.x_stmt_tree = c_stmt_tree;\n-  p->base.x_scope_stmt_stack = c_scope_stmt_stack;\n   p->x_in_iteration_stmt = c_in_iteration_stmt;\n   p->x_in_case_stmt = c_in_case_stmt;\n   p->returns_value = current_function_returns_value;\n@@ -6466,7 +6446,6 @@ c_pop_function_context (struct function *f)\n     }\n \n   c_stmt_tree = p->base.x_stmt_tree;\n-  c_scope_stmt_stack = p->base.x_scope_stmt_stack;\n   c_in_iteration_stmt = p->x_in_iteration_stmt;\n   c_in_case_stmt = p->x_in_case_stmt;\n   current_function_returns_value = p->returns_value;\n@@ -6518,14 +6497,6 @@ current_stmt_tree (void)\n   return &c_stmt_tree;\n }\n \n-/* Returns the stack of SCOPE_STMTs for the current function.  */\n-\n-tree *\n-current_scope_stmt_stack (void)\n-{\n-  return &c_scope_stmt_stack;\n-}\n-\n /* Nonzero if TYPE is an anonymous union or struct type.  Always 0 in\n    C.  */\n \n@@ -6542,20 +6513,6 @@ extract_interface_info (void)\n {\n }\n \n-/* Return a new COMPOUND_STMT, after adding it to the current\n-   statement tree.  */\n-\n-tree\n-c_begin_compound_stmt (void)\n-{\n-  tree stmt;\n-\n-  /* Create the COMPOUND_STMT.  */\n-  stmt = add_stmt (build_stmt (COMPOUND_STMT, NULL_TREE));\n-\n-  return stmt;\n-}\n-\n /* Return the global value of T as a symbol.  */\n \n tree"}, {"sha": "3d2004eb04c7618a422cbc78b3d1ed0a396b9c64", "filename": "gcc/c-dump.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-dump.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -169,19 +169,6 @@ c_dump_tree (void *dump_info, tree t)\n       dump_next_stmt (di, t);\n       break;\n \n-    case SCOPE_STMT:\n-      dump_stmt (di, t);\n-      if (SCOPE_BEGIN_P (t))\n-\tdump_string (di, \"begn\");\n-      else\n-\tdump_string (di, \"end\");\n-      if (SCOPE_NULLIFIED_P (t))\n-\tdump_string (di, \"null\");\n-      if (!SCOPE_NO_CLEANUPS_P (t))\n-\tdump_string (di, \"clnp\");\n-      dump_next_stmt (di, t);\n-      break;\n-\n     case STMT_EXPR:\n       dump_child (\"stmt\", STMT_EXPR_STMT (t));\n       break;"}, {"sha": "484cc7c772f0a35f6187e23f6623644a12cf2620", "filename": "gcc/c-gimplify.c", "status": "modified", "additions": 144, "deletions": 372, "changes": 516, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gimplify.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -80,17 +80,11 @@ static enum gimplify_status gimplify_do_stmt (tree *);\n static enum gimplify_status gimplify_if_stmt (tree *);\n static enum gimplify_status gimplify_switch_stmt (tree *);\n static enum gimplify_status gimplify_return_stmt (tree *);\n-static enum gimplify_status gimplify_stmt_expr (tree *);\n static enum gimplify_status gimplify_compound_literal_expr (tree *);\n-#if defined ENABLE_CHECKING\n-static int is_last_stmt_of_scope (tree);\n-#endif\n-static enum gimplify_status gimplify_block (tree *, tree *);\n-static enum gimplify_status gimplify_cleanup (tree *, tree *);\n+static void gimplify_cleanup_stmts (tree);\n static tree gimplify_c_loop (tree, tree, tree, bool);\n static void push_context (void);\n static void pop_context (void);\n-static tree c_build_bind_expr (tree, tree);\n static void add_block_to_enclosing (tree);\n static void gimplify_condition (tree *);\n \n@@ -160,6 +154,7 @@ c_genericize (tree fndecl)\n \n   /* Go ahead and gimplify for now.  */\n   push_context ();\n+  gimplify_cleanup_stmts (fndecl);\n   gimplify_function_tree (fndecl);\n   pop_context ();\n \n@@ -174,14 +169,41 @@ c_genericize (tree fndecl)\n     c_genericize (cgn->decl);\n }\n \n+/* Genericize a CLEANUP_STMT.  This just turns into a TRY_FINALLY or\n+   TRY_CATCH depending on whether it's EH-only.  */\n+\n+static tree\n+gimplify_cleanup_stmt (tree *stmt_p, int *walk_subtrees,\n+\t\t       void *data ATTRIBUTE_UNUSED)\n+{\n+  tree stmt = *stmt_p;\n+\n+  if (DECL_P (stmt) || TYPE_P (stmt))\n+    *walk_subtrees = 0;\n+  else if (TREE_CODE (stmt) == CLEANUP_STMT)\n+    *stmt_p = build (CLEANUP_EH_ONLY (stmt) ? TRY_CATCH_EXPR : TRY_FINALLY_EXPR,\n+\t\t     void_type_node, CLEANUP_BODY (stmt), CLEANUP_EXPR (stmt));\n+\n+  return NULL;\n+}\n+\n+static void\n+gimplify_cleanup_stmts (tree fndecl)\n+{\n+  walk_tree (&DECL_SAVED_TREE (fndecl), gimplify_cleanup_stmt, NULL, NULL);\n+}\n+\n /*  Entry point for the tree lowering pass.  Recursively scan\n     *STMT_P and convert it to a GIMPLE tree.  */\n \n int\n c_gimplify_stmt (tree *stmt_p)\n {\n-  tree stmt, next;\n-  tree outer_pre = NULL_TREE;\n+  tree stmt = *stmt_p;\n+  tree pre, post;\n+  int saved_stmts_are_full_exprs_p;\n+  location_t stmt_locus;\n+  enum gimplify_status ret;\n \n   /* PRE and POST are tree chains that contain the side-effects of the\n      gimplified tree.  For instance, given the expression tree:\n@@ -195,152 +217,130 @@ c_gimplify_stmt (tree *stmt_p)\n \t\tc = t1 + b;\n \t\tb = b + 1;\t<-- POST  */\n \n-  for (stmt = *stmt_p; stmt && stmt != error_mark_node; stmt = next)\n-    {\n-      tree pre, post;\n-      int saved_stmts_are_full_exprs_p;\n-      location_t stmt_locus;\n-      enum gimplify_status ret;\n-\n-      /* Set up context appropriately for handling this statement.  */\n-      saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p ();\n-      prep_stmt (stmt);\n-      stmt_locus = input_location;\n+  /* Set up context appropriately for handling this statement.  */\n+  saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p ();\n+  prep_stmt (stmt);\n+  stmt_locus = input_location;\n \n-      pre = NULL_TREE;\n-      post = NULL_TREE;\n+  pre = NULL_TREE;\n+  post = NULL_TREE;\n \n-      next = TREE_CHAIN (stmt);\n+  switch (TREE_CODE (stmt))\n+    {\n+    case COMPOUND_STMT:\n+      stmt = COMPOUND_BODY (stmt);\n+      ret = GS_OK;\n+      break;\n \n-      switch (TREE_CODE (stmt))\n-\t{\n-\tcase COMPOUND_STMT:\n-\t  stmt = COMPOUND_BODY (stmt);\n-\t  ret = GS_OK;\n-\t  break;\n+    case FOR_STMT:\n+      ret = gimplify_for_stmt (&stmt, &pre);\n+      break;\n \n-\tcase SCOPE_STMT:\n-\t  ret = gimplify_block (&stmt, &next);\n-\t  break;\n+    case WHILE_STMT:\n+      ret = gimplify_while_stmt (&stmt);\n+      break;\n \n-\tcase FOR_STMT:\n-\t  ret = gimplify_for_stmt (&stmt, &next);\n-\t  break;\n+    case DO_STMT:\n+      ret = gimplify_do_stmt (&stmt);\n+      break;\n \n-\tcase WHILE_STMT:\n-\t  ret = gimplify_while_stmt (&stmt);\n-\t  break;\n+    case IF_STMT:\n+      ret = gimplify_if_stmt (&stmt);\n+      break;\n \n-\tcase DO_STMT:\n-\t  ret = gimplify_do_stmt (&stmt);\n-\t  break;\n+    case SWITCH_STMT:\n+      ret = gimplify_switch_stmt (&stmt);\n+      break;\n \n-\tcase IF_STMT:\n-\t  ret = gimplify_if_stmt (&stmt);\n-\t  break;\n+    case EXPR_STMT:\n+      ret = gimplify_expr_stmt (&stmt);\n+      break;\n \n-\tcase SWITCH_STMT:\n-\t  ret = gimplify_switch_stmt (&stmt);\n-\t  break;\n+    case RETURN_STMT:\n+      ret = gimplify_return_stmt (&stmt);\n+      break;\n \n-\tcase EXPR_STMT:\n-\t  ret = gimplify_expr_stmt (&stmt);\n-\t  break;\n+    case DECL_STMT:\n+      ret = gimplify_decl_stmt (&stmt);\n+      break;\n \n-\tcase RETURN_STMT:\n-\t  ret = gimplify_return_stmt (&stmt);\n-\t  break;\n+    case LABEL_STMT:\n+      stmt = build1 (LABEL_EXPR, void_type_node, LABEL_STMT_LABEL (stmt));\n+      ret = GS_OK;\n+      break;\n \n-\tcase DECL_STMT:\n-\t  ret = gimplify_decl_stmt (&stmt);\n-\t  break;\n+    case GOTO_STMT:\n+      stmt = build1 (GOTO_EXPR, void_type_node, GOTO_DESTINATION (stmt));\n+      ret = GS_OK;\n+      break;\n \n-\tcase LABEL_STMT:\n-\t  stmt = build1 (LABEL_EXPR, void_type_node, LABEL_STMT_LABEL (stmt));\n-\t  ret = GS_OK;\n-\t  break;\n+    case CASE_LABEL:\n+      {\n+\ttree label = create_artificial_label ();\n+\tstmt = build (CASE_LABEL_EXPR, void_type_node,\n+\t\t      CASE_LOW (stmt), CASE_HIGH (stmt), label);\n+\tret = GS_OK;\n+      }\n+      break;\n \n-\tcase GOTO_STMT:\n-\t  stmt = build1 (GOTO_EXPR, void_type_node, GOTO_DESTINATION (stmt));\n-\t  ret = GS_OK;\n-\t  break;\n+    case CONTINUE_STMT:\n+      stmt = build_bc_goto (bc_continue);\n+      ret = GS_OK;\n+      break;\n \n-\tcase CASE_LABEL:\n-\t  {\n-\t    tree label = create_artificial_label ();\n-\t    stmt = build (CASE_LABEL_EXPR, void_type_node,\n-\t\t\t  CASE_LOW (stmt), CASE_HIGH (stmt), label);\n-\t    ret = GS_OK;\n-\t  }\n-\t  break;\n+    case BREAK_STMT:\n+      stmt = build_bc_goto (bc_break);\n+      ret = GS_OK;\n+      break;\n \n-\tcase CONTINUE_STMT:\n-\t  stmt = build_bc_goto (bc_continue);\n-\t  ret = GS_OK;\n-\t  break;\n+    case ASM_STMT:\n+      {\n+\ttree new_stmt = build (ASM_EXPR, void_type_node, ASM_STRING (stmt),\n+\t\t\t       ASM_OUTPUTS (stmt), ASM_INPUTS (stmt),\n+\t\t\t       ASM_CLOBBERS (stmt));\n+\tASM_INPUT_P (new_stmt) = ASM_INPUT_P (stmt);\n+\tASM_VOLATILE_P (new_stmt) = ASM_VOLATILE_P (stmt);\n+\tstmt = new_stmt;\n+\tret = GS_OK;\n+      }\n+      break;\n \n-\tcase BREAK_STMT:\n-\t  stmt = build_bc_goto (bc_break);\n+    default:\n+      if (lang_gimplify_stmt && (*lang_gimplify_stmt) (&stmt))\n+\t{\n \t  ret = GS_OK;\n \t  break;\n-\n-\tcase CLEANUP_STMT:\n-\t  ret = gimplify_cleanup (&stmt, &next);\n-\t  break;\n-\n-\tcase ASM_STMT:\n-\t  {\n-\t    tree new_stmt = build (ASM_EXPR, void_type_node, ASM_STRING (stmt),\n-\t\t\t\t   ASM_OUTPUTS (stmt), ASM_INPUTS (stmt),\n-\t\t\t\t   ASM_CLOBBERS (stmt));\n-\t    ASM_INPUT_P (new_stmt) = ASM_INPUT_P (stmt);\n-\t    ASM_VOLATILE_P (new_stmt) = ASM_VOLATILE_P (stmt);\n-\t    stmt = new_stmt;\n-\t    ret = GS_OK;\n-\t  }\n-\t  break;\n-\n-\tdefault:\n-\t  if (lang_gimplify_stmt && (*lang_gimplify_stmt) (&stmt, &next))\n-\t    {\n-\t      ret = GS_OK;\n-\t      break;\n-\t    }\n-\n-\t  fprintf (stderr, \"unhandled statement node in c_gimplify_stmt:\\n\");\n-\t  debug_tree (stmt);\n-\t  abort ();\n-\t  break;\n \t}\n \n-      switch (ret)\n-\t{\n-\tcase GS_ERROR:\n-\t  goto cont;\n-\tcase GS_OK:\n-          gimplify_stmt (&stmt);\n-\t  break;\n-\tcase GS_ALL_DONE:\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n+      fprintf (stderr, \"unhandled statement node in c_gimplify_stmt:\\n\");\n+      debug_tree (stmt);\n+      abort ();\n+      break;\n+    }\n \n-      /* PRE and POST now contain a list of statements for all the\n-\t side-effects in STMT.  */\n+  switch (ret)\n+    {\n+    case GS_ERROR:\n+      goto cont;\n+    case GS_OK:\n+      gimplify_stmt (&stmt);\n+      break;\n+    case GS_ALL_DONE:\n+      break;\n+    default:\n+      abort ();\n+    }\n \n-      append_to_statement_list (stmt, &pre);\n-      append_to_statement_list (post, &pre);\n-      annotate_all_with_locus (&pre, stmt_locus);\n+  /* PRE and POST now contain a list of statements for all the\n+     side-effects in STMT.  */\n \n-      append_to_statement_list (pre, &outer_pre);\n-    cont:\n-      /* Restore saved state.  */\n-      current_stmt_tree ()->stmts_are_full_exprs_p\n-\t= saved_stmts_are_full_exprs_p;\n-    }\n-  append_to_statement_list (stmt, &outer_pre);\n-  *stmt_p = outer_pre;\n+  append_to_statement_list (stmt, &pre);\n+  append_to_statement_list (post, &pre);\n+  annotate_all_with_locus (&pre, stmt_locus);\n+ cont:\n+  /* Restore saved state.  */\n+  current_stmt_tree ()->stmts_are_full_exprs_p = saved_stmts_are_full_exprs_p;\n+  *stmt_p = pre;\n \n   return GS_ALL_DONE;\n }\n@@ -366,7 +366,7 @@ add_block_to_enclosing (tree block)\n    BODY is a chain of C _STMT nodes for the contents of the scope, to be\n      genericized.  */\n \n-static tree\n+tree\n c_build_bind_expr (tree block, tree body)\n {\n   tree decls, bind;\n@@ -390,99 +390,15 @@ c_build_bind_expr (tree block, tree body)\n \n   if (!body)\n     body = build_empty_stmt ();\n-\n-  bind = build (BIND_EXPR, void_type_node, decls, body, block);\n-  TREE_SIDE_EFFECTS (bind) = 1;\n-\n-  return bind;\n-}\n-\n-/* Genericize a syntactic block by removing the bracketing SCOPE_STMTs and\n-   wrapping the intervening code in a BIND_EXPR.  This function assumes\n-   that matching SCOPE_STMTs will always appear in the same statement\n-   sequence.  */\n-\n-static enum gimplify_status\n-gimplify_block (tree *stmt_p, tree *next_p)\n-{\n-  tree *p;\n-  tree block;\n-  tree bind;\n-  int depth;\n-  location_t stmt_locus;\n-\n-  if (!SCOPE_BEGIN_P (*stmt_p))\n+  if (decls || block)\n     {\n-      /* Can wind up mismatched with syntax errors.  */\n-      if (!errorcount && !sorrycount)\n-\tabort ();\n-      *stmt_p = NULL;\n-      return GS_ERROR;\n-    }\n-\n-  block = SCOPE_STMT_BLOCK (*stmt_p);\n-\n-  /* Find the matching ending SCOPE_STMT.  */\n-  depth = 1;\n-  for (p = &TREE_CHAIN (*stmt_p);; p = &TREE_CHAIN (*p))\n-    {\n-      if (*p == NULL)\n-\tbreak;\n-      if (TREE_CODE (*p) == SCOPE_STMT)\n-\t{\n-\t  if (SCOPE_BEGIN_P (*p))\n-\t    ++depth;\n-\t  else if (--depth == 0)\n-\t    break;\n-\t}\n-    }\n-\n-  stmt_locus = input_location;\n-  if (*p)\n-    {\n-      if (SCOPE_STMT_BLOCK (*p) != block)\n-\tabort ();\n-      if (EXPR_LOCUS (*p))\n-\tstmt_locus = *EXPR_LOCUS (*p);\n-      *next_p = TREE_CHAIN (*p);\n-      *p = NULL_TREE;\n+      bind = build (BIND_EXPR, void_type_node, decls, body, block);\n+      TREE_SIDE_EFFECTS (bind) = 1;\n     }\n   else\n-    {\n-      /* Can wind up mismatched with syntax errors.  */\n-      if (!errorcount && !sorrycount)\n-\tabort ();\n-    }\n-\n-  bind = c_build_bind_expr (block, TREE_CHAIN (*stmt_p));\n-  *stmt_p = bind;\n-  input_location = stmt_locus;\n+    bind = body;\n \n-  return GS_OK;\n-}\n-\n-/* Genericize a CLEANUP_STMT.  Just wrap everything from here to the end of\n-   the block in a TRY_FINALLY_EXPR.  Or a TRY_CATCH_EXPR, if it's an\n-   EH-only cleanup.  */\n-\n-static enum gimplify_status\n-gimplify_cleanup (tree *stmt_p, tree *next_p)\n-{\n-  tree stmt = *stmt_p;\n-  tree body = TREE_CHAIN (stmt);\n-  tree cleanup = CLEANUP_EXPR (stmt);\n-  enum tree_code code\n-    = (CLEANUP_EH_ONLY (stmt) ? TRY_CATCH_EXPR : TRY_FINALLY_EXPR);\n-\n-  if (!body)\n-    body = build_empty_stmt ();\n-  if (!cleanup)\n-    cleanup = build_empty_stmt ();\n-\n-  *stmt_p = build (code, void_type_node, body, cleanup);\n-  *next_p = NULL_TREE;\n-\n-  return GS_OK;\n+  return bind;\n }\n \n /*  Gimplify an EXPR_STMT node.\n@@ -549,7 +465,7 @@ gimplify_condition (tree *cond_p)\n     {\n       tree decl = TREE_PURPOSE (cond);\n       tree value = TREE_VALUE (cond);\n-      c_gimplify_stmt (&decl);\n+      gimplify_stmt (&decl);\n       *cond_p = build (COMPOUND_EXPR, TREE_TYPE (value), decl, value);\n     }\n }\n@@ -713,26 +629,17 @@ gimplify_c_loop (tree cond, tree body, tree incr, bool cond_is_first)\n    prequeue and hand off to gimplify_c_loop.  */\n \n static enum gimplify_status\n-gimplify_for_stmt (tree *stmt_p, tree *next_p)\n+gimplify_for_stmt (tree *stmt_p, tree *pre_p)\n {\n   tree stmt = *stmt_p;\n-  tree init = FOR_INIT_STMT (stmt);\n \n-  if (init)\n+  if (FOR_INIT_STMT (stmt))\n     {\n-      /* Reorganize the statements so that we do the right thing with a\n-\t CLEANUP_STMT.  We want the FOR_STMT and nothing else to be in the\n-\t scope of the cleanup, so play with pointers to accomplish that.  */\n-      FOR_INIT_STMT (stmt) = NULL_TREE;\n-      chainon (init, stmt);\n-      *stmt_p = init;\n-      *next_p = TREE_CHAIN (stmt);\n-      TREE_CHAIN (stmt) = NULL_TREE;\n-      c_gimplify_stmt (stmt_p);\n+      gimplify_stmt (&FOR_INIT_STMT (stmt));\n+      append_to_statement_list (FOR_INIT_STMT (stmt), pre_p);\n     }\n-  else\n-    *stmt_p = gimplify_c_loop (FOR_COND (stmt), FOR_BODY (stmt),\n-\t\t\t       FOR_EXPR (stmt), 1);\n+  *stmt_p = gimplify_c_loop (FOR_COND (stmt), FOR_BODY (stmt),\n+\t\t\t     FOR_EXPR (stmt), 1);\n \n   return GS_ALL_DONE;\n }\n@@ -767,7 +674,6 @@ gimplify_if_stmt (tree *stmt_p)\n   tree stmt, then_, else_;\n \n   stmt = *stmt_p;\n- restart:\n   then_ = THEN_CLAUSE (stmt);\n   else_ = ELSE_CLAUSE (stmt);\n \n@@ -780,17 +686,6 @@ gimplify_if_stmt (tree *stmt_p)\n   gimplify_condition (& TREE_OPERAND (stmt, 0));\n   *stmt_p = stmt;\n \n-  /* Handle properly nested if-else chains via iteration instead of\n-     mutual recursion between gimplify.c and c-simplify.c.  */\n-  annotate_with_locus (stmt, input_location);\n-  if (TREE_CODE (else_) == IF_STMT && !TREE_CHAIN (else_))\n-    {\n-      stmt_p = &COND_EXPR_ELSE (stmt);\n-      stmt = else_;\n-      prep_stmt (stmt);\n-      goto restart;\n-    }\n-\n   return GS_OK;\n }\n \n@@ -960,130 +855,7 @@ c_gimplify_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED,\n     case COMPOUND_LITERAL_EXPR:\n       return gimplify_compound_literal_expr (expr_p);\n \n-    case STMT_EXPR:\n-      return gimplify_stmt_expr (expr_p);\n-\n     default:\n       return GS_UNHANDLED;\n     }\n }\n-\n-/* Returns the final EXPR_STMT which represents the return value of a\n-   STMT_EXPR, or NULL_TREE if none.  */\n-\n-tree\n-stmt_expr_last_stmt (tree stmt_expr)\n-{\n-  tree body = STMT_EXPR_STMT (stmt_expr);\n-  tree last_stmt, substmt;\n-\n-  /* Splice the last expression out of the STMT chain.  */\n-  last_stmt = NULL_TREE;\n-  for (substmt = COMPOUND_BODY (body); substmt;\n-       substmt = TREE_CHAIN (substmt))\n-    if (TREE_CODE (substmt) != SCOPE_STMT)\n-      last_stmt = substmt;\n-\n-  if (last_stmt == NULL_TREE\n-      || TREE_CODE (last_stmt) != EXPR_STMT\n-      || (TREE_TYPE (last_stmt)\n-\t  && VOID_TYPE_P (TREE_TYPE (last_stmt))))\n-    {\n-      location_t loc;\n-      if (last_stmt && EXPR_LOCUS (last_stmt))\n-\tloc = *EXPR_LOCUS (last_stmt);\n-      else if (EXPR_LOCUS (stmt_expr))\n-\tloc = *EXPR_LOCUS (stmt_expr);\n-      else\n-\tloc = input_location;\n-      warning (\"%Hstatement-expressions should end with a \"\n-\t       \"non-void expression\", &loc);\n-      last_stmt = NULL_TREE;\n-    }\n-\n-#if defined ENABLE_CHECKING\n-  if (last_stmt && !is_last_stmt_of_scope (last_stmt))\n-    abort ();\n-#endif\n-\n-  return last_stmt;\n-}\n-\n-/* Gimplify a STMT_EXPR.  EXPR_P points to the expression to gimplify.\n-   After gimplification, if the STMT_EXPR returns a value, EXPR_P will\n-   point to a new temporary that holds that value; otherwise it will be\n-   null.\n-\n-   PRE_P points to the list where side effects that must happen before\n-     *EXPR_P should be stored.  */\n-\n-static enum gimplify_status\n-gimplify_stmt_expr (tree *expr_p)\n-{\n-  tree body = STMT_EXPR_STMT (*expr_p);\n-\n-  if (VOID_TYPE_P (TREE_TYPE (*expr_p)))\n-    {\n-      *expr_p = body;\n-      return c_gimplify_stmt (expr_p);\n-    }\n-  else\n-    {\n-      tree last_stmt = stmt_expr_last_stmt (*expr_p);\n-      tree last_expr = NULL_TREE;\n-\n-      if (last_stmt)\n-\t{\n-\t  last_expr = EXPR_STMT_EXPR (last_stmt);\n-\n-\t  if (stmts_are_full_exprs_p ())\n-\t    last_expr = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (last_expr),\n-\t\t\t\tlast_expr);\n-\t  EXPR_STMT_EXPR (last_stmt) = NULL_TREE;\n-\t}\n-\n-      /* Genericize the block.  */\n-      c_gimplify_stmt (&body);\n-\n-      /* Now retrofit that last expression into the BIND_EXPR.  */\n-      if (last_expr)\n-\t{\n-\t  tree *sub_p;\n-\n-\t  if (!STMT_EXPR_NO_SCOPE (*expr_p))\n-\t    {\n-\t      /* Our BIND_EXPR will always be hidden within\n-\t\t a STATEMENT_LIST.  Discard that.  */\n-\t      body = expr_first (body);\n-\t      sub_p = &BIND_EXPR_BODY (body);\n-\n-\t      /* Append the last expression to the end of the BIND_EXPR.\n-\t\t We'll now re-process this, and let voidify_wrapper_expr\n-\t\t do its job.  */\n-\t      append_to_statement_list_force (last_expr, sub_p);\n-\t      TREE_TYPE (body) = TREE_TYPE (last_expr);\n-\t    }\n-\t  else\n-\t    append_to_compound_expr (last_expr, &body);\n-\t}\n-\n-      *expr_p = body;\n-      return GS_OK;\n-    }\n-}\n-\n-/* Code generation.  */\n-\n-/* Miscellaneous helpers.  */\n-\n-#if defined ENABLE_CHECKING\n-/*  Return nonzero if STMT is the last statement of its scope.  */\n-\n-static int\n-is_last_stmt_of_scope (tree stmt)\n-{\n-  return (TREE_CHAIN (stmt) == NULL_TREE\n-\t  || (TREE_CODE (TREE_CHAIN (stmt)) == SCOPE_STMT\n-\t      && SCOPE_END_P (TREE_CHAIN (stmt))));\n-}\n-#endif"}, {"sha": "74b04ebc17a1d9cd3568bb6fe8006e3524cb97bf", "filename": "gcc/c-lang.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -112,9 +112,6 @@ enum c_language_kind c_language = clk_c;\n #undef LANG_HOOKS_TREE_INLINING_DISREGARD_INLINE_LIMITS\n #define LANG_HOOKS_TREE_INLINING_DISREGARD_INLINE_LIMITS \\\n   c_disregard_inline_limits\n-#undef LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P\n-#define LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P \\\n-  c_tree_chain_matters_p\n #undef LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P\n #define LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P \\\n   anon_aggr_type_p"}, {"sha": "78523e960a07df5ab9193a60d848a9b2cf23a836", "filename": "gcc/c-mudflap.c", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-mudflap.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -67,7 +67,7 @@ mflang_lookup_decl (const char* name)\n void\n mflang_flush_calls (tree enqueued_call_stmt_chain)\n {\n-  tree fnname, t1, t2, body, block, scope;\n+  tree fnname, t1, t2, cs;\n \n   /* Short-circuit!  */\n   if (enqueued_call_stmt_chain == NULL_TREE)\n@@ -84,17 +84,9 @@ mflang_flush_calls (tree enqueued_call_stmt_chain)\n   TREE_USED (current_function_decl) = 1;\n   mf_mark (current_function_decl);\n \n-  body = c_begin_compound_stmt ();\n-  push_scope ();\n-  clear_last_expr ();\n-  add_scope_stmt (/*begin_p=*/1, /*partial_p=*/0);\n-\n+  cs = c_begin_compound_stmt (true);\n   c_expand_expr_stmt (enqueued_call_stmt_chain);\n+  add_stmt (c_end_compound_stmt (cs, true));\n \n-  scope = add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0);\n-  block = pop_scope ();\n-  SCOPE_STMT_BLOCK (TREE_PURPOSE (scope)) = block;\n-  SCOPE_STMT_BLOCK (TREE_VALUE (scope)) = block;\n-  RECHAIN_STMTS (body, COMPOUND_BODY (body));\n   finish_function ();\n }"}, {"sha": "f1faeefebf2f24fceeea2697cab11790ee53a15f", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -188,9 +188,7 @@ static void\n build_cdtor (int method_type, tree cdtors)\n {\n   tree fnname = get_file_function_name (method_type);\n-  tree body;\n-  tree scope;\n-  tree block;\n+  tree cs;\n \n   start_function (void_list_node,\n \t\t  build_nt (CALL_EXPR, fnname,\n@@ -199,20 +197,12 @@ build_cdtor (int method_type, tree cdtors)\n \t\t  NULL_TREE);\n   store_parm_decls ();\n \n-  body = c_begin_compound_stmt ();\n-  add_scope_stmt (/*begin_p=*/1, /*partial_p=*/0);\n+  cs = c_begin_compound_stmt (true);\n \n   for (; cdtors; cdtors = TREE_CHAIN (cdtors))\n-    add_stmt (build_stmt (EXPR_STMT,\n-\t\t\t  build_function_call (TREE_VALUE (cdtors), 0)));\n+    add_stmt (build_function_call (TREE_VALUE (cdtors), 0));\n \n-  scope = add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0);\n-\n-  block = make_node (BLOCK);\n-  SCOPE_STMT_BLOCK (TREE_PURPOSE (scope)) = block;\n-  SCOPE_STMT_BLOCK (TREE_VALUE (scope)) = block;\n-\n-  RECHAIN_STMTS (body, COMPOUND_BODY (body));\n+  add_stmt (c_end_compound_stmt (cs, true));\n \n   finish_function ();\n }"}, {"sha": "7589e738ef17185df15c4c7abd5e35d158df6f2d", "filename": "gcc/c-parse.in", "status": "modified", "additions": 57, "deletions": 120, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -208,10 +208,10 @@ do {\t\t\t\t\t\t\t\t\t\\\n %type <ttype> maybe_attribute attributes attribute attribute_list attrib\n %type <ttype> any_word\n \n-%type <ttype> compstmt compstmt_start compstmt_nostart compstmt_primary_start\n-%type <ttype> do_stmt_start pop_scope stmt label\n+%type <ttype> compstmt compstmt_start compstmt_primary_start\n+%type <ttype> do_stmt_start stmt label\n \n-%type <ttype> c99_block_start c99_block_end\n+%type <ttype> c99_block_start c99_block_lineno_labeled_stmt\n %type <ttype> declarator\n %type <ttype> notype_declarator after_type_declarator\n %type <ttype> parm_declarator\n@@ -650,24 +650,12 @@ primary:\n \t| '(' error ')'\n \t\t{ $$ = error_mark_node; }\n \t| compstmt_primary_start compstmt_nostart ')'\n-                 { tree saved_last_tree;\n-\n-\t\t   if (pedantic)\n-\t\t     pedwarn (\"ISO C forbids braced-groups within expressions\");\n-\t\t  saved_last_tree = COMPOUND_BODY ($1);\n-\t\t  RECHAIN_STMTS ($1, COMPOUND_BODY ($1));\n-\t\t  last_tree = saved_last_tree;\n-\t\t  TREE_CHAIN (last_tree) = NULL_TREE;\n-\t\t  if (!last_expr_type)\n-\t\t    last_expr_type = void_type_node;\n-\t\t  $$ = build1 (STMT_EXPR, last_expr_type, $1);\n-\t\t  TREE_SIDE_EFFECTS ($$) = 1;\n-\t\t  annotate_with_locus ($$, input_location);\n+                { if (pedantic)\n+\t\t    pedwarn (\"ISO C forbids braced-groups within expressions\");\n+\t\t  $$ = c_finish_stmt_expr ($1);\n \t\t}\n \t| compstmt_primary_start error ')'\n-\t\t{\n-\t\t  last_tree = COMPOUND_BODY ($1);\n-\t\t  TREE_CHAIN (last_tree) = NULL_TREE;\n+\t\t{ c_finish_stmt_expr ($1);\n \t\t  $$ = error_mark_node;\n \t\t}\n \t| primary '(' exprlist ')'   %prec '.'\n@@ -2010,51 +1998,9 @@ lineno_stmt_decl_or_labels:\n errstmt:  error ';'\n \t;\n \n-push_scope:  /* empty */\n-\t\t{ push_scope ();\n-\t\t  clear_last_expr ();\n-\t\t  add_scope_stmt (/*begin_p=*/1, /*partial_p=*/0);\n-\t\t}\n-\t;\n-\n-pop_scope:  /* empty */\n-                {\n-@@ifobjc\n-\t\t  if (c_dialect_objc ())\n-\t\t    objc_clear_super_receiver ();\n-@@end_ifobjc\n-\t\t  $$ = add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0);\n-\t\t}\n-        ;\n-\n /* Start and end blocks created for the new scopes of C99.  */\n c99_block_start: /* empty */\n-\t\t{ if (flag_isoc99)\n-\t\t    {\n-\t\t      $$ = c_begin_compound_stmt ();\n-\t\t      push_scope ();\n-\t\t      clear_last_expr ();\n-\t\t      add_scope_stmt (/*begin_p=*/1, /*partial_p=*/0);\n-\t\t    }\n-\t\t  else\n-\t\t    $$ = NULL_TREE;\n-\t\t}\n-\t;\n-\n-/* Productions using c99_block_start and c99_block_end will need to do what's\n-   in compstmt: RECHAIN_STMTS ($1, COMPOUND_BODY ($1)); $$ = $2; where\n-   $1 is the value of c99_block_start and $2 of c99_block_end.  */\n-c99_block_end: /* empty */\n-                { if (flag_isoc99)\n-\t\t    {\n-\t\t      tree scope_stmt = add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0);\n-\t\t      $$ = pop_scope ();\n-\t\t      SCOPE_STMT_BLOCK (TREE_PURPOSE (scope_stmt))\n-\t\t\t= SCOPE_STMT_BLOCK (TREE_VALUE (scope_stmt))\n-\t\t\t= $$;\n-\t\t    }\n-\t\t  else\n-\t\t    $$ = NULL_TREE; }\n+\t\t{ $$ = c_begin_compound_stmt (flag_isoc99); }\n \t;\n \n /* Read zero or more forward-declarations for labels\n@@ -2092,16 +2038,11 @@ compstmt_or_error:\n \t;\n \n compstmt_start: '{' { compstmt_count++;\n-                      $$ = c_begin_compound_stmt (); }\n+                      $$ = c_begin_compound_stmt (true); }\n         ;\n \n compstmt_nostart: '}'\n-\t\t{ $$ = convert (void_type_node, integer_zero_node); }\n-\t| push_scope maybe_label_decls compstmt_contents_nonempty '}' pop_scope\n-\t\t{ $$ = pop_scope ();\n-\t\t  SCOPE_STMT_BLOCK (TREE_PURPOSE ($5))\n-\t\t    = SCOPE_STMT_BLOCK (TREE_VALUE ($5))\n-\t\t    = $$; }\n+\t| maybe_label_decls compstmt_contents_nonempty '}'\n \t;\n \n compstmt_contents_nonempty:\n@@ -2113,30 +2054,24 @@ compstmt_primary_start:\n \t'(' '{'\n \t\t{ if (current_function_decl == 0)\n \t\t    {\n-\t\t      error (\"braced-group within expression allowed only inside a function\");\n+\t\t      error (\"braced-group within expression allowed \"\n+\t\t\t     \"only inside a function\");\n \t\t      YYERROR;\n \t\t    }\n-\t\t  /* We must force a BLOCK for this level\n-\t\t     so that, if it is not expanded later,\n-\t\t     there is a way to turn off the entire subtree of blocks\n-\t\t     that are contained in it.  */\n-\t\t  keep_next_level ();\n \t\t  compstmt_count++;\n-\t\t  $$ = add_stmt (build_stmt (COMPOUND_STMT, last_tree));\n-\t\t  last_expr_type = NULL_TREE;\n+\t\t  $$ = c_begin_stmt_expr ();\n \t\t}\n         ;\n \n compstmt: compstmt_start compstmt_nostart\n-\t\t{ RECHAIN_STMTS ($1, COMPOUND_BODY ($1));\n-\t\t  last_expr_type = NULL_TREE;\n-                  $$ = $1; }\n+\t\t{ add_stmt (c_end_compound_stmt ($1, true));\n+\t\t  $$ = NULL_TREE; }\n \t;\n \n /* Value is number of statements counted as of the closeparen.  */\n simple_if:\n \t  if_prefix c99_block_lineno_labeled_stmt\n-                { c_finish_then (); }\n+                { c_finish_then ($2); }\n /* Make sure c_expand_end_cond is run once\n    for each call to c_expand_start_cond.\n    Otherwise a crash is likely.  */\n@@ -2179,7 +2114,7 @@ do_stmt_start:\n \t\t  DO_COND ($<ttype>$) = error_mark_node; }\n \t  c99_block_lineno_labeled_stmt WHILE\n \t\t{ $$ = $<ttype>2;\n-\t\t  RECHAIN_STMTS ($$, DO_BODY ($$));\n+\t\t  DO_BODY ($$) = $3;\n \t\t  c_in_iteration_stmt--; }\n \t;\n \n@@ -2200,14 +2135,24 @@ lineno_labeled_stmt:\n \n /* Like lineno_labeled_stmt, but a block in C99.  */\n c99_block_lineno_labeled_stmt:\n-\t  c99_block_start lineno_labeled_stmt c99_block_end\n-\t\t{ if (flag_isoc99)\n-\t\t    RECHAIN_STMTS ($1, COMPOUND_BODY ($1)); }\n+\t  c99_block_start lineno_labeled_stmt\n+                { $$ = c_end_compound_stmt ($1, flag_isoc99); }\n \t;\n \n lineno_stmt:\n \t  save_location stmt\n-\t\t{ if ($2)\n+\t\t{ \n+\t\t  /* Two cases cannot and do not have line numbers associated:\n+\t\t     If stmt is degenerate, such as \"2;\", then stmt is an \n+\t\t     INTEGER_CST, which cannot hold line numbers.  But that's\n+\t\t     ok because the statement will either be changed to a\n+\t\t     MODIFY_EXPR during gimplification of the statement expr,\n+\t\t     or discarded.  If stmt was compound, but without new\n+\t\t     variables, we will have skipped the creation of a BIND\n+\t\t     and will have a bare STATEMENT_LIST.  But that's ok\n+\t\t     because (recursively) all of the component statments\n+\t\t     should already have line numbers assigned.  */\n+\t\t  if ($2 && EXPR_P ($2))\n \t\t    {\n \t\t      SET_EXPR_LOCUS ($2, NULL);\n \t\t      annotate_with_locus ($2, $1);\n@@ -2230,7 +2175,7 @@ select_or_iter_stmt:\n \t\t{ c_expand_start_else ();\n \t\t  $<itype>1 = stmt_count; }\n \t  c99_block_lineno_labeled_stmt\n-                { c_finish_else ();\n+                { c_finish_else ($4);\n \t\t  c_expand_end_cond ();\n \t\t  if (extra_warnings && stmt_count == $<itype>1)\n \t\t    warning (\"empty body in an else-statement\"); }\n@@ -2261,41 +2206,34 @@ select_or_iter_stmt:\n \t\t  $<ttype>$ = c_begin_while_stmt (); }\n \t  '(' expr ')'\n                 { c_in_iteration_stmt++;\n-\t\t  $4 = lang_hooks.truthvalue_conversion ($4);\n-\t\t  c_finish_while_stmt_cond\n-\t\t    (lang_hooks.truthvalue_conversion ($4), $<ttype>2);\n-\t\t  $<ttype>$ = add_stmt ($<ttype>2); }\n+\t\t  c_finish_while_stmt_cond ($4, $<ttype>2); }\n \t  c99_block_lineno_labeled_stmt\n                 { c_in_iteration_stmt--;\n-\t\t  RECHAIN_STMTS ($<ttype>6, WHILE_BODY ($<ttype>6)); }\n+\t\t  c_finish_while_stmt ($7, $<ttype>2); }\n \t| do_stmt_start\n \t  '(' expr ')' ';'\n                 { DO_COND ($1) = lang_hooks.truthvalue_conversion ($3); }\n \t| do_stmt_start error\n \t\t{ }\n \t| FOR\n-\t\t{ $<ttype>$ = build_stmt (FOR_STMT, NULL_TREE, NULL_TREE,\n-\t\t\t\t\t  NULL_TREE, NULL_TREE);\n-\t\t  add_stmt ($<ttype>$); }\n+\t\t{ $<ttype>$ = c_begin_for_stmt (); }\n \t  '(' for_init_stmt\n \t\t{ stmt_count++;\n-\t\t  RECHAIN_STMTS ($<ttype>2, FOR_INIT_STMT ($<ttype>2)); }\n+\t\t  c_finish_for_stmt_init ($<ttype>2); }\n \t  xexpr ';'\n-                { if ($6)\n-\t\t    FOR_COND ($<ttype>2)\n-\t\t      = lang_hooks.truthvalue_conversion ($6); }\n+                { c_finish_for_stmt_cond ($6, $<ttype>2); }\n \t  xexpr ')'\n                 { c_in_iteration_stmt++;\n-\t\t  FOR_EXPR ($<ttype>2) = $9; }\n+\t\t  c_finish_for_stmt_incr ($9, $<ttype>2); }\n \t  c99_block_lineno_labeled_stmt\n-                { RECHAIN_STMTS ($<ttype>2, FOR_BODY ($<ttype>2));\n-\t\t  c_in_iteration_stmt--;}\n+                { c_finish_for_stmt ($12, $<ttype>2);\n+\t\t  c_in_iteration_stmt--; }\n \t| SWITCH '(' expr ')'\n \t\t{ stmt_count++;\n \t\t  $<ttype>$ = c_start_case ($3);\n \t\t  c_in_case_stmt++; }\n \t  c99_block_lineno_labeled_stmt\n-                { c_finish_case ();\n+                { c_finish_case ($6);\n \t\t  c_in_case_stmt--; }\n \t;\n \n@@ -2319,28 +2257,27 @@ stmt:\n \t| expr ';'\n \t\t{ stmt_count++;\n \t\t  $$ = c_expand_expr_stmt ($1); }\n-\t| c99_block_start select_or_iter_stmt c99_block_end\n-\t\t{ if (flag_isoc99)\n-\t\t    RECHAIN_STMTS ($1, COMPOUND_BODY ($1));\n+\t| c99_block_start select_or_iter_stmt\n+                { add_stmt (c_end_compound_stmt ($1, flag_isoc99));\n \t\t  $$ = NULL_TREE; }\n \t| BREAK ';'\n \t        { stmt_count++;\n-\t\tif (!(c_in_iteration_stmt || c_in_case_stmt))\n-\t\t  {\n-\t\t    error (\"break statement not within loop or switch\");\n-\t\t    $$ = NULL_TREE;\n-\t\t  }\n-\t\telse\n-\t\t  $$ = add_stmt (build_break_stmt ()); }\n+\t\t  if (!(c_in_iteration_stmt || c_in_case_stmt))\n+\t\t    {\n+\t\t      error (\"break statement not within loop or switch\");\n+\t\t      $$ = NULL_TREE;\n+\t\t    }\n+\t\t  else\n+\t\t    $$ = add_stmt (build_break_stmt ()); }\n \t| CONTINUE ';'\n                 { stmt_count++;\n-\t\tif (!c_in_iteration_stmt)\n-\t\t  {\n-\t\t    error (\"continue statement not within a loop\");\n-\t\t    $$ = NULL_TREE;\n-\t\t  }\n-\t\telse\n-\t\t  $$ = add_stmt (build_continue_stmt ()); }\n+\t\t  if (!c_in_iteration_stmt)\n+\t\t    {\n+\t\t      error (\"continue statement not within a loop\");\n+\t\t      $$ = NULL_TREE;\n+\t\t    }\n+\t\t  else\n+\t\t    $$ = add_stmt (build_continue_stmt ()); }\n \t| RETURN ';'\n                 { stmt_count++;\n \t\t  $$ = c_expand_return (NULL_TREE); }"}, {"sha": "06b8654ab24ef3d7161dca02ba4b27ee6f08a0e8", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -26,6 +26,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"real.h\"\n #include \"c-pretty-print.h\"\n #include \"c-tree.h\"\n+#include \"tree-iterator.h\"\n #include \"diagnostic.h\"\n \n /* The pretty-printer code is primarily designed to closely follow\n@@ -1892,6 +1893,22 @@ pp_c_statement (c_pretty_printer *pp, tree stmt)\n   code = TREE_CODE (stmt);\n   switch (code)\n     {\n+    case STATEMENT_LIST:\n+      {\n+\ttree_stmt_iterator tsi;\n+\n+        if (pp_needs_newline (pp))\n+          pp_newline_and_indent (pp, 0);\n+        pp_c_left_brace (pp);\n+        pp_newline_and_indent (pp, 3);\n+\tfor (tsi = tsi_start (stmt); !tsi_end_p (tsi); tsi_next (&tsi))\n+          pp_statement (pp, tsi_stmt (tsi));\n+        pp_newline_and_indent (pp, -3);\n+        pp_c_right_brace (pp);\n+        pp_needs_newline (pp) = true;\n+      }\n+      break;\n+\n        /* labeled-statement:\n              identifier : statement\n              case constant-expression : statement\n@@ -1940,8 +1957,7 @@ pp_c_statement (c_pretty_printer *pp, tree stmt)\n         pp_newline_and_indent (pp, 0);\n       pp_c_left_brace (pp);\n       pp_newline_and_indent (pp, 3);\n-      for (stmt = COMPOUND_BODY (stmt); stmt; stmt = TREE_CHAIN (stmt))\n-\tpp_statement (pp, stmt);\n+      pp_statement (pp, COMPOUND_BODY (stmt));\n       pp_newline_and_indent (pp, -3);\n       pp_c_right_brace (pp);\n       pp_needs_newline (pp) = true;\n@@ -2103,27 +2119,6 @@ pp_c_statement (c_pretty_printer *pp, tree stmt)\n       }\n       break;\n \n-    case SCOPE_STMT:\n-      if (!SCOPE_NULLIFIED_P (stmt) && SCOPE_NO_CLEANUPS_P (stmt))\n-        {\n-          int i = 0;\n-          if (pp_needs_newline (pp))\n-            pp_newline_and_indent (pp, 0);\n-          if (SCOPE_BEGIN_P (stmt))\n-            {\n-              pp_left_brace (pp);\n-              i = 3;\n-            }\n-          else if (SCOPE_END_P (stmt))\n-            {\n-              pp_right_brace (pp);\n-              i = -3;\n-            }\n-          pp_indentation (pp) += i;\n-          pp_needs_newline (pp) = true;\n-        }\n-      break;\n-\n     case DECL_STMT:\n       if (pp_needs_newline (pp))\n         pp_newline_and_indent (pp, 0);"}, {"sha": "4a48191670004ad0d60b3518d5f5e15f133f8d1e", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 92, "deletions": 67, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -43,37 +43,104 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"timevar.h\"\n #include \"predict.h\"\n #include \"tree-inline.h\"\n+#include \"tree-gimple.h\"\n #include \"langhooks.h\"\n \n /* Create an empty statement tree rooted at T.  */\n \n-void\n-begin_stmt_tree (tree *t)\n+tree\n+push_stmt_list (void)\n {\n-  /* We create a trivial EXPR_STMT so that last_tree is never NULL in\n-     what follows.  We remove the extraneous statement in\n-     finish_stmt_tree.  */\n-  *t = build_nt (EXPR_STMT, void_zero_node);\n-  last_tree = *t;\n-  last_expr_type = NULL_TREE;\n-  last_expr_filename = input_filename;\n+  tree t;\n+  t = alloc_stmt_list ();\n+  TREE_CHAIN (t) = cur_stmt_list;\n+  cur_stmt_list = t;\n+  return t;\n+}\n+\n+/* Similarly, except that T may have already been pushed/popped, and\n+   thus may already contain statement(s).  Arrage for new statements\n+   to be appended.  */\n+\n+tree\n+re_push_stmt_list (tree t)\n+{\n+  if (t)\n+    {\n+      if (TREE_CODE (t) != STATEMENT_LIST)\n+\t{\n+\t  tree u = alloc_stmt_list ();\n+\t  append_to_statement_list_force (t, &u);\n+\t  t = u;\n+\t}\n+    }\n+  else\n+    t = alloc_stmt_list ();\n+  TREE_CHAIN (t) = cur_stmt_list;\n+  cur_stmt_list = t;\n+  return t;\n+}\n+\n+/* Finish the statement tree rooted at T.  */\n+\n+tree\n+pop_stmt_list (tree t)\n+{\n+  tree u = cur_stmt_list, chain;\n+\n+  /* Pop statement lists until we reach the target level.  The extra\n+     nestings will be due to outstanding cleanups.  */\n+  while (1)\n+    {\n+      chain = TREE_CHAIN (u);\n+      TREE_CHAIN (u) = NULL_TREE;\n+      if (t == u)\n+\tbreak;\n+      u = chain;\n+    }\n+  cur_stmt_list = chain;\n+\n+  /* If the statement list is completely empty, just return it.  This is\n+     just as good small as build_empty_stmt, with the advantage that \n+     statement lists are merged when they appended to one another.  So\n+     using the STATEMENT_LIST avoids pathological buildup of EMPTY_STMT_P\n+     statements.  */\n+  if (TREE_SIDE_EFFECTS (t))\n+    {\n+      tree_stmt_iterator i = tsi_start (t);\n+\n+      /* If the statement list contained exactly one statement, then\n+\t extract it immediately.  */\n+      if (tsi_one_before_end_p (i))\n+\t{\n+\t  u = tsi_stmt (i);\n+\t  tsi_delink (&i);\n+\t  free_stmt_list (t);\n+\t  t = u;\n+\t}\n+    }\n+\n+  return t;\n }\n \n /* T is a statement.  Add it to the statement-tree.  */\n \n tree\n add_stmt (tree t)\n {\n-  if (!EXPR_LOCUS (t))\n-    annotate_with_locus (t, input_location);\n+  if (EXPR_P (t) || STATEMENT_CODE_P (TREE_CODE (t)))\n+    {\n+      if (!EXPR_LOCUS (t))\n+\tannotate_with_locus (t, input_location);\n \n-  /* Add T to the statement-tree.  */\n-  TREE_CHAIN (last_tree) = t;\n-  last_tree = t;\n+      /* When we expand a statement-tree, we must know whether or not the\n+\t statements are full-expressions.  We record that fact here.  */\n+      STMT_IS_FULL_EXPR_P (t) = stmts_are_full_exprs_p ();\n+    }\n \n-  /* When we expand a statement-tree, we must know whether or not the\n-     statements are full-expressions.  We record that fact here.  */\n-  STMT_IS_FULL_EXPR_P (last_tree) = stmts_are_full_exprs_p ();\n+  /* Add T to the statement-tree.  Non-side-effect statements need to be\n+     recorded during statement expressions.  */\n+  append_to_statement_list_force (t, &cur_stmt_list);\n \n   return t;\n }\n@@ -91,59 +158,17 @@ add_decl_stmt (tree decl)\n   add_stmt (decl_stmt);\n }\n \n-/* Add a scope-statement to the statement-tree.  BEGIN_P indicates\n-   whether this statements opens or closes a scope.  PARTIAL_P is true\n-   for a partial scope, i.e, the scope that begins after a label when\n-   an object that needs a cleanup is created.  If BEGIN_P is nonzero,\n-   returns a new TREE_LIST representing the top of the SCOPE_STMT\n-   stack.  The TREE_PURPOSE is the new SCOPE_STMT.  If BEGIN_P is\n-   zero, returns a TREE_LIST whose TREE_VALUE is the new SCOPE_STMT,\n-   and whose TREE_PURPOSE is the matching SCOPE_STMT with\n-   SCOPE_BEGIN_P set.  */\n-\n-tree\n-add_scope_stmt (int begin_p, int partial_p)\n-{\n-  tree *stack_ptr = current_scope_stmt_stack ();\n-  tree ss;\n-  tree top = *stack_ptr;\n-\n-  /* Build the statement.  */\n-  ss = build_stmt (SCOPE_STMT, NULL_TREE);\n-  SCOPE_BEGIN_P (ss) = begin_p;\n-  SCOPE_PARTIAL_P (ss) = partial_p;\n-\n-  /* Keep the scope stack up to date.  */\n-  if (begin_p)\n-    {\n-      top = tree_cons (ss, NULL_TREE, top);\n-      *stack_ptr = top;\n-    }\n-  else\n-    {\n-      if (partial_p != SCOPE_PARTIAL_P (TREE_PURPOSE (top)))\n-\tabort ();\n-      TREE_VALUE (top) = ss;\n-      *stack_ptr = TREE_CHAIN (top);\n-    }\n-\n-  /* Add the new statement to the statement-tree.  */\n-  add_stmt (ss);\n-\n-  return top;\n-}\n-\n-/* Finish the statement tree rooted at T.  */\n+/* Queue a cleanup.  CLEANUP is an expression/statement to be executed\n+   when the current scope is exited.  EH_ONLY is true when this is not\n+   meant to apply to normal control flow transfer.  */\n \n void\n-finish_stmt_tree (tree *t)\n+push_cleanup (tree decl, tree cleanup, bool eh_only)\n {\n-  tree stmt;\n-\n-  /* Remove the fake extra statement added in begin_stmt_tree.  */\n-  stmt = TREE_CHAIN (*t);\n-  *t = stmt;\n-  last_tree = NULL_TREE;\n+  tree stmt = build_stmt (CLEANUP_STMT, NULL, cleanup, decl);\n+  CLEANUP_EH_ONLY (stmt) = eh_only;\n+  add_stmt (stmt);\n+  CLEANUP_BODY (stmt) = push_stmt_list ();\n }\n \n /* Build a generic statement based on the given type of node and"}, {"sha": "b311bb3e205cca9758beffb1cd13891b6c1081e1", "filename": "gcc/c-tree.h", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -191,7 +191,7 @@ extern tree start_decl (tree, tree, int, tree);\n extern tree start_struct (enum tree_code, tree);\n extern void store_parm_decls (void);\n extern tree xref_tag (enum tree_code, tree);\n-extern tree c_begin_compound_stmt (void);\n+extern int c_expand_decl (tree);\n extern void c_static_assembler_name (tree);\n extern tree make_pointer_declarator (tree, tree);\n \n@@ -249,11 +249,29 @@ extern tree build_compound_literal (tree, tree);\n extern void pedwarn_c90 (const char *, ...) ATTRIBUTE_PRINTF_1;\n extern void pedwarn_c99 (const char *, ...) ATTRIBUTE_PRINTF_1;\n extern tree c_start_case (tree);\n-extern void c_finish_case (void);\n+extern void c_finish_case (tree);\n extern tree build_asm_expr (tree, tree, tree, tree, bool);\n extern tree build_asm_stmt (tree, tree);\n extern tree c_convert_parm_for_inlining (tree, tree, tree, int);\n extern int c_types_compatible_p (tree, tree);\n+extern tree c_begin_compound_stmt (bool);\n+extern tree c_end_compound_stmt (tree, bool);\n+extern void c_expand_start_cond (tree, int, tree);\n+extern void c_finish_then (tree);\n+extern void c_expand_start_else (void);\n+extern void c_finish_else (tree);\n+extern void c_expand_end_cond (void);\n+extern tree c_begin_if_stmt (void);\n+extern tree c_begin_while_stmt (void);\n+extern void c_finish_while_stmt_cond (tree, tree);\n+extern void c_finish_while_stmt (tree, tree);\n+extern tree c_begin_for_stmt (void);\n+extern void c_finish_for_stmt_init (tree);\n+extern void c_finish_for_stmt_cond (tree, tree);\n+extern void c_finish_for_stmt_incr (tree, tree);\n+extern void c_finish_for_stmt (tree, tree);\n+extern tree c_begin_stmt_expr (void);\n+extern tree c_finish_stmt_expr (tree);\n extern tree build_offsetof (tree, tree);\n \n /* Set to 0 at beginning of a function definition, set to 1 if"}, {"sha": "af7fd03abdf1510ae764f6113e655a05900e4a88", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 310, "deletions": 22, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -45,6 +45,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"intl.h\"\n #include \"ggc.h\"\n #include \"target.h\"\n+#include \"tree-iterator.h\"\n+\n \n /* Nonzero if we've already printed a \"missing braces around initializer\"\n    message within this initializer.  */\n@@ -2206,16 +2208,7 @@ int\n c_tree_expr_nonnegative_p (tree t)\n {\n   if (TREE_CODE (t) == STMT_EXPR)\n-    {\n-      t = COMPOUND_BODY (STMT_EXPR_STMT (t));\n-\n-      /* Find the last statement in the chain, ignoring the final\n-\t     * scope statement */\n-      while (TREE_CHAIN (t) != NULL_TREE\n-             && TREE_CODE (TREE_CHAIN (t)) != SCOPE_STMT)\n-        t = TREE_CHAIN (t);\n-      return tree_expr_nonnegative_p (TREE_OPERAND (t, 0));\n-    }\n+    t = expr_last (COMPOUND_BODY (STMT_EXPR_STMT (t)));\n   return tree_expr_nonnegative_p (t);\n }\n \n@@ -6435,19 +6428,11 @@ do_case (tree low_value, tree high_value)\n \n   if (switch_stack)\n     {\n-      bool switch_was_empty_p = (SWITCH_BODY (switch_stack->switch_stmt) == NULL_TREE);\n-\n       label = c_add_case_label (switch_stack->cases,\n \t\t\t\tSWITCH_COND (switch_stack->switch_stmt),\n \t\t\t\tlow_value, high_value);\n       if (label == error_mark_node)\n \tlabel = NULL_TREE;\n-      else if (switch_was_empty_p)\n-\t{\n-\t  /* Attach the first case label to the SWITCH_BODY.  */\n-\t  SWITCH_BODY (switch_stack->switch_stmt) = TREE_CHAIN (switch_stack->switch_stmt);\n-\t  TREE_CHAIN (switch_stack->switch_stmt) = NULL_TREE;\n-\t}\n     }\n   else if (low_value)\n     error (\"case label not within a switch statement\");\n@@ -6460,22 +6445,325 @@ do_case (tree low_value, tree high_value)\n /* Finish the switch statement.  */\n \n void\n-c_finish_case (void)\n+c_finish_case (tree body)\n {\n   struct c_switch *cs = switch_stack;\n \n+  SWITCH_BODY (cs->switch_stmt) = body;\n+\n   /* Emit warnings as needed.  */\n   c_do_switch_warnings (cs->cases, cs->switch_stmt);\n \n-  /* Rechain the next statements to the SWITCH_STMT.  */\n-  last_tree = cs->switch_stmt;\n-\n   /* Pop the stack.  */\n   switch_stack = switch_stack->next;\n   splay_tree_delete (cs->cases);\n   free (cs);\n }\n+\f\n+/* Keep a stack of if statements.  We record the number of compound\n+   statements seen up to the if keyword, as well as the line number\n+   and file of the if.  If a potentially ambiguous else is seen, that\n+   fact is recorded; the warning is issued when we can be sure that\n+   the enclosing if statement does not have an else branch.  */\n+typedef struct\n+{\n+  int compstmt_count;\n+  location_t locus;\n+  int needs_warning;\n+  tree if_stmt;\n+} if_elt;\n+\n+static if_elt *if_stack;\n+\n+/* Amount of space in the if statement stack.  */\n+static int if_stack_space = 0;\n+\n+/* Stack pointer.  */\n+static int if_stack_pointer = 0;\n+\n+/* Begin an if-statement.  Returns a newly created IF_STMT if\n+   appropriate.  */\n+\n+tree\n+c_begin_if_stmt (void)\n+{\n+  tree r;\n+  r = add_stmt (build_stmt (IF_STMT, NULL_TREE, NULL_TREE, NULL_TREE));\n+  return r;\n+}\n+\n+/* Record the start of an if-then, and record the start of it\n+   for ambiguous else detection.\n+\n+   COND is the condition for the if-then statement.\n+\n+   IF_STMT is the statement node that has already been created for\n+   this if-then statement.  It is created before parsing the\n+   condition to keep line number information accurate.  */\n \n+void\n+c_expand_start_cond (tree cond, int compstmt_count, tree if_stmt)\n+{\n+  /* Make sure there is enough space on the stack.  */\n+  if (if_stack_space == 0)\n+    {\n+      if_stack_space = 10;\n+      if_stack = xmalloc (10 * sizeof (if_elt));\n+    }\n+  else if (if_stack_space == if_stack_pointer)\n+    {\n+      if_stack_space += 10;\n+      if_stack = xrealloc (if_stack, if_stack_space * sizeof (if_elt));\n+    }\n+\n+  IF_COND (if_stmt) = cond;\n+\n+  /* Record this if statement.  */\n+  if_stack[if_stack_pointer].compstmt_count = compstmt_count;\n+  if_stack[if_stack_pointer].locus = input_location;\n+  if_stack[if_stack_pointer].needs_warning = 0;\n+  if_stack[if_stack_pointer].if_stmt = if_stmt;\n+  if_stack_pointer++;\n+}\n+\n+/* Called after the then-clause for an if-statement is processed.  */\n+\n+void\n+c_finish_then (tree then_stmt)\n+{\n+  tree if_stmt = if_stack[if_stack_pointer - 1].if_stmt;\n+  THEN_CLAUSE (if_stmt) = then_stmt;\n+}\n+\n+/* Record the end of an if-then.  Optionally warn if a nested\n+   if statement had an ambiguous else clause.  */\n+\n+void\n+c_expand_end_cond (void)\n+{\n+  if_stack_pointer--;\n+  if (if_stack[if_stack_pointer].needs_warning)\n+    warning (\"%Hsuggest explicit braces to avoid ambiguous `else'\",\n+\t     &if_stack[if_stack_pointer].locus);\n+}\n+\n+/* Called between the then-clause and the else-clause\n+   of an if-then-else.  */\n+\n+void\n+c_expand_start_else (void)\n+{\n+  /* An ambiguous else warning must be generated for the enclosing if\n+     statement, unless we see an else branch for that one, too.  */\n+  if (warn_parentheses\n+      && if_stack_pointer > 1\n+      && (if_stack[if_stack_pointer - 1].compstmt_count\n+\t  == if_stack[if_stack_pointer - 2].compstmt_count))\n+    if_stack[if_stack_pointer - 2].needs_warning = 1;\n+\n+  /* Even if a nested if statement had an else branch, it can't be\n+     ambiguous if this one also has an else.  So don't warn in that\n+     case.  Also don't warn for any if statements nested in this else.  */\n+  if_stack[if_stack_pointer - 1].needs_warning = 0;\n+  if_stack[if_stack_pointer - 1].compstmt_count--;\n+}\n+\n+/* Called after the else-clause for an if-statement is processed.  */\n+\n+void\n+c_finish_else (tree else_stmt)\n+{\n+  tree if_stmt = if_stack[if_stack_pointer - 1].if_stmt;\n+  ELSE_CLAUSE (if_stmt) = else_stmt;\n+}\n+\f\n+/* Begin a while statement.  Returns a newly created WHILE_STMT if\n+   appropriate.  */\n+\n+tree\n+c_begin_while_stmt (void)\n+{\n+  tree r;\n+  r = add_stmt (build_stmt (WHILE_STMT, NULL_TREE, NULL_TREE));\n+  return r;\n+}\n+\n+void\n+c_finish_while_stmt_cond (tree cond, tree while_stmt)\n+{\n+  WHILE_COND (while_stmt) = (*lang_hooks.truthvalue_conversion) (cond);\n+}\n+\n+void\n+c_finish_while_stmt (tree body, tree while_stmt)\n+{\n+  WHILE_BODY (while_stmt) = body;\n+}\n+\f\n+/* Create a for statement.  */\n+\n+tree\n+c_begin_for_stmt (void)\n+{\n+  tree r;\n+  r = add_stmt (build_stmt (FOR_STMT, NULL_TREE, NULL_TREE,\n+\t\t\t    NULL_TREE, NULL_TREE));\n+  FOR_INIT_STMT (r) = push_stmt_list ();\n+  return r;\n+}\n+\n+void\n+c_finish_for_stmt_init (tree for_stmt)\n+{\n+  FOR_INIT_STMT (for_stmt) = pop_stmt_list (FOR_INIT_STMT (for_stmt));\n+}\n+\n+void\n+c_finish_for_stmt_cond (tree cond, tree for_stmt)\n+{\n+  if (cond)\n+    FOR_COND (for_stmt) = lang_hooks.truthvalue_conversion (cond);\n+}\n+\n+void\n+c_finish_for_stmt_incr (tree expr, tree for_stmt)\n+{\n+  FOR_EXPR (for_stmt) = expr;\n+}\n+\n+void\n+c_finish_for_stmt (tree body, tree for_stmt)\n+{\n+  FOR_BODY (for_stmt) = body;\n+}\n+\f\n+/* Create a statement expression.  */\n+\n+tree\n+c_begin_stmt_expr (void)\n+{\n+  tree ret;\n+\n+  /* We must force a BLOCK for this level so that, if it is not expanded\n+     later, there is a way to turn off the entire subtree of blocks that\n+     are contained in it.  */\n+  keep_next_level ();\n+  ret = c_begin_compound_stmt (true);\n+\n+  /* Mark the current statement list as belonging to a statement list.  */\n+  STATEMENT_LIST_STMT_EXPR (ret) = 1;\n+\n+  return ret;\n+}\n+\n+tree\n+c_finish_stmt_expr (tree body)\n+{\n+  tree ret, last, type;\n+  tree *last_p;\n+\n+  body = c_end_compound_stmt (body, true);\n+\n+  /* Locate the last statement in BODY.  */\n+  last = body, last_p = &body;\n+  if (TREE_CODE (last) == BIND_EXPR)\n+    {\n+      last_p = &BIND_EXPR_BODY (last);\n+      last = BIND_EXPR_BODY (last);\n+    }\n+  if (TREE_CODE (last) == STATEMENT_LIST)\n+    {\n+      tree_stmt_iterator i = tsi_last (last);\n+      if (tsi_end_p (i))\n+\t{\n+\t  type = void_type_node;\n+\t  /* ??? Warn */\n+\t  goto no_expr;\n+\t}\n+      else\n+\t{\n+\t  last_p = tsi_stmt_ptr (i);\n+\t  last = *last_p;\n+\t}\n+    }\n+\n+  /* If the last statement is an EXPR_STMT, then unwrap it.  Otherwise\n+     voidify_wrapper_expr will stuff it inside a MODIFY_EXPR and we'll\n+     fail gimplification.  */\n+  /* ??? Should we go ahead and perform voidify_wrapper_expr here?\n+     We've got about all the information we need here.  All we'd have\n+     to do even for proper type safety is to create, in effect,\n+\t( ({ ...; tmp = last; }), tmp )\n+     I.e. a COMPOUND_EXPR with the rhs being the compiler temporary.\n+     Not going to try this now, since it's not clear what should\n+     happen (wrt bindings) with new temporaries at this stage.  It's\n+     easier once we begin gimplification.  */\n+  if (TREE_CODE (last) == EXPR_STMT)\n+    *last_p = last = EXPR_STMT_EXPR (last);\n+\n+  /* Extract the type of said expression.  */\n+  type = TREE_TYPE (last);\n+  if (!type)\n+    type = void_type_node;\n+\n+ no_expr:\n+  /* If what's left is compound, make sure we've got a BIND_EXPR, and\n+     that it has the proper type.  */\n+  ret = body;\n+  if (TREE_CODE (ret) == STATEMENT_LIST)\n+    ret = build (BIND_EXPR, type, NULL, ret, NULL);\n+  else if (TREE_CODE (ret) == BIND_EXPR)\n+    TREE_TYPE (ret) = type;\n+\n+  return ret;\n+}\n+\f\n+/* Begin and end compound statements.  This is as simple as pushing\n+   and popping new statement lists from the tree.  */\n+\n+tree\n+c_begin_compound_stmt (bool do_scope)\n+{\n+  tree stmt = push_stmt_list ();\n+  if (do_scope)\n+    {\n+      push_scope ();\n+      clear_last_expr ();\n+    }\n+  return stmt;\n+}\n+\n+tree\n+c_end_compound_stmt (tree stmt, bool do_scope)\n+{\n+  tree block = NULL;\n+\n+  if (do_scope)\n+    {\n+      if (c_dialect_objc ())\n+\tobjc_clear_super_receiver ();\n+      block = pop_scope ();\n+    }\n+\n+  stmt = pop_stmt_list (stmt);\n+  stmt = c_build_bind_expr (block, stmt);\n+\n+  /* If this compound statement is nested immediately inside a statement\n+     expression, then force a BIND_EXPR to be created.  Otherwise we'll\n+     do the wrong thing for ({ { 1; } }) or ({ 1; { } }).  In particular,\n+     STATEMENT_LISTs merge, and thus we can lose track of what statement\n+     was really last.  */\n+  if (cur_stmt_list\n+      && STATEMENT_LIST_STMT_EXPR (cur_stmt_list)\n+      && TREE_CODE (stmt) != BIND_EXPR)\n+    {\n+      stmt = build (BIND_EXPR, void_type_node, NULL, stmt, NULL);\n+      TREE_SIDE_EFFECTS (stmt) = 1;\n+    }\n+\n+  return stmt;\n+}\n+\f\n /* Build a binary-operation expression without default conversions.\n    CODE is the kind of expression to build.\n    This function differs from `build' in several ways:"}, {"sha": "c8a1a1e5e9c13671d68a26a8f5a0b0614f7ebfb5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -1,3 +1,63 @@\n+2004-06-15  Richard Henderson  <rth@redhat.com>\n+\n+\t* call.c (initialize_reference): Don't build CLEANUP_STMT here.\n+\t* cp-gimplify.c (cp_gimplify_stmt): Remove next_p argument.\n+\t(genericize_try_block): Use gimplify_stmt.\n+\t(genericize_catch_block, genericize_eh_spec_block): Likewise.\n+\t(cp_gimplify_init_expr): Remove STMT_EXPR special case.\n+\t(gimplify_must_not_throw_expr): Update voidify_wrapper_expr call.\n+\t* cp-lang.c (LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P): Remove.\n+\t(cp_tree_chain_matters_p): Remove.\n+\t* cp-tree.h (COMPOUND_STMT_TRY_BLOCK): New.\n+\t(COMPOUND_STMT_BODY_BLOCK): New.\n+\t(STATEMENT_LIST_NO_SCOPE, STATEMENT_LIST_TRY_BLOCK): New.\n+\t(EXPR_STMT_STMT_EXPR_RESULT): New.\n+\t(building_stmt_tree): Check cur_stmt_list.\n+\t(tf_stmt_expr_cmpd, tf_stmt_expr_body): Remove.\n+\t(BCS_NO_SCOPE, BCS_TRY_BLOCK, BCS_FN_BODY): New.\n+\t* decl.c (poplevel): Use pop_stmt_list for minding cleanups.\n+\t(cp_finish_decl): Use push_cleanup.\n+\t(start_function, finish_function): Use statement lists.\n+\t(finish_stmt): Do nothing.\n+\t* except.c (begin_eh_spec_block): Use statement lists.\n+\t(check_handlers_1, check_handlers): Likewise.\n+\t* init.c (construct_virtual_base): Don't add extra compound stmts.\n+\t(build_vec_init): Likewise.\n+\t* name-lookup.c (maybe_push_cleanup_level): Use statement lists.\n+\t* name-lookup.h (struct cp_binding_level): Add statement_list.\n+\t* parser.c (cp_parser_statement): Take the STMT_EXPR node, not a bool.\n+\t(cp_parser_labeled_statement, cp_parser_expression_statement,\n+\tcp_parser_statement_seq_opt): Likewise.\n+\t(cp_parser_compound_statement): Likewise.  Take bool for try block.\n+\t(cp_parser_selection_statement): Tidy if processing.\n+\t(cp_parser_already_scoped_statement): Rewrite to do what it says.\n+\t* pt.c (tsubst_copy): Move STMT_EXPR to tsubst_expr.\n+\t(tsubst_expr): Rewrite STMT_EXPR processing.  Handle STATEMENT_LIST.\n+\tMind COMPOUND_STMT_TRY_BLOCK, EXPR_STMT_STMT_EXPR_RESULT.\n+\t* semantics.c (do_poplevel, do_pushlevel): Use statement lists.\n+\t(finish_cond): New, rewritten from FINISH_COND.\n+\t(simplify_loop_decl_cond): New.\n+\t(finish_expr_stmt): Avoid nested EXPR_STMTs.\n+\t(begin_if_stmt, finish_if_stmt_cond, finish_then_clause,\n+\tbegin_else_clause, finish_else_clause, finish_if_stmt,\n+\tbegin_while_stmt, finish_while_stmt_cond, finish_while_stmt,\n+\tbegin_do_stmt, finish_do_body, begin_for_stmt, finish_for_init_stmt,\n+\tfinish_for_cond, finish_for_stmt, begin_switch_stmt,\n+\tfinish_switch_cond, finish_switch_stmt, begin_try_block,\n+\tfinish_try_block, finish_cleanup_try_block, finish_function_try_block,\n+\tfinish_handler_sequence, finish_function_handler_sequence,\n+\tbegin_handler, finish_handler_parms, finish_handler,\n+\tbegin_stmt_expr, finish_stmt_expr_expr, finish_stmt_expr): Rewrite\n+\tusing statement lists.\n+\t(begin_compound_stmt): Replace has_no_scope argument with flags.\n+\tUpdate all callers.  Use statement lists.\n+\t(finish_compound_stmt): Likewise.\n+\t(finish_decl_cleanup, finish_eh_cleanup): Use push_cleanup.\n+\t(current_scope_stmt_stack): Remove.\n+\t(simplify_aggr_init_expr): Don't muck with TREE_CHAIN.\n+\t* typeck2.c (split_nonconstant_init_1, split_nonconstant_init):\n+\tRewrite with statement lists.\n+\n 2004-06-15  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* parser.c: Change all assignments of c_lex_string_translate"}, {"sha": "616cf812f9211359dc7c0696c333506fe5a0286b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -6362,9 +6362,9 @@ make_temporary_var_for_ref_to_temp (tree decl, tree type)\n    the VAR_DECL being initialized with the EXPR.  (In that case, the\n    type of DECL will be TYPE.)  If DECL is non-NULL, then CLEANUP must\n    also be non-NULL, and with *CLEANUP initialized to NULL.  Upon\n-   return, if *CLEANUP is no longer NULL, it will be a CLEANUP_STMT\n-   that should be inserted after the returned expression is used to\n-   initialize DECL.\n+   return, if *CLEANUP is no longer NULL, it will be an expression\n+   that should be pushed as a cleanup after the returned expression\n+   is used to initialize DECL.\n \n    Return the converted expression.  */\n \n@@ -6485,26 +6485,25 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n \t    {\n \t      add_decl_stmt (var);\n \t      *cleanup = cxx_maybe_build_cleanup (var);\n-\t      if (*cleanup)\n-\t\t/* We must be careful to destroy the temporary only\n-\t\t   after its initialization has taken place.  If the\n-\t\t   initialization throws an exception, then the\n-\t\t   destructor should not be run.  We cannot simply\n-\t\t   transform INIT into something like:\n+\n+\t      /* We must be careful to destroy the temporary only\n+\t\t after its initialization has taken place.  If the\n+\t\t initialization throws an exception, then the\n+\t\t destructor should not be run.  We cannot simply\n+\t\t transform INIT into something like:\n \t     \n \t\t     (INIT, ({ CLEANUP_STMT; }))\n \n-\t\t   because emit_local_var always treats the\n-\t\t   initializer as a full-expression.  Thus, the\n-\t\t   destructor would run too early; it would run at the\n-\t\t   end of initializing the reference variable, rather\n-\t\t   than at the end of the block enclosing the\n-\t\t   reference variable.\n-\n-\t\t   The solution is to pass back a CLEANUP_STMT which\n-\t\t   the caller is responsible for attaching to the\n-\t\t   statement tree.  */\n-\t\t*cleanup = build_stmt (CLEANUP_STMT, var, *cleanup);\n+\t\t because emit_local_var always treats the\n+\t\t initializer as a full-expression.  Thus, the\n+\t\t destructor would run too early; it would run at the\n+\t\t end of initializing the reference variable, rather\n+\t\t than at the end of the block enclosing the\n+\t\t reference variable.\n+\n+\t\t The solution is to pass back a cleanup expression\n+\t\t which the caller is responsible for attaching to\n+\t\t the statement tree.  */\n \t    }\n \t  else\n \t    {"}, {"sha": "2884d8b5b2df347660c2acd2227b349cc6e59db7", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -39,7 +39,7 @@ static void cp_gimplify_init_expr (tree *, tree *, tree *);\n /* Genericize a C++ _STMT.  Called from c_gimplify_stmt.  */\n \n int\n-cp_gimplify_stmt (tree *stmt_p, tree *next_p ATTRIBUTE_UNUSED)\n+cp_gimplify_stmt (tree *stmt_p)\n {\n   tree stmt = *stmt_p;\n   switch (TREE_CODE (stmt))\n@@ -76,12 +76,12 @@ genericize_try_block (tree *stmt_p)\n   tree body = TRY_STMTS (*stmt_p);\n   tree cleanup = TRY_HANDLERS (*stmt_p);\n \n-  c_gimplify_stmt (&body);\n+  gimplify_stmt (&body);\n \n   if (CLEANUP_P (*stmt_p))\n     /* A cleanup is an expression, so it doesn't need to be genericized.  */;\n   else\n-    c_gimplify_stmt (&cleanup);\n+    gimplify_stmt (&cleanup);\n \n   *stmt_p = build (TRY_CATCH_EXPR, void_type_node, body, cleanup);\n }\n@@ -94,7 +94,7 @@ genericize_catch_block (tree *stmt_p)\n   tree type = HANDLER_TYPE (*stmt_p);\n   tree body = HANDLER_BODY (*stmt_p);\n \n-  c_gimplify_stmt (&body);\n+  gimplify_stmt (&body);\n \n   /* FIXME should the caught type go in TREE_TYPE?  */\n   *stmt_p = build (CATCH_EXPR, void_type_node, type, body);\n@@ -111,7 +111,7 @@ genericize_eh_spec_block (tree *stmt_p)\n   tree failure = build_call (call_unexpected_node,\n \t\t\t     tree_cons (NULL_TREE, build_exc_ptr (),\n \t\t\t\t\tNULL_TREE));\n-  c_gimplify_stmt (&body);\n+  gimplify_stmt (&body);\n \n   *stmt_p = gimple_build_eh_filter (body, allowed, failure);\n }\n@@ -182,16 +182,8 @@ cp_gimplify_init_expr (tree *expr_p, tree *pre_p, tree *post_p)\n   if (TREE_CODE (from) == TARGET_EXPR)\n     from = TARGET_EXPR_INITIAL (from);\n \n-  sub = from;\n-\n-  /* If we are initializing from a STMT_EXPR, extract the returned\n-     expression.  */\n-  if (TREE_CODE (from) == STMT_EXPR)\n-    sub = EXPR_STMT_EXPR (stmt_expr_last_stmt (from));\n-\n   /* Look through any COMPOUND_EXPRs.  */\n-  while (TREE_CODE (sub) == COMPOUND_EXPR)\n-    sub = TREE_OPERAND (sub, 1);\n+  sub = expr_last (from);\n \n   /* If we are initializing from an AGGR_INIT_EXPR, drop the INIT_EXPR and\n      replace the slot operand with our target.\n@@ -205,8 +197,7 @@ cp_gimplify_init_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       *expr_p = from;\n \n       /* The initialization is now a side-effect, so the container can\n-         become void.  This is important for a STMT_EXPR, so we don't try\n-         to voidify it later by creating a temporary.  */\n+         become void.  */\n       if (from != sub)\n \tTREE_TYPE (from) = void_type_node;\n     }\n@@ -218,7 +209,7 @@ static void\n gimplify_must_not_throw_expr (tree *expr_p, tree *pre_p)\n {\n   tree stmt = *expr_p;\n-  tree temp = voidify_wrapper_expr (stmt);\n+  tree temp = voidify_wrapper_expr (stmt, NULL);\n   tree body = TREE_OPERAND (stmt, 0);\n \n   gimplify_stmt (&body);"}, {"sha": "eb0e2210624431502f2bac179fafc5f74e81ef09", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -138,9 +138,6 @@ static void cxx_initialize_diagnostics (diagnostic_context *);\n #undef LANG_HOOKS_TREE_INLINING_ADD_PENDING_FN_DECLS\n #define LANG_HOOKS_TREE_INLINING_ADD_PENDING_FN_DECLS \\\n   cp_add_pending_fn_decls\n-#undef LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P\n-#define LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P \\\n-  cp_tree_chain_matters_p\n #undef LANG_HOOKS_TREE_INLINING_AUTO_VAR_IN_FN_P\n #define LANG_HOOKS_TREE_INLINING_AUTO_VAR_IN_FN_P \\\n   cp_auto_var_in_fn_p\n@@ -292,12 +289,6 @@ cp_expr_size (tree exp)\n     return lhd_expr_size (exp);\n }\n \n-int\n-cp_tree_chain_matters_p (tree t)\n-{\n-  return cp_is_overload_p (t) || c_tree_chain_matters_p (t);\n-}\n-\n /* Langhook for tree_size: determine size of our 'x' and 'c' nodes.  */\n static size_t\n cp_tree_size (enum tree_code code)"}, {"sha": "faa57e2df5e2499d10ceb5a7379fe5470b310d25", "filename": "gcc/cp/cp-mudflap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fcp-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fcp-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-mudflap.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -82,7 +82,7 @@ mflang_flush_calls (tree enqueued_call_stmt_chain)\n   mf_mark (current_function_decl);\n \n   /* Generate the body, one statement at a time.  */\n-  body = begin_compound_stmt (/*has_no_scope=*/false);\n+  body = begin_compound_stmt (BCS_FN_BODY);\n \n   while (enqueued_call_stmt_chain)\n     {"}, {"sha": "799bbcfe79dfdd971c426dff0211091442e44f5f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -48,6 +48,9 @@ struct diagnostic_context;\n       PARMLIST_ELLIPSIS_P (in PARMLIST)\n       DECL_PRETTY_FUNCTION_P (in VAR_DECL)\n       KOENIG_LOOKUP_P (in CALL_EXPR)\n+      STATEMENT_LIST_NO_SCOPE (in STATEMENT_LIST).\n+      EXPR_STMT_STMT_EXPR_RESULT (in EXPR_STMT)\n+      COMPOUND_STMT_TRY_BLOCK (in COMPOUND_STMT)\n    1: IDENTIFIER_VIRTUAL_P.\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -63,13 +66,15 @@ struct diagnostic_context;\n       BINFO_LOST_PRIMARY_P (in BINFO)\n       TREE_PARMLIST (in TREE_LIST)\n       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (in VAR_DECL)\n+      STATEMENT_LIST_TRY_BLOCK (in STATEMENT_LIST)\n    3: TYPE_USES_VIRTUAL_BASECLASSES (in a class TYPE).\n       BINFO_VTABLE_PATH_MARKED.\n       BINFO_PUSHDECLS_MARKED.\n       (TREE_REFERENCE_EXPR) (in NON_LVALUE_EXPR) (commented-out).\n       ICS_BAD_FLAG (in _CONV)\n       FN_TRY_BLOCK_P (in TRY_BLOCK)\n       IDENTIFIER_CTOR_OR_DTOR_P (in IDENTIFIER_NODE)\n+      COMPOUND_STMT_BODY_BLOCK (in COMPOUND_STMT)\n    4: BINFO_NEW_VTABLE_MARKED.\n       TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n           or FIELD_DECL).\n@@ -266,6 +271,22 @@ typedef struct ptrmem_cst * ptrmem_cst_t;\n \n #define CLEANUP_P(NODE)         TREE_LANG_FLAG_0 (TRY_BLOCK_CHECK (NODE))\n \n+#define COMPOUND_STMT_TRY_BLOCK(NODE) \\\n+  TREE_LANG_FLAG_0 (COMPOUND_STMT_CHECK (NODE))\n+\n+/* Used to mark the block around the member initializers and cleanups.  */\n+#define COMPOUND_STMT_BODY_BLOCK(NODE) \\\n+  TREE_LANG_FLAG_3 (COMPOUND_STMT_CHECK (NODE))\n+\n+#define STATEMENT_LIST_NO_SCOPE(NODE) \\\n+  TREE_LANG_FLAG_0 (STATEMENT_LIST_CHECK (NODE))\n+#define STATEMENT_LIST_TRY_BLOCK(NODE) \\\n+  TREE_LANG_FLAG_2 (STATEMENT_LIST_CHECK (NODE))\n+\n+/* Marks the result of a statement expression.  */\n+#define EXPR_STMT_STMT_EXPR_RESULT(NODE) \\\n+  TREE_LANG_FLAG_0 (EXPR_STMT_CHECK (NODE))\n+\n /* Returns nonzero iff TYPE1 and TYPE2 are the same type, in the usual\n    sense of `same'.  */\n #define same_type_p(TYPE1, TYPE2) \\\n@@ -278,7 +299,7 @@ typedef struct ptrmem_cst * ptrmem_cst_t;\n \n /* Nonzero if we are presently building a statement tree, rather\n    than expanding each statement as we encounter it.  */\n-#define building_stmt_tree() (last_tree != NULL_TREE)\n+#define building_stmt_tree()  (cur_stmt_list != NULL_TREE)\n \n /* Returns nonzero iff NODE is a declaration for the global function\n    `main'.  */\n@@ -3031,12 +3052,7 @@ typedef enum tsubst_flags_t {\n \t\t\t\t   instantiate_type use) */\n   tf_user = 1 << 5,\t\t/* found template must be a user template\n \t\t\t\t   (lookup_template_class use) */\n-  tf_stmt_expr_cmpd = 1 << 6,   /* tsubsting the compound statement of\n-\t\t\t\t   a statement expr.  */\n-  tf_stmt_expr_body = 1 << 7,   /* tsubsting the statements in the\n-\t\t\t       \t   body of the compound statement of a\n-\t\t\t       \t   statement expr.  */\n-  tf_conv = 1 << 8              /* We are determining what kind of\n+  tf_conv = 1 << 6              /* We are determining what kind of\n \t\t\t\t   conversion might be permissible,\n \t\t\t\t   not actually performing the\n \t\t\t\t   conversion.  */\n@@ -4004,9 +4020,9 @@ extern tree finish_expr_stmt                    (tree);\n extern tree begin_if_stmt                       (void);\n extern void finish_if_stmt_cond                 (tree, tree);\n extern tree finish_then_clause                  (tree);\n-extern void begin_else_clause                   (void);\n+extern void begin_else_clause\t\t\t(tree);\n extern void finish_else_clause                  (tree);\n-extern void finish_if_stmt                      (void);\n+extern void finish_if_stmt                      (tree);\n extern tree begin_while_stmt                    (void);\n extern void finish_while_stmt_cond              (tree, tree);\n extern void finish_while_stmt                   (tree);\n@@ -4040,16 +4056,23 @@ extern void finish_handler_parms                (tree, tree);\n extern void begin_catch_block                   (tree);\n extern void finish_handler                      (tree);\n extern void finish_cleanup                      (tree, tree);\n-extern tree begin_compound_stmt                 (bool);\n-extern tree finish_compound_stmt                (tree);\n+\n+enum {\n+  BCS_NO_SCOPE = 1,\n+  BCS_TRY_BLOCK = 2,\n+  BCS_FN_BODY = 4\n+};\n+extern tree begin_compound_stmt                 (unsigned int);\n+\n+extern void finish_compound_stmt                (tree);\n extern tree finish_asm_stmt                     (int, tree, tree, tree, tree);\n extern tree finish_label_stmt                   (tree);\n extern void finish_label_decl                   (tree);\n extern void finish_subobject                    (tree);\n extern tree finish_parenthesized_expr           (tree);\n extern tree finish_non_static_data_member       (tree, tree, tree);\n extern tree begin_stmt_expr                     (void);\n-extern tree finish_stmt_expr_expr \t\t(tree);\n+extern tree finish_stmt_expr_expr \t\t(tree, tree);\n extern tree finish_stmt_expr                    (tree, bool);\n extern tree perform_koenig_lookup               (tree, tree);\n extern tree finish_call_expr                    (tree, tree, bool, bool);\n@@ -4082,8 +4105,6 @@ extern void finish_decl_cleanup                 (tree, tree);\n extern void finish_eh_cleanup                   (tree);\n extern void expand_body                         (tree);\n extern void cxx_expand_function_start\t\t(void);\n-extern void do_pushlevel                        (scope_kind);\n-extern tree do_poplevel                         (void);\n extern void finish_mem_initializers             (tree);\n extern void setup_vtbl_ptr\t\t\t(tree, tree);\n extern void clear_out_block                     (void);\n@@ -4164,7 +4185,6 @@ extern tree find_tree                           (tree, tree);\n extern linkage_kind decl_linkage                (tree);\n extern tree cp_walk_subtrees (tree*, int*, walk_tree_fn,\n \t\t\t\t      void*, void*);\n-extern int cp_tree_chain_matters_p\t\t(tree);\n extern int cp_cannot_inline_tree_fn (tree*);\n extern tree cp_add_pending_fn_decls (void*,tree);\n extern int cp_is_overload_p (tree);\n@@ -4286,7 +4306,7 @@ extern bool cp_dump_tree                         (void *, tree);\n \n /* in cp-simplify.c */\n extern int cp_gimplify_expr\t\t        (tree *, tree *, tree *);\n-extern int cp_gimplify_stmt\t\t        (tree *, tree *);\n+extern int cp_gimplify_stmt\t\t        (tree *);\n \n /* -- end of C++ */\n "}, {"sha": "84ce0d74e941dd42dadae718c125684644f73349", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -429,12 +429,15 @@ poplevel (int keep, int reverse, int functionbody)\n   int tmp = functionbody;\n   int real_functionbody;\n   tree subblocks;\n-  tree block = NULL_TREE;\n+  tree block;\n   tree decl;\n   int leaving_for_scope;\n   scope_kind kind;\n \n   timevar_push (TV_NAME_LOOKUP);\n+ restart:\n+\n+  block = NULL_TREE;\n \n   my_friendly_assert (current_binding_level->kind != sk_class, 19990916);\n \n@@ -657,6 +660,17 @@ poplevel (int keep, int reverse, int functionbody)\n     }\n \n   kind = current_binding_level->kind;\n+  if (kind == sk_cleanup)\n+    {\n+      tree stmt;\n+\n+      /* If this is a temporary binding created for a cleanup, then we'll\n+\t have pushed a statement list level.  Pop that, create a new\n+\t BIND_EXPR for the block, and insert it into the stream.  */\n+      stmt = pop_stmt_list (current_binding_level->statement_list);\n+      stmt = c_build_bind_expr (block, stmt);\n+      add_stmt (stmt);\n+    }\n \n   leave_scope ();\n   if (functionbody)\n@@ -680,21 +694,9 @@ poplevel (int keep, int reverse, int functionbody)\n   if (block)\n     TREE_USED (block) = 1;\n \n-  /* Take care of compiler's internal binding structures.  */\n+  /* All temporary bindings created for cleanups are popped silently.  */\n   if (kind == sk_cleanup)\n-    {\n-      tree scope_stmts;\n-\n-      scope_stmts\n-\t= add_scope_stmt (/*begin_p=*/0, /*partial_p=*/1);\n-      if (block)\n-\t{\n-\t  SCOPE_STMT_BLOCK (TREE_PURPOSE (scope_stmts)) = block;\n-\t  SCOPE_STMT_BLOCK (TREE_VALUE (scope_stmts)) = block;\n-\t}\n-\n-      block = poplevel (keep, reverse, functionbody);\n-    }\n+    goto restart;\n \n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, block);\n }\n@@ -4938,7 +4940,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n   /* If a CLEANUP_STMT was created to destroy a temporary bound to a\n      reference, insert it in the statement-tree now.  */\n   if (cleanup)\n-    add_stmt (cleanup);\n+    push_cleanup (decl, cleanup, false);\n \n  finish_end:\n \n@@ -5174,7 +5176,7 @@ register_dtor_fn (tree decl)\n   pop_deferring_access_checks ();\n \n   /* Create the body of the anonymous function.  */\n-  compound_stmt = begin_compound_stmt (/*has_no_scope=*/false);\n+  compound_stmt = begin_compound_stmt (BCS_FN_BODY);\n   finish_expr_stmt (fcall);\n   finish_compound_stmt (compound_stmt);\n   end_cleanup_fn ();\n@@ -5252,7 +5254,7 @@ expand_static_init (tree decl, tree init)\n       /* Begin the conditional initialization.  */\n       if_stmt = begin_if_stmt ();\n       finish_if_stmt_cond (get_guard_cond (guard), if_stmt);\n-      then_clause = begin_compound_stmt (/*has_no_scope=*/false);\n+      then_clause = begin_compound_stmt (0);\n \n       /* Do the initialization itself.  */\n       assignment = init ? init : NULL_TREE;\n@@ -5278,7 +5280,7 @@ expand_static_init (tree decl, tree init)\n \n       finish_compound_stmt (then_clause);\n       finish_then_clause (if_stmt);\n-      finish_if_stmt ();\n+      finish_if_stmt (if_stmt);\n     }\n   else\n     static_aggregates = tree_cons (init, decl, static_aggregates);\n@@ -10225,7 +10227,7 @@ start_function (tree declspecs, tree declarator, tree attrs, int flags)\n   cfun->x_dont_save_pending_sizes_p = 1;\n \n   /* Start the statement-tree, start the tree now.  */\n-  begin_stmt_tree (&DECL_SAVED_TREE (decl1));\n+  DECL_SAVED_TREE (decl1) = push_stmt_list ();\n \n   /* Let the user know we're compiling this function.  */\n   announce_function (decl1);\n@@ -10486,8 +10488,7 @@ save_function_data (tree decl)\n   DECL_SAVED_FUNCTION_DATA (decl) = f;\n \n   /* Clear out the bits we don't need.  */\n-  f->base.x_stmt_tree.x_last_stmt = NULL_TREE;\n-  f->base.x_stmt_tree.x_last_expr_type = NULL_TREE;\n+  f->base.x_stmt_tree.x_cur_stmt_list = NULL_TREE;\n   f->x_named_label_uses = NULL;\n   f->bindings = NULL;\n   f->x_local_names = NULL;\n@@ -10542,7 +10543,7 @@ begin_destructor_body (void)\n      initialize the vtables.)  */\n   finish_if_stmt_cond (boolean_true_node, if_stmt);\n \n-  compound_stmt = begin_compound_stmt (/*has_no_scope=*/false);\n+  compound_stmt = begin_compound_stmt (0);\n \n   /* Make all virtual function table pointers in non-virtual base\n      classes point to CURRENT_CLASS_TYPE's virtual function\n@@ -10551,7 +10552,7 @@ begin_destructor_body (void)\n \n   finish_compound_stmt (compound_stmt);\n   finish_then_clause (if_stmt);\n-  finish_if_stmt ();\n+  finish_if_stmt (if_stmt);\n \n   /* And insert cleanups for our bases and members so that they\n      will be properly destroyed if we throw.  */\n@@ -10593,7 +10594,7 @@ finish_destructor_body (void)\n \t\t\t   if_stmt);\n       finish_expr_stmt (exprstmt);\n       finish_then_clause (if_stmt);\n-      finish_if_stmt ();\n+      finish_if_stmt (if_stmt);\n     }\n }\n \n@@ -10616,7 +10617,7 @@ begin_function_body (void)\n        operation of dwarfout.c.  */\n     keep_next_level (true);\n \n-  stmt = begin_compound_stmt (/*has_no_scope=*/false);\n+  stmt = begin_compound_stmt (BCS_FN_BODY);\n   COMPOUND_STMT_BODY_BLOCK (stmt) = 1;\n \n   if (processing_template_decl)\n@@ -10716,10 +10717,10 @@ finish_function (int flags)\n \t\t\t      current_eh_spec_block);\n     }\n \n-  finish_fname_decls ();\n-\n   /* If we're saving up tree structure, tie off the function now.  */\n-  finish_stmt_tree (&DECL_SAVED_TREE (fndecl));\n+  DECL_SAVED_TREE (fndecl) = pop_stmt_list (DECL_SAVED_TREE (fndecl));\n+\n+  finish_fname_decls ();\n \n   /* If this function can't throw any exceptions, remember that.  */\n   if (!processing_template_decl\n@@ -10773,9 +10774,10 @@ finish_function (int flags)\n \t     the function so we know that their lifetime always ends with a\n \t     return; see g++.dg/opt/nrv6.C.  We could be more flexible if\n \t     we were to do this optimization in tree-ssa.  */\n+\t  && (outer = BLOCK_SUBBLOCKS (DECL_INITIAL (fndecl)))\n \t  /* Skip the artificial function body block.  */\n-\t  && (outer = BLOCK_SUBBLOCKS (BLOCK_SUBBLOCKS (DECL_INITIAL (fndecl))),\n-\t      chain_member (r, BLOCK_VARS (outer))))\n+\t  && (outer = BLOCK_SUBBLOCKS (outer))\n+\t  && chain_member (r, BLOCK_VARS (outer)))\n \tfinalize_nrv (&DECL_SAVED_TREE (fndecl), r, DECL_RESULT (fndecl));\n \n       current_function_return_value = NULL_TREE;\n@@ -11094,10 +11096,6 @@ cxx_maybe_build_cleanup (tree decl)\n void\n finish_stmt (void)\n {\n-  /* Always assume this statement was not an expression statement.  If\n-     it actually was an expression statement, its our callers\n-     responsibility to fix this up.  */\n-  last_expr_type = NULL_TREE;\n }\n \n /* DECL was originally constructed as a non-static member function,"}, {"sha": "8157950371b5b66cea4df621dac692cbaedf0ce1", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -1970,7 +1970,7 @@ start_objects (int method_type, int initp)\n     DECL_GLOBAL_DTOR_P (current_function_decl) = 1;\n   DECL_LANG_SPECIFIC (current_function_decl)->decl_flags.u2sel = 1;\n \n-  body = begin_compound_stmt (/*has_no_scope=*/false);\n+  body = begin_compound_stmt (BCS_FN_BODY);\n \n   /* We cannot allow these functions to be elided, even if they do not\n      have external linkage.  And, there's no point in deferring\n@@ -2127,7 +2127,7 @@ start_static_storage_duration_function (unsigned count)\n \t\t  SF_PRE_PARSED);\n \n   /* Set up the scope of the outermost block in the function.  */\n-  body = begin_compound_stmt (/*has_no_scope=*/false);\n+  body = begin_compound_stmt (BCS_FN_BODY);\n \n   /* This function must not be deferred because we are depending on\n      its compilation to tell us what is TREE_SYMBOL_REFERENCED.  */\n@@ -2307,7 +2307,7 @@ static void\n finish_static_initialization_or_destruction (tree guard_if_stmt)\n {\n   finish_then_clause (guard_if_stmt);\n-  finish_if_stmt ();\n+  finish_if_stmt (guard_if_stmt);\n \n   /* Now that we're done with DECL we don't need to pretend to be a\n      member of its class any longer.  */"}, {"sha": "7e6e54e0def74cd48ab23970061145fc9635962a", "filename": "gcc/cp/except.c", "status": "modified", "additions": 45, "deletions": 34, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -37,6 +37,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"toplev.h\"\n #include \"tree-inline.h\"\n+#include \"tree-iterator.h\"\n \n static void push_eh_cleanup (tree);\n static tree prepare_eh_type (tree);\n@@ -51,7 +52,6 @@ static tree wrap_cleanups_r (tree *, int *, void *);\n static int complete_ptr_ref_or_void_ptr_p (tree, tree);\n static bool is_admissible_throw_operand (tree);\n static int can_convert_eh (tree, tree);\n-static void check_handlers_1 (tree, tree);\n static tree cp_protect_cleanup_actions (void);\n \n /* Sets up all the global eh stuff that needs to be initialized at the\n@@ -462,6 +462,7 @@ begin_eh_spec_block (void)\n {\n   tree r = build_stmt (EH_SPEC_BLOCK, NULL_TREE, NULL_TREE);\n   add_stmt (r);\n+  EH_SPEC_STMTS (r) = push_stmt_list ();\n   return r;\n }\n \n@@ -470,7 +471,7 @@ finish_eh_spec_block (tree raw_raises, tree eh_spec_block)\n {\n   tree raises;\n \n-  RECHAIN_STMTS (eh_spec_block, EH_SPEC_STMTS (eh_spec_block));\n+  EH_SPEC_STMTS (eh_spec_block) = pop_stmt_list (EH_SPEC_STMTS (eh_spec_block));\n \n   /* Strip cv quals, etc, from the specification types.  */\n   for (raises = NULL_TREE;\n@@ -874,47 +875,57 @@ can_convert_eh (tree to, tree from)\n   return 0;\n }\n \n-/* Check whether any of HANDLERS are shadowed by another handler accepting\n-   TYPE.  Note that the shadowing may not be complete; even if an exception\n-   of type B would be caught by a handler for A, there could be a derived\n-   class C for which A is an ambiguous base but B is not, so the handler\n-   for B would catch an exception of type C.  */\n+/* Check whether any of the handlers in I are shadowed by another handler\n+   accepting TYPE.  Note that the shadowing may not be complete; even if\n+   an exception of type B would be caught by a handler for A, there could\n+   be a derived class C for which A is an ambiguous base but B is not, so\n+   the handler for B would catch an exception of type C.  */\n \n static void\n-check_handlers_1 (tree master, tree handlers)\n+check_handlers_1 (tree master, tree_stmt_iterator i)\n {\n   tree type = TREE_TYPE (master);\n-  tree handler;\n \n-  for (handler = handlers; handler; handler = TREE_CHAIN (handler))\n-    if (TREE_TYPE (handler)\n-\t&& can_convert_eh (type, TREE_TYPE (handler)))\n-      {\n-\twarning (\"%Hexception of type `%T' will be caught\",\n-\t\t EXPR_LOCUS (handler), TREE_TYPE (handler));\n-\twarning (\"%H   by earlier handler for `%T'\",\n-\t\t EXPR_LOCUS (master), type);\n-\tbreak;\n-      }\n+  for (; !tsi_end_p (i); tsi_next (&i))\n+    {\n+      tree handler = tsi_stmt (i);\n+      if (TREE_TYPE (handler) && can_convert_eh (type, TREE_TYPE (handler)))\n+\t{\n+\t  warning (\"%Hexception of type `%T' will be caught\",\n+\t\t   EXPR_LOCUS (handler), TREE_TYPE (handler));\n+\t  warning (\"%H   by earlier handler for `%T'\",\n+\t\t   EXPR_LOCUS (master), type);\n+\t  break;\n+        }\n+    }\n }\n \n-/* Given a chain of HANDLERs, make sure that they're OK.  */\n+/* Given a STATEMENT_LIST of HANDLERs, make sure that they're OK.  */\n \n void\n check_handlers (tree handlers)\n {\n-  tree handler;\n-  int save_line = input_line;\n-  \n-  for (handler = handlers; handler; handler = TREE_CHAIN (handler))\n-    {\n-      if (TREE_CHAIN (handler) == NULL_TREE)\n-\t/* No more handlers; nothing to shadow.  */;\n-      else if (TREE_TYPE (handler) == NULL_TREE)\n-\tpedwarn (\"%H`...' handler must be the last handler for\"\n-\t\t \" its try block\", EXPR_LOCUS (handler));\n-      else\n-\tcheck_handlers_1 (handler, TREE_CHAIN (handler));\n-    }\n-  input_line = save_line;\n+  tree_stmt_iterator i;\n+\n+  /* If we don't have a STATEMENT_LIST, then we've just got one\n+     handler, and thus nothing to warn about.  */\n+  if (TREE_CODE (handlers) != STATEMENT_LIST)\n+    return;\n+\n+  i = tsi_start (handlers);\n+  if (!tsi_end_p (i))\n+    while (1)\n+      {\n+        tree handler = tsi_stmt (i);\n+\ttsi_next (&i);\n+\n+\t/* No more handlers; nothing to shadow.  */\n+\tif (tsi_end_p (i))\n+\t  break;\n+\tif (TREE_TYPE (handler) == NULL_TREE)\n+\t  pedwarn (\"%H`...' handler must be the last handler for\"\n+\t\t   \" its try block\", EXPR_LOCUS (handler));\n+\telse\n+\t  check_handlers_1 (handler, i);\n+      }\n }"}, {"sha": "6c886238ea59a7175161198842f5fa77136986e7", "filename": "gcc/cp/init.c", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -72,7 +72,7 @@ begin_init_stmts (tree *stmt_expr_p, tree *compound_stmt_p)\n   bool is_global = !building_stmt_tree ();\n   \n   *stmt_expr_p = begin_stmt_expr ();\n-  *compound_stmt_p = begin_compound_stmt (/*has_no_scope=*/true);\n+  *compound_stmt_p = begin_compound_stmt (BCS_NO_SCOPE);\n \n   return is_global;\n }\n@@ -826,7 +826,6 @@ static void\n construct_virtual_base (tree vbase, tree arguments)\n {\n   tree inner_if_stmt;\n-  tree compound_stmt;\n   tree exp;\n   tree flag;  \n \n@@ -847,7 +846,6 @@ construct_virtual_base (tree vbase, tree arguments)\n   flag = TREE_CHAIN (DECL_ARGUMENTS (current_function_decl));\n   inner_if_stmt = begin_if_stmt ();\n   finish_if_stmt_cond (flag, inner_if_stmt);\n-  compound_stmt = begin_compound_stmt (/*has_no_scope=*/true);\n \n   /* Compute the location of the virtual base.  If we're\n      constructing virtual bases, then we must be the most derived\n@@ -857,9 +855,8 @@ construct_virtual_base (tree vbase, tree arguments)\n \n   expand_aggr_init_1 (vbase, current_class_ref, exp, arguments, \n \t\t      LOOKUP_COMPLAIN);\n-  finish_compound_stmt (compound_stmt);\n   finish_then_clause (inner_if_stmt);\n-  finish_if_stmt ();\n+  finish_if_stmt (inner_if_stmt);\n \n   expand_cleanup_for_base (vbase, flag);\n }\n@@ -2526,7 +2523,6 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n   tree compound_stmt;\n   int destroy_temps;\n   tree try_block = NULL_TREE;\n-  tree try_body = NULL_TREE;\n   int num_initialized_elts = 0;\n   bool is_global;\n   \n@@ -2605,7 +2601,6 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n       && from_array != 2)\n     {\n       try_block = begin_try_block ();\n-      try_body = begin_compound_stmt (/*has_no_scope=*/true);\n     }\n \n   if (init != NULL_TREE && TREE_CODE (init) == CONSTRUCTOR)\n@@ -2674,7 +2669,6 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n       /* If the ITERATOR is equal to -1, then we don't have to loop;\n \t we've already initialized all the elements.  */\n       tree for_stmt;\n-      tree for_body;\n       tree elt_init;\n \n       for_stmt = begin_for_stmt ();\n@@ -2685,9 +2679,6 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n       finish_for_expr (build_unary_op (PREDECREMENT_EXPR, iterator, 0),\n \t\t       for_stmt);\n \n-      /* Otherwise, loop through the elements.  */\n-      for_body = begin_compound_stmt (/*has_no_scope=*/true);\n-\n       if (from_array)\n \t{\n \t  tree to = build1 (INDIRECT_REF, type, base);\n@@ -2727,7 +2718,6 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n       if (base2)\n \tfinish_expr_stmt (build_unary_op (PREINCREMENT_EXPR, base2, 0));\n \n-      finish_compound_stmt (for_body);\n       finish_for_stmt (for_stmt);\n     }\n \n@@ -2747,7 +2737,6 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n \t  type = strip_array_types (type);\n \t}\n \n-      finish_compound_stmt (try_body);\n       finish_cleanup_try_block (try_block);\n       e = build_vec_delete_1 (rval, m, type, sfk_base_destructor,\n \t\t\t      /*use_global_delete=*/0);\n@@ -2756,7 +2745,7 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n \n   /* The value of the array initialization is the array itself, RVAL\n      is a pointer to the first element.  */\n-  finish_stmt_expr_expr (rval);\n+  finish_stmt_expr_expr (rval, stmt_expr);\n \n   stmt_expr = finish_init_stmts (is_global, stmt_expr, compound_stmt);\n "}, {"sha": "364cc0688b3d4b73afff8914e2f9e7f4e162fc6e", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -621,7 +621,7 @@ do_build_assign_ref (tree fndecl)\n   tree parm = TREE_CHAIN (DECL_ARGUMENTS (fndecl));\n   tree compound_stmt;\n \n-  compound_stmt = begin_compound_stmt (/*has_no_scope=*/false);\n+  compound_stmt = begin_compound_stmt (0);\n   parm = convert_from_reference (parm);\n \n   if (TYPE_HAS_TRIVIAL_ASSIGN_REF (current_class_type)\n@@ -778,7 +778,7 @@ synthesize_method (tree fndecl)\n   if (need_body)\n     {\n       tree compound_stmt;\n-      compound_stmt = begin_compound_stmt (/*has_no_scope=*/false);\n+      compound_stmt = begin_compound_stmt (BCS_FN_BODY);\n       finish_compound_stmt (compound_stmt);\n     }\n "}, {"sha": "401f6505d0c63f5d379a825db4fb4ce923fb60f2", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -1433,8 +1433,8 @@ maybe_push_cleanup_level (tree type)\n       && current_binding_level->more_cleanups_ok == 0)\n     {\n       begin_scope (sk_cleanup, NULL);\n+      current_binding_level->statement_list = push_stmt_list ();\n       clear_last_expr ();\n-      add_scope_stmt (/*begin_p=*/1, /*partial_p=*/1);\n     }\n }\n "}, {"sha": "49046e893fe552410e078c961806bde4c4bb0447", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -205,6 +205,10 @@ struct cp_binding_level GTY(())\n        TREE_LIST; the TREE_VALUE is the actual declaration.  */\n     tree dead_vars_from_for;\n \n+    /* STATEMENT_LIST for statements in this binding contour.\n+       Only used at present for SK_CLEANUP temporary bindings.  */\n+    tree statement_list;\n+\n     /* Binding depth at which this level began.  */\n     int binding_depth;\n "}, {"sha": "428762cb437801a0e482005906c304d259648a92", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 41, "deletions": 49, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -1415,15 +1415,15 @@ static tree cp_parser_builtin_offsetof\n /* Statements [gram.stmt.stmt]  */\n \n static void cp_parser_statement\n-  (cp_parser *, bool);\n+  (cp_parser *, tree);\n static tree cp_parser_labeled_statement\n-  (cp_parser *, bool);\n+  (cp_parser *, tree);\n static tree cp_parser_expression_statement\n-  (cp_parser *, bool);\n+  (cp_parser *, tree);\n static tree cp_parser_compound_statement\n-  (cp_parser *, bool);\n+  (cp_parser *, tree, bool);\n static void cp_parser_statement_seq_opt\n-  (cp_parser *, bool);\n+  (cp_parser *, tree);\n static tree cp_parser_selection_statement\n   (cp_parser *);\n static tree cp_parser_condition\n@@ -2542,7 +2542,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    /* Start the statement-expression.  */\n \t    expr = begin_stmt_expr ();\n \t    /* Parse the compound-statement.  */\n-\t    cp_parser_compound_statement (parser, true);\n+\t    cp_parser_compound_statement (parser, expr, false);\n \t    /* Finish up.  */\n \t    expr = finish_stmt_expr (expr, false);\n \t  }\n@@ -5615,7 +5615,7 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n      try-block  */\n \n static void\n-cp_parser_statement (cp_parser* parser, bool in_statement_expr_p)\n+cp_parser_statement (cp_parser* parser, tree in_statement_expr)\n {\n   tree statement;\n   cp_token *token;\n@@ -5638,7 +5638,7 @@ cp_parser_statement (cp_parser* parser, bool in_statement_expr_p)\n \tcase RID_CASE:\n \tcase RID_DEFAULT:\n \t  statement = cp_parser_labeled_statement (parser,\n-\t\t\t\t\t\t   in_statement_expr_p);\n+\t\t\t\t\t\t   in_statement_expr);\n \t  break;\n \n \tcase RID_IF:\n@@ -5675,11 +5675,11 @@ cp_parser_statement (cp_parser* parser, bool in_statement_expr_p)\n \t labeled-statement.  */\n       token = cp_lexer_peek_nth_token (parser->lexer, 2);\n       if (token->type == CPP_COLON)\n-\tstatement = cp_parser_labeled_statement (parser, in_statement_expr_p);\n+\tstatement = cp_parser_labeled_statement (parser, in_statement_expr);\n     }\n   /* Anything that starts with a `{' must be a compound-statement.  */\n   else if (token->type == CPP_OPEN_BRACE)\n-    statement = cp_parser_compound_statement (parser, false);\n+    statement = cp_parser_compound_statement (parser, NULL, false);\n \n   /* Everything else must be a declaration-statement or an\n      expression-statement.  Try for the declaration-statement\n@@ -5697,7 +5697,7 @@ cp_parser_statement (cp_parser* parser, bool in_statement_expr_p)\n \t    return;\n \t}\n       /* Look for an expression-statement instead.  */\n-      statement = cp_parser_expression_statement (parser, in_statement_expr_p);\n+      statement = cp_parser_expression_statement (parser, in_statement_expr);\n     }\n \n   /* Set the line number for the statement.  */\n@@ -5724,7 +5724,7 @@ cp_parser_statement (cp_parser* parser, bool in_statement_expr_p)\n    an ordinary label, returns a LABEL_STMT.  */\n \n static tree\n-cp_parser_labeled_statement (cp_parser* parser, bool in_statement_expr_p)\n+cp_parser_labeled_statement (cp_parser* parser, tree in_statement_expr)\n {\n   cp_token *token;\n   tree statement = error_mark_node;\n@@ -5792,7 +5792,7 @@ cp_parser_labeled_statement (cp_parser* parser, bool in_statement_expr_p)\n   /* Require the `:' token.  */\n   cp_parser_require (parser, CPP_COLON, \"`:'\");\n   /* Parse the labeled statement.  */\n-  cp_parser_statement (parser, in_statement_expr_p);\n+  cp_parser_statement (parser, in_statement_expr);\n \n   /* Return the label, in the case of a `case' or `default' label.  */\n   return statement;\n@@ -5809,7 +5809,7 @@ cp_parser_labeled_statement (cp_parser* parser, bool in_statement_expr_p)\n    expression statement.  */\n \n static tree\n-cp_parser_expression_statement (cp_parser* parser, bool in_statement_expr_p)\n+cp_parser_expression_statement (cp_parser* parser, tree in_statement_expr)\n {\n   tree statement = NULL_TREE;\n \n@@ -5821,12 +5821,12 @@ cp_parser_expression_statement (cp_parser* parser, bool in_statement_expr_p)\n   /* Consume the final `;'.  */\n   cp_parser_consume_semicolon_at_end_of_statement (parser);\n \n-  if (in_statement_expr_p\n+  if (in_statement_expr\n       && cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE))\n     {\n       /* This is the final expression statement of a statement\n \t expression.  */\n-      statement = finish_stmt_expr_expr (statement);\n+      statement = finish_stmt_expr_expr (statement, in_statement_expr);\n     }\n   else if (statement)\n     statement = finish_expr_stmt (statement);\n@@ -5844,17 +5844,18 @@ cp_parser_expression_statement (cp_parser* parser, bool in_statement_expr_p)\n    Returns a COMPOUND_STMT representing the statement.  */\n \n static tree\n-cp_parser_compound_statement (cp_parser *parser, bool in_statement_expr_p)\n+cp_parser_compound_statement (cp_parser *parser, tree in_statement_expr,\n+\t\t\t      bool in_try)\n {\n   tree compound_stmt;\n \n   /* Consume the `{'.  */\n   if (!cp_parser_require (parser, CPP_OPEN_BRACE, \"`{'\"))\n     return error_mark_node;\n   /* Begin the compound-statement.  */\n-  compound_stmt = begin_compound_stmt (/*has_no_scope=*/false);\n+  compound_stmt = begin_compound_stmt (in_try ? BCS_TRY_BLOCK : 0);\n   /* Parse an (optional) statement-seq.  */\n-  cp_parser_statement_seq_opt (parser, in_statement_expr_p);\n+  cp_parser_statement_seq_opt (parser, in_statement_expr);\n   /* Finish the compound-statement.  */\n   finish_compound_stmt (compound_stmt);\n   /* Consume the `}'.  */\n@@ -5870,7 +5871,7 @@ cp_parser_compound_statement (cp_parser *parser, bool in_statement_expr_p)\n      statement-seq [opt] statement  */\n \n static void\n-cp_parser_statement_seq_opt (cp_parser* parser, bool in_statement_expr_p)\n+cp_parser_statement_seq_opt (cp_parser* parser, tree in_statement_expr)\n {\n   /* Scan statements until there aren't any more.  */\n   while (true)\n@@ -5881,7 +5882,7 @@ cp_parser_statement_seq_opt (cp_parser* parser, bool in_statement_expr_p)\n \tbreak;\n \n       /* Parse the statement.  */\n-      cp_parser_statement (parser, in_statement_expr_p);\n+      cp_parser_statement (parser, in_statement_expr);\n     }\n }\n \n@@ -5935,35 +5936,30 @@ cp_parser_selection_statement (cp_parser* parser)\n \n \tif (keyword == RID_IF)\n \t  {\n-\t    tree then_stmt;\n-\n \t    /* Add the condition.  */\n \t    finish_if_stmt_cond (condition, statement);\n \n \t    /* Parse the then-clause.  */\n-\t    then_stmt = cp_parser_implicitly_scoped_statement (parser);\n+\t    cp_parser_implicitly_scoped_statement (parser);\n \t    finish_then_clause (statement);\n \n \t    /* If the next token is `else', parse the else-clause.  */\n \t    if (cp_lexer_next_token_is_keyword (parser->lexer,\n \t\t\t\t\t\tRID_ELSE))\n \t      {\n-\t\ttree else_stmt;\n-\n \t\t/* Consume the `else' keyword.  */\n \t\tcp_lexer_consume_token (parser->lexer);\n+\t\tbegin_else_clause (statement);\n \t\t/* Parse the else-clause.  */\n-\t\telse_stmt\n-\t\t  = cp_parser_implicitly_scoped_statement (parser);\n+\t\tcp_parser_implicitly_scoped_statement (parser);\n \t\tfinish_else_clause (statement);\n \t      }\n \n \t    /* Now we're all done with the if-statement.  */\n-\t    finish_if_stmt ();\n+\t    finish_if_stmt (statement);\n \t  }\n \telse\n \t  {\n-\t    tree body;\n \t    bool in_switch_statement_p;\n \n \t    /* Add the condition.  */\n@@ -5972,7 +5968,7 @@ cp_parser_selection_statement (cp_parser* parser)\n \t    /* Parse the body of the switch-statement.  */\n \t    in_switch_statement_p = parser->in_switch_statement_p;\n \t    parser->in_switch_statement_p = true;\n-\t    body = cp_parser_implicitly_scoped_statement (parser);\n+\t    cp_parser_implicitly_scoped_statement (parser);\n \t    parser->in_switch_statement_p = in_switch_statement_p;\n \n \t    /* Now we're all done with the switch-statement.  */\n@@ -6365,15 +6361,15 @@ cp_parser_implicitly_scoped_statement (cp_parser* parser)\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_BRACE))\n     {\n       /* Create a compound-statement.  */\n-      statement = begin_compound_stmt (/*has_no_scope=*/false);\n+      statement = begin_compound_stmt (0);\n       /* Parse the dependent-statement.  */\n       cp_parser_statement (parser, false);\n       /* Finish the dummy compound-statement.  */\n       finish_compound_stmt (statement);\n     }\n   /* Otherwise, we simply parse the statement directly.  */\n   else\n-    statement = cp_parser_compound_statement (parser, false);\n+    statement = cp_parser_compound_statement (parser, NULL, false);\n \n   /* Return the statement.  */\n   return statement;\n@@ -6387,21 +6383,17 @@ cp_parser_implicitly_scoped_statement (cp_parser* parser)\n static void\n cp_parser_already_scoped_statement (cp_parser* parser)\n {\n-  /* If the token is not a `{', then we must take special action.  */\n-  if (cp_lexer_next_token_is_not(parser->lexer, CPP_OPEN_BRACE))\n+  /* If the token is a `{', then we must take special action.  */\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_BRACE))\n+    cp_parser_statement (parser, false);\n+  else\n     {\n-      tree statement;\n-\n-      /* Create a compound-statement.  */\n-      statement = begin_compound_stmt (/*has_no_scope=*/true);\n-      /* Parse the dependent-statement.  */\n-      cp_parser_statement (parser, false);\n-      /* Finish the dummy compound-statement.  */\n-      finish_compound_stmt (statement);\n+      /* Avoid calling cp_parser_compound_statement, so that we\n+\t don't create a new scope.  Do everything else by hand.  */\n+      cp_parser_require (parser, CPP_OPEN_BRACE, \"`{'\");\n+      cp_parser_statement_seq_opt (parser, false);\n+      cp_parser_require (parser, CPP_CLOSE_BRACE, \"`}'\");\n     }\n-  /* Otherwise, we simply parse the statement directly.  */\n-  else\n-    cp_parser_statement (parser, false);\n }\n \n /* Declarations [gram.dcl.dcl] */\n@@ -11618,7 +11610,7 @@ cp_parser_parameter_declaration (cp_parser *parser,\n static void\n cp_parser_function_body (cp_parser *parser)\n {\n-  cp_parser_compound_statement (parser, false);\n+  cp_parser_compound_statement (parser, NULL, false);\n }\n \n /* Parse a ctor-initializer-opt followed by a function-body.  Return\n@@ -13265,7 +13257,7 @@ cp_parser_try_block (cp_parser* parser)\n \n   cp_parser_require_keyword (parser, RID_TRY, \"`try'\");\n   try_block = begin_try_block ();\n-  cp_parser_compound_statement (parser, false);\n+  cp_parser_compound_statement (parser, NULL, true);\n   finish_try_block (try_block);\n   cp_parser_handler_seq (parser);\n   finish_handler_sequence (try_block);\n@@ -13341,7 +13333,7 @@ cp_parser_handler (cp_parser* parser)\n   declaration = cp_parser_exception_declaration (parser);\n   finish_handler_parms (declaration, handler);\n   cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n-  cp_parser_compound_statement (parser, false);\n+  cp_parser_compound_statement (parser, NULL, false);\n   finish_handler (handler);\n }\n "}, {"sha": "c93184aa0c771518f1e68a3f03cbdb2a28cfd68a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -42,6 +42,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"rtl.h\"\n #include \"timevar.h\"\n+#include \"tree-iterator.h\"\n \n /* The type of functions taking a tree, and some additional data, and\n    returning an int.  */\n@@ -7615,22 +7616,6 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t\t\t    in_decl),\n \t\t       NULL_TREE);\n \n-    case STMT_EXPR:\n-      /* This processing should really occur in tsubst_expr.  However,\n-\t tsubst_expr does not recurse into expressions, since it\n-\t assumes that there aren't any statements inside them.  So, we\n-\t need to expand the STMT_EXPR here.  */\n-      if (!processing_template_decl)\n-\t{\n-\t  tree stmt_expr = begin_stmt_expr ();\n-\t  \n-\t  tsubst_expr (STMT_EXPR_STMT (t), args,\n-\t\t       complain | tf_stmt_expr_cmpd, in_decl);\n-\t  return finish_stmt_expr (stmt_expr, false);\n-\t}\n-      \n-      return t;\n-\n     case COND_EXPR:\n     case MODOP_EXPR:\n     case PSEUDO_DTOR_EXPR:\n@@ -7752,20 +7737,26 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n static tree\n tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n {\n+  /* Live only within one (recursive) call to tsubst_expr.  We use\n+     this to pass the statement expression node from the STMT_EXPR\n+     to the EXPR_STMT that is its result.  */\n+  static tree cur_stmt_expr;\n+\n   tree stmt, tmp;\n-  tsubst_flags_t stmt_expr\n-    = complain & (tf_stmt_expr_cmpd | tf_stmt_expr_body);\n \n-  complain ^= stmt_expr;\n   if (t == NULL_TREE || t == error_mark_node)\n     return t;\n \n-  if (!STATEMENT_CODE_P (TREE_CODE (t)))\n-    return tsubst_copy_and_build (t, args, complain, in_decl,\n-\t\t\t\t  /*function_p=*/false);\n-    \n   switch (TREE_CODE (t))\n     {\n+    case STATEMENT_LIST:\n+      {\n+\ttree_stmt_iterator i;\n+\tfor (i = tsi_start (t); !tsi_end_p (i); tsi_next (&i))\n+\t  tsubst_expr (tsi_stmt (i), args, complain, in_decl);\n+\tbreak;\n+      }\n+\n     case CTOR_INITIALIZER:\n       prep_stmt (t);\n       finish_mem_initializers (tsubst_initializer_list \n@@ -7778,15 +7769,28 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t\t\t       args, complain, in_decl));\n       break;\n \n+    case STMT_EXPR:\n+      {\n+\ttree old_stmt_expr = cur_stmt_expr;\n+\ttree stmt_expr = begin_stmt_expr ();\n+\n+\tcur_stmt_expr = stmt_expr;\n+\ttsubst_expr (STMT_EXPR_STMT (t), args, complain, in_decl);\n+\tstmt_expr = finish_stmt_expr (stmt_expr, false);\n+\tcur_stmt_expr = old_stmt_expr;\n+\n+\treturn stmt_expr;\n+      }\n+\n     case EXPR_STMT:\n       {\n \ttree r;\n \t\n \tprep_stmt (t);\n \n \tr = tsubst_expr (EXPR_STMT_EXPR (t), args, complain, in_decl);\n-\tif (stmt_expr & tf_stmt_expr_body && !TREE_CHAIN (t))\n-\t  finish_stmt_expr_expr (r);\n+\tif (EXPR_STMT_STMT_EXPR_RESULT (t))\n+\t  finish_stmt_expr_expr (r, cur_stmt_expr);\n \telse\n \t  finish_expr_stmt (r);\n \tbreak;\n@@ -7861,12 +7865,9 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  }\n \n \t/* A DECL_STMT can also be used as an expression, in the condition\n-\t   clause of an if/for/while construct.  If we aren't followed by\n-\t   another statement, return our decl.  */\n-\tif (TREE_CHAIN (t) == NULL_TREE)\n-\t  return decl;\n+\t   clause of an if/for/while construct.  */\n+\treturn decl;\n       }\n-      break;\n \n     case FOR_STMT:\n       {\n@@ -7916,21 +7917,17 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tfinish_if_stmt_cond (tsubst_expr (IF_COND (t),\n \t\t\t\t\t  args, complain, in_decl),\n \t\t\t     stmt);\n+\ttsubst_expr (THEN_CLAUSE (t), args, complain, in_decl);\n+\tfinish_then_clause (stmt);\n \n-\tif (tmp = THEN_CLAUSE (t), tmp)\n-\t  {\n-\t    tsubst_expr (tmp, args, complain, in_decl);\n-\t    finish_then_clause (stmt);\n-\t  }\n-\n-\tif (tmp = ELSE_CLAUSE (t), tmp)\n+\tif (ELSE_CLAUSE (t))\n \t  {\n-\t    begin_else_clause ();\n-\t    tsubst_expr (tmp, args, complain, in_decl);\n+\t    begin_else_clause (stmt);\n+\t    tsubst_expr (ELSE_CLAUSE (t), args, complain, in_decl);\n \t    finish_else_clause (stmt);\n \t  }\n \n-\tfinish_if_stmt ();\n+\tfinish_if_stmt (stmt);\n       }\n       break;\n \n@@ -7940,11 +7937,10 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tif (COMPOUND_STMT_BODY_BLOCK (t))\n \t  stmt = begin_function_body ();\n \telse\n-\t  stmt = begin_compound_stmt (COMPOUND_STMT_NO_SCOPE (t));\n+\t  stmt = begin_compound_stmt (COMPOUND_STMT_TRY_BLOCK (t)\n+\t\t\t\t      ? BCS_TRY_BLOCK : 0);\n \n-\ttsubst_expr (COMPOUND_BODY (t), args,\n-\t\t     complain | ((stmt_expr & tf_stmt_expr_cmpd) << 1),\n-\t\t     in_decl);\n+\ttsubst_expr (COMPOUND_BODY (t), args, complain, in_decl);\n \n \tif (COMPOUND_STMT_BODY_BLOCK (t))\n \t  finish_function_body (stmt);\n@@ -8053,7 +8049,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tstmt = begin_handler ();\n \tif (HANDLER_PARMS (t))\n \t  {\n-\t    decl = DECL_STMT_DECL (HANDLER_PARMS (t));\n+\t    decl = HANDLER_PARMS (t);\n \t    decl = tsubst (decl, args, complain, in_decl);\n \t    /* Prevent instantiate_decl from trying to instantiate\n \t       this variable.  We've already done all that needs to be\n@@ -8074,10 +8070,13 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       break;\n \n     default:\n+      if (!STATEMENT_CODE_P (TREE_CODE (t)))\n+\treturn tsubst_copy_and_build (t, args, complain, in_decl,\n+\t\t\t\t      /*function_p=*/false);\n       abort ();\n     }\n \n-  return tsubst_expr (TREE_CHAIN (t), args, complain | stmt_expr, in_decl);\n+  return NULL_TREE;\n }\n \n /* T is a postfix-expression that is not being used in a function"}, {"sha": "eeb66c5955949a5c8dfa7a42d933a92812afc75a", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 257, "deletions": 239, "changes": 496, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -44,6 +44,7 @@\n #include \"debug.h\"\n #include \"diagnostic.h\"\n #include \"cgraph.h\"\n+#include \"tree-iterator.h\"\n \n /* There routines provide a modular interface to perform many parsing\n    operations.  They may therefore be used during actual parsing, or\n@@ -60,23 +61,6 @@ static void emit_associated_thunks (tree);\n static tree finalize_nrv_r (tree *, int *, void *);\n \n \n-/* Finish processing the COND, the SUBSTMT condition for STMT.  */\n-\n-#define FINISH_COND(COND, STMT, SUBSTMT) \t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    if (last_tree != (STMT))\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-        RECHAIN_STMTS (STMT, SUBSTMT);\t\t\t\\\n-        if (!processing_template_decl)\t\t\t\\\n-          {\t\t\t\t\t\t\\\n-\t    (COND) = build_tree_list (SUBSTMT, COND);\t\\\n-\t    (SUBSTMT) = (COND);\t\t\t\t\\\n-          }\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\\\n-      (SUBSTMT) = (COND);\t\t\t\t\\\n-  } while (0)\n-\n /* Deferred Access Checking Overview\n    ---------------------------------\n \n@@ -332,45 +316,99 @@ anon_aggr_type_p (tree node)\n \n /* Finish a scope.  */\n \n-tree\n-do_poplevel (void)\n+static tree\n+do_poplevel (tree stmt_list)\n {\n-  tree block = NULL_TREE;\n+  tree block = NULL;\n \n   if (stmts_are_full_exprs_p ())\n-    {\n-      tree scope_stmts = NULL_TREE;\n+    block = poplevel (kept_level_p (), 1, 0);\n \n-      block = poplevel (kept_level_p (), 1, 0);\n-      if (!processing_template_decl)\n-\t{\n-\t  /* This needs to come after the poplevel so that partial scopes\n-\t     are properly nested.  */\n-\t  scope_stmts = add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0);\n-\t  if (block)\n-\t    {\n-\t      SCOPE_STMT_BLOCK (TREE_PURPOSE (scope_stmts)) = block;\n-\t      SCOPE_STMT_BLOCK (TREE_VALUE (scope_stmts)) = block;\n-\t    }\n-\t}\n+  stmt_list = pop_stmt_list (stmt_list);\n+  \n+  if (!processing_template_decl)\n+    {\n+      stmt_list = c_build_bind_expr (block, stmt_list);\n+      /* ??? See c_end_compound_stmt re statement expressions.  */\n     }\n \n-  return block;\n+  return stmt_list;\n }\n \n /* Begin a new scope.  */ \n \n-void\n+static tree\n do_pushlevel (scope_kind sk)\n {\n+  tree ret = push_stmt_list ();\n   if (stmts_are_full_exprs_p ())\n+    begin_scope (sk, NULL);\n+  return ret;\n+}\n+\n+/* Finish processing a conditional.  COND contains the raw expression;\n+   STMT_P is a stacked statement list that will contain any other stmts\n+   emitting during the processing of this conditional.  Place the \n+   resulting conditional back in STMT_P.  */\n+\n+static void\n+finish_cond (tree cond, tree *stmt_p)\n+{\n+  tree stmt = *stmt_p;\n+  stmt = pop_stmt_list (stmt);\n+  if (TREE_SIDE_EFFECTS (stmt))\n+    {\n+      /* If stmt is set, it will be a DECL_STMT.  When processing a template, \n+\t using this is enough, because tsubst_expr considers the result of a\n+\t DECL_STMT to be the DECL.  When generating real code, we build a\n+\t funny little TREE_LIST thingy that's handled by the gimplifier.  */\n+      /* ??? The object of this thingy is to get the DECL declared in the\n+\t proper scope.  Seems like this oughtn't be terribly hard with the\n+\t new explicit uses of BIND_EXPR and such.  */\n+      if (processing_template_decl)\n+\t{\n+\t  stmt = expr_only (stmt);\n+\t  if (!stmt)\n+\t    abort ();\n+\t}\n+      else\n+        stmt = build_tree_list (stmt, cond);\n+    }\n+  else\n+    stmt = cond;\n+  *stmt_p = stmt;\n+}\n+\n+/* If *COND_P specifies a conditional with a declaration, transform the\n+   loop such that\n+\t    while (A x = 42) { }\n+\t    for (; A x = 42;) { }\n+   becomes\n+\t    while (true) { A x = 42; if (!x) break; }\n+\t    for (;;) { A x = 42; if (!x) break; }\n+   The statement list for the loop body should have been pushed.  */\n+\n+static void\n+simplify_loop_decl_cond (tree *cond_p)\n+{\n+  tree cond = *cond_p;\n+  if (TREE_CODE (cond) == TREE_LIST)\n     {\n-      if (!processing_template_decl)\n-\tadd_scope_stmt (/*begin_p=*/1, /*partial_p=*/0);\n-      begin_scope (sk, NULL);\n+      tree if_stmt;\n+\n+      *cond_p = boolean_true_node;\n+  \n+      if_stmt = begin_if_stmt ();\n+      add_stmt (TREE_PURPOSE (cond));\n+      cond = build_unary_op (TRUTH_NOT_EXPR, TREE_VALUE (cond), 0);\n+      finish_if_stmt_cond (cond, if_stmt);\n+      finish_break_stmt ();\n+      finish_then_clause (if_stmt);\n+      finish_if_stmt (if_stmt);\n     }\n }\n \n+\n /* Finish a goto-statement.  */\n \n tree\n@@ -432,8 +470,12 @@ finish_expr_stmt (tree expr)\n \texpr = convert_to_void (expr, \"statement\");\n       else if (!type_dependent_expression_p (expr))\n \tconvert_to_void (build_non_dependent_expr (expr), \"statement\");\n-      \n-      r = add_stmt (build_stmt (EXPR_STMT, expr));\n+\n+      /* Simplification of inner statement expressions, compound exprs,\n+\t etc can result in the us already having an EXPR_STMT.  */\n+      if (TREE_CODE (expr) != EXPR_STMT)\n+\texpr = build_stmt (EXPR_STMT, expr);\n+      r = add_stmt (expr);\n     }\n \n   finish_stmt ();\n@@ -448,10 +490,12 @@ finish_expr_stmt (tree expr)\n tree\n begin_if_stmt (void)\n {\n-  tree r;\n-  do_pushlevel (sk_block);\n+  tree r, scope;\n+  scope = do_pushlevel (sk_block);\n   r = build_stmt (IF_STMT, NULL_TREE, NULL_TREE, NULL_TREE);\n+  TREE_CHAIN (r) = scope;\n   add_stmt (r);\n+  IF_COND (r) = push_stmt_list ();\n   return r;\n }\n \n@@ -462,7 +506,8 @@ void\n finish_if_stmt_cond (tree cond, tree if_stmt)\n {\n   cond = maybe_convert_cond (cond);\n-  FINISH_COND (cond, if_stmt, IF_COND (if_stmt));\n+  finish_cond (cond, &IF_COND (if_stmt));\n+  THEN_CLAUSE (if_stmt) = push_stmt_list ();\n }\n \n /* Finish the then-clause of an if-statement, which may be given by\n@@ -471,15 +516,16 @@ finish_if_stmt_cond (tree cond, tree if_stmt)\n tree\n finish_then_clause (tree if_stmt)\n {\n-  RECHAIN_STMTS (if_stmt, THEN_CLAUSE (if_stmt));\n+  THEN_CLAUSE (if_stmt) = pop_stmt_list (THEN_CLAUSE (if_stmt));\n   return if_stmt;\n }\n \n /* Begin the else-clause of an if-statement.  */\n \n-void \n-begin_else_clause (void)\n+void\n+begin_else_clause (tree if_stmt)\n {\n+  ELSE_CLAUSE (if_stmt) = push_stmt_list ();\n }\n \n /* Finish the else-clause of an if-statement, which may be given by\n@@ -488,16 +534,18 @@ begin_else_clause (void)\n void\n finish_else_clause (tree if_stmt)\n {\n-  RECHAIN_STMTS (if_stmt, ELSE_CLAUSE (if_stmt));\n+  ELSE_CLAUSE (if_stmt) = pop_stmt_list (ELSE_CLAUSE (if_stmt));\n }\n \n /* Finish an if-statement.  */\n \n void \n-finish_if_stmt (void)\n+finish_if_stmt (tree if_stmt)\n {\n+  tree scope = TREE_CHAIN (if_stmt);\n+  TREE_CHAIN (if_stmt) = NULL;\n+  add_stmt (do_poplevel (scope));\n   finish_stmt ();\n-  do_poplevel ();\n }\n \n /* Begin a while-statement.  Returns a newly created WHILE_STMT if\n@@ -509,7 +557,8 @@ begin_while_stmt (void)\n   tree r;\n   r = build_stmt (WHILE_STMT, NULL_TREE, NULL_TREE);\n   add_stmt (r);\n-  do_pushlevel (sk_block);\n+  WHILE_BODY (r) = do_pushlevel (sk_block);\n+  WHILE_COND (r) = push_stmt_list ();\n   return r;\n }\n \n@@ -520,38 +569,16 @@ void\n finish_while_stmt_cond (tree cond, tree while_stmt)\n {\n   cond = maybe_convert_cond (cond);\n-  if (processing_template_decl)\n-    /* Don't mess with condition decls in a template.  */\n-    FINISH_COND (cond, while_stmt, WHILE_COND (while_stmt));\n-  else if (getdecls () == NULL_TREE)\n-    /* It was a simple condition; install it.  */\n-    WHILE_COND (while_stmt) = cond;\n-  else\n-    {\n-      /* If there was a declaration in the condition, we can't leave it\n-\t there; transform\n-\t    while (A x = 42) { }\n-\t to\n-\t    while (true) { A x = 42; if (!x) break; }  */\n-      tree if_stmt;\n-      WHILE_COND (while_stmt) = boolean_true_node;\n-\n-      if_stmt = begin_if_stmt ();\n-      cond = build_unary_op (TRUTH_NOT_EXPR, cond, 0);\n-      finish_if_stmt_cond (cond, if_stmt);\n-      finish_break_stmt ();\n-      finish_then_clause (if_stmt);\n-      finish_if_stmt ();\n-    }\n+  finish_cond (cond, &WHILE_COND (while_stmt));\n+  simplify_loop_decl_cond (&WHILE_COND (while_stmt));\n }\n \n /* Finish a while-statement, which may be given by WHILE_STMT.  */\n \n void \n finish_while_stmt (tree while_stmt)\n {\n-  do_poplevel ();\n-  RECHAIN_STMTS (while_stmt, WHILE_BODY (while_stmt));\n+  WHILE_BODY (while_stmt) = do_poplevel (WHILE_BODY (while_stmt));\n   finish_stmt ();\n }\n \n@@ -563,6 +590,7 @@ begin_do_stmt (void)\n {\n   tree r = build_stmt (DO_STMT, NULL_TREE, NULL_TREE);\n   add_stmt (r);\n+  DO_BODY (r) = push_stmt_list ();\n   return r;\n }\n \n@@ -571,7 +599,7 @@ begin_do_stmt (void)\n void\n finish_do_body (tree do_stmt)\n {\n-  RECHAIN_STMTS (do_stmt, DO_BODY (do_stmt));\n+  DO_BODY (do_stmt) = pop_stmt_list (DO_BODY (do_stmt));\n }\n \n /* Finish a do-statement, which may be given by DO_STMT, and whose\n@@ -620,10 +648,9 @@ begin_for_stmt (void)\n \n   r = build_stmt (FOR_STMT, NULL_TREE, NULL_TREE, \n \t\t  NULL_TREE, NULL_TREE);\n-  NEW_FOR_SCOPE_P (r) = flag_new_for_scope > 0;\n-  if (NEW_FOR_SCOPE_P (r))\n-    do_pushlevel (sk_for);\n-  add_stmt (r);\n+\n+  if (flag_new_for_scope > 0)\n+    TREE_CHAIN (r) = do_pushlevel (sk_for);\n \n   return r;\n }\n@@ -634,9 +661,9 @@ begin_for_stmt (void)\n void\n finish_for_init_stmt (tree for_stmt)\n {\n-  if (last_tree != for_stmt)\n-    RECHAIN_STMTS (for_stmt, FOR_INIT_STMT (for_stmt));\n-  do_pushlevel (sk_block);\n+  add_stmt (for_stmt);\n+  FOR_BODY (for_stmt) = do_pushlevel (sk_block);\n+  FOR_COND (for_stmt) = push_stmt_list ();\n }\n \n /* Finish the COND of a for-statement, which may be given by\n@@ -646,29 +673,9 @@ void\n finish_for_cond (tree cond, tree for_stmt)\n {\n   cond = maybe_convert_cond (cond);\n-  if (processing_template_decl)\n-    /* Don't mess with condition decls in a template.  */\n-    FINISH_COND (cond, for_stmt, FOR_COND (for_stmt));\n-  else if (getdecls () == NULL_TREE)\n-    /* It was a simple condition; install it.  */\n-    FOR_COND (for_stmt) = cond;\n-  else\n-    {\n-      /* If there was a declaration in the condition, we can't leave it\n-\t there; transform\n-\t    for (; A x = 42;) { }\n-\t to\n-\t    for (;;) { A x = 42; if (!x) break; }  */\n-      tree if_stmt;\n-      FOR_COND (for_stmt) = NULL_TREE;\n-\n-      if_stmt = begin_if_stmt ();\n-      cond = build_unary_op (TRUTH_NOT_EXPR, cond, 0);\n-      finish_if_stmt_cond (cond, if_stmt);\n-      finish_break_stmt ();\n-      finish_then_clause (if_stmt);\n-      finish_if_stmt ();\n-    }\n+  finish_cond (cond, &FOR_COND (for_stmt));\n+  if (FOR_COND (for_stmt))\n+    simplify_loop_decl_cond (&FOR_COND (for_stmt));\n }\n \n /* Finish the increment-EXPRESSION in a for-statement, which may be\n@@ -694,11 +701,16 @@ finish_for_expr (tree expr, tree for_stmt)\n void\n finish_for_stmt (tree for_stmt)\n {\n+  FOR_BODY (for_stmt) = do_poplevel (FOR_BODY (for_stmt));\n+\n   /* Pop the scope for the body of the loop.  */\n-  do_poplevel ();\n-  RECHAIN_STMTS (for_stmt, FOR_BODY (for_stmt));\n-  if (NEW_FOR_SCOPE_P (for_stmt))\n-    do_poplevel ();\n+  if (flag_new_for_scope > 0)\n+    {\n+      tree scope = TREE_CHAIN (for_stmt);\n+      TREE_CHAIN (for_stmt) = NULL;\n+      add_stmt (do_poplevel (scope));\n+    }\n+\n   finish_stmt (); \n }\n \n@@ -724,10 +736,16 @@ finish_continue_stmt (void)\n tree\n begin_switch_stmt (void)\n {\n-  tree r;\n-  do_pushlevel (sk_block);\n+  tree r, scope;\n+\n   r = build_stmt (SWITCH_STMT, NULL_TREE, NULL_TREE, NULL_TREE);\n+\n+  scope = do_pushlevel (sk_block);\n+  TREE_CHAIN (r) = scope;\n+\n   add_stmt (r);\n+  SWITCH_COND (r) = push_stmt_list ();\n+\n   return r;\n }\n \n@@ -770,9 +788,10 @@ finish_switch_cond (tree cond, tree switch_stmt)\n \t    cond = index;\n \t}\n     }\n-  FINISH_COND (cond, switch_stmt, SWITCH_COND (switch_stmt));\n+  finish_cond (cond, &SWITCH_COND (switch_stmt));\n   SWITCH_TYPE (switch_stmt) = orig_type;\n   push_switch (switch_stmt);\n+  SWITCH_BODY (switch_stmt) = push_stmt_list ();\n }\n \n /* Finish the body of a switch-statement, which may be given by\n@@ -781,10 +800,15 @@ finish_switch_cond (tree cond, tree switch_stmt)\n void\n finish_switch_stmt (tree switch_stmt)\n {\n-  RECHAIN_STMTS (switch_stmt, SWITCH_BODY (switch_stmt));\n+  tree scope;\n+\n+  SWITCH_BODY (switch_stmt) = pop_stmt_list (SWITCH_BODY (switch_stmt));\n   pop_switch (); \n   finish_stmt ();\n-  do_poplevel ();\n+\n+  scope = TREE_CHAIN (switch_stmt);\n+  TREE_CHAIN (switch_stmt) = NULL;\n+  add_stmt (do_poplevel (scope));\n }\n \n /* Begin a try-block.  Returns a newly-created TRY_BLOCK if\n@@ -795,6 +819,7 @@ begin_try_block (void)\n {\n   tree r = build_stmt (TRY_BLOCK, NULL_TREE, NULL_TREE);\n   add_stmt (r);\n+  TRY_STMTS (r) = push_stmt_list ();\n   return r;\n }\n \n@@ -803,9 +828,8 @@ begin_try_block (void)\n tree\n begin_function_try_block (void)\n {\n-  tree r = build_stmt (TRY_BLOCK, NULL_TREE, NULL_TREE);\n+  tree r = begin_try_block ();\n   FN_TRY_BLOCK_P (r) = 1;\n-  add_stmt (r);\n   return r;\n }\n \n@@ -814,7 +838,8 @@ begin_function_try_block (void)\n void\n finish_try_block (tree try_block)\n {\n-  RECHAIN_STMTS (try_block, TRY_STMTS (try_block));\n+  TRY_STMTS (try_block) = pop_stmt_list (TRY_STMTS (try_block));\n+  TRY_HANDLERS (try_block) = push_stmt_list ();\n }\n \n /* Finish the body of a cleanup try-block, which may be given by\n@@ -823,7 +848,7 @@ finish_try_block (tree try_block)\n void\n finish_cleanup_try_block (tree try_block)\n {\n-  RECHAIN_STMTS (try_block, TRY_STMTS (try_block));\n+  TRY_STMTS (try_block) = pop_stmt_list (TRY_STMTS (try_block));\n }\n \n /* Finish an implicitly generated try-block, with a cleanup is given\n@@ -841,16 +866,9 @@ finish_cleanup (tree cleanup, tree try_block)\n void\n finish_function_try_block (tree try_block)\n {\n-  if (TREE_CHAIN (try_block) \n-      && TREE_CODE (TREE_CHAIN (try_block)) == CTOR_INITIALIZER)\n-    {\n-      /* Chain the compound statement after the CTOR_INITIALIZER.  */\n-      TREE_CHAIN (TREE_CHAIN (try_block)) = last_tree;\n-      /* And make the CTOR_INITIALIZER the body of the try-block.  */\n-      RECHAIN_STMTS (try_block, TRY_STMTS (try_block));\n-    }\n-  else\n-    RECHAIN_STMTS (try_block, TRY_STMTS (try_block));\n+  finish_try_block (try_block);\n+  /* FIXME : something queer about CTOR_INITIALIZER somehow following\n+     the try block, but moving it inside.  */\n   in_function_try_handler = 1;\n }\n \n@@ -860,7 +878,7 @@ finish_function_try_block (tree try_block)\n void\n finish_handler_sequence (tree try_block)\n {\n-  RECHAIN_STMTS (try_block, TRY_HANDLERS (try_block));\n+  TRY_HANDLERS (try_block) = pop_stmt_list (TRY_HANDLERS (try_block));\n   check_handlers (TRY_HANDLERS (try_block));\n }\n \n@@ -870,8 +888,7 @@ void\n finish_function_handler_sequence (tree try_block)\n {\n   in_function_try_handler = 0;\n-  RECHAIN_STMTS (try_block, TRY_HANDLERS (try_block));\n-  check_handlers (TRY_HANDLERS (try_block));\n+  finish_handler_sequence (try_block);\n }\n \n /* Begin a handler.  Returns a HANDLER if appropriate.  */\n@@ -880,11 +897,14 @@ tree\n begin_handler (void)\n {\n   tree r;\n+\n   r = build_stmt (HANDLER, NULL_TREE, NULL_TREE);\n   add_stmt (r);\n+\n   /* Create a binding level for the eh_info and the exception object\n      cleanup.  */\n-  do_pushlevel (sk_catch);\n+  HANDLER_BODY (r) = do_pushlevel (sk_catch);\n+\n   return r;\n }\n \n@@ -902,8 +922,7 @@ finish_handler_parms (tree decl, tree handler)\n \t{\n \t  decl = pushdecl (decl);\n \t  decl = push_template_decl (decl);\n-\t  add_decl_stmt (decl);\n-\t  RECHAIN_STMTS (handler, HANDLER_PARMS (handler));\n+\t  HANDLER_PARMS (handler) = decl;\n \t  type = TREE_TYPE (decl);\n \t}\n     }\n@@ -923,67 +942,58 @@ finish_handler (tree handler)\n {\n   if (!processing_template_decl)\n     expand_end_catch_block ();\n-  do_poplevel ();\n-  RECHAIN_STMTS (handler, HANDLER_BODY (handler));\n+  HANDLER_BODY (handler) = do_poplevel (HANDLER_BODY (handler));\n }\n \n /* Begin a compound-statement.  If HAS_NO_SCOPE is true, the\n    compound-statement does not define a scope.  Returns a new\n    COMPOUND_STMT.  */\n \n tree\n-begin_compound_stmt (bool has_no_scope)\n+begin_compound_stmt (unsigned int flags)\n {\n-  tree r; \n-  int is_try = 0;\n-\n-  r = build_stmt (COMPOUND_STMT, NULL_TREE);\n-\n-  if (last_tree && TREE_CODE (last_tree) == TRY_BLOCK)\n-    is_try = 1;\n-\n-  add_stmt (r);\n-  if (has_no_scope)\n-    COMPOUND_STMT_NO_SCOPE (r) = 1;\n+  tree r;\n \n-  last_expr_type = NULL_TREE;\n+  if (flags & BCS_NO_SCOPE)\n+    {\n+      r = push_stmt_list ();\n+      STATEMENT_LIST_NO_SCOPE (r) = 1;\n \n-  if (!has_no_scope)\n-    do_pushlevel (is_try ? sk_try : sk_block);\n+      /* Normally, we try hard to keep the BLOCK for a statement-expression.\n+\t But, if it's a statement-expression with a scopeless block, there's\n+\t nothing to keep, and we don't want to accidentally keep a block\n+\t *inside* the scopeless block.  */ \n+      keep_next_level (false);\n+    }\n   else\n-    /* Normally, we try hard to keep the BLOCK for a\n-       statement-expression.  But, if it's a statement-expression with\n-       a scopeless block, there's nothing to keep, and we don't want\n-       to accidentally keep a block *inside* the scopeless block.  */ \n-    keep_next_level (false);\n+    r = do_pushlevel (flags & BCS_TRY_BLOCK ? sk_try : sk_block);\n+\n+  if (flags & BCS_FN_BODY || processing_template_decl)\n+    {\n+      r = build (COMPOUND_STMT, NULL_TREE, r);\n+      COMPOUND_STMT_TRY_BLOCK (r) = (flags & BCS_TRY_BLOCK) != 0;\n+      COMPOUND_STMT_BODY_BLOCK (r) = (flags & BCS_FN_BODY) != 0;\n+      TREE_SIDE_EFFECTS (r) = 1;\n+    }\n \n   return r;\n }\n \n /* Finish a compound-statement, which is given by COMPOUND_STMT.  */\n \n-tree\n-finish_compound_stmt (tree compound_stmt)\n+void\n+finish_compound_stmt (tree stmt)\n {\n-  tree r;\n-  tree t;\n-\n-  if (COMPOUND_STMT_NO_SCOPE (compound_stmt))\n-    r = NULL_TREE;\n+  if (TREE_CODE (stmt) == COMPOUND_STMT)\n+    COMPOUND_BODY (stmt) = do_poplevel (COMPOUND_BODY (stmt));\n+  else if (STATEMENT_LIST_NO_SCOPE (stmt))\n+    stmt = pop_stmt_list (stmt);\n   else\n-    r = do_poplevel ();\n-\n-  RECHAIN_STMTS (compound_stmt, COMPOUND_BODY (compound_stmt));\n+    stmt = do_poplevel (stmt);\n \n-  /* When we call finish_stmt we will lose LAST_EXPR_TYPE.  But, since\n-     the precise purpose of that variable is store the type of the\n-     last expression statement within the last compound statement, we\n-     preserve the value.  */\n-  t = last_expr_type;\n+  /* ??? See c_end_compound_stmt wrt statement expressions.  */\n+  add_stmt (stmt);\n   finish_stmt ();\n-  last_expr_type = t;\n-\n-  return r;\n }\n \n /* Finish an asm-statement, whose components are a STRING, some\n@@ -1090,17 +1100,15 @@ finish_label_decl (tree name)\n void \n finish_decl_cleanup (tree decl, tree cleanup)\n {\n-  add_stmt (build_stmt (CLEANUP_STMT, decl, cleanup));\n+  push_cleanup (decl, cleanup, false);\n }\n \n /* If the current scope exits with an exception, run CLEANUP.  */\n \n void\n finish_eh_cleanup (tree cleanup)\n {\n-  tree r = build_stmt (CLEANUP_STMT, NULL_TREE, cleanup);\n-  CLEANUP_EH_ONLY (r) = 1;\n-  add_stmt (r);\n+  push_cleanup (NULL, cleanup, true);\n }\n \n /* The MEM_INITS is a list of mem-initializers, in reverse of the\n@@ -1120,14 +1128,6 @@ finish_mem_initializers (tree mem_inits)\n     emit_mem_initializers (mem_inits);\n }\n \n-/* Returns the stack of SCOPE_STMTs for the current function.  */\n-\n-tree *\n-current_scope_stmt_stack (void)\n-{\n-  return &cfun->language->base.x_scope_stmt_stack;\n-}\n-\n /* Finish a parenthesized expression EXPR.  */\n \n tree\n@@ -1348,17 +1348,7 @@ finish_qualified_id_expr (tree qualifying_class, tree expr, bool done,\n tree \n begin_stmt_expr (void)\n {\n-  /* If we're outside a function, we won't have a statement-tree to\n-     work with.  But, if we see a statement-expression we need to\n-     create one.  */\n-  if (! cfun && !last_tree)\n-    begin_stmt_tree (&scope_chain->x_saved_tree);\n-\n-  last_expr_type = NULL_TREE;\n-  \n-  keep_next_level (true);\n-\n-  return last_tree; \n+  return push_stmt_list ();\n }\n \n /* Process the final expression of a statement expression. EXPR can be\n@@ -1367,7 +1357,7 @@ begin_stmt_expr (void)\n    expression.  */\n \n tree\n-finish_stmt_expr_expr (tree expr)\n+finish_stmt_expr_expr (tree expr, tree stmt_expr)\n {\n   tree result = NULL_TREE;\n   tree type = void_type_node;\n@@ -1408,15 +1398,16 @@ finish_stmt_expr_expr (tree expr)\n       if (expr != error_mark_node)\n \t{\n \t  result = build_stmt (EXPR_STMT, expr);\n+\t  EXPR_STMT_STMT_EXPR_RESULT (result) = 1;\n \t  add_stmt (result);\n \t}\n     }\n   \n   finish_stmt ();\n \n-  /* Remember the last expression so that finish_stmt_expr can pull it\n-     apart.  */\n-  last_expr_type = result ? result : void_type_node;\n+  /* Remember the last expression so that finish_stmt_expr\n+     can pull it apart.  */\n+  TREE_TYPE (stmt_expr) = result;\n   \n   return result;\n }\n@@ -1426,46 +1417,62 @@ finish_stmt_expr_expr (tree expr)\n    representing the statement-expression.  */\n \n tree \n-finish_stmt_expr (tree rtl_expr, bool has_no_scope)\n+finish_stmt_expr (tree stmt_expr, bool has_no_scope)\n {\n-  tree result;\n-  tree result_stmt = last_expr_type;\n-  tree type;\n-  \n-  if (!last_expr_type)\n+  tree result, result_stmt, type;\n+  tree *result_stmt_p = NULL;\n+\n+  result_stmt = TREE_TYPE (stmt_expr);\n+  TREE_TYPE (stmt_expr) = void_type_node;\n+  result = pop_stmt_list (stmt_expr);\n+\n+  if (!result_stmt || VOID_TYPE_P (result_stmt))\n     type = void_type_node;\n   else\n     {\n-      if (result_stmt == void_type_node)\n+      /* We need to search the statement expression for the result_stmt,\n+\t since we'll need to replace it entirely.  */\n+      tree t;\n+      result_stmt_p = &result;\n+      while (1)\n \t{\n-\t  type = void_type_node;\n-\t  result_stmt = NULL_TREE;\n+\t  t = *result_stmt_p;\n+\t  if (t == result_stmt)\n+\t    break;\n+\n+\t  switch (TREE_CODE (t))\n+\t    {\n+\t    case STATEMENT_LIST:\n+\t      {\n+\t\ttree_stmt_iterator i = tsi_last (t);\n+\t\tresult_stmt_p = tsi_stmt_ptr (i);\n+\t\tbreak;\n+\t      }\n+\t    case BIND_EXPR:\n+\t      result_stmt_p = &BIND_EXPR_BODY (t);\n+\t      break;\n+\t    case COMPOUND_STMT:\n+\t      result_stmt_p = &COMPOUND_BODY (t);\n+\t      break;\n+\t    case TRY_FINALLY_EXPR:\n+\t    case TRY_CATCH_EXPR:\n+\t    case CLEANUP_STMT:\n+\t      result_stmt_p = &TREE_OPERAND (t, 0);\n+\t      break;\n+\t    default:\n+\t      abort ();\n+\t    }\n \t}\n-      else\n-\ttype = TREE_TYPE (EXPR_STMT_EXPR (result_stmt));\n+      type = TREE_TYPE (EXPR_STMT_EXPR (result_stmt));\n     }\n-  \n-  result = build_min (STMT_EXPR, type, last_tree);\n-  TREE_SIDE_EFFECTS (result) = 1;\n-  STMT_EXPR_NO_SCOPE (result) = has_no_scope;\n-  \n-  last_expr_type = NULL_TREE;\n-  \n-  /* Remove the compound statement from the tree structure; it is\n-     now saved in the STMT_EXPR.  */\n-  last_tree = rtl_expr;\n-  TREE_CHAIN (last_tree) = NULL_TREE;\n-\n-  /* If we created a statement-tree for this statement-expression,\n-     remove it now.  */ \n-  if (! cfun\n-      && TREE_CHAIN (scope_chain->x_saved_tree) == NULL_TREE)\n-    finish_stmt_tree (&scope_chain->x_saved_tree);\n \n   if (processing_template_decl)\n-    return result;\n-\n-  if (!VOID_TYPE_P (type))\n+    {\n+      result = build_min (STMT_EXPR, type, result);\n+      TREE_SIDE_EFFECTS (result) = 1;\n+      STMT_EXPR_NO_SCOPE (result) = has_no_scope;\n+    }\n+  else if (!VOID_TYPE_P (type))\n     {\n       /* Pull out the TARGET_EXPR that is the final expression. Put\n \t the target's init_expr as the final expression and then put\n@@ -1474,10 +1481,24 @@ finish_stmt_expr (tree rtl_expr, bool has_no_scope)\n       tree last_expr = EXPR_STMT_EXPR (result_stmt);\n       \n       my_friendly_assert (TREE_CODE (last_expr) == TARGET_EXPR, 20030729);\n-      EXPR_STMT_EXPR (result_stmt) = TREE_OPERAND (last_expr, 1);\n+      *result_stmt_p = TREE_OPERAND (last_expr, 1);\n+\n+      if (TREE_CODE (result) == BIND_EXPR)\n+\t{\n+\t  if (VOID_TYPE_P (TREE_TYPE (result)))\n+\t    TREE_TYPE (result) = TREE_TYPE (last_expr);\n+\t  else if (same_type_p (TREE_TYPE (result), TREE_TYPE (last_expr)))\n+\t    ;\n+\t  else\n+\t    abort ();\n+\t}\n+      else if (TREE_CODE (result) == STATEMENT_LIST)\n+\tresult = build (BIND_EXPR, TREE_TYPE (last_expr), NULL, result, NULL);\n+\n       TREE_OPERAND (last_expr, 1) = result;\n       result = last_expr;\n     }\n+\n   return result;\n }\n \n@@ -2755,11 +2776,8 @@ simplify_aggr_init_expr (tree *tp)\n \n   /* We want to use the value of the initialized location as the\n      result.  */\n-  call_expr = build (COMPOUND_EXPR, type,\n-\t\t     call_expr, slot);\n+  call_expr = build (COMPOUND_EXPR, type, call_expr, slot);\n \n-  /* Replace the AGGR_INIT_EXPR with the CALL_EXPR.  */\n-  TREE_CHAIN (call_expr) = TREE_CHAIN (aggr_init_expr);\n   *tp = call_expr;\n }\n "}, {"sha": "9b998ea47b0015c2a8707c7cc5a526a8c2c22976", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -293,13 +293,10 @@ cxx_incomplete_type_error (tree value, tree type)\n \n \f\n /* The recursive part of split_nonconstant_init.  DEST is an lvalue\n-   expression to which INIT should be assigned.  INIT is a CONSTRUCTOR.\n-   PCODE is a pointer to the tail of a chain of statements being emitted.\n-   The return value is the new tail of that chain after new statements\n-   are generated.  */\n+   expression to which INIT should be assigned.  INIT is a CONSTRUCTOR.  */\n \n-static tree *\n-split_nonconstant_init_1 (tree dest, tree init, tree *pcode)\n+static void\n+split_nonconstant_init_1 (tree dest, tree init)\n {\n   tree *pelt, elt, type = TREE_TYPE (dest);\n   tree sub, code, inner_type = NULL;\n@@ -331,7 +328,7 @@ split_nonconstant_init_1 (tree dest, tree init, tree *pcode)\n \t      else\n \t        sub = build (COMPONENT_REF, inner_type, dest, field_index);\n \n-\t      pcode = split_nonconstant_init_1 (sub, value, pcode);\n+\t      split_nonconstant_init_1 (sub, value);\n \t    }\n \t  else if (!initializer_constant_valid_p (value, inner_type))\n \t    {\n@@ -344,11 +341,10 @@ split_nonconstant_init_1 (tree dest, tree init, tree *pcode)\n \n \t      code = build (MODIFY_EXPR, inner_type, sub, value);\n \t      code = build_stmt (EXPR_STMT, code);\n-\n-\t      *pcode = code;\n-\t      pcode = &TREE_CHAIN (code);\n+\t      add_stmt (code);\n \t      continue;\n \t    }\n+\n \t  pelt = &TREE_CHAIN (elt);\n \t}\n       break;\n@@ -359,15 +355,13 @@ split_nonconstant_init_1 (tree dest, tree init, tree *pcode)\n \t  CONSTRUCTOR_ELTS (init) = NULL;\n \t  code = build (MODIFY_EXPR, type, dest, init);\n \t  code = build_stmt (EXPR_STMT, code);\n-\t  pcode = &TREE_CHAIN (code);\n+\t  add_stmt (code);\n \t}\n       break;\n \n     default:\n       abort ();\n     }\n-\n-  return pcode;\n }\n \n /* A subroutine of store_init_value.  Splits non-constant static \n@@ -382,10 +376,9 @@ split_nonconstant_init (tree dest, tree init)\n \n   if (TREE_CODE (init) == CONSTRUCTOR)\n     {\n-      code = build_stmt (COMPOUND_STMT, NULL_TREE);\n-      split_nonconstant_init_1 (dest, init, &COMPOUND_BODY (code));\n-      code = build1 (STMT_EXPR, void_type_node, code);\n-      TREE_SIDE_EFFECTS (code) = 1;\n+      code = push_stmt_list ();\n+      split_nonconstant_init_1 (dest, init);\n+      code = pop_stmt_list (code);\n       DECL_INITIAL (dest) = init;\n       TREE_READONLY (dest) = 0;\n     }"}, {"sha": "72974d6d06fb55fe8b205ec9a2d8a4d5f9d33b0f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -9015,7 +9015,7 @@ tree_expr_nonnegative_p (tree t)\n     case MODIFY_EXPR:\n       return tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n     case BIND_EXPR:\n-      return tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n+      return tree_expr_nonnegative_p (expr_last (TREE_OPERAND (t, 1)));\n     case SAVE_EXPR:\n       return tree_expr_nonnegative_p (TREE_OPERAND (t, 0));\n     case NON_LVALUE_EXPR:"}, {"sha": "b0a2aa67c12416b810694d9d6328646b8111f5c5", "filename": "gcc/gimplify.c", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -754,23 +754,23 @@ gimple_build_eh_filter (tree body, tree allowed, tree failure)\n    WRAPPER was already void.  */\n \n tree\n-voidify_wrapper_expr (tree wrapper)\n+voidify_wrapper_expr (tree wrapper, tree temp)\n {\n   if (!VOID_TYPE_P (TREE_TYPE (wrapper)))\n     {\n-      tree *p;\n-      tree temp;\n+      tree *p, sub = wrapper;\n \n+    restart:\n       /* Set p to point to the body of the wrapper.  */\n-      switch (TREE_CODE (wrapper))\n+      switch (TREE_CODE (sub))\n \t{\n \tcase BIND_EXPR:\n \t  /* For a BIND_EXPR, the body is operand 1.  */\n-\t  p = &BIND_EXPR_BODY (wrapper);\n+\t  p = &BIND_EXPR_BODY (sub);\n \t  break;\n \n \tdefault:\n-\t  p = &TREE_OPERAND (wrapper, 0);\n+\t  p = &TREE_OPERAND (sub, 0);\n \t  break;\n \t}\n \n@@ -789,15 +789,22 @@ voidify_wrapper_expr (tree wrapper)\n \t    }\n \t}\n \n-      if (p && TREE_CODE (*p) == INIT_EXPR)\n+      if (p == NULL || IS_EMPTY_STMT (*p))\n+\t;\n+      /* Look through exception handling.  */\n+      else if (TREE_CODE (*p) == TRY_FINALLY_EXPR\n+\t       || TREE_CODE (*p) == TRY_CATCH_EXPR)\n \t{\n-\t  /* The C++ frontend already did this for us.  */;\n-\t  temp = TREE_OPERAND (*p, 0);\n+\t  sub = *p;\n+\t  goto restart;\n \t}\n-      else if (p && TREE_CODE (*p) == INDIRECT_REF)\n+      /* The C++ frontend already did this for us.  */\n+      else if (TREE_CODE (*p) == INIT_EXPR)\n+\ttemp = TREE_OPERAND (*p, 0);\n+      /* If we're returning a dereference, move the dereference\n+\t outside the wrapper.  */\n+      else if (TREE_CODE (*p) == INDIRECT_REF)\n \t{\n-\t  /* If we're returning a dereference, move the dereference outside\n-\t     the wrapper.  */\n \t  tree ptr = TREE_OPERAND (*p, 0);\n \t  temp = create_tmp_var (TREE_TYPE (ptr), \"retval\");\n \t  *p = build (MODIFY_EXPR, TREE_TYPE (ptr), temp, ptr);\n@@ -808,12 +815,10 @@ voidify_wrapper_expr (tree wrapper)\n \t}\n       else\n \t{\n-\t  temp = create_tmp_var (TREE_TYPE (wrapper), \"retval\");\n-\t  if (p && !IS_EMPTY_STMT (*p))\n-\t    {\n-\t      *p = build (MODIFY_EXPR, TREE_TYPE (temp), temp, *p);\n-\t      TREE_SIDE_EFFECTS (wrapper) = 1;\n-\t    }\n+\t  if (!temp)\n+\t    temp = create_tmp_var (TREE_TYPE (wrapper), \"retval\");\n+\t  *p = build (MODIFY_EXPR, TREE_TYPE (temp), temp, *p);\n+\t  TREE_SIDE_EFFECTS (wrapper) = 1;\n \t}\n \n       TREE_TYPE (wrapper) = void_type_node;\n@@ -845,13 +850,14 @@ build_stack_save_restore (tree *save, tree *restore)\n /* Gimplify a BIND_EXPR.  Just voidify and recurse.  */\n \n static enum gimplify_status\n-gimplify_bind_expr (tree *expr_p, tree *pre_p)\n+gimplify_bind_expr (tree *expr_p, tree temp, tree *pre_p)\n {\n   tree bind_expr = *expr_p;\n-  tree temp = voidify_wrapper_expr (bind_expr);\n   bool old_save_stack = gimplify_ctxp->save_stack;\n   tree t;\n \n+  temp = voidify_wrapper_expr (bind_expr, temp);\n+\n   /* Mark variables seen in this bind expr.  */\n   for (t = BIND_EXPR_VARS (bind_expr); t ; t = TREE_CHAIN (t))\n     t->decl.seen_in_bind_expr = 1;\n@@ -2872,7 +2878,7 @@ gimplify_cleanup_point_expr (tree *expr_p, tree *pre_p)\n   tree_stmt_iterator iter;\n   tree body;\n \n-  tree temp = voidify_wrapper_expr (*expr_p);\n+  tree temp = voidify_wrapper_expr (*expr_p, NULL);\n \n   /* We only care about the number of conditions between the innermost\n      CLEANUP_POINT_EXPR and the cleanup.  So save and reset the count.  */\n@@ -3006,12 +3012,17 @@ gimplify_target_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \t temps list.  */\n       gimple_add_tmp_var (temp);\n \n-      /* Build up the initialization and add it to pre_p.  */\n-      init = build (MODIFY_EXPR, void_type_node, temp, init);\n-      ret = gimplify_expr (&init, pre_p, post_p, is_gimple_stmt, fb_none);\n-      if (ret == GS_ERROR)\n-\treturn GS_ERROR;\n-\n+      /* Build up the initialization and add it to pre_p.  Special handling\n+\t for BIND_EXPR can result in fewer temporaries created.  */\n+      if (TREE_CODE (init) == BIND_EXPR)\n+\tgimplify_bind_expr (&init, temp, pre_p);\n+      if (init != temp)\n+\t{\n+\t  init = build (MODIFY_EXPR, void_type_node, temp, init);\n+\t  ret = gimplify_expr (&init, pre_p, post_p, is_gimple_stmt, fb_none);\n+\t  if (ret == GS_ERROR)\n+\t    return GS_ERROR;\n+\t}\n       append_to_statement_list (init, pre_p);\n \n       /* If needed, push the cleanup for the temp.  */\n@@ -3286,7 +3297,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  break;\n \n \tcase BIND_EXPR:\n-\t  ret = gimplify_bind_expr (expr_p, pre_p);\n+\t  ret = gimplify_bind_expr (expr_p, NULL, pre_p);\n \t  break;\n \n \tcase LOOP_EXPR:\n@@ -3530,7 +3541,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n   /* If we are gimplifying at the statement level, we're done.  Tack\n      everything together and replace the original statement with the\n      gimplified form.  */\n-  if (is_statement)\n+  if (fallback == fb_none || is_statement)\n     {\n       if (internal_pre || internal_post)\n \t{"}, {"sha": "cf52b87e0279da09d7df4af01eab7064c2e9bbf3", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -78,7 +78,6 @@ extern tree lhd_tree_inlining_walk_subtrees (tree *, int *, walk_tree_fn,\n extern int lhd_tree_inlining_cannot_inline_tree_fn (tree *);\n extern int lhd_tree_inlining_disregard_inline_limits (tree);\n extern tree lhd_tree_inlining_add_pending_fn_decls (void *, tree);\n-extern int lhd_tree_inlining_tree_chain_matters_p (tree);\n extern int lhd_tree_inlining_auto_var_in_fn_p (tree, tree);\n extern tree lhd_tree_inlining_copy_res_decl_for_inlining (tree, tree, tree,\n \t\t\t\t\t\t\t  void *, int *, tree);\n@@ -151,8 +150,6 @@ extern int lhd_gimplify_expr (tree *, tree *, tree *);\n   lhd_tree_inlining_disregard_inline_limits\n #define LANG_HOOKS_TREE_INLINING_ADD_PENDING_FN_DECLS \\\n   lhd_tree_inlining_add_pending_fn_decls\n-#define LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P \\\n-  lhd_tree_inlining_tree_chain_matters_p\n #define LANG_HOOKS_TREE_INLINING_AUTO_VAR_IN_FN_P \\\n   lhd_tree_inlining_auto_var_in_fn_p\n #define LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING \\\n@@ -175,7 +172,6 @@ extern int lhd_gimplify_expr (tree *, tree *, tree *);\n   LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN, \\\n   LANG_HOOKS_TREE_INLINING_DISREGARD_INLINE_LIMITS, \\\n   LANG_HOOKS_TREE_INLINING_ADD_PENDING_FN_DECLS, \\\n-  LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P, \\\n   LANG_HOOKS_TREE_INLINING_AUTO_VAR_IN_FN_P, \\\n   LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING, \\\n   LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P, \\"}, {"sha": "439c12a910f132a5fe6afa80caf014922975901d", "filename": "gcc/langhooks.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -365,16 +365,6 @@ lhd_tree_inlining_add_pending_fn_decls (void *vafnp ATTRIBUTE_UNUSED, tree pfn)\n   return pfn;\n }\n \n-/* lang_hooks.tree_inlining.tree_chain_matters_p indicates whether the\n-   TREE_CHAIN of a language-specific tree node is relevant, i.e.,\n-   whether it should be walked, copied and preserved across copies.  */\n-\n-int\n-lhd_tree_inlining_tree_chain_matters_p (tree t ATTRIBUTE_UNUSED)\n-{\n-  return 0;\n-}\n-\n /* lang_hooks.tree_inlining.auto_var_in_fn_p is called to determine\n    whether VT is an automatic variable defined in function FT.  */\n "}, {"sha": "880ed7c238059e676371951e535a6f07ff3c0fca", "filename": "gcc/langhooks.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -39,7 +39,6 @@ struct lang_hooks_for_tree_inlining\n   int (*cannot_inline_tree_fn) (tree *);\n   int (*disregard_inline_limits) (tree);\n   tree (*add_pending_fn_decls) (void *, tree);\n-  int (*tree_chain_matters_p) (tree);\n   int (*auto_var_in_fn_p) (tree, tree);\n   tree (*copy_res_decl_for_inlining) (tree, tree, tree,\n \t\t\t\t      void *, int *, tree);"}, {"sha": "971520e90c1f23825cecc5c72870a597237f6264", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 26, "deletions": 35, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -1875,7 +1875,7 @@ build_module_descriptor (void)\n \n   {\n     tree parms, execclass_decl, decelerator, void_list_node_1;\n-    tree init_function_name, init_function_decl;\n+    tree init_function_name, init_function_decl, compound;\n \n     /* Declare void __objc_execClass (void *); */\n \n@@ -1903,6 +1903,7 @@ build_module_descriptor (void)\n \t\t\t      NULL_TREE),\n \t\t    NULL_TREE);\n     store_parm_decls ();\n+    compound = c_begin_compound_stmt (true);\n \n     init_function_decl = current_function_decl;\n     TREE_PUBLIC (init_function_decl) = ! targetm.have_ctors_dtors;\n@@ -1917,6 +1918,7 @@ build_module_descriptor (void)\n     decelerator = build_function_call (execclass_decl, parms);\n \n     c_expand_expr_stmt (decelerator);\n+    add_stmt (c_end_compound_stmt (compound, true));\n \n     finish_function ();\n \n@@ -2687,10 +2689,7 @@ objc_enter_block (void)\n #ifdef OBJCPLUS\n   block = begin_compound_stmt (0);\n #else\n-  block = c_begin_compound_stmt ();\n-  push_scope ();\n-  clear_last_expr ();\n-  add_scope_stmt (/*begin_p=*/1, /*partial_p=*/0);\n+  block = c_begin_compound_stmt (1);\n #endif\n \n   objc_exception_block_stack = tree_cons (NULL_TREE, block,\n@@ -2704,24 +2703,14 @@ static tree\n objc_exit_block (void)\n {\n   tree block = TREE_VALUE (objc_exception_block_stack);\n-#ifndef OBJCPLUS\n-  tree scope_stmt, inner;\n-#endif\n+  objc_exception_block_stack = TREE_CHAIN (objc_exception_block_stack);\t\n \n   objc_clear_super_receiver ();\n #ifdef OBJCPLUS\n-  finish_compound_stmt (0, block);\n+  finish_compound_stmt (block);\n #else\n-  scope_stmt = add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0);\n-  inner = pop_scope ();\n-\n-  SCOPE_STMT_BLOCK (TREE_PURPOSE (scope_stmt))\n-\t= SCOPE_STMT_BLOCK (TREE_VALUE (scope_stmt))\n-\t= inner;\n-  RECHAIN_STMTS (block, COMPOUND_BODY (block));\n+  block = c_end_compound_stmt (block, 1);\n #endif\n-  last_expr_type = NULL_TREE;\n-  objc_exception_block_stack = TREE_CHAIN (objc_exception_block_stack);\t\n \n   blk_nesting_count--;\n   return block;\n@@ -2804,6 +2793,15 @@ objc_build_try_enter_fragment (void)\n   c_expand_expr_stmt (build_function_call\n \t\t      (objc_exception_try_enter_decl, func_params));\n \n+#ifdef OBJCPLUS\n+  /* Um, C and C++ have very different statement construction functions.\n+     Partly because different scoping rules are in effect, but partly \n+     because of how their parsers are constructed.  I highly recommend\n+     simply constructing the statements by hand here.  You don't need\n+     any of the ancilliary tracking necessary for user parsing bits anyway.  */\n+#error\n+#endif\n+\n   if_stmt = c_begin_if_stmt ();\n   if_nesting_count++;\n   /* If <setjmp.h> has been included, the _setjmp prototype has\n@@ -2865,17 +2863,15 @@ objc_build_extract_fragment (void)\n       _rethrowException = objc_exception_extract(&_stackExceptionData);\n      }  */\n \n-  objc_exit_block ();\n-  c_finish_then ();\n+  c_finish_then (objc_exit_block ());\n \n   c_expand_start_else ();\n   objc_enter_block ();\n   c_expand_expr_stmt (build_modify_expr\n \t\t      (TREE_VALUE (objc_rethrow_exception),\n \t\t       NOP_EXPR,\n \t\t       objc_build_extract_expr ()));\n-  objc_exit_block ();\n-  c_finish_else ();\n+  c_finish_else (objc_exit_block ());\n   c_expand_end_cond ();\n   if_nesting_count--;\n }\n@@ -2934,8 +2930,7 @@ objc_build_try_epilogue (int also_catch_prologue)\n \n       tree if_stmt;\n \n-      objc_exit_block ();\n-      c_finish_then ();\n+      c_finish_then (objc_exit_block ());\n     \t\t\n       c_expand_start_else ();\n       objc_enter_block ();\n@@ -3017,8 +3012,7 @@ objc_build_catch_stmt (tree catch_expr)\n \n   objc_catch_type = tree_cons (NULL_TREE, var_type, objc_catch_type);\n \n-  objc_exit_block ();\n-  c_finish_then ();\n+  c_finish_then (objc_exit_block ());\n \n   c_expand_start_else ();\n   catch_count_stack->val++;\n@@ -3061,8 +3055,7 @@ objc_build_catch_epilogue (void)\n    } // end TRY-CATCH scope\n   */\n \n-  objc_exit_block ();\n-  c_finish_then ();\n+  c_finish_then (objc_exit_block ());\n \n   c_expand_start_else ();\n   objc_enter_block ();\n@@ -3075,7 +3068,8 @@ objc_build_catch_epilogue (void)\n   objc_exit_block ();\n   while (catch_count_stack->val--)\n     {\n-      c_finish_else ();\t\t/* close off all the nested ifs ! */\n+      /* FIXME.  Need to have the block of each else that was opened.  */\n+      c_finish_else ((abort (), NULL)); /* close off all the nested ifs ! */\n       c_expand_end_cond ();\n       if_nesting_count--;\n     }\n@@ -3084,8 +3078,7 @@ objc_build_catch_epilogue (void)\n \n   objc_build_extract_fragment ();\n \n-  objc_exit_block ();\n-  c_finish_else ();\n+  c_finish_else (objc_exit_block ());\n   c_expand_end_cond ();\n   if_nesting_count--;\n   objc_exit_block ();\n@@ -3116,8 +3109,7 @@ objc_build_finally_prologue (void)\n \t\t       0, if_stmt);\n   objc_enter_block ();\n   objc_build_try_exit_fragment ();\n-  objc_exit_block ();\n-  c_finish_then ();\n+  c_finish_then (objc_exit_block ());\n   c_expand_end_cond ();\n   if_nesting_count--;\n \n@@ -3141,8 +3133,7 @@ objc_build_finally_epilogue (void)\n      0, if_stmt);\n   objc_enter_block ();\n   objc_build_throw_stmt (TREE_VALUE (objc_rethrow_exception));\n-  objc_exit_block ();\n-  c_finish_then ();\n+  c_finish_then (objc_exit_block ());\n   c_expand_end_cond ();\n   if_nesting_count--;\n "}, {"sha": "f786369521cfeae813070d0d8866d5644418c546", "filename": "gcc/objc/objc-lang.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fobjc%2Fobjc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fobjc%2Fobjc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-lang.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -112,9 +112,6 @@ enum c_language_kind c_language = clk_objc;\n #undef LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING\n #define LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING \\\n   c_convert_parm_for_inlining\n-#undef LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P\n-#define LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P \\\n-  c_tree_chain_matters_p\n \n #undef LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION\n #define LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION c_expand_body"}, {"sha": "e1b964995bf877ee5d32bd7306ba54d58d98d8fc", "filename": "gcc/stub-objc.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fstub-objc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Fstub-objc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstub-objc.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -69,6 +69,11 @@ objc_message_selector (void)\n   return 0;\n }\n \n+void\n+objc_clear_super_receiver (void)\n+{\n+}\n+\n int\n objc_is_public (tree expr ATTRIBUTE_UNUSED, tree identifier ATTRIBUTE_UNUSED)\n {"}, {"sha": "51422bb6bfbe9a4cf42be0a4d4236ae804a34afd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -1,3 +1,8 @@\n+2004-06-15  Richard Henderson  <rth@redhat.com>\n+\n+\t* g++.dg/ext/stmtexpr1.C: XFAIL.\n+\t* gcc.dg/20030612-1.c: XFAIL.\n+\n 2004-06-15  Eric Christopher  <echristo@redhat.com>\n \n \t* g++.dg/charset/asm5.c: New."}, {"sha": "ad14a238b83497360e7de2fda1249d279bcc7462", "filename": "gcc/testsuite/g++.dg/ext/stmtexpr1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr1.C?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do run }\n+// { dg-do run { xfail *-*-* } }\n // { dg-options \"\" }\n \n // Copyright (C) 2003 Free Software Foundation, Inc."}, {"sha": "2c4a8d3e7e05705db837228a0a4b59682c864b5c", "filename": "gcc/testsuite/gcc.dg/20030612-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Ftestsuite%2Fgcc.dg%2F20030612-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Ftestsuite%2Fgcc.dg%2F20030612-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20030612-1.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -8,7 +8,7 @@ void foo()\n   long x = 3;\n   (void)({\n     A = B + x + ((1) - 1);\n-    return;\t/* { dg-warning \"statement-expressions should end with a non-void expression\" } */\n+    return;\t/* { dg-warning \"statement-expressions should end with a non-void expression\" \"\" { xfail *-*-* } } */\n   });\n }\n "}, {"sha": "29352a54b81290d568a2ec418b2922e7cbcf71aa", "filename": "gcc/tree-gimple.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Ftree-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Ftree-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.h?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -80,8 +80,6 @@ tree get_call_expr_in (tree t);\n \n void recalculate_side_effects (tree);\n \n-void append_to_statement_list (tree, tree *);\n-void append_to_statement_list_force (tree, tree *);\n void append_to_compound_expr (tree, tree *);\n \n /* FIXME we should deduce this from the predicate.  */\n@@ -116,7 +114,7 @@ tree gimple_current_bind_expr (void);\n void gimple_push_bind_expr (tree);\n void gimple_pop_bind_expr (void);\n void unshare_all_trees (tree);\n-tree voidify_wrapper_expr (tree);\n+tree voidify_wrapper_expr (tree, tree);\n tree gimple_build_eh_filter (tree, tree, tree);\n tree build_and_jump (tree *);\n tree alloc_stmt_list (void);"}, {"sha": "f4277931778ff93efe0de886ced20c28ed663b11", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -1657,7 +1657,7 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n \t restoring of current_function_decl.  */\n       save_decl = current_function_decl;\n       current_function_decl = id->node->decl;\n-      inline_result = voidify_wrapper_expr (expr);\n+      inline_result = voidify_wrapper_expr (expr, NULL);\n       current_function_decl = save_decl;\n \n       /* If the inlined function returns a result that we care about,\n@@ -1906,7 +1906,7 @@ clone_body (tree clone, tree fn, void *arg_map)\n   id.cloning_p = true;\n \n   /* Actually copy the body.  */\n-  TREE_CHAIN (DECL_SAVED_TREE (clone)) = copy_body (&id);\n+  append_to_statement_list_force (copy_body (&id), &DECL_SAVED_TREE (clone));\n }\n \n /* Save duplicate of body in FN.  MAP is used to pass around splay tree\n@@ -2006,8 +2006,7 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n      interesting below this point in the tree.  */\n   if (!walk_subtrees)\n     {\n-      if (code == TREE_LIST\n-\t  || lang_hooks.tree_inlining.tree_chain_matters_p (*tp))\n+      if (code == TREE_LIST)\n \t/* But we still need to check our siblings.  */\n \tWALK_SUBTREE_TAIL (TREE_CHAIN (*tp));\n       else\n@@ -2052,10 +2051,6 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n \t    WALK_SUBTREE (TREE_OPERAND (*tp, len - 1));\n \t}\n #endif\n-\n-      if (lang_hooks.tree_inlining.tree_chain_matters_p (*tp))\n-\t/* Check our siblings.  */\n-\tWALK_SUBTREE_TAIL (TREE_CHAIN (*tp));\n     }\n   else if (TREE_CODE_CLASS (code) == 'd')\n     {\n@@ -2226,8 +2221,7 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n       || TREE_CODE_CLASS (code) == 'c'\n       || code == TREE_LIST\n       || code == TREE_VEC\n-      || code == TYPE_DECL\n-      || lang_hooks.tree_inlining.tree_chain_matters_p (*tp))\n+      || code == TYPE_DECL)\n     {\n       /* Because the chain gets clobbered when we make a copy, we save it\n \t here.  */\n@@ -2245,8 +2239,7 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \n       /* Now, restore the chain, if appropriate.  That will cause\n \t walk_tree to walk into the chain as well.  */\n-      if (code == PARM_DECL || code == TREE_LIST\n-\t  || lang_hooks.tree_inlining.tree_chain_matters_p (*tp))\n+      if (code == PARM_DECL || code == TREE_LIST)\n \tTREE_CHAIN (*tp) = chain;\n \n       /* For now, we don't update BLOCKs when we make copies.  So, we"}, {"sha": "d13ea960888f99f6601e25c2c7f3d3d34fd16f45", "filename": "gcc/tree-iterator.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Ftree-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Ftree-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-iterator.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -40,14 +40,12 @@ alloc_stmt_list (void)\n   if (list)\n     {\n       stmt_list_cache = TREE_CHAIN (list);\n-      TREE_CHAIN (list) = NULL;\n-      TREE_SIDE_EFFECTS (list) = 0;\n+      memset (list, 0, sizeof(struct tree_common));\n+      TREE_SET_CODE (list, STATEMENT_LIST);\n     }\n   else\n-    {\n-      list = make_node (STATEMENT_LIST);\n-      TREE_TYPE (list) = void_type_node;\n-    }\n+    list = make_node (STATEMENT_LIST);\n+  TREE_TYPE (list) = void_type_node;\n   return list;\n }\n \n@@ -73,8 +71,6 @@ tsi_link_before (tree_stmt_iterator *i, tree t, enum tsi_iterator_update mode)\n   if (t == i->container)\n     abort ();\n \n-  TREE_SIDE_EFFECTS (i->container) = 1;\n-\n   if (TREE_CODE (t) == STATEMENT_LIST)\n     {\n       head = STATEMENT_LIST_HEAD (t);\n@@ -101,6 +97,8 @@ tsi_link_before (tree_stmt_iterator *i, tree t, enum tsi_iterator_update mode)\n       tail = head;\n     }\n \n+  TREE_SIDE_EFFECTS (i->container) = 1;\n+\n   cur = i->ptr;\n \n   /* Link it into the list.  */\n@@ -151,8 +149,6 @@ tsi_link_after (tree_stmt_iterator *i, tree t, enum tsi_iterator_update mode)\n   if (t == i->container)\n     abort ();\n \n-  TREE_SIDE_EFFECTS (i->container) = 1;\n-\n   if (TREE_CODE (t) == STATEMENT_LIST)\n     {\n       head = STATEMENT_LIST_HEAD (t);\n@@ -179,6 +175,8 @@ tsi_link_after (tree_stmt_iterator *i, tree t, enum tsi_iterator_update mode)\n       tail = head;\n     }\n \n+  TREE_SIDE_EFFECTS (i->container) = 1;\n+\n   cur = i->ptr;\n \n   /* Link it into the list.  */"}, {"sha": "c2483098871cad162b15e8851d0334ba90c601af", "filename": "gcc/tree-iterator.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Ftree-iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Ftree-iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-iterator.h?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -117,4 +117,7 @@ void tsi_delink (tree_stmt_iterator *);\n tree tsi_split_statement_list_after (const tree_stmt_iterator *);\n tree tsi_split_statement_list_before (tree_stmt_iterator *);\n \n+void append_to_statement_list (tree, tree *);\n+void append_to_statement_list_force (tree, tree *);\n+\n #endif /* GCC_TREE_ITERATOR_H  */"}, {"sha": "c38131d39d5a3d5fb29db3c9b2f6a93faa483d6c", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325c36911589375105e5437c513bf880aeffdc75/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325c36911589375105e5437c513bf880aeffdc75/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=325c36911589375105e5437c513bf880aeffdc75", "patch": "@@ -741,10 +741,12 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       break;\n \n     case TARGET_EXPR:\n-      dump_generic_node (buffer, TYPE_NAME (TREE_TYPE (node)), spc, flags, false);\n-      pp_character (buffer, '(');\n+      pp_string (buffer, \"TARGET_EXPR <\");\n+      dump_generic_node (buffer, TARGET_EXPR_SLOT (node), spc, flags, false);\n+      pp_character (buffer, ',');\n+      pp_space (buffer);\n       dump_generic_node (buffer, TARGET_EXPR_INITIAL (node), spc, flags, false);\n-      pp_character (buffer, ')');\n+      pp_character (buffer, '>');\n       break;\n \n     case COND_EXPR:"}]}