{"sha": "d10fb73e919c22a50a241b33b6a0d10aa752f70a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDEwZmI3M2U5MTljMjJhNTBhMjQxYjMzYjZhMGQxMGFhNzUyZjcwYQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2007-04-28T23:23:35Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2007-04-28T23:23:35Z"}, "message": "re PR libfortran/31501 (libgfortran internal unit I/O performance issues)\n\n2007-04-28  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libfortran/31501\n\t* io/list_read.c (next_char): Fix whitespace.\n\t* io/io.h: Remove prototypes and define macros for is_array_io,\n\tis_stream_io, and is_internal_unit.\n\t* io/unit.c (is_array_io), (is_internal_unit), (is_stream_io): Delete\n\tthese functions.\n\t* io/transfer.c (read_sf): Change handling of internal_unit to make a\n\tsingle call to salloc_r and use memcpy to transfer the data.\n\nFrom-SVN: r124266", "tree": {"sha": "8715a6c860658cac9b255cfeaab985075c62d031", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8715a6c860658cac9b255cfeaab985075c62d031"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d10fb73e919c22a50a241b33b6a0d10aa752f70a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d10fb73e919c22a50a241b33b6a0d10aa752f70a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d10fb73e919c22a50a241b33b6a0d10aa752f70a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d10fb73e919c22a50a241b33b6a0d10aa752f70a/comments", "author": null, "committer": null, "parents": [{"sha": "8e1f21e9c678c941fc1fc720c74f29d74768c9b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e1f21e9c678c941fc1fc720c74f29d74768c9b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e1f21e9c678c941fc1fc720c74f29d74768c9b8"}], "stats": {"total": 78, "additions": 32, "deletions": 46}, "files": [{"sha": "409c20d64a06b46b91754e31b8c738f5bf3a5599", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10fb73e919c22a50a241b33b6a0d10aa752f70a/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10fb73e919c22a50a241b33b6a0d10aa752f70a/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=d10fb73e919c22a50a241b33b6a0d10aa752f70a", "patch": "@@ -1,3 +1,14 @@\n+2007-04-28  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libfortran/31501\n+\t* io/list_read.c (next_char): Fix whitespace.\n+\t* io/io.h: Remove prototypes and define macros for is_array_io,\n+\tis_stream_io, and is_internal_unit.\n+\t* io/unit.c (is_array_io), (is_internal_unit), (is_stream_io): Delete\n+\tthese functions.\n+\t* io/transfer.c (read_sf): Change handling of internal_unit to make a\n+\tsingle call to salloc_r and use memcpy to transfer the data. \n+\n 2007-04-27  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/31532"}, {"sha": "181c1816b61709999c8227ef5cbcd52348b06954", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10fb73e919c22a50a241b33b6a0d10aa752f70a/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10fb73e919c22a50a241b33b6a0d10aa752f70a/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=d10fb73e919c22a50a241b33b6a0d10aa752f70a", "patch": "@@ -80,6 +80,14 @@ stream;\n \n #define sset(s, c, n) ((s)->set)(s, c, n)\n \n+/* Macros for testing what kinds of I/O we are doing.  */\n+\n+#define is_array_io(dtp) ((dtp)->internal_unit_desc)\n+\n+#define is_internal_unit(dtp) ((dtp)->u.p.unit_is_internal)\n+\n+#define is_stream_io(dtp) ((dtp)->u.p.current_unit->flags.access == ACCESS_STREAM)\n+\n /* The array_loop_spec contains the variables for the loops over index ranges\n    that are encountered.  Since the variables can be negative, ssize_t\n    is used.  */\n@@ -672,15 +680,6 @@ internal_proto(get_internal_unit);\n extern void free_internal_unit (st_parameter_dt *);\n internal_proto(free_internal_unit);\n \n-extern int is_internal_unit (st_parameter_dt *);\n-internal_proto(is_internal_unit);\n-\n-extern int is_array_io (st_parameter_dt *);\n-internal_proto(is_array_io);\n-\n-extern int is_stream_io (st_parameter_dt *);\n-internal_proto(is_stream_io);\n-\n extern gfc_unit *find_unit (int);\n internal_proto(find_unit);\n "}, {"sha": "9e2e0f91484ce34aba60dc807f61165487e01b92", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10fb73e919c22a50a241b33b6a0d10aa752f70a/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10fb73e919c22a50a241b33b6a0d10aa752f70a/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=d10fb73e919c22a50a241b33b6a0d10aa752f70a", "patch": "@@ -165,7 +165,7 @@ next_char (st_parameter_dt *dtp)\n \n   /* Handle the end-of-record and end-of-file conditions for\n      internal array unit.  */\n-  if (is_array_io(dtp))\n+  if (is_array_io (dtp))\n     {\n       if (dtp->u.p.at_eof)\n \tlongjmp (*dtp->u.p.eof_jump, 1);\n@@ -201,9 +201,9 @@ next_char (st_parameter_dt *dtp)\n   if (is_stream_io (dtp))\n     dtp->u.p.current_unit->strm_pos++;\n \n-  if (is_internal_unit(dtp))\n+  if (is_internal_unit (dtp))\n     {\n-      if (is_array_io(dtp))\n+      if (is_array_io (dtp))\n \t{\n \t  /* End of record is handled in the next pass through, above.  The\n \t     check for NULL here is cautionary.  */"}, {"sha": "13bb27206fd54c3cc6fe638412808426fb9262dc", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10fb73e919c22a50a241b33b6a0d10aa752f70a/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10fb73e919c22a50a241b33b6a0d10aa752f70a/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=d10fb73e919c22a50a241b33b6a0d10aa752f70a", "patch": "@@ -164,18 +164,19 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n       return base;\n     }\n \n+  if (is_internal_unit (dtp))\n+    {\n+      readlen = *length;\n+      q = salloc_r (dtp->u.p.current_unit->s, &readlen);\n+      memcpy (p, q, readlen);\n+      goto done;\n+    }\n+\n   readlen = 1;\n   n = 0;\n \n   do\n     {\n-      if (is_internal_unit (dtp))\n-\t{\n-\t  /* readlen may be modified inside salloc_r if\n-\t     is_internal_unit (dtp) is true.  */\n-\t  readlen = 1;\n-\t}\n-\n       q = salloc_r (dtp->u.p.current_unit->s, &readlen);\n       if (q == NULL)\n \tbreak;\n@@ -244,6 +245,8 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n       dtp->u.p.sf_seen_eor = 0;\n     }\n   while (n < *length);\n+\n+ done:\n   dtp->u.p.current_unit->bytes_left -= *length;\n \n   if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)"}, {"sha": "c468510b8752b58caeb11353fad7b747770340da", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10fb73e919c22a50a241b33b6a0d10aa752f70a/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10fb73e919c22a50a241b33b6a0d10aa752f70a/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=d10fb73e919c22a50a241b33b6a0d10aa752f70a", "patch": "@@ -476,33 +476,6 @@ get_unit (st_parameter_dt *dtp, int do_create)\n }\n \n \n-/* is_internal_unit()-- Determine if the current unit is internal or not */\n-\n-int\n-is_internal_unit (st_parameter_dt *dtp)\n-{\n-  return dtp->u.p.unit_is_internal;\n-}\n-\n-\n-/* is_array_io ()-- Determine if the I/O is to/from an array */\n-\n-int\n-is_array_io (st_parameter_dt *dtp)\n-{\n-  return dtp->internal_unit_desc != NULL;\n-}\n-\n-\n-/* is_stream_io () -- Determine if I/O is access=\"stream\" mode */\n-\n-int\n-is_stream_io (st_parameter_dt *dtp)\n-{\n-  return dtp->u.p.current_unit->flags.access == ACCESS_STREAM;\n-}\n-\n-\n /*************************/\n /* Initialize everything */\n "}]}