{"sha": "af15184ab60cc2c2caf47964734c3e123bc04f7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYxNTE4NGFiNjBjYzJjMmNhZjQ3OTY0NzM0YzNlMTIzYmMwNGY3Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-08-02T14:38:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-08-02T14:38:15Z"}, "message": "cgraph.c (cgraph_function_body_availability): Do not check cgrpah flags.\n\n\n\t* cgraph.c (cgraph_function_body_availability): Do not check cgrpah flags.\n\t* cgraph.h (symtab_for_node_and_aliases, symtab_nonoverwritable_alias,\n\tsymtab_node_availability): Declare.\n\t* ipa.c (can_replace_by_local_alias): New.\n\t(function_and_variable_visibility): Use it.\n\t* symtab.c (symtab_for_node_and_aliases, symtab_nonoverwritable_alias_1,\n\tsymtab_nonoverwritable_alias): New.\n\nCo-Authored-By: Martin Liska <marxin.liska@gmail.com>\n\nFrom-SVN: r201439", "tree": {"sha": "1cccd5c74a32da024ef7d68be27022345b749039", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cccd5c74a32da024ef7d68be27022345b749039"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af15184ab60cc2c2caf47964734c3e123bc04f7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af15184ab60cc2c2caf47964734c3e123bc04f7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af15184ab60cc2c2caf47964734c3e123bc04f7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af15184ab60cc2c2caf47964734c3e123bc04f7c/comments", "author": null, "committer": null, "parents": [{"sha": "01e54ef86f407385b0f2bb7afb5748f0db31bce8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01e54ef86f407385b0f2bb7afb5748f0db31bce8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01e54ef86f407385b0f2bb7afb5748f0db31bce8"}], "stats": {"total": 148, "additions": 146, "deletions": 2}, "files": [{"sha": "9e0e253745f3b0f327f46ddd025e0b899cf99582", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15184ab60cc2c2caf47964734c3e123bc04f7c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15184ab60cc2c2caf47964734c3e123bc04f7c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af15184ab60cc2c2caf47964734c3e123bc04f7c", "patch": "@@ -1,3 +1,14 @@\n+2013-08-02  Jan Hubicka  <jh@suse.cz>\n+\t    Martin Liska  <marxin.liska@gmail.com>\n+\n+\t* cgraph.c (cgraph_function_body_availability): Do not check cgrpah flags.\n+\t* cgraph.h (symtab_for_node_and_aliases, symtab_nonoverwritable_alias,\n+\tsymtab_node_availability): Declare.\n+\t* ipa.c (can_replace_by_local_alias): New.\n+\t(function_and_variable_visibility): Use it.\n+\t* symtab.c (symtab_for_node_and_aliases, symtab_nonoverwritable_alias_1,\n+\tsymtab_nonoverwritable_alias): New.\n+\n 2013-08-02  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/57963"}, {"sha": "6ab7891ec8f9c9f0a1380fb3b4bee3eb1412e520", "filename": "gcc/cgraph.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15184ab60cc2c2caf47964734c3e123bc04f7c/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15184ab60cc2c2caf47964734c3e123bc04f7c/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=af15184ab60cc2c2caf47964734c3e123bc04f7c", "patch": "@@ -1697,7 +1697,6 @@ enum availability\n cgraph_function_body_availability (struct cgraph_node *node)\n {\n   enum availability avail;\n-  gcc_assert (cgraph_function_flags_ready);\n   if (!node->symbol.analyzed)\n     avail = AVAIL_NOT_AVAILABLE;\n   else if (node->local.local)"}, {"sha": "4e4dddc0c3eef1c81b8a8b536c87e98c52b3b198", "filename": "gcc/cgraph.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15184ab60cc2c2caf47964734c3e123bc04f7c/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15184ab60cc2c2caf47964734c3e123bc04f7c/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=af15184ab60cc2c2caf47964734c3e123bc04f7c", "patch": "@@ -597,6 +597,12 @@ symtab_node symtab_alias_ultimate_target (symtab_node,\n \t\t\t\t\t  enum availability *avail = NULL);\n bool symtab_resolve_alias (symtab_node node, symtab_node target);\n void fixup_same_cpp_alias_visibility (symtab_node node, symtab_node target);\n+bool symtab_for_node_and_aliases (symtab_node,\n+\t\t\t\t  bool (*) (symtab_node, void *),\n+\t\t\t\t  void *,\n+\t\t\t\t  bool);\n+symtab_node symtab_nonoverwritable_alias (symtab_node);\n+enum availability symtab_node_availability (symtab_node);\n \n /* In cgraph.c  */\n void dump_cgraph (FILE *);"}, {"sha": "f42de4dac693942e379a5f7a8391954956358cac", "filename": "gcc/ipa.c", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15184ab60cc2c2caf47964734c3e123bc04f7c/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15184ab60cc2c2caf47964734c3e123bc04f7c/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=af15184ab60cc2c2caf47964734c3e123bc04f7c", "patch": "@@ -751,6 +751,21 @@ varpool_externally_visible_p (struct varpool_node *vnode)\n   return false;\n }\n \n+/* Return true if reference to NODE can be replaced by a local alias.\n+   Local aliases save dynamic linking overhead and enable more optimizations.\n+ */\n+\n+bool\n+can_replace_by_local_alias (symtab_node node)\n+{\n+  return (symtab_node_availability (node) > AVAIL_OVERWRITABLE\n+\t  && !DECL_EXTERNAL (node->symbol.decl)\n+\t  && (!DECL_ONE_ONLY (node->symbol.decl)\n+\t      || node->symbol.resolution == LDPR_PREVAILING_DEF\n+\t      || node->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t      || node->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY_EXP));\n+}\n+\n /* Mark visibility of all functions.\n \n    A local function is one whose calls can occur only in the current\n@@ -872,7 +887,36 @@ function_and_variable_visibility (bool whole_program)\n \t}\n     }\n   FOR_EACH_DEFINED_FUNCTION (node)\n-    node->local.local = cgraph_local_node_p (node);\n+    {\n+      node->local.local = cgraph_local_node_p (node);\n+\n+      /* If we know that function can not be overwritten by a different semantics\n+\t and moreover its section can not be discarded, replace all direct calls\n+\t by calls to an nonoverwritable alias.  This make dynamic linking\n+\t cheaper and enable more optimization.\n+\n+\t TODO: We can also update virtual tables.  */\n+      if (node->callers && can_replace_by_local_alias ((symtab_node)node))\n+\t{\n+\t  struct cgraph_node *alias = cgraph (symtab_nonoverwritable_alias ((symtab_node) node));\n+\n+\t  if (alias != node)\n+\t    {\n+\t      while (node->callers)\n+\t\t{\n+\t\t  struct cgraph_edge *e = node->callers;\n+\n+\t\t  cgraph_redirect_edge_callee (e, alias);\n+\t\t  if (!flag_wpa)\n+\t\t    {\n+\t\t      push_cfun (DECL_STRUCT_FUNCTION (e->caller->symbol.decl));\n+\t\t      cgraph_redirect_edge_call_stmt_to_callee (e);\n+\t\t      pop_cfun ();\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n   FOR_EACH_VARIABLE (vnode)\n     {\n       /* weak flag makes no sense on local variables.  */"}, {"sha": "a86bf6b132791e6b670519f8e251aceadfab2b6c", "filename": "gcc/symtab.c", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15184ab60cc2c2caf47964734c3e123bc04f7c/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15184ab60cc2c2caf47964734c3e123bc04f7c/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=af15184ab60cc2c2caf47964734c3e123bc04f7c", "patch": "@@ -1014,4 +1014,88 @@ symtab_resolve_alias (symtab_node node, symtab_node target)\n     symtab_alias_ultimate_target (target, NULL)->symbol.address_taken = true;\n   return true;\n }\n+\n+/* Call calback on NODE and aliases associated to NODE. \n+   When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n+   skipped. */\n+\n+bool\n+symtab_for_node_and_aliases (symtab_node node,\n+\t\t\t     bool (*callback) (symtab_node, void *),\n+\t\t\t     void *data,\n+\t\t\t     bool include_overwritable)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+\n+  if (callback (node, data))\n+    return true;\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list, i, ref); i++)\n+    if (ref->use == IPA_REF_ALIAS)\n+      {\n+\tsymtab_node alias = ref->referring;\n+\tif (include_overwritable\n+\t    || symtab_node_availability (alias) > AVAIL_OVERWRITABLE)\n+          if (symtab_for_node_and_aliases (alias, callback, data,\n+\t\t\t\t\t   include_overwritable))\n+\t    return true;\n+      }\n+  return false;\n+}\n+\n+/* Worker searching nonoverwritable alias.  */\n+\n+static bool\n+symtab_nonoverwritable_alias_1 (symtab_node node, void *data)\n+{\n+  if (decl_binds_to_current_def_p (node->symbol.decl))\n+    {\n+      *(symtab_node *)data = node;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* If NODE can not be overwriten by static or dynamic linker to point to different\n+   definition, return NODE. Otherwise look for alias with such property and if\n+   none exists, introduce new one.  */\n+\n+symtab_node\n+symtab_nonoverwritable_alias (symtab_node node)\n+{\n+  tree new_decl;\n+  symtab_node new_node = NULL;\n+  symtab_for_node_and_aliases (node, symtab_nonoverwritable_alias_1,\n+\t\t               (void *)&new_node, true);\n+  if (new_node)\n+    return new_node;\n+\n+  new_decl = copy_node (node->symbol.decl);\n+  DECL_NAME (new_decl) = clone_function_name (node->symbol.decl, \"localalias\");\n+  if (TREE_CODE (new_decl) == FUNCTION_DECL)\n+    DECL_STRUCT_FUNCTION (new_decl) = NULL;\n+  DECL_INITIAL (new_decl) = NULL;\n+  SET_DECL_ASSEMBLER_NAME (new_decl, DECL_NAME (new_decl));\n+  SET_DECL_RTL (new_decl, NULL);\n+\n+  /* Update the properties.  */\n+  DECL_EXTERNAL (new_decl) = 0;\n+  if (DECL_ONE_ONLY (node->symbol.decl))\n+    DECL_SECTION_NAME (new_decl) = NULL;\n+  DECL_COMDAT_GROUP (new_decl) = 0;\n+  TREE_PUBLIC (new_decl) = 0;\n+  DECL_COMDAT (new_decl) = 0;\n+  DECL_WEAK (new_decl) = 0;\n+  DECL_VIRTUAL_P (new_decl) = 0;\n+  if (TREE_CODE (new_decl) == FUNCTION_DECL)\n+    {\n+      DECL_STATIC_CONSTRUCTOR (new_decl) = 0;\n+      DECL_STATIC_DESTRUCTOR (new_decl) = 0;\n+      new_node = (symtab_node) cgraph_create_function_alias (new_decl, node->symbol.decl);\n+    }\n+  else\n+    new_node = (symtab_node) varpool_create_variable_alias (new_decl, node->symbol.decl);\n+  symtab_resolve_alias (new_node, node);  \n+  return new_node;\n+}\n #include \"gt-symtab.h\""}]}