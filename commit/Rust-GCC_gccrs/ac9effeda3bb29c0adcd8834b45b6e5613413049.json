{"sha": "ac9effeda3bb29c0adcd8834b45b6e5613413049", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM5ZWZmZWRhM2JiMjljMGFkY2Q4ODM0YjQ1YjZlNTYxMzQxMzA0OQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-11-23T16:36:28Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-11-23T16:36:28Z"}, "message": "generic.texi (ANNOTATE_EXPR): Document 3rd operand.\n\n\t* doc/generic.texi (ANNOTATE_EXPR): Document 3rd operand.\n\t* cfgloop.h (struct loop): Add unroll field.\n\t* function.h (struct function): Add has_unroll bitfield.\n\t* gimplify.c (gimple_boolify) <ANNOTATE_EXPR>: Deal with unroll kind.\n\t(gimplify_expr) <ANNOTATE_EXPR>: Propagate 3rd operand.\n\t* loop-init.c (pass_loop2::gate): Return true if cfun->has_unroll.\n\t(pass_rtl_unroll_loops::gate): Likewise.\n\t* loop-unroll.c (decide_unrolling): Tweak note message.  Skip loops\n\tfor which loop->unroll==1.\n\t(decide_unroll_constant_iterations): Use note for consistency and\n\ttake loop->unroll into account.  Return early if loop->unroll is set.\n\tFix thinko in existing test.\n\t(decide_unroll_runtime_iterations): Use note for consistency and\n\ttake loop->unroll into account.\n\t(decide_unroll_stupid): Likewise.\n\t* lto-streamer-in.c (input_cfg): Read loop->unroll.\n\t* lto-streamer-out.c (output_cfg): Write loop->unroll.\n\t* tree-cfg.c (replace_loop_annotate_in_block) <annot_expr_unroll_kind>:\n        New case.\n\t(replace_loop_annotate) <annot_expr_unroll_kind>: Likewise.\n\t(print_loop): Print loop->unroll if set.\n\t* tree-core.h (enum annot_expr_kind): Add annot_expr_unroll_kind.\n\t* tree-inline.c (copy_loops): Copy unroll and set cfun->has_unroll.\n\t* tree-pretty-print.c (dump_generic_node) <annot_expr_unroll_kind>:\n\tNew case.\n\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely): Bail out if\n\tloop->unroll is set and smaller than the trip count.  Otherwise bypass\n\tentirely the heuristics if loop->unroll is set.  Remove dead note.\n\tFix off-by-one bug in other note.\n\t(try_peel_loop): Bail out if loop->unroll is set.  Fix formatting.\n\t(tree_unroll_loops_completely_1): Force unrolling if loop->unroll\n\tis greater than 1.\n\t(tree_unroll_loops_completely): Make static.\n\t(pass_complete_unroll::execute): Use correct type for variable.\n\t(pass_complete_unrolli::execute): Fix formatting.\n\t* tree.def (ANNOTATE_EXPR): Add 3rd operand.\nada/\n\t* gcc-interface/trans.c (gnat_gimplify_stmt) <LOOP_STMT>: Pass 3rd\n\toperand to ANNOTATE_EXPR and also pass unrolling hints.\nc/\n\t* c-parser.c (c_parser_while_statement): Pass 3rd operand to\n\tANNOTATE_EXPR.\n\t(c_parser_do_statement): Likewise.\n\t(c_parser_for_statement): Likewise.\ncp/\n\t* pt.c (tsubst_expr) <ANNOTATE_EXPR>: Recurse on 3rd operand.\n\t* semantics.c (finish_while_stmt_cond): Pass 3rd operand to\n\tANNOTATE_EXPR.\n\t(finish_do_stmt): Likewise.\n\t(finish_for_cond): Likewise.\nfortran/\n\t* trans-stmt.c (gfc_trans_forall_loop): Pass 3rd operand to\n\tANNOTATE_EXPR.\n\nFrom-SVN: r255106", "tree": {"sha": "3f5eec951b1bf6f87260a9f9b1ac709979be8501", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f5eec951b1bf6f87260a9f9b1ac709979be8501"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac9effeda3bb29c0adcd8834b45b6e5613413049", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac9effeda3bb29c0adcd8834b45b6e5613413049", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac9effeda3bb29c0adcd8834b45b6e5613413049", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac9effeda3bb29c0adcd8834b45b6e5613413049/comments", "author": null, "committer": null, "parents": [{"sha": "02a703675c455492a0606579a37d373e9777284c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02a703675c455492a0606579a37d373e9777284c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02a703675c455492a0606579a37d373e9777284c"}], "stats": {"total": 741, "additions": 522, "deletions": 219}, "files": [{"sha": "98932b4b7b3cfeb7e43e624d2b023dc54d061ab5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -1,3 +1,43 @@\n+2017-11-23  Mike Stump  <mikestump@comcast.net>\n+            Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* doc/generic.texi (ANNOTATE_EXPR): Document 3rd operand.\n+\t* cfgloop.h (struct loop): Add unroll field.\n+\t* function.h (struct function): Add has_unroll bitfield.\n+\t* gimplify.c (gimple_boolify) <ANNOTATE_EXPR>: Deal with unroll kind.\n+\t(gimplify_expr) <ANNOTATE_EXPR>: Propagate 3rd operand.\n+\t* loop-init.c (pass_loop2::gate): Return true if cfun->has_unroll.\n+\t(pass_rtl_unroll_loops::gate): Likewise.\n+\t* loop-unroll.c (decide_unrolling): Tweak note message.  Skip loops\n+\tfor which loop->unroll==1.\n+\t(decide_unroll_constant_iterations): Use note for consistency and\n+\ttake loop->unroll into account.  Return early if loop->unroll is set.\n+\tFix thinko in existing test.\n+\t(decide_unroll_runtime_iterations): Use note for consistency and\n+\ttake loop->unroll into account.\n+\t(decide_unroll_stupid): Likewise.\n+\t* lto-streamer-in.c (input_cfg): Read loop->unroll.\n+\t* lto-streamer-out.c (output_cfg): Write loop->unroll.\n+\t* tree-cfg.c (replace_loop_annotate_in_block) <annot_expr_unroll_kind>:\n+        New case.\n+\t(replace_loop_annotate) <annot_expr_unroll_kind>: Likewise.\n+\t(print_loop): Print loop->unroll if set.\n+\t* tree-core.h (enum annot_expr_kind): Add annot_expr_unroll_kind.\n+\t* tree-inline.c (copy_loops): Copy unroll and set cfun->has_unroll.\n+\t* tree-pretty-print.c (dump_generic_node) <annot_expr_unroll_kind>:\n+\tNew case.\n+\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely): Bail out if\n+\tloop->unroll is set and smaller than the trip count.  Otherwise bypass\n+\tentirely the heuristics if loop->unroll is set.  Remove dead note.\n+\tFix off-by-one bug in other note.\n+\t(try_peel_loop): Bail out if loop->unroll is set.  Fix formatting.\n+\t(tree_unroll_loops_completely_1): Force unrolling if loop->unroll\n+\tis greater than 1.\n+\t(tree_unroll_loops_completely): Make static.\n+\t(pass_complete_unroll::execute): Use correct type for variable.\n+\t(pass_complete_unrolli::execute): Fix formatting.\n+\t* tree.def (ANNOTATE_EXPR): Add 3rd operand.\n+\n 2017-11-23  Sergey Shalnov  <Sergey.Shalnov@intel.com>\n \n \t* config/i386/i386.h (TARGET_PREFER_AVX256): Also"}, {"sha": "5a40cc14e5a028746b995b7c75c4176821a4c205", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -1,3 +1,9 @@\n+2017-11-23  Mike Stump  <mikestump@comcast.net>\n+            Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (gnat_gimplify_stmt) <LOOP_STMT>: Pass 3rd\n+\toperand to ANNOTATE_EXPR and also pass unrolling hints.\n+\n 2017-11-20  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR ada/83016"}, {"sha": "2544b4c3498c56fa8aa7947ac433ac1f6cc1b670", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -8506,17 +8506,30 @@ gnat_gimplify_stmt (tree *stmt_p)\n \t  {\n \t    /* Deal with the optimization hints.  */\n \t    if (LOOP_STMT_IVDEP (stmt))\n-\t      gnu_cond = build2 (ANNOTATE_EXPR, TREE_TYPE (gnu_cond), gnu_cond,\n+\t      gnu_cond = build3 (ANNOTATE_EXPR, TREE_TYPE (gnu_cond), gnu_cond,\n \t\t\t\t build_int_cst (integer_type_node,\n-\t\t\t\t\t\tannot_expr_ivdep_kind));\n+\t\t\t\t\t\tannot_expr_ivdep_kind),\n+\t\t\t\t integer_zero_node);\n+\t    if (LOOP_STMT_NO_UNROLL (stmt))\n+\t      gnu_cond = build3 (ANNOTATE_EXPR, TREE_TYPE (gnu_cond), gnu_cond,\n+\t\t\t\t build_int_cst (integer_type_node,\n+\t\t\t\t\t\tannot_expr_unroll_kind),\n+\t\t\t\t integer_one_node);\n+\t    if (LOOP_STMT_UNROLL (stmt))\n+\t      gnu_cond = build3 (ANNOTATE_EXPR, TREE_TYPE (gnu_cond), gnu_cond,\n+\t\t\t\t build_int_cst (integer_type_node,\n+\t\t\t\t\t\tannot_expr_unroll_kind),\n+\t\t\t\t build_int_cst (NULL_TREE, USHRT_MAX));\n \t    if (LOOP_STMT_NO_VECTOR (stmt))\n-\t      gnu_cond = build2 (ANNOTATE_EXPR, TREE_TYPE (gnu_cond), gnu_cond,\n+\t      gnu_cond = build3 (ANNOTATE_EXPR, TREE_TYPE (gnu_cond), gnu_cond,\n \t\t\t\t build_int_cst (integer_type_node,\n-\t\t\t\t\t\tannot_expr_no_vector_kind));\n+\t\t\t\t\t\tannot_expr_no_vector_kind),\n+\t\t\t\t integer_zero_node);\n \t    if (LOOP_STMT_VECTOR (stmt))\n-\t      gnu_cond = build2 (ANNOTATE_EXPR, TREE_TYPE (gnu_cond), gnu_cond,\n+\t      gnu_cond = build3 (ANNOTATE_EXPR, TREE_TYPE (gnu_cond), gnu_cond,\n \t\t\t\t build_int_cst (integer_type_node,\n-\t\t\t\t\t\tannot_expr_vector_kind));\n+\t\t\t\t\t\tannot_expr_vector_kind),\n+\t\t\t\t integer_zero_node);\n \n \t    gnu_cond\n \t      = build3 (COND_EXPR, void_type_node, gnu_cond, NULL_TREE,"}, {"sha": "1d71829d919899011ba8ad4ab8b8c4138f5d56c6", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -1,3 +1,11 @@\n+2017-11-23  Mike Stump  <mikestump@comcast.net>\n+\t    Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-parser.c (c_parser_while_statement): Pass 3rd operand to\n+\tANNOTATE_EXPR.\n+\t(c_parser_do_statement): Likewise.\n+\t(c_parser_for_statement): Likewise.\n+\n 2017-11-22  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c++/62170"}, {"sha": "7eb0f5625188bd1071bf425330af8fe92fb2db74", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -6055,9 +6055,10 @@ c_parser_while_statement (c_parser *parser, bool ivdep, bool *if_p)\n \t \"%<_Cilk_spawn%> statement cannot be used as a condition for while statement\"))\n     cond = error_mark_node;\n   if (ivdep && cond != error_mark_node)\n-    cond = build2 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n+    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n \t\t   build_int_cst (integer_type_node,\n-\t\t   annot_expr_ivdep_kind));\n+\t\t\t\t  annot_expr_ivdep_kind),\n+\t\t   integer_zero_node);\n   save_break = c_break_label;\n   c_break_label = NULL_TREE;\n   save_cont = c_cont_label;\n@@ -6120,9 +6121,10 @@ c_parser_do_statement (c_parser *parser, bool ivdep)\n \t \"%<_Cilk_spawn%> statement cannot be used as a condition for a do-while statement\"))\n     cond = error_mark_node;\n   if (ivdep && cond != error_mark_node)\n-    cond = build2 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n+    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n \t\t   build_int_cst (integer_type_node,\n-\t\t   annot_expr_ivdep_kind));\n+\t\t\t\t  annot_expr_ivdep_kind),\n+\t\t   integer_zero_node);\n   if (!c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n     c_parser_skip_to_end_of_block_or_statement (parser);\n   c_finish_loop (loc, cond, NULL, body, new_break, new_cont, false);\n@@ -6327,9 +6329,10 @@ c_parser_for_statement (c_parser *parser, bool ivdep, bool *if_p)\n \t\t\t\t\t \"expected %<;%>\");\n \t    }\n \t  if (ivdep && cond != error_mark_node)\n-\t    cond = build2 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n+\t    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n \t\t\t   build_int_cst (integer_type_node,\n-\t\t\t   annot_expr_ivdep_kind));\n+\t\t\t\t\t  annot_expr_ivdep_kind),\n+\t\t\t   integer_zero_node);\n \t}\n       /* Parse the increment expression (the third expression in a\n \t for-statement).  In the case of a foreach-statement, this is"}, {"sha": "be2ba8cf1a16fc92235fa99e784c0c66e58d022a", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -221,6 +221,11 @@ struct GTY ((chain_next (\"%h.next\"))) loop {\n   /* True if the loop is part of an oacc kernels region.  */\n   unsigned in_oacc_kernels_region : 1;\n \n+  /* The number of times to unroll the loop.  0, means no information\n+     given, just do what we always do.  A value of 1, means don't unroll\n+     the loop.  */\n+  unsigned short unroll;\n+\n   /* For SIMD loops, this is a unique identifier of the loop, referenced\n      by IFN_GOMP_SIMD_VF, IFN_GOMP_SIMD_LANE and IFN_GOMP_SIMD_LAST_LANE\n      builtins.  */"}, {"sha": "ac623f08f401a06974470d026ea1346d03b22b7a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -1,3 +1,12 @@\n+2017-11-23  Mike Stump  <mikestump@comcast.net>\n+\t    Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* pt.c (tsubst_expr) <ANNOTATE_EXPR>: Recurse on 3rd operand.\n+\t* semantics.c (finish_while_stmt_cond): Pass 3rd operand to\n+\tANNOTATE_EXPR.\n+\t(finish_do_stmt): Likewise.\n+\t(finish_for_cond): Likewise.\n+\n 2017-11-22  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/82401"}, {"sha": "8bc9c221da71ff328fcd235c593aafeff8498916", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -16728,8 +16728,10 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \n     case ANNOTATE_EXPR:\n       tmp = RECUR (TREE_OPERAND (t, 0));\n-      RETURN (build2_loc (EXPR_LOCATION (t), ANNOTATE_EXPR,\n-\t\t\t  TREE_TYPE (tmp), tmp, RECUR (TREE_OPERAND (t, 1))));\n+      RETURN (build3_loc (EXPR_LOCATION (t), ANNOTATE_EXPR,\n+\t\t\t  TREE_TYPE (tmp), tmp,\n+\t\t\t  RECUR (TREE_OPERAND (t, 1)),\n+\t\t\t  RECUR (TREE_OPERAND (t, 2))));\n \n     default:\n       gcc_assert (!STATEMENT_CODE_P (TREE_CODE (t)));"}, {"sha": "c316ad2940997a50726a3ad4967897bd8d75ab9f", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -812,11 +812,12 @@ finish_while_stmt_cond (tree cond, tree while_stmt, bool ivdep)\n   finish_cond (&WHILE_COND (while_stmt), cond);\n   begin_maybe_infinite_loop (cond);\n   if (ivdep && cond != error_mark_node)\n-    WHILE_COND (while_stmt) = build2 (ANNOTATE_EXPR,\n+    WHILE_COND (while_stmt) = build3 (ANNOTATE_EXPR,\n \t\t\t\t      TREE_TYPE (WHILE_COND (while_stmt)),\n \t\t\t\t      WHILE_COND (while_stmt),\n \t\t\t\t      build_int_cst (integer_type_node,\n-\t\t\t\t\t\t     annot_expr_ivdep_kind));\n+\t\t\t\t\t\t     annot_expr_ivdep_kind),\n+\t\t\t\t      integer_zero_node);\n   simplify_loop_decl_cond (&WHILE_COND (while_stmt), WHILE_BODY (while_stmt));\n }\n \n@@ -870,8 +871,9 @@ finish_do_stmt (tree cond, tree do_stmt, bool ivdep)\n   cond = maybe_convert_cond (cond);\n   end_maybe_infinite_loop (cond);\n   if (ivdep && cond != error_mark_node)\n-    cond = build2 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n-\t\t   build_int_cst (integer_type_node, annot_expr_ivdep_kind));\n+    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n+\t\t   build_int_cst (integer_type_node, annot_expr_ivdep_kind),\n+\t\t   integer_zero_node);\n   DO_COND (do_stmt) = cond;\n }\n \n@@ -990,11 +992,12 @@ finish_for_cond (tree cond, tree for_stmt, bool ivdep)\n   finish_cond (&FOR_COND (for_stmt), cond);\n   begin_maybe_infinite_loop (cond);\n   if (ivdep && cond != error_mark_node)\n-    FOR_COND (for_stmt) = build2 (ANNOTATE_EXPR,\n+    FOR_COND (for_stmt) = build3 (ANNOTATE_EXPR,\n \t\t\t\t  TREE_TYPE (FOR_COND (for_stmt)),\n \t\t\t\t  FOR_COND (for_stmt),\n \t\t\t\t  build_int_cst (integer_type_node,\n-\t\t\t\t\t\t annot_expr_ivdep_kind));\n+\t\t\t\t\t\t annot_expr_ivdep_kind),\n+\t\t\t\t  integer_zero_node);\n   simplify_loop_decl_cond (&FOR_COND (for_stmt), FOR_BODY (for_stmt));\n }\n "}, {"sha": "1a37615dcc07bdb8d033f9dde21d10776a1c7707", "filename": "gcc/doc/generic.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fdoc%2Fgeneric.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fdoc%2Fgeneric.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgeneric.texi?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -1695,7 +1695,7 @@ its sole argument yields the representation for @code{ap}.\n @item ANNOTATE_EXPR\n This node is used to attach markers to an expression. The first operand\n is the annotated expression, the second is an @code{INTEGER_CST} with\n-a value from @code{enum annot_expr_kind}.\n+a value from @code{enum annot_expr_kind}, the third is an @code{INTEGER_CST}.\n @end table\n \n "}, {"sha": "a05bf83ee67a1c79c505c84a8be0e9b7faeb3635", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -1,3 +1,9 @@\n+2017-11-23  Mike Stump  <mikestump@comcast.net>\n+\t    Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* trans-stmt.c (gfc_trans_forall_loop): Pass 3rd operand to\n+\tANNOTATE_EXPR.\n+\n 2017-11-23  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/82814"}, {"sha": "96ca21756742514d635bbe45678a917a05d10d47", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -3459,9 +3459,10 @@ gfc_trans_forall_loop (forall_info *forall_tmp, tree body,\n       cond = fold_build2_loc (input_location, LE_EXPR, logical_type_node,\n \t\t\t      count, build_int_cst (TREE_TYPE (count), 0));\n       if (forall_tmp->do_concurrent)\n-\tcond = build2 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n+\tcond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n \t\t       build_int_cst (integer_type_node,\n-\t\t\t\t      annot_expr_parallel_kind));\n+\t\t\t\t      annot_expr_parallel_kind),\n+\t\t       integer_zero_node);\n \n       tmp = build1_v (GOTO_EXPR, exit_label);\n       tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,"}, {"sha": "32c9893cd5948d3650faebd2d4ff36c6b6e77875", "filename": "gcc/function.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -385,8 +385,11 @@ struct GTY(()) function {\n      nonzero value in loop->simduid.  */\n   unsigned int has_simduid_loops : 1;\n \n-  /* Set when the tail call has been identified.  */\n+  /* Nonzero when the tail call has been identified.  */\n   unsigned int tail_call_marked : 1;\n+\n+  /* Nonzero if the current function contains a #pragma GCC unroll.  */\n+  unsigned int has_unroll : 1;\n };\n \n /* Add the decl D to the local_decls list of FUN.  */"}, {"sha": "13dbbe0538d2faa9ce51f43e04930038eb9b11ca", "filename": "gcc/gimplify.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -3747,6 +3747,7 @@ gimple_boolify (tree expr)\n       switch ((enum annot_expr_kind) TREE_INT_CST_LOW (TREE_OPERAND (expr, 1)))\n \t{\n \tcase annot_expr_ivdep_kind:\n+\tcase annot_expr_unroll_kind:\n \tcase annot_expr_no_vector_kind:\n \tcase annot_expr_vector_kind:\n \tcase annot_expr_parallel_kind:\n@@ -11390,6 +11391,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  {\n \t    tree cond = TREE_OPERAND (*expr_p, 0);\n \t    tree kind = TREE_OPERAND (*expr_p, 1);\n+\t    tree data = TREE_OPERAND (*expr_p, 2);\n \t    tree type = TREE_TYPE (cond);\n \t    if (!INTEGRAL_TYPE_P (type))\n \t      {\n@@ -11400,7 +11402,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t    tree tmp = create_tmp_var (type);\n \t    gimplify_arg (&cond, pre_p, EXPR_LOCATION (*expr_p));\n \t    gcall *call\n-\t      = gimple_build_call_internal (IFN_ANNOTATE, 2, cond, kind);\n+\t      = gimple_build_call_internal (IFN_ANNOTATE, 3, cond, kind, data);\n \t    gimple_call_set_lhs (call, tmp);\n \t    gimplify_seq_add_stmt (pre_p, call);\n \t    *expr_p = tmp;"}, {"sha": "fd5069caa29b2e9df7ccdc4f9a1d0784299839c9", "filename": "gcc/loop-init.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -361,8 +361,8 @@ pass_loop2::gate (function *fun)\n       && (flag_move_loop_invariants\n \t  || flag_unswitch_loops\n \t  || flag_unroll_loops\n-\t  || (flag_branch_on_count_reg\n-\t      && targetm.have_doloop_end ())))\n+\t  || (flag_branch_on_count_reg && targetm.have_doloop_end ())\n+\t  || cfun->has_unroll))\n     return true;\n   else\n     {\n@@ -560,7 +560,7 @@ class pass_rtl_unroll_loops : public rtl_opt_pass\n   /* opt_pass methods: */\n   virtual bool gate (function *)\n     {\n-      return (flag_unroll_loops || flag_unroll_all_loops);\n+      return (flag_unroll_loops || flag_unroll_all_loops || cfun->has_unroll);\n     }\n \n   virtual unsigned int execute (function *);"}, {"sha": "bbba35fbff1e4b466051b0a3d34087a45c03f9fc", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 64, "deletions": 39, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -224,9 +224,16 @@ decide_unrolling (int flags)\n \n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, locus,\n-                         \";; *** Considering loop %d at BB %d for \"\n-                         \"unrolling ***\\n\",\n-                         loop->num, loop->header->index);\n+\t\t\t \"considering unrolling loop %d at BB %d\\n\",\n+\t\t\t loop->num, loop->header->index);\n+\n+      if (loop->unroll == 1)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \";; Not unrolling loop, user didn't want it unrolled\\n\");\n+\t  continue;\n+\t}\n \n       /* Do not peel cold areas.  */\n       if (optimize_loop_for_size_p (loop))\n@@ -256,9 +263,7 @@ decide_unrolling (int flags)\n       loop->ninsns = num_loop_insns (loop);\n       loop->av_ninsns = average_num_loop_insns (loop);\n \n-      /* Try transformations one by one in decreasing order of\n-\t priority.  */\n-\n+      /* Try transformations one by one in decreasing order of priority.  */\n       decide_unroll_constant_iterations (loop, flags);\n       if (loop->lpt_decision.decision == LPT_NONE)\n \tdecide_unroll_runtime_iterations (loop, flags);\n@@ -347,19 +352,17 @@ decide_unroll_constant_iterations (struct loop *loop, int flags)\n   struct niter_desc *desc;\n   widest_int iterations;\n \n-  if (!(flags & UAP_UNROLL))\n-    {\n-      /* We were not asked to, just return back silently.  */\n-      return;\n-    }\n+  /* If we were not asked to unroll this loop, just return back silently.  */\n+  if (!(flags & UAP_UNROLL) && !loop->unroll)\n+    return;\n \n-  if (dump_file)\n-    fprintf (dump_file,\n-\t     \"\\n;; Considering unrolling loop with constant \"\n-\t     \"number of iterations\\n\");\n+  if (dump_enabled_p ())\n+    dump_printf (MSG_NOTE,\n+\t\t \"considering unrolling loop with constant \"\n+\t\t \"number of iterations\\n\");\n \n   /* nunroll = total number of copies of the original loop body in\n-     unrolled loop (i.e. if it is 2, we have to duplicate loop body once.  */\n+     unrolled loop (i.e. if it is 2, we have to duplicate loop body once).  */\n   nunroll = PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS) / loop->ninsns;\n   nunroll_by_av\n     = PARAM_VALUE (PARAM_MAX_AVERAGE_UNROLLED_INSNS) / loop->av_ninsns;\n@@ -391,6 +394,24 @@ decide_unroll_constant_iterations (struct loop *loop, int flags)\n       return;\n     }\n \n+  /* Check for an explicit unrolling factor.  */\n+  if (loop->unroll)\n+    {\n+      /* However we cannot unroll completely at the RTL level a loop with\n+\t constant number of iterations; it should have been peeled instead.  */\n+      if ((unsigned) loop->unroll - 1 > desc->niter - 2)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \";; Loop should have been peeled\\n\");\n+\t}\n+      else\n+\t{\n+\t  loop->lpt_decision.decision = LPT_UNROLL_CONSTANT;\n+\t  loop->lpt_decision.times = loop->unroll - 1;\n+\t}\n+      return;\n+    }\n+\n   /* Check whether the loop rolls enough to consider.  \n      Consult also loop bounds and profile; in the case the loop has more\n      than one exit it may well loop less than determined maximal number\n@@ -412,7 +433,7 @@ decide_unroll_constant_iterations (struct loop *loop, int flags)\n   best_copies = 2 * nunroll + 10;\n \n   i = 2 * nunroll + 2;\n-  if (i - 1 >= desc->niter)\n+  if (i > desc->niter - 2)\n     i = desc->niter - 2;\n \n   for (; i >= nunroll - 1; i--)\n@@ -651,16 +672,14 @@ decide_unroll_runtime_iterations (struct loop *loop, int flags)\n   struct niter_desc *desc;\n   widest_int iterations;\n \n-  if (!(flags & UAP_UNROLL))\n-    {\n-      /* We were not asked to, just return back silently.  */\n-      return;\n-    }\n+  /* If we were not asked to unroll this loop, just return back silently.  */\n+  if (!(flags & UAP_UNROLL) && !loop->unroll)\n+    return;\n \n-  if (dump_file)\n-    fprintf (dump_file,\n-\t     \"\\n;; Considering unrolling loop with runtime \"\n-\t     \"computable number of iterations\\n\");\n+  if (dump_enabled_p ())\n+    dump_printf (MSG_NOTE,\n+\t\t \"considering unrolling loop with runtime-\"\n+\t\t \"computable number of iterations\\n\");\n \n   /* nunroll = total number of copies of the original loop body in\n      unrolled loop (i.e. if it is 2, we have to duplicate loop body once.  */\n@@ -674,6 +693,9 @@ decide_unroll_runtime_iterations (struct loop *loop, int flags)\n   if (targetm.loop_unroll_adjust)\n     nunroll = targetm.loop_unroll_adjust (nunroll, loop);\n \n+  if (loop->unroll)\n+    nunroll = loop->unroll;\n+\n   /* Skip big loops.  */\n   if (nunroll <= 1)\n     {\n@@ -712,8 +734,9 @@ decide_unroll_runtime_iterations (struct loop *loop, int flags)\n       return;\n     }\n \n-  /* Success; now force nunroll to be power of 2, as we are unable to\n-     cope with overflows in computation of number of iterations.  */\n+  /* Success; now force nunroll to be power of 2, as code-gen\n+     requires it, we are unable to cope with overflows in\n+     computation of number of iterations.  */\n   for (i = 1; 2 * i <= nunroll; i *= 2)\n     continue;\n \n@@ -824,9 +847,10 @@ compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp,\n   return seq;\n }\n \n-/* Unroll LOOP for which we are able to count number of iterations in runtime\n-   LOOP->LPT_DECISION.TIMES times.  The transformation does this (with some\n-   extra care for case n < 0):\n+/* Unroll LOOP for which we are able to count number of iterations in\n+   runtime LOOP->LPT_DECISION.TIMES times.  The times value must be a\n+   power of two.  The transformation does this (with some extra care\n+   for case n < 0):\n \n    for (i = 0; i < n; i++)\n      body;\n@@ -1133,14 +1157,12 @@ decide_unroll_stupid (struct loop *loop, int flags)\n   struct niter_desc *desc;\n   widest_int iterations;\n \n-  if (!(flags & UAP_UNROLL_ALL))\n-    {\n-      /* We were not asked to, just return back silently.  */\n-      return;\n-    }\n+  /* If we were not asked to unroll this loop, just return back silently.  */\n+  if (!(flags & UAP_UNROLL_ALL) && !loop->unroll)\n+    return;\n \n-  if (dump_file)\n-    fprintf (dump_file, \"\\n;; Considering unrolling loop stupidly\\n\");\n+  if (dump_enabled_p ())\n+    dump_printf (MSG_NOTE, \"considering unrolling loop stupidly\\n\");\n \n   /* nunroll = total number of copies of the original loop body in\n      unrolled loop (i.e. if it is 2, we have to duplicate loop body once.  */\n@@ -1155,6 +1177,9 @@ decide_unroll_stupid (struct loop *loop, int flags)\n   if (targetm.loop_unroll_adjust)\n     nunroll = targetm.loop_unroll_adjust (nunroll, loop);\n \n+  if (loop->unroll)\n+    nunroll = loop->unroll;\n+\n   /* Skip big loops.  */\n   if (nunroll <= 1)\n     {\n@@ -1170,7 +1195,7 @@ decide_unroll_stupid (struct loop *loop, int flags)\n   if (desc->simple_p && !desc->assumptions)\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \";; The loop is simple\\n\");\n+\tfprintf (dump_file, \";; Loop is simple\\n\");\n       return;\n     }\n "}, {"sha": "fd6bd06ffb2219c2f553a59b2800eb5c450426db", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -825,6 +825,7 @@ input_cfg (struct lto_input_block *ib, struct data_in *data_in,\n \n       /* Read OMP SIMD related info.  */\n       loop->safelen = streamer_read_hwi (ib);\n+      loop->unroll = streamer_read_hwi (ib);\n       loop->dont_vectorize = streamer_read_hwi (ib);\n       loop->force_vectorize = streamer_read_hwi (ib);\n       loop->simduid = stream_read_tree (ib, data_in);"}, {"sha": "0442ec72d06d0ea69885bcfb7d251081add7c02f", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -1931,6 +1931,7 @@ output_cfg (struct output_block *ob, struct function *fn)\n \n       /* Write OMP SIMD related info.  */\n       streamer_write_hwi (ob, loop->safelen);\n+      streamer_write_hwi (ob, loop->unroll);\n       streamer_write_hwi (ob, loop->dont_vectorize);\n       streamer_write_hwi (ob, loop->force_vectorize);\n       stream_write_tree (ob, loop->simduid, true);"}, {"sha": "34d31b88760915e758e8c5d8aaf720b240e9a3db", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -1,3 +1,28 @@\n+2017-11-23  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* testsuite/gcc.dg/pr64277.c: Adjust scan.\n+\t* gcc.dg/tree-prof/unroll-1.c: Use detailed dump and adjust scan.\n+\t* gcc.dg/tree-ssa/cunroll-1.c: Adjust scan.\n+\t* gcc.dg/tree-ssa/cunroll-12.c: Likewise.\n+\t* gcc.dg/tree-ssa/cunroll-13.c: Likewise.\n+\t* gcc.dg/tree-ssa/cunroll-14.c: Likewise.\n+\t* gcc.dg/tree-ssa/cunroll-2.c: Likewise.\n+\t* gcc.dg/tree-ssa/cunroll-3.c: Likewise.\n+\t* gcc.dg/tree-ssa/cunroll-5.c: Likewise.\n+\t* gcc.dg/tree-ssa/loop-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/loop-23.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr61743-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr61743-2.c: Likewise.\n+\t* gcc.dg/unroll-2.c (foo): Adjust message.\n+\t(foo2): Likewise.\n+\t* gcc.dg/unroll-3.c: Adjust scan.\n+\t* gcc.dg/unroll-4.c: Likewise.\n+\t* gcc.dg/unroll-5.c: Likewise.\n+\t* gcc.dg/unroll-7.c: Use detailed dump and adjust scan.\n+\t* gnat.dg/unroll1.ad[sb]: New test.\n+\t* gnat.dg/unroll2.ad[sb]: Likewise.\n+\t* gnat.dg/unroll3.ad[sb]: Likewise.\n+\n 2017-11-23  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* gcc.dg/ipa/inline-1.c: Update template."}, {"sha": "aebb0fe19d6204add5af2a436d28dafd43ed0698", "filename": "gcc/testsuite/gcc.dg/pr64277.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Fpr64277.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Fpr64277.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr64277.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -1,8 +1,8 @@\n /* PR tree-optimization/64277 */\n /* { dg-do compile } */\n /* { dg-options \"-O3 -Wall -Werror -fdump-tree-cunroll-details\" } */\n+/* { dg-final { scan-tree-dump \"loop with 4 iterations completely unrolled\" \"cunroll\" } } */\n /* { dg-final { scan-tree-dump \"loop with 5 iterations completely unrolled\" \"cunroll\" } } */\n-/* { dg-final { scan-tree-dump \"loop with 6 iterations completely unrolled\" \"cunroll\" } } */\n \n #if __SIZEOF_INT__ < 4\n   __extension__ typedef __INT32_TYPE__ int32_t;"}, {"sha": "3ad0cf019b3458c445151ff5f1db1f76aa0a3760", "filename": "gcc/testsuite/gcc.dg/tree-prof/unroll-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Funroll-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Funroll-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Funroll-1.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O3 -fdump-rtl-loop2_unroll -funroll-loops -fno-peel-loops\" } */\n+/* { dg-options \"-O3 -fdump-rtl-loop2_unroll-details -funroll-loops -fno-peel-loops\" } */\n void abort ();\n \n int a[1000];\n@@ -20,4 +20,4 @@ main()\n     t();\n   return 0;\n }\n-/* { dg-final-use { scan-rtl-dump \"Considering unrolling loop with constant number of iterations\" \"loop2_unroll\" } } */\n+/* { dg-final-use { scan-rtl-dump \"considering unrolling loop with constant number of iterations\" \"loop2_unroll\" } } */"}, {"sha": "bcafbfe86b506a6c156209e61f440c318d0836de", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-1.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -9,5 +9,5 @@ test(int c)\n     a[i]=5;\n }\n /* Array bounds says the loop will not roll much.  */\n-/* { dg-final { scan-tree-dump \"loop with 3 iterations completely unrolled\" \"cunrolli\"} } */\n+/* { dg-final { scan-tree-dump \"loop with 2 iterations completely unrolled\" \"cunrolli\"} } */\n /* { dg-final { scan-tree-dump \"Last iteration exit edge was proved true.\" \"cunrolli\"} } */"}, {"sha": "aa472a6f0ad842ece8302130be7853f7f16f900f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-12.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-12.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -7,5 +7,5 @@ t(struct a *a)\n   for (int i=0;a->a[i];i++)\n     a->a[i]++;\n }\n-/* { dg-final { scan-tree-dump-times \"loop with 7 iterations completely unrolled\" 1 \"cunroll\" } } */\n+/* { dg-final { scan-tree-dump-times \"loop with 6 iterations completely unrolled\" 1 \"cunroll\" } } */\n /* { dg-final { scan-tree-dump-not \"Invalid sum\" \"cunroll\" } } */"}, {"sha": "dcc19f552d8dc69f7c142eb30599f278601a0575", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-13.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-13.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -19,5 +19,5 @@ t(struct a *a)\n /* { dg-final { scan-tree-dump-times \"Loop 1 iterates 123454 times\" 1 \"cunroll\" } } */\n /* { dg-final { scan-tree-dump-times \"Last iteration exit edge was proved true\" 1 \"cunroll\" } } */\n /* { dg-final { scan-tree-dump-times \"Exit condition of peeled iterations was eliminated\" 1 \"cunroll\" } } */\n-/* { dg-final { scan-tree-dump-times \"loop with 7 iterations completely unrolled\" 1 \"cunroll\" } } */\n+/* { dg-final { scan-tree-dump-times \"loop with 6 iterations completely unrolled\" 1 \"cunroll\" } } */\n /* { dg-final { scan-tree-dump-not \"Invalid sum\" \"cunroll\" } } */"}, {"sha": "5f112da310c8354eb9698b6d964700d73a043735", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-14.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-14.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -7,7 +7,7 @@ t(struct a *a)\n   for (int i=0;i<5 && a->a[i];i++)\n     a->a[i]++;\n }\n-/* { dg-final { scan-tree-dump-times \"loop with 5 iterations completely unrolled\" 1 \"cunroll\" } } */\n+/* { dg-final { scan-tree-dump-times \"loop with 4 iterations completely unrolled\" 1 \"cunroll\" } } */\n /* { dg-final { scan-tree-dump-not \"Invalid sum\" \"cunroll\" } } */\n /* { dg-final { scan-tree-dump-times \"Loop 1 iterates 4 times\" 1 \"cunroll\" } } */\n /* { dg-final { scan-tree-dump-times \"Last iteration exit edge was proved true\" 1 \"cunroll\" } } */"}, {"sha": "b1d1c7d3d852c00ca269ab9fe49f717bf42a562c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-2.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -14,4 +14,4 @@ test(int c)\n     }\n }\n /* We are not able to get rid of the final conditional because the loop has two exits.  */\n-/* { dg-final { scan-tree-dump \"loop with 2 iterations completely unrolled\" \"cunroll\"} } */\n+/* { dg-final { scan-tree-dump \"loop with 1 iterations completely unrolled\" \"cunroll\"} } */"}, {"sha": "e25c638ac5149d3508a89d24b10e1aa9abbd6f68", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-3.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -12,4 +12,4 @@ test(int c)\n }\n /* If we start duplicating headers prior curoll, this loop will have 0 iterations.  */\n \n-/* { dg-final { scan-tree-dump \"loop with 2 iterations completely unrolled\" \"cunrolli\"} } */\n+/* { dg-final { scan-tree-dump \"loop with 1 iterations completely unrolled\" \"cunrolli\"} } */"}, {"sha": "8ec4a029b1da4c57494213489ae867da9cd514aa", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-5.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -9,6 +9,6 @@ test(int c)\n     a[i]=5;\n }\n /* Basic testcase for complette unrolling.  */\n-/* { dg-final { scan-tree-dump \"loop with 6 iterations completely unrolled\" \"cunroll\"} } */\n+/* { dg-final { scan-tree-dump \"loop with 5 iterations completely unrolled\" \"cunroll\"} } */\n /* { dg-final { scan-tree-dump \"Exit condition of peeled iterations was eliminated.\" \"cunroll\"} } */\n /* { dg-final { scan-tree-dump \"Last iteration exit edge was proved true.\" \"cunroll\"} } */"}, {"sha": "18627505180bfdbfd2da263fdc722639c633c0fb", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-1.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -34,7 +34,7 @@ int xxx(void)\n /* We should be able to find out that the loop iterates four times and unroll it completely.  */\n \n /* { dg-final { scan-tree-dump-times \"Added canonical iv to loop 1, 4 iterations\" 1 \"ivcanon\"} } */\n-/* { dg-final { scan-tree-dump-times \"loop with 5 iterations completely unrolled\" 1 \"cunroll\"} } */\n+/* { dg-final { scan-tree-dump-times \"loop with 4 iterations completely unrolled\" 1 \"cunroll\"} } */\n /* { dg-final { scan-tree-dump-times \"foo\" 5 \"optimized\"} } */\n \n /* Because hppa, ia64 and Windows targets include an external declaration"}, {"sha": "4feada3e311f7df9b1818d074b53fd10b235ed2a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-23.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-23.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -24,5 +24,4 @@ int foo(void)\n   return sum;\n }\n \n-/* { dg-final { scan-tree-dump-times \"loop with 4 iterations completely unrolled\" 1 \"cunroll\" } } */\n-\n+/* { dg-final { scan-tree-dump-times \"loop with 3 iterations completely unrolled\" 1 \"cunroll\" } } */"}, {"sha": "f7cbda6832474e881aaae36ec2c82b5fd65d2c68", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr61743-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr61743-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr61743-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr61743-1.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -48,5 +48,5 @@ int foo1 (e_u8 a[4][N], int b1, int b2, e_u8 b[M+1][4][N])\n   return 0;\r\n }\r\n \r\n-/* { dg-final { scan-tree-dump-times \"loop with 4 iterations completely unrolled\" 8 \"cunroll\" } } */\r\n-/* { dg-final { scan-tree-dump-times \"loop with 9 iterations completely unrolled\" 2 \"cunrolli\" } } */\r\n+/* { dg-final { scan-tree-dump-times \"loop with 3 iterations completely unrolled\" 8 \"cunroll\" } } */\r\n+/* { dg-final { scan-tree-dump-times \"loop with 8 iterations completely unrolled\" 2 \"cunrolli\" } } */\r"}, {"sha": "b16e63129485a2fe8acf8ef67b5e42836cc8afac", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr61743-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr61743-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr61743-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr61743-2.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -48,5 +48,5 @@ int foo1 (e_u8 a[4][N], int b1, int b2, e_u8 b[M+1][4][N])\n   return 0;\r\n }\r\n \r\n-/* { dg-final { scan-tree-dump-times \"loop with 4 iterations completely unrolled\" 2 \"cunroll\" } } */\r\n-/* { dg-final { scan-tree-dump-times \"loop with 8 iterations completely unrolled\" 2 \"cunroll\" } } */\r\n+/* { dg-final { scan-tree-dump-times \"loop with 3 iterations completely unrolled\" 2 \"cunroll\" } } */\r\n+/* { dg-final { scan-tree-dump-times \"loop with 7 iterations completely unrolled\" 2 \"cunroll\" } } */\r"}, {"sha": "46126c303562e9640ce44ec0d8262e4bcf5be922", "filename": "gcc/testsuite/gcc.dg/unroll-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-2.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -15,7 +15,7 @@ int foo(void)\n {\n   int i;\n   bar();\n-  for (i = 0; i < 2; i++) /* { dg-message \"note: loop with 3 iterations completely unrolled\" } */\n+  for (i = 0; i < 2; i++) /* { dg-message \"note: loop with 2 iterations completely unrolled\" } */\n   {\n      a[i]= b[i] + 1;\n   }\n@@ -25,7 +25,7 @@ int foo(void)\n int foo2(void)\n {\n   int i;\n-  for (i = 0; i < 2; i++) /* { dg-message \"note: loop with 3 iterations completely unrolled\" } */\n+  for (i = 0; i < 2; i++) /* { dg-message \"note: loop with 2 iterations completely unrolled\" } */\n   {\n      a[i]= b[i] + 1;\n   }"}, {"sha": "10bf59b9a2e72ea879d1a8fb3eee02f2d85f6811", "filename": "gcc/testsuite/gcc.dg/unroll-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-3.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -28,4 +28,4 @@ int foo2(void)\n   return 1;\n }\n \n-/* { dg-final { scan-tree-dump-times \"loop with 3 iterations completely unrolled\" 1 \"cunrolli\" } } */\n+/* { dg-final { scan-tree-dump-times \"loop with 2 iterations completely unrolled\" 1 \"cunrolli\" } } */"}, {"sha": "17f194212279560b4c2883b19c00aa271d970d99", "filename": "gcc/testsuite/gcc.dg/unroll-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-4.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -28,4 +28,4 @@ int foo2(void)\n   return 1;\n }\n \n-/* { dg-final { scan-tree-dump-times \"loop with 3 iterations completely unrolled\" 1 \"cunrolli\" } } */\n+/* { dg-final { scan-tree-dump-times \"loop with 2 iterations completely unrolled\" 1 \"cunrolli\" } } */"}, {"sha": "f3bdebe9882f2c42149b9472c0a8b299b8da7af3", "filename": "gcc/testsuite/gcc.dg/unroll-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-5.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -28,4 +28,4 @@ int foo2(void)\n   return 1;\n }\n \n-/* { dg-final { scan-tree-dump-times \"loop with 3 iterations completely unrolled\" 1 \"cunrolli\" } } */\n+/* { dg-final { scan-tree-dump-times \"loop with 2 iterations completely unrolled\" 1 \"cunrolli\" } } */"}, {"sha": "055369bf8b14a3bef7da5ef87abe2075d4504559", "filename": "gcc/testsuite/gcc.dg/unroll-7.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-7.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-rtl-loop2_unroll -funroll-loops\" } */\n+/* { dg-options \"-O2 -fdump-rtl-loop2_unroll-details -funroll-loops\" } */\n /* { dg-require-effective-target int32plus } */\n \n extern int *a;\n@@ -14,5 +14,5 @@ int t(void)\n /* { dg-final { scan-rtl-dump \"number of iterations: .const_int 999999\" \"loop2_unroll\" } } */\n /* { dg-final { scan-rtl-dump \"upper bound: 999999\" \"loop2_unroll\" } } */\n /* { dg-final { scan-rtl-dump \"realistic bound: 999999\" \"loop2_unroll\" } } */\n-/* { dg-final { scan-rtl-dump \"Considering unrolling loop with constant number of iterations\" \"loop2_unroll\" } } */\n+/* { dg-final { scan-rtl-dump \"considering unrolling loop with constant number of iterations\" \"loop2_unroll\" } } */\n /* { dg-final { scan-rtl-dump-not \"Invalid sum\" \"loop2_unroll\" } } */"}, {"sha": "ff9222de0e0208a73357533587fd5d391b4253a2", "filename": "gcc/testsuite/gnat.dg/unroll1.adb", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgnat.dg%2Funroll1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgnat.dg%2Funroll1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Funroll1.adb?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -0,0 +1,27 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O2 -funroll-all-loops -fdump-rtl-loop2_unroll-details -fdump-tree-cunrolli-details\" }\n+\n+package body Unroll1 is\n+\n+   function \"+\" (X, Y : Sarray) return Sarray is\n+      R : Sarray;\n+   begin\n+      for I in Sarray'Range loop\n+         pragma Loop_Optimize (No_Unroll);\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X, Y : Sarray; R : out Sarray) is\n+   begin\n+      for I in Sarray'Range loop\n+         pragma Loop_Optimize (No_Unroll);\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+   end;\n+\n+end Unroll1;\n+\n+-- { dg-final { scan-tree-dump-times \"Not unrolling loop .: user didn't want it unrolled completely\" 2 \"cunrolli\" } } */\n+-- { dg-final { scan-rtl-dump-times \"Not unrolling loop, user didn't want it unrolled\" 2 \"loop2_unroll\" } } */"}, {"sha": "28dbea8a9c0e79aec5ee62438c06520e4a809a46", "filename": "gcc/testsuite/gnat.dg/unroll1.ads", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgnat.dg%2Funroll1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgnat.dg%2Funroll1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Funroll1.ads?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -0,0 +1,9 @@\n+package Unroll1 is\n+\n+   type Sarray is array (1 .. 4) of Float;\n+   for Sarray'Alignment use 16;\n+\n+   function \"+\" (X, Y : Sarray) return Sarray;\n+   procedure Add (X, Y : Sarray; R : out Sarray);\n+\n+end Unroll1;"}, {"sha": "01af9d2b788cf7e425427ca22b96874fed064673", "filename": "gcc/testsuite/gnat.dg/unroll2.adb", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgnat.dg%2Funroll2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgnat.dg%2Funroll2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Funroll2.adb?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -0,0 +1,26 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O2 -fdump-tree-cunrolli-details\" }\n+\n+package body Unroll2 is\n+\n+   function \"+\" (X, Y : Sarray) return Sarray is\n+      R : Sarray;\n+   begin\n+      for I in Sarray'Range loop\n+         pragma Loop_Optimize (Unroll);\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X, Y : Sarray; R : out Sarray) is\n+   begin\n+      for I in Sarray'Range loop\n+         pragma Loop_Optimize (Unroll);\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+   end;\n+\n+end Unroll2;\n+\n+-- { dg-final { scan-tree-dump-times \"note: loop with 3 iterations completely unrolled\" 2 \"cunrolli\" } } */"}, {"sha": "efae982c4c6640102c5f7fd471e03fec59313465", "filename": "gcc/testsuite/gnat.dg/unroll2.ads", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgnat.dg%2Funroll2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgnat.dg%2Funroll2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Funroll2.ads?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -0,0 +1,9 @@\n+package Unroll2 is\n+\n+   type Sarray is array (1 .. 4) of Float;\n+   for Sarray'Alignment use 16;\n+\n+   function \"+\" (X, Y : Sarray) return Sarray;\n+   procedure Add (X, Y : Sarray; R : out Sarray);\n+\n+end Unroll2;"}, {"sha": "3a0725b80931cd438875c35e34927ed7f900ab3b", "filename": "gcc/testsuite/gnat.dg/unroll3.adb", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgnat.dg%2Funroll3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgnat.dg%2Funroll3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Funroll3.adb?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -0,0 +1,26 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O -fdump-tree-cunroll-details\" }\n+\n+package body Unroll3 is\n+\n+   function \"+\" (X, Y : Sarray) return Sarray is\n+      R : Sarray;\n+   begin\n+      for I in Sarray'Range loop\n+         pragma Loop_Optimize (Unroll);\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X, Y : Sarray; R : out Sarray) is\n+   begin\n+      for I in Sarray'Range loop\n+         pragma Loop_Optimize (Unroll);\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+   end;\n+\n+end Unroll3;\n+\n+-- { dg-final { scan-tree-dump-times \"note: loop with 3 iterations completely unrolled\" 2 \"cunroll\" } } */"}, {"sha": "8264fc7b489aeee9f4376748afceadfc72058752", "filename": "gcc/testsuite/gnat.dg/unroll3.ads", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgnat.dg%2Funroll3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftestsuite%2Fgnat.dg%2Funroll3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Funroll3.ads?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -0,0 +1,9 @@\n+package Unroll3 is\n+\n+   type Sarray is array (1 .. 4) of Float;\n+   for Sarray'Alignment use 16;\n+\n+   function \"+\" (X, Y : Sarray) return Sarray;\n+   procedure Add (X, Y : Sarray; R : out Sarray);\n+\n+end Unroll3;"}, {"sha": "2835a4b722c21f0ced3542a505cdd56fae0bb37d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -280,6 +280,11 @@ replace_loop_annotate_in_block (basic_block bb, struct loop *loop)\n \tcase annot_expr_ivdep_kind:\n \t  loop->safelen = INT_MAX;\n \t  break;\n+\tcase annot_expr_unroll_kind:\n+\t  loop->unroll\n+\t    = (unsigned short) tree_to_shwi (gimple_call_arg (stmt, 2));\n+\t  cfun->has_unroll = true;\n+\t  break;\n \tcase annot_expr_no_vector_kind:\n \t  loop->dont_vectorize = true;\n \t  break;\n@@ -338,6 +343,7 @@ replace_loop_annotate (void)\n \t  switch ((annot_expr_kind) tree_to_shwi (gimple_call_arg (stmt, 1)))\n \t    {\n \t    case annot_expr_ivdep_kind:\n+\t    case annot_expr_unroll_kind:\n \t    case annot_expr_no_vector_kind:\n \t    case annot_expr_vector_kind:\n \t      break;\n@@ -8019,6 +8025,8 @@ print_loop (FILE *file, struct loop *loop, int indent, int verbosity)\n       fprintf (file, \", estimate = \");\n       print_decu (loop->nb_iterations_estimate, file);\n     }\n+  if (loop->unroll)\n+    fprintf (file, \", unroll = %d\", loop->unroll);\n   fprintf (file, \")\\n\");\n \n   /* Print loop's body.  */"}, {"sha": "a2633af478e421c25021ff3cc960765765a7e7f4", "filename": "gcc/tree-core.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -851,6 +851,7 @@ enum tree_node_kind {\n \n enum annot_expr_kind {\n   annot_expr_ivdep_kind,\n+  annot_expr_unroll_kind,\n   annot_expr_no_vector_kind,\n   annot_expr_vector_kind,\n   annot_expr_parallel_kind,"}, {"sha": "ca98e43327ec44feb4c22df61e8a6a416aa42e68", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -2597,6 +2597,11 @@ copy_loops (copy_body_data *id,\n \t  flow_loop_tree_node_add (dest_parent, dest_loop);\n \n \t  dest_loop->safelen = src_loop->safelen;\n+\t  if (src_loop->unroll)\n+\t    {\n+\t      dest_loop->unroll = src_loop->unroll;\n+\t      cfun->has_unroll = true;\n+\t    }\n \t  dest_loop->dont_vectorize = src_loop->dont_vectorize;\n \t  if (src_loop->force_vectorize)\n \t    {"}, {"sha": "c9a3e6360e0337808549481eb86b7afd129d8b04", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -2633,6 +2633,10 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n \tcase annot_expr_ivdep_kind:\n \t  pp_string (pp, \", ivdep\");\n \t  break;\n+\tcase annot_expr_unroll_kind:\n+\t  pp_printf (pp, \", unroll %d\",\n+\t\t     (int) TREE_INT_CST_LOW (TREE_OPERAND (node, 2)));\n+\t  break;\n \tcase annot_expr_no_vector_kind:\n \t  pp_string (pp, \", no-vector\");\n \t  break;"}, {"sha": "a32e12bee07d72a5a472bfba1640fccda6e7773e", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 152, "deletions": 126, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -681,11 +681,9 @@ try_unroll_loop_completely (struct loop *loop,\n \t\t\t    HOST_WIDE_INT maxiter,\n \t\t\t    location_t locus)\n {\n-  unsigned HOST_WIDE_INT n_unroll = 0, ninsns, unr_insns;\n-  struct loop_size size;\n+  unsigned HOST_WIDE_INT n_unroll = 0;\n   bool n_unroll_found = false;\n   edge edge_to_cancel = NULL;\n-  dump_flags_t report_flags = MSG_OPTIMIZED_LOCATIONS | TDF_DETAILS;\n \n   /* See if we proved number of iterations to be low constant.\n \n@@ -726,7 +724,8 @@ try_unroll_loop_completely (struct loop *loop,\n   if (!n_unroll_found)\n     return false;\n \n-  if (n_unroll > (unsigned) PARAM_VALUE (PARAM_MAX_COMPLETELY_PEEL_TIMES))\n+  if (!loop->unroll\n+      && n_unroll > (unsigned) PARAM_VALUE (PARAM_MAX_COMPLETELY_PEEL_TIMES))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Not unrolling loop %d \"\n@@ -740,121 +739,137 @@ try_unroll_loop_completely (struct loop *loop,\n \n   if (n_unroll)\n     {\n-      bool large;\n       if (ul == UL_SINGLE_ITER)\n \treturn false;\n \n-      /* EXIT can be removed only if we are sure it passes first N_UNROLL\n-\t iterations.  */\n-      bool remove_exit = (exit && niter\n-\t\t\t  && TREE_CODE (niter) == INTEGER_CST\n-\t\t\t  && wi::leu_p (n_unroll, wi::to_widest (niter)));\n-\n-      large = tree_estimate_loop_size\n-\t\t (loop, remove_exit ? exit : NULL, edge_to_cancel, &size,\n-\t\t  PARAM_VALUE (PARAM_MAX_COMPLETELY_PEELED_INSNS));\n-      ninsns = size.overall;\n-      if (large)\n+      if (loop->unroll)\n \t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"Not unrolling loop %d: it is too large.\\n\",\n-\t\t     loop->num);\n-\t  return false;\n+\t  /* If the unrolling factor is too large, bail out.  */\n+\t  if (n_unroll > (unsigned)loop->unroll)\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file,\n+\t\t\t \"Not unrolling loop %d: \"\n+\t\t\t \"user didn't want it unrolled completely.\\n\",\n+\t\t\t loop->num);\n+\t      return false;\n+\t    }\n \t}\n-\n-      unr_insns = estimated_unrolled_size (&size, n_unroll);\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n+      else\n \t{\n-\t  fprintf (dump_file, \"  Loop size: %d\\n\", (int) ninsns);\n-\t  fprintf (dump_file, \"  Estimated size after unrolling: %d\\n\",\n-\t\t   (int) unr_insns);\n-\t}\n+\t  struct loop_size size;\n+\t  /* EXIT can be removed only if we are sure it passes first N_UNROLL\n+\t     iterations.  */\n+\t  bool remove_exit = (exit && niter\n+\t\t\t      && TREE_CODE (niter) == INTEGER_CST\n+\t\t\t      && wi::leu_p (n_unroll, wi::to_widest (niter)));\n+\t  bool large\n+\t    = tree_estimate_loop_size\n+\t\t(loop, remove_exit ? exit : NULL, edge_to_cancel, &size,\n+\t\t PARAM_VALUE (PARAM_MAX_COMPLETELY_PEELED_INSNS));\n+\t  if (large)\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Not unrolling loop %d: it is too large.\\n\",\n+\t\t\t loop->num);\n+\t      return false;\n+\t    }\n \n-      /* If the code is going to shrink, we don't need to be extra cautious\n-\t on guessing if the unrolling is going to be profitable.  */\n-      if (unr_insns\n-\t  /* If there is IV variable that will become constant, we save\n-\t     one instruction in the loop prologue we do not account\n-\t     otherwise.  */\n-\t  <= ninsns + (size.constant_iv != false))\n-\t;\n-      /* We unroll only inner loops, because we do not consider it profitable\n-\t otheriwse.  We still can cancel loopback edge of not rolling loop;\n-\t this is always a good idea.  */\n-      else if (ul == UL_NO_GROWTH)\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"Not unrolling loop %d: size would grow.\\n\",\n-\t\t     loop->num);\n-\t  return false;\n-\t}\n-      /* Outer loops tend to be less interesting candidates for complete\n-\t unrolling unless we can do a lot of propagation into the inner loop\n-\t body.  For now we disable outer loop unrolling when the code would\n-\t grow.  */\n-      else if (loop->inner)\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"Not unrolling loop %d: \"\n-\t\t     \"it is not innermost and code would grow.\\n\",\n-\t\t     loop->num);\n-\t  return false;\n-\t}\n-      /* If there is call on a hot path through the loop, then\n-\t there is most probably not much to optimize.  */\n-      else if (size.num_non_pure_calls_on_hot_path)\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"Not unrolling loop %d: \"\n-\t\t     \"contains call and code would grow.\\n\",\n-\t\t     loop->num);\n-\t  return false;\n-\t}\n-      /* If there is pure/const call in the function, then we\n-\t can still optimize the unrolled loop body if it contains\n-\t some other interesting code than the calls and code\n-\t storing or cumulating the return value.  */\n-      else if (size.num_pure_calls_on_hot_path\n-\t       /* One IV increment, one test, one ivtmp store\n-\t\t  and one useful stmt.  That is about minimal loop\n-\t\t  doing pure call.  */\n-\t       && (size.non_call_stmts_on_hot_path\n-\t\t   <= 3 + size.num_pure_calls_on_hot_path))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"Not unrolling loop %d: \"\n-\t\t     \"contains just pure calls and code would grow.\\n\",\n-\t\t     loop->num);\n-\t  return false;\n-\t}\n-      /* Complete unrolling is a major win when control flow is removed and\n-\t one big basic block is created.  If the loop contains control flow\n-\t the optimization may still be a win because of eliminating the loop\n-\t overhead but it also may blow the branch predictor tables.\n-\t Limit number of branches on the hot path through the peeled\n-\t sequence.  */\n-      else if (size.num_branches_on_hot_path * (int)n_unroll\n-\t       > PARAM_VALUE (PARAM_MAX_PEEL_BRANCHES))\n-\t{\n+\t  unsigned HOST_WIDE_INT ninsns = size.overall;\n+\t  unsigned HOST_WIDE_INT unr_insns\n+\t    = estimated_unrolled_size (&size, n_unroll);\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"Not unrolling loop %d: \"\n-\t\t     \" number of branches on hot path in the unrolled sequence\"\n-\t\t     \" reach --param max-peel-branches limit.\\n\",\n-\t\t     loop->num);\n-\t  return false;\n-\t}\n-      else if (unr_insns\n-\t       > (unsigned) PARAM_VALUE (PARAM_MAX_COMPLETELY_PEELED_INSNS))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"Not unrolling loop %d: \"\n-\t\t     \"(--param max-completely-peeled-insns limit reached).\\n\",\n-\t\t     loop->num);\n-\t  return false;\n+\t    {\n+\t      fprintf (dump_file, \"  Loop size: %d\\n\", (int) ninsns);\n+\t      fprintf (dump_file, \"  Estimated size after unrolling: %d\\n\",\n+\t\t       (int) unr_insns);\n+\t    }\n+\n+\t  /* If the code is going to shrink, we don't need to be extra\n+\t     cautious on guessing if the unrolling is going to be\n+\t     profitable.  */\n+\t  if (unr_insns\n+\t      /* If there is IV variable that will become constant, we\n+\t\t save one instruction in the loop prologue we do not\n+\t\t account otherwise.  */\n+\t      <= ninsns + (size.constant_iv != false))\n+\t    ;\n+\t  /* We unroll only inner loops, because we do not consider it\n+\t     profitable otheriwse.  We still can cancel loopback edge\n+\t     of not rolling loop; this is always a good idea.  */\n+\t  else if (ul == UL_NO_GROWTH)\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Not unrolling loop %d: size would grow.\\n\",\n+\t\t\t loop->num);\n+\t      return false;\n+\t    }\n+\t  /* Outer loops tend to be less interesting candidates for\n+\t     complete unrolling unless we can do a lot of propagation\n+\t     into the inner loop body.  For now we disable outer loop\n+\t     unrolling when the code would grow.  */\n+\t  else if (loop->inner)\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Not unrolling loop %d: \"\n+\t\t\t \"it is not innermost and code would grow.\\n\",\n+\t\t\t loop->num);\n+\t      return false;\n+\t    }\n+\t  /* If there is call on a hot path through the loop, then\n+\t     there is most probably not much to optimize.  */\n+\t  else if (size.num_non_pure_calls_on_hot_path)\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Not unrolling loop %d: \"\n+\t\t\t \"contains call and code would grow.\\n\",\n+\t\t\t loop->num);\n+\t      return false;\n+\t    }\n+\t  /* If there is pure/const call in the function, then we can\n+\t     still optimize the unrolled loop body if it contains some\n+\t     other interesting code than the calls and code storing or\n+\t     cumulating the return value.  */\n+\t  else if (size.num_pure_calls_on_hot_path\n+\t\t   /* One IV increment, one test, one ivtmp store and\n+\t\t      one useful stmt.  That is about minimal loop\n+\t\t      doing pure call.  */\n+\t\t   && (size.non_call_stmts_on_hot_path\n+\t\t       <= 3 + size.num_pure_calls_on_hot_path))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Not unrolling loop %d: \"\n+\t\t\t \"contains just pure calls and code would grow.\\n\",\n+\t\t\t loop->num);\n+\t      return false;\n+\t    }\n+\t  /* Complete unrolling is major win when control flow is\n+\t     removed and one big basic block is created.  If the loop\n+\t     contains control flow the optimization may still be a win\n+\t     because of eliminating the loop overhead but it also may\n+\t     blow the branch predictor tables.  Limit number of\n+\t     branches on the hot path through the peeled sequence.  */\n+\t  else if (size.num_branches_on_hot_path * (int)n_unroll\n+\t\t   > PARAM_VALUE (PARAM_MAX_PEEL_BRANCHES))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Not unrolling loop %d: \"\n+\t\t\t \"number of branches on hot path in the unrolled \"\n+\t\t\t \"sequence reaches --param max-peel-branches limit.\\n\",\n+\t\t\t loop->num);\n+\t      return false;\n+\t    }\n+\t  else if (unr_insns\n+\t\t   > (unsigned) PARAM_VALUE (PARAM_MAX_COMPLETELY_PEELED_INSNS))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Not unrolling loop %d: \"\n+\t\t\t \"number of insns in the unrolled sequence reaches \"\n+\t\t\t \"--param max-completely-peeled-insns limit.\\n\",\n+\t\t\t loop->num);\n+\t      return false;\n+\t    }\n \t}\n-      if (!n_unroll)\n-        dump_printf_loc (report_flags, locus,\n-                         \"loop turned into non-loop; it never loops.\\n\");\n \n       initialize_original_copy_tables ();\n       auto_sbitmap wont_exit (n_unroll + 1);\n@@ -898,8 +913,8 @@ try_unroll_loop_completely (struct loop *loop,\n       else\n \tgimple_cond_make_true (cond);\n       update_stmt (cond);\n-      /* Do not remove the path. Doing so may remove outer loop\n-\t and confuse bookkeeping code in tree_unroll_loops_completelly.  */\n+      /* Do not remove the path, as doing so may remove outer loop and\n+\t confuse bookkeeping code in tree_unroll_loops_completely.  */\n     }\n \n   /* Store the loop for later unlooping and exit removal.  */\n@@ -915,7 +930,7 @@ try_unroll_loop_completely (struct loop *loop,\n         {\n           dump_printf_loc (MSG_OPTIMIZED_LOCATIONS | TDF_DETAILS, locus,\n                            \"loop with %d iterations completely unrolled\",\n-\t\t\t   (int) (n_unroll + 1));\n+\t\t\t   (int) n_unroll);\n           if (loop->header->count.initialized_p ())\n             dump_printf (MSG_OPTIMIZED_LOCATIONS | TDF_DETAILS,\n                          \" (header execution count %d)\",\n@@ -963,7 +978,8 @@ try_peel_loop (struct loop *loop,\n   struct loop_size size;\n   int peeled_size;\n \n-  if (!flag_peel_loops || PARAM_VALUE (PARAM_MAX_PEEL_TIMES) <= 0\n+  if (!flag_peel_loops\n+      || PARAM_VALUE (PARAM_MAX_PEEL_TIMES) <= 0\n       || !peeled_loops)\n     return false;\n \n@@ -974,20 +990,29 @@ try_peel_loop (struct loop *loop,\n       return false;\n     }\n \n+  /* We don't peel loops that will be unrolled as this can duplicate a\n+     loop more times than the user requested.  */\n+  if (loop->unroll)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \"Not peeling: user didn't want it peeled.\\n\");\n+      return false;\n+    }\n+\n   /* Peel only innermost loops.\n      While the code is perfectly capable of peeling non-innermost loops,\n      the heuristics would probably need some improvements. */\n   if (loop->inner)\n     {\n       if (dump_file)\n-        fprintf (dump_file, \"Not peeling: outer loop\\n\");\n+\tfprintf (dump_file, \"Not peeling: outer loop\\n\");\n       return false;\n     }\n \n   if (!optimize_loop_for_speed_p (loop))\n     {\n       if (dump_file)\n-        fprintf (dump_file, \"Not peeling: cold loop\\n\");\n+\tfprintf (dump_file, \"Not peeling: cold loop\\n\");\n       return false;\n     }\n \n@@ -1005,7 +1030,7 @@ try_peel_loop (struct loop *loop,\n   if (maxiter >= 0 && maxiter <= npeel)\n     {\n       if (dump_file)\n-        fprintf (dump_file, \"Not peeling: upper bound is known so can \"\n+\tfprintf (dump_file, \"Not peeling: upper bound is known so can \"\n \t\t \"unroll completely\\n\");\n       return false;\n     }\n@@ -1016,7 +1041,7 @@ try_peel_loop (struct loop *loop,\n   if (npeel > PARAM_VALUE (PARAM_MAX_PEEL_TIMES) - 1)\n     {\n       if (dump_file)\n-        fprintf (dump_file, \"Not peeling: rolls too much \"\n+\tfprintf (dump_file, \"Not peeling: rolls too much \"\n \t\t \"(%i + 1 > --param max-peel-times)\\n\", (int) npeel);\n       return false;\n     }\n@@ -1029,7 +1054,7 @@ try_peel_loop (struct loop *loop,\n       > PARAM_VALUE (PARAM_MAX_PEELED_INSNS))\n     {\n       if (dump_file)\n-        fprintf (dump_file, \"Not peeling: peeled sequence size is too large \"\n+\tfprintf (dump_file, \"Not peeling: peeled sequence size is too large \"\n \t\t \"(%i insns > --param max-peel-insns)\", peeled_size);\n       return false;\n     }\n@@ -1317,7 +1342,9 @@ tree_unroll_loops_completely_1 (bool may_increase_size, bool unroll_outer,\n   if (!loop_father)\n     return false;\n \n-  if (may_increase_size && optimize_loop_nest_for_speed_p (loop)\n+  if (loop->unroll > 1)\n+    ul = UL_ALL;\n+  else if (may_increase_size && optimize_loop_nest_for_speed_p (loop)\n       /* Unroll outermost loops only if asked to do so or they do\n \t not cause code growth.  */\n       && (unroll_outer || loop_outer (loop_father)))\n@@ -1345,7 +1372,7 @@ tree_unroll_loops_completely_1 (bool may_increase_size, bool unroll_outer,\n    MAY_INCREASE_SIZE is true, perform the unrolling only if the\n    size of the code does not increase.  */\n \n-unsigned int\n+static unsigned int\n tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n {\n   bitmap father_bbs = BITMAP_ALLOC (NULL);\n@@ -1522,9 +1549,9 @@ pass_complete_unroll::execute (function *fun)\n      re-peeling the same loop multiple times.  */\n   if (flag_peel_loops)\n     peeled_loops = BITMAP_ALLOC (NULL);\n-  int val = tree_unroll_loops_completely (flag_unroll_loops\n-\t\t\t\t\t  || flag_peel_loops\n-\t\t\t\t\t  || optimize >= 3, true);\n+  unsigned int val = tree_unroll_loops_completely (flag_unroll_loops\n+\t\t\t\t\t\t   || flag_peel_loops\n+\t\t\t\t\t\t   || optimize >= 3, true);\n   if (peeled_loops)\n     {\n       BITMAP_FREE (peeled_loops);\n@@ -1576,8 +1603,7 @@ pass_complete_unrolli::execute (function *fun)\n {\n   unsigned ret = 0;\n \n-  loop_optimizer_init (LOOPS_NORMAL\n-\t\t       | LOOPS_HAVE_RECORDED_EXITS);\n+  loop_optimizer_init (LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);\n   if (number_of_loops (fun) > 1)\n     {\n       scev_initialize ();"}, {"sha": "7523f5747bf4a2729e2b6b53889ddb1d33990598", "filename": "gcc/tree.def", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9effeda3bb29c0adcd8834b45b6e5613413049/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=ac9effeda3bb29c0adcd8834b45b6e5613413049", "patch": "@@ -1406,8 +1406,9 @@ DEFTREECODE (TARGET_OPTION_NODE, \"target_option_node\", tcc_exceptional, 0)\n \n /* ANNOTATE_EXPR.\n    Operand 0 is the expression to be annotated.\n-   Operand 1 is the annotation kind.  */\n-DEFTREECODE (ANNOTATE_EXPR, \"annotate_expr\", tcc_expression, 2)\n+   Operand 1 is the annotation kind.\n+   Operand 2 is additional data.  */\n+DEFTREECODE (ANNOTATE_EXPR, \"annotate_expr\", tcc_expression, 3)\n \n /* Cilk spawn statement\n    Operand 0 is the CALL_EXPR.  */"}]}