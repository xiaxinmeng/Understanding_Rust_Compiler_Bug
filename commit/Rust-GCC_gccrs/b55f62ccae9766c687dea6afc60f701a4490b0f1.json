{"sha": "b55f62ccae9766c687dea6afc60f701a4490b0f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU1ZjYyY2NhZTk3NjZjNjg3ZGVhNmFmYzYwZjcwMWE0NDkwYjBmMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-03-05T13:08:55Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-03-05T13:08:55Z"}, "message": "re PR middle-end/52353 (-ftrapv -fnon-call-exceptions does not work)\n\n2012-03-05  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/52353\n\t* optabs.h (trapv_unoptab_p): New function.\n\t(trapv_binoptab_p): Likewise.\n\t* optabs.c (expand_binop): Use emit_libcall_block_1 with\n\ta proper equiv_may_trap argument.\n\t(expand_unop): Likewise.\n\t(emit_libcall_block_1): Take extra argument whether the\n\tinstruction may trap.  Renamed from ...\n\t(emit_libcall_block): ... this.  New wrapper.\n\nFrom-SVN: r184932", "tree": {"sha": "42d3abf28617c05fdaa5e752dbc6b7ef735744cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42d3abf28617c05fdaa5e752dbc6b7ef735744cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b55f62ccae9766c687dea6afc60f701a4490b0f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b55f62ccae9766c687dea6afc60f701a4490b0f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b55f62ccae9766c687dea6afc60f701a4490b0f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b55f62ccae9766c687dea6afc60f701a4490b0f1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8dad8b259071a3b49d8ad0f08b7b0dba30b974c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dad8b259071a3b49d8ad0f08b7b0dba30b974c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dad8b259071a3b49d8ad0f08b7b0dba30b974c0"}], "stats": {"total": 54, "additions": 48, "deletions": 6}, "files": [{"sha": "983c0924451dcb49c02a33a93216926d5bf4cf6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55f62ccae9766c687dea6afc60f701a4490b0f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55f62ccae9766c687dea6afc60f701a4490b0f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b55f62ccae9766c687dea6afc60f701a4490b0f1", "patch": "@@ -1,3 +1,15 @@\n+2012-03-05  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/52353\n+\t* optabs.h (trapv_unoptab_p): New function.\n+\t(trapv_binoptab_p): Likewise.\n+\t* optabs.c (expand_binop): Use emit_libcall_block_1 with\n+\ta proper equiv_may_trap argument.\n+\t(expand_unop): Likewise.\n+\t(emit_libcall_block_1): Take extra argument whether the\n+\tinstruction may trap.  Renamed from ...\n+\t(emit_libcall_block): ... this.  New wrapper.\n+\n 2012-03-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/51721"}, {"sha": "565db428045c74cf1f6064fe4360d1a23874eca7", "filename": "gcc/optabs.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55f62ccae9766c687dea6afc60f701a4490b0f1/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55f62ccae9766c687dea6afc60f701a4490b0f1/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=b55f62ccae9766c687dea6afc60f701a4490b0f1", "patch": "@@ -60,6 +60,7 @@ optab code_to_optab[NUM_RTX_CODE + 1];\n static void prepare_float_lib_cmp (rtx, rtx, enum rtx_code, rtx *,\n \t\t\t\t   enum machine_mode *);\n static rtx expand_unop_direct (enum machine_mode, optab, rtx, rtx, int);\n+static void emit_libcall_block_1 (rtx, rtx, rtx, rtx, bool);\n \n /* Debug facility for use in GDB.  */\n void debug_optab_libfuncs (void);\n@@ -2115,8 +2116,9 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       end_sequence ();\n \n       target = gen_reg_rtx (mode);\n-      emit_libcall_block (insns, target, value,\n-\t\t\t  gen_rtx_fmt_ee (binoptab->code, mode, op0, op1));\n+      emit_libcall_block_1 (insns, target, value,\n+\t\t\t    gen_rtx_fmt_ee (binoptab->code, mode, op0, op1),\n+\t\t\t    trapv_binoptab_p (binoptab));\n \n       return target;\n     }\n@@ -3197,7 +3199,8 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \teq_value = simplify_gen_unary (TRUNCATE, outmode, eq_value, mode);\n       else if (GET_MODE_SIZE (outmode) > GET_MODE_SIZE (mode))\n \teq_value = simplify_gen_unary (ZERO_EXTEND, outmode, eq_value, mode);\n-      emit_libcall_block (insns, target, value, eq_value);\n+      emit_libcall_block_1 (insns, target, value, eq_value,\n+\t\t\t    trapv_unoptab_p (unoptab));\n \n       return target;\n     }\n@@ -3775,8 +3778,9 @@ no_conflict_move_test (rtx dest, const_rtx set, void *p0)\n    an insn to move RESULT to TARGET.  This last insn will have a REQ_EQUAL\n    note with an operand of EQUIV.  */\n \n-void\n-emit_libcall_block (rtx insns, rtx target, rtx result, rtx equiv)\n+static void\n+emit_libcall_block_1 (rtx insns, rtx target, rtx result, rtx equiv,\n+\t\t      bool equiv_may_trap)\n {\n   rtx final_dest = target;\n   rtx next, last, insn;\n@@ -3789,7 +3793,8 @@ emit_libcall_block (rtx insns, rtx target, rtx result, rtx equiv)\n   /* If we're using non-call exceptions, a libcall corresponding to an\n      operation that may trap may also trap.  */\n   /* ??? See the comment in front of make_reg_eh_region_note.  */\n-  if (cfun->can_throw_non_call_exceptions && may_trap_p (equiv))\n+  if (cfun->can_throw_non_call_exceptions\n+      && (equiv_may_trap || may_trap_p (equiv)))\n     {\n       for (insn = insns; insn; insn = NEXT_INSN (insn))\n \tif (CALL_P (insn))\n@@ -3870,6 +3875,12 @@ emit_libcall_block (rtx insns, rtx target, rtx result, rtx equiv)\n   if (final_dest != target)\n     emit_move_insn (final_dest, target);\n }\n+\n+void\n+emit_libcall_block (rtx insns, rtx target, rtx result, rtx equiv)\n+{\n+  emit_libcall_block_1 (insns, target, result, equiv, false);\n+}\n \f\n /* Nonzero if we can perform a comparison of mode MODE straightforwardly.\n    PURPOSE describes how this comparison will be used.  CODE is the rtx"}, {"sha": "70a7395cc0525d0dd301c52d2aed56c9765f0f3d", "filename": "gcc/optabs.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55f62ccae9766c687dea6afc60f701a4490b0f1/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55f62ccae9766c687dea6afc60f701a4490b0f1/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=b55f62ccae9766c687dea6afc60f701a4490b0f1", "patch": "@@ -1103,6 +1103,25 @@ set_direct_optab_handler (direct_optab op, enum machine_mode mode,\n   op->handlers[(int) mode].insn_code = (int) code - (int) CODE_FOR_nothing;\n }\n \n+/* Return true if UNOPTAB is for a trapping-on-overflow operation.  */\n+\n+static inline bool\n+trapv_unoptab_p (optab unoptab)\n+{\n+  return (unoptab == negv_optab\n+\t  || unoptab == absv_optab); \n+}\n+\n+/* Return true if BINOPTAB is for a trapping-on-overflow operation.  */\n+\n+static inline bool\n+trapv_binoptab_p (optab binoptab)\n+{\n+  return (binoptab == addv_optab\n+\t  || binoptab == subv_optab\n+\t  || binoptab == smulv_optab);\n+}\n+\n extern rtx optab_libfunc (optab optab, enum machine_mode mode);\n extern rtx convert_optab_libfunc (convert_optab optab, enum machine_mode mode1,\n \t\t\t          enum machine_mode mode2);"}]}