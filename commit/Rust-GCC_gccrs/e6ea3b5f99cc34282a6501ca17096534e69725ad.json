{"sha": "e6ea3b5f99cc34282a6501ca17096534e69725ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZlYTNiNWY5OWNjMzQyODJhNjUwMWNhMTcwOTY1MzRlNjk3MjVhZA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "2000-08-21T13:46:47Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-21T13:46:47Z"}, "message": "reload.c (reload_inner_reg_of_subreg): New function broken out of push_reload.\n\n        * reload.c (reload_inner_reg_of_subreg): New function broken out of\n        push_reload.\n        (push_reload): Use reload_inner_reg_of_subreg.\n        (combine_reloads): Do not combine reloads if the input reload\n        is a SUBREG in which the inner part will need reloading.\n\nFrom-SVN: r35841", "tree": {"sha": "fba4f559c029d28a1850565c7c0093be5f9d9ffe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fba4f559c029d28a1850565c7c0093be5f9d9ffe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6ea3b5f99cc34282a6501ca17096534e69725ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6ea3b5f99cc34282a6501ca17096534e69725ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6ea3b5f99cc34282a6501ca17096534e69725ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6ea3b5f99cc34282a6501ca17096534e69725ad/comments", "author": null, "committer": null, "parents": [{"sha": "e04ca094deb8860f36d28aa71cfdd66e8a6c55fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd"}], "stats": {"total": 75, "additions": 49, "deletions": 26}, "files": [{"sha": "06330a43a89c9282316c06c8717029d79e94478b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6ea3b5f99cc34282a6501ca17096534e69725ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6ea3b5f99cc34282a6501ca17096534e69725ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6ea3b5f99cc34282a6501ca17096534e69725ad", "patch": "@@ -1,5 +1,11 @@\n Mon Aug 21 07:41:12 2000  Jeffrey A Law  (law@cygnus.com)\n \n+\t* reload.c (reload_inner_reg_of_subreg): New function broken out of\n+\tpush_reload.\n+\t(push_reload): Use reload_inner_reg_of_subreg.\n+\t(combine_reloads): Do not combine reloads if the input reload\n+\tis a SUBREG in which the inner part will need reloading.\n+\n \t* global.c (global_alloc): Avoid passing dumpfile argument to\n \treload routines.\n \t* toplev.c (rest_of_compilation): Likewise."}, {"sha": "4dd36f02ae91bfb589afca5c574b54be5ca6dcff", "filename": "gcc/reload.c", "status": "modified", "additions": 43, "deletions": 26, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6ea3b5f99cc34282a6501ca17096534e69725ad/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6ea3b5f99cc34282a6501ca17096534e69725ad/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=e6ea3b5f99cc34282a6501ca17096534e69725ad", "patch": "@@ -243,6 +243,7 @@ static int push_secondary_reload PARAMS ((int, rtx, int, int, enum reg_class,\n \t\t\t\t\tenum insn_code *));\n #endif\n static enum reg_class find_valid_class PARAMS ((enum machine_mode, int));\n+static int reload_inner_reg_of_subreg PARAMS ((rtx, enum machine_mode));\n static int push_reload\t\tPARAMS ((rtx, rtx, rtx *, rtx *, enum reg_class,\n \t\t\t\t       enum machine_mode, enum machine_mode,\n \t\t\t\t       int, int, int, enum reload_type));\n@@ -767,6 +768,45 @@ find_reusable_reload (p_in, out, class, type, opnum, dont_share)\n   return n_reloads;\n }\n \n+/* Return nonzero if X is a SUBREG which will require reloading of its\n+   SUBREG_REG expression.  */\n+\n+static int\n+reload_inner_reg_of_subreg (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  rtx inner;\n+\n+  /* Only SUBREGs are problematical.  */\n+  if (GET_CODE (x) != SUBREG)\n+    return 0;\n+\n+  inner = SUBREG_REG (x);\n+\n+  /* If INNER is a constant, then INNER must be reloaded.  */\n+  if (CONSTANT_P (inner))\n+    return 1;\n+\n+  /* If INNER is not a hard register, then INNER will not need to\n+     be reloaded.  */\n+  if (GET_CODE (inner) != REG\n+      || REGNO (inner) >= FIRST_PSEUDO_REGISTER)\n+    return 0;\n+\n+  /* If INNER is not ok for MODE, then INNER will need reloading.  */\n+  if (! HARD_REGNO_MODE_OK (REGNO (inner) + SUBREG_WORD (x), mode))\n+    return 1;\n+\n+  /* If the outer part is a word or smaller, INNER larger than a\n+     word and the number of regs for INNER is not the same as the\n+     number of words in INNER, then INNER will need reloading.  */\n+  return (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n+\t  && GET_MODE_SIZE (GET_MODE (inner)) > UNITS_PER_WORD\n+\t  && ((GET_MODE_SIZE (GET_MODE (inner)) / UNITS_PER_WORD)\n+\t      != HARD_REGNO_NREGS (REGNO (inner), GET_MODE (inner))));\n+}\n+\n /* Record one reload that needs to be performed.\n    IN is an rtx saying where the data are to be found before this instruction.\n    OUT says where they must be stored after the instruction.\n@@ -993,20 +1033,7 @@ push_reload (in, out, inloc, outloc, class,\n   /* Similar issue for (SUBREG constant ...) if it was not handled by the\n      code above.  This can happen if SUBREG_WORD != 0.  */\n \n-  if (in != 0 && GET_CODE (in) == SUBREG\n-      && (CONSTANT_P (SUBREG_REG (in))\n-\t  || (GET_CODE (SUBREG_REG (in)) == REG\n-\t      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n-\t      && (! HARD_REGNO_MODE_OK (REGNO (SUBREG_REG (in))\n-\t\t\t\t\t+ SUBREG_WORD (in),\n-\t\t\t\t\tinmode)\n-\t\t  || (GET_MODE_SIZE (inmode) <= UNITS_PER_WORD\n-\t\t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n-\t\t\t  > UNITS_PER_WORD)\n-\t\t      && ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n-\t\t\t   / UNITS_PER_WORD)\n-\t\t\t  != HARD_REGNO_NREGS (REGNO (SUBREG_REG (in)),\n-\t\t\t\t\t       GET_MODE (SUBREG_REG (in)))))))))\n+  if (in != 0 && reload_inner_reg_of_subreg (in, inmode))\n     {\n       /* This relies on the fact that emit_reload_insns outputs the\n \t instructions for input reloads of type RELOAD_OTHER in the same\n@@ -1093,18 +1120,7 @@ push_reload (in, out, inloc, outloc, class,\n      However, we must reload the inner reg *as well as* the subreg in\n      that case.  In this case, the inner reg is an in-out reload.  */\n \n-  if (out != 0 && GET_CODE (out) == SUBREG\n-      && GET_CODE (SUBREG_REG (out)) == REG\n-      && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER\n-      && (! HARD_REGNO_MODE_OK (REGNO (SUBREG_REG (out)) + SUBREG_WORD (out),\n-\t\t\t\toutmode)\n-\t  || (GET_MODE_SIZE (outmode) <= UNITS_PER_WORD\n-\t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))\n-\t\t  > UNITS_PER_WORD)\n-\t      && ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))\n-\t\t   / UNITS_PER_WORD)\n-\t\t  != HARD_REGNO_NREGS (REGNO (SUBREG_REG (out)),\n-\t\t\t\t       GET_MODE (SUBREG_REG (out)))))))\n+  if (out != 0 && reload_inner_reg_of_subreg (out, outmode))\n     {\n       /* This relies on the fact that emit_reload_insns outputs the\n \t instructions for output reloads of type RELOAD_OTHER in reverse\n@@ -1655,6 +1671,7 @@ combine_reloads ()\n \t\t&& ! (GET_CODE (rld[i].in) == REG\n \t\t      && reg_overlap_mentioned_for_reload_p (rld[i].in,\n \t\t\t\t\t\t\t     rld[output_reload].out))))\n+\t&& ! reload_inner_reg_of_subreg (rld[i].in, rld[i].inmode)\n \t&& (reg_class_size[(int) rld[i].class]\n \t    || SMALL_REGISTER_CLASSES)\n \t/* We will allow making things slightly worse by combining an"}]}