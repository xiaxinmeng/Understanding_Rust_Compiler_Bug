{"sha": "f9f69dd651b2f1031761312cc3d13aee40b46b5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjlmNjlkZDY1MWIyZjEwMzE3NjEzMTJjYzNkMTNhZWU0MGI0NmI1ZQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-05-11T09:31:18Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-05-11T09:31:18Z"}, "message": "tree-ssa-loop-ivopts.c (get_loop_invariant_expr): Simplify.\n\n\t* tree-ssa-loop-ivopts.c (get_loop_invariant_expr): Simplify.\n\t(adjust_setup_cost): New parameter supporting round up adjustment.\n\t(struct address_cost_data): Delete.\n\t(force_expr_to_var_cost): Don't bound cost with spill_cost.\n\t(split_address_cost, ptr_difference_cost): Delete.\n\t(difference_cost, compare_aff_trees, record_inv_expr): Delete.\n\t(struct ainc_cost_data): New struct.\n\t(get_address_cost_ainc): New function.\n\t(get_address_cost, get_computation_cost): Reimplement.\n\t(determine_group_iv_cost_address): Record inv_expr for all uses of\n\ta group.\n\t(determine_group_iv_cost_cond): Call get_loop_invariant_expr.\n\t(iv_ca_has_deps): Reimplemented to ...\n\t(iv_ca_more_deps): ... this.  Check if NEW_CP introduces more deps\n\tthan OLD_CP.\n\t(iv_ca_extend): Call iv_ca_more_deps.\n\nFrom-SVN: r247885", "tree": {"sha": "ca6f5d5c55bf0be1634609720d990bd617133b7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca6f5d5c55bf0be1634609720d990bd617133b7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9f69dd651b2f1031761312cc3d13aee40b46b5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9f69dd651b2f1031761312cc3d13aee40b46b5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9f69dd651b2f1031761312cc3d13aee40b46b5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9f69dd651b2f1031761312cc3d13aee40b46b5e/comments", "author": null, "committer": null, "parents": [{"sha": "c2b64ceab2ae2e0b86271248a5c31690a1604984", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2b64ceab2ae2e0b86271248a5c31690a1604984", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2b64ceab2ae2e0b86271248a5c31690a1604984"}], "stats": {"total": 1153, "additions": 354, "deletions": 799}, "files": [{"sha": "2004b24d0c969085badb2dbabca5f34df907ebcc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f69dd651b2f1031761312cc3d13aee40b46b5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f69dd651b2f1031761312cc3d13aee40b46b5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9f69dd651b2f1031761312cc3d13aee40b46b5e", "patch": "@@ -1,3 +1,22 @@\n+2017-05-11  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-ssa-loop-ivopts.c (get_loop_invariant_expr): Simplify.\n+\t(adjust_setup_cost): New parameter supporting round up adjustment.\n+\t(struct address_cost_data): Delete.\n+\t(force_expr_to_var_cost): Don't bound cost with spill_cost.\n+\t(split_address_cost, ptr_difference_cost): Delete.\n+\t(difference_cost, compare_aff_trees, record_inv_expr): Delete.\n+\t(struct ainc_cost_data): New struct.\n+\t(get_address_cost_ainc): New function.\n+\t(get_address_cost, get_computation_cost): Reimplement.\n+\t(determine_group_iv_cost_address): Record inv_expr for all uses of\n+\ta group.\n+\t(determine_group_iv_cost_cond): Call get_loop_invariant_expr.\n+\t(iv_ca_has_deps): Reimplemented to ...\n+\t(iv_ca_more_deps): ... this.  Check if NEW_CP introduces more deps\n+\tthan OLD_CP.\n+\t(iv_ca_extend): Call iv_ca_more_deps.\n+\n 2017-05-11  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-ssa-address.c (struct mem_address): Move to header file."}, {"sha": "43cab302a5c4d6e484cb7714bd9bc8ce07679122", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 335, "deletions": 799, "changes": 1134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f69dd651b2f1031761312cc3d13aee40b46b5e/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f69dd651b2f1031761312cc3d13aee40b46b5e/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=f9f69dd651b2f1031761312cc3d13aee40b46b5e", "patch": "@@ -2910,6 +2910,45 @@ find_inv_vars (struct ivopts_data *data, tree *expr_p, bitmap *inv_vars)\n   walk_tree (expr_p, find_inv_vars_cb, &wdata, NULL);\n }\n \n+/* Get entry from invariant expr hash table for INV_EXPR.  New entry\n+   will be recorded if it doesn't exist yet.  Given below two exprs:\n+     inv_expr + cst1, inv_expr + cst2\n+   It's hard to make decision whether constant part should be stripped\n+   or not.  We choose to not strip based on below facts:\n+     1) We need to count ADD cost for constant part if it's stripped,\n+\twhich is't always trivial where this functions is called.\n+     2) Stripping constant away may be conflict with following loop\n+\tinvariant hoisting pass.\n+     3) Not stripping constant away results in more invariant exprs,\n+\twhich usually leads to decision preferring lower reg pressure.  */\n+\n+static iv_inv_expr_ent *\n+get_loop_invariant_expr (struct ivopts_data *data, tree inv_expr)\n+{\n+  STRIP_NOPS (inv_expr);\n+\n+  if (TREE_CODE (inv_expr) == INTEGER_CST || TREE_CODE (inv_expr) == SSA_NAME)\n+    return NULL;\n+\n+  /* Don't strip constant part away as we used to.  */\n+\n+  /* Stores EXPR in DATA->inv_expr_tab, return pointer to iv_inv_expr_ent.  */\n+  struct iv_inv_expr_ent ent;\n+  ent.expr = inv_expr;\n+  ent.hash = iterative_hash_expr (inv_expr, 0);\n+  struct iv_inv_expr_ent **slot = data->inv_expr_tab->find_slot (&ent, INSERT);\n+\n+  if (!*slot)\n+    {\n+      *slot = XNEW (struct iv_inv_expr_ent);\n+      (*slot)->expr = inv_expr;\n+      (*slot)->hash = ent.hash;\n+      (*slot)->id = ++data->max_inv_expr_id;\n+    }\n+\n+  return *slot;\n+}\n+\n /* Adds a candidate BASE + STEP * i.  Important field is set to IMPORTANT and\n    position to POS.  If USE is not NULL, the candidate is set as related to\n    it.  If both BASE and STEP are NULL, we add a pseudocandidate for the\n@@ -3841,14 +3880,20 @@ get_computation_at (struct loop *loop, gimple *at,\n \n /* Adjust the cost COST for being in loop setup rather than loop body.\n    If we're optimizing for space, the loop setup overhead is constant;\n-   if we're optimizing for speed, amortize it over the per-iteration cost.  */\n+   if we're optimizing for speed, amortize it over the per-iteration cost.\n+   If ROUND_UP_P is true, the result is round up rather than to zero when\n+   optimizing for speed.  */\n static unsigned\n-adjust_setup_cost (struct ivopts_data *data, unsigned cost)\n+adjust_setup_cost (struct ivopts_data *data, unsigned cost,\n+\t\t   bool round_up_p = false)\n {\n   if (cost == INFTY)\n     return cost;\n   else if (optimize_loop_for_speed_p (data->current_loop))\n-    return cost / avg_loop_niter (data->current_loop);\n+    {\n+      HOST_WIDE_INT niters = avg_loop_niter (data->current_loop);\n+      return ((HOST_WIDE_INT) cost + (round_up_p ? niters - 1 : 0)) / niters;\n+    }\n   else\n     return cost;\n }\n@@ -3910,353 +3955,6 @@ multiplier_allowed_in_address_p (HOST_WIDE_INT ratio, machine_mode mode,\n   return bitmap_bit_p (valid_mult, ratio + MAX_RATIO);\n }\n \n-/* Returns cost of address in shape symbol + var + OFFSET + RATIO * index.\n-   If SYMBOL_PRESENT is false, symbol is omitted.  If VAR_PRESENT is false,\n-   variable is omitted.  Compute the cost for a memory reference that accesses\n-   a memory location of mode MEM_MODE in address space AS.\n-\n-   MAY_AUTOINC is set to true if the autoincrement (increasing index by\n-   size of MEM_MODE / RATIO) is available.  To make this determination, we\n-   look at the size of the increment to be made, which is given in CSTEP.\n-   CSTEP may be zero if the step is unknown.\n-   STMT_AFTER_INC is true iff the statement we're looking at is after the\n-   increment of the original biv.\n-\n-   TODO -- there must be some better way.  This all is quite crude.  */\n-\n-enum ainc_type\n-{\n-  AINC_PRE_INC,\t\t/* Pre increment.  */\n-  AINC_PRE_DEC,\t\t/* Pre decrement.  */\n-  AINC_POST_INC,\t/* Post increment.  */\n-  AINC_POST_DEC,\t/* Post decrement.  */\n-  AINC_NONE\t\t/* Also the number of auto increment types.  */\n-};\n-\n-struct address_cost_data\n-{\n-  HOST_WIDE_INT min_offset, max_offset;\n-  unsigned costs[2][2][2][2];\n-  unsigned ainc_costs[AINC_NONE];\n-};\n-\n-\n-static comp_cost\n-get_address_cost (bool symbol_present, bool var_present,\n-\t\t  unsigned HOST_WIDE_INT offset, HOST_WIDE_INT ratio,\n-\t\t  HOST_WIDE_INT cstep, machine_mode mem_mode,\n-\t\t  addr_space_t as, bool speed,\n-\t\t  bool stmt_after_inc, bool *may_autoinc)\n-{\n-  machine_mode address_mode = targetm.addr_space.address_mode (as);\n-  static vec<address_cost_data *> address_cost_data_list;\n-  unsigned int data_index = (int) as * MAX_MACHINE_MODE + (int) mem_mode;\n-  address_cost_data *data;\n-  static bool has_preinc[MAX_MACHINE_MODE], has_postinc[MAX_MACHINE_MODE];\n-  static bool has_predec[MAX_MACHINE_MODE], has_postdec[MAX_MACHINE_MODE];\n-  unsigned cost, acost, complexity;\n-  enum ainc_type autoinc_type;\n-  bool offset_p, ratio_p, autoinc;\n-  HOST_WIDE_INT s_offset, autoinc_offset, msize;\n-  unsigned HOST_WIDE_INT mask;\n-  unsigned bits;\n-\n-  if (data_index >= address_cost_data_list.length ())\n-    address_cost_data_list.safe_grow_cleared (data_index + 1);\n-\n-  data = address_cost_data_list[data_index];\n-  if (!data)\n-    {\n-      HOST_WIDE_INT i;\n-      HOST_WIDE_INT rat, off = 0;\n-      int old_cse_not_expected, width;\n-      unsigned sym_p, var_p, off_p, rat_p, add_c;\n-      rtx_insn *seq;\n-      rtx addr, base;\n-      rtx reg0, reg1;\n-\n-      data = (address_cost_data *) xcalloc (1, sizeof (*data));\n-\n-      reg1 = gen_raw_REG (address_mode, LAST_VIRTUAL_REGISTER + 1);\n-\n-      width = GET_MODE_BITSIZE (address_mode) - 1;\n-      if (width > (HOST_BITS_PER_WIDE_INT - 1))\n-\twidth = HOST_BITS_PER_WIDE_INT - 1;\n-      addr = gen_rtx_fmt_ee (PLUS, address_mode, reg1, NULL_RTX);\n-\n-      for (i = width; i >= 0; i--)\n-\t{\n-\t  off = -(HOST_WIDE_INT_1U << i);\n-\t  XEXP (addr, 1) = gen_int_mode (off, address_mode);\n-\t  if (memory_address_addr_space_p (mem_mode, addr, as))\n-\t    break;\n-\t}\n-      data->min_offset = (i == -1? 0 : off);\n-\n-      for (i = width; i >= 0; i--)\n-\t{\n-\t  off = (HOST_WIDE_INT_1U << i) - 1;\n-\t  XEXP (addr, 1) = gen_int_mode (off, address_mode);\n-\t  if (memory_address_addr_space_p (mem_mode, addr, as))\n-\t    break;\n-\t  /* For some strict-alignment targets, the offset must be naturally\n-\t     aligned.  Try an aligned offset if mem_mode is not QImode.  */\n-\t  off = mem_mode != QImode\n-\t\t? (HOST_WIDE_INT_1U << i)\n-\t\t    - GET_MODE_SIZE (mem_mode)\n-\t\t: 0;\n-\t  if (off > 0)\n-\t    {\n-\t      XEXP (addr, 1) = gen_int_mode (off, address_mode);\n-\t      if (memory_address_addr_space_p (mem_mode, addr, as))\n-\t\tbreak;\n-\t    }\n-\t}\n-      if (i == -1)\n-\toff = 0;\n-      data->max_offset = off;\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"get_address_cost:\\n\");\n-\t  fprintf (dump_file, \"  min offset %s \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-\t\t   GET_MODE_NAME (mem_mode),\n-\t\t   data->min_offset);\n-\t  fprintf (dump_file, \"  max offset %s \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-\t\t   GET_MODE_NAME (mem_mode),\n-\t\t   data->max_offset);\n-\t}\n-\n-      rat = 1;\n-      for (i = 2; i <= MAX_RATIO; i++)\n-\tif (multiplier_allowed_in_address_p (i, mem_mode, as))\n-\t  {\n-\t    rat = i;\n-\t    break;\n-\t  }\n-\n-      /* Compute the cost of various addressing modes.  */\n-      acost = 0;\n-      reg0 = gen_raw_REG (address_mode, LAST_VIRTUAL_REGISTER + 1);\n-      reg1 = gen_raw_REG (address_mode, LAST_VIRTUAL_REGISTER + 2);\n-\n-      if (USE_LOAD_PRE_DECREMENT (mem_mode)\n-\t  || USE_STORE_PRE_DECREMENT (mem_mode))\n-\t{\n-\t  addr = gen_rtx_PRE_DEC (address_mode, reg0);\n-\t  has_predec[mem_mode]\n-\t    = memory_address_addr_space_p (mem_mode, addr, as);\n-\n-\t  if (has_predec[mem_mode])\n-\t    data->ainc_costs[AINC_PRE_DEC]\n-\t      = address_cost (addr, mem_mode, as, speed);\n-\t}\n-      if (USE_LOAD_POST_DECREMENT (mem_mode)\n-\t  || USE_STORE_POST_DECREMENT (mem_mode))\n-\t{\n-\t  addr = gen_rtx_POST_DEC (address_mode, reg0);\n-\t  has_postdec[mem_mode]\n-\t    = memory_address_addr_space_p (mem_mode, addr, as);\n-\n-\t  if (has_postdec[mem_mode])\n-\t    data->ainc_costs[AINC_POST_DEC]\n-\t      = address_cost (addr, mem_mode, as, speed);\n-\t}\n-      if (USE_LOAD_PRE_INCREMENT (mem_mode)\n-\t  || USE_STORE_PRE_DECREMENT (mem_mode))\n-\t{\n-\t  addr = gen_rtx_PRE_INC (address_mode, reg0);\n-\t  has_preinc[mem_mode]\n-\t    = memory_address_addr_space_p (mem_mode, addr, as);\n-\n-\t  if (has_preinc[mem_mode])\n-\t    data->ainc_costs[AINC_PRE_INC]\n-\t      = address_cost (addr, mem_mode, as, speed);\n-\t}\n-      if (USE_LOAD_POST_INCREMENT (mem_mode)\n-\t  || USE_STORE_POST_INCREMENT (mem_mode))\n-\t{\n-\t  addr = gen_rtx_POST_INC (address_mode, reg0);\n-\t  has_postinc[mem_mode]\n-\t    = memory_address_addr_space_p (mem_mode, addr, as);\n-\n-\t  if (has_postinc[mem_mode])\n-\t    data->ainc_costs[AINC_POST_INC]\n-\t      = address_cost (addr, mem_mode, as, speed);\n-\t}\n-      for (i = 0; i < 16; i++)\n-\t{\n-\t  sym_p = i & 1;\n-\t  var_p = (i >> 1) & 1;\n-\t  off_p = (i >> 2) & 1;\n-\t  rat_p = (i >> 3) & 1;\n-\n-\t  addr = reg0;\n-\t  if (rat_p)\n-\t    addr = gen_rtx_fmt_ee (MULT, address_mode, addr,\n-\t\t\t\t   gen_int_mode (rat, address_mode));\n-\n-\t  if (var_p)\n-\t    addr = gen_rtx_fmt_ee (PLUS, address_mode, addr, reg1);\n-\n-\t  if (sym_p)\n-\t    {\n-\t      base = gen_rtx_SYMBOL_REF (address_mode, ggc_strdup (\"\"));\n-\t      /* ??? We can run into trouble with some backends by presenting\n-\t\t it with symbols which haven't been properly passed through\n-\t\t targetm.encode_section_info.  By setting the local bit, we\n-\t\t enhance the probability of things working.  */\n-\t      SYMBOL_REF_FLAGS (base) = SYMBOL_FLAG_LOCAL;\n-\n-\t      if (off_p)\n-\t\tbase = gen_rtx_fmt_e (CONST, address_mode,\n-\t\t\t\t      gen_rtx_fmt_ee\n-\t\t\t\t\t(PLUS, address_mode, base,\n-\t\t\t\t\t gen_int_mode (off, address_mode)));\n-\t    }\n-\t  else if (off_p)\n-\t    base = gen_int_mode (off, address_mode);\n-\t  else\n-\t    base = NULL_RTX;\n-\n-\t  if (base)\n-\t    addr = gen_rtx_fmt_ee (PLUS, address_mode, addr, base);\n-\n-\t  start_sequence ();\n-\t  /* To avoid splitting addressing modes, pretend that no cse will\n-\t     follow.  */\n-\t  old_cse_not_expected = cse_not_expected;\n-\t  cse_not_expected = true;\n-\t  addr = memory_address_addr_space (mem_mode, addr, as);\n-\t  cse_not_expected = old_cse_not_expected;\n-\t  seq = get_insns ();\n-\t  end_sequence ();\n-\n-\t  acost = seq_cost (seq, speed);\n-\t  acost += address_cost (addr, mem_mode, as, speed);\n-\n-\t  if (!acost)\n-\t    acost = 1;\n-\t  data->costs[sym_p][var_p][off_p][rat_p] = acost;\n-\t}\n-\n-      /* On some targets, it is quite expensive to load symbol to a register,\n-\t which makes addresses that contain symbols look much more expensive.\n-\t However, the symbol will have to be loaded in any case before the\n-\t loop (and quite likely we have it in register already), so it does not\n-\t make much sense to penalize them too heavily.  So make some final\n-\t tweaks for the SYMBOL_PRESENT modes:\n-\n-\t If VAR_PRESENT is false, and the mode obtained by changing symbol to\n-\t var is cheaper, use this mode with small penalty.\n-\t If VAR_PRESENT is true, try whether the mode with\n-\t SYMBOL_PRESENT = false is cheaper even with cost of addition, and\n-\t if this is the case, use it.  */\n-      add_c = add_cost (speed, address_mode);\n-      for (i = 0; i < 8; i++)\n-\t{\n-\t  var_p = i & 1;\n-\t  off_p = (i >> 1) & 1;\n-\t  rat_p = (i >> 2) & 1;\n-\n-\t  acost = data->costs[0][1][off_p][rat_p] + 1;\n-\t  if (var_p)\n-\t    acost += add_c;\n-\n-\t  if (acost < data->costs[1][var_p][off_p][rat_p])\n-\t    data->costs[1][var_p][off_p][rat_p] = acost;\n-\t}\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"<Address Costs>:\\n\");\n-\n-\t  for (i = 0; i < 16; i++)\n-\t    {\n-\t      sym_p = i & 1;\n-\t      var_p = (i >> 1) & 1;\n-\t      off_p = (i >> 2) & 1;\n-\t      rat_p = (i >> 3) & 1;\n-\n-\t      fprintf (dump_file, \"  \");\n-\t      if (sym_p)\n-\t\tfprintf (dump_file, \"sym + \");\n-\t      if (var_p)\n-\t\tfprintf (dump_file, \"var + \");\n-\t      if (off_p)\n-\t\tfprintf (dump_file, \"cst + \");\n-\t      if (rat_p)\n-\t\tfprintf (dump_file, \"rat * \");\n-\n-\t      acost = data->costs[sym_p][var_p][off_p][rat_p];\n-\t      fprintf (dump_file, \"index costs %d\\n\", acost);\n-\t    }\n-\t  if (has_predec[mem_mode] || has_postdec[mem_mode]\n-\t      || has_preinc[mem_mode] || has_postinc[mem_mode])\n-\t    fprintf (dump_file, \"  May include autoinc/dec\\n\");\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-\n-      address_cost_data_list[data_index] = data;\n-    }\n-\n-  bits = GET_MODE_BITSIZE (address_mode);\n-  mask = ~(HOST_WIDE_INT_M1U << (bits - 1) << 1);\n-  offset &= mask;\n-  if ((offset >> (bits - 1) & 1))\n-    offset |= ~mask;\n-  s_offset = offset;\n-\n-  autoinc = false;\n-  autoinc_type = AINC_NONE;\n-  msize = GET_MODE_SIZE (mem_mode);\n-  autoinc_offset = offset;\n-  if (stmt_after_inc)\n-    autoinc_offset += ratio * cstep;\n-  if (symbol_present || var_present || ratio != 1)\n-    autoinc = false;\n-  else\n-    {\n-      if (has_postinc[mem_mode] && autoinc_offset == 0\n-\t  && msize == cstep)\n-\tautoinc_type = AINC_POST_INC;\n-      else if (has_postdec[mem_mode] && autoinc_offset == 0\n-\t       && msize == -cstep)\n-\tautoinc_type = AINC_POST_DEC;\n-      else if (has_preinc[mem_mode] && autoinc_offset == msize\n-\t       && msize == cstep)\n-\tautoinc_type = AINC_PRE_INC;\n-      else if (has_predec[mem_mode] && autoinc_offset == -msize\n-\t       && msize == -cstep)\n-\tautoinc_type = AINC_PRE_DEC;\n-\n-      if (autoinc_type != AINC_NONE)\n-\tautoinc = true;\n-    }\n-\n-  cost = 0;\n-  offset_p = (s_offset != 0\n-\t      && data->min_offset <= s_offset\n-\t      && s_offset <= data->max_offset);\n-  ratio_p = (ratio != 1\n-\t     && multiplier_allowed_in_address_p (ratio, mem_mode, as));\n-\n-  if (ratio != 1 && !ratio_p)\n-    cost += mult_by_coeff_cost (ratio, address_mode, speed);\n-\n-  if (s_offset && !offset_p && !symbol_present)\n-    cost += add_cost (speed, address_mode);\n-\n-  if (may_autoinc)\n-    *may_autoinc = autoinc;\n-  if (autoinc)\n-    acost = data->ainc_costs[autoinc_type];\n-  else\n-    acost = data->costs[symbol_present][var_present][offset_p][ratio_p];\n-  complexity = (symbol_present != 0) + (var_present != 0) + offset_p + ratio_p;\n-  return comp_cost (cost + acost, complexity);\n-}\n-\n  /* Calculate the SPEED or size cost of shiftadd EXPR in MODE.  MULT is the\n     EXPR operand holding the shift.  COST0 and COST1 are the costs for\n     calculating the operands of EXPR.  Returns true if successful, and returns\n@@ -4464,14 +4162,6 @@ force_expr_to_var_cost (tree expr, bool speed)\n \n   cost += cost0;\n   cost += cost1;\n-\n-  /* Bound the cost by target_spill_cost.  The parts of complicated\n-     computations often are either loop invariant or at least can\n-     be shared between several iv uses, so letting this grow without\n-     limits would not give reasonable results.  */\n-  if (cost.cost > (int) target_spill_cost [speed])\n-    cost.cost = target_spill_cost [speed];\n-\n   return cost;\n }\n \n@@ -4488,291 +4178,255 @@ force_var_cost (struct ivopts_data *data, tree expr, bitmap *inv_vars)\n   return force_expr_to_var_cost (expr, data->speed);\n }\n \n-/* Estimates cost of expressing address ADDR  as var + symbol + offset.  The\n-   value of offset is added to OFFSET, SYMBOL_PRESENT and VAR_PRESENT are set\n-   to false if the corresponding part is missing.  inv_vars is a set of the\n-   invariants the computation depends on.  */\n-\n-static comp_cost\n-split_address_cost (struct ivopts_data *data,\n-\t\t    tree addr, bool *symbol_present, bool *var_present,\n-\t\t    unsigned HOST_WIDE_INT *offset, bitmap *inv_vars)\n-{\n-  tree core;\n-  HOST_WIDE_INT bitsize;\n-  HOST_WIDE_INT bitpos;\n-  tree toffset;\n-  machine_mode mode;\n-  int unsignedp, reversep, volatilep;\n-\n-  core = get_inner_reference (addr, &bitsize, &bitpos, &toffset, &mode,\n-\t\t\t      &unsignedp, &reversep, &volatilep);\n-\n-  if (toffset != 0\n-      || bitpos % BITS_PER_UNIT != 0\n-      || reversep\n-      || !VAR_P (core))\n-    {\n-      *symbol_present = false;\n-      *var_present = true;\n-      find_inv_vars (data, &addr, inv_vars);\n-      return comp_cost (target_spill_cost[data->speed], 0);\n-    }\n-\n-  *offset += bitpos / BITS_PER_UNIT;\n-  if (TREE_STATIC (core)\n-      || DECL_EXTERNAL (core))\n-    {\n-      *symbol_present = true;\n-      *var_present = false;\n-      return no_cost;\n-    }\n+/* Returns cost of auto-modifying address expression in shape base + offset.\n+   AINC_STEP is step size of the address IV.  AINC_OFFSET is offset of the\n+   address expression.  The address expression has ADDR_MODE in addr space\n+   AS.  The memory access has MEM_MODE.  SPEED means we are optimizing for\n+   speed or size.  */\n \n-  *symbol_present = false;\n-  *var_present = true;\n-  return no_cost;\n-}\n-\n-/* Estimates cost of expressing difference of addresses E1 - E2 as\n-   var + symbol + offset.  The value of offset is added to OFFSET,\n-   SYMBOL_PRESENT and VAR_PRESENT are set to false if the corresponding\n-   part is missing.  inv_vars is a set of the invariants the computation\n-   depends on.  */\n-\n-static comp_cost\n-ptr_difference_cost (struct ivopts_data *data,\n-\t\t     tree e1, tree e2, bool *symbol_present, bool *var_present,\n-\t\t     unsigned HOST_WIDE_INT *offset, bitmap *inv_vars)\n+enum ainc_type\n {\n-  HOST_WIDE_INT diff = 0;\n-  aff_tree aff_e1, aff_e2;\n-  tree type;\n-\n-  gcc_assert (TREE_CODE (e1) == ADDR_EXPR);\n-\n-  if (ptr_difference_const (e1, e2, &diff))\n-    {\n-      *offset += diff;\n-      *symbol_present = false;\n-      *var_present = false;\n-      return no_cost;\n-    }\n-\n-  if (integer_zerop (e2))\n-    return split_address_cost (data, TREE_OPERAND (e1, 0),\n-\t\t\t       symbol_present, var_present, offset, inv_vars);\n-\n-  *symbol_present = false;\n-  *var_present = true;\n-\n-  type = signed_type_for (TREE_TYPE (e1));\n-  tree_to_aff_combination (e1, type, &aff_e1);\n-  tree_to_aff_combination (e2, type, &aff_e2);\n-  aff_combination_scale (&aff_e2, -1);\n-  aff_combination_add (&aff_e1, &aff_e2);\n-\n-  return force_var_cost (data, aff_combination_to_tree (&aff_e1), inv_vars);\n-}\n-\n-/* Estimates cost of expressing difference E1 - E2 as\n-   var + symbol + offset.  The value of offset is added to OFFSET,\n-   SYMBOL_PRESENT and VAR_PRESENT are set to false if the corresponding\n-   part is missing.  INV_VARS is a set of the invariants the computation\n-   depends on.  */\n+  AINC_PRE_INC,\t\t/* Pre increment.  */\n+  AINC_PRE_DEC,\t\t/* Pre decrement.  */\n+  AINC_POST_INC,\t/* Post increment.  */\n+  AINC_POST_DEC,\t/* Post decrement.  */\n+  AINC_NONE\t\t/* Also the number of auto increment types.  */\n+};\n \n-static comp_cost\n-difference_cost (struct ivopts_data *data,\n-\t\t tree e1, tree e2, bool *symbol_present, bool *var_present,\n-\t\t unsigned HOST_WIDE_INT *offset, bitmap *inv_vars)\n+struct ainc_cost_data\n {\n-  machine_mode mode = TYPE_MODE (TREE_TYPE (e1));\n-  unsigned HOST_WIDE_INT off1, off2;\n-  aff_tree aff_e1, aff_e2;\n-  tree type;\n-\n-  e1 = strip_offset (e1, &off1);\n-  e2 = strip_offset (e2, &off2);\n-  *offset += off1 - off2;\n-\n-  STRIP_NOPS (e1);\n-  STRIP_NOPS (e2);\n+  unsigned costs[AINC_NONE];\n+};\n \n-  if (TREE_CODE (e1) == ADDR_EXPR)\n-    return ptr_difference_cost (data, e1, e2, symbol_present, var_present,\n-\t\t\t\toffset, inv_vars);\n-  *symbol_present = false;\n+static comp_cost\n+get_address_cost_ainc (HOST_WIDE_INT ainc_step, HOST_WIDE_INT ainc_offset,\n+\t\t       machine_mode addr_mode, machine_mode mem_mode,\n+\t\t       addr_space_t as, bool speed)\n+{\n+  if (!USE_LOAD_PRE_DECREMENT (mem_mode)\n+      && !USE_STORE_PRE_DECREMENT (mem_mode)\n+      && !USE_LOAD_POST_DECREMENT (mem_mode)\n+      && !USE_STORE_POST_DECREMENT (mem_mode)\n+      && !USE_LOAD_PRE_INCREMENT (mem_mode)\n+      && !USE_STORE_PRE_INCREMENT (mem_mode)\n+      && !USE_LOAD_POST_INCREMENT (mem_mode)\n+      && !USE_STORE_POST_INCREMENT (mem_mode))\n+    return infinite_cost;\n \n-  if (operand_equal_p (e1, e2, 0))\n+  static vec<ainc_cost_data *> ainc_cost_data_list;\n+  unsigned idx = (unsigned) as * MAX_MACHINE_MODE + (unsigned) mem_mode;\n+  if (idx >= ainc_cost_data_list.length ())\n     {\n-      *var_present = false;\n-      return no_cost;\n-    }\n+      unsigned nsize = ((unsigned) as + 1) *MAX_MACHINE_MODE;\n \n-  *var_present = true;\n-\n-  if (integer_zerop (e2))\n-    return force_var_cost (data, e1, inv_vars);\n-\n-  if (integer_zerop (e1))\n-    {\n-      comp_cost cost = force_var_cost (data, e2, inv_vars);\n-      cost += mult_by_coeff_cost (-1, mode, data->speed);\n-      return cost;\n+      gcc_assert (nsize > idx);\n+      ainc_cost_data_list.safe_grow_cleared (nsize);\n     }\n \n-  type = signed_type_for (TREE_TYPE (e1));\n-  tree_to_aff_combination (e1, type, &aff_e1);\n-  tree_to_aff_combination (e2, type, &aff_e2);\n-  aff_combination_scale (&aff_e2, -1);\n-  aff_combination_add (&aff_e1, &aff_e2);\n-\n-  return force_var_cost (data, aff_combination_to_tree (&aff_e1), inv_vars);\n-}\n-\n-/* Returns true if AFF1 and AFF2 are identical.  */\n-\n-static bool\n-compare_aff_trees (aff_tree *aff1, aff_tree *aff2)\n-{\n-  unsigned i;\n-\n-  if (aff1->n != aff2->n)\n-    return false;\n-\n-  for (i = 0; i < aff1->n; i++)\n+  ainc_cost_data *data = ainc_cost_data_list[idx];\n+  if (data == NULL)\n     {\n-      if (aff1->elts[i].coef != aff2->elts[i].coef)\n-\treturn false;\n+      rtx reg = gen_raw_REG (addr_mode, LAST_VIRTUAL_REGISTER + 1);\n \n-      if (!operand_equal_p (aff1->elts[i].val, aff2->elts[i].val, 0))\n-\treturn false;\n-    }\n-  return true;\n-}\n+      data = (ainc_cost_data *) xcalloc (1, sizeof (*data));\n+      data->costs[AINC_PRE_DEC] = INFTY;\n+      data->costs[AINC_POST_DEC] = INFTY;\n+      data->costs[AINC_PRE_INC] = INFTY;\n+      data->costs[AINC_POST_INC] = INFTY;\n+      if (USE_LOAD_PRE_DECREMENT (mem_mode)\n+\t  || USE_STORE_PRE_DECREMENT (mem_mode))\n+\t{\n+\t  rtx addr = gen_rtx_PRE_DEC (addr_mode, reg);\n \n-/* Stores EXPR in DATA->inv_expr_tab, return pointer to iv_inv_expr_ent.  */\n+\t  if (memory_address_addr_space_p (mem_mode, addr, as))\n+\t    data->costs[AINC_PRE_DEC]\n+\t      = address_cost (addr, mem_mode, as, speed);\n+\t}\n+      if (USE_LOAD_POST_DECREMENT (mem_mode)\n+\t  || USE_STORE_POST_DECREMENT (mem_mode))\n+\t{\n+\t  rtx addr = gen_rtx_POST_DEC (addr_mode, reg);\n \n-static iv_inv_expr_ent *\n-record_inv_expr (struct ivopts_data *data, tree expr)\n-{\n-  struct iv_inv_expr_ent ent;\n-  struct iv_inv_expr_ent **slot;\n+\t  if (memory_address_addr_space_p (mem_mode, addr, as))\n+\t    data->costs[AINC_POST_DEC]\n+\t      = address_cost (addr, mem_mode, as, speed);\n+\t}\n+      if (USE_LOAD_PRE_INCREMENT (mem_mode)\n+\t  || USE_STORE_PRE_INCREMENT (mem_mode))\n+\t{\n+\t  rtx addr = gen_rtx_PRE_INC (addr_mode, reg);\n \n-  ent.expr = expr;\n-  ent.hash = iterative_hash_expr (expr, 0);\n-  slot = data->inv_expr_tab->find_slot (&ent, INSERT);\n+\t  if (memory_address_addr_space_p (mem_mode, addr, as))\n+\t    data->costs[AINC_PRE_INC]\n+\t      = address_cost (addr, mem_mode, as, speed);\n+\t}\n+      if (USE_LOAD_POST_INCREMENT (mem_mode)\n+\t  || USE_STORE_POST_INCREMENT (mem_mode))\n+\t{\n+\t  rtx addr = gen_rtx_POST_INC (addr_mode, reg);\n \n-  if (!*slot)\n-    {\n-      *slot = XNEW (struct iv_inv_expr_ent);\n-      (*slot)->expr = expr;\n-      (*slot)->hash = ent.hash;\n-      (*slot)->id = data->max_inv_expr_id++;\n+\t  if (memory_address_addr_space_p (mem_mode, addr, as))\n+\t    data->costs[AINC_POST_INC]\n+\t      = address_cost (addr, mem_mode, as, speed);\n+\t}\n+      ainc_cost_data_list[idx] = data;\n     }\n \n-  return *slot;\n-}\n+  HOST_WIDE_INT msize = GET_MODE_SIZE (mem_mode);\n+  if (ainc_offset == 0 && msize == ainc_step)\n+    return comp_cost (data->costs[AINC_POST_INC], 0);\n+  if (ainc_offset == 0 && msize == -ainc_step)\n+    return comp_cost (data->costs[AINC_POST_DEC], 0);\n+  if (ainc_offset == msize && msize == ainc_step)\n+    return comp_cost (data->costs[AINC_PRE_INC], 0);\n+  if (ainc_offset == -msize && msize == -ainc_step)\n+    return comp_cost (data->costs[AINC_PRE_DEC], 0);\n \n-/* Returns the invariant expression if expression UBASE - RATIO * CBASE\n-   requires a new compiler generated temporary.  Returns -1 otherwise.\n-   ADDRESS_P is a flag indicating if the expression is for address\n-   computation.  */\n-\n-static iv_inv_expr_ent *\n-get_loop_invariant_expr (struct ivopts_data *data, tree ubase,\n-\t\t\t tree cbase, HOST_WIDE_INT ratio,\n-\t\t\t bool address_p)\n-{\n-  aff_tree ubase_aff, cbase_aff;\n-  tree expr, ub, cb;\n+  return infinite_cost;\n+}\n \n-  STRIP_NOPS (ubase);\n-  STRIP_NOPS (cbase);\n-  ub = ubase;\n-  cb = cbase;\n+/* Return cost of computing USE's address expression by using CAND.\n+   AFF_INV and AFF_VAR represent invariant and variant parts of the\n+   address expression, respectively.  If AFF_INV is simple, store\n+   the loop invariant variables which are depended by it in INV_VARS;\n+   if AFF_INV is complicated, handle it as a new invariant expression\n+   and record it in INV_EXPR.  RATIO indicates multiple times between\n+   steps of USE and CAND.  If CAN_AUTOINC is nonNULL, store boolean\n+   value to it indicating if this is an auto-increment address.  */\n \n-  if ((TREE_CODE (ubase) == INTEGER_CST)\n-      && (TREE_CODE (cbase) == INTEGER_CST))\n-    return NULL;\n+static comp_cost\n+get_address_cost (struct ivopts_data *data, struct iv_use *use,\n+\t\t  struct iv_cand *cand, aff_tree *aff_inv,\n+\t\t  aff_tree *aff_var, HOST_WIDE_INT ratio,\n+\t\t  bitmap *inv_vars, iv_inv_expr_ent **inv_expr,\n+\t\t  bool *can_autoinc, bool speed)\n+{\n+  rtx addr;\n+  bool simple_inv = true;\n+  tree comp_inv = NULL_TREE, type = aff_var->type;\n+  comp_cost var_cost = no_cost, cost = no_cost;\n+  struct mem_address parts = {NULL_TREE, integer_one_node,\n+\t\t\t      NULL_TREE, NULL_TREE, NULL_TREE};\n+  machine_mode addr_mode = TYPE_MODE (type);\n+  machine_mode mem_mode = TYPE_MODE (TREE_TYPE (*use->op_p));\n+  addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (use->iv->base));\n \n-  /* Strips the constant part. */\n-  if (TREE_CODE (ubase) == PLUS_EXPR\n-      || TREE_CODE (ubase) == MINUS_EXPR\n-      || TREE_CODE (ubase) == POINTER_PLUS_EXPR)\n+  if (!aff_combination_const_p (aff_inv))\n     {\n-      if (TREE_CODE (TREE_OPERAND (ubase, 1)) == INTEGER_CST)\n-\tubase = TREE_OPERAND (ubase, 0);\n-    }\n+      parts.index = integer_one_node;\n+      /* Addressing mode \"base + index\".  */\n+      if (valid_mem_ref_p (mem_mode, as, &parts))\n+\t{\n+\t  parts.step = wide_int_to_tree (type, ratio);\n+\t  /* Addressing mode \"base + index << scale\".  */\n+\t  if (ratio != 1 && !valid_mem_ref_p (mem_mode, as, &parts))\n+\t    parts.step = NULL_TREE;\n \n-  /* Strips the constant part. */\n-  if (TREE_CODE (cbase) == PLUS_EXPR\n-      || TREE_CODE (cbase) == MINUS_EXPR\n-      || TREE_CODE (cbase) == POINTER_PLUS_EXPR)\n-    {\n-      if (TREE_CODE (TREE_OPERAND (cbase, 1)) == INTEGER_CST)\n-\tcbase = TREE_OPERAND (cbase, 0);\n-    }\n+\t  if (aff_inv->offset != 0)\n+\t    {\n+\t      parts.offset = wide_int_to_tree (sizetype, aff_inv->offset);\n+\t      /* Addressing mode \"base + index [<< scale] + offset\".  */\n+\t      if (!valid_mem_ref_p (mem_mode, as, &parts))\n+\t\tparts.offset = NULL_TREE;\n+\t      else\n+\t\taff_inv->offset = 0;\n+\t    }\n \n-  if (address_p)\n-    {\n-      if (((TREE_CODE (ubase) == SSA_NAME)\n-\t   || (TREE_CODE (ubase) == ADDR_EXPR\n-\t       && is_gimple_min_invariant (ubase)))\n-\t  && (TREE_CODE (cbase) == INTEGER_CST))\n-\treturn NULL;\n+\t  move_fixed_address_to_symbol (&parts, aff_inv);\n+\t  /* Base is fixed address and is moved to symbol part.  */\n+\t  if (parts.symbol != NULL_TREE && aff_combination_zero_p (aff_inv))\n+\t    parts.base = NULL_TREE;\n \n-      if (((TREE_CODE (cbase) == SSA_NAME)\n-\t   || (TREE_CODE (cbase) == ADDR_EXPR\n-\t       && is_gimple_min_invariant (cbase)))\n-\t  && (TREE_CODE (ubase) == INTEGER_CST))\n-\treturn NULL;\n+\t  /* Addressing mode \"symbol + base + index [<< scale] [+ offset]\".  */\n+\t  if (parts.symbol != NULL_TREE\n+\t      && !valid_mem_ref_p (mem_mode, as, &parts))\n+\t    {\n+\t      aff_combination_add_elt (aff_inv, parts.symbol, 1);\n+\t      parts.symbol = NULL_TREE;\n+\t      /* Reset SIMPLE_INV since symbol address needs to be computed\n+\t\t outside of address expression in this case.  */\n+\t      simple_inv = false;\n+\t      /* Symbol part is moved back to base part, it can't be NULL.  */\n+\t      parts.base = integer_one_node;\n+\t    }\n+\t}\n+      else\n+\tparts.index = NULL_TREE;\n     }\n-\n-  if (ratio == 1)\n+  else\n     {\n-      if (operand_equal_p (ubase, cbase, 0))\n-\treturn NULL;\n-\n-      if (TREE_CODE (ubase) == ADDR_EXPR\n-\t  && TREE_CODE (cbase) == ADDR_EXPR)\n+      if (can_autoinc && ratio == 1 && cst_and_fits_in_hwi (cand->iv->step))\n \t{\n-\t  tree usym, csym;\n-\n-\t  usym = TREE_OPERAND (ubase, 0);\n-\t  csym = TREE_OPERAND (cbase, 0);\n-\t  if (TREE_CODE (usym) == ARRAY_REF)\n+\t  HOST_WIDE_INT ainc_step = int_cst_value (cand->iv->step);\n+\t  HOST_WIDE_INT ainc_offset = (aff_inv->offset).to_shwi ();\n+\n+\t  if (stmt_after_increment (data->current_loop, cand, use->stmt))\n+\t    ainc_offset += ainc_step;\n+\t  cost = get_address_cost_ainc (ainc_step, ainc_offset,\n+\t\t\t\t\taddr_mode, mem_mode, as, speed);\n+\t  if (!cost.infinite_cost_p ())\n \t    {\n-\t      tree ind = TREE_OPERAND (usym, 1);\n-\t      if (TREE_CODE (ind) == INTEGER_CST\n-\t\t  && tree_fits_shwi_p (ind)\n-\t\t  && tree_to_shwi (ind) == 0)\n-\t\tusym = TREE_OPERAND (usym, 0);\n+\t      *can_autoinc = true;\n+\t      return cost;\n \t    }\n-\t  if (TREE_CODE (csym) == ARRAY_REF)\n-\t    {\n-\t      tree ind = TREE_OPERAND (csym, 1);\n-\t      if (TREE_CODE (ind) == INTEGER_CST\n-\t\t  && tree_fits_shwi_p (ind)\n-\t\t  && tree_to_shwi (ind) == 0)\n-\t\tcsym = TREE_OPERAND (csym, 0);\n-\t    }\n-\t  if (operand_equal_p (usym, csym, 0))\n-\t    return NULL;\n+\t  cost = no_cost;\n+\t}\n+      if (!aff_combination_zero_p (aff_inv))\n+\t{\n+\t  parts.offset = wide_int_to_tree (sizetype, aff_inv->offset);\n+\t  /* Addressing mode \"base + offset\".  */\n+\t  if (!valid_mem_ref_p (mem_mode, as, &parts))\n+\t    parts.offset = NULL_TREE;\n+\t  else\n+\t    aff_inv->offset = 0;\n \t}\n-      /* Now do more complex comparison  */\n-      tree_to_aff_combination (ubase, TREE_TYPE (ubase), &ubase_aff);\n-      tree_to_aff_combination (cbase, TREE_TYPE (cbase), &cbase_aff);\n-      if (compare_aff_trees (&ubase_aff, &cbase_aff))\n-\treturn NULL;\n     }\n \n-  tree_to_aff_combination (ub, TREE_TYPE (ub), &ubase_aff);\n-  tree_to_aff_combination (cb, TREE_TYPE (cb), &cbase_aff);\n+  if (simple_inv)\n+    simple_inv = (aff_inv == NULL\n+\t\t  || aff_combination_const_p (aff_inv)\n+\t\t  || aff_combination_singleton_var_p (aff_inv));\n+  if (!aff_combination_zero_p (aff_inv))\n+    comp_inv = aff_combination_to_tree (aff_inv);\n+  if (comp_inv != NULL_TREE)\n+    cost = force_var_cost (data, comp_inv, inv_vars);\n+  if (ratio != 1 && parts.step == NULL_TREE)\n+    var_cost += mult_by_coeff_cost (ratio, addr_mode, speed);\n+  if (comp_inv != NULL_TREE && parts.index == NULL_TREE)\n+    var_cost += add_cost (speed, addr_mode);\n+\n+  if (comp_inv && inv_expr && !simple_inv)\n+    {\n+      *inv_expr = get_loop_invariant_expr (data, comp_inv);\n+      /* Clear depends on.  */\n+      if (*inv_expr != NULL && inv_vars && *inv_vars)\n+\tbitmap_clear (*inv_vars);\n \n-  aff_combination_scale (&cbase_aff, -1 * ratio);\n-  aff_combination_add (&ubase_aff, &cbase_aff);\n-  expr = aff_combination_to_tree (&ubase_aff);\n-  return record_inv_expr (data, expr);\n+      /* Cost of small invariant expression adjusted against loop niters\n+\t is usually zero, which makes it difficult to be differentiated\n+\t from candidate based on loop invariant variables.  Secondly, the\n+\t generated invariant expression may not be hoisted out of loop by\n+\t following pass.  We penalize the cost by rounding up in order to\n+\t neutralize such effects.  */\n+      cost.cost = adjust_setup_cost (data, cost.cost, true);\n+      cost.scratch = cost.cost;\n+    }\n+\n+  cost += var_cost;\n+  addr = addr_for_mem_ref (&parts, as, false);\n+  gcc_assert (memory_address_addr_space_p (mem_mode, addr, as));\n+  cost += address_cost (addr, mem_mode, as, speed);\n+\n+  if (parts.symbol != NULL_TREE)\n+    cost.complexity += 1;\n+  if (parts.step != NULL_TREE && !integer_onep (parts.step))\n+    cost.complexity += 1;\n+  if (parts.base != NULL_TREE && parts.index != NULL_TREE)\n+    cost.complexity += 1;\n+  if (parts.offset != NULL_TREE && !integer_zerop (parts.offset))\n+    cost.complexity += 1;\n+\n+  return cost;\n }\n \n /* Scale (multiply) the computed COST (except scratch part that should be\n@@ -4816,31 +4470,25 @@ get_computation_cost (struct ivopts_data *data, struct iv_use *use,\n \t\t      bool *can_autoinc, iv_inv_expr_ent **inv_expr)\n {\n   gimple *at = use->stmt;\n-  tree ubase = use->iv->base, ustep = use->iv->step;\n-  tree cbase, cstep;\n-  tree utype = TREE_TYPE (ubase), ctype;\n-  unsigned HOST_WIDE_INT cstepi, offset = 0;\n+  tree ubase = use->iv->base, cbase = cand->iv->base;\n+  tree utype = TREE_TYPE (ubase), ctype = TREE_TYPE (cbase);\n+  tree comp_inv = NULL_TREE;\n   HOST_WIDE_INT ratio, aratio;\n-  bool var_present, symbol_present, stmt_is_after_inc;\n   comp_cost cost;\n   widest_int rat;\n+  aff_tree aff_inv, aff_var;\n   bool speed = optimize_bb_for_speed_p (gimple_bb (at));\n-  machine_mode mem_mode = (address_p\n-\t\t\t\t? TYPE_MODE (TREE_TYPE (*use->op_p))\n-\t\t\t\t: VOIDmode);\n \n   if (inv_vars)\n     *inv_vars = NULL;\n+  if (can_autoinc)\n+    *can_autoinc = false;\n+  if (inv_expr)\n+    *inv_expr = NULL;\n \n-  cbase = cand->iv->base;\n-  cstep = cand->iv->step;\n-  ctype = TREE_TYPE (cbase);\n-\n+  /* Check if we have enough precision to express the values of use.  */\n   if (TYPE_PRECISION (utype) > TYPE_PRECISION (ctype))\n-    {\n-      /* We do not have a precision to express the values of use.  */\n-      return infinite_cost;\n-    }\n+    return infinite_cost;\n \n   if (address_p\n       || (use->iv->base_object\n@@ -4859,180 +4507,65 @@ get_computation_cost (struct ivopts_data *data, struct iv_use *use,\n \treturn infinite_cost;\n     }\n \n-  if (TYPE_PRECISION (utype) < TYPE_PRECISION (ctype))\n-    {\n-      /* TODO -- add direct handling of this case.  */\n-      goto fallback;\n-    }\n-\n-  /* CSTEPI is removed from the offset in case statement is after the\n-     increment.  If the step is not constant, we use zero instead.\n-     This is a bit imprecise (there is the extra addition), but\n-     redundancy elimination is likely to transform the code so that\n-     it uses value of the variable before increment anyway,\n-     so it is not that much unrealistic.  */\n-  if (cst_and_fits_in_hwi (cstep))\n-    cstepi = int_cst_value (cstep);\n-  else\n-    cstepi = 0;\n-\n-  if (!constant_multiple_of (ustep, cstep, &rat))\n-    return infinite_cost;\n-\n-  if (wi::fits_shwi_p (rat))\n-    ratio = rat.to_shwi ();\n-  else\n+  if (!get_computation_aff_1 (data->current_loop, at, use,\n+\t\t\t      cand, &aff_inv, &aff_var, &rat)\n+      || !wi::fits_shwi_p (rat))\n     return infinite_cost;\n \n-  STRIP_NOPS (cbase);\n-  ctype = TREE_TYPE (cbase);\n-\n-  stmt_is_after_inc = stmt_after_increment (data->current_loop, cand, at);\n-\n-  /* use = ubase + ratio * (var - cbase).  If either cbase is a constant\n-     or ratio == 1, it is better to handle this like\n-\n-     ubase - ratio * cbase + ratio * var\n-\n-     (also holds in the case ratio == -1, TODO.  */\n-\n-  if (cst_and_fits_in_hwi (cbase))\n-    {\n-      offset = - ratio * (unsigned HOST_WIDE_INT) int_cst_value (cbase);\n-      cost = difference_cost (data,\n-\t\t\t      ubase, build_int_cst (utype, 0),\n-\t\t\t      &symbol_present, &var_present, &offset,\n-\t\t\t      inv_vars);\n-      cost /= avg_loop_niter (data->current_loop);\n-    }\n-  else if (ratio == 1)\n-    {\n-      tree real_cbase = cbase;\n-\n-      /* Check to see if any adjustment is needed.  */\n-      if (cstepi == 0 && stmt_is_after_inc)\n-\t{\n-\t  aff_tree real_cbase_aff;\n-\t  aff_tree cstep_aff;\n-\n-\t  tree_to_aff_combination (cbase, TREE_TYPE (real_cbase),\n-\t\t\t\t   &real_cbase_aff);\n-\t  tree_to_aff_combination (cstep, TREE_TYPE (cstep), &cstep_aff);\n-\n-\t  aff_combination_add (&real_cbase_aff, &cstep_aff);\n-\t  real_cbase = aff_combination_to_tree (&real_cbase_aff);\n-\t}\n-\n-      cost = difference_cost (data,\n-\t\t\t      ubase, real_cbase,\n-\t\t\t      &symbol_present, &var_present, &offset,\n-\t\t\t      inv_vars);\n-      cost /= avg_loop_niter (data->current_loop);\n-    }\n-  else if (address_p\n-\t   && !POINTER_TYPE_P (ctype)\n-\t   && multiplier_allowed_in_address_p\n-\t\t(ratio, mem_mode,\n-\t\t\tTYPE_ADDR_SPACE (TREE_TYPE (utype))))\n-    {\n-      tree real_cbase = cbase;\n-\n-      if (cstepi == 0 && stmt_is_after_inc)\n-\t{\n-\t  if (POINTER_TYPE_P (ctype))\n-\t    real_cbase = fold_build2 (POINTER_PLUS_EXPR, ctype, cbase, cstep);\n-\t  else\n-\t    real_cbase = fold_build2 (PLUS_EXPR, ctype, cbase, cstep);\n-\t}\n-      real_cbase = fold_build2 (MULT_EXPR, ctype, real_cbase,\n-\t\t\t\tbuild_int_cst (ctype, ratio));\n-      cost = difference_cost (data,\n-\t\t\t      ubase, real_cbase,\n-\t\t\t      &symbol_present, &var_present, &offset,\n-\t\t\t      inv_vars);\n-      cost /= avg_loop_niter (data->current_loop);\n-    }\n-  else\n+  ratio = rat.to_shwi ();\n+  if (address_p)\n     {\n-      cost = force_var_cost (data, cbase, inv_vars);\n-      cost += difference_cost (data, ubase, build_int_cst (utype, 0),\n-\t\t\t       &symbol_present, &var_present, &offset,\n-\t\t\t       inv_vars);\n-      cost /= avg_loop_niter (data->current_loop);\n-      cost += add_cost (data->speed, TYPE_MODE (ctype));\n+      cost = get_address_cost (data, use, cand, &aff_inv, &aff_var, ratio,\n+\t\t\t       inv_vars, inv_expr, can_autoinc, speed);\n+      return get_scaled_computation_cost_at (data, at, cost);\n     }\n \n-  /* Record setup cost in scratch field.  */\n-  cost.scratch = cost.cost;\n+  bool simple_inv = (aff_combination_const_p (&aff_inv)\n+\t\t     || aff_combination_singleton_var_p (&aff_inv));\n+  tree signed_type = signed_type_for (aff_combination_type (&aff_inv));\n+  aff_combination_convert (&aff_inv, signed_type);\n+  if (!aff_combination_zero_p (&aff_inv))\n+    comp_inv = aff_combination_to_tree (&aff_inv);\n \n-  if (inv_expr && inv_vars && *inv_vars)\n+  cost = force_var_cost (data, comp_inv, inv_vars);\n+  if (comp_inv && inv_expr && !simple_inv)\n     {\n-      *inv_expr = get_loop_invariant_expr (data, ubase, cbase, ratio,\n-\t\t\t\t\t   address_p);\n+      *inv_expr = get_loop_invariant_expr (data, comp_inv);\n       /* Clear depends on.  */\n-      if (*inv_expr != NULL)\n+      if (*inv_expr != NULL && inv_vars && *inv_vars)\n \tbitmap_clear (*inv_vars);\n-    }\n \n-  /* If we are after the increment, the value of the candidate is higher by\n-     one iteration.  */\n-  if (stmt_is_after_inc)\n-    offset -= ratio * cstepi;\n-\n-  /* Now the computation is in shape symbol + var1 + const + ratio * var2.\n-     (symbol/var1/const parts may be omitted).  If we are looking for an\n-     address, find the cost of addressing this.  */\n-  if (address_p)\n-    {\n-      cost += get_address_cost (symbol_present, var_present,\n-\t\t\t\toffset, ratio, cstepi,\n-\t\t\t\tmem_mode,\n-\t\t\t\tTYPE_ADDR_SPACE (TREE_TYPE (utype)),\n-\t\t\t\tspeed, stmt_is_after_inc, can_autoinc);\n-      return get_scaled_computation_cost_at (data, at, cost);\n+      cost.cost = adjust_setup_cost (data, cost.cost);\n+      /* Record setup cost in scratch field.  */\n+      cost.scratch = cost.cost;\n     }\n+  /* Cost of constant integer can be covered when adding invariant part to\n+     variant part.  */\n+  else if (comp_inv && CONSTANT_CLASS_P (comp_inv))\n+    cost = no_cost;\n \n-  /* Otherwise estimate the costs for computing the expression.  */\n-  if (!symbol_present && !var_present && !offset)\n+  /* Need type narrowing to represent use with cand.  */\n+  if (TYPE_PRECISION (utype) < TYPE_PRECISION (ctype))\n     {\n-      if (ratio != 1)\n-\tcost += mult_by_coeff_cost (ratio, TYPE_MODE (ctype), speed);\n-      return get_scaled_computation_cost_at (data, at, cost);\n+      machine_mode outer_mode = TYPE_MODE (utype);\n+      machine_mode inner_mode = TYPE_MODE (ctype);\n+      cost += comp_cost (convert_cost (outer_mode, inner_mode, speed), 0);\n     }\n \n-  /* Symbol + offset should be compile-time computable so consider that they\n-      are added once to the variable, if present.  */\n-  if (var_present && (symbol_present || offset))\n-    cost += adjust_setup_cost (data,\n-\t\t\t\t    add_cost (speed, TYPE_MODE (ctype)));\n-\n-  /* Having offset does not affect runtime cost in case it is added to\n-     symbol, but it increases complexity.  */\n-  if (offset)\n-    cost.complexity++;\n-\n-  cost += add_cost (speed, TYPE_MODE (ctype));\n-\n-  aratio = ratio > 0 ? ratio : -ratio;\n-  if (aratio != 1)\n-    cost += mult_by_coeff_cost (aratio, TYPE_MODE (ctype), speed);\n-\n-  return get_scaled_computation_cost_at (data, at, cost);\n-\n-fallback:\n-  if (can_autoinc)\n-    *can_autoinc = false;\n-\n-  /* Just get the expression, expand it and measure the cost.  */\n-  tree comp = get_computation_at (data->current_loop, at, use, cand);\n-\n-  if (!comp)\n-    return infinite_cost;\n+  /* Turn a + i * (-c) into a - i * c.  */\n+  if (ratio < 0 && comp_inv && !integer_zerop (comp_inv))\n+    aratio = -ratio;\n+  else\n+    aratio = ratio;\n \n-  if (address_p)\n-    comp = build_simple_mem_ref (comp);\n+  if (ratio != 1)\n+    cost += mult_by_coeff_cost (aratio, TYPE_MODE (utype), speed);\n \n-  cost = comp_cost (computation_cost (comp, speed), 0);\n+  /* TODO: We may also need to check if we can compute  a + i * 4 in one\n+     instruction.  */\n+  /* Need to add up the invariant and variant parts.  */\n+  if (comp_inv && !integer_zerop (comp_inv))\n+    cost += add_cost (speed, TYPE_MODE (utype));\n \n   return get_scaled_computation_cost_at (data, at, cost);\n }\n@@ -5113,7 +4646,14 @@ determine_group_iv_cost_address (struct ivopts_data *data,\n \t same cost as the first iv_use, but the cost really depends on the\n \t offset and where the iv_use is.  */\n \tcost = get_computation_cost (data, next, cand, true,\n-\t\t\t\t     NULL, &can_autoinc, NULL);\n+\t\t\t\t     NULL, &can_autoinc, &inv_expr);\n+\tif (inv_expr)\n+\t  {\n+\t    if (!inv_exprs)\n+\t      inv_exprs = BITMAP_ALLOC (NULL);\n+\n+\t    bitmap_set_bit (inv_exprs, inv_expr->id);\n+\t  }\n       sum_cost += cost;\n     }\n   set_group_iv_cost (data, group, cand, sum_cost, inv_vars,\n@@ -5560,7 +5100,7 @@ determine_group_iv_cost_cond (struct ivopts_data *data,\n \t inv_expr_elim instead.  */\n       if (inv_vars_elim && bitmap_count_bits (inv_vars_elim) > 1)\n \t{\n-\t  inv_expr_elim = record_inv_expr (data, bound);\n+\t  inv_expr_elim = get_loop_invariant_expr (data, bound);\n \t  bitmap_clear (inv_vars_elim);\n \t}\n       /* The bound is a loop invariant, so it will be only computed\n@@ -6221,25 +5761,21 @@ iv_ca_cost (struct iv_ca *ivs)\n     return ivs->cost;\n }\n \n-/* Returns true if all dependences of CP are among invariants in IVS.  */\n+/* Returns true if applying NEW_CP to GROUP for IVS introduces more\n+   invariants than OLD_CP.  */\n \n static bool\n-iv_ca_has_deps (struct iv_ca *ivs, struct cost_pair *cp)\n+iv_ca_more_deps (struct ivopts_data *data, struct iv_ca *ivs,\n+\t\t struct iv_group *group, struct cost_pair *old_cp,\n+\t\t struct cost_pair *new_cp)\n {\n-  unsigned i;\n-  bitmap_iterator bi;\n+  gcc_assert (old_cp && new_cp && old_cp != new_cp);\n+  unsigned old_n_invs = ivs->n_invs;\n+  iv_ca_set_cp (data, ivs, group, new_cp);\n+  unsigned new_n_invs = ivs->n_invs;\n+  iv_ca_set_cp (data, ivs, group, old_cp);\n \n-  if (cp->inv_vars)\n-    EXECUTE_IF_SET_IN_BITMAP (cp->inv_vars, 0, i, bi)\n-      if (ivs->n_inv_var_uses[i] == 0)\n-\treturn false;\n-\n-  if (cp->inv_exprs)\n-    EXECUTE_IF_SET_IN_BITMAP (cp->inv_exprs, 0, i, bi)\n-      if (ivs->n_inv_expr_uses[i] == 0)\n-\treturn false;\n-\n-  return true;\n+  return (new_n_invs > old_n_invs);\n }\n \n /* Creates change of expressing GROUP by NEW_CP instead of OLD_CP and chains\n@@ -6471,7 +6007,7 @@ iv_ca_extend (struct ivopts_data *data, struct iv_ca *ivs,\n       if (!new_cp)\n \tcontinue;\n \n-      if (!min_ncand && !iv_ca_has_deps (ivs, new_cp))\n+      if (!min_ncand && iv_ca_more_deps (data, ivs, group, old_cp, new_cp))\n \tcontinue;\n \n       if (!min_ncand && !cheaper_cost_pair (new_cp, old_cp))"}]}