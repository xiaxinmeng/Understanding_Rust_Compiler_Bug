{"sha": "437f4a0024d9829a138ad1f5b0311cbf4289d5e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM3ZjRhMDAyNGQ5ODI5YTEzOGFkMWY1YjAzMTFjYmY0Mjg5ZDVlMw==", "commit": {"author": {"name": "Ira Rosen", "email": "ira.rosen@linaro.org", "date": "2011-04-28T19:50:28Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2011-04-28T19:50:28Z"}, "message": "re PR tree-optimization/48765 (ICE in vect_transform_stmt)\n\n\n        PR tree-optimization/48765\n        * tree-vectorizer.h (vect_make_slp_decision): Return bool.\n        * tree-vect-loop.c (vect_analyze_loop_operations): Add new\n        argument to indicate if loop aware SLP is being used.  Scan\n        the statements and update the vectorization factor\n        according to the type of\n        vectorization before statement analysis.\n        (vect_analyze_loop_2): Get a return value from\n        vect_make_slp_decision, pass it to \n        vect_analyze_loop_operations.\n        (vectorizable_reduction): Set number of copies to 1 in case of\n        pure SLP statement.\n        * tree-vect-stmts.c (vectorizable_conversion,\n        vectorizable_assignment, vectorizable_shift,\n        vectorizable_operation, vectorizable_type_demotion,\n        vectorizable_type_promotion, vectorizable_store,\n        vectorizable_load): Likewise.\n        (vectorizable_condition): Move the check that it is not SLP\n        vectorization before the number of copies check.\n        * tree-vect-slp.c (vect_make_slp_decision): Return TRUE if\n        decided to vectorize the loop using SLP.\n\nFrom-SVN: r173132", "tree": {"sha": "d74e91634ee0c939232faa3f82d1f68d10da27ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d74e91634ee0c939232faa3f82d1f68d10da27ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/437f4a0024d9829a138ad1f5b0311cbf4289d5e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/437f4a0024d9829a138ad1f5b0311cbf4289d5e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/437f4a0024d9829a138ad1f5b0311cbf4289d5e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/437f4a0024d9829a138ad1f5b0311cbf4289d5e3/comments", "author": null, "committer": null, "parents": [{"sha": "45540bcf241167158663d4e7970749c103a8afd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45540bcf241167158663d4e7970749c103a8afd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45540bcf241167158663d4e7970749c103a8afd2"}], "stats": {"total": 208, "additions": 166, "deletions": 42}, "files": [{"sha": "459923e46861370342f5ff713bb0b46cabaee036", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437f4a0024d9829a138ad1f5b0311cbf4289d5e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437f4a0024d9829a138ad1f5b0311cbf4289d5e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=437f4a0024d9829a138ad1f5b0311cbf4289d5e3", "patch": "@@ -1,3 +1,25 @@\n+2011-04-28  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\tPR tree-optimization/48765\n+\t* tree-vectorizer.h (vect_make_slp_decision): Return bool.\n+\t* tree-vect-loop.c (vect_analyze_loop_operations): Add new argument\n+\tto indicate if loop aware SLP is being used.  Scan the statements\n+\tand update the vectorization factor according to the type of\n+\tvectorization before statement analysis.\n+\t(vect_analyze_loop_2): Get a return value from vect_make_slp_decision,\n+\tpass it to vect_analyze_loop_operations.\n+\t(vectorizable_reduction): Set number of copies to 1 in case of pure\n+\tSLP statement.\n+\t* tree-vect-stmts.c (vectorizable_conversion,\n+\tvectorizable_assignment, vectorizable_shift,\n+\tvectorizable_operation, vectorizable_type_demotion,\n+\tvectorizable_type_promotion, vectorizable_store, vectorizable_load):\n+\tLikewise.\n+\t(vectorizable_condition): Move the check that it is not SLP\n+\tvectorization before the number of copies check.\n+\t* tree-vect-slp.c (vect_make_slp_decision): Return TRUE if decided\n+\tto vectorize the loop using SLP.\n+\n 2011-04-28  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/48597"}, {"sha": "6e17672032d223db8a3e1a7d79d234ea5624af70", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437f4a0024d9829a138ad1f5b0311cbf4289d5e3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437f4a0024d9829a138ad1f5b0311cbf4289d5e3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=437f4a0024d9829a138ad1f5b0311cbf4289d5e3", "patch": "@@ -1,3 +1,8 @@\n+2011-04-28  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\tPR tree-optimization/48765\n+\t* gcc.dg/vect/pr48765.c: New.\n+\n 2011-04-28  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR tree-optimization/48775"}, {"sha": "469c4f423ce24f5ae7c920f62820338c62b2778b", "filename": "gcc/testsuite/gcc.dg/vect/pr48765.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437f4a0024d9829a138ad1f5b0311cbf4289d5e3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr48765.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437f4a0024d9829a138ad1f5b0311cbf4289d5e3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr48765.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr48765.c?ref=437f4a0024d9829a138ad1f5b0311cbf4289d5e3", "patch": "@@ -0,0 +1,82 @@\n+/* { dg-do compile { target powerpc*-*-* } } */\n+/* { dg-options \"-m64 -O3 -mcpu=power6\" } */\n+\n+enum reg_class\n+{\n+  NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS, XGRF_REGS, ALL_REGS,\n+    LIM_REG_CLASSES\n+};\n+enum machine_mode\n+{\n+  VOIDmode, QImode, HImode, PSImode, SImode, PDImode, DImode, TImode, OImode,\n+    QFmode, HFmode, TQFmode, SFmode, DFmode, XFmode, TFmode, SCmode, DCmode,\n+    XCmode, TCmode, CQImode, CHImode, CSImode, CDImode, CTImode, COImode,\n+    BLKmode, CCmode, CCEVENmode, MAX_MACHINE_MODE\n+};\n+typedef struct rtx_def\n+{\n+  int mode:8;\n+}\n+ *rtx;\n+extern rtx *regno_reg_rtx;\n+typedef unsigned int HARD_REG_ELT_TYPE;\n+typedef HARD_REG_ELT_TYPE HARD_REG_SET[((64 + 32 - 1) / 32)];\n+extern int reg_alloc_order[64];\n+extern int max_regno;\n+extern int *reg_n_calls_crossed;\n+extern short *reg_renumber;\n+static int *reg_where_dead;\n+static int *reg_where_born;\n+static int *reg_order;\n+static char *regs_change_size;\n+static HARD_REG_SET *after_insn_hard_regs;\n+static int stupid_find_reg (int, enum reg_class, enum machine_mode, int, int,\n+\t\t\t    int);\n+void\n+stupid_life_analysis (f, nregs, file)\n+     rtx f;\n+{\n+  register int i;\n+  for (i = (((64)) + 3) + 1; i < max_regno; i++)\n+    {\n+      register int r = reg_order[i];\n+      if ((int) LIM_REG_CLASSES > 1)\n+\treg_renumber[r] =\n+\t  stupid_find_reg (reg_n_calls_crossed[r], reg_preferred_class (r),\n+\t\t\t   ((regno_reg_rtx[r])->mode), reg_where_born[r],\n+\t\t\t   reg_where_dead[r], regs_change_size[r]);\n+    }\n+}\n+\n+static int\n+stupid_find_reg (call_preserved, class, mode, born_insn, dead_insn,\n+\t\t changes_size)\n+     int call_preserved;\n+     enum reg_class class;\n+     enum machine_mode mode;\n+{\n+  register int i, ins;\n+  HARD_REG_SET used, this_reg;\n+  for (ins = born_insn; ins < dead_insn; ins++)\n+    do\n+      {\n+\tregister HARD_REG_ELT_TYPE *scan_tp_ = (used), *scan_fp_ =\n+\t  (after_insn_hard_regs[ins]);\n+\tfor (i = 0; i < ((64 + 32 - 1) / 32); i++)\n+\t  *scan_tp_++ |= *scan_fp_++;\n+      }\n+    while (0);\n+  for (i = 0; i < 64; i++)\n+    {\n+      int regno = reg_alloc_order[i];\n+      if (((used)[(regno) / ((unsigned) 32)] &\n+\t   (((HARD_REG_ELT_TYPE) (1)) << ((regno) % ((unsigned) 32)))))\n+\t{\n+\t  register int j;\n+\t  if (j == regno)\n+\t    return regno;\n+\t}\n+    }\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e05c324d0b944b6041f046db5cef4783c0ecd4fd", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 39, "deletions": 27, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437f4a0024d9829a138ad1f5b0311cbf4289d5e3/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437f4a0024d9829a138ad1f5b0311cbf4289d5e3/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=437f4a0024d9829a138ad1f5b0311cbf4289d5e3", "patch": "@@ -1146,7 +1146,7 @@ vect_get_cost (enum vect_cost_for_stmt type_of_cost)\n    Scan the loop stmts and make sure they are all vectorizable.  */\n \n static bool\n-vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n+vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n@@ -1167,6 +1167,40 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n \n   gcc_assert (LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n   vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  if (slp)\n+    {\n+      /* If all the stmts in the loop can be SLPed, we perform only SLP, and\n+\t vectorization factor of the loop is the unrolling factor required by\n+\t the SLP instances.  If that unrolling factor is 1, we say, that we\n+\t perform pure SLP on loop - cross iteration parallelism is not\n+\t exploited.  */\n+      for (i = 0; i < nbbs; i++)\n+\t{\n+\t  basic_block bb = bbs[i];\n+\t  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+\t    {\n+\t      gimple stmt = gsi_stmt (si);\n+\t      stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\t      gcc_assert (stmt_info);\n+\t      if ((STMT_VINFO_RELEVANT_P (stmt_info)\n+\t\t   || VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (stmt_info)))\n+\t\t  && !PURE_SLP_STMT (stmt_info))\n+\t\t/* STMT needs both SLP and loop-based vectorization.  */\n+\t\tonly_slp_in_loop = false;\n+\t    }\n+\t}\n+\n+      if (only_slp_in_loop)\n+\tvectorization_factor = LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo);\n+      else\n+\tvectorization_factor = least_common_multiple (vectorization_factor,\n+\t\t\t\tLOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo));\n+\n+      LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"Updating vectorization factor to %d \",\n+\t \t\t    vectorization_factor);\n+    }\n \n   for (i = 0; i < nbbs; i++)\n     {\n@@ -1272,18 +1306,8 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n       for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n         {\n           gimple stmt = gsi_stmt (si);\n-          stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-\n-          gcc_assert (stmt_info);\n-\n \t  if (!vect_analyze_stmt (stmt, &need_to_vectorize, NULL))\n \t    return false;\n-\n-          if ((STMT_VINFO_RELEVANT_P (stmt_info)\n-               || VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (stmt_info)))\n-              && !PURE_SLP_STMT (stmt_info))\n-            /* STMT needs both SLP and loop-based vectorization.  */\n-            only_slp_in_loop = false;\n         }\n     } /* bbs */\n \n@@ -1303,18 +1327,6 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n       return false;\n     }\n \n-  /* If all the stmts in the loop can be SLPed, we perform only SLP, and\n-     vectorization factor of the loop is the unrolling factor required by the\n-     SLP instances.  If that unrolling factor is 1, we say, that we perform\n-     pure SLP on loop - cross iteration parallelism is not exploited.  */\n-  if (only_slp_in_loop)\n-    vectorization_factor = LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo);\n-  else\n-    vectorization_factor = least_common_multiple (vectorization_factor,\n-                                LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo));\n-\n-  LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n-\n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       && vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump,\n@@ -1410,7 +1422,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n static bool\n vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n {\n-  bool ok, dummy;\n+  bool ok, dummy, slp = false;\n   int max_vf = MAX_VECTORIZATION_FACTOR;\n   int min_vf = 2;\n \n@@ -1524,7 +1536,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   if (ok)\n     {\n       /* Decide which possible SLP instances to SLP.  */\n-      vect_make_slp_decision (loop_vinfo);\n+      slp = vect_make_slp_decision (loop_vinfo);\n \n       /* Find stmts that need to be both vectorized and SLPed.  */\n       vect_detect_hybrid_slp (loop_vinfo);\n@@ -1533,7 +1545,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   /* Scan all the operations in the loop and make sure they are\n      vectorizable.  */\n \n-  ok = vect_analyze_loop_operations (loop_vinfo);\n+  ok = vect_analyze_loop_operations (loop_vinfo, slp);\n   if (!ok)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -4136,7 +4148,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   if (STMT_VINFO_LIVE_P (vinfo_for_stmt (reduc_def_stmt)))\n     return false;\n \n-  if (slp_node)\n+  if (slp_node || PURE_SLP_STMT (stmt_info))\n     ncopies = 1;\n   else\n     ncopies = (LOOP_VINFO_VECT_FACTOR (loop_vinfo)"}, {"sha": "c4464d52ee2a156e4d37c778cdaf3b281696d651", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437f4a0024d9829a138ad1f5b0311cbf4289d5e3/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437f4a0024d9829a138ad1f5b0311cbf4289d5e3/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=437f4a0024d9829a138ad1f5b0311cbf4289d5e3", "patch": "@@ -1351,9 +1351,10 @@ vect_analyze_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n \n \n /* For each possible SLP instance decide whether to SLP it and calculate overall\n-   unrolling factor needed to SLP the loop.  */\n+   unrolling factor needed to SLP the loop.  Return TRUE if decided to SLP at\n+   least one instance.  */\n \n-void\n+bool\n vect_make_slp_decision (loop_vec_info loop_vinfo)\n {\n   unsigned int i, unrolling_factor = 1;\n@@ -1382,6 +1383,8 @@ vect_make_slp_decision (loop_vec_info loop_vinfo)\n   if (decided_to_slp && vect_print_dump_info (REPORT_SLP))\n     fprintf (vect_dump, \"Decided to SLP %d instances. Unrolling factor %d\",\n \t     decided_to_slp, unrolling_factor);\n+\n+  return (decided_to_slp > 0);\n }\n \n "}, {"sha": "bf6f36290fbd8c976f9760be3e32742dc50ce3c6", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437f4a0024d9829a138ad1f5b0311cbf4289d5e3/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437f4a0024d9829a138ad1f5b0311cbf4289d5e3/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=437f4a0024d9829a138ad1f5b0311cbf4289d5e3", "patch": "@@ -1747,7 +1747,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n      case of SLP.  */\n-  if (slp_node)\n+  if (slp_node || PURE_SLP_STMT (stmt_info))\n     ncopies = 1;\n \n   /* Sanity check: make sure that at least one copy of the vectorized stmt\n@@ -1940,7 +1940,7 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n      case of SLP.  */\n-  if (slp_node)\n+  if (slp_node || PURE_SLP_STMT (stmt_info))\n     ncopies = 1;\n   else\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n@@ -2149,7 +2149,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n      case of SLP.  */\n-  if (slp_node)\n+  if (slp_node || PURE_SLP_STMT (stmt_info))\n     ncopies = 1;\n   else\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n@@ -2497,7 +2497,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n      case of SLP.  */\n-  if (slp_node)\n+  if (slp_node || PURE_SLP_STMT (stmt_info))\n     ncopies = 1;\n   else\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n@@ -2895,7 +2895,7 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n      case of SLP.  */\n-  if (slp_node)\n+  if (slp_node || PURE_SLP_STMT (stmt_info))\n     ncopies = 1;\n   else\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_out;\n@@ -3175,7 +3175,7 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n      case of SLP.  */\n-  if (slp_node)\n+  if (slp_node || PURE_SLP_STMT (stmt_info))\n     ncopies = 1;\n   else\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n@@ -3358,7 +3358,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n      case of SLP.  */\n-  if (slp)\n+  if (slp || PURE_SLP_STMT (stmt_info))\n     ncopies = 1;\n   else\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n@@ -3851,7 +3851,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n      case of SLP.  */\n-  if (slp)\n+  if (slp || PURE_SLP_STMT (stmt_info))\n     ncopies = 1;\n   else\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n@@ -4457,6 +4457,10 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   /* FORNOW: unsupported in basic block SLP.  */\n   gcc_assert (loop_vinfo);\n \n+  /* FORNOW: SLP not supported.  */\n+  if (STMT_SLP_TYPE (stmt_info))\n+    return false;\n+\n   gcc_assert (ncopies >= 1);\n   if (reduc_index && ncopies > 1)\n     return false; /* FORNOW */\n@@ -4469,10 +4473,6 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n            && reduc_def))\n     return false;\n \n-  /* FORNOW: SLP not supported.  */\n-  if (STMT_SLP_TYPE (stmt_info))\n-    return false;\n-\n   /* FORNOW: not yet supported.  */\n   if (STMT_VINFO_LIVE_P (stmt_info))\n     {"}, {"sha": "9181f673830b25fd013ce60d648b92b04af38c25", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437f4a0024d9829a138ad1f5b0311cbf4289d5e3/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437f4a0024d9829a138ad1f5b0311cbf4289d5e3/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=437f4a0024d9829a138ad1f5b0311cbf4289d5e3", "patch": "@@ -870,7 +870,7 @@ extern bool vect_transform_slp_perm_load (gimple, VEC (tree, heap) *,\n extern bool vect_schedule_slp (loop_vec_info, bb_vec_info);\n extern void vect_update_slp_costs_according_to_vf (loop_vec_info);\n extern bool vect_analyze_slp (loop_vec_info, bb_vec_info);\n-extern void vect_make_slp_decision (loop_vec_info);\n+extern bool vect_make_slp_decision (loop_vec_info);\n extern void vect_detect_hybrid_slp (loop_vec_info);\n extern void vect_get_slp_defs (tree, tree, slp_tree, VEC (tree,heap) **,\n                                VEC (tree,heap) **, int);"}]}