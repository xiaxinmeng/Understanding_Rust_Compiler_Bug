{"sha": "0aafb128c06a4cbc4a6940c98fbfa4b4975398fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFhZmIxMjhjMDZhNGNiYzRhNjk0MGM5OGZiZmE0YjQ5NzUzOThmZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-04-22T23:13:12Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-04-22T23:13:12Z"}, "message": "cp-tree.h (lang_decl_flags): Remove returns_first_arg and preserves_first_arg.\n\n\t* cp-tree.h (lang_decl_flags): Remove returns_first_arg and\n\tpreserves_first_arg.  Enlarge dummy accordingly.\n\t(DECL_TINFO_FN_P): New macro.\n\t(SET_DECL_TINO_FN_P): Likeiwse.\n\t(DECL_RETURNS_FIRST_ARG): Remove.\n\t(DECL_PRESERVES_THIS): Likewise.\n\t(DECL_INIT_PRIORITY): New macro.\n\t(finish_struct_1): Change prototype.\n\t(cat_namespace_levels): Remove prototype.\n\t(vtable_decl_p): New prototype.\n\t(vtype_decl_p): Likewise.\n\t(sigtable_decl_p): Likewise.\n\t(walk_globals_pred): New typedef.\n\t(walk_globals_fn): Likewise.\n\t(walk_globals): New prototype.\n\t(walk_namespaces_fn): New typedef.\n\t(walk_namespaces): New prototype.\n\t(wrapup_globals_for_namespace): Likewise.\n\t(walk_vtables): Remove prototype.\n\t(walk_sigtables): Likewise.\n\t(instantiate_pending_templates): New prototype.\n\t* class.c (finish_struct_1): Don't return a value.\n\t* decl.h (pending_statics): Remove declaration.\n\t* decl.c (walk_namespaces_r): New function.\n\t(walk_globals_r): Likewise.\n\t(vtable_decl_p): Likewise.\n\t(vtype_decl_p): Likewise.\n\t(sigtable_decl_p): Likewise.\n\t(walk_namespaces): Likewise.\n\t(walk_globals_data): New type.\n\t(walk_globals): New function.\n\t(wrapup_globals_for_namespace): Likewise.\n\t(expand_static_init): Remove assertion.  Remove redundancy in\n\tconditional.  Don't put static data members in static_aggregates\n\tTidy.\n\t(finish_function): Remove redundancy in conditional.  Don't set\n\tDECL_RETURNS_FIRST_ARG.\n\t(cat_namespace_levels): Remove.\n\t* decl2.c: Include splay-tree.h and varray.h.\n\t(priority_info_s): New structure.\n\t(finish_vtable_vardecl): Change prototype.  Adjust for new calling\n\tconventions.\n\t(prune_vtable_vardecl): Likewise.\n\t(finish_sigtable_vardecl): Likewise.\n\t(setup_initp): Remove.\n\t(do_dtors): Remove.\n\t(do_ctors): Remove.\n\t(start_static_storage_duration_function): New function.\n\t(generate_inits_for_priority): Likewise.\n\t(finish_static_storage_duration_function): Likewise.\n\t(get_priority_info): Likewise.\n\t(do_static_initialization): Likewise.\n\t(do_static_destruction): Likewise.\n\t(do_static_initialization_and_destruction): Likewise.\n\t(generate_ctor_or_dtor_function): Likewise.\n\t(generate_ctor_and_dtor_functions_for_priority): Likewise.\n\t(pending_statics): Make it a varray.\n\t(pending_statics_used): New variable.\n\t(saved_inlines): Make it a varray.\n\t(saved_inlines_used): New variable.\n\t(finish_static_data_member): Change method of updating\n\tpending_statics.\n\t(mark_inline_for_output): Remove #if 0'd code.  Change method of\n\tupdating saved_inlines.\n\t(walk_vtables): Remove.\n\t(walk_sigtables): Likewise.\n\t(import_export_decl): Use DECL_TINFO_FN_P.\n\t(pending_templates): Remove declaration.\n\t(maybe_templates): Likewise.\n\t(static_aggregates_initp): Likewise.\n\t(setup_initp): Likewise.\n\t(finish_objects): Simplify.\n\t(INITIALIZE_P_IDENTIFIER): New macro.\n\t(PRIORITY_IDENTIFIER): New macro.\n\t(SSDF_IDENTIFIER): New macro.\n\t(initialize_p_decl): New variable.\n\t(priority_decl): Likewise.\n\t(ssdf_decl): Likewise.\n\t(priority_info_map): Likewise.\n\t(finish_file): Recode output of static intializers and other\n\tfile-scope finalization tasks.\n\t* error.c (OB_END_TEMPLATE_ID): New macro.\n\t(dump_type_real): Use it.\n\t(dump_decl): Likewise.\n\t(dump_function_name): Likewise.\n\t* lex.c (set_typedecl_interface_info): Adjust for new walk_globals\n\tinterface.\n\t(check_newline): Use walk_globals, not walk_vtables.\n\t* pt.c (pending_tempalte_expansions): Remove.\n\t(set_vardecl_interface_info): Likewise.\n\t(pending_templates): Make static.\n\t(maybe_templates): Likewise.\n\t(instantiate_class_template): Adjust call to finish_struct_1.\n\t(instantiate_pending_templates): New function.\n\t* rtti.c (get_tinfo_fn): Use SET_DECL_TINFO_FN_P.\n\t* tree.c (static_aggregates_initp): Remove.\n\t(cp_valid_lang_attribute): Don't use it; use DECL_INIT_PRIORITY\n\tinstead.\n\t* Makefile.in (decl2.o): Depend on varray.h and splay-tree.h.\n\nFrom-SVN: r26594", "tree": {"sha": "e4a00a2291e86f7c0c50315f152fd043cb14bdad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4a00a2291e86f7c0c50315f152fd043cb14bdad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/comments", "author": null, "committer": null, "parents": [{"sha": "32291f940ea10975e1555e2c0ae8189e34979482", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32291f940ea10975e1555e2c0ae8189e34979482", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32291f940ea10975e1555e2c0ae8189e34979482"}], "stats": {"total": 1976, "additions": 1261, "deletions": 715}, "files": [{"sha": "c517e678bf69e8eaa8047f7f456800adb368d0d9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0aafb128c06a4cbc4a6940c98fbfa4b4975398fd", "patch": "@@ -1,5 +1,105 @@\n 1999-04-22  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (lang_decl_flags): Remove returns_first_arg and\n+\tpreserves_first_arg.  Enlarge dummy accordingly.\n+\t(DECL_TINFO_FN_P): New macro.\n+\t(SET_DECL_TINO_FN_P): Likeiwse.\n+\t(DECL_RETURNS_FIRST_ARG): Remove.\n+\t(DECL_PRESERVES_THIS): Likewise.\n+\t(DECL_INIT_PRIORITY): New macro.\n+\t(finish_struct_1): Change prototype.\n+\t(cat_namespace_levels): Remove prototype.\n+\t(vtable_decl_p): New prototype.\n+\t(vtype_decl_p): Likewise.\n+\t(sigtable_decl_p): Likewise.\n+\t(walk_globals_pred): New typedef.\n+\t(walk_globals_fn): Likewise.\n+\t(walk_globals): New prototype.\n+\t(walk_namespaces_fn): New typedef.\n+\t(walk_namespaces): New prototype.\n+\t(wrapup_globals_for_namespace): Likewise.\n+\t(walk_vtables): Remove prototype.\n+\t(walk_sigtables): Likewise.\n+\t(instantiate_pending_templates): New prototype.\n+\t* class.c (finish_struct_1): Don't return a value.\n+\t* decl.h (pending_statics): Remove declaration.\n+\t* decl.c (walk_namespaces_r): New function.\n+\t(walk_globals_r): Likewise.\n+\t(vtable_decl_p): Likewise.\n+\t(vtype_decl_p): Likewise.\n+\t(sigtable_decl_p): Likewise.\n+\t(walk_namespaces): Likewise.\n+\t(walk_globals_data): New type.\n+\t(walk_globals): New function.\n+\t(wrapup_globals_for_namespace): Likewise.\n+\t(expand_static_init): Remove assertion.  Remove redundancy in\n+\tconditional.  Don't put static data members in static_aggregates\n+\tTidy.\n+\t(finish_function): Remove redundancy in conditional.  Don't set\n+\tDECL_RETURNS_FIRST_ARG.\n+\t(cat_namespace_levels): Remove.\n+\t* decl2.c: Include splay-tree.h and varray.h.\n+\t(priority_info_s): New structure.\n+\t(finish_vtable_vardecl): Change prototype.  Adjust for new calling\n+\tconventions.\n+\t(prune_vtable_vardecl): Likewise.\n+\t(finish_sigtable_vardecl): Likewise.\n+\t(setup_initp): Remove.\n+\t(do_dtors): Remove.\n+\t(do_ctors): Remove.\n+\t(start_static_storage_duration_function): New function.\n+\t(generate_inits_for_priority): Likewise.\n+\t(finish_static_storage_duration_function): Likewise.\n+\t(get_priority_info): Likewise.\n+\t(do_static_initialization): Likewise.\n+\t(do_static_destruction): Likewise.\n+\t(do_static_initialization_and_destruction): Likewise.\n+\t(generate_ctor_or_dtor_function): Likewise.\n+\t(generate_ctor_and_dtor_functions_for_priority): Likewise.\n+\t(pending_statics): Make it a varray.\n+\t(pending_statics_used): New variable.\n+\t(saved_inlines): Make it a varray.\n+\t(saved_inlines_used): New variable.\n+\t(finish_static_data_member): Change method of updating\n+\tpending_statics. \n+\t(mark_inline_for_output): Remove #if 0'd code.  Change method of\n+\tupdating saved_inlines.\n+\t(walk_vtables): Remove.\n+\t(walk_sigtables): Likewise.\n+\t(import_export_decl): Use DECL_TINFO_FN_P.\n+\t(pending_templates): Remove declaration.\n+\t(maybe_templates): Likewise.\n+\t(static_aggregates_initp): Likewise.\n+\t(setup_initp): Likewise.\n+\t(finish_objects): Simplify.\n+\t(INITIALIZE_P_IDENTIFIER): New macro.\n+\t(PRIORITY_IDENTIFIER): New macro.\n+\t(SSDF_IDENTIFIER): New macro.\n+\t(initialize_p_decl): New variable.\n+\t(priority_decl): Likewise.\n+\t(ssdf_decl): Likewise.\n+\t(priority_info_map): Likewise.\n+\t(finish_file): Recode output of static intializers and other\n+\tfile-scope finalization tasks.\n+\t* error.c (OB_END_TEMPLATE_ID): New macro.\n+\t(dump_type_real): Use it.\n+\t(dump_decl): Likewise.\n+\t(dump_function_name): Likewise.\n+\t* lex.c (set_typedecl_interface_info): Adjust for new walk_globals\n+\tinterface.\n+\t(check_newline): Use walk_globals, not walk_vtables.\n+\t* pt.c (pending_tempalte_expansions): Remove.\n+\t(set_vardecl_interface_info): Likewise.\n+\t(pending_templates): Make static.\n+\t(maybe_templates): Likewise.\n+\t(instantiate_class_template): Adjust call to finish_struct_1.\n+\t(instantiate_pending_templates): New function.\n+\t* rtti.c (get_tinfo_fn): Use SET_DECL_TINFO_FN_P.\n+\t* tree.c (static_aggregates_initp): Remove.\n+\t(cp_valid_lang_attribute): Don't use it; use DECL_INIT_PRIORITY\n+\tinstead.\n+\t* Makefile.in (decl2.o): Depend on varray.h and splay-tree.h.\n+\n \t* gxx.gperf (RETURN): Rename to RETURN_KEYWORD to avoid clashes\n \twith the RTL code RETURN.\n \t* hash.h: Regenerated."}, {"sha": "616525c29cf207b78f5c3d2c072e459be41a2175", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=0aafb128c06a4cbc4a6940c98fbfa4b4975398fd", "patch": "@@ -261,7 +261,8 @@ decl.o : decl.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n decl2.o : decl2.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   lex.h decl.h $(EXPR_H) $(srcdir)/../except.h \\\n   $(srcdir)/../output.h $(srcdir)/../except.h $(srcdir)/../system.h \\\n-  $(srcdir)/../toplev.h $(srcdir)/../dwarf2out.h $(srcdir)/../dwarfout.h\n+  $(srcdir)/../toplev.h $(srcdir)/../dwarf2out.h $(srcdir)/../dwarfout.h \\\n+  $(srcdir)/../../include/splay-tree.h $(srcdir)/../varray.h\n typeck2.o : typeck2.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   $(srcdir)/../system.h $(srcdir)/../toplev.h\n typeck.o : typeck.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\"}, {"sha": "9a20b5b093fa7bd6323bb7d5ed85a5195b83bf23", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=0aafb128c06a4cbc4a6940c98fbfa4b4975398fd", "patch": "@@ -3099,7 +3099,7 @@ add_implicitly_declared_members (t, cant_have_default_ctor,\n \n    ATTRIBUTES is the set of decl attributes to be applied, if any.  */\n \n-tree\n+void\n finish_struct_1 (t, warn_anon)\n      tree t;\n      int warn_anon;\n@@ -3144,7 +3144,7 @@ finish_struct_1 (t, warn_anon)\n       else\n \tmy_friendly_abort (172);\n       popclass ();\n-      return t;\n+      return;\n     }\n \n   GNU_xref_decl (current_function_decl, t);\n@@ -4116,7 +4116,7 @@ finish_struct_1 (t, warn_anon)\n   /* Finish debugging output for this type.  */\n   rest_of_type_compilation (t, toplevel_bindings_p ());\n \n-  return t;\n+  return;\n }\n \n /* When T was built up, the member declarations were added in reverse\n@@ -4210,7 +4210,7 @@ finish_struct (t, attributes, warn_anon)\n       TYPE_SIZE (t) = integer_zero_node;\n     }      \n   else\n-    t = finish_struct_1 (t, warn_anon);\n+    finish_struct_1 (t, warn_anon);\n \n   TYPE_BEING_DEFINED (t) = 0;\n "}, {"sha": "9dccb4d9331b35e90c654525d700f1288110b1ea", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0aafb128c06a4cbc4a6940c98fbfa4b4975398fd", "patch": "@@ -88,6 +88,9 @@ Boston, MA 02111-1307, USA.  */\n      For a TYPENAME_TYPE, this is TYPENAME_TYPE_FULLNAME.\n      For a TEMPLATE_TEMPLATE_PARM, this is\n      TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO.\n+\n+   DECL_SAVED_INSNS/DECL_FIELD_SIZE\n+     For a static VAR_DECL, this is DECL_INIT_PRIORITY.\n */\n \n /* Language-dependent contents of an identifier.  */\n@@ -1149,8 +1152,6 @@ struct lang_decl_flags\n \n   unsigned operator_attr : 1;\n   unsigned constructor_attr : 1;\n-  unsigned returns_first_arg : 1;\n-  unsigned preserves_first_arg : 1;\n   unsigned friend_attr : 1;\n   unsigned static_function : 1;\n   unsigned const_memfunc : 1;\n@@ -1171,7 +1172,7 @@ struct lang_decl_flags\n   unsigned needs_final_overrider : 1;\n   unsigned bitfield : 1;\n   unsigned defined_in_class : 1;\n-  unsigned dummy : 1;\n+  unsigned dummy : 3;\n \n   tree access;\n   tree context;\n@@ -1221,20 +1222,20 @@ struct lang_decl\n    for an object with virtual baseclasses.  */\n #define DECL_CONSTRUCTOR_FOR_VBASE_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.constructor_for_vbase_attr)\n \n+/* Non-zero for a FUNCTION_DECL that declares a type-info function.  */\n+#define DECL_TINFO_FN_P(NODE) \t\t\t\t\t\\\n+  (TREE_CODE (NODE) == FUNCTION_DECL\t\t\t\t\\\n+   && DECL_ARTIFICIAL (NODE)\t\t\t\t\t\\\n+   && DECL_LANG_SPECIFIC(NODE)->decl_flags.mutable_flag)\n+\n+/* Mark NODE as a type-info function.  */\n+#define SET_DECL_TINFO_FN_P(NODE) \\\n+  (DECL_LANG_SPECIFIC((NODE))->decl_flags.mutable_flag = 1)\n+\n /* For FUNCTION_DECLs: nonzero means that this function is a default\n    implementation of a signature method.  */\n #define IS_DEFAULT_IMPLEMENTATION(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.is_default_implementation)\n \n-/* For FUNCTION_DECLs: nonzero means that the constructor\n-   is known to return a non-zero `this' unchanged.  */\n-#define DECL_RETURNS_FIRST_ARG(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.returns_first_arg)\n-\n-/* Nonzero for FUNCTION_DECL means that this constructor is known to\n-   not make any assignment to `this', and therefore can be trusted\n-   to return it unchanged.  Otherwise, we must re-assign `current_class_ptr'\n-   after performing base initializations.  */\n-#define DECL_PRESERVES_THIS(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.preserves_first_arg)\n-\n /* Nonzero for _DECL means that this decl appears in (or will appear\n    in) as a member in a RECORD_TYPE or UNION_TYPE node.  It is also for\n    detecting circularity in case members are multiply defined.  In the\n@@ -1352,6 +1353,11 @@ struct lang_decl\n #define ORIGINAL_NAMESPACE(NODE)  \\\n   (DECL_NAMESPACE_ALIAS (NODE) ? DECL_NAMESPACE_ALIAS (NODE) : (NODE))\n \n+/* In a non-local VAR_DECL with static storage duration, this is the\n+   initialization priority.  If this value is zero, the NODE will be\n+   initialized at the DEFAULT_INIT_PRIORITY.  */\n+#define DECL_INIT_PRIORITY(NODE) (DECL_FIELD_SIZE ((NODE)))\n+\n /* In a TREE_LIST concatenating using directives, indicate indirekt\n    directives  */\n #define TREE_INDIRECT_USING(NODE) ((NODE)->common.lang_flag_0)\n@@ -2715,7 +2721,7 @@ extern int currently_open_class\t\t\tPROTO((tree));\n extern tree get_vfield_offset\t\t\tPROTO((tree));\n extern void duplicate_tag_error\t\t\tPROTO((tree));\n extern tree finish_struct\t\t\tPROTO((tree, tree, int));\n-extern tree finish_struct_1\t\t\tPROTO((tree, int));\n+extern void finish_struct_1\t\t\tPROTO((tree, int));\n extern int resolves_to_fixed_type_p\t\tPROTO((tree, int *));\n extern void init_class_processing\t\tPROTO((void));\n extern int is_empty_class\t\t\tPROTO((tree));\n@@ -2873,7 +2879,6 @@ extern int in_function_p\t\t\tPROTO((void));\n extern void replace_defarg\t\t\tPROTO((tree, tree));\n extern void print_other_binding_stack\t\tPROTO((struct binding_level *));\n extern void revert_static_member_fn             PROTO((tree*, tree*, tree*));\n-extern void cat_namespace_levels                PROTO((void));\n extern void fixup_anonymous_union               PROTO((tree));\n extern int check_static_variable_definition     PROTO((tree, tree));\n extern void push_local_binding                  PROTO((tree, tree, int));\n@@ -2882,6 +2887,18 @@ extern tree check_default_argument              PROTO((tree, tree));\n extern tree push_overloaded_decl\t\tPROTO((tree, int));\n extern void clear_identifier_class_values       PROTO((void));\n extern void storetags                           PROTO((tree));\n+extern int vtable_decl_p                        PROTO((tree, void *));\n+extern int vtype_decl_p                         PROTO((tree, void *));\n+extern int sigtable_decl_p                      PROTO((tree, void *));\n+typedef int (*walk_globals_pred)                PROTO((tree, void *));\n+typedef int (*walk_globals_fn)                  PROTO((tree *, void *));\n+extern int walk_globals                         PROTO((walk_globals_pred,\n+\t\t\t\t\t\t       walk_globals_fn,\n+\t\t\t\t\t\t       void *));\n+typedef int (*walk_namespaces_fn)               PROTO((tree, void *));\n+extern int walk_namespaces                      PROTO((walk_namespaces_fn,\n+\t\t\t\t\t\t       void *));\n+extern int wrapup_globals_for_namespace         PROTO((tree, void *));\n \n /* in decl2.c */\n extern int check_java_method\t\t\tPROTO((tree));\n@@ -2919,10 +2936,6 @@ extern tree coerce_delete_type\t\t\tPROTO((tree));\n extern void comdat_linkage\t\t\tPROTO((tree));\n extern void import_export_class\t\t\tPROTO((tree));\n extern void import_export_vtable\t\tPROTO((tree, tree, int));\n-extern int walk_vtables\t\t\t\tPROTO((void (*)(tree, tree),\n-\t\t\t\t\t\t       int (*)(tree, tree)));\n-extern void walk_sigtables\t\t\tPROTO((void (*)(tree, tree),\n-\t\t\t\t\t\t       void (*)(tree, tree)));\n extern void import_export_decl\t\t\tPROTO((tree));\n extern tree build_cleanup\t\t\tPROTO((tree));\n extern void finish_file\t\t\t\tPROTO((void));\n@@ -3158,6 +3171,7 @@ extern void maybe_process_partial_specialization PROTO((tree));\n extern void maybe_check_template_type           PROTO((tree));\n extern tree most_specialized_instantiation      PROTO((tree, tree));\n extern void print_candidates                    PROTO((tree));\n+extern int instantiate_pending_templates        PROTO((void));\n \n extern int processing_specialization;\n extern int processing_explicit_instantiation;"}, {"sha": "5457e9216c31328799b7a301188374805ca8b924", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 182, "deletions": 50, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0aafb128c06a4cbc4a6940c98fbfa4b4975398fd", "patch": "@@ -192,6 +192,8 @@ static void find_class_binding_level PROTO((void));\n static struct binding_level *innermost_nonclass_level PROTO((void));\n static tree poplevel_class PROTO((void));\n static void warn_about_implicit_typename_lookup PROTO((tree, tree));\n+static int walk_namespaces_r PROTO((tree, walk_namespaces_fn, void *));\n+static int walk_globals_r PROTO((tree, void *));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PROTO((void));\n@@ -1833,6 +1835,179 @@ clear_identifier_class_values ()\n     IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (t)) = NULL_TREE;\n }\n \n+/* Returns non-zero if T is a virtual function table.  */\n+\n+int\n+vtable_decl_p (t, data)\n+     tree t;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  return (TREE_CODE (t) == VAR_DECL && DECL_VIRTUAL_P (t));\n+}\n+\n+/* Returns non-zero if T is a TYPE_DECL for a type with virtual\n+   functions.  */\n+\n+int\n+vtype_decl_p (t, data)\n+     tree t;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  return (TREE_CODE (t) == TYPE_DECL\n+\t  && TREE_TYPE (t) != error_mark_node\n+\t  && TYPE_LANG_SPECIFIC (TREE_TYPE (t))\n+\t  && CLASSTYPE_VSIZE (TREE_TYPE (t)));\n+}\n+\n+/* Returns non-zero if T is a signature table.  */\n+\n+int \n+sigtable_decl_p (t, data)\n+     tree t;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  return (TREE_CODE (t) == VAR_DECL\n+\t  && TREE_TYPE (t) != error_mark_node\n+\t  && IS_SIGNATURE (TREE_TYPE (t)));\n+}\n+\n+/* Walk all the namespaces contained NAMESPACE, including NAMESPACE\n+   itself, calling F for each.  The DATA is passed to F as well.  */\n+\n+static int\n+walk_namespaces_r (namespace, f, data)\n+     tree namespace;\n+     walk_namespaces_fn f;\n+     void *data;\n+{\n+  tree current;\n+  int result = 0;\n+\n+  result |= (*f) (namespace, data);\n+\n+  for (current = NAMESPACE_LEVEL (namespace)->names;\n+       current;\n+       current = TREE_CHAIN (current))\n+    {\n+      if (TREE_CODE (current) != NAMESPACE_DECL\n+\t  || DECL_NAMESPACE_ALIAS (current))\n+\tcontinue;\n+      if (!DECL_LANG_SPECIFIC (current))\n+\t{\n+\t  /* Hmm. std. */\n+\t  my_friendly_assert (current == std_node, 393);\n+\t  continue;\n+\t}\n+\n+      /* We found a namespace.  */\n+      result |= walk_namespaces_r (current, f, data);\n+    }\n+\n+  return result;\n+}\n+\n+/* Walk all the namespaces, calling F for each.  The DATA is passed to\n+   F as well.  */\n+\n+int\n+walk_namespaces (f, data)\n+     walk_namespaces_fn f;\n+     void *data;\n+{\n+  return walk_namespaces_r (global_namespace, f, data);\n+}\n+\n+struct walk_globals_data {\n+  walk_globals_pred p;\n+  walk_globals_fn f;\n+  void *data;\n+};\n+\n+/* Walk the global declarations in NAMESPACE.  Whenever one is found\n+   for which P returns non-zero, call F with its address.  If any call\n+   to F returns a non-zero value, return a non-zero value.  */\n+\n+static int \n+walk_globals_r (namespace, data)\n+     tree namespace;\n+     void *data;\n+{\n+  struct walk_globals_data* wgd = (struct walk_globals_data *) data;\n+  walk_globals_pred p = wgd->p;\n+  walk_globals_fn f = wgd->f;\n+  void *d = wgd->data;\n+  tree *t;\n+  int result = 0;\n+\n+  t = &NAMESPACE_LEVEL (namespace)->names;\n+\n+  while (*t)\n+    {\n+      tree glbl = *t;\n+\n+      if ((*p) (glbl, d))\n+\tresult |= (*f) (t, d);\n+\n+      /* If F changed *T, then *T still points at the next item to\n+\t examine.  */\n+      if (*t == glbl)\n+\tt = &TREE_CHAIN (*t);\n+    }\n+\n+  return result;\n+}\n+\n+/* Walk the global declarations.  Whenever one is found for which P\n+   returns non-zero, call F with its address.  If any call to F\n+   returns a non-zero value, return a non-zero value.  */\n+\n+int\n+walk_globals (p, f, data)\n+     walk_globals_pred p;\n+     walk_globals_fn f;\n+     void *data;\n+{\n+  struct walk_globals_data wgd;\n+  wgd.p = p;\n+  wgd.f = f;\n+  wgd.data = data;\n+\n+  return walk_namespaces (walk_globals_r, &wgd);\n+}\n+\n+/* Call wrapup_globals_declarations for the globals in NAMESPACE.  If\n+   DATA is non-NULL, this is the last time we will call\n+   wrapup_global_declarations for this NAMESPACE.  */\n+\n+int\n+wrapup_globals_for_namespace (namespace, data)\n+     tree namespace;\n+     void *data;\n+{\n+  tree globals = NAMESPACE_LEVEL (namespace)->names;\n+  int len = list_length (globals);\n+  tree *vec = (tree *) alloca (sizeof (tree) * len);\n+  int i;\n+  tree decl;\n+  int last_time = (data != 0);\n+\n+  if (last_time && namespace == global_namespace)\n+    /* Let compile_file handle the global namespace.  */\n+    return 0;\n+\n+  /* Process the decls in reverse order--earliest first.\n+     Put them into VEC from back to front, then take out from front.  */\n+  \n+  for (i = 0, decl = globals; i < len; i++, decl = TREE_CHAIN (decl))\n+    vec[len - i - 1] = decl;\n+  \n+  if (!last_time)\n+    return wrapup_global_declarations (vec, len);\n+\n+  check_global_declarations (vec, len);\n+  return 0;\n+}\n+\n \f\n /* For debugging.  */\n static int no_print_functions = 0;\n@@ -2196,38 +2371,6 @@ pop_namespace ()\n   suspend_binding_level ();\n }\n \n-/* Concatenate the binding levels of all namespaces. */\n-\n-void\n-cat_namespace_levels()\n-{\n-  tree current;\n-  tree last;\n-  struct binding_level *b;\n-\n-  last = NAMESPACE_LEVEL (global_namespace) -> names;\n-  /* The nested namespaces appear in the names list of their ancestors. */\n-  for (current = last; current; current = TREE_CHAIN (current))\n-    {\n-      /* Catch simple infinite loops.  */\n-      if (TREE_CHAIN (current) == current)\n-\tmy_friendly_abort (990126);\n-\n-      if (TREE_CODE (current) != NAMESPACE_DECL\n-          || DECL_NAMESPACE_ALIAS (current))\n-\tcontinue;\n-      if (!DECL_LANG_SPECIFIC (current))\n-\t{\n-\t  /* Hmm. std. */\n-\t  my_friendly_assert (current == std_node, 393);\n-\t  continue;\n-\t}\n-      b = NAMESPACE_LEVEL (current);\n-      while (TREE_CHAIN (last))\n-\tlast = TREE_CHAIN (last);\n-      TREE_CHAIN (last) = NAMESPACE_LEVEL (current) -> names;\n-    }\n-}\n \f\n /* Subroutines for reverting temporarily to top-level for instantiation\n    of templates and such.  We actually need to clear out the class- and\n@@ -8259,15 +8402,12 @@ expand_static_init (decl, init)\n {\n   tree oldstatic = value_member (decl, static_aggregates);\n \n-  /* If at_eof is 2, we're too late.  */\n-  my_friendly_assert (at_eof <= 1, 990323);\n-\n   if (oldstatic)\n     {\n       if (TREE_PURPOSE (oldstatic) && init != NULL_TREE)\n \tcp_error (\"multiple initializations given for `%D'\", decl);\n     }\n-  else if (! toplevel_bindings_p () && ! pseudo_global_level_p ())\n+  else if (! toplevel_bindings_p ())\n     {\n       /* Emit code to perform this initialization but once.  */\n       tree temp;\n@@ -8369,22 +8509,16 @@ expand_static_init (decl, init)\n \t}\n \n       expand_end_cond ();\n-      if (TYPE_NEEDS_DESTRUCTOR (TREE_TYPE (decl)))\n-\t{\n-\t  static_aggregates = perm_tree_cons (temp, decl, static_aggregates);\n-\t  TREE_STATIC (static_aggregates) = 1;\n-\t}\n-\n       /* Resume old (possibly temporary) allocation.  */\n       pop_obstacks ();\n     }\n   else\n     {\n-      /* This code takes into account memory allocation\n-\t policy of `start_decl'.  Namely, if TYPE_NEEDS_CONSTRUCTING\n-\t does not hold for this object, then we must make permanent\n-\t the storage currently in the temporary obstack.  */\n-      if (! TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n+      /* This code takes into account memory allocation policy of\n+\t `start_decl'.  Namely, if TYPE_NEEDS_CONSTRUCTING does not\n+\t hold for this object, then we must make permanent the storage\n+\t currently in the temporary obstack.  */\n+      if (!TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n \tpreserve_initializer ();\n       static_aggregates = perm_tree_cons (init, decl, static_aggregates);\n     }\n@@ -13758,7 +13892,7 @@ finish_function (lineno, flags, nested)\n   if (fndecl == NULL_TREE)\n     return;\n \n-  if (! nested && function_depth > 1)\n+  if (function_depth > 1)\n     nested = 1;\n \n   fntype = TREE_TYPE (fndecl);\n@@ -14029,8 +14163,6 @@ finish_function (lineno, flags, nested)\n \t  tree abstract_virtuals = CLASSTYPE_ABSTRACT_VIRTUALS (current_class_type);\n \t  CLASSTYPE_ABSTRACT_VIRTUALS (current_class_type) = NULL_TREE;\n \n-\t  DECL_RETURNS_FIRST_ARG (fndecl) = 1;\n-\n \t  if (flag_this_is_variable > 0)\n \t    {\n \t      cond = build_binary_op (EQ_EXPR,"}, {"sha": "fcb247e702029d4a1c5c9e29863e0c7cfa38a747", "filename": "gcc/cp/decl.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Fdecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Fdecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.h?ref=0aafb128c06a4cbc4a6940c98fbfa4b4975398fd", "patch": "@@ -42,11 +42,6 @@ extern tree this_identifier, in_charge_identifier;\n    or a chain or parameter decls here.  */\n extern tree last_function_parms;\n \n-/* A list of static class variables.  This is needed, because a\n-   static class variable can be declared inside the class without\n-   an initializer, and then initialized, staticly, outside the class.  */\n-extern tree pending_statics;\n-\n /* A list of objects which have constructors or destructors\n    which reside in the global scope.  The decl is stored in\n    the TREE_VALUE slot and the initializer is stored"}, {"sha": "ea469f3ef109cd5f04291cf947df68fc5f58c6b9", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 701, "deletions": 603, "changes": 1304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0aafb128c06a4cbc4a6940c98fbfa4b4975398fd", "patch": "@@ -42,35 +42,54 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"dwarf2out.h\"\n #include \"dwarfout.h\"\n+#include \"splay-tree.h\"\n+#include \"varray.h\"\n \n #if USE_CPPLIB\n #include \"cpplib.h\"\n extern cpp_reader  parse_in;\n #endif\n \n+/* This structure contains information about the initializations\n+   and/or destructions required for a particular priority level.  */\n+typedef struct priority_info_s {\n+  /* A label indicating where we should generate the next\n+     initialization with this priority.  */\n+  rtx initialization_sequence;\n+  /* A label indicating where we should generate the next destruction\n+     with this priority.  */\n+  rtx destruction_sequence;\n+} *priority_info;\n+\n static tree get_sentry PROTO((tree));\n static void mark_vtable_entries PROTO((tree));\n static void grok_function_init PROTO((tree, tree));\n-static int finish_vtable_vardecl PROTO((tree, tree));\n-static int prune_vtable_vardecl PROTO((tree, tree));\n-static void finish_sigtable_vardecl PROTO((tree, tree));\n+static int finish_vtable_vardecl PROTO((tree *, void *));\n+static int prune_vtable_vardecl PROTO((tree *, void *));\n+static int finish_sigtable_vardecl PROTO((tree *, void *));\n static int is_namespace_ancestor PROTO((tree, tree));\n static void add_using_namespace PROTO((tree, tree, int));\n static tree ambiguous_decl PROTO((tree, tree, tree,int));\n static tree build_anon_union_vars PROTO((tree, tree*, int, int));\n static int acceptable_java_type PROTO((tree));\n static void output_vtable_inherit PROTO((tree));\n-static void setup_initp PROTO((void));\n static void start_objects PROTO((int, int));\n static void finish_objects PROTO((int, int));\n-static void do_dtors PROTO((tree));\n-static void do_ctors PROTO((tree));\n static tree merge_functions PROTO((tree, tree));\n static tree decl_namespace PROTO((tree));\n static tree validate_nonmember_using_decl PROTO((tree, tree *, tree *));\n static void do_nonmember_using_decl PROTO((tree, tree, tree, tree,\n \t\t\t\t\t   tree *, tree *));\n-\n+static void start_static_storage_duration_function PROTO((void));\n+static int generate_inits_for_priority PROTO((splay_tree_node, void *));\n+static void finish_static_storage_duration_function PROTO((void));\n+static priority_info get_priority_info PROTO((int));\n+static void do_static_initialization PROTO((tree, tree, tree, int));\n+static void do_static_destruction PROTO((tree, tree, int));\n+static void do_static_initialization_and_destruction PROTO((tree, tree));\n+static void generate_ctor_or_dtor_function PROTO((int, int));\n+static int generate_ctor_and_dtor_functions_for_priority\n+                                  PROTO((splay_tree_node, void *));\n extern int current_class_depth;\n \n /* A list of virtual function tables we must make sure to write out.  */\n@@ -79,11 +98,13 @@ tree pending_vtables;\n /* A list of static class variables.  This is needed, because a\n    static class variable can be declared inside the class without\n    an initializer, and then initialized, staticly, outside the class.  */\n-tree pending_statics;\n+static varray_type pending_statics;\n+static size_t pending_statics_used;\n \n /* A list of functions which were declared inline, but which we\n    may need to emit outline anyway.  */\n-static tree saved_inlines;\n+static varray_type saved_inlines;\n+static size_t saved_inlines_used;\n \n /* Used to help generate temporary names which are unique within\n    a function.  Reset to 0 by start_function.  */\n@@ -1487,8 +1508,17 @@ finish_static_data_member_decl (decl, init, asmspec_tree, need_pop, flags)\n \t= build_static_name (current_class_type, DECL_NAME (decl));\n     }\n   if (! processing_template_decl)\n-    pending_statics = perm_tree_cons (NULL_TREE, decl, pending_statics);\n-      \n+    {\n+      if (!pending_statics)\n+\tVARRAY_TREE_INIT (pending_statics, 32, \"pending_statics\");\n+\t\n+      if (pending_statics_used == pending_statics->num_elements)\n+\tVARRAY_GROW (pending_statics, \n+\t\t     2 * pending_statics->num_elements);\n+      VARRAY_TREE (pending_statics, pending_statics_used) = decl;\n+      ++pending_statics_used;\n+    }\n+\n   /* Static consts need not be initialized in the class definition.  */\n   if (init != NULL_TREE && TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n     {\n@@ -2010,28 +2040,14 @@ mark_inline_for_output (decl)\n     return;\n   my_friendly_assert (TREE_PERMANENT (decl), 363);\n   DECL_SAVED_INLINE (decl) = 1;\n-#if 0\n-  if (DECL_PENDING_INLINE_INFO (decl) != 0\n-      && ! DECL_PENDING_INLINE_INFO (decl)->deja_vu)\n-    {\n-      struct pending_inline *t = pending_inlines;\n-      my_friendly_assert (DECL_SAVED_INSNS (decl) == 0, 198);\n-      while (t)\n-\t{\n-\t  if (t == DECL_PENDING_INLINE_INFO (decl))\n-\t    break;\n-\t  t = t->next;\n-\t}\n-      if (t == 0)\n-\t{\n-\t  t = DECL_PENDING_INLINE_INFO (decl);\n-\t  t->next = pending_inlines;\n-\t  pending_inlines = t;\n-\t}\n-      DECL_PENDING_INLINE_INFO (decl) = 0;\n-    }\n-#endif\n-  saved_inlines = perm_tree_cons (NULL_TREE, decl, saved_inlines);\n+  if (!saved_inlines)\n+    VARRAY_TREE_INIT (saved_inlines, 32, \"saved_inlines\");\n+  \n+  if (saved_inlines_used == saved_inlines->num_elements)\n+    VARRAY_GROW (saved_inlines, \n+\t\t 2 * saved_inlines->num_elements);\n+  VARRAY_TREE (saved_inlines, saved_inlines_used) = decl;\n+  ++saved_inlines_used;\n }\n \n void\n@@ -2625,17 +2641,17 @@ output_vtable_inherit (vars)\n }\n \n static int\n-finish_vtable_vardecl (prev, vars)\n-     tree prev, vars;\n+finish_vtable_vardecl (t, data)\n+     tree *t;\n+     void *data ATTRIBUTE_UNUSED;\n {\n+  tree vars = *t;\n   tree ctype = DECL_CONTEXT (vars);\n   import_export_class (ctype);\n   import_export_vtable (vars, ctype, 1);\n \n   if (! DECL_EXTERNAL (vars)\n-      && (DECL_INTERFACE_KNOWN (vars)\n-\t  || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (vars))\n-\t  || (hack_decl_function_context (vars) && TREE_USED (vars)))\n+      && (DECL_INTERFACE_KNOWN (vars) || TREE_USED (vars))\n       && ! TREE_ASM_WRITTEN (vars))\n     {\n       /* Write it out.  */\n@@ -2680,98 +2696,35 @@ finish_vtable_vardecl (prev, vars)\n \n       return 1;\n     }\n-  else if (! TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (vars)))\n+  else if (! TREE_USED (vars))\n     /* We don't know what to do with this one yet.  */\n     return 0;\n \n-  /* We know that PREV must be non-zero here.  */\n-  TREE_CHAIN (prev) = TREE_CHAIN (vars);\n+  *t = TREE_CHAIN (vars);\n   return 0;\n }\n \n static int\n-prune_vtable_vardecl (prev, vars)\n-     tree prev, vars;\n+prune_vtable_vardecl (t, data)\n+     tree *t;\n+     void *data ATTRIBUTE_UNUSED;\n {\n-  /* We know that PREV must be non-zero here.  */\n-  TREE_CHAIN (prev) = TREE_CHAIN (vars);\n+  *t = TREE_CHAIN (*t);\n   return 1;\n }\n \n-int\n-walk_vtables (typedecl_fn, vardecl_fn)\n-     register void (*typedecl_fn) PROTO ((tree, tree));\n-     register int (*vardecl_fn) PROTO ((tree, tree));\n-{\n-  tree prev, vars;\n-  int flag = 0;\n-\n-  for (prev = 0, vars = getdecls (); vars; vars = TREE_CHAIN (vars))\n-    {\n-      register tree type = TREE_TYPE (vars);\n-\n-      if (TREE_CODE (vars) == VAR_DECL && DECL_VIRTUAL_P (vars))\n-\t{\n-\t  if (vardecl_fn)\n-\t    flag |= (*vardecl_fn) (prev, vars);\n-\n-\t  if (prev && TREE_CHAIN (prev) != vars)\n-\t    continue;\n-\t}\n-      else if (TREE_CODE (vars) == TYPE_DECL\n-\t       && type != error_mark_node\n-\t       && TYPE_LANG_SPECIFIC (type)\n-\t       && CLASSTYPE_VSIZE (type))\n-\t{\n-\t  if (typedecl_fn) (*typedecl_fn) (prev, vars);\n-\t}\n-\n-      prev = vars;\n-    }\n-\n-  return flag;\n-}\n-\n-static void\n-finish_sigtable_vardecl (prev, vars)\n-     tree prev, vars;\n+static int\n+finish_sigtable_vardecl (t, data)\n+     tree *t;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   /* We don't need to mark sigtable entries as addressable here as is done\n      for vtables.  Since sigtables, unlike vtables, are always written out,\n      that was already done in build_signature_table_constructor.  */\n \n-  rest_of_decl_compilation (vars, NULL_PTR, 1, 1);\n-\n-  /* We know that PREV must be non-zero here.  */\n-  TREE_CHAIN (prev) = TREE_CHAIN (vars);\n-}\n-\n-void\n-walk_sigtables (typedecl_fn, vardecl_fn)\n-     register void (*typedecl_fn) PROTO((tree, tree));\n-     register void (*vardecl_fn) PROTO((tree, tree));\n-{\n-  tree prev, vars;\n-\n-  for (prev = 0, vars = getdecls (); vars; vars = TREE_CHAIN (vars))\n-    {\n-      register tree type = TREE_TYPE (vars);\n-\n-      if (TREE_CODE (vars) == TYPE_DECL\n-\t  && type != error_mark_node\n-\t  && IS_SIGNATURE (type))\n-\t{\n-\t  if (typedecl_fn) (*typedecl_fn) (prev, vars);\n-\t}\n-      else if (TREE_CODE (vars) == VAR_DECL\n-\t       && TREE_TYPE (vars) != error_mark_node\n-\t       && IS_SIGNATURE (TREE_TYPE (vars)))\n-\t{\n-\t  if (vardecl_fn) (*vardecl_fn) (prev, vars);\n-\t}\n-      else\n-\tprev = vars;\n-    }\n+  rest_of_decl_compilation (*t, NULL_PTR, 1, 1);\n+  *t = TREE_CHAIN (*t);\n+  return 1;\n }\n \n /* Determines the proper settings of TREE_PUBLIC and DECL_EXTERNAL for an\n@@ -2824,8 +2777,7 @@ import_export_decl (decl)\n       else\n \tcomdat_linkage (decl);\n     }\n-  /* tinfo function */\n-  else if (DECL_ARTIFICIAL (decl) && DECL_MUTABLE_P (decl))\n+  else if (DECL_TINFO_FN_P (decl))\n     {\n       tree ctype = TREE_TYPE (DECL_NAME (decl));\n \n@@ -2882,8 +2834,6 @@ build_cleanup (decl)\n }\n \n extern int parse_time, varconst_time;\n-extern tree pending_templates;\n-extern tree maybe_templates;\n \n static tree\n get_sentry (base)\n@@ -2911,105 +2861,6 @@ get_sentry (base)\n   return sentry;\n }\n \n-/* A list of objects which have constructors or destructors\n-   which reside in the global scope.  The decl is stored in\n-   the TREE_VALUE slot and the initializer is stored\n-   in the TREE_PURPOSE slot.  */\n-extern tree static_aggregates_initp;\n-\n-/* Set up the static_aggregates* lists for processing.  Subroutine of\n-   finish_file.  Note that this function changes the format of\n-   static_aggregates_initp, from (priority . decl) to\n-   (priority . ((initializer . decl) ...)).  */\n-\n-static void\n-setup_initp ()\n-{\n-  tree t, *p, next_t;\n-  tree default_pri = build_int_2 (DEFAULT_INIT_PRIORITY, 0);\n-  int saw_default;\n-\n-  /* First, remove any entries from static_aggregates that are also in\n-     static_aggregates_initp, and update the entries in _initp to include\n-     the initializer.  For entries not in static_aggregates_initp, update\n-     them in place to look the same way.  */\n-  p = &static_aggregates;\n-  for (; *p; )\n-    {\n-      /* We check for symbol equivalence rather than identical decls\n-\t because decl_attributes is run before duplicate_decls.\n-\t XXX change to use DECL_MACHINE_ATTRIBUTES instead of\n-\t static_aggregates_initp.  */\n-      for (t = static_aggregates_initp; t; t = TREE_CHAIN (t))\n-\tif (DECL_ASSEMBLER_NAME (TREE_VALUE (t))\n-\t    == DECL_ASSEMBLER_NAME (TREE_VALUE (*p)))\n-\t  break;\n-\n-      if (t)\n-\t{\n-\t  /* We found an entry in s_a_initp; replace that entry with the\n-\t     format we want and remove the entry in s_a.  */\n-\t  TREE_VALUE (t) = *p;\n-\t  *p = TREE_CHAIN (*p);\n-\t  TREE_CHAIN (TREE_VALUE (t)) = NULL_TREE;\n-\t}\n-      else\n-\t{\n-\t  /* We didn't find an entry in s_a_i; replace the entry in s_a\n-\t     with the format we want.  */\n-\t  *p = perm_tree_cons (default_pri, *p, TREE_CHAIN (*p));\n-\t  TREE_CHAIN (TREE_VALUE (*p)) = NULL_TREE;\n-\t  p = &TREE_CHAIN (*p);\n-\t}\n-    }\n-\n-  /* And then attach the two lists.  By doing it this way, ctors with an\n-     explicit priority equal to the default are run before ctors with no\n-     explicit priority (i.e. the ones in s_a).  */\n-  static_aggregates_initp = chainon (static_aggregates,\n-\t\t\t\t     static_aggregates_initp);\n-  static_aggregates = NULL_TREE;\n-\n-  /* Then, group static_aggregates_initp.  After this step, there will only\n-     be one entry for each priority, with a chain coming off it.  */\n-  t = static_aggregates_initp;\n-  static_aggregates_initp = NULL_TREE;\n-\n-  saw_default = 0;\n-  for (; t; t = next_t)\n-    {\n-      next_t = TREE_CHAIN (t);\n-      if (TREE_INT_CST_LOW (TREE_PURPOSE (t)) == DEFAULT_INIT_PRIORITY)\n-\tsaw_default = 1;\n-\n-      for (p = &static_aggregates_initp; ; p = &TREE_CHAIN (*p))\n-\t{\n-\t  if (*p == NULL_TREE\n-\t      || tree_int_cst_lt (TREE_PURPOSE (*p), TREE_PURPOSE (t)))\n-\t    {\n-\t      TREE_CHAIN (t) = *p;\n-\t      *p = t;\n-\t      break;\n-\t    }\n-\t  else if (tree_int_cst_equal (TREE_PURPOSE (*p), TREE_PURPOSE (t)))\n-\t    {\n-\t      TREE_CHAIN (TREE_VALUE (t)) = TREE_VALUE (*p);\n-\t      TREE_VALUE (*p) = TREE_VALUE (t);\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  if (! saw_default)\n-    static_aggregates_initp = perm_tree_cons (default_pri, error_mark_node,\n-\t\t\t\t\t      static_aggregates_initp);\n-\n-  /* Reverse each list to preserve the order (currently reverse declaration\n-     order, for destructors).  */\n-  for (t = static_aggregates_initp; t; t = TREE_CHAIN (t))\n-    TREE_VALUE (t) = nreverse (TREE_VALUE (t));\n-}\n-\n /* Start the process of running a particular set of global constructors\n    or destructors.  Subroutine of do_[cd]tors.  */\n \n@@ -3064,23 +2915,7 @@ static void\n finish_objects (method_type, initp)\n      int method_type, initp;\n {\n-  char *fnname;\n-\n-  if (initp == DEFAULT_INIT_PRIORITY)\n-    {\n-      tree list = (method_type == 'I' ? static_ctors : static_dtors);\n-\n-      if (! current_function_decl && list)\n-\tstart_objects (method_type, initp);\n-\n-      for (; list; list = TREE_CHAIN (list))\n-\texpand_expr_stmt (build_function_call (TREE_VALUE (list), NULL_TREE));\n-    }\n-\n-  if (! current_function_decl)\n-    return;\n-\n-  fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n+  char *fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n \n   /* Finish up. */\n   expand_end_bindings (getdecls (), 1, 0);\n@@ -3115,456 +2950,719 @@ finish_objects (method_type, initp)\n #endif\n }\n \n-/* Generate a function to run a set of global destructors.  START is either\n-   NULL_TREE or a node indicating a set of destructors with the same\n-   init priority.  Subroutine of finish_file.  */\n+/* The names of the parameters to the function created to handle\n+   initializations and destructions for objects with static storage\n+   duration.  */\n+#define INITIALIZE_P_IDENTIFIER \"__initialize_p\"\n+#define PRIORITY_IDENTIFIER \"__priority\"\n+\n+/* The name of the function we create to handle initializations and\n+   destructions for objects with static storage duration.  */\n+#define SSDF_IDENTIFIER \"__static_initialization_and_destruction\"\n+\n+/* The declaration for the __INITIALIZE_P argument.  */\n+static tree initialize_p_decl;\n+\n+/* The declaration for the __PRIORITY argument.  */\n+static tree priority_decl;\n+\n+/* The declaration for the static storage duration function.  */\n+static tree ssdf_decl;\n+\n+/* A map from priority levels to information about that priority\n+   level.  There may be many such levels, so efficient lookup is\n+   important.  */\n+static splay_tree priority_info_map;\n+\n+/* Begins the generation of the function that will handle all\n+   initialization and destruction of objects with static storage\n+   duration.  The function generated takes two parameters of type\n+   `int': __INITIALIZE_P and __PRIORITY.  If __INITIALIZE_P is\n+   non-zero, it performs initializations.  Otherwise, it performs\n+   destructions.  It only performs those initializations or\n+   destructions with the indicated __PRIORITY.  The generated function\n+   returns no value.  \n+\n+   It is assumed that this function will only be called once per\n+   translation unit.  */\n \n static void\n-do_dtors (start)\n-     tree start;\n+start_static_storage_duration_function ()\n {\n-  tree vars;\n-  int initp;\n+  tree parm_types;\n+  tree type;\n+\n+  /* Create the parameters.  */\n+  parm_types = void_list_node;\n+  parm_types = perm_tree_cons (NULL_TREE, integer_type_node, parm_types);\n+  parm_types = perm_tree_cons (NULL_TREE, integer_type_node, parm_types);\n+  type = build_function_type (void_type_node, parm_types);\n+\n+  /* Create the FUNCTION_DECL itself.  */\n+  ssdf_decl = build_lang_decl (FUNCTION_DECL, \n+\t\t\t       get_identifier (SSDF_IDENTIFIER),\n+\t\t\t       type);\n+  TREE_PUBLIC (ssdf_decl) = 0;\n+  DECL_ARTIFICIAL (ssdf_decl) = 1;\n+  DECL_INLINE (ssdf_decl) = 1;\n+\n+  /* Create the argument list.  */\n+  initialize_p_decl = build_decl (PARM_DECL,\n+\t\t\t\t  get_identifier (INITIALIZE_P_IDENTIFIER),\n+\t\t\t\t  integer_type_node);\n+  DECL_CONTEXT (initialize_p_decl) = ssdf_decl;\n+  DECL_ARG_TYPE (initialize_p_decl) = integer_type_node;\n+  TREE_USED (initialize_p_decl) = 1;\n+  priority_decl = build_decl (PARM_DECL, get_identifier (PRIORITY_IDENTIFIER),\n+\t\t\t      integer_type_node);\n+  DECL_CONTEXT (priority_decl) = ssdf_decl;\n+  DECL_ARG_TYPE (priority_decl) = integer_type_node;\n+  TREE_USED (priority_decl) = 1;\n+\n+  TREE_CHAIN (initialize_p_decl) = priority_decl;\n+  DECL_ARGUMENTS (ssdf_decl) = initialize_p_decl;\n+\n+  /* Start the function itself.  This is equivalent to declarating the\n+     function as:\n+\n+       static inline void __ssdf (int __initialize_p, init __priority_p);\n+       \n+     It is static because we only need to call this function from the\n+     various constructor and destructor functions for this module.  */\n+  start_function (/*specs=*/NULL_TREE, \n+\t\t  ssdf_decl,\n+\t\t  /*attrs=*/NULL_TREE,\n+\t\t  /*pre_parsed_p=*/1);\n+\n+  /* Set up the scope of the outermost block in the function.  */\n+  store_parm_decls ();\n+  pushlevel (0);\n+  clear_last_expr ();\n+  push_momentary ();\n+  expand_start_bindings (0);\n \n-  initp = TREE_INT_CST_LOW (TREE_PURPOSE (start));\n-  vars = TREE_VALUE (start);\n+  /* Initialize the map from priority numbers to information about\n+     that priority level. */\n+  priority_info_map = splay_tree_new (splay_tree_compare_ints,\n+\t\t\t\t      /*delete_key_fn=*/0,\n+\t\t\t\t      /*delete_value_fn=*/\n+\t\t\t\t      (splay_tree_delete_value_fn) &free);\n+}\n \n-  for (; vars && vars != error_mark_node; vars = TREE_CHAIN (vars))\n+/* Generate the initialization code for the priority indicated in N.  */\n+\n+static int\n+generate_inits_for_priority (n, data)\n+     splay_tree_node n;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  int priority = (int) n->key;\n+  priority_info pi = (priority_info) n->value;\n+\n+  /* For each priority N which has been used generate code which looks\n+     like:\n+\n+       if (__priority == N) {\n+         if (__initialize_p)\n+\t   ...\n+\t else\n+\t   ...\n+       }\n+\n+     We use the sequences we've accumulated to fill in the `...'s.  */\n+  expand_start_cond (build_binary_op (EQ_EXPR,\n+\t\t\t\t      priority_decl,\n+\t\t\t\t      build_int_2 (priority, 0)),\n+\t\t     /*exit_flag=*/0);\n+\n+  /* Do the initializations.  */\n+  expand_start_cond (build_binary_op (NE_EXPR,\n+\t\t\t\t      initialize_p_decl,\n+\t\t\t\t      integer_zero_node),\n+\t\t     /*exit_flag=*/0);\n+  if (pi->initialization_sequence) \n     {\n-      tree decl = TREE_VALUE (vars);\n-      tree type = TREE_TYPE (decl);\n-      tree temp;\n+      rtx insns;\n \n-      if (TYPE_NEEDS_DESTRUCTOR (type) && ! TREE_STATIC (vars)\n-\t  && ! DECL_EXTERNAL (decl))\n-\t{\n-\t  int protect = (TREE_PUBLIC (decl) && (DECL_COMMON (decl)\n-\t\t\t\t\t\t|| DECL_ONE_ONLY (decl)\n-\t\t\t\t\t\t|| DECL_WEAK (decl)));\n-\n-\t  if (! current_function_decl)\n-\t    start_objects ('D', initp);\n-\n-\t  /* Set these global variables so that GDB at least puts\n-\t     us near the declaration which required the initialization.  */\n-\t  input_filename = DECL_SOURCE_FILE (decl);\n-\t  lineno = DECL_SOURCE_LINE (decl);\n-\t  emit_note (input_filename, lineno);\n-\t  \n-\t  /* Because of:\n+      push_to_sequence (pi->initialization_sequence);\n+      insns = gen_sequence ();\n+      end_sequence ();\n+\n+      emit_insn (insns);\n+    }\n \n-\t       [class.access.spec]\n+  /* Do the destructions.  */\n+  expand_start_else ();\n+  if (pi->destruction_sequence)\n+    {\n+      rtx insns;\n \n-\t       Access control for implicit calls to the constructors,\n-\t       the conversion functions, or the destructor called to\n-\t       create and destroy a static data member is performed as\n-\t       if these calls appeared in the scope of the member's\n-\t       class.  \n+      push_to_sequence (pi->destruction_sequence);\n+      insns = gen_sequence ();\n+      end_sequence ();\n \n-\t     we must convince enforce_access to let us access the\n-\t     DECL.  */\n-\t  if (member_p (decl))\n-\t    {\n-\t      DECL_CLASS_CONTEXT (current_function_decl)\n-\t\t= DECL_CONTEXT (decl);\n-\t      DECL_STATIC_FUNCTION_P (current_function_decl) = 1;\n-\t    }\n+      emit_insn (insns);\n+    }\n+  \n+  /* Close out the conditionals.  */\n+  expand_end_cond ();\n+  expand_end_cond ();\n \n-\t  temp = build_cleanup (decl);\n+  /* Don't stop iterating.  */\n+  return 0;\n+}\n \n-\t  if (protect)\n-\t    {\n-\t      tree sentry = get_sentry (DECL_ASSEMBLER_NAME (decl));\n-\t      sentry = build_unary_op (PREDECREMENT_EXPR, sentry, 0);\n-\t      sentry = build_binary_op (EQ_EXPR, sentry, integer_zero_node);\n-\t      expand_start_cond (sentry, 0);\n-\t    }\n+/* Finish the generation of the function which performs initialization\n+   and destruction of objects with static storage duration.  After\n+   this point, no more such objects can be created.  */\n \n-\t  expand_expr_stmt (temp);\n+static void\n+finish_static_storage_duration_function ()\n+{\n+  splay_tree_foreach (priority_info_map, \n+\t\t      generate_inits_for_priority,\n+\t\t      /*data=*/0);\n \n-\t  if (protect)\n-\t    expand_end_cond ();\n-\t  \n-\t  /* Now that we're done with DECL we don't need to pretend to\n-\t     be a member of its class any longer.  */\n-\t  DECL_CLASS_CONTEXT (current_function_decl) = NULL_TREE;\n-\t  DECL_STATIC_FUNCTION_P (current_function_decl) = 0;\n-\t}\n+  /* Close out the function.  */\n+  expand_end_bindings (getdecls (), 1, 0);\n+  poplevel (1, 0, 0);\n+  pop_momentary ();\n+  finish_function (lineno, 0, 0);\n+}\n+\n+/* Return the information about the indicated PRIORITY level.  If no\n+   code to handle this level has yet been generated, generate the\n+   appropriate prologue.  */\n+\n+static priority_info\n+get_priority_info (priority)\n+     int priority;\n+{\n+  priority_info pi;\n+  splay_tree_node n;\n+\n+  n = splay_tree_lookup (priority_info_map, \n+\t\t\t (splay_tree_key) priority);\n+  if (!n)\n+    {\n+      /* Create a new priority information structure, and insert it\n+\t into the map.  */\n+      pi = (priority_info) xmalloc (sizeof (struct priority_info_s));\n+      pi->initialization_sequence = NULL_RTX;\n+      pi->destruction_sequence = NULL_RTX;\n+      splay_tree_insert (priority_info_map,\n+\t\t\t (splay_tree_key) priority,\n+\t\t\t (splay_tree_value) pi);\n     }\n+  else\n+    pi = (priority_info) n->value;\n \n-  finish_objects ('D', initp);\n+  return pi;\n }\n \n-/* Generate a function to run a set of global constructors.  START is\n-   either NULL_TREE or a node indicating a set of constructors with the\n-   same init priority.  Subroutine of finish_file.  */\n+/* Generate code to do the static initialization of DECL.  The\n+   initialization is INIT.  If DECL may be initialized more than once\n+   in different object files, SENTRY is the guard variable to \n+   check.  PRIORITY is the priority for the initialization.  */\n \n static void\n-do_ctors (start)\n-     tree start;\n+do_static_initialization (decl, init, sentry, priority)\n+     tree decl;\n+     tree init;\n+     tree sentry;\n+     int priority;\n {\n-  tree vars;\n-  int initp;\n+  priority_info pi;\n \n-  initp = TREE_INT_CST_LOW (TREE_PURPOSE (start));\n-  vars = TREE_VALUE (start);\n+  /* Get the priority information for this PRIORITY,  */\n+  pi = get_priority_info (priority);\n+  if (!pi->initialization_sequence)\n+    start_sequence ();\n+  else\n+    push_to_sequence (pi->initialization_sequence);\n+\n+  /* Tell the debugger that we are at the location of the static\n+     variable in question.  */\n+  emit_note (input_filename, lineno);\n+\n+  /* If there's a SENTRY, we only do the initialization if it is\n+     zero, i.e., if we are the first to initialize it.  */\n+  if (sentry) \n+    expand_start_cond (build_binary_op (EQ_EXPR, \n+\t\t\t\t\tbuild_unary_op (PREINCREMENT_EXPR,\n+\t\t\t\t\t\t\tsentry,\n+\t\t\t\t\t\t\t/*noconvert=*/0),\n+\t\t\t\t\tinteger_one_node),\n+\t\t       /*exit_flag=*/0);\n+  \n+  /* Prepare a binding level for temporaries created during the\n+     initialization.  */\n+  expand_start_target_temps ();\n+\n+  if (IS_AGGR_TYPE (TREE_TYPE (decl))\n+      || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n+    expand_aggr_init (decl, init, 0);\n+  else if (TREE_CODE (init) == TREE_VEC)\n+    expand_expr (expand_vec_init (decl, TREE_VEC_ELT (init, 0),\n+\t\t\t\t  TREE_VEC_ELT (init, 1),\n+\t\t\t\t  TREE_VEC_ELT (init, 2), 0),\n+\t\t const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  else\n+    expand_assignment (decl, init, 0, 0);\n+  \n+  /* The expression might have involved increments and decrements.  */\n+  emit_queue ();\n \n-  /* Reverse the list so it's in the right order for ctors.  */\n-  vars = nreverse (vars);\n+  /* Cleanup any temporaries needed for the initial value.  */\n+  expand_end_target_temps ();\n \n-  for (; vars && vars != error_mark_node; vars = TREE_CHAIN (vars))\n-    {\n-      tree decl = TREE_VALUE (vars);\n-      tree init = TREE_PURPOSE (vars);\n-\n-      /* If this was a static attribute within some function's scope,\n-\t then don't initialize it here.  Also, don't bother\n-\t with initializers that contain errors.  */\n-      if (TREE_STATIC (vars)\n-\t  || DECL_EXTERNAL (decl)\n-\t  || (init && TREE_CODE (init) == TREE_LIST\n-\t      && value_member (error_mark_node, init)))\n-\tcontinue;\n+  /* Close the conditional opened above.  */\n+  if (sentry)\n+    expand_end_cond ();\n \n-      if (TREE_CODE (decl) == VAR_DECL)\n-\t{\n-\t  int protect = (TREE_PUBLIC (decl) && (DECL_COMMON (decl)\n-\t\t\t\t\t\t|| DECL_ONE_ONLY (decl)\n-\t\t\t\t\t\t|| DECL_WEAK (decl)));\n-\n-\t  if (! current_function_decl)\n-\t    start_objects ('I', initp);\n-\n-\t  /* Set these global variables so that GDB at least puts\n-\t     us near the declaration which required the initialization.  */\n-\t  input_filename = DECL_SOURCE_FILE (decl);\n-\t  lineno = DECL_SOURCE_LINE (decl);\n-\t  emit_note (input_filename, lineno);\n-\n-\t  /* 9.5p5: The initializer of a static member of a class has\n-\t     the same access rights as a member function.  */\n-\t  if (member_p (decl))\n-\t    {\n-\t      DECL_CLASS_CONTEXT (current_function_decl)\n-\t\t= DECL_CONTEXT (decl);\n-\t      DECL_STATIC_FUNCTION_P (current_function_decl) = 1;\n-\t    }\n+  /* Save the sequence for later use.  */\n+  pi->initialization_sequence = get_insns ();\n+  end_sequence ();\n+}\n \n-\t  if (protect)\n-\t    {\n-\t      tree sentry = get_sentry (DECL_ASSEMBLER_NAME (decl));\n-\t      sentry = build_unary_op (PREINCREMENT_EXPR, sentry, 0);\n-\t      sentry = build_binary_op\n-\t\t(EQ_EXPR, sentry, integer_one_node);\n-\t      expand_start_cond (sentry, 0);\n-\t    }\n+/* Generate code to do the static destruction of DECL.  If DECL may be\n+   initialized more than once in different object files, SENTRY is the\n+   guard variable to check.  PRIORITY is the priority for the\n+   destruction.  */\n \n-\t  expand_start_target_temps ();\n+static void\n+do_static_destruction (decl, sentry, priority)\n+     tree decl;\n+     tree sentry;\n+     int priority;\n+{\n+  rtx new_insns;\n+  priority_info pi;\n \n-\t  if (IS_AGGR_TYPE (TREE_TYPE (decl))\n-\t      || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n-\t    expand_aggr_init (decl, init, 0);\n-\t  else if (TREE_CODE (init) == TREE_VEC)\n-\t    {\n-\t      expand_expr (expand_vec_init (decl, TREE_VEC_ELT (init, 0),\n-\t\t\t\t\t    TREE_VEC_ELT (init, 1),\n-\t\t\t\t\t    TREE_VEC_ELT (init, 2), 0),\n-\t\t\t   const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t    }\n-\t  else\n-\t    expand_assignment (decl, init, 0, 0);\n-\t      \n-\t  /* The expression might have involved increments and\n-\t     decrements.  */\n-\t  emit_queue ();\n+  /* FIXME: We need destructions to be run in reverse order!  */\n \n-\t  /* Cleanup any temporaries needed for the initial value.  */\n-\t  expand_end_target_temps ();\n+  /* If we don't need a destructor, there's nothing to do.  */\n+  if (!TYPE_NEEDS_DESTRUCTOR (TREE_TYPE (decl)))\n+    return;\n+    \n+  /* Get the priority information for this PRIORITY,  */\n+  pi = get_priority_info (priority);\n+  if (!pi->destruction_sequence)\n+    start_sequence ();\n+  else\n+    push_to_sequence (pi->destruction_sequence);\n \n-\t  if (protect)\n-\t    expand_end_cond ();\n+  /* Start a new sequence to handle just this destruction.  */\n+  start_sequence ();\n \n-\t  DECL_CLASS_CONTEXT (current_function_decl) = NULL_TREE;\n-\t  DECL_STATIC_FUNCTION_P (current_function_decl) = 0;\n-\t}\n-      else if (decl == error_mark_node)\n-\t/* OK */;\n-      else\n-\tmy_friendly_abort (22);\n-    }\n+  /* Tell the debugger that we are at the location of the static\n+     variable in question.  */\n+  emit_note (input_filename, lineno);\n+  \n+  /* If there's a SENTRY, we only do the initialization if it is\n+     one, i.e., if we are the last to initialize it.  */\n+  if (sentry)\n+    expand_start_cond (build_binary_op (EQ_EXPR,\n+\t\t\t\t\tbuild_unary_op (PREDECREMENT_EXPR,\n+\t\t\t\t\t\t\tsentry,\n+\t\t\t\t\t\t\t/*nonconvert=*/1),\n+\t\t\t\t\tinteger_one_node),\n+\t\t       /*exit_flag=*/0);\n+  \n+  /* Actually to the destruction.  */\n+  expand_expr_stmt (build_cleanup (decl));\n+\n+  /* Close the conditional opened above.  */\n+  if (sentry)\n+    expand_end_cond ();\n+\n+  /* Insert the NEW_INSNS before the current insns.  (Destructions are\n+     run in reverse order of initializations.)  */\n+  new_insns = gen_sequence ();\n+  end_sequence ();\n+  if (pi->destruction_sequence)\n+    emit_insn_before (new_insns, pi->destruction_sequence);\n+  else\n+    emit_insn (new_insns);\n \n-  finish_objects ('I', initp);\n+  /* Save the sequence for later use.  */\n+  pi->destruction_sequence = get_insns ();\n+  end_sequence ();\n }\n \n-/* This routine is called from the last rule in yyparse ().\n-   Its job is to create all the code needed to initialize and\n-   destroy the global aggregates.  We do the destruction\n-   first, since that way we only need to reverse the decls once.  */\n+/* Add code to the static storage duration function that will handle\n+   DECL (a static variable that needs initializing and/or destruction)\n+   with the indicated PRIORITY.  If DECL needs initializing, INIT is\n+   the initializer.  */\n \n-void\n-finish_file ()\n+static void\n+do_static_initialization_and_destruction (decl, init)\n+     tree decl;\n+     tree init;\n {\n-  extern int lineno;\n-  int start_time, this_time;\n+  tree sentry = NULL_TREE;\n+  int priority;\n \n-  tree fnname;\n-  tree vars;\n-  int needs_cleaning = 0, needs_messing_up = 0;\n+  /* Deal gracefully with error.  */\n+  if (decl == error_mark_node)\n+    return;\n \n-  at_eof = 1;\n+  /* The only things that can be initialized are variables.  */\n+  my_friendly_assert (TREE_CODE (decl) == VAR_DECL, 19990420);\n \n-  /* Bad parse errors.  Just forget about it.  */\n-  if (! global_bindings_p () || current_class_type || decl_namespace_list)\n+  /* If this object is not defined, we don't need to do anything \n+     here.  */ \n+  if (DECL_EXTERNAL (decl))\n     return;\n \n-  start_time = get_run_time ();\n-\n-  /* Otherwise, GDB can get confused, because in only knows\n-     about source for LINENO-1 lines.  */\n-  lineno -= 1;\n+  /* Also, if the initializer already contains errors, we can bail out\n+     now.  */\n+  if (init && TREE_CODE (init) == TREE_LIST \n+      && value_member (error_mark_node, init))\n+    return;\n \n-  interface_unknown = 1;\n-  interface_only = 0;\n+  /* Trick the compiler into thinking we are at the file and line\n+     where DECL was declared so that error-messages make sense, and so\n+     that the debugger will show somewhat sensible file and line\n+     information.  */\n+  input_filename = DECL_SOURCE_FILE (decl);\n+  lineno = DECL_SOURCE_LINE (decl);\n \n-  for (fnname = pending_templates; fnname; fnname = TREE_CHAIN (fnname))\n-    {\n-      tree srcloc = TREE_PURPOSE (fnname);\n-      tree decl = TREE_VALUE (fnname);\n+  /* Because of:\n \n-      input_filename = SRCLOC_FILE (srcloc);\n-      lineno = SRCLOC_LINE (srcloc);\n+       [class.access.spec]\n \n-      if (TREE_CODE_CLASS (TREE_CODE (decl)) == 't')\n-\t{\n-\t  instantiate_class_template (decl);\n-\t  if (CLASSTYPE_TEMPLATE_INSTANTIATION (decl))\n-\t    for (vars = TYPE_METHODS (decl); vars; vars = TREE_CHAIN (vars))\n-\t      if (! DECL_ARTIFICIAL (vars))\n-\t\tinstantiate_decl (vars);\n-\t}\n-      else\n-\tinstantiate_decl (decl);\n-    }\n+       Access control for implicit calls to the constructors,\n+       the conversion functions, or the destructor called to\n+       create and destroy a static data member is performed as\n+       if these calls appeared in the scope of the member's\n+       class.  \n \n-  for (fnname = maybe_templates; fnname; fnname = TREE_CHAIN (fnname))\n+     we pretend we are in a static member function of the class of\n+     which the DECL is a member.  */\n+  if (member_p (decl))\n     {\n-      tree args, fn, decl = TREE_VALUE (fnname);\n-\n-      if (DECL_INITIAL (decl))\n-\tcontinue;\n-\n-      fn = TREE_PURPOSE (fnname);\n-      args = get_bindings (fn, decl, NULL_TREE);\n-      fn = instantiate_template (fn, args);\n-      instantiate_decl (fn);\n+      DECL_CLASS_CONTEXT (current_function_decl) = DECL_CONTEXT (decl);\n+      DECL_STATIC_FUNCTION_P (current_function_decl) = 1;\n     }\n+  \n+  /* We need a sentry if this is an object with external linkage that\n+     might be initialized in more than one place.  */\n+  if (TREE_PUBLIC (decl) && (DECL_COMMON (decl) \n+\t\t\t     || DECL_ONE_ONLY (decl)\n+\t\t\t     || DECL_WEAK (decl)))\n+    sentry = get_sentry (DECL_ASSEMBLER_NAME (decl));\n+\n+  /* Generate the code to actually do the intialization and\n+     destruction.  */\n+  priority = DECL_INIT_PRIORITY (decl);\n+  if (!priority)\n+    priority = DEFAULT_INIT_PRIORITY;\n+  do_static_initialization (decl, init, sentry, priority);\n+  do_static_destruction (decl, sentry, priority);\n+\n+  /* Now that we're done with DECL we don't need to pretend to be a\n+     member of its class any longer.  */\n+  DECL_CLASS_CONTEXT (current_function_decl) = NULL_TREE;\n+  DECL_STATIC_FUNCTION_P (current_function_decl) = 0;\n+}\n \n-  cat_namespace_levels();\n+/* Generate a static constructor (if CONSTRUCTOR_P) or destructor\n+   (otherwise) that will initialize all gobal objects with static\n+   storage duration having the indicated PRIORITY.  */\n \n-  /* Push into C language context, because that's all\n-     we'll need here.  */\n-  push_lang_context (lang_name_c);\n+static void\n+generate_ctor_or_dtor_function (constructor_p, priority)\n+     int constructor_p;\n+     int priority;\n+{\n+  char function_key;\n+  tree arguments;\n \n-#if 1\n-  /* The reason for pushing garbage onto the global_binding_level is to\n-     ensure that we can slice out _DECLs which pertain to virtual function\n-     tables.  If the last thing pushed onto the global_binding_level was a\n-     virtual function table, then slicing it out would slice away all the\n-     decls (i.e., we lose the head of the chain).\n-\n-     There are several ways of getting the same effect, from changing the\n-     way that iterators over the chain treat the elements that pertain to\n-     virtual function tables, moving the implementation of this code to\n-     decl.c (where we can manipulate global_binding_level directly),\n-     popping the garbage after pushing it and slicing away the vtable\n-     stuff, or just leaving it alone.  */\n-\n-  /* Make last thing in global scope not be a virtual function table.  */\n-#if 0 /* not yet, should get fixed properly later */\n-  vars = make_type_decl (get_identifier (\" @%$#@!\"), integer_type_node);\n-#else\n-  vars = build_decl (TYPE_DECL, get_identifier (\" @%$#@!\"), integer_type_node);\n-#endif\n-  DECL_IGNORED_P (vars) = 1;\n-  SET_DECL_ARTIFICIAL (vars);\n-  pushdecl (vars);\n-#endif\n+  /* We use `I' to indicate initialization and `D' to indicate\n+     destruction.  */\n+  if (constructor_p)\n+    function_key = 'I';\n+  else\n+    function_key = 'D';\n+\n+  /* Begin the function.  */\n+  start_objects (function_key, priority);\n+\n+  /* Call the static storage duration function with appropriate\n+     arguments.  */\n+  arguments = tree_cons (NULL_TREE, build_int_2 (priority, 0), \n+\t\t\t NULL_TREE);\n+  arguments = tree_cons (NULL_TREE, build_int_2 (constructor_p, 0),\n+\t\t\t arguments);\n+  expand_expr_stmt (build_function_call (ssdf_decl, arguments));\n+\n+  /* If we're generating code for the DEFAULT_INIT_PRIORITY, throw in\n+     calls to any functions marked with attributes indicating that\n+     they should be called at initialization- or destruction-time.  */\n+  if (priority == DEFAULT_INIT_PRIORITY)\n+    {\n+      tree fns;\n+      \n+      for (fns = constructor_p ? static_ctors : static_dtors; \n+\t   fns;\n+\t   fns = TREE_CHAIN (fns))\n+\texpand_expr_stmt (build_function_call (TREE_VALUE (fns), NULL_TREE));\n+    }\n \n-  for (vars = static_aggregates; vars; vars = TREE_CHAIN (vars))\n-    if (! TREE_ASM_WRITTEN (TREE_VALUE (vars)))\n-      rest_of_decl_compilation (TREE_VALUE (vars), 0, 1, 1);\n-  vars = static_aggregates;\n+  /* Close out the function.  */\n+  finish_objects (function_key, priority);\n+}\n \n-  if (static_ctors || vars)\n-    needs_messing_up = 1;\n-  if (static_dtors || vars)\n-    needs_cleaning = 1;\n+/* Generate constructor and destructor functions for the priority\n+   indicated by N.  DATA is really an `int*', and it set to `1' if we\n+   process the DEFAULT_INIT_PRIORITY.  */\n \n-  setup_initp ();\n+static int\n+generate_ctor_and_dtor_functions_for_priority (n, data)\n+     splay_tree_node n;\n+     void *data;\n+{\n+  int priority = (int) n->key;\n+  priority_info pi = (priority_info) n->value;\n+  int *did_default_priority_p = (int*) data;\n+\n+  if (priority == DEFAULT_INIT_PRIORITY)\n+    *did_default_priority_p = 1;\n+\n+  /* Generate the functions themselves, but only if they are really\n+     needed.  */\n+  if (pi->initialization_sequence\n+      || (priority == DEFAULT_INIT_PRIORITY && static_ctors))\n+    generate_ctor_or_dtor_function (/*constructor_p=*/1,\n+\t\t\t\t    priority);\n+  if (pi->destruction_sequence\n+      || (priority == DEFAULT_INIT_PRIORITY && static_dtors))\n+    generate_ctor_or_dtor_function (/*constructor_p=*/0,\n+\t\t\t\t    priority);\n+\n+  /* Keep iterating.  */\n+  return 0;\n+}\n \n-  /* After setup_initp, the aggregates are listed in reverse declaration\n-     order, for cleaning.  */\n-  if (needs_cleaning)\n-    for (vars = static_aggregates_initp; vars; vars = TREE_CHAIN (vars))\n-      do_dtors (vars);\n+/* This routine is called from the last rule in yyparse ().\n+   Its job is to create all the code needed to initialize and\n+   destroy the global aggregates.  We do the destruction\n+   first, since that way we only need to reverse the decls once.  */\n \n-  /* do_ctors will reverse the lists for messing up.  */\n-  if (needs_messing_up)\n-    for (vars = static_aggregates_initp; vars; vars = TREE_CHAIN (vars))\n-      do_ctors (vars);\n+void\n+finish_file ()\n+{\n+  extern int lineno;\n+  int start_time, this_time;\n+  int did_default_priority_p = 0;\n+  tree vars;\n+  int reconsider;\n+  size_t i;\n \n-  permanent_allocation (1);\n+  at_eof = 1;\n \n-  /* Done with C language context needs.  */\n-  pop_lang_context ();\n+  /* Bad parse errors.  Just forget about it.  */\n+  if (! global_bindings_p () || current_class_type || decl_namespace_list)\n+    return;\n \n-  /* Let expand_static_init know it's too late for more ctors.  */\n-  at_eof = 2;\n+  start_time = get_run_time ();\n \n-  /* Now write out any static class variables (which may have since\n-     learned how to be initialized).  */\n-  for (; pending_statics; pending_statics = TREE_CHAIN (pending_statics))\n-    {\n-      tree decl = TREE_VALUE (pending_statics);\n+  /* Otherwise, GDB can get confused, because in only knows\n+     about source for LINENO-1 lines.  */\n+  lineno -= 1;\n \n-      if (TREE_ASM_WRITTEN (decl))\n-\tcontinue;\n+  interface_unknown = 1;\n+  interface_only = 0;\n \n-      /* Output DWARF debug information.  */\n-#ifdef DWARF_DEBUGGING_INFO\n-      if (write_symbols == DWARF_DEBUG)\n-\tdwarfout_file_scope_decl (decl, 1);\n-#endif\n-#ifdef DWARF2_DEBUGGING_INFO\n-      if (write_symbols == DWARF2_DEBUG)\n-\tdwarf2out_decl (decl);\n-#endif\n+  /* We now have to write out all the stuff we put off writing out.\n+     These include:\n \n-      /* We currently handle template statics here.  We ought to handle\n-\t them the same way we do template functions, i.e. only emit them if\n-\t the symbol is needed.  */\n-      import_export_decl (decl);\n-      if (DECL_NOT_REALLY_EXTERN (decl) && ! DECL_IN_AGGR_P (decl))\n-\tDECL_EXTERNAL (decl) = 0;\n+       o Template specializations that we have not yet instantiated,\n+         but which are needed.\n+       o Initialization and destruction for non-local objects with\n+         static storage duration.  (Local objects with static storage\n+\t duration are initialized when their scope is first entered,\n+\t and are cleaned up via atexit.)\n+       o Virtual function tables.  \n \n-      rest_of_decl_compilation\n-\t(decl, IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)), 1, 1);\n-    }\n+     All of these may cause others to be needed.  For example,\n+     instantiating one function may cause another to be needed, and\n+     generating the intiailzer for an object may cause templates to be\n+     instantiated, etc., etc.  */\n \n   this_time = get_run_time ();\n   parse_time -= this_time - start_time;\n   varconst_time += this_time - start_time;\n-\n   start_time = get_run_time ();\n+  permanent_allocation (1);\n \n-  if (flag_handle_signatures)\n-    walk_sigtables ((void (*) PROTO ((tree, tree))) 0,\n-\t\t    finish_sigtable_vardecl);\n+  /* Create the function that will contain all initializations and\n+     destructions for objects with static storage duration.  We cannot\n+     conclude that because a symbol is not TREE_SYMBOL_REFERENCED the\n+     corresponding entity is not used until we call finish_function\n+     for the static storage duration function.  We give C linkage to\n+     static constructors and destructors.  */\n+  push_lang_context (lang_name_c);\n+  start_static_storage_duration_function ();\n+  push_to_top_level ();\n \n-  for (fnname = saved_inlines; fnname; fnname = TREE_CHAIN (fnname))\n+  do \n     {\n-      tree decl = TREE_VALUE (fnname);\n-      import_export_decl (decl);\n+      reconsider = 0;\n+\n+    /* If there are templates that we've put off instantiating, do\n+       them now.  */\n+      instantiate_pending_templates ();\n+\n+      /* Write out signature-tables and virtual tables as required.\n+       Note that writing out the virtual table for a template class\n+       may cause the instantiation of members of that class.  */\n+      if (flag_handle_signatures\n+\t  && walk_globals (sigtable_decl_p,\n+\t\t\t   finish_sigtable_vardecl,\n+\t\t\t   /*data=*/0))\n+\treconsider = 1;\n+      if (walk_globals (vtable_decl_p,\n+\t\t\tfinish_vtable_vardecl,\n+\t\t\t/*data=*/0))\n+\treconsider = 1;\n+      \n+      /* Come back to the static storage duration function; we're\n+\t about to emit instructions there for static initializations\n+\t and such.  */\n+      pop_from_top_level ();\n+      /* The list of objects with static storage duration is built up\n+\t in reverse order, so we reverse it here.  We also clear\n+\t STATIC_AGGREGATES so that any new aggregates added during the\n+\t initialization of these will be initialized in the correct\n+\t order when we next come around the loop.  */\n+      vars = nreverse (static_aggregates);\n+      static_aggregates = NULL_TREE;\n+      while (vars)\n+\t{\n+\t  if (! TREE_ASM_WRITTEN (TREE_VALUE (vars)))\n+\t    rest_of_decl_compilation (TREE_VALUE (vars), 0, 1, 1);\n+\t  do_static_initialization_and_destruction (TREE_VALUE (vars), \n+\t\t\t\t\t\t    TREE_PURPOSE (vars));\n+\t  reconsider = 1;\n+\t  vars = TREE_CHAIN (vars);\n+\t}\n+      push_to_top_level ();\n+      \n+      /* Go through the various inline functions, and see if any need\n+\t synthesizing.  */\n+      for (i = 0; i < saved_inlines_used; ++i)\n+\t{\n+\t  tree decl = VARRAY_TREE (saved_inlines, i);\n+\t  import_export_decl (decl);\n+\t  if (DECL_ARTIFICIAL (decl) && ! DECL_INITIAL (decl)\n+\t      && TREE_USED (decl)\n+\t      && (! DECL_REALLY_EXTERN (decl) || DECL_INLINE (decl)))\n+\t    {\n+\t      /* Even though we're already at the top-level, we push\n+\t\t there again.  That way, when we pop back a few lines\n+\t\t hence, all of our state is restored.  Otherwise,\n+\t\t finish_function doesn't clean things up, and we end\n+\t\t up with CURRENT_FUNCTION_DECL set.  */\n+\t      push_to_top_level ();\n+\t      if (DECL_TINFO_FN_P (decl))\n+\t\tsynthesize_tinfo_fn (decl);\n+\t      else\n+\t\tsynthesize_method (decl);\n+\t      pop_from_top_level ();\n+\t      reconsider = 1;\n+\t    }\n+\t}\n+    } \n+  while (reconsider);\n+\n+  /* Finish up the static storage duration function, now that we now\n+     there can be no more things in need of initialization or\n+     destruction.  */\n+  pop_from_top_level ();\n+  finish_static_storage_duration_function ();\n+\n+  /* Generate initialization and destruction functions for all\n+     priorities for which they are required.  */\n+  if (priority_info_map)\n+    splay_tree_foreach (priority_info_map, \n+\t\t\tgenerate_ctor_and_dtor_functions_for_priority,\n+\t\t\t&did_default_priority_p);\n+\n+  if (!did_default_priority_p) \n+    {\n+      /* Even if there were no explicit initializations or\n+\t destructions required, we may still have to handle the\n+\t default priority if there functions declared as constructors\n+\t or destructors via attributes.  */\n+      if (static_ctors)\n+\tgenerate_ctor_or_dtor_function (/*constructor_p=*/1, \n+\t\t\t\t\tDEFAULT_INIT_PRIORITY);\n+      if (static_dtors)\n+\tgenerate_ctor_or_dtor_function (/*constructor_p=*/0, \n+\t\t\t\t\tDEFAULT_INIT_PRIORITY);\n     }\n \n-  mark_all_runtime_matches ();\n-\n-  /* Now write out inline functions which had their addresses taken and\n-     which were not declared virtual and which were not declared `extern\n-     inline'.  */\n-  {\n-    int reconsider = 1;\t\t/* More may be referenced; check again */\n-\n-    while (reconsider)\n-      {\n-\ttree *p = &saved_inlines;\n-\treconsider = 0;\n-\n-\t/* We need to do this each time so that newly completed template\n-           types don't wind up at the front of the list.  Sigh.  */\n-\tvars = build_decl (TYPE_DECL, make_anon_name (), integer_type_node);\n-\tDECL_IGNORED_P (vars) = 1;\n-\tSET_DECL_ARTIFICIAL (vars);\n-\tpushdecl (vars);\n-\n-\treconsider |= walk_vtables ((void (*) PROTO((tree, tree))) 0, \n-\t\t\t\t    finish_vtable_vardecl);\n-\n-\twhile (*p)\n-\t  {\n-\t    tree decl = TREE_VALUE (*p);\n-\n-\t    if (DECL_ARTIFICIAL (decl) && ! DECL_INITIAL (decl)\n-\t\t&& TREE_USED (decl)\n-\t\t&& (! DECL_REALLY_EXTERN (decl) || DECL_INLINE (decl)))\n-\t      {\n-\t\tif (DECL_MUTABLE_P (decl))\n-\t\t  synthesize_tinfo_fn (decl);\n-\t\telse\n-\t\t  synthesize_method (decl);\n-\t\treconsider = 1;\n-\t      }\n-\n-\t    /* Catch new template instantiations.  */\n-\t    if (decl != TREE_VALUE (*p))\n-\t      continue;\n-\n-\t    if (TREE_ASM_WRITTEN (decl)\n-\t\t|| (DECL_SAVED_INSNS (decl) == 0\n-\t\t    && ! DECL_ARTIFICIAL (decl)))\n-\t      *p = TREE_CHAIN (*p);\n-\t    else if (DECL_INITIAL (decl) == 0)\n-\t      p = &TREE_CHAIN (*p);\n-\t    else if ((TREE_PUBLIC (decl) && ! DECL_COMDAT (decl))\n-\t\t     || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n-\t\t     || flag_keep_inline_functions)\n-\t      {\n-\t\tif (DECL_NOT_REALLY_EXTERN (decl))\n-\t\t  {\n-\t\t    DECL_EXTERNAL (decl) = 0;\n-\t\t    reconsider = 1;\n-\t\t    /* We can't inline this function after it's been\n-                       emitted.  We want a variant of\n-                       output_inline_function that doesn't prevent\n-                       subsequent integration...  */\n-\t\t    DECL_INLINE (decl) = 0;\n-\t\t    output_inline_function (decl);\n-\t\t    permanent_allocation (1);\n-\t\t  }\n-\n-\t\t*p = TREE_CHAIN (*p);\n-\t      }\n-\t    else\n-\t      p = &TREE_CHAIN (*p);\n-\t  }\n-      }\n-\n-    /* It's possible that some of the remaining inlines will still be\n-       needed.  For example, a static inline whose address is used in\n-       the initializer for a file-scope static variable will be\n-       needed.  Code in compile_file will handle this, but we mustn't\n-       pretend that there are no definitions for the inlines, or it\n-       won't be able to.\n+  /* We're done with the splay-tree now.  */\n+  if (priority_info_map)\n+    splay_tree_delete (priority_info_map);\n \n-       FIXME: This won't catch member functions.  We should really\n-       unify this stuff with the compile_file stuff.  */\n-    for (vars = saved_inlines; vars != NULL_TREE; vars = TREE_CHAIN (vars))\n-      {\n-\ttree decl = TREE_VALUE (vars);\n+  /* We're done with static constructors, so we can go back to \"C++\"\n+     linkage now.  */\n+  pop_lang_context ();\n \n-\tif (DECL_NOT_REALLY_EXTERN (decl)\n-\t    && !DECL_COMDAT (decl)\n-\t    && DECL_INITIAL (decl) != NULL_TREE)\n-\t  DECL_EXTERNAL (decl) = 0;\n-      }\n-  }\n+  /* Mark all functions that might deal with exception-handling as\n+     referenced.  */\n+  mark_all_runtime_matches ();\n \n   /* Now delete from the chain of variables all virtual function tables.\n      We output them all ourselves, because each will be treated\n      specially.  */\n+  walk_globals (vtable_decl_p, prune_vtable_vardecl, /*data=*/0);\n+\n+  /* We'll let wrapup_global_declarations handle the inline functions,\n+     but it will be fooled by DECL_NOT_REALL_EXTERN funtions, so we\n+     fix them up here.  */\n+  for (i = 0; i < saved_inlines_used; ++i)\n+    {\n+      tree decl = VARRAY_TREE (saved_inlines, i);\n+      \n+      if (DECL_NOT_REALLY_EXTERN (decl))\n+\tDECL_EXTERNAL (decl) = 0;\n+    }\n+\n+  /* We haven't handled non-local objects that don't need dynamic\n+     initialization.  Do that now.  */\n+  do\n+    {\n+      if (saved_inlines)\n+\treconsider \n+\t  |= wrapup_global_declarations (&VARRAY_TREE (saved_inlines, 0),\n+\t\t\t\t\t saved_inlines_used);\n+      reconsider \n+\t= walk_namespaces (wrapup_globals_for_namespace, /*data=*/0);\n+\n+      /* Static data members are just like namespace-scope globals.  */\n+      for (i = 0; i < pending_statics_used; ++i) \n+\t{\n+\t  tree decl = VARRAY_TREE (pending_statics, i);\n+\t  if (TREE_ASM_WRITTEN (decl))\n+\t    continue;\n+\t  import_export_decl (decl);\n+\t  if (DECL_NOT_REALLY_EXTERN (decl) && ! DECL_IN_AGGR_P (decl))\n+\t    DECL_EXTERNAL (decl) = 0;\n+\t}\n+      if (pending_statics)\n+\treconsider \n+\t  |= wrapup_global_declarations (&VARRAY_TREE (pending_statics, 0),\n+\t\t\t\t\t pending_statics_used);\n+    }\n+  while (reconsider);\n \n-  walk_vtables ((void (*) PROTO((tree, tree))) 0,\n-\t\tprune_vtable_vardecl);\n+  /* Now, issue warnings about static, but not defined, functions,\n+     etc.  */\n+  walk_namespaces (wrapup_globals_for_namespace, /*data=*/&reconsider);\n \n   finish_repo ();\n "}, {"sha": "f0e59bcc4a5ded7f62b030f564ecb783ae64ce07", "filename": "gcc/cp/error.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=0aafb128c06a4cbc4a6940c98fbfa4b4975398fd", "patch": "@@ -86,6 +86,11 @@ static char *scratch_firstobj;\n \t\t\t   OB_PUTCP (digit_buffer); } while (0)\n # define OB_UNPUT(N) obstack_blank (&scratch_obstack, - (N));\n \n+# define OB_END_TEMPLATE_ID() \t\t\t\t\t\t    \\\n+  ((obstack_next_free (&scratch_obstack) != obstack_base (&scratch_obstack) \\\n+    && obstack_next_free (&scratch_obstack)[-1] == '>')\t\t\t    \\\n+   ? OB_PUTC2 (' ', '>') : OB_PUTC ('>'))\n+\n # define NEXT_CODE(t) (TREE_CODE (TREE_TYPE (t)))\n \n enum pad { none, before, after };\n@@ -292,7 +297,7 @@ dump_type_real (t, v, canonical_name)\n \t      if (i < TREE_VEC_LENGTH (args)-1)\n \t        OB_PUTC2 (',', ' ');\n \t    }\n-\t  OB_PUTC ('>');\n+\t  OB_END_TEMPLATE_ID ();\n \t}\n       break;\n \n@@ -863,7 +868,8 @@ dump_decl (t, v)\n \t      }\n \t    if (len != 0)\n \t      OB_UNPUT (2);\n-\t    OB_PUTC2 ('>', ' ');\n+\t    OB_END_TEMPLATE_ID ();\n+\t    OB_PUTC (' ');\n \t  }\n \tnreverse(orig_args);\n \n@@ -905,7 +911,7 @@ dump_decl (t, v)\n \t    if (TREE_CHAIN (args))\n \t      OB_PUTC2 (',', ' ');\n \t  }\n-\tOB_PUTC ('>');\n+\tOB_END_TEMPLATE_ID ();\n       }\n       break;\n \n@@ -1199,7 +1205,7 @@ dump_function_name (t)\n \t\t}\n \t    }\n \t}\n-      OB_PUTC ('>');\n+      OB_END_TEMPLATE_ID ();\n     }\n }\n "}, {"sha": "db8fdd50db2f815bf07e33a8aac855b7e81e8564", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=0aafb128c06a4cbc4a6940c98fbfa4b4975398fd", "patch": "@@ -65,9 +65,9 @@ static int interface_strcmp PROTO((const char *));\n static int readescape PROTO((int *));\n static char *extend_token_buffer PROTO((const char *));\n static void consume_string PROTO((struct obstack *, int));\n-static void set_typedecl_interface_info PROTO((tree, tree));\n+static int set_typedecl_interface_info PROTO((tree *, void *));\n static void feed_defarg PROTO((tree, tree));\n-static int set_vardecl_interface_info PROTO((tree, tree));\n+static int set_vardecl_interface_info PROTO((tree *, void *));\n static void store_pending_inline PROTO((tree, struct pending_inline *));\n static void reinit_parse_for_expr PROTO((struct obstack *));\n static int *init_cpp_parse PROTO((void));\n@@ -1134,32 +1134,35 @@ interface_strcmp (s)\n   return 1;\n }\n \n-static void\n-set_typedecl_interface_info (prev, vars)\n-     tree prev ATTRIBUTE_UNUSED, vars;\n+static int\n+set_typedecl_interface_info (t, data)\n+     tree *t;\n+     void *data ATTRIBUTE_UNUSED;\n {\n-  tree id = get_time_identifier (DECL_SOURCE_FILE (vars));\n+  tree id = get_time_identifier (DECL_SOURCE_FILE (*t));\n   tree fileinfo = TIME_IDENTIFIER_FILEINFO (id);\n-  tree type = TREE_TYPE (vars);\n+  tree type = TREE_TYPE (*t);\n \n   CLASSTYPE_INTERFACE_ONLY (type) = TREE_INT_CST_LOW (fileinfo)\n-    = interface_strcmp (file_name_nondirectory (DECL_SOURCE_FILE (vars)));\n+    = interface_strcmp (file_name_nondirectory (DECL_SOURCE_FILE (*t)));\n+  return 0;\n }\n \n static int\n-set_vardecl_interface_info (prev, vars)\n-     tree prev, vars;\n+set_vardecl_interface_info (t, data)\n+     tree *t;\n+     void *data ATTRIBUTE_UNUSED;\n {\n-  tree type = DECL_CONTEXT (vars);\n+  tree type = DECL_CONTEXT (*t);\n \n   if (CLASSTYPE_INTERFACE_KNOWN (type))\n     {\n       if (CLASSTYPE_INTERFACE_ONLY (type))\n-\tset_typedecl_interface_info (prev, TYPE_MAIN_DECL (type));\n+\tset_typedecl_interface_info (&TYPE_MAIN_DECL (type), data);\n       else\n \tCLASSTYPE_VTABLE_NEEDS_WRITING (type) = 1;\n-      DECL_EXTERNAL (vars) = CLASSTYPE_INTERFACE_ONLY (type);\n-      TREE_PUBLIC (vars) = 1;\n+      DECL_EXTERNAL (*t) = CLASSTYPE_INTERFACE_ONLY (type);\n+      TREE_PUBLIC (*t) = 1;\n       return 1;\n     }\n   return 0;\n@@ -2461,7 +2464,14 @@ check_newline ()\n \n \t  main_input_filename = input_filename;\n \t  if (write_virtuals == 3)\n-\t    walk_vtables (set_typedecl_interface_info, set_vardecl_interface_info);\n+\t    {\n+\t      walk_globals (vtable_decl_p,\n+\t\t\t    set_vardecl_interface_info,\n+\t\t\t    /*data=*/0);\n+\t      walk_globals (vtype_decl_p,\n+\t\t\t    set_typedecl_interface_info,\n+\t\t\t    /*data=*/0);\n+\t    }\n \t}\n \n       extract_interface_info ();"}, {"sha": "12c8a95e2e741d096efa5b76994b94d990984916", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 119, "deletions": 4, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0aafb128c06a4cbc4a6940c98fbfa4b4975398fd", "patch": "@@ -50,15 +50,21 @@ extern struct obstack permanent_obstack;\n \n extern int lineno;\n extern char *input_filename;\n-struct pending_inline *pending_template_expansions;\n \n tree current_template_parms;\n HOST_WIDE_INT processing_template_decl;\n \n-tree pending_templates;\n+/* The PENDING_TEMPLATES is a TREE_LIST of templates whose\n+   instantiations have been deferred, either because their definitions\n+   were not yet available, or because we were putting off doing the\n+   work.  The TREE_PURPOSE of each entry is a SRCLOC indicating where\n+   the instantiate request occurred; the TREE_VALUE is a either a DECL\n+   (for a function or static data member), or a TYPE (for a class)\n+   indicating what we are hoping to instantiate.  */\n+static tree pending_templates;\n static tree *template_tail = &pending_templates;\n \n-tree maybe_templates;\n+static tree maybe_templates;\n static tree *maybe_template_tail = &maybe_templates;\n \n int minimal_parse_mode;\n@@ -5124,7 +5130,7 @@ instantiate_class_template (type)\n   input_filename = DECL_SOURCE_FILE (typedecl);\n \n   unreverse_member_declarations (type);\n-  type = finish_struct_1 (type, 0);\n+  finish_struct_1 (type, 0);\n   CLASSTYPE_GOT_SEMICOLON (type) = 1;\n \n   /* Clear this now so repo_template_used is happy.  */\n@@ -9421,6 +9427,115 @@ instantiate_decl (d)\n   return d;\n }\n \n+/* Run through the list of templates that we wish we could\n+   instantiate, and instantiate any we can.  */\n+\n+int\n+instantiate_pending_templates ()\n+{\n+  tree *t;\n+  int instantiated_something = 0;\n+  int reconsider;\n+  \n+  do \n+    {\n+      reconsider = 0;\n+\n+      t = &pending_templates;\n+      while (*t)\n+\t{\n+\t  tree srcloc = TREE_PURPOSE (*t);\n+\t  tree instantiation = TREE_VALUE (*t);\n+\n+\t  input_filename = SRCLOC_FILE (srcloc);\n+\t  lineno = SRCLOC_LINE (srcloc);\n+\n+\t  if (TREE_CODE_CLASS (TREE_CODE (instantiation)) == 't')\n+\t    {\n+\t      tree fn;\n+\n+\t      if (!TYPE_SIZE (instantiation))\n+\t\t{\n+\t\t  instantiate_class_template (instantiation);\n+\t\t  if (CLASSTYPE_TEMPLATE_INSTANTIATION (instantiation))\n+\t\t    for (fn = TYPE_METHODS (instantiation); \n+\t\t\t fn;\n+\t\t\t fn = TREE_CHAIN (fn))\n+\t\t      if (! DECL_ARTIFICIAL (fn))\n+\t\t\tinstantiate_decl (fn);\n+\t\t  if (TYPE_SIZE (instantiation))\n+\t\t    {\n+\t\t      instantiated_something = 1;\n+\t\t      reconsider = 1;\n+\t\t    }\n+\t\t}\n+\n+\t      if (TYPE_SIZE (instantiation))\n+\t\t/* If INSTANTIATION has been instantiated, then we don't\n+\t\t   need to consider it again in the future.  */\n+\t\t*t = TREE_CHAIN (*t);\n+\t      else \n+\t\tt = &TREE_CHAIN (*t);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (DECL_TEMPLATE_INSTANTIATION (instantiation)\n+\t\t  && !DECL_TEMPLATE_INSTANTIATED (instantiation))\n+\t\t{\n+\t\t  instantiation = instantiate_decl (instantiation);\n+\t\t  if (DECL_TEMPLATE_INSTANTIATED (instantiation))\n+\t\t    {\n+\t\t      instantiated_something = 1;\n+\t\t      reconsider = 1;\n+\t\t    }\n+\t\t}\n+\n+\t      if (!DECL_TEMPLATE_INSTANTIATION (instantiation)\n+\t\t  || DECL_TEMPLATE_INSTANTIATED (instantiation))\n+\t\t/* If INSTANTIATION has been instantiated, then we don't\n+\t\t   need to consider it again in the future.  */\n+\t\t*t = TREE_CHAIN (*t);\n+\t      else \n+\t\tt = &TREE_CHAIN (*t);\n+\t    }\n+\t}\n+      template_tail = t;\n+\n+      /* Go through the things that are template instantiations if we are\n+\t using guiding declarations.  */\n+      t = &maybe_templates;\n+      while (*t)\n+\t{\n+\t  tree template;\n+\t  tree fn;\n+\t  tree args;\n+\n+\t  fn = TREE_VALUE (*t);\n+\n+\t  if (DECL_INITIAL (fn))\n+\t    /* If the FN is already defined, then it was either already\n+\t       instantiated or, even though guiding declarations were\n+\t       allowed, a non-template definition was provided.  */\n+\t    ;\n+\t  else\n+\t    {\n+\t      template = TREE_PURPOSE (*t);\n+\t      args = get_bindings (template, fn, NULL_TREE);\n+\t      fn = instantiate_template (template, args);\n+\t      instantiate_decl (fn);\n+\t      reconsider = 1;\n+\t    }\n+\t\n+\t  /* Remove this entry from the chain.  */\n+\t  *t = TREE_CHAIN (*t);\n+\t}\n+      maybe_template_tail = t;\n+    } \n+  while (reconsider);\n+\n+  return instantiated_something;\n+}\n+\n /* Substitute ARGVEC into T, which is a TREE_LIST.  In particular, it\n    is an initializer list: the TREE_PURPOSEs are DECLs, and the\n    TREE_VALUEs are initializer values.  Used by instantiate_decl.  */"}, {"sha": "79fb8006ce885e45303ffd2dceb0cad5e73d8007", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=0aafb128c06a4cbc4a6940c98fbfa4b4975398fd", "patch": "@@ -381,7 +381,7 @@ get_tinfo_fn (type)\n   TREE_PUBLIC (d) = 1;\n   DECL_ARTIFICIAL (d) = 1;\n   DECL_NOT_REALLY_EXTERN (d) = 1;\n-  DECL_MUTABLE_P (d) = 1;\n+  SET_DECL_TINFO_FN_P (d);\n   TREE_TYPE (name) = copy_to_permanent (type);\n \n   pushdecl_top_level (d);"}, {"sha": "6acb50189ea91473aae6c57c935061595e5d663b", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=0aafb128c06a4cbc4a6940c98fbfa4b4975398fd", "patch": "@@ -2687,12 +2687,6 @@ pod_type_p (t)\n   return 1;\n }\n \n-/* A list of objects which have constructors or destructors\n-   which reside in the global scope.  The decl is stored in\n-   the TREE_VALUE slot and the initializer is stored\n-   in the TREE_PURPOSE slot.  */\n-tree static_aggregates_initp;\n-\n /* Return a 1 if ATTR_NAME and ATTR_ARGS denote a valid C++-specific\n    attribute for either declaration DECL or type TYPE and 0 otherwise.\n    Plugged into valid_lang_attribute.  */\n@@ -2773,9 +2767,7 @@ cp_valid_lang_attribute (attr_name, attr_args, decl, type)\n \t    (\"requested init_priority is reserved for internal use\");\n \t}\n \n-      static_aggregates_initp\n-\t= perm_tree_cons (initp_expr, decl, static_aggregates_initp);\n-\n+      DECL_INIT_PRIORITY (decl) = pri;\n       return 1;\n     }\n "}, {"sha": "ee0a029253aee103329502ac96acdb1807165c3d", "filename": "gcc/testsuite/g++.old-deja/g++.other/init12.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Finit12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Finit12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Finit12.C?ref=0aafb128c06a4cbc4a6940c98fbfa4b4975398fd", "patch": "@@ -0,0 +1,22 @@\n+// Build don't run:\n+// Special g++ Options: -O3\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+typedef int (*fp)();\n+ \n+struct S\n+{\n+  fp f;\n+};\n+\n+struct T\n+{\n+  static int f() {}\n+};\n+\n+static const S s = { &T::f };\n+\n+int main()\n+{\n+  return (*s.f)();\n+}"}, {"sha": "b1991f62106223a70403195a41b86751738afabe", "filename": "gcc/testsuite/g++.old-deja/g++.pt/link1.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flink1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flink1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flink1.C?ref=0aafb128c06a4cbc4a6940c98fbfa4b4975398fd", "patch": "@@ -0,0 +1,29 @@\n+// Build don't run:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+template <class T>\n+int f(T);\n+\n+template <class T>\n+struct S {\n+  template <class U>\n+  friend int f(U) { return 0; }\n+};\n+\n+int k = f(2);\n+\n+template <class T>\n+int g(T);\n+\n+int h = g(7);\n+\n+template <class T>\n+int g(T) {\n+  S<T> si;\n+  return 0;\n+}\n+\n+int main()\n+{\n+}\n+"}, {"sha": "172c3c3fe7d551cbb889f99a715f4e907101704a", "filename": "gcc/testsuite/g++.old-deja/g++.pt/static8.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fstatic8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aafb128c06a4cbc4a6940c98fbfa4b4975398fd/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fstatic8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fstatic8.C?ref=0aafb128c06a4cbc4a6940c98fbfa4b4975398fd", "patch": "@@ -0,0 +1,32 @@\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+int i;\n+\n+template <class T>\n+struct S {\n+  S() { ++i; }\n+\n+  virtual void g() {}\n+  virtual void f();\n+\n+  static S s;\n+};\n+\n+template <class T>\n+void S<T>::f() {\n+  s.f();\n+}\n+\n+S<int> si;\n+\n+template <class T>\n+S<T> S<T>::s;\n+\n+int main ()\n+{\n+  si.g();\n+  if (i != 2)\n+    return 1;\n+  else\n+    return 0;\n+}"}]}