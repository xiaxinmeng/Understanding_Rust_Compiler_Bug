{"sha": "d38d26be33aba5d4c12429478375a47c474124d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM4ZDI2YmUzM2FiYTVkNGMxMjQyOTQ3ODM3NWE0N2M0NzQxMjRkMg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-08-26T13:01:36Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-08-26T23:12:54Z"}, "message": "libstdc++: Avoid a move in std::function construction (LWG 2447)\n\nThis makes the std::function constructor use perfect forwarding, to\navoid an unnecessary move-construction of the target. This means we need\nto rewrite the _Function_base::_Base_manager::_M_init_functor function\nto use a forwarding reference, and so can reuse it for the clone\noperation.\n\nAlso simplify the SFINAE constraints on the constructor, by combining\nthe !is_same_v<remove_cvref_t<F>, function> constraint into the\n_Callable trait.\n\nSigned-off-by: Jonathan Wakely <jwakely@redhat.com>\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/std_function.h (_function_base::_Base_manager):\n\tReplace _M_init_functor with a function template using a\n\tforwarding reference, and a pair of _M_create function\n\ttemplates. Reuse _M_create for the clone operation.\n\t(function::_Decay_t): New alias template.\n\t(function::_Callable): Simplify by using _Decay.\n\t(function::function(F)): Change parameter to forwarding\n\treference, as per LWG 2447. Add noexcept-specifier. Simplify\n\tconstraints.\n\t(function::operator=(F&&)): Add noexcept-specifier.\n\t* testsuite/20_util/function/cons/lwg2774.cc: New test.\n\t* testsuite/20_util/function/cons/noexcept.cc: New test.", "tree": {"sha": "c771210d2741aae1783e86489d3211d55bfa592a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c771210d2741aae1783e86489d3211d55bfa592a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d38d26be33aba5d4c12429478375a47c474124d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d38d26be33aba5d4c12429478375a47c474124d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d38d26be33aba5d4c12429478375a47c474124d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d38d26be33aba5d4c12429478375a47c474124d2/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cf428bfd3ca967b3d135e311d3e391998a39335", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cf428bfd3ca967b3d135e311d3e391998a39335", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cf428bfd3ca967b3d135e311d3e391998a39335"}], "stats": {"total": 178, "additions": 132, "deletions": 46}, "files": [{"sha": "8dfbd11f71ec9ac9dea7b9cab1705af4a2817fc8", "filename": "libstdc++-v3/include/bits/std_function.h", "status": "modified", "additions": 64, "deletions": 46, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38d26be33aba5d4c12429478375a47c474124d2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38d26be33aba5d4c12429478375a47c474124d2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_function.h?ref=d38d26be33aba5d4c12429478375a47c474124d2", "patch": "@@ -127,7 +127,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t && __alignof__(_Functor) <= _M_max_align\n \t && (_M_max_align % __alignof__(_Functor) == 0));\n \n-\ttypedef integral_constant<bool, __stored_locally> _Local_storage;\n+\tusing _Local_storage = integral_constant<bool, __stored_locally>;\n \n \t// Retrieve a pointer to the function object\n \tstatic _Functor*\n@@ -142,32 +142,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    return __source._M_access<_Functor*>();\n \t}\n \n-\t// Clone a location-invariant function object that fits within\n+      private:\n+\t// Construct a location-invariant function object that fits within\n \t// an _Any_data structure.\n-\tstatic void\n-\t_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)\n-\t{\n-\t  ::new (__dest._M_access()) _Functor(__source._M_access<_Functor>());\n-\t}\n+\ttemplate<typename _Fn>\n+\t  static void\n+\t  _M_create(_Any_data& __dest, _Fn&& __f, true_type)\n+\t  {\n+\t    ::new (__dest._M_access()) _Functor(std::forward<_Fn>(__f));\n+\t  }\n \n-\t// Clone a function object that is not location-invariant or\n-\t// that cannot fit into an _Any_data structure.\n-\tstatic void\n-\t_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)\n-\t{\n-\t  __dest._M_access<_Functor*>() =\n-\t    new _Functor(*__source._M_access<const _Functor*>());\n-\t}\n+\t// Construct a function object on the heap and store a pointer.\n+\ttemplate<typename _Fn>\n+\t  static void\n+\t  _M_create(_Any_data& __dest, _Fn&& __f, false_type)\n+\t  {\n+\t    __dest._M_access<_Functor*>()\n+\t      = new _Functor(std::forward<_Fn>(__f));\n+\t  }\n \n-\t// Destroying a location-invariant object may still require\n-\t// destruction.\n+\t// Destroy an object stored in the internal buffer.\n \tstatic void\n \t_M_destroy(_Any_data& __victim, true_type)\n \t{\n \t  __victim._M_access<_Functor>().~_Functor();\n \t}\n \n-\t// Destroying an object located on the heap.\n+\t// Destroy an object located on the heap.\n \tstatic void\n \t_M_destroy(_Any_data& __victim, false_type)\n \t{\n@@ -188,12 +189,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      __dest._M_access<const type_info*>() = nullptr;\n #endif\n \t      break;\n+\n \t    case __get_functor_ptr:\n \t      __dest._M_access<_Functor*>() = _M_get_pointer(__source);\n \t      break;\n \n \t    case __clone_functor:\n-\t      _M_clone(__dest, __source, _Local_storage());\n+\t      _M_init_functor(__dest,\n+\t\t  *const_cast<const _Functor*>(_M_get_pointer(__source)));\n \t      break;\n \n \t    case __destroy_functor:\n@@ -203,9 +206,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return false;\n \t}\n \n-\tstatic void\n-\t_M_init_functor(_Any_data& __functor, _Functor&& __f)\n-\t{ _M_init_functor(__functor, std::move(__f), _Local_storage()); }\n+\ttemplate<typename _Fn>\n+\t  static void\n+\t  _M_init_functor(_Any_data& __functor, _Fn&& __f)\n+\t  noexcept(__and_<_Local_storage,\n+\t\t\t  is_nothrow_constructible<_Functor, _Fn>>::value)\n+\t  {\n+\t    _M_create(__functor, std::forward<_Fn>(__f), _Local_storage());\n+\t  }\n \n \ttemplate<typename _Signature>\n \t  static bool\n@@ -226,15 +234,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  static bool\n \t  _M_not_empty_function(const _Tp&)\n \t  { return true; }\n-\n-      private:\n-\tstatic void\n-\t_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)\n-\t{ ::new (__functor._M_access()) _Functor(std::move(__f)); }\n-\n-\tstatic void\n-\t_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)\n-\t{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }\n       };\n \n     _Function_base() = default;\n@@ -291,6 +290,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn std::__invoke_r<_Res>(*_Base::_M_get_pointer(__functor),\n \t\t\t\t     std::forward<_ArgTypes>(__args)...);\n       }\n+\n+      template<typename _Fn>\n+\tstatic constexpr bool\n+\t_S_nothrow_init() noexcept\n+\t{\n+\t  return __and_<typename _Base::_Local_storage,\n+\t\t\tis_nothrow_constructible<_Functor, _Fn>>::value;\n+\t}\n     };\n \n   // Specialization for invalid types\n@@ -329,19 +336,26 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,\n       private _Function_base\n     {\n+      // Equivalent to std::decay_t except that it produces an invalid type\n+      // if the decayed type is the current specialization of std::function.\n       template<typename _Func,\n-\t       typename _Res2 = __invoke_result<_Func&, _ArgTypes...>>\n+\t       bool _Self = is_same<__remove_cvref_t<_Func>, function>::value>\n+\tusing _Decay_t\n+\t  = typename __enable_if_t<!_Self, decay<_Func>>::type;\n+\n+      template<typename _Func,\n+\t       typename _DFunc = _Decay_t<_Func>,\n+\t       typename _Res2 = __invoke_result<_DFunc&, _ArgTypes...>>\n \tstruct _Callable\n \t: __is_invocable_impl<_Res2, _Res>::type\n \t{ };\n \n-      // Used so the return type convertibility checks aren't done when\n-      // performing overload resolution for copy construction/assignment.\n-      template<typename _Tp>\n-\tstruct _Callable<function, _Tp> : false_type { };\n+      template<typename _Cond, typename _Tp = void>\n+\tusing _Requires = __enable_if_t<_Cond::value, _Tp>;\n \n-      template<typename _Cond, typename _Tp>\n-\tusing _Requires = typename enable_if<_Cond::value, _Tp>::type;\n+      template<typename _Functor>\n+\tusing _Handler\n+\t  = _Function_handler<_Res(_ArgTypes...), __decay_t<_Functor>>;\n \n     public:\n       typedef _Res result_type;\n@@ -416,23 +430,26 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *  If @a __f is a non-NULL function pointer or an object of type @c\n        *  reference_wrapper<F>, this function will not throw.\n        */\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 2774. std::function construction vs assignment\n       template<typename _Functor,\n-\t       typename = _Requires<__not_<is_same<_Functor, function>>, void>,\n-\t       typename = _Requires<_Callable<_Functor>, void>>\n-\tfunction(_Functor __f)\n+\t       typename = _Requires<_Callable<_Functor>>>\n+\tfunction(_Functor&& __f)\n+\tnoexcept(_Handler<_Functor>::template _S_nothrow_init<_Functor>())\n \t: _Function_base()\n \t{\n-\t  static_assert(is_copy_constructible<_Functor>::value,\n+\t  static_assert(is_copy_constructible<__decay_t<_Functor>>::value,\n \t      \"std::function target must be copy-constructible\");\n-\t  static_assert(is_constructible<_Functor, _Functor>::value,\n+\t  static_assert(is_constructible<__decay_t<_Functor>, _Functor>::value,\n \t      \"std::function target must be constructible from the \"\n \t      \"constructor argument\");\n \n-\t  using _My_handler = _Function_handler<_Res(_ArgTypes...), _Functor>;\n+\t  using _My_handler = _Handler<_Functor>;\n \n \t  if (_My_handler::_M_not_empty_function(__f))\n \t    {\n-\t      _My_handler::_M_init_functor(_M_functor, std::move(__f));\n+\t      _My_handler::_M_init_functor(_M_functor,\n+\t\t\t\t\t   std::forward<_Functor>(__f));\n \t      _M_invoker = &_My_handler::_M_invoke;\n \t      _M_manager = &_My_handler::_M_manager;\n \t    }\n@@ -511,8 +528,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *  reference_wrapper<F>, this function will not throw.\n        */\n       template<typename _Functor>\n-\t_Requires<_Callable<typename decay<_Functor>::type>, function&>\n+\t_Requires<_Callable<_Functor>, function&>\n \toperator=(_Functor&& __f)\n+\tnoexcept(_Handler<_Functor>::template _S_nothrow_init<_Functor>())\n \t{\n \t  function(std::forward<_Functor>(__f)).swap(*this);\n \t  return *this;"}, {"sha": "a606104c84192eff44d46ba32e8efdaadfb8f499", "filename": "libstdc++-v3/testsuite/20_util/function/cons/lwg2774.cc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38d26be33aba5d4c12429478375a47c474124d2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Fcons%2Flwg2774.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38d26be33aba5d4c12429478375a47c474124d2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Fcons%2Flwg2774.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Fcons%2Flwg2774.cc?ref=d38d26be33aba5d4c12429478375a47c474124d2", "patch": "@@ -0,0 +1,31 @@\n+// { dg-do run { target c++11 } }\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+struct Funk\n+{\n+  Funk() = default;\n+  Funk(const Funk&) { ++copies; }\n+  Funk(Funk&&) { ++moves; }\n+\n+  void operator()() const { }\n+\n+  static int copies;\n+  static int moves;\n+};\n+\n+int Funk::copies = 0;\n+int Funk::moves = 0;\n+\n+int main()\n+{\n+  Funk e;\n+  // LWG 2774 means there should be no move here:\n+  std::function<void()> fc(e);\n+  VERIFY(Funk::copies == 1);\n+  VERIFY(Funk::moves == 0);\n+  // And only one move here:\n+  std::function<void()> fm(std::move(e));\n+  VERIFY(Funk::copies == 1);\n+  VERIFY(Funk::moves == 1);\n+}"}, {"sha": "635719874fbfd40b4f4c57b9db283c40b33e29ad", "filename": "libstdc++-v3/testsuite/20_util/function/cons/noexcept.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38d26be33aba5d4c12429478375a47c474124d2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Fcons%2Fnoexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38d26be33aba5d4c12429478375a47c474124d2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Fcons%2Fnoexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2Fcons%2Fnoexcept.cc?ref=d38d26be33aba5d4c12429478375a47c474124d2", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile { target c++11 } }\n+#include <functional>\n+\n+struct X\n+{\n+  void operator()(X*);\n+\n+  char bigness[100];\n+};\n+\n+using F = std::function<void(X*)>;\n+\n+static_assert( std::is_nothrow_constructible<F>::value, \"\" );\n+static_assert( std::is_nothrow_constructible<F, F>::value, \"\" );\n+static_assert( ! std::is_nothrow_constructible<F, F&>::value, \"\" );\n+static_assert( ! std::is_nothrow_constructible<F, const F&>::value, \"\" );\n+static_assert( std::is_nothrow_constructible<F, std::nullptr_t>::value, \"\" );\n+\n+static_assert( ! std::is_nothrow_constructible<F, X>::value, \"\" );\n+using R = std::reference_wrapper<X>;\n+static_assert( std::is_nothrow_constructible<F, R>::value, \"\" );\n+\n+\n+// The standard requires that construction from a function pointer type\n+// does not throw, but doesn't require that the construction is noexcept.\n+// Strengthening that noexcept for these types is a GCC extension.\n+static_assert( std::is_nothrow_constructible<F, void(*)(X*)>::value, \"\" );\n+// This is a GCC extension, not required by the standard:\n+static_assert( std::is_nothrow_constructible<F, void(&)(X*)>::value, \"\" );\n+// This is a GCC extension, not required by the standard:\n+static_assert( std::is_nothrow_constructible<F, void(X::*)()>::value, \"\" );\n+\n+auto c = [](X*){};\n+static_assert( std::is_nothrow_constructible<F, decltype(+c)>::value, \"\" );\n+// The standard allows this to throw, but as a GCC extenension we store\n+// closures with no captures in the std::function, so this is noexcept too:\n+static_assert( std::is_nothrow_constructible<F, decltype(c)>::value, \"\" );"}]}