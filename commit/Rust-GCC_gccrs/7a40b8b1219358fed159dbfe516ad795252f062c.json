{"sha": "7a40b8b1219358fed159dbfe516ad795252f062c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E0MGI4YjEyMTkzNThmZWQxNTlkYmZlNTE2YWQ3OTUyNTJmMDYyYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-06-13T14:50:26Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-13T14:50:26Z"}, "message": "bitmap.c (bitmap_and, [...]): Turn internal datastructure checks into checking asserts.\n\n\t* bitmap.c (bitmap_and, bitmap_and_into, bitmap_and_compl,\n\tbitmap_and_compl_into, bitmap_compl_and_into, bitmap_ior,\n\tbitmap_ior_into, bitmap_xor, bitmap_xor_into,\n\tbitmap_ior_and_compl, bitmap_ior_and_compl): Turn internal datastructure\n\tchecks into checking asserts.\n\t* rtlanal.c (find_reg_note): Use gcc_checking_assert.\n\t* tree-ssa-sccvn.c (VN_INFO): Likewise.\n\t* df-scan.c (df_reorganize_refs_by_reg_by_reg, df_install_ref,\n\tdf_ref_create_structure): Likewise.\n\t* alloc-pool.c (create_alloc_pool, empty_alloc_pool, pool_alloc,\n\tpool_free): Use gcc_checking_assert.\n\t* alias.c (get_alias_set): Likewise.\n\t* var-tracking.c (variable_htab_free, shared_hash_copy,\n\tcanonicalize_values_mark, variable_merge_over_cur): Likewise.\n\t* lto-streamer.c (bp_unpack_value): Likewise.\n\nFrom-SVN: r160681", "tree": {"sha": "aa39f92fe9688daf10109d15793c2c6e0bf4814a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa39f92fe9688daf10109d15793c2c6e0bf4814a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a40b8b1219358fed159dbfe516ad795252f062c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a40b8b1219358fed159dbfe516ad795252f062c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a40b8b1219358fed159dbfe516ad795252f062c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a40b8b1219358fed159dbfe516ad795252f062c/comments", "author": null, "committer": null, "parents": [{"sha": "0f398cb4885e76e6f43310eaf9765d7f6b87e9ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f398cb4885e76e6f43310eaf9765d7f6b87e9ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f398cb4885e76e6f43310eaf9765d7f6b87e9ea"}], "stats": {"total": 114, "additions": 66, "deletions": 48}, "files": [{"sha": "8fa56df307b1b7d6296930f50b9af75332c6dc46", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a40b8b1219358fed159dbfe516ad795252f062c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a40b8b1219358fed159dbfe516ad795252f062c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a40b8b1219358fed159dbfe516ad795252f062c", "patch": "@@ -1,3 +1,21 @@\n+2010-06-13  Jan Hubicka  <jh@suse.cz>\n+\n+\t* bitmap.c (bitmap_and, bitmap_and_into, bitmap_and_compl,\n+\tbitmap_and_compl_into, bitmap_compl_and_into, bitmap_ior,\n+\tbitmap_ior_into, bitmap_xor, bitmap_xor_into,\n+\tbitmap_ior_and_compl, bitmap_ior_and_compl): Turn internal datastructure\n+\tchecks into checking asserts.\n+\t* rtlanal.c (find_reg_note): Use gcc_checking_assert.\n+\t* tree-ssa-sccvn.c (VN_INFO): Likewise.\n+\t* df-scan.c (df_reorganize_refs_by_reg_by_reg, df_install_ref,\n+\tdf_ref_create_structure): Likewise.\n+\t* alloc-pool.c (create_alloc_pool, empty_alloc_pool, pool_alloc,\n+\tpool_free): Use gcc_checking_assert.\n+\t* alias.c (get_alias_set): Likewise.\n+\t* var-tracking.c (variable_htab_free, shared_hash_copy,\n+\tcanonicalize_values_mark, variable_merge_over_cur): Likewise.\n+\t* lto-streamer.c (bp_unpack_value): Likewise.\n+\n 2010-06-13  Richard Guenther  <rguenther@suse.de>\n \n \t* lto-streamer-in.c (lto_input_ts_type_tree_pointers):"}, {"sha": "08c38bf661601af8c749d541f088ff88c9ca9f7c", "filename": "gcc/alias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a40b8b1219358fed159dbfe516ad795252f062c/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a40b8b1219358fed159dbfe516ad795252f062c/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=7a40b8b1219358fed159dbfe516ad795252f062c", "patch": "@@ -713,7 +713,7 @@ get_alias_set (tree t)\n   t = TYPE_CANONICAL (t);\n   /* Canonical types shouldn't form a tree nor should the canonical\n      type require structural equality checks.  */\n-  gcc_assert (!TYPE_STRUCTURAL_EQUALITY_P (t) && TYPE_CANONICAL (t) == t);\n+  gcc_checking_assert (!TYPE_STRUCTURAL_EQUALITY_P (t) && TYPE_CANONICAL (t) == t);\n \n   /* If this is a type with a known alias set, return it.  */\n   if (TYPE_ALIAS_SET_KNOWN_P (t))\n@@ -1136,7 +1136,7 @@ record_set (rtx dest, const_rtx set, void *data ATTRIBUTE_UNUSED)\n \n   regno = REGNO (dest);\n \n-  gcc_assert (regno < VEC_length (rtx, reg_base_value));\n+  gcc_checking_assert (regno < VEC_length (rtx, reg_base_value));\n \n   /* If this spans multiple hard registers, then we must indicate that every\n      register has an unusable value.  */"}, {"sha": "ade1753c04657c3c6e0e7cc58109b8973df879b6", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a40b8b1219358fed159dbfe516ad795252f062c/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a40b8b1219358fed159dbfe516ad795252f062c/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=7a40b8b1219358fed159dbfe516ad795252f062c", "patch": "@@ -137,7 +137,7 @@ create_alloc_pool (const char *name, size_t size, size_t num)\n   struct alloc_pool_descriptor *desc;\n #endif\n \n-  gcc_assert (name);\n+  gcc_checking_assert (name);\n \n   /* Make size large enough to store the list header.  */\n   if (size < sizeof (alloc_pool_list))\n@@ -152,7 +152,7 @@ create_alloc_pool (const char *name, size_t size, size_t num)\n #endif\n \n   /* Um, we can't really allocate 0 elements per block.  */\n-  gcc_assert (num);\n+  gcc_checking_assert (num);\n \n   /* Allocate memory for the pool structure.  */\n   pool = XNEW (struct alloc_pool_def);\n@@ -201,7 +201,7 @@ empty_alloc_pool (alloc_pool pool)\n   struct alloc_pool_descriptor *desc = alloc_pool_descriptor (pool->name);\n #endif\n \n-  gcc_assert (pool);\n+  gcc_checking_assert (pool);\n \n   /* Free each block allocated to the pool.  */\n   for (block = pool->block_list; block != NULL; block = next_block)\n@@ -260,7 +260,7 @@ pool_alloc (alloc_pool pool)\n     desc->peak = desc->current;\n #endif\n \n-  gcc_assert (pool);\n+  gcc_checking_assert (pool);\n \n   /* If there are no more free elements, make some more!.  */\n   if (!pool->returned_free_list)\n@@ -328,19 +328,19 @@ pool_free (alloc_pool pool, void *ptr)\n   struct alloc_pool_descriptor *desc = alloc_pool_descriptor (pool->name);\n #endif\n \n-  gcc_assert (ptr);\n \n #ifdef ENABLE_CHECKING\n-  /* Check whether the PTR was allocated from POOL.  */\n-  gcc_assert (pool->id == ALLOCATION_OBJECT_PTR_FROM_USER_PTR (ptr)->id);\n+  gcc_assert (ptr\n+\t      /* Check if we free more than we allocated, which is Bad (TM).  */\n+\t      && pool->elts_free < pool->elts_allocated\n+\t      /* Check whether the PTR was allocated from POOL.  */\n+\t      && pool->id == ALLOCATION_OBJECT_PTR_FROM_USER_PTR (ptr)->id);\n \n   memset (ptr, 0xaf, pool->elt_size - offsetof (allocation_object, u.data));\n \n   /* Mark the element to be free.  */\n   ALLOCATION_OBJECT_PTR_FROM_USER_PTR (ptr)->id = 0;\n #else\n-  /* Check if we free more than we allocated, which is Bad (TM).  */\n-  gcc_assert (pool->elts_free < pool->elts_allocated);\n #endif\n \n   header = (alloc_pool_list) ptr;"}, {"sha": "aeaf2ea00e1ce779185a9cb2f83f8da10402e4b9", "filename": "gcc/bitmap.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a40b8b1219358fed159dbfe516ad795252f062c/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a40b8b1219358fed159dbfe516ad795252f062c/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=7a40b8b1219358fed159dbfe516ad795252f062c", "patch": "@@ -927,7 +927,7 @@ bitmap_and (bitmap dst, const_bitmap a, const_bitmap b)\n   /* Ensure that dst->current is valid.  */\n   dst->current = dst->first;\n   bitmap_elt_clear_from (dst, dst_elt);\n-  gcc_assert (!dst->current == !dst->first);\n+  gcc_checking_assert (!dst->current == !dst->first);\n   if (dst->current)\n     dst->indx = dst->current->indx;\n }\n@@ -975,8 +975,8 @@ bitmap_and_into (bitmap a, const_bitmap b)\n \t}\n     }\n   bitmap_elt_clear_from (a, a_elt);\n-  gcc_assert (!a->current == !a->first\n-\t      && (!a->current || a->indx == a->current->indx));\n+  gcc_checking_assert (!a->current == !a->first\n+\t\t       && (!a->current || a->indx == a->current->indx));\n }\n \n \n@@ -1119,7 +1119,7 @@ bitmap_and_compl (bitmap dst, const_bitmap a, const_bitmap b)\n       changed = true;\n       bitmap_elt_clear_from (dst, dst_elt);\n     }\n-  gcc_assert (!dst->current == !dst->first);\n+  gcc_checking_assert (!dst->current == !dst->first);\n   if (dst->current)\n     dst->indx = dst->current->indx;\n \n@@ -1175,8 +1175,8 @@ bitmap_and_compl_into (bitmap a, const_bitmap b)\n \t  b_elt = b_elt->next;\n \t}\n     }\n-  gcc_assert (!a->current == !a->first\n-\t      && (!a->current || a->indx == a->current->indx));\n+  gcc_checking_assert (!a->current == !a->first\n+\t\t       && (!a->current || a->indx == a->current->indx));\n   return changed != 0;\n }\n \n@@ -1470,8 +1470,8 @@ bitmap_compl_and_into (bitmap a, const_bitmap b)\n \t  b_elt = b_elt->next;\n \t}\n     }\n-  gcc_assert (!a->current == !a->first\n-\t      && (!a->current || a->indx == a->current->indx));\n+  gcc_checking_assert (!a->current == !a->first\n+\t\t       && (!a->current || a->indx == a->current->indx));\n   return;\n }\n \n@@ -1576,7 +1576,7 @@ bitmap_ior (bitmap dst, const_bitmap a, const_bitmap b)\n       changed = true;\n       bitmap_elt_clear_from (dst, dst_elt);\n     }\n-  gcc_assert (!dst->current == !dst->first);\n+  gcc_checking_assert (!dst->current == !dst->first);\n   if (dst->current)\n     dst->indx = dst->current->indx;\n   return changed;\n@@ -1615,7 +1615,7 @@ bitmap_ior_into (bitmap a, const_bitmap b)\n       a_elt = *a_prev_pnext;\n     }\n \n-  gcc_assert (!a->current == !a->first);\n+  gcc_checking_assert (!a->current == !a->first);\n   if (a->current)\n     a->indx = a->current->indx;\n   return changed;\n@@ -1693,7 +1693,7 @@ bitmap_xor (bitmap dst, const_bitmap a, const_bitmap b)\n   /* Ensure that dst->current is valid.  */\n   dst->current = dst->first;\n   bitmap_elt_clear_from (dst, dst_elt);\n-  gcc_assert (!dst->current == !dst->first);\n+  gcc_checking_assert (!dst->current == !dst->first);\n   if (dst->current)\n     dst->indx = dst->current->indx;\n }\n@@ -1750,7 +1750,7 @@ bitmap_xor_into (bitmap a, const_bitmap b)\n \t  a_elt = next;\n \t}\n     }\n-  gcc_assert (!a->current == !a->first);\n+  gcc_checking_assert (!a->current == !a->first);\n   if (a->current)\n     a->indx = a->current->indx;\n }\n@@ -1932,7 +1932,7 @@ bitmap_ior_and_compl (bitmap dst, const_bitmap a, const_bitmap b, const_bitmap k\n       changed = true;\n       bitmap_elt_clear_from (dst, dst_elt);\n     }\n-  gcc_assert (!dst->current == !dst->first);\n+  gcc_checking_assert (!dst->current == !dst->first);\n   if (dst->current)\n     dst->indx = dst->current->indx;\n \n@@ -2028,7 +2028,7 @@ bitmap_ior_and_into (bitmap a, const_bitmap b, const_bitmap c)\n     }\n \n  done:\n-  gcc_assert (!a->current == !a->first);\n+  gcc_checking_assert (!a->current == !a->first);\n   if (a->current)\n     a->indx = a->current->indx;\n   return changed;"}, {"sha": "353442923c2e0bb8835d43c3123156c8566ed662", "filename": "gcc/df-scan.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a40b8b1219358fed159dbfe516ad795252f062c/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a40b8b1219358fed159dbfe516ad795252f062c/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=7a40b8b1219358fed159dbfe516ad795252f062c", "patch": "@@ -1554,7 +1554,7 @@ df_reorganize_refs_by_reg_by_reg (struct df_ref_info *ref_info,\n \t      DF_REF_ID (ref) = offset++;\n \t      count++;\n \t      ref = DF_REF_NEXT_REG (ref);\n-\t      gcc_assert (offset < ref_info->refs_size);\n+\t      gcc_checking_assert (offset < ref_info->refs_size);\n \t    }\n \t}\n       if (include_uses)\n@@ -1566,7 +1566,7 @@ df_reorganize_refs_by_reg_by_reg (struct df_ref_info *ref_info,\n \t      DF_REF_ID (ref) = offset++;\n \t      count++;\n \t      ref = DF_REF_NEXT_REG (ref);\n-\t      gcc_assert (offset < ref_info->refs_size);\n+\t      gcc_checking_assert (offset < ref_info->refs_size);\n \t    }\n \t}\n       if (include_eq_uses)\n@@ -1578,7 +1578,7 @@ df_reorganize_refs_by_reg_by_reg (struct df_ref_info *ref_info,\n \t      DF_REF_ID (ref) = offset++;\n \t      count++;\n \t      ref = DF_REF_NEXT_REG (ref);\n-\t      gcc_assert (offset < ref_info->refs_size);\n+\t      gcc_checking_assert (offset < ref_info->refs_size);\n \t    }\n \t}\n       ref_info->count[regno] = count;\n@@ -2593,8 +2593,8 @@ df_install_ref (df_ref this_ref,\n       df->hard_regs_live_count[regno]++;\n     }\n \n-  gcc_assert (DF_REF_NEXT_REG (this_ref) == NULL\n-\t      && DF_REF_PREV_REG (this_ref) == NULL);\n+  gcc_checking_assert (DF_REF_NEXT_REG (this_ref) == NULL\n+\t\t       && DF_REF_PREV_REG (this_ref) == NULL);\n \n   DF_REF_NEXT_REG (this_ref) = head;\n \n@@ -2789,19 +2789,19 @@ df_ref_create_structure (enum df_ref_class cl,\n     {\n     case DF_REF_BASE:\n       this_ref = (df_ref) pool_alloc (problem_data->ref_base_pool);\n-      gcc_assert (loc == NULL);\n+      gcc_checking_assert (loc == NULL);\n       break;\n \n     case DF_REF_ARTIFICIAL:\n       this_ref = (df_ref) pool_alloc (problem_data->ref_artificial_pool);\n       this_ref->artificial_ref.bb = bb;\n-      gcc_assert (loc == NULL);\n+      gcc_checking_assert (loc == NULL);\n       break;\n \n     case DF_REF_REGULAR:\n       this_ref = (df_ref) pool_alloc (problem_data->ref_regular_pool);\n       this_ref->regular_ref.loc = loc;\n-      gcc_assert (loc);\n+      gcc_checking_assert (loc);\n       break;\n \n     case DF_REF_EXTRACT:\n@@ -2810,7 +2810,7 @@ df_ref_create_structure (enum df_ref_class cl,\n       DF_REF_EXTRACT_OFFSET (this_ref) = offset;\n       DF_REF_EXTRACT_MODE (this_ref) = mode;\n       this_ref->regular_ref.loc = loc;\n-      gcc_assert (loc);\n+      gcc_checking_assert (loc);\n       break;\n     }\n \n@@ -2880,7 +2880,7 @@ df_ref_record (enum df_ref_class cl,\n {\n   unsigned int regno;\n \n-  gcc_assert (REG_P (reg) || GET_CODE (reg) == SUBREG);\n+  gcc_checking_assert (REG_P (reg) || GET_CODE (reg) == SUBREG);\n \n   regno = REGNO (GET_CODE (reg) == SUBREG ? SUBREG_REG (reg) : reg);\n   if (regno < FIRST_PSEUDO_REGISTER)"}, {"sha": "216bc9536dfa709bc2c0a1a4748c12fd86c9ebdf", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a40b8b1219358fed159dbfe516ad795252f062c/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a40b8b1219358fed159dbfe516ad795252f062c/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=7a40b8b1219358fed159dbfe516ad795252f062c", "patch": "@@ -382,7 +382,7 @@ bp_unpack_value (struct bitpack_d *bp, unsigned nbits)\n   unsigned ix;\n \n   /* We cannot decode more bits than BITS_PER_BITPACK_WORD.  */\n-  gcc_assert (nbits > 0 && nbits <= BITS_PER_BITPACK_WORD);\n+  gcc_checking_assert (nbits > 0 && nbits <= BITS_PER_BITPACK_WORD);\n \n   /* Compute which word contains the next NBITS.  */\n   ix = bp_get_next_word (bp, nbits);"}, {"sha": "a26bf3b2272ee88b85ab05396eb5ccbb40feeee9", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a40b8b1219358fed159dbfe516ad795252f062c/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a40b8b1219358fed159dbfe516ad795252f062c/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=7a40b8b1219358fed159dbfe516ad795252f062c", "patch": "@@ -1694,7 +1694,7 @@ find_reg_note (const_rtx insn, enum reg_note kind, const_rtx datum)\n {\n   rtx link;\n \n-  gcc_assert (insn);\n+  gcc_checking_assert (insn);\n \n   /* Ignore anything that is not an INSN, JUMP_INSN or CALL_INSN.  */\n   if (! INSN_P (insn))"}, {"sha": "bb4a5172de8ec97769735eb3cbb88226badc5668", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a40b8b1219358fed159dbfe516ad795252f062c/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a40b8b1219358fed159dbfe516ad795252f062c/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=7a40b8b1219358fed159dbfe516ad795252f062c", "patch": "@@ -176,7 +176,7 @@ VN_INFO (tree name)\n {\n   vn_ssa_aux_t res = VEC_index (vn_ssa_aux_t, vn_ssa_aux_table,\n \t\t\t\tSSA_NAME_VERSION (name));\n-  gcc_assert (res);\n+  gcc_checking_assert (res);\n   return res;\n }\n "}, {"sha": "8786a7d784cbde4c3c672520a8f3bdec4c2967fd", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a40b8b1219358fed159dbfe516ad795252f062c/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a40b8b1219358fed159dbfe516ad795252f062c/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=7a40b8b1219358fed159dbfe516ad795252f062c", "patch": "@@ -1167,7 +1167,7 @@ variable_htab_free (void *elem)\n   variable var = (variable) elem;\n   location_chain node, next;\n \n-  gcc_assert (var->refcount > 0);\n+  gcc_checking_assert (var->refcount > 0);\n \n   var->refcount--;\n   if (var->refcount > 0)\n@@ -1370,7 +1370,7 @@ shared_hash_copy (shared_hash vars)\n static void\n shared_hash_destroy (shared_hash vars)\n {\n-  gcc_assert (vars->refcount > 0);\n+  gcc_checking_assert (vars->refcount > 0);\n   if (--vars->refcount == 0)\n     {\n       htab_delete (vars->htab);\n@@ -3066,7 +3066,7 @@ canonicalize_values_mark (void **slot, void *data)\n   if (!dv_is_value_p (dv))\n     return 1;\n \n-  gcc_assert (var->n_var_parts == 1);\n+  gcc_checking_assert (var->n_var_parts == 1);\n \n   val = dv_as_value (dv);\n \n@@ -3109,7 +3109,7 @@ canonicalize_values_star (void **slot, void *data)\n   if (!dv_onepart_p (dv))\n     return 1;\n \n-  gcc_assert (var->n_var_parts == 1);\n+  gcc_checking_assert (var->n_var_parts == 1);\n \n   if (dv_is_value_p (dv))\n     {\n@@ -3299,8 +3299,8 @@ canonicalize_values_star (void **slot, void *data)\n \n   /* Variable may have been unshared.  */\n   var = (variable)*slot;\n-  gcc_assert (var->n_var_parts && var->var_part[0].loc_chain->loc == cval\n-\t      && var->var_part[0].loc_chain->next == NULL);\n+  gcc_checking_assert (var->n_var_parts && var->var_part[0].loc_chain->loc == cval\n+\t\t       && var->var_part[0].loc_chain->next == NULL);\n \n   if (VALUE_RECURSED_INTO (cval))\n     goto restart_with_cval;\n@@ -3389,14 +3389,14 @@ variable_merge_over_cur (variable s1var, struct dfset_merge *dsm)\n   /* If the incoming onepart variable has an empty location list, then\n      the intersection will be just as empty.  For other variables,\n      it's always union.  */\n-  gcc_assert (s1var->n_var_parts\n-\t      && s1var->var_part[0].loc_chain);\n+  gcc_checking_assert (s1var->n_var_parts\n+\t\t       && s1var->var_part[0].loc_chain);\n \n   if (!onepart)\n     return variable_union (s1var, dst);\n \n-  gcc_assert (s1var->n_var_parts == 1\n-\t      && s1var->var_part[0].offset == 0);\n+  gcc_checking_assert (s1var->n_var_parts == 1\n+\t\t       && s1var->var_part[0].offset == 0);\n \n   dvhash = dv_htab_hash (dv);\n   if (dv_is_value_p (dv))"}]}